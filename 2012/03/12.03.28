00:00:38 <Enigmagic> > concatMap (\ x -> [x, x*2]) [1..5]
00:00:39 <lambdabot>   [1,2,2,4,3,6,4,8,5,10]
00:00:50 <ivanm> kallisti: which types?
00:00:54 <Enigmagic> kallisti: paste?
00:00:56 <lambda_zero_cool> Enigmagic++
00:01:10 <lambda_zero_cool> thanks :D
00:01:14 <Enigmagic> np:)
00:02:29 <ykm> > pure 1 == Just 1
00:02:29 <lambdabot>   True
00:02:30 <ion> Also note that (=<<) is concatMap for lists.
00:02:47 <ykm> :t pure
00:02:47 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
00:02:55 <ion> > do x <- [1..5]; [x, x*2]
00:02:56 <lambdabot>   [1,2,2,4,3,6,4,8,5,10]
00:04:48 <Ptival> so, I have this Windows user, using Haskell Platform, who can't cabal install repa because platform ships with base-4.3.1.0 and repa needs ==4.4
00:06:24 <mikeplus32> they'll need to upgrade their ghc manually, and cabal
00:06:34 <ion> cabal unpack repa, cd repa-…, vi repa.cabal, modify dependencies, cabal install
00:06:42 <mikeplus32> the HP is rather slow at updating
00:06:47 <Ptival> ion: is that safe? :)
00:07:15 <kallisti> instance MonadBase WD WD where liftBase = id
00:07:17 <kallisti> so if I do that
00:07:23 <kallisti> it clashes with a functional dependency
00:07:27 <mikeplus32> if repa doesn't use base 4.4+ features that should work, but repa is a cutting edge magical thing so it probably does
00:07:49 <Ptival> well, I'll explain that
00:07:54 <Ptival> thanks to you both
00:07:59 <ion> ptival: If it compiles, it probably works.
00:08:09 <kallisti> so how can I get my base monad to act like a base monad when it can't be a base monad.
00:08:12 <kallisti> ..
00:08:38 <Enigmagic> wut
00:09:02 <hpaste> kallisti pasted “aaaaah” at http://hpaste.org/66104
00:09:10 <kallisti> I'm messing with things I shouldn't be messing with.
00:09:18 <kallisti> instance MonadBase WD WD where liftBase = id
00:09:25 <kallisti> all because I want lifted-base. :_(
00:09:26 <Ptival> also, can't you get access to older versions of repa?
00:09:33 <Enigmagic> MonadBaseControl IO WD
00:09:47 <mikeplus32> yeah, Ptival, do cabal install repa-version for a specific version
00:09:48 <kallisti> oh
00:09:56 <mikeplus32> look at cabal info repa to see the available versions
00:10:03 <Ptival> mikeplus32: thanks
00:10:10 <Ptival> cabal info was what I needed
00:10:22 <kallisti> mikeplus32: er, I can't do that
00:10:24 <kallisti> that's already defined.
00:10:29 <kallisti> or something..
00:10:56 <Enigmagic> because you're using catch ?
00:11:17 <kallisti> Control.Exception.Lifted
00:11:19 <kallisti> catch
00:11:20 <kallisti> to be exact.
00:11:22 <Enigmagic> right
00:11:27 <Enigmagic> look at the context
00:11:39 <Enigmagic> it only works when base = IO
00:11:51 <kallisti> oh wait I see.
00:12:01 <Enigmagic> so either you need to not use catch or WD needs to be a transformer
00:12:04 <kallisti> well sort of.
00:12:22 <kallisti> how can WD be a transformer if it's just a monad stack over IO?
00:12:46 <Enigmagic> typical approach: define WDT as a transformer and WD as (WDT IO)
00:14:01 <Enigmagic> then make all of the instances for WDT but only ever use WD
00:15:11 <kallisti> well one problem is that the particular catch wasn't actually being used on WD
00:15:14 <kallisti> it was being used on the inner value.
00:15:39 <Enigmagic> missing a lift?
00:16:09 <kallisti> I don't know. this is honestly beyond me right now.
00:16:18 <kallisti> I should probably be doing this some other time.
00:16:58 <kallisti> what should I be lifting?
00:17:40 <Enigmagic> i don't know either
00:18:14 <kallisti> well...
00:18:23 <kallisti> if I'm using Control.Monad.State
00:18:29 <kallisti> is that going to have a MonadBase instance?
00:18:33 <Enigmagic> if you don't have a MonadBase instance that works with catch, you might just try using liftIO (if you have a MonadIO instance) instead
00:19:16 <Enigmagic> StateT s IO will have the correcdt MonadBase instance for catch
00:19:33 <kallisti> I think I can just rearrange the unwrapping of the newtype a bit to fix this..
00:20:35 <Veinor> bleh
00:20:41 <Veinor> apparently ghc and gold don't like each other
00:20:50 <Veinor> /usr/local/bin/ld: --hash-size=31: unknown option
00:21:14 <Enigmagic> that's the same error i ran into trying to get gold to work
00:22:04 <kallisti> so you're saying I shouldn't have instance MonadBase WD WD ?
00:22:16 <kallisti> if I try to do instance MonadBase IO WD  it doesn't work.
00:22:46 <Enigmagic> kallisti: if you want catch and friends from lifted-base to work WD needs to be a transformer
00:23:45 <kallisti> oh the problem with defining the MonadBase IO WD instance is that I didn't also change the MonadBaseControl instance.
00:23:56 <kallisti> I'm guessing I need to add a liftIO somewhere...
00:25:27 <Enigmagic> liftBase is basically liftIO if b = IO
00:25:50 <kallisti> yes
00:25:52 <kallisti> that's what I did.
00:26:15 <kallisti> oh wait
00:26:19 <kallisti> http://hackage.haskell.org/packages/archive/monad-control/0.2.0.3/doc/html/Control-Exception-Control.html
00:26:22 <kallisti> why don't I just use this.
00:26:32 <kallisti> and make a MonadControlIO instance.
00:26:42 <Enigmagic> that won't work with monad-control 0.3
00:26:55 <Enigmagic> since it's gone from 0.3
00:27:00 <kallisti> :(
00:30:16 <kallisti> I don't really see a point in exporting my transforming.
00:30:23 <kallisti> the entire point of the monad is to be a wrapper over IO.
00:30:45 <Enigmagic> i don't think it's actually required, i read the fundep backwards
00:31:03 <Enigmagic> i'm also getting tired :P
00:31:47 <kallisti> oh.
00:31:54 <kallisti> yeah it didn't feel like it was required.
00:32:03 <kallisti> but I decided to trust people with presumably more experience about these things.
00:32:13 <Cale> oh nice
00:32:24 <Enigmagic> that was probably a mistake :)
00:32:34 <kallisti> bah, the one time it's a bad idea.
00:32:38 <Cale> If a polynomial is known to have positive integer coefficients, then it is entirely determined by its values at two points
00:32:46 <Enigmagic> so fix the other instances and try again?
00:33:07 <kallisti> but fix how?
00:33:26 <kallisti> I'm trying to get MonadBaseControl IO WD
00:33:27 <kallisti> I believe
00:33:38 <Veinor> Cale: at two specific points, yeah
00:33:44 <Cale> yeah
00:33:45 <Enigmagic> gimme a minute, i'll see if i can get something to work
00:34:01 <kallisti> so StM is basically whatever state I have..
00:34:02 <Veinor> p(1) and p(p(1)+1) or something
00:34:16 <Cale> p(1) and p(p(1))
00:34:51 <Veinor> i wonder if you can extend that to work with negative coefficients
00:36:48 <kallisti> I wonder if I can just unwrap my monad and apply MonadBaseControl to the inside...
00:36:53 <kallisti> or utilize that rather.
00:37:44 <kallisti> I don't think I can.
00:38:14 <kallisti> oh wait maybe
00:39:57 <kallisti> basically I'd need to...
00:40:00 <kallisti> transform...
00:40:35 <kallisti> er nevermind
00:43:20 <kallisti> I'm not really understanding the benefit of this type family, when there was a much easier way to do the same thing in a previous version of monad.control...
00:45:03 <Enigmagic> it's shown to be a lot faster but harder to use
00:45:33 <kallisti> so far it's been nothing but a headache.
00:48:13 <kallisti> so yeah when I try the transformer it prompts me to turn on undecidable instances.
00:48:20 <kallisti> Illegal instance declaration for `MonadBaseControl b (WDT m)'
00:51:07 <kallisti> I could be explicitly writing error catching functions in a module
00:51:14 <kallisti> in the time it's taken to me stumbly clumsily through this.
00:51:24 <kallisti> ...*stumble
00:51:32 <Enigmagic> shouldn't need undecidable instances
00:51:35 <Enigmagic> hang on a minute tho
00:53:59 <nart> hi :)
00:54:20 <kallisti> hey
00:56:41 <kallisti> instance MonadBase b m => MonadBase b (WDT m) where liftBase = liftBaseDefault
00:56:47 <kallisti> this is what I'm currently doing for MonadBase
01:04:26 <kallisti> Enigmagic: well, I'm going to bed soon.
01:13:38 <kallisti> {-# LANGUAGE GeneralizedNewtypeDeriving, DeriveDataTypeable, TemplateHaskell, OverloadedStrings, NoMonomorphismRestriction,  ExistentialQuantification, MultiParamTypeClasses, TypeFamilies,  FlexibleInstances, UndecidableInstances #-}
01:14:13 <kallisti> o_O
01:14:19 <zhulikas> totally
01:14:42 <merijn> @quote cutting.edge
01:14:42 <lambdabot> edwardk says: {-# LANGUAGE time to pay the cutting edge typing features tax #-}
01:15:00 <kallisti> I just want... lifted... exception handling. :_(
01:15:40 <Enigmagic> at this point i'd just say to email Bas and ask for help, he's pretty good about it
01:15:56 <Veinor> 04:14:20          <lambdabot> edwardk says: {-# LANGUAGE time to pay the cutting edge typing features tax #-}
01:15:59 <Veinor> haha
01:16:33 <kallisti> I also need MonadTrans and MonadTransControl.
01:16:39 <kallisti> to get MonadBase and MonadBaseControl...
01:16:51 <kallisti> (that's only benefit of undecidable instances. I can continue debugging)
01:16:59 <Enigmagic> just for the default implementations
01:17:12 <Enigmagic> if you made it a transformer most of the rest would fall in place
01:17:16 <kallisti> I saw no defaults.
01:17:25 <kallisti> you mean:  instance MonadTrans WDT;
01:17:26 <kallisti> ?
01:17:33 <Enigmagic> defaultLiftBaseWith, etc
01:17:46 <kallisti> it is a transformer
01:17:50 <kallisti> I used defaultLiftBaseWith etc
01:17:54 <kallisti> it needs to be MonadTrans
01:18:12 <kallisti> and MonadTransControl.
01:18:44 <Enigmagic> then copy the stuff from here http://hackage.haskell.org/packages/archive/timeout-control/0.1/doc/html/src/System-Timeout-Control.html#line-53
01:19:08 <Enigmagic> 3 handcoded instances plus some derived instances
01:19:11 <kallisti> well lift is simple enough
01:19:37 <kallisti> lift = WDT . lift
01:20:01 <kallisti> but... MonadTransControl....
01:22:53 <kallisti> excuse me it's actually lift = WDT . lift . lift :P
01:23:19 <Enigmagic> kallisti: https://gist.github.com/cde906582a060f5793ab
01:24:34 <zhulikas> @type lift
01:24:35 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
01:28:10 <kallisti> :t void
01:28:11 <lambdabot> Not in scope: `void'
01:28:14 <kallisti> @hoogle void
01:28:14 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
01:28:14 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
01:28:15 <lambdabot> package void
01:31:37 <osa1> is there a way to create IO.Handle that actually doesn't write anything to anywhere?
01:32:08 <kallisti> you could use /dev/null, but that's not portable. :P
01:32:51 <osa1> kallisti: hmm that's a good idea, I'm on linux and I won't need to be portable for a while
01:33:10 <Enigmagic> kallisti: does that gist sample work at all? it type checks but i didn't test it
01:33:25 <kallisti> oh you linked me something..
01:34:09 <kallisti> oh, so you're bypassing the need for MonadTrans and MonadTransControl?
01:34:17 <Enigmagic> yeah
01:34:30 <kallisti> let me try.
01:37:07 <kallisti> huh...
01:37:07 <kallisti> yep
01:37:09 <kallisti> that compiles.
01:37:21 <kallisti> I knew there had to be a simple way
01:37:26 <kallisti> I just couldn't workthrough all the types..
01:38:37 <Enigmagic> crushes the mind a bit
01:38:39 <kallisti> well, thanks a lot. I'll let you know if it breaks.
01:38:46 <kallisti> but, if it compiled, I'm not too worried about it. :P
01:38:52 <Enigmagic> hopefully it does work :)
01:38:59 <Enigmagic> if not then email Bas and ask for help
01:39:17 <kallisti> definitely.
01:39:36 <kallisti> so basically the whole point of that was to concisely implement IO exception handling.
01:39:57 <kallisti> for this: https://github.com/kallisti-dev/hs-webdriver
01:40:23 <kallisti> so now I have a function called finallyClose that catches both monadic errors and IO errors and closes the session before rethrowing them
01:40:43 <kallisti> I'm sure library users will also find it useful.
01:41:19 <Enigmagic> sweet
01:41:22 <Enigmagic> well let me know if it breaks
01:41:45 <yasar> is Maybe a Monad? I thougt it was data type.
01:41:47 <Enigmagic> i'm curious in general, i'm sure i'll need a similar implementation for something
01:42:09 <Cale> yasar: all monads are data types
01:42:14 <kallisti> yasar: no worries, you were correct both times.
01:42:15 <Cale> or rather they are type constructors
01:42:40 <kallisti> yasar: another monad is linked lists.
01:42:44 <kallisti> which is also a data type.
01:42:58 <kallisti> so yes, it's possible to be both. in fact, fairly likely, I would say.
01:43:49 <kallisti> Enigmagic: oh and now I can also use that to make a sort of local-like withState
01:44:07 <kallisti> basically to reset the state locally, and set it back on any kind of exception.
01:44:32 <kallisti> basically always reset the state, regardless of what happens.
01:44:42 <yasar> So, when we say monads, are we talking about logically orderable data types?
01:44:56 <Enigmagic> yep
01:44:56 <kallisti> not by definition, no.
01:44:59 <kallisti> ...oh?
01:45:00 <Cale> "orderable" is a bit of a funny way to put it
01:45:08 <Enigmagic> kallisti: i mean, yep
01:45:19 <kallisti> I was thinking of partial orderings and total orderings...
01:45:19 <Enigmagic> capturing state/discarding/etc
01:45:21 <Cale> We're talking about type constructors m with implementations of   return :: a -> m a
01:45:31 <Cale> and (>>=) :: m a -> (a -> m b) -> m b
01:45:35 <Cale> satisfying some properties
01:46:04 <kallisti> yasar: a Monad is a typeclass whose instances have a definition for the functions Cale just listed, as well as obeying some properties (as Cale said)
01:46:10 <merijn> yasar: Monad is just another typeclass, similar to Eq and Ord
01:47:20 <merijn> :i Monad
01:47:22 <yasar> So, I would expect most of functors/applicatives to be also a monad correct?
01:47:24 <merijn> blah
01:47:33 <kallisti> yasar: many, yes.
01:47:35 <merijn> lambdabot needs info support
01:47:35 <Cale> yasar: not all, but many
01:47:37 <kallisti> all monads are functors.
01:47:42 <kallisti> for one.
01:47:48 <Cale> and all monads are applicatives
01:47:51 <Cale> but not the other way around
01:48:00 <merijn> yasar: Theoretically all monads are functors/applicatives, in practice there is no enforcement in the language atm
01:48:28 <merijn> (Mind you, functors and applicatives are not necessarily monads, they are more general)
01:49:12 <kallisti> Enigmagic: actually it would be pretty nice to have some kind of "improved state" monad with these state resetting features.
01:49:43 <kallisti> however it would require an IO base.
01:49:58 <kallisti> to do the IO bits
01:50:00 <yasar> maternalGrandfather p = mother p >>= father  --> Is this same as father (mother p)  ?
01:50:20 <kallisti> I guess what I'm actually describing is a StateErrorIO monad... basically what I have.
01:50:44 <merijn> yasar: Yes, assuming that you wrapped father with a case construct that checks for Nothing in the second example
01:50:58 <Enigmagic> kallisti: it doesn't need to be on top of IO unless you want exception handling (or other IO related business)
01:51:07 <kallisti> Enigmagic: yes, that's why it needs that.
01:51:30 <merijn> yasar: In other words >>= takes care of the error checking for Nothing in the first example and automatically returns Nothing if the input was Nothing without having to write the boilerplate code for it
01:51:43 <kallisti> because the improvement is that it comes with a "set local state" function that temporarily resets the state for a given action, and then always resets it, for any kind of error.
01:51:54 <kallisti> the State/Error subcase would leave out IO exception handling.
01:52:59 <t7> wikipedia is such a time sink...
01:53:05 <osa1> can anyone tell me the difference between this two: http://paste.pocoo.org/show/572429/
01:53:11 <t7> why do i allways end up on lesbian erotica
01:53:23 <Enigmagic> kallisti: i could see that being useful
01:53:28 <merijn> t7: Eh...odd personality defects? :p
01:53:46 <kallisti> Enigmagic: both the pure and IO-based versions could be useful, yes.
01:53:57 <kallisti> that's actually the problem. There are a lot of ways to rearrange this idea.
01:54:09 <quicksilver> osa1: you should really tell us the error.
01:54:21 <quicksilver> osa1: but I suspect you don't want the 'many1' in the first case
01:54:22 <kallisti> IO Error State, Error State, IO State, Maybe State, List State, State and LogicT
01:54:32 <quicksilver> osa1: just (letter <|> oneOf "-") `endBy1` eof
01:54:49 <quicksilver> osa1: but hang on no.
01:54:55 <kallisti> well actually those last cases are kind of useless.
01:54:56 <kallisti> I think.
01:55:04 <quicksilver> osa1: endBy1 is for multiple instances separated by eof, that's not useful ;0
01:55:30 <tzxn3> http://pastebin.com/scDvUHp5
01:55:33 <mauke> The paste scDvUHp5 has been copied to http://hpaste.org/66105
01:55:35 <Enigmagic> kallisti it's possible that Control.Monad.Trans.Control.control does a fair bit of it already
01:55:42 <osa1> quicksilver: actually that passes the type check but I think it's not what I want
01:56:20 <kallisti> osa1: another useful thing you may want to know about while using parser combinators is the <* operator
01:56:38 <kallisti> which works similarly to >> but returns the result of the left-hand action.
01:56:54 <kallisti> so that you don't have to bind "name" and then return it
01:57:16 <kallisti> you could just write many1 (letter <|> oneOf "-") <* eof
01:57:30 <tzxn3> I have no idea how to write the IO parts of a blackjack game
01:57:40 <osa1> kallisti: not in scope: <*, which package contains that?
01:57:41 <kallisti> tzxn3: with the IO monad of course.
01:57:44 <kallisti> osa1: Control.Applicative
01:57:56 <tzxn3> I've tried
01:58:01 <tzxn3> but it hasn't worked
01:58:34 <kallisti> osa1: <* is especially useful with parser combinators
01:58:37 <kallisti> but is useful in general.
01:58:58 <tzxn3> I honestly don't know where to begin
01:59:17 <kallisti> I wouldn't know where to point you.
01:59:32 <Enigmagic> i try to start at the beginning
01:59:56 <kallisti> where's that?
02:00:15 <Enigmagic> the starting point.
02:00:20 <osa1> kallisti: what's the syntax for importing just <* ? import Control.Applicative (<*) didn't work
02:00:30 <yasar> When in a do block, when first thing fail, will block stop progressing and return that value ?
02:00:40 <Enigmagic> osa1: add another set of parens
02:00:45 <Enigmagic> ((<*))
02:00:51 <osa1> thanks
02:00:53 <merijn> yasar: In a do block in the Maybe monad you mean? Yes
02:01:11 <Enigmagic> yasar: it will stop progressing and return Nothing
02:01:14 <merijn> Well, it will return Nothing at the end. For other monads it depends on the monad
02:01:22 <yasar> So it depends on the monad then?
02:01:41 <Enigmagic> yes
02:03:35 <merijn> yasar: Do notation is just syntacic sugar
02:03:37 <ClaudiusMaximus> tzxn3: what kind of input and output do you want from your program?  line-based text interface?
02:03:50 <tzxn3> yes
02:03:55 <merijn> @undo do {x <- foo; bar; xyzzy x}
02:03:56 <lambdabot> foo >>= \ x -> bar >> xyzzy x
02:04:39 <merijn> The behaviour of >>= and >> obviously depend on the monad they belong to.
02:05:30 <tzxn3> how can you tell which monad >>= belongs to?
02:05:36 <tzxn3> for a given isntnace?
02:05:44 <ClaudiusMaximus> tzxn3: look up getLine and putStrLn, i guess
02:05:53 <tzxn3> I ahve.
02:05:57 <merijn> tzxn3: Type signature of the do block/function it is in
02:06:06 <tzxn3> it's doing stuff based on those that I have a problem with
02:06:39 <merijn> tzxn3: Can you pastebin (hpaste.org) an example attempt (even if it doesn't compile at all), might be easier to tell you what's going wrong
02:06:45 <kallisti> Haskell infers types and has overloaded polymorphic operators, so... yeah.
02:06:53 <tzxn3> http://pastebin.com/scDvUHp5
02:06:53 <mauke> The paste scDvUHp5 has been copied to http://hpaste.org/66105
02:06:59 <tzxn3> that's all I've done so far
02:07:10 <tzxn3> no IO code, as I said, no idea where to begin
02:07:10 <kallisti> you can tell what >>= is being used by the values you're using with it.
02:07:28 <kallisti> > [1,2,3] >>= \x -> [x,-x]
02:07:29 <lambdabot>   [1,-1,2,-2,3,-3]
02:07:55 <kallisti> > Nothing >>= \x -> return (x+2)
02:07:56 <lambdabot>   Nothing
02:08:15 <merijn> tzxn3: Well, getLine returns IO String, so presumably you want to parse that string with something like "read :: String -> a" and hand it to a function
02:09:29 <kallisti> tzxn3: figuring out which >>= you're using is like figuring out which fmap you're using for functors, which == you're using with Eq, etc
02:09:50 <merijn> tzxn3: "getLine >>= return . doStuff . read" or "do { line <- getLine; return . doStuff . read $ line }" this is a do block with type IO a (where a is the return value of doStuff)
02:10:18 <tzxn3> aye
02:10:52 <merijn> It will read a line from stdin and return whatever doStuff does. If you want to use the result in some further computation you just write longer do blocks, or pass the result to other functions
02:11:16 <kallisti> spoilers: IO is a functor. you can just write that as fmap (doStuff . read) getLine
02:11:53 <kallisti> > fmap (+2) (Just 2)
02:11:54 <merijn> IO do blocks are really just imperative programming as you've done it in any other language (well, not entirely true. You can do things with do blocks that you cannot even think of doing in imperative languages)
02:11:54 <lambdabot>   Just 4
02:12:50 <kallisti> > fmap (+2) [1,2,3,4]
02:12:51 <lambdabot>   [3,4,5,6]
02:12:57 <merijn> tzxn3: In the trivial case you can just say "f- it, we'll do everything in IO" and write an essentially imperative program by just making all functions IO functions and writing assignments as "x <- y" and it will Just Work (TM)
02:13:13 <tzxn3> heh, cool
02:13:16 <merijn> Not proper haskell style maybe, but you can always start there and simplify from there
02:13:26 <kallisti> merijn: I doubt it will just work as /expected/
02:13:30 <kallisti> unless you know what's going on.
02:13:40 <merijn> kallisti: Well, obviously you need some clue
02:13:51 <kallisti> at the very least you need to know what needs binding and what doesn't
02:14:04 <kallisti> which hopefully is pretty simple.
02:14:12 <merijn> kallisti: Presumably if you have written imperative programs you already know this
02:14:18 <kallisti> hm?
02:14:31 <kallisti> imperative languages do not segregate their types into side-effectful actions and pure values.
02:14:37 <kallisti> the distinction is irrelevant.
02:14:57 <merijn> Sure, but if you shove everything in IO then you don't really care anymore and just write an imperative program
02:15:08 <kallisti> oh, sure. you can just return everything. :P
02:15:15 <yasar> So if monads are just data types, I could make my own data types monads too?
02:15:19 <kallisti> yep.
02:15:21 <merijn> yasar: Sure
02:15:34 <merijn> yasar: In fact, you can even use do-notation with your own data types if you do
02:15:35 <yasar> hmm, things are getting interesting :D
02:15:37 <DrSyzygy> yasar: whether they do anything USEFUL is another question. :-P
02:15:41 <kallisti> once you get into monad transformers this pretty common.
02:15:52 <kallisti> though you're not really "writing your own" so much as you are piecing together a bunch of other ones.
02:15:55 <kallisti> in a specific way.
02:16:07 <DrSyzygy> kallisti: We should really just make Haskell functors a proper calabi-yau category already... :-)
02:16:26 <kallisti> whoosh.
02:16:41 * kallisti turns around to watch the thing that just flew over his head.
02:16:45 <DrSyzygy> IIRC, this seems to be what monad transformers should do to make them work maximally nice: implement a braided category (i.e. monoidal category with commutator) that fulfills a few obvious axioms (making it calabi-ya)
02:17:02 <merijn> yasar: In fact, the fun thing is that if you make your own stuff a monad then you can just reuse a lot of existing generic monad code
02:17:10 * DrSyzygy - injecting ridiculous amounts of category theory into #haskell since 2008
02:17:31 <kallisti> DrSyzygy: publish your thoughts and perhaps they'll be in Haskell 2020. :D
02:17:35 <DrSyzygy> :-P
02:17:50 <DrSyzygy> Nah, I have better things to do than to get haskell-famous. There's tenure to pursue.
02:17:55 <quintessence> DrSyzygy: isn't the problem that many pairs of monads don't commute?
02:17:56 <merijn> You think "hmm, what I really need for my datatype is a function of type (a -> b -> c) -> m a -> m b -> m c", you go to Hoogle and find
02:17:59 <merijn> :t liftM
02:18:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:18:09 <merijn> err
02:18:11 <merijn> :t liftM2
02:18:12 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:18:36 <DrSyzygy> :t liftM2 (+) [1,2,3]
02:18:37 <lambdabot> forall a1. (Num a1) => [a1] -> [a1]
02:18:43 <DrSyzygy> > liftM2 (+) [1,2,3] [4,5]
02:18:44 <lambdabot>   [5,6,6,7,7,8]
02:19:04 <DrSyzygy> > liftM2 (+) [1,2,3] [10,20]
02:19:05 <lambdabot>   [11,21,12,22,13,23]
02:19:07 <DrSyzygy> There we go.
02:19:10 <DrSyzygy> that's what it does.
02:19:35 <kallisti> liftM2 (*) [a,b,c] [d,e] :: [Expr]
02:19:40 <kallisti> > liftM2 (*) [a,b,c] [d,e] :: [Expr]
02:19:41 <lambdabot>   [a * d,a * e,b * d,b * e,c * d,c * e]
02:20:32 <tzxn3> what's the difference between bind and fmap?
02:20:37 <merijn> :t fmap
02:20:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:20:43 <merijn> :t (>>=)
02:20:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:21:15 <merijn> tzxn3: With bind the function must return a value in the monad m, fmap implicitly wraps a return around the result
02:21:36 <tzxn3> ah, right
02:21:44 <Ptival> you can read fmap as (a -> b) -> (f a -> f b) too
02:21:50 <merijn> fmap f a == (a >>= return . f)
02:21:55 <yasar> object oriented languages advertise on code reusability, but as far as I can see, code reuse in haskell is easier than any other object oriented language that I know.
02:22:01 <merijn> yasar: Yes
02:22:10 <DrSyzygy> quintessence: Might well be.
02:22:27 <merijn> yasar: The downside is that it sometimes gets a bit abstract and confusing if you're a newcomer
02:22:29 <t7> how do i get ghc to spit out llvm bitcode ?
02:22:45 <tzxn3> I'd sort of picked up that they were very similar, but I wasn't sure how they differed precisely
02:22:49 <merijn> yasar: But in my experience immutability and type signatures help simplify understanding code without knowing every detail
02:23:59 <reinoud> Types.hs:3:8:
02:23:59 <reinoud>     Could not find module `Ix'
02:23:59 <reinoud>     It is a member of the hidden package `haskell98-2.0.0.1'.
02:24:24 <reinoud> how can i explicitly tell ghc to use haskell98 as a default package to include?
02:24:44 <reinoud> or do i have to modify all haskell files?
02:24:45 <tzxn3> hmm, is it that IO is just a special case of State, where the state is RealWorld?
02:25:01 <yasar> yes. Haskell feels like a language that is guaranteed to work as intended.
02:25:49 <nart> yasar: that exactly the same feeling i have =)
02:26:13 <reinoud> or is it that this ghc 7.4,1 uses `base' :-S and is not compatible?
02:26:17 <merijn> tzxn3: Maybe as a very beginner intuition. But you'll soon find it to be more wrong than useful, I think
02:26:39 <tzxn3> so how is it best to think of the IO monad?
02:26:50 <nart> yasar: once it compiles, my only concern is to check the program logic :)
02:27:26 <ion> Its bind operator combines two representations of actions into a new action that does both things sequentially upon execution.
02:27:27 <quicksilver> tzxn3: just as a notation for writing programs which do IO.
02:27:32 <tzxn3> heh
02:27:34 <merijn> tzxn3: Composable computations, which is I guess a bit abstract.
02:27:35 <yasar> well, if you define things correctly, everything is correct by definition :D
02:27:45 <tzxn3> burritos!
02:28:00 <ClaudiusMaximus> reinoud: ghc -package haskell98 -hide-package base    -- but possibly you want to update the code to use heirarchical modules like Data.Ix (haskell98 + base in same code = ambiguous Prelude pain)
02:28:16 <Ptival> an IO burrito
02:28:22 <merijn> tzxn3: For example, think of "forever :: m a -> m b" which is a computation that takes another computation as argument and then loops it indefinitely
02:29:00 <merijn> tzxn3: "a >>= b" (in IO) is just "given a computation a and a computation b, create a new computation that runs them in sequence"
02:30:05 <reinoud> Thanks ClaudiusMaximus :)
02:30:10 <reinoud> hehe now it gives:
02:30:15 <reinoud>    Could not find module `System.IO.Unsafe'
02:30:15 <reinoud>     It is a member of the hidden package `base'.
02:30:15 <reinoud> LOL
02:30:42 <reinoud> I guess it needs updating!
02:30:48 <nart> yasar: what i meant is that i could have defined things correctly, but i have to check if i e.x. follow a protocol correctly
02:30:58 <t7> is Andreas Rossberg on here?
02:31:10 <merijn> tzxn3: I think the point with IO is to replace "things that run" with "things that could be run by the haskell runtime if it decides to"
02:31:18 <tzxn3> aye
02:31:33 <ClaudiusMaximus> reinoud: perhaps fake haskell98 with something like Ix.hs with   module Ix(module Data.Ix) import Data.Ix
02:31:37 <Ptival> IO a is "an action that, when performed, will return a value of type a", the monad instance helps building bigger actions as compositions of smaller actions, and eventually the runtime gets this big "scheme" and can perform it
02:32:59 <reinoud> @hoogle List
02:32:59 <lambdabot> Data.List module Data.List
02:32:59 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
02:33:00 <lambdabot> Control.Monad.List module Control.Monad.List
02:33:00 <merijn> tzxn3: A practical example is this: suppose you had a language like C and you wanted to implement a short-circuiting boolean operator (like &&), but it was not built into the language. You cannot do this. In haskell it is simple because you can compose computations (IO actions) without actually running them.
02:33:35 <tzxn3> hmm
02:33:56 <reinoud>     Could not find module `Data.ByteString.Base'
02:33:56 <reinoud>     Perhaps you meant
02:33:56 <reinoud>       Data.ByteString.Lazy (from bytestring-0.9.2.1)
02:33:56 <reinoud>       Data.ByteString.Char8 (from bytestring-0.9.2.1)
02:33:56 <reinoud>       Data.ByteString.Unsafe (from bytestring-0.9.2.1)
02:33:57 <reinoud> hmmm
02:34:10 <ivanm> there is no such module as Data.ByteString.Base AFAIK
02:34:33 <opqdonut> merijn: hey, thanks, I'm gonna use that example on my lecture tomorrow
02:34:37 <ivanm> hayoo could confirm whether some random Hackage package defines it, but I doubt it
02:34:51 <merijn> tzxn3: "(&&) :: IO Bool -> IO Bool -> IO Bool" -> "a && b = do { bool <- a; if a then b else return bool }"
02:34:56 <reinoud> i guess they need Lazy or Char8
02:35:05 <tzxn3> that's pretty neat
02:35:15 <merijn> Of course this && is a bit pointless, unless a and/or b has side effects
02:35:27 <mgsloan1> http://www.mgsloan.com/mockup6.png <- dark themed type explanations mockup
02:35:31 <merijn> But still, it works with no hacking the language definition
02:35:44 <reinoud> @hoogle List.any
02:35:44 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
02:35:44 <lambdabot> Data.List any :: (a -> Bool) -> [a] -> Bool
02:35:44 <lambdabot> package anydbm
02:35:53 <mgsloan1> sans type contexts (lazy..)
02:36:01 <merijn> (You could do "then a", but then you might run a's side effects twice!)
02:36:56 <merijn> tzxn3: I hope that helped a bit :)
02:37:04 <opqdonut> merijn: ITYM if bool then ...
02:37:10 <tzxn3> thanks
02:37:18 <merijn> opqdonut: Damn
02:37:24 <opqdonut> :)
02:37:25 <merijn> Oh well :p
02:37:32 <merijn> Still clear enough, I hope
02:37:45 <reinoud> @hoogle Array
02:37:45 <lambdabot> Control.OldException ArrayException :: ArrayException -> Exception
02:37:45 <lambdabot> Control.Exception.Base data ArrayException
02:37:45 <lambdabot> Control.Exception data ArrayException
02:37:59 <reinoud> ugh
02:38:46 <reinoud> import Array
02:38:46 <reinoud> great....
02:38:53 * hackagebot blaze-html 0.4.3.3 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.4.3.3 (JasperVanDerJeugt)
02:38:56 <reinoud> is there a haskell98 to ~now list?
02:39:37 <t7> reinoud: i ran into these issues a little while ago
02:40:08 <reinoud> frustrating :(
02:40:14 <ClaudiusMaximus> http://www.haskell.org/haskellwiki/Haskell_2010#Changes_since_Haskell_.2798
02:40:38 <ivanm> wait, Array is still being used? :o
02:41:21 <ClaudiusMaximus> ivanm: i think reinoud has some old code that needs to be updated
02:41:39 <ivanm> hmmm, the Hierarchical Modules addendum's link doesn't work...
02:41:45 <ivanm> ClaudiusMaximus: it *really* must be old...
02:42:19 <reinoud> its code from say 2006
02:43:01 <reinoud> i am just trying to get it to work :)
02:43:46 <reinoud> or should i make the code so that the `ghc -package haskell98 -hide-package base'  works?
02:44:36 <ivanm> would re-implementing it make more sense?
02:44:39 <ivanm> (timewise, etc.)
02:44:49 <yasar>   :info IO says, it is Monad and Functor, it doesn't say applicative, but LYAH says otherwise.
02:45:02 <yasar> what's up with that_
02:45:07 <ivanm> yasar: you need to import Control.Applicative
02:45:12 <merijn> yasar: Applicatie instance may be defined in another module
02:45:17 <ivanm> that's where the Applicative instance is defined
02:45:58 <yasar> you were right. Thanks.
02:46:19 <reinoud> reimplementing code i didn't write is not my strongest part since i am still learning Haskell
02:46:48 <ivanm> reinoud: fair enough
02:46:58 <reinoud> Array is also used quite heavily in this code
02:47:05 <ivanm> Data.Array
02:47:27 <ClaudiusMaximus> reinoud: if you go +haskell98/-base, unsafePerformIO is still in Foreign (but this will only postpone the pain for a year or so, as next ghc version will remove it from there; System.IO.Unsafe is the preferred way)
02:48:03 <ivanm> and you might have issues with Num with ghc 7.4 (as I believe that breaks haskell98 as well)
02:48:05 <reinoud> i'll try to get it to work with base first
02:48:13 <yitz> reinoud: how many modules is it?
02:48:44 <reinoud> maybe 5 or so
02:48:52 <reinoud> @hoogle CPUTime
02:48:53 <lambdabot> System.CPUTime cpuTimePrecision :: Integer
02:48:53 <lambdabot> System.CPUTime module System.CPUTime
02:48:53 <lambdabot> System.Posix.Signals cpuTimeLimitExceeded :: Signal
02:48:57 <quicksilver> ivanm: only if you (a) implement your own Num instances or (b) write code which assumes that Num is Show.
02:49:19 <ivanm> quicksilver: right, but there's a fair amount of code that seems to fall under b)
02:49:32 <reinoud> @hoogle System
02:49:32 <lambdabot> System.Process system :: String -> IO ExitCode
02:49:32 <lambdabot> System.Cmd system :: String -> IO ExitCode
02:49:33 <lambdabot> package system-argv0
02:49:37 <yitz> reinoud: doesn't sound all that bad. you should be able to port it.
02:51:07 <yitz> ivanm: there may be a fair amount of programs that fall under (b), but even if so, each probably only does that in very few places.
02:51:18 <ivanm> true
02:51:41 <reinoud> ByteStringExtras.hs:20:9: Not in scope: `List.any'
02:51:42 <reinoud> ByteStringExtras.hs:22:12: Not in scope: `unsafeHead'
02:51:44 <reinoud> close...close
02:51:53 <reinoud> @hoogle List.any
02:51:54 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
02:51:54 <lambdabot> Data.List any :: (a -> Bool) -> [a] -> Bool
02:51:54 <lambdabot> package anydbm
02:52:33 <yitz> hmm head itself is already unsafe
02:53:07 <reinoud> euhhh how do i specify i want Data.List's any? by using Data.List.any ?
02:53:19 <reinoud> and what is the difference anyway?
02:53:32 <yitz> reinoud: those are the same
02:53:37 <ivanm> reinoud: import Data.List
02:53:40 <ivanm> but no, it's the same function
02:54:11 <reinoud>     Ambiguous occurrence `any'
02:54:11 <reinoud>     It could refer to either `Prelude.any',
02:54:11 <reinoud>                              imported from `Prelude' at ByteStringExtras.hs:1:8-23
02:54:11 <reinoud>                              (and originally defined in `GHC.List')
02:54:12 <reinoud>                           or `Data.ByteString.Lazy.any',
02:54:12 <reinoud>                              imported from `Data.ByteString.Lazy' at ByteStringExtras.hs:7:1-27
02:54:13 <reinoud>                           or `FPS.any',
02:54:13 <reinoud>                              imported from `Data.ByteString' at ByteStringExtras.hs:6:1-29
02:54:24 <yitz> if they were two different functions, you would import qualified Data.List and then use Data.List.any
02:54:24 <reinoud> hmpf
02:54:39 <yitz> reinoud: ahh. Data.ByteString should always be imported qualified
02:55:16 <ivanm> or very carefully with the Prelude functions not being imported
02:56:47 <reinoud> @hoogle unsafeHead
02:56:48 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
03:00:08 <reinoud> @hoogle Ix.index
03:00:08 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
03:00:08 <lambdabot> package sequential-index
03:00:52 <reinoud> @hoogle getArgs
03:00:52 <lambdabot> System.Environment getArgs :: IO [String]
03:00:52 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
03:01:44 <reinoud> @hoohle Control.Exception.catch
03:01:45 <lambdabot> Control.Exception.Base catch :: Exception e => IO a -> (e -> IO a) -> IO a
03:01:45 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
03:01:45 <lambdabot> Control.Exception catches :: IO a -> [Handler a] -> IO a
03:01:58 <reinoud> @hoogle  System.IO.Error.catch
03:01:58 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
03:01:58 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
03:01:58 <lambdabot> package maccatcher
03:03:22 <reinoud> LOL:
03:03:24 <reinoud>     Not in scope: Fast.map'
03:03:24 <reinoud>     Perhaps you meant `Fast.map' (imported from Data.ByteString)
03:03:34 <reinoud> well guess what i imported!
03:03:48 <mgsloan1> maybe map' vs map?
03:03:54 * hackagebot derive 2.5.7 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.7 (NeilMitchell)
03:04:07 <reinoud> import qualified Data.ByteString as Fast
03:04:07 <reinoud> import qualified ByteStringExtras as Fast
03:04:07 <reinoud> oh boy i found this in the code ... is this even valid?
03:04:14 <mgsloan1> yup
03:04:16 * ion cringes at approximating ‘ with the grave accent symbol.
03:04:35 <mgsloan1> yeah, that's probably one of the worst part of GHC errors
03:04:51 <ivanm> reinoud: as long as you don't try to use something that's exported by both, it's valid
03:05:26 <ion> ' is an approximation of both ‘ and ’ in the first place (because they wanted to avoid having extra keys in mechanical typewriters and extra codepoints in ASCII).
03:06:03 <ion> And of ′ in Haskell. :-)
03:06:24 <quicksilver> you can't really point the finger at ghc for that usage
03:06:28 <quicksilver> it's common in lots of programs
03:06:39 <ion> I point the finger at all of them. :-)
03:06:44 <quicksilver> it does annoy me, though, especially when it make thins hard to copy-paste.
03:07:15 <quicksilver> "man" has a habit of breaking source code excerpts from languages where single quotes mean something.
03:07:47 <ivanm> quicksilver: nah, copy-pasting code from pdfs is worse
03:07:59 <reinoud> @hoogle map'
03:07:59 <lambdabot> No results found
03:08:00 <ivanm> indentation is lost, quote characters are wrong, etc.
03:08:07 <ivanm> reinoud: it must be defined locally
03:08:37 <mgsloan1> double quotes around variables would be much less surprising for users
03:08:54 * hackagebot cmdargs-browser 0.1.1 - Helper to enter cmdargs command lines using a web browser  http://hackage.haskell.org/package/cmdargs-browser-0.1.1 (NeilMitchell)
03:09:07 <reinoud> its not defined locally :-/
03:09:52 <ivanm> reinoud: as in ghc can't find it?
03:10:09 <ivanm> because if it can, I'd be tempted to do ` :i map' ` in ghci
03:10:35 <ClaudiusMaximus> i think it might be from an ancient bytestring (pre-hackage)
03:10:50 <reinoud> :( i guess so
03:10:57 <reinoud> shall i just replace it with `map' then?
03:11:45 <ivanm> ClaudiusMaximus: ugh; I've come across something that used the old name for bytestrings :s
03:11:54 <reinoud> wow.. it links
03:13:01 <reinoud> ugh.. and now i need an example file...
03:14:48 <ivanm> anyone know what the API changes in deepseq are from 1.2 to 1.3 ?
03:16:43 <ivanm> is it just the (a -> b) instance being added?
03:18:14 <hpaste> ocaml pasted “A Simple Question About Concurrency” at http://hpaste.org/66107
03:20:41 <yasar> (+) for Int is defined as plusInt , but I can't find plusInt in hoogle.
03:21:30 <quicksilver> yasar: because it's a GHC internal function and hoogle doesn't, in most cases, index GHC internal source files.
03:21:54 <quicksilver> yasar: you can see it in http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html
03:23:01 <tzxn3> http://heh.fi/state-monad
03:23:08 <tzxn3> newtype State s a = S (s -> (a, s))
03:23:13 <yasar> hmm, ok. By they way, in which language the GHC written in?
03:23:13 <tzxn3> that does "S" mean?
03:23:39 <quicksilver> it's a constructor, tzxn3
03:23:41 <ClaudiusMaximus> ivanm: looks like it from the git log (possibly some SafeHaskell things too, though that might have been earlier? possibly instances for Data.Fixed.Fixed and Data.Version.Version were added after 1.2 too?)
03:23:42 <ion> Just a data constructor. It’s usually also called “State” but this might be clearer for newbies.
03:23:49 <quicksilver> yasar: mostly haskell.
03:24:00 <ivanm> ClaudiusMaximus: yeah, that's all that I could see
03:24:04 <ivanm> (I got the git log as well)
03:24:09 <quicksilver> yasar: some parts in Cmm, a few parts in C or assembly
03:24:12 <tzxn3> so State s a = State (s -> (a, s)) ?
03:24:21 <ion> Yeah, that’s equivalent.
03:24:33 <quicksilver> tzxn3: it's potentially confusing (although very common) to use the same name for Constructor and Type
03:24:34 <ivanm> so since I only a) create an instance of NFData, and b) use the list instance, then I should be able to use >= 1.1 && < 1.4
03:24:36 <Baikonur> "GHC is itself written in Haskell (in a technique known as bootstrapping), but the runtime system for Haskell, essential to run programs, is written in C and C--." says this in wikipedia
03:25:05 <quicksilver> Baikonur: which is less correct than my answer, if more detailed :P
03:25:08 <tzxn3> so State is the type and S is the constructor?
03:25:13 <quicksilver> yes.
03:25:25 <quicksilver> I assume that web page is using different names just to be clear about the difference.
03:26:05 <ivanm> gah! cabal-install won't let me use the version of a package I have installed locally!!! :@
03:27:25 <ClaudiusMaximus> ivanm: when i develop, i generally have to ghc-pkg unregister mylibrary && cabal install --solver=modular  (unless i really fancy bumping the version number every test compile)
03:28:03 <ivanm> I've just gone and appended an extra .1 onto the version string just to make it look "newer"
03:29:04 <reinoud> @info GLUT
03:29:04 <lambdabot> GLUT
03:29:08 <ivanm> preflex: seen sw17ch
03:29:08 <preflex>  sw17ch was last seen on #haskell 97 days, 15 hours, 29 minutes and 35 seconds ago, saying: rc?
03:29:10 <reinoud> @hoogle GLUT
03:29:10 <lambdabot> package GLUT
03:29:10 <lambdabot> Graphics.UI.GLUT.State glutVersion :: GettableStateVar String
03:29:10 <lambdabot> Graphics.UI.GLUT module Graphics.UI.GLUT
03:29:32 <ivanm> reinoud: IIUC, that's changed a fair amount since 2006 :s
03:30:04 <reinoud> i already feared so... the algorithm starts to run... no output yet
03:30:24 <reinoud> can't say its fast though :-/
03:30:30 <reinoud> and it is supposed to be :-P
03:32:06 <tzxn3> Maybe is a type and Just is a constructor?
03:32:23 <mm_freak> is there a simple way to add an SSH interface to a haskell program?  background:  i'm writing a server program and i'd like to provide a command line
03:32:25 <merijn> tzxn3: Well, "Maybe a" is a type, but otherwise, yes
03:32:34 <mm_freak> telnet would be easy, but i'd prefer SSH
03:32:43 <merijn> tzxn3: (Maybe is a type constructor. Applying Maybe to an existing type will create a new type)
03:33:01 <t7> that @info command seems a bit useless :)
03:34:07 <merijn> tzxn3: Normally you would say that "Maybe :: * -> *" where * is "the type of types" (usually called kind). So 1 :: Int and Int :: * and Maybe :: * -> *
03:34:16 <merijn> :k Maybe
03:34:17 <lambdabot> * -> *
03:34:40 <merijn> tzxn3: Similarly Either is a type constructor that takes two types as argument Either :: * -> * -> *
03:34:45 <merijn> :k Either
03:34:45 <lambdabot> * -> * -> *
03:35:09 <merijn> tzxn3: (If all that was confusing, just ignore it completely :p)
03:35:28 <ClaudiusMaximus> @info preflex: seen ClaudiusMaximus
03:35:29 <lambdabot> preflex : seen ClaudiusMaximus
03:35:45 <ClaudiusMaximus> aww...
03:35:48 <mm_freak> the 'ssh' library is hopelessly out of date =/
03:36:25 <mm_freak> i guess i'll just go with telnet for now
03:36:35 <mm_freak> or perhaps just provide a terminal interface and run the program through screen
03:36:39 <mm_freak> ugly =/
03:37:13 <Philonous_> mm_freak:  A workaround might be to create a user, set her login shell to "telnet localhost <application port>" and just use the openssh demon?
03:38:27 <mm_freak> Philonous_: i find that to be a potentially dangerous solution
03:38:28 <tzxn3> :p
03:38:39 <Botje> I guess using the subsystem interface provided by your ssh server is not an option?
03:38:51 <mm_freak> Botje: oh, good point…  i'll check
03:39:11 <merijn> Philonous_: If you do that why not just implement a terminal interface and set the login shell directly to your program?
03:39:13 <Botje> ssh foo@some_server -s your_fancy_app_name
03:39:19 <Philonous_> mm_freak:  Admittedly, I haven't thought this through. It was just an idea
03:39:34 <Botje> and/or set the shell of foo to your_fancy_app
03:39:41 <Philonous_> merijn:  Because the program would stop as soon as you log out?
03:40:18 <Philonous_> merijn:  Also, it would create new instances when you log on
03:40:25 <reinoud> AFAIR screen will continue to run even when logged of, or was that another tool
03:40:36 <Philonous_> reinoud:  Screen would do that, yes
03:40:37 <merijn> Not if you check for a running daemon and daemonize when not present
03:40:38 <mm_freak> Botje: great idea…  that could work indeed…  thanks a lot
03:40:38 <ClaudiusMaximus> isn't there some kind of socket thing on unix where you can use filesystem access controls?
03:40:51 <merijn> ClaudiusMaximus: Yes, unix sockets
03:41:02 <mm_freak> that's even better than providing an own SSH server =)
03:41:07 <mm_freak> i'll just use unix sockets
03:41:21 <Botje> mm_freak: that subsystem app could then connect to your local instance using unix sockets or telnet or http or pigeons, it's all good :)
03:42:25 <mm_freak> of course telnet doesn't support connecting to unix sockets…  don't make it too easy, have the user experience some pain, otherwise they'll be bored
03:42:28 <mm_freak> lol
03:45:08 <Botje> actually, supporting telnet is quite easy then
03:45:22 <Botje> just stuff the connecting program in an inetd rule
03:46:18 <mm_freak> yeah, thought about that
03:46:23 <mm_freak> i'm using xinetd anyway
03:47:07 <mm_freak> does anyone have experience with using mueval for the command line interface?
03:47:18 <mm_freak> it would be great if the commands were just haskell expressions
03:53:47 <mm_freak> hmm, mueval is too restricted…  i'll go with hint
03:53:59 * hackagebot sparse-lin-alg 0.3 - Small library for effective linear algebra on sparse matrices  http://hackage.haskell.org/package/sparse-lin-alg-0.3 (AlexeyAlekhin)
04:09:12 <Younder> Lispers are shaking from this 'new' multicore paradigm
04:09:47 <Younder> Luckily Haskellers are on top
04:10:41 <Younder> Thank you for a absolutely beautiful language
04:13:09 <rtharper> Younder: aren't you sweet ;)
04:15:05 <Younder> And I'm a hrd bitter man..
04:15:23 <worldsayshi> Hello all. I'm looking for a way to either have a Map generate keys for me or have some key generator for unique keys.
04:15:55 <bitonic> worldsayshi: [1..] is a great "unique key generator"
04:16:16 <merijn> worldsayshi: Why do you need a map if you're going to be generating arbitrary keys?
04:16:26 <bitonic> merijn: maybe he needs to tag things uniquely
04:18:06 <worldsayshi> Heh, probably is. Yeah, I need the map to store structures that are referenced by other structures via keys. A graph of sorts
04:18:32 <bitonic> worldsayshi: you can easily create a datatype like that: data MyMap v = MyMap {counter :: Int, map :: IntMap v}. 'insert' will have tipe 'insert :: v -> MyMap v -> (Int, MyMap v)', and will update the counter
04:18:34 <Younder> a dictionary
04:18:39 <liyang> bitonic: not if it's an [Int8]!
04:19:04 <worldsayshi> bitonic: Yup, thanks!
04:19:24 <ClaudiusMaximus> if you never delete, you could use Map.size for the new key?
04:19:36 <worldsayshi> I thought there may be an in built and more elegant solution
04:19:37 <bitonic> liyang: well it depends how many values you have :)
04:19:53 <worldsayshi> I do delete so size is probably a no go
04:19:55 <Younder> maps are non-functional!
04:20:28 <merijn> Younder: No they're not...
04:20:37 <Younder> At least in their current implementation.
04:20:46 <worldsayshi> Now I may end up with unused "key slots" but that doesn't really matter
04:20:57 <merijn> Younder: What do you mean by non-functional?
04:21:34 <reinoud> @hoogle print
04:21:35 <lambdabot> Prelude print :: Show a => a -> IO ()
04:21:35 <lambdabot> System.IO print :: Show a => a -> IO ()
04:21:35 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
04:21:49 <Younder> merijn, well the obvious, the modify global data
04:21:58 <quicksilver> Younder: no they don't.
04:22:03 <merijn> Younder: No
04:22:18 <Younder> I stand corrected
04:22:23 <merijn> Not the default Data.Map anyway
04:22:26 <bitonic> well that was a quick retreat :)
04:22:47 <merijn> Any map that does do that will have IO somewhere in it's functions and types
04:23:22 <Younder> No, I found it due to an error in my code. You are correct
04:24:32 <Younder> The IO bit occured
04:25:47 <Younder> Hate them pesky monads
04:27:55 <liyang> http://qkme.me/3oifa4
04:28:18 <reinoud> @hoogle flip
04:28:19 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
04:28:19 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
04:28:19 <lambdabot> package Flippi
04:28:59 <reinoud> @hoogle type
04:28:59 <lambdabot> Data.Typeable module Data.Typeable
04:29:00 <lambdabot> Foreign.C.Types module Foreign.C.Types
04:29:00 <lambdabot> System.Posix.Types module System.Posix.Types
04:29:06 <reinoud> @hoogle printtype
04:29:06 <lambdabot> No results found
04:29:26 <Younder> @hoole printf
04:29:26 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
04:29:26 <lambdabot> Text.Printf class PrintfArg a
04:29:26 <lambdabot> Text.Printf class PrintfType t
04:30:01 <reinoud> i have this function :     ; (print . length . flip isosurface dataset . fromIntegral . asInt) thresh
04:30:21 <reinoud> only i dont want to print the result of `length', i want to know the others
04:30:27 <reinoud> and just removing length won't work
04:30:30 <Younder> sounds like math
04:30:46 <t7> trace
04:30:52 <rtharper> Is there any way to parallelise "ghc --make"
04:30:57 <Younder> trace
04:30:59 <rtharper> like the -j flag for make
04:31:04 <reinoud> trace?
04:31:13 <rtharper> why are we saying trace
04:31:21 <t7> @hoogle trace
04:31:21 <lambdabot> Debug.Trace module Debug.Trace
04:31:21 <lambdabot> Debug.Trace trace :: String -> a -> a
04:31:21 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
04:31:24 <merijn> reinoud: I suspect the result of isosurface is not a member of the Show typeclass
04:31:48 <reinoud> its basicly [(a,b,c)]
04:31:58 <t7> > trace "haskell sucks" 123
04:31:59 <lambdabot>   Not in scope: `trace'
04:32:02 <merijn> reinoud: Are a, b and c member of Show?
04:32:09 <Younder> You have 'Real wold Haskell' right, so trace
04:32:11 <merijn> If not, then neither is [(a,b,c)]
04:32:23 <Younder> world
04:32:36 <merijn> And if it is not an instance of Show, then obviously print won't work
04:32:37 <liyang> rtharper: there's ghc -M which'll give you a Makefile of module dependencies...
04:32:49 <rtharper> liyang: ah thanks, that's close, I guess =)
04:33:43 <t7> bitonic: how does haskell handle a = b; b = a ?
04:33:58 <t7> in terms of type checking
04:34:14 <Younder> You all compile GHC via GCC?
04:34:25 <ClaudiusMaximus> :t let a = b ; b = a in (a,b)
04:34:26 <lambdabot> forall t t1. (t, t1)
04:34:36 <Younder> How queer
04:34:45 <merijn> Younder: How do you mean?
04:34:57 <reinoud>     ; (print . length . trace . flip isosurface dataset . fromIntegral . asInt) threi
04:35:01 <Younder> for better performance
04:35:02 <quicksilver> rtharper: no.
04:35:04 <reinoud> is that the way to show the type at that point?
04:35:08 <ClaudiusMaximus> (i didn't expect that!  dmr?)
04:35:12 <t7> ah so fix gets a fresh type?
04:35:19 <merijn> Younder: No? I use the default which compiles directly...
04:35:32 <rtharper> quicksilver: Wah.  Any reason why not?
04:35:40 <quicksilver> rtharper: coding is hard. They haven't written the code.
04:36:00 <rtharper> quicksilver: ohokay.  That's fine.  I didn't know if there was a more fundamental reason =)
04:36:04 <quicksilver> rtharper: some projects use makefiles which call ghc -c on each file, and you can make -j those.
04:36:20 <quicksilver> rtharper: however that turns out to be quite slow because ghc --make has the huge advantage of only loading .hi files once.
04:36:37 <Younder> the via-gcc does kick some ass
04:36:42 <quicksilver> rtharper: so a parallel --make, or a batch mode for compile which caches .hi files, would be great.
04:37:29 <quicksilver> rtharper: http://hackage.haskell.org/trac/ghc/ticket/910
04:37:33 <quicksilver> rtharper: not that that contains much info
04:38:37 <rtharper> ah, no, just that people are talking about it still as of 7 months ago, and I'm not hteonly one who wants it
04:38:45 <liyang> Careful with GHC 7.4.1 though. I seem to remember that if you run ghc --make with different flags than you originally invoked ghc -c with, it'll recompile all the modules. (It considers (some) flags part of the input.)
04:38:58 <rtharper> only using 7.0.4 anyway
04:39:02 * rtharper only uses the Haskell Platform.
04:39:38 <rtharper> Cutting edgeness usually just gets in the way for me =p
04:40:06 <quicksilver> and the blood makes a mess of the keyboard.
04:41:54 <ClaudiusMaximus> t7: i'm not sure why ghc doesn't unify the types of a and b there at all, it's different from...
04:41:55 <rtharper> quicksilver: indeed, and with a aluminium unibody mac
04:41:57 <ClaudiusMaximus> :t fix (\(a,b) -> (b,a))
04:41:58 <lambdabot> forall t. (t, t)
04:42:01 <rtharper> that means blood in the logic board =/
04:42:08 * quicksilver nods
04:42:20 <quicksilver> makes a nice smell when it warms up, though. That's a compensation.
04:42:57 <rtharper> We must have different olfactory aesthetics...
04:43:17 <Younder> forall means for all by i't nature it is inefficient
04:44:54 <Younder> alwys limit yourself to the minimum subgroup!
04:48:15 <reinoud> why is :t (isosurface dataset . fromIntegral . asInt) "100" illegal
04:48:25 <reinoud> where as the same code in a compiled .s is legal?
04:48:52 <reinoud> <interactive>:1:13:
04:48:53 <reinoud>     Couldn't match expected type `Word8'
04:48:53 <reinoud>                 with actual type `IO (Dataset Word8)'
04:48:53 <reinoud>     In the first argument of `isosurface', namely `dataset'
04:48:53 <reinoud>     In the first argument of `(.)', namely `isosurface dataset'
04:48:53 <reinoud>     In the expression: isosurface dataset . fromIntegral . asInt
04:48:57 <ClaudiusMaximus> reinoud: you had a flip up there?
04:49:40 <reinoud> this is the source line that gets accepted by ghc:
04:49:43 <reinoud> (print . length . flip isosurface dataset . fromIntegral . asInt) "100"
04:49:47 <ClaudiusMaximus> right, flip
04:49:50 <ClaudiusMaximus> :t flip
04:49:50 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:50:00 <ClaudiusMaximus> :t Prelude.flip
04:50:01 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:50:32 <reinoud> (flip isosurface dataset . fromIntegral . asInt) "100"
04:50:32 <reinoud> <interactive>:64:18:
04:50:32 <reinoud>     Couldn't match expected type `Array XYZ Word8'
04:50:32 <reinoud>                 with actual type `IO (Dataset Word8)'
04:50:32 <reinoud>     In the second argument of `flip', namely `dataset'
04:50:32 <reinoud>     In the first argument of `(.)', namely `flip isosurface dataset'
04:50:32 <reinoud>     In the expression: flip isosurface dataset . fromIntegral . asInt
04:50:37 <reinoud> that puzzles me!
04:50:57 <reinoud> looks like the compiler understands it but ghci doesnt
04:51:14 <merijn> reinoud: Oh, that can easily happen
04:51:15 <ClaudiusMaximus> could be different names in scope, and/or shadowing
04:51:44 <reinoud> :'(
04:51:56 <merijn> ClaudiusMaximus: The code in GHCI might also have some less context making type inference unsuccesfuly
04:52:01 <merijn> -y
04:52:03 <reinoud> would be nice if ghci could just load a .hs file like one compiles it and then use the same stuff
04:52:05 <ClaudiusMaximus> > let a = "ouch" in do a <- a ; return (toUpper a)
04:52:06 <lambdabot>   "OUCH"
04:52:31 <ClaudiusMaximus> > toUpper "ouch"
04:52:32 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:52:32 <lambdabot>         against inferred type...
04:53:04 <ykm> > map toUpper $ "ouch"
04:53:05 <lambdabot>   "OUCH"
04:53:22 <merijn> ykm: Dollar is redundant there
04:53:39 <flux> oh, that wasn't a political statement..
04:53:50 <ykm> oh...yep
04:54:59 <vodik> > toUpper <$> "ouch"
04:54:59 <lambdabot>   "OUCH"
04:56:52 <kstt> functors rock
04:59:38 <t7> :t (<?>)
04:59:39 <lambdabot> Not in scope: `<?>'
04:59:44 <t7> :t (<$>)
04:59:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:00:22 <t7> > "moo" :: Functor f => f
05:00:22 <lambdabot>   `f' is not applied to enough type arguments
05:00:22 <lambdabot>  Expected kind `*', but `f' has...
05:01:05 <quicksilver> "Functor f => f Char" perhaps, but that won't work
05:01:16 <quicksilver> string literals are not abitrary functor literals :)
05:01:40 <elliott> > pure 'm' <|> pure 'o' <|> pure 'o' :: String
05:01:41 <lambdabot>   "moo"
05:02:25 <t7> list is a functor?
05:02:29 <quicksilver> yes indeed.
05:02:57 <reinoud>    Couldn't match expected type `IO a0'
05:02:57 <reinoud>                 with actual type `[Triangle b]'
05:03:28 <reinoud>     ; print ((flip isosurface dataset . fromIntegral . asInt) thresh)
05:03:37 <reinoud> gives a long long error message
05:03:51 <reinoud> will that just say that print [Triangle b] is not defined?
05:05:04 <quicksilver> no, if it was saying that it would say something about missing Show instances.
05:05:09 <t7> :t (<*>)
05:05:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:05:21 <elliott> reinoud: it's saying that you have a [Triangle b], but are treating it as an IO action.
05:05:39 <elliott> I doubt that line is the actual one it's complaining about...
05:05:46 <elliott> hpaste the full error message incl. the expression it lists
05:05:57 <vodik> reinoud: use return?
05:05:59 <t7> > return (+ 1) <*> [1,2,3]
05:06:00 <lambdabot>   [2,3,4]
05:06:15 <dabblego> prefer pure there, or just use <$>
05:06:35 <reinoud> type  TriangleVertex a  = (a,a,a)
05:06:35 <reinoud> type  Triangle a        = (TriangleVertex a, TriangleVertex a, TriangleVertex a)
05:07:00 <vodik> reinoud: the error says it expects IO. either make it pure or use return
05:07:01 <reinoud> and since 'a' in this case is a float, i'd say why doesn't it print it as such?
05:07:23 <reinoud> @hoogle return
05:07:24 <lambdabot> Prelude return :: Monad m => a -> m a
05:07:24 <lambdabot> Control.Monad return :: Monad m => a -> m a
05:07:24 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
05:07:58 <ykm> why does haskell has return when it doesnt breaks away from the function?\
05:08:12 <quicksilver> bad choice of name ykm
05:08:24 <quicksilver> at least, a bad choice w.r.t people who've come from other languages.
05:08:39 <t7> > [ return 1, Just 2]
05:08:40 <lambdabot>   [Just 1,Just 2]
05:08:59 <t7> hindley millner is so clever
05:10:04 <reinoud> so now... how to create a Show for a Triangle :-/
05:10:17 <t7> deriving (Show) :)
05:10:29 <Cale> It's a good choice of name, it's just that it doesn't have the control semantics which it has in other languages and is simply a function and not a keyword.
05:10:31 <merijn> reinoud: If all arguments of Triangle constructors are show instances then you can derive it automatically
05:11:23 <vodik> ykm: return is a function, not a keyword
05:11:40 <Cale> ykm: for IO actions,  return v  is the action which does nothing, but returns the value v when executed.
05:12:25 <vodik> reinoud: deriving (Show)?
05:12:29 <ykm> because of haskell's lazy nature?
05:12:38 <Cale> nothing to do with evaluation
05:12:41 <vodik> no, i really has nothing to do with lazyiness
05:12:49 <vodik> it has to do with monads
05:13:15 <vodik> > return True :: Maybe Bool
05:13:16 <lambdabot>   Just True
05:13:24 <Cale> Yeah, each monad defines return separately
05:13:32 <vodik> > return True :: [Bool]
05:13:33 <lambdabot>   [True]
05:13:38 <vodik> > return True :: Either Bool
05:13:38 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
05:13:43 <vodik> > return True :: Either Bool Int
05:13:44 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:13:44 <lambdabot>         against inferred type ...
05:13:47 <vodik> > return True :: Either Bool Integer
05:13:48 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
05:13:48 <lambdabot>         against inf...
05:13:53 <Cale> wrong way around
05:13:57 <vodik> > return True :: Either Bool Bool
05:13:58 <lambdabot>   Right True
05:13:58 <vodik> ah
05:14:44 <vodik> ykm: Maybe, Either, [] are all monads. return just takes a value and shoves it inside the monad
05:15:37 <t7> you see... monads are like burritos
05:15:50 <t7> ... its like a space suit
05:17:01 <Cale> eek
05:17:09 <reinoud> should i set that deriving (Show) after the type definition?
05:17:10 <Cale> don't say "shoves it inside the monad" :)
05:17:34 <vodik> okay
05:17:53 <Cale> If you're thinking of monadic types as container types, return v makes a container containing just the value v
05:18:01 <t7> 'places it lovingly inside'
05:18:05 <reinoud> type  TriangleVertex a  = (a,a,a) deriving (Show)
05:18:06 <Cale> (which is *kinda* like that)
05:18:07 <reinoud> hehe
05:18:27 <vodik> but it doesn't have to be a container
05:18:49 <Cale> If you're thinking of monadic types as types of computations, then return v makes a computation which when executed, does nothing but produces v as its result.
05:19:22 <ykm> so a function can do multiple returns?
05:20:00 <elliott> "return" is nothing like imperative prorgamming return
05:20:05 <elliott> it doesn't break the chain of execution, or anything
05:20:09 <elliott> it's a really bad name :)
05:20:14 <Cale> It's not a bad name
05:20:25 <vodik> ykm: its simply a function.
05:20:27 <Cale> It's just not used to denote the same thing as in some other programming languages :)
05:20:28 <vodik> @src return
05:20:28 <lambdabot> Source not found. You untyped fool!
05:20:39 <vodik> i guess it wouldn't
05:20:50 <ykm> hmm..ok
05:21:04 <vodik> > return (return True) :: Maybe (Maybe Bool)
05:21:05 <lambdabot>   Just (Just True)
05:21:19 <vodik> > return (return True) :: Either Int (Maybe Bool)
05:21:20 <lambdabot>   Right (Just True)
05:21:32 <Cale> You *will* see it used near the end of do-blocks, because the result of a do block is the result of the last computation in it
05:21:53 <Cale> and so return can be used there to determine which result you want to return from the whole do-block
05:22:09 <Cale> (by doing nothing, and returning the given value)
05:22:35 <Cale> but if you put it in the middle of a do-block, it does nothing
05:22:52 <Cale> (and it returns a value which you can bind, but if that's all you're doing, you should probably just use let)
05:24:09 * hackagebot augeas 0.6.1 - A Haskell FFI wrapper for the Augeas API  http://hackage.haskell.org/package/augeas-0.6.1 (JudeNagurney)
05:25:18 <Cale> In an imperative language, every procedure definition behaves as if secretly wrapped up in a call-with-current-continuation, and return lets you call that continuation with a given value. There's none of that magic in Haskell's do blocks or definitions :)
05:25:49 <t7> undo { return 1; return 2 }
05:25:52 <t7> @undo { return 1; return 2 }
05:25:52 <lambdabot>  Parse error at "{" (column 1)
05:25:57 <t7> @undo do { return 1; return 2 }
05:25:57 <lambdabot> return 1 >> return 2
05:26:00 <Cale> (but there can be different magic, depending on what the monad is :)
05:26:10 <ivanm> @undo do { return 1; return 2 }
05:26:10 <lambdabot> return 1 >> return 2
05:26:43 <t7> i thought it used   return 1 >>= _ -> return 2
05:27:33 <reinoud> what is the difference between `type Triangle a' and `data Triangle a' ?
05:28:22 <yasar> when I say this:   (:) <$> (+1) <*> pure []  , what is the value of pure [] ?
05:28:36 <elliott> pure []
05:28:41 <elliott> depends which Applicative you're using as to the exact value
05:28:49 <elliott> since pure is a class method
05:29:09 * hackagebot grm 0.1.0 - grm grammar converter  http://hackage.haskell.org/package/grm-0.1.0 (BrettLetner)
05:29:16 <yasar> then what is the endvalue of whole expression?
05:29:59 <elliott> oh, wiat
05:30:05 <elliott> you're using the (->) applicative there
05:30:07 <elliott> didn't notice, sorry :)
05:30:08 <t7> what do i use for sum types in javascript?
05:30:11 <t7> whats the pattern?
05:30:17 <elliott> yasar: for the function applicative instance, pure is const
05:30:24 <merijn> :t (:) <$> (+1) <*> pure []
05:30:25 <lambdabot> forall a. (Num a) => a -> [a]
05:30:27 <elliott> so pure [] is const [], i.e. (\x -> [])
05:30:41 <dabblego> t7: my colleague church-encode them
05:30:43 <elliott> reinoud: the former defines a type synonym, the latter a data type
05:30:52 <dabblego> (I watch in amusement)
05:31:03 <elliott> reinoud: "type Triangle a = SomeExistingType" vs. "data Triangle a = Cons1 Field1 Field2 | Cons2 Field1 | ..."
05:31:12 <elliott> the former is just a handy alias, the latter actually defines a new type
05:31:19 <elliott> for instance, type String = [Char], so a String is literally a list of Chars
05:32:36 <reinoud> i tried this but eeuuhhh ghc is not digging it ;)
05:32:38 <reinoud> instance Show TriangleVertex (a,b,c) where
05:32:38 <reinoud>         PutStr "("+Show a + "," + Show b + "," + Show c + ")"
05:33:07 <merijn> reinoud: putrStr is an IO function
05:33:13 <vodik> :t (<*> pure [])
05:33:13 <lambdabot> forall (f :: * -> *) b a. (Applicative f) => f ([a] -> b) -> f b
05:33:16 <ykm> > pure 1 == Just 1
05:33:17 <lambdabot>   True
05:33:18 <vodik> :t (<*> [])
05:33:19 <lambdabot> forall a b. [a -> b] -> [b]
05:33:36 <elliott> reinoud: well...
05:33:43 <merijn> reinoud: Wait, why are all the show's capitalised? That's wrong regardless
05:33:43 <elliott> reinoud: for a start, you've got the syntax all wrong
05:33:45 <reinoud> merijn: the idea is to make the list printable
05:33:55 <elliott> reinoud: firstly, it should be Show (TriangleVertex a b c), most likely
05:33:59 <elliott> wait
05:34:04 <elliott> actually i have no idea what you are doing
05:34:05 <vodik> and putStr
05:34:07 <elliott> please show your type definition
05:34:07 <merijn> reinoud: Show is "a -> String", not "a -> IO ()"
05:34:11 <vodik> and putStr has no buiness in Show
05:34:19 <ykm> pure and Just are equivalent?
05:34:24 <elliott> ykm: for Maybe, yes
05:34:24 <vodik> ykm: no
05:34:26 <magicman> Hiyas. What is the preferred library for JSON manipulation (both reading and writing) these days?
05:34:30 <elliott> magicman: aeson i think
05:34:36 <ion> merijn: We should have a ShowIO for that!
05:34:46 <vodik> > pure 1 == [1]
05:34:47 <lambdabot>   True
05:34:52 <magicman> elliott: Cheers!
05:34:52 <vodik> > pure 1 == Left 1
05:34:53 <lambdabot>   False
05:34:55 <vodik> > pure 1 == Right 1
05:34:56 <lambdabot>   True
05:34:59 <reinoud> type  TriangleVertex a  = (a,a,a)
05:35:00 <reinoud> instance Show (TriangleVertex (a,b,c)) where
05:35:00 <reinoud>         PutStr "("+Show a + "," + Show b + "," + Show c + ")"
05:35:00 <merijn> ion: Why? print already works with any instance of Show
05:35:05 <elliott> reinoud: ok, well firstly, you can't do that
05:35:11 <elliott> you can't give an instance for a type synonym like that
05:35:19 <elliott> define a data type: data TriangleVertex a = TriangleVertex a a a
05:35:20 <ion> merijn: (That was a joke.)
05:35:30 <elliott> reinoud: secondly, it's "Show T" for your type T, you don't pattern-match there
05:35:31 <reinoud> i dont know why print can just convert it to IO
05:35:43 <elliott> reinoud: thirdly, you need to define _values_ in that instance block
05:35:44 <vodik> :t show
05:35:45 <lambdabot> forall a. (Show a) => a -> String
05:35:47 <elliott> but you've tried to put an expression there
05:35:51 <merijn> reinoud: "print" is just "putStrLn . show"
05:35:53 <vodik> reinoud: show returns a string
05:35:56 <merijn> :t putStrLn
05:35:57 <lambdabot> String -> IO ()
05:35:57 <danr> :t print
05:35:58 <lambdabot> forall a. (Show a) => a -> IO ()
05:35:59 <vodik> reinoud: not an IO action
05:36:01 <merijn> :t show
05:36:01 <lambdabot> forall a. (Show a) => a -> String
05:36:05 <elliott> reinoud: instance Show (TriangleVertex a) where show (TriangleVertex a b c) = ...your code...
05:36:30 <elliott> reinoud: your expression, apart from trying to use putStr which you can't, also has incorrect uppercase Shows and uses (+) to append strings (it's (++))... but anyway
05:36:46 <elliott> reinoud: if you use TriangleVertex a like that type synonym, you don't need an instance, by the way
05:36:51 <elliott> (a,b,c) already has a Show instance
05:37:10 <elliott> what you should probably do is "data TriangleVertex a = TriangleVertex a a a deriving (Show)", which will define a _new_ data type (not a synonym) and derive a Show instance for you.
05:37:46 <vodik> you don't need to manually derive Show 99% of the time
05:38:02 <vodik> explictly, i should say
05:38:29 <mm_freak> i have a thread with 'x `finally` y'…  i would expect y to get executed when the thread is killed via killThread, but that doesn't happen
05:38:32 <mm_freak> am i missing something?
05:38:37 <elliott> reinoud: but, for future reference... haskell is case sensitive :P
05:38:43 <quicksilver> wrong finally, mm_freak ?
05:39:10 * hackagebot pec 0.2.0 - pec embedded compiler  http://hackage.haskell.org/package/pec-0.2.0 (BrettLetner)
05:39:23 <yasar> I don't get it, how come: let y = (:) <$> (+2) <*> (\x -> [x + 1]) and y 10 give me [12,11] ?
05:40:49 <hpaste> “Ertugrul Söylemez” pasted “Server failing to clean up properly” at http://hpaste.org/66113
05:40:54 <quicksilver> :t (:) <$> (+2) <*> (\x -> [x+1])
05:40:54 <vodik> > let y = liftA2 (:) (+2) (\x -> [x + 1]) in y 12
05:40:55 <lambdabot> forall a. (Num a) => a -> [a]
05:40:55 <lambdabot>   [14,13]
05:41:01 <mm_freak> quicksilver: see paste…  i don't think this is wrong
05:41:11 <mm_freak> i know that the killThread gets executed
05:41:17 <quicksilver> mm_freak: I can't tell from that paste :)
05:41:31 <quicksilver> mm_freak: I meant, are you using the Prelude finally, or the 'new' Control.Exception finally
05:41:37 <reinoud> data TriangleVertexPrint a = TriangleVertex a deriving (Show)
05:41:38 <reinoud> data TrianglePrint a = Triangle a deriving (Show)
05:41:39 <mm_freak> the new one
05:41:41 <reinoud> so this should work?
05:41:43 <mm_freak> import Control.Exception (finally)
05:41:54 <quicksilver> mm_freak: then I don't know :(
05:42:10 <reinoud> Haskell has a steep learning curve :-S
05:43:20 <quicksilver> reinoud: what you're writing doesn't look like you understand.
05:43:22 <mm_freak> what is killThread?  isn't it just a throwTo?
05:43:34 <quicksilver> reinoud: you don't need special data types for printing
05:43:43 <mm_freak> according to the documentation it is
05:43:47 <quicksilver> reinoud: so I don't know why you'd call the types '....Print'
05:43:55 <quicksilver> mm_freak: I think you need JaffaCake
05:44:14 <reinoud> because i got:
05:44:17 <reinoud>     Multiple declarations of `TriangleVertex'
05:44:17 <reinoud> fg
05:44:27 <merijn> reinoud: What are you reading to learn haskell?
05:44:34 <vodik> reinoud: it would really help to see your code
05:44:51 <vodik> reinoud: do you have multiple declarations of TriangleVertex?
05:45:01 <reinoud> i am reading http://book.realworldhaskell.org/read/getting-started.html, but haven't progressed far with it yet
05:45:29 <vodik> reinoud: show us your code
05:45:51 <merijn> reinoud: Considering the things you are saying I think you may benefit from reading Learn You a Haskell instead
05:46:16 <merijn> reinoud: Because if I remember RWH ramps up quite fast and you seem to have missed some basic things about data types and so on
05:46:20 <reinoud> just paste in the definitions in hpaste?
05:46:27 <elliott> yeah, I really recommend LYAH over RWH
05:46:34 <merijn> @where lyah
05:46:35 <lambdabot> http://www.learnyouahaskell.com/
05:46:48 <vodik> reinoud: everything
05:47:14 <vodik> i don't think you realize which parts may be problematic
05:47:37 <elliott> fixing someone's programs on IRC is a really bad way to teach them the basics :p
05:47:39 <reinoud> its a mutli-file thing, how can i paste it correctly?
05:49:05 <vodik> elliott: true
05:49:16 <elliott> reinoud: seriously, though... it would be best to get basics like algebraic data types down before trying to dive in and write a program
05:50:00 <elliott> RWH is great if you can get over the initial curve fast enough but it's easy to miss one or two things and get kinda stuck with it since it moves very quickly on to "practical" stuff
05:50:10 <elliott> I'd rather everyone read LYAH before RWH, really
05:51:29 <reinoud> A web handler threw an exception. Details: Prelude.head: empty list
05:51:37 <reinoud> hmmm so far for the hpaste
05:52:02 <hpaste> “Reinoud pasting it here” pasted “Marching Cubes” at http://hpaste.org/66116
05:52:19 <reinoud> its a shar
05:52:36 <mm_freak> ah, i see why it didn't work…  killThread blocks until the exception is delivered, not until the thread is dead
05:53:20 <mm_freak> since after the killThread my application exits the exception handler doesn't get a chance to run
05:53:37 <reinoud> i use `ghc IsosurfaceS.hs' and it works but i want to adjust to code so it not prints the number of vcertices but the actual vertices!
05:53:53 <vodik> well thats far from basic
05:54:36 <_mpu> Is there a kind of "unzipWith" available in the standard library?
05:54:49 <reinoud> i just ported it to -current ghc from haskell98
05:54:54 <elliott> reinoud: i'd also recommend not modifying someone else's program as your first attempt at haskell
05:55:03 <elliott> it's not a very good way to learn
05:55:23 <reinoud> i have some experience with Miranda and Gopher, only switching over to Haskell is harder than i thought
05:55:25 <vodik> _mpu: map and curry?
05:55:31 <vodik> :t map . curry
05:55:31 <mm_freak> is there a way to actually wait for the thread to die?
05:55:31 <lambdabot> forall a b c. ((a, b) -> c) -> [a] -> [b -> c]
05:55:40 <ClaudiusMaximus> :t \f -> unzip . map f
05:55:41 <lambdabot> forall a b a1. (a1 -> (a, b)) -> [a1] -> ([a], [b])
05:55:44 <mm_freak> without using MVar that is
05:55:52 <vodik> hmm, not quite
05:56:14 <_mpu> ClaudiusMaximus, I wanted to avoid the unzip + map combination. Anyway.
05:56:18 <elliott> I thought Gofer had ADTs.
05:56:36 <liyang> mm_freak: no. You can't (in general) wait(2) since they're not OS threads.
05:56:59 <elliott> reinoud: but anyway, haskell adds at least one very major concept from Gofer (typeclasses) and beyond that, the evolution it's had over the past decades means that it's really more like learning a new, related language than simply switching over to a new dialect.
05:57:09 <reinoud> i followed a course where we had to program in Miranda and at home i used Gofer, but it has been some time ago and i ... have lost the touch a bit so to say
05:57:40 <reinoud> hehe, yeah i ... noticed that!!! :-D
05:58:28 <reinoud> it has been.... eeuuhhhh ouch, 2 decades ago already?? time flies :(
05:58:47 <elliott> anyway, you'll get a lot further if you spend some time reading the first few chapters of LYAH -- enough to get the basic data type and instance syntax down at least
05:58:53 <roconnor> I thought the only difference between Miranda and Haskell is that Haskell has lifted tuples :P
05:59:11 <merijn> roconnor: And some people actually use Haskell? :p
05:59:29 <roconnor> I know!!
06:01:27 <reinoud> is the code i pasted read-able?
06:01:52 <reinoud> its this line:
06:01:55 <reinoud>     ; (print . length . flip isosurface dataset . fromIntegral . asInt) thresh
06:02:05 <reinoud> that has been haunting me
06:02:16 <nart> ciao =)
06:02:54 <nart> what's the best web framework to create rest json api ? =)
06:02:58 <reinoud> maybe i should just rewrite it :( and learning Haskell in the process :)
06:03:06 <yasar> > (+) <$> (find (>0)) <*> (find (<5)) $ [1,2]
06:03:07 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
06:03:07 <lambdabot>    arising from a use of...
06:03:19 <yasar> Why doesn't that work?
06:03:42 <nart> :t find
06:03:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
06:04:23 <yasar> Can't I sum Maybe Num?
06:04:26 <ion> @type ?foo <$> find (>0) <*> find (<5)
06:04:26 <lambdabot> forall b a. (?foo::Maybe a -> Maybe a -> b, Num a, Ord a) => [a] -> b
06:04:59 <vodik> > liftA2 (+) (Just 5) (Just 8)
06:04:59 <lambdabot>   Just 13
06:05:06 <reinoud> thanks a lot for the help
06:05:14 <merijn> Alternately make a Num instance for Maybe :p
06:05:24 <reinoud> i'll start reading http://learnyouahaskell first :)
06:05:43 <merijn> instance (Num a) => Num (Maybe a) where -- abomination here :p
06:06:12 <vodik> > let f x = liftA2 (+) (find (> 0) x) (find (< 5) x) in f [1,2]
06:06:12 <lambdabot>   Just 2
06:06:40 <vodik> yasar: problem is that the first find doesn't get the list
06:06:58 <yasar> what does it get?
06:07:06 <vodik> nothing, its partially defined
06:07:10 <ion> reinoud: I don’t really see a problem with that line. Perhaps some subset of the functions being composited could be refactored into a separate function, but i don’t know enough about the program to know whether that’s a good idea or not.
06:07:11 <t7> javascript is so bad
06:07:13 <t7> srs
06:09:05 <yasar> when I see "(+) <$> (find (>0)) <*> (find (>5)) $ [1,2]" I read it like: first find a value, bigger than zero, and find a value bigger than five and than sum them. Where is the problem with that?
06:09:11 <mm_freak> liyang: it doesn't have to be a wait(2), just a haskell RTS wait
06:09:29 <mm_freak> nevermind, i've written a withThread function now that does that for me using an MVar
06:09:53 <vodik> :t (+) <$> (find (>0))
06:09:54 <lambdabot> forall a. (Num (Maybe a), Num a, Ord a) => [a] -> Maybe a -> Maybe a
06:10:16 <vodik> notice how its expecting 2 arguments?
06:10:25 <vodik> and the first one is a list?
06:10:29 <yasar> yes
06:10:40 <yasar> so?
06:10:51 <vodik> that's the position <*> will fill, so to speak
06:11:11 <reinoud> ion: that line puzzles me too in that it starts complaining about various stuff that ought to be type-safe to do so but it just gets confused when i start changing the line.
06:11:53 <yasar> Ohh, I see, so find(>5) should return a list of Ints, that a Maybe Int
06:12:01 <yasar> am I right?
06:12:22 <vodik> on the right track
06:12:22 <reinoud> (flip isosurface dataset . fromIntegral . asInt) "100" f.e. ought to give a list of triangles that `print' should be able to show since its all plain tuple stuff
06:12:56 <ion> yasar: In “foo <$> find (>0)” you’re using the (r →) functor.
06:13:10 <vodik> :t (+) <$> Just
06:13:10 <lambdabot> forall a. (Num (Maybe a)) => a -> Maybe a -> Maybe a
06:13:14 <reinoud> should i use $ ?
06:13:20 <vodik> err, thats not what i ment
06:13:24 <vodik> :t (+) <$> Just 3
06:13:24 <lambdabot> forall a. (Num a) => Maybe (a -> a)
06:13:40 <reinoud> hey!
06:13:42 <reinoud> i changed
06:13:43 <vodik> i don't know the proper terms
06:13:54 <vodik> but the (a -> a) inside Maybe is important
06:14:00 <reinoud>     ; print $ (length . flip isosurface dataset . fromIntegral . asInt) thresh
06:14:13 <yasar> :t (+) <$> (+3)
06:14:14 <lambdabot> forall a. (Num a) => a -> a -> a
06:14:15 <reinoud> and how it links so maybe the . was confusing the hell out of ghc
06:14:27 <reinoud> and my Miranda is playing up again ;)
06:14:46 <yasar> :t (+) <$> (+3) $ 5
06:14:46 <lambdabot> forall a. (Num a) => a -> a
06:15:05 <yasar> > (+) <$> (+3) $ 5
06:15:06 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:15:06 <lambdabot>    arising from a use of `...
06:15:07 <Peaker> Miranda was like Haskell with unlifted products? I want Miranda!
06:15:29 <vodik> > ((+) <$> (+3) $ 5) 1
06:15:30 <lambdabot>   9
06:16:02 <yasar> > (+) <$> (+3) $ 5 1
06:16:03 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:16:03 <lambdabot>    arising from a use of `...
06:16:05 <reinoud> bummer
06:16:20 <elliott> Unlifted products is _|_ = (_|_, _|_), right?
06:16:20 <reinoud> if i remove the `length' again it just bombs out
06:16:21 <vodik> yasar: 5 1 isn't valid, 5 isn't a function
06:16:24 <reinoud>     Could not deduce (Show b) arising from a use of `print'
06:16:45 <yasar> :t (+) <$> (+3)
06:16:46 <lambdabot> forall a. (Num a) => a -> a -> a
06:16:46 <hpc> (except for when it is, but that's lambdabot strangeness and should be ignored)
06:16:56 <Jafet> "Have I got some news for you"
06:17:11 <yasar> doesn't (+) <$> (+3) takes 2 arguments?
06:17:15 <vodik> :t (+) <$> 8
06:17:16 <lambdabot> forall a (f :: * -> *). (Num a, Num (f a), Functor f) => f (a -> a)
06:17:16 <nart> > (++) <$> (filter (>0)) <*> (filter (>5)) $ [1,2,-1]
06:17:18 <lambdabot>   [1,2]
06:17:47 <zhulikas> :t (+) <$> (+3)
06:17:48 <lambdabot> forall a. (Num a) => a -> a -> a
06:17:55 <zhulikas> yasar, yep, it does.
06:18:10 <Jafet> > ((+1) + (+2)) 0
06:18:11 <lambdabot>   3
06:18:14 <yasar> > (+) <$> (+3) $ 5 1
06:18:15 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:18:15 <lambdabot>    arising from a use of `...
06:18:20 <ion> reinoud: That’s simply the same as print ((length . flip isosurface dataset . fromIntegral . asInt) thresh)
06:18:31 <vodik> yasar: operator precedence
06:18:47 <yasar> > (+) <$> (+3) 5 1
06:18:48 <vodik> > ((+) <$> (+3) 5) 1
06:18:48 <lambdabot>   No instance for (GHC.Show.Show (f (a -> a)))
06:18:48 <lambdabot>    arising from a use of `M366...
06:18:48 <ion> reinoud: And since (f . g) x = f (g x), that’s the same as your original line.
06:18:49 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:18:49 <lambdabot>    arising from a use of `...
06:18:51 <reinoud> ah
06:18:55 <vodik> > ((+) <$> (+3) $ 5) 1
06:18:56 <lambdabot>   9
06:19:31 <reinoud> so now i am still stuck at that it won't print the results :-S
06:19:34 <yasar> Function applicative confuses me :S
06:19:49 <hpc> :t f <*> x
06:19:49 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
06:19:50 <lambdabot>     In the second argument of `(<*>)', namely `x'
06:19:50 <lambdabot>     In the expression: f <*> x
06:19:53 <hpc> :t f <*> g
06:19:54 <lambdabot> forall (f :: * -> *) a b. (SimpleReflect.FromExpr (f (a -> b)), SimpleReflect.FromExpr (f a), Applicative f) => f b
06:20:06 <hpc> > f <*> g $ x :: Expr
06:20:07 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:20:07 <lambdabot>    `SimpleReflect.FromExpr ...
06:20:10 <hpc> :(
06:20:18 <hpc> @src (->) (<*>)
06:20:18 <lambdabot> (<*>) f g x = f x (g x)
06:21:18 <ion> @@ @djinn @type (<*>) `asAppliedTo` (undefined :: a -> b)
06:21:20 <lambdabot>  f a b c = a c (b c)
06:21:47 <elliott> ion: heh, neat
06:22:28 <Jafet> ap = (<*>)
06:23:45 <hpc> @unmtl Reader e a
06:23:45 <lambdabot> e -> a
06:23:49 <hpc> @src ap
06:23:49 <lambdabot> ap = liftM2 id
06:24:26 <ion> Sadly, ap ≡ (<*>) only.
06:24:52 <Jafet> No, no, I just defined ap.
06:29:12 * hackagebot pec 0.2.1 - pec embedded compiler  http://hackage.haskell.org/package/pec-0.2.1 (BrettLetner)
06:29:29 <reinoud> have to dash now for a while
06:29:33 <reinoud> thanks a lot :)
06:49:12 * hackagebot haskell-src-exts 1.13.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.13.0 (NiklasBroberg)
06:51:04 <jeff_s_> EitherT and ErrorT are the same, is that right?
06:51:35 <merijn> jeff_s_: I think the latter has the first value as String, whereas the former does not
06:51:54 <merijn> i.e. "type Error a = Either String a" (I could be wrong)
06:53:03 <jeff_s_> I thought so too, but then I saw "newtype ErrorT e m a "
06:53:20 <quicksilver> ErrorT does not force it to be a string
06:53:21 <jeff_s_> Where e is the error type.
06:53:26 <hpc> use the source, luke
06:53:27 <quicksilver> but it does force it to be an instance of a typeclass
06:53:29 <quicksilver> (Error)
06:54:08 <quicksilver> which EitherT are you looking at?
06:54:14 <jeff_s_> quicksilver - thanks, I didn't notice that part, it's in throwError.
06:54:25 <hmwat> hey folks, I keep getting this when building the latest haskell platform
06:54:27 <hmwat> http://pastebin.com/Sg4eZ2Lz
06:54:28 <jeff_s_> http://hackage.haskell.org/packages/archive/EitherT/0.1.0/doc/html/Control-Monad-Trans-Either.html Is there another EitherT?
06:54:38 <mauke> The paste Sg4eZ2Lz has been copied to http://hpaste.org/66118
06:54:48 <elliott> jeff_s_: yes, in Control.Monad.Error
06:54:55 <elliott> oh, Either/T/
06:54:57 <hmwat> why is it looking for ghc-7.0.3?
06:54:58 <elliott> hmm, maybe transformers
06:55:23 <elliott> nope. guess not then
06:55:26 <jeff_s_> Ya, I've been using EitherT for error handling, and I was starting to wonder if I should be using ErrorT instead.
06:55:30 <hmwat> this is the 2011.4.0.0 haskell platform
06:56:13 <mm_freak> jeff_s_: use ErrorT
06:56:22 <mm_freak> it's just EitherT with a different name
06:56:42 <jeff_s_> What does implementing Error for my error type buy me?
06:56:42 <elliott> mm_freak: except for the broken constraint...
06:56:57 <mm_freak> true
06:56:59 <elliott> jeff_s_: the only reason the constraint is there is because of "fail".
06:57:05 <elliott> it's horrible.
06:57:19 <elliott> you can just "instance Error MyType where strMsg = error" or something
06:57:53 <mm_freak> strMsg = show
06:57:59 <mm_freak> ah, no
06:58:00 <mm_freak> read
06:58:10 <mm_freak> stupid
06:58:13 <elliott> mm_freak: haha, ew
06:58:32 <jeff_s_> ErrorT seems like extra work that I don't need.
06:58:33 <mm_freak> but yeah, if you don't use 'fail', you could just as well define noMsg only
06:58:51 <mm_freak> well, if you like CPS you can use the EitherT from contstuff =)
06:59:13 * hackagebot failure 0.2.0.1 - A simple type class for success/failure computations.  http://hackage.haskell.org/package/failure-0.2.0.1 (MichaelSnoyman)
06:59:48 <tzxn3> http://puu.sh/mMDV
07:00:11 <tzxn3> http://pastebin.com/raCWXhsJ
07:00:15 <mauke> The paste raCWXhsJ has been copied to http://hpaste.org/66119
07:00:17 <quicksilver> jeff_s_: well it's also in the Monad instance.
07:00:19 <tzxn3> not sure what's wrong with this code
07:00:57 <merijn> tzxn3: Any specific part/error?
07:01:17 <jeff_s_> Contstuff looks fun for another time.
07:01:21 <tzxn3> the playerTurn and dealerTurn procedures
07:02:05 <merijn> tzxn3: Not really related to your problem, why not move some of the playerTurn/dealerTurn code into smaller subfunctions in a where clause?
07:02:13 <merijn> To stop them from growing right so much
07:02:31 <tzxn3> I don't know how to do that effectively
07:04:04 <osager> what does :/ mean ?
07:04:13 * hackagebot data-clist 0.0.7.1 - Simple functional ring type.  http://hackage.haskell.org/package/data-clist-0.0.7.1 (JohnVanEnk)
07:05:27 <elliott> osager: frown
07:05:31 <elliott> or do you mean in haskell...
07:05:40 <osager> yes in haskell
07:05:53 <elliott> it's a constructor
07:05:55 <elliott> what's the context
07:05:57 <osager> i saw this operator in System.Directory.Tree package
07:06:00 <elliott> ah.
07:06:02 <elliott> well it's a constructor
07:06:06 <elliott> probably for a file path type
07:06:12 <elliott> you know how constructors have to start with upper-case letters?
07:06:24 <merijn> tzxn3: For an initial simplification, take a look at the annotation at the bottom: http://hpaste.org/66119
07:06:24 <elliott> : is the only uppercase symbol, so that's how operators that are constructors start
07:06:25 <osager> i do
07:06:42 <merijn> tzxn3: Replaces the nested if/else with guards
07:08:38 <osager> so elliott
07:08:41 <osager> what does it mean then
07:09:50 <elliott> well...
07:09:55 <elliott> data Foo = Bar Int String
07:09:58 <elliott> what does Bar mean?
07:10:01 <elliott> it's a constructor.
07:10:02 <hpaste> merijn annotated “pastebin.com/raCWXhsJ” with “More simplification” at http://hpaste.org/66119#a66121
07:10:16 <osager> yes
07:10:17 <elliott> or are you asking what it means in the context of System.Directory.Tree
07:10:30 <merijn> tzxn3: You probably want to cleanup the "choice" in the where clause there, but it's already a huge improvement I think
07:10:33 <elliott> in which case, the answer is I don't know, but I would bet it was chosen because it looks like the / directory separator on unix systems, which might be a hint.
07:11:02 <osager> the context is: data Foo a = FilePath :/ DirTree a
07:11:02 <elliott> osager: http://hackage.haskell.org/packages/archive/directory-tree/latest/doc/html/System-Directory-Tree.html#t:AnchoredDirTree
07:11:04 <merijn> Oh, damn. I messed up the indenting...oh well
07:11:16 <elliott> data AnchoredDirTree a = Blah FilePath (DirTree a)
07:11:16 <elliott> same thing
07:11:20 <elliott> it's declaring (:/)
07:11:24 <elliott> just as that line declares Blah
07:12:01 <osager> where can i find documentation on the meaning of this operator ?
07:12:05 <osager> i still dont get it
07:12:14 <elliott> ...it has no meaning
07:12:18 <elliott> osager: look, this would be exactly the same
07:12:29 <elliott> data Foo a = FilePath :$*$*$*$* DirTree a
07:12:37 <elliott> osager: you realise that operators in Haskell are user-defined, right? not built-in
07:12:40 <merijn> osager: It's not an operator, it's a constructor
07:12:44 <osager> ok; so how should i use it ?
07:12:45 <elliott> any name composed of symbols can be used infix like that
07:12:50 <elliott> osager: data AnchoredDirTree a = Blah FilePath (DirTree a)
07:12:52 <elliott> how would you use Blah?
07:12:57 <elliott> Blah aFilePath aDirTree
07:12:59 <elliott> aFilePath :/ aDirTree
07:13:01 <tzxn3> oh, thanks merijn
07:13:35 <osager> other constructors has the form of:File name::Filename
07:13:38 <osager> why not this one ?
07:13:52 <merijn> tzxn3: (I realise that's not actually remotely related to your problem/question, but it's easier to debug more readable code :p)
07:13:58 <elliott> osager: ehm, what?
07:14:00 <tzxn3> :p
07:14:07 <elliott> i don't know what constructors you've been looking at.
07:14:14 <elliott> data Maybe a = Nothing | Just a
07:14:19 <elliott> data Either a b = Left a | Right b
07:14:24 <elliott> data Foo a = Blah FilePath (DirTree a)
07:14:30 <elliott> data Bar a = FilePath :/ DirTree a
07:14:37 <merijn> tzxn3: But does it produce an error? Behave unexpected? If yes, how exactly?
07:14:49 <osager> ok so Left is a constructor i understand
07:14:58 <tzxn3> when player or dealer hits it puts way more card into the hand than it shoul
07:15:04 <osager> but How come FilePath :/ is also a constructor
07:15:07 <osager> ?
07:15:08 <elliott> osager: it's not
07:15:11 <elliott> (:/) is a constructor
07:15:13 <elliott> it's just written infix
07:15:15 <elliott> ok, let's put it this way
07:15:20 <elliott> data Foo a = (:/) FilePath (DirTree a)
07:15:25 <elliott> do you see now? (:/) is the name of the constructor
07:15:26 <osager> ok
07:15:28 <osager> know i get it
07:15:30 <elliott> but since it's an operator, you can use it infix
07:15:31 <elliott> right
07:15:43 <osager> i 've never seen it infix like this
07:15:46 <osager> very confusing
07:17:21 <yasar> Can I partially apply type constructors?
07:17:28 <osager> thanks elliott
07:17:40 <osager> i appreciate the patience
07:17:58 <merijn> tzxn3: Ah, I see. I think you're control flow is to complicated
07:18:15 <tzxn3> aye
07:18:19 <tzxn3> how could it be improved?
07:18:32 <Peaker> yasar: yeah, type application can be curried too
07:19:11 <merijn> tzxn3: Lemme see if I can sketch out something, because I think restructuring will be more useful then debugging
07:19:13 * hackagebot resourcet 0.3.2 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.3.2 (MichaelSnoyman)
07:19:24 <Peaker> yasar: For example, monad transformers are often composed as:  StateT s (WriterT w IO) a     (WriterT is applied to 2 of its 3 args, IO is applied to 0 of 1)
07:19:45 <Peaker> yasar: the kinds of multi-param type constructors are: * -> (* -> (....   just like ordinary curried functions
07:20:08 <eduaedtcacenco> !lista
07:20:32 <eduaedtcacenco> ~ThomasLoc@pdpc/supporter/active/thomaslocke
07:21:28 <Peaker> eduaedtcacenco spammed with privmsg -- might want to ban something?
07:24:46 <eacameron> Is there a way to make ghci set my prompt to "> " automatically whenever it starts up (like a ghcirc file or something)?
07:26:34 <Saizan> eacameron: .ghci
07:26:36 <ClaudiusMaximus> eacameron: ~/.ghci can contain :set prompt "> "      and other things
07:27:05 <eacameron> Saizan: ClaudiusMaximus: awesome, thanks!
07:28:24 <ClaudiusMaximus> actually you can have more than one .ghci file - seems the execution order is $(pwd)/.ghci then ~/.ghci - or something like that
07:28:26 <hpaste> merijn pasted “Very rough sketch” at http://hpaste.org/66122
07:28:37 <merijn> tzxn3: Something like: http://hpaste.org/66122
07:29:25 <merijn> tzxn3: You might be able to remove some IO's from there, but you don't necessarily have to
07:30:09 <merijn> tzxn3: You want to separate prompting for input from the actually deciding things based on gamestate
07:31:36 <jeff_s_> Hm, the ErrorT from the mtl package doesn't require that the error type be an instance of Error, whereas the ErrorT from the transformers package does.
07:32:01 <jeff_s_> So I could use ErrorT, but I would use the one from mtl.
07:32:03 <tzxn3> thanks
07:35:22 <merijn> tzxn3: You might want to change the playerTurn/dealerTurn to be "Input -> GameState -> GameState" for example and then do the IO in the round function
07:35:35 <tzxn3> yeah
07:35:47 <tzxn3> makes sense
07:35:48 <merijn> tzxn3: Recursively calling everything from each other doesn't make sense if you're going into IO anyway
07:36:08 <merijn> If you're in IO just do the sequential parts sequentially :p
07:36:28 <tzxn3> my friend gave me advice on the structure to use, I went with it!
07:37:20 <merijn> tzxn3: Well, it makes some sense to use a structure like that in pure code, because that's how you encode calling sequence in pure code. But if you're returning IO a anyway...
07:37:32 <tzxn3> yes
07:37:45 <jeff_s_> Never mind, I was wrong about that
07:37:52 <tzxn3> my friend basically wrote the playerTUrn function for me though :P
07:47:57 <yasar> what is "pure []" for a function?
07:48:32 <sipa> :t pure []
07:48:33 <lambdabot> forall a (f :: * -> *). (Applicative f) => f [a]
07:48:57 <sipa> it's not a function necessarily
07:49:18 <vodik> :t (+2)
07:49:19 <lambdabot> forall a. (Num a) => a -> a
07:49:21 <vodik> :t pure (+2)
07:49:22 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f (a -> a)
07:51:32 <elliott> yasar: const []
07:51:38 <elliott> aka (\a -> [])
07:51:41 <elliott> (didn't i say that earlier?)
07:52:39 <vodik> you did
07:52:50 <yasar> It's possible, I am trying to get applicative functors for hours.
07:52:50 <vodik> you used \x -> []
07:53:08 <yasar> I might have forgotten
07:53:19 <Peaker> yasar: Do you get Functors?
07:54:08 <tai> Are there any resources with a lot of "parallel examples", showing examples of code in Haskell alongside the equivalent in C or some other language?
07:54:18 <t7> @hoogle Num a => a -> (a -> b -> b) -> b -> b
07:54:18 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
07:54:18 <lambdabot> Data.IntMap foldr :: (a -> b -> b) -> b -> IntMap a -> b
07:54:19 <lambdabot> Data.IntMap foldr' :: (a -> b -> b) -> b -> IntMap a -> b
07:54:34 <t7> @hoogle IntMap
07:54:35 <lambdabot> Data.IntMap module Data.IntMap
07:54:35 <lambdabot> Data.IntMap data IntMap a
07:54:44 <yasar> Peaker: Yes, I am really about the get the whole thing now.
07:54:49 <_mpu> yasar, They are just "list like" types constructors.
07:57:14 <Peaker> tai: C and Haskell are far enough apart that if you write the actual same algorithm in both languages, it will be very long and probably not illuminating to see it in C
07:57:28 <yasar> Yes, but applicative (->) was driving me crazy, but I finally got it.
07:57:32 <hpaste> anachron pasted “memory use in parallelism” at http://hpaste.org/66123
07:57:49 <anachron> hi guys
07:58:20 <anachron> I'm having some trouble with memory usage when using parallel haskell
07:58:36 <Peaker> yasar: Yeah, fmap=(.), pure=const, (f <*> x) env = f env (x env)
07:59:15 <anachron> (that example program is somewhat contrived)
07:59:30 <_mpu> yasar, I use them for monads (mainly).
07:59:50 <Peaker> _mpu: what do you mean?
08:00:07 <_mpu> Peaker, many monads are applicative.
08:00:19 <anachron> essentially, running with +RTS -N1 has normal memory use
08:00:57 <anachron> but when using more than one core memory use skyrockets
08:01:01 <elliott> <_mpu> yasar, They are just "list like" types constructors.
08:01:06 <elliott> _mpu: IO is "list-like"?
08:01:21 <_mpu> elliott, In the sense that it is applicative, yes.
08:01:32 <elliott> I agree, if you define "list like" to mean "applicative", then IO is list like
08:01:34 <_mpu> hehe.
08:02:02 <_mpu> elliott, kind of an ill founded definition here.
08:02:13 <gspr> My guess is that the following question doesn't have an answer besides "it depends", but I'll give it a shot anyway. I have a rather large program that in a "complicated way" builds up a Map k v (the one from the standard containers). By a "complicated way" I mean that a lot of items are inserted, and each insertion involves some lookups in the map that's been built up so far. Now, the thing is, k is essentially [Int], so I've been thinking that the Ha
08:02:30 <elliott> "that the Ha"
08:02:35 <elliott> your line got cut off there.
08:02:43 <gspr> (The reason I ask: Experiments show that memory usage goes up by a *lot*, and there's no speed improvement)
08:02:53 <gspr> oh, sorry
08:02:55 <gspr> let me split it
08:02:57 <Peaker> _mpu: all Monads are Applicatives
08:02:59 <parcs`> christ, irc clients still can't handle long input?
08:03:13 <geekosaur> decent clients can
08:03:23 <copumpkin> it's the server limiting that
08:03:28 <gspr> elliott: that the HashMap from  unordered-containers must surely be better than what I have. Does this sound true to you guys aswell?
08:03:44 <elliott> gspr: Yes, probably.
08:03:46 <geekosaur> enh.  xchat autosplits, there are autosplit scripts for many other clients
08:03:54 <elliott> gspr: A trie map might be worth considering too.
08:03:58 <_mpu> Peaker, Hence, many monads are applicative.
08:04:05 <gspr> elliott: Hmm, interesting
08:04:05 <elliott> I would be very surprised if Map [Int] ever beat HashMap [Int]
08:04:23 <_mpu> parcs`, isn't it a server problem?
08:04:25 <elliott> and I would try HashMap before bothering with a trie package as it's common and well-optimised
08:04:37 <gspr> In my case performance is comparable (let's say within 10%). However, Map [Int] beats HashMap [Int] memory-wise by a factor of 5
08:04:41 <elliott> _mpu: no, irc clients should split long lines across lines
08:04:48 <_mpu> parcs`, Mine just respects the RFC, no more than 512 chars in a message.
08:04:50 <elliott> many of them just send whatever you type to the server without checking the length, causing data lossage
08:05:00 <_mpu> elliott, I see.
08:05:02 <geekosaur> the server advertises its line length limit (which is per RFC), client should deal
08:05:07 <elliott> gspr: That's odd. Sounds like you should report it.
08:05:09 <parcs`> _mpu: dunno. i assume there is a way to query the server about the maximum length of a message, so that the client can handle long input properly
08:05:10 <gspr> Though of course, I'm sure there's something in my algorithm that should be changed, and of course it's impossible for you guys to comment on that for the little info I'm givin :)
08:05:23 <geekosaur> it's part of the connection details
08:05:24 <elliott> gspr: At least I would consider that memory use a bug.
08:05:31 <gspr> elliott: Yeah, I'll consider it -- I need to reproduce the problem in a much, much cleaner way though
08:06:08 <gspr> elliott: Thanks a lot for your feedback though -- I needed input on whether I was just confused about HashMap :)
08:06:29 <_mpu> parcs`, If so, I feel like flood kicks will be more frequent :).
08:06:54 <parcs`> i don't. lambdabot gets away with writing 4 lines at a time
08:07:24 <_mpu> parcs`, lambdabot has supernatural powers.
08:07:45 <parcs`> that explains it
08:08:19 <gspr> elliott: Am I correct in thinking that HashMap.Lazy has comparable laziness to Map?
08:08:36 <gspr> (incidentally, I've tried with HashMap.Strict as well, with roughtly the same results)
08:08:51 <ClaudiusMaximus> anachron: well, i can reproduce it - +RTS -N1 uses 28M, +RTS -N2 490M
08:09:01 <_mpu> What's the point in wrapping monads? (WrappedMonad in Control.Applicative)
08:10:11 <parcs`> _mpu: you get a Monad instance for free
08:10:25 <parcs`> wait no
08:10:32 <parcs`> you get Functor/Applicative instances for free
08:10:32 <anachron> ClaudiusMaximus: exactly
08:11:11 <parcs`> if you :i WrappedMonad in ghci you'll see 'instance Monad m => Functor (WrappedMonad m)' and 'instance Monad m => Applicative (WrappedMonad m)'
08:12:07 <anachron> ClaudiusMaximus: it seems to execute nearly all threads simultaneously, rather than just 2 at a time
08:12:16 <ClaudiusMaximus> anachron: exactly.  hmm
08:12:38 <_mpu> parcs`, I don't get it, why not 'instance Monad m => Applicative m'
08:12:58 <parcs`> because that is not valid haskell
08:13:51 <_mpu> Oh I see because of a termination constraint.
08:18:14 <parcs`> yeah, because then you can do something like 'instance C a => D a; instance D a => C a' and have the typechecker loop
08:23:53 <ClaudiusMaximus> anachron: try using this instead of parMap: parMap' s f = withStrategy (parBuffer 4 s) . map f
08:25:17 <ClaudiusMaximus> anachron: the 4 is something i picked arbitrarily
08:27:51 <anachron> ClaudiusMaximus: that works, thanks :)
08:27:58 <tzxn3> merijn: not sure I entirely follow the sample you gave me
08:28:17 <tzxn3> how does it primarily differ from waht I've got already?
08:28:50 <ClaudiusMaximus> anachron: np - i learned something new that i might find useful at some point :)
08:29:15 * hackagebot pec 0.2.2 - pec embedded compiler  http://hackage.haskell.org/package/pec-0.2.2 (BrettLetner)
08:30:37 <tzxn3> I see there's no recursive calling
08:30:54 <tzxn3> of the turn functions
08:36:03 <xivix> join #archlinux
08:36:13 <xivix> rofl oops
08:36:17 <roconnor> join #nixos
08:37:00 <tzxn3> #archlinux is on freenode?
08:37:01 <xivix> XChat does this annoying thing where text is left behind when switching channels.
08:37:09 <xivix> tzxn3: Yup. It's a pretty good channel.
08:43:10 <thatismatt> Does anyone know if it is possible to open 2 file handles for the same file, one read and one write?
08:43:19 <elliott> no
08:43:25 <reinoud> what trikes me as strange is why ghc can't just print out all types, just as you would enter them
08:44:15 <parcs`> what?
08:44:20 <elliott> reinoud: you want ghc to be able to print functions?
08:45:03 <reinoud> it could just print it as `(Abc :: [int] -> int)' or whatever
08:45:11 <yasar> I have started to read Monoids, and checked if Int's were Monoids, but they weren't. But they can be with 1 and * , and also with 0 and +, is there any particular reason why Int's aren't Monoids?
08:45:31 <elliott> yasar: because they can be monoids two ways
08:45:36 <reinoud> Miranda used to do that... just print everything out, including trees etc one creates with types
08:45:50 <elliott> > getSum (Sum 42 `mappend` Sum 12)
08:45:51 <lambdabot>   54
08:45:55 <elliott> > getProduct (Product 42 `mappend` Product 12)
08:45:56 <lambdabot>   504
08:46:12 <yasar> Ohh, so they are newtyped?
08:46:15 <elliott> you can only have one instance per type in Haskell, so...
08:46:16 <elliott> yasar: yeah
08:46:33 <quicksilver> reinoud: yes, it's a bad design of GHC (IMO)
08:46:50 <thatismatt> elliot: ta
08:46:52 <quicksilver> reinoud: it shouldn't use a function *inside* the language (show) as its default display method.
08:46:56 <reinoud> i hope this will change for its quite a handy feature
08:47:06 <quicksilver> it should have something external, which works on all types.
08:47:16 <quicksilver> reinoud: you get used to its absence pretty quickly, to be honest.
08:47:24 <quicksilver> but I do think a different design would be better.
08:48:02 <reinoud> true, but just being able to print everything automagically and to be able to go interactive with 100% the same environment as the compilated stuff would also be good
08:48:18 <elliott> you can go interactive with 100% the same environment as the compiled stuff
08:48:36 <elliott> reinoud: anyway try and enter a Map into GHCi
08:48:42 <elliott> you'll be grateful it doesn't print the internal tree representation
08:48:46 <elliott> and instead prints a useful alist form
08:49:21 <reinoud> oh i dont mind having usefull format printing if defined, but otherwise just print out how one would enter it
08:49:42 <quicksilver> well that is the behaviour of the standard Show instance
08:49:57 <quicksilver> it's just there can't really be a sensible Show instance for functions, inside the language.
08:51:35 <reinoud> would Hugs give me a better debugging?
08:51:56 <elliott> hugs would give you not being maintained since mid-2000s
08:52:06 <reinoud> oh!
08:52:43 <reinoud> mutt
08:52:54 <reinoud> (wrong terminal(
08:52:55 <reinoud> )
08:57:50 <misterbeebee_> Following up on my ropes saga from yesterday.... data-rope wouldn't install on Windows, Lazy ByteString was far too slow for accessing near the end, and Data.Sequence was fine.
08:58:25 <misterbeebee_> Traversing it is most of the program's time, but it's acceptably fast for my program. I feel like the program uses a few hundred MB more RAM than it should, and could be 10x faster, but I have Moore's Law to save me.
08:58:50 <elliott> if you're storing all your data in memory, why lazy ByteString?
08:58:51 <gspr> elliott: I've managed to reproduce the HashMap vs Map performance with much simpler code now (20 lines including main function to print some stuff) -- would you mind taking a look at it before I pass it on as a possible bug?
08:58:55 <elliott> Seq is strict, so try strict ByteString
08:59:18 <elliott> gspr: ok, though i'm hardly an expert -- is this with the fancy new unordered-containers?
08:59:26 <rwbarton> how big are your chunks?
08:59:28 <elliott> 0.2 that is
08:59:35 <gspr> 0.2.1.0 yes
08:59:41 <gspr> I've never used it before today, so I just grabbed the latest
09:00:02 <misterbeebee_> Um, Because I need to cut and paste alot, and I think strict Bytestring would copy the whole array every time I moved a snippet?
09:00:21 <misterbeebee_> Seq gives much better cut and paste, I was led to understand.
09:00:34 <misterbeebee_> but I obviously am not sure I have this correct!
09:00:42 <elliott> well, right
09:00:50 <elliott> lazy bytestring is basically just a lazy list of bytestrings, for what it's worth
09:01:12 <gspr> elliott: I'll do one more test, and then I'll throw it up on hpaste. If you don't have time, I completely understand
09:01:17 <misterbeebee_> right, yeah. I assumed lazy BS would be better than strict
09:02:04 <quicksilver> misterbeebee_: a Seq of what?
09:02:08 <misterbeebee_> Char
09:02:09 <misterbeebee_> maybe the rest of my code was already optmized against bytestrings, I found myself trying stuff like "reverse' to work with the
09:02:14 <rwbarton> yikes!
09:02:18 <misterbeebee_> end of the list, and that used a ton of memory.
09:02:20 <elliott> gspr: I'll take a quick look at it, but you might as well ask lambdabot for all the good it'll do :)
09:02:27 <quicksilver> misterbeebee_: OK, well a Seq of Text is probably the most natural structure.
09:02:35 <quicksilver> misterbeebee_: that's "like" a rope, loosely speaking.
09:02:44 <misterbeebee_> reversing strict bytesrtrings was fast but quickly went over 2GB
09:02:49 <elliott> quicksilver: bad idea, since you can't measure length
09:02:52 <elliott> better to use the fingertree package
09:03:01 <elliott> then you can have a finger tree of Text which gets the length right
09:03:05 <quicksilver> elliott: only if measuring length is a key requirement.
09:03:14 <elliott> quicksilver: or indexing...
09:03:15 <elliott> or splitting
09:03:27 <quicksilver> splitting by index.
09:03:31 <elliott> well, sure
09:03:34 <quicksilver> rather than splitting by position in the seq
09:03:49 <quicksilver> you can do a Seq of lines, say.
09:03:58 <quicksilver> and a one-off seek to a given character position is not hard.
09:04:04 <quicksilver> (ByteString.length is fast)
09:04:16 <quicksilver> I mean, you're right, there are ways to build cleverer custom fingertrees.
09:04:17 <misterbeebee_> Yeah, I think the Ropes implementations are FingerTrees of ByteStrings
09:04:35 <elliott> misterbeebee_: right, but the fingertree package has the same fingertree used for Seq, more or less
09:04:39 <elliott> so if Seq is good, FingerTree should be too.
09:04:50 <ClaudiusMaximus> there's 'rope' and 'data-rope' and 'simple-rope' on hackage...
09:05:06 <misterbeebee_> yeah, I had an adventure with the rope packages yesterday
09:05:36 <misterbeebee_> Yeah, but Seq doesn't have that "pass through" where the measurements are over sub-objects of the elements.
09:05:37 <misterbeebee_> T
09:05:44 <misterbeebee_> That's what the rope packages add
09:05:45 <misterbeebee_> I a
09:05:47 <misterbeebee_> m l
09:05:49 <teneen> Why is Control.Monad.ST declared as "Untrusted"?
09:05:49 <gspr> elliott: http://hpaste.org/66126 <-- This is the Map version. The HashMap code is identical, save for the type name and the import.
09:05:56 <misterbeebee_> I am looking for minimum work for me :)
09:06:25 <quicksilver> misterbeebee_: well if Seq Char works, then maybe you're there already :)
09:06:26 <gspr> elliott: As I point out in the comments, the construction of the map is *really* nonsensical -- I just want some construction where I iteratively insert things into the map, and possible alter the map at each step
09:06:42 <quicksilver> but if you wish to reduce memory requirements, a Seq of slightly bigger chunks would be quite logical.
09:07:00 <elliott> gspr: looks like a good test-case to me -- but try making the x parameter of go strict
09:07:16 <gspr> elliott: I'll try that right away
09:07:45 <teneen> Why is Control.Monad.ST declared as "Unsafe"?
09:08:17 <misterbeebee_> quicksilver: absolutely, if one is willing to write extra code on top to keep the measurements working and get the memory savings :-)
09:08:31 <gspr> elliott: I'll also note the following: As it stands now, the Map code runs in 7 seconds. The lazy HashMap in 2 minutes, 44 seconds. The strict HashMap in 2 minutes 4 seconds. I haven't profiled memory yet (my original intention), but the HashMaps seem to use more.
09:08:38 <rwbarton> naturally there are space/time tradeoffs here but when I needed a Seq ByteString I determined that it'd be pretty crazy to have chunks of fewer than 64 bytes
09:09:11 <gspr> (this is all -O2 with GHC 7.0.3)
09:09:20 <rwbarton> since a ByteString value has about 64 bytes of overhead (well, 8 words, was on a 64-bit system)
09:10:24 <quicksilver> rwbarton: were you comparing to Seq Char though?
09:10:42 <quicksilver> rwbarton: I'd think even a Seq of 8-byte bytestrings would be better than a Seq Char....
09:10:58 <rwbarton> oh sure
09:11:09 <elliott> <teneen> Why is Control.Monad.ST declared as "Unsafe"?
09:11:13 <elliott> it has unsafeIOToST, IIRC
09:11:22 <quicksilver> a Seq of lines might be reasonable for a text editor
09:11:22 <elliott> Control.Monad.ST.Safe works in 7.2 or was it 7.4 and up
09:11:27 <quicksilver> just because that's the natural construct.
09:11:33 <quicksilver> (well, if it's line based in some sense)
09:11:46 <gspr> elliott: AHA! Stricting up the x parameter of go did *wonders*
09:11:52 <elliott> gspr: thought so.
09:11:55 <elliott> you weren't measuring the libraries at all
09:11:59 <elliott> just a massive build-up of thunks :)
09:12:17 <elliott> (well, mostly - obviously they still differ here - but you want that x parameter strict anyway)
09:12:17 <gspr> elliott: So many hours wasted... damn thunks, I both hate and love you bastards
09:12:24 <gspr> elliott: Thanks a bunch for that
09:12:31 <misterbeebee_> quicksilver: Yi text editor uses fingertrees of something, not sure if it is char or bytestring or custom.
09:12:36 <teneen> elliot: thanks
09:12:37 <elliott> gspr: i hope that improvement works for your original code too :)
09:12:51 <gspr> elliott: I'm crossing my fingers :)
09:13:17 <gspr> elliott: Do you have some words of wisdoms (or waving of hands) as to why Map worked fine with x lazy, while HashMap was really hit hard?
09:21:00 <ClaudiusMaximus> gspr: fwiw, with ghc-7.4.1 -O2, Data.Map -> 7 seconds and Data.HashMap -> 1.6 seconds, without changing your code  (i did cabal install --enable-optimization=2 hashmap)
09:21:36 <elliott> gspr: not sure.
09:21:41 <ClaudiusMaximus> (apart from the types; i meant no added strictness)
09:21:44 <elliott> maybe report it anyway?
09:22:24 <gspr> elliott: OK. Thanks again. I'll try to cook up some more/clearer examples before reporting.
09:22:32 <gspr> ClaudiusMaximus: Wow, that's very interesting!
09:22:58 <ClaudiusMaximus> gspr: probably ghc improved its strictness analyser
09:23:17 <gspr> ClaudiusMaximus: By quite a bit it seems. Yum!
09:24:12 <amindfv> Why is this only parsing til the first match of the delimiter pattern?:
09:24:22 <amindfv> sepBy (manyTill anyChar (try (string "tin"))) (string "tin")
09:24:23 * hackagebot scotty 0.3.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.3.0 (AndrewFarmer)
09:24:58 <misterbeebee_> huh, any rules of thumb on whether when to use  --enable-optimization on cabal installed packages in general?
09:24:59 <misterbeebee_> Since I'm so bad at efficient Haskell, I put faith in O2, but the doc says O1 is default for cabal install.
09:25:23 <amindfv> I thought sepBy alternated between matching its first and second arguments, until each failed
09:25:59 <dcoutts_> misterbeebee_: generally as a user you don't need to do anything, as a package author, if you can measure meaningful performance improvements then you can set -O2 in the .cabal file
09:26:11 <misterbeebee_> ok thx
09:26:22 <ClaudiusMaximus> misterbeebee_: i got into the habit of always using --enable-optimization=2 but i have a fast machine and plenty of time to wait around (with profiling on too, it took ~15mins to install graphviz iirc)
09:27:06 <quicksilver> amindfv: no, sepBy won't let the separator be the last thing.
09:27:21 <dcoutts_> ClaudiusMaximus, misterbeebee_: btw a shortcut for that is -O2
09:27:42 <dcoutts_> or use -O0 for when hacking on a package
09:27:43 <ClaudiusMaximus> dcoutts_: ooo, great!  is there a shortcut for --enable-executable-profiling  too?
09:28:05 <dcoutts_> ClaudiusMaximus: no, you can see these short and long options in the --help output
09:28:14 <ClaudiusMaximus> ok
09:28:18 <ClaudiusMaximus> thanks :)
09:28:30 <dcoutts_> there's -p for lib profiling, but no short options for exes
09:28:41 <amindfv> quicksilver: it stops parsing though, after the first match of the "manyTill." the behavior is the same as if I were just using manyTill, with no sepBy at all
09:29:19 <amindfv> here's an example, that doesn't end with the delimiter:
09:29:29 <amindfv> parse (sepBy (manyTill anyChar (try (string "tin"))) (string "tin")) "(stdin)" "testing, testing, tin can"
09:29:51 <gspr> elliott: My real-world code saw a running time improvement of about 20% after switching to HashMap. Memory usage no longer explodes, although it's still significantly higher than with Map. I'll see if I can isolate the latter. Thanks a bunch for your insights :)
09:30:26 <amindfv> it just returns Right ["tes"]
09:30:35 <gspr> (After adding strictness to my code, that is)
09:32:24 <quicksilver> amindfv: your manyTill consumes the first "tin"
09:32:33 <quicksilver> amindfv: which means that "tin" can't be the separator.
09:33:43 <amindfv> quicksilver: I thought that the "try" would make it lookahead without consuming?
09:34:26 <elliott> gspr: :)
09:34:57 <quicksilver> amindfv: no.
09:35:02 <quicksilver> amindfv: that is not what try does.
09:35:10 <quicksilver> try just makes it backtrack if it fails
09:35:23 <quicksilver> (try blah) still consumes all of blah it it succeeds.
09:36:30 <amindfv> quicksilver: thanks; that's good to know...
09:37:25 <amindfv> is there something like "try" that backtracks on success also?
09:37:42 <quicksilver> not really.
09:37:58 <quicksilver> there is lookAhead but it is sometimes fiddly
09:38:35 <amindfv> am I approaching this problem wrong? it seems like a very common use for Parsec
09:39:01 <quicksilver> probably yes
09:39:10 <quicksilver> there are lots of different ways of approaching any particular parsing problem
09:39:24 <quicksilver> your example seems pathological to me.
09:39:40 <amindfv> in what way?
09:39:41 <quicksilver> but maybe you have something more natural in mind and this is just you experimenting on an extreme example.
09:40:16 <misterbeebee_> BTW, I am bubbling with excitement over writing my first Haskell program that efficiently makes >1million edits to a 10MB data.
09:40:24 <misterbeebee_> It's still a bit buggy, but I got runtime down from "let it run overnight" to "2 minutes", and learned a lot about Haskell data structures along the way.
09:40:37 <misterbeebee_> It's so fast that I  have a nagging doubt that I somehow am not actually computing the results.
09:40:43 <misterbeebee_> This moment has been years in the making. :-) Hooray for Data.Sequence + STUArray + MVector + #haskell.
09:41:10 <amindfv> ack, have to run; thanks for your help quicksilver
09:41:18 <Philippa> will we ever have an STFUArray?
09:41:26 <Philippa> (but also: congrats)
09:41:33 <hpc> what would 'F' mean?
09:41:44 <misterbeebee_> Functional!
09:42:17 * quicksilver wonders what Philippa thinks of parse (sepBy (manyTill anyChar (try (string "tin"))) (string "tin")) "(stdin)" "testing, testing, tin can"
09:42:22 <Philippa> well, you could change the U as well?
09:42:38 <quicksilver> Philippa: it seems pathological to me but I can't quite explain why
09:42:56 <quicksilver> (it doesn't work because the manyTill consumes the 'tin', I"m not sure if lookAhead would work)
09:43:08 <quicksilver> does manyTill anyChar (lookAhead foo) work?
09:43:34 <Philippa> heh, I've seen this case before at least
09:46:01 <quicksilver> hmm
09:46:02 <quicksilver> parse (sepBy (manyTill anyChar (try (lookAhead (string "tin")))) (string "tin"))
09:46:06 <quicksilver> nearly works
09:46:15 <quicksilver> it just gets upset because there is no final tin
09:46:24 <quicksilver> (but if there is a final tin, then that's another element...)
09:54:23 * hackagebot sandlib 0.0.2 - SAND data serialization and manipulation library  http://hackage.haskell.org/package/sandlib-0.0.2 (MahmutBulut)
10:00:16 <tzxn3> http://pastebin.com/raCWXhsJ
10:00:17 <mauke> The paste raCWXhsJ has been copied to http://hpaste.org/66119
10:00:25 <tzxn3> I still can't solve this problem
10:00:44 <tzxn3> hitting adds a large number of cards to the hand
10:00:47 <tzxn3> instead of just one
10:05:12 <byorgey> tzxn3: you pass the arguments to hit in the wrong order
10:05:27 <byorgey> tzxn3: hit assumes the first argument is the deck and the second is the player hand
10:05:36 <byorgey> tzxn3: but in playerTurn you have   hit phand d
10:06:10 <byorgey> so it's not that hitting adds a large number of cards, it's that hitting switches the player's hand with the entire remaining deck
10:06:37 <c_wraith> seems likely to bust
10:06:52 <byorgey> a bit
10:07:31 <mk> which monad tutorial has the highest chance of completely teaching me what monads are?
10:07:51 <c_wraith> mk: of the ones I've seen, none.
10:07:53 <Clint> do you need to know what monads are?
10:08:02 <Philonous_> Is there a canonic way to convert a UTF8-encoded CString to Text?
10:09:02 <c_wraith> mk: Monad is just an interface. What it "is"... people look for too much depth. Why don't people ever ask the same question in java land: "What tutorial has the best chance of telling me what an Observable *is*?"
10:09:12 <rata_> hi everybody
10:09:43 <mk> I'd like to know, yes. As far as I've gotten now, I understand that something is done to functions such that they can accept a datastructure consisting of (orginigal arguments, monadic stuff), and the output is re-wrapped with the "monadic stuff" attached. And functions can be chained.
10:10:10 <c_wraith> mk: it's a composition pattern for functions involving types with kind * -> *
10:10:24 <c_wraith> mk: if that doesn't answer the question, you're looking for more answer than there is.
10:10:53 <mk> I'm finding the mathematical tutorials hard to follow, and while I'm alright with the sillier analogy ones, they seem to trail off and I don't learn what monads actually are
10:11:10 <mk> c_wraith: what's a composition pattern?
10:11:12 <c_wraith> mk: that's because monads aren't actually anything like what you're looking for
10:11:45 <c_wraith> mk: composition as in "function composition".  pattern as in "design pattern"
10:12:04 <c_wraith> mk: quit thinking there's more to them than that. There isn't.
10:12:19 <mk> I've read that they are more of a pattern than anything definite, but this is confusing because obviously there are concrete monads
10:12:30 <byorgey> mk: can you recite the precise types of the Monad type class methods?
10:13:04 <mk> byorgey: if I cheat by checking with one of my open internet tabs, then yes
10:13:12 <byorgey> mk: that doesn't count.
10:13:39 <byorgey> mk: go stare at the types, and try implementing several example Monad instances.
10:13:58 <Philonous_> It's strange how people don't seem to be so confused about the Monoid class. I wonder whether it's the higher-kinded polymorphism that entangles them. But then why Monad, not Functor?
10:14:00 <byorgey> only when you've mastered that does it really make sense to come back to thinking about "what they are" at a higher, more intuitive level.
10:14:18 <mk> (also, I know very little of haskell, but I'd like to learn what monads are without first learning half of haskell, if possible)
10:14:24 <byorgey> otherwise you will just be full of confused, vague notions.
10:14:24 <c_wraith> Hmm.  I need to work on that wording. ".. for functions *returning* values with the kind * -> *" is more accurate
10:14:27 <rata_> mk: have you tried reading LYAH's chapter about monads? I found that really useful to understand them
10:14:41 <c_wraith> mk: do you know java?
10:15:35 <ClaudiusMaximus> Philonous_: i'm guessing  packCString :: CString -> IO ByteString and decodeUtf8' :: ByteString -> Either UnicodeException Text
10:16:01 <Philonous_> ClaudiusMaximus:  Ah, so it's via ByeString. I thought as much. Thanks!
10:16:32 <mk> rata_: I haven't, though I've started reading yaht's io chapter until it lost me, as well as its monad chapter
10:17:04 <mk> c_wraith: yes, and javascript, and a bit of clojure
10:17:10 <ClaudiusMaximus> (there's unsafePackCString that might save a copy, but i wouldn't want to risk it in case Text at some point uses the original ByteString without making a copy)
10:17:23 <Philonous_> mk:  Monads are actually independent of Haskell. Moggi first introduced their use as a tool to formalize semantics here: http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf
10:17:32 <c_wraith> mk: are you familiar with java.util.Observer ?
10:18:32 <rata_> mk: read LYAH, it's the best I've seen so far at explaining monads in haskell
10:18:41 <hpc> ^
10:19:21 <mk> c_wraith: it's a listener interface, it seems
10:19:45 <c_wraith> Philonous_: I think the problem is too much "about haskell" material talks about monads like they're important. It makes people assume they are, long before they have the experience and familiarity with the type system to understand how slim of a pattern it actually is.
10:20:14 <hpc> c_wraith: by newbies for newbies, i say :P
10:20:28 <DijkstraGroupie> Hello. I want to make an infinite list such that (a !! i) - (a !! (i - 1)) = b if i is even, and c if i is odd. How do I do that?
10:20:52 <DijkstraGroupie> For example: [8,11,18,21,28...]
10:21:17 <c_wraith> mk: well.  If I asked you what an Observer is, wouldn't you think that's a question that assumes a lot of complexity that just isn't there?
10:21:17 <rwbarton> > scanl (+) a $ cycle [b, c]
10:21:18 <lambdabot>   [a,a + b,a + b + c,a + b + c + b,a + b + c + b + c,a + b + c + b + c + b,a ...
10:21:41 <DijkstraGroupie> rwbarton: Thanks.
10:22:02 <hpc> :t scanl
10:22:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:22:24 <Philonous_> c_wraith:  Why would anyone even mention them in such a setting (unless he doesn't know the first thing about them)
10:22:43 <mk> c_wraith: I'd start explaining listeners to you. I'd probably also have to make sure that you understood objects, and the sort of encapsulation needed in order for an object to ensure that it controls its own changes
10:22:55 <misterbeebee_> mk: Maybe look here http://www.haskell.org/haskellwiki/Typeclassopedia, and then come back to Monad after you feel comfortable with Functor and Applicative.
10:22:57 <misterbeebee_> Until then, just use IO/Maybe/List as each their own, and don't worry about the fact that are all instances of moads.
10:23:07 <misterbeebee_> *instances of monads.
10:23:11 <mk> c_wraith: so it depends on how much you actually know, I guess
10:23:15 <hpc> *instances of Monad
10:23:46 <c_wraith> mk: But that's not what I'm talking about.  I just want to know what an observable *is*. I mean, there are all kinds of concrete instances, so they must be something, right?
10:24:19 <mk> misterbeebee_: perhaps that's the only way that'll work in the end, but the fact that the page you linked is huge is somewhat offputting
10:25:25 <yitz> c_wraith: that question will confuse an oo programmer, because the whole paradigm is based on abuse of the poorly defined semantics of the word *is*.
10:25:53 <c_wraith> yitz: that kind of is my point, though...
10:26:37 <rata_> mk: do you understand functors?
10:26:42 <misterbeebee_> I don't think you'll get anything more than "Monads are like CFL light bulbs" without reading at least that much text.   That page is really nice, and if it's too much for you at first, then you really should just play with IO/Maybe/List until you get a feel for what abstract sense they have in common.
10:26:58 <hpc> whenever i hear someone say "what's a monad" i imagine them thinking "what the hell does (>>=) do?"
10:27:29 <mk> c_wraith: ok, a concrete observable is an object (which is an ugly mess of state, data, and functions) that can be asked to inform another object whenever its state is changed in a particular way
10:27:37 <hpc> bind has a pretty confusing type for newbies, and took me a while to not be disoriented by it
10:27:55 <yasar> a monad is a monoid in the category of endofunctors, what's the problem? :D
10:28:19 <hpc> yasar: a monad is a monad in the 2-category of categories! none of that endofunctor nonsense ;)
10:28:22 <misterbeebee_> http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem :-)
10:28:33 <yasar> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
10:28:39 <mk> rata_: no, in the (many) examples I've read, functors aren't explained very well. My vague notion is that they are some sort of supertype of functions
10:28:49 <dfletcher__> yasar, haha I just read that blog post yesterday
10:28:59 <c_wraith> mk: So that answer is "they aren't anything more than the interface".  That's basically true of monads, too.  Just learn the type signatures of return and (>>=). That's all you really need.
10:28:59 <hpc> @src Functor
10:29:00 <lambdabot> class  Functor f  where
10:29:00 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
10:29:02 <yasar> hpc: I was just kidding :D
10:29:06 <rata_> mk: then you should start here http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
10:29:16 <hpc> yasar: i know, just being annoying
10:29:28 <rata_> mk: and then go here http://learnyouahaskell.com/functors-applicative-functors-and-monoids
10:29:36 <mk> just to check - there is a concrete point at which one can confidently say "oh, I get monads", right?
10:29:55 <c_wraith> mk: yeah. It's approximately the point where you say "oh, is that all?"
10:29:57 <c_wraith> :)
10:30:01 <hpc> mk: for me, that point was "oh hey, i can write my own and it compiles"
10:30:05 <hpc> also what c_wraith said
10:30:18 <misterbeebee_> The #2 answer there got a bunch of upvotes for a concrete minimum-jargon explanation, but earned a comment "but it would not capture the full generality of the monad."
10:30:26 <rata_> yes, it's like what c_wraith says
10:30:40 <c_wraith> I like how James Iry has said he accidentally google-bombed himself with that blog post and the phrase "mostly wrong"
10:32:09 <c_wraith> So that now if you search google for "mostly wrong", he's the #1 result. Not the legacy he wanted. :)
10:32:18 <tzxn3> byorgey: haha
10:32:24 <tzxn3> I knew it would be something silly like that
10:32:36 <mk> if monads elicit the "oh, is that all" response, why are they so difficult to explain?
10:33:07 <mk> can I create monads in, say, java, or do I require real functions?
10:33:19 <c_wraith> mk: because the type of (>>=) is kind of complicated, and the pattern is pretty abstract
10:33:23 <misterbeebee_> Because they are a very abstract concept. And abstract concepts are only intuitive when you have a lot of concrete instances in your intuition.
10:33:45 <c_wraith> mk: you can create monads in any language. Creating a common interface for them like haskell has is a lot harder, though.
10:33:53 <mk> rata_: thanks for the links by the way, they'll be the first ones I start reading
10:34:14 <c_wraith> mk: you basically need something roughly equivalent of the haskell98 type system to abstract out the monad interface
10:35:17 <byorgey> mk: monads are simple but deep.  It's like learning to play chess. You can learn the rules in 15 minutes but it takes a long time before you feel like you really "get" chess.
10:35:19 <elliott> <mk> rata_: no, in the (many) examples I've read, functors aren't explained very well. My vague notion is that they are some sort of supertype of functions
10:35:24 <elliott> mk: that's the C++ meaning of them
10:35:27 <elliott> unrelated to the Haskell meaning
10:35:31 <mk> why are monads described as protecting the rest of the language from dangerous things?
10:35:37 <elliott> mk: as far s "if monads elicit the "oh, is that all" response, why are they so difficult to explain?", they aren't
10:35:40 <elliott> *as
10:35:45 <misterbeebee_> I think that's the key: You can implement Maybe, List, and such in Java, but implementing the typeclass Monad is hard to do faithfully in a language without Haskell's mathematical basis.
10:35:47 <elliott> "monads r hard" just FUD
10:35:50 <elliott> *is just
10:35:57 <elliott> mostly spread by people who don't really know haskell
10:35:59 <c_wraith> mk: those descriptions are lies. the IO type protects the rest of the language.  The fact that IO happens to be a monad by construction is irrelevant.
10:36:01 * byorgey doesn't agree.
10:36:10 <elliott> and this ends up being a self-fulfilling prophecy because people expect it to be really hard
10:36:17 <byorgey> Learning the definition of the Monad type class is easy.
10:36:20 <Mathnerd314> elliott: monads require learning, learning is hard
10:36:33 <Mathnerd314> elliott: at least according to 90% of the population
10:36:34 <mk> c_wraith: ok - but at least monads are capable of protecting the language?
10:36:38 <byorgey> Getting your head around what it really means, why you would care, when and how to use it, etc. IS really hard.
10:36:42 <elliott> mk: no, monads are just an interface
10:36:50 <c_wraith> mk: monad is just an interface.
10:36:53 <elliott> byorgey: sure - but all you really need is the former, the only way to develop the latter is experience
10:36:56 <elliott> mk: they're not even built in to the language
10:37:03 <elliott> mk: they're defined in the standard library, just like functors etc.
10:37:09 <Mathnerd314> elliott: do-notation
10:37:15 <elliott> (in fact, a monad is just a special type of functor.)
10:37:20 <byorgey> elliott: agreed.  But most people are thinking of the latter when they think about "learning monads".
10:37:32 <byorgey> elliott: so to say "monads are easy" is misleading at best.
10:37:33 <c_wraith> Mathnerd314: technically, desugars to function calls that need not have anything to do with monads.
10:37:38 <c_wraith> > do 5 :: Int
10:37:39 <lambdabot>   5
10:37:39 <mk> hmm. Saying that it's just an interface is like saying Observer is just an interface - it is, but you won't know what an observer is all about until you say what you can do with one
10:37:42 <elliott> byorgey: possibly - i think most people think they need to do the latter to use monads, whereas they actually only need to do the former
10:37:48 <elliott> "monads are easy" is probably too far
10:38:00 <elliott> they're certainly a bit alien to an imperative mindset
10:38:07 <elliott> but I think "hard" is also too far
10:38:16 <elliott> mk: yep, but that was in reply to "protecting the language"
10:38:20 <c_wraith> mk: and the answer is "the monad interface lets you compose functions that return types with the kind * -> *"
10:38:21 <byorgey> I strongly disagree that you only need to know the definition of the Monad type class in order to use monads.
10:38:26 <dfletcher__> the monad chapters in learnyouahaskell are a bit harsh. I was cranking through the book till I hit those and then it slowed to treacle speed.
10:38:35 <elliott> mk: in fact, we don't even need Monad to do IO.
10:38:42 <elliott> Monad is just a really convenient interface for doing IO, so it's the one we use
10:38:42 <byorgey> I base this on experience teaching them.
10:38:43 <c_wraith> mk: it's a very *abstract* interface
10:38:56 <elliott> byorgey: well, it's all you need to start using _specific_ monads
10:38:59 <c_wraith> mk: but that's why instances of it can be so vastly different.
10:39:05 <elliott> which can then develop into a more general understanding
10:39:37 <byorgey> but even using specific monads requires gaining some understanding of what the monad operations mean in that specific context.
10:39:41 <byorgey> and that can be hard.
10:40:16 <elliott> agreed
10:40:21 <mk> are monads a family concept - a grouping of things that might have certain things in common with some other members of the group, but nothing in common with all other members? It's just that the whole group is defined by a nebulous commonality between parts?
10:40:24 <elliott> but I'd call that learning the details of the instances, not of Monad itself
10:40:37 <elliott> mk: the whole group is defined by the commonality of having the two operations Monad does
10:40:39 <byorgey> mk: yes, although the commonality is not nebulous.
10:40:46 <c_wraith> mk: the commonality is "they support these operations"
10:40:48 <elliott> mk: that has to be a very large, and hence diverse group
10:41:00 <mk> can you specify nec and suffic conditions for what a monad is?
10:41:02 <elliott> mk: some monads are containers, some describe computations of a sort, some are too abstract to describe as either of those
10:41:17 <elliott> mk: the conditions would be the definition of the typeclass itself
10:41:23 <elliott> but that's unlikely to lead you straight to enlightenment.
10:41:25 <byorgey> mk: yes. it is necessary and sufficient to support the operations in the Monad type class.
10:41:45 <elliott> mk: are you reading LYAH/RWH?
10:41:46 <misterbeebee_> elliott: well, plus the laws, which aren't enforced by the definition.
10:42:10 <elliott> usually, the best thing is to realise you don't *need* to "learn monads" right now, and just continue at the pace of the tutorial, which will cover them -- then you can check out the Typeclassopedia afterwards to get a deeper understanding
10:42:15 <mk> ok, great - that's reassuring. When I read "the interface is very vague", I get a bit lost
10:42:45 <elliott> vague no, abstract yes
10:42:49 <misterbeebee_> where did you read "the interface is very vague"?
10:43:13 <kallisti> I think the "monads sure are tricky! you're going to have trouble with them!" just kind of reinforces the psychological barriers to learning monads.
10:43:35 <elliott> mk: you can think of Monad basically like a design pattern -- one that typical imperative languages aren't well-suited to encoding, and probably one too abstract to make it into a book of them
10:43:48 <elliott> (though you can develop a very helpful concrete intuition about Monad, and other typeclasses, through using them)
10:44:09 <elliott> (but it's hard to describe that kind of understanding, it's just something you gain with experience)
10:44:37 <hpc> you can kinda bootstrap the intuition yourself from the "dirty" explanations of different concrete monads
10:44:38 <misterbeebee_> mk, you might also find this helpful: http://stackoverflow.com/questions/2704652/monad-in-plain-english-for-the-oop-programmer-with-no-fp-background, with an answer from Eric Lippert
10:44:43 <byorgey> kallisti: sure.  On the other hand, "monads are easy!  you won't have any trouble with them!" is no better, because as soon as someone runs into trouble they now think they are stupid.
10:44:50 <hpc> like "Maybe is plain old calculation with short-circuiting"
10:45:01 <mk> elliott: I'm not learning haskell at the moment - I've heard about monads as a magical programming construct (much like one hears about lisp macros, and functional closures, and clojure protocols) and I want to know what they are... because it is proving difficult to learn what they are
10:45:15 <hpc> "Reader is a calculation where you can ask for the value of a 'global constant'"
10:45:18 <hpc> etc
10:45:23 <elliott> I don't find that Lippert answer helpful, really
10:45:32 <elliott> it's too vague and borders on misleading in parts
10:45:50 <elliott> mk: right, well, don't take "learn what a monad is" as your goal
10:45:58 <Jafet> Monads are like bad analogies.
10:46:03 <c_wraith> I feel like the best answer for "what is a monad" is "don't worry about it."
10:46:06 <elliott> mk: you're unlikely to accomplish that goal without having your real go be "learn haskell"
10:46:28 <elliott> I can definitely say that Haskell would be a rewarding and valuable thing to learn even if monads never got imported from category theory.
10:46:33 <misterbeebee_> mk: could you explain what a List macro is to a non-Listp programmer? Not usefully and meaningfully, I'd say, beyond selling some vague benefits.
10:46:44 <misterbeebee_> argh, *Lisp
10:46:52 <elliott> (listp 'lisp)
10:47:16 <hpc> misterbeebee_: you get to modify your entire program at runtime!
10:47:19 <hpc> ;)
10:47:19 <mk> what's a list of things that I should be able to check off, and know that I know what monads are? #1 seems to be "oh, is that all?", which has not yet occurred (because I suspect that I need to know how monads are used - I think the point about chess someone brought up earlier was good)
10:47:23 <misterbeebee_> > #t
10:47:24 <lambdabot>   <no location info>: lexical error at character 't'
10:47:29 <hpc> (i got vague AND misleading, there)
10:47:40 <kallisti> hpc: I thought macros were comp -- oh okay.
10:47:51 <kallisti> that's the misleading part, I guess.
10:48:06 <misterbeebee_> silly lambdabot doesn't know lisp.
10:48:07 <elliott> mk: you don't
10:48:17 <elliott> mk: you just realise that you already knew what they were at some point
10:48:20 <Jafet> hpc: but how does that make lisp better than php?
10:48:28 <elliott> mk: like i said, set "learn monads" as your goal, and you will assuredly fail
10:48:40 <hpc> Jafet: because PHP programmers use PHP, duh
10:48:43 <mk> #2 - I will realize that I already knew what they were ;)
10:48:48 <elliott> usually it clicks before you realise it clicks
10:49:07 <elliott> anyway, learning haskell is definitely a _requirement_ for learning how it uses monads
10:49:08 <DMcGill> mk: one thing could be to understand why the filterM (const [True,False]) trick works
10:49:12 <elliott> unless you want the category theory definition :)
10:49:19 <elliott> DMcGill: i doubt that would help if mk doesn't know any haskell
10:49:25 <Peaker> Learning Functors is pretty easy -- just learn about covariance/contravariance/invariance
10:49:28 <mk> DMcGill: no knowledge of haskell yet :)
10:49:43 <hpc> i doubt anything will help if mk doesn't know a language that can express the idea of monads
10:49:54 <mk> will I absolutely need to understand functors before I understand monads?
10:50:14 <Peaker> mk: it's pretty easy to understand what a Functor is, it might take 10-15 minutes
10:50:18 <hpc> mk: not quite "absolutely", but you'd be crazy not to
10:50:22 <mk> (by understand, I don't just mean be able to define, I mean be able to competently use because I understand various implications)
10:50:26 <hpc> mk: kind of like learning multiplication before addition
10:50:38 <elliott> mk: functors -> applicative functors -> monads is the standard hierarchy. but really, a checklist approach is doomed to failure
10:50:46 <elliott> it's much more of an absorption.
10:50:47 <Peaker> mk: Do you know what type constructors are? What the kind "* -> *" means?
10:51:12 <mk> http://learnyouahaskell.com/functors-applicative-functors-and-monoids is this among the best places to learn what a functor is, if I know nothing of haskell?
10:51:14 <elliott> mk: I recommend you start with Learn You a Haskell, then read the Typeclassopedia when you feel you need a deeper understanding. but if you don't want to learn Haskell for its own sake, you will get impatient.
10:51:15 <elliott> no
10:51:25 <elliott> learn you a haskell is a book about haskell, not a book about functors, you have to read the rest of the book first
10:52:00 <mk> elliott: which way do those arrows point? monads are a type of functors?
10:52:26 <elliott> all monads are applicative functors. all applicative functors are functors.
10:52:45 <elliott> functors are a very, very simple and general concept. but that chapter won't make any sense to you if you don't know haskell
10:52:54 <DMcGill> mk: you should decide if you want to learn them from the pov of category theory or programming. Whichever you pick, you need to learn the basics of that side before you can move to monads
10:53:04 <misterbeebee_> To me there are two reasons to learn topic X: Because X is a goal to motivate your learning a bunch of stuff leading up to X, or because X is needed to reach goal Y. Your reason for learning affects how you approach the learning.
10:53:32 <DMcGill> Given that you're asking in #Haskell, I recommend making your way through lyah
10:53:35 <misterbeebee_> either way, you do best learning in a building-up order, not grabbing advanced concepts like trivia
10:53:47 <DMcGill> then when you get to the chapters on monads, you'll understand it easily
10:53:53 <misterbeebee_> *like they are trivia
10:53:55 <ziman> @unpl (f >>= \x -> g >>= \y -> h x y)
10:53:55 <lambdabot> (f >>= \ x -> g >>= \ y -> h x y)
10:54:01 <ziman> @pl (f >>= \x -> g >>= \y -> h x y)
10:54:01 <lambdabot> (g >>=) . h =<< f
10:54:02 <kallisti> I'm currently using 10 language extensions in a single module. As an aspiring Haskell professional, does doubling the number of extensions by next week sound like a worthy goal?
10:54:04 <mk> Peaker: I took that to be a special type of thing, such that, yes, you have the thing, but if you'd like a "thing that doesn't yield a thing when given a thing", you need to give it a thing
10:54:19 <misterbeebee_> even for trivia, learning a subject area deeply is teh best way to become a trivia master in that area.
10:54:51 <hpc> kallisti: that's a lot of extensions
10:55:02 <kallisti> oh wait I can cut that down to 8.
10:55:17 <rata_> mk: you don't know any haskell?
10:55:24 <kallisti> I was using undecidable so that I could ignore my broken typeclasses and resolve unrelated errors.
10:55:31 <kallisti> and flexiblecontexts isn't needed either.
10:55:43 <Peaker> mk: I'm not sure what you said now :)
10:55:56 <elliott> mk: I don't know what you meant by that, but I'm pretty sure it's not what Peaker meant by (* -> *) :P
10:56:13 <rata_> mk: how much of clojure do you know?
10:56:16 <mk> misterbeebee_: my reason for learning about monads is that I feel uncomfortable not understanding what tutorials are talking about past a certain point
10:56:17 <elliott> but seriously: learn haskell. you'll learn a lot more than just monads
10:56:26 <kallisti> NoMonomorphismRestriction isn't technically needed either, now that TypeFamilies did strange things to inferrence and required me to add a bunch of type signatures..
10:56:29 <elliott> mk: LYAH doesn't throw "monads monads monads" at you at all
10:56:36 <kallisti> but I feel like I should keep it, as a matter of principle. :P
10:56:40 <elliott> it barely even talks about them before they're relevant, and you're not going to have to use the interface blindly before that point.
10:56:41 <misterbeebee_> playing the 5 Whys: why are you reading those tutorials?
10:56:55 <hpc> when i was learning haskell, lyah wasn't done yet
10:57:05 <hpc> and i was annoyed by how little it mentioned monads
10:57:26 <elliott> haha
10:57:33 <mk> rata_: I'm not sure, I'm new to it, but I get some of the basics. I understand protocols, for example, but I'm still hazy with namespaces/let/bind etc.
10:57:33 <kallisti> okay 7 extensions is a bit more reasonable.
10:57:46 <elliott> mk: another important thing to realise is that monads are by far not the only interface of their sort in haskell.
10:58:03 <elliott> there are many, many general interfaces along the same lines.
10:58:11 <Peaker> mk: Monads are a relatively advanced Haskell thing.. so many more basic things to learn first
10:58:15 <elliott> Monoid, Functor, Applicative, Category, Arrow...
10:58:26 <elliott> Foldable, Traversable...
10:58:38 <hpc> Arrow is a fad
10:58:41 * hpc ducks
10:58:54 <c_wraith> hpc: you'd actually get a lot of agreement with that here. :)
10:59:07 <kallisti> I don't know if I would call it a "fad"..
10:59:24 <kallisti> I don't know of any trendy Arrow users
10:59:39 <c_wraith> kallisti: that just means it's already on the downswing
10:59:45 <kallisti> ha. I see.
10:59:48 <elliott> hpc: it might suck, but I never said my list is filled with non-sucking things :P
11:00:06 <kallisti> I use Arrow to pointfree-icate some tuple functions now and then.
11:00:14 <kallisti> that's about it.
11:00:15 <Peaker> > sequenceA (1, Just 3)
11:00:16 <lambdabot>   Not in scope: `sequenceA'
11:00:42 <mk> what are the most simple particular monads?
11:00:42 <Peaker> > Data.Traversable.sequenceA (1, Just 3)
11:00:43 <lambdabot>   No instance for (Data.Traversable.Traversable ((,) t))
11:00:44 <lambdabot>    arising from a us...
11:00:53 <Peaker> Why is (,) t  not Traversable?
11:01:19 <elliott> Peaker: almost nothing is traversable by default
11:01:21 <elliott> it sucks
11:01:30 <elliott> just [], Maybe, Array
11:01:52 <c_wraith> @instances Traversable
11:01:53 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
11:01:55 <elliott> mk: you're not taking the hint, are you :P
11:01:56 <Philonous_> mk:  data Id a = Id a; instance Monad Id where return = Id; Id x >>= f = f a
11:02:04 <rata_> mk: maybe you can try to understand monads in clojure if you want http://www.intensivesystems.net/tutorials/monads_101.html
11:02:05 <c_wraith> @instances-importing Data.Traversable Traversable
11:02:05 <lambdabot> Maybe, []
11:02:28 <c_wraith> But there are more instances than that.  Seq and Set in containers, for example
11:02:49 <elliott> well, ok
11:03:06 <mk> elliott: I'm trying not to learn two languages at the same time :)
11:03:26 <DMcGill> mk: you don't seem to be trying to learn Haskell!
11:03:37 <misterbeebee_> rata_: that tutorial reminded me what I like about Haskell having a syntax
11:03:38 <mk> Philonous_: I don't follow the notation
11:04:09 <elliott> mk: then learn clojure first and come back :P
11:04:11 <mk> DMcGill: right. But I'd like to know what monads are
11:04:15 <elliott> clojure doesn't really use monads, so you'll be fine.
11:04:21 <elliott> or give up on clojure, but i doubt you want to do that
11:04:47 <DMcGill> that "notation" above was Haskell code, can't you just accept that to learn what monads are in the context of Haskell, you need to learn some Haskell first?
11:04:56 <Philonous_> mk:  Uh, that's haskell?
11:05:12 <elliott> what are you talking about? this is #monads, not #haskell
11:05:19 <elliott> that's why everybody asks us about monads
11:06:14 <mk> elliott: it should be possible to understand monads without understanding most of the rest of haskell. Learning something by osmosis is fine (and fun!), but it's... inefficient
11:06:20 <Philonous_> mk:  If you _really_ want to understand monads independently of haskell you will have to read Moggi's paper. It's either that or learn haskell
11:06:39 <DMcGill> if you want to learn monads without learning a programming language to do so, try #CategoryTheory
11:06:41 <elliott> mk: if you really want to try and do that, fine - the easiest way will be to pick up a  book on category theory
11:06:46 <elliott> i doubt it will satisfy you
11:06:52 <elliott> but #haskell cannot help such a silly aim
11:07:07 <mk> Philonous_: but I was told that monads are very easy to understand when I first asked...
11:07:19 <Philonous_> mk:  They are, when you know haskell.
11:07:23 <elliott> can you teach me what $clojure_concept is? I know nothing about Clojure. or electricity.
11:07:32 <misterbeebee_> I hung out with a math professor friend recently. He just recently got into programming, with JavaScript.
11:07:32 <DMcGill> or a different programming language with them in ofc
11:07:34 <misterbeebee_>  I gave him a mangled explanation of categories and monads in programming, and he instantly understood and explained it back to me in proper math terms.
11:07:36 <DijkstraGroupie> mk: If I understand correctly, a monad is just an encapsulation of a particular type of computation.
11:07:43 <elliott> DijkstraGroupie: nope
11:07:47 <mk> elliott: it depends, but yes
11:07:47 <misterbeebee_> so, getting a PhD in algebra is another route to understanding monads
11:07:56 <Philonous_> mk:  Or Category theory, lambda calculus and type theory. But My guess is you will learn haskell before that
11:08:02 <elliott> DijkstraGroupie: well, yes, but you have to make the definition of "computation" vaguer than you'd like to to make that work
11:09:12 <mk> so monads are in fact very difficult to understand
11:09:29 <DMcGill> it's like you're asking how to three point turn and we're telling you that you need to drive a car first. It doesn't have to be the car of Haskell and it could even be an abstract car but you can't learn one without some understanding of vehicles. Once you can drive however, it's very easy
11:09:31 <DijkstraGroupie> elliott: Maybe encapsulates computations that may fail or produce a single result. Lists encapsulate computations that may return any nonnegative number of results (maybe an infinite one!, hence lists as generators). IO encapsulates computations that have side-effects. Is this correct?
11:09:37 <copumpkin> mk: that's a function of your background
11:09:50 <Philonous_> mk:  For someone unwilling to learn the prerequisites, yes in-bloody-deed
11:09:51 <rata_> mk: I used that tutorial before learning haskell to try to understand monads and it uses a different viewpoint from the one haskellers normally use, so that's another way to understand monads without learning haskell... but after reading that tutorial I didn't feel like I really get them
11:10:03 <elliott> mk: no, they're not
11:10:14 <elliott> mk: but i don't see what you expect to get out of such a statement other than irritating people
11:10:21 <elliott> DijkstraGroupie: you can't prove a property of monads by proving it for finitely many examples of monads
11:10:29 <rata_> mk: to be difficult and to have a lot of prerequisites is not the same
11:10:32 <elliott> DijkstraGroupie: but it is true that the computation analogy is orders of magnitude closer than the container analogy.
11:10:46 <Philonous_> elliott:  Maybe you can if you prove it for _all_ finite sets?
11:10:49 <mk> copumpkin: sure, but if the only people saying "it's totally easy" all know haskell or category theory, my approach to learning monads is totally off (and I probably will have to learn one or the other)
11:10:56 <elliott> mk: addition is hard too, until you learn the natural numbers
11:11:10 <elliott> yes, we've told you your approach is off.
11:11:22 <elliott> note that nobody has actually said it's totally easy.
11:11:36 <misterbeebee_> elliott: what if you think of a "container" as  "header data and a pointer" , which is what a container is in a computer, and not a "container" like a "box in the real world"?
11:11:38 <elliott> just that it isn't a significant roadblock, or immensely difficult, as part of the normal process of learning haskell.
11:11:48 <copumpkin> mk: my usual approach is to tell haskell beginners to avoid them. They aren't crucial, and most people try before they have a good grasp of types, and get frustrated. The hype surrounding them is annoying, because it means a lot of people do try too early
11:11:49 <elliott> misterbeebee_: haskell doesn't know anything about pointers :)
11:12:01 <misterbeebee_> sorry, "reference" :)
11:12:02 <elliott> copumpkin: mk wants to learn monads without learning haskell, so...
11:12:10 <copumpkin> why?
11:12:17 <monochrom> to learn monads without haskell... that would be one of Moggi's papers
11:12:40 <elliott> copumpkin: because they're already learning clojure
11:12:41 <copumpkin> do you want to learn meromorphisms without learning complex analysis, too?
11:12:43 <copumpkin> oh
11:12:59 <copumpkin> well, the idea doesn't really make sense without types, but concepts from it can be extracted I guess
11:13:45 <mk> elliott: sorry, I really don't mean to frustrate people who are trying to help me understand something. It's just that the conversation started with "monads are just a sort of interface", and I was expecting to be able to get it after reading an appropriate tutorial, but now I have to learn a lot more, which is mildly discouraging
11:14:05 <monochrom> and to learn monads within haskell, what copumpkin says, you need to be fluent in the relevant kind of polymorphism first, i.e., going from "Maybe Int" to "m Int". it's why LYAH starts with Functor.
11:14:09 <elliott> well, those responses were made with the implicit understanding of someone learning haskell
11:14:18 <elliott> in which case, yes, they're just another interface for you to learn. no huge deal, you'll come to it.
11:14:32 <elliott> the reason it seems so different if you abandon that assumption is because it makes the goal absurd
11:14:48 <copumpkin> if you ignore the name and background and think of it as an abstract interface
11:14:52 <kallisti> I think this code would actually be more straightforward if I switched from monadic exceptions to IO exceptions..
11:14:54 <copumpkin> you just need to understand what the types mean
11:15:01 <misterbeebee_> When you need a monad to solve an actual problem you have, you will be able to learn enough to solve your problem. I promise.
11:15:08 <copumpkin> which honestly isn't that hard, but most people aren't used to thinking about interfaces that are that polymorphic
11:15:15 <copumpkin> call it "warm fuzzy thing" and try again
11:15:23 <elliott> misterbeebee_: in clojure? :)
11:15:23 <kallisti> because my monad type essentially acts as a base IO-like monad, it would make sense that its exceptions were also IO exceptions.
11:15:41 <kallisti> otherwise I find myself using both catchError and catch in most of the same places.
11:15:49 <mk> I'm not dead set on learning monads without learning haskell, I was just expecting that it could be done (short tutorials are misleading, I suppose)
11:15:50 <Philonous_> elliott:  I think it's perfectly reasonable to understand monads in their own right. As a matter of fact I think it is a folly to assume monads and haskell would be somehow related (other than that you can represent them there)
11:15:58 <shergill> i'm with copumpkin here. monads can be understood without haskell (assuming you have an understanding of the types). but you probably won't get much in terms of insight (since that needs more hands on experience)
11:16:05 <misterbeebee_> elliott: I believe that *if* "monad" is the correct answer to a question someone has, then they are in a position to understand it
11:16:05 <misterbeebee_> d it
11:16:14 <misterbeebee_> and if "monad" is not the answer, don't worry about "monad"
11:16:20 <shergill> though i'm sure you can implement monads in ocaml etc. so it's not bound to haskell
11:16:25 <monochrom> Moggi's paper is short enough. or at least you can skip enough of it
11:16:26 <elliott> misterbeebee_: fair enough
11:16:34 <elliott> Philonous_: yes, category theory is proof of that!
11:16:45 <elliott> but i rather expect mk doesn't want the abstract, mathematical side of it.
11:17:03 <elliott> mk: all tutorials, with a very small number of exceptions at most, that purport to teach monads are misleading
11:17:15 <elliott> usually to the point of being just wrong
11:17:31 <monochrom> Moggi's paper, feel free to skip the too-mathematical parts: http://www.disi.unige.it/person/MoggiE/ftp/lc88.pdf
11:17:45 <misterbeebee_> and btw, I believe that trying to understand X is an ill-formed request. Any X has many facets and levels, and we're constantly learning (and forgetting) more about all our Xes
11:18:13 <misterbeebee_> I've studied calculus 5 different ways in high school in college.
11:18:18 <misterbeebee_> for example.
11:18:19 <Philonous_> elliott:  Not only in CT but for programming language theory
11:19:00 <mk> elliott: I don't mind the mathematical side (I was very optimistic about http://unknownparallel.com/monads.php ,for example), but many of the tutorials start using terms that I'm not familiar with.
11:19:16 <monochrom> hrm, the whole paper is too mathematical, I wonder how I understood it in the first place!
11:19:49 <Philonous_> mk:  Monads don't exist in empty space, of course. So you will need to familiarize yourself with whatever setting you want to understand them in.
11:20:13 <Philonous_> mk:  But I guess we have hit that point home by now
11:20:21 <yasar> Is there any type class that doesn't have Maybe instace for it :D
11:20:22 <shergill> hmm i came across this tutorial/article/wiki on monads, which basically talked one through the problem that monads such as the state monad solve and sorta went through constructing monads from scratch. i thought that was pretty illustrative and didn't presuppose much in terms of haskell knowledge. anyone else know what i'm on about?
11:20:34 <elliott> yasar: Contravariant
11:20:39 <monochrom> oh well, the next best thing is Wadler's http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#marktoberdorf
11:20:44 <elliott> Category (ok, Kleisli Maybe is)
11:20:48 <mk> Philonous_: yep :)
11:20:56 <magicman> @google you could have invented monads
11:20:59 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
11:20:59 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
11:21:03 <magicman> shergill: that one?
11:21:11 <mk> "you'll need to know haskell" first is a bit discouraging, but that's fine
11:21:30 <misterbeebee_> hey, back to Haskell for a sec: I like to explicitly import every function I call (`import Data.Foldable(foldl)`) or whatever, so I know where methods come from and don't call the wrong one by accident.
11:21:32 <misterbeebee_>  Is there a good to help with that, to bulk cleanup messy code? An emacs macro or something?
11:21:41 <shergill> magicman: yes!
11:21:50 <misterbeebee_> (I use EclipseFP these days, because I was in Java for a while and got comfy in Eclipse)
11:21:59 <shergill> mk: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
11:22:04 <shergill> try that
11:22:20 <elliott> shergill: without knowing any haskell syntax?
11:22:38 <elliott> especially since it has exercises.
11:22:42 <elliott> the solutions to which are haskell code.
11:22:54 <shergill> elliott:  i skimmed through it before i had any knowledge of haskell syntax =/
11:22:58 <shergill> and i understood it
11:23:07 <shergill> or at least the problem monads were solving
11:23:12 <elliott> well, you're lucky then
11:23:16 <Mathnerd314> gwern: any chance of mueval on windows?
11:23:40 <mk> shergill: I'll have a look, thanks
11:24:10 <shergill> mk: don't try to get everything, but it did (at least in my case) provide me with enough of the overall picture
11:24:19 <shergill> in other words: skip the exercises
11:24:33 <mk> does anyone know here I can find the often-joked-about spacesuits tutorial? Most of the places I see point to the same dead page
11:24:42 <elliott> it's the haskell wikibook iirc
11:24:46 <elliott> but perhaps someone made it not terrible
11:25:02 <monochrom> good riddance
11:25:13 <misterbeebee_> http://www.iterasi.net/openviewer.aspx?sqrlitid=ixx7fcluvek_9lfolsxr_g ?
11:25:13 <misterbeebee_> wei
11:25:14 <misterbeebee_> rd
11:25:22 <elliott> can't imagine the shame the author of that one must feel :)
11:25:27 <misterbeebee_> page, but has the old page from 2005 in it
11:25:53 <elliott> oh, Eric Kow wrote it?
11:25:59 <elliott> well, pile on the shame anyway
11:27:19 <shergill> there are always burritos is space isn't your thing
11:27:21 <monochrom> I thought it was dons
11:27:31 <shergill> *if
11:27:34 <yasar> Can you do Monadic tail recursion using (>>=) ?
11:27:41 <mk> I didn't mind his toxic waste example. Functions really are like factory machines - thing goes in, thing comes out
11:28:04 <c_wraith> yasar: sure. that's what forever does
11:28:13 <c_wraith> yasar: in certain cases, anyway
11:28:37 <elliott> mk: most people don't mind really bad monad tutorials until they understand monads.
11:28:42 <c_wraith> > forever [0]
11:28:44 <lambdabot>   *Exception: stack overflow
11:28:53 <monochrom> eric kow's is space station, not spacesuit, and no toxic waste
11:28:55 <c_wraith> sometimes forever doesn't work so well. :)
11:29:03 <c_wraith> > forever []
11:29:04 <lambdabot>   []
11:29:14 <gwern> misterbeebee_: I think there's a ghc option to dump enumerated imports
11:29:22 <zmoazeni> Hey folks, I'm trying to play around with STM, and I'm wondering. IORef isn't thread safe is it? I'm trying to simulate a dirty read/write issue, but I'm not having much luck.
11:29:23 <mk> elliott: this implies that everyone writing monad tutorials doesn't understand monads :)
11:29:27 <hpaste> zmoazeni pasted “IORef thread safetyness?” at http://hpaste.org/66130
11:29:32 <misterbeebee_> gwern: thx
11:29:40 <zmoazeni> (I know IORef isn't STM. Just want a baseline to mess with)
11:29:42 <gwern> Mathnerd314: not unless you want to figure out how to do multiple processes on Windows. I don't use windows and don't plan to
11:30:18 <misterbeebee_> --dump-minimal-imports, sweet
11:30:33 <hpc> zmoazeni: IORef is not thread-safe (you can't do any locking, etc with it)
11:30:39 <elliott> mk: not really
11:30:44 <misterbeebee_> just need to plumb together something to do the search/replace in my code
11:30:46 <hpc> MVars are kinda thread-safe, but you can only lock on one at a time
11:30:50 <hpc> TVars are STM hotness
11:30:55 <Mathnerd314> gwern: System.Process is portable, IIRC...
11:30:59 <gwern> misterbeebee_: I think I once saw a script to take that and edit it into the file using haskell-src-exts but dunno
11:31:05 <elliott> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ explains it well
11:31:10 <zmoazeni> hpc: The output of http://hpaste.org/66130 is always consistent which is making me question the way I'm trying to force thread corruption issues
11:31:19 <hpc> er, you can't atomically lock more than one MVar
11:31:20 <gwern> Mathnerd314: yes, but stuff like nicing and killing aren't portable
11:31:41 <gwern> Mathnerd314: if you want to test whether they're unneessary on windows, the testcases are all in the script
11:32:11 <maloi> what's a good way to concate Integer like so f [1,3,4] = 134
11:32:15 <hpc> zmoazeni: you make 100 threads, and they all sleep for 20ms
11:32:16 <elliott> <hpc> zmoazeni: IORef is not thread-safe (you can't do any locking, etc with it)
11:32:19 <elliott> hpc: not strictly true
11:32:21 <hpc> they can all sleep at the same time
11:32:25 <elliott> you can do it for one IORef
11:32:34 <hpc> so at t+20ms, threads start adding stuff
11:32:37 <elliott> maloi: read . concatMap show?
11:32:43 <hpc> and it takes less than 80ms to finish 100 adds
11:32:45 <mk> elliott: yep, but that says "once you get monads, terrible analogies and complex explanations will seem great to you, because you now know the background needed for monads"
11:33:03 <zmoazeni> hpc: but shouldn't that be enough to have threads clobber each other? I'm actually wanting to see a dirty read/write
11:33:05 <elliott> no -- only the one analogy you come up with will seem good
11:33:06 <hpc> elliott: oh right, forgot about that
11:33:09 <gwern> mk: on lesswrong, we call that 'inferential distance'
11:33:15 <zmoazeni> Maybe I need to bump up the number of threads and/or the sleep
11:33:17 <elliott> anyway, i get the feeling i'm feeding into the monad mystique by talking about this, so i will stop
11:33:21 <gwern> you forget what you didn't know and didn't understand
11:34:00 <maloi> elliott: perfect, why this doesn't came to MY mind :)
11:34:06 <hpc> zmoazeni: ah, try this:
11:34:57 <hpc> brokenModifyIORef ref f = do {v <- readIORef f; sleepRandomTime; writeIORef ref (f v)}
11:35:21 <elliott> maloi: you need to spend more time on #haskell internalising @pl :P
11:35:31 <monochrom> the relation between [1,3,4] and 134 is inspired by: 134 = 1*100 + 3*10 + 4 = ((0*10 + 1)*10 + 3)*4. this is a foldl
11:35:32 <zmoazeni> Ah right on, I'll move to using random sleeps. Good idea
11:35:46 <hpc> my guess is the gap between read and write isn't long enough for there to be a reasonable chance of broken writes
11:35:51 <yasar> So, when something is a monad, it is also an applicative functor, and also a functor, correct?
11:35:59 <hpc> not with only 100 operations at least
11:36:04 <zmoazeni> hpc: Yeah. I was going to move to string concatenation next
11:36:06 <Taneb> yasar, yes?
11:36:06 <mk> gwern: gotcha. By the way - I assume gwern.net is yours? I've found it useful, thanks
11:36:12 <gwern> mk: yes
11:36:16 <gwern> mk: what on it?
11:36:22 <zmoazeni> hpc: Thanks for the 2nd pair of eyes. I just needed some feedback there
11:36:39 <hpc> you can also use an 'f' with a more complicated runtime than (+ 1)
11:36:56 <elliott> hpc: will that help?
11:36:58 <elliott> iorefs are lazy
11:37:01 <hpc> like "get number from https://duckduckgo.com/?q=random, then add"
11:37:01 <elliott> you'd need a $! in there
11:37:11 <elliott> ok, if it's in IO then it'll work :p
11:37:20 <monochrom> so, you should introduce an "accumulator" parameter. f [1,3,4] = g 0 [1,3,4].  g a [] = a.  g a (x:xs) = g (a*10 + x) xs.
11:37:40 <monochrom> @type foldl
11:37:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:37:41 <hpc> oh, i suppose you can't do that with modifyIORef
11:37:45 <hpc> :t modifyIORef
11:37:45 <lambdabot> Not in scope: `modifyIORef'
11:37:50 <zmoazeni> I defined modifyIORef
11:37:55 <hpc> but something like that
11:37:58 <zmoazeni> oh no, nm
11:38:01 <monochrom> or you can say f [1,3,4] = foldl (\a x -> a*10 + x) 0 [1,3,4]
11:38:02 <Taneb> yasar, fmap f m = m >>= (return . f)
11:38:07 <zmoazeni> I defined modifyTMVar elsewhere. something else
11:38:19 <hpc> just increase the probability of the runtime switching threads mid-modify
11:38:21 <mk> gwern: I think your n-back faq was the latest thing I looked at, though when I did, I recognized your site from trying to find out about something totally unrelated
11:38:27 <gwern> :)
11:38:29 <hpc> and use more threads
11:38:36 <gwern> mk: I pride myself on my eclecticism
11:38:41 <Taneb> yasar, or just liftM?
11:38:43 <hpc> (GHC can handle millions of forkIO threads without breaking a sweat)
11:38:57 <Taneb> yasar, (<*>) = ap
11:39:10 <zmoazeni> hpc: Thanks again
11:39:20 <hpc> np
11:39:35 <hpc> one of these days ill actually write a threaded program myself... :P
11:46:09 <shergill> next step: make sure it actually does what you intended it to :P
11:51:17 <nolrai_portland> Hey I am getting a strange cabal error.
11:51:21 <hpaste> nolrai pasted “Cabal error” at http://hpaste.org/66131
11:51:41 <nolrai_portland> Can someone help figure out what is up?
11:51:56 <FUZxxl> s
11:53:00 <donri> nolrai_portland: collections doesn't seem to build on ghc 7+
11:53:03 <dcoutts_> nolrai_portland: what it should say instead is that there's a constraint that base be installed already
11:53:14 <nolrai_portland> ahh.
11:53:33 <dcoutts_> nolrai_portland: the error message is just bad, because it doesn't mention the 'installed' part of the constraint
11:53:34 <nolrai_portland> hmm.
11:53:39 <nolrai_portland> Thanks.
11:53:59 <DMcGill> @src filterM
11:53:59 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:54:07 <nolrai_portland> Let me see what I was useing it for.
11:54:14 <donri> nolrai_portland: perhaps the containers package suffices for you?
11:54:14 <DMcGill> @src Control.Monad.filterM
11:54:14 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:54:30 <dcoutts_> nolrai_portland: so bigger picture: what it's saying is that containers needs base 3, and generally we can only use installed versions of base, it's not possible to install different base versions from source
11:54:43 <dcoutts_> nolrai_portland: and clearly you don't have base 3 installed, only 4.x
11:54:59 <dcoutts_> in other words, that containers version needs and older ghc
11:55:25 <dcoutts_> and then finally, whatever you were trying to install, it depends on an old containers version that came with an old ghc
11:55:34 <nolrai_portland> dcoutts_:so does this mean I cant use Data.Map in GHC 7.x?
11:55:48 <yasar> Does anyone have any idea where the name "Monad" comes from?
11:56:08 <roconnor>  yasar it is a combination of Monoid and Triad
11:56:53 <donri> nolrai_portland: Data.Map is in containers, not collections
11:57:04 <yasar> I guess those come from some ...... theory in matematics.
11:57:07 <roconnor> yasar it is a portmanteau of Monoid and Triad
11:57:24 <nolrai_portland> Oh..:blush:
11:57:42 <dcoutts_> nolrai_portland: no, Data.Map is in the containers that comes with your ghc-7.x
11:58:11 <dcoutts_> oh, donri said that already
11:58:31 <donri> nolrai_portland: is it intentional that your nick means something like "king" in lojban?
11:58:37 <nolrai_portland> hmm..doesn't seem to have been installed.
11:58:40 <nolrai_portland> Yes.
11:58:41 <roconnor> yasar: a monoid, you should familierize yourself with, if you don't already know it.
11:58:47 <roconnor> yasar: I don't even know what a triad is
11:59:16 <nolrai_portland> donri: yep.
11:59:30 <donri> heh
11:59:43 <yasar> roconnor: Me neither, but I have feeling that if it was in haskell, it would have been a type class :D
12:00:13 <nolrai_portland> (Its a pretty silly name..a name it should be nolrais I guess)
12:00:39 <roconnor> pfft, ncatlab doesn't even define what a triad is
12:00:57 <donri> ie nai lo selbri ka'e cmene
12:02:10 <roconnor> hmm, according to this, a triad is another name for a monad ... which is strange if monad is named in part from triad.
12:02:46 <roconnor> "standard construction" is another name for monad
12:03:20 <roconnor> which is why I alway insert a joke in my aricles when I introduce monads by saying "A monad is a standard construction in functional progamming langauges"
12:08:02 <roconnor> yasar: okay, from what I gather, what we call a monad has variously been called a "dual standard construction", "triple", "monoid" and "triad".  So it seems that the new term "monad" is a compromise between "monoid" and "triad".
12:10:30 <Mathnerd314> gwern: it's timing out on 'myquickcheck (1+1 == 2)' -E (by <1/2 second)... am I allowed to increase timeouts, or what?
12:10:51 <gwern> Mathnerd314: well, you could I guess increase the timeout
12:12:29 <elliott> roconnor: I would have preferred trioid
12:12:30 <elliott> sounds cooler
12:12:35 <eacameron> is there a easy built-in way to split a string based on any number of delimiters (not just one). like python's str.split(' \t.,')?
12:12:46 <lorinescu> give it up for a2enmod
12:13:02 <lorinescu> cel putin pe ubunti stie si tab completion
12:13:26 <elliott> eacameron: take a look at the split package
12:13:43 <nolrai_portland> Yo is " Map.toAscList . Map.fromListWith (+)" a reasonable thing to do?
12:13:49 <eacameron> elliott: cool!
12:13:58 <eacameron> elliott: This is exactly what I want
12:14:39 <elliott> nolrai_portland: sure
12:15:08 <nolrai_portland> Okay, just seemed weird to import Data.Map..just to use that.
12:15:54 <Mathnerd314> gwern: and then it failed on the Unicode test due to <stdout>: hPutChar: invalid argument (character is not in the code page)
12:16:06 <gwern> Mathnerd314: this is windows right?
12:16:14 <Mathnerd314> yep
12:16:32 * gwern shrugs. I don't understand the unicode handling on linux, I sure don't understand windows
12:16:45 <byorgey> nolrai_portland: why would it be weird?  This is the whole point of modularity/code reuse.  Just import little bits and pieces and assemble them into what you actually need.
12:17:54 <nolrai_portland> Jbyorgy: well..I guess I usually think of 'Map's as things you build and use, not just a steping stone between two lists.
12:18:11 <reinoud> @time reinoud
12:18:32 <reinoud> @clock reinoud
12:18:33 <lambdabot>   Not in scope: `reinoud'
12:19:10 <chrisdone> is there a way to disallow registrations with gitit?
12:20:15 <nolrai_portland> :bot
12:20:18 <nolrai_portland> @bot
12:20:19 <lambdabot> :)
12:20:51 <byorgey> nolrai_portland: everything is a stepping stone between something and something else =)
12:21:36 <chrisdone> life is a box of something, you never know something something
12:22:18 <mk> fmap :: (a -> b) -> m a -> m b  --where do the missing brackets go?
12:22:18 <elliott> most people think of lists as data structures, too
12:22:29 <elliott> mk: (a -> b) -> (f a -> f b)
12:23:20 <ClaudiusMaximus> chrisdone: maybe some apache reverse proxy rewrite rule could hide the registration stuff?  but seems there is no documentation covering this
12:23:32 <ClaudiusMaximus> (also useless if you're not using apache)
12:23:41 <chrisdone> ClaudiusMaximus: yeah maybe i'll just do an nginx rewrite
12:24:02 <chrisdone> can't be bothered opening the source at this time
12:24:12 <nart> does exist a simple web server ? i just need something to write a json api nothing too fancy
12:24:35 <gwern> chrisdone: set the anti-robot token to something unguessable?
12:24:39 <chrisdone> nart: warp/snap
12:24:41 <elliott> nart: Warp, Snap?
12:25:13 <mk> is s.indexof(m) / (index-of s m) described by (s m -> n) ?
12:25:23 <nart> i saw warp hasn't been update in about a year, is it still active ?
12:25:31 <nart> *updated
12:25:32 <chrisdone> gwern: that's an easier solution, thanks
12:25:35 <pozic> Why would a search engine not care about JavaScript on modern websites?
12:26:01 <pozic> E.g. when you change the title of a page dynamically.
12:26:20 <bss03_really> nart: Yeah, I'm pretty sure it is.  Snoyberg uses it for Yesod and that's still active; I think he's writing a book.
12:26:21 <chrisdone> running javascript would be a nice way to cripple your crawler
12:26:39 <pozic> chrisdone: a crawler is I/O limited.
12:26:41 <chrisdone> even for google
12:26:49 <pozic> chrisdone: or isn't it?
12:26:54 <gwern> writing books sounds like something you should do only when the project is cut, dried, done, and at 1.0
12:26:56 <pozic> Perhaps if you have dark fiber, it isn't.
12:27:02 <ClaudiusMaximus> javascript can do I/O?
12:27:08 <bss03_really> gwern: Yesod has released 1.1.
12:27:12 <pozic> ClaudiusMaximus: network I/O.
12:27:13 <chrisdone> ClaudiusMaximus: he means you have to wait for web servers to respond
12:27:18 <bss03_really> gwern: It's the Conduit-based version.
12:27:41 <gwern> bss03_really: sounds like the ideas and code are still in flux
12:27:48 <pozic> I see lots of people with SEO advice, and I really think that if a search engine cannot use JavaScript these days that it is just a big pile of failure.
12:27:49 <nart> bss03_really: ty, i have probably looked in the wrong place for the code
12:27:58 <elliott> nart: http://hackage.haskell.org/package/warp
12:27:59 <elliott> feb 2012
12:28:08 <nart> elliott: yep i just saw it
12:28:11 <elliott> oh, consider happstack too perhaps.
12:28:11 <bss03_really> pozic: I think that if a website *requires* JS, it is a big pile of failure.
12:28:20 <bss03_really> pozic: So, it each his own.
12:28:22 <pozic> bss03_really: why do you think that?
12:28:33 <mk> does (a b -> c d) specify a function that takes two distinct types, and return two distinct types?
12:28:35 <chrisdone> bss03_really: the 90s called, they want their opinions back :p
12:28:57 <bss03_really> pozic: I don't trust JS.  Besides the poor-ish security record of most browser, I try and only run free software.
12:29:11 <bss03_really> pozic: Most of the JS I see is not under an OSI-approved license.
12:29:22 <pozic> bss03_really: so you never visit a website?
12:29:32 <pozic> bss03_really: or use Google for that matter.
12:29:33 <elliott> I think Google do run JS.
12:29:37 <elliott> At least to generate their previews.
12:29:40 <elliott> Probably not in normal crawling.
12:29:42 <chrisdone> pozic: it'd be interesting to see if there's research in heuristics for reasonable amount of time and resources to allow a page script to run. it'd need a browser instance per page for the DOM. do you allow ajax requests, etc.?
12:29:59 <pozic> chrisdone: it is a trivial problem to solve.
12:30:13 <elliott> Every problem is trivial if you don't have to solve it.
12:30:16 <pozic> chrisdone: surely someone who works at Google should be able to answer that in an interview or something like that.
12:30:20 <ClaudiusMaximus> mk: no - a and c are type constructors there
12:30:33 <mk> pozic: there's a distinction between running free software yourself, and interacting with people/entities which choose not to. It's best to avoid this discussion, though
12:30:36 <bss03_really> pozic: Server-side execution (e.g. ASP, HAppStack, Perl::FastCGI) doesn't bother me -- they do what they want with their hardware.
12:30:44 <chrisdone> pozic: 'trivial' makes it sound like it's already been done by the company with the most computing resources and highest incentive to do it in the world
12:30:58 <ClaudiusMaximus> mk: for example, a might be Maybe and c might be []
12:30:59 <mk> ClaudiusMaximus: thank you
12:31:00 <chrisdone> pozic: but pretty sure it hasn't
12:31:01 <bss03_really> pozic: client-side execute (e.g. VBScript, JavaScript, ECMAScript) use my hardware, so they do concern me.
12:31:04 <pozic> chrisdone: indeed, and that's what I expect.
12:31:08 <gwern> ignoring JS encourages people to not write sites like the messed up #! sites
12:31:13 <Enigmagic> chrisdone: the javascript rendering image preview generation things i know about at some major search engine just has a timeout and they restart the VMs occassionally
12:31:22 <pozic> chrisdone: if they are not doing it, then Google perhaps has become more of an advertising company ;)
12:31:45 <chrisdone> :)
12:32:00 <pozic> gwern: messed up? You mean very user-friendly, polished web-applications?
12:32:30 <gwern> pozic: sites that load slow, that can't be archived, can't be checked for validity...
12:32:36 <pozic> How are you going to present real-time changing information on a website without JavaScript?
12:32:58 <bss03_really> But, I can here to see if someone could possibly tell me how to do hetrogenous lists with impredicative types?
12:33:11 <gwern> pozic: why do I need an article on gizmodo to load real-time changing information? or a tweet, for that matter?
12:33:38 <pozic> gwern: I wasn't talking about articles.
12:33:54 <gwern> pozic: strange, the makers of sites using #! strategies often are
12:34:00 <bss03_really> Basically I have a bunch of (Show b => a -> b) functions and I want to store them in the list, just syntaxically because they make the code easier to read.
12:34:02 <gwern> pozic: you should tell them to fix their sites, then
12:34:05 <elliott> <pozic> gwern: messed up? You mean very user-friendly, polished web-applications?
12:34:06 <chrisdone> Enigmagic: i know there's a screenshot thing, but that seems orthogonal to /indexing/ a dynamically changing DOM
12:34:13 <elliott> pozic: btw, you realise that twitter is undoing the #! mess now?
12:34:21 <bss03_really> I'm going to immediately (in the surrounding code) convert to a a -> [String].
12:34:29 <gwern> elliott: a lesson is learned but the damage is irreversible...
12:34:30 <elliott> it's been unnecessary for years, since every browser supports the history control via JS now.
12:34:32 <pozic> elliott: I don't even know what #! is.
12:34:44 <pozic> elliott: except that I know it from scripts.
12:34:47 <elliott> pozic: ah! so you don't know what you're talking about - ok
12:34:54 <pozic> elliott: and I know exactly what #! is.
12:35:00 <pozic> elliott: except not in this context.
12:35:08 <hpc> pozic: instead of writing foo.com/bar.cgi?id=15 -- server-side processing gets thing #15 and prints it
12:35:18 <chrisdone> elliott: not really 'every browser', unless you're discounting everything pre IE9, which would be a nice way to lose users ;p
12:35:32 <pozic> elliott: I am not the one introducing symbols that have already existed for since UNIX was first developed.
12:35:35 <hpc> pozic: you write foo.com/bar.cgi#!15 -- server gives you some javascript that then asks the server for thing 15 and prints it
12:35:43 <elliott> chrisdone: fair enough... though degrading to non-ajax for IE<9 seems OK to me
12:35:47 <chrisdone> (actually IE9 doesn't even have it)
12:36:02 <elliott> which, appropriately, becomes possible when you don't assume everyone in the world runs JS.
12:36:10 <luite> http://hdiff.luite.com/tmp/browser.png <- IE pre-9 gets this on my site, hah that will teach them
12:36:13 <chrisdone> elliott: yeah that's becoming standard. i do that. if it's not supported just fall back to anchors
12:36:15 <hpc> it's just an extra pointless handshake to avoid "reloading images" or whatever
12:36:20 <pozic> hpc: and how is this being called?
12:36:45 <hpc> pozic: how is what being called?
12:37:02 <pozic> hpc: the #! syntax/tech/whatever it is.
12:37:15 <pozic> hpc: I still don't see the point, btw.
12:37:24 <hpc> there is no point
12:37:25 <pozic> hpc: I haven't seen anything that's not possible in some other way.
12:37:37 <hpc> you see exactly what everyone else does :P
12:37:43 <bss03_really> Am I basically going to have to introduce an existential type for this?
12:37:44 <Enigmagic> chrisdone: some people do index a changing dom (i've built something that does this) but it's unlikely to be used for a full scale web crawl
12:37:52 <pozic> hpc: this is very confusing.
12:37:53 <elliott> bss03_really: almost certainly not.
12:38:02 <pozic> hpc: what was the reason #! was brought up?
12:38:06 <elliott> (i didn't read anything you said apart from the existential type part, but they're almost never necessary :P)
12:38:07 <elliott> pozic: <gwern> ignoring JS encourages people to not write sites like the messed up #! sites
12:38:16 <chrisdone> Enigmagic: nod. i'd expect that, but what are the reasons for it being unlikely?
12:38:23 <pozic> elliott: yes, and this #! sites are what?
12:38:31 <elliott> pozic: twitter, for one.
12:38:32 <bss03_really> elliott: I'm trying to do restricted hetrogenous lists.
12:38:36 <pozic> elliott: how is this #! technique or whatever called?
12:38:46 <elliott> it's called #!
12:38:52 <elliott> "hashbang"
12:38:56 <elliott> if you want something pronouncable
12:38:58 <bss03_really> elliott like [there-exists a. Show a => a]
12:39:01 <pozic> elliott: google cannot search for that.
12:39:07 <pozic> elliott: you get how to script bash.
12:39:09 <luite> is there a better way than #something to give people an url to some specific view on a single page?
12:39:09 <hpc> (not to be confused with crunchbang)
12:39:10 <elliott> pozic: it can search for "hashbang".
12:39:13 <elliott> i just did
12:39:20 <elliott> https://www.google.co.uk/search?aq=f&ix=sea&sourceid=chrome&ie=UTF-8&q=hashbang+url
12:39:25 <bss03_really> elliot: So, I can later so stuff like map print [ "ab", 'c' ]
12:39:28 <mauke> pozic: https://developers.google.com/webmasters/ajax-crawling/docs/specification
12:39:32 <elliott> in fact, the second and third results for "hashbang" are about the URLs here.
12:39:34 <chrisdone> pozic: by #! i think they're merely referring to using anchors for page navigation. i've never heard of it said like #!, it might be blogosphere terminology because of twitter. gmail for example is just an anchor. i prefer to just say 'anchor'
12:39:39 <elliott> chrisdone: no
12:39:43 <mauke> chrisdone: no
12:39:44 <Enigmagic> chrisdone: i don't think there's much of a benefit for a web search company to offer that. publishers will try to make their sites relatively crawler friendly if it's important to their business
12:39:45 <elliott> chrisdone: it's specifically the #! syntax
12:39:58 <elliott> which google have half-baked support for crawling because everyone rushed to rewrite their websites to be unusable by doing everything client-side
12:40:30 <hpc> chrisdone: gmail does on-click stuff, then updates the anchor link just to make the link copy-pastable
12:40:44 <hpc> or something like that
12:40:56 <hpc> (that's what i would do if i was gmail)
12:41:07 <chrisdone> hpc: sure. that's what i do
12:41:43 <chrisdone> elliott: ah ok. does it have a real name?
12:41:47 <elliott> chrisdone: "hashbang"
12:41:58 <pozic> mauke: yeah, I was already reading it.
12:42:23 <pozic> I think it is just Google being lazy.
12:42:51 <eacameron> I'm having a horrible time with Control.Exception's `catch`. I have an infinite loop inside the main monad that reads from stdin. But when stdin runs out, the program prints an end of file IOError warning. I want to suppress that somehow..???
12:42:52 <pozic> Google could surely just have figured out how to properly visit a web-application.
12:43:09 <pozic> Instead they introduce some random standard just to make their life easy.
12:43:28 <mauke> eacameron: IOErrors aren't warnings
12:43:31 <bss03_really> eacameron: Are you catching the EOF error?
12:43:46 <eacameron> mauke: right...my bad
12:43:53 <pozic> chrisdone: an anchor is #.
12:43:53 <mauke> pozic: no
12:43:56 <eacameron> bss03_really: no...how do I do that?
12:44:05 <pozic> mauke: no, what?
12:44:15 <mauke> pozic: "Google could surely just have figured out how to properly visit a web-application."
12:44:36 <Philonous> chrisdone:  Regarding haskell-process, the inferior mode abbreviates error messages a bit too eagerly. It would be neat if it was possible to expand them to see the whole thing.
12:44:47 <pozic> mauke: continue?
12:44:58 <pozic> mauke: /explain.
12:45:02 <chrisdone> pozic: yeah i know. i was just trying to guess what they were talking about. they were being quite secretive about its origin to outsiders who didn't already know it :p
12:45:07 <bss03_really> Since it is an IOError, it's probably eaiest to use http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.0.0.0/System-IO-Error.html#g:5
12:45:08 <elliott> pozic: it must be nice being able to assume all problems are trivial
12:45:09 <mauke> pozic: we're talking about arbitrary javascript code
12:45:14 <ClaudiusMaximus> eacameron: i guess something like   main = main' `catch` ignoreEOF ; ignoreEOF :: TheTypeOfTheEOFException -> IO () ; ignoreEOF _ = return () ; main' = the real program
12:45:26 <pozic> mauke: yes, I can also figure out what I can do on a website, can't I?
12:45:31 <mauke> pozic: no
12:45:31 <elliott> "why haven't we colonised mars yet?! you'd think we would have done that by now. morons."
12:45:40 <pozic> mauke: and so can you and millions of other people.
12:45:47 <mauke> pozic: no
12:45:48 <yrlnry> .query lambdabot
12:46:03 <chrisdone> Philonous: you can! just go to them and hit TAB :-)
12:46:16 <pozic> mauke: I am getting a bit tired of asking for arguments.
12:46:17 <chrisdone> TAB toggles
12:46:36 <Philonous> chrisdone:  Wait, really? I'm flabbergasted!
12:46:36 <mauke> pozic: I don't need arguments, it's obvious
12:46:46 <chrisdone> Philonous: :p
12:46:52 <elliott> pozic has not yet provided any arguments in favour of his positive claim that it is easy for google to do this, i note
12:46:59 <mauke> yes, exactly
12:47:04 <elliott> also, this has nothing to do with haskell.
12:47:06 <pozic> mauke: you are saying that intelligent people cannot understand how a website works?
12:47:09 <elliott> what
12:47:11 <mauke> pozic: correct
12:47:12 <elliott> stop trolling
12:47:16 <mauke> pozic: also, #haskell-blah
12:47:26 <bss03_really> Yeah, can we get back to my haskell program?
12:47:27 <Philonous> chrisdone:  Indeed. I was working around that by looking into the *haskell-process-log*.
12:47:41 <pozic> bss03_really: what's wrong with HLists?
12:48:53 <bss03_really> pozic: I'd like to avoid adding another dependency is the first reason.
12:48:58 <chrisdone> Philonous: hehe. i guess i will document all this anyway somewhen ;)
12:49:30 <pozic> bss03_really: ...
12:49:31 <jeff_s_> Anybody know how I can write this without using runEitherT? It seems like such a waste, since I'm just going back into EitherT.
12:49:33 <hpaste> “database either error or  result” pasted “Jeff Shaw” at http://hpaste.org/66133
12:49:37 <pozic> bss03_really: you know why people write libraries?
12:49:43 <pozic> bss03_really: for others to reduce work.
12:49:56 <bss03_really> pozic: I can write this without a hetrogenous list, but the code looks better if I use one, since the labels end up being close to the accessors.
12:50:07 <Philonous> chrisdone:  And two incredibly minor things: When the ghci buffer opens, it steals the focus of the minibuffer while you are supposed to enter the working directory; and when hitting enter in the inferior mode the cursor is only advanced when ghci produces output which is suprising when you enter an expression that takes a while until it prints something.
12:50:43 <ClaudiusMaximus> bss03_really: you can use extentials but  (modulo my errors and misunderstandings)    data Showable = MkShowable{ getShowable :: forall a . Show a => a }     mapM_ (print . getShowable) [ MkShowable "x", MkShowable 'y' ]       isn't exactly shorter or more useable than   mapM_ print [ show "x", show 'y' ]
12:50:47 <bss03_really> pozic: Also, at this point it is less about getting the work done and more about refining my understanding of RankNTypes and ImpredicativeTypes.
12:51:41 <bss03_really> ClaudiusMaximus: It is probably a bit shorted when "x" and "y" are "longSelectorName", "anotherSelctor", and about a dozen those names like that.
12:52:17 <elliott> bss03_really: That Showable type is isomorphic to String.
12:52:21 <elliott> (Modulo the precedence stuff.)
12:52:21 <chrisdone> pozic: you know, i'm getting a bad vibe from you—bad day? :-)
12:52:46 <bss03_really> ClaudiusMaximus: Also, I can save a bit because my list isn't immediately shown.
12:53:31 <chrisdone> Philonous: yeah… i noticed this. kinda annoying indeed… i can solve it somehow but need to rewrite some bit i think. for now i left it as it's not a HUGE problem
12:53:32 <reinoud> @hoogle Load
12:53:33 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer Load :: AccumOp
12:53:33 <lambdabot> package loadavg
12:53:33 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans loadIdentity :: IO ()
12:53:41 <bss03_really> Instead of having type (Show a) I have things of type (a -> Show b), and then I do some stuff in the Reader Monad to fianlly get a [Show a].
12:53:44 <reinoud> @hoogle load_
12:53:44 <lambdabot> GHC.Constants mIN_PAYLOAD_SIZE :: Int
12:53:54 <reinoud> @hoogle LoadStatus
12:53:54 <lambdabot> No results found
12:53:58 <chrisdone> Philonous: what do you mean about the cursor advancing when ghci produces output? what would you expect to happen?
12:53:59 <eacameron> ClaudiusMaximus: Worked like a charm! Thanks
12:54:02 <elliott> bss03_really: same as (a -> String), [String]
12:54:15 <Philonous> chrisdone:  It tells you something that this is the worst complaint that I can come up with ;)
12:54:58 <bss03_really> elliott: Also, I'm using "Show" as an example the actually TypeClass I'm dealing with is ToSElem from HStringTemplate.
12:55:02 <chrisdone> Philonous: btw, i pushed recently and eval'ing now outputs immediately any data that comes back until it ends (rather than collecting everything and then one big print at the end). this is good for infinite list scenarios and whathaveyou. still working on the interactive programs problem, not doing much hacking tonight though, resting the paws
12:55:10 <chrisdone> Philonous: ha! yeah, that's good news :p
12:55:14 <Philonous> chrisdone:  I have an IO action that takes a long time until it produces output, I enter it at the prompt and hit [ente]" but nothing happens. I'd expect the cursor to advance to the next line to signify that the command has been sent
12:55:15 <elliott> bss03_really: Yes, but I will be able to do the same simplification.
12:55:31 <eacameron> Out of curiosity, is it possible to bind the inputs of a lambda function to types? Something maybe like (\t :: Type -> stuff) ?
12:55:33 <Philonous> chrisdone:  Yeah, I saw that yesterday, I'm using that already
12:56:15 <chrisdone> Philonous: ah. haha. it DID do that, but i found it ugly that the cursor moved so much and tweaked it to not send anything. umm
12:56:18 <elliott> bss03_really: Depends on the surrounding code there though since it's a bit more complicated.
12:56:26 <Philonous> chrisdone:  It's not really a big deal when you know what's going on, just surprising if you don't
12:56:41 <bss03_really> Basically, I want to be able to write (map show [ list of 14 elements ]) instead of ([ show 1, show "2", show '3', ... ])
12:56:43 <reinoud> what is the recommended way to get rid of System.Plugins.Load ?
12:56:45 <geekosaur> eacameron, there is an extension for that
12:56:53 <bss03_really> Because it is easier to read.
12:57:10 <reinoud> @hoogle System.Plugins.Load
12:57:11 <lambdabot> package loadavg
12:57:11 <lambdabot> package cabal-upload
12:57:11 <lambdabot> package dist-upload
12:58:01 <chrisdone> eacameron: ScopedTypeVariables
12:58:02 <bss03_really> I really can just prepend all my values with "toSElem . " and I'm good, it just seems like uglier code that way.
12:58:02 <ClaudiusMaximus> eacameron: apparently you need ScopedTypeVariables extension for that, but it seems slight overkill to me
12:58:40 <chrisdone> Philonous: trying to think if there's a better more obvious way to indicate "stuff's happening"
12:58:57 <bss03_really> elliott: Is there a way to do that without existentials.  I have hoping that Impredictive types would get me there.
12:58:58 <elliott> eacameron: (and it's (\(t::Type) -> ...))
12:59:10 <elliott> bss03_really: No. Impredicative types are unrelated.
12:59:21 <elliott> bss03_really: I would say it likely points to a design flaw in HStringTemplate that you have to do this.
12:59:30 <chrisdone> Impredictive extensions are anyway unstable in ghc
12:59:45 <geekosaur> hm, I thiught there was a small er sledgehammer than ScopedTypeVariables
13:00:03 <roconnor> ScopedTypeVariables is pretty small
13:00:04 <Philonous> chrisdone:  add ellipsis and remove them once there's output?
13:00:16 <bss03_really> elliott: Nah.  They *also* make it easier, and I'm just avoiding deriving Data and Typeable because I've not used them enough...
13:00:51 <bss03_really> elliott: Basically, if I derive those two classes, HStringTemplate will give me the instance for free.
13:01:23 <Philonous> chrisdone:  But it's not that important, anyway.
13:01:24 <bss03_really> elliott: And I'm pretty sure GHC will automatically derive Data and Typeable for these ADTs.
13:01:48 <nicmo> h/names
13:01:51 <nicmo> woops
13:01:54 <nicmo> sorry for that :P
13:02:03 <nicmo> synergy got on the way
13:02:48 <chrisdone> Philonous: i'll thinks about it :] something like that sounds good
13:02:59 <bss03_really> elliott, ClaudiusMaximus: Thanks for the help!
13:03:02 <bss03_really> \quit
13:04:36 <chrisdone> Philonous: i keep hacking on it while at work and have to pull myself away from it
13:06:25 <Philonous> chrisdone:  Ah, so we are the beneficiaries of you procrastinating. Well, as far as I'm concerned: procrastinate away ;)
13:06:37 <chrisdone> Philonous: haha :D
13:07:35 <luite> hmm, I still haven't tried them, this is about the emacs haskell things, right?
13:07:37 <chrisdone> next big thing is hasktags stuff
13:07:50 <chrisdone> luite: yesh. haskell-mode
13:08:08 <luite> chrisdone: do you use scion or something similar to get info about the loaded module?
13:08:26 <eacameron> ClaudiusMaximus: elliott: ahh thanks...that's bulky
13:09:28 <chrisdone> luite: nope. i would like to. scion's kinda hard to get working, esp. across ghc versions. any info comes from ghci
13:09:34 <luite> hm, right
13:11:24 <luite> I'm working on something I'm pretty excited about for Wolfgang now, bascially I get the type of every expression and subexpression, from the typechecked GHC AST, and have some popup menu's to show them, and highlight point that introduce class constraints and stuff
13:11:32 <Absolute0> I really like the haskell programming language, but unfortunately there aren't many modern platforms that it can be used for. Is there any cool project I can create with haskell that I could possibly sell? Something like and iphone app or a web app? Haskell Web frameworks seem to lack due to haskells difficult method for working with state.
13:12:08 <elliott> haskell has no difficulty with state
13:12:11 <elliott> look at snap, yesod, happstack
13:12:23 <elliott> http://yesodweb.com/ http://snapframework.com/ http://happstack.com/index.html
13:12:39 <Absolute0> elliott: correction, hard to understand that monad stuff
13:12:56 <Absolute0> I didn't really bother trying to either. :(
13:13:05 <tzxn3> I tried to understand the state monad
13:13:09 <tzxn3> it defeated me :P
13:13:14 <Absolute0> there you go
13:13:26 <Absolute0> and web apps are 90% state.
13:13:34 <luite> Absolute0: you can do a lot in those frameworks without really understanding monads
13:13:41 <pozic> Absolute0: like what?
13:13:49 <Enigmagic> Absolute0: A monad is just a monoid in the category of endofunctors, what's the problem?
13:13:59 <chrisdone> luite: right. scion uses the ghc api, and it can do the type of sub expressions. but use of the ghc api is (aui) why it's so unstable across ghc versions
13:14:00 <adnauseam> what are endo functors ?
13:14:01 <Absolute0> !endofunctor
13:14:07 <Absolute0> :)
13:14:08 <elliott> Absolute0: that just means you didn't read a good tutorial.
13:14:16 <elliott> or didn't stick with it long enough :P
13:14:33 <adnauseam> learn you a haskell seems to be doign a good job so far explaining monads
13:14:36 <Absolute0> I wrote a chess game in haskell, that was a lot of fun. But I didn't touch monads.
13:14:44 <Absolute0> Just some minimal functor stuff.
13:15:05 <Absolute0> adnauseam: at the time that I read that tutorial, his Monad section wasn't yet written.
13:15:11 <Taneb> That's what you think
13:15:18 <Absolute0> or it was in beta or something
13:15:31 <pozic> Go read a book on category theory XOR learn Haskell.
13:15:32 <chrisdone> luite: but yeah that stuff is nice, we have a rich type system--we should use it!!
13:15:47 <adnauseam> Absolute0: did you read his monoid section?
13:15:52 <pozic> It's funny that many people seem to think the former is required for the latter.
13:16:07 <elliott> chrisdone: type of expression at point feature please thanks :P
13:16:07 <pozic> Have you run your Kleisli already today?
13:17:16 <Absolute0> adnauseam: I don't remember. If I did I don't remember any of it. :)
13:17:26 <pozic> It's also quite funny that all the web frameworks in the end end up with abortive continuations, read-only values and state.
13:17:40 <pozic> I.e., exactly the same as other programming languages have built-in.
13:17:57 <adnauseam> Absolute0: give this a read, then read the chapter after that http://learnyouahaskell.com/functors-applicative-functors-and-monoids
13:18:06 <luite> chrisdone: I'm still not quite sure how to present the information to the user, I have a rough mockup here: http://hdiff.luite.com/tmp/typeinfo-mockup.png <- you point your mouse at `scaleX', then you get a popup, pointed-at item is highlighted dark blue. when you then hover your mouse over expressions in the popup, you get the type of bigger expressions, and they're highlighted light blue in the code
13:18:11 <Absolute0> ok say I do use haskell for a web app, will it be effecient? Haskell for the web seems immature at the moment.
13:18:12 <adnauseam> it seems to be going good - though i hadn;t started programming anything - i seem to be understanding it
13:18:20 <pozic> Absolute0: what do you consider mature?
13:18:38 <adnauseam> Absolute0: from what i've read - haskell seems to be very good for making websites with
13:18:47 <luite> chrisdone: and the constraints are displayed separately, when you mouseover them you get a highlight of points in the code that introduce the constraint (wiht a text of the actual constraint, since some constraints have superclasses etc)
13:18:49 <Absolute0> good docs, a big community, plenty of adoption, runs fairly effeciently, etc.
13:19:03 <pozic> Absolute0: I meant a concrete web framework in any other language.
13:19:12 <pozic> Absolute0: not some hypothetical thing.
13:19:15 <Taneb> For me, the hardest thing about learning monads was the difference between (>>) and const
13:19:20 <luite> chrisdone: maybe you've already thought about it better, does this sound like a good idea?
13:19:32 <adnauseam> Taneb: reading about >> myself right now
13:19:41 <Taneb> It's not const!
13:19:48 <Taneb> Don't treat it as such!
13:19:58 <adnauseam> const is : ?
13:20:02 <pozic> Absolute0: yes?
13:20:04 <mauke> @src const
13:20:04 <lambdabot> const x _ = x
13:20:08 <stulli> Is there a way to redirect compiler warnings to a file when using cabal install?
13:20:25 <roconnor> > 7 >> 4
13:20:26 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Num.Num (m b))
13:20:26 <lambdabot>    arising from a u...
13:20:31 <pozic> Absolute0: can you please list your web framework nirvana?
13:20:36 <elliott> luite: that looks lovely
13:20:40 <mauke> ... 2> log.txt
13:20:45 <roconnor> > 7 4
13:20:46 <lambdabot>   7
13:20:48 <elliott> Taneb: at most it'd have to be flip const
13:20:58 <Taneb> Well, yeah
13:21:00 <mauke> or const id
13:21:04 <Absolute0> pozic: I am happy with Python + Flask
13:21:05 <elliott> <Absolute0> ok say I do use haskell for a web app, will it be effecient? Haskell for the web seems immature at the moment.
13:21:11 <Taneb> But it's nothing like const!
13:21:11 <Absolute0> but haskell is just so kewl...
13:21:12 <elliott> snap and warp (yesod's server) are very fast.
13:21:16 <elliott> also, it's a compiled language.
13:21:19 <Absolute0> seems like a waste not to use it.
13:21:21 <elliott> it'd have to try really hard to be slower than rails.
13:21:50 <chrisdone> luite: i haven't thought about that, never implemented such a thing. what you've done in the screenshot is pretty cool!
13:22:19 <luite> elliott: the GHC API part is done now, so I'm pretty sure that it's possible to support this interface, had to do some work to make an exprType :: HsExpr Id -> Type
13:22:55 <luite> = typechecked expression to ghc's type representation
13:23:06 <stulli> mauke: Excellent, thank you. I really need to learn more about these arrow brackets...
13:23:12 <elliott> luite: hehe, i meant the whole thing in genral
13:23:13 <shergill> to pass arguments to things like System.Process.proc i often have to invoke 'show' multiple times (eg. to pass strings with whitespace as a single argument). is there a way to get some benefit from the haskell typechecker to make sure the arguments have been processed with the right number of 'show'? (none for already quoted strings, once for regular strings, twice for any other datatype which supports show)
13:23:15 <elliott> *general
13:23:18 <chrisdone> people have been using haskell in web site production for some years
13:23:21 <elliott> luite: is this the evolution of that wolfgang lambda?
13:23:23 <pozic> Absolute0: I think for maturity you would likely want to use that framework.
13:23:25 <Taneb> > [1,2,3] >> "abc"
13:23:26 <lambdabot>   "abcabcabc"
13:23:35 <luite> elliott: yes, there are also other screenshots in the same dir
13:23:42 <elliott> Absolute0: happstack has been around for years
13:23:45 <elliott> previously as happs
13:23:46 <pozic> Absolute0: if you are an indepedent developer, you should be able to do anything in any language.
13:23:51 <luite> well, the rest is screenshot, this popup menu was still photoshop :)
13:23:54 <pozic> independent
13:23:55 <elliott> luite: cool
13:24:02 <chrisdone> luite: you trickster!
13:24:10 <elliott> http://hdiff.luite.com/tmp/plot4.png <-- awesome
13:24:17 <Absolute0> i should, and i shall definitely try!
13:24:22 <chrisdone> yeah that is cool
13:24:35 <elliott> luite: now give it a bootloader, i want to run this on the bare metal :P
13:24:37 <luite> hehe that's the google api :)
13:24:41 <luite> was really easy to add
13:25:26 <luite> the 3d plot is rotatable of course :p
13:25:35 <pozic> luite: do you use Yesod?
13:25:40 <luite> yes
13:25:43 <elliott> http://hdiff.luite.com/tmp/search.png awesome
13:25:59 <pozic> luite: does Yesod have caching support?
13:26:06 <elliott> http://hdiff.luite.com/tmp/types.gif awesomer
13:26:13 <elliott> http://hdiff.luite.com/tmp/types2.gif awesomerer
13:26:19 <chrisdone> for luite's work i'm sure even fastcgi would suffice :)
13:26:23 <luite> elliott: that's an old version of the types things I was hacking up
13:26:32 <pozic> luite: such that you can say 'every 400ms, refresh this page from the database.'
13:27:40 <luite> chrisdone: loading code into ghci is by far the most cpu intensive thing
13:28:10 <elliott> luite: so is this thing going to be hosted or run locally? or both?
13:28:20 <luite> pozic: you can build something like that yourself, but support isn't yet integrated
13:29:06 <pozic> luite: there is no source for your thing, right?
13:29:09 <luite> elliott: hosted initially, as a wiki where you can build your own pages, import other pages (= .lhs modules) etc, later also local, but I still need to do the local file browser interface
13:29:42 <elliott> luite: well, i mean more whether it'll be easily cabal installable
13:30:27 <chrisdone> luite's project has military backing and more security on its internals than the Iron Man suit
13:30:29 <luite> elliott: yeah that's the plan, but it will take some time... though the hosted version uses a rather complicated setup
13:30:59 <luite> elliott: so a local version that's like a graphical ghci, with no extra security, probably yes
13:31:05 <luite> cabal installing a whole wiki, no
13:31:23 <pozic> luite: what's the name of that other application which did something similar a few years ago on the desktop?
13:31:33 <elliott> luite: right - i thought it'd be neat to be able to write things locally wiki-style and then upload them to a read-only instance to show them to other people
13:31:38 <Taneb> Is there much demand from people who aren't me for a genealogy library?
13:31:41 <pozic> luite: someone build a research prototype.
13:31:48 <pozic> built*
13:32:24 <pozic> luite: http://www.cs.kent.ac.uk/projects/vital/index.html
13:32:26 <luite> elliott: yeah I guess that coul be useful
13:32:40 <pozic> luite: an extremely badly implemented version of what you seem to execute much better.
13:33:04 <luite> oh yes I've played a bit with that
13:33:09 <elliott> luite: basically blog-style.
13:33:10 <pozic> luite: I think the only disadvantage you have is ghci limitations.
13:33:30 <pozic> luite: so, even if you do everything perfectly, the experience will be less than stellar because of ghci.
13:33:37 <luite> but actually what I'm trying to do is more document oriented, wiki pages with haskell
13:33:41 <luite> pozic: hm what do you mean?
13:33:42 <pozic> luite: are you going to improve ghci too?
13:34:26 <pozic> luite: I mean that in the end you need a way to add a binding to the ghci run-time efficiently.
13:34:57 <elliott> i was under the impression luite used ghc api not ghci
13:34:58 <luite> pozic: hm, I don't understand what the problem is?
13:35:03 <luite> yeah I use the GHC API
13:35:05 <pozic> luite: if that takes more time than the time to just type check that definition and some small amount of byte code generation, it is too slow.
13:35:22 <pozic> luite: does the GHC API allow you to do those things now?
13:35:32 <luite> it reloads a moderately sized wiki page in 0.2 seconds on my dev system, even if it depends on 50 cabal packages
13:35:35 <pozic> luite: that is, are the Big Oh costs optimal?
13:36:24 <luite> elliott: actually I started this project because I wanted to make a weblog, I really liked chrisdone's tryhaskell
13:36:27 <pozic> luite: if you define hello = "hi" and then change that do hello = "hello" how long does that take?
13:36:44 <luite> elliott: and thought that weblog posts with interactive content would be teh awesome
13:37:16 <pozic> luite: the TeXMacs community is also doing that with TeXMacs, btw.
13:37:17 <luite> pozic: uh not too long, there is some delay
13:37:31 <pozic> luite: but it does not depend on the size of the program?
13:37:37 <pozic> luite: i.e. you only send diffs?
13:37:47 <luite> no, I send the whole source every time
13:38:10 <pozic> luite: for just the changed work sheet then?
13:38:26 <pozic> luite: can you also refer to other work sheets?
13:38:30 <luite> pozic: yes
13:39:00 <luite> those are compiled (every few minutes in the background), so if you same some page, and you import it in another, after a few minutes it will get the faster version
13:39:07 <luite> making reloads, and also typechecking a lot faster
13:39:31 <luite> the current interactive page is not compiled thogh, only if you save something
13:39:39 <pozic> luite: did the GHC API improve a lot?
13:39:50 <pozic> luite: in particular its documentation.
13:40:04 <luite> dunno, I only started working with it ~9 months ago
13:40:23 <luite> uh well, it helps if you have grep and a local hoogle server running :p
13:41:01 <pozic> luite: now, all you need to do is make a Mathematica bridge ;)
13:41:04 <luite> the API is not as friendly as, say, haskell-src-exts, it's much bigger
13:41:06 <luite> pozic: why?
13:41:26 <pozic> luite: you don't have to do anything.
13:41:28 <monochrom> Mathematica has a C binding IIRC
13:41:45 <pozic> luite: but the kind of people who use these things, are likely already using Mathematica.
13:42:26 <luite> yeah but I'm not sure how useful it would be, of course Mathematica has a lot of existing algorithms and other code
13:43:03 <rasfar> the secret is out then?
13:43:22 <luite>  it's kind of orthogonal though, if some package has good Mathematica bindings it would be easy to just import that package, define a few instances to prettyprint some results
13:43:25 <elliott> luite: i wouldn't bother binding to mathematica. it looks like you are in direct competition
13:43:28 <maloi> @pl f xs = (length xs)^(length xs)
13:43:28 <elliott> and lord knows mathematica needs some
13:43:29 <lambdabot> f = liftM2 (^) length length
13:43:58 <mauke> @pl f length xs = lenght xs^length xs
13:43:58 <lambdabot> f = liftM2 (^) lenght
13:44:01 <luite> elliott: yeah we need some people to implement all those algorithms in haskell though :p
13:44:04 <mauke> @pl f length xs = length xs^length xs
13:44:04 <lambdabot> f = ap =<< ((^) .)
13:44:15 <luite> edwardk is already some numerical things :)
13:44:32 <pozic> luite: I think it is better to have them implemented in C++ and get Haskell bindings for those :)
13:44:38 <edwardk> hah
13:44:52 <edwardk> pozic: depends on if you want to retain your sanity
13:44:57 <mauke> @pl f xs = (\length -> length xs^length xs) length
13:44:57 <lambdabot> f = flip (ap (ap . ((^) .) . flip id) (flip id)) length
13:45:09 <maloi> oO
13:45:17 <luite> but there's not much symbolic math going on in haskell, I think...
13:45:17 <edwardk> haskell AD is a hell of a lot nicer to work with than c++ AD
13:45:23 <mauke> @. unpl pl f xs = (\length -> length xs^length xs) length
13:45:23 <lambdabot> f c = ((\ u z -> (\ ag -> (^) (ag u)) >>= \ w -> z >>= \ v -> return (w v)) >>= \ n -> (\ j k -> k j) >>= \ m -> return (n m)) c length
13:45:27 <edwardk> luite: just use ad and Debug.Traced ;)
13:45:27 <mauke> perfect
13:45:41 <luite> hehe
13:45:42 <edwardk> you can do symbolic differentiation all day long
13:45:43 <rasfar> did i miss the "preview"?
13:45:58 <edwardk> no good symbolic integrator though
13:46:01 <maloi> i guess f xs = (l)^(l) where l = length xs is ok?
13:46:39 <luite> gsoc project: implement Risch? :)
13:46:40 <edwardk> i have a bunch of quadrature schemes for numerical integration, and i was working on building up a piecewise pade approximant library for doing more robust integration
13:46:42 <byorgey> maloi: sure.  but you don't need those parentheses.
13:46:50 <hpc> edwardk: some think there never will be a good symbolic integrator
13:46:52 <edwardk> luite: risch is pretty boring
13:47:19 <hpc> just hacky heuristics for many special cases
13:47:26 <luite> what do commercial packages use nowadays?
13:47:33 <mauke> @unpl f = join (liftM2 (^)) length
13:47:34 <lambdabot> f = ((\ d e -> d >>= \ b -> e >>= \ a -> return (b ^ a)) >>= \ f -> f) length
13:47:37 <mauke> :-|
13:47:51 <hpc> haha
13:47:52 <mauke> > join (liftM2 (^)) length "xxx"
13:47:52 <edwardk> luite: from talking to jacques carette there are a lot of pade approximant tricks being used (he used to run the team at maple)
13:47:53 <lambdabot>   27
13:48:10 <edwardk> luite: thats one reason why i wanted a nice library for manipulating them in haskell
13:48:13 <maloi> byorgey: yes, thanks
13:48:26 <luite> edwardk: ah right, cool :)
13:49:18 <edwardk> i got distracted by needing usable intervals and known rounding modes in order get taylor models running, and my algebra package was started so i could work on pade approximants (i needed some weak ring structures), but i got distracted by redefining geometric algebra
13:50:29 <luite> how did you arrive at the recent raytracing distraction then? :p
13:56:40 <rasfar> if i have constraint lists like "(Eq n,Enum n,Ord n,Show n,Num a,Ord a,Num b) =>" on all my methods what am i probably doing wrong?  overgeneralising?
13:57:26 <monochrom> Ord n subsumes Eq n. you can already omit Eq n
13:57:40 <luite> I had those earlier today, but then I was forgetting to nub my constraint lists
13:58:28 <monochrom> the rest are probably irreducible
13:58:44 <rasfar> okay; it's a bit hard to keep them minimal as they grow. / i see
13:58:45 <elliott> rasfar: s/methods/definitions/
13:58:51 <elliott> (methods are typeclass methods, so that can be confusing in this context)
13:58:53 <rasfar> oops, right
13:59:41 <rasfar> things really got crazy when i wanted it polymorphic over real and complex
14:00:06 <monochrom> but I am a bit surprised that you get three type variables n, a, b and they don't seem to interact at all
14:00:07 <rasfar> a bit unfortunate as the complex stuff is just an experiment and probably won't work out
14:00:30 <Mathnerd314> gwern: the IO tests pass by printing <IO ()>, when the script thinks they're supposed to fail... how should this be handled?
14:00:50 <rasfar> i'm resusitating some old code; i'm not even sure what n is.  a and b are node and edge weights respectively.
14:01:24 <gwern> Mathnerd314: dunno. I suppose the script could test whther it prints exactly "<IO ()>" and not anything else
14:02:21 <rasfar> i guess n is for the node indices; maybe i should just commit to Int and lay that one to rest :)
14:02:41 <hpc> > putStrLn "hello" -- Mathnerd314: i bet quickcheck is doing what lambdabot does
14:02:42 <lambdabot>   <IO ()>
14:02:49 <hpc> > readFile "/etc/passwd"
14:02:50 <lambdabot>   <IO [Char]>
14:03:07 <Mathnerd314> gwern: ok. maybe the tests should work by outputting everything to a file which should be identical to a reference file?
14:04:33 <Mathnerd314> hpc: this is mueval we're talking about, and IIRC lambdabot calls mueval when it's doing stuff, so they should be pretty similar actually
14:04:59 <hpc> Mathnerd314: what it's doing is calling 'show' on an IO action
14:05:05 <hpc> > show (putStrLn "hello")
14:05:06 <lambdabot>   "<IO ()>"
14:05:27 <gnoi> How can I convert value from Maybe () to IO ()?
14:05:49 <hpc> :t const (return ()) -- gnoi
14:05:50 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> m ()
14:05:51 <Mathnerd314> :t void
14:05:52 <lambdabot> Not in scope: `void'
14:05:57 <Mathnerd314> @hoogle void
14:05:57 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
14:05:57 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
14:05:58 <lambdabot> package void
14:06:54 <gnoi> What about Maybe a -> IO a
14:06:54 <gnoi> ?
14:07:01 <Mathnerd314> let void a = return () in void . return
14:07:15 <gnoi> :t const return
14:07:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => b -> a -> m a
14:07:19 <hpc> @src Maybe
14:07:20 <lambdabot> data Maybe a = Nothing | Just a
14:07:22 <Mathnerd314> gnoi: what it should it do with a value of Nothing?
14:07:26 <monochrom> if f :: Maybe a -> IO a, what should f Nothing do?
14:07:51 <hpc> (if you can answer that question, you can probably write it yourself)
14:09:01 <gnoi> Probably it is better to use IO (Maybe a)
14:12:45 <rasfar> I've got a lot of parameters of type "Network n a b" and have to give the constraints every time; if I create a new type class I can replace those constraint lists with a single constraint to the class, correct?
14:13:06 <rasfar> (possibly at the expense of some generality on some of the methods)
14:13:13 <rasfar> s/methods/definitions/ !!!
14:13:19 <hpc> rasfar: like a "class synonym"?
14:13:41 <hpc> that's actually mentioned somewhere in the GHC manual under the type class extensions section
14:14:24 <rasfar> i guess?  or like class (Eq n,Enum n,Ord n,Show n,Num a,Ord a,Num b) => Network n a b where ... (or something! i don't use classes much excuse me)
14:14:51 <rasfar> s/Eq n,//
14:15:07 <hpc> yeah, you can do that
14:15:15 <hpc> uh... flexible constraints is the term i think
14:15:18 <rasfar> Network is currently newtype
14:16:27 <rasfar> really? that would require extension? my vague impression was abstracting constraint lists was one of the basic purposes of classes.
14:17:07 <rasfar> since it's working with the awful constaint lists on all the definitions i'll put that on the back burner for now
14:17:10 <elliott> hpc: huh?
14:17:15 <elliott> rasfar: you need multiparamtypeclasses
14:17:19 <elliott> and you'll needa n instance for each type you want
14:17:20 <elliott> er
14:17:22 <elliott> each set of types that is
14:17:29 <elliott> you mightw ant to factor out each part separately
14:17:59 <rasfar> by each part, you mean the n, a, and b parts?  so have a class for NodeWeight, EdgeWeight, etc?
14:18:03 <elliott> you can actually do a proper constraint synonym with constraintkinds
14:18:11 <elliott> rasfar: yeah
14:18:32 <rasfar> wow, so this will need at least one and maybe two extensions to do it nicely.  i'm surprised.
14:19:28 <rasfar> thanks elliott, hpc, monochrom and anyone else who responded!  i think i'll postpone that refactoring for a bit.
14:20:40 <air00> how much would you guys offer in the ultimatum game?
14:23:51 <nart> conduit vs iteratee io, pros and cons ? =)
14:24:54 <ivanm> nart: I believe the main advantages of conduits are better error messages through separate types and the ability to have exceptions within the inner monads
14:25:05 <ivanm> plus it's under *quite* active development
14:25:08 <monochrom> conduit is newer
14:26:02 <nart> so i should read something about conduit
14:26:06 <monochrom> the authors are active. so active that:
14:26:09 <nart> thanks :)
14:26:19 <monochrom> snoyman : conduit :: apple : iphone
14:26:27 <copumpkin> o.O
14:26:36 <luite> the separate types will probably be combined into one type in the next version
14:26:46 <nart> is there any good good paper / tutorial that you know ?
14:27:01 <ivanm> monochrom: you mean that there's a whole crowd of people learning yesod just so that they can use conduit?
14:27:03 <ivanm> :p
14:27:29 <ivanm> luite: so then the "better error messages" aren't as important anymore? :/
14:27:43 <monochrom> no, I mean that snoyman invents a new, incompatible replacement every so often. conduit is already the 2nd generation.
14:28:13 <luite> conduit itself is almost at the 4th generation now :)
14:28:49 <monochrom> precisely. expect a "conduit 5s. this changes everything. again" soon
14:29:25 <luite> hmm, dunno, it's ony a few months old, so it's not that surprising that the API is still being refined?
14:29:38 <ivanm> luite: agreed
14:29:46 <ivanm> especially as it's something that he's trying to get "right"
14:29:58 <luite> after all, there was no perfect existing solution before, there was no solution in sight for the problems with enumerator
14:30:00 <ivanm> and without creating yet-another-conduit-implementation whilst doing so :p
14:30:07 <monochrom> don't just look at conduit. look at the predecessor of conduit, too, to see the big picture
14:30:39 <elliott> snoyman didn't invent enumerator :p
14:30:48 <luite> hmm, not sure what you mean there
14:31:14 <monochrom> my point is in 12 months snoyman will abandon conduit altogether and invent a new I/O lib
14:31:18 <luite> why?
14:31:36 <monochrom> because he is active
14:32:25 <monochrom> it will be even better than conduit, on the bright side
14:33:08 <tech2> monochrom: however, it'll require people adapt, again, to something different. Or take up where he left off
14:33:11 <luite> well if some new way of doing streaming IO is invented, I guess that he might switch Yesod to it
14:33:27 <luite> but the problems with enumerator were real
14:33:51 <monochrom> sure, tech2, just look at iphone, ipods, macs, macbooks
14:33:53 <luite> it required you to lift part of your handlers to a different monad, where you couldn't access the request body
14:34:08 <tech2> monochrom: not quite the same, surely?
14:34:28 <luite> monochrom: for users of the Yesod framework, not much has changed by the way
14:34:38 <monochrom> almost every other generation of iphone "require people adapt, again, to something different"
14:34:42 <luite> if you do streaming responses directly, then you have to adapt a few lines of coe
14:35:11 <luite> but far more visible is that you don't have to liftIOHandler every part of your handlers that does exception handling
14:35:25 <luite> and find ways to consume the request bodies outside those lifted parts
14:35:58 <monochrom> I don't understand why you are painstakingly explaining to me the advantages of conduit compared to enumerator
14:36:42 <monochrom> surely I know that the whole point of changing is improvements and benefits and fixing problems?
14:37:40 <monochrom> and indeed I rely heavily on that reason to predict yet another big change next time
14:39:15 <luite> right, it's the comparison with apple... apple wants to sell new things, not because they're better, but because they want to sell things
14:39:34 <luite> michael doesn't have any interest in selling new things if it doesn't do something better
14:39:40 <monochrom> I am not comparing their intents and motivations
14:41:04 <luite> ok
14:42:27 <monochrom> perhaps I should use Steve Jobs instead of Apple? Steve Jobs had so much money that he had long ceased to be motivated by money. his drive was more about perfection
14:43:24 <monochrom> but then you will poke it with "but snoyman isn't vegetarian"
14:43:43 <ivanm> to apply Michael's motivations to Steve Jobs: Steve kept pushing Apple to make new iPhones because he wanted a new phone every two years :p
14:43:46 <luite> hehe
14:45:00 <luite> I'm not sure that Yesod is about perfection btw, but it's about making something that works :)
14:47:02 <monochrom> I am sure. if the only criterion is "works", snoyman wouldn't firstly try haskell, and if haskell, wouldn't secondly invent his own web framework. snap already "works". happstack already "works"
14:47:43 <hpaste> xmlns pasted “Brainfuck Interpreter” at http://hpaste.org/66134
14:48:02 <ivanm> monochrom: wasn't he working on yesod before snap came out though?
14:48:08 <luite> hehe no that's right, there is more, but lots of the yesod code is certainly not perfect yet
14:48:21 <luite> it's more a pragmatic framework than a perfectionist one
14:48:39 <ivanm> luite: exhibit one being usage of TH?
14:49:06 * elliott can't call TH either pragmatic *or* perfect :)
14:49:32 <monochrom> the yesod tutorial has "look how I am so much simpler and more organized to use" written all over it. that should remind you of Steve Jobs bragging "my iphone is so much simpler and more sensible to use"
14:49:39 <ivanm> elliott: I believe their usage of TH can be described as being pragmatic
14:49:59 <ivanm> in that it avoids writing a lot of repetitive boilerplate that could lead to logic errors, etc.
14:50:20 <luite> ivanm: dunno if a perfectionist one could never use TH, but the quasiquoters for routes and persistent models are less flexible then a solution that would be more haskell
14:51:00 <ivanm> luite: right, but then you would need to use Haskell as a preprocessor to generate more haskell
14:51:02 <luite> so there has been some criticism, that boomerang would be better
14:51:26 <ivanm> boomerang? as in the package on hackage?
14:51:41 <luite> ivanm: you'd define your routes in haskell, and use some small TH call to generate all the necessary types and dispatch functions
14:51:43 <luite> yes
14:52:07 <luite> there's some routes thing for it
14:52:18 <luite> forgot the name
14:52:19 <stepkut> http://happstack.com/docs/crashcourse/WebRoutes.html#web-routes-boomerang
14:52:23 <ivanm> why boomerang rather than any other pretty-printing library? I wasn't aware that any parsing would be required
14:52:26 <ivanm> ahhh
14:52:33 <stepkut> ivanm: you have to print *and* parse
14:52:41 <luite> looks like web-routes-boomerang
14:52:43 <luite> yeah
14:52:45 <monochrom> my "perfection" refers to easy-to-use, BTW. not to what its internal code look to you
14:52:51 <luite> oh thanx stepkut :p
14:53:07 <stepkut> you have to convert a URL type to a string to put it in HTML, and parse it back to a type when the user makes a page request
14:53:42 <luite> monochrom: oh same for me
14:54:27 <ivanm> stepkut: OK, that makes sense then
14:54:37 <luite> but for example the quasiquoter for routes can lead to a bit more repetition than doing it in haskell
14:55:30 <luite> if you have lots of routes that live under /admin, and you want to do some specific authentication for all of those, there's no nice way to do that with the quasiquoter
14:55:36 <stepkut> luite: yeah, the QQ solution is not very extensible/composable
14:56:08 <luite> while if you used plain askell, you could make a list of those routes, and put it under /admin, and use the same list in the auth function
14:57:12 <luite> it still captures most use cases nicely... grouping routes by path is actually the only thing missing I've heard so far
14:57:42 <luite> and it's more concise than haskell code
14:58:16 <luite> but an alternative API that just used TH would be a nice addition, unfortunately so far noone has bothered to write one
14:58:36 <stepkut> luite: more concise.. until you need to do something beyond the basic capabilities it provides.. then you are left hanging
14:59:03 <maloi> i'm looking for a function that takes a list and returns a list of the number of occurences of any number in the list...like f [1,2,2,2,3] = [1,3,1]
14:59:05 <maloi> any ideas?
15:00:11 <Mathnerd314> gwern: patches sent. although I forgot to increment the version number.
15:00:20 <gwern> what did you do?
15:00:21 <luite> stepkut: yeah but I think that's hardly a problem in practice, most use cases are covered, and if yours is not, you could easily fall back to something else
15:00:55 <stepkut> luite: I think that in practice people *limit themselves to the cases that are covered because it is too hard to fall back to something else*
15:00:59 <elliott> framework war!
15:01:42 <Mathnerd314> gwern: removed the resources stuff, mostly
15:01:55 <gwern> removed one of the rings of protection?
15:02:10 <luite> stepkut: hmm, could be, although I've never felt that to be the case. do you have an example?
15:02:16 <elliott> gwern: here's my patch to mueval: system ("ghc -e '" ++ expr ++ "'")
15:02:28 <gwern> elliott: hm, I love how much it shrinks the codebase
15:02:34 <stepkut> luite: yes. I will be publishing a blog post on it in a few weeks
15:02:36 <gwern> a good day's work
15:02:39 <elliott> gwern: bonus feature: you can pass options to ghc now
15:02:40 <geekosaur> maloi: there's no single function that does so but it's easy to create one.  look through Data.List
15:02:42 <elliott> 2+2' -Wall
15:03:05 <monochrom> my patch is even smaller: system expr
15:03:15 <elliott> monochrom: ooh, now it works with hugs too
15:03:16 <elliott> and gcc
15:03:28 <monochrom> I am thinking of netcat
15:03:34 <maloi> geekosaur: yes i thought there is maybe a standard approach for it
15:04:15 <hpc> monochrom: here's my patch: id
15:04:22 <luite> stepkut: ok I look forward to reading it
15:04:22 <hpc> monochrom: as an added bonus, it's strongly typed
15:04:26 <hpc> no more of that String nonsense
15:04:45 <monochrom> unfortunately, that is too secure
15:05:38 <maloi> @pl map length $ group $ sort xs
15:05:38 <lambdabot> map length (group (sort xs))
15:05:55 <stepkut> luite: I look forward to you reading it!
15:06:25 <donri> luite: same applies to other QQs. i ported an app from lucius to language-css and could abstract things like vendor prefixes easily. lucius doesn't have anything like sass mixins that i'm aware of ...
15:06:49 <Mathnerd314_> gwern: I think it was mostly redundant; admittedly I don't know enough to prove it
15:08:22 <nart> wut ? why i get     Not in scope: type constructor or class `Resource'
15:08:22 <nart> Failed, modules loaded: none.
15:08:34 <nart> i'm following this http://www.yesodweb.com/book/conduits
15:09:43 <hpaste> shergill pasted “quoting arguments” at http://hpaste.org/66138
15:09:52 <donri> @pl \xs -> map length $ group $ sort xs
15:09:52 <lambdabot> map length . group . sort
15:10:19 <maloi> donri: i have this
15:10:21 <shergill> i feel dirty for using Data.Typeable in there ^. does someone have a better solution to the quoting problem that i was trying to solve
15:10:39 <maloi> is there a way without the need to sort the list?
15:10:54 <shergill> oh it only pasted the region
15:11:08 <hpaste> shergill pasted “quoting arguments” at http://hpaste.org/66139
15:15:24 <Mathnerd314> is there a hackage mirror somewhere with reverse dependencies?
15:16:05 <luite> donri: right, the limitations of the QQ are much more visible when the language you're basing things on is rather weak in abstraction
15:16:28 <luite> donri: do you convert language-css output to the Yesod CSS type btw?
15:17:08 <ivanm> Mathnerd314: http://hackage.factisresearch.com/package/
15:17:16 <ivanm> ^^ hackage 2!!!
15:17:27 <ivanm> or else there's packdeps, etc.
15:17:46 <nart> grrrrrrr, where the heck is the type Resource that's used in the conduit package
15:18:17 <ivanm> nart: the resourcet package?
15:19:12 <rasfar> maloi: check out http://stackoverflow.com/questions/9772098/building-a-histogram-with-haskell-many-times-slower-than-with-python
15:19:27 <rasfar> luite, maybe Niklas has heard us, considering the GSoC project proposal he's vetted.
15:20:12 <luite> rasfar: he might have... but I'd be (pleasantly) surprised if the project succeeds
15:20:28 <nart> ivanm: found it, i have conduit-0.3.0 and Resource has become MonadResource
15:21:00 <rasfar> d'accord
15:21:48 <luite> rasfar: I've already said this in #diagrams, but people are going to expect that they can use all GHC features, and you need to be able to find and load dependencies somehow, that looks like a big chunk of GHC you need to implement
15:22:46 <rasfar> it would really be better if the GHC project used haskell-src-exts to begin with (separation of concerns etc.)
15:22:48 <donri> luite: no why would i do that?
15:23:15 <luite> donri: you said you ported from lucius to language-css, it could (still) be a Yesod app
15:23:22 <donri> luite: it never was :)
15:23:27 <rasfar> otherwise it will always be catch-up for HSE, an unenviable position
15:24:05 <heatsink> Are types with free variables but no foralls, like forall. a -> [a], called polymorphic or monomorphic?
15:24:18 <elliott> heatsink: that's not a type
15:24:33 <elliott> unless there's a specific a in context -- in which case it's monomorphic
15:24:43 <monochrom> "a -> [a]" is polymorphic, if "a" is really a free type variable
15:25:10 <danharaj> if I want a list of values of a GADT, do I have to newtype wrap or can I turn on impredicative types and use [forall a. Foo a] without GHC hating me?
15:25:30 <monochrom> as opposed to a variable that stands for "an unknown to be solved"
15:25:49 <elliott> danharaj: just newtype it, impredicative types are never (rarely) the answer :p
15:25:58 <donri> luite: still, even if it was yesod why convert types? can't you easily use other types in yesod for some reason? (widgets?)
15:26:01 <copumpkin> danharaj: [forall a. Foo a] is the wrong type
15:26:11 <copumpkin> you'd want [exists a. Foo a]
15:26:19 <danharaj> yes you are right.
15:26:22 <elliott> yeah that too
15:26:30 <copumpkin> which unfortunately we can't write :)
15:26:36 <danharaj> I'd really like if we could :(
15:26:46 <monochrom> "a list of values of a GADT" sounds like [MyGADTNameHere] to me
15:26:48 <elliott> uhc can
15:26:57 <heatsink> > let {f :: forall a. a -> [a]; f x = let {g :: forall. a -> [a]; g y = [y]} in g x}
15:26:58 <lambdabot>   not an expression: `let {f :: forall a. a -> [a]; f x = let {g :: forall. a...
15:27:02 <heatsink> > let {f :: forall a. a -> [a]; f x = let {g :: forall. a -> [a]; g y = [y]} in g x} in f 1
15:27:03 <lambdabot>   [1]
15:27:08 <danharaj> monochrom: MyGADTNameHere is a type constructor though.
15:27:12 <heatsink> So g is monomorphic
15:27:31 <copumpkin> monochrom: presumably he means that it has a phantom type argument that gets refined by data constructors
15:27:37 <copumpkin> or more than one
15:27:38 <danharaj> Indeed.
15:28:10 <luite> donri: hm, I'm pretty sure that you can't have widgets in lucius and cassius, since they don't make much sense there (a Widget is a combination of content in the body and things to be inserted in the header)
15:28:30 <donri> luite: you can put css in header :)
15:28:35 <monochrom> since it's a phatom type, you don't even need existential
15:29:07 <monochrom> f :: MyGADTNameHere a -> LoseThePhantom  is writable
15:29:20 <donri> luite: so why did you think i might convert between types? what'd be the gain?
15:29:24 <monochrom> then use [LoseThePhantom] instead
15:29:32 <luite> donri: you can use a widget that inserts some css of course, that's probably the main use case for the quasiquoters, small css snippets in the widgets
15:29:36 <donri> i'm honestly curious!
15:29:44 <monochrom> presumably g :: LoseThePhantom -> MyGADTNameHere a  is also writable
15:29:57 <danharaj> monochrom: I know. I wanted to avoid a wrapper.
15:30:15 <luite> donri: oh I thought that oyu had a yesod web app, but some annoying css stylesheet with lots of repetition, and then converted that stylesheet from lucius to language-css
15:30:16 <heatsink> monochrom, I don't think you can say that the variable 'a' is an unknown to be solved if it's bound by a forall in an outer context.
15:30:17 <monochrom> existential type needs a wrapper. plus an extension
15:30:26 <elliott> phantom doesn't need gadts
15:30:27 <elliott> gadt
15:30:32 <elliott> so i suspect danharaj's param is not actually phantom
15:30:38 <donri> luite: ah you thought i was using *both*. no, ported the whole stylesheet.
15:31:11 <donri> luite: anyway doesn't look like lucius does *any* "snippet interpolation"
15:31:20 <donri> or whatever ^{} is called in hamlet
15:31:27 <luite> widget yes
15:31:42 <luite> no since widget are kind of html-specifi
15:31:43 <luite> c
15:31:58 <luite> you can use #{...}, but that probably works only for single fields
15:32:18 <donri> yea, not sure that even works for properties... just values?
15:32:21 <luite> I think most people see lucius as regular css in which you @{RouteR } your urls
15:32:36 <luite> so its pretty limited in that respect :)
15:32:37 <donri> + nested selectors
15:33:09 <donri> one thing language-css actually does *not*, although since selectors are combinators you can abstract that too ...
15:33:28 <luite> ah right, yes
15:33:35 <luite> css doesn't support that
15:33:46 <donri> + variables
15:35:59 <luite> ah
15:36:21 <nart> grrrrr, damn conduitss
15:36:48 <nart> anyone has "experience" with conduit-0.3.0 ?
15:37:50 <Clint> not yet
15:38:22 <nart> that lib is driving me crazy
15:38:29 <luite> donri: I wonder how hard it would be for a designer (non-programmer) to use language-css
15:38:45 <donri> oh, probably would drive them insane
15:39:03 <donri> though it's close to CSS but in haskell combinators
15:39:46 <elliott> nart: What problem are you having?
15:40:15 <nart> that the examples in the yesod book, don't work
15:40:42 <nart> elliott: sum' xs = runST $ runResourceT $ CL.sourceList xs $$ sumSink ... it's not working
15:40:51 <nart> Couldn't match type `GHC.ST.ST s' with `IO'
15:41:05 <elliott> That's because ST isn't IO.
15:41:17 <elliott> ResourceT only works with IO nowadays.
15:41:19 <elliott> Remove the runResourceT.
15:41:26 <elliott> The Yesod book's introduction to conduits is for 0.2.
15:41:33 <donri> luite: i don't really subscribe to the idea that you shouldn't have stuff like markup in code. i like hsp/blaze, i like language-css. no reason a designer can't add a raw css file, or some lucius, on top of that.
15:41:33 <elliott> Libraries change, esp. at this early stage.
15:41:37 <luite> you probably can also remove runResourceT here as well
15:41:51 <luite> it's now only required for conduits that actually use resources
15:41:55 <donri> luite: otherwise if you take that idea to its extreme, you can't use stuff like jquery-ui.
15:41:57 <nart> now i get     No instance for (MonadResource (GHC.ST.ST s))
15:41:59 <elliott> luite: That's what I said.
15:42:08 <elliott> nart: Change a MonadResource constraint to Monad.
15:42:29 <nart> omg it works
15:42:36 <luite> elliott: oh right I missed that, next time say it louder ;)
15:43:04 <monochrom>  
15:43:11 <nart> elliott: thanks
15:43:13 <monochrom> R E M O V E
15:43:13 <monochrom>  
15:43:25 <heatsink> H U H ?
15:43:26 <monochrom> I should try that trick more
15:43:40 <elliott> i was about to beat monochrom.
15:43:45 <elliott> but this stupid channel is +c. sheesh! no bold.
15:43:58 <luite> donri: well, I think that lucius actually encourages markup in code, if you count quasiquoters :)
15:44:00 <elliott> imagine this is bold: R E M O V E
15:44:02 <monochrom> did you know that +c was my idea? :)
15:44:24 <donri> luite: :) i actually kinda like lucius. i guess i could file a request for stuff like mixins ...
15:45:00 <elliott> monochrom: what! you're terrible.
15:45:22 <donri> though language-css has other benefits still. like it just works with my completions setup in vim.
15:45:25 <luite> donri: my stuff is half cassius, half plain .css atm, I really need to fix that :(
15:45:30 <donri> nice for those long property names
15:45:35 <nart> why the Sink type is defined data Sink input m output ... i mean why the monad between input and output ?
15:45:45 <Mathnerd314> monochrom: why did you suggest it?
15:45:46 <elliott> nart: so it can have a MonadTrans instance
15:46:02 <nart> mmm monadtrans
15:46:07 <monochrom> because I hate colours
15:46:36 <Mathnerd314> monochrom: why do you hate colours?
15:46:38 <mgsloan> colours: http://www.mgsloan.com/mockup6.png !
15:46:42 <mauke> racist
15:47:06 <mgsloan> yeah, variables of color would be offended
15:47:57 <nart> elliott: but the constrain is just Monad m, it doesn't require a Monad transformer
15:48:30 <monochrom> haha, "I hate colours" from someone called "monochrom" isn't very attractive, is it? :)
15:48:42 <elliott> nart: what?
15:48:49 <elliott> it's so you can execute actions of m in Sink.
15:48:56 <elliott> if it was Sink m input outpout, Sink could not be MonadTrans.
15:49:11 <luite> donri: what do you think about the haskell code that should be allowed inside #{...} ?
15:49:12 <elliott> mgsloan: that's lovely
15:49:19 <luite> donri: in hamlet/lucius etc?
15:49:26 <nart> ah sorry, i misunderstood your previous answer, i got it now
15:49:29 <elliott> i don't understand it
15:49:30 <elliott> but it's lovely
15:49:35 <mgsloan> elliott: thanks :) Gotta implement it now
15:49:45 <luite> hehe
15:49:47 <mgsloan> elliott: the Mini-Tut here might help  http://www.mgsloan.com/mockup6.png
15:49:52 <donri> luite: either any expression, or just an identifier. nothing in the middle :P
15:50:05 <monochrom> more seriously, we had some colour spam, and also honest colour mistakes (irc newbies unknowingly load up try-to-be-cute scripts). it became a bit tiresome to say "please turn off colours", even just for the honest mistake cases. so, one day, I suggested to the other ops, "if you don't object, I'm going to go ahead and +c". and so I did.
15:51:20 <elliott> monochrom: there should be a flag to turn off colours but not bold :)
15:51:35 <elliott> mgsloan: you just linked the same image again
15:51:38 <elliott> mgsloan: does this mean I'm unworthy?
15:51:42 <elliott> mauke: hi
15:51:44 <mgsloan> doh!  http://www.mgsloan.com/mockup5.png
15:51:45 * hpc wishes there was an easy way to copy agda code colors to irc
15:51:49 <mauke> damn xchat users
15:52:00 <luite> donri: yeah I personally want to allow as much as possible, any expression. but many of the others think that would maek it too complicated for designers. I don't understand that reasoning though
15:52:05 <elliott> mauke: :)
15:52:09 <elliott> i hate xchat
15:52:46 <mauke> irssi users represent
15:52:53 <mauke> aw, they fixed it?
15:53:02 <elliott> i hate irssi more though
15:53:28 <hpc> i can deal with irssi because i dont need configuration
15:53:41 <adnauseam> what hpc said
15:54:13 <hpc> or features
15:54:24 <mauke> I do
15:54:25 * adnauseam nods head 
15:55:16 <elliott> I don't need IRC
15:55:52 * adnauseam hands elliott a happy pill
15:56:00 <adnauseam> seems like we all need one today
15:56:22 <hpc> pppsh, parsec pills ftw
15:56:44 <monochrom> haha
15:57:07 <elliott> trifecta pills work really fast, but come in completely blank packaging
15:57:19 <wo0kie> hello :)
15:57:20 * hpc has done deplorably little haskell coding lately
15:57:48 <hpc> some really intense agda, and perl mostly
15:57:49 <adnauseam> alo wo0kie
15:58:05 <adnauseam> hpc - no projects in mind ?
15:58:23 <elliott> hpc: sounds like you need a language with the benefits of both agda and perl
15:58:27 <elliott> pergda
15:58:59 <hpc> adnauseam: im working on making lambdabot less of a mess
15:59:02 <hpc> theoretically
15:59:14 <hpc> but i get tied up with work and classes
15:59:25 <adnauseam> oh that sounds interesting actually
15:59:52 <adnauseam> is it something a noob can help in ?
15:59:55 <hpc> it's really not :P
16:00:08 <hpc> i havent even gotten @oeis working
16:00:09 <adnauseam> what sort of things are you doing to it ?
16:00:30 <hpc> adnauseam: first, figuring out how to run it :P
16:00:35 <elliott> wfm
16:01:04 <adnauseam> hah, ill be done with lyah soon enough and see about it
16:01:08 <hpc> http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13 -- my progress so far
16:01:56 <liyang> agderp
16:03:10 <hpc> plerdalg -- the most unfortunate concatenation of "agda" and "perl"
16:03:52 <elliott> apgedral
16:05:57 <adnauseam> hpc - looks straight forward enough. it'll be the first thing i do after i'm done reading
16:06:17 <rasfar> agape DR(oo)L
16:06:37 <Mathnerd314> hpc: I'm getting it working with 7.0.2 (on windows)... AFAICT the readline dependency is actually unnecessary
16:07:36 <wo0kie> is there a way get all possible combinations of a tuple of 5?
16:07:53 <wo0kie> I want to check each element against all the other elements
16:08:05 <c_wraith> of a tuple?
16:08:08 <wo0kie> (this is hw, so no straight answers please)
16:08:11 <wo0kie> yeah
16:08:16 <mauke> combinations?
16:08:24 <wo0kie> I'm trying to score cribbage using a tuple of (Card,Card,Card,Card,Card)
16:08:28 <wo0kie> recursively
16:08:30 <c_wraith> ah.
16:08:33 <mauke> huh?
16:08:42 <wo0kie> card game :)
16:08:56 <wo0kie> one of the ways to score is to find any combination of cards that adds up to 15
16:09:02 <wo0kie> :o
16:09:03 <OODavo> I'm attempting to split a list into a fixed number of equal-sized components. My current attempt is: splitInto l lst = splitEvery (length lst `div` l) lst
16:09:06 <OODavo> Unfortunately, due to the rounding involved in `div`, I get eight sublists from splitInto {6,7} "a sample string". Any suggestions?
16:10:34 <wo0kie> I could convert the tuple to a list no?
16:10:41 <wo0kie> and then try finding all possible combinations?
16:10:48 <wo0kie> that would add to 15?
16:11:01 <wo0kie> (since the tuple is guaranteed to be 5 elements in length)
16:13:12 <gnoi> How can I (Maybe a, Maybe a) -> Maybe (a,a)
16:13:14 <gnoi> ?
16:13:23 <elliott> gnoi: liftA2 (,0
16:13:24 <elliott> gnoi: liftA2 (,)
16:13:27 <elliott> er
16:13:31 <elliott> gnoi: uncurry (liftA2 (,))
16:19:04 <ski> > mergeByM (\_ _ -> [True,False]) "agda" "perl"
16:19:05 <lambdabot>   ["agdaperl","agdpaerl","agdpearl","agdperal","agdperla","agpdaerl","agpdear...
16:19:12 <ski> > length (mergeByM (\_ _ -> [True,False]) "agda" "perl")
16:19:14 <lambdabot>   70
16:20:37 <elliott> @hoogle mergeByM
16:20:37 <copumpkin> :O
16:20:37 <lambdabot> No results found
16:21:02 <copumpkin> oh, I see
16:21:09 <elliott> copumpkin: apparently hpc has been writing mainly agda and perl lately
16:21:13 <elliott> so i suggested the obvious.
16:22:00 <ski> > filter (`notElem` (mergeByM (\_ _ -> [True,False]) "agda" "perl")) ["plerdalg","apgedral"]
16:22:02 <lambdabot>   ["plerdalg"]
16:29:56 <kaitocracy> is there any way to set the default string type in a file?
16:30:10 <kaitocracy> for me to say, every string in this file will be Data.Text.Lazy (Text)
16:32:57 <bxc> hmm Crypto-4.2.4 is not building for me on ghc 7.4.1
16:33:18 <donri> kaitocracy: maybe if you get rid of IsString with NoImplicitPrelude...
16:34:14 <hpaste> “benc@cqx/ltd/uk” pasted “crypto build failure” at http://hpaste.org/66143
16:41:04 <geekosaur> bxc, the fix for that is exactly what the error message says; ghc 7.4.1 got rid of the Show requirement for Num and descendants, so you have to specify it yourself
16:41:17 <bxc> yeah
16:41:22 <bxc> i just figured that out
16:42:01 <bxc> is there a version control repo for that? I just see a downlaod tarball on teh hackage page
16:43:07 <rasfar> i'm trying to use QuickCheck for the first time.  actually, thinking about trying...  is anyone interested in some hand-holding?
16:43:31 <liyang> Sure, if you pay for dinner.
16:44:05 <rasfar> ahaha.  i may have to order you something for delivery, unless you happen to be in montreal
16:44:49 <rasfar> should i stay away from QuickCheck 2 given then seemingly-nonexistent state of its documentation?
16:45:23 <liyang> In the simple case, you just call quickCheck with any function that returns a Bool.
16:45:29 <bxc> geekosaur: adding those instance decls isn't goign to hurt when building on 7.2 and earlier, right?
16:45:46 <rasfar> quickCheck should be a binary in ~/.ghc/bin?
16:46:09 <rasfar> no no, nm last remark
16:46:10 <liyang> rasfar: no, it's an export from Test.QuickCheck.
16:46:51 <rasfar> so i write a property, which is a function that returns Bool based on my expectations, and quickCheck will take care of creating arbitrary instances of the relevant data types?
16:47:02 <geekosaur> bxc, no, they're redundant but won't cause errors or even warnings.  you might want to contact the maintainer at their email adrdess on the hackage page
16:47:19 <bxc> yeah when i've patched it here i'll send on the patch
16:47:37 <rasfar> and this much is the same from version 2 and the original?
16:47:39 <liyang> > quickCheck (\ n -> succ (pred n) == (n :: Integer))
16:47:40 <lambdabot>   Not in scope: `quickCheck'
16:47:42 <bxc> i just liek to do things like that inside the native VCS
16:47:45 <liyang> :(
16:48:02 <liyang> rasfar: yes. Close enough. Version 2 has been around for years...
16:48:02 <bxc> because its a total hassle to track separate patches otherwise
16:48:15 <rasfar> > Test.QuickCheck.quickCheck (\ n -> succ (pred n) == (n :: Integer))
16:48:15 <lambdabot>   Not in scope: `Test.QuickCheck.quickCheck'
16:48:31 <rasfar> @hoogle quickCheck
16:48:31 <lambdabot> package QuickCheck
16:48:31 <lambdabot> Test.QuickCheck.Test quickCheck :: Testable prop => prop -> IO ()
16:48:32 <lambdabot> Test.QuickCheck quickCheck :: Testable prop => prop -> IO ()
16:48:33 <monochrom> quickcheck doesn't have an executable, does it?
16:48:52 <monochrom> but if you're looking for executables, ~/.cabal/bin
16:49:18 <rasfar> monochrom, nah it's okay it was some vestigial confusion based on something i read somewhere...
16:49:33 <liyang> Don't think lambdabot will do quickCheck. In general, instead of a Bool, you can return a Property, which is actually an IO action.
16:49:56 <rasfar> i could swear people were using quickCheck a few hours earlier here
16:50:05 <rasfar> @type check
16:50:06 <lambdabot> Not in scope: `check'
16:50:11 <Enigmagic> @check x == y
16:50:12 <lambdabot>   "Falsifiable, after 0 tests:\n"
16:50:29 <Enigmagic> @check x > 2
16:50:30 <lambdabot>   "OK, passed 500 tests."
16:50:36 <monochrom> @check (==)
16:50:37 <lambdabot>   "OK, passed 500 tests."
16:50:38 <rasfar> @check (\ n -> succ (pred n) == (n :: Integer))
16:50:39 <lambdabot>   "OK, passed 500 tests."
16:50:48 <monochrom> "all animals are equal"
16:51:00 <rasfar> okay, that's pretty easy.  thank you liyang and Enigmatic!
16:51:15 <liyang> What does @check actually do? O_o
16:51:27 <monochrom> I think it runs quickcheck
16:52:12 <liyang> How could @check (==) pass 500 tests?
16:52:16 <pqmodn> () == ()
16:52:29 <liyang> Ah. Of course.
16:52:48 <rasfar> -- | Test a property with QuickCheck
16:52:48 <rasfar> module Plugin.Check where
16:53:42 <liyang> @check \ n -> pred (succ n) == (n :: Int8)
16:53:43 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary GHC.Int.Int8)
16:53:44 <lambdabot>    arising from a ...
16:53:47 <liyang> @check \ n -> pred (succ n) == (n :: Int)
16:53:48 <lambdabot>   "OK, passed 500 tests."
16:54:17 <rasfar> so i may find myself writing my own Arbitrary instances...
16:54:24 <pqmodn> yep
16:54:35 * rasfar can live with that
16:54:43 <pqmodn> rasfar: good place to start is looking at the source for Arbitrary on hackage
16:54:53 <rasfar> thx
16:57:09 <pqmodn> rasfar: another tip when making your own instances of Arbitrary is you can do things like this, data NonZero = NonZero Int; myProp (NonZero x) (NonZero y) = x + y > 0, rather than myProp x y = x /= 0 && y /= 0 ==> x + y > 0
16:57:10 <monochrom> "all animals are equal. some animals are more equal"
16:57:38 <pqmodn> rasfar: that way you avoid generating data that will just be thrown out by the guard
17:06:15 <rasfar> pqmodn: thanks very much (i was afk)
17:07:44 <liyang> There's a newtype Positive (and some other constrained Arbitrary instances) in QuickCheck.
17:14:17 <rasfar> strange there isn't better documentation/tutorials; a really thorough document would probably be greatly appreciated.  would make a good GSoC project or something!
17:14:52 <hnsz> GSoD
17:15:39 <hnsz> Doesn't sound as exciting :p
17:16:31 <liyang> rasfar: what documentation did you come across?
17:18:12 <rasfar> aside from the API (which has all the lovely qualities of typical Haskell Haddock docs), there is the original QC manual http://www.cse.chalmers.se/~rjmh/QuickCheck/manual_body.html
17:18:32 <rasfar> and also http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
17:19:07 <rasfar> (which is also for version 1 i think)
17:20:00 <rasfar> aside from that, looking at the test suites for some of my installed packages
17:20:46 <rasfar> there's plenty to go on, but i'm experiencing a strange inertia designing my own tests, so thought i'd get some advice here
17:20:48 <liyang> CoArbitrary is a separate class in version 2, but almost everything else still applies AFAICR.
17:22:06 <rasfar> okay (yeah, i read that on a stackoverflow topic; there were i think 3 changes mentioned there) -- good to know the old docs will still apply in the main
17:22:54 <rasfar> GSo...Doom!!!
17:25:57 <bxc> argh cabal vs profiling
17:28:22 <rasfar> hnsz: also how exciting that sounds would depend on your, er, persuasion :p  (groan, some jokes are better left ontold, but couldn't resist)
17:28:30 <bxc> anyone have an idea of how much it woudl take to fix up cabal vs profiling dependency resoution?
17:41:17 <kfish> flip fmap
17:43:44 <elliott> kfish: No instance for Show ...
17:47:46 <Clint> Axman6: you're missing backticks in the definition of many at http://random.axman6.com/blog/?p=124
17:54:15 <scooty-puff-sr> for some reason it looks like DataKinds and TypeOperators are not required when using a list data constructor as a kind argument to a type constructor when only defining a  type sig
17:54:28 <scooty-puff-sr> should type operators even be required then?
18:03:57 <dcoutts_> bxc: yes, it's more work than you'd imagine
18:04:18 <dcoutts_> bxc: we have to record the vanilla and profiling versions separately
18:07:55 <rasfar> if Eq is implied by Ord, why must one derive instances for both?
18:09:09 <kallisti> rasfar: because you may not be deriving Eq, yet deriving Ord.
18:09:35 <kallisti> also it helps to document that the Eq instance exists.
18:09:49 <rasfar> okay, so Ord doesn't /depend/ on Eq, the classes just "happen" to be structured as if hierarchically?
18:10:04 <dgpratt> for reasons I don't fully understand, my local .NET UG has decided to undertake a group project where we will implement a "Farkle" game engine...
18:10:23 <kallisti> sure, the deriving mechanism could just automatically derive Eq if you derive Ord and there is no Eq instance, but maybe that's not what you wanted. Maybe you just forgot to import the Eq instance, and now you end up with an Eq instance you didn't want, and no error indicating that there is a problem.
18:11:01 <rasfar> alright ... one more question but harder to formulate.  maybe i can use an hpaste
18:11:28 <kallisti> basically, everything just works nicer if you explicit derive exactly what typeclass you want, and the deriving mechanism doesn't attempt to do a lot of stuff automatically that could possible be not what you intended.
18:11:58 <kallisti> (help what are adverbs)
18:11:59 <dgpratt> ...and being the local Haskell evangelist, I thought it'd be interesting to come up with a Haskell version of the same
18:13:07 <kallisti> I would use StateT GameState IO a
18:13:11 <dgpratt> but it will push the limits of what I know how to model in Haskell
18:13:19 <kallisti> or possibly StateT GameState Rand
18:13:29 <kallisti> you probably want IO though.
18:13:50 <hpaste> rasfar pasted “no instance” at http://hpaste.org/66146
18:13:59 <dgpratt> kallisti: interesting
18:14:17 <kallisti> rasfar: what's the problem?
18:14:29 <rasfar> since Int is an instance of Integral I thought all those derived instances would suffice
18:14:34 <kallisti> no.
18:14:37 <rasfar> what is the problem!?
18:14:37 <kallisti> it doesn't work like that.
18:14:42 <kallisti> you need an instance declaration.
18:15:02 <rasfar> okay.  so that sort of sucks for polymorphism it seems to me
18:15:04 <dgpratt> I thought that there'd def. be a Monad or two in the final design, but I decided to first try to model it directly
18:15:09 <kallisti> rasfar: how?
18:15:11 <hpaste> dpratt71 pasted “farkle” at http://hpaste.org/66147
18:15:21 <kallisti> why should being a superclass of Integral mean that all integrals are NodeIndexes suddenly?
18:15:23 <rasfar> i'll need to write an instance declaration for each numeric type
18:15:48 <kallisti> what purpose does NodeIndex serve.
18:15:49 <rasfar> but i derived everything that could possibly be wanted surely
18:15:50 <kallisti> do you need it?
18:16:08 <rasfar> oh probably not; i'm just trying to get a grip on classes and instances at the moment :)
18:16:24 <kallisti> well, that's why it seems repulsive to have to make instances for every numeric type.
18:16:53 <rasfar> (but i also have node and arc labels which i do need to make polymorphic)
18:17:16 <kallisti> are you sure?
18:17:31 <rasfar> they need to be able to be, at minimum, either Float or Complex
18:17:57 <rasfar> which is working without classes; now i'm trying to refactor using classes to avoid long lists of constraints on each function definition's type decl
18:17:58 <kallisti> data NodeLabel = FLabel Float | CLabel Complex
18:18:05 <kallisti> like this?
18:18:25 <kallisti> you need existentials to do that.
18:18:27 <kallisti> not just typeclasses.
18:18:46 <rasfar> as the code currently stands, i don't need to pattern match on constructors; it "just works" polymorphically when I feed it an appropriately typed initiallisation value
18:19:09 <kallisti> why not just use an existing typeclass?
18:19:10 <kallisti> such as Floating?
18:19:34 <rasfar> oh yeah? Complex is an instance of Floating?  that might work...
18:19:39 <kallisti> to my knowledge
18:19:45 <kallisti> > 2.5 :: Complex Double
18:19:46 <lambdabot>   2.5 :+ 0.0
18:19:50 <kallisti> yep
18:20:08 <rasfar> that will probably do it; thanks!
18:20:18 <kallisti> rasfar: if you need to make a collection of node labels of different types, then you'll probably want something like an ADT or existential.
18:20:30 <kallisti> but if you're only dealing with one at a time that should be sufficient.
18:20:53 <rasfar> presently the node weights are homogeneous per graph instance
18:20:57 <kallisti> okay.
18:21:32 <kallisti> are you familiar with existentials?
18:21:44 <rasfar> still a bit perplexed about classes/instances but after a bit more practise no doubt i'll see the value in the way things are arranged
18:21:59 <kallisti> rasfar: what perplexes you?
18:22:13 <rasfar> i'm not, no -- is that where i use "forall" when I really mean "exists" ? :p
18:22:25 <kallisti> no, you really mean forall.
18:22:32 <rasfar> heh
18:23:08 <rasfar> maybe i'm not perplexed, just still a bit overloaded (<-pun)
18:23:30 <kallisti> data JSArg = forall a. ToJSON a => JSArg a
18:23:37 <kallisti> here's a snippet of code from one of my current projects.
18:23:46 <rasfar> (thanks kallisti)
18:23:50 <liyang> forall is \ for types.
18:24:06 <rasfar> that's a perspective i wasn't expecting, thanks liyang
18:24:46 <kallisti> basically I have a function called executeJS that takes some javascript and a list of arguments to the JS.
18:25:12 <rasfar> (something i'd like to be doing myself fairly soon, so especially nice example)
18:25:53 <kallisti> obviously I can't just say  executeJS :: (FromJSON a, FromJSON b) => [a] -> Text -> WD b
18:26:19 <kallisti> because lists are homogenous. I can't specify a string argument, followed by an integer argument, followed by a double, etc.
18:26:29 <kallisti> I can only pick one type to use.
18:26:37 <rasfar> yes
18:27:02 <kallisti> but with the existential I have.  executeJS :: fromJSON b => [JSArg] -> Text -> WD b
18:27:28 <parcs`> liyang: what is \ ?
18:27:34 <rasfar> (lambda)
18:27:34 <kallisti> lambda I believe
18:27:37 <parcs`> o
18:27:39 <kallisti> executeJS [JSArg "hello", JSArg 2.5, JSArg [1,2,3]] "..."
18:27:40 <copumpkin> omg it's liyang
18:27:48 <liyang> harro copumpkin
18:27:51 <copumpkin> HARRO
18:28:04 <rasfar> and here i was taking him for granted :/
18:28:45 <rasfar> kallisti, i am definitely a person that's slow on the uptake, i'll need to think about what you've shown me, but i thank you for it now.
18:28:45 <liyang> I'm a bit irregular.
18:29:24 <kallisti> > [toDyn 3, toDyn 3.4, toDyn "hello!"]
18:29:25 <lambdabot>   [<<Integer>>,<<Double>>,<<[Char]>>]
18:29:32 <kallisti> another example of some existential typing goodness.
18:29:43 <parcs`> @src Dynmaic
18:29:43 <lambdabot> Source not found. Maybe you made a typo?
18:29:48 <parcs`> @src Dynamic
18:29:49 <lambdabot> Source not found. My brain just exploded
18:29:56 <kallisti> parcs`: maybe if you try a third time. :P
18:30:00 <rasfar> i suppose that uses generics internally?
18:30:00 <liyang> It's in base:Data.Dynamic
18:30:14 <mk> could someone recommend a terse but complete explanation of the type system?
18:30:16 <liyang> No, it uses Typeable and unsafeCoerce internally.
18:30:19 <kallisti> to my knowledge, it's an existential wrapper over Typeable.
18:30:46 <rasfar> ok
18:30:46 <parcs`> data Dynamic = Data.Dynamic.Dynamic TypeRep Data.Dynamic.Obj
18:32:02 <liyang> A TypeRep is just a 128-bit MD5 hash of the (package,module,typename).
18:32:02 <rasfar> mk: do you know about the "Haskell Report"?  that's terse and complete, but doesn't cover a lot of extensions in common use.
18:32:34 <rasfar> (although coming from me after the above discussion, you might not be very convinced :D
18:32:35 <liyang> When you call fromDynamic, it checks the TypeReps are equal, then defers to unsafeCoerce.
18:32:40 <monochrom> the Haskell Report does not explain the type system either
18:32:57 <rasfar> no?  it talks about kinds and stuff...
18:33:14 <liyang> All the extensions are (at least briefly) documented in the GHC docs.
18:33:25 <rasfar> you mean H-M type inference i guess
18:33:29 <mk> rasfar: I didn't, thanks - I was looking for something spec-like in any case
18:33:53 <rasfar> it would be a good starting point at least; i read it thoroughly in 2003 but i've forgotten a lot
18:33:57 <monochrom> yes, whatever is already in HM, the Haskell Report doesn't bother to repeat
18:34:58 <mk> I'm reading through some of these online books and they put so much easy filler between the concepts that it's a bit hard to see the whole picture
18:35:03 <wo0kie> any way to generate a tuple of n size based off an integer value?
18:35:05 <kallisti> rasfar: by the way it's not very common that you need to add a class constraint to a data type declaration
18:35:08 <kallisti> as you did with NodeIndex
18:35:14 <kallisti> typically you would add the constraint to individual functions.
18:35:15 <wo0kie> for example generateTuple 3 = (x,x,x)
18:35:26 <monochrom> almost no way
18:36:13 <kallisti> wo0kie: each tuple size has a unique type constructor.
18:36:22 <wo0kie> hmm :(
18:36:29 <kallisti> which needs to be known at compile-time
18:36:31 <rasfar> kallisti, oh yeah?  as long as i can avoid the extremely verbose multiple "atomic" constraints i'm currently listing at all my defs, i'll be happy
18:36:37 <parcs`> wo0kie: you can't base it off of a value, but you can base it off of a type
18:36:48 <wo0kie> I see
18:36:49 <Ralith> monochrom: almost?
18:36:56 <kallisti> rasfar: well it's bad style to needlessly constraint datatypes to particular typeclasses.
18:37:25 <monochrom> wouldn't want to completely rule out the thin possibility that some perverts use TH and type class hacks to get close
18:37:38 <Ralith> TH is static...
18:37:39 <rasfar> yeah i can understand that; and after all, my "problems" are stemming from a desire to maintain generality, so i'd be at cross purposes if i did that
18:37:52 <monochrom> add a couple of unsafeCoerce to make it less static
18:38:02 <parcs`> with type classes you can be able to do something like 'generate (undefined :: Four) :: a -> b -> c -> (a, b, c)
18:38:38 <parcs`> or rather Three. anyway, you don't really want to do that
18:38:49 <rasfar> i think there's even a hard limit on tuple size (per compiler) is there not?
18:38:59 <kallisti> correct.
18:38:59 <Ralith> wo0kie: if you need values with variable size, use containers with variable size.
18:39:04 <kallisti> in GHC it's rather enormous.
18:39:18 <rasfar> that must look like hell in the GHC source :)
18:39:20 <wo0kie> I'm trying to add up all pairs of a given list
18:39:27 <wo0kie> and having a hard time doing it
18:39:35 <wo0kie> I thought I could use list comprehension
18:39:40 <wo0kie> but I can't figure out how to structure it
18:39:58 <kallisti> use list comprehensions to generate tuples? no. that's not going to work.
18:40:19 <wo0kie> if I want to generate a list of tuples of size 2
18:40:22 <wo0kie> that should work
18:40:25 <kallisti> sure
18:40:31 <kallisti> > repeat (2,2)
18:40:31 <lambdabot>   [(2,2),(2,2),(2,2),(2,2),(2,2),(2,2),(2,2),(2,2),(2,2),(2,2),(2,2),(2,2),(2...
18:40:36 <kallisti> like this for example.
18:40:40 <wo0kie> yeah
18:41:03 <wo0kie> but say I have a list of [1,2,3,4,5]
18:41:15 <wo0kie> how would I get all combinations of two elements that add up to 6?
18:41:21 <rasfar> > [ (x,y) | x <- [1..3], y <- [4..4] ]
18:41:21 <wo0kie> (as an example)
18:41:22 <lambdabot>   [(1,4),(2,4),(3,4)]
18:41:28 <rasfar> > [ (x,y) | x <- [1..3], y <- [4..5] ]
18:41:29 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
18:41:53 <parcs`> > [ (x, y) | x <- [1..5], y <- [x..5], x + y == 6 ]
18:41:54 <lambdabot>   [(1,5),(2,4),(3,3)]
18:42:01 <wo0kie> that makes more sense lol
18:42:08 <rasfar> > let lst=[1..3] in [ (x,y) | x <- lst, y <- lst ]
18:42:09 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
18:42:47 <kallisti> > let f = filter ((==6) . uncurry (+)) . join (liftM2 (,)) in f [1..5]
18:42:49 <lambdabot>   [(1,5),(2,4),(3,3),(4,2),(5,1)]
18:42:49 <wo0kie> now let's say instead of integers, I have arbitrary data types
18:43:12 <kallisti> my method is obviously the best.
18:43:21 <kallisti> it's the clearest and shortest, and requires the fewest dependencies.
18:43:26 <wo0kie> about to give up on this hw lol
18:43:27 <rasfar> kallisti you're one of those bots mentioned in typeclassopedia aren't you?
18:43:33 <kallisti> yes.
18:43:36 <wo0kie> cribbage is a terrible game to implement in haskell
18:44:14 <monochrom> "add up to 6" and "arbitrary data types" are oxymorons
18:44:33 <wo0kie> I'm a newbie to haskell
18:44:49 <wo0kie> hence, I have no idea what I'm talking about and am going to willingly fail this assignment
18:44:51 <wo0kie> lol
18:44:56 <monochrom> (how do I add URLs and how do I know whether a URL is below 6?)
18:45:01 <kallisti> wo0kie: what are you trying to add up specifically
18:45:14 <wo0kie> kallisti, h/o I'll pastebin
18:45:18 <parcs`> wo0kie: why don't you pay attention in class ;)
18:45:22 <rasfar> woOkie, the complicated one above was more of a joke than a suggestion; but parcs` was very applicable for you!
18:45:26 <wo0kie> I do pay attention
18:45:37 <wo0kie> my professor hasn't covered any of this in depth
18:45:40 <wo0kie> so it's a mystery to me
18:45:41 <monochrom> I don't accept "new to haskell" as an excuse. sure, new to haskell, that's fine. new to asking questions too? I don't think so.
18:45:43 <parcs`> why does your professor suck
18:46:13 <monochrom> for starters, it takes 0 effort to copy the given homework question verbatim
18:46:16 <wo0kie> monochrom: thanks bro, I'll admit I'm a dumbass
18:46:18 <wo0kie> no worries
18:46:25 <hpaste> lifestream pasted “isEven more simple” at http://hpaste.org/66149
18:46:26 <lifestream> Is my assumption correct in the paste above? And in that case, would the type of isEven' be  Integer -> Bool as well?
18:46:32 <acowley> Some days I really hate Num
18:46:40 <wo0kie> http://www.cs.rit.edu/~mtf/teaching/20113/psfp/homeworks/homework02/homework02.html
18:46:45 <wo0kie> question #2 under Cards
18:47:09 <kallisti> :t mod
18:47:10 <lambdabot> forall a. (Integral a) => a -> a -> a
18:47:13 <wo0kie> (near the bottom)
18:47:17 <kallisti> lifestream: it would work on any Integral type
18:47:28 <kallisti> with Eq
18:47:47 <kallisti> (
18:47:49 <kallisti> e
18:47:50 <kallisti> ..
18:47:52 <kallisti> er
18:48:02 <kallisti> (Integral a, Eq a) => a -> Bool
18:48:38 <lifestream> kallisti: basically I'm wondering if isEven' can be a function just with that expression, since if it's not true it's false; so there is no need for that Otherwise at all, right?
18:48:50 <kallisti> wo0kie: but to answer  your question: yes, it can be that type, but it's actually more general than that.
18:48:57 <kallisti> and yes that works.
18:49:01 <acowley> Does anyone know of a good typeclass for hyperreal numbers?
18:49:24 <wo0kie> thanks kallisti
18:49:32 <wo0kie> at this point my attempts are futile lol
18:49:49 <wo0kie> but I appreciate the help very much :)
18:50:40 <kallisti> wo0kie: so you're not adding up arbitrary types.
18:50:44 <kallisti> you're adding up Cards, yes?
18:50:56 <wo0kie> yeah
18:50:59 <kallisti> a Card should have a one-to-one correspondence to some integers, yes?
18:51:06 <wo0kie> yeah
18:51:11 <kallisti> well... there you go.
18:52:46 <kallisti> just write a function that converts Cards to Integers
18:52:47 <mm_freak> where and how do you store the run-time configuration of a program?  the autogen module Paths_PACKAGE doesn't seem to contain anything suitable
18:53:05 <wo0kie> I have one already :)
18:53:11 <kallisti> wo0kie: so what's the problem?
18:53:15 <wo0kie> once they're integers though, how do I mimic this functionality?
18:53:16 <wo0kie> [ (x, y) | x <- [1..5], y <- [x..5], x + y == 6 ]
18:53:30 <wo0kie> the y <- [x..5] is what's bothering me
18:53:37 <dcoutts_> mm_freak: System.Directory.getAppUserDataDirectory
18:53:47 <kallisti> wo0kie: oh because of the tuples
18:53:59 <mm_freak> dcoutts_: that sounds reasonable, thanks
18:54:18 <wo0kie> that, and I'm not sure I can use .. with Card
18:54:19 <wo0kie> :S
18:54:22 <monochrom> I am not convinced that you need the analogue of [1..5] for cards
18:54:23 <dcoutts_> mm_freak: basically it's ~/.blah/  or equiv on windows
18:54:29 <kallisti> wo0kie: you can if you derive Enum for it
18:54:33 <kallisti> but otherwise, no.
18:54:44 <kallisti> you could just write it out explicitly though. but I don't think you need to use lists here.
18:54:50 <wo0kie> :o
18:55:06 <monochrom> but it will take me forever to read the Cribbage rules to figure out what you really need
18:55:27 <wo0kie> took me forever too
18:55:41 <monochrom> meanwhile enjoy all the information-overload answers due to the XY Problem
18:55:42 <wo0kie> we're only supposed to "score" a hand
18:55:46 <wo0kie> not actually play the game
18:55:47 <kallisti> wo0kie: well you have a conditional for whether or not the cut is a Jack
18:55:51 <kallisti> that should be step one I think.
18:56:02 <wo0kie> the nob right?
18:56:19 <kallisti> basically if the cut is a Jack, and you're the dealer, you get 2 extra pints.
18:56:19 <rasfar> mm_freak: possibly http://hackage.haskell.org/package/configurator (there's also http://hackage.haskell.org/package/Configger) may be relevant, dunno
18:56:20 <kallisti> right?
18:56:40 <kallisti> oh wait nevermind.
18:56:43 <wo0kie> "one point for holding the Jack of the same suit as the starter card"
18:56:46 * kallisti doesn't actually know the rules of this game.
18:57:03 <wo0kie> kallisti: http://en.wikipedia.org/wiki/Cribbage_%28rules%29#The_show
18:57:08 <wo0kie> those are the rules we need to follow :P
18:57:09 <kallisti> I'm reading right now.
18:57:27 <kallisti> I mean you'll probably just need to go through and hardcode all of this logic. that's the quickest way, if you're a Haskell newbie.
18:57:28 <mm_freak> rasfar: that would be overkill, because it's really just a database
18:57:41 <mm_freak> all the run-time configuration is stored there
18:57:58 <kallisti> wo0kie: you could probably set it up so that each scoring rule results in a number, the result is the addition of all of those numbers.
18:58:22 <wo0kie> yeah I'm trying to define a function for fifteen-twos,runs,pairs, flushes and nobs
18:58:25 <rasfar> (alright) -- i don't even know what you mean by run-time configuration.  like +RTS stuff?  never mind me though, good luck!
18:58:32 <kallisti> wo0kie: if the rule has no effect on your score in the current state, you just return 0
18:58:37 <wo0kie> yeah
18:58:51 <kallisti> I assume you know about where and such?
18:59:01 <wo0kie> yeah
18:59:45 <liyang> > [1..5] >>= \ x -> [1..5] >>= \ y -> if x + y == 6 then [(x,y)] else []
18:59:46 <lambdabot>   [(1,5),(2,4),(3,3),(4,2),(5,1)]
19:00:08 <mm_freak> rasfar: no, just run-time configuration (as opposed to compile-time configuration)
19:00:35 <liyang> > do x <- [1..5]; y <- [1..5]; if x + y == 6 then [(x,y)] else []
19:00:36 <lambdabot>   [(1,5),(2,4),(3,3),(4,2),(5,1)]
19:00:38 <mm_freak> whatever you would normally store in .conf files
19:00:51 <kallisti> wo0kie: okay so for that rule you would just place all of the tuple elements in a list
19:01:01 <kallisti> then check each combination of 2
19:01:15 <wo0kie> which, the pair rule?
19:01:24 <kallisti> fifteen-twos
19:01:43 <wo0kie> two or /more/ cards though :o
19:01:47 <kallisti> ah
19:02:13 <kallisti> > permutations [1,2,3,4]
19:02:13 <wo0kie> not sure how I would get the combination of all 5 cards in pairs of 2s,3s, etc
19:02:14 <lambdabot>   [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4...
19:02:19 <wo0kie> :o
19:02:21 <kallisti> > nub . permutations $ [1,2,3,4]
19:02:22 <lambdabot>   [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4...
19:02:29 <kallisti> hm, no.
19:02:30 <kallisti> wrong thing.
19:02:50 <kallisti> ...well, here's what I would do....
19:03:05 <kallisti> > (`replicateM` [1,2,3,4]) =<< [2..4]
19:03:06 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4...
19:03:21 <kallisti> you'd need to remove duplicates though.
19:03:53 <kallisti> hm
19:04:04 <wo0kie> I knew I should have dropped this class haha
19:04:12 <wo0kie> got every question right but this last one
19:04:15 <wo0kie> and it's 20/70 D:
19:04:19 <rasfar> (nm_freak: ah okay) -- and, i'm offline, bye all
19:04:27 <wo0kie> bye :)
19:04:35 <kallisti> wo0kie: I can't help someone who gives up. sorry.
19:04:53 <rasfar> (thanks wo0kie) -- and don't give up, it's hard but you'll get there !!!
19:04:59 <wo0kie> I haven't given up yet :\
19:05:32 <wo0kie> I understand though kallisti
19:05:35 <wo0kie> and appreciate the help
19:06:05 * hackagebot gc-monitoring-wai 0.1.2 - a wai application to show GHC.GCStats  http://hackage.haskell.org/package/gc-monitoring-wai-0.1.2 (YiHuang)
19:08:19 <Apocalisp> edwardk: Why does category-extras require Representable g (f ()) in order to Adjunction f g?
19:08:52 <wo0kie> anywho
19:08:58 <wo0kie> off to go drown myself in the bathtub
19:09:04 <wo0kie> catch you guys on the other side
19:13:40 <kallisti> who was the person asking about farkle?
19:13:47 <kallisti> (so many dice games)
19:15:37 <kallisti> wo0kie: the most straightforward method would be to simply to check the case of 2 dice, then 3 dice, then 4 dice.
19:15:48 <wo0kie> ?
19:15:51 <wo0kie> I'm not doing dice
19:15:56 <kallisti> er
19:15:58 <kallisti> cards
19:15:59 <kallisti> right
19:16:04 * kallisti o_O
19:16:23 <wo0kie> lol :P
19:16:53 <kallisti> so say you have some arbitrary list ls of cards
19:17:25 <kallisti> > let ls = [1,2,3,4] in [(x,y) | x <- ls; y <- ls]
19:17:26 <lambdabot>   <no location info>: parse error on input `;'
19:17:33 <kallisti> > let ls = [1,2,3,4] in [(x,y) | x <- ls, y <- ls]
19:17:34 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4...
19:17:40 <kallisti> this would work, except that there are duplicate pairs.
19:17:46 <wo0kie> true
19:17:53 <kallisti> you want the y<-[x..5]  thing, which you were confused about earlier.
19:18:12 <wo0kie> yeah since that removes duplicates
19:18:27 <kallisti> basically you want to drop everything before and including the current "x"
19:18:36 <wo0kie> yup
19:18:37 <kallisti> one way to do that is to associate each x with an index value i
19:18:48 <kallisti> and so now you can take the index, and chop off part of the list.
19:18:57 <wo0kie> by doing a take?
19:19:01 <kallisti> drop specifically
19:19:06 <wo0kie> oh ok
19:19:17 <kallisti> > zip [1..4] ['a', 'b', 'c', 'd']
19:19:17 <wo0kie> how do I associate an index with x?
19:19:18 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
19:19:32 <wo0kie> o0o0o0o
19:19:33 <kallisti> you can actually just use [1..]  in the general case, but here we know that your list length is always 4.
19:20:13 <kallisti> > zip [1..] ['a', 'b', 'c', 'd']
19:20:14 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
19:20:16 <kallisti> works equally well.
19:20:46 <kallisti> and then of course we want the condition that the card values add up to 15
19:21:04 <donri> > zip [1..] "abcd"
19:21:05 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
19:21:52 <kallisti> wo0kie: you may want to have the "generate all unique pairs" as a seperate function.
19:22:12 <kallisti> you could have "generate all unique triples" and "generate all unique quadruples" as well, using the same methods.
19:22:46 <kallisti> sum [2 | (x,y) <- uniqPairs cardList, x + y == 15]
19:22:48 <kallisti> see?
19:23:00 <kallisti> well, you'd want to convert the cards to their values.
19:23:06 <wo0kie> yeah
19:23:17 <wo0kie> 2 before the pipe yields 2 points essentially right?
19:23:23 <wo0kie> is that what that's referring to?
19:23:28 <kallisti> yes
19:23:32 <wo0kie> o0oo0
19:24:03 <kallisti> > [2 | x <- [1,3,5,3,6,1,4], even x]
19:24:04 <lambdabot>   [2,2]
19:24:11 <kallisti> produces a 2 for every even x in that list.
19:25:40 <kallisti> wo0kie: what you need to code will look very similar to all of that. I leave it up to you to figure it out. I'll be glad at answer a few questions along the way, but right now I'm gonna be afk.
19:25:52 <wo0kie> no problem
19:25:55 <wo0kie> thanks for your help
19:25:59 <wo0kie> I'll see what I can do :)
19:28:48 <Apocalisp> allpairs = liftM2 (=<<) zip (tail . tails)
19:29:21 <Apocalisp> > let allpairs = liftM2 (=<<) zip (tail . tails) in allpairs [1,2,3,4]
19:29:22 <lambdabot>   [(1,2),(2,3),(3,4),(1,3),(2,4),(1,4)]
19:30:48 <kallisti> > let ls = [1,2,3,4] in zip ls =<< (tail . tails $ ls)
19:30:50 <lambdabot>   [(1,2),(2,3),(3,4),(1,3),(2,4),(1,4)]
19:30:56 <kallisti> for those who still prefer to have a little sanity left.
19:32:07 <Apocalisp> > let allpairs = (=<<) <$> zip <*> (tail . tails) in allpairs [1,2,3,4]
19:32:08 <lambdabot>   [(1,2),(2,3),(3,4),(1,3),(2,4),(1,4)]
19:32:42 <Apocalisp> For those who prefer no monads
19:33:24 <wo0kie> kallisti: http://pastebin.com/ezx2eNDj
19:33:28 <wo0kie> am I on the right track?
19:33:29 <mauke> The paste ezx2eNDj has been copied to http://hpaste.org/66150
19:33:51 <wo0kie> trying to print out all pairs that add up to 15
19:33:57 <wo0kie> just for checking
19:34:01 <kallisti> that should do it.
19:34:06 <kallisti> but you really want the unique ones.
19:34:17 <wo0kie> ah I see
19:34:21 <wo0kie> forgot that
19:34:41 <kallisti> rank is a number?
19:34:46 <wo0kie> yup
19:34:53 <acowley> The quote of me in the HWN this week is too subtle even for me. I think I was making a joke about free theorems and natural transformations. I am a huge nerd.
19:35:01 <wo0kie> rank is the number rank of the card
19:35:03 <wo0kie> ie, J = 11
19:35:11 <kallisti> wo0kie: you should focus instead on how to generate just the unique pairs of cards,  rather than the fifteen rule.
19:35:17 <kallisti> because that function will be useful for all of the other rules
19:35:34 <kallisti> you'll want one to generate triples, one for 4-tuples, and I think one for 5-tuples as well.
19:35:37 <kallisti> all using the same approach.
19:36:04 <wo0kie> hmm true
19:36:42 <kallisti> once you have those functions the rest will be pretty simple list comprehension stuff.
19:37:02 <kallisti> for three of a kind, for example, you just grab each unique triple and test if all 3 values are the same.
19:37:13 <wo0kie> yeah
19:37:23 <wo0kie> trying to determine how to remove duplicates now :)
19:38:35 <kallisti> wo0kie: the simplest way, without going into too much stuff you're probably not familiar with, is to associate each x with an integer starting at 1 and then use that integer to drop from the list of y's
19:39:07 <wo0kie> where would I apply the zip [1..] in my function though?
19:39:13 <wo0kie> in the where clause?
19:39:15 <kallisti> after the x <-
19:39:18 <kallisti> it would be
19:39:25 <kallisti> (i, x) <- zip [1..] rn
19:40:12 <wo0kie> cribbageCheckPairs cs = [(x,y) | (i, x) <- zip [1..] rn, y <- drop i rn]
19:40:18 <kallisti> yup
19:40:18 <wo0kie> I think that might have worked
19:40:26 <wo0kie> man, you're smart ;D
19:40:48 <kallisti> I like Apocalisp's solution better
19:41:15 <wo0kie> his doesn't make any sense lol XD
19:41:18 <wo0kie> to me at least
19:41:18 <kallisti> wo0kie: the 3-tuple, 4-tuple cases should all look similar I believe.
19:41:19 <wo0kie> lol
19:41:49 <kallisti> where you're associating each element with an integer to drop from the next list.
19:42:01 <kallisti> ...I think.
19:42:07 <kallisti> I may be forgetting something
19:42:39 <wo0kie> [(x,y,z) | (i, x) <- zip [1..] rn, (y, j) <- zip [1..] (drop i rn), z <- drop j rn, x + y + z== 15]?
19:42:47 <wo0kie> like this?
19:42:54 <kallisti> I /think/ so. please double check though
19:42:59 <wo0kie> will do
19:43:28 <parcs`> @hoogle perfomGC
19:43:28 <lambdabot> No results found
19:44:05 <kallisti> wo0kie: oh, and please remove the check for 15
19:44:10 <kallisti> because it's not needed here.
19:44:12 <kallisti> you can do that later.
19:44:19 <wo0kie> ok :)
19:44:55 <kallisti> wo0kie: you want to look over all of the rules and see what you need in the general case.
19:45:08 <kallisti> the most useful thing to you is the ability to generate unique 2-tuples, 3-tuples, 4-tuples, and so on.
19:45:19 <kallisti> the rest should come naturally.
19:45:33 <wo0kie> ok thank you :D
19:46:35 <kallisti> also I'm assuming the way the rules work is that the better runs cancel the possibility of other runs.
19:46:46 <kallisti> for for example i you have a run of four, that doesn't also count as 2 pairs.
19:47:05 <kallisti> oh wait
19:47:06 <kallisti> nevermind.
19:47:16 <kallisti> four of a kind doesn't count as 2 pairs, I mean.
19:47:22 <wo0kie> yeah
19:47:27 <wo0kie> it doesn't :)
19:48:52 <wo0kie> a full hand of 5H 6D 10H 5H 7C when printing all possible combos of 3 (duplicates removed) gives the first 3-tuple as (5,6,6)
19:48:56 <wo0kie> does that make sense? :S
19:49:12 <kallisti> yes
19:49:16 <kallisti> er
19:49:17 <kallisti> no
19:49:47 <wo0kie> ooooohhhh
19:49:58 <wo0kie> I forgot to do a double drop on the third part
19:50:00 <kallisti> I think it needs to be like drop (i+j) for the third card?
19:50:02 <wo0kie> z <- drop i (drop j rn)
19:50:04 <wo0kie> yeah :D
19:50:06 <kallisti> or that.
19:50:09 <kallisti> same thing.
19:50:18 <wo0kie> I like yours better :)
19:50:20 <kallisti> (except the first one is a bit faster probably)
19:50:43 <kallisti> I'm guessing you can see the pattern as the number of cards increases.
19:50:48 <wo0kie> yeah
19:50:52 <wo0kie> gets a bit more complicated
19:50:55 <wo0kie> but easily replicated
19:51:00 <kallisti> yup
19:51:24 <kallisti> also make sure you're not interested in suit ever when generating distinct combinations.
19:51:32 <kallisti> because your current function loses that information.
19:52:07 <kallisti> the only suit-based rule is flush, which doesn't look at combinations
19:52:09 <kallisti> so it should be fine.
19:52:12 <wo0kie> :)
19:52:28 <kallisti> I guess nobs is too.
19:52:32 <kallisti> but that one is trivial.
19:56:04 <kallisti> wo0kie: btw a trick for going form Card -> Integer
19:56:15 <kallisti> would be to add Enum to your list of derived typeclasses.
19:56:17 <kallisti> next to Eq
19:56:23 <kallisti> and then you get fromEnum and toEnum on Cards.
19:56:27 <wo0kie> don't think we're allowed to though :O
19:56:27 <kallisti> > fromEnum True
19:56:28 <lambdabot>   1
19:56:30 <kallisti> > fromEnum False
19:56:31 <lambdabot>   0
19:56:39 <kallisti> oh wait nevermind
19:56:48 <kallisti> you could only do that for the rank... which is already an integer. :P
19:56:54 <wo0kie> :)
19:57:17 <kallisti> > fromEnum 4
19:57:18 <lambdabot>   4
19:57:28 <mjrosenb> you should be able to do that for suit,
19:57:33 <kallisti> yes
19:58:38 <kallisti> cribbage is weird.
19:58:52 * kallisti is not really into card games.
19:59:47 <wo0kie> I only enjoy poker lol
19:59:58 <wo0kie> how would I detect a run?
20:00:24 <wo0kie> get all combos
20:00:25 <kallisti> sort the cards before passing them to the function
20:00:43 <wo0kie> by integer rank right?
20:00:47 <kallisti> yes.
20:01:04 <kallisti> > sortBy (comparing (\(MkCard _ rank) -> rank)) cardList
20:01:05 <lambdabot>   Not in scope: data constructor `MkCard'Not in scope: `cardList'
20:01:09 <kallisti> you probably want a getRank function
20:01:16 <kallisti> getRank (MkCard _ rank) = rank
20:01:23 <wo0kie> true
20:01:49 <kallisti> comparing is a wonderfully little thing
20:02:03 <kallisti> > sortBy (comparing abs) [1,2,3,-200,-2,-3,1,6,-16]
20:02:04 <lambdabot>   [1,1,2,-2,3,-3,6,-16,-200]
20:02:37 <kallisti> that basically applies abs before doing the comparison.
20:03:01 <Eridius> kallisti: I've never been able to figure out whether I should be using comparing or compare `on` (yes, I realize they both do the same thing)
20:03:13 <kallisti> why not use comparing?
20:03:24 <Eridius> why not use compare `on`?
20:03:36 <kallisti> uh, well, erm, uh.
20:04:27 <kallisti> I suppose they both require the same number of imports.
20:04:47 <kallisti> @hoogle comparing
20:04:47 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:04:50 <kallisti> yes
20:04:52 <kallisti> I typically default to comparing, but I could use compare `on` if I already have Data.Function and not Data.Ord
20:05:02 <Eridius> is `on` ever used for anything besides compare `on`?
20:05:09 <kallisti> yes
20:05:14 <kallisti> pointfree wizardry.
20:05:27 <kallisti> also the other *By functions
20:05:45 <Eridius> @hoogle on
20:05:45 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
20:05:46 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
20:05:46 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
20:06:04 <kallisti> (==) `on` is likely somewhat common
20:06:07 <Eridius> I don't think I've ever seen `on` used outside of compare `on`. That said, I pretty much just dabble, so there's quite a lot I never see
20:06:13 <Eridius> oh neat, hadn't thought of that one
20:06:30 <kallisti> I use on with some degree of frequency.. not much though
20:06:34 <Eridius> ...hrm, I'm pretty sure I could have actually used (==) `on` in one of my project euler solutions
20:10:03 <edwardk> Apocalisp: because every adjunction is representable
20:10:03 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:10:09 <edwardk> Apocalisp: (over hask)
20:10:15 <Apocalisp> yeah, that makes sense
20:10:21 <kallisti> $ find . -name '*.hs' -exec grep -H '`on`' {} \; | sprunge
20:10:22 <kallisti> http://sprunge.us/cMDG
20:10:27 <kallisti> Eridius: ^
20:10:29 <Apocalisp> Do you ever make use of the fact that it is representable?
20:10:46 <parcs`> Eridius: funny because compare `on` already has a synonym
20:10:49 <parcs`> :t comparing
20:10:50 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
20:10:55 <kallisti> parcs`: he kind of mentioned that.
20:11:14 <parcs`> lies!
20:11:26 <Eridius> parcs`: yes, that was the start of this :P
20:11:48 <kallisti> my PortalChess code is actually pretty neat. Though I think it's still broken.
20:12:10 <kallisti> I use "step generators" that generate movesets based on some arbitrary movement rule.
20:12:39 <kallisti> so to get a moveset you combine a step generator with a move rule. the most common step generator is just a linear step, but for knight-like movement you have to use one based on chebyshev distance.
20:13:27 <kallisti> and the movement rules can do fun stuff like, jump through portals. because this is portal chess after all.
20:13:51 <edwardk> Apocalisp: part of the point is showing off the fact that you can get a lot of properties for free. you can always go back and forth through the adjunction.
20:14:03 <edwardk> i've thought about stripping those requirements of of the class to some degree
20:14:11 <edwardk> and just making them available through a newtype wrapper
20:14:18 <edwardk> that would reduce the burden on implementors
20:14:22 <edwardk> but increase it on users
20:14:28 <edwardk> as the implementor i like that
20:14:33 <Apocalisp> heh
20:14:36 <edwardk> as a user i don't
20:14:37 <edwardk> ;)
20:19:11 <kallisti> I think with a bit of work I could turn my portal chess code into a general combinator library to write rules for chess variants.
20:25:30 <wo0kie> kallisti, I came very close to a solution for the cribbage game and want to thank you again for bearing with me and being so helpful :)
20:25:35 <wo0kie> it really is very much appreciated
20:26:38 <kallisti> wo0kie: are you going to finish it?
20:26:46 <wo0kie> have 30 minutes to do so
20:26:48 <wo0kie> going to try
20:26:52 <wo0kie> but it's unlikely :\
20:26:59 <kallisti> where are you at?
20:27:17 <wo0kie> sec
20:27:29 <wo0kie> http://pastebin.com/ZuzrtK8c
20:27:32 <wo0kie> this is what I have
20:27:32 <mauke> The paste ZuzrtK8c has been copied to http://hpaste.org/66152
20:27:34 <wo0kie> thus far
20:29:25 <kallisti> um, you could just use a list comprehenson for the pair checking functions.
20:29:46 <wo0kie> :o
20:30:44 <kallisti> wo0kie: okay so I /think/ if you sort the list of cards before passing it to the pair generators
20:31:01 <kallisti> then you'll get tuples such that the first element is smaller than the next element is smaller than the next element ...
20:31:07 <kallisti> if that's true
20:31:25 <kallisti> then you can just extract the elements from the tuple, and then check that x+1 == y, y+1 == z, ...
20:31:34 <wo0kie> hmm
20:31:55 <kallisti> that ONLY works if the tuple elements are ordered in such a way.
20:32:10 <kallisti> if not you may have to put the tuple elements into a list, sort that, then check that they're consecutive.
20:32:33 <wo0kie> hmm
20:33:02 <kallisti> you could try the second one since it's guaranteed to work.
20:33:29 <kallisti> so if you have a function isConsecutive
20:33:34 <kallisti> [Int] -> Bool
20:33:57 <kallisti> you could take each (x,y,z) for example
20:33:58 <kallisti> and do
20:34:04 <kallisti> isConsecutive (sort [x,y,z])
20:34:56 <wo0kie> hmmmmmm
20:35:25 <kallisti> what makes a sequence consecutive?
20:35:38 <kallisti> in general englishy terms.
20:35:43 <wo0kie> 1 + previous term
20:35:46 <kallisti> yep
20:35:59 <kallisti> so
20:36:06 <hpaste> enu pasted “problem” at http://hpaste.org/66153
20:36:09 <kallisti> let's say you have a list where x is the head of the list and xs is the tail
20:36:18 <kallisti> how do you take x and determine if xs is consecutive.
20:36:41 <enuyvatar> hey, can somebody help me out?
20:36:48 <enuyvatar> it's a 2-liner :)
20:37:00 <wo0kie> http://pastebin.com/0S8gyAUq
20:37:01 <wo0kie> ?
20:37:02 <mauke> The paste 0S8gyAUq has been copied to http://hpaste.org/66154
20:37:25 <wo0kie> wrote that really quick lol
20:37:36 <wo0kie> missing a base case I believe
20:37:43 <kallisti> wo0kie: yes that works, except it's missing the case where there's only 1 element.
20:37:46 <kallisti> yes
20:38:01 <kallisti> which is basically always true
20:38:02 <wo0kie> isConsecutive (c1:[]) = True?
20:38:06 <kallisti> yes
20:38:07 <kallisti> or just [c1]
20:38:10 <wo0kie> :D
20:38:17 <kallisti> or just [_] :P
20:38:31 <kallisti> right, so you just want to pass a sortest list of each n-tuple
20:38:36 <kallisti> *sorted
20:38:48 <kallisti> but there's a trick...
20:38:48 <wo0kie> so isConsecutive (sortBy (comparing (\(MkCard _ rank) -> rank)) cs))
20:39:00 <kallisti> if four of a kind results in a score, you don't want to check three of a kind
20:39:07 <wo0kie> true
20:39:08 <kallisti> if three of a kind results in a score, you don't want to check 2 of a kind.
20:39:20 <fizzbang> ls
20:39:22 <fizzbang> hahaaa
20:39:36 <kallisti> wo0kie: so just stop on the first one that's non-zero.
20:39:56 <kallisti> same thing with runs.
20:40:01 <fizzbang> okay, before i lose it, can somebody tip me off why my terrible hack of a haskell program does/doesn't compile? here's the paste http://pastebin.com/gyEbzwC8
20:40:03 <mauke> The paste gyEbzwC8 has been copied to http://hpaste.org/66155
20:40:05 <wo0kie> and pairs too?
20:40:15 <kallisti> pair is just 2 of a kind...
20:40:26 <kallisti> but the fifteen rule is independent of all of that, if that's what you mean.
20:40:31 <fizzbang> basically the first doesn't compile, but the second does and i don't understand the error message
20:40:32 <wo0kie> well I have to check pairs of 2 3 or 4
20:40:51 <kallisti> wo0kie: ..yes.
20:40:55 <wo0kie> 2 of a kind, 3 of a kind, 4 of a kind
20:40:57 <wo0kie> :P
20:41:04 <kallisti> except your terminology is wrong. "pair" means 2 of a kind
20:41:08 * hackagebot uuid 1.2.5 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.5 (AntoineLatter)
20:41:10 <kallisti> there is no "pair of 3" because that's not a pair. :P
20:41:13 <kallisti> but whatever
20:41:13 <wo0kie> yeah I just tried to fix it haha
20:41:55 <kallisti> wo0kie: so runs are a bit trickier. but the n of a kinds are pretty simple.
20:42:05 <kallisti> if you get 4 of a kind, 3 of a kind and 2 of a kind are impossible, so you just stop there.
20:42:11 <kallisti> 3 of a kind makes 2 of a kind impossible.
20:42:15 <wo0kie> if I get two, two of a kinds
20:42:16 <kallisti> ...er... well, no
20:42:21 <kallisti> you can get a "full house" I guess...
20:42:26 <wo0kie> how to tell if they're the same or different?
20:42:36 <wo0kie> I'd have to pass the card that's being paired to check it no?
20:42:52 <kallisti> possibly.
20:43:34 <kallisti> so with kinds you have basically a possibility of 2 pair and a full house
20:43:37 <kallisti> that you need to account for
20:43:44 <wo0kie> true
20:43:48 <kallisti> you can definitely say that if you get 4 of a kind then you're done.
20:44:16 <kallisti> if you get a three of a kind, then you want to check the values that /weren't/ part of the three of a kind, and see if they're a pair.
20:47:04 <kallisti> wo0kie: so like for three of a kind you want to, instead of multiplying the length of the list by 6
20:47:24 <kallisti> you actually want to extract the first element of the list, then filter those elements out of the card list, and check the remainder to see if it's a pair
20:47:33 <kallisti> ...does that make sense. :P
20:47:40 <wo0kie> I think so!
20:48:05 <wo0kie> 13 minutes
20:48:06 <kallisti> wo0kie: you can use case statements to make this simple.
20:48:10 <wo0kie> UGGHH
20:48:10 <wo0kie> lol
20:48:14 <wo0kie> true ;P
20:48:29 <kallisti> > case [1,2,3] of { [] -> 0; (x:xs) -> 5000 }
20:48:30 <lambdabot>   5000
20:49:14 <wo0kie> my professor offers 24 hour extensions on homework if emailed before the deadline
20:49:19 <wo0kie> given the deadline is 12 mins from now
20:49:24 <wo0kie> would you deem it wise to do so?
20:49:26 <kallisti> you should do that yes.
20:49:35 <kallisti> get to some kind of stopping point though
20:50:25 <wo0kie> is there a way to save an irc log of a current window in mirc?
20:50:32 <kallisti> no clue.
20:50:42 <kallisti> probably? :P
20:51:10 <wo0kie> well if I can't save this log, it won't help me to get an extension unless I bug you again tomorrow LOL
20:51:14 <wo0kie> taking notes though
20:51:49 <wo0kie> since this is only the second assignment of 8
20:52:06 <wo0kie> and we're only allowed 5 extensions (1 per assignment) and I haven't used any yet
20:52:14 <wo0kie> I might save my 5 for the more difficult assignments ahead
20:52:22 <wo0kie> and just bear the brunt of this one :\
20:52:41 <kallisti> just become awesome.
20:52:43 <kallisti> problem solved.
20:52:51 <wo0kie> dude inorite
20:53:10 <wo0kie> submitted my hw
20:53:12 <wo0kie> not entirely finished
20:53:24 <wo0kie> but good enough for a 60/70 I think
20:53:39 <wo0kie> (which could be worse)
20:53:49 <wo0kie> kallisti, thanks again for your help :)
20:53:58 <kallisti> not a problem.
20:54:13 <wo0kie> going to clear my head for a bit
20:54:16 <wo0kie> it's on overload
20:54:23 <wo0kie> ttyl and thanks again :)
20:54:38 <kallisti> no problem.
20:55:29 <zmoazeni> Hey folks, could someone point out where my STM mistake is with this snippet?
20:55:32 <hpaste> zmoazeni pasted “I gotta be doing something wrong” at http://hpaste.org/66156
20:56:35 <zmoazeni> It's not the wait, because I still get discrepancies even after bumping it up
20:58:22 <kallisti> zmoazeni: what exactly is the expected output?
20:58:48 <zmoazeni> I would expect TMVar 402. I was under the impression that the take and put would block the other threads with retries
20:59:46 <zmoazeni> I'm experimenting with IORef and TVar to see thread collisions. Based on what I've read, I assumed this code with TMVar would be threadsafe
21:00:23 <kallisti> well you're not waiting for every thread to finish.
21:00:30 <kallisti> so you're going to non-deterministic output
21:00:39 <kallisti> because you're just reading whenever you can.
21:00:43 <kallisti> in the main thread.
21:00:54 <zmoazeni> I'm waiting on line 36
21:01:06 <zmoazeni> Bumping the wait time to 60+ seconds produces the same output
21:01:41 <kallisti> you're only guaranteed to wake up after that time
21:01:44 <kallisti> not exactly at that time.
21:02:12 <kallisti> ahd 60 microseconds is not very much wait compared to 52 microseconds.
21:02:34 <zmoazeni> oh gah, I was thinking that was seconds. You're right, it's in micro
21:02:36 <kallisti> basically you're still at the whim of the scheduler.
21:03:05 <kallisti> http://hackage.haskell.org/packages/archive/threads/0.4.0.2/doc/html/Control-Concurrent-Thread-Group.html
21:03:13 <kallisti> this is probably something you might be interested in.
21:03:23 <kallisti> you can put all of the threads in a thread group, and then wait for the whole group to finish.
21:03:25 <zmoazeni> Still though, each thread waits between 10-50 microseconds. I still have problems if I wait 100 microseconds. I will try using seconds instead though
21:03:46 <zmoazeni> Yeah I should probably a thread join instead
21:04:24 <kallisti> wait :: ThreadGroup -> IO ()Source
21:04:25 <kallisti> Convenience function which blocks until all threads, that were added to the group have terminated.
21:04:54 <zmoazeni> I'll change it around to using the ThreadGroup and see if I have different results
21:05:01 <zmoazeni> Thanks for the suggestion
21:06:02 <edwardk> hrmm, trying to figure out a good way to genSym inside of the Q monad
21:06:28 <sm> evening all;
21:06:34 <edwardk> newName generates new names each time, but if they have the same 'base' name then i can still get Objective/C/Fun.hs:16:1:
21:06:35 <edwardk>     Multiple declarations of `makeFunDynamic'
21:06:35 <edwardk>     Declared at: Objective/C/Fun.hs:16:1
21:08:00 <sm> I use https://gist.github.com/2233207 for "cross-platform, cross-GHC-version en/decoding of file paths, command-line arguments etc."
21:08:12 <sm> what's a better name than PlatformString ?
21:09:10 <edwardk> anybody have any ideas?
21:15:14 <geekosaur> hm, that code is actually quite wrong.  it's often imagined that file paths are UTF8 on unix, but they are not and assuming so leads to cute stuff like various gtk versions dropping core when faced with perfectly acceptable filenames
21:15:46 <geekosaur> (and, somewhat more amusingly, likewise for OS X / Cocoa applications)
21:16:02 <kallisti> ByteString is a probably a good representation for paths.
21:19:33 <fizzbang> hello, could somebody help me understand the error message I get when compiling one of these files, but no the other: http://hpaste.org/66155
21:20:24 <edwardk> giving up and just giving it an extra string
21:21:19 <sm> geekosaur: thanks. I know, but did you read the linked page ? It convinced me
21:23:22 <geekosaur> sm, the linked page can say anything it feels like, I'm just telling you what the relevant POSIX standard says.  apps can pretend whatever they want about filename encodings as long as they recognize that it's pretense and they must be prepared to treat them as bytes with no interpretation.  most apps that want to pretend that POSIX path are UTF8 fail this in various ways
21:24:12 <geekosaur> including completely failing to open the right file if its name happens to use a non-normalized representation such as using a combining accent when a variant with the accent included exists
21:27:40 <Enigmagic> fizzbang: i think you want negate not (-)
21:27:45 <Enigmagic> :t negate
21:27:46 <lambdabot> forall a. (Num a) => a -> a
21:27:50 <Enigmagic> :t (-)
21:27:51 <lambdabot> forall a. (Num a) => a -> a -> a
21:29:00 <geekosaur> (in particular, you are unlikely get the case where both a file with an un-normalized UTF8 name and a file with the normalized version of that name exist correct.  the logic has to be *in the filesystem*, which requires new kernel APIs; you cannot reliably fix it in userspace)
21:33:04 <sm> geekosaur: I'm sure that's true, I'm just trying to work as often as I can on today's systems
21:33:07 <fizzbang> Enigmagic: i made an incorrect assumption about - i guess.. let me go hoogle that..
21:33:19 <geekosaur> ...and who cares when it doesn't
21:33:28 <sm> I was referring to http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html#utf8 if you care
21:33:49 * geekosaur still suspects security implications of the open-the-wrong-file version of it
21:35:12 <fizzbang> Enigmagic: no, i still get the same error upon compilation..
21:35:24 <fizzbang> Enigmagic: do you understand the error output by ghc?
21:37:26 <Enigmagic> fizzbang: oh are you just having problems with the version without the parens?
21:37:51 <fizzbang> Enigmagic: yeah, in the paste i show the other one compiling just fine
21:38:04 <Enigmagic> fizzbang: function application goes from left to right
21:38:13 <Enigmagic> so the first one is trying to sum the map function
21:39:13 <fizzbang> Enigmagic: then why don't i get an error in the parenthesized version about trying to negate the sum function?
21:40:08 <Enigmagic> fizzbang: the the parens change the order things are applied
21:41:42 <fizzbang> yes, so in "- sum (...)" the map gets applied earlier, but if application goes left to right then why don't i get an error about calling - on the sum function (not a number)
21:41:59 <fizzbang> Enigmagic: similar to the error about calling sum on the map function (not a list)
21:42:56 <Enigmagic> fizzbang: - is special i guess
21:43:36 <Enigmagic> "Prefix negation has the same precedence as the infix operator - defined in the Prelude (see Table 4.1). Because e1-e2 parses as an infix application of the binary operator -, one must write e1(-e2) for the alternative parsing. Similarly, (-) is syntax for (\ x y -> x-y), as with any infix operator, and does not denote (\ x -> xone must use negate for that."
21:45:57 <Enigmagic> fizzbang: http://hackage.haskell.org/trac/haskell-prime/wiki/NegativeSyntax
21:45:58 <Enigmagic> there ya go
21:47:28 <fizzbang> Enigmagic: okay, i just removed "-" from before "sum" and ghc spits out the same error.
21:47:41 <fizzbang> My question was more about how to interpret that error anyway..
21:50:48 <Enigmagic> fizzbang: it's just how the type inference engine works
21:51:00 <Enigmagic> you'll get better errors if you add type signatures
21:51:46 <hpaste> Enigmagic annotated “haskell question” with “haskell question (annotation)” at http://hpaste.org/66155#a66157
21:52:35 <Enigmagic> or plug in rational or whatever type you want
21:55:46 <fizzbang> Enigmagic: yeah i just did the same on my machine with 'Float' and i got the same errors as you
21:57:01 <Enigmagic> fizzbang: without the type signatures, ghc is trying to find some types that allow the code to compile
21:57:23 <Enigmagic> and that can lead to errors that aren't as useful
21:57:34 <fizzbang> Enigmagic: even with the type signatures I'm still unable to understand what the errors are ttalking about
21:57:59 <Enigmagic> No instance for (Num (t0 -> t1 -> Double)) arising from a use of `sum'
21:59:13 <Enigmagic> fizzbang: if you look at the error text, it will say the first argument of 'sum' has the type 't0 -> t1 -> Double' and there is no Num instance for it (sum needs the + operator which is defined on Num)
21:59:26 <Enigmagic> :t sum
21:59:27 <lambdabot> forall a. (Num a) => [a] -> a
22:00:45 <fizzbang> isn't the first argument of sum just map?
22:00:46 <fizzbang> :t map
22:00:47 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:01:07 <fizzbang> or does it associate right and just say it's [b]
22:01:32 <Enigmagic> the first (and only) argument for sum is a list
22:02:00 <fizzbang> then where does the 't0 -> t1 -> Double' type come from?
22:08:52 <vodik> fizzbang: sum $ map entropyPart dist
22:08:57 <vodik> does that work?
22:09:11 <fizzbang> vodik: maybe, i'm just trying to understand why the other thing *doesn't*
22:09:20 <vodik> because sum expects one argument
22:09:28 <vodik> and you're giving it 3
22:09:38 <vodik> you need sum (map entropyPart dist)
22:09:40 <fizzbang> the thing to the right of it is map, and that returns exactly one list, no?
22:09:41 <vodik> or sum $ ...
22:09:56 <vodik> fizzbang: but thats not how arguments are applied
22:10:30 <vodik> haskell things your giving calling (c style) sum (map, entroy, dist)
22:10:39 <vodik> not sum (map (entory, dist))
22:11:34 <vodik> :t sum map id
22:11:35 <lambdabot>     Couldn't match expected type `[a]'
22:11:35 <lambdabot>            against inferred type `(a1 -> b) -> [a1] -> [b]'
22:11:35 <lambdabot>     In the first argument of `sum', namely `map'
22:11:39 <vodik> :t sum $ map id
22:11:39 <lambdabot>     Couldn't match expected type `[a]'
22:11:40 <lambdabot>            against inferred type `[a1] -> [a1]'
22:11:40 <lambdabot>     In the second argument of `($)', namely `map id'
22:11:46 <vodik> right
22:11:52 <vodik> :t sum $ map id [1,2,3]
22:11:53 <lambdabot> forall a. (Num a) => a
22:11:59 <vodik> :t sum map id [1,2,3]
22:12:00 <lambdabot>     Couldn't match expected type `[a]'
22:12:00 <lambdabot>            against inferred type `(a1 -> b) -> [a1] -> [b]'
22:12:01 <lambdabot>     In the first argument of `sum', namely `map'
22:12:24 <vodik> fizzbang: guess these examples didn't work out well, but notice it only works when the $ is in there?
22:12:38 <vodik> > sum $ map id [1,2,3]
22:12:39 <lambdabot>   6
22:12:58 <fizzbang> yeah, because the $ says the stuff on the right is higher precedence than applying to the thing on the left
22:13:15 <fizzbang> or something?
22:13:24 <vodik> @src ($)
22:13:24 <lambdabot> f $ x = f x
22:13:40 <vodik> it applies arguments
22:13:58 <vodik> sum $ map ... is equivalent to sum (map ...)
22:14:03 <fizzbang> okay, so it means the stuff on the right has to be evaluated before it can be applied to the thing on the left?
22:14:18 <vodik> yeah
22:14:47 <vodik> not evaluated, since this is haskell and its lazy
22:14:54 <fizzbang> without it they are separate expressions passed to sum?
22:14:56 <vodik> but that the expression as a whole should be appied
22:15:01 <vodik> yes
22:15:19 <fizzbang> gah.. soo many tidbits to understand
22:15:39 <vodik> its actually very simple /once/ you've wrapper your head around it
22:15:42 <vodik> its just different
22:15:52 <vodik> the path there can be frustrating
22:16:54 <fizzbang> is there a ghci command like @src
22:17:02 <fizzbang> i'm not seeing it ..
22:17:22 <fizzbang> i'll check docs..
22:17:48 <fizzbang> anyhow, thanks to both of you vodik and Enigmagic ... i'm stumbling along with haskell so far..
22:18:05 <fizzbang> now things are a little better though .. :)
22:21:11 <misterbeebee_> oops, just fixed bug by changing Array.unsafeThaw to Array.thaw. Performance isn't notably slower either. /wrist-slap for premature optimization attempt.
22:22:31 <vodik> fizzbang: no, afaik its a feature of lambdabot
22:23:35 <fizzbang> vodik: that's ok.. hoogle is pretty clear on $ anyway
22:24:14 <vodik> fizzbang: ($) is useful for some other things too since its an actual operator
22:24:31 <vodik> > map ($ 2) [(+1), (+5), (*2)]
22:24:32 <lambdabot>   [3,7,4]
22:25:49 <vodik> > let f = ($ 2) in f (*6)
22:25:50 <lambdabot>   12
22:26:27 <fizzbang> yeah, that kind of currying is one of the things i want to learn how to use well..
22:29:01 <fizzbang> thanks again..
22:45:11 <DijkstraGroupie> Hello. I know I can do the following by defining my own data types. But I would like to know if I can do this using plain old tuples: I want a 2-tuple whose second component is itself a list of these 2-tuples. Is this possible?
22:50:05 <shachaf> DijkstraGroupie: Do you mean as in data Foo a = Foo a [Foo a]?
22:52:17 <shachaf> DijkstraGroupie: You can't have a recursive type without using data/newtype. However, you could use something like Mu.
22:54:29 <DijkstraGroupie> shachaf: What is Mu?
22:54:40 <shachaf> @src Mu
22:54:40 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
22:54:50 <shachaf> DijkstraGroupie: Type-level fix.
22:54:56 <DijkstraGroupie> shachaf: Nice.
22:55:05 <DijkstraGroupie> shachaf: Thanks!
22:55:24 <DijkstraGroupie> @hoogle Mu
22:55:24 <lambdabot> Text.ParserCombinators.ReadP munch :: (Char -> Bool) -> ReadP String
22:55:24 <lambdabot> Text.ParserCombinators.ReadP munch1 :: (Char -> Bool) -> ReadP String
22:55:24 <lambdabot> package mucipher
22:56:08 <shachaf> I don't think it's in any particular standard library.
22:56:27 <shachaf> Just #haskell lore.
22:57:14 <DijkstraGroupie> shachaf: Oh.
22:58:20 <shachaf> DijkstraGroupie: In general you should probably just use a data type for things like this. :-)
22:58:56 <shachaf> (Mu isn't enough -- you'd also need Compose, I think -- and type-level point-free isn't particularly pleasant.)
22:59:27 <DijkstraGroupie> @src Compose
22:59:27 <lambdabot> Source not found. You type like i drive.
23:00:04 <DijkstraGroupie> shachaf: Well, I guess I have no choice but to use a custom data type.
23:00:18 <shachaf> DijkstraGroupie: Custom data types aren't that bad!
23:00:30 <shachaf> If your data type is recursive, it probably *should* be custom.
23:00:42 <sopvop> So, I'm writing an extension to c-like language (in haskell, so it's relevant), kind of source to source compiler to extend basic language. And I'm thinking about adding haskell-like typeclasses to it, but can't figure out good syntax to use. Anyone know a good example of c-like language with better syntax than horrible c++ templates?
23:01:59 <sopvop> Asking here because haskellers are smart
23:03:19 <edwardk> sopvop: just adopt the haskell convention of using lower case types as type variables
23:03:36 <edwardk> sopvop: even in the absence of type classes, just having that as a generic mechanism is pretty sweet
23:04:19 <shachaf> edwardk: As opposed to explicit scoping?
23:04:33 <edwardk> shachaf: exactly
23:04:47 <sopvop> I just want to add syntax sugar, not breaking old code.
23:05:15 <edwardk> const :: a -> b -> a      rocks when compared to template <typename A, typeName B> A const(A a,B b)
23:05:24 <edwardk> oh, then you're doomed ;)
23:05:53 <shachaf> I think explicit scoping isn't that bad as long as it's not unreasonably verbose.
23:06:13 <sopvop> On the other hand, it can look like float foo(vector v, b, c) {} and b,c would be type variables
23:06:22 <edwardk> sopvop: most of the horribleness of c++ syntax came about from bjarne trying not to break existing code ;)
23:07:13 <Pseudonym> edwardk: Also true of Haskell, FWIW.
23:07:38 <Pseudonym> All the good syntax is taken by the less-useful, non-generic versions of stuff.
23:07:42 <sopvop> Haskell has quite readable syntax.
23:07:44 <Pseudonym> Because that's what was there first.
23:08:00 <Pseudonym> sopvop: Not arguing with that.
23:08:11 <ykm> @hoogle sequenceA
23:08:12 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
23:08:12 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
23:08:24 <Pseudonym> Must away.  Nytol!
23:08:37 <edwardk> sopvop: sure, there were just bouts of insanity when folks took up lots of useful operators for overly simple types, because they were afraid of how to teach stuff
23:08:51 <edwardk> 1998 was a very bad year for generality
23:09:50 * shachaf still isn't quite sure what happened between 1.4 and 98.
23:09:57 <yitz> edwardk: y was a very bad year for generality, where y is in some finite set S
23:10:20 * sopvop don't get math jokes.
23:10:24 <DijkstraGroupie> Don't you people sometimes wish you could compute types the way you compute (other) values?
23:10:28 <edwardk> shachaf: the mailing list from that year was quite informative
23:10:45 <edwardk> DijkstraGroupie: no, if i want to do that, i go play in agda, then i come back and enjoy myself ;)
23:11:12 <edwardk> DijkstraGroupie: i like type inference, it makes me happy, and gives me a great return on investment for the effort i expend.
23:11:22 <DijkstraGroupie> Agda's syntax is too weird.
23:12:01 <sopvop> Type inference stops working when you start to use GHC extensions :(
23:12:18 <shachaf> I don't think I've ever heard someone object to Agda with *syntax* as their chief complaint...
23:12:45 <Axman6> i wish it was slightly more haskell like in its syntax =)
23:12:48 <edwardk> sopvop: well, it remains able to infer reasonable types for everything you aren't using bizarre features for, so its a solid compromise
23:14:00 <shachaf> Axman6: I wish Haskell's syntax was more like Agda's.
23:14:39 <Axman6> types in agda start with a lower case r\ight?
23:15:18 <edwardk> Axman6: they can start with anything you want them to start with =P
23:15:29 <Axman6> >_<
23:15:50 <edwardk> shachaf: i like being able to type my code without a unicode reference table handy and a bunch of emacs macros for inspecting the codepoint under the cursor
23:16:29 <edwardk> don't get me wrong, before i used agda i was a huge proponent of unicode syntax =/
23:16:47 <edwardk> but the agda standard library cured me
23:16:48 <flux> heh
23:17:02 <shachaf> edwardk: I didn't say anything about Unicode.
23:17:07 <edwardk> that said, mixfix is kinda cool =)
23:17:13 <shachaf> edwardk: That's a library/culture issue, not a lanuage issue.
23:19:35 <sopvop> We need a special keyboard with led letters on keys, so you press some button and all the symbols on it turn into greek alphabet, another - get math symbols. But it should be real keyboard, not some flat tablet. Gamers already have keyboards with programmable images on keys.
23:20:01 <edwardk> sopvop: http://en.wikipedia.org/wiki/Optimus_Maximus_keyboard
23:21:11 <sopvop> Yeah, now we need emacs extension for it :)
23:21:17 <flux> if it didn't have (as I hear) bad touch, I might've been more than a toy :/
23:21:29 <yitz> edwardk: why do you need macros? emacs has some pretty neat unicode support out of the box.
23:23:46 <edwardk> yitz: mostly just referring to the keybinding to see what you're cursoring over. with the latex input mode its not bad to generate unicode. Especially when you aren't worried about interop with someone else's code -- but when you are you have to guess which funny arrow that looks like all the other funny arrows they used
23:24:09 <edwardk> its much faster to produce agda than consume it
23:24:29 <edwardk> or rather its easy to consume, but not extend
23:25:00 <edwardk> now, i'm probably pretty biased, copumpkin and dolio have it down to an art, they can fly through picking those things out
23:25:20 <copumpkin> hah
23:25:27 <edwardk> i'm just not that good =)
23:27:25 <yitz> edwardk: C-x 8 RET usually works fine for me, though i suppose it could become tedious if you are inputting a lot of text. though i'm not sure if latex input mode helps much more with that.
23:27:40 <yitz> </though></though>
23:28:27 <edwardk> i probably just need to get more facile with the use of the agda hole mechanism. i don't think i ever see either of them really type ;)
23:28:50 <edwardk> they just sit there and stare, then smash a dozen keys and get it to expand into what they want
23:29:18 <yitz> we'll see what happens if/when they add the hole mechanism to haskell, as some people are proposing
23:30:23 <edwardk> we'll see. i really really want the types of stuff that is in scope which was locally introduced around the hole. and the proposals so far don't seem to be offering that
23:30:27 <edwardk> which kinda makes it useless
23:30:55 <yitz> not useless, but true, far less usefull.
23:30:56 <edwardk> so i'm not yet sure i get anything more than I do with the ghetto ?foo hacks
23:31:10 <edwardk> well, with ?foo i can at least pass it those args and get them
23:31:37 <yitz> never really played with that, it looked messy
23:32:13 <edwardk> i wind up with a lot of cps'd code, which is precisely where i want to be able to manipulate holes in haskell to figure out my obligations and what things i have to fill in the holes
23:32:33 <edwardk> knowing an ungeneralized type of the hole without knowing what i can put into it is pretty silly
23:33:26 <yitz> it seems like the compiler *ought* to be able to provide that
23:34:32 <edwardk> @hpaste
23:34:32 <lambdabot> Haskell pastebin: http://hpaste.org/
23:35:42 <hpaste> edwardk pasted “i really need the types of ee and ce to know hw to fill in {}1 and {}2” at http://hpaste.org/66158
23:40:03 <hpaste> edwardk annotated “i really need the types of ee and ce to know hw to fill in {}1 and {}2” with “or worse” at http://hpaste.org/66158#a66159
23:45:40 <Peaker> yitz: emacs unicode support seems limited -- it doesn't seem to do BiDi right, for example
23:55:23 <ykm> is there any way to trace a function execution in ghci like in clisp?
23:59:17 <Axman6> @google haskell debugger
23:59:20 <lambdabot> http://www.haskell.org/haskellwiki/Debugging
23:59:20 <lambdabot> Title: Debugging - HaskellWiki
