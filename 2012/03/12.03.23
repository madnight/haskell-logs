00:02:26 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r ","GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops"]'
00:02:26 --- topic: set by glguy on [Tue Feb 21 17:16:07 2012]
00:03:00 <quicksilver> wagle: you've either been mislead, or you've misunderstood; can you point to examples of the kind of expert commentary you're talking about?
00:03:07 <wagle> in person
00:03:31 <kallisti> quicksilver: the memory overhead of copying is largely eliminated by clever garbage collection, however.
00:03:34 <kallisti> right?
00:04:12 <quicksilver> certainly the memory overhead of copying is less than you might imagine if it all happens in the nursery
00:04:22 <kallisti> right
00:04:27 <quicksilver> because the nursery fits in a cache-line
00:04:36 <quicksilver> and copying within the CPU cache is "free" on modern CPUs.
00:05:59 <quicksilver> there are also a few algorithms in which you can encode the only mutation they need into thunk-update
00:06:10 <quicksilver> and avoid copying that way. But that's a fairly limited class of algorithms.
00:06:27 <quicksilver> and certainly doesn't include typical array mutation code.
00:09:21 <Authoritarianism> Hello. I would like to know if there are any memory leaks in my prime sieve: http://hpaste.org/65804
00:35:16 <CQ> is there a way to trace execution of a haskell program to see what gets passed and evaluated at each step?
00:36:28 <Axman6> there is, ghci has a debugger. there are docs online... somewhere
00:36:33 <Axman6> @where debugger
00:36:34 <lambdabot> http://donsbot.wordpress.com/2007/11/14/no-more-exceptions-debugging-haskell-code-with-ghci/
00:38:11 <CQ> Axman6: thanks
00:39:19 <yasar> Is every "Num" is also a fractional?
00:40:15 <yasar> I mean how come 5 / 2 gives 2.5, while :t (/) gives Fractional a => a -> a -> a, and :t 5 give Num
00:43:26 <ion> Every fractional is also a num.
00:43:55 <ion> :t 5 `asTypeIn` \n -> n / 2
00:43:56 <lambdabot> forall t. (Fractional t) => t
00:44:23 <Authoritarianism> Is there any way to determine whether my code has memory leaks?
00:44:34 <CQ> Axman6: is there a way to run the debugger in an ide, like lakseh or something to make it easier to follow the line:column notation?
00:44:39 <ion> Sorry, i’m talking out of my ass. Just woke up and didn’t get the caffeine yet. :-P
00:45:18 <ion> Err. I’m not. Every fractional *is* a num.
00:45:32 <Authoritarianism> :i Fractional
00:45:48 <Authoritarianism> Awww, no :i?
00:45:52 <Authoritarianism> :(
00:46:07 <timthelion> In the case that we have a list of great lenght, and we need to create a new list that is the same, but with one value different, is newlist = newlist' (splitAt indexBeforeValueThatWeWishToChange list) newlist' (start,end)  = start ++ [newvalue] ++ (tail end) a reasonable method?
00:47:32 <Authoritarianism> Is there any way to see the C-- output generated by the compiler before that gets compiler to a native executable?
00:47:57 <timthelion> Authoritarianism: which compiler generates C code?
00:48:12 <Authoritarianism> gcc
00:48:15 <Authoritarianism> No, wait.
00:48:20 <quicksilver> yes, there is Authoritarianism
00:48:21 <Authoritarianism> I read it as compiles C code.
00:48:36 <quicksilver> although GHC doesn't produce pure C-- really
00:48:46 <quicksilver> but there are various -ddump-foo options
00:48:50 <quicksilver> check teh manual
00:49:04 <Authoritarianism> Okay!
00:49:07 <Authoritarianism> Thanks!
00:49:30 <timthelion> GHC produces C ????  Crazy :D I guess that's one way to make for easy portability.
00:49:31 <timthelion> So all my code gets translated to C...
00:52:47 <Guest274> hello people I come with a question: how do I add an Integer to a Ratio Integer?
00:52:56 <ion> guest: fromIntegral
00:53:10 <Guest274> argh
00:53:15 <yasar> if I say "fourtimes x = twotimes x + twotimes x", how many times does "twotimes" gets evaluated?
00:53:26 <Guest274> I need to stick fromIntegrals in front of all the integers?
00:53:40 <ion> guest: Hard to say without seeing your code.
00:54:12 <Guest274> ok, here's my code:
00:54:17 <Guest274> 	let t1 = ((x - z)*rhs1) + ((y - w)*rhs2) in
00:54:26 <Guest274> where rhs1 and rhs2 are Ratios
00:54:36 <Guest274> and x, z, y, w are Integers
00:54:56 <ion> I take it there’s a reason for them being Integers?
00:55:13 <timthelion> Guest274: but you can make it less nasty by creating a small function r = fromIntegral
00:55:13 <Guest274> Not really I could use Ints I guess
00:55:15 <Guest274> will that fix it?
00:55:25 <ion> Ints are bad, don’t use them. :-P
00:55:38 <timthelion> ion: why???
00:55:48 <ion> fromIntegral (x - z) * rhs1 + fromIntegral (y - w) * rhs2 isn’t that bad IMO.
00:56:04 <ion> timthelion: Ints are a wart, Integers are better.
00:56:33 <timthelion> ion: that's no reason...
00:56:51 <Guest274> ok, I'll sprinkle r's all over the place then
00:56:55 <Guest274> ty timhelion, ion
00:57:04 <Guest274> wheeee
00:58:35 <ion> timthelion: Either you want to restrict your values to a certain bit size or you don’t. The latter is a reasonable default, but if you want such a restriction, Data.Int contains such types with which you actually get to choose the size.
01:04:22 <timthelion> really, how can I make a list which is different by one value reasonably?
01:05:26 <timthelion> ion: you mean Int has arbitrary and platform specific size.
01:20:37 <Gying> hi, what kind of IDE  you use?
01:20:55 <Gying> for Haskell
01:21:09 <ion> None so far.
01:21:10 <Cale> timthelion: GHC *can* produce C code (whose compiled output requires additional mangling to actually run), but this is no longer the default.
01:21:24 <ykm> none.....ghci is good enough
01:21:46 <Cale> Gying: personally I just keep ghci open alongside whatever text editor I'm using at the time, usually vim/gvim or gobby
01:21:47 <ion> ykm: I wouldn’t say that.
01:22:11 <ykm> ion: for a beginner like me...it is
01:23:41 <Cale> Personally, I'd just like a text editor which actually understood the layout rule, and which would move an entire layout block when any edit caused the first non-whitespace character after a layout keyword to move.
01:26:07 <Gying> @ghci? ok,thank you very much``` it's my first day to study Haskell..
01:26:07 <lambdabot> No quotes match. Wrong!  You cheating scum!
01:26:26 <Gying> @Gying test.
01:26:27 <lambdabot> pong
01:32:02 <osa1> how can I match [A-Za-z0-9] with parsec?
01:37:39 <m3ga> osa1: @hoogle many1
01:37:47 <ion> let betw a b c = Any (a <= c && c <= b) in satisfy (mconcat [betw 'A' 'Z', betw 'a' 'z', betw '0' '9'])
01:38:33 <m3ga> osa1: many1 (letter <|> digit)
01:40:20 <osa1> m3ga: that was what I had tried, http://paste.pocoo.org/show/569887/
01:40:29 <ion> Whoops, what i said won’t work.
01:41:34 <m3ga> osa1: thats the error message. where is the code?
01:41:54 <osa1> m3ga: code is a = many1 (letter <|> digit)
01:42:08 <yasar> if I say "length [1..]" will I get something like "inf", or will I get infinite loop? I didn't dare to try :)
01:42:18 <ion> many1 has nothing to do with the original regexp.
01:42:42 <osa1> ion: original regexp should have +, I forget to put that
01:42:57 <osa1> [A-Za-z0-9]+
01:43:04 <ChristianS> yasar: you'll get an infinite loop.
01:43:11 <ChristianS> > length [1..]
01:43:14 <lambdabot>   mueval-core: Time limit exceeded
01:43:20 <ion> FWIW, satisfy (getAny . mconcat [betw 'A' 'Z', betw 'a' 'z', betw '0' '9']) should work. Also, “letter” isn’t [A-Za-z].
01:43:38 <ion> letter seems to be satisfy isAlpha.
01:43:41 <ChristianS> yasar: length is always linear to the length of the list.
01:44:19 <ion> oneOf (['A'..'Z'] ++ ['a'..'z']
01:44:35 <m3ga> ion: so what's the difference bewtween [A-Za-z] and letter?
01:44:44 <ion> ++ ['0'..'9']) would work as well, but it’s not as efficient as a few Ord comparisons.
01:44:59 <ion> > {- m3ga: -} isAlpha 'ä'
01:45:00 <lambdabot>   True
01:45:28 <m3ga> ion: orig poster probablt wants letter instead if A-Za-z anyway
01:45:41 <yasar> is there any difference between "null xs" and  "xs == []" ?
01:45:57 <m3ga> second if you want efficiency you should uses a token parser instead of a char parser
01:46:51 <osa1> ion: http://paste.pocoo.org/show/569889/
01:48:48 <mikeplus64> yasar: == is a bit more generic than null
01:49:49 <m3ga> @hoogle many1
01:49:49 <lambdabot> Text.ParserCombinators.ReadP many1 :: ReadP a -> ReadP [a]
01:49:50 <lambdabot> Text.Parsec.Combinator many1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]
01:49:50 <lambdabot> Text.ParserCombinators.Parsec.Combinator many1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]
01:49:57 <ChristianS> yasar: generally, null is preferred (except in pattern matching, where you would just write [] )
01:50:18 <m3ga> osa1: see the second many1 typesig above
01:50:23 <mikeplus64> null is probably just null [] = True; null _ = False, whereas x == y has to test equality for lists of ldifferent lengths
01:50:30 <mikeplus64> different*
01:50:49 <mikeplus64> so it is more complicated
01:50:54 <m3ga> many1 takes a 'ParsecT s u m a' and you're passing it a Char list
01:51:04 <ion> osa1: oneOf
01:51:35 <osa1> ion: yeah I've also tried that http://paste.pocoo.org/show/569890/
01:51:55 <astor_> Can someone explain to me why (Data.Packed.Matrix Double) is not an instance of Eq?  We have Container Matrix a => Eq (Matrix a) from Data.Packed.Matrix.  Then we have Container Vector Double and Container Vector a => Container Matrix a from Numeric.Container.  Shouldn't ghc resolve all of this?
01:54:03 <ion> λ> :t many1 (oneOf (['A'..'Z'] ++ ['a'..'z'] ++ ['0'..'9']))
01:54:07 <ion> many1 (oneOf (['A'..'Z'] ++ ['a'..'z'] ++ ['0'..'9'])) :: Stream s m Char => ParsecT s u m [Char]
01:54:09 <ion> Seems to work here.
01:55:30 <osa1> ion: strange. after adding GenParser Char st String signature, it worked. why do I need to add it?
01:56:13 <ion> osa1: Try just :: Parser String
01:56:37 <m3ga> osa1: because its abiguous without the typesig, but yeah, 'Parser String' should do it
01:56:50 <m3ga> > atom :: Parser [Char]
01:56:51 <lambdabot>   Not in scope: type constructor or class `Parser'Not in scope: `atom'
01:57:00 <osa1> Parser String is better, thanks
01:57:05 <ion> It doesn’t require a type signature here, though.
01:57:17 <ion> λ> parseTest (many1 (oneOf (['A'..'Z'] ++ ['a'..'z'] ++ ['0'..'9']))) "Foo bar"
01:57:19 <ion> "Foo"
01:57:23 <osa1> ion: it requires in my case, many1 (oneOf (['A'..'Z'] ++ ['a'..'z'] ++ ['0'..'9']))
01:57:41 <m3ga> osa1: http://paste.pocoo.org/show/569892/
01:58:31 <osa1> m3ga: yeah so my errors was because of left type signatures
01:58:37 <osa1> thanks
02:00:55 <ion> λ> parseTest (many1 (let betw a b = satisfy (\c -> a <= c && c <= b) <?> ("[" ++ [a] ++ "-" ++ [b] ++ "]") in betw 'A' 'Z' <|> betw 'a' 'z' <|> betw '0' '9')) "Foo bar"
02:00:57 <ion> "Foo"
02:01:16 <ion> With "ä": parse error at (line 1, column 1): unexpected "\228", expecting [A-Z], [a-z] or [0-9]
02:03:11 <ion> m3ga: Those are old module names, importing Text.Parsec and Text.Parsec.String should be enough.
02:34:07 * hackagebot flow2dot 0.9.0.1 - Library and binary to generate sequence/flow diagrams from plain text source  http://hackage.haskell.org/package/flow2dot-0.9.0.1 (DmitryAstapov)
02:46:16 <nart> hi
02:54:45 <quicksilver> timthelion: C-- is not C.
03:34:11 * hackagebot flow2dot 0.9.0.2 - Library and binary to generate sequence/flow diagrams from plain text source  http://hackage.haskell.org/package/flow2dot-0.9.0.2 (DmitryAstapov)
03:46:27 <mikeplus64> anyone know if the SDL and OpenGL bindings can coexist (ie so you can get 3D in haskell SDL apps)?
03:46:35 <mikeplus64> and if so, got any examples?
03:47:45 <mikeplus64> the SDL bindings are really great/simple to use, but the OpenGL ones reek of old imperative-ness
03:48:32 <mikeplus64> callbacks :(
03:48:51 <mikeplus64> I mean opengl + glut
03:53:25 <quicksilver> mikeplus64: you certainly can't use GLUT + SDL
03:53:30 <quicksilver> they're both windowing toolkits
03:53:35 <quicksilver> you can use opengl + SDL though
03:53:42 <quicksilver> although I can't give specific advice on how to do so
03:53:49 <bitonic> glut is a windowing toolkit?
03:54:05 <quicksilver> you need SDL to set up the openGL context for your window(s) and thereafter the normal opengl calls will work.
03:54:06 <bitonic> and SDL? what do you mean with windowing toolkit?
03:54:33 <quicksilver> they both handle your OS's native windowing system and they both "own" the event loop.
03:56:07 <quicksilver> bitonic: I agree that windowing toolkit isn't really the right term.
03:56:36 <bitonic> yeah, but I get what you're saying
03:57:11 <bitonic> I have to resist from starting stupid terminology discussions :P
03:58:09 * quicksilver recommends that :)
03:59:16 <mikeplus64> quicksilver: ok
04:02:22 <CQ> are there any docs / tutorials about how event driven programming (GUIs) and functional programming work together? issues like that one needs a lot of state, the other doesn't want state, etc.
04:03:07 <mikeplus64> oh awesome, SDL works in GHCi now
04:06:19 <CQ> wow, this ghci data structures visualization seems cool cheater	oh man, i feel bad.
04:06:28 <CQ> wow, this ghci data structures visualization seems cool https://www.youtube.com/watch?v=nQkhELdAYB8
04:06:42 <CQ> sorry, first paste was from #haskell-blah ;)
04:06:48 <timthelion> Is data Path = SeppingStone Point (Maybe Path) | Destination Point the "best" way of writting data Path = SteppingStone Point Path | Destination Point | NoPath ?
04:07:15 <Philonous> Has anyone else have the line "data Foo = Foo deriving (show)" generate a GHC panic (in 7.4.1) ?
04:08:05 <timthelion> Philonous: if you give me a test file I'll test it.
04:08:19 <ion> philonous: Hehe, it does indeed.
04:08:57 <Philonous> ion:  OK, it'll write a bug report
04:09:01 <Philonous> Thanks
04:09:09 <ion> Anything beginning with a lower-case letter does that.
04:09:13 <Philonous> I'll*
04:09:17 <Philonous> Indeed
04:10:04 <Philonous> It has to be in parenthesis, though
04:10:38 <ion> true
04:11:34 <ion> deriving ((?)) makes it panic, too.
04:11:45 <ion> (It’s nice a GHC doesn’t kill GHCi, btw.)
04:11:48 <ion> a GHC panic
04:13:10 <timthelion> you mean GHC doesn't compile with -Wall???
04:13:47 <ion> Who means?
04:15:43 <timthelion> ion: well that it panics...
04:17:57 <Philonous> timthelion:  No, it's an error, it shouldn't compile at all, but instead of generating an error ghc crashes
04:19:20 <hiptobecubic> lambdabot won't build :(
04:19:42 <timthelion> Philonous: Nevermind, I had somehow had it in my mind that -Wall programs *couldn't* crash.  But then I remembered cases like 1/0 and minimum []
04:20:31 <ion> main = putStrLn "panic!"
04:20:37 <ion> Here’s another program that says it panics.
04:20:40 <timthelion> hiptobecubic: what does it tell you?
04:20:56 <timthelion> ion: what a usefull error message :D
04:23:19 <hiptobecubic> timthelion, had to add "extensions: FlexibleInstances" to the cabal file
04:23:29 <ion> @check let paral = recip . sum . map recip in \a b c -> paral [a,b,c] == paral [a, paral [b,c]]
04:23:31 <lambdabot>   "Falsifiable, after 3 tests:\n2.5\n0.6666666666666666\n2.75\n"
04:33:18 <hiptobecubic> I installed djinn, but lambdabot can't find it apparently
04:35:58 <Ste1891> hpaste.org doesn't seem to be working; it throws exceptions when I try to post something.  Has anyone else had this problem?
04:36:50 <Senmorta> everyone yesterday had that problem too
04:37:10 <Senmorta> w/ hpaste
04:39:03 <timthelion> Senmorta: You have to select a programing language other than haskell.
04:40:46 <Senmorta> okay
04:41:25 <Ste1891> OK, I'll give it a try.
04:41:43 <hiptobecubic> does anyone have a local install of lambdabot working?
04:42:01 <hpaste> Ste1891 pasted “Type errors in function call” at http://hpaste.org/65807
04:42:03 <hiptobecubic> pl seems to work, djinn does not.  djinn itself, as a standalone DOES though.
04:42:14 <Ste1891> I'm being told there's "No instance for (Num[a0])" when calling my function in a print call.  Can anyone explain how to understand this?
04:45:01 <timthelion> Ste1891: what type is d_num?
04:45:30 <timthelion> try print (decimal_binary (read d::Int) 128)
04:45:54 <Ste1891> It's expected to be an integer between 0 and 255.
04:46:22 <timthelion> But readLn gives you a string, does it not?
04:48:54 <t7> @check \x -> not x
04:48:55 <lambdabot>   "Falsifiable, after 0 tests:\nTrue\n"
04:54:16 <hpc> hiptobecubic: it's a change between versions of djinn
04:54:24 <hpc> hiptobecubic: see http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13
05:07:25 <osa1> I'm trying to write a simple lisp-like language interpreter in haskell and I have no idea how can I emulate functions with arbitrary number of parameteres, any ideas?
05:07:49 <hpc> @tell hiptobecubic see http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13 -- newer versions of djinn have different output, and lambdabot is kind of stupid
05:07:49 <lambdabot> Consider it noted.
05:08:15 <hpc> osa1: data LType = LInt Int | ...
05:08:25 <hpc> type Function = [LType] -> LType
05:08:43 <hpc> or something like that
05:10:26 <nart> ciao =)
05:15:17 <exFalso> does anyone know why deriveLift puts constraints on phantom types?
05:21:45 <mekeor> does anyone know a function (which must be written in template haskell, AFAIK) which gets a function (:: a → a → … → a → a) and a list (:: [a]) and applies the function on the first N elements of the list (where N is the arity of the function) and then appends this result to the list (and removes the operands) and afterwards maybe returns the result (such that the type of the function is :: … → Maybe [a])?
05:22:12 <mekeor> i hope i could explain my concern…
05:26:24 <mekeor> let's call the function i am looking for like this: `foo'. so, `foo (+) [1..5]' would result in `[3,4,5]'. `foo (-) [1..5]' would result in `[-1,3,4,5]'. and `foo (++) ["foo","bar","baz"]' would result in `["foobar","baz"]'.
05:26:39 <mekeor> oh, i am sorry.
05:26:55 <mekeor> `foo (+) [1..5]' would result in [3,3,4,5]
05:27:52 <mekeor> and `foo (\x y z -> if x then y else z) [True,False,True,False]' would result in [False,False].
05:30:36 <mekeor> i think, in dependently-typed languages it would be easy to implement a such a function except that it would need the arity of the operand as well, like this: `foo 2 (+) someList' or `foo 3 (\x y z -> if x then y else z) someBooleanList'… but what about template haskell? is it possible to implement the function `foo' in TH?
05:31:33 <hpc> mekeor: only if you just need polymorphism
05:31:49 <hpc> if you need to wait until runtime to get the number of arguments, you're screwed
05:32:29 <mekeor> hpc: why?
05:32:49 <hpc> because static types
05:33:42 <hpc> TH is polymorphic in the way you need, but it still runs at compile-time, so all TH values are decided before the program runs
05:34:18 <mekeor> hmmm
05:35:05 * mekeor is wonders whether he needs the function at runtime…
05:37:04 <mekeor> no, i think i don't (if i'm right)! cool!  so, i could try TH =) so let's get started then…
05:37:07 <mekeor> thanks, hpc
05:41:55 <hpc> mekeor: you basically get the same kind of variadic function that printf gives you
05:42:07 <hpc> it can take any number of arguments, but GHC needs to know how many beforehand
05:42:16 <hpc> np
05:42:35 <cwl> which package defines YesodHeroku?
05:42:37 <dzhus> how do I case-match the monadic value?
05:43:16 <dzhus> (a shortcut for «foo <- doStuff; case foo of …»)
05:47:17 <hpaste> timthelion pasted “it didn't work :(” at http://hpaste.org/65811
05:48:21 <timthelion> hmm, hpaste's literary haskell code colloring sucks.
05:49:24 * hackagebot sparse-lin-alg 0.2.1 - Small library for effective linear algebra on sparse matrices  http://hackage.haskell.org/package/sparse-lin-alg-0.2.1 (AlexeyAlekhin)
05:50:37 <mekeor> dzhus: i heared that 'case of' is the same as '\x -> case x of', so you could maybe try something like 'doStuff >>= case of' but i'm not sure.  hpc will correct me if i am wrong.
05:51:00 <quicksilver> that's an extension proposal
05:51:04 <mekeor> ah
05:51:17 <quicksilver> it's not part of haskell and I don't think it's even implement as an extension
05:52:11 <quicksilver> mekeor: haskell-prime ticket : http://hackage.haskell.org/trac/haskell-prime/ticket/41 ; ghc patch (unapplied) : http://hackage.haskell.org/trac/ghc/ticket/4359
05:54:32 <mekeor> bummer.
05:54:47 <quicksilver> some interesting discussion in #4359
06:02:02 <hpc> yeah, i can't wait for case-of lambdas to be implemented
06:02:24 <hpc> it's so natural that im honestly surprised it hasn't been added sooner
06:03:47 <alpounet> the problem is apparently making it 1/ not conflict with the current syntax 2/ easy to read
06:10:00 <digitteknohippie> anyone here use debian?  haskell-network is no longer in the repo it seems.  someone said the network module had been merged, but when i run my haskell irc bot, it still cries out for the network module.  i've found no mention of this on debian's forums, wiki, bugs, etc.
06:11:30 <davesq> Does anyone have a simple example of when mapping over an infinite list is useful?
06:11:31 <hpc> digitteknohippie: http://hackage.haskell.org/package/network -- this?
06:11:53 <hpc> davesq: fib n = ...
06:11:57 <hpc> fibs = map fib [0..]
06:13:39 <digitteknohippie> hpc, yes.  it's still on packages.debian.  but not actually in the repository.
06:13:59 <timthelion> > (fst (3,2) - fst (4,4),snd(3,2) - snd (4,4))
06:13:59 <lambdabot>   (-1,-2)
06:14:05 <timthelion> So ugly :(
06:14:08 <hpc> digitteknohippie: you can cabal install network
06:14:09 <mekeor> digitteknohippie: use cabal(-install) instead of apt
06:14:19 <timthelion> how can I do (3,2)-(4,4)?
06:14:32 <hpc> apt-get install cabal-install && cabal update && cabal install network
06:14:40 <hpc> (possibly with --global)
06:14:59 <Clint> digitteknohippie: sounds like your mirror is screwed
06:15:09 <davesq> hpc: So to find, say, the first fib > x or something?
06:15:17 <digitteknohippie> yeah... fair enough.  :/  was trying to avoid that.   was trying to stick to the the repo.  oh well.  thnx guys.  :)
06:15:36 <digitteknohippie> clint, you still see haskell-network in yours?
06:15:50 <mekeor> timemage: you could make pairs an instance of Num such that you can always use that. but AFAIK that's already implemented somewhere… let's ask quicksilver.
06:15:57 <hpc> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2); fibs = map fib [0..] in dropWhile (< 15) fibs
06:16:01 <lambdabot>   mueval-core: Time limit exceeded
06:16:02 <Clint> digitteknohippie: yes
06:16:12 <timemage> mekeor, awesome.  what next?
06:16:16 <hpc> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2); fibs = map fib [0..] in takeWhile (< 15) fibs -- apparently this is slow
06:16:17 <lambdabot>   [1,1,2,3,5,8,13]
06:16:25 <snhmib> how do you do Float -> Double conversion in haskell?
06:16:29 <ion> realToFrac
06:16:33 <digitteknohippie> :O  i've tried on a squeeze and sid install, neither had it.
06:16:37 <snhmib> thanks
06:17:01 <ion> fromIntegral and realToFrac are the main number type conversion functions.
06:17:02 <Clint> digitteknohippie: what are you trying?
06:17:09 <mekeor> timemage: just to something like: instance Num (a,b) where (+) (a,b) (c,d) = (a+c,b+d) -- or something similar
06:17:28 <timemage> mekeor, just messing with you, pretty sure you want timthelion. =P
06:17:37 <quicksilver> timthelion, mekeor : well, use one of the vector packages for that kind of things.
06:17:46 <mekeor> timemage: oh, lol. sorry :D hehe
06:17:47 <digitteknohippie> tried simply apt-get install haskell-network (and in desperation libghc-network...)
06:17:58 <Clint> digitteknohippie: it's libghc-network-dev in sid and libghc6-network-dev in squeeze
06:17:59 <quicksilver> (Int,Int) is not a very good Num instance.
06:18:02 <ion> timthelion: http://hackage.haskell.org/package/NumInstances
06:18:06 <Clint> haskell-network is the name of the source package
06:18:27 <mekeor> quicksilver: why?
06:18:32 <digitteknohippie> ah, i missed the 6 when trying in squeeze
06:19:11 <quicksilver> mekeor: well, how would you define fromInteger?
06:19:35 <ion> > 4 :: (Integer, CReal)
06:19:36 <lambdabot>   (4,4.0)
06:19:36 <mekeor> (oh yea, actually it should be: instance (Num a, Num b) => Num (a,b) where (+) (a,b) (c,d) = (a+c,b+d) -- …)
06:19:43 <mekeor> quicksilver: err… >.>
06:19:51 <digitteknohippie> :)   ahhh, easy once you know.  XD    thanks clint.
06:20:04 <Clint> np
06:20:27 <quicksilver> ion: yes, there are answers. that is one of them.
06:20:38 <quicksilver> they're somehow unsatisfactory :)
06:21:19 <mekeor> ion: what the hell? who did implement that?
06:21:28 <ion> quicksilver: This one has the property that 2*(x,y) = (2*x,2*y)
06:21:45 <ion> mekeor: It says on the page.
06:21:56 <mekeor> ah
06:22:37 <timthelion> ion: I would have to install that through cabal?
06:22:42 <davesq> hpc: Thanks
06:23:11 <quicksilver> ion: indeed :)
06:23:16 <ion> timthelion: That’s how you install packages, yeah.
06:23:32 <timthelion> ion: not worth the extra dependnecy ;)
06:23:39 <mekeor> ion: ah, yea. i remember. we've already talked about that library once …  lambdabot uses it, right?
06:23:51 <quicksilver> ion: and it has the properties 1*v = v and 0*v = 0
06:23:56 <mekeor> okay, that's why it worked before… omg
06:23:59 <mekeor> :D
06:25:00 <ion> mekeor: Yeah, lambdabot uses it.
06:50:54 <mekeor`> oh, actually interact is in Prelude, too…
06:51:15 <nart> for example "Left :: forall b a. a -> Either a b " what are foral, b , a. a
06:51:20 <nart> *forall
06:51:58 <quicksilver> nart: it's just a way of indicating that Left has that type for all possible types "a" and "b"
06:52:01 <quicksilver> nart: it's not haskell
06:52:08 <quicksilver> (it is permitted by some haskell extensions though)
06:52:24 <parcs`> how do i interpolate a c macro with hsc2hs?
06:53:02 <Athas> Hm, what is the fastest way to read as many lines as possible from a Handle (as ByteStrings), but not blocking if none are available?
06:53:11 <nart> quicksilver: ah ok thanks
06:53:17 <Athas> Combining hGetNonBlocking with manual splitting into lines?
06:54:12 <quicksilver> Athas: yes, but you'll need to manage your own "partial line buffer"
06:54:27 <quicksilver> Athas: (to cope with the case that the handle blocks mid-line)
06:54:28 <Athas> Indeed.
06:54:34 <SoleSoul> Hi. How do I round a float to have 2 decimal digits after the dot?
06:54:40 <Athas> I'll hack it up and see what my performance will be like.
06:54:45 <quicksilver> Enumerat{or,ee}s solve this problem quite generally
06:54:51 <quicksilver> but many people find them fiddly to use.
06:55:11 <Athas> It just seems that Data.ByteStrings own hGetLine uses some evil, abstraction-breaking optimisations itself...
06:55:31 <quicksilver> > let x = 4.321 in (round (x * 100)) / 100
06:55:32 <lambdabot>   Ambiguous type variable `b' in the constraints:
06:55:32 <lambdabot>    `GHC.Real.Integral b'
06:55:32 <lambdabot>   ...
06:55:44 <quicksilver> > let x = 4.321 in (round (x * 100) :: Int) / 100
06:55:45 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
06:55:45 <lambdabot>    arising from a use o...
06:55:50 <Athas> Maybe I should use enumerators... I'll see whether that would actually result in smaller code.
06:55:59 <quicksilver> > let x = 4.321 in (fromIntegral $ round (x * 100)) / 100
06:56:00 <lambdabot>   4.32
06:56:09 <quicksilver> SoleSoul: like that ^^ maybe. Or use "showFFloat"
06:56:52 <SoleSoul> quicksilver: the *100 trick... I forgot it.
06:57:05 <SoleSoul> quicksilver: thank you
06:57:53 <quicksilver> > showFFloat 4.321 2 ""
06:57:53 <lambdabot>   No instance for (GHC.Real.Fractional
06:57:54 <lambdabot>                     (Data.Maybe.Maybe ...
06:58:02 <quicksilver> > showFFloat 4.321 (Just 2) ""
06:58:02 <lambdabot>   No instance for (GHC.Real.Fractional
06:58:03 <lambdabot>                     (Data.Maybe.Maybe ...
06:58:07 <quicksilver> :t showFFloat
06:58:08 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
06:58:18 <quicksilver> > showFFloat (Just 2) 4.321 ""
06:58:18 <lambdabot>   "4.32"
06:58:25 <quicksilver> SoleSoul: ^^ :-)
06:58:36 <quicksilver> depends if you want a string or a number at the end.
06:58:43 <SoleSoul> a string
06:58:44 <geekosaur> > (takeWhile (/= '.') . show) 4.321
06:58:46 <lambdabot>   "4"
06:58:52 <geekosaur> whoops, thinko
06:58:53 <quicksilver> then possibly showFFloat is fine.
06:58:56 * geekosaur loks for coffee
06:59:05 <quicksilver> > let x = 4.321 in (fromIntegral $ round (x * 100)) / 100 :: Rational
06:59:06 <lambdabot>   108 % 25
06:59:19 <quicksilver> ^^ round without losing precision by going back to floating point, but still getting a number out ;)
06:59:43 <quicksilver> @faq can haskell think of more ways to round a floating point number than I've had hot dinners?
06:59:44 <lambdabot> The answer is: Yes! Haskell can do that.
07:00:09 <SoleSoul> I thought that there would be a standard way to do it
07:00:27 <quicksilver> showFFloat is standard
07:00:33 <quicksilver> slightly obscure, but standard.
07:00:51 <SoleSoul> I'll read about it then. thanks
07:01:35 <quicksilver> SoleSoul: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Numeric.html#v:showFFloat
07:02:13 <SoleSoul> very good to know about it
07:02:33 <parcs`> > 0x8010
07:02:34 <lambdabot>   32784
07:04:36 <SoleSoul> what is this return type? 0.o? shows?
07:05:13 <nart> "Do not rely on the foldl analogy too firmly, it is misleading. ((+),0) is an F-algebra and foldl (+) 0 is a catamorphism. But iteratee is different, it is an automaton. ". i'm like .. "wth ?"
07:05:53 <nart> F-algebra, catamorphism, automaton ... anyone has an ELI5 explanation ? :D
07:06:34 <SoleSoul> :)
07:07:46 <SoleSoul> quicksilver: what do I do with the "ShowS" I got. I don't know this type.
07:07:50 <SoleSoul> ?
07:08:40 <parcs`> type ShowS = String -> String
07:08:52 <parcs`> apply it to ""
07:08:56 <quicksilver> SoleSoul: just pass another "" as a parameter
07:09:03 <quicksilver> which is what I did when I tested it here:
07:09:10 <quicksilver> > showFFloat (Just 2) 4.321 ""
07:09:11 <lambdabot>   "4.32"
07:09:17 <quicksilver> as parcs` says.
07:09:27 * hackagebot http-conduit 1.3.0.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.3.0.1 (MichaelSnoyman)
07:09:56 <Apocalisp> What is the dual of Maybe?
07:10:03 <SoleSoul> but I have to map it and the "" should be the last argument.
07:10:25 <osa1> after parsing with Parsec, how can I use parsed values in IO monad?
07:10:31 <Athas> Damn, why is isEOF potentially blocking?
07:10:35 <Athas> That is bizarre.
07:10:55 <parcs`> SoleSoul: map (flip (showFFloat (Just 2)) "") stuff
07:11:15 <Melvar> > map (($"") . showFFloat (Just 2)) [4.321,5.678]
07:11:17 <lambdabot>   ["4.32","5.68"]
07:11:23 <parcs`> or map (\f -> showFFloat (Just 2) f "")
07:11:29 <SoleSoul> wow
07:11:40 <SoleSoul> :)
07:11:54 <SoleSoul> *overwhelmed by clever responses*
07:14:27 * hackagebot yaml 0.6.1 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.6.1 (MichaelSnoyman)
07:15:08 <nart> > (($"") . showFFloat (Just 2)) <$> [4.321,5.678]
07:15:10 <lambdabot>   ["4.32","5.68"]
07:15:27 <osa1> after parsing with Parsec, how can I use parsed values in IO monad?
07:16:18 <ion> Just like any other value
07:16:59 <liyang> > printf "%.03f" 3.1415
07:17:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:17:00 <lambdabot>    `Text.Printf.PrintfType ...
07:17:06 <liyang> > printf "%.03f" 3.1415 :: String
07:17:06 <lambdabot>   "3.142"
07:20:00 <liyang> Just don't ask for the type of printf. It's Magic™.
07:20:17 <ion> :t printf
07:20:18 <lambdabot> forall r. (PrintfType r) => String -> r
07:20:28 <ion> It’s also Nasty™. :-P
07:21:59 <napping> is it that bad?
07:22:13 <brisbin> http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work
07:22:15 <liyang> (It's not really. Just dispatch on the return type, if you're okay with OO terminology.)
07:22:46 <ion> It lacks static verification.
07:23:08 <napping> not sure about the method, but it's basically PrintfType String, PrintfType (IO a), (PrintfArg a, PrintfArg r) => PrintfType (a -> r)
07:23:14 <napping> that it does
07:23:34 <ion> A Template Haskell printf that does static type checking would be better.
07:23:49 <liyang> ion: I'm sure someone's written one already.
07:23:55 <ion> Yes
07:24:17 <napping> Who had the pure ml one?
07:24:46 <napping> ah yes, Danvy's "Functional Unparsing"
07:24:56 <Philippa> osa1: something like do f <- readFile "parseme.txt"; let parsed = parse myParser f; print parsed
07:27:01 <osa1> Philippa: yep, found it. at first I though Parsec.parse returns `Parse a` but it's just returning Either a ParseError
07:28:22 <ion> either (throwIO . MyError) return
07:28:50 <napping> Hi Philippa. How's the constraint programming going?
07:30:04 <parcs`> osa1: that's because the parser can fail
07:30:13 <parcs`> what do you want it to do if it fails?
07:30:36 <Philippa> napping: heh, I've not written much code lately unfortunately :-( Got a bunch of stuff to get round to doing in those terms, though
07:31:16 <napping> Looks like a nice foundation, but STLC isn't really room to show off
07:31:41 <Philippa> yeah, it's very much basics - it does let me do one trick though
07:31:41 <Melvar> What is the canonical tool to parse a binary data format?
07:31:59 <parcs`> cereal!
07:32:08 <napping> has that replaced Data.Binary?
07:32:16 <Philippa> (but that's mentioned at the bottom of the current post: the next one's WIP, honest)
07:32:19 <parcs`> well Data.Binary is lazy
07:32:53 <parcs`> cereal+incremental io is better i think
07:33:15 <ion> Data.Binary’s decode returns bottom upon a parse error. :-( Cereal is better in that regard.
07:33:44 <Clint> what about attoparsec/attoparsec-conduit?
07:33:45 <napping> hmm, isolate looks nice. anything else in the interface?
07:33:56 <parcs`> cereal also supports generic programming. you can autoderive efficient binary serializations with it :)
07:34:03 <napping> Melvar: I have found Data.Binary pleasant enough
07:34:15 <azaq23> could typeclasses in their basic uses be completely replaced by rank n types used in data declarations? Just as you in the rank n types example given in the documentation, where class Monad m
07:34:16 <azaq23> where ... is expressed as data Monad m = Monad (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m b)) ?
07:35:04 <napping> azaq23: that pretty much lets you represent instances, the other part is automatically picking one
07:35:18 * liyang thought Data.Binary was horribly slow?
07:35:20 <napping> and also to plug together things like (C a) => (C [a])
07:36:07 <gnoi> Can you remind me some ncurses lib analogue?
07:36:13 <napping> Where did you get that idea? I haven't noticed it being slow, and the page claims "Serialisation speeds of over 1 G/sec have been observed, so this library should be suitable for high performance scenarios."
07:36:14 <gnoi> vyi or something like that
07:36:27 <parcs`> vty
07:36:41 <Melvar> Correct me if I’m wrong, but Data.Binary doesn’t seem to provide for errors.
07:36:47 <napping> Philippa: most of my programming recently has been Coq proofs about syntax. I'm starting to hate named variables
07:37:54 <napping> Melvar: No, not really. Are you trying to parse possibly-malformed binary files?
07:38:04 <liyang> napping: I stand better informed then. Thought I remember some second-hand experience of Data.Binary being slow.
07:38:25 <napping> I could assume valid input, if you can't I have no idea
07:38:39 <Philippa> napping: heh, I don't blame you. I figure it's fairly clear where I've been taking a duck on that so far
07:39:31 <Melvar> napping: Since I’m not trying to do anything serious, I could assume valid input, but I don’t want to.
07:40:09 <napping> I would be a bit surprised if anything has nicer error handling than "parse error at <offset>"
07:40:25 <azaq23> napping: ah yes, so you could give around a value of data type Monad to explicitly adress what instance you're going to use. (C a) => (C [a]) looks like it would be just a function Monad a -> Monad
07:40:25 <azaq23> [a]
07:41:18 <Mathnerd314> I'm not certain I understand the point of having names in the semantics. Can't you just preprocess everything into de Brujin indices?
07:41:45 <napping> Obvious faithfulnes to existing paper semantics?
07:43:34 <Philippa> not to mention keeping the calculus approximately human-readable at reasonable pace without high levels of practice
07:43:45 <Mathnerd314> doesn't sound useful :p
07:44:23 <napping> Yeah, who cares whether programs are correct as long as they usually seem to work :p
07:44:57 <napping> Preprocessing is something to keep in mind
07:45:41 <Philippa> yeah. I'm a lot more comfortable with naming schemes that keep the original scheme available, too
07:45:56 <napping> Generally you have names in the surface syntax, so the question is whether it's more trouble to get rid of them or just deal with them
07:46:03 <Philippa> even if you just tupled in the surface syntax names
07:46:19 <napping> the bigger part just axiomatizes substitution anyways
07:46:40 <Mathnerd314> I guess I was thinking of something more like GHC's renamer
07:47:16 <napping> The most recent bit is something that's supposed to implement that interface, where translating away surface names might help
07:47:45 <Philippa> yeah, I commonly do things like (UserSuppliedName, GeneratedSymbol) and use that to prettyprint back names that the user /could/ supply with the generated symbol included
07:47:55 <Philippa> (or couldn't, but only because I used an escape character)
07:48:26 <napping> turns out doing the first thing I thought of didn't give a very nice way to formalize the argument that if applying a substitution to a term leaves a closed term, than it had mappings for all the free variables
07:48:33 <Philippa> I'm not doing that in my blog code at the moment because it's plain superfluous - so far I haven't needed anything more than Eq or Ord on names
07:48:49 <napping> well, everything is sunshine and puppies until you need alpha-equivalence
07:50:16 <Philippa> I haven't had to do proofs involving it, thankfully
07:51:07 <gngdhr> Can someone help me with understanding the logic of this snippet http://davidtran.doublegifts.com/blog/?p=7
07:51:37 <gngdhr> I am trying to get my head around how the power-set is calculated from a list as the input
07:54:17 <napping> it's making the "powerset" of x:xs from the powerset of xs
07:54:28 * hackagebot QuickAnnotate 0.2 - Annotation Framework  http://hackage.haskell.org/package/QuickAnnotate-0.2 (ShayanNajd)
07:54:43 <napping> {X | X \in P(x:xs), x not in X} = P(xs)
07:54:52 <napping> {X-{x} | X \in P(x:xs), x in X} = P(xs)
07:55:03 <gngdhr> napping: agree, but what I am finding it difficult to visualize is how two recursive calls to powerset are working in tandem
07:55:13 <napping> tandem?
07:55:18 <napping> it's in the ++
07:55:24 <gngdhr> together
07:55:25 <napping> so it uses the first call, then the second
07:55:43 <gngdhr> ok, so the first call is the recursion on the LHS of the ++ isn't it?
08:00:01 <napping> yeah, that ends up making a depth-first sort of traversal
08:00:25 <ksf> hmm. this: http://www.spotify.com/se/devnull/ would be cool to have for haskell.
08:01:16 <ksf> or, in general, a language-centric version of the icfp challenge.
08:04:15 <Elemir> It's a game?
08:05:59 <ksf> it's a challenge wrapped in a game of sort from what I can tell.
08:06:06 <gngdhr> napping: thank you
08:06:30 <gngdhr> napping: I was not sure if the order of execution was Left-to-Right or Right-to-Left
08:06:46 <napping> it's ++ that's doing it
08:06:50 <ksf> the haskell version could do a classic monica monad searching for the fixpoint of her life kind of story.
08:07:16 <napping> []++ys=[] ; (x:xs) ++ ys = x:xs ++ ys means it has to force the left argument before producing any results
08:08:35 <gngdhr> napping: Thanks for that info. I wish there was some way I could step through the execution so that I understand how the recursion works. Am finding it a bit difficult to figure it out. Am going to write it down, I guess
08:10:24 <geekosaur> yu can step through execution in ghci, or you can see if hat/ghat will handle what you're doing (I think it's a bit out of date) to visualize the evaluation
08:11:52 <gngdhr>  geekosaur: will try debugging in ghci now; wasn't aware of the debugging capabilities
08:12:38 <ozataman> anyone know why I would get ghc panic when using isInstance from template haskell on a complex type?
08:15:08 <quicksilver> ozataman: well tht would be a bug :) Not one I've heard of before but then nobody uses TH.
08:15:15 <quicksilver> ozataman: have you tried googling the error message?
08:15:36 <ozataman> well, it's a pretty generic one
08:15:43 <ozataman> ghc: panic! (the 'impossible' happened)
08:16:03 <quicksilver> impossible messages normally have details afterwards?
08:24:14 <ozataman> interesting - if you give isInstance a VarT "whatevername", you get the ghc panic
08:34:30 * hackagebot QuickAnnotate 0.3 - Annotation Framework  http://hackage.haskell.org/package/QuickAnnotate-0.3 (ShayanNajd)
08:34:38 <_mpu> Hi, what are the best choices for a parser generator, today?
08:35:19 <_mpu> Oops, I failed I wanted a pretty printer generator/library.
08:38:54 <bitonic> @help brainfuck
08:38:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:38:58 <bitonic> @help list
08:38:59 <lambdabot> list [module|command]
08:38:59 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
08:39:15 <bitonic> hey. where did the brainfuck interpreter go
08:40:12 <parcs`> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
08:40:13 <lambdabot>   Hello World!
08:40:26 <sipa> wow
08:40:34 <Elemir> Is there unbf?
08:40:58 <Elemir> @unbf print "Hello world?"
08:40:59 <lambdabot> print "Hello world?"
08:41:09 <Elemir> ;(
08:42:04 <Saizan> @unbf do x
08:42:04 <lambdabot> do { x}
08:42:30 <Saizan> @unpl do x
08:42:30 <lambdabot> do { x}
08:43:09 <parcs`> i guess unbrainfuck is a good synonym for unpl :P
08:43:30 <sipa> did you expect lambdabot to have a Haskell-to-Brainfuck compiler?
08:44:28 <Saizan> you can expect anything from lambdabot
08:44:38 <bitonic> oh, ok.
08:45:04 <tgeeky_> he's *both* Turing and Morbo complete!
08:45:43 <sipa> @vixen can you solve the halting problem?
08:45:43 <lambdabot> I can take it. The tougher it gets, the cooler I get.
08:46:12 <t7> @unbf putStrLn "Hello World!"
08:46:12 <lambdabot> putStrLn "Hello World!"
08:46:15 <tgeeky_> @quote Morbo
08:46:15 <lambdabot> <Reporter> says: How are your children, Morbo?   <Morbo> Belligerent and numerous.
08:46:43 <t7> someone wrote a brainfuck to C translater
08:46:48 <t7> it workerd really well
08:46:56 <ClaudiusMaximus> i started writing an edsl for generating boolfuck at some point, got as far as a working rot13 before getting distracted by shinier things
08:49:31 * hackagebot jmacro 0.5.5 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.5.5 (GershomBazerman)
08:51:16 <t7> boolfuck ?
08:51:42 <ClaudiusMaximus> uses bits instead of bytes
08:53:18 <yasar> when explicitly defining type signature, can I use type class constraints?
08:53:50 <t7> i dont think so, HM has to have type args at the start of a type
08:54:51 <dmwit> yasar: Yes, of course.
08:55:00 <dmwit> foo :: Constraint a => a -> a
08:55:03 <dmwit> e.g.
08:55:04 <dmwit> :t (+)
08:55:05 <lambdabot> forall a. (Num a) => a -> a -> a
08:55:16 <dmwit> (You can ignore the "forall a." for now.)
08:55:19 <t7> oh i thought he meant inside a term
08:55:33 <dmwit> t7: You can do it inside a term, too.
08:55:38 <t7> > 1 + (1 :: Num a => a)
08:55:39 <lambdabot>   2
08:55:45 <dmwit> Anywhere you're allowed to put a type signature, you're allowed to put class constraints.
08:55:51 <mekeor`> :t 1 2 3
08:55:51 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
08:55:57 <t7> mind blown
08:56:13 <ClaudiusMaximus> :t (^)
08:56:14 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
08:56:17 <dmwit> (Note that the RHS of type aliases are not type signatures, so they're treated differently.)
08:57:21 <t7> what are they?
08:57:28 <dmwit> Give me a second to pull up the Report.
08:57:39 <dmwit> Anyway, they're a different syntactic class, I'm pretty sure.
08:58:55 <dmwit> Yeah, it's not really given a name in the report.
08:59:12 <t7> why is it different?
08:59:27 <t7> > 1 + (1 :: forall a. a)
08:59:27 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
08:59:28 <lambdabot>    arising from the li...
08:59:46 <t7> > 1 + (1 :: forall a. Num a => a)
08:59:47 <lambdabot>   2
08:59:49 <_mpu> So, any hints for a pretty printer library.?
09:00:07 <dmwit> t7: Because it doesn't have "context =>" in its productions, unlike all the other places where types appear. =)
09:00:21 <dmwit> e.g. gendecl -> vars :: [context =>] type
09:01:07 <parcs`> _mpu: wl-pprint-extras
09:01:40 <_mpu> ok, thanks.
09:01:51 <dmwit> likewise exp -> exp0 :: [context =>] type
09:02:51 <dmwit> Was that "why" a deeper "why"?
09:03:03 <dmwit> As in "Why did they choose to make it that way?"?
09:03:45 <t7> i dont understand the difference
09:04:01 <t7> apart from name declaration
09:04:48 <dzhus> Wouldn't it be nice if Haddock could generate a list of TODO items from annotations in comments? (Like Doxygen does)
09:05:44 <yasar> how can I get a char's ascii value?
09:05:53 <dmwit> :t ord
09:05:54 <mekeor`> yasar: toEnum
09:05:54 <lambdabot> Char -> Int
09:05:58 <dmwit> :t fromEnum
09:05:59 <lambdabot> forall a. (Enum a) => a -> Int
09:06:08 <dmwit> ?hoogle Char -> Int
09:06:08 <lambdabot> Data.Char digitToInt :: Char -> Int
09:06:08 <lambdabot> Data.Char ord :: Char -> Int
09:06:08 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
09:06:25 <mekeor`> :t toEnum
09:06:26 <lambdabot> forall a. (Enum a) => Int -> a
09:06:37 <ben> @src fromEnum :: Char -> Int
09:06:37 <lambdabot> Source not found. Maybe you made a typo?
09:06:39 <ben> :(
09:06:40 <mekeor`> i was wrong, dmwit was right.
09:06:48 <mekeor`> > fromEnum 'a'
09:06:48 <lambdabot>   97
09:07:15 <ben> how do I use hoogle to find a certain instance declaration?
09:07:17 <mekeor`> > ['a'..'z']
09:07:18 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
09:07:49 <t7> > digitToInt 'a'
09:07:49 <lambdabot>   10
09:08:00 <t7> > digitToInt 'z'
09:08:01 <lambdabot>   *Exception: Char.digitToInt: not a digit 'z'
09:08:04 <ben> I need to know which of ord or fromEnum is faster!!
09:08:12 <t7> wow...
09:08:38 <dmwit> ?src fromEnum Char
09:08:39 <lambdabot> Source not found. You type like i drive.
09:08:51 <dmwit> ben: I don't think Hoogle can do that right now. =/
09:09:06 <mekeor`> ben: ord IS fromEnum with 'Char -> Int' type declaration.
09:09:20 <mekeor`> see http://hackage.haskell.org/packages/archive/haskell98/latest/doc/html/Char.html#v:ord
09:09:25 <dmwit> mekeor`: *whoosh*
09:09:29 <dmwit> =)
09:09:55 <mekeor`> dmwit: *shoowh*
09:10:00 <mekeor`> =)
09:10:18 * dmwit cries in the corner
09:10:59 <ben> -- | The 'Prelude.fromEnum' method restricted to the type 'Data.Char.Char'.
09:10:59 <ben> ord :: Char -> Int
09:10:59 <ben> ord (C# c#) = I# (ord# c#)
09:11:15 <ben> That looks really fast to me, I'm sold. It has five of the make it go faster symbols!
09:11:41 <dmwit> Wow! We have embedded C# in Haskell.
09:11:47 <mekeor`> lol :D
09:11:50 <mekeor`> hahahha
09:11:52 <t7> if you want fast use javascript and V8
09:12:04 <quicksilver> ord#### (C# c#) = unsafeCoerce# c#
09:12:10 <quicksilver> more #s, faster!
09:13:10 <ben> Isn't ord basically unsafeCoerce too?
09:13:51 <ben> I guess it's really compiled out no matter how I call it then
09:14:11 <monochrom> maybe not if Char just occupies 32 bits and Int takes 64 bits
09:15:19 <parcs`> do foreignptrs get freed if the program quits abnormally due to eg an exception?
09:15:32 <parcs`> or rather do the finalizers run
09:21:09 <qued_____> Why this doesn't work? trying to build own Maybe-data type: http://pastebin.com/qF2cfcXw
09:21:53 <unlink> qued_____:   data Maybe2 t = Nothing2 | Just2 t  deriving (Show)
09:22:10 <unlink> qued_____: or add your own Show instances   instance Show Maybe2 where ...
09:23:21 <unlink> sorry instance Show a => Show (Maybe2 a) where
09:23:38 <monochrom> deriving (Show) is the easiest
09:24:47 <Mathnerd314> why doesn't GHC just derive Show automatically for all the datatypes it can?
09:24:55 <quicksilver> qued_____: well the important point is that it *does* work.
09:25:10 <quicksilver> qued_____: everything you did worked fine - it's only that ghci couldn't show the result.
09:28:14 <quicksilver> qued_____: well the important point is that it *does* work.
09:28:16 <quicksilver> qued_____: everything you did worked fine - it's only that ghci couldn't show the result.
09:28:31 <qued_____> unlink: sorry, my connection crashed ...
09:29:19 <qued_____> quicksilver: hm... okay. And for being displayable it has to derive from Show?
09:29:37 <quicksilver> right. but this isn't necessary to write programs using it
09:29:45 <qued_____> okay
09:29:46 <qued_____> ty
09:29:46 <quicksilver> just necessary if you want to inspect the results in ghci
09:29:59 <quicksilver> so the solution is to add "deriving (Show)" as unlink said
09:30:08 <quicksilver> but I just wanted to emphasise that you didn't have a bug, your code worked fine :)
09:32:27 <yasar> can I say my function would only apply to positive integral types when writing type signature?
09:34:17 <geekosaur> yasar: not without type level naturals
09:35:29 <tgeeky> edwardk: (\x -> pong)
09:36:05 <monochrom> a pong in a thunk? a lazy pong? :)
09:36:32 <tgeeky> monochrom: it's a tachyon!
09:36:54 <monochrom> higher-order pong continuations!
09:37:02 <tgeeky> giggles
09:37:26 * tgeeky is reading the S.Marlow / SPJ overview of GHC.
09:38:33 * tgeeky didn't realize that GHC and Core both had seperate type checkers. How brilliant!
09:39:10 <tgeeky> hm. that's not well worded.
09:43:46 <tgeeky> does anyone have an idea (or data) on what happens if you just haphazardly declare everything INLINABLE?
09:43:51 <Baughn> @hoogle [a] -> [b] -> [c] -> [(a,b,c)]
09:43:52 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
09:43:52 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
09:44:44 <Baughn> tgeeky: Your program gets much larger, leading to worse cache performance, and you can lose sharing
09:45:20 <Baughn> tgeeky: 'x = someSlowOperation'. If x is inlined..
09:45:38 <Baughn> That one's not an issue for functions, though.
09:45:40 <tgeeky> Baughn: yeah, I was hoping the distinction between actually inling and INLINABLE would do something smart
09:45:42 <Authoritarianism> Does ghci memoize recent results?
09:45:47 <Baughn> No.
09:45:57 <ClaudiusMaximus> Authoritarianism: it keeps the last value bound to 'it'
09:46:02 <Authoritarianism> Ah!
09:46:05 <tgeeky> Authoritarianism: it "memoizes" it by storing it
09:46:10 <tgeeky> damn. that didn't sound right either!
09:46:18 <nicmo> lol
09:46:24 <Baughn> it didn't sound right?
09:47:21 <Authoritarianism> I have created a prime number sieve, and it computes the 1000th, 10000th and 100000th prime in a reasonable amount of time, but it is taking very long to compute the 1000000th prime.
09:48:00 <Authoritarianism> I want to know if that is because the task is intrinsically difficult, or because I could optimize my sieve a little bit more.
09:48:11 <ClaudiusMaximus> are you using Int ? (could be an overflow bug somewhere?)
09:48:27 <Authoritarianism> ClaudiusMaximus: I am using Integer, not Int.
09:48:39 <ClaudiusMaximus> groovy
09:48:46 <Authoritarianism> Oh!
09:48:47 <Authoritarianism> It finished!
09:49:03 <Authoritarianism> And it computed it correctly! :D
09:51:35 <__ant__> depends on what algorithm you're using to find it
09:52:00 <user317> can anyone help me figure this out http://hpaste.org/65828
09:54:30 <magicman> :t runErrorT
09:54:31 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
09:54:55 <magicman> :t \aa -> return $ runErrorT aa
09:54:55 <lambdabot> forall (m :: * -> *) e (m1 :: * -> *) a. (Monad m) => ErrorT e m1 a -> m (m1 (Either e a))
09:55:03 <user317> yea, i follow that much, but i can pass things of type MonadError, MonadIO to it
09:56:17 <magicman> If you use runErrorT, you can only pass ErrorT values to it, not just any MonadError instance.
09:56:22 <quicksilver> user317: you can't "runErrorT" aa, because (aa :: y a) is not type ErrorT.
09:56:37 <hpc> :t either id . runErrorT
09:56:38 <lambdabot> forall b e a. ErrorT e ((->) b) a -> Either (Either e a) b -> Either e a
09:56:55 <hpc> :t either id runErrorT
09:56:55 <lambdabot> forall e (m :: * -> *) a. Either (m (Either e a)) (ErrorT e m a) -> m (Either e a)
09:57:10 <hpc> hmm
09:57:53 <hpc> :t either id
09:57:54 <lambdabot> forall a b. (b -> a) -> Either a b -> a
09:58:06 <edwardk> tgeeky: ping
09:59:11 <user317> hmm, ok, so whats the use of making that alias?  i basically want to combine a bunch of monad classes i have to type for every function
09:59:53 <quicksilver> user317: this isn't about your alias.
10:00:02 <quicksilver> user317: you're confusing "ErrorT" and "MonadError"
10:00:02 <magicman> The alias is fine.
10:00:11 <quicksilver> ErrorT is an actual, specific, type
10:00:18 <quicksilver> MonadError is a class with many instances.
10:00:28 <quicksilver> runErrorT runs on the specific type, not the class.
10:07:07 <nart> hi
10:07:33 <ben> so if I have, say, getContents, unwords . lines, and putStrLn, what cool operators are there so I can put them in one line in that order without too much noise?
10:09:44 <quicksilver> getContents >>= (unwords . lines) >>> putStrLn
10:09:55 <quicksilver> I'm not quite sure the precedence works between >>> and >>=
10:09:59 <quicksilver> might need more parens
10:10:08 <parcs`> interact (unwords . lines)
10:10:11 <quicksilver> :t getContents >>= (unwords . lines) >>> putStrLn
10:10:12 <lambdabot>     Precedence parsing error
10:10:12 <lambdabot>         cannot mix `>>=' [infixl 1] and `>>>' [infixr 1] in the same infix expression
10:10:13 <gnoi> JFYI: Hpaste didn't work
10:10:20 <quicksilver> :t getContents >>= ( (unwords . lines) >>> putStrLn )
10:10:21 <lambdabot> IO ()
10:10:31 <ClaudiusMaximus> parcs`: leads missing \n at end of output?
10:10:59 <nart> quicksilver: how would you write it with liftM ?
10:13:01 <quicksilver> nart: putStrLn =<< liftM (unwords . lines) getContents
10:13:19 <parcs`> interact ((++"\n") . unwords . lines)
10:14:00 <nart> quicksilver: why not liftM (putStrLn . unwords . lines) getContents ?
10:14:12 <nart> because putStrLn "returns" a Monad ?
10:14:15 <ben> Oh, for some reason I thought interact was doing things linewise. I guess that's better then.
10:14:16 <mokus_> @type putStrLn . unwords . lines =<< getContents
10:14:17 <lambdabot> IO ()
10:14:21 <parcs`> because the types don't match
10:14:22 <ben> But that's backwards!
10:15:06 <parcs`> interact (unwords . lines) <* putChar '\n'
10:15:30 <tgeeky> hm.
10:15:42 <quicksilver> :t liftM (putStrLn . unwords . lines) getContents
10:15:43 <lambdabot> IO (IO ())
10:15:47 <quicksilver> nart: ^^ see.
10:15:49 <tgeeky> @src FastString
10:15:50 <lambdabot> Source not found. Maybe you made a typo?
10:15:53 <quicksilver> that's not unusable.
10:15:57 <nart> quicksilver: got it
10:16:01 <quicksilver> you just need to execute it twice
10:16:05 <quicksilver> or use 'joni'
10:16:07 <quicksilver> 'join'
10:16:19 <quicksilver> ioact <- liftM (putStrLn . unwords . lines) getContents; ioact;
10:16:21 <quicksilver> or simply
10:16:24 <quicksilver> join $ liftM (putStrLn . unwords . lines) getContents
10:17:06 <parcs`> "simply"
10:17:06 <nart> @type putChar '\\n'
10:17:07 <lambdabot>     lexical error in string/character literal at character 'n'
10:17:19 <nart> @type putChar '\n'
10:17:20 <lambdabot> IO ()
10:18:40 <gwern> @quote
10:18:40 <lambdabot> syntaxglitch says: every time I have a cool idea about something that might work in Haskell, I go check Oleg's stuff and find that 1) he already did it 2) thought it out better 3) did it incidentally
10:18:40 <lambdabot> while working on something way more interesting
10:18:48 <nart> quicksilver: i asked because i kind of dislike the symbol >>=
10:18:59 <parcs`> man i really hate using preprocessors.. is there any way to have hsc2hs to calle
10:19:07 <parcs`> be called automatically by ghci?
10:19:48 <ben> Is there any way to combine ghc -e with loading more modules than the prelude?
10:20:39 <parcs`> good thing ghc 7.6 will remove most of the need for hsc2hs
10:21:13 <nart> @type (putStrLn . unwords . lines) <$> getContents
10:21:13 <lambdabot> IO (IO ())
10:22:02 <nart> @type join <$> (putStrLn . unwords . lines) <*> getContents
10:22:03 <lambdabot>     Couldn't match expected type `a -> a -> b'
10:22:03 <lambdabot>            against inferred type `IO ()'
10:22:03 <lambdabot>     In the first argument of `(.)', namely `putStrLn'
10:22:07 <nart> woops
10:22:09 <edwardk> class IsString a => WasString a where toString :: a -> String
10:28:13 <mekeor`> when should i (not) use GADTs, and when do i even have to use them?
10:28:46 <quicksilver> when you want the type of the value to give you (and the typechecker) information about what constructor has been chosen
10:28:54 <quicksilver> and, vice-versa on destruction
10:29:04 <quicksilver> the mere choice of constructor lets you refine the type of the variable.
10:29:20 <c_wraith> also, GADTs subsume existential types, if you want them to.
10:29:39 <quicksilver> yes although that's kind of a quirk of GHC rather than anything deep
10:29:53 <quicksilver> it just happens that the syntax GHC uses for GADTs permits existentials in a natural way.
10:29:56 <glguy> Do you mean that GADT syntax provides an alternate way to write existential types?
10:30:02 <c_wraith> glguy: yes
10:30:10 <mekeor`> ah
10:30:18 * quicksilver marks cross on diary. glguy spoke!
10:30:25 <c_wraith> data Foo where Foo :: a -> a -> Foo
10:30:29 <glguy> GADTs are for when you think "man, it'd be great if all these different types could be grouped together"
10:30:30 <c_wraith> that's an existential.
10:30:33 <c_wraith> A rather useless one.
10:30:53 <c_wraith> since all it gives you is a pair that you know are the same type, with no information on how to use the type
10:31:05 * mekeor` doesn't like existential types (as they seem to be quite senseless (mostly))…
10:31:15 <glguy> o.O
10:31:28 <c_wraith> They're sometimes valuable, but mostly they can be factored into laziness
10:32:43 <c_wraith> Or, in one case, factored into nested IO.
10:33:01 <c_wraith> I had an existential that contained an IO a, and an a -> IO ()
10:33:23 <quicksilver> existentials are a very natural part of the language and they are exactly what you need, when you need them.
10:33:24 <c_wraith> At some point, I realized that could be IO (IO ())
10:33:27 * mekeor` still doesn't understand the sentence "when you want the type of the value to give you (and the typechecker) information about what constructor has been chosen"…
10:34:39 <c_wraith> mekeor`: GADTs allow you to connect the exact type of an expression with the constructor it was made from.
10:34:41 <Philippa> quicksilver: surely CPS is all you need?!?!
10:34:50 <nart> @type join $ print <$> (return $ (unwords . lines) <*> x)
10:34:51 <lambdabot>     Couldn't match expected type `a -> b'
10:34:51 <lambdabot>            against inferred type `String'
10:34:51 <lambdabot>     In the first argument of `(.)', namely `unwords'
10:35:12 <nart> @type join $ print <$> ((return $ (unwords . lines)) <*> x)
10:35:13 <lambdabot>     Couldn't match expected type `IO String'
10:35:13 <lambdabot>            against inferred type `Expr'
10:35:13 <lambdabot>     In the second argument of `(<*>)', namely `x'
10:35:13 <c_wraith> mekeor`: data Foo a = Bar :: Foo Int | Baz :: Foo String
10:35:37 <nart> @t join $ print <$> ((return $ (unwords . lines)) <*> getContents)
10:35:38 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:35:54 <nart> @type  join $ print <$> ((return $ (unwords . lines)) <*> getContents)
10:35:55 <lambdabot> IO ()
10:35:55 <c_wraith> mekeor`: that data type sets up a bijection between type and constructor.  a Foo Int is always made with the bar constructor.  a Foo String is always made with the Baz constructor
10:36:05 <c_wraith> *Bar
10:36:13 <mekeor`> so, in GADTs, the type of constructor (say 'Con') of a data type (say 'Typ') needn't end with '-> Typ' ???   i mean, 'Con :: … -> Typ' isn't neccesserily true??
10:36:28 <c_wraith> mekeor`: look more closely
10:36:40 <c_wraith> mekeor`: both of those constructors have type signatures ending with Foo
10:36:48 <mekeor`> anyway, is it true what i said, or not?
10:36:52 <mekeor`> yea, okay.
10:36:54 <c_wraith> mekeor`: but they specify the type variable, rather than leaving it polymorphic
10:36:56 <parcs`> no, it's not true
10:36:56 <mekeor`> but …
10:37:04 <mekeor`> parcs`: good!
10:37:08 <quicksilver> Philippa: lennon and mccartney, right?
10:37:09 <mekeor`> that'd be holy crap
10:37:14 <parcs`> the result of the constrctor has to be Typ ...
10:37:28 <mekeor`> yea, that's absolute logical…
10:37:44 <nart> @type print <$ (return $ (unwords . lines)) *> x
10:37:45 <lambdabot>     Couldn't match expected type `m b' against inferred type `Expr'
10:37:45 <lambdabot>     In the second argument of `(*>)', namely `x'
10:37:45 <lambdabot>     In the expression: print <$ (return $ (unwords . lines)) *> x
10:37:53 <nart> @type print <$ (return $ (unwords . lines)) *> getContent
10:37:54 <lambdabot> Not in scope: `getContent'
10:38:13 <nart> however, is there a better way to write "return $ (unwords . lines))" ?
10:38:27 <mekeor`> c_wraith: wow, your example is great
10:38:48 <mekeor`> c_wraith: so, your example really works?
10:38:54 <mekeor`> that's cool!
10:39:00 <c_wraith> mekeor`: It's what GADTs exist for.
10:39:24 <jeff_s_> Anybody have an opinion about if the eclipse haskell plugin is worth using? Better than emacs?
10:39:36 <c_wraith> mekeor`: the ability for constructors to provide only certain types, in particular.
10:40:00 <mekeor`> c_wraith: great. thanks =)
10:41:12 <mekeor`> c_wraith: so, in consequence, GADTs don't really make sense in non-complex data types, right?
10:41:40 <mekeor`> i mean, it makes sense when defining something like functor, maybe and so on, but not Bool, Integer etc
10:41:44 <c_wraith> mekeor`: a GADT requires at least one type variable.  otherwise, it's a standard algebraic data type, but declared using GADT syntax
10:42:03 <mekeor`> c_wraith: i see. great. i got it =)
10:54:35 * hackagebot language-css 0.0.3 - CSS 2.1 syntax  http://hackage.haskell.org/package/language-css-0.0.3 (AntonKholomiov)
10:56:24 <dzhus> does overloading via typeclasses impose any overhead in runtime?
10:56:42 <c_wraith> dzhus: potentially
10:57:03 <c_wraith> dzhus: if it isn't specialized at compile time, it involves passing around a dictionary
10:57:51 <ClaudiusMaximus> dzhus: and sometimes it can't be specialized at compile time (eg: polymorphic recursion)
10:58:12 <dzhus> … but if it is, then nothing should differ from using type-specific functions?
10:58:48 <c_wraith> yeah, if it is specialized at compile time, it doesn't pass around the dictionary, instead just inserting the calls to the correct functions
11:02:08 <Authoritarianism> Do you think it is a good idea to use as few top-level declarations as possible, putting whatever one can in a let or where clause?
11:02:32 <ski> depends
11:02:59 <hpc> Authoritarianism: i prefer to keep as much out of 'where' clauses as possible unless i really need to close over something
11:03:02 <ski> for "helper" operations, it's usually good to put them into a `let' or `where'
11:03:08 <hpc> and even then, i usually just use partial application
11:03:12 <tauntaun> Authoritarianism: there's a tradeoff involving readability.
11:03:21 <ski> if you're debugging, it could help to temporary lift them out, though
11:03:31 <hpc> there's also sometimes a performance tradeoff, depending on a whole lot of other things
11:03:38 <ski> and sometimes "helper" operations are useful in their own
11:03:54 <tauntaun> hpc: can you say more?  A reasonable compiler should know better, no?
11:04:24 <hpc> let reallySlow = foo bar baz in f reallySlow reallySlow
11:04:26 <hpc> -- VS
11:04:43 <Authoritarianism> It seems to me that it is technically possible to not declare top-level functions that 1. will not be exported, 2. are not used internally in more than one place.
11:05:13 <hpc> let reallyHuge = foo bar baz in valueThatWillStickAroundAWhile
11:05:50 <hpc> tauntaun: it really depends on a lot, and im not really qualified to speak on it
11:05:53 <hpc> i just know it's there
11:06:40 <hpc> Authoritarianism: you can pull it off with just #1 if you use top-level tuple bindings
11:06:47 <hpc> but... ew
11:06:56 <Authoritarianism> :O
11:07:10 <hpc> let (exported, exported, ...) = (def1, def2, def3) where everythingNotExported
11:07:16 <tauntaun> hpc: thx.
11:07:17 <hpc> er, minus "let"
11:07:21 <ski> hpc : yeah, something like SML's `local <decls> in <decls> end' would be handy in Haskell ..
11:07:34 <Authoritarianism> hpc: That looks pretty badass.
11:07:44 <user317> quicksilver, sorry my connection died :),  so there is no way to write a function like foo :: (MonadIO m, MonadError String m, MonadIO y) => m a -> y (Either String a), really, i am just interested in saving some effort in typing (MonadError/MonadIO) everywhere
11:07:49 <Authoritarianism> Another question… How do I export a reusable module so that I do not have to explicitly :load it from ghci all the time?
11:07:54 <hpc> Authoritarianism: it's even more syntactic overhead than export lists, and ridiculous to boot
11:08:28 <hpc> module Foo (foo, module Baz) where
11:08:31 <hpc> import Baz
11:08:33 <c_wraith> user317: that's possible with the ConstraintKinds extension in ghc 7.4.  Don't know if it'll actually be that helpful to you
11:08:33 <hpc> foo = 15
11:09:15 <Authoritarianism> hpc: No, no… I mean, I downloaded some packages using cabal, and I do not have to :load anything to use those modules.
11:09:19 <user317> ok, i think i got it, foo :: (MonadIO m) => ErrorT String m a -> m (Either String a)  is what i want, makes sens
11:09:24 <user317> thanks everyone
11:09:25 <hpc> Authoritarianism: oh
11:09:26 <Authoritarianism> hpc: But if I want to use my own modules, I have to :load the source files.
11:09:44 <ski> hpc : like `local hiddenA = ..hiddenA..hiddenB..; hiddenB = ..hiddenA..hiddenB.. in visibleA = ..hiddenA..hiddenB..visibleA..visibleB..; visibleB = ..hiddenA..hiddenB..visibleA..visibleB..'
11:10:02 <hpc> Authoritarianism: how are you using those modules?
11:10:04 <user317> so, when i actually want to run that error, i have to define the instance for that monaderror class
11:10:13 <hpc> (the cabal ones)
11:10:23 <Authoritarianism> hpc: I am importing them from my own module.
11:10:26 <user317> otherwise there is no way for it to know which implementation to use
11:10:50 <hpc> ah, so like
11:10:56 <hpc> $ ghci Foo.hs
11:11:03 <hpc> Foo imports Data.List and Baz
11:11:09 <hpc> and now you have Data.List but not Baz?
11:11:31 <Authoritarianism> hpc: Yep, that would be an example.
11:11:54 <hpc> lemme experiment and get back to you
11:12:52 <hpc> Authoritarianism: that's strange; it works for me
11:13:15 <ClaudiusMaximus> perhaps it makes a difference if Foo.o exists?
11:13:30 <hpc> (this is with neither file compiled)
11:13:33 <Authoritarianism> hpc: I want to be able to just open ghci, without any command line parameters, and use my modules, just as I can open ghci, without any command line parameters, and use cabal packages?
11:13:43 <Authoritarianism> s/?/./
11:13:48 <hpc> ah
11:13:52 <hpc> i use "import"
11:14:09 <hpc> $ ghci
11:14:18 <hpc> λ> import Foo
11:14:21 <hpc> -- voila!
11:15:17 <Authoritarianism> Let me try.
11:16:02 <Authoritarianism> "Could not find module 'Primes': it is not a module in the current program, or in any known package."
11:16:16 <hpc> hmm
11:16:47 <Authoritarianism> I even loaded ghci while having my program's directory as the current directory.
11:18:31 <tgeeky_> Authoritarianism: so there's this weird middle ground that happens before turning a project into a cabal package (and installing it), and using it with ghci
11:19:32 <tgeeky_> Authoritarianism: can you hpaste your working directory contents (ie, ls -l)
11:19:44 <luite_> is there an easy way to prettyprint a HsWrapper as something that looks like a type constraint in haskell?
11:19:54 <Authoritarianism> tgeeky_: It contains a single file primes.hs.
11:19:55 <hpc> perhaps you have to :m+ it first?
11:19:59 <hpc> :m+ Foo
11:20:11 <hpc> (maybe :load Foo afterwards)
11:20:23 <Authoritarianism> Wait, how do I turn my project into a cabal package?
11:20:24 <hpc> Authoritarianism: oh, is that the capitalization
11:20:29 <hpc> "primes.hs"?
11:20:36 <Authoritarianism> hpc: Yep.
11:20:39 <mekeor`> Authoritarianism: stupid question, but do you have a line "moduel Primes where" in your sourc code?
11:20:41 <hpc> capitalize it
11:20:44 <hpc> "Primes.hs"
11:20:48 <Authoritarianism> mekeor`: Yep.
11:21:14 <tgeeky_> Authoritarianism: hpc's suggestion should fix it, then
11:21:40 <Authoritarianism> hpc: "attempting to use module Primes (./Primes.hs), which is not loaded"
11:21:56 <tgeeky_> luite_: hmmmmmm. easy?
11:22:17 <hpc> Authoritarianism: you used :m+? i think with it capitalized :load should work now
11:22:36 <tgeeky_> Authoritarianism: ah! That kind of error is the one I'm talking about! :)
11:22:42 <Authoritarianism> hpc: Is there any way I could turn my project into a cabal package so I do not have to use :m+?
11:23:03 <tgeeky_> hpc: ghci Primes
11:23:10 <tgeeky_> erp!
11:23:13 <tgeeky_> Authoritarianism: ghci Primes
11:23:53 <tgeeky_> luite_: -> #diagrams
11:24:14 <Authoritarianism> tgeeky_: If I eventually develop, say, 25 modules, I would not like to have to load them explicitly from the command line.
11:24:44 <tgeeky_> Authoritarianism: no, and you won't have to. If they are named right, you can run any one of them (if you *stay* in the top-level directory) such as
11:24:47 <alpounet> cabal-dev ghci?
11:24:49 <alpounet> smth like that
11:24:52 <hpc> when you 'ghci <foo>' it will also load the imports of foo
11:24:57 <tgeeky_> ghci PrimeSieves/Prime1
11:25:01 <Authoritarianism> Oh.
11:25:06 <hpc> so 'ghci Primes.hs' should work fine
11:25:12 <hpc> or whatever other modules
11:25:17 <tgeeky_> hpc: I don't think you need the .hs, but I'm not certain
11:25:35 <hpc> ive never run it without, because tab-complete is so easy
11:32:28 <led_nottingham> hi all
11:33:37 <ski> lo
11:34:54 <led_nottingham> so, i have a question for the masses:
11:35:23 <Authoritarianism> Is there any way to time my programs?
11:35:41 <geekosaur> Authoritarianism, look for the criterion package
11:35:52 <Authoritarianism> geekosaur: Okay, thanks.
11:41:05 <DMcGill> led_nottingham: ?
11:42:56 <eacameron> "Real World Haskell" recommends that I use mini-http, which is deprecated. What's the best HTTP client lib to use?
11:44:10 <hpc> http://hackage.haskell.org/package/HTTP
11:44:23 <hpc> might not be the best; hoogle seems to say there's lots of variety to pick from
11:44:26 <hpc> http://www.haskell.org/hoogle/?hoogle=http
11:44:32 <parcs`> http-conduit
11:44:32 <c_wraith> Ugh.  I wouldn't use HTTP
11:45:04 <c_wraith> http-conduit is probably the best at the moment.  Not segfaulty like curl, and Snoyman responds to bug reports pretty quickly.
11:45:20 <timthelion> how am I supposed to debug $ ./gridPrecompiler -i examplegrid.grid -o examplegrid.hs
11:45:27 <eacameron> yeah...if yesod uses it, I image it's pretty stable
11:45:31 <timthelion> gridPrecompiler: No match in record selector next
11:45:52 <hpc> search the .grid file for "next"?
11:46:10 * hpc doesn't know what gridPrecompiler is
11:46:19 <timthelion> hpc: is that a read error?
11:46:31 <timthelion> gridPrecompiler is my haskell program
11:46:36 <hpc> oh
11:46:43 <eacameron> hpc: how do you do that ***hpc doesn't know thing? I'm new to IRC
11:46:58 <c_wraith> eacameron: start your message with /me
11:47:09 * timthelion uses the /me tag :)
11:47:16 * eacameron is excited about this cool me thing
11:47:27 <hpc> /me is a showoff
11:47:28 <eacameron> c_wraith: timthelion: nice!
11:48:34 <ClaudiusMaximus> timthelion: i think that means you have data Foo = Bar{ next :: ... } | Baz{ no_next_here :: .. }  and try to   next Baz{ ... }
11:49:12 <hpc> or define a value Baz {next = ...}
11:49:24 <timthelion> ClaudiusMaximus: I'm pretty sure you're right, but I have such next tags across about 7 modules :(
11:52:01 <singpolyma> If I'm importing from another module a datatype that could have done deriving Enum, but didn't, can I do that for it in my module?
11:52:53 <ClaudiusMaximus> hpc: that case is either a compile error (Baz{ next = ... }) or a different exception (\a -> a{ next = ... }) Baz{ ... }
11:53:13 <ChristianS> singpolyma: i don't think so.
11:53:40 <singpolyma> ChristianS: hmm, ok
11:53:41 <ClaudiusMaximus> singpolyma: yes, -XStandaloneDeriving, deriving instance Enum T
11:53:54 <singpolyma> ClaudiusMaximus: ok.  so, I can, but only with an extension?
11:54:21 <timthelion> how come there is now cmdargs-prof in cabal?
11:54:53 <geekosaur> singpolyma, you can always do it by hand, instance Enum whatever where ...
11:55:00 <timthelion> I thought maybe it would give me a line number if I compiled with profiling, but it tells me that if I use CmdArgs I cannot compile with profiling...
11:55:43 <singpolyma> geekosaur: right
11:56:34 <hpc> ClaudiusMaximus: it would be, if it appeared in a compiled file
11:56:40 <hpc> ClaudiusMaximus: this is a read'd string
11:56:50 <hpc> coming from foo.grid
11:56:56 <ChristianS> timthelion: you have to install profiling versions of all they libs you are using
11:57:08 <hpc> i think it's a read error
11:57:25 <timthelion> ChristianS: Is there any other reasonable way?
11:57:55 <ChristianS> timthelion: no, but it that a problem?
11:58:00 <ChristianS> is*
11:58:07 <timthelion> Only in that I don't know how ;)
11:58:44 <hpc> timthelion: cabal configure --help
11:58:51 <hpc> or runghc Setup.hs configure --help
11:59:10 <hpc> look for a profiling option, then go through the regular install steps with that flag set
12:00:42 <timthelion> why is cabal so slow :( :(.
12:01:24 <eacameron> timthelion: slow at what? ;)
12:01:55 <timthelion> when you type cabal configure or cabal install it takes several seconds just to decide if the package exists or not.
12:02:46 <timthelion> pacman which handles several times the number of packages searches it's database almost instantly.
12:03:00 <c_wraith> searching isn't the slow part.
12:03:11 <c_wraith> resolving compatible dependency sets is the slow part
12:03:16 <eacameron> timthelion: cabal is lazy...
12:03:47 <eacameron> everytime I work with haskell I feel dumber and dumber: I don't understand liftIO...
12:04:08 <timthelion> c_wraith: will it improve?
12:04:19 <alpounet> there's another solver actually, IIRC
12:05:42 <aristid> :t liftIO
12:05:43 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:06:00 <eacameron> aristid: that's just the problem
12:06:07 <hpc> eacameron: you're writing a website
12:06:15 <hpc> eacameron: you have your super-way-rad-awesome-monad
12:06:15 <aristid> eacameron: liftIO isn't that hard to use :)
12:06:37 <hpc> it holds a database handle, some form stuff, and cookies
12:06:42 <hpc> and it prints html to stdout
12:06:55 <aristid> hpc: hmm, isn't that example kind of complex? :)
12:07:02 <hpc> suddenly you realize you need your script needs to do some other IO
12:07:08 <hpc> so you write an IO action that does it
12:07:20 <aristid> BUT HOW TO PUT IT IN THE AWESOME MONAD OMG
12:07:21 <hpc> but wait, how do you run it in super-way-rad-awesome-monad?
12:07:25 <c_wraith> timthelion: well, doing solving "right" is potentially exponential-time. No way around that. Though the new (in progress) solver is supposed to be cleverer about making good guesses to find a solution fast. Ultimately, it's not a problem cabal was ever meant to solve
12:07:27 <hpc> liftIO thatAction
12:07:56 <eacameron> ahh I think I understand
12:08:10 <hpc> timthelion: i assume pacman solves it by having the depends calculated by the server
12:08:13 <eacameron> you're running another monad from within your monad?
12:08:30 <hpc> you're running IO within your monad
12:08:48 <hpc> which... is another monad :P
12:08:49 <nart> @source liftIO
12:08:49 <lambdabot> liftIO not available
12:08:51 <hpc> so yes
12:09:00 <eacameron> does your monad have to be an IO monad ??
12:09:13 <c_wraith> nart: liftIO is a typeclass function.
12:09:20 <nart> yep i just saw eheh
12:09:26 <hpc> eacameron: that's where (MonadIO m) comes in
12:09:27 <timthelion> hpc: Well pacman has both a "depends on" and "required by" depends are done recursively and therefore do not need to be resolved.  Required by is done by the server.
12:10:09 <hpc> ah yeah, also pacman doesn't have many versions of their packages
12:10:10 <eacameron> hpc: the analogy helped, but this MonadIO you speak of ... I will have to read more
12:10:15 <c_wraith> The real problem is exponential combinations.  And the fact that many packages on hackage are released frequently
12:10:53 <hpc> eacameron: if your awesome monad didn't have to do IO, it might look something like
12:11:05 <c_wraith> eacameron: MonadIO is just an interface for "this thing can do IO.  it provides a function named liftIO that turns an IO action into an action for this type"
12:11:05 <hpc> type Awesome = Reader HTTPEnv
12:11:15 <hpc> eacameron: now it has to do IO, so it looks like
12:11:20 <parcs`> timthelion: darcs cabal-install is much faster at resolving deps, like 5x faster
12:11:23 <hpc> type Awesome = ReaderT HTTPEnv IO
12:11:47 <hpc> there's an instance for MonadIO for that
12:12:00 <hpc> or specifically, for (ReaderT whatever IO)
12:12:34 <hpc> and that's how the compiler knows your monad can do IO
12:12:58 <eacameron> the mist is clearing...
12:13:01 <eacameron> ;)
12:13:15 <hpc> eacameron: try writing "instance MonadIO IO where liftIO action = ?"
12:13:21 <hpc> eacameron: it should be a piece of cake ;)
12:14:07 <hpc> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/src/Control-Monad-IO-Class.html#MonadIO -- the answer is here, conveniently right next to the definition of the class that i wanted to link to
12:14:30 <aristid> eacameron: let's say you have a custom monad for which you want MonadIO, like newtype MyMonad a = M (Int -> IO a): for this, you can define liftIO as such: liftIO action = M (\anything -> action)
12:14:54 <aristid> (MyMonad is really just ReaderT Int, but that's just an example anyways)
12:15:52 <eacameron> aristid: hpc: much better...I'm gonna mull over these profound examples...I'll let you know when the Eurika moment hits
12:15:53 <hpaste> timthelion pasted “Well I don't seem to be able to build with profiling.” at http://hpaste.org/65833
12:17:03 <timthelion> why does it error 1?
12:25:52 <hiptobecubic> Still not getting lambdabot+djinn to work. Does anyone else have it running locally with success?
12:25:53 <lambdabot> hiptobecubic: You have 1 new message. '/msg lambdabot @messages' to read it.
12:28:38 <hpc> hiptobecubic: see msg :P
12:28:52 <hpc> you left before i could tell you the other day
12:34:39 <timthelion> No ideas as to why that cabal install command is failing?
12:35:30 <hiptobecubic> hpc, lol. great
12:36:14 <hpc> hiptobecubic: my guess is that old versions of djinn print the type signature
12:41:31 <hiptobecubic> hpc, so does the current ont
12:41:32 <hiptobecubic> one*
12:41:47 <hiptobecubic> @src [] <$>
12:41:47 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:41:59 <hiptobecubic> @src Data.List <$>
12:41:59 <lambdabot> Source not found. Maybe you made a typo?
12:42:07 <monochrom> not rocket scientist, just software engineer :)
12:42:40 <timthelion> lambdabot is so insulting :D
12:43:37 <timthelion> @src src
12:43:38 <lambdabot> Source not found. Take a stress pill and think things over.
12:43:48 <timthelion> @src concatMap
12:43:48 <lambdabot> concatMap f = foldr ((++) . f) []
12:44:46 * hackagebot lzma-conduit 0.1.2.2 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-0.1.2.2 (NathanHowell)
12:45:15 <hiptobecubic> wouldn't it be better to use (:) instead of (++) and then reverse at the end?
12:45:24 <hiptobecubic> Oh.. i guess we want to preserve the laziness
12:45:49 <c_wraith> also, ++ fuses
12:51:44 <acowley> Has anyone produced an attempt at a canonical restricted monad class using ConstraintKinds? It's awesome how well everything works with that.
12:52:34 <c_wraith> acowley: it suffers from the problem of being easy to do, but useless unless everyone switches to it.
12:53:27 <acowley> c_wraith: Yeah, that's why I'd like to throw my weight behind whatever nascent efforts are already underway. I figure every line of code helps.
12:54:04 <c_wraith> acowley: also, somewhat useless if it isn't supported by do notation.  And while the rebindable syntax extension works for that, it's still sort of a mess
12:54:29 <acowley> c_wraith: RebindableSyntax seems to work great for me, where does it break down?
12:54:46 * hackagebot biopsl 0.3 - Library and executables for working with PSL files  http://hackage.haskell.org/package/biopsl-0.3 (KetilMalde)
12:55:40 <c_wraith> acowley: Well, how do you distinguish between do blocks for instances of existing monad, and a restricted monad?  The only tools for doing that are type classes, and they don't really work there either.
12:56:51 <c_wraith> acowley: because you end up with all kinds of overlapping instances
12:57:03 <c_wraith> acowley: unless I'm missing a terrific trick
12:57:06 <acowley> c_wraith: I note the modest proviso that you rewrite all your Monad instances :P It's fine for the moment, and I still think there's a place for a slightly updated Prelude that just has this kind of change
12:57:24 <c_wraith> "advanced type Prelude" :)
12:57:27 <acowley> c_wraith: I mean to say, "it's fine for my own code for the moment"
12:57:50 <acowley> c_wraith: the problem that I see is that every attempt to advance the Prelude causes people to advocate their own riders, and then the whole thing collapses under its own weight
12:57:59 <acowley> c_wraith: it's like Congress
13:00:50 <c_wraith> Also, has anyone developed a sane class for list-like functionality that works with types that don't necessarily have the kind * -> * ?
13:01:08 <c_wraith> I'm sure the tools to do that must exist by now.
13:02:47 <danharaj> There is a need for a textbook on the type extensions of GHC.
13:03:02 <danharaj> Especially since in the last few versions a few enormously useful ones came out.
13:04:14 <c_wraith> I feel like PolyKinds has some bugs still, but once those are worked out, it will enable some crazy new type-level trickery
13:04:30 <danharaj> or the same old type-level trickery in a more uniform and sane way :3
13:04:56 <Saizan> @quote millioleg
13:04:56 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
13:04:58 <acowley> where is the Functor instance for Either defined?
13:05:05 <danharaj> @src Either
13:05:05 <lambdabot> Source not found. Take a stress pill and think things over.
13:05:07 <Saizan> @quote mere.*oleg
13:05:07 <lambdabot> No quotes match. Just try something else.
13:05:10 <Saizan> meh
13:05:34 <danharaj> Datakinds lets you define your own class of kinds right?
13:05:49 <danharaj> (I am not sure what to call the thing that ranges over kinds)
13:06:12 <geekosaur> sorts?
13:06:18 <Saizan> danharaj: if old type-hackery becomes sane, then with the same level of insanity we will be able to afford even more crazy type-hackery
13:07:10 <Saizan> i'd say it let you define a new kind
13:07:20 <acowley> Yeah
13:07:28 <acowley> it's just new kinds other than * or * -> *
13:07:46 <acowley> (or whatever other wacky things GHC uses to represent strictness or whathaveyou)
13:08:14 <hiptobecubic> @ft
13:08:15 <lambdabot> Done.
13:08:16 <monochrom> rumour: SPJ will write a thick book "A New Science of Kind"
13:08:23 <hiptobecubic> What does that one do?
13:08:54 <danharaj> ah yes, new kinds.
13:09:09 <sclv> @remember monochrom rumour: SPJ will write a thick book "A New Science of Kind"
13:09:10 <lambdabot> Okay.
13:09:38 <daniel31415> @botsnack
13:09:38 <lambdabot> :)
13:09:47 <hiptobecubic> @yhjulwwiefzojcbxybbruweejw
13:09:48 <lambdabot> "\"#$%&'()*+,\""
13:11:30 <dino-> Amazing stuff
13:11:45 <dino-> heh, wrong ch my friends
13:12:04 <dino-> But Haskell is Amazing Stuff. So it works.
13:12:24 <olsner> @quote milli-Olegs
13:12:24 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
13:12:32 <olsner> Saizan: was that the quote you were looking for?
13:12:32 <timthelion> @src minimum
13:12:32 <lambdabot> minimum [] = undefined
13:12:33 <lambdabot> minimum xs = foldl1 min xs
13:14:10 <hiptobecubic> not foldl1' ?
13:14:12 <sclv> new kinds are the best: https://www.youtube.com/watch?v=4jKTwnxyHlo
13:14:39 <hiptobecubic> Also, i feel like lambdabot would make 85% of what you want in an IDE if it could be properly tamed
13:15:07 <hiptobecubic> @vixen
13:15:07 <lambdabot> The press is the enemy.
13:15:12 <hiptobecubic> See?
13:15:45 <fads> what are <$> and <*> for?
13:16:05 <luite_> hmm, lambdabot doesn't have many IDE-like features
13:17:18 <tgeeky_> luite_: IRC doesn't have many IDE-like features
13:17:57 <koeien> fads: applicative
13:17:58 <c_wraith> IRC would be better with code-folding
13:18:03 <koeien> fads: <$> = fmap
13:18:26 <koeien> fads: <$> :: Functor f => (a -> b) -> f a -> f b
13:18:37 <koeien> it applies a function inside a "container"
13:18:53 <koeien> <*> :: Applicative f => f (a -> b) -> f a -> f b
13:18:58 <luite_> tgeeky_: true, but I think the state of haskell IDE's is pretty disappointing in general. Maybe EclipseFP is better, haven't tried it yet
13:19:02 <koeien> it applies a function inside a container to a value in a container
13:20:02 <Saizan> olsner: yep!
13:28:34 <acowley> c_wraith: working with these ConstraintKind-enabled restricted functors… would one potentially want to have different constraints for a type in its Functor instance and its Applicative instance, for example?
13:28:48 <acowley> err, that was directed at #haskell rather than c_wraith in particular
13:33:57 <Philippa> acowley: I suspect there isn't a sensible reason to do that rather than newtype, BICBW
13:34:38 <tazjin> Is there something like github for darcs?
13:35:35 <acowley> Philippa: I will probably just give Functors contexts and add a comment "PSIWO" (Philippa Said It Was OK). I have a similar comment elsewhere in my codebase for edwardk :)
13:36:05 <edwardk> acowley: ?
13:36:28 <acowley> edwardk: sorry, didn't mean to trigger an alert!
13:36:38 <luite_> tazjin: there's darcsden and patch-tag, but neither is quite as good
13:37:00 <edwardk> acowley: i have a polymorphic kind category/functor class with constraints, but sadly until we can write the kind annotations for polykinds i'm not ready to bundle it
13:37:17 <tazjin> luite_: I'm not interested in all those fancy social features, do you know whether either of those has acceptable speed from Europe?
13:37:41 <Philippa> acowley: I guess I'm flattered?
13:38:21 <elkalel> Good evening everybody! I am trying to get familiar with haskell, but I can't get a simple function to compile.
13:38:50 <elkalel> say I am trying to compile a function that adds 1 to a number x, wouldn't this do:
13:38:52 <luite_> tazjin: don't know, sorry, both websites feel fast enough from here (netherlands)
13:39:04 <elkalel> let p = 2 in add p = p +1 ?
13:39:24 <elkalel> of course with a new line after the 2
13:39:32 <rasfar> elkalel, if you're compiling: did you put it in a module called Main.hs?
13:39:43 <Philippa> elkalel: nope, let doesn't scope like that
13:39:50 <acowley> edwardk: what kind of annotation is it you want to write?
13:39:51 <rasfar> add p = let p=2 in p+1
13:39:51 <Senmorta> succ 1
13:40:14 <rasfar> (which would ignore the parameter p)
13:40:15 <Philippa> rasfar: that, and the p on the LHS looks redundant, yeah
13:40:19 <Philippa> snap!
13:40:26 <rasfar> heehee
13:40:38 <elkalel> rasfar: I see, it seems like I got it all wrong there.
13:40:49 <rasfar> luite_: sorry i missed 30% of your comments yesterday, it was a bit of a scramble but good fun! :)
13:40:57 <Elemir> @seen jtootf
13:40:58 <lambdabot> Unknown command, try @list
13:40:59 <tazjin> luite_: Alright, I'll try them (in case I manage to install darcs with 7.2)
13:41:06 <elkalel> to be honest, I was trying something like this, but couldn't get it to work: add p = p +1
13:41:31 <rasfar> elkalel: you might be happier using ghci (interactive system) for the time being.
13:41:42 <luite_> rasfar: hehe no prob, I hope you can use the code. I got some of the SYB AST transformations working already in my code
13:41:48 <Elemir> preflex: seen jtootf
13:41:48 <preflex>  jtootf was last seen on #haskell 32 days, 6 hours, 43 minutes and 58 seconds ago, saying: have anyone worked with the Data.Array.Accelerate?
13:42:27 <rasfar> i'm just debating whether to continue using haskell-src-exts in my big project, or try to go with the ghc AST's
13:42:28 <elkalel> rasfar: Hehehe, maybe you are right, thanks for your help.
13:44:23 <luite_> rasfar: I'm restructuring a bit to remove some haskell-src-exts things :)
13:45:27 <rasfar> sorry to hear the HSE person is unresponsive.  it's a shame that that package, which works really well as far as it goes, was not adopted by GHC (or vise versa if that's how the timeline went)
13:45:48 <luite_> oh I did get a reply
13:45:52 <luite_> this morning
13:46:02 <rasfar> oh yeah? i'm glad
13:46:03 <luite_> he will release one with the new kind syntax soon
13:46:18 <rasfar> i should see if he wants help
13:46:20 <luite_> but the prettyprinter bug won't be fixed
13:46:27 <luite_> at least, it's in the todo list, but nontrivial
13:47:06 <rasfar> is that the bug you mentioned where {-#LANGUAGE Blah #-} ---> {-# LANGUAGEBlah #-} ?
13:47:31 <luite_> yeah
13:47:36 <hpc> o.O
13:47:43 <hpc> how is that a non-trivial bug?
13:47:46 <rasfar> I was quite impressed with the pretty printing.  with Annotated, it really does preserve layout 100% in the tests I did.
13:48:20 <rasfar> (comments seem to just be collected in a list though)
13:48:23 <luite_> hpc: I think it would require some modification of the types to store the position of the pragma
13:49:06 <hpc> ah
13:49:39 <luite_> a simple fix would be to always print the pragma without any space between the #
13:49:53 <luite_> at least it wouldn't break output then :)
13:49:56 <rasfar> i've been superstitious about observing the space in "{-# LAN..." so never noticed.
14:00:07 <adit> I'm really surprised that ctags doesn't support Haskell
14:00:39 <adit> gasbag / hasktags should be merged into ctags
14:01:56 <edwardk> acowley: class Category (k :: a -> a -> *)
14:02:41 <danharaj> a in that case would be a kind variable right?
14:03:00 <danharaj> I feel like there should be a convention like type variables are latin alphabet and kind variables are greek ;)
14:03:12 <acowley> edwardk: ah. You can write a datakind explicitly, but not a polykind variable other than *?
14:03:44 <edwardk> acowley: class (Category (Dom f), Category (Cod f)) => Functor (f :: a -> b) where type Dom f :: a -> a -> *; type Cod f :: b -> b -> *; fmap :: Dom f x y -> Cod f (f x) (f y)
14:03:57 <acowley> danharaj: the old solution of "Kinds are written "*"" was at least concise!
14:04:13 <edwardk> that much you can kind of fake by other means, but it blows up when you want a constraint on the argument for the kind in the category
14:04:24 <edwardk> e.g.
14:05:24 <edwardk> class Category (k :: a -> a -> *) where type Ob k :: a -> Constraint; id :: Ob k a => k a a; (.) :: (Ob k a, Ob k b, Ob k c) => k b c -> k a b -> k a c
14:05:40 <edwardk> that blows up because we can't write the polykind argument
14:05:45 <edwardk> but we can fake it with an MPTC
14:06:18 <edwardk> class Category k ob | k -> ob where id :: ob a => k a a; (.) :: (ob a, ob b, ob c) => k b c -> k a b -> k a c
14:06:36 <edwardk> but we can never get that arg out of the MPTC, which gets in the way of certain categorical constructions
14:06:56 <edwardk> ultimately when they get around to adding a syntax for writing polymorphic kinds we'll be able to make much nicer categories
14:07:17 <nart> what's a kind ?
14:07:22 <tgeeky_> lol
14:07:24 <edwardk> nart: the types of types
14:07:30 <acowley> it's a kind of type
14:07:35 <edwardk> Int :: *.
14:07:41 * acowley gives himself a rim shot
14:07:45 <edwardk> but Maybe :: * -> *
14:07:59 <edwardk> * is the 'kind' of polymorphic types that have terms inhabiting them
14:08:05 <edwardk> and which are boxed, etc.
14:08:17 <edwardk> # is the kind of unboxed types, like machine ints, etc.
14:08:41 <adit> nart: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
14:08:47 <edwardk> there are other kinds, like under the new ghc, the kind of Eq is * -> Constraint
14:08:48 <adit> search for "kinds and some type-foo"
14:09:06 <acowley> and * -> * is the kind of type constructors, like Maybe
14:09:08 <edwardk> and types of kind constraint can appear on the left hand side of the double arrow =>
14:09:15 <edwardk> :k Either
14:09:16 <lambdabot> * -> * -> *
14:09:44 <edwardk> a recent extension allowed us to make up new kinds as well
14:09:53 <edwardk> which is pretty nifty
14:09:55 <nart> adit: i'll read it, edwardk: thanks for the explanation
14:10:13 <nart> that seems cool
14:10:22 <edwardk> nart: basically the existence of kinds is what keeps you from talking about nonsensical types like 'Maybe Maybe'
14:10:32 <edwardk> its a very simple type system in its own right
14:11:19 <ion> (Maybe . Maybe)
14:12:52 <rasfar> "Maybe Babey" (Buddy Holly anyone?)
14:13:17 <nart> so, what "kind" of the new kind is it possibile to create ?
14:13:48 <ksf> type Showy a = (Read a, Show a)
14:13:50 <ksf> for example.
14:14:13 <ksf> in addition to constraint, any ADT you can think of.
14:14:16 <acowley> that synonym should be called Literate
14:14:23 <ksf> e.g. data Nat = Zero | Succ Nat
14:14:26 <danharaj> heh
14:14:32 <tgeeky_> acowley: no!
14:14:33 <timthelion> is it reasonable to run two versions of GHC so packages like SourceGraph can be installed?
14:14:35 <edwardk> nart: well, with DataKinds you can say something like data Nat = Z | S Nat and use that definition at the kind level (for a kind Nat, which is inhabited by the types Z :: Nat and S :: Nat -> Nat
14:14:39 <nart> ADT ? xD
14:14:50 * hackagebot unbound 0.4.0.1 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.4.0.1 (BrentYorgey)
14:14:58 <ksf> ...and then do tail :: Vec a (Succ n) -> Vec a n
14:15:11 <edwardk> nart: then you could make data Vector :: Nat -> * -> * where
14:15:14 <ksf> nart, abstract data type, one of those data declaration thingy.
14:15:36 <c_wraith> ksf: algebraic
14:15:40 <acowley> different adt
14:15:41 <ksf> yes.
14:15:48 <edwardk> until now you just had to let the kind of that argument be *, so you had to deal with the fact that the end user might supply you _any_ type in that position
14:16:00 <rasfar> timthelion, i'm running 3 versions and it does lead to fragmentation of installed libs, but you can do it
14:16:15 <edwardk> Vector Blargh Int might not have any instances, but you wouldn't know
14:16:31 <timthelion> rasfar: fragmentation?
14:16:49 <danharaj> So the real question is when will you make a package for homological algebra, edwardk? ;)
14:17:00 <edwardk> danharaj: probably =P
14:17:03 <rasfar> timthelion, you only need to change your $PATH (or equivalent) to switch between
14:17:04 <edwardk> oh when
14:17:06 <edwardk> not sure
14:17:31 <nart> humm
14:17:36 <edwardk> right now i'm currently obsessing about how to cover complicated metropolis-hastings-style sampling techniques
14:17:44 <rasfar> fragmentation in the sense that cabal install will install the package for the version of platform that's first in your path at the time
14:17:53 <rasfar> but not in any of the other platforms
14:18:08 <timthelion> rasfar: thanks.  It sounds like a lot of work, jus to use some out of date packages.  Hopefully once ghc 7.4.1 has been out for a while the situation will improve.  Now a majority of major packages don't install.
14:19:06 <timthelion> ah, OK, that seems managable
14:19:14 <rasfar> i see, okay that's your situation.  it's not so much a lot of work, as it's easy to forget to twiddle your path
14:19:42 <rasfar> i don't use 7.4.1 much (mostly 7.0.4) so i hadn't noticed that issue with the older packages
14:19:44 <dzhus> is it alright to call a module SexParser instead of SexpParser to avoid p cancer?
14:20:06 <mauke> SexpArser
14:20:15 <mightybyte> Hacker News Programming Language Poll: http://news.ycombinator.com/item?id=3746692
14:20:31 <timthelion> rasfar: yeah, the Arch devs think that version number change means stable release, and like to keep everything up to date.  The haskell devs seem to think that version numbers change every time someone adds a new langauge extention :D
14:20:37 <mightybyte> There are 900+ people in this channel.  You do the math. :)
14:20:55 <ChristianS> dzhus: a SexParser will probably be much more popular with search engines
14:20:56 <rasfar> chuckle
14:22:13 <timthelion> sexy sexp's...
14:23:22 <dzhus> (.)(.)
14:23:27 <nart> so with the new DataKinds you can specify what type your parameterized type can take ?
14:23:49 <rasfar> The site www.clickpass.com is requesting access to your Google Account for the product(s) listed below.
14:23:50 <rasfar> 	Google Contacts
14:23:54 <rasfar> um, i don't think so!
14:24:07 <rasfar> (that's to log in to ycombinator poll above)
14:25:07 <tech2> rasfar: I know, frustrating yes?
14:25:20 <teneen> I'm having a problem with Impredicative types. If I say x = [1] :: [forall a. Num a => a], then I try to call "head x + 1" it gives an error. However, if I store "head x" in a variable say "y" and then call "y + 1" it works perfectly!
14:25:48 <rasfar> if "google contacts" means my contacts list, it's criminal
14:27:10 <timthelion> That's why javascript is currently wining the poll :D
14:27:20 <rasfar> actually, ... i'm sorry this is OT a bit, but I trust you folks ... has anyone grokked the new google privacy policy and decided to withdraw?  the deadline approaches...
14:28:06 <nart> rasfar: what's wrong with it ?
14:28:37 <rasfar> *i* haven't gorkked it (oops) just wondering if there's anything i should be worried about?
14:29:01 <dzhus> google will steal your parentheses
14:30:56 <path[l]> in a function definition can I write x:xs on the left to destructure a list AND have a name for the list?
14:31:02 <rasfar> i program directly on the AST so can live with that :p
14:31:23 <rasfar> path[l]: lst@(x:xs)
14:31:25 <timthelion> path[l]: I think you do list@(x:xs) no?
14:31:30 <path[l]> thanks :)
14:31:50 <rasfar> *really* handy syntax
14:31:54 <hiptobecubic> it's great
14:32:27 <nart> is it ok to use Iteratee IO  ?
14:32:40 <nart> i'm reading the slide "Iteratee IO safe, practical, declarative input processing"
14:33:02 <nart> it's update to 2010, so i wonder if it's still valid
14:33:03 * timthelion has been searching for an alternative search engine to google for a while.  Google is starting to suck :( (It doesn't handle multilanguge stuff well, so if I search in Czech it gets polish and Russian and English, and when I search in English I get Czech, ect)
14:33:07 <nart> *updated
14:34:24 <qued_____> .
14:34:56 <timthelion> qued_____: ...
14:34:59 <mekeor`> timthelion: ddg.gg and symbolhound.com are useful search-engines, too, btw
14:35:00 <qued_____> What does the first '|' mean here?   data BExp = | Var String | Not BExp | And BExp BExp | Or BExp BExp
14:35:03 <teneen> 	I'm having a problem with Impredicative types. If I say x = [1] :: [forall a. Num a => a], then I try to call "head x + 1" it gives an error. However, if I store "head x" in a variable say "y" and then call "y + 1" it works perfectly!
14:35:10 <mekeor`> > repeat '.'
14:35:11 <rasfar> teneen, dzhus: i wish i could help
14:35:11 <lambdabot>   ".............................................................................
14:36:20 <hpc> :t intersperse
14:36:21 <lambdabot> forall a. a -> [a] -> [a]
14:36:45 <timthelion> mekeor`: thanks
14:37:21 <roconnor> teneen: what's the error?
14:37:47 <teneen> roconnor: No instance for (Num (forall a. Num a => a))
14:37:58 <roconnor> heh
14:38:07 <mekeor`> hpc: can you answer qued_____'s question?
14:38:39 <mah_b> > let x = [1] :: [forall a. Num a => a] in head x + 1
14:38:40 <lambdabot>   2
14:39:12 <hpc> qued_____: i think it's a syntax error
14:39:35 <hpc> yep, syntax error
14:39:47 <mekeor`> hpc: but there are empty types, too, actually.
14:39:51 <mekeor`> like 'data Foo'
14:40:00 <hpc> the '|' is a delimiter between constructors of BExp
14:40:29 <hpc> you can read it as "a BExp is either (Var foo) for some String foo, (Not foo) for some BExp foo, ..."
14:41:00 <qued_____> hmmmm okay
14:41:01 <qued_____> ty
14:41:04 <hpc> the first '|' causes a parse error, but if you just delete it it will compile right
14:45:05 <teneen> mah_b: it doesn't work with ghci
14:47:41 <rasfar> oopts i meant s/dzhus/nart/ (dzhus ur beyond help :p)
14:49:01 <rasfar> is it possible to pass a type argument to a regular function (using something from Data.Typeable perhaps)?
14:49:27 <rasfar> so that instead of writing x::T in the function, I can pass T in as a parameter?
14:50:08 <rasfar> tried all kinds of things: http://hpaste.org/65706
14:54:21 <path[l]> hpaste is throwing errors : x
14:54:28 <geekosaur> rasfar:  no, types are not values
14:54:41 <rasfar> is it still?  but the old paste is still loading thankfully.
14:55:09 <rasfar> geekosaur: you should check out that paste though, types can almost be treated like values with Data.Generics...
14:55:09 <path[l]> can someone help me make this code look nicer -> http://pastie.org/3657130
14:56:06 <path[l]> how do you ask lambdabot to give you pointless code again?
14:56:21 <geekosaur> "@pl"
14:56:28 <mekeor`> path[l]: on line 7, you should check whether the list is empty. use 'null'.
14:56:41 <mekeor`> > head []
14:56:42 <lambdabot>   *Exception: Prelude.head: empty list
14:56:45 <rasfar> path[l]: that's pretty much what I'd have written, so guess i can't help!
14:56:46 <path[l]> ah
14:57:01 <rasfar> (except for the bugs of course)
14:57:16 <path[l]> umm, how do I check?
14:57:51 <rasfar> null :: [a] -> Bool
14:57:52 <path[l]> @pl f x (xs, b) = ((x:xs),b)
14:57:52 <lambdabot> f = (`ap` snd) . (. fst) . ((,) .) . (:)
14:58:05 <rasfar> @type null
14:58:06 <lambdabot> forall a. [a] -> Bool
14:58:35 <rasfar> @src null
14:58:35 <mekeor`> path[l]: you should use the same naming conventions in the whole code. do not name_some_functions_like_this and otherOnesLikeThis.
14:58:35 <lambdabot> null []     = True
14:58:36 <lambdabot> null (_:_)  = False
14:59:06 <path[l]> mekeor`: yeah, sorry, that was just hacked together, I didnt realise I had switched midway
14:59:37 <mekeor`> path[l]: yea, actually i don't care about such things either. but *you* asked for advices :P ;) :)
14:59:43 <path[l]> haha
15:00:11 <path[l]> I was looking for more in terms of using more idiomatic haskell. That merge1 merge2 crap is pretty ugly
15:00:15 <path[l]> for example
15:00:50 <quintessence> path[l]: in that case I would recommend using a let in each branch instead of defining both in a where and only using one
15:01:04 <path[l]> hmm
15:01:47 <path[l]> I usually prefer where because it moves the noise elsewhere. Out of the definition. But let me try that
15:02:11 <mekeor`> path[l]: ah, ok
15:02:41 <mekeor`> path[l]: i agree with you (regarding 'where').
15:03:52 <nart> path[l]: maybe instead of args <- getArgs   let filename = head args ->   filename <- head `fmap` getArgs
15:03:57 <mekeor`> path[l]: do you know 'hlint'?
15:04:03 <mekeor`> path[l]: that can help you.
15:04:30 <mekeor`> path[l]: i think, e.g. on line 17 and 18, some brackets are redundant
15:04:30 <path[l]> hmm, let me try hlint then
15:04:36 <path[l]> nart: ah ok
15:04:42 <nart> > let x = return "hi" :: IO (String) in head `fmap` x
15:04:43 <lambdabot>   <IO Char>
15:04:54 <nart> ah ops
15:05:14 <nart> path[l]: no i made a huge mistake
15:05:28 <mekeor`> nart: <$> is a symbolic infix-equivalent of fmap, btw.
15:05:36 <mekeor`> @src (<$>)
15:05:36 <lambdabot> f <$> a = fmap f a
15:05:50 <nart> mekeor`: i know, but you have to import Control.Applicative
15:06:08 <mekeor`> ah, right
15:06:24 <mekeor`> (i learned it today, so i wanted to mention it =])
15:07:25 <nart> > let x = return [1,2] :: IO ([Int]) in head <$> x
15:07:26 <lambdabot>   <IO Int>
15:08:29 <nart> >  let x = return [1,2] :: IO ([Int]) in print $ head <$> x
15:08:30 <lambdabot>   <IO ()>
15:08:33 <nart> -.-'
15:08:39 <mekeor`> nart: yea, that's nice, but you should check the length of the list before you apply head…
15:09:00 <hpc> mekeor`: poor choice of words there :P
15:09:05 <hpc> nart: check for emptiness
15:09:09 <hpc> > length [1..]
15:09:13 <lambdabot>   mueval-core: Time limit exceeded
15:09:15 <hpc> > null [1..]
15:09:16 <lambdabot>   False
15:09:34 <mekeor`> hpc: i mentioned null above.
15:09:42 <hpc> oh, that you did
15:09:53 <hpc> i blame it being off my screen
15:09:58 <mekeor`> but yea, u're right. check for emptiness…
15:10:02 <mekeor`> :)
15:10:22 <mizu_no_oto> What do you need in order for foldl to equal foldr?  Just associativity, or is commutativity required as well?
15:10:49 <hpc> mizu_no_oto: you mean for their results to be equal?
15:11:05 <hpc> (ie, you want some f and z such that foldl f z = foldr f z)
15:11:07 <mizu_no_oto> hpc: yeah
15:11:30 <koeien> yes then you need commutativity i think
15:11:35 <hpc> mizu_no_oto: i think what you need is monoid-ity
15:11:36 <koeien> not 100% sure
15:11:37 <nart> hpc, mekeor`: what's the best way to check for emptyness ?
15:11:44 <mekeor`> null
15:11:51 <koeien> hrm, probably not
15:11:52 <nart> *emptiness
15:11:55 <hpc> you need an f that associates, and a zero element
15:11:55 <nart> no i mean, in that code
15:12:11 <hpc> mizu_no_oto: foldr mappend mempty == foldl mappend mempty
15:12:13 <koeien> yes the 1 gets placed left or right
15:13:15 <hpc> mizu_no_oto: modulo strictness; the two will still evaluate differently and might diverge or just be slower
15:13:19 <mizu_no_oto> Monoids are only associative, so I guess you only need associativity
15:13:30 <hpc> but if they both terminate, it all works out
15:13:30 <koeien> monoids have also a 1
15:13:53 <hpc> associativity and an identity element
15:14:01 <hpc> (mappend, mempty)
15:14:08 <hpc> etc, etc :P
15:14:10 <koeien> ugly names btw
15:14:10 <rasfar> nart: you can't just add a  | null l1 || null l2  guard to your first merge_and_count binding, because the (x:xs) etc. pattern match will fail before the guards are reached.
15:14:13 <mizu_no_oto> koeien: yes, but you don't really need the identity element for foldl
15:14:20 <hpc> koeien: agree
15:14:26 <koeien> mizu_no_oto: you do
15:14:29 <hpc> koeien: in an ideal world, i would have ((++), one)
15:14:36 <koeien> hpc: yeah i like (++)
15:14:39 <hpc> (which would be confusing for Sum...)
15:14:40 <rasfar> so you'll need an extra binding for merge_and_count
15:14:41 <koeien> @src foldl
15:14:41 <lambdabot> foldl f z []     = z
15:14:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:15:07 <path[l]> ok now it's not ending. Guess I need to force it to be eager
15:15:11 <nart> rasfar: that's not my code eheh, it's path[l]'s
15:15:18 <mizu_no_oto> koeien: why do you need an identity element for foldl f someSeed = foldr f someSeed?
15:15:41 <mizu_no_oto> The initial seed in folding need not be the identity
15:15:42 <hpc> > foldl (+) 0 [x, y, z] -- see where 0 is
15:15:43 <lambdabot>   0 + x + y + z
15:15:46 <hpc> > foldr (+) 0 [x, y, z] -- see where 0 is
15:15:47 <lambdabot>   x + (y + (z + 0))
15:16:01 <rasfar> nart: ah yes, i was confused b/c you asked "what's the best way to test for emptiness"
15:16:03 <koeien> mizu_no_oto: it does not need to be. but, if you want them to be equal, they should be.
15:16:20 <koeien> mizu_no_oto: z + x + y does not necessarily equal x + y + z  if z is not an identity element
15:16:27 <hpc> the seed ends up on "opposite sides" of the list when you fold
15:16:28 <rasfar> anyhow, let's attend to this fold discussion, it's a nice question
15:16:38 <mizu_no_oto> hmm
15:16:50 <mizu_no_oto> So either you need commutativity, or an identity?
15:16:54 <koeien> (it's fine of course if your monoid is abelian)
15:16:58 <hpc> you need associativity AND an identity
15:17:07 <koeien> you need the "seed" to be an identity, or your + to be commutative
15:17:18 <hpc> oh, that
15:17:19 <hpc> yeah
15:17:34 <hpc> wait, no
15:17:47 <hpc> koeien: that doesn't work because the seed is on the "inside"
15:18:17 <hpc> or... i suppose it does because associativity too
15:18:19 <hpc> ignore me
15:18:44 <hpc> you can alternate associate and commute until the 0 is pulled from one side of the expression to another
15:18:54 <mizu_no_oto> right
15:19:05 <hpc> i like this question
15:20:54 <path[l]> how do I convert an Int to an Integer
15:20:58 <koeien> fromIntegral
15:21:00 <mizu_no_oto> Is there an algebraic structure with just the associativity and commutativity?
15:21:25 <path[l]> aha
15:21:26 <mizu_no_oto> And abelian semigroup?
15:21:32 <mizu_no_oto> *an
15:21:33 <roconnor> mizu_no_oto: commutative semigroup
15:21:44 <roconnor> abelian is probably fine
15:21:51 <koeien> "abelian" is generally used for groups, but it should be ok
15:22:16 <hpc> :t toInteger
15:22:17 <lambdabot> forall a. (Integral a) => a -> Integer
15:22:33 <path[l]> ok now it's time for me to understand how to use seq :/
15:22:46 <mizu_no_oto> So foldl = foldr for commutative semigroups and monoids
15:23:00 <koeien> not completely, you need to require that both terminate
15:23:17 <mizu_no_oto> For finite lists
15:23:58 <mizu_no_oto> And monoids have the additional requirement that the seed must be the identity
15:24:03 <koeien> yes
15:24:24 <koeien> i generally think of foldr as defining what should happen on the constructors (:) and 1
15:24:29 <koeien> foldl is a strange beast
15:24:43 <koeien> (i'm sure this has a nice name.)
15:27:31 <Ptival> like, catamorphism?
15:27:42 <koeien> yeah it's one of the *morphisms
15:27:49 <nart> what's a catamorphism ?
15:28:10 <Ptival> I'll let you google it
15:28:33 <nand`> fold is an example of a catamorphism
15:28:52 <nart> i'm asking you because i haven't understood it :S
15:29:03 <Ptival> nart: oh...
15:29:05 <nart> In category theory, the concept of catamorphism (from Greek: κατά = downwards or according to; μορφή = form or shape) denotes the unique homomorphism from an initial algebra into some other algebra
15:29:13 <path[l]> how can I make this non lazy -> https://gist.github.com/2175690 ?
15:29:14 * rasfar assumed koeien wanted a name to distinguish the beatliness of foldl in particular
15:29:22 <path[l]> I dont get how to use seq
15:30:04 <c_wraith> path[l]: what part is lazy that you don't want to be?
15:30:49 <path[l]> well the 2 functions merge_and_count and merge_sort_count are both recursive. So my guess is that on large lists they will leak memory?
15:31:03 <c_wraith> leak is not the same as "use"
15:31:06 <koeien> that's not a given at all
15:31:42 <mizu_no_oto> nart:  you should probably either ignore that, or pick up something like Contemporary Abstract Algebra  and then Category Theory for the Working Mathematician
15:31:47 <c_wraith> oh, it is likely you will build up thunks in your counters, though.
15:31:58 <path[l]> fair, but yeah I didnt want to leak thunks
15:32:05 <path[l]> err build up
15:32:21 <mizu_no_oto> nart:  the basic idea, though, is that a catamorphism is like a fold:  you take a structure, and reduce it to one element
15:32:45 <c_wraith> the simplest approach is to enable Bangpatterns and stick a ! in front of cnt in both equations for merge_and_count
15:33:16 <path[l]> hmm ok let me try to understand this. I'm surprised that it shows up in front of cnt
15:33:56 <qued_____> What does fromInteger do?
15:34:01 <mizu_no_oto> nart: the dual to that is an anamorphism, which is like an unfold:  you start out from a single value - (0,1), say, and then you turn that into the entire structure: [0,1,1,2,3,5,8,13,...]
15:34:01 <c_wraith> :t fromInteger
15:34:02 <lambdabot> forall a. (Num a) => Integer -> a
15:34:22 <c_wraith> that type should tell you just about everything.  Converts an Integer into any type that's an instance of Num
15:34:23 <qued_____> just printing out the Integer ?
15:34:38 <koeien> qued_____: no, fromInteger converts an Integer to any numeric data type
15:34:48 <qued_____> hmmm right ...
15:34:50 <qued_____> okay
15:34:54 <koeien> for example
15:35:00 <path[l]> c_wraith: would this be sufficient https://gist.github.com/2175690 (and in general how do I tell if Im building up thunks) ?
15:35:03 <koeien> > fromInteger (2^40) :: Float
15:35:04 <lambdabot>   1.09951163e12
15:35:17 <nart> mizu_no_oto: thanks for the explanation, and thanks for the suggested books :)
15:35:46 <c_wraith> path[l]: not even close. forcing a list to whnf is almost useless
15:36:09 <c_wraith> path[l]: as is forcing a tuple to whnf
15:36:16 <qued_____> koeien: but 2^40 is Float anyway ...
15:36:25 <koeien> qued_____: no.
15:36:35 <c_wraith> :t 2^40
15:36:36 <lambdabot> forall t. (Num t) => t
15:36:40 <koeien> > fromInteger (1024*1024*1024*1024) :: Float
15:36:41 <lambdabot>   1.09951163e12
15:36:59 <c_wraith> it seems 2^40 is a polymorphic expression that can be any instance of Num
15:37:05 <koeien> qued_____: do you know what a "type class" is ?
15:37:18 <qued_____> yes
15:37:23 <geekosaur> :t (^)
15:37:25 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:37:32 <path[l]> c_wraith: ok Im not even sure what whnf is : x, but let me read what bangPatterns does
15:37:49 <koeien> path[l]: BangPattern is syntactic sugar for seq
15:38:08 <koeien> whnf means "the value with the outermost constructor evaluated"
15:38:15 <c_wraith> path[l]: you can think of whnf as "the first constructor has been evaluated, but may contain further thunks"
15:38:26 <koeien> qued_____: cool. well fromInteger is :: Num a => Integer -> a
15:38:37 <mekeor`> :t (^)
15:38:38 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:38:56 <koeien> qued_____: this means that fromInteger can turn an integer into an arbitrary numeric value of your choosing
15:39:08 <koeien> for example, Double, Int, Float, Word64
15:39:16 <geekosaur> weak head normal form is evaluating to the first constructor.  for a list that means the first (:) (but neither the first element nor the tail of the list), similarly for a tuple it's the parentheses around the tuple
15:39:17 <path[l]> hmmm
15:39:48 <koeien> (a newtype is a bit different in thsi regard but you can ignore that for now)
15:39:52 <path[l]> so $! is only going to whnf ?
15:39:55 <c_wraith> yes
15:39:55 <koeien> yes.
15:40:01 <path[l]> ok
15:40:02 <koeien> f $! x is just x `seq` f x
15:40:14 <koeien> @src ($!)
15:40:14 <lambdabot> f $! x = x `seq` f x
15:41:08 <path[l]> I guess I've never really understood how to use seq. If I have f [] = [] and f (x:xs) = x:(f xs), how would I use seq to make it non lazy?
15:41:44 <c_wraith> path[l]: you wouldn't.
15:41:48 <quintessence> generally you want functions operating on lists to be lazy
15:42:08 <c_wraith> path[l]: that's already non-lazy.  it pattern-matches
15:42:20 <killy9999> ummm.... hpaste doesn't work?
15:42:39 <path[l]> I dont understand why that's non lazy, unless you mean the compiler is smart enough to realise Im doing nothing
15:42:59 <geekosaur> path[l], pattern matching is inherently strict except in let
15:43:03 <c_wraith> path[l]: it has to evaluate the argument to know which constructor is in use before it knows what constructor to return
15:43:13 <path[l]> ah I see
15:43:17 <geekosaur> (there is a way to defeat that)
15:43:50 <c_wraith> however, it doesn't force the whole list at once, just the head
15:44:00 <c_wraith> well, on the lead constructor
15:44:09 <c_wraith> it doesn't force the value at that location, nor the rest of the list
15:44:29 <path[l]> that's interesting. So does that mean that anytime I write a recursive list function and I use a pattern matching constructor it's non lazy? in https://gist.github.com/2175690 does that mean that merge_and_count is already non lazy?
15:44:45 <c_wraith> path[l]: you're not using the constructor on *all* the arguments
15:44:57 <c_wraith> path[l]: which was my point.  cnt is the argument that will cause you problems
15:45:20 <hpaste> killy9999 pasted “Type question” at http://hpaste.org/65849
15:45:37 <path[l]> oh
15:45:52 <killy9999> how does throwing an error in case of empty list fit into Haskell type system?
15:45:58 <geekosaur> :t error
15:45:59 <lambdabot> forall a. [Char] -> a
15:46:04 <c_wraith> path[l]: try this function instead « badAddition 0 y = y ; badAddition x y = badAddition (x - 1) (y + 1) »
15:46:19 <geekosaur> because it never produces an actual result, it matches all possible types
15:46:37 <geekosaur> (we call this "bottom", the computation that diverges)
15:46:40 <edwardk> killy9999: its a wart caused by the fact that head is 'traditional' from lisp. but ultimately you could always just spin forever trying to evaluate something
15:46:43 <path[l]> c_wraith: ah, that's non lazy is it? (when you say try, how would I confirm it's non lazy)
15:46:49 <killy9999> Is "error" considered any type?
15:46:57 <edwardk> killy9999: nothing keeps you from making head [] = head []; head (x:xs) = x
15:47:00 <edwardk> :t error
15:47:02 <lambdabot> forall a. [Char] -> a
15:47:03 <edwardk> :t undefined
15:47:04 <lambdabot> forall a. a
15:47:08 <edwardk> undefined = undefined -- would work
15:47:22 <edwardk> but what we do instead of actually try to propagate out a message to you
15:47:29 <c_wraith> path[l]: well, it's lazy in the second argument, (at least without optimizations, which would probably fix this case)
15:47:32 <qued_____> "(23:38:35) koeien: qued_____: this means that fromInteger can turn an integer into an arbitrary numeric value of your choosing"     , And how to choose it? And I thought Integer is already from type Num, so how to convert Integer to Num again?
15:47:38 <c_wraith> path[l]: more precisely, it's non-strict
15:47:46 <killy9999> mhm
15:47:50 <geekosaur> qued_____, you choose it by how you use it
15:47:50 <edwardk> thats what an exception is in haskell, is an undefined value, trying to evaluate it, causes your program to terminate with an error
15:47:53 <mekeor`> qued_____: with a type signature
15:47:54 <koeien> qued_____: you choose it by using it
15:47:58 <geekosaur> > fromIntegral 1 :: Float
15:47:59 <lambdabot>   1.0
15:48:02 <koeien> qued_____: for example, fromInteger 1 :: Double
15:48:09 <koeien> unfortunately, defaulting exists.
15:48:14 <c_wraith> path[l]: but consider what will happen when that function is run.  since nothing ever forces y, each recursive call will create a new thunk wrapping the result.
15:48:37 <path[l]> hmm
15:48:41 <killy9999> yes, but the compiler deosn't complai about type mismatch
15:48:41 <path[l]> aha
15:48:43 <path[l]> I see
15:48:46 <edwardk> now we have all sorts of semiprincipled things that can exist on top of this to let you see what went wrong, but you generally shouldn't rely on any relative ordering of what exception you'll see, because it can be exceedingly hard to reason about which error will happen first in a lazy world
15:48:46 <killy9999> that's what wonders me
15:49:00 <geekosaur> there is no mismatch.  "forall a. a" matches every type
15:49:01 <edwardk> killy9999: notice the return type of 'error'
15:49:11 <edwardk> :t error "hello"
15:49:12 <lambdabot> forall a. a
15:49:16 <c_wraith> path[l]: so, that'll create a giant stack of thunks when it runs.  And potentially run out of stack space when something tries to use it.
15:49:17 <killy9999> [Char] -. a
15:49:20 <killy9999> ->
15:49:25 <edwardk> :t error "hello" + 12
15:49:26 <lambdabot> forall a. (Num a) => a
15:49:31 <geekosaur> :t error "hello" :: a -> b
15:49:31 <lambdabot> forall a b. a -> b
15:49:33 <edwardk> :t error "hello" + (12 :: Int)
15:49:34 <lambdabot> Int
15:49:51 <edwardk> error "foo" has any type you want it to
15:50:00 <path[l]> c_wraith: how would I fix this using `seq`? I've never really understood how to use seq
15:50:11 <edwardk> (that is, any boxed type to be pedantic)
15:50:51 <killy9999> mhm, I see
15:51:00 <killy9999> more or less :)
15:51:18 <quintessence> path[l]: wrt earlier questions of style, I would do something like http://hpaste.org/65848 (I don't guarantee that those bang patterns are enough for strictness, though)
15:51:24 <c_wraith> path[l]: the most explicit fix would be « lessBadAddition 0 y = y ; lessBadAddition x y = let z = y + 1 in z `seq` lessBadAddition (x - 1) z »
15:52:25 <path[l]> c_wraith ah I see
15:52:30 <path[l]> quintessence: reading :)
15:53:06 <qued_____> many thanks ;) mekeor` , koeien
15:53:30 <path[l]> !t first
15:54:02 <path[l]> :t first
15:54:03 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:55:43 <path[l]> ah that's neat
15:55:54 <mekeor`> haskell.org/arrows is a good explanation of arrows
15:56:13 <quintessence> I still can't decide if arrow combinators are concise or obfuscated for normal code, but in this case the coin landed on "concise".
15:56:32 <c_wraith> I'm with edwardk here.  Arrows aren't really an abstraction worth learning.  The arrow combinators specialized to functions are handy, though.
15:56:57 <edwardk> yeah, down with arrows!
15:56:59 <edwardk> ;)
15:57:21 <koeien> i use (***) and (&&&) often
15:57:24 <edwardk> in general almost all of the good stuff from arrows can be had with applicatives
15:57:28 <path[l]> I ended up writing add_item x (xs, a) = (x:xs, a), I suppose using first is better than reinventing that
15:57:36 <edwardk> koeien: they generalize to CCCs
15:57:55 <koeien> edwardk: i'd need to brush up on my CT :D
15:58:18 <edwardk> http://hackage.haskell.org/packages/archive/categories/0.59/doc/html/Control-Category-Cartesian.html
15:58:44 <koeien> not -Closed ?
15:58:50 * rasfar thought CCC "Cartesian closed cat." 
15:59:27 <edwardk> (***) or (+++) are just the Bifunctor for (,) and Either respectively. (&&&) or (|||) only needs (Co)Cartesian. not even closed.
16:00:17 <edwardk> i need to go back through there and remove 'Comonoidal' and merge it with Monoidal.
16:00:22 <edwardk> forgot i hadn't done that
16:03:51 <path[l]> as I make these changes, how can I tell when I've stopped building up thunks?
16:04:47 <koeien> profile
16:06:06 <path[l]> ah right
16:09:32 <mekeor`> so, actually (->) is an arrow, right? hehe
16:09:45 <mekeor`> :D lol
16:09:45 <mekeor`> #
16:10:14 <koeien> that's right :)
16:12:46 <Philippa> edwardk: how easy is it to get those working if you don't want to import too much that isn't in the Platform, OOI?
16:13:53 <mekeor`> so, (-<) is for arrows like ($) is for functions?
16:13:57 <mekeor`> :t (-<)
16:13:58 <lambdabot> Not in scope: `-<'
16:14:07 <mekeor`> err.. what?
16:14:29 <edwardk> Philippa: categories uses 'base' and 'void'. 'void' brings in 'semigroups', 'semigroups' brings in 'containers'
16:14:36 <edwardk> thats it
16:15:00 <koeien> -< is not actually haskell iirc
16:15:14 <koeien> it's just "arrowed haskell", which gets converted to haksell
16:15:37 <mekeor`> koeien: what??
16:15:54 <edwardk> void is needed as an appropriate initial object, the semigroup is because Void does have a semigroup ;), and 'containers' is because its unlikely i'll get folks to invert the relationship between containers and semigroups any time soon
16:16:11 <Cale> mekeor`: the proc/do syntax for arrows isn't standardised
16:16:14 <koeien> http://www.haskell.org/arrows/syntax.html
16:16:27 <Philippa> edwardk: yeah, more an "I'm NIHing for blog purposes" thing I think - and it's only that specific case I really need
16:16:30 <koeien> "arrowed haskell" is not the best term, it just means some extension of haskell
16:16:31 <mekeor`> koeien: that's what i am reading atm
16:16:48 <mekeor`> koeien: ah
16:17:14 <edwardk> Philippa: well, categories is pretty minimal. i'll do a complete rewrite of it when we get a syntax for polykinds, but I deliberately didn't depend on much else of mine
16:17:40 <Philippa> *nod*
16:17:40 <path[l]> thanks c_wraith quintessence
16:18:02 <edwardk> the main reason i wrote it was so that people woudn't have to NIH unnecessarily =P
16:18:07 <Philippa> really I just want a way to pipe around a second copy of a metavariable's name when I gensym^WnewVar it for now
16:22:52 <mekeor`> > (id :: (->) a a) 5
16:22:52 <lambdabot>   5
16:23:24 <mauke> > 5 (id :: (->) a a)
16:23:25 <lambdabot>   5
16:23:31 <mauke> 5 is commutative
16:23:32 <mekeor`> is (->) officially an instance of Arrow?
16:23:38 * copumpkin slaps mauke 
16:23:46 <mekeor`> mauke: that's because of NumInstances
16:23:50 <mekeor`> @where NumInstances
16:23:50 <lambdabot> I know nothing about numinstances.
16:23:51 <copumpkin> mekeor`: yeah
16:24:06 <mekeor`> @package NumInstances -- …
16:24:06 <lambdabot> http://hackage.haskell.org/package/NumInstances -- …
16:24:09 <mauke> > first length ("", ())
16:24:10 <lambdabot>   (0,())
16:24:11 <shachaf> mauke: Don't you mean that " " is commutative?
16:24:37 <mekeor`> mauke: so, yes? (to my question)
16:24:43 <mekeor`> :t first
16:24:44 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
16:24:57 <mekeor`> indeed.
16:25:08 <mekeor`> nice, cool!
16:25:09 <mauke> > first 5 (id, ())
16:25:09 <lambdabot>   (5,())
16:25:19 <mauke> 5 is an instance of arrows
16:25:25 <mekeor`> > show const
16:25:26 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> a)
16:25:26 <lambdabot>    arising from a use...
16:25:46 <mekeor`> mauke: lol eheh
16:25:54 <mekeor`> :t 5 id
16:25:55 <lambdabot> forall t a. (Num ((a -> a) -> t)) => t
16:26:19 <mauke> :t 5 :: 1
16:26:20 <lambdabot>     No instance for (Num Unit)
16:26:20 <lambdabot>       arising from the literal `5' at <interactive>:1:0
16:26:20 <lambdabot>     Possible fix: add an instance declaration for (Num Unit)
16:26:27 <mekeor`> omg
16:26:34 <mekeor`> :t 5 :: ()
16:26:34 <lambdabot>     No instance for (Num ())
16:26:35 <lambdabot>       arising from the literal `5' at <interactive>:1:0
16:26:35 <lambdabot>     Possible fix: add an instance declaration for (Num ())
16:26:46 <mekeor`> data () = () -- right?
16:27:06 <mauke> yes
16:27:08 <c_wraith> mekeor`: if it wasn't for the fact that it's a syntax error, yes
16:27:26 <mekeor`> is -- data [] a = [] a | (:) a ([] a) -- valid haskell, actually?
16:27:32 <mauke> no
16:27:40 <mauke> technically yes, though
16:28:07 <rasfar> @src []
16:28:08 <lambdabot> data [] a = [] | a : [a]
16:28:24 <mekeor`> oh, thanks
16:29:20 <mekeor`> but, is that valid haskell?  -- my actual question is whether i can define a constructor called '[.]' then..
16:29:55 <mauke> no, the only uppercase symbol is :
16:30:06 <mekeor`> but that's a silly question. i pose too much silly questions.
16:30:10 <mauke> it's valid haskell in that "--" starts a comment and the line is ignored
16:30:11 <mekeor`> > isUpper ':'
16:30:12 <lambdabot>   False
16:30:16 <mekeor`> lol
16:30:27 <mekeor`> mauke: lol
16:32:34 <rasfar> > let --: x = x*x in --: 2
16:32:34 <lambdabot>   <no location info>: parse error on input `--:'
16:32:44 <mekeor`> > let 5 = 1 in 5
16:32:45 <lambdabot>   5
16:32:47 <rasfar> > let (--:) x = x*x in (--:) 2
16:32:48 <lambdabot>   4
16:33:42 <rasfar> let __ = 3 in __
16:33:49 <rasfar> > let __ = 3 in __  -- oops
16:33:50 <lambdabot>   3
16:34:42 <bennoleslie> hi all, I'm relatively new to haskell, and I'm trying to create a shared library on OS X (10.6.8) with the latest 64-bit haskell platform, but hitting some problems, hoping someone might be able to help
16:35:27 <bennoleslie> I'm getting "ld: pointer in read-only segment not allowed in slidable image", hoping someone has seen it before
16:36:16 <BMeph> Does anyone have a good paper for introducing "answer types"?
16:37:19 <dmwit> > let a --: b = b in 3 --: 2 -- rasfar
16:37:20 <lambdabot>   2
16:37:52 <mekeor`> BMeph: what's that?
16:38:25 <BMeph> bennoleslie: Have you tried #ghc? Because, not that we won't help here, but anyone that'd have something to say about it will also be there, and they concentrate more on compilr issues there.
16:38:33 <rasfar> dmwit: yeah
16:38:54 <BMeph> mekeor`: If I had a good paper to refer to you, I might be able to give you an answer... ;)
16:39:00 <dmwit> > let (--:) x = x * x in (2--:) -- does this work?
16:39:01 <lambdabot>   4
16:39:05 <dmwit> huh
16:39:10 <dmwit> I thought they took that out of Haskell.
16:39:11 <mekeor`> BMeph: actually #ghc is for ghc-development…
16:40:00 <BMeph> mekeor`: From what I gather, though, they have something to do with continuations, maybe even directly; part of that is what I'm trying to figure out.
16:40:05 <mekeor`> dmwit: maybe lambdabot feature??
16:40:19 <rasfar> wierd; looks like it should be a right section
16:40:19 <dmwit> mekeor`: Yes, lambdabot probably has the associated language extension turned on.
16:40:24 <mekeor`> dmwit: for me, it doesnt work…
16:40:28 <bennoleslie> BMeph: cool i didn't know about #ghc, thx!
16:40:31 <mekeor`> dmwit: ah, cool
16:40:46 <dmwit> UnaryOperatorSections or some such nonsense.
16:41:24 <rasfar> certainly, no worky in ghci 7.0.4
16:41:52 * mekeor` misses monochro'm. (i didn't want to mention his name directly.) i didn't hear him for a long time now…
16:42:57 <BMeph> mekeor`: Maybe you mean you've missed him; he's on now. :)
16:43:04 <rasfar> lol
16:43:07 <dmwit> Ah, here we go: PostfixOperators
16:44:01 <rasfar> s/right \(section\)/left \1
16:46:04 <mekeor`> why is the type of (<<^) not "Arrow a => a c d -> a b c -> a b d" or even "(Arrow a, Arrow a') => a c d -> a' b c -> a b d" but "Arrow a => a c d -> (b -> c) -> a b d" ?   (i hope i didn't missspell something..)
17:00:30 <BMeph> mekeor`: Your first signature is that of (.). I'm not sure if the second one is even possible; I feel as if it could go either way. The third one matches the pictorial hints of the operator.
17:01:17 <BMeph> mekeor`: That is to say, whoever felt the need for that operator felt it, and its mates, did the job. :)
17:01:24 * mekeor` still has to learn very much…
17:04:42 <DaveNull> say i have a sortGen :: Ord a => (a -> a -> Bool) -> [a] -> [a] which sorts a list according to a comp function...
17:04:56 * hackagebot invariant 0.1.0 - Haskell 98 invariant functors  http://hackage.haskell.org/package/invariant-0.1.0 (NicolasFrisby)
17:04:59 <mauke> why does it require Ord?
17:05:03 <c_wraith> DaveNull: I'd ask why you have an Ord requirement
17:05:04 <DaveNull> why let sortPlus = sortGen (<) doesnt work
17:05:14 <luite> is it possible with GHC to add an in-memory target (no Modulename.hs on disk, targetContents set to the source code), then load all its dependencies, and then compile the target itself in steps: parse/typecheck/load ?)
17:05:14 <mauke> what do you mean by "doesn't work"?
17:05:17 <c_wraith> because < isn't a -> a -> Bool
17:05:25 <c_wraith> or, well, yes it is
17:05:27 <mauke> c_wraith: wat
17:05:32 <DaveNull> :t sortPlus gives  [()] -> [()]
17:05:33 <lambdabot> parse error on input `->'
17:05:34 <c_wraith> I suck at math. :)
17:05:39 <mauke> DaveNull: so it works
17:05:58 <c_wraith> oh
17:06:01 <c_wraith> MR
17:06:08 <DaveNull> so i suppose my error is elsewhere :)
17:06:08 <c_wraith> the monomorphism restriction
17:06:08 <rasfar> luite: i use a "ramdisk" maybe that can work for you?  /dev/mem* in *nixy things.
17:06:21 <c_wraith> put a type signature on sortPlus
17:06:40 <DaveNull> c_wraith, i don't manage to do it in ghci
17:06:55 <mauke> DaveNull: there is no error
17:07:09 <rasfar> i just realised it's friday gotta ruuunnnn........
17:07:10 <c_wraith> let sortPlus :: Ord a => [a] -> [a] ; sortPlus = sortGen (<)
17:07:32 <luite> argh..
17:07:46 <luite> ok
17:07:57 <DaveNull> i got : no instance for (Num ())  arising from the literal `1' if i try to apply sortPlus [1..10]
17:08:17 <c_wraith> DaveNull: did you do what I said?  *put a type signature on it*
17:08:19 <mauke> yes, because your sortPlus has the wrong type
17:08:19 <DaveNull> c_wraith, thx, i try
17:08:30 <mauke> which is because monomorphism restriction
17:08:40 <mauke> I can't explain why your sortGen has the wrong type, though
17:09:25 <rasfar> (guess i stil have an hour =)
17:10:36 <DaveNull> c_wraith, ok, it works...
17:11:07 <DaveNull> still, i don't understand why a partial function "loses" it's type
17:11:25 <DaveNull> s/it's/its
17:11:26 <rasfar> luite: you may be talking about something harder, namely a generated module?  i mount a ramdisk to get better linker performance and less disk wear, only.
17:11:35 <c_wraith> DaveNull: you ran into the monomorphism restriction (MR) combined with ghci's extra defaulting rules.  the MR applies to declarations that "look like" values, and it makes them monomorphic
17:11:58 <c_wraith> DaveNull: in this case "looking like a value" means that it is declared without an argument list.
17:11:59 <DaveNull> ok, i'm gonna read some doc about MR
17:12:01 <danharaj> Why is the MR still enabled in ghci :\
17:12:15 <danharaj> rather, not disabled by default.
17:12:25 <c_wraith> great question
17:13:10 <luite> rasfar: oh you're back ;p
17:13:17 <rasfar> luite: still if that's the case, you can write the generated module to the ramdisk so that you have a handle to it, then go from there, and it should still avoid disk I/O.
17:13:24 <Philippa> partly because we can use .ghci to do that for us?
17:13:31 <c_wraith> DaveNull: the really short version is that if ghc had more information to infer type from (a full source file that uses it, not just a definition at the prompt in ghci), it would infer a better type.
17:13:32 <rasfar> (yeah, my friend needs a nap first heh)
17:13:44 <luite> rasfar: I already have a filename, but it doesn't match the module name, that's the problem
17:14:13 <rasfar> how does that happen?
17:14:14 <DaveNull> so, if i use let sortPlus list = sortGen (>) list, it works... good to know
17:14:33 <luite> rasfar: uh because the filename is based on a hash of the contents
17:14:49 <c_wraith> DaveNull: yes, that's the other condition
17:14:52 <rasfar> hey! i do the same thing.  you are doing a preprocessor, right?
17:15:09 <rasfar> since you're committed to GHC anyhow, have you explored the -F option?
17:15:15 <luite> no just loading
17:15:22 <luite> uh, I don't have options in the API :p
17:15:35 <rasfar> oh.  ah.  ooo
17:15:37 <luite> what does it do?
17:16:22 <rasfar> -F "seamlessly" integrates an arbitrary preprocessor (executable) and avoids the temp file renaming crap
17:16:27 <luite> oh right
17:16:34 <luite> yeah I don't have that :)
17:16:47 <rasfar> hahaha!  what is "loading"?
17:17:01 <luite> loadModule in the GHC API
17:17:58 <rasfar> okay, and the module is on disk, but for some reason has a different filename and module name -- for this situation, I used an edit script at the shell level to change the module name I think...  i better check
17:18:56 <tgeeky> rasfar: he's not loading from disk (necessarily). luite works on the web side of things
17:18:56 <lambdabot> tgeeky: You have 1 new message. '/msg lambdabot @messages' to read it.
17:19:29 <rasfar> er, no, i used the HSE API to modify the Module name in the constructor (rebuilt the root node of the AST).
17:19:36 <luite> rasfar: the problem is that there can be multipe versions of a single module name
17:19:46 <rasfar> tgeeky: so that would work for URI's too :)
17:20:25 <luite> rasfar: so if I'd load them from disk with ghc somehow, I'd at least have to make a symlink or something like that
17:20:36 <luite> for every request
17:21:36 <tgeeky> luite: so the problem is keeping (or recovering) sharing
17:21:38 <rasfar> you use hash of contents to generate a unique module name.  can't you then reconstruct the root node to harmonise it with that name?  (sorry you may need to pound this nail in more for me to see the problem clearly)
17:21:58 <luite> rasfar: yes and then all error messages will be off
17:22:32 <rasfar> how so? b/c GHC will report the hash-based name instead of the original?
17:22:35 <luite> plus the file wil have a wrong module declaration if it has one
17:22:39 <luite> yes
17:24:00 <tgeeky> luite: so, out of left field here
17:24:05 <rasfar> it seems like your problem is (like tgeeky is saying? or i may be wrong) about the persistence, more of a DB-ish problem?
17:24:06 <luite> I used to do the renaming, with haskell-src-exts, but that gave me wrong error messages, ugly code that modifies the module name and problems with the haskell-src-exts pretty printer
17:25:10 <rasfar> is it like, your application loads a module, makes two or more variants of it, and you need to keep those sorted but not change the original module name?
17:25:16 <luite> rasfar: well, I'm working on a wiki, and every module can have many different revisions
17:25:54 <tgeeky> luite: you mentioned at the top that you want this in-memory representation. As far as I could make out, that is what the (same authors?) Forest and PADS were trying to achieve.
17:26:14 <tgeeky> luite: they worked with a type-safe in-memory representation of a (predefined) directory structure
17:27:25 <luite> yeah and I'm working with GHC that doesn't support those ;p
17:27:36 <rasfar> tant pis
17:27:44 <tgeeky> luite: hmm? I'm pretty sure they use GHC?
17:27:53 <tgeeky> luite: there are code repositories, but they aren't on hackage
17:29:18 <luite> tgeeky: no I mean that GHC's Finder just uses a normal directory, not some abstraction with versioning on top of that
17:30:45 <rasfar> if you used a ramdisk and atomically swapped symlinks you could probably switch versions that way?
17:31:03 <tgeeky> rasfar: that sounds... very difficult.
17:31:10 <rasfar> i'm not up-to-date on Haskell libs for interacting with filesystems, but you could probably avoid a syscall even?
17:31:39 <rasfar> (well there'd have to be one but hopefully at the FFI level provided by the API)
17:32:00 <rasfar> how do you know which version of the code is wanted at any given instant?
17:32:03 <tgeeky> luite: http://www.google.com/url?sa=t&rct=j&q=forest%20haskell%20pads&source=web&cd=6&ved=0CEwQFjAF&url=http%3A%2F%2Fwww.cs.cornell.edu%2F~jnfoster%2Fpapers%2Fforest-icfp.pdf&ei=DhVtT5CyNOGQsAKUtqiNBg&usg=AFQjCNGHy5soC2jUovLEq28ctv8iv5OGTQ
17:32:12 <tgeeky> ugh@
17:32:30 <tgeeky> luite: www.cs.cornell.edu/~jnfoster/papers/forest-icfp.pdf <--
17:33:05 <rasfar> luite: i don't think it would be difficult, honestly
17:33:24 <rasfar> but then, i always think that before i implement something....
17:35:04 <luite> rasfar: I'm just not happy with having to create symlinks for every module, every time
17:35:49 <luite> tgeeky: yeah but that's really not useful for this problem where GHC dictates how files are named
17:36:01 <rasfar> wow, the Forest authors even give you grep and tar
17:36:32 <rasfar> luite: i wish i understood why you have all these versions?
17:37:15 <rasfar> (i don't know why i'm typing "luite" this is only a 3-way conversation after all)
17:37:34 <luite> rasfar: that's not really that important
17:38:01 <luite> but the idea is that you can run code for modules before they're permanently saved to disk
17:38:02 <rasfar> i'll take your word for it; just thought it would give me some perspective.
17:38:24 <luite> and there also modules that have no permanent on-disk representation at all
17:38:32 <tgeeky> luite: hehe. this sounds exactly like what Forest was designed to do
17:38:55 <luite> yes, now convince the GHC authors to port everything to Forest...
17:39:22 <tgeeky> luite: what function did you menation earlier in the GHC API?
17:39:32 <rasfar> anyway, i'm out of ideas vOv
17:39:34 <luite> it fails at depanal
17:40:13 <luite> steps to reproduce: setTarget (some target module here that deosn't have a file on disk), depanal
17:42:53 <luite> maybe I'm doing something wrong
17:44:00 <tgeeky> luite: here's the code I can see:
17:44:02 <tgeeky> http://hackage.haskell.org/packages/archive/haddock/2.10.0/doc/html/src/Haddock-Interface.html
17:45:05 <tgeeky> luite: if you could write a function other than "withTempOutputDir" but like "withRamdiskDirectoryStructuredJustLikeINeedIt"
17:46:10 <tgeeky> luite: btw, is this just for currently editing documents, or is this a problem for all imports, upgrades, new repositories?
17:46:32 <luite> editing docs
17:46:44 <luite> but it looks like GHC should support it
17:48:00 <tgeeky> luite: could you just inject their username (or a hash of it) into the module namespace? like: Tgeeky.Data.Stream.Infinite?
17:48:27 <Axman6> @check (\p p' p0 -> p /= 0 ==> (p + p' - p0) `mod` p == p' - p0)
17:48:28 <lambdabot>   Not in scope: `==>'Precedence parsing error
17:48:28 <lambdabot>      cannot mix `GHC.Classes./=...
17:48:45 <Axman6> @check (\p p' p0 -> (p /= 0) ==> ((p + p' - p0) `mod` p) == (p' - p0))
17:48:46 <lambdabot>   Not in scope: `==>'
17:48:50 <Axman6> -_-
17:49:03 <mauke> @check False
17:49:04 <luite> tgeeky: people don't need to be logged in, and edits/errors should be under the original module name, otherwise the module Data.Stream.Infinite where declaration wouldn't match anymore
17:49:04 <lambdabot>   "Falsifiable, after 0 tests:\n"
17:49:24 <Axman6> @check (\p p' p0 -> let True ==> x = x; False ==> _ = True in (p /= 0) ==> ((p + p' - p0) `mod` p) == (p' - p0))
17:49:25 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
17:49:25 <lambdabot>    arising from a use of ...
17:49:28 <tgeeky> luite: right, I was suggesting you change that on the sly :)
17:49:45 <luite> tgeeky: yes and I was doing thatn, and don't want to do that anymore
17:49:46 <Axman6> @check (\p p' p0 -> let True ==> x = x; False ==> _ = True in (p /= 0) ==> (((p + p' - p0) `mod` p) == (p' - p0)))
17:49:47 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n1\n-3\n"
17:50:05 <luite> tgeeky: since modifying source code is really tricky
17:50:16 <Axman6> @check (\p p' p0 -> let True ==> x = x; False ==> _ = True in (p /= 0 && p > 0 && p' > 0 && p0 > 0) ==> (((p + p' - p0) `mod` p) == (p' - p0)))
17:50:17 <lambdabot>   "Falsifiable, after 44 tests:\n5\n22\n24\n"
17:50:18 <tgeeky> luite: not when there is only one valid decleration per file it's not
17:50:56 <luite> tgeeky: what would you use to change it?
17:52:28 <tgeeky> luite: hmm. I'm not sure I see what you're saying, but maybe I do?
17:52:58 <luite> tgeeky: well, you'd need to parse the haskell source, to find the declaration, change it in the AST, and then just prettyprint the AST back, right?
17:53:00 <tgeeky> you mean would you modify the AST or the source file or?
17:53:19 <tgeeky> luite: oh, for the module decleration just a search-and-replace regex
17:53:45 <luite> yes, until people start adding newlines or comments between the module and name of the thing
17:53:58 <tgeeky> luite: regex handles both of those
17:54:47 <tgeeky> luite: actually, you should propose a GSoC project to read multiple modules definitions generically, or from the same file.
17:54:48 <luite> tgeeky: {- and -} need to balance in comments, good luck
17:55:18 <tgeeky> luite: dinner. let me think about it. :o
17:57:52 <Guest72730> So, want to build an executable with cabal, but the module containing main isn't called "Main".
17:58:17 <Guest72730> Is there a way to do that?  USing GHC-Options: "-main-is 'Main.Fcgi'" doesn't appear to work.
17:59:20 <parcs`> Guest72730: Main-Is:        Main.Fcgi
17:59:40 <Guest72730> I'm already using Main-Is: Main/Fcgi.hs
18:00:00 <Guest72730> The documentation says "Main-Is" is the haskell file name, not a module name...
18:00:08 <parcs`> oh right
18:00:13 <parcs`> that doesn't work?
18:01:19 <Guest72730> Well, "cabal build" does stuff, but I get no executable.
18:01:42 <slack1256> how can i import a module that is in an upper-level directory?
18:01:43 <Guest72730> There's a warning that output was redirected with -o but no output will be generated because "Main" was not found.
18:02:16 <slack1256> I am editing a/Parsers/Stdin.hs and I want to import a/Types.hs, or that doesn't make sense?
18:02:23 <yan_> can someone recommend a simple XML parsing library? i just need to extract a collection of URLs from a feed and fetch them independently
18:02:32 <Guest72730> slack1256: Not easily.  You can list multiple hs-source-dirs in your cabal...
18:02:53 <Makoryu> yan_: I am pretty sure there are a couple
18:02:57 <Guest72730> slack1256: What's the module name in Parsers/Stdin.hs?
18:03:13 <yan_> Makoryu: sure, i've seen a couple, was just wondering about people's experiences for simple usage
18:03:14 <parcs`> Guest72730: no idea, sorry :/
18:03:20 <slack1256> Guest72730: the problem is that I should had structured differently my project right?
18:03:40 <Guest72730> slask1256: If it is Parsers.Stdin, then you can just "import Types".
18:03:48 <slack1256> Guest72730: as the path says "module Parsers.Stdin where"
18:04:03 <slack1256> ohhh
18:04:34 <Guest72730> Module names always start from the top-level.  No relative module names.
18:04:45 <slack1256> that works.
18:04:46 <slack1256> awesome
18:04:52 <slack1256> thanks Guest72730
18:05:08 <parcs`> Guest72730: fwiw a custom Main-Is works for me (ie cabal build makes an executable)
18:05:28 <Guest72730> yan_: I seem to have enjoyed by time using the Arrow-based xml library...
18:05:35 <parcs`> did you cabal clean && cabal configure after making the change?
18:05:40 <Guest72730> yan_: I can't remember the name though, maybe HXT?
18:05:56 <yan_> looks to be yeah
18:06:03 <Guest72730> Hrm, didn't "cabal clean".  I'll retry.
18:06:33 <parcs`> also consider 'xmlhtml'
18:08:13 <hpaste> “Boyd Stephen Smith Jr.” pasted “cabal stuff” at http://hpaste.org/65850
18:08:28 <Guest72730> ^^ That's my paste.
18:09:02 <parcs`> Guest72730: remove the ghc-options directive, you should need it
18:10:03 <parcs`> and the perhaps it's problematic that Main/Fcgi.hs is not under Hs-Source-Dirs?
18:10:28 <Guest72730> It's finding it, I gave the name relative to a hs-source-dir.
18:10:35 <parcs`> oh ok
18:10:52 <Guest72730> After removing the ghc-options, cleaning, and configuring, I get the same build output.
18:11:32 <parcs`> does Main/Fcgi.hs have a 'main' function?
18:11:47 <Guest72730> Yes.
18:11:58 <parcs`> then i'm clueless :P
18:12:14 <Guest72730> My manual build is something like "ghc --make -main-is Main.Fcgi Main/Fcgi.hs -o ../signature_collector.fcgi"
18:12:29 <parcs`> oh wait, i believe the directive name is Main-Is
18:12:38 <parcs`> nope
18:12:40 <parcs`> never mind
18:12:46 <Guest72730> They are case-insensitive, IME.
18:14:06 <parcs`> what is cabal --version?
18:14:42 <Guest72730> cabal-install version 0.10.2
18:14:48 <Guest72730> using version 1.10.1.0 of the Cabal library
18:15:48 <Guest72730> Ah, I got it.
18:16:04 <Guest72730>   GHC-Options:          -main-is Main.Fcgi
18:16:14 <Guest72730> No quotes.
18:17:26 <Guest72730> I guess I only need quotes if I need to pass a token containing a space.
18:18:58 <parcs`> o i c
18:19:43 <parcs`> your Main/Fcgi.hs has the module name Main.Fcgi which Main-is doesn't handle, so you do need GHC-Options
18:19:52 <otters> using scala makes me miss haskell
18:20:01 <parcs`> usually the main file doesn't have an explicit module name though
18:20:40 <Guest72730> Well, this project is likely to have serveral executables.
18:20:50 <Guest72730> SCGI, FastCGI, QtWebkit, etc.
18:21:02 <parcs`> still, why would you need to give them module names?
18:22:12 <parcs`> if you don't give an explicit module name to a source file then the module name is implicitly Main even if the filename is not Main.hs
18:24:57 <Guest72730> I guess.  Feels more organized this way, but you have a good point.
18:25:27 <Guest72730> I shouldn't be exporting anything exception "main" from them anyway, and they shouldn't be imported.
18:26:01 <Guest72730> Thanks for the help!
18:53:41 <BMeph> bbl - Windows needs restarting... :(
19:00:39 <yezariaely> I get the error message Ambiguous module name `Numeric': it was found in multiple packages: base haskell98-2.0.0.1
19:00:53 <yezariaely> how can I tell it which package to use?
19:01:15 <yezariaely> (it is a simple import statement)
19:05:33 <parcs`> ghc-pkg hide haskell98
19:08:12 <yezariaely> parcs`: can I combine this somehow with cabal-dev?
19:08:23 <yezariaely> I tried cabal-dev ghc-pkg hide haskell98
19:08:34 <yezariaely> and then afterwards ran a build again, but the same message occured
19:09:09 <parcs`> ghc-pkg --package-conf cabal-dev/packages-*.conf hide haskell98
19:10:22 <yezariaely> parcs`: hmm did not work.
19:11:04 <parcs`> as in?
19:11:42 <parcs`> can you be more specific?
19:12:06 <yezariaely> same error message as before. the command ghc-pkg ... did not say anything
19:14:45 <yezariaely> parcs`: http://pastebin.com/eUupjH7Y
19:17:03 <parcs`> try rerunning the command with 'recache' instead of 'hide'
19:19:10 <yezariaely> parcs`: same error :(
19:19:26 <parcs`> if that doesn't work then edit GeomAlgLib's .cabal file and remove haskell98 from the build dependencies. it seems that the package you are compiling is a little crufty :P
19:20:12 <yezariaely> parcs`: hehe, yes, quite old. I already tried removeing haskell98 from the cabal file. same error.
19:21:34 <yezariaely> currently trying it with a fresh cabal-dev dir. maybe there is something messed up there
19:27:06 <parcs`> any luck?
19:27:45 <brisbin> if you give your type an instance for Default, are you supposed to export def or does your end-user have to depend on data-default and import it themselves?
19:31:03 <parcs`> brisbin: provide a Default instance but also provide a defaultFoo = def :: Foo synonym?
19:31:36 <brisbin> parcs`: hmm. i want the lib-user to use def, otherwise i'd skip Default
19:32:00 <brisbin> i chose to export it, but then it shows up in my haddocks with the docs from data-default :/
19:32:29 <parcs`> i  would skip Default, then :P
19:32:30 <JoeyA> I like the defaultFoo idea.  Providing a specific instance makes it easier to avoid ambiguity.
19:33:02 <JoeyA> For example, cereal (Data.Serialize) provides putWord8, even though put can be used to the same effect.
19:33:20 <brisbin> that's fair, but it begs the question -- what then is Data.Default useful for?
19:33:52 <brisbin> i like the idea of all these defaultMyType and defaultYouType being simplified to just def via a known type class
19:34:09 <JoeyA> In that case, have the user import Data.Default.
19:34:25 <JoeyA> You have to import Data.Monoid to use mappend, for example.
19:34:26 <brisbin> ok. you prefer than over my module exporting def
19:34:34 <JoeyA> Usually, yes.
19:34:50 <brisbin> cool, noted.
19:34:52 <brisbin> thanks
19:40:51 <luite> tgeeky: I've almost solved it, I think... just getting a linker error when there's no module name
19:46:55 <JoeyA> @hoogle die
19:46:56 <lambdabot> Network.HTTP.Base DieHorribly :: String -> ResponseNextStep
19:46:56 <lambdabot> package eddie
19:46:56 <lambdabot> GHC.Conc.Sync ThreadDied :: ThreadStatus
19:54:06 <vodik> hmm, how would i convert a Float into a GLfloat? (or CFloat which, as i understand, is what GLfloat is bound to)?
19:58:45 <vodik> oh, nm, wasn't calling realToFrac properly
19:58:47 <vodik> that works
19:59:20 <yezariaely> parcs`: no, no luck. I have given up. Maybe I can do without the library
20:30:16 <shapr> wheeeeee
20:30:26 <shapr> It's spring break! Time to write code!
20:39:48 <seanhess> I'm making a little REST-API MMO game. I have an HTTP API that will let players set their action, and I was thinking of having a second haskell program run a game loop that checked for player actions and updated the game state, storing it in the database. I'm new to game programming. Would you use a timer? Any general advice?
20:40:41 <dmwit> huh
20:41:39 <dmwit> seanhess: Use a timer? Why not run your code when the server gets a request?
20:42:31 <seanhess> I thought that "real" games used some kind of an internal tick. From a pratical standpoint, it's actually a programming game: clients are programs written by players to play the game, so I need a way to throttle their actions. Should I just build in a throttle instead?
20:43:02 <dmwit> Perhaps I just don't know enough to make a meaningful answer, then.
20:43:16 <napping> If you want a timer that works okay
20:43:34 <napping> if you don't, it can end up coming down to who sends orders fastest
20:43:49 <seanhess> I'm not sure I want a timer. I do need some way to throttle, but I'm curious to know more about how normal games are designed.
20:43:51 <napping> but if it's a programming game you might not mind?
20:44:00 <dmwit> hpaste.org seems down
20:44:03 <seanhess> I guess most games don't care if players move too quickly
20:44:17 <dmwit> Or, wait, maybe not.
20:44:20 <seanhess> yeah, well, I would rather the game be about tactics than knowing how to send http requests quickly
20:44:42 <dmwit> http://hpaste.org/65854 <- could somebody take a look and see if they think it's a bug that this doesn't compile?
20:45:00 <napping> When I wrote that sort of thing it worked well enough to run the game steps on a timer
20:45:13 <napping> and just stash the requests somewhere when they arrive
20:45:27 <seanhess> that's what I was most recently thinking
20:45:42 <napping> It was a local contest, so we didn't worry much about oversized requests and that sort of thing
20:46:19 <roconnor> dmwit: currly braces missing?
20:46:29 <dmwit> roconnor: compiles in 7.2.2
20:46:36 <dmwit> so I don't think it's a brace issue
20:46:47 <roconnor> > let a = 5; b = 6 in (a,b)
20:46:48 <lambdabot>   (5,6)
20:46:50 <seanhess> Excuse my lack of skill at haskell, but how would I write a recurring timer in haskell? Just loop in main and see if enough time has passed?
20:46:50 <roconnor> oooh
20:46:58 <dmwit> roconnor: Doesn't compile with layout or explicit braces, either.
20:47:13 <dmwit> roconnor: The error is a long one; I should have pasted it. I'll do that, one sec.
20:47:23 <napping> make a thread that sleeps for long enough
20:47:31 <napping> well, that's separate
20:47:36 <napping> but call threadDelay to wait
20:47:41 <roconnor> @type random
20:47:42 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
20:47:54 <hpaste> dmwit annotated “GHC 7.4.1 regression?” with “GHC 7.4.1 regression? (annotation)” at http://hpaste.org/65854#a65855
20:48:34 <seanhess> napping: ooh, threading. I have a feeling my butt is about to get kicked again
20:49:01 <dmwit> seanhess: You don't need (multi)threading to use threadDelay.
20:49:57 <napping> it's the easiest way to have a timer loop, and be listening on a bunch of sockets
20:50:09 <dmwit> Oh, sure.
20:50:19 <dmwit> I was thinking multi-processing. =P
20:50:58 <dmwit> roconnor: For bonus points, it also compiles without NoMonomorphismRestriction. (!)
20:51:01 <seanhess> I'm already using an event-based http server, so I've got that covered, just need to figure out how to do the game processing
20:51:26 <dmwit> (I'm much more used to it being the other way.)
20:52:12 <napping> what server?
20:52:45 <seanhess> The game runs on a server, and listens for commands to come in over http
20:52:54 <seanhess> stores the game state in the database
20:53:00 <seanhess> oh, you  mean which one
20:53:10 <seanhess> I'm using scotty, which is built on WAI / Warp
20:53:20 <seanhess> supposed to be pretty good, right?
20:54:01 <napping> it seems to tie up your main thread
20:54:01 <seanhess> http://hackage.haskell.org/package/scotty-0.2.0
20:54:11 <napping> so forkIO the timer loop before you start the server
20:54:26 <seanhess> right. hence my idea to have a 2nd program running the game server, but you're probably right, I can just forkIO
20:55:05 <seanhess> sorry "2nd programming running the game loop"
20:55:15 <seanhess> bah, can't type
20:55:37 <napping> it would still have to get messages, and sleep
20:55:47 <napping> even if the messages are parsed and cleaned up
20:57:37 <napping> have you used threads at all?
20:58:33 <seanhess> Not in haskell, no
20:58:55 <seanhess> But the threads could communicate through the database. Is it pretty easy to get them to communicate?
20:59:27 <napping> yeah
20:59:40 <seanhess> "get messages" - I'm assuming you mean having the threads message each other somehow
20:59:52 <seanhess> "even if the messages are parsed and cleaned up" - I don't know what this means
21:00:20 <napping> no, I was saying if you split it into two programs, the one that's doing the game logic still has to handle incoming commands but also wait until the right time to take a turn
21:01:04 <seanhess> so you'd recommend forking off the main program?
21:01:30 <napping> I'd recommend making a thread for the game loop
21:02:49 <seanhess> ok. I'm planning on not having the threads communicate at all. Instead, I'd have the game loop query the db for actions and update the db. Good plan?
21:03:08 <dmwit> Ah, hell, I'm already using five extensions. What's one more?
21:03:11 <seanhess> Clients get the updated state by polling the HTTP server
21:03:28 <napping> sounds a lot heavier than tossing the incoming request in a TVar, but probably works
21:03:45 <seanhess> ooh, I want to hear more about that. Have a good link for me?
21:04:25 <napping> http://hackage.haskell.org/package/stm
21:04:59 <napping> It's not quite as simple as MVars, but you might want a bit more than you can easily do with mvars
21:06:43 <napping> actuall, look at Control.Concurrent.MVar from base first
21:07:35 <seanhess> ok
21:09:43 <napping> now that I'm looking, it doesn't actually give you a swap
21:11:01 <dmwit> Ah, it's not a regression, it's an intentional change. Yikes!
21:11:16 <napping> so even for that stm might be simplest
21:12:27 <napping> are clients send lists of commands?
21:13:09 <seanhess> lists? They call the server to say what their current action is. It has to be one of a couple options
21:13:10 <napping> If they make a second request before the first is handled, what should happen?
21:13:18 <seanhess> replace the first, I think
21:13:23 <napping> (that's actually what I meant to ask)
21:13:32 <seanhess> Or respond with "you are moving too fast"
21:13:42 <napping> so you'd have per player (maybe set up when starting the game) a TVar (Maybe Command)
21:14:26 <napping> once you've got a request, atomically (writeTVar myTVar mycommand)
21:14:38 <napping> in the request handler, run in whatever thread the server feels like
21:15:25 <napping> then when the game loop wants to proces it does something like atomically (sequence [swapTVar player Nothing | player <- players)
21:16:00 <seanhess> super cool
21:16:08 <napping> which will get the orders, zero them out, and not have any risk of erasing an order if a new one arrives at the wrong time
21:16:32 <napping> sequence [atomically (swapTVar player Nothing) | player <- players]
21:16:43 <seanhess> I'll go play with it. Thanks so much for your help!
21:17:21 <napping> It's nice
21:26:09 <mzero> what's the name of the tool that can draw a graph of Haskell module relationships?
21:28:00 <mzero> sourcegraph
21:28:04 <mzero> there, answered it myself
21:28:20 <dmwit> Nice try, sourcegraph author!
21:28:22 <dmwit> ;-)
21:29:08 <mzero> no no - I'm not - honest!
21:30:55 <BMeph> That _is_ a good question ("What happened to Systems A through E?") ;)
21:37:37 <endojelly> ps-auxw, so, where in germany are you from?
22:29:16 <dmwit> ?djinn (a -> a) -> (Maybe a -> Maybe a)
22:29:16 <lambdabot> f a b =
22:29:16 <lambdabot>     case b of
22:29:17 <lambdabot>     Nothing -> Nothing
22:29:17 <lambdabot>     Just c -> Just (a c)
22:30:03 <dmwit> Now, how hard does djinn try to use its arguments...?
22:30:06 * hackagebot OpenAL 1.4.0.1 - A binding to the OpenAL cross-platform 3D audio API  http://hackage.haskell.org/package/OpenAL-1.4.0.1 (AndrewMiller)
22:30:10 <dmwit> ?djinn (a -> a) -> a -> (Maybe a -> Maybe a)
22:30:10 <lambdabot> f a b c =
22:30:10 <lambdabot>     case c of
22:30:10 <lambdabot>     Nothing -> Just (a b)
22:30:10 <lambdabot>     Just d -> Just d
22:30:15 <dmwit> Wow! Very hard.
22:31:10 <dmwit> ...especially considering I gave it the wrong type. =P
22:31:21 <dmwit> ?djinn (a -> b) -> b -> (Maybe a -> Maybe b)
22:31:21 <lambdabot> f a b c =
22:31:21 <lambdabot>     case c of
22:31:21 <lambdabot>     Nothing -> Just b
22:31:21 <lambdabot>     Just d -> Just (a d)
22:31:30 <dmwit> ?hoogle (a -> b) -> b -> (Maybe a -> Maybe b)
22:31:30 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
22:31:30 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
22:31:30 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
23:30:44 <rekahsoft> hey peter where have you been all day?
23:30:56 <rekahsoft> damb wrong chan ** sorry guys
23:48:49 <RealPoo> ##diarrhea
23:48:55 <RealPoo> the support group for Haskell programmers
23:49:02 <RealPoo> with chronic intestinal disorders
23:49:05 <RealPoo> or paraphilias
23:49:08 <RealPoo> like coprophilia
23:49:14 <RealPoo> or coprophagy
23:49:20 <RealPoo> join ##diarrhea today
23:52:14 --- mode: ChanServ set +o Saizan
23:52:19 --- mode: Saizan set +b *!*n1gg3rs@*.171.0.192.dsl.dyn.telnor.net
23:52:20 --- kick: RealPoo was kicked by Saizan (RealPoo)
