00:12:20 <hiptobecubic> does lyah have a bug tracker? i found a typo :)
00:12:49 <Cale> I wonder why BONUS fell off the face of IRC
00:12:55 <Cale> He used to hang around here a lot
00:13:12 <Cale> preflex: seen BONUS
00:13:13 <preflex>  BONUS was last seen on #haskell 308 days, 12 hours, 45 minutes and 13 seconds ago, saying: yeah i think that's better as well
00:13:18 <Cale> and then nothing
00:13:53 <edwardk> he done learned himself a haskell and moved on
00:16:10 * ddarius now has a Joy interpreter that can FFI to Java.
00:18:28 <edwardk> ddarius: nice
00:19:16 <ddarius> As far as I know, there is no sane way to subclass another class via reflection, so I'll still have to write a bunch of adapters.
00:20:21 * hackagebot KMP 0.1.0.1 - KnuthMorrisPratt string searching algorithm  http://hackage.haskell.org/package/KMP-0.1.0.1 (CindyLinz)
00:30:11 <edwardk> ddarius: you should be able to steal something from one of the mock object classloaders
00:31:29 <Enigmagic> ddarius: http://asm.ow2.org/
00:32:51 <yitz> ddarius: what is Joy? (sounds philosophical, i know, but...)
00:33:07 <Sgeo_> A concatenative language
00:33:26 <yitz> link?
00:33:54 <yitz> (since "joy" would be a slightly annoying google search)
00:34:01 <Sgeo_> http://www.latrobe.edu.au/phimvt/joy.html
00:34:06 <yitz> tnx
00:34:10 <Sgeo_> Joy programming language is not an annoying google search
00:34:17 <yitz> ok :)
00:34:31 <Sgeo_> That page seems unhelpful
00:34:37 <MostAwesomeDude> I prefer Factor, which *is* hard to search for. :3
00:34:45 <Sgeo_> Oh, just scroll down
00:36:42 <Sgeo_> MostAwesomeDude, problem, Slava lost interest.
00:37:31 <ChristianS> reading through http://en.wikipedia.org/wiki/Joy_%28programming_language%29 , Joy doesn't sound too joyful to me...
00:38:44 <MostAwesomeDude> Sgeo_: I can see
00:38:52 <MostAwesomeDude> Sgeo_: *how that would be a problem.
00:42:30 <adit> Anyone care to answer a question about Monad Transformers at this ungodly hour?
00:43:11 <shachaf> adit: Not unless you ask it. :-)
00:43:52 <hpaste> adit pasted “monad transformer sig” at http://hpaste.org/64725
00:44:12 <adit> I'm trying to understand the signature of `test3` here
00:44:38 <adit> @hoogle StateT
00:44:38 <lambdabot> Control.Monad.State.Lazy StateT :: (s -> m (a, s)) -> StateT s a
00:44:38 <lambdabot> Control.Monad.State.Strict StateT :: (s -> m (a, s)) -> StateT s a
00:44:38 <lambdabot> Control.Monad.Trans.State.Lazy StateT :: (s -> m (a, s)) -> StateT s m a
00:46:00 <shachaf> I'm not sure where "StateType" is coming from.
00:46:06 <Peaker> I'm actually surprised that the result type is (StateType (..), [Char]) rather than (Integer, [Char])
00:46:12 <Peaker> seems like some sort of unexpanded type-family
00:46:18 <adit> Yeah, that's what's confusing me
00:46:26 <adit> @hoogle MonadState
00:46:27 <lambdabot> Control.Monad.State.Class class Monad m => MonadState s m | m -> s
00:46:27 <lambdabot> Control.Monad.State.Lazy class Monad m => MonadState s m | m -> s
00:46:27 <lambdabot> Control.Monad.State.Strict class Monad m => MonadState s m | m -> s
00:46:40 <adit> Here's how MonadState is defined:
00:46:40 <adit> class (Monad m) => MonadState m where
00:46:41 <adit>     type StateType m
00:46:58 <adit> Lazy.StateT:
00:46:59 <adit> instance (Monad m) => MonadState (Lazy.StateT s m) where
00:46:59 <adit>     type StateType (Lazy.StateT s m) = s
00:47:07 <shachaf> Are you using a nonstandard library that defines these things?
00:47:13 <yitz> ok then. how easy is it to write a compiler from Haskell to Joy? if tractable, then we've got our Haskell to JVM compiler.
00:47:15 <shachaf> I think the regular StateT still uses fundeps.
00:47:29 <Peaker> mtl uses fundeps
00:47:32 <adit> This is monads-tf
00:47:33 <yitz> or if you prefer, s/Haskell/GHC external core/
00:47:51 <Peaker> I'd still expect ghc to expand:  StateType (<concrete type here>) to a concrete type
00:47:56 <covi> Does haskell have a built-in function that returns a list of all divisors of a number?
00:48:00 <shachaf> yitz: I don't think anyone has ever said that compiling Haskell to the JVM is difficult as such -- only doing it efficiently.
00:48:11 <Peaker> adit: which ghc version are you using?
00:48:11 <shachaf> covi: No. Haskell is not designed for Project Euler.
00:48:18 <adit> 7.0.2
00:48:20 <covi> shachaf: ...
00:48:30 <covi> shachaf: how do you know I'm fretting over PE?
00:48:42 <shachaf> covi: Because that's the only reason people ever ask that question in here.
00:48:49 <adit> hahaha
00:48:54 <covi> shachaf: (by fretting over I mean I don't... think Haskell is particularly suitable for tasks in PE)
00:49:02 <yitz> shachaf: it's nice to say that. but even if you don't care about efficiency, there is no practical way to compile Haskell to the JVM currently. all existing projects i know of are hopelessly bitrotted.
00:49:07 <shachaf> adit: Did you install monads-tf in order to learn about type families?
00:49:20 <shachaf> yitz: I'm pretty sure there's an x86 emulator written in Java or something like that.
00:49:23 <shachaf> So there you go.
00:49:50 <shachaf> covi: Haskell is probably about as suitable as any other language for most problems there.
00:49:51 <adit> shachaf: Long story short, I started a project that made me learn more about Monad Transformers
00:49:56 <yitz> shachaf: well, there's virtual box :)
00:50:03 <adit> specifically their signatures, which are throwing me off
00:50:28 <covi> shachaf: .... I can't even calculate f[20][20] where f[i][j] = f[i-1][j] + f[i][j-1], after reading half of lyah
00:50:30 <shachaf> adit: But somehow you ended up with monads-tf instead of the standard library?
00:50:39 <yitz> shachaf: anyway, no, obviously there is a limit to "don't care about efficiency".
00:50:53 <Peaker> ghc-7.4 yields:  test3 :: (Num (StateType (t m)), MonadTrans t, MonadState (t m), MonadState m, StateType m ~ [Char]) => t m (StateType (t m), [Char])
00:51:06 <shachaf> yitz: I doubt that compiling via Joy is a practical way to get Haskell running on the JVM.
00:51:13 <adit> What is the standard library? It's possible I fudged with my install and then forgot about it :P
00:51:30 <Peaker> and if I fix the Num type to be Integer:  test3 :: (MonadTrans t, MonadState (t m), MonadState m, StateType (t m) ~ Integer, StateType m ~ [Char]) => t m (Integer, [Char])
00:51:32 <yitz> shachaf: yeah you're probably right
00:51:40 <c_wraith> I hope StateType is a type family
00:51:41 <edwardk> adit: for monad transformers? mtl
00:51:47 <adit> ok
00:52:10 <shachaf> covi: Learning Haskell -- the interesting parts of learning Haskell, anyway -- is more of a matter of learning to think in a different way about problems like that than about the typical thing you'd learn with a new language.
00:52:14 <Peaker> Oh, I've got the NoMonomorphismRestriction, probably, which means the "main" isn't helping the type
00:52:41 <edwardk> adit: the definitions of the monads themselves lie in 'transformers', and 'mtl' contains a bunch of classes you can use with them to make it so you don't have to lift (lift get) all over your code
00:52:42 <shachaf> covi: If you're calculating Pascal's triangle or something like that, well, there are a bunch of nice Haskell solutions that I think people mentioned earlier in IRC.
00:52:44 <adit> Peaker: that looks a lot clearer. That's what I was expecting
00:52:46 <covi> shachaf: you're so right. I haven't mastered that new way of thinking yet. Lyah does not teach that
00:52:49 <Peaker> ah, here goes, with the MR: test3 :: StateT Integer (StateT [Char] Identity) (Integer, [Char])
00:53:16 <adit> edwardk: cool. I will start using those then. Thanks!
00:53:22 <Peaker> adit: do you know the MonomorphismRestriction?
00:53:37 <covi> shachaf: It's so different from Pascal's triangle, where a new row only depends on the previous row. In this case, f[i][j] depends on row i and row i-1 simultaneously.
00:53:38 <adit> Peaker: Yes. Do you have it turned on?
00:53:38 <Peaker> edwardk: The O(N^2) code explosion lifters are annoying :)
00:53:52 <edwardk> peaker: they are slightly annoying to write, but they are nice to use
00:54:01 <shachaf> covi: Oh, right.
00:54:04 <edwardk> and since i'm the poor bastard stuck maintaining them.. . =P
00:54:13 <Peaker> I think it's much nicer to just newtype your Monad stack and give names to each of the lifted layers explicitly... Who says you've got just one of each kind of transformer in your stack anyway?
00:54:16 <shachaf> covi: Well, even so, I assure you that Haskell has an elegant way of expressing that problem.
00:54:39 <covi> shachaf: I know it has :)
00:54:51 <adit> Yes
00:55:01 <edwardk> you're welcome to do so, but its nice for folks to be able to just make a monad out of a few transformers to satisfy a set of constraints placed on them by using 'get', 'tell', etc.
00:55:04 <adit> It would make these signatures a lot easier to read too :P
00:55:14 <shachaf> covi: Anyway, I don't recommend Project Euler as a way of learning a new language.
00:55:32 <c_wraith> It's a great way to learn math, though
00:55:33 <covi> shachaf: why?
00:55:36 <Peaker> edwardk: It might have unknown semantics if they just leave it as a set of constraints, might it not?
00:55:51 <Peaker> edwardk: whether the "tell" is behind or in front of an exception monad matters
00:55:53 <shachaf> covi: Because it has little to do with programming (for example).
00:55:54 <c_wraith> covi: project Euler mostly depends on knowing sophisticated math.  Which is almost unrelated to programming
00:55:56 <edwardk> yes
00:56:06 <edwardk> and they choose those semantics by supplying the instance
00:56:12 <edwardk> its not perfect
00:56:29 <Peaker> It means the code itself has no useful meaning on its own
00:56:56 <edwardk> most of the time users wind up with one or two constraints
00:57:09 <edwardk> and error is unfortunate, but most of the others commute
00:59:49 <adit> TIL about type families
00:59:59 <adit> That answered another question I had :)
01:02:10 <Peaker> adit: and TIL that GHC 7.0.3 allows type functions whose result is known in compile-time to remain/appear in the type
01:02:20 <Peaker> it was apparently fixed by GHC 7.4
01:04:09 <adit> What is a type function?
01:05:13 <c_wraith> type families are functions (of a limited sort) on types
01:06:06 <adit> yeah, it allows you to specify the types that if produces based on another parameterized type afaict
01:06:13 <adit> Reading through http://www.haskell.org/haskellwiki/GHC/Type_families now
01:06:50 <Peaker> class Monad m => MonadState m where type family StateType m :: *   <-- "StateType" is a type function, takes a monad "m" as an argument, and returns the state associated with it
01:07:43 <Peaker> adit: in your example, ghc 7.0.3 put: "StateType (StateT ..)" in your type signature, despite knowing exactly what StateType of StateT is already
01:07:57 <Peaker> ghc 7.4 replaced that, sanely, with just "Integer"
01:08:10 <adit> Ah I see
01:08:24 <adit> So a type function returns a type
01:09:13 <adit> data family Test a
01:09:13 <adit> data instance Test Char = MyChar
01:09:13 <adit> data instance Test Int = MyInt
01:09:18 <Peaker> adit: yeah.. it maps types to other types.. it's allows to be a partial function that only works if the input type is an instance of a type-class
01:09:18 <adit> Here, Test is a type function
01:09:35 <Peaker> adit: Yeah
01:09:40 <adit> Gotcha :)
01:13:18 <covi_> Can someone please check out the error in this code please? http://hpaste.org/64726
01:15:38 <mjrosenb> covi_: what is the result of amiciable 6?
01:15:53 <c_wraith> covi_: you wrote properdivisors in a really strange way.  Why not just a filter?
01:16:47 <covi_> mjrosenb: True
01:17:12 <covi_> c_wraith: my bad. I haven't been completely brainwashed by haskell
01:18:38 <mjrosenb> covi_: hint: I already know exactly what is wrong with your code.
01:18:52 <covi_> mjrosenb: and that's?
01:19:23 <mjrosenb> covi_: it is a project euler problem, i'm not going to just tell you what it is
01:19:47 <covi_> ..
01:20:39 <adit>     where amicable x = d x == (d $ d x)
01:20:45 <mjrosenb> covi_: hint: my previous hint was suggesting that True is in fact not the answer.
01:21:38 <covi_> what the heck...
01:21:40 <covi_> thanks man
01:24:25 <covi_> :r
01:50:26 * hackagebot HsOpenSSL 0.10.1.3 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.1.3 (MasatakeDaimon)
01:53:47 <efie> is in the sense of functional programming to use the ListStore a data type? ( http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-ModelView-ListStore.html ) I mean, the functions like listStoreInsert don't give a new ListStore back but only work on the same Data Store.This does not feel functional to me
01:55:33 <Saizan> gtk is imperative, and gtk2hs doesn't try to hide that
01:56:48 <haskellnoob> Hi. I am trying to understand the following function :
01:56:51 <haskellnoob> maybeRead :: (Read a) => String -> Maybe a
01:56:51 <haskellnoob> maybeRead = fmap fst . listToMaybe . filter (null . dropWhile isSpace . snd) . reads
01:57:07 <haskellnoob> (This is from a SO question : http://stackoverflow.com/questions/9552738/haskell-laziness-affected-by-parsing-method)
01:57:25 <haskellnoob> So first I looked at the function "reads" from the Prelude
01:57:38 <efie> you mean http://stackoverflow.com/questions/9551615/haskell-read-a-number-integer-or-floating-point
01:58:49 <haskellnoob> When I try : reads "abc" on the ghci command line, then I get an error saying "ambiguous type variable ..."
01:59:37 <haskellnoob> efie: no I meant the question to which I linked
01:59:46 <Saizan> haskellnoob: are you familiar with typeclasses?
01:59:49 <efie> haskellnoob: ok, sorry
01:59:53 <haskellnoob> Saizan: a bit
01:59:57 <haskellnoob> efie: no problem
02:01:32 <haskellnoob> my first doubt is: to what type of thing is the "reads" in the maybeRead function applied?
02:01:40 <Saizan> haskellnoob: reads "abc" doesn't know which Read instance to use because it has no info on what the type of the result should be
02:02:10 <Saizan> haskellnoob: the 'a' from the signature
02:02:36 <Saizan> well, the argument is String
02:02:40 <haskellnoob> Saizan: so does Haskell figure out the correct type of 'a' from the context in which maybeRead is used later?
02:02:51 <Saizan> but it'll return a ReadS a
02:02:52 <haskellnoob> Saizan: that is why I tried to apply it to a string
02:03:00 <Saizan> haskellnoob: yep
02:03:02 <zerax> > ( reads :: ReadS Int ) 123
02:03:03 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
02:03:03 <lambdabot>    arising from the literal `...
02:03:10 <zerax> > ( reads :: ReadS Int ) "123"
02:03:10 <lambdabot>   [(123,"")]
02:03:10 <zerax> even
02:03:22 <haskellnoob> zerax: thanks
02:03:38 <haskellnoob> Saizan: thanks. Let me now try to figure the rest out.
02:03:59 <haskellnoob> (I Maybe back ;) )
02:05:36 <mysticc> @hoogle Handle -> FilePath
02:05:36 <lambdabot> System.IO hGetContents :: Handle -> IO String
02:05:36 <lambdabot> GHC.IO.Handle hGetContents :: Handle -> IO String
02:05:36 <lambdabot> System.IO hGetLine :: Handle -> IO String
02:06:28 <mysticc> Can we get filePath back from a handle ??
02:06:49 <Saizan> no
02:07:10 <Saizan> you can have Handle's which are not backed by files
02:08:31 <Enigmagic> on windows you can get the filename if there is one (though there may be more than one) http://msdn.microsoft.com/en-us/library/windows/desktop/aa364388(v=vs.85).aspx
02:09:19 <zerax> Is there any posix support for it?
02:09:41 <Enigmagic> i don't think so
02:10:35 <zerax> I guess in most cases you probably have the original filename available somewhere, you just need to keep track of it.
02:10:48 <zerax> mysticc: What's the goal?
02:11:24 <mysticc> I was passing handle to some functions ... now I needed fileName .. so I will have to pass fileName too now ..
02:12:20 <mysticc> zerax: ^^
02:13:49 <geekosaur> POSIX does not provide a mechanism, and in general Unix does not support one.  (You can sometimes dig one out of /proc on linux, but this is not portable and may not be entireky reliable because it's caching information that can change out from under it)
02:46:00 <everythingWorks> =)
02:49:28 <shergill> does anyone have a working link to cale's article on "how to use monad transformers", the link in typeclassopedia doesn't seem to work
02:50:13 <Cale> shergill: that was on my old harddrive which is having problems
02:50:17 <everythingWorks> Is game development in haskell cool? ;)
02:50:33 <Cale> everythingWorks: yeah, it's interesting :)
02:50:48 <everythingWorks> Cale: what did you made for now? :D
02:52:58 <Cale> everythingWorks: Well, I did a bunch of the AIs and the basic combat mechanics with melee and projectile attacks. Lately I've been putting lots of work into our FRP system, trying to make it a good bit faster. There are lots of opportunities we still need to take advantage of there.
02:53:45 <everythingWorks> cool! :D
02:54:26 <Cale> oh, and before that I wrote a bunch of the game GUI code which I still need to port to the new system :)
03:04:28 <zerax> Cale, you mentioned before that there was some possibility that the more general improvements to libraries could be contributed to Hackage, is that still the case?
03:05:32 <zerax> I could imagine licensing never makes such things easy
03:05:43 <Cale> zerax: Or to GHC itself. We'll have to decide exactly where to cut things, but yeah, hopefully we can get at least the basic changes to the Arrow library out there.
03:06:11 <Cale> We own the rights on all our code, so I don't imagine it'll be an issue once we decide what to release.
03:06:29 <zerax> Interesting
03:20:40 <k0ral> @hoogle getHomeDirectory
03:20:41 <lambdabot> System.Directory getHomeDirectory :: IO FilePath
03:23:02 <haskellnoob> If I install hoogle on my machine (Mac, Haskell Platform 2011.4.0.0), will I be able to access it using a browser? The manual for hoogle (http://www.haskell.org/haskellwiki/Hoogle) does not answer this either way.
03:24:03 <mjrosenb> haskellnoob: i believe hoogle by default is just a cli program, it does not have a built in web server.
03:24:31 <haskellnoob> mjrosenb: thanks
03:34:14 <statusfailed> Is there something like "maybe" but for []?
03:35:50 <mauke> foldr
03:36:46 <statusfailed> derp
03:37:14 <statusfailed> oh wait, no- I want something like foldl1 with a default value for []
03:37:55 <statusfailed> (where the default is not included if the list contains elements)
03:39:50 <osa1_> does anyone know what's haskell sdl binding of this http://sdl.beuc.net/sdl.wiki/SDL_GetKeyState ?
03:40:35 * hackagebot hoogle 4.2.10 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.10 (NeilMitchell)
03:41:57 <k0ral> @hoogle </>
03:41:58 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
03:41:58 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
03:46:13 <osa1_> @hoogle ($=)
03:46:13 <lambdabot> No results found
03:53:34 <statusfailed> > sequence [] :: (Maybe [a])
03:53:35 <lambdabot>   Just []
03:53:55 <statusfailed> :\
03:54:13 <statusfailed> Shouldn't that be Nothing ?
03:55:15 <srhb> statusfailed: No, why?
03:55:37 <statusfailed> Because I want a function that gives me nothing :p
03:55:47 <alpounet> const Nothing ?
03:55:49 <alpounet> :P
03:55:54 <srhb> statusfailed: Can't you just interpret [] as nothing?
03:56:03 <statusfailed> srhb: code golf~
03:56:06 <srhb> Aha.
03:56:49 <srhb> What exactly are you golfing?
03:56:55 <statusfailed> fizzbuzz
03:57:25 <statusfailed> but more using it as an exercise to learn Applicative and some other bits
03:58:17 <srhb> So you want to transform a list [1..] to.. What?
03:58:28 <mauke> perl -le 'print"F"x!($_%3).b x!($_%5)||$_ for 1..23'
03:58:50 <srhb> Hah
03:58:55 <srhb> That is nice. And nasty. :P
03:59:43 <statusfailed> mauke: Is that the one from the reddit post?
04:00:23 <mauke> dunno
04:00:39 <statusfailed> oh, it's not anyway :p
04:00:39 * hackagebot imm 0.1.1.0 - RSS-to-maildir tool  http://hackage.haskell.org/package/imm-0.1.1.0 (koral)
04:02:42 <hpaste> ClaudiusMaximus pasted “does this idiom have a name?” at http://hpaste.org/64728
04:07:03 <yitz> > listToMaybe [] -- srhb
04:07:04 <lambdabot>   Nothing
04:08:31 <alpounet> he wants [a] -> Maybe [a] apparently
04:08:56 <srhb> yitz, alpounet: Not me, statusfailed.
04:09:04 <yitz> srhb: oh sorry
04:09:12 <yitz> > listToMaybe [] -- statusfailed
04:09:13 <lambdabot>   Nothing
04:09:21 <yitz> alpounet: return
04:09:30 <alpounet> heh yeah i guess :p
04:09:32 <osager> hi all, i'm on arch linux and i've installed ghc and i want to install all other packages through cabal. but i notice that after install ghc, there's already some packages installed(ghc-pkg list), my question is will these pacakges be in conflict with cabal. coz i used to get circle dependency
04:09:40 <alpounet> not very useful though
04:10:13 <alpounet> oh maybe it's [Maybe a] -> Maybe [a] in which case it's sequence indeed
04:10:16 <alpounet> anyway.
04:10:17 <osager> and shall i use ghc-pkg unregister to remove these packages ?
04:10:43 <yitz> osager: no don't do it!
04:11:03 <osager> yitz: :) thanks
04:11:22 <osager> yitz: so i just continue to install other packages with cabal
04:11:36 <osager> yitz: for example xmonad
04:11:38 <yitz> osager: those are the base libraries that come with ghc. don't touch them, or ghc will be broken.
04:11:49 <osager> yitz alright
04:11:56 <osager> so far i have [elflord@OldPapa ~]$ ghc-pkg list
04:11:56 <osager> /usr/lib/ghc-7.4.1/package.conf.d
04:11:56 <osager>    Cabal-1.14.0
04:11:56 <osager>    array-0.4.0.0
04:11:56 <osager>    base-4.5.0.0
04:11:57 <osager>    bin-package-db-0.0.0.0
04:11:59 <osager>    binary-0.5.1.0
04:12:01 <osager>    bytestring-0.9.2.1
04:12:03 <osager>    containers-0.4.2.1
04:12:05 <osager>    deepseq-1.3.0.0
04:12:07 <osager>    directory-1.1.0.2
04:12:11 <osager>    extensible-exceptions-0.1.1.4
04:12:13 <osager>    filepath-1.3.0.0
04:12:15 <osager>    ghc-7.4.1
04:12:17 <osager>    ghc-prim-0.2.0.0
04:12:19 <osager>    haskell2010-1.1.0.1
04:12:20 <osager>    haskell98-2.0.0.1
04:12:20 <yitz> osager: yeah just go ahead and install. cabal does get confused occasionally, but don't be tempted to touch those packages in that case.
04:12:22 <osager>    hoopl-3.8.7.3
04:12:24 <osager>    hpc-0.5.1.1
04:12:26 <osager>    integer-gmp-0.4.0.0
04:12:28 <osager>    old-locale-1.0.0.4
04:12:30 <osager>    old-time-1.1.0.0
04:12:32 <osager>    pretty-1.1.1.0
04:12:34 <osager>    process-1.1.0.1
04:12:36 <osager>    rts-1.0
04:12:40 <osager>    template-haskell-2.7.0.0
04:12:42 <osager>    time-1.4
04:12:44 <yitz> osager: please use hpaste for that kind of thing
04:12:44 <osager>    unix-2.5.1.0
04:12:46 <osager> are thse packages all base pacakges and essential ?
04:12:48 <osager> ok sorry
04:12:50 <yitz> @hpaste
04:12:51 <lambdabot> Haskell pastebin: http://hpaste.org/
04:13:06 <alpounet> osager, yes they are
04:13:35 <osager> and the Cabal is not the same as cabal install cabal ?
04:14:33 <srhb> What are pipes good for? Does anyone know some example code out there?
04:14:55 <yitz> osager: the cabal command comes from the cabal-install package. that uses the Cabal library, a general interface for managing packages.
04:15:02 <alpounet> srhb, it's a kind of alternative to conduit, iteratees, etc AFAIK
04:15:40 <osager> OK I see. Really thank you guys for the patience
04:28:19 <joe9> i just upgraded to ghc 7.4.1. when I try "cabal install cabal-install", it does not work. gives me these errors: http://codepad.org/xLZEI8bC
04:28:43 <joe9> cabal install unix --reinstall, works. http://codepad.org/bmSvUKAf
04:29:00 <joe9> any suggestions on how I can get cabal usable?
04:30:38 <joe9> ghc-pkg list says this: http://codepad.org/unVJUQb2
04:31:13 <joe9> cabal --version says this: http://codepad.org/8FXBZq7c
04:33:15 <sanjoyd> Is there some way to say 'instance (Not X s) => Y s' where X and Y are typeclasses?
04:33:40 <joe9> sanjoyd: newtype?
04:33:59 <joe9> maybe not.
04:34:20 <edwardk> @hpaste
04:34:21 <lambdabot> Haskell pastebin: http://hpaste.org/
04:34:43 <hpaste> edwardk pasted “tanh-sinh quadrature” at http://hpaste.org/64729
04:35:23 <edwardk> that should compute pretty fast numeric integrals
04:35:43 * hackagebot nsis 0.1 - Build NSIS Installers  http://hackage.haskell.org/package/nsis-0.1 (NeilMitchell)
04:44:03 <ClaudiusMaximus> edwardk: is your 'precision' machinery also useful for fixed-point numbers, ie, not only floating-point?  i started a vague hack... http://hpaste.org/64728  - i should probably check against your work to see how wrong mine is :)
04:44:30 <edwardk> jus floating really
04:44:38 <edwardk> numbers has an arbitrary precision Fixed
04:45:25 <edwardk> http://hackage.haskell.org/packages/archive/numbers/3000.0.0.0/doc/html/Data-Number-Fixed.html
04:46:56 <ClaudiusMaximus> edwardk: cool - strangely not on hayoo, but hoogle finds it
04:50:18 <niez> I'm reimplementing 'in memory database' in haskell (previous implementatiin was in c++), it is a graph based structure, in my c++ implementation for every node type I have 2 structures: a vector and a map, so I can find fast a node by name or by index, how can I implement this in haskell - one data in two places at a time?
04:51:51 <ClaudiusMaximus> @hoogle Map k v -> Int -> v
04:51:51 <sanjoyd> Have a list and a Data.Map?
04:51:51 <lambdabot> Data.Map findWithDefault :: Ord k => a -> k -> Map k a -> a
04:51:52 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
04:51:52 <lambdabot> Data.Map foldlWithKey :: (a -> k -> b -> a) -> a -> Map k b -> a
04:52:39 <sanjoyd> You can also use a mutable array within an ST monad if you want speed and your use satisfies the restrictions an ST monad places.
04:53:10 <sanjoyd> As in, create fast arrays within ST and use them outside ST.
04:53:51 <niez> and elements can be indexed by Int and String at the sime time?
04:53:56 <Taneb> I wrote a little memory game
04:54:06 <edwardk> the best answer is usually to use a map to store the nodes
04:54:29 <alpounet> there's IxSet, which can be useful
04:54:55 <Taneb> http://hpaste.org/64730
04:55:04 <edwardk> niez: you make up node id's as you run (say by bumping a counter) then when you need to make a node, you put the data you want both to be able to find in the map by a given id, and put the id in the structures you want to have fine it
04:55:44 <edwardk> one way to make an element indexable by Int and String is to make one of them canonical (or add a third), and then have one store the mapping from one to the canonical name, and the other store the data
04:56:05 <edwardk> alpounet: IxSet is rarely the right answer when someone is getting started =)
04:56:24 <niez> edwardk, this sound good
04:56:32 <Taneb> It's no great work of art, but it's the first game I've ever completed.
04:56:34 <edwardk> its equally rarely the right answer when you know what you're doing for that matter ;)
04:56:34 <nand`> > fmap (+1) ((1, 2, 3) :: (Int, Int, Int))
04:56:35 <lambdabot>   No instance for (GHC.Base.Functor
04:56:35 <lambdabot>                     ((,,) GHC.Types.Int G...
04:56:45 <nand`> Hmm, no functor instance for (a, a, a)?
04:56:50 <edwardk> nand: impossible
04:57:02 <alpounet> edwardk, how rare is it?
04:57:03 <edwardk> nand: keep in mind the Functor works on the lat argument
04:57:14 <nand`> edwardk: “lat”?
04:57:16 <edwardk> so it _could_ exist for (,,) a a
04:57:18 <Taneb> fmap f (a,b,c) = (a,b,f c)
04:57:18 <edwardk> last
04:57:45 <edwardk> nand: what i mean is that its not going to be the action you expect
04:57:54 <edwardk> you could make a data Triple a = Triple a a a
04:58:02 <nand`> edwardk: right, I know how (,,) a a would behave
04:58:11 <edwardk> then instance Functor Triple where fmap f (Triple a b c) = Triple (f a) (f b) (f c)
04:58:19 <edwardk> ok
04:58:30 <nand`> edwardk: yeah, I'll most likely do that, since I'm only working with triples of the same type
04:58:32 <Taneb> ((a,b),c) is a functor
04:58:46 <Taneb> Nobody really cares, but...
04:59:11 <edwardk> its just a problem where someone would have to make an orphan i suppose, and it has no canonical place to live
04:59:53 <niez> edwardk, and how can I model a bidirectional graph without the pointers (I have c++ background)?
05:00:12 <Taneb> Data.Graph?
05:00:20 <edwardk> do you need to edit the graph?
05:00:25 <edwardk> or just work with it, compute sccs, etc?
05:00:27 <alpounet> Taneb, is it playable online somewhere?
05:00:32 <Taneb> alpounet, no
05:00:43 <Taneb> It's written in Haskell, and I haven't even compiled it yet
05:01:07 <niez> edwardk, yes, I need to change the nodes
05:01:27 <edwardk> niez: then Data.Graph from containers is probably your easiest bet
05:01:58 <edwardk> its defined as Array Vertex [Vertex]
05:02:02 <edwardk> where Vertex = Int
05:02:19 <edwardk> the list is the list of successors
05:02:41 <edwardk> http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-Graph.html
05:03:07 <edwardk> there is also 'fgl' http://hackage.haskell.org/package/fgl, but I don't like it very much
05:03:12 <niez> I see type Edge = (Vertex, Vertex), and what about hypergraphs?
05:03:52 <edwardk> for hypergraphs with editing you're probably on your own
05:04:12 <alpounet> Taneb, yeah but i thought gloss apps could easily be integrated into webpages
05:04:15 <alpounet> don't ask me why
05:04:16 <edwardk> either by inverting it so represent the hyphergraph as a graph of the connections from the vertices to the edges
05:04:20 <edwardk> or by making a library
05:04:28 <Taneb> alpounet, it's GLUT, so prob not
05:05:44 <edwardk> my 'graphs' library is largely hypergraph agnostic, but it isn't designed for mutable graphs
05:06:17 <Taneb> I'd prefer a map to an rray
05:07:11 <edwardk> ok, getting a couple of hours of sleep
05:07:13 <edwardk> night all
05:07:17 <Taneb> Bye!
05:11:44 <monad> Is there a possibility to read out a path in Haskell-source which was set in a cabal before? I know there are some function generated by cabal like getFileName. But these still require a hard-coded subpath + filename...
05:14:21 <edwardk> monad: you can get the data directory for a cabal package
05:14:31 <edwardk> see my 'hyphenation' package which uses it
05:14:48 <edwardk> oh
05:14:53 <edwardk> wait thats what you don't want
05:15:07 <edwardk> you want them to just enter it on the cabal command line or in the environment?
05:15:40 <edwardk> you can make a custom build script, then dump it into an extra haskell source file, then add that to the build list
05:15:58 <edwardk> darcs does this so that the current darcs executable always knows what patch level it is at, etc.
05:16:08 <edwardk> their darcs config may be enlightening
05:16:10 <monad> there is an autogenerated function getDataFileName created by cabal. But if I want to load ressources in my source-code, I still have to call this function with the detailed subpath , like src/program/resource/picture.png
05:16:22 <edwardk> er i mean the darcs.cabal file might be
05:16:37 <alpounet> well, cabal generates these "Path_foo" files, right?
05:16:40 <alpounet> you can use those
05:17:23 <alpounet> monad, like in http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
05:17:46 <monad> alpounet: I know this Path_foo file. But as I said: If I want to load a specific resource, I still have to call the autogenerated function with src </> program </> resource </> pic.png for example
05:17:51 <edwardk> https://github.com/ekmett/hyphenation/blob/master/Text/Hyphenation/Language.hs#L51 is me using the Path_foo stuff
05:18:09 <edwardk> so what is crippling about that?
05:18:14 <edwardk> i'm not sure i understand the problem
05:18:16 <monad> alpounet: I know this page
05:18:23 <alpounet> monad, yeah but you just have to specify these name of the data file you want
05:18:30 <alpounet> the dir etc is already handled by cabal here
05:18:38 <alpounet> s/these/the/
05:18:59 <edwardk> getDataFileName gets you all the way to the 'data' dir, the rest of it is just whatever other structure you want to put in there
05:19:34 <edwardk> by read out a path, do you mean you want to browse the directory or some such?
05:19:35 <monad> edwardk: Is there any possibility to set this subpaths as an alias in cabal?
05:19:59 <edwardk> just make a function of method of your own
05:20:13 <edwardk> or you mean you want a cabal command where the user can set it?
05:20:22 <monad> I have e.g. a main path with a subdir for ressources which contains some pictures. Now I must call getFileNamePath with the whole subpath to this resource.
05:20:41 <edwardk> sure, but what keeps you from making
05:20:42 <monad> I just want to set an alias for that subpath in the cabal file
05:20:53 <monad> how can I set an alias in the cabal file?
05:21:08 <alpounet> why do you want to do this in the cabal file?
05:21:10 <edwardk> getPicture x = getDataFileName ("src" </> "program" </> "resource" </> x)
05:21:51 <monad> edwardk: exactly! And how can I put the string "src" </> "program" </> "resource" as an alias to the cabal file. If this path changes I have to recompile...
05:22:09 <mauke> monad: what
05:22:53 <adnam> "monad: what" :)
05:23:02 <edwardk> good question
05:23:18 <monad> Do you understand my problem? Consider I move the resource-directory, then I have to change all occurences of this path in my source-files.
05:23:23 <alpounet> monad, you can also just specify this in a config file, maybe?
05:23:35 <alpounet> not sure the cabal file is the right place to specify this
05:23:42 <mauke> monad: er, just make a variable for it
05:23:44 <monad> I thought this config-file would be the cabal-file :-)
05:23:51 <monad> Is this not possible?
05:23:53 <edwardk> monad: the usual approach is to let cabal pick the resource directory during install
05:24:18 <edwardk> then just use that, and if you need to specify another location read from an environment variable or command line option
05:24:31 <edwardk> cabal files aren't things you typically want your end user editing
05:24:42 <mauke> monad: I'd say the answer is "no" because we all seem to interpret your problem differently
05:24:48 <edwardk> mauke: hah
05:25:17 <edwardk> what the name of that package that provides xmonad-like configuration files?
05:25:25 <alpounet> edwardk, dyre?
05:25:30 <edwardk> thanks
05:25:45 <edwardk> http://hackage.haskell.org/package/dyre
05:25:48 <edwardk> is what you need
05:25:55 <monad> edwardk: ok, maybe I set a own config-file if necessary
05:26:00 <edwardk> http://hackage.haskell.org/packages/archive/dyre/0.8.6/doc/html/Config-Dyre.html
05:26:24 <edwardk> it makes a config file that has haskell source code in it, that when you edit it you recompile the application using that as your main
05:26:46 <monad> ok
05:26:50 <edwardk> it requires a lot of restructuring to make sure you use it right, but it gives you basically what xmonad has, where you can have a .config file, edit it, and everything just works
05:27:04 <edwardk> plus it makes your app a LOT more configurable, since you can write anything you want in the config file
05:27:35 <edwardk> then your cabal file can remain untouched an innocent
05:27:41 <edwardk> and i can get some sleep  ;)
05:27:46 <edwardk> ok, night all for real this time =)
05:27:51 <_fh_> I wrote this: http://hpaste.org/64711 code to implement this: http://tinypic.com/view.php?pic=35cj2tt&s=5 algorithm but it feels really clunky. Can anybody give me some advices to make it better?
05:28:22 <monad> good night :-)
05:28:53 <monad> _fh_: I saw this code yesterday :-)
05:29:11 <monad> Why do you think it's bad?
05:29:52 <_fh_> I think it could be more elegant since it is my first real haskell program but I don't know how exactly
05:30:44 <_fh_> especially the Literal definition seems needlessly indirect
05:30:51 <jay7557> Hi all!
05:30:59 <mach7> hello
05:31:11 <monad> _fh_: try the tool hlint. It could give you some advice
05:31:22 <niez> where can I find good resources about data structures in haskell? in 'learn you a haskell...' and 'real world haskell' there is not much
05:31:44 <joe9> _fh_: pretty good for your first program.
05:32:00 <_fh_> monad: thank you, I'll try that
05:32:16 <DxBlueIce> hey guys, anyone experienced in HOpenGL? need some advice
05:32:25 <_fh_> joe9: thank you :)
05:32:33 <monad> _fh_: It's a really nice tool that I have recently discovered. It's very valuable for beginners like me :-)
05:34:40 <_fh_> monad: visiting the site right now, looks like what a newbie like me needs
05:35:03 <hpaste> sanjoyd pasted “Type Stuff” at http://hpaste.org/64732
05:35:14 <monad> _fh_: there is also a ubuntu package
05:35:19 <monad> _fh_: hlint - Haskell source code suggestions
05:35:31 <sanjoyd> After I enter the above in ghci, (ne (undefined::A) (undefined::A)) should be ill-typed, right?
05:36:30 <monad> _fh_: I get 12 suggestions for your program :-)
05:37:01 <monad> _fh_: You should use infix notation as hpaste tells you ...
05:38:24 <_fh_> monad: is the infix union idiomatic? Because it does not seem that much clearer to me than the prefix one, might be my scheme experience talking though.
05:38:56 <monad> _fh_: it's easier to read as union is naturally a infix operation like '+'
05:39:23 <DxBlueIce> can anyone help with HOpenGL? please pm!
05:41:34 <monad> I am not experienced with opengl but know some good tutorials
05:42:27 <monad> there are some examples coded in hopengl from the red book
05:42:32 <DxBlueIce> i read alot of tuts already; do you have something about 3D games?
05:42:38 <monad> there is also a tutorial named "HOpenGL – 3D Graphics with Haskell"
05:43:06 <monad> I hate writing 3d games :-)
05:43:09 <DxBlueIce> i read the second one
05:43:11 <DxBlueIce> :D
05:43:23 <monad> the second one is more about 2d-programming
05:43:51 <monad> DxBlueIce: Are you 12 y old and learned C++ before :-)
05:43:58 <DxBlueIce> haha no
05:44:12 <DxBlueIce> well yes and no, im not 12 y old but i leanred c++ before :P
05:44:41 <DxBlueIce> i have to use haskell for a project at university ;)
05:44:43 <monad> then it's good to learn the cish-opengl first, it helps a lot
05:45:24 <monad> hopengl is just a wrapper; if you have learned the common opengl you have no problems with hopengl
05:46:09 <monad> do you know the hopengl-examples from the redbook
05:46:22 <monad> there is more information on 3d-programming
05:46:37 <DxBlueIce> ok i think i didnt read that
05:46:53 <monad> there should be a link on haskellwiki
05:47:03 <monad> it's no tutorial but a handful of helpful examples
05:47:32 <DxBlueIce> ok ty
05:47:45 <monad> corresponding information might be found in the "C"-redbook
05:47:54 <sanjoyd> Is there some way to get Haskell to tell me how it typechecked a term?
05:47:57 <monad> but it's C and not Haskell
05:48:34 <Tomsik> sanjoyd: :t
05:48:53 <Tomsik> it works with either ghci or lambdabot
05:48:54 <DxBlueIce> ok
05:48:54 <sanjoyd> It just shows me the type -- I want to see _how_ it derives the type itself.
05:49:11 <Tomsik> Oh
05:49:46 <sanjoyd> For instance, I want to know, in my above paste, how (ne (undefined::A) (undefined::B)) is well-typed.
05:49:53 <sanjoyd> I need to see the type derivation.
05:51:03 <zerax> How would you present that information
05:55:50 * hackagebot monad-lrs 0.0.2.1 - a monad to calculate linear recursive sequence  http://hackage.haskell.org/package/monad-lrs-0.0.2.1 (BinJin)
06:00:08 <osa1> @hoogle <$>
06:00:09 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
06:00:09 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
06:13:53 <ClaudiusMaximus> sanjoyd:  ghc -ddump-tc seems incomprehensible to me, but might be what you're after?
06:18:54 <hpaste> duairc pasted “monadstack.hs” at http://hpaste.org/64733
06:46:56 <ronankde> how to open the browser documentation haskell?
06:47:31 <ronankde> and equal to pydoc python
06:53:14 <ChristianS> ronankde: what you do mean? if haddock has generated documentation, you can view it in the browser of your choice.
06:55:20 <ronankde> What I mean is how to open the documentation ghc
06:57:29 <ChristianS> depends on your installation, the user manual should be locally installed somewhere.
06:59:11 <aavogt> ronankde: maybe something like http://holumbus.fh-wedel.de/hayoo/hayoo.html is what you're looking for
06:59:22 <ion> Try running “man ghc”.
06:59:35 <aavogt> rather than manually finding the html files that document things
07:00:08 <DxBlueIce> can anyone help me with opengl? i need to build a 3D room with a map textfile
07:01:11 <ronankde> i found
07:01:29 <ronankde> is this
07:01:32 <ronankde> file:///usr/share/doc/ghc-doc/html/index.html
07:01:38 <ronankde> is local
07:04:44 <Saizan> ronankde: those that look like this page? http://www.haskell.org/ghc/docs/latest/html/
07:05:44 <ronankde> exactly
07:06:26 <ronankde> and that but I'm not always online
07:08:05 <Saizan> (s/those/does/ , weird typo)
07:08:44 <Saizan> ronankde: anyhow those are the docs :)
07:15:24 <timsdesktop> I am having problems with my Haskell Evironment (OSX.6.8, GHC7.0.4) in that my "transformers-base" fails to install. Cabal install --reinstall world also fails on this. Anyone know how to totally remove and start again?
07:17:06 <Saizan> timsdesktop: assuming you've never installed stuff globally you should just have to delete your user package db
07:17:26 <timsdesktop> I did install globally :-(
07:17:47 <timsdesktop> (I was in the process of installing to get EclipseFP running.
07:18:00 <Saizan> then you still have to delete the user package db but also reinstall ghc
07:18:32 <Saizan> the userdb is found under ~/.ghc on linux, but anyhow ghc-pkg list --user should tell you the path at the top
07:19:36 <timsdesktop> Will re-installing Haskell environment ignore existing settings?
07:19:47 <antilect> haskHell :D
07:19:48 <antilect> <3
07:21:48 <timsdesktop> Ah, I tried to ghc-pkg recache, but it complained I did not have permissions (despite being Admin...)
07:34:59 <jay7557> Hi all!
07:35:41 <byorgey> hi jay7557!
07:36:00 <jay7557> Anybody has any idea of encoding char ?
07:36:38 <jay7557> Hi byorgey
07:37:39 <jay7557> am having problem with implementing function
07:37:56 <jay7557> like scrambling a char with xor and displaying the result
07:39:46 <ChristianS> > fromEnum 'A'
07:39:47 <lambdabot>   65
07:40:13 <ChristianS> > toEnum 99 :: Char
07:40:14 <lambdabot>   'c'
07:40:28 <ChristianS> jay7557: do you have something like that in mind?
07:40:41 <jay7557> yes
07:41:12 <jay7557> Can I paste the code I've written?
07:41:23 <ChristianS> hpaste.org
07:42:06 <hpaste> jay7557 pasted “problems” at http://hpaste.org/64735
07:44:15 <fryguybob> @check \a -> a `xor` a == (0 :: Int)
07:44:16 <lambdabot>   "OK, passed 500 tests."
07:48:13 <jay7557> any suggestions?
07:48:23 <jay7557> on the pasted script?
07:49:09 <Saizan> jay7557: map ord a :: [Int] so you can't pass it to putStrLn which wants a String
07:49:31 <Saizan> jay7557: maybe you want putStrLn (show (map ord a)) ?
07:49:35 <jay7557> yh
07:49:43 <jay7557> ok let me try
07:50:47 <Saizan> also fryguybob was pointing out that your scrable function is always going to produce a list of '\0'
07:51:24 <jay7557>     Couldn't match expected type `Char' with actual type `Int'     Expected type: [Char]       Actual type: [Int]     In the second argument of `map', namely `a'     In the first argument of `show', namely `(map ord a)'
07:51:34 <jay7557> error!
07:51:34 <jay7557> :(
07:52:07 <Saizan> oh, right
07:52:14 <Saizan> a is already [Int]
07:52:25 <Saizan> so you don't want to map ord it again
07:52:47 <Saizan> jay7557: what do you want to print?
07:53:53 <Saizan> try with "pusStrLn (show a)"
07:54:04 <jay7557> scrambled value
07:54:20 <jay7557> say if you enter "hello"
07:54:45 <jay7557> it would make it like "NUl\dulz\er2\hu2q"
07:54:51 <jay7557> something like that
07:55:39 <Saizan> well, i don't know how you'd do that
07:58:05 <jay7557> i can manage to do it at ghci
07:58:46 <jay7557> but can't compile the script because I get many indentation error etc..
07:59:09 <Saizan> what do you do in ghci?
08:02:49 <ion> DxBlueIce seems to be private messaging people at random.
08:05:42 <mauke> hmm
08:05:45 <ChristianS> true, but that's not exactly forbidden, as far as i know?
08:08:16 <Jafet> Forbidden by what?
08:09:10 <Saizan> he's not a spammer, but it's still not entirely polite to query for help
08:11:03 <Saizan> DxBlueIce: if noone that knows about opengl shows up you could try the haskell-cafe mailing list or even stackoverflow
08:11:42 <timsdesktop> Saizan: Thanks for your help. I wiped Library/Framework, ~/.ghc, ~/.cabal, reinstalled Haskell Framework and then the building has completed this time.
08:11:45 <Saizan> DxBlueIce: btw it's much better to directly ask a specific question rather than just the general problem
08:11:59 <Saizan> timsdesktop: cheers
08:15:58 <osager> hi all i can not install package "conjure"
08:16:05 <osager> with the following error
08:16:06 <osager> src/Conjure/Network/Client.hs:42:8:
08:16:06 <osager>     Could not find module `Data.Array.Diff'
08:16:06 <osager>     Perhaps you meant
08:16:06 <osager>       Data.Array.Base (from array-0.4.0.0)
08:16:06 <osager>       Data.Array.IO (from array-0.4.0.0)
08:16:07 <osager>       Data.Array.ST (from array-0.4.0.0)
08:16:15 <osager> any idea ?
08:18:00 <good> join #USEagency
08:23:48 <good> join #USEagency
08:31:10 * hackagebot nsis 0.1.1 - DSL for producing Windows Installer using NSIS.  http://hackage.haskell.org/package/nsis-0.1.1 (NeilMitchell)
08:31:12 * hackagebot control-monad-exception 0.10.1 - Explicitly typed, checked exceptions with stack traces  http://hackage.haskell.org/package/control-monad-exception-0.10.1 (PepeIborra)
08:32:55 <Saizan> osager: Diff arrays are no longer supported, you'd have to port the code
08:33:39 <Saizan> osager: but i'd go with Combinatorrent instead
08:49:48 <Taneb> Hello!
08:50:01 <Taneb> I want to get a key from input
08:50:06 <Taneb> How would I do that?
08:50:29 <Elemir> Where?
08:50:53 <Elemir> Windows, vt100-terminal, OS X, X11, wayland, framebuffer?
08:52:04 <Saizan> for the simplest case you could use getChar from System.IO
08:52:15 <Elemir> @todo To write wayland backend for haskell
08:52:15 <lambdabot> Plugin `todo' failed with: @todo has no args, try @todo-add or @list todo
08:52:23 <Elemir> @todo-add To write wayland backend for haskell
08:52:23 <lambdabot> Entry added to the todo list
08:53:10 <Taneb> It's in a terminal, I don't want the key to be echoed though7
08:53:45 <applicative> Is there a special insecurity in   do {key <- getLine ; ... key ...}
08:54:23 <Taneb> Not especially
08:54:25 <Jafet> @hackage vty
08:54:26 <lambdabot> http://hackage.haskell.org/package/vty
08:54:36 <Elemir> Taneb: something like getch in ncurses?
08:54:49 <Elemir> VTY is good answer, yes
08:55:08 <Taneb> I don't know ncurses
08:55:48 <Saizan> Taneb: there's hSetEcho
08:55:53 <Saizan> ?type hSetEcho
08:55:54 <lambdabot> Not in scope: `hSetEcho'
08:56:00 <Saizan> ?hoogle hSetEcho
08:56:00 <lambdabot> System.IO hSetEcho :: Handle -> Bool -> IO ()
08:56:00 <lambdabot> GHC.IO.Handle hSetEcho :: Handle -> Bool -> IO ()
08:56:15 <Taneb> Yeah, thanks!
08:56:20 <Taneb> You've all been very helpful
08:56:26 <Jafet> As Taneb wants to get "keys" from the "terminal", System.IO should not be used.
08:56:52 <Taneb> My terminology is likely a bit off
09:02:45 <hpaste> doug pasted “compile errro” at http://hpaste.org/64736
09:03:42 <dougransom> Hi, where do I look to try and fix http://hpaste.org/64736?  I am using eclipesefp to attempt to compile.  I'll paste up the cabal file now.
09:04:05 <gregATio> emacs ftw
09:04:19 <applicative> in the .cabal file it should be HUnit not hunit, I think
09:04:21 <hpaste> doug pasted “cabal” at http://hpaste.org/64737
09:04:59 <applicative> doug, try it with HUnit in the two lines with 'hunit'
09:06:01 <dougransom> That seemed to do it.
09:06:03 <dougransom> tx.
09:07:02 <tazjin> Why do people use Eclipse for things other than Java? Honest question. I wouldn't say that its interface is so great that it makes me want to use it for everything
09:08:09 <td123> tazjin: I think it's because it's a very versatile when it comes to language support
09:08:39 <td123> tazjin: (you don't have to learn another ide if you switch languages)
09:08:40 <dougransom> Ttazjin: Leksah crashed about every 30 seconds on osx when I tried it.  And i think an IDE would suit me better than emacs right now.
09:10:02 <tazjin> Hmm, on OS X I'm using Sublime Text + a simple Terminal; on Linux it's Geany (which I find to be ingenious). But everyone has their preferences :]
09:10:31 <td123> tazjin: yup, no wrong way to write text :)
09:11:52 <td123> (I've seen a professor use wordpad for editing code..)
09:12:17 <dougransom> I like to be able to click to add a breakpoint and have the tool manage the build for me.
09:12:43 <dougransom> If I just wanted some nice colours and indenting I'd stay with emacs.
09:13:38 <Eduard_Munteanu> dougransom: people rarely do that sort of debugging when it comes to Haskell.
09:16:06 <gregATio> can someone correct the following line from ghci for me please?
09:16:14 <gregATio> :t handle (const (return []))
09:16:15 <lambdabot> forall a (m :: * -> *) e ex. (Monad m, ArrowError ex (->)) => ((e, ex) -> m [a]) -> e -> m [a]
09:19:04 <dougransom> Is there a convention for the name of the .hs file unit tests go in?
09:24:06 <gregATio> from java unit tests have the name of the module you are testing with the name Test appended to the end
09:24:33 <gregATio> I tend to do the same in python
09:31:25 <Tomsik> :t mfix
09:31:26 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
09:31:43 <Tomsik> @instance MonadFix []
09:31:43 <lambdabot> Maybe you meant: instances instances-importing
09:31:49 <Tomsik> @instances MonadFix []
09:31:51 <lambdabot> Plugin `instances' failed with: regex failed: (ReturnCode 7,"Unmatched [ or [^")
09:32:00 <Tomsik> How does that work?
09:32:05 <applicative> gregATio: did you figure out :t handle etc?
09:32:54 <alpounet> @src MonadFix
09:32:55 <lambdabot> class (Monad m) => MonadFix m where
09:32:55 <lambdabot>     mfix :: (a -> m a) -> m a
09:33:55 <lutinbleu_> hello
09:34:02 <applicative> hello lutinbleu_
09:34:20 <alpounet> @src [] mfix
09:34:20 <lambdabot> mfix f = case fix (f . head) of
09:34:21 <lambdabot>            []    -> []
09:34:21 <lambdabot>            (x:_) -> x : mfix (tail . f)
09:34:28 <Tomsik> thanks
09:34:28 <lutinbleu_> I ended up here using the tryhaskell.org webpage
09:34:29 <alpounet> Tomsik, ^^^
09:34:40 <lutinbleu_> which is quite great, by the way
09:34:50 <applicative> lutinbleu_: good work.
09:35:04 <applicative> our friends can explain any alarming type errors or syntactical niceties
09:35:17 <lutinbleu_> that's nice
09:35:20 <lutinbleu_> thanks
09:36:01 <applicative> well good luck with the rest of it, lutinbleu_ Folks can also advise on further things to look at etc.
09:36:44 <lutinbleu_> thank you :)
09:39:13 <lutinbleu_> I know some of OCaml and Haskell reminds me some syntactical practicies
09:39:25 <lutinbleu_> like the way it handles pattern matching
09:40:36 <gregATio> applicative no, i havent figured out that handle stuff , still working on it
09:40:54 <gregATio> its actually from real world haskell
09:41:36 <alpounet> @type handle
09:41:37 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
09:44:04 <applicative> gregATio, the handle type uses the fancy Exception machinery, and is likely to give an opaque type error unless you give it a bit of added type info
09:44:25 <applicative> the type of handle ishandle :: Exception e => (e -> IO a) -> IO a -> IO a
09:44:31 <applicative> handle :: Exception e => (e -> IO a) -> IO a -> IO a
09:45:33 <applicative> so if you  e.g.  handle ((const (return [])) :: SomeException -> IO [b]) or something it will be okay
09:46:47 <gregATio> I want to do that
09:47:34 <applicative> or myException :: SomeException -> IO [b]; myException _ = return []  and then handle myException .... that sort of thing
09:47:50 <gregATio> so i put (handle (const return []))
09:48:10 <gregATio> but it complained that i hadnt put enough type info in it
09:48:16 <applicative> no wait, I made a has of that line above
09:48:18 <applicative> as usual
09:49:17 <gregATio> so i tried handle (const return []):: Exception e => (e -> IO [String])
09:49:22 <gregATio> it hates that too
09:49:26 <Ywen> Hi, people! I'm still trying to configure my vim right: does someone knows a good plugin to display the tags list (preferably with options: alphabetically/per file or directory...)?  I tried TagList but it only works with ctags/exuberant-ctags
09:49:31 <gregATio> not quite sure what it wants from em
09:49:57 <applicative> gregATio: thats a different problem you need more parens
09:50:12 <applicative> handle ((const return []):: Exception e => (e -> IO [String])) I think
09:50:49 <applicative> take that back,
09:51:45 <applicative> the line I wrote above with a separate myException was right this last signature not
09:52:47 <gregATio> cant i join them with => ? why separate
09:56:46 <applicative> handle's first argument has to be of the form (e -> IO a) where e is an actual exception type
09:57:47 <t7> i want my speed of light computer
09:57:54 <applicative> it cant take a think of type Exception e => (e -> IO [String]) as argument, since it doesn't know which exception type its using
09:58:51 <ion> t7: Your 2/3 speed of light computer isn’t enough?
09:59:56 <gregATio> so theres no way to define the exception type?
10:00:22 <applicative> gregATio: you can do all kinds of things, but for the simple case here there is the 'existential type' SomeException,
10:00:57 <applicative> so if you write a :: SomeException -> IO [String]; a = const (return [])  then you have a definite exception type
10:01:39 <rwbarton> what are you actually trying to do? what kind of exception do you want to handle?
10:02:47 <gregATio> yes but i dont really want to define a whole new exception type, when its just one line that im trying to handle
10:02:52 <rwbarton> what??
10:02:57 <gregATio> i want the exception type to be inline
10:03:19 <gregATio> IO [String]
10:03:46 <Saizan> gregATio: what is the type of exceptions you want to catch?
10:05:30 <gregATio> its an IO Exception
10:05:44 <gregATio> i think the type is Exception IO [String]
10:05:48 <NemesisD> is there a good way when your forkIO a thread to wait for it to complete?
10:06:15 * hackagebot xml-conduit 0.5.3.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.5.3.1 (MichaelSnoyman)
10:06:18 <Saizan> NemesisD: make it put into a MVar at the end
10:07:21 <NemesisD> Saizan: ii think i'm approaching this wrong. i have a thread that runs forever. how can i get the main thread to run forever after spawning all the threads
10:07:27 <applicative> let a = handle (const (return []) :: SomeException -> IO [Int]) (do a <- readLn ; b <- readLn ; return [a,b])
10:07:55 <monochrom> (t, v) <- do { v <- newEmptyMVar; t <- forkIO (your_job `finally` putMVar v ()); return (t, v) }
10:08:00 <applicative> gregATio: you want something like this ^^^ I used readLn because it can fail in the obvious way
10:08:09 <monochrom> then you takeMVar v when you want to wait
10:08:41 <gregATio> yeah i really like it only i thought i should be able to do something like....
10:09:34 <monochrom> your main thread could also forever (threadDelay 50000000000000000000)
10:09:50 <gregATio> let a = handle (const (return []) :: Exception [Int] someException => someException -> IO [Int])
10:09:53 <NemesisD> thats... inelegant
10:10:13 <rwbarton> that's basically the way a unix process waits forever at the OS level though
10:10:28 <NemesisD> so my job itself does the forkio and return the threadid, i'm a bit surprised haskell doesn't have any machinery for monitoring a threadids completion
10:10:44 <gregATio> there should be a way to issue a "join" command on the thread
10:10:58 <gregATio> applicative is there no way of inlining the exception type?
10:11:14 <monochrom> that machinery probably adds weight to threads
10:11:16 <rwbarton> gregATio: you're not making any sense
10:12:06 <applicative> let a = handle (const (return []) :: IOException -> IO [Int]) (do a <- readLn ; b <- readLn ; return [a,b])
10:12:36 <gregATio> ok i like that thanks
10:12:53 <applicative> rwbarton, he's reading the RWH bit about it, but I think it is out of date now? It's a little confusing
10:12:54 <rwbarton> of course readLn could fail for several reasons
10:14:12 <applicative> this handles the obvious case of unparseable input, no?
10:14:55 <rwbarton> yes, but also the case where stdin is attached to a file on a disk that gets unplugged or whatever
10:15:23 <monochrom> you can refine the handler. the point is first get the control flow and wrapping right
10:15:48 <rwbarton> I thought it was "first figure out what you want to do" :)
10:15:54 <lelf> Is there clever way to write foo where foo [] = Nothing, foo [Nothing,Nothing] = Nothing, foo [Just a,Nothing,Just b,…] = a `op` b `op` … ?
10:16:10 <gregATio> thats nice , i think my problem was i was unaware of the difference between Exception and IOException types
10:16:11 <applicative> he wanted the example from RWH to typecheck
10:16:35 <monochrom> typechecking RWH is easy. import Control.OldException
10:16:40 <NemesisD> i guess i can refactor my thread to just be an IO () that happens to have a threadDelay  then whatever uses it can handle the forking
10:16:42 <__zero> lelf: I don't see the pattern..
10:16:59 <bru`> Hi! Do you know what happened to the haskell-related packages on archlinux? I cannot update anything, dependencies changed, many packages are orphans in aur...
10:17:01 <gregATio> yes @ applicative because the example in RWH doesnt compile otherwise :-O
10:17:22 <Saizan> lelf: catMaybes is a start
10:17:30 <applicative> monochrom: that's the low road
10:17:49 <monochrom> the high road is to press the authors to update RWH
10:17:51 <gregATio> monochrome I'd rather not learn that
10:18:01 <gregATio> the middle road is #haskell
10:18:11 <applicative> via media #haskellica
10:18:21 <monochrom> you are not the first one or the last one to read RWH and find this disprecancy.
10:18:42 <monochrom> currently it seems we get this question once every month
10:18:43 <applicative> you are not the first one or last one to find this discrepancy on half of hackage
10:20:11 <monochrom> the middle road is the most inefficient road. to have someone live repeat the same answer every month. worst of both worlds
10:20:22 <applicative> bru` there was a change in policy about profiling, this has led to a certain amount of chaod
10:20:24 <applicative> chaos
10:20:31 <monochrom> though, I know one person who enjoy providing such repetition
10:21:24 <gregATio> isnt that what the bots are for
10:21:27 <gregATio> ?
10:21:33 <monochrom> or web pages
10:21:58 <alpounet> bru`, iirc it's being worked on, you may want to ask in #arch-haskell
10:22:02 <gregATio> well if you knew the web page perhaps it would have been easier if you'd just pointed me at it
10:22:15 <monochrom> but there is no web page yet
10:22:39 <rwinkler> I have an FFI question: What Haskell-type should I use for size_t? Is Word32 correct?
10:22:45 <monochrom> it's why I say the high road is to press the authors to update RWH. that is the right web page.
10:22:48 <gregATio> i see , well sorry for the inconvienience
10:23:01 <applicative> bru` i was going to mention #arch-haskell
10:23:25 <applicative> bru`: here's an example of one of the problems anyway http://groups.google.com/group/pandoc-discuss/browse_thread/thread/997f7fc8be40c2be#
10:23:32 <rwinkler> Though Word32 works, I don't know whether it's correct...
10:23:38 <lelf> __zero, Saizan: foo ls = case cayMaybes ls of [] -> Nothing; xs -> Just $ foldl op idElem xs. The same without pattern-maching?
10:24:29 <rwinkler> So can I map Word32 to size_t in FFI? Or should I use culong?
10:25:03 <Ralith> In OutsideIn(X), SPJ refers a few times to a stadnard, efficient algorithm for constraint solving which operates by side effects. Can anyone elaborate on this?
10:25:13 <rwinkler> oh, there's the type CSize, I will use it
10:31:59 <ddarius> Ralith: Basically what (modern) Prolog implementations do.
10:32:40 <Ralith> I'm not familiar with that. Is there anywhere I can find a detailed summary?
10:34:00 <NemesisD> monochrom: would using that takeMVar do anything to compromise a threadDelay in the forked thread?
10:34:21 <monochrom> I do not understand.
10:34:38 <NemesisD> my thread does something then delays for a second, i noticed that it instead now its doing work at all times and not sleeping
10:35:02 <monochrom> actual code?
10:37:23 <Peaker> without using explicit recursion or any recursive or partial function -- should it be possible to make an infinite loop/hanging program?
10:37:28 <_mpu> hi, my getFileStatus is spawning an error, how can I grab it?
10:37:29 <hpaste> NemesisD pasted “failing to delay” at http://hpaste.org/64740
10:37:42 <monochrom> note that many programs use what I said without problems. and what I said is right in the Control.Concurrent docs
10:37:45 <Peaker> I expected the answer to be no, but then if I use the catch-all type "newtype L = L { l :: L -> L }", I can write a hanging function
10:37:58 <Peaker> (As I can express the Y combinator)
10:38:04 <edwardk> Raith: most people implement unification via IORefs that point to types
10:38:33 <edwardk> Raith: look at the unification-fd ST implementation as opposed to the pure Map based one
10:38:46 <edwardk> Raith: that will showcase the difference between the two approaches
10:38:51 <monochrom> what are the relative precedences of $ and `finally`?
10:38:59 <NemesisD> monochrom: oh i have no doubt that its something i'm doing wrong
10:39:27 <NemesisD> im thinking my problem is in: loop conn = forever $ doRestore conn >> doDelay
10:39:43 <monochrom> what are the relative precedences of $ and >> ?
10:39:57 * ddarius tries to figure out a way to get tail call optimization without pessimizing everything else or completely changing everything.
10:40:16 <ddarius> edwardk: Also, want your books?
10:40:28 <edwardk> Raith: if you want to see how you can extend it to higher rank types, you can look at daan leijen's HMF, which is available from his website in two prototype impementations. One uses maps and explicit substitutions, the other uses IORefs (at least for the unification vars, it still does substitution to replace bound vars though
10:40:30 <edwardk> Sure
10:40:37 <edwardk> want to swing by?
10:40:46 <adimit> @pl \a b c -> k a b c >>= return.fst
10:40:47 <lambdabot> flip flip (return . fst) . ((flip . ((>>=) .)) .) . k
10:40:54 <adimit> >.>
10:41:04 <edwardk> also, lunch?
10:41:05 <ddarius> edwardk: Yeah, I'll head over in ten minutes or so.
10:41:06 <adimit> I think I'll stick with lambda.
10:41:09 <edwardk> sounds good
10:41:10 <NemesisD> monochrom: i've tried doing forever (doRestore conn >> doDelay) and it had the same effect
10:41:35 <NemesisD> does delay not block?
10:41:41 <Peaker> adimit: @pl is often stupid :) There is sometimes a nice way to do it
10:41:51 <adimit> Peaker: yeah, but I can't be arsed to find it.
10:42:02 <monochrom> which package is "delay" in?
10:42:04 <adimit> sure it'd be prettier, but… you know. It won't go fasta.
10:42:07 * Ralith polls ddarius 
10:42:19 <Peaker> adimit: here a nicer way is:  (result . result . result) (return . fst =<<) k
10:42:23 <Ralith> oh wait edwardk replied to me
10:42:26 <Ralith> didn't see that
10:42:49 <monochrom> is the program spending time in "connect"?
10:43:01 <NemesisD> monochrom: concurrent-extra, its just threadDelay but takes an integer instead of an int
10:43:11 <Peaker> adimit: read as:   on the result/result/result of k (i.e: after 3 args), apply (return . fst =<<)
10:43:24 <Peaker> adimit: though actually, (return . f =<<)  is actually (liftM f)
10:43:24 <monochrom> threadDelay blocks and does not use CPU
10:43:35 <rwbarton> NemesisD: you know that 1000 microseconds is not a very long time right
10:43:40 <Peaker> so it's:  (result . result . result . liftM) fst k
10:43:54 <Peaker> @let result = (.)
10:43:55 <lambdabot>  Defined.
10:43:55 <NemesisD> oh man, i think i got micro and milli mixed up
10:44:04 <Peaker> @type (result . result . result . liftM) fst
10:44:05 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (m :: * -> *) a b. (Functor f, Functor f1, Functor f2, Monad m) => f (f1 (f2 (m (a, b)))) -> f (f1 (f2 (m a)))
10:44:13 <Peaker> damn Caleskell!
10:44:26 <Peaker> lambdabot is for pedagogy, not golfing
10:44:37 <Peaker> @undef
10:44:44 <Peaker> @let result = (Prelude..)
10:44:44 <lambdabot>  <local>:1:9: Not in scope: `Prelude..'
10:44:48 <Peaker> @let result = (P..)
10:44:48 <lambdabot>  <local>:1:9: Not in scope: `P..'
10:45:01 <NemesisD> well i feel silly
10:45:23 <NemesisD> why on earth does threadDelay take an Int if the scale is microseconds
10:45:23 <monochrom> I thought you had an old version that successfully delayed long enough
10:45:28 <Peaker> @let result f g x = f (g x)
10:45:29 <lambdabot>  Defined.
10:45:34 <Peaker> @type (result . result . result . liftM) fst
10:45:35 <lambdabot> forall t t1 t2 (m :: * -> *) a b. (Monad m) => (t -> t1 -> t2 -> m (a, b)) -> t -> t1 -> t2 -> m a
10:45:45 <rwbarton> (I don't know why threadDelay doesn't just take a Rational number of seconds, or some type that represents a duration of time)
10:45:47 <Peaker> adimit: see the type?
10:46:04 <Peaker> rwbarton: yeah, it's pretty error-prone
10:46:25 <Peaker> it should be a newtype TimeInterval, or just use NominalDiffTime or such
10:48:00 <monochrom> then base depends on time
10:48:18 <Peaker> then NominalDiffTime itself can be moved to base, maybe
10:48:21 <Peaker> and re-exported from time
10:48:55 <Peaker> or threadDelay can be internalized to "GHC.Prim.threadDelayMicros", and re-exposed by a non-base package that can depend on "time"
10:49:34 <monochrom> pretty sure that's actually what the GHC people conceived
10:50:43 <monochrom> Control.Concurrent re-exports GHC.Conc, and both are intended to be low-level. someone else is supposed to upload a higher-level package to hackage doing what you said
10:50:48 <adimit> Peaker: thanks!
10:51:32 <Ralith> edwardk: HMF and co look like just the examples I was looking for, thanks
10:51:58 <edwardk> no problem. the actual OutsideIn(x) paper uses mutation as well
10:52:08 <Peaker> @where SECs
10:52:08 <lambdabot> I know nothing about secs.
10:52:09 <Peaker> @where SEC
10:52:09 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
10:52:13 <Peaker> adimit: it all becomes easy once you read that ^^
10:52:14 <adimit> Peaker: though, I think that this is less readable than the original variant.
10:52:32 <Peaker> result . result . result . liftM <-- makes little sense before you've internalized the SEC idiom
10:52:44 <adimit> yeah, I think so.
10:52:57 <Peaker> adimit: and it makes perfect sense after you have :-)
10:53:28 <adimit> reminds me of programming concatenatively.
10:53:42 <Peaker> adimit: points-free does, and SEC is a form of points-free, yeah
10:53:55 <adimit> or like, you know SKI.
10:54:05 <Peaker> adimit: I use SECs all the time, and it's very readable once you get used to it.
10:54:37 <adimit> well, that blog post is on my pile of "read tonight" :-)
10:54:39 <Peaker> And it can make lots of pieces of code significantly shorter (even if this example didn't) and nicer, so it's worth it
10:55:01 <adimit> yeah, I think for this example it wasn't really worth it, but I can see the general principle is nice.
10:55:28 <adimit> to be honest, I can't find the piece of code I wanted to use this in…
10:58:02 <adimit> i thought to do something like (liftM fst).k , but that doesn't work when k has 3 args…
10:58:33 <adimit> well, now I've \a b c -> liftM fst $ k a b c, that's rather clear :-)
10:58:46 <adimit> @pl  \a b c -> liftM fst $ k a b c
10:58:46 <lambdabot> ((fmap fst .) .) . k
10:58:51 <adimit> >.>
10:59:22 <adimit> I guess that's better.
11:03:51 <_mpu> how can I grap getFileStatus's errors?
11:04:39 <hiptobecubic> @src Maybe
11:04:39 <lambdabot> data Maybe a = Nothing | Just a
11:04:50 <hiptobecubic> @src Monad
11:04:51 <lambdabot> class  Monad m  where
11:04:51 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:04:51 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:04:51 <lambdabot>     return      :: a -> m a
11:04:51 <lambdabot>     fail        :: String -> m a
11:06:36 <hiptobecubic> @src [] (>>)
11:06:36 <lambdabot> xs >> ys      = concatMap (const ys) xs
11:07:33 <hiptobecubic> @src [] (>>=)
11:07:34 <lambdabot> xs >>= f     = concatMap f xs
11:12:20 <hiptobecubic> So are lists a category?
11:12:46 <hiptobecubic> well it's a monad i guess
11:13:07 <hiptobecubic> also a monoid i would think? with "." being concatenation?
11:13:19 <byorgey> hiptobecubic: the list constructor is a monad.  There is a category (the Kleisli category) that corresponds to any monad.
11:13:28 <byorgey> lists are a monoid, yes.
11:13:48 <byorgey> but it doesn't make sense to ask whether "lists are a category".
11:14:15 <hiptobecubic> byorgey, yeah. i feel like i'm one level of abstraction too low, or maybe more
11:14:56 <byorgey> the Kleisli category for lists is the category where arrows from a to b  are functions of type   a -> [b]
11:15:33 <hiptobecubic> why a -> [b] and not [a] -> [b]?
11:16:06 <monochrom> so that >>> is >=>
11:16:53 <DrSyzygy> hiptobecubic: Because that's what the Kleisli category is.
11:17:25 <parcs`> why [a] -> [b] and not a -> [b]?
11:17:38 <monochrom> heh
11:18:02 <hiptobecubic> parcs`, from lists to other lists?
11:18:09 <Tomsik> Almost anything is a category
11:18:40 <hiptobecubic> monochrom, i'm not read for three character operators yet. leave me with my >> for now
11:18:41 <DrSyzygy> If M is a monad, then the Kleisli category for M has as objects the objects of the category outside, and a morphism a -> b is a function a -> M b
11:19:12 <hiptobecubic> The category outside?
11:19:25 <DrSyzygy> hiptobecubic: In this case Hask, the category of haskell types.
11:19:27 <hiptobecubic> Tomsik, isn't that the point of them?
11:19:42 <DrSyzygy> so if M is a Haskell monad, you have objects of the Kleisli category being simply haskell types.
11:20:10 <hiptobecubic> So... M is in Hask as well of course?
11:20:18 <DrSyzygy> Composition g . f is join . fmap g . f
11:20:21 <DrSyzygy> M is  amonad.
11:20:23 <DrSyzygy> over Hask.
11:20:30 <DrSyzygy> so a monad in the sense you're used to.
11:20:38 <hiptobecubic> DrSyzygy, there is no sense that I'm used to.
11:21:02 <monochrom> M is a monadic functor from Hask to Hask
11:21:20 <DrSyzygy> For lists, this says that functions in a Kleisli category are maps a -> [b] (by definitino) and function composition takes f::a -> [b] and g::b -> [c] and does join . map g . f
11:22:13 <DrSyzygy> if you're not familiar with monads, thoguh, it's not entirely clear to me that learning about the Kleisli category will help you further.
11:23:00 <hiptobecubic> DrSyzygy, leaving parts out makes it harder to understand though. It's better this way.
11:23:24 <DrSyzygy> hiptobecubic: what parts are you worrying about seeing left out?
11:23:36 <hiptobecubic> maps are from a -> [b], where a is "outside" the monad and b is in it?
11:23:42 <rostayob> hiptobecubic: you're not leaving anything out if you're learning monads and you don't learn about arrows :P
11:24:15 <hiptobecubic> DrSyzygy, rostayob perhaps not, but that's not something you would know until it's too late
11:24:20 <DrSyzygy> hiptobecubic: a morphism from a to b in the Kleisli category for Hask is the same thing as a Haskell function a -> M b.
11:24:30 <rostayob> hiptobecubic: if you want to learn about arrows, read Wadler's paper
11:24:51 <rostayob> that was the best resource I could find
11:25:02 <hiptobecubic> I'll take your word for it, of course. I'm just tired of people throwing crappy analogies around everytime anyone writes a blog post or asks a question about monads
11:25:23 <DrSyzygy> hiptobecubic: You don't want crappy analogies? Okay then.
11:25:41 <DrSyzygy> 1. Do you know what a category is? (if you say no, I will follow up with a definition and a discussion of its implications)
11:25:42 <monochrom> there is no analogy here so far
11:25:57 <hiptobecubic> like this astronaut <-> spacestation garbage I found last time I was searching
11:26:08 <DrSyzygy> hiptobecubic: Christ, yeah, no.
11:26:13 <monochrom> right, we are all past that
11:26:18 <DrSyzygy> hiptobecubic: http://www.haskell.org/haskellwiki/User:Michiexile/MATH198
11:26:30 <DrSyzygy> Not a space station anywhere.
11:26:33 <hiptobecubic> DrSyzygy, I know of them, in that I very slowly read the wikipedia article four times in the last hour
11:26:47 <DrSyzygy> hiptobecubic: Okay. Here's my short spiel on a category.
11:26:48 <rostayob> hiptobecubic: you don't need to know about category theory either....
11:26:59 <hiptobecubic> rostayob, perhaps not, but now i'm interested :)
11:27:04 <rostayob> well, ok then
11:27:20 <DrSyzygy> A category is a thing that looks like what people in algebra and topology had been doing for a couple of decades already. It abstracts out the mathematical concept of a Function in a way that turns out to apply to all sorts of cases.
11:27:39 <DrSyzygy> Fundamentally, a category consists of Objects and Morphisms. Each morphism is associated to two objects -- a source and a target.
11:27:56 <DrSyzygy> And if you take a chain of morphism you can "compose" them - much like you would with functions -- to get a new morphism.
11:28:00 <hiptobecubic> DrSyzygy, yes. So far I think I got that part.
11:28:18 <DrSyzygy> Concretely, in our context we tend to talk about one category in particular: Hask. This has objects <Haskell types> and morphisms <Haskell functions>.
11:28:37 <DrSyzygy> So an object is something like Bool or Char or [String] -> (Int -> String)
11:28:38 <hiptobecubic> Ok
11:28:40 <parcs`> if Kleisli were [a] -> [b] it would be just a specialized function arrow
11:28:53 <DrSyzygy> A morphism is just any function you can write down.
11:29:07 <rostayob> [a] -> [b] is a useful arrow
11:29:13 <DrSyzygy> You'll notice that morphisms are members of haskell types as well -- this is a specific and kinda neat property that categories may or may not have.
11:29:39 <tzxn3> https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Introducing_State
11:29:48 <DrSyzygy> hiptobecubic: With me so far?
11:29:49 <ion> hiptobecubic: You could make a category of lists of functions. I’m not sure if that would be very useful, though. :-)
11:29:56 <hiptobecubic> DrSyzygy, yes
11:30:07 <hiptobecubic> so functions are objects and morphisms ?
11:30:10 <hiptobecubic> in Hask?
11:30:19 <tzxn3> I don't undestand what this code is doing
11:30:25 <DrSyzygy> hiptobecubic: objects in Hask are _datatypes_.
11:30:28 <ion> newtype LoF a b = LoF [a -> b]
11:30:39 <hiptobecubic> DrSyzygy, ohhh sorry. yes. that makes more sense
11:30:42 <DrSyzygy> hiptobecubic: morphisms in Hask are haskell functions.
11:30:47 <tzxn3> where does "get" actually stuff from?
11:30:51 <DrSyzygy> A function has an input datatype and an output datatype.
11:30:57 <Peaker> hehe
11:31:09 <Peaker> toying with Y-combinator in Haskell, and I managed to confuse GHC into hanging
11:31:26 <rostayob> Peaker: ? it's not hard to define the Y-combinator with Mu
11:31:27 <ion> id = LoF (pure id); (LoF fs) . (LoF gs) = LoF (liftA2 (.) fs gs) :-P
11:31:32 <DrSyzygy> hiptobecubic: Now, the next step is functors.
11:31:40 <hiptobecubic> DrSyzygy, pause
11:31:45 <DrSyzygy> hiptobecubic: Sure.
11:31:59 <hiptobecubic> DrSyzygy, So is the morphism just referring to source and target type? or the actual computation that the function does
11:32:06 <bgamari> How exactly should one go about locating a stack overflow that only turns up after 15 minutes of running with optimizations enabled
11:32:08 <hpaste> Peaker pasted “GHC hangs” at http://hpaste.org/64742
11:32:26 <DrSyzygy> hiptobecubic: The morphism is the function. But part of what a morphism is is that it knows where it starts and where it ends.
11:32:29 <bgamari> Things get at least an order of magnitude slower with -prof, so -xc is out it seems
11:32:43 <Peaker> rostayob: GHC hangs when *compiling* this program...
11:32:59 <tzxn3> I mean, rollDie doesn't take any arguments
11:33:05 <monochrom> "data L = L { l :: L -> L } | LitInt Int" I see what you're doing there! :)
11:33:12 <Peaker> (I thought it might be instance resolution, but it only hangs if "test" is actually used)
11:33:27 <tzxn3> I can see it getting a generator value from somewhere and then putting the new generator value in that somewhere
11:33:31 <Peaker> hehe, that's actually for a different test. I forgot to take it out in my minimal example
11:33:32 <DrSyzygy> hiptobecubic: Now what we basically have so far is a definition of an algebraic object. A category is a thing with objects and morphisms, such that things behave nicely.
11:33:52 <hpaste> Peaker pasted “GHC hangs” at http://hpaste.org/64743
11:33:54 <DrSyzygy> hiptobecubic: Behaving nicely here means things like "function composition is associative" and "id exists"
11:33:55 <rostayob> Peaker: which ghc? 7.2 doesn't typecheck, 7.4 doesn't hang
11:34:01 <rostayob> which is weird
11:34:04 <Peaker> no such nonsense in the new version
11:34:08 <rostayob> since it should typecheck
11:34:12 <DrSyzygy> hiptobecubic: In particular, it seems almost ridiculously obvious when we discuss the Haskell category.
11:34:17 <Peaker> rostayob: The Glorious Glasgow Haskell Compilation System, version 7.4.1
11:34:19 <int-e> Peaker: http://hackage.haskell.org/trac/ghc/ticket/668
11:34:22 <hiptobecubic> DrSyzygy, so the morphism "odd" is from the object Int to the object Bool, but it also includes the logic of the function to differentiate it from the other morphisms with the same source and target?
11:34:31 <DrSyzygy> hiptobecubic: Yes.
11:34:50 <rostayob> Peaker: doesn't hang
11:34:50 <DrSyzygy> hiptobecubic: In particular, odd :: Int -> Bool is a different morphism from even :: Int -> Bool.
11:34:55 <rostayob> Peaker: with 7.4.1
11:35:01 <hiptobecubic> DrSyzygy, yes that's what I was thinking. ok
11:35:17 <hiptobecubic> DrSyzygy, is there a word for the set of morphisms of type Int -> Bool?
11:35:28 <int-e> rostayob: hmm, try to compile the code rather than load it in ghci?
11:35:33 <monochrom> tzxn3: "GeneratorState Int" expands after a few steps to "StdGen -> (a, StdGen)". it has an argument. when you write "runState x y", y is passed as that argument.
11:35:35 <DrSyzygy> hiptobecubic: Sure. It's the set of morphisms Hom(Int, Bool)
11:35:39 <Peaker> rostayob: weird...
11:35:42 <Peaker> int-e: thanks
11:35:47 <hiptobecubic> DrSyzygy, Hom?
11:36:24 <rostayob> int-e: right, now it hangs
11:36:46 <singpolyma> Can I pattern match on (or even create values for)   Infinity and NaN ?
11:36:47 <Peaker> int-e: I guess it's trying to inline it because it can't see that the function is an infinite loop since the recursion is hidden?
11:36:49 <DrSyzygy> hiptobecubic: Or, in Haskell, it's the morphisms of type Int -> Bool.
11:36:49 <DrSyzygy> hiptobecubic: In particular, all this makes Category into an essentially algebraic idea.
11:36:49 <DrSyzygy> hiptobecubic: So we can apply algebraic techniqeus to them.
11:36:53 <DrSyzygy> hiptobecubic: We can, for instance, ask what a map between categories should look like.
11:37:09 <DrSyzygy> hiptobecubic: Hom = Homomorphisms. Comes from the algebraic heritage of category theory.
11:37:36 <hiptobecubic> DrSyzygy, ok
11:37:39 <ion> > case 0/0 of x | isNaN x -> "foo"
11:37:40 <lambdabot>   "foo"
11:37:43 <int-e> rostayob: (since it's not the type-checker but the inliner that loops -- and ghci does not enable the inliner by default)
11:37:55 <DrSyzygy> hiptobecubic: A map between categories should map objects to new objects. And it should map morphisms to morphisms. And things that compose should still compose. And the source/target should follow along.
11:38:05 <hiptobecubic> DrSyzygy, so between categories, would be object -> object?
11:38:08 <rostayob> Peaker: http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html#bugs-ghc
11:38:11 <rostayob> interesting
11:38:19 <tzxn3> I've been looking at this every day for the past week and I still don't get it
11:38:24 <hiptobecubic> DrSyzygy, yes ok
11:38:39 <DrSyzygy> hiptobecubic: So in particular, a map from Hask to Hask should assign to each data type t a new datatype F t, and to each function s -> t a new function F s -> F t.
11:38:53 <int-e> Peaker: I /guess/ the extraordinary thing is that inlining does not change the code -- it's a fixed point after all. usually it will become larger or smaller.
11:38:54 <Peaker> The simply-typed Lambda Calculus does not allow recursive types (e.g: Mu), right?
11:39:04 <tzxn3> State state result = State { runState :: state -> (result, state) }
11:39:07 <DrSyzygy> hiptobecubic: Since datatypes behave the way they do, in Haskell it is enough to have a constructor of kind * -> * to build the object side of a functor.
11:39:08 <rostayob> Peaker: no
11:39:10 <monochrom> tzxn3: you probably should play with Control.Monad.State first
11:39:12 <hiptobecubic> DrSyzygy, so if Int maps to A and Bool maps to B and even to C, then C should be of type A -> B?
11:39:21 <Peaker> int-e: ah, heh, I was wondering why my computer wasn't becoming unusable as ghc continued
11:39:33 <Peaker> rostayob: if it did, you could sneak in the y combinator?
11:39:34 <DrSyzygy> hiptobecubic: and the function side shows up from fmap :: (a -> b) -> (F a -> F b)
11:39:34 <ion> tzxn3: This may or may not be useful. http://heh.fi/state-monad
11:39:37 <Peaker> and make it unsound?
11:39:38 <rostayob> Peaker: yes
11:39:41 <tzxn3> I don't understand what it does though
11:39:49 <DrSyzygy> hiptobecubic: If you have a functor it will map each datatype to exactly one datatype.
11:39:58 <DrSyzygy> So Bool cannot map to both B and C.
11:40:04 <tzxn3> oh thanks ion
11:40:06 <DrSyzygy> Because the functor changes datatypes.
11:40:08 <singpolyma> ion: thanks, I guess that will work :)
11:40:10 <Peaker> ah, TIL that Haskell's type system allows sneaking recursion in through the back door that way :)
11:40:11 <rostayob> Peaker: you can write a Y combinator that looks exactly like the one in untyped lambda calculus with equi-recursive typed
11:40:13 <DrSyzygy> Here is when you want to start thinking about [].
11:40:25 <rostayob> Peaker: in haskell you have to pack/unpack the newtype
11:40:26 <DrSyzygy> hiptobecubic: If you have a datatype t, then [t] is a datatype.
11:40:28 <rostayob> but it's still similar
11:40:44 <DrSyzygy> hiptobecubic: and if you have a map s -> t, there is a particularly nice function map :: [s] -> [t].
11:40:55 <Peaker> rostayob: yeah, that's what I did today, as a pedagogical exercise, which surprised me, I thought Haskell was supposed to allow recursion only via "fix" or explicit recursive references
11:41:04 <Peaker> rostayob: and I guess it also catches the GHC inliner by surprise, too :)
11:41:23 <hiptobecubic> DrSyzygy, ok let me digest for a minute
11:42:00 <rostayob> Peaker: it's strange because I clearly remember writing it as well and not hitting that bu
11:42:02 <rostayob> g
11:43:32 <ion> drsyzygy: Are there other sensible maps from Hask to Hask than adding F in front of data types and the function’s input and output types?
11:43:40 <DrSyzygy> ion: Define sensible.
11:43:55 <hiptobecubic> DrSyzygy, so i'm clear. [t] is the same as m t where m is lists, yes?
11:44:01 <DrSyzygy> hiptobecubic: Yes.
11:44:19 <DrSyzygy> ion: It's actually kinda difficult to write down functor-ish things that aren't functors in Haskell.
11:44:32 <DrSyzygy> I'm sure we can figure one out, but they tend to have a slightly artificial feel to them.
11:45:17 <DrSyzygy> ion: Basically, just like you tend to want linear maps between vector spaces, you kinda really want functors between categories.
11:45:24 <hiptobecubic> DrSyzygy, "* -> *" is a kind? Meaning ... thing from a thing to a thing?
11:45:25 <ion> drsyzygy: How about an illustrative example outside Haskell?
11:45:31 <DrSyzygy> hiptobecubic: Yes.
11:45:33 <ion> or outside Hask
11:46:03 <DrSyzygy> ion: Sure! One nice bunch of categories show up from partially ordered sets.
11:46:25 <DrSyzygy> ion: So you have the partial order a < b < c, right? and another partial order d > e < f.
11:46:26 <ion> I get (a -> b) -> (F a -> F b) but i have no understanding of functors outside Hask.
11:46:34 <hiptobecubic> :t map
11:46:35 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:46:38 <hiptobecubic> :t fmap
11:46:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:46:56 <ion> drsyzygy: d > e < f or d < e < f?
11:46:59 <DrSyzygy> ion: So both these have three elements. one of them have all elements in a row, the other orders them so that e is smaller than both d and f, but we cannot compare d and f directly.
11:47:09 <ion> ok
11:47:31 <DrSyzygy> Here is one functor from abc to def: a->e b->d c->f.
11:47:38 <DrSyzygy> wait.
11:47:38 <quintessence> ion: if you count newtypes as only isomorphic (but not equal) to their base types, then the identity functor doesn't add an F in front of types
11:47:49 <DrSyzygy> first of all: here is how you make categories out of partial orders.
11:48:09 <DrSyzygy> objects are the elements of the poset. and there is EXACTLY one morphism x -> y iff x <= y.
11:48:18 <hiptobecubic> poset?
11:48:24 <DrSyzygy> partially ordered set.
11:48:27 <hiptobecubic> ok
11:48:44 <DrSyzygy> So in abc we have morphisms a->a, a->b, a->c, b->b, b->c, c->c.
11:49:08 <DrSyzygy> In def we have morphisms d->d, e->e, e->d, e->f, f->f.
11:49:29 <ion> ok
11:49:40 <shergill> oh gotta love a language which teaches you new math
11:49:47 <DrSyzygy> Now, a functor from abc to def is for instance a->e, b->d, c->f and all the maps go where they need to.
11:49:49 <rostayob> shergill: it's more the users of the language
11:49:56 <adimit> shergill: you'll love Haskell…
11:49:58 <DrSyzygy> no wait.
11:50:03 <DrSyzygy> I'm stupid. sorry.
11:50:05 <rostayob> shergill: you can write great haskell without knowing a thing about category theory
11:50:06 <cmccann> Peaker, btw, you can sneak term-level recursion in by hiding it with any other kind of general recursion
11:50:19 <hiptobecubic> DrSyzygy, so we can only map to larger values?
11:50:24 <DrSyzygy> A functor def -> abc is d->b e->a f->c and all morphisms go where they need to.
11:50:29 <shergill> rostayob: i know. but it's not as fun. then again i have a perverse sense of fun
11:50:35 <DrSyzygy> hiptobecubic: you have to be able to map morphissm.
11:50:53 <rostayob> shergill: mah I'm sure a lot of people have more fun programming than learning category theory :P
11:50:55 <DrSyzygy> what I wrote up there earlier is an example of a non-functor function between the object sets.
11:51:07 <rostayob> shergill: but yes theory is alluring
11:51:16 <Rotaerk> hmm, in Oracle, there is a way to express a string/character literal like:  q'<delimiter character><quoted characters><delimiter character>'
11:51:16 <DrSyzygy> because there IS a moprhism b->c, but there is no morphism d->f.
11:51:28 <Rotaerk> so for instance:  q'!'!' is a quoted apostrophe
11:51:37 <DrSyzygy> You can construct examples where all objects map, all morphisms map, but the composition breaks down.
11:51:38 <shergill> rostayob: programming is cool, don't get me wrong. but for me it's being able to understand what the heck half the blog posts are on about
11:51:45 <Rotaerk> I'm trying to figure out how to parse that construct using fparsec...
11:51:56 <_mpu> is there a standard way to catch io errors via, IO, I tried catch but the typechecker complains, how can I fix that?
11:52:01 <Rotaerk> is there a way to refer back to the value of a character that was previously parsed
11:52:01 <shergill> perhaps i shouldn't subscribe to so many blogs by mathematicians
11:52:11 <rostayob> _mpu: post code and the actual error
11:52:12 <shergill> _mpu: catch?
11:52:14 <hiptobecubic> DrSyzygy, need to read that again...
11:52:19 <DrSyzygy> shergill: I started out as a pure mathematician, doign stuff close to category theory. I took up haskell BECAUSE categories are so useful and closely related to the language.
11:52:30 <Rotaerk> (fparsec is F#'s version of parsec, so an understanding of how to do it in parsec would translate)
11:52:34 <shergill> DrSyzygy: heh
11:52:44 <rostayob> I started out as a pure programmer and I don't know who I am anymore :(
11:53:03 <cmccann> shergill, I think the rule of thumb is that Haskell enthusiasts are people who programmers think are mathematicians and mathematicians think are programmers
11:53:10 <shergill> rostayob: a haskeller?
11:53:14 <Rotaerk> do I have to use user state for that?
11:53:23 <shergill> cmccann: yeah, that seems to be the general consensus
11:53:40 <adimit> cmccann: what do mathematicians think non-Haskell programmers are?
11:53:46 <_mpu> rostayob: http://hpaste.org/64746
11:53:54 <shergill> adimit: not worth their time? :P
11:54:08 <monochrom> Rotaerk: do { char 'q'; char '\''; d <- anyChar; from now on you can use d for as long as you like } ?
11:54:14 <ion> drsyzygy: Ok, thanks, i can see how the map works. What would be an example of a use case for the map between posets?
11:54:14 <DxBlueIce> hey, can anyone help me with HOpenGL (3D room/level)?
11:54:29 <hiptobecubic> rostayob, I started out as a environmental biologist :) Don't feel bad
11:54:30 <rostayob> _mpu: what about the error
11:54:33 <DrSyzygy> ion: Suppose the poset structure is accidential, and what you really care about is some other property.
11:54:42 <_mpu> rostayob: in this case it typechecks, but I had to add my putStrLn + show to inform it about the type of e
11:54:47 <DrSyzygy> ion: Or suppose there are several valid poset structures on a set together with whatever other structure you are interested in.
11:54:51 <_mpu> rostayob: How can I avoid doing this?
11:54:53 <hiptobecubic> DrSyzygy, ok so we're limited to x <= y because otherwise we can't bring the morphisms from one category to the other?
11:54:58 <Rotaerk> ah hmm... I hadn't tried the monadic mechanisms of parsec yet
11:55:01 <DrSyzygy> hiptobecubic: exactly
11:55:06 <rostayob> _mpu: you can't, e has to be monomorphic because of typeable
11:55:21 <DrSyzygy> ion: For instance, you can define a total order on complex numbers; but in very many ways, none of which are always appropriate.
11:55:23 <rostayob> _mpu: it probably told you "ambiguous variable something"
11:55:30 <_mpu> rostayob: yes
11:55:31 <hiptobecubic> is eachpost it's own category in this example? And we're mapping between categories when we map between posets?
11:55:36 <rostayob> _mpu: do you know about Typeable?
11:55:41 <hiptobecubic> DrSyzygy, Is each poset* ^
11:55:43 <monochrom> Rotaerk: F# also has mutable variables, you can certainly create one to store d
11:55:47 <DrSyzygy> ion: But you can still do, say, complex analysis in spite of this, and you may well have complex analytic functions that might or might not agree with the orderings involved.
11:56:03 <DrSyzygy> hiptobecubic: Every poset is a category with the construction I talked about above.
11:56:09 <hiptobecubic> DrSyzygy, ok.
11:56:14 <_mpu> rostayob: yes, I know a bit of it, but is there a convenient way to grab only IOException errors?
11:56:21 <rostayob> _mpu: the way you did it
11:56:21 <DrSyzygy> A total order is a poset in which any pair of objects are comparable.
11:56:21 <hiptobecubic> DrSyzygy, are "posets" also a category?
11:56:28 <quintessence> _mpu: you can put a type signature on e
11:56:35 <monochrom> generally you can always create your own variables (mutable or not) to store important things that you read now and use later. I don't understand the need for the parser library to do that for you.
11:56:37 <rostayob> _mpu: you can put the type signature directly next to the lambda, which is nicer
11:56:40 <DrSyzygy> hiptobecubic: Yup. And morphisms for the category of posets are maps that respect ordering.
11:56:46 <DrSyzygy> hiptobecubic: So that if a < b then f(a) < f(b)
11:56:49 <rostayob> _mpu: but that's your way to tell ghc: I want only IOExceptions!
11:56:52 <DrSyzygy> so exactly the functor condition, really.
11:57:01 <_mpu> rostayob: no I can't the compiler tells me it is forbidden :(
11:57:03 <hiptobecubic> DrSyzygy, ok yes. I'm feeling it.
11:57:06 <rostayob> _mpu: catch needs a type to try to cast the exception that it casted to.
11:57:14 <rostayob> _mpu: you need to enable ScopedTypeVariables
11:57:15 <hiptobecubic> So
11:57:17 <rostayob> :t cast
11:57:18 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
11:57:37 <hiptobecubic> DrSyzygy, I think I'm caught up with you so far. If you were intending to continue
11:57:58 <_mpu> rostayob: would you be kind enough to remind me the syntax to add this in my hs file?
11:58:02 <DrSyzygy> hiptobecubic: Right. So if you are starting to get a feeling for functors, I want to start talking about endofunctors.\
11:58:11 <DrSyzygy> hiptobecubic: Or in other words, functors from Hask back to Hask again.
11:58:17 <rostayob> _mpu: {-# LANGUAGE ScopedTypeVariables #-}
11:58:22 <rostayob> usually at the top of your file
11:58:23 <_mpu> rostayob: thanks :)
11:58:27 <rostayob> _mpu: yw :)
11:58:35 <DrSyzygy> hiptobecubic: Here's one nice thing about functors Hask -> Hask: almost all of them make sense as "data containers".
11:58:53 <DrSyzygy> hiptobecubic: Because 1. a functor assigns to each data type a new data type -- the type contained.
11:59:16 <hiptobecubic> DrSyzygy, what do you mean?
11:59:17 <DrSyzygy> hiptobecubic: 2. functions between datatypes act on the "inside" by the fmap property of functors.
11:59:27 <DrSyzygy> hiptobecubic: 3. id has to fix things for a functor.
11:59:36 <DrSyzygy> hiptobecubic: 4. function composition has to work.
11:59:37 <_mpu> rostayob: heck,  Result signatures are no longer supported in pattern matches
11:59:55 <DrSyzygy> These 4 observations together force something that looks a lot like a data type container.
11:59:58 <rostayob> _mpu: mhm?
12:00:12 <DrSyzygy> hiptobecubic: So if F is a functor, and t is some datatype, we know that F t is some datatype.
12:00:16 <hiptobecubic> Also, you called "a -> e, b->d, c->f" a functor before, but it is also a morphism in the category of posets, right?
12:00:21 <quintessence> _mpu: you need parens around (e :: IOError)
12:00:24 <_mpu> rostayob:  In a lambda abstraction: \ _ :: IOException -> listdir d l
12:00:29 <Rotaerk> monochrom, well, at least with fparsec, I can't just store the result of a parser into a variable and then use it in another parser, all as part of a larger parser
12:00:39 <DrSyzygy> hiptobecubic: Yes. And because each poset is a category, we get functoriality.
12:00:40 <Rotaerk> I think
12:00:49 <DrSyzygy> hiptobecubic: There is a category of all categories, and morphisms in this category are functors.
12:00:52 <Rotaerk> because the result isn't obtained until you *run* the parser
12:01:04 <Rotaerk> however, the bind operator will work
12:01:06 <statusfailed> What do the "some" and "many" functions do in the "alternative" class?
12:01:13 <_mpu> quintessence: you were right, thanks.
12:01:21 <DrSyzygy> hiptobecubic: ... actually, I realized that this abc -> def wasn't a morphism - it was the function def -> abc that was.
12:01:45 <hiptobecubic> DrSyzygy, ok. So functors specifically refer to the morphisms in the category of categories
12:01:52 <DrSyzygy> hiptobecubic: EXACTLY!
12:02:16 <hiptobecubic> DrSyzygy, and endofunctors are morphisms for which the source and target are the same object?
12:02:19 <ion> What would be an example of a non-endo functor?
12:02:23 <DrSyzygy> hiptobecubic: Yup.
12:02:28 <hiptobecubic> let me try
12:02:35 <DrSyzygy> ion: Anything where source and target category are different.
12:02:51 <cmccann> ion, half of ContT is an interesting, Haskell-relevant example
12:02:52 <hiptobecubic> So for example the one you mentioned earlier, between posets
12:03:01 <hiptobecubic> is a non-endofunctor
12:03:17 <DrSyzygy> hiptobecubic: Yup. Because the posets are different and therefore form different categories.
12:03:26 <ion> OK, thanks
12:03:41 <DrSyzygy> hiptobecubic: So if F is a functor and t is a datatype, F t is some datatype.
12:03:59 <DrSyzygy> hiptobecubic: You know that id :: F t -> F t exists, and doesn't change things.
12:04:02 <hiptobecubic> Whereas Haskell functions (morphisms in Hask) are all endofunctors?
12:04:04 <cmccann> ion, i.e. "newtype F r m a = F (a -> m r)"
12:04:13 <DrSyzygy> hiptobecubic: Haskell Functors are all endofunctors.
12:04:20 <DrSyzygy> hiptobecubic: Haskell functions are all morphisms.
12:04:21 <cmccann> where composing F with itself gives you ContT
12:04:49 <DrSyzygy> hiptobecubic: You know that fmap :: (t -> s) -> (F t -> F s) exists, and that fmap id :: F t -> F t has to be the same as id.
12:04:51 <ion> cmccann: Oh, interesting.
12:04:52 <hiptobecubic> DrSyzygy, ok wait. Let me crystalize functor/function/morphism.
12:05:12 <dever> hey all, I want to use some modules in the GHC package, is there anyway of unhiding this package?
12:05:14 <DrSyzygy> hiptobecubic: And you know that fmap (g . f) is what you expect it to be. So fmap lets you operate inside F automatically.
12:05:19 <DrSyzygy> okay. Crystalize away.
12:05:48 <byorgey> dever: ghc-pkg expose ghc
12:06:01 <cmccann> also, Functor instances necessarily define proper subcategories of Hask, so you could also imagine functors between those subcategories
12:06:12 <byorgey> dever: alternatively, make a cabal package for your code and specify ghc as a dependency
12:06:44 <DrSyzygy> cmccann: _proper_ subcategories?
12:07:22 <DrSyzygy> cmccann: Oh wait .. yeah, even a trivial functor adds a constructor wrapping, so I guess it's prudient to talk about proper subcategories for Functor instances.
12:07:29 <DrSyzygy> cmccann: As opposed to actual endofucntors.
12:07:32 <cmccann> DrSyzygy, er, maybe not the correct term? in the sense that there's no true identity functor, &c.
12:07:40 <DrSyzygy> cmccann: Yeah, I realized.
12:07:45 <cmccann> yeah
12:07:48 <hiptobecubic> DrSyzygy, ok so Haskell Funtors are all endofunctors, but functions are morphisms... which are functors in the category of categories, of which Hask is one. So can functions, which are morphisms from something in Hask to something else in Hask also be called functors?
12:08:00 <DrSyzygy> hiptobecubic: no, wait...
12:08:10 <DrSyzygy> hiptobecubic: Any category needs to have a concept of what it means to be a morphism.
12:08:16 <DrSyzygy> hiptobecubic: Morphisms in Hask are haskell function.
12:08:17 <hiptobecubic> DrSyzygy, yes i just read that again andit makes no sense. Let me try again :)
12:08:19 <tomprince> DrSyzygy: They are endofunctors, but they just aren't essentially surjective.
12:08:23 <DrSyzygy> hiptobecubic: Morphisms in the category of categories are functors.
12:08:26 <cmccann> DrSyzygy, obviously if you squint a bit and look through any newtype wrappers then that's not the case though
12:08:35 <hiptobecubic> Morphisms in hask are definitely functions. Very clear on that.
12:08:52 <DrSyzygy> cmccann: There are several ways in which actual haskell is not a perfect reification of category theory.
12:08:54 <tomprince> Or maybe, not surjective, but potentially essentially surjective.
12:09:16 <cmccann> DrSyzygy, that's probably an understatement but yes :]
12:09:48 <DrSyzygy> cmccann: What fascinates me is the extent to which it fails to be more of an understatement than you'd think.
12:09:55 <t7> is /\ AND or OR ?
12:10:04 <DrSyzygy> t7: and IIRC
12:10:15 <DrSyzygy> t7: But I would tend to call it 'meet'.
12:10:16 <hiptobecubic> Morphisms in category of categories are the functors. So *some* functions are also functors, if their source and targets an be called categories?
12:10:21 <DrSyzygy> </lattice-theory>
12:10:30 <DrSyzygy> hiptobecubic: Yeeah.
12:11:06 <hiptobecubic> the Monads, are thus, a category?
12:11:23 <DrSyzygy> weeeeell...
12:11:27 <cmccann> DrSyzygy, it mostly manifests as _|_ undermining properties you'd expect to have, plus things being unclear because anything morphism-like getting flattened down to some sort of function
12:11:27 <ion> The kleisli monad is, right?
12:11:32 <hiptobecubic> Which are also a haskell data type, making them objects in Hask?
12:11:40 <DrSyzygy> where we started was the observation that given a monad M, there IS a category associated to it.
12:12:15 <hiptobecubic> "associated to it"?
12:12:20 <DrSyzygy> yes.
12:12:27 <cmccann> DrSyzygy, like type for (>>=) vs. its counterpart for a comonad. some of the arrows flip and others don't and it's not clear why unless you step away from Haskell and look at the "real thing"
12:12:29 <DrSyzygy> The Kleisli category of a monad is a NEW category that uses the monad in its definition.
12:12:37 <DrSyzygy> cmccann: Right.
12:12:55 <DrSyzygy> hiptobecubic: So we can build new categories by just describing objects and morphisms.
12:13:10 <DrSyzygy> and morphisms don't HAVE to be functions. Nor do they have to be the functions you think they are.
12:13:21 <DrSyzygy> So here is a category you can build using a monad M.
12:13:27 <DrSyzygy> Objects are just datatypes.
12:13:33 <hiptobecubic> can you give me an example of a morphism which isn't a function?
12:13:44 <hiptobecubic> in any sense? not in haskell
12:13:47 <DrSyzygy> hiptobecubic: a->b in the poset as a category.
12:13:57 <DrSyzygy> that one isn't a function, it's an ordering relation.
12:14:05 <hiptobecubic> oh
12:14:07 <ion> Ooh, i was thinking of it as a function.
12:14:10 <hiptobecubic> me too
12:14:25 <DrSyzygy> Now a morphism s -> t in the Kleisli category is defined to be a function s -> M t in Hask.
12:14:27 <cmccann> looking at a monoid as a single-object category is instructive here I think
12:14:37 <shergill> DrSyzygy: a->b being defined iff a <= b?
12:14:44 <DrSyzygy> cmccann: To disabuse people of the morphism=function idea?
12:14:45 <cmccann> where the arrows are actually the "values" and the monoid operation is composition
12:14:46 <DrSyzygy> shergill: Yup.
12:14:47 <cmccann> yes
12:14:55 <shergill> ok
12:15:00 <DrSyzygy> Okay. So pause in the kleisli exposition.
12:15:05 <DrSyzygy> hiptobecubic: You know what a monoid is?
12:15:12 <byorgey> shergill: composition in that category just corresponds to the transitivity law.
12:15:20 <hiptobecubic> DrSyzygy,
12:15:21 <hiptobecubic> yes
12:15:38 <DrSyzygy> So a monoid gives rise to a category.
12:15:46 <DrSyzygy> This category has one "virtual" object.
12:15:50 <DrSyzygy> Call it o
12:16:11 <DrSyzygy> And the set of all morphisms o->o is exactly the set of elements in the monoid.
12:16:16 <hiptobecubic> why is it virtual?
12:16:26 <DrSyzygy> hiptobecubic: Because it doesn't play any role other than placeholder.
12:16:34 <DrSyzygy> hiptobecubic: All the action is among the morphisms.
12:16:40 <DrSyzygy> the identity morphism is the identity element of the monoid.
12:16:40 <hiptobecubic> ah
12:16:55 <DrSyzygy> and the composition of morphisms is given by the operation in the monoid.
12:18:14 <hiptobecubic> thinking
12:19:12 <hiptobecubic> So if we take the monoid of integers with addition
12:19:18 <DrSyzygy> sure
12:19:29 <DrSyzygy> there is a morphism called 3 and another one called 5.
12:19:32 <ion> o → o is a natural number?
12:19:41 <DrSyzygy> ion: Yup.
12:19:44 <DrSyzygy> Well...
12:19:48 <hiptobecubic> an integer
12:19:52 <DrSyzygy> each natural number is an o->o.
12:20:11 <hiptobecubic> how is 3 a morphism?
12:20:34 <DrSyzygy> hiptobecubic: You said we would consider the monoid of integers.
12:20:58 <ion> It satisfies the laws. (3 . 4) . 5 = 3 . (4 . 5) and 3 . id = id . 3 = 3
12:21:00 <DrSyzygy> hiptobecubic: I said that if we have a monoid, it makes a category with just one object, and where the morphisms are just the elements of the monoid.
12:21:45 <DrSyzygy> hiptobecubic: So 3 is a morphism o->o because each monoid element becomes a morphism o->o.
12:21:56 <DrSyzygy> hiptobecubic: And we need for composition to be defined.
12:22:14 <DrSyzygy> You said monoid under addition; so 3 . 4 is going to be 7, and (3.4).5 is going to be 12.
12:22:22 <DrSyzygy> similarily 3.(4.5) = 12.
12:22:50 <hiptobecubic> DrSyzygy, ok yes. You did say that. But this example suggests that i'm not following it. For some reason I expected (+) to be the morphism. I guess that doesn't work though, as it's binary
12:23:02 <hiptobecubic> ohhhh wait
12:23:09 * cmccann notes that the monoid of church numerals under multiplication actually works this way
12:23:20 <DrSyzygy> cmccann: :-P
12:23:29 <hiptobecubic> the composition of morphisms is the binary relation
12:23:32 <LeNsTR> guys, what are you thinking about https://github.com/nominolo/scion ?
12:23:37 <DrSyzygy> hiptobecubic: Exactly!!
12:24:07 <hiptobecubic> oh wow
12:24:23 <DrSyzygy> :-)
12:24:48 <LeNsTR> someone using it?
12:25:35 <hiptobecubic> OK
12:25:51 <cmccann> hm, would something like "\x -> Endo (mappend x)" amount to explicitly constructing this view of monoids in Haskell?
12:25:53 <DrSyzygy> hiptobecubic: So you understand how monoid-as-category works?
12:25:59 <DrSyzygy> cmccann: Possibly.
12:26:33 <hiptobecubic> DrSyzygy, i think so. The elements of the monoid are actually morphisms in the category, with composition defined as the binary operator
12:26:45 <DrSyzygy> exactly
12:26:55 <DrSyzygy> and here we see how morphisms need not have ANYTHING to do with functions.
12:26:58 <hiptobecubic> so lists ARE a category :D
12:27:14 <DrSyzygy> sure.
12:27:15 <hiptobecubic> well "the lists"
12:27:25 <hiptobecubic> the actual lists are morphisms
12:27:36 <hiptobecubic> with composition being (++)
12:27:40 <DrSyzygy> yup
12:27:41 <hiptobecubic> ok
12:28:02 <DrSyzygy> Now to kleisli, shall we?
12:28:10 <hiptobecubic> Lets
12:28:25 <t7> http://en.wikipedia.org/wiki/Iota_and_Jot mind = blown
12:28:48 <DrSyzygy> So, given a monad M in Hask, we can construct a new category entirely.
12:28:53 <ion> Btw, can you encode this as an instance of Category any way? You’d have to pass * -> * to something that wants * -> * -> *, saying the two parameters are the same. :-P
12:29:00 <DrSyzygy> ion: Probably...
12:29:24 <DrSyzygy> Kleisli(M) has as objects datatypes in Haskell.
12:29:25 <Tomsik> t7: you need just three counters that you can add 1 to and check if they are empty
12:29:46 <DrSyzygy> But a morphism from s to t in Kleisli(M) is a function s -> M t
12:30:04 <DrSyzygy> and function composition works by g . f = join . fmap g . f
12:30:08 <hiptobecubic> DrSyzygy, a monad M in Hask is also a data type, yes?
12:30:23 <DrSyzygy> hiptobecubic: No. A monad M is a functor equipped with extra structure.
12:30:38 <hiptobecubic> DrSyzygy, ah ok.
12:30:50 <DrSyzygy> hiptobecubic: In particular, a functor M is a monad if it has 1. return :: t -> M t, 2. join :: M M t -> M t
12:31:07 <DrSyzygy> such that these things obey laws that are VERY similar to the monoid laws.
12:31:23 <DrSyzygy> THIS is what people mean when they say "monoid in category of endofunctors" btw.
12:31:30 <hiptobecubic> Yes
12:32:28 <DrSyzygy> So now you can verify that in this definition of compositino we get all the things we need -- compositino is associative. composition with identity is as if you hadn't done anything.
12:32:37 <DrSyzygy> oh btw. id in Kleisli(M) is the same as return for M.
12:33:45 <hiptobecubic> DrSyzygy, return maps from Hask to M, right?
12:33:51 <DrSyzygy> yup.
12:34:10 <DrSyzygy> Weeelll, return is a natural transformation from Id to M.
12:34:46 <hiptobecubic> oh wait
12:34:51 <hiptobecubic> what?
12:35:08 <DrSyzygy> So _functors_ with fixed source and target also form a category.
12:35:49 <DrSyzygy> And a morphism from F to G in this category is a collection of morphisms that transform any F s -> F t in to an G s -> G t in a good way.
12:35:51 <hiptobecubic> There are functors that don't have a fixed source and target? I thought functors were morphisms in the category of categories? And morphisms were inherently associated with a source and target?
12:36:06 <DrSyzygy> hiptobecubic: Nono, but any pair of functors don't have to have the same sources and targets.
12:36:24 <DrSyzygy> But if we consider ALL functors from C to D, then this collection forms a category.
12:37:03 <hiptobecubic> Oh you mean many different functors, each of which happening to have the same source objects and target objects?
12:37:09 <DrSyzygy> yes
12:37:21 <hiptobecubic> for which source and target are not necessarily the same object
12:38:00 <Saizan> source and target categories (objects of Cat)
12:38:27 <DrSyzygy> yup
12:38:58 <hiptobecubic> If we back track for a moment
12:39:16 <hiptobecubic> 3 was a morphism with source and target 'o'
12:39:43 <hiptobecubic> what *is* 'o' there?
12:39:43 <DrSyzygy> yeah
12:39:50 <DrSyzygy> hiptobecubic: Just a symbol.
12:40:18 <hiptobecubic> 3 is a morphism with source '' and target ''? where the source and target are just irrelevant?
12:40:26 <byorgey> o was the name we happened to pick for the single object in the monoid category
12:40:48 <DrSyzygy> hiptobecubic: Not entirely irrelevant. source and target has to be the same thing.
12:40:56 <hiptobecubic> yes
12:40:58 <hiptobecubic> ok
12:41:07 <hiptobecubic> But there's only one thing
12:41:23 <DrSyzygy> sure
12:41:52 <hiptobecubic> ok
12:42:06 <hiptobecubic> So back to functors from C to D
12:42:11 <DrSyzygy> Right.
12:42:16 <DrSyzygy> Let F and G both be functors from C to D.
12:42:18 <ion> How is the set of all functors from C to D a category? How do you compose f :: C -> D and g :: C -> D?
12:42:27 <ion> How do you get id :: C -> D?
12:42:29 <DrSyzygy> ion: That's what I'll tell you about.
12:42:32 <ion> :-)
12:42:33 <cemycc> How can i write a function that returns the value of a fibonaci number but with accumulator . I have write the function in the simple method: gfb n = if n == 1 then 1
12:42:33 <cemycc>     else if n == 0 then 0
12:42:33 <cemycc>     else gfb (n-1) + gfb (n-2)
12:42:47 <DrSyzygy> Now the OBJECTS are functors C -> D. The MORPHISMS are an entirely new thing that I'll tell you about now.
12:42:52 <ion> ah
12:43:01 <DrSyzygy> A _natural transformation_ from F to G is a collection of morphisms in D.
12:43:20 <DrSyzygy> Namely, for any object s in C, there is a resulting morphism F s -> G s.
12:43:50 <hiptobecubic> i need a pencil and paper
12:44:08 <DrSyzygy> And for any morphism s -> t in C we require that if we first go F s -> G s and then go G s -> G t, or first F s -> F t and then F t -> G t, the resulting map F s -> G t should always be the same both ways.
12:44:22 <Aune> DrSyzygy, Am I understanding this correctly? Hask is a category where the types {Int, Bool, Char} are objects and the functions {a -> b, Bool -> [Int] } are the morphisms. But arent some things both objects and morphisms, IE the arguments to {(Bool -> Int) -> (Int -> Char) -> Char}? Does this have any implications or do we just choose to view the object (a -> b) and the morphism (a -> b) as different entities?
12:44:36 <hpaste> xxx pasted “verotel” at http://hpaste.org/64747
12:44:51 <DrSyzygy> Aune: Yes, in Haskell there is an _internal hom_, i.e. morphisms are members of objects.
12:45:11 <Aune> DrSyzygy, ok
12:45:17 <byorgey> cemycc: try writing a function  (Integer, Integer) -> (Integer, Integer)  that takes two consecutive Fibonacci numbers and gives you the next pair, e.g. if you give it (2,3) it gives back (3,5)
12:45:24 <byorgey> cemycc: then see if you can go from there.
12:45:25 <DrSyzygy> Aune: And this is a particularly pleasant thing when it happens in a category.
12:45:53 <Algo> http://www.willamette.edu/~fruehr/haskell/evolution.html
12:45:54 <hiptobecubic> so we have a category that is made of morphisms from category C to category D
12:45:57 <Algo> [The Evolution of a Haskell Programmer]
12:46:01 <DrSyzygy> hiptobecubic: Yup.
12:46:11 <Aune> DrSyzygy, havent seen any of that in my book, do you have a link to something about that?
12:46:22 <hiptobecubic> and that means that the morphisms are now objets
12:46:25 <byorgey> Aune: look up "cartesian closed categories"
12:46:37 <DrSyzygy> Aune: I write a bit about it in my lecture notes. http://www.haskell.org/haskellwiki/User:Michiexile/MATH198
12:47:14 <Aune> byorgey, DrSyzygy, thanks
12:48:55 <DrSyzygy> hiptobecubic: Yup.
12:48:56 <quintessence> hiptobecubic: there's an object corresponding to the collection of morphisms between two given objects.  So there's an object (type) Int -> Int, but not an object corresponding to the individual morphism (+1).
12:48:59 <Aune> Is terminal object the same as bottom in Hask?
12:49:14 <DrSyzygy> Aune: Nooo, usually not, not quite.
12:49:24 <DrSyzygy> Aune: Terminal object is different depending on where you look for it.
12:49:34 <DrSyzygy> Aune: Bottom doesn't fit neatly into the category semantics.
12:49:41 <ion> drsyzygy: Could you give an example of C, D, F, G, s and t? C = Id, D = M for instance?
12:49:55 <ion> Or s = Id, t = M?
12:50:12 <DrSyzygy> ion: Okay. C = Hask, D = Hask, F = Id, G = [].
12:50:19 <DrSyzygy> s = Int, t = Bool.
12:50:23 <ion> Thanks
12:50:49 <DrSyzygy> So a natural transformation F -> G is a collection of maps s -> [s] and such that these commute with the fmaps.
12:51:00 <hiptobecubic> DrSyzygy, F = id?
12:51:09 <DrSyzygy> F = Id. The identity endomorphism.
12:51:29 <DrSyzygy> Now, here's one neat thing about a natural transformation:
12:51:37 <DrSyzygy> it's what gives us polymorphism in Haskell.
12:51:42 <hiptobecubic> we're looking at it as a morphism from C to D?
12:51:51 <DrSyzygy> as a morphism from F to G.
12:52:10 <hiptobecubic> Id is a morphism from Id to [] ?
12:52:23 <DrSyzygy> nooo, Id is a functor Hask -> Hask.
12:52:35 <DrSyzygy> And return is a morphism from Id to [].
12:52:53 <hiptobecubic> from Id to M ?
12:53:00 <DrSyzygy> Yup.
12:53:33 <tgeeky_> dzhus: wow, that is a cool statement.
12:53:42 <tgeeky_> DrSyzygy: ,even
12:53:53 <DrSyzygy> tgeeky_: It's the core of "Theorems for free"
12:54:06 <ion> f :: Id Int -> Id Bool, g :: Id Bool -> [] Bool, g . f :: Id Int -> [] Bool
12:54:16 <hiptobecubic> so is F id in Klielsi(m) or is it the id in Hask?
12:54:16 <ion> f :: Id Int -> [] Int, g :: [] Int -> [] Bool, g . f :: Id Int -> [] Bool
12:54:24 <DrSyzygy> hiptobecubic: All of this is in Hask.
12:54:41 <DrSyzygy> hiptobecubic: Kleisli is of surprisingly little use in mainstream haskell
12:54:59 <cemycc> byorgey: I have write than function : fibAcc (a,b) = (a+b, a+2*b) but my main function need to find what is the value for a natural number (n) from the Fibonacci numbers.
12:55:09 <DrSyzygy> though the way the Monad class is usually presented uses the Kleisli idea to get from join :: M M t -> M t to bind :: (t -> M t) -> M t -> M t
12:55:34 <ion> > > (permutations <=< subsequences) "hai"
12:55:35 <lambdabot>   <no location info>: parse error on input `>'
12:55:37 <ion> > (permutations <=< subsequences) "hai"
12:55:38 <lambdabot>   ["","h","a","ha","ah","i","hi","ih","ai","ia","hai","ahi","iah","aih","iha"...
12:55:48 <byorgey> cemycc: I think it would be easier if you made it go from (a,b) to (b, a+b)
12:55:48 <DrSyzygy> http://www.cs.sfu.ca/CourseCentral/831/burton/Notes/July14/free.pdf << uses the natural transformation property of polymorphic functions to do all sorts of awesome things.
12:56:00 <byorgey> cemycc: then your main function just has to repeat that function n times.
12:56:15 <Aune> Is  unit  "()" a terminal object in Hask, any morphism (a -> ()) ought to be competely isomorphic to (const ())? Also, is there any initial objects in Hask. Seems to me there shouldnt be.
12:56:32 <tgeeky_> DrSyzygy: so what is:  (C,D) = Hask, F= id X id, G= [[]], S=Int with the same statement?
12:56:36 <DrSyzygy> Aune: sounds about right I think...
12:56:54 <DrSyzygy> tgeeky_: So your F t = (t,t) ?
12:57:04 <byorgey> Aune: if you don't pay attention to _|_ then () is a terminal object  and   data Void   is an initial object.  But _|_ complicates matters.
12:57:07 <DrSyzygy> And your G t = [[t]] ?
12:57:07 <tgeeky_> DrSyzygy: I didn't define it, because you didn't use t anywhere?
12:57:22 <timthelion> Is there a built in function to return the longer of two lists?
12:57:25 <DrSyzygy> ....
12:57:33 <DrSyzygy> so your F s = (s,s) and your G s = [[s]] ?
12:57:38 <timthelion> like max for lists?
12:58:01 <DrSyzygy> tgeeky_: Then a natural transformation F -> G is a polymorphic function f :: (s,s) -> [[s]]
12:58:12 <byorgey> Aune: for example, there could actually be many morphisms  (a -> ()) depending on how much of 'a' is forced to be evaluated
12:58:29 <byorgey> Aune: and you can tell the difference when a contains _|_.
12:59:31 <tgeeky_> DrSyzygy: is this the stuff covered in Wadlers paper?
12:59:39 <timthelion> > let x = [0,1]; let y=[0,1,2] ; if length x > length y then x else y
12:59:40 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:59:42 <tgeeky_> DrSyzygy: I don't understand too many things here to ask anything else :O
12:59:45 <DrSyzygy> tgeeky_: To some extent. Might be hidden in type theory language.
12:59:54 <byorgey> timthelion: maximumBy (comparing length)
12:59:55 <Algo> http://www.willamette.edu/~fruehr/haskell/evolution.html [The Evolution of a Haskell Programmer]
13:00:07 <byorgey> timthelion: import Data.List for maximumBy and Data.Ord for comparing
13:00:20 <timthelion> byorgey: thanks
13:01:10 <singpolyma> Is there a good resource on the difference between a Monoid and a MonadPlus ?
13:01:18 <hiptobecubic> So a natural transformation is a morphism in the category of functors-with-identical-types?
13:01:20 <__zero> i want to concatenate actions, i know i have to use the >> operator with a fold just dont remember how to fold monads..
13:01:27 <rostayob> mhm after all this discussion I'm tempted to learn category theory as well
13:01:31 <__zero> what was the name of the function?
13:01:33 <rostayob> the best book is Acowley right?
13:01:36 <DrSyzygy> rostayob: Awesome
13:01:47 <DrSyzygy> rostayob: I'd like to think that my draft does a decent job. ;-)
13:02:01 <byorgey> rostayob: hahaha, I think you mean Awodey
13:02:03 <DrSyzygy> rostayob: But yeah, Awodey is a really nice book. A bit logic-and-maths-heavy.
13:02:18 <rostayob> right, Awodey
13:02:20 <ion> Do you mean <http://www.haskell.org/haskellwiki/User:Michiexile/MATH198> by your draft? I didn’t read it yet.
13:02:22 <byorgey> rostayob: but I will tell acowley that you like his book ;)
13:02:30 <rostayob> byorgey: yeah I messed them up :D
13:02:36 <hiptobecubic> @src maximumBy
13:02:36 <lambdabot> Source not found. Are you on drugs?
13:02:36 <rostayob> oh pierce wrote a book as well
13:02:37 <DrSyzygy> ion: Yes.
13:02:42 <ion> Ok, thanks
13:02:44 <DrSyzygy> ion: I'm considering making a book out of that.
13:02:46 <rostayob> I liked TaPL
13:02:48 <hiptobecubic> ouch
13:03:04 <rostayob> I think I'm going to go for Pierce after I finish the type theory book
13:03:10 <Aune> byorgey, Ok, if f :: a -> () forces the evaluation of its argument then the result will not be () but _|_ in the case where the argument evaluates to bottom. But if we restrict oursefls to Hask*, the 'subcategory' of Hask not including _|_, then it is () is terminal.
13:03:19 <ion> zero: Do you mean sequence_?
13:03:30 <Aune> In this case, why is Void initial?
13:03:53 <__zero> ion: hmm yes that one would work
13:03:57 <__zero> ion: thanks
13:04:00 <cemycc> byorgey: can you please tell me how I repeat a function in haskell ? I din't know that repeat is a haskell solution and i can't find anything on internet
13:04:10 <ion> What do you mean by repeating a function?
13:04:16 <rostayob> so Awoley or Pierce? the library has both!
13:04:30 <DrSyzygy> rostayob: Awodey. Pierce won't do a decent job of teachign you category theory.
13:04:39 <byorgey> Aune: correct.
13:05:02 <DrSyzygy> trying to remember if Pierce is the book that just coddles you, or the book with the sudden jump from mindnumbing coddling to breathtakingly advanced type theory.
13:05:06 <hiptobecubic> DrSyzygy, was my last statement correct?
13:05:11 <hiptobecubic> "So a natural transformation is a morphism in the category of functors-with-identical-types?"
13:05:14 <byorgey> Aune: oh, hmm, I guess you're right about Void
13:05:20 <DrSyzygy> hiptobecubic: Yup.
13:05:38 <DrSyzygy> Also, a natural transformation between endofunctors of Hask is a polymorphic function.
13:05:46 <byorgey> Aune: an imaginary Haskell-without-bottom might be expected to have a primitive  Void -> a
13:05:49 <rostayob> DrSyzygy: I have some background in type theory (I'm almost done with understanding "type theory for functional programmers") and I'd like a book that relates the two
13:05:49 <byorgey> Aune: but it doesn't
13:06:05 <DrSyzygy> rostayob: Then pierce might be worth looking at.
13:06:54 <cemycc> byorgey: I have found something about iterate, but iterate can be used only with function with one argument from what i have understand
13:07:09 <byorgey> cemycc: yes, and your function only has one argument
13:07:19 <byorgey> cemycc: a pair (x,y) is a single value
13:07:19 <rostayob> DrSyzygy: ah no actually the library doesn't have Awodey. so Pierce it is.
13:07:47 <ChristianS> > maximumBy (comparing length) [[1,2,3], [1..]]
13:07:52 <lambdabot>   mueval: ExitFailure 1
13:07:52 <lambdabot>  mueval: Prelude.undefined
13:08:11 <DrSyzygy> > maximumBy (comparing length) [[1,2,3],[1,2,3,4]]
13:08:12 <lambdabot>   [1,2,3,4]
13:08:22 <DrSyzygy> ChristianS: length [1..] won't work.
13:08:25 <brisingr> What is really "it" in GHCi? I know you can use it reference to the last result, but what is it?
13:08:29 <brisingr> > 1 + 2
13:08:30 <lambdabot>   3
13:08:32 <brisingr> > it + 4
13:08:33 <lambdabot>   Not in scope: `it'
13:08:35 <ChristianS> DrSyzygy: yes, that's my point
13:08:44 <brisingr> ah, damn, lambdabot doesn't have it
13:08:52 <byorgey> maximumBy (comparing genericLength)  could work if you use lazy peano naturals =)
13:09:13 <ChristianS> timthelion: maximumBy (comparing length) has the disadvantage that is will evaluate the length of both lists, while for your purpose it would be enough to check the number of elements that both lists have in common
13:09:26 <byorgey> ChristianS: good point.
13:09:52 <ChristianS> might be better to define a  isShorter a b  function and use that
13:11:56 <DanBurton> what's a good package that provides something like `downloadWebpage :: String -> IO String'?
13:12:13 <alpounet> @hoogle simpleHTTP
13:12:14 <lambdabot> Network.HTTP.Stream simpleHTTP :: Request_String -> IO (Result Response_String)
13:12:14 <lambdabot> Network.HTTP simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
13:12:14 <lambdabot> Network.HTTP.HandleStream simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
13:12:21 <shergill> DrSyzygy: your lecture notes present a nice overview (i just made my way through the first lecture). thanks for putting them up!
13:12:22 <hiptobecubic> DrSyzygy, is this analogy correct?  Hask : Cat :: Function : Functor?
13:12:27 <alpounet> oh wait no
13:12:34 <DrSyzygy> hiptobecubic: Sure.
13:12:34 <alpounet> DanBurton, download or download-curl i guess
13:12:36 <DrSyzygy> shergill: Thank you.
13:13:20 <DanBurton> alpounet: that looks like it would work, actually
13:13:27 <KorriX> hello
13:13:44 <alpounet> DanBurton, well simpleHTTP is a layer down on the abstraction scale
13:13:57 <KorriX> is there any Boomerang combinator for trailing slash matching ?
13:13:57 <alpounet> with download(-curl) you really just have the function signature you described
13:16:01 <copumpkin> ddarius: where should we meet?
13:20:41 <KorriX> ... </> eos does not work
13:21:37 <ion> drsyzygy: Thanks for your time, i’ll be sure to read your lecture notes.
13:23:08 <hiptobecubic> DrSyzygy, ok i'm off for tonight. Thanks so much for this talk. Category theory is a lot more interesting than I had imagined
13:23:24 <hiptobecubic> "3 is a morphism" really woke me up.
13:23:31 <DrSyzygy> ion, hiptobecubic: thanks for your interest and attention.
13:23:48 <hpaste> DanBurton pasted “"download" package problems” at http://hpaste.org/64748
13:24:13 <Aune> Mathematical functors have the law: F(g∘f) = F(g) ∘ F(f), how does this translate into haskell? This more reminds me more of applicative than functor. pure(f∘g) = pure(f) <*> pure(g)...
13:25:03 <hiptobecubic> DrSyzygy, categories require morphisms with composability and an identity?
13:25:18 <DrSyzygy> hiptobecubic: yup.
13:25:21 <hiptobecubic> ok
13:25:33 <hiptobecubic> I'm trying to go back and summarize this a bit on paper
13:25:48 <ion> aune: fmap (g . f) = fmap g . fmap f
13:26:18 <Aune> ion, huh. so easy Im almost ashamed
13:26:20 <cmccann> Aune, also, pure f <*> x = fmap f x
13:26:47 <cmccann> so the Applicative part is more about saying that pure behaves appropriately with respect to the functor law
13:27:28 <Hasn> Has anyone here been paid to write a program in Haskell?  Just curious.
13:27:30 <cmccann> also, you're probably thinking of something like (.) <$> pure f <*> pure g
13:28:04 <timthelion> Is there a way to tell ghc to tell me which function deffinitions are incomplete?  AKA, if I have data Foo=Bar|Goop function doink Bar = "hi" would throw an error since it doesn't have a case for goop.
13:28:14 <Aune> Ooooh. I've been thinking about the typeconstructor as the F in that case...
13:28:17 <hiptobecubic> DrSyzygy, all functors are morphisms, all morphisms appear to be functors though as well. is that right?
13:28:47 <hiptobecubic> Does not sound right
13:28:48 <alpounet> DanBurton, that's odd. tried with another ghc ?
13:29:03 <Aune> Need to unwind my brain a bit it seems.
13:29:25 <hiptobecubic> Hasn, google "haskell in industry". I think it's on the wiki also.
13:30:01 <cmccann> Aune, the F is both the type constructor and fmap
13:30:21 <Saizan> timthelion: there's a warning for that
13:30:22 <timthelion> Hasn: If you want to read about being paid to write haskell BEAUTIFUL CODE,
13:30:23 <timthelion> COMPELLING EVIDENCE
13:30:43 <timthelion> is a good place to start. by J.R.Heard  It is free online
13:31:04 <timthelion> Saizan: I don't seem to be recieving it.
13:31:26 <cmccann> timthelion, you need to enable it with a flag
13:31:34 <cemycc> byorgey: thanks for your help, finally I have found the solution: gfia n = fst (iterate fibAcc(0,1) !! n) :)
13:31:36 <Aune> cmccann, and that only confuses me more.
13:31:38 <Hasn> hiptobecubic: thanks
13:32:57 <cmccann> Aune, how so? in both cases F is mapping something from one category to another. it's just that in Haskell we don't have a uniform way to do that on both
13:33:23 <timthelion> cmccann: I need to use ghc -Wall?
13:33:49 <cmccann> timthelion, I think it's -fwarn-incomplete-patterns or something
13:34:06 <cmccann> but I think you'll get it with -Wall too
13:34:07 <timthelion> cmccann: thanks
13:34:46 <cmccann> Aune, it might help to re-parenthesize fmap's type as "(Functor f) => (a -> b) -> (f a -> f b)"
13:34:49 <Aune> cmccann, and unwinding completed. It is so obvious now. fmap :: (a -> b) -> (f a -> f b).
13:34:55 <cmccann> heh
13:35:00 <hiptobecubic> Night everyone
13:35:00 <Aune> nice
13:35:34 <Aune> So fmap is for the morphisms and the type-constructor for the objects ^^
13:36:00 <cmccann> Aune, compare that to "($) :: (a -> b) -> (a -> b)", "(=<<) :: (Monad m) => (a -> m b) -> (m a -> m b)", and "(<*>) :: (Applicative f) => f (a -> b) -> (f a -> f b)"
13:36:53 <cmccann> oh, and "arr :: Arrow (~>) => (a -> b) -> (a ~> b)" while we're at it
13:39:00 <Aune> cmccann, wow, thanks
13:39:10 <Aune> it's starting to unify nicely
13:40:19 <ben> in ghc 7.4 do you still need to tell it at runtime that you have multiple cores?
13:41:22 <parcs`> yeah i think so
13:41:51 <parcs`> ebut you don't have to compile ghc with -rtsopts to get the -N rts flag anymore
13:41:58 <ben> right, cool
13:41:59 <ben> thanks
13:42:55 <tommd> ben: note the -with-rtsopts option.
13:43:06 <tommd> ghc -with-rtsopts=-N someFile.hs
13:43:24 <ben> that's better :)
13:44:50 <parcs`> no
13:44:59 <cmccann> Aune, you'd probably be better off asking DrSyzygy if you want a rigorous explanation of exactly how those relate though, heh
13:45:02 <parcs`> i mean if you compile with -threaded you get to use -N
13:45:11 <tommd> right.
13:48:43 <ben> Does Control.Exception.try catch async exceptions?
13:49:04 <tommd> Yes
13:49:16 <Aune> So, excluding bottom. Is Hask cartesianly closed?  () is a terminal object, any two objects a and b have the product (a,b). But what about the third requrement; that any two objects have an exponential?
13:49:56 <ben> Does that include the killThread exception? I'm conusing myself here
13:49:58 <Aune> If I understand this correctly the exponential objects should be the morphisms a -> b.
13:49:58 <shergill> hah. so going over some old python scripts i'd written for a project (a couple of years old) i come across the following note: "TODO: need a way to chain together functions. perhaps using decorators?". what i needed was haskell
13:50:05 <cmccann> Aune, the exponential object for objects A and B is the object (A -> B)
13:50:16 <mzero> shergill: LOL!
13:51:48 <cmccann> Aune, note that Haskell is cartesian closed in a sufficiently aggressive way that it's hard to even distinguish between morphisms (A -> B) and the exponential object (A -> B)
13:55:20 <cmccann> Aune, the morphisms (A -> B) are functions from A to B, while the exponential object (A -> B) is a type inhabited by values corresponding to those morphisms
13:55:45 <ion> I managed to make a toy category for the list monoid but i have trouble figuring out how to make this work for any monoid: https://gist.github.com/1974979
13:55:54 <ion> λ> Foo "o " . id . Foo "hai"
13:55:55 <ion> Foo "o hai"
13:56:12 <cmccann> Aune, if those seem like they're the same thing, that just means you've forgotten what it's like to not have first-class functions in your programming languages ;]
13:57:00 <Aune> cmccann, They totaly seem like the same thing... I really cant see the difference.
13:57:00 <Saizan> ion: data Foo m a b where Foo :: m -> Foo a a
13:57:28 <Saizan> ion: instance Monoid m => Category (Foo m) where ..
13:57:37 <ion> I tried something like that without success. Let me try again.
13:58:44 <ion> λ> Foo (Sum 42) . id . Foo (Sum 1)
13:58:46 <ion> Foo (Sum {getSum = 43})
13:58:58 <ion> Thanks. I must have made some silly mistake, i don’t remember what was different in what i tried.
13:59:08 <Aune> cmccann, Is it different in the same way that the cartesian product of sets A B is different from the set of functions A -> B but they are isomorphic
13:59:21 <ion> Updated the gist.
13:59:32 <Aune> cmccann, wait, no let me refrase
14:01:07 <cmccann> Aune, imagine a programming language without higher-order functions. how could they be the same thing when there's no such thing as a type (A -> B)?
14:01:39 <ion> @tell hiptobecubic Here’s a toy Category instance for Monoids. :-P https://gist.github.com/1974979
14:01:39 <lambdabot> Consider it noted.
14:02:18 <cemycc> In haskell to use recursive functions is a good solution comparing to other languages like c/c++ ?
14:02:36 <monochrom> yes
14:02:52 <strager> To use folds and map is a good solution.  =]
14:02:56 <ion> They would be a good solution in C and C++, too, if most of the compilers didn’t have trouble with recursion.
14:03:12 <strager> ion: What makes you say they have trouble with recursion?
14:03:15 <cmccann> using recursive functions is a good solution in any language, with the caveat that poorly-written compilers may not optimize tail-calls correctly
14:03:28 <ion> strager: What cmccann said.
14:03:47 <cmccann> that's not a feature of the language, though
14:04:08 <strager> I wouldn't say "not extremely optimizing" is "having trouble".
14:04:29 <Aune> cmccann, If every function A -> B can be identified with a subset of A*B. so a function 'not' (Bool -> Bool) can for example be identified with the subset ((True,False)(False,True))
14:04:52 <shergill> cmccann: it can be? i believe r5rs specifies tail calls be optimized?
14:04:56 <Aune> of Bool*Bool
14:05:05 <shergill> or did you mean not a feature of haskell?
14:05:29 <cmccann> shergill, ok, it's not a feature of any language that doesn't specify, which most don't :P
14:05:44 <shergill> heh fair enough
14:06:40 <cemycc> :)
14:07:15 <Aune> cmccann, I see how they are not the same thing but they are just sooo nicely isomorphic it pains me not to think of them as identical
14:07:48 <cmccann> Aune, right, but again that's only true in a category--or programming language--that lets you do that
14:07:54 <copumpkin> Aune: how are they isomorphic?
14:08:45 <copumpkin> Aune: every element in A -> B can be thought of as a subset of A x B,  but there exist many subsets of A x B that are not elements of A -> B
14:09:16 <Aune> Oh, thats true
14:09:41 <copumpkin> or that do not correspond to elements of A -> B, I should say
14:09:56 <copumpkin> furthermore, the subsetness complicates things
14:10:40 <copumpkin> you might say that (A -> B) -> ((A x B) -> 2)
14:10:45 <Aune> I was thinking a bit to restricted. I was thinking of the subsets of A*B containing exactly one pair (a , b) for each a in A.
14:10:46 <copumpkin> but that's not constructive
14:12:53 <copumpkin> does that mean (A -> B) can be transformed to ((A x B) -> 2) can be transformed to ((A x B x 2) -> 2) etc. ?
14:17:33 <Aune> copumpkin, Ok, that got me a bit confused. What exactly do you mean by transform here. do you mean "is there an isomorphism from (A -> B) to ((A x B) -> 2)" or do you mean something else?
14:17:55 <copumpkin> an injection
14:18:11 <copumpkin> which I guess is fine
14:18:17 <sausage2> Hi. Wtf is wrong with my code? that's because it runs a former test I made (Copy paste)
14:18:19 <copumpkin> since the sets are getting bigger and bigger
14:18:26 <copumpkin> so it's kind of trivial
14:18:32 <sausage2> wait, link
14:18:34 <sausage2> pastebin.com/HvYXHqL3
14:18:44 <sausage2> http://pastebin.com/HvYXHqL3 there
14:18:46 <mauke> The paste HvYXHqL3 has been copied to http://hpaste.org/64749
14:18:59 <sausage2> http://hpaste.org/64749 <-- correction
14:19:00 * marienz raises an eyebrow
14:19:10 <sausage2> oh, you're everywhere =o
14:19:17 <copumpkin> sausage2: this is #haskell
14:19:20 <copumpkin> that code is not :)
14:19:23 <sausage2> marienz: I'm boored. So this is the result
14:19:43 <marienz> sausage2: if I remove that quiet now-ish, will you be a friendly kind of bored over in #defocus?
14:20:19 <sausage2> I'll just log out, and come back another time... it's all rather embarrasing to for me
14:20:22 <copumpkin> marienz is an octopus
14:20:27 <copumpkin> sausage2: either way, this is not the place for that question :)
14:20:36 <marienz> sausage2: or that, your choic
14:20:38 <marienz> choice, too
14:20:53 <sausage2> -.-
14:21:22 <Aune> copumpkin, Am I wrong? Im kind of confused by this?
14:21:46 <copumpkin> Aune: you're glossing over the subset aspect of it
14:21:49 <DanBurton> saurik: the problem is that it isnot Haskell
14:21:56 <DanBurton> *sausage2 &
14:21:58 <copumpkin> lol
14:21:59 <DanBurton> ^
14:22:00 <copumpkin> ohai saurik
14:22:21 <copumpkin> Aune: set sizes don't really work out if you gloss over the subset aspect
14:22:25 <marienz> (he'd been similar or worse in other channels, if you hadn't guessed)
14:22:44 <shergill> what just happened here
14:22:57 <copumpkin> just marienz being omnivident
14:23:23 <Aune> copumpkin, I will have to get back to that. Seems like Im sidetracking a bit to much
14:23:38 <marienz> hmm, an omnivident octopus
14:24:15 <copumpkin> Aune: I just mean that cardinalities get kind of messed up :) for example, the type of subsets of A is A -> 2, which, being the powerset, has a strictly larger cardinality
14:24:30 <copumpkin> Aune: if you think of it as A x 2, that has the same (infinite) cardinality as A
14:24:54 <copumpkin> however, the secret is that your "some subset of the cartesian product" is actually throwing a powerset back in
14:25:12 <cmccann> omnivident is a good word.
14:25:45 <Aune> copumpkin, Aaah, okay.
14:27:14 <cmccann> copumpkin, for context that whole line of discussion came from Aune finding it strange to talk about function-ish morphisms without having exponential objects as well, give or take
14:27:34 <copumpkin> ah
14:27:53 <Aune> And Im still confused about that ^^
14:33:59 <cmccann> Aune, you could always spend some time looking at code based on Arrow and learn the hard way what it's like to not have exponentials, heh
14:34:42 <Aune> cmccann, I was just about to ask you for an example actually.
14:35:15 <Aune> And that mioght be a nice one.
14:36:04 <Aune> Might take this as a good point to learn about arrows as well
14:37:16 <cmccann> Aune, right, given an arbitrary Arrow instance (~>) you don't have equivalents of functions that presume higher-order functions
14:37:54 <cmccann> e.g. "($) :: (a, a ~> b) ~> b"
14:38:15 <cmccann> or "curry :: ((a, b) ~> c) ~> (a ~> (b ~> c))"
14:39:00 <Aune> can you give an example of a specific arrow instance where this is true?
14:39:33 <cmccann> note that all of those involve an arrow whose domain or codomain mentions the arrow type itself
14:40:38 <cmccann> Aune, not at the moment, I think the only instances in Control.Arrow itself are (->) and Kleisli
14:40:47 <cmccann> both of which also have ArrowApply instances
14:41:34 <Aune> ok. Im reading up on arrows in the mean time.
14:44:18 <cmccann> Aune, actually, I don't think the automaton arrow allows ArrowApply
14:44:20 <cmccann> so that's one example
14:44:52 <Aune> with automaton, do you mean a finite automata?
14:45:32 <cmccann> I mean something like "newtype Automaton a b = Automaton (a -> (b, Automaton a b))"
14:45:58 <cmccann> basically a mealy machine if memory serves me
14:46:19 <cmccann> and related to arrow FRP and iteratees for what that's worth
14:47:25 <Aune> Nice, well, I do love finite state machines.
14:49:51 <cmccann> Aune, so think about an automaton that takes (A, B) as input and produces C as output. currying would let you turn that into an automaton that takes A as input and produces as output a stream of automatons from B to C
14:49:58 <timthelion> If I have data V = X Point String | None ; f (X (x,y) s) = something, is there a way for me to get the whole V from within f?  Like as if I had written the functin f v = something, or do I have to reconstruct the V using (X (x,y) s)?
14:50:08 <cmccann> Aune, you can probably see how that's not going to work very well
14:50:49 <Aune> well, yeah. cant know the future output without the future input
14:51:44 <Aune> Aaah, that is obvious.
14:51:55 <cmccann> it might work if you did the same sort of diagonalization that a Monad instance for infinite streams requires
14:51:58 <cmccann> but that's horrible anyway
14:54:02 <magicman> @type app
14:54:09 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
15:06:07 <quintessence> timthelion: there are @-patterns that bind a name and match a pattern: duplicateHead xs@(x:_) = x : xs
15:11:00 <shergill> hmm so i'm looking for some examples, where it makes sense to use monads, and others where arrows make more sense. i started reading hughes' programming with arrows, and conceptually they make sense. i just am not clear as to a practical advantage they offer over monads. i got a few pages into the paper, but the opening example didn't offer much in terms of motivation =/
15:12:43 <merijn> shergill: Did you read the Hughes paper "Generalising Monads to Arrows"?
15:13:05 <shergill> merijn: hmm no. did that precede the programming with arrows one?
15:13:45 <merijn> No clue, I just remember finding that quite readable and illustrative
15:13:50 <merijn> ymmv
15:14:27 <shergill> merijn: looking at it now, thanks for the reference
15:15:40 <merijn> shergill: np
15:16:01 * cmccann still thinks that Arrow and Monad are conceptually very different and comparing them in the sense of "which one to use" is ill-defined
15:17:48 <timthelion> cmccann: everything, which is not equal, is different.
15:18:11 <shergill> cmccann: perhaps a better way to phrase my question might be, when to use which?
15:18:49 <shergill> so i'm not looking for a comparison so much as examples which highlight the strong points of each
15:21:42 <cmccann> shergill, well, composable pipelines with a static structure is the usual idea with Arrow
15:22:37 <shergill> what is 'structure' here? pairs of the type of input/output for each unit in the pipeline?
15:22:42 <shergill> cmccann: ^
15:23:39 <cmccann> shergill, well, it's roughly the same sense in which Applicative requires a static structure, but that might not clear anything up
15:23:58 <shergill> cmccann: it doesn't =/
15:25:49 <cmccann> shergill, to give a very hand-wavy description, all the combinators to build an Arrow or Applicative are fixed; the computation they describe is static, only the values inside it change
15:27:22 <shergill> cmccann: hmm could you give a concrete example?
15:27:26 <cmccann> whereas with Monad you can inspect values at run time, build new computations with (>>=) based on those values, and then run that
15:27:44 <shergill> ah
15:27:51 <shergill> ok that makes more sense now
15:28:21 <cmccann> (note that ArrowApply gives you that ability as well)
15:28:34 <ion> (<*>) :: f (a -> b) -> (f a -> f b): the “a -> b” doesn’t get to decide to e.g. short-circuit the computation in the case of Maybe, or whether to print “hello” or launch the missiles based on a in the case of IO.
15:28:50 <ion> (=<<) :: (a -> f b) -> (f a -> f b): the “a -> f b” has both abilities.
15:29:11 <shergill> hmm in a Monad pipeline (using >=> say) the computation stages depend on the ones preceding it. while that's not so in arrows?
15:29:15 <cmccann> a simple illustration with Applicative vs. Monad is that, in the list monad, (<*>) can't filter values, but (>>=) can
15:30:04 <cmccann> shergill, the pipeline is fixed in that case
15:30:38 <shergill> right, ok
15:30:59 <cmccann> e.g., think about how you'd splice in a new (>=>) if you're building your computation using only (>=>)
15:34:03 <cmccann> shergill, anyway, having a static structure for the computation was a motivation for both Applicative and Arrow, because it enables better compile-time analysis and optimization
15:34:39 <shergill> cmccann: and in cases where the computation has a static structure you don't need the flexibility awarded by monads?
15:34:41 <rekahsoft> hi all..beeing trying to install network globally using cabal but i get error 127..i attempted to search what error 127 was but came up unsuccessful..anyways network installs locally so i don't know whats up..file conflicts maybe? since it wraps a c library does it try to install that too?
15:35:29 <ivanm> rekahsoft: no, it needs some C libraries already installed
15:35:37 <ivanm> maybe post up the entire build log?
15:35:38 <ivanm> @hpaste
15:35:39 <lambdabot> Haskell pastebin: http://hpaste.org/
15:36:04 <cmccann> shergill, it's more that if what you're doing permits such a static structure, you might benefit from doing it that way
15:37:06 <shergill> cmccann: sure. and the comment you made about ArrowApply. so does that mean once you're using ArrowApply you have monads? or do you have something more expressive than monads? or something which is different altogether?
15:38:14 <cmccann> shergill, for any instance of ArrowApply (~>), ((~>) ()) is a Monad
15:39:13 <cmccann> there's a newtype wrapper in Control.Arrow that does precisely that
15:39:22 <akosch> why aren't the types of exceptions a function can throw listed in the type of the function? some languages have this (throwing) and I'm surprised haskell doesn't
15:39:34 <shergill> cmccann: ah
15:39:58 <akosch> at least optionally
15:40:07 <cmccann> shergill, so you get the static structure from Arrow or Applicative, and dynamic structure from ArrowApply or Monad
15:40:08 <rwbarton> it has optionally, use Either
15:41:11 <shergill> cmccann: right. and now i'm wondering about when the distinguishing characteristics of Arrow vs Applicative
15:41:34 <timthelion> > (1,1)==(2,2)
15:41:36 <lambdabot>   False
15:41:58 <cmccann> shergill, what are the distinguishing characteristics of (.) vs. ($)?
15:44:28 <shergill> cmccann: well (.) takes two functions and returns a function and ($) takes a function and a value and returns a value
15:46:10 <cmccann> shergill, right. now compare that to the operations defined for Arrow/Category and Applicative/Functor
15:49:40 <adimit> so, I have k :: m a, and l :: a -> m b. I also have as :: [a]. I want to feed each a to k, then pass it to l, and *while* l is doing its thing, pass the next a already to k. Since l is going to take longer than k, k then has to wait until it can take another a.
15:50:12 <adimit> Essentially, I have two actions whose input depends on each other, but which can process their input chunk-wise and independently in two different threads.
15:50:24 <adimit> This sounds like so common a pattern that there should be some abstraction for it, no?
15:51:31 * cmccann isn't sure how you feed an a to something of type (m a)
15:52:01 <adimit> cmccann: sorry, it should have been k :: a -> m b, and l :: b -> m c
15:52:33 <adimit> I know how I would do it with mvars, but I just thought that There Should be a Library for IT.
15:52:35 <adimit> *it.
15:52:47 <adrake> why not do something like a parallel map of (k >=> l) over the list?
15:52:50 <shergill> cmccann: wow. thanks
15:52:56 <adrake> instead of this pipeline-y thing?
15:53:47 <shergill> cmccann: specifically the connection of (.) with first. it makes sense now
15:54:03 <rekahsoft> ivanm: sorry for the slow responce..headed off for dinner..anyways why does it install locally then and not globally?
15:54:18 <adimit> adrake: yeah, that's a good idea, however, I fail at the "parallel map" part. Could you be more specific as to what that means exactly?
15:54:33 <ivanm> rekahsoft: I don't know if I don't see the build log! ;-)
15:54:48 <cmccann> shergill, everything in Arrow is about fancier ways of composing function-like things, which is why you see stuff like (&&&) and first used a lot in pointfree code
15:55:27 <rekahsoft> ivanm: sorry my friend..not fluent with cabal..looking for it right now
15:55:29 <cmccann> whereas Applicative is about doing function application inside certain Functors
15:55:53 <ivanm> rekahsoft: you don't have the output anymore from when you tried building it?
15:56:07 <ivanm> cabal install network -v3 <-- with full build log
15:57:01 <shergill> cmccann: gotcha
15:57:37 <rekahsoft> ivanm: i installed it locally so i did "ghc unregister network" and the retried "cabal install --root-cmd root --global network"
15:57:40 <cmccann> shergill, and note that any Arrow behaves a lot like the Applicative instance for (->)
15:57:45 <cmccann> :t (.)
15:57:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:57:56 <cmccann> as Caleskell helpfully shows us :P
15:58:00 <ivanm> rekahsoft: any particular reason for installing it globally?
15:58:13 <shergill> heh
15:58:28 <rekahsoft> the second time it worked
15:58:52 <cmccann> since fmap for (->) = function composition
15:58:59 <rekahsoft> ivanm: so that all users can use the library..
15:59:09 <cmccann> whereas with Arrow you can lift a function with arr, then compose with (<<<)
15:59:09 <rekahsoft> ivanm: why is there a better way?
15:59:22 <ivanm> rekahsoft: which OS?
15:59:48 <rekahsoft> ivanm: parabola (libre archlinux_
15:59:55 <rekahsoft> )*
15:59:57 <rekahsoft> ivanm: brb afk
16:00:06 <ivanm> rekahsoft: doesn't arch have haskell packages you can use?
16:01:00 <adrake> adimit: so, I haven't done a whole lot of parallel code in haskell, but http://zwell.net/content/haskell.html looks like it is probably what you want for that?
16:01:16 <adrake> using control.parallel
16:01:36 <shergill> cmccann: right. another thing, i've seen people use (~>) when describing arrows. running :info Arrow in ghci however returns the uglier prefix representation (with 'a' replacing (~>)). is ~> a newer convention?
16:01:59 <cmccann> shergill, it's just a type variable :]
16:02:10 <cmccann> I think you need to enable the TypeOperators extension
16:02:55 <cmccann> just like constructors beginning with : are "uppercase", operators not beginning with : are "lowercase"
16:04:37 <shergill> constructors beginning with ':'? o.O
16:04:38 <adimit> adrake: yeah, thanks. I actually had that open :-)  need a way to restrict the number of concurrent maps though, because my data structures would get too big to fit into memory. I can keep at most 2 of them.
16:06:41 <shergill> ah. i wasn't aware of that
16:06:48 * shergill is going over haskell lexemes now
16:06:54 <cmccann> shergill, er, I meant "operators" there, but yes
16:06:55 <adimit> seems I'll have to write my own map function based on par. but that zwell.net post seems to cover that.
16:07:21 <shergill> right, i figured
16:07:23 <cmccann> operators beginning with : are "uppercase" and can be used where capitalized alphanumeric identifiers would be required
16:07:34 <cmccann> though you need TypeOperators to allow that in general
16:07:47 <cmccann> for things like type constructors and type classes
16:11:09 <maloi> sup { _|_ ⊑ ... ⊑ _|_ ⊑ n ⊑ ... ⊑ n } = n how comes sup { _|_ = f0(n) ⊑ f1(n) ⊑ f2(n) ⊑ ... } = f(n)
16:12:26 <maloi> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Convergence
16:18:14 <Eduard_Munteanu> maloi: what exactly is your question?
16:18:55 <Eduard_Munteanu> Mind  sup A  needn't be in A, if that's what you're asking.
16:19:04 <maloi> oh sorry, i don't the the step from n tpo f1(n), f2(n) etc
16:23:30 <maloi> what if f is infinite?
16:23:35 <Eduard_Munteanu> maloi: mm, I think they've not shown that yet: "Of course, it remains to be shown that f(n) actually yields a defined value for every n, but this is not hard and far more reasonable than a completely ill-formed definition."
16:24:47 <maloi> ok i go and read ahead, thank you
16:26:22 <Eduard_Munteanu> The sequence of fs? Presumably then it doesn't necessarily have a (trivial) least upper bound.
16:26:49 <maloi> hmm yeah
16:38:48 <jay7557> Hi all!
16:39:02 <jay7557> anybody free to check my code ?
16:43:14 <gentleben> sure
16:45:02 <Eduard_Munteanu> Sure he left.
16:46:28 * hackagebot boomerang 1.3.0 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.3.0 (JeremyShaw)
16:52:38 <duairc> Is it possible to write a type family to extract a functional dependency? I'm trying to do something like this: http://hpaste.org/64761
16:57:55 <lpsmith> You know what would be interesting?   A program that would analyse a library and uses of a library and suggest how to split the definitions into modules
16:58:49 <irene-knapp> indeed!
17:01:29 * hackagebot yjsvg 0.1.13 - make SVG string from Haskell data  http://hackage.haskell.org/package/yjsvg-0.1.13 (YoshikuniJujo)
17:01:38 <rekahsoft> ivanm: sorry i'm back..and yes it does for some of the packages in hackage but not all
17:02:06 <ivanm> what does for some?
17:02:24 <rekahsoft> a nice solution would be to have a little app that turns a cabal package into a arch package
17:02:56 <rekahsoft> actually i think something like that did exist a while back but its unsupported? i'm not sure on that..just refering to my search engine now :P
17:03:41 <ivanm> there already is such a thing
17:03:45 <ivanm> cabal2arch
17:03:50 <ivanm> and arch has quite a lot of Haskell packages
17:03:57 <ivanm> almost definitely including network
17:04:23 <c_wraith> there's been a lot of recent work on making network work properly on 7.4, it looks like
17:05:21 <Boney> @src groupBy
17:05:21 <lambdabot> groupBy _  []       =  []
17:05:21 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
17:05:21 <lambdabot>     where (ys,zs) = span (eq x) xs
17:05:35 <ivanm> rekahsoft: oh, this is for ghc-7.4?
17:05:45 <ivanm> if so, you might need to get the version on github
17:06:16 <Boney> @src span
17:06:17 <lambdabot> span _ xs@[]                     =  (xs, xs)
17:06:17 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
17:06:17 <lambdabot>                   | otherwise    =  ([],xs)
17:08:01 <rekahsoft> ivanm: yes it is..but they just updated the packages so i am now using the arch packages when possible cabal global install otherwise
17:09:05 <rekahsoft> ivanm: and when i say they updated the packages i mean the yupdated ghc and some others (xmonad, xmonad-contrib, parsec, network, ...)
17:11:57 <hpaste> “Doug Ransom” pasted “File name does not match module name:” at http://hpaste.org/64762
17:12:17 <dougransom> Any thoughts on why I get the error/how to fix?
17:13:37 <maloi> The name of the file must be that of the module but with a .hs file extension.
17:14:40 <dougransom> They show a different module for a test suite for the main in the cabal file in the example http://www.haskell.org/cabal/release/cabal-1.10.2.0/doc/users-guide/#test-suites
17:14:49 <Elemir> @hackage hdaemonize
17:14:49 <lambdabot> http://hackage.haskell.org/package/hdaemonize
17:15:03 <Elemir> I love this programming language!
17:16:29 * hackagebot xturtle 0.0.17 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.0.17 (YoshikuniJujo)
17:17:31 * Elemir strokes hackagebot 
17:21:22 <dougransom> what is the main-is for in cabal files if I can't specify a module named something other than main.hs?
17:23:33 <applicative> you can specify files other than Main.hs
17:26:25 <Elemir> What is true way for adding functional tests in cabal?
17:32:05 <alpounet> Elemir, http://www.haskell.org/cabal/users-guide/#test-suites ?
17:32:10 <tromp__> > 0^0
17:32:11 <lambdabot>   1
17:34:48 <Elemir> Nice
17:34:54 <Elemir> 10x
17:40:37 <tomku> 1/quit
17:44:55 <tsanhwa> @info Word8
17:44:55 <lambdabot> Word8
17:45:01 <tsanhwa> @hoogle Word8
17:45:01 <lambdabot> Data.Word data Word8
17:45:02 <lambdabot> GHC.IO.Buffer readWord8Buf :: RawBuffer Word8 -> Int -> IO Word8
17:45:02 <lambdabot> GHC.IO.Buffer writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
17:46:31 * hackagebot yjtools 0.9.14 - some tools for Monad, List, Tuple and so on.  http://hackage.haskell.org/package/yjtools-0.9.14 (YoshikuniJujo)
18:04:33 <applicative> > [maxBound, minBound] :: [Word8]
18:04:34 <lambdabot>   [255,0]
18:09:21 <aristid> > [maxBound .. minBound] :: [Double]
18:09:22 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
18:09:22 <lambdabot>    arising from a use o...
18:09:30 <aristid> > [maxBound .. minBound] :: [Int]
18:09:31 <lambdabot>   []
18:11:48 <ion> Positive, finite “minBound” and “maxBound” for floats: https://gist.github.com/1188115
18:24:15 <covi> Hi guys. I have a two-line-long snippet that outputs a huge number to the ghci terminal. How do I redirect the output to a file or print to a file?
18:27:13 <td123> probably show the number and pass it to writeFile?
18:29:43 <aristid> ion: heh
18:31:04 <td123> covi: writeFile "bignumber" $ show $ product [1..1000]
18:36:33 * hackagebot parse-help 0.0 - generate command line arguments from a --help output  http://hackage.haskell.org/package/parse-help-0.0 (GregWeber)
18:41:27 <hpaste> totimkopf pasted “IO Example” at http://hpaste.org/64764
18:41:41 <totimkopf> hi guys, I'm having trouble running that code
18:42:01 <totimkopf> output.hs:6:14:
18:42:01 <totimkopf>     The last statement in a 'do' construct must be an expression:
18:42:01 <totimkopf>     inh <- openFile "input.txt" ReadMode
18:42:27 <totimkopf> I'm getting that code from the Real World Haskell book
18:42:30 <totimkopf> :D
18:42:50 <totimkopf> but I don't see what I'm doing wrong!
18:42:53 <totimkopf> :)
18:43:30 <luxurymode> When you pattern match, say a list like (x:xs) does the "rest" of the list part (i.e. xs) have to xs or is that just convention? could it just as well be (x:yw)?
18:43:48 <dmwit> Yes, it's just a convention.
18:43:50 <adit> totimkopf: maybe bad intentation?
18:43:56 <hpaste> applicative annotated “IO Example” with “IO Example (annotation)” at http://hpaste.org/64764#a64765
18:44:00 <luxurymode> oh ok thanks dmwit
18:44:09 <dmwit> > let foo:blargle = [1,2,3] in (foo, blargle)
18:44:09 <totimkopf> oh
18:44:10 <lambdabot>   (1,[2,3])
18:44:18 <luxurymode> whats the logic of the convention? just curious...
18:44:24 <dmwit> xs is the plural of x =)
18:44:30 <luxurymode> oh haha right
18:44:33 <luxurymode> like exes
18:44:37 <dmwit> right
18:44:46 <luxurymode> thanks a lot
18:44:50 <luxurymode> haskell is beastly
18:44:54 <luxurymode> blowing my mind
18:44:57 <BMeph> luxurymode: What dmwit said; one "x", many "x"s... or "xs"
18:44:59 <applicative> totimkopf: after you write 'do' or other key word, the next letter you write is sacred, it starts a new left margin so to say
18:45:00 <luxurymode> no state, pure function
18:45:03 <luxurymode> beautiful
18:45:56 <BMeph> luxurymode: There's lenty of state, you just don't get to modify it as you please.
18:46:06 <dmwit> The next non-comment character is sacred, letter or otherwise.
18:46:12 <BMeph> Er, There's *plenty of state, I mean
18:46:18 <dmwit> It starts a new left margin provided it isn't a {
18:46:48 <luxurymode> BMeph, right gotcha
18:47:34 <totimkopf> applicative, ok, but I still don't see where my mistake is :S
18:47:46 <totimkopf> my indentation looks identical to that of the book
18:47:56 <dmwit> totimkopf: "inh" is indented more than "outh".
18:48:28 <nand`> luxurymode: state and function aren't mutually exclusive
18:48:30 <dmwit> Also, unless you set your editor to use tabstops every eight columns, do not go by looks.
18:48:40 <applicative> hm are tabs coming in?  all the statements in a do block should line up, but line 6 doesn't line up with 7 8 9
18:48:45 <dmwit> If you write code that depends on the size of tabstops to be correct, you will be summarily executed.
18:48:52 <danharaj> @pl (\f g a b -> f (g a b))
18:48:52 <lambdabot> (.) . (.)
18:49:01 <dmwit> applicative: I don't think tabs are coming in; this is just pre-emptive.
18:49:11 <applicative> oh, like dmwit said
18:49:13 <luxurymode> nand` true… i wasnt being accurate. i just mean that functions have well-defined values and that you cant simply say a =3 if you already said its 2
18:49:32 <luxurymode> i come from a java background, so its just very…different ;)
18:49:45 <nand`> luxurymode: you can, just not in the same scope ;)
18:49:57 <luxurymode> well right of course
18:49:59 <danharaj> @pl (\f g a -> f . (g a))
18:49:59 <lambdabot> (.) . (.)
18:50:01 <nand`> let a = 2 in let a = 3 in a
18:50:02 <taiyal> what version of Haskell should I be using to start out on learning it?
18:50:03 <nand`> > let a = 2 in let a = 3 in a
18:50:04 <lambdabot>   3
18:50:15 <adit> ghc v. 7.4
18:50:18 <dmwit> > let a = 2; a = 3 in a -- same scope
18:50:19 <lambdabot>   Conflicting definitions for `a'
18:50:19 <lambdabot>  Bound at: <interactive>:1:4
18:50:19 <lambdabot>            <in...
18:50:23 <dmwit> =)
18:50:34 <luxurymode> hehe thanks
18:50:38 <dmwit> taiyal: Haskell 2010
18:50:40 <taiyal> are there any ppa's with the latest version of haskell
18:50:44 <taiyal> for ubuntu / mint
18:50:49 <taiyal> or do I have to build it
18:50:54 <nand`> > do { let a = 2; let a = 3; a }
18:50:55 <lambdabot>   <no location info>: parse error on input `}'
18:51:01 <nand`> > do let a = 2; let a = 3; a
18:51:01 <dmwit> taiyal: Though you probably meant "which Haskell compiler should I use", in which case the answer is "whatever is the most recent stable GHC available from GHC's website".
18:51:02 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:51:04 <DanBurton> @where hp
18:51:04 <lambdabot> http://hackage.haskell.org/platform/
18:51:15 <nand`> well, “return a” anyways
18:51:26 <dmwit> Oh, the Haskell Platform is pretty good, too.
18:51:29 <applicative> totimkopf: similarly you start a do block in line 14 with the statement 'ineof <- hIsEOF inh'  but the 'if'  is the other statement in that block, but it's not lined up
18:51:35 <DanBurton> taiyal: you can apt-get install haskell-platform
18:51:53 <totimkopf> applicative, that's how it is in the book :D
18:51:55 <DanBurton> but it's not the latest
18:52:06 <applicative> hm, whats the book?
18:52:06 <DanBurton> but it's close enough
18:52:12 <adit> totimkopf: check the errata
18:52:31 <dmwit> totimkopf: Pics or it didn't happen.
18:52:45 <taiyal> are there any major changes in syntax between ghc6 and ghc7?
18:52:50 <dmwit> No.
18:52:53 <taiyal> okay
18:52:55 <dmwit> However, GHC6 is a bit old.
18:53:01 <applicative> totimkopf, these are really ancient rules. is it electronic so you are cutting and pasting?
18:53:10 <taiyal> is it easy to build GHC7 from source?
18:53:23 <totimkopf> applicative, no, I'm a masochist, I'm typing as I see it
18:53:25 <dmwit> No, but it is easy to install the GHC7 binaries available from the website.
18:53:48 <applicative> i'm baffled what is the thing you're reading, there may be some curiosity in publication
18:54:12 <applicative> dmwit and adit aren't kidding, the code as you wrote it never compiled on any implementation
18:54:15 <totimkopf> page 170 Chapter 7: I/O of Real World Haskell
18:54:27 <applicative> ahah
18:54:33 <dmwit> ?where rwh
18:54:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:54:53 <adit> looks correct on the site
18:54:54 <dmwit> totimkopf: Lies.
18:54:55 <adit> http://book.realworldhaskell.org/read/io.html
18:55:23 <dmwit> totimkopf: I conclude that you typed it in as *you* saw it, but you don't know which parts are important.
18:55:26 <dmwit> ;-)
18:55:36 <totimkopf> ok, I stand corrected then
18:55:58 <totimkopf> this book rocks my socks off, btw
18:56:13 <totimkopf> I'm reading this one as a supplement to 'Learn You a Haskell for Great Good'
18:56:37 <DanBurton> LYAH + RWH is an excellent way to get started with Haskell
18:56:55 <applicative> totimkopf, the rule is simple, but i get tripped up by it pretty frequently
19:00:18 <applicative> totimkopf, there are already a few out of date bits with RWH, but people here can explain when opaque errors arise....
19:01:25 <totimkopf> cool, thanks, can you generalize the outdated bits?
19:02:41 <applicative> well, the error handling chapter uses what is now called Control.OldException, instead of the new exception system This came up when i was on here earlier
19:04:05 <td123> there's also some early content that has errors, forgot what
19:04:10 <applicative> I think the Parsec chapter uses Parsec-2, one problem is because the underlying types of Parsec-3 are more abstract, you need a few more type signatures around
19:05:06 <applicative> if there is trouble with the parsec snippets, if I remember, it sometimes helps to throw {-#LANGUAGE NoMonomorphismRestriction#-} at the top of the file
19:05:51 <applicative> totimkopf: these are the things i remember, or think i remember
19:05:51 <totimkopf> ah
19:05:59 <totimkopf> cool, thanks
19:07:43 <XexonixXexillion> I have to parse an ada specification. What library would people here suggest using?
19:08:12 <applicative> the only other problem is its missing some of the swanker ultra-modern libraries, many of them due to the authors themselves but only now established
19:08:28 <adit> afaik your choices are Parsec or Happy
19:08:50 <adit> I'm using Parsec on a project and like it
19:11:35 <tgeeky_> adit: you missed a chance to say that you were Happy with it
19:11:53 <adit> wow
19:11:59 <adit> I can't believe I missed that
19:12:38 <adit> I was parsec with Happy. There.
19:13:14 * applicative is unparsec with happy; parsec with parsec
19:14:21 <lispy> hi
19:16:19 <adit> hi
19:17:52 <lispy> I wish I had more free time
19:17:58 <lispy> But doesn't everyone?
19:18:04 <lispy> edwardk: ping
19:18:23 <mdxbhmt> need time? I wish I had time efficiency
19:19:14 <lispy> mdxbhmt: what is time efficiency?
19:19:24 <mdxbhmt> Do more with less
19:19:38 <mdxbhmt> as I must stop wasting my time on reddit //lol
19:19:42 <mdxbhmt> as in*
19:19:58 <lispy> some amount of time wasting is healthy though, so don't cut that part :)
19:20:07 <mdxbhmt> Yes
19:20:21 <mdxbhmt> but when you live on perpetual procrastination, somethings really wrong
19:20:22 <mdxbhmt> ahahah
19:20:29 <slack1256> somebody has binaries of wxhaskell?, i tried to build it but ran off memory (2GB)
19:20:44 <slack1256> archlinux doesn't have wxhaskell binaries on the new release of GHC
19:21:03 <lispy> slack1256: running out of memory while building haskell stuff usually happens inside gnu ld for me
19:21:16 <lispy> slack1256: do you know if it was gnu ld that ran out of memory for you?
19:21:45 <slack1256> not really, it seemed that a bunch of newtype on CINT and CBOOL where causing errors
19:22:08 <slack1256> problems with the FFI basically
19:22:21 <lispy> slack1256: that's odd
19:22:30 <lispy> I haven't seen that one before
19:22:42 <slack1256> but i could try tunning up the gnu ld bin
19:22:47 <slack1256> what did you do to solve it?
19:22:49 <JoeyA> base 4.5 changed how they do the Foreign.C types CInt, etc.
19:23:09 <JoeyA> (don't know what CBOOL is, though)
19:23:34 <JoeyA> In base 4.4, CInt was an abstract type: http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/Foreign-C-Types.html#t:CInt
19:23:47 <JoeyA> In base 4.5, CInt is a newtype: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t:CInt
19:23:53 <Axman6> JoeyA: dyslexis tells me it's COBOL :P
19:24:35 <JoeyA> This will result in FFI import warnings, if the library writer did explicit imports.
19:24:40 <slack1256> joeyA: before also happened (GHC 6.10) but at the end i had a succesful package.
19:24:47 <lispy> slack1256: I had to rebuild ghc and disable split-objs
19:24:48 <JoeyA> (e.g. import Foreign.C (CInt)
19:25:13 <JoeyA> Not sure any of what I said is related.
19:26:00 <JoeyA> You might have better luck installing the dependencies piecemeal.  I've seen cabal's memory usage go up and up when installing a lot of packages.
19:26:39 <slack1256> mmm. ok i will try installing dependencies pice by piece.
19:26:46 <slack1256> also will post an hpaste
19:26:55 <lispy> I wonder if gold can be used with ghc and if it would fair better
19:27:34 <dmwit> Yes, gold can be used with ghc.
19:27:53 <dmwit> And yes, reportedly it fares better.
19:27:56 <byorgey> bitcoins can also be used with ghc.
19:28:11 <lebro> i use diamonds with mine
19:28:24 <dmwit> I mine diamonds with use.
19:28:36 <lebro> almonds* srry typo
19:28:45 <lebro> on a budget atm
19:28:47 <byorgey> hehehe
19:28:48 <hpaste> slacknatcher pasted “wxhaskell errors on FFI” at http://hpaste.org/64766
19:28:52 <lispy> a quick google search makes me think gold works with ghc and has better performance
19:29:11 <dmwit> ?hackage manatee includes gold as a prerequisite =)
19:29:11 <lambdabot> http://hackage.haskell.org/package/manatee includes gold as a prerequisite =)
19:29:22 <slack1256> why gold isn't the default?
19:29:39 <parcs`> it is not as
19:29:43 <parcs`> stable as gnu ld
19:29:43 <dmwit> slack1256: Those are not errors.
19:30:02 <dmwit> slack1256: The code that would correct those warnings would also not change anything other than what GHC printed.
19:30:13 <JoeyA> Indeed, those are the warnings I was talking about.
19:30:18 <dmwit> slack1256: (The correct solution is to import a module; if it prints that warning, it imports the module for you.)
19:30:19 <slack1256> i know, but is there where the memory blows up.
19:31:17 <dmwit> Okay. I just got here, so I'm sure I'm missing some context; likely I won't have anything helpful to say even if you were to tell me more, since that's very nearly the boundary of my knowledge of the FFI. =)
19:32:02 <JoeyA> Note to package writers: although explicit imports are usually a good idea, don't do them for Foreign.C anymore.
19:32:04 <slack1256> dmwit: also mine, i only know how to code in haskell not in C
19:32:35 <dmwit> Explicit imports in Foreign.C are fine if you import the appropriate constructors.
19:32:39 <JoeyA> import Foreign.C (CInt) -- wrong: produces a warning with GHC 7.4
19:32:51 <dmwit> import Foreign.C (CInt(CInt)) -- correct
19:33:00 <JoeyA> doesn't work with earlier versions of base
19:33:04 <JoeyA> you'd have to do an #if
19:33:28 <dmwit> Oh, I didn't know that.
19:33:28 <JoeyA> #if MIN_VERSION_base(4,5,0)  (import constructor)  #else  (do it the other way)  #endif
19:33:45 <JoeyA> It's easier to just say: import Foreign.C  ;-)
19:35:01 <mdxbhmt> mother told me to never import strangers
19:35:19 <JoeyA> Can you import foreigners?
19:35:29 <mdxbhmt> they scare me
19:35:31 <covi> Is there a way to do something like   filter (not . elem [RANGE]) [RANGE']
19:35:49 <covi> (the   elem [RANGE]  part is obviously not properly composed)
19:36:16 <JoeyA> So elements not in a given range?
19:36:20 <covi> JoeyA: yeah
19:36:24 <slack1256> but foreigners are cool. they make the best haskell compilers!
19:36:32 <JoeyA> ;-)
19:36:37 <covi> JoeyA: the [RANGE] maybe a given list.
19:36:37 <JoeyA> err, :-)
19:36:43 <dmwit> covi: notElem
19:36:48 <JoeyA> ;-) implies I was involved in the making of Haskell.  I wasn't.
19:36:54 <mdxbhmt> slack1256: That's why our economy is dying, we keep outsourcing to foreigners!
19:36:59 <covi> :t notElem
19:37:00 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
19:37:08 <JoeyA> > filter (notElem [0..9]) "The answer is 42"
19:37:09 <lambdabot>   Couldn't match expected type `[[t]]'
19:37:10 <lambdabot>         against inferred type `GHC.Typ...
19:37:16 <JoeyA> > filter (`notElem` [0..9]) "The answer is 42"
19:37:17 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
19:37:17 <lambdabot>    arising from the literal `0...
19:37:22 <slack1256> mdxbhmt: i have a job because of that!
19:37:24 <covi> dmwit: thanks!
19:37:44 <dmwit> JoeyA: 0 is not a character
19:37:53 <dmwit> JoeyA: Perhaps you wanted ['\0' .. '\9']
19:38:04 <dmwit> or ['0' .. '9']
19:38:05 <JoeyA> > filter (`notElem` ['0'..'9']) "The answer is 42"
19:38:05 <dmwit> not sure
19:38:06 <lambdabot>   "The answer is "
19:38:10 <covi> When I program in Haskell, I don't feel like everything is in my control. Maybe that's because I'm a newbie.
19:38:12 <mdxbhmt> slack1256:  we need to keep our language pure! No  haskell shall marry C++
19:38:22 <dmwit> covi: What don't you have control of?
19:38:34 <covi> dmwit: complexity of the code I wrote
19:38:50 <covi> dmwit: I mean in C/C++/Python, I can easily judge them
19:38:50 <td123> are you talking about runtime?
19:39:02 <td123> algorithmic complexity?
19:39:12 <JoeyA> One time I searched for HDBC (Haskell Database Connectivity package), and Google said "Searching instead for JDBC"
19:39:20 <JoeyA> arggh
19:39:35 <mdxbhmt> I think he speaking about function complexity, haskell can seems quite a high wall
19:39:44 <dmwit> JoeyA: Click on the "no, I really meant HDBC", and teach Google that HDBC is a thing.
19:39:52 <covi> td123: algorithmic complexity (both time and space)
19:39:58 <JoeyA> It knows better now.
19:46:24 <ivanm> preflex: seen malcolmw
19:46:25 <preflex>  malcolmw was last seen on #haskell 254 days, 9 hours, 49 minutes and 41 seconds ago, saying: GHC has a CSE pass, but it is usually turned off
19:46:48 * ivanm wonders why polyparse's BS parser is Char-based rather than Word8-based
19:47:35 <slack1256> ivanm: what is the benefit of using a word8-based instead of one char-based?
19:48:03 <ivanm> slack1256: because BS is Word8-based, so to make it Char-based requires a conversion step
19:48:17 <ivanm> and I then want to parse binary data, which means I need to convert the Char back to Word8
19:48:21 <JoeyA> unsafeCoerce to the rescue!
19:48:25 <ivanm> heh
19:48:55 <JoeyA> > unsafeCoerce 'a' :: Word8
19:48:55 <lambdabot>   Not in scope: `unsafeCoerce'
19:49:29 <JoeyA> unsafeCoerce '\x266b' :: Word8 prints 9835 :D
19:49:50 <JoeyA> Apparently, Word8 is capable of storing numbers larger than 256
19:50:01 <JoeyA> err, 255
19:50:05 <ivanm> :o
19:50:45 <slack1256> oh. that makes sense.
19:50:57 <mdxbhmt> that doesn't
19:50:58 <mdxbhmt> @.@
19:50:58 <lambdabot> Maybe you meant: . @
19:51:08 <mdxbhmt> > "no"
19:51:08 <lambdabot>   "no"
19:51:34 <JoeyA> Apparently, Word8 is stored internally in a format similar to Int.
19:54:45 <lebro> word?
19:55:06 <shergill> bird
19:55:22 <slack1256> mdxbhmt: sorry i refered to BS being Word8-based as "making sense"
19:55:43 <lebro> herd
19:55:44 <ion> λ> unsafeCoerce (maxBound :: Word16) :: Word8
19:55:45 <ion> 65535
19:55:57 <ion> λ> unsafeCoerce (maxBound :: Word64) :: Word8
19:55:59 <ion> -1
19:56:04 <mdxbhmt> slack1256: there's nothing to be sorry lol
19:56:38 <Axman6> > fromIntegral (maxBound :: Word64) :: Word8
19:56:39 <lambdabot>   255
19:56:39 <mdxbhmt> in fact it makes some sense, because there should be no way to store a 8 bit word
19:56:42 <shergill> turd?
19:56:43 <Axman6> :o
19:57:28 <rwbarton> one might hope the Show instance for Word8 would only use 8 bits of the stored value, though
19:57:46 <JoeyA> In Monad.Reader 15, one of the articles, by Andrew Coppin, describes the making of a pure-Haskell STM implementation.  Did he ever release the code?
19:58:21 <ion> rwbarton: If the only way you’re going to get broken Word8s is unsafeCoerce i wouldn’t care.
19:58:47 <dmwit> I must say I'm quite confused by this exchange:
19:58:57 <dmwit> Prelude Unsafe.Coerce Data.Word> unsafeCoerce (-1) :: Word8
19:58:58 <dmwit> -1
19:58:58 <dmwit> Prelude Unsafe.Coerce Data.Word> unsafeCoerce (2^64-1) :: Word8
19:58:58 <dmwit> 72058142106464399
19:58:58 <dmwit> Prelude Unsafe.Coerce Data.Word> unsafeCoerce (2^64) :: Word8
19:59:00 <dmwit> 144115736144393533
19:59:24 <ion> You’re coercing Integers.
19:59:35 <dmwit> Yes, to Word8s.
19:59:53 <dmwit> How are those Word8s storing bigger numbers than an actual machine word can store?
20:00:01 <ion> As in, libgmp stuff :-)
20:00:07 <dmwit> Yes, I know.
20:00:18 <dmwit> Ah, yes, I misread the answer.
20:00:20 <ion> Perhaps they aren’t; perhaps the Show instance is just confused.
20:00:44 <mauke> > (unsafeCoerce (2^64) :: Word8) > maxBound
20:00:44 <lambdabot>   Not in scope: `unsafeCoerce'
20:00:53 <ion> > logBase 2 144115736144393533
20:00:55 <lambdabot>   57.00000548654357
20:00:59 <dmwit> Yes, I very misread the answer. Things make much more sense now.
20:01:03 <mdxbhmt> noob question. what exactly is unsafeCoerce?
20:01:15 <mauke> concentrated satan
20:01:16 <dmwit> "unsafeCoerce randomBits :: Word8" explains this output
20:01:17 <shachaf> mauke: I doubt lambdabot will ever provide unsafeCoerce. :-)
20:01:26 <shachaf> But (> maxBound) of that thing is True.
20:01:49 <shachaf> Word8 internally just stores a Word64, I'm pretty sure.
20:01:59 <cmccann> mdxbhmt, it's a function with type (a -> b)
20:02:20 <JoeyA> @hoogle unsafeCoerce
20:02:21 <cmccann> that and the word "unsafe" in its name should give you the basic idea
20:02:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:02:24 <shachaf> And (+) and so on behave in the way you'd expect them to for Word8.
20:02:31 <shachaf> And fromInteger, in particular.
20:02:39 <JoeyA> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Unsafe-Coerce.html#v:unsafeCoerce
20:02:48 <shachaf> But if you unsafeCoerce something to Word8 there are no guarantees -- the internally-stored Word will just be too big.
20:02:50 <mdxbhmt> cmccann, change the type and pray to god it works?
20:02:54 <shachaf> data Word8 = W8# Word# 	-- Defined in `GHC.Word'
20:03:05 <JoeyA> mdxbhmt: Precisely.
20:03:12 <dmwit> shachaf: I wouldn't be surprised if Word8 was a Word32 on 32-bit machines.
20:03:25 <mdxbhmt> JoeyA: That's seems a toy for the devil
20:03:32 <applicative> mdxbhmt import Unsafe.Coerce in ghci and see what happens...
20:03:32 <ivanm> mdxbhmt: it is
20:03:38 <cmccann> mdxbhmt, that's the gist of it. it's very easy to generate segfaults that way.
20:03:42 <Jafet> GHC states that any WordN smaller than Word has the same representation as Word, I think
20:03:47 <shachaf> dmwit: Yep. And a Word64 on 64-bit machines.
20:03:48 <rwbarton> but why does (+) behave in the way I expect but not (>)
20:03:51 <shachaf> Or, rather, a Word#
20:04:02 <shachaf> rwbarton: Because it probably just does regular comparison on the Word#s?
20:04:12 <ion> rwbarton: Because of the assumption that the incoming data is valid.
20:04:14 <rwbarton> but (+) is an add and a bitmask?
20:04:42 <shachaf> λ> W8# (unsafeCoerce# (2^64) :: Word#) -- 139749287259738
20:04:49 <shachaf> λ> W8# (unsafeCoerce# (2^64) :: Word#) + 1 -- 171
20:05:01 <Jafet> I expect it to use the processor's byte-adding instruction
20:05:07 <applicative> unsafeCoerce (Just 7) :: String    "\aSegmentation fault
20:05:36 <ion> applicative: There should be a package in the style of spoon that captures that string.
20:05:39 <JoeyA> code-golf: Write the smallest unsafeCoerce expression that produces a segfault.
20:05:40 <rwbarton> but not the byte-comparing instruction, for some reason, apparently
20:05:47 <Jafet> JoeyA: unsafeCoerce 0 0
20:05:49 <JoeyA> The shortest one I know is, in GHCi: unsafeCoerce retry
20:06:27 <JoeyA> I get an internal error, not a segfault.  Good enough, though ;-)
20:06:38 <JoeyA> (for unsafeCoerce 0 0)
20:06:42 <Jafet> stg it to the man.
20:06:53 <shachaf> rwbarton: Well, you don't *need* to use the byte-comparing instruction for correctness, at least.
20:06:58 <dmwit> JoeyA: Remember to double-check it with compiled code.
20:07:02 <shachaf> It would only be a performance thing, presumably.
20:07:04 <ion> peek nullPtr
20:07:06 <shachaf> Or something.
20:07:11 <rwbarton> hmm, I guess.
20:07:17 <dmwit> JoeyA: ghci is unbelievably robust to unsafeCoerce, for some reason.
20:07:39 <applicative>  unsafeCoerce [1] :: Char      '\-1476080038'
20:07:40 <JoeyA> http://codegolf.stackexchange.com/a/4404/38
20:08:07 <JoeyA> heh
20:08:56 <cmccann> JoeyA, nice
20:09:03 <JoeyA> (that's syntactically invalid, by the way)
20:09:12 <applicative>  unsafeCoerce unsafeCoerce :: Int     4
20:09:18 <shachaf> rwbarton: data Word8 = W8# Word# deriving (Eq, Ord)
20:09:25 <shachaf> rwbarton: I think that's a sufficient explanation. :-)
20:09:41 <rwbarton> I see
20:12:26 <applicative> what does internal error: TSO object entered! mean?  thats what i get from JoeyA 's foreign import
20:12:57 <JoeyA> It means the TSO object has been entered!  Duh.
20:13:06 <applicative> oh
20:13:17 <applicative> with ghc-7.4 it's internal error: STACK object entered!
20:13:41 <applicative> I think i won't report it as a bug
20:13:42 <cmccann> applicative, http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#ThreadStateObjects
20:13:56 <JoeyA> It's a feature.
20:14:16 <applicative> ah,  Thread State Object is already a flood of ligh
20:14:18 <applicative> light
20:15:39 <cmccann> also, "entered" is GHC jargon for... something it does which it's not supposed to do to some things, only other things
20:15:49 * cmccann is helpful
20:16:02 <JoeyA> I get a segfault no matter what, it seems (when I compile and run foreign import ccall main::IO())
20:16:09 <JoeyA> I'm on Ubuntu 64-bit.
20:16:47 <dmwit> entering is when you set the PC to the value of a pointer in hopes of it either converting a thunk or returning immediately
20:16:50 <dmwit> ...I think
20:17:05 <cmccann> yeah, I've mostly heard it used in reference to closures
20:17:40 <cmccann> I assume it's something to do with inspecting a value of a lifted type
20:18:13 <JoeyA> Unrelated: do MVar operations act as barriers to IORef reordering like atomicModifyIORef does?
20:18:15 <dmwit> I'm pretty sure it's for Haskell values of any type.
20:18:21 <dmwit> But TSO's are not Haskell values of any type.
20:18:25 <cmccann> hm, ok
20:18:37 <maloi> > let f = fix reverse in f [1,2,1]
20:18:38 <lambdabot>   Couldn't match expected type `[t1] -> t'
20:18:38 <lambdabot>         against inferred type `[a]'
20:18:45 <dmwit> source: vague recollections of skimming the STG paper long ago
20:18:45 <maloi> :(
20:19:04 <dmwit> JoeyA: Excellent question.
20:19:11 <JoeyA> Suppose I have a mutable data structure implemented with IORefs, all behind an MVar.  Is it safe to take the MVar lock, do something to the data structure in one thread, then release it and have another thread take the MVar lock and use it?
20:19:19 <dmwit> Probably not, but if you're using an MVar already, why bother with IORefs?
20:19:34 <dmwit> ...ah
20:20:13 <dmwit> > iterate reverse [1,2,1] -- maloi?
20:20:13 <lambdabot>   [[1,2,1],[1,2,1],[1,2,1],[1,2,1],[1,2,1],[1,2,1],[1,2,1],[1,2,1],[1,2,1],[1...
20:21:00 <dmwit> > let someFixpointButHopefullyNotTheLeast f x = if x == f x then x else someFixpointButHopefullyNotTheLeast f (f x) in someFixpointButHopefullyNotTheLeast reverse [1,2,1]
20:21:00 <lambdabot>   [1,2,1]
20:21:04 <dmwit> also a possibility
20:26:00 <maloi> thx, i'm playing with fix atm
20:26:54 <maloi> and i thought because of reverse [1,2,1] == [1,2,1] that fix reverse [1,2,1] just gives me [1,2,1] aswell
20:27:22 <dmwit> Yep, [1,2,1] is a fixpoint of reverse, but it's not the least fixpoint of reverse.
20:27:36 <dmwit> reverse undefined is undefined, so fix reverse is undefined.
20:27:38 <dmwit> > fix reverse
20:27:42 <lambdabot>   mueval-core: Time limit exceeded
20:28:10 <dmwit> (Also, "fix reverse" doesn't have a function type, so you know right away that "fix reverse [1,2,1]" isn't going to fly. =)
20:28:13 <dmwit> :t fix reverse
20:28:14 <lambdabot> forall a. [a]
20:28:43 <maloi> yup, that hits me right after i typed it in here :)
20:28:50 <maloi> -s
20:31:10 <maloi> can i say that fix reverse won't work, because reverse is not lazy, too?
20:32:43 <dmwit> Yes, fix <anything strict> is undefined.
20:33:04 <dmwit> This is direct from the definition of strict: "f" is strict when "undefined" is a fixpoint. =)
20:33:17 <maloi> wow, that's cool
20:33:41 <maloi> thank you
20:37:46 <ivanm> in parsec, which modules are the parsec3 ones? Text.Parsec or Text.ParserCombinator ?
20:37:53 <edwardk> lispy: pong
20:38:04 <applicative> the former
20:38:10 <ivanm> OK
20:38:42 <lispy> edwardk: I just noticed Johan's email about not being head mentor.  How does that play with your plan to register haskell.org this year?
20:38:57 <lispy> edwardk: do we still need someone to cover for Johan this year?
20:39:07 <edwardk> thats fine. i could use a backup admin, just so i have a name to put in
20:39:41 <edwardk> but its not a problem
20:39:50 <lispy> edwardk: You can write me down if you like
20:39:55 <edwardk> will do
20:40:29 * ddarius waits for a ParseC package.
20:41:18 <ivanm> ddarius: just to confuse everyone? :p
20:41:23 <ivanm> how would it differ from language-c ?
20:41:53 <ddarius> It would be written by someone who has only used Haskell for a week.
20:41:55 <edwardk> johan mostly ran around getting people psyched about it, and tried to propose project ideas last year. for the last couple of years i've done the paperwork, and most of the emails, etc. this last year i'd asked him to coadmin again because i was going on vacation smack dab in the middle of the approval process, but i don't have any such plans this year
20:42:28 <edwardk> so you probably won't get hit with too much to do, unless i get hit by a bus =P
20:42:38 <ivanm> how does count in attoparsec differ from replicateM?
20:42:41 <ivanm> @src replicateM
20:42:41 <lambdabot> replicateM n x = sequence (replicate n x)
20:42:49 <ivanm> oh, it doesn't
20:42:51 <ivanm> just a redefinition
20:42:54 <ivanm> yay :s
20:43:13 <ddarius> The name "count" preceded replicateM by a large amount.
20:43:34 <lispy> edwardk: well, training me up would be good for us both :)
20:43:54 <edwardk> sounds good
20:44:11 <edwardk> i'll do the registration tomorrow and put your name down
20:44:25 <edwardk> was going to today, but i got distracted by a pack of wild haskellers
20:44:30 <lispy> hehe
20:44:38 <lispy> Suddenly Monads
20:44:54 <edwardk> suddenly hamiltonian mechanics, bloom filters and ray tracing
20:44:59 * applicative howls at edwardk
20:45:09 <lispy> oh, neat
20:45:23 <lispy> edwardk: I started writing a ray tracer last year
20:45:27 <lispy> made it reasonably far
20:45:32 <ivanm> ddarius: huh? attoparsec isn't *that* old...
20:45:44 <ddarius> Parsec is though.
20:45:48 <edwardk> i do a bit of work on metropolis light transport these days
20:45:49 <totimkopf> hmm, what is better to get GHC 7.2 or 7.4?
20:45:54 <totimkopf> I have 7.2 installed
20:46:48 <ivanm> oh, must have missed that being defined in parsec
20:46:58 <ivanm> totimkopf: 7.4 is better, but not everything builds with it yet
20:47:03 <ivanm> unless your distro has patches
20:47:22 <totimkopf> hmm, I just compiled 7.2 for mac os x
20:47:24 * ion reads <http://en.wikipedia.org/wiki/Metropolis_light_transport>. Seems cool.
20:47:54 <applicative> totimkopf: i don't think the haskell platform flotilla of libraries is all ready for 7.4
20:48:21 <applicative> oh, totimkopf you have 7.0.x from the haskell platform?
20:48:23 <totimkopf> well, in any case, I'm still learning Haskell so I don't think it would better
20:48:56 <totimkopf> yeah, I got the platform initially but compiled ghc 7.2 by hand :D
20:49:01 <totimkopf> is that naughty?
20:49:04 * ddarius fixed his tail calling code.
20:49:18 <applicative> totimkoptf, i would have said the Haskell Platform installer is the best in that case, since things like the gui libraries you might want to try are more likely to get all the linking right
20:49:29 <totimkopf> oh :(
20:49:46 <totimkopf> well, I'm not using any GUI libraries atm
20:50:00 <totimkopf> I'm just using ghc/ghcrun/ghci :)
20:50:32 <ivanm> nothing to do with GUI libraries
20:50:41 <applicative> totimkopf: oh, missed your next remark. you might have trouble with things like network and HTTP, but maybe not
20:50:46 * ddarius has written interpreters for Joy-like languages (usually with "first-class" defining forms) in Haskell, x86 assembly, and Java now.
20:50:49 <totimkopf> ohhh :(
20:50:51 <ivanm> upstream darcs doesn't build on 7.4 IIUC
20:51:10 <totimkopf> applicative, because I installed 7.0.x platform then GHC 7.2?
20:51:17 <totimkopf> or are you talking about 7.4 again?
20:51:41 <ivanm> totimkopf: 7.4
20:52:38 <ddarius> (Actually, the x86 assembly one was a very simple compiler, but it's quotations are second-class which is not as limiting as it might first seem.)
20:52:55 <applicative> totimkopf, no, i just mean, you have a ghc-7.2 with just the basic libraries
20:53:55 <applicative> totimkopf, the advantage of the Haskell Platform is that heroic benefactors solve problems with more difficult libraries
20:54:11 <totimkopf> applicative, oh, so I won't be able to use socket related stuff with ghc-7.2 without the platform?
20:55:30 <ddarius> totimkopf: Basically the packages that were installed by the platform won't be used by 7.2 so you'll end up reinstalling them.
20:55:37 <applicative> well you'd need to install network anyway
20:56:04 <applicative> oh yeah, like ddarius says, you need to reinstall the libraries you use.  you can see what you have now with ghc-pkg list
20:57:23 <applicative> have you cabal-installed anything since you put in the new ghc?
20:57:41 <totimkopf> yes
20:57:45 <totimkopf> i mean, no
20:57:47 <totimkopf> :D
20:57:51 <totimkopf> i have 0 packages
20:58:05 <totimkopf> is there a list somewhere of all the packages that are included in the 'platform'?
20:58:16 <applicative> yeah its on the webpage
20:58:20 <totimkopf> ok, thanks
20:58:26 <ddarius> The Platform is nothing but a list.
21:00:05 <applicative> i'm not seeing the list, but it's somewhere on the platform site
21:02:06 <ivanm> I'm wanting to compare various parsers for parsing binary data; does binary have any equivalent of a "satisfy" combinator (e.g. satisfy (/=0) to parse a non-zero byte)?
21:02:27 <ddarius> The binary package has no notion of failure.
21:02:36 <totimkopf> meh, I'll just re-install the platform
21:02:57 <ddarius> totimkopf: It shouldn't have been uninstalled.
21:03:14 <ddarius> You can have as many GHCs side-by-side as you want.
21:03:25 <totimkopf> well, I replaced all the ghc binaries in /usr/bin with the ghc 7.2 equivalents
21:03:51 <applicative> totimkopf: you can figure out the platform libs your missing from the tarball http://hackage.haskell.org/platform/linux.html
21:04:18 <dmwit> totimkopf: ghc, ghc-pkg, and ghci should just be links to ghc-7.x, ghc-pkg-7.x, and ghci-7.x anyway.
21:04:43 <dmwit> symlinks
21:04:48 <ddarius> whereis ghc-7.0.4
21:04:51 <dmwit> And maybe something else, too... haddock perhaps?
21:04:55 <ivanm> ddarius: so it's all position-based? i.e. you have to know that so many bits here mean something, then so many bits there?
21:05:26 <totimkopf> aaaaa
21:05:27 <totimkopf> yes
21:05:29 <totimkopf> now I see
21:05:40 <applicative> totimkopf, i think the way to go is have the platform installed the usual way, then build fancy ghc's locally
21:06:13 <ddarius> ivanm: It's intended for formats where "parsing" is deterministic.
21:06:40 <ivanm> *nod*
21:07:00 <ivanm> OK, doesn't apply to what I want then (keep parsing until you reach a 0; repeat n times)
21:07:11 <dmwit> satisfy (/= 0) doesn't exactly scream nondeterministic to me.
21:07:37 <dmwit> Ah, that part does sound nondeterministic.
21:08:24 <dmwit> But that uses <|> or similar, which does scream nondeterministic.
21:08:46 <applicative> totimkopf: on the other hand, you will probably learn a lot about all the bits and pieces of ghc-land if you make a go of 7.2
21:08:54 <ivanm> dmwit: using many1, so I suppose so
21:11:14 <ivanm> if I want to benchmark different parsers with criterion, should I have the benchmark read the file in each time or load the entire contents in first?
21:12:21 <dmwit> Loading the contents is probably more honest.
21:12:40 <dmwit> Your OS is probably going to do that, anyway.
21:12:53 * totimkopf tired -- will just have fun with the ghc he has installed on his ubuntu laptop
21:13:01 <totimkopf> the haskell platform… that is
21:13:16 <dmwit> err... that is, loading the file's contents before starting criterion is probably more honest
21:13:36 <dmwit> Having whatever benchmark you're handing off to criterion load the file is probably pointless.
21:13:58 <ivanm> dmwit: that's what I figured
21:14:19 <ivanm> just worried that if it's big that it might swamp memory from having it kept in memory all the time
21:17:00 <dmwit> You could "swapoff" before you run criterion, then read from the file every time.
21:17:17 <dmwit> err
21:17:28 <dmwit> swapoff isn't quite the right thing, is it?
21:17:50 <dmwit> Yeah, it's not.
21:18:13 <dmwit> Does your OS have a convenient way to turn off disk caching or flush the cache?
21:19:10 <dmwit> man -k cache doesn't show anything terribly convincing
21:19:43 <ivanm> it's Linux...
21:20:01 <ivanm> or else just have all the benchmarks take a ByteString as input, have main read it in, rnf it, etc.
21:20:01 <dmwit> Maybe so, but I don't know the answer even for Linux.
21:20:15 <totimkopf> what IDE do you guys recommend for haskell?
21:20:25 <totimkopf> I don't want to worry about the stupid spacing issue with keywords again
21:21:37 <dmwit> totimkopf: No IDE is sufficiently advanced to obviate the need for understanding the layout rule.
21:21:53 <totimkopf> :<
21:21:59 <dmwit> (In fact, becoming sufficiently advanced in that respect is AI-complete.)
21:22:28 <dmwit> ivanm: /proc/sys/vm/drop_caches looks promising
21:22:41 <ivanm> eh, stuff it
21:22:45 <dmwit> ivanm: Provided you aren't also writing.
21:23:54 <mdxbhmt> strange idea here: Is there a way of editing files inside ghci and the interpreter reevaluates all functions call that I did in the past so I can see the diferences?
21:31:20 <ivanm> is there a NFData instance for ByteString anywhere?
21:45:41 <QinGW> @type equalP
21:45:42 <lambdabot> Not in scope: `equalP'
22:01:56 <adit> has anyone used the llvm bindings for haskell?
22:03:16 <adit> I'm trying to use them for a toy project, and wondering if I'd be better off writing something myself
22:05:55 <Enigmagic> adit: yes, i have a large working compiler written using them
22:06:57 <adit> Yeah, you had mentioned that. I'm just trying to build a toy compiler, and reading through the source for the bindings seems like a lot of overhead
22:07:23 <adit> I might go your route and build one in C first, but ideally I would have liked to build it in Haskell
22:07:57 <Enigmagic> adit: well, they try to be type-safe. the production compiler i wrote in C++ was quite a lot of work to maintain compared to the Haskell/LLVM-bindings but it was much easier to get started
22:08:19 <Enigmagic> if you just want to generate bitcode you could look at the llvm assembly printer in ghc
22:08:46 <Enigmagic> someone was talking about maintaining it outside of the ghc codebase, perhaps this has been done already
22:08:54 <adit> yeah, that's another possibility
22:09:09 <adit> the thing is, llvm has great documentation for the bitcode
22:09:15 <adit> so that might actually be easier
22:09:35 <Enigmagic> sorta, you'll need to run the debug+asserts llvm bits and the verifier pass to catch type errors
22:10:04 <Enigmagic> it's the nice part about dealing with the llvm-bindings is most of those runtime/assembler errors from llvm turn into haskell build breaks
22:10:37 <adit> agreed
22:10:47 <Enigmagic> though certain things are so complicated (like dealing with llvm structs) in the llvm-bindings that i don't think it's always worthwhile
22:11:39 * hackagebot KMP 0.1.0.2 - KnuthMorrisPratt string searching algorithm  http://hackage.haskell.org/package/KMP-0.1.0.2 (CindyLinz)
22:11:53 <adit> Yeah. I'm going through it very slowly right now.
22:12:12 <adit> I'd love to grok it fully and write a mini-tutorial
22:12:21 <adit> To make this easier for myself and whoever else
22:13:52 <Enigmagic> that would be a huge benefit imo
22:15:30 <ion> I’d probably find that useful.
22:16:14 <adit> okie
22:17:41 <Enigmagic> if you do get a draft up i'd be happy to review it and provide feedback
22:18:04 <Enigmagic> i have too many other posts i'm working on right now or i'd try to help more :-/
22:18:36 <adit> Cool. I'll post something once I figure this stuff out
22:18:42 <adit> It'll be a while :P
22:19:08 <Enigmagic> are you having trouble with something in particular?
22:21:13 <adit> Not really. I'm trying to sort through all the various new types they introduce so that I can create a basic hello world
22:21:33 <adit> I have something that works, but it's not pretty
22:21:48 <ex-parrot> is anyone around familiar with the System.USB module?
22:22:15 <adit> And it's taking me a while to figure out what it's doing
22:22:38 <Enigmagic> adit: what part of it?
22:23:25 <hpaste> adit pasted “hello world example” at http://hpaste.org/64770
22:23:54 <adit> Here I've defined print as a haskell function called mkPut
22:24:08 <adit> erm
22:24:16 <adit> wait, wrong snippet :/
22:24:51 <hpaste> adit pasted “hello world example #2” at http://hpaste.org/64771
22:25:15 <latros> probably a stupid question, but any idea why this doesn't typecheck:
22:25:17 <adit> this is taken from augustss's blog
22:25:33 <hpaste> latros pasted “takebetween” at http://hpaste.org/64772
22:25:37 <adit> so, I pass in the puts function in to _main and use it to print out "hello world"
22:25:47 <adit> I was trying to combine the two into one function
22:25:59 <latros> it complains about an infinite type in the last argument of helper
22:26:05 <adit> And I don't think I can?
22:26:23 <latros> oh
22:26:28 <latros> dropPast :: a -> [a] -> [a]
22:26:31 <latros> kinda necessary
22:26:33 <ex-parrot> I'm trying to work out if there are any gotchas in the way this snippet calls libusb: https://github.com/tuxmark5/EnableRazer/blob/de12c3f71b814e6ae0faef06457902acedb6e492/src/Main.hs
22:31:54 <hpaste> Enigmagic annotated “hello world example #2” with “hello world example #2 (annotation)” at http://hpaste.org/64771#a64773
22:32:07 <latros> uh
22:32:10 <latros> ok now I'm really confused
22:32:32 <hpaste> latros pasted “takebetween” at http://hpaste.org/64774
22:32:45 <latros> that (which doesn't even try to do what I want, but oh well) still doesn't typecheck
22:32:56 <latros> ...
22:32:58 <latros> nvm
22:33:01 <latros> () around list patterns
22:33:03 <latros> carry on
22:33:33 <shachaf> That's not a pattern, but yes.
22:33:41 <latros> well
22:33:44 <latros> "patterns"
22:33:53 <latros> I was thrown off because I thought it was only necessary in patterns
22:33:58 <latros> which...was silly
22:33:59 <latros> ofc
22:34:05 <latros> due to the fixity
22:34:56 <Enigmagic> adit: you may need to jiggle the withStringNul function around (i have a modified version of the llvm-bindings) but that should work otherwise
22:34:56 <hpaste> adit annotated “hello world example #2” with “hello world example #2 (annotation) (error)” at http://hpaste.org/64771#a64775
22:35:40 <adit> that's the error I've been running into...got it with that annotated version too
22:35:44 <Enigmagic> adit: what compiler and llvm package version are you using?
22:36:10 <adit> ghc v 7.0.4, llvm package: most recent, llvm v 2.9
22:38:26 <hpaste> Enigmagic annotated “hello world example #2” with “hello world example #2 (annotation) (annotation)” at http://hpaste.org/64771#a64776
22:38:44 <Enigmagic> adit: does that help? i recall errors like that on 7.0.x ... doesn't seem to happen on 7.4.1
22:40:20 <hpaste> adit annotated “hello world example #2” with “hello world example #2 (annotation) (annotation) (annotation) (error)” at http://hpaste.org/64771#a64777
22:40:39 <adit> Well, it's a different error than the one I've been seeing, so that's progress
22:41:10 <Enigmagic> ok, that fixed the original error
22:41:55 <adit> yup. I'm installing ghc v 7.4 on one of my spare boxes, going to see if this code compiles on that
22:42:21 <Enigmagic> well the current problem is because i have modified llvm bindings that allow you to add string literals within a function
22:45:02 <adit> oh I see
22:47:19 <hpaste> Enigmagic annotated “hello world example #2” with “hello world example #2 (annotation) (annotation) (annotation)” at http://hpaste.org/64771#a64779
22:47:30 <Enigmagic> adit: try that, kinda ugly but whatever :P
22:48:13 <adit> holy crap
22:48:15 <adit> that worked
22:48:16 <adit> !!
22:49:19 <Enigmagic> adit: i prefer to write string literals within a function so i made a patch a while ago {-# LANGUAGE ScopedTypeVariables #-}
22:49:20 <Enigmagic> import Data.Word
22:49:20 <Enigmagic> import LLVM.Core
22:49:20 <Enigmagic> import LLVM.ExecutionEngine
22:49:20 <Enigmagic> _main :: CodeGenModule (Function (IO ()))
22:49:20 <Enigmagic> _main =
22:49:20 <Enigmagic>   withStringNul "hello world" $ \greetz ->
22:49:21 <Enigmagic>     let body :: CodeGenFunction () Terminate
22:49:21 <Enigmagic>         body = do
22:49:22 <Enigmagic>           puts :: Function (Ptr Word8 -> IO ()) <- externFunction "puts"
22:49:22 <Enigmagic>           tmp <- getElementPtr greetz (0 :: Word32,(0 :: Word32, ()))
22:49:23 <Enigmagic>           call puts tmp
22:49:23 <Enigmagic>           ret ()
22:49:24 <Enigmagic>     in createNamedFunction ExternalLinkage "main" body
22:49:25 <Enigmagic> asdfasdf
22:49:25 <Enigmagic> crap
22:49:52 <Enigmagic> i meant to link to this :( https://github.com/alphaHeavy/llvm/commit/05465f4f44626269ebc7af527df650ab5651e005
22:50:41 <dp_wiz> I have a Text.Blaze.ToHtml instance FormField which makes a Html.input and a bunch of [FormField]s which i want to render inside some other block. How do i squash a [FormField] into a single Html?
22:51:52 <adit> oh, I see. Hmm, I think I'll borrow that
22:53:33 <adit> Thanks a lot for your help!
22:54:28 <Enigmagic> np, it was a bit painful to figure this stuff out the first time around :)
22:55:03 <adit> yeah, I bet
22:59:00 <cizra> hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
22:59:16 <cizra> -- how do I ignore these errors? I just want to do some byte-pushing and I don't really care about encodings.
23:00:03 <Enigmagic> :t hSetEncoding
23:00:04 <lambdabot> Not in scope: `hSetEncoding'
23:00:19 <Enigmagic> @hoogle hSetEncoding
23:00:20 <lambdabot> System.IO hSetEncoding :: Handle -> TextEncoding -> IO ()
23:00:20 <lambdabot> GHC.IO.Handle hSetEncoding :: Handle -> TextEncoding -> IO ()
23:00:52 <Enigmagic> err no
23:00:55 <xelxebar> #C
23:00:59 <Enigmagic> @hoogle hSetBinaryMode
23:00:59 <lambdabot> System.IO hSetBinaryMode :: Handle -> Bool -> IO ()
23:00:59 <lambdabot> GHC.IO.Handle hSetBinaryMode :: Handle -> Bool -> IO ()
23:01:04 <xelxebar> whoops, sorry
23:01:40 * hackagebot xturtle 0.1.0 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.0 (YoshikuniJujo)
23:02:33 <cizra> Thanks, I'll read up on those.
23:11:58 <mhink> I just want to announce something to the world: I'm finally starting to understand monads!
23:12:42 <cizra> Hmm, just monoids in the category of endofunctors, what's to understand there...
23:13:13 <cizra> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
23:15:57 <latros> cizra--random question, why are you not in #lojban
23:16:00 <latros> given your name
23:16:28 <latros> (if your name does not come from lojban, I am completely baffled, but ignore me nonetheless)
23:17:08 <shachaf> latros: cizra is in #jbopre
23:17:23 <latros> ah
23:17:26 <latros> nvm then
23:17:48 <cizra> hehe
23:25:41 <dp_wiz> Is there a happstack "look"-like method which gives a Maybe result?
23:27:47 <dp_wiz> Ah. I guess i could use looks which gives a List result, that is also a monad...
23:29:23 <covi> I can't analyze the time complexity of my Haskell codes. Can someone help?
23:33:13 <Sgeo_> : listToMaybe
23:33:16 <Sgeo_> :t listToMaybe
23:33:18 <lambdabot> forall a. [a] -> Maybe a
23:37:54 <ktklam9> hi, I'm writing a library that depends on liblbfgs, an external C-library, I expect the user to have previously installed liblbfgs, how can I state this dependency in cabal and how can I ensure that the user won't have to manually point to liblbfgs static library when compiling their program?
23:38:18 <int-e> covi: it's better to assume the answer is "yes" and state your problem.
23:40:06 <latros> why does deleteBy not just take an a->Bool
23:40:09 <latros> >.<
23:40:44 <ivanm> latros: filter (not . p) ?
23:40:55 <ivanm> ktklam9: you can use pkg-config in your .cabal file
23:40:57 <latros> that's slower for this
23:41:16 <latros> I want it to blindly assume that everything after the found object satisfies the predicate
23:41:23 <latros> because my list is big and the test is expensive
23:41:23 <ivanm> OK
23:41:36 <ivanm> @hoogle (a -> Bool) -> [a] -> [a]
23:41:41 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
23:41:41 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
23:41:41 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
23:41:51 <ivanm> @type deleteBy
23:41:52 <ktklam9> ivanm: liblbfgs does not come with its own pkg-config file
23:41:52 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
23:42:06 <latros> deleteBy inexplicably passes the second argument to the first argument
23:42:14 <latros> which could easily be done with currying in an a->Bool
23:42:25 <covi> int-e: I'm thinking if there's a quick reference list that contains complexities for common functions in Haskell
23:42:34 <ivanm> yay, my parsers are failing seemingly to some junk at the end of the input file...
23:43:10 <latros> it'd make more sense to have deleteBy p (x:xs) = if p x then xs else x : deleteBy p xs
23:43:16 <latros> (plus the obvious base case)
23:43:27 * latros makes a deleteBy' >.>
23:43:49 <ivanm> @src deleteBy
23:43:49 <lambdabot> deleteBy eq x []        = []
23:43:49 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
23:44:02 <ivanm> yeah, that is a bit weird
23:44:21 <latros> and it doesn't match find
23:44:33 <latros> @src find
23:44:33 <lambdabot> find p          = listToMaybe . filter p
23:44:42 <latros> ...well that was lazy
23:44:56 <latros> lazy and efficient, ofc, but still lazy
23:46:13 <ddarius> @src delete
23:46:13 <lambdabot> delete = deleteBy (==)
23:46:37 <latros> I could see deleteBy being defined like that to make the definition of delete a little cleaner
23:46:39 <latros> but
23:46:42 <latros> eh
23:48:50 <ddarius> @src nub
23:48:50 <lambdabot> nub = nubBy (==)
