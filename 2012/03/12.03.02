00:00:16 <randomclown> what are the pros and cons of data.vector
00:01:07 <mzero> ? relative to? IntMap?
00:01:15 <randomclown> yeh
00:01:22 <mzero> well, they are arrays and O(1) indexing for lookup
00:01:25 <mzero> for starters
00:01:39 <mzero> the unboxed versions are efficient, and strict  which for a z-buffer I imagine you want
00:01:47 <randomclown> is it O(n) for write or O(1)
00:02:05 <mzero> well - look at Data.Vector.Unboxed.Mutable.Safe
00:02:15 <mzero> I don't know how you are managing these z-buffers,
00:02:34 <mzero> so there isn't just one answer for writing
00:02:51 <randomclown> access to see if point is occupied, if it the new point's value is smaller, replace the entry
00:04:15 <mzero> well, if, for example, you were doing that over the whole buffer in sequence, it might be better to compute the z-buffer of the two images, and then write the merge that produces a new image & z-buffer in one go -
00:04:41 <mzero> never modifying the inputs
00:05:16 <randomclown> I have a function that generates a set of points and uses the zbuffer to see which point is visible
00:05:26 <shirt> but if you are rendering, say, a bunch of triangles into the zbuffer, then you are probably going to want to modify the zbuffer in place (mutable)
00:18:15 <germanyboy24> http://xeducation.info/2012/02/young-italian-nimfo-teens-loves-group-sex-adolescenza-perversa-italian/
00:19:43 <Sgeo> Uh
00:20:07 <Sgeo> Oh, spammer. Thought it was a mispaste.
01:17:14 <srhb> I'm reading a binary format which has an endian indicator, and I don't understand how to handle it. The format states that it consists of two bytes, the characters MI, and if I read them as IM, I need to use "byte swapping". I suppose this means I will have to read integer values as either little endian or big endian, but which is it? This is confusing.
01:18:05 <mauke> which binary format?
01:19:19 <srhb> MAT5
01:19:33 <srhb> It is a Matlab export format.
01:21:01 <srhb> What I think I have to do is read this endian indicator, conclude that it is interpreted as IM, not MI, and based on this, my program needs to read things with big-endianness or little-endianness, but I'm not sure which or how.
01:22:17 <mauke> yeah, the matlab coders are stupid assholes, apparently
01:22:54 <Sgeo> srhb, perhaps if you ... hmm
01:23:16 <srhb> mauke: Because they allow the format to be saved as either depending on the machine architecture?
01:23:21 <Sgeo> srhb, maybe it means try reading them in one endianness, and if you get it wrong, try the other? But can characters even swap like that?
01:23:30 <Sgeo> With endianness? I thought it would be per character.
01:23:30 <mauke> srhb: no, because the file format spec makes no fucking sense
01:23:39 <srhb> mauke: Oh? It seems to make sense to me.
01:23:47 <srhb> Except I don't know what to do here :-)
01:23:49 * Sgeo looks at an ASCII table
01:23:50 <srhb> Sgeo: Looks like it!
01:23:54 <mauke> srhb: exactly
01:24:11 <srhb>  endian  <- getBytes 2 <-- when I show this, I get "IM"
01:24:13 <mauke> "Endian Indicator    Contains the two characters, M and I, written to the MAT-file in this order, as a 16-bit value."
01:24:16 <mauke> you're fired
01:24:21 <srhb> lol
01:24:47 <srhb> Is it really that bad? I guess I'm not experienced enough to be able to form an opinion on it. :-)
01:24:53 <Sgeo> But ... how can endianness flip the order of the characters?
01:24:55 <srhb> Except that it's really annoying right now
01:25:09 <Enigmagic> srhb: read it in as a 16 bit value and compare it
01:25:20 <srhb> Enigmagic: Read what it?
01:25:21 <mauke> Enigmagic: to what?
01:25:28 <srhb> in*
01:25:36 <Enigmagic> mauke: to 'IM' or 'MI'
01:25:46 <Enigmagic> is how you'd do it in C :)
01:25:47 <mauke> Enigmagic: that's a syntax error
01:25:51 <mauke> and no, it isn't
01:25:55 <srhb> Well I know that Haskell sees "IM"
01:25:59 <mauke> because the value of 'IM' is implementation defined
01:26:00 <Enigmagic> sure it is
01:26:07 <mauke> so that still doesn't mean anything
01:26:12 <Sgeo> srhb, try using the other endianness and seeing if it comes out as MI
01:26:12 <srhb> Now the question is, how does my code have to handle this flip from this point
01:26:22 <mauke> Sgeo: what
01:26:26 <srhb> Sgeo: Huh?
01:26:39 <Enigmagic> Sgeo: he's reading it a byte array, not an integer
01:26:39 <mauke> srhb: I'd say generate a sample file with known values
01:26:41 <Enigmagic> which is the problem
01:26:49 <mauke> and then see what the format really is
01:27:12 <Enigmagic> srhb: if you're using a library like binary or cereal, read in a host-endian 16-bit integer
01:27:26 <srhb> I can use getWord16le or getWord16be
01:27:29 <srhb> Does that help?
01:27:40 <mauke> or you could google it
01:27:46 <srhb> Google what?
01:27:48 <Sgeo> Try using one then the other and see which works?
01:28:00 <Enigmagic> srhb: like getWord16host
01:28:01 <mauke> srhb: THE ENDIANNESS OF THE FILE FORMAT
01:28:04 <mauke> god dammit
01:28:18 <Sgeo> Then from there work out what you need to do to do the comparison and use the correct thing programmatically
01:28:19 <Enigmagic> mauke: it's variable
01:28:27 <mauke> Enigmagic: GEE REALLY
01:28:28 <srhb> mauke: Calm down. How would googling help that when the definition specifically states that the host machine will save it in whatever format the saving machine is in?
01:28:42 <mauke> srhb: where does it state that?
01:28:47 <Enigmagic> mauke: there isn't an endianness of the file
01:28:48 <srhb> I forget.
01:28:51 <srhb> Somewhere in the pdf
01:29:07 <Enigmagic> mauke: of the file format rather, it's per file.
01:29:24 <mauke> Enigmagic: and what is the endianness of a particular file?
01:29:32 <srhb> "Note Programs that create MAT-files always write data in their native
01:29:32 <srhb> machine format. Programs that read MAT-files are responsible for
01:29:32 <srhb> byte-swapping."
01:29:35 <srhb> Oops, sorry.
01:29:37 <srhb> Bad paste.
01:30:02 <srhb> It is right under the specification for the endian indicator field.
01:30:04 <Enigmagic> mauke: it's either little or big, depending on the first two characters
01:30:10 <mauke> Enigmagic: and which is it?
01:30:17 <Enigmagic> mauke: it depends on the file.
01:30:25 <srhb> This is very productive. :-)
01:30:30 <mauke> Enigmagic: depends how?
01:30:36 <Sgeo> Does M byte-flipped become I by any chance?
01:30:39 <Sgeo> I mean, I doubt it
01:30:42 <mauke> Sgeo: that makes no sense
01:30:48 <Sgeo> bit-flipped
01:30:54 <Sgeo> But yeah
01:30:54 <Enigmagic> mauke: the person writing the file gets to choose the endianness
01:31:06 <mauke> Enigmagic: missing the fucking point
01:31:15 <mauke> Enigmagic: given a file, how do you determine the endianness?
01:31:31 <Enigmagic> mauke: by reading the first two bytes as a 16-bit integer and comparing it against two constants
01:31:33 <srhb> By looking at host endianness and then MI
01:31:38 <srhb> If I get MI host and file is the same
01:31:42 <srhb> if IM, host and file are different
01:31:44 <mauke> Enigmagic: wrong
01:31:50 <mauke> srhb: unlikely
01:31:55 <Enigmagic> mauke: oh?
01:32:02 <Enigmagic> how do you do it then?
01:32:04 <srhb> mauke: Based on what?
01:33:10 <mauke> srhb: on that description making no sense
01:33:24 <srhb> mauke: Why doesn't it make sense?
01:33:48 <mauke> "By looking at host endianness and then MI" - what does this mean?
01:35:07 <Enigmagic> srhb: anyways, i'd just call getWord16host and compare the result against 0x4D49 ('MI') or 0x494D ('IM')
01:35:08 <srhb> mauke: Well, let's try to work it out together? First, I read those two bytes as a ByteString. Then I show that Bytestring. I get IM. But the machine that wrote it wrote "MI", and I'm getting the different result because we're on different endianness, right?
01:36:14 <srhb> Enigmagic: I get 4d49. Hm.
01:36:15 <mauke> srhb: yes/no/what
01:36:31 <Enigmagic> srhb: there ya go
01:36:32 <mauke> Enigmagic: how did you come up with 0x4d49 == MI?
01:36:47 <srhb> mauke: You're being useless and frustrated because you're either unable or unwilling to explain what I say makes no sense. Thanks for the help anyway. :)
01:36:57 <Enigmagic> mauke: https://gist.github.com/933e3a0a5ba610b31dae
01:37:26 <mauke> Enigmagic: did you miss the part where multi-character constants have implementation defined values?
01:37:44 <Enigmagic> mauke: yeah, i'm relying on my knowledge of the compiler to get the correct result
01:37:56 <mauke> how do you know which result is correct?
01:38:03 <Enigmagic> experience
01:38:06 <mauke> what
01:39:09 <mauke> srhb: the first byte of the endianness field is either 'M' or 'I'. one of these means little endian, the other big endian. the only question is which is which
01:39:41 <mrothe> Hello, snap init generates this: http://paste.pocoo.org/show/559629/ In line 71 it sais 'getActions. Where does the ' come from and what does it do?
01:39:42 <mauke> and if the file format doesn't work this way you're screwed anyway
01:39:57 <srhb> mauke: As I understand it, you read it "as if" host endianness, and if you do NOT get MI, then the endianness of the file is strictly opposite of the host endianeness. Why does this not make sense?
01:40:12 <mauke> srhb: because MI is not a number
01:40:31 <mauke> srhb: also that's overly complicated
01:40:33 <srhb> It says it is.
01:40:36 <mauke> yes
01:40:38 <srhb> It says it's a 16 bit int.
01:40:40 <mauke> yes
01:40:47 <srhb> So it is a number.
01:40:52 <mauke> no
01:40:54 <Enigmagic> srhb: do you have a working solution now? :)
01:40:58 <srhb> Care to explain that step?
01:41:19 <srhb> Enigmagic: Well, apparently it matches host-endianness, but I have to figure out how to get my program to act accordingly if it bumps into a file which does not.
01:42:44 * shachaf peeks in #haskell, wonders what's going on.
01:42:57 <shachaf> Either people are abusing mauke or mauke is abusing people.
01:43:01 <shachaf> I can't figure out which. Maybe both.
01:43:21 <srhb> So I have to make some kind of decision. I guess the simple solution is to get the "opposite" of getWordxxHost and... alias it
01:43:24 <srhb> Or somesuch.
01:44:25 <shachaf> srhb: I think mauke might be saying that the first byte of the file is either 'M' or 'I', and one of them means "little-endian", and the other means "big-endian".
01:44:35 <shachaf> Do you know which one means which?
01:44:38 <srhb> Which is false
01:44:42 <shachaf> srhb: Why is that false?
01:45:04 <srhb> Well, according to the spec it is at least. But yes, we've had no concrete suggestion as to why it works
01:45:16 <shachaf> Why is it false according to the spec?
01:45:20 <shachaf> What does the spec say?
01:45:26 <srhb> Contains the two characters, M and I, written to the MAT-file in this order, as a 16-bit value. If, when read from the MAT-file as a 16-bit value, the characters appear in reversed order (IM rather than MI), it indicates that the program reading the MAT-file must perform byte-swapping to interpret the data in the MAT-file correctly.
01:45:33 <Enigmagic> shachaf: the first two bytes need to be interpreted as a 16-bit integer, and if the value is == 0x494D then it's in host order and if it's not then it's in the opposite order
01:45:50 <mauke> how does that contradict what I said?
01:46:07 <srhb> I don't know if it does, but it contradicts what schachaf said.
01:46:14 <shachaf> OK, so if the first byte is 'M' then it'll be little-endian?
01:46:18 <mauke> srhb: how so?
01:46:22 <srhb> Then it'll be host-endian
01:46:23 <srhb> Whatever that is
01:46:29 <shachaf> What?
01:46:32 <Enigmagic> mauke: this statement is wrong:
01:46:36 <Enigmagic> <mauke> srhb: the first byte of the endianness field is either 'M' or 'I'. one of these means little endian, the other big endian. the only question is which is which
01:46:44 <mauke> Enigmagic: how is it wrong?
01:46:54 * shachaf reads further up.
01:46:59 <Enigmagic> mauke: because the absolute endianess doesn't matter
01:47:05 <thom_logn> howdy
01:47:09 <srhb> That is how I understand it as well.
01:47:12 <mauke> Enigmagic: everything is in "absolute endianness"
01:47:14 <Enigmagic> it's host-order vs not-host-order
01:47:25 * shachaf tries to figure out what "MI" means.
01:47:29 <mauke> your host has an absolute endianness
01:47:33 <mauke> shachaf: good luck
01:47:42 <shachaf> Is it a number?
01:47:45 <Sgeo> What are the actual bits of M and I?
01:47:54 <Enigmagic> shachaf: it's two ascii characters
01:48:05 <thom_logn> If I am implementing an Ord instance on a type with two value constructors does that mean I have to match to all 4 possible orderings?
01:48:36 <shachaf> Does endianness affect the order of two ASCII characters?
01:48:37 <mauke> thom_logn: why not just derive Ord?
01:48:37 <Enigmagic> mauke: yes it does, but the application reading the file only needs to know if it needs to byte-swap while reading
01:48:41 <mauke> shachaf: no
01:48:48 <Enigmagic> shachaf: yes
01:48:52 <mauke> Enigmagic: how does that contradict what I said?
01:49:13 <Enigmagic> mauke: nobody needs to know if it's in big-endian or little-endian
01:49:15 <mauke> also "needs to byte-swap" assumes a particular storage format for numbers
01:49:21 * shachaf no longer knows what any of y'all're talking about.
01:49:30 <mauke> yay, found sample C code
01:49:45 <mauke> endian = 0x4d49; fwrite(&endian, 2, 1, mat->fp);
01:50:09 <mauke> M means big endian, I means little endian
01:50:12 <mauke> problem solved
01:50:16 <shachaf> So MI means 0x4d49 and IM means 0x494d?
01:50:37 <thom_logn> data MyType a = Datum a | MyType MyType MyType. can derive do something sensible with that?
01:50:48 <alang_> Is there anyone who has used both the plot and Chart packages and can comment on their differences?
01:50:49 <mauke> thom_logn: yes
01:51:39 <mauke> thom_logn: well, assuming you mean MyType (MyType a) (MyType a)
01:51:45 <Enigmagic> shachaf: yeah, they're the ascii values
01:51:45 <thom_logn> data MyType a = Datum a | MyType a MyType MyType.  <=== typoed. Need to compare based on a field in MyType constructor
01:51:52 <thom_logn> yes, sorry
01:51:57 <thom_logn> that's what I meant
01:52:00 <Enigmagic> shachaf: with one character shifted over by a byte
01:52:08 <Enigmagic> and or'd together
01:52:39 <Sgeo> MI is 0100110101001001 and IM is 0100100101001101
01:52:42 <shachaf> Enigmagic: I would assume that "MI" means something the two bytes {0x4D, 0x49} in memory in that order.
01:52:53 <mauke> shachaf: yes, but that would be sensible
01:53:06 <mauke> the authors of the MAT5 spec are not sensible
01:53:19 <efie> hello, could anybody tell me how to fix 2 errors I get? http://hpaste.org/64643 I don't know what I am doing wrong
01:53:24 <Enigmagic> shachaf: yea
01:53:35 <quicksilver> well the authors of the spec are confused about what endianness means and made a failed attempt to explain it in a "simple" way.
01:53:48 <Sgeo> How does endianness affect stuff again?
01:54:01 <srhb> Sgeo: It breaks my numbers! :-(
01:54:02 <quicksilver> I think they really meant to say "the first 16-bit number in the file is always 0x4d49; by reading this number you can deduce the endianness of the file"
01:54:06 <Enigmagic> shachaf: so you can have a constant 'MI' that will either be 0x4D49 or 0x494D in memory, depending on the endianness of the processor
01:54:06 <efie> ( kontaktStore  = contactStore )
01:54:07 <mauke> efie: your type signature is wrong
01:54:34 <efie> ah, IO (ListStore Entry)=
01:54:34 <mauke> Enigmagic: that is wrong
01:54:34 <srhb> quicksilver: That's what they say though, albeit in a complicated manner.
01:54:40 <quicksilver> srhb: no, actually they don't
01:54:45 <quicksilver> srhb: they say something stupid and wrong.
01:54:45 <srhb> quicksilver: Oh?
01:54:52 <shachaf> mauke: Why is that wrong?
01:55:06 <quicksilver> "MI" can only possibly be taken to mean 0x4d 0x49, in that order.
01:55:09 <shachaf> If you interpret an address in memory tha contains those two bytes as 2-byte integer.
01:55:10 <srhb> quicksilver: I don't understand that. The two characters in that order means exactly the number that you said, does it not?
01:55:14 <mauke> shachaf: because (assuming we're talking about C) 'MI' could have any value, including 42
01:55:15 <efie> mauke: thanks
01:55:16 <quicksilver> the order of byes in a string is the order of bytes in a string.
01:55:17 <Enigmagic> quicksilver: i said 'MI', which is not a string
01:55:20 <shachaf> mauke: Fair enough. :-)
01:55:25 <quicksilver> endianness does not affectthe order of bytes in a string.
01:55:49 <Enigmagic> shachaf: it's a non-portable way of writing integer constants, gcc and msvc (and most compilers) do the same thing though
01:55:49 <srhb> Alright, fair enough, they should have written the number instead, but it was obvoius (to some of us) what they meant.
01:55:51 <shachaf> quicksilver: We're not talking about C but about some strange spec (apparently).
01:56:05 <mauke> Enigmagic is talking about C
01:56:05 <quicksilver> Enigmagic: you did say that. I don't recall multichar constans being standard, but what people quoted from the spec did not use a multichar constant.
01:56:28 <mauke> srhb: if it was obvious, why did you have to ask?
01:56:32 <quicksilver> srhb: it was pretty clear how to guess what they meant, yes.
01:56:44 <quicksilver> but it was more clear that it was nonsense.
01:56:57 <quicksilver> and that the only way to be sure would be to check some C source or just examine some files.
01:56:59 <srhb> mauke: I asked how to deal with this information and how to read integers afterwards, and you started swearing at Matlab programmers and us. :-)
01:57:19 <srhb> I also made the mistake of reading it as a bytestring which was nonsensical
01:57:24 <srhb> Probably based on the bad wording, too.
01:57:28 <Enigmagic> quicksilver: alrighty
01:57:58 <mauke> srhb: "I don't understand how to handle it. ...  I suppose this means I will have to read integer values as either little endian or big endian, but which is it? This is confusing."
01:58:17 <srhb> mauke: Indeed.
01:59:34 <mauke> do x <- readThatByte; let { myWord16Reader = if x == 'M' then readWord16BE else readWord16LE }; ...
01:59:37 <mauke> or something
02:00:04 <srhb> But it is way clearer now. I simply read it as either endian, if I get 0x4D49 I stick with that endianness, otherwise I switch. Right?
02:00:28 <srhb> Or the first byte would work too, yes.
02:01:00 <Enigmagic> you'd need to look at both bytes to verify it is one of the known constants and not 42 ;)
02:02:07 <mauke> yeah, that would probably be a good sanity check
02:02:25 <shachaf> This channel is long overdue for a few sanity checks.
02:02:36 <mauke> ooh, I like how the version number comes first but is stored in variable endian format too
02:02:43 <srhb> mauke: I was just thinking about that too :P
02:02:48 <srhb> That is quite idiotic.
02:02:59 <srhb> In fact, why is the endianness not in front of _everything_?
02:03:07 <srhb> endianness indicator*
02:03:19 <efie> is it  in the sense of functional programming to for example use the ListStore from Graphics.UI.Gtk.ModelView.ListStore? I mean there are functions which change the state of this Store (for example listStoreAppend) and don't return a new Store
02:03:34 <Enigmagic> srhb: common problem...
02:03:49 <mauke> <mauke> yeah, the matlab coders are stupid assholes, apparently
02:04:19 <srhb> Well at least there's a fixed address for the endianness indicator. Otherwise it would be really bad.
02:04:55 <mauke> (all my tolerance for stupid file formats was used up in writing a swf->abc->disassembler)
02:05:29 <augur> @tell edwardk your lens talk has gotten me interested in actually learning about lenses in haskell <3
02:05:29 <lambdabot> Consider it noted.
02:08:15 <srhb> Heh, okay, actually, I'm still unsure on how to do the actual picking. Or did we come to the conclusion that if I read MI (whatever the number was) I know the absolute endianness of the file?
02:08:33 <mauke> <mauke> do x <- readThatByte; let { myWord16Reader = if x == 'M' then readWord16BE else readWord16LE }; ...
02:08:34 <srhb> Because I have getWord32host and company, but I don't have getWord32notHost
02:08:42 <mauke> where "that byte" is the first byte of the endianness field
02:08:54 <srhb> Did you pick BE and LE arbitrarily there?
02:08:58 <mauke> no
02:09:02 <mauke> wtf
02:09:57 <Sgeo> mauke, shouldn't the one you use depend on being the opposite of host?
02:10:01 <srhb> Indeed.
02:10:05 <mauke> Sgeo: no
02:10:10 <srhb> lol, we're back to relative vs. absolute endianness now.
02:10:21 <mauke> this is stupid
02:10:23 * shachaf has the strangest sense of déjà vu.
02:10:24 * mauke leaves
02:10:34 <Enigmagic> Sgeo: there are two ways of doing it, they're both equally correct but one may be easier to implement than the other.
02:10:56 <Sgeo> Does readThatByte have a specific endianness?
02:11:39 <srhb> It should not
02:11:52 <Enigmagic> Sgeo: bytes don't have an endianness
02:12:37 <srhb> This discussion has cleared up nothing. Should be simpler to test it. I need an opposite-endian system. :-)
02:13:16 <quicksilver> Enigmagic: bytes might indeed have an endianness, but the nature of "readbyte" is that it can't observe them.
02:13:39 <quicksilver> and since both protocols and files are traditionally specified at the level of bytes, the endianness of the bits is abstract.
02:13:55 <quicksilver> if you have a bit-level file format (like some compression formats) then byte-endianness assurredly matters.
02:13:56 <Phlogistique> quicksilver: what does "endianness" mean for bytes
02:13:56 <shachaf> quicksilver: Bits in a byte might also be arranged in a hexagon for all you care.
02:14:07 <Phlogistique> yes, that
02:14:12 <shachaf> That's true, though.
02:14:17 <quicksilver> shachaf: quite. bit it means something relative to a data considered as a bitstream.
02:14:24 <quicksilver> shachaf: if you ever chose to consider data as a bitstream.
02:14:31 <quicksilver> which you don't have to. it's quite permitted to abstract that away.
02:14:32 <Phlogistique> indeed
02:14:34 <shachaf> But that's defined on top of bytes as a primitive, sort of.
02:14:41 <quicksilver> in practice, yes.
02:14:46 <shachaf> Right.
02:14:57 <quicksilver> however older computers permitted some nibble-access which made byte-endianness something you could observe
02:15:02 <quicksilver> or so I believe I recall.
02:15:14 <quicksilver> BCD in nibbles.
02:15:26 <shachaf> Reasonable enough.
02:15:36 <srhb>  ... endian <- getWord16le;  return $ endian == 19785
02:15:51 <srhb> Does that check make sense?
02:15:56 <quicksilver> shachaf: I note that bytes in a Word48 could be arranged in a hexagon for all we cared, *if* we considered our data as Word48-streams.
02:15:59 <srhb> 19785 is the number in question, should it should, I think.
02:16:02 <shachaf> Bytes might also not be octets in C.
02:16:05 <shachaf> quicksilver: Right.
02:16:27 <quicksilver> shachaf: it's just an (almost universal) convention that we treat everything as byte streams, and everything below the byte is therefore abstract w.r.t. how it is stored/sent/received.
02:16:53 <shachaf> quicksilver: Yes, you are correct.
02:20:06 <Phlogistique> quicksilver: you would be able to observe byte endianness if you were writing some microcode for a serial bus controller
02:20:10 <Phlogistique> *bit endianness
02:20:15 <Phlogistique> for example
02:20:37 * quicksilver nods at Phlogistique 
02:21:26 <shachaf> Or in compression formats taht are defined over bitstreams, as quicksilver pointed out.
02:21:40 <shachaf> Which might be more common. :-)
02:23:03 <hpaste> srhb pasted “Endianness sucks. Both kinds!” at http://hpaste.org/64644
02:23:10 <srhb> Does the above make sense?
02:26:13 <srhb> Doh, I've worn out the patience of #haskell. :-) I deserve a prize, really.
02:26:28 <mauke> no, you've worn out my patience
02:26:43 <mauke> "Magic that no one understands." why, thank you
02:26:43 <Phlogistique> srhb: 0x4d49 would be nicer than 19785, I think
02:26:55 <srhb> mauke: I think I did that by even bringing up the subject. But sure, it is me that does not understand it.
02:27:07 <srhb> Phlogistique: Ok :)
02:31:11 <zhulikas> srhb, me neither
02:31:45 <srhb> At least I'm not alone in my ignorance. :-) But at least I'm fairly confident in this solution.
02:31:55 <srhb> (for no reason other than #haskell being confident in it)
02:58:07 <ziman> this is weird. In my definition of pipeToString, "(chunk ++) <$> pipeToString pipe" deadlocks while "do { rest <- pipeToString pipe; return (chunk ++ rest) }" does not. I'd expect these two expressions to be equivalent.
02:58:50 <quicksilver> they look equivalent to me
02:59:02 <quicksilver> are you quite sure?
03:01:04 <shachaf> If they're not equivalent your Monad/Functor instance seems to be broken.
03:04:26 <ziman> you're right, the reason is probably a race condition that happened to correlate with my source code edits (the deadlock reappeared now after deleting a comment)
03:11:17 <efie> how can i create a .txt file? i cannot find a method in http://hackage.haskell.org/packages/archive/directory/1.0.0.0/doc/html/System-Directory.html#1
03:13:26 <adimit> I'm curious: is there a way of my program "knowing" which git commit it was built from? Ideally, cabal would bail on dirty indexes, and otherwise set some exported values to the SHA1 hash of HEAD.
03:14:41 <irene-knapp> Cabal doesn't currently have that feature
03:14:52 <adimit> irene-knapp: do you think one could hack in via Setup.hs?
03:14:58 <ziman> efie, writeFile is the simplest way, if you have the content ready as a String
03:15:13 <irene-knapp> it does have a similar feature for making the version number from the .cabal file available to the program, so yes, it could be done in principle
03:15:26 <adimit> irene-knapp: oh, well, that'd already be rather nice.
03:15:28 <irene-knapp> I think Setup.hs would be the harder route compared to writing a patch
03:15:30 <irene-knapp> yeah
03:15:48 <adimit> … ah, I don't really have time for very expensive hacks right now.
03:15:52 <irene-knapp> yeah
03:15:59 <adimit> I was wondering if there'd be an "easy" way to do it.
03:16:07 <irene-knapp> there isn't really, no
03:16:12 <adimit> irene-knapp: thanks for your help!
03:16:16 <irene-knapp> np!
03:17:17 <efie> ziman: thanks! I didn't guess from the description that a new file is created
03:17:23 <efie> if there is no existing one
03:19:19 <thom_logn> if I'm going to define an instance on the Num class do I need to define all the functions in the interface or just the ones I use?
03:21:04 <thom_logn> it's telling me "Occurs check: cannot construct the infinite type: a = Thing a" and I can't figure out what that means
03:21:53 <ziman> efie, I think this is a universal property of file-opens in write mode in most languages
03:22:03 <adimit> thom_logn: it's basically a type error. You're trying to recursively define a type (or, more likely, you've made a mistake somewhere and the type inference algorithm is trying to construct a recursive type.) It'd be nice if you could post your code so we could have a look at it.
03:22:26 <adimit> it has nothing to do with not defining all functios in an instance.
03:22:42 <thom_logn> what us pastebot url?
03:22:46 <thom_logn> is
03:22:48 <adimit> hpaste.org
03:23:10 <adimit> In fact, most of the time, there's default implementations of many instance functions. Refer to the docs to find out.
03:23:53 <hpaste> thom_logn pasted “my thing” at http://hpaste.org/64650
03:24:06 <timthelion> why isn't x == True ? http://hpaste.org/64649
03:25:06 <Saizan> x is a function Foo -> Bool
03:25:11 <Saizan> x moo == True
03:25:40 <timthelion> I am an idiot
03:25:42 <timthelion> :)
03:26:55 <thom_logn> adimit: did you get a chance to look at my paste?
03:27:15 <adimit> thom_logn: looking at it right now. What exactly is the Num nstance for Thing to do?
03:27:32 <thom_logn> I want to sort on them?
03:27:55 <adimit> you don't need a Num instance to sort on values, just Ord.
03:28:06 <thom_logn> on the datum item for those and the difference a field in the Difference object
03:28:35 <ClaudiusMaximus> thom_logn: line 16 is the problem, the rhs::a when it should be rhs::Thing a
03:28:43 <thom_logn> I need to say (Thing a) -  (Thing a) to generate more differences
03:28:57 <thom_logn> looking
03:29:19 <Eduard_Munteanu> :t sortBy
03:29:20 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:29:47 <adimit> true, you don't even need an Ord instance, just a comparison function.
03:29:55 <adimit> :t sort
03:29:56 <lambdabot> forall a. (Ord a) => [a] -> [a]
03:30:05 <adimit> though for that one, you do need it :-)
03:30:14 <thom_logn> rhs? right hand side?
03:30:43 <adimit> yes.
03:31:48 <thom_logn>  ClaudiusMaximus:  I see neither a "a" or a "Thing a" on line 16???
03:32:57 <adimit> thom_logn: it's about type signatures.
03:33:16 <adimit> it helps to look at the type for getOrd:
03:33:24 <adimit> getOrd :: (Ord t) => Thing t -> t
03:33:25 <thom_logn> ok
03:33:40 <thom_logn> ah? hmmm. so what to do?
03:33:55 <adimit> now, when you say getOrd x - getOrd y, you get something of type a, not of type Thing a
03:34:19 <adimit> but the Num instance of (Thing a) would require your x - y function to return something of type (Thing a)
03:34:23 <adimit> :t (-)
03:34:23 <lambdabot> forall a. (Num a) => a -> a -> a
03:34:44 <adimit> so you give it two (Thing a), and it *has to return* a (Thing a)
03:35:04 <adimit> though, of course, I don't think defining a Num instance is what you really want to do here in the first place.
03:35:22 <thom_logn> okay. what is the better what to do it?
03:35:47 <adimit> thom_logn: you'll have to wrap the result of getOrd x - getOrd y in a type constructor for Thing. Either Difference  or Datum.
03:35:54 <adimit> I'd propose to use a pattern match or so.
03:38:47 <thom_logn> Hmmm, I think I see how to do it without the Num instance...
03:38:59 <adimit> very good :-)
03:39:04 <thom_logn> thanks
04:13:10 * hackagebot tpdb 0.3 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-0.3 (JohannesWaldmann)
04:50:50 <germanyboy24> http://xeducation.info/2012/03/gorgeous-brunette-milf-teacher-punishes-her-student/
04:52:28 <ChristianS> can somebody kick that spammer, please?
04:52:45 <Cale> He's already K-lined
04:53:04 <zhulikas> ChristianS, you don't like to be punished in such way?
05:20:49 <kowey> is there a known issue with mailing lists on project.haskell.org?
05:20:56 <kowey> Mailman experienced a very low level failure and could not even generate a useful traceback for you. Please report this to the Mailman administrator at this site.
05:33:12 * hackagebot egison 1.0.7 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.0.7 (SatoshiEgi)
06:03:14 * hackagebot resource-simple 0.2 - Allocate resources which are guaranteed to be released.  http://hackage.haskell.org/package/resource-simple-0.2 (ShaneOBrien)
06:05:38 <SoleSoul> Hi! I need an advice regarding xml (rss) encoding. I have an RSS feed in the form of XML encoded in Windows-1255. When I read the file with "readFile" I can't print the string because of the encoding. I get "Invalid or incomplete multibyte or wide character"
06:05:38 <lambdabot> SoleSoul: You have 1 new message. '/msg lambdabot @messages' to read it.
06:06:28 <zhulikas> @hoogle UTCTime -> String
06:06:28 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
06:06:28 <lambdabot> Prelude show :: Show a => a -> String
06:06:28 <lambdabot> Text.Show show :: Show a => a -> String
06:07:11 <quicksilver> SoleSoul: you want to set the encoding with hSetEncoding
06:07:23 <quicksilver> something like hSetEncoding h (mkTextEncoding "CP1255")
06:07:33 <quicksilver> erm
06:07:40 <quicksilver> something like hSetEncoding h =<< (mkTextEncoding "CP1255")
06:08:17 <quicksilver> see docs at http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#g:23
06:09:24 <SoleSoul> quicksilver: Thank you. I will read it. I will just add the context of the problem to make sure this is the way to go.
06:10:35 <SoleSoul> quicksilver: I have to read the string, do some manipulations and print it out. I could get the string, but after doing "show" on the result instead of getting the actual chars I got "\238 \241 \235" etc..
06:11:45 <SoleSoul> quicksilver: either I could keep the original chars but got the "invalid or incomplete" error, or I got around the error but lost the chars to the \238 list of numbers
06:12:05 <quicksilver> SoleSoul: that's expect behaviour for 'show'
06:12:18 <quicksilver> show is designed to produce conservative (7-bit) haskell source syntax
06:12:34 <quicksilver> so everything is in "" and lots of things will be escapted
06:14:06 <SoleSoul> quicksilver: Does "print" do the same?
06:14:56 <nand`> print = putStrLn . show
06:15:08 <SoleSoul> nand`: Thanks
06:15:18 <quicksilver> so you should just putStrLn
06:15:19 <SoleSoul> ok, I'll read some more and be back
06:15:21 <quicksilver> (not print)
06:15:42 <quicksilver> if you are getting errors on putStrLn it means that the encoding haskell is using isn't the one your terminal expects
06:15:55 <quicksilver> you might hSetEncoding stdout to the right one
06:15:57 <nand`> :t show `asAppliedTo` ""
06:15:58 <lambdabot> [Char] -> String
06:16:00 <quicksilver> if you know what it is :)
06:16:07 <nand`> :t show `asAppliedTo` (undefined :: String)
06:16:08 <lambdabot> String -> String
06:16:30 <nand`> ^ show is redundant on strings
06:16:56 <SoleSoul> quicksilver: The reason I used "show" is because I wanted to check if the Text.Feed.Types.Feed I got from the rss parsing library preserved the chars. This type is not a string so I used "show"
06:17:07 <quicksilver> ah well
06:17:19 <quicksilver> then show is the right thing - but you must expect the chars to be presented as \123
06:17:29 <quicksilver> you can always look up the unicode points and see if they're right.
06:17:41 <mike-burns> show is more than redundant on strings; it isn't idempotent.
06:18:03 <SoleSoul> quicksilver: They were right. But when I write this string to a file the file contains \numbers instead of the actual chars
06:18:11 <quicksilver> yes indeed
06:18:13 <quicksilver> that's what show will do
06:18:19 <quicksilver> if you're writing it to a file, you probaby don't want to do that!
06:18:24 <quicksilver> btu I don't know what you *do* want to do
06:18:29 <quicksilver> 'show' isn't for sensible file output
06:18:32 <quicksilver> it's for debugging
06:18:42 <quicksilver> ...using it to check the RSS feed was parsing correctly was a good use of show
06:18:47 <quicksilver> using it for your file format probably isn't what you want.
06:18:50 * nand` would like to add that “read” is almost never what you want, either
06:19:35 <SoleSoul> quicksilver: hmm, so I can try continuing with the development as if the string is fine and find a way later to extract the string without "show"
06:19:52 <SoleSoul> quicksilver: maybe the RSS library has a function to get the real string
06:21:04 <SoleSoul> Can Haskell libraries work with strings of such encoding or do I have to convert it to UTF-8 before doing any manipulations?
06:21:26 <SoleSoul> (Windows-1255)
06:22:16 <SoleSoul> nand`: :) I was never brave enough to trust "read"
06:22:17 <nand`> Using “String” for anything other than unicode code points is, in my opinion, not valid
06:22:37 <nand`> Since String is just [Char] and Char is an unicode code point (or some subset of it)
06:22:59 <nand`> encoded strings should be done via ByteString
06:23:13 <SoleSoul> nand`: so what is the route of action? Is there a standard way of dealing with strings of foreign encodings?
06:23:30 <ChristianS> SoleSoul: just specify the encoding to use when reading the file
06:23:33 <nand`> SoleSoul: use a ByteString and convert to/from String
06:23:57 <ChristianS> in haskell, String is a set of Chars not a set of bytes
06:23:59 <SoleSoul> mm... which way? nand`? ChristianS ?
06:24:06 <ChristianS> or do as nand` says
06:24:08 <nand`> if it's from a file do what ChristianS said
06:24:15 <SoleSoul> :)
06:24:17 <nand`> since the file IO should handle encoding for you
06:24:23 <SoleSoul> it is from a file
06:24:37 <SoleSoul> so back to quicksilver's hSetEncoding?
06:24:50 <ChristianS> yes
06:24:52 <nand`> I thought you were getting it from an RSS stream or something
06:25:19 <SoleSoul> nand`: I don't know much about RSS but I thought these are simple xml files
06:25:46 <SoleSoul> nand`: what do you mean by "stream"?
06:25:49 <nand`> oh you saved the feed locally
06:25:50 <ChristianS> SoleSoul: alternatively, you could read a bytestring and decode it into a Data.Text instead of a String. that's generally a good idea if performance matters (should be faster).
06:26:18 <nand`> ChristianS: but that entirely depends on how he's using the string
06:26:29 <ChristianS> true
06:26:41 <SoleSoul> nand`: yes, I am intending to cache the files before using them
06:26:55 <SoleSoul> ooo too many ways to manipulate text :(
06:27:32 <nand`> SoleSoul: so you're using some xml lib to parse the files?
06:27:32 <SoleSoul> so we have three options?
06:27:36 <ChristianS> SoleSoul: easiest should be to try hSetEncoding and see if it works for you.
06:28:09 <SoleSoul> 1) hSetEncoding 2) ByteString -> String 3) ByteString -> Data.Text    ??
06:28:30 <SoleSoul> are these the options?
06:28:41 <nand`> ChristianS: that would only work if the entire file is Windows-1255; unless the XML bits itself are compatible between encodings; I was under the impression that the XML-file is ASCII but the strings (CDATA) inside it are Windows-1255 or something
06:29:09 <nand`> not really sure what Windows-1255 is or how it works
06:29:16 <ChristianS> nand`: well, Windows-1255 is a superset of ascii so that should work
06:29:27 <SoleSoul> nand`: I prefer using the most high level libs for parsing RSS. I first tried Text.Feed
06:29:56 <ChristianS> if a text file mixes multiple encodings, it deserves being deleted without further ado.
06:30:07 <SoleSoul> nand`: Windows-1255 is lower 128 ascii and upper 128 bits hebrew
06:30:19 <SoleSoul> *not bits, values
06:30:50 <nand`> “simple XML file” is an oxymoron btw :)
06:30:56 <ChristianS> SoleSoul: yup, ascii superset, like i said
06:31:05 <nand`> well then try hSetEncoding
06:31:07 <ChristianS> (ascii only has 128 chars)
06:31:08 <nand`> should work
06:31:27 <SoleSoul> ChristianS: yes, you are right. I just added some detais
06:31:30 <SoleSoul> *details
06:32:00 <SoleSoul> nand`, ChristianS, quicksilver: Ok, thank you. I am going to try using hSetEncoding.
06:34:08 <jay_gridley> hello, looking for way how to replace part of string (example: "" -> "), any idea?
06:34:08 <lambdabot> jay_gridley: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:34:41 <jay_gridley> '/msg lambdabot @messages
06:35:23 <nand`> jay_gridley: subRegex maybe
06:35:26 <hpaste> erus` pasted “The type of a universe polymorphic arrow type” at http://hpaste.org/64666
06:36:38 <kstt> mmh, that's annoying, "data Foobar = Foo | Bar Bool deriving (Show, Eq, Enum, Bounded)" is forbidden because Foobar is not an enumeration type
06:36:58 <kstt> However, it it trivialy enumerable
06:37:10 <kstt> because Bool is an enumeration type
06:38:22 <kstt> by the way, it does not complain for Show, thus the compiler is clever enough for figure how to show the elements
06:38:42 <ChristianS> kstt: your combined type is certainly not Bounded
06:38:53 <kstt> Foobar = { Foo , Bar False , Bar True }
06:38:53 <SoleSoul> jay_gridley: maybe this can help: http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/src/Data-List-Utils.html#replace
06:39:51 <kstt> anyway, GHC refuses to derive any of enumeration or boudaries
06:40:06 <quicksilver> kstt: yes, because that's not what deriving Enum means
06:40:18 <quicksilver> although I can understand why you might want it to mean that, it isn't what it means.
06:40:28 <quicksilver> you are permitted to write your own instance you know :)
06:40:35 <quicksilver> deriving is just a default scheme for types of a particular form.
06:41:42 <kstt> indeed, but the enumeration+bounded *auto* derivation is a simple and powerful way to have guaranteed coverage of your type values
06:42:08 <kstt> if I do that by hand I could very well forget an element silently
06:42:16 <napping> and very tricky to do if constructor take arguments
06:42:38 <napping> Enum isn't really specified either
06:42:38 <kstt> why ?
06:42:45 <napping> what if you had some integer arguments?
06:43:08 <kstt> well, naturals are enumerable, aren't they ?
06:43:09 <napping> data X = A Integer | B Integer deriving (Enum,Ord)
06:43:38 <quicksilver> kstt: yes, you could propose an extension to the deriving mechanism.
06:43:41 <kstt> Integer is enumerable but not bounded
06:43:43 <quicksilver> but it's not so hard to get it right.
06:44:17 <quicksilver> and you could write a DrIFT or Data.Derive recipe for other people's use
06:44:42 <napping> Your case where only one constructor takes an argument, and that argument is Bounded should work smoothly
06:44:43 <kstt> quicksilver: I've never used DrIFT and alway felt a bit impressed
06:44:59 <kstt> napping: your case as well,
06:45:14 <napping> how do you end up with a fromEnum consistent with the ordering?
06:45:23 <quicksilver> except the ways to enumerate two Integers are not really compatible with the simpler case
06:45:31 <kstt> succ (A x) = A (succ X)
06:45:32 <quicksilver> also, the enumeration of Integer doesn't actually enumerate it.
06:45:33 <napping> well, for that matter claiming Integer is Enum is a bit fishy
06:45:41 <kstt> succ (B x) = B (succ x)
06:45:41 <napping> Int being smaller
06:45:48 <quicksilver> that's because the Enum class is very badly broken.
06:46:01 <kstt> I agree enum is poorly defined
06:46:03 <quicksilver> to be honest the noble fragment of the Enum class is the application to finite types
06:46:08 <quicksilver> where it seems most complete and consistent.
06:46:13 <napping> succ and pred sure, but toEnum and fromEnum is fine
06:46:20 <napping> bad, rather
06:46:30 <napping> also, if you do it like that enumFrom and friends will miss values
06:46:42 <napping> so if the point is to have something that enumerates all the members that will fail
06:47:10 <kstt> obviously the proposal should start by defining classes with more consistent properties
06:47:50 <napping> Bounded doesn't obviously mean finite
06:48:00 <napping> Bounded+Enum probably should
06:48:20 <napping> hopefully the optimizer could reduce fromEnum minBound / fromEnum maxBound to constants
06:48:37 <kstt> in any case, having a way to automatically enumerate all values inhabitating a type is valuable in many situations
06:48:47 <kstt> and very doable
06:49:27 <napping> Enum usuall supposedly has something to do with the order, and a natural notion of successor/predecessor
06:49:47 <napping> you might want SmallCheck
06:49:56 <kstt> A type is finitly enumerable iff all its constructors are finitly enumerables and all its constructor arguments are finitly enumerables
06:50:10 <napping> or at least something like LogicT that smoothly handles interleaving infinite enumerations
06:51:35 <napping> that sounds fairly reasonable
06:52:05 <napping> especially if you're willing to give up on -> or things with explicit polymorphism
06:53:23 <napping> should also be fairly easy to write automatic deriving for
06:53:33 <kstt> in which case its finite enumeration simply is a recursive depth-first traversal of its constructors
06:53:47 <napping> Enum seems to be more about enumerating ranges according to some ordering
06:54:02 <kstt> napping: indeed
06:54:10 <kstt> enum isn't the right choice
06:54:11 <napping> if you just want a class Finite a where allMembers :: [a]
06:54:21 <kstt> precisely
06:55:17 <kstt> we could provide ordering predictability if we stick to the left-to-rigth-depth-first traversal
06:55:46 <kstt> for my usual use cases I don't mind, but some users could find it useful, and that certainly does not harm others
06:57:10 <kstt> I'll give you an example. I'm doing a web app with Happstack. For the sake of static guarantees, all my pages have a constructor of the Page type.
06:57:30 <kstt> early routing convert paths to Page
06:58:27 <quicksilver> kstt: depending on order breaks something you would otherwise expect to be a meaning preserving transformation, FWIWI
06:58:37 <quicksilver> I don't claim this is terrible important in practice.
06:58:50 <kstt> now I want to generate a sitemap of the website. That is, roughly, a [(PageUrl, RelevanceFactor)]
06:59:34 <kstt> I don't want to forget a page so I write a function of type Page -> [(PageUrl, RelevanceFactor)] and the compiler checks that I don't forget any page, nice !
07:00:16 <kstt> But I don't have my list yet ! What I want now is the [(PageUrl, RelevanceFactor)], for all 'page' in Page
07:00:29 <kstt> and here I'm stuck !
07:00:41 <kstt> enumerating them manually is error prone and the compiler won't help
07:01:28 <kstt> And I find this pattern quiet often actually
07:02:16 <napping> if you want help, quickcheck that toEnum . fromEnum == id
07:03:01 <Saizan> and/or write your own deriving in TH
07:03:11 <ChristianS> kstt: writing Enum instances yourself is not that hard
07:03:16 <Saizan> (maybe derive already has it?)
07:03:17 <kstt> quickcheck is wonderfull, but I don't like to run tests for things that can be statically verified, or I would program with ruby and cucumber ;p
07:03:42 <napping> well, now you are seeing that Haskell barely has an expressive type system
07:07:35 <kstt> mmh ... That should be fixable
07:08:32 <napping> In Coq, you'd go on and define enumGood : forall (p : Page), In p allPages.
07:10:06 <aristid> napping: these more expressive type systems seem to generally come at a huge cost
07:10:21 <aristid> napping: but maybe that's a solvable problem? :)
07:10:50 <napping> perhaps theres a cost, but if you want static verification, you know where to find it :)
07:11:05 <aristid> yeah, coq or agda or isabelle..
07:11:44 <napping> Agda's closer to Haskell, but it's example would be full of unicode :)
07:12:29 <HugoDaniel> i hate agda
07:12:31 <HugoDaniel> there, i said it
07:12:36 <HugoDaniel> i also hate coq
07:12:37 <HugoDaniel> done
07:13:42 <napping> If you want to avoid errors in exhaustively listing your type, the way to go is probably writing and testing a deriving thing
07:14:33 <napping> or writing a fromEnum-style function where exhaustivenes checking will help you (also Catch, if you want), and then using quickCheck or something to see that it's the inverse of your enumeration function
07:15:12 <aristid> HugoDaniel: omg. you're evil!
07:16:11 <napping> aristid: Agda doesn't seem particularly more expensive, if you stick with simple types and don't worry about termination checking
07:16:41 <aristid> napping: not worrying about termination checking? i think you'd need to pass it a flag for that.
07:17:03 <aristid> napping: and then you basically have a slower haskell without some of the niceties of haskell
07:18:24 <kstt> Haskell is a slower C
07:18:47 <napping> missing niceties and slower, yes, but it doesn't seem to be huge cost
07:18:50 <kstt> without some flexibility :)
07:19:09 <aristid> napping: i think the termination checking is an integral part of agda :)
07:19:24 <aristid> napping: but it's true that the dependent types are somewhat optional
07:20:12 <napping> it will sternly highlight things in red, but doesn't refuse to run them
07:21:10 <napping> at least, that's how the emacs mode defaults
07:21:28 <aristid> napping: you can't import these functions in other modules then
07:26:45 <napping> I guess you do need to stick a pramga at the top of the module with the problematic function if you want to import it elsewhere
07:29:39 <t7> I have implemented Type inference for missing type applications :3
07:29:42 <idnar> how do I render a UTCTime as human-readable text?
07:29:43 <t7> in sysm-f :)
07:30:01 <idnar> oh nevermind, I'm blind
07:30:04 <Guest65134> @help
07:30:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:30:05 * idnar finds Data.Time.Format
07:30:09 <Guest65134> @list
07:30:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:30:26 <Guest65134> @djinn help
07:30:27 <lambdabot> -- f cannot be realized.
07:30:34 <Guest65134> @help djinn
07:30:34 <lambdabot> djinn <type>.
07:30:34 <lambdabot> Generates Haskell code from a type.
07:30:34 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
07:31:21 <Guest65134> @djinn (a-a)
07:31:21 <lambdabot> Cannot parse command
07:31:27 <Guest65134> @djinn (a->a)
07:31:27 <lambdabot> f a = a
07:32:15 <Guest65134> @djinn (a -> Either a b) -> (b -> a -> Either a c) -> a -> Either a c
07:32:15 <lambdabot> f a b c =
07:32:15 <lambdabot>     case a c of
07:32:15 <lambdabot>     Left d -> Left d
07:32:15 <lambdabot>     Right e -> b e c
07:32:55 <Guest65134> :quit
07:32:57 <Guest65134> :help
07:32:59 <Guest65134> @help
07:32:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:35:58 <tazjin> > intersperse ' ' "Is this a good way to emphasize text?"
07:35:59 <lambdabot>   "I s   t h i s   a   g o o d   w a y   t o   e m p h a s i z e   t e x t ?"
07:36:38 <scooty-puff> > map toUpper "blech"
07:36:39 <lambdabot>   "BLECH"
07:37:20 <parcs`> > "test"
07:37:21 <lambdabot>   "test"
07:37:50 <applicative> what did they call that in old german, s p a r e n d r u c k or something
07:38:31 <tazjin> applicative: I'm German and "Sparendruck" doesn't make any sense to me :P
07:38:40 <applicative> no it doesn't
07:38:54 <applicative> i'm thinking, but it is an old way of italicizing
07:39:56 <osfameron> > concat . intersperse "  " $ map (intersperse '.') $ words "Is this a good way to emphasize text?"
07:39:58 <lambdabot>   "I.s  t.h.i.s  a  g.o.o.d  w.a.y  t.o  e.m.p.h.a.s.i.z.e  t.e.x.t.?"
07:40:01 <napping> Isn't the "druck" part at least plausible for a typesetting term?
07:40:12 <osfameron> saving print?
07:40:51 <tazjin> "Druck" is "print", basically. Yes
07:41:04 <tazjin> I just looked it up
07:41:12 <applicative> http://de.wikipedia.org/wiki/Sperrsatz
07:41:13 <tazjin> > intersperse ' ' "This is called Sperrsatz"
07:41:13 <lambdabot>   "T h i s   i s   c a l l e d   S p e r r s a t z"
07:41:56 <idnar> bleh, I'm confused now
07:42:04 <idnar> The old-locale package
07:42:05 <idnar> This package provides the old locale library. For new code, the new locale library is recommended.
07:42:08 <idnar> what new locale library? :(
07:42:22 <tazjin> System.Locale, I think?
07:42:34 <tazjin> Or is that the old one? I'm not 100% sure
07:42:35 <idnar> that appears to be provided by old-locale
07:42:49 <idnar> there doesn't seem to be a library called "locale"
07:43:07 <idnar> maybe I'm missing something
07:43:34 <koala_bot> Hello all. I'm trying to write a function based on some code I was provided but am getting this error: The last statement in a 'do' construct must be an expression
07:44:04 <Clint> that means the last statement in your 'do' construct isn't an expression
07:44:10 <tazjin> idnar: I think it's been split up into different packages
07:44:20 <tazjin> idnar: Are you looking for anything from that in specific?
07:44:22 <koala_bot> Clint: Clearly :) I don't understand why what I have does not qualify.
07:44:33 <hpaste> koala_bot pasted “contents” at http://hpaste.org/64668
07:44:33 <scooty-puff> koala_bot: are you completing the do block with <...> <- <...>?
07:44:38 <idnar> tazjin: I'm trying to get a TimeLocale to pass to formatTime
07:44:48 <applicative> sperren not sparen
07:44:51 <scooty-puff> i think its maybe you indentation
07:45:01 <rwbarton> 'if' needs to be as indented as 'b'
07:45:02 <tazjin> idnar: I've always been using defaultTimeLocale from System.Locale. Works fine
07:45:54 <hpaste> “{{” annotated “contents” with “contents (annotation)” at http://hpaste.org/64668#a64669
07:45:59 <scooty-puff> koala_bot: if you use emacs at least (and surely vim), hit <tab> and it will cycle through possible indentations
07:46:10 <scooty-puff> well, vim would have diff command for it
07:46:35 <koala_bot> Unfortunately I don't, though rwbarton's instructions seem to have gotten me far enough to have revealed other errors I need to correct :) Thanks for getting me that far, everybody. I appreciate it.
07:51:41 <_Mikey> Hey guys
07:52:06 <_Mikey> I've got a small problem with types.. I think
07:52:30 <tazjin> Just ask then :P
07:52:45 <_Mikey> I give fst or snd a label based on a conditional
07:53:01 <Mkman> is there any haskell talks online?
07:53:03 <_Mikey> and then pass it around in the hope of using it as fst and snd works
07:53:26 <applicative> what do you want to hear said, Mkman
07:53:29 <_Mikey> but for some reason Haskell tries to narrow down the type if I use it more than one place.
07:53:51 <Mkman> applicative: sorry?
07:54:08 <Eduard_Munteanu> Mkman: yeah, mzero's talk springs to mind, should be on Youtube.
07:54:08 <tazjin> _Mikey: Did you manually set a type signature? Can you paste your code to hpaste.org?
07:54:17 <_Mikey> sure
07:54:22 <applicative> what do you want to hear people talking about
07:54:25 <jay_gridley> guys, I have a problemo, I am using Parsec library to parse strings (my string are wrapped in ' (apostrophes), but inside of string can be also apostrophe), but Parsec parse expects ' to be end of string, so string 'this is string with ' apostrophe' is trimed to 'this is string'. Any one could suggest something? Thanks!
07:54:26 <tazjin> Mkman: And, of course, SPJ's talks :)
07:56:06 <ChristianS> jay_gridley: how do you distinguish between ' within strings as ' as the end of string?
07:56:13 <hpaste> “_Mikey” pasted “tyoe stuff” at http://hpaste.org/64670
07:56:19 <Eduard_Munteanu> For example.. http://www.youtube.com/watch?v=b9FagOVqxmI
07:56:24 <ChristianS> if you know how to do that, you can probably tell parsec how to do it too...
07:56:25 <applicative> https://www.google.com/search?q=simon+peyton+jones&tbm=vid
07:56:37 <_Mikey> its a bit lengthy  but
07:57:02 <fryguybob> _Mikey: Sounds like the Monomorphism Restriction.
07:57:04 <fryguybob> @where dmr
07:57:04 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:57:11 <_Mikey> side is the name I give to fst or second based on a bool which is passed into the function
07:57:53 <_Mikey> ahhh ;/
07:57:57 <jay_gridley> ChristianS: Thats what I dont know how to do.. :-)
07:58:13 <rwbarton> _Mikey: what and where is the error?
07:58:39 <_Mikey> there is no error at the moment. its just I can't use side where I wish to
07:59:02 <_Mikey> in swapOut line 77
07:59:09 <fryguybob> _Mikey: You can try adding at the top of the file {-# LANGUAGE NoMonomorphismRestriction #-} or give a polymorphic signature to what you want.
07:59:14 <_Mikey> I wish to use side where side' is
07:59:19 * fryguybob notes he didn't actually look at the code.
07:59:35 <rwbarton> MR shouldn't be relevant
07:59:35 <jay_gridley> ChristianS: Ah, I got it now.... apostrophe inside of string must be escaped by another apostrophe, so double '' inside of string results in one '
07:59:59 <_Mikey> fryguybob, you took a good guess cause I'm pretty sure it's the problem.
08:00:43 <rwbarton> _Mikey, it looks like you're trying to use higher-order polymorphism
08:01:12 <_Mikey> yea its what I'm trying.
08:01:23 <jay_gridley> ChristianS: so in case, if i got ' in string, I hate to look forward, if there is an another ' and if it is not one, then return end of string
08:01:25 <_Mikey> I want side to function exactly like fst
08:01:26 <_Mikey> or snd
08:01:33 <_Mikey> so it is type independent.
08:01:55 <jay_gridley> ChristianS: so the question is, how can I look forward in string parsing?
08:03:45 <ChristianS> jay_gridley: sorry, i'm no parsec expert. i think there is a way to try a match: if ', try whether '' matches, if yes, return ', if no, return end-of-string.
08:04:24 <ChristianS> jay_gridley: there is a chapter on parsec in RWH, i remember having seen a similar example there. you could look it up.
08:04:42 <jay_gridley> ChristianS: will do, thanks man
08:05:03 <sclv> somebody remind me about the state of the art in kind polymorphism in ghc please
08:05:54 <sclv> nevermind, looking at the manual
08:08:15 <napping> sclv: the examples work in 7.4.1
08:09:41 <t7> @hoogle (a -> a -> Ord) -> [a] -> [a]
08:09:41 <lambdabot> Warning: Unknown type Ord
08:09:41 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
08:09:41 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
08:09:48 <t7> @hoogle groupBy
08:09:49 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
08:09:49 <lambdabot> Data.ByteString.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
08:09:49 <lambdabot> Data.ByteString.Lazy.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
08:11:32 <mreh> does anyone know of an FRP implementation that can be resumed?
08:12:13 <mreh> e.g. after a system crash
08:12:26 <Aune> I have a question about phantom types. Im trying to do make a short program that reads Strings, tags them as Unsafe, then have a bunch of functions with which to convert it into a Safe String and so on.
08:12:33 <Aune> How do I do that?
08:14:05 <mreh> Aune: BlazeHtml do something similar with user strings in HTML
08:14:26 <t7> @pl f (x, _) (y, _) = x == y
08:14:26 <lambdabot> f = (`ap` snd) . (. fst) . (const .) . (==) . fst
08:14:55 <danr> @unpl (==) `on` fst
08:14:55 <lambdabot> (on (==) fst)
08:15:13 <Aune> mreh, ok thanks. Will check that out.
08:15:17 <mreh> create a type whose meaning is a safe string, and when you convert any potentially unsafe strings to this type you can ensure they are safe
08:15:48 <quicksilver> there is no need to use a phantom type here unless you wish to be polymorphic over it.
08:15:55 <mreh> yes
08:16:13 <quicksilver> the main reason to use a Phantom type would be to express concepts like "function which works on both safe and unsafe strings and always returns an unsafe one"
08:16:26 <t7> is there a function to check if a list is all eq?
08:16:46 <quicksilver> :t foldr1 (==)
08:16:47 <lambdabot> [Bool] -> Bool
08:16:51 <quicksilver> nope.
08:17:43 <mreh> pair up all the elements and check the pairs for equality
08:17:44 <quicksilver> :t zipWith(uncurry(==))`ap`tail
08:17:45 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
08:17:45 <lambdabot>     In the first argument of `zipWith', namely `(uncurry (==))'
08:17:45 <lambdabot>     In the first argument of `ap', namely `zipWith (uncurry (==))'
08:18:06 <mkscrg> ok, so about monads… is it correct to describe monads as higher-kinded monoids?
08:18:24 <danr> t7: all id
08:18:31 <danr> oh all equal
08:18:59 <danr> and . (zipWith (==) <*> tail)
08:19:09 <danr> or drop 1 rather than tail
08:19:22 <quicksilver> :t all.zipWith(==)`ap`tail
08:19:23 <lambdabot>     Precedence parsing error
08:19:23 <lambdabot>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression
08:19:29 <quicksilver> :t all.(zipWith(==)`ap`tail)
08:19:29 <lambdabot>     Couldn't match expected type `a -> Bool'
08:19:30 <lambdabot>            against inferred type `[Bool]'
08:19:30 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
08:19:35 <danr> quicksilver: no you mean and rather than all
08:19:40 <quicksilver> :t and.(zipWith(==)`ap`tail)
08:19:41 <lambdabot> forall a. (Eq a) => [a] -> Bool
08:19:42 <quicksilver> thanks :)
08:19:45 <danr> :)
08:20:12 <mreh> :t and . (. map)
08:20:13 <lambdabot>     Couldn't match expected type `[Bool]'
08:20:13 <lambdabot>            against inferred type `(a -> b1) -> b'
08:20:13 <lambdabot>     In the second argument of `(.)', namely `(. map)'
08:21:15 <dmwit> mkscrg: I would rather go with "typed monoid".
08:21:36 <dmwit> oh wait, no, that's categories
08:21:39 <dmwit> Ignore me.
08:21:58 <quicksilver> mkscrg: not really, no.
08:22:26 <dmwit> mkscrg: Anyway, you could be forgiven thinking of monads as monoids; compare the monad laws stated like this to the monoid laws:
08:22:35 <quicksilver> monads are monoids in a sense, but 'higher-kinded' is not the right way to explain that sense.
08:22:50 <dmwit> return >=> f = f; f >=> return = f; f >=> (g >=> h) = (f >=> g) >=> h
08:22:57 <Aune> mreh, quicksilver, I actually intend to be polymorphic over it
08:23:18 <koala_bot> I'm getting a parse error on a return call... what could be causing that?
08:23:39 <dmwit> versus the monoid laws: zero + x = x; x + zero = x; x + (y + z) = (x + y) + z
08:23:49 <quicksilver> koala_bot: incorrect indentation?
08:23:55 <dmwit> koala_bot: Better paste some code.
08:23:56 <dmwit> ?hpaste
08:23:56 <lambdabot> Haskell pastebin: http://hpaste.org/
08:24:19 <Aune> I want a nice way to distinguish between safe and unsafe data. And I think Phantom Types is the solution, I just dont know how to use them
08:24:27 <mkscrg> dmwit: right, that's what i was getting at. return is obviously related to mempty and >>= is obviously related to mappend
08:24:40 <dmwit> >=> is related to mappend, not >>=
08:24:48 <koala_bot> hpaste actually told me - i guess my do line had a tab in it
08:24:49 <quicksilver> Aune: newtype TaggedString a = TS String
08:24:56 <koala_bot> yikes this stuff is touchy
08:25:11 <quicksilver> Aune: data Safe; data Unsafe;
08:25:33 <quicksilver> Aune: mkUnsafe :: String -> TaggedString Unsafe; mkUnsafe s = TS s;
08:26:03 <mkscrg> dmwit: you're right. also thanks for pointing out the >=> way of stating the monad laws
08:26:05 <Aune> quicksilver, thanks
08:26:17 <mkscrg> that makes explaining them as left/right identity and associativity much easer
08:26:19 <mkscrg> *easier
08:30:29 <Aune> quicksilver, How do I do it if I want a general TaggedData ? newtype TaggedData a b = TD a, mkUnsafe :: a -> TD a ?
08:30:54 <quicksilver> sure.
08:31:01 <Aune> nice
08:31:03 <quicksilver> well that last is wrong
08:31:11 <quicksilver> mkUnsafe :: a -> TaggedDate a Unsafe
08:31:16 <quicksilver> you conflated type and implementation
08:31:17 <Aune> Aaah, ok
08:31:21 <quicksilver> mkUnsafe t = TD t
08:40:19 <Aune> For some reason my system wont allow datatypes without constructors, is there some good reason why this is not allowed by default or is it just a friendly nudge?
08:40:50 <ion> Huh. http://hackage.haskell.org/packages/archive/text-icu/0.6.3.4/doc/html/Data-Text-ICU-Convert.html doesn’t seem to have any way to indicate a conversion error.
08:40:54 <quicksilver> Aune: yes, there is a good reason.
08:41:03 <quicksilver> Aune: without constructors how can you do type inference.
08:41:34 <quicksilver> Aune: ("hi") is of type String, (TD "hi") is of type TaggedData String b
08:41:41 <quicksilver> Aune: it's the constructor that makes that inference possible.
08:42:51 <applicative> does Aune want EmptyDataDecls
08:43:01 <Aune> Ok, that makes sence
08:43:08 <Aune> applicative, I dont really know
08:43:28 <applicative> data Safe; data Unsafe then make sense
08:43:34 <quicksilver> oh!
08:43:41 <quicksilver> yes, I wasn't thinking of that part
08:43:50 <quicksilver> yes, Aune wants EmptyDataDecls for that part ;)
08:44:00 <quicksilver> I thought Aune was wondering why the 'TD' tag was necessary.
08:44:20 <bogwonch> :q
08:44:50 <Aune> Ok, what is the difference between using -XEmptyDataDecl and just declaring constructors data Safe = Safe, data Unsafe = Unsafe ?
08:45:12 <Aune> Both seems to work for me.
08:45:28 <applicative> i was wondering if it would matter in your case.  data Safe only has error "good luck" as a 'value'
08:46:01 <applicative> data Safe = Safe has Safe and error "i don't exist" as 'values'
08:49:06 <quicksilver> if you're only using them as tags it doesn't technically matter.
08:49:23 <quicksilver> having unused terms (Safe and Unsafe) which are valid but have no purpose might be annoying
08:49:41 <quicksilver> it might make the compiler accept some things which you might write by mistake but didn't really need
08:49:48 <quicksilver> so it's more elegant not to have them there in the first place.
08:52:20 <zhulikas> if I have a function
08:52:21 <zhulikas> isAdmin :: GHandler s Hermes AuthResult
08:52:27 <zhulikas> and I do
08:52:31 <zhulikas> a <- isAdmin
08:52:36 <zhulikas> what will I have in a? AuthResult?
08:52:58 <zhulikas> or will it be enclosed with something else
08:53:50 <applicative> if the monad instance is for GHandler s x then it's an AuthResult
08:55:59 <Saizan> AuthResult
08:59:20 <quicksilver> applicative: well, the monad instance can't be for anything else...
08:59:54 <quicksilver> hmm
08:59:56 <quicksilver> unless...
08:59:56 <applicative> i hesitated imagining a type synonym
09:00:00 <quicksilver> yes right
09:00:02 <quicksilver> I just got there
09:00:12 <quicksilver> I'm way behind you :)
09:00:52 <applicative> i see its in yesod so it's derived, from a newtyped 17 transformer deep type, very swank
09:01:48 <applicative> newtype GHandler sub master a = GHandler { unGHandler :: ReaderT (HandlerData sub master) (MEitherT HandlerContents (WriterT (Endo [Header]) (WriterT (Endo [(String, Maybe String)]) (IO)))) a}
09:03:07 <dylukes> jesus
09:03:14 <dylukes> throw some type synonyms in there ;__;
09:03:20 <applicative> fortunately there are a lot of helper functions given to the user
09:07:24 <applicative> if you look at the yesod types, it's scary, but at least with conduits I found that the approach is pretty sensible, the error messages in particular work out well
09:22:03 <ak0s> dear all, how do I call getLine N times, where N is a variable?
09:22:33 <napping> replicateM
09:22:39 <quicksilver> dear ak0s, replicateM n getLine
09:23:04 <quicksilver> as ever your humble &c., all
09:23:27 <ak0s> thanks dear napping and quicksilver
09:23:51 <quicksilver> :)
09:23:54 <ak0s> appreciate your help sirs
09:32:37 <t7> when will universal polymorphism be in mainstream languages?
09:33:28 <adu> t7: the data variety? or the type variety?
09:33:58 <t7> type
09:34:06 <t7> whats data universe polymorphism
09:35:17 <_Mikey> If I have a list of functions and a list of values
09:35:21 <adu> data MyData a b c = MyA a | MyB b | MyC c
09:35:42 <_Mikey> is there a function to map sort of map zip the two
09:35:57 <Philippa_> zipWith ($) ?
09:36:07 <_Mikey> preferably in paralle
09:36:08 <_Mikey> preferably in parallee
09:36:10 <_Mikey> preferably in parallel
09:36:21 <_Mikey> hmm
09:36:28 <adu> Haskell is theoretically always parallel
09:37:02 <t7> evaluation semantics arent in the standard?
09:37:42 <quicksilver> not sure what you mean by "evaluation semantics"
09:37:51 <quicksilver> the standard attempts to specify the semantics, yes
09:38:01 <quicksilver> it does not attempt to prescribe the precise strategy too much
09:38:52 <adu> t7: so are you talking about typeclasses then?
09:39:20 <Phlogistique> quicksilver: "operational semantics"?
09:39:51 <quicksilver> possibly
09:39:57 <quicksilver> there's more than one meaning of that too :)
09:40:01 <t7> id = \u : Universe  \x : Type u -> x
09:40:13 <t7> i mean apply that to arrow etc
09:40:15 <Saizan> _Mikey: for the "in parallel" part see Control.Parallel.Strategies
09:40:18 <quicksilver> but, for example, sharing might be considered operational semantics and that certainly isn't specific by the standard
09:40:23 <Phlogistique> quicksilver: "everything which is not denotative semantics"
09:40:23 <quicksilver> although it's hinted in a couple of places
09:41:05 <_Mikey> Saizan, Already imported I'm playing with parMap.
09:41:09 <Saizan> t7: it's not clear universe polymorphism is the right solution
09:42:37 <adu> t7: I don't understand what you mean by "universal polymorphism"
09:42:44 <koala_bot> I have a function which does some putStr, gets a character from IO, then does a return. For some reason it's mimicking the "prompt"/file name where I should be able to type a new expression.
09:42:48 <koala_bot> Little help?
09:42:57 <t7> so i function works at type level too
09:46:11 <adu> t7: are you saying Haskell has "universal polymorphism"?
09:46:22 <t7> no ... ?
09:47:30 <adu> t7: I can't find any clear definition of "universal polymorphism" on the internet
09:48:16 <t7> it means a function that works on terms, will work on types, or types of types, or type of types of types, all the way down
09:48:39 <adu> t7: every language with first-class types allows that
09:49:37 <t7> it needs a pure type system tho, right?
09:49:54 <adu> define "pure"
09:50:09 <t7> http://en.wikipedia.org/wiki/Pure_type_system
09:51:55 <koala_bot> I can't figure out why this is happening: http://i.imgur.com/16cen.jpg
09:56:15 <ulfdoz> re
09:56:38 <ulfdoz> Die interessanteste Erkenntnis des heutigen Tages: Fr'n Entwickler verdiene ich scheinbar richtig gut.
09:59:31 <ulfdoz> " Die Staatsanwaltschaft Hannover hat das Haus von Ex-Bundesprsident Wulff in Groburgwedel durchsucht. Die Aktion sei "auf freiwilliger Basis" verlaufen, einen Durchsuchungsbeschluss gebe es nicht, sagte ein Sprecher. Zuvor hatten Ermittler Bro und Wohnrume von Filmproduzent Groenewold durchsucht." <- lol!
09:59:46 <adu> t7: why do you need a pure type system?
09:59:55 <ulfdoz> arg, sry.
10:01:18 <koala_bot> I'd appreciate a moment of someone's time. I'm having an issue where my program is running and then at the next prompt the prompt label thing gets duplicated. Has this happened to anyone else?
10:02:02 <adu> koala_bot: yes, that happends every time I press enter twice
10:02:20 <koala_bot> adu: http://i.imgur.com/16cen.jpg
10:04:34 <koala_bot> adu: What you are describing is not the same as what I am observing, is it? As per the screenshot?
10:04:53 <adu> yes, that's exactly what happens to me when I press enter twice
10:06:39 <koala_bot> adu: That is not what happens if I hit enter twice from a proper prompt in my environment. That is happening on its own and I'm not sure why.
10:10:28 <koala_bot> adu: Any ideas?
10:11:03 <napping> how are you running ghci?
10:11:13 <koala_bot> The WinGHCi client
10:11:55 <napping> I haven't used that for a while, but it looks kind of like something might be messing up history
10:12:20 <napping> like when you hit up, and it copies the prompt and also the last things you typed
10:12:29 <hpaste> koala_bot pasted “queryUser” at http://hpaste.org/64672
10:13:03 <napping> I've seen that sort of problem with emacs shell mode or rlwrap or something
10:13:34 <koala_bot> The function I just pasted is the only one having that effect on my environment
10:14:46 <napping> what if you use getLine instead?
10:15:14 <tgeeky> koala_bot: weird. especially that it gave you the prompt (minus >) and then gave you the full prompt
10:15:20 <tgeeky> koala_bot: are you using ghc 7.4.1?
10:15:25 <napping> aren't you pretting return twice?
10:15:40 <tgeeky> napping: no. that would create a second colored prompt
10:15:42 <napping> after the y or n to get it to respond?
10:15:59 <adu> napping: Windows always sends 2 characters "\r\n" maybe that's why
10:16:02 <koala_bot> tgeeky: what is the easiest way to check my version?
10:16:17 <tgeeky> koala_bot: :! ghc --version
10:16:46 <koala_bot> tgeeky: 7.0.4
10:17:22 <napping> did you type 'n', or 'n' <return> ?
10:17:46 <tgeeky> napping: 'n' <return>.
10:17:47 <koala_bot> napping :'n' <return>. Without the return, 'n' does nothing.
10:17:55 <tgeeky> koala_bot: I have the same behavior (exactly so)
10:18:31 <tgeeky> koala_bot: it doesn't do the same behavior if you use normal, console ghci (in windows, this is ghcii.sh)
10:18:42 <tgeeky> koala_bot: so this must be a bug/problem with WinGHCI
10:18:48 <koala_bot> tgeeky: Should I just ignore it then?
10:18:51 <tgeeky> koala_bot: yes
10:19:11 <napping> the getChar only reads one character, it leave the return for the shell
10:19:25 <koala_bot> Alright. Thanks everybody
10:19:40 <napping> with 7.4.1 it returns immediately after typing the y or n, and leaves no junk
10:20:06 <napping> you might also be able to set character buffering, but I don't know how that gets along with the GUI
10:20:23 <tgeeky> napping: unless you're using WinGHCi, this probably isn't relevant
10:20:58 <adu> so it is an "\r\n" issue
10:22:26 <_Mikey> Hi guys
10:22:40 <_Mikey> I've got a question about parallel processing lists
10:22:44 <_Mikey> I think I'm close
10:22:47 <tgeeky> adu: looks like it. That, and maybe a delayed buffering issue or something. On ghcii.sh (which is just ghci), if you run queryUser twice, the second run is short circuited (meaning it doesn't wait to grab input)
10:22:55 <hpaste> “_Mikey” pasted “zip parallel” at http://hpaste.org/64673
10:28:37 <rasfar> > :t (zipWith $)
10:28:37 <lambdabot>   <no location info>: parse error on input `:'
10:29:04 <rasfar> > typeOf (zipWith $)  -- ?
10:29:04 <lambdabot>   Ambiguous type variable `a' in the constraint:
10:29:05 <lambdabot>    `Data.Typeable.Typeable a...
10:29:17 <rasfar> ach...
10:29:19 <tgeeky> :t (zipWith $)
10:29:20 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:29:24 <rasfar> (zipWith $) :: (a -> b -> c) -> [a] -> [b] -> [c]
10:29:48 <_Mikey> hmm
10:35:06 <hpaste> harlekin pasted “ReaderT (ReaderT (...))” at http://hpaste.org/64674
10:36:22 <harlekin> Hi. I am having a monad transformer and underlying two ReaderT monad transformers. From the outmost monad, I'd like to retrieve both environments from the inner Readers. However, I am not able to do this. Could someone tell me what's wrong?
10:36:29 <rasfar> _Mikey: might be easier to modify processAQuadrant to take a (GraphATuple,GraphPTuple) instead, then you can use parMap?
10:37:16 <harlekin> Mh... nevermind.
10:37:22 <harlekin> It is working now in my test file...
10:37:38 <_Mikey> hmmmmm, rasfar, that could work
10:38:19 <parcs`> harlekin: use get to retrieve the outermost env and lift get to retrieve the inner one
10:38:31 <hpaste> harlekin annotated “ReaderT (ReaderT (...))” with “ReaderT (ReaderT (...)) (annotation)” at http://hpaste.org/64674#a64675
10:38:45 <parcs`> oh right, ask
10:39:16 <harlekin> parcs`: yes. Thanks. My main problem is that I always write ReaderT instead of RenderT, apparently. Might use lift . lift to avoid this. But thank you very much!
10:40:43 <tsousa> which algorithms is better to solve the eight queen puzzle?
10:42:25 <rasfar> tsousa: if you search for "n queens" you'll see more ... this looks promising: http://stackoverflow.com/questions/1255018/n-queens-in-haskell-without-list-traversal
10:42:26 <CodeWeaverX> For simplicity that doesn't rely on pure brute force, recursive-descent-with-backtracking.  Try a move.  If it breaks the constraints, undo a move and try another one.  If it doesn't break the constraints, go further.
10:45:48 <rasfar> I just watched SPJ's presentation "The Future is Parallel, and the Future of Parallel is Declarative" (www.youtube.com/watch?v=hlyQjK1qjw8) and this is discussed in a parallel context.
10:57:09 <rasfar> For 880 people this is a very quiet space!
10:57:30 <srhb> rasfar: Not always. In fact only rarely.
10:58:39 <rasfar> srhb: yeah, the tunes logs give the full picture!
10:59:03 <rasfar> Anyone familiar with SYB feel like chatting?
10:59:17 <srhb> What is SYB_
10:59:26 <Clint> scrap your boilerplate
10:59:29 <rasfar> Suppose I have constructed a value from a set of mutually-recursive data types.
10:59:33 <srhb> Ahh
10:59:55 <rasfar> I would like to compute the join (semilattice sense) of all the terms in the tree of a specific type.
11:00:48 <rasfar> The only way I've thought of (and haven't attempted it yet) is very messy...
11:02:31 <rasfar> It seems like a case for bottom-up traversal?
11:05:50 <rasfar> I'm looking for the rootwardmost node which has at least two children with type T descendants.
11:06:23 <rasfar> Unless there is no such node, in which case I want the rootwardmost T node.
11:06:52 <rasfar> I don't have the skill to implement this in SYB yet.  Any advice?
11:09:45 <rasfar> Maybe I should try Biplate instead...
11:13:02 <rasfar> Ok, bye for now 888 quiet souls!
11:24:55 <sykora> quick question - What is the command line option I need to get ghc/i to let me import modules from a particular directory I'm developing in? `-i' doesn't work.
11:25:34 <srhb> sykora: -iwhat doesn't work?
11:26:56 <sykora> srhb: I have a package structure in my current directory (e.g. ./A/B/C.hs), but `ghci -i.' doesn't let me import A.B.C
11:28:45 <solidsnack> sykora: Well, . should be in the include path by default.
11:28:58 <Saizan> sykora: does the file start with "module A.B.C where" ?
11:29:19 <sykora> Saizan: yes
11:29:29 <Saizan> should work then
11:32:11 <sykora> "module is not loaded: `A.B.C' (./A/B/C.hs)"
11:32:40 <sykora> I recreated the problem with precisely those names, to isolate my specific environment, still no luck
11:33:25 <Saizan> oh, in older ghci you have to :load ./A/B/C.hs
11:34:34 <sykora> older as in, pre 7.0.3?
11:35:33 <Saizan> i don't remember exactly but something like that
11:36:54 <Saizan> or maybe i'm wrong and you need to explicitly :load now too
11:37:28 <sykora> I seem to vaguely remember having done this before, and don't remember doing too many contortions
11:39:56 <Saizan> it's not much of a contortion
11:40:09 <Saizan> on the prompt you need :load, in code you just use import
11:43:32 <sykora> OK, then why does import work for system/cabal-installed modules, but not for my own?
11:43:42 <sykora> the path to cabal must be stored somewhere
11:43:50 <Saizan> it's not about paths
11:44:15 <Saizan> it's that :load is the command to interpret modules
11:44:31 <Saizan> cabal installed modules are already compiled and don't need that step
11:44:42 <Saizan> anyhow the paths for them are stored by ghc-pkg
11:51:26 <sykora> well, :load works so I can go ahead now. Thanks, Saizan.
11:56:06 <monochrom> it is not compiled vs not compiled. it is library vs not in library.
12:01:08 <monochrom> to show that it is not compiled vs not compiled: you still need :load for modules already compiled but not packaged
12:02:55 <monochrom> to show that it is library vs not in library: prepare some package and install it. go to a directory that has the source code of that package, maybe modified to show differences. if you :load, you get the code in that directory, not the installed package; if you don't :load, you get the code in the installed package
12:03:23 <sykora> "don't :load" => import?
12:03:57 <monochrom> import or :m
12:04:54 <sykora> monochrom: so this is what everyone does during development?
12:05:04 <monochrom> I don't know about everyone
12:05:26 <monochrom> and I don't know about myself either because it depends on context
12:05:48 <sykora> I guess the only issue here is with ghci, ghc works by passing -i anyway
12:06:59 <monochrom> "only" is an illusion. the same issue exists to ghc. the illusion is due to "ghc haha.hs" implies :load haha.hs
12:07:36 <monochrom> clearly, "ghc haha.hs" does not take haha.hs from an installed package
12:08:17 <sykora> monochrom: the difference is between ":load A.B.C" and "import A.B.C"
12:08:18 <monochrom> but since you don't enter the ":load" yourself, you don't notice it
12:11:05 <monochrom> that is not a useful comparison. you need a fair comparison.
12:11:39 <monochrom> ":load haha.hs" vs "ghc haha.hs", OK? because ghc rejects "ghc A.B.C.hs" anyway
12:12:02 <monochrom> now, inside haha.hs, you have "import A.B.C". that's inside haha.hs
12:13:14 <monochrom> if you :load haha.hs, and it imports A.B.C, then the computer first looks in the current directory and/or whatever is on your -i
12:13:31 <monochrom> if not there, then looks in the installed packages
12:13:58 <monochrom> that is the effect of :load. and it is the same with "ghc haha.hs"
12:14:17 <monochrom> so ":load haha.hs" and "ghc haha.hs" have no difference
12:14:28 <sykora> then what does `import' in ghci mean?
12:15:12 <sykora> "bring-into-scope"?
12:15:45 <monochrom> it is just a better :m
12:16:05 <monochrom> and both are just namespacing
12:18:10 <sykora> OK, got it.
12:20:01 <monochrom> import and :m are not responsible for fetching code. they are only responsible for resolving names later. ":m M" means, next time you enter "x", the computer will try "M.x". that is all.
12:20:51 <monochrom> only :load can fetch code, if the code is not in an installed package
12:23:28 <sykora> I assume an implicit :load is done for any package that has been :m'ed if ghc-pkg can find it?
12:23:43 <sykora> when it first resolves M.x, that is
12:24:35 <c_wraith> no...  :load puts you in the scope of that module.
12:24:39 <monochrom> I would love to tell that white lie, but no. this can be shown by ":load Data.Char" being an error
12:24:42 <c_wraith> :m just makes the module available
12:25:59 <monochrom> code from installed packages cannot be :load'ed. simply can't. the computer still finds them and uses them automatically, sure
12:27:47 <monochrom> also you don't need :m to use code from installed packages. try "Data.Char.chr 65" some time.
12:31:10 <monochrom> code from installed packages are automatically brought in, but put at a low precedence. :load brings in more code (and it does a bit of transitive chasing). you can only use code from those two origins.
12:32:09 <monochrom> the convenient and confusing thing is that :load X includes a :module X, so you don't easily see the distinction between bringing code in and setting namespace
12:32:35 <monochrom> but there are experiments to show the distinction
12:33:34 * hackagebot spike 0.1 - Experimental web browser  http://hackage.haskell.org/package/spike-0.1 (KrzysztofSkrzetnicki)
12:44:49 <zhulikas> @hoogle a -> [a] -> [a]
12:44:49 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
12:44:49 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
12:44:50 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
12:46:23 <zhulikas> I am looking for a splitOn function
12:46:27 <zhulikas> is it in standard library?
12:46:32 <ion> @hackage split
12:46:33 <lambdabot> http://hackage.haskell.org/package/split
12:46:34 <zhulikas> @hoogle splitOn
12:46:34 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
12:46:35 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
12:46:50 <zhulikas> hmm, actually Text is even better
12:48:13 <zhulikas> @hoogle isLetter
12:48:13 <lambdabot> Data.Char isLetter :: Char -> Bool
12:48:41 <zhulikas> @hoogle Text -> [Char]
12:48:42 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
12:48:42 <lambdabot> Data.Text.Internal showText :: Text -> String
12:48:42 <lambdabot> Data.Text.Lazy unpack :: Text -> String
12:48:47 <zhulikas> damn.
12:48:57 <zhulikas> unpacking, checking and packing again seems wrong
12:48:59 <sykora> monochrom: I'm off now, thanks for the explanation.
13:02:31 <ChristianS> zhulikas: why would you unpacking + repack a Text?
13:03:01 <zhulikas> don't know, I'm bored
13:03:17 <zhulikas> well, I get input as Text
13:03:17 <monochrom> I thought you just wanted to split
13:03:27 <zhulikas> and that is actually comma separated tags
13:03:40 <zhulikas> but I wanted to make sure that every tag is letter-only Text
13:03:49 <zhulikas> no special characters, no numbers
13:03:59 <monochrom> I think you can split Text directly
13:04:03 <zhulikas> yeah
13:04:06 <zhulikas> splitOn in Data.Text
13:04:12 <zhulikas> but
13:04:14 <zhulikas> @hoogle isLetter
13:04:14 <lambdabot> Data.Char isLetter :: Char -> Bool
13:04:17 <zhulikas> that's for Char
13:04:38 <ChristianS> Data.Text.all
13:04:46 <zhulikas> @hoogle all
13:04:47 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
13:04:47 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
13:04:47 <lambdabot> Data.Monoid All :: Bool -> All
13:05:08 <ChristianS> @type Data.Text.all
13:05:09 <lambdabot> (Char -> Bool) -> Data.Text.Internal.Text -> Bool
13:05:09 <monochrom> split :: (Char -> Bool) -> Text -> [Text]
13:05:10 <zhulikas> but... Text is not [a], again
13:05:19 <zhulikas> hmm
13:05:29 <monochrom> that works directly on Text, and welcomes isLetter
13:05:34 <zhulikas> cool
13:05:39 <zhulikas> thanks
13:06:05 <zhulikas> well, Data.Text.all is what I need
13:06:06 <zhulikas> not split
13:06:47 <monochrom> ah, still good
13:09:48 <zhulikas> hmm
13:09:51 <zhulikas> @hoogle Prelude.all
13:09:52 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
13:09:52 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
13:09:53 <lambdabot> package allocated-processor
13:09:59 <zhulikas> conflicting exports
13:10:51 <monochrom> yeah you probably like to import qualified
13:10:56 <zhulikas> I believe that should work
13:11:01 <zhulikas> ll (isLetter <|> (== ',')) t
13:11:05 <zhulikas> all, not ll
13:11:10 <monochrom> haha
13:11:14 <ChristianS> import qualified Data.Text as T
13:11:26 <zhulikas> nah, I don't want qualified
13:11:34 <zhulikas> I'd rather do hiding from Prelude :D
13:12:07 <zhulikas> but I wonder if I understand <|> correctly
13:12:16 <ChristianS> "This module is intended to be imported qualified" -- http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html
13:12:25 <monochrom> @type (<|>)
13:12:25 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
13:12:29 <ChristianS> if the package tells you you should, you should!
13:12:32 <zhulikas> :)
13:12:39 <zhulikas> import Data.Text (Text, pack, unpack, splitOn, all)
13:12:42 <zhulikas> I do this instead
13:12:56 <zhulikas> changing it to qualified would mean too much work :\
13:13:00 <zhulikas> change existing stuff...
13:14:01 <zhulikas> > Data.Text.all (Char.isLetter) (Data.Text.pack "asdfasdfa")
13:14:02 <lambdabot>   Not in scope: `Data.Text.all'Not in scope: `Char.isLetter'Not in scope: `Da...
13:14:22 <zhulikas> > all (isLetter) ("adf")
13:14:23 <lambdabot>   True
13:14:38 <zhulikas> > all (isLetter <|> (== ',') ("ad,f")
13:14:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:14:41 <monochrom> lambdabot probably doesn't have TexT
13:14:43 <zhulikas> > all (isLetter <|> (== ',')) ("ad,f")
13:14:43 <lambdabot>   No instance for (Control.Applicative.Alternative
13:14:44 <lambdabot>                     ((->) ...
13:14:52 <zhulikas> and applicative
13:15:44 <monochrom> it has applicative. it has <|>. but <|> does not do your job. write your own.
13:16:03 <ion> @type liftA2 (||) isLetter (== ',')
13:16:04 <lambdabot> Char -> Bool
13:20:32 <ChristianS> that would work, or just a lambda
13:20:36 <ChristianS> > all (\x -> isLetter x || x == ',') ("ad,f")
13:20:37 <lambdabot>   True
13:32:34 <Ralith> is it weird that I feel like the OutsideIn(X) paper has greatly strengthened my grasp of and ability to implement conventional constraint-based typing, compared to where I was after having skimmed TAPL?
13:33:05 <c_wraith> Not really.  SPJ is very easy to follow.
13:33:27 <Ralith> it struck me as odd because that's not even the *point* of the paper, just background.
13:33:35 <Ralith> but I've really been enjoying reading it.
13:33:37 * hackagebot live-sequencer 0.0 - Live coding of MIDI music  http://hackage.haskell.org/package/live-sequencer-0.0 (HenningThielemann)
13:34:48 <Ralith> dense as gold, but about that worthwhile, too.
13:49:06 <MaybeJust> statistics question: for a small country that has a hard time producing talent for a sport for small age groups. like 16-17, 18-19, 19-21. could they be more successfull at 18-35? even for other countries the talentpool expands since there are more players to choose from but if you only produce one top player a year(for simplicity) then the 18-35 team could produce enough of
13:49:15 <MaybeJust> them but the smaller ages wouldnt while for bigger countires they could. of course the smaller country wouldnt have players with the experience and not enough goos substitutes but the difference in quality could still be smaller?
13:49:41 <MaybeJust> does that make any sense at all?
13:51:03 <ddarius> No.
13:51:13 <ddarius> Moral of the story: be a big country.
13:53:45 <tommd> Does EHC/UHC support TH?
13:54:02 <ddarius> No.
13:54:13 <tommd> Thanks
13:54:47 <MaybeJust> ddarius: are you sure?
13:54:54 <MaybeJust> did you get what i mean?
13:58:24 <tommd> I thought he was talking to me...
13:58:30 <tommd> Maybe... Just maybe.
14:04:01 <tzxn3> does anyone have any haskell problems or exercises they'd recommend?
14:04:04 <tzxn3> I'm aware of H99
14:05:52 <alpounet> tzxn3, there's no reason for you to restrict yourself to "haskell problems"
14:06:03 <tzxn3> lol
14:06:04 <alpounet> just pick random interview questions/problems
14:06:23 <alpounet> it'll be a bit harder probably (and that's not even sure) but really fine I think
14:06:28 <tzxn3> any good resources for those?
14:06:29 <bill```> what about project euler problems?
14:06:42 <bill```> http://projecteuler.net/problems
14:06:52 <tzxn3> I'm aware of those as well
14:08:07 <alpounet> tzxn3, i don't have any reference website for those, but googling "interview questions/problems programming" should bring you some
14:13:23 <tzxn3> project Euler is very maths focused
14:14:04 <tzxn3> the only solution I can ever think of is "brute force search every possible solution"
14:14:25 <bill```> that's the easiest/best solution in a lot of cases
14:15:02 <ion> @type [?a .: ?b, curry (?a . uncurry ?b)]
14:15:03 <lambdabot> forall c a b c1. (?b::a -> b -> c1, ?a::c1 -> c) => [a -> b -> c]
14:16:30 <monochrom> the TaPL description of type inference has an obscuring redundancy. whereas we can easily just say "pick fresh variable v", it instead goes out of its way to track the set of variables used so far, just so as to say "pick variable v not in that set"
14:17:36 <ion> (a . b) .: c = a .: (b .: c), but curry (a . b . uncurry c) works the same no matter how you group the composition. :-)
14:24:48 <adit> @hoogle Functor
14:24:48 <lambdabot> Prelude class Functor f
14:24:48 <lambdabot> Data.Functor class Functor f
14:24:48 <lambdabot> Control.Monad class Functor f
14:25:23 * ddarius does not assume an infinite set of fresh variables.
14:26:34 <tazjin> @yhjulwwiefzojcbxybbruweejw What does this even do?
14:26:34 <lambdabot> Just 'J'
14:27:00 <zhulikas> @hoogle [Either a b] -> [Right b]
14:27:00 <lambdabot> Did you mean: [Either a b] -> [Either b a]
14:27:00 <lambdabot> Data.Array.MArray readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
14:27:00 <lambdabot> Data.Array.MArray writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
14:27:36 <zhulikas> @hoogle [Either a b] -> [b]
14:27:36 <lambdabot> Data.Either rights :: [Either a b] -> [b]
14:27:36 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
14:27:36 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
14:27:41 <zhulikas> ah, ok
14:30:46 <adit> @hoogle [Either a b] -> b
14:30:47 <lambdabot> Data.Either rights :: [Either a b] -> [b]
14:30:47 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
14:30:47 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
14:31:01 <adit> huh
14:31:19 <adit> If there's a `rights`, why not have a `right` too for a single val
14:31:27 <zhulikas> :D
14:31:37 <zhulikas> what if there are no rights
14:31:42 <zhulikas> undefined!
14:32:04 <zhulikas> or then
14:32:06 <zhulikas> Maybe b
14:32:10 <adit> haha
14:32:12 <adit> well
14:32:13 <zhulikas> @hoogle [Either a b] -> Maybe b
14:32:14 <adit> since it's a list
14:32:14 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
14:32:14 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
14:32:14 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
14:32:18 <adit> you would get the empty list
14:32:24 <adit> Prelude Data.Either> rights [Left 1]
14:32:24 <adit> []
14:32:33 <zhulikas> but you want a single value, not a list with `right`
14:32:35 <zhulikas> :P
14:32:39 <adit> ah right
14:32:46 <adit> I see what you're saying
14:33:17 <adit> It would be like `fromJust1
14:33:19 <adit> err
14:33:21 <adit> fromJust*
14:33:31 <adit> which throws an error if you pass in Nothing
14:33:35 <adit> @hoogle fromJust
14:33:35 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
14:33:46 <zhulikas> errors
14:33:50 <zhulikas> yuck
14:33:54 <adit> yeah agreed
14:33:56 <adit> not greayt
14:34:16 <adit> *sighs*
14:34:26 <adit> yeah, maybe a `right` wouldn't be that nice
14:34:29 <zhulikas> actually I didn't see any errors ever in a well-written code
14:34:44 <adit> heck yeah
14:34:48 <zhulikas> so error in haskell is just useless
14:34:49 <adit> Haskell has no errors
14:34:58 <zhulikas> it should be deprecated
14:35:03 <adit> :D
14:35:58 <zhulikas> I wonder if (_:_) is a good pattern against non-empty list
14:36:03 <zhulikas> looks like butt
14:36:18 <adit> lol
14:36:28 <adit> scala does currying with _
14:36:32 <adit> so you get a lot of butts
14:36:39 <zhulikas> :D
14:36:45 <adit> (_+_) to curry addition
14:36:48 <zhulikas> I bet scala smells
14:36:54 <zhulikas> because of all the butts
14:37:03 <adit> lol
14:38:54 <stulli> Does anybody here use emacs? How on earth do i enable syntax highlighting for Haskell?
14:39:09 <adit> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs ?
14:39:57 <stulli> adit: I tried https://github.com/chrisdone/haskell-emacs and thought syntax highlighting would be included
14:40:27 <adit> I'm not an emacs user, but I use haskellmode for vim and it gives me syntax highlighting
14:41:05 <zhulikas> there is even nanorc for haskell syntax highlighting in nano
14:41:07 <stulli> Yeah, i'm a vim user too but thinking about switching to emacs + evil
14:41:23 <zhulikas> I always wanted to switch to vim :(
14:41:39 <zhulikas> but am too lazy to switch from GUI to text-based interfaces
14:42:22 <adit> haha, yeah I was lazy too
14:42:30 <zhulikas> was it worth it?
14:42:46 <monochrom> I just use http://projects.haskell.org/haskellmode-emacs/ . I get colouring.
14:43:08 <zhulikas> I am kinda growing to finally switching to vim
14:43:10 <zhulikas> but not just yet
14:43:16 <adit> meh. I switched b/c I had to ssh and edit code on remote machines
14:43:24 <adit> with no GUI options :P
14:43:32 <adit> So I figured, might as well learn vim
14:43:34 <zhulikas> I always use nano :D
14:43:39 <monochrom> I just use emacs -nw when there is no X
14:43:48 <monochrom> ok, sometimes I use nano
14:43:53 <zhulikas> but vim/emacs is the best choice for programming editors as I see it
14:44:03 <zhulikas> and as people talk
14:44:33 <monochrom> I am tired of needing to press esc every so often to switch "mode"s
14:44:37 <zhulikas> btw, is there a mouse support in vim?
14:44:39 <stulli> monochrom: So you have syntax-highlighting for Haskell?
14:44:43 <zhulikas> like click somewhere and pointer gets there
14:44:45 <monochrom> yes
14:44:47 <adit> zhulikas: nope
14:44:48 <adit> err
14:44:51 <adit> there is in macvim
14:44:59 <zhulikas> in gui version of vim, right?
14:45:02 <zhulikas> gvim
14:45:10 <adit> yeah
14:45:10 <zhulikas> yeah, and macvim
14:45:14 <stulli> monochrom: Would you mind to explain an emacs-noob how to achieve this?
14:45:33 <monochrom> of course, I agree that "10dd" to delete 10 lines is pretty slick
14:45:37 <adit> yeah gvim is a smoother transition
14:45:48 <monochrom> use http://projects.haskell.org/haskellmode-emacs/
14:46:10 <adit> monochrom: I use vim b/c I learned it before emacs :P
14:46:16 <adit> I'm sure emacs is just as good
14:47:12 <tgeeky_> :/
14:47:27 <tgeeky_> re: an earlier vim comment. That's how i clear my buffer in vim. :0 999999999999999dd
14:47:39 <tgeeky_> i can't wait until it fails me because the file is too big :o
14:47:56 <monochrom> dG
14:47:58 <ion> ggdG
14:48:39 <tgeeky_> any more? you guys gonna go Larry Wall on my ass? There's a thousand ways to do it, but damn if I didn't pick the worst one.
14:48:53 <adit> :D
14:49:46 <monochrom> well, there are trivially infinitely many ways. 99999dd, 100000dd, 100001dd ...
14:49:58 <tgeeky_> that doesn't make me feel any better!
14:50:38 <adit> ways = map (\x -> " :0 " ++ (show x) ++ "dd") [0..]
14:50:52 <adit> YOU'RE WELCOEM
14:51:01 * tgeeky_ cries in the corner with a dunce cap on
14:51:04 <stulli> monochrom, adit: haskell-mode worked just fine, thanks.
14:51:13 <adit> cool!
14:51:41 <zhulikas> I wonder if geany integrates with ghc
14:52:00 <monochrom> it offers about 4 mutually-exclusive indentation package. IMO the best is 'turn-on-haskell-indentation
14:52:03 <zhulikas> and could do some function suggesting
14:52:44 <monochrom> http://hpaste.org/47103/emacs_haskellmode_demo has an example of what you type and what you get
14:53:48 <tgeeky_> uhhh
14:54:06 <tgeeky_> someone is posting addresses on hpaste :/
14:54:27 <monochrom> eh? addresses? whose addresses? I want them! :)
14:54:34 <tgeeky_> http://hpaste.org/64678
14:54:38 <tgeeky_> e-mail and real, it looks like
14:55:07 <monochrom> I hope kategoriec@email.de is made up
14:58:03 <hpaste> timthelion pasted “error in generated code” at http://hpaste.org/64679
14:58:24 <timthelion> can anyone explain to me why I get that error?
14:58:33 <zhulikas> @hoogle m a -> m1 a
14:58:33 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
14:58:33 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
14:58:33 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
14:58:40 <monochrom> which line is line 8?
14:59:09 <timthelion> f3x0  p1  = if p1  then f4x0  else return []
14:59:24 <timthelion> sorry, I cut some whitespace out of the top, not even thinking about it
15:00:34 <monochrom> "if p1  then putChar  else return []" what does it look like to you?
15:01:20 <timthelion> mm, so the putchar is asking for an argument that isn't there...
15:01:30 <timthelion> thank you, now I see it
15:01:37 <monochrom> f5x0  p1  = putChar p1 ?
15:01:41 <timthelion> this generated code isn't the easiest to read.
15:01:48 <timthelion> yes, that is what I need to change
15:02:10 <monochrom> ok, next, "if p1  then putChar  'n' else return []" what does it look like to you?
15:02:41 <timthelion> monochrom: are you saying that is still wrong?
15:02:50 <monochrom> or a simpler version, "if p1 then return () else return []"
15:03:34 <timthelion> monochrom: aha, I see what you are saying.  That's tricky :D
15:04:24 <ddarius> A/=B as the famous sequel to A=B.
15:05:33 * ddarius should finish reading A=B.
15:06:11 <ddarius> @google wgrep
15:06:13 <lambdabot> http://sysunconfig.net/unixtips/wgrep.txt
15:08:50 <zhulikas> @hoogle (a -> m b) -> [a]
15:08:50 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
15:08:50 <lambdabot> Control.Monad.Trans.Cont runContT :: ContT r m a -> (a -> m r) -> m r
15:08:51 <lambdabot> Control.Monad.Cont runContT :: ContT r a -> (a -> m r) -> m r
15:09:16 <zhulikas> @hoogle (a -> m b) -> [a] -> m [b]
15:09:16 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:09:17 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:09:17 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
15:09:30 <zhulikas> @hoogle (a -> m b) -> [a] -> [m b]
15:09:30 <lambdabot> Test.QuickCheck.Arbitrary shrinkList :: (a -> [a]) -> [a] -> [[a]]
15:09:31 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
15:09:31 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
15:09:37 <zhulikas> hmm, probably mapM :|
15:11:48 <zhulikas> whoa
15:11:49 <zhulikas> it compiles!!!
15:11:52 <zhulikas> \o/
15:14:48 <gentleben> there better not be another stream api after conduits
15:15:10 <gentleben> porting all my enumerator code is annoying
15:15:24 <monochrom> haha
15:16:48 <gentleben> we wrote a ton of custom enumerators and enumeratees
15:17:29 <mm_freak> gentleben: if the code works, why don't you just stick with it?
15:18:06 <mm_freak> i'm pretty sure conduits are not the end of the road
15:18:19 <Ralith> Can simple multi-parameter typeclasses (lacking fundeps and type families) be implemented without issue in a traditional constraint-based type system?
15:19:54 <applicative> gentleben, what you haven't moved on to pipes? The api seems a little more stable.....
15:19:58 <byorgey> Ralith: doesn't seem too hard
15:20:09 <gentleben> hehe
15:20:23 <Ralith> that was my understanding, but I'm pretty shakey on the formalizms so I wanted to be sure before I embarked on a doomed project.
15:20:30 <gentleben> mm_freak: upgrading to the current AWS package
15:20:30 <Ralith> formalisms*
15:20:36 <Ralith> thanks
15:20:42 <gentleben> all the rest of the code I am leaving
15:20:47 <byorgey> applicative, gentleben: I hear the new 'sliuces' package is even better
15:20:52 <byorgey> *sluices
15:20:58 <gentleben> hehe
15:21:00 <stulli> monochrom: I'm not sure i could get used to that indentation style, but thanks for the hint, i'll try the other modes
15:21:08 <gentleben> just what the world needs
15:21:24 <applicative> sluices, that's the ticket.
15:27:44 <aristid> gentleben: you use the aws package? which APIs?
15:28:01 <gentleben> well the world needs a few more different packages that no one uses
15:29:32 <edwardk> byorgey: heh, we have another model for iteratees we've been playing with here at the office. lets make the space even more crowded!
15:30:16 <byorgey> edwardk: I was joking about sluices.  But yeah, we still seem to be in the proliferation/exploration phase
15:30:44 <gentleben> aristid: we use sqs and s3, dropped simple db cause it sucks
15:30:51 <gentleben> not the api, sampled itself
15:30:58 <edwardk> byorgey: heh, i may steal that name. i kinda like it better than 'interestees' ;)
15:31:03 * applicative has heard about this crazy new idea 'lazy io', he thinks they call it.
15:31:15 <byorgey> edwardk: feel free!
15:31:36 <byorgey> edwardk: yeah, 'interestees' is not great
15:31:43 <applicative> aquaducts
15:32:18 <applicative> that's if you use a lot of lifts to get up to them.
15:34:36 <UzbeK> is there any free bnc?
15:34:37 <gwern> applicative: lazy io could let us abstract over the chunking and manual IO management of iteratees! brilliant!
15:35:08 * ddarius would think BNC connectors are cheap enough as is.
15:35:53 <gwern> UzbeK: of course not, people would abuse the hell out of it
15:37:15 <mm_freak> gentleben: i'm probably not helping with this remark, but in case there is no time to update the code, you can add an upper bound on the version number of a cabal dependency
15:39:11 <gentleben> mm_freak: yeah. we are upgrading our packages as part of moving to 7.4.1. It turns out that lots of other packages need to be at specific versions to make those kind of things work
15:39:39 <gentleben> and with thousands of lines of code we try to keep versions somewhat uniform
15:41:21 <ehy_> > (+ 1) <$> [1,2]
15:41:22 <lambdabot>   [2,3]
15:41:38 <ehy_> > (+) <$> [1,2] <*> [1,2]
15:41:39 <lambdabot>   [2,3,3,4]
15:42:01 <ehy_> (+) <$> 1 <*> 2
15:42:07 <ehy_> > (+) <$> 1 <*> 2
15:42:07 <lambdabot>   No instance for (GHC.Num.Num (f a))
15:42:07 <lambdabot>    arising from a use of `e_112' at <in...
15:42:25 <ehy_> > (+) <$> [1] <*> [2]
15:42:26 <lambdabot>   [3]
15:43:03 <ehy_> > foldMap (\_ -> []) [1..5]
15:43:04 <lambdabot>   Not in scope: `foldMap'
15:43:13 <ehy_> > Data.Foldable.foldMap (\_ -> []) [1..5]
15:43:14 <lambdabot>   []
15:43:24 <ehy_> > Data.Foldable.foldMap (\x -> [x, x]) [1..5]
15:43:24 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
15:43:35 <applicative> > let f =  (+) <$> 1 <*> 2  in f 17
15:43:36 <lambdabot>   3
15:44:27 <mm_freak> > mapM (\x -> [x, x]) [1..5]
15:44:28 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1...
15:44:34 <mm_freak> uh
15:44:42 <mm_freak> > concatMap (\x -> [x, x]) [1..5]
15:44:43 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
16:00:28 <hpaste> “Joey Adams” pasted “Fun with catchSTM” at http://hpaste.org/64682
16:00:43 <JoeyA> Does STM have rollback semantics when throwSTM and catchSTM are used?  Based on my little test program, it seems that it does.
16:01:38 <Enigmagic> JoeyA: that's my understanding
16:03:06 <JoeyA> This is informative: http://darcs.brianweb.net/testsuite/tests/ghc-regress/concurrent/should_run/conc061.hs
16:11:02 <otters> @pl \x -> x*x
16:11:03 <lambdabot> join (*)
16:28:39 <rasfar> when "warrenharris_ is now known as warrenharris" is the most interesting message in 10 minutes on a channel of 870 that's just spooky...
16:29:21 <rasfar> (sorry, ybit2 is now known as yottabit has you beat,  but somehow missed that one)
16:29:40 <shergill> heh
16:31:12 <Jafet> Silence is golden; duct tape is silver.
16:32:38 <rasfar> i suppose there's no point asking about semilattice join with SYB again?...
16:33:13 <rasfar> copumpkin! you would know....
16:33:19 <copumpkin> ?
16:33:23 <rasfar> do you use syb?
16:33:25 <copumpkin> nopr
16:33:45 <rasfar> aw shucks!
16:34:13 <rasfar> (do you use biplate?)
16:35:39 <ddarius> copumpkin: Want to go to random new food place that is awkward for you to get to and relatively convenient for me and whose quality is unknown?
16:37:10 <shachaf> That sounds like fun.
16:38:20 <mikeplus64> @pl (\a -> display a >> print a) b
16:38:20 <lambdabot> display b >> print b
16:38:29 <mikeplus64> @pl (\a -> display a >> print a) =<< b
16:38:29 <lambdabot> liftM2 (>>) display print =<< b
16:38:37 <mikeplus64> @unpl (\a -> display a >> print a) =<< b
16:38:38 <lambdabot> (b >>= \ a -> (display a) >> (print a))
16:38:43 <mikeplus64> neat
16:42:32 <copumpkin> ddarius: would Sunday night work for you? I can't tonight
16:42:53 <copumpkin> but yeah, I love going to food places that are awkward for me to go to and relatively convenient for you
16:42:56 <copumpkin> :)
16:45:43 <DoctorSmaug> How do you generate an infinite list of strings from shortest to longest?
16:46:07 <Jafet> > iterate (":-) "++) ""
16:46:07 <Botje> generate all strings of length 1, then all of length 2, and so on
16:46:09 <lambdabot>   ["",":-) ",":-) :-) ",":-) :-) :-) ",":-) :-) :-) :-) ",":-) :-) :-) :-) :-...
16:46:12 <DoctorSmaug> e.g. ["a","b".."z","aa","ab"..]
16:46:34 <byorgey> DoctorSmaug: is this homework? or you are just curious?
16:46:43 <byorgey> someone was just asking about that same problem the other day
16:47:41 <copumpkin> well, in that case I'll put my beautiful solution awat
16:48:32 <Jafet> > concat $ liftM2 ( :) ['a'..'z'] `iterate` [""]
16:48:33 <lambdabot>   ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r"...
16:48:40 <copumpkin> > [0..] >>= (`replicateM` ['a'..'z']) -- fine
16:48:41 <lambdabot>   ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r"...
16:49:12 * Jafet ongoader
16:49:56 <shachaf> copumpkin: What about food places that are awkward for you and relatively convenient for me?
16:50:02 <copumpkin> > elemIndex "dan" ([0..] >>= (`replicateM` ['a'..'z']))
16:50:03 <lambdabot>   Just 2744
16:50:10 <shachaf> Also, there are a bunch of strings that your list doesn't contain.
16:50:12 <shachaf> Like (repeat 'a')
16:50:22 <copumpkin> infinite strings are lame
16:50:30 <copumpkin> > elemIndex "jafet" ([0..] >>= (`replicateM` ['a'..'z']))
16:50:32 <lambdabot>   Just 4591542
16:50:58 <Jafet> I am more than just a number
16:50:59 <shachaf> copumpkin: Aren't you just Mr. Countable?
16:51:14 <ddarius> copumpkin: Yeah, I don't actually know when the place closes, so it may be too late for you to get there and eat.
16:51:16 <ddarius> anyway
16:52:13 <DoctorSmaug> is there a non-monad way of doing that?
16:52:24 <shachaf> I recommend that you go have lunhc at Blue Planet Natural Grill in Omaha, NE.
16:52:36 <copumpkin> DoctorSmaug: inline the monad operations
16:52:42 <shachaf> DoctorSmaug: No. Every way of doing that will involve a type that's an instance of Monad.
16:52:43 <byorgey> DoctorSmaug: sure.  there's nothing magical about the list monad, you can write the same algorithm without using it.
16:53:09 <Jafet> DoctorSmaug: using Monad is the only way of making sure we don't accidentally do your homework
16:53:18 <copumpkin> lol
16:53:22 <DoctorSmaug> It's not homework, trust me
16:53:22 <byorgey> although as shachaf points out you will still be using it without knowing.
16:53:59 <shachaf> Trust him, he's a doctor!
16:54:05 <shachaf> Doctors don't get homework, right?
16:54:13 <byorgey> DoctorSmaug: step 1: write a function   Int -> String  that generates all strings containing 'a'..'z'  which are of the given length
16:54:24 <byorgey> DoctorSmaug: step 2: map it over [1..]  step 3: concat
16:55:07 <DoctorSmaug> thanks :)
16:55:40 <monochrom> I never care whether it is homework or not
16:55:41 <shachaf> By the way, you presumably want [minBound..maxBound], not  ['a'..'z']
16:55:48 <shachaf> If it's generating all Strings.
16:56:41 <DoctorSmaug> Well they're actually going to be variable names
16:56:50 <DoctorSmaug> I'm building a JavaScript compressor
16:57:03 <DoctorSmaug> I'm in the process of compressing variable names
16:57:08 <Jafet> Content-Encoding: gzip
16:57:10 <monochrom> then ['a'..'a'] is enough
16:57:21 <Jafet> Best javascript compressor
16:57:30 <monochrom> oh, compress? then you need more than ['a'..'z']
16:57:41 <Eduard_Munteanu> > length ([minBound..maxBound] :: [Char])
16:57:42 <lambdabot>   1114112
16:58:25 <shachaf> If you want to pick variable names optimally you can still do better than ["a",..,"z","aa"..] :-)
16:58:48 <DoctorSmaug> well I'm going to include numbers etc...
16:58:55 <DoctorSmaug> Did you have anything else in mind?
16:59:21 <monochrom> in a javascript identifier, the first char can be any unicode letter, or $, or _, or \ unicode-escape-sequence
16:59:28 <Jafet> I'm sure there will be javascript programs that break your "compressor" no matter how cleverly you write it
16:59:43 <DoctorSmaug> Why Jafet?
16:59:49 <monochrom> but I suppose unicode-escape-sequence can be very long, so let's ignore that part.
16:59:50 <shachaf> What monochrom said..
16:59:55 <shachaf> s/.$//
17:00:31 <DoctorSmaug> Yes, I'm aware of the id name rules, I just wanted the bare bones function from you guys :)
17:00:47 <monochrom> after that, the remaining chars can be any unicode letter, $, _, any unicode combining mark, any unicode digit, or any unicode connector punctuation
17:01:24 <monochrom> I mention all these because if you want the shortest lengths, you must use the largest character palette
17:01:40 <DoctorSmaug> Yup, will do
17:02:08 * ddarius recommends using the "character palette" "o".
17:02:19 <sohum> o oo = ooo oooo
17:02:21 <Jafet> There are too many ways to make variable names significant in javascript
17:02:48 <monochrom> since there are like hundreds of unicode letters, and usually just tens of identifiers in one source file, you may actually just need one-char identifiers, ever
17:02:49 <DoctorSmaug> I'm going to leave global identifiers untouched.
17:02:53 <ddarius> Indeed, there is a big difference between purity and referential transparency.
17:03:08 <ddarius> Jafet: It's a lost cause.
17:03:40 <DoctorSmaug> I'm only interested in reducing the local ones in functions
17:04:01 <Eduard_Munteanu> Assuming UTF-8, you probably want to use only the first 256 codepoints.
17:04:05 * shachaf wonders what "purity" is.
17:04:15 <ddarius> shachaf: You're not the only one.
17:04:24 <ddarius> @google "What is a purely functional language"
17:04:25 <lambdabot> http://wotan.liu.edu/docis/lib/cilt/rclis/dbl/jfulop/(1998)8%253A1%253C1%253AWIAPFL%253E/www.cs.uoregon.edu%252F~sabry%252Fpapers%252FpurelyFunctional.ps.gz%252Fsabry98what.ps
17:05:02 * ddarius huggles pure functions that can't be written in purely functional languages.
17:05:14 <Jafet> Not dysfunctional
17:05:18 * Eduard_Munteanu wonders why stuff like Javascript isn't compiled though
17:05:35 * Jafet wonders why people think it isn't
17:05:47 <Eduard_Munteanu> Ok, it doesn't make that much sense for HTML which is already tree-like, but for JS...
17:05:48 <ddarius> Jafet: I think he means before being sent over the wire.
17:05:53 <copumpkin> ddarius: is it against the law to write them!?
17:05:54 <DoctorSmaug> I think he means before it is transfered.
17:05:55 <Eduard_Munteanu> Yeah, what ddarius says.
17:06:08 <sohum> isn't that what NaCl is meant to do?
17:06:16 <monochrom> chrome and IE compile javascript. firefox may, too
17:06:23 <ddarius> monochrom: Yes, it does.
17:06:34 <Jafet> Oh, you want browsers to agree on a standard for compiled javascript?
17:06:40 <sohum> monochrom: client side, though
17:06:40 <Eduard_Munteanu> monochrom: I don't mean JIT-ing it or anything, just receiving bytecode from the server
17:06:41 <parcs`> ddarius: like what?
17:06:54 <parcs`> 'pure functions that can't be written in purely functional languages'
17:07:12 <Eduard_Munteanu> Jafet: well, they could have agreed on a better representation in the first place, I guess.
17:07:16 <monochrom> our society is not mature enough to discuss a standardized javascript bytecode
17:07:23 <thoughtpolice> monochrom: safari does as well
17:07:46 <Jafet> You're assuming they've explicitly agreed on anything.
17:07:59 <thoughtpolice> and opera. just about every major browser does it these days, even on mobile devices safari and the android browsers do jitting
17:08:02 <Eduard_Munteanu> Well, whoever pushed it in the first place :D
17:08:16 <Jafet> No one ever agreed on javascript, other browsers imitated it to catch up with netscape
17:08:35 <geekosaur> there *is* ecmascript
17:08:43 <Jafet> ...which isn't javascript
17:08:49 <geekosaur> I would not want to rely on it as working in a browser though
17:10:54 <ddarius> parcs`: Implement a function, called f, with this specification: f :: ((() -> ()) -> ()) -> Bool; f ($()) = True; f (const ()) = False; f undefined = undefined.  This is a monotonic (i.e. computable) well-defined, pure function.
17:11:46 <ddarius> It's also quite easy to implement with effects.
17:13:14 <sohum> ddarius: what does "f($()) = True" mean?
17:13:31 <Eduard_Munteanu> :t ($ ())
17:13:32 <lambdabot> forall b. (() -> b) -> b
17:13:36 <sohum> oh, right
17:14:02 <Jafet> Is it really computable?
17:14:39 <Jafet> How can ($()) be distinguished from (const())?
17:15:02 <ddarius> > undefined $ ()
17:15:03 <lambdabot>   *Exception: Prelude.undefined
17:15:07 <ddarius> > const () undefined
17:15:07 <lambdabot>   ()
17:15:11 <ddarius> Seem distinguishable to me.
17:15:27 <Jafet> But not in the language
17:15:37 <Jafet> So in which language are they distinguishable
17:15:45 * Eduard_Munteanu wants spoon as a primitive :P
17:16:22 <ddarius> Jafet: Just because you don't have a decidable test to distinguish two things doesn't make them observationally equivalent.
17:17:00 <Jafet> If there is no decidable test to distinguish two things, as you say, then distinguishing them is not computable
17:17:20 <Jafet> I'm confused by what exactly you mean.
17:17:27 <ddarius> Jafet: There is a decidable test in this case.
17:17:45 <ddarius> You just can't implement it purely functionally.
17:18:16 <ddarius> One way is already indicated by my example and expanded upon by Eduard_Munteanu.
17:18:33 <quintessence> ddarius: I'd call that non-total even if it counts as decidable
17:19:29 <ddarius> quintessence: The function is defined on all defined inputs.  People don't normally consider a function "not total" if it is strict.
17:19:37 <Jafet> When talking about computation, I consider functions as their computable definitions, and I find it strange if you don't
17:20:12 <Jafet> So there are many possible representations of ($()) and (const()), and it is not possible to distinguish them
17:20:30 <ddarius> Jafet: So you consider () and undefined equivalent?
17:20:58 <Jafet> (from eg. a fourth value of (()->()), which is const undefined)
17:21:27 <ddarius> Jafet: I say nothing about what the function should do on that input, but, absent seq, const undefined is equivalent to undefined.
17:21:29 <Eduard_Munteanu> I think ddarius means it gives you those results when passed exactly those values.
17:21:40 <Eduard_Munteanu> (and dontcare otherwise)
17:22:02 <quintessence> ddarius: oh, yes, the function you're looking for is total, just not the apply to undefined procedure for "distinguishing" those two values
17:22:24 <ddarius> Absent seq, there is no "otherwise."  There are only three "pure" values of type (() -> ()) -> ().
17:23:14 <ddarius> quintessence: If you catch the exception, there is nothing "not total" about it.  I mean, if you passed in fix id it wouldn't work, but undefined isn't fix id.
17:23:29 <Eduard_Munteanu> Oh, by looking at how they behave.
17:23:59 <ddarius> It's quite easy to characterize what this function does.  It tests whether its argument uses its argument.
17:25:11 <Jafet> ddarius: I just don't understand how computability is involved here, because the behaviour of a function is not the same thing as the behaviour of a computer evaluating a definition of the function
17:25:43 <Jafet> Perhaps there is a standard model of computability for monotonic functions that I don't know about
17:25:44 <rwbarton> is that function (specification) really monotone?
17:26:07 <ddarius> Jafet: The only reason I even mentioned computability is to be clear that I'm not asking for an impossible function like f _|_ = True; f _ = False
17:26:42 <Jafet> Whether your function is impossible depends on the computer, and I'm having trouble imagining a computer on which it is possible.
17:27:01 <ddarius> Jafet: The term "monotonic" comes from the theory of continuous partial orders (CPOs), which is probably the oldest, non-syntatic mathematical theory for the untyped lambda calculus.
17:27:39 <ddarius> Jafet: It's a stupid simple function to implement in any language with effects.
17:29:01 <Jafet> I think you're imagining that the class of (Haskell) functions with the same behaviour as ($()) consists only of the (Haskell) function defined by ($())
17:29:20 <Eduard_Munteanu> ddarius: mm, wouldn't it work for the impossible example then?
17:29:44 <Jafet> And not, for example, (turnThisIntoAHaltingProblem($()))
17:29:44 <ddarius> Eduard_Munteanu: I don't know what you mean, what tould work for what impossible example?
17:30:14 <Eduard_Munteanu> I could e.g. use spoon to write f _|_ = True; f _ = False.
17:30:48 <Jafet> spoon cannot solve the halting problem
17:30:57 <Jafet> (What is _|_?)
17:31:02 <Eduard_Munteanu> Ah, fair.
17:32:01 <ddarius> Jafet: Your statement doesn't make sense unless you are distinguishing different expressions for the same function.  Otherwise you are saying "I think you are imagining {($())} consists only of ($())."
17:32:49 <ddarius> At any rate, even if you want to distinguish different expressions for the same function, I didn't say anything about them.  You only need to get the semantics I listed for the expressions I wrote.
17:34:18 <Jafet> Determining whether a computation has the behaviour of ($()) is undecidable. I assume that's what you mean when you say f ($()) = True; return True for any computation equivalent to ($()).
17:34:58 <ddarius> Jafet: See my last statement.
17:35:23 <quintessence> Jafet: you're allowed to diverge if you're passed something other than (const ()) or ($ ())
17:35:34 <Jafet> Okay, then it's easy if you can deconstruct functions in your purely functional language.
17:35:36 <ddarius> But, -by definition-, everything observationally equivalent to ($()) will produce the same result.
17:38:58 <quintessence> hmm, effects let you get n back out of \f -> foldr (.) id (replicate n f) ()
17:39:03 <ddarius> Jafet: That would be one extremely destructive way to extend a purely functional language to handle this.  You could also add this function as a primitive.
17:40:07 <Jafet> Well, I'm not sure why languages don't have this feature.
17:40:36 <Jafet> Perhaps some old lisps did
17:40:46 <ddarius> Jafet: Because it reduces observational equivalence to the trivial relation and -completely- destroys referential transparency.
17:41:25 <ddarius> Jafet: Javascript does, to some extent, hence why I assume you were advising DoctorSmaug as you were.
17:43:08 <ddarius> Using different wording, adding that would make every non-trivial equational rule invalid.
17:43:30 <Mathnerd314> ddarius: you can still define equivalence classes
17:44:11 <Mathnerd314> no two 1's are the same, but they are equal under addition, multiplication, and your other favorite operators
17:44:37 <Jafet> I can't see how it breaks referential transparency
17:44:47 <Jafet> Sure, functions are not so equivalent any more
17:44:48 <ddarius> Mathnerd314: Sure, you could talk about things other than observational equality, but those aren't relevant to the semantics of your language.
17:45:17 <ddarius> Jafet: You probably can't see that because you equate referential transparency with purity.
17:46:30 <Jafet> Or perhaps because I was thinking in applicative order
17:46:41 <Eduard_Munteanu> Mmm, if that's anything like reflection on the AST of that value, it seems rather harmless. I mean, there's something like than in Agda for instance.
17:46:52 <Jafet> You're probably right if non-strict evaluation is used
17:47:04 <Eduard_Munteanu> Oh, wait, not exactly.
17:47:08 <ddarius> Order of evaluation is irrelevant.
17:47:41 <Eduard_Munteanu> You'd quote terms in the caller there.
17:47:56 <Jafet> Could you give an example, ddarius?
17:48:02 <ddarius> An example of?
17:48:16 <Jafet> An expression that no longer has referential transparency
17:48:31 <quintessence> Jafet: you could presumably use this facility to distinuish (+1), \x -> 1 + x, and succ
17:48:36 <ddarius> Jafet: Every expression loses it.  That's what "completely" means.
17:48:58 <Jafet> quintessence: yes, that would be the whole point of this language feature
17:49:12 <ddarius> You cannot inline a name for its referent because I might do a case analysis on the name which is rather different than its referent.
17:50:07 <Jafet> Ah, I hadn't considered free variables, if that's what you're referring to
17:50:54 <Eduard_Munteanu> How evil is that anyway>
17:50:58 <Eduard_Munteanu> s/>/?/
17:51:15 <ddarius> It has nothing to do with free variables.  Even the examples quintessence provided that you validated as being what you mean suffer it.  succ = \x -> 1 + x, but with your extension succ and \x -> 1 + x would be inequivalent.  I could not replace succ with its definition.
17:51:37 <Eduard_Munteanu> IOW, can't you still do inlining somewhere at a lower level?
17:52:29 <ddarius> Eduard_Munteanu: You can certainly do analyses, probably most profitably whole-program analyses, and recover the fact that various equations actually do hold of that particular program.
17:54:07 <Jafet> I should clarify that what I said only applies to a language with primitive combinators and no free variables
17:54:41 <Jafet> So succ wouldn't exist, only (+1) (which is \x -> x + 1) and \x -> 1 + x
17:54:52 <Jafet> Sorry for the confusion
17:54:55 <ddarius> If you have no variables, or more general, no names, then your language is trivially referentially transparent.
17:55:24 <Jafet> Isn't that wunderbar!
17:55:28 <ddarius> Which is another way you can have a wildly "impure" language that is referentially transparent.
17:56:18 <ddarius> Though what you were originally describing, or so it seemed, is the other extreme.  A language that is pure but wildly non-referentially transparent.
17:59:10 <Jafet> Okay, so both languages can implement the distinguisher but neither is a purely functional language
17:59:35 <Jafet> I have the feeling that the distinguisher problem cannot be expressed in the semantics of a purely functional language, anyway
18:00:10 <ddarius> You haven't defined "distinguisher."
18:00:20 <ddarius> Or "distinguisher problem."
18:00:36 <Jafet> Your function f :: (() -> ()) -> Bool.
18:01:39 <ddarius> That's not it's type.
18:02:04 <ddarius> Also, your example is purely functional (arguably) even without being restricted to "primitive combinators."
18:02:20 <ddarius> I've also listed another way to get a purely functional language to solve this problem.
18:02:32 <Jafet> Oops
18:02:33 <ddarius> So my original statement was mildly extreme.
18:02:45 <monochrom> http://ro-che.info/ccc/09.html :)
18:03:11 <quintessence> ddarius: what was the purely-functional solution?
18:03:49 <ddarius> Add it as a primitive.  It is a pure function.  There are better functions that can be added as primitives that would solve this problem generally though.
18:04:35 <ddarius> But you can amend my original statement to be "in the (suitably sugared) lambda calculus."
18:07:51 <Eduard_Munteanu> Heh, didn't know about the CCC comics.
18:08:21 <ddarius> One thing to note about this example is it illustrates how little is known about third (and higher) order functions.
18:16:38 <adit> Has anyone used the LLVM bindings for Haskell?
18:16:50 <Enigmagic> adit: yes
18:17:08 <adit> How did you get started? I'm trying to follow http://llvm.org/docs/tutorial/
18:17:35 <Enigmagic> i wrote two compilers with the regular C++ headers
18:17:44 <Enigmagic> then i learned how to use the LLVM bindings for Haskell
18:18:05 <mnestic> how can I call a function just for the side effects?  like the ignore function in F#
18:18:17 <Enigmagic> mnestic: _ <- fun
18:18:37 <Enigmagic> or if the return type is IO () (or whatever) you don't need the _ <-
18:18:41 <JoeyA> @quote LLVM
18:18:41 <lambdabot> JoeyA says: LLVM: The easy-to-use compiler infrastructure nobody knows how to use.
18:18:51 <adit> Enigmagic: did you use any resources? or just read through the examples?
18:18:55 <adit> LOL
18:19:05 <Enigmagic> adit: they didn't have examples really back then
18:19:24 <Enigmagic> adit: mostly i looked at the output of clang/llvm-gcc with -emit-llvm -S
18:19:43 <adit> ah alright
18:19:47 <Enigmagic> and this one other trick:
18:20:00 <mnestic> is there a way to say '_ <-' in english? like wildcard something?
18:20:10 <Enigmagic> adit: http://llvm.org/demo/index.cgi
18:20:21 <Enigmagic> adit: select the 'LLVM C++ API code' target
18:20:31 <Enigmagic> (they added this a couple years ago)
18:20:46 <adit> oh nice
18:20:49 <adit> wow
18:21:16 <Enigmagic> mnestic: i dunno
18:21:24 <Enigmagic> 'discard the result' ?
18:21:42 <mnestic> no, so _ is wild card right, what is the name of the <- syntax?
18:21:55 <adit> lambda?
18:22:09 <adit> oh
18:22:12 <mnestic> \ is lambda, right?
18:22:18 <Enigmagic> \ is lambda
18:22:20 <Enigmagic> <- is bind
18:22:20 <adit> yeah, ignore me
18:22:21 <adit> :P
18:22:23 <adit> bind
18:22:24 <mnestic> bind, thank you
18:22:28 <quintessence> mnestic: you don't have to say _ <- something.  In a do-block a line that isn't a binding does the expression for its effects, and outside of a do-block nothing has side effects
18:22:44 <adit> you could also do func1 >> func2
18:22:58 <Enigmagic> quintessence: yep, but with -Wall it will complain without the _ <- :)
18:23:00 <adit> that would toss away the result of func1
18:23:05 <mnestic> could I do funToIgnore >> return ()
18:23:12 <adit> yup
18:23:41 <adit> that's the same as do {funToIgnore; return ()}
18:25:00 <jmcarthur> :t Control.Monad.void
18:25:01 <lambdabot> Not in scope: `Control.Monad.void'
18:25:03 <jmcarthur> aw
18:25:25 <jmcarthur> in the current base, Control.Monad.void :: Functor f => f a -> f ()
18:26:30 <mnestic> thanks for all the solutions
18:31:51 <totimkopf> how well does Haskell scale for web applications?
18:32:06 <mnestic> haskell is web scale
18:32:11 <shachaf> Up to 11.
18:32:14 <mnestic> ;-)
18:32:48 <totimkopf> it's definitely faster than Java/PHP/C#, right?
18:33:03 <totimkopf> too bad there isn't a mod_haskell for apache…we have to resort to fastCGI?
18:33:39 <shachaf> It's all the fasts, so absolutely.
18:34:06 <shachaf> totimkopf: (Your question is too vague for anyone to give it a reasonable serious answer, so you're getting joke answers instead.)
18:34:14 <ddarius> Languages don't have speeds, even implementations don't, programs are much closer to having speeds.
18:34:32 <ddarius> I guarantee I can write a Haskell web program that is slower than a PHP equivalent.
18:35:00 <shachaf> Even if the PHP equivalent is non-terminating?
18:35:04 <totimkopf> is it easier to write slower web apps in haskell than in PHP?
18:35:17 <ddarius> That's a function of the programmer.
18:35:36 <shachaf> Are we having a "who can write the slowest web app" competition?
18:35:41 <irene-knapp1> > fix error
18:35:42 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:35:45 <irene-knapp1> ^ slowest web app
18:35:48 <shachaf> I think the traditional answer is "switch horses" or something like that.
18:36:17 <zerax> The only question you need the answer to is, 'is Haskell fast enough for my web application.'
18:36:25 <otters> yen
18:36:26 <otters> yes
18:36:32 <shachaf> zerax: Refer to ddarius's first line above.
18:36:39 <tibbe> totimkopf: it's fast enough :)
18:36:40 <ddarius> zerax: Refer to shachaf's most recent line.
18:36:53 <zerax> ;)
18:36:53 <mitchw> wow, I think the last 10-20 lines has just given me reason to move on...
18:37:16 <totimkopf> :)
18:37:22 <shachaf> The last 10-20 lines give you a lot more information about #haskell than about Haskell.
18:37:28 <shachaf> I suppose that could be a factor in making your decision.
18:37:35 <mitchw> shachaf: exactly.
18:37:47 <tibbe> totimkopf: we measured 20,000 requests per core on simple benchmarks. A real app wouldn't be close to that but it should be fast enough for you.
18:38:15 <tibbe> totimkopf: I'd recommend looking at either Snap or Yesod, two of the major Haskell web frameworks.
18:38:25 <tibbe> totimkopf: They have benchmarks on their respective project pages.
18:38:37 <ddarius> tibbe: Unless you write your app stupid-like because you know nothing about programming in Haskell and you get 2 requests per core.
18:38:49 <totimkopf> :D
18:39:25 <tibbe> ddarius: sure
18:39:35 <tibbe> ddarius: learning the language is a prerequsite
18:40:07 <totimkopf> I guess the main benefit of using Haskell would be speedy production
18:40:10 * shachaf likes "requests per core".
18:40:14 <totimkopf> (if the programmer knew Haskell well enough)
18:40:29 <totimkopf> (in the case of a web application)
18:40:49 <mnestic> seamicro servers for request per core lol
18:42:54 <tibbe> totimkopf: yes
18:43:13 <tibbe> totimkopf: but even more important, once you have a large application you will still feel confident changing it without breaking everything
18:43:30 <tibbe> totimkopf: this is my experience from working on YouTube (which is a very large Python application)
18:43:50 <tgeeky_> man. Just when I thought one of my idols (Thomas Jefferson) couldn't get any better, it turns out he invented macaroni and cheese!@
18:43:59 <tgeeky_> (sort of)
18:44:29 <mnestic> tibbe: youtube uses haskell, or you feel less confident when working on the python in youtube?
18:44:54 <tgeeky_> mnestic: I highly doubt YouTube uses haskell :o
18:45:03 <totimkopf> imagine if youtube did
18:45:04 <totimkopf> :o
18:45:06 <tibbe> mnestic: youtube doesn't use haskell. I feel less confident when working in a large Python code base. Big refactorings feel almost impossible
18:45:21 <totimkopf> ooo, refactoring...
18:45:22 <ddarius> totimkopf: Facebook does.
18:45:29 <tgeeky_> ddarius: (sort of)
18:45:36 <tgeeky_> ddarius: wasn't bos the first adopter over there?
18:45:37 <ddarius> And Google does in other areas.
18:45:38 <totimkopf> what does Facebook use  haskell for?
18:45:55 <ddarius> totimkopf: Ironically, for refactoring their PHP.
18:46:06 <totimkopf> eh, that's strange
18:46:17 <totimkopf> why not just make the push to haskell :D
18:46:34 <mnestic> totimkopf: never push for a full rewrite!
18:46:38 <tgeeky_> totimkopf: I'm sure that's the first thing on their list after 1) make huge amounts of money off an IPO
18:46:39 <homie> ghc is for php ?
18:46:43 <homie> wtf.....
18:46:44 <tgeeky_> homie: no
18:47:05 <homie> well, the above almost reduces it to that .......
18:47:10 <tgeeky_> homie: haskell is a good language to inspect, evaluate, and transform languages in general (including php)
18:47:38 <tgeeky_> ddarius: but... is is true that Brian was the first person to use haskell @ facebook?
18:47:53 <ddarius> I doubt it, but I don't know.  I also don't know who Brian is.
18:47:58 <ddarius> Maybe you meant Bryan.
18:48:11 <tgeeky_> ddarius: yeah. I just spelled his name wrong. bos.
18:48:58 <totimkopf> would Haskell be awesome for computational linguistics then?
18:49:15 <totimkopf> s/awesome/ideal
18:49:17 <tgeeky_> totimkopf: yes, haskell can do that.
18:49:31 <totimkopf> bioinformatics?
18:49:32 <Mathnerd314> augur is doing stuff with that, IIRC
18:49:42 <tgeeky_> totimkopf: there are dozens of packages for bioinfo
18:49:45 <Mathnerd314> (comp. ling., not bioinfo)
18:49:50 <tgeeky_> totimkopf: there are probably a handful for comp ling
18:50:03 <totimkopf> wow
18:50:15 <totimkopf> so I should probably start learning Haskell now
18:50:21 <totimkopf> thanks guys
18:52:15 <totimkopf> I'm reading 'Learn You a Haskell For Great Good'
18:53:25 <edwardk_> totimkopf: yes haskell is good of both of those domains
18:56:20 <Jafet> "Computationally assisted linguistics" may be more appropriate
19:59:12 <danharaj> oh man
19:59:15 <danharaj> so uhh
19:59:37 <tgeeky_> ho wat
19:59:42 <danharaj> got a 20x speedup by removing spurious realToFrac calls
19:59:44 <danharaj> OOPS
19:59:47 <edwardk_> danharaj: =)
20:00:03 <danharaj> although to be fair it should be optimized away if the underlying types are identical
20:00:05 <edwardk_> increasing optimization level is pretty good at that as well
20:00:15 <edwardk_> what are you compiling ith?
20:00:17 <edwardk_> er with?
20:00:22 <danharaj> GHC some old version.
20:00:28 <edwardk_> I mean -O2, etc
20:00:33 <danharaj> O2 indeed
20:00:44 <danharaj> I don't think GHC knows that OpenGL floats are the same as Floats.
20:00:51 <edwardk_> it doesn't and can't
20:00:59 <edwardk_> this is one of the things i absolutely hate about HOpenGL
20:00:59 <danharaj> I think it was an open issue actually to add rules so that it does know.
20:01:11 <danharaj> that was many moons ago
20:01:16 <danharaj> I just got back into hacking.
20:02:00 <Elemir> > 08:00 < edwardk_> it doesn't and can't
20:02:00 <lambdabot>   Not in scope: `edwardk_'Not in scope: `it'Not in scope: `doesn't'Not in sco...
20:02:08 <Elemir> Why can't?
20:02:34 <edwardk_> well, it can't because they aren't the same type
20:02:44 <Elemir> Heh, ok
20:02:54 <edwardk_> FLOATING_TYPE(GLdouble,tyConGLdouble,"GLdouble",CDouble)
20:03:06 <danharaj> What is that pragma you can do
20:03:12 <danharaj> that tells GHC rules for type coercions it can do
20:03:17 <tgeeky_> RULES?
20:03:23 <danharaj> THAT'S TOO LOGICAL
20:03:34 <edwardk_> go go gadget unsafeCoerce ;)
20:03:38 <danharaj> yes indeed
20:03:42 <danharaj> but I thought there was a way to like
20:03:47 <danharaj> tell GHC that a realToFrac is a nop.
20:03:49 <edwardk_> well, the other problem is they don't expose its internals
20:04:04 <edwardk_> in case you might some day execute an opengl platform on a non-existent platform where they don't agree
20:04:12 <danharaj> indeed
20:04:20 <edwardk_> however, in that case they'll have to change the !@)# package anyway
20:04:33 <danharaj> ahaha edwardk_ do you want to tell lispy how you feel :3
20:04:35 <danharaj> he's the maintainer now.
20:04:37 <edwardk_> so i don't see the point in protecting me from myself by making my code 20x slower
20:04:40 <danharaj> I think. He was a while ago.
20:04:43 <edwardk_> i have, he said he'd do something
20:04:50 <edwardk_> i sent him a patch even
20:05:08 <edwardk_> in the meantime i just don't use opengl from haskell or unsafeCoerce my way through
20:05:13 <tgeeky_> aren't they both IEEE whatever?
20:05:25 <danharaj> no
20:05:26 <edwardk_> so in the interest of increasing my safety… they force me to decrease it
20:05:34 <danharaj> opengl is very sketchy about the hardware it demands.
20:05:49 <tgeeky_> well, I just meant the structure of the double or float
20:05:58 <danharaj> it doesn't specify what the float is.
20:05:58 <edwardk_> no, technically there is _an_ argument that can be made that opengl floats may not obey your platform's conventions regarding underflow, etc.
20:06:10 <danharaj> yeah, maybe 20 years ago
20:06:12 <edwardk_> even if they maintain the same shape
20:06:23 <edwardk_> well, to be fair, most gpu's suck at underflow, etc
20:06:37 <danharaj> I suppose that can occur.
20:06:39 <edwardk_> but in practice, the conversion is just wasted time
20:06:52 <danharaj> indeed!
20:07:02 <danharaj> I was wondering why rendering a few hundred squares was chugging like that.
20:07:18 <danharaj> frankly I am a bit concerned I'm still running at only 600 fps emulating a terminal.
20:07:19 <edwardk_> so i can either unsafeCoerce or i can give up 1-2 orders of magnitude worth of performance
20:07:36 <edwardk_> which just makes me sad and angry
20:07:50 <tgeeky_> edwardk_: does using unsafeCoerce actually trigger safe-haskell?
20:08:06 <edwardk_> tgeeky_: yeah i probably lose access to safe haskell as well
20:08:10 <edwardk_> not sure
20:09:00 <edwardk_> in practice i'm usually talking to cuda these days rather than opengl, but sheesh
20:09:10 <tgeeky_> and this isn't the kind of thing that would/could be solved by rewriting the types for both?
20:10:16 <edwardk_> well, we have a lesser issue in that its tied to CDouble, not Double, and there isn't a guarantee that those are the same, is there?
20:10:38 <danharaj> I don't think so.
20:10:40 <danharaj> Or well
20:10:59 <danharaj> yeah I don't think so but really there's virtually no way it's not going to be true on most hardware.
20:11:07 <edwardk_> they are, but what i mean is even if you strip away the GLdouble nonsense you wind up with a CDouble
20:11:57 <tgeeky_> i'm saying, if you were writing haskell` fancypants parallel CUDA and OpenGL aware version, couldn't you write a new "RealDouble" and use it everywhere?
20:12:28 <danharaj> does that sound palatable to you
20:12:31 <edwardk_> sadly they can't just unilaterally fix it to be the same type though, since NHC newtypes aren't unsafeCoerce'able, which leads to all sorts of base silliness
20:12:42 <danharaj> really? gross.
20:13:36 <edwardk_> the whole realToFrac thing makes me hang my head
20:13:53 <edwardk_> lets use non-semantics preserving rewrite rules to fix a broken function!
20:14:43 <edwardk_> > realToFrac (0/0 :: Double) :: Double
20:14:44 <lambdabot>   -Infinity
20:15:07 <edwardk_> ಠ_ಠ
20:15:21 <tgeeky_> that's not even wrong!
20:15:36 <Elemir> > 0/0
20:15:37 <lambdabot>   NaN
20:15:45 <Elemir> sad =(
20:15:57 <edwardk_> realToFrac is just a bad idea that won't die =/
20:18:02 <tgeeky_> I think this is more a problem with the Reals, than doubles, Doubles, CDoubles, etc
20:18:37 <tgeeky_> but that's just like me. blame the mathematics instead of Haskell :O
20:20:28 <Elemir> Reals are invented by physicists
20:20:51 <int-e> there are perfectly non-broken real fields with practical implementations that do not support realToFrac. Q[sqrt(2)], for example.
20:20:54 <Elemir> I think that it's really bad field
20:21:27 <danharaj> Hm I'm increasingly becoming convinced that giving a name to (\x -> (x,x)) will save me quite a bit of typing.
20:21:46 <edwardk_> danharaj: import it from Control.Category.Cartesian its 'diag' iirc
20:21:51 <edwardk_> ;)
20:22:01 <int-e> or call it dup, and define it locally :)
20:22:22 <danharaj> I expect the type of your diag is generalized to all limits :p
20:22:34 <edwardk_> is that a problem?
20:22:40 <rwbarton> > let x = 0/0 :: Double in x == realToFrac x
20:22:41 <lambdabot>   False
20:22:45 <rwbarton> that gives the right answer at least
20:22:47 <danharaj> no, but I'm wondering what its signature looks like.
20:23:18 <edwardk_> pretty boring http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian.html#v:diag
20:23:26 <int-e> > let x = 0/0 :: Double in realToFrac x == realToFrac x
20:23:26 <lambdabot>   True
20:23:44 <edwardk_> that reminds me i need to ship a new version of 'categories'
20:23:52 <int-e> now let's discuss whether that *should* be true or not ;-)
20:24:00 <Elemir> > diag :: k a (p a a)
20:24:01 <lambdabot>   Not in scope: `diag'
20:24:06 <danharaj> I see you're getting increasingly closer to overthrowing (->)'s privilege.
20:24:24 <edwardk_> danharaj: that is to say i was back in 2008 ;)
20:24:43 <edwardk_> been a while since i wrote that
20:24:52 <danharaj> I'm sure you've made great advances since then.
20:25:19 <edwardk_> sure, i now have polykinded versions of some of that stuff
20:25:35 <edwardk_> sadly i can't compile it til we get a syntax for talking about polymorphic kinds explicitly
20:25:40 <danharaj> have they fixed that syntax hack you loathed from the first release?
20:25:45 <danharaj> ah hm.
20:25:47 <edwardk_> no
20:26:05 * edwardk_ is a ray of sunshine tonight
20:26:59 <albel727> it shows.
20:27:35 <edwardk> i blame my laptop disappearing into apple's care with all the code i wanted to work on on it =)
20:28:18 <irene-knapp> could be worse
20:28:18 <albel727> why haven't you backup?
20:28:29 <irene-knapp> I felt so safe - I had just done a full backup for the first time in years
20:28:40 <irene-knapp> but the laptop and the backup drive were sitting right next to each other at the time of the fire :(
20:28:46 <albel727> -_-
20:28:50 <edwardk> i do, more or less, but i'm currently waiting for Xcode to reinstall on my other laptop so i can reinstall ghc, etc.
20:28:50 <irene-knapp> I was only prepared for an electronic catastrophe, not a physical one
20:28:51 <danharaj> :\
20:29:00 <edwardk> irene-knapp: ouch
20:29:09 <irene-knapp> yeah, oh well.  tomorrow we reach that part of the house and I find out if either survived.
20:29:12 <edwardk> irene-knapp: i keep most of my code backed up offsite
20:29:13 <irene-knapp> hopefully.
20:29:26 <irene-knapp> edwardk: my /recent/ code is /mostly/ on my Linode...
20:29:31 <edwardk> yeah
20:29:34 <irene-knapp> edwardk: but since it was manual, unlike Time Capsule, ...
20:29:37 <edwardk> yep
20:29:40 * irene-knapp nods
20:29:41 <albel727> well, it's kinda common sense to separate backups physically, but oh well.
20:29:44 <Rotaerk> hmm I'm kind of surprised not to find a function in hoogle with this signature:  (a->b->c)->(c->d)->a->b->d
20:30:06 <edwardk> my time capsule sits only a few feet from my machine, so if the house burned down, i'd lose both
20:30:18 <MostAwesomeDude> Rotaerk: Doesn't (.) fill that need?
20:30:26 <edwardk> plus, my main machine has many many terabytes worth of misc. stuff that its my only copy of
20:30:28 <misterbeebee> I think there is a grammatical error in the Control.Category.Carteion documentation at the link @edwardk_ posted. "Consequently its coproduct is merely a semigroup, not a monoid as it has no identity, and since we want to be able to describe its dual category, which has this non-traditional form being built over a category with an associative bifunctor rather than as a monoidal category for the product monoid."  Besides being math way
20:30:28 <misterbeebee> over my head, I think it's not actually a grammatical sentende:  "Consequently [clause], and since [clause], which [verb phrase]". There should be something else (another consdequence) after the "and since"
20:30:59 <edwardk> misterbeebee: probably. it was very much stream of consciousness when i wrote it
20:31:26 <edwardk> i take patches. ;) though you probably should submit them to the 'categories' package where that moved
20:31:30 <Rotaerk> MostAwesomeDude, actually I guess to make it more consistent with (.) it should be:  (c->d)->(a->b->c)->a->b->d
20:31:47 <MostAwesomeDude> :t flip (.)
20:31:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
20:32:08 <MostAwesomeDude> Hm, that is not what I thought it would be. Nevermind.
20:32:10 <misterbeebee> edwark_: Well I certainly have no idea what should logically/mathematically come after "and since"!
20:32:27 <Rotaerk> MostAwesomeDude, where (a . b) is a function that can be applied to one argument, (a ??? b) is something that can be applied to two
20:32:38 <Rotaerk> so for instance (swap ??? tuple) 5 6
20:32:42 <Rotaerk> produces (6, 5)
20:32:47 <misterbeebee> (unless the "and since" is just a reason supporting the "consequently" at the beginning of the sentence)
20:33:39 <edwardk> bah, went to patch categories, and i want to fix it up to use the polymorphic kinds, while I'm in there, but i can't
20:34:40 <edwardk> misterbeebee: dumped your comment in my TODO file for the project
20:35:40 <misterbeebee> :t flip ((.) . (.))
20:35:41 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (f1 a) -> (a -> b) -> f (f1 b)
20:36:02 <misterbeebee> that looked like " (a -> a1 -> b) -> (b -> c) -> a -> a1 -> c" in my ghci
20:36:29 <dolio> (.) is defined as fmap in lambdabot.
20:37:02 <MostAwesomeDude> Aha.
20:37:07 <edwardk> misterbeebee: lambdabot doesn't have a standard prelude, it includes a number of 'improvements' that seemed like a good idea to folks a few years ago ;)
20:37:17 <edwardk> @type flip
20:37:18 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
20:37:25 <edwardk> @type (.)
20:37:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:37:36 <misterbeebee> ah
20:37:52 <dolio> flip's fancy type isn't coming into play in this particular case.
20:38:05 <dolio> But fmap's is.
20:38:06 <shachaf> edwardk: But clearly (.) should be (Control.Cateogry..), not fmap, right?
20:38:19 <edwardk> shachaf: cale and i have agreed to disagree on that ;)
20:38:28 <rwbarton> does cale really still think that?
20:38:31 <shachaf> Cateogry. That sounds like particularly terrifying adjective to describe a monster with.
20:38:32 <edwardk> shachaf: he wants it for fmap which he argues is the more common usecase
20:38:52 <Cale> and I spend all day programming in arrows :P
20:39:00 <edwardk> muahahaha
20:39:09 <shachaf> edwardk: To be fair, having a one-character operator for fmap can be nice.
20:39:12 <edwardk> karmic retribution
20:39:16 <edwardk> ;)
20:39:39 <Cale> But (<<<) somehow works better together with the arrow syntax anyway
20:39:56 <dolio> (<<<) is way lower precedence.
20:40:11 <dolio> (.) binds tighter than all the arrow combinators.
20:41:24 <kallisti> what library do you guys recommend for date/time data?
20:42:06 <dolio> I'd probably recommend Data.Time, because it's the only library, I think.
20:42:13 <edwardk> kallisti: you're kinda stuck with 'time'
20:42:13 <kallisti> there's Data.DateTime
20:42:16 <shachaf> What about old-time?
20:42:17 <dolio> Besides the old deprecated one.
20:42:48 <dolio> I don't recommend anything with "old" in the name.
20:42:58 <ivanm> dolio: what about old-locale ?
20:43:04 <ivanm> seeing as how there's no "new" locale?
20:56:20 <kallisti> well, I'm writing a binding for the Selenium 2 API. it has time info in the form of seconds since epoch. so I might just leave it as an integer and then let users use their own datetime formats?
20:58:13 <edwardk> kallisti: probably the 'right' thing to do would be to convert it to a UTCTime
20:59:58 <kallisti> hmmm, there doesn't seem to be a conversion function.
21:00:01 <Elemir> @type posixSecondsToUTCTime
21:00:02 <lambdabot> Not in scope: `posixSecondsToUTCTime'
21:00:16 <kallisti> @hoogle Integer -> UTCTime
21:00:16 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
21:00:16 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:00:17 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
21:00:20 <kallisti> oh, right...
21:00:26 <Elemir> @type Data.Time.Clock.POSIX.posixSecondsToUTCTime
21:00:27 <lambdabot> Data.Time.Clock.POSIX.POSIXTime -> time-1.1.4:Data.Time.Clock.UTC.UTCTime
21:00:27 <edwardk> i gave up understanding 'time' a long time ago
21:00:30 <edwardk> there is a diffTime
21:00:34 <kallisti> ah but UTCTime isn't Num nevermind
21:00:35 <edwardk> there is also a nominalDiffTime
21:00:57 <edwardk> you can make a 'DiffTime' from a number of seconds, but i have no idea how to add it to a UTC Time
21:01:07 <Elemir> 09:00 < lambdabot> Data.Time.Clock.POSIX.POSIXTime -> time-1.1.4:Data.Time.Clock.UTC.UTCTime
21:01:10 <kallisti> Elemir: thanks
21:01:12 <edwardk> however, you can add NominalDateTime
21:01:42 <edwardk> ah
21:01:47 <edwardk> thats it, thanks Elemir
21:01:53 <kallisti> hmmm POSIXTime is a NominalDiffTime.
21:02:08 <kallisti> ah I see. so I can use fromInteger to convert to that.
21:04:55 <kallisti> so, I guess I should use POSIXTime?
21:05:07 <kallisti> or should I convert to UTCTime?
21:05:13 <kallisti> ...time is confusing.
21:07:38 <Elemir> I use UTCTime in same situation in my 9p library
21:07:54 <Elemir> s/in/at/
21:13:14 <JoeyA> I wish I could extract fields from partially-applied data constructors.
21:18:51 * hackagebot copilot-language 0.8 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-0.8 (LeePike)
21:18:53 * hackagebot copilot-libraries 0.5 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-libraries-0.5 (LeePike)
21:19:58 <tomprince> JoeyA: You could probably finish constructing them with undefined, and then match on what you want.
21:20:40 <JoeyA> tomprince: I've thought about doing that from time to time.
21:20:56 <shachaf> tomprince: Not if they're strict in some fields.
21:21:22 <JoeyA> But what if I shove the object somewhere first?  I'd have to update the object there.
21:21:39 <JoeyA> I could make IORefs containing undefined, but then I'd have to use readIORef for every access.
21:22:28 <tomprince> Why do you need to update them? After you finished matching, just use the original value to build what you want.
21:22:34 <JoeyA> The straightforward solution is to stack data constructors (e.g. data Client = Client { clientInitial :: ClientInitial, clientName :: String }, where ClientInitial contains the first two fields.
21:23:47 <tomprince> JoeyA: You might get a more useful answer if you provided more context.
21:24:41 <JoeyA> This is a small example program.  It isn't much of a problem here.
21:25:32 <JoeyA> But the general problem is: when constructing an object with a bunch of fields, you can't leave some of the fields blank until you're ready to fill them.
21:25:35 <tomprince> All the better to post.
21:26:26 <tomprince> Well, there is the record update syntax. Which, depsite its name, doesn't actually modify anything, just returns a copy with the new fields.
21:27:21 <shachaf> tomprince: Once again, that doesn't work with strict fields. :-)
21:28:11 <tomprince> shachaf: Sure. But I think it is a reasonable assumption that that isn't the case.
21:28:57 <shachaf> "People don't ever want to leave a strict field to be filled in later" is a reasonable assumption?
21:30:30 <tomprince> No.
21:32:38 <tomprince> But that somebody working with strict fields could be reasonably be expected to realize that what I am suggesting doesn't work in that case.
21:32:40 <hpaste> “Joey Adams” pasted “Constructing an object piecemeal” at http://hpaste.org/64683
21:33:33 <JoeyA> What's annoying is, if I want to add a bunch of fields to Client, I also have to add a bunch of parameters to serve.
21:34:40 <JoeyA> If there are more steps in the construction, each step has to list out the parameters.  Only when the Client is fully realized do you get the luxury of passing only one thing around.
22:07:42 <kallisti> :t lookup
22:07:43 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
22:08:50 <tomprince> JoeyA: It looks like your structure has a mixture of connection info and connection state.
22:10:02 <tomprince> And also becuase of that, some fields will be valid somethimes, and others at others.
22:14:47 <JoeyA> Thanks for the input
22:15:58 <tomprince> The trick for handling that is to have the state dependent fields as different constructors of a data type, and then have a field of that type in your base type.
22:22:06 <ovechkin> i have a list of strings of the from "Int, Double, Double". is there a concise one liner for converting this to a list of type List[Int, Double, Double]?
22:22:46 <bgamari> Are there any regex implementations on Data.Text?
22:23:08 <Makoryu> > map read ["1, 1, 2", "2, 3, 4"] :: [(Int, Double, Double)] -- ovechkin
22:23:09 <lambdabot>   [*Exception: Prelude.read: no parse
22:23:12 <Makoryu> WHOOPS
22:23:31 <otters> > read "1, 1, 2" :: (Int, Int, Int)
22:23:32 <lambdabot>   *Exception: Prelude.read: no parse
22:23:37 <otters> > read "(1, 1, 2)" :: (Int, Int, Int)
22:23:38 <lambdabot>   (1,1,2)
22:23:47 <otters> snap
22:23:55 <Makoryu> > map (read . \xs -> "(" ++ xs ++ ")") ["1, 1, 2", "2, 3, 4"] :: [(Int, Double, Double)] -- ovechkin
22:23:57 <lambdabot>   [(1,1.0,2.0),(2,3.0,4.0)]
22:24:14 <copumpkin> snap: rhyhtm is a dancer
22:24:15 <ovechkin> oh man
22:24:18 <ovechkin> you guys are quick
22:24:32 <otters> hell yeah
22:24:50 <ovechkin> thanks
22:25:06 <Makoryu> ovechkin: Man Haskell is like... all about taking arbitrary data and just rebuilding it as a different form of data
22:25:20 <Makoryu> Especially if "data" means "code"
22:27:25 <JoeyA> ovechkin: zipWith3, perhaps?
22:27:30 <JoeyA> @type zipWith3
22:27:31 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
22:27:57 <JoeyA> > zipWith3 [1,2,3] [1.0, 2.0, 3.0] [-1.0, -2.0, -3.0]
22:27:57 <lambdabot>   Couldn't match expected type `a -> b -> c -> d'
22:27:58 <lambdabot>         against inferred ty...
22:28:07 <JoeyA> err
22:28:11 <JoeyA> > zip3 [1,2,3] [1.0, 2.0, 3.0] [-1.0, -2.0, -3.0]
22:28:12 <lambdabot>   [(1,1.0,-1.0),(2,2.0,-2.0),(3,3.0,-3.0)]
22:28:18 <JoeyA> @src zip3
22:28:18 <lambdabot> zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs
22:28:19 <lambdabot> zip3 _      _      _      = []
22:28:19 <otters> > zipWith3 (join (+)) [1..3] [1..3] [1..3]
22:28:20 <lambdabot>   No instance for (GHC.Enum.Enum (b -> c -> d))
22:28:20 <lambdabot>    arising from a use of `e_1...
22:28:29 <otters> :t join (+)
22:28:30 <lambdabot> forall a. (Num a) => a -> a
22:28:35 <otters> hm
22:28:39 <otters> that's the opposite of what I wanted
22:28:42 <JoeyA> I was looking for the zip3 = zipWith3 (,,) definition
22:29:52 <kallisti> looks like you found it.
22:37:24 <tomprince> JoeyA: This http://vimeo.com/21564387 talks about that (around 26:30 or so). It is about ocaml, but the ideas are applicable to haskell too.
22:39:39 <JoeyA> tomprince: Thanks!
22:40:01 <tomprince> (the rest of the talk is probably interesting too)
23:11:45 <shergill> i'm going over the outside-in paper, and i'm having trouble understanding the type of the test function presented in the introduction
23:12:31 <shergill> specifically, the first 'potential' type given for test is presented as: forall a, T a -> Bool -> Bool
23:13:34 <shergill> shouldn't it be, T Bool -> a -> Bool?
23:15:49 <shachaf> shergill: Why?
23:16:22 <shergill> well T1 constructor has type Int -> T Bool
23:17:16 <shergill> so in the first use of test (test (T1 n) _ = n > 0), (T1 n) is a T Bool
23:17:32 <shergill> _ has unknown type
23:18:05 <shergill> and the result has the type of 'n > 0' which is a bool
23:18:58 <shergill> shachaf: ^
23:19:01 <shachaf> Well, the "Bool" for the second argument comes from the T2 case, presumably.
23:19:25 <shachaf> And in (T1 n) n is always an Int.
23:20:58 <shergill> agreed wrt n always being an Int in (T1 n)
23:22:54 <shergill> well ok let me rewind. looking only at "test (T1 n) _ = n > 0" with T1:: Int -> Bool, what would you reckon is the type of test?
23:25:21 <shergill> the way i was reading it was, test is taking two arguments and producing a result. the type of the first argument is the result of (T1 n) which is T Bool. the second argument isn't defined and so should be replaced with a type variable. the result has type Bool
23:26:14 <shachaf> shergill: T1 :: Int -> T Bool, you mean?
23:26:16 <shergill> so the type of test only looking at that definition seems to be forall a, T Bool -> a -> Bool
23:26:26 <shergill> shachaf: yes
23:26:50 <shachaf> I don't think the "first possible type" is decided on based on just the first line of the function.
23:27:13 <shergill> agreed
23:27:21 <shergill> i was just walking through it.
23:27:32 <shachaf> Anyway, even with that first line, the type can be "T a", not just "T Bool".
23:27:53 <shachaf> For example, data T :: * -> * where T :: Int -> Foo Bool
23:28:20 <shachaf> s/Foo/T/
23:28:27 <shachaf> (\(T x) -> x) :: T a -> Int
23:29:12 <shachaf> That's how GADTs work: The whole function's type is polymorphic, but once you pattern-match a specific constructor you get to learn more about the type.
23:30:09 <shergill> hmm i thought i already understood GADTs, apparently not. ok
23:30:52 <shachaf> s/is/can be/
23:33:17 <shergill> in that lambda expression you pasted, is there ever a case where x can be anything other than an Int?
23:34:09 <shergill> sorry my bad. is there any way where (T x) is anything other than a T Bool
23:34:58 <edwardk> shergill: not without an unsafeCoerce ;)
23:35:08 <shergill> edwardk: heh
23:35:23 <shergill> right, so why doesn't the type reflect that? why is the type T a -> Int
23:35:34 <shergill> and not T Bool -> Int
23:35:36 <edwardk> pattern matching on T will do type refinement
23:35:52 <edwardk> the type doesn't bubble out.
23:35:57 <edwardk> because say you had another constructor
23:35:59 <shergill> ah ok
23:36:10 <edwardk> that could be F :: Double -> T ()
23:36:19 <nejucomo> I want something like MVar, except for single-threaded use.  Does this exist?
23:36:30 <edwardk> and what if you had a bottom, which was a T (Int, a -> b)
23:36:35 <shachaf> edwardk: Right, that was the case we were talking about above. :-)
23:36:58 <shachaf> data T :: * -> * where T1 :: Int -> T Bool; T2 :: T a
23:37:19 <nejucomo> Ah, IORef.
23:37:34 <edwardk> the idea is that the type refinement from GADTs can only flow 'in' to the case, not out, otherwise you can leak existentials in funny ways
23:37:47 <shergill> edwardk: right i see the issue when other constructors. but the reason the types aren't bubbled out is to make type inference more tractable? so that the inference engine doesn't have to worry about what other constructors might be out there?
23:38:13 <shergill> edwardk: could you elaborate on 'leak existentials in funny ways'?
23:38:26 <edwardk> well, the problem is you can wind up with cases where the only thing you know about the type of something is that it exists. you have a type like 'exists a. a'
23:38:46 <edwardk> try using existential types, and putting a field accessor in. you can't use it
23:39:31 <edwardk> data Foo = for all e. Foo { getFoo :: e }   -- try to do anything with getFoo, you can't
23:40:47 <edwardk> similarly the only way you can 'get the existential out' is with case analysis. you aren't allowed to open it with a destructuring assignment in a let.
23:40:48 <shachaf> Hah, that's an interesting case.
23:41:23 <edwardk> at last check ghc will say its brain exploded or some such
23:41:41 <shachaf> Cannot use record selector `getFoo' as a function due to escaped type variables
23:41:45 <shergill> ah ok, that makes some sense now
23:41:52 <shachaf> Even on asking for the type of getFoo
23:41:58 <edwardk> yeah
23:42:02 <shachaf> I guess the reason it lets you define an accessor at all is for record syntax.
23:42:23 <edwardk> because getFoo :: exists a. Foo -> a  isn't a type we're allowed to say
23:42:33 <shachaf> Sadly.
23:42:59 <shergill> ok
23:43:04 <edwardk> meh, allowing it means you can type check crap like if foo then True else () ;)
23:43:22 <edwardk> so i'd rather not have it
23:43:27 <shergill> thanks for clarifying that edwardk :)
23:43:29 <shachaf> You could allow it but not inferrably...
23:44:14 <edwardk> it interacts non-trivially with all the other interesting things you need to do
23:44:41 <shachaf> It's not as if you'd be able to compute a "most general type" at any rate (take the intersection of all the type classes of the two types or something?).
23:44:55 <edwardk> yeah
23:45:22 <edwardk> well, you could, but that has all sorts of crazy implicit dependencies on the current context
23:45:47 <shachaf> Right, it's not the "most general type" because someone could define new instances.
23:46:33 * shachaf probably ought to read that paper.
23:48:11 <adit> Could someone explain this class definition to me?
23:48:15 <adit> class FunctionArgs f g r | f -> g r, g r -> f where
23:48:41 <adit> Specifically, how does the pipe syntax (|) work
23:49:04 <edwardk> that says given f you can infer g and r, and that given g and r you can infer f
23:49:18 <geekosaur> "functional dependency" is the formal term
23:49:56 <shergill> adit: the combination of both those being that for a given pair of (f, (g,r)) there can only be one definition (i believe so, edwardk, shachaf can correct me if i'm wrong)
23:50:08 <edwardk> read | as 'such that', and -> as 'determines', and comma as 'and' ;) f -> g r,  g r -> f
23:51:00 <adit> ah ok. Thanks guys!
23:51:56 <BMeph> Welcome to Haskell, where "you must Unlearn what you have learned". 8D
23:52:46 <adit> :D
