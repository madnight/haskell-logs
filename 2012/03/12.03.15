00:05:25 <huangjs> Enigmagic: ah, i see. thanks!\
00:24:03 * hackagebot AhoCorasick 0.0.2 - Aho-Corasick string matching algorithm  http://hackage.haskell.org/package/AhoCorasick-0.0.2 (SergeyLymar)
00:29:18 <zhulikas> @hoogle def
00:29:18 <lambdabot> System.Posix.DynamicLinker.Prim Default :: DL
00:29:18 <lambdabot> System.Posix.Signals Default :: Handler
00:29:18 <lambdabot> keyword default
00:59:51 * astor is impressed by the latest leksah
01:01:47 <zhulikas> astor, what's new?
01:02:49 <rasfar> one more note:  http://www.fremissant.net/freesect/primitives.html contains a nice table of freesect translations, in case anyone's around from earlier...
01:03:20 <rasfar> hands are freezing, this is a sketchy alley to squat wifi in, i'll be off now!
01:04:17 <astor> zhulikas: not sure, it's been a while since I tried it last.  but now it sort of just worked.  and was painless to build.
01:04:49 <zhulikas> I never built it with cabal
01:04:54 <zhulikas> always got a bunch of errors
01:04:56 <zhulikas> :D
01:06:48 <zhulikas> somebody should integrate Haskell to Visual Studio
01:07:03 <zhulikas> and I do know about Visual Haskell
01:07:08 <zhulikas> but that was just an attempt
01:08:55 <zhulikas> hmm I might start looking into Visual Studio SDK
01:09:04 * hackagebot lzma-conduit 0.1.2.1 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-0.1.2.1 (NathanHowell)
01:19:05 * hackagebot xml-conduit 0.5.4 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.5.4 (MichaelSnoyman)
01:40:05 <srhb> length never inspects the element of a list, does it? Does this mean that the time to compute the length of a list will never depend on the elements in the list, only their number?
01:40:32 <int-e> srhb: yes
01:41:08 <srhb> int-e: Thanks. Don't know why I doubted that, actually. :P
01:43:57 <geekosaur> you can tell that from the type, even
01:44:02 <geekosaur> :t length
01:44:03 <lambdabot> forall a. [a] -> Int
01:44:18 <geekosaur> since it has no way to know what a *is*, it cannot inspect it at all
01:46:23 <srhb> geekosaur: Oh, really, I didn't know that implication. Is it true for all "unnamed types" in a type signature?
01:46:33 <srhb> It must be.
01:46:49 <geekosaur> you can have constraints on a type that allow things to be done ot it
01:46:51 <geekosaur> :t (+)
01:46:52 <lambdabot> forall a. (Num a) => a -> a -> a
01:46:52 <srhb> Right.
01:47:29 <geekosaur> "Num" then defines operations that can be applied to any type that is an instance of Num.
01:47:49 <srhb> But I can only make this assumption on the very argument, right?
01:47:58 <srhb> very last*
01:48:18 <geekosaur> I do not understand the question
01:48:22 <srhb> :t foldr
01:48:23 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:48:34 <geekosaur> there are some functions where you can infer a behavior from a forall-ed type
01:48:37 <geekosaur> :t error
01:48:37 <lambdabot> forall a. [Char] -> a
01:48:48 <zhulikas> > error "hai"
01:48:49 <lambdabot>   *Exception: hai
01:49:18 <srhb> Ie. I can't say anything about whether "foldr" will inspect any elements, because I need to make it all the way to the last x -> y in the arguments, no?
01:49:22 <srhb> Or does that logic not even work.
01:49:28 <geekosaur> "produces anything", well, there's only one way to do that.  produce "bottom" (i.e. the computation that does not finish, which is an exception / runtime error / crash or an inifnite loop, etc.)
01:49:39 <srhb> :t foldr (+) 0
01:49:39 <lambdabot> forall a. (Num a) => [a] -> a
01:50:10 <zhulikas> :t def
01:50:11 <lambdabot> Not in scope: `def'
01:50:15 <geekosaur> foldr itself does not inspect elements because it doesn't know anything about them.  but the function that is one of its parameters may inspect them, if the use case allows it
01:50:34 <srhb> Of course. :-) Thank you.
01:51:13 <geekosaur> and, of course, there's this:
01:51:16 <geekosaur> :t undefined
01:51:17 <lambdabot> forall a. a
01:52:03 <srhb> There's magic in undefined though, isn't there? It can take any number of arguments, for instance.
01:52:14 <srhb> Or rather it type checks regardless.
01:54:51 <geekosaur> it's not really "magic"; `a' can be anything, which includes function types (and Haskell's uncurried syntax means all functions effectively tkae a single parameter in that way)
01:55:30 <geekosaur> on the other hand, since the only value that is common to all types is "bottom", you know the only thing it can possibly do is throw an exception
01:56:53 <ceii_> > let undef :: a ; undef = undef in undef 'a' :: Char
01:56:57 <lambdabot>   mueval-core: Time limit exceeded
01:57:04 <ceii_> ...or never terminate
01:58:15 <geekosaur> true
01:58:45 <geekosaur> although ghc catches many of those cases and gives you a special exception called "<<loop>>"
01:59:13 <ceii_> you'll get struck by lightning some day if you rely on this :)
01:59:32 <geekosaur> I'm actually a little surprised it didn't there, as that's one of the cases that the <<loop>> blackhole is supposed to catch
01:59:48 <geekosaur> relying on bottom at all is... dubious
01:59:53 <shachaf> geekosaur: MuEval does some unusual thing.
02:00:06 <geekosaur> ah
02:00:09 <shachaf> Back when lambdabot used a different method of evaluating Haskell it would've caught that.
02:03:25 <ceii_> is it that weird? GHCi doesn't detect it either.
02:07:27 <geekosaur> hrm
02:09:18 * geekosaur wonders what happened to that check...
02:10:55 <geekosaur> (first time it runs "undef" it should be temporarily replacing it with a "ack! reentered" thunk; the immediate attept to rerun it should then trigger that.  wonder if that broke something else somehow)
02:19:07 * hackagebot test-framework 0.4.2.3 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.4.2.3 (MaxBolingbroke)
02:46:11 <Administ1ator> hi all
02:47:02 <Administ1ator> hi i am from china
02:47:25 <mrcarrot> hello
02:47:38 <Administ1ator> hi mrcarrot
02:48:57 <rupert111> cool
03:07:29 <muschipups> m
03:07:29 <muschipups> m
03:07:48 <Mikalaidis> ???
03:07:56 <muschipups> sry wrong frame
03:16:19 <dobblego> how do you cabal install cabal-install on GHC 7.4.1 when it requires unix >=4.2 && <4.4 since GHC-7.4.1 comes with unix 2.5.1.0?
03:16:56 <ClaudiusMaximus> dobblego: you bootstrap cabal-install from darcs (or at least, that's what i did)
03:17:03 <Baughn> dobblego: You use the darcs version of cabal-install
03:17:22 <Baughn> The official release version is meant to go with haskell-platform, which does *not* use 7.4
03:19:55 <dobblego> oh right
03:22:23 <blackdog> dobblego: alternatively, there's nothing wrong with using an older precompiled cabal-install with ghc-7.4.1
03:22:41 <dobblego> yeah I think I did that last time
03:36:05 <ksf> constraint synonyms don't seem to be expanded before decidability of an instance is checked
03:36:15 <ksf> is that an oversight?
03:38:16 <hiptobecubic> ksf, what do you mean/
03:40:09 <ksf> if I replace all my constraints with a constraint synonym ghc complains about variables not occurring often enough in the constraints.
03:40:53 <ksf> ...which makes sense, as I just replaced a gazillion occurences with one, but then doesn't, because the synonym is only a synonym.
03:41:51 <hiptobecubic> ksf, i can't really help. I was just curious :)
03:42:16 <hiptobecubic> ksf, good luck though. sounds like a bug to me.
03:42:54 <ksf> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html
03:43:45 <ksf> it's probably just cromulent lazyness, for now.
03:44:12 <ksf> if it weren't a plain synonym but a type family things would get hairy.
03:45:07 <hiptobecubic> ksf, ahh..
03:46:36 <hiptobecubic> PastePipe is essentially dead, isn't it?
03:59:17 <rostayob> When I try to start up ghci in emacs with haskell mode (Using C-c C-l for example) it just freezes and I have to kill it with C-g. Any ideas on how to investigate this problem?
04:05:11 <ksf> rostayob, yes. install vim.
04:05:34 <ksf> oh, and xmonad, because running line-editing programs in an editor is a bad idea, anyway.
04:05:50 <ksf> emacs may have a terminal emulator, but it's anything but proper.
04:05:59 <ksf> can't even properly deal with less, iirc.
04:06:04 <rostayob> ksf: thanks, but I like emacs and I like i3 much better than vim and xmonad
04:06:29 <rostayob> also, you clearly havent tried thins like slime or geiser.
04:06:33 <ksf> well, anything that allows you to switch quickly between terminals.
04:06:55 <rostayob> ksf: i3 does, but it's much more convenient to have the shell inside a buffer window
04:07:28 <ksf> I always have two konsoles open, either split with the console taking up a small horizontal part, or fullscreen, as needed.
04:07:55 <ksf> in any case the konsole, or editor, is only meta+j or k away.
04:08:02 <ksf> that's faster than C-c C-l
04:08:10 <rostayob> ksf: C-c C-l is just to start it up.
04:08:32 <rostayob> and again, it's convenient to have it as a buffer since you can easily switch between that and files
04:08:39 <rostayob> anyways, this doesn't solve my problem :P
04:09:01 <ksf> of course it does. you're just refusing to let me define the problem away.
04:10:21 <rostayob> ksf: I use vim and tiling wms. I like emacs much better for editing projects. You're not going to convince me now :)
04:13:17 <nand`> rostayob: I don't think he's trying to convince you to not edit projects with emacs, he's telling you to not run ghci inside emacs. Problem solved
04:13:27 * geekosaur guake/yakuake/visor...
04:13:45 <rostayob> nand`: no, problem not solved, because I like running the shell inside emacs...
04:33:50 <ksf> suppose I have a data kind K = T1 | T2, an associated data family D a :: K -> * and a class function foo :: D a T1 -> D a T2. obviously. K is a phantom type so I could *in principle* specify a default method foo :: id... but that doesn't type, I have to deconstruct and reconstruct the concrete data type in the instance to do it.
04:33:54 <ksf> ...or is there another way?
04:34:19 <ksf> (barring unsafeCoerce)
04:35:11 <geekosaur> deconstruct and reconstruct is the correct way, as I understand it
04:35:26 <ksf> well, yes, but it's also the boilerplaty way
04:36:22 <ksf> ideally, we'd have a unsafeCoerce that refuses to work on inhabited types.
04:37:50 <ksf> all in all, however, ghc 7.4 is just great.
04:51:58 <Spockz> Who has read Elliots' "Push-pull functional reactive programming"? I cannot figure out how you would run the system? e.g. how could I fire an event?
04:54:25 * hackagebot yesod 0.10.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.10.2 (MichaelSnoyman)
05:03:56 <ksf> @pl \mod -> Just (f mod  =<< findModule mod)
05:03:57 <lambdabot> Just . liftM2 (=<<) f findModule
05:04:27 * hackagebot yesod-platform 0.10.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-0.10.2 (MichaelSnoyman)
05:04:31 <ksf> Spockz, you push them into sinks.
05:04:57 <ksf> ...which you could do, but last I looked reactive was dysfunctional.
05:05:12 <Spockz> ksf: what do you mean  by that last comment/
05:05:27 <ksf> didn't do much more than make my cpu generate heat.
05:05:44 <ksf> unamb is the painful thing afaiu.
05:06:05 <ksf> it once ran, though, even if barely.
05:06:54 <Spockz> aha, that doesn't sound  hopeful ksf :0
05:07:30 <merijn> There are some newer/more active and (I've heard) better performing FRP libraries
05:07:37 <hiptobecubic> Why isn't zip implemented as zipWith (,)  ?
05:07:59 <Jaak> @hoogle zipWith
05:07:59 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
05:07:59 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
05:08:00 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
05:08:08 <ksf> performance, I think.
05:08:15 <ksf> also, (,) needs -XTupleSections
05:08:29 <Spockz> merijn: such as? I'm looking for the combination of push/pull, but I'm mainly interested in push
05:08:33 <hiptobecubic> ksf, are you sure? I just didn't it and i've never heard of -XTupleSections
05:08:49 <ClaudiusMaximus> > (,) 1 2
05:08:49 <lambdabot>   (1,2)
05:08:54 <ClaudiusMaximus> > (1,) 2
05:08:55 <lambdabot>   Illegal tuple section: use -XTupleSections
05:08:55 <Spockz> merijn, ksf: I'm currently working on a Haskell port of our JS based reactive framework
05:08:58 <ksf> oh.
05:09:10 <hiptobecubic> ClaudiusMaximus, oh, but you wouldn't need that in this case
05:09:19 <merijn> FRP category has 31 packages on haskell (not sure of the maturity of all of them)
05:09:21 <merijn> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:frp
05:10:07 <merijn> Spockz: Are there many of those? I heard my brother was using one, but I wasn't under the impression that was in common use for JS coding
05:10:21 <Spockz> merijn: this has been developed in-housee
05:10:40 <merijn> Yampa is supposedly one of the better performing libraries for FRP
05:10:41 <fbern> does someone konw if hoogle (web) can be told to return results in a different format (eg. json)?
05:12:15 <ksf> use the source, fbern
05:17:32 <fbern> thats what i thought, thaks ksf
05:17:41 <fbern> ^thaks
05:17:50 <fbern> thanks
05:19:29 * hackagebot gc-monitoring-wai 0.1 - a wai application to show GHC.GCStats  http://hackage.haskell.org/package/gc-monitoring-wai-0.1 (YiHuang)
05:19:31 * hackagebot hierarchical-clustering-diagrams 0.2 - Draw diagrams of dendrograms made by hierarchical-clustering.  http://hackage.haskell.org/package/hierarchical-clustering-diagrams-0.2 (FelipeLessa)
06:07:58 <ClaudiusMaximus> > let double r | r2 >= 1 = r2 - 1 | otherwise = r2 where r2 = 2 * r ; orbit = iterate double in orbit (5/28 :: Rational) -- how might i efficiently split an orbit into the preperiodic part and the periodic part?
06:07:59 <lambdabot>   Not in scope: `orbit'
06:08:37 <ClaudiusMaximus> > let { { double r | r2 >= 1 = r2 - 1 | otherwise = r2 where r2 = 2 * r } ; orbit = iterate double } in orbit (5/28 :: Rational) -- how might i efficiently split an orbit into the preperiodic part and the periodic part?
06:08:38 <lambdabot>   <no location info>: parse error on input `{'
06:09:02 <ClaudiusMaximus> > let orbit = iterate double ; double r | r2 >= 1 = r2 - 1 | otherwise = r2 where r2 = 2 * r in orbit (5/28 :: Rational)
06:09:03 <lambdabot>   [5 % 28,5 % 14,5 % 7,3 % 7,6 % 7,5 % 7,3 % 7,6 % 7,5 % 7,3 % 7,6 % 7,5 % 7,...
06:23:41 <yitz> ClaudiusMaximus: find n such that 2^n - 1 is divisible by the denominator of the orignal number
06:26:27 <ClaudiusMaximus> > head $ filter (\n -> (2^n - 1) `mod` 28 == 0) [0..]
06:26:28 <lambdabot>   0
06:26:38 <ClaudiusMaximus> > head $ filter (\n -> (2^n - 1) `mod` 28 == 0) [1..]
06:26:39 <yitz> ClaudiusMaximus: without the 2 component of course
06:26:42 <lambdabot>   mueval-core: Time limit exceeded
06:27:35 <yitz> ClaudiusMaximus: the periodic part is described by what i said. i think the preperiodic part may be the length of the 2 component of the original denominator, i haven't checked that
06:27:43 <ClaudiusMaximus> yes, seems to make sense
06:28:59 <yitz> ClaudiusMaximus: i was going to say something about memoizing until you find a repitition, until i realized - forget that, just do the math.
06:29:04 <ClaudiusMaximus> :)
06:30:39 <t7> cabal reports 2.3.0.5 >= 2.3   as false?
06:30:41 <t7> wtf
06:31:12 <dcoutts_> t7: sounds unlikely
06:31:48 <yitz> ClaudiusMaximus: yes that's it. anything with odd denominator is periodic. so you just knock of the twos one by one, with an occasional downward bump, until all the twos are gone. then it's periodic.
06:32:55 <ClaudiusMaximus> groovy - still curious about the memoizing method - supposing a less obvious function to orbit
06:33:12 <ClaudiusMaximus> but i don't actually need that (yet)
06:33:39 <dcoutts_> t7: there's probably a different explanation, but you'd have to give more details
06:34:23 <t7> also its trying to build network 2.3.0.5 when its allready installed
06:34:31 <t7> any reason why it might be doing that>
06:34:33 <t7> ?
06:35:07 <yitz> dcoutts_: some good ideas from tibbe. but i disagree that cabal is only for building executables. i use it mostly for building libraries.
06:35:12 <t7> ok its not anymore :|
06:35:40 <dcoutts_> yitz: did I miss something?
06:36:05 <yitz> http://blog.johantibell.com/2012/03/cabal-of-my-dreams.html
06:36:13 <dcoutts_> ah found it
06:36:16 <dcoutts_> yitz: ta
06:36:48 <yitz> dcoutts_: you are mentioned there, too, another reason why you ought to see it ;)
06:36:55 <dcoutts_> :-)
06:38:02 <dcoutts_> yitz: I guess install with libs is in some sense an intermediate thing about making something available in an environment for reuse
06:39:01 <dcoutts_> yitz: well, I agree with pretty much all of that
06:42:32 <hpaste> stj pasted “I'm trying to optimize this simple function "rotate" since it takes 20% of time - any advice?” at http://hpaste.org/65346
06:43:40 <stj> would be great if you can find a way to optimize "solve" "uNode" "findVal.go" or "splay" maybe
06:49:33 <ClaudiusMaximus> stj: those strictness annotations on the tree data seem inappropriate to me...
06:49:35 <hpaste> “cabal issue” pasted “t7” at http://hpaste.org/65347
06:49:51 <stj> ClaudiusMaximus: why? they speed the code up quite a bit
06:50:06 <ClaudiusMaximus> stj: oh, ok
06:50:07 <t7> dcoutts, you know why its doing that?
06:54:19 <dcoutts_> t7: run using --dry-run -v
06:54:23 <yitz> dcoutts_: not really. ultimately, way down the road, the libraries will be integrated into an executable, but that's just one step at the very end of development process. most of the time, you're compiling libraries.
06:54:37 <dcoutts_> t7: it'll say why it's reinstalling network which should give you a hit as to how to avoid it
06:54:57 <dcoutts_> yitz: sure, it depends if you're thinking push or pull
06:55:09 <yitz> dcoutts_: depends on the project
06:55:19 <dcoutts_> yitz: install is inserting a lib into an environment so that you can use it later
06:55:42 <dcoutts_> yitz: which currently is typically the global or per-user environment
06:55:44 <yitz> dcoutts_: or test it now, or integrate it with some other libraries
06:56:03 <yitz> dcoutts_: not for me i've given up on that. cabal-dev only.
06:56:22 <t7> ah its parsec
06:56:34 <dcoutts_> yitz: well cabal-dev is doing exactly that, it's telling cabal to install into a specific environment rather than the global one
06:56:35 <yitz> dcoutts_: it would be nice if that would work again though. i was hoping the new solver will be enough.
06:57:00 <dcoutts_> yitz: I'm not sure what you're referring to now
06:57:20 <dcoutts_> yitz: "integrate it with other libs" is the same thing, making it available in an environment
06:57:28 <dcoutts_> but it might be a local environment
06:57:54 <stj> ClaudiusMaximus: most of the time is spent in "solve" (22%)... do you think it's because of slow input?
06:58:09 <yitz> dcoutts_: cabal installs into an environment which is global w.r.t. projects. (unless you override the target pkg db, like what cabal-dev does)
06:58:16 <thoughtpolice> preflex: seen kfish
06:58:17 <preflex>  kfish was last seen on #haskell 1 day, 5 hours, 56 minutes and 45 seconds ago, saying: * kfish just added a bunch of FlexibleInstances pragmas to fix build breakage with ghc-7.5
06:58:54 <dcoutts_> yitz: ok we're talking at cross purposes slightly, you're talking about what cabal install actually does now, tibbe is talking about what "install" for a lib should mean
06:59:26 <dcoutts_> yitz: and I was meaning I agree that what it really means is to make something available in a particular environment (and perhaps do some work and error checking eagerly)
07:01:30 <yitz> dcoutts_: tibbe wants to replace the notion of a pkg db by explicit use of file system structure as a pkg db. i don't like that idea.
07:01:46 <yitz> dcoutts_: though i suppose it could be made an option for people who want that.
07:01:49 <stj> oh, and my code is allocate loads of stuff ... mainly functions rotate, solve and findVal.go... I don't see why rotate is allocating the most?
07:01:51 <dcoutts_> yitz: I'm not sure he's talking about mechanism that specifically
07:02:03 <stj> It's so simple it can use almost no memory when implemented in C
07:02:37 <Botje> stj: presumably the results are not being forced.
07:02:45 <dcoutts_> yitz: and personally I think a nix style package store is the right way to do this, and then have multiple environments which are views into the store
07:02:46 <Botje> or forced fast enough
07:02:59 <ClaudiusMaximus> stj: allocation is relatively meaningless, as long as productivity is high (+RTS -s)
07:03:05 <yitz> dcoutts_: "We frequently have to work on multiple dependent packages at once and thus we also need a way to build them together, without registering the by-products in some shared package database. For example, given this directory structure..."
07:03:10 <dcoutts_> yitz: that mechanism would cover the cabal-dev style use case, and multiple "global" environment
07:03:28 <stj> ClaudiusMaximus: maybe it's a sign that something that could be inlined isn't
07:03:39 <dcoutts_> yitz: yes, not changing a global environment
07:04:20 <dcoutts_> yitz: he's not asking for a specific mechanism
07:05:13 <yitz> dcoutts_: i want the solver to pick versions of the dependencies for me automatically (except get it right please).
07:05:22 <stj> Botje: have you perhaps found a suspicious place where it isn't forced?
07:05:37 <dcoutts_> yitz: yes, and the new solver is much better at that
07:06:05 <dcoutts_> yitz: I think that's mostly orthogonal to the issue of environments and installed package stores
07:06:49 <yitz> dcoutts_: i think the nix-style thing you are describing would still do that. i understood from tibbe's post that he wants more of a make-style build tool.
07:07:32 <dcoutts_> yitz: he wants sometimes to be able to specify particular dependencies, like "this unpacked directory"
07:07:35 <Botje> stj: no clue.
07:07:42 <dcoutts_> yitz: which is fine, that integrates into solving fine
07:07:59 <Botje> stj: presumably getKth, but no clue how you could fix that.
07:08:00 <yitz> dcoutts_: cabal-dev add-source
07:08:26 <dcoutts_> yitz: right now, when you do: " cabal install ./ ../lib/foo " then it's still solving, but some of the dependencies are fixed
07:09:14 <KorriX> hello
07:09:16 <dcoutts_> yitz: and yes, cabal-dev does the same thing by giving cabal an extra package index and constraining the solver to use versions from that
07:09:49 <yitz> dcoutts_: i also use a local yackage server for that.
07:10:02 <KorriX> how to make template-haskell function with will create constat with assigned some data (like makeVariable "name" "value")
07:10:23 <dcoutts_> yitz: point is, I don't think there's a conflict between these two things, using a solver to pick the unconstrained bit, and having local environments that partially constrain the solution
07:11:45 <yitz> dcoutts_: the general solver is probably np-hard, isn't it.
07:11:51 <dcoutts_> yitz: yes it is
07:19:20 <ronankde> how to install gtk3 on haskell
07:23:04 <hpaste> Sithis annotated “variable scope” with “variable scope (annotation)” at http://hpaste.org/65348#a65349
07:25:09 <geekosaur> ronankde, what do you mean?
07:27:57 <stj> hmm, apparently putStrLn is taking 20% of time... is there a faster way to just print a string? :)
07:28:27 <quicksilver> ByteString or Text
07:46:43 <hpaste> stj pasted “profiling output” at http://hpaste.org/65351
07:47:17 <stj> well this is interesting splays inside insert are fast and splays inside getCount are slow
07:47:39 <stj> there is about the same number of random calls to insert and getCount... this is puzzling me :/
07:50:59 <stj> nvm, my mistake in input
08:00:35 <david80> Hi I am struggling with the type system and Automatic Differentiation in the 'ad' package
08:00:47 <edwardk> david80: shoot
08:01:07 <david80> your the author! :)
08:01:11 <edwardk> that i am
08:01:48 <david80> so if I run this:  gradientAscent (logLikelihood' [2,3,4,5]) [1, 1.0, 2.0]
08:01:57 <david80> it works
08:02:03 <BlankVerse> when i use pandoc with beamer , i get this :
08:02:04 <BlankVerse> pandoc: /home/pankajm/.cabal/share/pandoc-1.8.2.1/templates/default.beamer: openFile: does not exist (No such file or directory)
08:02:11 <BlankVerse> do i need to install something else?
08:02:34 <david80> but when I try and replace the first list with the output of a function I get this error:      Couldn't match expected type `AD s a0' with actual type `Double'
08:02:34 <david80>     Expected type: [AD s a0]
08:02:34 <david80>       Actual type: [Double]
08:02:34 <david80>     In the first argument of `logLikelihood'', namely `s'
08:02:34 <david80>     In the first argument of `gradientAscent', namely
08:02:39 <edwardk> finding modes of log concave functons?
08:02:45 <av> hello everyone
08:03:05 <mauke> david80: your function returns Doubles
08:03:30 <edwardk> you need the function to be able to take on the type: Mode s => [AD s Double] -> AD s Double
08:03:38 <edwardk> rather than [Double] -> Double
08:03:48 <edwardk> when you inline it, it is taking the more general signature
08:03:57 <edwardk> otherwise I can't plumb the derivative information through it
08:04:19 <av> this is probably a very dumb question, but here it is anyway: is there a more elegant way of writing this line, without the lambda?   p = endBy word (char ';') >>= \w -> newline >> return w
08:04:28 <david80> thanks, I'll have a bash and see how that goes
08:04:34 * fryguybob knew edwardk secretly computed calls to ad.
08:04:38 <edwardk> those FU f a and UU a aliases are short hand
08:04:39 <mauke> @pl p = endBy word (char ';') >>= \w -> newline >> return w
08:04:39 <lambdabot> p = (newline >>) . return =<< endBy word (char ';')
08:05:03 <geekosaur> (@pl: be careful what you ask for...)
08:05:07 <edwardk> type FU f a = (forall s. Mode s => f (AD s a) -> AD s a)
08:05:21 <mauke> av: fgfgasdf <* newline
08:05:47 <david80> I'm a bit of a noob to be honest so I'll try hacking around and get back to you
08:05:49 <edwardk> which basically means you have to pass in a function that doesn't care what AD mode I use, but which can accept a traversable container full of AD variables and give me back an AD variable
08:06:41 <Spockz> any ideas as what the cause is for the annoying "file already exists but is not managed by cabal" warning when installing a cabal package?
08:06:43 <edwardk> if you _need_ to multiply by some double you have lying around you can always use lift :: Mode s => a -> AD s a
08:07:01 <av> mauke: that's in Control.Applicative, right? Looks like exactly what I was looking for
08:07:08 <edwardk> this way you don't need to regenerate all your data every time, just the stuff that depends on your function arguments
08:07:55 <edwardk> and those functors/traversables are the way you can export more information from the function than just numbers as an expert user
08:08:46 <edwardk> av: endBy word (char ';') <* newline
08:09:18 <edwardk> av: when using parsers with applicative combinators the <'s point to the stuff you care about.
08:09:31 <edwardk> char '(' *> expr <* char ')'
08:09:45 * hackagebot http-types 0.6.10 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.10 (AristidBreitkreuz)
08:10:23 <edwardk> fryguybob: shh. what do you think i use the call to unsafePerformIO in reverse mode for?
08:11:24 <av> edwardk, mauke: thanks, it looks, however, as if some of Control.Applicative conflicts with Text.Parsec... what a shame that I'll have to import one qualified...
08:11:46 <david80> so lets say I have fn :: [Double] I understand I need to lift those but how would I go about doing that? also they are the result of a big simulation, would I end up making that differentiable?
08:12:12 <ChristianS> av: qualified import is almost always a good idea.
08:12:18 <edwardk> av: just hide the Parsec <|>, many and empty. The applicative instance for Parsec is compatible
08:12:23 <ksf> gnargl. DeriveGeneric doesn't support data families, either.
08:12:33 <edwardk> av: the reason is historical. <|> has a different precedence in parsec
08:13:00 <av> edwardk: thanks a lot...
08:13:14 <edwardk> ChristianS: in this case it is ok
08:13:20 <KorriX> that template-haskell can work in local function context ?
08:13:27 <Rc43> Hi, guys.
08:13:34 <KorriX> Rc43: hi
08:13:49 <edwardk> the parsec maintainer didn't want to break his existing users by changing the precedence of what is arguably the second most common operation in a parser
08:13:52 <Rc43> How should I be if I need to declare some instances of data X in two separate files?
08:14:04 <Rc43> I want to avoid import cycles.
08:14:16 <Rc43> But I want to separate big coed parts too.
08:14:16 <edwardk> in trifecta i just never bothered, and used Alternative all the way throughout the code
08:14:22 <KorriX> Rc43: it is generally bad idea
08:14:36 <Rc43> KorriX, orphaned instances?
08:15:09 <Rc43> Create mock functions just for importing is something not good too.
08:15:18 <KorriX> yes
08:17:02 <mootcube> hi, does anybody know how to solve "No instance for (Num (IO t0))", please?
08:17:17 <rostayob> mootcube: what are you trying to do?
08:17:55 <mootcube> i made a function that return fib of a number
08:18:02 <mootcube> it returns an Integer
08:18:15 <rostayob> mootcube: post the code
08:18:22 <int-e> mootcube: oh. probably a missing 'print'
08:19:54 <mootcube> main = do
08:19:54 <mootcube> 	k <- fib 100
08:19:54 <mootcube> 	print k
08:20:22 <Lemmih> mootcube: '<-' isn't used for regular bindings.
08:20:34 <Lemmih> mootcube: Use 'let k = fib 100' instead.
08:25:20 <Ragnaroek> is there an example of what code deriving (Monad) does produce on a newtype?
08:27:57 <Lemmih> Ragnaroek: Doesn't it produce what you'd expect?
08:28:38 <Ragnaroek> I want to define my own monad, but it's know data and not newtype anymore and i can't use deriving
08:28:43 <geekosaur> I didn't think it did anything; a newtype has no representation, all newtype deriving does is "unhide" something that the newtype "hid"
08:29:31 <ksf> Ragnaroek, there's the derive and generic-deriving packages.
08:30:20 <ksf> if that fails, there's template hasell or grumble that your case isn't covered, which is what I'm currently occupied with.
08:30:42 <ksf> also, it's past 4, so it's time for beer.
08:32:06 <Ragnaroek> newtype M a = M (N a) deriving (Monad)
08:32:10 <Ragnaroek> where N is a Monad
08:32:17 <Ragnaroek> how does >>= look?
08:32:26 <ksf> follow the types.
08:32:39 <ksf> there's exactly one (sensible) way.
08:32:51 <rwbarton> it just uses the fact that M and N are the same
08:33:10 <hpc> Ragnaroek: what would M.(>>=) do in terms of N.(>>=)
08:33:16 <hpc> (not how it would be defined, just what it does)
08:34:07 <rwbarton> pretty sure the way it actually works is (>>=) = unsafeCoerce ((>>=) :: N a -> (a -> N b) -> N b)
08:34:38 <hpc> haha
08:34:49 <rwbarton> the point is you could write this yourself, by inserting/removing M in various places
08:40:49 <Ragnaroek> M (N x) >>= f = M $ f x ?
08:42:16 <ksf>     Not in scope: type constructor or class `DCC'
08:42:16 <ksf>     Perhaps you meant `DDC' (line 42)
08:42:16 <ksf>   .oO( ... )
08:42:44 <ski> Ragnaroek : it might be easier not to get confused if you defined it as `newtype M a = MkM (N a) deriving Monad'
08:46:27 <hpaste> stj pasted “a simple tree” at http://hpaste.org/65353
08:47:24 <stj> when doing these rotation I'm creating a lot of new nodes and that's very time consuming... can I somehow tell GHC: hey, I don't care about persistency and stuff, just do this inline, don't create new nodes, just modify fields in the ones you already have?
08:48:01 <ksf> oh damn I'm completely and utterly blind.
08:48:09 <stj> my equivalent implementation of splay tree in C++ is more than 10 times faster and I'd like to shrink that gap
08:50:00 <unlink> What are the types sat_sLM, sat_sNh, sat_sLL reported by +RTS -hd?
08:50:09 <ksf> I thought splay trees were dead?
08:50:18 <ksf> too much mutation overhead compared to veb?
08:50:45 <unlink> Oh, those aren't types at all, they are some kind of closure.
08:50:54 <ksf> (not that implementing vEBs would be that feasible in haskell)
08:51:09 <Peaker> stj: why is Int not a strict field?
08:51:57 <ksf> that's not the problem. the problem is that the subtrees are strict.
08:51:58 <Peaker> stj: I think you might need to use explicit mutations - but I'm not sure
08:52:03 <ksf> ...makes the whole spine strict.
08:52:17 <Peaker> ksf: unless that's what he wants...
08:52:59 <ksf> I don't think so, splay trees work their magic by near-root mutations.
08:53:20 <ksf> on the max you'd want to seq a level or two down, but not more.
08:53:30 <ksf> especially as everything there is constant.
08:54:17 <Ragnaroek> newtype SF a = NSF (C a)
08:54:19 <Ragnaroek> (NSF c) >>= f = NSF (c >>= \x -> f x)
08:54:36 <ksf> looks right.
08:54:46 <stj> Peaker: didn't make much of a difference :(
08:54:54 <rwbarton> don't you still need to remove a NSF from that f
08:54:56 <ksf> well, you can make \x -> f x into f
08:55:07 <ksf> oh, yes.
08:56:42 <stj> pardon my lack of experince in haskell, but I'm a bit lost
09:01:07 <stj_> where can I read more about explicit mutations?
09:05:07 <rostayob> stj_: explicit mutation?
09:05:10 <rostayob> *mutations
09:05:18 <worldsayshi> A cabal build question: I'm using leksah to manage my project, but a dependency require the WITHGLUT pragma to be defined. Can I set this in my cabal file or set it somewhere in leksah settings?
09:05:32 <rostayob> splay trees work well in a pure setting
09:07:41 <stj_> rostayob: yes, somebody metioned it here
09:08:04 <Ragnaroek> newtype SF a = NSF {
09:08:05 <Ragnaroek>     cmp :: (C a)
09:08:07 <Ragnaroek> }
09:08:08 <Ragnaroek> (NSF c) >>= f = NSF $ (c >>= \x -> cmp $ f x)
09:08:29 <stj_> I'm a bit disappointed how splay tree in haskell can't get below 10 times slower than in C :/
09:09:37 <quicksilver> stj_: you said you were a newbie to haskell?
09:10:06 <quicksilver> if so, you can't really concluded that "splay tree in haskell can't get below 10 times slower than C" just because you can't do it on your first try...
09:10:57 <stj_> quicksilver: yes :)
09:11:15 <stj_> sure, I agree
09:12:50 <stj_> I'm trying to solve this problem in haskell: http://www.spoj.pl/problems/ORDERSET/
09:13:42 <stj_> and I already have accepted solutions with treap, left-leaning RBT and splay tree in C++ (around 4 secs)
09:19:47 * hackagebot HJVM 0.1 - A library to create a Java Virtual Machine and manipulate Java objects  http://hackage.haskell.org/package/HJVM-0.1 (JeanPhilippeMoresmau)
09:20:08 <ksf> stj, the natural data structure for that one in haskell is any kind of ordered tree.
09:20:30 <ksf> or rather, set, but that's the same in this case.
09:21:14 <ksf> http://hackage.haskell.org/packages/archive/TrieMap/4.0.1/doc/html/Data-TrieSet.html
09:21:17 <ksf> ...in general.
09:21:47 <ksf> though that kth-lowest thing can surely be implemented more efficiently than repeatedly calling minView.
09:24:11 <ksf> the whole thing, *in practice* of course also depends on the ratio of insert/query vs. minview operations.
09:25:15 <Claudius1aximus> > fst . M.elemAt 5 . M.fromList . join zip $ "hello, world"
09:25:17 <lambdabot>   'l'
09:25:39 <LeNsTR> "hello, world" !! 3
09:25:44 <LeNsTR> > "hello, world" !! 3
09:25:45 <lambdabot>   'l'
09:25:50 <LeNsTR> :3
09:27:23 <stj_> ksf: cool, didn't know about that one...
09:27:40 <stj_> but still, it isn't nowhere as powerful as a custom splay tree
09:28:35 <stj_> maybe I'm wrong
09:30:12 <ksf> http://hackage.haskell.org/trac/ghc/ticket/5936  NO DONT DISCUSS DO IT THAT"S WHAT I WANT
09:31:11 <ksf> ...trust no data structure without benchmarking it rigirously in exactly the situation you're using it in.
09:31:51 <ksf> if in doubt, use a standard one and hope it's not part of the 20%.
09:34:48 * hackagebot git-annex 3.20120315 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120315 (JoeyHess)
09:36:35 <mroman> What offers HP more than plain-GHC?
09:36:55 <mroman> If I'm correct ghc also delivers cabal and suck.
09:36:57 <mroman> *such
09:37:32 <dcoutts_> mroman: a bunch of other libs, plus happy, alex
09:37:53 <mroman> I'd like to upgrade to GHC 7.4.1
09:38:08 <mroman> Is it ok if I upgrade to the latest HP and then upgrade GHC to 7.4.1?
09:38:19 <dcoutts_> that's fine, you can choose between stable and well tested, or bleeding edge
09:38:22 <mroman> The latest HP is from 2011 and GHC 7.4.1 is from feb 2012
09:38:34 <mroman> so the latest HP does not include GHC 7.4.1 I guess.
09:38:45 <dcoutts_> mroman: library packages are installed separately for each instance of GHC you have installed
09:38:50 <geekosaur> you can also choose between supported and not supported, or works vs. nobody knows
09:39:08 <mysticc> Is there a B+ tree implementaion on harddisk in haskell ??
09:39:12 <td123> mroman: you will probably have to manage all pkgs yourself, but that probably isn't a big issue
09:39:17 <mroman> dcoutts_: Oh. So I have to reinstall all packages for the new compiler version?
09:39:23 <copumpkin> mysticc: not that I know
09:39:30 <dcoutts_> mroman: yes
09:39:43 <mroman> As long as cabal does the job, that shouldn't be much of a problem.
09:40:01 <quicksilver> it is a problem
09:40:03 <quicksilver> none of them work.
09:40:22 <quicksilver> don't use GHC 7.4 unless you want to fix almost every single package you want to use.
09:40:55 <mroman> Oh. I don't want that :)
09:41:04 <td123> quicksilver: a lot of pkgs work fine with 7.4.1
09:41:18 <ksf> mysticc, I don't think so.
09:41:19 <quicksilver> a lot of packages just require you to adjust the dependencies
09:41:26 <geekosaur> ...
09:41:37 <geekosaur> the arch folks still need to defend their choice, I see
09:41:40 <quicksilver> some won't work even if you do that due to real incompatibilities
09:41:49 <ksf> mysticc, there's your usual db client libraries and things like data-acid
09:42:00 <mroman> I'm currently upgrade to 7.0.4
09:42:03 <td123> geekosaur: I'm talking from personal experience :P
09:42:06 <ksf> oh, and there's also the filesystem or the other.
09:42:09 <mroman> as I would need 7.0.4 anyway to upgrade to 7.4.1
09:42:13 <mightbereptar> I'm coming from a mathematical background, is tryhaskell a good resource to learn haskell?
09:42:13 <mroman> *upgrading
09:42:20 <mysticc> ksf: filesystem ??
09:42:26 <ksf> filesystem.
09:42:32 <ksf> nothing completely serious, though.
09:42:34 <td123> geekosaur: and I'm not defending anything, someone just wants to upgrade to 7.4.1
09:42:53 <ksf> ...if you've got a proper filesystem, you shouldn't need b+ trees, anyway.
09:43:01 <mroman> mightbereptar: That and learnyouahaskell.com
09:43:19 <zachk> easiest way to get 7.4.1 working is using arch linux, if you find arch linux easy.
09:43:31 <ksf> nah the easiest way is gentoo.
09:44:02 <td123> lol :)
09:44:16 <mroman> The new ghci features sounded very convincing to try to upgrade to 7.4.1 :)
09:44:29 <zachk> > length "pacman -S ghc"
09:44:29 <lambdabot>   13
09:44:31 <ksf> derivegeneric and polykinds, too.
09:44:44 <mroman> ghci-decls to be specific.
09:44:50 <mysticc> ksf: Whats b+ trees have to do with proper filesystem ??
09:45:08 <quicksilver> polykinds aren't complete in 7.4 though
09:45:17 <ksf> problem is, there's crash barriers left and right.
09:45:29 <zachk> ksf: what is a crash barrier?
09:45:31 <ksf> ...and that doesn't even mean that you can't get ghc to panic.
09:45:42 <ksf> those metal rails on the side of highways.
09:46:33 <ksf> mysticc, well, they're made for block-access.
09:47:19 <mysticc> ksf: Yeah .. thats what I was trying to do .. to generate index on blocks of a file ..
09:47:28 <Enigmagic> quicksilver: having just done a 7.4.1 rebuild again yesterday... i only had to jigger 3 packages out of 204 that came from hackage
09:47:51 <quicksilver> OK not as bad as I thought Enigmagic
09:47:53 <ksf> oh, I see, the usual suspects only use it for metadata, but common dbs use them as backend.
09:49:00 <ksf> that doesn't, per se, necessiate b+-trees, though.
09:49:06 <mroman> What are polykinds exactly?
09:49:13 <ksf> they're only used because of their high fanout, which reduces disk accesses.
09:49:38 <ksf> as log_large(n) < log_small(n), even if theorists tell you otherwise.
09:49:49 <mroman> Section 7.8.1 in the release notes is not very specific on that.
09:50:21 <ksf> mroman, there's a whole chapter in the manual.
09:51:14 <ksf> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html
09:51:58 <mysticc> ksf: what else can I use for the same purpose ...
09:52:12 <mysticc> I mean for indexing the blocks..
09:52:37 <ksf> any data structure whatsoever.
09:52:59 <ksf> ...well, any map-like.
09:53:05 <mroman> I have no idea what a "kind" is.
09:53:14 <ksf> the type of a type.
09:53:20 <ksf> and the type of a kind is a sort.
09:53:28 <ksf> so you get value -> type -> kind -> sort
09:53:45 <mysticc> ksf: But again I will have to serialize it .. because I want it to be external ..
09:54:26 <ksf> there's binary instances for those data structures.
09:54:32 <ksf> ...just write them to disk.
09:54:48 <ksf> that's going to do what you want semantically, performance is another question.
09:55:43 <quicksilver> it sounds a little like you're being deliberately obtuse, ksf
09:55:56 <mysticc> ksf: But again I have to handle the case where I want only partial data in memory and rest on the file.. when map is much greater then my main memory..
09:55:57 <mroman> hm.
09:56:03 <quicksilver> the niche of the B+-tree and similar structures is the case where the index is too large for memory.
09:56:13 <mroman> type family Elem c :: *
09:56:15 <quicksilver> you don't use Binary instances or in-memory-datastructures for this case.
09:56:22 <quicksilver> you use direct access to on-disk tree
09:56:27 <mroman> ^- a type family which allows all types?
09:56:27 <quicksilver> (and trust the OS to cache what it can)
09:56:47 <ksf> mysticc, the map including the data at the leaves or just the index, with integers or whatever as indices into the file?
09:57:06 <quicksilver> I don't know of an on-disk index lib on hackage although it sounds plausible someone would have done one.
09:57:16 <ksf> in that case I'd say use a database.
09:57:59 <quicksilver> unless, for example, you are writing a database.
09:58:16 <ksf> mroman, no, a type family saying that any concrete Elem <concrete type> has kind *
09:58:16 <quicksilver> I have a partial B*-tree implementation lying about somewhere from a prototype database I was working on.
09:58:17 <mysticc> quicksilver: you just got what I was about to say :)
09:58:59 <mysticc> quicksilver: was working or still working ?
09:59:47 <quicksilver> was working, it was a few years ago
10:00:13 <quicksilver> thought haskell would be a good platform for writing a better relational database
10:00:18 <quicksilver> but free time ran a bit short
10:00:36 <ksf> filtering the whole thing through my quick and dirty filter, I'd say represent the tree as directories and files.
10:00:50 <ksf> one node should easily fit into memory.
10:01:03 <ksf> ...but then you might not be inclined to quick+dirty ;)
10:01:11 <mysticc> quicksilver: hmm .... I think then I will have to write an implementation on my own .. still surprised that no package exist for it ..
10:01:48 <ksf> it's a pretty specialised thing, and haskell isn't that big in systems programming.
10:01:57 <ksf> binding to a c library is an option, too.
10:02:03 <mysticc> ksf: I am quite oriented towards the performance side .. so definately dont want to do that :)
10:02:35 <quicksilver> mysticc: well it's an obscure use case, you only need it for writing on-disk indicies.
10:02:43 <quicksilver> mysticc: it's not hard, anyway.
10:03:13 <mysticc> quicksilver: whats not hard ..
10:05:18 <quicksilver> mysticc: B*-trees
10:05:21 <quicksilver> mysticc: (or whichever)
10:19:49 * hackagebot test-framework 0.6 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.6 (MaxBolingbroke)
10:19:51 * hackagebot test-framework-quickcheck2 0.2.12.1 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.12.1 (MaxBolingbroke)
10:22:24 <scooty-puff1> if overlapping instances must be used in a particular situation, is there a good way to minimize just how bad they are?  i assume make the module that has that enabled as small as possible, maybe don't export the class that is defined in that module, if possible?
10:45:10 <shepheb> damn it, I upgraded to 7.4.1 on a small VM I use to host some things, and it's swap thrashing while trying to compile my Yesod application's Model. too much TH.
10:45:59 <shepheb> it's progressing by roughly 0.5 CPU seconds per minute
10:46:14 <miller> shepheb: oh wow
10:47:29 <luite_> shepheb: yeah it's known to use a lot of ram for that
10:47:46 <luite_> I think the latest persistent already has some improvements
10:47:54 <shepheb> I'm wondering what options I have, aside from asking my sysadmin for more RAM I probably won't get.
10:48:07 <shepheb> I just cabal installed it, though possible the .cabal limited the version.
10:48:12 <luite_> compile locally generally seems to be the advice
10:48:15 <xil> hi everyone. If GHC is smart enough to skip over a trace with an unchanging second argument, does that mean there's a chance that trace won't be run even once?
10:48:30 <shepheb> luite_: as in, compile on a bigger box and push to the server?
10:48:43 <luite_> shepheb: yeah
10:48:46 <shepheb> -_-
10:51:03 <shepheb> sigh.
10:54:50 <xil> anyone know how I can ensure a trace is output?
10:56:42 <geekosaur> make sure you;re evaluating it?
10:56:45 <xil> I basically have {trace "some string" ""} and I can see why that's not being output, but not even once?
10:56:58 <c_wraith> if it's not being output, it's not being evaluated.
10:57:00 <xil> that empty string is needed many times
10:57:10 <geekosaur> apparently not
10:57:17 <xil> I assumed it's GHC magic that is keeping the trace from being evaluated
10:57:25 <c_wraith> trace is *exactly* tracing evaluation.
10:57:38 <c_wraith> if it's not being evaluated, it won't be printed
10:57:51 <xil> so if the trace isn't producing output at the terminal then I can be sure the second argument isn't called upon?
10:58:13 <c_wraith> you can be sure the expression containing the trace isn't being evaluated
10:58:21 <xil> right, okay hmmm
10:58:23 <xil> thanks =]
11:00:04 * hackagebot leksah-server 0.12.0.5 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.12.0.5 (HamishMackenzie)
11:00:26 <sm> shepheb: limit GHC's maximum heap size. Eg: +RTS -M400m
11:00:54 <shepheb> sm: will it still manage to build?
11:01:25 <sm> everything has built for me within 400 megs, just a little slower
11:03:00 <sm> IIRC
11:09:55 <t7> @hoogle m m a -> m a
11:09:56 <lambdabot> Control.Monad.Trans.Identity runIdentityT :: IdentityT m a -> m a
11:09:56 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
11:09:56 <lambdabot> Text.Regex.Base.RegexLike getAllMatches :: AllMatches f b -> (f b)
11:10:04 <t7> @hoogle m (m a) -> m a
11:10:04 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
11:10:04 <lambdabot> Test.QuickCheck.Property joinRose :: Rose (Rose a) -> Rose a
11:10:04 <lambdabot> Prelude concat :: [[a]] -> [a]
11:14:13 <xil> does anyone know if Text.Regex handles posix extended regular expressions? things like the or operator '|'?
11:17:44 <geekosaur> with the PCRE variant or regex-posix (see compExtended, which appears to be the default)
11:24:47 <xil> it looks like I do have the right version. So my next question is how I go a group, like (cat|dog)? Can I just use parentheses since they are part of the specification for something else?
11:25:28 <geekosaur> "yes" and I suggest you study POSIX EREs; Haskell does not define them
11:26:35 <xil> geekosaur: I've studied the spec on the wiki, I'm just trying to make sure of the source of the error I'm having
11:28:42 <xil> here's a funny thing I noticed though. It says the ERE spec removed support for \n backreferences, but they seem to work with this....
11:29:43 <shepheb> sm: heh, no dice.
11:29:53 <shepheb> it errored out
11:29:58 <geekosaur> if they were in the sepc and then removed, then whether they work or not depends on the backend you're using and which version of the spec it (or the libraries it uses) implements
11:35:11 <xil> geekosaur: well all that matters right now is that it works. Thanks =]
11:39:26 <hikingpete> @pl (\x -> 89 `mod` x /= 0)
11:39:26 <lambdabot> (0 /=) . (89 `mod`)
11:45:13 <hikingpete> @pl (\x -> x /= 1 && x /= 89)
11:45:14 <lambdabot> liftM2 (&&) (1 /=) (89 /=)
11:45:37 <otters> :t (1 /=)
11:45:38 <lambdabot> forall t. (Num t) => t -> Bool
11:46:01 <geekagent> otters: It's lifting into the (->r) Monad.
11:46:06 <otters> yeah I know
11:46:49 <c_wraith> geekagent: missing some parens.  It's lifting into (r->), which has to be written as ((->)r)
11:47:50 <geekagent> c_wraith: Yeah, I know.
11:48:16 <geekagent> (->)r Monad
11:48:48 <otters> it's not like it's incomprehensible if you write (->r)
11:48:52 <otters> I don't get why people are up in arms about it
11:49:02 <hpc> otters: because (-> r) is different
11:49:07 <ski> well, it's wrong
11:49:18 <otters> okay
11:49:36 <hpc> > let foo = (/ 3) in foo 6
11:49:37 <lambdabot>   2.0
11:49:38 <c_wraith> (-> r) is something very different.
11:49:41 <hpc> > let foo = (3 /) in foo 6
11:49:42 <lambdabot>   0.5
11:49:44 <c_wraith> that's the main reason
11:49:52 <otters> what is it
11:49:59 <ski> `(-> r) a' would be the same as `a -> r', while `(r ->) a' would be the same as `r -> a' -- assuming it would follow the same rules as other sections
11:50:00 <hpc> haskell doesn't let you do type sections
11:50:06 <hpc> and ghc needs an extension turned on
11:50:21 <c_wraith> and it can't be a Monad instance without a newtype wrapper, either.
11:50:39 <c_wraith> Actually, probably can't be a monad instance anyway
11:50:39 <ski> c_wraith : `(r ->)' can
11:51:01 <tgeeky__> isn't one of these the "env" or reader monad?
11:51:02 <ski> hm, i suppose you meant `(-> r)'
11:51:11 <cadabra> Suppose you have "loop f = f >> loop f". Can f maintain state? I guess f can reference one or more IORefs. Can I use the state monad here?
11:51:12 <ski> and that can't be a monad, since it's not covariant
11:51:31 <ski> tgeeky__ : yeah, `(r ->)' is
11:51:42 <geekagent> (-> r) (Parens correct this time) would make a CoMonad.
11:51:44 <c_wraith> cadabra: you could use StateT.  But that's probably more complicated than you want
11:51:45 <ski> it's the environment monad
11:51:48 <cadabra> Suppose that every time f is invoked, I want to print "Nth invocation". How do I do that?
11:51:58 <ski> geekagent : no, comonads also have to be covariant
11:52:11 <c_wraith> cadabra: if that's all you want, I'd change loop to take a counter
11:52:14 <ski> both monads and comonads have to be (covariant) functors
11:52:16 <geekagent> ski: right.
11:52:27 <ski> a contravariant functor can be neither a monad nor a comonad
11:52:28 <otters> oh
11:52:37 <cadabra> c_wraith: can I do it without changing loop?
11:52:37 <c_wraith> loop n f = f n >> loop (n + 1) f
11:52:39 <otters> okay i'm lost then
11:52:41 <tgeeky__> ski: and that's invalid haskell syntax, right?
11:52:48 <c_wraith> cadabra: no.
11:53:04 <cadabra> Couldn't I do it with an ioref?
11:53:21 <ski> tgeeky__ : hpc seemed to suggest GHC will accept `(r ->)' with an extension -- i'm not sure whether it would accept `(-> r)', though
11:53:37 <ski> (but yes, in the standard it's not allowed syntax)
11:54:40 <tgeeky__> ski: ok. I don't think there is an extension that will make it work (that I know of), but maybe
11:54:43 <tgeeky__> hpc: is there?
11:54:56 <ski> cadabra : i would go for an argument as well, if it's just a single recursive `loop'
11:55:32 <cadabra> Well, loop isn't as simple as that. That's just to illustrate what's happening.
11:55:39 <ski> tgeeky__ : well, conceivably, writing `(-> a) r' could work, even though e.g. `Mu (-> a)' wouldn't
11:55:52 <hpc> tgeeky__: yo
11:56:03 <ski> tgeeky__ : maybe `Foo (-> a)' could also work, assuming `Foo' was a type synonym which applied its argument to a type
11:56:24 <c_wraith> cadabra: you could certainly do it with an IORef - you would just have to make sure that the definition of f closes over an IORef
11:56:25 <cadabra> All I'm saying is I have some IO () that will be invoked over and over again, and I'm wondering what my options for maintaining state are.
11:56:37 <hpc> tgeeky__: oh, thought you were asking if i was there
11:56:54 <hpc> tgeeky__: uh, not sure what the extension is, or if it even exists
11:56:56 <cadabra> I can do it with an IORef, I can keep state in a file on disk, etc, etc. Anything else interesting here?
11:56:59 <ski> cadabra : `IORef'/`MVar'/&c., `StateT s', explicit argument
11:57:15 <hpc> i know if it did exist, it would need the extension that makes type synonyms magic
11:57:44 <hpc> and then sections would fall naturally out of 'type flip a b = b a
11:59:56 <ski> itym `type Flip f a b = f b a'
12:00:21 <hpc> ski: oh, yes that
12:00:31 <Glorious> hi i want to get the minimum of a string of numbers recursively and return an int
12:00:33 <Glorious> i have
12:00:38 <Glorious> min1 :: String -> Int
12:00:42 <Glorious> min1 (x:xs) = x < min1(xs)
12:00:46 * hpc is distracted by a huge talk that was transcribed instead of filmed
12:00:53 <Glorious> how do i make this work?
12:02:03 <ski> Glorious : i would suggest naming the result of the recursive call in a `where', to begin with
12:02:19 <ski> then, use guards or `if'-`then'-`else' (or `case')
12:02:32 <c_wraith> cadabra: if you are restricted to something of type IO (), your options are going to "store in a mutable cell in memory" or "store in some other resource accessed via IO, which might include disk, network, or other even more bizarre things"
12:02:50 <ski> c_wraith : .. and arguments, depending
12:03:13 <c_wraith> ski: doesn't arguments imply *not* IO ()?
12:03:34 <ski> no, you can use `loop :: Int -> IO ()', just fine
12:03:58 <ski> (and then the initial call to that would have type `IO ()')
12:04:25 <Glorious> ski could u help me with a short answer
12:04:38 <ski> Glorious : my answer above wasn't short ?
12:04:45 <shepheb> I ended up increasing to 1GB RAM on the VM, and it worked (though it still used all the RAM and chugged a bit...). oh well.
12:04:46 <c_wraith> ski: uh.  That's not the setup in question.  Each time you call that action, it would repeat the same loop, not increment from the previous one.
12:06:00 <ski> c_wraith : hm, i can't infer that from what cadabra was saying
12:07:25 <ski> it sounded to me that cadabra had a simple recursive `loop', and then it should be possible to do what i said -- this is assuming it is not involved in mutual recursion
12:07:25 <c_wraith> ski: the question was "carry state across multiple executions of an action with type IO ()".  When you're restricted to that being the exact type of what you pass in to the thing that executes multiple times, you don't really have non-IO options
12:08:17 <ski> hm, i suppose what cadabra said *could* be construed as meaning that `loop' is called from somewhere else more than once, and cadabra wants to maintain state wrt these different initial invocations -- this wasn't the way i interpreted it, though
12:08:45 <jeff_s_> Is there a good way to use functions that return types (STM (Either ...)) and (Either ...)? I'm wanting to use do notation, but I'm not clear on how to make STM (Either...) behave like (Either...). Basically I'm expecting that anything that ends up as (STM (Left ...)) returns immidiately.
12:09:19 <ski> c_wraith : i don't follow
12:09:27 <jeff_s_> Or should I be using exceptions or invariants or something?
12:09:47 <ski> maybe you're assuming that `f' here should also have access to the state -- it didn't seem to me that that's what cadabra wanted, though
12:10:45 <c_wraith> ski: despite saying that he couldn't change "loop", as it was a stand-in for something more complicated that he has to work with?  What else could that possibly mean?
12:10:47 <ski> jeff_s_ : you want an `EitherT' thing, like in `EitherT Foo STM a'
12:10:56 <jeff_s_> ski - thanks, that sounds right
12:11:11 <ski> jeff_s_ : maybe it's called `ErrorT' still, i don't recall, but if there's an `EitherT', i'd use that
12:12:26 <ski> c_wraith : hm, i don't see where cadabra said s/he can't change `loop' -- i only see where s/he asked whether it could be avoided
12:12:45 <ski> maybe cadabra really meant the former, though
12:13:41 <ski> (i.e. it could mean that cadabra only would like to avoid it (for whatever reason i don't know))
12:14:33 <ski> (c_wraith : i'm sorry if i'm annoying you; just explaining how i understood it)
12:14:45 <c_wraith> ski: that's fine.  I don't mind.
12:14:59 <tgeeky__> i love being annoyed. It makes me feel alive!
12:24:28 <jeff_s_> ski - there is an EitherT package. I'll try that.
12:25:28 <alsasounda> is SS--uominen a nazi?
12:25:41 <roconnor> preflex: seen chirsdone
12:25:41 <preflex>  Sorry, I haven't seen chirsdone
12:25:47 <roconnor> preflex: seen chrisdone
12:25:47 <preflex>  chrisdone was last seen on #haskell 4 days, 8 hours, 40 minutes and 5 seconds ago, saying: from http://hackage.haskell.org/packages/archive/haskell-src-exts/1.11.1/doc/html/Language-Haskell-Exts-Syntax.html#g:5
12:26:15 <monad> preflex: seen monad
12:26:16 <preflex>  monad was last seen on #haskell 8 days, 18 hours and 22 minutes ago, saying: Inspired by Liebniz however
12:26:31 <monad> Good, good.
12:27:08 <roconnor> @ask chrisdone why do the line numbers peter out in http://hpaste.org/65089 ?
12:27:08 <lambdabot> Consider it noted.
12:27:40 <jeff_s_> I love that this channel has a secretary.
12:28:16 <dfletcher> heh I just installed a lambdabot to play around, the default install has a stock ticker :)
12:28:25 <dfletcher> @ticker SBUX
12:28:25 <lambdabot> SBUX: 52.955 +0.275 (+0.52%) @ 3/15/2012 3:13pm
12:28:27 <dfletcher> :)
12:28:33 <roconnor> @ticker VTI
12:28:33 <lambdabot> VTI: 72.34 +0.41 (+0.57%) @ 3/15/2012 3:12pm
12:28:36 <roconnor> :O
12:28:51 <jeff_s_> Wow, that's awesome.
12:29:05 <roconnor> move over google finance
12:29:06 <jeff_s_> You know how much a business person 50 years ago would pay for a lambdabot? At least dozens of dollars.
12:29:21 <dfletcher> heh
12:29:24 <jeff_s_> (Because there was no internet to support it at the time, it's not worth much without that.)
12:53:55 <merijn> Design question: I'm implementing a connection handler for a socket which should logically do "read a bunch of lines, respond to them and at some point replace yourself with a different handler" should I just say "eh, screw it" and implement all the handlers as "IO String -> IO ()" or is there a more elegant method I'm not considering (I looked at Arrows for a bit, but that quickly looked a lot more complex and less elegant than the simple
12:53:55 <merijn> approach)
12:59:14 <Claudius1aximus> merijn: something like this perhaps? newtype Handler a = Handler (a -> IO (Maybe (Handler a)))
13:00:03 <merijn> I thought of that, but that really doesn't get you all the much clarity as opposed to just passing the IO String around
13:00:10 <hpc> Claudius1aximus: i think there's something like that that parameterizes over the monad
13:00:26 <hpc> in FRP or something
13:01:31 <merijn> And putting it in Maybe is not really necessary, there is already a catch to deal with the exception from read to empty socket (i.e. closed on the remote side, who the f'decided that should throw an exception?!?) so you can just as easily keep going and exception out without the Maybe
13:02:22 <merijn> It's just that after starting to work out a similar approach I didn't see it substantially simplifying the code, was just wondering if I missed some obvious alternative
13:03:32 <hpc> merijn: is there a way to squeeze "IO String -> IO String" out of what you want?
13:03:38 <hpc> then you might be able to compose handlers
13:06:02 <merijn> hpc: What I want is something like pass the socket to login handler (read username/password, repeat until finished, then switch to relevant handler for connected user)
13:06:11 <cmccann> merijn, it probably wouldn't simplify the code as such, unless you can use pre-existing generalizations that come with lots of handy stuff pre-written
13:06:39 <merijn> I guess you could use hGetContents to get IO [String], but then you run the risk of lazy IO shenanigans?
13:06:59 <tasuret> I have a question about Text.Regex.Posix
13:07:03 <jeff_s_> Hey, lazy IO Is great!
13:07:04 <cmccann> the type Claudius1aximus suggested is about 80% of the way to the usual automaton arrow
13:07:11 <jeff_s_> (Except if you close the SQL connection too early.)
13:07:18 <hpc> merijn: and you also don't get to say with as much certainty that you read in the right order
13:07:40 <hpc> something could get (stream !! 4096) and something else later uses (stream !! 5)
13:07:57 <merijn> cmccann: yeah, I saw that. But as I said, I don't feel the generality really gets me anything substantial
13:08:22 <hpaste> tasuret pasted “testing Regex” at http://hpaste.org/65356
13:09:13 <cmccann> merijn, like I said, it probably doesn't unless you make substantial use of existing stuff that uses the generalized forms
13:09:33 <hpc> merijn: loop :: IO (String, Bool) -> IO String -- perhaps this function might help?
13:09:40 <merijn> ok, so party at IO's place it is
13:10:18 <hpc> loop act = repeat act until snd is True
13:10:40 <merijn> Yeah, I wrote something like that before I got sidetracked into trying to do it with fancy arrows
13:10:40 <hpc> or something
13:10:58 <hpc> might need to make the parameter a function or something crazy
13:11:38 <hpc> also, you should try (ReaderT Socket)
13:12:49 <merijn> I'm not really sure I understand the Reader monad yet
13:13:31 <lukish> Can anyone helps with vimrc? I put all hs_ options described in http://vimdoc.sourceforge.net/htmldoc/syntax.html , but "where" word still not highlighted. Why?
13:14:15 <hpc> lukish: how is your vim installed?
13:14:29 <hpc> on my machine, i just :syntax on
13:15:19 <cmccann> merijn, Reader is just a newtype around functions
13:15:40 <hpc> @unmtl ReaderT env m a
13:15:40 <lambdabot> env -> m a
13:15:49 <lukish> hpc: i have module word highlighted, for example. Syntax is on, yes
13:15:51 <cmccann> merijn, when you "run" something using Reader the "environment" value you give it is basically an extra argument to everything
13:16:16 <hpc> lukish: i mean, did you get it from apt/pacman, compiled yourself, or what?
13:16:36 <hpc> you might not have the right syntax file
13:16:56 <hpc> (or whatever it's called; the thing that says "this is what haskell looks like")
13:17:08 <lukish> I made my own ~/.vim/after/syntax/haskell.vim
13:17:49 <hpc> ah
13:19:01 <hpc> i don't think enabling those documented flags will do anything then
13:20:07 <hpc> or perhaps i misunderstand how after syntax works...
13:20:58 <hpc> try commenting your whole .vim file, then uncommenting gradually until things break
13:23:05 <ChristianS> lukish: what do you want to change compared to vim's standard syntax file for haskell? it works pretty fine for me...
13:55:14 * hackagebot RepLib 0.5.2 - Generic programming library with representation types  http://hackage.haskell.org/package/RepLib-0.5.2 (BrentYorgey)
13:55:16 * hackagebot unbound 0.4 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.4 (BrentYorgey)
13:55:49 <jeff_s_> Ah, now I know who byorgey is.
13:56:17 <xil> hi everyone. Something weird happening. I have 2 empty strings and when I compare them with == I'm getting False, I think. At least, it's the input to an if and I'm getting the "else" side of things
13:56:37 <c_wraith> xil: I would suggest one of them isn't empty, then.
13:57:04 <byorgey> jeff_s_: I am trying to figure out under what circumstances you could have not known before but now know after seeing only those two hackagebot announcements.
13:57:11 <jeff_s_> xil: That, or you're importing some unusual instance for Eq String.
13:57:14 <xil> c_wraith: one is a constant "" and the other one is printed as part of the "else" condition
13:57:33 <c_wraith> xil: or else you're confused about what's actually evaluating.
13:57:40 <unlink> Do I have some huge space leak here? This takes an unexpectedly large amount of ram (and isn't too fast either): https://gist.github.com/8e66ee26c4ec7065968e
13:57:47 <xil> jeff_s_: wouldn't the compiler throw an error about which == to use?
13:57:55 <jeff_s_> byorgey - now I know more about your name.
13:58:02 <worldsayshi> A question to anyone: I'm hacking at a cabal file and trying to turn a second cabal project a dependency of the first. Is there a way to make cabal recognize a dependency that isn't yet installed? Essentially I want to be able to work on two packages at the same time where one depends on the other.
13:58:10 <byorgey> jeff_s_: ah, I see =)
13:58:10 <c_wraith> yes, importing conflicting instances, then attempting to use them, results in a compiler error
13:58:14 <jeff_s_> xil: Not if you weren't getting the default one from Prelude. I think it's kind of unlikely. I was just throwing it out there.
13:58:47 <dcoutts_> worldsayshi: you can register it inplace, or register it into a local package db
13:58:56 <byorgey> worldsayshi: if you use cabal-dev you can do 'cabal-dev add-source path/to/other/project'
13:59:04 <dcoutts_> worldsayshi: cabal can do the using the --package-db flag
13:59:15 <tromp__> xii: what do you get if you also print the string's length in the else branch
14:00:03 <dcoutts_> byorgey: that takes a snapshot right?
14:00:11 <byorgey> dcoutts_: yes
14:00:29 <dcoutts_> so may or may not be what you want when working on a pair of packages
14:00:38 <Clint> dcoutts_: can you advise on how to have Cabal pass the output of `getconf LFS_CFLAGS` to the relevant programs it invokes?
14:00:49 <byorgey> indeed.  you can also, say, cd to the parent directory and do  cabal-dev install package1/ package2/
14:01:08 <byorgey> worldsayshi: see the README here: https://github.com/creswick/cabal-dev
14:01:16 <dcoutts_> byorgey: is that doing anything different from cabal install package1/ package2/
14:01:31 <byorgey> dcoutts_: it puts the results in a local package DB
14:01:37 <dcoutts_> ah, in the current directory
14:01:38 <worldsayshi> Ah, thanks dcoutts_ and byorgey. I will look into it and see what I can make of it. Finally. :)
14:01:44 <byorgey> but otherwise my understanding is no.
14:01:51 <byorgey> dcoutts_: right
14:01:58 <tgeeky__> dcoutts_: or --sandbox=./anywhere/you/want/it/
14:02:07 <dcoutts_> byorgey: ok, so it's automating the --package-db=./somewhere/
14:02:12 <byorgey> dcoutts_: right.
14:02:41 <dcoutts_> Clint: you'll need to put custom code in the Setup.hs
14:02:57 <worldsayshi> oh
14:03:11 <worldsayshi> for cabal-dev?
14:03:12 <dcoutts_> Clint: in the conf hook it's possible to alter the flags for programs called
14:03:41 <dcoutts_> worldsayshi: sorry, what's the question exactly?
14:04:20 <worldsayshi> Do I need to customize Setup.hs when using the cabal-dev solution?
14:04:35 <worldsayshi> oh
14:04:36 <Clint> dcoutts_: so make a hook that tweaks the LocalBuildInfo output of configure?
14:04:40 <dcoutts_> worldsayshi: no, I was talking to Clint, answering his earlier question
14:04:53 <worldsayshi> yes, sorry. I see
14:05:19 <dcoutts_> Clint: right, and iirc, one of the components of that is the program configuration
14:05:46 <dcoutts_> Clint: and there's a module for playing with that, D.S.Program.*
14:06:00 <Clint> ok, i'll give it a shot. i was trying to do it earlier on and it wasn't taking
14:06:17 <dcoutts_> Clint: if it's just c flags or something then you can just modify the LocalBuildInfo
14:06:28 <dcoutts_> Clint: e.g. by merging a HookedBuildInfo
14:06:47 <Clint> yeah, it'll just be two -Defines or an empty string
14:07:08 <Clint> but passing --hsc2hs-options etc. doesn't work either
14:08:12 <yan_> applicative functions can contain either a function or a value, but the 'last' one in a chain of <*> needs to be a value.. is that a correct way to think about it?
14:08:36 <c_wraith> yan_: not really.
14:09:07 <c_wraith> > pure fix <*> Just (1:)
14:09:08 <lambdabot>   Just [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:09:59 <dmwit> I have a cabalized project which has a library and an executable. I want to put the executable's Main.hs in a directory. What's a good name for that directory?
14:10:53 <ski> yan_ : it's better then to say that the first one in the chain must "contain" a function
14:11:28 <yan_> ski: would it be accurate to say every intermediate one needs a (->)?
14:11:48 <yan_> (i'm obviously very new to haskell, coming from c/scala/clisp/others)
14:11:58 <ski> yan_ : no
14:12:04 <c_wraith> yan_: intermediate ones don't need ->
14:12:16 <ski> > pure (&&) <*> Just True <*> Just False
14:12:17 <lambdabot>   Just False
14:12:51 <ski> yan_ : it would be correct to say that the first one needs as many `->'s as the number of the others
14:13:05 <ski> @type \a b c d -> a <*> b <*> c <*> d
14:13:06 <lambdabot> forall (f :: * -> *) a a1 a2 b. (Applicative f) => f (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
14:13:10 <c_wraith> ski: (not counting ones in parens..)
14:13:24 <td123> > (&&) <$> Just True <*> Just True
14:13:25 <lambdabot>   Just True
14:13:36 <ski> here `a', of type `f (a -> a1 -> a2 -> b)' must contain (at least) three `->', since there's three of the rest : `b`,`c',`d'
14:14:06 <c_wraith> yan_: really, these aren't things that there are short summaries like you want for.  The only accurate version is "the types of the functions must fit together".
14:14:25 <c_wraith> err, types of the *expressions*
14:14:48 <ski> yan_ : yes, all this are just consequences of the type of `(<*>)' -- it's not magical, it's just a library function
14:15:09 <yan_> c_wraith: i'm just trying to wrap my head around functors/applicative functors to begin with. i see the power in functors alone and being able to abstract the inner type, but i'm having a harder time seeing the beauty in applicative functors
14:15:12 <ski> it follows the same typing rules as the rest of the language
14:15:42 <ski> yan_ : maybe it would be easier for you to first grasp monads (i don't know)
14:16:13 <yan_> ski: i thought about just moving ahead through monoids, and them monads (of which i have a superficial understanding) and come back to this later
14:16:17 <yan_> *and then
14:16:27 <c_wraith> monoids are way easier.  They're not higher-kinded :)
14:16:32 <ski> yan_ : functors are quite simple. applicative functors are more complex -- they're a bit like monads, but somewhat more general
14:16:56 <ski> (and functors are more general than applicative functors in turn -- but functors are conceptually very simple)
14:17:11 <yan_> also i've been reading through this in a vacuum, which isn't usually how i approach learning a new language
14:17:34 <yan_> but i felt like it would be harder to dive into code of an existing project before goign through this
14:17:42 <ski> you use applicative functors where you would otherwise use a monad, because of : (a) applicative functors often give nicer-looking code; (b) sometimes you need something which can't be a monad, but is an applicative functor
14:18:02 <ski> so, the use-cases for applicative functors are often related to the use-cases of monads
14:18:16 <ski> that was why i said that you maybe have more luck first understanding monads
14:18:21 <c_wraith> (c) sometimes, the applicative instance is optimized in ways the monad instance can't be.
14:18:42 <c_wraith> (c) applies, in particular, to some parser libraries.  uu-parsinglib is the one that comes to mind.
14:18:43 <ski> yeah, that too
14:18:44 <yan_> fair enough, i'm just reading 'learn you a haskell' cover to cover.. i'll get through everything first then return to functors for review and go through applicative functors
14:19:10 <yan_> it makes sense as i read it, but i don't grok it or have an inate feeling of it that i do for a lot of other topics that are a lot more relatable to from other languages/math
14:19:36 <ski> yan_ : yeah, both for monads and applicative functors you will need many examples of specific such to see what they're good for, and how to use them
14:20:00 <c_wraith> yan_: pulling out an editor and ghci and just playing with things often helps make sense of it.  Though monads in particular only really make sense after you see a few ways they're used, and what the commonalities are.
14:20:14 <ski> yan_ : with some experience and exposure to it, it will come
14:20:32 <yan_> i'm sure eventually it becomes second nature but just struggling along through now.. (my first line of haskell was three days ago heh)
14:20:44 <yan_> alright back to ghci+book later tonight
14:20:58 <jeff_s_> One thing I found useful for learning monads was how to desugar and resugar do notation.
14:21:12 <ski> yan_ : also, it's often very helpful to see how the code would have been written if it *hadn't* used monads or applicative functors -- seeing this helps much with seeing what monads and applicative functors are good for, and when to use them
14:21:35 <jeff_s_> Similarly, learning how to sugar and desuger list comprehensions.
14:21:52 <yan_> will do, i'll finish the book first, then look for example code, then come back if i still don't get it
14:22:12 <xil> this is so bizarre. I have a Map and I go through the whole thing producing some PHP files. When I add a trace to output one of the fields in the structure in the Map I get this nice list of stuff that I know is there, but something is missing. The trace doesn't output this one thing, yet it's in the final php file, meaning it WAS there. What?
14:22:33 <xil> wow I spoke too soon. So sorry everyone
14:22:44 <xil> rubber duck to the rescue *facepalm*
14:22:59 <ski> yan_ : "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> is a somewhat old, but (imo) still a good starting tutorial for what monads are good for
14:23:35 <jeff_s_> You guys should try to get yan_ to start with Arrows, instead.
14:24:08 <ski> (note that what it calls `accumulate' is actually called `sequence' nowadays, though)
14:24:14 <c_wraith> jeff_s_: I'd argue no one should use arrows.  that's simpler yet. :)
14:24:51 <xil> quick infix precedence question. Would an infix function I make have higher or lower precedence than (++)?
14:25:02 <ski> c_wraith : could Fudgets be rephrased in terms of an applicative functor ?
14:25:14 <ski> xil : depends on what fixity you specify for it
14:25:24 <xil> ski: I meant that I didn't specify
14:25:27 <ski> xil : if you don't specify any, i think the default was `infixl 9'
14:25:32 <jeff_s_> c_wraith: I learned a bit about arrows when I was doing some hacking with HaXml. It was rather painful. The concepts aren't hard, but all the little extra arrows in the library make it tough to know which to use.
14:25:49 <ski> you could check the report (or use `:i' in the interactor) to make sure
14:26:48 <xil> ski: ah okay, then one more thing, does a lower number mean it is executed sooner or later?
14:27:14 <ski> higher numbers means it binds tighter, lower means it binds looser
14:27:27 <ski> when things are executed is unrelated to this
14:28:00 <ski> e.g. in `False && 1+1 == 2', the `1+1' is never evaluated
14:28:08 <yan_> jeff_s_: do you mean learning more about the -> operator in general, and not just looking at it when declaring types? (as i do now)
14:28:32 <ski> the precedences of `&&',`+',`==' here only means that `False && 1+1 == 2' is interpreted as if you had written `False && ((1+1) == 2)'
14:28:33 <xil> ski: was a poor choice of words on my part, I meant what you said. So my infixl 9 is processed before infixr 5?
14:28:44 <ski> execution or evaluation doesn't enter the picture
14:28:45 <jeff_s_> yan_: Sorry, no. Ignore my comments about Arrows. :)
14:29:00 <yan_> jeff_s_: fair enough :)
14:29:08 <ski> xil : yes, i just wanted to correct the terminology :)
14:29:25 <xil> ski: yeah I know my terminology is wrong =P, but I know what you mean about it all
14:29:35 <xil> thanks =D
14:29:40 <ski> xil : yes, iirc, it gets `infixl 9' by default, and in that case your infix function would bind tighter than `++'
14:30:26 <merijn> Operators are infl 9 by default, yes
14:30:30 <ski> xil : you could always ask the interactor which fixity it gets, using `:i' (assuming it's defined at the top-level of the module)
14:31:35 <xil> ski: I'll check before running this but I'm pretty sure you're right that it's infixl 9
14:31:49 <xil> but ++ get's r 5, I checked that with :i
14:32:08 <ski> yes
14:34:20 <dmwit> "cabal install cabal-install" always makes me feel a bit meta
14:34:47 <dcoutts_> eventually it'll be just cabal install cabal
14:35:12 <dcoutts_> dunno if that's more or less meta
14:35:44 <xil> ski: it doesn't say when you don't specify apparently
14:37:40 <ski> xil : hm, ok
14:37:45 <ski> the report then, i guess
14:37:49 <ski> @where report
14:37:49 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
14:38:00 <xil> ski: thanks =]
14:40:39 <ski>   "If no fixity declaration is given for `op` then it defaults to highest precedence and left associativity"
14:40:42 <ski>   <http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-240003.2>
14:40:45 <ski> xil ^
14:41:02 <xil> haha, thanks again =]
14:41:15 <ski> (and `9' is the highest one can specify for an operator -- though application has precedence `10')
14:41:35 <ski> (so, maybe it's actually `infixl 10', but i would expect `infixl 9')
14:41:36 <hpaste> dmwit pasted “making xmonad exe depend on xmonad lib” at http://hpaste.org/65359
14:42:18 <hpaste> dmwit pasted “cabal error for previous paste” at http://hpaste.org/65360
14:42:28 <dmwit> dcoutts_: ping =)
14:43:04 <dcoutts_> dmwit: the xmonad prog needs to depend on base
14:43:19 <dmwit> dcoutts_: See the if flag(small_base) section?
14:43:24 <dcoutts_> where?
14:43:39 <dmwit> Oh, wait, that's if flag(testing) && flag(small_base)
14:43:42 <dmwit> How did this build before?
14:43:48 <dcoutts_> dmwit: I don't know what .cabal file you're looking at
14:44:13 <dmwit> http://hpaste.org/65359
14:44:36 <dmwit> darcs confirms that I did not remove any build-depends lines. =/
14:44:53 <dmwit> Anyway it's clearly wrong as-is.
14:45:05 <dcoutts_> dmwit: so in the !small_base case, it only depends on QuickCheck
14:45:08 <dcoutts_> not base
14:45:13 <dcoutts_> so that's obviously wrong
14:45:21 * hackagebot rdtsc 1.3.0.0 - Binding for the rdtsc machine instruction  http://hackage.haskell.org/package/rdtsc-1.3.0.0 (MartinGrabmueller)
14:45:29 <dcoutts_> dmwit: did you change the "cabal-version:      >= 1.8"
14:45:30 <dcoutts_> ?
14:45:31 <dmwit> Yes, but I'm testing with small_base true (it defaults to true, right?).
14:45:36 <dmwit> dcoutts_: I did.
14:45:42 <dmwit> dcoutts_: Does that change how dependencies are computed?
14:45:45 <dcoutts_> dmwit: yes
14:45:50 <dmwit> hahaha
14:45:54 <dmwit> awesome
14:46:02 <dcoutts_> dmwit: you're opting in to the correct semantics rather than the old broken semantics
14:46:17 <dcoutts_> dmwit: you now have to list the deps properly
14:46:23 <dmwit> Okay. =)
14:46:52 <dcoutts_> dmwit: previously the deps from the exe and lib were merged
14:47:04 <dmwit> aaaah
14:47:15 <dcoutts_> dmwit: but fixing that without breaking all old packages relies on an opt-in, which is done via the cabal-version
14:47:35 <dcoutts_> the cabal-version field really says what version of the cabal spec your .cabal file conforms to
14:47:55 <dcoutts_> the '>=' thing is misleading
14:54:36 <hikingpete> @pl (\a b c -> a + max b c)
14:54:36 <lambdabot> (. max) . (.) . (+)
15:02:44 <ski> \a -> (a +) .: max
15:02:53 <ski> (.: max) . (+)
15:05:29 <rostayob> :t (.:)
15:05:30 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
15:07:24 <dmwit> dcoutts++ as usual
15:07:36 <dcoutts_> :-)
15:09:47 <ski> @type let (.) = (Prelude..); (.:) = (.) . (.) in (.:)
15:09:48 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:10:19 <dmwit> dcoutts_: I'm having other problems now with the "testing" flag, but at least without "testing" things seem OK.
15:10:41 <dmwit> dcoutts_: I think the other problem is bug #807 on the tracker, so I don't expect you to fix it in-channel. =P
15:11:05 <bgamari_> Does fclabels not have getM and setM?
15:11:19 <bgamari_> People refer to them but I can't find them in the documentation
15:11:42 <ben> @type flip fmap
15:11:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
15:12:07 <ben> @hoogle (Functor f) => f a -> (a -> b) -> f b
15:12:08 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
15:12:08 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
15:12:08 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
15:20:47 <ski> ben : sometimes've called that `pamf'
15:22:53 <bgamari_> ahh, gets and sets
15:27:21 <jfischoff_> has anyone tried modifying djinn or something similar to derive lenses or isomorphisms?
15:27:25 <ben> maybe i'll get away with (˙) = flip (Control.Category..)
15:27:37 <jfischoff_> Seems very possible
15:31:11 <Glorious> hi could somebody help me with this http://hpaste.org/65362 i really dont know how to do this im a bit stuck
15:32:02 <Glorious> i have smt like this now : compute x = [x, y | x <- , y<-]
15:32:12 <Glorious> but i really dont know how to do this recursively
15:32:39 <tromp__> > replicateM 5 "rby"
15:32:40 <lambdabot>   ["rrrrr","rrrrb","rrrry","rrrbr","rrrbb","rrrby","rrryr","rrryb","rrryy","r...
15:32:57 <jfischoff_> nice
15:33:24 <Lemmih> A pirate suffering a stoke?
15:33:36 <jfischoff_> ha
15:33:43 <tromp__> > you cld do it hard way like
15:33:44 <lambdabot>   <no location info>: parse error on input `do'
15:33:59 <tromp__> > [[a,b]|a<-"rby",b<-"rby"]
15:34:00 <lambdabot>   ["rr","rb","ry","br","bb","by","yr","yb","yy"]
15:34:24 <tromp__> but that's kinda ugly
15:35:14 <Glorious> how do i do it according to n which can be equal to 5 for example
15:35:16 <Glorious> hmm
15:35:23 <Glorious> how do i generate a,b,c,d,e
15:36:33 <mauke> > replicateM 0 "rby"
15:36:33 <lambdabot>   [""]
15:36:34 <tromp__> by redefining the haskell functoins that make up replicateM :)
15:36:52 <Glorious> i need to do it with list comprehension
15:36:54 <Glorious> :(
15:37:11 <tromp__> try to work out how to change the n=2 answer to the n=3 answer
15:37:18 <tromp__> with one list comprehension
15:37:48 <ski> @djinn-add data Lens a b = L (a -> (b,b -> a))
15:37:48 <tromp__> then iterate that on [""]
15:37:50 <Glorious> hmmm
15:37:52 <ski> @djinn Lens a b -> Lens b c -> Lens a c
15:37:52 <lambdabot> f a b =
15:37:52 <lambdabot>     case a of
15:37:52 <lambdabot>     L c -> case b of
15:37:52 <lambdabot>            L d -> L (\ e ->
15:37:52 <lambdabot>                      case c e of
15:37:54 <lambdabot>                      (f, g) -> case d f of
15:37:56 <lambdabot>                                (h, i) -> (h, \ j -> g (i j)))
15:37:57 <ski> jfischoff_ : like that ^ ?
15:37:59 <statusfailed> I just tried to /whois someone by typing :t ...
15:38:20 <ski> statusfailed :)
15:38:55 <Glorious> where can i find how replicatM is defined?
15:39:03 <ski> @src replicateM
15:39:04 <lambdabot> replicateM n x = sequence (replicate n x)
15:39:10 <Glorious> hopefully it is implemented with list comp
15:39:12 <Glorious> ohh nvm
15:39:47 <Glorious> its not
15:40:23 <ski> Glorious : you need to write something like `y <- compute (...)' inside your list comprehension
15:41:45 <tromp__> @let next ls = [x:l| l<-ls,x<-"rby"]
15:41:46 <lambdabot>  Defined.
15:42:11 <Glorious> im trying right now
15:42:16 <tromp__> > (iterate next [""])!!2
15:42:17 <lambdabot>   Ambiguous occurrence `next'
15:42:17 <lambdabot>  It could refer to either `L.next', defined at ...
15:43:05 <Glorious> :(
15:43:10 <ski> > iterate L.next [""] !! 2
15:43:12 <lambdabot>   ["rr","br","yr","rb","bb","yb","ry","by","yy"]
15:43:14 <_Mikey> Hey
15:43:22 <_Mikey> I'm having problems install gtk haskell
15:43:39 <_Mikey> I get an error saying it can't find alex.
15:43:44 <_Mikey> what is alex?
15:44:03 <ski> @let previous ls = [x:l | x <- "rby", l <- ls]
15:44:04 <lambdabot>  Defined.
15:44:08 <ski> > iterate previous [""] !! 2
15:44:10 <lambdabot>   ["rr","rb","ry","br","bb","by","yr","yb","yy"]
15:44:17 <ski> > iterate previous [""] !! 3
15:44:19 <lambdabot>   ["rrr","rrb","rry","rbr","rbb","rby","ryr","ryb","ryy","brr","brb","bry","b...
15:44:22 <Glorious> hmmm
15:44:53 <nart> hi
15:44:55 <ski> lo
15:45:36 <Glorious> what is ls?
15:45:45 <ski> just a variable name, the input of the function here
15:45:54 <Glorious> and thats the integer
15:46:02 <ski> jfischoff : did you miss the `djinn'-stuff above ?
15:46:09 <Glorious> im reading
15:46:11 <nart> i don't understand how to use the State monad to keep a Map a functions
15:46:52 <ski> Glorious : no integer in `previous' -- it just encodes a single step, while you want to do as many such steps as there are elements in your input list
15:47:17 <ski> @paste
15:47:18 <lambdabot> Haskell pastebin: http://hpaste.org/
15:47:26 <ski> nart : paste your code there ^
15:47:48 <rasfar> ski: little reminder to take a glance at http://fremissant.net/freesect if you're so inclined
15:48:09 <nart> it would be awesome if i had some code ... but i'm stuck at the type definition
15:48:37 <ski> so, you want a `Map' of functions ?
15:48:47 <ski> functions of which type ?
15:49:03 <ski> is the `Map' indexed by `Int' or `String' or what ?
15:49:38 <ski> in case you want functions of type `String -> String', and want `Int' indexing, it would look like `Map Int (String -> String)'
15:49:39 <nart> the map in indexed by String, functions are String -> Net ()
15:49:50 <ski> ok, so `Map String (String -> Net ())'
15:50:30 <ski> then, to keep that as the state in a state monad, you'd write something like
15:50:45 <ski>   foo :: ... -> State (Map String (String -> Net ())) Blah
15:50:46 <ski> or
15:50:54 <ski>   foo :: ... -> StateT (Map String (String -> Net ())) SomeMonad Blah
15:51:20 <ski> at this point, it may be a good idea to define a type synonym (or a `newtype')
15:51:38 <nart> thanks
15:51:42 <ski> yw
15:51:50 <Glorious> ski is working
15:51:52 <Glorious> thank you so much
15:52:00 <ski> Glorious : great ! :)
15:52:27 <ski> would you like to show the code so we can pick it apart, and criticize it ? ;)
15:52:36 <hpaste> Glorious pasted “Glorious” at http://hpaste.org/65364
15:52:45 <nart> ski: what's the "Blah" in State (Map String (String -> Net ())) Blah ?
15:52:50 <Glorious> :D
15:53:38 <d-snp> hey guys, I get a weird error: unexpected semi-colons in conditional
15:53:46 <d-snp> but there are no semicolons in my code, just line endings
15:53:58 <d-snp> aren't I allowed to have random line endings in my conditionals?
15:54:00 <shachaf> d-snp: Line endings get translated into semicolons.
15:54:04 <shachaf> Nope.
15:54:17 <shachaf> But maybe try {-# LANGUAGE DoAndIfThenElse #-}?
15:54:43 <shachaf> (Well, not line endings but indentation.)
15:55:03 <d-snp> http://pastie.org/3604461 <-- I thought this was legal?
15:55:27 <nart> sky: nevermind, got it
15:55:31 <shachaf> @google doandifthenelse
15:55:34 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
15:55:34 <lambdabot> Title: DoAndIfThenElse – Haskell Prime
15:57:06 <ski> nart : `Blah' is the monadic return type -- i.e. whatever result you want your monadic computation to have
15:57:48 <saite> hi
15:58:48 <ski> hello saite
15:59:35 <saite> since the only information related to the problem i found (and solved) was a chat log of this channel ... i thought i might leave the solution here as well :)
15:59:43 <d-snp> thanks shachaf
15:59:45 <ski> Glorious : yeah, that looks fine :)
16:00:03 <ski> Glorious : i would probably write `compute(length-1)' as `compute (length-1)', or even `compute (length - 1)', though
16:00:25 <shachaf> compute ((-) length 1)
16:00:28 <saite> OTOH the problem is: using dbus-core on FreeBSD and the solution is a hack.
16:00:39 <ski> (and i might rename `length' to `n')
16:01:07 <shachaf> And "compute" to "f", in the Haskell tradition?
16:01:13 <ski> (because there's already a function named `length' -- but your `length' shadows that one, so it's ok, just slightly confusing to read at first)
16:01:25 <shachaf> It's pratically a syntax error to have an identifier longer than one character.
16:01:35 <shachaf> > (length - 1) "hello"
16:01:36 <lambdabot>   4
16:02:10 <ski> shachaf : well, i would probably rename `compute' to something related to "combinations"
16:02:16 <ski> shachaf :)
16:02:20 <shachaf> combinute
16:02:47 <ben> What crazy instance is that?
16:02:57 <ski> saite : is this related to Haskell in any way ?
16:03:23 <d-snp> hey it says in that link you posted me that the above example should now actually be legal.. am I running an outdated version of haskell then?
16:03:33 <d-snp> 7.0.3
16:03:38 <shachaf> d-snp: You're not running any version of Haskell. :-)
16:03:39 <saite> ski: ddbus-core is a (pure haskell) implementation of the DBUS protocol (and in hackage).
16:03:45 <d-snp> .. of ghc :P
16:03:46 <ski> saite : if not, the channels ##freebsd and #dbus might be more appropriate
16:03:47 <shachaf> That's GHC. It's probably running in Haskell 98 mode.
16:03:56 <ski> saite : ah, ok. then it's fine here
16:04:12 <ski> (maybe there's a more appropriate channel, i dunno)
16:04:31 <d-snp> alright, very nice, it compiled using cabal now
16:04:37 <shachaf> Maybe try using {-# LANGUAGE Haskell2010 #-}?
16:04:40 <ski> ben : `instance Num n => Num (rho -> n)'
16:04:41 <shachaf> I don't know.
16:04:52 <shachaf> Seems to work for me in GHC 7.0.4
16:04:53 <d-snp> is that a preprocessor command? where would I put it?
16:05:37 <shachaf> At the top of the file. It's a pragma, not really a preprocessor command.
16:05:51 <shachaf> Alternatively use -XEXTENSIONNAME
16:05:57 <ski> ben : with `fromInteger = const . fromInteger' and `(+) = liftM2 (+)',&c.
16:06:00 <hpaste> saite pasted “dbus-core on FreeBSD” at http://hpaste.org/65365
16:06:19 <d-snp> should I put it in the setup.lhs? or really in every file I want to use that syntax in? it's not so bad I would want to make a mess of things :P
16:07:02 <shachaf> If you're using Cabal you can specify extensions in the .cabal file.
16:09:42 <ben> what's a failure join-point
16:11:41 <ben> also what's the requirements for a recursive call to be tail-recursive and not make my stack overflow?
16:12:17 <JoeyA> ben: Usually when that happens, you have an unevaluated thunk.
16:12:42 <JoeyA> e.g. loop n (x : xs) = loop (n + x) xs
16:12:57 <JoeyA> This will (likely) stack overflow because the additions are never evaluated.
16:13:09 <JoeyA> To fix, you can use bang patterns: loop !n (x : xs) = loop (n + x) xs
16:13:29 <ben> in my case it was (apparently) a ghc bug, but i just wanted to know what the general requirements are :)
16:14:55 <t7> hackage is turning into dependancy hell
16:17:14 <ski> rasfar : i think "A context inference policy based on typeability tests among various possible scopes would also be possible..." would be bad
16:17:56 <rasfar> ski: agreed, but it's interesting!
16:18:12 <ski> the fact that the parsing of expressions, and the scope of variables (and in some sense also which operations are referenced) is independent of types is a feature
16:18:22 <rasfar> did you check the table with all the primitives?  i think they look rather nice :)
16:18:35 <rasfar> http://fremissant.net/freesect/primitives.html
16:18:41 <ski> it means we can ignore types, when figuring out how something is parsed, and how variables scope
16:19:38 <rasfar> hmm i never thought of it as a feature...
16:19:43 <ski> rasfar : i think something like `__' has been suggested several times over the years here -- i haven't seen your `_[',`]_' suggested before though (the introduction of those handles one complaint about the idea)
16:19:46 <jfischoff> ski: just got back. example is interesting, but not what I am looking for. For instance, I want to splice $((a, b) -> b) and have it emit the expression for a lens.
16:20:07 <ski> jfischoff : oh ..
16:20:23 <ski> you want an automagic way of translating a function to a lens
16:20:24 <rasfar> thanks for your feedback ski, i appreciate it
16:21:15 <ski> rasfar : "it is impossible for an enclosing freesect to have a wildcard inside any enclosed freesect." is one thing i meant by claiming that i don't think it scales well
16:21:30 <rasfar> ski: actually my context inferencing algorithm is probably the most interesting part of the implementation, it really does allow you to safely drop the _[ ]_ in the vast majority of cases.
16:21:55 <rasfar> ah! was it you, i think someone else also felt it wouldn't scale well.
16:22:00 <ski> "Fresh identifiers generated by FreeSect are guaranteed to be unique among names referenced within a module." (i.e. hygiene) is of course good (and essential)
16:22:03 <rasfar> i had a better think about that after i got offline
16:22:10 <nart> is it possibile use runReaderT  on a State monad ?
16:22:10 <ski> rasfar : probably someone else as well
16:22:36 <ski> nart : no, use `runStateT' for a `StateT s m' monad
16:22:48 <ski> `runReaderT' is for a `ReaderT r m' monad
16:22:53 <nart> no sorry, i mean
16:23:06 <ski> nart : however, there *is* `evalStateT'/`evalState'
16:23:10 <ski> @type evalState
16:23:11 <lambdabot> forall s a. State s a -> s -> a
16:23:12 <ski> @type evalStateT
16:23:13 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
16:23:18 <rasfar> yes i agree, the lambda has another advantage because the vars are not anonymous, i'll have to mention that in the comparison.
16:23:24 <ski> nart : which may be what you were looking for
16:23:33 <ski> (there's also `execState' and `execStateT')
16:23:35 <nart> wrap the reader monad transformer on a state monad
16:23:46 <jfischoff> accidentally went offline. djinn as it stands won't derive the correct set function, because the types of set are really b and the one whole context of a at b.
16:24:08 <ski> nart : oh, you mean like `ReaderT r (State s) a' ?
16:24:50 <nart> and the state in also a StateT
16:24:50 <ski> nart : to run something of this type, you can write :  (`runState` initialState) . (`runReaderT` initialEnvironment) $ do ...
16:25:12 <ski> ok, so s/State s/StateT s m/ and s/runState/runStateT/
16:25:25 <nart> perfect, thank you very much :D
16:26:41 <ski> rasfar : you can check at <http://tunes.org/nef/logs/haskell/12.03.13> (or was it the twelfth ?)
16:26:57 <nart> sky: is this correct ? http://hpaste.org/65366
16:28:33 <t7> why did arch have to stop using the platform
16:28:36 <t7> its so frustrating
16:28:44 <ski> nart : looks fine
16:28:54 <rasfar> ski: what am i sifting for, discussion about lambdas/scope or what?!
16:28:56 <c_wraith> t7: I'm really a big fan of not using the platform.
16:29:11 <t7> c_wraith: nothing on haskage builds for me anymore
16:29:18 <td123> t7: what troubles are you having?
16:29:29 <t7> postgresql
16:29:38 <c_wraith> t7: usually the fix for that is deleting all installed packages and starting over.
16:29:44 <ski> nart : *if* you'd like the function in the map to have type `String -> EventNet' instead, that would also be possible, but you'd have to define `EventNet' with `data' or `newtype' (i'd recommend `newtype'), since it becomes recursive
16:30:23 <ski> rasfar : "ah! was it you, i think someone else also felt it wouldn't scale well." -- i just meant you could check for yourself who mentioned scaling problems, if you like
16:30:27 <td123> t7: i mean like errors
16:30:37 <nart> sky: ah ok, thanks for the tip
16:31:05 <rasfar> oh, yes! right.  that'll be easier in my xchat scrollback :)
16:31:08 <ski> rasfar : another problem i can see is that `foo bar baz' is no longer the same as `(foo bar) baz', in case any of the expressions `foo',`bar' contains a `__'
16:31:24 <deggis> hmh. dull & familiar situation. i ran into compiling error that was already pasted to hpaste, and probably was already solved at irc
16:31:24 <ski> nart : just fyi, my nick is "ski", not "sky" :)
16:31:25 <rasfar> (thank goodness for tunes logs though, what a great resource)
16:32:23 <rasfar> ski i think it is, since after the translation to lambda, the whole expression is intact as the [rhs of the lambda -- whatever you call those]
16:32:54 <hpaste> t7 pasted “error” at http://hpaste.org/65367
16:33:16 <rasfar> i fit had any ()'s .'s $'s they are preserved; if any could be inferred without the __'s they would still be inferred, no?
16:33:26 <rasfar> s/i fit/if it/
16:33:46 <danharaj> playing with (.) is fun.
16:34:01 <rasfar> but that's my first instinct; i'll give it more consideration
16:34:27 <rasfar> i also plan to get quickcheck working in the next version...
16:34:46 <ski> nart : if you want to do this, i would suggest something like `newtype EventNet a = EN (StateT MyState Net a) deriving (Monad,MonadState MyState,MonadReader Bot,MonadIO)' with `type MyState = Map.Map String (String -> EventNet ())'
16:35:05 <ski> nart : enabling the `GeneralizedNewtypeDeriving' extension to be able to use `deriving' like this
16:35:41 <td123> t7: I just built it on arch, you'll probably just need to clear out ~/.cabal and ~/.ghc if you don't find any other answers
16:35:58 <t7> td123: i need snap installed too
16:36:01 <danharaj> :t \f -> ((.f).)
16:36:02 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f a -> f1 (a -> b) -> f1 (f b)
16:36:16 <ski> rasfar : "when the _[   ]_ are omitted, the defaulting rules are as follows: The semilattice join of all unbacketed wildcards in a RHS are given context of the innermost enclosing parentheses ..."
16:36:16 <danharaj> :t \f -> (((.f).).)
16:36:17 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f a -> f2 (f1 (a -> b)) -> f2 (f1 (f b))
16:36:18 <t7> i think thats interfering
16:36:29 <rasfar> it was Axman6: "but I have a strong feeling that it does not scale (in terms of user comprehension)"
16:36:43 <rasfar> mind you that's a different scaling dimension
16:36:44 <td123> t7: ah, I talked to the snap dev a couple of days ago, he said -git works with ghc 7.4.1 but he plans on releasing a stable version compatible with 7.4.1 "soon", he's also an arch user :P
16:37:06 <danharaj> These types are way more fun when they're specialized to (->) :3
16:37:10 <t7> im using the git master :|
16:37:10 <rasfar> ski: yeah, that was a challenge to implement
16:37:33 <td123> t7: dunno, I can only repeat what he told me :P
16:37:34 <rasfar> (the bracketed ones are all rewritten first)
16:37:47 <t7> is there a way to revert to the platform on arch?
16:37:57 <ski> rasfar : this clearly means that  `(f __) a' (meaning `(\x -> f x) a') is different from `f __ a' (meaning `\x -> f x a')
16:38:31 <rasfar> ah!
16:38:52 <rasfar> drat!
16:39:13 <ski> rasfar : i'm not sure whether you implemented it like that or not -- but that's the only way i can interpret the desciption given
16:39:16 <rasfar> oh well, maybe there's a better policy; and hopefully it uses the join somehow...
16:39:34 <rasfar> no, you are quite right
16:39:44 <td123> t7: I don't think so
16:40:00 <t7> il try building from source
16:40:20 <nart> sky: awesome, thanks, now it's much more readable
16:42:20 <td123> t7: that's probably more work than figuring out your issues tbh
16:42:45 <ski> rasfar : i suppose you might be able to say something like : after removing brackets (in the syntax tree) like from `(foo bar) baz' to `foo bar baz', it will be delimited by remaining brackets
16:42:46 <t7> the issue is that hackage packages target the platform
16:42:50 <t7> and i dont have it
16:42:59 <ski> rasfar : though this seems more tricky to understand
16:43:53 <rasfar> i don't understand the distinction of the two types of parentheses...
16:44:30 <rasfar> and i really appreciate you're giving it a thorough going over, it's more than i hoped for certainly.  i'm making changes based on our discussion already...
16:44:33 <ski> well, because application is left-associative, this kind is in a sense redundant
16:45:02 <ski> `foo bar baz' is really `(foo bar) baz', i.e. an application of `foo' on `bar', and then a *new* application of the result of that on `baz'
16:45:03 <d-snp> how do I define a Word8 literal?
16:45:10 <d-snp> I thought it would be like 1 :: Word8
16:45:14 <td123> t7: do they really?
16:45:15 <rasfar> ski, i /do/ know that...
16:45:15 <d-snp> but it doesn't seem to work
16:45:23 <ski> however, we usually abbreviate this as (a bit incorrectly) saying that `foo' takes two arguments
16:45:39 <rasfar> so you are talking about implicit grouping due to AST structure, as well as explicit grouping using () and $?
16:46:24 <rasfar> right i see.  and we don't want a policy where the programmer has to think about the structure of the AST, which is even prone to change probably.
16:46:27 <d-snp> hmm nvm I fixed it
16:46:46 <ski>   -@-@- foo
16:46:48 <ski>      \- bar
16:46:48 <ski>    @--- baz
16:46:54 <ski> consider this AST
16:47:06 <rasfar> (thought it was a cartoon at first)
16:47:35 <ski> i'm saying that we could ignore any (explicit) bracketing around the `foo bar' expression, in case it's the operator part in another application, as it is here
16:47:45 <ski> i.e. only count other explicit bracketing
16:48:14 <ski> this would mean that `(f __) a' would still be translated to `\x -> f x a', so the difference would disappear
16:48:40 <ski> (and i suspect one wouldn't notice this often, since one doesn't commonly write stuff like `(foo bar) baz')
16:49:03 <ski> rasfar : i'm not saying this is a good resolution of it
16:49:15 <ski> i'm just saying that it seems to be a possible resolution of it
16:50:25 <ski> (and yes, i wasn't thinking you didn't know about left-associativity of application, i just wanted to establish a context for what i wanted to say)
16:50:51 <rasfar> i see ... yeah, that's almost a relief i guess ... oh.  well, maybe there's some best semantics (is this semantics?) ... ok, i sorta thought so
16:51:34 <ski> well, the extension is defined by translation
16:51:51 <ski> so it's semantics in the same sense a compiler is about semantics :)
16:52:04 <rasfar> anyway it is kinda fun, and teasingly almost useful, but i'm in over my head as i'm not a language theory guy despite having taken some courses
16:52:29 <ski> (it would probably also be possible to specify directly the semantics, instead of via translation to other constructs)
16:53:32 <rasfar> in what language would that be?  you mean in "plain natural language"?
16:53:41 <ski> rasfar : btw, i would probably have used `=' instead of `<=>' and `=>' for specifying equivalences of code expressions
16:53:46 <ski> yeah, e.g.
16:53:56 <ski> or a denotational or operational semantics, e.g.
16:53:59 <rasfar> = and not == ?
16:54:09 <ski> yes, `==' is for testing equality
16:54:24 <rasfar> well, they should be truly equal
16:54:27 <ski> > not == not
16:54:28 <lambdabot>   *Exception: (==): No overloading for function
16:54:29 <ski> doesn't work
16:54:33 <rasfar> but = is for assignment
16:54:37 <ski> `not = not' is a true statement, though
16:54:44 <ski> there is no assignment in Haskell
16:54:49 <ski> `=' is equality
16:54:52 <rasfar> that would be suitable for definitions i guess
16:54:59 <rasfar> since the core syntax is a priori
16:55:24 <rasfar> got me there -- yet the syntax does call them bindings, not equalities
16:55:27 <MaybeJust>  so, can anyonme suggest a good exercise for fourier transform? i have only done on boring ass square signals and such, i want a real aplication of it
16:56:01 <ski> a Haskell definition of an operation consists of one or more definition equations, which are equalities of a special form which are suitable for defining and evaluating the operations
16:56:11 <rasfar> it's meta syntax anyway, should be in another font
16:56:40 <ski> however, one can reason axiomatically about a Haskell program, proving properties about the operations, and then one can just treat the defining equations as equality axioms
16:56:51 <ski> (or axiom schemes, to be exact)
16:57:19 <ski> well, a binding is a special case of an equality
16:57:45 <ski> e.g. `fmap f . fmap g = fmap (f . g)' is an equality, but isn't suitable for defining anything
16:57:59 <ski> (but it could be used in a `RULES' pragma)
16:58:07 <rasfar> yes
16:58:46 <ski> but the nice thing is that we can treat the bindings/equations as true equalities, and use them like that when reasoning about the program
16:58:57 <rasfar> if it weren't for patterns, it would seem silly to speak of equalities, they are really definitions of names
16:59:01 <ski> which is why i prefer using `=' for equality when reasoning about expressions
16:59:25 <rasfar> but with patterns...  the line between declarations and equalities such as your fmap one above seem to get blurrier
16:59:32 <ski> i agree it wouldn't be as useful in the absense of patterns
17:00:13 <rasfar> but if it's a translation, you'd prefer => to = right?
17:00:41 <ski> no
17:00:52 <rasfar> => reserved for reductions?
17:01:14 <ski> either i'd prefer `=', or it should be real named translation function, applied to expressions, and recursively calling itself
17:01:23 <rasfar> aside from type contexts, that's where i've seen =>
17:01:24 <ski> (and *then* the `=' would be on the meta-level)
17:02:53 <ski> (you can also define a translation by a (meta-)relation instead of a (meta-)function, in which something like `-->'/`~>',`=>' would be ok)
17:03:08 <ski> (s/in which/in which case/)
17:03:57 <nart> sky: sorry to bother you again, but i really don't understand how to start this thing :S http://hpaste.org/65369
17:05:23 <nart> ski: sorry to bother you again, but i really don't understand how to start this thing :S http://hpaste.org/65369	
17:05:52 <ski> no need to be sorry
17:06:17 <ski> firstly, your `loop' isn't really looping, so it's a strange name choice
17:06:26 <ski> secondly, `loop' wants two arguments
17:06:55 <ski> i suspect you want something like
17:06:58 <ski>   main = do
17:07:03 <ski>     st <- connect
17:07:11 <ski>     (`runState` Map.empty) . (`runReaderT` st) $ do
17:07:22 <ski>       putStr ">> " >> hFlush stdout
17:07:29 <ski>       l <- getLine
17:07:35 <ski>      msg (socket st) l
17:08:00 <ski> hm, i suppose you seem to want s/$/. forever $/
17:08:15 <ski> nart : also, you need `liftIO getLine'
17:08:40 <ski> (and also for the `msg')
17:09:01 <ski> nart : does that help ?
17:09:37 <nart> i have posted the error message at the end of the file, have you seen it ?
17:10:06 <ski> yes
17:10:34 <ski> oh, also yuo should use `runStateT', not `runState'
17:11:32 <kiddesr> hmm... I want to understand that. Are those monad transformers?
17:11:33 <ski> possibly in some of the operations which have `Net' in the type you really want `EventNet' instead
17:11:49 <ski> yes, `StateT s' and `ReaderT r' are monad transformers
17:11:58 <kiddesr> ski: ok, thanks.
17:12:29 <nart> ski: let me try those changes
17:12:50 <ski> nart : the last change i suggested isn't necessarily what you want -- but you should consider whether you want it or not
17:13:09 <ski> generally, there isn't much point to keep track of more monads than you really need
17:13:35 <ski> if you only need `EventNet', there may not be much point in having operations in `Net'
17:14:21 <ski> otoh, there might be things that are simpler or more appropriate to do in `Net', in which case maybe you want to keep those operations in it anyway
17:14:27 <ski> it's a tradeoff
17:15:50 <ski> @wiki All About Monads
17:15:50 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
17:16:11 <ski> kiddesr : that ^ tutorial goes through monad transformers, in case you're interested
17:16:39 <nart> ski: ok it works, but it doesn't start the run function
17:16:44 <kiddesr> cool thanks
17:17:10 <nart> i mean, how can i start the run function ?
17:17:56 <ski> well, `run' is written in the `Net' monad, not in the `EventNet' monad
17:18:11 <MaybeJust>  so, can anyonme suggest a good exercise for fourier transform? i have only done on boring ass square signals and such, i want a real aplication of it
17:18:28 <nart> i have changed the type to EventNet
17:19:03 <ski> btw, if you replace `newtype EventNet a = EN (StateT MyState Net a)' with `newtype EventNet a = EN {unEN :: StateT MyState Net a}', you get a handy `unEN' defined for running `EventNet' actions
17:19:10 <ski> so, you'd use
17:19:22 <ski>   (`runState` Map.empty) . (`runReaderT` st) . unEN $ do
17:19:25 <ski> instead then
17:19:42 <ski> however, to run a `Net'-action `...', you just do
17:19:56 <ski>   (`runReaderT` st) $ do
17:19:58 <ski>     ..
17:20:27 <ski> nart : so, what you want to do depends a bit on what you're after here
17:20:37 <nart> ugh ... i'll never grasp this stuff
17:20:45 <ski> if you want, you could define a shorthand
17:21:05 <ski>   runEventNet action = (`runState` Map.empty) . (`runReaderT` st) . unEN $ action
17:21:10 <kiddesr> nart: I'm reading the monad thing right now. You should too!
17:21:10 <ski> this is btw the same as
17:21:33 <kiddesr> I think I have a cursory understanding of them. I just have never been able to understand the application
17:21:44 <ski>   runEventNet action = runState (runReaderT (unEN action) st) Map.empty)
17:21:53 <ski> sorry, s/runState/runStateT/ above
17:22:09 <ski> if you do this, then you could replace
17:22:30 <MaybeJust> can anyone tell me an application of a kalman filter that isnt something very advancd?
17:22:32 <ski> hm, no, you also need to pass `st' i suppose
17:22:33 <ski> so
17:22:39 <ski>   runEventNet st action = runState (runReaderT (unEN action) st) Map.empty)
17:22:45 <ski> so, you could replace
17:22:48 <ski>   (`runStateT` Map.empty) . (`runReaderT` st) . unEN . forever $ do
17:22:50 <ski>     ...
17:22:51 <ski> with
17:22:58 <ski>   runEventNet st $ do
17:23:00 <ski>     ...
17:23:08 <ski> which looks a bit simpler on the eye :)
17:23:44 <ski> nart : with some practice, and looking at tutorials of how one can use transformers, you should be able to grasp it
17:24:55 <ski> (but one needs to understand the type system first before being able to grasp transformers, methinks -- not claiming you don't, just stating this in general)
17:25:47 <ski> kiddesr : applications is whenever you want to use the effects of two different monads at the same time (which is realtively common)
17:25:58 <nart> ski: runEventNet st action = runStateT (runReaderT (unEN action) st) Map.empty
17:26:11 <nart> Couldn't match expected type `ReaderT                                     r0 (StateT (Map.Map k0 a1) Data.Functor.Identity.Identity) a0'                 with actual type `StateT MyState Net a2
17:26:19 <ski> kiddesr : however, i suppose it takes some familiarity with what the common monads do to be able to spot where a monad (or a monad transformer) would help
17:26:53 <lispy> howdy haskell
17:27:11 <ski> nart : try adding a type signature `runEventNet :: Bot -> EventNet a -> IO a' to it
17:27:44 <nart> Couldn't match expected type `ReaderT r0 (StateT s0 IO) a0'                 with actual type `StateT MyState Net a1'     In the return type of a call of `unEN'     In the first argument of `runReaderT', namely `(unEN action)'     In the first argument of `runStateT', namely       `(runReaderT (unEN action) st)'
17:28:00 <ski> er -- right
17:28:12 <ski> the `runStateT' and the `runReaderT' is in the wrong order
17:28:24 <ski> so
17:28:51 <ski>   runEventNet st action = (`runReaderT` st) . (`runState` Map.empty) . unEN $ action
17:28:55 <ski> alternatively
17:29:26 <ski>   runEventNet st action = runReaderT (runState (unEN action) Map.empty) st
17:29:54 <ski> alternatively
17:30:02 <ski>   runEventNet st (EN action) = runReaderT (runState action Map.empty) st
17:30:08 <ski> (whicheven you prefer)
17:30:30 <nart> sorry =(  Couldn't match expected type `ReaderT r0 IO a'                 with actual type `(a0, s0)'     In the return type of a call of `runState'     In the first argument of `runReaderT', namely       `(runState (unEN action) Map.empty)'     In the expression: runReaderT (runState (unEN action) Map.empty) st
17:30:35 * ski didn't notice that nart had them in the wrong order in the paste
17:30:51 <ski> hm, oh right
17:30:56 * ski is apparently tired
17:30:59 <nart> *nart notice that is a haskell n00b
17:31:04 <nart> ops
17:31:21 <nart> (i mean, i'm an haskell n00b)
17:31:24 <ski> if you don't care above the final state, then replace `runStateT' with `evalStateT'
17:31:35 <ski> if you care about it, then replace the type signature with
17:31:52 <ski>   runEventNet :: Bot -> EventNet a -> IO (a,MyState)
17:32:49 <ski> (this type signature just says that it will return the result together with the final state)
17:33:21 <ski> (if you only case about the final state, not the result value, then you can use `execStateT' and `runEventNet :: Bot -> EventNet a -> IO MyState')
17:33:40 <nart> omg it works
17:33:53 <ski> nart : was it you who said you started haskell three days ago ?
17:33:56 <ski> nart : hehe :)
17:34:33 <nart> no, but i have started it 7 days ago :D
17:34:50 <ski> ok, 'twas someone else, then
17:35:06 <nart> thank you so much
17:35:11 <Cody_> how do I import a library in Haskell, such as Data.Numbers.Primes?
17:35:29 <danharaj> import Data.Numbers.Primes
17:35:35 <ski> btw, the difference between having functions of type `String -> Net ()' in the map, and functions of type `String -> EventNet ()' is that in the latter case those functions themselves can read and modify the map state
17:35:37 <danharaj> You have to have the package that it comes from installed.
17:35:48 <Cody_> How do I do that?
17:35:53 <danharaj> cabal
17:36:01 <danharaj> Are you using the Haskell Platform?
17:36:05 <Cody_> Yes
17:36:06 <rasfar> ski, i've incorporated all your suggestions into the docs, thanks once again.
17:36:06 <ski> nart : and since i suspect this map is for some kind of plugin-stuff, i suspect you'd like it if plugins could also manage the plugin state
17:36:18 <danharaj> then you come with cabal install. It's a way to get packages into your GHC system.
17:36:39 <danharaj> try `cabal --help' in your command line to get a feel for cabal.
17:36:45 <ski> rasfar : ok, yw
17:37:23 <nart> ski: exactly, i'm trying to develop an event/hook system for an irc client, but i got lost in monads' forest :)
17:37:37 <ski> yeah
17:37:43 <Cody_> danharaj: type `cabal --help' in ghci?
17:38:01 <ski> nart : btw, the only way to break that `forever' is with exceptions, or exiting the process
17:38:12 <ski> nart : you may or may not want this
17:38:23 <danharaj> Cody_: no, in your command line for whatever your os is
17:38:45 <ski> (it would also be possible to use an `EitherT' monad or a continuation monad to exit the `forever')
17:39:27 <Cody_> danharaj: the haskell platform is installed on my usb drive, what folder do I have to navigate to?
17:39:35 <nart> so much stuff to learn, awesome
17:39:45 <ski> nart : yeah, but it's *fun* ! :)
17:40:05 <nart> i know, it wasn't ironic :D
17:40:15 <ski> nart : anyway, i hope this helped enough for you to be able to continue hacking on your code -- i'm going to sleep
17:40:26 <nart> yep, thank you again
17:40:30 <ski> yw
17:43:35 <JoeyA> I'm noticing a situation where "foo f = \a b c -> ..." is faster than "foo f a b c = ...".  Why might that be?
17:44:00 <shachaf> JoeyA: Are you passing it first one argument and then three arguments?
17:44:08 <JoeyA> I think it has to do with inlining.  The performance difference is significant.
17:44:18 <JoeyA> Actually, yes I am.
17:44:26 <shachaf> I remember that (.)'s definition was changed from (.) f g x = f (g x) to (.) f g = \x -> f (g x)
17:44:53 <rasfar> @karma+ ski
17:44:53 <lambdabot> ski's karma raised to 1.
17:44:59 <rasfar> ch!
17:45:06 <shachaf> JoeyA: I think it has to do with how GHC passes arguments together rather than one at a time whenever it can manage to.
17:45:28 <d-snp> this is a bit awkward, modifyMVar_ takes an a -> IO(a)
17:45:28 <shachaf> JoeyA: But in the case that a function takes two arguments at once but you pass them one at a time, it has to create a temporary function to pass the second argument in later.
17:45:34 <d-snp> but I just want an a -> a
17:45:51 <ski> (actually, i str having some karma points in the past -- not that i really care that about them, though :)
17:45:51 <d-snp> how do I put a into the IO monad? I don't actually require any IO'y stuff
17:45:57 <shachaf> @ty return
17:45:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:46:07 <d-snp> hmm
17:46:11 <DanBurton> @hoogle modifyMVar_
17:46:11 <lambdabot> Control.Concurrent.MVar modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
17:46:12 <lambdabot> GHC.Conc.Sync modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
17:46:47 <shachaf> d-snp: See also modifyIORef, maybe.
17:47:16 <DanBurton> @type \x f -> Control.Concurrent.MVar.modifyMVar_ x (return . f)
17:47:17 <lambdabot> forall a. GHC.MVar.MVar a -> (a -> a) -> IO ()
17:47:45 <BMeph> @pl \x f -> Control.Concurrent.MVar.modifyMVar_ x (return . f)
17:47:46 <lambdabot> (. (return .)) . Control.Concurrent.MVar.modifyMVar_
17:48:02 <BMeph> Oh, much better... *rolls eyes*
17:48:03 <DanBurton> @botsmack
17:48:03 <lambdabot> :)
17:48:16 <JoeyA> Might want to use evaluate instead of return, to avoid thunks piling up.
17:48:33 * d-snp has a bit of syntax blindness
17:48:38 <d-snp> my line is already so ugly :P
17:48:46 <JoeyA> e.g. modifyMVar mv (\x -> return (x + 1))
17:49:01 <JoeyA> If you keep doing that without ever examining x, you'll get a memory leak.
17:49:14 <JoeyA> modifyMVar mv (\x -> evaluate (x + 1)) would be better
17:49:30 <d-snp> modifyMVar_ (instances stack) (Map.insert (ipAddress addr, portNumber addr) (socketInputChannel socket))
17:49:38 <JoeyA> That can be simplified to: modifyMVar mv (evaluate . (+1))
17:50:20 <d-snp> so you guys say wrap it in a lambda that calls return
17:50:31 <d-snp> or evaluate
17:50:40 <JoeyA> d-snp: I'd say evaluate, to prevent memory leakage.
17:50:44 <ski> (or use `(return . Map.insert (...) (...))')
17:50:54 <JoeyA> So modifyMVar_ (instances stack) (evaluate . Map.insert (ipAddress addr, portNumber addr) (socketInputChannel socket))
17:51:09 <d-snp> ok
17:51:53 <ski> (whether `evaluate' is a good idea may depend on the type of the stuff stored in the `MVar' -- if it's a structured value an `evaluate' might not do very much)
17:52:52 <d-snp> it's a Data.Map
17:53:38 <ski> (yeah, so the question is whether `Map.insert' forces the whole structure of the result -- if it doesn't, there may not be much point to using (only) `evaluate')
17:55:34 * hackagebot yjtools 0.9.15 - some tools for Monad, List, Tuple and so on.  http://hackage.haskell.org/package/yjtools-0.9.15 (YoshikuniJujo)
18:00:07 <Glorious> hi im just wondering why this is not working http://hpaste.org/65371
18:00:22 <Glorious> probably because i m formulating the tuple wrong
18:00:35 <Glorious> how do u formate a tuple from an integer a b as (a, b)
18:00:52 <d-snp> thanks guys, it seems to work perfectly, you can see https://github.com/d-snp/SCTP-in-Haskell/blob/master/sctp/socket.hs if you want to know what monster you are helping me create :P
18:01:38 <d-snp> it doesn't do anything yet
18:02:10 <d-snp> but it's an attempt to face the 'awkward squad' all in one library
18:02:20 <d-snp> and see what goes down :P
18:02:30 <alpounet> Glorious, the problem is in your guard
18:02:41 <alpounet> i don't think that's what you meant
18:02:45 <ski> Glorious : your `True' guard means that the first case is always chosen
18:02:51 <vodik> Glorious: are you sure you didn't mean (a,b) == x = True
18:02:56 <ski> (note that `otherwise' is just another name for `True')
18:03:17 <ski> @src otherwise
18:03:17 <lambdabot> otherwise = True
18:04:02 <ski> Glorious : you might also consider using the `||' operator (i.e. "or"/disjunction)
18:04:07 <Glorious> hmmm
18:04:39 <vodik> its condition first with guards
18:04:54 <JoeyA> d-snp: If you start feeling overwhelmed as your module gets bigger and bigger, consider putting data definitions in a module, freeing you to put parts of your program in separate modules.
18:04:56 <Glorious> thanks it works with (a,b) == x = True
18:05:08 <JoeyA> Whether or not that's the best advice, I'm not sure.
18:05:10 <Glorious> did not know that it metters where i put the true
18:05:15 <Glorious> in front or at the end
18:05:19 <ski> Glorious : *nod*, but `||' would be more readable, imo
18:06:25 <d-snp> thanks JoeyA, I already have some types in a separate file, but you're right I still have too many random types there
18:06:43 <d-snp> I'm a complete noob to haskell so the project is a bit ambitious :P
18:08:54 <rostayob> d-snp: I think that learning haskell with a project that involves a lot of ugly IO might scare you off
18:10:32 <d-snp> nah, the IO in haskell is actually pretty ok
18:10:50 <JoeyA> Have you learned about asynchronous exceptions yet?  ;-)
18:10:54 <d-snp> I learnt in FP in a language quite like haskell, so I'm familiar with the basic concepts
18:11:05 <d-snp> haha not yet, I'm sure I'll find out about them soon :P
18:11:37 <ski> which language ?
18:11:42 <rostayob> d-snp: i'm not saying it's ok, but it's quite different and you might miss the functional beauty of haskell if you do mostly IO
18:11:52 <rostayob> d-snp: it's probably different from whatever FP language you have experience in
18:12:07 <rostayob> *I'm not saying it's not ok
18:12:09 <d-snp> amanda, it's a miranda clone made for my university
18:12:13 <ski> d-snp : any one of SML,O'Caml,Clean,Erlang,F#,Scheme ?
18:12:19 <ski> ok, Miranda
18:12:33 <rostayob> doesn't miranda use stream-based IO?
18:12:36 <d-snp> yes :D
18:12:40 <d-snp> it's pretty cool :P
18:12:46 <ski> @type interact
18:12:47 <lambdabot> (String -> String) -> IO ()
18:12:47 <rostayob> well, that has nothing to do with how Haskell does IO
18:13:10 <rostayob> haskell did IO like that before Monads came :D
18:13:21 <ski> rostayob : well, Haskell once upon a time did stream-based (aka `Dialogue'-based) I/O too
18:13:27 <ski> yea
18:14:22 <rostayob> d-snp: but IO in haskell moves fast, for example in the last years iteratees took over
18:14:39 <aristid> and now there's a move away from iteratees
18:14:49 <rostayob> so it might be a bit confusing, that's all I'm saying (since you mentioned the awkward squad, if you read the paper, that paper would be completely different now!)
18:14:50 <d-snp> yes, I've been meaning to learn about them, but I struggled to understand it
18:14:54 * ski suppose he should attempt to grok iteratees some time
18:14:59 <d-snp> I've just mastered monads :P
18:15:08 <aristid> ski: they're just left folds! :D
18:15:11 <rostayob> they're not hard
18:15:15 <rostayob> yeah really! ehe
18:15:26 <zmoazeni> Hey folks, is there something about using ffi and .hsc that makes it behave differently in ghci and ghc? I'm debugging http://hackage.haskell.org/package/leveldb-haskell-0.0.2 ( https://github.com/kim/leveldb-haskell ) ghc works great, but there's a delay/silent failure when playing in ghci.
18:15:31 <ski> aristid : i'm worrying about how correct the "just" there is :)
18:16:14 <napping> zmoazeni: one thing I know of is that ghci's linker doesn't run "constructors"
18:16:14 <d-snp> is it 'just' left folds like io/monads are just concatenated lists of lambda's? :P
18:16:18 <rostayob> the yesod book thing included a nice introduction, but nowadays it's probably conduits
18:16:25 <napping> so anything with static intialization tends to fails
18:17:15 <zmoazeni> napping: Oh I see, I'm pretty sure this code uses static compilation for leveldb. I've talked with the maintainer and he's wanting to move it linking to the leveldb libraries rather than keeping a copy of it in the codebase. Maybe if it were moved out, things would "just work"
18:17:22 <aristid> ski: don't worry, be oleg
18:17:23 <rostayob> d-snp: they're just left folds in the same way that monads are endofunctors
18:17:31 <ski> aristid :)
18:17:46 <napping> zmoazeni: not static compilation, but whatever thing it is where shared libraries have some functions that are supposed to run as soon as it's loaded
18:17:59 <aristid> ski: oleg jokes never get old
18:17:59 <ski> @quote oleg
18:17:59 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
18:18:10 <napping> for some reason ghci does the linking itself, but doesn't or at least didn't run those things
18:18:14 <rostayob> oh oleg :)
18:18:19 <ski> @quote milli-oleg
18:18:19 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
18:18:26 <ski> @where oleg
18:18:26 <lambdabot> http://okmij.org/ftp/
18:18:53 <rostayob> d-snp: oleg is Haskell secret weapon to scare people off and keep the reputation of hard language high
18:19:30 <zmoazeni> napping: I meant to say that the source code for leveldb itself is embedded in this project and statically compiled along with these bindings. Rather than expecting the user to have leveldb installed and this just bind to those shared libraries. AFAIK that's not a longterm plan from the maintainer.
18:19:36 <gwern> @quote
18:19:36 <lambdabot> Pseudonym says: Smart programmers naturally write monadic code, even if they don't realise it.
18:19:56 <napping> I don't know if that would be a problem
18:20:03 <aristid> what does that even mean? "monadic code"
18:20:09 <napping> having the library linked in doesn't always break things
18:20:15 <zmoazeni> napping: right on
18:20:24 <ski> @quote studying.teachings
18:20:24 <lambdabot> bartek says: It took me 2 years of studying teachings of Oleg Kiselyov (who was raised among types, where he learned to speak their language), but finally, I have the solution.
18:21:37 <aristid> @quote studying\steachings
18:21:37 <lambdabot> bartek says: It took me 2 years of studying teachings of Oleg Kiselyov (who was raised among types, where he learned to speak their language), but finally, I have the solution.
18:21:46 <ski> @quote OlegFacts
18:21:46 <lambdabot> OlegFacts says: Oleg's first datatype in haskell started like this: data ChuckNorris ...
18:21:48 <aristid> that is so much better than the . trick
18:22:25 <ski> @quote OlegFacts
18:22:25 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
18:22:46 <rostayob> then I killed Oleg several times, by brain explosion.
18:25:35 * hackagebot yjsvg 0.1.14 - make SVG string from Haskell data  http://hackage.haskell.org/package/yjsvg-0.1.14 (YoshikuniJujo)
18:27:36 <aristid> @quote oleg
18:27:36 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
18:27:58 <shapr> @quote oleg
18:27:58 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
18:28:01 <shapr> @quote oleg
18:28:01 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
18:28:07 <shapr> @quote millioleg
18:28:07 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
18:29:03 <shapr> @quote olsner
18:29:03 <lambdabot> olsner says: most everything gives nicer everything than perl
18:55:47 <andares> is there any way of building a list from the right instead of the left in Haskell?
18:56:08 <andares> I'm trying to write a simple number -> digit list function, but I'm getting the wrong order.
18:56:09 <napping> build from the left and reverse?
18:56:13 <rostayob> andares: build the list and reverse?
18:56:19 <napping> [] isn't really efficient built from the right
18:56:19 <andares> I could, but that seems wasteful.
18:56:26 <rostayob> why?
18:56:35 <napping> another thing might be composing list -> list functions
18:56:44 <napping> f . (x:)
18:56:48 <rostayob> if that's all you need to do it's ok
18:56:56 <andares> rostayob: asymptotically it's the same, but it's an unnecessary second pass isn't it?
18:57:14 <rostayob> andares: it is necessary if you want to view the list from the other side at the end
18:57:22 <andares> napping: … huh.
18:57:44 <digitteknohippie> lazyness also takes care of the efficiency
18:57:47 <rostayob> napping: is referring to difference lists, in which you do the appending all in one go
18:57:57 <rostayob> napping, without the :.
18:57:59 <napping> I'm not quite sure what you mean by "from the right"
18:58:32 <andares> digitteknohippie: even with reverse?
18:58:40 <andares> cool.
18:59:04 <digitteknohippie> depends how u utilise it i suppose.  [not an expert]
18:59:07 <napping> if you first compute the element you want at the end, you could just be consing onto an accumulating parameter
18:59:07 <rostayob> andares: lazyness doesen't matter when using reverse
18:59:14 <rostayob> reverse is monolithic
18:59:25 <andares> monolithic?
18:59:36 <rostayob> you can't have partial results
18:59:46 <rostayob> well... you can but the bulk of the work has to be done upfront
18:59:52 <andares> makes sense. reverse [1..] wouldn't really make sense.
18:59:59 <rostayob> you have to traverse the whole list before getting the first element
19:00:02 <rostayob> andares: precisely
19:00:11 <andares> as long as reverse is just O(n) I guess it's okay.
19:00:37 <andares> but you know, you can implement dlinked lists as efficiently as linked lists.
19:00:54 <andares> don't even need two pointers per element.
19:01:36 <copumpkin> andares: yeah, but you lose sharing
19:01:38 <rostayob> yes, that's a cool trick
19:01:46 <andares> sharing?
19:01:49 <copumpkin> and it stops being "inductive"
19:01:57 <andares> ah.
19:02:19 <copumpkin> I can take "abc" and make "bbc" by just putting a different head onto the same tail
19:02:21 <napping> reverse is fine if you're working with lists, and if you really need performance you probably need to change other stuff too
19:04:50 <Aune> Can you do the equivalent of schemes   (((call/cc (lambda (k) k)) (lambda (x) x) 3) with callCC from Control.Monad.Cont ?
19:08:16 <dolio> Aune: Yes, but not directly like that.
19:08:35 <dolio> You'll need to wrap it in some types to break the recursion.
19:09:44 <parcs`> Aune: what does that do
19:09:47 <Aune> ok, Im trying to wrap my head around how Cont works, maybe a better example would be the classic ying-yang puzzle.
19:10:26 <dolio> @type callCC return
19:10:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m b
19:10:28 <lambdabot>       Expected type: m a
19:10:28 <lambdabot>       Inferred type: m (a -> m b)
19:11:04 <parcs`> access the continuation from outside?
19:11:20 <Aune> parcs`, Exactly
19:11:32 <parcs`> you can do that
19:11:38 <Aune> pass the continuation on to outside the call/cc block
19:11:53 <parcs`> :t callCC (return . fix)
19:11:54 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => m (m b)
19:13:13 <parcs`> > (`runCont` id) $ runWriterT $ do label <- callCC (return . fix); tell [()]; label
19:13:17 <lambdabot>   mueval-core: Time limit exceeded
19:13:25 <Aune> I dont understand that
19:15:29 <parcs`> > (`runCont` id) $ (`runStateT` 0) $ do callCC $ \exit -> label <- callCC (return . fix); val <- get; when (val == 5) (exit ()); put (succ val); label
19:15:30 <lambdabot>   <no location info>: Parse error in pattern
19:15:40 <parcs`> > (`runCont` id) $ (`runStateT` 0) $ do callCC $ \exit -> do label <- callCC (return . fix); val <- get; when (val == 5) (exit ()); put (succ val); label
19:15:42 <lambdabot>   ((),5)
19:16:50 <parcs`> Aune: it returns a continuation that has been infinitely applied to itself
19:17:31 <Aune> parcs`, Yeah, so far so good. Im going to take a couple of minutes to parse that.
19:17:46 <parcs`> > (`runCont` id) $ (`runStateT` 0) $ do callCC $ \exit -> do label <- callCC (\k -> return (fix k)); val <- get; when (val == 5) (exit ()); put (succ val); label
19:17:47 <lambdabot>   ((),5)
19:18:13 <parcs`> > (`runCont` id) $ (`runStateT` 0) $ do callCC $ \exit -> do label <- callCC (\k -> return (k (k (k (k (k undefined)))))); val <- get; when (val == 5) (exit ()); put (succ val); label
19:18:14 <lambdabot>   ((),5)
19:18:15 <Aune> that being the  " (`runCont` id) $ (`runStateT` 0) $ .... " line
19:18:31 <parcs`> > (`runCont` id) $ (`runStateT` 0) $ do callCC $ \exit -> do label <- callCC (\k -> return (k (k (k undefined)))); val <- get; when (val == 5) (exit ()); put (succ val); label
19:18:32 <lambdabot>   *Exception: Prelude.undefined
19:19:45 <parcs`> Aune: oh, well i'm working in a monad transformer composed of the Cont monad and the State monad, so i run it by making the state initially 0 and then applying the continuation to id
19:19:54 <td123> hmm, anyone familiar with running ghc-mod? I added it using vundle and it seems to silently get ignored (none of the commands are available to me) just wondering if anyone else encountered this problem
19:19:55 <parcs`> (`a` b) is just flip a b
19:31:17 <Aune> parcs`, I have a hard time understanding nested monad transformers. But it seems to me this code says:   1) Run the following code and apply id to it. 2) Run with initial state 0. 3) let *exit* be the continuation we call to return. 4) *label* is a "goto this place" statement. 5) use *label* to loop and increment the state until it is equal to five. then return with *exit*
19:32:13 <bxc> ok, now whats happening?
19:32:13 <bxc> Implicit import declaration:
19:32:14 <bxc>     Ambiguous module name `Prelude':
19:32:16 <bxc>       it was found in multiple packages: base haskell98-2.0.0.0
19:32:20 <bxc> in maccatcher-2.1.3
19:32:22 <andares> can you layer |?
19:34:03 <bxc> 2.1.5 works...
19:34:09 <bxc> problem solved by update
19:34:48 <Aune> parcs`, thanks, I think I get it now
19:35:21 <parcs`> Aune: yeah, that's pretty much it
19:41:43 <andares> hm, can you not overload functions in Haskell?
19:42:07 <Aune> andares, you can with typclasses
19:42:22 <parcs`> not many people learn about the Cont monad before learning about monad transformers :P
19:42:24 <andares> I'm having issues with !.
19:42:32 <andares> I have to qualify it as Map.! rather than !
19:44:38 <Aune> parcs`, yeah. Im mostly just doodling around on my free time. so I never really got to monad transformers, except for the use of ReaderT in an IRC-bot tutorial
19:53:01 <Glorious> ok maybe u guys can hellp me with the following: I have an list of tuples [
19:58:22 <Glorious> ok maybe u guys can hellp me with the following: I have an list of tuples [ (1,2),(2,3) ] which represens a graph where vertices = 2 and edges = 3. I need to backtrack this with list comprehansion so i do not have the same colour on 2 adjacent vertices. if the colours = "r" , "y" , "b" i need all the possible permutations in this case" ryb" "yrb" "bry" and so o. maybe sm1 has a good insight.
19:59:10 <Glorious> for now i create a function which checks if 2 integers are adjacent and returns true if they are and false if they arent
19:59:11 <Glorious> checkAdjacent :: Int -> Int -> [(Int,Int)] -> Bool
20:06:34 <tromp__> :t all
20:06:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:06:50 <aristid> :t any
20:06:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:07:30 <rasfar> Glorious: i recall from yesterday. can you give a link to the actual problem statement?
20:07:34 <t7> @hoogle n a -> m n a
20:07:34 <lambdabot> Control.Monad.Trans.Identity IdentityT :: m a -> IdentityT m a
20:07:34 <lambdabot> Control.Applicative WrapMonad :: m a -> WrappedMonad m a
20:07:35 <lambdabot> Text.Regex.Base.RegexLike AllMatches :: (f b) -> AllMatches f b
20:07:44 <t7> :t lift
20:07:45 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
20:08:24 <Glorious> yes rasfar
20:09:38 <rasfar> actually if it is homework, that might be pushing the limits of the acceptable (mods?) but i'd just like to see the constraints on how you're permitted to solve it..
20:10:28 <rasfar> you could send it to me in a private message (/msg rasfar <url>) if you prefer
20:11:40 <andares> is there a reason you can't layer guards?
20:13:40 <ozataman> why would haskell-mode ghci start hanging all of a sudden? it works fine when I change the program name to cabal-dev ghci, but not when it's ghci
20:14:15 <rasfar> andares: i've often wished you could
20:15:32 <Glorious> i dont want an working implementation of it
20:15:34 <Glorious> i just want
20:15:35 <Glorious> some advice
20:15:58 <rasfar> sure but can we see the question?
20:16:18 <rasfar> not in your words but verbatim
20:16:25 <rasfar> ah, i believe i have a message...
20:17:17 <Glorious> :)
20:18:25 <rasfar> not done reading yet (long problem statement...) but you need only generate one valid colouring (depth-first then stop), that's helpful.
20:19:18 <Glorious> yes but i have to backtrack as well
20:19:39 <rasfar> "a backtracking solution" ... "implemented using list comprehension"
20:19:47 <rasfar> yeesh...
20:20:25 <Saizan> what's yeesh about that?
20:24:04 <rasfar> what's yeesh about?
20:25:01 <rasfar> i'm sure it would take me at least an hour to figure that out, not quite up to it sorry.  Saizan could do it in 10 seconds, maybe they will be more helpful. ;)
20:27:20 <Saizan> Glorious: i don't think checkAdjacent helps, actually
20:27:48 <rasfar> it's interesting you've been asked to actually explain why your solution will exploit laziness in only returning one valid colouring, don't forget about that part...
20:28:57 <Saizan> Glorious: but a function, notSameColor :: String -> (Int,Int) -> Bool, where the String is the order of colors while (Int,Int) is one arc would
20:30:17 <Saizan> because with the list comprehension is easy to generate all possible colorings as String's but you want to filter away those that assign the same color at adjacent nodes
20:30:39 * hackagebot blaze-svg 0.1.0.0 - SVG combinator library  http://hackage.haskell.org/package/blaze-svg-0.1.0.0 (DeepakJois)
20:30:41 * hackagebot diagrams-svg 0.3 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-0.3 (DeepakJois)
20:32:27 <t7> @hoogle a -> b -> b
20:32:27 <lambdabot> Prelude seq :: a -> b -> b
20:32:28 <lambdabot> GHC.Conc.Sync par :: a -> b -> b
20:32:28 <lambdabot> GHC.Conc par :: a -> b -> b
20:33:16 <rata_> hi all
20:33:32 <Aune> Glorious, How do you mean backtracking? Does [coloring | coloring <- generateColorings, valid? coloring] count as backtracking?
20:34:07 <Saizan> yes, that would count
20:34:17 <Saizan> except 'valid?' is not a valid identifier
20:34:33 <Aune> to much scheme lately ^^
20:38:23 <gdoteof> can someone tell me why i am getting a parse error on the second `|` in 'isPalindrome'
20:38:26 <gdoteof> http://pastie.org/3605646
20:39:39 <gdoteof> sorry, third pipe
20:40:00 <gdoteof> e.hs:20:5: parse error on input `|'
20:41:39 <nexx> gdoteof why do you use the "if"?
20:42:06 <geekosaur> 1. the if/then/else are completely gratuitous there.  2. "where" scopes over all guards
20:42:57 <gdoteof> nexx: geekosaur: hrm.  i thought i was saying "if xs is odd then do the following: if (...) then TRUE else FALSE
20:43:29 <nexx> gdoteof you do. But you can do <bool> insteald of if <bool> then true else false
20:44:00 <geekosaur> ^^ that.  what's the point of the if, when the boolean condition already returns true/false?
20:44:35 <gdoteof> geekosaur: nexx: oh i see
20:44:45 <rata_> I'm memory profiling an app (because I had an unusually high memory usage, that keep growing the more iterations I run) and found MUT_ARR_PTRS_FROZEN is growing constantly
20:45:18 <rata_> how do you solve such issue?
20:46:42 <gdoteof> geekosaur: removing the gratuitous if/then/else does not solve my parsing error
20:46:44 <gdoteof> oh
20:46:48 <gdoteof> 2.
20:52:06 <gdoteof> now it doesn't like it because (length xs) / 2 is not returning an Int
20:52:28 <geekosaur> correct
20:52:36 <monochrom> length xs `div` 2  or  fromIntegral (length xs) / 2, depending on what you want
20:52:51 <geekosaur> you might want `div`, or you might want to cast the result of (/) back to an Integral
20:52:54 <geekosaur> ...that
20:53:08 <geekosaur> (local notwork is very not, as it's raining.)
20:54:51 <gdoteof> oh.. fromIntegral is knowing how to turn different numbers into what the function expects
20:55:52 <monochrom> it is fairly polymorphic. from {Int, Integer, the like} to {any number type}
20:55:54 <JoeyA> I wish Haskell had deriving Exception (which automatically derives Show and Typeable as necessary) ...
20:56:40 <monochrom> you almost don't need deriving Exception. use its default method code. just be sure to derive/handwrite Show and Typeable
20:56:46 <gdoteof> hrm.  i would think i would want fromIntegral ( (length xs) / 2 )
20:57:03 <gdoteof> but that doesn't appear to work
20:57:07 <JoeyA> Defining Exception types involves unnecessary boilerplate.  {-# LANGUAGE DeriveDataTypeable #-}  import Control.Exception  import Data.Typeable  deriving (Show, Typeable)  instance Exception Foo
20:57:11 <monochrom> no, / wants Double etc
20:57:25 <JoeyA> That's just a lot to type.
20:58:43 <monochrom> OK sure, {-# LANGUAGE DeriveException #-} import Control.Exception  deriving (Exception)  is only a small saving
20:59:27 <gdoteof> monochrom: so now i would think i want something like- fromIntegral ( fromIntegral(length xs) / 2) )
20:59:37 <gdoteof> but that both doesn't work and seems bad
20:59:57 <monochrom> what is the outer fromIntegral supposed to do? convert Double to what? Double again?
21:00:09 <gdoteof> monochrom: the outer is supposed to convert back to int
21:00:15 <gdoteof> for take ..
21:00:27 <mysticc> @hoogle word64
21:00:27 <lambdabot> Data.Word data Word64
21:00:27 <lambdabot> GHC.Constants wORD64_SIZE :: Int
21:00:45 <monochrom> don't you guess something from the name fromIntegral? Double doesn't sound like Integral does it?
21:01:12 <monochrom> also <monochrom> it is fairly polymorphic. from {Int, Integer, the like} to {any number type}
21:01:22 <monochrom> I would think that was fairly clear
21:01:52 <monochrom> the second question is convert Double to Int in which way? there are 4 common ways...
21:01:57 <gdoteof> monochrom: yes it was clear.  i parsed over {Int, Integer, the like} and saw something like {Int, Double, whatever}
21:04:07 <monochrom> with length xs being non-negative, there are still 2 ways
21:05:45 <lispy> hello
21:08:20 <gdoteof> monochrom: i am close (ish).  floor is giving me an Integer
21:08:23 <gdoteof> which is still not good enough
21:08:40 <monochrom> add ":: Int" somehwere
21:09:06 <monochrom> but I disagree with this voodoo-like method of programming
21:10:19 <monochrom> "find any function at all for Double->Int, worry about what it actually does later" vs "specify what the function should actually do, then find it"
21:10:56 <gdoteof> monochrom: i ended up wth http://pastie.org/3605673.txt
21:11:14 <gdoteof> two fromIntegrals bugs me but i guess thats right?
21:11:27 <monochrom> so I am bowing out of this pursuit. it is against my principle.
21:11:42 <gdoteof> monochrom: i did it without the :: Int
21:11:59 <gdoteof> is what i have still voodoo?
21:12:30 <rata_> gdoteof: you probably just want div if you are using floor then
21:12:48 <rata_> write length xs `div` 2
21:13:03 <lispy> > length [1..7] `div` 2
21:13:04 <lambdabot>   3
21:13:21 <monochrom> this is why it is voodoo from beginning to end
21:13:30 <monochrom> <monochrom> length xs `div` 2  or  fromIntegral (length xs) / 2, depending on what you want
21:13:54 <monochrom> clearly, from then to now, no attention is paid to "what you want"
21:14:27 <monochrom> or rather, it is consistently left vague
21:14:33 <gdoteof> hrm.  that works much better.
21:14:56 <gdoteof> monochrom: sorry i thought it was clear i was looking for an argument to `take`
21:15:41 <gdoteof> thanks for the help
21:16:07 <JoeyA> Is it possible to ask the compiler to inline a callback given to it?
21:16:22 <JoeyA> (besides putting an INLINE pragma on the source function)
21:16:43 <dmwit> There really ought to be a better way than "darcs send -o /dev/null"
21:16:43 <lispy> JoeyA: if you're asking what I think you're asking I'm not sure how it could make sense
21:16:55 <lispy> dmwit: what are you trying to do?
21:16:56 <monochrom> both of {length xs `div` 2, ceiling (fromIntegral (length xs / 2))} are perfectly valid arguments to `take`. so you are still being vague.
21:17:45 <dmwit> lispy: See what patches are new in my repository compared to the current default remote repository.
21:17:47 <lispy> dmwit: there is a --dry-run if you just want to see if the send would work
21:17:56 <monochrom> the issue is if length xs is an odd number like 15, do you want 7 or 8. you could easily say "7", or say "8", and everything would be completely specified
21:18:05 <dmwit> I'd rather not have the danger of typing "send" at all. =P
21:18:18 <dmwit> I want the one-layer-of-abstraction-higher version of "darcs whatsnew".
21:18:36 <lispy> dmwit: IIRC, darcs pull reports when you have local patches that the remote does not have
21:18:43 <monochrom> but it is easier to hide behind "I just want an Int, 'any' Int" and avoid making a decision
21:18:47 <lispy> dmwit: so, darcs pull --dry-run may be another way to get what you want
21:18:58 <dmwit> darcs pull does no such thing here
21:19:39 <lispy> dmwit: then I would just make a shell alias/function that runs the command that works but has a "safe to type" name
21:20:04 <lispy> (or submit a patch implementing your feature)
21:20:42 * hackagebot http-enumerator 0.7.3.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.3.1 (MichaelSnoyman)
21:20:50 * dmwit nods agreement at lispy
21:25:42 * hackagebot hs-logo 0.2 - Logo interpreter written in Haskell  http://hackage.haskell.org/package/hs-logo-0.2 (DeepakJois)
21:25:59 <lispy> logo interpreter in haskell must be pretty easy
21:26:33 <lispy> oh cool, it has svg support
21:27:20 <lispy> The examples are pretty: http://deepakjois.github.com/hs-logo/
21:43:43 <t7> how do i instantiate this class https://github.com/norm2782/snaplet-hdbc/blob/master/src/Snap/Snaplet/Hdbc.hs#L99 ?
21:44:15 <t7> wtf does that pipe mean?
21:50:08 <geekosaur> t7, it's a functional dependency; it says that every distinct type for m specifies a distinct type for (c s)
21:51:04 <Glorious> here http://hpaste.org/65378
21:51:06 <geekosaur> so you don't have to provide a type signature every time you use it, it can try to figure it out itself by keeping track of types it infers for m or (c s)
21:52:18 <Glorious> computeColours generates listColours to be ["r","b","y"] and i want to append to them all permutations of colours of a graph where 2 adjacent vertixes cannot have the same colours
21:52:54 <Glorious> so i want to end up with smt like "rrb","ryb","rby","bry","byr","yrb" and so on
21:53:42 <Axman6> Can someone actually explain to me what "a monad is a monoid in the category or endofunctors" means?
21:54:01 <Axman6> (this is for use in some0ne else's talk. so a concise answer would be best)
21:54:01 <shachaf> Axman6: Sure. What's the problem?
21:54:05 <ezyang> ooh ooh I think I wrote a blog post about this
21:54:19 <shachaf> Look at the monad laws and the monoid laws. They're the same thing.
21:54:20 <ezyang> Nah, but there is a stack overflow answer
21:54:28 <ezyang> nhttp://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
22:00:44 * hackagebot hs-logo 0.3 - Logo interpreter written in Haskell  http://hackage.haskell.org/package/hs-logo-0.3 (DeepakJois)
22:15:44 * hackagebot hs-logo 0.4 - Logo interpreter written in Haskell  http://hackage.haskell.org/package/hs-logo-0.4 (DeepakJois)
22:21:40 <nyingen> @quote
22:21:40 <lambdabot> bos says: Crummy languages give static types a bad name.
22:33:56 <nyingen> @quote
22:33:57 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:33:59 <nyingen> @quote
22:34:00 <lambdabot> jimi_hendrix says: that took longer than it should have, but it feels so pure
22:49:42 <blackdog> anyone played with jasper's websockets library? i'm having some trouble having websocket.org/echo.html connect to it...
22:58:40 <Veinor> i'm a huge i'm considering wriing a blog engine in haskell, bu the problem i'm running into is that most blog engines have some kind of plugin support
22:58:44 <Veinor> which seems difficult to do
22:59:28 <mzero> @hackage hs-plugins
22:59:29 <lambdabot> http://hackage.haskell.org/package/hs-plugins
22:59:33 <mzero> :-)
22:59:33 <lambdabot> mzero: You have 1 new message. '/msg lambdabot @messages' to read it.
22:59:51 <Veinor> what's the memory usage on that like?
23:00:20 <mzero> it's just loading a lib
23:00:29 <Veinor> also, i think you mean plugins
23:00:45 <mzero> so in the normal running case - all the plugins get loaded once
23:01:26 <Veinor> so with that i could, say
23:01:46 <mzero> the name of the package has been, er, somewhat variable over time!
23:02:16 <Veinor> oh, interesting
23:02:37 <Veinor> it doesn't load the entire module in at once, it loads in a single symbol
23:02:56 <mzero> not really
23:03:15 <mzero> what happens is you have it compile a given module
23:03:22 <Veinor> load :: FilePath -> [FilePath] -> [PackageConf] -> Symbol -> IO (LoadStatus a), though
23:03:23 <mzero> and then the load API returns you one symbol
23:03:36 <mzero> but in fact the whole .o file for the module (your plug-in) has been loaded
23:03:40 <Veinor> right
23:03:42 <Veinor> that's what i meant
23:04:01 <mzero> so typically you define one symbol that each plugin must export
23:04:27 <seanhess> Is there any way to start completely over with cabal packages? I'm in dependency hell. It's saying it can't match types across versions of libraries: "Couldn't match expected type `conduit-0.2.2:Data.Conduit.Types.Source.Source"...
23:04:51 <blackdog> seanhess: rm -rf ~/.ghc
23:05:00 <Veinor> mzero: right
23:05:31 <Veinor> so like
23:06:20 <geekosaur> seanhess: then use cabal-dev or virthualenv to help keep things separated
23:07:57 <seanhess> blackdog: ty!
23:07:57 <mzero> Veinor: I use it in my Barley project (a web based Haskell IDE for exploring Haskell)
23:08:00 <mzero> https://github.com/mtnviewmark/barley/blob/master/src/Barley/Loader.hs
23:08:08 <seanhess> geekosaur: interesting, it will install all dependencies to the local folder?
23:08:30 <geekosaur> yes, and keep them out of the pool that other packages see
23:08:33 <Veinor> interesting
23:08:40 <seanhess> very cool. Thanks.
23:08:51 <geekosaur> (virthualenv is more involved but also lets you have separate GHC versions and global environments)
23:39:38 <rata_> is anobody there wanting to help me out with a memory leak I'm having?
23:40:30 <rata_> the memory profiler says it's MUT_ARR_PTRS_FROZEN the culprit
23:53:44 <cheater_> rata_: hang around, maybe someone will know later
23:54:36 <rata_> cheater_: ok, I'll be here =)
23:59:44 <Enigmagic> rata_: can you put up the profiler results and source on hpaste or github?
