00:09:14 <JaynesAddiction> Tired of niggers?
00:12:07 <alphadios> !list
00:15:17 <cwl> @src (==.)
00:15:18 <lambdabot> Source not found. There are some things that I just don't know.
00:15:22 <cwl> @src selectList
00:15:23 <lambdabot> Source not found. Wrong!  You cheating scum!
00:15:34 <cwl> > :t (==.)
00:15:35 <lambdabot>   <no location info>: parse error on input `:'
00:15:45 <cwl> type (==.)
00:22:30 <dmwit> :t (==.)
00:22:31 <lambdabot> Not in scope: `==.'
00:22:41 <dmwit> cwl: ^^
00:32:58 <miller> Is there any way to make a joinIO to have the opposite effect as liftIO?
00:32:58 <cwl> dmwit: how to find the doc of (==.) selectList etc
00:33:23 <yitz> @hoogle ==.
00:33:24 <lambdabot> No results found
00:35:01 <yitz> cwl: hayoo can't find it either. i guess we're all stumped. we have no idea what that is. you'll have to give us some context.
00:35:25 <cwl> yitz: Ysod persistent
00:35:29 <cwl> yesod
00:35:33 <yitz> ahhh
00:36:11 <yitz> cwl: try #yesod
00:36:20 <cwl> ok
00:36:29 <yitz> cwl: http://www.yesodweb.com/page/community
00:37:25 <cwl> yitz: thanks
00:37:57 <yitz> miller: what is the "opposite effect" of liftIO?
00:38:56 <miller> yitz: Being able to strip away layers of transformers to get the (IO a) part?
00:39:09 <miller> My question might not be logical. My brain is currently hurting.
00:39:30 <yitz> miller: liftIO allows you to use an expression of type just IO in the context of a monad transformer that wraps IO. the opposite would be.. an expression in the type of the transformer, so just use it.
00:39:42 <miller> oh.
00:39:43 <c_wraith> Well, there's a negative version, theoretically
00:39:55 <miller> >_____>
00:40:14 <c_wraith> ((IO a) -> b) -> t (IO a) -> b
00:40:28 <c_wraith> liftIO can't do that
00:40:44 <yitz> c_wraith: the dual you mean
00:41:58 <c_wraith> sure
00:42:22 <yitz> c_wraith: there aren't too many functions of type IO a -> b that are not actually IO a -> IO b
00:42:34 <c_wraith> turns out, that's a really hard thing to do. No one's happy with any of the existing formulations
00:43:16 <yitz> c_wraith: unsafePerformIO springs to mind
00:43:26 <c_wraith> My point was more along the lines of "I don't even care about the return value, just any function that takes an IO action as an argument"
00:43:38 <yitz> error
00:43:48 <c_wraith> const
00:43:58 <yitz> ok that's fair
00:46:49 <c_wraith> though yes, the form (IO a -> IO b) -> t (IO a) -> t (IO b) is commong.
00:47:01 <c_wraith> err, common
00:47:03 * hackagebot gt-tools 0.1.4.3 - Console and GUI interface for Google Translate service  http://hackage.haskell.org/package/gt-tools-0.1.4.3 (SergeiTrofimovich)
00:47:05 <c_wraith> But it's not general enough
00:49:31 <randomclown> how do I >>= a monad to itself ten times?
00:49:49 <randomclown> without writting it 10 times of course
00:50:19 <c_wraith> depends on what you actually mean?
00:50:33 <randomclown> I have something like
00:50:34 <c_wraith> you mean something like x >>= f >>= f etc?
00:50:38 <randomclown> yeah
00:50:47 <miller> Suppose I have a function an identity function with type `IO () -> IO ()`, how do I apply it to something that has a type of `(Monad m) -> m IO ()`?
00:51:01 <miller> s/a function//
00:51:26 <miller> hrg too many typos
00:51:39 <miller> Suppose I have an identity function with type `IO () -> IO ()`, how do I apply it to something that has a type of `(Monad m) => m IO ()`?
00:51:59 <randomclown> c_wraith:
00:52:23 <c_wraith> :t foldl1 (>=>) . replicate 10 ?f $ ?x
00:52:24 <lambdabot>     Couldn't match expected type `a -> [b -> m b]'
00:52:24 <lambdabot>            against inferred type `[a1]'
00:52:24 <lambdabot>     In the second argument of `(.)', namely `replicate 10 ?f'
00:52:30 <shachaf> miller: That's a kind error.
00:53:17 <c_wraith> well, clearly I'm not awake enough for this.
00:54:34 <miller> shachaf: I feel like there should be some way to transform the identity function to have the signature `m IO () -> m IO ()`, and then use that instead, but I could be totally confused.
00:54:56 <randomclown> alright so >=> should be what i need to look at
00:55:03 <c_wraith> yes, and I was close
00:55:11 <c_wraith> @ty foldl1 (>=>) $ replicate 10 ?f
00:55:12 <lambdabot> forall (m :: * -> *) b. (Monad m, ?f::b -> m b) => b -> m b
00:55:21 <c_wraith> that gets you most of what you want
00:55:31 <c_wraith> putting in your real function in place of ?f
00:56:40 <c_wraith> (>=>) and (<=<) are composition of functions that return monadic values
00:56:48 <Enigmagic> miller: do you want "Monad m => m (IO ())" (note the parens) or "Monad m => m IO ())"
00:57:10 <Enigmagic> without the last paren ..
00:57:38 <miller> Enigmagic: Ah! I'm sorry! I want the parens! I mean `m (IO ())`.
00:57:58 <shachaf> Just fmap, then.
00:58:09 <shachaf> liftM. Whatever. Just the way that you usually apply functions.
01:00:52 <miller> Ah ha! They do exist. Thanks. :D
01:02:14 <Jafet> @src liftM
01:02:14 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:09:53 <Franciman> hi all
01:10:57 <randomclown> c_wraith what if I have an initial condition
01:11:04 <hpaste> Franciman pasted “RWHExample” at http://hpaste.org/65605
01:11:08 <Franciman> hey people I've got a question about a code example in Real World Haskell
01:11:17 <Franciman> about that *
01:11:36 <randomclown> righ
01:11:42 <Franciman> why is it possible to define that function like that?
01:11:58 <Franciman> the type complains only about 2 args
01:12:04 <Franciman> but actually they're 6
01:12:20 <shachaf> Franciman: Do you know how multiple arguments work in Haskell?
01:12:29 <Franciman> yes
01:12:52 <Franciman> but I thought that since the last return type was a function
01:12:58 <shachaf> Well, expand it out and see.
01:13:04 <Franciman> it is
01:13:04 <shachaf> type InfoP a = FilePath -> Permissions -> Maybe Integer -> ClockTime -> a
01:13:35 <shachaf> InfoP a -> a -> InfoP Bool === (FilePath -> Permissions -> Maybe Integer -> ClockTime -> a) -> a -> FilePath -> Permissions -> Maybe Integer -> ClockTime -> Bool
01:13:38 <Franciman> equalP :: ( Eq a ) => (FilePath -> Permissions -> Maybe Integer -> ClockTime -> a) -> a -> (FilePath -> Permissions -> Maybe Integer -> ClockTime -> Bool )
01:13:52 <shachaf> Right.
01:14:05 <shachaf> Franciman: Are you sure you know how multiple arguments work in Haskell?
01:14:14 <Franciman> at this point no
01:14:15 <Franciman> :(
01:14:25 <shachaf> For example, what's this type? Int -> (Char -> Bool)
01:14:39 <Franciman> it accepts an Int in and returns a function
01:14:54 <shachaf> What about this type?
01:14:57 <shachaf> Int -> Char -> Bool
01:15:04 <Franciman> it accepts an int
01:15:12 <Franciman> and a char
01:15:15 <Franciman> and returns a bool
01:15:18 <Franciman> but it can also
01:15:27 <Franciman> accept only an int and return a function
01:15:28 <Franciman> of type
01:15:32 <Franciman> Char->Boll
01:15:38 <Franciman> Bool*
01:15:40 <shachaf> You're allowed to type more than three words on one line of IRC, by the way. :-)
01:15:47 <shachaf> Franciman: Anyway, yes. The two types are equivalent.
01:15:54 <Franciman> lol yes, bad habit
01:16:04 <shachaf> Similarly, (FilePath -> Permissions -> Maybe Integer -> ClockTime -> a) -> a -> FilePath -> Permissions -> Maybe Integer -> ClockTime -> Bool is equivalent to (FilePath -> Permissions -> Maybe Integer -> ClockTime -> a) -> a -> (FilePath -> Permissions -> Maybe Integer -> ClockTime -> Bool)
01:16:58 <Franciman> ahh because -> is right associative
01:17:20 <Franciman> so applying parens there doesn't have any effect
01:17:21 <Franciman> right?
01:18:17 <shachaf> Something like that.
01:18:53 <mrcarrot> while i understood this pasted code... i think (and people have right to disagree) that it is bad in this case to use short one letter variables. it would be much more readable with longer variable names
01:19:19 <mrcarrot> especially as this is from a book ment to teach haskell
01:19:59 <Franciman> shachaf, If I had (Int->Int)->Char, instead. I could not do myFun i1 i2
01:20:02 <Franciman> right?
01:21:14 <Franciman> because (Int->Int)-> Char is a different thing
01:21:18 <shachaf> Franciman: Well, this about what the type means.
01:21:24 <shachaf> s/s/nk/
01:22:14 <Franciman> ohh and that also makes sense
01:22:22 <t7> It's my birthday...
01:22:28 <Franciman> happy birthday :D
01:22:30 <Authoritarianism> Congrats!
01:22:32 <Authoritarianism> Happy birthday!
01:22:49 * Franciman is in that awkward moment when he realises that what he didn't understand was too easy
01:23:41 <asante> happy birthday!
01:28:18 <t7> I watched a video on silk last night
01:28:27 <t7> do the devs hang out in here?
01:30:14 <Franciman> t7 which silk?
01:30:21 <t7> silkapp.com
01:30:43 <Franciman> k thanks
01:31:04 <cwl> data Person = Person { name :: String, Age :: Int } deriving Show
01:31:14 <cwl> main = print $ Person { name = "Tom" }
01:31:33 <cwl> the program crashes like encounter a nullpointer exception
01:31:43 <cwl> why haskell don't avoid that?
01:31:49 <shachaf> cwl: Haskell do avoid that.
01:31:59 <shachaf> GHC warns you at compile-time that your program is wrong.
01:33:13 <cwl> shachaf: it just warns, in big project, it usually be submerged warnings
01:33:42 <shachaf> cwl: Compile with -Werror. Problem solved.
01:33:48 <cwl> and the point is that does nullable value exists in haskell?
01:34:07 <cwl> In the language concept
01:34:09 <shachaf> This doesn't have much to do with "nullable".
01:34:13 <shachaf> Well, not directly.
01:34:25 <shachaf> cwl: "Age" there is like an infinite loop.
01:34:54 <cwl> infinite loop? what does it mean?
01:35:08 <Enigmagic> @src undefined
01:35:08 <lambdabot> undefined =  error "Prelude.undefined"
01:35:13 <Enigmagic> doh
01:35:14 <Enigmagic> :)
01:35:48 <Lemmih> cwl: 'print undefined' throws an error and that doesn't even give you a warning.
01:35:51 <cwl> Enigmagic: do you mean Age is initialize as undefined?
01:36:07 <Enigmagic> cwl: http://www.haskell.org/haskellwiki/Bottom
01:36:18 <jfischoff> is there higher kinded analog to functor?
01:37:12 <jfischoff> I guess bifunctor...
01:37:33 <shachaf> Lemmih: That's fair. But on the other hand there's not much you can do about people explicitly writing _|_s into your code.
01:37:47 <shachaf> (Other than not be Turing-complete.)
01:39:03 <hiptobecubic> > print undefined
01:39:05 <lambdabot>   <IO ()>
01:48:18 <merijn> shachaf: That's one of the many excellent arguments against Turing completeness :)
01:55:25 <Authoritarianism> Hello. Is it possible to define in Haskell the type of doubly linked lists?
01:55:46 <Franciman> I guess so
01:55:47 <ion> yes
01:55:58 <hiptobecubic> Why not?
01:56:23 <danr> Authoritarianism: here's one way on the wiki: http://www.haskell.org/haskellwiki/Tying_the_Knot
01:56:39 <danr> not necessarily very convenient to work with
01:56:47 <Franciman> data DoubleLinkedList a = Node ( DoubleLinkedList prev ) a ( DoubleLinkedList next )
01:56:59 <Authoritarianism> danr, Franciman: Thanks.
01:57:11 <merijn> Alternately, if you just want easy back and forth movement through lists you may want to look up zippers
01:57:13 <shachaf> Authoritarianism: It's possible but it's not very useful.
01:57:38 <shachaf> In fact, it's nearly uselessful.
01:58:16 <Authoritarianism> shachaf: I am trying to translate an algorithm I came up to generate the list of primes that is a modified version of the Sieve of Sundaram, from my toy imperative language (mostly C++-like) to Haskell.
01:58:30 <Authoritarianism> shachaf: And the algorithm requires a doubly linked list.
01:58:43 <danr> Authoritarianism: why not just use cycle?
01:58:52 <Franciman> * (DoubleLinkedList a ) not prev and next
01:58:54 <danr> and have an infinite singly linked list
01:58:58 <shachaf> Authoritarianism: You're not going to gain much by translating algorithms from C++ to Haskell.
01:59:22 <danr> > cycle [2,4,8,8,4]
01:59:24 <lambdabot>   [2,4,8,8,4,2,4,8,8,4,2,4,8,8,4,2,4,8,8,4,2,4,8,8,4,2,4,8,8,4,2,4,8,8,4,2,4,...
01:59:36 <Authoritarianism> danr: I do not need cycles.
01:59:41 <Authoritarianism> danr: I need a queue.
01:59:55 <danr> alright
02:00:18 <Authoritarianism> danr: Append to the tail, extract from the head. No idea how this could be done efficiently with another data structure.
02:00:31 <t7> anyone know a language with polymorphism without need pointers, that isnt GCd?
02:01:16 <Authoritarianism> t7: I am designing one. (The toy language I mentioned.)
02:01:37 <merijn> Authoritarianism: Just a queue or a priority queue? (i.e. do you only need to append to the start/end or middle too?)
02:01:45 <t7> Authoritarianism: using raii ?
02:01:53 <Authoritarianism> t7: Heavy use of RAII.
02:02:04 <Franciman> t7, well I C++ you can using references
02:02:05 <danr> Authoritarianism: try Data.Sequence http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html
02:02:07 <t7> cool you got github or anything?
02:02:16 <Franciman> instead of pointers
02:02:16 <Authoritarianism> t7: No, and I will not until it is done.
02:02:29 <t7> Franciman: i cant make a list of derived types
02:02:32 <Franciman> *well in C++
02:02:34 <Franciman> oh yes
02:02:36 <t7> without using new
02:02:38 <Franciman> that can't be done
02:02:42 <Authoritarianism> merijn: I do not need to do anything to the elements of the queue besides its head and its final elements.
02:02:49 <merijn> I remember a nice simple queue data structure mentioned in one of SPJ's talks (example from xmonad)
02:02:56 <Franciman> t7, you could use some smart pointer btw
02:02:57 <Authoritarianism> danr: Let me see.
02:03:09 <Franciman> like shared_array
02:04:33 <merijn> Basically: "data Queue a = Queue [a] [a]", one list is the front of the queue, the other list is the end (in reverse order) so instead of appending to the end you'd append to the start of the second list (O(1)) and then whenever the "front" list is empty you just reverse the back list, make that the front and replace the back list with empty
02:04:43 <Authoritarianism> danr: What data structure is used internally? Is that a binary search tree?
02:04:56 <hiptobecubic> There was a nice paper on this
02:05:07 <hiptobecubic> functional data structures, i mean
02:05:22 <merijn> Don't remember the amortized complexity, though. But it was fairly efficient
02:05:24 <danr> Authoritarianism: nope, it's a 2-3 finger tree
02:05:29 <shachaf> Basically it's just, like, lim_{h->0}{List(x+h) - List(x) \over h} and stuff.
02:05:37 <danr> It's in the header of the module description, with a link to a paper describing it
02:05:56 <Authoritarianism> danr: Oh, yeah, I should have read that. I skipped the intro.
02:12:09 * hackagebot hmatrix 0.14.0.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.14.0.0 (AlbertoRuiz)
02:15:29 <ismtrn> Can anybody recommend a book about functional algorithms?
02:15:55 <ismtrn> I have been looking at purely functional datastructures
02:16:01 <alistra> is there any other
02:16:04 <alistra> than okasaki?
02:16:30 <ismtrn> Theres is also one called something like functional programming pearls
02:16:43 <ismtrn> or functional algorithm pearls or something...
02:16:49 <alistra> it's a series of papers
02:17:09 * hackagebot hmatrix-glpk 0.3.1 - Linear Programming based on GLPK  http://hackage.haskell.org/package/hmatrix-glpk-0.3.1 (AlbertoRuiz)
02:17:16 <alistra> functional pearls, but i wouldn't say they like cover general and useful stuff
02:17:28 <alistra> they are just random things, that look nice functionally
02:17:32 <ismtrn> ok.
02:17:44 <ismtrn> is purely functional datastructures good?
02:18:02 <mysticc> @hoogle lines
02:18:02 <alistra> you mean okasaki?
02:18:03 <lambdabot> Prelude lines :: String -> [String]
02:18:03 <lambdabot> Data.List lines :: String -> [String]
02:18:03 <lambdabot> Data.String lines :: String -> [String]
02:18:09 <mysticc> @hoogle words
02:18:09 <lambdabot> Prelude words :: String -> [String]
02:18:10 <lambdabot> Data.List words :: String -> [String]
02:18:10 <lambdabot> Data.String words :: String -> [String]
02:18:30 <mysticc> Is there a Lazy ByteString equivalent of lines and words
02:18:41 <ismtrn> it is written by Chros Okasaki
02:18:44 <ismtrn> so yes.
02:18:49 <alistra> ismtrn: well i guess, but ml has a different memory model
02:19:00 <alistra> so it won't be performance 1:1 portable to haskell
02:19:27 <ismtrn> i guess there isent many other choices?
02:20:01 <alistra> not rly, but what exactly do you want to learn :D?
02:22:08 <ismtrn> I would like to learn to solve some text-book-ish computer science problems, like the ones you find on project euler and USACO in a functional way
02:22:09 * hackagebot hmatrix-tests 0.2 - Tests for hmatrix  http://hackage.haskell.org/package/hmatrix-tests-0.2 (AlbertoRuiz)
02:23:42 <alistra> you mean in not so slow time?
02:24:06 <alistra> first learn haskell memory model and profiling, there are a lot of cool guides :P
02:24:37 <alistra> basically how to force haskell to be strict sometimes
02:25:37 <ismtrn> yeah, but i guess i would also have to know something about designing algorithms?
02:26:50 * mrcarrot wonders why there is so many thinking there is something magic about designing algorithms...
02:27:38 <mrcarrot> what i mean is: coming up with algorithms is usually very simple, the difficult thing is to get really performant algorithms
02:28:27 <alistra> from what i know you don't have to do accumulators like ml and prolog
02:28:51 <alistra> but it's not based on the true understanding, but on that somebody told me so
02:34:48 <tech2> mrcarrot: I think you'd be surprised. Certainly some actions are easier to theorise than enact, but coming up with something like Boyer Moore search or Timsort must have taken significant thought.
02:38:36 <mrcarrot> tech2: as i said, high performance algorithms are difficult to create. string searching is not a difficult task, but doing it with O(3n) as in Boyer Moore search, that is difficult
02:39:29 <tech2> mrcarrot: ah, perhaps I misunderstood, I'd assumed you'd separated out the two concepts into "algorithm" and "performant implementation"
02:39:47 <mrcarrot> tech2: what i meant more is that nowdays people are looking at algorithms, like something impossible (even if performance is not important).
02:40:24 <mysticc> Has anybody found the reason behind this yet http://stackoverflow.com/questions/9772098/building-a-histogram-with-haskell-many-times-slower-than-with-python
02:40:45 <tech2> mrcarrot: I have my own beliefs about why that's the case, but that's a rant for another time.
02:41:18 <mysticc> I tested it on a file with 100000 lines and The code was more than 10 times slower than the python code ..
02:41:54 <mysticc> I am more interested in the code performing atleast as fast as the python code ..
02:42:16 <srhb> That should be pretty easy to achieve..
02:42:36 <tech2> I figure I'll ask here since I'm not having much luck elsewhere, does anyone here have any good examples of functional specifications? I'm trying to follow GAMP5 but it's a bit... limited... in places.
02:43:01 <mysticc> here are the files if you dont want to copy paste : http://paste.pocoo.org/show/568366/ http://paste.pocoo.org/show/568365/
02:43:34 <mysticc> srhb: Nope it is getting difficult :P
02:44:10 <merijn> One easy step would be to switch to a different Map implementation that has similar complexity to python's dictionaries
02:44:26 <mysticc> srhb: I also checked the solutions with hashtables etc .. but still python code is much much faster and smaller :P
02:45:00 <mysticc> merijn: Data.HashTable also not very good ..
02:49:50 <int-e> is there a ready to use hash function for Data.Text.Text?
02:52:08 <osa1> int-e: this package should have one http://hackage.haskell.org/package/hashable-1.1.2.3
02:52:54 <int-e> thanks.
03:11:07 <hpaste> cfricke pasted “Inversion Count” at http://hpaste.org/65606
03:11:16 <cfricke> Hello, can anyone tell me, if there is a better solution to my inversion count implementation regarding the length call that increases the complexity by almost a factor n.
03:12:32 <cfricke> I assume that using lists won't cut it, so resorting to another data structure entirely would be best.
03:15:10 <merijn> cfricke: Completely unrelated to your question, as hpaste points out you can simplify "putStrLn (show . fst $ scount xs)" to "print . fst . scount $ xs" (or some other variation), because "print = putStrLn . show"
03:15:31 <cfricke> merijn: Yes, thanks, I noticed. Forgot about print.
03:19:42 <cfricke> I'll be right back.
03:19:46 <av> hi again, I'm playing with attoparsec and having trouble...
03:21:29 <av> why does this evaluate as "Partial _"? :
03:21:38 <av> parse (many (many letter <* endOfLine)) $ pack "lkjasdlfjk\nf\n"
03:23:21 <cfricke> And back.
03:34:37 <timthelion> Does State give preformance gains, or only ST?
03:35:13 <shachaf> Performance gains over what?
03:35:50 <timthelion> shachaf: in the case of modifying several pixels of a large image...
03:36:17 <shachaf> Performance gains as opposed to doing what?
03:36:32 <timthelion> as opposed to pure recursion with copying...
03:36:59 <Jafet> Don't give him a straight answer yet. Instead, point to the GHC profiler documentation.
03:37:20 <timthelion> Jafet: was that a joke ;)?
03:38:40 <timthelion> The preformance of f :: myimage -> myonlyslightlymodifiedimage is terrible, is State just a prettier way of writting that, or does it actually fix the preformance problem?
03:38:51 <quicksilver> timthelion: State is just a prettier way of writing that.
03:39:18 <quicksilver> the State monad is just an unusual syntax for constructing functions.
03:39:38 <timthelion> thankyou
03:40:27 <quicksilver> the performance of f :: myimage -> myslightlydifferentimage depends what kind of data structure you use for the image.
03:41:10 <quicksilver> there are ways of making it reasonably fast. And "terrible", in isolation, doesn't mean much. Simply copying memroy is something that modern CPUs do fairly fast, so avoiding copying isn't always the important thing.
03:41:44 <timthelion> quicksilver: well it can be, what, an array, or a List.   I'd like to make a program akin to MS paint,  I don't want to reload the image in memory every single brush stroke :D
03:42:42 <av> any takers on my attoparsec issue? :(
03:43:08 <timthelion> quicksilver: I'm not convinced.  I remember once I had in java the loop while(something){stringf++"something";} and I measured that concat at over a seccond.
03:43:13 <Botje> timthelion: guess what your video card is doing in the meantime.
03:43:17 <merijn> timthelion: There's packages that provide arrays with in place updates
03:43:42 <timthelion> Botje: the video card mutates the video buffer in place.
03:44:16 <merijn> Depends
03:44:22 <Botje> and then it is copied into the right place by a compositor
03:44:30 <merijn> Lots of copying there too, from the various different local caches/memory
03:44:55 <Botje> and then it's copied again to a double buffer system
03:44:58 <quicksilver> timthelion: video cards do not mutate buffers in place.
03:45:09 <quicksilver> timthelion: java string concat is not a simple memory copy.
03:45:10 <timthelion> Copying array to array is perhaps quick.  But array to newarray is very slow... So the question is whether memory allocation takes place.
03:45:18 <quicksilver> wrong again
03:45:23 <quicksilver> memory allocation in haskell is very fast.
03:45:40 <timthelion> why should it be different across languages?
03:45:58 <quicksilver> because different language runtimes have different memory allocation strategies.
03:46:19 <quicksilver> haskell maintains a pool of heap and a pointer; allocating new memory is one machine code addition (to change that pointer)
03:46:44 <quicksilver> you might guess that typical java implementation has to find a pool of the right size and record some metadata about the size of block allocated
03:46:54 <quicksilver> (NB I haven't actually looked at a java implementation recently)
03:47:17 <quicksilver> one of the key advantages of a GC system like GHC is that allocation is very very fast.
03:47:26 <quicksilver> there is a trade-off at the other end.
03:47:37 <timthelion> what trade off?
03:47:49 <quicksilver> well, GHC has a garbage collector, which takes time to run
03:47:58 <quicksilver> compared to, say, C++'s stack deallocation which is fast
03:48:04 <int-e> afaik, java also has a copying GC for the first generation at least.
03:48:04 <quicksilver> if you managed to keep stuff on the stack.
03:48:07 <shachaf> quicksilver: Why wouldn't a Java implementation be able to allocate memory the same way?
03:48:11 <rostayob> I remember somewhere on the haskellwiki a way to generate haddock documents with link to the hackage documentation, but I can't find it now
03:48:11 <lambdabot> rostayob: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:48:21 <int-e> C/C++ don't have that choice because the programmer gets to see and manipulate raw pointers.
03:49:02 <quicksilver> shachaf: you can imagine one which might.
03:49:18 <quicksilver> shachaf: implementations have to make various different GC choices because of mutability though.
03:50:26 <rostayob> ok, found something..
03:52:06 <quicksilver> timthelion: anyhow, I came across as more unfriendly than I intended.
03:52:30 <quicksilver> timthelion: probably you're right, that to write macpaint you would try to avoid copying all the pixels every time the user changed the image
03:52:35 <timthelion> quicksilver: it doesn't bother me.  I appreciate that you attempt to answer my questions.
03:52:54 <quicksilver> although that's less important than you'd think - modern operating systems/graphics cards copy every single pixel on the screen 60 times a second, much of the time.
03:52:58 <quicksilver> even smartphones do this.
03:53:14 <quicksilver> modern graphics cards are designed specifically to make this a reasonable approach.
03:53:28 <quicksilver> there are loads more structures than array and list
03:53:38 <quicksilver> you might consider some kind of tree of "commands"
03:53:46 <quicksilver> so that you could always reconstruct the steps the user had taken
03:53:54 <quicksilver> that approach gives you infinite undo capability
03:54:09 * av is scratching his head
03:54:17 <timthelion> quicksilver: and requires that all functions applied to the image have an inversion.
03:54:31 <quicksilver> it doesn't require that; that might make it more efficient in some cases
03:54:44 <quicksilver> but you can always start from the white canvas at time 0 and work forward
03:55:10 <quicksilver> after the user has made some 10s of thousands of commands maybe this isn't efficient any more
03:55:24 <quicksilver> but you could save "keyframes" every hundred commands
03:55:34 <quicksilver> lots of trade-offs between speed, memory, and functionality.
03:55:54 <shachaf> quicksilver: Or store log(n) keyframes, depending on the use case.
03:56:00 <quicksilver> yes.
03:56:08 <timthelion> well we no longer have to worry about memory.  I'm only using a third of my 3gigs
03:56:12 <quicksilver> there are lots of possible approaches.
03:56:16 <shachaf> log(n) has the advantage of being constant. :-)
03:57:43 <merijn> Ha, depends on your work and machine :p
03:58:26 <merijn> I recently (for the first time) ran into needing a address space significantly bigger than 32bit (which the machine unfortunately didn't have :p)
03:58:29 <timthelion> merijn: over here, I find that graphics and CPU have always bottlenecked before memory.
03:58:43 <timthelion> merijn: and what where you doing?
03:59:52 <merijn> timthelion: Experimenting with software managed coherency (think caches), if you're planning on sharing significant bits of address space between multiple cores you can burn through 32bit in no time
04:00:41 <timthelion> oh, that's why you need 128 :D
04:00:44 <timthelion> bits that is
04:01:05 <_mpu> Hi, I recently upgraded ghc, but now packages in my home directory are no longer listed by ghc-pkg list.
04:01:12 <_mpu> What should I do?
04:01:22 <shachaf> _mpu: Recompile them.
04:01:36 <shachaf> _mpu: The old GHC will keep seeing the old packages, if it's still around.
04:01:42 <shachaf> But it doesn't work across GHCs.
04:01:58 <_mpu> shachaf, Can I safely erase my ~/.cabal to free space?
04:02:14 <timthelion> I just the other day I was trying to figure out if there would be any advantage to a 1024bit CPU.  The only things I could think of were fringe cases where you would use bitmasks to modify brightness/contrast on large images, and processed the image in 30 pixel chunks.
04:02:35 <timthelion> _mpu: diskorexia?
04:02:59 <shachaf> _mpu: Well, it has a bunch of other things, like .cabal/config and .cabal/bin and what not.
04:03:13 <shachaf> _mpu: You can try renaming it to something else and seeing if something is broken.
04:03:24 <shachaf> _mpu: Also, space is cheap.
04:03:38 <_mpu> shachaf, I don't like bloat.
04:04:19 <timthelion> _mpu: you suffer from diskorexia, it's a terrible disease.
04:05:56 <_mpu> timthelion, I do not vomit.
04:06:17 <astor_> is there a pipes/iteratees/etc where one can merge multiple inputs?
04:06:54 <timthelion> _mpu: no, that's diskolemia, when you freek out and reinstall every time hard disk usage gets to 30%
04:06:57 <timthelion> :D
04:09:11 <av> any users of attoparsec around here?
04:09:48 <Axman6> plenty, whats your question?
04:09:56 <bcw> i've erased ~/.cabal several times when i wanted to "start fresh", the only problem i had was remembering to ALSO delete ~/.ghc so it doesn't get confused
04:10:33 <av> my code is this: parse (many (many letter <* endOfLine)) $ pack "lkjasdlfjk\nf\n" -- why does this evaluate as "Partial _"?
04:11:03 <Axman6> av: mergw how? theres severl ways you could do it
04:11:12 <Axman6> uh, astor_
04:12:51 <dcoutts> timthelion: big vector registers can be quite useful, rather than wide individual registers
04:13:26 <yitz> av: because there could be more input
04:14:00 <av> yitz: so how do I make it work then?
04:14:02 <yitz> av: you have to tell attoparsec that you are done. then it will know to stop looking for more of the "many"
04:14:03 <mysticc> Not able to beat python dictionaries .. http://paste.pocoo.org/show/568365/ vs http://paste.pocoo.org/show/568413/ ..
04:14:22 <astor_> Axman6: for example in Contro.Pipe.Pipe, you can only use 'await'.  But sometimes you want to take two pipes, and merge them using some comparator that decides which pipe to await from.
04:14:41 <yitz> av: the Partial data is a function to process further input. feed it the empty string.
04:15:19 <timthelion> dcoutts: but they only save time in memory access, rather than actually reducing flops.
04:15:21 <yitz> av: there is also something like "parseOnly" which does that automatically.
04:16:20 <dcoutts> timthelion: depends how much ALU hardware you stick in, but yes the really big vectors are there to optimise memory latency and improve pipelining
04:16:43 <av> yitz: ah, OK, thanks -- let's see how I get on
04:17:29 <dcoutts> timthelion: if you want to think about it in bit widths, the cray vector machines had 4096 bit registers
04:18:08 <_mpu> Now, if package P appears in "ghc-pkg list" but when I do cabal build the package is not found by ghc.
04:18:27 <dcoutts> _mpu: is it listed in ()'s or {}'s ?
04:18:36 <timthelion> dcoutts: and did they find use for them?  I seem to recall how(as an example) the hard drive caches didn't do anything for preformance...
04:18:36 <_mpu> dcoutts, No.
04:18:53 <dcoutts> _mpu: then cabal and ghc should find it.
04:20:03 <_mpu> dcoutts, Even if it is in my home package.conf.d?
04:20:16 <dcoutts> timthelion: sure, mainly for fortran code, and it's not about caching
04:20:25 <dcoutts> _mpu: yes
04:20:52 <_mpu> dcoutts, Still: <command line>: cannot satisfy -package-id Stream-0.3.1-28f...
04:21:19 <_mpu> dcoutts, And ghc-pkg list says:    Stream-0.3.1
04:21:26 <dcoutts> _mpu: if you've changed packages around since doing cabal build, then you would have to cabal configure again
04:21:48 <_mpu> dcoutts, Oh yes, thanks.
04:22:07 <_mpu> dcoutts, Now it is fine, thanks.
04:22:50 <mysticc> Python code here is 10times faster than haskell code (compiled with -O2) .. Not able to beat python dictionaries .. http://paste.pocoo.org/show/568365/ vs http://paste.pocoo.org/show/568413/ ..
04:23:03 <dcoutts> _mpu: ghc/ghc-pkg record the package ABI hash as well, so that re-building and re-registering a package marks it as being different from the previous build (since they're now ABI incompatible)
04:27:52 <mrcarrot> mysticc: so that function counts how many times each word exists in a sentence?
04:27:58 <dcoutts> mysticc: well, not so much python vs haskell as a benchmark of hash tables, still I think Gregory Collins would be interested in your benchmark of his package.
04:29:21 <dcoutts> mysticc: I understood from him that his hashtable impl was pretty good, so I think he'd be interested in what's going on with a 10x factor. Try emailing him.
04:31:19 <mysticc> mrcarrot: I tested it on a file with like 1000000 words ..
04:32:34 <mysticc> I just wanted to know how to write a haskell code that can beat the performance of the python dictionaries ..
04:33:03 <mrcarrot> mysticc: do you plan to modify the code to keep that hashtable for later use?
04:33:10 <dcoutts> mysticc: or you can ask here https://github.com/gregorycollins/hashtables/issues
04:33:59 <mysticc> mrcarrot: That is just a test case .. I want to query on the hashtable for count of each word..
04:34:31 <dcoutts> mysticc: that's a difficult question, since you're talking not about python but about a C hashtable implementation that has been tuned over many years by many people.
04:35:04 <dcoutts> mysticc: there is no reason to expect that you could beat that in any language really, except possibly assembler, or by using a different/better data structure
04:35:30 <mysticc> dcoutts: Ok .. but atleast get twice slowdown ..
04:36:02 <dcoutts> mysticc: yes, that's kind of the level I would expect. As I said, I think Greg would be interested to see your example.
04:36:24 <mysticc> ok
04:36:29 <dcoutts> he'd have a much better chance than any of us in explaining what's going on, or fixing things
04:37:31 <dcoutts> mysticc: so if you report it to him, or in the github bug tracker, make sure you give details on how you did the benchmark
04:37:44 <dcoutts> versions of everything, OS, CPU etc
04:38:56 <mrcarrot> i do not know anything about the implementation of the hashtable you are using and the one in base... i wonder how this one is changing the performance: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-HashTable.html
04:39:30 <dcoutts> mrcarrot: it's not the one in base, it's this one http://hackage.haskell.org/package/hashtables
04:39:55 <dcoutts> the one in base is pretty poor
04:40:27 <dcoutts> (unless the impl was changed recently)
05:12:57 <astor_> I found this example of merging using Iteratee http://okmij.org/ftp/Haskell/Iteratee/Merge.hs - can this be done in Control.Pipe?
05:42:20 <exFalso1> hi, is there a way to get a datatype's projections in TH?
05:42:38 <rostayob> exFalso1: projections? you mean record fields?
05:42:45 <exFalso1> yes
05:42:48 <rostayob> yes, there is
05:42:54 <exFalso1> ah thats why google didnt show any results :)
05:43:12 <rostayob> exFalso1: look at RecC
05:43:25 <exFalso1> thanks!
05:43:34 <rostayob> no problema
05:49:41 <_mpu> When I try to cabal install some packages, this error pops up (http://paste.pocoo.org/show/568455/). Can anybody help?
05:51:36 <dcoutts> _mpu: the workaround is to stick to the version of the template-haskell package that came with your ghc version
05:51:43 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/5704
05:51:45 <quicksilver> I think
05:52:00 <dcoutts> ah, and quicksilver beat me to the actual ghc bug
05:53:03 <imc> the name is not for nothing
05:53:08 <_mpu> dcoutts, ok, so I must hide my local template-haskell?
05:53:40 <dcoutts> _mpu: either get rid of it, or tell cabal to use the other one
05:53:45 <dcoutts> using --constraint flags
05:53:49 <dcoutts> hiding does nothing
05:53:53 <dcoutts> that only affects ghci
05:54:01 <_mpu> dcoutts, How can I get rid of a package?
05:54:08 <dcoutts> unregister it
05:54:23 <dcoutts> using ghc-pkg
05:54:52 <_mpu> Yes, thanks.
06:07:12 <nifei> lesson2
06:09:49 <nifei> a
06:09:51 <nifei> 12
06:09:57 <nifei> 5＋７
06:10:19 <nifei> 12
06:10:21 <nifei> 12
06:10:46 <hpc> > 5 + 7
06:10:47 <lambdabot>   12
06:10:50 * hpc learned so much!
06:19:14 <kallisti> it would be nice to have a graphical visualizer of the Haskell runtime.
06:19:33 <JaffaCake1> kallisti: we used to have such a thing, but it has bitrotted
06:19:36 <mux> isn't that what ThreadScope is about?
06:20:18 <JaffaCake> there was a "front panel" that showed in realtime things like the size of each generation, the memory map, number of threads etc.
06:20:38 <JaffaCake> the code is still in the repo, rts/FrontPanel.c
06:22:24 <kallisti> Neat. It would be cool (and useful!) to see a visualization of the order of evaluation of expressions, but this is probably a pretty difficult thing to do.
06:23:34 <exFalso1> if i insert {-# LANGUAGE TemplateHaskell #-} ghc-mod's flymake will stop detecting errors... does anyone know whats going on?
06:25:23 <exFalso1> can i somehow specify that ghc should use -fth when compiling with flymake?
06:26:24 <rostayob> exFalso1: it does detect error for me. are you sure you have errors in the first place :P?
06:27:02 <exFalso1> if i delete the flag's line it works
06:27:13 <exFalso1> i mean it detects errors
06:27:26 <geekosaur> kallisti, no idea about threadscope but there are already tools to do that (hat)
06:27:30 <rostayob> actually no. it detects errors that are not there... I don't know
06:27:42 <rostayob> (that are not there when I compile the file)
06:28:53 <kallisti> geekosaur: I might have to look into one of those. I might actually learn something about the evaluation order of my programs, rather than fumbling about in the dark.
06:31:16 <sajkr> i'm having some trouble using Data.Vector.Unboxed.Mutable with the ST monad.
06:31:34 <kallisti> sajkr: go on
06:33:10 <sajkr> type inference fails, it can't unify MVector (PrimState (ST s)) Int with MVector (PrimState m0) Int?
06:33:18 <dcoutts_> JaffaCake: I was looking at that code not so long ago, when adding the new heap events to the rts
06:33:26 <sajkr> wait, i forgot Rank-2 :D
06:33:47 <dcoutts_> JaffaCake: I think we now have enough that we could re-create the front pannel, but remotely via a ghc-events stream
06:34:04 <sajkr> nope, still fails.
06:34:38 <quicksilver> sajkr: can we have a paste of the code and the exact error message?
06:34:48 <sajkr> just a moment.
06:34:51 <kallisti> sajkr: it sounds like it can't figiure out which Monad you want to use, at some point. I can only give vague advice without more detailed info.
06:35:15 <JaffaCake> dcoutts_: except the memory map stuff, right?
06:35:28 <dcoutts_> JaffaCake: ah, I missed that bit
06:35:37 <JaffaCake> maybe only I care about that :)
06:35:40 <dcoutts_> :-)
06:35:50 <JaffaCake> generation sizes is quite interesting too
06:36:53 <t7> how many monads could a monad monad if a monad monad monad?
06:36:55 <JaffaCake> I remember giving a talk about the front panel once, and someone asked me to fire it up with 64 generations.  I'd never tried it, but it worked, and gave some really interesting insight into what the GC was doing
06:37:04 <dcoutts_> JaffaCake: interesting
06:37:06 <hpaste> sajkr pasted “mutable vectors & st monad” at http://hpaste.org/65609
06:37:51 <hpaste> sajkr pasted “the error” at http://hpaste.org/65610
06:38:11 <dylukes> JaffaCake: Hey, did you see my Trac comment?
06:38:15 <Jafet> A front panel would be great for company tours. "And this, folks, is our state-of-the-art network service."
06:38:52 <JaffaCake> dcoutts_: would be great to break the heap space down into thunks, functions, and constructors and give each a different colour, to give visual feedback on what the heap is full of
06:38:54 <sajkr> quicksilver, kallisti: there you go.
06:39:16 <JaffaCake> dylukes: thanks
06:39:33 <JaffaCake> Jafet: heh
06:39:34 <dcoutts_> JaffaCake: and we can do that without -prof mode
06:39:45 <JaffaCake> dcoutts_: right
06:40:05 <quicksilver> sajkr: you're not actually *executing* the code in go/repr, are you?
06:40:14 <dcoutts_> JaffaCake: the only hard part is finding the time to do it :-)
06:40:17 <quicksilver> that might be making type inference harder
06:40:36 <dcoutts_> JaffaCake: did I tell you about the linux perf status after our last meeting btw?
06:40:38 <quicksilver> I would recommend type signatures on all your top level functions
06:40:41 <quicksilver> which would make this obvious
06:40:52 <JaffaCake> dylukes: can you dual-boot 10.8? is it possible to resize partitions on OS X to make room for it?
06:40:56 <quicksilver> but I think you simply want to run (repr pm) rather than return it, at the end.
06:40:57 <kallisti> sajkr: try adding some top level type signatures and -- yes what quicksilver said.
06:41:03 <dylukes> JaffaCake: indeed.
06:41:07 <JaffaCake> dcoutts_: no you didn't...
06:41:10 <exFalso1> is there a way to make ghc-mod display the output of the flymake compile directly?
06:41:17 <dcoutts_> JaffaCake: ah, let me do so...
06:41:18 <sajkr> quicksilver: oh, i see.
06:41:28 <dylukes> Open up Disk Utility, it should be pretty straightforward.
06:41:28 <JaffaCake> dylukes: indeed as in, you can?
06:41:33 <dylukes> Yep.
06:41:41 <JaffaCake> ok great
06:41:46 <dylukes> But, mind you,
06:41:56 <dylukes> if you have Linux installed, chances are it fucked up the Hybrid MBR/GPT.
06:42:01 <dylukes> If not, you're fine.
06:42:07 <dylukes> messed up*
06:42:14 <JaffaCake> I don't have Linux installed
06:42:28 <sajkr> quicksilver: yes, i somehow overlooked the "return $" when i changed that line.
06:42:32 <mightbereptar> then you should
06:42:33 <sajkr> silly me.
06:42:39 <JaffaCake> but it'd probably still take me a day to do all this, at least
06:42:50 <dylukes> Then yeah, just go into Disk Utility, select the disk, Partition, [ + ] button, and just make sure it's Mac OS Extended (Journaled).
06:43:02 <sajkr> quicksilver, kallisti: thanks, it works now, without explicit annotations.
06:43:23 <dylukes> Once you have two, that's all you need to do. Then just run the 10.8 installer, select the new partition, and it'll automatically boot from a ramdisk on restart.
06:43:29 <dylukes> No disks or anything.
06:43:33 <kallisti> sajkr: I still recommend explicit top-level types.
06:44:14 <dylukes> I would do the analysis myself, but I don't have any experience or idea what to do. Sorry.
06:45:39 <t7> is there a turing complete combinatory logic without parens?
06:47:20 <kallisti> t7: Unlambda
06:47:26 <kallisti> that's the only one I can think of off the top of my head.
06:50:32 <int-e> http://semarch.linguistics.fas.nyu.edu/barker/Iota/
06:50:43 <rostayob> iota still needs parens (but just one combinator)
06:51:23 <int-e> nah, as described there it uses the same idea as unlambda, but ` is called *.
06:51:33 <t7> how does it work
06:51:47 <rostayob> oh, ok.
06:52:12 <t7> the *
06:52:29 <rostayob> t7: it explains there
06:53:05 <t7> a binary programming language :)
06:53:17 <rostayob> now, I wonder if it's possible to have that with one symbol :)
06:53:24 <rostayob> well yes actually
06:53:32 <rostayob> mhm...
06:54:04 <rostayob> it's definitely theoretically possible, e.g. encoding programs as numbers and then simply having n instances of the same symbol (where n is the number)
06:54:11 <exFalso1> yep
06:54:20 <t7> you can encode anything as a number
06:54:47 <t7> i was just thinking the same thing
06:55:36 <rostayob> yeah but I don't think you can using just one symbol and term rewriting :P
06:56:14 <kallisti> the semantics associated with the symbol would likely be different.
06:56:17 <dcoutts_> JaffaCake: just in case you were not looking at #ghc, I explained about linux perf there.
06:56:30 <JaffaCake> oops, sorry
07:00:04 <t7> i wish tcp sockets could be transferred between connections
07:01:20 <astor_> t7: a tcp connection? does that make sense?
07:01:25 <snhmib> tcp over tcp for new tcp? o_O
07:01:33 <t7> i mean adapter
07:01:33 <mux> I wish I had a flying unicorn
07:01:49 <t7> like im turing wireless off now because i have ethernet pluggged in
07:01:57 <t7> irc should stay online
07:02:00 <jeff_s_> mux - remember to wish for it to be pink.
07:02:10 <mux> you want SCTP then, you actually want multi-homing
07:02:36 <quicksilver> I heard you like networking so I put a layer in your layer so you could connect while you connect
07:02:36 <mux> SCTP can handle multiple endpoint addresses just fine (at least in theory)
07:02:39 <quicksilver> or something.
07:03:19 <rostayob> is it possible to have cabal generate haddock links to the hackage packages?
07:04:43 <dcoutts_> rostayob: yes, with a bit of fiddling
07:05:05 <rostayob> dcoutts_: is there something online?
07:05:41 <dcoutts_> rostayob: cabal user guide, see the haddock subcommand
07:06:28 <rostayob> dcoutts_: right, thanks.
07:07:15 <rostayob> I get:
07:07:18 <rostayob> Warning: Cannot read /home/rostayob/.cabal/share/doc/mtl-2.0.1.0/html/mtl.haddock:
07:07:20 <rostayob>    Interface file is of wrong version: /home/rostayob/.cabal/share/doc/mtl-2.0.1.0/html/mtl.haddock
07:07:23 <rostayob> for everything but base.
07:07:27 <astor_> t7: or multipath tcp, or ice
07:08:12 <dcoutts_> rostayob: check what version of haddock you're using
07:08:38 <rostayob> 2.10.0, hackage uses something different?
07:08:51 <mux> astor_: I think MPTCP is even less deployed than SCTP these days (I could be wrong though, I didn't check that)
07:11:16 <astor_> mux: ice + udp is what's used
07:11:31 <rostayob> dcoutts_: the problem is that hackage docs themselves have been generated with different hackage versions..
07:11:59 <dcoutts_> rostayob: but the versions on your machine should have used one version
07:12:08 <dcoutts_> rostayob: you're not downoloading .haddock files from hackage
07:12:48 <rostayob> dcoutts_: yeah but I have no problems without specifying --html-location (in other words the local links get generated correctly)
07:12:53 <mux> astor_: most likely doesn't help much with IRC though :) I wonder if there are SCTP-enabled IRC servers out there. I guess not
07:13:40 <t7> someone should write an itoa hardware processor
07:13:59 <cdh473> write a hardware processor?
07:14:08 <t7> make
07:14:29 <sipa> itoa?
07:14:39 <sipa> integer to ascii?
07:14:40 <int-e> cdh473: in some hardware description language.
07:14:41 <t7> *i*iii*i*i
07:14:42 <int-e> sipa: iota
07:15:14 <dcoutts_> rostayob: --html-location does not do anything special with reading extra files, it's just changing what urls get generated
07:15:15 <int-e> t7: that's malformed.
07:15:31 <rostayob> dcoutts_: oh right, my bad, sorry
07:15:32 <t7> the last bit?
07:15:50 <int-e> t7: it's 3 expressions, one incomplete: (*i*ii)(i)(*i*i<something is missing here>)
07:15:57 <t7> its curried
07:16:21 <totimkopf> how does one do  'next' and 'previous' with a list in haskell? (as a linked list)
07:16:25 <dcoutts_> rostayob: if you've found a problem, you'll have to be a lot more specific about what works and what doesn't
07:16:32 <rostayob> dcoutts_: no no, it was my fault
07:17:38 <int-e> totimkopf: 'next' is 'tail'; 'previous' doesn't exist because haskell lists are singly linked. (you *can* build doubly linked lists but they are extremely awkward to create and impossible to modify (you have to create a new list from scratch instead))
07:18:24 <hpc> (you can't modify singly linked lists either)
07:18:37 <hpc> ((also, a doubly linked list is a kind of zipper))
07:18:39 <int-e> hpc: true, but you can share tails.
07:18:51 <hpc> zippers can share tails
07:18:54 <hpc> in both directions
07:19:07 <hpc> and do
07:19:07 <totimkopf> 'share tails'? what does that mean?
07:19:38 <hpc> when you seek a list zipper, all that gets created is a single cons for the previous cursor
07:19:45 <int-e> you can take a list xs and prepend different values to it without copying it. 'a':xs and 'b':xs
07:20:25 <int-e> The real question is, of course, "what is a list?"
07:20:44 <hpc> @src []
07:20:45 <lambdabot> data [] a = [] | a : [a]
07:21:00 <hpc> read: a list is either empty, or a thing followed by a list
07:21:35 <int-e> in which case there is a 'next' operation (tail), but no 'prev' one.
07:23:33 <cdh473> The list [1,2,3] in Haskell is actually shorthand for the list 1:(2:(3:[]))
07:45:45 <osa1> can I use parsec on Data.Text?
07:46:19 <donri> Text.Parsec.Text
07:48:21 <osa1> donri: can't find that package, can you tell me the link?
07:48:28 <donri> @hackage parsec
07:48:28 <lambdabot> http://hackage.haskell.org/package/parsec
07:49:02 <donri> attoparsec also supports text with Data.Attoparsec.Text
07:52:17 <osa1> donri: I have Text.Parsec package but don't have Text.Parsec.Text, do you have any ideas?
07:52:28 * hackagebot nanoAgda 1.0.0 - A toy dependently-typed language  http://hackage.haskell.org/package/nanoAgda-1.0.0 (JeanPhilippeBernardy)
07:55:28 <chupish> huh, nanoAgda looks really neat
07:57:53 <danr> chupish: yes, let's install it
07:58:11 <chupish> danr: already on it :)
08:02:29 * hackagebot biosff 0.2 - Library and executables for working with SFF files  http://hackage.haskell.org/package/biosff-0.2 (KetilMalde)
08:06:20 <Eduard_Munteanu> chupish: btw, there's also Agda and #agda ;)
08:07:02 <chupish> Eduard_Munteanu: oh yeah, I've seen Agda before, and it's awesome, but this nanoAgda seems really neat
08:07:13 <chupish> "The goal of the project is to provide a minimal type-checker with dependent types that can be easily fiddled with. " sounds *awesome*
08:07:39 <Eduard_Munteanu> There also micro and miniAgda, IIRC
08:08:19 <chupish> oh, neat
08:15:43 <roconnor> Regarding: http://www.eugenkiss.com/blog/2012-03-thoughts-on-upcoming-pls.html , it is too bad that people find laziness-by-difficult so hard to switch to.  After programming in Haskell for years, I struggle to write things in strict-by-default langauges where strictness problems lurk everywhere and eta-expanding functions have huge operational consequences.
08:17:19 <lorinescu> brempulamea
08:17:31 <kallisti> any suggestions on an efficient algorithm to select N elements randomly from a list?
08:17:58 <kallisti> I was thinking you could randomly choose offsets to drop, but I'm not sure what kind of math you would need to do that accurate.
08:17:59 <lorinescu> am fost la un interviu unde mi-au explicat aia ca vor un devops ca ei au jruby si java si hadoop si fac loadbalancing cu keepalived si mac spoofing
08:18:09 <lorinescu> import Face.Palm;
08:18:18 <lorinescu> sorry, wrong window
08:18:27 <mauke> devops? jruby? hadoop? romanian?
08:18:43 <roconnor> kallisti: choose with or without duplicates?
08:18:48 <kallisti> without
08:18:54 <lorinescu> yeah, just went trough a terrible interview
08:18:58 <lorinescu> job interview
08:19:14 <danr> chupish: did you get it to compile? I get an error from alexGetByte
08:19:15 <mauke> man, and I went through all that trouble to be able to type şi
08:19:35 <kallisti> roconnor: oh, and a library that does it for me is perfectly acceptable.
08:19:37 <roconnor> kallisti: actually, your droping of elements of the list doesn't seem like a terrible idea.
08:19:40 <kallisti> I was just considering if it would be trivial to write.
08:19:59 <kallisti> roconnor: yes, if done correctly it would be efficient. I'm just uncertain of the mathematically correct way to do it.
08:20:13 <roconnor> kallisti: the killer bit is that you need to know the length of the list first, which is a little unfortunate, since it will force the spine.
08:20:20 <kallisti> ah, yes.
08:20:21 <roconnor> kallisti: but for not too long lists it would be okay.
08:20:34 <osa1> does anyone here have some examples about using parsec on Data.Text ?
08:20:39 <chupish> danr: it's still running through cabal deps apparently
08:21:15 <dolio> roconnor: Was that a Freudian slip?
08:21:15 <roconnor> kallisti: it'd be interesting to find an algorithm that would work without forcing the list
08:21:54 <roconnor> dolio: possibly, since I don't know what you are refering to.
08:22:03 <dolio> "laziness-by-difficult"
08:22:08 <quicksilver> roconnor: not possible with equal probability (as far as I can see)
08:22:08 <dolio> :)
08:22:15 <roconnor> dolio: hah
08:22:20 <roconnor> it must have been
08:22:54 <roconnor> kallisti: I'd be tempted to, for now, simply turn the list into an array and pick random indexes
08:23:05 <kallisti> yeah..
08:24:01 <roconnor> quicksilver: I'm imagining something where you first take the first n elements of your list, then check if the rest of the list is empty, if so, you are done, if not you randomly replace one of your n elements with the head of the remainder of the list, or skip it, with some appropriate probability ...
08:24:05 <roconnor> quicksilver: not sure if this works
08:25:42 <roconnor> so for the (n+1)th element you drop it with probability (1/n+1) and otherwise some random element of your state.
08:26:52 <roconnor> then for the (n+2)th element you drop it with probabiliity (2/(n+1)/(n+2))??? and otherwise replace some random element of your state
08:27:03 <roconnor> and keep doing this until you get to the end of your list
08:27:17 <roconnor> ... I have no idea if this works properly
08:27:40 <roconnor> anyone want to do the math?
08:28:03 <copumpkin> eww math
08:28:12 <roconnor> Even if this does work, I'd be tempted to use an array still.
08:29:58 <ben> I've heard this promoted as an algorithm to pick e.g. a random line from a file with only on pass
08:30:25 <roconnor> ben: drat, I get no paper out of this.
08:30:26 <ben> so based on the appeal of the authority of probably some babby's-first-algorithm article on the internet, i'm gonna say that's mathematically sound
08:30:27 <roconnor> :P
08:31:34 <quicksilver> roconnor: sounds good to me, I'll take twelve, where do I sign?
08:31:36 <roconnor> kallisti: so there you go, if you really want to use a foldM on your list instead of an array for some strange reason, some person on the internet says that some person on the internet says that this will work.
08:31:48 <kallisti> oh good.
08:32:30 <kallisti> a suppose my question now is: if I use an array, is there a better way to avoid duplicates than checking my existing randomly selected list for duplicates.
08:32:33 <weexplat> hm, using fchdir(2) still wouldn't be safe if i had it, because someone could have revoked search permission on the cwd before i change back to it
08:33:04 <weexplat> fork it is, i guess
08:33:14 <weexplat> i wish fork worked right with threaded ghc
08:33:26 <roconnor> for the (n+k)th element of the list, you drop it with probability (product [1..k]/product[n+1...n+k]) and otherwise you randomly replace an element of your current n-picks.
08:34:02 <quicksilver> it works better than it used to weexplat
08:34:55 <kallisti> roconnor: interesting
08:35:55 <roconnor> kallisti: one way is to pick a random index of the array i \in [0..m-1] and swap it with position 0.  Then, pick a random index of the sub-array [1..m-1] and swap it with position 1, and repeat this until your first n-positions are filled and take those.
08:36:18 <kallisti> roconnor: ah. so C++ style. :D
08:36:24 <roconnor> kallisti: here you would use a Mutable array, probably in the ST monad.
08:36:49 <weexplat> quicksilver: as of which ghc version?
08:36:56 <roconnor> kallisti: it's easy and simple to understand.
08:36:59 <kallisti> yes.
08:37:08 <kallisti> I didn't mean anything bad by that.
08:37:11 <roconnor> :)
08:38:02 <dschoepe> although "easy and simple to understand" is definitely not the first thing that comes to mind when one hears C++ :)
08:38:03 <weexplat> i was sure there was a library on hackage to do this combinatorial stuff
08:38:50 <weexplat> dschoepe: what do you mean?  whenever i hear 'C++' i immediately think 'i wish it was something easy and simple to understand' ...
08:39:05 <roconnor> ya, there is presumably a package to do this sort of thing somewhere on hackage ... :S
08:39:37 <roconnor> only because there are so many packages
08:39:44 <dschoepe> weexplat: Yeah.. that's what I get for not being specific enough in #haskell... :)
08:40:11 <weexplat> roconnor: i meant 'i could swear i actually saw one at some point although i can't remember what it was called'
08:40:52 <dschoepe> weexplat: combinat? http://hackage.haskell.org/package/combinat
08:41:21 <quicksilver> weexplat: http://hackage.haskell.org/trac/ghc/ticket/1185
08:41:58 <quicksilver> but see also http://hackage.haskell.org/trac/ghc/ticket/4027
08:42:16 <Younder> I have "innerProd :: Num a => [a] -> [a] -> a \n innerProd x y = foldr (+) 0 (zipWith (*) x y)" can I do this without havng to spesify x and y?
08:42:53 <quicksilver> weexplat: and see further http://www.haskell.org/pipermail/cvs-libraries/2011-December/014717.html
08:43:03 <mux> @pl \x y -> foldr (+) 0 (zipWith (*) x y)
08:43:03 <lambdabot> (foldr (+) 0 .) . zipWith (*)
08:43:13 <mux> Younder: there you go ;)
08:43:19 <Younder> mux: thx
08:43:25 <weexplat> dschoepe: probably
08:43:33 <mux> whether it makes sense to write it that way is up to you
08:43:42 <weexplat> quicksilver: thanks, that seems pretty thorough
08:43:49 <mux> I find the pointful version more readable myself
08:44:45 <weexplat> mux: the readable pointless way is (foldr (+) 0) .: zipWith (*)
08:45:10 <danr> weexplat: agreed
08:45:31 <weexplat> or better yet sum .: zipWith (*).  or 'sumr' if you really must have the foldr
08:45:33 <mux> I still prefer the pointful one
08:47:30 <quicksilver> I'm not sure f .:  g is any more readable than (f .) . g
08:47:43 <quicksilver> in each case you read it simply by remembering what it means
08:47:57 <quicksilver> is .: a better symbol than .).
08:47:59 <quicksilver> perhaps.
08:48:06 <jeff_s_> Haskell could use a better module importing system. 50 lines of imports for a 177 line file seems a bit much.
08:48:10 <jeff_s_> Not that I know how to fix it.
08:48:25 <quicksilver> well you can import them all into JeffSCoolImports.hs
08:48:31 <quicksilver> and re-export them from that
08:48:36 <quicksilver> unless you need some of them qualified.
08:48:47 <dolio> (_.). is an inconvenient operator to write.
08:48:50 <jeff_s_> Some of them, no tall.
08:48:53 <dolio> Mainly.
08:48:54 <quicksilver> the ability to re-export qualified would be really quite handy.
08:48:57 <kallisti> then you could have JeffSCoolImports and JeffSCoolQualifiedImports
08:49:07 <kallisti> and import both of those.
08:49:09 <kallisti> problem solved.
08:49:17 <jeff_s_> This sounds almost like a good idea.
08:49:19 <quicksilver> kallisti: not if you need different qualifications.
08:49:37 <quicksilver> if you have the five types A.T, B.T, C.T, D.T and E.T
08:49:50 <quicksilver> you need five separate import statements to get them under different qualifications.
08:49:54 <dolio> Clearly this is why we shouldn't curry anything.
08:49:57 <quicksilver> qualified re-xport would solve this.
08:50:06 <kallisti> the solution: don't use imports. right everything yourself.
08:50:26 <kallisti> *write
08:50:34 <quicksilver> dolio: did you mean (\f g -> (f.).g) is inconvenient to write?
08:50:45 <quicksilver> (if you want to pass the operator itself around as a higher order parameter)
08:51:07 <quicksilver> or did you mean that, in a concrete expression "(f.).g" is harder to write than "f.:g" ?
08:51:08 <dolio> No, I mean it's inconvenient to use in your expressions.
08:51:19 <quicksilver> I don't find it particularly so.
08:51:22 <kallisti> well you can figure out what (f.).g without simply memorizing. So in some sense it's more clear, it's just more visually displeasing I think.
08:51:39 <quicksilver> no worse than the other arbitrary rules about the "precedence" of lambda and ->, anyhow.
08:52:36 <quicksilver> there is a cognitive load to work out where to place the corresponding "(" to the ".)." certainly.
08:52:47 <kallisti> quicksilver: qualified re-export possibly introduces new problems however, that need to be fixed by more fine-grained module control.
08:53:01 <quicksilver> but with ".:" that's replaced by the cognitive load of remembering the precedence of ".:" and whether or not you need () on either side of it.
08:53:19 <quicksilver> kallisti: problem worth solving though I think?
08:53:23 <kallisti> quicksilver: yes.
08:53:26 <jeff_s_> Always use (), that solves the cognitive load problem.
08:53:45 <amathew> ˜/jeff_s_ 11:52> Always use (), that solves the cognitive load problem. — words to live by
08:53:54 <mm_freak> i have an application that could make use of a parallel mapM, where the order of the results does not matter…  currently i'm creating an MVar and then do: replicateM (length xs) (takeMVar resultVar)
08:53:55 <quicksilver> then the choice is between ".)." and ").:("
08:54:04 <mm_freak> is there a package that provides such a parallel mapM out of the box?
08:54:08 <quicksilver> clearly ".)." is one fewer char! ;)
08:54:13 <mm_freak> btw, it's IO's mapM
08:54:24 * quicksilver thinks this horse now adequately flogged.
08:54:29 <ClaudiusMaximus> mm_freak: spawn has parMapIO iirc
08:54:56 <ClaudiusMaximus> though it might preserve order
08:55:20 <weexplat> quicksilver: itym ).).(
08:55:26 <mm_freak> ClaudiusMaximus: indeed, thanks
08:55:46 <mm_freak> well, preserving order wouldn't hurt too much…  it's just not needed
08:55:52 <quicksilver> weexplat: how dare you try to hold me to the rules of my own game? :)
08:56:14 <kallisti> quicksilver: more control over individual symbols could be interesting. import X.Y ( ExportedModuleSymbol as M, qualified z as B.z)
08:56:32 <kallisti> actually I'm not sure what the purpose of qualified is there.
08:56:35 <ronankde> Haskell supports gtk3?
08:56:43 <weexplat> Agda's module system can handle nested modules, so it can do this sort of thing
08:56:57 <quicksilver> kallisti: the main thing I want is to be able to set up interface helper modules which set up a conventional interface (even if that spans namespaces)
08:57:25 <quicksilver> and then for compositionality other things should be able to re-root that entire namespace
08:57:27 <kallisti> quicksilver: yes that would be good.
08:57:38 <quicksilver> so "FancyMap" exports "map" and "FM.T"
08:57:50 <quicksilver> if you want you can re-root that to "A.map" and "A.FM.T"
08:58:24 <kallisti> quicksilver: import LambdabotModules. ;)
08:58:37 <quicksilver> weexplat: these aren't really nested modules for any real semantic or lexical sense of nesting.
08:58:41 <quicksilver> weexplat: it's just playing with namespaces
08:58:53 <quicksilver> playing with names.
08:59:03 <quicksilver> kallisti: yes that's a better example actually.
08:59:06 <weexplat> quicksilver: i'm just saying nested modules are a big enough hammer
08:59:25 <quicksilver> I don't know what else they mean in agda
08:59:35 <quicksilver> I'm saying that hammer is unfamiliar to me, will it hurt? :)
08:59:44 <kallisti> quicksilver: but now that you've given the exporter more control I think an equivalent gain in import control should occur, so then the exported namespaces can be arbitrary renamed or unqualified.
08:59:52 <quicksilver> kallisti: yes I think that too.
09:00:24 <weexplat> well, modules in agda are about only two things: playing with names/namespaces and factoring out common sets of parameters
09:00:47 <kallisti> in fact I think you could use this as a principle when making changes to the module system.
09:00:48 <weexplat> as long as none of the modules are parameterized it's all just the first part
09:00:58 <quicksilver> weexplat: ok makes sense.
09:03:00 <kallisti> quicksilver: the symbol-level syntax would naturally support renaming arbitrary symbols, regardless of namespacing.  import X.Y (z as a)  for example.
09:03:27 * quicksilver nods
09:03:52 <kallisti> and then importing everything else as-is would probably be good:  import X.Y (z as a, ..)
09:04:04 <kallisti> you could probably go on endlessly about how to change the import list mechanic.
09:04:40 <quicksilver> import X.Y( /[a-z]+_new/ as new\1 )
09:05:15 <kallisti> ..yes! that will be in the upcoming -XRegexImportLists
09:06:34 <kallisti> quicksilver: I'm glad someone else noticed a distinct lack of the ability to import the rot13 equivalents of every exported symbol.
09:09:44 <kallisti> also can you embed TH into an import list? this feature seems like it would be in high demand.
09:10:09 <kallisti> (I could I guess you can just write TH for the whole import declaration)
09:13:29 <t7> can i infer the type arguements of a function if i know the type of what it is being applied to? (in system f)
09:14:44 <phao> hey
09:15:24 <phao> are there cases of games developped in haskell ? I want to get into game programming (simple stuff), and I like functional programming a lot. But never heard of FP + Game Dev together...
09:15:43 <geekosaur> @go haskell frag
09:15:44 <lambdabot> Maybe you meant: google googleit do
09:15:47 <geekosaur> bah
09:15:52 <Lemmih> phao: There's a snake game written in Haskell.
09:15:56 <geekosaur> @google haskell frag
09:15:58 <maloi> http://www.haskell.org/haskellwiki/Game_Development
09:15:58 <lambdabot> http://www.haskell.org/haskellwiki/Frag
09:15:59 <lambdabot> Title: Frag - HaskellWiki
09:16:00 <hpc> phao: monadius
09:16:03 <t7> Lemmih: lol
09:16:11 <drmegahertz> phao: check out nikki and the robots
09:16:19 <phao> thx
09:16:24 <geekosaur> anyway, a number of games, plus FRP is generally (although not always) targeting game development
09:16:28 <hpc> http://www.mobygames.com/game/windows/monadius -- it's even made it to mobygames, wow
09:20:27 <kallisti> I'm kind of surprised there's no function to convert a list into a mutable Vector.
09:21:30 <Lemmih> kallisti: Such things aren't usually done.
09:22:48 <t7> > fmap (+ 123) [1, 2, 3]
09:22:49 <lambdabot>   [124,125,126]
09:22:56 <OliverB> Perhaps someone should write to the mailing list and suggest the regex imports as a solution to record label namespacing :)
09:22:59 <t7> :t fmap
09:23:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:32:51 <t7> you will never design a language cooler than haskell :( (sad frog)
09:33:14 <t7> did kmc die or something?
09:34:31 <rostayob> preflex: seen kmc
09:34:31 <preflex>  kmc was last seen on ##c 3 days, 12 hours, 35 minutes and 57 seconds ago, saying: how so?
09:36:16 <edwardk> preflex: xseen gwern
09:36:17 <preflex>  gwern was last seen on freenode/#haskell 2 days, 23 hours, 4 minutes and 28 seconds ago, saying: @quote
09:49:52 <Mathnerd314> why doesn't freenode have a global seen feature?
09:50:11 <t7> donate cash or code :3
09:51:09 <t7> to be fair they could just add one more column to the users db that they allready have
09:51:38 <donri> there is /whowas :)
09:52:10 <quicksilver> I imagine it's because they don't want to, for privacy reasons
09:52:14 <quicksilver> not because it's hard to do.
09:52:36 <donri> doesn't nickserv do it already
09:52:43 <donri> or at least "last identified"
09:52:48 <quicksilver> last identified yes
09:53:03 <quicksilver> but it doesn't show what channels they were in and what they said
10:15:03 <Mathnerd314> :t (<>)
10:15:03 <lambdabot> Doc -> Doc -> Doc
10:16:25 <hpaste> Clint pasted “applicatives?” at http://hpaste.org/65619
10:16:37 <Clint> what's the best way to shorten that?
10:18:15 <Mathnerd314> :t \func2 func3 func4 func5 arg1 arg2 -> [func2, func3, func4,func5] <*> pure arg1 <*> pure arg2
10:18:16 <lambdabot> forall a a1 b. (a -> a1 -> b) -> (a -> a1 -> b) -> (a -> a1 -> b) -> (a -> a1 -> b) -> a -> a1 -> [b]
10:18:40 <Corey> Clint: Could pull some vowels: "Clnt pstd "applicatives?" @ http://hpaste.org/65619" maybe.
10:18:54 <Clint> thanks
10:18:59 <Corey> No worries. :-D
10:19:11 <parcs`> Clint: leave it the way it is
10:19:53 <Clint> ok
10:20:33 <Mathnerd314> Clint: what's the type of Construct?
10:20:57 <parcs`> @pl Construct firstval (f1 (f2 a b)) (f1 (f3 a b)) (f1 (f4 a b)) (f1 (f5 1 b))
10:20:57 <lambdabot> Construct firstval (f1 (f2 a b)) (f1 (f3 a b)) (f1 (f4 a b)) (f1 (f5 1 b))
10:21:17 <parcs`> @pl \f1 f2 f3 f4 f5 a b -> Construct firstval (f1 (f2 a b)) (f1 (f3 a b)) (f1 (f4 a b)) (f1 (f5 1 b))
10:21:20 <lambdabot> ap (flip . ((flip . ((flip . (((.) . flip . (ap .)) .)) .)) .) . ap (flip . ((flip . (((.) . liftM2 ap) .)) .) . ap (flip . (((.) . liftM2 (liftM2 (Construct firstval))) .) . (.) . (.)) ((.) . (.)))
10:21:21 <lambdabot> ((.) . (.))) ((. ($ 1)) . (.))
10:21:21 <Clint> Mathnerd314: it's basically data Construct = Construct Content Content Content Content Content
10:22:28 <Mathnerd314> and why do you need exactly 5 Content's?
10:23:04 <Mathnerd314> (or whatever the number is)
10:24:04 <Clint> Mathnerd314: it's 5 different representations of data for Yesod (to be chosen with an http Accept: header)
10:25:24 <Mathnerd314> so why not use some sort of function Data -> AcceptFormat -> ... ?
10:25:53 <nyingen> so I have a list of (String, Double) coming from an external library, and I need to filter the list based on the number, then pack the String component into Text. Should I just use filter, then map, or would it be faster to use mapMaybe?
10:26:55 <byorgey> nyingen: faster?
10:26:58 <nyingen> maybe it doesn't matter, but the function will be running quite often, so some time savings could be good
10:27:14 <byorgey> nyingen: the only way to know would be to benchmark it.
10:27:31 <nyingen> I just feel like traversing the list twice is bound to be worse performance-wise, but yeah I guess profiling is the only way to kno
10:27:34 <nyingen> w
10:27:35 <byorgey> nyingen: worrying about it now is almost certainly premature optimization
10:30:34 <Mathnerd314> you could look at the Core... offhand, I'd guess that GHC would fuse the map . filter into something like mapMaybe
10:31:30 <teneen> Are there parser libraries which use only applicative parsing?
10:31:43 <teneen> What readings are available on applicative parsing?
10:32:05 <c_wraith> I don't know if there are any that are *only* applicative.  Maybe some of the PEG parsers?
10:33:15 <teneen> c_wraith: OK, Are there any readings or material on applicative parsing?
10:33:36 <dmwit> There's the Duponcheel paper on arrow-based parsing.
10:34:02 <dmwit> Is there a reason you're so focused on parsers that only admit an applicative interface?
10:34:05 <ChristianS> nyingen: i would suppose that it doesn't matter. just write your function in a readable way and ghc should optimize it for you.
10:34:37 <teneen> dmwit: No, I just want to learn it.
10:34:39 <nathan28> hey all, i've got a noob question, but is there a content management system based on haskell?
10:34:59 <dmwit> teneen: Then look at the parsers that admit both applicative and monadic interfaces, but focus on the applicative interface.
10:35:06 <c_wraith> doaitse swierstra's paper on the design of uu-parsinglib is probably the best
10:35:13 <c_wraith> I can't find it at the moment
10:35:27 <c_wraith> but it's out there
10:35:35 <teneen> dmwit: Thanks. Which one should I start with?
10:35:57 <dmwit> Parsec is the archetypical Haskell parsing library.
10:36:02 <t7> will there ever be a dependantly typed language more popular than agda and coq? :(
10:36:18 <roconnor> t7: yes, epigram 2!!!
10:36:41 <t7> but... but... silly syntax
10:36:50 <teneen> dmwit: Where exactly is the applicative subset of parsec. I just get lost in it and could not differentiate what's monadic from what's applicative!
10:36:57 <roconnor> t7: epigram 2!!!
10:37:06 <dmwit> ?src Applicative
10:37:06 <lambdabot> class Functor f => Applicative f where
10:37:07 <lambdabot>     pure  :: a -> f a
10:37:07 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
10:37:08 <mauke> teneen: >>= is monadic
10:37:14 <mauke> teneen: <*> is applicative
10:37:21 <dmwit> teneen: "pure" and "<*>" are the applicative subset of parsec.
10:37:24 <dmwit> (?)
10:37:35 * dmwit isn't sure he understands what teneen is asking/wants
10:37:38 * hackagebot sundown 0.4.1.1 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.4.1.1 (FrancescoMazzoli)
10:37:40 * hackagebot bson-mapping 0.1.4.1 - Mapping between BSON and algebraic data types.  http://hackage.haskell.org/package/bson-mapping-0.1.4.1 (FrancescoMazzoli)
10:37:42 * hackagebot kyotocabinet 0.1.1 - Mid level bindings to Kyoto Cabinet  http://hackage.haskell.org/package/kyotocabinet-0.1.1 (FrancescoMazzoli)
10:37:51 <singpolyma> So, I see System.Directory.getDirectoryContents -- what if I want to find files matching some pattern in a directory (like a limited find command) -- is there a library for that?
10:37:56 <c_wraith> teneen: if you look at uu-parsinglib in detail, you will find that it uses entirely different internal constructs to implement the applicative and monadic interfaces.  Look at doaitse swierstra's paper about it
10:38:07 <quicksilver> c_wraith: I never knew that.
10:38:15 <teneen> dmwit: Yes, I'm talking about the predefined parser combinators. Which ones fall into which category?
10:38:25 <weexplat> singpolyma: use a filter on System.Directory.getDirectoryContents, maybe?
10:38:27 <mauke> teneen: none/none
10:38:30 <dmwit> teneen: none
10:38:55 <dmwit> teneen: The parser combinators (other than pure, (>>=), and (<*>)) are extra to the monadic/applicative interfaces.
10:38:56 <singpolyma> weexplat: well, I actually mean semi-recursively (ie the pattern   blah/*/thing)
10:39:14 <c_wraith> quicksilver: well, not completely different, I guess.  They have to know about each other. But they try to stay separate
10:39:36 <t7> roconnor: does it have the type classes?
10:39:49 <roconnor> umm
10:39:52 <bitonic> t7: epigram 2 has about everything
10:39:58 <teneen> dmwit: aha I see. As a side question, how is (<*>) used in parsing? I've seen uses (*>) and (<*), but I can't imagine (<*>).
10:40:01 <roconnor> t7: it has dependent records
10:40:10 <t7> oh no like agda?
10:40:13 <dmwit> ?src (*>)
10:40:13 <lambdabot> (*>) = liftA2 (const id)
10:40:15 <roconnor> t7: which is pretty much as good as type classes ^_^
10:40:17 <dmwit> ?src liftA2
10:40:18 <lambdabot> liftA2 f a b = f <$> a <*> b
10:40:26 <t7> roconnor: nope...
10:40:28 <dmwit> teneen: (*>) and (<*) use (<*>) =)
10:40:32 <t7> no way jose
10:41:06 <teneen> dmwit: Ok, quite embarrassing :)
10:41:21 <roconnor> t7: I guess you will want canonical structures, or more generally, unification hints.
10:42:55 <weexplat> singpolyma: oh, hm, FilePather has something (in System.FilePath.FilePather.Find)
10:43:27 <weexplat> singpolyma: http://hackage.haskell.org/package/FilePather
10:43:32 <byorgey> teneen: more directly, <*> can be used in parsing like  Constructor <$> fieldParser1 <*> fieldParser2 <*> fieldParser3
10:43:50 <byorgey> teneen: if the representations of the three fields for some constructor will be consecutive in the input
10:44:36 <teneen> byorgey: Ohh I see. Thanks for the clarification :)
10:45:35 <singpolyma> weexplat: cool, thanks!
10:46:08 <dino-> Anybody here working with the webkit library for gtk? Can't build it with: 'hswebkit.h: No such file or directory'
10:46:18 <dino-> message
10:47:40 <dino-> Otherwise, enough of Haskell gtk stuff installed to successfully build and run the Hello World app on the website.
10:47:57 <ybit> i'm looking for something similar to this for haskell: http://docs.python-requests.org/en/v0.10.7/index.html
10:47:59 <dino-> (which means, gth2hs-buildtools, gtk, pango, cairo, blah blah more stuff)
10:50:04 <dino-> ybit: Hm, wondering if curl would help with that. http://hackage.haskell.org/package/curl
10:50:37 <dino-> Anyone think libcurl is overkill for this? What would you use instead?
10:51:46 <ybit> nice suggestion, i like the questions as well
10:51:54 <ybit> i don't know enough to answer though
10:52:34 <dino-> ybit: Maybe just the HTTP lib: http://hackage.haskell.org/package/HTTP
10:52:42 <geekosaur> you're starting from webkit (a browser framework) and libcurl as alternative is overkill?
10:53:08 <geekosaur> (hswebkit.h missing sounds like a bug in the webkit package; just by its name, that's an internal header)
10:53:18 <dino-> geekosaur: No no, I'm asking about building webkit for hs2gtk for myself. And helping ybit find a library he needs. The two aren't related here.
10:53:37 <geekosaur> ah
10:53:57 <dino-> geekosaur: re hswebkit.h, ya, I see one other plea for help about this, 6 hours ago on the ML
10:55:09 <dino-> ybit: That looks maybe easier, more like what your Python link was about, the HTTP library I mean
10:57:40 <dino-> geekosaur: Looking at the webkit sources, I see hswebkit.h right in the root. Maybe installed improperly or not right include dir trying to use it now.
10:59:15 <random23> hello everybody. I wonder is it pos I wonder is it possible to pass somehow polymorphic function as function argument?sible to pass somehow polymorphic function as function argument?
10:59:19 <random23>  I wonder is it possible to pass somehow polymorphic function as function argument?
10:59:35 <mauke> yes, with rank>1 types
10:59:39 <random23> oops, sorry for doubleposting
10:59:49 <mauke> triple
11:00:25 <random23> mauke: Thanks i'll google it now
11:00:54 <gnoi> Is there any function like \(a,b) -> [a,b] &
11:00:55 <gnoi> ?
11:01:31 <mauke> gnoi: you just wrote it
11:01:50 <gnoi> Oh great!
11:02:20 <mauke> @pl \(a,b) -> [a,b]
11:02:21 <lambdabot> uncurry ((. return) . (:))
11:02:52 <magicman> @pl \[a,b] -> (a,b)
11:02:52 <lambdabot> (line 1, column 2):
11:02:52 <lambdabot> unexpected "["
11:02:53 <lambdabot> expecting pattern
11:03:51 <magicman> :t (,) <$> head <*> (head . tail)
11:03:52 <lambdabot> forall a. [a] -> (a, a)
11:04:09 <mauke> (!! 1)
11:04:23 <magicman> Point.
11:04:33 <t7> Could not find module 'System'
11:04:41 <t7> @Hoogle System
11:04:41 <lambdabot> Maybe you meant: google hoogle
11:04:41 <gnoi> Good for you
11:04:44 <bbhoss> Someone rip this apart for me: https://gist.github.com/75ce41b4dc2600cd926f
11:04:47 <geekosaur> System is obsolete
11:04:48 <t7> @hoogle System
11:04:48 <lambdabot> System.Process system :: String -> IO ExitCode
11:04:48 <lambdabot> System.Cmd system :: String -> IO ExitCode
11:04:48 <lambdabot> package system-argv0
11:05:07 <geekosaur> strict Haskell 98 used it; modern Haskell uses hierarchical modules
11:05:14 <t7> bummer
11:05:16 <bbhoss> I feel like all of those lets are wrong
11:05:23 <t7> epigram needs old haskell :(
11:05:46 <teneen> byorgey: How can I parse the concatenation of many strings? I used (++) <$> string s1 <*> string s2. But what if have more than two strings?
11:05:51 <bitonic> t7: btw, epigram 2 isn't actually more popular than agda and coq. it's unfinished and experimental
11:06:30 <geekosaur> it may be enough to add a dependency on the haskell98 package
11:06:43 <c_wraith> and remove a dependency on base
11:06:53 <c_wraith> since base and haskell98 are no longer compatible
11:07:03 <bitonic> t7: if you're getting started with dependently typed languages, epigram 2 is probably not the best choice (but I've never used it, so I can't be sure)
11:07:20 <t7> yeah i will stick to coq
11:07:33 <stepkut> t7: Agda perhaps?
11:07:41 <t7> agda doesnt have type classes
11:07:49 <stepkut> t7: thank goodness :p
11:07:50 <bitonic> t7: that's hardly a problem
11:08:02 <t7> how can i monad without type classes?
11:08:03 <bitonic> and you can emulate them using implicit parameters
11:08:08 <bitonic> t7: you can
11:08:28 <bitonic> also, you shouldn't worry about monads really
11:08:33 <Clint> Mathnerd314: how would that help?
11:09:18 <bitonic> t7: btw, monads have nothing to do with typeclasses. typeclasses just allow the overloading of >>= and return.
11:09:53 <stepkut> t7: (you probably have to manually set the page encoding to utf-8 to view this page) http://www.patch-tag.com/r/stepcut/agdabot/snapshot/current/content/raw/IRC.agda
11:10:12 <matthiasgorgens2> In a cabal file, if I put garbage into the extra-libraries field, is the build supposed to break?
11:10:14 <stepkut> t7: that is an example of a simple IRC parser using the StateT monad in agda
11:10:22 <byorgey> teneen: concat <$> mapM string [s1, s2, ...]
11:10:24 <matthiasgorgens2> or just complain but go ahead?
11:11:02 <teneen> byorgey: that's amazing, thanks!
11:11:32 <geekosaur> the problem with garbage there is it's mostly passed to ld, which will probably break the build
11:12:32 <danr> @pl \f h g x -> f (h x) (h (g x))
11:12:33 <lambdabot> (`ap` (.)) . (((.) . ap) .) . (.)
11:12:36 <t7> also agda relies so heavily on emacs, its very frustrating
11:12:43 <danr> @pl \f g h x -> f (h x) (h (g x))
11:12:44 <lambdabot> (. flip (.)) . ap . liftM2
11:12:54 <bitonic> t7: well, coq relies on a dedicated IDE...
11:13:02 <t7> true
11:13:11 <stepkut> t7: I'm ok with it
11:13:59 <dcoutts_> matthiasgorgens2: it should break
11:14:22 <dcoutts_> matthiasgorgens2: in fact it should break when you do cabal configure
11:14:37 <byorgey> bitonic: no it doesn't.
11:14:46 <byorgey> bitonic: Coq can be used in emacs as well.
11:15:20 <bitonic> byorgey: it does in the same way that agda relies on emacs
11:15:30 <matthiasgorgens2> dcoutts, thanks.
11:15:34 <bitonic> you don't *have* to use emacs to use agda
11:16:07 <bitonic> there's even vim highlighting for agda ehe
11:16:12 <byorgey> I see your point.  But I think in that case  Agda is to emacs as Coq is to emacs.
11:16:28 <byorgey> in particular proof general + emacs + Coq is MUCH nicer than CoqIDE.
11:17:41 <bitonic> ok, I haven't used coq much. still, with most theorem provers you don't have much choice for the environment.
11:17:54 <bitonic> at least coq has two apparently :P
11:18:01 <Younder> I can write innerProduct  = (sum .) . zipwith  (*) but not innerProduct = sum $ zipWidth (*). I apparently don't understand $. Can anyone explain why this doesn't work?
11:18:26 <aib> I like using tabs for indentation and spaces for alignment. But I suspect this won't work as well with Haskell as it does with other languages, because Haskell seems to have much more alignment than indentation. Am I right?
11:18:31 <bitonic> :t ($)
11:18:32 <lambdabot> forall a b. (a -> b) -> a -> b
11:18:36 <bitonic> :t zipWidth (*)
11:18:38 <lambdabot> Not in scope: `zipWidth'
11:18:48 <bitonic> :t zipWith (*)
11:18:49 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
11:18:53 <bitonic> :t sum
11:18:54 <lambdabot> forall a. (Num a) => [a] -> a
11:19:04 <bitonic> Younder: the types don't match.
11:21:11 <kyer> hello
11:22:14 <bitonic> kyer: hello
11:22:35 <t7> is there an agda changelog?
11:22:57 <bitonic> t7: yes, check the darcs repo
11:23:54 <bitonic> t7: http://code.haskell.org/Agda/doc/release-notes/
11:24:00 <bitonic> t7: btw, there is an #agda channel.
11:24:02 <byorgey> aib: correct.  The usual recommendation is to use only spaces in Haskell code.
11:24:48 <byorgey> aib: you should be able to configure Your Favorite Editor (tm) to convert tabs to spaces when editing haskell files.
11:26:17 <byorgey> Younder: ($) is just function application.  f $ x = f x.
11:26:26 <aib> byorgey: and is there a recommended indentation size? (this is the part I have problems with. with hard tabs for indentation, it's customizable per user)
11:26:33 <byorgey> Younder: so if  sum (zipWith (*)) doesn't make sense then neither does  sum $ zipWith (*)
11:26:34 <bitonic> aib: 4 spaces
11:26:48 <bitonic> aib: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
11:31:54 <aib> bitonic: that seems like a good point to start my style. thanks
11:32:14 <bitonic> aib: in general there is no "one style" in the haskell community. but that is gaining traction I think
11:32:17 <bitonic> I like it.
11:32:42 <dino-> Well, it's not a perm solution, but helped to manually cp hswebkit.h to /usr/local/include/
11:32:51 <aib> I'm not sure I like the [ x \n , y \n , z \n ] part
11:32:52 <dino-> well, manualy ln -s
11:33:04 <jeff_s_> I prefer 2 spaces, but maybe I'm bizarre. On the other hand, I don't prefer 2 so much more that I do the work of changing haskell-mode's defaults.
11:33:10 <bitonic> aib: actually there is a wide consensus on that.
11:33:14 <jeff_s_> Pattern matching is 2 spaces, anyway.
11:33:15 <bitonic> (commans on newlines)
11:33:53 <bitonic> *commas
11:34:37 <aib> in my view , is clutter and does not need to be aligned. aligned vertical [ and ] with only spaces in between them look better to me
11:35:15 <hpc> yeah, i think if a list needs to be aligned like that, it's already too long
11:35:27 <jeff_s_> , should be on the new line, so that removing an entry from the end of a list doesn't require editing the previous line.
11:35:39 <bitonic> aib: wait, you don't have to always put newlines.
11:35:40 <hpc> i also personally like two spaces of indent instead of 4, but that's just me
11:35:46 <hpc> also i don't use 'where'
11:35:51 <bitonic> but when the list is too long, you break it up like that
11:35:55 <monochrom> I like 1.99999 spaces
11:36:31 <jeff_s_> 1.99999 spaces would work if the GHC parser could read source from ps or pdf files.
11:36:51 <hpc> jeff_s_: haha
11:37:10 <aib> I don't mind editing 2 lines just to remove 1 item from a list. my lists don't tend to change that much, anyway.
11:37:16 <monochrom> as long as commas are required between items and required to be absent elsewhere, you will always have a problem with adding or removing the beginning item or the ending item
11:37:43 <aib> there's that too
11:37:59 <hpc> that's why you don't write enormous lists in-code
11:38:04 <jeff_s_> Some programming languages allow a trailing ,.
11:38:09 <aib> I'm personally in love with using tabs+spaces, I wonder if I can carry that over to Haskell code
11:38:25 <c_wraith> aib: no, that will break everything.  constantly.  as it should.
11:38:26 <hpc> aib: it will be hard, and people will hate you for it
11:38:26 <monochrom> contrast with the {;} notation: both { ; m ; n } and { m ; n; } are allowed.
11:38:43 <hpc> but you can do it if you don't mind losing all the flexibility GHC's alignment rules give you
11:38:53 <aib> c_wraith: hpc: but what you say applies _only_ to Haskell, right? you wouldn't make the same argument for C or Python?
11:38:58 <bitonic> aib: spaces and tabs are ugly :(
11:39:02 <mightbereptar> I'm a mathematician trying to get into programming, would Haskell be a good language for this?
11:39:10 <bitonic> aib: actually the C code in GHC is tabs + spaces, so irritating :P
11:39:22 <bitonic> mightbereptar: yes. you'd be surrounded by people like you.
11:39:22 <hpc> for python, i would make the argument of "don't use python", i think
11:39:25 <mightbereptar> (I'm after your opinions)
11:39:30 <monochrom> you can use tabs+spaces as long as you know what the Haskell Report says about tabs
11:39:31 <c_wraith> aib: it will break python quite a lot, too. And really, I think tab characters should be lexical errors in all programming languages.
11:39:32 <hpc> because counting the levels of indentation is so much more important
11:39:33 <bitonic> which might be ood or bad
11:39:36 <jeff_s_> mightbereptar: It would probably be the best language for you.  Look up the book, The Haskell Road to Logic and Math.
11:39:37 <t7> mightbereptar: yes
11:39:41 <hpc> and so much less obvious from the content of the code itself
11:40:00 <jeff_s_> mightbereptar: http://homepages.cwi.nl/~jve/HR/
11:40:12 <monochrom> C couldn't care less about tabs and spaces
11:40:43 <aib> yep :) I'm still not sure about Python.. what with being indent-sensitive and all
11:41:09 <aib> I just like it when someone can adjust tab size AND when all the bits line up properly.. that's why I use tabs+spaces
11:41:11 <bitonic> in general tabs are nasty imho... tabs are useful too format ascii data and stuff like that
11:41:13 <bitonic> but not code
11:41:30 <nyingen> aib: tab-laden code is a good way to troll this channel
11:41:30 <bitonic> *to format
11:41:56 <monochrom> well, someone people view code as ascii data, too
11:41:57 <aib> I disagree with that part. almost every ASCII tabulated text I've seen breaks because one line has an item >8 chars or <16 or something like that
11:41:58 <c_wraith> aib: why do you need to adjust tab size?  Why not just indent things reasonably in the first place?
11:42:44 <jeff_s_> mightbereptar: On the other hand, if you want to do things that are more like a turing machine and less like algebra, there might be better languages for you out tehre.
11:43:00 <kallisti> aib: I assume you're talking about all /monospace/ tabulated text.
11:43:28 <mightbereptar> Thanks everyone :)
11:43:29 <donri> -fwarn-tabs :)
11:43:44 <c_wraith> Tabs made sense on typewriters. Keeping them around after that was a mistake.
11:44:03 <hpc> c_wraith: they did?
11:44:03 <donri> BTW if someone misunderstood I think aib means "tabs for indentation and spaces for alignment", duno how well that works in Haskell but it's not as problematic as randomly mixing tabs and spaces.
11:44:28 <aib> yeah. I told that earlier, but thanks for the recap
11:44:33 <donri> oh :)
11:44:35 <hpc> donri: technically, everything in haskell is alignment, so tabs + spaces = spaces
11:44:53 <donri> i guess you have a point there
11:44:53 <aib> I suspected it doesn't work as well in Haskell. I think I'm right.
11:44:59 <c_wraith> hpc: yes, absolutely.  They moved the carriage to the next hardware tab stop.  fancier typewriters even had multiple user-settable tab stops.
11:45:10 <hpc> oh right, tab stops
11:45:14 <c_wraith> hpc: but the reason they made sense was that tabs are a shortcut for *output*
11:45:23 <t7> or you can use python style: only tabs. But not when editing others source files
11:45:37 <aib> editing others' source files -> use their style
11:45:40 <donri> FWIW I like to use two spaces, but four after bindings
11:46:00 <jeff_s_> Just make things easy for yourself and use the haskell-mode defaults. (If you're using emacs...)
11:46:17 <t7> im using vim you insensitive clod
11:46:20 <donri> t7: python's recommended style is four spaces
11:47:54 <jeff_s_> Just make things easy for yourself and use the haskell-mode defaults. (If you're using emacs...)
11:48:03 <jeff_s_> Oops, sorry. THat was supposed to happen on a terminal.
11:50:46 <applicative> mightbereptar: http://blog.sigfpe.com/2006/01/eleven-reasons-to-use-haskell-as.html
11:53:15 <aib> is there a countOccurences :: Eq a -> a -> [a] -> Int function built-in?
11:53:46 <jfischoff> What is the equivalent of a groupiod for a Kleisli category? Basically I want to represent every f :: a -> m b has a g :: b -> m a.
11:55:45 <copumpkin> aib: no, but you can filter and take the length of that
11:56:32 <copumpkin> jfischoff: I don't think anything stops your kleisli category from being a groupoid, but I'm not sure what monads would lead to it being one
11:56:39 <teneen> How can you parse the negation of a parser in Parsec?
11:56:55 <applicative> jfischoff: could a function possibly have that type, without a trivializing monad
11:57:33 <teneen> I mean all possible strings which are not in the language that that particular parser accepts?
11:57:41 <edwardk> teneen: notFollowedBy
11:58:32 <teneen> edwardk: Thanks!
11:59:00 <norton-> Hi, how's project euler for practising programming with Haskell for a new learner?
11:59:12 <jfischoff> copumpkin: Yeah, I guess I was your right. I was confusing my self because the input and output were different types, but I guess it is just a groupoid.
11:59:14 <tgeeky> norton-: interesting, but difficult at times
11:59:20 <copumpkin> norton-: the first few might help you, but after a while they're not going to help you with haskell
11:59:24 <tgeeky> norton-: however, solutions are out there in github repositories and all
11:59:37 <edwardk> jfischoff: its going to be pretty boring. e.g. that you have the identify functor on a groupoid, or ran id id
11:59:40 <copumpkin> jfischoff: well, I don't think there are any interesting monads that would lead to a groupoid kleisli category
11:59:59 <edwardk> jfischoff: or the trivial monad ;)
12:00:07 <alpounet> norton-, you'll most likely learn a lot but also be confronted (bitten by? :P) to some specificities of Haskell there
12:00:52 <jfischoff> The use case is for a bidirectional composition of functions that can have errors
12:00:58 <monochrom> project euler is a great way to practice brute-force algorithms
12:00:58 <tgeeky> norton-: that's a better idea for your math skills, rather than your Haskell skills. Try the exrecises in Real World Haskell
12:01:09 <jfischoff> thing a -> Maybe b or a -> Either String b
12:01:14 <tgeeky> monochrom: where you're the brute, and you force yourself to make algorithims? :o
12:01:45 <monochrom> and then complaining that Haskell isn't smart enough to transform brute-force algorithms to fast ones
12:02:00 <monochrom> like any compiler is obliged to
12:02:16 <edwardk> jfischoff: ah so 'partial isomorphisms', etc.
12:02:23 <jfischoff> yep
12:02:36 <norton-> tgeeky: I see, thanks for the recommendation, I'll read it and try the exercises.
12:02:38 <monochrom> and also practicing unfair comparisons between ghc*I* performance with gcc-generated-code performance
12:02:39 <tgeeky> so it occured to me a few minutes ago... many of us use and like cabal-dev in place of cabal... a nice enhancement would be to use hackage reverse deps to decide to pre-install ones with many reverse deps with 'cabal' before installing them locally
12:02:49 <tgeeky> @hoogle RWH
12:02:50 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
12:02:52 <tgeeky> err
12:02:53 <norton-> Thanks to alpounet and copumpkin too!
12:02:59 <edwardk> well, you can compose isomorphisms in the kleisli category, but you can't work with it as a monad, the context sensitivity screws you
12:03:01 <tgeeky> @google RWH
12:03:04 <lambdabot> http://www.rwhtrucking.com/
12:03:04 <lambdabot> Title: RWH Trucking, Inc.
12:03:08 * tgeeky kills himself
12:03:12 <norton-> :P
12:03:29 <tgeeky> so... re: cabal-dev idea, good?
12:03:40 <jfischoff> It think that is okay, I only need composition.
12:04:14 <Saizan> tgeeky: sounds like it would defeat the point of cabal-dev
12:04:40 <jfischoff> I'm trying some reversible bidirectional programming, but I need better errors then just Maybe, I want Either String atleast
12:05:12 <alpounet> tgeeky, you probably wanted to do "@where rwh" :p
12:05:24 <tgeeky> Saizan: a little, yes, but there are so few packages that have more than 2 or 3 rdeps, and it's a pretty simple optimization
12:05:36 <tgeeky> Saizan: I think I mean 'cabal Prime' not cabal-dev
12:05:50 <tgeeky> Saizan: I assume 'cabal prime' will have nearly identical cabal-dev kind of functionality (sandboxing)
12:06:00 <tgeeky> @where RWH
12:06:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:06:09 <tgeeky> alpounet++
12:06:13 <dino-> Hm, I just tried to email a bug report for that webkit thing to the email listed in the .cabal file, gtk2hs-users@sourceforge.net, and it bounced back. Unknown user.
12:06:19 <tgeeky> cheapest karma ever
12:06:20 <dino-> Email listed in the webkit project .cabal
12:06:35 <tgeeky> dino-: talk to 'dmwit' in here
12:06:39 <tgeeky> i think?
12:06:55 <dino-> btw, that webkit control is smokin fast.
12:07:23 <tgeeky> dino-: wrong person.
12:07:48 <tgeeky> dino-: e-mail Duncan Coutts, and let him know the mailing list isn't working
12:07:52 <alpounet> tgeeky, what problem would your idea solve? Having a "local ecosystem" (local meaning wrt a given group of packages) that's compatible?
12:08:22 <tgeeky> alpounet: yep, reducing unnecessary duplicate compiles
12:08:30 <dino-> tgeeky: Will do, thank you
12:08:49 <tgeeky> alpounet: i want the unsuccessfully-compiled attempts to be duplicated as much as necessary, but once something is successfully compiled, I want to share it
12:08:52 <adnauseam> alo, an elementary question about functors. in Learn you a haskell, the chapter "functors, applicative functors and monoid", there's this definition: instance Functor IO when fmap f action = do etc...
12:09:26 <tgeeky> alpounet: actually, a simple idea might be just to invent a utility that takes a working cabal-dev package and promotes it into ghc-pkg --user space
12:09:30 <adnauseam> the part of "fmap f action " do i imagine that f is being replaced by IO and that it's given to fmap as such ?
12:09:40 <adnauseam> sorry if this doesn't make sense..
12:09:51 <tgeeky> adnauseam: don't apologize for learning.
12:10:12 <monochrom> but it doesn't make sense :)
12:10:19 <adnauseam> ;p
12:10:32 <adnauseam> hrm, i'll try to retthink the question
12:10:41 <applicative> adnauseam: fmap f ioaction performs the same action, but applies f to the result it returns
12:11:05 <monochrom> it is not like fmap f [1,2,3] is "f is replaced by []"
12:11:07 <t7> holy shit the distance between each step in the Fibonacci seq is the Fibonacci seq... mind blown
12:11:19 <qued_____> What's the difference between: [Char] and String ?
12:11:28 <monochrom> no difference
12:11:29 <nyingen> hm, this is odd. I have a hs file (implementing a thrift server) which works in ghci, but produces linker errors if I try to compile it
12:11:37 <hpc> > length "[Char]" - length "String"
12:11:39 <lambdabot>   0
12:11:43 <hpc> qued_____: nothing
12:11:47 <monochrom> haha cunning
12:11:54 <tgeeky> hpc: I was going to say, the length of the string, but then I waited, luckily
12:12:09 <hpc> @src String
12:12:11 <lambdabot> type String = [Char]
12:12:27 <adnauseam> hmm, so the functor with its initial definition of fmap is first applied to []\or IO, then f is a function that's given which is then also applied\returned ?
12:12:32 <Saizan> adnauseam: the f as argument to fmap is not the f type variable that's used as the argument of Functor in its declaration
12:12:37 <qued_____> hpc: and why ghci differentiate both?
12:12:54 <t7> > readMay "[Char]" :: String
12:12:55 <lambdabot>   Not in scope: `readMay'
12:12:55 <alpounet> tgeeky, i'm actually working with another person on something that would *help* solving dependencies hell but waaay upfront in the process, that is at dev. time
12:12:59 <t7> damn
12:13:00 <hpc> qued_____: it... doesn't - at least not in any place that matters
12:13:24 <adnauseam> hrm, it's clearing up abit... lets hope more reading will help clear up the fog even more
12:13:25 <tgeeky> alpounet: there seem to be a lot of conversations going on about cabal-prime.
12:13:27 <alpounet> (among other things, that's not the main goal)
12:13:31 <roconnor> I found a neat trick in Data.Fixed yesterday:  class HasResulotion a where resolution :: f a  -> Integer
12:13:33 <tgeeky> alpounet: is there leadership here?
12:13:47 <hpc> ":t" and stuff will give different answers for different things, but that's just a side effect of type aliasing
12:13:48 <alpounet> tgeeky, well, that's not really an in-cabal thing, but kind of revolves around it
12:13:51 <qued_____> okay, thanks
12:13:58 <hpc> there's also 'type FilePath = String'
12:14:00 <hpc> :t readFile
12:14:01 <lambdabot> FilePath -> IO String
12:14:03 <roconnor> works for any type constructor f!
12:14:21 <tgeeky> alpounet: yeah, and I do understand that tendency (cabal-dev, cabal-nirvana, etc, etc, etc) but at some point, we might want to admit that everyone that uses haskell should be using whatever innovations we make in packaging
12:14:23 <hpc> > readFile "/etc/passwd"
12:14:26 <lambdabot>   <IO [Char]>
12:15:03 <hpc> roconnor: wait, what
12:15:39 <hpc> oh, that's silly
12:16:03 <hpc> f will always be Fixed in that module
12:16:11 <alpounet> tgeeky, well, that's not just some kind of workaround, but rather a build-bot
12:16:40 <tgeeky> alpounet: yeah. but we're mature enough now to suggest that all building might be done by a continuous integration system :o
12:16:46 <tgeeky> alpounet: we'll see.
12:17:07 <tgeeky> alpounet: cabal is, for better or worse, one of the biggest barriers to entry for noobs
12:17:14 <alpounet> yeah
12:17:29 <tgeeky> it's also utterly indespensible for the rest of us, as is
12:17:50 <alpounet> i talked about the hypothetical continuous integration system hackage2 would have with duncan, and how it could be related to the project i'm working on
12:18:13 <tgeeky> alpounet: are you developing publicly? github?
12:18:15 <alpounet> there's much to say, to share and to tackle about these stuffs...
12:18:47 <roconnor> hpc: nope, f a is never used by resolution.  resolution produces a constant.
12:19:08 <tgeeky> alpounet: http://travis-ci.org/ <-- that supports haskell now
12:19:24 <hpc> roconnor: i mean, at the type-level f is always Fixed
12:19:28 <hpc> in how it's being used
12:19:48 <hpc> you're not going to see it called with f = [] or f = Maybe
12:19:50 <roconnor> tgeeky: http://hydra.nixos.org/ <- also supports haskell.
12:20:00 <hpc> and it's just polymorphic for lulz
12:20:16 <roconnor> hpc: ah I see what you mean
12:20:29 <roconnor> hpc: no it is polymorphic to "prove" the function is constant.
12:22:42 <Franciman_> hey people, why in functional programming trees are cheaper to update?
12:23:08 <monochrom> that is too general
12:23:12 <Franciman_> ( I read that hashtables would not be good in FP as they are in Imperative programming since they must be copied always)
12:23:20 <hpc> roconnor: ah, also that
12:23:52 <monochrom> if you read it from someone, ask that someone.
12:23:53 <Franciman_> how are usually trees updated?
12:24:04 <roconnor> hpc: actually I hadn't noticed the function works for Fixed a inputs
12:24:11 <Franciman_> I mean add new Nodes
12:24:18 <roconnor> hpc: I figured the whole point was to prove that the function was constant.
12:24:30 <roconnor> hpc: but that it does work for Fixed a seems like it might be convienent
12:24:39 <hpc> roconnor: yeah, you would do "resolution 5" and get the precision of the number
12:24:48 <timthelion> I'm trying to learn how to compile and load modules dynamically from example.  But in looking through XMonad's code, there is no reference to ghc except in the comments(as far as I can tell)
12:24:50 <roconnor> > resolution 5
12:24:53 <lambdabot>   No instance for (GHC.Num.Num (p a))
12:24:53 <lambdabot>    arising from the literal `5' at <int...
12:24:58 <roconnor> > resolution (5 :: Fixed E3)
12:24:59 <lambdabot>   1000
12:25:01 <hpc> oh, and now i see EXACTLY why the 'f' is making it constant
12:25:11 <hpc> it doesn't even allow pattern matching on the 'a'
12:25:14 <sclv> xmonad doesn't do dynamic loading as i recall
12:25:18 <sclv> it used to a long time ago
12:25:20 <roconnor> hpc: right
12:25:23 <sclv> but now it just restarts
12:25:24 <hpc> clever
12:25:26 <roconnor> hpc: f could be Const Void
12:25:48 <timthelion> sclv: it does just restart.  But even that would be enough for me.  I still don't see how it compiles itself.
12:25:49 <hpc> > resolution (undefined :: Const Void E3)
12:25:51 <lambdabot>   Not in scope: type constructor or class `Void'
12:25:54 <hpc> :(
12:27:04 <roconnor> > resolution (undefined :: Const (Mu Identity) E3)
12:27:04 <lambdabot>   1000
12:27:43 <kallisti> Franciman_: the problem with an immutable hash table is that updating a single element requires a copy of the entire array (assuming there's no magic in the implementation of immutability.)  In general, trees are constant time to update a node (though the picture is more complicated if you look at specific algorithms)
12:27:48 <mhitza> timthelion, because it doesn't load dinamically any code. It exports the xmonad function upon which you apply customization
12:27:49 <roconnor> hpc: ... good thing we don't have type-level beta-reduction
12:28:02 <sclv> timthelion: http://hackage.haskell.org/packages/archive/xmonad/0.10/doc/html/src/XMonad-Core.html#recompile
12:28:02 <hpc> roconnor: haha, indeed
12:28:05 <kallisti> Franciman_: but it doesn't mean that an immutable hash table is unsuitable for functional programming. Implementations exist.
12:28:13 <Franciman_> kallisti, yes
12:28:22 <Franciman_> I meant that trees perform better in this case
12:28:25 <qued_____> Any rule when to define funktions pointwise and when not? pointwise def is only needed if the function is depending on input?
12:28:28 <Franciman_> but how is it possible
12:28:33 <Franciman_> that trees update in constant time
12:28:33 <Franciman_> ?
12:28:41 <Saizan> mhitza: it does recompile itself if you hit meta-q and the xmonad.hs changed
12:28:48 <Saizan> mhitza: but just calling out to ghc
12:28:50 <Franciman_> do not I have to copy the whole struct as well?
12:29:00 <teneen> Is monadic parsing slow? as mentioned here http://carlo-hamalainen.net/blog/2011/02/11/parsing-with-monads-can-be-slow/
12:29:09 <teneen> Does this apply to parsec and attoparsec?
12:29:16 <kallisti> qued_____: there's not really a hard rule. If the expression is a simple chain of functions then I typically convert it to pointfree if possible.
12:29:18 <sclv> timthelion: also this packages up the xmonad-style reloading pattern http://hackage.haskell.org/package/dyre
12:29:37 <timthelion> thank you
12:30:00 <Saizan> teneen: have you read the first paragraph?:)
12:30:16 <mhitza> Saizan, I tought the question was about it dinamically loading code; as in plugins, or what not
12:30:54 <monochrom> wow, people really like to take an article not written by us, and ask us "is it true?"
12:30:54 <teneen> Saizan: yes?
12:31:12 <timthelion> monochrom: who is us?
12:31:20 <monochrom> AFAIK the only profession that does that is news reporters, not programmers
12:31:25 <monochrom> #haskell people
12:31:41 <kallisti> qued_____: it's just a question of readability vs. conciseness, which are ultimately subjective human qualifications. I'm sure a few rules of thumb exist but I couldn't list them all.
12:31:53 <roconnor> presumably monadic parsing can be as slow as context-senstive parsing.
12:32:02 <monochrom> "Hey Mr. Obama, Ronney said so and so, is that true?"
12:32:35 <monochrom> my answer would be "why don't you press Ronney to justify what he says"
12:32:37 <timthelion> monochrom: there is nothing wrong with asking a 3rd party to audit the facts of a seccond.
12:32:42 <kallisti> Franciman_: it's much like how you can prepend an element to the front of a linked list.
12:33:03 <kallisti> but it depends on what you mean by "tree" and "insert." :P  not all trees are implemented the same way.
12:33:08 <nyingen> why would some code that uses a FFI binding work in ghci with no special switches, but cause linker errors when I try to compile it normally?
12:33:09 <kallisti> the simplest ones work similarly to linked lists, however.
12:33:14 <Franciman_> well binary tree
12:33:15 <monochrom> oh sure, that's the profession of news reporters, nothing wrong with news reporters
12:33:21 <timthelion> monochrom: like, when I ask a plumber to give me an estimate, I might ask a friend if the price is reasonable.
12:33:33 <hpc> monochrom: "Romney said so and so, is that true?"
12:33:38 <hpc> monochrom: "yes, he did indeed say that"
12:33:40 <Franciman_> kallisti and is it also constant time to insert into a linked list?
12:33:47 <kallisti> to the beginning, yes.
12:33:56 <jeff_s_> I feel kind of dumb, since I just did this with EitherT. How do I turn a Maybe value into a MaybeT value?
12:34:04 <Franciman_> but the copy must still happen
12:34:05 <Franciman_> I mean
12:34:19 <kallisti> it's not necessary that it copy.
12:34:23 <kallisti> a naive implementation would copy, yes.
12:34:27 <Franciman_> how?
12:34:27 <k0ral> hi, is there an easy way to translate every special character like 'é', 'è', 'ê', into its equivalent 'e' ?
12:34:30 <kallisti> GHC is not a naive implementation of Haskell.
12:34:52 <hpc> jeff_s_: pretty much the same way, with different handling for Left/Nothing
12:35:04 <Franciman_> kallisti, so it's compiler's magic?
12:35:17 <kallisti> I wouldn't even say it's magic really.
12:35:20 <hpc> jeff_s_: imo, it's a flaw that mtl doesn't provide a class method for that kind of lift
12:35:38 <kallisti> Franciman_: if you think of Haskell values as being represented by pointers, then the cons operation is just sticking two pointers together...
12:35:41 <c_wraith> k0ral: maybe in big language-processing libraries.  there are some NLP libs available for haskell.  But calling 'e' "equivalent" is a misrepresentation of what's really going on
12:35:58 <Franciman_> yes
12:36:00 <hpc> k0ral: OCR with the sensitivity turned way down?
12:36:02 <teneen> quit
12:36:13 <geekosaur> actually, you want a binding to ICU or similar library
12:36:13 <hpc> see also the thing about them not being equivalent
12:36:21 <k0ral> c_wraith: in my application it is really important
12:36:33 <qued_____> kallisti: thanks ;)
12:36:35 <kallisti> Franciman_: if you really want to dive into how GHC works, then I could link you some papers. :D
12:36:44 <k0ral> c_wraith: misrepresentation maybe, but I want it
12:36:45 <c_wraith> k0ral: then look at NLP libraries.
12:36:46 <Franciman_> if you can :D
12:36:51 <Franciman_> that'd be great
12:37:00 <k0ral> hpc: very funny :)
12:37:07 <mhitza> k0ral, I think you can find transliteration possible with http://hackage.haskell.org/packages/archive/iconv/0.4.0.2/doc/html/Codec-Text-IConv.html
12:37:29 <mhitza> k0ral, don't know how but when you google haskell transliteration it shows second in the mailing list with no example
12:38:27 <kallisti> Franciman_: it's a bit outdated with how GHC actually works nowadays, but http://research.microsoft.com/pubs/67083/spineless-tagless-gmachine.ps.gz is a good starting point.
12:38:44 <k0ral> mhitza: looking at that, thank you
12:38:53 <Franciman_> great, thanks
12:39:27 <kallisti> Franciman_: in particular "update frames" might be of interest to you.
12:39:53 <Franciman_> yeah thanks again
12:40:37 <mhitza> k0ral, if you have any knowledge with iconv it should be straightforward. Usually you just have to convert from your encoding to "ASCII//TRANSLIT", but never used this library so I wouldn't be able to give you an example translated to haskell
12:41:49 <k0ral> that doesn't sound really clean
12:42:20 <k0ral> I guess translating to ascii will remove accents as a side effect, but in the end I'll have to translate it back
12:42:59 <mhitza> k0ral, can't you keep a reference on the initial data while working with the transliterated variant/
12:43:16 <kallisti> it would be interesting if Haskell's function declaration syntax supported cases with differing numbers of arguments.
12:43:42 <kallisti> handler (MyException s) = return (); handler = throwError
12:44:08 <k0ral> mhitza, yes I can, but I'm more looking for a f :: Char -> Char which is id everywhere except on characters with accents
12:44:32 <kallisti> but that's objectionable on several accounts.
12:47:29 <geekosaur> k0ral, another question is how widely you expect that to be usable.  Char -> Char won't work if it uses a Unicode combining character, for eample
12:48:07 <k0ral> Unicode combining ?
12:48:55 <hpc> http://hpc.dyndns-web.com:8000/thirdparty/unicode.html -- search for combining
12:50:26 <k0ral> oh
12:50:51 <hpc> kallisti: you can kind of do that
12:51:06 <k0ral> you mean unicode is using a couple of characters to represent characters with accents ?
12:51:23 <hpc> > let revAnd x False = False; revAnd = const in revAnd True False
12:51:24 <lambdabot>   Equations for `revAnd' have different numbers of arguments
12:51:24 <lambdabot>    <interactive>...
12:51:32 <hpc> oh... you can't :(
12:51:48 <hpc> :t let revAnd x False = False; revAnd = const in revAnd
12:51:50 <lambdabot>     Equations for `revAnd' have different numbers of arguments
12:51:50 <lambdabot>       <interactive>:1:4-25
12:51:50 <lambdabot>       <interactive>:1:28-41
12:52:03 <hpc> :t let revAnd x False = False; revAnd x y = const x y in revAnd
12:52:04 <lambdabot> Bool -> Bool -> Bool
12:52:28 <k0ral> why is cabal recompiling gtk while I already have it compiled and installed
12:52:29 <k0ral> ?
12:53:02 <k0ral> it's been weeks now that I can't compile my project using gtk
12:53:12 <jeff_s_> k0ral - what version do you have installed, and what version does the project require?
12:53:37 <hpaste> “Jeff Shaw” pasted “Maybe to MaybeT mistake” at http://hpaste.org/65633
12:53:49 <jeff_s_> What should line 7 be? I feel like I'm missing something very obious.
12:53:52 <jeff_s_> obvious*
12:54:16 <hpc> @unmtl MaybeT m a
12:54:17 <lambdabot> m (Maybe a)
12:54:24 <hpc> :t return Nothing
12:54:25 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a)
12:54:27 <donri> roconnor: hey would MonadReader helpers make sense in data-lens-fd or should they go somewhere else? i have for example this http://hpaste.org/65632
12:54:32 <hpc> :t return (Just undefined)
12:54:33 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a)
12:54:37 <hpc> :t MaybeT
12:54:38 <lambdabot> Not in scope: data constructor `MaybeT'
12:54:52 <hpc> @src MaybeT
12:54:53 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:54:54 <k0ral> jeff_s_: gtk 0.12.3 installed, the project doesn't mention any version requirement, just "gtk"
12:55:08 <hpc> jeff_s_: in any event, you need to use the constructor for MaybeT
12:55:57 <jeff_s_> hpc - on line 7?
12:56:35 <hpc> MaybeT :: m (Maybe a) -> MaybeT m a
12:56:49 <hpc> return . Just :: a -> m (Maybe a)
12:56:56 <hpc> return Nothing :: m (Maybe a)
12:57:03 <roconnor> donri: I think a function of type MonadReader r m => Lens r t -> m t would make more sense
12:57:21 <hpc> that should be all the functions you need to define liftMaybe :: Maybe a -> MaybeT m a
12:57:31 <mightbereptar> Why would you ever use 'let' in this way (from tryhaskell): let square x = x * x in square 3
12:58:05 <donri> roconnor: I use it with acid-state+ixset like this: getPaste k = pastes %. fmap snd . getOne . getEQ k
12:58:14 <mightbereptar> I don't see the benefit of defining the function in the let and using it only once
12:58:34 <donri> roconnor: not sure how your type is more useful?
12:58:38 <copumpkin> mightbereptar: to demonstrate how let works?
12:58:39 <hpc> mightbereptar: you wouldn't do that, but just because it's so simple
12:58:55 <hpc> also what copumpkin said
12:59:49 <donri> roconnor: the idea is that %. is like %=, not ~=
13:00:04 <donri> roconnor: I suppose a ~. could work too?
13:00:07 <k0ral> is anyone able to compile hbro-contrib ?
13:00:33 <donri> no wait that doesn't make much sense
13:00:45 <k0ral> I'm getting "depends on deepseq-1.3.0.0 which failed to install" while deepseq is correctly installed
13:00:52 <k0ral> this doesn't make any sense
13:01:07 <roconnor> donri: I might write that as getPaste k = fmap snd . getOne . getEQ k <$> asks (getL pastes)
13:01:09 <donri> roconnor: I also have askL = asks . getL
13:01:26 <roconnor> okay then
13:01:34 <roconnor> donri: I might write that as getPaste k = fmap snd . getOne . getEQ k <$> asksL pastes
13:01:54 <donri> hm I think that got me ambiguous infix ops because of trhsx or something
13:02:27 <roconnor> donri: I kinda don't like excessive use of infix character noise. so I would be hesitant to add more.
13:02:31 <donri> any particular reason to not have %. as a helper too, then?
13:02:35 <donri> OK
13:02:44 * hackagebot pipes 1.0.2 - Compositional pipelines  http://hackage.haskell.org/package/pipes-1.0.2 (GabrielGonzalez)
13:03:03 <roconnor> donri: of course, please feel free to use it yourself in your project
13:03:14 <roconnor> donri: I'll keep your suggestion in mind.
13:03:43 <roconnor> donri: it isn't totally unreasonable.
13:03:46 <hpaste> koral pasted “Compilation failure” at http://hpaste.org/65634
13:03:47 <donri> I was mainly wondering if I should send you a patch for them
13:04:55 <donri> I find that a lot of acid-state queries fit (%.), and they'd be more verbose without it
13:05:09 <roconnor> donri: interesting
13:05:15 <donri> oh hey new pipes
13:06:04 <roconnor> sometimes I wish haskell had implicit coercion, to covert Lenses into projections.
13:06:13 <roconnor> though I sort of fear what that might entail.
13:07:05 <donri> for the curious, http://hdiff.luite.com/cgit/pipes/commit?id=1.0.2
13:07:19 <donri> luite++
13:07:42 <roconnor> donri: do you use (^.) ?
13:07:53 <donri> yep
13:07:58 <jeff_s_> hpc - turns out it requires MaybeT . return.
13:08:05 <roconnor> I really need to make a new release of data-lens
13:08:14 <roconnor> I'm going to change the associativity of (^.)
13:08:19 <roconnor> since the current way is wrong
13:08:26 <donri> aha
13:08:46 <donri> haven't used it complexively enough to run into problems
13:09:09 <donri> i need to figure out how to fix data-lens-ixset too, which is hard because i don't completely understand how it's broken in the first place
13:09:10 <hpaste> “Jeff Shaw” annotated “Maybe to MaybeT mistake” with “Maybe to MaybeT mistake (annotation)” at http://hpaste.org/65633#a65635
13:09:32 <jeff_s_> That is really ugly looking.
13:09:33 <roconnor> donri: if it makes you feel better, from what I understood data-lens-ixset is broken.
13:09:44 <roconnor> donri: in that their lenses don't satify the lens laws
13:09:48 <flebron> Hey. x >>= f should be the same as join . fmap f x, correct?
13:09:58 <roconnor> flebron: yep
13:10:05 <donri> roconnor: that doesn't make me feel better, it's my package ;)
13:10:16 <roconnor> flebron: well join $ fmap f x
13:10:17 <donri> and i know it's broken from your reddit comments
13:10:18 <flebron> And x >>= id == x, correct?
13:10:27 <roconnor> donri: ah oops
13:10:31 <donri> mind you, i'm a haskell newb
13:10:36 <roconnor> donri: sorry I misread what you wrote
13:10:39 <donri> ;)
13:10:40 <donri> np
13:10:40 <flebron> Hrm, maybe not id, but return.
13:11:02 <flebron> Ah, binding id should be return?
13:11:05 <roconnor> donri: I'm impressed if you are a haskell newbie.
13:11:32 <donri> yes, clearly i'm skilled enough to manage to write type checking incorrect code :)
13:11:38 <monochrom> x >>= return == x
13:11:54 <roconnor> donri: "lenses" for database query is a difficult topic that appears to be an active area of research.
13:12:11 <monochrom> actually why don't I use a funny equal symbol? :) x >>= return ≡ x
13:13:30 <nand`> How can I best express this in words: f a . f b = f b . f a ?
13:13:39 <roconnor> monochrom: when I design my own language = will be an illegal operator.
13:14:22 <monochrom> \∩/
13:16:35 <monochrom> "f a and f b commute". don't go for precision and completeness in words.
13:17:46 <nand`> monochrom: if it's true for all a, b in f's domain, is there some way I can formulate it without including a or b in the description? I'm looking for something in the form of “f is ...”
13:18:35 <monochrom> "dot is commutative in the range of f"
13:19:07 <alpounet> doesn't seem clearer though
13:19:33 <monochrom> words are not supposed to be clearer
13:19:41 <timthelion> alpounet: mostly because it includes the term dot, which is hardly clearly defined.
13:23:27 <gzmask> is a game loop in haskell simulated by infinite recursions?
13:23:37 <monochrom> you can easily say "function composition is commutative in the range of f" for a more mouthful
13:23:47 <byorgey> gzmask: sure
13:24:28 <timthelion> hm, Dyre doesn't work for me :( I thought I could be lazy by simply using a haskell source file as my file format.  But it seems that dynamically loading such a file is impossible if XMonad and Dyre use such a terrible method.
13:24:44 <gzmask> byorgey: how do you track delta time in recursive manner then?
13:25:00 <byorgey> gzmask: just make it a parameter to the recursive function
13:25:21 <byorgey> gzmask: unless I am not understanding your question
13:27:18 <gzmask> byorgey: is this parameter mutable ?
13:27:27 <byorgey> gzmask: nothing in Haskell is mutable.
13:27:37 <byorgey> (to a first approximation)
13:27:58 <byorgey> gzmask: foo curTime = do some stuff >> foo (curTime + 1)
13:28:13 <gzmask> byorgey: but delta time in imperative programming is mutable
13:28:58 <byorgey> oh, I see, "delta time" is a technical term.  I guess I didn't understand your question.
13:29:11 <alpounet> timthelion, what's the issue you're having here?
13:29:21 <bitonic> gzmask: what do you mean by "delta time" here?
13:30:02 <byorgey> http://en.wikipedia.org/wiki/Delta_timing  ?
13:30:03 <iandalton> FP just blew my mind. I have never learned anything about it, but http://www.defmacro.org/ramblings/fp.html says Haskell can implement CL's 'unless' without macros. :-O
13:30:31 <gzmask> byorgey: a game runs in frames per second, right? but the amount of processing need to be handle varies, thus delta time represents the passed time of previous frame, and it's a variable
13:30:50 <byorgey> iandalton: it's true.  Though that has more to do with laziness than with functional programming.
13:30:50 <bitonic> gzmask: you don't need mutable variables to do that, just what byorgey said
13:30:53 <parcs`> iandalton: haskell can implement goto without macros
13:31:00 <timthelion> alpounet: well I have some data, and it's easilly expressed in a haskell data declaration, so I thought that I'd just let ghc do the parsing.  But it seems unreasonable, because it seems that would mean that the file would always have to have a certain name or some such hack.
13:31:23 <iandalton> byorgey: right, OK. That's still amazing.
13:31:36 <bitonic> there are more amazing things about lazyness and haskell in general ehe
13:31:38 <byorgey> gzmask: you just remember the timestamp from the previous call, and pass it along as a parameter.  Then you get the current time and compare.
13:31:43 <iandalton> parcs`: are you referring to TCO?
13:31:43 <bitonic> but yeah I miss it a lot in scheme (lazyness)
13:31:57 <byorgey> gzmask: no mutable variables are needed, though of course you do need to do I/O to get the current time
13:32:03 <alpounet> timthelion, what's the role of the data you put in that file?
13:32:08 <byorgey> iandalton: =)
13:32:12 <hpaste> timthelion pasted “Just dynamically load this as your file, like you would in python” at http://hpaste.org/65638
13:32:34 <maxerize> i'm running a subprocess and need to capture the output as a String
13:32:45 <maxerize> can I do this with System.Process ?
13:32:54 <timthelion> alpounet: it's a user edited file.  it's like a spreadsheet.
13:33:17 <gzmask> byorgey: ahh, I see. so anything that represents the current game state need to pass to next recursion as parameter, I guess.
13:33:51 <byorgey> gzmask: right.  In practice you probably have a single parameter which is a record of game state.
13:33:54 <timthelion> alpounet: I think I'll have to write a partial parser for haskell code, to parse that text and set up the correct data constructors.
13:33:54 <alpounet> timthelion, is this gonna be changed regularly, and read from and written to often ,
13:33:55 <alpounet> ?
13:33:56 <byorgey> maxerize: http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#v:readProcess ?
13:34:02 <timthelion> alpounet: Yes.
13:34:16 <alpounet> timthelion, there already are parsers for haskell code
13:34:38 <alpounet> are you writing some kind of editor, and that represents meta-data about code that's being edited?
13:34:53 <bitonic> timthelion: haskell doesn't support hot swapping of modules, yet.
13:35:16 <bitonic> s/haskell/GHC/
13:35:28 <bitonic> timthelion: doing that in python is much easier
13:35:36 <timthelion> alpounet: nope.  I just thought that it would be a free way(no coding required) to serialize and reload the object.
13:35:43 <gzmask> byorgey: thanks  :)
13:35:49 <bitonic> an haskell application is a big binary. with python everything runs in an interpreter that can easily do that
13:35:52 <parcs`> timthelion: i mean the goto control structure
13:35:57 <maxerize> thanks byorgey
13:36:13 <maxerize> i do have another error. I'm trying to get a IO String out of it
13:36:16 <alpounet> timthelion, is that file edited as is by something external to your program?
13:36:23 <maxerize> "    Couldn't match expected type `[Char]'
13:36:24 <maxerize>            against inferred type `IO String'"
13:36:47 <bitonic> timthelion: also you have to make sure that the types match. so for a variety of reasons it's much harder than in python/erlang/etc.
13:36:51 <parcs`> iandalton: i mean the goto control structure, and by extension, for/while loops, and the continue/break loop operators
13:36:55 <timthelion> alpounet: I'd like it to be human editable, simply because I have a strong bias against non human readable/editable data.
13:37:05 <maxerize> byorgey: http://hpaste.org/65639
13:37:11 <iandalton> parcs`: interesting
13:37:36 <sclv> timthelion: you can just derive read/show
13:37:41 <c_wraith> maxerize: you need to use return
13:37:50 <timthelion> bitonic: but that makes it easier.  In python, garbage in = random behavior.  In haskell, garbage in means usefull error messages.
13:37:53 <c_wraith> :t return "foo"
13:37:54 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
13:38:07 <alpounet> timthelion, then maybe you could use an existing serialization/deserialization library (not just read/show for performance issues), by just writing an instance for your data type that contains all these informatios
13:38:14 <timthelion> sclv: aka make Cell readable?
13:38:36 <bitonic> alpounet: he wants the data to be humanly readable, serialization libraries won't help
13:38:39 <sclv> Everything in Cell seems liek it can just be read/shown.
13:38:50 <bitonic> timthelion: all I'm saying is that it's much harder to implement
13:38:51 <sclv> If performance isn't an issue, that's pretty decent.
13:39:02 <sclv> The main problem is actually that the parser is somewhat fragile and gives crummy messages.
13:39:07 <alpounet> bitonic, well, serialization to JSON, YAML and whatnot would be just fine
13:39:07 <bitonic> timthelion: if you just need to load haskell data structures you can use read and show as sclv said.
13:39:23 <timthelion> ok, thank you
13:39:26 <sclv> I've done that for simple configs in the past.
13:39:38 <bitonic> alpounet: yes, I tought you were suggesting binary/cereal.
13:39:39 <sclv> When you want to get fancier, you do indeed probably want to switch to json.
13:39:49 <maxerize> c_wraith: still get a type error
13:40:03 <maxerize> couldn't match 'Char' against 'IO String'
13:40:07 <sclv> and thelibs are pretty good there and can give you generic serialization deserialization wtih deriving Data as well.
13:40:18 <sclv> (or actually, with the new generic mechanisms too I think!)
13:40:37 <alpounet> bitonic, nope, that would indeed not match his needs
13:40:47 <c_wraith> maxerize: oh, then you're probably attempting to <- a String, rather than an IO String
13:41:15 <c_wraith> maxerize: this isn't something that can be fixed by random fix-shotgunning.  You need to follow the types
13:41:28 <maxerize> I don't get this
13:41:44 <maxerize> I'm using the "Roll your own IRC Bot guide"
13:41:49 <maxerize> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
13:42:10 <maxerize> and here's my code http://hpaste.org/65640
13:42:52 <c_wraith> and what line does it say is an error?
13:43:02 <maxerize> 75
13:43:15 <maxerize> Couldn't match 'String' to 'IO String'
13:43:36 <c_wraith> ah.
13:43:58 <c_wraith> the problem is that privmsg takes a string, but runCommand' return an IO String
13:44:09 <c_wraith> You will need to do more work to get them to work together.
13:44:22 <maxerize> is there no simple way to cast one as another?
13:44:28 <kallisti> so are there any improvements to the standard PRNG for haskell out there?
13:44:39 <c_wraith> that's like asking if you can cast a program to a string
13:44:48 <c_wraith> No, you can't.
13:44:57 <c_wraith> You could run the program and look at its output, though
13:46:01 <c_wraith> unfortunately, this isn't a good beginner-level tutorial
13:46:17 <timthelion> why is this page in spanish? http://www.haskell.org/haskellwiki/Data
13:46:19 <c_wraith> because it's using ReaderT, which is going to make it more complicated to do that.
13:46:51 <qued_____> What's wrong with that?   isInAbc c = (isIn "abcdefghijklmnopqrstuvwxyz") . toLower c
13:47:36 <c_wraith> qued_____: «toLower c» isn't a function, so the type of . doesn't work
13:48:08 <maxerize> So IO String and String are completely different? How?
13:48:37 <c_wraith> maxerize: IO String means "a program that potentially does arbitrary IO, and results in a String"
13:48:58 <maxerize> So I can capture stdout and use that as a String, right?
13:49:06 <c_wraith> maxerize: well, "program" is a bit of a lie
13:49:22 <c_wraith> maxerize: but it's the most truthful analogy
13:49:29 <c_wraith> maxerize: in fact, using it is much easier than that
13:49:34 <qued_____> c_wraith: thanks ^^
13:49:42 <monochrom> @quote ls
13:49:44 <lambdabot> dibblego says: everyone else's code is fixed by teaching them haskell too!
13:49:47 <maxerize> Why do i feel so stupid
13:50:11 <c_wraith> maxerize: IO is built so that you can combine multiple IO actions together, using the results from some as input to others.
13:50:30 <monochrom> @quote contains
13:50:31 <lambdabot> kzm says: My program contains a bug.  How ungrateful, after all I've done for it.
13:50:33 <c_wraith> maxerize: do-notation is one way of doing that, with the bind arrow (<-) in particular
13:50:51 <c_wraith> maxerize: explicitly using functions like (>>=) is another way of doing that.
13:51:13 <maxerize> wait, isn't >>= shorthand for do {} ?
13:51:39 <kallisti> maxerize: do notation is syntax sugar for >>= and >>
13:51:46 <kallisti> and >> is just a specific form of >>=
13:52:02 <maxerize> This language is pretty damn hard.
13:52:07 <kallisti> maxerize: so it's the other way around. do notation is a "shorthand" for >>=
13:52:31 <kallisti> maxerize: it just takes some practice
13:52:42 <maxerize> Coming from OO, more than that.
13:52:43 <kallisti> like learning your first imperative language likely took.
13:56:44 <srhb> maxerize: do { foo <- bar; foo } is shorthand for bar >>= \foo -> foo, but it doesn't really become apparent that it's a shorthand until you have several <-'s in the do block. :-)
13:57:14 <maxerize> Back to LYAH
13:57:19 <kallisti> also, it's not always more convenient. I use do notation and >>= equally often, I would say.
13:57:24 <maxerize> Obviously not read yet
13:57:25 <srhb> Same.
13:57:26 <maxerize> *ready
13:57:41 <jeff_s_> I tend to use >>= only when I'm not chaining it.
13:58:09 <zerax> maxerize: If learning Haskell doesn't kill you, it makes your brain stronger.
13:58:10 <jeff_s_> Using do inside of do is always a good time.
13:58:40 <srhb> It does become obvious once you have do blocks like do { foo <- bar; baz <- blob; ... } which is bar >>= \foo -> (blob >>= \baz -> ...)
13:58:49 <srhb> (I think)
13:59:02 <kallisti> (yes)
13:59:16 <kallisti> :D
13:59:26 <srhb> Thanks. ;) Was worrying about my parens.
13:59:55 <kallisti> I still chain >>='s if it's just easier to express that way.
14:00:07 <kallisti> f x =<< g y z =<< m
14:00:56 <srhb> Yes, and oneoffs like readFile "foo" >>= return . ... . lines -- is always nice
14:01:14 <kallisti> m >>= return . f
14:01:20 <kallisti> is just f <$> m
14:01:21 <brisbin> jeff_s_: using do :: Maybe a inside of a do :: IO () is also fun :)
14:01:32 <kallisti> which is just:  fmap f m
14:01:34 <srhb> kallisti: but that needs Control.Monad doesn't it?
14:01:34 <jeff_s_> Why do I get a "No instance for (Show UTCTime)" error when clearly there is such an instance? http://hackage.haskell.org/packages/archive/time/1.2.0.3/doc/html/Data-Time-Clock.html
14:01:41 <kallisti> srhb: Control.Applicative
14:01:45 <srhb> Ah yes, of course.
14:01:47 <kallisti> srhb: fmap is in Prelude
14:01:50 <srhb> Indeed.
14:02:02 <bgamari> How does one lens through a Maybe in fclabels?
14:02:29 <bgamari> e.g. If I have data A = A { b :: Maybe B }; data B = B { c :: Int }
14:02:41 <_KY_> Is there a library for message-passing similar to that in Erlang?
14:02:52 <kallisti> jeff_s_: I'm guessing you have imported Data.Time.Clock at some point?
14:03:02 <bgamari> Is there any nice way to modify b.c if I know it's Just (i.e. I've already pattern matched on it)
14:03:34 <jeff_s_> kallisti - yup. I import Data.Time.Clock, I have t bound to a value with type UTCTime, and I try to print it.
14:03:40 <kallisti> bgamari: why do you need to work around a Maybe that you've already reconstructed with a pattern match?
14:03:56 <maxerize> jeff_s_: fmap show t
14:03:57 <maxerize> ?
14:04:16 <timthelion> wow, thanks guys, read show works great !!!
14:04:17 <kallisti> *deconstructed
14:05:04 <kallisti> _KY_: in general message passing concurrency can be done rather nicely with abstract data types and Control.Concurrent.Chan
14:05:18 <kallisti> each kind of message is just a constructor of your message type.
14:05:44 <_KY_> kallisti: does it work for both multi-core and multi-node?
14:05:54 <jeff_s_> maxerize - "Couldn't match expected type 'f0 a0' with actual type 'UTCTime'"
14:06:13 <kallisti> _KY_: well, that depends on what kind of concurrency you're using. but, uh, sure. Haskell has multi-core concurrency.
14:06:21 <jeff_s_> "... in the second argument of 'fmap', namely 't'"
14:06:21 <kallisti> specifically GHC does.
14:06:53 <jeff_s_> I've even done this before. arg!
14:07:40 <Ouzned1> Hi all
14:07:54 <brisbin> jeff_s_: http://sprunge.us/cfNe works for me
14:07:55 <_KY_> Yes I'm using GHC
14:08:14 <Ouzned1> i'm currently working on a small chess game in haskell
14:08:31 <Ouzned1> my chess board is represented as a list of lists
14:08:44 <kallisti> _KY_: okay. I'm not sure I understand the second question, but if it's what I think it is, then the answer is yes.
14:08:52 <Ouzned1> and I was wondering what's the best way to retrieve a square in the board :
14:09:00 <kallisti> Ouzned1: are you seriously concerned about the performance of your chess game?
14:09:01 <jeff_s_> brisbin - I get the no Show instance error.
14:09:06 <kallisti> because a list of lists is not a good representation.
14:09:11 <Ouzned1> by using (!!) or navigating the board with a foldl?
14:09:17 <jeff_s_> I've been able to use Show UTCTime before, so I'm not sure what's going on.
14:09:32 <hpc> Ouzned1: you want get :: [[Square]] -> Square?
14:09:33 <parcs`> Ouzned1: board !! row !! col
14:09:35 <Ouzned1> (since doing something like board!!9!!9 would throw an error with a 8x8 chess board)
14:09:36 <brisbin> jeff_s_: maybe you've got the wrong package proving UTCTime, i dunno
14:09:38 <_KY_> I want to write code that can handle multi-core and multi-node concurrencies uniformly.. is that possible?
14:09:43 <hpc> Ouzned1: you want get :: Int -> Int -> [[Square]] -> Square? -- this, rather
14:09:50 <hpc> what parcs` said
14:09:55 <kallisti> _KY_: oh by "multi-node" you mean multiple machines? no.
14:09:55 <hpc> but be ready for stuff like
14:09:57 <Ouzned1> hpc: yep
14:10:03 <hpc> > [1, 2, 3] !! 1000
14:10:05 <lambdabot>   *Exception: Prelude.(!!): index too large
14:10:07 <_KY_> I see...
14:10:23 <_KY_> Or maybe with minimal change
14:10:24 <Saizan> Ouzned1: what do you want it to do for out of bound indexes instead?
14:10:24 <Ouzned1> so how should i prevent this error from happening ?
14:10:32 <Ouzned1> do i do bound checking in the function ?
14:10:37 <hpc> if you want to be safe, you can do a length check first, but that's pretty much giving up on speed
14:10:48 <kallisti> _KY_: you don't get out-of-the-box distributivity in Haskell. to my knowledge. Of course you can manually send serialized data very easily.
14:10:59 <kallisti> _KY_: but doing things such as transferring processes across network is less trivial.
14:11:11 <Ouzned1> Saizan: I'd just like to show a message telling that the given position doesn"t exist on the square
14:11:14 <Ouzned1> board*
14:11:23 <hpc> Ouzned1: to get performance and safety, pick an array type and work with that
14:11:35 <Saizan> Ouzned1: btw, i'd use a Map (Int,Int) Square instead, it has a better API for these things
14:11:41 <shergill> am i the only one who finds the do notation confusing to work with and prefers to convert things in the underlying lambda, >>= notation?
14:11:49 <hpc> Ouzned1: http://www.haskell.org/haskellwiki/Arrays
14:11:54 <parcs`> shergill: have you met zzo38?
14:11:55 <bitonic> shergill: you're the first one I meet who thinks that way yes.
14:11:58 * kallisti recommends a 1D Data.Vector with your own specialize chess board interface (including a custom indexing function)
14:12:03 <kallisti> this is the approach I use in a chess game I've made.
14:12:06 <Ouzned1> hpc, Saizan: Thanks I'll have a look at these
14:12:09 <shergill> parcs`: no
14:12:15 <_KY_> Kallisti: seems that all I need is to pass messages
14:12:22 <hpc> shergill: it's confusing for some monads, sure
14:12:42 <hpc> shergill: what monads have you dealt with so far? i know [] is particularly bamboozling to read in do-notation form
14:12:42 <kallisti> _KY_: multi-core concurrency and message-passing is no problem. multi-node is a bit trickier but not as difficult as it could be.
14:12:59 <bitonic> hpc: how is it less bamboozling in do notation?
14:13:06 <jeff_s_> "Loading package time-1.4.0.1 ... linking ... done." -- so I'm definitely using the time package.
14:13:09 <shergill> hpc: monad transformers
14:13:10 <Cale> shergill: while it's a good idea to understand the way that the do-notation translates, I think it's clearer notation overall once you're comfortable with that.
14:13:11 <bitonic> really the difference between do and >>= is that the name binding is done on the right.
14:13:14 <jeff_s_> I had 1.2.3, but I updated for the heck of it.
14:13:16 <hpc> bitonic: i said it's more confusing :P
14:13:31 <_KY_> Kallisti: why would it be tricky? isn't it a standard function?
14:13:37 <bitonic> sorry, how is it less bamboozling using >>= :P
14:13:42 <hpc> it's less confusing when translated to comprehensions :P
14:13:53 <hpc> (or rather, untranslated)
14:14:04 <Cale> It's really the same thing of course
14:14:06 <jeff_s_> Maybe I have some nonstandard Show that happens to have the same name?
14:14:13 <bitonic> hpc: sure
14:14:21 <kallisti> _KY_: standard function where? standard function of what?
14:14:38 <Cale> There's very little difference, but writing things in terms of >>= has a bit more visual noise to it
14:15:12 <_KY_> Kallisti: I mean, a common operation for coders, I expect some library would have it?
14:15:17 <bitonic> yeah, it adds 4 characters to be specific
14:15:19 <bitonic> >>= and \
14:15:28 <shergill> Cale: i feel that visual noise is what makes the code clearer. perhaps it's just that i need to get more comfortable with the do notation?
14:15:29 <bitonic> other than that it's the same...
14:15:51 <hpc> shergill: yeah; it's a very simple transformation from do to (>>=) and back
14:16:02 <hpc> just takes a bit of brain-bending
14:16:10 <Cale> shergill: probably :)
14:16:22 <kallisti> _KY_: http://www.haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism#Distributed_Haskell
14:16:27 <Cale> shergill: do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
14:16:28 <jeff_s_> Woah - I've tried printing a UTCTime value on three different computers, and none worked.
14:16:31 <jeff_s_> This is very strange.
14:16:39 <shergill> hpc: yeah. well the thing is that i saw myself having to go through those mental gymnastics first while writing code and then while trying to comprehend what that code accomplished later on
14:16:39 <kallisti> depending on your needs you may just want to use serialization of some kind rather than something more complex.
14:16:49 <Cale> shergill: do { x ; <stmts> } = x >> do { <stmts> }
14:17:08 <sykora> Quick question about cabal-dev: Is there any way I can isolate my sandbox from the global package list?
14:17:11 <shergill> Cale: yeah, i know the translation
14:17:37 <parcs`> shergill: how do you desugar do { C <- a; blah } ?
14:17:48 <Saizan> sykora: some packages are only available as global, e.g. base
14:17:49 <Cale> shergill: it's very straightforward, so you should be able to look at one and read off the other in your head without having to think too hard about what's going on
14:18:00 <_KY_> Kallisti: if serialization, what should I use?
14:18:13 <shergill> parcs`: a >>= \C -> do { blah}
14:18:13 <Cale> There are some sneaky cases involving pattern matching (which use fail in the present standard)
14:18:21 <bitonic> shergill: nope.
14:18:22 <parcs`> nope! :P
14:18:38 <kallisti> _KY_: depends. Cereal is a good serialization library.
14:18:44 <shergill> oh. hmm
14:18:44 <bitonic> do automatically pattern matches and calls 'fail' if it fails
14:18:55 <kallisti> _KY_: Aeson does JSON.
14:18:56 <Cale> It's actually kinda annoying
14:19:00 <parcs`> a >>= \x -> case x of C -> blah; _ -> fail "pattern match failure message"
14:19:05 <hpc> a >>= \randomName12345 -> case randomName12345 of C -> do blah; _ -> fail "blah"
14:19:11 <Cale> Matching against patterns which might fail should really use mzero instead of fail at least
14:19:14 <Cale> fail is bad :P
14:19:18 <bitonic> fail is bad yes.
14:19:29 <bitonic> it calls fail with 'let' as well
14:19:32 <kallisti> _KY_: another way to handle serialization would be to just use read and show.
14:19:35 <hpc> a sane MonadPlus will let fail = const mzero
14:19:38 <parcs`> shergill: this is why do is superior notation in some cases
14:19:40 <bitonic> the only way to fail a pattern in a do block is with a case
14:20:12 <hpc> custom monads can exploit fail rather cleverly
14:20:26 <hpc> though sometimes 'cleverly' == 'confusingly', tbh
14:20:34 <bitonic> fail shouldn't be in Monad. fail shouldn't be in Monad.
14:21:03 <parcs`> > let xs = [Nothing, Just 3, Nothing, Just 4] in do { Just a <- xs; return a }
14:21:04 <_KY_> Kallisti: I'm not familiar with read and show... are any of these methods as easy as Erlang's messaging?
14:21:04 <lambdabot>   [3,4]
14:21:28 <sykora> Saizan: What if there's a globally installed package which I need a different version of, and cabal-dev complains because it's already installed?
14:21:52 <parcs`> > let xs = [Nothing, Just 3, Nothing, Just 4] in xs >>= \(Just a) -> return a
14:21:52 <Saizan> sykora: which package is that?
14:21:53 <lambdabot>   *Exception: <interactive>:3:54-74: Non-exhaustive patterns in lambda
14:21:57 <jeff_s_> cabal install package-version
14:21:58 <bitonic> _KY_: read and show have nothing in common with erlang's messaging. they are typeclasses to convert datatypes to/from strings.
14:22:18 <shergill> ah. gotcha
14:22:26 <kallisti> _KY_: well since none of them happen impplicitly, no. but they're all very very simple. Cereal and Aeson both have ways to automatically generate serialization code for types, and GHC can automatically derive Read and Show instances for you.
14:22:46 <kallisti> _KY_: and in exchange you get type safety, which is something Erlang doesn't have much of.
14:22:58 <sykora> Saizan: QuickCheck
14:23:07 <Cale> The way I'd have it work is that if you pattern match against a constructor of a datatype which has more than one constructor (i.e. the pattern might not match), then the code which would be generated would use mzero and you'd get a MonadZero constraint in your code, which might alert you to the fact that this is happening. If you added a ~ to the pattern, you could get back to plain Monad (with a pattern match error w
14:23:07 <Cale> hen you use the value if it fails)
14:23:13 <_KY_> Kallisti: so the messages must be strings?
14:23:46 <bitonic> _KY_: what do you need to do? communication between haskell threads?
14:23:52 <bitonic> because if that's all you want, you don't need to serialize anything
14:23:58 <kallisti> _KY_: at the lowest level, you need to be able to transmit the data across a network protocol as a sequence of bytes.
14:24:08 <kallisti> _KY_: of course your program doesn't have to think in terms of that.
14:24:18 <bitonic> _KY_: if you need multi-node it's trickier.
14:24:32 <bitonic> _KY_: much trickier than with erlang. erlang is pretty much unbeatable on that front
14:24:32 <Saizan> sykora: ah, that should be upgradable, so i'd look for a way to circumvent cabal-dev's refusal but i don't use it myself
14:24:37 <parcs`> Cale: that is sensible. perhaps you should lobby for this change in one of the mailing lists? a lot of standards stuff is being changed nowadays (eg Num superclass constraints)
14:24:39 <kallisti> bitonic: he's talking about concurrency over network (aka distributed)
14:24:50 <_KY_> Bitonic: I see....
14:25:00 <_KY_> But I definitely would need multi-node
14:25:09 <Cale> It's basically how things were in Haskell 1.4 :P
14:25:12 <kallisti> _KY_: oh did I mention that serialization isn't needed in that case? I thought it was clear.
14:25:21 <Cale> But yeah, maybe I should
14:25:29 <adit> I thought that's what CloudHaskell was for?
14:25:43 <bitonic> _KY_: then you need to set up things manually, there is no messaging facility like in erlang, and no automatic serialization
14:25:54 <_KY_> Serialization isn't needed in the distributed case? you mean
14:25:59 <kallisti> but there is nearly-automatic serialization. :P
14:26:01 <bitonic> you need to use some serialization library, and you can't pass functions around as you can in erlang
14:26:04 <parcs`> Cale: what was the rationale for the addition of 'fail'?
14:26:09 <kallisti> _KY_: no it's not needed in the local case, communicating between local Haskell threads.
14:26:35 <Cale> parcs`: a whole bunch of poor decisions which started with the removal of monad comprehensions
14:26:57 <Cale> (due to the error messages about monads being too confusing for someone's students)
14:26:59 <bitonic> _KY_: there was a project to give erlang-like functionality to haskell (cloud haskell)
14:27:33 <parcs`> Cale: how unfortunate
14:27:38 <Cale> parcs`: once those were removed, someone noticed that every present instance of MonadZero was an instance of MonadPlus and so they could be merged (not very reasonable actually)
14:27:39 <bitonic> well, now monad comprehensions are back :)
14:27:39 <_KY_> Yea... someone mentioned cloud haskell to me before
14:27:48 <_KY_> Should I use it to simplify work?
14:28:00 <Cale> parcs`: but once they were merged, the do-notation translation involving mzero would no longer work
14:28:07 <Cale> So they added fail to make up for that :P
14:28:13 <kallisti> _KY_: it largely depends on how much of the Erlang-like functionality you need.
14:28:36 <bitonic> _KY_: I don't think it's ready. tbh, if distribution is essential to your application, I'd probably choose erlang over haskell.
14:28:41 <parcs`> fail!
14:28:46 <kallisti> if your distributed code is just going to be transferring data across network, you can do that very simply by hand.
14:29:04 <kallisti> and various serialization methods which can auto-generate the serialization and parsing code for you.
14:29:31 <t4nk827> Hi all!
14:29:32 <geekagent> kallisti: Both template haskell and ghc are availble at haskell runtime.
14:29:41 <_KY_> I don't see the need to pass functions around... is that common?
14:29:47 <t4nk827> let s = ["hello","world"]
14:30:00 <parcs`> Cale: why would the do-notation translation no longer work?
14:30:08 <bitonic> _KY_: no not really :P. but it's not just that, messaging is first class and really easy in erlang. it really depends on what you need to do
14:30:12 <t4nk827> map (const '*') [x | x <- s]
14:30:40 <t4nk827> gives me '**' only
14:30:40 <Cale> parcs`: well, it would, it's just that you'd get MonadPlus constraints
14:30:43 <geekagent> t4nk827: '**'
14:30:45 <_KY_> I need to pass messages around a large network, to do sko distributive computing
14:31:00 <Cale> parcs`: which means that you'd need to implement all of MonadPlus to handle failure
14:31:04 <t4nk827> geekagent: yh but I need '*****' '*****'
14:31:08 <hpc> @let s = ["hello","world"]
14:31:08 <geekagent> t4nk827: It should only give you '**'
14:31:10 <lambdabot>  Defined.
14:31:11 <Cale> I guess it would still work semi-okay
14:31:11 <_KY_> *to do some kind of distributive computing
14:31:12 <t4nk827> 'hello' 'world'
14:31:14 <bitonic> _KY_: you can definitely do that in haskell and it's not even hard. but it won't be trivial like in erlang.
14:31:17 <hpc> > [x | x <- s]
14:31:17 <mauke> @undefine
14:31:19 <kallisti> _KY_: do you need threads on one machine to transfer to other machines?
14:31:20 <lambdabot>   Ambiguous occurrence `s'
14:31:20 <lambdabot>  It could refer to either `L.s', defined at <local...
14:31:21 <hpc> hey!
14:31:22 <Cale> but... well, none of those decisions really make perfect sense
14:31:27 <mauke> hpc: stop breaking lambdabot
14:31:33 <adit> > (map.map) (const '*') ["hello", "world"]
14:31:36 <lambdabot>   ["*****","*****"]
14:31:39 <gloucester> Can someone answer a couple of questions for me about whether upgrading my GHC will work with Platform?
14:31:44 <hpc> > let s = words "hello world" in [x | x <- s]
14:31:45 <lambdabot>   ["hello","world"]
14:31:47 <_KY_> Kallisti: probably not
14:32:03 <kallisti> _KY_: well that's one thing that Erlang can do very easily that Haskell cannot.
14:32:10 <t4nk827> adit: hey adit thanks
14:32:17 <adit> sure
14:32:19 <bitonic> erlang can also do hot code changes, you can attach shells to existing processes...
14:32:25 <_KY_> It's just the messages that need to be passed around
14:32:31 <Cale> gloucester: If you upgrade your GHC, probably the most sensible thing to do is just to install cabal-install, and install any packages you need as you need them, rather than trying to get HP running.
14:32:33 <kallisti> yep that's easy.
14:32:37 <dmwit> ?hoogle measure
14:32:38 <lambdabot> package Measure
14:32:45 <bitonic> you have mnesia, etc. erlang was more or less thought to build resilient services
14:33:11 <_KY_> I see...
14:33:14 <kallisti> _KY_: do you know Haskell? if you have any kind of time pressure and already know Erlang but don't know Haskell, then that's something to take into consideration.
14:33:42 <_KY_> I know some haskell, more than erlang actually
14:33:44 <gloucester> Cale: OK, I prob just do that. Do you know what version of GHC will be included in the next release of HP?
14:34:08 <_KY_> I want to write some algorithms in haskell, but I also want erlang's distributive stuff =)
14:34:27 <kallisti> like I said, if you just need to pass messages, that's also trivial in Haskell. but not implicit.
14:34:42 <bitonic> I wouldn't say it's "trivial".
14:34:49 <bitonic> you have to set up some server that listens
14:35:13 <kallisti> sure.
14:35:18 <bitonic> in erlang you already have something that manages them for you, retries to deliver them if you don't accept them, etc.
14:35:27 <Cale> gloucester: I don't really know. It'd probably be nice to have one with 7.4 in it, though 7.4 has quite a few bugs at present. (Maybe there'll be some point releases soon or something? :)
14:35:31 <roconnor> how do you all guys do networking in Haskell when there is no way to set a timeout a socket?
14:35:51 <gloucester> Cale: HP
14:35:54 <c_wraith> roconnor: other than System.Timeout?
14:36:24 <kallisti> roconnor: it's actually more natural to use blocking reads with concurrency, in many situations.
14:36:43 <gloucester> Cale: HP's site says the next release will be in May. I'm just trying to figure out whether I should figure out how to upgrade to fix a very aggravating bug in GHC 7.0 on OS X 10.7 or just wait ...
14:36:49 <kallisti> than to do asynchronous IO with non-blocking sockets.
14:36:50 <roconnor> c_wraith: so you start separate timeout threads?
14:37:08 <c_wraith> roconnor: if you can call them that.  They're really just entries in a queue
14:37:35 <roconnor> c_wraith: but you use forkIO
14:37:52 <roconnor> what a pain
14:37:57 <c_wraith> *I* don't.
14:38:01 <roconnor> oh
14:38:02 <roconnor> :D
14:38:05 <c_wraith> some library function does.
14:38:09 <c_wraith> and it may not, anymore
14:38:18 <kallisti> I don't see anything in System.Timeout about threads.
14:38:25 <c_wraith> there was talk of updating it to use the new IO manager stuff in ghc 7
14:38:38 <bitonic> _KY_: all in all, erlang is a joy for distributed software, Haskell is a joy for everything else :). they're both languages that will teach you a lot
14:38:39 <c_wraith> to just hook into its timeout stuff without starting a new thread
14:39:01 <kallisti> roconnor: depending on what you're doing, you may want to look into blocking + concurrency.
14:39:22 <kallisti> you may be pleasantly surprised.
14:39:24 <roconnor> c_wraith: or, you know, we could expose the timeouts that already exist in the BSD socket library.
14:39:25 <_KY_> I'm not sure if I need blocking or non-blocking...
14:39:45 <kallisti> _KY_: good, because no one asked. :P
14:47:25 <kallisti> roconnor: are you sure that non-blocking connects is the best choice?
14:47:42 <roconnor> kallisti: IIRC I wanted blocking connects with a timeout
14:48:23 <roconnor> and I didn't want to get into forkIO.
14:48:32 <kallisti> why?
14:48:34 <c_wraith> kallisti: timeouts are 100% independent of blocking/non-blocking
14:48:46 <c_wraith> I don't understand the fear of forkIO, though.
14:48:50 <roconnor> kallisti: cause then I would have to learn about semaphores and mutexes and whatnot
14:48:55 <c_wraith> no you don't
14:49:00 <c_wraith> just use System.Timeout
14:49:03 <roconnor> and all I want to is just timeout
14:49:10 <c_wraith> all it does is timeout
14:49:11 <_KY_> Kallisti: oh I think I need non-blocking send and recieve
14:49:15 <c_wraith> the details are non-important
14:49:57 <roconnor> c_wraith: hmm
14:50:07 <roconnor> c_wraith: interesting
14:50:28 <roconnor> c_wraith: ``When timeout is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator.
14:50:35 <roconnor> c_wraith: should this worry me?
14:50:45 <c_wraith> only if you're using things that do their own FFI calls
14:50:54 <c_wraith> and aren't well-written
14:50:54 <roconnor> c_wraith: like connect?
14:51:05 <c_wraith> nothing from the network package is going to be a problem
14:51:16 <c_wraith> because it was written correctly
14:51:22 <roconnor> oh?
14:51:32 <roconnor> so as an aside, how do they write this correctly?
14:51:58 <hpaste> Vic pasted “No instance for (Data.String.IsString (Maybe String))” at http://hpaste.org/65646
14:51:59 <c_wraith> write it using non-blocking calls, and hook into the IO manager interfaces to make it appear to be blocking.
14:52:12 <_vic> So... that's my problem.
14:52:23 <roconnor> ^_^
14:52:31 <_vic> that code works with userName=Nothing and password=Nothing
14:52:40 <roconnor> c_wraith: that seems crazy.
14:52:42 <hpaste> kallisti annotated “No instance for (Data.String.IsString (Maybe String))” with “No instance for (Data.String.IsString (Maybe String)) (annotation)” at http://hpaste.org/65646#a65647
14:52:46 <roconnor> c_wraith: although good for me
14:52:50 <kallisti> _vic: ^ does that fix it?
14:52:53 <kallisti> oh oops
14:52:54 <_vic> One sec
14:53:09 <kallisti> nevermind oops, that's what I meant to do. :P
14:53:36 <kallisti> _vic: double oops
14:54:04 <_vic> Yeah, it's an old snippet
14:54:08 <_vic> But I need the auth part
14:54:20 <c_wraith> roconnor: that's how the ghc IO system is designed - the FFI calls are fast and non-blocking.  All the crazy system-level callback stuff is handled by the IO manager, which provides an external interface that appears to be blocking
14:54:34 <sclv> roconner: you can either use calls with timeouts set directly, or just use non-blocking and wrap it.
14:54:41 <sclv> so you spin instead of blocking
14:54:41 <_vic> Found this "There is a new module Data.String, which defines the new IsString(fromString) class. This class is used by the new overloaded strings extension "
14:54:50 <_vic> But I don't know how to use this information
14:54:52 <sclv> and then regular old System.timeout works fine.
14:55:08 <sclv> since it'll just interrupt the spin.
14:55:11 <kallisti> _vic: nevermind I misinterpreted the error.
14:55:23 <c_wraith> sclv: you don't spin, most of the time.  also, System.Timeout won't stop a spin that doesn't allocate
14:55:42 <sclv> c_wraith: you try, then wait, then try, then wait.
14:55:51 <_vic> kallisti: no problem
14:56:08 <sclv> timeout will interrupt a nonallocating thread, as long as that thread yields every now and then!
14:56:11 <c_wraith> sclv: except in the case of interfaces that give back a file descriptor.  If that happens, you just throw it to the IO manager with readWait or writeWait
14:56:11 <sclv> and that's what the waits do.
14:56:45 <kallisti> _vic: if you're getting that compile error, using Nothing shouldn't be working at all.
14:56:47 <sclv> All the necessary nonblocking calls are in system.network
14:56:59 <c_wraith> no, the waits do not spin
14:57:08 <c_wraith> the waits use epoll on linux
14:57:13 <sclv> I was using "spin" loosely.
14:57:19 <c_wraith> equivalent interfaces on other platforms
14:57:33 <sclv> As in you just try to read, and then if you fail, you just call threadDelay before you try to read again.
14:57:37 <kallisti> on Windows waits calculate very large prime numbers to prevent the process from getting bored.
14:57:40 <_vic> kallisti: using Nothing gives me
14:57:52 <hpaste> Davorak pasted “Edit lenses Install error” at http://hpaste.org/65648
14:58:02 <sclv> and you can package this up so it looks exactly like a typical io call, and you can even wrap it in an unsafeinterleave to get lazy io
14:58:18 <sclv> and i've used this pattern to good effect and promise it works.
14:58:22 <_vic> ** Exception: connect: does not exist (Connection refused)
14:58:29 <dmwit> Davorak: Hm, what version of GHC are you using?
14:58:37 <kallisti> _vic: what do you get with other data?
14:58:49 <kallisti> if it's a compile error, as the title of your paste seems to suggestion, then that makes no sense.
14:59:01 <c_wraith> sclv: it works, sure, but it's more complicated to implement and less efficient than other approaches that are often possible.
14:59:05 <_vic> Not a compile error. runhaskell / ghci error
14:59:21 <sclv> c_wraith -- it is dead simple to implement. i don't deny there are other more efficient approaches.
14:59:51 <kallisti> _vic: oh, you need to wrap the string in Just
15:00:15 <_vic> Ahh
15:00:45 <kallisti> _vic: also might want to take a look at hpastes suggestions on your code.
15:00:52 <kallisti> lots of redundant do and $
15:00:53 <_vic> Those are fixed.
15:00:56 <kallisti> ah okay.
15:01:01 <_vic> Well, I just want it to work.
15:01:44 <_vic> Ook, how do I wrap it?     userName :: Just String ?
15:02:24 <c_wraith> no, wrap the value
15:02:44 <_vic> Just "username" then...
15:03:19 <_vic> Ah, cool
15:03:46 <roconnor> sclv: calls with timeouts set directly?
15:04:07 <_vic> *** Exception: connect: does not exist (Connection refused)   but at least I got rid of that error.
15:04:58 <kallisti> _vic: yes a string literal is not a Maybe String, basically.
15:05:16 <nexx> is there a way to define a class in ghci? I tried :{ }: but still get a parse error on input `class'
15:05:53 <roconnor> sclv: what does that mean?
15:06:52 <_vic> kallisti: thank you
15:07:40 <hpc> nexx: don't define it in ghci
15:07:56 <hpc> nexx: when i use ghci, i always define stuff in a file and reload as i edit
15:08:06 <kallisti> _vic: also I notice you do a lot of  m >> return ()
15:08:11 <kallisti> you can replace those with void (return IO)
15:08:27 <kallisti> when (isJust user && isJust pass) . void $ sendCommand ...
15:08:29 <kallisti> for example
15:08:29 <roconnor> gah, whose stupid idea was it to call that function void
15:08:35 <roconnor> now Haskell is as bad as C
15:08:39 <nexx> hpc is this a no?
15:08:49 <kallisti> roconnor: oh no, it uses the same word as C. therefore it's bad.
15:08:59 <sclv> roconnor: http://hackage.haskell.org/packages/archive/network/2.3.0.11/doc/html/Network-Socket.html
15:09:00 <roconnor> kallisti: oh I see
15:09:01 <hpc> nexx: it's an "ive never tried; here's a better way" ;)
15:09:11 <hpc> or "probably a no" :P
15:09:15 <sclv> you can set the recvtimeout and sendtimeout options directly on the socket
15:09:32 <roconnor> sclv: where?
15:09:47 <nexx> well probably thx :-)
15:10:06 <sclv> see setSocketOption
15:10:20 <roconnor> sclv: it doesn't work
15:10:31 <kallisti> _vic: er, I meant return (void m)  not return (void IO)   :P
15:10:57 <_vic> Yeah, got that.
15:11:14 <_vic> One more thing: how do I make this run with runhaskell. What do I add in main?
15:11:21 <_vic> main = do sendTest ?
15:11:28 <kallisti> main = sendTest
15:11:30 <sclv> roconner: oh well. then the other suggestion :-)
15:11:35 <_vic> Let's see
15:11:41 <kallisti> _vic: that do does absolutely nothing
15:11:44 <kallisti> > do do do do do do 2
15:11:46 <lambdabot>   2
15:12:05 <roconnor> sclv: http://www.haskell.org/pipermail/libraries/2005-October/004435.html
15:12:15 <roconnor> sclv: it's been unsuable for over 7 years now
15:12:31 <_KY_> By the way, I'd pay for someone to do the distributive code if anyone is interested =)
15:12:48 <kallisti> _KY_: sure.
15:13:05 * kallisti is a professional freelancer.
15:13:21 <sclv> roconnor: http://hackage.haskell.org/package/network-socket-options-0.2 ?
15:13:21 <_KY_> Great, let's chat private... =)
15:13:27 <kallisti> okay.
15:13:51 <roconnor> sclv: horray!
15:14:03 <hpc> > do do that voodoo -- kallisti
15:14:04 <lambdabot>   that you do so well
15:14:13 <kallisti> heh
15:14:14 <roconnor> sclv: Joey Adams deserves a medal or something
15:14:15 <kallisti> :t that
15:14:16 <lambdabot> forall t. t -> Doc
15:14:25 <kallisti> :t voodoo
15:14:26 <lambdabot> forall a. a
15:14:41 <t4nk827> map (words . lines) xs
15:14:43 <sclv> hackage gold :-)
15:14:47 <roconnor> sclv: to be fair it was only packaged 1 month ago.
15:14:53 <roconnor> sclv: so I guess I can be excused.
15:14:54 <t4nk827> let xs = ["hello"]
15:14:57 <t4nk827> xs
15:15:10 <roconnor> > let xs = ["hello"] in xs
15:15:10 <lambdabot>   ["hello"]
15:15:13 <_vic>  Recipient address rejected: Relay access denied; from=... Great.
15:15:19 <_vic> Now... I have to fix this.
15:15:36 <sclv> roconnor: haha yeah. as i said, i just rolled my own thing with recvLen anyway. which is indeed not the most efficient, but does play nice with normal timeouts, which is a win in and of itself.
15:15:51 <bgamari> kallisti: I was just wondering whether it would be possible to avoid repeating myself
15:15:54 <bgamari> kallisti: In reference to my previous question regarding fclabels and Maybe
15:16:01 * kallisti still needs to write up docs before he can release his Selenium 2 library.
15:16:25 <kallisti> bgamari: ah okay.
15:16:45 <_vic> kallisti: the Robot Test Automation Framework?
15:16:49 <t4nk827> roconnor: how can i use lines and words
15:17:06 <t4nk827> roconnor: map (words . lines) xs.. like this?
15:17:43 <Mathnerd314> is there a type a such that Either a () is isomorphic to Void ?
15:18:31 <c_wraith> Mathnerd314: the existence of the value Right () would seem to suggest not
15:18:33 <hpc> Mathnerd314: no
15:19:03 <hpaste> t4nk827 pasted “error in replacing with asterisks” at http://hpaste.org/65650
15:19:22 <c_wraith> and if you're working from a domain theory perspective, even Either Void Void has more possible values than Void
15:19:22 <Mathnerd314> imaginary types?
15:19:35 <t4nk827> Can anybody help me figure out the error please !!
15:20:21 <c_wraith> Mathnerd314: While Either is a sum type, haskell has no negative types with which to extend the analogy :)
15:20:46 <byorgey> Mathnerd314: you can formalize such types using the theory of virtual species, but Haskell has nothing like that
15:21:12 <nexx> o.o
15:21:15 <Saizan> t4nk827: you should paste it
15:21:27 <Botje> t4nk827: your convertWord type is too general.
15:21:35 <byorgey> t4nk827: also, convertWord =   not  convertWord ::
15:21:39 <nexx> byorgey would there a use for it?
15:21:41 <byorgey> in the second line
15:21:47 <t4nk827> oh yh
15:21:48 <t4nk827> thanks
15:21:49 <kallisti> _vic: that's the one.
15:21:55 <_vic> Interesting
15:22:02 <byorgey> nexx: funny you should ask, that's basically going to be my dissertation topic =D
15:22:12 <nexx> :D
15:22:31 <nexx> sounds interessting :)
15:22:38 <c_wraith> byorgey: but is there a use for it? :)
15:22:41 <kallisti> _vic: here's a very early alpha, if it intrigues you. https://github.com/kallisti-dev/hs-webdriver
15:22:59 <byorgey> c_wraith: I just said it was going to be my dissertation topic, didn't I?
15:23:01 <_vic> t4nk827: bonus link for you http://nlpwp.org/book/chap-words.xhtml
15:23:02 <byorgey> so, of course not!
15:23:05 <byorgey> ;)
15:23:11 <c_wraith> just making sure :)
15:23:19 <sclv> a dissertation is a use!
15:23:49 <c_wraith> it's more of a negative use
15:23:59 <c_wraith> putting it into the dissertation keeps it from escaping into the wild
15:24:00 <sclv> arguably, the most important use (to people trying to write dissertations)
15:24:01 <byorgey> to be fair, it won't just be about virtual species specifically, and honestly I don't know of any *direct* uses for virtual species.
15:24:04 <c_wraith> (usually)
15:24:08 <byorgey> sclv: good point.
15:24:11 <nexx> byorgey you could have said, that we have wait for the result of the dissertation to decide :-)
15:24:47 <byorgey> hehe
15:24:48 <t4nk827> _vic: thanks, the link is great!
15:25:18 <tgeeky> nexx: nahh, there still won't be any direct uses :o
15:25:52 <nexx> tgeeky was your thesis to prove this? :D
15:26:25 <_vic> kallisti: looks good
15:26:30 <sclv> I would argue that there is at least one subring of the ring of virtual species which is quite useful.
15:26:40 <tgeeky> nexx: no, but I am getting my virtual PhD using a virtual dissertation using *real* species
15:26:52 <_vic> kallisti: waiting for the examples and instructions :-P
15:26:53 <tgeeky> nexx: and by duality, etc, etc
15:26:55 <byorgey> sclv: the ring of nonvirtual species? =)
15:27:33 <tgeeky> byorgey: you're a mentor for GSoC. Do you have to be instutite-affiliated to participate as a student?
15:27:33 <byorgey> tgeeky: hehehe
15:27:35 <sclv> the ring of integers.
15:27:46 <nart> hi
15:27:50 <byorgey> tgeeky: I don't think so
15:27:50 <tgeeky> sclv: BORING!
15:27:58 <byorgey> sclv: hehehe, excellent point =)
15:27:59 <kallisti> _vic: yeah it'll happen. still in testing right now.
15:28:00 <tgeeky> byorgey: sweet, I'll put my name in
15:28:16 <kallisti> _vic: the Main.hs program is a decent example.
15:28:17 <sclv> before virtual species, it was very hard to formalize integers :P
15:28:38 <_vic> kallisti: indeed
15:28:38 <nart> i have a list of function, how can i do something like, delete test [test] ?
15:28:58 <_vic> Hmm, I'll test it on a site I'm working
15:29:27 <kallisti> _vic: yes please do. there's a lot of different things to test. Most of the enlightening bits of code is going to be in Types.hs and Commands.hs
15:29:36 <_vic> Will check out.
15:29:38 <byorgey> nart: you mean delete a particular function from a list of functions?
15:29:42 <nart> yep
15:29:47 <byorgey> nart: you can't
15:29:54 <sclv> > delete "test" ["test"]
15:29:56 <byorgey> nart: because functions cannot be compared for equality.
15:29:59 <lambdabot>   []
15:30:03 <nart> i suspected that
15:30:16 <byorgey> nart: if you need to do this, I'd suggest keeping a list of Strings or something like that, and also keep a Map from Strings to functions
15:30:31 <byorgey> so you have a list of *references* to functions
15:31:24 <_vic> But first... I have to install Http
15:31:50 <_vic> *Http 4k
15:32:21 <_vic> Data.Aeson hmm
15:32:46 <_vic> And Aeson.
15:32:47 <nart> i have just seen that in the list i also have anonymous functions :S
15:33:02 <nart> i have to rethink the way i'm doing this, thanks anyway
15:33:28 <Mathnerd314> byorgey: what about reallyUnsafePtrEquality# ?
15:33:50 <sclv> I think the name answers the question?
15:34:12 <hpc> Mathnerd314: wow, that's a whole lot of unsafety going on in that name
15:34:21 <byorgey> Mathnerd314: even aside from the unsafeness, that won't really help if you happen to have two equivalent functions with different locations in memory
15:34:31 <byorgey> as might reasonably happen if you have anonymous functions in the list
15:34:47 <sclv> it should be called reallyUnsafeAndUnreliablePointerEquality
15:35:03 <byorgey> reallyUnsafeAndUnreliablePointerEquality#
15:35:05 <sclv> because you get other funny effects with gc and the like too, as I recall
15:35:07 <hpc> sclv: or perhaps more concisely, youDon'tWantThisFunction
15:35:29 <sclv> iUnderstandWhatIAmCallingAndIAcceptTheConsequencesOfMyActions#
15:35:37 <_vic> kallisti: Ok, modules loaded: Test.WebDriver, Main, Test.WebDriver.Types, Test.WebDriver.Commands, Test.WebDriver.Commands.Internal, Test.WebDriver.JSON, Test.WebDriver.Internal, Test.WebDriver.Types.Internal.
15:35:41 <_vic> kallisti: Ok, modules loaded: Test.WebDriver, Main, Test.WebDriver.Types, Test.WebDriver.Commands, Test.WebDriver.Commands.Internal, Test.WebDriver.JSON, Test.WebDriver.Internal, Test.WebDriver.Types.Internal.
15:35:45 <_vic> Awesome
15:35:47 * bgamari is frustrated by attoparsec requiring him to acknowledge the existence of fail
15:35:57 <bgamari> Is there no way to fail with a description other than fail
15:36:09 <bgamari> failDesc sadly doesn't seem to be exported
15:36:17 <c_wraith> bgamari: just pretend it's an attoparsec-specific function
15:36:29 <hpc> to be fair, it's about as close to appropriate as fail can get
15:36:47 <bgamari> hpc: Point taken
15:39:35 <Authoritarianism> One question. Can I reuse a data constructor name in two different types?
15:39:43 <_vic> Main.hs: connect: does not exist (Connection refused)
15:39:49 <_vic> Not this again. Damn
15:39:51 <hpc> Authoritarianism: yes, but not in the same scope
15:39:59 <hpc> in module A: data Foo = Foo
15:40:04 <hpc> in module B: data Bar = Foo
15:40:19 <kallisti> _vic: is that from WebDriver or something else?
15:40:21 <hpc> if you import both at the same time, you get errors
15:40:28 <hpc> or if one imports the other, etc
15:40:32 <kallisti> _vic: if it's from WebDriver, that's because you need to actually start the Selenium server.
15:40:44 <_vic> kallisti: I think I forgot something. I need to start the Selenium server
15:40:45 <Authoritarianism> hpc: Ah, I was just going to ask you that very last thing you mentioned.
15:40:46 <_vic> Ma bad
15:40:48 <Authoritarianism> hpc: Thanks!
15:41:04 <kallisti> _vic: yep. no worries. I may eventually set up some code to automate that part. I think the official libraries do this.
15:41:12 <hpc> it helps to think "what's the type of Foo"
15:41:21 <hpc> to which the answer is either "Foo" or "Bar"
15:41:25 <hpc> but never both
15:41:53 <kallisti> _vic: Test.WebDriver exports the interface you'll mostly likely be using. basically Types and Commands
15:46:41 <_vic> kallisti: how long did it take to develop this alpha?
15:47:26 <kallisti> _vic: 4 days
15:48:01 <kallisti> that includes some testing. (certainly not comprehensive testing though)
15:48:02 <_vic> And for how long have you been coding in Haskell?
15:48:10 <kallisti> about 3 years now I believe.
15:48:22 <_vic> Cool
15:49:05 <kallisti> most of the difficult was the result of poor documentation from the Selenium project.
15:49:13 <kallisti> I had to go digging through some Java and Python source.
15:49:18 * kallisti filed several issues. :D
15:49:33 <_vic> But it was rapid development
15:49:59 <_vic> Haskell shines in this area
15:50:26 <kallisti> it's pretty straightforward implementation-wise. It likely would have finished faster had the client-server protocol been better documented.
15:51:01 <kallisti> but yes 800-ish lines of code isn't bad compared to the official Selenium libraries. ;)
15:52:25 <_vic> First run "org.openqa.selenium.InvalidSelectorException: The given selector //[not(ancestor::div[contains(@style,'display:none')])][1] is either invalid or does not result in a WebElement. The following error occurred:"
15:52:29 <_vic> Ok.
15:53:02 <nart> is there a builtin function that allows to delete the nth element of a list ?
15:53:20 <_Mikey> @hoogle [(a,a)]->[a]
15:53:21 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
15:53:21 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
15:53:21 <lambdabot> Prelude snd :: (a, b) -> b
15:55:19 <_Mikey> is there a function which takes a list of tuples of the same type
15:55:24 <shergill> the MaybeT transformer is a way to transform a monad m a to type monad m Maybe a. the StateT transformer is a way to add state to a monadic computation. is there a way to have a meta-transformer of sorts? eg. using MaybeTT (maybe transformer transformer) with StateT adds a Maybe state to a monadic computation. has this already been done, or am i missing the point of transformers?
15:55:33 <_Mikey> and returns a list of all the values
15:55:40 <kallisti> _vic: oh, yes. my test program doesn't run currently. if you remove that line everything else runs I think.
15:55:50 <kallisti> also the click e3 afterward
15:56:04 <kallisti> I was trying to find a visible element to test but I think my XPath is wrong.
15:56:13 <mhitza> _Mikey, map fst ?
15:57:05 <_Mikey> mhitza, keeping the second values in the list two
15:57:40 <_Mikey> I guess map fst ++ map snd
15:57:43 <_vic> kallisti: now I'll just tweak the test suite
15:59:09 <mhitza> _Mikey, concatMap (\(a,b) -> a : b : [])  then ?
15:59:27 <_Mikey> Ohh
15:59:32 <_Mikey> I like the look of that
15:59:37 <mhitza> :)
15:59:47 <_Mikey> nice one
16:00:45 <kallisti> _vic: all of the IME stuff doesn't work a all. I think because it's unimplemented in the server.
16:04:35 <kallisti> _vic: one thing that could use some work is the exception type. it's a little complex, because I try to give as much details to the user as the server gives to me.
16:04:45 <kallisti> the official Selenium libraries dumb the client exceptions down a bit.
16:05:26 <_vic> kallisti: I first need to figure out the commands. I'm looking at the Ruby example atm
16:06:25 <kallisti> _vic: http://code.google.com/p/selenium/wiki/JsonWireProtocol  this is the resource I used the most when writing the implementation.
16:06:36 <kallisti> the long list of URLs corresponds almost directly to all of my commands.
16:06:58 <kallisti> with different names and an abstraction interface.
16:08:19 <_vic> Yes, that's better
16:09:31 <kallisti> _vic: hopefully it'll be clearer after I document everything. Let me know if you think some of the functions/types are weirdly named for their purpose or anything like that.
16:12:43 <_vic> kallisti: will do
16:14:55 <_vic> Playing with the executeJS function atm
16:15:14 <kallisti> I've noticed it's pretty slow.
16:15:21 <kallisti> pretty sure there's nothing I can do about that, however.
16:16:13 <_vic> How do I use the click function?
16:16:18 <_vic> click "http:// " ?
16:16:38 <_vic> Ah, no
16:16:42 <kallisti> _vic: you click Elements with it
16:17:00 <_vic> Got it
16:17:23 <kallisti> for the above you'd want something like:  click =<< findElem ByLinkText "http:// "
16:18:07 <hpc> substitute any number of other ways to find elements
16:20:58 <exFalso1> hi, is there a way to get all function declarations of a module with TH?
16:21:37 <kallisti> _vic: this may be a given, but I recommend OverloadedStrings ;)
16:21:45 <kallisti> since there's Text everywhere.
16:21:45 <GetOneWithLambda> I have the following definition. Can it be made shorter?
16:22:26 <GetOneWithLambda> make (Cell False x) = Row (Cell False x) (Cell True (x * (6 * x + 2)))
16:22:31 <GetOneWithLambda> Sorry...
16:22:34 <GetOneWithLambda> I meant...
16:22:39 <GetOneWithLambda> make (Cell False x) = Row (Cell False x) (Cell True (x * (6 * x - 2)))
16:22:52 <GetOneWithLambda> make (Cell True x) = Row (Cell True x) (Cell True (x * (6 * x + 2)))
16:23:06 <roconnor> make c@(Cell _ x) = Row c (Cell True (x * (6 * x + 2)))
16:23:19 <kallisti> I don't understand the third case there.
16:23:33 <GetOneWithLambda> kallisti: Ignore the first case.
16:23:37 <kallisti> ah okay.
16:23:48 <kallisti> right
16:23:53 <roconnor> GetOneWithLambda: make c@(Cell _ x) = Row c (Cell True (x * (6 * x + 2)))
16:23:55 <kallisti> roconnor: that's close but not correct
16:24:00 <roconnor> ah oops
16:24:23 <GetOneWithLambda> I want something like "if b then + else -"
16:24:32 <exFalso1> ou can do that
16:24:32 <kallisti> you could also use some fromEnum tricks
16:24:35 <kallisti> > fromEnum True
16:24:37 <lambdabot>   1
16:24:42 <roconnor> GetOneWithLambda: make c@(Cell b x) = Row c (Cell True (x * (6 * x `f` 2))) where f = if b then (+) else (-)
16:24:53 <dmwit> > (if True then (+) else (-)) 1 2
16:24:55 <lambdabot>   3
16:24:56 <roconnor> ... not sure f is the best name
16:25:00 <dmwit> > (if False then (+) else (-)) 1 2
16:25:01 <GetOneWithLambda> roconnor: Awesome!
16:25:01 <lambdabot>   -1
16:25:11 <kallisti> > signum (fromEnum False - 1)
16:25:13 <lambdabot>   -1
16:25:17 <kallisti> if you enjoy obfuscation...
16:25:24 <kallisti> > signum (fromEnum True - 1)
16:25:27 <lambdabot>   0
16:25:29 <kallisti> oh oops :P
16:25:34 <GetOneWithLambda> I do not enjoy obfuscation.
16:25:44 <roconnor> > signum (2*fromEnum True - 1)
16:25:44 <kallisti> I'm shocked.
16:25:45 <lambdabot>   1
16:25:47 <GetOneWithLambda> But I also hate using too much horizontal space.
16:25:51 <roconnor> > signum (2*fromEnum False - 1)
16:25:52 <lambdabot>   -1
16:26:00 <tromp__> i love obfuscation
16:26:04 <roconnor> GetOneWithLambda: I only did it on one line due to IRC.
16:26:08 <roconnor> :)
16:26:11 <kallisti> roconnor: luckily Haskell has sensible layout rules. :D
16:26:13 <tromp__> for recreational purposes:)
16:26:15 <GetOneWithLambda> GetOneWithLambda: Ah. :)
16:26:45 <kallisti> also
16:26:47 <hpc> haskell excells at obfuscation by α-renaming
16:26:49 * roconnor feels dirty for using if then else
16:27:01 <hpc> roconnor: nah, i use it in agda
16:27:11 <hpc> roconnor: i even define it myself instead of importing :P
16:27:25 <hpc> great, now i feel dirty too
16:27:36 <kallisti> (<>) | b = (+) | otherwise = (-)
16:27:40 <roconnor> GetOneWithLambda: I'm not sure what Cell is but you may wish to consider making your own 2-element data type with better names, ... depending on your application.
16:27:41 <kallisti> if this makes you feel better
16:27:57 <kallisti> (indent before each of the | )
16:27:58 <roconnor> GetOneWithLambda: e.g. data DIr = L | R
16:28:05 <GetOneWithLambda> roconnor: The names "Cell" and "Row" make sense in the context I am using them.
16:28:24 <roconnor> GetOneWithLambda: oh I'm good with that
16:28:29 <kallisti> (I'm not sure if you knew that you can use guards with variables)
16:28:34 <roconnor> GetOneWithLambda: I'm more concerned with the Bool parameter
16:28:41 <GetOneWithLambda> roconnor: Cell represents a number that is guaranteed to be of the form (6x+1) or (6x-1).
16:28:56 <GetOneWithLambda> roconnor: If it is True, then it is 6x+1, otherwise, it is 6x-1.
16:29:09 <GetOneWithLambda> roconnor: make initializes a pair (x, x*x).
16:29:29 <kallisti> > let (<>) | True = (+) | otherwise = (-) in 5 <> 8
16:29:32 <lambdabot>   13
16:29:40 <roconnor> GetOneWithLambda: I would be inclined to use 2 constructors for Cell.
16:29:40 <kallisti> > let (<>) | False = (+) | otherwise = (-) in 5 <> 8
16:29:42 <lambdabot>   -3
16:30:02 <GetOneWithLambda> roconnor: Oh.
16:30:08 <roconnor> GetOneWithLambda: granted your nifty 1 liner wouldn't work then.
16:30:31 <kallisti> what is a line of code in Haskell?
16:30:41 <GetOneWithLambda> roconnor: My main problem with two constructors is that Haskell constructors are named.
16:30:50 <roconnor> indeed
16:30:58 <GetOneWithLambda> roconnor: And I suck at coming up with data constructor names. :(
16:31:01 <roconnor> kallisti: make c@(Cell b x) = Row c (Cell True (x * (6 * x `f` 2))) where f = if b then (+) else (-)
16:31:11 <kallisti> yes?
16:31:18 <kallisti> the change I was suggesting applied to that/
16:31:22 <roconnor> GetOneWithLambda: well, you are in the best position to decide what is best for your code ;)
16:31:31 <GetOneWithLambda> :)
16:31:42 * kallisti thinks the guards look nicer.
16:31:57 <kallisti> and the symbolic infix operator.
16:32:10 <dmwit> x * (6 * x + if b then 2 else -2)
16:32:25 <roconnor> dmwit: too slow! :P
16:32:36 <dmwit> undoubtedly
16:32:57 <hpc> x * (6 * x + (if b then id else negate) 2)
16:33:00 <kallisti> where blah | b = 2 | otherwise = -2
16:33:02 <kallisti> there much better
16:33:04 <hpc> because this isn't ugly enough
16:33:35 <shachaf> if b return =<< id else return =<< negate -- just so no one gets confused
16:33:50 <roconnor> kallisti: see, now you are using Eq instead of pattern matching
16:33:53 <hpc> needs "then"
16:33:56 <roconnor> kallisti: Use a pattern guard instead
16:33:57 <kallisti> roconnor: no I'm not
16:34:05 <roconnor> kallisti: ah oops
16:34:06 <shachaf> hpc: See? You didn't get confused.
16:34:07 <roconnor> misread it
16:34:09 <roconnor> kallisti: sorry
16:34:11 <kallisti> I'm using a guard instead of a conditional :D
16:34:37 <dmwit> Oh yeah? Well I'm using *two* guards instead of a conditional!!
16:34:43 <roconnor> where f | b = (+)  | otherwise = (-)
16:34:48 <roconnor> kallisti: I like this
16:34:49 <roconnor> well
16:34:50 <kallisti> dmwit: you are? where
16:34:54 <roconnor> where (<>) | b = (+)  | otherwise = (-)
16:34:57 <dmwit> on paper
16:35:23 <kallisti> dmwit: impressing. but can you go deeper? we are remaking Guardception.
16:35:47 <hpc> a 'where' within a 'where'
16:35:59 <dmwit> Don't worry. I'll use three different indentation levels. It will protect against all but the most sophisticated attacks!
16:36:02 <roconnor> where (<>) | check = (+)  | otherwise = (-)  where check | b = True | otherwise = not otherwise
16:36:09 <hpc> @let inception = text . map toUpper . intersperse ' '
16:36:12 <lambdabot>  Defined.
16:36:22 <hpc> > inception "inception"
16:36:24 <lambdabot>   I N C E P T I O N
16:36:26 <roconnor> er sorry
16:36:31 <roconnor> where (<>) | check = (+)  | otherwise = (-)  where check | b = otherwise | otherwise = not otherwise
16:36:41 <kallisti> otherwise = not otherwise   -- that's a nice little gem
16:37:02 <roconnor> kallisti: | otherwise = not otherwise -- the | is important
16:37:20 <kallisti> yes yes
16:38:00 <hpc> > let true false | otherwise = not otherwise in true otherwise
16:38:01 <lambdabot>   False
16:38:37 <mhitza> hpc what the hell does that mean?
16:38:54 <mhitza> you lost me there all the way
16:39:02 <_Mikey> me too
16:39:09 <kallisti> it means a lot of nothing.
16:39:18 <hpc> true = const False
16:39:18 <mhitza> it's cryptomagic haskell night apparently
16:39:28 <dmwit> mhitza: It defines a function named "true"; in all cases, this function takes an argument named "false" and returns the Haskell value False.
16:39:51 <Saizan> > otherwise
16:39:52 <lambdabot>   True
16:40:07 <_Mikey> not bad
16:40:09 <dmwit> mhitza: But first, it checks whether the guard "otherwise" is True (which it is, by definition), and evaluates "not otherwise" instead of returning the constant value False.
16:40:10 * kallisti has produced only elegant program fragments throughout this conversation, thank you very much.
16:40:25 <shachaf> @let otherfoolish = not otherwise
16:40:26 <lambdabot>  Defined.
16:40:51 <hpc> @remember shachaf @let otherfoolish = not otherwise
16:40:52 <lambdabot> Done.
16:41:06 <dmwit> @let otherwise == not = not otherwise
16:41:08 <lambdabot>  Defined.
16:41:20 <dmwit> > x (L.==) f
16:41:22 <lambdabot>   Couldn't match expected type `(t1 -> (t1 -> t11) -> t11) -> a -> t'
16:41:22 <lambdabot>        ...
16:41:27 <shachaf> > x L.== f
16:41:28 <lambdabot>   Ambiguous type variable `t1' in the constraints:
16:41:29 <lambdabot>    `SimpleReflect.FromExpr...
16:41:29 <mhitza> dmwit, after the `not otherwise in` what happens? Isn't it recalling itself causing an infinite loop?
16:41:32 <shachaf> > x L.== f :: Expr
16:41:34 <lambdabot>   f x
16:41:42 <c_wraith> > 1 == 2
16:41:42 <lambdabot>   Ambiguous occurrence `=='
16:41:43 <mhitza> dmwit, that's the way I've read it and got confused
16:41:43 <lambdabot>  It could refer to either `L.==', defined at <loc...
16:41:44 <dmwit> mhitza: No, "otherwise" is not being bound by anything.
16:41:51 <c_wraith> @flush
16:41:51 <lambdabot> Not enough privileges
16:41:54 <dmwit> mhitza: "otherwise" is a variable defined in the Prelude.
16:41:55 <c_wraith> err, wrong command
16:41:58 <dmwit> ?src otherwise
16:41:59 <lambdabot> otherwise = True
16:42:02 <Saizan> @undef
16:42:07 <c_wraith> that's the one I wanted
16:42:09 <c_wraith> > 1 == 2
16:42:11 <lambdabot>   False
16:42:14 <c_wraith> much better
16:42:40 <dmwit> mhitza: So, it's equivalent to writing this:
16:42:44 <dmwit> true false | True = not True
16:42:56 <dmwit> Which, since the guard is sort of silly, is equivalent to writing
16:43:00 <dmwit> true false = not True
16:43:04 <dmwit> so
16:43:07 <dmwit> true false = False
16:43:08 <dmwit> so
16:43:11 <dmwit> true _ = False
16:43:16 <dmwit> And now it's vaguely readable.
16:43:38 <mhitza> so the rest after `in` is never evaluated?
16:43:46 <dmwit> eh?
16:43:52 <dmwit> > let true _ = False in true otherwise
16:43:54 <lambdabot>   False
16:44:14 <mhitza> oh right, I've been confusing it with let ... in
16:44:30 <kallisti> > let {{{ x = 2 }}} in x
16:44:32 <lambdabot>   <no location info>: parse error on input `{'
16:44:36 <kallisti> aww
16:44:43 <kallisti> > let { x = 2 } in x
16:44:45 <lambdabot>   2
16:44:48 <kallisti> I guess only one level of emphasis will have to do.
16:45:28 <hpc> > 1 L.== 2
16:45:31 <lambdabot>   Not in scope: `L.=='
16:45:38 <hpc> oh derp, scrolled up
16:45:51 <kallisti> > do let in voodoo
16:45:52 <lambdabot>   Not in scope: `voodoo'
16:46:15 <hpc> > do do that voodoo
16:46:16 <lambdabot>   that you do so well
16:46:40 <kallisti> hpc: why is it defined for you and not for me?
16:46:45 <hpc> because im magic
16:46:51 <kallisti> :_(
16:46:58 <hpc> also because i used @let
16:47:09 <hpc> in a private chat
16:47:13 <aib> can't sleep without learning this: I want to do:   λx -> (f1 x) `op` (f2 x)   is there a way to somehow "compose" f1, op and f2 and to get this function without using lambda?
16:47:16 <mhitza> I tought that read like this let true fals | x = not True in true x
16:47:33 <kallisti> aib: op `on` f
16:47:34 <mhitza> but seeing it ain't so, I'll try to read it again in the morning with a fresh mind :-)
16:47:43 <kallisti> aib: op is a function from Data.Function
16:47:44 <hpc> @pl \f1 f2 op x -> f1 x `op` f2 x
16:47:45 <kallisti> er
16:47:45 <lambdabot> flip . (ap .) . flip (.)
16:47:48 <kallisti> on rather
16:47:52 <kallisti> oh wait x
16:47:53 <hpc> @pl \f1 op f2 x -> f1 x `op` f2 x
16:47:53 <lambdabot> (ap .) . flip (.)
16:47:54 <kallisti> and two functions
16:47:55 <kallisti> nevermind
16:47:55 <kallisti> :P
16:47:59 <hpc> @pl \op f1 f2 x -> f1 x `op` f2 x
16:48:00 <lambdabot> liftM2
16:48:03 <kallisti> disregard me.
16:48:05 <hpc> oooooooooh
16:48:24 <hpc> if you want f1 == f2, use on
16:48:25 <hpc> @src on
16:48:27 <lambdabot> (*) `on` f = \x y -> f x * f y
16:48:39 <hpc> or something like that
16:48:41 <kallisti> hpc: nice. I've never noticed that one.
16:48:48 <kallisti> (the liftM2 that is)
16:48:58 <hpc> yeah, i didn't either
16:49:33 <hpc> now that i look at it, it makes perfect sense though
16:49:59 <hpc> liftM2 op x y = (run x) `op` (run y)
16:50:10 <hpc> kind of
16:50:19 <hpc> ignore my reasoning
16:50:24 <roconnor> I wish `liftM2 (*)` was allowed
16:50:24 <kallisti> heh
16:50:35 <kallisti> roconnor: it's not?
16:50:40 <roconnor> nope
16:50:45 <roconnor> er
16:50:46 <kallisti> :t liftM2 (*)
16:50:47 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
16:50:48 <roconnor> that was meant to be infix
16:50:52 <aib> ah. well, f1 != f2
16:51:00 <roconnor> I wish x `liftM2 (*)` y was allowed
16:51:11 <aib> though I did not know about on, thanks. I'd also forgotten about @pl, obviously
16:51:25 <kallisti> aib: also you can use the function instance for join for extra point-freeage
16:51:34 <kallisti> join f x = f x x
16:51:36 <shachaf> roconnor: You can emulate it with infix operators!
16:51:53 <kallisti> > join ((*) `on` f) x
16:51:54 <lambdabot>   Ambiguous type variable `b' in the constraints:
16:51:55 <lambdabot>    `SimpleReflect.FromExpr ...
16:51:57 <kallisti> > join ((*) `on` f) x :: Expr
16:51:59 <lambdabot>   f x * f x
16:52:04 <roconnor> shachaf: yep, it is a bit scary though.
16:52:07 <hpc> (that's just join's definition for ((->) e) (oh god the parentheticals))
16:52:30 * roconnor runs join on hpc to flatten the parentheticals
16:52:37 <kallisti> hpc: (I had hoped it was understood)
16:53:36 <aib> am I supposed to be able to answer ":t (flip . (ap .) . flip (.))" without using pen and paper?
16:53:46 <kallisti> no
16:53:57 <aib> good :)
16:54:23 <aib> well, thanks. I'll stick to the lambda version :D
16:54:28 <roconnor> thinks flip indicates code smell
16:54:38 <kallisti> aib: awww but join ((*) `on` f)  is nice... come on
16:54:58 <hpc> roconnor: flip is only a code smell when it's used to reverse argument order
16:55:08 * kallisti prefer (`f` x) to flip f x
16:55:09 <hpc> when it's used as a badass functor trick, though...
16:55:10 <kallisti> *prefers
16:55:14 <roconnor> I'm a BKW type of guy.  Screw C.
16:55:43 <kallisti> I think (`f` x) is less smelly.
16:55:58 <hpc> i think backticks are smellier than flip
16:56:04 <hpc> but (<> x) is nice
16:56:28 <kallisti> hpc: where (<>) = flip f I assume. :P
16:56:35 <aib> > ((*) `on` f) :: Expr
16:56:36 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
16:56:37 <lambdabot>         against inferred ...
16:56:43 <roconnor> http://1.bp.blogspot.com/-5w2kF9RZaPI/Tfm1CTYEP6I/AAAAAAAAAC0/QAgBeJv6-ps/s200/card_S.png
16:56:43 <kallisti> aib: needs an argument
16:56:44 <hpc> kallisti: where (<>) = f
16:56:49 <kallisti> hpc: oh yes.
16:56:50 <kallisti> my bad
16:57:06 <shachaf> > let (≪) = flip id; (≫) = id in Just 5 ≪liftM2 (*) ≫ Just 6
16:57:09 <lambdabot>   Just 30
16:57:23 <roconnor> shachaf: those symbols are not so bad
16:57:41 <shachaf> roconnor: They're the wrong width in a monospace font, though.
16:57:43 <hpc> you can even type them if you use agda's unicode stuff!
16:57:47 <shachaf> I tried « but it's in the wrong category.
16:58:06 <roconnor> I wish agda's unicode stuff was TeXmacs unicode stuff
16:58:19 <shachaf> > let (≺) = flip id; (≻) = id in Just 5 ≺liftM2 (*)≻ Just 6
16:58:21 <lambdabot>   Just 30
16:58:24 <shachaf> Nah, too close to <
16:58:47 <aib> > ((-) `on` id) :: Expr
16:58:48 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
16:58:50 <lambdabot>         against inferred ...
16:58:50 <aib> meh
16:58:55 <kallisti> aib: it's a function
16:59:05 <roconnor> «»
16:59:17 <kallisti> > ((-) `on` id) 2 2
16:59:20 <shachaf> roconnor: Doesn't work. :-(
16:59:22 <lambdabot>   0
16:59:29 <roconnor> shachaf: stupid
16:59:36 <aib> I just don't know how Expr works :(
16:59:45 <kallisti> aib: Expr is an instance of Num
16:59:53 <kallisti> > 2 :: Expr
16:59:55 <lambdabot>   2
16:59:59 <kallisti> > 2 + 2 :: Expr
17:00:00 <lambdabot>   2 + 2
17:00:01 <shachaf> #haskell-how-expr-works
17:00:13 <shachaf> aib: You should consider it a fun puzzle and figure it out.
17:00:20 <aib> I will
17:00:40 <kallisti> shachaf: what, I can't just tell him how it works? what kind of programming language channel IS this.
17:00:51 <hpc> aib: to make it easier, don't worry about getting the parenthesis right
17:00:59 <hpc> > foldr (+) 0 [x, y, z]
17:01:00 <lambdabot>   x + (y + (z + 0))
17:01:05 <hpc> > foldl (+) 0 [x, y, z] -- vs
17:01:06 <lambdabot>   0 + x + y + z
17:01:19 <Brolapse_> interessant
17:01:23 <Brolapse_> interdasting
17:01:26 <aib> alright :)
17:01:28 <hpc> muy es interessant
17:01:53 <hpc> (yes, that was deutcshpanol)
17:02:24 <Brolapse_> http://pastebin.com/SLsahL8P
17:02:26 <mauke> The paste SLsahL8P has been copied to http://hpaste.org/65654
17:02:40 <Brolapse_> obv doesnt work, i just don't know a simple way of comparing month to the 3 months
17:03:00 <hpc> Brolapse_: step 1, spaces instead of tabs
17:03:06 <hpc> step 2, you want
17:03:14 <hpc> month == foo || month == bar || ...
17:03:20 <Brolapse_> ah soi gotta rwite it out that way
17:03:29 <Brolapse_> wow i am good at writing things + coding today
17:03:46 <kallisti> month `elem` [foo, bar, ...]
17:03:54 <hpc> also that
17:04:08 <eyu> > fix (\x -> Just (case x of {Just _ -> (); Nothing -> ()}))
17:04:08 <hpc> if you want to be all elegant and such
17:04:09 <lambdabot>   Just ()
17:04:34 * kallisti is all about that elegance.
17:16:28 <dmwit> > fix (\x -> Just (case x of Just _ -> (); Nothing -> error "never get into this branch"))
17:16:29 <lambdabot>   Just ()
17:39:33 <yasar> Hi, this is the first time I am looking into haskell. I have red through introduction in haskell wiki. It sounds good, but, I am not sure. Do you think it would worth learning it. In what kinds of purposes the haskell is being used?
17:40:28 <shachaf> yasar: You might consider reading the FAQ. It's a bit hidden away, but you can find it at:
17:40:31 <shachaf> @where faq
17:40:32 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:40:54 <yasar> Ohh, I see. I am looking into it right now.
17:41:20 <nyingen> so what's this I hear about how we're not supposed to use fromJust
17:43:25 <irene-knapp> @faq can the bot link me to the FAQ?
17:43:26 <lambdabot> The answer is: Yes! Haskell can do that.
17:43:28 <parcs`> because it provides a crappy error message in the case that it is Nothing
17:43:37 <nyingen> oh, is that all?
17:44:17 <parcs`> no. ideally you should not resort to runtime exceptions, but there are cases where using something like fromJust makes practical sense
17:44:34 <nyingen> like when you know it's always going to be a Just
17:44:44 <shachaf> parcs`: let Just x = ... is better than let x = fromJust ...
17:45:30 <roconnor> sometimes I write let Just url = parseURL "http://haskell.org/"
17:45:41 <roconnor> sometimes I do it as a top-level definition too
17:47:28 <shachaf> roconnor: One of the advantages is that a pattern-match failure will give you the line it happened on.
17:47:45 <roconnor> yay
17:48:51 <shachaf> roconnor is not impressed.
17:51:02 <Saizan> fromJust : {x : a} -> (m : Maybe a) -> m = Just x -> a
17:51:09 <parcs`> in a semi-perfect world all runtime exceptions would come with a backtrace
18:04:25 <Anon_> hello
18:05:32 <Anon_> help?
18:05:33 <Anon_> help
18:06:21 <dmwit> Hiya, Anon_!
18:07:10 <Anon_> I'm learning haskell
18:07:21 <Anon_> though, I don't know what it is yet
18:07:45 <dmwit> Hm. How are you learning it?
18:08:02 <Anon_> im at tryhaskell.org/#19
18:08:20 <dmwit> Ah, cool. Then you certainly must know that Haskell is a programming language by now. =P
18:08:46 <Anon_> yeah
18:08:58 <Anon_> im guessing you're expert?
18:09:18 <dmwit> I know a few things.
18:09:33 <Anon_> how far are you at?
18:09:37 <Mathnerd314> @karma dmwit
18:09:37 <lambdabot> dmwit has a karma of 20
18:09:40 <Anon_> like the steps
18:10:13 <parcs`> Anon_: this channel isn't exclusive to people who are from tryhaskell.org
18:10:29 <dmwit> I've never done tryhaskell, though I expect I could finish any challenge it has.
18:11:03 <Anon_> Ah i see, I mean..the tryhaskell was instructing me to type "chat" if I'd like to chat with people with programming knowledge
18:11:04 <mauke> ooh, there are challenges?
18:11:48 <Anon_> @dmwit what programming languages do you know?
18:11:49 <lambdabot> Unknown command, try @list
18:11:56 <Anon_> dmwit what programming languages do you know?
18:12:36 <dmwit> Well, Haskell, for one. =)
18:12:57 <mauke> ALL OF THEM
18:13:25 <Anon_> dmwit haha nice
18:13:35 <Anon_> mauke really? list them :P
18:14:19 <dmwit> I dunno if having everybody boast is really that productive...
18:15:14 <mauke> basic, sh, c, c++, pascal, ocaml, perl, brainfuck, java, javascript, x86 asm, false, lisp, php, vimscript
18:15:51 <dmwit> I bet you know LaTeX.
18:16:03 <mauke> not really. I can copy/paste LaTeX, though
18:16:15 <mauke> and while I'm lying:
18:16:46 <nyingen> I see you didn't bother to learn python. good for you. :)
18:17:03 <mauke> awk, intercal, python, ruby, latex, c#, java2k, sorted!, piet
18:17:18 <dmwit> I was surprised that Python and Ruby weren't in your previous list. =)
18:17:23 <nyingen> really, piet?
18:17:26 <mauke> no
18:17:42 <mauke> this is the list of languages I've heard of and maybe written a "hello world" level program
18:18:07 <Anon_> ahh
18:18:18 <mauke> dmwit: they didn't seem very interesting for someone who already knows perl
18:18:19 <Anon_> I'm only at intro to Java right now
18:18:26 <hpc> haha
18:18:33 <hpc> mauke: so true
18:18:52 <mauke> languages I fail at: prolog, forth, tamerlane
18:19:20 <mauke> and anything beyond haskell (agda, coq, etc.)
18:19:34 <Mathnerd314> missing: cobol, fortran, algol
18:19:39 <Jafet> I can write hello world in C++ templates
18:19:50 <yasar> So, I am trying haskell, and I have my mind blowed here: http://tryhaskell.org/#32 , I can't grasp what exactly does this mean-> :: (a -> b) -> [a] -> [b]
18:20:00 <Anon_> lol, you guys are way way above me
18:20:11 <mauke> Mathnerd314: I actually read an algol book!
18:20:29 <shachaf> yasar: It means :: (a -> b) -> ([a] -> [b])
18:20:34 <Jafet> mauke: the Revised Report?
18:20:44 <hpc> yasar: it's the type of the function 'map'
18:20:46 <mauke> Jafet: no, I think it was a german book
18:20:50 <hpc> [a] is a list of things of type 'a'
18:20:51 <mauke> relatively old
18:20:59 <hpc> a -> b is a function from 'a' to 'b'
18:21:01 <gwern> @quote emission
18:21:01 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
18:21:22 <hpc> > map (* 2) [1, 2, 3, 4, 5] -- and this is what it does
18:21:23 <lambdabot>   [2,4,6,8,10]
18:21:29 <Jafet> Are you sure it was german? If it was the RR, it could have been dutch
18:22:05 <Anon_> map let (a,b) = (10, 12) in a * b / 3.14
18:22:13 <yasar> so it says that map is a function that takes an function of a to b and returns a function that takes a list of a's and returns a lists of b's , am I correct?
18:22:33 <mauke> yasar: yes
18:22:34 <hpc> yasar: indeed
18:22:40 <yasar> wow, this is fun!
18:22:51 <mauke> map upgrades functions so they work on entire lists at once
18:23:40 <shachaf> That's a one-way upgrade, sadly. :-(
18:24:07 <mauke> unmap :: ([a] -> [b]) -> a -> b
18:24:19 <mauke> unmap f x = head (f [x])
18:24:42 <Mathnerd314> mauke: not total
18:25:09 <mauke> good enough
18:25:14 <Anon_> mauke, you think you could help me with Java programming language a bit?
18:25:26 <dmwit> Anon_: No, but ##java might.
18:25:26 <Jafet> It's totally a total inverse of map.
18:25:43 <mauke> I can System.out.println("hello world"), does that count?
18:25:44 <shachaf> Jafet: It's partially a total inverse and totally a partial inverse.
18:25:55 <Anon_> lol, something more advanced
18:26:07 <Anon_> could you?
18:26:09 <Jafet> @quote factory
18:26:10 <lambdabot> arcatan says: ManagerManager works in FactoryFactory
18:26:15 <shachaf> Anon_: This isn't really the channel for that.
18:26:47 <Anon_> So..how do I switch channel or something?
18:26:59 <yasar> So, I want to try something, can anyone suggest a (a->Bool) function so that I can throw it at filter?
18:27:06 <shachaf> const True
18:27:08 <Jafet> You need a remote control for IRC.
18:27:20 <dmwit> yasar: odd
18:27:27 <hpc> :t odd
18:27:28 <lambdabot> forall a. (Integral a) => a -> Bool
18:27:41 <hpc> (you can pretend that says Int -> Bool)
18:27:42 <mauke> ooh, it uses the standard webchat
18:27:48 <josh__> Hello all, I'm working my way through "Haskell: The Craft of Functional Programming" (good book btw), but I'm having trouble with combining type classes on tuples
18:27:50 <mauke> Anon_: /join ##java
18:27:51 <Anon_> oh man, this is the first time using IRC or something rather
18:28:01 <yasar> hpc: tnaks!
18:28:11 <yasar> hpc: *Thanks.
18:28:12 <mauke> Anon_: hopefully it will use a standard tab-based display
18:28:27 <mauke> use /part to leave a channel
18:28:45 <mauke> hah
18:28:52 <mauke> ##java is +r (only registered users can join)
18:29:10 <josh__> For instance, I can compile "instance Movable b => Movable (b, c)" and "instance Named c => Named (b, c)"  but
18:29:49 <josh__> "instance (Movable b, Named c) => NamedMovable (b, c) " gives me a type error
18:30:15 <josh__> do I need to enable any GHC extensions to combine classes in this way?
18:30:48 <hpc> josh__: yes
18:31:02 <mauke> preflex: seen chrisdone
18:31:02 <preflex>  chrisdone was last seen on #haskell 9 days, 14 hours, 45 minutes and 19 seconds ago, saying: from http://hackage.haskell.org/packages/archive/haskell-src-exts/1.11.1/doc/html/Language-Haskell-Exts-Syntax.html#g:5
18:31:07 <mauke> grr
18:31:19 <hpc> (on a more helpful note, i can't remember which you need, but you can start by googling for undecidable instances or something like that)
18:31:28 <hpc> the ghc docs should show up
18:31:35 <yasar> ":t take" command gives me "Int -> [a] -> [a]", how do I know if "it's a function of Int to a function that takes a list and returns a list" or "it's a function that takes int and list, and return a list"
18:31:58 <dmwit> yasar: It's the former.
18:32:11 <hpc> one feature of haskell is currying
18:32:22 <hpc> which is another way of saying "it's always the former"
18:32:27 <dmwit> yasar: Luckily, you can use it in the latter way anyway. There's really no difference between the true.
18:32:32 <dmwit> s/true/two/
18:32:34 <dmwit> yikes
18:32:35 <mauke> yasar: it is both
18:36:59 <speilberg0> any reason HsColour would fail to print the last line from stdin?
18:37:00 <BMeph> mauke: No icon? You make me a Sad Panda... :(...
18:37:32 <mauke> well, piet programs count as icons
18:38:36 <speilberg0> calling  tail -n 20 -f ~/.ghcioutput.log | HsColour
18:38:50 <speilberg0> wont show last line given
18:38:57 <speilberg0> although cat will
18:40:12 <yasar> hmm, so no for loop in Haskell huh?
18:40:36 <monochrom> because you can write one whenever you want.
18:40:56 <mauke> :t forM_
18:40:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
18:41:13 <hpaste> shergill pasted “attempt to cache result of io computations” at http://hpaste.org/65659
18:42:36 <shergill> can someone spare a few minutes and go through the code posted above? i'd like to cache the result of calling the function getBOFHExcuses. i managed to accomplish that, however i'd like to cache it across invocations of 'main'
18:43:02 <shergill> i'm not sure how to accomplish that in pure code
18:43:05 <BMeph> mauke: No, I meant tha tin your list of languages you've not never heard of, you did not list SNOBOL 6, AKA "icon"
18:43:19 <mauke> I know :-)
18:43:40 <danharaj> Is there a cheatsheet for using git+hub?
18:43:54 <danharaj> I pick it up every few months but then drop it because I forget how to use it.
18:43:55 <monochrom> "across invocations of main" would need saving to a file and reading back, no?
18:44:22 * BMeph gets a crowd of University of Arizona alumni to throw eggs at mauke's house...some of them NOT hard-boiled!
18:44:23 <mauke> danharaj: I always click on "help" or whatever it's called
18:44:26 <shergill> monochrom: well main is in a loop calling itself, if it can cache across those calls i'd be happy
18:44:50 <shergill> i'm just not sure how to pass state from one call on to the other for main
18:45:03 <monochrom> then shouldn't you just merge the two runStateT's into one?
18:45:30 <shergill> monochrom: that was just to check if the caching works within the call to main
18:45:40 <monochrom> is your cache already in s1? then just passing it to the second runStateT should do
18:45:52 <shergill> right. and it does
18:46:28 <shergill> i'd like to pass s1 (or s2) on to when main calls itself
18:46:57 <shergill> when main calls itself, runStateT again has the initial state of 'Nothing'
18:47:09 <monochrom> main cannot take further parameters. write one more function for the loop
18:47:36 <mm_freak> yasar: f x y = (f x) y
18:47:44 <mm_freak> and a -> b -> c = a -> (b -> c)
18:48:05 <monochrom> main = go Nothing; go s1 = do { (e, s2) <- runStateT getBOFHExcusesC s1; go s2 }
18:48:56 <shergill> ah right
18:50:41 <gwern> @quote
18:50:41 <lambdabot> JohnMeacham says: There will also be a karaoke competition to determine the fate of the monomorphism restriction.
18:50:54 <monochrom> hahahaha
18:51:05 <yasar> this "lazy evaluation" thing is done in compile time, or in runtime?
18:51:29 <mauke> ?
18:52:27 <rasfar> runtime, but the compiler sets it up, so both i guess
18:52:45 <monochrom> (lionel richie) ♪ Hello ♪ is it monomorphism you're looking for? ...
18:53:15 <shergill> monochrom: hmm the reason i was doing it in main was because i'd like the control to return to main (so i can do other stuff). the suggestion you gave will keep the program in an endless loop outside of main. is there a way to save state across function calls without saving to an external file?
18:53:58 <monochrom> all the functions involved should know about that state, so as to pass around properly
18:54:20 <monochrom> unless you use top-level unsafePerformIO to obtain a global variable for that
18:56:02 <monochrom> it is not so questionable to change from "control return to main, where I may do other stuff" to "control return to go, where I may do other stuff", no?
18:57:13 <shergill> well i'd like to call this function from another module, and i don't want the calling function/module to have to keep track of the state
18:57:35 <shergill> 'this function' = getBOFHExcusesC
18:59:17 <monochrom> there is always the unsafePerformIO global variable trick for the last resort, but I'll tell you a story
19:00:05 <monochrom> once upon a time, a common DNS library (client-side) was like that, has a global variable, not really for cache, for config variables instead
19:01:38 <monochrom> so typically you call "set(OPTIONNAME, 0)" to config, then you can call "lookup(string)", without passing around a reference/handle to a config block
19:01:48 <shachaf> "Crime doesn't pay" -- http://community.haskell.org/~simonmar/papers/aos.pdf
19:02:07 <monochrom> then one day, multithreading came around, and that design clearly collapsed
19:02:50 <monochrom> thread #1: set(OPTIONNAME, 0); lookup(x). thread #2: set(OPTIONNAME, 1); lookup(y);  not going to work
19:04:18 <monochrom> the library got revamped. all the old functions (without passing around a reference/handle to a config block) got obsoleted. obsoleted means they're now stubs that just go abort("don't use me")
19:04:57 <monochrom> new functions are introduced and they all require passing around a config block handle. every thread can use its own config block.
19:06:39 <monochrom> as a consequence, old user code is all broken, for example eggdrop. eggdrop hasn't been updated to use the new paradigm. and that's how I know the whole story. I tried to run eggdrop, got a "don't use me" message and abortion
19:07:25 <monochrom> the solution is to go back in time and use the sustainable paradigm right at day 1.
19:07:43 <JoeyA> Why doesn't the old API just use a global mutex?  It's slower, but at least it doesn't break stuff.
19:08:11 <monochrom> I don't know. that may work.
19:13:01 <gwern> @quote
19:13:01 <lambdabot> FogCreek says: Since throwing away a large code base and starting from scratch is typically a bad idea, the final decision was to have an intern write a compiler to translate a subset of ASP into
19:13:02 <lambdabot> PHP.
19:18:23 <JoeyA> Do I have to worry about translating the comments, too?
19:18:37 <JoeyA> s/Microsoft/Zend/
19:18:40 <eyebloom> What is the best strategy for finding infinite loops?
19:21:49 <monochrom> again?
19:22:26 <monochrom> what is the best strategy for finding infinite loops of "what is the best strategy for finding infinite loops"?
19:23:54 * dfletcher has a personal problem. his infinte loops are short.
19:24:49 <eyebloom> Seems like a straightforward question.
19:24:50 <JoeyA> Sprinkle your code with trace calls.  That may be a good start.
19:25:07 <JoeyA> But I don't know the best strategy.  I don't run into infinite loops much.
19:25:43 <sheaf> I want to have a type to be (in essence) determined at runtime, and I don't have any idea how to do it
19:25:50 <sheaf> I read some sort of config, say data Config a = Config { scheme :: a }
19:26:04 <sheaf> and then have a rendering routine that would look something like
19:26:07 <sheaf> render :: (Scheme a, b ~ AssociatedData a) => Config a -> Renderer b
19:26:31 <sheaf> how would I make that kind of thing work with 'a' somehow determined at runtime?
19:26:34 <eyebloom> JoeyA: That's not working for me, in this case. And some of the tutorials for breaking in ghci don't seem to be working for me.
19:26:48 <edwardk> sheaf: one way to do this is to make runtime into compile time and use something like dyre.config
19:27:10 <edwardk> sheaf: then you can put pretty much any haskell you want into your app's config file
19:27:45 <edwardk> otherwise, you're stuck making an actual ADT or choosing between a fixed set of combinations of types
19:28:33 <edwardk> ultimately, you can punt that decision to whatever calls render though
19:29:47 <sheaf> well, I'd rather avoid recompiling upon change of configuration (if I understand that that's what would be involved with the first option)
19:30:17 <sheaf> so what's the alternative exactly?
19:31:38 <sheaf> I had considered doing something like changing 'a' to say Either A B, but then I don't (think I) can have (Scheme Either A B) so I'm not sure what I'm doing
19:31:45 <sheaf> sorry for not understanding
19:43:13 <yasar> can you invent your own types in haskell?
19:44:16 <eyebloom> Yes
19:44:20 <lifestream> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
19:44:51 <eyebloom> What kind of type do you want to invent?
19:45:30 <yasar> eyebloom: Nothing particular, I was reading http://book.realworldhaskell.org/read/types-and-functions.html ,and the question popped into my mind.
19:49:06 <eyebloom> You can both create types. And create simple functions over types.
19:53:44 <axx__> set(OPTIONNAME, 0)
19:59:46 <nyingen> @quote
19:59:46 <lambdabot> GeDaMo says:  That's it! You people have stood in my way long enough. I'm going to clown college!
20:03:15 <yasar> When I say "compare (sqrt 3) (sqrt 6)" does it calculate square root of 3 and 6 and compare them, or since "3 < 6" means (sqrt 3) < (sqrt 6) and this would return LT without calculatig sqrt?
20:04:06 <c_wraith> yasar: it's not magic.  there's no monotonicity property propogated by the compiler.
20:04:14 <nyingen> yasar: it calculates the roots
20:04:22 <edwardk> yasar: it knows nothing about sqrt as a function, so it does the work
20:04:47 <edwardk> yasar: if you have a high enough -O2-like level it may evaluate that at compile time though
20:05:49 <yasar> I see.
20:06:11 <eyebloom> yasar: you would need to create a sqrt type and an instance of Eq. In order to compare sqrts without first reducing them.
20:06:50 <yasar> ha ha. Haskell is awesome!
20:06:59 <eyebloom> data Sqrt = Sqrt Float
20:12:45 <Sgeo> c_wraith, any languages that could propagate that sort of information at compile-time?
20:14:01 <BMeph> Maude can.
20:14:02 <c_wraith> Sgeo: Nothing comes to mind in the traditional compiled space.  Computer algebra systems like mathematica might.
20:14:33 * BMeph pauses to recall if Maude compiles...
20:25:41 <nyingen> @quote
20:25:41 <lambdabot> Heffalump says: (re the RealWorld# token) The compiler knows that it can implement the token using the  arrow of time
20:27:15 <tgeeky> @quote professor
20:27:15 <lambdabot> DanielFranke says: Genuine quote from my old logic professor: “Haskell? Oh, must be named for Haskell Curry. Good guy. I dated his daughter.”
20:27:31 <nyingen> heh
20:28:20 <nyingen> A professor I worked with once told me something like that, except that it was "i fucked his daughter" instead of "dated"
20:33:24 <BMeph> Does anyone here have a go-to operator alias for 'uncurry'?
20:34:00 <gwern> 'The same holds true for Erlang. I've had cases where I've looked at the code for the entire day and then modified three lines.  Of course, because it is Erlang (and, therefore, slightly magic), those three modifications turned the system from a single-machine distributed system to a multi-machine distributed system with redundancy checking.  I despise and, at the same, deeply love Erlang.'
20:56:15 <nyingen> @quote
20:56:15 <lambdabot> PaulPotts says: Haskell is an even "redder" pill than Lisp or Scheme
21:01:05 <yasar> Is this a good way to get the element before the last: last (take ((length xs) -1) xs) or would you do it otherwise?
21:01:51 <shachaf> yasar: No, it's a terrible way. Getting the element before last in a list is generally a terrible thing to do.
21:02:21 <shachaf> The simplest way would be something like (last . init) or (!!1).reverse
21:02:57 <yasar> I am just trying to do the exercise here: http://book.realworldhaskell.org/read/types-and-functions.html
21:03:48 <shachaf> yasar: Well: Computing the length of a list is an evil thing to do.
21:04:20 <jmcarthur> not always evil
21:04:25 <jmcarthur> just... usually :)
21:04:41 <shachaf> Right.
21:04:52 <yasar> Ok, I see. But I couldn't understand your examples, I am haskell user for just couple of hours now :)
21:04:54 <jmcarthur> it's reasonable basically when it's the last thing you intend to do with the list
21:04:58 <shachaf> For example, if your goal is to compute the length of a list, computing the length of a list is a pretty good way to do it.
21:05:13 <yasar> ha ha :)
21:05:26 <jmcarthur> same for indexing
21:05:40 <jmcarthur> it's reasonable when it's pretty much the last thing you do with the list
21:06:00 <nyingen> why/
21:06:01 <nyingen> ?
21:06:05 <eyebloom> They say evil, but they mean, not lazy. Haskeller like to put everything off until just a little later.
21:06:07 <yasar> so, how does (!!1).reverse works?
21:06:14 <jmcarthur> maybe some other times, too, but this describes most cases that i think it's reasonable
21:06:46 <jmcarthur> nyingen: because then you aren't forcing the list and holding it all in memory. and also because it means you aren't doing silly things like traversing the list many times
21:06:48 <shachaf> yasar: If this is an exercise, should I be telling you? :-)
21:06:58 <shachaf> yasar: Just take it into pieces and figure out how each piece works.
21:07:46 <jmcarthur> > iterate (*2) 1 !! 10  -- reasonable use of indexing
21:07:47 <lambdabot>   1024
21:08:02 <yasar> Ok, just tell me one thing then, is "(last . init) or (!!1).reverse" two seperate statement that I could use either one, or is it just one compound statement that uses "or"
21:08:17 <jmcarthur> two separate ones
21:08:25 <yasar> ok thanks.
21:08:39 <jmcarthur> > last (init [a,b,c,d,e,f])
21:08:40 <lambdabot>   e
21:08:51 <jmcarthur> > reverse [a,b,c,d,e,f] !! 1
21:08:53 <lambdabot>   e
21:09:01 <eyebloom> yasar: It's helpful to look at the source for each function in an expression. Including the source for . (function composition) that helps you break it down.
21:10:05 <jmcarthur> i claim that (last . init) is a terrible way to do this (but not as terrible at taking the length and then indexing unless you are using genericLength and indexing with lazy naturals), by the way :)
21:10:17 <jmcarthur> err
21:10:19 <jmcarthur> i take it back
21:10:29 <jmcarthur> i've been using ocaml too much
21:11:03 <yasar> Ok, I see what init does (removes last element right?) but I am not familiar with !! syntax.
21:11:09 <jmcarthur> :t (!!)
21:11:10 <lambdabot> forall a. [a] -> Int -> a
21:11:16 <jmcarthur> :t init
21:11:17 <lambdabot> forall a. [a] -> [a]
21:11:19 <jmcarthur> :t last
21:11:20 <lambdabot> forall a. [a] -> a
21:11:30 <JoeyA> !! is an infix operator that extracts the Nth element (and takes O(n) time to do it)
21:11:41 <JoeyA> > [0,1,2,3] !! 2
21:11:42 <lambdabot>   2
21:11:42 <eyebloom> !! is just lookup
21:11:48 <JoeyA> :t lookup
21:11:49 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
21:11:57 <JoeyA> Lookup is different
21:13:00 <jmcarthur> !! is just \xs n -> fromJust . lookup n $ zip [0..] xs
21:13:00 <eyebloom> Ok subscript. Takes a list and an index and returns an element.
21:14:02 <yasar> so, when I say "reverse [1,2,3,5] !! 1" , does full list get reversed before I access get the first element, or just enough of the list gets reversed to get first element?
21:14:41 <eyebloom> That depends on precedence. But in this case yes.
21:15:00 <jmcarthur> how does it depend on precedence?
21:15:28 <jmcarthur> yasar: it has no idea what element is at index 1 unless it at least traverses the whole list to the end
21:15:31 <jmcarthur> @src reverse
21:15:32 <lambdabot> reverse = foldl (flip (:)) []
21:15:43 <eyebloom> if !! had a higher precedence than application it would evaluate first.
21:15:47 <jmcarthur> ... not the most helpful definition for beginners i guess
21:16:09 <jmcarthur> eyebloom: no operator has higher precedence than application, for one. for another, precedence has nothing to do with evaluation in haskell
21:16:45 <eyebloom> Of course it does.
21:16:46 <jmcarthur> > "foo" ++ undefined  -- if precedence defined evaluation order, this would not output "foo" before erroring
21:16:48 <lambdabot>   "foo*Exception: Prelude.undefined
21:17:20 <jmcarthur> (++ is right associative)
21:18:12 <eyebloom> If you are new to the language you might confuse (reverse [a,b,c,d,e,f]) !! 1 with reverse( [a,b,c,d,e,f] !! 1).
21:18:36 <eyebloom> Even though to a seasoned programmer this is an obvious type error.
21:18:59 <jmcarthur> but that's a matter of writing different programs entirely. comparing evaluation orders doesn't even make sense then
21:19:48 <eyebloom> That's just what I understand his question to be, about which program it is.
21:20:04 <jmcarthur> i took it to be a question about laziness
21:20:05 <monochrom> precedence has nothing to do with evaluation in anywhere, too.
21:20:23 <jmcarthur> monochrom: ah, indeed
21:20:27 <monochrom> 0*(23098493+320849032)  are you seriously going to evaluate 23098493+320849032 first?
21:20:47 <jmcarthur> well, some languages may define it to work that way...
21:21:00 <monochrom> sure, but I'm saying you
21:21:04 <jmcarthur> but of course if you moved the parens around you'd get a different result anyway
21:21:43 <monochrom> the real story is you first get a parse tree, and then you decide which part of it to evaluate first
21:22:35 <monochrom> if you decide to always evaluate subtrees first, sure, I respect that decision. but precedence is only there for establishing the parse tree
21:23:18 <jmcarthur> agreed
21:23:51 <BMeph> Does anyone here have a go-to operator alias for 'uncurry'?
21:24:31 <monochrom> in C, 1 ? (z * a) : (b / c) does not evaluate b/c ever, so nevermind first or last or in the middle
21:25:20 <sipa> BMeph: ?
21:25:59 <BMeph> sipa: What, did I stutter? ;)
21:26:13 <sipa> what is a go-to operator alias?
21:27:42 <edwardk> sipa: one that you prefer or use often
21:27:47 <BMeph> sipa: An other way to write (alias) a function in non-letter form (operator) that you use in preference to just using what is given to you (go-to).
21:27:50 <edwardk> BMeph: `uncurry`
21:28:33 * BMeph suspects edwardk never uses a big word, when he can use a diminutive one instead... ;þ
21:29:09 <edwardk> eschew obfuscation
21:30:33 <BMeph> edwardk: "eschew" -- Gesundheit. ;)
21:32:51 <JoeyA> Never use a big word where a diminutive one would suffice (that's the quote as I learned it)
21:35:42 <jmcarthur> i always just use uncurry, myself
21:40:00 <litselle> Can't write to trac, but I'd like to make known that the bug "RTS crash w/ strange closure type 603975781 on OS X 10.8" is not limited to GHC 7.4, it manifests equally with 7.2 and 7.0. both i386 and x86_64.
21:40:32 <litselle> So this means that there is NO working GHC for OS X 10.8 at the moment
21:46:40 <gng314> All, question regarding type classes. Am reading this - http://learnyouahaskell.com/making-our-own-types-and-typeclasses
21:47:20 <gng314> When I try the 'Eq' typeclass example, I get the following error- Equal.hs:4:25:
21:47:20 <gng314>     Ambiguous occurrence `/='
21:47:20 <gng314>     It could refer to either `Main./=', defined at Equal.hs:3:9
21:47:20 <gng314>                           or `Prelude./=', imported from Prelude
21:47:48 <gng314> How do I constrain the Eq type class to not use the Main./= or Main.== functions?
21:48:19 <shachaf> gng314: This has nothing to do with the Eq class.
21:48:38 <gng314> Thanks shachaf, I understand that
21:48:40 <shachaf> It has to do with the value that (/=) is referring to. In this case there are two values with that name.
21:48:57 <gng314> what I am looking for is to tell ghc to not look into the Prelude's functions
21:49:05 <shachaf> gng314: You can import Prelude hiding ((==),(/=))
21:49:06 <gng314> I believe that is where the ambiguity comes from
21:49:26 <shachaf> gng314: But I'd suggest just giving your own class's functions different names.
21:49:39 <gng314> Yup, that worked :)
21:49:43 <shachaf> gng314: I don't think you're meant to type that code from LYAH in -- it's just there for demonstrating purposes.
21:49:54 <shachaf> It's probably not a good idea to shadow (==) in general. :-)
21:50:00 <gng314> I was trying import Prelude hiding (==) and that failed
21:50:11 <shachaf> gng314: You need extra parentheses.
21:50:13 <shachaf> hiding ((==))
21:50:25 <gng314> Sure, I understand that, but I wanted to understand how the Eq typeclass was to be created
21:50:44 <shachaf> gng314: OK -- but you can create your own class using different names. :-)
21:50:48 <gng314> Thanks a ton for the immediate response shachaf; I was struggling a bit for this
21:50:57 <shachaf> Like class Equal a where equal :: a -> a -> Bool
21:51:32 <gng314> Ok, that means that the infix function will be called equal instead of ==  am I right?
21:53:33 <gng314> http://pastebin.com/4fsfbV26 is what I meant
21:53:36 <mauke> The paste 4fsfbV26 has been copied to http://hpaste.org/65666
21:53:59 <JoeyA> Arggh, the expander links don't work on the yesodweb blog.
21:54:28 <gng314> didn't know about hpaste - thank you :)
22:30:55 <hpaste> yasar pasted “ListADT” at http://hpaste.org/65668
22:31:50 <yasar> So I created a list like above, but when I try Cons 0 1, I get an error  No instance for (Num (List a0))
22:32:09 <yasar> What is happening?
22:42:31 <Saizan> yasar: you want (Const 0 (Cons 1 Nil))
22:43:17 <Saizan> yasar: otherwise it sees that you're trying to use 1 as a list
22:43:17 <yasar> Ohh, it's because data definition is recursive right?
22:43:24 <Saizan> ?type 1
22:43:25 <lambdabot> forall t. (Num t) => t
22:44:09 <Saizan> yasar: well, it's because your Cons has type a -> List a -> List a
22:50:10 <Wizecoder> for installing Haskell on Mac is it better to use Homebrew or the official websites version?
23:08:16 <hpaste> yasar pasted “Tree” at http://hpaste.org/65670
23:08:59 <yasar> I am trying to implement a Tree using Maybe, but I am stuck here: http://hpaste.org/65670 , can someone help?
23:14:45 <yasar> ok, nevermind. Figured it out myself.
23:37:37 <mjrosenb> yasar: another job well done on my part!
23:37:49 <shachaf> mjrosenb++
23:37:58 <shachaf> It's a good thing we've got you in here.
23:38:25 * hackagebot type-spine 0.1.1 - A spine-view on types  http://hackage.haskell.org/package/type-spine-0.1.1 (NicolasFrisby)
23:43:27 * hackagebot type-cereal 0.1.1 - Type-level serialization of type constructors  http://hackage.haskell.org/package/type-cereal-0.1.1 (NicolasFrisby)
23:43:29 * hackagebot yoko 0.3.1 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-0.3.1 (NicolasFrisby)
23:43:32 * hackagebot yoko 0.3.1.1 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-0.3.1.1 (NicolasFrisby)
23:43:34 * hackagebot yoko 0.3.1.2 - Generic Programming with Disbanded Data Types  http://hackage.haskell.org/package/yoko-0.3.1.2 (NicolasFrisby)
