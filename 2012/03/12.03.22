00:15:03 * hackagebot authenticate-oauth 1.2.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.2.0 (HiromiIshii)
00:16:55 <yasar> Trying to understand how foldr works made my brain hurt.
00:17:58 <Philippa> foldr's pretty simple. Picture a list as a tree of nodes, each : having an item and a list as children and [] and items being the leaves
00:18:08 <c_wraith> You need a good model of laziness before foldr *really* makes sense.
00:19:03 <Philippa> c_wraith: I guess? Knowing it's the one that's well-behaved for linear traversals helps, I guess
00:19:22 <Philippa> (but hey, at least "picture it as a tree" lets you carry on with a graph reduction model)
00:19:35 <Philippa> yasar: do you know where I'm going with that, or should I continue?
00:20:03 <c_wraith> Philippa: and when you start getting into folding functions that have variable strictness in their second argument, depending on their first...  You need a really solid understanding to see that.
00:20:06 <yasar> Philippa: I have no idea whar you are talking about, so I guess you should continue :)
00:21:34 <Philippa> c_wraith: point, I've not run into that case in a manner where it mattered. Mostly I'm in the fast-and-loose playground
00:22:01 <Philippa> yasar: what would happen if you did a simple search-and-replace on that tree, replacing all the :s with a function and [] with a value? (ignore infinite lists for now)
00:22:07 <c_wraith> anyway, I've taken you completely off-track for actually helping yasar.  sorry. :)
00:23:12 <Philippa> c_wraith: I do have a good enough model when I take the time to think, AFAIK. But I'm pretty lazy about keeping track of the strictness properties of stuff I code because it's not supposed to be dealing with anything that needs non-strictness
00:24:06 <yasar> Philippa: What do you mean " replacing all the :s with a function"
00:24:47 <Philippa> exactly that: you had applications of : to different values, they're now applications of f
00:25:08 <glguy_> > foldr (+) 0 (a:b:c:d:e:[])
00:25:09 <lambdabot>   a + (b + (c + (d + (e + 0))))
00:25:31 <c_wraith> > foldr (\c r -> if c == ' ' then (if null r then [] else c:r) else c:r) [] "foo bar   "  -- craziness
00:25:32 <lambdabot>   "foo bar"
00:25:43 <yasar> It's starting to make sense.
00:26:13 <mzero> be careful here with this approach to understanding
00:26:35 <c_wraith> > foldr (\c r -> if c == ' ' && null r then [] else c:r) [] "foo bar   "  -- better craziness
00:26:36 <lambdabot>   "foo bar"
00:26:48 <mzero> so foldr (+) 0    takes    a : b : c : d : d : []    into     a + (b + (c + (d + (e + 0))))
00:27:22 <mzero> you must remember that   a : b : c : d : d : []    associates as      a : (b : (c : (d : (e : []))))
00:27:27 <Philippa> c_wraith's comments about strictness matter because strictly (...) speaking foldr gives you a piece of code that munches its way through the list as you demand bits of the result, not the final tree - so if the function doesn't always terminate, you might not get as much of the result as you expected
00:27:44 <c_wraith> > foldr (\c r -> if c == ' ' && null r then [] else c:r) [] $ "foo bar   " ++ undefined
00:27:46 <lambdabot>   "foo bar*Exception: Prelude.undefined
00:27:47 <Philippa> mzero: that's why I'm saying to draw the tree, yeah
00:27:58 <mzero> yup
00:28:00 <c_wraith> partial laziness!
00:28:07 <Philippa> (also why I'd appreciate it if people didn't chuck code snippets into chan without asking me first if I'm explaining)
00:29:08 <yasar> So, to sum up, foldr translates :s into functions, as long as we demand more of the final list?
00:29:58 <Philippa> there isn't necessarily a "final list", the result might be a number. But if it's something with 'parts' then it'll still behave lazily: it'll only look at the :s it needs to in order to build the bits you're looking at
00:30:09 <Philippa> in other news, laziness is surprisingly confusing
00:30:28 <c_wraith> yasar: that's a very accurate summary
00:31:17 <Philippa> c_wraith: generalised appropriately, yeah :-) "more of the result" and it's fine - Ints are all-or-nothing, but you still accidentally the entire Int
00:31:20 <mzero> yasar - just look at the + example --- notice that the first +, the one that starts  a + (...    can't complete until the right hand side computes.... which means you don't get a result until it is all done
00:31:47 <c_wraith> yeah, I just focused on the first part - converting (:) constructors into function application
00:31:59 <mzero> but now, imagine a different function in place of +    --- one that can produce a result with a lazy value from the right hand side
00:32:12 <hpaste> yasar pasted “myTakeWhile” at http://hpaste.org/65725
00:32:27 <mzero> now you can get a result, and start using it, before the whole tree of function applications is created
00:32:52 <yasar> So above function works with infinite lists, but I don't understand how it stops the folding.
00:33:14 <Philippa> c_wraith: I got to watch Conor McBride figuring out (more of) an approach to making demand patterns typeful, btw
00:33:18 <yasar> for example, myTakeWhile_fold (<10) [1..] actually works.
00:33:52 <c_wraith> yasar: if the function ever knows what it will produce without examining its second argument, there will be no recursive call
00:34:15 <c_wraith> yasar: the recursive call is only done if the second argument needs to be evaluated
00:34:20 <yasar> Ohh, I see.
00:34:56 <c_wraith> that's where laziness really sneaks in cleverness :)
00:35:35 <c_wraith> It gives you (in this case) a way to control recursion simply by controlling what you look at.
00:36:03 <Philippa> c_wraith: or unpleasantness. Consider mapp f [] = []; mapp f [x] = [f x]; mapp f (x:x':xs) = f x:f x':mapp f xs
00:36:19 <Philippa> at first site, it looks like map = mapp, no?
00:36:23 <Philippa> *sight
00:36:41 <c_wraith> if you think strictly, yep
00:37:48 <shachaf> Or totally. :-)
00:38:07 <c_wraith> that doesn't look like it's completely strict, though - just in pairs of elements at a time.  Or am I misreading it?
00:38:34 <Philippa> c_wraith: nope, you've got the consumption pattern basically right. It's only as element-strict as f is, of course
00:38:40 <Philippa> but it eats two elements at a time
00:38:42 <c_wraith> of course
00:39:11 <Philippa> worryingly, that's /non-obvious/ from the folk version of the Report's informal equational semantics
00:40:07 <Philippa> there's also a much nastier example or two floating around, but I can't remember them right now - suffice to say, wanting to make consumption patterns typeful is really rather sensible?
00:40:44 <c_wraith> I can definitely see value in that.
00:41:02 <c_wraith> Not completely sure what it'd look like - but that's why guys like Conor McBride are working on it.
00:41:42 <Philippa> *nod*. Basically he uses applicative functors with "clocks" that count how many times you've gone round a fixpoint typefully
00:43:03 <Philippa> led_nottingham: 'lo, it's not often I see someone mentioning snotts in their nick
00:43:38 <led_nottingham> Ahoy - aye, someone already bagged led, and I was at a loss for what else to use
00:43:46 <led_nottingham> led prime seemed a bit out of sorts :P
00:44:19 <Philippa> the lack of competition for mine is a mixed bag, but hey
00:47:21 * Philippa takes a poke at led_nottingham's homepage and puts stuff on the to-read list
00:48:08 <Philippa> I guess you can find my blog as readily if you want to scare me in turn :-)
00:48:09 <led_nottingham> T'is the one paper thus far, its a short addition to the stack :)
00:48:11 <yasar> Ohh, I get it!
00:48:42 <Philippa> yasar: cool. The best bit? It turns out there's a function like foldr for every datatype you can declare with a data statement
00:49:47 <Philippa> led_nottingham: one more than I've published, so hey
00:50:13 <Philippa> but also something I've always been fairly interested in, much as I tend to muck around with typecheckers
00:50:46 <led_nottingham> Speaking of Notts, Thorsten is giving a machines and languages lecture in an hour, and I feel a need to heckle
00:50:50 <led_nottingham> Off to a bus I go!
00:50:56 <led_nottingham> back later :)
00:51:07 <Philippa> heh
00:52:47 <yasar> what kind of function can I use with groupBy, any examples?
00:54:02 <bobajett> > groupBy (<=) [1,2,3,1,2,3]
00:54:03 <lambdabot>   [[1,2,3,1,2,3]]
00:54:43 <c_wraith> bobajett: groupBy won't work how you'd expect with (<=)
00:54:57 <c_wraith> bobajett: it's only defined to work for equivalence relations
00:55:04 * hackagebot process-conduit 0.1.0 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-0.1.0 (HideyukiTanaka)
00:55:05 <bobajett> ah
00:55:06 <yasar> I'm still trying to guess what it does actually.
00:55:13 <Philippa> > groupBy (<=) [1,2,3,0,1,2,3]
00:55:14 <lambdabot>   [[1,2,3],[0,1,2,3]]
00:55:45 <ion> @src groupBy
00:55:45 <lambdabot> groupBy _  []       =  []
00:55:46 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
00:55:46 <lambdabot>     where (ys,zs) = span (eq x) xs
00:55:46 <ceii> > groupBy ((==) `on` snd) [('a',1), ('b',2),('c',3),('d',4)]
00:55:47 <lambdabot>   [[('a',1)],[('b',2)],[('c',3)],[('d',4)]]
00:55:58 <c_wraith> > groupBy (<=) [1,2,3,5,1,2,3,1,2,3]
00:55:58 <lambdabot>   [[1,2,3,5,1,2,3,1,2,3]]
00:55:59 <ceii> > groupBy ((==) `on` snd) [('a',1), ('b',1),('c',2),('d',3)]
00:56:00 <lambdabot>   [[('a',1),('b',1)],[('c',2)],[('d',3)]]
00:56:20 <ceii> ^ this. groupBy and "on" work well together.
00:57:10 <Philippa> the first item in a list is the start of a group. The next item continues the current group if it's "equivalent" to the previous one, otherwise it starts the next group (which of course becomes current)
00:57:54 <ion> > groupBy (<=) [1,2,3,2,1,0{-new group-},1,2,3,2,1,0,-1{-new group-},0,1,2,1,0,-1,-2]
00:57:55 <lambdabot>   [[1,2,3,2,1],[0,1,2,3,2,1,0],[-1,0,1,2,1,0,-1],[-2]]
00:58:48 <bobajett> > groupBy (==) "helloo"
00:58:48 <lambdabot>   ["h","e","ll","oo"]
00:58:55 <Philippa> ion: you missed -2 getting its own group :p
00:59:04 <ion> philippa: No, i didn’t. :-P
00:59:23 <ion> I assumed the pattern would be clear by then. :-)
01:00:05 * hackagebot msgpack-rpc 0.7.1 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.7.1 (HideyukiTanaka)
01:00:15 <c_wraith> Philippa: the implementation is actually if things are "equivalent" to the first item in the current group - which is why it only works particularly well with equivalence relations
01:00:23 <c_wraith> well.  the implementation in base
01:00:27 <ion> process-conduit, huh? I might find that useful some day.
01:00:46 <Philippa> c_wraith: heh, clearly I skimmed too quickly
01:01:27 <c_wraith> > groupBy (<) [1,5,4,3,2]
01:01:28 <lambdabot>   [[1,5,4,3,2]]
01:01:44 <c_wraith> if it looked at the previous element, that would have different results
01:08:40 <osa1> I'm having trouble understanding how can I type system be stronger then others, can anyone point me some sources to read about type systems?
01:10:08 <Philippa> Pierce's Types and Programming Languages is a decent intro if you can get your hands on a copy
01:10:32 <Philippa> it doesn't just cover a decent range of systems, it also conceptualises what's going on well
01:12:26 <osa1> Philippa: what skill do I need to understand that?
01:13:17 <Philippa> depends how much of it you want to understand - the proofs don't require anything special by undergrad standards though, a little basic set theory and a willingness to crank it by hand until you understand it if need be is plenty
01:14:55 <Philippa> there's code in ML, but IIRC enough to understand the code is included in the book regardless of whether you know ML - it's certainly not hard to follow if you already know Haskell
01:15:04 <osa1> Philippa: great. I'm third year CS undergrad, I hope I have enough background for it :)
01:15:36 <osa1> Philippa: yeah I already had some experience with ML thanks to great papers with code in ML :)
01:16:35 <MaskRay> `hedis' or `redis' ?
01:17:36 <Philippa> osa1: I was a third (=final in the UK, but still) year undergrad when I picked it up, that's plenty
01:17:44 <Philippa> really, I had the necessary background by the end of my first year
01:19:11 <MaskRay> which is better as a Redis client? hedis or redis?
01:19:29 <gnoi> How can I read haskell-cafe via rss?
01:20:02 <timthelion> How can I search gtk2hs when it's functions aren't in hoogle?
01:21:37 <ClaudiusMaximus> timthelion: http://www.haskell.org/hoogle/?hoogle=dialog+%2Bgtk ? http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=dialog%20package:gtk
01:22:19 <timthelion> aha, I see how it works.
01:22:25 <timthelion> thank you
01:22:56 <lifestream> :t drop,  Int -> [a] -> [a] reads as "Drop takes an Int and a list, and returns a list", right? So, :t map, (a -> b) -> [a] -> [b] reads as "Map (a) takes a function (b)... that takes a list [b], and returns a list [a]"... correct? I know what map does; but I don't  understand why the type is written the way it is. Sorry, I know this is really basic...
01:22:57 <lambdabot> parse error on input `,'
01:23:32 <Philippa> map takes a function (a->b)... that...
01:23:33 <wto> lifestream: map takes a function fram a to b, and a list of a's, and out comes a list of b's
01:23:37 <Philippa> the parens are significant
01:24:29 <lifestream> "from a to b"?
01:24:43 <Philippa> the parameter is an a, the result is a b
01:24:48 <wto> oh, right. What Philippa said.
01:25:01 <lifestream> Ah yes, thank you both :) *jots it down in the notepad*
01:31:07 <lifestream> It's so complicated to me BECAUSE it's so simple.
01:32:10 <mauke> then let's simple this up a bit more
01:32:50 <Philippa> lifestream: that's a common experience :-) It gets hard to find how to relate the simplicity to things you've already met and hang your intuitions off existing ones, no?
01:32:57 <mauke> 'A -> B' is the type of a function that takes a value of type A and returns a value of type B
01:33:04 <Philippa> or at least, you end up having to work it all through for a while
01:33:09 <Philippa> (also, what mauke is saying)
01:33:21 <mauke> 'A -> B -> C' is the same as 'A -> (B -> C)'
01:33:47 <lifestream> Right
01:33:50 <mauke> 'A -> (B -> C)' is the type of a function that takes a value of type A and returns a function that takes a value of type B and returns a value of type C
01:35:48 <mauke> assume f :: Int -> String. then map :: (a -> b) -> ([a] -> [b]);  map f :: [Int] -> [String];  (map f) [1,2,3] :: [String]
01:40:06 * hackagebot feldspar-language 0.5.0.1 - A functional embedded language for DSP and parallelism  http://hackage.haskell.org/package/feldspar-language-0.5.0.1 (EmilAxelsson)
01:40:08 * hackagebot feldspar-compiler 0.5.0.1 - Compiler for the Feldspar language  http://hackage.haskell.org/package/feldspar-compiler-0.5.0.1 (EmilAxelsson)
01:40:26 <repl_> monad 是使haskell缓慢的根源
01:40:33 <ion> Indeed.
01:40:49 <Skola> feldspar, what an elegant name
01:40:49 <lifestream> I'm working on it on paper ^^
01:40:54 <Jafet> Is that chinese for burrito
01:41:23 <MaskRay> repl_: chinese?
01:46:22 <MaskRay> which is better as a Redis client? hedis or redis?
01:52:55 <timthelion> It took me about 2 hours to figure out that whoever wrote the example code for table drawing in GTK made x stand for row, and y for collumn, when I thought that it would be logically reversed :D
01:55:47 <lifestream> I apologize for that person, sounds like something I would do >_<" Quick, send an email and have them change it!
01:57:09 <timthelion> lifestream: perhaps he's american, and perhaps in america they don't only switch x and y on the keyboard ;)
01:59:26 <lifestream> Would it have been better to use r and c? ;P
02:00:22 <timthelion> lifestream: yes.
02:07:41 <MaskRay> how to parse a "\u98ab" like encoded string to Text/ByteString ?
02:32:47 <lifestream> So :t take ... a -> [a]. take is a function that takes a value of type a and returns a value of type [a]... it's REALLLY that simple? I'm trying to understand before I move on to the next lesson in Try Haskell.
02:33:49 <lifestream> I've watched lectures, read tutorials and books, the more I do the more confused I am :o
02:35:08 * hackagebot parsec-numbers 0.0.3 - Utilities for parsing numbers from strings  http://hackage.haskell.org/package/parsec-numbers-0.0.3 (ChristianMaeder)
02:35:22 <lifestream> Ah, the Try Haskell console and the ghci console give different types (I guess they must mean the same thing)
02:36:12 <lifestream> Because my first guess was :t take is [a] -> [a], but because the Try Haskell console gave me: (Num t) => [t], I thought I was wrong.
02:38:06 <ChristianS> @type take
02:38:07 <lambdabot> forall a. Int -> [a] -> [a]
02:38:14 <zhulikas> lifestream, it takes a number and a list
02:38:21 <zhulikas> and returns a sublist
02:38:34 <zhulikas> > take 5 ['a'..'z']
02:38:35 <lambdabot>   "abcde"
02:38:50 <zhulikas> @src take
02:38:51 <lambdabot> take n _      | n <= 0 =  []
02:38:51 <lambdabot> take _ []              =  []
02:38:51 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
02:39:02 <zhulikas> it's quite simple
02:40:02 <lifestream> Right, for take and filter, I guessed correctly, but the Try Haskell console gave me a different output, no wonder I was confused GRR!!
02:40:23 <zhulikas> :)
02:41:58 <merijn> lifestream: Which lesson/step is that?
02:42:08 <merijn> (Want to check what it's saying wrong)
02:43:38 <lifestream> L6/Step32 ... and actually *I* was wrong, the output I was confused about was when I typed something like take 2 [1,2,3,4,5]
02:44:03 <zhulikas> lifestream, I strongly suggest you this book: learnyouahaskell.com
02:44:03 <zhulikas> it's free online and extremely useful
02:44:04 <zhulikas> I loved it:)
02:44:33 <merijn> lifestream: Oh!
02:44:41 <merijn> lifestream: Makes perfect sense in that case
02:45:09 <merijn> lifestream: ":t take 2 [1,2,3,4,5]" returns the type of the total expressions (i.e. the result of the applied function)
02:45:11 <lifestream> I really like how LYAH is written but it doesn't work for me. I'm going to revisit it after I learn a bit from Try Haskell.
02:46:08 <merijn> lifestream: In Haskell numeric literals (i.e. the ones in the list) are overloaded (they represent the type class (Num t) which is the type classes for numeric types)
02:46:22 <lifestream> Basically when reading tutorials or LYAH I read and read and nothing sticks in my brain. Try Haskell is helping (I have learning problems from autoimmune condition)
02:47:16 <merijn> In other words, the input list "[1,2,3,4,5] :: (Num t) => [t]", in other words it is a list of overloaded numerics. So applying take to it will (of course) also return a list of overloaded numerics
02:47:59 <merijn> :t take
02:48:00 <lambdabot> forall a. Int -> [a] -> [a]
02:48:00 <lifestream> Might have to take note of that and re-read it later :)
02:48:07 <merijn> :t [1,2,3,4,5]
02:48:08 <lambdabot> forall t. (Num t) => [t]
02:48:13 <merijn> :t take 2
02:48:14 <lambdabot> forall a. [a] -> [a]
02:48:17 <CQ> hm, why does try haskell need google analytics to work??
02:48:23 <merijn> :t take 2 [1,2,3,4,5]
02:48:24 <lambdabot> forall t. (Num t) => [t]
02:48:42 <CQ> I have firefox with request policy, and the return key doesn't work untill I allow scripts from analytics
02:48:45 <merijn> lifestream: Look at those few type signatures and ponder them until enlightenment :)
02:49:10 <merijn> :t take 2 ([1,2,3,4,5] :: Int)
02:49:11 <lambdabot>     Couldn't match expected type `Int' against inferred type `[a]'
02:49:11 <lambdabot>     In the second argument of `take', namely `([1, 2, 3, 4, 5] :: Int)'
02:49:11 <lambdabot>     In the expression: take 2 ([1, 2, 3, 4, 5] :: Int)
02:49:15 <merijn> ah, bollocks
02:49:31 <ClaudiusMaximus> so i implemented fixed-point arithmetic with a type level number to determine the precision at the value level; but now i want to keep some such values around in my GUI program, increasing/decreasing precision as needed - should i look at existentials? or would it be better to keep track of the useful precision separately using an Int, and store the values as Rational, using approxRational to avoid explosions of large Integers?
02:49:32 <merijn> :t take 2 [1,2,3,4,5] :: Int
02:49:33 <lambdabot>     Couldn't match expected type `Int' against inferred type `[t]'
02:49:33 <lambdabot>     In the expression: take 2 [1, 2, 3, ....] :: Int
02:50:08 * hackagebot syntactic 0.8 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-0.8 (EmilAxelsson)
02:50:49 <lifestream> Pondering no more, once I get these 2 questions right and completely understand them, I'm moving on to the next lesson before my brain falls off my skull ;P
02:55:08 * hackagebot parsec-numbers 0.0.4 - Utilities for parsing numbers from strings  http://hackage.haskell.org/package/parsec-numbers-0.0.4 (ChristianMaeder)
03:02:45 <nart> hi
03:03:39 <adnauseam> alo nart
03:04:42 <nart> any interesting news / paper ?
03:06:00 <nart> i have to wait 2 hours  before i'll take my oral exam about set theory & co (nothing fancy, it's a basic course, but i'll fail it for sure)
03:07:19 <adnauseam> i suppose physorg ought to have something down that alley
03:07:36 <Entroacceptor> nart: read about set theory?
03:07:44 <Entroacceptor> two hours should be enough ;)
03:09:11 <nart> it more than that, but the real problem is my prof
03:09:25 <adnauseam> http://www.physorg.com/news/2012-03-swedish-parliament-controversial-storage-bill.html well the swedes passed a law that demands ISPs to store 6 months' worth of data traffic, which is rather unsettling
03:09:49 <adnauseam> smile when you first get into the room - it might save you
03:10:27 <CQ> ...and comment on what a beautiful spring day it is, and how youve jsut fallen in love, that ought to excuse a few mistakes ;)
03:10:30 <bitonic> adnauseam: #haskell-blah
03:10:36 <nart> CQ: ahaha
03:11:06 <nart> bitonic: sorry i didn't know about haskell-blah
03:11:14 <bitonic> nart: it's great :)
03:12:54 <adnauseam> woo
03:15:09 * hackagebot majordomo 0.1.4 - Majordomo protocol for ZeroMQ  http://hackage.haskell.org/package/majordomo-0.1.4 (MarkWotton)
03:22:01 <CQ> when does map need functions in () and when not?
03:22:22 <CQ> is it when the symbols themselves can be functionsl like (+5) ?
03:23:04 <Botje> CQ: (+5) is a special construct in haskell.
03:23:21 <bitonic> Botje: special construct?
03:23:26 <Botje> it expands to (\x -> x + 5)
03:23:29 <bitonic> it's just a partial application of +
03:23:30 <Lemmih> bitonic: It's part of Haskell, not map.
03:24:46 <bitonic> well, ok. CQ: when you partially apply operators (e.g. (+ 5), or (f >>=)) you need parenthesis around it for haskell to parse your expression
03:25:18 <CQ> bitonic: parse the expression as opposed to what, evaluating in place?
03:25:57 <Lemmih> CQ: See the difference between 'map + 5' and 'map (+5)'?
03:26:03 <bitonic> CQ: no it has nothing to do with evaluation, it has to do with the fact that operators bind less tightly than function application. 'map + 5' would be interpreted as 'add map to 5'
03:26:17 <CQ> ah, got it
03:38:15 <CQ> is fst only for tuples? Why is there a fst and head?
03:38:30 <CQ> i.e. why not just head for everything?
03:38:44 <shachaf> Because they're different functions that do different things.
03:38:49 <shachaf> Why should they have the same name?
03:39:26 <CQ> shachaf: I guess I don't see the difference between lists and tuples clearly enough yet, a tuple seems like a list to me
03:39:32 <Entroacceptor> :t fst
03:39:33 <lambdabot> forall a b. (a, b) -> a
03:39:37 <Entroacceptor> :t head
03:39:38 <lambdabot> forall a. [a] -> a
03:39:54 <Jaak> > fst (1, "foo")
03:39:55 <lambdabot>   1
03:39:58 <Entroacceptor> CQ: a list contains lots of elements of the same type
03:39:59 <Jaak> > head [1, "foo"]
03:40:00 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
03:40:00 <lambdabot>    arising from the literal ...
03:40:09 <Entroacceptor> a tuple contains two elements which may be of different type
03:40:28 <Entroacceptor> (or more than two, but always a fixed amount)
03:41:36 <CQ> Entroacceptor: ok, what if I wanted more than two different elements in a tuple? sorry, trying to understand some basics here
03:42:55 <DMcGill> CQ: tuples can be as long as you want - see '(3,'c',"str") :: (Int,Char,String)'
03:43:50 <CQ> ok
03:43:53 <DMcGill> well, in practice GHC only supports tuples up to 10 long or so - if you're using tuples longer than that you need to have a long think about what you're actually doing
03:44:11 <CQ> makes sense, I thought they were limited to two
03:44:56 <DMcGill> The "two" sound in "tuple" used to confuse me - they're not related at all
03:45:13 <osfameron> some people pronounce it "tupple" don't they?
03:46:10 <DMcGill> I, and my lecturers have always said it "two-ple"
03:46:22 <DMcGill> "two-pull" even
03:46:40 <CQ> I pronounce it tupple, but was still thinking two...
03:47:30 <DMcGill> the way I've seen it done, if you want to specify how long the tuple is, you do call it an n-tuple
03:47:42 <DMcGill> and 2-tuples are usually called pairs
03:47:57 <Entroacceptor> :t (1)
03:47:58 <lambdabot> forall t. (Num t) => t
03:48:43 <CQ> hm, comments to try haskell should probably go directly tot he author?
03:49:25 <bitonic> DMcGill: I think that GHC supports tuples much bigger than 10 elements
03:49:32 <bitonic> :t (,,,,,,,,,,,,,,,,)
03:49:32 <lambdabot> forall a b c d e f g h i j k l m n o p q. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
03:49:38 <bitonic> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
03:49:39 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -
03:49:39 <lambdabot> > z -> t28 -> t29 -> t30 -> t31 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31)
03:51:16 <bitonic> > GHC.Exts.maxTupleSize
03:51:17 <lambdabot>   Not in scope: `GHC.Exts.maxTupleSize'
03:51:20 <DMcGill> bitonic: Ok, sorry for the misinformation
03:51:47 <bitonic> well, it's 62 apparently, but I can get the type of tuple constructors with hundreds of elements. that's weird
03:51:51 <DMcGill> I do believe there is a max tuple size though, and I would say using an ADT is much better past 4- or 5- tuples anyway
03:52:03 <bitonic> DMcGill: check GHC.Exts.maxTupleSize
03:52:24 <DMcGill> 62 for me
03:52:44 <bitonic> yeah, but I can get the type for arbitrary-big tuple constructors. weird.
03:54:24 <Senmorta> in my ghci thought this code would count by 3's_ [3,50..200]
03:54:58 <Senmorta> but it counts by 47's
03:55:01 <bitonic> Senmorta: that would have a step of 47
03:55:27 <DMcGill> > [50,53..200]
03:55:29 <lambdabot>   [50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98,101,104,107,110,113,116...
03:58:21 <Senmorta> i get it now, ty, it is the gap, that is actually pretty neat
03:58:44 <mux> > enumFromThenTo 50 53 200
03:58:45 <lambdabot>   [50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98,101,104,107,110,113,116...
04:05:15 * hackagebot yesod-core 0.10.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.10.3 (FelipeLessa)
04:09:27 <hiptobecubic> Any maintainers of hpaste in here? It's broken. Can't find hlint.
04:10:05 <CQ> if a tuple can have a longer length, then why is fst so limited (to two)? i.e. fst (10,'a',"hello") doesn't work...
04:10:22 <hiptobecubic> CQ, because the type signature says it takes a two tuple
04:10:26 <Guest95611> Fst has the type signature [a]->a
04:10:28 <Guest95611> i mean
04:10:33 <DMcGill> :t fst
04:10:35 <lambdabot> forall a b. (a, b) -> a
04:10:35 <Guest95611> (a,b)->a
04:10:37 <hiptobecubic> (a, b) -> a
04:10:52 <DMcGill> so you can define your own fst3
04:10:57 <CQ> hiptobecubic: I know, I checked that in ghci, but why not define it to give the first element of a tuple, as apposed to limiting it to a pair?
04:11:11 <DMcGill> > let fst3 (a,_,_) = a in fst3 (1,2,3)
04:11:11 <Jafet> CQ: the type (a,b) is completely unrelated to the type (a,b,c).
04:11:12 <lambdabot>   1
04:11:31 <Jafet> There are ways to relate them, but Haskell does not provide any.
04:11:37 <DMcGill> CQ: think about how you'd define fst, fst3 and so on
04:12:07 <CQ> Jafet: ah, each tuple is its own type, then it makes sense. I still think of tuples as special lists... thats probably wrong
04:12:08 <hiptobecubic> CQ, you'd have to redefine tuple as a recursive data structure like list to achieve it anyway.
04:13:03 <Jafet> CQ: see hlist, if you have the fortitude for it
04:14:07 <hiptobecubic> I need this simple looking thing I made to scale appropriately up to very large lists. I'm sure i'm building up a bunch of thunks but I'm looking for some hints on where it would be best to add strictness to help it along.  http://vpaste.net/BsTGm
04:14:55 <hiptobecubic> It just reads a list of integers from stdin and counts the number of inversions, piggy backing on merge sort
04:15:15 <CQ> Jafet: thanks for the pointer, buthlist is a bit much for now :)
04:16:09 <zhulikas> I was thinking about participating in GSoC by making a Haskell support for Microsoft Visual Studio
04:16:14 <zhulikas> what do you guys think?
04:16:19 <hiptobecubic> can't hurt
04:16:47 <zhulikas> I love visual studio actually
04:16:51 <zhulikas> for whatever I do in it
04:16:57 <zhulikas> and to have it for Haskell would be amazing
04:17:23 <bitonic> I'm not sure, it'd be a windows only thing, wouldn't it much better to have a good closs platform haskell ide (for those who want it)
04:17:26 <Philippa> do you have any kind of a plan for what and how you'd do it? Have you looked at the previous (now bitrotten, I imagine) attempts?
04:17:28 <bitonic> e.g. make Leksah better
04:18:59 <zhulikas> Philippa, I have looked a bit into Visual Studio SDK
04:19:09 <bitonic> but yeah I guess it can't hurt
04:19:12 <zhulikas> not much yet
04:19:13 <zhulikas> it's still just an idea
04:19:26 <zhulikas> I don't want to make a new haskell ide
04:19:28 <zhulikas> there is leksah
04:19:32 <zhulikas> but it kinda sucks
04:19:35 <Philippa> *nod* if you want to have a proposal accepted, you should probably do those things
04:19:38 <CQ> what about working on something like http://eclipsefp.sourceforge.net/haskell/ ?
04:19:39 <zhulikas> and visual studio is the best option on windows
04:20:04 <zhulikas> hehe :)
04:20:04 <zhulikas> also it's a big project
04:20:15 <zhulikas> because eclipse is slow
04:20:48 <DMcGill> last time I tried eclipse fp I was getting a 1s delay on each character I typed :/
04:20:54 <zhulikas> hehe :)
04:21:46 <CQ> ouch
04:22:23 <zhulikas> now I wonder where I should look for mentors
04:22:26 <DMcGill> back to notepad++ for me!
04:22:34 <zhulikas> well, probably haskell.org
04:22:40 <bitonic> The thing I'd really like is an Agda-like emacs thing for Haskell. basically make ghc-mod better
04:22:44 <zhulikas> as there would be some compiler integration as well
04:22:56 <zhulikas> which I have never done
04:22:57 <CQ> zhulikas: there is a trac page somewhere for gsoc projects, maybe post the idea there and see who answers?
04:23:12 <DMcGill> http://hackage.haskell.org/trac/summer-of-code/report/1
04:23:16 <zhulikas> hmm, probably
04:23:24 <zhulikas> ahh, here
04:24:43 <FUZxxl> Hello!
04:24:59 <FUZxxl> darcs refuses to build on my machine.
04:25:08 <zhulikas> hi
04:25:17 <FUZxxl> cabal says something about dependency problems with HTTP
04:25:22 <FUZxxl> Anything I can do?
04:25:29 <FUZxxl> Is there a patch on the road?
04:26:03 <adnauseam> hrm, why doesn't fmap (replicate 3) (Left "foo") work, while Right "Foo" does ?
04:26:20 <bitonic> @src Either fmap
04:26:21 <lambdabot> fmap _ (Left x) = Left x
04:26:21 <lambdabot> fmap f (Right y) = Right (f y)
04:26:24 <FUZxxl> > fmap (replicate 3) (Left "foo")
04:26:26 <lambdabot>   Left "foo"
04:26:34 <FUZxxl> fmap for Either works only on Right
04:26:43 <bitonic> and it couldn't be otherwise
04:26:44 <FUZxxl> similar as fmap for (,) works only for the right member
04:26:47 <FUZxxl> yes.
04:26:47 <adnauseam> *scratches head*
04:26:49 <Philippa> rather, it assumes it's Either as an error representation
04:27:01 <FUZxxl> That's because Either and (,) have two parameters on type level
04:27:09 <FUZxxl> whereas Functor touches onlky one
04:28:01 <adnauseam> i understand that
04:28:39 <Philippa> it's also coherent with the Monad instance, which is indeed Either as an error-handling mechanism
04:29:45 <hiptobecubic> adnauseam, it makes life easier with error handling for certain
04:30:08 <bitonic> adnauseam: it's a bit arbitrary, but it's the only possible instance for Either anyways. You could have newtype MyEither a = MyEither (Either a a) and then have that as a functor, but that's a different type
04:30:09 <adnauseam> Either + Maybe ?
04:30:42 <DMcGill> @src Either (>>=)
04:30:43 <lambdabot> Left  l >>= _ = Left l
04:30:43 <lambdabot> Right r >>= k = k r
04:30:44 <zhulikas> I am not getting an email from GSoC haskell trac :(
04:31:00 <bitonic> > Right "foo" >> Left 0 >> Right "bar"
04:31:02 <lambdabot>   Left 0
04:31:02 <adnauseam> not there yet- i was just wondering wy Left and Right work the way they do - i still find it a bit bewildering
04:31:05 <adnauseam> a bit :p
04:31:08 <DMcGill> zhulikas: gmail flagged it as spam for me
04:31:13 <adnauseam> a bit less bewildering than before asking
04:31:19 <zhulikas> ahh, ok
04:31:30 <zhulikas> I c
04:32:02 <zhulikas> ok, got it
04:32:04 <zhulikas> thanks
04:33:22 <yasar> does main module compilation in here: http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html is outdated? I needed to change it in order for it to work.
04:33:56 <yasar> I am using ghc 7.4.1
04:35:41 <hiptobecubic> @src (,) fmap
04:35:41 <lambdabot> fmap f (x,y) = (x, f y)
04:35:58 <OneWithLambda> > :t fmap
04:35:59 <lambdabot>   <no location info>: parse error on input `:'
04:36:05 <OneWithLambda> :t fmap
04:36:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:36:23 <danr> @src ((->) e) fmap
04:36:24 <lambdabot> Source not found. Where did you learn to type?
04:36:27 <danr> :(
04:36:32 <bitonic> @src (->) fmap
04:36:32 <lambdabot> fmap = (.)
04:36:54 <bitonic> danr: but I see where you're coming from :P
04:37:38 <hiptobecubic> do i need to import something to get fmap for (,) ?
04:38:06 <CQ> > drop (-1) "hello"
04:38:06 <lambdabot>   "hello"
04:38:17 <bitonic> hiptobecubic: what GHC do you have? it should be already there. anyways, try Control.Monad.Instances
04:38:19 <OneWithLambda> > drop 2 "hello"
04:38:20 <lambdabot>   "llo"
04:38:34 <hiptobecubic> bitonic, 7.2.2
04:38:41 <hiptobecubic> fmap (+1) (0,0)
04:38:43 <hiptobecubic> >fmap (+1) (0,0)
04:38:50 <hiptobecubic> > fmap (+1) (0,0)
04:38:51 <lambdabot>   (0,1)
04:38:59 <hiptobecubic> that fails for me
04:39:07 <OneWithLambda> :t (fmap (+1))
04:39:07 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
04:39:13 <bitonic> hiptobecubic: you're right. import Control.Monad.Instances
04:39:23 <hiptobecubic> bitonic, ok thanks
04:39:45 <hiptobecubic> bitonic, yeah, thakns.
04:40:20 <hiptobecubic> hah. I am the WORST optimizer in the world :D
04:40:22 <yitz> preflex: seen cmccann
04:40:22 <preflex>  cmccann was last seen on #haskell 3 days, 9 hours, 37 minutes and 41 seconds ago, saying: was kinda sad how easily the same joker could troll /r/lisp though, they just kept encouraging him
04:40:34 <hiptobecubic> so far i've gained -80%
04:41:22 <FUZxxl> Anybody with an answer to my question?
04:48:11 <ChristianS> FUZxxl: what was your question?
04:48:13 <Senmorta> wish i could answer it, but still learning
04:49:32 <CQ> is jumping into parsec a sensible way to get into haskell? I have something I want to do that needs parsing ...
04:50:17 * hackagebot resourcet 0.3.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.3.1 (MichaelSnoyman)
04:53:44 <FUZxxl> ChristianS: darcs fails to build on my machine.
04:54:24 <CQ> FUZxxl: post machine details and erros messagesto a pastebin?
04:54:55 <Philippa> CQ: it works well enough
04:55:07 <Philippa> (jumping into parsers with parsec, that is)
04:55:39 <ChristianS> FUZxxl: i'm a git user, sorry
04:57:21 <FUZxxl> http://d00m.org/~fuz/darcs.log
04:57:25 <FUZxxl> Me too
04:57:45 <FUZxxl> I need darcs to compile darcs-fastconvert to convert the jhc repository to git.
04:57:48 <FUZxxl> :-p
04:58:02 <ChristianS> hehe, i see
04:58:15 <FUZxxl> CQ: Here you are :-)
05:01:15 <CQ> FUZxxl: looks like you have base 4.5 installed, but cabal: cannot configure HTTP-4000.1.2. It requires base >=3 && <4.5
05:01:23 <FUZxxl> okay.
05:01:33 <FUZxxl> So, what should I do=
05:01:34 <FUZxxl> ?
05:01:36 <CQ> I have no clue and have never used cabal, but thats how I read it
05:01:44 <FUZxxl> ...
05:02:49 <CQ> try installing base-4.4.1.0 maybe since that seems to be the latest under 4.5?
05:03:42 <FUZxxl> okay.
05:03:44 <FUZxxl> I try...
05:03:45 <CQ> or can you have several bases side by side? I don't know how the package management works
05:03:55 <FUZxxl> Neither do I know.
05:04:03 <FUZxxl> Haskell package managament is kind of arcane...
05:04:58 <ClaudiusMaximus> base version is tied to ghc version
05:05:07 <FUZxxl> okay...
05:05:10 <FUZxxl> build fails.
05:05:11 <ChristianS> FUZxxl: hm, i don't think you should install other base version because of what ClaudiusMaximus said
05:05:23 <FUZxxl> ClaudiusMaximus: Do you have another idea for this?
05:05:34 <FUZxxl> I use ghc version 7.4.1
05:06:58 <ClaudiusMaximus> FUZxxl: personally i'd "cabal unpack HTTP-4000.1.2 && cd HTTP-4000.1.2 && nano HTTP.cabal (remove upper bound on base, append a .1 to the version) && cabal install"
05:08:40 <FUZxxl> okay.
05:08:49 <ClaudiusMaximus> FUZxxl: and maybe if build fails and there aren't an insane number of errors, i'd fix any Eq/Show/Num things and send a patch upstream
05:09:09 <FUZxxl> The most recent versionof HTPP is installed and works just fine.
05:09:14 <FUZxxl> Is it better to make darcs compile against that instead?
05:11:30 <ClaudiusMaximus> oh! i don't know
05:12:03 <ChristianS> FUZxxl: you could just try whether darcs compiles with the latest http
05:13:02 <FUZxxl> okay.
05:13:04 <FUZxxl> I try.
05:14:36 <timthelion> Sigh... cabal: dependencies conflict: ghc-7.4.1 requires Cabal ==1.14.0 however
05:14:36 <timthelion> Cabal-1.14.0 was excluded because yi-0.6.4.0 requires Cabal ==1.10.*
05:15:17 * hackagebot task 0.0.1 - A command line tool for keeping track of tasks you worked on  http://hackage.haskell.org/package/task-0.0.1 (SeanSeefried)
05:20:10 <timthelion> when I do{f<-newEmptyMVar;putMVar f "h";a<-takeMVar f;} How does GHC resolve the type of a?
05:21:28 <hiptobecubic> When you have something like readInt :: ByteString -> Maybe (Int, ByteString), and you want to build up a list of all the Ints possible until Nothing is hit, is there an idiom for this or do I just invent something myself?
05:22:09 <ClaudiusMaximus> :t unfoldr
05:22:10 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:22:27 <CQ> hm, wiki.darcs.net is down?
05:22:33 <hiptobecubic> ClaudiusMaximus, i suppose that's exactly what i need. thanks
05:22:40 <srhb> hiptobecubic: Although, how do you expect them to be split? As you state it there, it seems there is only one Int.
05:23:01 <srhb> hiptobecubic: So once you think about the actual way ints are split in the ByteString, more solutions become obvious.
05:23:08 <hiptobecubic> hm
05:23:25 <hiptobecubic> Well i'm reading in a list of 100,000 ints, split by newlines.
05:23:41 <timthelion> CQ: seems to be
05:24:04 <DMcGill> :t map read . lines
05:24:05 <lambdabot> forall a. (Read a) => String -> [a]
05:24:23 <hiptobecubic> DMcGill, was using that first. Very very slow.
05:25:06 <srhb> hiptobecubic: But all you want to do is translate that idiom to ByteStrings, right?
05:25:11 <bitonic> hiptobecubic: use Binary
05:25:24 <bitonic> if the numbers are in binary format
05:25:39 <bitonic> otherwise attoparsec?
05:25:46 <hiptobecubic> Yes, i just need to speed up the reading.  The numbers are written in ascii in the file.
05:25:53 <ClaudiusMaximus> hiptobecubic: i'd unfoldr (fmap (fmap (BS.drop 1)) . readInt) , or attoparsec
05:26:19 <hiptobecubic> never used attoparsec
05:27:53 <bitonic> well I'd try unfoldr + readInt first as ClaudiusMaximus says...
05:28:00 <hiptobecubic> yeah
05:29:38 <srhb> hiptobecubic: http://www.haskell.org/haskellwiki/SPOJ#Introduction
05:29:59 <bitonic> that should be really fast anyways, you're not copying anything
05:30:15 <hiptobecubic> srhb, what's a SPOJ
05:30:51 <srhb> hiptobecubic: SPOJ is one of those online judges where you submit your code solution for a given problem and the running time and correctness of the final result is judged.
05:31:17 <srhb> hiptobecubic: As that wiki page states, most of the problems involve reading a large amount of integers from stdin and doing "something" with them, so the actual reading process must have very low overhead.
05:31:39 <srhb> hiptobecubic: The page has a number of extremely fast solutions for doing this, but Solution 1 (scroll down a bit) is very very fast with minimal code mess.
05:32:50 <hiptobecubic> ah ok, similar to codechef, codesprint, etc etc
05:32:57 <srhb> I assume so. :_
05:33:00 <srhb> :)
05:33:36 <srhb> But as you can see the idiomatic map readInt . split ... solution is considered very fast.
05:37:31 <MaskRay> what about `state readInt' (Control.Monad.State Data.ByteString)
05:38:04 <gamowaxaky> pls help me offer program arguments to WinGHCi
05:38:15 <gamowaxaky> how to do that
05:39:14 <fryguybob> gamowaxaky: I don't understand your question, can you give some more detail?
05:39:58 <ClaudiusMaximus> @hoogle args
05:40:00 <lambdabot> Test.QuickCheck.Test Args :: Maybe (StdGen, Int) -> Int -> Int -> Int -> Bool -> Args
05:40:00 <lambdabot> Test.QuickCheck Args :: Maybe (StdGen, Int) -> Int -> Int -> Int -> Bool -> Args
05:40:00 <lambdabot> Test.QuickCheck.Test data Args
05:40:29 <gamowaxaky> for example, my program read command line arguments
05:40:43 <gamowaxaky> so how to offer them to WinGHCi
05:41:03 <t7> im not sure you can
05:41:04 <fryguybob> gamowaxaky: in ghci you can run your program with > :main arg1 arg2 ...
05:41:10 <t7> runghc works with arch tho
05:41:17 <t7> o i didnt know about :main
05:41:17 <gamowaxaky> thanks
05:41:24 <gamowaxaky> but  what is arch tho
05:41:33 <t7> args
05:41:45 <ClaudiusMaximus> :t withArgs
05:41:46 <lambdabot> Not in scope: `withArgs'
05:41:58 <ClaudiusMaximus> @hoogle withArgs
05:41:58 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
05:42:03 <fryguybob> gamowaxaky: You can see other commands with :help
05:42:12 <gamowaxaky> thanks all
05:57:51 <DrDiagoras> please, can anyone help me with ^^this^^
05:58:14 <DrDiagoras> auch
05:58:40 <DrDiagoras> is hpaste working today?
05:58:54 <bitonic> apparently not
05:59:10 <fryguybob> hpaste: Are you taking the day off?
05:59:38 <timthelion> it seems the computers have gone on strike !!!
05:59:52 <DrDiagoras> damn :-) any other pastes with haskell syntax?
05:59:54 <timthelion> @faq "Does haskell wan higher wages?"
05:59:54 <lambdabot> The answer is: Yes! Haskell can do that.
06:00:10 <bitonic> DrDiagoras: most of them really. http://vpaste.net/
06:00:22 <hpaste> fryguybob pasted “Nope” at http://hpaste.org/65739
06:00:54 <fryguybob> looks like missing hlint is causing it to crash before it gets to sending the message to the channel.
06:01:05 <DrDiagoras> ok, another try: http://vpaste.net/Da5Fr
06:01:26 <DrDiagoras> I'm still working on desired memoization
06:02:11 <fryguybob> @tell chrisdone seems to be a problem with hlint on hpaste.
06:02:11 <lambdabot> Consider it noted.
06:02:52 <DrDiagoras> here I coded two different strategies - one with STUArray backend and another with Map one
06:04:06 <DrDiagoras> one with STUArray inside works with pure functions resulting with ST monad
06:05:04 <DrDiagoras> one with Map inside works with monadic functions
06:05:30 <bitonic> DrDiagoras: I guess that would work but there are nicer ways to do that, this is a nice little example: http://stackoverflow.com/questions/3208258/memoization-in-haskell
06:06:07 <bitonic> in general returning a tuple and passing the map back manually is kind of annoying
06:07:53 <DrDiagoras> I know, it's just raw prototype. problem isn't here. problem is about need of sort of combination of two strategies - memoization with storage in STUArray, but working with arbitary monadic function
06:08:53 <DrDiagoras> something like "(Monad m) => STUArray s i e -> i -> e -> (i -> m e) -> ???"
06:09:23 <Botje> you can only use STarrays from inside the ST monad.
06:10:30 <bitonic> DrDiagoras: yeah you can't do that with ST, if you want to collect the results of the monadic computation. you can however store the monadic actions, but I'm not sure that's what you want
06:10:45 <bitonic> I mean what do you need to do?
06:12:15 <bitonic> you can have the whole thing wrapped in a monad transformer and then have ST as the innner monad
06:13:06 <hiptobecubic> :t (>>>)
06:13:07 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
06:13:17 <DrDiagoras> damn :-( but your last proposal brings a bit of hope. how do you think such function definition would look?
06:13:25 <hiptobecubic> hm
06:13:30 <bitonic> but there can be no general way of doing 'STUArray s i e -> i -> e -> (i -> m e) -> ST s e', simply because you can't "run" arbitrary monads
06:13:34 <mreh> I asked yesterday if you could dynamically load haskell modules, but I'm quite interested to know if you can dynamically call functions and fail gracefully if the function isn't found
06:13:42 <hiptobecubic> Wasn't there an 'fmap' but which acts on the first of a tuple? in Arrow or something
06:13:47 <bitonic> DrDiagoras: I'm not sure what you need to do here. What's your goal?
06:13:54 <bitonic> hiptobecubic: first
06:13:56 <bitonic> :t first
06:13:57 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
06:14:14 <mreh> :t arr
06:14:15 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
06:14:21 <DrDiagoras> one moment - I'll try to explain
06:14:38 <mreh> :t first . arr
06:14:39 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => (b -> c) -> a (b, d) (c, d)
06:15:19 <bitonic> DrDiagoras: what I was proposing is 'MonadTrans t => STUArray s i e -> i -> e -> (i -> t ST e) -> t ST (s e)'
06:15:34 <bitonic> sorry
06:15:53 <bitonic> 'MonadTrans t => STUArray s i e -> i -> e -> (i -> t (ST s) e) -> t (ST s) e'
06:16:12 <mreh> -> is already an Arrow isn't it
06:16:24 <bitonic> mreh: yes
06:16:38 <hiptobecubic> looks like an arrow to me
06:16:50 <mreh> no, an Arrow
06:17:04 <bitonic> > first (+1) (0, 0)
06:17:05 <lambdabot>   (1,0)
06:17:16 <DrDiagoras> bitonic: this (i -> m e) is hell of a monadic stack with some high-level monte-carlo stuff above manual memory managment. and I need this actions to be performed only once for each Ptr () returned
06:17:18 <hpc> > succ *** pred $ (15, 100)
06:17:19 <lambdabot>   (16,99)
06:17:35 <hiptobecubic> i don't see how that signature suggests that it would be doing that though
06:17:51 <hiptobecubic> merijn, ... wireless.uva?
06:17:56 <hiptobecubic> damnit :D
06:17:57 <bitonic> hiptobecubic: replace 'a' with (->) in that type sig
06:18:04 <hiptobecubic> bitonic, hmm
06:18:19 <hiptobecubic> bitonic, ah of course ok
06:18:30 <bitonic> DrDiagoras: well you can add ST to the stack
06:20:01 <DrDiagoras> bitonic: hmm... that idea haven't came to my mind. before I haven't need to explicitly explicitly state something as MonadTrans in function signatures... won't this bite me in the ass somewhere later?
06:20:21 * hackagebot text-format-simple 1.1.0 - Simple text formatting library.  http://hackage.haskell.org/package/text-format-simple-1.1.0 (DmitryBespalov)
06:20:46 <CQ> how do I install libraries?     Could not find module `Text.ParserCombinators.Parsec': ...
06:21:35 <Philippa> these days it's in Text.Parsec IIRC
06:21:40 <mreh> CQ lots of libraries are packaged up and hosted on hackage, you can install them using cabal-install
06:21:54 <Philippa> but in case you don't have parsec at all, what mreh said
06:22:30 <mreh> someone will bash me saying package manager, so I didn't
06:22:31 <mreh> OOPS
06:22:44 <bitonic> DrDiagoras: if you want a generic function that does that, you can't, you could I guess if there was a typeclass for ST
06:22:56 <bitonic> DrDiagoras: but you can definitely write code specific to your stack
06:23:12 <bitonic> I put MonadTrans just to clarify that that is a monad transformer
06:24:08 <DrDiagoras> damn. I suppose, I'd need to use IOUArray even. forgot that my manual memory managment is already in bottom IO monad. and I can't have two bottom monads in a stack probably
06:24:18 <mreh> wee, functionExtractor looks good
06:24:20 <bitonic> no, you can't.
06:24:25 <CQ> mreh: what does cabal do? download the haskell sources, and compile them into libraries?
06:24:44 <bitonic> DrDiagoras: but if you're got IO already, just use IORefs or whatever suits you
06:24:49 <roconnor> CQ: yep libraries and applications.
06:24:49 <mreh> pretty much, as well as creating your documentation too
06:25:06 <mreh> oh yes, and binaries
06:25:22 <mreh> cabal-install is the command line tool for interacting with cabal
06:25:33 <CQ> ok, parsec is installed... cabal reminds me a lot of apt-get :)
06:25:41 <DrDiagoras> ok, fuck generic solutions! time to make hands dirty again :-) thanks for help, bitonic
06:25:46 <mreh> have fun
06:26:28 <bitonic> DrDiagoras: I'm sure that if you could do something generic, it just requires a bit more scaffolding
06:26:30 <hiptobecubic> CQ, except there's no undo
06:26:45 <bitonic> for example if you're storing the memo table in IO you can use MonadIO
06:26:47 <CQ> if I didn't know it was called text.parsec, how would I have found it?
06:27:01 <CQ> hiptobecubic: meaning one something is installed it stays?
06:27:04 <Philippa> HackageDB -> haddocks
06:27:12 <merijn> Also Hoogle and Hayoo
06:27:16 <merijn> @where hoogle
06:27:16 <lambdabot> http://haskell.org/hoogle
06:27:21 <merijn> @where hayoo
06:27:21 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
06:29:06 <DrDiagoras> bitonic: hm... some hand-coded lifting of IO probably can make my stack less ugly. that's another good idea, thanks!
06:29:35 <CQ> ouch, is there a way to get vim to indent haskell correctly?
06:29:54 <hiptobecubic> CQ, almost.
06:30:10 <hiptobecubic> CQ, find "haskell-mode"
06:30:32 <timthelion> CQ: or if you are using an older version of ghc try yi :D
06:31:14 <hpaste> timthelion pasted “How does this type error come about?” at http://hpaste.org/65743
06:32:46 <hiptobecubic> CQ, as with most things vim, there's a learning curve to haskell-mode. It doesn't reasonably well though I think... if a bit slow
06:33:30 <t7> @seen nielm
06:33:30 <lambdabot> Unknown command, try @list
06:33:54 <zhulikas> http://hackage.haskell.org/trac/summer-of-code/ticket/1615
06:35:32 <shurikas> <zhulikas> http://hackage.haskell.org/trac/summer-of-code/ticket/1615
06:35:35 <shurikas> don't know if you got that
06:35:40 <shurikas> my connection here is really bad
06:45:07 <exFalso1> @hoogle t m (m a) -> t m a
06:45:08 <lambdabot> No results found
06:45:31 <exFalso1> :t \a -> a >>= lift
06:45:31 <lambdabot> forall (m :: * -> *) b (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m, Monad (t m)) => t m (m b) -> t m b
06:49:02 <CQ> what does this mean at compile time? That I need to link something in? parse.hs:5:12: Not in scope: type constructor or class `GenParser'
06:49:58 <danr> import the module exporting GenParser
06:50:16 <danr> some suggestions on hoogle: http://www.haskell.org/hoogle/?hoogle=GenParser
06:50:19 <CQ> I thought I did: import Text.Parsec
06:51:01 <quicksilver> GenParser is a type, it is not a constructor or a class
06:51:17 <quicksilver> hmm it is a type constructor :)
06:51:20 <quicksilver> sorry misread error.
06:51:42 <CQ> I'm trying to get the code from http://book.realworldhaskell.org/read/using-parsec.html to work
06:53:32 <Philippa> CQ: import Text.Parsec.String for now?
06:53:42 <quicksilver> that's Parsec2 code
06:53:43 <Philippa> or drop the type annotations, which I have to admit is what I normally do
06:53:43 <geekosaur> isn;t that based on parsec2, while current is parsec3?
06:53:45 <quicksilver> (isn't it?)
06:53:50 <Philippa> it is, yeah
06:53:53 <quicksilver> import Text.ParserCombinators.Parsec
06:53:59 <quicksilver> is not "import Text.Parsec"
06:54:00 <geekosaur> (types are very different)
06:54:12 <quicksilver> although they didn't break the API very badly some of the type names changed.
06:54:27 <CQ> whats teh best way to go, get it to work with parsec2 first, or try to get it to parsec3?
06:54:35 <Philippa> learn parsec3
06:54:46 <Philippa> try removing all the type annotations, then asking ghci what they should be
06:55:04 <Philippa> :t "What is this, anyway?"
06:55:06 <lambdabot> [Char]
06:56:10 <CQ> Philippa: line :: ParsecT String u Data.Functor.Identity.Identity [[Char]] ... etc.
06:56:40 <Philippa> looks about right
06:57:25 <CQ> Philippa: where are some useful docs? RWH is old, http://legacy.cs.uu.nl/daan/parsec.html points to parsec2 ...
06:58:32 <weexplat> parsec is not exactly quick and easy as compared to say, sscanf
06:58:53 <Philippa> CQ: good question. I have to admit, I honestly don't know - the parsec 2 docs + the readme from when parsec3 was released were usable for someone who knows Haskell, but not great
06:59:08 <quicksilver> I don't know if I agree
06:59:14 <quicksilver> sscanf is pretty arcane too
06:59:22 <quicksilver> format strings? qualifiers? pointers?
06:59:29 <quicksilver> you even need to remember the C ABI promotion rules
06:59:34 <quicksilver> since it's varargs
06:59:38 <CQ> weexplat: I know, but I have a choice of using recDesent in perl, or writing a parser in haskell and learning haskell... and sscanf is not good enough for what I need
06:59:43 <Philippa> (my involvement was limited by release stage: I mentored the SoC project that put together the first version of parsec3)
07:00:49 <Philippa> CQ: mostly you can use the GenParser synonym in Text.Parsec.String to get you by for now, the two parameters are your token type and the result of the parser. Give or take filling in the blanks on the monad name, the parsec2 functions mostly just work
07:04:44 <ccc_> hello
07:10:44 <djanatyn> Why is System.Random no longer included with GHC? :O
07:11:16 <timthelion> if I have myComplexFunctionWithTonsofSlowSortBys :: SomeGiantTreeStructure .. And I use the value of that function in multiple places, do I need to tell GHC to cache the result or does it do so automagically?
07:13:51 <Mortchek> If I know a given division will always yield an integer, what is the safest way to mark its value as one?
07:13:56 * zhulikas wants to know the answer as wel
07:13:56 <zhulikas> well
07:15:52 <quicksilver> if you *know* it will be Integer
07:16:07 <quicksilver> then truncate the two operands to Integer in advance
07:16:11 <quicksilver> and use `div`
07:16:44 <imc> :D
07:16:47 <quicksilver> > truncate 8.0 `div` truncate 2.0
07:16:48 <lambdabot>   4
07:17:13 <Mortchek> quicksilver, thanks, that works.
07:17:53 <Mortchek> The operands are actually already Integral types (which I should have said instead of integer)
07:18:04 <quicksilver> then no need to truncate, indeed
07:18:06 <quicksilver> simply use div
07:18:18 <Mortchek> Yep, that is what I've done. Thanks.
07:19:38 <DMcGill> Wasn't there talk about replacing the Num/Floating/whatever system with Integer/Fractions/Reals at some point?
07:20:24 <DMcGill> or having inheretance of Num? Putting 'fromIntegral' all over my arithmetic code isn't very nice at all
07:23:27 <khs> Hi, how can i deconstruct a constructor without pattern matching? i.e. only extract one field from a constructor containing very many fields.
07:23:37 <applicative> djanatyn: Isn't the general policy, at least since the Haskell Platform got going, to move things out of the ghc
07:24:10 <DMcGill> khs: either define a function somewhere which does patternmatch to get the component you want or define the constructor with record syntax
07:24:14 <applicative> khs, record syntax?
07:24:49 <DMcGill> http://en.wikibooks.org/wiki/Haskell/Pattern_matching#Introduction_to_records
07:24:52 <dschoepe> khs: `nameOfTheField recordValue'?
07:25:35 <khs> thanks
07:26:01 <DMcGill> there's also a few ghc extentions to make it easier, see XNamedFieldPuns
07:27:03 <quicksilver> s/easier/more hideous and vile/
07:27:25 <quicksilver> type-altering shadows considered wicked.
07:27:49 <osfameron> "Puns" in code is an interesting idea
07:28:51 <astor> what's the difference between pipes and pipes-core?
07:29:30 <hpc> my guess would be that pipes is the interface you are expected to use, and pipes-core is the deep magic abstracted away by pipes
07:30:13 <exFalso1> @hoogle Cxt -> Type
07:30:14 <lambdabot> Language.Haskell.TH.Syntax ForallT :: [TyVarBndr] -> Cxt -> Type -> Type
07:30:14 <lambdabot> Language.Haskell.TH ForallT :: [TyVarBndr] -> Cxt -> Type -> Type
07:30:14 <lambdabot> Data.List genericLength :: Num i => [b] -> i
07:30:24 <sclv> astor: nope
07:30:33 <exFalso1> is there a way to turn a Cxt into a Type?
07:30:39 <exFalso1> in TH?
07:30:48 <hpc> @hoogle Cxt
07:30:48 <lambdabot> Language.Haskell.TH.Syntax type Cxt = [Pred]
07:30:48 <lambdabot> Language.Haskell.TH type Cxt = [Pred]
07:30:48 <lambdabot> Language.Haskell.TH.Lib cxt :: [PredQ] -> CxtQ
07:30:54 <sclv> pipes is the original pipes
07:31:07 <sclv> pipes core is an experimental modification of pipes
07:31:17 <sclv> that the author of the pipes lib thinks isn't sound.
07:31:24 <hpc> sclv: that's poorly named imo
07:31:28 <sclv> yes.
07:31:47 <exFalso1> the problem is that [d| instance $(something) SomeClass SomeType |] expects something to be (Q Type)
07:32:31 <exFalso1> (left out the =>)
07:35:44 * applicative agrees that the name of pipes-core is completely absurd
07:36:31 * applicative proposes a package parsec-core that defines fib
07:38:50 * applicative on further reflection advises D. Swierstra to rename uu-parsinglib 'parsec-core'
07:39:34 <bitonic> exFalso1: a type needs a context and a body
07:40:06 <roconnor> > let fib n = ((\(x,y) -> if y <= x then 1 else 0)^n) (True,True) in map fib [0..]
07:40:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:40:18 <roconnor> oops
07:40:23 * hackagebot tomato-rubato-openal 0.1.0.0 - Easy to use library for audio programming.  http://hackage.haskell.org/package/tomato-rubato-openal-0.1.0.0 (HeinrichApfelmus)
07:40:25 * hackagebot xml-conduit 0.6.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.6.1 (MichaelSnoyman)
07:40:26 <bitonic> exFalso1: what do you mean turn a Cxt into a Type?
07:40:27 * roconnor signs
07:40:31 <roconnor> *sighs
07:40:49 <ion> > let fibs = repeat 1 in fibs
07:40:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:41:24 <roconnor> I don't suppose I can get matrix multiplication for free out of some sort of standard monoid or dioid thing in lambdabot.
07:41:31 <exFalso1> bitonic: well the [d| |] splice expects a Type to be in the context's place
07:42:16 <exFalso1> which is why i thought there is a way to turn a cxt into a type (constraintkinds style maybe?)
07:43:17 <sclv> @oeis 0,1,1,2,3,5,8,13,21
07:43:20 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
07:43:20 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:43:36 <bitonic> exFalso1: I don't get it. "turning a Cxt into a Type doesn't make sense to me."
07:43:39 <bitonic> @hoogle Cxt
07:43:39 <lambdabot> Language.Haskell.TH.Syntax type Cxt = [Pred]
07:43:39 <lambdabot> Language.Haskell.TH type Cxt = [Pred]
07:43:39 <lambdabot> Language.Haskell.TH.Lib cxt :: [PredQ] -> CxtQ
07:43:41 <bitonic> @hoogle Type
07:43:41 <lambdabot> Data.Typeable module Data.Typeable
07:43:42 <lambdabot> Foreign.C.Types module Foreign.C.Types
07:43:42 <lambdabot> System.Posix.Types module System.Posix.Types
07:43:52 <exFalso1> i'll rephrase
07:44:03 <exFalso1> if you have a context of type (Q Cxt)
07:44:08 <fryguybob> @oeis 1,1,1,1
07:44:11 <exFalso1> cxt :: Q Cxt
07:44:23 <lambdabot> Plugin `oeis' failed with: thread killed
07:44:26 <hpc> i suggest dealing with the issue of TH thinking it wants a type where it really wants a class context
07:44:34 <fryguybob> roconnor: I think you are on to something
07:44:44 <Mortchek> @oeis 1,4,9,16
07:44:44 <exFalso1> then [d| instance $(cxt) => SomeClass SomeType where |] will throw a type error saying it expects a Type
07:44:47 <lambdabot>  The squares: a(n) = n^2.
07:44:47 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
07:45:02 <exFalso1> hpc: yep
07:45:30 <bitonic> exFalso1: isn't [d| |] just for values declarations?
07:45:39 <exFalso1> its for any Dec
07:45:46 <bitonic> right
07:45:58 <bitonic> so what you want
07:46:07 <bitonic> is to generate a variable
07:46:11 <bitonic> and then create a type
07:46:26 <bitonic> ForallT [v] cxt v
07:46:27 <bitonic> and use that
07:46:42 <bitonic> where 'v' is the generate variable of course.
07:46:46 <bitonic> *generated
07:46:57 <bitonic> and then you have to use the 'v' in SomeType obviously
07:47:11 <roconnor> fryguybob: onto what?
07:47:19 <exFalso1> but that is a type of kind * which won't work for contexts?
07:47:42 <DMcGill> @oeis 1,1,1,3,5,9,18
07:47:45 <lambdabot>  Sequence not found.
07:47:50 <fryguybob> something to powerful for lambdabot's oeis plugin!
07:47:58 <bitonic> exFalso1: they will work, but you're giving it a context and obviously it wants a type
07:48:02 <bitonic> what you're doing now
07:48:19 <DMcGill> fryguybob: sum of previous 3 numbers
07:48:23 <bitonic> is 'instance Foo => Bar (Baz v) where'
07:48:33 <bitonic> you want 'instance Foo v => Bar (Baz v) where'
07:48:40 <DMcGill> that I got wrog
07:48:42 <DMcGill> wrong*
07:48:43 <exFalso1> no...
07:48:49 <exFalso1> Cxt is a list of Preds
07:49:01 <exFalso1> every type var is quantified there already
07:49:02 <bitonic> oh shit right, sorry.
07:49:35 <exFalso1> it *should* expect a Cxt
07:50:03 <bitonic> exFalso1: yeah, it does. can you post the code and the error?
07:50:31 <exFalso1> i tried to use the explicit InstanceD constructor but that behaves in a weird way
07:51:00 <bitonic> why?
07:51:09 <bitonic> post the code and error :P
07:51:13 <exFalso1> ok...
07:51:23 <exFalso1> err not many comments :)
07:51:57 <bitonic> you want too use 'instanceD' if you have a 'Q Cxt', but you probably already know that
07:52:47 <exFalso1> lol hpaste bugged
07:54:29 <exFalso1> http://pastebin.com/qT7BvZ9h  error at bottom
07:55:44 <hiptobecubic> @djinn (a->b->c) -> (d->e->f) -> (a, d) -> (c, f)
07:55:45 <lambdabot> -- f cannot be realized.
07:55:52 <bitonic> exFalso1: let's see...
07:56:03 <t7> > foldl (\x y -> x ++ (map fst (reads y :: [(Int, String)]))) [] "123 4"
07:56:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:56:04 <lambdabot>         against inferred ty...
07:56:15 <t7> > foldl (\x y -> x ++ (map fst (reads [y] :: [(Int, String)]))) [] "123 4"
07:56:17 <lambdabot>   [1,2,3,4]
07:56:18 <exFalso1> with InstanceD it will generate a new unique name for the function implementation...
07:56:28 <exFalso1> (schema here)
07:56:29 <t7> > foldl (\x y -> x ++ (map fst (reads [y] :: [(Int, String)]))) [] "12asd3asd45"
07:56:30 <lambdabot>   [1,2,3,4,5]
07:57:48 <hiptobecubic> @djinn (a->a)
07:57:48 <lambdabot> f a = a
07:58:02 <hiptobecubic> Why can my previous f not be realized?
07:58:16 <hiptobecubic> oh i had my sig backwards
07:58:25 <t7> @djinn a -> b
07:58:25 <lambdabot> -- f cannot be realized.
07:58:29 <hiptobecubic> @djinn (a->b->c) -> (d->e->f) -> (a, c) -> (d, f)
07:58:29 <lambdabot> -- f cannot be realized.
07:58:30 <t7> it doesnt really mean f
07:58:46 <Twinsen> can i define a Type synonym that is deriving Show?
07:58:56 <hiptobecubic> @djinn (a->b->c) -> (d->e->f) -> (a, d) -> (c, f)
07:58:56 <lambdabot> -- f cannot be realized.
07:59:07 <sansor> hi all, i have a code that uses map and works fine
07:59:14 <fryguybob> > let boolFibs = scanl (||) False (True:boolFibs) in boolFibs
07:59:15 <lambdabot>   [False,True,True,True,True,True,True,True,True,True,True,True,True,True,Tru...
07:59:29 <sansor> if i use parMap it gives a stackoverflow error
07:59:32 <exFalso1> Twinsen: it's a synonym meaning that as long as the rhs derived Show the lhs will have Show
07:59:35 <sansor> does anyone have that problem?
07:59:44 <bitonic> exFalso1: return (InstanceD cxt typ [FunD 'schema [Clause [] (NormalB sch) []]])
08:00:00 <t7> @pl (\x y -> x ++ (map fst (reads [y] :: [(Int, String)])))
08:00:00 <lambdabot> (. (map fst . (:: [(Int, String)]) . reads . return)) . (++)
08:00:05 <bitonic> didn't try with QQ, you can figure that out :P
08:00:05 <dschoepe> hiptobecubic: Such a function has no value of type b and none of type e, so it can't make use of the functions it gets as arguments.
08:00:12 <exFalso1> bitonic: ah and 'schema is quaranteed to be that function
08:00:18 <exFalso1> bitonic: thanks!
08:00:25 * hackagebot dtd 0.4.0 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-0.4.0 (MichaelSnoyman)
08:00:26 <bitonic> 'schema is the 'schema' in scope
08:00:29 <bitonic> exFalso1: np
08:00:31 <hiptobecubic> dschoepe, oh of course. i forgot some arguments
08:00:34 <hiptobecubic> dschoepe, thanks
08:00:52 <MaskRay> is hedis better than redis?
08:00:57 <hiptobecubic> @djinn (a->b->c) -> (d->e->f) -> (a, d) -> (b, e) -> (c, f)
08:00:57 <lambdabot> f a b (c, d) (e, f) = (a c e, b d f)
08:01:21 <DMcGill> @help djinn
08:01:22 <lambdabot> djinn <type>.
08:01:22 <lambdabot> Generates Haskell code from a type.
08:01:22 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
08:01:32 <DMcGill> @help pf
08:01:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:01:38 <roconnor> I think there sould be a standard Dioid class
08:01:50 <roconnor> when Monoid won't due
08:02:07 <hiptobecubic> roconnor, turning it up to eleven?
08:02:16 <sansor> does anyone have experience with parMap
08:02:24 <roconnor> hiptobecubic: more like turning it up to 2
08:03:05 <hiptobecubic> roconnor, unary 11?
08:03:07 <jeff_s_> Crap.... anyone have a suggestion for tracking down a cause for an "unkown symbol" error when linking a library? Could it be due to my use of "undefined"?
08:03:16 <roconnor> hiptobecubic: *l*
08:03:26 <merijn> jeff_s_: Maybe its not exported?
08:03:27 <jeff_s_> The library I'm linking is Haskell-only, no c.
08:03:38 <roconnor> jeff_s_: shouldn't be related to undefined
08:03:57 <quicksilver> jeff_s_: did you use ghc --make ?
08:03:58 <roconnor> ironically undefined is perfectly well-defined.
08:04:13 <quicksilver> in the prelude, too, so it's quite hard to avoid linking it.
08:04:24 <quicksilver> jeff_s_: pasting your error message might help
08:04:26 <sansor> anyone? parMap experiences?
08:04:28 <jeff_s_> merijn - I think you're right that it's not exported. What a terrible error message I got for something so simple.
08:04:57 <merijn> jeff_s_: Linker can't know that
08:05:06 <merijn> Since it might not be linking just haskell code
08:05:18 <quicksilver> jeff_s_: that should never be a linker error.
08:05:28 <quicksilver> jeff_s_: if it's not exporting you get a compiler error.
08:05:42 <sansor> anyone? parMap experiences?
08:06:23 <quicksilver> sansor: if someone knew they'd probably already have replied; re-asking every minute isn't really necessary
08:06:42 <sansor> quicksilver: sorry
08:06:45 <jeff_s_> Loading package wda-rtb-0.6 ... linking ... ghc: /root/.cabal/lib/mylibname-0.6/ghc-7.0.4/HSmylibname-0.6.o: unknown symbol `__stginit_xxxzmxxxzm0zi6_XXXziXXXzixx_'
08:06:55 <jeff_s_> bah, I didn't sanitize that all the way. Oh well.
08:07:38 <jeff_s_> ya, the missing export was definitely the problem.
08:07:56 <ozataman_> has anyone been getting "Something is amiss; requested module  template-haskell-2.6.0.0:Language.Haskell.TH.Syntax differs from name found in the interface" errors with 7.4.1?
08:08:25 <quicksilver> jeff_s_: that's very peculiar.  A missing export should have caused an error at compile time.
08:08:43 <quicksilver> maybe you can get that by a .hi/.o mismatch.
08:08:48 <quicksilver> ozataman_: yes.
08:09:04 <ozataman_> what the heck is going on? this keeps happening over and over again
08:09:09 <jeff_s_> quicksilver - it was an export missing in my cabal file, not the library itself, if that makes a difference.
08:09:20 <ozataman_> removing the lib and reinstalling helped in some of the cases
08:09:24 <quicksilver> oh, probably jeff_s_
08:09:32 <quicksilver> ozataman_: http://hackage.haskell.org/trac/ghc/ticket/5704
08:09:39 <dcoutts> jeff_s_: yeah, sorry, that's not tracked yet
08:10:41 <ozataman_> ouch. th-2.7 breaks some of my code in my example case so I can't use it readily
08:10:42 <quicksilver> ozataman_: mostly "don't try to use a version of template-haskell other than the one that comes with GHC"
08:11:05 <jeff_s_> dcoutts: That's ok, merijn gave me the hint I needed, and I'll know what to look for in the future.
08:11:31 <ozataman_> ClassI Dec [InstanceDec] - it no longer exposes the InstanceDec internals like it used to, which is what stopped a cursory trial to port my code
08:13:00 <t7> @pl if a then b else c
08:13:00 <lambdabot> if' a b c
08:13:14 <t7> @hoogle if'
08:13:14 <lambdabot> No results found
08:14:23 <hpc> @pl \p f x -> if p x then f x else x
08:14:23 <lambdabot> flip flip id . (ap .) . liftM2 if'
08:14:31 <hpc> :t liftM2 if'
08:14:32 <lambdabot> Not in scope: `if''
08:14:46 <hpc> :t let if' p t f = if p then t else f in liftM2 if'
08:14:47 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m (a2 -> a2)
08:15:52 <hpc> :t \p f -> if' <*> p <*> f
08:15:53 <lambdabot> Not in scope: `if''
08:16:02 <hpc> @let if' p t f = if p then t else f
08:16:03 <lambdabot>  Defined.
08:16:25 <koala_man> what do you call those code snippets that are valid syntax in several different languages?
08:16:40 <donri> polyglot?
08:17:04 <donri> https://en.wikipedia.org/wiki/Polyglot_%28computing%29
08:17:04 <hpc> ah
08:17:05 <hpc> @ty \p f -> if' <$> p <*> f <*> id
08:17:06 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
08:17:20 <DMcGill> @help ty
08:17:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:17:23 <koala_man> donri: yay, thanks
08:17:38 <hpc> it's @type
08:17:44 <DMcGill> ah, ok
08:17:55 <DMcGill> odd that help doesn't recognise it
08:18:25 <pqmodn> koala_man: see also, http://en.wikipedia.org/wiki/Cognate
08:18:45 <donri> of course, most programs can be made polyglot to whitespace ;)
08:19:31 <DMcGill> isn't the standard tactic just abuse of comments?
08:19:37 <hpc> yes
08:19:44 <hpc> or #define
08:20:39 <hpc> :t join .: liftA2 if'
08:20:40 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
08:20:42 <hpc> yay!
08:20:54 <hpc> (@pl by hand is fun)
08:22:25 <t7> > let cardValid = cv = (== 0) . (`mod` 10) . (snd . foldl (\(eo,s) x -> if eo then (not eo, s + (sum . unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10))) (x * 2)) else (not eo, x + s)) (False, 0)) . (foldl (\x y -> x ++ (map fst (reads [y] :: [(Int, String)]))) []) in cardValid "49927398716"
08:22:26 <lambdabot>   <no location info>: parse error on input `='
08:22:34 <t7> > let cardValid = (== 0) . (`mod` 10) . (snd . foldl (\(eo,s) x -> if eo then (not eo, s + (sum . unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10))) (x * 2)) else (not eo, x + s)) (False, 0)) . (foldl (\x y -> x ++ (map fst (reads [y] :: [(Int, String)]))) []) in cardValid "49927398716"
08:22:36 <lambdabot>   True
08:23:04 <hpc> o.O
08:23:31 <t7> @pl (== 0) . (`mod` 10) . (snd . foldl (\(eo,s) x -> if eo then (not eo, s + (sum . unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10))) (x * 2)) else (not eo, x + s)) (False, 0)) . (foldl (\x y -> x ++ (map fst (reads [y] :: [(Int, String)]))) [])
08:23:35 <lambdabot> (0 ==) . (`mod` 10) . snd . foldl (uncurry (ap (ap . (ap .) . ap ((.) . (.) . if') ((. ((. (sum . unfoldr (ap (flip if' Nothing . (0 ==)) (Just . liftM2 (,) (`mod` 10) (`div` 10))) . (2 *))) . (+)))
08:23:35 <lambdabot> . (.) . (,) . not)) ((. (+)) . (.) . (,) . not))) (False, 0) . foldl ((. (map fst . (:: [(Int, String)]) . reads . return)) . (++)) []
08:23:35 <lambdabot> optimization suspended, use @pl-resume to continue.
08:23:41 <t7> lol
08:23:53 <hpc> don't bother resuming, that usually means it looped
08:25:58 <t7> doesnt work for uk cards :(
08:26:33 <t7> oh bugger its right to left
08:26:43 <t7> back to the drawing board
08:29:42 <t7> >let validCCard = cv = (== 0) . (`mod` 10) . (snd . foldl (\(eo,s) x -> if eo then (not eo, s + (sum . unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10))) (x * 2)) else (not eo, x + s)) (False, 0)). reverse . (foldl (\x y -> x ++ (map fst (reads [y] :: [(Int, String)]))) []) in validCCard "4992 7398 716"
08:29:47 <t7> > let validCCard = cv = (== 0) . (`mod` 10) . (snd . foldl (\(eo,s) x -> if eo then (not eo, s + (sum . unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10))) (x * 2)) else (not eo, x + s)) (False, 0)). reverse . (foldl (\x y -> x ++ (map fst (reads [y] :: [(Int, String)]))) []) in validCCard "4992 7398 716"
08:29:47 <lambdabot>   <no location info>: parse error on input `='
08:29:54 <t7> > let validCCard = (== 0) . (`mod` 10) . (snd . foldl (\(eo,s) x -> if eo then (not eo, s + (sum . unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10))) (x * 2)) else (not eo, x + s)) (False, 0)). reverse . (foldl (\x y -> x ++ (map fst (reads [y] :: [(Int, String)]))) []) in validCCard "4992 7398 716"
08:29:55 <lambdabot>   True
08:30:00 <t7> better
08:32:09 * roconnor knows t7's credit card number.
08:32:23 <t7> nah thats the one on the example website :)
08:32:43 <roconnor> that number looks about 5 digits too short to me.
08:32:52 <t7> yeah i tried my visa and it works too
08:33:03 <copumpkin> > 1.05^(365 * 40) :: CReal
08:33:05 <lambdabot>   231082161445116226471053067320310105199568399287057787916064395634202710765...
08:33:06 <roconnor> t7: I don't believe you.  Try it on lambdabot.
08:33:10 <roconnor> >:)
08:33:18 <t7> hohoho
08:34:14 <copumpkin> > length . show $ 1.05^(365 * 40)
08:34:15 <lambdabot>   8
08:34:16 * roconnor knows copumpkin's credit card's daily interest rate.
08:34:22 <copumpkin> > length . show $ 1.05^(365 * 40) :: CReal
08:34:23 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
08:34:23 <lambdabot>         against infe...
08:34:25 <copumpkin> dammit
08:34:35 <copumpkin> > length . show $ (1.05^(365 * 40) :: CReal)
08:34:38 <lambdabot>   351
08:34:38 <roconnor> @type showCReal
08:34:38 <lambdabot> Int -> CReal -> String
08:34:51 <copumpkin> roconnor: yeah :(
08:35:09 <roconnor>  length . showCReal 0 $ (1.05^(365 * 40))
08:35:11 <roconnor> > length . showCReal 0 $ (1.05^(365 * 40))
08:35:11 <copumpkin> damn cash advances
08:35:12 <hpc> copumpkin: man, i would love to get 5% daily interest on my money
08:35:13 <lambdabot>   310
08:35:23 <copumpkin> hpc: I have the perfect solution for you!
08:35:26 * hackagebot shelly 0.3.0.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.3.0.2 (GregWeber)
08:35:26 <copumpkin> hyipbit.com
08:35:27 <hpc> lawl
08:35:35 <roconnor> *lol*
08:35:39 <copumpkin> the next bitcoin ponzi scheme
08:35:43 <copumpkin> everyone invest, quick
08:36:06 <copumpkin> at least earlier bitcoin ponzis actually advertised themselves as ponzi schemes. This one actually pretends to be legit
08:37:49 <roconnor> http://homepage.smc.edu/nestler_andrew/trapezoid.jpg
08:39:14 <roconnor> copumpkin: I like how that number exceed the total number of allowable bitcoins, or even satoshis.
08:39:31 <copumpkin> or atoms in the universe, as dolio points out
08:39:47 <roconnor> pfft atoms
08:40:09 <roconnor> tell me when it exceeds the plank surface area of the universe.
08:40:21 <t7> you can track a number higher than the number of atoms in the universe
08:40:49 <t7> in theory
08:41:03 <copumpkin> t7: wildberger would disagree
08:41:13 <Mathnerd314> copumpkin: there are market inefficiencies that be exploited...
08:41:28 <t7> depending on whether an electron is charged or not treat it as a bit
08:41:32 <t7> or something like that
08:41:38 <copumpkin> Mathnerd314: I don't doubt it, but 5% a day is a pretty grand claim :)
08:41:46 <copumpkin> (or even 6%)
08:42:25 <roconnor> copumpkin: do they mean solar days or sidereal days?
08:42:35 <copumpkin> who knows :P
08:42:38 <copumpkin> I'm staying the hell away
08:42:48 <roconnor> I'm all in
08:42:59 <copumpkin> roconnor: with _all_ of your bitcoins?
08:43:02 <copumpkin> shit
08:43:03 <roconnor> yep
08:43:18 <dolio> They mean simultaneous 4-day time cubes.
08:43:22 <roconnor> so fair they have made good on their claims.
08:43:26 <roconnor> *far
08:44:17 <Mathnerd314> roconnor: how many bitcoins do you have?
08:44:58 <roconnor> Mathnerd314: 0
08:45:13 <dolio> He's getting even higher than 5%/day interest!
08:45:26 * hackagebot dtd 0.4.1 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-0.4.1 (MichaelSnoyman)
08:45:49 <Mathnerd314> roconnor: so you invested 0 bitcoins to get 0 back?
08:45:57 <Guest25143> jens
08:46:03 <Guest25143> sorry!!
08:46:21 <roconnor> Mathnerd314: I sort of cut out the middle man and just reap the 5% per day directly.
08:46:40 <roconnor> Mathnerd314: no point in paying out a management fee to those hyipbit people.
08:48:14 <copumpkin> true that
08:48:20 <copumpkin> plus he eliminates counterparty risk that way
08:48:29 <copumpkin> in fact, with 0 coins he also eliminates currency risk
08:48:43 <copumpkin> with infinite returns, that's a pretty good investment
08:51:03 <hpc> copumpkin: wow, infinity percent? im tripling my investment!
08:51:56 <roconnor> To be fair, I've also hit gambler's ruin
08:52:16 <dca> hi
08:52:19 <weexplat> it's kind of weird that an expression like (3 !) is constrained so that it can only return a function
08:52:20 <roconnor> hi
08:52:26 <dca> any ideas that doesn't wanna typecheck? http://dpaste.com/720082/
08:52:34 <hpaste> timthelion pasted “Is there a better way of accessing data properties than having hundreds of lines if cellNext, or cellPath ect functions?” at http://hpaste.org/65750
08:54:34 <roconnor> dca: fivs2 :: [Int] -> Int -> Int -> Int should be fivs2 :: [Int] -> Int -> Int
08:54:56 <dca> omg
08:55:00 <dca> thank you
08:55:34 <dca> but why such a cryptic message:
08:55:34 <dca>     Couldn't match expected type `Int -> Int' with actual type `Int'
08:55:34 <dca>     In the return type of a call of `ifbAdd'
08:55:34 <dca> ?
08:56:08 <hpc> dca: it's not really cryptic, it's just a generic message for all kinds of type errors
08:56:24 <hpc> it says "i thought i was getting Int, but i really got Int -> Int"
08:56:25 <roconnor> dca: it is trying to say that fivs2 :: [Int] -> Int -> **Int -> Int** should be fivs2 :: [Int] -> Int -> **Int**
08:56:34 <roconnor> dca: I agree it is cryptic.
08:56:53 <roconnor> er wait
08:57:04 <roconnor> dca: I take that back
08:57:15 <geekosaur> it's confusing, but an inevitable consequence of curried function application
08:57:21 <roconnor> dca: basically it is hard to identify the real source of typing errors.
08:57:36 <soc1234> hello channel
08:57:50 <dca> so it tries to make curry application to ifbAdd ?
08:57:56 <timthelion> can someone/is someone look at/looking at/ the code I just pasted?
08:58:08 <dca> (if type signature is original)
08:58:28 <soc1234> im new in haskell and i have to make a homework....is there anyone who can help me?
08:58:31 <roconnor> dca: it was thinking for fivs2 to have type [Int] -> Int -> (Int -> Int), then the foldl needs to return an (Int -> Int), which means that ifbAdd needs to return an (Int -> Int) but it doesn't.
08:58:55 <timthelion> soc1234: what is your question? what have you tried, do you have an error message? what do you know about haskell?
08:59:04 <roconnor> dca: anyhow, the source of type errors can be hard to isolate since there are multiple plausible ways of fixing type errors.
08:59:50 <snhmib_> timthelion: you can make records with selectors of the same name
09:00:19 <dca> ok
09:00:20 <dca> thank you
09:01:18 <timthelion> snhmib_: aha, I see now
09:01:19 <snhmib_> timthelion: data AB = A {same_thing :: Int, somethingelse :: String } | B { same_thing :: Int, somethingdifferent :: Int }
09:01:39 <snhmib_> blah :: AB -> Int   blah x = same_thing x
09:02:15 <timthelion> snhmib_: thankyou.  Sometimes one just needs a word to google :)
09:02:59 <snhmib_> np :) i only learned that recently as well... made me very happy :)
09:04:02 <soc1234> hello...i have to make a program called redact that redacts certain words in a text file and replacing them with stars(***)...Is there anyone to help me please?
09:04:23 <timthelion> soc1234: well you are reading the text from a file?  This should be very easy.  Do you know haskell's syntax?
09:05:27 * hackagebot transformers 0.3.0.0 - Concrete functor and monad transformers  http://hackage.haskell.org/package/transformers-0.3.0.0 (RossPaterson)
09:08:24 <soc1234> yeah i am reading a text from a text file and i have to put some words as a command line arguments....then that certain words should be replaced with stars(***) from the text file#
09:09:23 <timthelion> soc1234: do you know how to read the text from the file?
09:12:27 <teneen> Can GADTs always replace dependent types?
09:12:53 <notrusty> i need some advice tracking down a space leak...
09:13:32 <lifestream> y
09:13:46 <danr> teneen: no, you need to be able to lift values to the type level
09:14:09 <danr> while you can do GADT equality between types, you cannot do it between values
09:14:53 <danr> for instance, you cannot prove that x + y = y + x in Haskell unless you only restrict yourself to type-level arithmetic
09:15:31 <notrusty> my program is WriterT State, (State and Writer both strict), and my state and tell are both large Data.Sequences
09:16:00 <teneen> danr: But as far as type-level programming is concerned, are they equivalent?
09:16:20 <soc1234> timthelion: Im not sure what u mean.... in order to import a text file to my program i have to use : cat poem.txt | ./redact      and then put some certain words to replace with (***) in my text file right?
09:16:52 <whittle> What is The Haskell Way to write asynchronous network interfaces? Is Reactive the way to go?
09:17:17 <quicksilver> soc1234: the impression I get is that you don't know much about how to programm in haskell. Can I suggest a beginner's guide like LYAH ?
09:17:19 <timthelion> soc1234: fine, so do you know how to read the arguments that are passed to your program and read from standard input?
09:17:20 <quicksilver> @where lyah
09:17:20 <lambdabot> http://www.learnyouahaskell.com/
09:17:42 <quicksilver> whittle: "The Haskell Way" is just to use threads. IO in GHC is intrinsicially non-blocking if you use a threaded style.
09:18:09 <quicksilver> whittle: reactive (and other FRP) is cool, and possibly nicer, but not a well-trodden path.
09:19:08 <notrusty> i get a stack space overflow, and my heap graph shows a THUNK_1_0 expanding steadily
09:20:03 <danr> teneen: It is hard to give a precise answer to this without knowing exactly what restrictions you want to enforce. But you can come pretty far, although usually with a lot of pain, with type level computation with type families in Haskell
09:20:25 <whittle> quicksilver: Thank you; good to know.
09:20:26 <soc1234> qucksilver: i know the basics but im still confused... thank you for the LYAH i will take a look
09:20:47 <whittle> Does Haskell/GHC provide a good way to test threads/threaded programs?
09:21:24 <hpc> teneen: if your goal is dependent haskell, you can go pretty far with agda + {-# OPTIONS --no-termination-check #-}
09:21:29 <drdo> whittle: http://www.haskell.org/haskellwiki/ThreadScope
09:21:33 <soc1234> timthelion: No i dont know how
09:21:38 <danr> whittle: what do you want to test? you can visualise performance using ThreadScope
09:21:56 <danr> but if you want to test parallel programs, you can still use quickcheck
09:22:58 <timthelion> soc1234: it's very hard to explain everything.  I think quicksilver is right, that you should read at least the first few chapters of that book.
09:23:45 <soc1234> timthelion: ok thank you i will take a look
09:23:48 <ClaudiusMaximus> notrusty: strict State is strict in the actions, not the value in the state - you probably want to    put $! thing   or  use a strict modify
09:26:03 <whittle> danr: Gotcha. I’m new to Haskell and used to relying on extensive testing in other (interpreted) languages, so I mostly just want to make sure I don’t regress to a methodology of “compile it and see.”
09:26:53 <whittle> s/testing/test suites/
09:30:21 <mrcarrot> whittle: haskell has a compiler, interpreter and an interactive shell
09:33:08 <whittle> You’re right, of course, mrcarrot. It would have been more apt of me to say non-type-safe languages.
09:34:26 <ChristianS> whittle: haskell is very type-safe, thank god.
09:35:01 <sm> re asynchronous network interfaces, shouldn't whittle be looking at https://github.com/jepst/CloudHaskell
09:36:39 <whittle> Whoo! Cloud Haskell looks pretty fun, sm.
09:38:41 <sm> on hackage, it's "remote"
09:39:48 <Tekmo> What is the conventional library to use on Hackage for the fixed point of a functor?  I did some searching found Data.Functor.FixedPoint from unification-fd, Generics.Pointless.Functors from pointless-haskell, and Control.Functor.Fix from category-extras.  I can obviously roll my own Fix data type in a single line of code and lose a dependency, but I wanted to see if I could base it on a library that provides a lot of well-thought-out utility functi
09:39:50 <Tekmo> ons for working with fixed points.
09:40:17 <edwardk> recursion-schemes has one, unification-fd just rolled his own to avoid the dependency
09:40:28 * hackagebot monad-loops 0.3.2.0 - Monadic loops  http://hackage.haskell.org/package/monad-loops-0.3.2.0 (JamesCook)
09:40:30 <edwardk> and category-extras is retired, the recursion-schemes is where that part landed
09:40:42 <Tekmo> Thanks, let me check out recursion-schemes
09:40:59 <Tekmo> Perfect!
09:41:05 <Tekmo> This is exactly what I was looking for.  Thanks
09:41:11 <edwardk> np
09:44:26 <notrusty> hmm, wrapping that transformer stack around IO and adding a few "You are here" print-outs seems to have made it stop crashing
09:44:52 <notrusty> i think it's spending a whole lot of time garbage collecting, though
09:50:42 <timthelion> oooo literate haskell.  Haskell love all around :)  I think I will never write anything, as for every new line of code I write, I discover a new language feature and wish to start over...
09:51:56 <hpc> timthelion: don't worry, eventually you'll get to the point where it takes a month to absorb a new feature
09:52:11 <hpc> that's when the real fun starts :D
09:53:07 <timthelion> I'm still trying to figure out why there aren't more applications(aka gui) written in haskell.
09:54:54 <hpc> timthelion: https://cdsmith.wordpress.com/2011/03/13/haskells-niche-hard-problems/ -- this might help explain it
09:55:11 <hpc> GUI falls into the category of "boring" or "easy" problems
09:55:24 <hpc> where your biggest struggle is getting the damn gtk file chooser to work
09:55:54 <hpc> hard problems have easier solutions
09:57:16 <sm> timthelion: no compelling cross-platform gui libraries
09:57:50 <sm> some of us are opting for web apps instead
09:58:32 <timthelion> sm: what does C++ have in that regard that haskell does not?
09:58:45 <koeien> Qt
09:59:05 <elemir> timthelion: unusability
09:59:25 <sm> I think not much, aside from large well-funded commercial teams. If you had those in haskell, you'd see more gui apps
09:59:51 <sm> well, and gui libs are of course plenty more mature
10:00:04 <koeien> microsoft visual studio
10:00:07 <elemir> Haskell is very usable, it is unacceptable for c++ programmers
10:00:20 * sm adds and the tools
10:00:21 <hpc> sm: and legions of FOSS programmers who know enough to write GUI code but not enough to do more interesting things
10:00:30 <hpc> (begin flame war in 3, 2, 1..)
10:00:40 * sm adds and the best practices & patterns
10:00:42 <koeien> hpc: and they all work on KDE. /me runs :)
10:01:03 <elemir> KDE? Is it still alive?
10:01:08 <koeien> sure it is
10:01:11 <hpc> koeien: my suspicion is somebody told them that C was "C++ without templates" and they all work on GNOME now
10:01:24 <jfischoff> is there any way to tell if a value is undefined?
10:01:32 <koeien> i was taking a jab at KDE because of the perceived (by me) bugginess
10:01:33 <hpc> jfischoff: got a halting oracle?
10:01:35 <koeien> jfischoff: no.
10:01:45 <koeien> jfischoff: this would be akin to solving the Halting problem
10:02:04 <sm> ok, ASIDE from the large well-funded commercial teams and the more mature gui libs, tools, best practices & patterns... C++ doesn't have much over haskell for guis
10:02:10 * elemir thought that all gui-fucker have switched to tablets
10:02:19 <hpc> > let isItDefined = length [1..] in isItDefined
10:02:22 <lambdabot>   mueval-core: Time limit exceeded
10:02:29 <koeien> mailrank was writing its backend in haskell, front-end in C# iirc.
10:02:35 <koeien> this might be fairly typical
10:02:36 <jfischoff> hpc: great, its always the oracles you through out you need
10:02:58 <jfischoff> hpc: it was such a great yardsale find
10:03:39 <jfischoff> Wait, the runtime could do it.
10:03:53 <jfischoff> sure at compile time it would be impossible
10:04:05 <koeien> no, how?
10:04:19 <jfischoff> but the runtime could provide and isUndefined function.
10:04:26 <koeien> findSmallestGoldbachCounterexample = ...
10:04:42 <koeien> isUndefined findSmallestGoldbackCounterexample
10:04:56 <elemir> :t isUndefined
10:04:57 <lambdabot> Not in scope: `isUndefined'
10:05:24 <ski> > seq undefined ()
10:05:25 <lambdabot>   *Exception: Prelude.undefined
10:05:30 <jfischoff> koeien: My understanding is that undefined thunks are different from evaluated ones
10:05:48 <koeien> jfischoff: if you're only interested in calls to "error", you can use spoon. but, it's fairly evil
10:06:21 <ski> jfischoff : semantically, `error ...' and a non-terminating computation are treated in the same way, both represented abstractly by the symbol `_|_'
10:06:39 <koeien> (i.e. evil in the sense that it uses unsafePerformIO)
10:06:53 <jfischoff> koeien: totally that would be the only way
10:07:07 <jfischoff> there is now way to do with system F omega for sure
10:07:20 <jfischoff> okay I'll look at spoon
10:07:41 <koeien> the haskell way is to use Maybe or Error or something like that
10:07:51 <elemir> Either
10:08:04 <ski> jfischoff : *why* do you want to do this ?
10:08:04 <koeien> yup, also reasonable
10:08:20 <jfischoff> Honestly, I was just curious
10:09:00 <ski> jfischoff : the normal approach would be to not have `undefined's in the first place, if possible
10:09:13 * elemir thinks that haskell way isn't good
10:09:32 <dzhus> is there a shortcut for \d v -> maybe d id v ?
10:09:33 <jfischoff> ski: no doubt
10:09:52 <koeien> :t \d v -> maybe d iv v
10:09:53 <lambdabot> Not in scope: `iv'
10:09:55 <koeien> :t \d v -> maybe d id v
10:09:56 <lambdabot> forall a. a -> Maybe a -> a
10:09:57 <elemir> @type \d v -> maybe d id v
10:09:58 <lambdabot> forall a. a -> Maybe a -> a
10:10:04 <ClaudiusMaximus> :t fromMaybe
10:10:05 <elemir> @type fromMaybe
10:10:05 <lambdabot> forall a. a -> Maybe a -> a
10:10:06 <lambdabot> forall a. a -> Maybe a -> a
10:10:09 <elemir> Argh
10:10:13 <elemir> :)
10:10:18 <weexplat> > let fibs = scanl (+) 0 $ 1:fibs in take 20 $ zipWith(flip(/))<*>tail $ fibs
10:10:21 <lambdabot>   [Infinity,1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619...
10:10:24 <koeien> dzhus: hoogle is very useful for this
10:10:31 <koeien> just enter a -> Maybe a -> a
10:10:41 <koeien> @hoogle a -> Maybe a -> a
10:10:42 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
10:10:42 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:10:42 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
10:10:46 <ski> dzhus : (`maybe` id)
10:10:46 <elemir> @pl (\d v -> maybe d id v)
10:10:47 <lambdabot> flip maybe id
10:11:08 * ski grins
10:11:39 <dzhus> fromMaybe! I thought we only have kludgy fromJust & fromNothing
10:12:13 <koeien> yes those are evil.
10:12:45 <ClaudiusMaximus> fromNothing?!
10:13:07 <elemir> > fromNothing Nothing 0
10:13:08 <koeien> fromNothing (Just _) = error "surely you did not mean that"
10:13:08 <lambdabot>   Not in scope: `fromNothing'
10:14:08 <parcs`> > let fibs = scanl (+) 0 $ 1:fibs in  last $ take 200 $ zipWith(flip(/))<*>tail $ fibs
10:14:09 <lambdabot>   1.618033988749895
10:14:14 <dzhus> well, right, just fromJust
10:16:17 <parcs`> > (1 + sqrt(5)) / 2
10:16:18 <lambdabot>   1.618033988749895
10:16:53 <Mathnerd314> parcs`: needs more precision
10:17:45 <parcs`> > (1 + sqrt(5)) / 2 :: CReal
10:17:46 <lambdabot>   1.6180339887498948482045868343656381177203
10:17:53 <parcs`> > let fibs = scanl (+) 0 $ 1:fibs in  last $ take 200 $ zipWith(flip(/))<*>tail $ fibs :: CReal
10:17:57 <lambdabot>   mueval-core: Time limit exceeded
10:18:02 <ion> I expected that.
10:18:23 <Mathnerd314> :t (/)
10:18:23 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:18:59 <Mathnerd314> > let fibs = scanl (+) 0 $ 1:fibs in last $ take 200 $ zipWith(flip(/))<*>tail $ map fromIntegral fibs :: CReal
10:19:00 <lambdabot>   1.6180339887498948482045868343656381177203
10:19:38 <Mathnerd314> hmm... maybe they are equal :p
10:20:25 <rata_> hi guys
10:20:28 <koeien> hi rata_
10:20:57 <Franciman_> hey people why is forall useful, and what purpose does it serve?
10:21:23 <koeien> it introduces a type variable and is necessary for some constructs (existentialt ypes, higher rank types i think)
10:21:37 <weexplat> danr: you can do something like data Nat = Z | S Nat; data Nat2 :: Nat -> * where { Z2 :: Nat2 Z ; S2 :: Nat2 a -> Nat2 (S a) } to synchronize type-level and value-level arithmetic
10:21:43 <koeien> however, for your run-of-the-mill types it does not matter
10:21:56 <koeien> a -> b -> a, you can write this as forall a b. a -> b -> a  if you want
10:22:01 <weexplat> danr: there are still some limitations, of course
10:23:16 <Mathnerd314> Franciman_: it's used in the ST monad:
10:23:25 <Mathnerd314> :t runST
10:23:26 <lambdabot> forall a. (forall s. ST s a) -> a
10:23:44 <koeien> yes that's a rank2 type
10:24:19 <ski> Franciman_ : see e.g. the types of `trivialFix' and `traceFix' at <http://hpaste.org/10060/repaste_of_poormandebug> for an example of a rank-2 type signature
10:24:27 <alpounet> Franciman_, in the runST example, you see that 's' is only defined inside the parens, so it can't appear in the return type
10:24:56 <alpounet> it kind of "keeps" the user from propagating the state outside runST
10:25:01 <ski> Franciman_ : i that case, i use rank-2 types to hide aspects of the implementation
10:25:05 <louise> @absence
10:25:05 <lambdabot> Unknown command, try @list
10:25:37 <ski> louise : itym s/@absence/absence : /
10:26:32 <ski> absence : apparently louise wanted to get your attention ^
10:26:44 * ski shakes head
10:27:30 <ski> Franciman_ : anyway, by using a rank-2 type, you can pass a *polymorphic* function as argument to another function
10:28:34 <ski> Franciman_ : .. did we scare you away ?
10:32:51 <eacameron> does anyone know of a library working with Couchbase (previously Membase)?
10:40:40 <gwern> > 4 + 1 / 5 + 2
10:40:41 <lambdabot>   6.2
10:41:00 <gwern> lies!
10:41:04 <gwern> CURSE YOU PEMDAS
10:41:21 <gwern> WILL I NEVER HAVE RESPITE FROM YOUR TRICKERY
10:41:27 <gwern> > (4 + 1) / (5 + 2)
10:41:28 <lambdabot>   0.7142857142857143
10:41:38 <mekeor> unlock capslock pls
10:42:06 <gwern> no! capslock is cruise control for cool
10:42:18 <koeien> OH THANKS NOW IT IS EASIER
10:43:03 <mekeor> eacameron: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:database
10:43:25 <mekeor> especially:
10:43:29 <mekeor> @package CouchDB
10:43:30 <lambdabot> http://hackage.haskell.org/package/CouchDB
10:43:47 <mekeor> Which introductory book to type theory can you recommend?  (Of course, there's a lot of such books but I'm looking for one that is capable for autodidactic and comprehensible by an ordinary Haskeller.)
10:44:02 <ski> TaPL ?
10:44:15 <ski> @where TaPL
10:44:16 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
10:44:20 <rata_> is it shadowing always an evil thing stylistically? or is it appropiate when you actually want to hide something in a lexical space/context?
10:44:41 <mekeor> ski: hmm… could be nice but it's expensive :/
10:46:20 <eacameron> mekeor: Yeah...I checked there too. unfortunately CouchDB is not the same as Couchbase
10:46:20 <ski> rata_ : things similar to `do x <- f x; (x,a) <- g x; x <- h (i a) x; ..x..' is commonly written in the MLs (and in Clean)
10:46:56 <ski> (possibly Scheme as well)
10:47:12 <mekeor> eacameron: oh! i'm sorry! oops =)
10:47:59 * albel727 found it really expensive to download TaPL just now. whole 20 seconds!
10:48:41 <Senmorta> lol
10:48:42 <ski> mekeor : well, it's the only one i know about :)
10:49:03 <eacameron> mekeor: still...not too many db servers with "couch" in the name. ;)
10:49:07 <hpaste> timthelion pasted “Cabal error” at http://hpaste.org/65753
10:49:29 <rata_> ski: ok... I was just doing it and then I remind some people here said it was evil
10:49:29 <timthelion> Hello, why am I getting this error? The code compiles without a problem.
10:49:31 <rata_> =P
10:49:32 <nart> a good book about Category Theory ?
10:49:38 <sykora> I have a function `f :: (a -> b) -> (b -> Bool) -> a -> Bool`, how can I express `notf g h x = not $ f g h x` point-free?
10:49:59 <ski> rata_ : well, i think you shouldn't do it unless you have a good reason :)
10:50:01 <mekeor> ski: well, i also know this one:
10:50:05 <mekeor> @where ttfp
10:50:06 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
10:50:29 <ski> sykora : `notf = not .:: f'
10:50:30 <rata_> ski: ok, thanks... I think I have a good reason =)
10:50:45 <mekeor> ski: and this: http://www.cse.chalmers.se/research/group/logic/book/
10:50:46 <ski> rata_ : if you want, you could paste your code ;)
10:50:55 <eacameron> timthelion: I'm surprised that compiles, try `main = do putStrLn "Hello World"`
10:51:03 <sykora> ski: and where is (.::) from?
10:51:11 <ski> mekeor : oh, right
10:51:30 <weexplat> gwern: Sᴍᴀʟʟ ᴄᴀᴘꜱ ʟᴏᴄᴋ ɪꜱ ᴄʀᴜɪꜱᴇ ᴄᴏɴᴛʀᴏʟ ꜰᴏʀ ᴅɪɢɴɪꜰɪᴇᴅ.
10:51:34 <ski> sykora : old invention of mine : `infixr 9 .::; (.::) = (.) . (.) . (.)'
10:51:40 <gwern> weexplat: or if you're Death
10:51:43 <ski> goes with `infixr 9 .:; (.:) = (.) . (.)'
10:51:51 <ski> @type (.:)
10:51:52 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
10:52:02 <timthelion> eacameron: Same error.
10:52:08 <copumpkin> I want small caps lock
10:52:17 <weexplat> gwern: i was going to say 'or?' but then i thought about a few things ...
10:52:20 <ski> @type let (.) = (Prelude..); infixr 9 .:; (.:) = (.) . (.) in (.:)
10:52:20 <mekeor> weexplat: O_O
10:52:21 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:52:30 <ski> @type let (.) = (Prelude..); infixr 9 .::; (.::) = (.) . (.) . (.) in (.::)
10:52:31 <lambdabot> forall b c a a1 a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
10:52:33 <rata_> ski: thanks, don't worry, I prefer to bother you with more important things
10:52:49 <ski> rata_ : hehe, your choice :)
10:53:59 <eacameron> timthelion: Hmmm that works for me. what's your compile command look like?
10:54:18 * gwern ponders where on his website he could employ small caps
10:54:34 <copumpkin> titles!
10:54:37 <copumpkin> headings!
10:55:01 <timthelion> eacameron: ghc lit.lhs but what's that got to do with it?
10:55:04 <ski> mekeor : i haven't looked at TTFP (though i'm dimly aware of it). but i think of TaPL as not being about quite the same thing as that Martin-Löf Type Theory one
10:56:10 <geekosaur> wow.  OS X can be really strange about errors sometimes.
10:56:21 <eacameron> timthelion: Do you start the line with ">"? LHS files need > to begin each line. If you don't want it that way, use .hs extension
10:57:02 <timthelion> eacameron: I thought that I had read on the wiki, that it can be either > or \begin{code} \end{code}
10:57:03 <geekosaur> mistyped "gcc --make foo.hs" to test something.  the error?  "file was built for unsuppprted architecture which is not the one being linked for" / "symbols not found: _main"
10:57:43 <geekosaur> that's an ... interesting chain of strange default actions
10:57:44 <koeien> geekosaur: was there an .o file present already? :)
10:57:53 <khs> Hi, I have a function " findFile :: [FilePath] -> FilePath -> IO FilePath  " How can I map this over a list of FilePaths? like " map (findFile paths) filepaths " ?
10:58:05 <koeien> khs: mapM
10:58:07 <zachk> khs: mapM
10:58:11 <koeien> :t mapM
10:58:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:58:42 <geekosaur> koeien, no, it passed the .hs file to the linker, apparently on the assumption it was a linker script
10:58:43 <eacameron> timthelion: No...that's just for LaTeX
10:58:51 <koeien> geekosaur: heh
10:58:52 <geekosaur> (I believe that's known gcc behavior)
10:59:03 <MOMOMOMA> ciao
10:59:19 <MOMOMOMA> !list
10:59:24 <ski> @type let findFile :: [FilePath] -> FilePath -> IO FilePath; findFile = undefined; (paths,filepaths) = undefined  in  mapM (findFile paths) filepaths
10:59:25 <lambdabot> IO [FilePath]
10:59:25 <eacameron> timthelion: That's a suggestion for embedding Haskell code in LaTeX documents. You can't do that in lhs files.
10:59:29 <timthelion> eacameron: ah,I see
10:59:43 <ski> @type let findFile :: [FilePath] -> FilePath -> IO FilePath; findFile = undefined  in  \paths filepaths -> mapM (findFile paths) filepaths
10:59:44 <lambdabot> [FilePath] -> [FilePath] -> IO [FilePath]
10:59:44 <singpolyma> I have a lazy function constructing a list.  An exception can thrown in constructing some elements of the list.  How can I force the entire list at a given point so that I can catch the exception early?
11:00:00 <koeien> singpolyma: rnf
11:00:02 <timthelion> eacameron: thanks, perhaps I'll change the wiki page to make that more clear
11:00:35 * hackagebot bitvec 0.1 - Unboxed vectors of bits / dense IntSets  http://hackage.haskell.org/package/bitvec-0.1 (JamesCook)
11:00:39 <ski> eacameron : are you sure ?
11:00:53 <dcoutts_> timthelion: I've taken a look at your example, it's rather odd. haddock doesn't seem to like Main modules without a module declaration
11:01:13 <eacameron> ski: That's what the page says anyway. Am I missing something?
11:01:17 <singpolyma> koeien: that looks like what I want.  I was trying to do something with map and seq, but it wasn't working
11:01:37 <ski> eacameron : i don't know. i just had a vague impression you *could* write something like that as well
11:01:37 <timthelion> dcoutts_: I just threw together the simplest bit of code I could think of :)
11:01:58 <dcoutts_> timthelion: you can simplify it to...
11:02:04 * dcoutts_ annotates the paste
11:02:09 <koeien> singpolyma: or,
11:02:29 <koeien> force [] = []; force (x:xs) = seq x (force xs)
11:02:40 <hpaste> dcoutts annotated “Cabal error” with “Cabal error (annotation)” at http://hpaste.org/65753#a65754
11:02:46 <koeien> this evaluates each element to WNHF
11:03:40 <dcoutts_> timthelion: so it looks to me like a haddock problem, not a problem with the way cabal does the .lhs -> .hs conversion
11:03:56 <singpolyma> koeien: right, looking at the rnf source, that's what it's defined as
11:04:05 <dcoutts_> timthelion: adding "module Main where" makes it work
11:04:17 <dcoutts_> timthelion: I suggest you file a haddock bug
11:04:32 <koeien> singpolyma: not completely. rnf uses rnf x (force xs) instead of seq
11:04:38 <ski> koeien : i would make `seq' an argument there ..
11:05:26 <timthelion> dcoutts_: OK, thanks.  I was using caball because cabal aparently works better with lhs http://osdir.com/ml/haskell-cafe@haskell.org/2010-01/msg00770.html
11:06:37 <timthelion> apparently the | can be placed in text sections using cabal, but not directly using haddock
11:07:42 <dcoutts_> timthelion: right, cabal uses a different unlit that means if you want to use .lhs then using haddock markup isn't quite so annoying
11:08:13 <dcoutts_> timthelion: I'm not sure I'd go as far as to say that using .lhs is actually easier than .hs though
11:09:00 <tgeeky_> experts: there's a good question waiting on reddit: http://www.reddit.com/r/haskell/comments/r8nyi/error_handling_and_parallel_free_monads/
11:09:10 <timthelion> dcoutts_: well I'm just playing around and trying to learn what I like for now.
11:10:12 <timthelion> dcoutts_: I don't think I can file a bug http://trac.haskell.org/haddock/haddock/register
11:10:31 <timthelion> ah, ok
11:10:41 <timthelion> the register link is dead, but there is another register link
11:10:55 <dcoutts_> timthelion: http://trac.haskell.org/haddock/register  I'll fix the wiki link, thanks
11:12:51 <Franciman_> ski, sorry I was afk had some problems
11:13:11 <Franciman_> btw, I still don't understand completely
11:15:02 <Franciman_> the rank2 types I mean
11:15:43 <ski> Franciman_ : well, say you have written `foo xss = reverse (map reverse xss)'
11:15:54 <m24de> http://3c921c66.hornywood.tv  HOT BRAZILIAN PORNSTAR GISELE GUCI  FUCKED HARD ENJOY
11:16:08 <ski> now, you want to generalize this by passing the `reverse' function as an argument to `foo'
11:16:30 <Franciman_> yes
11:16:35 <ski> so, you try `foo f xss = f (map f xss)'
11:16:40 <ski> however, this doesn't work
11:16:46 <m24de> http://3c921c66.hornywood.tv  HOT BRAZILIAN PORNSTAR GISELE GUCI  FUCKED HARD ENJOY
11:16:51 <ski> because for this to work, `f' needs to be polymorphic
11:17:08 <ski> because in one case, `f' is used on the element lists (having type `[a]', say)
11:17:23 <ski> and in the other case, `f' is used on the whole list of list, then having type `[[a]]'
11:17:27 <ski> if you write
11:17:32 <ski>   foo f xss = f (map f xss)
11:17:59 <ski> Haskell will attempt to infer a type like `[a] -> [a]' or `[[a]] -> [[a]]' for `f'
11:18:08 <Franciman_> yep
11:18:09 <ski> but it doesn't work, since it can't have both types at the same time
11:18:34 <ski> however, one *can* do this, by supplying a rank-2 signature for `foo' :
11:18:50 <ski>   foo :: (forall b. [b] -> [b]) -> [[a]] -> [[a]]
11:18:52 <ski>   foo f xss = f (map f xss)
11:18:54 <ski> this works
11:19:11 <ski> but rank-2 types can't be inferred, you have to know already which signature should be there
11:19:18 <quintessence> :t let foo f xss = f (map f xss) in foo
11:19:19 <lambdabot> forall b. ([b] -> b) -> [[b]] -> b
11:19:37 <Franciman_> ski but are they part of the haskell standard?
11:19:38 <ski> with this signature, `f' doesn't have type `[b] -> [b]', it has type `forall b. [b] -> [b]'
11:19:53 <ski> meaning that `f' is *polymorphic* inside the both of `foo' -- which is why this works
11:20:04 <ski> Franciman_ : no, they are a language extension
11:20:08 <ski> btw, note that
11:20:10 <Franciman_> also forall?
11:20:11 <ski>   foo :: (forall b. [b] -> [b]) -> [[a]] -> [[a]]
11:20:13 <ski> really means
11:20:18 <ski>   foo :: forall a. (forall b. [b] -> [b]) -> [[a]] -> [[a]]
11:20:20 <ski> just like
11:20:29 <ski>   map :: (a -> b) -> ([a] -> [b])
11:20:32 <ski> really means
11:20:37 <ski>   map :: forall a b. (a -> b) -> ([a] -> [b])
11:21:07 <Franciman_> oh so it's like saying
11:21:08 <ski> if you're not using higher-rank types, then you never have to write an explicit `forall' in type signatures
11:21:09 <Franciman_> * -> *
11:21:09 <Franciman_> ?
11:21:31 <ski> no, this isn't really related to function kinds
11:21:52 <ski> Franciman_ : and yes, the keyword `forall' is also a language extension
11:22:19 <ski> Franciman_ : another use of this is if you want to put a polymorphic operation inside a data-structure
11:22:35 <ski> e.g. you could write
11:22:51 <ski>   data Mapper f = M (forall a b. (a -> b) -> f a -> f b)
11:23:28 <ski> a value of type `Mapper f' (for some type function `f') contains a *polymorphic* value (function) of type `forall a b. (a -> b) -> f a -> f b'
11:24:46 <Franciman_> and if I hadn't used forall what would have happened?
11:24:59 <Franciman_> ( just little recap to see if I have understood)
11:32:53 <ski> Franciman_ : sorry, back now
11:33:11 <Franciman_> np
11:33:23 <ski> Franciman_ : if you hadn't used `forall' where ? in the `foo' example or in the `Mapper' one ?
11:33:34 <Franciman_> mapper
11:33:51 <ski> well, you'd got a "type variable not in scope" error
11:34:32 <ski>   data Mapper f = M ((a -> b) -> f a -> f b)  -- i.e. this would give that error
11:34:43 <Franciman_> oh ok
11:34:52 <ski> there are at least two other ways to remove that error from this code
11:34:57 <Franciman_> I should have defined them near Mapper f , like Mapper f a b
11:34:58 <Franciman_> right?
11:35:07 <ski> but they give a very different type `Mapper'
11:35:21 <Franciman_> of course
11:35:24 <ski>   data Mapper f a b = M ((a -> b) -> f a -> f b)  -- yes, this is one of the two ways
11:35:39 <ski>   data Mapper f = forall a b. M ((a -> b) -> f a -> f b)  -- is the other one
11:36:09 <ski> of course, you could also mix the ways, like in
11:36:18 <ski>   data Mapper f a = forall b. M ((a -> b) -> f a -> f b)
11:36:19 <ski> or
11:36:28 <ski>   data Mapper f = forall a. M (forall b. (a -> b) -> f a -> f b)
11:36:30 <ski> &c.
11:36:40 <Franciman_> yes
11:36:56 <ski> do you understand the difference between the different placements of `forall' here ?
11:37:21 <Franciman_> yep
11:37:27 <Franciman_> and why don't they add it to haskell?
11:37:49 <ski> maybe they will
11:38:08 <Franciman_> hope so
11:38:09 <ski> currently it's a language extension, supported by at least GHC and Hugs
11:38:39 <elemir> EHC support forall too
11:39:15 <elemir> And it's support `exists'!
11:39:44 <ski> elemir : which cases of ? `ExplicitForall' ? `PolymorphicComponents' ? `ExistentialQuantification' ? `Rank2Types' ? `RankNTypes' ? `ImpredicativeTypes' ?
11:40:01 <ski> elemir : in contravariant position only ? or also in covariant position ?
11:44:27 <ski> Franciman_ : .. and you understand `ExistentialQuantification' ?
11:45:21 <elemir> In both, for `ExistentialQuantification' it uses `exists' keyword, so in case of `RankNTypes' and `PolymorphicComponents'
11:46:07 * elemir can't understand why ghc uses `forall' keyword of existentials. It's crazy
11:46:31 <elemir> http://www.cs.uu.nl/wiki/bin/view/Ehc/UhcUserDocumentation
11:49:57 <ski> elemir : hm, you mean it uses `data SomeShowable = exists a. Show a => SS a' ?
11:50:10 * ski thinks using `forall' here is much more sensible
11:51:00 <ski> given `data Foo = MkF A B', we know `MkF :: A -> B -> Foo'
11:51:23 <ski> given `data Foo = forall a. MkF A (F a)', we know `MkF :: forall a. A -> F a -> Foo'
11:51:37 <ski> which is basically the same as `MkF :: A -> (exists a. F a) -> Foo'
11:51:48 <Franciman_> ski no
11:52:10 <ski> ?
11:52:12 <Franciman_> what is it?
11:52:17 <ski> ah, right
11:52:22 <Franciman_> ( ExistentialQuantification )
11:52:34 <ski> it's a way to hide types
11:53:15 <ski> consider the case that you're writing a stream processor
11:53:39 <ski> this is something that has a current "state", and can accept an input, producing an output, and a new current state
11:53:58 <ski> so when you pass it the next input, it can then depend on the next state
11:54:27 <ski> e.g. if you pass it a sequence of numbers, one by one, it could e.g. keep an internal sum, and at each step output the total sum so far
11:54:27 <Franciman_> yes
11:54:37 <ski> one way to write a type for this is :
11:55:07 <ski>   data SP a b = forall x. SP x (a -> x -> (b,x))
11:55:14 <ski> this means that
11:55:36 <ski>   SP :: x -> (a -> x -> (b,x)) -> SP a b
11:55:55 <ski> (or, if you prefer being explicit,
11:56:00 <ski>   SP :: forall a b x. x -> (a -> x -> (b,x)) -> SP a b
11:56:00 <ski> )
11:56:13 <ski> so, the type of the state is *hidden* in the type `SP a b'
11:56:29 <ski> this means that if someone hands you a value of type `SP a b'
11:56:29 <Franciman_> yes
11:56:44 <ski> which consists of a value of type `x', and a function of type `a -> x -> (b,x)'
11:56:55 <ski> then you have *no* idea in general what the type `x' is
11:57:17 <Franciman_> got that :)
11:57:21 <ski> this is why it's called *existential* quantification, because the only thing you know is that there *exists* some type `x' here
11:57:36 <Franciman_> but you do not know anything bout it
11:57:48 <ski> so, really the only thing you can do with that value of type `x' is to pass it to the function (together with an `a'), getting a `b' and a new `x' back
11:58:10 <ski> and the only useful thing you can do with the new `x' is to put it back into a `SP a b' container
11:58:26 <ski> Franciman_ : the only thing you know about it is that it's the same type `x' in the value and in the function
11:58:31 <ski> so, you can write
11:58:37 <Franciman_> oh yes
11:58:45 <ski>   stepSP :: SP a b -> a -> (b,SP a b)
11:59:14 <ski>   stepSP (SP old_x f) a = (b,SP new_x f)
11:59:16 <ski>     where
11:59:27 <ski>     (b,new_x) = f a old_x
12:00:03 <ski> another point : note that you can place many `SP a b's in a e.g. a list, even though they probably contain different `x' types inside them
12:00:36 <colah> If people have a moment, I'd be very interested in thoughts on this: https://github.com/colah/Control.Monad.State.Sugar
12:00:53 <ski> Franciman_ : another (a bit silly) example of this :
12:00:54 <colah> It's something I've spent a few hours hacking together in the last few days.
12:00:56 <colah> Very early.
12:01:05 <colah> But maybe kind of fun :)
12:01:27 <ski>   data Showable = forall a. MkS a (a -> String)
12:01:36 <ski> using this, we can write
12:01:43 <ski>   test :: [Showable]
12:02:03 <ski>   test = [MkS 42 show,MkS "abc" show,MkS "abc" id]
12:02:16 <ski> Franciman_ : do you understand this ?
12:02:19 <Franciman_> oh yes
12:02:38 <ski> and the only thing you really can do with a `Showable' is to pass the `a' to the `a -> String' function
12:02:51 <ski> another way of writing this is
12:02:58 <Franciman_> ski, so this can also be used to produce a list of heterogeneous data?
12:03:01 <exFalso1> is there a way to safely get the Name of a data constructor in TH ('Constr doesnt work)?
12:03:03 <ski>   data Showable = forall a. Show a => MkS a
12:03:05 <ski>   test :: [Showable]
12:03:11 <Franciman_> colah, I'm not a pro or something like that, but hey that sounds nice
12:03:12 <ski>   test = [MkS 42,MkS "abc"]
12:03:14 <ski> Franciman_ : yes
12:03:27 <colah> Franciman: Thanks!
12:03:51 <Franciman_> ski, and I bet Dynamic is defined in terms of forall
12:03:58 <ski> yeah
12:04:00 <Franciman_> no it's a lost bet
12:04:05 <Franciman_> ah lol
12:04:11 <ski>   data Dyanmic = forall a. Typable a => Dynamic a  -- iirc
12:04:14 <Franciman_> yeah then I got it right
12:04:27 <Franciman_> ski, thanks SO much
12:04:29 <ski> Franciman_ : anyway, let's go back to
12:04:36 <Franciman_> yes
12:04:37 <ski>   data Showable = forall a. MkS (a,a -> String)
12:04:54 <ski> the reason for using `forall' here is that the constructor `MkS' is polymorphic
12:04:59 <ski> it's type signature is
12:05:12 <ski>   MkS :: forall a. (a,a -> String) -> Showable
12:05:16 <byorgey> colah: looks cool
12:05:16 <Franciman_> yep
12:05:19 <ski> (which could be written as
12:05:24 <ski>   MkS :: (a,a -> String) -> Showable
12:05:39 <ski>  by implicit `forall' quantification on the "toplevel" of the type)
12:05:43 <ski> however
12:05:45 <ski>   MkS :: forall a. (a,a -> String) -> Showable
12:05:49 <ski> is basically the same as
12:05:55 <ski>   MkS :: (exists a. (a,a -> String)) -> Showable
12:06:27 <ski> so, given a pair of two values of type `a' and type `a -> String', for *some* `a', `MkS' produces a `Showable'
12:06:46 <ski> this is why (imo) it's right to use `forall' in the syntax here, and not `exists'
12:06:55 <Franciman_> exists? it is like that reverse E in math notation?
12:06:59 <ski> yes
12:07:12 <ski> just like `forall' is like the upside-down `A' in math/logic notation
12:07:15 <Franciman_> oh great
12:07:18 <Franciman_> yes yes
12:07:29 <ski> however, few haskell implementations support the keyword `exists'
12:07:35 <Franciman_> ghc?
12:07:35 <ski> morally, we want
12:07:39 <ski>   MkS :: (exists a. (a,a -> String)) -> Showable
12:07:44 <ski> but since this is logically equivalent to
12:07:48 <ski>   MkS :: forall a. (a,a -> String) -> Showable
12:08:00 <ski> we can in this case reuse the `forall' keyword to get what we want
12:08:04 <ski> contrast
12:08:14 <ski>   data Showable = forall a. MkS (a,a -> String)
12:08:15 <ski> with
12:08:36 <ski>   data SomethingElse = MkSE (forall a. (a,a -> String))
12:08:43 <ski> this one is *very* different
12:08:49 <ski> the type signature of the constructor here is
12:09:06 <ski>   MkSE :: (forall a. (a,a -> String)) -> SomethingElse
12:09:19 <ski> meaning that in this case, the constructor takes a *polymorphic* argument
12:09:31 <ski> in the `Showable' case, the constructor itself was polymorphic
12:09:36 <ski> those cases are very different
12:09:47 <ski> Franciman_ : no, GHC doesn't support the `exists' keyword
12:09:57 <ski> Franciman_ : we can still use it when *talking* about code, though :)
12:10:42 <Franciman_> ok
12:10:56 <ski> often we talk about things like
12:11:09 <ski>   frob :: Foo -> exists a. Bar a
12:11:16 <colah> byorgey: Yay!
12:11:29 <ski> however, since we can't write exactly this in GHC at least, we have to encode this using a data type
12:11:32 <ski> like
12:11:46 <ski>   data SomeBar = forall a. WrapBar (Bar a)
12:11:52 <ski>   frob :: Foo -> SomeBar
12:12:16 <ski> Franciman_ : however, i think it helps with the conceptual thinking to talk about `exists' like this
12:12:46 <colah> Anyone know why GHC doesn't support existential types? My understanding is that they are computationaly equivelant to the others, and they'd be really nice to have...
12:12:54 <Franciman_> of course, it makes thinking tidier
12:13:20 <ski> Franciman_ : maybe in a future version of GHC, we can actually write `exists' ..
12:13:41 <colah> ski: +1
12:14:37 <dolio> @quote first-class.existentials
12:14:38 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
12:15:17 <ski> Franciman_ : now a word of caution. some people when learning about existentials try to use it too much, in cases where it's not required/sensible (presumably due to using "heterogenous collections" in OO)
12:15:40 <ski> Franciman_ : read <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass> to learn about why you shouldn't use them without cause
12:15:43 * hackagebot hierarchical-clustering-diagrams 0.3 - Draw diagrams of dendrograms made by hierarchical-clustering.  http://hackage.haskell.org/package/hierarchical-clustering-diagrams-0.3 (FelipeLessa)
12:16:00 <Franciman_> not my case lol, I've never had the pleasure to use heterogenous collections in C++ :'(
12:16:08 <Franciman_> oh ok thanks
12:19:28 <timthelion> is there any way to test if a record selector has a match without getting an error?
12:19:55 <sclv> use a case statement instead...
12:20:26 <timthelion> how would that work?
12:20:42 <timthelion> it seems to me that they are unrelated...
12:20:46 <eacameron> can someone enlighten me on the difference between these two cabal packages? parsec-tagsoup and tagsoup-parsec  ??
12:25:10 <timthelion> sclv: really, how would that work?  I have like data DAT = A {x :: Int , y :: Int} | B { x :: Int, y::Int,z::SomethingElse}| Z {woopsnox :: String}  I was hoping that selectors would save me code, since before I was doing http://hpaste.org/65750
12:27:20 <sclv> getX :: DAT -> Maybe Int; getX (A x _) = Just x; getX (B...); getX _ = Nothing
12:27:46 <ski> timthelion : i would probably try to factor
12:27:53 <singpolyma> Is there a good library for fuzzy date parsing?  (like strtotime in PHP, give it a string and it figures out what format the date is in and parses it)
12:28:45 <timthelion> sclv: that's no better than my previous solution
12:29:06 <worldsayshi> Q: Is there a way to scope a number on the type level to be 0< and <1?
12:29:14 * timthelion googles factoring at ski's sugestion
12:30:37 <worldsayshi> *set a range on the type level
12:32:55 <sclv> timthelion: he just means break up your data type into smaller bits of data. so you have a data Coords = Coords x y and etc...
12:33:08 <sclv> then you glue those smaller data bits together into your full type.
12:33:33 <sclv> which is very very loosely analogous to e.g. factoring a number.
12:33:43 <ski> timthelion : is this meant to be the AST for a small language ?
12:33:56 <timthelion> sclv: yes, this is a very small language
12:34:08 <sclv> or finding common factors for a set of numbers, even moreso.
12:34:14 <ski>   data AB_or_AC = AB A B | AC A C
12:34:22 <ski> vs.
12:34:38 <ski>   data A_and_BC = ABC A B_or_C
12:34:46 <ski>   data B_or_C = B B | C C
12:35:10 <sclv> ski: excellent example!
12:35:10 <ski> `(a * b) + (a * c)  =  a * (b + c)'
12:35:29 <ski> timthelion : what is `End' ?
12:36:05 <timthelion> ski: End is the last command in the program or branch of the program(since it's multithreaded).
12:36:26 <ski> so it's effectively `Halt' ?
12:37:20 * ski doesn't understand `EndIf' here ..
12:37:26 <timthelion> ski: yes.  What I'm doing, is I'm laying out haskell functions on a flowchart grid(thus the points) and then literally precompiling to workable haskell code.
12:37:45 <timthelion> it is stack based, and EndIf clears the stack.
12:37:57 <ski> yeah, but how would it be used
12:38:08 <ski> it appears your `Cell' type is direclty recursive
12:38:21 <ski> so would both `Then' and `Else' contain an `EndIf', in the `If' case ?
12:38:38 <timthelion> ski if I recall correctly I wrote EndIf wrong in that, so it shouldn't make sense, it should contain a Point and a Cell, does it not?
12:38:58 <ski> i'm not talking about what an `EndIf' node contains
12:38:59 <timthelion> ski: yes, they would both contain EndIf if they wanted to join back together
12:39:10 <ski> i'm talking about how it would be contained in other nodes
12:39:19 <ski> that sounds very strange
12:39:48 <timthelion> we'll see if the language is useable.  I kind of have to make it first, and then I'll play arround with it.
12:40:35 <ski> anyway, i'm not sure what the point of `End' not having a point is ?
12:41:13 <timthelion> it has no looping functionality.  Rather, it takes a trick from befunge, and makes If capable of pointing back to an earlier place in the program for looping.
12:41:38 * ski doesn't know befunge
12:42:04 <timthelion> End could have a point.  But there are other cases where I'd like to get a record that is not universal, for example Actions and Starts have code but If's don't
12:42:10 <timthelion> ski: look it up, it will blow your mind.
12:42:42 <ski> (you have type error in `cellPaths')
12:43:12 <timthelion> ski: that is possible.
12:43:37 <weexplat> timthelion: no, the previous version of bf would blow your mind, this one will bend your mind
12:43:57 <timthelion> right now I'm rewriting my code with registers.
12:44:24 <timthelion> weexplat: hehe.  I'm taking haskell and befunge, and trying to make a very practical programing language.  That will blow everyones minds :D
12:44:40 <ski> i would probably `cellNext :: Cell -> [Cell]'
12:45:23 <ski> what is the use of `stripCellNext' ?
12:45:57 <timthelion> ski: at some point, I convert the Cell tree into a list in order to draw it on the screen
12:46:13 <timthelion> ski: I didn't want to recursivly copy the whole tree and waste memory
12:46:35 <timthelion> so I strip the tail of the tree before putting it into the list to be displayed
12:47:01 <fmapE> @help
12:47:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:47:03 <timthelion> ski: you're right about cellNext though, a list would be better.
12:47:06 <ski> timthelion : i might have tried using IndirectComposite there
12:47:11 <fmapE> @help tell
12:47:11 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
12:47:29 <ski> (btw, i'm not sure why you would need to recursively copy the tree otherwise ..)
12:47:47 <ski> @where IndirectComposite
12:47:48 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
12:50:46 <ski> timthelion : "for example Actions and Starts have code but If's don't" -- this is re `cellText' and the `String' fields ?
12:50:58 <timthelion> ski: well I wouldn't explicitly.  But if I have [Cell] then that will take up a lot more room in memory than the stripped version.
12:51:10 <ski> timthelion : why ?
12:51:47 <timthelion> ski: why store the fact that the action is an If statement in a String?
12:52:13 <ski> i mean : "But if I have [Cell] then that will take up a lot more room in memory than the stripped version." -- why is that ?
12:52:13 <timthelion> ski: the user won't edit that text. This is a visual programming language...
12:53:18 <ski> just copying references to the sub-ASTs in the implementation isn't expensive
12:53:47 <ski> calling `stripCellNext' however will actually copy the nodes, so will probably use more memory
12:54:18 <timthelion> ski: really?  I was pretty sure it would be.
12:54:47 <timthelion> I was under the thinking, that I was building a whole new data construct, and I shouldn't place more than need be into that construct.
12:54:55 <timthelion> still getting used to laziness.
12:55:18 <ski> (btw, the brackets in the definienses for `stripCellNext' are redundant)
12:55:46 * hackagebot portaudio 0.2.0 - Haskell bindings for the PortAudio library.  http://hackage.haskell.org/package/portaudio-0.2.0 (AnilVaitla)
12:56:14 <ski> timthelion : if you have a whole tree, and you collect all the sub-trees of that tree into a list, then the only more memory that is needed should be the memory for the list structure
12:56:17 <timthelion> ski: Yes they are, but they make me feel good.  I got my baby teeth out on elisp
12:56:28 <ski> the sub-trees in the list would be shared with the actual tree, not copied in memory
12:56:46 <timthelion> OK, that's neat.  Haskell is smarter than it looks.
12:56:55 <sp3ctum> hehe
12:56:57 <ski> the same would be true in Emacs Lisp
12:57:06 <CQ> how would I best handle a file that I need to parse, where some lines are one line, and others are continued (with \) across sseveral lines?
12:57:15 <jfischoff> Is there a type class for endofunctors anywhere? Also if I endofunctor and its identity morphism, is there a name for that?
12:58:07 <ski> jfischoff : an endofunctor is just a functor with the same domain and codomain. `Functor' is a class of endofuncor on `*'
12:58:07 <sp3ctum> CQ, maybe write a parser that recognizes \ characters as part of a Line data type or similar
12:58:26 <ski> s/endofuncor/endofunctors/
12:59:05 <ski> CQ : you could make a pre-processing pass, which joins lines ending with a backslash
12:59:27 <jfischoff> ski: Yep. I am want class (Category cat) => BinaryEndofunctor cat op where
12:59:27 <jfischoff>     construct :: iso a b -> iso c d -> iso (op a c) (op b d)
13:00:01 <jfischoff> But I was want to assoicate the endofunctor with an identity element (morphism)
13:00:25 <ski> > let frob ('\\':'\n':s) = frob s; frob (c:s) = c : frob s  in frob "abc\ndef\\\nghi\n"
13:00:26 <lambdabot>   "abc\ndefghi\n*Exception: <interactive>:3:4-55: Non-exhaustive patterns in ...
13:00:38 <ski> er, right :)
13:00:46 <ski> > let frob "" = ""; frob ('\\':'\n':s) = frob s; frob (c:s) = c : frob s  in frob "abc\ndef\\\nghi\n"
13:00:47 <lambdabot>   "abc\ndefghi\n"
13:00:47 <yasar> What does it mean -> "It is available in Hackage."
13:00:50 <ski> CQ : like that ^ ?
13:00:59 <timthelion> ski: I found a nice way to do record selection with gaurds and otherwise, with a gaurd for each type that has the value, and otherwise handling the rest.
13:01:14 <timthelion> *I think*
13:01:14 <CQ> ski yes, now I jsut need to understand what you did :)
13:01:35 <ski> jfischoff : `iso' ?
13:01:53 <jfischoff> opps, I mean cat
13:02:37 <ski> jfischoff : "But I was want to assoicate the endofunctor with an identity element (morphism)" -- huh ? why ?
13:03:21 <ski> (timthelion : s/gaurd/guard/)
13:03:33 <ski> timthelion : how would that look like ?
13:04:18 <jfischoff> ski: to talk about the idea of an operation with an inverse
13:04:28 <alpounet> yasar, haven't you heard of http://hackage.haskell.org/ ?
13:04:48 <jfischoff> jfischoff: in a general setting. That will transfer from categories to groupoids
13:04:49 <ski> jfischoff : what has that got to do with binary endofunctors ?
13:04:51 <yasar> alpounet: No. I am quite new in haskell.
13:05:03 <alpounet> yasar, that's a public package database
13:05:26 <alpounet> that is, among other things, used by the "cabal-install" tool to install packages on your computer
13:05:30 <jfischoff> ski:make monoids and semirings with the operation
13:05:33 <nyingen> Question about the record syntax: why is it only a warning, and not an error (in GHC) to leave some fields uninitialized? It's very convenient, but I'm surprised it's allowed
13:05:46 <yasar> alpounet: Thanks. Look good.
13:06:03 <ski> jfischoff : i don't understand why you seem to want to add stuff for that in the `BinaryEndoFunctor' class, though ..
13:06:09 <hpc> nyingen: empty fields are undefined
13:06:12 <alpounet> yasar, you can find a *bunch* of documentation about this, enjoy
13:06:23 <hpc> > undefined
13:06:24 <lambdabot>   *Exception: Prelude.undefined
13:06:32 <nyingen> hpc: ah, I see
13:06:49 <jfischoff> ski: I don't. I want to know what I should call a class that is a binary endofunctor with an identity element
13:07:20 <timthelion> ski: could I not do f c \n | A = selector c | B = selector c | otherwise = NoSelectorC
13:07:27 <jfischoff> ski: err actually wait
13:07:58 <jfischoff> ski: Yeah i think that is what I want
13:08:26 <ski> jfischoff : i don't understand what you mean by "a binary endofunctor with an identity element"
13:09:21 <ski> jfischoff : my first reaction is that by "identity element" here you mean a *type* which is an identity element to the type (/object) `op' there -- but from what you're saying it appears that you want the "identity element" to be a *morphism*
13:09:49 <ski> timthelion : only if `A' and `B' are boolean expressions
13:10:17 <timthelion> ski: hrmph.  and is there a way to do this nicely with my current data type?
13:10:19 <jfischoff> ski: Yeah morphism. for example lets say I have cat a b -> cat c d -> cat (a, c) (b, d). Then then identity would be cat () ()
13:10:19 <ski> s;*type*;*type* (/ object);
13:10:31 <ski> s;type (/object);type;
13:10:56 <timthelion> this is perhaps the greatest challenge of Haskell, is if you don't get the data correct then you have to re-write your program.
13:11:11 <jfischoff> jfischoff: where () <-> 1 and (,) <-> *
13:11:24 <CQ> if I need to read a large file, will teh file be read all at once, or will it be read lazily, so just enough data to process is read?
13:11:25 <jfischoff> I keep putting my own name :(
13:11:25 <hpc> timthelion: not entirely though
13:11:31 <ski> timthelion : you could do `f c@(A ...) = selector c' -- or `f c@A{} = selector c'
13:11:45 <hpc> you can keep the interface to the data the same, sometimes
13:12:02 <jfischoff> ski: I think I need to find what algebraic struct has just and operation and identity
13:12:14 <hpc> and a lot of general functions will carry over just from parametricity
13:12:55 <ski> jfischoff : ok, so it appears that you *are* talking about an identity object, where your morphism `cat () ()' is just the identity morphism over that object
13:13:15 <ski> jfischoff : so, i'm not sure why you need to name that morphism at all
13:13:33 <jfischoff> ski: it comes into play later
13:14:09 <ski> anyway, functors must preserve identity morphisms
13:14:10 <jfischoff> ski: I guess it is like a subcategory?
13:14:39 <root_____> @pl \x y -> x y
13:14:39 <lambdabot> id
13:15:07 <ski> in the case of the functor from the terminal category that points out your `1' object, this means that the mapping for this must be the identity morphism on object `1'
13:15:13 <root_____> @pl \x -> (f x) . g
13:15:13 <lambdabot> (. g) . f
13:15:34 <ski> (it's slightly inconvenient here that we're talking about "identity" in two different senses/instances)
13:15:38 <keep_learning> Does any one here use Haskell in high performance computing ?
13:15:53 <jfischoff> ski: true
13:16:23 <jfischoff> ski: and I am not the clearest on this stuff, so I am sure my explainations are confusing
13:16:33 <ski> jfischoff : let's say `mult : C * C >---> C' and `one : 1 >---> C'
13:17:14 <alpounet> keep_learning, i don't know about people in here, but i believe i saw a company using it for this purpose, probably in the Industrial Haskell User Group or smth
13:17:20 <pozic> keep_learning: some people wrote papers. In my experience lots of 'scientific' programs are inefficient.
13:17:28 <ski> your `construct :: BinaryEndoFunctor cat mult => cat a b -> cat c d -> cat (mult a c) (mult b d)' is the mapping for the `mult' functor here
13:17:39 <pozic> keep_learning: the kernels are generally really fast, though.
13:17:54 <jfischoff> ski: yep
13:18:06 <ski> and something of type `cat one one' would be the mapping for the `one' functor
13:18:19 <ski> but because of laws, this must always be the identity morphism on `one'
13:19:13 * ski wonders about "it comes into play later"
13:19:18 <keep_learning> pozic, dph looks promising but not sure if its really fast enough.
13:19:34 <jfischoff> jfischoff: I'll show you in a bit. Thanks for the help. Got to run
13:19:36 <keep_learning> pozic, Could you  give me the link of papers
13:19:41 <pozic> keep_learning: I think you have to think about fundamentals a bit more.
13:19:50 <pozic> keep_learning: Haskell is slow because it uses lists.
13:19:59 <pozic> keep_learning: DPH is fast because it uses arrays.
13:20:17 <pozic> keep_learning: or rather 'predictable access patterns'.
13:20:48 * hackagebot sparse-lin-alg 0.2 - Small library for effective linear algebra on sparse matrices  http://hackage.haskell.org/package/sparse-lin-alg-0.2 (AlexeyAlekhin)
13:20:49 <alpounet> keep_learning, you may want to follow what's done there: http://www.well-typed.com/blog/48
13:20:55 <pozic> keep_learning: so, even if the current Haskell compiler might not be 'great' (I don't know whether it isn't), you still have your programs.
13:21:10 <pozic> keep_learning: so, you could likely compile it to something else without losing anything.
13:21:23 <keep_learning>  alpounet Thank you
13:21:28 <pozic> keep_learning: (and that's a worst case scenario)
13:22:19 <ski> jfischoff : i'm not sure where subcategories comes into play, here ..
13:22:36 <keep_learning> pozic, I  used Haskell to solve programming problems and I think its competitive enough with C/C++
13:22:46 <jfischoff> ski: endofunctors make subcategories
13:23:23 <ski> via image, i suppose you mean ?
13:24:03 <ski> (if so, that isn't specific to *endo*functors)
13:24:09 <keep_learning> pozic, Thanks for  input
13:24:20 <jfischoff> ski: true
13:24:33 <pozic> keep_learning: I think it is much easier to program in Haskell, but I also think creating efficient programs with small constant factors in Haskell is an uphill battle.
13:24:47 <ski> jfischoff : "I want to know what I should call a class that is a binary endofunctor with an identity element" -- if the functor is supposed to also be associative, you can call it `MonoidalCategory' or `MonoidalStructure' or `MonoidalStructuredCategory'
13:24:58 <pozic> Where 'Haskell' means using 'idiomatic Haskell'.
13:25:21 <jfischoff> ski: Cool. That is useful information
13:25:34 <keep_learning> pozic, and this is where compiler comes into the picture. Am I correct ?
13:25:53 <keep_learning> generating efficient code
13:26:12 <ski> jfischoff : if the functor is also symmetric (upto iso, of course), then it's `SymmetricMonoidalCategory', iirc
13:28:00 <luite_> if I want to change something in every occurrence of some HsExpr constructors, deep inside a ParsedModule, is there an easy way to do this? the nodes have Data instances, but contain booby traps
13:28:19 <pozic> keep_learning: ideally the compiler knows about all kinds of details you as a scientist don't want to care about.
13:28:30 <pozic> keep_learning: practically, compilers are not perfect.
13:28:37 <byorgey> booby traps?
13:28:48 <pozic> keep_learning: but DPH should map fairly well to GPU computing.
13:28:53 <pozic> keep_learning: there are papers about that.
13:29:13 <byorgey> luite_: use something like uniplate?
13:29:37 <pozic> keep_learning: lots of algorithms are sequential and for those FORTRAN still seems to be best.
13:29:39 <ski> jfischoff : clarification, if you have a `forall a b. cat (mult a b) (mult b a)' that is *involutive*, then it's a symmetric monoidal structure
13:29:52 <pozic> keep_learning: (just look at the language shootout to see that)
13:30:01 <ski> jfischoff : if you just have an *iso* `forall a b. cat (mult a b) -> cat (mult b a)', then it's braided monoidal structure
13:30:42 <keep_learning> pozic, Language shoot out is great idea . Thanks
13:30:43 <pozic> keep_learning: fast programs are generally fast because they don't do a lot of work and when they do work it has some hardware architecture in mind.
13:31:06 <qued_____> Which package to import for isIn c "0123456789"
13:31:06 <qued_____> ?
13:31:10 <pozic> keep_learning: so, for example, sometimes you have to consider the exact size of your cache-lines, etc.
13:31:19 <pozic> keep_learning: except that concept doesn't even exist in Haskell.
13:31:22 <luite_> byorgey: hm I haven't used that before, only very basic low level Data things for serialization. do know some good example code?
13:31:35 <pozic> keep_learning: for that same reason Haskell code is fairly portable.
13:31:44 <ski> > '3' `elem` "0123456789"
13:31:45 <lambdabot>   True
13:31:51 <pozic> keep_learning: but Haskell code is also fairly unstable.
13:31:59 <ski> qued_____ : did you mean like that ^ ?
13:32:04 <pozic> keep_learning: (API breakage, etc.)
13:32:14 <byorgey> luite_: see http://community.haskell.org/~ndm/uniplate/  and  http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm
13:32:42 <keep_learning> pozic, yes because lots of people started using this and writing their own library. Price of popularity
13:33:25 <qued_____> yes ski, ty
13:36:40 <luite_> byorgey: hmm, those examples show only a single type, can it also work if you have dozens of different node types, and when some nodes are undefined or error?
13:37:16 <ski> luite_ : mutually recursive types ?
13:37:37 <luite_> uh not always, but some are
13:37:49 <ski> multiplate may be more appropriate
13:37:50 <luite_> it's just GHC's AST types
13:39:49 <luite_> suppose for example that I have a ParsedSource a want to renumber lines by walking the whole AST, and every Located a = L SrcSpan a, updating the SrcSpan for each
13:40:37 <gzmask> what am I gunna duiii? After learning just a little bit Haskell, I want to rewrite my Master project even though it's the end of the semester XD
13:42:17 <c_wraith> gzmask: turn in the project now, then learn more haskell. :)
13:43:35 <gzmask> c_wraith: yea, that's what I am trying to do now. I can not bare looking at my ugly, ugly code base with side-effects everywhere anymore
13:45:43 <worldsayshi> Question to anyone: Is there a way to limit a number to the interval [0,1] on the type level in haskell?
13:46:18 <c_wraith> worldsayshi: not without constructing a new data type that somehow represents only those values.
13:47:03 <c_wraith> worldsayshi: Though that could be done efficiently by treating Int as a rational value.
13:47:14 <snhmib_> does anyone know more articles like this: http://users.info.unicaen.fr/~karczma/arpap/Fdpe02/fumach.pdf ?
13:47:22 <c_wraith> err, positive only.  Ok, Word32
13:47:47 <snhmib_> i.e. articles about writing interpreters (in haskell)?
13:47:52 <snhmib_> nice ones :)
13:48:22 * ski has probably read some ..
13:48:42 <worldsayshi> c_wraith: So you mean that [0, integerBound] would map against [0,1]?
13:49:12 <c_wraith> worldsayshi: yeah...  It's not really exactly what you meant, but it's the closest you can manage cleanly and efficiently in haskell
13:50:39 <worldsayshi> <c_wraith>: Ok, seems like a reasonable solution
13:50:59 <Veinor> so what would having a stable ABI do?
13:51:15 <Veinor> would it mean i wouldn't have to recompile as much stuff
13:54:43 <c_wraith> Veinor: not really, for things built from source and updating rapidly.  What it would mean is library binaries could be distributed without source, and could be used across any version of ghc with the same ABI
13:57:04 <digitteknohippie> i'm trying to reinstall my haskell irc bot on my friend's debian/squeeze server, but haskell-network seems to have disapeared from the repo.  it's still what i need, or has it been swallowed up into some other package or something now?   haskell-network is still what i need, right?
13:57:20 <worldsayshi> c_wraith: That solution doesn't provide type safety though as (maxBound::Int)+1 evaluates to -2147483648 :)
13:57:38 <c_wraith> worldsayshi: that's why I said to go with Word32 instead of Int.
13:58:17 <Veinor> c_wraith: ah, so cabal install could just download binaries?
13:58:30 <christian___> Yet another cabal question: how can I use a path relative to the package's top level directory as a extra-lib-dir? Are there any variables?
13:58:30 <c_wraith> worldsayshi: which will then just wrap to zero if you try that
13:58:51 <c_wraith> Veinor: it could, yes.  Not sure how much impetus there would be to move to that, even if it were an option.
13:58:57 <worldsayshi> Ah, thanks!
14:00:50 * hackagebot flock 0.3.1.1 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.3.1.1 (ErikHesselink)
14:00:59 <Veinor> sure
14:05:51 <jfischoff> ski: I finally figured out what I was trying the express. The fixed point of an endofunctor. It just happens to be an identity element of a algebra where the operation is the endofunctor.
14:06:45 <yasar> How much time does it take to start doing daily programming in haskell when you first start?  I have finished realworldhaskell chapter 4 up until now.
14:07:33 <yasar> But ideas still didn't quite click.
14:07:46 <ski> jfischoff : fixed point of a *binary* endofunctor, how ?
14:07:51 <ski> given `mult : C * C >---> C', do you mean `mu r. mult (r,r)' ?
14:08:08 <squark42> hi guys: why is "\033OA" == "!OA" ?
14:08:25 <ski> > "\033OA" == "!OA"
14:08:25 <jfischoff> ski: I mean fixed point in the sense I get back what I put in
14:08:26 <lambdabot>   True
14:08:43 <c_wraith> > "\033" == "!"
14:08:46 <lambdabot>   True
14:08:54 <c_wraith> that should answer your question
14:09:13 <c_wraith> > chr $ 3 * 8 + 3
14:09:14 <squark42> hm, ok but I would like to save a terminal escape sequence in a string
14:09:14 <ski> > ord '!'
14:09:14 <lambdabot>   '\ESC'
14:09:16 <lambdabot>   33
14:09:38 <ski> squark42 : `33' is the character code (in decimal) for the `!' character
14:09:44 <c_wraith> squark42: haskell apparently doesn't do octal character codes
14:10:09 <c_wraith> > "\27"
14:10:10 <lambdabot>   "\ESC"
14:10:30 <ski> > chr 0o33
14:10:31 <squark42> ah, ok it's '\ESC', thanks
14:10:32 <lambdabot>   '\ESC'
14:11:11 <ski> > '\o33'
14:11:12 <lambdabot>   '\ESC'
14:11:20 <ski> squark42 ^
14:11:32 <digitteknohippie> is the network module part of haskell/ghc now?  how could i check to find out without upgrading to latest?  haskell-network is no longer in debian repos, which is causing me problems.
14:11:40 <nart> "A monad is just a monoid in the category of endofunctors, what's the problem?", i know what a category, monoid, functor is, but still i can't "visualize" that statment :S
14:11:50 <nart> any tips ?
14:12:33 <ski> nart : take a category `C', and an endofunctor `T : C >---> C'
14:12:54 <nart> wait, what's >---> ?
14:13:00 <ski> morphism arrow
14:13:19 <nart> ah ok,
14:13:52 <qubital> How do you derive a class on a preexisting type?
14:14:00 <ski> now, `T' is a monad if we have natural transformations `eta : 1 >---> T' and `mu : T . T >---> T', satisfying three extra laws
14:14:44 <hiptobecubic> is there a nice way to take the middle of three values in Ord?
14:15:02 <bitonic> hiptobecubic: (!! 1) . sort
14:15:06 <ski> qubital : using the `StandaloneDeriving' extension as documented at <http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving>
14:15:09 <byorgey> qubital: depends on the class
14:15:12 <hiptobecubic> (4, 2, 9) would return 4.  (3, 3, 7) would return 3, etc
14:15:22 <hiptobecubic> bitonic, ah yes of course, thanks
14:15:29 <qubital> byorgey: data
14:15:30 <glguy> \ a b c -> min a (max b c) ?
14:15:30 <byorgey> oh, wait, I see what you're asking
14:15:36 <byorgey> yeah, what ski said
14:15:43 <qubital> ski: thanks, i'll take a look
14:15:45 <glguy> err, that doesn't seem right :)
14:15:46 <bitonic> hiptobecubic: yeah if they're tuples what glguy said it's better
14:15:50 * hackagebot fclabels 1.1.1.1 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.1.1 (ErikHesselink)
14:15:50 <bitonic> ah no
14:15:53 <bitonic> damn.
14:16:01 <bitonic> seemed too simple
14:16:11 <nart> ski: that's it ?
14:16:19 <ski> nart : agree so far ?
14:16:32 <nart> ski: yep
14:17:23 <rasfar> luite_ are you still here? maybe i can help...
14:17:55 <ski> nart : ok, now you can make a category `Endo C', containing the endofunctors over `C' as objects, and having natural transformations between them as morphisms
14:18:20 <ski> nart : using this, `1',`T',`T . T' are now objects in this new category
14:18:47 <nart> ski: i know what a functor is, but what is that endo suffix ?
14:18:55 <koeien> endo just means T -> T
14:19:02 <rtharper> *why* does Haskell Platform for Mac OS X
14:19:04 <koeien> instead of T -> U, the more general case
14:19:08 <byorgey> a functor from some category to itself.
14:19:11 <nart> koeien: ah ok thanks
14:19:12 <rtharper> use /Developer/usr/bin/gcc
14:19:26 <ski> nart : and a monoid in that *monoidal* category `Endo C' is given by giving an object `T' in that category, together with two morphisms `eta : 1 >---> T' and `mu : T . T >---> T', satisfying the appropriate laws
14:19:30 <koeien> (holds for endomorphisms of graphs, monoids, rings, fields, and stuff as well)
14:20:00 <ski> nart : an endomorphism is a morphism with the same object as domain and codomain
14:20:19 <koeien> endo = "inside"
14:20:38 <ski> nart : endofunctor is just an instance of this, when the category has categories as objects, and functors as morphisms -- so an endofunctor is a functor with the same category as domain and codomain
14:20:59 <koeien> (contrast "exo")
14:21:35 * ski . o O ( inner vs. outer automorphism )
14:22:13 <byorgey> nart: note, that statement is referring to a somewhat more general notion of "monoid" than Haskell's Monoid type class, although it's the same general idea
14:22:24 <snhmib_> am i right in thinking that when i would use something like this http://codepad.org/LF09EpTC (i.e. lazily generate a graph/tree of all codepads) as input to an interpreter, basically what would get generated would be the list of executed nodes + thunks?
14:22:37 <snhmib_> pads=paths
14:22:40 <ski> nart : do you know the category terrorist version of the definition of a monoid ?
14:23:09 <nart> ski: no, i know the usual one, semigroup with neutral element
14:23:23 <ski> nart : yeah, so consider the category `Set'
14:23:44 <ski> to categorically specify a monoid here, we have to specify an object `M' (in `Set')
14:23:54 <ski> an operation `mult : M * M >---> M'
14:24:08 <ski> and an *operation* `one : 1 >---> M'
14:24:26 <ski> where `*' is cartesian product, and `1' is the (canonical) singleton set
14:24:54 <nart> ski: ok, i'm following
14:24:55 <ski> the laws being
14:25:16 <sohum> @pl \w -> foo w &&& bar
14:25:17 <lambdabot> (&&& bar) . foo
14:25:18 <ski>   mult . (one * id)  =  mult
14:25:25 <ski>   mult . (id * one)  =  mult
14:25:37 <Cale> haha, category terrorist
14:26:01 <nart> ski: ok
14:26:06 <ski>   mult . (mult * id)  =  mult . (id * mult) . assoc
14:26:10 <ski> where
14:26:24 <ski>   assoc : (A * B) * C >---> A * (B * C)
14:26:54 <ski> hm, actually for the first two laws we also need `A >---> 1 * A' and `A >---> A * 1'
14:27:06 <luite_> rasfar: yes I am
14:27:25 <ski> nart : this definition generalizes to any base category in place of `Set', as long as we have a *monoidal* structure on it
14:27:30 <rasfar> good timing, i just got back (again) ... you are looking into uniplate?
14:27:36 <ski> i.e. a bifunctor `*' with identity object `1'
14:28:12 <rasfar> i recently did some stuff with SYB and Haskell AST's ... if you already have Data instances that may be the way to go.
14:28:56 <ski> nart : now, the point is that in the category `Endo C', we actually have a monoidal structure
14:29:32 <luite_> rasfar: oh I was doing something else now, but it would be great if you had a nice example of using uniplate with these types
14:29:33 <ski> nart : namely composition of endofunctors over `C' is the "multiplication", and the identity endofunctor is the "one" object
14:29:36 <ski> so
14:29:41 <ski>   one : 1 >---> M
14:29:48 <ski>   mult : M * M >---> M
14:29:50 <ski> here becomes
14:29:59 <ski>   eta : id >---> T
14:30:05 <ski>   mu : T . T >---> T
14:30:13 <ski> or, written in terms of the components
14:30:20 <ski>   eta_A : A >---> T A
14:30:30 <ski>   mu_A : T (T A) >---> T A
14:30:34 <ski> @type return
14:30:35 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:30:36 <ski> @type join
14:30:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:30:42 <ski> nart : does this help ?
14:30:43 <rasfar> well, I didn't use uniplate because the Haskell data types already derive Data and Typeable, so SYB is a better choice there unless there's something you really can't manage with SYB.
14:31:32 <nart> ski: a lot, i have saved your explanation and i'll go through it again to try to fully grasp it
14:31:47 <nart> ski: thank you very much
14:32:04 <rasfar> if you can spare the time now to come back to your AST traversal problem, maybe I can help.  the only "sample code" I have offhand is "freesect", you can get it off hackage if you want to check that out.  Make sure to get the latest version, the code is easier on the eyes...
14:32:35 <luite_> rasfar: ah, does it travers a GHC AST?
14:32:42 <nart> i gotta go now, bye
14:32:53 <ski> nart : to be more complete, a monoidal structure on a category `C' consists of a binary endofunctor `(*) : C * C >---> C' and an object `I' of `C' such that `I * B = B',`A * I = A',`(A * B) * C = A * (B * C)', where those equalities are really isomorphisms
14:33:09 <luite_> rasfar: since GHC "boobytraps" the AST with exceptions, that might complicate things a little
14:33:10 <rasfar> or we can just discuss your problem live
14:33:54 <ski> nart : i.e. you should have an isomorphism `leftUnit_B : I * B >---> B', one `rightUnit_A : A * I >---> A' and one `assoc_{A,B,C} : (A * B) * C >---> A * (B * C)'
14:33:55 <rasfar> okay, i wasn't sure what you meant by "boobytrap".  i used haskell-src-exts so didn't have to deal with that.
14:34:18 <ski> nart : these isomorphisms themselves satisfying a few laws (look up "pentagonal identity/law")
14:34:21 <nart> ski: i'm sorry i have to go :S
14:34:22 <rasfar> still it might not matter, i don't see why a generic traversal should trip the traps?
14:34:28 <luite_> rasfar: some nodes have types, and they are undefined or an exception until the typechecker has run
14:34:28 <ski> nart : ok
14:34:34 <nart> ski: ty again
14:34:35 <rasfar> i see!
14:35:10 <luite_> rasfar: don't know if it would be a problem, just thought I'd mention it :)
14:36:00 <byorgey> I think you should be able to arrange things so that it does a top-down traversal and stops before recursing into booby-trapped parts, IF you can identify in advance where the booby traps might be
14:36:11 <byorgey> sounds kind of fiddly though.
14:36:43 <luite_> rasfar: anyway, in the most concrete terms, I have a function HsExpr -> HsExpr, and a ParsedModule (which contains a ParsedSource), I just want to run the function recursively on the whole ParsedSource
14:36:44 <rasfar> luite_: can you point me to a page explaining the GHC AST types?
14:37:35 <rasfar> byorgey, that sounds like the way to go.  there must be some way to identify those nodes without tripping them...
14:37:49 <luite_> rasfar: this is what I have, http://www.haskell.org/ghc/dist/stable/docs/html/libraries/ghc-7.4.0.20120131/GHC.html#t:ParsedModule
14:38:01 <rasfar> I'm looking at http://hackage.haskell.org/trac/ghc/wiki/GhcApiAstTraversals
14:38:11 <luite_> byorgey: it's always the same fields, so yes, just don't evaluate some of them :)
14:38:44 <byorgey> luite_: ok, good, that should work then =)
14:39:59 <luite_> rasfar: hmm, 4 years ago... :)
14:40:00 <rasfar> any constructors you don't give explicit cases for just have id applied
14:40:34 <rasfar> hey ghc and syb are 3x older at least!
14:41:13 <rasfar> you don't even need top-down probably, which will give you more alternatives as the SYB API is biased towards bottom-up traversals
14:42:04 <rasfar> you want to transform HsExp's and ignore the rest of the nodes, that'll be really easy...
14:42:54 <luite_> sounds good, when will you have it ready? ;p
14:43:17 <nart> Irc from android on 3g. Didn't expect it to work :)
14:43:44 <ksf> syb is real great if you don't care about performance :)
14:44:12 <luite_> I do care, but atm I'm just trying some things, might replace the code later
14:44:14 <qued_____> functions can be written as sets of tuples in haskell?
14:44:24 <qued_____> functions from A->B
14:44:38 <rasfar> everywhere (mkT $ \(x::Ctor a b) -> Ctor' d e f)
14:44:51 <rasfar> er ... not quite
14:44:59 <ksf> there's a problem with strings, for example. iirc syb isn't smart enough to see that strings can't contain ints, and thus traverses all your strings if you want to change a single int.
14:45:18 <rasfar> mkT (\x::HsExpr -> f(x))
14:45:30 <ksf> there's quite a zoo of generics libraries though, and also a comparison paper.
14:45:31 <rasfar> but you will need one case per HsExpr constructor
14:45:51 * hackagebot monad-control 0.3.1.1 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.3.1.1 (BasVanDijk)
14:45:53 <luite_> hehe that's the one type with a hundred constructors of course ;p
14:45:54 <rasfar> hope that helps!
14:46:31 <byorgey> no you don't
14:46:41 <byorgey> f CtorICareAbout = foo; f x = x
14:46:45 <rasfar> i know...  it's the same one i was dealing with.  start with one constructor, maybe App, and if it works for you...
14:47:04 <luite_> right
14:47:18 <rasfar> byorgey: i know that, but if you want to do something useful you need to give a specific case per constructor
14:47:42 <rasfar> "need" probably too strong, but that's how SYB is used in examples i've seen
14:48:09 <byorgey> qued_____: no, but if you have a set of tuples you can certainly turn it into a function which takes an input and tries to find the matching output
14:48:17 <rasfar> applying id is your only choice for the default
14:48:44 <ski> qued_____ : not in general
14:49:01 <qued_____> only if the set is a functional one, yes ..
14:49:23 <ski> qued_____ : if you have a `domain :: [a]', then given `f :: a -> b' (assuming `Eq a'), you can do `[(a,f a) | a <- domain] :: [(a,b)]'
14:49:55 <ski> qued_____ : no, only if the domain of the function has equality, and is available as a list/whatever
14:49:56 <byorgey> qued_____: which way do you want to go? from a set of tuples to a function, or from a function to a set of tuples?
14:50:11 <byorgey> ski: it depends which way qued_____ is trying to convert
14:51:12 <byorgey> ski: it seems we picked opposite interpretations =)
14:51:25 <qued_____> I'm interested in both ;)
14:51:29 <rasfar> ksf: yeah ... there are two good resources I've seen addressing this:
14:51:29 <ski> byorgey : yes. i interpreted "functions can be written as sets of tuples in haskell?" as meaning going from functions to graphs
14:51:42 <rasfar> http://www.haskell.org/haskellwiki/Scrap_your_boilerplate -- the "Listify whole lists" section
14:51:56 <qued_____> so e.g. set -> function can be converted in haskell if ... ?
14:51:57 <byorgey> ski: right, and I interpreted it as meaning the ability to use a set of tuples as a concrete syntax for a function =)
14:51:57 <ski> @type \domain f -> [(a,f a) | a <- domain]
14:51:59 <lambdabot> forall t t1. [t] -> (t -> t1) -> [(t, t1)]
14:52:21 <ski> @type \graph a -> fromJust (lookup a graph)
14:52:22 <lambdabot> forall a a1. (Eq a) => [(a, a1)] -> a -> a1
14:52:32 <ski> byorgey :)
14:52:36 <byorgey> ski: nice =)
14:52:37 <rasfar> ksf: and the FoldTree.hs example in the SYB tests (source package)
14:53:05 <ski> qued_____ : why are you asking about this ? what are you trying to do / figure out ?
14:54:41 <qued_____> ski: just wanna see an example how to convert a set (maybe a set that was generated out of an earlier existing function) to a function
14:54:44 <qued_____> why? for learning haskell
14:55:16 <ski> ok
14:55:56 <ski> it's just that sometimes when people ask specific questions like this, they're really after solving some specific problem, and sometimes that problem is better solved in another way
14:56:20 <ski> asking about it out of curiosity is fine, though :)
14:57:58 <qued_____> yes, got that idea after reading about tuples/ algebraic types
14:58:30 <weexplat> turning an alist to a function is just 'lookup'
14:58:43 <weexplat> (iiiiif you have no concern for speed)
14:59:40 <weexplat> if you want to do better than that you need to have more information about the domain type than just how to compare it for equality
15:00:01 <qued_____> ski: this would work, right?  f x = snd [y | (x,y) <- S]     (if for every x there is only one y with (x,y) in Set S)
15:00:08 <weexplat> like an ordering, a hash function, a Data instance ...
15:00:17 <qued_____> eh... should be head
15:00:20 <luite_> rasfar: ok looks like I have somethign that compiles now, thanks :)
15:00:43 <ski> qued_____ : no, you can't match on `x' like that (like you can in Erlang and Prolog)
15:01:03 <ski> qued_____ : also, the `snd' shouldn't be there
15:01:16 <ski> you can say
15:01:21 <rasfar> luite_ yw! feel free to get in touch if you want to talk about it, rasfar at gmai... (you know the rest)
15:01:24 <weexplat> src lookup
15:01:28 <weexplat> @src lookup
15:01:28 <lambdabot> lookup _key []          =  Nothing
15:01:28 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
15:01:28 <lambdabot>                         | otherwise = lookup key xys
15:01:47 <ski>   f x0 = head [y | (x1,y) <- s , x0 == x1]
15:01:56 <luite_> rasfar: right
15:02:10 <luite_> oh it doesn't work, it trips one of the boobytraps
15:02:21 <ski> qued_____ : however, this is more or less the same as `lookup' is doing
15:02:22 <rasfar> that qualifies for "drat"
15:02:36 <rasfar> what's the traversal code you used?
15:02:45 <qued_____> weexplat: ((x,y):xys) means list of tuples?
15:02:54 <qued_____> in general
15:03:01 <weexplat> i think just having the booby traps qualifies for 'drat'
15:03:19 <rasfar> i'm curious how applying id would trip one of these booby traps.  (i didn't see the traps yet on the API page you linked, but just scanned it quickly)
15:03:23 <zhulikas> @type ((a,b):_)
15:03:24 <lambdabot> Pattern syntax in expression context: _
15:03:26 <zhulikas> ok :(
15:03:27 <weexplat> tripping them with a traversal qualiies for '[redacted]'
15:04:08 <luite_> rasfar: processParsedSource' = SYB.everywhere (mkT $ replaceExp), replaceExp (GHC.ExplicitList t exprs) = GHC.ExplicitList t []
15:04:10 <rasfar> qualifies for '[redacted]' ? hmm...
15:04:26 <geekosaur> :t let c@((a,b):_) = undefined in c
15:04:27 <lambdabot> forall t t1. [(t, t1)]
15:04:38 <weexplat> qued_____: when you pattern-match on ((x,y):xys), the argument and xys are lists of tuples
15:04:41 <luite_> rasfar: it's just something very stupid that replaces all lists with []
15:05:16 <rasfar> your replaceExp function needs more type constraint I think?
15:05:34 <ski> qued_____ : `(x,y):xys' is a pattern for a list of pairs, yes
15:05:45 <luite_> rasfar: its type sig: replaceExp :: GHC.HsExpr GHC.RdrName -> GHC.HsExpr GHC.RdrName
15:05:45 <rasfar> give it an explicit HsExpr -> HsExpr typesig
15:06:10 <rasfar> (right)
15:08:11 <rasfar> i've never looked at the GHC AST types before, so it's a bit rough going at present.  there's no Exp types at all on that doc page...
15:08:28 <luite_> hehe it's kind of a jungle :p
15:08:33 <luite_> lots of different types
15:08:37 <luite_> lemme find them
15:08:41 <rasfar> nor anything about redacted ... i'm interested in learning about this stuff though!
15:09:23 <rasfar> http://www.haskell.org/ghc/dist/stable/docs/html/libraries/ghc-7.4.0.20120131/HsSyn.html
15:11:04 <luite_> HsModule -> HsDecl (ValD) -> HsBind -> HsBindLR (FunBind) -> MatchGroup -> Match -> GRHS -> Stmt / HsExpr
15:11:15 <luite_> is how I arrive at my exprs in my simple test code
15:11:39 <rasfar> you might start by trying to replace all HsLit with 3 or something, something really simple.  of course it will probably fail type checking, but you can just dump the AST for debugging?
15:11:47 <luite_> http://localhost:16004/file//Users/luite/.cabal/share/doc/ghc-7.4.1/html/HsExpr.html#t:HsExpr
15:11:56 <luite_> oh that might not work :p
15:12:08 <rasfar> nope!
15:12:38 <luite_> rasfar: yeah i'm doing something like that, replacing all lists with [] is even simpler
15:13:43 <rasfar> by lists, you mean ExplicitList PostTcType [LHsExpr id] constructor?
15:14:04 <luite_> http://hackage.haskell.org/packages/archive/ghc-syb-utils/0.2.1.0/doc/html/GHC-SYB-Utils.html <- ooh, this has something useful
15:14:23 <luite_> rasfar: yeah, just change the second field to [] to make an empty list :)
15:14:33 <rasfar> replaceExp (ExplicitList ptt lst) = ExplicitList ptt []
15:14:39 <rasfar> replaceExp x = x
15:15:02 <rasfar> with your type sig, should do it.  but it's tripping a boobytrap you say?
15:15:05 <luite_> yes that is what I already have, and pasted here, but I need the everythingStaged from that syb-ghc package instead of the everything
15:15:34 <rasfar> you pasted the type signature
15:15:45 <luite_> also the implementation :p
15:16:27 <rasfar> hmm i still don't see it, but anyways, at least we're attempting the same thing so i have some idea what you're talking about.
15:17:28 <rasfar> oh yeah, i see it now
15:18:01 <rasfar> i'd love to try this, would you be willing to paste a module for me?
15:18:58 <rasfar> (so that i don't have to figure out the imports etc.)
15:19:03 <stephenjudkins> is there a way to get "home" and "end" keys to work properly in ghci?
15:19:36 <luite_> rasfar: I'm currently testing this as part of a larger thing, but I should probably make a separate test module as well
15:20:10 <rasfar> actually the imports wouldn't be the time consuming part, it would be figuring out how to parse a source
15:22:18 <luite_> ok, could take a moment
15:23:51 <rasterfar> (i was disconnected, but i see your last message on tunes.  hope it's not too much trouble...)
15:25:37 <luite_> rasfar: nah, I should make a separate test case for myself anyway
15:27:00 <rasfar> the idea of plunging into these (ghc) depths is giving me the butterflies... :D
15:28:06 <luite_> I was doing source code processing with haskell-src-exts, but it was giving me some trouble, and since its author doesn't reply to emails, I'm trying to do everything with GHC now
15:30:50 <lazythunk> stephenjudkins: like ^a or ^e ?
15:31:30 <stephenjudkins> lazythunk: yes, that does the trick. thanks. (although every other REPL i've used works fine with home/end)
15:32:14 <kallisti> would it be possible to mimic Control.Exceptions subclassing structure within the ErrorT monad?
15:32:23 <rasfar> what trouble i wonder?  i managed to do fairly complicated traversals with both Exts and Exts.Annotated.
15:32:38 <rasfar> I was still wondering whether HSE was used by GHC or not; now I know "not"...
15:32:51 <stephenjudkins> lazythunk: obviously haskell is not ready for Enterprise-Scale Development :)
15:33:37 <kallisti> wouldn't the way home/end is handled be specific to your terminal emulator?
15:33:48 * hackagebot jalla 0.1.0 - Higher level functions for linear algebra. Wraps BLAS and LAPACKE.  http://hackage.haskell.org/package/jalla-0.1.0 (ChristianGosch)
15:34:16 <geekosaur> readline was proving a portability issue, so ghci uses its own simulation thereof.  dunno if it supports home/end, I use the emacs keys
15:35:12 <geekosaur> (for example OS X has a "readline" which is actually BSD editline, which breaks things in annoying ways; actual readline would need to be installed separately)
15:36:39 <yasar> I am at chapter 5. of real world haskell, I am trying to compile PrettyStub.hs file, using "ghc - c PrettyStub.hs", but it gives "The function `main' is not defined in module `Main'", what am I doing wrong?
15:36:46 <ben> I use vi keys in my ghci and home/end works
15:36:59 <ben> you can fuck with ~/.haskeline and maybe get it to work
15:38:03 <mauke> yasar: why "- c"?
15:41:05 <yasar> main module is not ready at this step, I have created a stub module for my Prettify module, because Prettify module is not written yet.
15:41:25 <mauke> what
15:41:27 <yasar> I am trying to follow what http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html does.
15:41:38 <rasfar> "Error ... couldn't find module ... of the hidden package `ghc-7.0.4'" -- should I cabal expose it?
15:41:49 <mauke> that doesn't contain "- c"
15:41:52 <luite_> rasfar: oh, I'm doing some exact prettyprinting with modifications, and it gets ugly :) and it prints {-#LANGUAGE FlexibleInstances #-} back as {-# LANGUAGEFlexibleInstances #-}, and some new ghc syntax is not supported yet
15:42:39 <rasfar> sounds interesting.  luite_ -- should I "cabal expose" ghc in order to build a parser?
15:42:47 <luite_> no
15:42:51 <luite_> ghci -package ghc
15:42:52 <rasfar> i hesitate to do that as it sounds like it could be, erm, dangerous.
15:43:11 <luite_> one moment, I'm still putting together the example, looks like I'm almost done
15:43:13 <rasfar> can i avoid ghci actually?.... :)
15:43:17 <rasfar> okay
15:43:28 <luite_> oh ghc -package ghc --make ... will also work
15:43:38 <yasar> if a imports b and b imports c, can I use a in c?
15:43:41 <rasfar> i found some sort of examples, so just trying to make sure i'm ready when the moment arrives
15:44:02 <rasfar> yasar, not very easily
15:44:22 <yasar> So I need to import a in c seperately?
15:44:54 <rasfar> that will likely be a circular import; can you split the thing in c out (either into a, or into a new module)?
15:45:29 <rasfar> luite_ thank you, -package ghc worked a treat
15:46:21 <kallisti> yasar: you can explicitly export module a within module b
15:46:28 <rasfar> haha! "hello world" with the GHC imports is only 25 MB in size
15:46:28 <kallisti> and then anything importing b will import all the symbols exported by a
15:47:05 <yasar> something like module b where import a ... ?
15:47:10 <kallisti> no
15:47:16 <kallisti> module B (someSymbol, moreSymbols, AType(..), module A) where ...
15:47:17 <rasfar> make that 30 MB
15:47:28 <kallisti> you specify it within the explicit export list.
15:47:32 <kallisti> as module A
15:47:43 <kallisti> a lot of "meta modules" do this.
15:48:08 <yasar> Can I say something like, export everthing, and also module A?
15:48:09 <kallisti> module My.Software (module My.Software.A, module My.Software.B) where
15:48:18 <kallisti> import My.Software.A; import My.Software.B
15:48:30 <kallisti> yasar: I don't recall. not to my knowledge.
15:48:54 <luite_> rasfar: almost done now :)
15:49:03 <kallisti> the exporting/importing facilities could use a bit of extra features, I think.
15:49:45 <kallisti> yasar: typically explicit export lists is Good Practice, and if a module has a lot of thinks to export to the point that it becomes tedious, this may be an indication that you need to split it up.
15:49:51 <kallisti> *things
15:50:12 <kallisti> or rethink your module structure in general.
15:50:19 <mauke> yasar: yes
15:50:37 <mauke> you can put modules in the export list, including yourself
15:50:44 <kallisti> oooh
15:50:46 <kallisti> right.
15:50:57 <kallisti> why didn't I think of that. :P
15:53:06 <luite_> rasfar: ok, I have one that shows the exception with everywhere
15:53:35 <rasfar> luite_ fantastic, you can email it or hpaste?
15:54:40 <luite_> hm, hpaste seems to have some problems atm
15:54:57 <luite_> oh it still posted my source
15:54:57 <rasfar> email is rasfar at the g mail
15:55:02 <luite_> http://hpaste.org/65775
15:55:08 <rasfar> oh, ... alright
15:55:45 <luite_> it tries to parse the module, then dump the ast before and after transformation
15:58:13 <rasfar> i'm building the dependencies now
15:59:06 <luite_> shouldn't take too long, small packages :)
15:59:21 <rasfar> maybe 300 brower tabs + these compilations are a bit much for the netbook, be patient :)
16:00:07 <rudyl313> I have a list of types with type: [(Double, MyUnOrderableType)] ... whats the easiest way to pick out the list element (tuple) with the maximum value for the double in the tuple
16:00:51 <Botje> maximumBy (compare `on` fst)
16:01:03 <rudyl313> Botje: sweet thanks!
16:01:12 <Botje> `on` is in Data.Function
16:01:56 <ben> compare `on` is just comparing from Data.Ord, isn't it
16:02:15 <geekosaur> yes
16:02:25 <rudyl313> ben: do u have an alternative?
16:02:25 <geekosaur> compare `on` is a little older
16:02:35 <ben> Data.Ord.comparing
16:02:40 <hpc> @src comparing
16:02:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:03:12 <ben> comparing p x y = compare (p x) (p y)
16:03:23 <ben> Data.Ord is a fairly small module!
16:03:49 <rudyl313> maximumBy (comparing fst) worked for me :)
16:03:53 <Pseudonym> That's a good thing, no?
16:04:13 <rasfar> luite_: Could not find module `GHC.SYB.Utils' but ghc-syb-utils did install...
16:04:34 <rasfar> wait, never mind, this terminal has my path swapped around!
16:05:09 <rasfar> ah no, which means I have to install both those extras again...
16:05:46 <rasfar> sorry about that; meanwhile i can look at the code...
16:06:06 <luite_> no hurries :)
16:08:36 <rasfar> it runs, but tells me: "Main: Module not part of module graph" -- this isn't the exception you're referring to presumably.
16:09:21 <rasfar> nm, i had to edit the module name in Test1.hs (formerly a Main.hs)
16:09:48 <rasfar> for one thing, i should have chosen a shorter test file... heh
16:10:24 <luite_> oh yeah it doesn't catch exceptions yet
16:10:41 <luite_> so wrong things happen if you don't have the right .hs file :)
16:10:58 <rasfar> right, "Main: noRebindableInfo" is what you get?
16:11:51 <rasfar> my test file contains one function, "test = map (*2) [1,2,3]" (figured it should have an ExplicitList).
16:12:48 <rasfar> i will confess that your syb code looks fine, i don't yet have any clue (and you are a better programmer than i by a fair stretch)
16:13:39 <rasfar> i'm trying it with everywhere' which is top-down ... nope, same thing.
16:15:55 <rasfar> now i'm disentangling my earbuds (<- hard problem) as it just got real loud here.
16:16:33 <luite_> rasfar: yeah it can be solved by checking the types first
16:17:30 <luite_> like everythingStaged, but how do you implement an everywhereStaged ?
16:18:27 <rasfar>  :t earbuds --> Shure
16:18:46 <rasfar> so that's what "stages" is about -- that's post-typecheck>
16:19:40 <luite_> yeah, if it's Parser, then it cannot evaluate PostTcType things
16:19:44 <luite_> since it will go boom
16:20:43 <rasfar> (i'm going to find the local api pages that just installed)
16:21:59 <rasfar> so everywhereStaged needs a Staged as first arg
16:24:24 <rasfar> and you gave it SYB.Parser which is what i just concluded i should try, so i guess i'm caught up :/
16:26:48 <rasfar> oh! it's an "everything" not an "everywhere" -- we need a mkQ not mkT for the traversal!
16:27:48 <rasfar> but that's no good for transforming nodes :(
16:28:33 <rasfar> i'm looking at the source for everthingStaged, i suppose we could write an analogous everywhereStaged but I wonder why it's not already there?
16:30:38 <luite_> rasfar: I'm trying to write one, I think I have one, but it still fails
16:30:59 <rasfar> i see!
16:35:21 <rasfar> the type would be everywhereStaged :: Staged -> GenericT -> GenericT correct?
16:37:46 <rasfar> everywhereButStaged ?
16:38:23 <luite_> uh same as everywhere, but with an extra Stage parameter
16:38:31 <khs> Hi, is there any way to set a single field of a dataconstructor with record syntax? ie ... setField :: SomeData -> SomeData ?
16:38:53 <khs> without making the setField function...
16:40:14 <luite_> rasfar: oh I'm kinda stupid, the exception occurs already in the prettyprint of the untransformed tree
16:41:53 <DMcgill> khs: `data{field = value}'
16:42:15 <DMcgill> it isn't a nice function unfortunately
16:42:17 <rasfar> oh i see
16:42:46 <rasfar> hmm, so maybe we don't need an everywhereStaged after all
16:44:16 <yasar> I guess it doesn't matter in which order you define function in haskell, does it?
16:44:30 <DMcgill> yasar: not that I know of
16:44:47 <luite_> rasfar: yes we do, but everything in the ghc-syb-utils package is wrong
16:44:52 <DMcgill> at the same level of scope anyway
16:45:04 <rasfar> where would I find postTcType fixity nameSet
16:45:24 <luite_> those are local definitions there
16:45:27 <rasfar> that's my last problem (i believe) until having everywhereButStaged
16:45:44 <rasfar> oh! why are they not found i wonder (looks again)
16:46:15 <luite_> just const functions based on the stage
16:46:26 <luite_> the key is of course the type sigs
16:47:27 <rasfar> ghc-syb-utils uses them but i can't seem to import them...
16:47:29 <Authoritarianism> Is there any standard heap data type?
16:47:48 <rasfar> i think we need them, based on the definition of everythingStaged
16:47:54 <luite_> rasfar: they're local, in teh where of everythingStaged
16:50:25 <rasfar> yes, i'm trying to paste them but i need to put SYB. in front of some other things...
16:51:12 <luite_> oh yes, I removed all thos qualified things already
16:52:32 <nart> hi :D
16:56:17 <rasfar> okay now u'm into the type errors....
16:57:08 <luite_> rasfar: I can pp the tree now, but it seems to have lots of black holes :(
16:58:49 <rasfar> m-hmm
16:59:10 <rasfar> you mean prior to the generic traversal?
17:00:23 <luite_> it looks like SyntaxExpr is just a type synonym for HsExpr, maybe SYB has no way to tell them apart?
17:00:50 <luite_> in that case we would be screwed...
17:02:24 <rasfar> no way that i know of ... gee, why would an important distinction be predicated on a type synonym!
17:02:49 <rasfar> bad day for internet, hpaste still down (and i don't even get a link to share), and i cannot log in to my web server
17:02:51 <luite_> wait, maybe there is still a diff in the parameter
17:03:14 <luite_> http://hpaste.org/65780
17:03:17 <luite_> this is your link
17:03:23 <luite_> it gives an exception, but the past is still stored
17:03:51 <luite_> I already have everywhereStaged btw :)
17:03:58 <luite_> just can't test it
17:04:15 <rasfar> i believe you but i had to try it, this is very good for me
17:04:39 <rasfar> anyone have a better suggestions than AwardSpace for shared hosting, they are terrible actually
17:04:42 <rasfar> ?
17:05:16 <rasfar> (should see some of the answers i've had from their support)
17:07:59 <luite_> dunno, but I like Hetzner for dedicated hosting :)
17:09:24 <luite_> so uh, we can't distinguish them by type, is there anything we can do to make SYB not traverse certain fields with gmapT ?
17:15:55 <nart> @help
17:15:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:16:04 <nart> @list
17:16:04 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:16:27 <nart> @seen ski
17:16:27 <lambdabot> Unknown command, try @list
17:20:02 <zhulikas> @hoogle mapM
17:20:02 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:20:02 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:20:02 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
17:22:58 <rasfar> with test = [7,13]  it does work
17:23:12 <nart> http://dl.dropbox.com/u/10443564/monad.html
17:23:52 <rasfar> (apparently i was offline for the last 5 messages i typed)
17:24:26 <rasfar> Hertzner, thank you
17:24:43 <rasfar> Hetzner, oops
17:24:54 <mjrosenb> is there a way of getting ghc to use a particular linker?
17:25:30 <rasfar> luite_ : do you have the extra stop conditions?  i assumed those were there to avoid the holes
17:25:41 <rasfar> this line:   | (const False `SYB.extQ` postTcType `SYB.extQ` fixity `SYB.extQ` nameSet) x = x
17:25:47 <luite_> yeah these conditions are not enough, the SyntaxExpr thing must be stopped
17:25:58 <rasfar> ok
17:26:20 <luite_> but since it's the same type, you have to match on where it's used
17:26:49 <rasfar> is SyntaxExpr a "hole"? i don't even know what these holes are, or know if i've seen one...
17:27:31 <Ste1891> Sorry, basic question, but what type signature should I use for a function (e.g.: combine a b = [a, b]) if a and b can only be of type Int?
17:28:37 <rasfar> combine :: Int -> Int -> [Int]
17:30:05 <rasfar> mjrosenb: -pgml cmd
17:30:36 <rasfar> i suppose i'm offline again, sigh
17:31:14 <rasfar> combine :: Int -> Int -> [Int]
17:31:20 <rasfar> mjrosenb: -pgml cmd
17:31:22 <Ste1891> rasfar: thanks.
17:31:33 <rasfar> (sorry if already answered; i went offline the first time i typed those)
17:31:34 <luite_> rasfar: yep it is a hole
17:31:41 <luite_> rasfar: before the renamer
17:32:00 <rasfar> sorry for the disconnects
17:32:09 <mjrosenb> rasfar: thanks.
17:32:31 <rasfar> Ste1891, mjrosenb: you're very welcome =)
17:33:02 <luite_> rasfar: np, I'm busy typing new stop conditions anyway :)
17:33:29 <rasfar> if it's any consolation, with a simpler example the whole thing runs fine:  test = [7,13]  ;)
17:33:51 <rasfar> or should i say "the hole thing" teehee
17:36:30 <rasfar> actually not the whole thing -- you can't print the program before the transformation, but it's fine when you've nulled the list.  fussy!
17:42:14 <luite_> rasfar: yeah I expected as much, it's the overloaded literals
17:42:23 <luite_> I have a prettyprinter now that can print it
17:43:47 <luite_> brb, getting something to eat
17:44:14 <luite_> will make a full example after
17:44:37 <rasfar> cool, i look forward to it
17:47:50 <Cale> http://theproofistrivial.com/ <-- haha
17:49:32 <irene-knapp> Cale: what's grey and commutes?
17:50:20 <Cale> I don't know, what?
17:50:25 <irene-knapp> an abelian elephant
17:50:40 <irene-knapp> I think that's part of a series of three jokes
17:50:44 <irene-knapp> but I'm not math-y enough to know the others
17:50:51 <irene-knapp> so I leave them as an exercise to the reader?  yeah, that works
17:50:59 <Cale> I only knew the "what's purple and commutes" one
17:51:02 <irene-knapp> haha okay
17:51:06 <Cale> (an abelian grape)
17:51:09 <irene-knapp> yes
17:51:17 <c_wraith> I forgot the joke, but I remember the punchline: A finitely-venerated abelian grape
17:51:19 <irene-knapp> I find elephants more intrinsically humorous than grapes
17:51:21 <Cale> an elephant in the centre of the grape?
17:51:31 <irene-knapp> haha, cute c_wraith
17:51:48 <c_wraith> so, you know, add something about limited worship
17:52:19 <Cale> What's yellow and complete under the metric induced by its norm?
17:52:31 <irene-knapp> dunno, what?
17:52:32 <Cale> A banananach space
17:52:53 <irene-knapp> hah!
17:52:56 <irene-knapp> I get it!  almost
17:53:08 <Cale> http://en.wikipedia.org/wiki/Banach_space
17:53:15 <edwardk> cale: ouch
17:54:22 <fryguybob> What's yellow and equivalent to the Axiom of Choice?
17:54:36 <irene-knapp> dunno, what?
17:54:44 <fryguybob> Zorn's Lemon.
17:54:47 <irene-knapp> cute, haha
17:54:57 <Cale> Why did the chicken cross the Möbius strip?
17:55:14 <rasfar> that's a paraducks
17:55:17 <c_wraith> to get to the same side?
17:55:47 <irene-knapp> see, I would have told that one as "to get to the other — oh wait"
17:57:45 <rekado> Hi
17:58:35 <rekado> In my application I want to treat JSON (in the form of a ByteString) as a HashMap
17:58:58 <Authoritarianism> Hello, does Haskell have any standard heap data type?
17:59:33 <rekado> I tried using Data.Aeson to parse the ByteString, but I only get a Value, not an Object that I could run lookup on.
18:01:14 <rekado> I execute this to get the Value: parseOnly json myJSONByteString
18:01:31 <rekado> parseOnly is from Data.Attoparsec
18:01:39 <luite_> rasfar: great success
18:01:45 <rasfar> super
18:01:58 <c_wraith> rekado: what version of aeson?
18:02:03 <zhulikas> @hoogle lift
18:02:03 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
18:02:04 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
18:02:04 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:02:16 <rekado> c_wraith: 0.6.0.0
18:02:30 <c_wraith> why not just call decode?
18:02:49 <c_wraith> of course, that'll still give you a Value back, so it's equivalent
18:03:11 <rekado> c_wraith: yes, that's what I thought
18:03:27 <c_wraith> But...  Just pattern-match on the value.  *if* it's an Object constructor, it contains the map you want
18:03:51 <rekado> c_wraith: Oh. Have to try that.
18:04:18 <rekado> c_wraith: thanks.
18:04:18 <rasfar> luite_: any chance to see it, or did you do it in the big system?
18:04:58 <luite_> rasfar: http://hpaste.org/65785
18:06:43 <luite_> ooh, everywhereStaged isn't required at all
18:06:53 <luite_> the exception was just in the pretty printing part
18:07:26 <luite_> so you can remove it, but keep the changes in the lower part
18:07:52 <rasfar> i see.  so you brought in showData for that.
18:08:19 <luite_> yeah, just some extra things that it prettyprints differently if stage < Renamer
18:08:24 <rasfar> isn't it exported, or maybe you altered it?...
18:08:39 <luite_> I added all the extra cases for SyntaxExpr
18:08:47 <rasfar> ah, i see
18:08:53 * hackagebot git-date 0.1 - Bindings to the date parsing from Git.  http://hackage.haskell.org/package/git-date-0.1 (StephenWeber)
18:09:30 <rasfar> thanks, this is a great starting point for me to explore the ghc api, and hopefully syb is serviceable to you in exchange
18:10:04 <luite_> yeah I'm starting to get the hang of it now
18:10:43 <rasfar> only 3279 more HsExpr constructors to go!
18:10:57 <luite_> hehe
18:12:11 <rasfar> okay i'm off for what will no doubt become a lesson in Flamenco guitar
18:12:30 <luite_> good luck :)
18:17:32 <zhulikas> @hoogle map
18:17:33 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
18:17:33 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
18:17:33 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
18:18:08 <zhulikas> @hoogle (a -> b) -> [a] -> [b]
18:18:09 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
18:18:09 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
18:18:09 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
18:22:48 <Cale> irene-knapp: heh, this joke is actually useful:  Q: What is a compact city?
18:22:52 <Cale> It's a city that can be guarded by finitely many nearsighted policemen.
18:23:02 <irene-knapp> hah!
18:23:05 <irene-knapp> nice
18:23:19 <Cale> though probably that should be "totally bounded"
18:23:25 <irene-knapp> hmm
18:23:53 * hackagebot cab 0.1.11 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.11 (KazuYamamoto)
18:24:32 <Cale> Q: Why didn't Newton discover group theory? Because he wasn't Abel.
18:25:11 <irene-knapp> hmm
18:25:18 <irene-knapp> cute
18:30:11 <troubld> could someone point me to a document on how to interact with programs through pipes? I'm having a whole lot of trouble
18:34:55 <troubld> ah, i found libexpect i will give that a try
18:35:36 <yasar> what does '$' mean in 'putStrLn $ show [("hi", 1), ("there", 3)]'
18:36:00 <Authoritarianism> > putStrLn $ show [("hi", 1), ("there", 3)]
18:36:01 <rekado> yasar: apply to
18:36:02 <lambdabot>   <IO ()>
18:36:19 <rekado> yasar: it's like round brackets around everything that follows the $
18:36:46 <Sgeo> yasar, f $ x = f x
18:36:49 <yasar> basically same thing as putStrLn (show [("hi", 1), ("there", 3)]) ?
18:36:55 <Sgeo> Yes
18:41:21 <Authoritarianism> Hello. Suppose I have a value of a deeply nested algebraic data type, and I just want to modify one of its deeply nested components.
18:41:33 <roconnor> lenses!
18:42:05 <Authoritarianism> I could reconstruct the whole value with the modified component, but the computational complexity of that operation could be very high.
18:42:06 <ezyang> edit combinators!
18:42:20 <Authoritarianism> Lenses? Edit combinators?
18:42:52 <roconnor> Authoritarianism: you have to reconstruct the modified component, however it isn't as bad as you think as most of it will be shared with the old value.
18:43:12 <roconnor> Authoritarianism: lenses are a data structure that make such modifications of deeply nested structures easier.
18:43:18 <Authoritarianism> roconnor: I know most will be shared.
18:43:22 <ezyang> zippers!
18:43:43 <ezyang> Basically, there are a lot of solutions, and you need to be a little more specific so we can help you in your specific case.
18:43:49 <weexplat> well, it depends.  if it's the last element of a linked list of a million elements, that's a problem.  if it's like a 5 megabyte structure but only 10 levels deep, it's probably no big deal
18:44:24 <Authoritarianism> weexplat: I still have not chosen a specific data structure, but it in principle must be a min-heap.
18:44:51 <weexplat> Authoritarianism: can't you use one from a library?
18:44:55 <ezyang> Well then, min heaps tend to have good depth properties, so path copying works well.
18:45:23 <Authoritarianism> weexplat: Does Haskell not come with a standard heap data type?
18:45:48 <roconnor> Authoritarianism: we have priority-queues, priority-search-queues and finger-trees
18:45:52 <weexplat> Authoritarianism: 'no' or 'several', depending what you mean by 'come with'
18:46:05 <ezyang> IIRC, none in 'base'
18:46:09 <ezyang> / 'containers'
18:46:43 <txibilis> .
18:47:28 <adit> hey #haskell folks
18:47:39 <Authoritarianism> roconnor: How can a heap be emulated using a queue or a finger-tree?
18:47:50 <adit> what is your favorite xml / html parsing library for Haskell, if there is one you like
18:48:24 <roconnor> Authoritarianism: What's the difference between a priority queue and a heap?
18:48:36 <weexplat> Authoritarianism: technically they are members of the 'priority queue' class of ADTs, just like heaps, rather than emulating a heap per se
18:48:55 <weexplat> priority queue is a class of interfaces, heap is a class of implementations
18:49:13 <Authoritarianism> roconnor, weexplat: Oh, yeah, the priority is the ordering itself… I just realized it.
18:49:36 <roconnor> Authoritarianism: and the paper on finger trees describes how to implement a priority queue with them.
18:50:14 <roconnor> Authoritarianism: though it already has been implemented in http://hackage.haskell.org/package/fingertree-psqueue
18:50:43 <weexplat> if you insist on rolling your own heap, though, almost all of the pointer-based heap implementations adapt straightforwardly
18:51:00 <Authoritarianism> No, no. I do not want to roll my own.
18:51:06 <weexplat> (as opposed to the array-heap)
18:51:09 <Authoritarianism> That is the very last thing I want to do.
18:51:24 <roconnor> Authoritarianism: regular priority-queues: http://hackage.haskell.org/package/pqueue http://hackage.haskell.org/package/priority-queue http://hackage.haskell.org/package/pure-priority-queue
18:51:57 <roconnor> Authoritarianism: and regular priority-search-queues http://hackage.haskell.org/package/PSQueue
18:52:01 <weexplat> okay, well, the reason most of the priority queues are some kind of finger tree is finger-tree-based pqueues support more operations
18:53:01 <Authoritarianism> Oh.
18:53:24 <Authoritarianism> IIRC, Data.Sequence is implemented as a finger tree, right?
18:53:36 <c_wraith> yes
18:53:44 <ezyang> Well, there are a bunch of classic heaps on Hackage too.
18:54:03 <roconnor> ezyang: what's a classic heap?
18:54:55 <ezyang> usually I think of a binary heap
18:54:58 <Authoritarianism> I am not interested in any specific heap (in particular, it does not necessarily have to be a binary heap). I just want to retrieve the minimum element in O(log(n)).
18:55:01 <weexplat> roconnor: just like original heap, but with corn syrup
18:55:21 <ezyang> Wait, you don't even need a heap for that...
18:55:27 <roconnor> Authoritarianism: you have a plethory of choices
18:55:42 <weexplat> Authoritarianism: all of the previously mentioned libraries will do that for you
18:56:01 <Authoritarianism> roconnor, weexplat: Yeah, and now I do not know how to choose. I guess I will have to try them all.
18:56:23 <ezyang> Honestly, it probably doesn't matter.
18:56:58 <roconnor> If you just need the minimum value of a list, you can use (minimum) :)
18:57:06 <ezyang> unless your data set is big enough for it to matter... in which case you might want to do something that takes advantage of machine-sized keys.
18:57:57 <roconnor> ezyang: minimum uses O(1) space.
18:58:28 <ezyang> roconnor: Erm, I don't know how you're counting space :-)
18:58:52 <roconnor> ezyang: lists take O(1) space :D
18:59:08 <roconnor> > minimum [1...1000]
18:59:09 <lambdabot>   Not in scope: `...'
18:59:13 <roconnor> > minimum [1..1000]
18:59:13 <lambdabot>   1
19:05:21 <yasar> Can someone suggest easier to understand online learning material than real world haskell book? I have started to loose track after chapter 4.
19:05:34 <yasar> lose*
19:08:35 <JoeyA> yasar: What part are you having trouble with?
19:08:46 <roconnor> Learn You a Haskell for Great Good is a popular book
19:09:39 <tazjin> Does anybody else receive an error when trying to paste to hpaste?
19:09:56 <yasar> Joey: I didn't get typeclasses much.
19:10:29 <yasar> I mean JoeyA ..
19:11:02 <JoeyA> yasar: I'm not seeing any type classes in Chapter 4.
19:11:05 <tazjin> yasar: Try LYAH, the typeclasses chapter is at http://learnyouahaskell.com/types-and-typeclasses
19:12:11 <yasar> JoeyA: I meant I was following until chapter 4, after than that, It became hard to follow. Typeclasses are at chapter 6. I had problems in chapter 5 tooç
19:12:14 <tazjin> yasar: I think you should start with Learn You A Haskell and then move on to Real World Haskell (RWH has a slightly steeper learning curve)
19:13:49 <yasar> tazjin: Learn you a haskell looks fun!
19:26:00 <Modius> Is there a trick to reverse curry, i.e. put a function and its *last* parameter?
19:26:43 <sipa> :t uncurry
19:26:43 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:28:04 <tsbo> :t curry . uncurry . flip
19:28:05 <lambdabot> forall a b c. (b -> a -> c) -> a -> b -> c
19:30:13 <gwern> @quote
19:30:14 <lambdabot> unknown says: codependent types are useful for dysfunctional programming
19:41:44 <roconnor> @type second
19:41:45 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
19:46:23 <Authoritarianism> Hello. Is there any shorthand for "f $ f $ f $ f … f $ g h"?
19:47:04 <byorgey> Authoritarianism: iterate f (g h) !! 42
19:47:14 <Pseudonym> However, don't do that.
19:47:19 <byorgey> Pseudonym: why not?
19:47:25 <Pseudonym> f . f . f . f . g $ h
19:47:26 <Pseudonym> Or
19:47:31 <Pseudonym> f . f . f $ g h
19:47:45 <byorgey> Pseudonym: but if you want 42 f's...
19:48:04 <Pseudonym> Sorry, I was replying to the original question, not you.
19:48:19 <Authoritarianism> Oh.
19:48:31 <Authoritarianism> Then, is there any shorthand for "f . f . f … f $ g h"?
19:48:44 <Pseudonym> What byorgey said is one option.
19:48:51 <byorgey> Authoritarianism: yes!  it's the same as what I said. =)
19:48:56 <Authoritarianism> Oh.
19:49:12 <Pseudonym> foldr (.) (g h) [ f | _ <- [1..42] ]
19:49:15 <byorgey> f . f . f ....  is just considered better style than  f $ f $ f $ ....  , that's all
19:49:44 <Pseudonym> Uhm.
19:50:00 <Authoritarianism> f (g h) !! 42 yields an error. :(
19:50:06 <Pseudonym> foldr (.) id [ f | _ <- [1..42] ] g h
19:50:20 <Pseudonym> Authoritarianism: You might have missed the word "iterate".
19:50:43 <Authoritarianism> Aaaaaaaaah!
19:50:46 <Authoritarianism> :P
19:51:22 <weexplat> let iter = flip (foldr (const f)) . flip replicate () in iter 42 ('a':) "rrgghh"
19:51:25 <weexplat> > let iter = flip (foldr (const f)) . flip replicate () in iter 42 ('a':) "rrgghh"
19:51:26 <lambdabot>   Overlapping instances for GHC.Show.Show
19:51:26 <lambdabot>                              ([GHC....
19:51:26 <roconnor> @hoogle (<+>)
19:51:27 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
19:51:27 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
19:51:27 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
19:52:08 <weexplat> :t let iter = flip (foldr (const f)) . flip replicate () in iter (a:) 42 "rrgghh"
19:52:10 <lambdabot>     Couldn't match expected type `Int'
19:52:10 <lambdabot>            against inferred type `[Expr] -> [Expr]'
19:52:10 <lambdabot>     In the first argument of `iter', namely `(a :)'
19:52:38 <weexplat> > let iter f = flip (foldr (const f)) . flip replicate () in iter ('a':) 42 "rrgghh"
19:52:40 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarrgghh"
19:52:48 <Authoritarianism> Yes, argh.
19:53:39 <Pseudonym> > foldr (.) id [ (a:) | _ <- [1..42] ] ("rg"++) "h"
19:53:40 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> [GHC.Types.Char]'
19:53:40 <lambdabot>        ...
19:53:51 <Pseudonym> > foldr (.) id [ ('a':) | _ <- [1..42] ] ("rg"++) "h"
19:53:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> [GHC.Types.Char]'
19:53:52 <lambdabot>        ...
19:53:58 <Pseudonym> Erm.
19:54:44 <weexplat> > foldr (.) id (replicate 42 ('a':)) # ("rg"++) "h"
19:54:45 <lambdabot>   Not in scope: `#'
19:54:45 <Pseudonym> > foldr (.) id [ ('a':) | _ <- [1..42] ] $ "rgh"
19:54:47 <Pseudonym> Right.
19:54:47 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaargh"
19:58:59 <weexplat> > execState (replicateM_ 42 $ modify ('a':)) "rgh" -- monads ftw
19:59:01 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaargh"
20:12:11 <roconnor>  No instance for (Read (Fixed E3))
20:12:13 <roconnor> :(
20:13:37 <zhzhxtrrk> is ghc using Windows IOCP for IO stuff?
20:24:28 <roconnor> how much bactracking does Parsec do?
20:25:02 <kallisti> is there any library with lifted variants of common functions?
20:25:11 <kallisti> for example.  <||> :: Monad m =
20:25:12 <kallisti> er
20:25:19 <kallisti> for example.  <||> :: Monad m => m Bool -> m Bool -> m Bool
20:25:31 <kallisti> simple example of what I'm talking about.
20:26:09 <JoeyA> What's the advantage of using RWS versus stacking ReaderT, WriterT, and StateT myself, besides convenience?
20:26:21 <glguy> roconnor: it does the backtracking you tell it to
20:27:06 <kallisti> more specifically I'm interested in things like lifted equality, lifted Ord, etc.  <==> :: MonadEq m a => a -> a -> m Bool
20:27:51 <kallisti> I ask because I'm interested in perhaps creating such a library.
20:28:03 <kallisti> as I believe it would be useful for quickly writing EDSLs
20:29:38 <roconnor> glguy: will it backtrack with (string "abc" >> return ABC) <|> (string "acd" >> return ACD) ?
20:29:50 <kallisti> JoeyA: to my knowledge, that's the main benefit.
20:29:53 <byorgey> roconnor: nope
20:30:00 <roconnor> what a pain
20:30:14 <byorgey> roconnor: you have to wrap (string "abc") in a call to 'try'
20:30:18 <byorgey> or else left-factor the grammar.
20:30:39 <roconnor> I'm not going ot left-factor my grammer
20:30:45 <roconnor> that's computer's work
20:31:06 <byorgey> Indeed.  I just felt obligated to enumerate the possibilities.
20:31:42 <roconnor> :)
20:32:20 <glguy> roconnor: ReadP will parse it both ways for you
20:32:40 <glguy> It does all the parse trees at the same time to try and free up the input as early as possible
20:32:59 <roconnor> oh
20:33:04 <roconnor> why am I using parsec?
20:33:08 <Gying> hi,
20:33:19 <Gying> what's this?
20:33:26 <Gying> any one?
20:33:55 <kallisti> Gying: what's what?
20:34:22 <kallisti> http://en.wikipedia.org/wiki/Haskell_%28programming_language%29
20:34:23 <kallisti> you mean this?
20:34:33 <Gying> can any good person tell me what is Haskell
20:34:43 <kallisti> sorry, I'm not good.
20:34:52 <Gying> ...hah。。
20:35:05 <Gying> thank u
20:35:20 <ortla> hi, i have a question regarding parmap space leak, does anyone have an experience with that?
20:46:18 * kallisti still doesn't really get type/data families
20:46:47 <Gying> i have a question
20:46:52 <kallisti> go on
20:47:26 <Gying> is any difference between haskell and mathematics
20:48:16 <kallisti> Gying: yes
20:48:42 <Gying> err, i have all my ears..please..
20:48:59 <kallisti> they're so different that I don't even know where to start..
20:49:39 <byorgey> Gying: Haskell is much closer in spirit to mathematics than many other languages.
20:49:52 <kallisti> in general, mathematics is not concerned with how things are computed (though it can be)
20:50:18 <kallisti> Haskell, as a programming language, is very much about describing a computation.
20:50:54 <byorgey> but it's much *less* about describing computation than, say, most imperative languages. =)
20:51:12 <kallisti> in some sense, I guess.
20:52:16 <kallisti> Gying: the question is similar to "is architecture like construction work?"
20:53:17 <kallisti> (actually I guess its: is construction work like architecture?)
20:58:20 <kyagrd_> Mutually recursive types are cannot be encoded in System F, am I right?
20:58:35 <yasar> If I wrote functions that depends on each other, like a calls b, and b calls a, would compiler warn me about this?
20:58:50 <kallisti> yasar: no. this is called mutual recursion
20:58:58 <kallisti> sometimes it's desireable
20:59:13 <yasar> But isn't it infinite recursion?
20:59:18 <kallisti> (well, it may warn. I don't know. I haven't done any mutual recursion in Haskell)
20:59:23 <kallisti> yasar: it can be. not always.
20:59:24 <kyagrd_> yasar, well loop = loop is infinite recursion too
20:59:36 <kyagrd_> doesn't have to be mutaully recursive
20:59:40 <kallisti> yasar: also, in Haskell infinite recursion is not always a bad thing. ;)
20:59:51 <kallisti> > repeat 2
20:59:52 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
21:00:02 <yasar> > repeat 5
21:00:02 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
21:00:12 <kallisti> > take 3 . repeat $ 5
21:00:13 <lambdabot>   [5,5,5]
21:00:15 <kyagrd_> Whether computation terminates and wither it is mutually recursive is a different matter.
21:01:01 <kyagrd_> Mutual recursion can be encoded by simple recursion.
21:01:06 <kallisti> yasar: some mutually recursive functions can terminate.
21:01:07 <kallisti> also that.
21:01:35 <kyagrd_> However, mutually recursive types aren't unless you have some feature outside of Systerm F
21:02:01 <glguy> > let even 0 = True; even x = odd (x - 1); odd 0 = False; odd x = even (x - 1) in (even 10, odd 10)
21:02:02 <lambdabot>   (True,False)
21:02:19 <kallisti> yes, the standard example of mutual recursion, terminates.
21:02:29 <kallisti> (on some inputs)
21:02:57 <glguy> depending on the type, those two functions will terminate on all inputs, as well (Int vs Integer, say)
21:03:06 <Authoritarianism> One question: Does Haskell has a language-defined identity function?
21:03:07 <kallisti> yes
21:03:14 <kallisti> > id 2
21:03:15 <lambdabot>   2
21:03:16 <kallisti> you mean like that?
21:03:19 <Authoritarianism> kallisti: Yes!
21:03:22 <Authoritarianism> kallisti: Thanks!
21:03:25 <kallisti> no problem.
21:03:32 <kyagrd_> Authoritarianism: it is in the Prelude
21:03:50 <Authoritarianism> So I can do something like (if cond then f else id) g, right?
21:03:54 <yasar> So, I am reading about typeclasses, I think you can implement more than one typeclass for a data type right?
21:03:57 <kallisti> yes
21:04:09 <Authoritarianism> Is there something even shorter than that?
21:04:19 <Authoritarianism> I mean, like a function that takes a boolean and a function….
21:04:25 <kallisti> you could define a function and use a guard, perhaps.
21:04:28 <kallisti> might be cleaner
21:04:31 <Authoritarianism> Okay.
21:04:33 <Authoritarianism> Thanks!
21:04:40 <kyagrd_> yasar: of course. Try :info Int  in GHC
21:04:42 <kallisti> f | cond = operation | otherwise = x
21:04:44 <kallisti> for example
21:04:56 <kallisti> may not be as short, but it probably looks nicer.
21:04:58 <kyagrd_> it will show you several type classes that has Int instances
21:05:19 <kyagrd_> > : info Int
21:05:20 <lambdabot>   <no location info>: parse error on input `:'
21:05:28 <kyagrd_> ah this doesn't work :)
21:05:30 <kallisti> kyagrd_: lambdabot doesn't have it
21:05:33 <kallisti> try ghci
21:05:37 <Authoritarianism> kallisti: I am doing this in a very nested where.
21:05:37 <yasar> :info Int
21:05:49 <yasar> nope, doesn't work :)
21:05:50 <kallisti> Authoritarianism: that's no good. :(
21:06:21 <kallisti> well, maybe. there's a point, in my opinion, where there's too much where. :P
21:06:46 <Authoritarianism> :P
21:07:03 <Authoritarianism> I can't help. I love where.
21:07:20 <kallisti> I actually use let in some situations, because it looks better for small bindings
21:08:40 <Authoritarianism> In my case, let would only make it worse.
21:09:06 <Authoritarianism> By the way, infix operators always have lower precedence than regular functions / constructors, am I right?
21:09:22 <kallisti> yes
21:09:31 <kallisti> function and constructor application, that is.
21:09:48 <Authoritarianism> Okay! Thanks!
21:10:00 <kallisti> also record update is higher precedence than both application and other operators. as in:  record {x = y, z = a, b = c, ...}
21:10:29 <kallisti> f Cons {x = y} -- like this, for example
21:11:04 <Authoritarianism> Is there any way to evaluate what in C is (x & 1) in Haskell?
21:11:47 <glguy> You can use stuff from Data.Bits, or you can use "odd"
21:12:38 <kyagrd_> Authoritarianism: try using Control.Applicative if you want fancier alternative for (if cond then f else id)
21:13:05 <Authoritarianism> kyagrd_: Let me check that out.
21:13:16 <kyagrd_> instance Applicative ((->) a) can do the job
21:14:33 <Authoritarianism> I hope that is not too complicated.
21:17:43 <byorgey> Authoritarianism: probably not worth it.  do you know about Functors yet?
21:18:00 <Authoritarianism> byorgey: Nope.
21:18:02 <byorgey> (because if not, don't try reading about Applicative until you do)
21:18:13 <byorgey> but there's no rush in any case.
21:19:12 <kyagrd_> Authoritarianism: oh I misguided you I think, I think you should define instance Alternative class ...
21:19:32 <roconnor> @hoogle minimumBy
21:19:32 <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
21:19:32 <lambdabot> Data.Foldable minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
21:19:47 <kyagrd_> It's in Control.Applicative anyway
21:21:15 <byorgey> kyagrd_: you are misguding Authoritarianism because they are not ready to learn about Applicative or Alternative. =P
21:25:32 <yasar> does "do" keyword mean, you should execute imperatively in this block?
21:26:14 <parcs`> > do do do do do do do do 5
21:26:15 <lambdabot>   5
21:26:49 <yasar> > do putStrLn "yasar"
21:26:50 <lambdabot>   <IO ()>
21:26:56 <yasar> hmm...
21:27:09 <mzero> yasar: no, do is a syntactic sugar for monadic bind (>>=) and a few related things
21:27:26 <yasar> monadic what?
21:27:30 <parcs`> the do keyword doesn't mean anything by itself
21:27:34 <Saizan> the (>>=) operator
21:27:43 <mzero> so here's an example:
21:27:53 <mzero> do { print "hi"; print "world" }
21:28:03 <mzero> is the same as     print "hi" >> print "world"
21:28:07 <yasar> I don't know what (>>=) operator does.
21:28:10 <mzero> and
21:28:29 <mzero> do { n <- getLine; print $ "hi " ++ name }
21:28:32 <mzero> is the same as
21:28:45 <mzero> getLine >>= (\n -> print $ "hi " ++ n)
21:28:47 <parcs`> yasar: are you reading LYAH?
21:28:53 <ortla_> hi, does anyone have experience with parMap space leaks
21:29:09 <yasar> parcs`: I am reading http://book.realworldhaskell.org/read/io.html
21:30:25 <mzero> okay, yasar, in that case... for now,   think of  do  as "the action that is the sequencing of these actions together"
21:30:32 <parcs`> ah, near the end of the chapter you will realize that do notation is just syntactic sugar for the >>= operator
21:30:41 <mzero> in other words, very similar to a block in an imperative language
21:31:01 <yasar> Ok.
21:32:53 <mzero> you will eventually learn that  do  expressions aren't necessarily imperative
21:33:23 <adu> like with Maybe, Either, and []
21:33:42 <mzero> or State even....!
21:33:56 <adu> I never groked State
21:34:10 <Pseudonym> People still think that Prolog's comma operator is imperative.
21:34:26 <Pseudonym> Which it kind of is, actually. Scratch that. Mercury's comma operator!
21:35:33 * Pseudonym thinks do notation would make a lot more sense if we had monad comprehension syntax first
21:36:42 <adu> what is that?
21:37:00 <Pseudonym> [ (x,y) | x <- xs, y <- ys ]
21:37:07 <Pseudonym> List comprehensions.
21:37:13 <Pseudonym> Alternative notation for this:
21:37:15 <adu> like <${ x | f x }$>
21:37:22 <Pseudonym> do { x <- xs; y <- ys; return (x,y) }
21:37:52 <Pseudonym> Monad comprehensions are basically do-notation in list comprehension syntax.
21:37:55 <adu> but I like do notation
21:38:13 <mzero> i don't think he was suggesting replacing do notation -
21:38:29 <Pseudonym> [ l | l <- getLine, putLine l ]
21:38:29 <mzero> (or she... as it may be)
21:38:39 <Pseudonym> No name, no gender.
21:38:44 <adu> lol
21:39:04 <Pseudonym> No, I wasn't recommending getting rid of do notation.
21:39:15 <Pseudonym> I was recommending re-introducing monad comprehensions.
21:40:11 <Saizan> they got back into GHC with an extension
21:40:28 <mzero> a question:    I want to write something like     class (Monoid (z a)) => ZeeThing z where
21:40:36 <mzero> but, that isn't legal.
21:41:25 <mzero> I want this because I want to write:      foo :: (ZeeThing z) => a -> a -> z a
21:41:39 <mzero> and have Monoid (z a) implied in the body of foo
21:42:00 <mzero> otherwise I have to write     foo :: (ZeeThing z, Monoid (z a)) => a  -> a -> z a
21:42:10 <mzero> and that gets tiresome for many foo s
21:42:42 <Pseudonym> Sounds to me like you want typeclass synonyms.
21:42:52 <mzero> any ideas how I can an encode a constraint for a class when the constraint is on an applied form of the typeclass?
21:42:55 <Pseudonym> We all want them. :-)
21:43:24 <Saizan> ContraintKinds let you define Foo z a = (ZeeThing z, Monoid (z a))
21:43:55 <Saizan> so you can write foo :: Foo z a => a -> a -> z a
21:44:24 <yasar> "Recent versions of ghc, for instance, can provide a level of automatic parallelism for the pure parts of your code" --> Wow!
21:44:41 <Pseudonym> Where's haskell-prime when you need it.
21:45:00 <Pseudonym> That's exactly the sort of thing which we've been asking for in the standard for a decade or so.
21:46:37 <Saizan> heh, it's only been in implemented in the latest GHC release
21:58:32 <JoeyA> I think my favorite GHC extension now is RecordWildCards
21:59:21 <JoeyA> You can actually use Haskell's lack of distinct namespaces per structure to your advantage.
22:00:12 <JoeyA> f Thing{..} Gizmo{..} =  (access the Thing using thingX, thingY; access the Gizmo using gizmoX, gizmoY)
22:00:18 <kfish> JoeyA, yup :)
22:00:50 <kfish> and you can do things like:
22:00:58 <kfish> gizmoX <- calcX foo bar
22:01:42 <kfish> gizmoY <- calcY baz
