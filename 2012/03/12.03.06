00:01:08 <ChristianS> Enigmagic: yes, that sounds better.
00:02:52 <Rc43> Somehow, `cabal install glut` work normally, but `cabal install -w ghc-7.4.1 glut` fails because of insufficient glut lib.
00:12:15 <gregATio> how can i get documentation about a function outside of hoogle, is there a way to get documentation on a fucntion in ghci?
00:17:04 <JoeyA> gregATio: :t to see the type, :i to see more information.  But that's not full documentation.
00:17:36 <JoeyA> For base packages, Hackage documentation comes on your system when you install GHC.
00:17:59 <JoeyA> Also, you can cabal install hoogle.  It's a command-line utility, too.
00:18:08 <gregATio> aha
00:18:47 <JoeyA> What I'd like to know is: can I generate a hoogle index for packages on my system?
00:19:05 <JoeyA> Or am I stuck only being able to search packages that are notable enough?
00:19:21 <JoeyA> (to be in the hoogle index downloaded from Hackage)
00:19:33 <basvandijk> JoeyA: cabal haddock --hoogle
00:20:29 <JoeyA> basvandijk: Ah.  How do I get hoogle to use it?
00:21:51 <JoeyA> I guess I'll try http://stackoverflow.com/questions/6989668/how-to-use-hoogle-locally-like-ctags
00:22:12 <basvandijk> JoeyA: I don't know. Maybe it's in the manual: http://www.haskell.org/haskellwiki/Hoogle
00:22:36 <OODavo> I'm looking at various Haskell quines along the lines of: ap (++) show "ap (++) show "
00:22:39 <OODavo> On trying to run this particular example in GHCi, I'm informed there's no Monad instance for ((->) [Char]). Isn't this a use of the Reader monad, and, if so, why isn't it typechecking in GHCi?
00:23:16 <c_wraith> OODavo: the instance isn't in scope without an import
00:23:23 <c_wraith> import Control.Monad.Instances
00:23:57 <OODavo> Ah, that was it. Thank you.
00:24:07 <Enigmagic> JoeyA: run "hoogle data packagename" then do "hoogle (a -> b -> c) +packagename"
00:24:42 <Enigmagic> where packagename is the package you want
00:25:23 <OODavo> On a related note, where would I find the Functor instance for Reader?
00:25:56 <OODavo> Oh, wait, it's also in Control.Monad.Instances. Never mind.
00:26:34 <JoeyA> Enigmagic: Warning: initech-base couldn't find both Cabal and Haddock inputs
00:27:03 <Enigmagic> JoeyA: you may need to turn on haddock and/or cabal docs in your config file or on the command line when building
00:27:24 <JoeyA> I already ran cabal haddock --hoogle
00:28:38 <Enigmagic> JoeyA: i think the "hoogle data" command looks as the installed documentation
00:28:43 <Enigmagic> cabal haddock doesn't install them
00:29:04 <Enigmagic> you may need to run "cabal install --enable-documentation"
00:31:01 <JoeyA> Still didn't work.  I definitely do have documentation enabled (I use it a lot).
00:31:56 <JoeyA> Running cabal haddock --hoogle and putting the resulting .txt file in my ~/.cabal/share/hoogle-4.2.8/databases/ directory does make hoogle blah +initech-base work.
00:33:35 <Enigmagic> JoeyA: odd, i've never had to do that and hoogle data picks up my packages ..
00:33:46 <Enigmagic> who knows
00:37:39 <osa1> what is the most used graph library in haskell? fgl?
00:43:22 * hackagebot test-framework-th-prime 0.0.4 - Template Haskell for test framework  http://hackage.haskell.org/package/test-framework-th-prime-0.0.4 (KazuYamamoto)
00:44:33 <JoeyA> How do I combine all my .hoo files (I want to add a file to the haddock index so I don't have to say +pkgname)?
00:44:45 <JoeyA> hoogle combine -o default.hoo $(ls *.hoo | sed '/default/d') dies due to too many open files.
00:45:48 <JoeyA> I'll see what hoogle data does.
00:48:15 <hpaste> haus pasted “Maybe” at http://hpaste.org/64865
00:49:07 <haus> anybody about? I'm working at some haskell homework and having a hard time wrapping my head around Maybe
00:49:43 <zerax> What's the trouble
00:49:50 <shachaf> haus: You should ask your question.
00:49:59 <haus> the assignment is to use Maybe to simulate exceptions
00:50:11 <shachaf> haus: By the way, it would be a good idea to use idiomatic Haskell syntax -- function application is "f x", not "f(x)".
00:50:15 <shachaf> Using the latter will only confuse you.
00:50:24 <basvandijk> haus: There's Nothing to it, it's Just easy...
00:50:37 <haus> shachaf: good tip, thanks
00:50:41 <zerax> *groan*
00:50:53 <shachaf> haus: Anyway, you've still not asked your question.
00:51:16 <shachaf> Oh, I see. You have a type error there.
00:51:34 <shachaf> Think about what values you want to return for various inputs.
00:51:53 <haus> right
00:52:07 <shachaf> For example, what's the value you want for "mineven [1,3]"? And for "mineven [1,2,3]"?
00:52:26 <haus> i was trying to make mineven [1,3] = Nothing
00:52:28 <shachaf> (That's not a rhetorical question. :-) )
00:52:37 <haus> and mineven [1,2,3] = 2
00:52:40 <shachaf> (Well, not purely.)
00:52:49 <shachaf> haus: The problem there is that "Nothing" and "2" are of different types.
00:53:09 <haus> right, i thought that's where the Maybe comes in
00:53:20 <shachaf> Well, as soon as you're using Nothing, the Maybe comes in.
00:53:31 <shachaf> The type of Nothing is "Maybe x", for some x.
00:53:37 <shachaf> The type of "2" is "Int".
00:53:46 <shachaf> What's the return type you *want* for this function?
00:54:11 <haus> Integer
00:54:31 <shachaf> But you're returning Nothing in some cases! So it can't be Integer.
00:54:37 <haus> okay, right
00:54:42 <shachaf> Maybe isn't a magic type, you know; you can define it yourself in one line of code.
00:54:53 <osa1> can anyone give me some pointers about understanding what does inductive programming style mean?
00:55:01 <haus> right, i saw the definition... Maybe a = Just a | Nothing
00:55:18 <shachaf> haus: Right. What's the type you want for this function?
00:55:30 <haus> so if it can't be Integer, then can the return type be Maybe Integer, or is that nuts?
00:56:02 <zerax> Perfectly reasonable
01:02:13 <haus> okay, so i updated the return to do Just x, which is of the right type (i thought), but now i'm constructing an infinite type?
01:03:50 <merijn> haus: pastebin source/error somewhere? (or repeat the link if you already did)
01:04:05 <haus> ah, yes...second
01:05:31 <hpaste> haus pasted “Maybe” at http://hpaste.org/64866
01:06:36 <merijn> haus: You're type signature for mineven is wrong
01:06:46 <merijn> You claim it to be "[a] -> Maybe Integer"
01:06:59 <haus> [Integer] -> Mabye Integer better?
01:07:05 <merijn> But you return "Just x" (which is on the list and hence type a)
01:07:11 <merijn> That should work yes
01:07:42 <merijn> Alternatively you could do "(Integral a) => [a] -> Maybe a" which works for any Integer
01:07:56 <merijn> Any Integral, even
01:08:08 <mauke> where "work" means "compile"
01:08:19 <mauke> the results will probably be wrong
01:08:40 <merijn> Where "work" means "according to some arbitrary semantics based on the instance of even for that type" :)
01:08:56 <mauke> oh, it won't compile
01:09:15 <mauke> if it did, it would always return Nothing
01:09:34 <merijn> Oh right, stupid I missed that
01:10:01 <merijn> haus: You do "x < (mineven xs)", which is impossible, since "mineven xs" is type "Maybe Integer"
01:10:36 <merijn> Also, the parenthesis are redundant, function application always binds stronger than operators, so you can also write "x < mineven xs" (which will still be the wrong type, though)
01:11:31 <haus> merijn: would "Just x < mineven xs" work?
01:11:46 <merijn> :t (<)
01:11:47 <lambdabot> forall a. (Ord a) => a -> a -> Bool
01:12:13 <merijn> > Just 1 < Just 2
01:12:13 <lambdabot>   True
01:12:17 <merijn> > Just 1 < Nothing
01:12:18 <lambdabot>   False
01:12:32 <merijn> Yes, but it'll always return Nothing as mauke says :)
01:14:36 <haus> so i need to do something is xs is Nothing and something else if xs is not Nothing
01:15:00 <mauke> :t fmap negate . maximum . (Nothing :) . map negate . filter even
01:15:01 <lambdabot> forall a. (Num a, Integral (Maybe a)) => [Maybe a] -> Maybe a
01:15:15 <mauke> :t fmap negate . maximum . (Nothing :) . map (Just . negate) . filter even
01:15:16 <lambdabot> forall a. (Integral a) => [a] -> Maybe a
01:15:39 <hpaste> merijn annotated “Maybe” with “Maybe (annotation)” at http://hpaste.org/64866#a64867
01:16:05 <merijn> You could use pattern guards (I think my example is correct, but didn't try whether it actually compiles :p)
01:16:14 <mauke> merijn: that looks broken
01:16:32 <mauke> Just requires Just first
01:16:37 <mauke> Nothing will always be returned
01:16:38 <aostiles> does anyone have a recommendation for a Haskell web development framework?
01:16:59 <merijn> mauke: Oh, doh :(
01:17:18 <merijn> You could still use it, but it'd be slightly less nice, I guess
01:17:19 <mauke> > fmap negate . maximum . (Nothing :) . map (Just . negate) . filter even $ [1, 2, 3]
01:17:21 <lambdabot>   Just 2
01:17:37 * shachaf suspects that this solution is not going to help haus.
01:17:40 <merijn> aostiles: Yesod and snap seem fairly popular (the former being more advanced, the latter simpler)
01:17:56 <merijn> There's also happs or happstack or whatever it's called
01:18:01 <mauke> shachaf: decomposition into filter/minimum would still help a lot
01:18:08 <aostiles> thanks, I might try out snap
01:18:34 <shachaf> mauke: Absolutely. It would also not be an n^2 thing that way.
01:18:53 <mauke> that can be fixed by not calling mineven xs twice
01:19:24 <shachaf> What do you mean?
01:19:55 <shachaf> Oh, I misread the code.
01:20:32 <merijn> blah
01:20:38 <merijn> My client died :\
01:20:39 <shachaf> merijn: That goes in the other channel.
01:20:46 <mauke> heh
01:22:46 <t7> when people talk about complexity of algorithms, is does O(1) mean constant time, no matter the length of the constant time?
01:23:04 <JoeyA> Correct.
01:24:11 <hpaste> merijn annotated “Maybe” with “Maybe (annotation) (ugly but works)” at http://hpaste.org/64866#a64868
01:24:31 <merijn> haus: See my new annotation, that actually works. Could probably be nicer, but can't be arsed right now
01:25:01 <Botje> hey, homework questions! :)
01:25:16 <Botje> someone was asking the same thing yesterday
01:25:37 <haus> Botje: same problem?
01:26:01 <Botje> yep
01:26:53 <haus> not surprising...i don't think i'm really being taught haskell
01:28:38 <haus> merijn: thanks for the example, that's helpful
01:29:42 <merijn> haus: If you think on it you can probably device a less ugly implementation that removes the two if/else clauses and replaces them with nicer case/pattern matching
01:29:54 <t7> > sort [10..1]
01:29:55 <lambdabot>   []
01:30:35 <haus> merijn: yea, that's my next plan
01:30:40 <t7> > sortBy compare [10..1]
01:30:41 <lambdabot>   []
01:31:04 <mauke> > [10 .. 1]
01:31:05 <lambdabot>   []
01:31:15 <t7> oh lol
01:32:26 <cheater__> > [1, 2, ... 10]
01:32:27 <lambdabot>   A section must be enclosed in parentheses thus: (... 10)Not in scope: `...'
01:32:31 <cheater__> wat
01:32:34 <cheater__> > [1, 2, .. 10]
01:32:35 <lambdabot>   <no location info>: parse error on input `..'
01:32:38 <cheater__> > [1, 2 .. 10]
01:32:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
01:32:44 <cheater__> always sucked at this
01:33:05 <t7> let mineven = listToMaybe . sort . filter even in mineven [10,9..1]
01:33:10 <t7> > let mineven = listToMaybe . sort . filter even in mineven [10,9..1]
01:33:11 <lambdabot>   Just 2
01:33:33 <mauke> t7: oh. you win.
01:38:23 * hackagebot ghc-mod 1.10.11 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.10.11 (KazuYamamoto)
01:39:41 <t7> i guess i should work on my ast editor then
01:39:49 <t7> as i have eff all today today
01:40:12 <t7> or my C interpreter
01:40:44 <merijn> t7: C interpreter! (so I can more easily test my crap) :p
01:40:45 <t7> no i remember why i stopped working on that. all the number casting rules are really silly and boring
01:41:02 <merijn> awww
01:43:53 <t7> merijn: its really easy with the Language.C stuff in hackage :)
01:44:20 <merijn> t7: What? Writing the interpreter or testing my crap?
01:44:29 <t7> writing an interpreter
01:44:32 * merijn just wants a C REPL :<
01:44:39 <mauke> gdb
01:44:58 <merijn> mauke: That only lets me call stuff my program is linked with, I think
01:50:39 <shachaf> merijn: Write a program that's linked with everything.
01:51:00 <zerax> -lall
01:57:43 <timthelion> Is there some other name that haskell-src goes by? I cannot find any real documentation on it, just the autogenerated stuff in Hackage which is useless.
02:01:38 <paolino> hello, I'm reading http://hackage.haskell.org/packages/archive/hmatrix/0.13.1.0/doc/html/src/Numeric-ContainerBoot.html#Build
02:02:39 <donri> timthelion: does https://github.com/haskell-pkg-janitors/haskell-src/blob/master/examples/hsparser.hs help?
02:02:58 <paolino> It looks like I'm next to understand type families, but I'd like to know if it's a good example for using those
02:03:11 <timthelion> donri: a little :)  But it would be nice to have a tutorial.
02:03:42 <paolino> Or if it is easier to do without ...
02:06:54 <timthelion> donri: ah, yes, this does help. thank you.  I thought you had just linked me to the source...
02:12:23 <Rc43> I have installed gloss/glut/opengl libs with profiling, but program outputs nothing.
02:12:29 <unlink> What is the proper idiom for:  do { x <- someAction ; case x of Nothing -> anotherAction ; Just y -> aThirdAction y }
02:12:36 <paolino> btw, haskell is so nice to learn, even if very slowly for me
02:12:39 <Rc43> Running with `+RTS -p -sstderr -RTS`.
02:13:03 <Rc43> Compiling with `-prof -auto-all -O -rtsopts --make`
02:13:09 <paolino> unlink, x >>= maybe f1 f2
02:13:34 <srhb> :t maybe
02:13:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:13:37 <unlink> paolino: thanks. It just struck me the moment after I sent it.
02:13:48 <unlink> Case analysis is da bomb.
02:13:54 <Rc43> And the code is http://code.ouroborus.net/gloss/gloss-stable/gloss-examples/Lifespan/
02:14:30 <merijn> hmm
02:15:30 <Rc43> hmm, it seems, program should be exited correctly.
02:16:32 <merijn> Is there a function like "IO a -> IOException -> IO a" that takes an action execute as exception handler? Or do I have to write a lambda everytime I use catch?
02:17:09 <mauke> merijn: huh?
02:18:44 <merijn> mauke: Essentially I just want to do "work hnd `catch` (\x -> foo)" where foo is some "IO ()" (print in this case), but then GHC whines about the lack of type for x
02:19:19 <mauke> `catch` (\SomeException{} -> ...)
02:19:22 <earthy> merijn: there's try
02:19:33 <paolino> it depends on type of foo
02:19:40 <mauke> or define a catchAny helper function
02:19:44 <earthy> try :: Exception e => IO a -> IO (Either e a)
02:20:00 <merijn> mauke: That catches anything, though, doesn't it? I only want IOException's, but I'm unsure of what the nice way is to define them
02:20:10 <mauke> oh, I see
02:20:19 <earthy> merijn: you want catchJust
02:20:21 <mauke> merijn: use Prelude.catch
02:20:24 <earthy> or handleJust
02:20:24 <JoeyA> merijn: You want to catch all IO exceptions, or only specific ones?
02:20:59 <paolino> catch' f g = catch f (\_::IOException -> g)
02:21:04 <merijn> JoeyA: It's a socket, so I think there's only "unexpected eof"
02:21:05 <oz__> Data Proposition = Date int  | Vote [(Int,Int)] | Positive [([String],Int)] | Negative [([String],Int)]
02:21:28 <JoeyA> Sockets can have all sorts of IO errors, not just EOF.
02:21:29 <oz__> is this proper grammer?
02:21:50 <JoeyA> e.g. "No error" (because error handling wasn't properly implemented for recv or something)
02:23:06 <JoeyA> @hoogle catchIOError
02:23:06 <lambdabot> No results found
02:23:17 <merijn> JoeyA: Yeah, but in practice my only response to any socket error is going to be "drop the connection and terminate" anyway
02:23:38 <mux> :t ioErrors
02:23:38 <lambdabot> Not in scope: `ioErrors'
02:23:46 <hpaste> shergill pasted “foo (ignore)” at http://hpaste.org/64873
02:24:12 <JoeyA> Right, so just catch IO errors.  Apparently, base 4.4 and up have catchIOError :: IO a -> (IOError -> IO a) -> IO a
02:24:14 <merijn> mauke: Yeah, I'll use Prelude.catch then, that was what I found before but the docs said to use Control.Exception.catch instead
02:24:26 <mauke> fuck 'em
02:25:06 <dobblego> what is the name of the extension if I wish to annotate local functions with type variables appearing in the outer function?
02:25:07 <JoeyA> If you need to support base < 4.4 (i.e. GHC < 7.2, I think), you can define it manually: catchIOError :: IO a -> (IOError -> IO a) -> IO a; catchIOError = E.catch
02:25:23 <JoeyA> ScopedTypeVariables
02:25:29 <dobblego> ah thanks
02:25:32 <mauke> JoeyA: or I could just use Prelude.catch
02:25:36 <mauke> which is exactly that
02:25:56 <JoeyA> Sounds like a good idea.
02:27:01 <mux> using Prelude.catch issues a warning though, right?
02:27:09 <mauke> does it?
02:27:15 <merijn> deprecation warning
02:27:24 <mux>     Warning: In the use of `catch'
02:27:24 <mux>              (imported from Prelude, but defined in System.IO.Error):
02:27:24 <mux>              Deprecated: "Please use the new exceptions variant, Control.Exception.catch"
02:27:35 <mauke> that is stupid
02:27:50 <dobblego> Re: ScopedTypeVariables http://paste.pocoo.org/show/561746/ what am I doing wrong?
02:28:00 <mauke> dobblego: missing forall
02:28:08 <dobblego> forall a. ?
02:28:28 <JoeyA> dobblego: forall f. Monad f => f Int
02:28:44 <dobblego> oh thanks
02:28:51 <mauke> someone should file a bug for that deprecation warning
02:29:11 <mauke> Prelude.catch is in H2010
02:29:12 <JoeyA> forall makes type variables cascade.
02:29:22 <dobblego> yep got it
02:30:11 <paolino> prelude is scripting
02:39:24 <paolino> Is it correct thet tpe families help to avoid some multi parameter class cases ?
02:39:55 <shachaf> Some cases, yes.
02:42:47 <paolino> Are they more basic then multiparameter classes, or it has more to do with fundeps ?
02:43:26 <ivanm> IIRC, there are a *few* things you can do with MPTCs + FDs that you can't do with TFs, due to extra safety in the latter
02:43:32 <ivanm> though theoretically they're equivalent
02:44:00 <paolino> And , are there applications without single parameter classes ?
02:44:15 <ivanm> ummmm.... how is that possible?
02:44:24 <paolino> Applications for TF I mean
02:44:32 <ivanm> oh
02:44:38 <ivanm> you mean MPTCs used with TFs ?
02:44:48 <ivanm> I've done so in the past because superclass constraints weren't available
02:45:02 <oz__> hey guys, I have go here a bucket of noob questions, I'm asking them because I'm writing a really short program, which is almost finished, and reading the book will take a lot of time. It would be great for me if anyone here would like to answer some of them. I'll try to be clear. if this is not the place for this stuff, than sorry
02:45:06 <ivanm> I can see some matchup between different kinds using MPTCs
02:45:19 <ivanm> oz__: depends on the questions...
02:45:36 <Botje> oz__: as long as the questions aren't 'can someone write X for me', we're happy to help.
02:46:07 <Botje> oz__: that said, reading 'the book' will help you further than us patching the holes in your knowledge will
02:46:12 <paolino> ivanm, I mean usefulness of TFs without any class using them in its methods
02:46:35 <ivanm> dunno
02:46:43 <ivanm> you usually see them used in some way with classes
02:47:41 <oz__> like.. how do I write a function, that removes the first member of a list of strings?
02:47:57 <oz__> I mean, returns the said list of strings with its head cut
02:48:19 <ivanm> in that case, read the book
02:48:30 <shachaf> I think most introductions to Haskell cover that exact function, as well as how to write it.
02:48:32 <srhb> How do I send EOF to my inferior ghci process in Emacs?
02:48:33 <ivanm> because that is so basic and fundamental that us just telling you how won't help
02:48:44 <ivanm> srhb: to kill something? C-c C-c
02:48:53 <srhb> ivanm: No, to end stdin
02:48:54 <paolino> ivanm, the role of classes being using them as indexes to set of types , so the class is less parametric ?
02:48:56 <ivanm> or C-c C-d to send an actual EOF character I think
02:48:56 <shachaf> srhb: Ask in #emacs
02:48:59 <srhb> If that even makes sense.
02:49:00 <oz__> okay, sorry
02:49:04 <ivanm> shachaf: it has to do with the ghci process stuff
02:49:13 <srhb> shachaf: I'm sure people know more about it here, but thanks.
02:49:18 <ivanm> paolino: not following
02:49:20 <shachaf> ivanm: Oh, it does?
02:49:40 <shachaf> I would assume that emacs has a generic "inferior process" thing with the ability to send EOFs.
02:49:48 <ivanm> shachaf: well, specifically the comint mode it's using; I wouldn't know if people in #emacs would know what the inferior ghci process in emacs even means :p
02:50:05 <ivanm> shachaf: if you ran ghci inside a term mode, it would be different I think
02:50:19 <srhb> Yes, then ^D would work I think
02:50:59 <tdammers> oz__: some books recommend reading the entire Prelude interface, top-to-bottom
02:51:06 <tdammers> not a bad idea if you ask me
02:51:54 <ivanm> srhb: but I think you need C-c first to let it accept C-d
02:52:55 <srhb> ivanm: You are correct. It just ignores it though, even though it does say send eof. Weird.
02:53:07 <paolino> ivanm, each type family can project each involved type instance for a class to another type avoiding it to appear as parameter. So each family can take down the parameter count of a class
02:53:18 <ivanm> OK...
02:53:52 <oz__> tdammer: you mean reading the basic library?
02:54:46 <oz__> okay, found it http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
02:58:26 * hackagebot nlp-scores 0.4.0 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.4.0 (GrzegorzChrupala)
03:05:45 <ChristianS> oz__: the Prelude is just one module from the base lib.
03:06:48 <ChristianS> oz__: actually i found it useful to first read through the whole apidocs of the base package to find out what's actually there -- esp. the Prelude and many of the Data.* modules are important.
03:21:14 <tdammers> ChristianS: true, but I'd argue that the Prelude is the most important
03:21:36 <yitz> Data.List is pretty high up there too
03:22:20 <tdammers> I found that once I'd read through the Prelude, I noticed that a bunch of list-related stuff is missing, and I knew about the existence of Data.List
03:30:23 <ivanm> I think I've almost convinced myself that one reason why attoparsec is so fast is that it uses strict bytestrings even when supposedly parsing lazy bytestrings
03:32:04 <rostayob> ivanm: attoparsec is about parsing strict bytestrings
03:32:36 <ivanm> rostayob: well, yes, but even the lazy module uses the bytestring .Internal module to get the constructor and individually parsing each chunk
03:32:45 <ivanm> and I'm interested in parsing rather large binary data
03:33:05 <ivanm> so far, when using lazy bytestrings, attoparsec is about 2.5x as fast as my customised and tuned polyparse parser
03:33:32 <rostayob> ivanm: well attoparsec way of parsing binary data is mainly through reading manually the strict bytestrings in chunks
03:33:39 <rostayob> i didn't even know there was a "lazy" module
03:33:45 <ivanm> there is
03:34:04 <ivanm> took me a while to realise that it was actually using the chunks
03:34:19 <ivanm> one problem with that is that combinators such as takeWhile return strict bytestrings
03:34:28 <ivanm> (without considering that they might be too small...)
03:35:33 <rostayob> ivanm: well yeah makes sense
03:36:30 <ivanm> when I write a strict-bytestring polyparse parser, the times are much closer together
03:37:00 <ivanm> though it's difficult to tell because the sample data that I'm using is either much smaller or much bigger (in terms of file size) than the maximum size of a strict bytestring
03:37:11 <rostayob> I guess that's the overhead with lazy bytestrings. if there was no overhead, strict bytestrings would be useless
03:37:24 <ivanm> no, I'm using strict for both
03:37:51 <ivanm> just so that I can determine if the strict-based parsing is indeed what makes the difference
03:38:26 <rostayob> ivanm: no I was referring to polyparse being slower when using lazy bytestrings
03:38:34 <ivanm> ahhh, right
03:39:17 <ivanm> I'm currently getting about 1.17ms vs 1.33ms for strict-based parsing
03:40:00 <arthur_honeynet> hi folks. I have a question about compiling the unix package
03:40:22 <arthur_honeynet> when compiling with ghc 7.0.4 (from .tgz) on Linux (Mint 12), I get the error
03:40:34 <arthur_honeynet> System/Posix/Signals.hsc:1:49: Unsupported extension: CApiFFI
03:40:37 <arthur_honeynet> any ideas?
03:41:07 <ivanm> which version of the unix package?
03:41:19 <t7> is compiling lambda calculus to ski calculus gonna be outrageously hard?
03:41:21 <ivanm> I presume you're using cabal-install?
03:41:39 <arthur_honeynet> unix 2.5.1.0
03:41:45 <t7> maybe i can brute force it
03:42:01 <arthur_honeynet> yes, cabal from haskell-platform, compiled from the latest using that version of ghc
03:43:08 <ivanm> arthur_honeynet: I get the same error
03:43:17 <ivanm> looks like it only works on newer ghc (I also have 7.0.4)
03:43:50 <arthur_honeynet> all this just to compile yeganesh for xmonad :)
03:44:11 <arthur_honeynet> which ghc version would I need to move to?
03:44:44 <ivanm> arthur_honeynet: get an older version of yeganesh?
03:45:02 * ivanm tries to remember what Daniel Wagner's nick on IRC is
03:45:14 <ChristianS> arthur_honeynet: hm, to me this sounds like it may be a problem with your c compiler rather than ghc?
03:45:14 <gienah> sed -e 's@unix >= 2.5@unix >= 2.4@' -i "yeganesh.cabal"
03:45:19 <ivanm> duh, dmwit
03:45:26 <ivanm> ChristianS: it isn't
03:45:51 <ivanm> dmwit: ^^ I think you can drop the base-3 support from yeganesh; it seems your dep on unix-2.5 makes it only build on 7.2+
03:46:00 <arthur_honeynet> my yeganesh.cabel says "unix >= 2.5"
03:46:02 <rostayob> arthur_honeynet: (use i3!)
03:46:15 <ivanm> rostayob: why?
03:46:31 <ivanm> arthur_honeynet: the shell prompt inbuilt into xmonad-contrib is rather nice
03:46:38 <ivanm> I've stopped using dmenu+yeganesh for it
03:47:06 <rostayob> ivanm: because its defaults are much better than xmonad imho
03:47:13 <arthur_honeynet> ivanm: well, that would work. What's it called?
03:47:17 <ivanm> rostayob: but who uses the defaults?
03:47:18 <rostayob> you can probably bring xmonad to be like i3 but it's a pain
03:47:23 <rostayob> ivanm: me
03:47:26 <ivanm> arthur_honeynet: XMonad.Prompt.Shell or something
03:47:30 <ivanm> rostayob: bah
03:47:35 <ivanm> customisation is the whole point!
03:47:39 <rostayob> and it comes with a traybar, a dzen-like thing, a workspace switcher
03:47:49 <rostayob> ivanm: customization for the saze of customization is a waste of time
03:48:22 <ivanm> it's not for the *sake* of customisation; it's to get the environment working as you want it
03:48:25 <rostayob> also, i3 handles float in a sane way
03:48:28 <ivanm> if the defaults for i3 suit you, fair enough
03:48:36 <ivanm> anyway, I need to hit the sack
03:48:36 <ivanm> g'night all!
03:48:40 <rostayob> ivanm: they suit most people I know better than xmonad
03:48:44 <rostayob> ivanm: goodnight :)
03:50:42 <arthur_honeynet> ok fixed.
03:50:54 <arthur_honeynet> for the record, I had to go back to yeganesh 2.2.1 to remove the
03:51:01 <arthur_honeynet> dependency on unix >= 2.5
03:51:44 <arthur_honeynet> ivanm: thanks
03:53:34 <arthur_honeynet> /quit
04:03:24 <t7> @pl \x -> x y z
04:03:24 <lambdabot> flip ($ y) z
04:08:17 <t7> can a lambda calculus term be made point free?
04:09:48 <Jaak> S K I
04:10:25 <Saizan> t7: http://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis
04:11:27 <grondilu> which one should a beginner install:  ghc or hugs?
04:11:27 <mauke> ghc
04:11:27 <grondilu> (that was fast :)
04:11:27 <mauke> preflex: version
04:11:27 <grondilu> so ghc it is.
04:11:27 <mauke> wtf
04:11:27 <mauke> > ()
04:11:28 <lambdabot>   ()
04:11:29 <preflex>  3.317
04:11:46 <mauke> oh wow
04:11:48 <mauke> crazy lag
04:19:11 <nlogax> trying to upgrade ghc on arch linux, i get ghc: /usr/share/doc/ghc/html/libraries/doc-index-126.html exists in filesystem. can i just remove doc/ghc ?
04:21:47 <drmegahertz> nlogax: yep, shouldn't be a problem, it'll get reinstalled anyways
04:24:26 <merijn> @pl \x -> f x >>= g
04:24:26 <lambdabot> (g =<<) . f
04:24:42 <blackdog> feels like there must be a standard operator for this:
04:24:43 <blackdog> https://gist.github.com/1986002
04:25:15 <SecretCarrot> github.....
04:25:31 <blackdog> intuitively: keep running the action until it returns Nothing
04:25:41 <blackdog> using the result of the Just as seed for the next iteration
04:26:12 <mysticc> @hoogle serialize
04:26:12 <lambdabot> package genericserialize
04:26:12 <lambdabot> package graph-serialize
04:26:13 <lambdabot> package gtk-serialized-event
04:26:18 <danr> @hoogle unfoldM
04:26:19 <lambdabot> No results found
04:27:24 <danr> blackdog: http://hackage.haskell.org/packages/archive/monad-loops/0.3/doc/html/Control-Monad-Loops.html#v:unfoldrM
04:28:45 <blackdog> danr: so i'd have to change the function i pass in to be a pair
04:28:50 <shachaf> danr: That's close, except it collects a list of values rather than the final value.
04:28:51 <blackdog> return a pair, rather.
04:29:13 <danr> shachaf: blackdog: yeah it just struck me that it isn't exactly what we wanted
04:29:19 * blackdog fully recognises the irony of trying to optimise a single line of code
04:29:29 <shachaf> blackdog: You could submit it to monad-loops!
04:29:58 <blackdog> heh, perhaps
04:30:02 <danr> there's whileJust :: m (Maybe a) -> (a -> m b) -> m [b]
04:30:15 <shachaf> danr: Yes, that's used in blackdog's @paste. :-)
04:30:29 <blackdog> shachaf: actually, i called it whileJust
04:30:34 <blackdog> just a recursive call
04:30:39 <danr> shachaf: no, that whileJust was from monad-loops
04:31:02 <shachaf> Oh, wait.
04:31:05 <blackdog> danr: i don't think that's quite right - it doesn't feed the result of the action back into the next iteration.
04:31:06 * shachaf misread, clearly.
04:31:27 <srhb> Am I misunderstanding something: Should getContents not end on \EOT?
04:31:33 <blackdog> i shouldn't have named it something from monad-loops. naming is hard - if it were precise, it'd just be the code, right?:)
04:31:36 <danr> blackdog: i vouch for shachaf's suggestion to patch monad-loops :)
04:32:02 <danr> heh, `iterateJust'?
04:32:11 <danr> or `justIterate'
04:33:29 <t7> T[λx.λy.E] => T[λx.T[λy.E]]    what does this mean
04:33:48 <t7> its the only rule i cant read
04:34:10 <shachaf> t7: It means what it says.
04:34:25 <t7> yeah but i have different types for E and T[]
04:34:26 <shachaf> Apply T on the inner part first, and then you can add on the lambda and apply it on the outer part.
04:34:34 <qanomaly> heya
04:34:39 <shachaf> t7: What do you mean?
04:34:40 <qanomaly> i've got a question about ghci
04:34:49 <t7> well t[] returns ski calc
04:34:52 <t7> E is lambda calc
04:35:01 <qanomaly> is it possible to define multiple patterns interactively?
04:35:08 <shachaf> T[] takes a lambda expression that might also use combinators like SKI.
04:35:09 <danr> t7: the rules 5-6 are described in a later section
04:35:19 <shachaf> qanomaly: let f ... = ...; f ... = ...
04:36:42 <qanomaly> already tried that, throws a parse error :/
04:36:49 <srhb> Aha, it works when I compile it. Why does getContents >>= print fail to break on ctrl-d in ghci, but it works when I compile the program?
04:37:10 <qanomaly> example: Prelude> let factorial 0 = 1;
04:37:10 <qanomaly> Prelude> factorial n = n*factorial(n-1)
04:37:21 <qanomaly> <interactive>:1:13: parse error on input `='
04:37:24 <mauke> qanomaly: why did you hit enter?
04:37:31 <qanomaly> after the ;
04:37:37 <merijn> @hoogle (a,b,c) -> (c -> d) -> (a,b,d)
04:37:37 <lambdabot> No results found
04:38:01 <shachaf> qanomaly: Read mauke's question again. :-)
04:38:20 <qanomaly> damn, i read 'when', thanks :D
04:38:30 <qanomaly> okay, that clarifies it
04:38:32 <qanomaly> thanks!
04:38:33 <shachaf> t7: (I understand your complaint and don't really have a good response to it.)
04:38:57 <t7> hmm i will have a think
04:39:07 <mauke> ski is a subset of lambda
04:40:35 <yitz> merijn: you can name it "flip third"
04:40:35 <t7> it has 1 less term and adds 3 more
04:47:08 <t7> i guess i have to make a whole new data type for Rule 5
04:47:11 <t7> fuck you rule 5
04:48:11 <mauke> .oO( rule 34 )
04:48:23 <merijn> @hoogle IO Bool -> IO ()
04:48:23 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
04:48:23 <lambdabot> Network.BSD setHostEntry :: Bool -> IO ()
04:48:23 <lambdabot> Network.BSD setNetworkEntry :: Bool -> IO ()
04:48:49 <merijn> @hoogle IO a -> (a -> Bool) -> IO ()
04:48:50 <lambdabot> Foreign.Marshal.Error throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
04:48:50 <lambdabot> Foreign.C.Error throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
04:48:50 <lambdabot> Foreign.C.Error throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
04:49:18 <merijn> Hmm, I feel there should be a "repeat until condition holds" combinator, but Hoogle isn't turning anything up :\
04:50:20 <shachaf> (`whileM` return ())
04:50:51 <shachaf> untilM_ (return ()), rather.
04:52:47 <shachaf> Or iterateUntil id
04:54:32 <merijn> shachaf: Ah, yeah. I want iterateUntil. I wonder why that wasn't found
04:54:52 <shachaf> I doubt Hoogle searches it.
04:56:08 <CQ> hello, I need to write a parser, and am choosing between haskell and Perls parse::RecDescent ... its for a fairly straightforward grammar, with the result going into a DB (postgres) for further mangling and analysis
04:57:54 <aristid> should i add example programs (which just show how to use the library) to my library's cabal file? if so, how?
04:58:40 <CQ> any recommendations or pointers to good tutorials?
04:59:05 <merijn> CQ: For haskell or for haskell parser libraries?
04:59:25 <t7> every function can be represented with one combinator ...
04:59:30 <srhb> CQ: If you go to #haskell and ask whether to use Perl or Haskell, guess what the answer will be. :-)
04:59:48 <CQ> srhb: I had figured that, but the _why_ would be interesting ;)
05:00:01 <srhb> CQ: The why is probably: Parsec is awesome.
05:00:22 <CQ> anything better than http://legacy.cs.uu.nl/daan/download/parsec/parsec.html online then?
05:00:41 <merijn> I think Real World Haskell has a chapter on parsec too
05:00:45 <merijn> @where rwh
05:00:46 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:00:59 <tdammers> ^ yes.
05:01:13 <CQ> Ive read parts of it, need to go back to it then.
05:02:19 <tdammers> it doesn't cover everything, it's definitely worth looking into parsec's documentation after reading RWH, but as an introduction, it is pretty good
05:08:16 <CQ> well, this sounds like teh lattest excuse I need to finally learn haskell then ;)
05:08:29 <merijn> What is the more canonical style? "(`elem` l)" or "flip elem l"
05:08:42 * hackagebot aws 0.3.2 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.3.2 (AristidBreitkreuz)
05:09:24 <aristid> i decided to use Extra-source-files for the example :P
05:11:18 <mysticc> I have directory System/A and Files as B.hs and C.hs .. B is module System.A.B and C is module System.A.C .. now when I write import System.A.B in C it says can not find module .. ?
05:12:43 <hpaste> erus` pasted “lambda to ski” at http://hpaste.org/64875
05:13:02 <t7> that algorithm is beautifully concise
05:14:58 <yitz> merijn: it is entirely a matter of your personal taste
05:17:25 <t7> does s(kk)i = k ?
05:17:49 <dobblego> @type (<*>) (const const) id
05:17:50 <lambdabot> forall b b1. b1 -> b -> b1
05:17:57 <dobblego> yes
05:18:15 <t7> i think i need a reduction pass
05:21:02 <shachaf> t7 is erus`?
05:21:08 <t7> yeah
05:21:14 <shachaf> Why can't people just stick with one nick?
05:21:21 * shachaf sighs.
05:21:32 <t7> because i wanted a two character nick :3
05:21:42 <t7> (i wanted 1 character)
05:22:17 <cgroza> Is there a library that parses math expressions?
05:23:02 <mauke> hah, "math expressions"
05:23:08 <mauke> math is unparseable
05:23:47 <parcs`> even wolfram alpha sucks at it
05:23:53 <merijn> I think he just means arithmetic?
05:24:02 <Axman6> and that shit's got heaps of processing power yo
05:24:23 <cgroza> merijn: and some algebra too.
05:24:28 <t7> I used the C language parser
05:24:33 <t7> probably overkill
05:24:48 <Axman6> cgroza: well, ghc can parse them, you might be able to find an easy way to get ghc to parse maths expressions into an AST you've written
05:25:22 <CQ> is a two-character nick like a three-digit slashdot ID? ;)
05:25:57 <merijn> CQ: Yes, in the sense that no one sensible cares about it
05:26:00 <mysticc> I have System.A and files B.hs and C.hs .. My cabal install succeeds .. but when I do ghci B.hs .. I get error "Could not find module System.A.C" ??
05:26:32 <cgroza> You see, I have written some code to solve some equations. It works well, but I have to give it the input by building the datatypes. I would need somethign that could take a string and return it in the form that I need.
05:26:49 <yitz> mysticc: cd ../..
05:27:03 <Axman6> mysticc: what's in B.hs?
05:27:04 <yitz> mysticc: then do ghci System.A.B
05:27:11 <t7> now i have my SKI combinator calculus i can super compile it to C
05:27:13 <mysticc> yitz: Huh .. just found out ..
05:27:19 <t7> for the fastest code in the world
05:27:44 <Axman6> t7: dood, it'll be faster if you use the C to produce assembly
05:27:50 <yitz> t7: is it a lazyk compiler, or an unlambda compiler?
05:27:52 <Axman6> thish writes direct machine code
05:27:56 <Axman6> which* (wtf?)
05:29:47 <t7> it just translates lambda calc to ski calc
05:32:27 <Axman6> t7: i had to write a program that did that in both directions for an assignment last year, it was quite fun
05:32:40 <Axman6> well, it only _had_ to go one direction, but i wanted to make it go both directions
05:33:10 <t7> SKI to lambda calc should be simple
05:33:17 <t7> but i guess you reduced it and stuff?
05:33:23 <Axman6> yeah
05:33:54 <Axman6> also wrote something that could execute both (and allowed a language that was a mix of the two)
05:34:15 <Axman6> i just had an AST which I called SKIL, SKI with lambdas =)
05:34:31 <Axman6> i lost marks for having them both use the same type :(
05:34:56 <t7> I can only convert SKI -> LC by using an intermediate AST
05:35:01 <t7> i can't see another way
05:35:17 <t7> after conversion i can convert to another datatype
05:35:22 <t7> but god damn rule 5 man
05:35:30 <t7> and 6 to be fair
05:36:43 <Axman6> T[λx.E]             => (K T[E]) that one?
05:37:16 <t7> T[\x.\y.e] => T[\x.T[\y.e]]
05:38:04 <Axman6> ah, yeah that was the reason I had to have the combined AST I think. apparently it's easy to do without it, but it never bothered to figure out how
05:39:35 <Axman6> removeLams (Lam x (Lam y e)) | x `free` e = do { inner <- removeLams (Lam y e); removeLams (Lam x inner) } is how i did it (using the Either monad)
05:40:08 <Axman6> which, funnily enough, i never produce Left values anywhere =)
05:40:52 <Axman6> hmm, i think my free function is broken, heh
05:41:55 <Saizan> you could have T go from LC to LC, where S K I are just free variables
05:43:22 <rostayob> Axman6: more than lambdas I'd add combinators to SKI
05:43:42 <Axman6> which combinators?
05:43:43 <rostayob> I mean you can write a little term rewriting system and then encode SKI in it
05:43:49 <rostayob> Axman6: user definable combinators
05:43:55 <hpaste> paolino pasted “TFs and annotations” at http://hpaste.org/64877
05:44:19 <Axman6> rostayob: the purpose of the assignment wasn't to make something that was nice to use though =)
05:44:46 <paolino> I tried the code pasted and I get wrong number of argument
05:44:53 <paolino> in the instance
05:44:56 <rostayob> Axman6: well but combinators make more sense (ehe) in the context of combinatorial logic
05:45:33 <t7> Saizan: i thought about that, but what if i allready have variables with the same name
05:45:47 <Axman6> paolino: doesn't (a->a) have sort *?
05:45:47 <paolino> how  *->* should be used in the family declarations ?
05:46:53 <paolino> I think it has kind *, but I'm confused actually
05:47:12 <rostayob> (a -> a) has kind *.
05:48:07 <paolino> with type family C :: * I have the same error
05:48:37 <paolino> so I'm confused
05:48:38 <rostayob> paolino: yes because you don't give kindness to the type family itself but to the parameters
05:48:48 <rostayob> e.g. type family C (a :: *) or whatever
05:49:16 <rostayob> what you wrote doesn't make much sense
05:49:27 <paolino> so I must name them all ?
05:49:52 <paolino> I thought annotations were ther to avoid naming them
05:50:30 <rostayob> I'm not sure what you need to do, maybe you want 'type family C (a :: *) :: *'
05:50:41 <rostayob> no sorry, type family C (a :: *) :: * -> *
05:51:15 <rostayob> paolino: no, what I said before :P
05:51:24 <rostayob> e.g.
05:51:26 <rostayob> type family C (a :: *) :: *
05:51:28 <rostayob> type instance C (a -> a) = a
05:51:59 <rostayob> you can also omit the kind annotations here
05:52:04 <paolino> isn't (a :: *) :: * equivalent to * -> *
05:52:09 <paolino> ?
05:52:24 <rostayob> paolino: yes but I'm not sure you can do that
05:52:37 <paolino> it's in the docs ....
05:52:49 <paolino> or I misinterpreted them
05:52:53 <pozic> paolino: isn't that supposed to be ?? ?
05:52:56 <rostayob> paolino: where?
05:53:02 <Saizan> type family C a :: * means that C is indexed by a and return a type of kind *
05:53:11 <rostayob> paolino: ah,
05:53:21 <rostayob> "Named arguments can also be given explicit kind signatures if needed. Just as with [http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html GADT declarations] named arguments are entirely optional, so that we can declare Array alternatively with ..."
05:53:26 <Saizan> type family C :: * -> *; means that C is not indexed by anything and return a type of kind * -> *
05:54:18 <paolino> Saizan, that is how to interpret that paragraph ?
05:54:24 <rostayob> Saizan: the GHC manual seems to suggest that you can write that (section 7.7.1.1)
05:54:27 <paolino> with the Array example ?
05:56:15 <Saizan> i've not read the manual, this is how it works though
05:57:45 <rostayob> paolino: I see where you're coming from anyways
05:59:29 <paolino> Saizan : can you please make an example of instance for C in the * -> * case ?
06:00:10 <Saizan> paolino: type instance C = Maybe
06:00:13 <rostayob> paolino: type instance C = Maybe
06:00:20 <rostayob> oh well.
06:00:30 <Saizan> and you can have only one instance for C in this case
06:00:45 <paolino> ah
06:01:00 <rostayob> however I don't see why it has to work that way, why doesn't it work like value-level functions?
06:01:18 <rostayob> with no "arguments" and "return type", but just a kind signature
06:02:52 <paolino> I guess the Array :: * -> * in the example is supposed to have more than one
06:03:37 <rostayob> paolino: more than one what?
06:03:43 <paolino> instance
06:04:10 <rostayob> well yeah they're implying that 'data family Array e' is equivalent to 'data family Array :: * -> *'
06:04:44 <rostayob> but I think it'd make even more sense to have just the second notation, just like value-level functions
06:05:06 <paolino> maybe it's different for data family ...
06:05:31 <Saizan> yes, it's likely different for data families
06:06:26 <Saizan> the whole point of keeping track of the difference between indexes and other arguments for type families is that they are guaranteed injective only on the latters
06:06:37 <Saizan> while data families are injective for all of them
06:06:46 <rostayob> ah right
06:07:41 <merijn> Hmm, I find myself wanting a type like "type Foo = String -> IO Foo" (i.e. a function that takes a string, does some IO and returns a new function to run). Any suggestions how to do this that are not as obviously broken as this one?
06:07:44 <rostayob> right right
06:07:58 <Saizan> merijn: newtype
06:08:03 <rostayob> merijn: you can't have recursive type synonyms, use newtype
06:08:49 <merijn> That was less complicated then I expected it to be...
06:11:30 <rostayob> paolino: yeah basically you can't do that for the same reason taht you can't partially apply type synonyms
06:11:44 <rostayob> you could do all sorts of type level computation in that case
06:12:05 <LostPW> hello
06:12:07 <merijn> Saizan, rostayob: That does something, but not what I want. Because I need to convert from newtype Foo back to an actual function when I want to use it...
06:12:29 <rostayob> merijn: you have to
06:12:30 <merijn> I guess what I'm trying to do is CPS IO actions?
06:13:06 <paolino> :t join
06:13:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:13:10 <merijn> rostayob: "I have to" what? Convert it? I understand, but I don't know all
06:13:11 <rostayob> you can't express a function of that type without a newtype (btw what you're doing is a special case of Automaton)
06:13:12 <LostPW> can anybody tell me where is the different between a definition: Num a => a->a->a for (+) or a->b->a for (+)
06:13:41 <rostayob> merijn: http://hackage.haskell.org/packages/archive/arrows/0.4.4.0/doc/html/Control-Arrow-Transformer-Automaton.html
06:13:45 <merijn> LostPW: All a's in the former must be the same (i.e. the sametype)
06:14:05 <merijn> LostPW: Whereas the latter could have different types for a and b
06:14:09 <rostayob> merijn: you need a newtype to express that recursive type. then to use it you need to "unpack it" and apply it each time
06:14:17 <paolino> LostPW, (+) is defined on 2 arguments of the same type
06:14:19 <nikkk> exit
06:14:38 <paolino> and prduce same type argument
06:15:01 <paolino> Int -> Int -> Int
06:15:17 <paolino> cannot sum Int and Float with (+)
06:15:18 <merijn> rostayob: Yes, but I meant that I have no clue how to unpack newtype's. Just pattern match on the constructor name?
06:15:23 <yitz> merijn: you would need some outside way of deciding when to stop running those functions. they don't return information besides the side effects.
06:15:28 <LostPW> ok but in foldr you can use (+) as a funktion from a->b->b but the type of (+) is Num a=> a->a->a
06:15:48 <paolino> because b can be a
06:15:58 <rostayob> j2jxx: yeah
06:16:00 <rostayob> oops
06:16:02 <rostayob> merijn: yes
06:16:05 <merijn> yitz: I plan to just run until I call "killThread myThreadid" when i want to exit
06:16:23 <yitz> merijn: that ought to stop it. :)
06:16:25 <rostayob> merijn: or you can have 'newtype Foo = Foo {unFoo :: String -> IO Foo}'
06:16:47 <LostPW> ok thanks paolino ....it makes sense ... i had an exam in the next week and this was something that wasnt clear ... thank you very much
06:17:38 <merijn> yitz: I'm writing a thread that handles input from a socket, but I don't want to pass the socket handle throughout all my functions. I figured I could avoid that by defining a handler that just takes a string and returns the next handler and have the top level deal with reading from the handle
06:18:00 <paolino> LostPW, applying foldr to (+) is legal because (+) can match the broader foldr request
06:18:40 <mux> merijn: in the past, I've been using the Reader monad to avoid having to pass Handle's around, I'm not sure that's the best way to go about it, but it sure works
06:18:56 <rostayob> merijn: and again, what you have is 'Automaton (Kleisli IO) String ()'
06:19:05 <merijn> mux: Yeah, I considered that too. But this way seemed cleaner
06:19:32 <rostayob> merijn: which you can run with 'runAutomaton'
06:19:38 <merijn> rostayob: Yeah, I looked at the docs you linked. But I don't think my PLT skillz are l33t enough (yet) for that level of abstraction
06:19:57 <merijn> Because the types there just leave me sort of lost scratching my head
06:20:20 <rostayob> merijn: yeah that's understandable if you haven't met Arrows before :D
06:20:25 <merijn> I can always take a look when I'm more at home with the concrete implementation
06:20:41 <rostayob> it'd be clearer if they had a (>~) instead of an 'a'
06:21:13 <merijn> Yeah, I've met ***, &&& and friends which suffer the same problem
06:21:35 <merijn> But I don't really understand them outside of Arrow (->)
06:22:03 <paolino> :t return (return 4) >>= id
06:22:04 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
06:24:04 <rostayob> merijn: you can read "Programming with Arrows" if you're interested
06:39:49 <danr> if beta reduction is used "backwards", as in going from e[x/y] to (\x.e) y, can it be called beta expansion?
06:40:40 <rostayob> danr: those two thigns are not equivalent.
06:40:48 <rostayob> well ok
06:40:59 <danr> y \notin fv(e)
06:41:02 <danr> i should add :)
06:41:21 <rostayob> anyways, I guess you could
06:41:35 <danr> Eh, also I meant e[y/x]
06:41:52 <danr> rostayob: did you ever encounter the term "beta expansion"?
06:42:11 <rostayob> danr: nope
06:42:41 <Saizan> danr: lambda-lifting is a special case
06:45:35 <danr> Saizan: Of course. If (\x.e) is lambda lifted, and say y is the only FV in e, then we replace (\x.e) with (\y.\x.e) y and then (\y.\x.e) can be lifted out. The replacement step can be thought of a "beta-expansion". Is that what you had in mind?
06:47:03 <danr> (I guess it's reasonable to guess that x is a free variable in e too)
06:49:05 <Saizan> danr: not sure why you start with (\x.e) rather than just e, but that's what i was thinking
06:50:23 <danr> Saizan: When you say it, I'm not sure either :)
06:50:28 <danr> Thank you!
06:52:22 <Na-Fiann> I want to use Data.Map in a small program, that takes a list and returns a modified list with one element changed if possible, and exits if the value isn't in the map, but I'm not sure how to do this... example would be (incorrect code): change myMap (a:b:c:d) = (a:b: lookup myMap c:d)
06:52:23 <lambdabot> Na-Fiann: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:53:58 <merijn> Na-Fiann: That should work (assuming the type of values in myMap is the same as the type of keys)
06:54:11 <merijn> Actually
06:54:25 <Na-Fiann> merijn, no the value is inside this Maybe thing
06:54:32 <merijn> You would probably need to do "case lookup myMap c of"
06:54:43 <Na-Fiann> *sorry, don't know the official name
06:54:48 <Na-Fiann> oooh
06:54:57 <merijn> And then pattern match on Just/Nothing (return new list on Just, do something else with Nothing)
06:55:31 <merijn> For example, throw an IOError to exit/crash the application
06:59:28 <Na-Fiann> merijn, thanks, I think that works
07:11:32 <ChristianS> Na-Fiann: did you get my paste and my messages?
07:15:00 <Na-Fiann> ChristianS, yeah thanks I just read them
07:15:40 <Na-Fiann> I've looked up you version, trying to understand why it's faster :)
07:15:41 <t7> @hoogle a -> b -> b
07:15:41 <lambdabot> Prelude seq :: a -> b -> b
07:15:41 <lambdabot> GHC.Conc.Sync par :: a -> b -> b
07:15:41 <lambdabot> GHC.Conc par :: a -> b -> b
07:16:04 <t7> i mix up const and seq
07:16:09 <azaq23> @type const
07:16:10 <lambdabot> forall a b. a -> b -> a
07:16:13 <t7> seq returns the _seq_ond
07:19:00 * hackagebot snaplet-recaptcha 0.1 - A ReCAPTCHA verification snaplet with connection sharing.  http://hackage.haskell.org/package/snaplet-recaptcha-0.1 (LarsPetersen)
07:21:33 <ChristianS> Na-Fiann: actually, i think the main reason your version was slow was the trim function which twice reverses the bytestring. i replaced it with  trimLeft = B.dropWhile isSpace  which is sufficient for your purposes and the resulting program was (i think) about as fast as my version.
07:22:14 <ChristianS> Na-Fiann: my other changes weren't for speed but for readability since i found your sents function quite hard to understand.
07:23:53 <Na-Fiann> ChristianS, yeah I have trouble understanding it myself now -_-
07:24:03 <ChristianS> :-)
07:25:44 <Na-Fiann> I suspect that everything I write in haskell will be a bit muddled until I understand the language better
07:27:38 <nand`> Na-Fiann: in what you pasted earlier you can just use fromJust if you want the function to error if it wasn't found
07:29:01 * hackagebot download-curl 0.1.4 - High-level file download based on URLs  http://hackage.haskell.org/package/download-curl-0.1.4 (SoenkeHahn)
07:29:17 <Na-Fiann> nand`, thanks, I prefer this version though, slightly better error handling
07:30:02 <ChristianS> Na-Fiann: yes, haskell takes some getting used to. but it's worth it!
07:30:33 <nand`> Na-Fiann: yeah ideally you want a -> Maybe b for anything that should be able to fail
07:31:01 <nand`> or if you want it to crash with a more sane error message, you can still write your own fromJust with a better fromJust Nothing = error "foo"
07:31:11 <nand`> (or just put it inside a case like you probably did, I haven't looked)
07:31:54 <Saizan> ther's also fromMaybe
07:33:11 <nand`> yeah, that's good if you want the function to return the list unmodified if it fails
07:33:52 <nand`> (a:b: fromMaybe c (lookup myMap c) :d)
07:39:48 <gdoteof> hello.  i am following: http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/  which i think is not quite quite updated to thelatest yesod.  but, i am trying to make a form post, and it seems that the hamlet file is generating the form correctly
07:39:52 <gdoteof> but, nothing is happening on submit
07:40:09 <ChristianS> Na-Fiann: btw, i just noted that lambda function in my code (\a b -> B.null a == B.null b) can be replaced by ((==) `on` B.null) -- requires import Data.Function
07:41:52 <hpaste> gdoteof pasted “generated by yesod” at http://hpaste.org/64881
07:42:37 <hpaste> gdoteof pasted “generated by yesod” at http://hpaste.org/64882
07:44:09 <hpaste> gdoteof pasted “the haskell code” at http://hpaste.org/64883
07:45:00 <gdoteof> the third one is the code that is generating the 'generated by yesod' html
07:45:18 <gdoteof> but clicking submit at localhost:3000/mirror is not submitting anything
07:45:59 <scooty-puff> is there already something like monad that looks sort of like a state monad, but implements reader and writer?
07:46:18 <gdoteof> the route i am using is /mirror MirrorR GET POST
07:46:45 <scooty-puff> not sure if it would be misleading that "ask" maybe give different results depending on where its sequenced, rather than nesting (i.e. via "local")
07:47:34 <cmccann> scooty-puff, wouldn't "ReaderT s (Writer s)" or something like that work?
07:47:50 <cmccann> or do you mean something that acts more like State?
07:48:00 <scooty-puff> it would act like that, though i guess:
07:48:07 <scooty-puff> ?unmtl ReaderT s (WriterT s)
07:48:07 <lambdabot> Plugin `unmtl' failed with: `ReaderT s (WriterT s)' is not applied to enough arguments.
07:48:20 <scooty-puff> ?unmtl ReaderT s (WriterT s) a
07:48:20 <lambdabot> Plugin `unmtl' failed with: `WriterT s a' is not applied to enough arguments, giving `/\A. a (A, s)'
07:48:31 <scooty-puff> ?unmtl ReaderT s (Writer s) a
07:48:31 <lambdabot> s -> (a, s)
07:48:40 <scooty-puff> ?unmtl State s a
07:48:40 <lambdabot> s -> (a, s)
07:48:49 <cmccann> scooty-puff, note that it looks like State but it won't actually act like it
07:49:02 <scooty-puff> reader-writer?
07:49:22 <cmccann> since the reader and writer parts are completely separate
07:49:25 <scooty-puff> yeah, which is why would have to do over state i imagine, that or by newtype wrapping and having diff tell's, etc.
07:49:26 <scooty-puff> yeah
07:49:42 <ClaudiusMaximus> ?unmtl ReaderT r (Writer w) a
07:49:42 <lambdabot> r -> (a, w)
07:50:11 <cmccann> newtype wrapping State and then implementing the reader/writer stuff using State is probably what you want then
07:50:16 <t7> wikipedia says: SIIα = Iα(Iα) = αα
07:50:19 <scooty-puff> so i guess the real benefit to having a state-like monad that implements reader and writer is that it would be slightly more restrictive?  or at least not as easy to just replace the state
07:50:22 <scooty-puff> well, other than by pass, etc.
07:50:24 <t7> but thats eager evaluation
07:50:36 <scooty-puff> :t pass
07:50:37 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
07:50:43 <cmccann> t7, eager evaluation doesn't matter there, does it?
07:51:05 <rostayob> t7: well between the first and the second step that's the only evaluation step you have
07:51:13 <t7> well if you apply K you get SIIK = IK(IK) = K(IK)
07:51:18 <rostayob> and then it goes in one step to the "normal" form
07:52:04 <t7> oh its only like that with K :)
07:52:06 <t7> im an idiot
07:52:24 <acfoltzer> scooty-puff, what about http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-RWS-Lazy.html
07:53:24 <t7> my SII(SII) crashes :| it doesnt say stack overflow or anything
07:54:03 <rostayob> t7: that would never terminate
07:54:56 <rostayob> t7: since SIIα --> αα, SII(SII) --> SII(SII)
07:55:05 <t7> yeah but space leak or whatever
07:55:40 <rostayob> t7: I don't follow
07:55:59 <t7> i thought it would make a huge thunk
07:56:12 <LGWapnitsky> new to haskell, trying to install LDAP package on windows.  Being told that C library isn't installed.
07:56:18 <rostayob> t7: that term doesn't have a normal form
07:56:26 <LGWapnitsky> Downloaded the C library from Novell and tried to link to it, but not working,  Assistance?
07:56:35 <rostayob> if you're evaluating until you get a normal form you'll never sto evaluating
07:56:58 <rostayob> (normal form with combinators = a combinator with less arguments that it needs to rewrite)
08:00:48 <t7> are there any papers on compiling functional languages to stack based x86 type code?
08:00:55 <scooty-puff> acfoltzer: only problem with that is that the reader and writer are separate - so would have to wrap and redefine ask (well, maybe) and tell
08:01:17 <scooty-puff> but that naming convention makes me hesitant to name it RW rw m a
08:01:36 <Eduard_Munteanu> @where stg
08:01:37 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
08:01:51 <Eduard_Munteanu> t7: you might be interested in that ^^
08:03:33 <acfoltzer> scooty-puff: hmm, I'm not sure I understand. Are the ask and tell from MonadReader and MonadWriter not enough?
08:04:02 * hackagebot PrimitiveArray 0.2.1.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.2.1.0 (ChristianHoener)
08:04:49 <scooty-puff> i would want tell a >> ask to include a
08:05:04 <acfoltzer> ahh, I see
08:05:47 <scooty-puff> yeah, which makes me worry that it will be nonobvious what it is i'm meaning (that the env and written will be the same)
08:06:38 <Eduard_Munteanu> scooty-puff: sounds like you want State instead, or a suitable wrapper for.
08:06:44 <acfoltzer> it sounds like you want something closer to state, but instead of being able to arbitrarily get and put, you want to mappend on the front or back only
08:07:36 <hpaste> ChristianS annotated “Slow” with “Slow (with strictLines trick)” at http://hpaste.org/64795#a64885
08:07:39 <acfoltzer> or, I suppose, you do want to arbitrarily get, you just want to restrict put
08:08:30 <scooty-puff> acfoltzer: yes, very much so - basically do not want replaces, though it could be done if you properly screw with your monoid instance.. but i'll accept that
08:09:02 * hackagebot BiobaseXNA 0.6.2.1 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.6.2.1 (ChristianHoener)
08:09:04 * hackagebot BiobaseTurner 0.2.2.1 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.2.2.1 (ChristianHoener)
08:09:40 <ChristianS> Na-Fiann: i just pasted a new version that uses a trick that I used before with good success ^^ : I/O is lazy, but each line is processed into a strict bytestring before further processing, and finally converted back (in other cases I also decode lines to Data.Text at the same time).
08:10:18 <acfoltzer> scooty-puff: I'd come up with a code sketch for you if I wasn't about to be late to class! bbl
08:10:42 <scooty-puff> nah, already most of the way through it
08:10:44 <ChristianS> that's again much faster -- about 30% when redirecting output to a file, and at least 3 times as fast when printing to my terminal
08:11:00 <scooty-puff> acfoltzer: (et al) but thanks for the help
08:12:42 <ChristianS> in fact i'm dismayed by how slow output to stdout/terminal is when writing lazy bytestrings that have many little pieces. i would have supposed it doesn't matter that much since stdout should use LineBuffering, but nevertheless the difference is *huge*.
08:19:02 * hackagebot BiobaseVienna 0.2.2.1 - Import Vienna energy parameters  http://hackage.haskell.org/package/BiobaseVienna-0.2.2.1 (ChristianHoener)
08:19:08 <Eduard_Munteanu> I wonder if the large number of syscalls is the bottleneck.
08:19:10 <Na-Fiann> ChristianS, I guess my biggest problem is that I have to learn all of these tricks to get results comparable to my naive python implementations
08:19:43 <Eduard_Munteanu> Na-Fiann: how large is your input dataset?
08:20:37 <Eduard_Munteanu> Although printing lots of stuff to a terminal is always going to be slow.
08:21:24 <Na-Fiann> Eduard_Munteanu, not huge, I'm currently playing around with haskell to see if I can replace it for my python needs. Typically I munge text files from a few MB to several hundred MB. usually I just pipe all my outputs into a file
08:21:39 <Na-Fiann> *all in the name of learning haskell of course :)
08:22:38 <Eduard_Munteanu> Hm, you should consider Data.Text instead.
08:23:23 <ChristianS> Na-Fiann: hm, even without many tricks our program was already twice as fast as the python version (when redirecting the output to a file). that's not bad, i think.
08:24:51 <ChristianS> in general i find that it's often sufficient to write straightforward haskell code without special tricks to get good performance (thought the strictLines/lazyUnlines trick is an exception).
08:26:47 <Eduard_Munteanu> I think the main complaint is the naive approach is very slow.
08:27:09 <Na-Fiann> ChristianS, sure, but for example: I'm replacing some strings in my input using a map now. on a typical dataset, using the simplest python implementation, it takes 2.5s, the same kind of thing on haskell using Data.Text takes 18s. Using Data.ByteString doesn't work, because its utf-8 data
08:28:02 <Na-Fiann> maybe my idea of a naive haskell implementation should change, and I just write inefficient haskell, but still
08:28:20 <CQ> Na-Fiann: pastebin them for people to look at?
08:28:41 <Na-Fiann> CQ: sure
08:29:03 <babueverest> why is haskell important?
08:29:06 <ChristianS> Na-Fiann: you could try Data.HashMap (from unordered-containers package) instead of Data.Map, that should speed things up a bit. though not as much as you want...
08:29:34 <Eduard_Munteanu> babueverest: important? I don't know, unless you mean notable.
08:30:07 <babueverest> sorry why is it notable?
08:30:11 <babueverest> I m a newbie
08:30:58 <Na-Fiann> http://hpaste.org/64888
08:31:17 <Na-Fiann> ChristianS, CQ, ^^^
08:31:28 <Eduard_Munteanu> babueverest: well, you're asking people in #haskell why their (favorite) language is nice/important/etc. :). For one thing, it is different as you might have noticed.
08:31:29 <Na-Fiann> I don't check the lines of the map file, because I don't in python either
08:31:39 <ChristianS> Na-Fiann: also i noted that lazy stuff is really very slow, when used as key in a map. there you should really try the strictLines trick i just posted. one second...
08:32:07 <merijn> babueverest: The (or one of the) most well known Hindley-Milner style functional languages. Notable for being the only (as far as I'm aware) one that is very focussed on purity
08:32:45 <merijn> babueverest: See also "Why functional programming matters" (http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf) and http://www.haskell.org/haskellwiki/Why_Haskell_Matters
08:33:11 <Eduard_Munteanu> Yeah, pretty much the only language in its class that got some traction.
08:33:36 <Eduard_Munteanu> (There are others, but less well known/used.)
08:33:41 <merijn> Also, a lot of innovative features such as typeclasses being experimented with
08:34:02 <babueverest> Thank you <merijn> and <Eduard_Munteanu>
08:34:21 <merijn> In the Hindley-Milner category ocaml arguably has more real world/business traction, but is not as focussed on purity
08:34:25 <azaq23> my favorite language is brainfuck, I can control everything to the last detail
08:34:30 <Eduard_Munteanu> babueverest: you might want to check Wikipedia for a general overview.
08:35:00 <hpaste> ChristianS pasted “Lazy I/O <-> strict Texts” at http://hpaste.org/64890
08:36:08 <ChristianS> Na-Fiann: see ^^ http://hpaste.org/64890 for a variant that allows you to combine lazy I/O (via bytestrings) with lines that are strict Data.Text. may make a big difference.
08:39:39 <mm_freak_> tried ocaml multiple times…  just can't live with the lack of type classes
08:39:40 <Na-Fiann> ChristianS, thanks! and sorry for complaining about stuff like this, it's just a bit weird for me that the standard string datatype seems to be the slowest
08:39:52 <mm_freak_> it's one of the reasons ocaml code is so ugly compared to haskell
08:41:21 <tromp__> like different + for ints and doubles?
08:41:27 <ChristianS> yes, standard string is [Char] which is elegant but not very practical. the whole string situation is indeed a bit unfortunate in haskell...
08:43:27 <tromp__> an elegant default and efficient (but less elegant) alternatives seems desirable
08:44:36 <Eduard_Munteanu> mm_freak_: what do you do, pass around functions?
08:45:01 <dbelange> How do I get dynamic scoping in Haskell?
08:45:01 <mm_freak_> tromp__: for example, yes
08:45:25 <mm_freak_> Eduard_Munteanu: well, it's "objective" caml, so you probably do some OOP stuff
08:45:27 <Eduard_Munteanu> ChristianS: arguably it could be less unpractical if it fused more often.
08:45:29 <mm_freak_> but i hate OOP
08:45:50 <mm_freak_> ChristianS: i don't think it's unfortunate
08:45:56 <mm_freak_> it's just a little more explicit
08:45:59 <Eduard_Munteanu> Mmm, OOP isn't bad per se.
08:46:01 <tromp__> azaq23: a brainfuck interpreter is not hard to write in haskell:)
08:46:17 <mm_freak_> Eduard_Munteanu: i'm using FP to get rid of the paradigm
08:46:26 <rwbarton> my understanding is that OCaml users largely ignore its "O"-related features
08:46:37 <Eduard_Munteanu> It's a nuisance when everybody pretends their limited idea of OO is the way to go, rather.
08:46:43 <roconnor> http://okmij.org/ftp/Computation/Subtyping/
08:46:48 <ChristianS> Na-Fiann: you should also use hlint on your code -> try to fix the warnings under your paste (ghc's -Wall option is useful to)
08:47:05 <Na-Fiann> what's hlint?
08:47:10 <mm_freak_> Eduard_Munteanu: i know all the different kinds of OO, smalltalk-style, C++-style, etc.
08:47:19 <mm_freak_> and i enjoy none of them
08:47:35 <dbelange> jack of all trades, master of none
08:47:43 <roconnor> mm_freak_: Eiffel?
08:47:44 <Eduard_Munteanu> Haskell does some OO too.
08:47:50 <azaq23> tromp__: yes, I did it once
08:47:54 <ChristianS> Na-Fiann: http://community.haskell.org/~ndm/hlint/
08:47:55 <mm_freak_> roconnor: haven't tried that one
08:48:01 <mm_freak_> also i missed CLOS
08:48:13 <mm_freak_> Eduard_Munteanu: like what?  existential types?
08:48:16 <ChristianS> Na-Fiann: can be installed via  cabal install hlint , if you don't have it already.
08:48:20 <dbelange> you people talk about esoteric programming languages like they were designer drugs
08:48:22 <Eduard_Munteanu> And pretty much any reasonable abstraction looks like OO, I'd guess.
08:48:30 <tromp__> azaq23: me too:)
08:48:43 <dbelange> except for haskell, you just sound like potheads with that one
08:48:51 <mm_freak_> Eduard_Munteanu: you apply functions to values…  if that's OO, then yes, everything looks like OO ;)
08:48:56 <Eduard_Munteanu> mm_freak_: yeah, but not only.
08:48:57 <ChristianS> dbelange: haskell, ocaml and eiffel aren't esoteric programming languages.
08:49:38 <ChristianS> dbelange: if you want esoteric programming languages, look at http://en.wikipedia.org/wiki/Iota_and_Jot
08:49:43 <mm_freak_> Eduard_Munteanu: existential types are first class values together with operations…  OO in industry is mainly abused to modularize code
08:49:44 <Na-Fiann> ChristianS, cheers, have to go now though
08:49:48 <franco00> I have a function which signature is "evaluateText :: (Monad m) => [Variable] -> Text -> m String" . when I put said function in main (e.g. in "where eva = evaluateText var txt") GHCi complains about "ambiguous type variable". What should be the type signature of eva, ? I would like an either, but alas eva :: Either String String does not work)
08:49:51 <Eduard_Munteanu> We do treat various types as self-contained entities, and prefer to use an interface rather than stare into its guts.
08:49:58 <dbelange> I don't know what "esoteric" means to you
08:50:09 <dbelange> but I've never seen anyone use eiffel or haskell in the wild
08:50:26 <mm_freak_> dbelange: i use haskell in the wild
08:50:40 <quicksilver> esoteric programming languages has a specific accepted meaning
08:50:54 <Botje> franco00: forcing the type should work. are you sure it's complaining about the m there?
08:50:54 <quicksilver> slightly more extreme than the everyday use of the word 'esoteric'
08:51:08 * cmccann reminds people that dbelange has a track record of trolling and arguing is probably a waste of time
08:51:21 <Eduard_Munteanu> mm_freak_: anyway, apart from their particular idea of how OO should be, the really basic ideas are pretty much universal, AFAICT
08:51:23 <franco00> Botje: if I comment the line, everything is ok. Should I paste the error?
08:51:32 <rwbarton> franco00: are you using eva at all?
08:51:35 <rostayob> dbelange is the guy who argued for hours about how #haskel should be ##haskell
08:51:38 <mm_freak_> Eduard_Munteanu: the basic idea depends on the language
08:51:40 <rostayob> *#haskell
08:51:41 <franco00> rwbarton: not yet
08:51:55 <franco00> just put it in where
08:51:58 <mm_freak_> Eduard_Munteanu: OO is more than just writing "x.f" instead of "f x"
08:52:01 <dbelange> from wikipedia "he usual aim is to remove or replace conventional language features while still maintaining a language that is Turing-complete"
08:52:03 <Botje> didn't we ban someone trolling from csclub.uwaterloo.ca a while ago?
08:52:04 <dbelange> sounds like haskell
08:52:24 <rwbarton> I guess you are running into the monomorphism restriction. if you use eva somewhere your problem should just go away. or you can turn off the monomorphism restriction
08:53:18 <cmccann> fyi, if you google dbelange you can also find some logs of previous trolling attempts
08:53:29 <ChristianS> haskell is the most feature-rich programming language i have ever met.
08:53:43 <_Mikey> Hey peoples, We often stress the difference between Concurrency and Parallelism, but are there any academic papers which layout definitions for these terms explicitly?
08:54:17 <franco00> rwbarton: still "No instance for (Monad (Either String))", even if I use it in main.
08:54:23 <ChristianS> (though most of its features come from libraries, they don't require built-in syntax -- which speaks for the power of the language.)
08:54:30 <rwbarton> oh, well, that's a different problem.
08:54:39 <Botje> franco00: oh. you forgot to load the module that defines that instance.
08:54:41 <franco00> I am all ears rwbarton
08:54:49 <franco00> ...
08:54:50 <franco00> silly
08:54:52 <franco00> me.
08:54:54 <franco00> :P
08:54:54 <rwbarton> see Botje, I forget which module it is currently
08:55:09 <majuscule> I'm trying to read a configfile, first trying the user rc file, then the global rc. If the user file isn't there, i get an error with openFile, obviously, but what is the standard way to handle this in haskell?
08:56:06 <mm_freak_> majuscule: well, one obvious way is to catch the exception
08:56:06 <rwbarton> majuscule, exceptions
08:56:21 <mm_freak_> majuscule: but a better way is to check for the file's existence before opening it
08:56:42 <rwbarton> that's generally not a good way
08:56:42 <ClaudiusMaximus> what if the file disappears between checking and opening?
08:57:05 <mm_freak_> rwbarton: if the file exists and the opening fails, you /should/ get an error message
08:57:05 <franco00> Botje: which module is it?
08:57:17 <mm_freak_> majuscule: see System.Directory.doesFileExist
08:57:22 <franco00> Botje: which module is it?
08:57:31 <rwbarton> you can specifically catch the FileNotFoundException or whatever
08:57:36 <franco00> (sorry mis ctrl+v)
08:58:17 <mm_freak_> rwbarton: using the global RC file should not be in response to an error…  it should be well-defined behaviour
08:58:24 <cmccann> rwbarton, checking for the file seems safe in this case. seems like the worst case scenario would be it doesn't find the file and that's something that needs to be handled anyway.
08:58:38 <rwbarton> I agree in this case it doesn't matter much
08:58:40 <majuscule> i've searched and searched for a function to check for a files existence, but i can't turn anything up. am I missing something? I'm looking System.IO, System.FilePath
08:58:59 <cmccann> rwbarton, but yes checking for existence is an invitation to race conditions in general
08:59:00 <mm_freak_> majuscule: again, System.Directory
08:59:39 <Botje> I don't know now
08:59:39 <majuscule> mm_freak_: my apologies, i somehow missed your message. thank you
08:59:56 <Botje> oh, it's Control.Monad.Error
09:00:02 <franco00> thanks
09:00:15 <rwbarton> I think (in this very implausible and unimportant scenario) the worst case is we check whether the user rc file exists, it does, now we try to open it and it is gone so we get an exception, what do we do now
09:00:26 <mm_freak_> well, it is a race condition…  but there is a second reason you should use this way
09:00:34 <rwbarton> either we give up, which doesn't seem right, if the global rc file always existed
09:00:35 <mm_freak_> you don't want to open a block device
09:00:40 <rwbarton> or we handle the exception, in which case we have gained nothing
09:00:48 <rwbarton> over doing it the standard way
09:00:50 <majuscule> rwbarton: that's a pretty convincing argument
09:00:55 <Number6> Hey. I keep getting this error -     Failed to load interface for `RandomGenerator':
09:02:33 <mm_freak_> the argument was convincing from the beginning…  i wish there was a way to do the check and open the file atomically
09:02:37 <mm_freak_> like a transactional filesystem
09:03:35 <cmccann> mm_freak_, file I/O with semantics similar to STM would be very handy
09:04:21 <rwbarton> how is that different from attempting to open the file and checking for ENOENT?
09:04:37 <mm_freak_> rwbarton: well, it's not an error response
09:05:02 <rwbarton> are we talking about the Haskell standard library or the POSIX kernel interface?
09:05:07 <mm_freak_> i don't like the idea that well-defined behaviour abuses exceptions
09:05:20 <mm_freak_> probably the latter
09:05:43 <rwbarton> if you try to open(2) a nonexistent file, it will give you ENOENT
09:05:47 <rwbarton> so I'm not sure what you mean
09:05:58 <rwbarton> it's just in Haskell that it wraps this error in an exception, and you have to unwrap it
09:06:37 <rwbarton> a "openFileIfExists :: FilePath -> IO (Maybe Handle)" might be a nice addition
09:06:51 <rwbarton> but you can implement that yourself in Haskell 98
09:07:50 <quicksilver> you can argue about which style of programming you prefere
09:07:57 <quicksilver> but this is certainly not an *abuse* of exceptions.
09:08:12 <quicksilver> One of the specific use cases of exceptions is so you don't have to check return values every step of the way.
09:09:34 <singpolyma> What does it mean when I get printed out:   ProgramName: <<loop>>   ?
09:10:07 <mm_freak_> rwbarton, quicksilver:  maybe you're right
09:10:16 <mm_freak_> i really wish we had a transactional filesystem
09:10:22 <mm_freak_> it would make a lot of things easier
09:10:34 <mm_freak_> singpolyma: you have an infinite recursion somewhere
09:10:38 <mm_freak_> singpolyma: like:  f = f
09:10:46 <rwbarton> yeah, "open if exists" is about as far as you can get with normal filesystems :)
09:10:47 <mm_freak_> a nonproductive recursion that is
09:10:48 <singpolyma> mm_freak_: hmm, ok
09:13:15 <quicksilver> mm_freak_: this is why so much stuff uses SQLite even though it sucks in many many ways
09:13:32 <quicksilver> mm_freak_: despite all its suckage it does approximate a private transactional filesystem.
09:14:38 <mm_freak_> true
09:15:20 <quicksilver> makes it easy to write crash-safe apps with persistent state
09:15:25 <quicksilver> and that's nice in many ways.
09:15:43 <quicksilver> crash-safe apps can just be unmapped by the kernel instead of being explicitly killed.
09:15:53 <CQ> is haskell looking at doing anything like Erlang with the live-module replacements?
09:16:13 <quicksilver> on the other hand, if you manage to get your persistent state in a place that violates your invariants, you rediscover the hell of (for example) the windows registry.
09:16:26 <quicksilver> a program which can never be launched and there is no way to fix it. Yay.
09:16:36 <quicksilver> CQ: lots of people have looked at that, yes.
09:16:39 <mm_freak_> well, in haskell you have acid-state
09:16:52 <mm_freak_> i'd prefer that over sqlite
09:17:03 <quicksilver> CQ: look at http://hackage.haskell.org/package/plugins and http://hackage.haskell.org/package/dyre
09:17:25 <quicksilver> CQ: (there are others) neither is exactly what you asked for but, well, haskell is different from erlang.
09:17:46 <mm_freak_> with acid-state if anything goes wrong you have the ability to roll back
09:17:48 <quicksilver> mm_freak_: sure. Plenty of reasons to prefer that. Doesn't solve the broken invariants though :)
09:18:18 <cmccann> mm_freak_, acid-state is too limited for my tastes though
09:18:26 <mm_freak_> cmccann: huh?
09:18:50 <cmccann> mm_freak_, compared to what a transactional file system would do, I mean
09:19:06 <mm_freak_> cmccann: well, that's two different things
09:19:08 * hackagebot PrimitiveArray 0.2.1.1 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.2.1.1 (ChristianHoener)
09:19:10 * hackagebot BiobaseXNA 0.6.2.2 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.6.2.2 (ChristianHoener)
09:19:15 <cmccann> yeah, sorry
09:20:12 <mm_freak_> in a transactional filesystem i don't need to overwrite by creating a second file and then renaming it to the target file…  acid-state lets me persist some application state safely
09:20:36 <cmccann> I was thinking about what quicksilver said about people using sqlite to approximate a private transactional file system, and that you'd prefer acid-state
09:20:47 <cmccann> but neither is really comparable to a real transactional file system
09:20:56 <mm_freak_> potentially in a transactional filesystem power outage while updating my system won't kill it…  it happened to me recently, and i so wished that i were using NixOS
09:21:47 <quicksilver> cmccann: they're not comparable, but you can implement most of the bits of one that you need.
09:22:09 <quicksilver> cmccann: by implementing your own filesystem-a-like as either SQL tables (first case) or haskell structures (second case)
09:23:27 <Eduard_Munteanu> mm_freak_: um, any reasonable filesystem nowadays uses some form of journalling and syncing to ensure consistency.
09:24:05 <quicksilver> Eduard_Munteanu: only metadata consistency.
09:24:06 <Eduard_Munteanu> Also, any reasonable application using such a filesystem will fsync appropriately.
09:24:08 * hackagebot BiobaseTurner 0.2.2.2 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.2.2.2 (ChristianHoener)
09:24:09 <mm_freak_> Eduard_Munteanu: that doesn't help, if only half of the files of a critical package gets updated and you don't know which package
09:24:10 * hackagebot BiobaseVienna 0.2.2.2 - Import Vienna energy parameters  http://hackage.haskell.org/package/BiobaseVienna-0.2.2.2 (ChristianHoener)
09:24:12 <cmccann> Eduard_Munteanu, consistency of the file system is not the same as consistency in the files
09:24:14 <quicksilver> not file consistency or package consistency
09:24:21 <quicksilver> or package *system* consistency
09:24:43 <Eduard_Munteanu> Sounds like a broken package manager.
09:25:08 <quicksilver> dpkg should be able to tell you which packages were broken, certainly
09:25:22 <quicksilver> it tries quite hard to make package updates close to atomic and leave indication of which state its in
09:25:48 <mm_freak_> Eduard_Munteanu: there is no way to do this fully ensuring consistency
09:25:56 <mm_freak_> at some point you need to update the files
09:26:36 <mm_freak_> you could keep a record of updated files and sync after every single file, then after a crash just rollback
09:26:44 <Eduard_Munteanu> Yes, but if you track the state appropriately you can recover from it.
09:26:46 <mm_freak_> but that's going to make updates take a long time
09:27:13 <Eduard_Munteanu> Ah, fair.
09:27:39 <Enigmagic> you don't need to sync after every file
09:28:33 <Enigmagic> you're describing what MSI (microsoft installer) has done for years otherwise, and it is definately not fast
09:28:37 <Eduard_Munteanu> Though I think something like LVM snapshots would make it reasonable, assuming commiting the snapshot back is atomic (?).
09:28:58 <Enigmagic> Eduard_Munteanu: that's how OS updates on Solaris work with zfs
09:29:12 <Enigmagic> zfs snapshot -> update OS -> reboot
09:29:20 <Eduard_Munteanu> Ah. Yeah, zfs provides native snapshots.
09:29:23 <Enigmagic> old snapshots show up in the boot manager
09:29:41 <mm_freak_> well, NixOS provides a real solution to the problem
09:29:53 <Enigmagic> but then you're running Solaris :)
09:29:56 <Enigmagic> :(
09:29:58 <mm_freak_> it's the whole idea of most package managers that's broken
09:30:05 <Eduard_Munteanu> Enigmagic: btrfs could do that though
09:30:12 <Eduard_Munteanu> (on the Linux side)
09:30:24 <Enigmagic> Eduard_Munteanu: yeah i'm just saying that Solaris/OpenSolaris has been doing exactly that for a while
09:31:25 <Eduard_Munteanu> mm_freak_: Nix is certainly interesting, although I've seen some criticism regarding it. Mainly you end up with lots of different versions, like with Cabal.
09:31:41 <mm_freak_> Eduard_Munteanu: correct
09:31:49 <mm_freak_> what's the criticism?
09:32:31 <Tinned_Tuna> Is it possible to buy a Haskell Logo poster?
09:32:33 <Eduard_Munteanu> mm_freak_: that you end up with stale versions around. Presumably you could GC them and/or rebuild everything.
09:32:46 <mm_freak_> Eduard_Munteanu: you GC them
09:33:22 <mm_freak_> it's a matter of one short command to get rid of all unused revisions ("derivations" as they're called by nix)
09:33:54 <Eduard_Munteanu> mm_freak_: though you probably want a way to completely get rid of all the different versions, I guess.
09:34:14 <mm_freak_> Eduard_Munteanu: version + configuration = derivation
09:34:49 <Eduard_Munteanu> Can you tell Nix to rebuild everything using common dependencies?
09:35:14 <mm_freak_> that request doesn't make sense in nix
09:36:20 <Eduard_Munteanu> How so? If I have 100 packages depending on different versions of X, doesn't it make sense to say "rebuild all those packages using the latest version of X, so I can save space etc."?
09:36:25 <f4stra> when i serach for something in google and then click view page source, how can i decipher the urls of the ten results it gives me? doing ctrl+f www.whatever.com doesnt work
09:36:41 <mm_freak_> your current user environment is a set of derivations…  it is derived from the set of packages installed and the configuration used…  if rebuilding that environment has a different result, then the package manager has a bug
09:36:52 <mm_freak_> in other words:  rebuilding must never be necessary for anything
09:37:08 <mm_freak_> unless you changed the configuration in a way that requires rebuilding, of course
09:37:24 <mm_freak_> Eduard_Munteanu: no, it doesn't
09:37:46 <mm_freak_> one derivation can't depend on version X this time and version Y the next time
09:38:01 <mm_freak_> that's the basic idea of what they call "purely functional package management"
09:40:25 <Eduard_Munteanu> mm_freak_: mm, so you're saying you can never get rid of stale versions unless ... ?
09:40:41 <Eduard_Munteanu> Well, they're not technically stale.
09:41:09 <mm_freak_> ;)
09:42:09 <Eduard_Munteanu> But still, there should be a way to compact that. Or are you saying Nix is a binary distro and there's nothing to rebuild?
09:43:07 <CQ> sounds like teh opposite of gentoo :)
09:44:28 <Eduard_Munteanu> Yeah, it makes sense if the current set of available packages actually have those dependencies.
09:44:36 <mm_freak_> Eduard_Munteanu: it's a source distribution with binary packages for common derivations
09:44:52 <mm_freak_> Eduard_Munteanu: a GC-ed system should not use any more space than with any other distribution
09:46:06 <Eduard_Munteanu> AFAIU, GC merely removes unneeded dependencies, it doesn't do anything to "release" existing dependencies.
09:47:29 <mm_freak_> Eduard_Munteanu: "dependencies"?
09:48:15 <mm_freak_> you install derivations, and they depend on others…  obviously you can't remove them, until they aren't needed anymore
09:49:22 <Boxo> Is there something I can paste a long haskell one-liner expression into and it will split it into lines and indent it properly?
09:50:31 <dekuked> how stable is nixOS for using it as a server?
09:51:00 <CQ> interesting debian-apt-nix read here http://lists.debian.org/debian-devel/2008/12/msg01027.html
09:51:39 <mm_freak_> Boxo: like a code beautifier?
09:51:59 <Boxo> mm_freak_: yeah I guess
09:52:22 <mm_freak_> dekuked: probably not that bad…  in fact you can easily put the actual system in a VM, so that when someone intrudes, just rebuild the VM with newer versions and then use your backups
09:53:21 <dekuked> so, don't expect sane security defaults?
09:54:28 <Boxo> hm, there's haskell-src-exts. let's pray it installs without errors...
09:59:14 * hackagebot copilot-language 0.9 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-0.9 (LeePike)
09:59:16 * hackagebot copilot-libraries 0.6 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-libraries-0.6 (LeePike)
10:02:00 <Eduard_Munteanu> mm_freak_: (sorry for the delay). Ok, Gentoo does this the other way: when updating, it simply breaks dependencies and you have to run a tool (revdep-rebuild) to rebuild all broken packages to depend on the latest version of that library.
10:02:30 <Eduard_Munteanu> Now, it looks like Nix keeps old versions around. I wondered if there's any sensible analogue to revdep-rebuild there.
10:03:14 <Eduard_Munteanu> Such that packages depend on a single (latest) versions and older ones can be GCed.
10:05:58 <roconnor> Eduard_Munteanu: question about nix?
10:07:04 <Eduard_Munteanu> roconnor: yes. Basically I was asking if there's a way to get rid of "stale" Cabal-like dependencies by updating packages to depend on a single version of a library.
10:07:58 <roconnor> Anything not depending on, directly or indirectly, a GC-root package, will be GCd
10:08:21 <roconnor> so then it depends on the policy for what packages are GC-roots
10:09:15 * hackagebot copilot-language 0.9.1 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-0.9.1 (LeePike)
10:09:17 * hackagebot cblrepo 0.5.0 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.5.0 (MagnusTherning)
10:09:59 <roconnor> in nix, all current and previous "user-environments" are GC-roots
10:10:04 <Eduard_Munteanu> roconnor: yeah, though I was wondering if there's a way to break such dependency relations so you could GC everything but one version.
10:11:31 <roconnor> Eduard_Munteanu: depedencies are not between versions, but between specific "builds" of versions of software. and all builds are (effectively) immutable.
10:12:05 <roconnor> Eduard_Munteanu: I think there is something that I am not getting about your scenario
10:12:14 <Boxo> @djinn Monoid a => [a -> [(a, b)]] -> a -> [b] -> [(a, b)]
10:12:14 <lambdabot> Error: Undefined type []
10:12:49 <roconnor> Eduard_Munteanu: if you want to GC old builds of installed packages, then you have to mark then as no longer being GC-roots and then run the garbage collector.
10:12:55 <roconnor> (in nix)
10:12:56 <Eduard_Munteanu> roconnor: well, my scenarios is I have a library X and 50 other packages depending on different versions of X. How do I improve the situation?
10:13:19 <Eduard_Munteanu> *scenario
10:13:37 <mm_freak_> Eduard_Munteanu: that's not necessary in nixos
10:14:07 <mm_freak_> assuming no bugs every derivation is fully consistent with its dependencies
10:14:13 <roconnor> Eduard_Munteanu: firstly, such a scenario isn't problematic in nix.  Secondly, there is no way to fix it without changing the packages depending on X until they all depend on the same build of X.
10:14:38 <Eduard_Munteanu> I understand it's consistent, but what about disk space-related concerns?
10:15:14 <mm_freak_> Eduard_Munteanu: by not forcing the maintainers to go with every dependency update NixOS naturally takes more space than others distributions
10:15:15 <roconnor> Eduard_Munteanu: in nixpkgs, we strive to make all our packages depend on the same build of libraries.
10:15:38 <mm_freak_> the package manager is more relaxed in that regard
10:15:54 <mm_freak_> of course packaging policy may still force maintainers to do so
10:15:59 <dolio> Is there garbage collection?
10:16:05 <mm_freak_> yes
10:16:13 <dolio> Oh, that's not bad, then.
10:16:16 <Eduard_Munteanu> Mm, I thought a package would accept a number of versions of a particular library. Like foo > 2 and foo <= 3
10:16:31 <roconnor> Eduard_Munteanu: ah, in Nix we have no contraints like in Hackage.
10:16:42 <mm_freak_> Eduard_Munteanu: no, think of a package as a function of its dependencies
10:16:42 <roconnor> Eduard_Munteanu: (for the most part)
10:16:45 <newsham> https://plus.google.com/104222093009939197511/posts/Q3o5WPZUjph
10:16:47 <Eduard_Munteanu> If so, it makes sense to make it possible to ask Nix to update everything to depend on foo == 3 if that's possible.
10:16:55 <Eduard_Munteanu> Hm.
10:17:24 <mm_freak_> it is indeed functional package management…  a derivation depends on derivations, not on packages, as far as i understand
10:17:31 <dolio> I'm using 25% of my 40 gigs of root partition here in Fedora.
10:17:39 <dolio> So I could handle a significant blowup.
10:17:48 <roconnor> Eduard_Munteanu: most packages in nixpkgs, says "depend on the `standard' version of so and so library"
10:17:51 <Eduard_Munteanu> Hm, that's a bit strange. So a package is actually own version + each dependency version?
10:18:20 <mm_freak_> Eduard_Munteanu: a derivation
10:18:26 <mm_freak_> which is package + dependencies + configuration
10:18:27 <roconnor> Eduard_Munteanu: In practice, when updateing a library, we go ahead and update the 'standard' version of it.
10:18:43 <roconnor> Eduard_Munteanu: then cross our fingers and hope everything still builds.
10:19:13 <roconnor> Eduard_Munteanu: In case a package no longer builds, we can change it to depend on a specific version of the library instead of the 'standard' version.
10:19:14 <Eduard_Munteanu> Ah, so you don't handle multiple versions of a library, I guess.
10:19:34 <Eduard_Munteanu> E.g. like Gentoo provides multiple stable versions of an ebuild.
10:19:46 <roconnor> Eduard_Munteanu: in partcular change it to depend on the previous version that used to be standard.
10:20:19 <roconnor> Eduard_Munteanu: In nixpkgs we do support multiple versions of libraries, but usually one is 'standard'.
10:20:55 <roconnor> Eduard_Munteanu: To be clear, the 'standard' version isn't used "by default", we always explicitly say "use the standard version".
10:21:28 <Eduard_Munteanu> Ah.
10:21:35 <roconnor> Eduard_Munteanu: but the standard version typically has a shorter name for its expression, and has no version number attached to its expression
10:21:50 <mm_freak_> nix is basically portage on steroids =)
10:21:57 <roconnor> Eduard_Munteanu: while the other versions typically have a longer name for their experssions that include something like their version number.
10:22:04 <Eduard_Munteanu> Do you have anything like an ebuild, which describes a way to build a package based on a range of library versions?
10:22:26 <roconnor> Eduard_Munteanu: not to my knowledge, but such a thing should be compatible with the nix framework.
10:22:43 <Eduard_Munteanu> I see.
10:22:46 <roconnor> Eduard_Munteanu: although there is hack-nix, which somehow turns hackage into nix expressions.
10:22:48 * Eduard_Munteanu needs to look further into this.
10:22:50 <roconnor> Eduard_Munteanu: it might do this.
10:23:36 <roconnor> Eduard_Munteanu: nixpkgs supports an overriding mechanism allowing anyone to fine tune any derivation for their particular needs.
10:24:00 <Eduard_Munteanu> newsham: that's seriously messed up, and pretty much prior art.
10:24:09 <roconnor> so you can inline say, take the standard expression for building library X, and make such and such a change to it.
10:24:42 <roconnor> such as "disable the damned pulseaudio in KDE!"
10:24:57 <Eduard_Munteanu> Ah, like USE flags in a way.
10:25:21 <roconnor> but then you are unlikely to get binary builds for your modified deriviation
10:25:52 <newsham> ed: *sigh*
10:25:56 <roconnor> and you will need to build KDE youself
10:26:23 <roconnor> Eduard_Munteanu: a well abstracted expression for a package will make tweeking it easy.
10:28:14 <roconnor> Eduard_Munteanu: I've tried in this discussion to diffenentiate between nix and nixpkgs.  Nixpkgs is one way to make a distribution using nix, but it is not necessarily the only way or the best way.
10:29:03 <roconnor> nixpkgs works pretty well, at least for the current scale of use.
10:29:20 <Eduard_Munteanu> Mm, is that the "mainline" Nix distribution?
10:29:38 <roconnor> Eduard_Munteanu: I think that would be a fair way of putting it.
10:30:42 <roconnor> I think some package broke recently when the standard libpng was updated
10:31:05 <roconnor> oh it was chrome.
10:31:17 <roconnor> becasue chrom isn't build from source.
10:32:01 <Eduard_Munteanu> Ah, libpng is a PITA.
10:32:08 <Eduard_Munteanu> In Gentoo as well.
10:32:17 <roconnor> and it was fixed by replacking the libpng dependency in chrome with pkgs.libpng12
10:33:35 <Peaker> http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html <-- really awesome blog post.
10:34:17 <Peaker> in "tCheck r (Pi x a b) = do", why is it ok to return "t" as the type(kind/sort) of the Pi?
10:35:00 <Peaker> The type of a (Lam s a b) is (Pi s a (tCheck b))   so why is the type of (Pi s a b) (tCheck b) ?
10:36:23 <roconnor> Peaker: do you have the lambda cube paper?
10:36:45 <Peaker> roconnor: nope.. trying to make sense of that blog post on its own
10:37:17 <Peaker> roconnor: is it a prerequisite to understand that?
10:38:08 <roconnor> PTS are described by a list of rules of the form (s1, s2, s3)
10:38:33 <Peaker> PTS?
10:38:41 <roconnor> Pure Type System
10:38:59 <roconnor> so in general, that type check should return s3 when a has type s1 and b has type s2
10:39:02 <roconnor> however
10:39:23 <roconnor> rules of the form (s1,s2,s2) are *so* common that they are abbrivated to (s1,s2)
10:39:46 <roconnor> so in these particular cases the type check should return s2 when a has type s1 and b has type s2
10:40:21 <Peaker> so why is *->[]  a  []   and    []->*    a  *?
10:40:28 <roconnor> and it looks like augustss's system only supports these special rules.
10:40:39 <Peaker> (yeah, that's "allowedKinds")
10:40:44 <roconnor> (which are by far the most common)
10:41:27 <Peaker> is there any example that illustrates why there's a difference in the sort of (* -> []) and ([] -> *) ?
10:41:31 <Eduard_Munteanu> Peaker: it isn't
10:41:57 <Eduard_Munteanu> Peaker: look at that 'extend'.
10:42:00 <roconnor> the type of * -> [] is the type of []  and the type of [] -> * is the type of *
10:42:10 <Peaker> oh, right
10:42:27 <Peaker> roconnor: is there any example or intuitive explanation of why it is the case, though?
10:43:03 <roconnor> I don't recall why this sort of rule is most common.  It certainly feels like the standard impredicative way to do things.
10:43:13 <roconnor> someone else will have to help you from here
10:43:19 <Peaker> roconnor: thanks :)
10:43:25 <roconnor> maybe the lambda cube paper says
10:43:55 <Peaker> Is it readable by someone with Haskell background, and little theoretical background?
10:44:33 <roconnor> As I recall it is.
10:45:55 <Peaker> We're working on a structural editor for Haskell, and currently edit an untyped representation.. we want to add types, and were wondering about a good way to represent types in there.. Using the standard Haskell way seemed like there would be lots of duplication in the ADTs
10:48:32 <Peaker> Does anyone have a link to "The Lambda Cube paper"?
10:48:49 <jfischoff> which one?
10:49:04 <roconnor> Peaker: wikipedia does
10:49:33 <Eduard_Munteanu> Wait what do you mean by "the type of * -> [] is the type of []"?
10:49:34 <roconnor> jfischoff: Introduction to generalized type systems.
10:49:41 <Peaker> "Intro to generalized type systems"?
10:50:06 <roconnor> Eduard_Munteanu: (* -> [] :: s) iff ([] :: s)
10:50:27 <roconnor> [] is box
10:50:29 <jfischoff> is that the first one?
10:50:35 <roconnor> not an empty list
10:50:52 <roconnor> Peaker: yes
10:51:05 <roconnor> Journal of Functional Programming, 1(2):125-154, April 1991.
10:51:43 <Eduard_Munteanu> Um, that doesn't seem sound.
10:51:52 <Eduard_Munteanu> At least Agdaish-sound.
10:52:39 <roconnor> Eduard_Munteanu: It is not likely to be predicative.
10:54:17 <osa1> how good is fgl for graph operations in terms of efficiency? do we have any better implementations in haskell?
10:54:19 <roconnor> Eduard_Munteanu: As long as you are fine with 2^(2^X) being isomorphic to X, we are sound.
10:54:50 <Eduard_Munteanu> I'm not :)
10:55:14 <Eduard_Munteanu> roconnor: how does that make sense?
10:56:01 <jfischoff> Peaker: FYI, I don't think it is in the blog post, but the Lennart has a related "lambdacube" package on hackage
10:57:36 <Eduard_Munteanu> @djinn ((a -> Bool) -> Bool) -> a
10:57:36 <lambdabot> -- f cannot be realized.
10:57:48 <Eduard_Munteanu> @djinn a -> ((a -> Bool) -> Bool)
10:57:48 <lambdabot> f a b = b a
10:58:32 <vodik> am i missing some sort tecnique? i image there's got to be a shorter way of writting this function
10:58:34 <vodik> > foldr (\a r -> map ((,) a) [1..3] ++ r) [] [1..3]
10:58:36 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:59:13 <mauke> > liftM2 (,) [1..3] [1..3]
10:59:14 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:59:22 <Eduard_Munteanu> > [ (x, y) | x <- [1..3], y <- [1..3] ]
10:59:23 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:59:51 <vodik> go figure
10:59:53 <vodik> Eduard_Munteanu: thanks
11:00:01 <mauke> > replicateM 2 [1..3]
11:00:02 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
11:00:31 <vodik> hmm
11:00:34 <vodik> mauke: thanks
11:01:33 <mauke> > filterM (return [True, False]) "abc"
11:01:34 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
11:01:36 <Eduard_Munteanu> vodik: look into the list monad if you're interested in how it works
11:01:40 <roconnor> Eduard_Munteanu: not for every X, just for a few types X.
11:02:11 <hiptobecubic> mauke, what the hell
11:02:28 <mauke> > filterM (return [True, False]) "magic"
11:02:29 <lambdabot>   ["magic","magi","magc","mag","maic","mai","mac","ma","mgic","mgi","mgc","mg...
11:03:37 <hiptobecubic> which monad is return going to?
11:03:41 <c_wraith> it's important to note that the monad used by filterM is not the same monad as return is using there
11:03:45 <hiptobecubic> list ... again.. i guess?
11:03:46 <c_wraith> return is in the function monad
11:03:54 <hiptobecubic> ok
11:03:57 <c_wraith> that's actually const [True, False]
11:05:15 <hiptobecubic> @src (->) return
11:05:15 <lambdabot> return = const
11:05:20 <hiptobecubic> crazy
11:05:25 <hiptobecubic> @src (->) bind
11:05:26 <lambdabot> Source not found. :(
11:05:36 <c_wraith> use the real name :)
11:05:40 <Eduard_Munteanu> roconnor: what's the box kind again? Any kind?
11:05:46 <c_wraith> @src (->) (>>=)
11:05:46 <lambdabot> f >>= k = \ r -> k (f r) r
11:05:56 <hiptobecubic> c_wraith, oh
11:06:27 <ashoat> hey guys: looking for a bit of help. basically, I'm trying to get around making an orphaned instances declaration. I want to make a type (defined outside my module) showable, and I'm not sure how to do this with orphaning the instance declaration.
11:07:17 <c_wraith> ashoat: you can't, by the definition of an orphan instance.  Just ignore the warning if it's what you really mean to do.
11:07:23 <roconnor> Eduard_Munteanu: box is the sort of kinds. ... if that helps
11:07:27 <hiptobecubic> c_wraith, i don't get it.  f >>= k means apply k to (f r) and r?
11:07:48 <Eduard_Munteanu> Ah.
11:08:01 <roconnor> Eduard_Munteanu: so *, * -> *, (* -> *) -> * -> * all are of sort []
11:08:13 <ashoat> c_wraith: okay, thanks. I thought it might be possible to make a synonym of some sort and declare that showable, or else possibly to "extend" the existing module somehow
11:08:16 <c_wraith> ashoat: and keep in mind why orphan instances are frowned upon (If the module that defines the type later adds that instance, it'll break any code using your orphan instance)
11:08:17 <hiptobecubic> c_wraith, isn't there some way to tell ghc to ignore just this one spot?
11:08:23 <Eduard_Munteanu> roconnor: well, so it's a trivial rule? Any kind has [] as a sort?
11:08:42 <Eduard_Munteanu> Or do you have lifting from types to kinds?
11:08:49 <Eduard_Munteanu> * -> [] I mean.
11:09:21 <c_wraith> hiptobecubic: f >>= k means "create a new function that passes its argument into k and f as required by the types"
11:09:37 <c_wraith> hiptobecubic: if it helps, that's exactly the same thing as the Reader monad, without the newtype wrapper
11:10:10 <c_wraith> ashoat: well, if you can work with a newtype, you can create the show instance for it. But that adds wrapping and unwrapping everywhere, potentially
11:10:22 <Eduard_Munteanu> Um, it'd be (r ->).
11:10:24 <hiptobecubic> c_wraith, haven't used reader or state yet
11:10:27 <Eduard_Munteanu> (->) is confusing.
11:10:52 <roconnor> Eduard_Munteanu: I think Peaker might have been confused.  * -> [] isn't a valid term in any of the corners of the lambda cube AFAIU.
11:11:27 * Eduard_Munteanu wonders how the lambda cube relates to Agda/Coq.
11:11:37 <mwc> Is there any way to build "shared modules" (i.e., "plugins") with cabal? Neither library not executable fit
11:11:39 <roconnor> Eduard_Munteanu: I think Peaker was thinking of X -> Y where X : *  and Y : [], but wrote it incorrectly as * -> []
11:12:01 <roconnor> Eduard_Munteanu: I feel bad for not catching it until now
11:12:03 <mwc> Specifically a dynamic library with an exported C api that can be dlpoened by any arbitrary program
11:12:32 <roconnor> Eduard_Munteanu: though lambda-U does have things like * -> []
11:12:41 <hiptobecubic> c_wraith, i can't seem to construct a working example using >>= in the function monad :/ Do you have one?
11:12:42 <roconnor> Eduard_Munteanu: and it is inconsistent as you noted.
11:12:59 <Eduard_Munteanu> Hm, that makes more sense. A-la   X : Set a, Y : Set b, X -> Y : Set (a \lub b)
11:13:02 <c_wraith> hiptobecubic: well, then, chasing types is probably the best thing to do.  As Eduard_Munteanu pointed out, (->) is actually a horrible shortcut for saying (r ->), which actually has the right kind to be a monad.
11:13:27 <c_wraith> hiptobecubic: So take the signature m a -> (a -> m b) -> m b, and sub in (r ->) for m.
11:13:53 <hiptobecubic> oh
11:13:55 <c_wraith> hiptobecubic: (r -> a) -> (a -> r -> b) -> (r -> b)
11:14:05 <roconnor> Eduard_Munteanu: still, in the lambda cube, X -> Y has sort * when X : [] and Y : *, which is unagda-like
11:14:12 <c_wraith> and then, well.  ask djinn about it.
11:14:16 <Eduard_Munteanu> Ouch.
11:14:23 <c_wraith> @djinn (r -> a) -> (a -> r -> b) -> (r -> b)
11:14:23 <lambdabot> f a b c = b (a c) c
11:14:34 <hiptobecubic> what is djinn?
11:14:50 <c_wraith> djinn takes a type signature and provides an implementation for it.
11:14:58 <magicman> > (do {x <- (+1); y <- (*2); return (x*y)}) 5
11:14:59 <hiptobecubic> c_wraith, oh. wow. That's great
11:14:59 <lambdabot>   60
11:15:10 <Eduard_Munteanu> hiptobecubic: if you need some intuition, think Reader tacks an additional parameter to a function's type.
11:15:10 <c_wraith> for many sufficiently polymorphic type signatures, djinn produces the *only* sane implementation
11:15:13 <magicman> > (do {x <- (+1); y <- (*2); return (x*y)}) 6
11:15:14 <lambdabot>   84
11:16:12 <jfischoff> Eduard_Munteanu: Agda and Coq are both corners of the cube. Agda has a termination checker though, so it is more restrictive. That's my understanding, but you probably know that.
11:16:14 <roconnor> Eduard_Munteanu: haskell has this property too.
11:16:25 <roconnor> @kind forall a. a -> a
11:16:26 <lambdabot> *
11:16:32 <Eduard_Munteanu> roconnor: I guess here "lambda cube" refers to a simplified implementation of one of the corners of Barendregt's cube. I think you can describe Agda as the same corner generically (well + inductive families etc.)
11:16:38 <lispy> jfischoff: Coq doesn't have a termination checker?
11:16:47 <lispy> jfischoff: that would surprise me
11:16:50 <jfischoff> I don't know anything about Coq
11:16:57 <Eduard_Munteanu> roconnor: um, an element of * -> [] would be something like a -> *.
11:17:02 <jfischoff> I bet it does
11:17:24 <Eduard_Munteanu> jfischoff: um, I thought Coq had one too.
11:17:29 <roconnor> Eduard_Munteanu: I mean, Haskell has things (kinda) like X -> Y where X : [] and Y : *
11:17:34 <roconnor> @kind forall a. a -> a
11:17:35 <lambdabot> *
11:17:49 <roconnor> in this example X is * (the type of a) and Y is (a -> a)
11:17:55 <ehy_> hmm, lambdabot's @free doesn't work for seq
11:17:57 <Eduard_Munteanu> roconnor: hm, is your [] cumulative?
11:17:58 <lispy> Eduard_Munteanu, jfischoff: without a termination checker you can use divergent terms to prove false
11:18:00 <ehy_> @free seq
11:18:00 <lambdabot> g . seq x = seq (f x) . g
11:18:15 <roconnor> Eduard_Munteanu: no.
11:18:15 <hiptobecubic> does does @free do?
11:18:17 <hiptobecubic> what*
11:18:22 <ehy_> > (+ 1) (seq 1)
11:18:23 <lambdabot>   *Exception: show: No overloading for function
11:18:25 <c_wraith> free is more complicated.
11:18:26 <lispy> Eduard_Munteanu, jfischoff: and such a weak logic wouldn't be good for theorem proving :)
11:18:38 <jfischoff> lispy: No doubt
11:18:45 <Eduard_Munteanu> lispy: that's not the issue. AFAIK, anything as complex as Coq/Agda needs separate, explicit termination checking. As in it can't be implicit.
11:18:46 <ehy_> > (+ 1) . (seq 1) $ 2
11:18:48 <lambdabot>   3
11:18:49 <c_wraith> free gives you theorems about properties of a function that can be derived from only its type
11:19:04 <ehy_> seq (undefined 1) . (+ 1) $ 2
11:19:07 <Eduard_Munteanu> @where free
11:19:07 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
11:19:07 <ehy_> > seq (undefined 1) . (+ 1) $ 2
11:19:08 <jfischoff> my point is that dependent types != equal termination checker
11:19:08 <lambdabot>   *Exception: Prelude.undefined
11:19:10 <Eduard_Munteanu> Grr.
11:19:16 <Eduard_Munteanu> @google theorems for free
11:19:18 <lambdabot> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
11:19:18 <lambdabot> Title: Theorems for free Philip Wadler University of Glasgow* June 1989 Abstract From t ...
11:19:28 <Eduard_Munteanu> hiptobecubic: see ^
11:19:35 <hiptobecubic> ah
11:19:35 <ehy_> > seq (const 1) . (+ 1) $ 2
11:19:36 <lambdabot>   3
11:19:47 <jfischoff> Agda, and I guess Coq have them for obvious reasons
11:22:12 <Eduard_Munteanu> roconnor: mm, I'm reading   forall a. a -> a  assuming a, b :: *
11:22:20 <Eduard_Munteanu> Does forall do something weird there?
11:22:47 <roconnor> Eduard_Munteanu: in agda notation yo'd write (a:*) -> a -> a
11:22:50 <tomprince> Well, coq just doesn't allow you to write things that need a termination check.
11:22:57 <Eduard_Munteanu> Oh, right.
11:23:29 <roconnor> Eduard_Munteanu: and it wouldn't be legal in agda
11:23:41 <roconnor> er
11:23:48 <roconnor> at least it won't have type *
11:23:49 <Eduard_Munteanu> roconnor: where's the box though? (a : *) -> (a -> a),   and that's pretty much * -> *
11:24:05 <roconnor> Eduard_Munteanu: * has type []
11:24:55 <Eduard_Munteanu> Ah.
11:25:03 <roconnor> Eduard_Munteanu: * has type [] and (a -> a) has type *
11:25:14 <roconnor> and the whole function type has type * (in Haskell)
11:25:26 <roconnor> which is grossly impredicative
11:26:07 <tomprince> It just has structural recursion (and well founded recursion which is just structural recursion on the proof of well foundedness.
11:26:12 <Eduard_Munteanu> Ouch.
11:26:17 <roconnor> and leads to the existence of types X where 2^(2^X) is isomorphic to X.
11:26:29 <hpaste> Per pasted “AdvancedHaskellSummary” at http://hpaste.org/64893
11:26:48 <roconnor> Eduard_Munteanu: under the assumption of functional extentionality and such things.
11:26:55 <Eduard_Munteanu> tomprince: I thought Coq did explicit termination checking as well.
11:27:11 <Eduard_Munteanu> As in it doesn't simply result from well-typing.
11:27:31 <roconnor> Eduard_Munteanu: it results simply from well-typing ... ignoring co-inductive types.
11:27:41 <Eduard_Munteanu> roconnor: I see. Coming from Agda, extensionality is also a big "if" :)
11:27:50 <roconnor> Eduard_Munteanu: and if you believe in Mahlo cardinals ... and lots of them.
11:28:10 * Eduard_Munteanu doesn't know about those.
11:28:23 <roconnor> Eduard_Munteanu: then you don't know if all Coq functions terminate :D
11:28:24 <Eduard_Munteanu> Coinduction goes through productivity checking.
11:28:26 <tomprince> The structural recursion comes from well typing?
11:28:48 <roconnor> Eduard_Munteanu: in Coq, coinductive types destroys subject-reduction.
11:28:57 <tomprince> It is certainly syntactic.
11:29:03 <roconnor> oh tom is right
11:29:15 <roconnor> coq doesn't enforce structural recursion.
11:29:25 <roconnor> isntead it has this guardedness condition
11:29:40 <roconnor> which is so similar, I forget they are not the same.
11:29:47 <Eduard_Munteanu> So it is an explicit check.
11:30:03 <tomprince> For coinductive types. Which means that the recursive call needs to be hidden behind a constructor of the coinductive type.
11:30:07 <Eduard_Munteanu> (though guardedness sounds like coinduction)
11:30:14 <Eduard_Munteanu> Yeah.
11:30:26 <tomprince> Which is again syntactc (or at least mostly so.
11:30:40 <Eduard_Munteanu> tomprince: but I'm unsure, what typing rules actually prevent you from creating non-terminating terms?
11:31:01 <roconnor> Eduard_Munteanu: coq's guard check on fixpoints is some syntactic wonkery that makes sures that recursive calls are made on some substructor *or* some subsubstructure *or* ...
11:31:26 <Eduard_Munteanu> Is that for normal inductive types?
11:31:49 <hiptobecubic> oh lord. I just discovered -XParallelListComp
11:31:51 <roconnor> Eduard_Munteanu: normal is to only allow recursive calls on immediate substructures.
11:32:02 <Eduard_Munteanu> Sounds a bit like what Agda does (as far as I understand it), namely it checks terms are size-decreasing when recursing.
11:32:13 <hiptobecubic> I have been zipWith (uncurry f)'ing everything
11:32:21 <tomprince> I'm not sure if if it comes from typing. but it is purely syntactic. I guess you could call it a termination checker.
11:32:22 <roconnor> Eduard_Munteanu: what coq allows is more like course-of-values recursion.
11:32:40 <tomprince> I thought agda had more a extensive termination checker.
11:32:52 <MostAwesomeDude> hiptobecubic: I was really hoping that that was automatic parallel execution of the list monad.
11:33:04 <jfischoff> here it is: http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.TerminationChecker
11:33:14 <hiptobecubic> MostAwesomeDude, isn't there some kind of  [: foo :] that does that?
11:33:16 <jfischoff> They sound very similar
11:33:18 <Eduard_Munteanu> Well, you do have to handle cases like   f (suc n) = f (id n)   for example.
11:33:42 <MostAwesomeDude> hiptobecubic: I'm sure there's something in execution strategies, but something automatic would be nice.
11:33:51 <Eduard_Munteanu> (sure you could use well-founded recursion, but it's overkill)
11:34:25 <roconnor> Eduard_Munteanu: f (id n) reduces to f n
11:34:59 <hpaste> srhb pasted “Simple merge sort” at http://hpaste.org/64894
11:35:58 <srhb> I tried factoring out the length check that I was using on every recursive sort, but now my code turned into spaghetti. Am I missing an obvious way of shortening this?
11:37:35 <Eduard_Munteanu> srhb: I guess you could operate on a different structure, like a balanced tree.
11:39:33 * hackagebot memoize 0.2 - A memoization library  http://hackage.haskell.org/package/memoize-0.2 (JesseTov)
11:39:41 <srhb> Eduard_Munteanu: That would certainly make sense.
11:41:06 <Eduard_Munteanu> srhb: it probably won't be shorter, but conceptually nicer.
11:42:13 <hiptobecubic> MostAwesomeDude, http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
11:42:24 <srhb> Eduard_Munteanu: Yeah, that was mostly what I meant to. Lots of where and let and in and mess here.
11:43:14 <ClaudiusMaximus> > partitionEithers $ zipWith ($) (cycle [Left, Right]) "avoiding length, dunno if it'd be better overall"
11:43:15 <lambdabot>   ("aodn egh un fi' ebte vrl","viiglnt,dnoi tdb etroeal")
11:43:59 <jedai> @type random
11:44:00 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
11:46:12 <jacklk> Does Haskell have web and MySQL access?
11:46:57 <Eduard_Munteanu> jacklk: there are bindings to work with MySQL databases. What do you mean by "web" though?
11:47:37 <c_wraith> eh, either way, the answer is yes.  there are web frameworks.  there are web clients
11:47:39 <jacklk> Eduard_Munteanu: I mean, is it a good web programming language
11:47:48 <jacklk> .
11:48:09 <Eduard_Munteanu> In certain ways.
11:48:11 <Eduard_Munteanu> @where yesod
11:48:12 <lambdabot> I know nothing about yesod.
11:48:18 <Eduard_Munteanu> @google yesod
11:48:19 <lambdabot> http://www.yesodweb.com/
11:48:19 <lambdabot> Title: Home Page
11:48:42 <Eduard_Munteanu> jacklk: see that for example ^^
11:48:51 <jacklk> Thank you both. (=
11:49:14 <srhb> jacklk: There's also Happstack and Snap for commonly used web frameworks
11:49:18 <hpaste> ChristianS annotated “Replace strings” with “Replace strings (tiny stylistic suggestions and a question)” at http://hpaste.org/64888#a64895
11:49:44 <jacklk> srhb: I'll look at them too later.
11:50:23 <ChristianS> @tell Na-Fiann see http://hpaste.org/64888#a64895
11:50:23 <lambdabot> Consider it noted.
11:52:28 <aluink> pl \(a,b) (c,d) -> ((a+c),(b+d))
11:52:45 <aluink> @pl \(a,b) (c,d) -> ((a+c),(b+d))
11:52:45 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
11:55:53 <efie> http://learnyouahaskell.com/for-a-few-monads-more#state heading "The State monad" it has to be "... and has a result of type (a,s)", right?
11:57:31 <roconnor> efie: nope
11:57:54 <roconnor> efie: it is talking about what the s and a mean in State s a
11:58:13 <roconnor> efie: but don't get hung up on this
11:58:31 <efie> roconoor: um ok, thanks
12:12:19 <watermind> is any of the haskell IDE's capable of doing type inference/type checking on the fly?
12:12:47 <watermind> or am I asking for way too much?
12:14:26 <ncs> i have a problem with pattern matching
12:14:31 <ncs> if i have these datatypes:
12:14:31 <ncs> data A = A Int B
12:14:31 <ncs> data B = B1 Int String | B2 Int String
12:14:31 <ncs> and i want to define a function of this type:
12:14:31 <ncs> f :: A -> Int -> A
12:14:31 <ncs> then the pattern matching would be like this?
12:14:33 <ncs> f (A x (B1 y s)) n = A x+n (B1 y s)
12:14:35 <ncs> f (A x (B2 y s)) n = A x+n (B2 y s)
12:14:36 * hackagebot spike 0.3 - Experimental web browser  http://hackage.haskell.org/package/spike-0.3 (KrzysztofSkrzetnicki)
12:15:14 <Cale> ncs: there are some missing parens around x+n on the right hand side of each equation
12:15:20 <Cale> other than that, it looks okay
12:15:26 <watermind> I was thinking something like, having a red/yellow/green light on a corner,  red = not-well typed, yellow = well typed, but doesn't match the provided signature yet, red = cannot possibly be  well typed
12:15:43 <Cale> Though, you don't really need to be pattern matching on the B structure here
12:15:55 <Cale> because you do nothing with it, just copy it across
12:15:57 <ncs> i can use the underscore for it?
12:16:24 <watermind> no
12:16:29 <Eduard_Munteanu> ncs: no,  f (A x t) n = A (x+n) t   for example
12:16:30 <watermind> because you need the value
12:16:38 <ncs> oh, yes
12:16:39 <ncs> right
12:18:21 <merijn> watermind: It doesn't exist yet, but many people are interested in working on that sort of thing
12:19:03 <watermind> merijn: I see... I just noticed there were some IDE's I've never tried so had a bit of hope
12:19:15 <watermind> it just feels like we're not taking full advantage of the type system
12:19:37 * hackagebot specialize-th 0.0.0.1 - Create specialized types from polymorphic ones using TH  http://hackage.haskell.org/package/specialize-th-0.0.0.1 (JonathanFischoff)
12:19:39 * hackagebot type-sub-th 0.1.0.5 - Substitute types for other types with Template Haskell  http://hackage.haskell.org/package/type-sub-th-0.1.0.5 (JonathanFischoff)
12:19:50 <merijn> watermind: The problem is that there's no real way to query the compiler for that sort of information (yet, people are working on it)
12:20:51 <merijn> watermind: Or, if want to take it further and you're a masochist who enjoys very formal and dense papers, read up on Epigram
12:24:28 <watermind> merijn: I kind of am, and I should actually, but I've been using my very limited free time to look at agda
12:24:56 <watermind> merijn: and by the way, those agda holes would be nice too...
12:25:55 <watermind> sometimes I just write undefined... but it's not very appealing visually, and I'm always afraid of forgeting about one
12:26:56 <watermind> plus I'd like to be able to do type inference on the hole
12:27:22 <merijn> watermind: Oh, if you're learning Agda then definitely look up Epigram. Their goal is to automatically derive programs from types.
12:27:43 <watermind> merijn: I will for sure...
12:28:09 <watermind> brb
12:28:49 <parcs`> you can simulate agda holes with implicit parameters
12:29:01 <merijn> watermind: I recommend starting with Conor McBride's phd thesis, its far more readable than the Epigram papers if you're new to type theory
12:29:06 <parcs`> @let f x = ?y
12:29:06 <lambdabot>   Parse error: ?
12:29:09 <parcs`> aw
12:29:33 <parcs`> well try that in ghci. you'll get 'unbound implicit parameter: ?x :: Int'
12:29:40 <parcs`> er, f :: Int -> Int; f x = ?y
12:29:44 <merijn> It's called "Dependently Typed Functional Programs and their Proofs"
12:30:43 <parcs`> with ghc 7.5 it's even better because of the new -fdefer-type-errors flag: you'll get the hole, _and_ the rest of the module will compile successfully, allowing you to analyze both the type of the hole and  the bound names of the module at the same time
12:31:39 <roconnor> Eduard_Munteanu: BTW, there is a bigish problem with nix, or at least with nixpkgs.
12:33:34 <roconnor> Eduard_Munteanu: if lib B depends on lib D and lib C depends on lib D, and if application A uses both lib B and lib C, it is usually the case that the build of lib D must be the same for the builds of libs B and C used by A.  Nothing in nixpkgs enforces this at the moment beyond the fact that usually everyone uses the standard build of lib D.
12:38:28 <watermind> parcs`: ah I didn't even think of that, it's been a while since I've used implicit parameters... I thought they had been deprecated?
12:38:52 <zero___> is there any way to print string without the outter "" ?
12:39:08 <dmwit> putStrLn
12:40:27 <zero___> thank you!!!
12:40:37 <merijn> zero___: putStr and putStrLn print strings, "print = putStrLn . show"
12:40:57 <zero___> ohh i get it now..
12:41:18 <watermind> parcs`: also I would you need defer type errors? why wouldn't it be well typed when you use implicit parameters as holes?
12:41:31 <watermind> I may be missing something
12:53:24 <hpaste> ChristianS annotated “Replace strings” with “Replace strings (mapping)” at http://hpaste.org/64888#a64898
13:08:44 <Luke> Does anyone know of anything like incanter (Clojure R-like library) for Haskell? http://incanter.org/
13:11:51 <rostayob> Luke: no. there are good statistics packages
13:12:10 <rostayob> but nothing that combines that with graphics afaik.
13:15:36 <Luke> rostayob: thanks
13:15:51 <Luke> rostayob: you're talking about bos' stats package?
13:18:02 <rostayob> Luke: yes
13:22:18 <blackdog> watermind: ghc-mod for emacs does a bit of that.
13:22:34 <blackdog> you'll at least get highlighting of non-fitting code
13:22:54 <blackdog> the only problem is that you have to stay close to a working program, otherwise you don't get much support
13:25:48 <christian`> Hey everyone .. can someone here answer questions about haddock?
13:26:00 <DanBurton> possibly
13:26:57 <christian`> I have this problem: I documented a module, which contains class instances of some data types. I would like these instances to be visible in the documentation, but haddock does not automatically do that. How can I make it do this?
13:27:47 <nand`> Does anybody ever use foldl as infix? I'm thinking something like “f `foldl` initial somelist” could be easier to read
13:28:14 <christian`> So it's like "data MyData = ..." and then "instance Num MyData where ..."
13:28:32 <christian`> But haddock does not include the fact that MyData is an instance of Num in the documentation ...
13:28:33 <blackdog> nand`: given that you almost always want foldl', `foldl'` could be a bit of a visual roadbump
13:28:48 <shachaf> christian`: It should include that...
13:29:00 <DanBurton> Indeed. Odd that it wouldn't
13:29:09 <christian`> hmm..
13:29:22 <christian`> Anything obvious one can do wrong when using haddock?
13:29:46 <christian`> Anything I must add in the exports, perhaps?
13:29:56 <DanBurton> you're exporting MyData(..)?
13:30:01 <christian`> Yes.
13:30:20 <christian`> hmm .. partly. Sometimes I export only MyData, not MyData(..).
13:31:26 <DanBurton> well I believe if you only export MyData and not its constructors, it should still show the instances
13:31:46 <DanBurton> I'm testing it out right now
13:32:26 <christian`> I could send you a github link to the source, if that helps .. and I'm using "cabal haddock" to build the documentation.
13:34:52 <hpaste> DanBurton pasted “Show Num instance in Haddock” at http://hpaste.org/64899
13:36:38 <aristid> it is annoying that many people make their packages ghc 7.4 only, when the haskell platform still comes with 7.0
13:36:55 <christian`> Ah .. I'm using haddock 2.9.2. Maybe that poses a problem ...
13:37:35 <rostayob> christian`: if you want the type class to be visible in the documentation *only*, you can't do that
13:37:55 <rostayob> exporting only the class but not its method won't prevent the user from doing 'instance Foo a where ...'
13:38:04 <rostayob> actually simply 'instance Foo Bar'.
13:38:15 <christian`> I think the current version does not build with ghc 7.0.3.
13:38:50 <christian`> rostayob: I want to export a data type, and its instances should be visible in the docs.
13:39:36 <rostayob> christian`: well... that happens already if the classes are visible
13:39:54 <rostayob> you don't even need to export the data constructor
13:40:37 <aristid> on os x, when installing ghc 7.4... is it recommended to use 32-bit or 64-bit ghc? :)
13:40:46 <rostayob> christian`: I didn't read the previous messages, what problems are you having?
13:40:50 <christian`> hmm .. it doesn't happen in my case. Does "visible" mean haddock needs to be able to link to documentation of the classes?
13:41:44 <christian`> The classes are partly ones which I export from the same module, and partly classes like Show and Num.
13:41:53 <rostayob> christian`: not even that really. haddock will display instances of non visible classes as well
13:42:12 <christian`> Which version of haddock do you use?
13:42:28 <christian`> I just checked that I use 2.9.2, which seems a little on the old side.
13:42:29 <ChristianS> christian`: what happens if you haddock pasted DanBurton's example? does that work for you?
13:42:35 <rostayob> 2.9.4, but it shouldn't make a difference
13:42:45 <christian`> I'm going to check it .. btw thanks to DanBurton!
13:42:50 <rostayob> christian`: no that's not old
13:42:57 <ChristianS> DanBurton's pasted example*
13:42:57 <axx__> Hi...Question: How to explicitly declare type for funtions? example would be great!!
13:43:17 <DanBurton> > foo :: Int -> Int; foo x = x + 3
13:43:18 <lambdabot>   <no location info>: parse error on input `;'
13:43:26 <DanBurton> > let foo :: Int -> Int; foo x = x + 3 in foo 5
13:43:27 <lambdabot>   8
13:43:43 <DanBurton> axx__: something like that ^
13:44:12 <rostayob> axx__: in a source file you can just write "foo :: Int -> Int; foo x = x + 3", where ";" is a newline
13:47:07 <watermind> blackdog: thanks for the suggestion, I didn't know that
13:47:58 <Peaker> roconnor: I read the #haskell logs after I left -- I see your correction, it is indeed my mistake. thanks!
13:48:32 <Peaker> roconnor: I wrote * -> []   when it was (X : *) -> (Y : [])
13:48:35 <roconnor> Peaker: sorry I didn't pick up on it right away.
13:48:56 <roconnor> Peaker: this area gets a little confusing
13:49:02 <Peaker> roconnor: Very confusing for me :-)
13:49:06 <axx__> Thanks
13:49:06 <christian`> rostayob: No, haddock does not show the instances.
13:49:26 <christian`> DanBurton: Thanks for the example! It did not work with my local haddock.
13:49:28 <Peaker> like everything else, probably takes some practice.. or "the feeling of confusion is you learning stuff" :)
13:49:33 <blackdog> watermind: no worries. i really like ghc-mod, and i don't think it gets as much use as it ought to.
13:49:39 <roconnor> Peaker: I would hesitate to use the notation (X : *) -> (Y : []) since it usually means something different.
13:49:47 * hackagebot zeromq3-haskell 0.1.4 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.1.4 (ToralfWittner)
13:49:57 <christian`> I.e., it did create documentation, but does not show the instances.
13:49:58 <blackdog> only caveat is that it autosaves your code so it can check it. would be nicer if it could use a shadow directory or something.
13:50:51 <axx__> thanks DanBurton, rostayob
13:51:38 <DanBurton> christian`: how odd. I wonder if there are some global haddock preferences that you've somehow mucked up? I have no idea if such is the case.
13:52:10 <Peaker> roconnor: what does it usually mean?
13:52:51 <roconnor> Peaker: in Agda, (a:A) -> B means Pi a:A. B
13:53:00 <roconnor> aka forall a:A. B
13:53:33 <roconnor> Peaker: granted what you wrote wasn't the same as that, but it is disturbingly close.
13:53:39 <Peaker> Yeah, I understand
13:53:41 <roconnor> Peaker: and incompatible.
13:54:14 <roconnor> I wouldn't be surprized if the Adga notation becomes popular.  It is easier on the eyes.
13:54:45 <christian`> DanBurton: I am going to search for some haddock settings .. thanks for your assistance!
13:54:49 * hackagebot cabal-nirvana 0.1 - Avoid Cabal dependency hell by constraining to known good versions.  http://hackage.haskell.org/package/cabal-nirvana-0.1 (MichaelSnoyman)
13:55:31 <Peaker> roconnor: the thing making augutuss's blog post so accessible is use of ascii Haskell (with just a few alphas/betas thrown in)
13:56:00 <Peaker> I saw various other papers about DT and such and they're really hard to read if you're not used to the weird notations
13:56:16 <roconnor> :)
13:56:58 <rostayob> I *love* Agda's syntax in every aspect
13:57:29 <dolio> I don't love ([ x ] , [ y ])
13:57:30 <rostayob> it's definitely the feature which is more portable to "practical" programming languages
13:57:36 <rostayob> dolio: yes that's the price to pay
13:57:45 <dolio> But it might be worth it.
13:57:47 <roconnor> dolio: what is that?
13:57:50 <rostayob> I think it is
13:57:52 <edwardk> ([ x ], [ y ]) ?
13:57:54 <rostayob> roconnor: you have to put spaces
13:58:00 <dolio> roconnor: [x],[y] is a single identifier.
13:58:05 <edwardk> ick
13:58:07 <roconnor> ah
13:58:14 <edwardk> oh, agda
13:58:25 <rostayob> well that's why you're able to assign whatever names
13:58:31 <roconnor> I'm an epigram2 person myself.
13:58:47 <rostayob> never touched epigram, but emacs + agda is a joy
13:58:54 <roconnor> I get to imagine whatever I want it to be.
13:59:00 <dolio> It might be possible to strike a better balance.
13:59:04 * roconnor sighs
13:59:05 <adimit> If I want to install cabal-install (using bootstrap.sh) and I've got zlib in a non-standard location (not the admin on that machine) how do I tell the configure script where to find zlib? Is there an environment variable I can set, or do I have to edit the bootstrap.sh script?
13:59:24 <rostayob> dolio: I am almost never annoyed by that limitation tbh. but still I don't write that much agda.
13:59:37 <DanBurton> cabal-nirvana looks interesting. I wonder where this magic list of "known compatible versions of libraries" comes from
13:59:39 <edwardk> i usually don't like using a third person library with agda, all the symbol matching, etc. makes writing it fluidly awkward, but part of that i admit is my relative inexperience with that typing style
13:59:53 <edwardk> its just annoyingly modal to keep selecting the next arrow type until i see the one i want
14:00:00 <alpounet> adimit, i did that once, and just modified the boostraph.sh script
14:00:16 <adimit> alpounet: thanks. I thought there'd be a more elegant solution :-)
14:00:21 <adimit> but that'll do.
14:00:27 <rostayob> edwardk: working with the stdlib I almost never had that problem
14:00:29 <roconnor> I imagine epigram2 to be beautiful 2-D unicode layout where you never actually enter any code directly, and instead simply issue commands to refine types into terms.
14:00:38 <roconnor> Mmmm
14:00:54 <alpounet> adimit, there might be, but i didn't feel like spending too much time on that, as long as I got something that worked
14:01:02 <rostayob> roconnor: wait is epigram2 some mythical vaporware?
14:01:09 <dolio> roconnor: It's actually horrible ascii art that allegedly looks like your beautiful 2D typeset layout.
14:01:10 <roconnor> rostayob: sort-of
14:01:35 <roconnor> rostayob: don't let pigworker know I said that.
14:01:55 <dolio> He might agree that it's vaporware.
14:01:56 * rostayob can blackmail roconnor now
14:02:26 <RichyB> Isn't #haskell publicly logged? Good luck with the secrecy when this place shows up in Google searches, roconnor. :)
14:02:42 <rostayob> roconnor: damn he got you
14:02:53 <roconnor> Isn't google blocked in the UK?
14:03:12 <edwardk> rostayob: not saying that my experience is typical, but almost any library written by NAD has caused me to recoil, then stumble through using the operators =P
14:03:16 <adimit> alpounet: ah, in the script it actually says it: you can pass options to configure by setting EXTRA_CONFIGURE_OPTS
14:03:32 <MostAwesomeDude> Epigram looks a whole lot, to me, like Coq with different syntax. Is there more to it that I'm not seeing?
14:03:41 <rostayob> edwardk: NAD = Nils ... right? one of the core devs
14:03:42 <dolio> Yes.
14:03:48 <edwardk> i used to be a huge proponent of unicode syntax everywhere, then i used agda ;)
14:03:54 <roconnor> MostAwesomeDude: way way more
14:04:38 <MostAwesomeDude> Oh. Okay.
14:04:42 <roconnor> MostAwesomeDude: no one can tell you what Epigram is.  You need to experience it for yourself.
14:04:52 <MostAwesomeDude> Haha, what.
14:04:59 <roconnor> MostAwesomeDude: or you can just read "The View from the Left (unpublished)"
14:05:11 <DanBurton> @remember edwardk says: i used to be a huge proponent of unicode syntax everywhere, then i used  agda ;)
14:05:12 <lambdabot> Nice!
14:05:29 <dolio> View from the Left only gets you to Epigram 1 or so, though.
14:05:41 <dolio> There's a bunch of work on theory stuff for Epigram 2.
14:05:42 <rostayob> edwardk: I like it! ehe
14:05:48 <dolio> And they keep rewriting it from scratch.
14:05:50 <MaybeJust> i got kicked out of #math for telling a math joke, is that really allowed?7
14:06:10 <DanBurton> irc is a very serious place. no jokes allowed >.>
14:07:44 <edwardk> MaybeJust: yep\n/kick MaybeJust
14:08:06 <roconnor> dolio: I think the view from the left bit is even more imporant than the observation type theory bit of epigram 2
14:08:31 <roconnor> MaybeJust: #math keeps telling me to do my own homework when I ask questions.
14:08:38 <roconnor> :(
14:08:40 <edwardk> roconnor: hah
14:09:00 <roconnor> Is every ordered field of characteristic 0?
14:09:05 <roconnor> ... do your own homework!
14:09:13 <roconnor> well, that didn't really happen
14:09:16 <Peaker> edwardk: I don't see why people want unicode in their syntax, in general
14:09:18 <Dashkal> mmm, hostile IRC channels
14:09:22 <edwardk> roconnor: yes
14:09:30 <Peaker> unicode is really complicated (e.g: right-to-left languages), too
14:09:30 <rostayob> I would have never thought there was a #math.
14:09:33 <roconnor> edwardk: thanks!
14:09:40 <roconnor> edwardk: I figured.
14:09:43 <edwardk> =)
14:09:58 <edwardk> thats the difference between #haskell and #math ;)
14:09:59 <dolio> roconnor: Then why aren't you just using Epigram 1?
14:10:07 <roconnor> dolio: emacs
14:10:11 <edwardk> here the math is just assumed
14:10:22 <roconnor> dolio: I cannot get help and backspace working at the same time.
14:10:32 <dolio> Also, observational type theory isn't the only new stuff.
14:10:34 <roconnor> dolio: or at least I had that problem when I last tried in 1995
14:10:40 <roconnor> oh wait
14:10:43 <edwardk> now ask in #agda, and you'll get 5 people trying to figure out how to prove that in agda rather than answer the question
14:10:43 <dolio> There's all the generic programming stuff.
14:10:51 <roconnor> when I last tried 2 years ago, none of the drop-down menus worked.
14:10:57 <rostayob> edwardk: 5 people? that's a crowd
14:10:57 <dolio> Which may lead to ornaments and stuf.f
14:11:17 <roconnor> dolio: that's true
14:11:24 <dolio> So that you don't have to rewrite the same data type 500 times for every program to get nice behavior.
14:11:25 <roconnor> dolio: I still think the view from the left is more important ...
14:11:25 <edwardk> rostayob: its a lot more populated in there than it used to be
14:11:32 <dolio> To successfully use your view from the left style programming.
14:11:40 <rostayob> edwardk: I've been visiting
14:11:44 <roconnor> dolio: but maybe this is because I've never really used the view from the left style of programming.
14:11:45 <rostayob> #agda only lately :)
14:12:10 <roconnor> dolio: I vaugely use it in Coq a little issy bit
14:12:43 <nand`> edwardk: ask in ##c and you'll get a “who cares”
14:12:52 <DanBurton> whoa big discussion about ease of installing Yesod/HP https://plus.google.com/116553865628071717889/posts/WFPfB3M5C1Q
14:12:54 <roconnor> dolio: actually I had this horrible talk with James about how great his paper is and how I now write my own elimination principles without data types in Coq.
14:13:07 <rostayob> nand`: you'll get that in most IRC chans
14:13:10 <roconnor> dolio: and he said, no no, the point was to write inductive data types to generate the elimination principles for you!
14:13:20 <edwardk> nand`: ask in javascript and people will start sobbing uncontrollably about the bad things their math teacher made them do in gradeschool.
14:13:25 <edwardk> nand`: its a continuum ;)
14:13:40 <nand`> rostayob: I was tempted to write “mainstream programming channel” but I didn't want to enforce the notion that haskell is obscure
14:13:50 <roconnor> dolio: I thought the point was to not write the data types and just write the elimination principles.
14:14:16 <dolio> roconnor: Well, someone mentioned in response to glguy's talk on well founded recursion....
14:14:31 <rostayob> nand`: I think we can safely classify agda as "oscure"
14:14:38 <dolio> That Conor thinks you should never use well founded recursion, just use a data type such that structural recursion is the right thing.
14:14:44 <rostayob> not in the sense of "hard" but it's completely alien to mainstream programming
14:14:46 <dolio> Which is similar.
14:15:18 <dolio> Bake the right proofs into your data type such that structural recursion via dependent pattern matching just naturally gives the right solution.
14:15:35 <rostayob> dolio: isn't that an incredible pain?
14:15:37 <nand`> In the sense of “nobody this side of the moon uses it”
14:15:39 <dolio> If I'm not mistaken on the point.
14:15:48 <roconnor> dolio: yep
14:15:57 <dolio> But, that means you have to rewrite lists with different proofs baked in depending on what you want to do.
14:15:59 <dolio> Which sucks.
14:16:25 <roconnor> dolio: I don't think it necessarily means that.
14:16:28 <rostayob> dolio: yeah that's what I was thinking
14:16:41 <rostayob> e.g. encode the notions of "sorted" in the datatype
14:16:51 <dolio> So I think you really want his ornaments and generic programming to program that way.
14:17:03 <dolio> To actually get code reuse.
14:17:04 <rostayob> isn't it much more convenient to carry around the list and the proof?
14:17:26 <dolio> It's more convenient in some ways and less in others.
14:17:38 <roconnor> dolio: I mean, to sort a list you convert the list into a tree and do either merge sort or tree sort depending on the type of tree you use.
14:18:02 <roconnor> dolio: basically you preprocess your data before recursion
14:18:22 <roconnor> dolio: which isn't extra work, it is more like separating out the preprocessing step that normally is folded into the recursive function.
14:18:33 <rostayob> dolio: well, you can for example have a treesort and do structural recursion on that, but you're going to need a way back and from to lists at some point to do something useful
14:18:35 <roconnor> dolio: breaking the hylomorphism into its pieces.
14:19:47 <dolio> How do I do this: enumFromTo m n | m < n = m : enumFromTo (m+1) n | otherwise = []?
14:21:06 <rostayob> dolio: you get the difference first and you count until n is 0?
14:21:16 <rostayob> and map (+m)
14:21:18 <magicman> The next DJ is Haplo, and they're on from Tue Mar 06 20:00 EST until Tue Mar 06 21:59 EST.
14:21:22 <magicman> Durnit.
14:21:27 <magicman> Sorry for that v_v
14:21:32 <rostayob> go DJ Haplo
14:21:48 <dolio> rostayob: I don't want a solution that does way more work.
14:22:53 <dolio> Counting down on n builds the entire list in memory up front.
14:23:46 <rostayob> dolio: you provide a proof of 'm <= n' instead of the two arguments?
14:24:11 <rostayob> the base case will be when they're equal, and you return []
14:24:17 <watermind> I get this when trying to cabal install ghc-mod,    "Cabal.hs:65:61: Not in scope: type constructor or class `Language'"
14:24:20 <roconnor> dolio: I would call a helper function which does enumFromLen m e  that produces [m , ... , m + e]
14:24:31 <watermind> what's the problem here? do I need ghc 7.x ?
14:24:31 <roconnor> dolio: this would be even faster than the code you wrote
14:24:41 <watermind> I'm still on 6.12.3
14:24:56 <dolio> roconnor: How would it build it?
14:24:56 <roconnor> dolio: becuase your code compares m with n on *every* recursive call.
14:25:24 <dolio> I want the list to be produced on demand.
14:25:24 <roconnor> dolio: enumFromLen m e is easy to do by recursion on e (assuming nats here).
14:26:20 <rostayob> dolio: the list is produced on demand that way
14:26:52 <roconnor> dolio: and then enumFromTo m n = case n - m of | Pos e  -> enumFromLen m e | _ -> []
14:26:58 <roconnor> or something like that
14:27:16 <rostayob> (roconnor solution is equivalent to mine but simpler)
14:28:05 <roconnor> (recall n - m is equavlent to the caculation of n < m, but loses less information).
14:28:34 <rostayob> since you probably have some function that gives you either <= or not I think that providing a proof of 'm <= n' is even simpler
14:28:39 <dolio> roconnor: I don't know what your algorithm is. Is it using an accumulator?
14:28:50 <dolio> Because if it is, then it's not producing the list on demand.
14:29:13 <dolio> It's building it up from the rear.
14:29:18 <roconnor> dolio: enumFromLen m 0 = [] ; enumFromLen m (S e) = m : enumFromLen (S m) e
14:29:39 <dolio> Oh, okay.
14:29:52 * hackagebot cabal-nirvana 0.1.0.1 - Avoid Cabal dependency hell by constraining to known good versions.  http://hackage.haskell.org/package/cabal-nirvana-0.1.0.1 (MichaelSnoyman)
14:31:35 <dolio> Now do fibonacci numbers. :)
14:31:43 <dolio> Or primes.
14:32:04 <roconnor> dolio: I need coinductive types for that.
14:32:12 <dolio> Why?
14:32:13 <rostayob> dolio: you mean fibonaccis up to n?
14:32:18 <dolio> Yes.
14:32:28 <rostayob> why is that a problem?
14:32:51 <roconnor> dolio: map nthFib (enumFromLen 0 n)
14:33:27 <dolio> It's probably not a problem.
14:33:59 <dolio> Except you're stepping up by a non-uniform positive amount each time.
14:34:29 <roconnor> nthFib n = fst (nthFibH n) where
14:35:00 <dolio> So you need to subtract from your equivalent of e, instead of just structurally decreasing.
14:35:03 <dolio> So make a new data type.
14:35:05 <roconnor> nthFibH 0 = (0,1);  nthFibH (S n) = let (a,b) = nthFibH n in (b, a+b)
14:35:53 <roconnor> dolio: oh you want to tie a knot.
14:35:55 <dolio> You don't seriously think I'm going to accept map nthFib [0..n] do you?
14:36:01 <roconnor> ah
14:37:44 <gregATio> trying to compile ghc from source
14:37:50 <roconnor> fibList n = fibListH 0 1 n where fibListH _ _ 0 = [];  fibListH a b (S n) = a:fibListH b (a+b) n
14:37:59 <gregATio> and when i run make after running perl boot
14:38:24 <dolio> roconnor: Oh, also, I don't want the first n fibs, I want the fibs less than n.
14:38:41 <roconnor> oh
14:38:43 <rostayob> dolio: oh that's different
14:39:04 <dolio> A cheating way would be takeWhile (< n) (nthFib [1..n]), since you know the nth fib is less than n.
14:39:08 <roconnor> that is complicated
14:39:08 <dolio> But that's no good.
14:39:24 <dolio> Er, the nth fib is greater than n.
14:39:45 <gregATio> its complaining about an old version of Alex, wtf is Alex?
14:39:53 <dolio> Alex is a lexer generator.
14:39:55 <rostayob> gregATio: Haskell's lexer generator
14:40:51 <dolio> roconnor: I think you need to keep the difference around, so fibs (fn-1) (fn) (fn+1) acc = ...
14:40:52 <rostayob> dolio: I see how a data family helps in that case
14:41:17 <gregATio> cool, i think im getting the later version through cabal
14:41:18 <dolio> But then you still don't know that you can recurse merely because fn-1 > 0 and you're going from acc to acc - fn-1.
14:41:55 <dolio> I'm not sure what the simple structural solution is.
14:42:33 <dolio> Once you prove that counting up to a finite value is valid well-founded, though, you can just do it.
14:43:40 <rostayob> you can have a data family indexed by the two greatest numbers in the series
14:43:45 <rostayob> and the start is with 0 and 1
14:44:37 <dolio> Anyhow, a simple example is....
14:44:46 <copumpkin> can't you just use tabulate to count up?
14:44:49 <copumpkin> or did I miss context
14:45:00 <gregATio> oh and how does one install hoogle , is it cabal install hoogle?
14:45:07 <rostayob> copumpkin: you can't use tabulate when generating fibonacci numbers
14:45:08 <gregATio> or is it haddock?
14:45:13 <rostayob> well
14:45:26 <copumpkin> oh, you're talking about writing fibs nicely in agda or similar?
14:45:34 <rostayob> copumpkin: precisely
14:45:35 <copumpkin> it can get tricky
14:45:43 <copumpkin> you need well-hung coinduction for it
14:45:47 <dolio> Σ n:Nat (n < m)  is isomorphic to Fin m.
14:46:14 <rostayob> copumpkin: not an infinite generator, just fibs up to n
14:46:20 <copumpkin> oh
14:46:21 <monochrom> well-hung? :)
14:46:23 <dolio> But, you may have to rewrite every arithmetic operation on Fin m instead of just getting it for the former.
14:46:24 <copumpkin> why not infinite?
14:46:25 <rostayob> (in the sense up to the greates fibs less than n)
14:46:34 <copumpkin> monochrom: yeah, xplat's coined term for the counterpart to well-founded induction
14:46:39 <dolio> copumpkin: Infinite list of fibs is too easy.
14:46:44 <rostayob> copumpkin: because it's trickier
14:46:51 <copumpkin> rostayob: really?
14:46:59 <exFalso> haha
14:47:14 <copumpkin> just run take on your infinite stream of fibs and get your finite one!
14:47:14 <copumpkin> :P
14:47:31 <rostayob> copumpkin: well the tricky part here is to prove termination
14:47:38 <dolio> copumpkin: fibs = gofibs 0 1 ; gofibs x y = x : gofibs y (x + y)
14:47:44 <copumpkin> oh, that thing
14:47:57 <dolio> copumpkin: Writing takeWhile on your infinite stream is the hard part.
14:48:18 <copumpkin> not if you use the magic ascending stream type I wrote
14:48:25 <copumpkin> but I'm not sure where that is now
14:48:32 <dolio> Well, that's the other point.
14:48:39 <dolio> You wrote an extra type to carry the proofs you want.
14:48:45 <copumpkin> :P
14:48:58 <dolio> Which sucks, because now you have to reimplement everything in Data.Stream for your new type.
14:49:04 <copumpkin> pfft
14:49:10 <dolio> Unless you have ornaments or something.
14:49:15 <dolio> Which no one does.
14:49:15 <copumpkin> I totally do
14:49:21 <rostayob> copumpkin: this whole thing started because Conor uses structural induction exclusively, making ad-hoc datatypes depending on the context
14:49:24 <copumpkin> Conor's my buddy and he sends me the good shit
14:49:28 <rostayob> eheheh
14:51:17 <Saizan> we should implement our own epigram
14:51:33 <copumpkin> either way, you can prove separately that your generated stream is ascending (I think) and then run a monotonic takeWhile on that
14:52:29 <dolio> copumpkin: Yes, but that's against Conor's structural-recursion-only policy.
14:52:50 <merijn> Newbie PLT syndrome, the name Conor McBride wakes you up in the middle of the night sweating and screaming...
14:53:16 <c_wraith> is he pigworker on reddit/so?
14:53:22 <rostayob> c_wraith: he's on so
14:53:25 <rostayob> and on reddit actually
14:53:30 <c_wraith> the question was the name. :P
14:53:36 <etpace> Does anyone know of an example where typing a mutually recursive group polymorphically (as opposed to monomorphically, and then generalising as a group) causes bugs?
14:53:45 <merijn> c_wraith: He's pigworker on twitter/freenode, so I figure yes?
14:53:52 <merijn> If his comments are remotely legit
14:53:52 <c_wraith> merijn: thanks :)
14:54:35 <dolio> Even an ascending stream probably isn't enough to do takeWhile structurally. You need to somehow structurally encode the well-foundedness of takeWhileing on the monotone stream.
14:54:51 <rostayob> dolio:  what about something like this
14:54:54 <rostayob> data Fib : ℕ → ℕ → Set where
14:54:56 <rostayob>   start : Fib 0 1
14:54:58 <rostayob>   next  : ∀ {n m} → Fib n m → Fib m (n + m)
14:55:18 <copumpkin> why is this in #haskell, by the way? :P
14:55:20 * merijn is in a quantum superstate of simultaneously understanding and not understanding anything of this conversation
14:55:59 <merijn> copumpkin: To prevent people from think haskell is a language used by Real Programmers rather than PLT enthousiasts :)
14:56:03 <copumpkin> oh ok
14:56:07 <merijn> s/think/thinking
14:56:20 <dolio> I forget what led into it exactly.
14:56:32 <rostayob> me saying that Agda syntax is nice
14:56:35 <Peaker> augutuss's lambda cube work is really great
14:57:11 <dolio> Oh, I think it was Russel saying that he thought View from the Left was more important than the OTT stuff, and I said that I think that the ornaments and generic programming stuff is important for actually doing View from the Left style programming.
14:57:12 <merijn> rostayob: Compared to what? :p
14:57:27 <merijn> The only other contenders are Coq and Epigram, and that's hardly a contest...
14:57:49 <dolio> And he was talking about that because of what Peaker said.
14:57:59 <rostayob> merijn: compared to whatever programming language
14:58:26 <dolio> Epigram is pretty swanky when typeset.
14:58:44 <rostayob> yeah but the ascii representation looks pretty ugly from what I've seen
14:58:49 <dolio> Yeah.
14:58:52 <merijn> dolio: Yes, because I always code in a terminal that outputs fancy LaTeX characters :p
14:59:37 <dolio> If I could, I would.
14:59:57 <merijn> You'd first have to implement a nice way of inputting unicode
15:00:09 <dolio> Epigram doesn't use unicode.
15:00:21 <dolio> It's 2 dimensional ascii art.
15:00:29 <dolio> That gets rendered into nice latex.
15:00:36 <merijn> dolio: A terminal doing fancy LaTeX characters is wasted without unicode
15:00:37 <shapr> LaTeX fetish, eh?
15:00:54 <merijn> (I want something like the fancy Chinese input methods that supports LaTeX for unicode input)
15:00:58 <rostayob> I don't like that idea. I'd like the source code to be nice as well
15:01:12 <rostayob>      (         !       (          !   (  n : Nat  !
15:01:15 <rostayob> data !---------! where !----------! ; !-----------!
15:01:17 <rostayob>      ! Nat : * )       !zero : Nat)   !suc n : Nat)
15:01:19 <rostayob> really?
15:01:46 <dolio> Won't be using proportional fonts for that.
15:01:48 <MostAwesomeDude> Obviously it should be "succ" instead of "suc."
15:02:06 <rostayob> MostAwesomeDude: in TT it's usually suc.
15:02:23 <MostAwesomeDude> rostayob: Yeah, I know. Was trying to make a joke.
15:02:27 <rostayob> ah. sorry.
15:02:30 <MostAwesomeDude> I notice I'm a lot less funny in this channel. :c
15:02:35 <merijn> :D
15:02:56 * DanBurton chuckled at the joke
15:02:58 <merijn> The best humor requires a PhD (or more than one!) to understand :p
15:03:19 <dolio> rostayob: At least you don't have to draw the boxes by hand. :)
15:03:25 <rostayob> MostAwesomeDude: I like succ better as well
15:03:47 <dolio> Well, as long as you use xemacs.
15:04:33 <rostayob> xemacs.
15:05:01 <rostayob> is xemacs even alive?
15:05:12 <srhb> Not when I last checked in 2002.
15:06:28 <DanBurton> @faq can Haskell resuscitate xemacs?
15:06:28 <lambdabot> The answer is: Yes! Haskell can do that.
15:06:32 <Saizan> etpace: the problem is that doing generalization any earlier means not having collected all the constraints and so ending up with types that are too polymorphic
15:07:08 <roconnor> dolio: sorry, I got distracted.
15:07:13 <dolio> No problem.
15:07:50 <roconnor> dolio: I was going say that getting the fibs less than n relies on the fact that the sequence isn't a very slow growing sequence.
15:08:01 <etpace> I agree Saizan, I'm trying to find a concrete example for my writing
15:08:11 <etpace> I remember doing this a few months back when it bit me the first time, and I lost it :(
15:08:33 <roconnor> dolio: for example, imagine taking the inverse ackerman upto n.
15:08:48 <roconnor> dolio: this function won't be primitive recursive, so you need sufficent induction.
15:09:49 <dolio> roconnor: You can make my objection more abstract, I think.
15:09:50 <roconnor> dolio: My larger point is that the fact that takeWhile (< n) fibs terminates is a non-obvious fact.
15:09:54 <Saizan> etpace: something like this? let foo 0 = 0; foo n = length (foo (n-1)) + n
15:10:25 <dolio> roconnor: You can have streams, and prove that a particular stream is strictly increasing, and that takeWhile on a strictly increasing stream is well-founded.
15:10:38 <roconnor> dolio: fibs isn't strictly increaseing.
15:10:52 <dolio> Start from 1, 2, then.
15:11:34 <dolio> Or you can build a type of streams that can have takeWhile run on them for the right type of predicate.
15:11:46 <etpace> hmm.. that could work, thanks Saizan
15:12:06 <dolio> But then you need to reimplement all basic stream operations that make sense from scratch.
15:13:26 <roconnor> dolio: in order to get an elegant structurally recursive function producing fibs, I need an elegent proof of termination.
15:14:39 <roconnor> dolio: I can easily write a function that produces fibsLessThan n that simply aborts after n-1 elements by using a counter.
15:14:50 <roconnor> dolio: but that is effectively using well-founded recursion.
15:14:57 <dolio> Yes.
15:16:59 <dolio> You can fake anything that way, I guess.
15:17:24 <dolio> If you can get a sufficiently productive large number generator, it will be indistinguishable from general recursion in practice.
15:18:07 <dolio> Just have it make a number big enough that ultrafinitists will say it doesn't exist.
15:18:12 <roconnor> when you do this, it just shuffles all the hard work into proving that your result is correct.
15:19:04 <roconnor> what would pigworker do
15:29:59 <dolio> I'm not sure you can make a large number generator that productive, either.
15:30:20 <dolio> Is exponentiation good enough?
15:36:06 <roconnor> huh?
15:36:23 <roconnor> dolio: huh?
15:37:36 <navaati> hi
15:37:52 <dolio> roconnor: You need to produce an N such that you can reliably peel off an S whenever you need it without spinning for a really long time.
15:38:19 <tgeeky> dolio: N, S :: ?
15:38:26 <navaati> is loop fusion and deforestation done on classical haskell list, or do i need to use a variant of them ?
15:38:57 <roconnor> dolio: I think it isn't so hard, IIRC
15:39:58 <roconnor> let me think
15:40:28 <tgeeky> roconnor: Is N an Natural and S a Successor?
15:40:56 <roconnor> I mean exp 0 = 1; exp (S n) = 2 * exp n
15:42:36 <Saizan> navaati: fusion is done on the functions rather than on the types, anyhow most ones from Data.List can fuse
15:43:06 <navaati> ok, thanks
15:43:17 <navaati> do you think scanl can ?
15:43:30 <roconnor> so exp 3 = 2 * exp 2 = exp 2 + 1 * exp 2 = 2 * exp 1 + 1 * exp 2 = exp 1 + 1* exp 1 + 1 * exp 2 = exp 0 + 1 * exp 0 + 1 * exp 1 * 1 + 1 * exp 2  = 1 + 1 * exp 0 + 1 * exp 1 * 1 + 1 * exp 2
15:43:40 <roconnor> dolio: hmm, doesn't look all that great
15:43:56 <roconnor> :/
15:44:13 <roconnor> oh I'm doing this all wrong.
15:45:10 <shapr> me too, except I'm doing trig
15:45:40 <Saizan> navaati: there doesn't seem to be a RULE for it, so i don't think so
15:45:56 <navaati> :/
15:46:10 <Martty> roconnor: what are you trying to do? the series expansion of exponential?
15:46:23 <roconnor> Martty: lazy evaulation of exp
15:46:26 <Martty> oh ok
15:46:38 <roconnor> dolio: the common trick in coq is to write, using continuations, expFix n : (a -> a) -> (a -> a)  where expFix n f = iterate f (2^n) times.
15:46:43 <roconnor> dolio: lets see
15:46:48 <roconnor> It was something like
15:46:54 <roconnor> expFix 0 = id
15:47:08 <roconnor> expFix (S n) = expFix n . expFix n
15:47:30 <roconnor> dolio: good enough?
15:48:26 <roconnor> > let expFix 0 = id; expFix (n + 1) = expFix n . expFix n in expFix 3 f
15:48:27 <lambdabot>   <no location info>: Parse error in pattern
15:48:34 <roconnor> > let {expFix 0 = id; expFix (n + 1) = expFix n . expFix n} in expFix 3 f
15:48:35 <lambdabot>   <no location info>: Parse error in pattern
15:48:53 <roconnor> > let {expFix 0 = id; expFix n = expFix (n - 1) . expFix (n - 1)} in expFix 3 f
15:48:54 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:48:54 <lambdabot>    `GHC.Show.Show a'
15:48:55 <lambdabot>      a...
15:49:03 <roconnor> > f . f
15:49:03 <lambdabot>   No instance for (GHC.Show.Show (f b))
15:49:03 <lambdabot>    arising from a use of `M6356410496...
15:49:10 <roconnor> > f
15:49:11 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:49:11 <lambdabot>    `SimpleReflect.FromExpr ...
15:49:20 <roconnor> > f x
15:49:21 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:49:21 <lambdabot>    `GHC.Show.Show a'
15:49:21 <lambdabot>      a...
15:49:25 <roconnor> > x
15:49:26 <lambdabot>   x
15:49:45 <roconnor> > foldr ($) x [f,g]
15:49:46 <lambdabot>   f (g x)
15:49:54 * roconnor is confused.
15:50:07 <roconnor> > f $ x
15:50:08 <lambdabot>   Ambiguous type variable `b' in the constraints:
15:50:08 <lambdabot>    `SimpleReflect.FromExpr ...
15:50:45 <dolio> roconnor: Yeah, that's probably all right.
15:51:24 <tgeeky> dolio: I think that's derived and implemented in one of Hinze's stream papers
15:52:09 <roconnor> dolio: in Coq you go on to prove that expFix n f is equal to iterate f (2^n) and then prove that 2^n is a big enough bound to do whatever you are trying to do.
15:52:23 <dolio> Sure.
15:52:50 <dolio> roconnor: I was thinking more like, "I can interpret Agda in Agda for enough steps to reach the heat death of the universe" or something.
15:53:00 <dolio> By counting down from Ack(4,4).
15:53:46 <dolio> Except Ackermann doesn't have the nice peeling property.
15:54:29 <dolio> Maybe 4,4 is too small, too.
15:54:35 <dolio> But you get the idea.
15:57:10 <roconnor> dolio: I don't know how to get better than exponential;  I'd try higher-order continuations.
15:58:06 <MostAwesomeDude> Hey, I have a [Token] and want to get another [Token], by combining certain Tokens with other Tokens. I kind of want some sort of fold/map thing, but have been told that writing my own recursion is iffy. Is there a builtin function that can do this sort of work?
15:58:57 <tgeeky> MostAwesomeDude: http://www.haskell.org/hoogle/?hoogle=%5BToken%5D+-%3E+%5BToken%5D
15:59:35 <rostayob> MostAwesomeDude: you haven't really described what your function does.
15:59:55 <strager> MostAwesomeDude: Combine how?
16:00:11 <strager> Does it [conditionally] combine adjacent tokens?
16:00:16 <MostAwesomeDude> rostayob: It's a stream of tokens from a parse. Some tokens really trivially combine with tokens ahead of/behind them.
16:00:20 <jfischoff> it is so hard to resist the urge to be snarky
16:00:20 <strager> If so, a standard fold will work.
16:00:21 <tgeeky> rostayob: I, for one, hope that it lets you counterfeit arcade tokens. Then I'll rue the day. As long as that day is in the 1980s.
16:00:23 <DanBurton> MostAwesomeDude: anything that can be done to a list can be done with "fold"
16:00:26 <jfischoff> paste an example
16:00:30 <strager> Assuming only one item lookahead
16:00:39 <DanBurton> the only catch is that you may end up with additional bookkeeping along with your result
16:01:02 <rostayob> DanBurton: in fact, lists themselves can be seen as fold functions
16:01:15 <MostAwesomeDude> Yeah, I'm not sure how to do that bookkeeping.
16:01:36 <strager> One hack is to fold over a tuple, where the tuple contains the extra data =]
16:01:37 <rostayob> MostAwesomeDude: use fold with a tuple (a, [Token]) as the accumulator
16:01:50 <strager> Er, fold with the tuple as the accumulator
16:02:11 <jfischoff> tuple FTW
16:02:14 <rostayob> MostAwesomeDude: but defining a dedicated function is much better
16:02:23 <MostAwesomeDude> Sort of like s -> (a, s) State style?
16:02:23 <strager> MostAwesomeDude: Manual recursion will work nicely if you have specific patterns you want to transform.  You can match using : (list cons).
16:02:35 <tech2> ah, the late 80's and early 90's, awesome arcade cabinets abound.
16:03:10 <DanBurton> MostAwesomeDude: I concur with stranger. Write it with manual recursion first, and then post it and ask if it would be more cleanly expressed as a fold, map, or filter
16:03:15 <strager> strager*
16:03:24 <DanBurton> yes that
16:03:26 <rostayob> MostAwesomeDude: no. you use foldr with a function '(Token -> (a, [Token]) -> (a, [Token])'
16:03:35 <rostayob> you do the bookkeeping with 'a'.
16:03:59 <MostAwesomeDude> Hm. Alright.
16:04:09 <MostAwesomeDude> I guess this is still a little hard to wrap my head around.
16:04:17 <rostayob> MostAwesomeDude: but as the others said, just define a recursive function
16:04:48 <rostayob> with fold you don't gain anything and you lose in readability
16:04:53 <rostayob> (if the function is big)
16:06:45 <otters> okay, "import Parsec" is giving me "Parsec not found" and I've installed parsec-3.1.2 and it shows up in ghc-pkg list
16:07:23 <jfischoff> The old parsec tutorials are not accurate
16:07:37 <otters> nuts
16:07:55 <jfischoff> There is a compatibility layer
16:07:57 <DanBurton> @hoogle Parsec
16:07:57 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
16:07:58 <lambdabot> package parsec
16:07:58 <lambdabot> package parsec-extra
16:08:06 <jfischoff> there you go
16:08:10 <DanBurton> Test.Parsec now
16:08:47 <DanBurton> you could always install an old version of Parsec to go with the tutorial, though I wouldn't recommend it
16:08:49 <otters> I see
16:08:53 <ahf> 18
16:09:38 <jfischoff> the types have changed but I think the functions are pretty much the same, at least when I went through them
16:09:49 <jfischoff> once you get it to compile you'll be fine
16:16:38 <DanBurton> "once you get it to compile you'll be fine" - typical haskell advice :)
16:17:09 <jfischoff> and like all free advice ... :)
16:17:13 <ddarius> DanBurton: Uh, you'd have to install a Parsec 1 which predates the hierarchical modules extension being widely used which was about 10 years ago.
16:17:14 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
16:17:48 <ddarius> For the most part, the only difference between what is described in the Parsec Letter and newer versions of Parsec (other that new features) is the module names.
16:26:31 <cmccann> jfischoff, free advice is, of course, any advice which satisfies the properties expected given the definition of "advice", but nothing further ;]
16:31:55 <cetinsert> Just one question for all ...
16:31:58 <Saizan> ddarius: and a propensity to trigger the MR
16:32:48 <cetinsert> Are there going to be new developments on ARM support in GHC now that Windows is coming out for that CPU?
16:32:56 <jfischoff> cmccann: which is easy to give for the polymorphic lambda calculus.
16:37:25 <monochrom> haha free advice. satisfies universal properties
16:42:54 <DanBurton> @remember cmccann says: free advice is, of course, any advice which satisfies the  properties expected given the definition of "advice", but nothing  further ;]
16:42:54 <lambdabot> Nice!
16:44:02 <DanBurton> oh lambdabot automatically puts the "says:" part >,<
16:44:07 <DanBurton> @quote free.advice
16:44:07 <lambdabot> cmccann says: says: free advice is, of course, any advice which satisfies the  properties expected given the definition of "advice", but nothing  further ;]
16:47:16 <ddarius> @forget cmccann says: free advice is, of course, any advice which satisfies the  properties expected given the definition of "advice", but nothing  further ;
16:47:17 <lambdabot> No match.
16:47:31 <ddarius> @forget cmccann says: free advice is, of course, any advice which satisfies the  properties expected given the definition of "advice", but nothing  further ;]
16:47:31 <lambdabot> Done.
16:53:52 <DanBurton> @remember cmccann free advice is, of course, any advice which satisfies the  properties expected given the definition of "advice", but nothing  further ;]
16:53:52 <lambdabot> Done.
16:54:01 <DanBurton> @quote free.advice
16:54:01 <lambdabot> cmccann says: free advice is, of course, any advice which satisfies the  properties expected given the definition of "advice", but nothing  further ;]
16:54:52 <dabblego> is there a search function where I can say, "what type-classes are defined over parameters of this kind?"
16:55:22 <dabblego> e.g. search *->* would give me Functor and friends, *->*->* Category and all that jazz
16:57:00 <DanBurton> Not that I'm aware of
16:57:22 <DanBurton> I imagine it's possible, though
16:58:29 <ddarius> I don't see that as being terribly useful.
16:59:11 <rostayob> ...DataKinds...
16:59:54 <shachaf> @forget cmccann free advice is, of course, any advice which satisfies the  properties expected given the definition of "advice", but nothing  further ;]
16:59:54 <lambdabot> Done.
17:00:07 <shachaf> @remember cmccann free advice is, of course, any advice which satisfies the properties expected given the definition of "advice", but nothing further ;]
17:00:07 <lambdabot> Okay.
17:02:27 * ddarius is considering running a VM in a VM.
17:03:20 <monad> Yo dawg.
17:03:58 <blackdog> monad, i bind you, from doing harm to yourself and doing harm to others
17:04:04 <rostayob> monad: nice nick
17:04:08 <monad> ty
17:04:15 <monad> Inspired by Liebniz however
17:05:17 <monochrom> a friend did that with an ibm mainframe back then, since its OS came with a VM. he nested 16 levels. in the innermost level, it took 1 minute from keypress to screen update
17:05:21 <Eduard_Munteanu> @ask roconnor Hm, interesting, I guess you're limited by the ability to dynamically link different versions at the same time?
17:05:22 <lambdabot> Consider it noted.
17:05:46 <roconnor> Eduard_Munteanu: oh, does that produce a runtime error?
17:05:46 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
17:06:01 <roconnor> Eduard_Munteanu: I'm pretty sure that what happens is things just segfault randomly.
17:06:09 <roconnor> maybe my example were statically linked.
17:06:22 <Eduard_Munteanu> roconnor: no, I was just guessing regarding the nix problem.
17:07:00 <roconnor> Eduard_Munteanu: AFAIK, you can dynamically load two different versions of the same library at runtime.
17:07:09 <ddarius> Hmm, maybe if I can mount a VHD as a disk in Linux I'll avoid some amount of craziness.
17:07:16 <roconnor> though I'm not very familiar with this sort of thing.
17:07:45 <Eduard_Munteanu> ddarius: VM in VM should work fine with KVM if you have a reasonable CPU.
17:08:17 <Eduard_Munteanu> roconnor: yeah, I'm not sure what works either.
17:10:07 <roconnor> Eduard_Munteanu: what I imagine needs to be done is for libraries to declare which dependencies are "exported", ie are used in their interfaces.
17:10:32 <Eduard_Munteanu> Or perhaps symbol versioning?
17:11:16 <roconnor> AFAIU, the problem is handing a data structure built with one version of the library over to a another version of the same library.
17:11:40 <roconnor> and since the structure may no longer be layed out the same ... boom.
17:11:51 <Saizan> at least GHC makes that a type error for haskell code :)
17:11:53 <roconnor> I don't know
17:12:14 <roconnor> maybe symbol versioning would catch this at linking time?
17:12:33 <blackdog> structuring question: if i have two functions of type a -> IO (Maybe a), and i'd like to compose them in the obvious way: what would i use?
17:12:42 <roconnor> Saizan: that is what is excting about cabal; this analysis could plausibly be done
17:12:53 <ddarius> blackdog: You could use (>=>) and MaybeT.
17:13:21 <roconnor> blackdog: or string it together by hand.
17:13:46 <Elemir> Someone stole ghc 7.2.2 from gentoo =(
17:13:56 <Eduard_Munteanu> roconnor: mm, I doubt that. If that were the case, that particular application would have to explicitly link to both.
17:14:00 <roconnor> edwardk: if only MaybeT was part of transformers.
17:14:35 <blackdog> roconnor: yeah, i can do that. i'd rather have something that showed intent, though.
17:14:57 <Saizan> Eduard_Munteanu: it does indirectly
17:15:05 <Eduard_Munteanu> roconnor: rather, it sounds like the same executable would have to link in both versions indirectly
17:15:46 <Eduard_Munteanu> When linking A, the linker brings in both B and C, each with its own version of the D library.
17:16:01 <Eduard_Munteanu> Sounds like a symbol namespace issue so far.
17:16:35 <roconnor> Anyhow, it is a problem that I don't understand very well I guess.
17:20:06 * hackagebot swish 0.6.5.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.5.0 (DouglasBurke)
17:45:06 * hackagebot swish 0.6.5.1 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.5.1 (DouglasBurke)
17:46:51 <shurane> that's a quick update
18:00:28 <aristid> shurane: a quick update is when it comes in less than a minute ;)
18:06:49 <eyebloom> Does anyone have a minute to look at a type quandary I'm working through.
18:13:32 <redheadphones> is there anyway to get a String (not IO String) out of System.* calls for stdout parsing?
18:15:08 <copumpkin> no
18:15:27 <RichyB> redheadphones, nah, but there's a thing called "interact" in the standard library.
18:15:28 <copumpkin> instead of thinking about taking things out of IO to work on them, think of putting your work into IO
18:15:37 <RichyB> interact :: (String -> String) -> IO ()
18:15:58 <tomprince> redheadphones: listen to copumpkin
18:16:15 <ddarius> Don't listen to copumpkin.
18:17:06 <RichyB> `interact` takes a function for transforming a String into another String, and returns an IO action that runs that function on bytes from stdin and writes them to stdout for you..
18:17:08 <aristid> only ever listen to pumpkin
18:17:14 <redheadphones> i saw interact, i'll have to look at it harder. i'm basically trying to use https://github.com/dom96/SimpleIRC to wrap an interpreter, maybe using `ghc -e`
18:17:39 <redheadphones> tomprince, hi there
18:18:08 <redheadphones> i'm already converting between ByteString and String for the parsing
18:18:12 <RichyB> e.g. main = interact (map toUpper) # WORKS A BIT LIKE THE UNIX UTILITY CALLED "CAT", ONLY MORE SHOUTY.
18:18:39 <redheadphones> how does lambdabot do it, the interpretation?
18:19:00 <RichyB> IIRC lambdabot uses a library called "mueval"
18:19:17 <tomprince> redheadphones: hey. What you want to do is write you function that takes a string, And then, when you want to actually work on input, you can "apply" it to something "in" IO.
18:20:09 <RichyB> which has, somewhere in it, a function like (interpret :: String -> IO (Either Error String)), where the input string is a piece of source code and the output is Either some error message type or a String to be printed back into the channel.
18:20:55 <redheadphones> the way i'm getting the messages to irc is with this function: https://github.com/dom96/SimpleIRC/blob/master/Network/SimpleIRC/Core.hs#L479
18:24:05 <redheadphones> tomprince, so maybe something like inIO f = return . f
18:25:29 <tomprince> For simplicity, assume you have a function 'writeMessage: String -> IO ()' for getting the message to IRC. And you have an input that looks like 'readMessage: IO String' (<--- that descriptiono isn't entirely accurate). and a function 'echo: String -> String'. 'readMessage >>= return . echo >>= writeMessage' would read a message, transform it with echo, and then write it.
18:26:31 <tomprince> Techinaclly 'IO String' represents an action that *when executed* gives a string, and the expression at the end, is an action that *when executed* reads+transforms+writes.
18:27:33 <tomprince> You could also write it as 'readMessage >>= writeMessage . echo'
18:28:03 <tomprince> redheadphones: Does that make any sense?
18:28:33 <redheadphones> it does a bit. i think more time on >>= and matching/tracing types will help solidify it.
18:29:29 <redheadphones> tomprince, thanks, i'm going to try things in ghci
18:31:52 <tomprince> redheadphones: You might try thinking of 'IO a' as a deferred that will be fired with an 'a' and >>= add adding a callback that takes an 'a' and returns a deferred that will fire with 'b' (i.e. 'a -> IO b'). The result of which is a deferred that fires with a 'b (i.e. 'IO b').
18:32:27 <tomprince> That isn't entirely accurate, but I think gives the right impression.
18:52:06 <tromp__> > 'c' - 'a'
18:52:07 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
18:52:07 <lambdabot>    arising from a use of `GHC....
19:00:29 <tromp__> @hoogle (a -> Maybe a) -> a -> [a]
19:00:29 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
19:00:29 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:00:30 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:00:44 <tromp__> :t unfold
19:00:45 <lambdabot> Not in scope: `unfold'
19:00:50 <tromp__> :t unfoldr
19:00:51 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:03:40 <tromp__> @djinn (a -> Maybe a) -> (a -> Maybe (a,a))
19:03:40 <lambdabot> f a b =
19:03:40 <lambdabot>     case a b of
19:03:40 <lambdabot>     Nothing -> Nothing
19:03:40 <lambdabot>     Just c -> Just (c, c)
19:04:20 <tromp__> @pl \a b -> case a b of Nothing -> Nothing; Just c -> Just (c, c)
19:04:21 <lambdabot> (line 1, column 29):
19:04:21 <lambdabot> unexpected ">" or "-"
19:04:21 <lambdabot> expecting variable, "(", operator or end of input
19:04:31 <tromp__> @pl \a b -> case a b of { Nothing -> Nothing; Just c -> Just (c, c) }
19:04:32 <lambdabot> (line 1, column 21):
19:04:32 <lambdabot> unexpected "{"
19:04:32 <lambdabot> expecting variable, "(", operator or end of input
19:07:07 <shergill> @help
19:07:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:08:08 <tromp__> @pl \a -> (a,a)
19:08:08 <lambdabot> join (,)
19:10:11 <MostAwesomeDude> @djinn ((a, b) -> (a, b)) -> [a] -> [a]
19:10:11 <lambdabot> Error: Undefined type []
19:14:02 <MostAwesomeDude> @djinn ((a, b) -> (a, b)) -> f a -> f a
19:14:03 <lambdabot> f _ a = a
19:14:13 <MostAwesomeDude> Yes, thank you lambdabot
19:16:57 <NemesisD> hi all. I've got an argument a :: Maybe ThreadId and a function Maybe ThreadId -> IO () that kills the thread if it exists, i'd like to use Maybe's instances to do this concicely instead of pattern matching
19:17:31 <MostAwesomeDude> when isJust tid $ your_killing_function
19:17:43 <MostAwesomeDude> :t isJust
19:17:44 <lambdabot> forall a. Maybe a -> Bool
19:17:45 <MostAwesomeDude> :t when
19:17:46 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:18:20 <MostAwesomeDude> ...I misplaced that $, but yeah.
19:18:31 <NemesisD> yeah i could do that. i just thought there was a way to get killThread into the Maybe monad or something
19:22:50 <MostAwesomeDude> :src join
19:22:55 <MostAwesomeDude> @src join
19:22:55 <lambdabot> join x =  x >>= id
19:26:08 <NemesisD> does join work though? the type is Monad m => m (m a) -> m a, but theres 2 different monad types at play isn't there?
19:36:00 <ion> There’s a single m.
19:36:41 <NemesisD> ion: there is? i thought there was IO and Maybe in this case
19:38:04 <shachaf> NemesisD: What are you trying to do?
19:39:01 <NemesisD> schroedinbug: foo :: Maybe ThreadId, maybeKillThread :: Maybe ThreadId -> IO ()
19:39:08 <NemesisD> erm shachaf *
19:39:26 <shachaf> NemesisD: You want to combine the two?
19:39:30 <shachaf> "id" will work.
19:39:47 <NemesisD> i wanted to do something like killThread =<< foo, but that's not enough because it doesn't put them at the same level, for lack of the proper term
19:39:55 <shachaf> What?
19:40:06 <shachaf> The first step should be writing out, long-hand, what you're trying to do.
19:40:13 <shachaf> Are you writing the function maybeKillThread?
19:40:16 <NemesisD> yes
19:40:26 <NemesisD> without using pattern matching
19:40:28 <shachaf> I have no idea where foo gets into it.
19:40:36 <shachaf> Can you write out the function?
19:41:51 <Elemir> @hoogle m a -> (m a -> n b) -> n b
19:41:52 <lambdabot> Test.QuickCheck.Arbitrary (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
19:41:52 <lambdabot> Test.QuickCheck (><) :: (Gen a -> Gen a) -> (Gen a -> Gen a) -> (Gen a -> Gen a)
19:41:52 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
19:42:16 <hpaste> NemesisD pasted “maybe kill” at http://hpaste.org/64911
19:42:57 <shachaf> I thought you were writing a function :: Maybe ThreadId -> IO ()
19:43:04 <shachaf> In which case "maybe (return ()) killThread" is probably what you want.
19:43:44 <NemesisD> that essentially is my type just slightly more complex inn the actual code
19:44:17 <shachaf> Well, if you're pattern-matching anyway, it doesn't seem unreasonable to do what you're doing.
19:44:45 <shachaf> But you can always maybe (return ()) (killThread . refillerThread) or something like that.
19:45:38 <NemesisD> just looking at alternative ways to solve problems. i feel like i take the same approach to most of my problems in haskell and get alarmed sometimes at how little i use in Monad and Applicative
19:49:35 <hpaste> Elemir pasted “killBucketInterface without pattern matching for NemesisD” at http://hpaste.org/64912
19:49:56 <Elemir> Something like that, for example
19:52:34 <edwardk> preflex: xseen ddarius
19:52:34 <preflex>  ddarius was last seen on freenode/#haskell 1 hour, 36 minutes and 19 seconds ago, saying: Don't listen to copumpkin.
19:52:41 <edwardk> good advice
19:52:46 <copumpkin> :(
19:52:49 <edwardk> =)
19:52:53 <copumpkin> :)
19:53:03 <shachaf> Don't listen to copumpkin if he promises you dola.
19:53:28 <edwardk> @tell ddarius http://graphics.cs.kuleuven.be/publications/PATHDIFF/pathdiff.pdf at least uses the path differentials that the hamiltonian approach would give, and its used to give a blurring kernel, so it should make you happy
19:53:28 <lambdabot> Consider it noted.
19:54:02 <edwardk> nah, copumpkin is good for dola, its bitcoins that he'll take you to the cleaners for
19:54:06 <copumpkin> lol
19:56:29 <ddarius> edwardk: Now you need to fine some tridirectional path tracers.
19:56:29 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
19:56:31 <Elemir> @hoogle m a -> (a -> n b) -> n b
19:56:31 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
19:56:31 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
19:56:32 <lambdabot> GHC.Conc.Sync withMVar :: MVar a -> (a -> IO b) -> IO b
19:56:36 <edwardk> ddarius: =)
19:57:09 <edwardk> i've largely given up there, the result is systemetically biased
19:57:27 <Elemir> @hoogle (Monad m, Monad n) => m a -> (a -> n b) -> n b
19:57:27 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
19:57:27 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
19:57:27 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
19:57:42 <Elemir> lambdabot: Bad bot
19:58:07 <Elemir> Ye, it's cannot work =(
19:58:18 <Elemir> Stupid elemir ;(
19:58:30 <edwardk> trying to reverse engineer the factoring used in http://gfx.cs.princeton.edu/proj/brdf/
19:59:28 <edwardk> and still make sure that i can get partials out of it
20:01:57 <ddarius> They don't describe it in enough detail?
20:02:27 <edwardk> well, just started. and they don't really give enough for me to check my work
20:02:48 <Elemir> Hem
20:02:50 <Elemir> http://hackage.haskell.org/packages/archive/monad-state/0.1.1.2/doc/html/Control-Monad-Runnable.html
20:03:16 <Elemir> Is there type class for pure runnable monads?
20:03:21 <edwardk> that and i need to chase down some of their references, lee and seung, etc.
20:03:48 * shachaf wonders how useful the idea of a "runnable monad" is.
20:04:28 <edwardk> Elemir: runnability is kind of by definition a one-off concept per monad
20:05:21 <Elemir> Of cause
20:05:21 <Brolapse> can anyone tell me why i'm bad? http://pastebin.com/aiKMwXwR
20:05:23 <mauke> The paste aiKMwXwR has been copied to http://hpaste.org/64913
20:05:31 <Elemir> run :: m a -> RunData m -> RunContainer m (ConstructType m a)
20:05:50 <edwardk> also, re your m a -> (a -> n b) -> o b signature, you can look at http://comonad.com/reader/2007/parameterized-monads-in-haskell/ which is an old hack on my part for just that
20:05:57 <edwardk> but keep in mind i don't recommend it ;)
20:06:06 <shergill> @where djinn
20:06:06 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
20:07:20 <Elemir> It is was little research
20:07:46 <ion> class BadHaskell
20:07:49 <ion> class Baskell
20:08:08 <Brolapse> if anyone is reading what i just pastebin'd - found answer i'm an idiot
20:08:15 <ion> claskell
20:08:46 <Elemir> Brolapse: Use hpaste!
20:09:12 <Brolapse> yeah i saw the bot correct me :P
20:09:39 <Elemir> Is there some pastebin program for hpaste?
20:09:42 <ddarius> mauke is not a bot
20:09:53 <Elemir> o_O'
20:09:57 <Brolapse> o
20:10:01 <DanBurton> I wouldn't be so sure
20:10:24 <shachaf> mauke: maukesnack
20:10:26 <Brolapse> came here to get help with haskell homework and now i'm just confused in general with what is going on here
20:10:31 <mauke> :-)
20:11:32 <Elemir> It can be bot, that to ZNC of real man
20:11:39 <shachaf> mauke: I have a K at my K1, and no other pieces. You have only K at K6 and R at R1. It is your move. What do you play?
20:11:45 <Elemir> O, god idea
20:12:15 <mauke> shachaf: global thermonuclear war
20:12:54 <ion> mauke used to be a human, but he was replaced with a simple shell script.
20:12:54 <Elemir> Brolapse: Haskell is not ML. It uses carry notation of arguments
20:13:25 <mauke> carry notation?
20:13:33 <Brolapse> post
20:13:34 <Brolapse> fix
20:13:39 <Brolapse> func 5 4
20:13:49 <Brolapse> sorry multilining, is that what you meant electrogeek ?
20:13:50 <Elemir> ML use tuples for arguments, for example
20:13:51 <Brolapse> Elemir, *
20:14:22 <ion> ITYM currying
20:14:23 <scooty-puff> is there a good solution to dependency issues with cabal?
20:14:26 <Elemir> countElems $ num - 1 $ drop 1 list
20:14:31 <scooty-puff> last time i just deleted parts of .cabal and .ghc..
20:14:47 <Brolapse> $ !?
20:14:55 <Elemir> :t ($)
20:14:56 <lambdabot> forall a b. (a -> b) -> a -> b
20:15:41 <ion> Programmers should get an electric shock of 10^n volts where n is the number of $s they have on a line.
20:15:41 <Elemir> scooty-puff: Just use gentoo. Cabal is integrated in portage
20:16:13 <scooty-puff> hmm.. archlinux..
20:16:14 <mbetter> i put $ between every token on a line, just to be on the safe side
20:16:26 <parcs`> scooty-puff: cabal from darcs does a pretty good job at preventing you from breaking packages
20:16:42 <scooty-puff> k
20:17:54 <mm_freak_> programmers should get an electrick shock of 10^10 volts for suggesting to switch the distribution to solve a problem instead of providing a real solution
20:18:19 <mbetter> bonus points for suggesting gentoo
20:18:38 <mm_freak_> arch linux is fine for haskell development
20:18:39 <dbelange> bonus volts
20:18:47 <ivanm> mm_freak_: users shouldn't bitch about how they have an issue with cabal-install when their distro (on their personal machine they have root access to) has perfectly good packages that won't have those problems
20:19:09 <mbetter> maybe the current could vary by the exact distro suggested
20:19:10 <mm_freak_> ivanm: i don't use my distro packages either…  except GHC
20:19:42 <ivanm> mm_freak_: yes, but I don't recall you whining about cabal-install leaving your system in a mess all that often :p
20:19:54 <ivanm> though admittedly I pretty much just use my distro for GHC atm
20:20:05 <mm_freak_> well, i whine about some packages =)
20:20:05 <ivanm> as I'm procrastinating about fixing their Haskell support up :s
20:20:12 <mm_freak_> but not about cabal
20:20:16 * hackagebot unordered-containers 0.2.0.0 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.0.0 (JohanTibell)
20:20:20 <shachaf> ion: Oh, come on. 10^(n-1)
20:20:28 <td123> any distro that has packaged a 3rd party repo has pretty much failed
20:20:34 <parcs`> arch linux has some problems with its haskell packages, namely sometimes a package fails to completely deinstall, leaving you with untracked files polluting your FS and ghc thinking a package is installed that isn't
20:21:02 <ion> shachaf: Whoops. :-D That’s what i meant.
20:21:12 <mbetter> i'm pattern and all i care about is the constructor.. is there any way i can get away from doing: Constructor _ _ _ _ _
20:21:21 <mbetter> all of the underscores
20:21:33 <mauke> mbetter: Constructor{}
20:21:34 <ivanm> mbetter: Constructor{}
20:21:34 <mbetter> pattern matching
20:21:43 <shachaf> ion: Actually, it's not what *I* meant. But never mind.
20:22:16 <mbetter> oh jeez, i knew that
20:22:19 <mbetter> thanks
20:22:42 <mm_freak_> > let (,) {} = (3, 4) in ()
20:22:43 <lambdabot>   ()
20:22:46 <shachaf> irssi needs support for completing long words that have recently been said in IRC.
20:22:57 <mm_freak_> uh…  didn't expect that to work
20:22:58 <ddarius> ion thinks programmers should get shocked for writing code.
20:23:27 <mm_freak_> ddarius: for 90% of PHP programmers i would agree
20:23:32 <shachaf> > let ((,)) {} = (3,4) in ()
20:23:33 <lambdabot>   <no location info>: Empty record update
20:23:40 <mm_freak_> the PHP developers are contained in that 90%
20:23:44 <mauke> shachaf: can be done with a script
20:23:57 <magicman> ... how is (,) {} even a valid pattern?
20:24:00 <shachaf> mauke: I'm sure.
20:24:06 <mm_freak_> magicman: (,) is the constructor
20:24:10 <mm_freak_> > (,) 3 4
20:24:10 <shachaf> magicman: The same way that Constructor{} is a valid pattern.
20:24:11 <lambdabot>   (3,4)
20:24:12 <magicman> Oh, I see. Tuple-constructor with magic-{} even if not part of the definition.
20:24:18 <mbetter> PHP is gaining type hints, if there's a mismatch between the actual parameter and the type hint, you now get an implicit conversion
20:24:34 <magicman> Neat.
20:24:39 <mauke> haha
20:24:54 <magicman> (the (,){} part... dunno about PHP :p)
20:25:01 <mauke> haskell needs that too!
20:25:02 <mm_freak_> neat?
20:25:12 <mm_freak_> come on
20:25:13 <mbetter> mauke: seriously. i'm a little jealous.
20:25:17 <ion> mbetter: haha
20:25:19 <mm_freak_> you're in #haskell
20:26:00 <ion> “Strongly weakly typed”
20:26:24 <mm_freak_> in fact PHP can do some very limited strong type checking
20:27:27 <mbetter> mm_freak_: further enforcing their "Principle of Maximal Surprise."
20:27:30 <gentleben> thats nice
20:27:31 <mm_freak_> but you have to provide annotations explicitly and it works only for class types
20:27:43 <parcs`> and arrays ;)
20:27:47 <mm_freak_> true
20:28:00 <mm_freak_> in other words, PHP is far away from not sucking
20:28:28 <mm_freak_> and still the PHP developers should get jailed for ruining the web
20:31:00 <parcs`> haha
20:31:08 <parcs`> your deep hatred of php is amusing :P
20:31:21 <mm_freak_> it's justified
20:32:03 <mm_freak_> just think you would have to write:  $main = $return(null)
20:34:39 * tibbe does a little victory dance.
20:34:51 <shachaf> tibbe++ # victory
20:34:57 <shachaf> What was your victory?
20:35:39 <tibbe> shachaf: released over a year's worth of work on unordered-containers
20:35:47 * DanBurton does a victory swing-gunblade-over-head dance for tibbe
20:35:49 <yshavit_> hi there, Java programmer here trying to get into the Haskell mindset. I'm trying to translate an interview question I do for Java into Haskell -- a little shapes drawing program. In Java, I'd have a Shape interface and implementing classes Square and Circle. In Haskell, I tried to make a "Shape a" class, with instances for data types Square and Circle. But with that approach, I can't have an array of Shapes, right?
20:36:03 <mbetter> tibbe, i was just reading about that on r/haskell
20:36:13 <tibbe> yshavit_: you can
20:36:15 <mbetter> congrats
20:36:15 <shachaf> yshavit_: Don't use a type class.
20:36:24 <yshavit_> tibbe: how so?
20:36:33 <yshavit_> shachaf: what should I use instead?
20:36:37 <shachaf> yshavit_: Type classes are completely different from Java classes and and are used for very different things.
20:36:41 <shachaf> yshavit_: A type?
20:36:52 <tibbe> yshavit_: you need to define a type for things that are shapes, a little container if you wish. data SomeShape = Shape a => SomeShape a  -- I think this syntax is right
20:36:56 <yshavit_> shachaf: as in, an algebraic type?
20:37:08 <shachaf> yshavit_: As in some sort of data type or another.
20:37:15 <DanBurton> data Shape = Circle {...} | Square {...} | etc
20:37:25 <tibbe> yshavit_: people might tell you to just us a plain algebraic data type: data Shape = Rectangle …. | Circle ….
20:37:29 <shachaf> yshavit_: You *can* define a thing that lets you ahve a list of instances of "Shape", but it's rarely what you want.
20:37:33 <shachaf> yshavit_: Read this:
20:37:34 <shachaf> @google existential antipattern
20:37:34 <mbetter> a type class is closer to a java interface
20:37:35 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
20:37:35 <lambdabot> Title: Haskell Antipattern: Existential Typeclass « Luke Palmer
20:37:36 <yshavit_> shachaf, tibbe : I was hoping to be able to avoid that; it means I can't in some other file define a new kind of shape, right?
20:37:46 <shachaf> mbetter: It's closer but it's still not that.
20:38:01 <shachaf> yshavit_: If you use a sum type like Rectangle | Circle, yes, it means that.
20:38:06 <tibbe> yshavit_: that's right
20:38:06 <shachaf> yshavit_: But you don't have to use a type like that.
20:38:07 <tibbe> yshavit_ : data types are closed (you cannot add new options), type classes are open
20:38:13 <shachaf> yshavit_: See the link above.
20:38:18 <DanBurton> yshavit_: true, but it does mean you can easily define a new kind of operation on shapes
20:38:21 <yshavit_> shachaf: okay, I'll read up on that. Thanks!
20:38:27 <tibbe> mbetter: thanks
20:38:37 <DanBurton> "the expression problem" or something like that
20:38:51 <mbetter> tibbe: the hackage link seems broken. still uploading?
20:39:03 <yshavit_> DanBurton: yeah, I was hoping to be able to have an open world of shapes. So that if some 3rd party developer comes and wants to create a plugin that defines a Triangle, he'd be able to
20:39:23 <yshavit_> (in this case I'm my own 3rd party dev, but this is just an exercise of course)
20:39:33 <tibbe> yshavit_: if you have a closed type (i.e. an algebraic data type) it's easy to add new function over it, but not new constructors. It's the opposite ways with OO classes, it's easy to add new subclasses, but not new methods (as you'd have to update all classes.)
20:39:40 <tibbe> mbetter: let me check
20:39:54 <yshavit_> tibbe: yeah, that's why I was trying to avoid an algebraic data type :)
20:40:01 <shachaf> yshavit_: All data types are algebraic. :-)
20:40:13 <shachaf> yshavit_: There's the possibility suggested by the link above.
20:40:28 <yshavit_> shachaf: erm, well then the "data" type. I haven't gotten to the paper yet, but it's loaded in my browser :)
20:40:42 <mm_freak_> tibbe: with speed improvements? =)
20:40:44 <tibbe> mbetter: link fixed
20:41:02 <tibbe> mm_freak_: yes
20:41:11 <tibbe> mm_freak_: quite large ones in cases, and memory overhead improvements
20:41:12 <mm_freak_> great, i'll try it out right away
20:41:14 <mbetter> tibbe, thanks
20:41:26 <shachaf> yshavit_: "paper" is overstating it. I can type the contents of it into this IRC window, but it seems like wasted effort when luqui has already written it up so nicely. :-)
20:41:26 <mm_freak_> tibbe: thanks for that
20:42:07 <tibbe> mm_freak_: hope it works for you
20:42:09 <yshavit_> shachaf: fair enough :) I'm trying to learn Haskell while ignoring my gf's watching Downton Abbey, which is why my brain is a bit slow
20:42:12 <DanBurton> yshavit_: the trouble with translating a Java exercise to Haskell is that good Haskell style is very different than the class-based style of Java
20:42:19 <tibbe> mm_freak_: note that it's faster on GHC 7.4
20:42:30 <shachaf> DanBurton: Did *you* read that link?
20:42:51 <yshavit_> DanBurton: Oh, definitely. I'm trying to translate the app, not the solution. That's actually the whole point... I can do the Java part no prob, it's the Haskell part I want to learn.
20:42:52 <DanBurton> shachaf: the luke palmer blog post? indeed I did.
20:42:58 <totimkopf> is there a function for time in haskell?
20:43:12 <DanBurton> @hoogle getCurrentTime
20:43:12 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
20:43:12 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
20:43:19 <yshavit_> DanBurton: In other words, I'm trying to take the drawing app and think about it in idiomatic Haskell.
20:43:20 <shachaf> @google is there a function for time in haskell
20:43:20 <lambdabot> http://stackoverflow.com/questions/1516808/writing-a-time-function-in-haskell
20:43:21 <lambdabot> Title: scala - Writing a time function in Haskell - Stack Overflow
20:43:21 <totimkopf> poo, thank you sir
20:43:24 <DanBurton> totimkopf: it's not a function, though. it's an IO action
20:43:28 <mm_freak_> tibbe: i've got GHC 7.4.1 now =)
20:43:31 <tibbe> yshavit_: it might be worth avoiding trying to map the OO design onto Haskell and instead trying to solve the problem directly with Haskell tools. Come up with a basic version first, and then think about making it flexible enough to be extensible in the directions you want.
20:43:37 <totimkopf> ooo*
20:43:48 <mm_freak_> and i'm using HashMap extensively for a project, which is speed-critical
20:43:48 <totimkopf> what is an 'action'?
20:44:01 <tibbe> mm_freak_: oh?
20:44:07 <totimkopf> @google haskell actions
20:44:08 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_Haskell_IO/Actions
20:44:09 <lambdabot> Title: Introduction to Haskell IO/Actions - HaskellWiki
20:44:14 <yshavit_> tibbe: fair enough
20:44:25 <mm_freak_> tibbe: and i hope to release it this week =)
20:44:32 <tibbe> yshavit_: what you want is possible, the question is if it's desirable in this case
20:44:36 <tibbe> mm_freak_: sweet
20:44:39 <tibbe> mm_freak_: open source?
20:44:42 <mm_freak_> sure
20:45:00 <tibbe> yshavit_: one possible encoding is via type classes
20:45:03 <yshavit_> tibbe: "it" being a 3rd party dev being able to define a new shape? I don't see why that wouldn't be desirable...
20:45:41 <yshavit_> tibbe: doesn't have to be via classes, of course
20:46:26 <tibbe> yshavit_: if that's what you want, you can do what I said (using a type class) or what the blog post someone mention said
20:46:33 <mbetter> does Data.TrieMap use hashes internally?
20:47:04 <yshavit_> tibbe: hm wait, how does a type class help? that's what I started out with, and that's what ran me into trouble
20:47:07 <tibbe> yshavit_: Haskell includes the same mechanism as OO (ad-hoc polymorphism, etc) but they are split up into smaller parts, so you can pick and chose what you want.
20:47:16 <shachaf> yshavit_: You can use a type class with an existential type.
20:47:19 <tibbe> mbetter: was that for me?
20:47:33 <shachaf> yshavit_: However, that's more complicated than just doing the record thing. :-)
20:47:43 <mbetter> tibbe: in general, though i figured you might know it offhand :)
20:47:56 <tibbe> yshavit_: http://www.haskell.org/haskellwiki/Existential_type
20:48:01 <DanBurton> totimkopf: was that googled link sufficient to clarify the difference between a function and an action?
20:48:11 <tibbe> mbetter: never tried it actually
20:48:15 <shachaf> I like how someone asked a question and was given a link to a good answer, and now we're still typing in answers ten minutes later.
20:48:27 <tibbe> mbetter: I tend to be skeptical of new data structure libraries, unless they have benchmarks :)
20:48:32 <mbetter> tibbe: i'm using bytestring-trie heavily for something i'm working on
20:48:43 <tibbe> mbetter: ok
20:48:59 <tibbe> mbetter: if you don't need the trie like nature (for prefix queries) HashMap is most likely faster.
20:49:11 <DanBurton> shachaf: opinions vary on whether using typeclasses and existentials in that way is OK or not.
20:49:16 <mbetter> tibbe: that's why i'm using it, the prefix queries
20:49:36 <mbetter> tibbe: i was wondering if there's anything better
20:49:48 <totimkopf> DanBurton, hmm, somewhat, putStrLn is a function but putStrLn "hello" is an action… I'm still trying to wrap my head around this
20:49:51 <eyebloom> Been trying for an hour to run a configure script. I keep getting the message "At least the following dependencies are missing:" but the packages in question are installed.
20:50:05 <yshavit_> shachaf: so, tell me if I"m on the right track. Right now, I have this type class Shape with two functions: area :: a -> Double, draw :: a -> [DrawStep]. Sounds like instead, I should have each Shape be a data type that just has { area :: Double, draw :: [DrawStep] } ?
20:50:05 <totimkopf> it seems almost zen like
20:50:09 <zachk_> :type putStrLn
20:50:10 <shachaf> DanBurton: The way to establish which solution is the best is obviously to recommend all of them to someone who's just started learning Haskell and seeing what they pick.
20:50:14 <DanBurton> totimkopf: putStrLn is a function whose result is an action
20:50:18 <zachk_> > :t putStrLn
20:50:19 <lambdabot>   <no location info>: parse error on input `:'
20:50:20 <DanBurton> totimkopf: if that helps :)
20:50:30 <shachaf> DanBurton: Anyway, even if the better solution is an existential type, that link also talks about how to do that.
20:50:33 <totimkopf> taoism and haskell go hand in hand
20:50:40 <DanBurton> :t putStrLn -- zachk_
20:50:41 <lambdabot> String -> IO ()
20:50:44 <shachaf> yshavit_: That would work.
20:50:52 <yshavit_> shachaf: would it be good, though?
20:50:55 <tibbe> mbetter: not that I know off
20:51:04 <zachk_> :i putStrLn
20:51:11 <tibbe> mbetter: I have an idea for a better design for read-only queries, using something called an SSTable
20:51:12 <shachaf> yshavit_: Well, that depends on what you're actually doing. :-)
20:51:20 <shachaf> yshavit_: Do you see how it would be equivalent, though?
20:51:25 <tibbe> mbetter: SSTables do well with range queries and can hold gigabytes of data
20:51:30 <yshavit_> shachaf: yup (to the second part)
20:51:36 <mbetter> tibbe: that sounds right up my alley
20:51:53 <totimkopf> so, in essence an action is a "side effect"…something that just doesn't return a value but does "something" with it
20:52:00 <totimkopf> :t show
20:52:01 <lambdabot> forall a. (Show a) => a -> String
20:52:23 <totimkopf> show is a function whose result is an action?
20:52:30 <tibbe> mbetter: there's no Haskell implementation of one yet. One exists in Cassandra and probably another one in Hadoop, both written in Java.
20:52:35 <DanBurton> totimkopf: sort of. some actions can produce values, though, e.g. getLine
20:52:39 <tibbe> mbetter: mind you, they are construct-once structures
20:52:40 <yshavit_> shachaf: and to the first part, for now I just want an app with an open-world of shapes, in which each shape type can draw itself, give its area, and in the near future let itself be edited (which involves maintaining constraints -- which I'm thinking would be just another record in the data type)
20:52:47 <mauke> totimkopf: no, an IO "action" is an abstract value
20:52:50 <DanBurton> totimkopf: String is not an action. String is just a String.
20:52:56 <mbetter> tibbe: that doesn't sound up my alley :(
20:53:04 <mauke> totimkopf: it does nothing. it just sits around
20:53:21 <totimkopf> but show is outputted… to STDOUT
20:53:23 <totimkopf> :S
20:53:26 <shachaf> show *is* a function whose result is a [] action. But please ignore the previous sentence.
20:53:41 <mauke> totimkopf: no, show doesn't output
20:53:51 <tibbe> mbetter: :( unfortunately I don't need one right now and I'm not motivated enough to implement one
20:54:04 <totimkopf> ah,  so its GHCi that's blinding me
20:54:12 <aristid> shachaf: calling lists actions is evil
20:54:15 <mauke> totimkopf: yes, ghci automatically prints the results of expressions
20:54:20 <mauke> totimkopf: such as 2 + 2
20:54:23 <shachaf> aristid: It's sensible.
20:54:31 <totimkopf> mauke, right, thanks :)
20:54:39 <mbetter> tibbe: i've been hacking at Data.HiggsSet recently, trying to add multiple back-end index types so you can optimize for specific queries
20:54:47 <mauke> shachaf: lists are actions the same way IO a is a box
20:54:48 <ion> shachaf: show is an (r →) action.
20:54:56 <shachaf> ion: Right.
20:55:07 <totimkopf> what
20:55:12 <totimkopf> :S
20:55:19 <mauke> totimkopf: ignore the abstract nonsense :-)
20:55:19 <shachaf> mauke: I think the common meaning of "action" is "something of type m a for some monad m".
20:55:20 <ion> totimkopf: Ignore me.
20:55:21 <totimkopf> what is a r -> action?
20:55:23 <tibbe> mbetter: sounds interesting
20:55:27 <totimkopf> ah
20:55:42 <totimkopf> well, I really want everything in haskell to eventually "make sense"
20:55:43 <shachaf> mauke: Whereas the common meaning of "box" is "something that contains something else".
20:55:58 <yshavit_> totimkopf: it all makes sense, just not to you and me ;)
20:56:05 <totimkopf> yshavit_, hehehe
20:56:28 <shachaf> If you call "x :: State Int Char" a "State Int action" and "y :: IO Bool" an "IO action", I don't see why you wouldn't call "z :: [Char]" a "[Char] action".
20:56:29 <mauke> spoiler: the type X -> Y is equivalent to (->) X Y
20:56:30 <totimkopf> I want it to eventually make sense to me :)
20:57:48 <mbetter> tibbe: it sort of is. i'm doing a jagged-table kind of thing where multi-constructor types get mapped to overlapping indexes
20:58:49 <tibbe> mbetter: I see
21:01:00 <ion> shachaf: State Int Char wraps a function and IO Bool represents a side effect. At least those seem to have a good reason for being called an action. [Char] is just… oh crap, cons a b = \picker -> picker a b
21:01:29 <shachaf> ion: What about Either Error Char?
21:01:32 <shachaf> Is that an action?
21:03:26 <MostAwesomeDude> Huh. Traversable and Foldable seem pretty cool. I don't want to have to create a Functor in order to make a Traversable though.
21:03:40 <MostAwesomeDude> I guess I'm building an AST. Does Traversable really make sense?
21:03:56 <ion> shachaf: Good question. :-)
21:03:58 <shachaf> MostAwesomeDude: Foldable just means ToListable.
21:04:30 <yshavit_> shachaf: so, sorry, let's say I have my Shape { area :: Double, draw :: [DrawStep] } deriving (Eq). I want to add to Shape an edit function (not too worried for now its signature), while keeping the Eq. I can't use the function straight-up, but I'd like it to matter; a rectangle and a square aren't equal, even if they happen to have the same shape right now. So is it sensible to create a data type ShapeEditor that encapsulates
21:04:30 <ion> And if something’s ToListable it only makes sense it’s also Mappable.
21:04:30 <yshavit_> some unique ID and a function, and defines Eq based on the ID?
21:04:54 <MostAwesomeDude> shachaf: I have what apparently is an AST of some sort, and I want to "map" some stateful transformations over it. Does Traversable make sense as an easy way to get that functionality?
21:05:06 <MostAwesomeDude> I'm not sure what fmap would mean for an AST.
21:05:09 <shachaf> MostAwesomeDude: That depends on what you mean.
21:05:23 <yshavit_> shachaf: And if that is reasonable -- how do I get the unique ID? Seems like that would be hard, assuming I don't want it to be an IO Int or something like that.
21:05:27 <shachaf> yshavit_: Note that the derived Eq instance for a shape may not be what you want.
21:06:10 <yshavit_> shachaf: yeah, I'm not married to deriving it. Basically I want to somehow say "equality includes whether the two Shapes have the same edit function"
21:06:11 <shachaf> yshavit_: For example, is [Up 1,Left 1,Down 1,Right 1] the same shape as [Left 1,Up 1,Right 1,Down 1]?
21:06:30 <shachaf> (I have no idea what your DrawSteps look like.)
21:07:11 <ion> [Up 1,Up 1,Down 1,Down 1,Left 1,Right 1,Left 1,Right 1,B 1,A 1]
21:07:25 <yshavit_> shachaf: they look something like that :) And yes, I was using the derived mostly as shorthand. In the "real" code, I'd probably normalize (ie sort, probably) the [DrawStep]
21:07:33 <yshavit_> ion: ++
21:08:34 <mbetter> if you ask somebody what the Konami code is and their answer ends with "Select, Start" you can be reasonably confident that they have a sibling
21:09:19 <shachaf> mbetter: My answer would have ended with Select,Start and I've never played a game that used that code.
21:10:00 <mbetter> shachaf: do you have a sibling?
21:10:33 <yshavit_> mbernstein: I wouldn't have ended with Select, Start -- and I have two siblings.
21:10:35 * shachaf feels like that should be beside the point. :-(
21:10:48 <shachaf> You hear that, mbernstein?!
21:11:02 <mbetter> that mbernstein and his fanciful conjectures
21:11:38 <yshavit_> shachaf: so for my edit function, in Java (I know, I know :) ) I'd have some ShapeEditor interface, and check for identity equality when seeing if two shapes (including their constraints, as encapsulate dby the ShapeEditor) are equal. In Haskell obviously that's wrong.
21:11:38 <MostAwesomeDude> shachaf: I'm still restructuring this parser thingy, and it's starting to look a lot like data Melody = Note ... | Block [Melody] | Tuplet [Melody]
21:12:27 <lpsmith> tibbe, I think there is a unit error in your performance graphs
21:12:36 <MostAwesomeDude> So, y'know, an abstract tree-like thing.
21:12:37 <mbetter> yshavit_: identity equality meaning referential equality, i assume, doesn't fit too well with immutable structures
21:12:48 <shachaf> MostAwesomeDude: You may or may not want to make it parametric.
21:13:00 <yshavit_> mbetter: right -- I'm at the stage where I know what doesn't work, but not what does :-\
21:13:17 <yshavit_> shachaf: so my next thought was to have a data type ShapeEditor { shapeEditorId :: Int, editShape :: whatever } and have its Eq depend just on shapeEditorId. But that leaves the question of how to get that ID in a unique way.
21:13:40 <shachaf> MostAwesomeDude: Perhaps Melody = Rose (ChildrenType,NoteThing) :-)
21:13:46 <tomprince> Well, why do you want to compare for equality?
21:14:02 <MostAwesomeDude> shachaf: Maybe. The grammar's pretty strict. (This is a strict subset of Lilypond, which is super-specific.)
21:14:03 <mbetter> yshavit_: to know something is unique means you need to know what else there is
21:14:08 <mbetter> yshavit_: which means state
21:14:11 <tibbe> lpsmith: oh
21:14:20 <yshavit_> tomprince: this is all just an exercise, so basically "to see how it'd be done"
21:14:30 <tibbe> lpsmith: did my reply on reddit make sense?
21:14:34 <lpsmith> tibbe, yes
21:14:42 <yshavit_> mbetter: : only way I can think of is with some sort of state monad type approach, but that's hardly robust. Two pieces of code could easily create separate, different, yet equal editor functions.
21:14:44 <MostAwesomeDude> shachaf: Anyway, I kinda need to, well, fold/map over it, and Traversable looks like a good idea, but I don't think fmap/Functor would really mean anything to this structure.
21:14:50 <lpsmith> tibbe, I just replied to your reply
21:14:58 <yshavit_> mbetter: is the answer to that basically, "make sure they don't" ?
21:15:00 <shachaf> MostAwesomeDude: In that case you probably can't.
21:15:01 <mbetter> yshavit_: not necessarily a state monad
21:15:24 <tibbe> lpsmith: phew
21:15:34 <tomprince> yshavit_: Yes, I've been following along. But it might depend on what you use the equality for, to determine how best to construct one.
21:15:45 <mbetter> yshavit_: the state monad gives you implicit state
21:15:57 <yshavit_> mbetter: or something equivalent, no? "given this function and this shapeEditorCreator, give me a ShapeEditor and a new shapeEditorCreator" ?
21:16:24 <mbetter> yshavit_: that would work
21:16:27 <lpsmith> tibbe, it might be helpful to label the x-axis time (us) per 4096 inserts
21:16:34 <yshavit_> tomprince: so I'm thinking, for instance, I may want to compare two saved drawings and see if they're identical -- including not just how they look, but how then can be edited
21:17:07 <yshavit_> tomprince: that'd be off in the future for my skills ;) I'm just trying to think ahead.
21:17:11 <MostAwesomeDude> shachaf: Is this something people do often? Would you suggest a different approach?
21:17:28 <shachaf> MostAwesomeDude: I don't know enough about what you're doing to be able to say.
21:18:28 <mbetter> yshavit_: what do you mean by "how they can be edited?"
21:18:52 <mbetter> yshavit_: a unit circle is a unit circle, right?
21:18:56 <yshavit_> mbetter: for instance, a Rectangle's width and height are independent, whereas a Square's aren't.
21:19:07 <tomprince> If you are saving things, you either need a closed type, or an algebraic description of how they can be edited, I'd guess.
21:20:36 <yshavit_> tomprince: yeah, I was wondering about that. I was thinking maybe save tuples of (string, [point]) (conceptual tuples, not literally Haskell tuples) and then look up the string in a map that gives me a [Point] -> Shape
21:20:57 <yshavit_> tomprince: or probably, a [Point] -> Either String Shape
21:21:41 <MostAwesomeDude> shachaf: Well, I'm parsing a thing and building an AST. Is this just not something that people do often? I see this in Haskell a lot, but it tends to be, y'know, a Scheme-alike. :3
21:21:49 <yshavit_> mbetter: so for instance, if I have a Square with bounding box (0,0) - (1, 1), and a Rectangle of the same bounding box, I don't want them to be equal.
21:23:21 <yshavit_> mbetter, tomprince : And my (Shape -> [Point] -> Either String Shape) reader implies a solution to the equality problem, which is that each shape just has its own, unique name. In Java that'd be kinda yucky, but in Haskell would it be appropriate?
21:23:49 <yshavit_> each shape type, rather -- not each shape. Square, Rectangle, etc.
21:26:13 <shachaf> yshavit_: That would seem to close the set of possible data types again.
21:26:26 <tomprince> Hmmm. I'm getting the feeling that the problem isn't well defined enough to give a good answer for how the data types should be structured in Haskell. In Java, it easy since there isn't any choice. In haskell, howver; once you pick the right data types (and type signatures), the code tends to write itself.
21:26:30 <yshavit_> shachaf: why's that?
21:26:32 <shachaf> Well, not if you use Strings for names like you're doing, I guess. But that's indeed yucky.
21:26:38 <mbetter> very yucky
21:26:44 <yshavit_> oh, yes. :)
21:27:52 <mbetter> i agree with tomprince. once you define your goals further, lots of these questions will answer themselves
21:28:31 <yshavit_> hm, I guess i think they're fairly well defined. Maybe I just haven't been communicating them well...
21:29:41 <tomprince> Perhpas if you show us some example code (in psuedo-java), somebody (more experienced than I) might be able to translate it into idiomatic haskell.
21:29:45 <cmasseraf> Anyone have a good introduction link for Formal Method Software Verification?
21:30:36 <mbetter> yshavit_: if you have a limited world of things that are considered Shapes, future developers can be free to create new ways to interact with the Shapes
21:30:59 <yshavit_> each shape should be able to report its area, draw itself (by providing a [DrawStep]), and describe its editing. Let's say that's done by providing a [Point] of editable points, and then a function (Shape -> Point -> Point -> Shape) which, given a Shape, a Point in that Shape, and a proposed replacement for that Point, returns a new Shape...
21:31:16 <yshavit_> and equality should include that last function.
21:32:25 <yshavit_> tomprince: I don't have the Java written -- the original exercise is really a whiteboard design session, virtually no coding. And as someone here mentioned, I'd rather try to think it from the ground up in Haskell terms, rather than writing Java and then translating it.
21:32:47 <tomprince> yshavit_: Well, you did indicate that it was a standard question for you, so you've probably thought about it many times.
21:33:08 <yshavit_> tomprince: yes, but in Java terms :)  I haven't written it down, though I could if you think it'd help.
21:33:12 <shachaf> tomprince: I don't think encouraging yshavit_ to think in terms of a Java solution will help anyone. :-)
21:33:56 <tomprince> No, not now that we have a concrete list of requirements.
21:34:11 <yshavit_> tomprince: but essentially, there'd be a Shape interface and it'd have subclasses for Square, Rectangle, etc -- and equality for those subclasses would include a check of the other object's class, which would answer the "are the constraints the same" question .
21:35:27 <yshavit_> oh, and to add to my list of requirements -- the system should be able to save the shapes to a file and read them back out, handling any errors (a Square with three points, e.g.) gracefully (I'm thinking an Either String Shape)
21:36:03 <mbetter> yshavit_: it sounds like you'd want a type class
21:36:05 <yshavit_> and as mentioned previously, ideally it'd be nice if the shapes were open-world, such that some 3rd party developer could easily come in and create a Triangle.
21:37:00 <yshavit_> mbetter: that's where I started :) ran into the problem of heterogeneous arrays, for which I guess there's an answer but it's not very "haskelly"
21:37:15 <yshavit_> (the existential types)
21:37:51 <shachaf> yshavit_: I think the first step is to call them "lists" (unless you're actually talking about arrays). :-)
21:38:22 <ddarius> shachaf: How 'bout ArrayList as a compromise.
21:38:22 <shachaf> yshavit_: If someone comes along and creates a Triangle, how would it be saved and loaded?
21:38:26 <yshavit_> shachaf: ha, sorry :)  Hard to shake the habit of [] being a list
21:39:28 <mzero> anyone here have experience augmenting a parse AST with location information?
21:40:08 <yshavit_> shachaf: for instance, as the string "Triangle: (0, 0) (0, 1), (1, 1)". And yes, I realize that means a future run may not know what a triangle is, or may try to load a different definition of triangle -- I'm okay with that, as long as the load is allowed to fail if the stored triangle doesn't violate the runtime triangle's constraints (in which case the load would result in the Left String)
21:40:29 <shachaf> mzero: I think I've heard edwardk mumbling something about that in the context of Trifecta.
21:40:39 <shachaf> (Actually, I doubt he was mumbling. He doesn't mumble much.)
21:40:44 <edwardk> ?
21:40:47 <yshavit_> shachaf: more specifically, each shape's read/write would include its unique name, plus a list (not array! :) ) of Point
21:41:01 * edwardk mumbles, "hrmm?"
21:41:19 <edwardk> mzero: trifecta makes that fairly easy
21:41:30 <shachaf> yshavit_: That also sounds yucky, speaking of yucky things.
21:41:32 <ddarius> data Shape = Shape { name :: String, points :: [Point] }
21:42:12 <mzero> I'm just wondering what a good design pattern is --- I see that Haskel.Souce.Exts takes the approach of having a Loc value in every data type, for example
21:42:24 <edwardk> you can annotate a tree at each level with an appropriate Span, Caret, or Rendering
21:42:31 <mzero> Another idea would be to have a Loc wrapper at every node
21:42:31 <yshavit_> shachaf: meh, I don't personally find that aspect too yucky. Though it'd be nice if the name's importance were only important for its read/write -- not its Eq
21:42:42 <edwardk> mzero: the former is usually less of a pain in the behind
21:43:03 <edwardk> there is a way to make the latter more principled (you can treat your syntax tree as the cofree comonad of a base functor)
21:43:11 <edwardk> but its a lot of syntactic overhead
21:43:20 <mzero> Okay - but the later would allow me to stick something like       spanned $    in front of every rule of my grammar
21:43:23 <mzero> and just get it
21:43:24 <edwardk> yeah
21:43:54 <yshavit_> shachaf: if I do go that route, btw, I'm thinking I should definitely newtype that name, at least.
21:43:58 <mzero> I currently have a Parsec parser for a somewhat fiddly grammar
21:44:22 <edwardk> but then all your patterns look like (Foo x y :> l) =  instead of (Foo l x y) -- assuming you use an infix 'cofree' like that
21:44:41 <lispy> is hackage down?
21:44:51 <mzero> right --- or I'd have to case on    unLoc x
21:44:52 <lispy> that down for me website says no, but I can't reach it
21:44:53 <shachaf> lispy: hackage.haskell.org is up for me.
21:45:02 <edwardk> and the cofree idiom can be harder to work with when you have a complicated ast with multiple types, statements, expressions, etc.
21:45:11 <shachaf> (And I'm using Comcast DNS!)
21:45:16 <edwardk> there is a way to salvage it, by 'rolling' the constructor a bit, but its tricky
21:45:30 <lispy> shachaf: me too
21:45:44 <shachaf> lispy: Is comonad.com up for you?
21:45:45 <edwardk> so i tend to just recommend the slightly simpler span-in-every-node approach
21:46:03 <edwardk> this has the benefit that you can sometimes elide it, e.g. by letting variables themselves hold a span
21:46:08 <lispy> shachaf: nope
21:46:47 <mzero> how does Trifecta do it?
21:46:50 <Twey> What's the easiest way to get the number of picoseconds elapsed within the current day?
21:46:51 <lispy> shachaf: that's somehow related I take it?
21:46:53 <edwardk> neither wins in all circumstances, but having done both, the annoying 'field in every constructor' approach, is less annoying than the extra constructor at every level
21:47:03 <edwardk> trifecta is completely agnostic with regards to your AST
21:47:03 <shachaf> lispy: Nope.
21:47:24 <yshavit_> shachaf, mbetter: I hate to say it, but to my Java-y mind, an existential type seems nicest :-\ That way, a data Square equals a data Square if their bounding boxes are the same, and I don't need to take the edit function into account at all.
21:47:28 <mzero> I see, so it doesn't auto-powy-magical fix this for me.... ?
21:47:31 <mzero> :-)
21:47:34 <lispy> shachaf: oh, then why did you have me check it?
21:47:35 <edwardk> sadly no
21:47:50 <ddarius> yshavit_: You define equality.
21:47:57 <edwardk> i have a 'spanned' combinator that wraps a type 'a' in an Spanned constructor, but you probably don't want to use the Spanned comonad for your AST
21:48:01 <shachaf> lispy: Because it's down for me.
21:48:07 <yshavit_> ddarius: I know, the problem is that I want a function to be part of that equality.
21:48:09 <shachaf> (And I think it has to do with Comcast's DNS.)
21:48:19 <edwardk> (though, admittedly you could)
21:48:23 <yshavit_> ddarius: I wrote a more detailed set of requirements above.
21:48:25 <Twey> If I use Data.Time and utctDayTime, I can get a DiffTime value that represents my time… but I'm having trouble figuring out how I'm supposed to get the value out of it
21:48:38 <shachaf> lispy: Anyway, hackage.haskell.org (69.30.63.204) seems to be up.
21:48:40 <mzero> right now I'm getting away with mostly just type defs     type Pipeline = [ Command ]     --- adding Loc within every constructor - is going to mean adding many constructors
21:48:42 <mzero> sigh
21:48:56 <edwardk> yep
21:49:20 <edwardk> Well, you can get by by using type Pipeline = Careted [Command]
21:49:30 <lispy> shachaf: I just tried http://69.30.63.204/package/cabal-nirvana and I'm still timing out
21:49:32 <edwardk> and then only have to do a few explicitly
21:49:37 <lispy> shachaf: so dns might be fine
21:50:08 <shachaf> lispy: Well, it's a virtual host, so just going to the IP wouldn't work anyway. But that URL gives me a 404.
21:50:33 <edwardk> or rather Rendered [Command] is probably a better choice
21:50:45 <yshavit_> shachaf, mbetter, ddarius et al: I think I should go to bed (it's 1am), but I've definitely got a lot to sleep on. I've got a few options floating in my head... should probably call it a night.
21:50:50 <ddarius> Shallot [Command]
21:50:53 <edwardk> that way the individual AST element can know how to draw itself with ^'s ~~~'s etc. under the source
21:51:00 <mbetter> yshavit_: same here
21:51:03 <edwardk> ddarius: =P
21:51:45 <lispy> shachaf: dig/traceroute can figure out the ip
21:52:04 <mzero> and there is the ugly issue of getting the span just right - don't want to accidentally include the trailing whitespace to the next token.... looks bad
21:52:13 <lispy> shachaf: traceroute is timing out though, around easystreet: vlan5.cis197cor04.bea1.easy.easystreet.com
21:52:37 <davidL> lispy: comcast is having routing issues. you're not alone
21:52:54 <yshavit_> For now I'm thinking that the Shape will have the simple record (area, draw, edit), as well as a unique ID assigned by the system. What the 3rd party dev provides isn't actually the shape data type, it's a bunch of info (including a name and the edit function) which the system can register, and then create shapes accordingly -- and each shape type will have its own, unique-per-run ID
21:52:55 <mzero> The other crazy idea I had was to parameterize the whole tree on some decorator type  ---
21:53:06 <yshavit_> details to be hashed out at a later time :)
21:53:16 <mzero> and then use an identity decorator for when I'm just running the AST
21:53:41 <lispy> davidL: Wait, I think I'm alone.  Are you saying you're hiding in my bathroom?
21:55:20 <yshavit_> good night all!
21:55:42 <lispy> can't even get to craigslist...
21:55:46 <davidL> lispy: hiding is the wrong word ;)
21:56:12 <vivek_007> Whats the difference between languages like python, ruby with Haskell ?? Is there a big difference???
21:57:07 <mzero> edwardk: when you say cofree I'm only sort of grasping what you mean - is there a reference to this pattern?
21:57:07 <mauke> vivek_007: yes!!!!!!
21:57:20 <edwardk> mzero: i wrote an article. one sec
21:57:29 <mzero> you rock
21:57:41 <edwardk> http://comonad.com/reader/2009/incremental-folds/
21:57:52 <SecretCarrot> vivek_007: is there a difference between juice, coffee and tea?
21:58:08 <edwardk> the type :> in that write up is the cofree comonad
21:58:09 <mzero> and an hpaste I found! http://hpaste.org/64546
21:58:18 <edwardk> i also have a package with it
21:58:38 <Twey> edwardk: Ooh, you made your site prettier since last I was here.
21:58:41 <edwardk> http://hackage.haskell.org/packages/archive/free/2.0.3/doc/html/Control-Comonad-Cofree.html
21:58:46 <edwardk> twey: ?
21:58:59 <edwardk> same design since 2008 or so ;)
21:59:12 <Twey> Really?  I don't remember it looking like this
21:59:24 <Twey> *shrug*
21:59:32 <shachaf> Twey: Maybe you've been using Comcast DNS since 2008.
21:59:37 <edwardk> hahahaha
21:59:43 <edwardk> comcast seems to dislike me
21:59:43 <SecretCarrot> vivek_007: haskell is a functional programming language, while the other two you mentioned are having some parts from functional programming, they are mostly considered to be imprerative programming languages
21:59:43 * shachaf types "for the past two years", looked at date, became sad. :-(
22:00:51 <vivek_007> SecretCarrot: Thank u :) But for what purposes is it generally preferred?
22:01:57 <blackdog> vivek_007: pretty good at cases where you care about being right. much faster than it used to be (generally close to well-written C now - factor of 3, maybe?), and good at running many threads at once.
22:01:58 <mikeplus64> vivek_007: many people like haskell for "pure" problems (no IO) but it's really as good at being a general purpose language than any other high-ish level language out there
22:02:17 <Twey> shachaf: British equivalent :þ
22:03:00 <SecretCarrot> vivek_007: haskell is taking software safety a step further than the other. the compiler finds most mistakes and once a program (at least a small one) is compiling it is often working from first attempt. also, haskell is a language that can be compiled with ghc and you have a much faster program than with python or ruby
22:03:43 <mikeplus64> only type errors, ghc won't magically fix your logic :)
22:03:55 <SecretCarrot> mikeplus64: of course :)
22:03:56 <vivek_007> Okies ...
22:04:18 <SecretCarrot> @where lyah
22:04:18 <lambdabot> http://www.learnyouahaskell.com/
22:04:23 <SecretCarrot> vivek_007: ^^
22:04:45 <SecretCarrot> vivek_007: check the link lambdabot gave
22:06:36 <MostAwesomeDude> edwardk: Is trifecta ready for use?
22:06:53 <vivek_007> Ok ..
22:07:14 <edwardk> MostAwesomeDude: i intend to simplify the diagnostic handling quite a bit, but dylukes and a few others have gotten quite a bit of mileage out of it so far
22:07:25 <MostAwesomeDude> edwardk: Cool. Any documentation on it?
22:07:50 <edwardk> not a whole lot, the main thing is its basically parsec designed around typeclasses
22:08:03 <MostAwesomeDude> Hm.
22:08:24 <edwardk> and the main implementation of the parser uses ropes to store its input, which makes it good at programming languages, but bad at things like log files
22:08:37 <edwardk> in particular i tend to say its designed for 'human scale' inputs
22:09:08 <blackdog> mikeplus64: to an extent, the point is to bake logic errors into your types
22:09:10 <MostAwesomeDude> Well, I am parsing complex languages. Looks like it's got highlighters and stuff too.
22:09:10 <edwardk> and stuff that is in ascii or utf-8, since the error messages get formatted with slices of the source code assuming that it is in that kind of format
22:09:14 <edwardk> yeah
22:09:16 <blackdog> uh,  bake them out, i guess?
22:09:27 <blackdog> oh dear. this metaphor is falling apart like an overly moistcake.
22:09:52 <MostAwesomeDude> Is there a main entrypoint I could look at, or should I just try to absorb it all through osmosis?
22:09:54 <edwardk> the token parsers automatically add information to a highlight interval map, so you can dump out the highlighted version of the source file. not every parser implementation is required to track the highlights, but the reference implementation does
22:10:00 <mikeplus64> don't worry, your point is clear, blackdog
22:10:17 <edwardk> hrmm, well, i suppose you could look at dylukes' STGMA which uses it to parse an STG like language
22:10:58 <edwardk> https://github.com/DylanLukes/Winchester-STG-Compiler/blob/master/WSC/Parser.hs
22:11:05 <edwardk> oh, he renamed it apparently
22:11:30 <DrAwesomeClaws> hey everyone.  I'm a haskell noob, currently playing around trying to get some intuition about it.  I wrote a function with type (t -> a) -> [t] -> [a]     Did I just basically write map (which reports (a -> b) -> [a] -> [b]?
22:11:44 <MostAwesomeDude> DrAwesomeClaws: Possibly.
22:11:51 <edwardk> DrAwesomeClaws: most likely
22:11:56 <shachaf> DrAwesomeClaws: We can't know for sure, but map is the most reasonable function with that type.
22:11:56 <MostAwesomeDude> @djinn (a -> b) -> [a] -> [b]
22:11:56 <lambdabot> Error: Undefined type []
22:12:20 <DrAwesomeClaws> mutate a (x:xs) = (a (x)) : mutate a (xs)
22:12:23 <edwardk> DrAwesomeClaws: technically the only such functions you could have written are ones that may possibly scramble, replicate or drop some of the inputs after running them through the supplied function ;)
22:13:09 <DrAwesomeClaws> ah, yeah... I get it i think.  There are other functions besides map that could take that type.  It just struck me when i saw the type of my function... "Hey, that looks familiar"
22:13:10 <DrAwesomeClaws> haha
22:13:19 <edwardk> @free foo :: (a -> b) -> [a] -> [b]
22:13:19 <lambdabot> g . h = k . f => $map g . foo h = foo k . $map f
22:13:30 <shachaf> edwardk: Or that returns an empty list!
22:13:31 <MostAwesomeDude> @src map
22:13:31 <lambdabot> map _ []     = []
22:13:31 <lambdabot> map f (x:xs) = f x : map f xs
22:13:36 <MostAwesomeDude> DrAwesomeClaws: ^^ pretty much
22:13:41 <shachaf> Hmm, I guess that goes under "drop"
22:13:45 <edwardk> and your function can be distributed over the real map
22:13:45 <edwardk> shachaf: yeah
22:13:52 <edwardk> er not distributed, commuted
22:13:55 <DrAwesomeClaws> thanks for the info everyone, off to confuse myself some more
22:15:24 * hackagebot mwc-random 0.12.0.0 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.12.0.0 (BryanOSullivan)
22:15:48 <miyako> so, tomorrow at work we're having a meeting to decide whether haskell or common lisp will be our offically sanctioned functional language- any advice?  I haven't found much in the way of articles talking about people using haskell beyond "here are some companies that use haskell"
22:16:12 <blackdog> miyako: might be worth checking CUFP
22:16:13 <mauke> common lisp isn't a functional language
22:16:14 <Twey> miyako: Well, Common Lisp isn't a functional language, so that one's right out ;)
22:16:39 <blackdog> from a tactical point of view, a definitional argument doesn't win you many victories:)
22:16:51 <miyako> Twey; blackdog: well, CL supports functional programming better than the other languages we're using
22:16:57 <adnauseam> haskell is a modern and rapidly evolign functional language that's designed to be scalabale on multi-core systems
22:17:07 <DrAwesomeClaws> can you two expand on that or link a source?  I've always thought of lisp as an example of a functional language... but I don't claim to actually know.  Curious
22:17:09 <adnauseam> what mroe wold one need :o
22:17:27 <mikeplus64> miyako: what adnauseam said
22:17:31 <mikeplus64> haha
22:17:33 <mauke> DrAwesomeClaws: if CL counts as functional, then so does Perl/Javascript/whatever
22:17:40 <shachaf> DrAwesomeClaws: It's a matter of definitions and therefore probably not worth arguing about.
22:17:53 <mzero> setq
22:18:03 <Elemir> CL suppors functional programming?!?
22:18:11 <Twey> DrAwesomeClaws: Common Lisp is an imperative language with first-class functions, like Python or Ruby.  It has mutable state, impure procedures, and (progn) for explicit sequencing.
22:18:20 <Elemir> In parallel universe?
22:18:24 <DrAwesomeClaws> ah, that makes sense.
22:18:38 <mzero> miyako: that sounds crazy - is it like "10am - 11:30, meeting in Big Conf. Room A, agenda: CL or Haskell."
22:18:42 <Twey> For the usual definitions, anyway.  If you stretch them enough, you can prove that C is a pure functional language ;)
22:18:55 <mzero> what are you going to do? debate? take a vote?
22:19:15 <mzero> choosing a language for development work is a big choice, with many nuanced factors -
22:19:49 <mzero> how can you just "have a meeting to decide"?
22:20:00 <miyako> mzero: well, it's pretty much going to come down to a debate
22:20:06 <tomprince> Haskell has an active, inclusive community. I'm not so sure about lisp. Racket probaly does somewhat too.
22:20:12 <DrAwesomeClaws> Haskell seems like it'd be more robust in a production environment (Static/Strict typing, purity, etc) than Lisp.  And if any programmer that can program (or has the ability to learn to program) Lisp should be able to pick up haskell just as easily.  But that's just me guessing
22:20:26 * hackagebot cabal-nirvana 0.2 - Avoid Cabal dependency hell by constraining to known good versions.  http://hackage.haskell.org/package/cabal-nirvana-0.2 (MichaelSnoyman)
22:20:26 <tomprince> Common lisp, not so much, I don't think.
22:20:37 <blackdog> miyako: we are, of course, jumping to the conclusion that haskell is a better choice:) but the nonfragmented community is probably a plus
22:20:41 <miyako> basically, I had something to write, I was going to use haskell because it was a good fit, but one of the other developers was aruging that we should use CL instead, then bosses got involved
22:20:52 <mikeplus64> (besides (haskell (this stuff) (doesn't have)))
22:20:55 <mikeplus64> (everywhere)
22:21:33 <miyako> blackdog: non-fragmented community was one of my big points, along with haskell's overall better documentation for the developers on the team who don't know it
22:21:53 <Twey> miyako: In a commercial context you should probably bring up robustness by static tying
22:21:56 <Twey> typing**
22:22:26 <Twey> Oh, and the concurrency thing
22:22:32 <mikeplus64> miyako: add easy and fast concurrency/parellelism
22:22:55 <Twey> mzero: How would *you* choose a language for development?
22:23:11 <adnauseam> consider the production of maintainable code - even john carmack was considering Haskell - but decided not to due to the costs of training the team
22:23:26 <adnauseam> but if your team is up to learning haskell - it can only benefit
22:23:27 <DrAwesomeClaws> purely anecdotal, but I've noticed Haskell programmers generally have cooler and more interesting beards
22:23:32 <Twey> Haha
22:24:08 <miyako> DrAwesomeClaws: although an interesting point, we all already have majestic unix beards so I don't know that it would help me win the argument ;)
22:24:20 <mzero> I'd consider the deployment environment, the development path, the external requirements on the software to be produced, the comfort level of the team with the language, the schedule....
22:24:25 <mzero> ... and then I'd pick Haskell
22:24:25 <DrAwesomeClaws> sounds like a good place to work
22:24:38 <DrAwesomeClaws> haha
22:24:54 <tomprince> I've noticed quite a few python programmers are interested in haskell+ocaml.
22:25:18 <SHODAN> what about visual basic!?
22:25:23 <mikeplus64> my thought process is to use the best language for the job at hand, which is of course haskell
22:25:27 <mikeplus64> SHODAN: WHAT ABOUT IT.
22:25:34 <SHODAN> it's better than haskell, right?
22:25:39 <DanBurton> oh look it's cabal-nirvana 0.2 already
22:25:41 <SHODAN> just kidding ..
22:26:08 <companion_cube> however, performance of CL may be more predictable and easy to tune
22:26:13 <DrAwesomeClaws> Visual Basic is mostly useful for hacker guis.  Careful you don't get WinNuked
22:26:19 <mikeplus64> I've had to dust off the VB 6 recently and :()()^%&%^:$#%#@
22:26:20 <SHODAN> :D
22:26:23 <mikeplus64> the horror
22:26:39 <mikeplus64> too many ducks
22:27:28 <Twey> mzero: I guess these are the sort of things the company is hoping will be brought up if they bring all the developers into a big debate?
22:27:57 <miyako> yeah, the "haskell makes it hard to reason about performance" issue was brought up, although I'm not convinced that performance in haskell is nearly as bad as people make it out to be
22:28:07 <mzero> I'm not either
22:28:08 <Cale> SHODAN: What are you 1 dan in?
22:28:30 <SHODAN> Cale, no karate! it's from system shock
22:28:34 <mzero> and I think the 'training cost' argument is baloney too
22:28:41 <mikeplus64> miyako: it isn't
22:28:41 <Cale> I was thinking perhaps go.
22:29:07 * DanBurton ponders the possibility of making an eager-esque Haskell compiler
22:29:17 <mzero> I think I get any reasonably good programmer coding in Haskell in a day - and feeling productive in a week at most
22:29:20 <ddarius> DanBurton: Multiple ones have been made.
22:29:28 <DanBurton> ddarius: such as?
22:29:57 <mzero> Cale - you play Go? I do... but not nearly shodan
22:29:57 <miyako> mzero: well, as it stands right now on a team of 5, 2 of us know lisp and 1.5 of us know haskell, so training is required either way, but there doesn't really seem to be a lisp equivlent of LYAH, nor hayoo/hoogle or the haskell wiki
22:30:00 <adnauseam> mzero: got tips ? :o
22:30:29 <DanBurton> @google land of lisp
22:30:30 <lambdabot> http://landoflisp.com/
22:30:50 <Twey> DanBurton: Idris is basically an eager Haskell^WAgda
22:30:53 <ddarius> Eager Haskell, a speculative evaluation branch of GHC, some other branch of GHC, other "eager Haskell's", other Haskell-like languages such as Disciple.
22:31:04 <mzero> mzero: well, presumably you've heard of my video, so you can see the kind of approach I'd take
22:31:06 <Twey> Yeah
22:31:18 <ddarius> mzero has lost it.
22:31:30 <mzero> ?
22:31:40 <DanBurton> you directed your previous comment at yourself
22:31:47 <mzero> hahahah
22:31:50 <mzero> I have
22:31:58 <Rotaerk> ugh, not sure if parsec does this, but in fparsec, apparently the single-character parsers specially handle newlines
22:32:16 <Cale> mzero: The highest I got was maybe around 6 kyu
22:32:36 <mzero> I'm supposed to be coding - but then edwardk directed me at Cofree and now my mind is Jello   m ::> f (Cofree f m)   indeed!
22:32:43 <Cale> mzero: But that was back when I played all the time :)
22:32:50 <Rotaerk> such that if you say "pchar '\r'" and the input stream is at "\r\n", it'll return "\r" but consume both "\r\n"
22:32:59 <mzero> I was about 8kyu when I played regularly
22:33:21 <edwardk> mzero: hah
22:33:50 <miyako> ah well, I suppose I'm lucky that the debate isn't "java or c#" and not worry too much about it
22:33:50 <edwardk> i suck at go, but am pretty good at go puzzles
22:34:11 <mzero> Rotaerk: ew! why would you want that hidden under the char parser?
22:34:23 <Rotaerk> mzero, I don't know !
22:34:26 <mzero> when it is SO easy to write the parser that does that when you need it!
22:34:29 <DrAwesomeClaws> Re: Ability to reason about performance: From my experience with non-haskell (or functional) platforms of all sorts -- and with some notable exceptions -- most of the time performance can be dealt with in terms of finding major bottlenecks and optimizing those.  The large bottlenecks are usually apparent, and thus when tackling performance issues you're generally focused on some relatively easy to identify, and limited,
22:34:29 <DrAwesomeClaws> areas of the code base.  The challenge lies with actually optimizing the algorithms that those sections of code describe.  I'd *guess* with Haskell you'd be able to more efficiently reason about the actual algorithms that need to be optimized, which would more than make of for a slightly increased detriment of the ability to reason about the performance of the whole.
22:34:33 <Rotaerk> mzero, exactly
22:34:52 <Rotaerk> I was trying to test the results of my parser with the expected values, and getting mismatches because of this flaw..
22:35:11 <mzero> that smells like a flaw to me
22:38:47 <yitz> DrAwesomeClaws: i deny that there is inherently any less ability to reason about the performance of haskell programs as a whole. the thinking is very different in nature though, so perhaps one loses a bit of the organic industry-wide expertise, but in principal there is no reason why it should be any harder. (it's a hard problem to begin with of course.)
22:38:54 <notrusty2> http://www.quanttec.com/fparsec/reference/charparsers.html#members.pchar
22:38:57 <miyako> well, I suppose I should get to bed, thanks for the insight all.  I'll stop by tomorrow and let you know how it turned out.
22:39:15 <DrAwesomeClaws> night
22:41:43 <yitz> DrAwesomeClaws: whether or not i'm right, i can give the anecdotal evidence that while developing large and complex commercial systems in haskell, i have never had any more difficulty finding performance bottlenecks than in systems of similar scale in any other language. that said, once they are found, eliminating hasn't been any easier in haskell. it seems to be pretty much a language-independent issue.
22:42:32 <DrAwesomeClaws> yitz, you're probably right.  I'm kind of talking out of my ass... just typing to help myself think about it, haha.  And I'm thinking of some real world instances where problems become much more complex than they ordinarily would because of bad/anti patterns and sloppyness.  My impression is that writing in Haskell, with Static typing, purity, etc on your side would discourage bad code more so than in most other language
22:42:32 <DrAwesomeClaws> s.  But I don't really know anything, complete Haskell noob here
22:43:36 <DrAwesomeClaws> The thing that draws me to haskell most (so far) is that it's really forcing me to think about my code before I just start writing it
22:43:37 <yitz> mzero: i'd be interested to hear more about your approach to get muscle-bound imeprative programmers working productively in haskell within a day.
22:43:48 <DrAwesomeClaws> (with the exception of playing around in ghci)
22:44:51 <yitz> DrAwesomeClaws: yeah, you can just start writing, but what you write at the beginning is usually types, not code that does stuff, so it helps you notice important things up front.
22:44:55 <mzero> yitz: my two runs at it are the Barley project, which was field tested last year - where we got 40 or so web programmers coding haskell web pages in about four hours
22:45:16 <mzero> and my one hour intro to Haskell, which I did as a talk live twice
22:46:31 <DrAwesomeClaws> mzero, I seem to remember being familiar with your talk one of the other times I've popped in here in the past... but right now I'm blanking on who you are.  Link your talk(s) if you don't mind, looking for some background audio/video while i sit in bed and play with ghci
22:46:32 <yitz> mzero: well, with web programming you can cheat using yesod. copy a little boilerplate, write html and css inside quasiquoters, and your site is up.
22:46:37 <mzero> I'd say the basic thing is a fundamental attitude of "you can do this, and we don't need to baby-step around it" - so I get the syntax out of the way quick - get types in front of 'em quick - don't try to explain the deep mysteries of monads or such
22:47:11 <mzero> we didn't - we got them to build up HTML from data structures - teaching them map in the process, for example
22:47:28 <mzero> @where amuse-bouche
22:47:29 <lambdabot> I know nothing about amuse-bouche.
22:47:37 <mzero> @where Haskell Amuse-Bouche
22:47:37 <lambdabot> http://haskell.org
22:47:42 <mzero> silly lambdabot
22:48:00 <mzero> http://www.youtube.com/watch?v=b9FagOVqxmI
22:48:14 <DrAwesomeClaws> thank you
22:48:18 <yitz> mzero: extremely silly now - whenever you try to get her to say anything she just quotes Richard Nixon.
22:50:01 <DrAwesomeClaws> ah, I have seen this before.  Actually I was thinking about it earlier today, but couldn't remember what talk / who gave it.  Watching again now, awesome talk though.
22:50:10 <mzero> be sure to open up the "show more" slider to get the links to the slides and code repo
22:50:19 <mzero> thank you
22:50:36 <DrAwesomeClaws> this was the first time Maybe actually made sense to me
22:51:02 <mzero> Maybe is the gateway drug of Haskell...
22:51:21 <ddarius> mzero: It is ridiculous if that is true.
22:51:44 <DrAwesomeClaws> well, it made sense to me before to some extent... but I didn't "get it".  My reaction to Maybe went from... "so?" to "holy shit, that's awesome"
22:53:08 <mzero> Maybe is the first thing that a C/C++/Java programmer can see that shows the type system actually doing something for them, besides just keeping them from incorrectly dereferencing a pointer
22:55:03 <beyondnotion> hello
22:55:52 <mzero> welcome, beyondnotion
22:55:55 <ddarius> mzero: Java and C++ programmers can easily implement Maybe.
22:56:41 <mzero> they can - but they don't - and they don't because it is syntactically painful and you don't get wondrous stuff like   maybe   fmap   and  >>=
22:57:29 <shergill> @where agda
22:57:29 <lambdabot> Agda2, proof assistant / dependently typed FPL, at <http://wiki.portal.chalmers.se/agda/> -- Agda1, earlier incarnation, at (broken) <http://www.cse.chalmers.se/~catarina/agda/>,<http://web.archive.
22:57:29 <lambdabot> org/web/*/http://www.cs.chalmers.se/~catarina/agda/>. Also see `Alfa',`Cayenne'
22:57:37 <mzero> instead they use null because it is syntactically easy, and it casts to bool in if statements correctly
22:57:40 <ddarius> You can easily get all of that and it's not as compact as data Maybe a = Nothing | Just a, but it isn't that bad.
22:57:40 <DrAwesomeClaws> ddarius: how often does that happen?  haha, I've never seen it.  to me it was more of a revelation of "wow, there's a different way to handle this" which I never see from my experiences in the imperative / mostly dynamically/loosely typed world
22:58:27 <ddarius> DrAwesomeClaws: Yes, that is the ridiculous part.  Maybe is trivial and not in any way FP, let alone Haskell, specific.
22:58:39 <mzero> actually, it isn't easy to create a Maybe in C++ that is sound and works for all types --- no algebraic unions
22:58:49 <ddarius> mzero: Use OO.
22:59:20 <mzero> your makin' my point for me - look at Boost's Optional (is that what it is called?)
23:00:06 <ddarius> C++ is crazy and boost is fairly crazy too, but there is no reason Maybe need be more complicated than any other C++ type.
23:00:19 <ddarius> That said, most C++ types are extremely complicated to implement correctly.
23:00:58 <mzero> and yet....
23:01:14 <ddarius> mzero: I'm pretty sure you are misunderstanding the spirit of my original comment.
23:01:24 <mzero> and perhaps you mine
23:01:43 <osa1> what does # signs after names mean?
23:01:43 <DrAwesomeClaws> I'm actually just learning haskell to be more successful with the ladies.
23:01:58 <mzero> I guess I just disagree: Java and C++ programmers *can't* easily implement Maybe
23:02:14 <dmwit> osa1: It's a convention for unboxed values.
23:02:42 <mzero> DrAwesomeClaws: what, the awesome claws aren't enough?
23:03:15 <DrAwesomeClaws> sadly not always, nor my pretend doctorate when I'm on irc/reddit
23:04:13 <shergill> @djinn (a -> Maybe a) -> (a -> Maybe (a,a))
23:04:13 <lambdabot> f a b =
23:04:13 <lambdabot>     case a b of
23:04:13 <lambdabot>     Nothing -> Nothing
23:04:13 <lambdabot>     Just c -> Just (c, c)
23:04:34 <dmwit> :t fmap (\x -> (x,x))
23:04:35 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
23:05:28 <ddarius> interface Maybe<A> { public B CaseMaybe<B>(B nothing, Func<A,B> just); }; class Nothing<A> : Maybe<A> { public Nothing(){}; public B CaseMaybe<B>(B nothing, Func<A,B> just) { return nothing; } }; class Just<A> : Maybe<A> { private readonly A val; public Just(A val) { this.val = val; }; public B CaseMaybe<B>(B nothing, Func<A,B> just) { return just(val); } }
23:05:53 <mzero> :t fmap (id &&& id)
23:05:54 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
23:05:57 <ddarius> There you go for C#.  (Older) Java would require you making an interface for Func<A,B> but that is straightforward.
23:06:30 <ddarius> Implementing fmap, (>>=), and any function whatsoever over Maybe types is doable in terms of this interface.
23:07:11 <ddarius> You can do the same thing in C++ though obviously there are a lot more things to worry about to do it correctly, but that's more due to lack of memory-safety and garbage collection.
23:08:18 <mzero> that, and function objects are just plain painful
23:08:28 <mauke> boost::function
23:08:57 <mauke> or in this case: fuck types, go with C func
23:09:07 <ddarius> You can have an IsJust, IsNothing, GetValue to avoid needing higher-order functions.  The same can be done in Java to avoid anonymous inner classes.
23:09:11 <MostAwesomeDude> class Maybe(object): def __init__(self, value): self.value = value;; def isJust(self): return self.value is not None
23:10:12 <mauke> MostAwesomeDude: Maybe(None)
23:10:35 <mzero> night all
23:10:37 <ddarius> In fact, I did exactly this to implement immutable singly linked lists in Java just the other day.
23:10:58 <MostAwesomeDude> mauke: Sorry, did you want a Nothing singleton? Could do that instead.
23:11:20 <MostAwesomeDude> Actually, None really does implement the semantics of Maybe pretty well.
23:11:51 <MostAwesomeDude> Everything either is, or is not, None. And there's only one None, and it has no value.
23:12:30 <DrAwesomeClaws> That's why I love programming, I can ponder "Everything either is, or is not, None. And there's only one None, and it has no value." without completely feeling like a pot head
23:15:09 <ddarius> DrAwesomeClaws: If you feel None implements the semantics of Maybe pretty well then you are not grasping what it does.
23:15:29 <DrAwesomeClaws> I'm not saying that, just making a joke, haha
23:15:56 <DrAwesomeClaws> one doesn't need to agree to a conjecture to ponder it
23:16:58 * DrAwesomeClaws shouldn't get stoned in the haskell channel
23:17:28 <yitz> @tell mzero nice video thanks
23:17:28 <lambdabot> Consider it noted.
23:17:40 <ivanm> DrAwesomeClaws: s/ in the haskell channel//
23:17:41 <ivanm> ;)
23:18:10 <maus> Hi, what's the advised way to install haskell-platform on ubuntu-12.04?
23:19:03 <ddarius> maus: Use the haskell-platform in the Ubuntu-12.04 repositories.  If it does not exist, wait until it does.
23:19:08 <ddarius> (or make it exist)
23:19:17 <DrAwesomeClaws> haha.  It doesn't make me smarter, but it does make me more interested.  I'd probably be watching a movie or something right now, instead I'm clumsily dancing in ghci.
23:19:50 <maus> ddarius, It exists. But ghc-7.0 doesn't. There is only ghc-7.4 in the official repo.
23:20:23 <ddarius> maus: When did versions of GHC become relevant?
23:21:09 <maus> ddarius, haskell-platform has a dependency ghc (< 7.0.4+)
23:22:20 <ddarius> If there is a haskell-platform package in the Ubuntu repositories, it will use packages also in the Ubuntu repositories and should "just work" if the people packaging the haskell-platform for Ubuntu are doing there jobs at all.
23:22:21 <ivanm> ddarius: the latest platform is still 7.0.4
23:22:24 <maus> I tried using ghc-7.4 and found plenty of packages i need fail to compile
23:22:35 <ivanm> maus: yeah, 7.4 isn't aimed at end users yet
23:22:49 <ivanm> (end-users == people not wanting to tinker with haskell packages)
23:23:12 <ddarius> ivanm: If Ubuntu-12.04 has GHC 7.4 only, then it probably doesn't have a haskell-platform package.
23:23:14 <maus> ivanm, still 7.4 is the sole version in the repo :)
23:23:56 <maus> I'll try this one now http://packages.ubuntu.com/oneiric/ghc
23:24:24 <ivanm> ddarius: yeah, sounds like the ubuntu packagers went from "Haskell? huh? wassat?" to "we need the latest and greatest!!!"
23:24:55 <maus> yeah :D
23:25:30 <ddarius> ivanm: I'm pretty sure they package whatever is current when they start the packaging process.
23:27:15 <maus> they packaged incompatible versions of haskell-platform and the rest packages :) you just do apt-get install haskell-platform and get two pages of dependency errors :(
23:28:09 <ddarius> Perhaps you should wait for 12.04 to actually be released.
23:30:30 <maus> too late... And if not to take haskell into account, it works far better than 11.10 for me.
23:32:15 <maus> installed ghc-7.0.3 from oneiric. Looks like all works :)
23:32:22 <mrcarrot> (openbsd has haskell platform, with ghc 7.0.4 and a lot of other haskell libraries ready compiled)
23:34:22 <maus> mrcarrot, If only it also had drivers for my hardware...
23:35:22 <mrcarrot> maus: what does it not have drivers for?
23:37:43 <maus> mrcarrot, I guess it offtopic here. My experience with BSD comes from 2004, it was a terrible situation then. Maybe it changed now. Don't know for sure.
23:40:32 <mrcarrot> maus: yeah, it is pretty much offtopic here. bsd is of course a little bit behind in hardware support, but unless you have some really strange hardware it works nowdays on most computers. it is working on all my computers at least
23:41:47 <mrcarrot> maus: well, at least if you do not need fast 3d support... there openbsd is still lacking. i do not need it personally so it is not a big issue for me
23:43:05 <maus> mrcarrot, I respect bsd folks for their profound approach. If Linux would become popular enough on destop to attract hackers, I would surely move :)
23:43:44 <DrAwesomeClaws> I hear 2012 is the year of the linux desktop
23:44:19 <mrcarrot> maus: it was not the security that got me to switch, it was the easiness to maintain and the good documentation together with good stability
23:44:23 <maus> I hear it every year :)
23:46:05 <mrcarrot> DrAwesomeClaws: *nix is more far away than ever from "the year of the *nix desktop".
23:46:36 <maus> mrcarrot, that's not so bad, after all
23:47:04 <DrAwesomeClaws> I've got a "Boot" magazine in a box somewhere that claims the linux desktop has arrived and includes a CD with redhat 5.2
23:47:09 <Cale> DrAwesomeClaws: lol, no, that was 2010 maybe. 2012 is the year that the linux desktop spends being completely broken and annoying because of UI designers thinking that everyone now only has a tablet PC apparently.
23:47:34 <mrcarrot> DrAwesomeClaws: before we had just two big desktop environment... then both destroyed all their assets and now we have plenty of desktops because there is absolutely no unity. and without a unity among the develops there will not be anything like the year of linux on the desktop.
23:47:39 <Cale> Note that it's also much of the same story for Windows :)
23:47:52 <DrAwesomeClaws> I just gave up on gnome... installed xmonad and haven't looked back.  I love it, maybe in a few months I'll know haskell well enough to actually configure it too
23:48:14 <mrcarrot> it is more the year of the linux desktops rather than the year of linux on desktop
23:49:01 <Cale> Unity is exactly the problem that I'm talking about, actually ;)
23:49:48 <mrcarrot> this whole problem is of course also contaminating all other *nix
23:49:52 <Cale> (as in Gnome's new UI)
23:50:19 <Cale> Or, Ubuntu's rather
23:50:27 <Cale> I think Gnome has its own annoying variant.
23:50:50 <Cale> Yeah, Gnome Shell.
23:52:16 <mikeplus64> GNOME 3 really isn't that bad last time I tried it
23:52:28 <mikeplus64> 3.0 was horrible; it didn't even run on my computer
23:52:51 <ChristianS> still quite happy with xfce
23:52:54 <mikeplus64> and the newer PulseAudio actually works on my computer too, which is also nicer than it not working at all
23:53:05 <mikeplus64> yeah, I run XMonad, but GNOME 3 is pretty good for what it is
23:53:12 <mrcarrot> mikeplus64: this is what happened when i tried gnome3. some useful applets in the bar stopped to work and got disabled, and no way to ever add them back. the lack of ability to configure is really annoying.
23:53:30 <DrAwesomeClaws> Gnome is just all... clunky with huge margins around everything these days.  xmonad (or tiled in general) is so much nicer.  I'm actually running an ubuntu VM on my macbook now just so I can use xmonad on top of OS X (without the huge pain in the ass of getting it all compiled for OS X)
23:53:32 <mikeplus64> the whole shell is configurable via js and css last time I checked
23:53:43 <mikeplus64> yeah, I hate the huge margins around everything
23:53:44 <mrcarrot> i am running xmonad myself, but i do test the major DE as i often end up installing computers for other persons and i need to know how good they are
23:53:55 <Cale> I'm not sure if it's PA's fault exactly, but all the newer audio systems seem to do this horribly annoying jack sense thing where having my headset plugged in means that my speakers force-mute themselves.
23:56:31 <mrcarrot> aucat > pulseaudio
23:56:58 <DrAwesomeClaws> how's kde doing these days?  I haven't used it in years (and nothing will move me from xmonad now), I'm curious as to how it's doing.  I never cared for it much, felt like I was in a rocket ship made out of candy or something when I used it.
23:57:08 <mikeplus64> KDE is pretty good imo
23:57:17 <mikeplus64> I use dolphin and akregator a lot
23:57:20 <mikeplus64> they are excellent
23:57:43 <DrAwesomeClaws> cool, maybe I'll spin up a VM sometime soon to check it out for fun
23:59:32 <mrcarrot> it is pretty strange with openbsd. it has the very newest gnome in current, but still kde3
