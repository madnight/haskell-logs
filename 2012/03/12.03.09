00:08:08 <andares> how could I take every fifth element of a list in haskell?
00:09:36 <dmwit> ?hackage split
00:09:36 <lambdabot> http://hackage.haskell.org/package/split
00:10:15 <dmwit> Specifically, http://hackage.haskell.org/packages/archive/split/0.1.4.2/doc/html/Data-List-Split.html#v:chunk
00:10:16 <andares> is there a way without using custom packages?
00:10:28 <dmwit> :t iterate (drop 5)
00:10:29 <lambdabot> forall a. [a] -> [[a]]
00:10:58 <mauke> > let everyNth _ [] = []; everyNth n xs = take 1 ys ++ everyNth n (drop 1 ys) where ys = drop (n - 1) xs in everyNth 5 "http://hackage.haskell.org/packages/archive/split/0.1.4.2/doc/html/Data-List-Split.html#v:chunk"
00:11:00 <lambdabot>   ":c.ercshs/4omtslt:k"
00:11:01 <ChristianS> andares: or fifth (_:_:_:_:x:xs) = x : fifth xs; fifth _ = [] -- though that's somewhat clumsy
00:11:13 <dmwit> I'm not sure there's really a good reason to avoid Hackage packages, though.
00:11:18 <amiddelk> or: let f [] = []; f (x:xs) = x : f (drop 4 xs) in f [1..20]
00:11:20 <dmwit> Code reuse is a good thing, to be sought out, not avoided.
00:11:23 <mauke> > let everyNth _ [] = []; everyNth n xs = take 1 ys ++ everyNth n (drop 1 ys) where ys = drop (n - 1) xs in everyNth 5 "abcd"
00:11:25 <lambdabot>   ""
00:12:37 <dmwit> > let everyNth xs = [x | (x, i) <- zip xs [0..], i `mod` 5 == 0] in everyNth "abcdefghijklmn" -- since everyone else is doing it
00:12:38 <lambdabot>   "afk"
00:13:30 <ChristianS> > let everyNth xs = [x | (x, i) <- zip xs [1..], i `mod` 5 == 0] in everyNth "abcdefghijklmno"
00:13:31 <lambdabot>   "ejo"
00:13:54 <dmwit> > map head . takeWhile (not . null) . iterate (drop 5) $ "abcdefghijklmno"
00:13:55 <lambdabot>   "afk"
00:15:04 <andares> dmwit: I'm avoiding hackage for now because I want to create a lot of things myself to learn the language better.
00:15:42 <andares> oh hey, that's cool.
00:16:41 <drbean> @hoogle (a -> b) -> a -> b
00:16:41 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
00:16:41 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
00:16:41 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
00:17:13 <drbean> @hoogle (a -> b) -> [a] -> [b]
00:17:14 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
00:17:14 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
00:17:14 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
00:19:02 <taiyal> I need a suggestion for a Haskell-written program whose source I can download and analyze to see what a well-made Haskell program looks like.
00:19:22 * hackagebot uAgda 1.2.0.2 - A simplistic dependently-typed language with parametricity.  http://hackage.haskell.org/package/uAgda-1.2.0.2 (JeanPhilippeBernardy)
00:19:32 <dmwit> taiyal: xmonad is nice
00:20:32 <taiyal> okay, I'll check that out.
00:46:05 <Enigmagic> :r
00:59:01 <osager> hi all i use cabal-dev install to install the helloworld project from yesod
00:59:27 <osager> but it builds a lot of the librarys from scratch
00:59:35 <osager> and took a long time
00:59:48 <osager> why can't it find those library on my system ?
01:00:09 <osager> i already add .cabal in my path
01:04:57 <ChristianS> osager: i suppose it has to install all the yesod packages?
01:05:34 <ChristianS> osager: $HOME/.cabal/bin (not .cabal) should be in your path to run cabal-installed binaries. but that's irrelevant for libraries.
01:06:12 <osager> well now i try to use normal cabal install
01:06:19 <osager> and it's finished quickly
01:06:45 <osager> i tried cabal-dev install to avoid conflit
01:06:52 <osager> thanks christians
01:10:56 <donri> though $PATH still matters for preprocessors
01:30:41 <osager> after i modified the web page code, do i need to re run yesod devel to see the modifications ? i normally do this by ctr+c to kill the running one
01:30:42 <osager> first
01:31:01 <osager> but i think there might be a better way
01:35:17 <donri> osager: i think the point of yesod devel is it reloads?
01:35:37 <osager> it will reload automatically
01:35:53 <osager> but i have to kill it first
01:36:31 <donri> huh
01:36:33 <donri> that doesn't sound right
02:01:37 <Guest26165> cabal install gtk and soegtk worked for me, but if I try to compile a file which importsGraphics.SOE.Gtk I get "Could not find module `Graphics.SOE.Gtk':" what do I have to do?
02:13:43 <mikeplus64> I've finally done it; found myself a use for the monadic fish operator
02:13:49 <mikeplus64> reconnect = disconnect >=> connect
02:14:41 <mikeplus64> (real code from a irc bot library sorta thing I'm writing)
02:21:17 <ziv> hello! I'm having a small syntax error in my code and I can't figure out why
02:21:25 <ziv> http://pastebin.com/2NceuBKV
02:21:27 <mauke> The paste 2NceuBKV has been copied to http://hpaste.org/65024
02:21:50 <ziv> oh nonono
02:21:54 <ziv> that's the wrong code
02:21:57 <ziv> sorry
02:23:48 <hpaste> ziv pasted “fail to compile” at http://hpaste.org/65025
02:24:20 <ziv> this code fails at the "reverseSNum = reverse (show x)" row, on the equal sign
02:25:00 <quicksilver> ziv: the indentation is wronf
02:25:20 <quicksilver> reverseSNum needs to line up with sNum
02:26:20 <ziv> it does when tab is 4 spaces... can I configure ghc so that tab is 4 spaces?
02:26:28 <merijn> ziv: Tabs are not 4 spaces
02:26:35 <Botje> ziv: don't mix tabs and spaces.
02:26:46 <merijn> Tabs are 8 spaces as decreed by god and the haskell standard
02:26:47 <Botje> ziv: in fact, don't use tabs at all. they fail more often than not
02:26:54 <merijn> (Also, python standard)
02:27:03 <merijn> And yes, tabs are evil, stop using them >.>
02:27:05 <ziv> isn't the python standard 4 spaces?
02:27:23 <merijn> The python standard indentation is 4 spaces, but tab width is 8
02:27:39 <ziv> ohhhhh, VS has lied to  me my whole life :(
02:27:53 <merijn> You should configure your editor to use soft tabs (i.e. insert spaces when you hit tab)
02:28:22 <quicksilver> it is simpler to just stop using tabs
02:28:30 <quicksilver> but if you wish to, start a new line after the 'let'
02:28:36 <quicksilver> so that sNum is a whole number of tabs in
02:28:42 <quicksilver> and then reverseSNum is the same
02:28:50 <ziv> IT's gonna be a hard habit to quit, but I'll try
02:29:25 <merijn> ziv: Why? Most editors (really any editor worth using) supports auto-indent and soft tabs. Shouldn't require much thought :p
02:30:21 <ziv> I've just installed ubuntu, and my vim isn't configured yet
02:30:32 <merijn> Oh, that's easy
02:30:51 <Tinned_Tuna> merijn: ooo, linky?
02:31:11 <hpaste> merijn pasted “vim tab config” at http://hpaste.org/65026
02:31:24 <merijn> That's everything tab related you will ever need
02:31:25 <rostayob> ziv: you could also do the right thing and use emacs.
02:31:28 <ziv> thank you!
02:31:45 <quicksilver> merijn: is that somewhere on the haskell wiki? would be handy
02:31:46 <merijn> Will even correctly erase shiftwidth worth of tabs when you hit backspace at the start of a line
02:32:03 <merijn> quicksilver: Dunno, this is just my .vimrc
02:32:31 <merijn> People where asking questions so often that I just documented the entire thing so I could just copy/paste the relevant section when needed :p
02:35:17 <quicksilver> it's a small step further to copy-paste it into the wiki
02:35:17 <quicksilver> and then you could just drop the link to that page when needed :)
02:35:17 <quicksilver> http://www.haskell.org/haskellwiki/Vim
02:35:17 <merijn> Yeah, I just never bothered to create a wiki account
02:35:23 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r ","GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops"]'
02:35:23 --- topic: set by glguy on [Tue Feb 21 17:16:07 2012]
02:35:23 --- names: list (clog etpace tty7 tobias1 Talvino bondar ThomasLocke alang ziv otibom amesha MaskRay vortexion agundry iocor hajimehoshi RichyB odinswand abernstein rekahsoft Guest26165 Enoria lnostdal_ Lajla pikhq enobscuratus Jafet cfricke noam masklinn Zedrikov brendyn orbital_fox Kn0wledge jem777 ozgura rostayob nowhere_man edon Jeanne-Kamikaze DuoSRX acfoltzer drbean takuan merijn yaxu Yvo jamil_1 kpal Skola azaq23 Azel popx imc Icewing Krez everzet ccc tobias)
02:35:23 --- names: list (hamishmack janbanan rickardK_ geonetix OlegYch|h tessier silver Rozuur insomniaSalt aartamonau PatrickRobotham mceier Itkovian A1kmm zhulikas meanburrito920 when-pigs-fly mrtimuk asdfhjkl avocado areil treyka homie taiyal gwicke_ jutaro raichoo Apocalisp rmunoz blast_hardcheese cdidd ftrvxmtrx gal_bolle c1de0x Palmik wsliang Beetny ngochai Ragnaroek ChristianS Spockz` Botje LtWorf odi vili ace2001ac cbm80 gbeshers nighty- jeltsch godzemo MoALTz Zamarok jsgf)
02:35:23 --- names: list (free_beard shintah RayNbow`TU zeiris otk zw01 chu scm Karmaon augur lazythunk vodik nexx SamB_XP_ emmanuelux araujo segf drwho dolio wespee_ gienah CQ otto_s kushal Philonous_ ejackson clone_of_saturn cubi Khisanth shapr bytbox schroedinbug Raynes dibblego pommes_ Mortchek perlite looopy rfw_ CrazyThinker confab babalone1 DasIch ajhager kvey m_stone lnostdal blackdog Lemon totte bgamari xivix|gone ivan\ maurer dylukes cschneid TacticalGrace dmn001 gentleben)
02:35:23 --- names: list (kniu The_thir- [mth]_ [mth] ozataman neer tgeeky Philippa Tene ByronJohnson djanatyn honza mikecb dncr joeytwiddle Amadiro_ otters eacameron integral bbee adnam idnar localhost matthiasgorgens theorbtwo Spockz matthiasgorgens3 proq JaffaCake1 stchang decltype pfn statusfailed ben julmuri tavelram master_of_master EarlGray pi8027 elnn AntiSpamMeta AtnNn arkx Nimatek mcglk Cale moonlite Athas timemage hoverbear owst fryguybob danols_work vmeson nus mezzagis)
02:35:23 --- names: list (dflemstr djh mm|swarm Ornedan minsa Nshag gredman timp jonke tempire Carmivore pcapriotti xinming SoupE adnap [[zz]] vithos hiredman Axman6 Zephyrus stianhj castaway args[0] wagle gehho2 bddn clemux m3ga amiri koeskoes newsham preflex wdua magicman elliottt sShintah ricky kallisti dominikh snits parcs` nand` shergill mxweas herself gwern jtannenbaum Wooga overrosy __main__ mux dan brandonw sporous ice799_ SonicvanaJr michaelh_ ezyang mattp_ tamiko andersk)
02:35:23 --- names: list (dcoutts freddie_ dogmaT boris`` jayne chee1 WzC Guest21043 osfameron xnyhps smop lokydor impl rvchangue alistra gmcabrita dp_wiz mrdomino torkjak dumbhat Sgeo gerard0 smarter_ mikeg s4msung McManiaC stepcut Runar Saizan kanak astor Taggnostr2 bezik MigX BlastHardcheese drmegahertz machine2 xsysstar mlh ormaaj digitteknohippie Na-Fiann Obfuscate brett lomeo_ kleini__ albel727 liyang mm_freak BMeph juhp tdubellz Corey MichaelBurge xelxebar ion em TheTFEF xrl)
02:35:23 --- names: list (henr_k gentz zerax rxc fabjan sykora_ Eliel Adios thetallguy ortmage brisbin majuscule eno akahn almostsix exobit__ gwillen r126f mateu olsner kaol copton snarkyboojum mullein mimico Munksgaard Masxmasx rsimoes pyrtsa dreixel jimmyy111 setmeaway haus qz nibalizer caligula_ notrusty2 mortberg nimred frigga1 noddy fukushima donri srcerer dgpratt willb Paks tomh obcode dbelange morolin Excureo pqmodn kcin mroman Mitar mauke edwinb kuuki sohum Bwild audunska)
02:35:23 --- names: list (amiddelk plat0 hamilyon sp3ctum monochrom wilfredh `10 dMazz sm stepnem kolmodin Varakh kshannon tomku amiller Urchin SmartViking sutats zip kkris Draconx Jonno_FTW niko jix jochu thetallguy1 iulian `0660 norm2782 greap joe9 MK_FG tlockney unlink cmccann brixen gnuvince hackagebot Belgarion0 Madoka-Kaname tridactyla FireFly srh rhodesd Internet13 Maxdamantus Ptival quicksilver Jambato Nisstyre edwtjo nlogax chops__ mercury^ EyesIsServer levi Ivoz_)
02:35:23 --- names: list (traviscline ps-auxw Aikawa Yacoby Elemir totimkopf mnestic identity_ k0ral shutdown_-h_now sordina tommd rglenn_ jimleroyer hvr Kuba mimi_vx akosch hirsch_ Bassetts sunfun jml demolithion parus dropdrive helgikrs jrib lukish dcolish redheadphones jyyou dcguru xplat felipe_ shrimpx arnihermann henux j2jxx kiddesr ivan` Dashkal DrSyzygy adimit TML dixie Intensity dumael cola_zero etabot conntrack i1126 LeNsTR|off peddie puzza007 Jaak Damn3d pranq joe_k Nereid)
02:35:23 --- names: list (zk knyppeldynan warpy othiym23 solarus vold jrk_ alpounet davidL Yarou cmrn locci deavid drdo neptunepink froztbyte snorble_ bxc Luke Baughn Cerise andrewsw mee dowski zorzar Razz Entroacceptor aszlig ville mikeplus64 si14 mjo strager LeninParty mantovani scgilardi samek mehitabel hpc pantski destrudo endojelly jrslepak_neu antonh pettter shurane Gunni lambdabot idoru ian_mi ahkurtz_ ybit dmarkey shepheb chipdude guerrilla harlekin cncl dilinger Clint)
02:35:23 --- names: list (confound mrd CindyLinz hpaste Martty PreciousMetals tromp__ ciaranm Boxo @ChanServ robbert nominolo dcoutts__ MostAwesomeDude SimonRC a11235 jabirali Redshift64 mike1703 mietek flazz poucet tomprince Draggor dabradley saati Innominate Lemmih jlewis aluink boyscared naig Guest34074 Tinned_Tuna pyykkis Guest30003 Liskni_si rwbarton ocharles shachaf majoh Vulpyne_ Gracenotes Dodek jmcarthur mulletron clsmith __class__ }ElectrowolF{ cjackson jaspervdj thirsteh)
02:35:23 --- names: list (davean klugez ousado ahf tazjin|away ft BrianHV jackhill routin jbauman nathanel_ mjhan_ kalven 16SAASELP Guest26576 h0st1le saiam Enigmagic johs angstrom Derander_ anders^^ janne cods dougransom ski byorgey dlmalloc jd10 liesen strmpnk nkpart SeanTAllen mndrix bobry wto locks adnauseam c2thunes lispy lomeo kakos yrlnry ccasin kloeri companion_square KitB yezariaely robinbb gemelen kate_r ve ClaudiusMaximus dju sjl joni6128 abbe aristid sp mendez burp)
02:35:23 --- names: list (tauntaun amgarching profmakx kissyboy flamingspinach mrcarrot wyvern mornfall nyingen sclv freiksenet Tesseraction ChongLi milli lopex geekosaur SHODAN bcoppens skiold bogner` heoa chra wires cjay ernst MrNibbles ido naneau tafryn R496 anachron Ke kosmikus ehamberg zenzike Laney RogueShadow smly- jamiely_desktop1 ReinH earthy sipa rndm pdxleif rby mokus Gilly linduxed noplamodo rcj_ hyko int-e cwb zomg peterhil ahihi2 ricky26 FUZxxl cpa untwisted Boney)
02:35:23 --- names: list (jlouis marienz Igloo tg ibid Gothmog_ Astro- ec tomaw hugin fwg zaero Zarathu perimosocordiae pyryp ssalbiz repnop djahandarie elgot koala_man limetree aliak_ Clex vav gdsx jlaire dmwit bogner koninkje_away ubiquill chr1s_ saurik suiside_ lebastr thorkilnaur deggis KaneTW sunnavy ray dqd petanqk alexsdutton danr jrockway pou flori taruti And[y] wavewave strlen reacocard ziman DustyDingo twn kyagrd mrshoe jonafan Starfire noj otterdam opqdonut tsuraan__)
02:35:23 --- names: list (cynick pr Jaxan CosmicRay lefant welterde snetz fattrat Sunhay_ companion_cube fall_ danm_ mbernstein Will| Solver lpsmith HalfWayMan Arnar sully nihtml tuv emias Nanar seats duairc maloi Veinor bd_ yottis zygoloid_ szbalint _root_ birkenfeld brainproxy Valodim Dybber Twey dom96 alip PHO_ erg jwatzman yeltzooo wunki_off electrogeek Vq flux Guest25308 Ayvee levitation[A] inr)
02:35:24 <Tinned_Tuna> merijn: that goes in ~/.vimrc ?
02:35:50 <rostayob> merijn: yes
02:36:05 <quicksilver> merijn: done - http://www.haskell.org/haskellwiki/Vim
02:36:05 <merijn> Yes
02:36:24 <merijn> Damn, now I registered for nothing :p
02:36:30 <quicksilver> ;)
02:36:46 <rostayob> quicksilver: you might also put a link to ghc-mod
02:36:52 <rostayob> and haskell-mode
02:36:56 <quicksilver> I might, if I knew what it was or where it was.
02:37:00 * quicksilver knows nothing about vim :)
02:37:17 <rostayob> quicksilver: right, you use the better editor
02:37:40 <hpaste> merijn pasted “vimrc” at http://hpaste.org/65027
02:37:54 <merijn> Tinned_Tuna: If you're interested, that's the entire documented thing
02:38:00 <merijn> Quite some useful tricks in there
02:39:05 <rostayob> also, vundle is cool for what regards vim: https://github.com/gmarik/vundle
02:39:47 <hpaste> franco00 pasted “Yet another monadic problem” at http://hpaste.org/65028
02:40:26 <rostayob> franco00: it's not that scary. you trying to compare two 'Section's and you don't have an Eq instance.
02:40:26 <franco00> puzzled by this problem with monad ^-- any help?
02:40:52 <rostayob> franco00: it has nothing to do with monads, add "deriving (Eq)" after declaring Section
02:40:56 <Tinned_Tuna> merijn: thank you! :-)
02:41:06 <franco00> rostayob: I thought I am comparing sectionIDs
02:41:12 <franco00> which are type == Integer
02:41:14 <franco00> right?
02:41:27 <rostayob> franco00: i think that "lup" is a section?
02:41:37 <rostayob> *Section
02:41:38 <quicksilver> rostayob: no it's a  Maybe :P
02:41:40 <rostayob> in the gamebook thing
02:41:44 <quicksilver> franco00: never write == Nothing
02:41:45 <merijn> franco00: No, sectionId is a function returning a Section, according to that error
02:41:50 <quicksilver> never, ever, ever write == Nothing.
02:41:51 <franco00> yes, but that is a maybe
02:41:57 <quicksilver> and this has nothing to do with monads.
02:41:58 <rostayob> ah, right
02:42:00 <franco00> quicksilver: what should I write then?
02:42:02 <rostayob> franco00: case
02:42:06 <quicksilver> well you shouldn't use if at all
02:42:13 <rostayob> case lup of Nothing -> blah; Just x -> bar;
02:42:13 <quicksilver> but if you must use if, use "if isNothing lup"
02:42:15 <franco00> okok, not not monad
02:42:24 <franco00> isNothing then?
02:42:26 <franco00> lemme see
02:42:28 <rostayob> franco00: no, case
02:42:32 <rostayob> so you don't have to use fromJust
02:42:36 <quicksilver> no, don't use if and don't use isNothing and never use fromJust
02:42:43 <quicksilver> if you MUST use if, then use isNothing
02:42:47 <quicksilver> in this case you use case
02:42:51 <quicksilver> and then you won't need the fromJust either
02:42:55 <quicksilver> and the whole code gets nicer :)
02:43:06 <franco00> =) thanks wise men
02:43:13 * franco00 tinkers
02:43:35 <quicksilver> case lup of Just x -> return x; Nothing -> fail $ "error message"
02:43:36 <merijn> franco00: It helps to try to parse the errors by ignoring the cryptic names and scanning for lines like the first
02:44:29 <merijn> "Could not deduce (Eq Section) arising from a use of `=='" tells you that the compiler thinks you're trying to use == on a Section which reduces the number of possible errors to 2 options
02:45:00 <merijn> 1) You forgot to define Eq 2) You made a mistake and are using an argument of the wrong type somehow
02:45:25 <merijn> The rest is just scary compiler speak for how the compiler ran into the problem
02:46:18 <franco00> dd (Eq Section) to the context of         the type signature for           getSection :: Monad m => Gamebook -> SectionId -> m Section <-- that tricked me
02:47:42 <franco00> thanks everyone, I will try to eschew == Nothing and the like
02:55:39 <quicksilver> franco00: the point is, by the way, that to compare two "Maybe Sections" with ==, you need to be able to compare the 'Just' case, and that requires being able to compare Sections.
02:55:58 <quicksilver> franco00: that's why the Eq instance for Maybe works that way (requiring an Eq instance for the contained type).
02:56:15 <quicksilver> obviously logically it wouldn't be needed for Nothing, but that's not how the instances work.
02:56:23 <quicksilver> and there are other reasons to prefer the case solution.
02:56:45 <quicksilver> (or the combinators "maybe" and "fromMaybe" which are two common patterns of case)
02:57:09 <hvr> how's the admin in charge for  {projects,community}.haskell.org?
02:57:12 <quicksilver> you could have used : maybe (fail "my long error message") return
02:57:16 <hvr> who's
02:57:17 <shachaf> quicksilver: "maybe" is every pattern of case. :-)
02:57:22 * quicksilver nods
02:57:58 <quicksilver> hvr: the default contact is the haskell.org committee I think?
02:58:20 <quicksilver> I'm not sure who runs them in practice.
02:58:38 <hvr> quicksilver: I wanted to report that the MX seems down... but sending email to support@community.haskell.org doesn't reach them...
02:59:14 <quicksilver> committee [AT] haskell.org says the wiki page
02:59:21 <franco00> yeah looking at the ew class is all more clear
02:59:28 <franco00> *eq
02:59:44 <hvr> quicksilver: I'll try that
04:54:40 * hackagebot polyparse 1.8 - A variety of alternative parser combinator libraries.  http://hackage.haskell.org/package/polyparse-1.8 (MalcolmWallace)
04:57:59 <mekeor> 'liftM' is like 'fmap' but for monads, right?
04:58:22 <Elemir> @type liftM
04:58:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:58:33 <Elemir> @type fmap
04:58:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:58:51 <mekeor> @src liftM
04:58:52 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:59:22 <Elemir> Hem
04:59:31 <Elemir> @src Monad
04:59:31 <lambdabot> class  Monad m  where
04:59:31 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
04:59:32 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
04:59:32 <lambdabot>     return      :: a -> m a
04:59:32 <lambdabot>     fail        :: String -> m a
04:59:58 <Elemir> Monad isn't Functor?
05:00:54 <merijn> Elemir: For historical reasons
05:00:57 <mekeor> in theory, yes; in haskell's implementation not obligatorily, AFAIK.
05:01:08 <merijn> i.e. Functor didn't exist when most of the Monad instances were written
05:01:31 <mekeor> merijn: so, fmap is for functors what liftM is for Monads, right?
05:01:45 <merijn> Yes
05:01:52 <Elemir> fmap f xs  ==  xs >>= return . f
05:01:57 <Elemir> Yes :)
05:02:17 * Saizan is pretty sure h98 had both Monad and Functor
05:02:39 <merijn> Saizan: Ok, in that case some idiot didn't define the dependency and should be smacked :p
05:03:41 <quicksilver> the decision was taken quite deliberately.
05:03:51 <quicksilver> wrongly, perhaps, but not by mistake or in ignorance.
05:04:47 <quicksilver> the Functor class and Monad class don't map cleanly (you can define fmap from return + join) and there isn't a good default class mechanism and so on.
05:04:54 <hpc> merijn: the dependency isn't there because functor came later, and the change would require touching every library to fix
05:05:10 <hpc> also what quicksilver said
05:05:27 <Saizan> hpc: read more of the backlog
05:05:30 <merijn> hpc: That's what I just said and then someone mentioned that's not the case and now I am confused :\
05:05:46 <Elemir> Legacy…
05:05:50 <hpc> i blame mornings...
05:06:01 * hpc goes back to sleep :P
05:06:26 <quicksilver> it's possible functor came later, but they certainly both came a very long time ago
05:06:34 <quicksilver> there weren't many libraries to rewrite back then
05:06:57 <quicksilver> I think the haskell committee deliberations used to be archived online but last time I tried to find them I couldn't.
05:07:07 <quicksilver> augustss is normally the one who remembers, because he was tehre.
05:07:30 <Elemir> Usenet?
05:07:49 <Saizan> http://www.haskell.org/onlinereport/standard-prelude.html <- there they are, at least
05:07:59 <quicksilver> sure, but h98 is quite late in haskell's history
05:08:36 <Saizan> yeah, still very few libraries to break though
05:08:51 * quicksilver nods
05:09:03 <damowe> hello :)
05:09:36 <Elemir> Is there online documentation for Agda libraries?
05:09:50 <merijn> There are Agda libraries? :D
05:09:56 <Elemir> :D
05:10:09 <mekeor> Elemir: #agda
05:10:09 <damowe> how can I detect memory leaks in Haskell?, I mean track which function/expression is retaining memory?
05:10:15 <Elemir> Standard, of cause
05:10:29 <mekeor> Elemir: http://www.cse.chalmers.se/~nad/listings/lib-0.6/Everything.html that's useful, too
05:10:49 <quicksilver> damowe: GHC has an extensive heap profiler with lots of options.
05:11:05 <quicksilver> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/prof-heap.html
05:11:08 <merijn> damowe: Yeah, Real World Haskell has a chapter on profiling memory and related things: http://book.realworldhaskell.org/read/profiling-and-optimization.html
05:11:16 <Elemir> mekeor: thanks
05:11:21 <mekeor> np
05:13:04 <damowe> thanks
05:13:46 <Elemir> Ou. Adga isn't very readable…
05:13:50 <t7> i like coq more than agda. *ducks*
05:13:51 <Elemir> *Agda
05:15:00 <merijn> Elemir: Ha, try reading Coq :p
05:15:24 <hpc> agda can be very readable
05:15:28 <hpc> it just often-times isn't
05:15:30 <hpc> :P
05:15:35 <t7> coq syntax is simple
05:15:44 <t7> explicit pattern matching etc
05:15:50 <Elemir> t7: Coq has no chances to become general-purpose language
05:16:10 <Elemir> IMHO agda has
05:16:10 <t7> and agda does?
05:16:15 <merijn> And Agda does? :D
05:16:32 <hpc> you can almost write a normal program if you turn off the termination checker
05:16:43 <hpc> and have 3 gigs of ram
05:16:52 <fireboot> Hello guys
05:16:53 <hpc> and 2 hours of compile time
05:16:54 <hpc> :P
05:17:00 * Elemir have 4 gifs of ram at netbook
05:17:00 <t7> coq > agda because type classes
05:17:09 <fireboot> I'm trying to use parsec to parse a (very small) subset of C
05:17:25 <Elemir> Don't try to use parsec!
05:17:29 <Elemir> Joke
05:17:31 <Saizan> quicksilver, merijn: haskell 1.3 is the first standard with a Monad class, being the first one with constructor classes, Functor is there too but not as a superclass
05:17:44 <fireboot> I am using the semiSep parser to parse semi column separated instructions
05:18:07 <fireboot> but the thing is, it gets confused when the last line is ended by a semi column
05:18:44 <fireboot> by that I mean
05:19:02 <fireboot> "foo = 10; bar = 20" is parsed correctly
05:19:03 <fireboot> but
05:19:08 <fireboot> "foo = 10; bar = 20;" is not
05:19:14 <lukish> Hi. Can we reopen this http://stackoverflow.com/q/8455780/ question? It's right, that cabal is not a packet manager, but I think it will be interesting to listen some advices how people avoid and solve that problem.
05:19:26 * Elemir knows only one general-purpose language with dependent types — Dependent ML. But it was born dead
05:19:31 <quicksilver> Saizan: ISTR the question of it being a superclass was discussed as part of the '98 process.
05:19:57 <Saizan> fireboot: there's sepEndBy
05:20:15 <Elemir> Haskell has chances to become second :) But haskell has a lot of legacy
05:20:30 <Saizan> Elemir: see Idris
05:20:52 <dcoutts_> lukish: the answer is that cabal has no easy way to do that right now, because ghc-pkg/cabal do not track profiling versions of libs separately from normal
05:20:58 <Elemir> > Idris, GBE (Arabic: إدريس الأول‎)
05:20:59 <lambdabot>   <no location info>: parse error on input `,'
05:21:02 <Elemir> Ou…
05:21:15 <Tinned_Tuna> lukish: it is my opinion that when you ask for something to be installed, it should crawl the dependencies automagically. That does constitute turning cabal into a beastly package manager, but I'm all for that...
05:21:15 <lukish> dcoutts_: okay, but why it's closed?
05:21:44 <Elemir> " Idris is a general purpose pure functional programming language with dependent types.
05:21:48 <dcoutts_> lukish: I don't know any more than you about that, someone linked it as a duplicate right?
05:22:34 <dcoutts_> Tinned_Tuna: it does crawl the deps automatically, the issue here is that profiling libs are not tracked separately
05:22:49 <lukish> Actually all that I need it you pressed (reopen) button, lol
05:22:57 <lukish> s/it/is/
05:23:15 <Elemir> Saizan: They use tactic-based proving. Is it useful for general-purpose language?
05:23:35 <Tinned_Tuna> dcoutts_: if memory serves me correct, I was trying to do something with ftphs. I had it's repo cloned onto my box, and cabal didn't seem to want to crawl it's deps when installing it like that
05:23:43 <Tinned_Tuna> (I was probably doing something wrong, all told)
05:23:54 <Tinned_Tuna> but it did happily crawlthe deps for cabal install MissingH
05:24:05 <Saizan> Elemir: it's useful for the computationally-irrelevant proofs
05:24:07 <t7> http://www.reddit.com/r/haskell/comments/qosr7/eff_30_is_out_a_functional_language_with/
05:24:39 <dcoutts_> Tinned_Tuna: if you ran cabal install in the repo then it'll install deps too. If you just use cabal configure, it's assumes all deps are installed already.
05:25:21 <Saizan> Elemir: though i've not seen much of it in practice, since it's a very new language
05:26:11 <Tinned_Tuna> dcoutts_: then I was probably just being a plank :-p
05:26:31 <dcoutts_> Tinned_Tuna: :-)
05:27:10 <Saizan> Elemir: could also be useful for the same stuff we use TemplateHaskell
05:27:26 <Tinned_Tuna> dcoutts_: You'll get to know with me that if something's gone wrong, it's 99.99% likely to be my fault due to sheer idiocy :-p
05:30:12 <damowe> wow, seq does magic :)
05:30:34 <Cale> damowe: Only in that function types and types without exposed data constructors can be evaluated.
05:30:36 <damowe> I'm impressed, well placed seq and $! are doing really good stuff
05:30:45 <Cale> oh, magic in that sense :)
05:30:52 <damowe> yes :)
05:30:55 <Cale> damowe: In most cases, seq is equivalent to case
05:31:07 <Cale> But for functions, it's not.
05:31:24 <Cale> (you can't pattern match a function in a way that just forces the function to be evaluated)
05:31:39 <merijn> t7: Is that interesting enough to warrant taking my reddit block out of my host file? :p
05:31:43 <damowe> Cale: my problem with the memory leak seems that was a wrong implementation of Parsec parser output handling
05:32:08 <t7> merijn: i can send the paper url if you like
05:32:12 <Cale> damowe: If you like seq and $!, try BangPatterns as well :)
05:32:23 <damowe> ok, thanks
05:32:31 <merijn> t7: Please do :)
05:32:54 <t7> http://arxiv.org/abs/1203.1539
05:33:11 <merijn> I have managed to make visiting reddit sufficiently annoying that I never do so during work anymore :p
05:33:22 <Cale> It lets you put ! before a variable in a pattern match, and that'll cause the value of that variable to be forced using seq
05:33:31 <merijn> t7: Thanks
05:33:35 <Cale> merijn: wat
05:33:45 <zachk> merjin: how did you accomplish that?
05:33:49 <damowe> thanks
05:33:56 <Tinned_Tuna> merijn: what is this dark magic?
05:33:58 <merijn> Cale: All hostnames resolve to localhost and my browser resolver caches hostnames
05:34:06 <Cale> oh I see
05:34:25 <Cale> That's one way to stop yourself :)
05:34:46 <merijn> And since Opera functions as my IRC client/browser I have to "sudo, edit host file, close browser/IRC, flush DNS cache, restart browser"
05:35:07 <merijn> The way to stop procrastination is to introduce high transaction costs for switching :p
05:35:33 <t7> haha
05:36:03 <Tinned_Tuna> I have chromium with stayfocusd installed.
05:36:13 <Tinned_Tuna> with a hard limit of 25mins (iirc)
05:36:27 <merijn> I still procrastinate, but in more useful ways than reddit link clicking
05:36:52 <merijn> (instead I now read arrow papers and procrastinate here :p)
05:39:09 <mekeor> merijn is a geak
05:41:36 <Elemir> Who doesn't?
05:42:20 <Cale> I just realised that it would be quite nice if reddit had subscription sets (you could make separate accounts, but that's obviously not ideal)
05:43:12 <_Mikey> if I have list of <values> can I map a function over them which moves them all into Just <vales>
05:43:19 <Cale> map Just
05:43:27 <Cale> Just is a function :)
05:43:30 <Elemir> http://projects.haskell.org/pipermail/haddock/2012-January/000909.html
05:43:34 <_Mikey> ah great!
05:44:12 <Elemir> WANT
05:44:34 <Elemir> Reading haddock in browser makes me sad
05:44:50 <Cale> why?
05:44:55 <merijn> Cale: That sounds like a question which can be answered in a lot of different ways :p
05:45:05 <shergill> Elemir: move to emacs, and read in w3m? :P
05:45:05 <merijn> map return \o/
05:45:25 <merijn> shergill: I would move to emacs if only it had good modal editing :\
05:45:47 <shergill> there is evil or viper or something i hear
05:45:50 <shergill> merijn: ^
05:45:56 <Cale> I guess it would be sorta nice to be able to look up Haskell documentation while in vim, but I don't really see the problem with switching to my web browser to see it.
05:45:59 <Elemir> shergill: I have stand-alone w3m
05:46:07 <Tinned_Tuna> tmux+elinks
05:46:08 <merijn> shergill: Yes, and its terrible
05:46:23 <merijn> I once considered hacking vim to be more emacs-like. Then I looked at the vim source and that idea was quickly killed
05:46:31 <Tinned_Tuna> Cale: run tmux, split into panes, have vim on the left, elinks on the right.
05:46:47 <shergill> merijn: heh. yeah. vim makes hacking on it a pain
05:46:55 <Cale> Yeah, I don't see the need to do that either :P
05:47:05 <Elemir> Why yi is so slow?
05:47:06 <merijn> shergill: To be fair emacs source isn't really more readable :p
05:47:30 <Cale> I'm sitting in front of a 1920x1080 display and my machine has lots of memory, I can afford to run a web browser in a separate window :P
05:47:53 <_Mikey> > \x -> do{if x == Just 0.0 then Nothing}
05:47:54 <lambdabot>   <no location info>: parse error on input `}'
05:47:55 <shergill> merijn: really? i mean sure emacs lisp is a bastardized lisp, but it's still nice to work with. and docstrings!
05:48:03 <Tinned_Tuna> Cale: but it makes it so nice to tile :-p
05:48:13 <_Mikey> no do notation in lambda functions?
05:48:39 <Elemir> _Mikey: You forgot else
05:48:50 <_Mikey> > \x -> do{if x == Just 0.0 then Nothing else x}
05:48:51 <lambdabot>   Overlapping instances for GHC.Show.Show
05:48:52 <lambdabot>                              (Data....
05:49:05 <quicksilver> not much point in a do block with only one expression in it, either
05:49:23 <_Mikey> quicksilver, how would you do it?
05:49:32 <shergill> Tinned_Tuna: get a tiling wm? that being said, tmux is quite nice
05:49:37 <Cale> _Mikey: do { x } = x
05:49:48 * Elemir loves vim modality
05:50:00 <quicksilver> _Mikey: do what? as Cale says "do x" is just "x"
05:50:08 <_Mikey> ah
05:50:15 <t7> ive got an idea for a startup, gimme your money
05:50:20 <t7> i will implement in haskell
05:50:22 <_Mikey> > \x -> if x == Just 0.0 then Nothing else x
05:50:23 <lambdabot>   Overlapping instances for GHC.Show.Show
05:50:23 <lambdabot>                              (Data....
05:50:31 <merijn> shergill: emacs is not all emacs lisp :p
05:50:56 <Elemir> t7: Be a communist. Money is nothing!
05:51:03 <Tinned_Tuna> shergill: I would like that, but I cba switching agian
05:51:49 <shergill> merijn: agreed. it does drop down to c, but honestly i've never had to deal with the c source code. and i'm not sure why you'd need to either
05:52:37 <shergill> Tinned_Tuna: you may want to give awesome a try. it has nice enough tiling support, but it makes transitioning from non-tilling wm very easy (good mouse support)
05:53:01 <shergill> /s/but/and
05:53:32 <Tinned_Tuna> shergill: my co-worker right next to me uses awesome. I am discouraged.
05:54:05 <Tinned_Tuna> shergill: mainly due to the bugginess that he encounters almost everyday. Otherwise it seems powerful++
05:54:34 <Elemir> Does anybody use yi editor?
05:54:36 <Tinned_Tuna> Besides which, I just have a couple of tmux windows, chromium and netbeans and I'm done (+IM apps like skype)
05:55:29 <Elemir> IM layout from xmonad + skype == win
05:55:48 <Elemir> Skype without it == fail
05:55:55 <Tinned_Tuna> I desparaely want a big Java IDE that isn't point & click
05:56:32 <Elemir> Just don't use Java ;)
05:56:45 <Tinned_Tuna> so, project management, debuggers, hotkey build/build&clean/etc.
05:57:04 <Tinned_Tuna> Elemir: that's equivalent to "just don't get paid" with is equivalent to "just don't eat or pay rent!"
05:57:09 <shergill> Tinned_Tuna: bugginess? while it's true that the api does change between point releases, it's usually straightforward enough to upgrade. other than that, i've not really encountered any bugs. then again i keep it functional, and don't just go about indiscriminately copying stuff into my config files =/
05:57:30 <Tinned_Tuna> shergill: I don't know what his config file is like
05:57:51 <Tinned_Tuna> shergill: But I have fluxbox setup relatively sane-ly
05:58:13 <Elemir> Tinned_Tuna: Pure C coders are more expensive
05:58:45 <Tinned_Tuna> Elemir: Maybe, but I have less experience in C
05:59:11 <Elemir> Sad =(
05:59:23 <Tinned_Tuna> Elemir: indeed :-/
05:59:23 <t7> anyone know of a vim plugin that indents code as i write it automagicaly
05:59:24 <fireboot> not sure
05:59:33 <fireboot> C and java are both as painful to use
05:59:43 <fireboot> for different reasons, but they are still painful
05:59:46 <Tinned_Tuna> I would love to write Haskell or something similar in my day job
05:59:49 <Tinned_Tuna> maybe OCaml...
05:59:54 <Tinned_Tuna> (perhaps)
06:00:24 <t7> enjoy your IO operations all over the place
06:00:51 <Tinned_Tuna> t7: Just because you can, doesn't mean you should.
06:01:04 <Tinned_Tuna> b
06:01:34 <Elemir> Guys, how can I put my crap to hackage?
06:02:39 <quicksilver> t7: well of course it can't get it correct all the time because it can't know what you mean. But I believe there are some for vim.
06:03:08 <t7> or an ast editor would be nice
06:03:18 <t7> has anyone played with that?
06:03:41 <quicksilver> maybe this one is good - http://projects.haskell.org/haskellmode-vim/
06:04:06 <quicksilver> I don't think there are any AST editors for haskell although leksah has some leaning in that direction
06:05:42 <Elemir> quicksilver: it's slower than yi
06:06:35 <quicksilver> yi doesn't try to be an AST editor at all, does it?
06:06:45 <quicksilver> yi tries to be a general text editor that happens to be *written* in haskell
06:07:22 <Elemir> AST editor???
06:07:27 <Itkovian> Elemir: see the hackage page, it tells you how to package and upload iirc
06:08:12 <Elemir> What does it means, — AST editor?
06:10:26 <Elemir> Itkovian: this http://hackage.haskell.org/packages/accounts.html and this http://hackage.haskell.org/packages/upload.html ?
06:10:44 <Itkovian> yes.
06:10:49 <oz__> help! I set a variable "address = main" and my main is "main :: I0(Maybe Int) but I want my address act as the Int coming back from the main. how do I do that?
06:11:05 <t7> address <- main
06:11:07 <Itkovian> but do try to install it locally first to see if _everything_ works eh :-D
06:11:24 <oz__> t7: thanks!
06:11:29 <Elemir> > locally
06:11:30 <lambdabot>   Not in scope: `locally'
06:11:49 <Elemir> Itkovian: what CMS does it use?
06:12:01 <oz__> ... parse error at input '<-'
06:12:10 <Itkovian> Elemir: does what use?
06:12:26 <Elemir> HackageDB, cause
06:12:38 <Itkovian> No idea
06:12:39 <t7> is using opengl for an ast editor a bit overkill?
06:12:43 <Elemir> Yesod? Happstack?
06:12:45 <t7> it would be very portable
06:12:49 <Elemir> PHP shit?
06:12:56 <Itkovian> Like I said. No idea.
06:13:56 <Elemir> t7: Tell me, wtf ast editor. It's ungooglable.
06:14:02 <merijn> t7: Someone in here was working on an AST editor, the python prototype (pygame/opengl) was very nice
06:14:15 <merijn> Elemir: Abstract Syntax Tree (see also structural editing)
06:14:27 <Elemir> I understant wtf AST
06:14:35 <Elemir> But AST EDITOR???
06:14:50 <Elemir> Something like xslt?
06:15:37 <merijn> No
06:15:47 <Elemir> So how?
06:16:03 <merijn> Just an editor that understands the underlying AST of the code. For example, when you edit a function name all occurences of the function are automatically updated as well
06:17:42 <Elemir> Hem…
06:18:50 <Elemir> Is there reasons to including such undestanding in editor core?
06:19:47 <merijn> Yes, automatic refactoring, integrated version control with faultless merges
06:21:00 <Saizan> basically, the idea is that your IDE shouldn't reparse the code all the time
06:21:08 <_Mikey> @hoogle (a->b->c)->[a]->[b]->[c]
06:21:09 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
06:21:09 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
06:21:09 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:21:32 <Saizan> (i'm not entirely convinced that's the case though)
06:21:42 <Elemir> IMHO editor core must be like simple terminal
06:22:27 <Elemir> So modules can support AST
06:24:04 <t7> i want opengl haskell declarations whizzing around the screen, just to piss off the old codgers
06:24:07 <Saizan> well, that's another point
06:24:14 <DavidT> Saizan: That's how ReSharper works to edit C# in Visual Studio - it has a massive database that indexes your source code tree in a load of interesting ways and keeps the indices in sync incrementally
06:24:27 <DavidT> So isn't continually reparsing the whole project
06:24:42 <Saizan> DavidT: well, i didn't mean the whole project
06:24:55 <Saizan> DavidT: just the module you are currently editing
06:25:18 <Elemir> AST VCS is interesting
06:26:20 <DavidT> Why not the whole project? Auto-completion is fab. And if I change something in one module, the changes are propagated basically straight away to the other modules' editors without having to re-compile the whole thing
06:26:33 <Elemir> So vim cannot be a AST editor. But IMHO yi can.
06:29:06 <Saizan> DavidT: heh, we keep misunderstanding each other :)
06:30:03 <merijn> Elemir: The only way to do AST VCS is to track *all* changes, which means your editor needs to track them while you're working
06:30:57 <Saizan> DavidT: my point is that while it's easy without an AST editor to keep stored sufficient metadata for the rest of the project without reparsing, with an AST editor you can do it even for the code you edit
06:31:02 <merijn> I would argue that AST VCS is the main thing that makes structural editing interesting, free refactoring is just a nice bonus
06:31:37 <Saizan> DavidT: though i'm not so convinced myself that this is very relevant, so don't ask me to defend it :)
06:31:45 <Elemir> How about breaking AST?
06:32:25 <Elemir> What do AST editors with it?
06:33:47 <Saizan> they don't allow it?
06:33:54 <Elemir> o_O'
06:34:05 <Elemir> "data F = F () | " isn't valid haskell code
06:34:09 <MaskRay> how to pretty print the AST
06:34:24 <t7> Elemir: you would just get a parse error
06:34:26 <Elemir> But it's part of valid code!
06:34:27 <Saizan> Elemir: so?
06:34:29 <MaskRay> and when you are working on part of it
06:34:40 <merijn> MaskRay: That's pretty easy (bonus, no more tabs vs spaces debate!)
06:34:47 <Saizan> Elemir: editing code would work differently
06:35:17 <Saizan> Elemir: you'd have commands for data definitions, then multiple constructors which you can fill in with the types etc..
06:35:30 <flux> well, that sounds like a bit painful to use, no?-o
06:35:52 <Elemir> t7: Wrong. I expect what this error don't broke valid parts of code
06:35:57 <flux> but even if you wanted a 'text editor' feel to it, you could just be in 'non-parse' state when the contents is not parseable
06:36:19 <flux> and when it again becomes parseable, you could construct an operation that transforms the previous valid AST to the current one, should you need it
06:36:36 <quicksilver> see "paredit" and epigram1 for prior art
06:36:57 <quicksilver> both restricted code editors to a greater or lesser extent guaranteeing wellformedness.
06:37:03 <quicksilver> epigram even guaranteed welltypedness.
06:37:29 <t7> system f doesnt have let statements because first class polymorphism renders it redundant, is that correct?
06:37:34 <merijn> If people have a second, someone in here send me a python prototype with some example C code loaded
06:37:46 <merijn> Lemme see if I can find it and put it up for people to look at
06:37:49 <merijn> It's pretty neat
06:38:23 <Elemir> I think what AST for editor must me more wider than really language AST
06:38:33 <DavidT> Saizan: I see - sorry I missed the start of the discussion.
06:38:46 <Elemir> s/me/be/;s/more//
06:39:43 <Elemir> And it should support some local error
06:39:50 <DavidT> I switch between Visual Studio (for work) and EclipseFP and the lack of incremental cross-project AST parsing in EclipseFP is painful when you're used to it, so it's a sore point.
06:40:57 <DavidT> It also handles parse errors incredibly well - it can tell what you're missing and compile the bits that still parse correctly. It handles something like "data F = F () | " just fine
06:43:28 <merijn> For those interested: http://dl.dropbox.com/u/1841232/python-prototype.zip (you need python + pygame, for obvious reasons)
06:43:47 <Elemir> Nooooo
06:43:56 <Elemir> Not python. Nooooo
06:44:03 <EvanR> lol
06:44:13 <EvanR> i concur
06:44:17 * Elemir hides under big stone
06:44:27 <zomg> haha
06:44:40 <zomg> When you mention Python on most programming channels people usually go "Oh I like Python"
06:44:54 <zomg> First time I see this reaction to it... =)
06:45:02 <merijn> So do most people here, except the handful of trolls and people who like to act elitist
06:45:07 <EvanR> its haskell, everything sucks
06:45:31 * Saizan would suggest less emotionally charged comments
06:45:32 <merijn> Actually, the overlap between trolls and elitists is probably close to complete
06:46:04 <EvanR> i dont understand this thing against 'elitists'
06:46:11 <Philippa> I dunno, you get the occasional anti-elitist with a wide notion of elitist
06:46:16 <EvanR> is that like saying 'its better to be worse' or what
06:46:29 <Saizan> i stand behind the guy who mailed SICP to guido, even if python could be worse
06:46:30 <Philippa> 'elite' is rarely just about applicable merit
06:46:52 <merijn> EvanR: Elitism rarely arises from actual merit
06:47:02 <quicksilver> ideally it's about space trading and no longer being mostly harmless
06:47:10 <Elemir> Anti-elitism is kind of elitism
06:47:13 <Philippa> I mean, I'm happy to stand up and say that my merits are extremely lopsided...
06:47:26 * EvanR checks on some random definition of elitism now
06:47:39 <EvanR> i figured it was 'being betterism'
06:47:42 <Philippa> Elemir: "only we live in the real world"? I think that's only really elitism when it's coming from particular directions
06:48:13 <merijn> I hate haskell just as much as I hate python and all other languages I've programmed (well, except maybe PHP and Java, man...those two can go die in a fire)
06:48:19 <Philippa> heh
06:48:35 <merijn> @quote enlightened.gentle
06:48:35 <lambdabot> PenguinOfDoom says: Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
06:48:42 <Philippa> I wouldn't quite go that far, but it certainly has things I'd like to see different if we got a clean slate, 2012 knowledge based design
06:48:54 <silver> I don't like python
06:49:11 <EvanR> uhg 2012
06:49:14 <Elemir> I just think that python is a big piece of shit
06:49:17 <EvanR> how about 2112?
06:49:20 <EvanR> would be better
06:49:27 <Elemir> IMHO it isn't kind of elitism
06:49:38 <Philippa> I dunno, I'd like to get to use that clean slate design sometime in my life
06:50:17 <Philippa> for its age, Haskell's got a kind of life to it that I think's mostly comparable to the ML and especially lisp families
06:50:37 <EvanR> well wikipedia is no help on elitism in this context
06:50:45 <merijn> silver: Sure, neither do I like ocaml. But I hope we can both agree that there is no reason to respond "nooooooooo" to the revelation that someone else likes to write in that language
06:50:54 <Elemir> For example I don't like Java, but I think that Java is better than python
06:51:10 <EvanR> the only thing i can gather is it implies a sort of exclusiveness, but in haskell we try to include as many people as possible
06:51:13 <EvanR> so...
06:51:25 <Philippa> well, some of us more than others
06:51:45 <Philippa> and there's a certain amount of "we /know/ we're the elite, let's get on with making things better already shall we?" too
06:51:50 <merijn> EvanR: elitism implies that being better is a justification for excluding those on a (perceived) lower level
06:51:55 <quicksilver> personally I include everyone except the elite
06:51:57 <silver> merijn, yeah, I agree, especially archive named prototype-something, it's ok to prototype in python
06:52:08 <silver> (for me)
06:52:26 <EvanR> merijn: who am i excluding by saying python sucks
06:52:38 <t7> :t let x a b = a b in x
06:52:38 <lambdabot> forall t t1. (t -> t1) -> t -> t1
06:52:56 <merijn> silver: It's especially a shame since the prototype is quite nifty
06:53:16 <Philippa> EvanR: you're making life potentially uncomfortable for people whose preferred language (especially: whose internal language is closest to) Python. Stuff like that can pile up over time
06:53:56 <EvanR> golden rule
06:54:20 <Philippa> I'd prefer some balance between it and the platinum rule, myself
06:54:30 <merijn> EvanR: You're making a rather controversial blanket statement about a language, a statement mostly made by people who do not have any clear reasoning for it
06:54:46 <Philippa> (admittedly I'm happy to apply the reverse golden rule in conflict, but I'm also happy to admit that I'm a complete asshole when I'm in the mood to be)
06:54:54 <EvanR> balance between good and evil helps evil and hurts good!
06:55:09 <Philippa> yeah, but how do you know which you are?
06:55:27 <merijn> A lot of people seem to want python to be haskell, which seems a bit odd. We already have haskell
06:55:28 <EvanR> tautologically
06:55:45 <Philippa> I'd like Python to be a little closer to Haskell, but that's not the same thing
06:55:54 <Philippa> EvanR: yeah, I don't make that assumption myself
06:56:02 <EvanR> 'python sucks' is often said in #python by python people
06:56:05 <Philippa> it seems to work out better in the long run
06:56:08 <merijn> If you're going to define good and evil subjectively you might as well do away with the terms and say "because I like it this way"
06:56:20 <Philippa> merijn: Quite
06:56:48 <merijn> Which is a valid reason, I guess. But it does make you kind of a prick, socially speaking
06:57:05 <Philippa> depends on how much you're willing to be honest about it and then negotiate
06:57:33 <merijn> Vice versa, if you have an objective (or at least slightly objective) definition of good and evil you can't tautologically claim to be good
06:57:34 <quicksilver> anyhow the social point about #haskell is that we do not denigrate people or their views
06:57:36 <EvanR> well if the goal is to please as many people as possible i guess that explains entirely the state of world wide web tools and systems
06:57:40 <quicksilver> in this channel.
06:57:48 <quicksilver> except overlappinginstances, which is fair game.
06:57:55 <silver> lol
06:57:59 <Saizan> and lazy I/O?
06:58:03 <quicksilver> yes, and that.
06:58:22 <merijn> quicksilver: Man, I wish someone would implement the instance chain stuff described in the habit report...
06:58:32 <ChristianS> what's wrong with lazy I/O?
06:58:40 <EvanR> errors
06:58:41 <Saizan> merijn: make them open source it!
06:58:57 <merijn> Saizan: That doesn't make them magically appear in GHC :p
06:58:58 <quicksilver> ChristianS: http://www.haskell.org/pipermail/haskell-cafe/2007-March/023073.html
06:59:02 <Elemir> ChristianS: unsafeInterleaveIO
06:59:21 <merijn> Saizan: afaik people where interested in implementing it in GHC, but implementation had some tricky bits
06:59:32 <merijn> s/where/were
06:59:51 <Saizan> merijn: if you can see an implementation it'll be quite easier, i think
06:59:57 <Elemir> Hacky
07:00:11 <t7> has anyone in here implemented hindley milner type inference?
07:00:23 <Saizan> who hasn't?:)
07:00:28 <Elemir> :3
07:00:29 <EvanR> ... me :(
07:00:29 <merijn> Saizan: What I heard was that the actual implementation was fairly easy, but getting it to fit into GHC was harder. But I might be completely wrong
07:00:47 <Philippa> t7: more times than I care to remember
07:00:58 <Philippa> implement unification, then the rest's pretty easy
07:01:19 <Philippa> (which reminds me: I need to implement unification under a mixed prefix)
07:01:29 <t7> did you use de bruijn indices for terms and types?
07:01:54 <Philippa> I didn't bother, no
07:02:06 <Elemir> Hem… Is there way to write tactics for System F in ghc?
07:02:09 <t7> the only examples i can find use the state monad or some other monad im not familiar with
07:02:27 <Philippa> yeah, that's because it's much easier if you use a monad to handle the constraint problem
07:02:29 <tai> is tryhaskell.org running a recent enough version of Haskell for it to be a useful resource for beginning the same?
07:02:34 * ChristianS shrugs -- getContents/readFile works fine for me
07:02:48 <Philippa> even when I've written all the machinery to not /have/ to use a monad, I do it anyway
07:02:49 <rostayob> tai: for beginning the same?
07:02:55 <Philippa> besides, the state monad's a piece of piss to work with
07:03:01 <Elemir> @src hGetContents
07:03:01 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:03:06 <quicksilver> ChristianS: they work fine if you don't care about handling errors or resources. They have their place.
07:03:07 <Elemir> @src getContents
07:03:07 <lambdabot> getContents = hGetContents stdin
07:03:12 <tai> sorry, I could have phrased that differently: "for beginning Haskell"
07:03:14 <Philippa> it's like IO except you've only got two operations - get and put, operating on a single mutable store
07:03:30 <Philippa> then you just call runState or evalState with your initial state and off you go
07:03:31 <rostayob> tai: tryhaskell is ok to toy around. get the Haskell Platform
07:03:36 <t7> maybe its time to get my feet wet with it then
07:03:48 <quicksilver> ChristianS: however, they should be documented better to explain their shortcomings and, in general, when you are using IO you do care about errors and resources.
07:04:08 <Philippa> *nod*. Just clean them off afterwards, you don't want them smelling all day :-)
07:04:37 <rwbarton> s/in general/sometimes/
07:04:42 <Philippa> quicksilver: yeah, lazy IO is mostly for when you at least locally don't care
07:04:55 <Philippa> (it might be nice to have exception-throwing lazy IO be more of a thing, though)
07:06:33 <hpaste> “_Mikey” pasted “cabal wxcore” at http://hpaste.org/65032
07:06:44 <t7> can HM be implemented with de bruijn indices rather than variable names?
07:06:49 <Philippa> of course it can
07:06:59 <Philippa> it doesn't care how you represent variables so long as you do so
07:07:02 <t7> no one seems to use them
07:07:06 <_Mikey> I'm having real trouble implementing wxcore through cabal
07:07:10 <Philippa> Pierce's code from TaPL does
07:07:18 <_Mikey> s/implementing/installing
07:07:32 <yrlnry> de bruijn indices are a bigger pain in the butt than alpha-conversion.
07:07:47 <t7> i like them :)
07:07:58 <Philippa> I gather a lot of code for dependently-typed languages uses them in some form - using strings for free variables and indices for bound ones is pretty common, for example
07:08:01 <ChristianS> readFile throws an error if the file doesn't exist or is unreadable, which (in my experience) is generally sufficient.
07:08:06 <t7> but keeping track of them while adding new type schemes and stuff sounds liek a pain
07:08:47 <Philippa> hint: until you generalise them, the 'type variables' in HM are really metavariables
07:08:58 <Philippa> (and all existentially bound at outermost scope)
07:09:24 <Philippa> once you generalise them, they're all bound within that type scheme, so you're probably just counting which variable your tree crawler found first anyway
07:11:05 <quicksilver> Philippa: I think that observation is rather subtle; the way HM works appears to, say, the naive user of an ML repl, to have a very simple approach to quantifiers, but "why that works so neatly" is not as simple as it looks.
07:11:20 <Philippa> *nod* yeah, very much so
07:11:24 <quicksilver> ChristianS: not if you get an error any time after opening the file.
07:11:43 <Philippa> those existential quantifiers belong to whatever metalogic you're using to handle the HM rules with, for example
07:12:07 <Philippa> whereas the universal quantifiers in type schemes belong firmly to the language the user works in
07:12:34 <Philippa> while I've not got on to HM you've probably caught me blogging about some of this lately, though?
07:12:40 <t7> im reading through algorythm w step by step, it doesnt have type application ...
07:12:59 <Philippa> of course it doesn't, HM has no notion of it
07:13:07 <Philippa> it just goes straight to the instantiation rule
07:13:38 <Philippa> HM doesn't have type lambdas either, just the (let-)generalisation rule
07:13:43 <rwbarton> quicksilver: how large do you think the proportion of programs that read a file is that care about exceptions that occur after the file has been successfully opened *and* want to deal with them in a way other than aborting with an error message
07:13:45 <t7> the wikipedia article shows monotypes as being t or ap t t
07:14:19 <rostayob> t7: I've implemented W in haskell several times if you need it
07:14:24 <t7> yes plox
07:14:33 <rostayob> t7: is it homework :P?
07:14:38 <t7> i wish it was
07:14:43 <t7> i might be able to get some help
07:14:45 <Philippa> I'd avoid using wikipedia as your main reference for such things
07:14:59 <Philippa> if you can afford it, Pierce's Types and Programming Languages is excellent, btw
07:15:06 <rostayob> t7: ok, wait a sec. btw, the best resource for this kind of things is "typing haskell in haskell", if you're a beginner
07:15:17 <hpaste> Peaker pasted “Histogram” at http://hpaste.org/65033
07:15:40 <ChristianS> quicksilver: true, but if somebody deletes a file from under my program's ass i'll just slap them instead of complaining about my program ;-)
07:15:45 <hpaste> Peaker annotated “Histogram” with “Histogram (less optimal)” at http://hpaste.org/65033#a65034
07:16:09 <rwbarton> someone else deleting the file wouldn't even be an error (at least on unix)
07:16:28 <Peaker> Ok -- toying with optimizing of this example. Started with a mapM_ action to increase the appropriate histogram bin for each char -- was slow. Replaced it with ByteString.Lazy.foldr to build the ST action -- and it sped up from 1.6sec to 1sec
07:16:37 <Peaker> any idea how to speed a loop over a lazy bytestring even further?
07:16:43 <Philippa> rostayob: overkill for HM, but yes, it works :-)
07:17:56 <rwbarton> and on windows I guess it is an error--for them :P
07:18:30 <rostayob> t7: mhm this is an SML version: https://github.com/rostayob/ml/blob/138ae8cbc3595057f04180df36fbc2cfc1d7f135/sml/typecheck.sml
07:18:37 <rostayob> the haskell version does a lot more than what you need
07:18:44 <Philippa> ...I just had a probably-not-silly idea. If I'm going to use the laptop on the sofa I should really try using the TV as a second monitor for papers, shouldn't I?
07:18:49 <geekosaur> :I'm going to use a typesafe programming language and then expect sloppy runtime behavior!"
07:19:12 <t7> wow thats consise
07:19:16 <EvanR> at least CRT tv is hard to read on
07:19:18 <t7> i need to learn how to read ml
07:19:24 <hpaste> Saizan pasted “Hindley Milner in 7 lines of hacky prolog” at http://hpaste.org/65035
07:19:53 <rostayob> t7: it'd be a lot shorter in haskell...
07:20:04 <rostayob> yeah, prolog is concise.
07:20:04 <t7> is that purely functional, rostayob
07:20:14 <rostayob> t7: no, the fresh variable generation is not
07:20:21 <rostayob> but it doesn't take much to purelyfunctionalize that
07:20:41 <rostayob> eg. thread a [1..]
07:20:48 <Philippa> or just write it in a state monad
07:21:11 <Philippa> if it behaves like state anyway, it's probably better code that way round
07:21:14 <rostayob> also, there is no separation at the type level between type schemes and normal types
07:21:21 <quicksilver> is prolog really concise? Or is that because it reuses prolog's internal unifier?
07:21:32 <rostayob> quicksilver: the latter
07:21:45 <rostayob> unification is easy peasy in prolog, and W is much about unification
07:21:49 * quicksilver nods
07:22:16 <rostayob> t7: actually no, I have a better resource for you, there is a paper with Cardelli's type inference code in Haskell
07:22:20 <rostayob> but they do path compression as well
07:22:28 <rostayob> but it's like 20 lines (just the unification)
07:22:42 <t7> rostayob: have you got this in haskell?
07:23:09 <rostayob> t7: no I don't have a straight W in haskell I think, but I did it more than once is very brief
07:23:25 <rostayob> which resource are you using to find out how W works?
07:23:32 <Philippa> rostayob: to be fair, writing unification as CHRs is also pretty quick for example
07:23:35 <Saizan> quicksilver: plus a extra-logical hack for handling type schemes without explicitly representing object-level variables
07:24:06 <quicksilver> Saizan: *nod*
07:24:12 <rostayob> Philippa: CHR?
07:25:13 <t7> various online articles
07:25:18 <t7> its not working very well
07:25:32 <Philippa> rostayob: Constraint Handling Rules
07:25:40 <rostayob> don't know what that is
07:25:46 <Philippa> they're a nifty concurrent logic language for describing constraint solvers
07:26:11 <yaxu> I've been trying to understand the reddit comments on my blog post here http://www.reddit.com/r/haskell/comments/qkc34/patterns_in_haskell_revisited/
07:26:17 <rostayob> t7: this is my course notes: http://www.doc.ic.ac.uk/~svb/Images/pdf.gif there's W at some point
07:26:24 <rostayob> I just translated it from there
07:26:37 <rostayob> and I represent the substitutions as lists which is inefficient but effective :P
07:26:39 <yaxu> Why is it amazing that these types are similar, and does it mean anything beyond a coincidence?
07:26:45 <t7> i hope thats not your course notes...
07:27:11 <rostayob> t7: it is
07:27:24 <t7> its just an icon
07:27:27 <rostayob> oh.
07:27:36 <rostayob> t7: http://www.doc.ic.ac.uk/~svb/TSfPL/notes.pdf , sorry
07:28:26 <rostayob> t7: page 29
07:28:46 <Philippa> so it turns out acroreader, fullscreen at fit visible on a TV is kinda pleasant
07:29:00 <rostayob> t7: once you have unification working translating it is super easy.
07:29:15 <t7> ok
07:29:26 <t7> can i implement that independently ?
07:29:38 <rostayob> t7: what? unification?
07:29:41 <Philippa> yes, it's just a function you'll call a lot
07:29:46 <t7> yeah
07:30:14 <rostayob> t7: yeah it's just something of type 'Type -> Type -> Subst'
07:30:28 <rostayob> well with failyre
07:30:30 <rostayob> *failure
07:30:50 <rostayob> in SML I just raise exceptions, in Haskell you want an error monad to do things nicely
07:32:44 <t7> i have no idea what this function should be returning
07:32:49 <t7> i need some test cases
07:34:31 <rostayob> t7: a substitution is a maping between type variables and types
07:34:34 <rostayob> *mapping
07:34:45 <rostayob> in my case I just use a [(TyVar, Type)]
07:34:50 * hackagebot happstack-static-routing 0.3 - Support for static URL routing with overlap detection for Happstack.  http://hackage.haskell.org/package/happstack-static-routing-0.3 (MagnusCarlsson)
07:36:17 <tai> so, Haskell doesn't have dotted pairs then?
07:36:44 * tai learning Haskell after studying Lisp for a while
07:36:56 <sipa> what is a dotted pair, exactly?
07:37:05 <mauke> a tuple. (a, b)
07:37:08 <tai> it's what you would get if 'a' : 'b' worked
07:37:23 <tai> mauke: oh, okay
07:38:23 <quicksilver> in list (:) and (,) are the same thing, so pairs and lists are unified.
07:38:32 <quicksilver> s/in list/in lisp/
07:38:43 <quicksilver> in haskell we consider it more convenient to tell them apart.
07:39:02 <tai> ah, okay
07:39:50 * hackagebot string-conversions 0.2 - Simplifies dealing with different types for strings  http://hackage.haskell.org/package/string-conversions-0.2 (SoenkeHahn)
07:39:59 <EvanR> not only do arrays/lists used for pairs annoy me in other systems, but they are usually damn inconvenient without pattern matching
07:40:20 <quicksilver> lisp doesn't use arrays/lists for pairs.
07:40:25 <quicksilver> it uses pairs for lists.
07:40:53 <EvanR> ah right
07:43:57 <sclv> yaxu: it is a pretty neat coincidence.
07:45:35 <tai> wow! I like how simple maths lambdas are given to map
07:46:08 <tai> I saw +1 and figured at first that it'd be a special case
07:46:55 <mauke> no, this isn't lisp :-)
07:47:25 <sclv> But I think the treatmeant of final events is what makes this different...
07:47:57 <rostayob> oh, finally <> = mappend. I hadn't noticee
07:47:59 <rostayob> *noticed
07:49:56 <_Mikey> guys! It's friday!! :)
07:50:09 <_Mikey> is there a parallel version of zipWith?
07:50:27 <mauke> what
07:50:35 <Elemir> @src zipWith
07:50:35 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:50:36 <lambdabot> zipWith _ _      _      = []
07:50:37 <rwbarton> wrong question
07:50:44 <_Mikey> @hoogle (a->b->c) -> [a] -> [b] -> [c]
07:50:44 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:50:45 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:50:45 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:51:31 <_Mikey> rwbarton, wrong?
07:51:32 <Elemir> It's already parallel, IMHO
07:51:41 <rwbarton> the question should be "how do I evaluate the elements of this list in parallel"
07:51:50 <_Mikey> ahh
07:52:27 <_Mikey> but par requires another parameter to be evaluated in parallel right?
07:52:59 <sclv> actually... the argument is basically, I guess, that a pipe over [] takes a list: [a] and describes a very general transformation to a list: [r], with intermediate values of doubles and possibly durations. and that's basically the meaning of what your patterns do!
07:53:02 <rwbarton> there are several functions for evaluating the elements of a list in parallel, see Control.Parallel.Strategies
07:53:56 <Elemir> GHC doesn't support parallel optimization?
07:54:04 <_Mikey> unless I did something like [ zipWith \x y-> x+y (map (par $) [ints]) ([moreints])
07:54:38 <mauke> huh?
07:55:31 <aszlig> hm, does it make sense to submit a highly specific package to hackage? highly specific as in: it's just the slave and the library which is only useful for a very limited audience...
07:55:46 <rwbarton> everyone go read the Control.Parallel.Strategies for 5 min and then see if you have any questions.
07:56:08 <rwbarton> *Control.Parallel.Strategies documentation (http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/Control-Parallel-Strategies.html)
07:59:45 <_Mikey> rwbarton, how does one make values of type Strategy
08:01:16 <_Mikey> rpar moves something into the Eval monad
08:01:17 <zhulikas> @hoogle Strategy
08:01:18 <lambdabot> Control.Seq type Strategy a = a -> ()
08:01:18 <lambdabot> Control.Parallel.Strategies type Strategy a = a -> Eval a
08:01:18 <lambdabot> package StrategyLib
08:01:42 <zhulikas> @type Strategy 5
08:01:43 <lambdabot> Not in scope: data constructor `Strategy'
08:01:46 <rwbarton> for individual elements you will want rseq or rdeepseq
08:02:05 <_Mikey> rwbarton, but for a list of elements
08:02:16 <rwbarton> then read the rest of the module
08:02:18 <rwbarton> there are many options
08:28:58 <_Mikey> so close in installing this package I've been trying to get for days now
08:29:25 <hpaste> “_Mikey” pasted “shadowed package” at http://hpaste.org/65040
08:29:42 <_Mikey> does anyone know how to unshadow cabal packages?
08:30:35 <dcoutts_> _Mikey: unregister the other one
08:31:32 <geekosaur> that means you have different versions of a package installed in global and user (which is in general a bad thing); you could "ghc-pkg hide --user parsec-3.1.1" (or unregister it but that could break other stuff)
08:39:14 <kallisti> anyone familiar with Aeson?
08:39:43 <Clint> barely
08:40:31 <kallisti> I'm trying to get:  Parser a -> Result a
08:40:57 <kallisti> something like:  parse parseJSON ?
08:41:33 <Saizan> the Parser type is from attoparsec, iirc
08:45:13 <_Mikey> dcoutts_, unregistering either package doesn't work.
08:45:23 <_Mikey> using the full package id anyhow.
08:45:54 <dcoutts_> _Mikey: almost certainly one is in the user db and one in the global, so you can just use the --user flag and the short id
08:47:52 <tai> wow pattern matching is pretty neat
08:49:46 <tai> hmm, the tutorial wanted me to use let (_,(a:_)) = (10,"abc") in a , but I used let (a,b:_) = (10,"abc") in b to get the same result.  Aside from the ignored values listed by _, what is non-canonical about the guess I had made?
08:51:27 <geekosaur> tai, you assumed operator precedence
08:51:31 <cheater> tai: you don't use a.
08:51:39 <cheater> and what he said.
08:51:48 <Cale> and you guessed correctly
08:52:06 <Cale> Though, (,) isn't exactly an operator
08:52:09 <Cale> it's special syntax
08:52:28 <geekosaur> yeh, I meant of (:) relative to the special syntax
08:53:03 <hpc> > let (a, b) = (10, "abc") in b
08:53:04 <lambdabot>   "abc"
08:53:09 <hpc> > let b = "abc" in b
08:53:10 <lambdabot>   "abc"
08:53:14 <geekosaur> although in some sense (:) is special syntax in h'98, I think
08:53:22 <hpc> > let (b:bs) = "abc" in (b, bs)
08:53:23 <lambdabot>   ('a',"bc")
08:53:25 <_Mikey> dcoutts_, Cheers!
08:53:33 <hpc> > let (b:bs) = 'a':'b':'c' in (b, bs)
08:53:34 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:53:34 <lambdabot>         against inferred ty...
08:53:38 <hpc> > let (b:bs) = 'a':'b':'c':[] in (b, bs)
08:53:39 <lambdabot>   ('a',"bc")
08:53:43 <_Mikey> I've got it compiling, should know in a few seconds if I'm there.
08:54:28 <Cale> Well, no other precedence would have parsed correctly, because the parens are a required part of the pair syntax
08:55:08 <Cale> In any case tai, I wouldn't worry about the difference between your code and the tutorial's
08:55:56 <kallisti> currently I'm extracting the HashMap and using lookup
08:56:05 <Cale> I personally don't use the _ pattern very much, probably because I just think the underscore character is typographically ugly. :)
08:56:09 <kallisti> but I feel that there should be an easy way to use .: to extract fields from an existing JSON Value.
08:56:24 <kallisti> Cale: I sometimes use "otherwise"
08:56:54 <Cale> Shadowing the Prelude's definition of otherwise seems a little problematic though ;)
08:57:30 <geekosaur> `sth'?  (only half serious)
08:57:43 <nart> hi
08:58:03 <Cale> case foo of True -> ...; otherwise -> case bar of x | ... | otherwise -> "lol"
08:58:10 <kallisti> heh
08:58:25 <nart> i'm trying to understand filterM and the infamous powerSet with no luck, any tips ? =)
08:58:36 <kallisti> nart: do you understand the list monad?
08:59:05 <Cale> nart: "Running" a list in the list monad means to pick an element from it in all possible ways
08:59:08 <nart> i have read the cap on learnyouahaskell
08:59:17 <nart> but i don't think i understand it really well
08:59:25 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
08:59:26 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
08:59:30 <kallisti> > do { x <- [1..10]; y <- [1..100]; [x+y, x-y] }
08:59:31 <lambdabot>   [2,0,3,-1,4,-2,5,-3,6,-4,7,-5,8,-6,9,-7,10,-8,11,-9,12,-10,13,-11,14,-12,15...
08:59:52 <nart> vectorial product ?
09:00:00 <kallisti> it can be used to model that yes.
09:00:02 <Cale> Cartesian product
09:00:08 <kallisti> er, yes that.
09:00:24 <Cale> > sequence [[1,2,3], [4,5], [6,7,8]]
09:00:25 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
09:00:34 <kallisti> but you can also return multiple results from a list computation as well.
09:00:46 <kallisti> :t filterM
09:00:47 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:00:51 <Cale> okay, so filterM is a version of filter which runs the "predicate" in an arbitrary monad
09:01:12 <Cale> If we choose the list monad, it lets us say "no matter what the element is, either drop it or keep it"
09:01:21 <Cale> that is,  const [False, True]
09:02:21 <kallisti> which is, in combinatorics, one of the ways you can think about the powerset. the number of elements in a powerset is 2^n.  A good way to think of this is that you go up to each element and ask "are you in the set, or are you out?"  each time you ask represents 2 distinct possibilities, and so you multiply those possibilities together with all the others.
09:02:25 <Cale> and the list monad will make those choices in all possible ways and give a list of the results
09:03:34 <kallisti> > length $ filterM (const [True, False]) [100..103]
09:03:35 <lambdabot>   16
09:04:01 <kallisti> > 2^4
09:04:02 <lambdabot>   16
09:04:18 <nart> mmmm, thanks
09:06:04 <kallisti> heh, hopefully my incoherent rambling made some amount of sense.
09:06:22 * kallisti is not good at explaining things, but he can bombard you with related facts to help it sink in. :P
09:06:42 <nart> eheh
09:07:43 <gytis_z> lol
09:07:52 <kallisti> nart: the list monad is great. you should look into its potential uses.
09:08:46 <andares> hey, I'm working on project euler, trying to find the greatest product of four diagonally-adjacent elements in a list.
09:09:11 <nart> i'll look into it, thanks again :D
09:09:22 <andares> are there good ways to iterate over things like that?
09:09:34 <andares> I don't want to use indices because it seems un-Haskell.
09:09:37 <andares> and ugly.
09:10:26 <kallisti> andares: well, it's ugly when you're using a linked list, yes.
09:10:32 <kallisti> with other structures indexing is perfectly natural.
09:10:55 <kallisti> andares: you would probably want to make use of the list monad.
09:10:58 <andares> what structures would be appropriate?
09:11:05 <andares> ah
09:11:05 <kallisti> in fact that's how I did that particular problem.
09:11:33 <Philippa> kallisti: paths for trees are an awesome thing
09:11:58 <kallisti> andares: what's the problem number again, so I can see how I did it.
09:12:09 <andares> problem 11, kallisti!
09:12:11 <kallisti> (I won't spoil it for you. just want to look)
09:12:22 <Philippa> if you want random access, arrays are available as well
09:12:49 <kallisti> oh, I did something insane actually.
09:12:52 <kallisti> I can barely read it.
09:14:38 <kallisti> basically what I did is iterate over every point, and from that point produce the vertical, horizontal, major diagonal, and minor diagonal that "starts" at that point (and using Maybe to omit the cases where they don't exist, such as points on the edge of the grid). from there it's just taking the product of each of those sublists and finding the maximum.
09:14:44 <kallisti> ...hopefully doesn't spoil too much. :P
09:15:45 <kallisti> oh and I used an array to make indexing faster.
09:16:36 <andares> kallisti: that doesn't sound like a very pretty way to solve it. :p
09:16:44 <andares> but List monads are a good idea?
09:16:57 <kallisti> actually I'm not sure that I'm using the list monad. lemme look.
09:17:06 <kallisti> oh, I am.
09:17:22 <kallisti> andares: it's not perfect, but it works pretty well.
09:17:35 <kallisti> and it's too ugly if you use the right functions.
09:17:48 <andares> too ugly?
09:18:18 <kallisti> I could show you the code if you'd like. :P
09:21:55 <Spockz`> Is it possible to specify --enable-tests in the cabal file, so we don't need to pass it to configure
09:22:14 <kallisti> anders^^: it uses the list monad over a list of functions, arrows, and Data.Array... so you know it's quality stuff!
09:22:46 <kallisti> oh he left.
09:25:38 <dmwit> Spockz`: No, and let's hope it never is.
09:25:47 <dmwit> Spockz`: You can specify it in your ~/.cabal/config, though.
09:28:17 <_Mikey> Hey guys,
09:28:20 <_Mikey> I have a question
09:28:22 <_Mikey> http://www.haskell.org/haskellwiki/WxHaskell/Troubleshooting#App-compilation_issues
09:28:34 <_Mikey> it says "doing the standard Cabal stuff"
09:28:41 <_Mikey> what does it mean by that?
09:29:47 <dmwit> _Mikey: It means typing "cabal install".
09:36:33 <kallisti> okay so, unlike local, withState modifies the global state after it's applied right?
09:37:39 <kallisti> I basically want local in State, if that already exists. otherwise I'll roll my own.
09:38:37 <ski> afaik, you'll have to roll your own
09:38:57 * ski wonders how this would interact with exceptions
09:39:14 <kallisti> ski: shhhhh. don't want to think about that.
09:39:31 <ski> @unmtl StateT s (ErrorT e m) a
09:39:32 <lambdabot> s -> m (Either e (a, s))
09:39:41 <ski> @unmtl ErrorT e (StateT s m) a
09:39:41 <lambdabot> s -> m (Either e a, s)
09:39:53 <kallisti> I'm currently using the former.
09:40:21 <kallisti> I could do exception handling to always ensure that the state is returned back to the original.
09:40:37 <ski> hm, in the former case, there should be no problem, since an exception means the state is lost
09:40:59 <kallisti> hm, ah right.
09:41:10 * kallisti occasionally mixes up the way monad stacks peel off.
09:41:44 <kallisti> maybe I want the reverse though...
09:41:57 <kallisti> it would be nice to handle exceptions and keep a consistent state.
09:42:08 <kallisti> but it would also be nice to handle exceptions across multiple unrelated states.
09:42:15 <ski> in the latter case, i suppose one could fix this by making a class with `fluidLet' as member, with `instance MonadFluid m s => MonadFluid (EitherT e m) s' doing the right thing
09:42:40 <pozic> MonadFluid?
09:43:31 <ski> well, this is known as `fluid-let' or `let-fluid' (or dynamic/special variables or parameters) in Scheme (/ Lisp)
09:47:44 <kallisti> ski: hmm, so state doesn't get thread between the two if I use mplus?
09:47:47 <kallisti> *threaded
09:48:13 <kallisti> failingStateTErrorT `mplus` successSTateTErrorT
09:48:44 <kallisti> oh wait
09:48:48 <kallisti> that would be if it's ErrorT on the outside.
09:49:36 <kallisti> oh wait, StateT's MonadPlus instance just falls through to the inner monad.
09:49:38 <kallisti> so yeah.
09:50:49 <kallisti> m `mplus` n = StateT $ \s -> runStateT m s `mplus` runStateT n s
09:51:42 <kallisti> so they share state through mplus. which means that if an error occurs inside the withState computation, the state change is no longer "local"
09:52:06 <kallisti> if I understand this correctly. mtl is confusing. :P
09:52:41 <kallisti> oh no. nevermind
09:52:56 <kallisti> they share state at the point mplus is called, but the state isn't threaded from the first argument to the second.
09:53:00 <kallisti> got it.
09:57:52 <quicksilver> kallisti: the state from the first half is rolled back, if it fails
09:57:56 <quicksilver> is one way of looking at that
09:58:00 <quicksilver> (but what you said is correct)
09:58:09 <kallisti> quicksilver: yep.
09:58:23 <quicksilver> which is transactional behaviour
09:58:25 <quicksilver> in a slightly weak sense
09:58:46 <kallisti> transactional behavior thanks to immutability? :P
09:59:14 <ski> kallisti : hm, with `mplus' it should only be threaded into the two branches, not out of one branch into the other
09:59:14 <Philippa> thanks to handling the state explicitly
10:00:03 * ski nods to what was said
10:08:03 <ch33sus> hey there, just wanted to get started with haskell, any comments on "real world haskell" book?
10:08:27 <t7> @hoogle intersperse
10:08:28 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:08:28 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
10:08:28 <lambdabot> Data.ByteString.Lazy.Char8 intersperse :: Char -> ByteString -> ByteString
10:08:45 <byorgey> ch33sus: it's good.
10:08:52 <byorgey> ch33sus: you may also be interested in:
10:08:54 <byorgey> @where lyah
10:08:54 <lambdabot> http://www.learnyouahaskell.com/
10:09:07 <byorgey> depending on your background and why you are interested in Haskell.
10:09:53 <ch33sus> coming from good old C
10:11:28 <ch33sus> ok lyah looks cool, is there maybe a version i can download?
10:12:22 <byorgey> ch33sus: you can buy it as an ebook
10:12:32 <t7> i wish my vim had tab completion for haskell
10:13:05 <ch33sus> hm i can read the whole book online for free but have to pay for a download version?
10:14:27 <ch33sus> i mean httrack takes maybe 2 minutes to download the site so wtf
10:15:33 <ch33sus> anyway i got reservation for real world haskell in the library if you say its good it will be alright i guess
10:15:37 <ch33sus> thanks anyway
10:17:53 <kallisti> Object (fromList [("stackTrace",Array (fromList [])),("message",String ""),("Screen",Null),("",Null),("Class",Null)])
10:17:56 <kallisti> huh, interesting.
10:18:09 <kallisti> a JSON key with no name. :P
10:18:11 <kallisti> wonder what happens to that.
10:21:52 <rostayob> kallisti: did you parse that?
10:21:57 <rostayob> t7: emacs.
10:22:23 <t7> rostayob im porting your type inference thing :3
10:22:38 <rostayob> the sml one?
10:22:42 <t7> yeah
10:23:00 <rostayob> i wouldn't be surprised if something is broken, but nothing significant. the parser is ugly.
10:23:19 <rostayob> also in terms of educational value I'd suggest understanding how W works :P
10:23:36 <t7> im trying to learn by doing
10:25:16 <rostayob> t7: you can easily port that code without a clue on how it works.
10:27:18 <ChristianS> ch33sus: i have a pdf version of LYAH which was once available on their site and which i can share if you are interested. not sure how up-to-date it, it's a few year old and ends with "More LYAH coming soon, keeps your eyes peeled!"
10:27:32 <t7> rostayob: well it cant hurt
10:28:29 <t7> type annotations on functions would have been nice :P
10:28:54 <rostayob> t7: you can't with SML
10:28:59 <rostayob> i mean you can but it's awkward
10:29:14 <t7> why did you write this in sml anyway
10:29:21 <t7> it seems like an awful language
10:29:23 <rostayob> t7: i wanted to learn sml
10:29:26 <rostayob> it's a very nice language.
10:29:37 <t7> i like * for product, but thats it
10:29:52 <rostayob> t7: the module system is great. also, it's a small langauge
10:30:09 <rostayob> it's very far from an horrible language anyway.
10:31:05 <t7> haskell has spoiled me
10:31:33 <Kaidelong> SML has some warts but so does Haskell
10:32:18 <rostayob> t7: sml would be as nice as haskell if it wasn't for some conservative but useless choices
10:32:35 <rostayob> the most annoying thing is that type constructors can't be partially applied
10:32:49 <rostayob> also the value restriction is annoying
10:32:58 <rostayob> but overall is a very good functional language
10:33:52 <Kaidelong> the value restriction is one of the main reasons why I think future MLs will start tending to be pure
10:33:58 <Kaidelong> in some way or another
10:36:54 <rostayob> Kaidelong: there must be better way of dealing with that.
10:37:04 <rostayob> also, it's not *that* annoying when you get used to it.
10:37:23 <Kaidelong> rostayob: What's wrong with making a pure ML that uses something like stream IO?
10:37:24 <rostayob> the fact that most functions and data constructors are uncurried is much more annoying in everyday programming
10:37:45 <Kaidelong> yeah that's rather surprising to me too since it's a trivial transformation from one to the other
10:37:51 <rostayob> what's stream IO?
10:38:14 <rostayob> SML programming style relies on side effects for IO tasks
10:38:19 <Kaidelong> rostayob: like rather than working with impure values you treat the program as an accumulator over a stream of pure values
10:38:27 <Kaidelong> that comes from the outside world
10:38:39 <rostayob> Kaidelong: that sucks, it was like that in the initial Haskell afaik
10:38:54 <tmike> Quick question: Haskell looks really cool, but I don't have much time for work to learn more than I need for xmonad configuration.  Can someone tell me what <+> does?
10:39:10 <Kaidelong> that was my impression too when my dad bought it up
10:39:13 <DrSyzygy> :t <+>
10:39:14 <lambdabot> parse error on input `<+>'
10:39:16 <byorgey> tmike: <+> is xmonad-specific
10:39:23 <tmike> interesting
10:39:24 <byorgey> it combines two ManageHooks into one, IIRC
10:39:25 <rostayob> tmike: composes hooks
10:39:26 <Kaidelong> but he has started convincing me, although his concept is dynamically typed and it may work better in that context
10:39:45 <tmike> Okay.  That explains why I couldn't find any information on it.
10:39:47 <tmike> Thank you very much.
10:39:58 <rostayob> Kaidelong: no you don't understand, Haskell was like that at the beginning and nobody liked it as far as I know
10:40:02 <rostayob> tmike: http://hackage.haskell.org/packages/archive/xmonad/0.10/doc/html/XMonad-ManageHook.html#v:-60--43--62-
10:40:09 <rostayob> tmike: in general, http://hackage.haskell.org/packages/archive/xmonad/0.10/doc/html/doc-index.html
10:40:15 <byorgey> tmike: in fact, it turns out it is just a synonym for 'mappend'
10:40:18 <Kaidelong> rostayob: Yes that's what I told him
10:40:22 <rostayob> Kaidelong: and?
10:40:36 <Kaidelong> I realized I didn't know why stream IO sucks and mini is such a different language from haskell
10:40:48 <Kaidelong> that I should take a serious look at the concept in its context
10:41:10 <tmike> Lovely.  Thanks a bunch.
10:41:18 <rostayob> I don't know what "mini" is,  but the consensus on stream io seems that it's not that useful for practical programming.
10:41:31 <rostayob> I think that a strict functional programming languages with side effects has its place
10:41:43 <rostayob> you can type it better of course
10:41:49 <rostayob> disciple seems really cool in that direction
10:41:58 <Kaidelong> disciple is cool although
10:42:10 <Kaidelong> I'm more interested in where things like F* and ACL2 are going to go
10:42:16 <Kaidelong> anyway we should take this to -blah
10:42:43 <rostayob> Kaidelong: those are different languages for different purposes :)
10:42:48 <rostayob> (I don't know ACL2)
10:43:04 <Kaidelong> Applicative Common Lisp 2, a pure, strict, sub-turing language
10:43:33 <Kaidelong> but what I find really cool about it is its type system
10:43:48 <rostayob> why?
10:43:51 <rostayob> i mean
10:43:53 <Kaidelong> which is basically dynamic types with static checks to ensure functions are total
10:43:55 <rostayob> what does it have?
10:44:23 <rostayob> I am having trouble imagining that.
10:44:31 <rostayob> dynamic strong types?
10:44:42 <Kaidelong> I guess that is what it boils down to
10:44:56 <rostayob> well if they're weak I realy can't see how that works.
10:45:03 * hackagebot unordered-containers 0.2.0.1 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.2.0.1 (JohanTibell)
10:45:05 * hackagebot diagrams-lib 0.5 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.5 (BrentYorgey)
10:45:07 * hackagebot diagrams-core 0.5 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.5 (BrentYorgey)
10:45:19 <Kaidelong> you don't have a compile time phase where you check types but you do have a proof phase where a turing complete prover tries to prove program termination
10:45:20 <t7> whats @ in sml?
10:45:45 <byorgey> t7: list concatenation, I think
10:45:51 <Kaidelong> and really proving and typechecking boil down to the same thing
10:46:22 <rostayob> Kaidelong: the usual type theory stuff
10:46:31 <rostayob> I don't see how you do that with dynamic types.
10:47:11 <rostayob> I mean TT is not novel (and that's the most famous of programs as proofs)
10:47:19 <rostayob> but I don't see how dynamic types fit :P
10:47:23 <Kaidelong> rostayob: You don't know at compile time, if there even is one, what type something has, but you know properties that it has to prove it has. Not all too different from typeclasses except you always wait until runtime
10:47:26 <Kaidelong> to specialize
10:48:47 <rostayob> Kaidelong: I can't picture it. I might read about it sometimes when I have time
10:48:57 <rostayob> I am satisfied with Agda for what concerns those kind of stuff
10:49:32 <Kaidelong> Agda with structural typing would probably boil down to something very similar
10:50:09 * hackagebot active 0.1.0.0 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.0 (BrentYorgey)
10:50:10 <rostayob> Kaidelong: yeah but defining data families is a fundamental part of agda.
10:50:11 * hackagebot diagrams-cairo 0.5 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.5 (BrentYorgey)
10:50:14 * hackagebot diagrams-contrib 0.1.0.0 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-0.1.0.0 (BrentYorgey)
10:50:16 * hackagebot diagrams 0.5 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-0.5 (BrentYorgey)
10:52:13 <rostayob> Kaidelong: well I guess you can have a unityped language since you can represent all algebraic data types with one type anyways
10:52:42 <t7> ?
10:53:08 <rostayob> t7: ?
10:53:18 <Kaidelong> rostayob: I think the deeper issue is simply that the dynamic/static distinction becomes unimportant if you can already prove that functions are total
10:53:26 <t7> whats this one type to rule them all?
10:53:27 <Kaidelong> you end up with some kinds of static checks
10:53:48 <Kaidelong> well unimportant wrt correctness
10:53:57 <rostayob> Kaidelong: yes but if you have dynamic types you have to check totality against all possible inputs
10:53:58 <Kaidelong> still important in other ways like performance and extensibility at runtime
10:54:45 <Kaidelong> rostayob: when you have access to the code to check it against, which can be at runtime, that's fine, you just keep the prover around right?
10:55:01 <rostayob> t7: well, firstly, there is to notice that all ADTs are sums of products anyway
10:55:12 <rostayob> so you can have a uniform representation, e.g. GHC.Generic
10:55:58 <rostayob> in type theory you can define tree like data family that can represent any data type quite elengantly
10:55:58 <t7> ah
10:57:15 <rostayob> actually it's not even a data family sorry
11:16:29 <damowe> hello
11:16:47 <dmwit> an auspicious start =)
11:16:54 <Kaidelong> hello
11:16:59 <zhulikas> haj
11:17:51 <damowe> is there any lazy version of lines (http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:lines) to that I can use with hGetContents?
11:18:17 <dmwit> lines is already lazy
11:18:51 <dmwit> > lines ("abc\n" ++ undefined)
11:18:51 <zhulikas> I am lazy too
11:18:53 <lambdabot>   ["abc"*Exception: Prelude.undefined
11:18:58 <dmwit> see?
11:19:34 <scooty-puff> would someone beable to explain some of this to me:
11:19:34 <scooty-puff> http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
11:19:37 <damowe> xD
11:19:42 <zhulikas> > head $ lines ("a\n" ++ undefined)
11:19:42 <scooty-puff> in particular the TypeCase stuff
11:19:43 <lambdabot>   "a"
11:19:54 <zhulikas> if it wasn't lazy, it would throw an exception?
11:20:42 <dmwit> zhulikas: yes
11:20:52 <ski> > lines ("abc" ++ undefined)
11:20:53 <lambdabot>   ["abc*Exception: Prelude.undefined
11:20:59 <zhulikas> ok
11:21:14 <zhulikas> my example shows better how lines is lazy!
11:21:49 <ski> all show it sufficiently, imo
11:21:58 <zhulikas> > head $ reverse $ reverse $ lines ("a\n" ++ undefined)
11:21:59 <lambdabot>   "*Exception: Prelude.undefined
11:22:03 <dmwit> I agree with ski.
11:22:07 <zhulikas> I do not
11:22:18 <zhulikas> it needs to be more clear for me :D
11:22:29 <ski> (but different ways to look at something is useful)
11:23:54 <ski> > (head . reverse . reverse . lines) ("a\n" ++ [undefined])
11:23:56 <lambdabot>   "*Exception: Prelude.undefined
11:24:09 <zhulikas> indeed
11:24:10 <ski> > undefined :: String
11:24:11 <lambdabot>   "*Exception: Prelude.undefined
11:24:23 <zhulikas> reverse . reverse kinda makes it not-lazy
11:24:30 <ski> aye
11:25:04 <zhulikas> don't mind that I tell obvious things :D I am still learning
11:25:21 <zhulikas> kinda need a confirmation
11:25:44 <ski> np :)
11:26:31 <Hemite> Hi guys, I'm trying to learn haskell, and I was wondering if anyone could help me with this implementation of the maximum function
11:26:34 <Hemite> maximum' :: (Ord a) => [a] -> a
11:26:34 <Hemite> maximum' = foldr1 (\x acc -> if x > acc then x else acc)
11:26:49 <Hemite> I'm not too sure how that second line works
11:27:08 <dmwit> > foldr1 f [x,y,z]
11:27:09 <lambdabot>   Ambiguous occurrence `f'
11:27:09 <lambdabot>  It could refer to either `L.f', defined at <local...
11:27:16 <ski> @define
11:27:17 <zhulikas> do you know how fold works?
11:27:17 <dmwit> ?undefine
11:27:21 <dmwit> > foldr1 f [x,y,z]
11:27:22 <lambdabot>   f x (f y z)
11:27:29 <dmwit> > foldr1 f [v,w,x,y,z]
11:27:30 <lambdabot>   f v (f w (f x (f y z)))
11:27:48 <Hemite> I'm reading up on the fold section, but I am a bit confused
11:27:52 <dmwit> ?wiki fold diagrams
11:27:52 <lambdabot> http://www.haskell.org/haskellwiki/fold_diagrams
11:27:56 <zhulikas> \x acc -> ... is a function which takes two arguments and returns only the bigger one
11:27:56 <ski> Hemite : it might help if you give the lambda-expression a name, in a `where'
11:28:05 <zhulikas> now with a fold you go over a list - you go over every element
11:28:22 <Hemite> yea the section that's teaching folds is using lambda's, and I don't think I quite grasped both concepts
11:28:24 <dmwit> http://en.wikipedia.org/wiki/Fold_(higher-order_function)
11:28:26 <ski>   maximum' = foldr1 func
11:28:27 <zhulikas> so every time you go over an element - you compare it with something you had as a result from last function
11:28:28 <ski>     where
11:28:29 <ski>     func = \x acc -> if x > acc then x else acc
11:28:38 <ski> where that last line could be rewritten as
11:28:43 <ski>     func x acc = if x > acc then x else acc
11:28:47 <zhulikas> and if it's bigger than a previous result - you take that value and go to the next element
11:28:55 <zhulikas> until end of the list is reached
11:29:10 <ski> Hemite : my `func' corresponds to the `f' in dmwit's examples above
11:29:23 <zhulikas> > foldl (\a b -> if a > b then a else b) 0 [1..10]
11:29:23 <lambdabot>   10
11:29:34 <zhulikas> 0 is initial value
11:29:42 <zhulikas> so on first function call a will be 0 and b will be 1
11:29:56 <zhulikas> next time a will be return value of first call and b will be 2
11:30:00 <zhulikas> and it goes forward
11:30:03 <ski> > let maximum' :: (Ord a) => [a] -> a; maximum' = foldr1 (\x acc -> if x > acc then x else acc)  in  maximum' [1..10]
11:30:04 <lambdabot>   10
11:30:14 <kallisti> no, it seems Aeson uses an internal Parser type
11:30:16 <kallisti> and hides constructors..
11:30:33 <zhulikas> I think it's a bad thing to use foldr1 as it doesn't show what's an initial value. So it looks like it works magically
11:30:37 <ski> > foldl1 f [v,w,x,y,z]
11:30:38 <lambdabot>   f (f (f (f v w) x) y) z
11:30:57 <zhulikas> Hemite, did you get what I said?
11:31:43 <Hemite> I'm reading all the responses carefully
11:32:27 <kallisti> so... I still can't figure out how to extract a value from an Aeson Parser
11:32:33 <kallisti> because it's not attoparsec and its constructors are hidden.
11:32:59 <ski> as zhulikas says, it might be easier to understand if you start with `foldl1' (or `foldl') instead of `foldr1' (or `foldr')
11:33:14 <zhulikas> I'd say just foldl/foldr
11:33:20 <zhulikas> so it requires setting initial value
11:33:25 <Hemite> @ski true, but I think I understand how foldl1 works in this case, not so much how to implement it with foldr1
11:33:25 <lambdabot> Maybe you meant: ask src wiki
11:33:30 <zhulikas> and yes, left one probably
11:34:00 <damowe> can this function cause a memory leak? http://hpaste.org/65055
11:34:10 <Hemite> I think I'm not sure what acc is referring to, the entire list starting from the right?
11:34:25 <zhulikas> accessor
11:34:32 <monochrom> acc is the maximum found "so far"
11:34:33 <zhulikas> like - an element before current one
11:34:38 <zhulikas> ah, or that
11:34:40 <Hemite> I see
11:34:49 <Saizan> acc is short for accumulator
11:34:56 <zhulikas> oops
11:35:02 <zhulikas> it's time for me to stop talking
11:36:20 <Hemite> so if x is bigger than acc, the function is called again with a bigger acc?
11:36:38 <ski> Hemite : one way to think of it is : `acc' when using `foldl', is the maximum so far, reading the list from the *left*
11:36:52 <dmwit> damowe: Calling "seq" with a list argument is usually a bit silly.
11:37:00 <ski> Hemite : while `acc', when using `foldr', is the maximum so far, reading the list from the *right*
11:37:04 <dmwit> damowe: It only evaluates far enough to tell whether the resulting list is [] or not.
11:37:12 <damowe> ah, I see
11:37:29 <ski> (Hemite : this isn't the whole story regarding `foldr', but i think it can be a good zeroeth approximation of what happens)
11:37:50 <dmh> wait, does foldr1 mean it starts at 1 for initial acc?
11:37:56 <Hemite> @ski all right, thanks for the help
11:37:56 <lambdabot> Maybe you meant: ask src wiki
11:38:05 <monochrom> you are really looking at: foldr1 max
11:38:10 <smithw> hi, I wrote a simple program to count the weekdays in a given date range, and it works. can anyone please criticize it style-wise? http://hpaste/65057
11:38:12 <ski> Hemite : so, using `foldl1', it will start by comparing the first two elements, then comparing the maximum of those with the next, then comparing the maximum so far with the next, &c.
11:38:15 <dmwit> damowe: (Also, the first clause is subsumed by the second, so you can drop it entirely. Shouldn't affect time or space performance, though.)
11:38:15 <mauke> @src foldr1
11:38:16 <lambdabot> foldr1 _ [x]    = x
11:38:16 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
11:38:16 <lambdabot> foldr1 _ []     = undefined
11:38:26 <bgamari> Are there any regexp implementations operating on Data.Text?
11:38:30 <dmh> hrm
11:38:35 <smithw> I'm fairly new to FP and I'm trying to get it right...
11:38:47 <dmwit> smithw: ...that's not a real URL at all!
11:39:03 <ski> Hemite : otoh, using `foldr1', it will start by comparing the *last* two elements, working its way backwards, keeping track of current maximum, until it reaches the start, at which point it has the global maximum of the whole list
11:39:09 <ski> Hemite : does that help any ?
11:39:23 <monochrom> with foldr1 max (x:xs) = max x (foldr1 max xs), you are finding the max between x and (the maximum of the rest of the list)
11:39:29 <smithw> dmwit, I'm sorry, I'm connected on my tablet and copying from the desktop... http://hpaste.org/65057
11:39:48 <kallisti> ...this should not be as difficult as it is.
11:40:09 <dmwit> damowe: Not sure about space leaks. Nothing obvious there, but have you profiled it?
11:40:21 <Hemite> @ski Yes I think I get it now, My confusion was that I thought acc represented the whole list, which was not the case. I believe I understand the situation now though, thank you guys for the help
11:40:21 <lambdabot> Maybe you meant: ask src wiki
11:40:41 <Hemite> thanks everyone for the help
11:41:17 <damowe> dmwit: yes, I got a many LogLine entries which is the result of parseLogLine
11:41:43 <dmwit> smithw: Mostly it looks good.
11:41:48 <ski> Hemite : please do "ski : ...", not "@ski ..."
11:42:02 <damowe> where can I upload an image of the profiled program?
11:42:05 <dmwit> smithw: I prefer (.) chains to ($) ones whenever possible, and main is a bit messy.
11:42:21 <Hemite> "ski : oh ok, sorry
11:42:31 <ski> (heh, without the quotes, i.e.)
11:42:58 <Hemite> -facepalm-
11:43:02 <Hemite> ski: yes thanks
11:43:11 <ski> yw :)
11:43:23 <ski> > 4 `max` (3 `min` undefined) -- .. it would be nice if this could give `4'
11:43:24 <lambdabot>   *Exception: Prelude.undefined
11:43:54 <smithw> dmwit: what is the idiomatic way to parse arguments in Haskell? the case args of was the best I could come up with on my own
11:43:54 <ion> unamb? :-)
11:44:08 <smithw> (assuming that's what you're referring to by messy)
11:44:10 <ski> Hemite : btw, you're aware that there are `max' and `min' functions (taking two parameters), yes ?
11:44:13 <bgamari> smithw: cmdargs?
11:44:23 <hpaste> dmwit annotated “weekdays” with “weekdays (annotation)” at http://hpaste.org/65057#a65058
11:44:32 <ski> ion : well, i was thinking maybe some kind of improving interval type ..
11:44:40 <dmwit> smithw: Perhaps something like that would be a bit cleaner.
11:45:01 <smithw> dmwit: thank you very much for your help :)
11:45:31 <Hemite> ski: Yes, but I'm just reading introductory material which implements all the stl functions using different ways
11:45:54 <smithw> that's actually immensely clever
11:45:55 <Hemite> ski: aka using folds or lambda's and other ways
11:46:10 <dmwit> smithw: One more suggestion:
11:46:25 <zhulikas> > foldr1 max [1..10]
11:46:26 <lambdabot>   10
11:46:36 <dmwit> dateRange start finish = takeWhile (<= finish) . iterate (addDays 1) $ start
11:47:04 <dmwit> smithw: Optionally add back in a clause that does your "start < finish" sanity check.
11:47:54 <smithw> dmwit: thanks again, that does look a lot better
11:51:04 <otters> is there a float modulus somewhere in the haskell standard library
11:51:39 <ClaudiusMaximus> @index mod'
11:51:39 <lambdabot> bzzt
11:51:58 <ClaudiusMaximus> @hoogle mod'
11:51:58 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
11:51:58 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
11:52:54 <otters> > mod' 3.4 1
11:52:54 <lambdabot>   0.3999999999999999
11:52:59 <otters> > mod' (3.4 :: CReal) 1
11:53:00 <lambdabot>   *Exception: CReal.toRational
11:53:03 <otters> ok.
11:54:25 <monochrom> @type foldr
11:54:26 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:54:56 <dmwit> > fmod 3.4 1
11:54:57 <lambdabot>   Not in scope: `fmod'
11:55:06 <damowe> @type foldl'
11:55:07 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:55:39 <otters> so CReal doesn't respond to toRational
11:55:52 <ski> well, it's uncomputable
11:56:09 <ski> (but so is `(==)')
11:56:48 <otters> well I'm trying to figure out if it can be represented as an integer or not
11:56:50 <ski> (i guess `(/=)' is semi-computable and `(==)' is reverse semi-computable, or whatever it's called)
11:56:55 <otters> like 3.0 -> "3" but 3.1 -> "3.1"
11:57:08 <otters> i.e. in the Show instance
11:57:08 <ski> well, you can check whether it's near enough
11:57:28 <otters> how
11:57:34 <ski> e.g. if you're showing 40 decimals, you could check that upto those, it's integral
11:57:56 <otters> I see
11:58:03 <ski> hm .. at least i think it should be possible
11:58:40 <dmwit> CReal is basically forall x : Integer. Vec x Bit. You could plausibly change this implementation to something like exists size : Maybe Integer. forall x : Integer. Vec (maybeMin size x) Bit.
11:58:51 <dmwit> Then sometimes equality would be decidable.
11:59:11 <dmwit> And sometimes toRational would be decidable.
11:59:26 <dmwit> (In both cases: exactly when size was a Just.)
12:00:05 <honeybubbles> hello
12:00:15 <honeybubbles> i need some help
12:00:17 <parcs`> 932 people
12:00:27 <parcs`> jeez this channel is growing at like 15 people per day
12:00:43 <honeybubbles> im friken desperate lol
12:00:46 <rostayob> honeybubbles: just ask away
12:00:50 <ski> dmwit : hm, you're sure that's the representation ?
12:01:00 <dmwit> ski: Nope!
12:01:08 <ski> (modulo sign, of course)
12:01:21 <honeybubbles> how the hell do u get an apk out of a rar file?
12:01:28 <dmwit> ski: data CReal = CR (Int -> Integer)
12:01:33 <dmwit> ski: So, very nearly what I said, yes.
12:01:34 <mauke> honeybubbles: how is that a haskell question?
12:01:36 <roconnor> honeybubbles: try #haskell-blah
12:01:38 <honeybubbles> i downloaded it on my phone used andozip no apk inside
12:01:44 <rostayob> http://en.wikipedia.org/wiki/Constructivism_%28mathematics%29#Example_from_real_analysis
12:01:47 <monochrom> wrong channel. and I don't know how. and I don't know which other channel to ask.
12:01:50 <ski> dmwit : for a general computable real, it is impossible (in general) to determine the stream of decimals
12:02:03 <dmwit> ski: Absolutely.
12:02:07 <ski> dmwit : one could still determine large prefices of that stream in some cases, though
12:02:13 <honeybubbles> what is haskell-blah?
12:02:19 <honeybubbles> im new to this damn thing lol
12:02:21 <ski> honeybubbles : another IRC channel
12:02:22 <dmwit> ski: But when you're constructing the reals from expressions like "1 + 2", you can record as much information as you have.
12:02:27 <ion> CReal is basically a function from an exponent of two to an integer scaled by the 2^n IIRC.
12:02:29 <dmwit> ski: Sometimes you'll have to give up. But not always.
12:02:36 <scooty-puff> can data types, classes, and instances be defined using lambdabot?
12:02:40 <scooty-puff> in this irc
12:02:46 <dmwit> scooty-puff: no
12:02:53 <scooty-puff> k
12:02:57 <ski> dmwit : *nod*
12:02:59 <monochrom> lambdabot takes none of them
12:03:28 <roconnor> scooty-puff: though with Either, (,) (->) and Mu, you can go pretty far.
12:03:30 <monochrom> but you can try http://www.vex.net/~trebla/haskell/testbed.cgi
12:03:55 <scooty-puff> roconnor: k
12:04:04 <monochrom> although, by then you're better off with your own ghc
12:04:04 <ski> ion : ok, could work then
12:04:05 <hpaste> scooty-puff pasted “Succeeds” at http://hpaste.org/65059
12:04:13 <roconnor> @type Roll
12:04:14 <lambdabot> Not in scope: data constructor `Roll'
12:04:21 <roconnor> @type Mu
12:04:22 <lambdabot> Not in scope: data constructor `Mu'
12:04:24 <roconnor> :/
12:04:25 <hpaste> scooty-puff annotated “Succeeds” with “Fails” at http://hpaste.org/65059#a65060
12:04:25 <rostayob> @kind Mu
12:04:26 <ski> @type In
12:04:26 <lambdabot> (* -> *) -> *
12:04:26 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
12:04:31 <roconnor> ski: thanks
12:04:39 <ski> @type out
12:04:40 <lambdabot> forall (t :: * -> *). Mu t -> t (Mu t)
12:04:56 <scooty-puff> for some reason instance flag ~ False => Has<...> a flag succeeds where instance Has<...> a False doesn't
12:05:25 <scooty-puff> (btw, it looks like some of the use of oleg's TypeCast may now be provided by ~)
12:05:45 <Saizan> (should be all of them)
12:05:46 <ski> instance resolution doesn't take contraints on the instance declaration into account when searching for an applying instance
12:05:58 <ski> (though iiuc, works may be in progress of fixing that)
12:06:10 <scooty-puff> k
12:07:34 <scooty-puff> is there something unsafe - other than the general warnings about overlapping instances - that i'm doing here?
12:07:51 <scooty-puff> (worried about it breaking in later compilers, etc.)
12:07:55 <rasfar> \msg lambdabot
12:08:00 <rasfar> doh!
12:08:18 <ski> overlapping instances isn't really good, imo
12:08:28 <ski> (and incoherent instances is of course worse)
12:09:09 <scooty-puff> k - other than having a hidden super class, is it otherwise possible to ensure other instances aren't created?
12:09:17 <scooty-puff> to decrease some of the danger perhaps
12:10:07 <honeybubbles> is there a channel for askin questions only?
12:10:25 <dmwit> Classes are open. It's one of the fundamental choices made in the design of Haskell.
12:10:53 <scooty-puff> ok
12:11:06 * dmwit now has this comical picture of an IRC channel where people only ask questions, and anybody who answers one is kickbanned
12:11:34 <honeybubbles> jeez
12:11:50 <scooty-puff> "what is instance resolution doesn't take constraints on the instance declaration into account when searching for an applying instance?"
12:11:54 <scooty-puff> jeopardy style
12:11:56 <tgeeky> In Soviet Russia, answers question you!
12:12:12 <honeybubbles> lol
12:12:50 <honeybubbles> i just wanna know how to get a apk out of a rar when its not showing one thats all i want to know and i will leave u all in pleace
12:12:56 <honeybubbles> please im begging you
12:13:13 <dmwit> You might involuntarily leave us in peace long before you get your answer if you don't turn your topic towards programming in Haskell.
12:13:30 <mauke> honeybubbles: I have no idea what you're talking about
12:13:39 <Saizan> honeybubbles: this channel is about the Haskell programming language
12:14:09 <honeybubbles> thank u for explaning that i didnt know iv never tried theses channel thing thought they were just chat rooms
12:14:14 * ski gets the picture of an IRC channel for asking questions, and another one for answering them
12:14:18 <scooty-puff> honeybubbles:
12:14:19 <tgeeky> honeybubbles: tar -zxvf filename.rar > /dev/null
12:14:21 <scooty-puff> try: #android
12:14:21 <scooty-puff> #android-dev
12:14:21 <scooty-puff> #androidforums
12:14:36 <scooty-puff> honeybubbles: /join #android
12:14:51 <honeybubbles> thank you
12:14:52 <scooty-puff> if you're talking about what i think you are
12:15:10 <mauke> honeybubbles: for questions about the network itself, #freenode
12:17:30 <bgamari> s
12:25:13 <franco00> I am having problems compiling a simple program under linux
12:25:39 <franco00> on windows it worked, and now he can't fine modules though the files are all there
12:25:49 <mauke> what's the command you used? what's the error message?
12:25:59 <franco00> I am using ghc --make myfile.hs
12:26:12 <franco00> error is "could not find module 'formatstring'
12:26:33 <mauke> what's the actual error?
12:26:42 <dmwit> Please copy and paste the error instead of retyping it.
12:27:02 <franco00> wait, there is more
12:27:13 <dmwit> At a guess, though: file names and module names are case sensitive.
12:27:21 <monochrom> I do not believe "the files are all there" and I do not believe that it is sufficient even if true
12:27:28 <dmwit> franco00: If there is more than one or two lines, you can use hpaste.org.
12:28:23 <franco00> geez monochrom
12:28:50 <franco00> before pasting the error: if I run the same line from /media/DOCS (usb pen) it compiles :/
12:29:06 <mauke> the plot thickens
12:29:15 <franco00> I wrote that on a win machine
12:29:21 <franco00> so I was worried about encodings?
12:29:27 * dmwit repeats: file names and module names are case sensitive
12:30:23 <monochrom> clearly, new evidence supports my theory. some files are not "there"
12:30:33 <dmwit> monochrom++
12:30:48 <yaxu> yes it could be that the pen drive is a windows filesystem
12:30:55 <mauke> it's even likely
12:30:59 <franco00> unfortunately when I type ./readbook.o I get a 'permission denied'
12:31:00 <yaxu> which isn't case sensitive
12:31:00 <hpaste> scooty-puff pasted “For location info and error logging” at http://hpaste.org/65061
12:31:03 <mauke> fat32 is the "standard", I believe
12:31:14 <mauke> franco00: does that surprise you?
12:31:40 <monochrom> readbook.o is not an executable, and not meant to.
12:31:47 <franco00> err sorry
12:31:48 <yaxu> so when you copy the files elsewhere under linux, you then have to make sure the upper/lowercase module names etc are matched in the filenames
12:31:57 <franco00> i mean, ./test
12:32:03 <franco00> *meant
12:32:07 <franco00> yaxu: didn't know that, thanks
12:32:15 <yaxu> try chmod u+x test
12:32:31 <mauke> franco00: are you ignoring me?
12:32:37 <franco00> mauke: no!
12:32:47 <mauke> franco00: are you going to answer my question?
12:33:11 <franco00> mauke: what should/should not surprise me?
12:33:29 <mauke> franco00: no, the other question
12:33:57 <mauke> franco00: but the "surprise" thing was in response to <franco00> unfortunately when I type ./readbook.o I get a 'permission denied'
12:33:58 <td123> is there a way to reset ghci to a clean environment without quitting?
12:34:28 <geekosaur> how clean is clean?  :r does a lot of it
12:34:44 <geekosaur> but won't e.g. reset any flag changes
12:34:57 <monochrom> probably none. if you fork a thread in ghci and forget its ID, you can't kill it
12:35:30 <td123> geekosaur: like let bindings, imports
12:35:33 <franco00> ./test mauke , I corrected myself. In any case, the error is "bash: ./test: Permission denied". chmod u+x test leads me to the same error
12:35:58 <dmwit> td123: ":m" to clean imports
12:36:00 <mauke> franco00: what is ./test?
12:36:13 <geekosaur> check permissions on its interpreter (for an executable that'll be /lib/ld-linux.so or similar)
12:36:28 <franco00> the output of ghc -o test readbook.hs
12:36:52 <monochrom> on FAT, "chmod u+x" has no effect.
12:36:53 <mauke> franco00: is that on the pen drive?
12:36:56 <franco00> yes
12:37:02 <mauke> ...
12:37:03 <geekosaur> oh
12:37:19 <geekosaur> it's mounted noexec by default for security reasons
12:37:28 <franco00> I see
12:37:40 <franco00> thanks for the info
12:37:51 <geekosaur> you can force the mount flags with mount -o remount,exec or you can copy it to the local disk
12:38:06 <geekosaur> (sudo required for the remount, again security reasons)
12:38:29 <mauke> geekosaur: will that make a difference?
12:38:39 <franco00> hypens will!
12:40:15 <nand`> An AST I have loaded uses about 130 MB of memory; but dumping the output of “show myAst” to a file results in a file 3 MB large (and that's with string expansion, and all). Why does the AST consume so much memory?
12:41:05 <nand`> the AST in question is the output of listAllInfo in Network.MPD (libmpd)
12:41:19 <latros> why can I do this:
12:41:21 <mroman> I need some binary tree through which I can travel in all directions.
12:41:28 <geekosaur> the "noexec" mount flag, which most linuxes automatically set for removabe media such as pen drives, prevents programs from running directly off the drive.  "sudo mount -o remount,exec /path/to/mountpoint" will change it for the current mount (but not future ones)
12:41:30 <latros> instance Floating a => Num (Uncert a) where
12:41:43 <Saizan> nand`: tried deepseq'ing it?
12:41:55 <mroman> I.e I need to be able to travel from every node to its parent node
12:42:00 <latros> (:+-) x ex + (:+-) y ey = <thing involving + with x, ex, y, and ez>
12:42:16 <mroman> Is there some library which provides such functionality?
12:42:32 <nand`> Saizan: I'll try; what I was doing now was simply outputting it to stdout, waiting for a keypress, then outputting it again (so it can't get GC'd)
12:42:35 <franco00> yaxu: file casing it was, lesson learned! Thanks again
12:42:40 <mauke> mroman: some kind of zipper?
12:42:42 <latros> I've only put Floating a in the typeclass restrictions, and yet I somehow am guaranteed to have + in the a type
12:42:45 <mroman> Preferably without IO, but I assume that ain't possible.
12:42:46 <nand`> but it's certainly possible that the thunks get reduced twice in this case
12:42:46 <rasfar> yeah mroman, I'm looking forward to hearing the suggestions
12:42:48 <latros> even though technically Floating is not a subclass of Num
12:43:02 <Saizan> nand`: well no
12:43:08 <monochrom> algebraic data types can take a lot of memory to store. for example "Ctor x y z" takes 4 words or more. 1 word means 32 bits or 64 bits.
12:43:16 <rasfar> there's the pez package if you have record labels...
12:43:20 <mauke> latros: yes, it is
12:43:25 <latros> wait what
12:43:32 <latros> but...haskell doesn't have subclassing at all
12:43:37 <latros> how can that work
12:44:03 <mroman> mauke: Not sure what you mean by "kind of zipper".
12:44:11 <latros> I know every Floating is *supposed* to be a Num, but I was sure that that was just like every Monad is *supposed* to be a Functor
12:44:23 <geekosaur> latros, Floating a implies Num a, to the extent that if the instance is selected, the Floating a instance brings the Num instance into scope
12:44:27 <mroman> but given I have a node I must be able to get
12:44:34 <latros> how does it do that
12:44:34 <Saizan> nand`: GHC should evaluate it only once, so the heap profiler doesn't show any reduction in heap size after the first print?
12:44:35 <rasfar> mroman: you could check out http://learnyouahaskell.com/zippers also
12:44:37 <mroman> a.) the node on the other side
12:44:39 <geekosaur> it;s not the same as subclassing but can behave similarly *once* the instance has been selected
12:44:40 <mroman> b.) the parent node
12:44:58 <andares> does >>= have precedence greater than ->?
12:44:59 <latros> what would happen if I made a Floating instance that wasn't a Num instance
12:45:03 <mroman> A can be achieved by b, ouf course.
12:45:17 <geekosaur> error when making it a Floating instance
12:45:17 <rostayob> andares: >>= is a function. -> is a type constructor, and a special one
12:45:18 <Saizan> latros: you can't
12:45:18 <copumpkin> andares: -> isn't an operator
12:45:24 <latros> how did they set it up so that you can't?
12:45:30 <geekosaur> because Floating is:  class Num a => Floating a where ...
12:45:34 <Saizan> latros: Num is an indirect superclass of Floating
12:45:40 <latros> um
12:45:42 <mauke> geekosaur: Fractional actually
12:45:47 <latros> I thought you couldn't do that
12:45:50 <geekosaur> yeh, indirectly
12:45:51 <rasfar> c'mon folks, mroman's question is rather important in general don't you think?
12:45:53 <latros> because then the instance head is no smaller
12:45:56 <latros> or something similar
12:46:02 <nand`> Saizan: I'm using htop to monitor memory usage, not the haskell profiler
12:46:05 <mauke> latros: it's not an instance
12:46:11 <latros> what
12:46:15 <andares> so [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch) is equivalent to [1,2] >>= (\n -> (['a','b'] >>= (\ch -> return (n,ch))))?
12:46:15 <mauke> latros: it's not an instance
12:46:20 <andares> or is it left-associative?
12:46:21 <latros> oh, it's not in the instance declaration
12:46:38 <Saizan> nand`: i don't think a GHC executable will ever return memory to the OS, unless they fixed this recently
12:46:45 <latros> so you can do that in class declarations?
12:46:56 <rasfar> anyhow mroman, definitely give that url I posted a look; there's no easy "non-generic" way so far as I know...
12:46:56 <geekosaur> yes
12:47:04 <nand`> Saizan: I heard it is fixed now
12:47:12 <mroman> Why is this called a "zipper"?
12:47:14 <latros> then why can't you do that to create a Monad'-Applicative'-Functor' with a proper hierarchy?
12:47:14 <rasfar> except maybe to not use a tree
12:47:16 <nand`> Using 7.4.1 to build btw
12:47:43 <mroman> also reconstructing a whole tree just to change one node is a bit expensive.
12:47:48 <latros> that is, what would stop you from doing
12:47:50 <rasfar> i'm actually not quite sure myself -- but, if you "zip" two trees together, you can achieve similar navigability, maybe that's why
12:47:51 <Saizan> andares: yes, it's equivalent to that, also because you wouldn't have n in scope in (n,ch) otherwise
12:47:53 <latros> class Functor' f where ...
12:48:01 <latros> class Functor' f => Applicative' f where ...
12:48:11 <latros> class (Functor' m, Applicative' m) => Monad' m where ...
12:48:11 <mauke> mroman: it's not the whole tree
12:48:15 <rasfar> you only have to reconstruct the lineal path to root
12:48:16 <latros> can you do that?
12:48:44 <Saizan> latros: sure
12:48:46 <geekosaur> re "zipper", because it behaves a bit like a physical zipper (picture it as the zipper "head" moving along the structure like zipping and unzipping an article of clothing or etc.  you can step the zipper head in either direction
12:48:52 <latros> seriously.
12:48:54 <rasfar> but moving from a node to its parent is not easy
12:49:02 <latros> huh
12:49:03 <latros> thanks then
12:49:30 <geekosaur> re functor/applicative/monad, the issue is not that it can't be domne, it's that it wasn't done initially and retrofitting it in now will break stuff that has declared it manually or etc
12:49:55 <latros> ah yes
12:50:03 <latros> because sometimes it's better to define it backwards
12:50:04 <rasfar> the zipper metaphor comes from operations on list types
12:50:06 <mroman> I can keep track of the current selected node with those direction breadcrumbs
12:50:07 <geekosaur> (couldn't have been done initially as Applicative didn't exist)
12:50:12 <mroman> That works.
12:50:15 <latros> and with the constraint at class level you're forbidden
12:50:16 <mroman> Thanks for the link.
12:50:16 <latros> to do that
12:50:23 <mauke> latros: not really
12:50:24 <rasfar> you're welcome mroman
12:50:32 <latros> how not really?
12:50:54 <andares> hey kallisti, you're not still around by any chance are you?
12:50:54 <mauke> latros: you could insert a boilerplate definition of instance Functor X where fmap = liftM; instance Applicative X where pure = return; (<*>) = ap
12:51:04 <latros> but that's not subclassing
12:51:06 <latros> that's templates
12:51:14 <mauke> how is that templates?
12:51:32 <latros> if you try to do it globally you will need UndecidableInstances
12:51:42 <mauke> no, I don't
12:51:46 <latros> I've tried it
12:51:46 <mauke> and all instances are global
12:51:49 <latros> write this
12:51:55 <latros> instance Monad m => Functor m where fmap = liftM
12:51:58 <mauke> no
12:51:59 <latros> try to compile it
12:52:00 <latros> it will fail
12:52:06 <mauke> that's why I won't do that
12:52:15 <latros> then it isn't subclassing, and you're just using a template
12:52:26 <mauke> I have no idea what you're talking about
12:52:48 <latros> you're not actually achieving subclassing by writing up a boilerplate definition when you retrofit
12:53:04 <monochrom> I don't know why subclassing is brought up.
12:53:07 <mauke> nope, still not making sense
12:53:19 <latros> subclassing is pretty much where I started from in this discussion
12:53:21 <monochrom> but if you say it's a lot of boilerplate, sure.
12:53:42 <latros> since *at class level* Floating is apparently a subclass of Num
12:53:46 <dmwit> latros: I haven't read any of this conversation except your last statement, but I'm pretty sure that nobody is claiming Haskell has OO-style subclassing.
12:53:53 <andares> hey, what's the best data structure to use for a 2D array?
12:53:59 <latros> I know, dmwit
12:54:03 <latros> I meant typeclass subclassing
12:54:04 <dmwit> latros: The term "subclass" means something different in Haskell than in Java.
12:54:09 <latros> I know
12:54:11 <tgeeky> andares: [[]]?
12:54:20 <monochrom> the correct direction is "class Functor m" and then "class (Functor m) => Monad m", but it was not done, and it is too late to do now
12:54:23 <mauke> latros: then why are you talking about "achieving subclassing"?
12:54:24 <Saizan> yes, making instances you don't make sublasses
12:54:26 <tgeeky> andares: array? Array of Vector
12:54:32 <andares> tgeeky: well, I'm trying to navigate horizontally/vertically/diagonally in it so I thought it would be ugly.
12:54:33 <latros> I'm talking about achieving typeclass subclassing
12:54:41 <mauke> latros: that means nothing
12:54:45 <latros> sure it does
12:54:50 <tgeeky> andares: a 2D array is a matrix, right?
12:54:51 <latros> one interface provides another
12:54:53 <latros> simple
12:54:58 <mauke> what
12:55:12 <latros> the Monad interface conceptually provides a Functor interface
12:55:18 <andares> yup.
12:55:21 <latros> consequently Monad is a subclass of Functor
12:55:35 <tgeeky> andares: http://hackage.haskell.org/package/hmatrix-0.13.1.0 ?
12:55:38 <Saizan> latros: yes, it's true that we have to modify the Monad class to make functor a subclass of it
12:55:42 <mauke> latros: no
12:55:42 <latros> yes
12:56:03 <nand`> Saizan: other way round
12:56:08 <latros> I'm not saying that the actual Monad class in haskell is a subclass of Functor, the fact that it isn't is basically what sparked this whole thing
12:56:15 <mauke> latros: no
12:56:20 <latros> what
12:56:23 <mauke> latros: you have weird ideas about what "subclass" means
12:56:33 <Saizan> nand`: no, this way around
12:56:34 <latros> no, this isn't a new idea, mauze
12:56:36 <latros> *mauke
12:56:42 <nand`> Saizan: then we're using vastly different definitions of the term “subclass”
12:56:55 <nand`> Most likely, you're correct
12:56:57 <mauke> latros: I didn't say it was new. I said it was weird
12:57:03 <latros> it's not that weird, either
12:57:05 <Saizan> nand`: uh, no you're right, Functor would be the superclass
12:57:12 <andares> tgeeky: hm, I might use that. thanks.
12:57:13 <latros> cf. various articles on Monad-Applicative-Functor hierarchy
12:57:20 <mauke> latros: it's not the definition haskell uses
12:57:25 <nand`> Saizan: then we are in accord
12:57:31 <latros> haskell doesn't use subclassing in general
12:57:39 <mauke> yes, it does
12:57:41 <latros> esp not OO style subclassing
12:57:43 <latros> what
12:57:53 <mauke> the Prelude is full of subclasses
12:57:54 <latros> in what sense are you saying haskell uses subclassing
12:58:03 <latros> subtypeclasses?
12:58:06 <mauke> yes
12:58:11 <latros> then we're talking about the same thing
12:58:12 <mauke> the only classes haskell has
12:58:27 <latros> somehow we've had a failure of communication because that's exactly what I was talking about
12:58:33 <mauke> no, it isn't
12:58:38 <latros> how is it different?
12:58:53 <mauke> I don't know but you keep talking about "achieving subclassing"
12:58:59 <geekosaur> is this where someone offers a reminder that typeclasses are not OO-style classes and thinking about them as such will get you into trouble fairly quickly?
12:59:11 <Saizan> mauke: how do you know that it's not it then?
12:59:21 <latros> it's not different, mauke
12:59:25 <dmwit> geekosaur: I think I did that a few minutes ago.
12:59:26 <latros> I just phrased it poorly earlier
12:59:32 <mauke> Saizan: because there's nothing to achieve, you simply do 'class Super a => Sub a'
12:59:56 <latros> yes, I was saying that what doesn't achieve subclassing is general *instance* declarations
13:00:19 <latros> which don't work because their ability to be overriden causes UndecidableInstances to be required
13:00:22 <nand`> latros: then that's not subclassing, the terminology is already used
13:00:27 <nand`> subinstancing maybe?
13:00:33 <mauke> latros: no, instances can't change the class hierarchy
13:00:51 <latros> <mauke> latros: you could insert a boilerplate definition of instance Functor X where fmap = liftM; instance Applicative X where pure = return; (<*>) = ap
13:00:51 <latros> <latros> but that's not subclassing
13:00:51 <latros> <latros> that's templates
13:00:51 <latros> <mauke> how is that templates?
13:01:01 <latros> is what drove this whole thing
13:01:10 <latros> which is a pointless discussion because we both know what's going on
13:01:17 <copumpkin> I agree
13:01:33 <mauke> I'm not sure you know what's going on
13:01:34 <Saizan> latros: those instances weren't supposed to show that you could make Applicative a superclass of Monad that way
13:01:44 <latros> I know, which was my whole point
13:01:56 <latros> doing that doesn't actually achieve what I wanted, which I didn't until earlier realize you could do at class level
13:01:57 <monochrom> @quote monochrom debates
13:01:57 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
13:02:07 <andares> there doesn't seem to be a way to do project euler 11 prettily. :/
13:02:24 <latros> however, with TH
13:02:25 <Saizan> latros: they were meant to show that it's still easy to make an instance of Monad even if you had Functor and Applicative superclasses
13:02:29 <latros> it actually does
13:02:32 <mauke> context: <latros> because sometimes it's better to define it backwards  <latros> and with the constraint at class level you're forbidden  <mauke> latros: not really
13:02:49 <latros> if the constraint were at class level, could you do that?
13:02:54 <mauke> YES
13:02:57 <Saizan> latros: yes
13:02:59 <mauke> WHICH WAS MY WHOLE POINT
13:02:59 <latros> oh?
13:03:07 <latros> how
13:03:12 <latros> wouldn't that result in some cyclic issue?
13:03:16 <Saizan> no
13:03:20 <franco00> relax mauke , it's teh internet :)
13:03:21 <latros> how?
13:03:22 <mauke> <mauke> latros: you could insert a boilerplate definition of instance Functor X where fmap = liftM; instance Applicative X where pure = return; (<*>) = ap
13:03:43 <kallisti> andares: hello
13:03:43 <latros> yeah, but does that work when the Monad class declaration looks like
13:03:45 <blackdog> i'm trying to profile a server program. this is a bit tricky, because i have to control-c it to get it to stop, and if i do that i get an empty .prof file.
13:03:48 <Saizan> latros: you can just make instances in any order
13:03:50 <latros> class Functor m => Monad m where
13:03:53 <geekosaur> latros, it doesn;t
13:03:59 <blackdog> i've tried installing a signal handler for sigINT, but it doesn't seem to have helped.
13:04:01 <Saizan> latros: they get checked module-wise
13:04:04 <mauke> latros: <mauke> YES  <mauke> WHICH WAS MY WHOLE POINT
13:04:05 <blackdog> any ideas?
13:04:13 <geekosaur> that's the point, those classes are missing ccurrently, mauke's telling you how to "add" them fpr a specific instance
13:04:16 <andares> hey kallisti. I'm still kind of disoriented trying to solve that problem, so I was wondering how you navigated in the list of numbers.
13:04:47 <latros> I know how to add them given what's there now, what's new to me is that if the restriction existed at class level, you could still define things in reverse order
13:05:07 <latros> I suppose this is similar to how default typeclass implementations can be mutually recursive
13:05:14 <Saizan> latros: right, we understand you didn't know it worked, but it just works
13:05:35 <latros> now I'm seeing why I was thrown off; now how does that work?
13:05:42 <cizra> Hi guys and gals! http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:TextEncoding mentions the char8 text encoding, which is not present in my GHC )=
13:05:49 <cizra> What might be the trouble?
13:06:00 <latros> it seems like you're being required to have a Functor instance to create a Monad instance but are creating the Functor instance using the Monad instance
13:06:01 <cizra> I guess I could use binary instead, but I'm scared of pointers )=
13:06:13 <geekosaur> *sigh*
13:06:21 <geekosaur> no, Monad does not imply Functor
13:06:21 <kallisti> andares: want to see the code?
13:06:30 <andares> kallisti: ah, sure. thanks!
13:06:30 <mauke> geekosaur: what are *you* talking about?
13:06:31 <geekosaur> it "should" but for historical reasons it does not
13:06:34 <latros> not in the implementation, but conceptually it does
13:06:46 <latros> I know, geekosaur, if you've been following this is in the context of doing it all over again
13:06:55 <Saizan> latros: it's just like how you can define mutually recursive functions as long as you have cases where the recusion stops
13:07:19 <latros> this just seems sketchy because it's mutual recursion at type constraint level
13:07:34 <latros> not really sketchy, just weird
13:07:56 <latros> the Functor instance is needed for the Monad instance which provides the Functor instance
13:08:11 <Saizan> if you write down the instances you'll see there's no mutuality at the constraint level
13:08:12 <latros> which means the instantiations can't be performed by the compiler in order
13:08:21 <latros> hm, that's true
13:08:55 <latros> rather, there's a Monad declaration of something that doesn't have a Functor declaration until the Monad declaration has been instantiated
13:08:59 <latros> er
13:09:04 <latros> handled, or what have you
13:09:09 <mauke> data A = A B; data B = B A
13:09:13 <latros> my knowledge of GHC internals is somewhat limited
13:10:02 <hpaste> “_Mikey” pasted “wxHaskell” at http://hpaste.org/65062
13:10:16 <latros> in other words, I'm trying to grasp the procedure that the compiler would use to set this up; would it set up the constraint dependency graph and the function definition dependency graph, determine what nodes have been provided, and then trace out the two graphs?
13:10:18 <Saizan> (anyhow GHC handles all sorts of circularity for instances)
13:10:21 <_Mikey> Does a anyone know where I might be going wrong here?
13:11:01 <latros> specifically, Monad -> ((>>=),return) -> liftM -> fmap -> Functor -> Monad
13:11:36 <latros> and hence by reading in the second node it can complete the cycle and hence allows the instance to exist
13:12:02 <latros> what's then weird to me is that if you commented out the default Functor implementation you would actually fail to get a Monad implementation, even though it could read that second node
13:12:34 <latros> (not really weird in a way that can be explained, since I understand that that's what happens, it just almost seems like magic that it does)
13:12:48 <Saizan> latros: that seems wrong
13:13:03 <latros> the arrows mean different things, I admit
13:13:18 <latros> specifically the Functor -> Monad arrow is "is required by" unlike all the others
13:13:23 <Saizan> latros: instance Functor Foo where {} is a fine instance for Functor
13:13:36 <latros> huh?
13:13:59 <Saizan> it just means that you'll have fmap = undefined
13:14:01 <hpaste> Kallisti pasted “Project Euler Problem 11 (SPOILERS)” at http://hpaste.org/65063
13:14:11 <latros> oh
13:14:12 <kallisti> andares: I think I got all the relevant imports. I may have a missed a few modules.
13:14:13 <latros> ohhhhhhhhh
13:14:17 <latros> now I see how it does it
13:14:37 <Saizan> latros: no, it doesn't have an empty instance for functor first and then fills it
13:14:44 <latros> aw
13:14:53 <kallisti> andares: ^
13:15:07 <andares> huh, interesting. I don't know about half of these :p
13:15:33 <Saizan> latros: what you're getting wrong is the idea that GHC has to evaluate the code to compile it, while that's no need for it, so it doesn't have to chase the recursive calls at compile time
13:15:35 <kallisti> andares: well at is a simple indexing function that lets you index the array by a 2-tuple.
13:15:46 <kallisti> andares: it also returns a Maybe so that an out-of-bounds index returns Nothing.
13:15:55 <Saizan> latros: it just makes them point to each other
13:15:57 <andares> what is this *** business?
13:16:01 <rwbarton> you can just use a two-dimensional array...
13:16:09 <kallisti> > succ *** pred $ (2,2)
13:16:10 <lambdabot>   (3,1)
13:16:15 <kallisti> > succ *** pred $ (100,2)
13:16:16 <lambdabot>   (101,1)
13:16:17 <c_wraith> *** is just a function
13:17:01 <nand`> :t (***)
13:17:01 <kallisti> andares: vert, horiz, majDiag, minDiag  are all functions on tuples.
13:17:02 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:17:08 <latros> ah, ok, that makes even more sense then
13:17:11 <latros> @ saizan
13:17:42 <nand`> without all the arrow cruft that's basically :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)  for functions
13:17:44 <andares> ohh, I see. that's interesting.
13:17:49 <kallisti> andares: given a tuple they produce the "next" one in a straight line. vert does a vertical line, horiz, does a horizontal line. etc.
13:18:27 <kallisti> andares: I iterate those functions infintely, chop off the infinite sequence at 4 elements, then apply the indexing function to each of the tuples.
13:18:58 <kallisti> > mapM (+1)  [Just 2, Just 3, Just 4]
13:18:59 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
13:18:59 <lambdabot>    arising from a use of...
13:19:03 <kallisti> er..
13:19:27 <kallisti> > mapM (return.(+1))  [Just 2, Just 3, Just 4]
13:19:28 <lambdabot>   No instance for (GHC.Show.Show (m [Data.Maybe.Maybe t]))
13:19:29 <lambdabot>    arising from a ...
13:19:36 <latros> you went the wrong way
13:19:51 <latros> > mapM (fmap (+1)) [Just 2,Just 3,Just 4]
13:19:52 <lambdabot>   Just [3,4,5]
13:20:04 <kallisti> ah there we go.
13:20:04 <andares> kallisti: and ! is like !!?
13:20:08 <kallisti> andares: yep
13:20:11 <dmwit> > mapM (return.(+1)) [2,3,4]
13:20:12 <kallisti> but less dangerous. ;)
13:20:12 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
13:20:12 <lambdabot>    arising from a use of `M16211948...
13:20:18 <kallisti> thus the fewer exclaimation points, you see.
13:20:19 <dmwit> > mapM (return.(+1)) [2,3,4] :: Maybe [Int]
13:20:21 <lambdabot>   Just [3,4,5]
13:20:21 <kallisti> causes less alarm.
13:20:27 <andares> kallisti: part of the control.arrow package? my ghc doesn't seem to know it.
13:20:36 <kallisti> andares: yes Control.Arrow
13:20:52 <kallisti> andares: you should have it by default.
13:21:05 <andares> I have it, it just wasn't imported apparently.
13:21:12 <kallisti> yes you have to do that explicitly.
13:21:16 <Franciman> hi all, a question, why in interactive mode if I do : (Just a) = Nothing, I don't get any error?
13:21:23 <Franciman> the same with (x:xs) = []
13:22:00 <kallisti> andares: mapMaybe is like map except the function you pass to it returns a Maybe. if the Maybe is Nothing then it's skipped in the output list.
13:22:07 <monochrom> because those are treated lazily
13:22:14 <kallisti> > mapMaybe (\x -> if x == 1 then Nothing else Just x) [1,2,3,4,5,6,7]
13:22:15 <lambdabot>   [2,3,4,5,6,7]
13:22:24 <kallisti> andares: it's kind of like combining map and filter into one function.
13:22:33 <andares> ah, I see.
13:23:10 <andares> I don't think ! is in Control.Arrow. no mention of it on the doc page.
13:23:11 <t7> rostayob: can you help me with something quickly?
13:23:15 <kallisti> andares: Control.Arrow
13:23:18 <kallisti> import all the things I import.
13:23:22 <kallisti> er
13:23:23 <dmwit> List comprehensions seem nicer to me than mapMaybe.
13:23:24 <kallisti> Data.Array
13:23:25 <latros> ! is in Data.Array
13:23:27 <andares> oh, right
13:23:30 <Franciman> monochrom, ah ok thank you for the explaination
13:23:39 <kallisti> dmwit: I can't be as pointless with list comprehensions though. :P
13:23:58 <latros> mapMaybe f = filter (isJust) . map f, yes?
13:24:00 <latros> eh
13:24:03 <latros> redundant parens
13:24:04 <kallisti> not quite
13:24:10 <latros> er yeah
13:24:11 <latros> nvm
13:24:12 <kallisti> it removes the Maybe layer as well.
13:24:16 <latros> map unJust . filter isJust . map f
13:24:19 <latros> ugly
13:24:20 <kallisti> fromJust, yes.
13:24:24 <latros> ah yeah
13:24:25 <latros> woops
13:24:40 <dmwit> mapMaybe f xs = xs >>= maybe [] return . f
13:24:43 <ion> catMaybes . map f?
13:24:50 <kallisti> also those.
13:25:05 <kallisti> except that I believe catMaybes is implemented from mapMaybe.
13:25:05 <latros> depends on what you consider primitive I suppose
13:25:14 <dmwit> ?src mapMaybe
13:25:14 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:25:37 <kallisti> catMaybes = mapMaybe id
13:25:43 <ion> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Maybe.html#catMaybes
13:25:59 <kallisti> ah nevermind.
13:26:02 <kallisti> they're implemented seperately of each other.
13:26:26 <rostayob> t7: not now, maybe later
13:26:36 <kallisti> andares: can you kind of follow my program now?
13:26:40 <t7> aww
13:27:05 <andares> kallisti: yep. I'm glad you showed me the source though, I didn't know most of this stuff before so it probably would have taken me hours.
13:27:32 <kallisti> cool.
13:27:40 <rostayob> t7: coursework deadline in 2 hrs :P
13:27:50 <kallisti> andares: did you know about liftM2 (,) x y
13:27:53 <kallisti> for cartesian products.
13:28:15 <kallisti> applicative style works as well.
13:28:46 <kallisti> > (,) <$> [1..3] <*> [1..3]
13:28:46 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
13:28:54 <andares> nope. I'd learned a little about applicative style though.
13:29:12 <kallisti> the above is equivalent to liftM2 (,) [1..3] [1..3]
13:29:13 <kallisti> except
13:29:20 <kallisti> that one uses the Monad instance and one uses the Applicative instance.
13:30:14 * hackagebot category-extras 1.0.1 - A meta-package documenting various packages inspired by category theory  http://hackage.haskell.org/package/category-extras-1.0.1 (DanielWagner)
13:30:36 <andares> kallisti: so does liftM2 use >>= internally to lift the values out of the list monad?
13:30:41 <latros> yes
13:30:49 <kallisti> yes it has to
13:31:01 <kallisti> because that's the only thing it knows about the value you've given it.
13:31:04 <kallisti> is that it's an instance of Monad.
13:31:13 <kallisti> so it can only use functions defined over any Monad.
13:31:15 <andares> ah, so it probably just uses the trick of layering two >>=.
13:31:23 <kallisti> @src liftM2
13:31:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:31:24 <andares> I see.
13:31:37 <kallisti> @@ @undo @src liftM2
13:31:37 <lambdabot>  ()
13:31:39 <kallisti> er
13:31:46 <kallisti> @undo do { x1 <- m1; x2 <- m2; return  (f x1 x2) }
13:31:47 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
13:32:00 <andares> what's @undo?
13:32:14 <kallisti> deconstructs do notation into >>= >> and return
13:32:16 <monochrom> it translates do to >>=
13:32:18 <t7> SML foldl takes args in a different order to haskell?
13:32:29 <andares> so <- is just syntactic sugar that's part of the do notation?
13:32:33 <kallisti> yep.
13:32:34 <latros> yup
13:32:38 <andares> awesome!
13:32:42 <latros> all of do notation is just sugar
13:33:00 <latros> a LOT of haskell is just sugar actually >.>
13:33:01 <monochrom> @quote dodo
13:33:01 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
13:33:12 <kallisti> > do do do do do do do do 2
13:33:13 <lambdabot>   2
13:33:27 <monochrom> deep dodo :)
13:33:31 <andares> hehe
13:33:32 <kallisti> > let in let in let in let in let in do do do do 2
13:33:33 <lambdabot>   2
13:33:37 <nlogax> is that why it's so damn sweet?
13:33:47 <andares> I think my brain is diabetic..
13:33:52 <monochrom> everyone loves sugar!
13:34:17 <kallisti> andares: also, did you know that.
13:34:28 <kallisti> er, well, do you know what join does?
13:34:34 <kallisti> :t join
13:34:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:34:46 <kallisti> > join (Just (Just 2))
13:34:47 <lambdabot>   Just 2
13:35:00 <kallisti> > join [[2,3],[4,5],[6,7]]
13:35:01 <lambdabot>   [2,3,4,5,6,7]
13:35:13 <andares> @src concat
13:35:13 <lambdabot> concat = foldr (++) []
13:35:21 <andares> okay, not as linked as I thought.
13:35:21 <kallisti> @src join
13:35:22 <lambdabot> join x =  x >>= id
13:35:29 <kallisti> it's equivalent for the list monad
13:35:32 <kallisti> however join works on any monad.
13:35:39 <kallisti> it's the equivalent of "concat" for other monads.
13:35:48 <andares> huh, why does concat exist then?
13:35:51 <kallisti> you'll notice they have the same type, except that one is generalized to monads and one is specifically  for lists.
13:36:00 <kallisti> andares: to assist newcomers such as yourself, most likely.
13:36:14 <andares> :) can't argue with that.
13:36:14 <kallisti> and, well, I use concat anyway.
13:36:25 <kallisti> because it's more clear that you're talking about specifically lists
13:36:26 <latros> a lot of the time it's not actually all that clear to use the polymorphic function
13:36:28 <kallisti> sometimes you can be too general.
13:36:51 <latros> in monad transformers for example you can technically get horrible things that look roughly like "return = return . return"
13:37:07 <nand`> because sometimes the type is ambiguous when using join instead of concat
13:37:08 <latros> I think MaybeT's return is actually "return = return . Just . return"?
13:37:30 <latros> @src MaybeT
13:37:30 <lambdabot> Source not found. I feel much better now.
13:37:32 <latros> :(
13:37:38 <Zamarok> I'm trying to upgrade GHC (Arch Linux), but I keep getting this: failed retrieving file 'haskell.db' from andromeda.kiwilight.com : couldn't connect to host
13:37:41 <Zamarok> anyone know why?
13:37:42 <dmwit> Unlikely. Just is return.
13:37:49 <kallisti> andares: so, an interesting thing about monads is that the following law always holds:
13:37:57 <kallisti> join (fmap f m) = m >>= f
13:37:58 <dmwit> Zamarok: Perhaps you're using a bad mirror list.
13:38:12 <Zamarok> I'll check
13:38:17 <kallisti> andares: if  you plug join and fmap for the list monad you can see a familiar example.
13:38:52 <kallisti> for lists: fmap = map; join = concat; (>>=) = flip concatMap
13:39:09 <latros> when you cut out the cruft, return = MaybeT . fmap Just . return, apparently
13:39:22 <latros> which you could also write as
13:39:22 <nand`> (++) = mappend
13:39:25 <andares> er.. processing, one second
13:39:30 <latros> return = MaybeT . fmap return . return
13:39:34 <latros> which is just horrible
13:39:48 <kallisti> latros: it's just a polymorphic function, what's the problem? :P
13:40:06 <latros> the problem is going through and manually typechecking and figuring out what return is what :p
13:40:13 <latros> the last one can't be helped
13:40:34 <latros> you have to use the other monad's return, that's just how it goes
13:40:44 <andares> kallisti: I don't see why you need the join in the (fmap f m) above. won't it already be contained in m's context and no further?
13:41:03 <kallisti> andares: well, if you didn't have the join they wouldnn't be equivalent
13:41:06 <kallisti> fmap is not >>=
13:41:26 <latros> fmap f m, when m and f have the type of the arguments of >>=
13:41:30 <latros> is m (m a)
13:41:32 <latros> er
13:41:34 <latros> m (m b)
13:41:35 <latros> not m b
13:41:45 <kallisti> yes, the context should have been clear that I was talking about monads
13:41:47 <kallisti> and all monads are functors.
13:41:58 <kallisti> (the reverse is not true. not all functors are monads)
13:42:07 <andares> :t fmap
13:42:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:42:16 <kallisti> andares: fmap = (<$>)
13:42:24 <kallisti> you said you were familiar with applicative style
13:42:31 <kallisti> well:  (<$>) = fmap
13:42:39 <andares> sorry, I read through applicative style, functors and monads 30 minutes ago. taking a while to absorb.
13:42:40 <hughfdjackson> ^^ finally, i have found my first (pointless, but fun) haskell project :p
13:42:41 <kallisti> <$> is a synonym for fmap, which is the actual Functor method.
13:43:02 <hughfdjackson> a rehashed, prelude-only json parser (ignoring the existence of jsonParse
13:43:09 <kallisti> andares: it's easier to use a familiar example. for this particular thing the list monad is really good
13:43:39 <kallisti> > fmap (\x -> [x,-x]) [1..]
13:43:40 <lambdabot>   [[1,-1],[2,-2],[3,-3],[4,-4],[5,-5],[6,-6],[7,-7],[8,-8],[9,-9],[10,-10],[1...
13:43:47 <kallisti> > concat $ fmap (\x -> [x,-x]) [1..]
13:43:48 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
13:43:48 <vodik> > (+1) <$> [1, 2, 3, 4, 5]
13:43:49 <lambdabot>   [2,3,4,5,6]
13:44:09 <latros> this may cloud the issue, but
13:44:12 <kallisti> > [1..] >>= (\x -> [x,-x])
13:44:13 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
13:44:14 <latros> if you understand >>= more than fmap
13:44:29 <nand`> > map ((,) <$> abs <*> negate . abs) [1, 2, -5, 7, 9]
13:44:30 <latros> fmap f m = m >>= (return . f)
13:44:31 <lambdabot>   [(1,-1),(2,-2),(5,-5),(7,-7),(9,-9)]
13:44:32 <andares> ohhhh, f : a -> m b
13:44:37 <andares> I get it. I was thinking of f : a -> b
13:44:50 <latros> b is a type variable, so it can be m c :p
13:45:57 <andares> arrows look.. interesting.
13:46:05 <kallisti> andares: also   m >>= return . f = fmap f m
13:46:11 <kallisti> this one should be easier to follow.
13:46:19 <latros> (I actually just said that one)
13:46:23 <kallisti> oh.
13:46:25 <nand`> I mainly use arrows so I can mix (>>>) and (>>=). Unfortunately, I can't mix (>>>) and (>>=)
13:46:41 <kallisti> >>> is from Control.Category as well.
13:46:43 <aluink> does this instance seem reasonable? http://hpaste.org/65065
13:46:49 <kallisti> and you can, just use parenthesis. :P
13:46:55 <nand`> kallisti: I know :P but that's just as ugly
13:47:00 <nand`> I just end up using . and =<<
13:47:01 <kallisti> parentheses aren't ugly.
13:47:42 <nand`> mixing >>> and >>= (without arrows) though would be a nice way to confuse C++ programmers, make them think IO works like streams
13:47:49 <kallisti> nand`: http://sprunge.us/cURe?haskell  here's a cat program I wrote using >>= and >>> style. I think it looks nice.
13:47:53 <kallisti> it reads from left to right.
13:47:59 <kallisti> unlike >>= and . which changes directions.
13:48:25 <nand`> kallisti: (>>>) should just really have the same or similar fixivity as (.) in my opinion
13:48:45 <kallisti> maybe not the same, but greater than >>= at least.
13:49:02 * kallisti doesn't recall the actual precedence level of >>=
13:49:13 <dmwit> ghci says infixl 1
13:49:18 <latros> that is a lot of infix :(
13:49:32 <kallisti> latros: I'm not a fan of flip.
13:49:45 <rasfar> mroman: if you're still around, I'd really suggest looking at one of the zipper libraries on hackage, if you feel up to it.  Try searching for "zipper" on the hackage package list http://hackage.haskell.org/packages/archive/pkg-list.html, there look to me some that would be more convenient than the breadcrumbs...
13:50:14 <latros> well, you could do it in pointed style in do notation
13:50:19 <latros> it'd be easier to read albeit more verbose
13:50:29 <kallisti> well terse was my goal for this one.
13:50:32 <latros> k
13:50:54 <kallisti> "basic cat program with as little unnecessary stuff as possible"
13:51:00 <nand`> ɹɐqooɟ should really be equal to (flip foobar)
13:51:05 <t7> can ghc just typecheck a file without creating any files?
13:52:38 <andares> m a >>= f = m (f a), fmap f (m a) = m (f a), right kallisti? and return . f = (m f).
13:52:59 <latros> what's that m
13:53:11 <dmwit> andares: ...none of those laws look true
13:53:16 <latros> as in, m is a type constructor
13:53:19 <latros> not a data constructor
13:53:22 <latros> so that doesn't actually make any sense
13:53:31 <andares> I'm trying to understand it.
13:53:44 <dmwit> return a >>= f = f a -- this is true
13:53:58 <latros> for a given Monad m and a given type a, m a is a type, not an object
13:54:02 <latros> for example [a] is a type
13:54:06 <dmwit> fmap f (return a) = return (f a) -- this looks plausible
13:54:19 <latros> huh
13:54:21 <latros> does that work?
13:54:21 <dmwit> return . f = return f -- this certainly isn't true
13:54:44 <nand`> fmap f (return a) = return (f a) -- should be true
13:54:52 <latros> return a >>= (return . f)
13:54:53 <latros> ah
13:54:53 <latros> yes
13:54:54 <latros> k
13:54:55 <latros> right
13:55:04 <andares> I misunderstood >>= I think.
13:55:06 <latros> had to translate it to bind notation first
13:55:21 <kallisti> andares: I think you got confused when you saw the type "m a" and thought that it looked like that at the data level somehow.
13:55:22 <latros> you seem to have a type-data distinction misunderstanding as well
13:55:24 <kallisti> "m a" is a single value.
13:55:35 <latros> m a is a type of a value
13:55:38 <latros> it's not a value
13:55:42 <kallisti> er, yes.
13:55:59 <latros> (actually it's not one type, but for fixed m and a it is)
13:56:12 <andares> ah, I think I interpreted m as a data constructor erroneously.
13:56:23 <kallisti> nope
13:56:33 <kallisti> data Maybe a = Nothing | Just a
13:56:39 <kallisti> here's a type with many different constructors.
13:56:48 <latros> I'm not sure why you said nope
13:56:53 <latros> because that's exactly what happened
13:57:08 <kallisti> I meant nope as in "that's not the case"
13:57:13 <kallisti> English and negatives, man...
13:57:20 <latros> I think that came across wrong then, heh
13:57:34 <latros> one unfortunate fact of syntax/idiom
13:57:49 <kallisti> there's no requirement that each constructor have the same number of arguments as its type has type parameters.
13:57:58 <kallisti> nor is there any requirement that it syntactically resemble its type in any way.
13:58:02 <latros> is that data constructors often have the same name as their type constructors
13:58:30 <latros> which makes it easy (and common) to make the mistake of thinking that they're the same thing
13:58:55 <kallisti> I even think in this way sometimes. :P
13:59:02 <kallisti> but not at the syntax level.
13:59:21 <latros> in some cases it's quite close; in some cases the constructor basically just wraps up a value and that's all there is to it
13:59:29 <nand`> kallisti: clearly the solution is to not use English ;)
13:59:52 <andares> ah, so in a >>= (return . f) = fmap f a, (a >>= return . f) applies f to data inside of a, then boxes it into the same type as a, right? while fmap f a … yeah, I see.
14:00:33 <latros> yes, precisely
14:00:54 <andares> now to attempt to understand Control.Arrow.
14:00:58 <kallisti> (my (English `is`) >>= not . great) `because` (I `speak` too . much $ Haskell)
14:01:00 <latros> (though personally I think fmap/join/return is easier to understand than >>=/return)
14:01:01 <vodik> andares: you can always think of a >>= return . f as a >>= \i -> return (f i)
14:01:13 <andares> of course.
14:01:28 <andares> haha
14:01:50 <latros> fmap applies a function to the values inside; join rolls the values inside together; return boxes
14:02:03 <andares> back in several moments.
14:02:11 <kallisti> how many exactly?
14:02:14 <latros> how many what
14:02:17 <kallisti> moments
14:02:51 <andares> 10^46 Planck moments, kallisti.
14:03:01 <latros> lol
14:03:30 <latros> I might have to figure out how many of each Planck unit it takes to get to the same order of magnitude as the KMS units
14:03:35 <latros> and then just start talking in terms of them
14:03:53 <vodik> > join (Just Nothing)
14:03:54 <lambdabot>   Nothing
14:04:00 <vodik> hmm, i need to play with join more
14:04:02 <latros> "be back in 10^45 planck times"
14:04:24 <vodik> > join Nothing
14:04:25 <lambdabot>   Nothing
14:04:38 <teneen> Can someone explain to me what's this syntax allows this
14:04:41 <vodik> > join (Just (Just (Just Nothing)))
14:04:42 <lambdabot>   Just (Just Nothing)
14:04:47 <latros> join Nothing is an interesting example because it shows that Nothing has a very polymorphic type
14:04:48 <teneen> newtype RIO p C(r u t t1) a = RIO {
14:04:50 <teneen>         unsafeUnRIO :: Repository p C(r u t) -> IO a -- ^ converts @RIO a@ to @IO a@.
14:04:51 <teneen>    }
14:04:55 <teneen> it's in the darcs source
14:04:56 <kallisti> > join []
14:04:57 <lambdabot>   []
14:05:03 <kallisti> same here.
14:05:06 <latros> same for that yes
14:05:11 <copumpkin> teneen: record syntax
14:05:18 <latros> any data constructor which doesn't take a parameter when the type constructor does
14:05:24 <latros> creates a really polymorphic value
14:05:29 <vodik> > join (Left (Right 6))
14:05:30 <lambdabot>   Left (Right 6)
14:05:33 <teneen> @copumpkin what is this capital C ?
14:05:34 <lambdabot> Unknown command, try @list
14:05:36 <latros> wtf
14:05:37 <vodik> > join (Left (Left 6))
14:05:38 <lambdabot>   Left (Left 6)
14:05:43 <latros> join for Either....what
14:05:47 <kallisti> Left is like the Nothing for Either.
14:05:52 <teneen> @copumpkin C(r u t)
14:05:52 <lambdabot> Unknown command, try @list
14:05:55 <vodik> > join (Right (Left 6))
14:05:56 <lambdabot>   Left 6
14:06:00 <vodik> ah
14:06:07 <vodik> thats interesting
14:06:08 <kallisti> if you think of Left as being an error condition
14:06:09 <copumpkin> teneen: oh, weird
14:06:12 <kallisti> and Right as being a successful condition.
14:06:12 <vodik> kallisti: yeah
14:06:21 <copumpkin> teneen: I'd assume it's a macro
14:06:24 <vodik> kallisti: i get how Either works, just groking join
14:06:27 <copumpkin> teneen: outside of haskell
14:06:39 <teneen> compumkin: this makes sense
14:06:48 <copumpkin> not sure what the definition is though
14:06:57 <kallisti> vodik: I assumed you did. the same logic applies to join, as far as I can tell.
14:06:59 <latros> isn't that just an omitted space
14:07:06 <latros> ah wait no
14:07:10 <latros> that's weird
14:07:35 <KruMn> hi guys
14:08:17 <vodik> kallisti: is, very loosly, <*> is to join what <$> is to liftM?
14:08:58 <copumpkin> no
14:08:59 <opqdonut> <*> is ap, <$> is liftM/fmap
14:09:08 <vodik> okay, ap
14:09:40 <vodik> ooh, okay, thats actually starting to make sense
14:10:14 <vodik> return f `ap` a `ap` ...
14:10:16 <vodik> right
14:12:17 <mk12> Can anyone give me a reason prefer let bindings over where or vice versa? I'd rather always use one when they both work, but I cant decide
14:13:59 <vodik> mk12: i think generally _i_ end up using let when the the expression is pure and where when its monadic
14:15:15 * hackagebot diagrams-cairo 0.5.0.1 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-0.5.0.1 (BrentYorgey)
14:15:51 <vodik> mk12: stressing i because i don't know if there's an actual standard or guidelines
14:16:37 <mk12> i don't like having two ways to do the same thing with no clear difference... I know what the differences are but in a lot of the time they work exactly the same
14:16:56 <Clint> what's the least intrusive way to add a second condition to something like: if boolA then return [(x,y)] else return []
14:17:17 <mk12> and I'd like to be consistent, but I feel like i end up just choosing whichever looks better
14:17:33 <vodik> Clint: else if ... then ... else return []
14:18:13 <Clint> i mean that the list should contain another value if the second bool is true
14:18:43 <vodik> Clint: put it on the outside then
14:19:12 <Clint> vodik: eh?
14:19:31 <vodik> let temp = if boolA ...
14:19:55 <vodik> in if boolB (temp ++ [z]) ...
14:20:10 <Clint> hmm
14:20:27 <Clint> ok, thanks
14:20:28 <vodik> Clint: although you might want to rething if statements and use when
14:20:44 <vodik> > when (True) [(1,2)]
14:20:45 <lambdabot>   Couldn't match expected type `()' against inferred type `(t, t1)'
14:20:53 <vodik> > when True [(1,2)]
14:20:54 <lambdabot>   Couldn't match expected type `()' against inferred type `(t, t1)'
14:21:04 <kallisti> vodik: yeah the difference between ap and <*> is which instance it uses. Sometimes I like to use ap if it means that I can avoid an unnecessary Applicative instance in my type.
14:21:20 <kallisti> vodik: same with liftM vs. <$> and <*>
14:21:29 <latros> vodik, it has to be an m ()
14:22:10 <Clint> vodik: i'm modifying someone else's code so i don't want to change more than necessary anyway
14:22:12 <kallisti> otherwise it doesn't know what to return on the false case.
14:23:03 <vodik> latros: heh, i think i could stuble through this if i did it on my machine, but lambdabot and ghci i don't fully get yet
14:23:17 <latros> @type when
14:23:18 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:23:23 <latros> pretty straightforward
14:23:35 <latros> you gave a [(a,b)]
14:23:41 <latros> which is not a [()]
14:24:06 <latros> really all when can do with lists is fork
14:24:11 <vodik> riiight, m ()
14:24:20 <vodik> i think im confusing when with guard
14:24:24 <latros> yes
14:24:25 <latros> probably
14:24:28 <latros> @type guard
14:24:29 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:24:31 <kallisti> huh, I didn't know monomorphism restriction applied to values bound by a where on a top-level declaration.
14:24:35 <latros> er, no, I'm wrong
14:24:57 <kallisti> you're confusing when with an if statement
14:25:01 <latros> yeah
14:25:06 <kallisti> which returns a value on the false case.
14:25:19 <kallisti> (when does too, you just can't specify)
14:25:24 <latros> you can only use when/guard when () is allowed
14:25:49 <latros> which is somewhat more than you might think
14:26:04 <kallisti> any kind of "stateful" monad
14:26:11 <kallisti> works well with when
14:26:14 <latros> even lists, as I said
14:26:28 <kallisti> guard is useful with many monads.
14:26:31 <latros> if you are conceiving of lists as modeling nondetermistic computation rather than as a data structure
14:26:46 <latros> (with when, that is)
14:26:52 <latros> with guard it even makes sense as a nondetermistic computation
14:27:02 <latros> er
14:27:04 <latros> as a data structure
14:27:13 <latros> as evidenced by how comprehensions work
14:27:16 <kallisti> latros: also, if you're only interested in the number of possibilities and not the data itself.
14:27:17 <vodik> guard words for any MonadPlus, no?
14:27:21 <kallisti> (re: when and lists)
14:27:21 <latros> yup
14:27:50 <latros> guard b m = if b then m else mzero, iirc
14:27:53 <latros> @src guard
14:27:54 <lambdabot> guard True  =  return ()
14:27:54 <lambdabot> guard False =  mzero
14:27:57 <latros> oh
14:27:58 <latros> nvm
14:28:08 <latros> doesn't take a second arg, right
14:28:17 <latros> chops everything off if it fails
14:28:22 <kallisti> latros: that's a surprisingly common mistake, I've noticed.
14:28:26 <kallisti> to think that guard takes a second argument.
14:28:30 <vodik> latros: i've only ever used it with ListT
14:28:40 <latros> used what, guard?
14:28:41 <vodik> x <- ListT [1..2]
14:28:45 <vodik> x <- ListT [1..]
14:28:50 <vodik> guard (x `mod` 2)
14:28:51 * kallisti prefers LogicT to ListT.
14:28:59 <kallisti> because it's a bit more efficient.
14:29:00 <latros> that's basically just a comprehension, vodik
14:29:04 <vodik> exactly
14:29:11 <latros> and in fact with MonadComprehensions
14:29:13 <latros> it can be written as one
14:29:14 <latros> :p
14:29:29 <latros> (also, x `mod` 2 is not a boolean in haskell :p)
14:29:43 <latros> (this isn't C :p)
14:29:49 <latros> (or python, or ...)
14:30:36 <hpc> @let listOfLanguagesHaskellIsNot = words "Python C C++ Java" -- TODO: add more languages
14:30:37 <lambdabot>  Defined.
14:30:43 <vodik> @type x `mod` 2
14:30:44 <lambdabot> Expr
14:30:50 <vodik> > x `mod` 2
14:30:51 <lambdabot>   x `mod` 2
14:30:53 <vodik> err
14:30:55 <vodik> > 4 `mod` 2
14:30:56 <lambdabot>   0
14:30:59 <vodik> oh right
14:31:23 <hpc> :t mod
14:31:24 <lambdabot> forall a. (Integral a) => a -> a -> a
14:31:41 <hpc> if you want to have heaps of fun, define an Integral instance for Bool
14:31:53 <hpc> (4 `mod` 2) will not even remotely be what you expect :P
14:32:13 <hpc> ...actually, i suppose it will, but almost nothing else will work right
14:33:34 <vodik> well, then again there is odd
14:33:37 <vodik> @type odd
14:33:38 <lambdabot> forall a. (Integral a) => a -> Bool
14:33:48 <vodik> err, even
14:33:50 <vodik> whatever
14:40:39 <t7> whats #n in SML ?
14:40:43 <t7> where n is an int
14:41:22 <quintessence> tuple label selectors iirc
14:41:27 <shachaf> Get a value at position n from a tuple, I think.
14:41:34 <shachaf> Why are you asking here?
14:41:56 <t7> im translating some code from SML to haskell
14:42:00 <t7> kinda on topic
14:42:10 <c_wraith> how does sml deal with that, type-wise?
14:42:22 <c_wraith> Is it not a typeable expression?
14:43:13 <monochrom> no. as a built-in. special type rules.
14:43:24 <c_wraith> ah.  So not a function.
14:43:28 <c_wraith> that makes it easier
14:48:14 <quintessence> SML just complains if it can't infer a concrete type for the "argument" of a selector, but there are type systems with row polymorphism or qualified types that can give it a principal type
14:50:15 <hpaste> gdoteof pasted “how to avoid ambiguous import” at http://hpaste.org/65068
14:50:42 <vodik> gdoteof: import qualified Import as I
14:50:50 <vodik> gdoteof: then I.import
14:51:04 <gdoteof> ^ i tried adding import Database.MongoDB.import as import
14:51:11 <vodik> gdoteof: thats if you need both, you can also do this:
14:51:23 <vodik> gdoteof: import Import hiding (import)
14:51:30 <vodik> if you know you will only use the one
14:52:01 <gdoteof> vodik; ok.  i tried import qualified Import as I but it broke everything else it seemed; it was saying $ was out of scope
14:52:12 <DanBurton> gdoteof: using `import qualified' can resolve ambiguities by forcing you to qualify the use of anything from that import
14:52:30 <DanBurton> I would import the other one qualified
14:52:32 <quintessence> gdoteof: if you want to keep or throw away a list of names from an import, you can import Foo (keep, these, names) or import Bar hiding (don't, import, these), but usually importing qualified is clearer
14:52:43 <vodik> gdoteof: you'd have to prefix everything from Import with I. then
14:52:48 <DanBurton> e.g. import qualified Database.MongoDB as Mongo
14:53:48 <gdoteof> vodik: got it.  so if i do import Database.MongoDB (insert) is that giving `insert` by itself to Database.MongoDB?  or is there no way to be explicit about what 'insert' means; and only what it doesn't mean
14:54:37 <vodik> gdoteof: you can't have two imports that share the same name
14:54:42 <ski> (c_wraith : btw, note that `n' must be a literal)
14:54:44 <gdoteof> i get a parse error with Database.MongoDB (input)
14:54:47 <vodik> gdoteof: either you hide on, and make it unaccessable
14:55:09 <vodik> gdoteof: or you qualify the import. you can think of qualifications like namespace
14:55:17 * hackagebot xmlhtml 0.1.7 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1.7 (GregoryCollins)
14:55:19 <vodik> gdoteof: im sure you've seen import Data.Map as M before
14:55:44 <gdoteof> yes
14:56:17 <gdoteof> vodik: i see.  hiding i think is what makes sense int his case but thanks for the help from so many angles
14:56:59 * c_wraith thinks he has just figured out why GADTs are awesome
15:00:48 <GADTnewbie> can anyone tell my why GADTs are awesome??
15:00:57 <monochrom> hahaha
15:00:58 <tromp__> :t unfoldr
15:00:59 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
15:03:45 <roconnor> Oleg says everything you can do with GADTs can be done with typeclasses
15:04:24 <c_wraith> I could certainly do it with a typeclass
15:04:30 <c_wraith> It just would be a lot more verbose
15:05:03 <tromp__> @pl \f -> (fmap (\x->(x,x)) . f)
15:05:04 <lambdabot> (fmap (join (,)) .)
15:05:26 <latros> ....lol function monad...
15:05:45 <latros> (I don't see it much, so it's amusing when it pops up)
15:06:46 <c_wraith> Anyway, I've got a case where I want to tie the return type of a function to an enumeration it works with.
15:07:17 <c_wraith> I could have defined a type class for the return type that would return the correct value in the enumeration.
15:07:23 <c_wraith> But that felt really heavy
15:07:27 <ski>   (fmap (id &&& id) .)
15:07:48 <latros> that's not heavy at all, ski
15:08:01 <ski> heavy ?
15:08:12 <latros> dependency heavy relative to what it does, I guess
15:08:21 <latros> or abstraction heavy
15:08:21 <ski> c_wraith : so you used a GADT, yes :)
15:08:23 <c_wraith> So I created a GADT that attaches a phantom type variable with different types for each constructor in the enumeration
15:08:46 * ski can read c_wraith's mind !
15:08:47 <latros> paste?
15:08:56 <latros> that sounds pretty interesting
15:09:16 <c_wraith> Eh.  It's company code, and it'd take some time to whip up something parallel that isn't company code.
15:09:46 <ski> latros : oh -- well that `fmap' thing wasn't related to what c_wraith said, it was an alternate answer to tromp__'s query
15:09:49 <latros> really? doesn't seem like it'd be that hard, I'm mainly just confused by what you mean by attaching a type to each constructor
15:09:55 <latros> I know
15:09:59 <c_wraith> ah, ok.  give me a few minutes, then
15:12:10 <zzo38> Just some questions: What things would you have done differently in designing Haskell programming language? And which features (including but not limited to extensions) are you using?
15:12:27 <latros> IO would be a comonad
15:12:29 <latros> (random)
15:12:45 <ski> hahaha :)
15:12:56 <zzo38> IO certainly could not be a comonad on (->) it doesn't make sense.
15:13:09 <latros> um
15:13:13 <latros> do I need to get the paper?
15:13:21 <ski> Kieburz paper ?
15:13:26 <latros> probably
15:13:33 <ski> at least as described by him, it doesn't work
15:13:34 <c_wraith> latros: http://hpaste.org/65071
15:13:42 <latros> oh yeah?
15:13:54 <c_wraith> is a very simple example of what I did
15:16:18 <ski> zzo38 : i would write tuple types differently. i would have included a `local'-`in' construct, and also module types and module functions
15:16:24 <seafood> Anyone here ever built a cross compiler?
15:16:28 <zzo38> I know it doesn't work. At least, IO cannot be a comonad on (->); it obviously is a comonad on the dual category.
15:16:48 <seafood> I want to build a cross compiler for GHC 7.2.2 from either Darwin to ARM or Linux to ARM
15:16:55 * ski presumes latros was thinking about the `Hask' category, yes
15:16:58 <c_wraith> latros: the main idea is that because of the construction of the GADT, the return type of the function is uniquely determined by the value of the enumeration chosen
15:17:04 <dylukes> ski: "in"?
15:17:16 <ski> dylukes : or whatever concrete syntax you prefer
15:17:23 <dylukes> for what...?
15:17:27 * dylukes is confused
15:17:37 <ski> dylukes : `local <decls> in <decls>', being a declaration itself
15:17:41 <latros> apparently there is a setup that works but that violates referential transparency
15:17:51 <latros> ...which only "works" in a certain sense
15:18:09 <zzo38> ski: OK. Yes I have heard of local-in too and I think that may be a reasonable idea. But what do you mean by module types and module functions?
15:18:16 <ski> dylukes : for when you want to use `where' over two clauses of a definition, or over two different definitions, but can't because that's not how `where' works
15:18:29 <ski> dylukes : SML has this, and it's often useful, imo
15:19:10 <ski> zzo38 : as in signatures / module types, and functors, in SML and O'Caml
15:19:51 <ski> zzo38 : see e.g. <http://www.catonmat.net/blog/on-functors/> for some kind of explanation of what "functor" means in this context
15:20:12 <thoughtpolice> seafood: you'd probably be better off using a copy of HEAD; it has some work on cross compilation that didn't appear in 7.2 or 7.4
15:20:27 <quintessence> ski: what do you think of the "First-class Modules for Haskell" paper?  I find the idea of having a module system without a separate language very enticing.
15:20:28 <thoughtpolice> seafood: generally speaking cross compilation isn't all there yet, at least not with a standard build procedure and expected workflow
15:20:29 <seafood> Oh, really?
15:20:45 <seafood> thoughtpolice: Okay. Has anyone written about this anywhere?
15:20:46 <ski> quintessence : hm, i don't recall if i've read that one
15:20:59 <seafood> thoughtpolice: And didn't we have it at some point? Back in 6.11?
15:21:10 <ski> quintessence : but the idea sounds like it could be useful (but i'd wonder how it would interact with the type system)
15:21:11 <thoughtpolice> seafood: there's some stuff on the wiki about the expected results and design kinda, but overall I just watch ghc-cvs and look at the commits
15:21:42 <thoughtpolice> seafood: it had the ability to port successfully, i.e. putting GHC on a new platform, not cross compiling (running on linux/amd64 and creating binaries for ios/arm, for example)
15:22:15 <seafood> thoughtpolice: Is it working now?
15:22:18 <thoughtpolice> there is ghc-iphone, which is a cross compiler version of GHC 6.10, but it's very old, and the work was never mainlined directly. the creator (blackh) wrote the patches that hit HEAD in the past few months however
15:22:45 <thoughtpolice> seafood: i can't say, i haven't tried it, i only know there's been work done in the build system (but it's not in 7.4 or 7.2)
15:23:24 <thoughtpolice> (and again that work was done by blackh.) there's really not many guarantees about 'does it work' here, it's still pretty much a work in progress, and there hasn't been consistent, dedicated work applied to it
15:23:33 <ski> zzo38 : there's also other small things would could be nifty, such as writing `foo@(map f) (a:as) = f a : foo as' or defining types like `newtype k (Flip f a b) = MkFlip (k (f b a))'
15:23:37 <thoughtpolice> mostly because it's really boring work, like hacking autoconf/makefiles and build toolchains
15:23:56 <ski> zzo38 : i could probably think of more interesting things, if i thought for a while
15:24:08 <quintessence> ski: basically, the paper gives some sugar for encoding abstract types as existentials and manifest types as type parameters.  You can already encode SML/O'Caml's module system in Sytem F, but doing it pleasantly in Haskell is another matter.
15:24:31 <thoughtpolice> seafood: overall you'll likely be on your own a lot. the people in #ghc might be more informed however
15:25:06 <ski> zzo38 : another thing which could be nice would be replacing/fixing TH to support typed staged programming
15:25:21 <ion> Typed staged programming? /me googles
15:25:57 <ski> (TH isn't fully typed, because it is still possible to write code-generating code which will generate ill-typed code when run. the MetaML/MetaOCaml system is an example of a system which doesn't allow this)
15:26:09 <ski> ion : see MetaML/MetaOCaml
15:26:14 <ion> Ok, thanks
15:26:34 <lukish> How can I get time::Integer, nick::String and text::String from "[time] <nick> text" ? Using regexp or whatever
15:26:55 <ion> lukish: Parsec or Trifecta.
15:27:13 <zzo38> OK I read about the "Functors in Standard ML"; I can understand a bit. In my own idea (codenamed "Ibtlfmm") I did already suggest the @ kind for modules, and something. And I have thought of things like TH differently, as well as many more metaprorgamming possible, including C-like macros and Lisp-like macros. But tell me your other idea if you have one
15:27:46 <identity_> Hey guys. I was wondering if any of you knew of a more efficient, possibly cross-platform way to move a file using Haskell than just copyFile->deleteFile? I'm currently developing on windows, and as I'm sure you guys know, moving a file there is basically instantenous if you're using the graphical interface. I'm assuming it's using MoveFile from the windows API which probably just changes entries in the file system, or some such
15:27:56 <identity_> Do you guys think this assumption is correct?
15:28:29 <ion> @hoogle rename
15:28:29 <tech2> identity_: moving a file is only instantaneous if it's on the same device, in which case it's probably a rename
15:28:29 <lambdabot> System.Posix.Files rename :: FilePath -> FilePath -> IO ()
15:28:29 <lambdabot> System.Directory renameDirectory :: FilePath -> FilePath -> IO ()
15:28:30 <lambdabot> System.Directory renameFile :: FilePath -> FilePath -> IO ()
15:28:41 <ski> zzo38 : "A Ban on Imports" <http://gbracha.blogspot.com/2009/06/ban-on-imports.html> and "A Ban on Imports (continued)" <http://gbracha.blogspot.com/2009/07/ban-on-imports-continued.html> might also be interesting
15:29:23 <identity_> Aaah
15:29:31 <identity_> I hadn't thought about it like that.
15:29:44 <tech2> identity_: does mean you have to ensure it's on the same device though
15:29:55 <identity_> tech2: Yes, I see.
15:30:30 <zzo38> ski: Yes I have thought about that kind of things too, and have ways to fix that.
15:30:52 <ski> zzo38 : in Haskell, assume that you have written a module that uses a priority queue to implement something. now you want to change the implementation of the priority queue -- this ought to be possible without *touching* the code of your module (only changing which priority queue it gets linked up with, and that should be specified *externally*) -- currently, you can't do this in Haskell (at least not in a simple way)
15:31:31 <ski> (to clarify, you want to swap the implementation of the priority queue used for another PQ implementation)
15:32:54 <quintessence> In (S|O'Ca)ML projects do you usually just have one file the plugs together a bunch of functors?  I've never worked on anything big in either.
15:33:08 <zzo38> ski: Yes, I know. Is why, I had idea making new programming language, this is one of thing fixed. But I solved it by using a different kind of system for package identifiers as one thing
15:33:57 <zzo38> Unlike Haskell, my package identification system is decentralized so it does not require a central package system such as Hackage.
15:34:04 <acowley> Racket's Units are a closely related point in this design space, too.
15:35:29 <tromp__> how does one post an article to reddit (i only see how to submit a link) ?
15:36:03 <zzo38> I will tell you some of my other ideas too: One is that there is no if/then/else expression; instead just use a function (bool :: x -> x -> Bool -> x).
15:36:06 <ski> quintessence : i think that is most common, yes
15:36:19 <latros> you can already do that zzo
15:36:20 <zzo38> Some people might like this and some people might hate it.
15:36:22 <latros> and lambdabot even has it
15:36:25 <latros> @src if'
15:36:25 <lambdabot> Source not found. My pet ferret can type better than you!
15:36:26 <ski> (though libraries which are used may themselves be structured in a similar way)
15:36:28 <latros> ...
15:36:30 <latros> :(
15:36:42 <latros> @pl if True then 1 else 0
15:36:43 <lambdabot> if' True 1 0
15:36:43 <acowley> @src bool
15:36:44 <lambdabot> Source not found. Take a stress pill and think things over.
15:36:47 <latros> wtf
15:36:50 <acowley> haha
15:37:01 <latros> it can't find if'
15:37:06 <latros> and then spits it out when I use @pl
15:37:07 <latros> wtf
15:37:07 <ski> quintessence : for SML/NJ there's also CM files for specifying how to link together files (for MLton, it's MLB files, iirc)
15:37:14 <zzo38> latros: I know you can already do that, and I do already do that in Haskell programs. What I am saying is just that it doesn't need if expression due to that purpose.
15:37:21 <quintessence> :t if'
15:37:22 <lambdabot> Not in scope: `if''
15:37:32 <latros> is @pl separate from the rest of lambdabot?
15:37:33 <acowley> latros: you have been deemed unworthy of lambdabot's if'
15:37:41 <monochrom> the @src command is hand-coded. it's up to the mercy of the author what @src knows.
15:37:42 <ion> @hackage pointfree
15:37:42 <lambdabot> http://hackage.haskell.org/package/pointfree
15:37:56 <ski> zzo38 : well, packages are different from modules (and module functors)
15:38:10 <latros> I'd actually be curious to see how @pl is implemented
15:38:15 <latros> but I have a feeling that it is horrifying
15:38:26 <latros> given some of the disturbing things that I've seen it return
15:38:58 <zzo38> ski: I know, but using the @ kind as welll as my new package identification system, as well as macros, might be able to do many of these things you have described.
15:39:00 <ski> latros : `pointless' is one plugin for lambdabot, yes
15:39:14 <latros> oh
15:39:17 <latros> k
15:40:38 <ski> zzo38 : one good thing about ML-style modules and functors is that it enables separate compilation .. does your `@' thing allow this as well ?
15:41:27 <zzo38> ski: No but the package identification system does allow this.
15:42:13 <ski> (also, at least with some extensions, cyclic functor instantiation is also possible)
15:42:15 <zzo38> (One feature of my package identification system is local aliases; although it has various other features too)
15:42:20 <azaq23> latros: there is some monad reader article about the SKI calculus and the automatic conversion to it with implementation, this is basically what @pl does without the refinement, so you might want to
15:42:20 <azaq23> look into it - name was "SKI calculus and applicative" or so
15:42:51 <zzo38> Another of my idea is local instances and shadow dictionaries and so on.
15:45:09 <zzo38> One idea I had is, my new classes system; different from Haskell.
15:45:25 <ousado> hm.. I'm having trouble to understand the difference between GADTs and dependent datatypes - is there any?
15:45:32 <c_wraith> huh.  when GHC tells me a type variable is untouchable, what does that mean?
15:46:17 <quintessence> c_wraith: in practice, it tends to mean "add more type signatures" -- it's part of the type inference algorithm for GADTs
15:46:24 * ski thinks it ought to be called the "SKI (combinatory) algebra" instead of "SKI (combinatory) calculus"
15:46:36 <c_wraith> I have some intuition based on where the error message came from, and how I got rid of it.
15:46:37 <ski> (see <http://lambda-the-ultimate.org/node/533#comment-7712>)
15:47:04 <c_wraith> In particular, I was adding a type signature inside of one branch of a pattern match on a GADT
15:47:04 <monochrom> the line between calculus and algebra is thin
15:47:12 <ski> c_wraith : it's a skolem, it's generic
15:47:22 <c_wraith> and it wasn't happy until I moved that type signature outside of the case expression
15:47:48 <c_wraith> So, it meant something along the lines of "I can't allow you to make that type concrete in this context"
15:47:55 <ski> c_wraith : let's say you're implementing `foo :: forall a. ..a..' : in the implementation of this, you're not allowed to assume anything about `a', in particular you can't unify it with any other (concrete) type, nor with any other type variable
15:48:29 <ski> (i.e. not with any other type variable `b', which also is bound in that `forall')
15:49:03 <quintessence> GADTs don't have principal types, so the intuition that adding (consistent) type signatures can only improve things no longer holds
15:49:06 <c_wraith> Hmm.  the type variable *was* bound in that forall.  damn overloadedstrings.
15:49:16 <acowley> ousado: I suppose one difference would be if you wanted a constructor like (x:nat) -> x>0 -> Foo
15:49:38 <zzo38> In my system, a class is just defined as a type synonym, so when it is fully applied it eventually becomes something of kind & and it can be a compound constraint; the parts can include: class methods, class tags, mathematical laws, and relations between them.
15:49:38 <c_wraith> quintessence: ah.  That actually explains a lot
15:49:46 <acowley> ousado: so in Coq, I might write [foo : forall x, x > 0 -> Foo]
15:49:48 <zzo38> Do you like this?
15:50:40 <ski> c_wraith : in case of GADTs, the type variable `a' can actually be refined to a more concrete type, but not by normal unification, only by matching on GADT constructors
15:51:44 <c_wraith> ski: it wasn't actually a type in the GADT.  It was «case foo of Bar -> ""» where foo is a GADT value and OverloadedStrings was on.
15:51:50 <ousado> acowley: hm.. I see, yes, putting static constraints on values.
15:51:55 <c_wraith> ski: I couldn't annotate that to "" :: String
15:51:58 <quintessence> zzo38: you might want to look at Ur/Web, which is a language where a type class is just a family of types whose members can be inferred and passed as implicit parameters
15:52:11 <ousado> acowley: ATS also supports that
15:52:18 <c_wraith> ski: I had to move the annotation fixing its type to outside the case expression
15:52:20 <ski> zzo38 : yes, with the new system in GHC, there is a kind for classes as well
15:52:28 <zzo38> quintessence: Something like that yes.
15:52:47 <ski> @where Ur
15:52:47 <lambdabot> Ur and Ur/Web by Adam Chlipala (aka Smerdyakov) at <http://www.impredicative.com/ur/> and #ur -- Ur is a functional, pure, statically-typed, and strict programming language, supporting a powerful
15:52:47 <lambdabot> kind of metaprogramming based on row types. Ur/Web is Ur plus a special standard library and associated rules for parsing and optimization, supporting construction of dynamic web applications backed
15:52:47 <lambdabot> by SQL databases.
15:53:01 <zzo38> However, the way I am thinking of, one thing you could even define superclasses later on, and/or make up other ways to define a class later on, etc.
15:54:53 <ski> ousado : dependent types allows types with kind like `Nat -> *' (and also types like `forall x : Nat. Foo x' / `(x : Nat) -> Foo x'). with a system like Haskell (including GADTs) you only get kinds like `* -> *' (and `forall's in types can only bind type variables, not value variables)
15:55:32 <ski> c_wraith : you mean the `forall' thing -- yeah, you tend to need that with GADTs
15:56:43 <c_wraith> ski: actually, I didn't need a forall.  Just a «:: String» annotation on the result of the case expression, at the use site.  (The code is probably a bit too polymorphic)
15:57:06 <ski> oh, a type *ascription*
15:57:08 <acowley> ousado: I think Coq and Agda are really helpful for looking at these things because you see where type parameters fit, and then the type indices show up elsewhere. If you stop there you have something like Haskell with GADTs. If you then want logical propositions parameterized by values you need DT.
15:57:17 * ski was thinking c_wraith was talking about a type signature
15:57:23 <zzo38> I also have idea of other new kinds. My basic kinds are @ # + * ? & -> while some are subkinds of others, there are user-defined datakinds given capitalized alphanumeric names, and if a type is inside of {} that is a kind where the types are a expression of that type inside of {}
15:57:36 <acowley> well, I shouldn't say you "need" DT
15:57:44 <zzo38> I can explain what I mean by these kinds if you want to.
15:58:54 <ski> c_wraith : or, hm, maybe you meant a signature after all -- did you mean you bound the `case'-expression to a name, and added a type signature ? or added an ascription on the use of the name ?
15:59:08 <zzo38> What do you think of this ideas so far?
15:59:13 <c_wraith> ski: the latter, in this case.
15:59:19 <ski> ok
16:00:07 <ousado> I see. that makes it clearer.
16:00:08 * ski didn't understand zzo38's `{}' thing
16:00:56 <quintessence> it sounds like SHE's "braces of upwards mobility"
16:01:43 <zzo38> ski: For example, {"Hello, World!"} is a type of kind {String}. The only things that you can do with them would be to convert the type to a value of the correct type; this allow you to make up types that take values as parameters.
16:03:06 <ski> mhm
16:03:11 <ski> and what is the use of this ?
16:03:20 <ski> encoding dependent types ?
16:04:22 <zzo38> Maybe you can do that, I don't know. But you would be able to substitude for the reflection types that some Haskell packages have, might be another thing you can do.
16:10:13 <zzo38> Another thing is that some people have said they didn't want the "Int" type in Prelude. I agree; now my idea, there is no "Int" type. The signed integer types are the bounded types Int8, Int16, Int32, and Int64; and the unbounded type Integer.
16:10:50 <zzo38> Haskell uses Word8 and so on for unsigned integer types. My idea uses Nat8 instead. So the unsigned integer types would be the bounded types Nat8, Nat16, Nat32, and Nat64; and the unbounded unsigned integer type Natural.
16:14:07 <teneen> in the source of GHC.ST there's a use of a value "realworld#", I want to know from where this value comes from
16:14:11 <teneen> runSTRep st_rep = case st_rep realWorld# of
16:14:13 <teneen>                         (# _, r #) -> r
16:14:35 <teneen> it's not defined in the module or any of the imported ones
16:17:47 <lukish> How can I get current timestamp in unix time format?
16:18:59 <latros> teneen, realworld things aren't explicitly defined anywhere
16:19:02 <latros> they're magic
16:20:24 <teneen> latros, mm silly question but how does ghc know how to treat them?
16:20:59 <latros> I should rephrase, they aren't explicitly defined in the bits of GHC that are haskell
16:21:36 <latros> the things that operate directly on realWorld values, iirc, are implemented in C
16:21:49 <latros> I may be mistaken however
16:21:55 <ski> @index realWorld#
16:21:56 <lambdabot> bzzt
16:22:27 <lukish> > getCurrentTime
16:22:28 <lambdabot>   Not in scope: `getCurrentTime'
16:22:48 <lukish> > Data.Time.Clock.getCurrentTime
16:22:49 <lambdabot>   Not in scope: `Data.Time.Clock.getCurrentTime'
16:23:08 <lukish> Anyway, how can I get Integer value from it?
16:23:08 <alpounet> @type getCurrentTime
16:23:09 <lambdabot> Not in scope: `getCurrentTime'
16:23:15 <teneen> latros, is that C source code available somewhere? :)
16:23:21 <latros> yes
16:23:29 <latros> in any GHC source distribution
16:23:59 <ski> teneen : hm, seems to be in at least `GHC.Base' and `GHC.Exts', here
16:24:23 <teneen> ski, that's RealWorld not realworld#
16:24:39 <latros> the # bit has to do with boxing
16:24:52 <latros> also
16:24:53 <latros> aaaaaaaaah
16:25:00 <latros> newtype Sudoku a = Sudoku (StateT (DiffUArray (Int,Int) Int) Nondet a)
16:25:00 <latros>     deriving (Functor, Monad, MonadPlus)
16:25:03 <latros> those derivings
16:25:04 <latros> what
16:25:30 <quintessence> latros: you can derive anything through a newtype
16:25:38 <latros> I know that you *can*
16:25:43 <ski> teneen : no, i was talking about `realWorld#', not `RealWorld'
16:26:06 <latros> eh I guess it's not so weird
16:26:18 <teneen> ski, are they defined there? they are just used
16:26:26 * ski doesn't know
16:27:20 <quintessence> values of type RealWorld don't actually have any runtime representation, but I don't know where that's handled
16:27:28 <ski>   realWorld# :: State# RealWorld  -- Defined in GHC.Prim
16:27:32 <ski> it says in this version
16:28:46 <ski> latros : that's `GeneralizedNewtypeDeriving'
16:28:49 <teneen> which version is this?
16:29:08 <ski> teneen : that was 6.12.1
16:29:29 <hpaste> “can't get yesod to work with mongo” pasted “gdoteof” at http://hpaste.org/65072
16:29:52 <teneen> ski, could you please link me to the source?
16:30:07 <ski> (same answer in 7.0.4, though)
16:30:16 * ski hasn't looked at the source, yet
16:30:23 * hackagebot pipes-core 0.0.1 - Compositional pipelines  http://hackage.haskell.org/package/pipes-core-0.0.1 (PaoloCapriotti)
16:30:25 * hackagebot pipes-attoparsec 0.0.1 - Utilities to convert a parser into a pipe.  http://hackage.haskell.org/package/pipes-attoparsec-0.0.1 (PaoloCapriotti)
16:30:27 * hackagebot pipes-conduit 0.0.1 - Conduit adapters  http://hackage.haskell.org/package/pipes-conduit-0.0.1 (PaoloCapriotti)
16:30:44 <quintessence> yay pipes!
16:31:04 <teneen> ski, I don't understand. Didn't you just say it is in the source?
16:32:57 <ski>   "GHC.Prim        Has no implementation.  It defines built-in things, and by importing it you bring them into scope. The source file is GHC.Prim.hi-boot, which is just copied to make GHC.Prim.hi"
16:33:06 <ski>   (from <http://darcs.haskell.org/packages/base/GHC/Base.lhs>)
16:33:19 <ski> teneen : no, i did `:i realWorld#' in GHCi
16:33:40 <shapr> I enjoy this thread: http://www.haskell.org/pipermail/haskell-cafe/2009-July/064690.html
16:33:59 <shapr> inits = takeWhileM (const [True,False])
16:34:50 <ski> interesting
16:36:03 <teneen> ski, ok thanks :)
16:36:36 <ski> "Underestimating the novelty of the future is a time-honored tradition. (D.G.)" -- heh
16:40:23 * hackagebot pipes-extra 0.0.1 - Various basic utilities for Pipes.  http://hackage.haskell.org/package/pipes-extra-0.0.1 (PaoloCapriotti)
16:40:25 * hackagebot git-annex 3.20120309 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120309 (JoeyHess)
16:40:27 * hackagebot pipes-network 0.0.1 - Utilities to deal with sockets.  http://hackage.haskell.org/package/pipes-network-0.0.1 (PaoloCapriotti)
16:40:29 * hackagebot pipes-zlib 0.0.1 - Pipes to deal with zipped data.  http://hackage.haskell.org/package/pipes-zlib-0.0.1 (PaoloCapriotti)
16:56:23 <lifestream> Hi, does anyone know of any Haskell tutorials where as you learn, you are coding towards *something*?  For example, a rudimentary file manager, text editor, or some such. I have trouble learning even the most basic things unless "there's a point" to it. Umm... hope this makes sense :-S
16:57:07 <alpounet> lifestream, have you taken a look at Real World Haskell?
16:57:09 <alpounet> @where rwh
16:57:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:57:33 <alpounet> pretty much all the examples lead you to writing actually useful pieces of code
16:57:42 <alpounet> not just computing a fibonacci sequence
17:00:41 <lifestream> Oops, how embarrassing. I have that book open in my browser right now, and I've been reading the first couple pages, but from looking at the table of contents I thought it would be same old, same old... so now I skipped to the last chapters and I see there are many program examples... thanks..! :-X
17:01:21 <ski> lifestream : hm, maybe "Write Yourself a Scheme in 48 Hours" at <http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours> ?
17:01:43 <lifestream> Well, someone's going to be up all night now, I need to get good enough to create something like the applications on that book :-)
17:02:35 <alpounet> lifestream, there are parsers, tcp servers, and whatnot
17:02:41 <alpounet> really that's a pragmatic introductory book
17:03:10 <lifestream> ski,  didn't realize that was for haskell language.
17:03:56 <lifestream> now that I saw all the example programs on 'real world haskell' I think I'll stick through it for now. Thanks all
17:04:56 <lifestream> Seems I also missed all the "Practical Haskell" links in the Tutorial wiki page
17:12:13 <parcs`> @where revdeps
17:12:13 <lambdabot> "Show reverse dependencies" at <http://hackage.haskell.org/trac/hackage/ticket/576>,"Hackage with Reverse Dependencies" by Roel van Dijk at <http://bifunctor.homelinux.net/~roel/hackage/packages/
17:12:13 <lambdabot> hackage.html>,"Reverse Dependencies" at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html>,<http://packdeps.haskellers.com/reverse> -- `bifunctor.homelinux.net' is
17:12:13 <lambdabot> broken, use `81.26.216.99' instead
17:21:13 <mm_freak> byorgey: a project is coming up where i will need to draw complicated diagrams possibly with loops…  would you recommend your diagrams library or should i stick with graphviz for now?
17:21:58 <byorgey> mm_freak: I recommend diagrams of course =)
17:22:20 <mm_freak> i'm asking because i've seen the fibs example, which looks quite nice, but i hope i'm not stuck with trees then =)
17:22:41 <byorgey> mm_freak: probably both of them will be frustrating and not do what you want, but at least with diagrams you will be able to do something about it =)
17:22:55 <mm_freak> that's true =)
17:23:17 <byorgey> mm_freak: there isn't currently any built-in support for drawing general graphs, but it would not be hard to add
17:23:35 <byorgey> I mean, it wouldn't require changing the library at all
17:24:02 <byorgey> you could even use the graphviz bindings to get graphviz to do layout and then do the actual drawing with diagrams
17:24:21 <mm_freak> that's actually a great idea
17:24:30 <mm_freak> because graphviz does some physics to get the nodes to be reasonably layed out…  i'd like not to have to reinvent that
17:24:44 <byorgey> yeah, graphviz is awesome at graph layout and sucks at drawing
17:25:39 <mm_freak> let's see if graphviz supports that
17:26:35 <byorgey> mm_freak: supports what?
17:28:00 <mm_freak> great
17:28:11 <mm_freak> graphviz can output a plain text file with the coordinates =)
17:28:32 <mm_freak> perhaps the library can give me this data more directly
17:30:13 <mm_freak> byorgey: is there a way to put an auto-sized box around text?  i can only see how you can put a fixed box below the text
17:31:04 <byorgey> mm_freak: ivanm's graphviz bindings can handle that round-trip I'm pretty sure
17:32:16 <byorgey> mm_freak: not using vanilla diagrams, but if you are OK with being tied to the cairo backend you can use http://projects.haskell.org/diagrams/doc/Diagrams-Backend-Cairo-Text.html
17:32:47 <otters> :t ap zip tail
17:32:48 <lambdabot> forall b. [b] -> [(b, b)]
17:32:49 <mm_freak> that should work
17:32:56 <otters> why can't I understand this
17:33:01 <mm_freak> thanks, byorgey
17:33:55 <mm_freak> otters: that's the reader monad
17:34:32 <mm_freak> zip :: [a] -> Reader [b] [(a, b)]
17:34:38 <otters> right
17:34:43 <mm_freak> tail :: Reader [b] [b]
17:34:45 <otters> :src liftM2
17:34:50 <mm_freak> and ap is equivalent to (<*>)
17:34:53 <ski> @type ap
17:34:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:34:54 <otters> whoops
17:34:56 <otters> @src liftM2
17:34:56 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:35:20 <otters> so in this case x1 is zip a and x2 is tail a
17:35:27 <otters> okay I think I got it
17:35:33 <ski> rather `zip :: Reader [a] ([b] -> [(a,b)])', no ?
17:35:35 <mm_freak> so this basically zips a list with its tail, as far as i see it
17:35:39 <otters> right
17:35:44 <otters> so I know what it does, and I can understand it
17:36:03 <mm_freak> ski: oh, right
17:36:30 <mm_freak> it's this:  do f <- zip; x <- tail; return (f x)
17:36:43 <mm_freak> > ap zip tail $ [1..]
17:36:44 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
17:36:54 <otters> okay
17:37:05 <dbelange> > ap zip tail $ [7..]
17:37:06 <lambdabot>   [(7,8),(8,9),(9,10),(10,11),(11,12),(12,13),(13,14),(14,15),(15,16),(16,17)...
17:37:14 <mm_freak> > (do f <- zip; x <- tail; return (f x)) [1..]
17:37:15 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
17:37:19 <dbelange> > ap zip tail $ [1,1,2,3,5,8..]
17:37:19 <lambdabot>   <no location info>: parse error on input `..'
17:37:31 <ski> @quote aztec
17:37:31 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
17:37:42 <otters> zipaptail
17:37:44 <otters> yep
17:37:59 <otters> now the next step is applying it to similar situations
17:38:36 <otters> :t ap zip (map (**2))
17:38:37 <lambdabot> forall a. (Floating a) => [a] -> [(a, a)]
17:38:52 <mm_freak> > let distances = map (abs . uncurry subtract) . zip ap tail in distances [1, 4, 5, 10, 13]
17:38:53 <lambdabot>   Couldn't match expected type `[a]'
17:38:53 <lambdabot>         against inferred type `m (a1 -> ...
17:39:04 <mm_freak> > let distances = map (abs . uncurry subtract) . ap zip tail in distances [1, 4, 5, 10, 13]
17:39:05 <lambdabot>   [3,1,5,3]
17:39:38 <otters> okay so ap zip (map (**2)) gives me [(Float,Float)] but zip a $ map (**2) a gives me [(Int,Float)]
17:39:39 <otters> sup widdat
17:40:08 <mm_freak> but i'd write it differently
17:40:24 <otters> are those two not equivalent
17:40:26 <mm_freak> > liftA2 (zipWith $ abs . uncurry subtract) id tail $ [1, 5, 6, 10]
17:40:27 <lambdabot>   Occurs check: cannot construct the infinite type:
17:40:27 <lambdabot>    b = (b -> c, b -> c)
17:40:41 <mm_freak> uh
17:42:11 <ski> otters : is `a' polymorphic ?
17:42:19 <otters> yeah
17:42:20 <otters> Floating a
17:42:33 <ski> that explains it
17:42:49 <mm_freak> d'oh
17:43:22 <ski> (you should be able to add a type ascription ` :: [(Float,Float)]' in the latter case, to override the defaulting)
17:43:23 <mm_freak> > liftA2 (zipWith $ \x y -> abs (x - y)) id tail $ [1, 5, 6, 10]d
17:43:24 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
17:43:39 <mm_freak> > liftA2 (zipWith $ \x y -> abs (x - y)) id tail $ [1, 5, 6, 10]
17:43:39 <lambdabot>   [4,1,4]
17:43:41 <otters> ski: but why in the first case do the tuple members have the same type?
17:43:42 <mm_freak> i suck today
17:43:47 <otters> or why do they have to
17:44:04 <ski> otters : in the first case, the `ap' forces the inputs to have the same type
17:44:26 <otters> I don't see that in ap's type signature though
17:44:30 <ski> (i.e. the same, *monomorphic* type)
17:44:33 <ski> @type ap
17:44:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:44:57 <byorgey> in this case  m = ((->) e)
17:45:04 <otters> oh, it's m
17:45:05 <byorgey> so the two e's have to be the same
17:45:05 <otters> duh
17:45:08 <otters> okay
17:45:16 <ski> when `m' here is instantiated to `(rho ->)', `rho' in turn stands for a fixed monotype
17:45:24 <otters> okay
17:45:58 <otters> @type ap zip
17:45:58 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
17:46:22 <mm_freak> rho can well be polymorphic, but it has to be the same throughout the composition
17:47:06 <ski> @type genericLength &&& genericLength
17:47:06 <ski> @type join (&&&) genericLength
17:47:07 <lambdabot> forall b c i. (Num c, Num i) => [b] -> (c, i)
17:47:07 <lambdabot> forall c b. (Num c) => [b] -> (c, c)
17:47:15 <ski> the same thing is happening above ^
17:47:23 <otters> I see
17:48:50 <ski> mm_freak : hm, without `ImpredicativeTypes' ?
17:51:45 <carter> hey all, are there any actively maintained GIS libs for haskell?
17:52:36 <mm_freak> ski: i'd think so…  at least with an explicit type signature
17:53:04 <carter> as I can't seem to find any at least via hackage, that are actively maintained, which makes me suspect not
17:54:11 <byorgey> if it ain't on hackage it doesn't exist
17:57:23 <zzo38> The {} types/kinds I have written about, there can be another use:   type TypeOf (_ :: {x}) = x;
17:58:23 <mm_freak> zzo38: what's that?
18:00:28 <carter> byorgey: so I need to add that to my community service list this spring, damn
18:00:52 <carter> I'm already planning on taking Uber Cab with a platform written in Haskell
18:01:00 <carter> *taking on
18:01:04 <byorgey> hehe
18:01:15 <byorgey> good luck!
18:01:46 <byorgey> though personally I think the world needs Haskell GIS libraries much more than it needs an Uber Cab competitor
18:02:15 <carter> coincidentally the market needs for both intersect at me
18:02:47 <latros> this thing I'm about to paste is actually really long, but I'm actually just wondering about how exactly one specific use case gets performed
18:02:57 <carter> latros: hpaste
18:03:00 <latros> yes
18:03:01 <latros> I know
18:03:06 <latros> about to paste it
18:03:12 <latros> just showing the use case first
18:03:17 <latros> namely something like 2*(2 :+- 1) -> 4 :+- 2
18:03:26 <zzo38> mm_freak: Part of my idea of new programming language, with some ideas from Haskell. Hopefully if you read what I wrote on this channel before, then you might understand this code.
18:03:26 <latros> which is what is supposed to happen, but I don't know how what I wrote does it
18:03:29 <hpaste> latros pasted “uncert” at http://hpaste.org/65077
18:04:08 <carter> byorgey: this is all an elaborate scheme just so I can endow a grad fellowship for myself with an absurd fellowship name and ridiculous stipend and expense tab
18:04:18 <latros> does one of the from functions get called on 2?
18:04:20 <byorgey> carter: sounds awesome
18:04:29 <byorgey> latros: yes, fromInteger
18:04:34 <zzo38> mm_freak: What part do you misunderstand?
18:04:48 <latros> what happens if I replace 2 by pi?
18:04:53 <latros> oh wait
18:04:54 <byorgey> latros: integer constants are always polymorphic, and they are converted to a specific instance of Num by calling fromInteger
18:04:54 <latros> sorry
18:04:57 <latros> there's an implementation of pi
18:04:59 <latros> um
18:05:11 <latros> what happens if I replace 2 by some random Double
18:05:20 <monochrom> pi is also polymorphic, though less polymorphic than 0
18:05:38 <latros> I guess I can't then, hm
18:05:39 <byorgey> latros: a Double constant would use fromRational
18:05:42 <latros> ah
18:06:02 <latros> I didn't realize that worked on Floatings
18:06:16 <latros> I tried it on pi, it didn't work
18:06:33 <mm_freak> zzo38: i didn't read what you wrote earlier, but why another programming language?  i.e. what problem is it that haskell doesn't solve elegantly?
18:06:35 <byorgey> what didn't work?
18:06:41 <latros> fromRational pi :: Uncert Double
18:07:03 <latros> which was dumb, because I have a pi in here already
18:07:08 <byorgey> latros: oh, right, pi is not Rational
18:07:23 <monochrom> @type pi
18:07:23 <lambdabot> forall a. (Floating a) => a
18:07:27 <latros> are all Floatings?
18:07:33 <zzo38> mm_freak: A large number of things I just dislike about the design of Haskell.
18:07:36 <kallisti> is it commonly expected that library code use withSocketsDo or is it largely expected that Haskell programs apply it to their main?
18:07:39 <monochrom> some Floatings are not Rational
18:07:53 <latros> are all built in Floatings Rational?
18:08:00 <monochrom> no
18:08:00 <zzo38> (Including do-notation. My own has no do-notation, but it can be made up using macros.)
18:08:09 <mm_freak> zzo38: except the usual complaints that haskell doesn't have dependent types, what else? ;)
18:08:09 <latros> so my code can break?
18:08:13 <byorgey> Rational is a type
18:08:16 <byorgey> not a type class
18:08:20 <monochrom> Double is a Floating
18:08:20 <latros> right
18:08:30 <latros> will all Doubles cooperate?
18:08:34 <latros> that's really all that matters for this use case
18:08:41 <latros> if they can't then I need to make a simple lifter
18:08:48 <byorgey> latros: what do you mean by 'cooperate'?
18:08:52 <monochrom> what is Uncert Double?
18:08:59 <kallisti> I'm guessing it's commonly expected for end users to use withSocketsDo, rather than having it called all the type in any library code that uses sockets.
18:09:12 <byorgey> monochrom: http://hpaste.org/65077
18:09:14 <latros> Uncert models uncertainty propagation calculations
18:09:24 <latros> with normally distributed inputs
18:09:41 <latros> only Uncert Float and Uncert Double really make any sense
18:10:02 <latros> but as I mention in a comment there are infinitely many Uncert types that have a Floating interface
18:10:05 <monochrom> you have "instance Floating a => Floating (Uncert a)". then "pi :: Uncert Double" already works
18:10:13 <latros> yes, I noticed
18:10:17 <latros> will every Double work?
18:10:23 <latros> not by coercion
18:10:23 <zzo38> For example, one thing you cannot do with the Haskell class system is to add on superclasses later. In my own you would be able to connect them by relating classes using mathematical laws and relationships between tags and methods given, so that you can add an equivalent one which will then add more superclasses or different methods or whatever.
18:10:25 <latros> but if I try to multiply
18:10:30 <byorgey> every Double *constant* will work
18:10:30 <kallisti> "every Double" what do you mean?
18:10:48 <byorgey> sorry, let me say that again
18:10:53 <monochrom> realToFrac (x :: Double) :: Uncert Double
18:11:00 <byorgey> every floating-point literal will work
18:11:03 <byorgey> like  2.3456
18:11:04 * ski . o O ( s/constant/literal/ )
18:11:05 <latros> how does it know how to do the realFrac
18:11:14 <latros> when I didn't implement a realFrac
18:11:21 <latros> (I forget if realFrac has a default implementation)
18:11:29 <byorgey> but you can't just use something of type Double as an Uncert Double, you have to do the conversion manually
18:11:30 <monochrom> @src realToFrac
18:11:31 <lambdabot> realToFrac = fromRational . toRational
18:11:35 <monochrom> that is how
18:11:35 <latros> ahhhhhh
18:11:36 <latros> k
18:11:38 <latros> thanks
18:11:47 <latros> yeah sorry, that's what I meant in practice
18:11:49 <latros> floating point literals
18:11:54 <latros> nothing else is really necessary for this purpose
18:12:00 <latros> since this is really just for interactive use anyway
18:12:25 <byorgey> @type 2.5
18:12:26 <lambdabot> forall t. (Fractional t) => t
18:12:34 <byorgey> floating point literals can have any Fractional type
18:14:01 <latros> thanks, thanks
18:14:05 <latros> that helps a lot
18:14:29 <latros> the Num system is pretty elegant given that it has nastiness thrust upon it by the architecture
18:14:33 <mm_freak> zzo38: and you think this can't be done properly as a haskell extension?  because apparently most people with great ideas feel the urgent need to make their own language just to reinvent 99% of the wheel, do that badly and then have a single killer feature and the whole idea breaks because nobody uses it
18:15:21 <latros> real world use case of what I was just doing btw
18:15:23 <zzo38> mm_freak: Not only that, but a large number of other things (including things about the syntax in general, and features of the compiler, package identification system, etc)
18:15:26 <latros> *Main> 15744 :+- 6 + 0.5*130.8 :+- 0.4 - 0.5*224 :+- 6 - 0.25*0.994 :+- 0.007 + 0.25*4.2 :+- 2
18:15:26 <latros> 15698.2015 :+- 6.729784770889779
18:15:38 <latros> which I find pretty exciting, YMMV
18:16:50 <ski> interval arithmetic ?
18:16:55 <latros> not really
18:17:09 <byorgey> latros: you do know that  0.5*130.8 :+- 0.4   parses as  (0.5*130.8) :+- 0.4, right?
18:17:18 <latros> I changed the fixity
18:17:19 <zzo38> I remove many of the Haskell features including: if/then/else expression, do-notation, layout syntax, list comprehension, the "Int" type, etc. And many other things are greatly changed, and many things added.
18:17:22 <latros> after I had that problem
18:17:24 <byorgey> OK
18:17:25 <kallisti> latros: looks cool.
18:17:25 <zzo38> So it is really many difference.
18:17:34 <latros> it's infix 8 now
18:17:41 <byorgey> yep, cool
18:18:04 <mm_freak> zzo38: i see…  what's your substitute for do-notation?  a more lightweight lambda syntax? =)
18:18:14 <ski> mm_freak : .. reinventing the wheel can be useful for didactive and exploratory purposes
18:18:36 <mm_freak> ski: true
18:18:46 <zzo38> mm_freak: There is no substitute for do-notation, but it would have macro systems which can be used to make up do-notation working in a similar way to Haskell; but do-notation is not built-in.
18:18:58 <zzo38> (I also dislike do-notation in general, for many reasons.)
18:19:04 <mm_freak> it's just sad to see so many languages with great potential to fail, just because nobody uses them
18:19:20 <mm_freak> zzo38: i see
18:19:35 <ski> zzo38 : ok, so you have lexically scoped keywords, then ?
18:20:19 <zzo38> mm_freak: Well, I would use them; especially if it has a feature to be linked together with Haskell programs it might work.
18:20:58 <zzo38> ski: Yes, something very much like that. Although in general it is macros to a file, and a module can export and import these macros too, I suppose.
18:21:07 <mm_freak> zzo38: the problem is, they never get ready for production
18:22:02 <mm_freak> just too much work for a single person
18:22:07 <zzo38> But I would also remove case/of; but lambdas can have {} around the part after \ if you have multiple patterns to match (you can omit the {} if there is only one pattern).
18:22:58 <mm_freak> zzo38: what's the substitute for Int?
18:23:03 <zzo38> And the standard Monad class would be join and return (not >>=) and have Functor has its superclass with map.
18:23:18 <zzo38> mm_freak: You have to use a more specific type: Int8, Int16, Int32, Int64, or Integer.
18:23:41 <zzo38> (All of which have the same meaning as they do in Haskell.)
18:23:49 <mm_freak> note:  Monad in terms of join/return might have a performance impact, unless you have a very clever rewrite rule system
18:24:01 <tromp__> no Word32 etc. ?
18:24:02 <mm_freak> also you really want Int with unspecified size in many cases
18:24:14 <zzo38> tromp__: There is, but it is now called Nat32.
18:24:16 <ski> tromp__ : named `Nat32',&c.
18:24:33 <mm_freak> i think of Int as "a reasonably fast native integer type"
18:24:52 <zzo38> mm_freak: I understand; and yes it would have a rewrite rule system based on mathematical laws
18:25:17 <mm_freak> zzo38: also you probably don't want to repeat the mistake made by haskell's class hierarchy
18:25:27 * hackagebot egison 1.2.0 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-1.2.0 (SatoshiEgi)
18:25:28 <zzo38> mm_freak: I know that.
18:26:00 <gentleben> why do you want infinitely large integers
18:26:12 <mm_freak> zzo38: make it possible to define minimal complete definitions explicitly
18:26:18 <ski> well, ordinals are fun, no ?
18:26:18 <tromp__> for Project Euler
18:26:21 <mm_freak> then better add both (>>=) and join to Monad
18:26:49 <zzo38> One thing I have is the ability to fix it in later modules, by adding superclasses later. Since, the classes are not really like Haskell classes; instead you simply make a type synonym which becomes a constraint. And, yes; I do intend you can define minimal complete definitions explicitly; and even change them later on.
18:27:01 <ski> mm_freak : yeah, i've wanted a way to specify that
18:27:09 <mm_freak> in haskell the state of things is a bit unfortunate:  if two functions' default definitions are in terms of each other, haskell is fine with not giving any definition
18:27:54 <zzo38> So, you can add (>>=) to Monad later even if join isn't there; simply by defining the relations between the classes correctly. (Note that in mine, class methods by themselves are even classes; although so are many other things.) And it can work.
18:28:09 <mm_freak> sounds interesting
18:28:56 <ski> mm_freak : it would also be nice to be able to specify both how to implement `a' in terms of `b', and how to implement it in terms of `c' (and say `b' and `c' in terms of each other), making it select the right one for `a', depending on which of `b' and `c' you provide :)
18:28:58 <zzo38> And if you define something which does not follow the mathematical laws which belong (mathematical laws are also classes; a type synonym brings them together with the class methods, tags, relations, etc) then it is not guaranteed to work.
18:29:03 <hpaste> acowley pasted “parMapST” at http://hpaste.org/65080
18:29:15 <zzo38> ski: And I do certainly intend you can do that too.
18:29:21 <acowley> So that's what I came up with. It works and I don't think it's unsafe.
18:29:37 <ski> zzo38 : well, i wish you luck
18:29:43 <acowley> Is there some loophole for badness that I'm missing?
18:29:54 <zzo38> ski: I really don't know how to implement all this stuff but I can write specifications.
18:30:03 <zzo38> Or at least, I can try to.
18:30:10 * ski smiles
18:30:36 <Saizan> acowley: it's not deterministic
18:31:02 <rwbarton> f could hold an STRef or something and then the threads would access that STRef in an unsynchronized way
18:32:00 <ski> (what Saizan&rwbarton said)
18:33:14 <ski> acowley : this is similar to `unsafeInterleaveST' (which actually is unsafe, in that it can break the semantics)
18:34:40 <mm_freak> zzo38: "is not guaranteed to work"?  "does not compile" would be better
18:35:06 <zzo38> mm_freak: You are correct; but in some cases the computer might not be able to tell whether or not it is correct.
18:35:13 * ski . o O ( "does not compute" )
18:35:59 <zzo38> Another thing is that Haskell has built-in rules for the [] type and value and for integer literals and fraction literals and so on; so in mine, instead, all of these things are macros instead. All of these macros would be defined in the Prelude; but you can redefine them with your own definitions if you want to.
18:36:08 <ski> zzo38 : then it's usually best to conservatively not allow it (unless the user explicitly adds some "promiseX" stuff, in which case the user is on their own)
18:36:27 <arbn> I'm reading the source for DEMO-light, but I've never seen this syntax before. Any pointers would be appreciated.
18:36:43 * ski thinks Haskell doesn't have fraction literals
18:36:53 <hpaste> arbn pasted “DEMOlight question” at http://hpaste.org/65081
18:37:14 <zzo38> ski: I mean floating point literals such as 2.5 and so on.
18:37:27 <ski> arbn : all of the things in the comma-list are declared to have the same type
18:37:38 <ski> arbn : `;' is just used instead of breaking the line
18:37:46 <ski> zzo38 : ah, ok
18:37:48 <dolio> @type 2.0
18:37:49 <lambdabot> forall t. (Fractional t) => t
18:37:50 <zzo38> OK, I suppose you might want to conservatively not allow it; another idea, is to make it a warning (which the user can suppress or change into an error)
18:37:58 <ski> @type 2%0
18:37:59 <lambdabot> forall t. (Integral t) => Ratio t
18:38:04 <arbn> ski: thanks!
18:38:43 * ski feels an urge to line up all the `='s in that paste
18:39:37 <ski> zzo38 : i think "better safe than sorry" is a pretty good default, usually :)
18:40:43 <mm_freak> zzo38: well, the agda compiler will indeed run forever, if proving correctness takes forever
18:40:47 <mm_freak> i like that path
18:41:14 <zzo38> ski: I think I prefer to make it a warning by default, although of course compilers can do a few things different; if their defaults are not the same as the standard, they could have an option to switch standard-compliant mode on except for options which are explicitly overridden.
18:41:33 <mm_freak> in any case…  all in all it sounds like you're making a purely functional, statically typed common lisp =)
18:41:35 * ski nods vaguely
18:41:44 <mm_freak> common hisp
18:41:49 <irene-knapp> wait, who's doing this
18:41:52 <irene-knapp> sounds fun
18:41:54 <ski> zzo38
18:42:14 <irene-knapp> although my syntactic aspirations have evolved past s-expressions
18:42:18 * ski waits for someone to make a pure dynamically typed language with monads
18:42:53 <kallisti> Pyskell
18:42:55 <zzo38> mm_freak: Yes I suppose it has many similarities to a purely functional, statically typed common lisp.
18:42:55 <wavewave_> is http://www.haskell.org/platform down?
18:43:01 <mm_freak> "language with monads"?
18:43:16 <kallisti> "language with abstraction and nice syntax sugar for monads"
18:43:28 <ski> zzo38 : i don't recall whether i've mentioned MetaML/MetaOCaml to you yet ..
18:43:41 <irene-knapp> my own pet language is purely functional, statically and dependently typed, and is lexically English-like, with the lexical stuff divided into what I call the "high grammar" and "low grammar" so that macro expansion, as with Lisp s-expressions, can happen at the lower layer.
18:43:50 <zzo38> But I would have comonads in the prelude as well, not only monads. But there isn't any do-notation built-in, so it doesn't have these kind of syntax sugar.
18:43:56 <zzo38> ski: You have mentioned those to me.
18:43:59 <ski> mm_freak : yeah, with good support for monads, using monads for I/O at the very least
18:44:22 <irene-knapp> because I can have "real" CL-esque macros, I don't /need/ to have do-notation built in, it can be a standard macro!
18:44:28 <mm_freak> i'm not sure monads are the end of the road for I/O
18:44:41 <Saizan> ski: i thought eff was that, unless they added types
18:44:57 <ski> mm_freak : didn't say it was :)
18:44:58 <mm_freak> they are great for I/O, but i'm pretty sure there are nicer solutions to be found
18:45:04 <alpounet> irene-knapp, is there a repo for yours? would like to see how it looks like
18:45:32 <ski> irene-knapp : s/macro/syntax/ :)
18:45:35 <irene-knapp> alpounet: wellllll it might be easiest if I just hpaste the grammar for you or something
18:45:35 <zzo38> Also the difference in the type of main: The type of main can be any type, but to compile into a standalone executable, only two types are possible: (IO ()) or (unsafe "c_int(c_int,c_char**)"). If it is any other type, you can still make a dynamically loadable library but not a standalone executable.
18:45:39 <irene-knapp> ski: yes, that, haha
18:45:52 <irene-knapp> alpounet: it's too early for there to be any actual code written /in/ the language :)
18:45:56 * ski likes lexically scoped syntices, like in Scheme
18:45:58 <alpounet> hah ok
18:46:07 <alpounet> irene-knapp, then yes, seeing the grammar is fine too
18:46:08 <ski> (obviously with hygiene)
18:46:11 <alpounet> you just got me curious
18:46:16 <irene-knapp> sure thing :)
18:46:20 <irene-knapp> one sec then :)
18:46:21 <hpaste> gdoteof pasted “yesod#3” at http://hpaste.org/65082
18:46:40 <mm_freak> you know what i would like?  compiling haskell to PHP…  and i'm serious about that
18:46:57 <mm_freak> right now i'm using haxe, but haskell is still much nicer
18:47:12 <mm_freak> haxe is a big improvement over PHP though and i can still deploy on PHP-only servers
18:47:31 <hpaste> irene-knapp pasted “Knapp.joy” at http://hpaste.org/65083
18:47:53 <irene-knapp> this grammar file is a bit verboseish
18:48:12 <zzo38> Not only PHP, but also MMIX and Glulx. As far as I know Haskell compiles to none of these.
18:48:22 <irene-knapp> for example, microJoy, the parser generator, doesn't support parametrized grammar symbols :)
18:48:29 <irene-knapp> so there's a little duplication near the bottom
18:48:46 <wavewave_> it seems that hackage.haskell.org is down now.
18:48:48 <alpounet> ok
18:48:59 * ski was thinking once about making a Prolog-like language using (a fragment of) english for syntax
18:48:59 <irene-knapp> and there's a long list of most of the prepositions in the English language, which I got from _A Comprehensive Grammar of the English Language_ :)
18:48:59 <mm_freak> wavewave_: works for me
18:49:15 <irene-knapp> but there's only a couple dozen productions, by design
18:49:24 <ski> zzo38 : MMIX ?
18:49:25 <arbn> zzo38: Woah. Haxe compiles to MMIX instructions? Seriously?
18:49:44 <arbn> ski: Knuth's instruction set / architecture.
18:49:45 <zzo38> arbn: I didn't mean that. I meant I wanted to compile PHP into MMIX and Glulx.
18:49:45 <wavewave_> mm_freak: hmm. then probably my name server is not finding hackage.haskell.org?
18:49:47 <irene-knapp> to me, the biggest lesson to take from Inform7 was that "English-like programming language" does not mean "English as a programming language".   it's merely a family of grammars, nothing more.
18:49:56 <irene-knapp> Inform7 has hundreds of grammatical productions because its authors haven't realized that yet
18:50:01 <irene-knapp> I went the other direction :)
18:50:20 <arbn> zzo38: Oh. OK. :)
18:50:34 <mm_freak> wavewave_: http://www.downforeveryoneorjustme.com/ =)
18:51:00 <irene-knapp> MMIX and Glulx?!  wtf :D that is awesome!
18:51:18 * irene-knapp didn't know anyone but her and Andrew Plotkin even knew what Glulx was
18:51:21 <kallisti> wow, it was surprisingly painless to switch some strings over to newtypes with generalized newtype deriving.
18:51:21 <MaskRay> irene-knapp: Via what tool to diddle with http://hpaste.org/65083
18:51:24 <wavewave_> mm_freak: thanks.. what the hell is going on my side....
18:51:40 <irene-knapp> MaskRay: sorry, what's the question?
18:51:49 <JoeyA> Inform7 is a programming language.  A programming language tells a computer what to do.  The computer is in a room.  You are facing West.
18:51:54 <zzo38> My idea also includes some ideas of Prolog, Inform7, Lisp, and even INTERCAL and Magic: the Gathering. But also having inline LLVM, which I don't know of any other programming language which has inline LLVM codes. (Inline LLVM codes are string literals prefixed by the keyword "unsafe"; and can be used in types of kind # and in values; C types can have "c_" prefix to use in inline LLVM codes.)
18:51:57 <irene-knapp> JoeyA: ahahahaha!
18:52:07 <ski> arbn : i was first thinking it was a name of a partial evaluator (they semi-often have "mix" in their name)
18:52:23 <irene-knapp> @remember <JoeyA> Inform7 is a programming language.  A programming language tells a computer what to do.  The computer is in a room.  You are facing West.
18:52:24 <lambdabot> Done.
18:52:30 <irene-knapp> @quote West
18:52:30 <lambdabot> <JoeyA> says: Inform7 is a programming language.  A programming language tells a computer what to do.  The computer is in a room.  You are facing West.
18:52:30 <MaskRay> irene-knapp: how to play with your code?
18:52:40 <kallisti> newtype WindowHandle = WindowHandle String  deriving (Eq, Show, Read, IsString,  FromJSON, ToJSON)
18:52:45 <kallisti> what are some other things I should consider deriving?
18:52:49 <irene-knapp> MaskRay: it doesn't really work yet, and it's written against the microJoy parser generator (also by me)
18:52:56 <zzo38> As well as WEB; the program file is formatted similar to a WEB program so that you can use literate programming like that too; although much of it is different from WEB, too.
18:52:59 <alpounet> irene-knapp, hah that definitely looks fun
18:53:01 <irene-knapp> MaskRay: so you can't really play with it yet :) unless you are prepared to do a lot of work
18:53:04 <irene-knapp> alpounet: thanks!
18:53:15 <alpounet> keep people posted about it
18:53:19 <irene-knapp> I shall!
18:53:23 <kallisti> is there some other String instances that I'm forgetting about?
18:53:52 <irene-knapp> you notice how I replaced the algebraic/record dichotomy with just nouns-plus-prepositions for everything? :)
18:53:53 <kallisti> there's Ord, but I don't want Ord.
18:54:00 <MaskRay> irene-knapp: sigh...
18:54:21 <ski> irene-knapp : written in Joy ?
18:54:31 <irene-knapp> MaskRay: I'd love to have people playing with it, but at my current pace it'll be at least a few weeks before anyone but me can even compile it
18:55:27 <irene-knapp> ski: well, microJoy is a subset of Joy that scales back what it is meant to be able to do to just what I need for this language project (which I am calling Knapp just in case it takes off, so that I will be able to say "I'm Irene Knapp" and people will be able to immediately make the connection to the programming language :D)
18:55:31 <alpounet> irene-knapp, yeah i did
18:55:37 <irene-knapp> alpounet: cool :)
18:55:41 <alpounet> kind of reminds me *a bit* about edwardk's kata
18:55:49 <irene-knapp> oh, really?  interesting.  wasn't familiar with it
18:56:45 <irene-knapp> ski: so the file header and name both still say Joy because I haven't bothered to change that, but it's microJoy really which is kinda different.  for one thing the output is just a .hs file which contains definitions of the parse tables; you're expected to write your own driver loop.
18:56:56 * ski thinks attribute grammars are fun/interesting
18:57:01 <alpounet> irene-knapp, well it's different, but he somehow has classes and let you qualify them with kind of adjectives
18:57:17 <irene-knapp> alpounet: hmmmmm, interesting, I will have to look at it for inspiration and stuff
18:57:18 <alpounet> irene-knapp, see https://github.com/ekmett/kata/blob/master/doc/Category.ks
18:57:19 <irene-knapp> ski: they are!
18:57:37 <irene-knapp> why is he ekmett on github but edwardk everywhere else?  well, anyway, looking :)
18:57:43 * ski has a few ideas about marrying AGs with logic programming
18:58:30 <irene-knapp> ski: it turns out that there are some parts of speech for which you can use ambiguity-capable parse algorithms to let unknown words be created just by using them, and others for which you get exponential blowup
18:59:00 <irene-knapp> prepositions of course are in the latter category, which is why Knapp.joy contains a huge list of hardcoded ones - since they won't be user-extensible, the user had better /really/ never need to extend them!
18:59:30 <irene-knapp> ski: not sure if that was the sort of feature you had in mind, but.
18:59:58 <ski> irene-knapp : interesting
18:59:58 <irene-knapp> hmmmm, this Category.ks is cleaner than his TH code that I've seen at least :)
19:00:03 <irene-knapp> ski: I thought so :)
19:00:39 <irene-knapp> but I still don't really have the brain-torque to figure it out right now.  I'll leave it open overnight in case I do in the morning.
19:00:48 <irene-knapp> hm
19:00:55 <irene-knapp> that would have been funnier if I said something like
19:00:57 <zzo38> But I think we should make up the discussion group for my idea of programming language (codenamed Ibtlfmm); some people from this channel and some people from #esoteric channel, and I am the main person.
19:01:02 <irene-knapp> I don't have enough brain-hertz
19:01:08 <ski> irene-knapp : well, i was thinking about simplistic examples like `Bob is a cat.',`Apples are green or red.', &c., corresponding to `cat(bob).',`( green(X) ; red(X) ) :- apple(X).',&c.
19:01:43 <irene-knapp> zzo38: your codename needs to either be shorter or more pronounceable
19:01:52 * ski grins
19:02:02 <irene-knapp> ski: yeah, hmmmmm….
19:02:28 <irene-knapp> ski: that relates to I7, kinda, in that I7 has a few hardcoded situations where it infers the type of something from how it's referred to
19:02:29 <zzo38> irene-knapp: I know that.
19:04:16 * ski hasn't really looked at Inform
19:05:21 <irene-knapp> ski: I'm not sure whether it's worth looking at for your purposes or not, but it's at the very least cute and different
19:05:39 <irene-knapp> it's not an attribute grammar - it's actually just a traditional LALR(1) grammar
19:05:59 * ski didn't presume it was, though
19:06:20 <irene-knapp> zzo38: oh, did you actually want a better codename?  because I just spent a minute writing a shell pipeline to generate one for you =p
19:06:35 <zzo38> irene-knapp: Well, if you have already done so, write it here.
19:07:08 <irene-knapp> one sec, it's executing. :)
19:07:48 <zzo38> But I had other suggestions too, such as: "HELLwaPAIN" (Haskell Extended Logic Language with a Pronounceable, Acronymic, Initialled Name), "hell pain", "Iuckqlwviv Kjugobe" (my D&D character's name; completely irrelevant here), ...
19:08:45 <zzo38> The files are still called "Ibtlfmm", and renaming them would make old URLs fail to work.
19:09:05 <irene-knapp> irene@jusenkyo:~$ sort -R /usr/share/dict/words | head -n 1000 | egrep "^[a-z]{5,9}$" | head -n 2
19:09:05 <irene-knapp> legalism
19:09:06 <irene-knapp> gossipped
19:09:14 <irene-knapp> (the head -n 1000 is to make it quicker)
19:09:19 <irene-knapp> (the egrep turns out to be the slow step)
19:09:38 <irene-knapp> I like the word "legalism" there, but "gossipped" may need a tweak
19:09:52 <alpounet> gopissed
19:10:02 <irene-knapp> haha
19:10:28 * hackagebot pandoc 1.9.1.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.1.2 (JohnMacFarlane)
19:11:12 <mjreed> hey, how would I declare a type that includes an array field?
19:12:17 <monochrom> like data X = X (Array Int Bool)
19:12:29 <ski> @help freshname
19:12:29 <lambdabot> freshname. Return a unique Haskell project name.
19:12:35 <ski> irene-knapp : ^ is another option
19:12:39 <monochrom> @freshname
19:12:39 <lambdabot> Hafp
19:12:45 <monochrom> heh
19:12:59 <monochrom> "Haskell food processor"
19:13:07 <monochrom> @freshname
19:13:07 <lambdabot> Hafq
19:13:14 <monochrom> um...!
19:13:22 <latros> @freshname
19:13:22 <lambdabot> Hafr
19:13:26 <mjreed> so that'd declare X to be an array of booleans with int indices, right, monochrom?
19:13:26 <irene-knapp> haha
19:13:26 <irene-knapp> nice
19:13:28 <latros> do they all start with Haf?
19:13:30 <latros> >.>
19:13:34 <latros> @freshname
19:13:34 <lambdabot> Hafs
19:13:41 <latros> oh
19:13:42 <monochrom> next one is "Haskell fish trout"
19:13:43 <latros> I see what they did there
19:13:48 <irene-knapp> @freshname
19:13:48 <lambdabot> Haft
19:13:53 <latros> lexicographic, cute
19:13:59 <irene-knapp> oh, haha
19:14:00 <maloi> Haft is an awesome name!
19:14:02 <irene-knapp> I see what it did there
19:14:04 <alpounet> Hafu sounds great
19:14:14 <irene-knapp> actually, it does
19:14:33 <alpounet> don't know what it could mean but well
19:14:34 <monochrom> mjreed: that declares X to have an array field
19:14:39 <alpounet> that may be my next project's name
19:14:50 <ski> mjreed : no, it'd declare the `X' to be a type that contains an array of booleans indexed by `Int's
19:14:51 <monochrom> "Haskell fire utility"
19:15:03 <ski> s/type that contains/type whose values contains/
19:15:18 <mjreed> ... that's what I meant, ski.
19:15:20 * ski . o O ( "snafu" )
19:15:34 <ski> mjreed : well, it's not what you said :)
19:15:42 <ski> (just making sure there's no misunderstanding)
19:15:44 <monochrom> I really wouldn't say "is"
19:15:51 <alpounet> mjreed, what you said would translate to: type X = Array Int Bool
19:16:09 <alpounet> which doesn't create an actual newtype, here X would just be a synonym for "Array Int Bool"
19:17:13 <mjreed> OK, backing up.  X is a type.  What can we say about values of that type?  Are they arrays?  Or tuples which include an array as an element?  Or something else?
19:17:42 <monochrom> Robert Harper may be biased about non-strictness, but the technical fact he says about "data X = X Int is not isomorphic to Int" is right
19:17:53 <mjreed> (assuming the data statement, not the type statement)
19:17:59 <ski> mjreed : are you talking about `data X = X (Array Int Bool)' or `type X = Array Int Bool' atm ?
19:18:14 <ski> mjreed : well, then they are not arrays, but they contain arrays
19:18:16 <mjreed> The former, ski.  hadn't seen the latter yet when I typed the question.
19:18:20 <mjreed> ok.
19:18:31 <ski> (and they're not tuples)
19:18:33 <shachaf> monochrom: Nonsense. Real programs are total.
19:18:42 <mjreed> sorry.  new to this stuff.
19:19:06 <ski> monochrom : where is he saying that ?
19:19:50 <monochrom> he doesn't use the exact example data X = X Int. he uses lazy peano naturals as his example
19:20:34 <shachaf> The best peanists play naturally and lazily.
19:21:59 * ski started reading an interesting paper named "Remarks on the Notion of Standard Non-Isomorphic Natural Number Series" by David Isles
19:22:25 <monochrom> http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/ "It is not possible in Haskell to define the type of natural numbers, nor the type of lists of natural numbers (or lists of anything else), nor any other inductive type!"
19:23:04 <ski> ;)
19:23:22 <dolio> If you replace "type" with "set" it's actually true.
19:33:13 <tromp__> is that because bottom inhabits every type?
19:33:20 <dolio> Yes.
19:52:37 <slack1256> algorithms as DEFLATE are made to be used with arrays. How can this be implemented efficiently in haskell?
19:52:58 <slack1256> also, what could be a good use of lazy array?
19:53:09 <rwbarton> Haskell has arrays, so that would be one option.
19:53:47 <slack1256> rwbarton: yes, but every change on a element returns a new array, which is expensive.
19:53:57 <rwbarton> it has mutable arrays also
19:55:06 <slack1256> mmm that's an option. specially for deflate algorithm
19:55:19 <slack1256> but when could i use the default lazy arrays?
19:55:27 <slack1256> (when is benefitial?)
19:57:22 <Jafet> Do you need mutable arrays?
19:58:11 <slack1256> no no. I need a case where inmutable arrays are better than mutable ones
19:59:43 <otters> how do you update base
20:00:04 <Jafet> Immutable arrays are better when having arrays be immutable is better than having mutable ones
20:01:16 <latros> lol
20:01:50 <slack1256> i can't think in a situation where "uhh this totally asks for a lazy array"
20:02:34 <copumpkin> slack1256: we often use them for dynamic programming/memoization purposes
20:02:41 <Jafet> You mean lazy immutable arrays, or lazy mutable arrays?
20:03:43 <slack1256> copumpkin: do you have some code i could look at?
20:04:40 <rwbarton> > let fibs = listArray (0, 5) $ 0 : 1 : [ fibs !! (i-2) + fibs !! (i-1) | i <- [2..4] ] in fibs
20:04:41 <lambdabot>   Couldn't match expected type `[a]'
20:04:41 <lambdabot>         against inferred type `GHC.Arr.A...
20:04:58 <rwbarton> > let fibs = listArray (0, 5) $ 0 : 1 : [ fibs ! (i-2) + fibs ! (i-1) | i <- [2..4] ] in fibs
20:04:59 <lambdabot>   array (0,5) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,*Exception: (Array.!): undefi...
20:05:04 <ski> slack1256 : dynamic programming can sometimes use lazy arrays to good effect
20:05:13 <rwbarton> oh, bah
20:06:12 <slack1256> umm that's cool.
20:06:20 <rwbarton> there's also accumArray, useful for instance if you want to tabulate character counts in some text, that doesn't require mutability
20:07:34 <kallisti> http://hpaste.org/65090 any recommendations on what I should do to this somewhat complex exception structure?
20:08:11 <kallisti> (I'm writing a client library for Selenium 2)
20:08:39 <slack1256> rwbarton: true true, i'd forgotten about accumArray. thanks for your help
20:09:29 <ski> @type accumArray
20:09:29 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
20:13:43 <bgamari> How does one get the actual subgraphs representing the components of an fgl Graph?
20:15:10 <ski> @hoogle components
20:15:11 <lambdabot> Data.Graph components :: Graph -> Forest Vertex
20:15:11 <lambdabot> Data.Graph.Inductive.Query.DFS components :: Graph gr => gr a b -> [[Node]]
20:15:11 <lambdabot> Graphics.Rendering.OpenGL.GL.Evaluators getMap1Components :: (Map1 m, ControlPoint c, Domain d) => m c d -> IO ((d, d), [c d])
20:15:29 * ski knows almost nothing about FGL
20:15:52 * ski recalls the connected-components functor is left adjoint to the free functor, though
20:16:20 <bgamari> how helpful ;)
20:16:44 <bgamari> some day I'll be able to claim I actually understand what that means
20:16:52 <bgamari> sadly today is not that day
20:17:26 <bgamari> I was thinking mkGraph $ map (context gr) $ components gr
20:17:28 <bgamari> might do it
20:18:13 <bgamari> but it crashes for reasons I can't quite say I yet understand
20:18:45 <Jafet> > let unlz77 xs n = elems ys where ys = listArray (0, n-1) (f xs); f [] = []; f xs = case reads xs of [((i,j),xs')] -> map (ys!) [i..i+j] ++ f xs'; _ -> head xs : f (tail xs); in unlz77 "Mary had a little lamb,(10,13)(11,12)(0,23)its fleece was white as snow." 103
20:18:47 <lambdabot>   "Mary had a little lamb, little lamb, little lamb, Mary had a little lamb, ...
20:22:44 <bgamari> I just can't believe it's really this difficult to construct a subgraph
20:28:53 <kallisti> bgamari: subgraphs are difficult.
20:29:23 <bgamari> kallisti: I guess so
20:29:40 <kallisti> http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem
20:34:58 <bgamari> kallisti: If you know any relatively pain-free way to construct the an undirected subgraph containing a given set of nodes, I'd greatly appreicate it
20:36:01 <kallisti> http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem#Algorithms  apparently if the subgraph is fixed you can solve it in polynomial time.
20:36:26 <kallisti> I don't know the algorithm itself, but if it involves backtracking then LogicT may be a good choice.
20:36:44 <kallisti> as that's what LogicT is for.
20:37:50 <kallisti> but if you want arbitrary two graphs that's going to be exponential time..
20:40:24 <kallisti> bgamari: oh you just want to construct a graph?
20:42:36 <JoeyA> How do I hide those pesky "Loading package" messages when using ghci?
20:43:11 <bgamari> kallisti: yes
20:43:27 <kallisti> bgamari: I suppose you've already tried using an existing graph library?
20:43:31 <bgamari> kallisti: components gives you the nodes for the
20:43:35 <bgamari> Oops
20:43:36 <ClaudiusMaximus> bgamari: perhaps efilter
20:43:40 <bgamari> I'm using fgl
20:43:53 <parcs`> JoeyA: -v0
20:44:02 <JoeyA> Thanks
20:44:06 <bgamari> ClaudiusMaximus: That won't cull singleton nodes, will it?
20:44:20 <bgamari> I really just want to subgraphs corresponding to the connected components
20:44:34 <bgamari> s/want to/want the/
20:44:48 <ClaudiusMaximus> bgamari: ah true
20:47:03 <bgamari> No ideas?
20:50:57 <ClaudiusMaximus> bgamari: delNodes all the singletons?  - seems a bit of a roundabout way...
20:52:28 <hpaste> hamilyon pasted “Probability Base.hs type error” at http://hpaste.org/65092
20:53:04 <augur> what are predicate transformers?
20:54:25 <hamilyon_> I am trying to compile probability lib/ Can anyone please help me with this error http://hpaste.org/65092
20:55:25 <ClaudiusMaximus> hamilyon_: did you try what the error message suggested?  -XFlexibleInstances on the command line or {-# LANGUAGE FlexibleInstances #-} at the top of the source file
20:57:26 <hamilyon_> Yes, tried that, error messages changed to something likeControl/Monad/Distribution/Base.hs:169:10:
20:57:26 <hamilyon_>     Could not deduce (Functor m)
20:57:26 <hamilyon_>       arising from the superclasses of an instance declaration
20:57:26 <hamilyon_>     from the context (Monad m, RandomGen g)
20:57:26 <hamilyon_>       bound by the instance declaration
20:57:27 <hamilyon_>       at Control/Monad/Distribution/Base.hs:169:10-51
20:57:27 <hamilyon_>     Possible fix:
20:57:28 <hamilyon_>       add (Functor m) to the context of the instance declaration
20:57:28 <hamilyon_>     In the instance declaration for `Dist (RandT g m)'
20:59:21 <Ayvee> ARM is a tier 2 platform for GHC.  If the plans to put Raspberry Pi into schools everywhere (at least in UK) work out, it might be a good idea to raise ARM to tier 1.  Get the kids into functional programming before they're brainwashed with imperative. :P
20:59:59 <miyako> I'd love to see first class support for ARM in GHC
21:01:31 <Ayvee> I'll try building it when I finally get an Rpi.  My order isn't in first batch, sadly.
21:02:39 <miyako> I just want a tablet that runs a real linux distribution that I can program on... and possible has an LCARS themed UI
21:03:27 <Ayvee> Ditto.  I have an Android tablet, but the Linux isn't accessible as I haven't jailbroken it.  (Still under warranty)
21:04:55 <miyako> yeah, I have a galaxy tab, and it's nice but I'd like to have a real linux on it, and be able to program it the same way I'd program any linux box
21:05:10 <Ayvee> Haha, I have the same :P
21:05:30 <miyako> I haven't had to do too much with it, but the last time I looked at the NDK it seemed...special
21:05:44 <ClaudiusMaximus> hamilyon_: at that point i'd complain to whoever i got the code from or look for alternatives (or maybe get a newer GHC and retry if i happened to be running an ancient one)
21:05:50 <Ayvee> Very nice hardware.  Don't like Android though, I want a plain Linux distro.
21:07:34 <gentleben> ARM is going to be important going forward, probably even more so on the server side
21:07:43 <Ayvee> Agreed
21:08:20 <gentleben> client won't be a big deal cause it won't ever be officially supported
21:08:31 <gentleben> but the server, will be super important
21:08:32 <miyako> Ayvee: have you looked into the spark tablet?
21:09:19 <Ayvee> ARM Holdings are very clever.  Their model of controlling the cores and letting everyone manufacture under license is far superior to Intel's I think.
21:09:20 <miyako> oh, and on a completely unrelated, but on topic note, I forgot to report back the other day, haskell is now an officially sanctioned language at work and I get to use it for my current project :)
21:09:34 <Ayvee> miyako: no, haven't.  Good?
21:10:05 <Ayvee> Haha, gratz :-)
21:10:24 <Ayvee> Did you have to blackmail the boss? :P
21:10:26 <miyako> Ayvee: a little pricey for the hardware, but it's running real linux with a KDE based UI, it's up for pre-order apparently right now, I'm waiting to see if they actually get it to manufacturing
21:10:49 <gentleben> Ayvee: its worked for them
21:11:10 <Ayvee> Interesting, I'll keep an eye on Spark
21:11:26 <miyako> Ayvee: if by blackmail you mean "I can do it in 6 weeks in C or 3 in haskell" then yes
21:12:13 <Ayvee> No, I meant more like sleeping with him or threatening to expose his porn collection.  But your technique is much more upstanding :P
21:12:42 <gentleben> but significantly less fun
21:12:58 * Ayvee chuckles
21:13:35 <miyako> actually, the arguments didn't really come from my boss, the biggest protestor was another guy on the team who insisted that if I wanted to use haskell we should use common lisp instead
21:14:04 <gentleben> there is always a lisp guy hanging out
21:15:34 <companion_cube> maybe lua is a good language for the raspberry pi
21:16:34 <Ayvee> Lua's a good scripting language for all small quick hacks, and quite fast.  Clean
21:17:11 <mathstuf> hi, i cant seem to find a mkdtemp equivalent in the haskell libs...is there an equivalent?
21:17:12 <companion_cube> it has a low memory footprint, that may
21:17:14 <companion_cube> help
21:17:24 <kallisti> @pl (\x y z -> f ( g x y z))
21:17:24 <lambdabot> ((f .) .) . g
21:17:37 <gentleben> raspberry pi would be useful if i could get them 100 as at a time, like a cheap seamicro
21:18:40 <mathstuf> ack, found it
21:18:48 <dmwit> Hiya, mathstuf.
21:18:52 <dmwit> Did you get my mail?
21:19:16 <miyako> it appears that yesod has, like many frameworks before it, failed to help me address the fundamental problem that I have with web programming
21:19:44 <mathstuf> dmwit: in re?
21:20:05 <miyako> and that is, my site still looks awful because I'm terrible at making pretty pictures
21:20:31 <mathstuf> dmwit: ah, yes
21:20:35 <dmwit> mathstuf: I think X11 is the right place to put fixes.
21:20:50 <dmwit> mathstuf: Go ahead and change the type to something more correct, as appropriate.
21:21:10 <mathstuf> break backwards compat?
21:21:18 <dmwit> yes
21:21:21 <mathstuf> k
21:21:35 <dmwit> (I'm fairly certain xmonad is the only X11 customer, anyway. =P)
21:21:38 <gentleben> miyako: web development sucks and no framework can ever fully fix it
21:22:02 <mathstuf> xmobar maybe
21:22:14 <dmwit> possibly, yes
21:22:16 <mathstuf> but i have a history of patches there too :)
21:22:51 <mathstuf> PR updated
21:23:27 <roconnor> xplat: you didn't post your solution to reddit
21:23:39 <miyako> gentleben: yeah, although it would suck less if the web was still text based
21:23:55 <Ayvee> Web development sucks *today* because webbies took a perfectly good and scalable sessionless web model and turned it into a session-based one which isn't scalable.
21:24:11 <MostAwesomeDude> I was just gonna blame JS.
21:24:12 <gentleben> miyako: nah, no chart porn
21:24:23 <gentleben> Actually I hate layout
21:24:27 <Ayvee> Roy Fielding is spinning in his grave ... and he hasn't even died.
21:24:59 <Ayvee> MostAwesomeDude: Agreed.  That was the 2nd phase killing of the web.
21:25:22 <mathstuf> dmwit: should i bump XRandR support up my list or do you want to do a release before that lands?
21:25:41 <miyako> all I want is to make a personal website/resume that is of sufficient quality to encourage people to give me money in exchange for writing non-web code for them in my free time.  Thus far this seems to be one of my more unattainable goals.
21:25:58 <mathstuf> miyako: latex :)
21:26:05 <dmwit> mathstuf: The current plan is to release X11 co-timely with the next xmonad release.
21:26:15 <mathstuf> is there a plan for that?
21:26:18 <dmwit> mathstuf: (Because we're moving another function from xmonad-contrib to X11.)
21:26:20 <companion_cube> miyako: markdown :)
21:26:28 <dmwit> mathstuf: I don't know of any concrete plans for releasing xmonad.
21:26:44 <mathstuf> hrm...
21:26:49 <miyako> mathstuf: is there actually some sort of htmlatex thing that exists and is good?
21:26:55 <mathstuf> i guess ill work on xrandr soon then
21:27:09 <mathstuf> mehitabel: well, for the resume/cv, id do latex
21:27:17 <mathstuf> oops
21:27:17 <geekosaur> miyako, have you looked at elance.com?
21:27:45 <mathstuf> miyako: for the web part...i just do simple stuff
21:27:52 <mathstuf> its not like web dev is on there anyways
21:28:01 <miyako> geekosaur: I specifically wanted to not go through a third party site, although I haven't looked at elance specifically
21:28:42 <geekosaur> I've been poking at getting a profile for that set up, and setting up my own web server for it seems like a lose (I have a web server going but no idea how long I can keep it around)
21:28:56 <miyako> most of my expertise is in things that do not seem to be all that common in the sort of work that gets farmed out to typical contracting sites
21:29:54 <Ayvee> Well that's good.  You probably wouldn't want to be a Java programmer :P
21:30:37 <miyako> Ayvee: better Java than COBOL or VB, but yeah, definitely not at the top of my list
21:30:48 <dmwit> mathstuf: Bleh, github is being flaky. Anyway, I'm looking at it. Thanks.
21:31:11 <mathstuf> np...was tired of sxiv being spastic
21:31:15 <kallisti> geekosaur: I've been finding clients on IRC more than I have third party sites. :P
21:31:24 <mathstuf> pity it took me months to get around to fixing the bug
21:31:33 <mathstuf> it might have made 0.10 if i had just done it :/
21:31:47 <geekosaur> I hear that (I'm mostly an infrastructure sysadmin, which is not really the sort of thing that farms out well.  In fact, I did work for a company that did contract stuff of that nature... it folded in 1996)
21:31:57 <Ayvee> kallisti: Finding clients on IRC?  That interesting, not heard anyone say that before
21:32:19 <sipa> what channels? :)
21:33:14 <kallisti> mostly #freelance
21:33:20 <kallisti> it's mostly inactive but occasionally things come up.
21:33:28 <kallisti> I've gotten some long term clients that way.
21:36:13 <Ayvee> kallisti: Bum on seat clients, or telecommute / code at home clients?
21:36:42 <kallisti> ..the latter.
21:36:44 <kallisti> :P
21:37:16 <dmwit> mathstuf: You probably wouldn't have made 0.10. I didn't get fed up enough with the "no maintainer on X11" thing until after the 0.10 release. =P
21:37:21 <kallisti> you guys are making me give away my trade sekrets.
21:37:38 <mathstuf> dmwit: ah
21:37:43 <Ayvee> lol
21:37:50 <geekosaur> heh
21:38:19 <xplat> roconnor: i have a perfect record of not posting to reddit, not going to break it so easily :)
21:38:38 <roconnor> xplat: how about adding to my gist?
21:39:54 <c_wraith> > 1 == 2 == True
21:39:55 <lambdabot>   Precedence parsing error
21:39:55 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
21:40:12 <c_wraith> well, at least declaring it as infix prevents that. :)
21:41:06 <roconnor> xplat: this is very nice
21:41:13 <MostAwesomeDude> Has anybody messed around with Haskore at all?
21:41:27 <xplat> roconnor: next time i'm on that computer, i suppose.  or you could put it on yourself and credit me.
21:41:32 <roconnor> xplat: this is much nicer than mine
21:42:25 <xplat> well, it was my second try
21:43:12 <roconnor> given how terrible Agda is at reasoning, you are pretty much forced to make it super-awesome to make any headway.
21:43:12 <xplat> i basically nuked everything i had yesterday
21:43:56 <roconnor> xplat: truly and falsely is genius.
21:45:13 <xplat> ehehe, thanks ^_^)
21:45:32 <roconnor> this really exceeded any expectation I had.
21:45:50 <roconnor> I thought it would be a mess in Agda, since that is what would happen if you translated what I wrote in Coq.
21:45:55 <roconnor> but this is so nice.
21:50:09 <xplat> it's all thanks to your challenge that i wrote it at all!  and calling for the lens laws gave me the idea.  and edwardk's lens library for haskell which i freely borrowed any design ideas i thought would work in agda from :)
21:53:00 <roconnor> xplat: does set-indep inply get-indep?
21:53:24 <xplat> roconnor: yes, along with the lens laws
21:53:33 <roconnor> I didn't know that
21:54:06 <xplat> i didn't either, until a couple of hours ago
21:55:01 <dmwit> What are you two discussing?
21:55:01 <xplat> i thought at best i was going to be able to prove symmetry of get-indep between f and g, but the proof for the second version didn't actually use get-indep ...
21:56:05 <roconnor> dmwit: http://www.reddit.com/r/dependent_types/comments/qmlml/patricia_trie_challenge/ and http://hpaste.org/65089
21:56:46 <roconnor> xplat: this fact may make it easier to formulate lens independence using coalgebra operations.
21:57:32 <xplat> cool
21:58:03 <dmwit> wow, this is cool
21:58:25 <otters> what language is that
21:58:43 <xplat> original is coq, the paste is agda
21:58:53 <otters> oh
21:59:12 <mgsloan> is there a lens library that avoids the round-trip for modify?
21:59:34 <shachaf> mgsloan: Data.Lens?
22:00:01 <shachaf> It has lenses isomorphic to a -> (b, b -> a)
22:00:03 <shachaf> If that's what you mean.
22:00:28 <mgsloan> clever way to do it.
22:01:03 <mgsloan> if only it didn't break so many fclabels conventions
22:01:23 <mgsloan> I quite like fclabels api, and I think it's the most used
22:01:32 <shachaf> If only fclabels didn't break the data-lens conventions...
22:03:06 <mathstuf> dmwit: for xrandr stuff, what should i do for things like enums and such
22:03:17 <mathstuf> since they wont be there when it isnt enabled
22:03:19 <mathstuf> undefined?
22:03:35 <mathstuf> and just expect users to do compiledWithXrandr?
22:03:56 <dmwit> Can you just not expose functions that would use xrandr enums when it's not compiled with xrandr?
22:04:08 <dmwit> Sorry, I'm not an X expert.
22:04:15 <dmwit> So forgive me if that's a stupid question.
22:04:46 <mathstuf> i wonder if theres a way for cabal to query for flags a dependency was compiled with
22:04:57 <mathstuf> X11 >= ... < ... -fxrandr
22:05:01 <mathstuf> or whatever
22:05:07 <dmwit> Alternately, is there a reason to expect that anybody will *not* build it with xrandr support?
22:05:17 <dmwit> If not, then why bother having a flag at all? Just demand xrandr headers.
22:05:22 <mathstuf> hermits? ;)
22:05:25 <dmwit> ...or whatever the demands might be.
22:05:45 <mathstuf> ill just expect and then whoever wants to disable it can figure out the mess :)
22:06:06 <dmwit> That seems like a sane approach to me. =)
22:11:00 * kallisti goes on mad coding spree, modifying his Selenium client library like a madman.
22:11:16 * kallisti runs GHC. it compiles.
22:11:19 <kallisti> o_O?
22:11:21 <dmwit> Is there a way to see what dependencies cabal has chosen after doing "cabal configure"?
22:11:53 <dmwit> Ah, configure --verbose seems to show what I want to know.
22:11:54 <mathstuf> dmwit: dist/package.conf.inplace ?
22:12:07 <mathstuf> or that :)
22:12:17 <dmwit> mathstuf: I don't see such a file.
22:12:23 <mathstuf> hmm
22:12:34 <mathstuf> i do in xmonad-contrib
22:12:48 <dmwit> Perhaps that's after a successful build?
22:12:55 <mathstuf> maybe
22:13:01 <mathstuf> ah, probably
22:13:03 <dmwit> The only file in dist right now is setup-config.
22:13:10 <dmwit> Which presumably has the information I want, actually.
22:13:17 <dmwit> But it's not very human-readable.
22:13:38 <kallisti> dmwit: is there such a thing as a negative window position?
22:13:42 <kallisti> like a negative x or y?
22:13:47 <mathstuf> in what context?
22:13:53 <dmwit> kallisti: Yes, definitely.
22:14:09 <kallisti> well, in the context of the "window position" attribute that Selenium gives me when I ask it too.
22:14:09 <dmwit> kallisti: Windows need not be positioned on the visible part of the display.
22:14:22 <kallisti> ah
22:14:25 <kallisti> yes, okay.
22:14:48 <kallisti> dmwit: do you think Int would be sufficient to store these numbers?
22:15:01 <dmwit> dunno, look at what X11 does for its rectangles
22:15:10 <dmwit> Whatever it uses will be sufficient, for certain. =)
22:15:25 <kallisti> dmwit: does xmonad not keep track of that info?
22:15:33 <dmwit> xmonad probably does, too
22:16:01 <kallisti> also:  window size? probably non-negative yes?
22:16:04 <dmwit> X11 has type Position = Int32, type Dimension = Word32
22:16:26 <dmwit> Yes, window size is constrained to be non-negative (see previous comment about type Dimension).
22:16:28 <kallisti> okay.
22:16:43 * kallisti was deciding whether to use Word or Int
22:16:48 <dmwit> But you should use X11's type aliases, since those types may be different on differently-word-sized machines.
22:16:49 <kallisti> Int for window position, Word for size, seems reasonable.
22:17:06 <dmwit> X11 even provides a Rectangle type.
22:17:09 <kallisti> dmwit: well, it's not really specific to my machine.
22:17:16 <kallisti> dmwit: selenium can be running on an web server somewhere.
22:17:29 <dmwit> Ah, that makes things a bit trickier, then.
22:17:42 <dmwit> Then it's not clear that Int and Word are big enough at all.
22:17:43 <kallisti> it gives me stuff in JSON, and there's no much documentation on what it can be.
22:17:47 <kallisti> so I might just have to dig through some source.
22:18:34 <dmwit> kallisti: Can I interest you in an Integer? =)
22:18:43 <kallisti> eh, I guess.
22:18:51 <kallisti> I was trying to find the minimum allowed. :P
22:19:09 <kallisti> and I don't like with non-negative numbers are represented as types that are negatable.
22:19:10 <dmwit> Just at a guess, that's going to be premature optimization.
22:19:13 <kallisti> *when
22:19:19 <dmwit> Yes, that last part is a bit frustrating.
22:19:38 <dmwit> data Nat = Z | S Nat -- probably efficient enough ;-)
22:19:42 <ClaudiusMaximus> > negate 4 :: Word8
22:19:43 <lambdabot>   252
22:20:07 <kallisti> :_(
22:22:45 <kallisti> Integer it is.
22:22:50 <kallisti> with gross negatives included.
22:22:55 <dmwit> sorry =/
22:23:24 <kallisti> I mean, it's what most programs do.
22:23:29 * kallisti conformist.
22:26:19 <kallisti> dmwit: I think I could probably get away with Word64 on most modern architectures.
22:26:24 <kallisti> for window size.
22:26:33 <kallisti> and Int64 for position.
22:26:40 <dmwit> Yes, you probably could.
22:26:54 <mikeplus64> for window size I doubt you're going to need anything near the bounds of Word64 or Int64
22:27:09 <dmwit> mathstuf: Okay, I'm just blatantly stealing code from your xmonad-core patch.
22:27:12 <mikeplus64> modern screens are small
22:27:45 <mathstuf> dmwit: hmm?
22:28:05 <dmwit> mathstuf: Well, the change to X11 has to be accompanied by changes to xmonad and xmonad-contrib.
22:28:17 <dmwit> But your patch calls the version with a Maybe in its name. =P
22:28:24 <mathstuf> ah
22:28:26 <mathstuf> yes
22:29:13 <kallisti> dmwit: huh, wait, or I could just use (Num a, Num b) => (a, b)
22:29:17 <kallisti> and let someone else decide.
22:29:43 <dmwit> That... probably isn't a good idea.
22:30:18 <dmwit> You could internally write polymorphic versions, but I don't think your API should expose them -- since allowing an arbitrary Num instance also allows an arbitrary Read parser...
22:31:08 <dmwit> argh
22:31:21 <dmwit> It's not github being flaky, it's everything.
22:31:25 <kallisti> well, FromJSON parser in this case. but yes.
22:31:27 * dmwit blames his ISP without doing any testing to confirm
22:32:10 <mathstuf> dmwit: seems to be enough evidence to me :P
22:32:42 <mathstuf> honestly though, i had sporadic connectivity issues here for over a year
22:32:55 <mathstuf> external would drop everything while iternal works fine
22:33:05 <mathstuf> needed a router power cycle to get it back
22:33:24 <mathstuf> turns out that the crappy netgear router i had overheated and cut off the external connection or something
22:33:35 <mathstuf> or got overwhelmed
22:34:05 <dmwit> Hm, maybe I should just try rebooting the router.
22:35:17 <dmwit> 20% packet loss to external sites, 0% to other 192.168.1/24's. But you say that doesn't prove it's not the router's fault.
22:35:47 <mathstuf> i had 100% drop to external, 0% internal
22:35:53 <dmwit> ouch
22:36:03 <mathstuf> (streamed mpd just fine while external was down)
22:36:05 <dmwit> This kills the IRC>
22:36:39 <dmwit> Alright, here we go. See you on the flip side.
22:43:41 <dmwit> Well, that did something alright. Now I can't see my router's administration page. =P
22:44:27 <dmwit> No packet loss any more, though.
22:46:26 <dfletcher> just learning haskell from learnyouahaskell and the implementation of btree is astonishing :o I think I'm going to like this language.
22:47:08 <dmwit> =)
22:50:40 <adnauseam> hrm, what does Haskell have over OCaml ?
22:51:07 <dmwit> cleanliness
22:51:10 <dmwit> a spec
22:51:24 <adnauseam> expand on that for the ignorant me ?;p
22:51:35 <dmwit> Haskell was designed; OCaml grew. That implies a lot of pros and cons on both sides.
22:52:04 <dmwit> I'm sure there are plenty of discussions of this on the web...
22:52:08 <adnauseam> funny enough that was what i was thinking
22:52:14 <mathstuf> adnauseam: from the (very little) ive seen of ocaml, (*) works for all Num instances in haskell instead of just integers; take that as you will :)
22:52:31 <mathstuf> and thats about where my specific ocaml knowledge gets exhausted
22:52:35 <adnauseam> i just need a good reason to make the demons in my head go hush - not interested in what the internet's debate monkeys have to say :p
22:53:16 <adnauseam> hrm, i think i understand what you mean
22:53:53 <adnauseam> i've only finished reading about types, and although currently dazed and confused, it makes sense somehow
22:54:02 <mathstuf> dmwit: not sure how to approach the XRRSetScreenInfo functions
22:54:12 <dmwit> adnauseam: I have a diatribe on the differences between OCaml's and Haskell's FFI that I think is representative of feature comparisons between the two languages. Let me see if I can find it.
22:54:28 <adnauseam> aw excellent
22:54:39 <adnauseam> mathstuf: google hasn't turned out any example code ?
22:54:41 <mathstuf> since you need up-to-date structures anyways, do i just query myself or let the caller handle it?
22:54:48 <mathstuf> you provide a timestamp
22:55:06 <mathstuf> which the xrandr can use to say "youre out of date, ask again"
22:55:15 <mathstuf> the man pages says the client *must*
22:55:38 <mathstuf> i suppose ill write the common case and also just wrap the raw case too
22:56:29 <shachaf> adnauseam: You don't want to know all the existing things that the Internet debate monkeys said, so instead you're trying to get the ones in here to type up fresh copies of those things for you?
22:57:05 * adnauseam hands shachaf a tampon
22:57:19 <adnauseam> that should stop the bleeding
22:57:36 <plat0> Haskell's growing now, isn't it?
22:57:40 <plat0> With extensions.
22:57:53 <adnauseam> plat0, aye it is - in a more controlled manner
22:58:12 <shachaf> adnauseam: The part you're missing is where every day people come into #haskell asking the same questions and for the language's existence to be justified and so on.
22:58:24 <mathstuf> dmwit: what do you say to patches nuking -fglasgow-exts and tabulators?
22:58:35 <adnauseam> shachaf: this place seems to be a good place to ask such questions
22:59:01 <shachaf> Sure -- but it's better if they're more specific.
22:59:21 <adnauseam> surely i feel more confident about the intellectual abilities of people who are in this channel, than those who aren't
22:59:43 <shachaf> That's a bad move. Did you know they'll let just *anybody* into this channel these days?!
22:59:58 * companion_cube for instance
23:00:00 * dfletcher <-- unshaven unshowered internetmonkey
23:00:01 <adnauseam> why haven't you used the tampon i gave you yet :P
23:00:06 <shachaf> Anyway, just look up answers on the Internet written by members of this channel specifically. :-)
23:00:38 <adnauseam> sigh
23:00:44 <adnauseam> you doubt i did that already i see
23:01:12 <adnauseam> what happened to the good old practice of wanting to have something extra by shooting in the dark
23:01:16 <dmwit> mathstuf: Whitespace-only patches will probably be rejected.
23:01:18 <dmwit> mathstuf: Patches that reduce warnings will be accepted.
23:01:28 * shachaf stops with this.
23:02:19 <mathstuf> trailing whitespace makes git output warnings... ;)
23:03:31 <dmwit> mathstuf: As I was typing it, I started wondering just how far you'd go. Would you submit a patch to GHC with whitespace style warnings just to get me to accept a whitespace patch? =P
23:03:46 <mathstuf> :P
23:04:06 <mathstuf> probably not that far
23:04:15 <dmwit> adnauseam: Well, reddit's search sucks, I don't know how to Google for it, and I'm tired of clicking "next" on my comment history.
23:04:23 <mathstuf> at work we do while-im-in-the-area whitespace cleanup
23:07:02 <dmwit> If your whitespace-only patch includes a style-file which happens to match what most of the code already does, I guess that might be something worthwhile.
23:07:11 <DrSatan1> Guys, anyone willing to help a super-noob please
23:07:24 <adnauseam> dmwit: i appreciate the afford still man :]
23:07:29 <shachaf> DrSatan1: Only if you say what your problem is.
23:07:29 <dmwit> I don't want to apply a lot of whitespace patches with no clear guidance on how future patches should treat whitespace, though.
23:08:17 <DrSatan1> :P... I cant get program number one in Learn you a haskell for great good to compile. I do what it says but GHCi wont compile it.
23:08:24 <mathstuf> well, im looking at a record where one out of 10 members is using tabulators and the rest spaces
23:08:37 <dmwit> argh
23:08:42 <dmwit> Alright, fine.
23:08:45 <dmwit> That's pretty egregious.
23:08:59 <mathstuf> yeah, its blue in vim :)
23:09:01 <shachaf> DrSatan1: If it's a "program" (as in "main = ..."), you probably need to put it in a file.
23:09:19 <shachaf> You should say what it actually is, though; not everyone has LYAH committed to memory. :-)
23:09:53 <DrSatan1> i do - i save it in a file main.hs with the exact text DoubleMe x = x + x, in the same directory as GHCi.exe
23:10:16 <shachaf> DrSatan1: That's not the exact text written in in LYAH.
23:10:32 <dmwit> DrSatan1: Function names must start with a lower-case character.
23:11:03 <kallisti> "for reasons"
23:11:08 * kallisti waves hands.
23:11:37 <shachaf> kallisti: No need to add that.
23:11:44 <DrSatan1> hahaha I can't believe that took me an hour to figure out
23:11:46 <dmwit> There's a good reason: we must have some way of differentiating constructors from identifiers when writing pattern matches.
23:11:55 <shachaf> People are used to dealing with mysterious rules when they're first learning something.
23:12:07 <kallisti> not everyone.
23:12:14 <shachaf> dmwit: Is that actually a valid reason?
23:12:48 <dmwit> That is the reason. Whether it is valid or not depends on how you define valid.
23:12:57 <kallisti> well it's helpful in a case statement, yes.
23:13:19 <shachaf> Fine: Is that actually a "good" reason?
23:13:31 <dmwit> The Haskell committee chose to make the grammar context-free; without this restriction, perhaps that argument would not apply.
23:13:44 <shachaf> Fair enough.
23:13:53 <mathstuf> shachaf: we'd have $variables otherwise :)
23:14:20 <dmwit> um
23:14:42 <dmwit> Both context-free *and* with a goal of making separate compilation possible.
23:14:49 <dmwit> So, yeah, I think it's a pretty good reason.
23:21:58 <dmwit> mathstuf: So, do you know a bit about X?
23:22:11 <dmwit> mathstuf: Is not getting size hints distinct from getting back Nothing for each possible hint?
23:22:44 <mathstuf> we just ask for the size hint prop
23:22:47 <mathstuf> which may not be set
23:22:48 <ezyang> If I want to do IPC between a Haskell daemon and a C daemon, what is the easiest thing to do?
23:22:49 <dmwit> mathstuf: Perhaps getWMNormalHints should still return an IO SizeHints after all.
23:23:04 <dmwit> mathstuf: Right, but SizeHints is a record, each field of which is a Maybe.
23:23:11 <mathstuf> oh
23:23:18 <dmwit> mathstuf: So I'm asking a semantics question here.
23:23:18 <mathstuf> hmm
23:23:41 <mathstuf> then the Maybe is being ignored somewhere?
23:23:48 <dmwit> ezyang: dbus, sockets, zeromq... depends what you need
23:23:57 <dmwit> mathstuf: hm?
23:24:00 <mathstuf> ive been unable to reproduce the problem with that patch
23:24:21 <mathstuf> so that patch avoids random memory reads somewhere
23:24:32 <dmwit> mathstuf: I'm proposing an alternate patch.
23:24:35 <ezyang> I don't really relish the thought of making my own message protocol for sockets
23:24:45 <dmwit> mathstuf: Instead of returning Nothing when the status is zero, let's return SizeHints Nothing Nothing Nothing Nothing.
23:24:50 <dmwit> mathstuf: How do you feel about that?
23:24:55 <ezyang> zeromq is kind of overkill though
23:25:07 <ezyang> (I'm writing a tiny program to duplex coqtop sessions)
23:25:12 <ezyang> *multiplex
23:25:36 <dmwit> mathstuf: In other words: is it important to be able to retrieve the bit saying whether the prop existed or not?
23:25:51 <mathstuf> dmwit: ah, yes, that should work
23:25:59 <dmwit> mathstuf: (I'm not *only* asking with respect to your current problem, either. This is a philosophical question.)
23:26:13 <dmwit> mathstuf: (I want to do the right thing, not the least invasive thing that happens to work for now.)
23:26:32 <mathstuf> if the records are Maybe already, then yes
23:26:41 <mathstuf> i hadnt thought to look there
23:26:45 <dmwit> excellent
23:27:02 <dmwit> That will reduce the required volume of xmonad changes/xmonad-contrib changes as well, then, right?
23:27:38 <mathstuf> yes
23:28:55 <mathstuf> yeah, the maybe id ... in applySizeHints handles it
23:30:36 <ezyang> man, Network is such a low level module
23:32:01 <shachaf> ezyang: It's pretty much the UNIX socket API, isn't it?
23:32:14 <ezyang> yeah
23:32:16 <shachaf> Well, as far as the interface goes. I guess it also does all the I/O manager things.
23:33:12 <shachaf> Anyway, coming up with good general APIs is hard. :-)
23:33:12 <ezyang> is there anything that is a teensy bit higher level (but not too much more?)
23:33:22 <arbn> Network offers a higher-level API than UNIX sockets.
23:34:58 <mathstuf> dmwit: hrm...not sure if this is an issue
23:35:01 * dmwit suggests dbus again
23:35:23 <mathstuf> oops, nvm
23:35:31 <ezyang> dmwit: Are you actually being serious about dbus?
23:35:42 <shachaf> Wait, is someone suggesting dbus?
23:36:18 * shachaf wonders where dbus and Network are competitors.
23:36:20 <dmwit> I thought dbus looked like a fairly nice, high-level design.
23:36:28 * shachaf also wonders why anyone would ever suggest dbus for anything.
23:36:34 * dmwit shrugs
23:36:48 <shachaf> My experiences with it have been wholly negative. Admittedly I haven't had many.
23:37:37 <mathstuf> shachaf: it allows me to sleep my machine without going as root... (upower)
23:37:49 <mathstuf> pm-utils checks for $UID == 0 very early :(
23:39:22 <ClaudiusMaximus> :t Numeric.showGFloat
23:39:23 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
23:40:36 <dmwit> This is probably not the right terminology, so help me out here.
23:40:41 <ezyang> Hum, apparently dbus is actually what I want.
23:40:47 <dmwit> How do I say that the current commit should really be the future of everything forever in git?
23:40:55 <dmwit> Like, can I just call it master?
23:41:23 <dmwit> I've got a scary-looking message about being in "detached HEAD" mode sitting in front of me.
23:41:52 <shachaf> dmwit: How did you get to that state?
23:42:23 <dmwit> I checked out a branch from mathstuf, decided I didn't want any of those patches, and checked out a previous commit.
23:42:34 <dmwit> (I've since committed one additional patch.)
23:42:48 <shachaf> The previous commit wasn't master?
23:42:49 <mathstuf> git checkout master; git reset --hard origin/master
23:42:56 <shachaf> You can checkout master and merge your current branch.
23:43:11 <shachaf> By "branch" I mean commit.
23:43:23 <shachaf> Is master one of the ancestors of your current commit?
23:43:32 <dmwit> I really don't know. How do I check?
23:43:59 <shachaf> `git show master` should show you the which commit master is.
23:44:12 <shachaf> Then you can check if that commit is in `git log`
23:44:36 <dmwit> master is not an ancestor of my current commit
23:44:50 <shachaf> Oh.
23:45:02 <shachaf> Is *any* branch an ancestor of your current commit?
23:45:14 <shachaf> Or maybe master's parent?
23:45:23 * shachaf has the vague feeling this is spamming the channel.
23:45:35 <shachaf> dmwit: #-blah?
23:47:04 <Enigmagic> dmwit: just run "git checkout -b <new branch name>"
23:47:12 <Enigmagic> that'll give it a name so it's not detached
23:47:26 <shachaf> Or do what Enigmagic said first, yes. That's a good thing to do.
23:48:16 <Enigmagic> then party on as desired, the name "master" doesn't really mean much and you can delete/rename them later if you really want
23:49:14 <NemesisD> sweet holy mother i just looked at the source for HashMap delete
23:49:31 <kallisti> I'm having difficulties deciding when it's appropriate to use Text and when it's appropriate to use String.
23:49:38 <kallisti> I feel like the convenience of Strings shouldn't be overlooked.
23:51:14 <drdo> Where does cabal-install build packages? (Getting an autotools error and need to look at the config.log)
23:52:17 <Enigmagic> how about "find . -name config.log" ?
23:53:23 <mathstuf> drdo: should be under ~/.cabal
23:53:40 <drdo> mathstuf: Isn't
23:53:59 <mathstuf> not sure then :/
23:54:09 <Enigmagic> drdo: run "cabal unpack packagename" then run "cabal install" in the unpacked package directory
23:54:23 <Enigmagic> the config.log will be in the root
23:55:06 <drdo> thanks
23:55:38 <drdo> Was just me passing -flto to an old gcc that doesn't know it
23:56:43 <kallisti> I think I'm going to stick with Text
23:56:45 <kallisti> because... it's better.
23:57:41 <drdo> kallisti: Eh, how are Strings more convenient anyway?
23:58:38 <kallisti> eh, perhaps I'm just more familiar with Strings than Text.
23:59:46 <dmwit> drdo: There's an awful lot of list functions that happen to be convenient operations on Strings.
