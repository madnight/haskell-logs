00:16:07 <sanjoyd> Okay, so I'm reading Advanced topics in TaPL, and in chapter 2, Figure 2-1,
00:16:34 <sanjoyd> they talk about `Tau |- *` (rule WF-STAR).  What does it mean?
00:16:51 <sanjoyd> Which type's kind are they talking about?
00:21:28 <sanjoyd> http://i.imgur.com/rHbvC.png
00:21:41 <Dildeaux> I am upset over the Trayvon Martin case
00:21:47 <Dildeaux> it is an injustice!
00:21:51 <Dildeaux> That is why I am venting steam over at
00:21:53 <Dildeaux> chimpout
00:21:54 <Dildeaux> .com
00:21:57 <Dildeaux>  /forum
00:22:15 <Botje> Dildeaux: go away.
00:22:48 <Dildeaux> George Zimmerman deserves a medal!
00:23:00 <Dildeaux> he just made Florida a little bit safer
00:23:12 <Dildeaux> he doesn't deserve this media crucifixtion
00:23:27 <Dildeaux> chimpout
00:23:28 <Dildeaux> .com
00:23:31 <Dildeaux>  /forum
00:48:20 <dekudekuplex> help
00:48:52 <Botje> Please state the nature of the Haskell emergency.
00:48:59 <zhulikas> :DD
00:49:31 <Botje> wow, patient person.
00:49:41 <c_wraith> 10 seconds, gone
00:49:58 <Botje> I ignore joins/parts/quits in big channels
00:50:06 <Botje> so this kind of stuff happens to me occasionally.
00:50:08 <Botje> oh well :)
01:04:29 <fgomez> Just watched Mark Lentczner google tech talk, want to learn Haskell now : (
01:04:39 <Mihai00> !keep Mihai00
01:04:59 <Veinor> fgomez: do it
01:05:40 <Botje> fgomez: you say that like it's a bad thing.
01:05:53 <fgomez> Veinor: do you know of any good book to start from
01:06:01 <Botje> @where lyah
01:06:02 <lambdabot> http://www.learnyouahaskell.com/
01:06:12 <fgomez> Botje: It's just a bad thing because I don't think I really have the time for it right now
01:06:14 <Veinor> lyah is great
01:06:42 <Botje> fgomez: buy the book, read it on the toilet.
01:06:50 <Botje> or when you're waiting for a bus.
01:07:05 <fgomez> Botje: that's what I will do
01:07:35 <Botje> :)
01:23:38 <t7> does unification have any other applications other than type inference?
01:24:54 <Botje> prolog uses it extensively.
01:25:09 <companion_cube> it's a central concept in computational logic
01:25:25 <Botje> pattern matching in haskell is a handicapped form of unification
01:25:40 <Botje> (since you can't do f x x = ... )
01:26:12 <companion_cube> and you can't have variables on the right side
01:26:46 <t7> how does haskell turn a = b; b = a into a term?
01:27:03 <t7> using fix ?
01:27:39 <Botje> t7: you should read 'the implementation of functional programming languages' if you're interested in this stuff
01:28:09 <Botje> they step you through building a compiler for miranda (a predecessor of haskell, but it's very similar)
01:28:30 <t7> i have my hindley milner iference working
01:28:35 <t7> without let polymorphism
01:28:49 <t7> but i cant define mutual recursion or whatever :(
01:29:37 <Botje> well, they explain how they do it
01:29:56 <Botje> organizing a big list of collections into nested let / letrecs
01:30:07 <Botje> @where ifp
01:30:07 <lambdabot> I know nothing about ifp.
01:30:11 <Botje> hmm. nope.
01:30:18 <Botje> @where ifpl
01:30:19 <lambdabot> I know nothing about ifpl.
01:30:24 <t7> brb in 2 days reading a whole book
01:30:39 <Botje> @where+ ifpl http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
01:30:40 <lambdabot> I will remember.
01:31:11 <t7> i wonder if i can buy this on amazon or something
01:32:31 <statusfailed> Is there a matrix library for the "Accelerate" package?
01:33:26 <Botje> t7: it's out of print, so probably only at ruinous prices.
01:33:38 <t7> your right, £62
01:45:01 <t7> @hoogle find'
01:45:02 <lambdabot> No results found
01:45:38 <t7> > find (== 10000) [1..]
01:45:39 <lambdabot>   Just 10000
01:45:45 <t7> > find (== 1000000) [1..]
01:45:47 <lambdabot>   Just 1000000
01:46:04 <t7> no space leak :) ?
01:46:23 <shachaf> Why would it have a space leak?
01:46:35 <shachaf> Well, if you keep the head of the list around it won't be GCed.
01:48:28 <Peaker> > let xs = [1..] in (find (== 1000000) xs, head xs)
01:48:29 <lambdabot>   (Just 1000000,1)
01:49:05 <shachaf> t7: If find' is by analogy to foldl', though, I'm not sure what you intend it to do exactly.
01:49:30 <t7> me neither, after having a little think about it
01:52:21 <t7> @hoogle a -> (a, a)
01:52:21 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
01:52:21 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
01:52:22 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
01:52:47 <t7> @hoogle (a -> a -> b) -> a -> b
01:52:47 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
01:52:47 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
01:52:47 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
01:53:02 <shachaf> @ty join :: (a -> a -> b) -> a -> b
01:53:03 <lambdabot> forall a b. (a -> a -> b) -> a -> b
01:53:30 <t7> > join (+) 2
01:53:31 <lambdabot>   4
02:07:11 <Peaker> > Data.Traversable.sequenceA (1, Just 2)
02:07:12 <lambdabot>   No instance for (Data.Traversable.Traversable ((,) t))
02:07:12 <lambdabot>    arising from a us...
02:07:20 <Peaker> > Data.Traversable.sequenceA (Just (1, 2))
02:07:21 <lambdabot>   Ambiguous type variable `t' in the constraints:
02:07:21 <lambdabot>    `GHC.Num.Num t'
02:07:21 <lambdabot>      ari...
02:07:38 <Peaker> > Data.Traversable.sequenceA (Just ([], 2))
02:07:39 <lambdabot>   ([],Just 2)
02:08:34 <Peaker> I wonder what a better name for sequenceA would be.. insideOut maybe?
02:09:35 <t7> insideOutMaybe
02:10:22 <Peaker> It's not just for Maybe's
02:10:44 <t7> insideOutMaybeT
02:10:57 <Peaker> @type Data.Traversable.sequenceA (Just getLine)
02:10:58 <lambdabot> IO (Maybe String)
02:11:04 <Peaker> @type Data.Traversable.sequenceA [getLine]
02:11:06 <lambdabot> IO [String]
02:16:22 <ClaudiusMaximus> > Data.Traversable.sequenceA ["hat","coat"]
02:16:23 <lambdabot>   ["hc","ho","ha","ht","ac","ao","aa","at","tc","to","ta","tt"]
02:16:43 <hiptobecubic> combinations?
02:16:46 <ClaudiusMaximus> hm, not what i expected
02:16:56 <ClaudiusMaximus> but seems logical enough
02:17:44 <hiptobecubic> @src Data.Traversable.sequenceA
02:17:45 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
02:33:52 <t7> ah let rec has > 1 definitions
02:34:58 <lambda_zero_cool> silly question - anyone know how to do a conditional assignment?
02:35:41 <sanjoyd> lambda_zero_cool: what is an assignment?
02:35:43 <Lemmih> lambda_zero_cool: You don't.
02:35:59 <lambda_zero_cool> sanjoyd: e.g., bind a variable to a value
02:35:59 <sanjoyd> You can do let x = (if c then a else b) in ...
02:36:11 <sanjoyd> > let m = if true then 0 else 1 in m + 1
02:36:12 <lambdabot>   Not in scope: `true'
02:36:15 <sanjoyd> > let m = if True then 0 else 1 in m + 1
02:36:16 <lambdabot>   1
02:36:19 <sanjoyd> lambdabot: ^
02:36:23 <sanjoyd> lambda_zero_cool: ^
02:36:38 <sanjoyd> But that isn't "assignment", really.
02:36:51 <Botje> it's single assignment at best :)
02:36:57 <sanjoyd> The expression `if True then 0 else 1` evaluates to 0.
02:37:13 <sanjoyd> And you're binding m to that.
02:38:52 <lambda_zero_cool> yes, this makes sense, thanks!
02:38:55 <lambda_zero_cool> sanjoyd++
02:51:11 <lambda_zero_cool> another silly question - i want to unconditionally perform one *action* (rendering some graphics), but conditionally perform some other action. is there a convenient way to do this?  I know you can't have "if" without "else," but all i see is repeating code xD
02:51:28 <Botje> :t when
02:51:29 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:54:28 <ClaudiusMaximus> :t unless
02:54:29 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:59:58 <t7> @src when
02:59:59 <lambdabot> when p s = if p then s else return ()
03:00:32 <JerryKwan> is any haskell books to recommend?
03:02:00 <osfameron> JerryKwan: Learn You a Haskell.  Real World Haskell.
03:02:35 <bitonic> @where LYAH
03:02:35 <lambdabot> http://www.learnyouahaskell.com/
03:02:44 <bitonic> JerryKwan: LYAH is much better as a first book
03:04:41 <JerryKwan> anybody known about the SNAP framwork?
03:05:14 <statusfailed> JerryKwan: They have a channel, I think it's #snap-framework
03:05:27 <ozataman_> JerryKwan: #snapframework
03:05:32 <statusfailed> so clos e:
03:05:38 <ozataman_> statusfailed: :)
03:05:55 <egomes> Hi! The command "cabal sdist" gives the following error: "cabal: dist/src/sdist.-5642/diagrams-svg-0.2: does not exist". Can anyone help me?
03:06:20 * hackagebot natural-numbers 0.1.1.1 - Natural numbers  http://hackage.haskell.org/package/natural-numbers-0.1.1.1 (WolfgangJeltsch)
03:08:13 <ClaudiusMaximus> egomes: i seem to recall that being down to cabal-install being linked to an incompatible Cabal library - or something along those lines
03:10:35 <lambda_zero_cool> man, i wanted to recommend JerryKwan The Haskell School of Expression
03:10:59 <lambda_zero_cool> it's good in conjunction with learn you, cuz it gives you rudamentary IO tools early on - something too many tutorials neglect
03:11:02 <ClaudiusMaximus> egomes: 07:35:25 <dcoutts> Philonous: your cabal-install is built with the wrong version of the Cabal lib. You or someone has adjusted the .cabal file for cabal-install-0.10.x so that it'd build against Cabal-1.12 or later.
03:12:34 <egomes> ClaudiusMaximus: Thanks, I'll check the .cabal file.
03:12:39 <cheater> > when True "asdf"
03:12:40 <lambdabot>   Couldn't match expected type `()'
03:12:40 <lambdabot>         against inferred type `GHC.Types....
03:12:46 <cheater> > type when
03:12:47 <lambdabot>   <no location info>: parse error on input `type'
03:12:50 <cheater> er
03:12:52 <cheater> @type when
03:12:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:13:03 <cheater> why do i think "when" is a useless function?
03:13:07 <obk> Is there a way in HUnit to assert that a pure computation results in an error?
03:13:09 <t7> "rostayob: I was a type constructor, then I took an arrow in the kind" hohoho
03:15:27 <statusfailed> cheater: are you asking what it's for?
03:17:06 <lambda_zero_cool> cheater: you can use it for cool things like debugging.  "when debug print stuff"
03:18:40 <statusfailed> I think it's meant for monads like IO- I suppose it is quite useless on say the List monad
03:18:51 <bitonic> cheater: I don't know. when is a useful shorthand.
03:20:09 <bitonic> I used "when" and "unless" very often
03:20:14 <ClaudiusMaximus> @hoogle Monad m => Bool -> m a -> m (Maybe a)
03:20:15 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
03:20:15 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
03:20:15 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
03:36:27 <yasar> So monads were nothing more than type classes huh?
03:36:57 <mauke> haha
03:37:01 <t7> :t a = b; b = a; a
03:37:01 <lambdabot> parse error on input `='
03:37:13 <t7> :t let a = b; b = a in a
03:37:14 <lambdabot> forall t. t
03:37:16 <mauke> so primes were nothing more than integers huh?
03:37:47 <mauke> make that 'ints'
03:39:20 <yasar> Things I read made me nervous about them, but I don't think they are that complex.
03:39:40 <mauke> they aren't
03:40:21 <mauke> best example: [] is an instance of Monad
03:40:39 <mauke> > join [[1,2], [], [3]]
03:40:40 <lambdabot>   [1,2,3]
03:41:26 * hackagebot hakyll 3.2.7.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.7.0 (JasperVanDerJeugt)
03:42:07 <Entroacceptor> > mapM (return . (+1)) [1,2,3]
03:42:07 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
03:42:08 <lambdabot>    arising from a use of `M15650826...
03:42:28 <mauke> doesn't know which monad you want
03:42:38 <Entroacceptor> yeah, I'm confused
03:44:43 <Entroacceptor> I wanted
03:44:44 <Entroacceptor> > [1,2,3] >>=return . (+1)
03:44:45 <lambdabot>   [2,3,4]
03:45:00 <mauke> >>= return . is liftM
03:47:57 <t7> bitonic: does your Type inference stuff do recursive defs?
03:48:03 <t7> i need to take another look
03:49:06 <bitonic> t7: it has a fixed point combinator
03:49:16 <bitonic> so you can easily write a letrec if you want
03:50:55 <bitonic> I mean the fixed point combinator I have is basically a letrec
04:00:14 <egomes> ClaudiusMaximus: It didn't work! I've cleaned the .cabal and .ghc, re-installed the ghc 7.4.1 and cabal-install-10.4-3 package (archlinux)
04:00:27 <ClaudiusMaximus> egomes: yes, archlinux cabal-install is broken
04:00:32 <ClaudiusMaximus> you need cabal-install from darcs
04:00:34 <ClaudiusMaximus> if you want a cabal-install that works with ghc-7.4.1
04:11:29 * hackagebot idris 0.9.2.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.2.1 (EdwinBrady)
04:17:05 <t7> bitonic: so for fix you just set the id type to a fresh variable and unify?
04:18:31 <gnoi> Is ross@soi.city.ac.uk alive? I'm waiting for hackage account during 3 days ;_;
04:18:39 <ClaudiusMaximus> :t (let a = b ; b = a in (a, b), fix (\(a,b) -> (b,a)))
04:18:40 <lambdabot> forall t t1 t2. ((t, t1), (t2, t2))
04:19:27 <t7> fix x : t0 in x  = t0
04:20:46 <ClaudiusMaximus> i'm puzzled by that, why does the first not unify the types of a and b
04:21:24 <t7> ClaudiusMaximus: i thought it would
04:21:26 <t7> :|
04:27:28 <bitonic> t7: note that in my thing "fix" is a keyword
04:28:03 <t7> i can check if binding_name is free in binding_expression
04:28:06 <bitonic> that works like this: "fix v . ..." where ... is an expression, and v is the recursive var you're binding. the type of 'v' is initialized to forall a. a
04:28:07 <t7> and chuck a free in
04:28:12 <bitonic> so the most general one
04:28:22 <t7> fix*
04:28:40 <bitonic> t7: I don't know what "binding_name" and "binding_expression" is
04:28:50 <bitonic> t7: https://github.com/bitonic/ml-w/blob/master/TypeInfer.hs#L210
04:28:53 <t7> foo = 1 + foo
04:29:10 <t7> when i compile higher level language down to lambda calc
04:30:09 <bitonic> in my little language foo = 1 + foo would be 'fix foo . 1 + foo'
04:31:32 <t7> bitonic: have you tried implementing this with debruijn indexes rather than names in context?
04:31:38 <ClaudiusMaximus> hm, same behaviour in hugs - odd, can anyone explain?
04:32:15 <bitonic> t7: names aren't that annoying to handle when type checking, so I use a named representation
04:32:50 <t7> im probably making more work for myself
04:33:04 <t7> :t (let a = b ; b = a in [a, b], fix (\(a,b) -> (b,a)))
04:33:05 <lambdabot> forall t t1. ([t], (t1, t1))
04:33:29 <bitonic> names are really annoying when doing beta-reduction, since you have to do alpha-renaming, while with indices it's much easier
04:34:09 <t7> ah true
04:34:21 <ClaudiusMaximus> also, it seems that there is no 'fix' in any haskell98 module - strange..
04:34:36 <bitonic> ClaudiusMaximus: what behaviour?
04:34:40 <ClaudiusMaximus> :t (let a = b ; b = a in (a, b), fix (\(a,b) -> (b,a)))
04:34:41 <lambdabot> forall t t1 t2. ((t, t1), (t2, t2))
04:35:18 <ClaudiusMaximus> i'd expect ((t1,t1),(t2,t2))  (ie, a and b get unified to the same type)
04:35:37 <t7> :t let a = undefined in (a, a)
04:35:38 <lambdabot> forall a a1. (a, a1)
04:36:04 <t7> they dont because they are polymorphicly(sp?) defined
04:36:48 <bitonic> ClaudiusMaximus: 'a' and 'b' are both forall a. a
04:37:05 <bitonic> :t let a = b; b = a; in (a, b)
04:37:06 <lambdabot> forall t t1. (t, t1)
04:37:12 <bitonic> ClaudiusMaximus: they're both undefined basically.
04:37:19 <bitonic> they inhabit every type
04:37:35 <ClaudiusMaximus> right.  i should know this, having done silly things like...
04:38:01 <ClaudiusMaximus> > let a :: Num a => a ; a = 5 in (a :: Int, a :: Double)
04:38:02 <lambdabot>   (5,5.0)
04:38:08 <ClaudiusMaximus> in real projects
04:39:23 <t7> am i a PL god now that i can implement Hindley-Milner?
04:40:00 <yasar> I have finished LYAH (except for zippers part), should I move on to real world haskell now, or would you suggest somewhere else?
04:41:23 <Ptival> t7: I think a dependent type checker is the next step
04:41:48 <t7> impossibru
04:41:50 <bitonic> yasar: you should move to implement some medium-sized thing with haskell :P
04:43:26 <ClaudiusMaximus> i wouldn't read the whole of real world haskell in order, though i find it useful to read a chapter online on a particular topic when i get stuck on something related
04:43:26 <yasar> bitonic: I was thinking likewise actually. But then, I couldn't think of anything. Maybe anyone can suggest something?
04:43:31 <Ptival> t7: haha, yes impossibru :(
04:43:54 <luite> some medium sized thing like a haskell compiler, web framework or revision control system
04:44:36 <bitonic> yasar: I don't know. The thing I usually suggest is a parser/interpreter for some language
04:45:11 <bitonic> some little language :)
04:45:22 <luite> C++
04:45:50 <bitonic> ehe.
04:45:50 <t7> C++ with the new type class things on templates
04:46:32 <yasar> Hmm, those sounds like big projects to me actually.
04:48:05 <bitonic> yasar: writing a little interpreter is not a big project, trust me
04:48:25 <ClaudiusMaximus> at least for some little language like untyped lambda calculus or brainfuck
04:48:45 <bitonic> no even something that you can do meaningful stuff with
04:49:03 <bitonic> brainfuck is probably 50 lines :P
04:49:06 <ClaudiusMaximus> my life is devoid of meaning :'(
04:49:33 <t7> untyped is a really fun first project
04:50:45 <bitonic> yeah but... not medium sized
04:51:02 <t7> turn it into a real language like python
04:55:09 <hiptobecubic> contribute something meaningful. make an IRC bot
04:55:53 <ClaudiusMaximus> an emulator for an ancient games console might be fun
04:55:55 <t7> write a bitcoin node in haskell, because roconnor gave up
04:56:21 <hiptobecubic> t7, add uninstall to cabal
04:56:35 <t7> thats a good idea
04:56:42 <dcoutts> yep, would be nice
04:56:49 <hiptobecubic> would be *great*
04:57:19 <mrcarrot> uninstall++
05:04:54 <t7> termination checker
05:06:45 <mreh> i'm reading the template haskell paper
05:06:58 <mreh> the printf example doesn't look right to me
05:07:22 <mrcarrot> a graphical version of NIM. https://en.wikipedia.org/wiki/Nim
05:07:38 <mrcarrot> nim is very easy to implement
05:07:54 <t7> why stop there? a multiplayer nim server
05:07:58 <t7> with bitcoin betting
05:08:04 <t7> web server*
05:08:14 <Blkt> good day everyone
05:08:30 <mreh> it is, nice and sunny
05:08:38 <hiptobecubic> mreh, not here.
05:08:40 <mrcarrot> here it is raining
05:08:48 <mreh> i have one thing to say
05:08:50 <mrcarrot> and i have to walk home after 50 mintures
05:08:52 <mreh> "haha"
05:09:07 <mrcarrot> minutes*
05:09:09 <Blkt> ahahah
05:09:12 <nart> ciao :)
05:09:13 <ClaudiusMaximus> here is in drought
05:09:55 <mreh> meteor showers anyone?
05:10:32 <egomes> ClaudiusMaximus: Thanks a lot :) I've installed cabal-install from darcs and worked flawless.
05:10:54 <ClaudiusMaximus> egomes: :)
05:11:28 <mreh> may I direct you to SPJs TH paper, section 2, the implementation of printf with arbitarily many substitution parameters
05:12:03 <mreh> I don't understand how Expr can't be polymorphic
05:12:56 <mreh> he's returning quoted function and then splicing them in as if they were strings
05:12:58 <mreh> i don't get it
05:13:13 <bitonic> mreh: I read that paper a while ago and it made sense. note that now things are different
05:13:17 <bitonic> but the core concepts stand
05:14:03 <arossouw> new to haskell, what is haskell most practical for?
05:14:23 <mreh> hard to answer
05:14:27 <arossouw> ok
05:14:36 <mreh> tell us what you want to do
05:14:42 <mreh> that would be an easier approach for us
05:14:50 <arossouw> lets say text parsing and replacing shell scripts
05:14:59 <bitonic> arossouw: Haskell is very general purpose.
05:15:03 <rekado_> Hi, does anyone know how to use the package Bindings.Gpgme?
05:15:04 <arossouw> ok
05:15:08 <bitonic> mreh: I'm rereading the paper now, what's the problem?
05:15:22 <mreh> bitonic: section 2 "The Basic idea"
05:15:28 <arossouw> see lots of python talking about haskell being really cool
05:15:36 <arossouw> s/python/python developers
05:15:41 <mreh> bitonic: the last code definition in the second column
05:15:57 <bitonic> @faq is Haskell "really cool"?
05:15:57 <lambdabot> The answer is: Yes! Haskell can do that.
05:16:06 <mreh> heh
05:16:35 <arossouw> isn't code harder to maintain when you use for example map , filter and lambda?
05:16:38 <yasar> What kind of IDE/Editor do you use to develop in haskell?
05:16:49 <mreh> yasar: vim
05:16:53 <bitonic> yasar: emacs
05:16:53 <rekado_> yasar: vim
05:16:54 <Botje> arossouw: why would it be?
05:16:59 <mauke> arossouw: what would you use instead?
05:17:01 <arossouw> readability
05:17:07 <bitonic> mauke: so the function "gen"? It looks all right to me
05:17:29 <hpaste> enu pasted “type problem” at http://hpaste.org/66162
05:17:38 <rekado_> http://hackage.haskell.org/packages/archive/bindings-gpgme/0.1.4/doc/html/Bindings-Gpgme.html
05:17:47 <enu> can someboedy help me out with simple function typing?
05:18:01 <mreh> bitonic: okay, i'm glad it's just me
05:18:05 <Botje> arossouw: why ou
05:18:08 <mreh> thanks
05:18:08 <rekado_> has anyone here successfully used bindings-gpgme before?
05:18:25 <Botje> why would you say they're less "readable" ?
05:18:48 <mauke> Botje: I'd focus on "less"
05:18:54 <bitonic> mreh: what's not clear?
05:18:56 <enu> -- why does this work in ghci?  let getF = return ["bla","bla"] :: IO [FilePath]
05:18:56 <arossouw> guess its just bit difficult to grasp for a beginner, find python easier to understand
05:19:08 <mreh> bitonic: my mind, it's all rather new
05:19:12 <enu> and this not? let getF x y = return ["bla","bla"] :: FilePath -> [FilePath] -> IO [FilePath]
05:19:18 <mauke> arossouw: er, what you listed were python functions
05:19:30 <Botje> arossouw: quick, what does for (x = 0; x < 10; x ++) { if (x.even) { sum += x} } do?
05:19:33 <pengw> hi all
05:19:34 <mauke> enu: because one is right and the other isn't?
05:19:41 <arossouw> mauke: sure but Guodo's philosphy says simple is better than complex
05:19:47 <mauke> arossouw: ok, and?
05:19:50 <Botje> arossouw: as compared to sum (filter even list)
05:19:50 <ClaudiusMaximus> @wiki FAQ
05:19:50 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
05:20:27 <arossouw> for example using if  then and alse is easier , for me to understand
05:20:36 <enu> mauke: could you just point me out what exactly is wrong? can't I add arbitrary parameter to a function and give it a type?
05:20:36 <mauke> arossouw: easier than what?
05:20:41 <rekado_> arossouw: there's if then and else in haskell
05:20:47 <arossouw> ok
05:20:53 <mauke> enu: return ["bla","bla"] is not a function
05:20:58 <arossouw> rekado_: thats not functional though
05:21:04 <mauke> arossouw: why not?
05:21:06 <mreh> i remember guido's rant against tail call optimisation
05:21:09 <rekado_> arossouw: why would you say that?
05:21:11 <arossouw> functional approach
05:21:16 <arossouw> sorry, wrong wording
05:21:23 <mauke> arossouw: wrong understanding
05:21:26 <Botje> arossouw: what do you call 'functional' ?
05:21:42 <arossouw> from what i understand lambda, maps, list comprehensions
05:21:55 <mauke> ...
05:22:05 <mreh> go easy on him
05:22:08 <arossouw> dont know the rest
05:22:17 <Botje> arossouw: and you don't think if-then-else fits into that picture?
05:22:17 <mux> yes, no need to harp on him so harshly, he's obviously new to this
05:22:22 <arossouw> i'll just read up more on haskell, should get it after couple of months
05:22:23 <mauke> arossouw: "functional" isn't a list of functions you memorize
05:22:30 <enu> mauke: I see.. I actually want to express something like this : let ( getF x y = return ["bla","bla"] ) :: FilePath -> [FilePath] -> IO [FilePath]
05:22:46 <quicksilver> enu: put the signature before the definition.
05:22:59 <mauke> enu: you have 2.5 ways to do that
05:23:08 <quicksilver> let getF :: FilePath -> [FilePath] -> IO [FilePath]; getF x y = return [..];
05:23:10 <enu> how to do this in the interpreter?
05:23:15 <bitonic> where is chrisdone haskell-emacs gone?
05:23:17 <arossouw> mauke: ok, i need more understanding of the terminology then, will read up
05:23:21 <mauke> enu: #1 is what quicksilver said
05:23:24 <quicksilver> enu: just like I just did.
05:23:37 <quicksilver> > let a :: Int; a = 5 in a + 1
05:23:38 <lambdabot>   6
05:23:39 <mauke> enu: #2: let getF = (\x y -> return ["bla","bla"]) :: FilePath -> [FilePath] -> IO [FilePath]
05:23:46 <quicksilver> ^^ example of the general style.
05:24:02 <arossouw> so is it good idea to replace shell scripts with haskell, or is it just overcomplicating stuff
05:24:05 <mauke> enu: #2.5: let getF x y = return ["bla","bla"] :: IO [FilePath]
05:24:20 <enu> I see :) thank you very much!
05:24:22 <enu> well
05:24:29 <enu> I am a bit confused with the last one
05:24:37 <rekado_> arossouw: depends on the task. I don't use it for shell scripting.
05:24:42 <arossouw> ok
05:24:42 <enu> is it now a->b->IO [FilePath]?
05:24:44 <mauke> arossouw: note that Guido literally does not understand functional programming
05:24:55 <mauke> :t let getF x y = return ["bla","bla"] :: IO [FilePath] in getF
05:24:56 <lambdabot> forall t t1. t -> t1 -> IO [FilePath]
05:25:02 <quicksilver> s/functional//;
05:25:10 <mauke> quicksilver: oh?
05:25:16 <arossouw> lets say i want to compare 2 different databases with the same structure's primary key count with each other
05:25:20 <quicksilver> mauke: well I'm just being rude, to be honest.
05:25:23 <quicksilver> mauke: but he started it :)
05:25:32 <rekado_> arossouw: it is possible to write shell scripts, but I found haskell's purity to be more limiting in these situations.
05:25:32 <arossouw> mauke: ok
05:25:35 <ClaudiusMaximus> arossouw: see http://hackage.haskell.org/package/HSH perhaps
05:26:13 <mauke> quicksilver: I'm referring to http://www.reddit.com/r/haskell/comments/lxoo0/guido_van_rossums_criterion_for_when_a_language/
05:26:42 <arossouw> ClaudiusMaximus: thanks, will give it a try
05:27:14 <bitonic> @msg chrisdone Is haskell-emacs still going? The github page is gone...
05:27:14 <lambdabot> Not enough privileges
05:27:21 <bitonic> uff. how did this work again?
05:27:24 <bitonic> @help msg
05:27:24 <lambdabot> msg <nick or channel> <msg>
05:27:24 <quicksilver> bitonic: you mean @tell
05:27:31 <bitonic> quicksilver: thanks
05:27:37 <arossouw> quicksilver: interesting
05:27:37 <bitonic> @tell chrisdone Is haskell-emacs still going? The github page is gone...
05:27:38 <lambdabot> Consider it noted.
05:27:39 <mauke> or @ask
05:27:43 <quicksilver> but, chrisdone is AWOL, I think
05:27:49 <quicksilver> preflex: seen chrisdone
05:27:49 <preflex>  chrisdone was last seen on #haskell 15 hours, 57 minutes and 22 seconds ago, saying: luite's project has military backing and more security on its internals than the Iron Man suit
05:27:54 <quicksilver> oh, he's back :)
05:27:55 <quicksilver> yay.
05:28:18 <rekado_> I'm totally new to FFI; would someone please help me with this type:
05:28:20 <mreh> heh, AWOL
05:28:23 <mreh> how appropriate
05:28:29 <ClaudiusMaximus> https://github.com/haskell/haskell-mode maybe
05:28:36 <rekado_> p'gpgme_new :: FunPtr (Ptr sth1 -> IO sth2)
05:28:41 <bitonic> ClaudiusMaximus: oh. thanks
05:28:55 <bitonic> ClaudiusMaximus: isn't that the normal haskell-mode?
05:28:55 <hiptobecubic> i just found ghc-mod this morning. haven't tried it yet but it looks quite superior.
05:28:57 <rekado_> what does it do?
05:29:38 <luite> bitonic: I think he just renamed the repository
05:30:17 <quicksilver> bitonic: ah yes there was an email message about this
05:30:24 <mauke> rekado_: looks like a pointer to a function that takes a pointer and has side effects
05:30:54 <rekado_> mauke: does that mean it is a pointer to an external function? or a haskell function?
05:30:58 <bitonic> luite, quicksilver: yeah but that haskell-mode looks like the straight, elisp only haskell mode. I thought that his haskell-emacs did more stuff using GHC
05:31:06 <enu> @pl getCount x y = liftM length $ getF x y
05:31:06 <lambdabot> getCount = (fmap length .) . getF
05:31:07 <mauke> rekado_: either
05:31:11 <quicksilver> haskell-mode-exts
05:31:15 <rekado_> mauke: oh, ok. thanks.
05:31:18 <quicksilver> was the name of chrisdone's repo, I think
05:31:31 <hiptobecubic> http://www.mew.org/~kazu/proj/ghc-mod/en/
05:32:02 <bitonic> hiptobecubic: yeah I already use that :)
05:32:15 <bitonic> what I'm looking for is easy jumping to definitions
05:32:17 <quicksilver> bitonic: https://github.com/chrisdone/emacs ?
05:32:34 <hiptobecubic> bitonic, emacs doesn't have that already, in general?
05:32:37 <hiptobecubic> based on tags perhaps?
05:32:44 <quicksilver> bitonic: but also if you look at chrisdone's github page he's actively committing to haskell/haskell-mode
05:32:51 <quicksilver> yes, it does, hiptobecubic
05:33:08 <quicksilver> hiptobecubic: but perhaps bitonic hopes for somethign smarter which understands the difference between two functions called 'foo' ?
05:33:11 <bitonic> yeah with tags, but I'd like something better
05:33:13 <bitonic> quicksilver: yes
05:33:15 <quicksilver> which plain old TAGS can't do.
05:33:31 <quicksilver> well you could fully qualify the in the tags file, of course
05:33:33 <bitonic> I'm really getting used to agda-mode, which is awesome. we really need something like that...
05:33:38 <quicksilver> but you'd still need smarts to work out what is what.
05:36:02 <quicksilver> bitonic: anyhow, this is one of chrisdone's two posts to haskellmode-emacs ; http://projects.haskell.org/pipermail/haskellmode-emacs/2010-August/000083.html
05:36:20 <quicksilver> bitonic: but I suspect the things he was working on are now either in haskell/haskell-mode or chrisdone/emacs
05:37:50 <bitonic> quicksilver: ok, thanks.
05:39:53 <hpaste> nart pasted “Conduit test” at http://hpaste.org/66163
05:40:17 <nart> why in ^^ i get Right ( Right <num here >)
05:40:28 <nart> a right inside a right, why ? :S
05:40:46 <nart> while when it throws the exception i only get one Left
05:40:46 <bitonic> btw, I remember there being various etags generator for Haskell. is there a "best" one?
05:42:09 <rekado_> Hmm, in the low-level bindings to GPGME there's a function c'gpgme_new that takes a pointer and does IO.
05:42:24 <rekado_> c'gpgme_new :: Ptr C'gpgme_ctx_t -> IO C'gpgme_error_t
05:42:52 <rekado_> There is no function that returns a pointer, so I suppose I have to magically create a pointer.
05:43:09 <quicksilver> nice. Those names make it look like you're having a coughing fit
05:43:20 <osfameron> Ie! Ie! phtagn
05:43:20 <rekado_> How could I get the required pointer?
05:43:32 <rekado_> quicksilver: It's Klingon, I think
05:43:45 <rekado_> http://hackage.haskell.org/packages/archive/bindings-gpgme/0.1.4/doc/html/Bindings-Gpgme.html
05:43:52 <quicksilver> trying to decode the klingon
05:44:03 <quicksilver> that is presumably a "Pointer to a C gpgme context"
05:44:13 <rekado_> the prefix c' just means that it's a C function.
05:44:17 <quicksilver> I doubt you're supposed to malloc that empty.
05:44:25 <quicksilver> I expect you're supposed to call new context, or something?
05:44:39 <rekado_> quicksilver: well, that would be this very function.
05:44:47 <quicksilver> oh I see
05:44:50 <quicksilver> it's pass by reference
05:44:52 <rekado_> it's a direct translation of the GPGME lib.
05:44:54 <quicksilver> it really is a low level binding
05:45:07 <quicksilver> just use one of the functions from Foreign, rekado
05:45:07 <rekado_> here's the original: http://pyme.sourceforge.net/doc/gpgme/Creating-Contexts.html#Creating-Contexts
05:45:14 <quicksilver> @hoogle malloc
05:45:15 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
05:45:15 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
05:45:16 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
05:45:25 <quicksilver> possibly the first one there.
05:45:27 <rekado_> quicksilver: oh my...
05:45:40 <rekado_> quicksilver: thank you.
05:45:56 <rekado_> quicksilver: I really didn't intend to write C in haskell :-/
05:47:07 <quicksilver> since the context is just an int, you only need the pointer for a moment, I guess
05:47:36 <quicksilver> so you can write a nicer "gpgme_new :: IO C'gpgme_ctx_t"
05:48:10 <rekado_> quicksilver: apparently, I need to pass the pointer again and again to other functions.
05:48:41 <quicksilver> I don't think so rekado_
05:48:47 <quicksilver> I just searched through the docs
05:48:58 <quicksilver> all the other functions take a C'gpgme_ctx_t not a (Ptr C'gpgme_ctx_t)
05:49:14 <rekado_> quicksilver: oh yes, you are right.
05:49:33 <rekado_> quicksilver: I looked at the p'... functions and thought otherwise.
05:49:51 <rekado_> quicksilver: don't think I'll have to use those prefixed with p'.
05:50:35 <quicksilver> alloca ( \p -> err <- c'gpgme_new p; if error return Nothing else ctx <- peek p; return (Just ctx) )
05:50:38 <quicksilver> rekado_: ^^
05:50:52 <quicksilver> rekado_: that should have type IO :: Maybe C'gpgme_ctx_t
05:50:59 <quicksilver> and it returns one if it can, or 'Nothing' in case of error.
05:51:07 <quicksilver> except I don't actually know how to check for error.
05:51:15 <quicksilver> the 'if errro' part is pseudo code :)
05:51:21 <rekado_> :t peek
05:51:22 <lambdabot> Not in scope: `peek'
05:51:25 <quicksilver> it might be as simple as "if err != 0"
05:51:29 <quicksilver> @hoogle peek
05:51:29 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
05:51:29 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
05:51:29 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
05:51:39 <rekado_> quicksilver: ah, I see.
05:51:40 <quicksilver>  /= rather
05:51:46 <quicksilver> damn switching language contexts.
05:51:55 <rekado_> quicksilver: hehe
05:52:34 <quicksilver> the point is that 'alloca' allocates temporarily for a delimited scope
05:52:43 <quicksilver> so you don't forget to call free.
05:52:55 <quicksilver> on the other hand, you risk nasal daemons if you accidentally leak the pointer.
05:53:08 <rekado_> "nasal daemons"?
05:53:19 <quicksilver> it's an old C joke
05:53:23 <quicksilver> for undefined behaviour
05:53:37 <rekado_> ok.
05:53:45 <quicksilver> http://www.catb.org/jargon/html/N/nasal-demons.html
05:53:56 <quicksilver> 1992++ # great year for jokes
06:02:01 <mrBG> how do i resgister a nickname?
06:02:13 <Botje> /msg nickserv hello
06:02:16 <Botje> to get started, iirc
06:02:45 <hpc> /msg nickserv hello
06:02:49 <hpc> er
06:03:01 <hpc> /msg nickserv help
06:03:22 <hpc> hello just says "invalid command, try help"
06:03:34 <Botje> awww
06:03:39 <nart> here  class (Monad m) => MonadReader r m | m -> r where  what's the symbol | means ? or where i can find doc about it ?
06:03:50 <rekado_> quicksilver: thanks again, that really helped to get me started.
06:04:14 <hpc> nart: functional dependency
06:04:27 <hpc> 'm' uniquely determines 'r'
06:04:45 <nart> hpc: thanks, i'll read about it :)
06:04:56 <hpc> ie, for each 'm', you can't simultaneously have MonadReader foo m and MonadReader bar m
06:05:10 <ClaudiusMaximus> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
06:05:50 <nart> ClaudiusMaximus: ty
06:06:48 <nart> ah is it possible to get the source code of a function directly form ghci ?
06:08:07 <hpc> sometimes, iirc
06:08:11 <ClaudiusMaximus> no, but you can use :info to get the source code location for interpreted modules
06:08:21 <hpc> yeah, that
06:10:08 <db81> I colored my ghci a bit with 256 colors and found a way around the issue with readline and long lines. It can look kind of like this http://i.imgur.com/cTEpt.jpg . Do we need info about how to do that at http://www.haskell.org/haskellwiki/GHCi_in_colour ?
06:12:56 <rekado_> db81: nice!
06:21:40 <roconnor> xplat: I think Hinze's Generalizing Generalized Tries is wrong, or at least not quite right (though I'm only on page 12).
06:25:58 <Taneb> It seems the Leksah cabal package requires itself...
06:31:35 <bitonic> db81: I guess it wouldn't hurt!
06:31:41 <bitonic> db81: so yeah put it on the wiki
06:36:50 <ClaudiusMaximus> hm, some .ghci hacking, needs more work: *Main> :src main
06:36:50 <ClaudiusMaximus> main = do
06:37:12 <ClaudiusMaximus> needs some magic to show more than the first line...
06:42:49 <Younder> Lisp group can fuck themselves they are NOT getting funlib
06:43:04 <ski> "funlib" ?
06:43:57 <Younder> Yes, I wrote a library of functional programming based on my experiences with ML Haskell and Clojure
06:43:58 <roconnor> @time dibblego
06:43:59 <lambdabot> Local time for dibblego is Thu Mar 29 23:43:37
06:44:13 <Younder> I caled it funlib
06:44:24 <Younder> called
06:44:49 <Younder> I am a common lisper
06:45:31 <fxr> Younder: labs.core.gen.tr
06:45:48 <Younder> But these days I mostly write Haskell. A language I have come to know and love.
06:47:13 <Younder> Has anyone told you Haskell is a truly beautiful language?
06:47:52 <Younder> It has a beauty I never found in Lisp.
06:48:02 <fxr> great
06:48:35 <fxr> rewrite your projects in haskell and show us the difference
06:49:33 <Younder> fxr. NOP I am writing my own language in Haskell. I call it formula.
06:49:38 <tzxn3> http://pastebin.com/raSG0cCr
06:49:45 <mauke> The paste raSG0cCr has been copied to http://hpaste.org/66164
06:49:49 <tzxn3> anyone have any idea how to improve the IO code of this?
06:50:30 <tzxn3> it's not very nicely structured at the moment
06:50:52 <Younder> NO, it stinks
06:51:08 <luite> hm, some doesn't need to be in IO
06:51:40 <Younder> Isolate be bit's that need to be IO from the bit's that don't
06:51:58 <Younder> s/be/the
06:52:10 <tzxn3> what doesn't need to be IO?
06:52:18 <tzxn3> point me to a specific example
06:52:33 <luite> I'd try to move the shuffle function out of IO
06:52:41 <adnauseam> am i doing someting wrong with [ x | x <- [1..], x < 99] ?
06:52:44 <Younder> ahuffle
06:52:51 <Younder> shuffle
06:53:03 <adnauseam> the resulting list is stuck and ineed to ctrl-c it
06:53:07 <tzxn3> how would that be done?
06:53:16 <Younder> rawValue carToName
06:53:33 <Younder> replaceFirstItem
06:53:37 <adnauseam> > [ x | x <- [1..], x < 9]
06:53:38 <tzxn3> I used IO shuffle because it's easiest
06:53:41 <lambdabot>   mueval-core: Time limit exceeded
06:53:42 <tzxn3> :P
06:53:45 <adnauseam> hrm
06:53:46 <Entroacceptor> adnauseam: yes, the evaluation doesn't know it's ordered
06:53:53 <hpc> adnauseam: it can't see when the list is finished
06:53:54 <luite> tzxn3: use STArray instead, and either give it a random generator, or convert it to MonadRandom
06:54:05 <Entroacceptor> so it tries to evaluate the complete [1..] to check
06:54:06 <Younder> playerTurn should be seperated
06:54:09 <tzxn3> I wouldn't know where to begin using STArray
06:54:14 <Entroacceptor> why don't you use [1..99]?
06:54:16 <adnauseam> isn't x < 9 the end ?
06:54:24 <Younder> same with dealerTurn
06:54:32 <tzxn3> separate into what>?
06:54:39 <adnauseam> hm
06:54:40 <Younder> good luck
06:54:48 <adnauseam> > [ x | x <- [1..], x <= 9]
06:54:52 <lambdabot>   mueval-core: Time limit exceeded
06:55:01 <tzxn3> I don't really see how I'd separate it
06:55:09 <hpc> adnauseam: how does it know it should stop at 9?
06:55:23 <adnauseam> "x <= 9" ?
06:55:24 <hpc> there could be a smaller number later in the list
06:55:40 <Younder> you never asked it to , is paralell
06:55:50 <ion> adnauseam: [ x | x <- someReallyLongListIGaveYou, x <= 9 ]
06:55:54 <tzxn3> what simpler procedures could I decompose it into?
06:55:56 <ion> adnauseam: Should it stop at the first nine it encounters?
06:55:59 <hpc> (hint: ghc isn't magic)
06:56:16 <Younder> so x <_ [1..] and also x<=9 concurrently
06:56:17 <adnauseam> hmm
06:56:23 <owst> adnauseam: You've said take this list X and remove all those that x < 9 is true on. It has to check the whole list.
06:56:43 <adnauseam> oh
06:56:46 <Younder> DON'T d DO THAT
06:56:49 <ClaudiusMaximus> :t [filter, takeWhile]
06:56:50 <lambdabot> forall a. [(a -> Bool) -> [a] -> [a]]
06:57:05 <owst> It doesn't matter that the list you've given is in fact ordered such that once you've hit False, you'll never hit True again
06:57:43 <Entroacceptor> > take 10 [ x | x<-[1..], x<=9]
06:57:46 <adnauseam> a cockup with understanding laziness and list comp. on my part
06:57:47 <lambdabot>   mueval-core: Time limit exceeded
06:57:51 <tzxn3> I really don't know what I'm doing here
06:58:47 <Younder> Entroacceptor, still bad coding style I think
06:58:56 <Entroacceptor> I agree
06:59:02 <owst> > take 5 [ x | x <- [1..], x <= 9 ]
06:59:02 <lambdabot>   [1,2,3,4,5]
06:59:04 <tzxn3> I've tried to learn the state monad
06:59:10 <roconnor> @type maybe
06:59:11 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:59:12 <tzxn3> but I couldn't understand it
06:59:22 <tzxn3> even after thinking about it and going back
06:59:24 <adnauseam> > takeWhile (<10) [ x | x <- [1..]]
06:59:25 <lambdabot>   [1,2,3,4,5,6,7,8,9]
06:59:32 <adnauseam> \o/
06:59:34 <yasar> doesn't Maybe data constructor in Prelude? Why I am getting: Not in scope: data constructor `Maybe'
06:59:36 <Entroacceptor> > [1..99]
06:59:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:59:51 <hpc> @src Maybe
06:59:51 <lambdabot> data Maybe a = Nothing | Just a
06:59:52 <Entroacceptor> > [1..9]
06:59:53 <lambdabot>   [1,2,3,4,5,6,7,8,9]
06:59:58 <ion> Maybe is a type constructor, not a data constructor.
07:00:00 <hpc> @src Bool
07:00:01 <lambdabot> data Bool = False | True deriving (Eq, Ord)
07:00:27 <danr> @src Forest
07:00:27 <lambdabot> Source not found. You untyped fool!
07:00:37 <hpaste> yasar pasted “Maybe” at http://hpaste.org/66165
07:00:49 <Entroacceptor> danr: type Forest a = [Tree a]
07:01:00 <danr> Entroacceptor: thank you :)
07:01:04 <tzxn3> does anyone have any advice? I've read an awful lot on monads and I'ms till not really comfortable with them
07:01:04 <yasar> What am I doing wrong in above paste than?
07:01:08 <Entroacceptor> (from Data.Tree)
07:01:32 <ion> yasar: Look at the definition of Maybe. None of the two data constructors are named Maybe.
07:01:57 <yasar> Ohh, I see
07:02:04 <yasar> I should have used Just :)
07:03:36 <tzxn3> I mean, I understand chaining together IO actions
07:03:45 <tzxn3> but I find I don't really know how to apply it
07:03:56 <Younder> monads are a GREAT  source of confusion
07:04:09 <Axman6> only if you don
07:04:17 <Younder> quite
07:04:22 <Axman6> don't understand them*
07:04:35 <Axman6> which is the same for most moderately complex topics
07:04:36 <hpc> tzxn3: try doing simple stuff in ghci
07:04:45 <hpc> :t getLine
07:04:46 <lambdabot> IO String
07:04:55 <hpc> :t putStrLn
07:04:55 <lambdabot> String -> IO ()
07:04:59 <Younder> IS string is easy
07:05:04 <Younder> IO
07:06:24 <Entroacceptor> :t putStrLn =<< getLine
07:06:25 <lambdabot> IO ()
07:06:46 <ski> Younder : ooc, what does your library implement ?
07:07:40 <rewind> [ x | x <- [1..], x <= 9]
07:07:50 <rewind> use take 10 [1..]
07:07:58 <Younder> ski: partion-by, span, ...
07:08:07 <rewind> [1..] is an infinite list of integers
07:08:08 <Younder> That sort of thing
07:08:16 <rewind> x<=9 is the filter
07:08:26 <ski> Younder : list operations ? other data structures as well ? other stuff ?
07:08:34 <ski> mhm
07:08:40 <rewind> it will apply the filter on every number in list and return the list of results
07:08:46 <rewind> so it won't stop.... ever
07:08:53 <Younder> ski: soly list operations
07:08:53 <Entroacceptor> > filter (<=9) [1..]
07:08:57 <lambdabot>   mueval-core: Time limit exceeded
07:09:00 <ski> rewind : s/take 10/take 9/
07:09:06 <tzxn3> I know what putStrLn and getLine do
07:09:07 <hpc> @src filter
07:09:07 <lambdabot> filter _ []     = []
07:09:08 <lambdabot> filter p (x:xs)
07:09:08 <lambdabot>     | p x       = x : filter p xs
07:09:08 <lambdabot>     | otherwise = filter p xs
07:09:08 <ski> Younder : ok
07:09:09 <rewind> my bad
07:09:38 <Younder> ski:I am considering using defmethod to extend it to vectors and maps
07:10:23 <tzxn3> putStrLn takes a string and returns an IO action that outputs that string, getLine is an IO action that gets a line from input and returns it
07:10:29 <tzxn3> or at least, I think that's hat they do
07:10:47 <hpc> tzxn3: yes
07:11:03 <hpc> tzxn3: now how do you get a line of input, then print it?
07:11:03 <ski> Younder : i should attempt learning some basic CL (and CLOS) some time -- i'm mostly familiar with Scheme
07:11:21 <ClaudiusMaximus> > [ x | x <- [0..], then takeWhile by (x <= 9) ] -- using TransformListComp language extension
07:11:22 <lambdabot>   Illegal transform or grouping list comprehension: use -XTransformListCompNo...
07:11:45 <rewind> can anyone pls try this ? : take 11 [x| x<-[1..], x<=9]
07:11:52 <tzxn3> getLine >>= putStrLn
07:11:55 <ski> > take 11 [x| x<-[1..], x<=9]
07:11:58 <danr> > take 11 [x| x<-[1..], x<=9]
07:11:59 <lambdabot>   mueval-core: Time limit exceeded
07:12:02 <lambdabot>   mueval-core: Time limit exceeded
07:12:05 <Entroacceptor> of course
07:12:07 <danr> :)
07:12:41 <roconnor> what's a good name for (***)
07:12:43 <ski> Younder : which implementation would you suggest trying ? sbcl ?
07:12:47 <Younder> Ski: CLOS is actually worth it
07:12:52 <hpc> tzxn3: how about to get two lines of input and print one?
07:12:53 <ski> roconnor : i've seen it called `cross'
07:13:00 <Younder> Ski: I use SBCL
07:13:06 <hpc> (hint: (>>))
07:13:28 <roconnor> ski: well, at least that is better than "split"
07:14:05 <tzxn3> print which one?
07:14:23 <hpc> second
07:14:28 <ski> first
07:14:38 <hpc> (first shouldnt be hard either)
07:14:39 * ski couldn't resist
07:14:41 <hpc> lol
07:15:16 <tzxn3> getLine >>= \x -> getLine >> putStrLn x
07:15:26 <tzxn3> for first :P
07:15:32 <hpc> yep
07:15:42 <tzxn3> or getLine >> getLine >>= putStrLn
07:15:42 <tzxn3>  for second
07:15:48 <ski> @do getLine >>= \x -> getLine >> putStrLn x
07:15:48 <lambdabot> do { x <- getLine; getLine; putStrLn x}
07:15:53 <ski> @do getLine >> getLine >>= putStrLn
07:15:54 <lambdabot> do { a <- do { getLine; getLine}; putStrLn a}
07:15:55 <hpc> i think you already get monads
07:16:02 <hpc> even if you think you dont
07:16:07 <tzxn3> lol
07:16:10 <ski> @do getLine >> (getLine >>= putStrLn)
07:16:11 <lambdabot> do { getLine; (do { a <- getLine; putStrLn a})}
07:16:17 <ski> @slap lambdabot
07:16:17 <lambdabot> stop telling me what to do
07:16:24 <RichyB> @pl getLine >> \x -> getLine >> putStrLn x
07:16:24 <lambdabot> getLine >> (getLine >>) . putStrLn
07:17:07 * ski hasn't been following what tzxn3 is trying to do ..
07:17:13 <rewind> lambdabot executes scripts it reads?
07:17:20 <hpc> no
07:17:27 <tzxn3> it's just that when I try to write IO code for a simple blackjack game, it turns horrible :P
07:17:28 <ski> it evaluates expressions you send it, yes
07:17:31 <hpc> it evaluates enough to call "show"
07:17:39 <tzxn3> http://hpaste.org/66164
07:17:53 <rewind> take 5 [1..]
07:18:09 <rewind> how does it work ?
07:18:17 <hpc> @src take
07:18:17 <lambdabot> take n _      | n <= 0 =  []
07:18:17 <lambdabot> take _ []              =  []
07:18:17 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
07:18:18 <ski> rewind : you have to use `@run ' or `> ' at the start of the line
07:18:27 <ski> @run 2^3
07:18:28 <lambdabot>   8
07:18:29 <ski> > 2^3
07:18:30 <lambdabot>   8
07:18:32 <rewind> >take 5 [1..]
07:18:37 <ski> .. with a space :)
07:18:37 <rewind> > take 5 [1..]
07:18:38 <lambdabot>   [1,2,3,4,5]
07:18:49 <rewind> ski : thank you
07:18:53 <ski> yw
07:21:00 <hpc> tzxn3: okay, ive switched from phone to computer, so now i can read that paste :P
07:23:13 <tzxn3> :D
07:25:01 <ski> instead of `x = hit d phand', using `fst x' and `snd x', you could do `(newPlayerHand,newDeck) = hit d phand' and use `newPlayerHand' and `newDeck' instead
07:26:00 <tzxn3> sorry, not sure I follow
07:26:44 <ski> in `playerTurn' and `dealerTurn'
07:27:14 <tzxn3> what about the dealer's hand though?
07:27:20 <tzxn3> sorry if that's a stupid question :p
07:27:41 <ski> the code is more readable if you use pattern-matching `where (newPlayerHandmnewDeck) = hit d phand' instead of `x = hit d phand' (then using `fst' and `snd' to extraxt the parts)
07:28:18 <tzxn3> oh right
07:28:32 <tzxn3> I need to tell my friend that, he wrote it that way :P
07:28:52 <ski> i might factor out the common `checkForBust' call inside the conditional in `dealerTurn'
07:28:59 <hpc> you should also pick one of alignment or indentation, and stick to it
07:29:19 <hpc> compare: playerTurn and dealerTurn
07:29:39 <tzxn3> heh
07:30:08 <hpc> were you using tabs at all?
07:30:17 * ski wonders about the last choice in `playerTurn'
07:30:19 <hpc> (i think hpaste converts tabs to spaces)
07:30:32 <tzxn3> I was using spaces
07:30:49 <hpc> ah, good
07:31:12 <hpc> (tabs tend to not get displayed right in editors; ghc treats them as 8 spaces always)
07:31:33 <tzxn3> I found that out when I first started
07:33:45 <tzxn3> mhm, I'm used to if statements as flow control
07:33:56 <tzxn3> in imperative languages
07:34:47 <hpc> also, try this:
07:34:49 <hpc> type Hand = [Card]
07:34:50 <hpc> type Deck = [Card]
07:34:50 <hpc> data Game = Game {phand :: Hand, dhand :: Hand, deck :: Deck}
07:35:14 <hpc> then most of your functions will be of type Game -> other params -> IO something
07:35:46 <magicman> *ghc treats them as as many spaces necessary to end up at a column that's a multiple of 8
07:35:47 <hpc> deal :: Deck -> Game, etc
07:35:50 <ski> tzxn3 : not much different than imperative languages, here ..
07:35:59 <hpc> magicman: oh
07:36:41 * ski notes tzxn3 hasn't put a type signature on `checkForBust'
07:36:47 <magicman> Something with 11 spaces does not align with 2 spaces, tab, 1 space. Just tested it, too :p
07:36:56 <tzxn3> I forgot about that one :P
07:37:43 <hpc> tzxn3: reorder your functions too, so related functions are nearer to each other
07:37:51 <hpc> (related as in, foo calls bar, calls baz, ...)
07:38:08 <ski> tzxn3 : heh, i was thinking that you hadn't done it, because you preferred not thinking about what the type signature should be ;)
07:38:13 * hpc likes to be able to read a program from main at the top down to the "leaves" of the program at the bottom
07:38:51 <roconnor> what are the two equational laws for (|||)? One law is (f ||| g) . h = (f . h) ||| (g . h)
07:39:03 <hpc> :t (|||)
07:39:04 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
07:39:06 <tzxn3> checkForBust :: (([Card], [Card], [Card]) -> Bool -> Bool -> IO ()) -> ([Card], [Card], [Card]) -> Bool -> Bool -> IO ()
07:39:14 <tzxn3> I think that's right :P
07:39:26 <ski> tzxn3 : btw, make sure to browse through the hlint comments at the end of <http://hpaste.org/66164>
07:39:59 <magicman> :t (\f g h -> (f ||| g) . h, \f g h -> (f . h) ||| (g . h))
07:40:00 <lambdabot> forall b b1 c (f :: * -> *) a d (a1 :: * -> * -> *) b2. (Functor f, Functor (a1 b2), ArrowChoice a1) => ((b -> b1) -> (c -> b1) -> f (Either b c) -> f b1, (a -> d) -> (a -> d) -> a1 b2 a -> a1 (
07:40:00 <lambdabot> Either b2 b2) d)
07:40:29 <roconnor> I kinda think the other law will involve id somehow.
07:40:49 <tzxn3> hlint is impressively clever :P
07:40:50 <magicman> :t (\f g h -> (f ||| g) Prelude.. h, \f g h -> (f Prelude.. h) ||| (g Prelude.. h))
07:40:51 <lambdabot> forall b c c1 a b1 b2 c2. ((b -> c) -> (c1 -> c) -> (a -> Either b c1) -> a -> c, (b1 -> c2) -> (b1 -> c2) -> (b2 -> b1) -> Either b2 b2 -> c2)
07:41:10 <hpc> magicman: it looks like the laws are going to be "(|||) distributes over (.)"
07:41:23 <ski> roconnor : hm, so not beta and eta, then ?
07:41:26 <magicman> Yes, though those two don't have the same type :-/
07:41:39 <roconnor> ski: hmm
07:41:46 <roconnor> ski: you make a good point about beta and eta
07:44:12 <tzxn3> playerTurn and dealerTurn are annoying me
07:44:24 <tzxn3> I'm aware they're horrible
07:44:34 <tzxn3> but I'm not really sure how I can fix them
07:44:46 <hpc> tzxn3: instead of working on those, work on the functions that call them
07:44:52 <magicman> :t (\f g h -> f Prelude.. (h ||| g), \f g h -> (f Prelude.. h) ||| (f Prelude.. g))
07:44:53 <lambdabot> forall b c b1 c1 b2 d b3 c2. ((b -> c) -> (c1 -> b) -> (b1 -> b) -> Either b1 c1 -> c, (b2 -> d) -> (c2 -> b2) -> (b3 -> b2) -> Either b3 c2 -> d)
07:45:52 <tzxn3> the functions that call them explicitly are main and the functions themselves
07:46:12 <tzxn3> checkForBust has them passed as parameters
07:46:52 <tzxn3> what issue would you say I need to eliminate?
07:47:07 <tzxn3> or, what are the main issues?
07:47:33 <hpc> tzxn3: oh, i see now; it's very confusing :P
07:47:50 * roconnor thinks btrfs is making his system hang
07:48:39 <hpc> tzxn3: have playerTurn :: Game -> Bool -> Bool -> IO (Game, Bool) -- or something like that; have it return (newGame, bust)
07:48:48 <ClaudiusMaximus> roconnor: the laws seem to be defined in terms of 'left', going from http://www.soi.city.ac.uk/~ross/papers/fop.html
07:48:52 <magicman> roconnor: The law that involves "id" is (Left ||| Right) === id.
07:49:03 <hpc> then have a function that loops through playerTurn, dealerTurn
07:49:07 <hpc> showing hands and so forth
07:49:24 <magicman> (corresponding with (fst x, snd x) === x)
07:50:02 <magicman> (and I forgot the \x -> (f x, g x) operator... (***) or (&&&), but which <_<)
07:50:26 <hpc> @pl \x -> (f x, g x)
07:50:26 <lambdabot> liftM2 (,) f g
07:50:37 <hpc> :t (f *** g)
07:50:37 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (SimpleReflect.FromExpr (a b c), SimpleReflect.FromExpr (a b' c'), Arrow a) => a (b, b') (c, c')
07:50:42 <tzxn3> mhm
07:50:46 <hpc> :t (f &&& g)
07:50:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (SimpleReflect.FromExpr (a b c), SimpleReflect.FromExpr (a b c'), Arrow a) => a b (c, c')
07:50:57 <hpc> > (f &&& g) x :: (Expr, Expr)
07:50:58 <lambdabot>   (f x,g x)
07:50:59 <tzxn3> that makes some amount of sense
07:51:14 <roconnor> magicman: that's interesting.
07:51:19 <hpc> tzxn3: believe it or not, it's okay to think imperatively in haskell ;)
07:51:47 <roconnor> @type left
07:51:48 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
07:52:24 <magicman> :t left +++ right
07:52:25 <lambdabot> forall (a :: * -> * -> *) b c d (a1 :: * -> * -> *) b1 c1 d1. (ArrowChoice a, ArrowChoice a1) => Either (a b c) (a1 b1 c1) -> Either (a (Either b d) (Either c d)) (a1 (Either d1 b1) (Either d1 c1))
07:52:29 <magicman> :t left ||| right
07:52:30 <lambdabot> forall (a :: * -> * -> *) c d. (ArrowChoice a) => Either (a c c) (a d d) -> a (Either c d) (Either c d)
07:52:32 <roconnor> magicman: The problem is that Lens (supposedly) has a (|||) operation but not a (+++) operations; but you are saing that the laws of (|||) are in terms of (+++).
07:52:50 <roconnor> magicman: which is making me doubt that (|||) is well defined for lenses.
07:53:20 <hpc> roconnor: it means lenses aren't an instance of ArrowChoice, so yeah
07:53:34 <hpc> (aren't a sane instance, anyhoo)
07:53:40 <magicman> roconnor: I know nothing about lenses, but I know that (|||) is dual to (&&&), and that I remember the laws for functions on tuples, which should generalize to arrows for tuples.
07:54:25 <roconnor> hpc: well the question is, are lenses an instance of a hypothetical Choice class that is derived from Category but not derived from Arrow.
07:54:34 <hpc> ah
07:55:25 <roconnor> dibblego is trying to make this Class less hypothetical.
07:55:56 <hpc> i approve of this effort
07:56:08 <hpc> anything that reduces the massive class heirarchy beneath Arrow is a good thing
07:56:21 <roconnor> but the (|||) operation appears to naively work fine for Lenses
07:56:31 <roconnor> while (+++) is right out.
07:56:47 <hpc> nor shalt one count to (***)?
07:56:56 <hpc> :P
07:57:02 <roconnor> :D
07:57:12 <mokus> excepting that thou then proceedest to (|||)!
07:57:32 <hpc> but yeah, just judging from above, i think distributivity + identity is a good set of laws for (|||)
07:59:44 <roconnor> hpc: it is, except that Lens cannot satisfy them
07:59:53 <roconnor> which was dibblego's whole motifivation to start this
07:59:55 <hpc> oh
08:00:05 <hpc> huh
08:00:13 <roconnor> *motivation
08:01:57 <roconnor> I think this means that (|||) isn't actually well defined on Lenes, contrary to appearances.
08:02:08 <roconnor> but I'd like to make a compelling illustration.
08:02:17 <tzxn3> how do I pattern match with a constructor I've defined?
08:02:42 <roconnor> which is hard, because (|||) really really looks well defined for Lenses.
08:02:57 <magicman> The (|||) and (+++) laws follow from a commutative diagram for coproducts?
08:03:29 <roconnor> magicman: I presume so, from what you said :D
08:04:02 <tzxn3> is it 'f Constructor {x, y, z} = ' ?
08:04:24 <tzxn3> or 'f (Constructor x y z) =' ?
08:04:29 <ClaudiusMaximus> the second
08:04:39 <tzxn3> yeah, that makes sense
08:04:46 <tzxn3> just wanted to check
08:06:45 <yasar> I have just realized, if you read do notation backwards, and replacing "<-" with ">>=" in your mind, it is same as using binds outside of do notation!
08:07:08 <yasar> well, almost ...
08:07:11 <roconnor> yasar: not quite
08:08:36 <tzxn3> there's also the lambdas
08:09:04 <yasar> You are right. But still, it gives intuation about how would it translate.
08:09:16 <ClaudiusMaximus> yasar: http://book.realworldhaskell.org/read/monads.html#monads.do
08:11:20 <hpc> roconnor: do lenses even form a category?
08:12:21 <roconnor> hpc: definitely
08:12:26 <mokus> they should
08:12:49 <roconnor> I should have a proof around here somewhere
08:14:23 <roconnor> hmm, can find a proof
08:14:26 <roconnor> but I'm mostly sure
08:16:13 <roconnor> @type right
08:16:14 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
08:18:47 <magicman> @type \f -> (id +++ f)
08:18:48 <lambdabot> forall b b' c'. (b' -> c') -> Either b b' -> Either b c'
08:19:00 <magicman> @type \f -> (Control.Category.id +++ f)
08:19:01 <lambdabot> forall (a :: * -> * -> *) b b' c'. (ArrowChoice a) => a b' c' -> a (Either b b') (Either b c')
08:19:50 <magicman> I think it's possible to define (|||) in terms of (+++) and vice-versa.
08:20:39 <magicman> @type \f g -> (Left Control.Category.. f ||| Right Control.Category.. g)
08:20:39 <lambdabot> forall b b1 b2 c. (b2 -> b) -> (c -> b1) -> Either b2 c -> Either b b1
08:21:06 <magicman> Oh, right. Hrm. Need "arr Left" and "arr Right", but we don't have "arr".
08:23:36 <magicman> Unless arr Left and arr Right become class primitives.
08:25:28 <magicman> But then I assume those don't make sense for Lenses :p
08:26:28 <mizu_no_oto> Is there a nice way to make (a  -> a) a monoid where mappend = .  ?
08:26:47 <magicman> @type Endo
08:26:48 <lambdabot> forall a. (a -> a) -> Endo a
08:27:30 <magicman> But without that Endo-wrapper, that probably requires all kinds of typeclass extensions.
08:28:05 <ciaranm> haskell needs a good way of handling types that are a typeclass in more than one way
08:28:11 <roconnor> okay, so there is a natural bijection between (A -> C)*(B -> C) and (A + B) -> C, for regular Hask functions right?
08:28:14 <hpc> incidentally, (Monoid m => Endo m) gives you a nice way of reversing the order of mappends of another monoid
08:28:20 <hpc> ie, DList
08:28:29 <magicman> roconnor: Yes.
08:28:33 <magicman> :t either
08:28:34 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:28:50 <magicman> Bijection, actually, not sure.
08:29:10 <roconnor> @:t uncurry either
08:29:11 <lambdabot> Done.
08:29:11 <magicman> Oh, yes. Derp.
08:29:16 <roconnor> @t uncurry either
08:29:16 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:29:20 <roconnor> @type uncurry either
08:29:21 <lambdabot> forall a c b. (a -> c, b -> c) -> Either a b -> c
08:29:45 <magicman> :t \f -> (f . Left, f . Right)
08:29:45 <lambdabot> forall b a b1. (Either a b1 -> b) -> (a -> b, b1 -> b)
08:30:07 <leino> quick question: is there a name for a list which can extend infinitely (lazily) in two directions?
08:30:15 <roconnor> @type (. (Left *** Right))
08:30:16 <lambdabot> forall b b1 b2 b' a. ((Either b1 b2, Either a b') -> b) -> (b1, b') -> b
08:30:23 <roconnor> @type (. (Left &&& Right))
08:30:24 <lambdabot> forall b b1 b2 a. ((Either b1 b2, Either a b1) -> b) -> b1 -> b
08:30:25 <hpc> leino: Zipper
08:30:27 <roconnor> hmm
08:30:30 <roconnor> anyhow
08:30:47 <leino> hpc: thought so. thanks!
08:30:59 <roconnor> but there *isn't* a bijection between (Lens A C*Lens B C) and (Lens (A +B) C) is there?
08:31:38 <roconnor> what about between (Lens A C + Lens B C) and (Lens (A + B) C)?
08:32:08 <mizu_no_oto> So when will GHC implement named instances for typeclasses?
08:32:09 <magicman> I'm assuming Lens a b ~= (a -> (b, b -> a)).
08:32:19 <magicman> Because that's what my head is used to <_<
08:32:28 <roconnor> magicman: not quite, that plus the coalgbra / lens laws.
08:32:59 <roconnor> magicman: it would be a subset type if Haskell had those.
08:33:17 <rewind> @src @
08:33:17 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:33:33 <hpc> @hoogle (@)
08:33:34 <lambdabot> keyword
08:33:34 <lambdabot> Test.HUnit.Base (
08:33:34 <lambdabot> Test.HUnit.Base (
08:33:43 <hpc> heh
08:33:56 <rewind> could anyone pls explain : let abc@(a,b,c) = (10,20,30) in (abc,a,b,c)
08:34:05 <rewind> i don't understand the abc@
08:34:12 <ciaranm> rewind: that's an @ pattern
08:34:17 <td123> as pattern
08:34:25 <hpc> rewind: let abc = (10, 20, 30); (a, b, c) = abc in (abc, a, b, c)
08:34:29 <td123> rewind: abc = (10,20,30)
08:35:11 <roconnor> rewind: the (a,b,c) is the regular pattern but abc@(a,bc) binds abc to the whole triple (a,b,c)
08:35:27 <magicman> coalgebra laws...
08:35:33 <magicman> Let me search for them.
08:35:57 <magicman> It has to do with Store-comonads, but I know of the name only >_<
08:36:07 <roconnor> magicman: they are extract . l = id and fmap l . l = duplicate . l
08:36:24 <roconnor> magicman: but for lenses they are equivalent to the get/set, set/get and set/set laws.
08:36:41 <rewind> without actually executing it, what's the result? :let abc@(a,b,c) = (10,20,30) in (abc,a,b,c)
08:36:47 <magicman> I'm more familiar with get/set, set/get, set/set.
08:36:57 <t7> how do i read hex number as Integer ?
08:37:04 <t7> @hoogle String -> Integer
08:37:04 <lambdabot> Prelude error :: [Char] -> a
08:37:05 <lambdabot> Debug.Trace trace :: String -> a -> a
08:37:05 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
08:37:22 <ciaranm> rewind: ((10, 20, 30), 10, 20, 30)
08:37:24 <magicman> I know the comonad laws only as dual to monad laws, but I don't know the specific Comonad instance for (Lens a). Could probably write them, but not understand them :p
08:37:27 <roconnor> @hoogle readHex
08:37:27 <hpc> > read "0xb00b135" :: Integer
08:37:28 <lambdabot> Numeric readHex :: Num a => ReadS a
08:37:28 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
08:37:28 <lambdabot>   184594741
08:37:40 <rewind> ciaranm : 12...it's 12
08:37:47 <roconnor> t7: let (r,""Numeric
08:37:54 <jeff_s_> Does anyone know if there is a version of Control.Exception.Base.bracket that works in MonadIO instead of IO?
08:38:03 <roconnor> t7: let [(result,"")] = Numeric.readHex input in result
08:38:22 <t7> yey cheers
08:38:23 <ciaranm> rewind: let 2 + 2 = 12 in 2 + 2
08:38:28 <roconnor> oh ya
08:38:34 <roconnor> t7: and what hpc said
08:38:39 <hpc> jeff_s_: there's a package with some type classes that do that lifting, but they're broken in a fairly crucial way
08:38:53 <roconnor> hpc: that is a lot easier
08:39:05 * roconnor will try read . ("0x"++) more often
08:39:08 <hpc> http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/
08:39:15 <hpc> ^ jeff_s_
08:39:17 <jeff_s_> hpc - what package is that? I can maybe pull just that one function out and make it work properly.
08:39:21 <jeff_s_> hpc- thanks!
08:40:07 <rewind> ciaranm : got it to print ((10,20,30),10,20,30)
08:48:12 <roconnor> nope no bijection bewteen (Lens A C + Lens B C) and (Lens (A + B) C)?
08:48:18 <roconnor> s/?/.
08:51:40 <dolio> That'd be an odd expectation anyway.
08:52:03 <dolio> (Lens A C, Lens B C) and Lens (A + B) C would be more reasonable.
08:53:25 <roconnor> dolio: sure, but I don't think there is a bijection there either.
08:53:49 <dolio> No?
08:53:51 <roconnor> hmm
08:53:55 <roconnor> maybe I was too hasty
08:54:11 <mizu_no_oto> What non-numeric useful things form Groups (other than (,))?  In my Abstract Algebra class, we're talking almost entirely about modular arithmetic and the like.  While things like sets under union and lists under concatenation and the like form monads, it seems difficult to come up with useful instances of groups because of the inverse.
08:54:21 <dolio> I think it's Lens (A * B) C that's a problem.
08:54:37 <ciaranm> mizu_no_oto: bijective functions
08:54:54 <mokus> Lens (A+B) C -> (Lens A C, Lens B C) would be problematic - in particular, the "get" operation
08:55:02 <roconnor> WIth (Lens (A + B) C) you could be given an A, set a new C and it turns into a B.
08:55:28 <mokus> oh wait, which parameter is which?
08:55:39 <Runar> do lenses form a group?
08:55:39 <ciaranm> mizu_no_oto: every finite group is (iso to) a subgroup of a permutation group, and a permutation is (iso to) a finite bijective function
08:55:46 <roconnor> in Lens A B, B is the substructure and A is the superstructure
08:55:58 <dolio> (Lens A B, Lens A C) ~ Lens A (B * C) is a problem, because you could have B = C and point both lenses as the same place.
08:55:59 <roconnor> Runar: they form a category
08:56:08 <mokus> ah, ignore my last statement then - i was thinking of the opposite
08:56:14 <Runar> ah of course
08:56:27 * roconnor -> lunch
08:57:03 <ciaranm> mizu_no_oto: also, you should look up free groups. they're like lists with inverses.
08:57:27 <dolio> roconnor: That doesn't really gel with my idea of what lenses are, but I guess it's possible.
09:01:47 <Younder> hi all
09:02:10 <Younder> At leat here I am still welcome
09:03:19 <Younder> In my philosophy group I seemed to have said 'shit hit's the fan' so I was banned there. lol
09:03:54 <quicksilver> well I might have given you a warning for the incorrect use of apostrophe.
09:04:21 <Younder> Now in Lisp I begged the to ban me before I lost my temper and they obliged.
09:04:52 <rtharper_> @src unfoldr
09:04:52 <lambdabot> unfoldr f b  = case f b of
09:04:52 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
09:04:52 <lambdabot>    Nothing        -> []
09:05:30 <Younder> nice
09:05:37 <tibbe> dcoutts: I could use the new bytestring builder right about now :/
09:05:53 * rtharper_ is suprised unfoldr doesn't use the static argument transformation
09:05:57 <mizu_no_oto> ciaranm:  Is there a useful way to guarantee 1-1 ness in the type system and have some means of generating inverses?
09:06:18 <dcoutts> tibbe: mm, I'm somewhat stuck with some I/O functions for bytestring-0.10
09:06:29 <tibbe> dcoutts: oh?
09:06:40 * hackagebot happstack-server 7.0.0 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.0.0 (JeremyShaw)
09:06:48 <tibbe> dcoutts: what kind of I/O functions?
09:07:11 <tibbe> dcoutts: I'm working on a new CSV parsing and encoding in the flavor of aeson
09:07:15 <dcoutts> tibbe: I'm trying to fix the char8 I/O functions to do what we wanted them to do with line endings
09:07:32 <tibbe> dcoutts: I see
09:07:46 <dcoutts> tibbe: the char8 I/O functions always used to respect text vs binary mode, the modern equiv of that is the handle line ending mode
09:07:47 <ciaranm> mizu_no_oto: in general, no. but you can turn certain things into groups in canonical ways.
09:07:49 <tibbe> dcoutts: can it wait?
09:08:00 <dcoutts> tibbe: not easily, it's really a bug
09:08:06 <tibbe> dcoutts: oh
09:08:11 <tibbe> dcoutts: didn't know it was handled before
09:08:26 <ciaranm> mizu_no_oto: (although sometimes in more than one canonical way)
09:08:46 <dcoutts> tibbe: it broke with a newer ghc version but we didn't notice immediately, users have reported it
09:09:08 <dcoutts> tibbe: I could do a low performance fix, but doing it properly is more involved
09:09:30 <tibbe> dcoutts: I see
09:09:39 <tibbe> dcoutts: I say do the low performance fix
09:09:48 <tibbe> dcoutts: will only affect text mode handles I presume
09:09:57 <dcoutts> tibbe: yes
09:10:10 <tibbe> dcoutts: I think that's fine, I think it's more important to integrate Simon's work
09:10:23 <dcoutts> or rather release, it's included already
09:11:09 <tibbe> dcoutts: even better!
09:11:42 * hackagebot happstack-server-tls 7.0.0 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.0.0 (JeremyShaw)
09:11:44 * hackagebot happstack-lite 7.0.0 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-7.0.0 (JeremyShaw)
09:11:46 * hackagebot happstack-hamlet 7.0.0 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-7.0.0 (JeremyShaw)
09:11:48 * hackagebot happstack-heist 7.0.0 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.0.0 (JeremyShaw)
09:12:10 <quicksilver> rtharper_: @src is not intended to be accurate
09:12:18 <rtharper_> quicksilver: oh?
09:12:34 <parcs`> there should be a Bit monoid where mplus is .|. and mzero 0
09:12:50 <quicksilver> rtharper_: @src is a work of fiction intended for didactic purposes.
09:12:56 <quicksilver> rtharper_: I think it should be removed.
09:13:04 <rtharper_> why can't it be true too?
09:13:05 <rtharper_> =p
09:13:09 <quicksilver> rtharper_: however, it does appear to have the correct source for unfoldr :)
09:13:20 <quicksilver> rtharper_: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#unfoldr
09:13:35 <quicksilver> rtharper_: well, because @src is intended to be implementation-neutral specifications
09:13:49 <rtharper_> ah okay
09:13:50 <quicksilver> whereas quite a few of the functions in it have GHC-specific implemenatations.
09:14:00 <quicksilver> I think it does more harm thatn good overall.
09:14:04 <rtharper_> indeed
09:14:05 <rtharper_> hehehe
09:14:08 <quicksilver> it's better to teach people how to get to the *actual* library source
09:14:15 <rtharper_> agreed
09:14:41 <quicksilver> a lambdabot tool which generated http: links to the actual source on haskell.org would be nice ot have
09:14:46 <tibbe> dcoutts: so what do you think, release the current state?
09:14:57 <ciaranm> clearly @src should reduce the source to the simplest standalone implementation and display that!
09:14:59 <dcoutts> tibbe: no, I'm not happy with the bug
09:15:11 <tibbe> dcoutts: after a non-optimal fix I mean
09:15:57 <dcoutts> tibbe: yes, that'd be ok
09:16:40 * hackagebot happstack-hsp 7.0.0 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.0.0 (JeremyShaw)
09:16:48 <hpaste> ClaudiusMaximus pasted “"best match" needs better algorithm” at http://hpaste.org/66176
09:17:16 <tibbe> dcoutts: :)
09:18:25 <dolio> roconnor: I guess the obvious example is id : Lens (A + B) (A + B) has no decomposition into Lens A (A + B) and Lens B (A + B)
09:18:43 <ClaudiusMaximus> any suggestions?  the intent is to find the best weights and vectors to match a target vector with a weighted sum, given some collections of vectors and being limited to one vector from each collection
09:20:11 <tzxn3> if I have a monadic function that returns a tuple, how can I unpack the values in the tuple within a do-block?
09:20:40 <ciaranm> tzxn3: you mean something like (a, b, c) <- blah ?
09:20:44 <tzxn3> yes
09:21:28 <ciaranm> tzxn3: like that then :P
09:21:35 <tzxn3> I tried it
09:21:41 <tzxn3> it says the variables aren't in scope
09:21:42 * hackagebot happstack-hstringtemplate 7.0.0 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-7.0.0 (JeremyShaw)
09:21:44 * hackagebot hsx-jmacro 7.0.0 - hsx+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.0.0 (JeremyShaw)
09:21:46 * hackagebot happstack-jmacro 7.0.0 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.0 (JeremyShaw)
09:21:48 * hackagebot happstack 7.0.0 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-7.0.0 (JeremyShaw)
09:21:52 <tzxn3> *GHC does
09:22:01 <yitz> tzxn3: hpaste an example
09:22:06 <yitz> @hpaste
09:22:06 <lambdabot> Haskell pastebin: http://hpaste.org/
09:22:46 <ciaranm> > let f x = Just (x, x) in do (a, b) <- f 1 ; return $ a + b -- tzxn3
09:22:47 <lambdabot>   Just 2
09:22:53 <tzxn3> http://hpaste.org/66177
09:22:59 <tzxn3> is the code I'm currently working on
09:23:20 <kallisti> what happens exactly when I send C-c to a Haskell process?
09:23:24 <ciaranm> oh dear god
09:23:35 <kallisti> it doesn't seem to be raising an IO exception. either that or my IO exception handling is completely broken.
09:24:19 <tzxn3> :P
09:24:40 <tzxn3> around line 124 is my problem
09:24:55 <ciaranm> no, your problem is larger than that
09:26:41 * hackagebot happstack-plugins 7.0.0 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-7.0.0 (JeremyShaw)
09:27:11 <tzxn3> :P
09:27:28 <ciaranm> don't write java in haskell
09:28:32 <tzxn3> I didn't think i was writing java
09:29:06 <ciaranm> if more than 10% of your functions have IO in their signature, you're not writing haskell!
09:29:37 <tzxn3> I don't know how to do it any differently
09:30:00 <tzxn3> I'm trying to refactor according to what people in this channel have suggested
09:30:17 <sm> morning all
09:30:28 <hpc> ciaranm: you can write IO-heavy haskell just fine :P
09:30:47 <ciaranm> hpc: only if you want to catch aids
09:30:53 <sm> strange, GHC 7.4.1 docs still include 7.2.1 release notes
09:31:30 <tzxn3> all I did was take a problem and try to solve it
09:32:05 <hpc> tzxn3: ignore ciaranm, he's displaying an irrational fear of the IO monad
09:32:17 <sm> oh, ha ha. It includes several versions' release notes
09:33:09 <tzxn3> if he can suggest how my code could be made more pure, I'll listen :p
09:34:30 <ciaranm> you'll need some holy water, an old priest, a young priest, a linked list and a virgin
09:35:24 <tzxn3> linked list?
09:36:41 * hackagebot web-routes-happstack 0.23.3 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.23.3 (JeremyShaw)
09:41:12 <Peaker> having a lot of IO in Haskell code is a smell
09:42:39 <tibbe> dcoutts: would you be open to adding simple decimal :: Int -> ByteString functions, those are handy sometimes when builders are overkill
09:43:18 <tibbe> dcoutts: or perhaps Integral a => a -> ByteString
09:43:21 <dcoutts> tibbe: I'm not sure how far we should go there, we're in danger of ending up with a pretty ad-hoc collection
09:43:38 <dcoutts> tibbe: we've already got the (admittedly useful) readInt
09:44:01 <tibbe> dcoutts: I was thinking of pythons base set
09:44:07 <tibbe> dcoutts: which is int -> base -> bytestring
09:44:08 <tibbe> getting off shuttle
09:45:56 <kallisti> @hoogle (b -> c) -> (a -> WD b) -> WD c
09:45:57 <lambdabot> Warning: Unknown type WD
09:45:57 <lambdabot> No results found
09:46:04 <kallisti> @hoogle (b -> c) -> (a -> m b) -> m c
09:46:04 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
09:46:04 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
09:46:04 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
09:46:14 <kallisti> hm, okay.
09:47:16 <roconnor> dolio: what doesn't gel with your diea of what lenses are?
09:48:16 <dolio> roconnor: I just wasn't thinking correctly.
09:48:31 <roconnor> ah okay
09:48:50 <dolio> I was thinking that if A + B has a C, then both A and B must have a C, but if C = A + B, that's clearly not true.
09:48:55 <dolio> For example.
09:50:41 <roconnor> right
09:51:07 * sm wonders what http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/src/GHC-Debug.html#debugLn does, besides printing the argument
09:51:30 <roconnor> I came up with the example htat () + () has a Bool (in two ways) but () doesn't have a Bool, which is really an instance of yours.
09:53:59 <roconnor> magicman, dolio: as a vague aside, the two laws for (***) are id *** id = id and (fl *** fr) . (gl *** gr) = (fl . gl) *** (fr . gr) ?
09:54:42 <dolio> roconnor: I don't think that second one is a law, if you're talking about arrows.
09:55:14 <dolio> Because the effects may happen in a different order in a lot of arrows.
09:55:24 <hpc> it doesn't hold for Kleisli IO, for instance
09:55:51 <yasar> With infix definitions, you can design your own haskell, how cool is that!
09:56:08 <roconnor> dolio:  that is ... strange
09:56:30 <dolio> roconnor: It would be required if you wanted (***) to be the morphism part of a bifunctor, though.
09:56:44 * roconnor sighs
09:56:51 <roconnor> how can (***) not be a bifunctor?!
09:57:43 <roconnor> This Arrow class is screwy
09:57:59 <dolio> Products are a Haskell bifunctor, not a Kleisli bifunctor.
09:58:39 <roconnor> so what the heck is (***) ?
09:59:38 <dolio> A handy combinator?
09:59:45 * roconnor is starting to understand why arrows never took off.
09:59:52 <dolio> Although, not as handy as if it actually followed some nice reasoning rules.
10:00:00 <roconnor> exactly
10:01:03 <magicman> Heh, the docs: "Split the input between the two argument arrows and combine their output. Note that this is in general not a functor."
10:01:17 <magicman> That last comment probably exactly *because* of things like Kleisli IO.
10:01:24 <roconnor> ah
10:01:33 <roconnor> no wonder dibblego called this class "Split"
10:01:46 <magicman> And with Kleisli [], it may result in a different order of elements in the output.
10:02:20 <dolio> I expect it's only a functor for commutative monads.
10:03:06 <roconnor> So what about (|||) ?
10:03:14 <roconnor> is it not a coproduct then?
10:03:25 <roconnor> and (&&&) isn't a product either?
10:03:46 <mysticc> f :: a -> b -> IO c and g :: a -> b -> IO (Maybe c) .. how to write this in pointfree .. f a b = fromJust <$> g a b
10:03:57 <dolio> I think coproducts lift to the Kleisli category.
10:04:16 <hpc> @pl \a b -> fromJust <$> g a b
10:04:16 <lambdabot> ((fromJust <$>) .) . g
10:04:19 <roconnor> dolio: and CoKleisli arrows?
10:04:25 <dolio> (a -> m c, b -> m c) ~ (a + b -> m c)
10:04:28 <hpc> :t \a b -> fromJust <$> g a b
10:04:28 <dolio> No.
10:04:29 <lambdabot> forall t t1 a (f :: * -> *). (SimpleReflect.FromExpr (t -> t1 -> f (Maybe a)), Functor f) => t -> t1 -> f a
10:04:40 <dolio> I'd expect products to lift to cokleisli categories.
10:04:41 <roconnor> dolio: so there we go
10:04:56 <roconnor> Arrows are just a trash heap of random crap
10:05:11 <dolio> (w a -> b, w a -> c) ~ (w a -> b * c)
10:05:15 <nart> ciao )
10:05:39 <dolio> Those isomorphisms just work from the regular product and coproduct isomorphisms.
10:08:13 <roconnor> WTF
10:08:14 <roconnor> first f >>> arr (id *** g) = arr (id *** g) >>> first f
10:08:20 <roconnor> what type of law is that
10:08:34 <roconnor> (***) isn't even the (***) from the arrow class, it is for (->)
10:08:37 <dolio> Is that even true?
10:08:48 <dolio> Oh wait, arr.
10:08:51 <roconnor> it is what http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html claims
10:08:54 <magicman> It is, if you have arr :p
10:09:11 <hpc> @quote arr
10:09:11 <lambdabot> newsham says: do'nt confuse larry wall's drug induced vision of computing with the state of reality
10:09:13 <dolio> first f >>> id *** g = id *** g >>> first f is definitely wrong.
10:09:16 <dolio> You need the arr in there.
10:09:16 <hpc> @quote yarr
10:09:16 <lambdabot> hpc says: yarr, arr be rather arr-bitrary
10:09:29 <magicman> Yeah, because Kleisli IO again v_v
10:10:31 <roconnor> this is ridiculous
10:10:34 <hpc> Arrow: where polymorphism goes to die
10:13:13 <byorgey> the point is that 'arr' creates 'pure' arrows
10:13:25 <byorgey> so you can commute first past it because the 'order of effects' does not matter
10:13:28 <roconnor> Okay, now I'm tempted to create a BiMap class that uses (***) as a big f***k you to the Arrow class.
10:13:53 <c_wraith> :t (?f *** ?k)
10:13:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (?f::a b c, ?k::a b' c', Arrow a) => a (b, b') (c, c')
10:13:56 <byorgey> that's why  first f >>> id *** g = id *** g >>> first f  isn't true, because it can switch the order of some effects
10:14:19 <dolio> roconnor: Or, CategoryWithProducts.
10:14:51 <dolio> Instead of CategoryWithWhatLooksLikeProductsButReallyTheyArent.
10:15:33 <hpc> or for lenses
10:15:54 <hpc> ProbablyNotACategoryButWePretendItIsSoWeCanHaveWhatLooksLikeProductsButReallyTheyArent
10:15:56 <roconnor> dolio: I wouldn't mind some advice on how to to structure the division of (***) and (&&&) .  I know (&&&) depends on (***) for its laws, but I don't think (***) entails (&&&).
10:16:15 <roconnor> dolio: did you prove that lenses were a category?
10:16:23 <roconnor> dolio: in Agda?
10:16:24 <hpc> @src (&&&)
10:16:25 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
10:16:36 <dolio> Maybe. It should be pretty straight forward.
10:16:47 <roconnor> hpc doubts that Lenses form a category.
10:16:52 <roconnor> which is fair
10:17:02 <roconnor> it isn't entirely obvious.
10:17:13 <dolio> (&&&) is part of the definition of products. (***) is derivable from it and fst, snd, I think.
10:17:33 <hpc> roconnor: yeah, i figure if it's obviously not an arrow and not obviously a category...
10:18:03 <hpaste> yasar pasted “Type Error” at http://hpaste.org/66179
10:18:31 <yasar> Can anyone see what I am doing wrong here ^^
10:18:56 <magicman> Category laws are (f . id) = f = (id . f), and (f . g) . h = f . (g . h), yes? Anything else?
10:19:45 <timthelion> Somehow, googling Larry Walls drug induced theory of programing brought me to a page full of uniquely non porographic graphic novels drawn by two of his children :)
10:19:52 <roconnor> dolio: lenses appear to have (***) but not (&&&)
10:20:15 <roconnor> magicman: AFAIU, that is it.
10:20:28 <roconnor> magicman: same laws as a Monoid
10:20:42 <roconnor> magicman: since a categoyr is a Monoidoid
10:20:43 <byorgey> roconnor: you should discuss this with dmwit.
10:21:02 <byorgey> roconnor: he has thought a lot about the categorical structure of various formulations of lenses.
10:21:27 <roconnor> @seen dmwit
10:21:27 <lambdabot> Unknown command, try @list
10:21:32 <roconnor> preflex: seen dmwit
10:21:32 <preflex>  dmwit was last seen on #xmonad 1 day, 1 hour, 16 minutes and 31 seconds ago, saying: It means the most recent version of the code, according to the darcs repository.
10:23:09 <roconnor> dolio: in that there is a nice (***) operation and id *** id = id for lenses and (fl *** fr) . (gl *** gr) = (fl . gl) *** (fr . gr) for lenses.
10:23:22 <byorgey> yasar: what is the type of (?)
10:24:01 <yasar> Parser a -> (a -> Bool) -> Parser a
10:24:43 <byorgey> yasar: ok, so in the definition of 'becomes', what is that type 'a' ?
10:25:04 <yasar> (Char, Char) ?
10:25:07 <byorgey> yasar: right
10:25:19 <byorgey> yasar: so the second argument to ?  needs to be a function of what type?
10:25:39 <timthelion> ach jo, teen romance fantasy without the sex.  Larry Walls kids sure are boring!
10:25:48 <yasar> Maybe ((Char, Char), String) ?
10:26:27 <byorgey> yasar: no, look back at the type you told me for (?)
10:26:39 <byorgey> what type should its second argument be?
10:26:48 <yasar> oww, it should be a predicate!
10:26:57 <byorgey> indeed
10:27:10 <byorgey> of what type, specifically?
10:27:22 <yasar> (Char,Char) -> Bool ?
10:27:37 <byorgey> right!
10:28:01 <yasar> Thanks a lot!
10:28:17 <byorgey> yasar: I think you were getting confused between the predicate you provide to ?, and what ? actually does
10:28:46 <byorgey> yasar: you just provide a predicate.  (?), presumably, takes care of matching on something and rest, checking the predicate, and then returning some Maybe value
10:29:11 <Mathnerd314> is (>>) associative?
10:29:23 <byorgey> Mathnerd314: the monad laws require it to be.
10:29:24 <Runar> Mathnerd314: Yes
10:30:21 <dolio> roconnor, hpc: The proofs are trivial: http://code.haskell.org/~dolio/agda-share/html/LensCategory.html
10:30:27 <yasar> byorgey: It takes a function (Parser a), and if it doesn't return nothing, it feeds it's output to second function, and return it's value.
10:30:46 <yasar> if predicate is true I mean.
10:30:47 <byorgey> yasar: right
10:31:43 <hpc> dolio: oh, huh
10:37:40 <nart> is there an haskell library to perform OCR on images ?
10:43:06 <hpaste> vitno pasted “mergeSort” at http://hpaste.org/66180
10:43:12 <vitno> Hey, so I'm a new haskeller(?) and I have no clue what is wrong with this. I'm going through Learn you a haskell, and I just got thrugh the recursion chapter. At the end of that, it showed you how to implement quicksort. I figured it would be good for me to try implementing something like mergesort... but it doesn't work
10:43:22 <vitno> hpaste.org/66180
10:43:37 <mauke> mergeSort [x] = x looks like a type error
10:44:10 <vitno> why is that a type error?
10:44:24 <hpc> mergeSort takes a list and returns a list
10:44:25 <mauke> well, what is the type of mergeSort supposed to be?
10:44:34 <hpc> mergeSort list = element of list -- wrong
10:44:40 <hpc> mergeSort [x] = x -- wrong
10:45:04 <vitno> ouch, thanks.
10:45:10 <vitno> makes perfect sense now
10:46:02 <hpc> it helps if you learn to read the errors GHC spits out
10:46:18 <hpc> they will generally say something like "expected foo but got bar"
10:46:50 <hpc> for mergeSort it would say "expected [a] but got a" or something like that
10:47:07 <hpc> ie, "expected list, got a thing instead"
10:47:07 <mauke> not necessarily
10:47:15 <hpc> possibly
10:47:16 <mauke> mergeSort might even compile
10:47:23 <vitno> nah, it compiled
10:47:27 <hpc> oh
10:47:39 <vitno> which is why I was so confused
10:47:43 <hpc> oh fun
10:47:55 <hpc> in that case, it helps to put type signatures on your functions
10:48:02 <mauke> <mauke> well, what is the type of mergeSort supposed to be?
10:48:05 <mauke> ^ hence this :-)
10:48:06 <hpc> mergeSort :: Ord a => [a] -> [a]
10:48:17 <kallisti> anyone familiar with Control.Exception.Lifted
10:48:21 <vitno> yea... haha. I need to reread the chapter on types.
10:48:27 <hpc> (read as, for all 'a' that can be ordered)
10:48:41 <kallisti> I'm wondering if my error handlers can actually revert the state of an StateT computation.
10:49:14 <kallisti> in functions such as finally and onException it warns that side-effects in the handler won't actually be kept.
10:49:28 <kallisti> but there is no warning for functions such as catch, even though the implementation is very similar.
10:49:50 <nart> vitno: however, that mergeSort fun won't be very fast because your using length on every list/sublist
10:49:56 <nart> *you're
10:50:06 <hpaste> kallisti pasted “lifted exception and state” at http://hpaste.org/66181
10:50:18 <vitno> yea, I know. I just don't know any other way to do it right now
10:50:49 <hpc> vitno: if you don't mind getting in way over your head, you can take a look at the sort function in Prelude
10:50:58 <hpc> er, Data.List
10:51:01 <hpc> http://www.haskell.org/hoogle/?hoogle=sort
10:52:18 <vitno> looking!
10:53:14 <dolio> roconnor: Also, yes, as I recall, lenses have (***) for a bifunctor, but they don't have (&&&) which would make it a product in the category of lenses.
10:53:48 <nart> vitno: just recursively traverse the list getting the first two elements, then put that element in two seperate list inside a tuple, when you arrive at the base case [] or [x] just return ([], []) or ([x], []), (not really clear i know, but i don't know how to explain it in a better way sorry)
10:54:40 <vitno> nah, that makes sense. not really textbook mergesort though
10:55:02 <gdoteof> can someone tellme why this *does* compile? http://hpaste.org/66182  when I am returning 'existingSeats' i get a type error
10:55:20 <gdoteof> i thought i was explicitly saying that the return type is a list of tuples, but it forces me to return just a tuple
10:55:35 <mauke> gdoteof: no, it doesn't
10:55:39 <mauke> gdoteof: 'return' doesn't return
10:55:45 <mauke> 'return' is a constructor
10:56:00 <mauke> a list constructor, in this case
10:56:04 <monochrom> "return x" in this context translates to [x]
10:56:16 <nart> vitno: http://stackoverflow.com/questions/1215432/merge-sort-in-haskell
10:56:35 <gdoteof> m
10:56:36 <nart> vitno: the second answer
10:56:38 <monochrom> therefore, [("something", [1,2,3])] has the right type, [existingSeats] has the wrong type
10:56:40 <gdoteof> okay
10:56:42 <kallisti> I'm wondering if it would be possible, via ContT, to implement an exception handling computation where exceptions can be "unthrown" back to the throwing computation.
10:56:54 <vitno> @hpc fun... just a bit over my head :)
10:56:54 <lambdabot> Maybe you meant: ghc pl rc src
10:57:06 <gdoteof> that makes sense.  why is return a list constructor 'in this case'
10:57:18 <mauke> gdoteof: because your type signature says the result is a list
10:57:25 <mauke> :t return
10:57:26 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:57:27 <monochrom> because return is polymorphic
10:57:38 <mauke> this forces m = []
10:57:39 <monochrom> > return 'x' :: Maybe Char
10:57:40 <lambdabot>   Just 'x'
10:57:46 <monochrom> > return 'x' :: [Char]
10:57:47 <lambdabot>   "x"
10:58:04 <kallisti> > return 'x' :: Identity Char
10:58:05 <lambdabot>   No instance for (GHC.Show.Show
10:58:05 <lambdabot>                     (Data.Functor.Identity.I...
10:58:07 <monochrom> the exact behaviour depends on the type context. the above are two examples
10:58:15 <kallisti> oh, no Show for Identity, interesting.
10:58:31 <monochrom> you have forced the type context to be [blahblah], so the [] version is chosen
10:58:32 <ion> > runIdentity (return 'x')
10:58:32 <lambdabot>   'x'
10:58:56 <hpc> > runState (return 'x') 5
10:58:57 <lambdabot>   ('x',5)
10:58:58 <mauke> > gshow (return 'x' :: Identity Char)
10:58:59 <lambdabot>   No instance for (Data.Data.Data
10:58:59 <lambdabot>                     (Data.Functor.Identity....
10:59:04 <mauke> :-(
10:59:05 <ion> runIdentity = unsafeCoerce
10:59:11 <hpc> lol
10:59:18 <ion> return = unsafeCoerce
10:59:40 <hpc> ion: were you here for "ridiculous functions that == unsafeCoerce"?
10:59:46 <ion> yeah
10:59:48 <hpc> :D
10:59:54 <kallisti> unsafeCoerce = unsafeCoerce
11:00:06 <mauke> nonsense, functions aren't in Eq
11:00:14 <hpc> mauke: they are if you coerce them
11:00:42 <mauke> > gshow (Just 'x')
11:00:43 <lambdabot>   "(Just ('x'))"
11:03:18 <angstrom> is there a way to "overwrite" error messages?
11:03:20 <kallisti> so, anyone have any clue what's going on in my hpaste stuff?
11:03:32 <kallisti> I guess I could just /test/ it, but, sheesh, that's a lot of work.
11:03:37 <kallisti> I could just ponder it for a while.
11:04:36 <roconnor> dolio: those proofs are pretty damn trivial
11:05:54 <ion> instance Functor ⊥ where fmap f (Error error) = Error (f error)
11:06:04 <ion> -- overwrite error messages
11:07:10 <kallisti> newtype Error a = Identity a deriving (Functor)
11:07:16 <kallisti> er
11:07:24 <kallisti> newtype Error a = Error (Identity a) deriving (Functor)
11:07:38 <hpaste> ClaudiusMaximus pasted “ghci slow with long module names” at http://hpaste.org/66183
11:07:54 <ClaudiusMaximus> is that a bug to report or just me being a fool?
11:09:03 <ion> Yes to both. ;-)
11:09:21 <kallisti> dunno, I would kind of expect times like that for long module names.
11:09:46 <kallisti> doesn't mean it can't be optimized though.
11:12:24 <angstrom> what'd I'd like to do is something like `f xs i = try (xs !! i) (\msg -> error "bla")' where msg would be "index too large"
11:14:08 <kallisti> > [] !! 2
11:14:09 <lambdabot>   *Exception: Prelude.(!!): index too large
11:14:10 <dolio> roconnor: I papered over the need for extensionality a little there,.
11:14:18 <kallisti> angstrom: ???
11:14:20 <dolio> But other than that, it's all computation and eta.
11:14:30 <kallisti> oh I see.
11:14:39 <kallisti> angstrom: you want to use catch not try
11:14:49 <kallisti> also it has to be in IO.
11:15:18 <monochrom> I am actually surprised that GHC accepts such a long module name to begin with
11:15:26 <roconnor> dolio: what would you call a class with a (***) but not (&&&)?
11:15:37 <roconnor> dolio: presumably (&&&) inherits from the (***) class
11:16:58 <dolio> roconnor: It might be a monoidal category.
11:17:09 <dolio> () is unit, (,) is tensor product.
11:17:18 <ion> angstrom: left (const "bla") anEitherValueWithLeftRepresentingError
11:17:36 <roconnor> dolio: (***) should be specific to (,)
11:17:50 <kallisti> angstrom: you want something like:   (xs !! i) `catch` \(IndexOutOfBounds _) -> ...
11:17:51 <roconnor> I don't want to get beyond Haskell 98 into crazy abstact math land
11:18:01 <roconnor> at least not at the moment.
11:18:08 <kallisti> it is specific to (,)
11:18:11 <kallisti> :t (***)
11:18:12 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:18:22 <dolio> So make it a specialization of monoidal categories to the (), (,) case.
11:18:37 <roconnor> dolio: and still call it monoidal category?
11:18:45 <roconnor> I might be good with that.
11:19:13 <dolio> Functor is already endofunctor specific.
11:19:19 <dolio> Category is for subcategories of Hask.
11:19:27 <dolio> So, why not bastardize monoidal categories.
11:19:40 <roconnor> and (,) is the modial product in Hask we care about 80% of the time
11:19:49 <roconnor> *monoidal
11:19:59 <angstrom> kallisti: thanks
11:21:46 * hackagebot digestive-functors-happstack 0.1.1.5 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.1.1.5 (JasperVanDerJeugt)
11:22:13 <kallisti> angstrom: er. actually I think that's the wrong exception. if IndexOutOfBounds doesn't work try ErrorCall
11:22:25 <angstrom> I've got it to work with SomeException
11:22:41 <kallisti> heh. that works, I guess. though you could accidentally catch things you didn't mean to.
11:22:53 <angstrom> like what? :-)
11:23:13 <mauke> KillThread
11:23:17 <kallisti> UserInterrupt, ThreadKilled, StackOverflow
11:23:21 <mauke> er, that
11:24:02 <kallisti> basically anything from AsyncException
11:24:10 <ClaudiusMaximus> monochrom: me too! hugs aborts with ERROR "camel.hs":1 - Maximum token length (4000) exceeded
11:24:15 <angstrom> I see
11:24:23 <dolio> Actually, I guess category isn't quite subcategories of Hask. But it's still weird.
11:24:59 <kallisti> yeah it's ErrorCall
11:25:05 <kaitocracy> I'm trying to use HDBC and I'm not sure how to catch and respond to SqlErrors are there any useful documents on how to do this?
11:25:05 <kallisti> Prelude Control.Exception> ([] !! 1) `Control.Exception.catch` \(ErrorCall e) -> error "blah"
11:25:08 <kallisti> *** Exception: blah
11:25:48 <kallisti> because Prelude likes to be a Glasgow Haskell n00b.
11:26:46 * hackagebot digestive-functors-happstack 0.3.0.1 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.3.0.1 (JasperVanDerJeugt)
11:28:08 <kallisti> angstrom: ^
11:29:14 <monochrom> how does that type-check?
11:29:30 <mauke> monochrom: [] :: [a]
11:29:37 <angstrom> kallisti: awesome, thanks
11:29:43 <kallisti> kaitocracy: they're IO exceptions. you can learn more about that from the documentation of Control.Exception
11:29:55 <monochrom> @type Control.Exception.catch
11:29:56 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
11:29:59 <kallisti> kaitocracy: also there's some useful functions such as withTransaction which automatically do commits and rollbacks for you.
11:30:03 <monochrom> and [a] matches IO a?
11:30:12 <ClaudiusMaximus> :t (!!)
11:30:12 <monochrom> oh, nevermind
11:30:13 <lambdabot> forall a. [a] -> Int -> a
11:30:13 <mauke> monochrom: [] !! 1 :: a
11:31:57 <kallisti> kaitocracy: do it would be something like  ioAction `catch` (\(SqlError ...) -> ...)
11:32:06 <kallisti> *so
11:32:21 <kaitocracy> kallisti: thanks!
11:32:37 <kallisti> but the most common case is already handled for you by withTransaction, so I would look at that.
11:32:47 <kallisti> typically you want to rollback if /any/ exception happens, not just SqlError
11:37:45 <roconnor> dolio: do you know how Lens A () fits into this picture?
11:37:53 * roconnor really needs dmwit
11:37:58 <tswett> What do you call a binary search tree where each node has a key and a value, and the value of a non-leaf node is the sum of the values of its children?
11:38:38 <dolio> Isn't that lens trivial?
11:39:13 <kallisti> tswett: I've never heard of anything that specifically matches that definition.
11:40:52 <Enigmagic> tswett: i believe they're just called sum trees
11:41:23 <dolio> () is terminal in the lens category.
11:41:31 <dolio> If I'm not mistaken.
11:41:55 <byorgey> tswett: see http://apfelmus.nfshost.com/articles/monoid-fingertree.html
11:43:15 <byorgey> tswett: usually the term "binary search tree" is reserved for trees with data at internal nodes and the property that the data at a node is greater than all the data in the left subtree and less than all in the right (you can also add "or equal to" in various ways).
11:43:58 <kallisti> I'm guessing he meant that it had that property on the keys
11:44:03 <kallisti> and the values are the numbers.
11:44:04 <kallisti> ?
11:44:43 <mun> is x < 0 or x > 2 an interval?
11:44:54 <kallisti> no
11:45:02 <monochrom> two intervals, unioned
11:45:20 <mun> is there a name for this?
11:45:21 <monochrom> complement of one interval
11:45:29 <mun> right
11:45:50 <monochrom> "union of two intervals" (understood to be disjoint)
11:45:56 <mauke> unterval
11:46:01 <ion> hah
11:46:06 <dolio> uberval
11:46:08 <kallisti> outerval
11:46:10 <ClaudiusMaximus> i'd call it a line segment under certain circumstances..
11:46:25 <monochrom> open set :)
11:46:25 * kallisti would call it a set. :>
11:46:30 <tswett> Each node has a key and a value.  The keys satisfy the search tree criterion.
11:46:54 <mun> does an interval have to be defined wrt to some partial order?
11:47:03 <byorgey> tswett: oh, I see.  and the values satisfy the sum criterion.
11:47:06 <monochrom> yes
11:47:07 <tswett> Anyway, these things might be called Fenwick trees.  Let me see if they're the same thing that I have in mind.
11:47:14 <tswett> byorgey: yeah, that.
11:47:35 <mun> monochrom, what else is required to define an interval?
11:48:00 <monochrom> I think that's it. just need a partial order.
11:49:15 <mun> monochrom, so does that many for any number system  as long as it has a partial order defined, one would then be able to work with intervals?
11:49:22 <Younder> I'm just listening to Motzarts reuqiem. Pretty avesome.
11:49:38 <keep_learning> I have list xs
11:49:39 <mun> does one need to have some form of limits defined?
11:49:46 <keep_learning> to evaluate this
11:49:51 <Younder> sometimes things just go right
11:50:08 <keep_learning> Should I use deeseq xs () or deepseq xs xs ?
11:50:29 <kallisti> what do you want to return?
11:50:36 <kallisti> use that as the second argument.
11:50:51 <kallisti> if you want to force the list and return it, then the latter.
11:51:01 <monochrom> deeqseq xs (length xs) :)
11:51:06 <mun> then is [3] an interval?
11:51:11 <keep_learning> kallisti, I want to get the whole list evaluate
11:51:14 <mun> with one value
11:51:21 <monochrom> yes
11:51:26 <kallisti> mun: yes, assuming it's a set, that's the interval [3,3]
11:51:37 <mun> i see
11:51:53 <kallisti> keep_learning: I think you probably want the latter.
11:52:01 <keep_learning> kallisti, yes
11:52:09 <kallisti> but both force the entire list.
11:52:17 <keep_learning> kallisti, and when I should used the first one ?
11:52:25 <kallisti> when you... want to force xs and return ().
11:52:30 <kallisti> >_>
11:52:31 <keep_learning> I am getting bit of improvement over the second one
11:52:48 <hpaste> troubld pasted “what am i doing wrong?” at http://hpaste.org/66186
11:53:11 <monochrom> I think you're thinking imperatively. "force the list" but doesn't say what answer you want. "void deepseq(list x)" you're thinking
11:53:56 <keep_learning> monochrom, Almost similar
11:54:16 <kallisti> keep_learning: forcing a list doesn't do anything useful for you unless you also use it elsewhere.
11:54:26 <monochrom> unfortunately in haskell you seldom get work done by X->() functions
11:54:28 <keep_learning> monochrom, When I am passing the list after evaluating deepseq xs ()
11:54:45 <keep_learning> then time is bit 1 second more than deepseq xs xs
11:55:39 <keep_learning> kallisti, monochrom Thank you both
11:56:02 <monochrom> ok, suppose I want xs!!5 as the answer but I want all of xs forced. I will write deepseq xs (xs !! 5). that is how deepseq is supposed to used.
11:57:01 <keep_learning> will this be any different from your ( deepseq xs xs ) !! 5
11:57:01 <monochrom> it's like how to use seq. I want x+y as the answer but I x forced. seq x (x+y)
11:57:30 <kallisti> keep_learning: where are you apply deepseq and where are you using xs?
11:58:08 <keep_learning> kallisti, I just want to evaluate the whole list before passing it to function.
11:58:22 <kallisti> deepseq xs (f xs)
11:58:38 <monochrom> yeah, it all depends on the bigger picture
11:58:43 <kallisti> I'm not even sure how you would use deepseq xs () to accomplish this.
11:59:10 <kallisti> it's likely that you're seeing a speed improvement when you use deepseq xs () because the deepseq is not actually being evaluated.
11:59:19 <kallisti> but I would need to see the code to be certain.
12:01:19 <monochrom> how to use seq and deepseq in general: first ignore them, just write the expression that gives the right answer. then, choose a suitable subexpression and wrap your "seq x" or "deepseq xs" around it
12:01:37 <kallisti> for example if you did something like:   let x = deepseq xs ()  in f xs
12:01:41 <keep_learning> kallisti, Looks like I was doing it wrong . you deepseq xs ( f xs ) is what I was look for
12:01:45 <keep_learning> kallisti, thank you
12:01:46 <kallisti> then the deepseq is not actually being evaluated.
12:02:17 <keep_learning> kallisti, let me post the code
12:02:27 <monochrom> "let x = deepseq xs ()  in f xs" is thinking imperatively like in SML. Haskell doesn't work that way
12:03:41 <kallisti> you can think imperatively in the IO monad though:  do { deepseq xs (); f xs }   but there's really no reason to phrase it like that.
12:03:49 <kallisti> er  deepseq xs (return ())
12:05:58 <hpaste> keep_learning pasted “deepseq” at http://hpaste.org/66187
12:06:01 <kallisti> keep_learning: oh btw there's a function called ($!!) that's a shorthand of the deepseq xs (f xs)  case.
12:06:05 <kallisti> f $!! xs
12:06:08 <mun> for 2 intervals [1,2] and [5,6], is there a better way than saying '[1,2] is outside of [5,6]'?
12:06:16 <troubld> alright i've got the expect source code and will read that
12:06:32 <troubld> you guys suck for anything other than syntax questions
12:06:38 <troubld> bye
12:06:47 <kallisti> heh
12:07:00 <mun> oops wrong chan
12:07:27 <monochrom> [1,2] and [5,6] are disjoint
12:07:27 <kallisti> mun: [1,2] - [5,6] = {}
12:07:31 <kallisti> also that.
12:08:02 <kallisti> mathematically, you're dealing with sets. if you're doing interval arithmetic in a program you'll probably want to use a different representation though.
12:08:18 <kallisti> so all of the usual set operations are valid on intervals.
12:08:26 <shachaf> kallisti: I think what you said is the opposite of what you mean...
12:08:29 <magicman> [1,2] - [5,6] = [1,2] >_>
12:08:42 <kallisti> oh I meant intersection.
12:08:50 <kallisti> not difference.
12:09:00 <elliott> that troubld guy seems dissatisfied.
12:09:24 <monochrom> like the name says, troubled
12:09:25 <eliet> I have no idea what's going on.
12:09:32 <shachaf> eliet: It's going on in #agda
12:09:35 <begoryy> > sort "elliott"
12:09:36 <lambdabot>   "eillott"
12:09:40 <kallisti> oopse. mun: replace - with a big upside-down U   (super official terminology)
12:09:43 <shachaf> hpc sorted byorgey out.
12:10:13 <monochrom> hpc sorted is chp
12:10:13 <eillott> You should always begoryy.
12:10:23 <monochrom> @google chp haskell
12:10:25 <lambdabot> http://www.cs.kent.ac.uk/projects/ofa/chp/
12:10:26 <lambdabot> Title: Communicating Haskell Processes
12:10:31 <monochrom> \∩/
12:10:36 <timthelion> > sort "timthelion"
12:10:37 <lambdabot>   "ehiilmnott"
12:10:50 <eillott> > sort "monochrom"
12:10:51 <hpc> monochrom: oh man, perfect!
12:10:51 <lambdabot>   "chmmnooor"
12:10:55 <monochrom> btw [1,2] ∩ [5,6] is the notation you're looking for
12:10:57 <eillott> You know what to do...
12:11:13 <kallisti> eillott: you wouldn't happen to know about Control.Exception.Lifted would you? I'm wonder if catch actually preserves state changes.
12:11:34 <eillott> It does not (and cannot), if you mean that in the way I think you mean.
12:11:40 <kallisti> because the functions such as onException and finally come with big warnings that state changes won't actually be permanent.
12:11:44 <kallisti> but catch does not.
12:11:46 <eillott> But I don't know if you do mean it in that way.
12:12:00 <eillott> Or, wait.
12:12:04 <kallisti> hold on I have code.
12:12:09 <eillott> It also might. I don't know, question too vague.
12:12:18 <kallisti> http://hpaste.org/66181
12:12:20 <kallisti> like so.
12:12:31 <kallisti> the idea is to put the old state back in the event of an exception.
12:12:45 <kallisti> or actually to always put the state back, as a finalizer.
12:12:49 <eillott> It is easy to see that the state cannot advance if an IO exception occurs.
12:12:56 <eillott> This is because the only alternative would be to keep the state "just before" the exception.
12:13:07 <eillott> But the IO (a, s) doesn't return an (a, s), it throws an exception.
12:13:10 <eillott> Therefore that state is inaccessible.
12:13:27 <eillott> Therefore catch will reset the state to what it was at the beginning of the catch if an exception occurs.
12:13:39 <kallisti> oh, I see.
12:13:45 <roconnor> dolio: sure, but what is the type class for bang :: a b () ?  It seems likely related to the monoidal category stuff
12:13:48 <kallisti> ah, so I can still implement the semantics, just not like that.
12:13:51 <kallisti> I believe.
12:14:17 <kallisti> if I use try instead of catch.
12:14:30 <dolio> roconnor: I don't think there's a terminal object class.
12:14:36 <eillott> roconnor: (Arrows?)
12:14:47 <mk> types don't inherit from each other, do they?
12:14:50 <eillott> Maybe not.
12:14:50 <eillott> mk: No.
12:15:21 <dolio> () isn't terminal in all arrows, because there may be multiple distinct arrows into it.
12:15:33 <timthelion> > sortBy (\x y-> if (ord x)<(ord y) then GT else LT) "timthelion"
12:15:33 <kallisti> eillott: I just wasn't sure if MonadBaseControl had some clever way to preserve state. Mostly because I don't understand it at all.
12:15:34 <lambdabot>   "ttonmliihe"
12:15:38 <dolio> Like putStrLn "Hello" vs. putStrLn "Goodbye"
12:15:47 <dolio> Er, const of that.
12:15:48 <roconnor> but we have already established that arrows are retarded
12:15:56 <roconnor> or at least (***) and (&&&) are
12:16:01 <eillott> kallisti: It cannot do the impossible, regardless of its intelligence.
12:16:03 <timthelion> > reverse . sort "timthelion
12:16:04 <lambdabot>   <no location info>:
12:16:04 <lambdabot>      lexical error in string/character literal at end o...
12:16:04 <timthelion> "
12:16:07 <timthelion> > reverse . sort "timthelion"
12:16:08 <lambdabot>   Couldn't match expected type `[a]'
12:16:08 <lambdabot>         against inferred type `GHC.Types...
12:16:13 <eillott> roconnor: The generalised arrows stuff calls (a ~> ()) ga_drop, in the GArrowDrop typeclass.
12:16:25 <eillott> For whatever that's worth.
12:16:30 <eillott> Actually it's (a ~> u).
12:16:38 <nart> is it possible to "escape" from the IO monad, for example from IO String  to String ?
12:16:39 <roconnor> I was thinking of calling it "terminator"
12:16:39 <eillott> Parametrised on u. But whatever.
12:16:47 <eillott> nart: No.
12:16:53 <eillott> nart: See here:
12:16:57 <roconnor> nart: nope, use bind or do-notation instead.
12:16:59 <eillott> nart: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
12:17:04 <eillott> + the introduction it links
12:17:25 <nart> eillott: neither with unsafe...something ?
12:17:35 <dolio> roconnor: The thing about () is that it isn't quite as useful in the lens category. There are almost no global elements Lens () A.
12:17:57 <nart> i'm just experimenting from ghci, i won't write it in a real program
12:18:02 <nart> i know it's unsafe :D
12:18:07 <eillott> nart: If you're asking that question, by definition you do not yet understand when unsafePerformIO is OK/useful.
12:18:12 <eillott> Anyway, it's not part of Haskell.
12:18:25 <eillott> Some implementations offer it. Not all implemenations could, even theoretically.
12:18:27 <roconnor> dolio: I figure Lens A () might be as useful as the Void type.
12:18:54 <eillott> roconnor: oh, are you trying to wrangle arrows into something lenses can be?
12:19:00 <monochrom> Haskell 2010 includes FFI. FFI lets you implement unsafePerformIO yourself
12:19:07 <eillott> that might be difficult, with its dual co-and-contravariantness in both arguments
12:19:11 <nart> eillott: isn't unsafePermoIO useful to "debug" the program, isn't trace written with it ?
12:19:40 <eillott> nart: It's not useful to do that with unsafePerformIO in general; trace will cover practically all valid uses.
12:19:56 <roconnor> eillott: I'm trying to steal the arrow function symbols, redefine them and pour concrete on the shoes of the arrow operations and throw those opreations into a big lake.
12:21:01 <hpc> roconnor: make them sleep with the (>=>)'s?
12:21:16 <roconnor> hpc: yes, very good
12:21:23 <monochrom> what are you doing to my beloved arrow operations?!
12:21:41 <roconnor> monochrom: there is nothing beloved about (***); it is an abomination.
12:21:54 <roconnor> and presumably (&&&) too
12:21:54 <monochrom> hehe
12:22:16 <hpc> they're pretty damn awesome if you pretend (->) is the only arrow
12:22:25 <eillott> roconnor: you can't call (***) an abomination. it leaves no word left for arr
12:22:35 <hpc> @quote yarr
12:22:35 <lambdabot> hpc says: yarr, arr be rather arr-bitrary
12:22:41 <hpc> eillott: "arr-bitrary"
12:22:59 <eillott> Pirates aren't capable of the hate required for arr.
12:23:10 <hpaste> kallisti pasted “withSession (now trying harder!)” at http://hpaste.org/66188
12:23:20 <kallisti> eillott: this should work right?
12:23:31 <chrisdone> Philonous_: etags support!
12:23:31 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
12:23:32 <kallisti> oops I forgot put s
12:23:50 <hpaste> kallisti annotated “withSession (now trying harder!)” with “withSession (now trying harder!) (annotation)” at http://hpaste.org/66188#a66189
12:24:36 <eillott> I don't know. I don't know what "work" is, to start with.
12:25:07 <roconnor> I think it somewhere in Leviticus 18 it says that (***) is an abomination
12:25:22 <hpaste> yasar pasted “Operator” at http://hpaste.org/66190
12:25:29 <yasar> In above paster
12:26:03 <chrisdone> roconnor: don't start arrow about it!
12:26:04 <dolio> roconnor: I guess Void is initial for lenses, too?
12:26:10 <yasar> I am asked to write (-#) in terms of (#) and (>->) but I could't figure out how. Can anyone help?
12:26:26 <roconnor> dolio: probably
12:26:37 <yrlnry> Section 5 of Danvy and Filinski's paper "Representing control: a study of the CPS transformation" defines two operators called "reset" and "shift". "shift" is something like call-with-current-continuation.  There are no examples of "reset".  I don't understand the explanation in the paper.  What is somewhere else that I could read about these operators?
12:26:52 <mauke> oleg had something
12:26:55 <eillott> yasar: Hint: (m # k) has type Parser (a,b), as opposed to the Parser b you need.
12:27:01 <chrisdone> @google delimited continuations
12:27:03 <lambdabot> http://en.wikipedia.org/wiki/Delimited_continuation
12:27:03 <lambdabot> Title: Delimited continuation - Wikipedia, the free encyclopedia
12:27:29 <mauke> yrlnry: IIRC 'reset' establishes an anchor and 'reset' grabs everything from here to the anchor as a continuation
12:27:59 <yrlnry> mauke, chrisdone: many thanks.
12:28:03 <mauke> http://okmij.org/ftp/continuations/#tutorial
12:28:08 <mauke> ergh
12:28:24 <mauke> I meant 'shift' there
12:29:46 <yrlnry> Thanks again to both of you.
12:30:39 <hpaste> kallisti annotated “withSession (now trying harder!)” with “withSession (now trying harder!) (annotation) (annotation)” at http://hpaste.org/66188#a66191
12:30:46 <kallisti> okay I think this should be right.
12:31:36 <yasar> eillott: Thanks, but I am still not seeing it.
12:32:33 <mauke> m -# k = (m # k) >-> snd
12:32:54 <eillott> giving away the answer is one way to do it, I suppose :P
12:33:16 <kallisti> eillott: this should work, because the state revert happens outside of the catch, yes?
12:33:21 <yasar> mauke: oww, It didn't occur to me to use another function.
12:33:38 <eillott> yasar: You didn't need to use another function: >-> (\(a,b) -> b) would have worked just as well.
12:33:47 <mk> is there a way to write 5::Int without the type hint? That is, is there an int literal as there is a char literal 'x'?
12:33:50 <mauke> \(a,b) -> b is still a function
12:33:59 <mauke> mk: no
12:34:13 <eillott> kallisti: If you don't care about retaining the state if there's no exception, sure...
12:34:27 <eillott> mk: Well, "5" works just fine.
12:34:39 <eillott> (5 :: Int) works because 5 satisfies the type Int.
12:35:29 <kallisti> eillott: correct. The idea is that it acts similarly to local from MonadReader.
12:35:48 <kallisti> it changes the state for some local computation, then sets it back regardless of what hapens.
12:35:51 <kallisti> +p
12:35:58 <mk> right, but :t 5 yields 5::Num a=>a, rather than e.g. 'c'::Char
12:36:02 <eillott> kallisti: Um. So why not just do
12:36:34 <mauke> @src Int
12:36:36 <lambdabot> data Int = I# Int#
12:36:37 <eillott> withSession s' (WD wd) = WD . lift $ evalStateT wd s'
12:37:18 <mk> is adding extra ways of expressing 5::Int is considered merely useless, or incorrect in some sense?
12:37:32 <mk> -is
12:37:42 <kallisti> not needed, I would say.
12:37:50 <mauke> I haven't missed it
12:37:50 <eillott> mk: Well, it seems rather pointless. The only reason 'c' is Char is because that's the only charific type.
12:38:05 <eillott> mk: We have the OverloadedStrings extension that makes "abc" :: (IsString a) => a in turn.
12:38:13 <eillott> But there's still only one type for characters, whereas there are many numeric types.
12:38:27 <eillott> (5::Int) seems a perfectly fine notation if you absolutely must have a monomorphic value.
12:38:30 <kallisti> eillott: hm. I guess that does the same thing, in effect?
12:39:02 <mauke> :t let i x = x :: Int in  i 5
12:39:03 <lambdabot> Int
12:39:12 <mauke> notation!
12:39:53 <kallisti> > let i = (`asTypeOf` (undefined :: Int)) in i 5   -- obligatory pointfree style
12:39:54 <lambdabot>   5
12:39:56 <eillott> > let i = id :: Int -> Int in i 5 -- optimised
12:39:57 <lambdabot>   5
12:40:07 <kallisti> mine is more confusing, and thus better pointfree style.
12:40:11 <mk> alright - thanks
12:40:20 <mauke> :t let i x = x :: Int in  \(i -> x) (i -> y) -> (x, y)
12:40:21 <lambdabot>     Illegal view pattern:  (i -> x)
12:40:21 <lambdabot>     Use -XViewPatterns to enable view patterns
12:40:22 <lambdabot>     Illegal view pattern:  (i -> y)
12:40:25 <mauke> :-(
12:40:47 <mauke> > let i x = x :: Int in  (\(i -> x) (i -> y) -> (x, y)) 5 6
12:40:48 <lambdabot>   (5,6)
12:41:03 <mauke> > let i x = x :: Int in  typeOf (\(i -> x) (i -> y) -> (x, y))
12:41:04 <lambdabot>   Int -> Int -> (Int,Int)
12:41:05 <mauke> nice
12:41:38 <eillott> did mauke just turn on ViewPatterns? :P
12:41:46 <mauke> no
12:41:51 <eillott> oh, :t
12:41:59 <eillott> why is :t completely different to > again
12:42:24 <chrisdone> good question
12:43:07 <chrisdone> must be different hlint procedures rather than specified as file pragmas
12:43:27 <kallisti> eillott: so that "reverts" the state for any kind of exception, yes? I think I understand it correctly. How does it interact with monadic errors.
12:43:35 <kallisti> I have: newtype WD a = WD (StateT WDSession (ErrorT WDError IO) a)
12:43:40 <kallisti> but you probably inferred something like that.
12:43:48 <shachaf>  @ty can also give you the types of modules that > can't access at all.
12:44:04 <hpc> :t unsafeCoerce
12:44:05 <lambdabot> Not in scope: `unsafeCoerce'
12:44:09 <hpc> :(
12:44:19 <Mathnerd314> :t typeOf
12:44:20 <lambdabot> forall a. (Typeable a) => a -> TypeRep
12:44:24 <eillott> kallisti: monadic errors are thrown
12:44:26 <eillott> presumably
12:44:33 <eillott> it only peels off the StateT part of the stack.
12:44:41 <eillott> why the heck are you using ErrorT over IO?
12:44:49 <kallisti> eillott: I'm wondering this myself.
12:44:52 <hpc> eillott: "> " uses mueval, which uses a whitelisted subset of modules that are safe to evaluate
12:44:53 <eillott> 10 seconds before monochrom links that page on his site
12:45:01 <eillott> hpc: yeah, but why doesn't :t too? :(
12:45:02 <hpc> eillott: :t uses a pipe to ghci
12:45:14 <eillott> ooh, so all i need is to find an exploit in ghci
12:45:17 <hpc> and it doesn't evaluate anything, so more is safe
12:45:21 <monochrom> err, which page? :)
12:45:28 <hpc> eillott: no, you won't find an exploit :P
12:45:32 <elliott> monochrom: the ErrorT vs. exceptions thing
12:45:37 <monochrom> oh haha
12:45:39 <elliott> or was it Either vs. exceptions, same thnig
12:45:40 <elliott> *thing
12:45:43 <kallisti> eillott: when starting this project I seemed to have the mistaken notion that monadic errors are in some sense "better." also initially I wasn't using lifted-base so handling IO exceptions would have been painful.
12:45:44 <chrisdone> ivanm: :)
12:45:47 <hpc> :t id; fix id
12:45:48 <lambdabot> parse error on input `;'
12:46:05 <monochrom> http://www.vex.net/~trebla/haskell/exception.xhtml
12:46:12 <elliott> slightly more than 10 seconds
12:46:13 <elliott> but i'll allow it
12:46:35 <monochrom> well, I was reading Erik Meijer's article in ACM Queue!
12:47:13 <elliott> slacking off, in other words!
12:47:23 <elliott> F- dissatisfied customer
12:47:29 <monochrom> anyway, StateT ErrorT may or may not behave the way you like. ErrorT StateT behaves the same, despite all your opinion
12:47:38 <kallisti> also I asked one of those wonderful vague questions on this channel:  "is it better to use monadic errors or IO exceptions?" and people seemed to think that monadic errors were "better."  of course, I didn't mention anything about purpose.
12:48:32 <hpc> kallisti: better to use pure exceptions!
12:48:39 <hpc> it was hard to compile, it should be hard to run
12:49:17 <mk> what's a common example of a function with a Concrete -> Concrete type signature?
12:49:30 <elliott> mk: by concrete, do you mean monomorphic?
12:49:32 <Mathnerd314> hmm, so the main difference is that with EMonad, you can do :info EMonad and see what sorts of errors can be thrown
12:49:34 <monochrom> @type negate
12:49:34 <hpc> :t interact
12:49:34 <lambdabot> forall a. (Num a) => a -> a
12:49:35 <lambdabot> (String -> String) -> IO ()
12:49:41 <patate> hello
12:49:41 <mk> elliott: yes - thanks :)
12:49:43 <monochrom> oh, negate is too abstract
12:49:44 <elliott> almost all of the IO lib
12:49:46 <monochrom> @type not
12:49:47 <lambdabot> Bool -> Bool
12:49:48 <elliott> like interact, putStr, putStrLn, and so on
12:49:50 <ClaudiusMaximus> :t ord
12:49:50 <lambdabot> Char -> Int
12:49:53 <elliott> :t (&&)
12:49:54 <monochrom> that's pretty concrete and useful
12:49:54 <lambdabot> Bool -> Bool -> Bool
12:49:56 <elliott> ClaudiusMaximus: not in Prelude though
12:50:55 <mk> hmm. Is there a non-io one? ah - && looks great, thanks.
12:51:12 <kallisti> but I guess since my monad essentially acts as an IO-like base monad, it would make sense to use IO exceptions.
12:51:17 <hpaste> patate pasted “fgl graphviz” at http://hpaste.org/66192
12:51:19 <Mathnerd314> mk: but it's really a synonym for (++) :p
12:51:36 <elliott> (what Mathnerd314 says is not true.)
12:51:56 <kallisti> mk: if you're looking for monomorphic examples, avoid numeric functions. Char functions are pretty good.
12:52:09 <patate> I have a type checking problem with my fgl graphviz program
12:52:09 <monochrom> Bool is the best
12:52:21 <elliott> (Boolish b) => b -> b -> b
12:52:22 <patate> does somebody have an idea?
12:52:38 <elliott> class Boolish b where sheffer :: b -> b -> b
12:52:41 <hpc> data EnterpriseBool = True | False | FILE_NOT_FOUND
12:52:45 <elliott> oh, I forgot from
12:52:47 <elliott> fromBool
12:52:50 <kallisti> I find when teaching someone Haskell basics, char functions work well as an intro. there are multiple one-argument examples with monomorphic types.
12:52:54 <elliott> class Boolish b where { sheffer :: b -> b -> b; fromBool :: Bool -> b }
12:52:57 <byorgey> patate: you'll have to be much more specific than that.  Can you paste your code (along with the type error) on hpaste.org?
12:53:03 <Mathnerd314> elliott: sheffer is?
12:53:09 <elliott> class (Boolish b) => Boolean b where { toBool :: b -> Bool }
12:53:15 <elliott> Mathnerd314: sheffer stroke -- nand
12:53:25 <patate> byorgey: it s already on hpaste :)  http://hpaste.org/66192
12:54:09 <mk> is there anything for which :t yields ... Mono -> a ?
12:54:10 <elliott> patate: it doesn't know what kind of graph to use
12:54:22 <elliott> mk: "error"
12:54:23 <elliott> :t error
12:54:24 <lambdabot> forall a. [Char] -> a
12:54:47 <elliott> of course you cannot just conjure a value of type a out of nowhere. so error cheats, it raises an exception instead.
12:54:50 <monochrom> data CorporateBool = You_are_being_a_team_player | You_are_not_being_a_team_player
12:54:54 <byorgey> patate: yeah, you just need to fix a concrete type for your graph
12:54:57 <elliott> patate:   let a :: G.DynGraph gr => gr String ()
12:55:04 <patate> yep but graphviz have type constraint like Graph gr => gr a b but I have a DynGraph
12:55:04 <byorgey> patate: e.g. just give 'a' a concrete type signature
12:55:05 <elliott> patate: let a :: SomeConcreteGraphType String () instead
12:55:11 <mk> strange. Is there anything else which does that?
12:55:14 <elliott> which concrete graph type depends on what you want, of course
12:55:15 <kallisti> elliott: well, thanks for simplifying my vastly overcomplicated function. :P
12:55:19 <elliott> mk: well, here's another
12:55:23 <elliott> :t \x -> fix id
12:55:24 <lambdabot> forall t a. t -> a
12:55:30 <elliott> (specialise to String -> a)
12:55:31 <byorgey> patate: oh, you mean there is nothing which is both Graph and DynGraph?
12:55:33 <elliott> mk: that one just loops forever.
12:55:45 <elliott> of course there's also throw from the exception library...
12:55:50 <monochrom> parametricity implies that Mono->a is boring
12:56:00 <elliott> mk: basically anything that conjures up a fully-polymorphic value from nowhere must return _|_ ("bottom")
12:56:08 <elliott> which is what we call non-termination and exceptions
12:56:22 <elliott> mk: of course, you can have e.g.
12:56:35 <elliott> foo :: (Integral a) => Maybe Int -> a
12:56:42 <elliott> where it uses 0 if it's Nothing or otherwise converts the Int inside
12:56:48 <elliott> but that's not really fully polymorphic on a, because of the constraint.
12:57:19 <patate> byorgey: I mean DynGraph is derived from the Graph typeclass but graphviz' which take a Graph doesn't seem to like to take a DynGraph
12:57:36 <mk> interesting
12:57:38 <ClaudiusMaximus> patate: you might want to pick one of http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-Tree.html#t:Gr or http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-PatriciaTree.html#t:Gr
12:57:43 <mk> elliott: thanks
12:58:04 <byorgey> patate: that doesn't make sense.  graphviz' will take any type which is an instance of Graph.  It doesn't know or care whether that type is also an instance of DynGraph or not.
12:58:28 <patate> ClaudiusMaximus: ah I see, I will try that
12:58:39 <ClaudiusMaximus> patate: otherwise the compiler doesn't know which of the possible implementations of graphs that might exist to pick for you
12:58:58 <byorgey> patate: just change  a :: G.DynGraph gr => gr String ()   to   a :: Gr String ()
12:59:11 <patate> byorgey: ok, now I see where my issue is
12:59:12 <byorgey> oh, or maybe  G.Gr String ()
12:59:22 <patate> thank you guys :)
12:59:25 <byorgey> Data.Graph.Inductive re-exports Data.Graph.Inductive.Tree
12:59:31 <byorgey> you're welcome =)
13:05:02 <hpaste> lifestream pasted “Int -> [Int]” at http://hpaste.org/66193
13:05:04 <lifestream> So I've been staring at the computer screen for 5 hours, could someone give me a hint how I would take an integer and make a list of its digits? Using only the stuff in Prelude. (see paste above)
13:05:30 <hpc> :t 123456 :: Integer
13:05:31 <lambdabot> Integer
13:05:37 <hpc> :t show (123456 :: Integer)
13:05:38 <lambdabot> String
13:05:41 <cheater> etc
13:05:55 <hpc> :t map (:[]) (show (123456 :: Integer))
13:05:56 <lambdabot> [[Char]]
13:05:56 <cheater> > map read (show 12345 :: Integer)
13:05:57 <lifestream> I need to get [Integer], not [Char]
13:05:57 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
13:05:57 <lambdabot>         against inf...
13:06:14 <cheater> > map read (show 12345 :: Integer) :: [Int]
13:06:15 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
13:06:15 <lambdabot>         against inf...
13:06:19 <hpc> > map (read . (:[])) . show $ 123456
13:06:21 <lambdabot>   [*Exception: Prelude.read: no parse
13:06:24 <cheater> > map read (show 12345 :: Int) :: [Int]
13:06:25 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:06:25 <lambdabot>         against inferred type ...
13:06:30 <cheater> what's going on?
13:06:34 <hpc> > map (read . (:[])) . show $ 123456 :: [Int]
13:06:36 <lambdabot>   [1,2,3,4,5,6]
13:06:53 <lifestream> OK, one second.
13:06:53 <hpc> cheater: can't read a char
13:07:13 <ClaudiusMaximus> > (25 `div` 10, 25 `mod` 10)
13:07:14 <lambdabot>   (2,5)
13:07:18 <cheater> riight
13:07:47 <elliott> hpc: pure is a much nicer spelling than (:[]) :(
13:07:52 <ClaudiusMaximus> > (125 `div` 10, 125 `mod` 10)
13:07:53 <lambdabot>   (12,5)
13:08:03 <elliott> > (map (read . pure) . show) 123456 :: [Int]
13:08:04 <lifestream> ClaudiusMaximus: if I do that, I get a topple?
13:08:04 <lambdabot>   [1,2,3,4,5,6]
13:08:16 <elliott> Wait.
13:08:19 <elliott> Using only the stuff in Prelude?
13:08:24 <elliott> Homework, right?
13:08:37 <elliott> If yes, ignore everything hpc and I said :P
13:08:45 <lifestream> Yes, only predule. No, I'm not in school, I'm trying to learn on my ow
13:08:50 <lifestream> *own.
13:09:00 <elliott> Oh, okay.
13:09:04 <elliott> Then why the Prelude-only restriction?
13:09:44 <angstrom> :t quotRem
13:09:44 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
13:09:58 <lifestream> I'm following this professor's lessons (available online), he gives out lectures and homework to the public, I'm only at lesson 1 right now.
13:10:32 <lifestream> Good thing this is not for school, I would have dropped out of the class in a panic already :P
13:12:03 <lifestream> I mean, I know of things like "show", $, but those things haven't been introduced yet in the lesson I'm at
13:13:00 <elliott> Oh, ok, so it *is* homework, just not homework you're required to do ;)
13:13:33 <elliott> When "Is this homework?" is asked in here, it's not to chastise or deny help if the answer is yes; it's just so we can know to give hints and suggestions rather than giving the solution outright, which won't help you learn.
13:13:54 <ClaudiusMaximus> lifestream: you can use mod to "extract" the least significant digit, like you said in your paste, and div "removes" the least significant digit, and you can then repeat the process to get the next digit, figuring out when to stop
13:15:40 <lifestream> So then I just have to cons each result into a list. I was missing the "divide" part. Thanks!
13:15:59 <gnoi> Homework tag just takes care about spoilers
13:16:01 <gnoi> !
13:17:03 <lifestream> (Homework for myself only, I'm not in university)
13:17:08 <monochrom> skip the "is it homework?" part. just always answer in a way that helps you learn. and in some cases it means going straight to the concrete answer, homework or not
13:17:43 <lifestream> I like to make sure I understand things before I move on to the next lesson. It's a good thing too, this professor gives out fun homework!
13:17:45 <elliott> well, going straight to the concrete answer when it is homework has ethics issues :p
13:18:00 <monochrom> the concrete answer serves as a concrete example to learn from. concrete before abstract.
13:18:22 <lifestream> The problem is some people are sneaky and just want the grade, rather than learn from the answer, monochrom  ;)
13:19:08 <parcs`> that's not a problem
13:19:15 <parcs`> some people just have different priorities
13:19:26 <lifestream> I already feel slimy because I tried to look at the source code of toDigit in desperation :P But anyway, I couldn't understand any of it :P
13:19:53 <monochrom> oh? if you know the preconditions for spelling out the solution in plain to help learning, you won't be worrying about its impact on grades
13:20:11 <monochrom> namely, the precondition is that the question and the answer are both pretty trivial
13:20:21 <ciaranm> just give the answers in caleskell
13:20:24 <monochrom> and also worth trivial marks
13:20:31 <elliott> ciaranm++
13:20:31 <ciaranm> that should be enough to deter homework questions
13:20:56 <lifestream> Caleskell ? :o
13:21:11 <ciaranm> i still get yelled at for using . for fmap, and i don't even do homework any more!
13:21:53 * hackagebot RSA 1.0.6.3 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-1.0.6.3 (AdamWick)
13:22:32 <monochrom> Example. "Q: how do I find the ascii value of a char?" you're better off just showing the example ord 'x' than "oh, this is homework, I'm going to be smug about it, visit this url, read it, think about it, hint: what would be the type of the function?"
13:22:54 <ciaranm> that's not a homework question
13:23:18 <mauke> "what would be type of the function?" could be a good way to tell them about hoogle
13:23:26 <monochrom> I mean, if you spell out "ord" the reader already knows how to look it up and read more about it and learn
13:23:27 <mauke> i.e. it's a meta-answer
13:24:22 <elliott> lifestream: the dialect of haskell lambdabot accepts
13:24:23 <monochrom> "what would be the type of the function" is a good hint for those who are sufficiently proficient in type expressions
13:24:27 <elliott> it has some... unconventional extensions
13:24:35 <monochrom> it is a bad hint for those still confused about types
13:24:58 <monochrom> but you can spell out "hoogle for Char->Int" and then it is a good hint for both
13:24:58 <ciaranm> well they need to get unconfused about types
13:25:15 <monochrom> oh yes, how do you unconfuse them about types?
13:25:27 <monochrom> by giving concrete examples such as Char->Int
13:25:29 <mauke> monochrom: I don't think I disagree with you
13:25:41 <monochrom> concrete before abstract
13:25:50 <monochrom> Piaget's theory
13:26:00 <ciaranm> you start by teaching them system F
13:26:12 <mauke> heh
13:26:23 <ciaranm> well... you start by teaching untyped lambda calculus
13:26:27 <ciaranm> then system f
13:26:31 <mauke> of course
13:26:53 * hackagebot BoundedChan 1.0.0.3 - Implementation of bounded channels.  http://hackage.haskell.org/package/BoundedChan-1.0.0.3 (AdamWick)
13:29:19 <lispy> ?ping Cale
13:29:19 <lambdabot> pong
13:29:30 <lispy> ?get-cale
13:29:30 <lambdabot> Unknown command, try @list
13:29:35 <Cale> hello
13:29:57 <nart> what's the best way to get the last line of an handler ?
13:30:03 <lispy> Cale: how's it going?
13:30:08 <Cale> all right :)
13:30:24 <lispy> Cale: Are you the right persot to talk to if I wanted lambdabot to see in a new channel?
13:30:31 <Cale> lispy: yes
13:30:40 <lispy> cool, sending you an email
13:30:52 <Cale> (I am after all still running it on the account I have on your machine :)
13:31:12 <Cale> You can just tell me which channel, and I'll have it join right away
13:31:38 <lispy> Cale: it's not actually for me.  I think email will be easiest
13:33:00 <kyagrd__> How can a sane person be confused about types?
13:33:23 <monochrom> I don't know? but how do you know that students are sane?
13:33:28 <lispy> kyagrd: how can a sane person be confused by logic?
13:33:33 <zzo38> data CoPh x;     Answer the question what you think: Does this form a monad? Does this form a comonad? (My answer is no to the first question, and yes to the second. Although some people say no to both or yes to both.)
13:33:51 <monochrom> also it could be just confused about the type syntax rather than the types
13:33:55 <kallisti> wow. Typeable is nice for complex exception handling.
13:34:06 <zzo38> If you want, give a reason.
13:34:12 <kyagrd> I mean types makes it much more clear about programs. Untyped programs are more confusing.
13:35:21 <zzo38> kallisti: I find Typeable useful for a number of things.
13:36:12 <kyagrd> In reality, GHC type error message might sometimes be confusing though (e.g., impossible has happenned).
13:36:42 <dolio> That isn't a type error, is it?
13:36:48 <lispy> kyagrd: I don't think types are easy to understand, but I do agree that they are worth it.
13:36:58 <zzo38> What do *you* think about CoPh? Different people have said different answers, but so far only one each.
13:37:24 <kallisti> PS !!ForeignPtr Word8 !!Int !!Int
13:37:27 <kallisti> can someone remind me what this notation means.
13:37:33 <kallisti> is it "REALLY strict"  :P
13:37:50 <dolio> It's how haddock displays unpacked fields.
13:37:57 <vitno> is there some sort of official hakell style guide? Everything I've read says 8 spaces but when I look at code examples it often uses 4
13:37:58 <kallisti> ah I see.
13:38:07 <dolio> {-# UNPACK #-} !Int turns into !!Int for some reason.
13:38:09 <ben> They're clearly accessing the ForeignPtrth element of the list PS, and so on
13:38:11 <kyagrd> lispy: Well, I think types are easy to understand. What is difficult and confusing is when you teach students recursive (or, inductive) data structures before intruducing recursive (or, inductive) types.
13:38:14 <monochrom> "!!ForeignPtr" seems like a mistake
13:38:15 <kallisti> dolio: interesting
13:38:19 <elliott> vitno: Everything you've read says 8 spaces?
13:38:24 <elliott> You've read some weird things.
13:38:29 <kallisti> monochrom: submit a bug report to the bytestring maintainer, then. ;)
13:38:32 <zzo38> vitno: I use 2 spaces, and non-layout, but use what you like to use.
13:38:36 <kyagrd> Everything made sense about lists and trees after learning about datatypes in functional languages.
13:38:43 <elliott> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md This one is popular.
13:39:03 <kyagrd> I leared lists and trees with C, which just made me lost with pointer hacking.
13:39:12 <kyagrd> typo, leanred.
13:39:23 <vitno> ahh, I like that. much better
13:39:24 <vitno> thanks
13:39:49 <ben> I'm really not a fan of the thing where you align [s with ,s
13:40:06 <kyagrd> ah "learned"
13:40:14 <ben> or {s
13:40:22 <kallisti> ben: I like it. :D
13:40:28 <ben> I mean, yeah, I get what they're going for but that's gotta be really unintuitive compared to the layman's use of punctuation
13:40:41 <nyingen> I sure would like it if haskell permitted e.g. [1,2,3,]
13:40:44 <kallisti> as with anything, you get used to it pretty quickly.
13:41:08 <ben> Maybe we'd be better off with some specical bullet-point-style list syntax
13:41:13 <kyagrd> Types does get confusing when you first see the impredicative encoding of datatypes Chruch encoded terms, but I don't think we are talking about that.
13:41:16 <ben> instead of abusing those poor commas
13:41:28 <kallisti> nyingen: try using the style that we're discussing right now and you might have less of a problem with accidental trailing commas.
13:41:59 <nyingen> kallisti: I never have a problem with trailing commas, myself. I just don't like the 'comma-first' style, and I don't think people would use it if trailing commas were allowed
13:42:14 <kallisti> I ould.
13:42:15 <kallisti> +w
13:42:29 <dolio> I would, too.
13:42:38 <nyingen> comma-first--
13:42:43 <lifestream> Yaaaaaaaaay, I did it :)   toDigits n = (mod n 10) : (toDigits (div n 10)) ... next challenge *wipes sweaty brow*
13:42:53 <lispy> Cale: I forgot to mention in the email, this guy is a friend and co-worker.
13:43:28 <mauke> lifestream: does it work for 0?
13:43:32 <Cale> okay, y u no tell me the channel name?
13:43:43 <lifestream> mauke: yes and negative numbers, I set some conditions above that line
13:44:25 <kallisti> nyingen: in fact the reason why I like comma-first style is entirely unrelated to accidental trailing commas.
13:45:34 <Cale> lispy: I literally need only one piece of information in order to have lambdabot join an additional channel, the name of the channel itself.
13:45:43 <adnauseam> in Either's MonadPlus' definition "instance (Error e) => MonadPlus (Either e) where" ..., what does n stand for in "Left _  `mplus` n = n", does it stand for Right x?
13:45:52 <Cale> lispy: If you can get me that piece of information, that's all I need to have lambdabot join it.
13:46:14 <nyingen> kallisti: oh?
13:46:32 <lispy> Cale: Sorry, I don't actually know the channel name
13:46:39 <kallisti> yes, I mainly like it because I think it looks nicer.
13:46:41 <nyingen> is it because you don't like to edit the previous line when adding an item to the end of the list?
13:46:42 <geekosaur> adnauseam, it stands for some other value which is unknown
13:46:44 <elliott> Can you make lambdabot join... a channel? Any channel.
13:46:49 <kallisti> nyingen: that too
13:46:53 <Cale> lispy: Okay, well, ask him about it and get back to me then :)
13:46:58 <elliott> #ubuntu. Or ##extreme-fishing.
13:47:12 <elliott> Or... ###.
13:47:25 <Cale> elliott: I could... are you serious about any of those?
13:47:55 <kallisti> nyingen: I like symmetry in code layout. so I like that the commas line up. Also each line being independent of every other when editing is a small benefit but not really very important.
13:48:04 <adnauseam> geekosaur: aye, in that context too?
13:48:27 <adnauseam> geekosaur: i'm not too familiar with Either
13:48:50 <geekosaur> adnauseam, I'm not entirely sure what you're asking, tbh.  the point is that if we have a Left, and we mplus anything to it, we get the anything and the original Left is discarded
13:48:58 <elliott> Cale: Well, no.
13:49:22 <elliott> Though I expect if lambdabot joined #ubuntu, not a single person would notice, considering how noisy that place is :P
13:49:46 <adnauseam> geekosaur: hrm, i wanted to understand what n may be
13:49:53 <geekosaur> the new value might be a Left or a Right, we don't care; we just care that a Left gets overridden.  that way we grab the first Right that shows up
13:50:07 <adnauseam> can it be anything other than a right ?
13:50:55 <geekosaur> it can be a Left or a Right, as I said, we don't care.  (here.  what happens in the equation given an intiial Right determines whether we keep the first Right that shows up or the last)
13:51:54 * hackagebot SHA 1.5.0.1 - Implementations of the SHA suite of message digest functions  http://hackage.haskell.org/package/SHA-1.5.0.1 (AdamWick)
13:51:56 * hackagebot sqlite 0.5.2.1 - Haskell binding to sqlite3  http://hackage.haskell.org/package/sqlite-0.5.2.1 (AdamWick)
13:54:09 <adnauseam> geekosaur: hrm,  i should get a better understanding of Either - thanks for the help man
13:54:28 <geekosaur> @src Either
13:54:28 <lambdabot> Source not found. My pet ferret can type better than you!
13:54:30 <yescalona> anyone use xmonad with xfce4.8??
13:54:34 <geekosaur> huh
13:55:05 <elliott> adnauseam: you know Maybe?
13:55:16 <elliott> Either is like Maybe, except its version of Nothing carries a value too
13:55:21 <geekosaur> oh.
13:55:23 <elliott> Maybe is Nothing or Just a, Either is Left a or Right b
13:55:26 <geekosaur> @src Either mplus
13:55:27 <lambdabot> Left _ `mplus` n = n
13:55:27 <lambdabot> m      `mplus` _ = m
13:56:20 <geekosaur> so:  if we have a Left we always replace it with the other argument.  otherwise we keep what we have; thus mplus finds the first Right in a series
13:56:50 <geekosaur> @src Either mzero
13:56:50 <lambdabot> mzero            = Left noMsg
13:57:07 <adnauseam> elliott: yeah, Maybe a, i think i have a good non-practical (haven't really gotten to implement it yet) understanding of Maybe a
13:57:08 <sm> when using Control.Exception.catch, how do you fix "Ambiguous type variable `e1' in the constraint" when your error handler does not use the exception argument ?
13:57:35 <mgsloan> hmm.  I'm trying to make an existential wrapper for a few type classes, and in the instances I'm getting errors of the form "No instance for (Interactive (forall a. (Interactive a,  ...) => a))"
13:58:21 <mgsloan> makes no sense.. :/
13:58:31 <elliott> adnauseam: heh, implementing it is as simple as stating what i said
13:58:34 <geekosaur> it's not so much what Either is about, as about what mplus is about
13:58:44 <elliott> sm: (\(e :: MyType) -> ...) with ScopedTypeVariables extension
13:58:45 <elliott> sm: *or*
13:59:02 <elliott> sm: (\e -> blah `const` (e :: MyType))
13:59:07 <elliott> or such if you want to avoid the extension
13:59:23 <sm> elliott: ah, thank you
13:59:38 <adnauseam> geekosaur: aye, it's that MonadPlus business :p
13:59:52 * sm befriends ScopedTypeVariables
14:00:07 <adnauseam> mplus being similar to cont i think
14:00:29 <adnauseam> i might be wrong
14:00:46 <adnauseam> hmm
14:00:54 <adnauseam> i think i understood my initial question now
14:01:33 <geekosaur> adnauseam, so, if you know Maybe, you can think of Either as Maybe but where the "Nothing" can carry a value; useful if you have an error message you want to propagate (which is why you have an Error constraint there, as a formalization of the convention where Left is an error corresponding to Nothing and Right is a value coresponding to Just)
14:02:47 <geekosaur> (gradually the libraries are moving to a state where Either is being divorced from the Left=error notion, instead Error is used as a wrapper for it that carries the notion)
14:03:01 <elliott> They are?
14:03:08 <elliott> Error is abominable.
14:03:11 <elliott> I haven't seen anyone use it.
14:04:00 <adnauseam> geekosaur: yeah, it clicked :D
14:04:46 <kallisti> can someone help me with some lifted-base magic?
14:04:56 <kallisti> my MonadBaseControl instance seems to be faulty.
14:05:03 <elliott> Isn't your thing just a newtype?
14:05:07 <elliott> Just derive the instance.
14:05:13 <kallisti> type families. :(
14:05:58 <hpaste> kallisti pasted “MonadBaseControl problem?” at http://hpaste.org/66194
14:06:02 <geekosaur> elliott, what I am seeing is Error used to be kinda useless, but recent changes are seeing it take on a more formalized role.  there was some discussion about it a while back on libraries@, IIRC
14:06:10 <kallisti> the program types, but it doesn't appear to be doing anything?
14:06:23 <kallisti> I'll run some more tests to figure out exactly what is going on.
14:06:34 <shapr> Hail Eris!
14:06:40 <notthemessiah> how would turn a derived Enum into a algebraic cyclic group? (succ end = start)? It's giving me an ambiguous occurance error. (Main.succ or Prelude.succ?)
14:06:50 <elliott> geekosaur: meh... i think we should relegate it to ErrorT and put big warning signs on the whole module saying it's awful, then introduce a proper EitherT without a fail :)
14:07:05 <monochrom> kallisti: a couple of "trace"s may help :)
14:07:28 <elliott> notthemessiah: you have a definition of "succ" in your code
14:07:33 <elliott> but that conflicts with the Prelude's succ
14:07:38 <elliott> name it something else
14:07:40 <kallisti> well, the handler in question catches SomeException and prints it.
14:07:42 <monochrom> and yes, these deeply lifted-and-buried exception handlers can have very non-obvious control flow
14:08:07 <elliott> kallisti: I know that instance is wrong.
14:08:11 <elliott>   data StM WD a = StWD {unStWD :: WD a}
14:08:13 <elliott> That's not right.
14:08:16 <kallisti> good good.
14:08:23 <elliott>   data StM WD a = StWD {unStWD :: StM (StateT WDSession IO) a}
14:08:25 <elliott> That is.
14:08:31 <kallisti> aha
14:08:34 <elliott> Just do what a smarter newtype deriving engine would do.
14:08:54 <kallisti> I am not well-versed in type families so I find this code kind of alien.
14:09:00 <geekosaur> elliott, I think that is the ultimate goal, but as with most of these rearrangements to the core it's being done in small hopefully less disruptive steps
14:09:08 <monochrom> and I am not a smart engine :)
14:09:18 <monochrom> (ok, I am)
14:09:23 <notthemessiah> elliot: can I override it? or does enum have to be bounded?
14:09:30 <geekosaur> (see for example how much disruption the small step of killing Eq and Show for Num has caused...)
14:09:43 <elliott> notthemessiah: I don't really understand your question. If you use "deriving" then you can't override parts of the instance.
14:10:12 <kallisti> I have a feeling this code would be much simpler with a type family synonym rather than data type.
14:10:23 <elliott> geekosaur: I don't think my plan would even break backwards compatibility, if you just ErrorT around forever to rot :)
14:10:24 <monochrom> yeah, there is no "deriving Enum except change this..."
14:10:38 <elliott> kallisti: It doesn't use an associated type synonym because of a GHC bug.
14:10:45 <kallisti> yes
14:10:58 <notthemessiah> but the only change is changing something that would otherwise be an error
14:11:06 <geekosaur> it was thought killing Eq and Show wouldn't cause noticeable breakage either...
14:11:15 <monochrom> but I have a cunning plan
14:11:46 <monochrom> data X0 = A | B | C deriving Enum
14:11:54 * hackagebot live-sequencer 0.0.1 - Live coding of MIDI music  http://hackage.haskell.org/package/live-sequencer-0.0.1 (HenningThielemann)
14:12:06 <monochrom> newtype X1 = X1 X0
14:12:19 <notthemessiah> oh, I could have to implement it with "instance Enum X0"
14:12:41 <monochrom> instance Enum X1 where  succ (X1 C) = X1 A; succ (X1 e) = X1 (succ e)
14:13:17 <monochrom> now X1 is cyclic and morally X0
14:13:25 <notthemessiah> monochrom: thanks, that's what I wanted.
14:13:50 <monochrom> actually, I am not convinced you really want this way. but whatever floats your boat!
14:14:32 <monochrom> I am also not convinced that general expectation of Enum allows cyclicy
14:14:36 <elliott> My boat sure feels floated.
14:14:51 <elliott> > succ maxBound :: Int  -- everything on Ints overflows; that succ doesn't suggests to me that a cyclic Enum instance is breaking the ill-defined rules
14:14:52 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
14:14:52 <monochrom> some people want their boats double, not float :)
14:15:09 <kallisti> monochrom: Bounded + Enum can be cyclic
14:15:15 <elliott> Can it?
14:15:16 <vitno> I'm readig about lambdas right now. Is there anything they can do that "where" can't?
14:15:32 <elliott> vitno: You can always rewrite a lambda as a local definition, if that's what you mean.
14:15:35 <mauke> vitno: yeah, create functions
14:15:36 <kallisti> elliott: I mean, you can sanely write a function that cycles through the values and expect it to repeat at some point.
14:15:42 <elliott> vitno: OTOH "f a b c = ..." is just sugar for "f = (\a b c -> ...)".
14:15:50 <geekosaur> should we dig that bikeshed out of the lists?  I think there was discussion of rearranging Enum because it conflates two concepts, one of which allows cyclicity to make sense and the other doesn't
14:15:58 <elliott> kallisti: Well, uh... yeah.
14:16:11 <elliott> geekosaur: more importantly, it conflates range creation and enumeration of values
14:16:13 <geekosaur> or maybe 3 concepts; it was getting pretty thick in there toward the end :)
14:16:20 <monochrom> alright, there is little expectation
14:16:20 <geekosaur> yes
14:17:22 <monochrom> no, there are strict expectations
14:17:32 <monochrom> "The calls succ maxBound and pred minBound should result in a runtime error."
14:17:35 <elliott> I strictly expect Enum instances to not make any sense.
14:17:56 <elliott> monochrom: does Bounded even require Enum?
14:18:06 <elliott> laws like that are ugly, they break the open-world assumption
14:18:18 <monochrom> no, but now it refutes your "Bounded + Enum can be cyclic". explicitly banned
14:18:32 * monochrom not a fan of open-world to begin with
14:18:35 <elliott> someone defines Enum, correctly. someone unrelated, in another universe, defines Bounded, correctly. someone else entirely manages to get both these instances in scope
14:18:52 <elliott> now the instances are wrong, but nobody did anything wrong
14:18:55 <kyagrd> monochrom: does that mean you are not fan of type classes?
14:19:22 <monochrom> not a fan of type-classes-without-axioms
14:19:34 <notthemessiah> I guess it depends if succ defines an ordering relation or not.
14:19:52 <kallisti> that would be Enum + Ord
14:19:58 <monochrom> if you impose enough axioms, open-world vs closed-world can be irrelevant
14:20:10 <geekosaur> Bounded does not require Enum
14:20:26 <elliott> geekosaur: right. then i complain :)
14:20:39 <elliott> notthemessiah: "The calls succ maxBound and pred minBound should result in a runtime error." is pretty unambiguous
14:20:50 <monochrom> so for example, even though you write an Enum instance and not a Bounded instance, you can make it acyclic. now anyone else adding a Bounded instance will not cause a problem
14:21:15 <monochrom> in light of that, IMO, the author of a cyclic Enum instance is the one doing wrong.
14:22:06 <elliott> monochrom: true, agreed. it is more of a philosophical objection than anything else
14:22:39 <elliott> the right thing to do is probably obvious in all practical cases. but i still don't like classes dictating things about instances of classes that aren't superclasses
14:23:00 <elliott> haha, happstack are playing the website-prettiness game
14:23:02 <geekosaur> (has someone done the new-Prelude version of this bikeshed yet?  if so, what did they do with Float/Double?)
14:23:25 <elliott> geekosaur: oh, there's also a problem with Ix
14:23:32 <elliott> in that it's kind of awkwardly duplicating IIRC
14:23:36 <monochrom> it is of course more preferrable if Enum axioms did not mention Bounded, and the axioms still strong enough that once Bounded axioms are added, you get "succ maxBound is an error"
14:23:51 <elliott> geekosaur: i seem to remember agreeing with one of the proposals in that discussion which accounted for Float and Double being rangable but not enumerable, it unified Ix too
14:23:55 <elliott> but I don't remember the proposal itself
14:25:00 <geekosaur> elliott, I was referring to that, yes, but I meant "is there an alternative Prelude with this in the wild yet?"
14:25:59 <hpaste> kallisti annotated “MonadBaseControl problem?” with “MonadBaseControl problem? (annotation)” at http://hpaste.org/66194#a66195
14:26:03 <kallisti> so I'm completely lost...
14:26:22 <geekosaur> and, that axiom doesn't belong in Enum, it belongs in Bounded with a "if it's also Enum" (and potential future "and it's not Cyclic")
14:27:10 <geekosaur> (where "class (Enum b, Bounded b) => Cyclic b" such that maxBound wraps to minBound)
14:27:26 <kallisti> I think I need to apply liftBaseWith on the inner monad, but I don't know how to convert the functions correctly.
14:28:07 <elliott> geekosaur: i doubt it. Overture is the only "alternate prelude" that seems to have anybody caring about it these days, and it explicitly doesn't mess with classes
14:28:37 <elliott> kallisti: that StM definition is not what i told you to use
14:28:59 <kallisti> oh, indeed
14:29:17 <elliott> data StM WD a = StWD {unStWD :: StM (StateT WDSession IO) a}; restoreM = WD . restoreM . unStWD
14:29:23 <elliott> liftBaseWith should go similarly.
14:29:30 <elliott> modulo newtype wrapping/unwrapping, your instance should be circular
14:29:37 <elliott> i.e. if you strip out all of that it should look like f = f; g = g
14:29:42 <elliott> just like newtype-derived instances do
14:29:57 <kallisti> ah I bet the lack of the restoreM is causing the problem.
14:30:23 <kallisti> man, I'm bad at this...
14:30:28 <elliott> I don't know what you mean.
14:30:49 <kallisti> me neither. I really only have a hazy idea of what's going on here. :P
14:31:43 <sm> sounds like a typical haskell programmer :)
14:32:05 <kallisti> yep. I just want my lifted-base to work, and suddenly I'm in type family monad transformer hell.
14:33:06 <kallisti> I'd like to figure it out though..
14:33:59 <kallisti> okay so for RunInBase I think I need to actually run my monad.
14:34:06 <elliott> <elliott> modulo newtype wrapping/unwrapping, your instance should be circular
14:34:11 <elliott> You are thinking too much.
14:34:18 <elliott> You already have an instance for WD, because StateT has an instance.
14:34:21 <elliott> Just use it.
14:34:25 <kallisti> yes I know, however.
14:34:29 <kallisti> there's the nested function stuff.
14:34:34 <kallisti> that's what I'm trying to wrap my head around.
14:35:11 <kallisti> ah wait.
14:35:14 <elliott> liftBaseWith f = WD $ liftBaseWith (\runInBase -> f (\(WD m) -> runInBase m))
14:35:16 <elliott> I believe.
14:35:23 <kallisti> yes
14:35:30 <kallisti> I had just arrived at that conclusion, minus the actual code.
14:36:27 <kallisti> hm
14:36:34 <kallisti> oh yes.
14:36:39 <kallisti> okay.
14:36:52 <zhulikas> okay
14:37:08 <kallisti> something similar to runWithBaseDefault actually
14:37:29 <kallisti> or whatever it's named.
14:37:34 <kallisti> defaultLiftBaseWith
14:37:58 <elliott> Oh, just do what http://hackage.haskell.org/packages/archive/monad-control/0.3.1.1/doc/html/Control-Monad-Trans-Control.html#g:1 says.
14:38:11 <elliott> Or, hm.
14:38:12 <elliott> No, don't.
14:38:14 <elliott> That's wrong.
14:38:24 <elliott> It'll bypass the StateT instance, which is not what you want.
14:38:50 <kallisti> it will?
14:38:58 <elliott> Yes.
14:38:59 <kallisti> isn't liftBaseWith being called for the StateT instance?
14:39:10 <elliott> Not in that documentation.
14:39:11 <elliott> Honestly, if you just want exception handling I think you should just write your own catch/finally.
14:39:28 <kallisti> yes, I had considered that. I would already be done now. :P
14:41:56 * hackagebot authenticate-ldap 0.0.3 - LDAP authentication for Haskell web applications.  http://hackage.haskell.org/package/authenticate-ldap-0.0.3 (MichaelLitchard)
14:44:03 <rata_> hi all
14:44:29 <shapr> hi rata_
14:46:44 <rata_> when using foldM with the list monad, how can I make foldM to return the last intermediate result it gets... ie, when the function returns [], foldM stops and returns the list it has
15:01:56 * hackagebot yesod-auth-ldap 0.0.3 - LDAP Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-ldap-0.0.3 (MichaelLitchard)
15:16:39 <prasad> Hi, I would like to execute queries on the Vertica database using HDBC using the JDBC driver provided by Vertica. I am using Mac OS 10.6 and Vertica does not provide ODBC drivers for the mac.
15:17:52 <elliott> prasad: We don't really have Java interop, if I'm interpreting your question correctly.
15:18:26 <lifestream> How can I use pattern matching for a negative number? Right now I'm using a guard:  n <= 0    = []
15:18:37 <lifestream> (Yes, I meant to match 0)
15:19:36 <elliott> lifestream: foo (-1) = ...
15:19:46 <elliott> foo (-n)... might work.
15:19:49 <elliott> I don't actually know.
15:19:54 <elliott> > let foo (-n) = "oh no" in foo (-42)
15:19:55 <lambdabot>   <no location info>: Parse error in pattern
15:19:58 <elliott> > let foo (-42) = "oh no" in foo (-42)
15:19:59 <lambdabot>   "oh no"
15:20:05 <elliott> lifestream: Okay, stick with what you have then.
15:20:40 <lifestream> Yeah, will do, thanks. Just read that it's best to use pattern matching rather than guards whenever possible.
15:21:10 <shachaf> elliott: I'm quite glad foo (-n) = ... doesn't work.
15:21:50 <joshua__> hello, were can i find good comparison between haskell and python regarding speed?
15:21:53 <shachaf> Anyway, that idiom is standard.
15:21:56 <shachaf> @src take
15:21:56 <lambdabot> take n _      | n <= 0 =  []
15:21:56 <lambdabot> take _ []              =  []
15:21:56 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
15:23:49 <prasad> Thanks elliott - I think you are interpreting my question correctly. Is there an alternative solution? My goal is to be able to execute queries in Haskell on Vertica database on a mac. Vertica provides JDBC driver but no ODBC driver for mac.
15:24:00 <fryguybob> joshua__: Here is a flawed comparison: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=python3
15:24:19 <elliott> prasad: Do they provide any other methods of connectivity?
15:24:55 <elliott> joshua__: GHC is almost certainly going to be faster than CPython for idiomatic Haskell and Python programs.
15:25:02 <conal> i'd like to get a sanity check about ghci. i'm using -fobject-code & -odir to compile loaded source modules. when start a new ghci session and load an already-compiled module, ghci doesn't have symbol information. for instance ":i" comes up empty-handed. am i getting expected behavior? is there a way to use compiled code *and* get symbol info?
15:26:34 <joshua__> elliott: why is that? i thought cpython would be much faster actually..
15:27:19 <hpaste> keep_learning pasted “creating IntMap from List” at http://hpaste.org/66197
15:27:32 <keep_learning> Hello all
15:27:46 <keep_learning> I am trying to create a IntMap from list
15:27:53 <fryguybob> joshua__: When you are statically typed you have more optimization oportunities?
15:28:14 <keep_learning> I am using this code IM.fromListWith ( ++ ) . map ( \( i , j , val ) -> ( j , [ ( i , val ) ] ) )  $ xs
15:28:23 <keep_learning> but I want to avoid ( ++ )
15:28:33 <joshua__> was that a question?
15:28:59 <keep_learning> Is it possible to create the IntMap using ( : )
15:29:06 <Enigmagic> joshua__: even PyPy is faster than CPython http://speed.pypy.org/
15:29:09 <Enigmagic> for most things
15:29:09 <fryguybob> joshua__: I'm offering a possible explination.
15:29:14 <keep_learning> rather than ++
15:29:29 <elliott> joshua__: Why do you think that?
15:29:34 <elliott> joshua__: GHC is an advanced optimising compiler.
15:29:38 <elliott> CPython is a bytecode interpreter.
15:29:39 <monochrom> conal: if you load a compiled module, you get what it exports, that's it. to get what it doesn't export, force loading the source, ":load *MyModule", but yes that means no more fast code
15:29:41 <elliott> There is not really much contest.
15:29:47 <elliott> GHCi will probably be slower than CPython, though.
15:30:17 <elliott> conal: yeah, that behaviour surprises me too
15:30:34 <elliott> conal: you could use CPP to expose everything if debugging
15:30:54 <conal> monochrom: thanks.
15:31:29 <conal> elliott: ah. hm. and pass in a -D to ghci, i guess. i wonder whether the recompilation checker would account for the -D
15:31:37 <joshua__> well i did my own benchmarking and so far haskell was slower in 9 out of 12 tests.. i will publish my results soon.. it might be that i am just not a very good haskell programmer .. i am trying not to be biased..
15:32:02 <kallisti> it could also be that you didn't compile with optimization. though I'm still somewhat surprised if that's the case.
15:32:04 <conal> in this case, i'm more interested in fast loading than fast code.
15:32:07 <fryguybob> joshua__: How are you compiling/running the haskell code?
15:32:28 <thoughtpolice> it's also worth asking if you're benchmarking pure python code, or python code that just calls out to C (several of the std python libs do this i think)
15:33:10 <shachaf> Or if you're benchmarking completely different algorithms.
15:33:26 <hpaste> kallisti pasted “AWWWWW YEAH” at http://hpaste.org/66198
15:33:33 <kallisti> elliott: feels good
15:33:44 <elliott> conal: you don't necessarily need to pass in a -D
15:33:56 <elliott> conal: have it be #ifdef PRODUCTION ( export list ) #endif
15:34:05 <elliott> then -DPRODUCTION in your cabal file, but don't pass it to ghc
15:34:07 <monochrom> kallisti: do you mean you finally get it working?
15:34:18 <kallisti> well, when I catch SomeException and print it, it prints.
15:34:21 <conal> elliott: oh, sneaky. thx. :)
15:34:22 <kallisti> so to me that indicates that it "works"
15:34:27 <elliott> joshua__: You're almost certainly either not compiling with "ghc -O2", or just writing inefficient Haskell programs due to inexperience.
15:34:28 <kallisti> but that doesn't leave out the possibility of a subtle bug.
15:34:55 <joshua__> algorithms are the same.. but yeah there are 2 places where python calls C internally.. i should remove them..
15:34:57 <elliott> Plenty of people come in and complain about Haskell's performance; it's universally one of those two reasons.
15:35:25 <elliott> (Even people complaining about GHC's performance relative to C usually leave more-or-less satisfied.)
15:35:37 <monochrom> if you are not a pro, I would not trust your "it's the same algorithm" judgement
15:36:04 <elliott> yes, unless all the haskell code is in ST :)
15:36:17 <elliott> and never uses []...
15:36:18 <kallisti> monochrom: though strangely if I defined the lambda in my code as a bound name in a where clause, it complained about a rank-2 type variable escaping
15:36:23 <kallisti> I thought it would be equivalent to the lambda.
15:36:50 <monochrom> because of different evaluation orders, literal transliteration is highly unlikely to result in "the same algorithm", for starters
15:38:02 <kallisti> wow that code is ridiculous.
15:38:09 <kallisti> (the MonadBaseControl instance)
15:38:30 <joshua__> actually the problem might be that my python code is too optimized .. while with haskell i didn't have much options.. i think i will recheck my haskell code again..
15:38:49 <monochrom> you mean "f $ \x -> blah" vs "f g where g x = blah"?
15:39:07 <kallisti> monochrom: no I mean \(WD sT) -> sT   vs. a "unWD" defined in a where clause
15:39:16 <kallisti> with the same definition
15:39:22 <kallisti> and no type signature.
15:39:42 <kallisti> actually maybe it was something else I didn't notice. I'll double check.
15:40:13 <kallisti> nope. that was it.
15:40:52 <monochrom> does it help if it's instead "where unWD sT = sT"?
15:41:04 <kallisti> no, that would be a type error, ???
15:41:13 <monochrom> oh, sorry
15:41:26 <monochrom> "where unWD (WD sT) = sT"
15:41:31 <kallisti> I'm guessing because there's a rank-2 type involved the default inferrence was incorrect or something?
15:41:58 <kallisti> yes that's the code that gives a type error as opposed to just using a lambda.
15:42:39 <elliott> kallisti: That instance looks wrong.
15:42:42 <elliott> What was wrong with the one I gave?
15:43:03 <kallisti> elliott: it "wasn't working"
15:43:05 <kallisti> ..
15:43:21 <monochrom> your guess should be right. things get weird with rank-2 values
15:43:30 <kallisti> it's basically a miracle that I got it to work, so I can't really explain what was wrong.
15:43:56 <kallisti> also I don't remember what yours looked like. let me scroll up.
15:44:29 <elliott> I am suspicious that if my instance didn't work, then your expectation of the behaviour is incorrect.
15:44:40 <elliott> Try writing your example without WD, just use StateT WDSession IO directly.
15:44:50 <elliott> What you get is the expected behaviour.
15:47:57 <kallisti> liftBaseWith f = WD $  liftBaseWith (\runInBase -> f  (\(WD m) -> runInBase m))
15:47:59 <kallisti> you mean this one?
15:50:10 <wo0kie> \o/
15:50:16 <elliott> kallisti: Yes.
15:50:24 <kallisti> that one doesn't work because there's no liftM StWD  :P
15:50:31 <kallisti> since that's the only difference
15:50:40 <elliott> Fine:
15:50:44 <kallisti> you told me to disregard that one, so I did, and then completely reinvented it. :P
15:51:03 <elliott> I did not tell you to disregard that one.
15:51:16 <elliott> liftBaseWith f = WD $ liftBaseWith (\runInBase -> f  (\(WD m) -> liftM StWD (runInBase m)))
15:51:49 <elliott> liftBaseWith f = WD $ liftBaseWith (\runInBase -> f (liftM StWD . runInBase . unWD)) -- nicer
15:51:53 <kallisti> oh I see. yeah you didn't tell me to disregard that one.
15:53:47 <elliott> liftBaseWith = unsafeCoerce (liftBaseWith :: ...type for StateT...) -- this would also work
15:54:18 <kallisti> elliott: ..ha
15:54:39 <kallisti> but that makes assumptions about newtype (can you actually make those assumptions and get away with it?)
15:55:08 <elliott> With GHC, yes.
15:55:14 <kallisti> I don't recall if it's explicitly started anywhere that newtypes must always be represented the same way as their inner type.
15:55:17 <kallisti> ah okay.
15:55:19 <kallisti> *stated
15:55:23 <elliott> I wouldn't be surprised if the Report requires newtype representation to equal the wrapped type's representation, even.
15:55:29 <elliott> Though I doubt it defines "representation" if it does.
15:56:32 * kallisti never wants to touch rank-2 types again.
15:57:22 <monochrom> the unwritten expectation is that newtype adds no overhead
15:57:36 <elliott> kallisti: Yeah well, blame basvandijk for not looking at my simplified monad-control design yet :P
15:57:39 <hpc> isn't it the written expectation?
15:57:50 <elliott> IIRC that had no rank-2 types.
15:57:51 <kallisti> since otherwise it would just be called "data"
15:57:57 <monochrom> oh no, Haskell Report is smarter than that
15:58:19 <elliott> Indeed, it didn't
15:58:21 <elliott> kallisti: Wrong.
15:58:31 <elliott> newtype's semantics are different from data regardless of representation
15:58:41 <kallisti> oh yes, re: strictness
15:58:49 <elliott> More than that.
15:58:55 <elliott> Pattern-matching differs from newtype vs. data with strict field
15:58:56 <hpc> elliott: oh, sneaky
15:59:15 <elliott> foo (DataWithStrictField x) = 42  -- foo _|_ = _|_
15:59:21 <elliott> foo (Newtype x) = 42  -- foo _|_ = 42
15:59:28 <elliott> hpc: Hm?
15:59:50 <monochrom> Haskell Report is pretty weaselling legalese when it comes to computational costs. witness how it even avoids committing to lazy evaluation
16:00:15 * elliott appreciates the report's agnosticism
16:00:21 <kallisti> well it makes sense that you wouldn't want to complicate the language specification with implementation details.
16:03:15 <hpaste> kallisti pasted “help, too many constructors” at http://hpaste.org/66199
16:04:15 <kallisti> you know I just realized as I was pasting that, that I could probably simplify error handling now that I've moved away from monadic exceptions to IO exceptions  (speaking of which, I need to remove that Error instance now and write a MonadZero instance)
16:04:55 <DanBurton> Hello, #haskell. I have come to spam you all with a shamless self-plug. In a minute.
16:05:05 <kallisti> excellent!
16:05:14 <kallisti> no one likes plugs to be filled with shame.
16:05:18 <monochrom> just put the spam on hpaste
16:05:51 <monochrom> be sure to include error messages!
16:05:56 <kallisti> yeah I can greatly simplify this error type now that I'm using IO exceptions.
16:06:10 <kallisti> maybe split it up into multiple error types.
16:06:27 <bitonic> yay, happstack 7!
16:06:33 <bitonic> whooo new website.
16:07:42 <hpaste> hpc pasted “for your consideration, SPAM” at http://hpaste.org/66200
16:07:58 <monochrom> haha
16:08:53 * DanBurton is contemplating the reddit title for this submisison
16:09:12 <DanBurton> "Implementing System F (via HOAS) with GADTs" just seems so bland
16:10:09 <hpc> is it Fω?
16:11:15 <DanBurton> http://www.reddit.com/r/haskell/comments/rk0uf/why_gadts_are_awesome_implementing_system_f_using/
16:11:35 <DanBurton> no just F
16:12:17 <elliott> I bet that's not actually system F, because of the standard HOAS pitfall.
16:12:27 <DanBurton> what is the standard HOAS pitfall?
16:12:37 <elliott> >   VTy :: (Type a -> Type b) -> Type (V a b)
16:12:38 <lambdabot>   Not in scope: type constructor or class `Type'Not in scope: type constructo...
16:12:48 <elliott> Nothing stops VTy's function pattern-matching on its argument and doing evil things with it.
16:13:24 <elliott> VTy (\t -> case t of NumTy -> TyVar 'x'; FunTy f g -> VTy (const g))
16:13:26 <elliott> And so on.
16:14:08 <DanBurton> that is true
16:14:15 <elliott> (e.g. consider your eqTy, against an evil VTy that does something completely different when it gets a TyVar.)
16:14:36 <elliott> I think there are certain languages where you can actually express the type of "a function that doesn't do anything funny with its argument", but I don't know anything about them
16:14:42 <kallisti> so how can we get line numbers into our errors..
16:15:29 <elliott> kallisti: By using a partial pattern match to the left of <-?
16:15:34 <elliott> Or missing a clause of a function?
16:16:48 <DanBurton> elliott: indeed, I made a small note about the unenforced assumption that you are not constructing types in weird ways. But I wasn't really sure what those ways were, thanks for elaborating :)
16:17:15 <elliott> It's a shame, because HOAS is quite pretty.
16:17:21 <kallisti> not quite what I had in mind.
16:17:33 <elliott> kallisti: Then you'll need a slightly less vague question...
16:17:40 <DanBurton> perhaps I should clarify that it is a toy implementation, not to be considered an "enterprise" System F
16:18:14 <DanBurton> though you could imagine simply using a pre-processor to check that System F expressions do not use any unapproved Haskell features
16:18:21 <elliott> DanBurton: You have a comment runAppPrim's implementation above its implementation.
16:18:23 <elliott> That's a bit confusing.
16:19:05 <sully> argh
16:19:10 <kallisti> elliott: I mean better IO exceptions in general. With more context on how the exception occured.
16:19:15 <sully> the hs-twitter bindings are underdocumented
16:19:18 <sully> (surprise, surprise)
16:20:27 <DanBurton> elliott: hm it didn't seem that bad to me before, but now that I look at it again I see your point. I'll move that around a little
16:21:43 <elliott> kallisti: You don't. Though you can try -xc. Or if you have GHC 7.4 (or was it 7.6).
16:22:14 <kallisti> the main obstacle with that is that by default cabal doesn't compile packages with profiling enabled.
16:22:35 <kallisti> and, cool, I didn't  realize better exception reporting had been added.
16:23:45 <elliott> kallisti: That's why you change the default.
16:25:09 <kallisti> I'm not sure that's the most efficient solution.
16:25:56 <kallisti> to expect that everyone using cabal should know, before even touching cabal, that it's going to be tedious to reinstall everything to allow profiling, shared libraries, etc.
16:26:15 <elliott> I didn't say anything about everyone, I said "you".
16:26:48 <ivanm> kallisti: not everyone wants profiling
16:26:52 <dcoutts> kallisti: of course, the right solution is that we register profiling libs separately and can install profiling ones later to match the ones you've got already
16:26:57 <kallisti> yes
16:27:00 <ivanm> e.g. people just using cabal-install to get pandoc or something
16:27:01 <kallisti> ivanm: and yes
16:27:29 <ivanm> dcoutts: is there a way of getting cabal-install to replicate the old behaviour of "cabal upgrade --dry-run"? i.e. tell me which packages *are* upgradeable?
16:27:40 <dcoutts> kallisti: the latter part of that is a bit tricky however, keeping enough info to reproduce a package but with profiling
16:28:11 <dcoutts> ivanm: cabal install --upgrade-dependencies --dry-run
16:28:24 <ivanm> dcoutts: it asks for a package
16:28:29 <dcoutts> ivanm: use world
16:28:37 <ivanm> ahhh
16:28:38 <dcoutts> ivanm: however it's likely not to work
16:28:53 <dcoutts> because you usually cannot get a consistent set of deps for everything in world
16:29:01 <ivanm> right
16:29:11 <ivanm> I just wanted to be able to tell which distro packages could be updated
16:29:25 <dcoutts> ivanm: use hackport!
16:30:12 <ivanm> dcoutts: it's not gentoo!
16:30:26 * dcoutts is shocked
16:31:21 <hpc> a little bit of perl should give you "get list of all packages, cabal install $each --dry-run, see what happened, list results"
16:33:37 <kallisti> where is the MonadPlus instance for IO defined?
16:33:45 <ivanm> @instances MonadPlus
16:33:45 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:33:52 <ivanm> kallisti: probably where MonadPlus is defined
16:34:02 <Enigmagic> kallisti: i think it was removed in 7.2 or 7.4
16:34:04 <ivanm> dcoutts: I'm using exherbo now
16:34:15 <ivanm> too many things in gentoo were pissing me off
16:34:18 <elliott> kallisti: it's bad, don't use it
16:35:03 <kallisti> elliott: is it bad because it catches SomeException?
16:35:16 <kallisti> or are there other reasons?
16:35:41 <elliott> It breaks the laws.
16:35:48 <elliott> Specifically
16:35:48 <elliott>  v >> mzero   =  mzero
16:35:49 <elliott> that one.
16:35:51 <kallisti> ah right
16:36:12 <kallisti> hm
16:38:54 <sully> argh
16:39:02 <sully> the twitter bindings are filled with fail
16:41:19 <kallisti> I'm... very tempted to break that rule anyway.
16:42:28 <kallisti> mostly I just want mzero so that I can use guard.
16:42:39 <kallisti> I guess I could just write my own functions instead.
16:42:51 <kallisti> but they would have less awesome names.
16:43:35 <lispy> ?fact hi
16:43:35 <lambdabot> I know nothing about hi
16:43:38 <rasfar> ah, kallisti -- thanks for your advice about not constraining types on data/newtype declarations.  after getting rid of those, the number of constraints on my function definitions went way down and made a lot more sense. :)
16:43:41 <lispy> ?fact-set hi is hello
16:43:42 <lambdabot> Fact recorded.
16:43:44 <lispy> ?fact hi
16:43:45 <lambdabot> hi: is hello
16:43:55 <Enigmagic> kallisti: probably better to throw an exception directly, the mzero generic exception is basically useless
16:44:11 <kallisti> I don't mean that I want to use the IO instance.
16:44:28 <kallisti> I have a case where it would be very convenient to use guard to a throw an exceptional condition as a "false" value.
16:44:38 <kallisti> an alternative would be Maybe, I guess.
16:45:31 <kallisti> hm
16:46:37 <elliott> lispy: whoa, what's that?
16:46:38 <kallisti> perhaps I should use MaybeT
16:46:57 <elliott> kallisti: MaybeT is pretty slow compared to using IO exceptions. For what it's worth.
16:47:20 <elliott> I defined my own combinators for short-circuiting as an alternative. But I was trying to eke out every ms I could.
16:47:45 <kallisti> WD ( Maybe a)  just doesn't feel right for this.
16:48:01 <kallisti> before it would just use mzero to throw a monadic exception.
16:48:49 <kallisti> also I don't really see how MonadT can adhere to MonadPlus laws when m = IO
16:48:59 <elliott> "MonadT"?
16:49:02 <kallisti> ...er, MaybeT
16:49:15 <kallisti> Monad m => MonadPlus (MaybeT m)
16:49:21 <elliott> Anyway, using mzero like that would be dangerous, since Error doesn't provide enough to reliably distinguish mzero from other errors I don't think.
16:49:39 <kallisti> it does. that's what Error is for.
16:49:47 <kallisti> I just had a special WDZero constructor.
16:49:58 <kallisti> and then caught that.
16:50:10 <elliott> kallisti: MaybeT's MonadPlus instance is bad too.
16:50:11 <elliott> So don't use it.
16:50:27 <kallisti> guess I'll just do some custom functions.
16:50:32 <kallisti> with less awesome naming that guard.
16:50:36 <kallisti> *than
16:50:51 <kallisti> oh wait..
16:50:54 <kallisti> @hoogle assert
16:50:55 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
16:50:55 <lambdabot> Control.Exception assert :: Bool -> a -> a
16:50:55 <lambdabot> Control.OldException assert :: Bool -> a -> a
16:51:06 <kallisti> I could just use this
16:53:25 <kallisti> maybe provide a special case for Bool -> WD ()
16:54:17 <kallisti> oh wait assertions can be disabled with a compiler flag, so that's not good.
17:00:27 <hpaste> lifestream pasted “where xs = toDigitsRev ... ?” at http://hpaste.org/66203
17:00:28 <lifestream> Sorry I always ask silly questions, but that's the most I've been able to accomplish since I last asked a question :P I want to pass a list from a function to another, and I always get 'not in scope'. I'm looking for the last line. Can you help?
17:01:09 <elliott> lifestream: Please hpaste the error GHC gives. But "where xs = ..." is a bad idea.
17:01:15 <elliott> You already bound xs in doubleEveryOther's pattern.
17:01:24 <lifestream> Ah...
17:01:30 <hpc> lifestream: what's n?
17:02:30 <lifestream> hpc: no idea, I guess I meant for it to be input
17:02:36 <lifestream> But I see what you mean now.
17:03:13 <lifestream> Oh, perhaps <-
17:04:39 <vlad2048> hi, i'm new to haskell
17:05:02 <vlad2048> shame the interactive lesson is so short, it's pretty nice
17:05:18 <ivanm> you mean tryhaskell ?
17:05:46 <lifestream> The TryHaskell.org ? Yeah, it was good fun! Got stuck on the last step and didn't want to move on until I understood it... then once I did I was shocked to see it was the last part ;D
17:05:59 <ivanm> blame chrisdone! :p
17:06:15 <vlad2048> yes tryhaskell !
17:06:27 <hpc> vlad2048: time to install GHC :D
17:06:32 <vlad2048> there's just the bit with the @ operator I didn't get
17:06:35 <kallisti> :t any
17:06:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:07:22 <vlad2048> i'm stuck with some complex f# at work, having a hard time modifying it
17:07:22 <elliott> vlad2048: don't be sad, you get to read learn you a haskell next :P
17:07:33 <vlad2048> gigantic function signatures and 2 levels of nested generics :(
17:07:46 <elliott> oh, we have those too!
17:07:50 <elliott> well, not the generics
17:07:56 <elliott> but the gigantic signatures and nesting
17:08:09 <vlad2048> well, yeah by generic I mean generic types like in tryhaskell
17:08:20 <hpc> oh, we don't call those generics
17:08:27 <lifestream> Hey vlad2048, check out the lessons I'm going through now, it has homework too! http://www.cis.upenn.edu/~cis194/lectures.html
17:08:39 <vlad2048> it's very hard to debug for an experienced imperative programmer
17:08:52 <elliott> @where lyah
17:08:52 <lambdabot> http://www.learnyouahaskell.com/
17:09:01 <elliott> <standard over-the-top LYAH recommendation>
17:09:31 <vlad2048> lifestream: it looks awesome thanks
17:09:43 <lifestream> <3
17:10:33 <vlad2048> how different is haskell and f# ?
17:10:47 <vlad2048> they 'seem' pretty similar
17:10:48 <bitonic> vlad2048: pretty different, but they have some points in common
17:11:08 <bitonic> vlad2048: in the panorama of PLs, F# is one of the closest to Haskell. They're still different anyways :P
17:11:15 <elliott> isn't F# strict and impure?
17:11:25 <elliott> it's much much more like OCaml.NET than Haskell afaics
17:11:28 <vlad2048> mmm, i came here because I read haskell is purely functional
17:11:38 <bitonic> yes it's OCaml without Functors :(
17:11:40 <bitonic> and do notation
17:11:45 <vlad2048> i didn't want to have the imperative crutch
17:11:50 <bitonic> why did I capitalize functor, I don't know
17:12:18 <kaitocracy> hi I'm writing a WAI application and I've got a handler :: Request -> ResourceT IO Html
17:12:26 <Enigmagic> bitonic: it sorta has do notation: http://msdn.microsoft.com/en-us/library/dd233182.aspx
17:12:30 <vlad2048> alright thx and good night !
17:12:32 <kaitocracy> the Request it takes I need to pass to a function like 5 levels down
17:12:47 <bitonic> Enigmagic: functor in OCaml != functor in Haskell
17:12:47 <kaitocracy> and it this something that I have to do quite often
17:12:57 <kaitocracy> is it advisable to use a ReaderT or implicit parameters in this case?
17:13:00 <bitonic> != functor in C++ :P
17:13:07 <Enigmagic> bitonic: i'm not talking about functors
17:13:14 <lifestream> would post the error message, elliott, but I guess it's meaningless since I'm doing it wrong anyway. How would you pickup the list from toDigits, then? (Sorry, I have looked and looked)
17:13:28 <c_wraith> C++ functors are really convoluted currying :)
17:13:29 <bitonic> Enigmagic: oh. then yes, it has do notation
17:13:33 <hpc> (hint: haskell functors are category theory functors, which are REAL functors)
17:13:52 <elliott> lifestream: oh, i was just commenting on your variable naming.
17:13:52 <bitonic> hpc: ML functors are kinda category theoretic
17:13:56 <elliott> you hid one "xs" with another
17:13:57 <hpc> (well, a special case of category theory functors)
17:14:17 <lifestream> elliott: Ah, I see, I tried other variables and ghci tells me 'not in scope', so I'm at a loss.
17:14:18 <alpounet> bitonic, where modules are the categories?
17:14:21 <bitonic> yes
17:14:33 <elliott> lifestream: What, exactly, does it say is not in scope?
17:14:42 <hpc> except modules don't form categories :P
17:14:43 <bitonic> disclaimer: I know nothing about CT! but I guess that's why they're called that way
17:14:50 <bitonic> or maybe not
17:14:51 <hpc> other than that, it's exactly the same!
17:15:13 <bitonic> hpc: well, modules are made of functions and types so stretching it a bit...
17:15:15 <bitonic> but yeah...
17:15:22 <alpounet> or maybe it's just that it's a "function operating on modules", and that names ending in "or" just sound neat, so... FUNCTOR!
17:15:40 <hpc> haskell functors are genuine hand-crafted functors in hask
17:16:05 <lifestream> elliott: Well, I need that xs@(x:y:ys), right? But I need to pickup the [Int] from the toDigits. When I do  where xs = toDigits n, it says n is not in scope. So I'm not sure how to go about it.
17:16:15 <lifestream> Hold on...
17:16:28 <elliott> lifestream: That's because you used "n" without defining it.
17:16:40 <elliott> You might as well say "where xs = toDigitsRev sdfjkladjsdlasdasd".
17:16:51 <hpc> lifestream: what's your function supposed to do?
17:16:57 <hpc> more specifically, why does it need the digits
17:17:08 <lifestream> Double every other item in list.
17:17:08 <mauke> is there some basic introduction to writing a test suite with cabal?
17:17:23 <shachaf> > n == sdfjkladjsdlasdasd
17:17:24 <lambdabot>   True
17:17:27 <shachaf> elliott has a point.
17:17:28 <lifestream> hpc: http://hpaste.org/66203
17:17:48 <elliott> mauke: perhaps the "how to write a haskell program" wiki article
17:17:52 <elliott> that covers it
17:17:58 <elliott> might be out of date, though
17:18:13 <hpc> lifestream: why do you need the result of toDigits?
17:18:19 <alpounet> mauke, i only know of the section in the user manual
17:18:41 <mauke> alpounet: that section explains nothing and doesn't even contain links
17:18:41 <hpc> how does it contribute to the ultimate goal of doubling things?
17:19:09 <mauke> elliott: it doesn't cover it. it doesn't even mention "cabal test"
17:19:10 <elliott> mauke: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Add_some_automated_testing:_QuickCheck onwards
17:19:19 <elliott> oh
17:19:21 <elliott> it doesn't... yeah
17:19:30 <elliott> mauke: well, i know that exitcode-stdio is what you're meant to use
17:19:36 <elliott> and the detailed type was released prematurely
17:19:39 <elliott> if that helps, at all :P
17:19:40 <mauke> elliott: that's not what the manual says
17:19:45 <elliott> mauke: i know that's not what the manual says
17:19:47 <elliott> the manual is wrong
17:19:50 <bitonic> what was the performance overhead of 'catch'?
17:19:51 <elliott> i forget who told me this
17:19:55 <mauke> elliott: what's the bug number?
17:19:58 <elliott> i don't know
17:20:03 <elliott> i don't know if there even is a bug
17:20:04 <mauke> great
17:20:07 <elliott> but basically everyone uses exitcode-stdio
17:20:15 <elliott> and detailed isn't "ready" for some reason
17:20:16 <lifestream> hpc: Because the exercise is to double every other item of the list we processed earlier in toDigits. toDigits takes a number and puts its digits into a list. I can't dobule every other item of the number, it has to be the digits of the number. (That's what the exercise says)
17:20:21 <elliott> at least this is the understanding i was given
17:20:26 <mauke> elliott: by whom?
17:20:37 <parcs`> bitonic: large enough that there's a 'catches'
17:20:38 <hpc> lifestream: and that list is passed as a parameter, yes?
17:21:20 <lifestream> hpc: the list would be passed to doubleEveryOther, yes, that's what I hope to do
17:21:45 <elliott> mauke: i forget. possibly dcoutts
17:21:53 <alpounet> mauke, I know tibbe uses this in unordered-containers, so maybe you can somehow get your test suite up by looking at how tibbe wrote his'. https://github.com/tibbe/unordered-containers/blob/master/unordered-containers.cabal
17:22:36 <mauke> that uses exitcode-stdio
17:22:49 <tibbe> elliott: mauke: exitcode-stdio is the only publicly supported interface. It works quite well together with test-framework
17:22:50 <alpounet> yeah
17:22:59 <bitonic> parcs`: I'd like something more specific :P
17:23:03 <hpc> lifestream: okay, suppose you were writing code in hypothetical-java-knockoff:
17:23:09 <mauke> tibbe: supported how?
17:23:12 <hpc> int[] doubleEveryOther(int[] xs) {
17:23:23 <tibbe> mauke: as in the only documented and not guaranteed to change one
17:23:30 <tibbe> mauke: the detailed interface is still in flux
17:23:34 <hpc>   xs = toDigitsRev(n);
17:23:38 <mauke> tibbe: that's not what the documentation says
17:23:46 <elliott> we established that
17:23:49 <hpc> ^ why would you do that when you already have xs?
17:23:54 <elliott> the documentation was updated prematurely
17:24:01 <tibbe> mauke: what elliott said
17:24:18 <mauke> tibbe: then "the only documented" one is wrong
17:24:38 <tibbe> mauke: is anything I said unclear? :)
17:24:52 <mauke> no, only contradictory
17:24:54 <hpc> lifestream: remember, you're calling doubleEveryOther (toDigitsRev n), not doubleEveryOther n
17:25:07 <tibbe> mauke: I believe the docs have been fixed in the darcs repo
17:25:22 <mauke> that's ... nice?
17:25:29 <tibbe> mauke: I don't know if the updated docs where ever uploaded. Cabal is on a 10 year release cycle or so
17:25:32 <elliott> i'm not sure what mauke's question is at this point
17:25:58 <mauke> I don't think I have a question anymore
17:26:00 * tibbe disappears
17:26:12 <mauke> basically, there is no reliable information on tests in cabal
17:26:17 <hpc> lifestream: basically what im saying is, that entire where-clause shouldn't be there
17:27:15 <tibbe> mauke: they could definitely be better, submit a patch
17:27:21 * mauke tries to integrate perl's test system
17:29:02 <lifestream> hpc: thought about that, but then I couldn't do this, could I? doubleEveryOther toDigitsRev(x:y:ys)= x : (y * 2) : (doubleEveryOther ys)   ...I'd have to access the list some other way?
17:31:01 <hpc> no
17:31:14 <hpc> doubleEveryOther has no idea where its parameter comes from
17:31:25 <hpc> you know where it comes from, but the function itself doesn't care
17:37:03 * hackagebot bmp 1.2.1.1 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.1.1 (BenLippmeier)
17:38:17 <lifestream> I guess I must use a list comprehension instead
17:38:38 <kallisti> type families sure do compile slow.
17:39:00 <ivanm> kallisti: as in they take longer to compile than MPTCs+FDs?
17:39:44 <kallisti> no. I haven't really compared the tw.
17:39:46 <kallisti> +o
17:40:26 <ivanm> then what makes you think they're slow?
17:40:32 <ivanm> *to compile
17:40:48 <kallisti> compiling them.
17:40:55 <kallisti> it could be unrelated.
17:41:08 <kallisti> it just seems that my compilation time increased when I started using a TypeFamilies
17:41:26 <kallisti> specifically the compilation time of the module in which TypeFamilies are being used.
17:43:43 <ivanm> kallisti: maybe because it now has so much stuff in them?
17:43:54 <ivanm> @slap stupid students using SO to get their assignments done
17:43:54 * lambdabot locks up stupid students using SO to get their assignments done in a Monad
17:46:09 <lifestream> So hpc, I must be misunderstanding. are you saying that the list would be send /from/ doubleEveryOther /to/ toDigitsRev, instead of the other way around? Because no matter how much I work on this, I don't understand. I have been working on this all day since this morning and all I have to show is those few lines :O
17:46:43 <hpc> lifestream: im saying, write doubleEveryOther as if toDigitsRev never existed at all
17:46:56 <hpc> then later, you can pass the result of toDigitsRev to doubleEveryOther
17:47:03 <hpc> and you can also pass many other lists too!
17:47:12 <lifestream> I see, first check how it works and why.
17:47:30 <lifestream> I still do not understand how to pass the list, but I guess you are right.
17:48:09 <kallisti> ivanm: possibly.
17:48:19 <kallisti> I wasn't being very scientific in my claim, I admit.
17:49:54 <Enigmagic> kallisti: my unscientific view is that RankN types slow it down the most
17:57:14 <mauke> @pl \x -> (x, succ x)
17:57:14 <lambdabot> ap (,) succ
17:57:56 <mauke> @pl \x -> (succ x, succ x)
17:57:56 <lambdabot> liftM2 (,) succ succ
17:58:09 <lambda_zero_cool> Anybody around who can help a newbie with an HOpenGL question?
17:59:13 <hpaste> any annotated “Int -> [Int]” with “Int -> [Int] (annotation)” at http://hpaste.org/66193#a66205
18:02:04 * hackagebot RNAFold 1.99.1.0 - RNA secondary structure prediction  http://hackage.haskell.org/package/RNAFold-1.99.1.0 (ChristianHoener)
18:02:41 <hpc> whoa, hackage gets all the cool stuff
18:02:55 <rasfar> lambda_zero_cool: i've not used it but i'd like to try, ask away!
18:04:42 <shergill> i'm curious, but which haskell mode indentations do users here prefer? haskell-indentation, haskell-indent or haskell-simple-indent?
18:05:10 <elliott> indent iirc
18:05:32 <monochrom> I prefer the most advanced one. 'turn-on-haskell-indentation
18:06:04 <shergill> monochrom: advanced in what sense? evolution of the modes or something more?
18:06:05 <lambda_zero_cool> rasfar: so i went through the OpenGL tutorial at http://www.haskell.org/haskellwiki/OpenGLTutorial2 , and i decided to expand on illustrating opaque cubes by tracing the edges of the cubes with black lines.  when i do this, the entire black frame of the cube is visible, through all the faces, and no opacity level blocks out anything from the more distant face
18:06:52 <nh2> control-monad-failure is obsolete. What else provides Failure instances for ErrorTs?
18:07:10 <monochrom> it understands more of haskell's syntax
18:07:36 <lambda_zero_cool> shergill: what editor is this in?
18:07:44 <elliott> with indentation i spend half my day hitting tab to cycle through implausible indentations
18:07:45 <elliott> ymmv
18:07:53 <shergill> lambda_zero_cool: emacs
18:08:05 <monochrom> my http://hpaste.org/47103/emacs_haskellmode_demo has an example. minimal manual work, really
18:08:45 <mauke> @index liftIO
18:08:45 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:09:09 <rasfar> lambda_zero_cool: well, i'll need to catch up a bit, looking at that page.  However I can honestly say I've had more trouble with blending in OpenGL than any other single thing, it can be very tricky and unintuitive.
18:09:40 <rasfar> if you could hpaste what you have so far, that would be best
18:10:23 <monochrom> in my example, for about 11 lines of code, there are only 3 backspaces, and no tab
18:12:46 <shergill> i had simple-indent earlier. i guess i'm going to play with indentation and see how it feels, but it does seem to handle things well at least as per the example you posted monochrom
18:12:46 <rasfar> to make sure the problem isn't geometric precision, you might try drawing the black outline slightly smaller, so as to be sure it is properly contained in the white cube.
18:13:21 <rasfar> (in any case, this is probably an OpenGL question more than a Haskell question)
18:15:14 <hpaste> lambda_zero_cool pasted “Modified OpenGL Tutorial” at http://hpaste.org/66208
18:16:23 <rasfar> super, so it will be easy to make cubeFrame slightly smaller (and centred) the way your code is organised; would you try that first?
18:16:54 <lambda_zero_cool> rasfar: sure, how small? 0.39 or something?
18:18:20 <lambda_zero_cool> rasfar: with cubeFrame called with a side of 0.39, all lines are visible, and there's a little spillage of the colors outside the lines
18:21:13 <rasfar> okay.  i'm just trying to compile.  i put everything in one module (Main) for convenience, but I'm not finding reshape, pointCircle or keyboardMouse functions yet... maybe i'm missing a package?
18:21:55 <lambda_zero_cool> oh, i hpasted parts of the files as relevant. i can give you the entire thing if you'd prefer
18:22:03 <lambda_zero_cool> one moment...
18:22:56 <rasfar> yeah, i'd like to get it compiling if possible
18:26:03 <hpaste> lambda_zero_cool pasted “Complete Modified OpenGL Tutorial” at http://hpaste.org/66209
18:30:50 <rasfar> l_z_c: does your last paste include everything from the first paste? (so i can delete that stuff?)
18:31:45 <lambda_zero_cool> rasfar: yeah, it should have everything
18:31:55 <rasfar> it compiles!
18:32:09 <rasfar> and runs, wow, colour, movement, lovin' it
18:32:26 <rasfar> i see no frame lines at all though
18:32:51 <rasfar> oh wait, that's because i enabled blending :p
18:33:15 <lambda_zero_cool> rasfar: so in general, what i'm finding is on mine whatever primitive is drawn last is drawn over all others, even if they are at more distant z-coordinates
18:33:28 <rasfar> ah, no it isn't b/c i enabled blending, since i commented out that stuff...
18:34:04 <lambda_zero_cool> rasfar: yeah. also, if you notice - the frame lines should be too big in the one i sent you.  if you resize them, then draw them last, they all get drawn on top of the cubes
18:34:32 <rasfar> okay.  i wonder if you need to enable z-buffering?
18:35:03 <danharaj> Is there a better way to deal with naming indices in lambda-like things that's better than a global pool of fresh variables or de bruijn indices?
18:35:27 <danharaj> The former is icky and the latter is always bug ridden when I implement it. :p
18:35:44 <shachaf> danharaj: De Bruijn indices are bug ridden?
18:35:55 <shachaf> It seems conceptually simpler to me than actual names.
18:36:09 <danharaj> shachaf: I never get it right the first time.
18:36:14 <lambda_zero_cool> rasfar: hm, this is on a different FAQ - let me see what i can get out of this
18:37:07 <rasfar> okay, i'm seeing what you describe (and my previous suggestion was stupid anyhow, i see now)
18:39:01 <rasfar>     clear [ColorBuffer,DepthBuffer]
18:39:01 <rasfar>     loadIdentity
18:39:01 <rasfar>     depthFunc $= Just Less
18:39:07 <rasfar> that'll do it lambda_zero_cool!
18:39:29 <lambda_zero_cool> rasfar: ahah, you beat me to it!
18:39:34 <rasfar> heehee
18:39:37 <lambda_zero_cool> rasfar: wasn't clearing the depth buffer
18:39:44 <lambda_zero_cool> is it ++name or name++ for karma boost
18:40:01 <rasfar> wow my first karma boost!  @karma+ rasfar
18:40:27 <heatsink> Can you read de Bruijn indices, though?
18:40:35 <heatsink> To me, it's about as easy as reading binary-encoded ASCII
18:40:49 * kallisti can read de Bruijn indices.
18:41:02 <lambda_zero_cool> @karma+ rasfar
18:41:02 <heatsink> Gasp! Are you Chuck Norris?
18:41:02 <lambdabot> rasfar's karma raised to 1.
18:41:08 <kallisti> heatsink: nah
18:41:10 <lambda_zero_cool> awwww yeah
18:41:12 <lambda_zero_cool> thanks for the help man
18:41:24 <rasfar> cheers, and thank you for introducing me to HOpenGL!
18:42:17 <kallisti> heatsink: step 1) look at the number  step 2) count that many nested lambdas upward. that's the lambda that binds that variable
18:42:33 <mauke> lambda_zero_cool: prefer name++ over @karma+
18:42:50 <mauke> lambdabot accepts both but other bots don't understand @karma
18:42:55 <lambda_zero_cool> mauke: kk, will do, thanks
18:43:04 <lambda_zero_cool> rasfar: wait, silly question - did you just drop those three lines into display.hs?
18:43:06 <mauke> (just my 2 cents)
18:43:14 <shachaf> "other bots"
18:43:20 <lambda_zero_cool> rasfar: also, for fun - check out the snowflake fractal
18:43:40 <rasfar> lambda_zero_cool: (i will check it out) -- I put those three lines where you formerly had these two:
18:43:52 <mauke> shachaf: such as perlbot, purl, preflex, jsBot, ...
18:44:06 <rasfar>     clear [ColorBuffer]
18:44:06 <rasfar>     loadIdentity
18:44:26 <rasfar> don't forget the depthFunc $= Just Less
18:44:51 <rasfar> and if you don't mind:  rasfar++ ....
18:46:03 <rasfar> (or probably @rasfar++ ?? -- i don't really care about karma, but hey it's my first since i joined in 2005!)
18:46:12 <lambda_zero_cool> rasfar: hmm, this might not be working on my machine - i wonder if i have enough depth bits set
18:46:57 <rasfar> wierd.  well, let me see if "bumblebee" is still working, i'm actually running that in software rendering at the moment...
18:47:37 <mauke> preflex: karma rasfar
18:47:37 <preflex>  rasfar: -1
18:47:47 <mauke> huhu
18:48:44 <rasfar> hey! how come?
18:50:04 <mauke> you ++'d yourself
18:50:20 <rasfar> my nVidia card is not working for whatever reason, sorry.
18:50:25 <rasfar> mauke: i didn't!
18:50:36 <mauke> did too
18:50:40 <rasfar> when?
18:50:50 <mauke> <rasfar> and if you don't mind:  rasfar++ ....
18:51:05 <monochrom> preflex: karma rasfar
18:51:05 <preflex>  rasfar has no karma
18:51:11 <rasfar> doesn't it have to be at the start of a line? 'stie!
18:51:13 <monochrom> now it is 0
18:51:25 <shachaf> rasfar: Clever.
18:51:28 <rasfar> okay 0 seems right for a chaotic neutral type
18:51:55 <mauke> TAP++ prove++
18:52:05 * hackagebot data-default 0.4.0 - A class for types with a default value  http://hackage.haskell.org/package/data-default-0.4.0 (LukasMai)
18:52:22 <lambda_zero_cool> rasfar: found it
18:52:35 <rasfar> hahaha!  that was not strategic getting mauke to quote me shachaf.  thanks for acknowledging my existence finally btw. ;p
18:52:51 <mauke> I did it on purpose :-)
18:53:02 <rasfar> i'm about to get evicted from the cafe, gotta run (thanks mauke) -- laters
18:53:07 <mauke> bye
18:53:15 <lambda_zero_cool> rasfar: I need include "WithDepthBuffer" in my initaldisplaymode list
18:53:20 <hpaste> clsmith pasted “Polymorphic recursion” at http://hpaste.org/66210
18:53:21 <shachaf> gotta run (thanks mauke)-- laters
18:53:26 <shachaf> oops
18:53:33 <elliott> bye shachaf
18:53:38 <mauke> preflex: karma thanks mauke
18:53:38 <preflex>  thanks mauke: -1
18:53:41 <shachaf> preflex: karma thanks mauke
18:53:41 <preflex>  thanks mauke: -1
18:54:02 <clsmith> hey all. the paste i just pasted causes crazy compiler errors. if i move the g to the right of the type and add 'g ->' it works, but that's ugly. is there a better way to fix that?
18:54:21 <shachaf> (thanks mauke)++
18:54:32 <kallisti> ++++
18:55:01 <elliott> @karma ++
18:55:01 <lambdabot> ++ has a karma of 3
18:55:23 <mauke> preflex: karmabot
18:55:30 <elliott> clsmith: problem is that the "g" there isn't the g from randomR's type sig
18:55:35 <elliott> it's a new universally-quantified g
18:55:48 <preflex>  <: -41341; -: -36054; <-: -6534; <!: -1159; <--: -963; ~: -820; --: -619; debian: -613; -rw-r--r: -562; ^: -483
18:55:51 <elliott> you might be able to get it working with ScopedTypeVariables
18:56:01 <mauke> preflex: karmatop
18:56:16 <clsmith> and i can't put a type for randomR because it's a type class function :/
18:56:19 <preflex>  c: 185627; g: 9429; ##c: 7449; c/c: 6136; bacek: 4581; whiteknight: 4323; notepad: 3766; vc: 3525; #c: 3525; moritz: 3425
18:56:23 <elliott> clsmith: you can put a type for g though
18:56:28 <elliott> (maybe)
18:56:36 <elliott> clsmith: you could just define randomR separately
18:56:40 <elliott> and then randomR = myRandomR
18:56:49 <elliott> c/c--
18:56:55 <clsmith> hmm, true.
18:57:12 <mauke> c's karma grows too slowly
18:57:14 <clsmith> atm i'm using let (x,g') = (randomR r :: RandomGen g => g -> (Double, g)) g
18:57:23 <mauke> we'll never reach 32 bits that way
18:58:21 <elliott> c-- is the best compilation backend imo
18:58:26 <elliott> c-- is much better than c or assembly
18:58:29 <elliott> i love c--
18:58:36 <elliott> doin' my bit
18:58:53 <mauke> :-(
18:59:06 <kallisti> clsmith: what's the problem with removing all type annotations?
18:59:18 <elliott> preflex: karma c++
18:59:18 <preflex>  c++: -64
18:59:22 <elliott> c++--
18:59:23 <elliott> preflex: karma c++
18:59:23 <preflex>  c++: -65
18:59:29 <elliott> hmm
18:59:30 <elliott> preflex: karma c
18:59:30 <preflex>  c: 185626
18:59:32 <elliott> c++--
18:59:33 <elliott> preflex: karma c
18:59:33 <preflex>  c: 185626
18:59:37 <clsmith> kallisti: inferring the type of a polymorphic recursive function is undecidable
18:59:41 <elliott> mauke: lame, that should increment c _and_ decrement c++
18:59:50 <mauke> I don't think so, tim
18:59:53 <mauke> preflex: karma i
18:59:53 <preflex>  i: 2272
18:59:55 <elliott> then we could just say c++-- all day and do the world a service
19:00:03 <kallisti> clsmith: could asTypeOf be used here?
19:00:16 <elliott> yes
19:00:18 <elliott> (i believe)
19:00:18 <clsmith> no idea, never used it :p
19:00:29 <elliott> clsmith: asTypeOf is just const but a -> a -> a
19:00:37 <elliott> so if you do g' `asTypeOf` g, they'll unify
19:00:43 <elliott> probably need to do the same for x
19:03:43 <kallisti> (x, g') = randomR `asTypeOf` (r, g)   -- perhaps?
19:03:56 <kallisti> *randomR r g
19:04:04 <clsmith> let (x,g') = randomR (lo,hi) g `asTypeOf` (lo,g) -- seems to work
19:04:36 <rhc> i'm having trouble googling, what is the !! operator in haskell?
19:04:37 <kallisti> ah nevermind
19:04:44 <kallisti> rhc: list subscripting
19:04:48 <kallisti> > [1,2,3,4] !! 2
19:04:49 <lambdabot>   3
19:04:54 <mauke> rhc: http://www.haskell.org/hoogle/?q=%21%21
19:05:05 <rhc> mauke: ah, thank you, and kallisti
19:05:08 <clsmith> cool, thanks guys :)
19:05:30 <kallisti> rhc: note that it's slow because it has to traverse the list up to that index. so if you need to make heavy use of random access, you'll want a different data structure.
19:06:06 <rhc> kallisti: yeah, just reading http://learnyouahaskell.com/higher-order-functions and stopped before reading the context below
19:36:43 <Clint> how do i track down what's throwing Prelude.Enum.Bool.toEnum: bad argument?
19:37:03 <elliott> ghci
19:38:41 <Clint> thanks
19:44:22 <ByronJohnson> Clint: See http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
19:48:01 <elliott> I didn't mean the GHCi debugger.
19:48:05 <elliott> (But if you like it then by all means.)
19:48:29 <Clint> off by one error
19:51:03 <sohum> @hoogle Int -> [a] -> [[a]]
19:51:03 <lambdabot> Prelude drop :: Int -> [a] -> [a]
19:51:03 <lambdabot> Data.List drop :: Int -> [a] -> [a]
19:51:03 <lambdabot> Prelude take :: Int -> [a] -> [a]
19:51:07 <sohum> hmm.
19:51:13 <sohum> @hoogle chunk
19:51:13 <lambdabot> Data.Text.Lazy.Internal chunk :: Text -> Text -> Text
19:51:14 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
19:51:14 <lambdabot> Data.Text.Lazy.Internal chunkOverhead :: Int
19:51:25 <sohum> orrr not.
19:52:13 <elliott> sohum: split package
19:52:18 <elliott> http://hackage.haskell.org/package/split
19:52:25 <hask3ll> hey. is there a simple way to turn a function :: Monad m => a -> m b to a function :: Monad m => a -> m (Maybe b) ?
19:52:38 <sohum> elliott: cheers
19:52:47 <dibblego> @type fmap fmap fmap pure
19:52:48 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Applicative f2) => f (f1 a) -> f (f1 (f2 a))
19:53:37 <dibblego> hask3ll: ^^ that's not "simple" -- you probably should  consider using Kleisli
19:54:00 <mauke> :t const (const (return Nothing))
19:54:01 <lambdabot> forall a (m :: * -> *) b b1. (Monad m) => b1 -> b -> m (Maybe a)
19:54:10 <elliott> dibblego: one too many fmaps.
19:54:35 * elliott thinks (fmap Just .) is ok
19:54:49 <elliott> ok *liftM Just to fit the type signature exactly
19:55:29 <dibblego> @type fmap fmap fmap $ pure
19:55:29 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Applicative f2) => f (f1 a) -> f (f1 (f2 a))
19:55:48 <elliott> @type fmap (fmap pure)
19:55:49 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *). (Applicative f, Functor f1, Functor f2) => f2 (f1 a) -> f2 (f1 (f a))
19:55:55 <elliott> hmm... oh!
19:56:01 <elliott> dibblego: sorry, of course, the outer f is the function arrow
19:56:09 <dibblego> @type \f -> fmap f . Kleisli
19:56:10 <lambdabot> forall a b a1 (m :: * -> *). (Functor (Kleisli m a1)) => (a -> b) -> (a1 -> m a) -> Kleisli m a1 b
19:56:34 <sohum> @hoogle [m a] -> m [a]
19:56:34 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:56:34 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
19:56:34 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
19:56:40 <dibblego> @type fmap Just . Kleisli
19:56:41 <lambdabot> forall a a1 (m :: * -> *). (Functor (Kleisli m a1)) => (a1 -> m a) -> Kleisli m a1 (Maybe a)
19:59:21 <hask3ll> by simple I mean something that isn't the horrible function I am using now :)
20:00:12 <hask3ll> ppp f (Just x) = liftM Just $ f x   (and ppp _ Nothing = return Nothing)
20:00:30 <dibblego> looks like you want MaybeT to me
20:00:38 <hask3ll> it seems like something that can be reduced
20:03:48 <elliott> hask3ll: that doesn't match the type you gave, anyway
20:05:16 <hask3ll> oh, right. I have Maybe on the argument there
20:06:46 <parcs`> first define 'f :: Maybe (m a) -> m (Maybe a)' then your function is just 'f . fmap'
20:06:57 <hask3ll> let me re-ask the question... how can I use the Maybe monad >>= inside another monad with a function in the other monad?
20:07:08 <parcs`> wait, fmap f . fmap :P
20:07:08 <dibblego> hask3ll: MaybeT
20:07:35 <parcs`> what is 'n (m a) -> m (n a)' called again?
20:07:40 <dibblego> sequence or distribute
20:07:47 <dibblego> depending on properties of n and m
20:08:59 <hask3ll> dibblego, I don't quite see how. wouldn't MaybeT be on the outside, like MaybeT (m a)? then I would have to do something with join to get back to m
20:09:02 <parcs`> :t fmap sequenceA . fmap
20:09:03 <lambdabot> Not in scope: `sequenceA'
20:09:11 <parcs`> :t fmap Data.Traversable.sequenceA . fmap
20:09:12 <lambdabot> forall (t :: * -> *) (f :: * -> *) a a1. (Data.Traversable.Traversable t, Applicative f) => (a1 -> f a) -> t a1 -> f (t a)
20:09:14 <dibblego> hask3ll: MaybeT m a ~~ m (Maybe a)
20:09:31 <dibblego> your code above is almost the body of (>>=) for MaybeT
20:10:01 <dibblego> @type Data.Distributive.distribute
20:10:01 <lambdabot> Couldn't find qualified module.
20:10:04 <dibblego> boo
20:10:04 <parcs`> :t fmap Data.Traversable.sequenceA . fmap :: (a -> IO b) -> Maybe a -> IO (Maybe b)
20:10:05 <lambdabot> forall a b. (a -> IO b) -> Maybe a -> IO (Maybe b)
20:10:14 <dibblego> parcs`: that's traverse
20:10:27 <dibblego> @type Data.Traversable.traverse
20:10:28 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:10:51 <parcs`> oh, cool
20:11:03 <dibblego> distribute :: (Functor f, Distributive g) => f (g a) -> g (f a)
20:11:18 <parcs`> in what package is distribute defined?
20:11:33 <dibblego> distributive
20:11:33 <elliott> one of edwardk's. "distributive"?
20:11:36 <elliott> yay
20:12:14 <parcs`> oh, cool
20:18:11 <hask3ll> so I take it MaybeT doesn't come with the GHC?
20:18:43 <parcs`> it does
20:18:46 <parcs`> Control.Monad.Trans.Maybe
20:19:22 <hask3ll> oh, there it is
20:19:34 <parcs`> well, technically it doesn't, but the package it's in is pretty much ubiquitous
20:20:17 <luite> actually it does come with ghc, module name is Maybes, package ghc :)
20:20:29 <luite> but that's not the one everyone is using of course
20:21:14 <elliott> ghc's package naming is so
20:21:17 <elliott> uh
20:21:19 <elliott> imaginative
20:21:25 <elliott> creative, is another word
20:21:41 <elliott> "mess" is another still
20:21:49 <luite> you mean module naming?
20:22:00 <tgeeky> elliott: in the same way that a thesaurus is "creative" for havining "imaginative" in its listing
20:26:14 <elliott> luite: yeah module
20:26:16 <elliott> sorry
20:28:57 <luite> yes the module structure is rather.. flat, except for a few, uh, exceptions
20:40:07 <pengw> is there a opencl haskell binding?
20:40:31 <ByronJohnson> pengw: http://hackage.haskell.org/package/OpenCL-1.0.3.0
20:41:04 <ByronJohnson> pengw: You can always search for packages on Hackage at http://hackage.haskell.org/packages/hackage.html (or with cabal-install)
20:47:01 <hask3ll> okay. I guess I don't see how this fits together with MaybeT. I have my function :: Monad m => a -> m b and I want to pass m (Maybe a) and get m (Maybe b) back. so I need to do something like liftM into MaybeT, right?
20:47:24 <sully> hm
20:47:36 <sully> is there an easy way to turn an Integer into a ByteString with its bytes?
20:47:47 <mauke> what do you mean by "its bytes"?
20:47:59 <sully> like, a ByteString that contains the same number
20:48:06 <mauke> what do you mean by "same number"?
20:48:24 <ivanm> sully: textually?
20:48:26 <sully> I mean a big-endian representation of the number in the integer
20:48:29 <ByronJohnson> sully: You probably want to serialize that data.
20:48:29 <sully> or a little-endian
20:48:30 <sully> or whatever
20:48:36 <ivanm> sully: see blaze-builder or binary-bits
20:48:39 <ByronJohnson> sully: I'd look at http://hackage.haskell.org/package/binary-0.5.1.0
20:49:03 <ivanm> or just binary itself
20:49:05 <ByronJohnson> sully: And http://hackage.haskell.org/package/cereal-0.3.5.1
20:49:10 <ivanm> or cereal if you want strict bytestrings
20:49:25 <ski> hask3ll : if you first convert to `a -> MaybeT m b', you can then use `(=<<)' to get `MaybeT m a -> MaybeT m b', from where it's easy to get `m (Maybe a) -> m (Maybe b)'
20:49:50 <sully> (my actual goal is that I want to take an md5 hash of something but get the output as base64)
20:50:50 <hask3ll> ski, the problem is the conversion. is the only way to do it to write a wrapper function?
20:52:08 <ski> not sure what you mean
20:52:30 <sully> Data.Binary looks like it was want I want
20:52:31 <sully> thanks
20:53:49 <hask3ll> say I have a function like String -> IO (). how do I turn it to String -> MaybeT IO ()?
20:53:58 <ski>   runMaybeT (lift . my_function =<< MaybeT blah)  -- something like this might work
20:54:21 <hask3ll> I see
20:54:26 <ski> hask3ll : i thought you wanted to get `IO (Maybe String) -> IO (Maybe ())' back there .. ?
20:55:02 <mauke> liftIO . f
20:55:03 <ski> well, `lift . my_function' is the answer to your last question
20:55:06 <ByronJohnson> :t (lift .)  :: (String -> IO ())  ->  (String -> MaybeT IO ())
20:55:07 <lambdabot>     Not in scope: type constructor or class `MaybeT'
20:55:28 <ski> @hoogle MaybeT
20:55:29 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
20:55:29 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
20:55:29 <lambdabot> Control.Monad.Trans.Maybe newtype MaybeT m a
20:56:15 <sully> hm, fuck
20:56:20 <hask3ll> I'm not sure why I said that earlier. the last part is what I need
20:56:22 <sully> how do I go from a lazy bytestring to a strict one?
20:56:37 <mauke> concat . chunks
20:56:48 <ByronJohnson> sully: You use toChunks to get a list of strict bytestrings and then concatenate that
20:56:57 <sully> cute.
21:04:56 <hask3ll> "No instance for (Control.Monad.Trans.MonadTrans MaybeT)" when I do that, ski
21:05:35 <sohum> @src sequence
21:05:35 <lambdabot> sequence []     = return []
21:05:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:05:36 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
21:06:01 <sohum> is it just me, or does that have a space leak
21:06:15 <ski> hask3ll : hm, that's strange
21:06:47 <mauke> @src sequence_
21:06:47 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
21:06:52 <shachaf> sohum: In what way would you want it to be different?
21:07:17 <ski>   instance MonadTrans MaybeT
21:07:20 <ski>     where
21:07:30 <ski>   --lift :: Monad m => m a -> MaybeT m a
21:07:40 <ski>     lift ma = MaybeT (liftM Just ma)
21:07:43 <ski> i think
21:09:16 <hask3ll> it worked!
21:10:15 <hask3ll> now the question is... why is that not in the module? or am I importing the wrong thing?
21:10:31 <ski> maybe, i dunno
21:13:45 <sohum> shachaf: I'm... not sure, now, after some testing
21:13:56 <hask3ll> well I'm off. thanks for the help guys
21:32:17 * danharaj writes the edwardk signal on a blackboard
21:32:23 <edwardk> sup?
21:32:56 <danharaj> Dumb question: how do you turn 'Store i o r = Store (i -> r) o' into a comonad?
21:33:08 <edwardk> its an indexed comonad
21:33:12 <edwardk> not a comonad
21:33:14 <edwardk> let i = o
21:33:16 <edwardk> then its a comonad
21:33:21 <danharaj> indexed comonad?
21:33:30 <edwardk> like an indexed monad
21:33:35 <danharaj> heh.
21:33:40 <edwardk> return :: a -> m i i a
21:33:56 <edwardk> bind :: m i j a -> (a -> m j k b) -> m i k b
21:34:00 <danharaj> I see, so when you said "indexed store comonad" I misassociated it as "(indexed store) comonad"
21:34:09 <edwardk> yeah
21:34:34 <edwardk> an example of an indexed monad, is indexed writer, where you parameterize it on a category, not a monoid
21:34:43 <edwardk> or indexed state, where you can change the state between calls to get and put
21:35:22 <edwardk> its worthwhile to go through and work a few of those out
21:35:29 <danharaj> I shall.
21:35:29 <edwardk> indexed writer is pretty spiffy actually
21:35:55 <danharaj> It'll be a bit of a puzzle for me to figure out what it would mean to run an indexed writer. :)
21:36:07 <edwardk> sigfpe has a blog post on the topic
21:36:14 <edwardk> indexed cont is useful for delimited continuations as well
21:37:32 <edwardk> think of bind as taking some pair of a value and an arrow in a category, and applying the function you bound to, to get a new value, and composing the arrow you get back to the old arrow you had, giving you a longer arrow in the category
21:37:52 <edwardk> e.g. you could use Endo x as a monoid for your writer
21:38:00 <edwardk> now you are allowed to change 'x' on each tell
21:40:09 <danharaj> Someone really ought to write a book on this stuff, even if it is just a very big bibliography of blog posts and papers. :)
21:40:34 <kaitocracy> hi what is the difference between liftM and fmap?
21:40:52 <znhxr> liftM is for Monad, fmap is for Functor
21:40:54 <edwardk> kaitocracy: liftM requires Monad, fmap only requires Functor
21:40:58 <znhxr> many things are both Functors and Monads
21:41:00 <kaitocracy> but they're essentially the same operation no?
21:41:05 <edwardk> effectively yes
21:41:11 <kaitocracy> got it thanks
21:41:15 <danharaj> Yes they are but it is a historical accident that Monad is not a subclass of Functor.
21:41:17 <edwardk> the laws constrain them to do the same thing if both are defined
21:41:29 <edwardk> however, Monad isn't a subclass of Functor, because of some bad judgment in 98
21:41:41 <dolio> Earlier than that, I think.
21:41:42 <kaitocracy> is anyone working on a new Prelude that makes more sense?
21:41:51 <kaitocracy> it seems to me like the whole Functor, Applicative, Monad thing is a mess
21:41:52 <liyang> There are various alternative Preludes.
21:42:09 <edwardk> well, there was talk of adding it during the haskell 98 standardization
21:42:22 <edwardk> kaitocracy: and i don't think anyone would disagree with you =)
21:42:33 <edwardk> its really quite embarassing
21:42:34 <liyang> But none slated to replace the existing one.
21:42:38 <kaitocracy> I see
21:42:39 <danharaj> There are already steps towards breaking up the class hierarchy.
21:42:54 <danharaj> and 'fixing' it.
21:43:04 <edwardk> kaitocracy: ultimately, when you have a third party Monad, and just a Monad, use liftM, when you are making your own monads, make them also Functors
21:43:17 <kaitocracy> okay I see
21:43:18 * mgsloan thinks we need to take steps towards making these kinds of decisions less permanent
21:43:38 <edwardk> the main time I use liftM is when I have a function i'm defining where all i can know about the argument is its a monad (e.g. i'm in a monad transformer stack, etc)
21:43:53 <edwardk> mgsloan: there was a big push from SPJ and marlow to make a bunch of breaking changes
21:43:54 <liyang> Problem is that so many existing libraries uses the current Prelude, it's too much work to avoid.
21:44:00 <edwardk> but the community largely hasn't taken them up on it
21:44:15 <edwardk> liyang: its pretty much impossible to get anything done without the prelude
21:44:19 <mgsloan> in the general case of determining class hierarchies - there needs to be a way to say "I have this other, but related class hierarchy, and here's the isomorphism" - and get libraries that use each to interoperate
21:44:26 <kaitocracy> well it seems like an alternative Prelude would be very simple, you'd call it Postlude or something
21:44:35 <kaitocracy> then you'd just do import Prelude (); import Postlude
21:44:40 <kaitocracy> in all of your new files or something
21:44:53 <edwardk> kaitocracy: the problem is you need everyone to move over to it, because otherwise they didn't import your classes or make any instances for it
21:45:04 <edwardk> kaitocracy: which makes it basically never fly
21:45:22 <kaitocracy> I see
21:45:25 <danharaj> Haskell already avoids success at all costs.
21:45:35 <danharaj> Might as well break standard library interfaces on top of that.
21:46:31 <mgsloan> I've considered writing a TH wrapper thingie that would take code that targets a better typeclass hierarchy, and have a way of deriving instances for any types using the other hierarchy
21:46:51 <mgsloan> kinda like C++ template instantiation
21:47:12 <danharaj> any time you end a sentence with "kind of like C++ template instantiation" you know something you said was terribly perverted.
21:47:16 <mgsloan> (:)
21:48:09 <mgsloan> yeah, I get that a lot.  people suggested my TH access be revoked after I created pointless plumbers :)
21:48:22 <mgsloan> macros aren't evil!  We're too used to not needing them
21:49:15 <mgsloan> there is _definitely_ something missing when it comes to deriving class instances.
21:50:13 <mgsloan> e.g. I want to be able to declare newtype-deriving style instances for things, but with a lens to map to/from the thing that actually has instances defined
21:50:33 <mgsloan> err maybe not a lens.  Bijection.
21:50:47 <znhxr> B I J E C T I O N
21:51:00 <edwardk> mgsloan: yeah, you were saved, because we couldn't get a quorum without dons showing up, and hell, when was the last time anyone saw him?
21:51:07 <mgsloan> lens could work too, actually, as long as all of the methods take one of the "a"
21:53:28 <BMeph> I've been having lots of fun catching up on my education, reading papers pablished in the mid-to-late '80's.
21:53:51 <BMeph> I think we need more fun with continuations. MOAR CONTINUATIONS!
21:55:58 * BMeph makes a "full disclosure" statement concerning his writing an interpreter for a language whose control structures are continuation-based.
21:56:47 <kaitocracy> wait are liftM and ap also the same thing?
21:56:49 <otters> who's this damn3d guy
21:57:42 <liyang> edwardk: SC are working him pretty hard it seems. D:
21:58:12 <hpaste> sohum pasted “sequence space leak?” at http://hpaste.org/66213
21:58:47 <edwardk> liyang: i think they broke something in him along the way. if you follow his tweets for the last year they have been nothing but wistful glances out the window at sunsets
21:59:14 <liyang> edwardk: need to hatch a plan to break him out of there. :(
21:59:33 <edwardk> Perhaps dons is trying to send us a message, like "HELP! I Am being held hostage!" and we've been ignoring the steganographic evidence all along.
21:59:46 <sohum> shachaf: pasted a thing that shows the problem I'm having
22:06:44 <sopvop> Maybe he actually found haskell job?
22:08:11 <liyang> They do use Haskell at Standard Chartered; not sure how much though, nor how much personal freedom to work on community stuff they have. Neil Mitchell's there too.
22:08:36 <liyang> (We use Haskell too, pretty much exclusively. *plug* :)
22:09:22 <Enigmagic> (We use Haskell for the important stuff)
22:10:39 <sopvop> Being the only programmer in animation studio I can choose any language I want, but since most of my work is writing plugins and scripts for closed source apps, I'm forced to use python or c++.
22:12:27 <sopvop> And now my code in python is getting filled by if isinstance... else if isinstance... , and I used to love python.
22:12:49 <Enigmagic> sopvop: i like python for 20-30 line scripts
22:13:27 <Enigmagic> i'm too used to having some form of static type checking to deal well with scripts over a hundred lines or so
22:14:00 <sopvop> type checking is one thing, pattern matching is what I miss the most.
22:18:20 <zmoazeni> liyang / Enigmagic / others: in what context is Haskell used in the industry?
22:18:36 <thelastnode> hey guys, looking to work on a side project with audio (microphone in) in Haskell, any recommendations?
22:19:11 <Enigmagic> zmoazeni: http://www.haskell.org/haskellwiki/Haskell_in_industry ?
22:21:12 <liyang> Pattern matching (in that sense) is really a consequence of (closed) algebraic data types. Unfortunately in OO-influenced languages the class hierarchy is more akin to open (you can add more 'constructors' later) ADTs, and 'pattern matching' (i.e. isinstance) becomes a bit more hairy.
22:24:45 <liyang> zmoazeni: in Tsuru's case, close enough to everything we write.
22:29:24 <sopvop> At least in c++ you have boost::variant, which is almost like ADT
22:36:13 <zmoazeni> I'm surprised to see so many trading/financial applications of Haskell. Though I guess it makes.
22:36:53 <zmoazeni> *sense
22:38:20 <sohum> anyone feel like helping me with http://hpaste.org/66213 ?
22:56:10 <quintessence> sohum: making sequence tail recursive (via the usual list reversing trick) seems to work
22:56:39 <quintessence> I guess "tail recursive modulo bind" is more like it
22:57:20 <flamingspinach> man, why do we apply functions from the left side of an expression but have arrows going left to right in the function's type declaration?
22:57:43 <flamingspinach> like, a -> b -> c is a -> (b -> c) but a b c is (a b) c
23:02:37 <danharaj> flamingspinach: because it makes sense that way
23:02:40 <liyang> (->) associating to the left would be pretty tedious…
23:03:16 <liyang> And likewise the invisible function application operator.
23:07:23 <sohum> @pl \f a b -> foldl' (flip f) a (reverse b)
23:07:23 <lambdabot> flip flip reverse . ((.) .) . foldl' . flip
23:07:48 <sohum> quintessence: you mean foldr' f a b = foldl' (flip f) a (reverse b)?
23:08:22 <shachaf> You know you're doing something wrong when @pl
23:08:43 <shachaf> 's output looks more like instructions for acrobatics than a Haskell program.
23:09:02 * sohum does a double reversed flip!
23:09:04 <quintessence> um, I wrote it out as sequence' xs = go xs [] where {go [] vs = return $ reverse vs; go (x:xs) vs = x >>= go xs . (:vs)}
23:09:25 <shachaf> quintessence: That's not the same function.
23:09:53 <shachaf> I mean that it has completely different effects, which are often the point of sequence.
23:10:11 * shachaf looks at the context.
23:10:47 <quintessence> does it?  It still does them in order
23:11:05 <shachaf> It does?
23:11:10 <shachaf> Oh, it does.
23:11:13 * shachaf misread.
23:11:35 <shachaf> I guess in some cases it would make sense?
23:12:02 <quintessence> sohum was getting a stack overflow from regular sequence
23:12:51 <shachaf> Ah.
23:13:24 <shachaf> sohum: What weird unsafePerformIO semantics, by the way? If it's safe you might consider using unsafeDupablePerformIO.
23:15:09 <sohum> shachaf: I didn't check, but I suspect it was running the IO code more than once. and when the point of making this change is that this section of your code is 90% of your runtime ... :P
23:16:01 <shachaf> unsafePerformIO shouldn't do that, I think.
23:16:12 <mgsloan> Damn3d's join / exits are far too regular to be unintentional
23:16:13 <shachaf> But of course you should avoid it anyway in a situation where you can help it.
23:16:20 <mgsloan> also "Excess Flood" quit message?
23:16:51 <shachaf> mgsloan: It could be an unthrottled IRC client sending too many join commands when starting up?
23:17:09 <mgsloan> could be
23:17:41 <mgsloan> not sure why I even have entrance / exit messages viewable
23:29:17 <sohum> oh, duh
23:29:37 <sohum> @pl \f a b -> reverse $ foldl' (flip f) a b
23:29:37 <lambdabot> ((reverse .) .) . foldl' . flip
23:30:03 <sohum> :t reverse ((.) . (.)) foldl' . flip
23:30:04 <lambdabot>     Couldn't match expected type `[a -> b]'
23:30:04 <lambdabot>            against inferred type `(a1 -> b1) -> f a1 -> f b1'
23:30:04 <lambdabot>     In the second argument of `(.)', namely `(.)'
23:30:16 <sohum> oh, three, not two
23:31:04 <sohum> anyway, that's foldr', and with that you can implement sequence' just replacing foldl with foldr'
23:32:52 <xrl> I'm writing a tool to parse a URI and create a TCP socket. To do this sane I want to use MaybeT IO but I'm having a heck of time with the types. https://github.com/xrl/zmqhs/blob/connection/test/blaster/Blaster.hs is the CLI.
23:34:04 <xrl> pulling out the parts of the URI should be a Maybe, so if it fails it won't even try the create the socket
23:38:22 <Enigmagic> xrl: what line in particular?
23:38:36 <xrl> line 45
23:38:59 <Enigmagic> what's the type of ZC.uri_parts ?
23:39:08 <xrl> U.URI -> Maybe (S.HostName, S.ServiceName, S.SocketType)
23:39:14 <xrl> err, uri_parts :: U.URI -> Maybe (S.HostName, S.ServiceName, S.SocketType)
23:39:37 <Enigmagic> okay, so what is the liftIO supposed to do?
23:40:19 <sohum> or... not
23:40:21 * sohum headdesk
23:40:49 <sohum> I'll just use the explicit variant... my head's clearly not working
23:40:49 <xrl> Enigmagic: the liftIO should not be there. without it I would expect the code to behave like the Maybe monad
23:40:54 <sohum> thanks, quintessence!
23:41:11 <Enigmagic> xrl: except it's not the Maybe monad, it's MaybeT
23:41:50 <Enigmagic> xrl: read through this post to see how to convert (Maybe a) to (MaybeT m a) .. http://stackoverflow.com/questions/8684252/how-to-inject-a-maybe-value-into-maybet
23:41:51 <xrl> hmm, for some reason I thought I could put Maybe in MaybeT
23:42:06 <cy1> Cabal-1.14.0-3413d556320121d1c08b8a8bc3f7e245 is unusable due to missing or recursive dependencies: directory-1.1.0.2-71fc9828e4f6545b839e07243053221f process-1.0.1.5-633141f7a94fd11e18aab0c47e279ae7
23:42:33 <cy1> cabal install --global process works fine, but cabal install --global syb fails...
23:45:14 <xrl> Enigmagic: it seems like this should be part of the MaybeT monad. I'll have to stash it away somewhere. Thanks for the info -- it definitely makes sense
23:45:38 <kaitocracy> Are there any good guides on how to write a monad transformer?
23:45:48 <kaitocracy> I find a lot on how to use them
23:45:55 <kaitocracy> Not so much on how to make them
23:46:00 <Enigmagic> xrl: i agree
23:48:41 <cy1> I guess haskore can't be installed anymore... looked promising too.
23:49:36 <sohum> ... it hit a ghc bug
23:49:55 <cy1> damn, that sucks
23:50:38 <cy1> "syb" is what cabal won't do, I guess because it's old and depends on old versions of process and directory. Didn't know it hit a genuine bug though.
23:53:41 <cy1> There's hmt, but the website is 403 forbidden so who knows what the heck it does
23:55:32 <nart> ciao =)
23:55:54 <cy1> HaMusic requires authentication to see its sales pitch. x.x
