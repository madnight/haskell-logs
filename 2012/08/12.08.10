00:00:05 <pharaun> it normally arrives as ascii/utf8 but if its too large it will be prefixed with two byte set to 00 and the rest of it is compressed
00:00:16 <shachaf> donri: Why are you telling people about Char8?
00:00:21 <pharaun> haha
00:00:22 <donri> Char8 isn't really worse than Num :P
00:00:33 <shachaf> Yes, it is.
00:00:37 <pharaun> anyway thanks for slapping me out of my stupidity :)
00:00:38 <startling> why is Char8 bad?
00:00:54 <Jafet> pharaun: ASCII/UTF8 is not an encoding
00:00:55 <startling> how is it different from Word8? is Word8 good?
00:01:01 <Jafet> If it's UTF-8, it's not ASCII
00:01:13 <startling> if it's ASCII, it's UTF-8!
00:01:21 <donri> shachaf: in any case i find withholding information rarely helps. pharaun will just go on to discover char8 themselves, without our warnings.
00:01:55 <shachaf> donri: "withholding information" isn't the same as "offering up information about bad things that no one asked for". :-(
00:02:07 <startling> ∴ ASCII ⊂ Utf-8
00:02:22 <donri> shachaf: i personally find it useful to know about the bad options, so i can understand better why i should use the better options
00:02:48 <Jafet> @google joel spolsky unicode
00:02:49 <lambdabot> http://www.joelonsoftware.com/articles/Unicode.html
00:02:49 <lambdabot> Title: The Absolute Minimum Every Software Developer Absolutely, Positively Must Know A ...
00:02:51 <shachaf> I'm not saying "no one should ever know about the existence of Char8".
00:03:08 <pharaun> Jafet: ascii is a subset of utf8 is it not because utf8 was made to be a "superset" of ascii from my understanding
00:03:10 <shachaf> But if someone asks "how do I convert an Integer to a Double", you might tell them about fromIntegral, but you don't tell them about unsafeCoerce.
00:03:19 <pharaun> donri: i've already dealt with char8 before on other project
00:03:30 <startling> I still don't get it. Are you guys saying Char8 is bad because it encourages ASCII?
00:03:45 <Jafet> Char8 is a module in Data.ByteString.
00:03:45 <startling> or because it's a bad implementation of a sometimes-necessary thing? or what?
00:03:53 <Jafet> You should never import it.
00:03:59 <startling> oh alright
00:04:04 <donri> shachaf: in your example, fromIntegral isn't really more work to use
00:04:29 <donri> shachaf: dealing with encodings *is* extra work, and it's useful to understand why you need to do it
00:04:42 <pharaun> Jafet: is that because Char8 is a single block of 8bit but with UTF8, etc.. you can have multiple 8bit block for a character
00:05:10 <donri> startling: char8 truncates Char to Word8 at runtime with no errors or warnings.
00:05:10 <pharaun> Actually what is the best approach for dealing with utf8 string?
00:05:17 <shachaf> Using Char8 makes you racist.
00:05:21 <donri> lol
00:05:28 <Jafet> Text.Encoding.decodeUTF8
00:05:31 <shachaf> Or maybe being racist makes you use Char8. I don't know which direction it goes.
00:05:33 <Jafet> Or whatever it's called
00:05:43 <pharaun> i'm going to have to deal with utf8 soon anyway, right now my test data is ascii but i know the input needs to be able to take utf8
00:05:46 <Jafet> thatsracist.gif
00:05:55 <donri> decodeUtf8 IIRC
00:06:08 <pharaun> Jafet: so when i got a ByteString, i should feed it into this decodeUtf8 and it'll do the right thing ?
00:06:13 <startling> donri: ah alright
00:06:28 <shachaf> pharaun: If it's a ByteString of UTF-8 data, decodeUtf8 will turn it into a Text.
00:06:34 <Jafet> It will decode UTF-8
00:06:39 <donri> (which is why i half-joked that it's no worse than Num; Num also truncates without warnings)
00:06:44 <Jafet> If it doesn't get UTF-8, it bawls in a corner
00:06:45 <donri> > 256 :: Word8
00:06:46 <lambdabot>   0
00:07:01 <pharaun> shachaf: Data.Text ?
00:07:08 <shachaf> Data.Text.
00:07:18 <Jafet> That's not truncation
00:07:24 <Jafet> > 257 :: Word8
00:07:25 <lambdabot>   1
00:07:39 <donri> well yea, mod
00:07:45 <pharaun> that's annoying, google always links to the damn archive for haskell docs
00:07:53 <startling> how else would Num work?
00:08:17 <startling> after all, (1 :: Word8) + 255 == 0
00:08:21 <donri> startling: compile-time errors for literals at least would be nice
00:08:35 <Jafet> It's not an error
00:08:53 <Jafet> WordN is a ring modulo 2^N
00:08:57 <pharaun> shachaf: can i still use parsec on Data.Text. ? or is it better to have parsec parse the underlaying ByteString (I know the header data) is limited to ASCII, but the data payload has utf8 in it
00:08:57 <shachaf> > maxBound + 1 :: Int -- What about this?
00:08:58 <lambdabot>   -9223372036854775808
00:11:00 <donri> pharaun: maybe you want conduit leftovers. you could peek at the header bytes and then put them back into the stream
00:12:23 <pharaun> donri: i already tried conduit, it proved just slightly beyond what i'm in the mood for tonight :) but i think i got some progress there, will re-try it once i got more patience :)
00:14:24 <MostAwesomeDude> Hey! Apparently doing Haskell on Windows is a PITA; can I cross-compile?
00:16:21 <Jafet> Theoretically
00:16:46 <pharaun> Jafet: shachaf donri <3
00:16:55 <pharaun> i got something to work for uncompressing this
00:18:42 <Jafet> ghc doesn't seem to have any cross compiling options
00:19:15 <pharaun> can't you emit the source from ghc then use gcc to cross-compile ?
00:19:20 <pharaun> or is it more complicated than that?
00:19:21 <Jafet> I guess you just need to build a ghc with a different target
00:19:36 <Jafet> ghc is no longer via-c
00:19:45 <pharaun> oh when did they change that
00:19:55 <startling> you can still output C, can't you?
00:20:13 <Jafet> When they added a proper code generator
00:20:41 <Jafet> You can probably still use via-c, but that's dumb
00:34:07 <MostAwesomeDude> Well, mingw is significantly less stupid than Windows itself.
00:34:35 <MostAwesomeDude> I mean, ideally, somebody would have a document somewhere that explains how Joe Practical Haskell would deploy an app to Windows and OS X.
00:34:52 <startling> deploy? who deploys haskell?
00:34:56 <MostAwesomeDude> (And of course, ideally, there would be no Windows or OS X, but until then...)
00:35:21 <startling> MostAwesomeDude: I can potentially help for os x at least. what kind of thing is it?
00:35:31 <pharaun> cygnwin? at least for windows?
00:45:10 <jtanguy> is it possible to turn a list of String into datatype constructors?
00:47:10 <startling> jtanguy, you'll need to specify more clearly what you mean
00:49:29 <jtanguy> i have a list of string, say ["q0","q1","q2"], and i would like to turn it into some data declaration : data Location = Lq0 | Lq1 | Lq2
00:49:51 <shachaf> foo :: String -> Maybe Location
00:50:12 <shachaf> foo "q0" = Just Lq0; foo "q1" = Just Lq1; foo "q2" = Just lq2; foo _ = Nothing
00:50:21 <shachaf> map foo ["q0","q1","q2"]
00:51:45 <tmiw> class constraints get me every time
00:51:58 <jtanguy> shachaf: i'd like to generate the data declaration
00:52:19 <shachaf> ?
00:52:23 <tmiw> turns out the RenderMessage is actually important for i18n to work. https://github.com/tmiw/4peas/blob/master/Forms/RecipeForm.hs#L36
00:52:26 <tmiw> hehe
00:52:30 <fmap> that should be possible with TH
00:52:32 <shachaf> You have a list of strings at compile-time?
00:52:43 <jtanguy> yes
00:52:44 <shachaf> If so, yes, TH.
00:54:55 <startling> jtanguy: why don't you just write the data declaration?
00:56:27 <jtanguy> the input string can be quite long, but i would like to have it encoded in a type
00:59:08 <jargonjustin> Is it possible to get a stack trace (or something similar) for where I'm hitting undefined?
01:00:18 <donri> jargonjustin: -prof -prof-auto -rtsopts -with-rtsopts=-xc
01:00:37 <donri> -fprof-auto, sorry
01:00:58 <jargonjustin> donri: Is that only necessary for my module, or do I have to build linked libraries with similar options as well?
01:01:21 <donri> jargonjustin: everything must be at least -prof
01:01:56 <donri> easy with cabal-dev: cabal-dev install --enable-library-profiling
01:02:56 <jargonjustin> donri, thanks
01:03:24 <jargonjustin> Is there a similar incantation for GHCi?
01:03:32 <jargonjustin> And is this documented somewhere?
01:03:40 <donri> no idea, and http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-compiler-options.html
01:03:45 <hpaste> Vivian pasted “Not in scope data constructor” at http://hpaste.org/72897
01:03:54 <donri> well http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
01:04:53 <om-foxy> Hi, I have a strange error that a data constructor is not in scope.  http://hpaste.org/72897
01:05:39 <donri> om-foxy: you don't actually have module Types where there right?
01:06:01 <shachaf> om-foxy: What's "Ticks"?
01:06:21 <shachaf> It's a type, but you're talking about a value called "Ticks".
01:06:32 <om-foxy> donri:  Yes, I export the whole module
01:06:53 <donri> om-foxy: but surely you have, module Graphics.Rendering.Plot.Types where, not just "Types"?
01:06:57 <jargonjustin> donri, thanks again
01:07:14 <om-foxy> shachaf:  data Ticks = Ticks LineType TickValues
01:07:30 <shachaf> Oh, it's TickNum that isn't in scope.
01:07:36 <shachaf> Yes, the problem is what donri said.
01:07:56 <om-foxy> donri: yes, I have module Graphics.Rendering.Plot.Types
01:08:04 <shachaf> om-foxy: No, you have "module Types".
01:08:17 <shachaf> If the module's names is Graphics.Rendering.Plot.Types, it should say that.
01:09:01 <om-foxy> shachaf: Yes, I have the long qualified Types.hs, I wasn't cutting and pasting
01:09:29 <shachaf> OK, so the problem is probably somewhere other than where you think it is.
01:09:56 <donri> no idea then, maybe try -fforce-recomp or something, duno
01:10:25 <ergot> hi
01:10:55 <jtanguy> :r
01:11:08 <jtanguy> oops, wrong term
01:11:10 <ergot> is there any way to use the Data.Elf with lazy ByteStrings?
01:11:27 <ergot> or some alternative elf parsing library?
01:12:46 <startling> ergot: you could help me write mine. :)
01:13:38 <shachaf> ergot: Turning a strict ByteString into a lazy ByteString is easy.
01:13:53 <shachaf> LB.fromChunks [strictByteString]
01:14:46 <om-foxy> hm...  I erased the word `TickNum` and retyped `TickNum` and it now works.
01:14:52 <ergot> shachaf the problem is that parseElf doesn't seem to support lazy bytestrings as parameter
01:15:13 <ergot> startling I don't know if I'm good enough at haskell to help you :P
01:15:52 <shachaf> ergot: Oh, it's the other way around.
01:16:15 <shachaf> Converting a lazy ByteString to a strict ByteString is easy too, but you have to load the whole thing into memory.
01:16:31 <ergot> thats the problem
01:17:21 <startling> what should I use for a 128-bit integer?
01:17:25 <ergot> I want to parse the Elf data in /proc/kcore and obviously my program can't allocate the memory
01:17:42 <shachaf> startling: I think there's a module that has those.
01:18:04 <startling> @hoogle Word128
01:18:05 <lambdabot> No results found
01:18:14 <shachaf> @google Word128 haskell
01:18:19 <shachaf> Not sure if it's any good.
01:18:22 <lambdabot> http://hackage.haskell.org/packages/archive/Crypto/4.1.0/doc/html/Data-LargeWord.html
01:18:23 <lambdabot> Title: Data.LargeWord
01:18:24 <t7> i think its in cypto
01:18:31 <startling> shachaf: ooh, thanks
01:18:48 <startling> will Integer go that big?
01:18:53 <t7> yeah
01:19:00 <t7> Integer is unbounded (almost)
01:19:04 <startling> I can just use that, I suppose
01:19:30 <startling> t7: how can it be unbounded almost? surely it's too small for most of the integers
01:19:48 <t7> > 12894769826983476598347659827346589463598763249857639485683456834659876345896 :: Integer
01:19:49 <lambdabot>   12894769826983476598347659827346589463598763249857639485683456834659876345896
01:19:56 <t7> its a bignum
01:20:20 <startling> t7: it's still too small for most of the integers
01:20:28 <startling> ;)
01:20:36 <t7> it limited by you ram
01:20:50 <t7> and probably 32bit block indexes
01:20:55 <t7> so buy more ram
01:21:08 <shachaf> Or download more.
01:22:07 <ergot> startling: in what state of development is your Elf parsing lib?
01:22:18 <startling> ergot: nothing at the moment
01:22:29 <ergot> heh, ok
01:22:31 <startling> working on Macho, and parsing is secondary to generating for me
01:22:54 <sopvop> So, If I make a to/form json converter which also documents format, can I make a smart face and call it "self documenting partial isomorphism"?
01:23:41 <startling> sopvop, you could do s/{/< s/}/> s/:/= and call it xml. :)
01:27:25 <t7> why have i heard the word isomorphism about 100 times this week?
01:27:32 <sopvop> Well, I actually mean shema generating printer-parser. Like you can convert haskell data type to json, try parse json from it or generate shema. Is there some smart word for it? :) It should end with "ism" "oid" and start with something like "hemi" "iso" "group"
01:27:33 <t7> is it a new fad?
01:27:43 <sopvop> Because of "lens" package?
01:27:45 <t7> one of those memes
01:28:05 <t7> le isomorphism rage face fuuuuuuuuu
01:28:57 <sopvop> In topology rageface is isomorphic to trollface, coolface, torus and cup.
01:29:31 <supercali> Greetings, enlightened citizens!
01:29:49 <supercali> How would I model an object oriented hierarchy in Haskell ?
01:30:14 <supercali> Are there some papers which give a systematic conversion algorithm ?
01:30:15 <Yuu-chan> supercali: ADTs, typeclasses
01:30:39 <t7> Yuu-chan: its more of an alternative than a mirror
01:30:41 <sopvop> However, there are no subtyping in haskell
01:30:52 <supercali> yeah .. i was going to ask about subtyping
01:31:19 <startling> supercali: why would you want to?
01:31:38 <supercali> hmm .. that's a good question ..
01:32:00 <supercali> Say I was trying to come up with an alternative to the Java Swing API, it a GUI library .
01:32:18 <Yuu-chan> AFAIR, subtyping can be emulated via the existential quantification
01:32:43 <supercali> so it has a concept of Panels , which are the supertype of almost everyother class like a textbox ..
01:33:13 <supercali> how would i go about using ex quant ?
01:33:18 <sopvop> Or you can make data Widget = Widget { draw :: DrawRequest -> IO (), ... } and smart constructors.
01:34:10 <Yuu-chan> supercali: don't use it ;) There are plenty GUI libraries in Haskell
01:34:15 <supercali> he he ..
01:34:34 <supercali> I just gave it as an example .. wanted to know if this has been studied formally ..
01:35:00 <donri> if you're designing a new API, there are usually better options
01:35:06 <srhb> supercali: Well, mashing object models onto Haskell is often not the right solution for Haskell.
01:35:10 <srhb> supercali: There are better alternatives.
01:35:35 <supercali> srhb: could you point out some blogs/articles which talk about these alternatives ?
01:35:58 <donri> but, there are bindings to e.g. GTK for haskell, and GTK object-oriented, so maybe look at how Gtk2hs does it
01:35:59 <srhb> supercali: I think you'd do well to check out the GUI libraries of Haskell and their sources. :) Or simply a GUI tutorial in Haskell
01:36:25 <supercali> ok .. will check it out ... I just didn't want to be distracted by all the IO related concerns ..
01:39:31 <Yuu-chan> I have a strong feeling that the subtyping hierarchy can be mathematically mapped to sum types, like data CPanel = TextBox CTextBox | Label | Button, CTextBox = SimpleTextBox | RichTextBox, but it would be unbearable for practical use
01:43:50 <pharaun> how can i get rid of the whitespace 'foo <- (many1 (noneOf "-\n")) `sepBy1` string "-"' with this string 'foobar - test' yields ["foobar ", " test"]
01:44:08 <pharaun> is there any good way of getting rid of the leading/trailing space or am i going to need to trim it myself? (parsec btw)
01:44:50 <t7> @hoogle Set (Set a) -> Set a
01:44:51 <lambdabot> Data.Set deleteMax :: Set a -> Set a
01:44:51 <lambdabot> Data.Set deleteMin :: Set a -> Set a
01:44:51 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
01:45:22 <t7> > join :: Set (Set a) -> Set a
01:45:24 <lambdabot>   Not in scope: type constructor or class `Set'Not in scope: type constructor...
01:46:01 <fmap> i don't think Set is a monad
01:46:20 <fmap> a Monad rather*
01:46:27 <t7> i will use a fold then
01:47:19 <Yuu-chan> > join :: Data.Set.Set(Data.Set.Set a) -> Data.Set.Set a
01:47:20 <lambdabot>   Not in scope: type constructor or class `Data.Set.Set'Not in scope: type co...
01:48:30 <t7> @pl (\a b -> Set.union (free a) b)
01:48:31 <lambdabot> Set.union . free
01:48:33 <Yuu-chan> But List is a monad, ans Set could be so...
01:48:56 <fmap> pharaun: if whitespaces aren't significant i'd just filter input string before parsing
01:50:32 <pharaun> fmap: that's what i would do on my first try however in this case its sadly significant, most expr looks like "INVALID LOGIN - reason blah"
01:51:44 <Yuu-chan> pharaun: you can look into http://legacy.cs.uu.nl/daan/download/parsec/parsec.html , "Lexical analysis"
01:52:15 <t7> @pl (\a b -> Set.union b (free (substitute s (TVar a))))
01:52:15 <lambdabot> flip Set.union . free . substitute s . TVar
01:52:22 <t7> meh
01:52:36 <pharaun> Yuu-chan: ahh k i'll look thanks :)
01:56:30 <sgk284> hey there... sorry in advance for the amateur question, but... I've got two types that I'd like to compare and can't figure out how to do it. is this possible in haskell?
01:56:56 <sgk284> since Ord only takes one type... my inclination is it's not, but that can't be right
01:57:18 <quicksilver> what would it mean to compare values of two different types, sgk284 ?
01:57:36 <quicksilver> is (Left 4.0) more or less than (Just "fish") ?
01:57:55 <shachaf> quicksilver: Yes.
01:58:10 <Botje> mu.
01:58:16 <quicksilver> shachaf: the answer I was looking for was "No."
01:58:23 <shachaf> sgk284: I think sgk284 wants to comapre two types, to be fair, not two values of different types.
01:58:29 * quicksilver empties the gunk tank onto shachaf's head.
01:58:30 <Botje> sgk284: can you be more concrete?
01:58:34 <shachaf> You could certainly say that S (S Z) < S (S (S Z))
01:58:46 <quicksilver> shachaf: do you think that? I don't. Because he said "Ord only takes one type"
01:58:49 <sgk284> I've got a data type called Event, which is a {topic :: Int, time :: Int) and a Subscription which is also {topic :: Int, time :: Int}. They're different types despite having the same structure
01:59:00 <sgk284> I want to filter a stream of events if the event is >= the subscription
01:59:04 <shachaf> OK, he probably doesn't actually think that. :-)
01:59:08 <sgk284> hopefully that makes sense
01:59:19 <shachaf> sgk284: You'll need to define your own meaning for the "same structure".
01:59:20 <quicksilver> sgk284: for that case I'd just write a small custom function.
01:59:30 <shachaf> Or maybe write a function to convert one to the other, if they're really isomorphic.
02:00:18 <quicksilver> filter (\e -> E.topic e >= S.topic s || (E.topic e == S.topic s && E.time e >= S.time s))
02:00:40 <sgk284> ok, thanks. that's the route I took... but I was wondering if it was possible to define compare :: (Event a, Subscription b) => a -> b -> Ordering
02:01:14 * sgk284 is new to haskell... but trying :)
02:01:28 <Botje> sgk284: but then what would you do for different topics? the comparison doesn't apply there.
02:01:44 <quicksilver> sgk284: compare :: Event -> Subscription -> Ordering
02:01:50 <quicksilver> certainly.
02:01:57 <Yuu-chan> Better to define data Event ... deriving Ord and toEvent :: Subscription -> Event
02:01:59 <quicksilver> although it's a different compare from the normal one.
02:02:01 <Botje> sgk284: you could have ... -> Just Ordering, where you return Nothing if the topics don't match
02:02:46 <sgk284> great, thanks guys... all of this is really useful stuff
02:02:56 <Yuu-chan> Btw... how do you have different types of events in a single stream?
02:03:06 <Yuu-chan> :t compare
02:03:07 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
02:03:56 <sgk284> Yuu-chan: It's just a list of Events
02:04:06 <sgk284> which have a time
02:04:33 <sgk284> and I just want to filter the events by subscriptions if the subscription topic matches the event topic and the event time is >= the subscription time
02:04:34 <Yuu-chan> Oh, and you have some Subscription and need to filter Events with it, right?
02:05:05 <sgk284> so I'd like to to: filter (>= subscription) events
02:05:29 <sgk284> but then I'd need to someone get a `compare` function that takes two different types
02:05:37 <sgk284> someone=somehow
02:05:48 <sgk284> and is an instance of Ord
02:06:01 * sgk284 thinks I'm getting the vocabulary right...
02:06:08 <Yuu-chan> sgk284: I got it :) In that case the simplest solution is to write a custom comparator, like quicksilver proposed
02:06:15 <sgk284> sounds good
02:06:18 <sgk284> thanks guys!
02:06:28 <Yuu-chan> sgk284: you're welcome :)
02:06:45 <sgk284> I can't believe how useful this channel was. I think I'll lurk around a bit and see what else I can learn
02:08:04 <dottedmag> Is there a list of topics to study to understand research papers about Haskell?
02:08:40 <Yuu-chan> dottedmag: category theory :))
02:08:44 <Botje> do you have any papers in mind?
02:08:56 <Botje> I found most of them to be understandable with only knowledge about haskell
02:09:13 <dottedmag> E.g. Damas, Milner "Principal type-schemes for functional programs"
02:09:18 <Botje> uh
02:09:18 <Botje> yeah
02:09:20 <thothstriangle> whats the topic here?
02:09:22 <t7> upside down U is intersection right?
02:09:23 <Botje> that's not a research paper about haskell :)
02:09:27 <Botje> t7: yes.
02:09:41 <dottedmag> Botje: It's a prerequisite to many.
02:09:55 <Botje> dottedmag: that one is quite heavy-handed.
02:10:02 <Botje> dottedmag: have you tried 'typing haskell in haskell' first?
02:11:34 <dottedmag> Botje: looking at it. Looks much less cryptic, but my ultimate goal is to refresh memories from university, given most of the stuff in Haskell research papers seem pretty familiar, but long forgotten.
02:12:12 <Botje> they don't mention algorithm W directly, but it will give you a feel for type inference i guess.
02:12:49 <dottedmag> [Not even saying that Russian logic/mathematics community has a distinct dialect, which does not help to understand stuff]
02:13:07 <Botje> but jargon is fun!
02:14:18 <t7> @hoogle (a -> [b]) -> [a] -> [b]
02:14:19 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
02:14:19 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
02:14:19 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
02:15:16 <t7> @pl \f x -> setJoin $ Set.map f x
02:15:16 <lambdabot> (setJoin .) . Set.map
02:15:39 <Taneb> @pl \f x -> g f x
02:15:40 <lambdabot> g
02:15:46 <Taneb> @pl \f x -> g x f
02:15:46 <lambdabot> flip g
02:15:57 <Yuu-chan> Botje: it's not fun when there aren't conventional translations for a whole bunch of specific CS terms :(
02:16:36 <Botje> I never understood why people translate CS terms.
02:17:08 <Yuu-chan> Botje: like all other sciences terms.
02:18:24 <Botje> but people don't go around translating molecule names, do they?
02:18:30 <quicksilver> dottedmag: the book TAPL gives a very good background for understanding papersl ike that
02:18:35 <Botje> or techniques named after their inventor
02:18:45 <quicksilver> dottedmag: (as well as a good background for understanding haskell type extensions)
02:18:52 <dottedmag> quicksilver: Thanks!
02:18:58 <quicksilver> it's not cheap tho :-(
02:19:09 <quicksilver> http://www.cis.upenn.edu/~bcpierce/tapl/
02:19:37 <Taneb> Botje, http://de.wikipedia.org/wiki/Sauerstoff
02:19:57 <quicksilver> Botje: it's a fair point. Really all category theory terms should be french :)
02:19:59 <solrize> i think damas milner may be in PFPL which may be a better place to get started, plus it's online
02:20:08 <solrize> @where pfpl
02:20:08 <lambdabot> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
02:20:19 <Yuu-chan> Botje: they don't. But if things titled not after some proper names, but for some more or less generic words (such as "list comprehension" or "type"/"kind"/"sort") it's rather weird to simply transliterate them
02:20:23 <Taneb> PFPL?
02:20:26 <dottedmag> quicksilver: 50$? Less than a weekly ticket for public transport here.
02:20:34 <solrize> @where pfpl
02:20:34 <lambdabot> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
02:20:58 <Botje> dottedmag: wat. I paid €50 for a month of public transport
02:21:08 <quicksilver> dottedmag: well, yes, that's less that I pay for my weekly too. But I wouldn't make a habit of taking a week of work to buy a book :)
02:21:18 <dottedmag> Botje: Oslo, Norway. Everything is ridiculously expensive here.
02:21:23 <Yuu-chan> dottedmag: a good Russian translation was published recently, it's cheaper
02:21:25 * quicksilver pays EUR600/month more or less.
02:21:46 <Botje> do you commute with a private helicopter? O_o
02:22:10 <dottedmag> Botje: 600 eur sounds like a public helicopter :)
02:22:34 <quicksilver> no, the only form of transport more expensive than private helicopter - english train.
02:22:52 <Botje> oh.
02:23:12 <sipa> what does let's say 100km train cost in england, on a weekday
02:23:14 <Yuu-chan> dottedmag: you can contact publisher, they may be able to send you a copy directly
02:23:41 <dottedmag> Amazon is fine, I think.
02:23:58 <quicksilver> sipa: if you don't book in advance, a return ticket would probably be around 35GBP. Of course there are lots of different train lines.
02:24:30 <sipa> ok, that's indeed somewhat more expensive than here (belgium)
02:24:59 <Botje> sipa: I paid €25 roundtrip brussel-hasselt
02:25:07 <Botje> and that's not much more than 100km
02:26:22 <t7> @unpl i
02:26:23 <lambdabot> i
02:26:24 <t7> @unpl id
02:26:24 <lambdabot> (\ a -> a)
02:26:41 <t7> @unpl ((.).(.))
02:26:42 <lambdabot> (\ i b c f -> i (b c f))
02:26:53 <Yuu-chan> Is "Purely functional data structures" worth buying?
02:27:05 <t7> download it and see
02:27:12 <Yuu-chan> @pl (\x y z -> x z (y z))
02:27:13 <lambdabot> ap
02:27:13 <t7> if its good buy it
02:27:36 <habyss> what is the disadvantage of using a global mvar for a common Configuration value (to store program options) versus ReaderT IO? (all of my functions which need to access this data are in IO)
02:27:59 <quicksilver> it ends up not being any more convenient, habyss
02:28:05 <quicksilver> since you have to pass the MVar around anyway
02:28:07 <t7> habyss: harder testing
02:28:11 <sipa> Botje: yes, seems it isn't much more, but still more
02:28:32 <habyss> quicksilver: no I wouldn't, since the Mvar is global: config = unsafePerformIO $ newMVar ...
02:28:40 <Yuu-chan> :t ap
02:28:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:29:33 <quicksilver> habyss: ah, well the disadvantage with that is that it's immoral and nonsensical.
02:29:49 <habyss> quicksilver: those words don't have any technical meaning
02:29:58 <quicksilver> nonsensical has a technical meaning.
02:30:06 <Botje> the PETV might hear you!
02:30:17 <quicksilver> it means, that, that construct has no defined denotation
02:30:22 <quicksilver> it "means nothing" in the semantics of haskell
02:30:27 <quicksilver> so you can't reason about it
02:30:35 <quicksilver> and you can't be sure it works.
02:30:49 <quicksilver> (and, indeed, certain optimisation options *do* break it unless you use certain compiler pragmas)
02:30:53 <shachaf> quicksilver: Is that the same as the nonsense in "abstract nonsense"?
02:30:57 <quicksilver> nope.
02:31:00 <habyss> it'll probably work most of the time, if I NOINLINE it, etc
02:32:06 <habyss> I also don't care about proving this code correct, so its denotation isn't terribly important to me. are there any other disadvantage?
02:35:37 <Yuu-chan> Aren't there some standard combinators in Parsec to parse float?
02:36:42 <habyss> they are in Text.Parsec.Token
02:37:05 <quicksilver> if you use the haskell-style lexer than you get the float lexed automatically
02:37:12 <quicksilver> at that point you can just parse it with 'read'
02:37:22 <quicksilver> although that won't be fast if you have thousands of them
02:37:39 <Yuu-chan> A neat idea, thanks quicksilver
02:38:22 <Yuu-chan> @hoogle mplus
02:38:23 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
02:39:52 <habyss> quicksilver: can you think of other disadvantages of the global MVar approach? assuming I'm not interesting in reasoning very deeply about this code, I can't think of a good reason to burden myself with the Reader types
02:40:21 <quicksilver> it's a bit less modular
02:40:46 <quicksilver> makes it harder for you to have "two copies" of your code because they've captured a global name referring to a single MVar
02:41:08 <habyss> ah, that's a good point
02:41:17 <quicksilver> and most reasonably complex monadic code ends up with a newtype'd custom monad anyway
02:41:25 <quicksilver> at which point, the Reader is no "additional burden"
02:41:30 <quicksilver> it's part of something you're already paying for
02:42:33 <habyss> right
02:51:34 <t7> :t (let id = \x -> x in id id)
02:51:35 <lambdabot> forall t. t -> t
02:51:42 <t7> :t (let id = \x -> x in id id) (let id = \x -> x in id id)
02:51:43 <lambdabot> forall t. t -> t
02:52:33 <t7> my type checker thinks you are an infinite type :|
02:52:45 <t7> order of substitutions must be wrong
02:53:37 <quicksilver> well that one is quite subtle
02:53:44 <quicksilver> compare it to:
02:53:54 <quicksilver> > (\id -> id id) (\x -> x)
02:53:55 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
02:54:17 <quicksilver> the nature of 'let' is to bind polymorphically so that the two instantiations can unify differently.
02:54:29 <quicksilver> where \ binds monomoriphically
02:54:47 <t7> I dont think my constraints set can be an unordered Set :(
02:55:03 <t7> i might aswel start from scratch
02:56:28 <srhb> My God, lenses are so nice combined with modify and State
02:57:12 <clinton> is there a "sizeof()" in GHC?
02:57:14 <shachaf> Which kind of lenses?
02:57:17 <clinton> or GHCI?
02:57:22 <shachaf> clinton: Storable has a sizeof.
02:57:49 <srhb> shachaf: Um, Data.Lens
02:57:53 <clinton> shachaf: Thanks
02:58:47 <shachaf> srhb: Data.Lens is passé, I hear.
02:58:51 <quicksilver> clinton: but Storable's sizeof probably isn't what you want.
02:58:53 <quicksilver> what did you want?
02:59:11 <quicksilver> Storable's sizeof tells you what size things are when stored under the C ABI (only for things which it knows about)
02:59:22 <shachaf> clinton: What quicksilver said.
02:59:36 <shachaf> srhb: Control.Lens is the new thing.
02:59:50 <clinton> well, I'm doing some work that involves a lot of, I guess "records"
03:00:01 <srhb> shachaf: Oh, is it?
03:00:08 <clinton> basically key => value mappings where the keys are known at compile time
03:00:11 <srhb> shachaf: QQ, and I was feeling so clever.
03:00:17 <MostAwesomeDude> srhb: Same author.
03:00:30 <MostAwesomeDude> srhb: Data.Lens is pretty snazzy, but Control.Lens is even more so.
03:00:48 <shachaf> srhb: data-lens was too simple. Control.Lens will have you scratching your head in no time!
03:01:03 <clinton> I want functions to have optional parameters and complusory parameters, and throw errors at compile time if particular parameters are missing
03:01:08 <srhb> Wow, sounds like a perfect tradeoff. More snazz and less understanding. :-)
03:01:54 <srhb> "For a longer description of why you should care about lens families, and an overview of why we use 4 parameters a, b, c, and d instead of just 2, see [...]"
03:02:00 <clinton> I was tossing up between "Data.Has", tuples, or maybe something else for building and storing these
03:02:01 <srhb> YES! MORE PARAMETERS!
03:03:44 <clinton> so I was hoping to gain some insight into how various structures were stored
03:04:04 <clinton> e.g. are "empty" elements of tuples stored.
03:04:15 <shachaf> clinton: OK, sizeof is almost definitely not what you want.
03:04:30 <clinton> perhaps you could help with the main issue?
03:04:44 <clinton> which is, what sort of structure to use?
03:05:38 <shachaf> I'm not sure what you're doing.
03:05:41 <clinton> Data.Has seemed to be the way to go, but it doesn't seem to have a function which can check if the record has a particular element
03:06:18 <clinton> shachaf: I'm trying to build a key => value mapping, but the keys are done at compile time
03:06:29 <clinton> so they can be checked by the type system
03:06:48 <quicksilver> I think oleg did something like this clinton
03:07:38 <clinton> quicksilver: can you link me?
03:07:47 <quicksilver> trying to find it
03:09:20 <quicksilver> clinton: http://okmij.org/ftp/Haskell/types.html#HList but that's not very specific
03:09:37 <quicksilver> I thought there was something quite specifically like what you asked for but I can't remember what it was called if so
03:10:53 <quicksilver> clinton: perhaps also some of the links at http://www.haskell.org/haskellwiki/Extensible_record
03:11:19 <clinton> quicksilver: this looks roughly what I'm looking for, but its hard to work out where to start from the 20 sub modules
03:11:26 <clinton> is there a hlist tutorial?
03:12:07 <quicksilver> there is a paper (Are some papers)
03:12:53 <mysticc> @hoogle while
03:12:54 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:12:54 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
03:12:54 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
03:12:57 <mysticc> @hoogle whileM
03:12:57 <lambdabot> No results found
03:13:02 <mysticc> @hoogle forM
03:13:02 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
03:13:03 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
03:13:03 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
03:20:47 <srhb> shachaf: You're right, Control.Lens is much more complicated to use!
03:21:25 <shachaf> srhb: Is it?
03:21:35 <shachaf> srhb: https://github.com/ekmett/lens/wiki/Tutorial
03:23:36 <srhb> shachaf: My bad, I assumed ^= would do the same thing as in Data.Lens
03:24:06 <shachaf> srhb: Ah, no, the operators are different.
03:24:20 <shachaf> Note that you don't need (Control.Category..) etc. -- you can just use (.)
03:24:26 <neuro_> can someone help me with this probably simple parsing problem? http://hpaste.org/72902
03:25:33 <shachaf> neuro_: You probably want to add endOfInput to the end of your parser, or something along those lines.
03:26:05 <shachaf> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-ParserCombinators-Parsec-Combinator.html#v:eof
03:26:48 <RichyB> I'd make parseExpr = (parseString <|> parseNumber) >> eof
03:29:06 <fmap> neuro_: if it's from "write youself a scheme" (looks like) you probably don't want parser to fail on "3 3"
03:30:12 <neuro_> RichyB, shachaf: thank you; RichyB: this does not seem to work: Couldn't match expected type `Value' with actual type `()'
03:30:17 <saep> (parseString <|> parseNumber) <* eof
03:32:18 <neuro_> fmap: um yes it is, I did not really understand how "parseList" from this tutorial works, and I thought for nested expressions I could first try to look if theres only a string or only a real number (such as "333" and not "3 3") if there is not, I can try to parse everthing by invoking parsers on the strings, separated  by the whitespaces
03:34:08 <t7> how to i ByteString -> Lazy.ByteString and vise versa >
03:34:13 <t7> ?
03:34:40 <shachaf> fromChunks, toChunks
03:36:25 <neuro_> saep: thanks
03:38:40 <t7> shachaf: to i have to concat those?
03:39:34 <shachaf> t7: Yep.
03:39:48 <t7> and how to get a lazy bs again?
03:39:50 <shachaf> A lazy ByteString is more or a less a list of strict ByteStrings.
03:39:53 <t7> toChunks?
03:39:56 <shachaf> Yep.
03:40:49 <sipa> :t toChunks
03:40:50 <lambdabot> Not in scope: `toChunks'
03:40:55 <fmap> neuro_: well, to parse list like "(3 3)" you need to parse '(', parse number, skip spaces, parse number, parse ')' - which is `List <$> (char '(' *> sepBy parseExpr spaces <* char ')'' from tutorial (maybe in tutorial it's more monadic than applicative, i don't quite remember)
03:41:00 <sipa> @hoogle toChunks
03:41:01 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
03:41:01 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
03:41:01 <lambdabot> Data.Text.Lazy toChunks :: Text -> [Text]
03:41:21 <fmap> anyway, there isn't much sense in failing on "3 3"
03:41:39 <t7> BS.fromChunks . return {- to list -}  . hash . SBS.concat . BS.toChunks
03:41:50 <t7> BS = lazy SBS = strict
03:42:01 <t7> am i doing it right.jpg
03:42:39 <quicksilver> sounds like it would be much better to get a hash function which works on lazy bytestrings
03:42:40 <srhb> Isn't there a "modify" thingy for Control.Lens? If I want to use some function on a specific field to give me a new value with only that modified?
03:42:46 <quicksilver> SBS.concat in particular is expensive.
03:42:55 <t7> i might aswel write my own
03:42:58 <quicksilver> (if your bs is long in the first place. If it's short then who cares)
03:43:09 <t7> allready had to write my own ECDSA
03:43:33 <t7> oh there is a hashlazy function
03:43:36 <t7> silly me :)
03:45:28 <quicksilver> for hash algorithms with a suitable combine it should be foldl' hashCombine . map hash
03:45:54 <quicksilver> then at least you're hashing one chunk at a time which should be much more sensible performance
03:48:02 <mietek> Can anyone offer a motivating example for the use of monad stacks?
03:48:28 <mietek> I'm reading the monad transformer chapter of RWH, and I'm unconvinced that using transformers is an improvement
03:49:40 <identity> mietek: It does of course depend on what you are writing
03:50:05 <identity> but an example.. Well, what about WriterT + IO? Getting something over the network, and logging it using writer
03:51:21 <mietek> identity: so this is the first example in chapter 18. The supposed gain is that you can use "tell" instead of explicitly tracking the return value.
03:51:32 <srhb> aha. adjust / (%~) was what I was looking for
03:51:53 <mietek> identity: I'm not sure if this outweights the noise introduced by "liftIO"
03:51:57 <srhb> What a weird choice for operator.. Why not $~?
03:52:53 <shachaf> srhb: %= is used in State, %~ for regular use of the function.
03:53:13 <srhb> Hmm.
03:53:21 <srhb> So I can actually skip modify entirely
03:53:28 <identity> mietek: Give me a sec. phone
03:53:33 <shachaf> Right.
03:53:36 <mietek> identity: OK
03:53:40 <srhb> Oh wow, that is excellent.
03:53:47 <shachaf> See the example at the end of that tutorial link.
03:53:49 <srhb> I now agree that Control.Lens is cool. :-)
03:54:27 <shachaf> srhb: Data.Lens has operators for working with State too, of course.
03:54:31 <shachaf> http://hackage.haskell.org/packages/archive/data-lens/2.10.2/doc/html/Data-Lens-Lazy.html
03:54:48 <quicksilver> srhb: it's a pun.
03:54:54 <srhb> shachaf: I guess I just didn't run into those - but now I can operate Control.Lens in a trivial fashion, that's enough for me :-)
03:55:06 <quicksilver> srhb: "%" is the 'mod' operator in C, and here it's used to 'mod'ify.
03:55:12 <srhb> Aaah, of course.
03:55:16 <srhb> Neat, a mnemonic :-)
03:55:19 <quicksilver> :)
03:55:39 <shachaf> quicksilver: It's actually the `rem` operator!
03:56:01 <mietek> quicksilver: ugh
03:56:05 <quicksilver> shachaf: hush :)
03:56:30 <shachaf> quicksilver: (Is that pun due to edwardk or is that you?)
03:57:00 <Taneb> How does Control.Lens mesh with State?
03:57:09 <quicksilver> it's not me, that's for sure.
03:57:12 <t7> fromEnum 'a' :: Word8
03:57:16 <t7> > fromEnum 'a' :: Word8
03:57:17 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
03:57:17 <lambdabot>         against inferred type...
03:57:28 <identity> mietek: Well, if you actually wrote code that tracked the "logging part" on top of the IO monad, it would amount to quite a good deal of noise in your code
03:57:30 <quicksilver> I saw some explain the pun here but I'm not sure whose idea it was.
03:57:43 <quicksilver> > fromIntegral (fromEnum 'a') :: Word8
03:57:44 <lambdabot>   97
03:57:47 <quicksilver> t7: ^^
03:57:58 <identity> But WriterT is just one example. StateT is another, and that would amount to even more code.
03:57:58 <quicksilver> (fromEnum is not polymorphic in it's *return* type)
03:58:13 <identity> And, by doing so, you would basically be replicating the respective transformer monads
03:58:27 <identity> brb for 2 mins.
03:58:45 <t7> Lazy Bytestring isnt an IsString :|
03:59:01 <shachaf> t7: For good reason!
03:59:06 <shachaf> It's not a string.
03:59:14 <shachaf> It holds bytes, not characters.
03:59:21 <quicksilver> It could be an IsWord8Vector
03:59:25 <srhb> Basically it looks like lenses should always be derived if I ever want to "use" records. Even without nested records it seems much cleaner to work with. Is there a disadvantage?
03:59:27 <quicksilver> if that class existed :)
03:59:28 <t7> there is a ByteString IsString though, right?
03:59:47 <shachaf> t7: No.
03:59:53 <srhb> Now if only records had proper namespaces..
03:59:54 <shachaf> (Yes, but it's hidden away in a module you shouldn't use.)
04:00:06 <t7> @hoogle Text -> ByteString
04:00:07 <lambdabot> Data.Text.Encoding encodeUtf16BE :: Text -> ByteString
04:00:07 <lambdabot> Data.Text.Lazy.Encoding encodeUtf16BE :: Text -> ByteString
04:00:08 <lambdabot> Data.Text.Encoding encodeUtf16LE :: Text -> ByteString
04:00:19 <shachaf> @hoogle+
04:00:20 <lambdabot> Data.Text.Lazy.Encoding encodeUtf16LE :: Text -> ByteString
04:00:20 <lambdabot> Data.Text.Encoding encodeUtf32BE :: Text -> ByteString
04:00:20 <lambdabot> Data.Text.Lazy.Encoding encodeUtf32BE :: Text -> ByteString
04:00:21 <shachaf> @hoogle+
04:00:21 <lambdabot> Data.Text.Encoding encodeUtf32LE :: Text -> ByteString
04:00:21 <lambdabot> Data.Text.Lazy.Encoding encodeUtf32LE :: Text -> ByteString
04:00:22 <lambdabot> Data.Text.Lazy.Encoding encodeUtf8 :: Text -> ByteString
04:00:27 <shachaf> Just look at all those functions!
04:00:27 <Taneb> @info ByteString
04:00:28 <lambdabot> ByteString
04:00:43 <shachaf> t7: All of those are valid Text -> ByteString functions.
04:02:14 <t7> No instance for (Data.String.IsString Data.Text.Lazy.Internal.Text)
04:02:48 <shachaf> t7: Hmm, Data.Text ought to have an IsString instance.
04:03:42 <shachaf> There's one defined here...
04:03:46 <shachaf> Maybe you're using an old version.
04:04:03 <t7> Versions installed: 0.11.2.0
04:04:40 <quicksilver> perhaps the instance is only for strict text?
04:04:43 <quicksilver> I don't know, though.
04:05:03 <shachaf> Nope.
04:05:03 <shachaf> instance IsString TL.Text -- Defined in `Data.Text.Lazy'
04:05:24 <t7> ah my bad
04:05:31 <t7> was using Text non lazy above
04:05:37 <t7> sorry sorry
04:10:53 <t7> i need some test cased for ECDSA with sha256 now
04:11:12 <t7> whats the bitcoin curve
04:11:47 <sipa> secp256kq
04:11:58 <sipa> secp256k1, sorry
04:14:19 <t7> oh yeah its a koblitz curve
04:14:38 <t7> my code is gonna be really slow relative to ones that take advantage of that :(
04:15:09 <t7> well i dont use any optimizations at all
04:15:14 <t7> and i use affine coords
04:16:05 <Jafet> Just blame integer-gmp for everything
04:16:32 <sipa> openssl does not take advantage of it, by the way
04:16:42 <t7> I will say my goal is readable code rather than speed
04:16:46 <t7> which is kinda true
04:16:52 <Jafet> Like not having mpz_gcd
04:17:02 <Jafet> Or more relevantly extgcd
04:21:25 <mysticc> I am using ByteString getLine and when I press backspace in stdin it print ^? instead of deleting .. similarly with arrow keys ?
04:21:45 <quicksilver> line editing is not an inherent feature of getLine
04:21:57 <mysticc> quicksilver: Then ?
04:22:05 <quicksilver> getLine is just simple reading from a fildescriptor.
04:22:12 <quicksilver> use a line-editing library
04:22:20 <quicksilver> haskeline maybe? I've never used it.
04:22:26 <mysticc> quicksilver: I have to make an interactive program .. ok
04:22:32 <quicksilver> (also you shouldn't be using a ByteString for interactive input)
04:22:44 <Jafet> I think you use haskeline whenever you use ghci
04:23:03 <quicksilver> Jafet: well, I meant I've never used it as a programmer :)
04:23:44 <t7> sipa you know which file this is defined in?
04:23:53 <t7> in the bitcoin repo?
04:24:55 <shachaf> quicksilver: You don't program with ghci?
04:25:51 <sipa> t7: key.cpp
04:26:32 <Jafet> Glasgow Haskell calculator instrument
04:27:08 <quicksilver> shachaf: I mean, I've never myself written an interactive program using the facilities of haskeline to enable line editor.
04:27:21 <quicksilver> (talking to you guys is like pulling teeth sometimes!)
04:27:43 <quicksilver> I've written my own inferior line editors a few times.
04:29:35 <t7> NID_secp256k1 i guess this is in openssl somewhere
04:29:37 <shachaf> I don't like haskeline.
04:29:44 <sipa> t7: yes
04:29:49 <shachaf> It breaks compatibility with readline in awkward ways.
04:30:05 <sipa> t7: but the sec2 standard specifies the curve well
04:30:46 <t7> sipa im reading the pdf, and for G it has a bit integer that (/ 2) /= 256
04:30:55 <t7> but G is supposed to be a point (x & y)
04:31:12 <sipa> hmm?
04:31:30 <t7> the other curve definitions i have seen define x and y for G
04:32:03 <E0F> Hi, I'm a beginner to Haskell and I was rewriting a trivial prime test function trying to make it tail recursive so ghc can perform tail-call optimization and unroll it as a loop. Can someone tell me wether or not my function is tail-recursive ? it's tellisPrime : http://hpaste.org/72903
04:32:49 <shachaf> E0F: Haskell is a pretty different language from those you might be used to, and tail recursion in particular is not always what you want.
04:33:07 <sipa> t7: it gives G in compressed and uncompressed coordinates
04:33:29 <sipa> 0x04 + 32-byte BE x-coord + 32-byte BE y-coord
04:33:37 <sipa> is the uncompressed encoding
04:33:37 <t7> ah i just strip the 04
04:33:43 <E0F> shachaf: I heard lazy evaluation made it tricky to tell if tail-recursion was useful, is that it ?
04:33:48 <t7> ok cheers
04:33:53 <shachaf> Yes.
04:33:57 <shachaf> Well, part of it.
04:34:32 <E0F> hum ok. But from a theoretical point of view, is my function tail recursive ?
04:35:12 <sipa> E0F: yes
04:35:21 <shachaf> It looks tail-recursive, yes.
04:35:37 <shachaf> You can simplify it, by the way.
04:35:46 <E0F> Thanks, I wanted to be sure. I was having a bit of trouble making tail recursions
04:35:55 <E0F> shachaf: how ?
04:37:59 <neuro_> http://hpaste.org/72905 : I would like to parse "3 3" into "List [Number 3, Number3], what is wrong with the code?
04:38:52 <fmap> E0F: don't use tab characters, btw, it would lead to confusing errors
04:38:53 <shachaf> neuro_: You have that eof in parseExpr
04:39:29 <E0F> fmap: thank you for the advice, i'll set vim to use spaces
04:39:42 <E0F> is there a preferred number of spaces for one tab ?
04:39:55 <shachaf> E0F: Maybe something like this? tellisPrime x curr = curr*curr > x || (x `mod` curr /= 0 && tellisPrime x (curr + 2))
04:40:16 <frerich> E0F: 2, 4 and 8 are common values
04:40:18 <neuro_> shachaf: I want to use eof there because I want to make sure that "3 3" does not yield "3"
04:40:25 <shachaf> You can expand it out with guards or something if that's too dense.
04:40:43 <shachaf> neuro_: eof means "end of input".
04:41:08 <int-e> _f_ile
04:41:17 <E0F> frerich: Ok, I was asking because, in python for instance, good practices are to use 4 spaces so maybe there's something similar in haskell
04:41:51 <E0F> shachaf: good idea thank you
04:42:56 <neuro_> shachaf:I thought this means that number tries to read the whole strings until the end of the input... if it fails then, the parser parseList is invoked to the string, this is not the case?
04:44:15 <shachaf> neuro_: Sort of but not really -- it'll fail but still consume the input, I think.
04:44:28 <shachaf> But the bigger issue is that parseList just goes right back to parseExpr.
04:44:39 <Yuu-chan> How to simplify case (smth :: Maybe a) of Nothing -> return () | Just val -> (fun :: a -> IO ()) val ?
04:44:50 <shachaf> Which will presumably try to use parseNumber, not find an eof, fail, etc.
04:45:03 <shachaf> @ty maybe
04:45:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:45:08 <shachaf> @ty maybe (return ())
04:45:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
04:45:23 <shachaf> @ty maybe (return ()) (?fun :: a -> IO ())
04:45:25 <lambdabot>     Could not deduce (?fun::a -> IO ()) from the context ()
04:45:25 <lambdabot>       arising from a use of implicit parameter `?fun'
04:45:26 <lambdabot>                    at <interactive>:1:19-22
04:45:39 <shachaf> Anyway, that.
04:45:46 <shachaf> @ty maybe (return ()) ?fun :: IO ()
04:45:47 <lambdabot>     Couldn't match expected type `IO ()'
04:45:47 <lambdabot>            against inferred type `Maybe a -> m ()'
04:45:47 <lambdabot>     In the expression: maybe (return ()) ?fun :: IO ()
04:45:57 <Yuu-chan> shachaf: thanks
04:45:59 <shachaf> Hah, right. Anyway.
04:46:14 <mrotondo> Anyone here have much experience building ghc? I'm having trouble getting stage 2 to build.
04:47:32 <neuro_> shachaf: but by saying "sepBy parseExpr spaces" I think that parseExpr is called with every segment of the string which is seperated by whitesapces, therefore I think it is ok to use parseExpr with the number-parser again then
04:47:59 <shachaf> neuro_: No, "eof" means the end of the input as a whole, I'm pretty sure.
04:48:09 <shachaf> mrotondo: If you have a question you should probably ask it. :-)
04:48:40 <shachaf> mrotondo: Also, you should say what the error is instead of "nothing different happens". :-)
04:48:57 <mrotondo> Yeah, my question is: I can't get stage 2 to build :) I've tried "make stage=2" as suggested here: http://hackage.haskell.org/trac/ghc/wiki/Building/Using, but nothing (especially not ghc-stage2) shows up in inplace/bin
04:49:45 <mrotondo> I've only just gotten stage 1 to build, but I need stage 2 + an interpreter to build template haskell stuff
04:50:31 <shachaf> Did just plain "make" not work?
04:50:40 <shachaf> "nothing shows up" isn't really an error message.
04:51:10 <neuro_> shachaf: But when I say "do parseNumber <* eof ; <|> parseString" and call it with "\"a\"" parseString parses the "a" ... isn't this a contradiction to that eof consumes the whole input?
04:51:36 <shachaf> neuro_: eof doesn't consume anything.
04:52:51 <neuro_> shachaf Did you not say so at 13:43?
04:53:07 <mrotondo> shachaf: no, plain make doesn't work. I'm using the ios branch that some folks have been working on: https://github.com/ghc-ios/ghc. I was mainly hoping that there would be some obvious step I need to do to build stage 2, but it sounds like make should've done it, so I'll keep digging
04:53:39 <shachaf> neuro_: No, parseNumber will consume the input it consumes.
04:53:57 <shachaf> mrotondo: "I'm using the ios branch" is also one of those things that's good to mention. :-)
04:54:19 <Yuu-chan> @hoogle [a] -> [[a]] -> [a]
04:54:21 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
04:54:21 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
04:54:21 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
04:54:41 <mrotondo> :P
04:54:56 <neuro_> ok, then let parseNumber consume the input. anyway, this seems contradictory to me
04:59:57 <fmap> neuro_: do you have an infinite loop with your code?
05:00:13 <neuro_> fmap: no
05:00:32 <fmap> interesting
05:03:02 <shachaf> It sounded like you did.
05:03:06 <shachaf> But who knows.
05:03:13 <shachaf> I think you should read more about how these parsers work.
05:05:06 <neuro_> Maybe something with "sepBy parseExpr spaces" is wrong and it does not filter out the whitespaces?
05:05:13 <neuro_> shachaf: I agree :)
05:05:21 <shachaf> No, the wrong thing is with parseExpr.
05:05:24 <shachaf> Namely, the eof.
05:06:22 <neuro_> Why parsing "\"a\"" works then? With "parseExpr = do parseNumber <* eof ; <|> parseString"
05:07:08 <shachaf> That looks like a syntax error.
05:07:34 <neuro_> You know what I mean, don't you?
05:07:52 <shachaf> I'm not sure that either of us does.
05:08:22 <shachaf> In (parseNumber <* eof) <|> parseString, (parseNumber <* eof) is failing, and then parseString is succeeding.
05:08:33 <Yuu-chan> :t when
05:08:35 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:09:01 <fmap> what I don't is why this parser terminates since it looks left recursive
05:09:02 <mysticc> What data structure should I use for a one to one relation such that if a -> b then b -> a ... so that I can search both ways
05:09:20 <fmap> don't get*
05:09:55 <shachaf> mysticc: I think Hackage has "BiMap"?
05:10:03 <shachaf> @google haskell bidirectional map
05:10:04 <lambdabot> http://hackage.haskell.org/packages/archive/bimap/0.2.1/doc/html/Data-Bimap.html
05:10:04 <lambdabot> Title: Data.Bimap
05:11:06 <neuro_> shachaf: so if parseString consumes the whole string too, then should parseList do so as well, that's whay I guess eof is not the problem here
05:12:42 <Yuu-chan> Why browse or request in Network.Browser writes some debug info to the console and how to turn it off?
05:13:19 <fmap> neuro_: you can't successgully parse number that isn't at the end of input with `parseNumber <* eof'
05:21:41 <fmap> oh, i see why it terminates
05:23:17 <neuro_> fmap: can you tell us what you see? :)
05:23:54 <fmap> neuro_: parseString works because parseNumber fails without consuming any output, parseList isn't even started since parseNumber consumes first "3"
05:24:42 <fmap> see http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Prim.html#v:-60--124--62-
05:26:19 <srhb> does import foo as bar ever makes sense without qualified?
05:27:00 <Athas> srhb: yes, because you'll still be able to use Bar.whatever.
05:27:25 <srhb> But I can also just use whatever, which may or may not be ambiguous?
05:27:33 <nand`> but if it is you'd have to qualify it
05:27:38 <fmap> srhb: yes, when you want to re-export bunch of modules
05:27:49 <Athas> Yes, it'll be ambiguous if you don't qualify.
05:27:49 <neuro_> fmap: could you tell me why parseNumber on the hand does not consume any input, and on the other hand consumes "3"?
05:27:58 <srhb> Okay.
05:28:04 <nand`> omitting the ‘qualified’ doesn't force you to qualify it, but you still can when it ends up colliding
05:28:10 <nand`> (using that particular prefix)
05:28:13 <srhb> Ah yes, okay.
05:28:13 <neuro_> I mean the code is the same, parseString is just replaced by parseList
05:28:18 <Athas> Remember that name clashes happen when the names are *used*, not when they are imported.
05:28:23 <Athas> This is different from many other languages.
05:28:25 <t7> how do i set overloaded string in ghci again?
05:28:35 <nand`> same as instances
05:28:35 <srhb> Athas: Yes, right, that was exactly what I was confusing.
05:28:39 <nand`> it's pretty useful actually
05:28:50 <nand`> I guess Haskell's collision checker is.. lazy!
05:29:01 <Athas> It's the only kind of late binding we have!
05:29:33 <fmap> neuro_: parseNumber is `many1 digit <* eof'. when you give it "a" it fails instantly, when you give it "3 3", `many1 digit' eats 3
05:30:14 <fmap> and then fails on `eof'
05:30:34 <neuro_> fmap: ah yes, thanks
05:30:34 <neuro_> hm
05:30:59 <neuro_> so it is really eof why parseList does not work?
05:31:02 <srhb> If I want to make a gameLoop which operates on a state based on IO.. Will I need to stack monads?
05:31:10 <srhb> based on IO input, rather
05:31:28 <fmap> neuro_: what is eof?
05:32:01 <neuro_> I think it forces the parser to consume the whole string
05:32:07 <fmap> in "3 3" there is only one eof, and you need two to parse two numbers
05:33:12 <fmap> eof doesn't force parser to consume anything
05:33:30 <Athas> srhb: you might, yes.
05:33:35 <Athas> You never "need" anything.
05:33:44 <Athas> You could keep the state in MVars too, although I wouldn't recommend it.
05:34:38 <Athas> You'll probably need a monad stack consisting of a Reader, a State, some kind of error handling, and IO at the bottom.
05:35:00 <Athas> That's a typical setup for control-loop based programs that need to do IO.
05:35:28 <neuro_> fmap: ok, I need two, that is why I want to use parseList to split the "3 3" up into "3" "3"
05:35:34 <srhb> Athas: I think I could get away with State and an IO Monad, though it might not be the cleanest. I think I'll give that a shot first since transformers are already a bit confusing for me.
05:35:36 <neuro_> and apply the parser
05:36:05 <srhb> Athas: (Thanks for handing me "control-loop" as a concept. :D)
05:36:37 <fmap> neuro_: sepBy doesn't split anything
05:36:48 <Yuu-chan> Guys?
05:37:51 <Athas> srhb: you're really going to need a Reader as well, to store handles for whatever you're doing IO with.
05:38:01 <fmap> neuro_: `sepBy p sep' is roughly "eat p, eat sep, eat p, ..."
05:38:10 <Athas> It's ugly to put things in State that are not supposed to ever change.
05:38:56 <srhb> Athas: Ah, I see. I thought I would be able to have a recursive loop that just passed the handle to each successive call
05:39:01 <srhb> As a parameter.
05:43:58 <quicksilver> you can do that too
05:44:16 <quicksilver> there really isn't a difference between passing the handle to each recursive call and a Reader monad
05:44:31 <quicksilver> well, there is a difference in what you have to write in practice :) but it's the same effect.
05:46:46 <Athas> Right, it's just cleaner and easier to extend with a Reader monad.
05:49:17 <quicksilver> there is something to be said for doing it one way and refactoring to the other way
05:49:22 <quicksilver> from a learning experience point of view
05:52:23 <srhb> I actually already dit it in an entirely explicit state passing kind of way, so I was trying to bind it together with State now. It does seem like the middle ground is not really there :P Either you do StateT or you don't do State at all in this case.
05:53:46 <E0F> which is more haskellish : building a list using list comprehension then summing it, or using a (tail ?) recursive function to sum without building a list in memory ?
05:54:02 <E0F> I found the second option to be faster but slightly less elegant
05:54:34 <nand`> E0F: I'd go with the former and rely on GHC to fuse/deforest for me
05:55:06 <frerich> E0F: What does the list comprehension look like?
05:55:46 <E0F> I tested both, using a tail-recursive function made me gain some dozens of miliseconds
05:56:01 <E0F> wait i'll show u both
05:56:39 <frerich> E0F: the usual disclaimer applies: make sure you're profiling with optimizations enabled.
05:57:14 <Botje> E0F: haskell shoudldn't build an intermediate list.
05:58:02 <hpaste> E0F pasted “List comprehension vs recursion” at http://hpaste.org/72907
05:58:42 <nand`> I would go with the former over the latter solely for the reason that I can understand what the former is doing at a quick glance
05:59:19 <parcs`> E0F: why not use filter isPrime (2:[3,5..20000000]) ?
05:59:21 <E0F> Botje: that's what I thought but actually the recursive version has a best running time of ~1.300 seconds while the list comprehension rarely runs below 1.345 seconds
05:59:37 <E0F> parcs`: I tried it and it didn't make any difference i think
06:00:02 <nand`> I wouldn't worry too much about those few milliseconds, the gain is not worth the clarity you lose
06:00:03 <luite> E0F: did you compile with -O2 ?
06:00:17 <Botje> @src sum
06:00:18 <lambdabot> sum = foldl (+) 0
06:00:29 <E0F> luite: ghc --make -O3 -fllvm -optlo-O3 -msse2 -fexcess-precision -optc-ffast-math -optlo-loop-unswitch
06:00:30 <Botje> E0F: can you replace sum by foldl' (+) 0 ?
06:00:37 <mauke> -O3 is wrong
06:00:42 <E0F> ok let's try it
06:01:01 <parcs`> gentoo user? :P
06:01:11 <frerich> I think you're profiling at a level which is so low that the results may be very different with any new ghc release.
06:01:13 <quicksilver> does -optc-ffast-math mean anything in combination with the llvm backend?
06:01:20 <Botje> there's no -funroll-loops yet ;)
06:01:29 <quicksilver> I thought optc-ffast-math was for the old via-c backend
06:01:43 <E0F> mauke: why ?
06:01:55 <E0F> parcs`: Fedora actually (if you were talking to me)
06:02:11 <luite> E0F: llvm may not be faster, although that part of the code generator runs well after the inliner and demand analysis, so ncg or llvm wouldn't make a difference in constructing an temporary list or not
06:02:25 <mauke> E0F: because there is no -O3 option
06:02:44 <luite> doesn't it use -O2 if you run it with -O3?
06:02:46 <parcs`> E0F: the ghc optimization level is clamped between [0..2]
06:02:55 <mauke> luite: yes
06:03:01 <parcs`> and -O2 implies -opt-O3
06:03:06 <parcs`> -optlo*
06:03:16 <mauke> luite: do you remember when that started? 6.6?
06:04:13 <E0F> changing sum by fold didn't have much effect on timing
06:04:26 <luite> mauke: no, i don't think i programmed haskell back then
06:04:47 <luite> earliest ghc i remember using is 6.8 or 6.10
06:05:12 <mauke> before they explicitly clamped it to [0 .. 2], -O3 used to set some bits equivalent to something between -O0 and -O1
06:05:29 <luite> oh that's interesting :)
06:05:47 <E0F> so I should use O2 instead of O3 then ?
06:06:07 <t7> i think theres a bug in Data.ASN1.DER
06:06:27 <luite> E0F: if you want to do it right, yes, but it won't make a difference :)
06:07:02 <E0F> ok, and should I try with -fasm instead of -fllvm ?
06:07:16 <luite> that's the default
06:07:17 <E0F> I found the llvm backend to be sometimes slower
06:08:00 <E0F> but maybe llvm has more optimizations
06:11:02 <E0F> ok, llvm is faster in this case when optimized, however it is slower without any optimizations
06:12:19 <t7> VincentHanquez
06:13:56 <marcot> Is there a way to get what was parsed after the execution of a Parser () function from parsec?
06:16:36 <fmap> you want ()?
06:18:24 <Saizan> marcot means the tokens corresponding to what the parser consumed, i guess
06:18:53 <marcot> Saizan: Yes, that's right.
06:19:57 <Athas> marcot: you should make the parser action return some value instead.
06:20:02 <Athas> What is your exact use case?
06:20:26 <marcot> Athas: I want to parse e-mail address, using the code from http://porg.es/blog/email-address-validation-simpler-faster-more-correct
06:20:57 <marcot> Athas: I'm addapting it to return the parsed e-mail as String, but basically I'm getting every parsed char.
06:24:35 <marcot> If you have any suggestion for parsing e-mail with parsec, it would solve my problem even better. =)
06:27:38 <t7> @hoogle (b-> c) -> (a -> f b) -> fc
06:27:39 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
06:27:39 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
06:27:40 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
06:27:41 <t7> @hoogle (b-> c) -> (a -> f b) -> f c
06:27:42 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
06:27:42 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
06:27:42 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
06:29:09 <matthew-> right, so can someone point me at a reformulation of Monad which drops 'fail' and has fail only in some sub TC?
06:29:18 <Athas> marcot: well, that code looks fairly correct.  You just need to change it to return the various parts of the email address.
06:29:50 <marcot> Athas: Yes, that's what I'm doing.
06:32:21 <JenLoveHewitt> Would it even make sense to use monads in python
06:35:33 <nand`> I imagine that's fairly dependent on ’Would it make sense to use python’
06:35:54 <srhb> Holy hells, monad transformers are magic.
06:35:57 <srhb> Mind blown.
06:36:48 <belgin> why am I getting an error for this code? http://hpaste.org/72908 and the error: http://hpaste.org/72909
06:36:58 <marcot> Athas: It's consuming spaces after the address.  Is this supposed to be correct?
06:37:23 <Cale> JenLoveHewitt: Well, yes, except for the fact that it's hard to make anything polymorphic in only its return type
06:37:25 <nand`> belgin: probably missing a fromIntegral or two
06:37:33 <Jafet> You can't write Monad in most programming languages
06:37:37 <nand`> (did you come from lisp?)
06:37:46 <Cale> JenLoveHewitt: so ironically, 'return' ends up being difficult
06:38:06 <Cale> :t return
06:38:07 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:38:09 <belgin> no, I come from C, but I'm a beginner in all this haskell stuff
06:38:57 <Cale> Its result has type m a where m is whatever monad is demanded by context.
06:39:12 <belgin> nand`: it's the euler totient function
06:39:17 <Cale> (and a is the type of the parameter to return)
06:41:37 <nus-> @instances Fractional
06:41:38 <lambdabot> Double, Float
06:41:47 <nus> @type (/)
06:41:48 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:41:50 <nus> @type 1
06:41:52 <lambdabot> forall t. (Num t) => t
06:42:11 <nus> @type fromInteger
06:42:12 <lambdabot> forall a. (Num a) => Integer -> a
06:44:16 <nand`> belgin: reason I asked was because holy hell, so many parentheses
06:49:36 <mm_freak_> belgin: as a side note there are better ways to calculate the totient, where you don't need division
06:50:13 <Athas> marcot: I know very little about email address formats, to be honest.
06:50:15 <belgin> there probably are, but before i get there, first i need to get this working
06:56:53 <mm_freak_> belgin: you can't use (/) on integers
06:57:10 <mm_freak_> either you actually want integer division, which is called 'div' in haskell
06:57:20 <nand`> I doubt he wants (1 `div`)
06:57:23 <mm_freak_> or you want floating point division, in which case you need to convert to floating point first
06:57:54 <mm_freak_> > let x = 1 :: Integer in fromIntegral x / 4
06:57:55 <lambdabot>   0.25
06:58:07 <mm_freak_> also (1 /) = recip
06:58:10 <mm_freak_> > recip 4
06:58:12 <lambdabot>   0.25
06:58:25 <nand`> :t recip
06:58:26 <lambdabot> forall a. (Fractional a) => a -> a
06:58:29 <belgin> that's what that innermost map is for, but for some reason it didn't copy fromIntegral
06:58:35 <belgin> sorry about that
06:58:59 <mm_freak_> > map (recip . fromIntegral) [1..10]
06:59:01 <lambdabot>   [1.0,0.5,0.3333333333333333,0.25,0.2,0.16666666666666666,0.1428571428571428...
06:59:46 <nand`> note that later you multiply by n, this will also need a fromIntegral
06:59:57 <nand`> since n is an integer but the product at that point is some fractional
07:00:00 <Cale> Seems like a pretty decent use of Rational, don't use floating point :)
07:00:09 <nand`> yeah
07:00:41 <nand`> > map (recip . fromIntegral) [1..10] :: [Rational]
07:00:44 <lambdabot>   [1 % 1,1 % 2,1 % 3,1 % 4,1 % 5,1 % 6,1 % 7,1 % 8,1 % 9,1 % 10]
07:00:47 <mm_freak_> seems like a decent abuse of fractional numbers…  use another formula ;)
07:02:45 <belgin> ok now i did this: "test = truncate 20 * product . map ((1-) . recip . fromIntegral) unique . factor 20" just for the number 20 but it's telling me something about map being applied to too many arguments
07:03:26 <mm_freak_> :t product . map (liftA2 (\p e -> (p - 1) * p^(e - 1)) id length) . group
07:03:27 <lambdabot> forall a. (Num [a], Eq a) => [a] -> [a]
07:03:28 <Axman6> it;s applied to ((1-) . recip . fromIntegral) and unique
07:03:41 <mm_freak_> > product . map (liftA2 (\p e -> (p - 1) * p^(e - 1)) id length) . group $ [3, 5]
07:03:43 <lambdabot>   No instance for (GHC.Num.Num [a])
07:03:43 <lambdabot>    arising from a use of `e_121135' at <i...
07:03:51 <Axman6> but the type of (.) says it needs to be applied to another argument
07:03:58 <mm_freak_> :t product . map (liftA2 (\p e -> (p - 1) * p^(e - 1)) head length) . group
07:04:00 <lambdabot> forall a. (Num a) => [a] -> a
07:04:06 <mm_freak_> > product . map (liftA2 (\p e -> (p - 1) * p^(e - 1)) head length) . group $ [3, 5]
07:04:08 <lambdabot>   8
07:04:19 <mm_freak_> > product . map (liftA2 (\p e -> (p - 1) * p^(e - 1)) head length) . group $ [2, 2, 5, 5]
07:04:22 <lambdabot>   40
07:06:45 <nand`> ugh, no instance for Integral (a -> a) ruins my golfing again
07:07:39 <mm_freak_> nand`: Integral has toInteger, which is difficult for that type =)
07:09:25 <nand`> doesn't NumInstances just place ‘error’ on illogical functions?
07:09:41 <mm_freak_> doubt it
07:09:41 <nand`> well, it does for Eq and Show
07:10:06 <mm_freak_> note that in base 4.5 Num is not a subclass of Eq and Show
07:10:15 <ique> can someone help me look at how to optimize this code: http://hpaste.org/72910 I've been fiddling with it for like 12 hours at least now and can't make any further improvements
07:10:39 <ique> one function takes 55% of time and it only consists of a couple of guards with subtractions in them
07:11:17 <Athas> That's because it's the body of your inner loop.
07:11:24 <Athas> Look at the number of times it's being called.
07:11:26 * mekeor is loving hayoo.
07:11:49 <ique> well yeah, it's called 30m times, but this is still slow… it's about 15x slower than my reference solution in C right now
07:12:07 <ique> I would hope to achieve at least 2-4x the speed of C
07:14:25 <ique> in C it's just 3 nested for loops that run really fast, for some reason the Haskell version using zipWith and sum allocates about 1.5M memory.. using a fold instead uses no memory but then it's about 2x slower
07:14:51 <ique> i can see why zipWith uses memory, but not why a fold is so much slower
07:15:01 <Athas> ique: I'd try adding some strictness annotations.
07:15:15 <Athas> I think the 'sum . zipWith'-construction is deforested, and that's why it's faster.
07:16:43 <ique> Athas: ah yeah perhaps
07:17:23 <hiptobecubic> yes, you must be missing some fusion
07:18:39 <ique> I've tried adding strictness both with `seq` and `deepseq` in some places, but with no luck.. like on the actual swap, on the calculation of the contribution as well as a bunch of other things, but with no luck.. i've also tried a data structure for the "closestSecondClosest" pair with forced constructor arguments, didn't make a significant difference
07:19:17 <ique> btw the run-time with a 200x200 matrix is about 5 second, and about 0.3-0.4 seconds with C
07:19:52 <ique> but I'm hoping to run it with 1000-2000 sized matrices for real
07:20:51 <hiptobecubic>  how are you compiling it?
07:21:14 <ique> through cabal with: ghc-options: -Wall -O3 -prof -auto-all -threaded -rtsopts
07:21:28 <hiptobecubic> -prof and -threaded conflict at least
07:21:35 <ique> (i'm actually not using threaded anymore but tried removing it without a difference)
07:21:53 <ique> removing threaded and trying again just to see
07:21:55 * dcoutts_ notes there's no such thing as -O3
07:21:59 <hiptobecubic> but a profile build is not as fast as a normal one because it has to do magic to keep track of everything
07:22:09 <hiptobecubic> you need at least -O5
07:22:15 <Cale> -O3 used to do no optimisation at all :)
07:22:16 <hiptobecubic> maybe even 7
07:22:29 <Cale> but now the value gets clamped :)
07:22:32 <hiptobecubic> Cale, intentionally :D
07:22:33 <ique> oh.. wow, I'm used to not have to go above 2 or 3 with C :P
07:22:54 <hiptobecubic> ique, don't listen to me. i'm an idiot.
07:22:54 <Cale> ique: No, it was too high, and therefore meaningless :)
07:23:15 <dcoutts_> ique: right people often use -O2 as default with gcc, sensible default for ghc is just -O, not even -O2
07:23:20 <Cale> ique: but nowadays if you write -O3, it'll treat it like -O2 anyway
07:23:27 <ique> oh i see
07:23:32 <hiptobecubic> but do turn off profiling if you are trying to benchmark
07:23:44 <JenLoveHewitt> So, in Lisp code is data, how big do you think this idea is? Haskell obv doesn't have this-
07:24:03 <Cale> JenLoveHewitt: In Haskell we have Template Haskell for treating code as data.
07:24:22 <ique> hiptobecubic: right, re-compiling and running without profiling to see
07:25:11 <ique> hiptobecubic: that actually made quite a difference ^^ down from 5s to 1.57s
07:25:14 <hiptobecubic> ique, not that it's a good way to program in general, but when every pico second counts, there's always "strictify"
07:25:20 <hiptobecubic> ique, yes i'd expect so
07:25:37 <Cale> It doesn't get used nearly as much as macros do in Lisp, perhaps partly because TH is designed to stick out like a sore thumb when used, and partly because the syntax of Haskell is a bit more complicated than Lisp, so macros are a bit trickier to write perhaps.
07:25:38 <hiptobecubic> ique, you can't inline everything if it's trying to keep track of function calls
07:26:17 <ique> I see, right.. so now I'm in an acceptable range of 3x slower
07:26:21 <hiptobecubic> Cale, can you do just as much with it?
07:26:30 <Cale> hiptobecubic: I think so, yes.
07:27:04 <hiptobecubic> I'm not a lisper and I haven't used template haskell for anything so I'm in no position to ask any further questions :D
07:28:00 <hiptobecubic> ique, also, numeric stuff tends to benefit a lot from using the llvm backend if that's available to you
07:28:00 <ique> now my fold solution is actually faster as well, without the profiling :D down to 0.89s
07:28:05 <c_wraith> I wish TH didn't slow down compilation so much
07:28:47 <Cale> You can even do IO in macros, so it's possible to query a database and generate code from the results if you're so inclined. :)
07:28:51 <ique> hiptobecubic: on a mac right now, so I think it should be, is there a ghc flag for that?
07:28:59 <hiptobecubic> -fllvm i think?
07:29:29 <Cale> For the most part I prefer preprocessors though
07:29:48 <belgin> can someone please tell me exactly how i can fix this? "test = 20 * product . map ((1-) . recip) unique . factor 20" it tells me map is applied to too many arguments, but I don't see how
07:30:08 <mroman> belgin: Add more ( )
07:30:11 <Cale> GHC has a nice flag -F (along with -pgmF <programname>) which will filter the source code through any given program before compiling it.
07:30:25 <Cale> and you can just write ordinary source -> source translations and plug them in
07:30:35 <mroman> belgin: map ((1-) . recip) <- 1st argument unique <- 2nd argument
07:30:37 <c_wraith> belgin: well, it's applied to two arguments, and you're treating the result of that as a function...  that's too many arguments
07:30:47 <mroman> You may want
07:30:48 <hiptobecubic> with src-exts?
07:30:51 <Yuu-chan> belgin: tput $ before the last argument
07:30:53 <hiptobecubic> Cale, ^
07:30:56 <Cale> Yeah
07:31:13 <mroman> map (((1-) . recip) unique) or map (((1-).recip).unqiue)
07:31:25 <belgin> i don't know what the $ operator does yet, so i'd like to avoid using it for the moment
07:31:36 <hiptobecubic> @src $
07:31:36 <lambdabot> f $ x = f x
07:31:41 <Cale> belgin: f $ x = f x  but $ has really low precedence
07:31:55 <Cale> i.e. it's almost like you're wrapping what's on either side of it with parens
07:32:03 <mroman> a b $ c d = (a b) (c d)
07:32:14 <belgin> i see, thanks
07:32:38 <Yuu-chan> It's often used to get rid of parentheses: f(g(h(x(y(z))))) to f . g . h . x . y $ z
07:33:28 <Cale> It gets better as the ) moves farther away from its matching (
07:33:43 <Cale> So things like  withFoo $ \foo -> do ... long block of code ...
07:34:20 <dmwit> hm
07:34:21 <Cale> is much nicer than having  withFoo (\foo -> do ... long block of code ... ) -- where you have to remember the ) even though it's a long distance from the (
07:35:11 <Cale> However, I've always been a little curious why lambda isn't allowed there without some kind of delimiter.
07:35:18 <Cale> withFoo \foo -> ...
07:35:22 <belgin> so i should put it between recip) and unique ?
07:35:29 <Yuu-chan> belgin: so I guess you need "test = 20 * product . map ((1-) . recip) . unique . factor $ 20"
07:35:46 <belgin> oh i get it now
07:36:13 <Yuu-chan> ...if I got right that you need to get factors of 20, find unique, map each of them to 1-1/x, and multiply all
07:36:21 <Cale> :t \unique factor -> 20 * product . map ((1-) . recip) . unique . factor $ 20
07:36:23 <lambdabot> forall a a1 a2. (Fractional a, Num a2) => (a1 -> [a]) -> (a2 -> a1) -> a
07:36:27 <JenLoveHewitt> couldnt there be some nice syntax instead of let? like: main = do { a <-- doB } ?
07:36:58 <Cale> hah
07:36:58 <ben_____> :h
07:37:13 <Cale> Normally you'd get  (Fractional c, Num a, Num (a -> c)) => (b -> [c]) -> (a -> b) -> c
07:37:17 <dfeuer> How do you use unsafe (non-bounds-checked) operations on STArrays?
07:37:33 <Cale> unless there's an instance of Num for functions, you're not allowed to multiply a function by 20
07:38:00 <nand`> Yuu-chan: 20 * product doesn't seem valid without NumInstances
07:38:11 <nand`> I think he actually wants 20 * (product . map ((1-) . recip) . unique . factor) 20
07:38:12 <Cale> JenLoveHewitt: You don't like  let ... in ... ?
07:38:19 <c_wraith> I'm starting to really appreciate  fix :: (IO () -> IO ()) -> IO ()
07:38:32 <Cale> c_wraith: yeah, it's nice isn't it?
07:38:41 <hiptobecubic> why
07:38:54 <Yuu-chan> @let factor n = [x | x <- [1..n-1, n
07:38:55 <lambdabot>   Parse error: ,
07:38:55 <nand`> just for expressing recursive do-forms anonymously?
07:39:02 <nand`> do-blocks, rather
07:39:05 <c_wraith> nand`: yep
07:39:06 <Cale> fix $ \loop -> do ... loop ...
07:39:10 <Yuu-chan> @let factor n = [x | x <- [1..n-1], n `div` x == 0]
07:39:12 <lambdabot>  Defined.
07:39:24 <Cale> fix $ \loop x -> ... loop (x+1) ...
07:39:34 <mun> hi
07:39:34 <mun> is the term 'higher-order logic' typically used to refer to a typed or untyped logic?
07:39:49 <Yuu-chan> > 20 * product . map ((10) . recip . fromInteger) . factor $ 20
07:39:51 <lambdabot>   20
07:39:51 <c_wraith> the nice thing is that it lets you declare and call the loop at the same time...  saving a line of code.  Woo, a saved line of code!
07:40:09 <nand`> Yuu-chan: well, lambdabot has NumInstances :D
07:40:31 <c_wraith> > 1 2 3 4 5
07:40:32 <belgin> ok i did what nand` said but i'm getting something about Fractional Integers
07:40:33 <lambdabot>   1
07:40:34 <dfeuer> NumInstances?
07:40:35 <Yuu-chan> @google NumInstances
07:40:37 <lambdabot> http://hackage.haskell.org/package/NumInstances
07:40:37 <lambdabot> Title: HackageDB: NumInstances-1.0
07:40:43 <Cale> > cos^2 + sin^2 $ 5
07:40:44 <nand`> Instance Num b => Num (a -> b)
07:40:45 <lambdabot>   0.9999999999999999
07:40:46 <nand`> and friends
07:40:50 <nand`> :t 20 * product
07:40:52 <lambdabot> forall a. (Num a) => [a] -> a
07:41:01 <c_wraith> belgin: you're probably trying to use / with Integers then
07:41:08 <Cale> > (20 * product) [1,2,3]
07:41:10 <lambdabot>   120
07:41:11 <nand`> :t 20 `asTypeOf` product
07:41:12 <lambdabot> forall a. (Num a) => [a] -> a
07:41:22 <hiptobecubic> :t asTypeOf
07:41:23 <lambdabot> forall a. a -> a -> a
07:41:28 <hiptobecubic> lol
07:41:52 <sipa> :t id `asTypeOf` (undefined :: Int -> Int)
07:41:53 <lambdabot> Int -> Int
07:42:01 <sipa> > (id `asTypeOf` (undefined :: Int -> Int)) 4
07:42:03 <lambdabot>   4
07:42:11 <nand`> :t id `asTypeIn` (undefined :: Int -> Int)
07:42:13 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `Int'
07:42:13 <lambdabot>     In the second argument of `asTypeIn', namely
07:42:13 <lambdabot>         `(undefined :: Int -> Int)'
07:42:16 <nand`> oops
07:42:20 <nand`> :t 4 `asTypeIn` (undefined :: Int -> Int)
07:42:21 <dfeuer> Unfortunately, conal here hasn't gotten around to documenting that yet.
07:42:21 <lambdabot> Int
07:42:27 <sipa> :t asTypeIn
07:42:28 <c_wraith> belgin: oh, I see.  It's the use of recip.
07:42:29 <lambdabot> forall a b. a -> (a -> b) -> a
07:42:38 <belgin> c_wraith here's what i'm doing: 20 * (product . map ((1-) . recip) . unique . factor) 20
07:42:48 <nand`> belgin: still missing a fromIntegral most likely
07:43:03 <nand`> what are the type signatures on ‘unique’ and  ‘factor’?
07:43:04 <Cale> belgin: yeah, that's reasonable. You could also put the 20 inside the parens after a $
07:43:09 * Yuu-chan needs to learn operators precedence
07:43:36 <Cale> I mean: 20 * (product . map ((1-) . recip) . unique . factor $ 20)
07:43:38 <hpaste> mbuf pasted “Not in scope data constructor” at http://hpaste.org/72911
07:44:22 <c_wraith> belgin: recip works with types that can represent arbitrary fractions. factor produces Integer, which can't.  that's the cause of the type error you're seeing.
07:44:29 <nand`> mbuf: module Data.Number.Interval doesn't export Interval's constructors
07:44:33 <nand`> you likely want Interval(..)
07:44:35 <Cale> mbuf: That module doesn't export the I constructor
07:44:47 <Cale> You want to use ival
07:44:52 <Cale> ival :: Ord a => a -> a -> Interval a
07:44:56 <nand`> oh, or ival
07:45:05 <Cale> which is a "smart constructor" for Interval
07:45:10 <nand`> (I wasn't paying attention to the source, just the error :))
07:45:15 <belgin> i added a fromIntegral and now it works
07:45:27 <c_wraith> belgin: excellent
07:45:32 <Cale> (that makes sure the bounds are in the right order, and throws an error early if not)
07:45:53 <mbuf> Cale: nand` getIval (Interval 3 4) :: (Int, Int) also says Not in scope data constructor: `Interval'
07:46:05 <nand`> mbuf: like Cale said, use ival
07:46:07 <Cale> mbuf: Interval is a type constructor, not a data constructor
07:46:08 <nand`> getIval (ival 3 4)
07:46:34 <belgin> c_wraith: however, now I want test to be a function that takes an Integer and returns an Integer
07:46:47 <belgin> so I should have n instead of 20 there
07:46:48 <nand`> belgin: then you need some way of losing precision
07:47:09 <mbuf> Cale: ohh! okay
07:47:11 <Yuu-chan> nand`: or use Rational
07:47:30 <nand`> Yuu-chan: you still lose precision when truncating/rounding/flooring/whatevering from Rational to Integer
07:47:58 <mbuf> Cale: nand` thanks
07:48:02 <Yuu-chan> nand`: you can check if the denominator == 1
07:48:21 <nand`> Yuu-chan: and error otherwise?
07:48:47 <hpaste> dmwit pasted “API design question” at http://hpaste.org/72912
07:48:59 <dmwit> oh, no word wrap =/
07:49:32 <Yuu-chan> nand`: return Maybe Integer :) We should know about the task first, I guess
07:50:28 <Eduard_Munteanu> dmwit: edit it in vim and gq it :)
07:51:08 <nand`> Yuu-chan: it may be the case that in this particular scenario it's provable the result is always an integer (but in that case I feel that there should exist a reformulation of the algorithm which avoids rationals altogether)
07:51:11 <nand`> I think mm_freak_ mentioned something to this effect
07:51:37 <Yuu-chan> As I can understand, it's some kind of mathematical equality
07:51:38 <hpaste> dmwit annotated “API design question” with “word-wrapped” at http://hpaste.org/72912#a72913
07:53:02 <nand`> Yuu-chan: it's the totient function
07:53:38 <nand`> looks like it should always be integer; since it ‘counts the number of positive integers ...’
07:53:56 <Yuu-chan> @google totient function
07:53:57 <lambdabot> http://en.wikipedia.org/wiki/Euler's_totient_function
07:54:02 <nand`> so if euler's formula is proven to be equal to the naive definition of the totient it should be the case that it's always an integer result
07:54:10 * Yuu-chan becomes addicted to bots
07:54:22 <srhb> For my toy games with maps of various elements I've often been keeping a map of Coord -> Element, but I see a lot of other people go the other way around, defining one Map (or rather, Set) of coords for each type of element. Am I doing it wrong?
07:54:27 <nand`> in that case I would be fine with erroring on denom≠1 since it would be a mathematical impossibility
07:55:18 <nand`> srhb: maybe both? Map Elem Coord ∧ Map Coord Elem? I guess it depends on what kind of lookups you want to do
07:55:40 <nand`> (there's a two-way Map somewhere for what I just described)
07:56:22 <srhb> Oh, a two way map does sound quite clever. Best of two worlds.
07:56:43 <Yuu-chan> belgin: don't you solve Project Euler problems? :)
07:57:06 <belgin> not now
07:57:09 <dmwit> ?hackage bimap
07:57:09 <lambdabot> http://hackage.haskell.org/package/bimap
07:57:15 <nand`> project euler always makes me feel stupid; the only solutions I can come up with are brute force formulations and they take aeons to run
07:57:20 <mietek> identity: thanks for your earlier explanations. I found that http://www.grabmueller.de/martin/www/pub/Transformers.pdf provides more than enough motivation to convince me of the utility of transformer stacks.
07:57:59 <parcs`> @hoogle IO a -> STM a
07:58:00 <lambdabot> GHC.Conc.Sync unsafeIOToSTM :: IO a -> STM a
07:58:00 <lambdabot> GHC.Conc unsafeIOToSTM :: IO a -> STM a
07:58:00 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
07:58:38 <srhb> dmwit: Thanks!
07:59:26 <timthelion> dmwit: make a FooBit for Foo: a type like data FooBit = NumWidgets Int | NamedWibble (String,Wibble)... and then send a list of [FooBit] and then make a fooBitsToFoo :: [FooBit] -> Foo
07:59:52 <srhb> Oh, but in a bimap elements on each side are unique. I do need the right hand side to not be unique..
08:00:01 <Yuu-chan> Sorry to ask again, but why browse or request in Network.Browser writes some debug info to the console and how to turn it off?
08:00:03 <srhb> If I'm to go that route..
08:00:19 <timthelion> dmwit: Not sure if that's much better than Maybe's...
08:00:33 <dmwit> srhb: Oh, fair point.
08:00:34 <fmap> nand`: i think interesting part of project euler is to bruteforce the problem under a minute
08:00:39 <timthelion> dmwit: of simply look up the values in the FooBit list...
08:00:59 <nand`> fmap: :)
08:01:03 <dmwit> timthelion: Hm, how would that help?
08:01:14 <dmwit> timthelion: Is this using the former or latter definition of Foo?
08:01:21 <dmwit> (In retrospect I should have given them different names.)
08:01:37 <belgin> now I did this: test n = truncate n * (product . map ((1-) . recip . fromIntegral) . unique . factor) n, with test :: Integer -> Integer and i'm getting the Fractional Integer error again
08:02:26 <Yuu-chan> belgin: truncate $ stuff
08:02:27 <timthelion> dmwit: Well, using the former, I guess you cannot convert.  But you can do a lookup function that searches in the [FooBit]s
08:02:39 <belgin> factor is Integer -> [Integer] and unique is [Integer] -> [Integer]
08:02:39 <mbuf> how do I use CReal defined by: data CReal = CR (Int -> Integer)?
08:02:47 <nand`> Yuu-chan: looks like ‘browse’ isn't doing any IO, it's all in the BrowserAction
08:03:06 <timthelion> dmwit: I think your best bet is the Maybe's though.
08:03:34 <dmwit> hm
08:03:45 <dmwit> Actually, it's not a bad idea.
08:03:47 <timthelion> dmwit: unless you have several different sets you might want to look up, in which case you can make FooPart1 FooPart2
08:03:50 <Yuu-chan> belgin: er, sorry. test n = n * truncate $ stuff
08:04:07 <dmwit> Though I'd want to return an HList instead and make an instance that knows how to do the appropriate request.
08:04:11 <dmwit> I like that idea!
08:04:12 <timthelion> dmwit: so for request1 you would recieve not Foo, but FooPartDesignedForRequest1
08:04:23 <dmwit> You just pattern match on the fields you want and you're done.
08:04:43 <timthelion> dmwit: that's with an HList?
08:04:50 <nand`> dmwit: maybe something like http://hackage.haskell.org/packages/archive/records/0.1.1.6/doc/html/Data-Record.html could be related?
08:05:06 <dmwit> oooo
08:05:10 <dmwit> fancy =D
08:05:28 <nand`> I think it does stuff like letting you query for certain fields among all types that contain it
08:05:57 <Yuu-chan> @hoogle a -> (b, c) -> (a, b, c)
08:05:58 <lambdabot> Data.Graph.Inductive.Graph inn :: Graph gr => gr a b -> Node -> [LEdge b]
08:05:58 <lambdabot> Data.Graph.Inductive.Graph out :: Graph gr => gr a b -> Node -> [LEdge b]
08:05:59 <lambdabot> Language.Haskell.TH.Lib varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
08:06:07 <timthelion> nand`: great package, thanks for the link, though the author should know, that is called a dictionary!!! (me has a bit of a pet peave for when two identical concepts get given different names)
08:06:19 <dmwit> not a dictionary
08:06:23 <timthelion> ?
08:06:24 <timthelion> how so?
08:06:29 <dmwit> this can have multiple copies of a single field, it seems =)
08:06:39 <timthelion> I see
08:06:43 <nand`> a static dictionary, perhaps; just ‘dictionary’ I would associate with something like Map
08:07:09 <nand`> Yuu-chan: n * truncate $ stuff <- will still require NumInstances
08:07:25 <nand`> it's (n * truncate) $ stuff
08:07:30 <belgin> Yuu-chan: if i put truncate there, i get 0 for any n
08:07:55 <nand`> belgin: what does your function look like now?
08:08:32 <Yuu-chan> nand`: :'(
08:08:48 <belgin> test n = n * (truncate $ (product . map ((1-) . recip . fromIntegral) . unique . factor) n)
08:09:35 <Yuu-chan> belgin: silly me... Seems it's necessary to add another fromIntegral to n before multiplying.
08:09:43 <nand`> oh
08:09:47 <nand`> no I see what you're doing
08:09:57 <nand`> if you truncate before multiplying, you lose a lot more precision
08:10:06 <nand`> in fact, all of it
08:10:28 <Yuu-chan> nand`: that was my fault
08:10:31 <belgin> that's what i thought
08:10:37 <nand`> reciprocals of integers are always ≥0 ∧ ≤1; so even after (1-) if you multiply them together the result will be in the same range
08:11:04 <nand`> truncate always rounds towards zero, at least for positive integers; so you get n * 0
08:11:13 <Yuu-chan> Test: ?0 ? ?1
08:11:18 <nand`> you want truncate $ n * (product ...) n
08:11:28 <nand`> truncate $ fromIntegral n * (product ...) n
08:12:02 <Yuu-chan> I wanna Unicode in my messages too!
08:12:22 <timthelion> If I have an external preprocessor, that I want to run on my source files before compiling, can I put that into a cabal file, or do I need to put something into Setup.lhs?
08:12:43 <dcoutts_> timthelion: both, but mainly into the Setup.hs
08:12:56 <belgin> thanks, nand` it works fine now
08:13:06 <timthelion> dcoutts_: can you think of a package off the top of your head that does this?
08:13:35 <dcoutts_> timthelion: in the .cabal file you list it in the build-tools, and in the Setup.hs you explain what that build tool is and how to use it as a pre-processor
08:13:48 <timthelion> dcoutts_: ok
08:14:16 <timthelion> dcoutts_: is that different than a build-depend(like that error you get when happy isn't installed yet)?
08:14:31 <JenLoveHewitt> lisp really fells like lamer-haskell
08:14:34 <dcoutts_> timthelion: older versions of alex/happy listed perl as a build tool, but they didn't use the pre-processor thing. The Cabal API should be semi-self-explanitory about the pre-processor stuff
08:14:48 <timthelion> ok, thanks
08:14:58 <dcoutts_> timthelion: yes, build-tools refers to programs rather than packages/libs
08:15:25 <Yuu-chan> JenLoveHewitt: I'll quote that to my Lisper friend :)
08:15:28 <nand`> belgin: you could try comparing it to a naive counting implementation, eg. length [ p | p <- [1 .. n], coprime p n ]
08:15:39 <dcoutts_> timthelion: the UserHooks structure contains hooks for custom program and custom pre-processors, you'll need both
08:15:40 <nand`> I wonder how that compares
08:16:39 <statusfailed> @pl (\x -> isAlpha x && isAscii x)
08:16:40 <lambdabot> liftM2 (&&) isAlpha isAscii
08:16:41 <timthelion> dcoutts_: I'm writting in haskarrow http://hackage.haskell.org/package/haskarrow (When McBride wrote she, he integrated her directly into ghc) with haskarrow, I've kept haskarrow as a seperate executable that you run first, and then you run ghc after on the resulting hs file...  Is McBride's approach better?  I don't want to accidentally fuck up ghc...
08:16:46 <statusfailed> dafuq!?
08:17:08 <JenLoveHewitt> how do i get version of glut so i can put it in blah.cabal?
08:17:12 <dcoutts_> timthelion: certainly easier to get started that way
08:17:26 <timthelion> that = as a seperate program?
08:17:43 <dcoutts_> timthelion: Connor may have had other reasons to integrate into ghc, e.g. access to extra info
08:17:56 <timthelion> ok
08:17:58 <timthelion> thanks
08:18:25 <dcoutts_> timthelion: the cabal pre-processor mechanism relies on unique file extensions, like .hsc, .x, .y etc
08:19:50 <timthelion> dcoutts_: OK, that's fine.  I've been using the extension lhs, but only so I get highlighting for my code in vim, I can make a unique extension without problem...
08:22:54 <nule> good morning, all - is anybody aware of a http://processing.org/ -like environment for Haskell? I'm looking to do some visualization work but I'd like to attempt it all in Haskell
08:23:22 <nule> (even a simple canvas-like GUI would be fine, I don't need to build and deploy apps)
08:23:39 <luite> you can look at diagrams and gloss
08:23:43 <JenLoveHewitt> if i have graphics.ui.glut and graphics.rendering.opengl in my main.hs what do i put in x.cabal?
08:24:35 <luite> nule: diagrams is higher level, can do animation, but is not very optimized yet, it might be too slow
08:25:03 <nule> luite, thanks, I'll look at that
08:26:05 <nule> err, those
08:26:08 <dmwit> JenLoveHewitt: Try cabal build, it'll tell you. =)
08:26:38 <dmwit> JenLoveHewitt: Also, you can use Hoogle to answer this kind of question if you ask it properly.
08:26:52 <dmwit> http://www.haskell.org/hoogle/?q=Graphics.UI.GLUT third result says it's in the GLUT package
08:31:46 <nule> another related question - is wx the "preferred" UI toolkit for Haskell or do people prefer something else? (and thanks)
08:33:34 <n-dolio> I wouldn't say it's preferred.
08:34:08 <n-dolio> There hasn't been a whole lot of work on UI toolkits generally, though.
08:34:19 <nule> n-dolio: understood, thanks
08:34:23 <n-dolio> So you take what you can get.
08:35:09 <JenLoveHewitt> @hoogle glut
08:35:10 <lambdabot> package GLUT
08:35:10 <lambdabot> Graphics.UI.GLUT.State glutVersion :: GettableStateVar String
08:35:10 <lambdabot> Graphics.UI.GLUT module Graphics.UI.GLUT
08:40:22 <srhb> How could the Haskell community go about getting real UI work done though? Sponsoring someone? Hiring a company to do it?
08:40:29 <hpc> nule: gtk is another popular one
08:40:33 <srhb> It seems this often crops up, that the UI part is unpolished.
08:40:44 <hpc> you can also go down a level to SDL or opengl
08:41:12 <mietek> There's GLFW
08:41:17 <nule> i don't think i need an actual UI for the visualization work I'm doing, but it's helpful to know some options
08:41:18 <mietek> Which might be less painful than GLUT
08:41:23 <S11001001> srhb: first we need people to define what polished means
08:41:28 <srhb> S11001001: True.
08:41:33 <mietek> Particularly https://github.com/bsl/GLFW-b
08:42:56 <mietek> srhb: how do you define "real UI work"?
08:43:08 <mietek> Native bindings to UI functions on each major platform?
08:47:56 <hpc> i know native bindings are tricky apple-side
08:48:11 <hpc> and probably on windows too due to their obsession with COM
08:49:11 <mm_freak_> srhb: easy…  find someone who pays me for a comprehensive FRP GUI library =)
08:49:26 <timthelion> hpc: COM is higher level than truely native windows bindings.  One can bind to windows.h very easilly(at least that was the case 10 years ago last time I had a computer running windows )
08:49:38 <hpc> ah
08:49:38 <mietek> hpc: you can easily call Haskell code from Obj-C on OS X
08:50:18 <mm_freak_> that person/company can even choose between OpenGL, GTK and Qt =)
08:50:19 <mietek> So I guess one way could be to build your UI the usual way, and keep the logic in Haskell
08:52:14 <tew88> mm_freak_: You could always try your luck on Kickstarter ;)
08:53:03 <hpc> mm_freak_: there's no Qt bindings yet though, i think?
08:53:06 <mm_freak_> tew88: nobody is paying me there (or anywhere else) for a GUI library, otherwise i'd have written one long ago…  after all by now i have quite some time of experience as an FRP implementor
08:53:34 <mm_freak_> hpc: dunno…  Qt is probably not a good idea
08:56:39 <mm_freak_> hpc: i think the most interesting application for FRP UI programming is the web…  not only because it's great, but because i know it works =)
09:01:31 * hackagebot subtitleParser 0.4 - A parser for .srt and .sub files (RubenAstudillo)
09:02:32 <nand`> mm_freak_: sell it to microsoft, they will think running their horrible web browser on top of every single application is a good idea
09:03:02 <mm_freak_> don't they do that already?
09:03:07 <nand`> actually that might be possible with current technologies, Haskell compiled down to javascript
09:03:55 <nand`> now if people actually used windows 8 that would be an incentive for making a metro package
09:06:33 * hackagebot rank1dynamic 0.1.0.0 - Like Data.Dynamic/Data.Typeable but with support for rank-1 polymorphic types (EdskoDeVries)
09:06:35 * hackagebot distributed-static 0.1.0.0 - Compositional, type-safe, polymorphic static values and closures (EdskoDeVries)
09:06:37 * hackagebot distributed-process 0.3.0 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
09:07:56 <eldar> hi all! I'm new to haskell and I am going to work on a web app with it. I've used Node JS before and I'm looking for something simiar. Is Yesod my best bet?
09:08:56 <mm_freak_> eldar: hard to say…  i recommend trying out all of the three major web frameworks in haskell
09:08:57 <hpc> eldar: never used happstack; from what i know of node.js, happstack might be similar
09:09:02 <mm_freak_> happstack, snap and yesod
09:09:09 <mm_freak_> they all have different strengths
09:09:28 <mm_freak_> if happstack is similar to node.js, then snap is also
09:09:31 <JenLoveHewitt> can i run cabal update with some info so isse hats going on?
09:09:40 <JenLoveHewitt> it takes forever(mpbile broadband)
09:09:51 <eldar> mm_freak_, hpc, thanks for pointing out, I'll try them out!
09:10:20 <mm_freak_> eldar: yesod is like:  be as productive as possible, but don't care about the internals
09:10:37 <mm_freak_> eldar: snap is like:  be productive, but know what's going on
09:10:54 <mm_freak_> eldar: and happstack is like the magic force that drives snap =)
09:10:55 <nand`> so yesod exposes a higher level abstraction?
09:11:05 <eldar> yeah, I'm not a web developer, so I liked how in Node you know what's going on
09:11:10 <mm_freak_> nand`: no, it just doesn't expose the abstraction =)
09:11:17 <applicative> JenLoveHewitt: it's pretty slow these days, hackage is so huge
09:11:25 <mm_freak_> eldar: then yesod is not for you
09:11:27 <eldar> even though you'll have to use another layer on top of it like Express to build something useful :)
09:11:31 * hackagebot dvda 0.3.0.1 - Efficient automatic differentiation and code generation (GregHorn)
09:11:38 <eldar> yeah, I don't like the "magic" approach :)
09:11:42 * nand` is befuddled.. surely it presents some API
09:11:51 <mm_freak_> nand`: yes
09:11:56 <mm_freak_> template haskell and quasiquotes =)
09:12:17 <mm_freak_> and a highly opaque handler monad
09:12:27 <nand`> there are your abstractions :P
09:12:52 <mm_freak_> yesod is tuned for productivity…  be productive with as little thinking as possible…  leave the thinking to the framework developers
09:13:01 <applicative> yesod seems to have more in the way of a 'community', no?
09:13:18 <mm_freak_> applicative: doubt it…  all three of them have a strong community behind them
09:13:20 <hpc> happstack seems to be "the hacker's web framework"
09:13:36 <hpc> what with how you are pretty much writing an httpd yourself
09:13:41 <mm_freak_> hpc: happstack will be nice as soon as version 8 comes out, where you finally have modularity
09:13:43 <nand`> what if I'm looking for elegance, especially declarative minimalism and straightforwardness?
09:13:50 <mm_freak_> snap has snaplets, which makes web dev modular
09:14:09 <applicative> mm_freak_: or maybe I meant, beginner friendly community. Certainly the stackoverflow questions are weighted toward yesod pretty considerably
09:14:09 <hpc> mm_freak_: eh, modularity isn't really a problem for me
09:14:57 <applicative> eldar snap has a #snap-framework and yesod a #yesod channel, for what it maybe be worth
09:15:01 <mm_freak_> hpc: still it's very nice to break the application down into logical units (not necessarily visually distinct)
09:15:25 <mm_freak_> applicative: i think that's mostly related to the PR features of yesod
09:15:36 <mm_freak_> the yesod website is amazing compared to the other frameworks
09:15:55 <mm_freak_> nand`: happstack or snap
09:16:01 <applicative> yes, but 'pr' is an integral part of a framework, maybe....
09:16:12 <pr> those hilights
09:16:13 <mm_freak_> yesod is elegant, too, but for my taste it's too opaque
09:16:14 <pr> aaaaaaaaaah
09:16:26 <mm_freak_> lol pr
09:16:30 <pr> :)
09:16:33 <nand`> mm_freak_: I guess it boils down to ‘You'll have to look at all three and decide for yourself’
09:16:34 <applicative> the conduit system is less appalling than iteratees certainly
09:16:38 <hpc> mm_freak_: yeah, the happstack website URLs are useless for knowing where you are
09:16:43 <mm_freak_> pr: applicative and fmap (the guys) have the same problem ;)
09:16:46 <hpc> they're stuff like happstack.com/C/1
09:16:57 <pr> mm_freak_: haha, you're right
09:17:14 <mm_freak_> nand`: if you want clean, transparent elegance, you can scratch yesod from that list =)
09:17:30 <Reaga> lol
09:17:42 <Reaga> I got baned from #java for point out that the java compiler sucks
09:17:42 <applicative> and use iteratees instead?
09:17:48 <mm_freak_> applicative: not at all…  conduits are now based on pipes, a very clean and more flexible approach to stream processing
09:17:49 <Reaga> and cant optimize for tail end recursion
09:18:10 <hpaste> hewitt pasted “glut” at http://hpaste.org/72914
09:18:19 <JenLoveHewitt> i cant install glut
09:18:22 <nand`> I'm not exactly sure what ‘clean, transparent elegance’ refers to. The kind of elegance I'm envisioning is say fac n = product [1..n]; where I can build up something out of very few other components that read exactly the way they should
09:18:29 <applicative> mm_freak_: right, isn't that an argument in its favor?
09:18:30 <JenLoveHewitt> with cabal install
09:18:53 <mm_freak_> applicative: oh, i read "appalling" as "appealing" =)
09:19:03 <hpaste> teepark pasted “type overlap” at http://hpaste.org/72915
09:19:21 <teepark> i have a question regarding instance overlap (in that paste)
09:19:28 <belgin> nand`: the naive counting function is much slower than the product solution
09:19:29 <mm_freak_> a lot of great libraries did emerge as part of the yesod project…  i think it's one of the driving forces of haskell web development, but it's probably not something i personally would use, because i want transparency
09:19:36 <nand`> belgin: :(
09:19:39 <teepark> dump "test" complains of overlapping instances from lines 24 and 27
09:19:58 <teepark> but it seems like the constraint in the second instance should preclude the first
09:20:01 <applicative> i was thinking the transparency of pipes over iteratees was an argument that yesod had a bit of 'transparency' snap lacked thats all
09:20:03 <mm_freak_> nand`: in that case you might actually like yesod =)
09:20:17 <mm_freak_> nand`: code written for yesod is /very/ clean and readable as well as concise
09:20:23 <mm_freak_> just don't mind all those quasiquotes =)
09:20:31 <teepark> how would I get a function to behave differently for String/[Char] than for lists of other dumpable types?
09:20:40 <applicative> JenLoveHewitt: did 'cabal update' complete?
09:20:53 <belgin> nand`: phi 1000000 takes 0.00 seconds to complete while phi2 1000000 (the naive one) takes a little over 3 seconds
09:20:54 <nand`> mm_freak_: I'd have to look at examples of each, or I'll have a hard time feeling it out
09:21:05 <mm_freak_> teepark: use a newtype for the strings
09:21:11 <applicative> JenLoveHewitt: what operating system are you using?
09:21:27 <mm_freak_> teepark: better solution:  write two functions ;)
09:21:38 <belgin> nand`: But I used the gcd from Prelude, maybe that's the problem
09:21:51 <mm_freak_> nand`: examples won't help…  write a guestbook in all of them
09:22:04 <nand`> teepark: the way Show a solved it is by adding a showList :: [a] -> String; then defining that differently for the Char instance as opposed to other instances
09:22:12 <nand`> and the Show [a] instance is show = showList
09:23:35 <applicative> JenLoveHewitt: in theory the haskell GLUT libraries come with the Haskell-Platform.  Does ghc-pkg list show anything?
09:23:42 <teepark> nand`: not sure how that solves it, now showList has to tell the difference between [Char] and [anything-else]
09:23:53 <mightybyte> nand' and eldar: I wrote a blog post comparing the three frameworks if you haven't seen it.
09:24:00 <mightybyte> http://softwaresimply.blogspot.com/2012/04/hopefully-fair-and-useful-comparison-of.html
09:24:00 <mm_freak_> teepark: Show for [a] is a hack
09:24:19 <nand`> teepark: showList has differing instances for Char as opposed to anything-else
09:24:30 <nand`> but mm_freak_ is right
09:24:33 <nand`> it's a hack
09:24:36 <nand`> just to avoid having to newtype
09:24:46 <nand`> and getting differing behaviors into the same function
09:25:12 <applicative> mightybyte is here, eldar, if we can just wake up stepkut and a few others we can get a real irc battle of the frameworks going
09:25:23 <teepark> hmm
09:25:28 <mm_freak_> teepark: again, write two functions
09:25:42 <eldar> mightybyte, thks will have a read
09:25:47 <mm_freak_> one might want the regular behavior for [Char] instead of the special [Char] behavior
09:25:56 <JenLoveHewitt> Im running ubuntu on vmware and im running this example using glut and opengl, the window opens with the correct title but the polygon is not shown, in the window is just emacs or ubuntu or whatever is behind the window when I launch. I will paste code
09:26:00 <eldar> applicative, lol I just need a tool for a job, and learn haskell in the meantime :)
09:26:17 <teepark> Char isn't dumpable in this case, except as a length-1 string
09:26:20 <hpaste> hewitt pasted “opengl glut” at http://hpaste.org/72916
09:26:20 <Reaga> can someone link me to an explanation of haskells problems with estimating its usage
09:26:31 <Reaga> i dont understand how haskell causes problems iwt h estimating sizes of usage
09:27:24 <hpc> Reaga: "estimating sizes of usage"?
09:28:41 <applicative> JenLoveHewitt: O
09:28:42 <mm_freak_> teepark: "dump"?
09:28:53 <mm_freak_> teepark: serialize?
09:28:59 <teepark> yes
09:29:02 <JenLoveHewitt> applicative: O?
09:29:10 <applicative> JenLoveHewitt: I'm on osx and am similarly just getting a white window.  How big are these points
09:29:17 <teepark> mm_freak_: serialize
09:29:17 <mm_freak_> teepark: why don't you just use the 'cereal' library?
09:29:24 <applicative> JenLoveHewitt: sorry, hit return accidentally
09:29:44 <teepark> mm_freak_: this is a reimplementation of a serialization format previously written in C, and I'm going for interoperability
09:29:54 <teepark> mm_freak_: so it needs its own implementation
09:30:00 <Reaga> hpc: i mean its memory use
09:30:16 <Reaga> laziness makes it more difficult for programmers to reason about the performance of their code (particularly its space usage).
09:30:16 <mm_freak_> teepark: i see, but then String is in fact [Char]…  what is more like a C string is ByteString
09:30:57 <hpc> Reaga: i don't think it really makes it harder, so much as different
09:31:02 <teepark> mm_freak_: yes and I'm using that throughout, but sometimes need [Word8] as a go-between for ByteString and Lazy.ByteString
09:31:14 <applicative> JenLoveHewitt: for example, no color seems to  have been determined
09:31:22 <hpc> (once you bring optimizations into the picture, it's going to be hard to reason about memory use in any language)
09:32:16 <hiptobecubic> why would you take a nick like 'fmap' in this channel
09:33:26 <hpc> hiptobecubic: i occasionally get pinged for haskell program coverage
09:33:27 <JenLoveHewitt> to run haskell code on android youd need a haskell to java compiler?
09:33:34 * hackagebot distributed-process-simplelocalnet 0.2.0.4 - Simple zero-configuration backend for Cloud Haskell (EdskoDeVries)
09:33:57 <teepark> mm_freak_: nand`: thanks for the help
09:34:42 <geekosaur> JenLoveHewitt, android has had the ability to run native ARM code for a while now.  no idea if anyone's taken advantage of that yet though
09:35:05 <mm_freak_> mightybyte: you are a yesod developer, right? =)
09:35:13 <edwardk> mm_freak_: hahahaha
09:35:13 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
09:35:18 <mightybyte> mm_freak_: Exactly
09:35:39 <c_wraith> geekosaur: I think that's actually a big part of why ghci finally runs on arm
09:35:40 <mm_freak_> yet it's a nice post and i can confirm all of the information
09:36:30 <mightybyte> Although...if it was that easy to figure out, I need to go back and make my post less biased. ;)
09:36:37 <EvanR> is there a more efficient nub that works on sort...
09:36:41 <EvanR> sorted data
09:36:47 <EvanR> group?
09:36:53 <mm_freak_> teepark: [Word8] is a bad way to interface strict to lazy ByteString
09:36:57 <geekosaur> map head . group ?
09:36:59 <hpc> > map head . group $ [1, 1, 2, 3, 3, 3, 3, 3, 4]
09:37:01 <lambdabot>   [1,2,3,4]
09:37:12 <EvanR> cool
09:37:21 <mm_freak_> teepark: see toChunks and fromChunks in Data.ByteString.Lazy
09:37:53 <EvanR> i just learned about unix command uniq
09:37:54 <mm_freak_> EvanR: or don't have a list in the first place, see Data.Set
09:38:32 <mm_freak_> EvanR: if you need the occurence counts, see Data.Map
09:38:36 <mm_freak_> Map X Int
09:38:48 <EvanR> Data.Bag ? ;)
09:39:16 <mm_freak_> dunno about that one
09:40:51 <teepark> mm_freak_: I even knew about that, thanks for the reminder
09:41:30 <gertc> http://stackoverflow.com/questions/11905826/haskell-data-binary-example
09:44:06 <ReinH> edwardk: ping
09:44:17 <edwardk> pong
09:44:35 <ReinH> edwardk: congrats to us because we're awesome https://github.com/languages/Haskell
09:44:55 <ReinH> lens is the most watched repo today and one of the top 5 for the month :)
09:45:12 <edwardk> hah
09:46:11 <DMcGill> so for a monad transformer t and a monad m, return :: a -> t m a
09:46:39 <DMcGill> is there a function :: m a -> t m a that isn't the constructor?
09:46:51 <ReinH> edwardk: https://twitter.com/haskelllive/status/233967439052931074
09:47:07 <c_wraith> DMcGill: that's what lift does
09:47:17 <ReinH> also... https://github.com/pufuwozu/osxmonad o_O
09:47:27 <ReinH> tiling window manager for os x?
09:47:33 <DMcGill> ah, MonadTrans
09:47:35 <DMcGill> thanks
09:47:37 <ReinH> could this be the thing I've been waiting for for forever?
09:49:21 <edwardk> i guess the UML diagram helped ;)
09:51:43 <JenLoveHewitt> applicative: did u find anything that helps?
09:52:14 <DMcGill> what's the command for lambdabot to link its local source/namespace thing?
09:53:18 <hpaste> dfeuer pasted “Not as fast as I'd like” at http://hpaste.org/72917
09:53:26 <JenLoveHewitt> :t lift
09:53:28 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:53:34 <zhulikas> @src lift
09:53:34 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:53:52 <JenLoveHewitt> > lift (Just 5)
09:53:53 <lambdabot>   No instance for (GHC.Show.Show (t Data.Maybe.Maybe t1))
09:53:54 <lambdabot>    arising from a u...
09:54:09 <c_wraith> zhulikas: it's the function in the MonadTrans class.  Its implementation varies with t
09:54:18 <zhulikas> @type lift (Just 5)
09:54:19 <lambdabot> forall t (t1 :: (* -> *) -> * -> *). (Num t, MonadTrans t1) => t1 Maybe t
09:54:40 <applicative> JenLoveHewitt: no, got distracted.  have you looked at the examples in the glut package?
09:54:50 <tertl3> i cant get this to compile
09:55:00 <tertl3> http://haskelllive.com/episode-1-the-chess-board/
09:56:03 <ReinH> edwardk: ... uml diagram?
09:56:09 <nand`> are there any examples of actual production websites running JavaScript which was compiled from Haskell?
09:56:16 <ReinH> tertl3: that's a website; I'm not surprised that it doesn't compile :)
09:56:53 <nand`> ReinH: entire possible with literate haskell :P
09:56:59 <mauke> tertl3: why not?
09:57:03 <ReinH> nand`: hush you
09:57:51 <ReinH> tertl3: you might try using the tag for episode-1 https://github.com/haskelllive/haskelllive/tree/episode-1
09:58:07 <ReinH> or being more descriptive than "doesn't work"
09:59:01 <latro`a> ReinH: I was lacking internet for the last couple days, but since I still have this hpaste here:
09:59:07 <hpaste> latro`a pasted “readSquare'” at http://hpaste.org/72919
09:59:12 <ReinH> latro`a: I missed you :)
09:59:47 <ReinH> latro`a: exactly what I ended up with modulo a few names :D
09:59:48 <ReinH> sec
09:59:53 <latro`a> awesome
10:01:51 <ReinH> latro`a: https://github.com/haskelllive/haskelllive/blob/master/Chess.hs
10:02:42 <latro`a> ah
10:02:59 <ReinH> latro`a: I do prefer the case to the if though
10:03:10 <ReinH> latro`a: ok, very similar, not exactly
10:03:16 <latro`a> yeah, close enough though
10:03:35 <ReinH> latro`a: thanks so much :)
10:03:46 <ReinH> latro`a: and I think it was pretty easy to explain in the vid
10:03:50 <latro`a> I like this way because it gets you from Maybe (Maybe a) to Either compositionally
10:03:56 <latro`a> but using return does that as well, sorta
10:04:03 <dgpratt> what's going on when you 'cabal configure'? why is that a seperate (and required, apparently) step from 'cabal build'? 'cabal build
10:04:24 <ReinH> although ofc I explained mapM relatively well and then flubbed composition (mapM (mapM a) = (mapM . mapM) a
10:04:28 <dgpratt> err...apparently I've developed an echo
10:04:39 <dgpratt> echo
10:04:54 <ReinH> latro`a: my fmap return == your fmap Just
10:05:24 <latro`a> I meant by having two versions of readSquare
10:05:27 <latro`a> in the file together
10:05:42 <ReinH> latro`a: right
10:05:54 <ReinH> I could easily extract the Maybe version
10:05:59 <latro`a> right
10:06:00 <ReinH> the big win for me was note
10:06:06 <latro`a> yup :)
10:06:07 <ReinH> which I was unaware of, and which is totally awesome
10:06:49 <latro`a> I would still do showPiece (Piece Black type) = toLower $ showPiece (Piece White type), by the way
10:06:58 <latro`a> not a huge deal, bu makes that shorter :)
10:07:00 <latro`a> *but
10:07:39 <ReinH> latro`a: in the video I left refactoring showPiece to remove duplication as an exercise to the watcher ;)
10:07:49 <ReinH> latro`a: feel free to submit a pull request ;)
10:08:30 <ReinH> latro`a: I really liked how your refactor of readPiece removed the White/Black redundancy, the Piece constructor redundancy and the Just constructor redundancy.
10:08:32 <JenLoveHewitt> How much money does Dons, Neil Mitchell etc make?
10:08:34 <ReinH> maximally effective
10:10:47 <mightybyte> ReinH: How does your warning highlighting work in vim?  Do you have to be using guard for that to work correctly?
10:11:13 <ReinH> mightybyte: ghc-mod + syntastic
10:11:29 <ReinH> ghc-mod's HLint and HCheck runners manage the "sign column" (list of warnings)
10:11:34 <mightybyte> Ok, then what's the purpose of guard?
10:11:45 <ReinH> mightybyte: I just like seeing the compiler running
10:11:58 <mightybyte> Ahh, ok.
10:12:11 <ReinH> mightybyte: and also right now syntastic doesn't differentiate between warnings and compile failures
10:12:22 <ReinH> so if you notice it still says syntax error even for a warning
10:12:55 <zenzike> I also use syntastic, but since it's synchronous, and ghc-mod check can sometimes be slow, I've started using ghcmod-vim instead
10:12:58 <mightybyte> Ahh, I see
10:13:20 <ReinH> zenzike: right, I'm fortunate to have a nice modern macbook pro with an SSD from work
10:13:37 <ReinH> zenzike: but you can run the aync version of check and lint on buffer write
10:13:43 <ReinH> and get pretty much the same thing
10:14:09 <zenzike> ReinH: there are patches to syntastic that make it async (they've been pending for about 3 months)
10:14:19 <ReinH> zenzike: do they work/
10:14:40 <zenzike> ReinH: well, they rely on the AsyncCommand module, which require vim to be started in server mode
10:14:52 <ReinH> zenzike: o_O
10:14:57 <ReinH> ok, I see why that wouldn't get merged
10:15:01 <mightybyte> ReinH: I traditionally have tried to avoid using vim plugins, because there's value in using whatever is off-the-shelf.  But seeing those plugins at work in your screencast is pretty compelling.
10:15:04 <zenzike> ReinH: and if you're using a terminal version of vim, rather htan gvim, then it's annoying to have to pass --server
10:15:30 <ReinH> mightybyte: A former coworker of mine uses vim in essentially compatible mode in insert mode with one hand
10:15:47 <mightybyte> heh, I'm not that bad
10:15:48 <ReinH> mightybyte: his argument for his vim usage is "I can't depend on plugins to be available on other people's vims"
10:16:12 <mightybyte> Yeah, that's been my argument too.
10:16:16 <zenzike> I saw that Tekmo claims to do the same (on reddit)
10:16:20 <ReinH> mightybyte: I've been using vim for over a decade so I have a pretty good split by now between my environment and vim defaults
10:16:26 <ReinH> so if I'm on a server, say, I don't feel too lost
10:16:31 <mightybyte> But I heavily use a fairly large subset of vim's features.
10:16:36 <ReinH> I just switch to my own internal "vim compatible mode"
10:17:06 <zenzike> ReinH: I saw you were using tmux. I've been tempted to have a shot for a while too now, but since I use xmonad I've been reluctant to spend any time investigaing
10:17:21 <mightybyte> Yeah, I'm probably pushing 15 years of vim.
10:17:32 <ReinH> I also don't use finder plugins because vim navigation powerful enough that if people actually understood it they would never write finder plugins
10:17:39 <mightybyte> It was a bit of a trick when I switched to dvorak...
10:17:42 <ReinH> zenzike: makes sense. I really like it.
10:17:47 <ReinH> mightybyte: o_O
10:17:53 <ReinH> that's the main thing keeping me from trying a switch
10:18:08 <mightybyte> It really didn't end up being too bad.
10:18:11 <zenzike> mightybyte: very brave. I did a dvorak switch and my mind exploded
10:18:15 <ReinH> :e **/ is 90% as powerful as any fancy finder plugin out there
10:18:26 <ReinH> and it's pure vim
10:18:30 <mightybyte> yep
10:18:41 <zenzike> ReinH: but *slow*
10:18:50 <parcs`> i think vim on dvorak is no worse than on qwerty, if not better
10:18:51 <ReinH> zenzike: have you seen these fuzzy finder plugins?
10:18:53 <ReinH> THEY are slow :p
10:18:58 <zenzike> ReinH: I use FuF
10:19:14 <kennyd> parcs` with default keybindings?
10:19:16 <ReinH> CtrlP is probably my favorite
10:19:27 <ReinH> it's the most vim friendly I've tried
10:19:32 <parcs`> kennyd: of course
10:19:33 <ReinH> I hate vim plugins that try to make vim something other than vim
10:19:35 <zenzike> ReinH: :-) at least they cache the results, I don't think :e **/ does
10:19:37 <mightybyte> I use vim+dvorak with default bindings.
10:19:41 <ReinH> zenzike: true, but it's fast enough for me
10:19:51 <ReinH> unless I'm in a really big project
10:20:04 <ReinH> and besides, I don't edit files: edit methods and classes
10:20:07 <ReinH> so I mostly use :tag
10:20:08 <kennyd> hjkl being scattered all around the keyboard seems odd, but i guess you get used to it
10:20:17 <ReinH> kennyd: you can rebind
10:20:37 <ReinH> exhuberant ctags is a wonderous thing
10:20:40 <kennyd> I know, that's what I would do if I used dvorak
10:20:52 <zenzike> ReinH: :tag is brill. I've been thinking of making a plugin that does auto-tag generation by finding up-directory-stream .cabal files and building there
10:21:00 <DMcGill> can you derive in ghci?
10:21:05 <mightybyte> kennyd: hjkl actually wasn't that bad.  h and l still have a good correspondence with left and right.
10:21:05 <ReinH> files are just a leak in our chosen data abstraction layer ;)
10:21:15 <ReinH> zenzike: nice
10:21:16 <nand`> “enable developers to prototype quickly, deploy painlessly, scale massively, operate reliably, and change easily.” <- that doesn't sound very convincing, for some reason
10:21:23 <ReinH> zenzike: mine depends on git project root
10:21:29 <parcs`> kennyd: on dvorak, jk are adjacent and accessible with your left hand. hl are not adjacent but h is to the left of l and they're both accessible with your right hand
10:21:36 <ReinH> zenzike: and it's not a vim plugin, it's just a little bash script
10:21:37 <mightybyte> kennyd: And j and k are right next to each other in the index and middle finger just down a row and on the other hand.
10:21:47 <ReinH> zenzike: it writes to .git/tags
10:21:48 <zenzike> ReinH: is it shared somewhere?
10:21:50 <parcs`> kennyd: this means you can use both hands to navigate, as opposed to on qwerty where you can only use one
10:21:52 <ReinH> zenzike: not sure
10:22:15 <ReinH> zenzike: oh I borrowed it from tpope http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html
10:22:26 <ReinH> tpope is the best thing to ever happen to vim
10:22:28 <zenzike> ReinH: I'd be curious to see how you have that set up, I find the whole tag generation a bit of a PITA, and I tend to only do it when I start on a project with unfamiliar territory
10:22:56 <parcs`> my brain was literally in pain when i was learning dvorak. it was surreal
10:22:58 <ReinH> I had the good fortune to work with him for a couple years and pair with him quite a bit during that time
10:23:05 <ReinH> I thought I was good with vim after almost a decade of use
10:23:12 <ReinH> he showed me what actually being good with vim looks like
10:23:25 <DMcGill> is it a bug that the type inferrer makes a mistake?
10:23:30 <zenzike> :-) that must have been fun. I use a silly number of tpope's plugins. very useful
10:23:36 <DMcGill> "return" returns a compilation error, (:[]) works
10:23:47 <ReinH> zenzike: it was mostly me going "wait how did you do that?" every 30 seconds
10:23:57 <nand`> DMcGill: return and :[] don't have the same types, so that doesn't sound too surprising
10:24:08 <nand`> DMcGill: it could be an ambiguous type error
10:24:09 <ReinH> DMcGill: maybe you can hpaste some code?
10:24:14 <ReinH> (and the compile error)
10:24:42 <nand`> it could even be a conflicting instance error
10:26:03 <zenzike> ReinH: hm, making tags on git commmits seems nice enough, but what I think would be *really* nice would be to piggy-back on cabal's infrastructure, so that tags get generated whenever I do a cabal install
10:26:23 <nand`> most indescriptive type ever? “Maybe (String -> String -> t -> String -> Int -> Integer -> String -> String -> IO ()”
10:26:24 <ReinH> zenzike: that would also be nice :)
10:26:39 <mightybyte> Yes, that would be awesome.
10:26:40 <ReinH> zenzike: although I mostly need tags for my functions, not package functions
10:27:17 <ReinH> nand`: missing a ) somewhere too :p
10:27:28 <nand`> ReinH: after the ) :)
10:27:33 <mightybyte> I'm still holding out for the utopia where yi gets to a useable subset of vim
10:27:48 <nand`> me too, yi sounds cool
10:27:51 <nand`> it just feels uncool
10:27:51 <mightybyte> ...and fast enough
10:28:06 <zenzike> is anyone still working on yi?
10:28:35 * hackagebot netcore 1.0.0 - The NetCore compiler and runtime system for OpenFlow networks. (ArjunGuha)
10:29:26 <nand`> ReinH: that's why you use type aliases gratuitously, at any rate
10:30:09 <JenLoveHewitt> http://yannesposito.com/Scratch/en/blog/Haskell-OpenGL-Mandelbrot/ #### anyoen doen that? I get Couldn't match expected type `Float' with actual type `GLfloat' and dont know hwo tolsve that
10:31:09 <ReinH> nand`: yep
10:31:13 <ReinH> what is this I don't even https://github.com/DanBurton/tardis
10:32:29 <nand`> state monad with opposite plumbing iirc
10:32:31 <nand`> oh
10:32:47 <nand`> with both ways
10:34:06 <c_wraith> works just fine, as long as you don't introduce paradoxes. If you do, the universe ends up in an infinite loop
10:34:55 <jfischoff> what is a use case for tardis?
10:35:00 <jfischoff> undo?
10:35:48 <JenLoveHewitt> woooohooooo, olympic final!
10:37:32 <parcs`> > fix $ (1:) . scanl (+) 0
10:37:35 <lambdabot>   [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
10:37:47 <osfameron> jfischoff: traveling through time and space. no?
10:38:12 <nand`> I know a use case for reverse state monads, but not both-ways-state-monads
10:38:57 <parcs`> the reverse state monad, aka 'fix'
10:39:09 <c_wraith> parcs`: that is an interesing version of that sequence
10:39:39 <nand`> > fix $ scanl (+) 0 . (1:)
10:39:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:39:45 <conal> jfischoff: same as nand`: i have a useful example for backward state: http://conal.net/blog/posts/adding-numbers/. i don't know about both-ways.
10:39:46 <nand`> fix'd
10:39:59 <nand`> conal: that's the one I was thinking of
10:40:12 <conal> nand`: ah. i was just about to ask you.
10:40:37 <parcs`> oh right, didn't notice that
10:41:38 <conal> it was an eye-opener for me to realize that the standard right-to-left method of addition is exactly wrong for lax/lazy info extraction.
10:42:39 <hpaste> applicative annotated “opengl glut” with “opengl glut (annotation)” at http://hpaste.org/72916#a72921
10:42:40 <tibbe> @dcoutts I'm about to merge https://github.com/haskell/cabal/pull/988 unless you protest
10:42:40 <lambdabot> Unknown command, try @list
10:42:49 <conal> and (as a special case) a show-stopper for exact real arithmetic.
10:42:56 <applicative> JenLoveHewitt: pardon hideous green ^^^
10:43:07 <tibbe> dcoutts: it's the part of Mikhail's work that adds the support for local build trees to the source package index format
10:48:37 * hackagebot dvda 0.3.1 - Efficient automatic differentiation and code generation (GregHorn)
10:50:59 <Taneb> > fix (\r n -> case n of 0 -> 1; n -> n * r (n - 1)) 10
10:51:00 <lambdabot>   3628800
10:51:12 <Taneb> @pl fix (\r n -> case n of 0 -> 1; n -> n * r (n - 1))
10:51:13 <lambdabot> (line 1, column 26):
10:51:13 <lambdabot> unexpected ">"
10:51:13 <lambdabot> expecting variable, "(", operator or ")"
10:51:41 <Taneb> @pl fix (\r n -> if n == 0 then 1 else n * r (n - 1))
10:51:42 <lambdabot> fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1))
10:51:51 <hpaste> nand` pasted “Horrible lens code” at http://hpaste.org/72922
10:51:56 <nand`> edwardk: ^
10:52:16 <edwardk> heya
10:53:23 <Taneb> nand`, I think import Control.Lens.TH is redundant
10:53:30 <edwardk> hah
10:53:36 <edwardk> yeah Control.Lens re-exports TH now
10:53:37 * hackagebot dvda 0.3.2 - Efficient automatic differentiation and code generation (GregHorn)
10:53:43 <nand`> maybe ‘new’ could turn into some sort of demonic variable-argument uncurrying beast so the syntax is new Foobar(5, "foo", False)
10:53:45 <nand`> k
10:54:35 <edwardk> hah
10:54:48 <edwardk> debating about overloading _1, _2 etc to work on all tuples
10:54:52 <edwardk> at last up to 9-tuples
10:54:55 <edwardk> er at least
10:55:07 <edwardk> i've been doing a proof of concept and the type inference works great
10:55:09 <nand`> if you can make it work out
10:55:19 <nand`> can we see a hpaste?
10:55:29 <edwardk> sure one sec, i'm about halfway through
10:55:40 <Taneb> edwardk, I wish to complain that lens is ridiculously complicated and simple at the same time
10:57:37 <edwardk> @hpaste
10:57:38 <lambdabot> Haskell pastebin: http://hpaste.org/
10:57:59 <hpaste> edwardk pasted “polymorphic _1.._9 (wip)” at http://hpaste.org/72923
10:58:14 <edwardk> i'm most of the way done
10:58:16 <mekeor> wtf oO
10:58:50 <edwardk> Taneb: i'll take that as both a rebuke and a compliment ;)
10:59:10 <Taneb> It's complex in its simplicity
10:59:58 <timthelion> why does (\handlerValue -> return $ Just handlerValue) -- have a type of Maybe (IO a) and not IO (Maybe a)?
11:00:47 <ParahSailin_> :t (\handlerValue -> return $ Just handlerValue)
11:00:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m (Maybe a)
11:00:55 <Taneb> Surely it would be a -> m (Maybe a)?
11:01:00 <ParahSailin_> :t (\handlerValue -> return (Just handlerValue))
11:01:02 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m (Maybe a)
11:02:12 <ParahSailin_> @pl (\handlerValue -> return $ Just handlerValue)
11:02:13 <lambdabot> return . Just
11:02:28 <parcs`> hmm, speaking of that
11:02:34 <hpaste> Timothy pasted “ThreadObject error” at http://hpaste.org/72924
11:02:35 <edwardk> nand`: i did a version with MPTCs but they i can't ensure that knowing Tuple7 implies knowing Tuple6, etc.
11:02:39 <timthelion> Taneb: I think so too, but GHC dissagree's with me
11:02:43 <edwardk> its a tossup
11:02:47 <parcs`> edwardk: isn't Maybe distributive?
11:02:53 <parcs`> Distributive
11:03:04 <edwardk> parcs`: in data.distributive terms?
11:03:10 <edwardk> how do you distribute it?
11:03:14 <DT``> hi.
11:03:29 <Taneb> Hello
11:03:29 <edwardk> you just have a functor you need to move it over, you need to know that all the elements are Just to pull the Just out
11:03:32 <timthelion> see my paste as to what I mean
11:03:35 <edwardk> which you can't know
11:03:37 * hackagebot dvda 0.3.2.1 - Efficient automatic differentiation and code generation (GregHorn)
11:03:54 <edwardk> the | in the data type is a good clue its not distributive
11:04:15 * mekeor read http://www.haskell.org/haskellwiki/Functional_dependency
11:04:38 <timthelion> mekeor: past tense, imperitive tense, or gramatical error?
11:04:41 <nand`> edwardk: ugly! but seems to work
11:04:45 <parcs`> edwardk: ah right. thanks
11:04:50 * nand` always cries when looking at tuple instances
11:04:57 * mekeor notices that there were 3 releases of dvda within a quite short time.
11:05:02 <timthelion> nand`: :D
11:05:05 <nand`> so much code duplication. of all the things haskell solves, this seems not to be among them
11:05:07 <edwardk> nand`: heh. i figured this at least makes _me_ write this hideousness, not the user
11:05:14 <mekeor> timthelion: past
11:05:23 <edwardk> i wrote a version first using MPTCs, but its worse in some places
11:05:29 <edwardk> its shorter, but you can say less
11:05:38 <slack1256> mekeor: I had some problem updating a package in hackage earlier maybe is that?
11:06:01 <timthelion> nand`: as many people have said, haskell lacks a good multipass MACRO system.
11:06:09 <mekeor> slack1256: you're GregHorn?
11:06:28 <danil> edwardk: too bad we don't have TypeNats yet
11:06:34 <slack1256> mekeor: who? no :S
11:06:44 <timthelion> Did anyone take a look at my paste?
11:07:03 <adnam> where does cabal install stuff on windows?
11:07:06 <mekeor> timthelion: nope
11:07:11 <timthelion> mekeor: :D
11:07:21 <timthelion> mekeor: thanks for the nak
11:07:25 <mekeor> what paste?
11:07:26 <JuanDaugherty> all were apoplectic at your criticism
11:07:35 <timthelion> http://hpaste.org/72924
11:07:40 <timthelion> just an error I cannot figure out
11:07:43 <JenLoveHewitt> @hoogle told7
11:07:44 <lambdabot> No results found
11:07:45 <JenLoveHewitt> @hoogle told
11:07:46 <lambdabot> No results found
11:07:58 <timthelion> seems GHC has gone insane...
11:08:01 <JenLoveHewitt> How much money does Dons, Neil Mitchell etc make?
11:08:13 <edwardk> nand`: one nice thing is you can use them with your monomorphic tuple types as well
11:08:23 <mekeor> timthelion: tl;dr
11:08:29 <edwardk> since you can make the instance for Tuple3 Vec3 Vec3
11:08:56 <timthelion> mekeor: there is a 3 line error message at the top. that says (\ handlerValue -> return $ Just handlerValue) has type Maybe (IO a)
11:09:08 <timthelion> which is blatantly wrong,
11:09:21 <mekeor> hm.
11:09:21 <timthelion> even lambdabot dissagrees
11:09:32 <mekeor> disagrees with ghc?
11:09:36 <mekeor> or with you?
11:09:40 <timthelion> ghc
11:09:43 <mekeor> hm…
11:10:00 <mekeor> weird stuff…
11:10:03 <timthelion> :t (\ handlerValue -> return $ Just handlerValue)
11:10:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m (Maybe a)
11:10:17 <timthelion> the m is clearly outside the Maybe there!
11:10:59 <danil> timthelion: you forgot an argument to exceptionHandler and are using >>= in the function monad
11:11:18 <danil> it's complaining that the *body* of the lambda is of type "exception -> ..."
11:11:30 <timthelion> danil: really,
11:11:33 * timthelion goes to take a look
11:11:45 <cwl> yes
11:12:33 <timthelion> danil: aha, didn't even notice that :)  ghc didn't give me a very usefull error on that one...
11:12:36 <timthelion> thanks
11:12:53 <timthelion> this is the problem with pointless programming...
11:13:20 <mekeor> :)
11:13:35 <timthelion> yay, it compiles :)
11:13:37 <nand`> timthelion: GHC did tell you the problem: it said “return $ Just handlerValue” has type “exception -> Maybe (IO a)”, which it falls in line with what lambdabot said
11:13:59 <nand`> :t return $ Just ?handlerValue :: exception -> Maybe (IO a)
11:14:01 <lambdabot>     Could not deduce (?handlerValue::IO a) from the context ()
11:14:01 <lambdabot>       arising from a use of implicit parameter `?handlerValue'
11:14:01 <lambdabot>                    at <interactive>:1:14-26
11:14:06 <nand`> :(
11:14:53 <cwl> > let f = show
11:14:55 <lambdabot>   not an expression: `let f = show'
11:15:19 <cwl> > let f = show in f 5
11:15:20 <lambdabot>   "5"
11:15:28 <timthelion> lambdabot: all incomprehensiable strings are expressions. haven't you heard of art!  You fool.
11:16:17 <c_wraith> anyone know offhand what exception SIGINT results in in ghc on linux?
11:16:17 <edwardk> nand`: ok, i now have all the _n overloads ready, time to splice them in
11:16:39 <nand`> edwardk: how clear are error messages?
11:16:43 <nand`> can you provide examples?
11:16:53 <nand`> say what happened if I use (1,2)^._3
11:17:20 <JuanDaugherty> c_wraith as a result of what condition?
11:17:32 <nand`> why do they start at _1 either way? 0 is the true first ordinal :)
11:17:34 <edwardk>     No instance for (Tuple3 (t0, t1) (t0, t1))
11:17:34 <edwardk>       arising from a use of `_3'
11:17:41 <nand`> edwardk: fair enough
11:18:11 <c_wraith> JuanDaugherty: the signal handler for SIGINT throws some exception.  I don't know which.
11:18:22 <edwardk> but its kinda nice to be able to use ghci> _3 .~ "hello" $ (1,2,3)
11:18:22 <edwardk> (1,2,"hello")
11:18:41 <edwardk> and get polymorphic rewrites of tuple types
11:18:53 <nand`> yes
11:19:01 <JenLoveHewitt> Noone knows how much money people make coding Haskell for banks?
11:19:17 <edwardk> i'll probably add a 'tuple' traversal that is overloaded 'both' as well
11:19:22 <nand`> this deprecates the stupid ‘fst3’ ‘snd3’ ‘thd/trd/3rd/whatever’ aliases people commonly hack up too
11:19:25 <Axman6> JenLoveHewitt: lots
11:19:27 <slack1256> JenLoveHewitt: I guess nobody want to tell and isn't important :)
11:19:43 <nand`> edwardk: was ‘all’ taken?
11:19:47 <JenLoveHewitt> it is important since the job isnt interesting(for me) but the money is
11:20:00 <edwardk> > all [True,False]
11:20:01 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
11:20:02 <lambdabot>         against inferred ...
11:20:02 <JenLoveHewitt> Axman6: how much is lots?
11:20:06 <nand`> oh
11:20:11 <edwardk> > all (>4) [5,6]
11:20:12 <c_wraith> all id!
11:20:13 <lambdabot>   True
11:20:20 <timthelion> edwardk: so _3 is a "lens" to the third item of the tuple, .~ is a function which takes a lense and a value and an object and replaces the part of the object which is focused by the lense with the value it's given?
11:20:20 <edwardk> > and [True,False]
11:20:22 <lambdabot>   False
11:20:23 <Axman6> JenLoveHewitt: if you don't find the job interesting, then they probably don't want you
11:20:27 <edwardk> timthelion: yep
11:20:29 <JenLoveHewitt> > all True [True, False]
11:20:31 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
11:20:31 <lambdabot>         against inferred ...
11:20:32 <slack1256> JenLoveHewitt: charge for the project not for the programming language used.
11:20:43 * timthelion gets lenses now
11:20:47 <JenLoveHewitt> > all (==rue) [True, False]
11:20:48 <edwardk> timthelion: and it can change the types involved as needed (and permitted by the lens)
11:20:49 <lambdabot>   Not in scope: `rue'
11:20:54 <nand`> > all id [True, False]
11:20:56 <lambdabot>   False
11:21:04 <JenLoveHewitt> > (all (==True) [True, False] , and [True,False])
11:21:06 <lambdabot>   (False,False)
11:21:08 <_flow_> is there an fast way to view haskell function documentation from emacs? like describe-function for elisp?
11:21:15 <edwardk> timthelion: (1,2,"hello")^._3  will return "hello" as well
11:21:39 <timthelion> edwardk: what if I do _3 .~ "foo" $ (1,2,3,4)
11:21:41 <edwardk> so with ^. and .~ you have enough to be productive with lenses, but there are a lot of extra things you can do with the lens package, like make getters, setters, etc.
11:21:44 <JenLoveHewitt> Everybody wants Jennifer Love HEwitt
11:21:49 <nand`> timthelion: (1,2,"foo",4)
11:21:50 <edwardk> that works now too with the code i'm adding
11:21:58 <timthelion> nand`: really !!! :D
11:22:02 <timthelion> cool
11:22:12 <timthelion> so it IS better than fst and snd
11:22:19 <edwardk> works up to 9-tuples
11:22:20 <Cale> but _3 is such an ugly name for something that's meant to be used :(
11:22:28 <slack1256> JenLoveHewitt: the 90's called
11:22:40 <c_wraith> Cale: would you prefer the name #3 ? :)
11:22:42 <nand`> Cale: I don't think they're too ugly, better than coming up with silly three-letter aliases for numbers
11:22:43 <timthelion> edwardk: and if you were to copy-paste-re-edit once more it would work up to 18 tuples?
11:22:48 <slack1256> Cale: WarmFussyThing3 maybe?
11:22:50 <edwardk> Cale: allOf (traverse._2) (>4) [("hello",5),("world",6)]
11:22:58 <edwardk> it is intended to mostly vanish when composed with .
11:23:17 <edwardk> timthelion: well the names start getting uglier ;)
11:23:25 <edwardk> and its O(n^2) work for me
11:23:36 <Cale> hehe, pi3 ;)
11:23:38 <timthelion> hmm :/
11:23:40 <Axman6> is it O(n^2) work for TH though?
11:23:45 <danil> Cale: In Habit you could just use 3 -- their overloaded integer literals use an instance that depends on the (type-level) number
11:23:45 <c_wraith> switch to TH to generate them!
11:23:46 <parcs`> instance Functor f => Num ((b -> f b) -> a -> f a) where ...
11:23:56 <edwardk> Axman6: no, i don't use TH to generate code in lens itself, mostly to make the package install faster
11:24:01 <nand`> Cale: π₃ ?
11:24:12 <c_wraith> π3 is readonable to type
11:24:21 <c_wraith> the subscript, less so :)
11:24:25 <Axman6> edwardk: seems to me it could all be automated quite simply anyway
11:24:28 <edwardk> sure
11:24:42 <edwardk> but i figure covering through 9 tuples is a pretty good cutoff
11:24:51 <slack1256> nand`: that's a kind of good name.
11:24:52 <nand`> I've never used more than three, honestly
11:24:56 <c_wraith> doesn't ghc cut off before that?
11:25:00 <c_wraith> for at least some functions?
11:25:04 <timthelion> edwardk: and it's a typeclass and we can always extend our own instances anyways?
11:25:08 <edwardk> timthelion: yep
11:25:26 <edwardk> and the way the class is written you can use these for monomorphic 'tuple-like' types as well
11:25:45 <nand`> Data.Tuple.Curry has an instance Curry ((a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) -> r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> a11 -> a12 -> a13 -> a14 -> a15 -> r)
11:25:49 <edwardk> e.g. data Vec3 = Vec3 {-# UNPACK #-} !Double {-# UNPACK #-} !Double {-# UNPACK #-} !Double
11:25:59 <nand`> re: c_wraith
11:26:16 <c_wraith> :t uncurry3
11:26:18 <lambdabot> Not in scope: `uncurry3'
11:26:21 <nand`> and I think that's the largest I've seen
11:26:31 <c_wraith> meh.  if you can handle 3-tuples, you're better than the prelude :)
11:26:39 <edwardk> in scala the products run up to ~23 because you can't make a function that takes more than that many arguments
11:26:40 <nand`> oh
11:26:43 <nand`> edwardk: http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Select.html
11:26:57 <nand`> looks like some of your work has already been done
11:27:06 <nand`> Data.Tuple.Update too
11:27:31 <edwardk> well, i can't lean on it from here, and the lens is a bit trickier, but good on lennart ;)
11:29:45 <nand`> edwardk: seems like it doesn't directly cooperate either way, I tried ‘lens sel1 upd1’ but it type errors when using
11:29:56 <nand`> ambiguous type error
11:30:04 <edwardk> yeah making the types flow forward and back was why i used the TFs
11:30:26 <nand`> it has Data.Tuple.Sequence too, even :P
11:30:45 <nand`> which could be used to make traversables
11:30:49 <nand`> oh well
11:30:51 <edwardk> heh, well that will be 'tuple' in Control.Lens.Traversal or Data.Tuple.Lens
11:30:56 <DMcGill> is there a nice function that's the same as
11:31:07 <edwardk> probably Data.Tuple.Lens
11:31:09 <DMcGill> onNonEmpty f [] = []; onNonEmpty f xs = f xs
11:31:09 <DMcGill> ?
11:31:24 <DMcGill> and by "nice" I meant "library"
11:31:47 <DMcGill> perhaps taking advantage of the MonadPlus instance?
11:31:47 <edwardk> DMcGill: no
11:32:06 <nand`> his code looks funny too: http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/src/Data-Tuple-Select.html
11:32:17 <DMcGill> Monoid I meant
11:33:08 <DMcGill> nand`: that is very unfunny code
11:33:20 <latro`a> looking at that code makes me want to finally understand what this is about: http://hackage.haskell.org/packages/archive/hmatrix/0.14.0.1/doc/html/src/Data-Packed-Internal-Common.html#app1
11:33:46 <nand`> best comment ever
11:34:37 <EvanR> so someone was interested in learning programming yesterday and said he knows basically nothing
11:34:51 <mekeor> omg
11:34:54 <latro`a> the frustrating thing is that understanding how to imitate hmatrix would really require understanding how app3 works
11:35:08 <latro`a> also app2
11:35:13 <DMcGill> that code makes a compelling argument for TH
11:35:13 <latro`a> the higher ones are never used afaict
11:35:38 <nand`> code like that always makes me cringe. it follows a clear pattern, but I can't seem to express it directly
11:36:05 <latro`a> the ww ones are easier to understand
11:36:15 <latro`a> though I don't understand the point of them nonetheless
11:36:30 <timthelion> EvanR: and?
11:36:32 <EvanR> so i said haskell, and im thinking of links to give him
11:36:36 <nand`> I'm not convinced TH is the solution either; I'd like the ability to, say, work with 100-tuples without the appropriate compilation taking quadratic or whatever time/space
11:36:38 <EvanR> tryhaskell, learnyou a haskell
11:36:54 <timthelion> EvanR: yes?
11:37:02 <EvanR> will that be sufficient?
11:37:12 <nand`> depends
11:37:15 <EvanR> to write real programs you need like IO stuff
11:37:20 <nand`> sufficient to decide whether he likes haskell or not? probably
11:37:32 <nand`> LYAH and RWH cover IO stuff, at least at a basic level
11:37:35 <timthelion> EvanR: The average person cannot learn to program at all.
11:37:42 <EvanR> and ability to write recursive functions for stuff theres no Control.Monad function for
11:37:50 <nand`> timthelion: I believe that's wrong
11:38:14 <nand`> timthelion: perhaps you meant ‘program well’? I imagine every person is trivially capable of producing a trivial program in a trivial language, for example
11:38:23 <EvanR> i thought haskell would be a good to start from scratch with
11:38:30 <EvanR> im wondering if thats true now
11:38:39 <DMcGill> no bad habits to forget!
11:38:44 <DMcGill> start with LYAH
11:38:54 <nand`> I can't judge that since I didn't start from scratch with Haskell but it seems like the choice I'd make
11:38:59 <DMcGill> and then if needs be afterwards, link to some papers etc
11:39:11 <timthelion> nand`: I asked 9 girls and 3 boys at my school why so few women program(ok, women and men, this is college) and all 9 of the 9 girls said that women don't have what it takes, and all of them men said that women aren't interested in such a profession.
11:39:14 <EvanR> is tryhaskell good for this situation or is tryhaskell for refugees from other languages with interactive inteprreters
11:39:20 <nand`> LYAH does seem to orient itself towards established programmers new to functional languages, afaik
11:39:27 <nand`> it's still a good introduction to Haskell itself for that matter
11:39:33 <DMcGill> tryhaskell is GHCI in a browser with a tutorial that's worse than LYAH's
11:39:55 <DMcGill> or at least, much shorted
11:39:58 <EvanR> timthelion: the hot 24-35 year old girls who world here are girls to me ;)
11:40:02 <DMcGill> s/shorted/shorter
11:41:24 <EvanR> seems like rails and similar frameworks are somehow easily setup by relative noobs
11:41:30 <EvanR> can the same be said of any sort of haskell web stack
11:41:48 <nand`> I don't think web frameworks are a good way to begin programming in any language
11:41:58 <nand`> especially if you're new to programming altogether
11:41:59 <EvanR> no but thats the 'killer app' apparently for anything
11:42:25 <Cale> timthelion: I think "The average person cannot learn to program at all." is untrue. It's just that the average person has no interest in learning to program. I think anyone who puts at least 10000 hours into trying will be capable.
11:42:28 <danil> EvanR: I think the Haskell frameworks have one more step than rails, which is "install cabal"
11:42:40 <hpaste> Timothy annotated “ThreadObject error” with “ThreadObject error (annotation)” at http://hpaste.org/72924#a72926
11:42:48 <nand`> danil: cabal comes with ghc
11:42:56 <EvanR> install cabal install ;)
11:43:05 <nand`> bah, cabal-install :)
11:43:05 <latro`a> with *GHC*? what
11:43:11 <timthelion> OK, so why am I getting this error, see annotation?
11:43:16 <latro`a> with the platform, sure, but, what
11:43:30 <nand`> latro`a: sorry, maybe I'm mistaken
11:43:52 <timthelion> No instance for (Num (GHC.Prim.Any *))
11:43:55 <EvanR> alright sending links now
11:43:56 <latro`a> just GHC is actually surprisingly little
11:44:19 <nand`> latro`a: it seems you were right, cabal is an extra package here
11:44:39 <latro`a> for example, even something like Random isn't in GHC
11:44:43 <timthelion> latro`a: what 534 mb is little?
11:44:59 <latro`a> the amount of stuff that comes with just GHC is surprisingly little, given its size
11:45:04 <nand`> timthelion: if you subtract the amount of that that's just bloat?
11:45:43 <timthelion> nand`: targzipped it's 50 something and you take it out of the tarball and it grows by a factor of ten!
11:46:09 <nand`> also, tghc is 26 MB here
11:46:11 <nand`> ghc*
11:46:26 <edwardk> *** Exception: compiler/rename/RnSource.lhs:429:14-81: Irrefutable pattern failed for pattern Data.Maybe.Just (inst_tyvars,
11:46:26 <edwardk>                                                         _,
11:46:28 <edwardk>                                                         SrcLoc.L _ cls,
11:46:29 <edwardk>                                                         _)
11:46:30 <nand`> ghc-7.4.2-src.tar.bz2
11:46:30 <edwardk> thats a new one on me ;)
11:46:52 <roconnor> _head _ [] = error "_head: empty list"
11:46:56 <timthelion> nand`: I'm going by the arch linux repos.
11:46:58 <roconnor> Whyyyyyyyyyyyyyyyyyyyyyyyyyy
11:46:59 <nand`> ‘Irrefutable pattern failed’ <- but I thought it was irrefutable!
11:47:06 <nand`> timthelion: gentoo here
11:47:19 <timthelion> nand`: so in gentoo you get half as much stuff
11:47:25 <nand`> precisely
11:47:27 <nand`> :
11:47:29 <roconnor> KHHHHHHHHHHHHHAN!
11:47:29 <nand`> :)
11:47:46 <timthelion> roconnor: u o k?
11:47:47 <EvanR> bombs away
11:47:54 <nand`> timthelion: it's actually 63 MB unpacked here
11:48:00 <roconnor> timthelion: nope
11:48:12 <timthelion> roconnor: what's so bad about this?
11:48:46 <roconnor> timthelion: I'm upset by _head
11:49:07 <timthelion> roconnor: what's wrong with that deffinition?
11:49:16 <EvanR> if/when he finds haskell isnt suitable, ill be sure to explain what his problems are in here ;)
11:49:19 <EvanR> if he doesnt show up
11:49:33 <DMcGill> get him to ask himself
11:49:34 <edwardk> roconnor: sorry man
11:49:34 <roconnor> timthelion: same problems that head has
11:49:42 <edwardk> roconnor: yeah
11:49:44 <DMcGill> iirc runhaskell has a link to this irc
11:49:45 <roconnor> edwardk: I feel better after screaming
11:49:54 <EvanR> DMcGill: already directed him here
11:49:57 <edwardk> use headOf traverse ;)
11:50:07 <edwardk> or element 0
11:50:17 <timthelion> edwardk: are those Maybe typed?
11:50:18 <edwardk> well, element 0 gives you the same problem
11:50:24 <edwardk> headOf traverse is Maybe typed
11:50:49 <edwardk> traverseHead can be used with Maybe to give you what you want as well
11:50:50 <timthelion> roconnor: isn't there a SafePrelude where everything even div is Maybe typed?
11:51:03 <nand`> edwardk: only if the list contents form a monoid
11:51:13 <edwardk> nand`: hence the use of Just
11:51:45 <roconnor> edwardk: where is the function restricting a traverse to the nth element?
11:51:49 <timthelion> > {-like-}transverseHead $ Just []
11:51:50 <lambdabot>   Not in scope: `transverseHead'
11:51:57 <nand`> edwardk: well for example Maybe Int doesn't work
11:52:03 <timthelion> Shut up lambdabot
11:52:16 <edwardk> roconnor: there is an 'elementOf' that assumes the element is present and gives you a lens. i used to have one that took a predicate on positions, but i don't think its in there right now
11:52:20 <EvanR-tryhaskell> haha
11:52:58 <edwardk> it was called traverseElementsOf and it took a traversal and a predicate on their positions and gave you a travesal
11:53:02 <timthelion> EvanR-tryhaskell: did you just hack tryhaskell by preforming unsafe IO?
11:53:10 <EvanR-tryhaskell> yes
11:53:11 <roconnor> edwardk: ah okay;  I don't really need it anyways at the moment; Using Int is somewhat poor form anyways.
11:53:16 <timthelion> :P
11:53:19 <nand`> edwardk: just a thought, maybe the variable for Isomorphic and Indexed in use could be swapped out; currently they're both ‘k’
11:53:19 <DMcGill> timthelion: no, tryhaskell is also an irc client
11:53:22 <edwardk> i'll probably swap it to something that takes an indexed traversal and a predicate on the keys to give you an indexed traversal where the keys match
11:53:35 <timthelion> DMcGill: OK
11:53:39 <edwardk> they are both k because they are both being used to overload the same position
11:53:52 <EvanR-tryhaskell> its not ghci, because i cant use 'it' ;)
11:54:00 <edwardk> k (c -> f d) (a -> f b) and the two feature sets are incompatible
11:54:08 <DMcGill> see also: IO on lambdabot
11:54:10 <mm_freak_> EvanR-tryhaskell: please report that
11:54:16 <edwardk> plus the mnemonic of using k for category
11:54:24 <EvanR-tryhaskell> mm_freak_: i just did? ;)
11:54:25 <nand`> I didn't even realize that one
11:54:31 <edwardk> (even if Index isn't a category)
11:54:47 <nand`> I would have expected either ‘a’ for arrow or ‘c’ for category, unfortunately both are taken
11:54:52 <edwardk> yep
11:55:03 <mm_freak_> EvanR-tryhaskell: not just here, but also to the maintainer, so he can propagate the report to relevant library authors
11:55:15 <mm_freak_> EvanR-tryhaskell: this might be a bug in some safe evaluation library
11:55:22 <edwardk> historically i'd use (~>) or some crap but spj indicated he may want to change the way type operators get bound
11:55:25 <edwardk> so i've been avoiding them
11:55:41 <mm_freak_> so it might be a security risk to the whole haskell community
11:55:50 <EvanR-tryhaskell> how?
11:55:55 <EvanR-tryhaskell> is 'it' supposed to work?
11:56:11 <edwardk> roconnor: if you just want to read from it, you can use ifiltered to make a filtered indexed fold from an indexed fold
11:56:12 <EvanR-tryhaskell> well, lambdabot can send a message to chrisdone right
11:56:12 <mm_freak_> EvanR-tryhaskell: that's not what i mean…  i mean the fact that you can perform unsafe IO
11:56:23 <EvanR-tryhaskell> haha i didnt use unsafePerformIO
11:56:41 <timthelion> EvanR-tryhaskell: what did you use?
11:56:46 <EvanR-tryhaskell> 'chat'
11:56:48 <mm_freak_> i'd be surprised if that worked anyway
11:57:04 <nand`> tryhaskell has a built-in IRC client; as has been mentioned
11:57:08 <nand`> this is entirely expected behavior
11:57:14 <mm_freak_> oh lol
11:57:17 * timthelion giggles.
11:57:19 <mm_freak_> ok, then i'm fine =)
11:57:21 <EvanR-tryhaskell> every time you type chat<enter> to spawns a new irc client in the browser
11:57:41 <mm_freak_> never triedhaskell =)
11:58:00 <nand`> besides, isn't the point of safe evaluation libraries / SafeHaskell to be fundamentally proven never to execute unsafe code? :P
11:58:27 <timthelion> nand`: you cannot prove anything in real life, you can only prove based on assumptions.
11:58:31 <mm_freak_> nand`: yeah, but the notion of "safe" is library-dependent
11:58:50 <nand`> oh, right
11:59:05 <nand`> it allows some unsafe functions as long as the library flags them, right?
11:59:16 <nand`> otherwise stuff like bytestring etc. may not be possible
11:59:31 <timthelion> nand`: for example, some idiot in here decided to make an FFI to the perl regex utility.  And what if there is a security hole in perl regex and his FFI is marked safe?
11:59:33 <edwardk> nand`: safe is intended to avoid subverting the type system by allowing you to crash the rts, etc. its not a notion of something safely executable.
11:59:52 <nand`> oh
11:59:56 <edwardk> you still need to build whatever quarantining system you want on top of SafeHaskell
12:00:02 <EvanR> unsafeLaunchMissiles
12:00:12 <nand`> so I could still gain control of lambdabot and hatch my world domination scheme given a broken enough library
12:00:19 <mm_freak_> safeLaunchMissiles
12:00:21 <timthelion> nand`: yep :D
12:00:21 <edwardk> it simply is out to ensure that the code can't do things like, say cast a data type to a function and call it
12:00:27 <edwardk> yes
12:00:50 <mm_freak_> nand`: basically it's really just an attribute of modules and SafeHaskell checks your imports
12:01:20 <timthelion> nand`: for example, if the idiot who wrote the regex FFI didn't sanitize his regexes well enough, you might be able to execute perl code on the lambabot server.
12:01:23 <edwardk> for instance with lens, Language.Haskell.TH.Lens and Control.Lens.TH are flagged trustworthy, and the rest are safe-inferred
12:04:17 <plat0> @pl (prod f x () = f x)
12:04:18 <lambdabot> (line 1, column 13):
12:04:18 <lambdabot> unexpected " "
12:04:18 <lambdabot> expecting variable, "(", operator or ")"
12:04:36 <plat0> @pl (\f x () -> f x)
12:04:37 <lambdabot> (line 1, column 9):
12:04:37 <lambdabot> unexpected " "
12:04:37 <lambdabot> expecting pattern or "->"
12:05:21 <ParahSailin_> @pl (\f x _ -> f x)
12:05:21 <lambdabot> (const .)
12:05:36 <plat0> oh i see
12:05:38 <plat0> () is a value
12:05:41 <plat0> not a variable
12:05:46 <plat0> Thanks ParahSailin_
12:05:53 <EvanR> () is also a type
12:06:19 <plat0> @pl (prod f x _ = f x)
12:06:20 <lambdabot> (line 1, column 11):
12:06:20 <lambdabot> unexpected "_"
12:06:20 <lambdabot> expecting variable, "(", operator or ")"
12:06:28 <EvanR> @src ()
12:06:29 <lambdabot> data () = ()
12:06:36 <nand`>  @pl only accepts expressions
12:06:39 <plat0> I see.
12:06:47 <plat0> That's fair enough.
12:07:15 <ParahSailin_> @pl prod f x _ = f x
12:07:16 <lambdabot> prod = (const .)
12:07:41 <plat0> oh
12:07:44 <nand`> apparently it also only accepts a certain subset of let...in expressions
12:07:53 <nand`> oh, sorry
12:07:55 <nand`> my information was incorrect
12:08:10 <plat0> That's ok.
12:08:22 <nand`>  @pl did accept definitions, but only very certain kinds of them
12:08:29 <EvanR> @pl (\f x _ -> f x)
12:08:30 <lambdabot> (const .)
12:08:31 <nand`> I think you can't do any pattern matching involving constructors
12:08:56 <nand`> hmm, that's not entirely true either
12:08:57 <Taneb> @pl f Nothing = 0; f (Just a) = a
12:08:58 <lambdabot> (line 1, column 14):
12:08:58 <lambdabot> unexpected ";"
12:08:58 <lambdabot> expecting digit, variable, "(", operator or end of input
12:08:58 <nand`> @pl f (x,y) = x+y
12:08:59 <lambdabot> f = uncurry (+)
12:09:04 <nand`> it works for tuples, apparently
12:09:11 <Taneb> And not Maybe
12:09:36 <nand`> @pl f (x:xs) = x
12:09:36 <lambdabot> f = head
12:09:37 <timthelion> > 1/0
12:09:38 <EvanR> @pl f True = 0; f False = 1
12:09:38 <lambdabot>   Infinity
12:09:39 <lambdabot> (line 1, column 11):
12:09:39 <lambdabot> unexpected ";"
12:09:39 <lambdabot> expecting digit, variable, "(", operator or end of input
12:09:47 <timthelion> Infinity! Is this a joke???
12:09:49 <nand`> it does seem to accept certain forms
12:09:51 <latro`a> lol, infinity
12:09:53 <EvanR> > (-1)/0
12:09:55 <lambdabot>   -Infinity
12:09:59 <EvanR> > 0/0
12:10:00 <lambdabot>   NaN
12:10:01 <nand`> timthelion: IEEE floats
12:10:08 <nand`> they have observable infinity
12:11:04 <EvanR> > 1 `div` 0
12:11:05 <lambdabot>   *Exception: divide by zero
12:11:08 <EvanR> timthelion: ^
12:11:22 <nand`> > 1 / 0 :: Rational
12:11:24 <lambdabot>   *Exception: Ratio.%: zero denominator
12:11:37 <nand`> and of course, here's the only reasonable implementation:
12:11:39 <nand`> > 1 / 0 :: CReal
12:11:43 <lambdabot>   mueval-core: Time limit exceeded
12:11:49 <EvanR> whuuu
12:12:37 <timthelion> nand`: :O
12:13:01 <Reaga> hey, i need a funciton which mutates existing variables
12:13:07 <Reaga> does such a function exist?
12:13:09 <EvanR> no
12:13:18 <Reaga> are you sure?
12:13:27 <EvanR> depends on what youre calling variables
12:13:29 <timthelion> Reaga: you need to either recurse, or you need to use a mutable type inside a monad
12:13:29 <monochrom> are you really learning haskell? what code have you written?
12:13:30 <latro`a> depends what a variable is, yeah
12:13:59 <timthelion> Reaga: but mostly, you just need to recurse
12:14:13 <EvanR> mostly you need IO to mutate
12:14:21 <eikke> or ST
12:14:24 <nand`> or State to simulate mutating
12:14:26 <timthelion> recurse: to say fuck, and then say fuck again.
12:14:33 <eikke> or STM
12:14:39 <timthelion> or STD
12:14:40 <nand`> or automatons
12:14:44 <monochrom> or are you just idly musing haskell, so people should know and decide how much time to spend on you?
12:15:06 <timthelion> troll
12:16:57 <monochrom> I mean, it seems like broad-question-of-the-day to me so far. "is haskell all about recursion" yesterday, for example
12:17:24 <nand`> is recursion all about recursion?
12:17:46 <timthelion> >fuck = fuck
12:17:54 <timthelion> > let fuck = fuck in fuck
12:17:58 <lambdabot>   mueval-core: Time limit exceeded
12:18:00 <eikke> today is "Is Haskell best suited for conservative voters?" :-P
12:18:00 <danharaj> can we stop
12:18:05 <edwardk> please
12:18:15 <Taneb> eikke, I'm a liberal in a conservative family
12:18:27 <Taneb> Should I be using Scala or something?
12:18:32 <danharaj> --- #haskell-blah ---->
12:18:43 <Taneb> Yeah, I'm done
12:19:23 <EvanR> --- o_O -->
12:19:42 <edwardk> EvanR: that looks like it hurt
12:20:09 <EvanR> this is your face on arrow frp
12:20:18 <monochrom> haha
12:20:20 <nand`> edwardk: I like ‘fresh’
12:20:25 <edwardk> nand`: =)
12:20:27 <nand`> EvanR: heh
12:20:29 <edwardk> it even reads right!
12:20:35 <edwardk> fresh = id <+= 1
12:20:37 <nand`> edwardk: ‘id’ hehe
12:21:12 * nand` feels like it should be <-- o_O --< then
12:21:23 <nand`> or just <- -<
12:21:35 <edwardk> nand`: oh i wrote a bunch of multiplates using arrow notation and lenses the other day
12:21:43 <nand`> multiplates?
12:21:50 <danharaj> I never got why they're called plates.
12:21:52 <danharaj> Or what they are.
12:21:54 <edwardk> me neither
12:21:58 <edwardk> at least the name
12:22:09 <monochrom> may be related to boilerplates
12:22:09 <edwardk> i suppose it goes back to uniplate, and that was for 'boilerplate'
12:22:10 <roconnor> danharaj: plate comes from "boilerplate" I believe
12:22:23 <danharaj> I see.
12:22:25 <nand`> edwardk: I read my way into arrow notation the other day and went through some netwire examples; I still haven't an inkling of a clue what I'd use arrow notation with lenses for
12:22:57 <roconnor> danharaj: in multiplate, a plate is a multisorted coalgebra if that helps
12:23:00 <edwardk> nand`: for lenses its boring you only have sequential composition
12:23:07 <Reaga> hey, i just read an article saying that haskell access elements of an array in time O(log n) rather than O(1). is this true?
12:23:07 <edwardk> with multiplates you can make better use
12:23:10 <edwardk> consider something like
12:23:23 <EvanR> Reaga: no
12:23:29 <edwardk> (a -> f b, c -> f d) -> Either a c -> f (Either b d)
12:23:38 <edwardk> look like a lens/traversal?
12:23:52 <nand`> if only the types ligned up
12:23:52 <edwardk> i tupled the args so you can see that you could use it as an arrow
12:23:54 <plat0> I'm rather confused about arrows.  first f >>> second g is not guaranteed to be second g >>> first f so it seems rather hard to understand the semantics for them.  They don't seem closely related to any form of category, for example.
12:23:55 <nand`> lined*
12:23:57 <roconnor> Reaga: since it takes O(log n) time just to read an index, no one can access an array in O(1) time.
12:24:09 <edwardk> so you can then use arrow notation to feed in lenses of traversas for its arguments
12:24:10 <roconnor> plat0: I agree
12:24:25 <latro`a> lol, cute roconnor
12:24:27 <danharaj> plat0: they are equal when the effects of f and g commute.
12:24:34 <plat0> Yes
12:24:38 <latro`a> though that one is basically quibbling about what a primop is
12:24:43 <Reaga> roconnor: heh... interesting... ?
12:25:05 <edwardk> prox v -> do x <- _1 -< v; y <- _2 -< v; _either <- (x,y)
12:25:07 <latro`a> reaga: an index takes logn bits to store, which means it takes logn bit-reads to determine what it is
12:25:07 <edwardk> er proc
12:25:28 <nand`> danharaj: are they equal for ‘pure’ arrows? (f &&& f  =  f >>> id &&& id)
12:25:29 <Reaga> so why the hell have i been told reading an array takes O(1) time
12:25:35 <EvanR> latro`a: 'determine what it is', i dont see how this is a necessary step in real life implementation of anything
12:25:47 <Reaga> reading an element of an aray at index i takes O(1) time <- thats what ive been told my whole life
12:25:48 <edwardk> Reaga: when people talk about asymptotics they use some abstract machine to talk about it
12:25:49 <plat0> In 3 dimensional  space it takes O(n^(1/3)) time to get the data from the store to the cpu.
12:25:51 * Reaga its all a lie
12:25:51 <danharaj> nand`: idk
12:26:00 <latro`a> it depends on the background abstract machine, yeah
12:26:05 <edwardk> on a random access machine where you are assume to be able to add offsets to pointers, it takes O(1)
12:26:07 <edwardk> in that model
12:26:18 <EvanR> latro`a: for example if i were implementing an if statement where the values of true and false are functions, i dont have to 'determine what it is' to branch
12:26:18 <roconnor> Reaga: often people compare Haskell *maps* to arrays in other languages and lement the log n access factor in the Map lookup; but they are comparing apples to oranges.  Map lookup for bounded keys, like Int is also O(1)
12:26:19 <danharaj> of course that model doesn't correspond to reality :P
12:26:21 * mekeor gets headache with so much traffic on #haskell…
12:26:23 <edwardk> but the mapping of that model onto real hardware takes an extra O(log n) when you count bits
12:26:29 <nand`> edwardk: surely that must depends on the size of the offsets you're adding too :)
12:26:43 <latro`a> edwardk is saying what I meant more clearly, EvanR
12:26:45 <edwardk> nand`: the RAM model is an approximation, its useful at certain scales
12:26:47 <Reaga> oh
12:27:08 <neothemachine> easy challenge for the evening (at least in Germany it is :P): how to transform [a] into an indexed Array Int a? did I miss something built-in? at the moment: toArray xs = array (1,n) (zip [1..n] xs) where n = length xs
12:27:09 <EvanR> yeah
12:27:28 <edwardk> Reaga: now, Data.Array indexes in O(1) under RAM assumptions
12:27:40 <edwardk> Reaga: so wherever you got that is false, when talking about haskell arrays
12:27:51 <roconnor> neothemachine: looks okay to me
12:27:52 <Taneb> Maybe it's talking about Sequences?
12:27:56 <edwardk> but we don't use Arrays in all the places that other people do
12:28:17 <edwardk> Data.Sequence provides a growable array, c++ gives this to people as a 'vector' for instance
12:28:20 <latro`a> neothemachine, you can be lazy and omit the n in [1..n]
12:28:21 <EvanR> of course, since all computers must be physically implemented as very long turing tape machines, nothing can be faster than O(n) because thats how long it takes to reel the tape
12:28:23 <edwardk> we move the asymptotics around a bit though
12:28:30 <EvanR> very unfortunate
12:28:33 <edwardk> they ensure they always have a contiguous region of memory and so get O(1) access
12:28:37 <latro`a> can't avoid computing length xs, however, unfortunately
12:28:40 <edwardk> but the growth can be very very expensive
12:28:42 <Taneb> We also have Vector, Set, lazy lists, IntMaps...
12:28:46 <edwardk> on the other hand growing a sequence is O(1)
12:29:06 <edwardk> we have other container types that are closer to what you'd expect depending on what language you are coming from
12:29:21 <DMcGill> I enjoyed my turing machine programming for unary and binary stuff
12:29:37 <neothemachine> latro`a: omitting n is just for convenience, right? nothing else changes?
12:29:46 <edwardk> neothemachine: correct
12:30:01 <neothemachine> ok
12:30:03 <EvanR> haha, omit the n in [1..n] makes you lazy
12:30:06 <latro`a> the semantics don't change; "zip [1..] xs" ends when xs runs out
12:30:34 <latro`a> though I'm not sure if the semantics change if n is 0
12:30:46 <latro`a> nope, they don't
12:30:53 <EvanR> > [1..0]
12:30:55 <lambdabot>   []
12:30:58 <latro`a> ^that being why
12:31:04 <neothemachine> ah
12:31:26 <neothemachine> well, saved one char, I think it was worth it :D thanks guys
12:31:54 <latro`a> to just get an assoc list of indices, when you don't need to tell the system the bounds, "zip [1..] xs" is (probably) faster than "zip [1..length xs - 1] xs"
12:31:56 <nand`> Achievement Unlocked: Micro-optimization thanks to #haskell
12:32:08 <latro`a> eeerm
12:32:09 <latro`a> length xs
12:32:10 <EvanR> if only optimization was a matter of saving characters ;)
12:32:10 <latro`a> no -1
12:32:12 <EvanR> in the source
12:32:19 <edwardk> nand`: needs more codensity
12:32:26 <nand`> EvanR: that's the only sort of optimization I know :)
12:32:29 <nand`> edwardk: true
12:32:56 <DMcGill> now we just need a Haskell minimiser
12:33:03 <nand`> though that may be co-optimization, depending on how you see it :)
12:33:11 <DMcGill> and/or obfusticator
12:33:16 <nand`> we have an obfuscator
12:33:19 <neothemachine> hmm why would it be faster? I use length n anyway
12:33:26 <neothemachine> eh, length xs
12:33:32 <neothemachine> for array (1,n)
12:33:37 <nand`> @. unpl pl \f x y -> f (y x x)
12:33:37 <lambdabot> (\ n q k -> n (((\ e f -> f e) >>= \ a b c -> a c b) q k))
12:33:48 <nand`> repeat as necessary
12:34:10 <DMcGill> anybody that hasn't seen the code example on this page should do so: http://www.haskell.org/haskellwiki/Obfuscation
12:34:14 <DMcGill> it is beautiful
12:34:32 <neothemachine> oh boy
12:34:41 <EvanR> we should switch from js to haskell for web shit because its easier to obfuscate!
12:34:48 <DMcGill> thus more secure!
12:34:52 <EvanR> yes
12:34:59 <nand`> “Succ Zeroth Obfuscated Haskell Contest”
12:35:06 <EvanR> obfuscated in such a way to make understanding it in any way computationally intractable or worse
12:35:07 <nand`> EvanR: but you can compile Haskell down to some pretty obscure JS
12:35:12 <nand`> obfuscated, even
12:35:33 <EvanR> theoratically impossible!
12:35:39 <DMcGill> just implement Haskell -> Turing Machine compiler
12:35:46 <DMcGill> good luck decompiling that
12:36:02 <EvanR> haha turing machine target
12:36:08 <EvanR> love it
12:36:28 <timthelion> EvanR: see the current haskell-blah discussion on ubfuscated js...
12:37:10 <monochrom> that was an hour ago
12:37:22 <timthelion> monochrom: but only 5 lines ago
12:37:28 <monochrom> heh ok!
12:37:53 <nand`> at least parts of it can't have been more than 37 minutes ago
12:37:54 <EvanR> my temporal existence is based on irc lines of chat
12:38:01 <EvanR> not fucking hyperfine transitions
12:38:19 <EvanR> timestamps are just decorative
12:41:30 <k0ral> @hoogle m (a -> b) -> a -> m b
12:41:31 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:41:32 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:41:32 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:43:27 <copumpkin> :t flip :: Applicative m => m (a -> b) -> a -> m b
12:43:28 <lambdabot> forall (m :: * -> *) a b. (Applicative m) => m (a -> b) -> a -> m b
12:43:37 <DT``> :t (return .)
12:43:38 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
12:43:42 * hackagebot basic-prelude 0.1.0.0 - An enhanced core prelude, meant for building up more complete preludes on top of. (DanBurton)
12:44:40 <DT``> :t (return .) :: Monad m => (a -> b) -> a -> m b
12:44:41 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> a -> m b
12:44:50 <DT``> since when return's got a functor constraint?
12:45:13 <mauke> DT``: it doesn't
12:45:31 <nand`> the functor comes from (.)
12:45:46 <nand`> caleskell strikes again?
12:45:50 <DT``> :t (.)
12:45:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:45:55 <DT``> (.) = fmap?
12:45:58 <nand`> correct
12:46:04 <DT``> that's unusual.
12:46:09 <nand`> it is :)
12:46:13 <geekosaur> see "Caleskell"
12:46:19 <nand`> note that fmap on functions is just postcomposition
12:46:56 <DMcGill> ((->) a) is a Functor
12:47:05 <Cale> heh
12:47:08 <DMcGill> and (->) a b = a -> b
12:47:34 <Cale> Yeah, actually thinking about (.) as fmap is a rather good way to understand things like ((.).(.))
12:47:56 <nand`> :t fmap.fmap
12:47:57 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:47:58 <Cale> (consider (fmap . fmap) and then specialise)
12:47:59 <DT``> good ol' fmap fmap fmap.
12:48:01 <nand`> :t foldMap.foldMap
12:48:02 <lambdabot> Not in scope: `foldMap'
12:48:03 <lambdabot> Not in scope: `foldMap'
12:48:04 <nand`> :(
12:48:11 <nand`> traverse.traverse works too
12:51:23 <DMcGill> :t traverse . traverse
12:51:24 <lambdabot> Not in scope: `traverse'
12:51:24 <lambdabot> Not in scope: `traverse'
12:52:27 <zhulikas> :t fap
12:52:28 <lambdabot> Not in scope: `fap'
12:52:41 <zhulikas> need to write a function for that
12:54:09 <DMcGill> does anybody else find that they slowly accumulate tabs of documentation while programming?
12:54:27 <geekosaur> zhulikas, we did, it's called @pl ;}
12:54:42 <parcs`> what's a tab?
12:54:49 <DMcGill> browser tabs
12:54:50 <parcs`> oh, browser tab?
12:54:55 <mekeor> aah :D
12:55:08 <DMcGill> I had at least 3 copies of the WriterT docs open :/
12:55:10 <mekeor> DMcGill: yes.
12:56:08 <DT``> geekosaur, if fmap adds a functor constraint on map, fap shouldn't be fmap strictly for non-monads?
12:56:36 <DT``> ok, maybe I'm taking the joke too far...
12:56:47 <mekeor> :]
12:56:50 <DMcGill> look, I've programmed in Coq
12:56:59 <DMcGill> a function called "fap" is nothing
12:58:16 <mroman> DMcGill: Yeah.
12:58:26 <mauke> you may have a case for renaming ap to fap
12:58:29 <MostAwesomeDude> Hm. What's the general technique for frame-independent timers in, say, SDL?
12:58:31 <mauke> it's for applicative functors
12:58:37 <mroman> But as always I blame the browsers
12:58:54 <mroman> for not beeing able to merge multiple tabs horizontally into one tab
12:59:16 <mroman> so one can read different sections of a site without having to scroll up and down.
12:59:18 <mekeor> mroman: how should taht work?
12:59:28 <mekeor> ah, hm
12:59:39 <mroman> Horizontal tiles.
12:59:42 <matthiasgorgens> MostAwesomeDude: what do you mean?
13:00:01 <mroman> one with foo.html#bar, another one with foo.html#baz etc.
13:00:06 <nand`> DMcGill: I do. about 34 haskell-related tabs open right now, most of them haddocks
13:00:13 <geekosaur> splitting like in OSX Terminal (which almost nobody knows abut...)
13:00:14 * mekeor can't concentrate on coding while irc is open… :/
13:00:54 <mroman> Instead of implementing new stupid technology nobody *really* needs they could work on the user interface instead.
13:01:07 <mroman> and make browsers more awesome to use.
13:01:14 <mekeor> mroman: what do you refer to?
13:01:21 <mekeor> tab groups?
13:01:33 <MostAwesomeDude> matthiasgorgens: Okay, so in an imperative language, there's a game loop, right? And it has a handful of things to it.
13:02:16 <matthiasgorgens> MostAwesomeDude: do you know that talk (http://lambda-the-ultimate.org/node/1277) ?
13:02:20 <MostAwesomeDude> And one of those things is that it uses a timer to determine whether it should make a physics step or a graphics step, etc.
13:02:29 <parcs`> there should be an $ with high precendence
13:02:33 <matthiasgorgens> (that's a link to the slides.  I don't know whether there's a video to the actual talk.)
13:02:41 <nand`> parcs`: there is, it's called ‘ ’
13:02:49 <parcs`> or low precedence.. whatever the opposite is called
13:02:55 <nand`> $ has low precedence :)
13:02:57 <srhb> parcs`: High, and it is indeed ' '
13:03:02 <matthiasgorgens> MostAwesomeDude: that might give you a nice overview how one might use fp in game programming.
13:03:19 <parcs`> except that ' ' doesn't allow the introduction of a do block :)
13:03:24 <MostAwesomeDude> matthiasgorgens: Yeah, I guess I'll take a look at that.
13:03:28 <mroman> No @Tab groups.
13:03:33 <mroman> I wan't tab tiling.
13:03:35 <nand`> `id` might work
13:03:36 <mroman> *want
13:03:45 <parcs`> so you can do something like 'Foo <$> bar `id` do ...'
13:03:58 <mroman> I want lots of stuff no browser supports.
13:04:02 <parcs`> i know, i know, you can do fmap Foo $ bar $ do but still
13:04:33 <nand`> :t \foo -> Just <$> foo `id` do return 3
13:04:34 <lambdabot> forall a t (m :: * -> *) (f :: * -> *). (Num t, Monad m, Functor f) => (m t -> f a) -> f (Maybe a)
13:05:12 <MostAwesomeDude> matthiasgorgens: Nifty, thanks.
13:05:15 <srhb> parcs`: foo (do ...) but it'd be prettier to name it I guess?
13:05:24 <parcs`> :t Just <$> Foreign.Concurrent.newForeignPtr `id` do ?x
13:05:26 <lambdabot> forall a. (?x::GHC.Ptr.Ptr a) => IO () -> Maybe (IO (GHC.ForeignPtr.ForeignPtr a))
13:05:38 <nand`> when GHC picks letters like ‘m’ or ‘f’ for type class variables, do these just come from the definition of the class?
13:05:52 <DMcGill> mroman: time to start programming then!
13:05:59 <DMcGill> (or at least submit a feature request)
13:06:01 <johnw> if I want to write f x y in the applicative style, where "x" return m a, but "y" only returns b, what is the syntax for that?  f <$> x ??? y
13:06:27 <DMcGill> f <$> x <*> pure y
13:06:28 <nand`> <*> pure y -- works, but I think there's a combinator for it
13:06:28 <DMcGill> would work
13:06:43 <johnw> yeah, I'm wondering what the combinator is
13:06:48 <johnw> <*?
13:06:54 <matthiasgorgens> johnw: I often do flip f y <$> x there.
13:06:59 <matthiasgorgens> but that's not really good looking.
13:07:02 <srhb> :t (<*)
13:07:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:07:07 <mroman> DMcGill: Yeah... I don't have the experience nor the credentials to do that.
13:07:29 <matthiasgorgens> mroman: credentials?
13:07:35 <DMcGill> @src (<*)
13:07:36 <lambdabot> (<*) = liftA2 const
13:07:44 <nand`> @hoogle Applicative f => f (a -> b) -> a -> f b
13:07:44 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:07:44 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
13:07:44 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
13:08:02 <matthiasgorgens> const is pure for one specific instance.
13:08:09 <matthiasgorgens> (the reader monad, to be precise.)
13:08:34 <johnw> :t (*>)
13:08:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
13:08:48 <matthiasgorgens> (*>) is like (>>)
13:08:55 <johnw> oh yeah
13:09:00 <johnw> i remember seeing that
13:09:01 <mroman> I don't know a better word @credentials
13:09:07 <johnw> like f <$> (x *> y)
13:09:35 <daniel_-> is there a way to make cabal ignore build-depends or catch all when im still is in the early process of the project?
13:09:37 <matthiasgorgens> johnw: might as well make thet x >> f <$> y
13:09:39 <mroman> credibility?
13:09:45 <johnw> sure
13:09:47 <DMcGill> reputation?
13:09:48 <matthiasgorgens> but depends on your actual functions, to see which one makes more sense.
13:09:54 <johnw> but we love our options :)
13:09:57 <mroman> reputation sounds good.
13:10:03 <matthiasgorgens> there's more than one way to do it. :o)
13:10:10 <matthiasgorgens> mroman: you mean for putting in a feature request?
13:10:24 <matthiasgorgens> if you write the patch yourself, it will be it's own credential.
13:10:24 <mroman> That, and for programming, yes.
13:10:31 <DMcGill> mroman: confidence
13:10:37 <matthiasgorgens> DMcGill: :o)
13:10:46 <DT``> matthiasgorgens, I wish Applicative was Monad's superclass.
13:10:49 <DT``> *ducks*
13:11:01 <mroman> I also have no confidence.
13:11:16 <nand`> DT``: I think most of us would agree with you
13:12:07 <ReinH> holy god that Yegge thing is absolutely terribad
13:12:36 <johnw> @pl f <$> pure x
13:12:37 <lambdabot> f <$> pure x
13:12:48 <johnw> yeah, looks like that's as compact as it gets
13:12:53 <johnw> even though that's f x
13:12:59 <DT``> nand`, I never understood what would break if Applicative m => Monad m.
13:13:03 <ReinH> I'm not at all convinced that Ezra is doing Haskell any favors by agreeing to enter into it as if it's a reasonable dialog to be having
13:13:35 <DMcGill> johnw: I think you meant:
13:13:54 <DMcGill> @pl g x = f <$> pure x
13:13:54 <lambdabot> g = (f <$>) . pure
13:14:12 <johnw> shouldn't that decay to g = f?
13:14:17 <DMcGill> just calling pl on something that's not a function doesn't really do anything
13:14:24 <johnw> good to know
13:14:30 <danil> DT``: every package with types that are currently Monads but not Applicatives would have to declare one
13:14:42 <DMcGill> see: the Num/Show/Eq thing
13:14:42 <matthiasgorgens> DT``: everybody wishes that know.
13:14:55 <DMcGill> breaking compatibility with loads of old packages
13:19:29 <nand`> how many would those be, in practice?
13:20:35 <DT``> well, didn't GHC recently drop Show and Eq from Num anyway?
13:20:42 <DMcGill> yes
13:22:03 <DT``> how many packages did it irrecuperably break?
13:22:31 <DMcGill> hard to say. Actually updating code to accomodate the change was pretty easy
13:22:32 <DT``> I'd think that adding a constraint to relevant functions would be pretty easy to do mechanically.
13:22:40 <geekosaur> none irrecoverably, lots broken until new versions released with the necessary changes
13:23:03 <DMcGill> but just yesterday we had somebody ask about an error they were getting because they were trying to install code where Num implied Eq
13:23:16 <Clint> bitrot
13:23:19 <danil> it actually sounds easier to automate adding superclasses than removing them
13:23:44 * hackagebot ThreadObjects 0.0 - Mutable objects that reside in their own threads. (TimothyHobbs)
13:24:00 <danil> to figure out whether you have to add to the context you need to re-infer its type, but to add functor/applicative instances you'd just need to scan for monad instances without them
13:24:58 <timthelion> :)
13:25:14 <timthelion> The sweet poison of OOP is seeping it's way into haskell
13:25:25 <nand`> blame lenses
13:25:40 <timthelion> I'm refering to the package I just released.
13:25:50 <timthelion> which, by the way, is awsome
13:25:59 <nand`> and I'm referring to the lenses somebody will inevitably write for it to make it feel more OOPy
13:27:58 <timthelion> That is a package, with mutable objects that are mutated with an update :: ThreadObject a signal -> (a -> a) -> IO a -- function.  And if that (a->a) throws an error, for example, division by zero, it's as if the update never happened(of course an error dialog will appear or something) but no actuall damage is caused by the update, the old value is retained...
13:29:29 <MostAwesomeDude> matthiasgorgens: That was a pretty nifty set of slides, but it didn't really get to the meaty part, which is about how to actually implement this sort of thing.
13:29:29 <timthelion> got the type wrong there, update :: ThreadObject a signal -> (a->a) -> IO ()
13:30:38 <johnw> i'm confused why this doesn't type check: putStrLn $ show . length <$> getArgs
13:30:51 <johnw> shouldn't the arg to putStrLn now be a String?
13:30:54 <johnw> ghci things it's a Char
13:31:21 <DMcGill> could it be saying [Char]?
13:31:23 <DT``> it's probably using [a]'s <$>.
13:31:25 <mauke> it's neither
13:31:35 <k0ral> :t flip :: Applicative m => m (a -> b) -> a -> m b
13:31:37 <lambdabot> forall (m :: * -> *) a b. (Applicative m) => m (a -> b) -> a -> m b
13:31:43 <DMcGill> but as mauke said, it's IO String
13:31:46 <mauke> johnw: what's the actual error message?
13:31:52 <k0ral> @hoogle flip
13:31:52 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
13:31:53 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
13:31:53 <lambdabot> package Flippi
13:31:57 <k0ral> ?!
13:31:58 <lambdabot> Maybe you meant: . ? @ v
13:31:58 <timthelion> johnw: but what is the type of length <$> getArgs?  IO [Char]?
13:32:07 <timthelion> no IO [Int] sorry
13:32:17 <johnw> it's IO Int
13:32:22 <johnw> why would it be IO [Int]?
13:32:56 <timthelion> johnw: because you are applying length to each element of the list returned by getArgs(I think)?
13:33:01 <DMcGill> show . length <$> getArgs has type IO String
13:33:13 <johnw> length <$> getArgs == a <- getArgs >> length a
13:33:16 <DMcGill> putStrLn needs a string
13:33:17 <johnw> so it should return an Int
13:33:20 <nand`> getArgs :: IO [String] --?
13:33:27 <latro`a> you can swap out the $ for another .
13:33:30 <mauke> johnw: hello?
13:33:32 <latro`a> I think
13:33:34 <johnw> hi
13:33:35 <latro`a> erm...no
13:33:36 <DMcGill> putStrLn =<< show . length <$> getArgs
13:33:37 <latro`a> needs to be a bind
13:33:38 <latro`a> yeah
13:33:38 <nand`> look to me like he wants =<<
13:33:39 <latro`a> tha
13:33:40 <latro`a> t
13:33:40 <nand`> not $
13:33:41 <mysticc> I have a number in string form .. example "2" how to write a function from String -> Maybe Int .. which returns Just int if parse was success otherwise Nothing
13:33:41 <johnw> aha
13:33:49 <mauke> johnw: did you see my question?
13:33:58 <latro`a> mysticc: use reads
13:34:05 <latro`a> or rather a wrapper around reads
13:34:06 <johnw> yes, =<< is it
13:34:22 <DMcGill> @hoogle ReadS
13:34:22 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
13:34:22 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
13:34:22 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
13:34:38 <mauke> :t reads
13:34:39 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:35:23 <johnw> mauke: sorry, a lot going on here
13:35:39 <latro`a> myreads :: String -> Int; myreads str = case reads str of { [(i,[])] -> Just i; _ -> Nothing }
13:35:41 <latro`a> should do it
13:35:44 <johnw> The error message is: Couldn't match expected type `Char' with actual type `String'
13:35:56 <johnw> i don't even know why it would be giving that message
13:36:45 <mauke> johnw: what's the actual complete error message?
13:36:54 <DMcGill> I would have thought because the putStrLn informs the type inferrer that the things after the $ are a string
13:37:06 <johnw> https://gist.github.com/3317656
13:37:38 <DMcGill> then the <$> that returns a string takes an argument of type (Char -> Char)
13:37:49 <DMcGill> which is your expected a0 -> Char
13:38:37 <mauke> you're doing putStrLn (show <$> ...)
13:38:48 <mauke> <$> is polymorphic in its functor
13:38:52 <johnw> ah
13:38:58 <mauke> putStrLn takes [Char], which fixes f = []
13:39:24 <mauke> i.e. at that point it's basically putStrLn (map show ...)
13:39:37 <mauke> and map show returns [String] where String is required
13:39:51 <mauke> which it does because show returns [Char] where Char is required
13:41:15 <johnw> :t (<<=)
13:41:16 <lambdabot> Not in scope: `<<='
13:41:18 <johnw> :t (=<<)
13:41:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:41:31 <edwardk> nand`: switching to the fundep version from the type family version, its about a 3rd of the code, reads better and gives no warnings from haddock
13:41:37 <johnw> :t putStrLn
13:41:38 <lambdabot> String -> IO ()
13:41:50 <DMcGill> johnw: if you're not sure about (=<<), reading LYAH's chapter on monads will make things MUCH easier
13:42:03 <johnw> I understand >>=, but not yet =<< :)
13:42:12 <mauke> @src (=<<)
13:42:13 <lambdabot> f =<< x = x >>= f
13:42:13 <latro`a> =<< just has the arguments reversed
13:42:19 <johnw> ah, cool
13:42:22 <mekeor> :D
13:42:25 <johnw> oh, I get it
13:42:27 <latro`a> (and I assume the associativity flipped?)
13:42:31 <johnw> because <$> puts the result in the IO Monad
13:42:31 <DMcGill> same for (>>) and (<<)
13:42:32 <johnw> of course
13:42:40 <latro`a> is there a << in base?
13:42:49 <DMcGill> no
13:42:52 <mekeor> infixr 1 =<<; infixl 1 >>=
13:42:53 <DMcGill> bad example
13:43:04 <sclv> quick question: anyone have a source for the hash combining functions in tibbe's Hashable?
13:43:10 <sclv> like a citation?
13:43:17 <edwardk> latro`a: Control.Monad exports it
13:43:30 <mekeor> edwardk: ah, cool
13:43:31 <edwardk> latro`a: note that the effect composition is opposite <*
13:43:50 <latro`a> mmk
13:44:13 <mekeor> edwardk: i can't find Control.Monad.<< (on hackage) :/
13:44:32 <edwardk> interesting
13:44:35 <mekeor> @hoogle (<<)
13:44:36 <lambdabot> Control.Category (<<<) :: Category cat => cat b c -> cat a b -> cat a c
13:44:36 <lambdabot> Control.Arrow (<<<) :: Category cat => cat b c -> cat a b -> cat a c
13:44:36 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
13:44:44 <edwardk> where'd it go?
13:45:40 <mekeor> anyway, (<<) ≈ (<*)
13:45:57 <edwardk> (<<) used to be just flipped (>>)
13:46:03 <edwardk> the order of effects was the opposite of (<*)
13:46:10 <sclv> specifically: combine h1 h2 = (h1 + h1 `shiftL` 5) `xor` h2
13:46:13 <edwardk> which was why <* was so weird when it came out
13:46:14 <sclv> where's that from?
13:48:17 <mauke> I don't remember << ever existing
13:48:31 <mauke> I once defined my own but it was equivalent to <*
13:48:36 <ParahSailin_> @pl combine h1 h2 = (h1 + h1 `shiftL` 5) `xor` h2
13:48:37 <lambdabot> combine = xor . ap (+) (`shiftL` 5)
13:48:59 <edwardk> sclv: can't think of a reference for it
13:49:09 <latro`a> that @pl is almost usable O.o
13:49:27 <mauke> that means your brain is already changing
13:49:55 <Taneb> :t xor . (+) <$> (`shiftL` 5)
13:49:56 <lambdabot> forall a. (Bits (a -> a), Bits a) => a -> (a -> a) -> a -> a
13:50:03 <Taneb> :t xor . ((+) <$> (`shiftL` 5))
13:50:05 <lambdabot> forall a. (Bits (a -> a), Bits a) => a -> (a -> a) -> a -> a
13:50:08 <Taneb> Hmm
13:50:18 <Taneb> Wait
13:50:23 <Taneb> :t xor . (+) <*> (`shiftL` 5)
13:50:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
13:50:25 <lambdabot>     Probable cause: `shiftL' is applied to too many arguments
13:50:25 <lambdabot>     In the second argument of `(<*>)', namely `(`shiftL` 5)'
13:50:31 <Taneb> :t xor . ((+) <*> (`shiftL` 5))
13:50:32 <lambdabot> forall a. (Bits a) => a -> a -> a
13:50:36 <Taneb> :)
13:50:40 <edwardk> at least for those constants
13:50:47 <edwardk> @google jenkins shift-add-xor hash
13:50:49 <lambdabot> http://home.comcast.net/~bretm/hash/7.html
13:50:49 <lambdabot> Title: Pluto Scarab — Evaluation of Bob Jenkins' Hash
13:51:10 <edwardk> er not the link i was looking for
13:51:47 <edwardk> http://en.literateprograms.org/Hash_function_comparison_(C,_sh)#Shift-add-XOR
13:53:01 <nand`> :t 1 + xor 0 $ 4
13:53:02 <lambdabot> forall t. (Bits t) => t
13:53:03 <edwardk> most of the shift-add-xor hashes i'm familiar with actually rotate though this one just shifts
13:53:08 <sclv> ok, thanks.
13:53:10 <nand`> > 1 + xor 0 $ 4
13:53:11 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:53:12 <lambdabot>    `Data.Bits.Bits a'
13:53:12 <lambdabot>      a...
13:53:19 <nand`> > 1 + xor 0 $ 4 :: Integer
13:53:21 <lambdabot>   5
13:53:21 <edwardk> so i'm not sure how good it is at mixing
13:53:57 <c_wraith> :t let fixWith = flip fix in fixWith
13:53:58 <lambdabot> forall a b. a -> ((a -> b) -> a -> b) -> b
13:54:26 <c_wraith> that makes way too much sense to me.
13:55:07 <ParahSailin_> @pl  fixWith = flip fix in fixWith
13:55:08 <lambdabot> (line 1, column 20):
13:55:08 <lambdabot> unexpected reserved word "in" or "i"
13:55:08 <lambdabot> expecting variable, "(", operator or end of input
13:55:27 <nand`> ParahSailin_: the output of that would be ‘flip fix’
13:55:31 <edwardk> sclv: http://www.akira.ruc.dk/~keld/teaching/algoritmedesign_f08/Artikler/03/Ramakrishna97.pdf might be a slightly more academic source, but i can't spot the exact shape tibbe used in there
13:55:34 <c_wraith> it's already pointless
13:55:47 <osa1> do we have an extension for python style regex strings(I think they're called "raw strings" in python) ? I don't want to escape all '\'s in regex strings
13:55:59 * parcs` is tempted to use unsafeIOToSTM
13:56:16 <c_wraith> osa1: quasiquoters. >_>
13:58:06 <osa1> c_wraith: do you mean this: http://hackage.haskell.org/package/regexqq ?
13:58:09 <root_555> hi
13:58:10 <timthelion> > foldr (\a mayb -> case mayb of Nothing -> Nothing ; Just n -> (case a of Just x -> Just (n*10+x) ; Nothing -> Nothing)) (Just 0) $ reverse $ map (\char -> lookup char (map (\n->(head $ show n,n)) [0..9]))  "123" -- mysticc
13:58:11 <lambdabot>   Just 123
13:58:22 <timthelion> ^_^
13:58:47 <timthelion> > foldr (\a mayb -> case mayb of Nothing -> Nothing ; Just n -> (case a of Just x -> Just (n*10+x) ; Nothing -> Nothing)) (Just 0) $ reverse $ map (\char -> lookup char (map (\n->(head $ show n,n)) [0..9]))  "foo123" -- mysticc
13:58:48 <lambdabot>   Nothing
13:59:01 <latro`a> that case is an fmap
13:59:02 <latro`a> :p
13:59:15 <mekeor> :D
13:59:19 <timthelion> which one?
13:59:20 <latro`a> with lambda case it'd be straightforward to write as one
13:59:26 <latro`a> there is only one case statement
13:59:34 <timthelion> there are two
13:59:39 <latro`a> oh nvm
13:59:41 <latro`a> the top level one
13:59:44 <mekeor> both!
13:59:49 <latro`a> and the inner one
13:59:49 <latro`a> yeah
13:59:55 <latro`a> you're fmap (fmap f)'ing
14:01:23 <c_wraith> osa1: I had no clue such a thing already existed. I was just saying that
14:01:40 <c_wraith> 's the only way to insert string literals that don't treat \ specially
14:01:57 <timthelion> What is the correct syntax?
14:02:05 <timthelion> > foldr (\a mayb -> fmap . fmap (\n x -> n*10+x)) (Just 0) $ reverse $ map (\char -> lookup char (map (\n->(head $ show n,n)) [0..9]))  "123f"
14:02:06 <lambdabot>   Couldn't match expected type `(a -> a1) -> f a -> f (a1 -> a1)'
14:02:06 <lambdabot>         aga...
14:03:41 * timthelion is too tired to use fmap
14:03:52 <hpaste> “Pepijn de Vos” pasted “Poke fight” at http://hpaste.org/72930
14:04:01 <sclv> parcs`: unsafeIOToSTM will unleash great evil
14:04:30 <latro`a> you need nested lambdas in this case
14:04:34 <timthelion> sclv: what, they want another unsafe?
14:04:42 <latro`a> which means do notation might be clearer
14:06:29 <timthelion> latro`a: care to show me?
14:06:35 <latro`a> sure
14:07:24 * timthelion has never actually done non-IO monad do notation
14:07:39 <DMcGill> timthelion: Maybe is quite nice
14:07:56 <timthelion> DMcGill: in do notation?
14:08:06 <DMcGill> yeah
14:08:43 <DMcGill> say you have a x, y :: Maybe Int to allow for safe division
14:08:45 <luis> Hello. I'm trying to install GtkHs via cabal and the cairo bit wants a lot of dependencies that weren't install by brew: things like libX11, libXrender, etc. Is there some convenient way to get these?
14:09:08 <hpaste> latro`a pasted “timthelion foldr” at http://hpaste.org/72932
14:09:15 <DMcGill> you'd get saveAdd x y = do {x' <- x; y' <- y; return (x + y)}
14:09:18 <latro`a> threw in a &&& for fun
14:09:23 <DMcGill> s/save/safe
14:09:44 <latro`a> in this particular case you can be even clearer by using liftM2
14:09:49 <timthelion> luis: in most linux distros, gtk2hs is included as a package becuase it's so darn hard to build on your own
14:09:59 <latro`a> erm
14:10:05 <latro`a> that should be mayb on the left, not maybe
14:10:06 <latro`a> but
14:10:08 <luis> timthelion: right. I should mention I'm using OSX. :-/
14:10:20 <timthelion> latro`a: thanks!
14:10:21 <latro`a> f = liftM2 (\n x -> n*10+x)
14:10:47 * mekeor 's friend's name is luis.
14:11:04 * timthelion has never used OSX
14:11:15 * mekeor neither
14:13:30 <Okasu> hello
14:14:04 <Okasu> i've just installed lambdabot but eval seems doesn't works
14:14:46 <geekosaur> luis, if you can't get an X11 from brew, try http://xquartz.macosforge.org
14:14:47 <luite> yes you need to install mueval and some extra package
14:14:48 <luite> s
14:15:18 <Okasu> luite: yep, i know, it's in README
14:15:31 <Okasu> and mueval has been installed
14:15:50 <Okasu> http://vpaste.net/T6nN5 error
14:16:05 <Okasu> but show installed too
14:17:11 <luite> hmm
14:18:26 <Reaga> anyone here a mathematician?
14:18:28 <Okasu> maybe it's something with PATHs?
14:18:46 * hackagebot imm 0.4.1.0 - Retrieve RSS/Atom feeds and write one mail per new item in a maildir. (koral)
14:18:52 <Reaga> if haskell isnt procedural, how do i get it to print "hello" then print "goodbye" in that order?
14:19:11 <latro`a> putStrLn "hello" >> putStrLn "goodbye"
14:19:17 <Okasu> >1+1
14:19:28 <latro`a> and reaga, I'm somewhat of a mathematician
14:19:32 <Okasu> lambdabot: >1+1
14:19:41 <monochrom> are you learning haskell? pretty sure most tutorials tell you how to print stuff
14:19:45 <latro`a> and yeah, they do
14:19:57 <monochrom> read a tutorial for real
14:20:06 <latro`a> LYAH is quite nice
14:21:16 <monochrom> read a tutorial and do some exercises. write some code
14:21:27 <edwardk> Reaga: there is a monad for dealing with IO. the idea of using a monad to order effects in a functional language goes back to eugenio moggi in '88 http://www.disi.unige.it/person/MoggiE/ftp/lc88.pdf
14:21:53 <edwardk> Reaga: but it turned out to be a much more general concept, so we use them for a lot of stuff
14:23:07 <monochrom> you still haven't answered my question "are you learning haskell?" even though I have asked twice. I am pretty sure people have the right to know
14:23:11 <mekeor> where can i read the definition of IO?
14:23:21 <Reaga> edwardk: i understand that pdf completely
14:23:21 <edwardk> Reaga: one way to think about IO is that is model of a cooperative coroutine between your pure language and an imperative interpreter that knows how to inspect the state of the pure language
14:23:23 <Reaga> not!
14:23:28 <nand`> http://www.haskell.org/haskellwiki/IO_inside might be what you're looking for mekeor
14:23:38 <edwardk> monochrom: to be fair, you didn't include his name in your query
14:23:46 * hackagebot highlighting-kate 0.5.2 - Syntax highlighting (JohnMacFarlane)
14:24:07 <monochrom> to be more fair, he didn't include my name or your name in his queries. (so why are you answering?)
14:24:58 <mekeor> nand`: i don't think so… i really want the *definition* =)
14:25:01 <edwardk> just saying that getting mad at someone for not responding to a query when it isn't clear its being directed at them is a bit silly
14:25:21 <monochrom> not getting mad
14:25:21 <nand`> Okasu: contents of ~/.lambdabot/State/L.hs ?
14:25:25 <luis> geekosaur: I have X11. Does that mean I should already have those libs (and headers, I suppose) somewhere?
14:25:29 <mekeor> nand`: oh, ah: http://www.haskell.org/haskellwiki/IO_inside#Welcome_to_the_machine:_the_actual_GHC_implementation
14:25:37 <Mathnerd314> is there a working Hackage 2.0 server somewhere?
14:26:06 <mekeor> nand`: newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
14:26:24 <ParahSailin_> what do the #'s mean
14:26:40 <edwardk> mekeor: State# RealWorld is a token the compiler passes around, and its not allowed to shuffle things past those case analyses
14:26:43 <c_wraith> nothing by themselves.
14:26:56 <monochrom> the # is a naming convention for internal implementation things
14:26:57 <c_wraith> But # is often added to GHC internal things
14:27:15 <geekosaur> (# #) is an unboxed tuple, State# is an internal type that users aren't supposed to (and normally can't) access directly
14:27:16 <edwardk> ParahSailin_: # is normally just a legal operator character. the MagicHash extension lets you use it as part of an identitifier, ghc uses that to denote internal stuff you probably shouldn't care about.
14:27:40 <edwardk> the UnboxedTuples extension lets you pass around pairs of things without putting them in a box. thats the (#  #)'s
14:27:47 <DrTeggy> Doesn't it mean "unboxed"?
14:27:57 <copumpkin> by convention
14:27:58 <edwardk> DrTeggy not always, but its a good clue
14:28:08 <geekosaur> it means whatever the library says it means.  unboxed is a common use but not th eonly one
14:28:14 <copumpkin> it typically just means "internal shit you shouldn't care about"
14:28:18 <DrTeggy> I see.
14:28:21 <copumpkin> also by convention
14:28:36 <monochrom> "definition of IO" is a bit of an ambiguous question. do you want an implementation-specific defintion? or an implementation-impartial definition?
14:28:41 <geekosaur> luis:  if you're on Snow Leopard or Lion, /usr/X11 has a full X11.  if you install XQuartz then /opt/X11 has a newer version of that same X11.  you willprobably have to point stuff to one of those directories
14:29:00 <geekosaur> if you have Mountain Lion, /usr/X11 is a stub and installing XQuartz makes it a symlink to /opt/X11
14:29:32 <mekeor> monochrom: i don't know exactly… so IO doesn't have just a usual definition as other stuff, right?
14:30:19 <nand`> not in terms of (Haskell sans IO) itself
14:30:20 <edwardk> mekeor: there are multiple ways to implement the haskell IO type. ghc uses a 'world passing' model.
14:30:21 <monochrom> right, if you don't commit to one single implementation, it is abstract, you can only talk about properties
14:30:37 <monochrom> just like "Int" is abstract
14:30:37 <nand`> you need to rely on some implementation-specific primitive which is not defined in the Haskell report
14:31:20 <mekeor> okay
14:31:28 <luis> geekosaur: I have Lion. Thanks! I'll try to point something to /use/X11!
14:31:34 <Veinor> (#_#) looks like an emoticon
14:31:34 <edwardk> mekeor: you can also use something like http://comonad.com/reader/2011/free-monads-for-less-3/
14:31:52 <edwardk> that is what we use for IO in our haskell-clone here at capital iq
14:31:58 <monochrom> but one property you can rely on is that "print 0 >> print 1" has a sequential effect. 0 before 1.
14:32:16 <edwardk> monochrom: up to happensbefore semantics on your machine ;)
14:32:36 <mekeor> edwardk: okay… interesting
14:33:00 <edwardk> mekeor: we just choose to implement IO by making IO the type of something the RTS knows how to inspect and interpret
14:33:39 <edwardk> e.g. it is either a pure value a, or a reference to a calculation the RTS should perform, and a function to call with the answer from that calculation
14:33:55 <edwardk> then the language itself is pure, and just constructs these pure IO values
14:33:58 <monochrom> GHC uses the RealWorld# thing to trick its own code generator to generate sequential code
14:34:01 <edwardk> its the RTS that is responsible for sequencing
14:34:15 <edwardk> now, that story is not perfect, because it doesn't allow for unsafePerformIO at first reading
14:34:40 <mekeor> oO
14:34:45 <monochrom> so, it's a phantom thing to add data/control dependency, rather than real data that contains state
14:34:56 <edwardk> but it does provide you with a vacuously simple denotational semantics for IO
14:35:46 <edwardk> and unlike with the realworld passing the abstraction doesn't leak when you have multiple threads
14:36:21 <luis> geekosaur: 'PKG_CONFIG_PATH=/usr/X11/lib/pkgconfig cabal install cairo' did the trick. Thanks a lot!
14:36:22 <nand`> RealWorld# is basically just a unit type internally, right?
14:36:37 <latro`a> that article earlier said that it's internally a 0 byte token
14:36:41 <monochrom> yeah
14:37:43 <edwardk> nand`: yeah it takes 0 bytes to store or pass
14:39:01 <DT``> that's pretty inefficient.
14:40:46 <Reaga> hey guys
14:41:00 <nand`> DT``: :)
14:41:01 <Reaga> anyone want to help me build up th haskell libraries?
14:41:07 <Reaga> they're pretty shoddy at the moment
14:44:21 --- mode: ChanServ set +o edwardk
14:45:03 --- kick: Reaga was kicked by edwardk (Your behavior is not conducive to the desired environment.)
14:45:14 --- mode: edwardk set -o edwardk
14:45:14 <latro`a> +1
14:45:19 <mekeor> wow :)
14:45:28 <nand`> that seemed bound to happen eventually
14:45:32 <latro`a> at first I read that as "template haskell haskell libraries"
14:45:37 <latro`a> apparently I've been spending too much time here
14:45:37 <nand`> latro`a: me too :)
14:46:02 <nand`> I parsed it as “anybody want to help me build my TH library”?
14:46:03 <mekeor> latro`a: i'm still reading it as such… what is it really?
14:46:08 <latro`a> th as typo for the
14:46:13 <mekeor> ah
14:46:15 <mekeor> lol
14:46:36 <nand`> @protontorpedo
14:46:37 <lambdabot>  and is haskell ez to debug?
14:46:41 <Enigmagic> edwardk: but doesn't it eat up a register at times? i see it passed explicitly in some cmm code
14:47:13 <edwardk> Enigmagic: it does take up a slot. you'll see the distinction between N and P parameters here and there
14:47:58 <shachaf> edwardk: A "denotational semantics" that doesn't denote anything.
14:48:00 <Mortchek> I'm playing with pointfree, and it keeps giving things involving using ap on functions, but ghc is telling me there is no Monad instance for them. Is there something I have to enable for that to work?
14:48:22 <nand`> Control.Monad.Instances
14:48:30 <edwardk> shachaf: amazing. its almost like when you use referential transparency to talk about denotational semantics. ;)
14:48:31 <nand`> actually shouldn't C.A re-export those?
14:48:49 <Mortchek> Ah, Control.Monad.Instances does it. Thanks.
14:48:59 <mekeor> yay =)
14:49:17 <edwardk> Mortchek: import Control.Applicative or on older versions Control.Monad.Instances
14:49:23 <edwardk> C.M.I is empty now
14:49:29 <Mortchek> Will do.
14:49:43 <edwardk> Mortchek: what version of ghc are you on?
14:49:56 <Mortchek> 7.0.4
14:50:06 <edwardk> yeah thats before C.M.I got emptied ;)
14:51:10 <Mortchek> Yeah, Control.Applicative doesn't seem to have it in this version.
14:52:37 <Mortchek> Hmm. Seems this version is more than a year old. I wonder why a newer one isn't in the repo yet (LMDE, based on Debian Testing).
14:54:04 <geekosaur> hm, I thought testing was on 7.4.1 now
14:55:11 <Mortchek> Maybe it's LMDE that's lagging behind.
14:56:08 <nand`> isn't debian testing still behind most distro's stable branches?
14:56:26 <nand`> (nm, off-topic flame baiT)
14:56:40 <Mortchek> It's certainly not behind Debian Stable. ;)
14:56:45 <monochrom> Control.Applicative gives you <*> instead of ap
14:57:01 <nand`> monochrom: in his problem it's a missing instance though; he has ‘ap’
14:57:15 <nand`> or did you mean to make him aware of the alternative?
14:57:33 <monochrom> ap wants a Monad instance. <*> wants an Applicative instance
14:57:52 <nand`> and C.A / C.M.I define both for functions
14:57:54 <nand`> don't they?
14:57:59 <Okasu> nand`: http://vpaste.net/jSVCL
14:58:04 <monochrom> I don't know. I bet no.
14:58:11 <Okasu> sorry, was AFK
14:58:12 <nand`> Okasu: maybe you could just remove ‘import ShowIO’ and try again
14:58:16 <nand`> Okasu: I don't have that in my L.hs
14:58:18 <Mortchek> No instance for Functor for functions either.
14:58:25 <nand`> and I can't find it on hayoo or hoogle (is your lambdabot maybe outdated?)
14:58:32 <monochrom> I would think C.A focuses on Applicative and C.M.I focuses on Monad
14:58:35 <Mortchek> Which is what <*> wants.
14:58:46 <Okasu> nand`: nope, darcs pull says it's uptodate
14:59:03 <nand`> oh, I think it's for
14:59:05 <nand`> > print ()
14:59:06 <lambdabot>   <IO ()>
14:59:46 <nand`> nope, that works in my lambdabot and I don't have ‘ShowIO’ in L.hs
14:59:58 <nand`> beats me then; does simply removing it end up working?
15:00:17 <Okasu> nand`: hm, i've just removed it from L.hs but error persists
15:01:30 <Okasu> localhost: find -name "*.hs" -print0|xargs -0 grep ShowIO
15:01:30 <Okasu> ./State/Pristine.hs:import ShowIO
15:01:30 <Okasu> ./State/L.hs:import ShowIO
15:02:04 <nand`> hmm, I don't have Pristine.hs either; maybe it's my lambdabot that's outdated
15:02:17 <nand`> oh, it probably is, I'm on 4.2.3.2
15:02:30 <nand`> Okasu: maybe it's something like lambdabot-utils?
15:02:55 <Okasu> nand`: what do you mean? It's installed automatically
15:03:02 <Okasu> as deps
15:03:03 <nand`> nevermind then
15:03:28 <nand`> you could always try rolling back to 4.2.3.2 and seeing if that works, I guess
15:03:42 <nand`> maybe Cale would know more
15:04:34 <Cale> I know nothing
15:04:44 <Cale> lol
15:10:58 <strypd_> \connect irc.slashnet.org
15:17:21 <Okasu> ok, i've commented out all occurances of ShowIO and now i get Could not find module `Control.Parallel.Strategies'
15:18:11 <Okasu> doing cabal install parallel
15:18:45 <Okasu> finally, eval is working
15:20:23 <MostAwesomeDude> So, is reactive-banana the best way to go for FRP?
15:20:37 <Okasu> its seems most of all haskell libs are outdated, so many deprication warnings...
15:21:34 <startling> MostAwesomeDude: "In the programming-language world, one rule of survival is simple: dance or die. This library makes dancing easy." – Simon Banana Jones
15:21:54 <MostAwesomeDude> startling: Well, I had a thought.
15:22:12 <MostAwesomeDude> See, in the C world, you would do SDL et al. with a loop.
15:22:26 <MostAwesomeDude> You'd loop for events, and then you'd dispatch on the event to update your state.
15:22:32 <startling> mhm
15:22:41 <MostAwesomeDude> Then you'd check your timers. If your physics timer dinged, you'd do a physics step, etc.
15:22:49 <MostAwesomeDude> Finally, you would draw your frame, and tell SDL to flip it.
15:23:14 <latro`a> MostAwesomeDude, to within my understanding reactive-banana is the better GUI FRP lib but netwire is the better other-FRP lib
15:23:31 <MostAwesomeDude> So, it occurs to me that instead of a loop, I could just have some sort of FRP thing that draws frames whenever it can, does physics on a timer, and relies on vsync/flipping to not go too fast.
15:24:32 <startling> MostAwesomeDude: that's a neat idea.
15:24:51 <aristid> MostAwesomeDude: apfelmus would say reactive-banana is best, and mm_freak_ would say netwire is best, i guess :)
15:25:18 <latro`a> for not-GUIs I'm not actually sure how comparable they are
15:25:24 <Swizec> turns out cognac and haskell mix very well
15:25:27 <Swizec> also hello aristid
15:25:35 <aristid> hi Swizec
15:27:38 <osa1> so I'm using a library and author didn't make a data type derive Ord. is there a way to derive Ord without modifying the source and without manually writing "compare" function ?
15:28:01 <shachaf> deriving instance Ord Foo
15:28:06 <shachaf> But it'll be an orphan instance.
15:28:23 <startling> too bad we can't monkey-patch !!
15:28:34 <monochrom> if the data type is not abstract
15:28:38 <osa1> MostAwesomeDude: are you using this package http://hackage.haskell.org/package/SDL ?
15:28:44 <MostAwesomeDude> osa1: Yes.
15:29:02 <shachaf> monochrom: If it's abstract then writing the compare function manually isn't possible either.
15:29:13 <shachaf> (And you probably don't want the Ord instance, for that matter.)
15:29:26 <monochrom> right
15:30:18 <osa1> shachaf: this type: http://hackage.haskell.org/packages/archive/hinotify/0.3.1/doc/html/System-INotify.html#t:EventVariety
15:30:38 <osa1> shachaf: I want to put this data constructors in a map.
15:32:31 <c_wraith> osa1: you could just hack that with StandaloneDeriving
15:32:57 <c_wraith> osa1: oh, which happens to be the answer to exactly the question you asked.
15:33:51 <c_wraith> {-# LANGUAGE StandaloneDeriving #-}  deriving instance Ord EventVariety
15:35:05 <osa1> c_wraith: great! thanks
15:38:53 <statusfailed> Are there any default CSS styles for HTML generated by pandoc?
15:57:11 <mm_freak_> statusfailed: nope, but you can write a stylesheet…  pandoc generates some classes for you
15:57:12 <edwardk> i need a name for something that you can check to see if it is pure without sounding like a snob or i sounding like i hate women ;)
15:57:18 <edwardk> ideas?
15:57:43 <mm_freak_> edwardk: if what is pure?
15:58:20 <edwardk> e.g. its going to be a form of an applicative, where i want to know if it was constructed with pure, so i can gain sharing information
15:58:46 <edwardk> but checking if something is pure leads to all sorts of chastity metaphors
15:59:00 * hackagebot penny-lib 0.4.0.0 - Extensible double-entry accounting system - library (OmariNorman)
15:59:04 <S11001001> actionable :]
15:59:04 <edwardk> which is not a good place to go for class names
15:59:08 <edwardk> S11001001: =)
15:59:33 <mm_freak_> edwardk: IsPurified =P
15:59:47 <edwardk> Purified isn't bad
16:00:04 <mm_freak_> i have a class called Effectful in netwire
16:00:11 <mm_freak_> you may have something like IsEffectful
16:00:23 <S11001001> partially copointed
16:01:21 <typoclass> purified sounds like it was impure and then was made pure
16:01:31 <mm_freak_> anyway, i'm suspecting this is about lenses, and since i'm planning to use your lens library, please don't call it Effectful =P
16:01:39 <edwardk> hah
16:01:44 <edwardk> i already have Effective ;)
16:01:51 <mm_freak_> that's fine =)
16:02:21 <edwardk> this may wind up being about lenses, but i'm trying to see if i can make a form of traverse that keeps sharing when nothing is done to the branch
16:02:27 <mm_freak_> i have Effectful, Feedback, MonadRandom and Reactive as class names =)
16:02:49 <mm_freak_> three of them are for arrows
16:03:03 <edwardk> it comes up when i talk about multitraversals or multiplates because multiplates whack all sharing everywhere
16:03:09 <edwardk> so they are kind of a blunt instrument
16:03:22 <edwardk> if i can know that a branch wasn't changed by the multiplate i can use the old value
16:03:40 <edwardk> e.g. something like pmap :: Purified f => b -> (a -> b) -> f a -> f b
16:03:44 <edwardk> and liftP2, etc.
16:03:55 <scri> what's the first thing I should check if GHC isn't importing a module that it says is installed?
16:04:40 <edwardk> then i can use traverse with those instead of pure, and use an Applicative transformer that lets me check purity
16:05:02 <edwardk> its still very much in the 'still resolving' stage of idea formation
16:05:13 <typoclass> is Pure taken already? (capital P)
16:05:39 <edwardk> its got bad connotations because its already used by scalaz for something that only supplies 'pure'
16:06:39 <edwardk> maybe i can get away without a class, and just make 'Purified' an applicative transformer
16:06:53 <edwardk> which is basically composition with a product containing a bool
16:07:24 <typoclass> IsPure? WasPure? FromPure?
16:07:58 <edwardk> of course its kinda silly that impure = Impure . pure ;)
16:08:26 <typoclass> other than that, lots of stuff here http://thesaurus.com/browse/pure kosher, unalloyed, unmingled, flawless, spotless, stainless, ... nothing that i find completely convincing
16:09:01 * hackagebot penny-bin 0.4.0.0 - Extensible double-entry accounting system - binary (OmariNorman)
16:09:12 <edwardk> Kosher would be kinda funny =)
16:09:24 <edwardk> let me check to see if this term is kosher before i consume it
16:11:40 <hpaste> “Joey Adams” pasted “Pattern bind guards don't extend to where clause” at http://hpaste.org/72939
16:11:48 <JoeyA> ^ Is this a bug?
16:11:58 <JoeyA> err, pattern guard bindings*
16:12:31 <hpc> not a bug
16:12:45 <hpc> it has to do with how pattern guards desugar
16:13:14 <typoclass> could view patterns help?
16:13:47 <hpc> probably, yeah
16:13:51 <JoeyA> "The bindings introduced by pattern guards scope over all the remaining guard qualifiers, and over the right hand side of the equation."
16:13:56 <JoeyA> (from the GHC manual)
16:14:02 * hackagebot fay 0.6.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
16:15:19 <typoclass> JoeyA: i think the where doesn't count as the "right hand side of the equation", but your question is very understandable
16:15:52 <JoeyA> For every other type of pattern, the where clause is included, no?
16:18:18 <augur> @tell ezyang its perpetuated not perpetrated
16:18:18 <lambdabot> Consider it noted.
16:19:44 <JoeyA> Ah, I see.  Pattern guards get to use definitions in the where clause, but not vice versa.
16:20:20 <JoeyA> e.g. launchMissiles xs | all isLaunchable xs = ... where isLaunchable = ...
16:21:27 <typoclass> JoeyA: i guess you could think of pattern guards as sugar for an if-then-else inside the function. the where couldn't see into the function either
16:26:40 <gertc> thsi supose to make sense right?
16:26:50 <gertc> put Contact{..}= do put name; put adress; put phone
16:26:56 <MostAwesomeDude> :t (***)
16:26:57 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:27:51 <gertc> how do you do this? get = Contact{get name; get adress; get phone}
16:27:55 <MostAwesomeDude> :t (&&&)
16:27:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:28:32 <JoeyA> gertc: Is get a pure function, or is it an action to unserialize or something?
16:28:47 <Reaga> Lol i got kicked for saying haskells libraries are shoddy?
16:28:50 <mm_freak_> i have a function where i write this:  f (X x) = … X x …
16:28:58 <mm_freak_> where the type of X is a newtype
16:28:58 <Reaga> "Your behavior is not conducive to the desired environment." <- wtf ?
16:29:16 <gertc> JoeyA, unserialize stuf
16:29:25 <mm_freak_> i'm compelled to use sharing:  f ox@(X x) = … ox …
16:29:31 <mm_freak_> is this really necessary for a newtype?
16:29:36 <squidz> can anybody help me install haskell-src-exts
16:29:39 <Reaga> Your behavior is not conducive to the desired environment. ?
16:29:45 <mauke> Reaga: how did you determine that the libraries are shoddy?
16:29:49 <squidz> i get this error when trying to cabal install
16:29:50 <JoeyA> gertc: get = do name <- get; address <- get; phone <- get; return Contact{..}
16:29:55 <squidz> http://hpaste.org/72940
16:30:11 <MostAwesomeDude> Reaga: Well, what's the problem, and what do you plan to do about it?
16:30:14 <JoeyA> The Contact{..} expression grabs up any fields in scope with the same name as members of Contact.
16:30:22 <gertc> JoeyA, thx saved me allot of headick :)
16:30:51 <scri> newbie q: i've installed the package primes, but importing Data.Numbers.Primes doesn't work.. the package appears in ghc-pkg list and cabal list
16:31:07 <gertc> mean headache
16:31:14 <scri> what should i try first?
16:31:39 <mm_freak_> scri: how did you install it?  did you use the "cabal" command line tool?
16:31:43 <scri> yes
16:32:11 <scri> mm_freak_: i've also tried --reinstall
16:32:36 <mm_freak_> scri: are you using it in your own package?
16:32:40 <mm_freak_> (trying to)
16:32:50 <phao> Hi.
16:32:52 <mm_freak_> i.e. does whatever you want to compile have a .cabal file?
16:32:56 <mm_freak_> hi there phao
16:33:05 <scri> mm_freak_: i'm just using GHCi
16:33:37 <mm_freak_> scri: summary:  cabal update; cabal install primes; ghci
16:33:40 <squidz> anybody know why happy isnt in my ghc-pkg list even though I installed it with cabal?
16:33:47 <mm_freak_> then:  :m Data.Numbers.Primes
16:33:51 <mm_freak_> scri: correct?
16:33:56 <phao> In learning about functional programming, it's common NOT to use arrays. I know that in practice, implementations do give some array like primitive. But afaik, they're not "functionally friendly", meaning that they're not so much useful or convenient without assignment.
16:33:59 <scri> mm_freak_: yes
16:34:03 <phao> What is the alternative?
16:34:16 <phao> I mean, what is the alternative data structure in FP for arrays?
16:34:27 <latro`a> that depends heavily on the context, phao
16:34:36 <mm_freak_> phao: that's wrong actually…  i use arrays quite often, but you use them entirely differently in FP
16:34:38 <roconnor> phao: I use Data.Map a lot
16:34:47 <mm_freak_> phao: however, Data.Map is probably what you would use most of the time
16:34:56 <phao> what is this data.map?
16:35:02 <roconnor> I also love Data.PSQueue
16:35:12 <dcoutts_> squidz: ghc-pkg is only used for library packages, since that's all ghc cares about
16:35:20 <mm_freak_> phao: a tree data structure that exposes a dictionary-like interface
16:35:37 <scri> mm_freak_: ah, when i try compiling, i get amiguous module names: it was found in multiple packages: Numbers-0.2.1 primes-0.2.1.0
16:35:43 <edwardk> @hpaste
16:35:44 <lambdabot> Haskell pastebin: http://hpaste.org/
16:35:46 <typoclass> phao: the data structure most often used in haskell is probably the list (it's basically a linked list)
16:35:47 <phao> mm_freak_, what if one wants a constant time access DS ?
16:35:50 <typoclass> > [0..5] -- a list
16:35:51 <lambdabot>   [0,1,2,3,4,5]
16:36:04 <mm_freak_> scri: that of course makes sense…  one way is to use the PackageImports extension:  ghci -XPackageImports
16:36:05 <hpaste> edwardk pasted “traversable with sharing (non-dependent version)” at http://hpaste.org/72941
16:36:07 <roconnor> typoclass: I think you mean Control.List :P
16:36:15 <mm_freak_> scri: then in GHCi:  import "primes" Data.Numbers.Primes
16:36:15 <edwardk> so this was my first stab at the problem
16:36:24 <edwardk> its not perfect though, it tracks sharedness outside of the 'f'
16:36:32 <edwardk> which means it can run on an applicative
16:36:33 <mm_freak_> phao: depends on your access…  random access?
16:36:41 <phao> yes..
16:36:43 * roconnor often uses lists, but not as a data structure, except for Strings
16:36:48 <edwardk> but it means that if you inspect stuff and then decide not to change your result, the result isn't Shared.
16:36:49 <typoclass> roconnor: what's a Control.List?
16:37:01 <edwardk> but i can make a version that works with a monad f'
16:37:01 <mm_freak_> phao: out of my head i can imagine only /very/ few applications, which require constant time random access
16:37:14 <edwardk> and then you can do traversals that keep full sharing info internally
16:37:18 <roconnor> typoclass: The way Lists are often used: for lazy producer/consumer protocol
16:37:21 <mm_freak_> phao: could you give an example?
16:37:31 <phao> hmm
16:37:32 <scri> yes, that seems to work, ty
16:37:41 <edwardk> er those Pure{} Pure{} Pure{} checks should be Shared{} Shared{} Shared{}
16:37:45 <roconnor> typoclass: it's hardly a data structure when it doesn't even appear in memory all at once ever.
16:37:45 <latro`a> (eh, the scrabble program I wrote up could make use of O(1) random access and update, to be fair)
16:37:49 <roconnor> typoclass: IMHO
16:38:04 <phao> mm_freak_, I didn't really thought of applications...
16:38:07 <scri> mm_freak_: yes, that seems to work, ty
16:38:08 <mm_freak_> latro`a: both?  wow, i think i have never needed that
16:38:08 <latro`a> (it doesn't, at present, and doesn't run slow at all as a consequence, but still)
16:38:11 <edwardk> i flipped the role of them
16:38:13 <phao> I guess the "counting characters" thing is one.
16:38:16 <latro`a> it *could* make use of it, is my point
16:38:25 <mm_freak_> phao: Data.Map is fine for counting characters
16:38:32 <latro`a> because you can wind up putting a word pretty much anywhere, and in the process have to look at the adjacent squares to wherever you tried
16:38:57 <latro`a> that said, since the grid is only a few hundred squares, O(n) is basically instant anyway
16:39:06 <scri> mm_freak_: unregistering one of the packages also works
16:39:09 <typoclass> roconnor: heh, i see. i guess when a function returns a tuple and you are only interested in one of the fields should be Control.Tuple then =)
16:39:10 <latro`a> the IO is far slower than the internal manipulation
16:39:12 <phao> So the common is to actually use a "slower" feature because of its other benefits?
16:39:20 <phao> In this case.
16:39:22 <mm_freak_> scri: yeah, but that's inconvenient…  btw, i recommend looking at the 'arithmoi' library
16:39:36 <edwardk> that would be enough to restore sharing for multiplates where you use 'shared' for the branches you don't take instead of pure plates
16:39:36 <roconnor> typoclass: arguably
16:39:39 <mm_freak_> scri: that one pretty much makes all your number theory dreams come true =)
16:39:43 <edwardk> but its not the best sharing solution
16:39:45 <latro`a> in practice it doesn't tend to wind up being slower because you're using a data structure that works well for what you need in particular; that asid if you need large, random access, and random update, mutable arrays do exist
16:39:52 <latro`a> s/asid/said
16:40:14 <mm_freak_> phao: Data.Map is slower, but the difference is really low…  also for certain applications Data.Map will actually be faster
16:40:28 <mm_freak_> phao: in non-exhaustive cases it will also require less memory
16:40:44 <latro`a> and yeah Data.Map gets both in logn time for random and constant time for "structured"
16:40:45 <phao> Sure...
16:40:54 <latro`a> (hopefully what I mean by "structured" is clear here)
16:40:56 <phao> what do you mean?
16:41:09 <scri> mm_freak_: wow, this is nice. i'm interested to see how the two compare in efficiency
16:41:10 <mm_freak_> phao: but to answer your question:  if you /want/ an array, there is really nothing wrong with using one, but you should really ask yourself whether you really want to work in a stateful monad all the time
16:41:15 <latro`a> you can traverse a whole Map in O(n) time, while a random lookup takes logn
16:41:31 <phao> latro`a, ahh, ok.
16:41:34 <hpaste> edwardk annotated “traversable with sharing (non-dependent version)” with “traversable with sharing (non-dependent version) (fixed)” at http://hpaste.org/72941#a72942
16:41:39 <phao> mm_freak_, sure
16:41:47 <mm_freak_> scri: arithmoi is about the most efficient NT library on hackage
16:41:50 <phao> mm_freak_, I agree that mostly, arrays can be replaced.
16:41:55 <mm_freak_> scri: it's primarily developed for efficiency
16:42:08 <phao> I am just used to using them in C and C++ (vectors)
16:42:26 <mm_freak_> phao: note how only very few languages actually provide real arrays…  what is called an "array" in most languages is actually mostly a hash table
16:42:43 <phao> Hmm
16:42:44 <roconnor> mm_freak_: really?
16:42:49 <phao> I am talking about in the C and C++ sense.
16:42:50 * roconnor must be old
16:42:58 <edwardk> roconnor: perl, etc
16:42:59 <phao> also in the scheme sense.
16:43:07 * roconnor has never used perl, etc.
16:43:20 <phao> I guess in these languages they are actually arrays.
16:43:21 <geekosaur> perl arrays are not hash tables.
16:43:30 <mm_freak_> phao: yes, they are
16:43:42 <edwardk> roconnor: basically all the scripting languages followed perl's lead and made powerful default collection types
16:43:49 <mm_freak_> phao: btw, there is also an efficient hash table implementation for haskell in the 'unordered-containers' package
16:43:59 <mm_freak_> that one beats Data.Map from time to time
16:44:06 <roconnor> edwardk: and called them arrays?
16:44:12 <edwardk> ye
16:44:15 <edwardk> er yes
16:44:21 <phao> mm_freak_, I wonder if the difference is big..
16:44:39 <mm_freak_> phao: the biggest difference i have measured so far is a factor of 2
16:44:51 <phao> When I was implementing some data structures back when I was first learning this stuff. I remembered that balanced trees had REALLY SMALL depth
16:44:56 <edwardk> phao: the one in unordered-containers isn't an actual hashtable if you're talking about data.hashmap
16:44:57 <mm_freak_> phao: and the HashMap type in unordered-containers is really efficient
16:45:09 <phao> I remember a 2-3 tree with depth 19, for 10 bi. elements
16:45:18 <phao> ops
16:45:21 <phao> 10 mi. elements
16:45:26 <mm_freak_> phao: yeah, Data.Map is like that
16:45:30 <edwardk> roconnor: in javascript an array is something that has members named '1', '5', etc. that happens to have a length method and in theory a certain prototype
16:45:45 <mm_freak_> it will still be slower, but the factor is almost constant (i.e. logarithmic)
16:45:58 <aristid> edwardk: i like that perl actually distinguishes between arrays and hashmaps.
16:45:59 <phao> hmm
16:46:00 <phao> nice
16:46:02 <phao> thx for help
16:46:24 <edwardk> aristid: yeah, it works pretty well for their workloads, though their arrays can do some pretty odd stuff, shift, etc
16:47:10 <mm_freak_> phao: in any case, if you need arrays, powerful array libraries (even with automatic parallelization) are available, so it's really wrong to say that functional programmers don't use arrays =)
16:47:25 <latro`a> mm_freak_, what you said about arrays doesn't match python, does it?
16:47:26 <geekosaur> most dynamic languages actually followed in awk's footsteps (associative arrays) instead of perl's; perl split arrays and hashes
16:47:39 <latro`a> (iirc python's lists are C arrays with weird stuff buckled onto them, under the hood)
16:47:53 <mm_freak_> phao: 'vector' is a fast library that even fuses your array operations to the point, where you can work with immutable arrays and still get mutable performance…  and then there is 'repa', which does parallel arrays operations transparently (!)
16:48:02 <aristid> edwardk: well my point is more that i don't like having a single container for _all_ these things
16:48:04 <phao> mm_freak_, I don't venture into these statements =) I guess even the most strange DS is useful to somebody
16:48:10 <mm_freak_> latro`a: i don't know python well enough
16:48:10 <edwardk> sure
16:48:35 <companion_cube> python has both arrays and associative arrays (aka 'dicts')
16:48:52 <latro`a> iirc python's indexing and append are both O(1), though the append is a rather slow O(1)
16:49:01 <ahkurtz> what is operation fusion? combining loops that each do one op into a single loop?
16:49:19 <aristid> companion_cube: python calls them "lists", right? or was it tuples?
16:49:28 <companion_cube> yes, it's lists
16:49:34 <barometz> Python has both lists and tuples :)
16:49:36 <mm_freak_> ahkurtz: basically yes
16:49:39 <companion_cube> tuples are actually one of the rare python immutable stuf
16:49:39 <barometz> the latter is immutable
16:49:41 <companion_cube> stuff
16:49:48 <mm_freak_> ahkurtz: fusion can actually get rid of in-memory data structures
16:49:48 <latro`a> lists and tuples are distinct; lists are mutable, tuples immutable (modulo pointers)
16:49:49 <aristid> barometz: *blink*
16:50:01 <barometz> aristid: eye drops?
16:50:09 <aristid> barometz: it just seems weird
16:50:25 <barometz> it is a bit.
16:50:46 <aristid> not everything can be as elegant as ADTs i guess
16:50:51 <ahkurtz> mm_freak_: like, normally because of immutability this would be a copy on each op, but fusion does it safely in place under the hood?
16:50:58 <barometz> Tuples also pop up in all sorts of weird places, fortunately they've been eliminated for the new string formatting
16:51:12 <mauke> barometz: how does the new string formatting work?
16:51:13 <scri> mm_freak_: holy crap it _is_ fast...
16:51:27 <barometz> mauke: positional and named parameters to str.format()
16:51:29 <aristid> barometz: so they are basically phasing them out?
16:51:30 <ahkurtz> and somehow it avoids sharing intermediate values?
16:51:34 <mauke> barometz: ah, boring
16:51:39 <barometz> aristid: I doubt that
16:51:40 <mm_freak_> ahkurtz: fusion gets rid of intermediary data structures
16:51:49 <mm_freak_> scri: =)
16:52:00 <scri> mm_freak_: thanks!
16:52:02 <barometz> mauke: effective!  Especially as you can pass dictionaries as argument lists, which makes for some convenient shortcuts
16:52:07 <mm_freak_> scri: you're welcome
16:52:38 <mm_freak_> scri: an arithmoi-based RSA key generator actually outperformed openssl for me =)
16:53:32 <companion_cube> python is quite expressive in the small, but really untractable in the large...
16:54:23 <MostAwesomeDude> companion_cube: IYSS.
16:55:27 <companion_cube> MostAwesomeDude: ok, it's just my opinion, but I find that no way to specify interfaces nor enforcing types makes it really hard
16:55:52 <companion_cube> you basically have no check on your code, even about existence of the functions/variables you talk about
16:56:29 <barometz> There's a reason unittesting is a fairly big thing.  The whole duck typing thing is... well, I find it less than ideal for bigger stuff
16:56:39 <MostAwesomeDude> companion_cube: Well, first, there are good tools for interfaces: ABCs, zope.interface.
16:56:55 <scri> ok... haskell is awesome
16:57:06 <MostAwesomeDude> companion_cube: Second, unit tests are important.
16:58:12 <aristid> barometz: in perl (which is mauke's favorite language as far as i understand), _all_ function calls involve passing a list or hashmap, or combination. so compared to that it's not particularly effective
16:58:20 <companion_cube> yeah, but replacing interfaces and types by testing is tough
16:58:54 <MostAwesomeDude> Again, IYSS.
16:59:04 <companion_cube> yep
16:59:36 <companion_cube> my brain just sucks at dynamic typing ^^
17:01:11 <mauke> I was about to cite a perl example
17:01:29 <mauke> http://paste.scsys.co.uk/204891
17:01:50 <mauke> Global symbol "$ofset" requires explicit package name at XFile.pm line 53.
17:01:56 <mauke> Bareword "SEEK_SET" not allowed while "strict subs" in use at XFile.pm line 52.
17:02:12 <mauke> (can't do that in python)
17:03:07 <Reaga> The haskell community is worthy of my contempty.
17:03:20 <ahkurtz> no I do not like perl and CPAN, no I do not like them sam I am. I will not use perl and CPAN, I will not use them with a fox ...
17:03:24 <mauke> Reaga: you didn't answer my question
17:03:24 <Reaga> My improvements to haskell include being more vague.
17:03:29 <Reaga> what was your question
17:03:32 <MostAwesomeDude> Reaga: Do you have a reputation for holding things in contempt?
17:03:34 <mauke> Reaga: scroll up
17:04:07 <Reaga> ok, to annswer your question
17:04:28 <Reaga> I determined they are shoddy because people told me so
17:04:31 <Reaga> people whom i trust
17:04:40 <mauke> do these people exist outside of your head?
17:04:46 <Reaga> Yes
17:04:52 <mauke> [citation needed]
17:04:58 --- mode: ChanServ set +o edwardk
17:04:59 <Reaga> citation granted
17:04:59 <MostAwesomeDude> Okay. So what do you hope to gain by talking about it on IRC?
17:05:05 <Reaga> Understanding
17:05:16 <typoclass> Reaga: do you think people are likely to listen to you after you made broad insults like "you're worthy of my contempt"?
17:05:26 <mauke> MostAwesomeDude: <Reaga> anyone want to help me build up th haskell libraries?  <Reaga> they're pretty shoddy at the moment
17:05:30 --- mode: edwardk set +b reaga!*@*
17:05:37 <mauke> keep in mind that Reaga knows nothing about haskell
17:06:00 <MostAwesomeDude> mauke: Fair enough.
17:06:46 --- mode: edwardk set +b *!~Dantion@host81-141-142-107.wlms-broadband.com
17:06:46 --- kick: Reaga was kicked by edwardk (Your behavior is not conducive to the desired environment.)
17:06:49 <edwardk> that was better ;)
17:06:59 --- mode: edwardk set -b reaga!*@*
17:07:12 <edwardk> missed my first kick
17:07:26 --- mode: edwardk set -o edwardk
17:07:54 <ahkurtz> troll bell
17:08:01 <RichyB> edwardk: obviously you are missing a non-shoddy IRC library with a non-shoddy kickAndBan :: String -> IO () subroutine. ;)
17:08:08 <latro`a> lol
17:08:25 <edwardk> RichyB: heh well, i blame textual being case sensitive on nicks ;)
17:08:39 <RichyB> Ooh
17:08:41 <typoclass> RichyB: where the type system guarantees that the target nickname exists?
17:08:47 <latro`a> ....
17:09:21 <RichyB> If you implemented an ircd where the ephemeral state was backed by STM, you could provide a primitive KICKBAN command that really did guarantee no gap between the ban the kick.
17:10:15 <RichyB> typoclass: no, that's overkill. A more sensible boundary is to use the type system to guarantee that the server won't crash on a non-existent nick. :)
17:13:51 <RichyB> Does Agda get compiled by transforming it into Haskell and feeding it into GHC or am I totally smoking crack on that one?
17:14:54 <geekosaur> that was my understanding, not that I've looked that closely
17:15:10 <aristid> RichyB: i think most agda code is never compiled at all, but the different compiler backends of agda are probably a better topic for #agda ?
17:16:32 <RichyB> I was kind of being lazy and assuming that the entire Agda community was also following Haskell too. ¬_¬
17:20:43 <edwardk> RichyB: there are a number of agda backends, you can definitely extract haskell from it, but thats usually done at the end, and who actually runs agda code? typechecking it is the adventure
17:22:14 <RichyB> Huh.
17:22:52 <nand`> I hear some people claim to use Agda as a general purpose programming language
17:33:55 <cleantc> Is "constraint" kind also a star kind (sub-kind)?
17:35:54 <Nereid> no
17:38:08 <edwardk> cleantc: no
17:38:31 <edwardk> cleantc: if you need to pass around constraints as values you can use my constraints package though
17:38:50 <edwardk> @hackage constraints
17:38:51 <lambdabot> http://hackage.haskell.org/package/constraints
17:39:12 <cleantc> oh, thanks!
17:39:35 <edwardk> that includes machinery for modeling classes and instances as a class ;)
17:39:43 <mysticc> I am compiling my program with ghc --make , but no executabel is produced . It only produces 2 files ,, one .hi and one .o
17:40:11 <mauke> mysticc: paste ls -l output
17:40:12 <edwardk> so in addition to passing them around you can use them to discharge obligations, compose them, etc.
17:40:27 <Enigmagic> mysticc: make sure the module you're compile is called Main, or use the -main-is arg to set it
17:40:30 <cleantc> I guess it is not possible to define a class of kind "constraint -> constraint"
17:40:32 <geekosaur> mysticc, is there also a -c option?
17:40:56 <edwardk> sure it is
17:41:12 --- mode: ChanServ set +o mauke
17:41:13 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by mauke
17:41:19 <mysticc> Enigmagic: Thanks ..
17:41:32 <edwardk> class Typeable t where typeRepOf :: Proxy t -> TypeRep; instance Typeable Eq -- would work fine
17:41:49 <Enigmagic> mysticc: np
17:42:04 <edwardk> you'd need to turn on polykinds to make t polymorphic enough to accept both something of kind * -> Constraint and other kinds, but thats it
17:42:20 <edwardk> you can of course do so without polykinds if you want to make something more monomorphic
17:43:13 --- mode: mauke set -o mauke
17:43:32 <edwardk> cleantc : take a look at my class Class b h | h -> b where cls :: h :- b  -- for instance
17:43:45 <edwardk> h and b are both classes
17:43:56 <cleantc> edwardk: it requires method signatures to contain the class parameter (otherwise it is considered ambiguous) and (->) :: *->*->* so it doesn't kind-check
17:44:02 <edwardk> instance Class (Eq a) (Ord a) -- reifies the relatioship class Eq a => Ord a
17:44:52 <edwardk> similarly class b :=> h | h -> b where ins :: b :- h  -- is how i reify instances. so to reify an instance Ord a => Ord [a] -- you can use instance Ord a :=> Ord [a]
17:44:56 <cleantc> oh right, method-less class definition
17:45:07 <edwardk> no, i have methods in there
17:45:13 <edwardk> i just wrote it without for irc
17:45:25 <edwardk> cls works great
17:45:59 <edwardk> (:-) forms what would be a valid Category if Control.Category.Category was polykinded
17:46:29 <edwardk> id is the identity implication that says that the constraint oblication a can be met by a dictionary for constraint a. and (.) is composition of entailment
17:46:36 <edwardk> er obligation
17:47:15 <edwardk> if we start with data Dict where Dict :: a => Dict a
17:47:27 <edwardk> we can make newtype a :- b = Sub (a => Dict b)
17:47:43 <edwardk> which is a data type that says that given a dictionary for 'a' we can give you a dictionary for b
17:47:56 <edwardk> then a :- a is trivial.
17:47:58 <edwardk> id = Sub Dict
17:48:18 <edwardk> and we can make a combinator for performing dictionary substitution
17:48:25 <edwardk> (\\) :: a => (b => r) -> (a :- b) -> r
17:48:46 <edwardk> r \\ Sub Dict = r
17:48:51 <hpc> what's (=>) here?
17:48:54 <edwardk> with that everything else is easy
17:48:59 <edwardk> (=>) is what it always has been
17:49:05 <edwardk> :t 2
17:49:06 <lambdabot> forall t. (Num t) => t
17:49:09 <edwardk> ^- same =>
17:49:12 <hpc> huh
17:49:23 <edwardk> its funny seeing it in negative position there, but its legal ;)
17:49:46 <hpc> obviously it uses higher ranked types and data kinds
17:49:55 <hpc> er
17:49:57 <hpc> constraint kinds
17:49:58 <edwardk> given a constraint a, and something that given a constraint b can give you an r, and the fact that a entails b, i can give you an r
17:50:05 <edwardk> just constraint kinds, yeah
17:50:24 <edwardk> data kinds didn't exist when i wrote the constraints package
17:51:13 <edwardk> basically pattern matching on Sub incurs the obligation on a, which matches the supplied dictionary, then matching on Dict gives you back the b you need to resolve the argument r.
17:51:40 <edwardk> trans :: (b :- c) -> (a :- b) -> a :- c; trans f g = Sub $ Dict \\ f \\ g  -- gives you transitivity of entailment
17:51:53 <edwardk> and almost everything else is written the same way
17:52:06 <edwardk> (&&&) :: (a :- b) -> (a :- c) -> a :- (b, c); f &&& g = Sub $ Dict \\ f \\ g
17:52:24 <edwardk> matching on the constructors is enough to discharge the remaining obligations in scope
17:52:33 <edwardk> its rather impressive how nicely it works out
17:53:15 <edwardk> i wrote the package because the unification that ghc uses on constraint types isn't good enough for many uses, sometimes i need to flip around arguments or check entailment or bientailment
17:53:39 <edwardk> and i needed a toolbox for those kinds of permutations
17:54:04 <sentientwaffle> is there a module that I can use to get the rows/columns of a TTY terminal?
17:54:29 <edwardk> that and you have to admit reifying an instance Ord a => Ord [a]    as another instance Ord a :=> Ord [a] where ins = Sub Dict -- is pretty hilarious ;)
17:54:43 <startling> sentientwaffle, the number of rows and columns?
17:54:51 <Jafet> @hackage vty
17:54:52 <lambdabot> http://hackage.haskell.org/package/vty
17:54:54 <Jafet> @hackage hcurses
17:54:55 <lambdabot> http://hackage.haskell.org/package/hcurses
17:54:55 <edwardk> especially since the class :=> is reified by instance Class () (:=> b a)
17:55:01 <startling> @hackage terminfo
17:55:02 <lambdabot> http://hackage.haskell.org/package/terminfo
17:55:24 <edwardk> and then it bootstraps with (b :=> a) => () :=> (b :=> a)
17:55:41 <edwardk> and Class b a => () :=> (Class b a)
17:56:19 <sentientwaffle> startling, Jafet: yes, thanks!
17:56:38 * edwardk shuts up and goes back to playing with lenses
17:57:47 <startling> sentientwaffle: fwiw these are all for unixes I think
17:58:35 <sentientwaffle> startling: oh, theres other operating systems?
17:59:07 <Clint> toy ones
18:02:29 <startling> sentientwaffle, yeah, but no one uses them
18:02:45 <startling> no point in supporting BeOS and Hurd and Windows
18:03:03 <geekosaur> enh. there is pc-curses but I don't think any haskell bindings are actually known to work with it
18:03:21 <startling> oh, I was being farcical
18:03:41 <startling> no idea, never done terminal stuff on windows
18:03:48 <tarps> unicks
18:03:57 <startling> eunuchs
18:04:09 <Jafet> Windows doesn't have a terminal, so it's a moot issue.
18:04:30 <startling> fair enough
18:04:44 <nand`> so I got through the first few paragraphs of this post about free monads of indexed store comonads; then I got to “James and Sabry then proceeded to optimize it by hitting it with Codensity”. Okay, now where do I learn what the heck a Codensity is?
18:05:52 <tarps> eunuchs have oprn sores
18:05:56 <hpc> iirc, codensity is (forall r. Cont r a)
18:06:18 <hpc> and it accomplishes a similar task as DList
18:06:23 <hpc> @hoogle DList
18:06:23 <lambdabot> Text.Html dlist :: Html -> Html
18:06:23 <lambdabot> Text.XHtml.Strict dlist :: Html -> Html
18:06:24 <lambdabot> Text.XHtml.Frameset dlist :: Html -> Html
18:06:44 <Jafet> type DList a = [a] -> [a]
18:06:46 <hpc> http://hackage.haskell.org/package/dlist
18:06:48 <hpc> yeah, that
18:07:42 <hpc> never actually used it though, so i am likely wrong
18:08:03 <nand`> edwardk: any good posts on the matter?
18:08:32 <edwardk> nand`: check my kan extension articles
18:08:48 <edwardk> james and sabry never used the name codensity
18:09:13 <edwardk> newtype Codensity f a = Codensity { forall r. (a -> f r) -> f r }
18:09:25 <edwardk> its in my kan-extensions package, and there are 3 kan extension posts on my blog
18:10:31 <applicative> nand` http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/ links several things; exercises included
18:12:21 <nand`> “Have you ever wondered how the codensity transformation, a surprisingly general trick for speeding up the execution of certain types of monads, worked, but never could understand the paper or Edward Kmett's blog posts on the subject?”
18:12:23 <nand`> heh
18:13:54 <applicative> The answer is of course Yes
18:14:32 <edwardk> hahha
18:17:24 <startling> nand`: hahaha
18:23:03 <jmcarthur> nand`: do you understand how dlist works?
18:23:09 <jmcarthur> difference lists, that is
18:23:36 <nand`> jmcarthur: after a quick glance at the haddock, I feel so; yeah
18:23:55 <jmcarthur> the trick there is similar to the codensity trick
18:24:16 <nand`> basically using function composition to re-order various (efficient) prepend operations in the ‘opposite’ way when appending
18:24:21 <byorgey> it's actually the same trick, from a sufficiently general point of view
18:24:28 <jmcarthur> byorgey: exactly
18:24:33 <byorgey> as explained in Ralf Hinze's paper "Art and Dan explain an old trick"
18:24:42 <edwardk> yeah
18:24:49 <edwardk> i was very pleased with that paper
18:24:58 <byorgey> (Art and Dan being Arthur Cayley and Daniel Kan)
18:25:05 <hpc> basically, it takes (a >> (b >> (c >> ...
18:25:15 <byorgey> it's a great paper.  I am still in the process of wrapping my head around it.
18:25:31 <hpc> and turns it into ((((a >> b) >> c) >> ...
18:25:31 <edwardk> i don't just say that because it mentions my blog ;)
18:25:35 <jmcarthur> hpc: other way around
18:25:38 <edwardk> hpc: the other way
18:25:44 <hpc> ah yes
18:26:02 <nand`> ++ is >> for some free monad?
18:26:03 <edwardk> basically if you apply it to a free monad, it avoids retraversing the core of the structure over and over again for left associated binds
18:26:07 <hpc> and (>=>) instead of (>>)
18:26:12 <MostAwesomeDude> What's the right thing to use for parsing JSON?
18:26:32 <edwardk> nand`: its never >>
18:26:34 <hpc> in fact...
18:26:43 <edwardk> laws get in the way
18:26:48 <hpc> data Endo a = Endo (a -> a)
18:26:49 <jmcarthur> nand`: not that i know of, but there is a free monad for which they have similar behavior
18:26:54 <hpc> -- can be generalized to
18:27:03 <hpc> data Endo arr a = Endo (arr a a)
18:27:06 <edwardk> yep
18:27:19 <hpc> which gives you Codensity if you put Kleisli in there, i think
18:27:26 <edwardk> i had that as GEndo in some version of category-extras
18:27:33 <nand`> I thought (>>) is like (++) for Free (a,) ()
18:27:36 <hpc> or something that's pretty close, anyway
18:27:37 <jmcarthur> hpc: i don't think so...
18:27:42 <edwardk> hpc: don't think so
18:27:45 <nand`> maybe I'm remembering incorrectly
18:28:11 <edwardk> codensity and kleisi come up when you start talking about the yoneda lemma in the kleisli category of a monad
18:28:51 <edwardk> _then_ you can see the connection between forall r. (a -> m r) -> m r   and forall r. (a -> r) -> m r  for a monad m. which is not immediately obvious
18:30:02 <edwardk> the fact that Codensity m and Yoneda m are isomorphic when  m is a  monad wasn't obvious to me at all
18:30:33 <edwardk> that was the main 'nice!' moment from the art and dan paper for me
18:30:47 <edwardk> because i'd previously strongly believed it wasn't true
18:30:53 <edwardk> (when m is not a monad it doesn't hold)
18:31:25 <edwardk> e.g. forall r. (a -> r) -> Endo r    is Maybe    while forall r. (a -> Endo r) -> Endo r  is []
18:32:39 <edwardk> but it makes me feel better about the interchangeable use of forall r. (a -> Maybe r) -> Maybe r with Maybe a and with  forall r. (a -> r) -> Maybe r
18:33:51 <hpc> edwardk: i can see how you can convert from one to the other quite plainly
18:34:12 <edwardk> sure =)
18:34:15 <hpc> by interpreting the (a -> m r) parameter as just the last action in the sequence
18:34:22 <hpc> :P
18:34:43 <edwardk> you pass it return and you can get the m a out
18:35:06 <edwardk> but it was reassociated right by the way it was build
18:35:11 <edwardk> er built
18:35:23 <hpc> and it only works for monads because the conversion requires both return and join
18:36:02 <edwardk> well, the fact that it is an isomorphism for monads is what shocked me. the Endo example was my old standby
18:38:03 <startling> Word32 roughly corresponds to a 32-bit uint, right? how do I do a 32-bit signed int?
18:38:17 <startling> > -1 :: Word32
18:38:17 <edwardk> Int32
18:38:18 <lambdabot>   4294967295
18:38:32 <startling> edwardk: I should've guessed
18:38:35 <edwardk> > -1 :: Int32
18:38:37 <lambdabot>   -1
18:45:15 <MostAwesomeDude> Oh! That's quite clever.
18:45:29 <MostAwesomeDude> You gotta have the entire type written out for a JSON parse in Text.JSON. Nifty.
18:46:06 <roconnor_> MostAwesomeDude: link?
18:46:15 <MostAwesomeDude> roconnor_: http://hackage.haskell.org/packages/archive/json/0.5/doc/html/Text-JSON.html
18:46:51 <MostAwesomeDude> I wanted to see what it would give me for just a random large chunk of JSON, and it told me that it couldn't parse ().
18:47:24 <MostAwesomeDude> Oh, I guess I can specify JSValue.
18:47:46 <roconnor_> JSON ()
18:49:51 <startling> is there a typeclass of things you can do a c-like sizeof on?
18:50:06 <shachaf> Storable
18:50:18 <nand`> edwardk: Ran f g a is equivalent to (a, forall b. f b -> g b) ?
18:50:44 <edwardk> no
18:50:55 <luis> Hi. I'm trying to run threadscope on OSX (Lion), a blank window briefly pops up, but then I get an assertion failed related to cairo followed by "Abort trap: 6".
18:51:06 <startling> shachaf: that's not quite what I want, since size takes an argument
18:51:06 <edwardk> Ran f g a = forall r. (a -> f r) -> g r
18:51:08 <luis> Any ideas how to fix this?
18:51:17 <startling> er, sizeOf
18:51:19 <geekosaur> luis, I was under the impression threadscpe was known not to work on OS X
18:51:25 <shachaf> startling: You can just pass it undefined.
18:51:27 <nand`> oh right, I can't extract the ‘a’ closed in a Ran f g a can I?
18:51:34 <startling> shachaf: oh, that's true
18:51:35 <edwardk> nand`: check out my monad-ran package, which redefines all monad-transformers as right-kan-extension transformers
18:51:38 <nand`> (without suitable f g)
18:51:53 <startling> > sizeOf (undefined :: Word8)
18:51:55 <edwardk> (it also includes right kan extension forms for IO, ST s, and STM, etc.
18:51:55 <lambdabot>   Not in scope: `sizeOf'
18:52:03 <nand`> will do
18:52:22 <nand`> yikes, is that some really old haddock output?
18:52:46 <luis> geekosaur: uf, really? :-/
18:52:52 <edwardk> probably =)
18:52:57 <edwardk> i haven't really updated it
18:53:19 * luis boots up his Ubuntu VM...
18:53:43 <edwardk> that was a very early (ab)use of type families
18:53:59 <geekosaur> luis, apparently someone did get it to work recently:  http://www.haskell.org/haskellwiki/Talk:ThreadScope_Tour/Install
18:55:38 <edwardk> nand`: it turns out that using the ran transformer is usually only a win when it can be a codensity transformer
18:55:55 <startling> how come I still get "x is not a derivable class" even with GeneralizedNewtypeDeriving switched on?
18:56:20 <nand`> is the type you are deriving it for a newtype?
18:56:35 <shachaf> In particular, is it a newtype of something that has an instance?
18:57:00 <startling> yes
18:57:04 <Okasu> http://vpaste.net/zsHNJ whats wrong with it?
18:57:09 <startling> oh ugh the {-# Language wasn't on the first line
18:57:17 <Okasu> i'm tryng to builf lambdabot with 'cabal build'
18:57:34 <Okasu> 'cabal configure' was fine
18:57:52 <shachaf> What version of GHC?
18:58:05 <Okasu> Glasgow Haskell Compiler, Version 7.4.2, stage 2 booted by GHC version 7.4.1
18:58:42 <ku> Is Haskell really inferior to Erlang for concurrency?
18:59:02 <nand`> @protontorpedo
18:59:03 <lambdabot> can u build things fast in haskell?
18:59:09 <luis> ku: what kind of a question is that?
18:59:19 <latro`a> that's really too vague to answer
18:59:24 <nand`> ^
18:59:35 <Okasu> strange thing i was able to build i run lambdabot with 'cabl install lambdabot' but it's fails when i pull it from datcs
18:59:38 <ku> luis, one stemming from confusing blog posts
18:59:43 <latro`a> haskell has powerful native facilities for concurrency
18:59:45 <latro`a> so does erlang
18:59:50 <latro`a> the facilities themselves are completely different
19:00:08 <nand`> haskell has the capabilities to make your own concurrency systems
19:00:11 <pharaun> perhaps ku is referring to the whole crash/retry thing in erlang?
19:00:19 <Cale> I think Haskell is better for SMP stuff, and Erlang is better for distributed stuff, from what I've seen.
19:00:27 <ku> I'm referring to concurrency in general
19:00:29 <pharaun> but that's the OTP
19:00:34 <nand`> I've heard ‘cloud haskell’ mentioned in this regard
19:00:43 <nand`> but I don't know how complete, usable, good or otherwise it is
19:00:46 <latro`a> ku--there's really no way to *be* that general
19:00:49 <ku> mostly distributed computing and perhaps the Actor model
19:00:55 <ku> latro`a, ^ that
19:00:57 <latro`a> when both languages have powerful concurrency systems
19:01:14 <latro`a> given that the Actor model is built right in, for that one purpose you can probably irrefutably say erlang is better
19:01:35 <Okasu> how can i tell cabal to build lambdabot with -XFlexibleInstances?
19:01:36 <latro`a> but then, by what I've heard STM is one hell of a powerhouse
19:01:42 <Jafet> Just use whichever language is winning threadring
19:01:51 <parcs`> @faq can haskell really inferior to erlang for concurrency?
19:01:51 <lambdabot> The answer is: Yes! Haskell can do that.
19:02:04 <Jafet> Add {-# LANGUAGE FlexibleInstances #-} to the module that needs it
19:02:06 <ku> @faq Does @faq say Yes to everything?
19:02:06 <lambdabot> The answer is: Yes! Haskell can do that.
19:02:25 <shachaf> Okasu: --ghc-options "-XFlexibleInstances", maybe.
19:02:32 <shachaf> But you probably shouldn't have to do that...
19:02:36 <ku> What about writing event-based servers, Node.js-style, but distributed? Haskell vs Erlang?
19:02:47 <Jafet> Why not just use Node.js
19:03:00 <aristid> shachaf: cabal knows an Extensions field
19:03:06 <nand`> for one, it's javascript; for two, it's awful
19:03:17 <Jafet> If you want Node.js
19:03:18 <luis> geekosaur: I think this might be my problem: http://trac.haskell.org/ThreadScope/ticket/8
19:03:25 <shachaf> aristid: Yes, but modifying the .cabal file isn't nice.
19:03:31 <latro`a> I don't understand all this comparison of pairs of languages that both have rich features
19:03:49 <shachaf> ku: "Haskell vs Erlang" questions are probably not going to get much useful accomplished in here (nor in #erlang, for that matter).
19:03:49 <startling> is there a nice way to define peek and poke for a Storable instance that's just a collection of other Storables?
19:03:52 <ku> Jafet, because I don't want JavaScript?
19:03:59 <Cale> Just spend some time learning the language, see if you like it
19:04:01 <startling> erlang is dynamic
19:04:03 <ku> and I want Haskell
19:04:05 <startling> sometimes that's useful
19:04:08 <ku> I do like Haskell
19:04:29 <ku> and Erlang feels like the new PHP in terms of hype-ugliness relation
19:04:36 <shachaf> Anyway, that argument is more suited for #haskell-overflow or something.
19:04:41 <ku> except it is actually good at something
19:04:45 <shachaf> It's certainly out of place here.
19:05:04 <ku> shachaf, there are 14 people in that channel.
19:05:24 <shachaf> Good! Maybe it'll die more quickly.
19:05:40 <mauke> why -overflow?
19:05:47 <shachaf> If you have a specific question about doing something in Haskell I'm sure people in here would be happy to answer it.
19:05:51 * nand` has a feeling http://jlouisramblings.blogspot.de/2010/04/haskell-vs-erlang-for-bittorent-clients.html?_escaped_fragment_ might be relevant
19:06:03 <ku> nand`, thanks, I'll take a look
19:06:21 <nand`> it's not about concurrency but it approaches the ‘Haskell or Erlang?’ question
19:06:27 <nand`> by showing the pros and cons of both
19:06:28 <ku> I read through the first 10 chapters of LYAH, is that good enough for H99?
19:06:31 <Jafet> National telecoms networks don't run on PHP
19:06:50 <mauke> Jafet: as far as you know
19:06:55 <Okasu> for what version of ghc people writing libs(and update olfd ones) for now?
19:07:01 <Jafet> Well, maybe mine does
19:07:09 <nand`> mauke: would explain my ISP's poor services!
19:07:10 <Jafet> Anyway, badtroll is bad
19:07:34 <shachaf> Jafet: What nation is that?
19:08:18 <Jafet> The republic of unaffiliated
19:09:48 <nand`> edwardk: your (first?) article on kan-extensions shows how Ran can be a Monad for all types of kind * -> *; but does it satisfy the monad laws for non-functors as well?
19:10:02 <edwardk> yes
19:10:12 <edwardk> try Endo
19:11:26 <edwardk> more interestingly: forall r. Monoid r => (a -> r) -> r -- should look familiar after playing with folds!
19:12:57 <nand`> Monoid r => Ran (Const r) (Const r) a ?
19:13:32 <shachaf> Hmm, cabal install data-memocombinators seems to be failing on the download.
19:13:37 <shachaf> Even though other packages are succeeding.
19:13:39 <shachaf> Any idea why?
19:14:20 <startling> hmmm, what's a good way to read a sequence of values from a Ptr? surprised there's not a monad or applicative for this
19:14:59 <shachaf> Data.Binary.Get?
19:15:10 <shachaf> Or who knows.
19:15:17 <shachaf> mapM? Why do you need a monad?
19:15:27 <startling> would be cool if I could just do Mything <$> peek <*> peek <*> peek and Mything <$> poke <*> poke <*> poke
19:15:49 <ku> Why do I get this: last'.hs:2:1: Parse error in pattern: last'
19:15:59 <shachaf> ku: Because you have invalid syntax.
19:16:13 <shachaf> It's probably on line 2, column 1, in the pattern: last'
19:16:17 <shachaf> I can't tell you any more than that.
19:16:52 <ku> shachaf, er, thanks, putting parens around (x:xs) seems to fix it
19:17:03 <nand`> startling: I thought you could do that using the Get monad and then run that get on a Ptr or something
19:18:06 <startling> oh, Data.Binary looks fancy
19:18:14 <startling> shachaf: missed that, thanks
19:20:52 <ku> Sorry for the stupid question, but what does this do?:  foldr1 (const id)
19:21:14 <shachaf> @ty foldr1 (const id)
19:21:16 <lambdabot> forall a. [a] -> a
19:21:22 <shachaf> > foldr1 (const id) "hello"
19:21:23 <lambdabot>   'o'
19:21:29 <shachaf> Looks like it gives you the last element of a list.
19:21:35 <shachaf> Commonly known as "last".
19:22:13 <parcs`> > foldr1 const "hello"
19:22:14 <lambdabot>   'h'
19:22:18 <parcs`> > foldl1 const "hello"
19:22:20 <lambdabot>   'h'
19:22:23 <parcs`> > foldl1 (const id) "hello"
19:22:24 <lambdabot>   'o'
19:22:49 <ku> But what are "const" and "id"?
19:22:52 <shachaf> Don't foldl1 const
19:22:59 <shachaf> ku: You should look them up on Hoogle!
19:23:02 <shachaf> @where hoogle
19:23:02 <lambdabot> http://haskell.org/hoogle
19:23:09 <shachaf> That's a good way to figure that sort of thing out.
19:23:11 <nand`> (const id) returns its second parameter, which in the case of foldr is the initial value; or in foldr1 the last element of the list
19:24:14 <nand`> then the same happens again and again all the way back to the beginning of the fold, where it gets returned
19:24:19 <parcs`> > foldl1 const [1..1000000]
19:24:21 <lambdabot>   1
19:24:36 <ku> Why (const id) instead of const?
19:24:45 <nand`> :t const
19:24:46 <ku> > foldr1 const "hello"
19:24:49 <lambdabot>   'h'
19:24:49 <lambdabot> forall a b. a -> b -> a
19:24:51 <nand`> :t const id
19:24:53 <lambdabot> forall a b. b -> a -> a
19:24:54 <parcs`> > foldl1 const [1..100000000]
19:24:58 <lambdabot>   mueval-core: Time limit exceeded
19:25:02 <nand`> ‘const’ returns its first parameter, ‘const id’ returns its second parameter
19:25:31 <nand`> > foldr1 const [1..100000000000]
19:25:32 <lambdabot>   1
19:26:46 <startling> heh, get = Mything  <$> get <*> get <*> get <*> get <*> get <*> get <*> get <*> get
19:26:58 <startling> <3
19:27:29 <ku> What is the point of id? I still don't understand, it seems like a useless function to me (although it's obviously not)
19:27:38 <roconnor_> ku: useful in higher order functions
19:27:44 <nand`> ku: to see why these functions in particular are picked for head/last; look at the expanded form of fold f xs:   x₁ `f` x₂ `f` x₃ `f` ... `f` e; in the case of the -1 variants ‘e’ is just ‘xn’ (the last item in the list). Which way these are grouped is depends on whether you choose the foldl or foldr variants. At any rate, you can see that if `f` always returns the left hand side, it evaluates
19:27:46 <nand`> down to x₁. If it always returns the right hand side, it evaluates down to ‘e’ or ‘xn’
19:28:04 <Cale> > foldr (.) id [reverse, map toUpper] "hello"
19:28:09 <lambdabot>   mueval-core: Time limit exceeded
19:28:28 <Cale> wat
19:28:31 <nand`> an odd thing to time out on
19:28:31 <Cale> > foldr (.) id [reverse, map toUpper] "hello"
19:28:34 <lambdabot>   "OLLEH"
19:28:35 <startling> :t const . id
19:28:38 <lambdabot> forall a b. a -> b -> a
19:28:40 <Cale> I wonder if lambdabot's machine is having trouble
19:28:43 <nand`> const . id = const
19:28:49 <startling> er wait
19:28:53 <startling> :t id . const
19:28:53 <roconnor_> > foldr ($) "hello" [reverse, map toUpper]
19:28:54 <lambdabot> forall a b. a -> b -> a
19:28:55 <lambdabot>   "OLLEH"
19:28:58 <Jafet> f . id = f
19:28:58 <nand`> id . const = const
19:29:00 <startling> yeah dunno what I'm thinking of
19:29:04 <Jafet> id . f = f
19:29:06 <roconnor_> granted ($) is just id so
19:29:10 <Cale> huh, things look pretty okay
19:29:10 <roconnor_> > foldr id "hello" [reverse, map toUpper]
19:29:12 <lambdabot>   "OLLEH"
19:29:18 <startling> there's something a little too clever for me to remember
19:29:41 <Okasu> Cale: nah, i'm recently get this "mueval-core: Time limit exceeded" when performin "1+1" :/
19:29:53 <Cale> > zipWith ($) [(*10),(*100),(+5)] [4,5,10]
19:29:55 <lambdabot>   [40,500,15]
19:29:58 <Cale> > zipWith id [(*10),(*100),(+5)] [4,5,10]
19:30:00 <lambdabot>   [40,500,15]
19:30:10 <Cale> ($) and id are of course the same thing :)
19:30:15 <Cale> (modulo types)
19:30:18 <nand`> ku: const a _ = a;  so (const) x y  = x;  and const id x = id; so (const id x) y = y
19:31:07 <startling> hm, how do I write a put for a collection of other Binary types?
19:31:09 <ku> nand`, thanks, but you lost me
19:31:34 <Cale> ku: Basically, we like to write higher order functions when we see a pattern showing up in our programs except some bit of the program changes. We factor it out and take the changing bit of the function as a parameter.
19:31:41 <nand`> (as for the definition of last using foldr1, if you don't like the pointfree version you could look at this:)
19:31:51 <Cale> ku: But then it's often the case that we want to fill in one of those parameters with "do nothing here"
19:31:54 <nand`> > foldr1 (\_ l -> l) "foobar"
19:31:55 <lambdabot>   'r'
19:31:57 <Cale> ku: and that's what id does
19:31:59 <startling> :t len . filter id
19:32:00 <lambdabot> Not in scope: `len'
19:32:04 <mikeplus64> > (+1) `id` (+2) `id` 3
19:32:06 <lambdabot>   6
19:32:08 <startling> :t length . filter id
19:32:09 <lambdabot> [Bool] -> Int
19:32:15 <Cale> ku: It's like "why is there 0, when adding it to something does nothing?"
19:32:18 <startling> ^ how many Trues are in a list
19:32:38 <nand`> Cale: that's actually a good example
19:32:44 <ku> Cale, I understand what you said, but I still don't understand id
19:32:53 <mikeplus64> startling: i wonder if ghc would fuse the length and filter calls together ...
19:32:57 <Cale> Just as 0 + x = x, and x + 0 = x, we have that for any function f, that id . f = f, and f . id = f
19:33:09 <Clint> is there some kind of type magic i can use to make a heterogeneous list?
19:33:20 <Jafet> @hackage HList
19:33:20 <startling> Clint, tuples?
19:33:20 <lambdabot> http://hackage.haskell.org/package/HList
19:33:21 <nand`> ku: using Cale's example as a starting point, this is how you would define your own version of ‘sum’
19:33:25 <Cale> ku: id is just the function so that for all x,  id x = x
19:33:26 <nand`> sum = foldl (+) 0
19:33:27 <mikeplus64> Clint: data Atom = forall a. Atom a
19:33:27 <startling> Clint: Either?
19:33:33 <nand`> see how the 0 is there to provide a ‘terminating’ value?
19:33:42 <nand`> we can do the same for composing a ‘pipeline’ of functions:
19:33:49 <startling> :t foldl (.) id
19:33:49 <nand`> compose = foldl (.) id
19:33:51 <lambdabot> forall a. [a -> a] -> a -> a
19:33:57 <ku> Cale, I know, I don't understand the difference between const and const id then
19:34:16 <shachaf> ku: Do you have ghci?
19:34:18 <startling> ku: assuming you mean const . id? nothing, i was confused
19:34:22 <ku> shachaf, yes
19:34:28 <Cale> :t const
19:34:30 <lambdabot> forall a b. a -> b -> a
19:34:33 <Cale> :t const id
19:34:34 <lambdabot> forall a b. b -> a -> a
19:34:41 <shachaf> ku: Run ghci, then type: ":t const"; ":t const id"; "const 1 2"; "const id 1 2"
19:34:42 <startling> const id anything = id
19:34:47 <shachaf> Then you'll know the difference.
19:35:01 <Clint> mikeplus64: ExistentialQuantification?
19:35:07 <ku> shachaf, I understand the effect now, but not how it's achieved
19:35:11 <mikeplus64> Clint: but it's best to define your or data type with the specific things you need, like data Thing = Num Int | Str String | Herp Derp ...
19:35:13 <mikeplus64> Clint: yeah
19:35:22 <shachaf> ku: You can work it out from the types alone.
19:35:38 <shachaf> The implementations follow the types directly.
19:35:39 * ku puts on his thinking cap
19:35:42 <Cale> ku: const is the function which when given any value k, gives a function which when applied to anything else, always results in k
19:35:47 <Clint> mikeplus64: the problem is that i want it to work for any as-yet-undefined instance.  thanks, i'll look into that extension
19:36:01 <Cale> ku: const id is the function which when applied to anything else, always results in id
19:36:27 <Cale> which is a function which takes another thing and returns that
19:36:30 <mikeplus64> Clint: in that case, you could use data Atom = forall a. Typeclass a => Atom a so you don't lose all type information
19:36:45 <Cale> So const is the same as (\x y -> x)
19:36:46 <startling> anyone have a nice Binary instance for a struct-like data structure? I could use an example
19:36:47 <nand`> ku: one way would be via point elimination: you start out with the function you ‘want’; ie. some operator that always returns its right hand side: x `f` y = y; or f _ y = y;   f = \_ y -> y;  now you can eta-reduce this to f = \_ -> id; and rewrite that as f = const id
19:36:53 <Cale> and const id is the same as (\x y -> y)
19:36:57 <Clint> mikeplus64: okay, i'll play
19:36:59 <nand`> I'm not sure if that helps or not, but it answers your question of “how do you get there”
19:39:13 <ku> :t const id
19:39:14 <lambdabot> forall a b. b -> a -> a
19:39:52 <JunkBee> How come my really big number doesn't load properly in haskell, do I need a specific library loaded to handle huge integers?
19:40:09 <mikeplus64> JunkBee: use Integer
19:40:09 <nand`> ‘Integer’ can be fairly huge
19:40:18 <nand`> if you're using that, there must be some other problem
19:40:35 <startling> JunkBee: what are your symptoms?
19:40:44 <mikeplus64> JunkBee: ie huge number :: Integer, or if you need it, huge number :: Rational
19:40:57 <JunkBee> I am typing in a large number and it is printing as '67679'
19:41:15 <startling> JunkBee: where are you typing it in to?
19:41:32 <JunkBee> 6008514751437
19:41:45 <nand`> > 6008514751437 :: Int
19:41:46 <lambdabot>   6008514751437
19:41:59 <startling> > 6008514751437 :: Word8
19:42:01 <lambdabot>   205
19:42:04 <startling> > 6008514751437 :: Word16
19:42:06 <lambdabot>   11213
19:42:11 <startling> > 6008514751437 :: Word32
19:42:13 <lambdabot>   4150471629
19:42:16 <nand`> odd
19:42:20 <startling> > 6008514751437 :: Int32
19:42:22 <lambdabot>   -144495667
19:42:26 <JunkBee> must be my noobness
19:42:34 <startling> JunkBee: dunno what would get you 67679
19:42:35 <nand`> JunkBee: if you shared code we could be more specific
19:42:46 <JunkBee> Ok, one second.
19:43:44 <JunkBee> http://sprunge.us/fCZT
19:44:01 <JunkBee> I am just printing [x, y] right now
19:44:08 <JunkBee> to see what is happening
19:44:10 <mekeor> http://sprunge.us/fCZT?hs is better
19:44:11 <nand`> have you changed Int to Integer?
19:44:23 <JunkBee> Oh, I was googling how to do that
19:44:26 <JunkBee> I will do that now.
19:44:32 <startling> JunkBee: just s/Int/Integer
19:44:35 <nand`> s/Int/Integer/ should do it
19:44:36 <ku> nand`, so, in foldr1 :: (a -> a -> a) -> [a] -> a, the (a -> a -> a) would be const id's (a -> a) -> b -> (a -> a), which makes my brain explode
19:44:38 <nand`> /g too
19:44:44 <startling> heh
19:44:50 <JunkBee> what is the function :: int -> int thing called in haskell, prototype?
19:45:11 <nand`> ku: I have no idea where you got (a -> a) -> b -> (a -> a) from
19:45:25 <nand`> ku: the type of ‘const id’ here is a -> a -> a
19:45:27 <mikeplus64> JunkBee: function :: whatever reads function has type of whatever
19:45:44 <JunkBee> Okay.
19:45:49 <ku> nand`, isn't it b -> a -> a
19:45:49 <roconnor_> JunkBee: type declairation
19:45:59 <startling> I have a function like "x p = m (f p) >> m (g p) >> m (h p)"
19:46:05 <mekeor> JunkBee: type signature
19:46:12 <mikeplus64> JunkBee: f :: x -> y -> z means that f consumes an argument with the type x, another with the type y, and returns a z
19:46:12 <startling> is there a way I can simplify that?
19:46:26 <nand`> ku: correct, but in this case the type signature of foldr1 forces it to be the less general type a -> a -> a; remember that ‘b’ can always be ‘a’ since it's fully polymorphic
19:46:29 <JunkBee> So if I refer to this I say the function type signature?
19:46:36 <roconnor_> JunkBee: yes
19:46:40 <JunkBee> neat :D
19:46:42 <ku> nand`, from the way I understand it, const :: a -> b -> a, and the a is id's a -> a?
19:46:46 <roconnor_> JunkBee: though it doesn't have to be a function
19:47:52 <nand`> ku: oh, I see where you are coming from. Yes; in ‘const id’ the ‘const’ has type (a -> a) -> b -> (a -> a); but since the first argument is already applied in ‘const id’ that isn't in the type signature of ‘const id’ itself anymore: so it's only the part after the first (a -> a) ->; namely ‘b -> (a -> a)’, or ‘b -> a -> a’ due to associativity
19:47:57 <mekeor> JunkBee: did you know that types have kind signatures just like values have type signatures? try ":k Integer" and ":k Maybe", if you want ;)
19:47:57 <latro`a> const id x y = ((const id) x) y = (id) y = y
19:48:28 <latro`a> any weird currying shenanigans can usually be clarified by insertion of parens :p
19:48:51 <startling> oh, I can use ap and pure
19:48:51 <nand`> and we thought we were beyond lisp :)
19:48:56 <latro`a> hah
19:49:12 <latro`a> eventually you build intuition, but until then insertion of parens helps
19:49:20 <JunkBee> so much to know
19:51:12 <latro`a> this works at the type level too, by the way, except in reverse
19:51:30 <latro`a> const :: a -> b -> a; const id :: b -> (a->a) == b -> a -> a
19:52:16 <latro`a> at the type level the parens are there to begin with and then when you remove them the answer is obvious
19:54:40 <Clint> why am i getting "Constructor `Atom' must have a Haskell-98 type"?
19:54:49 <Clint> (when trying to derive instances)
19:55:34 <mikeplus64> haskell 98 doesn't have existential types, so you can't derive instances for it
19:55:37 <mikeplus64> i suppose
19:56:45 <ku> nand`, so, if f = const id 0 1, "const id 0" basically resolves to "id", and "id 1" = 1?
19:57:38 <Clint> ah, hmm
19:58:12 <latro`a> ku: yes, that's how it works
19:58:23 <ku> latro`a, now I feel stupid :P
19:58:30 <latro`a> this sort of thing pretty much happens whenever you return a function
19:58:45 <latro`a> ("return" a function doesn't make total sense, but you get the point)
20:00:43 <ku> latro`a, I think I'm just confused by trying to use Haskell like I would Python
20:01:37 <latro`a> that is probably the case
20:01:40 <latro`a> write some haskell
20:01:50 <latro`a> then throw it out here, asking if it's any good
20:01:56 <latro`a> at first people will probably tear it up :p
20:02:04 <latro`a> then you'll get used to some idioms
20:02:18 <ku> There is also this thing I do where I read an entire programming book without writing any code
20:02:26 <ku> #badhabit
20:02:30 <latro`a> yes, I do the same with math
20:02:47 <ku> you can get away with doing that with math...
20:02:54 <latro`a> not really
20:03:00 <latro`a> more than programming maybe
20:03:29 <ku> as for people tearing code up, I'm just trying to do H99 and comparing with the official solutions atm
20:05:50 <ku> > foldr1 const "xyz"
20:05:51 <lambdabot>   'x'
20:06:05 <ku> > foldl1 const "xyz"
20:06:06 <lambdabot>   'x'
20:11:08 <ku> What is "curry id" and why is its type declaration longer than id's?
20:11:17 <Cale> :t curry
20:11:19 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:11:33 <Cale> ku: if c = (a,b) in that type
20:11:50 <Cale> and we use the specialisation id :: (a,b) -> (a,b)
20:12:05 <ku> :t curry id
20:12:07 <lambdabot> forall a b. a -> b -> (a, b)
20:12:10 <ku> :t id
20:12:12 <lambdabot> forall a. a -> a
20:12:17 <ku> What is the additional b?
20:12:28 <latro`a> > curry id 1 2
20:12:29 <lambdabot>   (1,2)
20:12:39 <Cale> okay, let me write those using all different letters first, so the discussion is easier
20:12:52 <ku> > id 1 2
20:12:53 <lambdabot>   1
20:12:54 <Cale> curry :: ((a, b) -> c) -> a -> b -> c
20:12:57 <Cale> id :: d -> d
20:12:58 <ku> > id (1, 2)
20:12:58 <nand`> first it's “these are all just limits”, then it's “adjunctions arise everywhere” and now it's “everything is just a kan extension”? I don't know who to trust anymore!
20:12:59 <lambdabot>   (1,2)
20:13:10 <edwardk> =)
20:13:23 <Cale> If we want to apply curry id, that means d = (a,b) and d = c
20:13:27 <nand`> Kantegory Theory
20:13:33 <Cale> ku: right?
20:13:38 <ku> Cale, I think I understand
20:13:46 <Cale> because (d -> d) = ((a,b) -> c)
20:13:56 <Cale> So d has to be equal to (a,b) and equal to c
20:14:00 <edwardk> functors were invented to describe natural transformations, natural transformations to describe adjunction, adjunctions to describe representability and kan extensions. and then you have 1-category theory
20:14:01 <Cale> and then the result has type
20:14:03 <Cale> a -> b -> c
20:14:08 <ku> right
20:14:18 <ku> By the way, what is better? RWH or LYAH?
20:14:18 <Cale> and we know that c = d = (a,b)
20:14:25 <ku> I already read LYAH 1-10
20:14:27 <Cale> They're both all right
20:14:42 <ku> er, 1-8
20:14:44 <Cale> LYAH is better for getting started from what I've seen
20:14:57 <ku> Cale, well, I'm already "started"
20:14:59 <Cale> RWH has some more in-depth real world examples in it
20:15:10 <Cale> Neither is really the book that I'd write
20:15:13 <nand`> edwardk: that does make some sense
20:15:21 <Cale> But I've never quite gotten around to that :)
20:15:28 <nand`> edwardk: ah, I've reached an infinite loop when reading these blog posts
20:15:34 <edwardk> haha
20:15:52 <nand`> your free-monads-for-less-3 defers me to codensity, and the paper I'm now reading on codensity defers me to free-monads-for-less-3
20:15:54 <latro`a> ku--I find RWH is rather dense
20:16:01 <edwardk> think of it as bizarro world. they all have an internally consistent logic, just don't try to apply it to the outside world ;)
20:16:40 <sentientwaffle> if I pass an array of some record to a function, under what circumstances will that array be copied?
20:16:56 <ku> latro`a, alright, I think I'll read LYAH for now
20:17:23 <ku> How can I write \(x,y) -> (y,x) only with Prelude and no funcs/lambdas?
20:17:52 <nand`> @pl \(x,y) -> (y,x)
20:17:52 <lambdabot> uncurry (flip (,))
20:18:23 <aristid> edwardk: yet you actually apply that bizarro world to the outside world?
20:18:24 <nand`> ‘no funcs’ seems like a bit of a limiting constraint though
20:18:36 <ku> nand`, just an exercise I found on the wiki, thanks
20:18:40 <nand`> oh
20:18:43 <nand`> sorry I spoiled it
20:18:50 <edwardk> aristid: i've gotten pretty good at flipping back and forth between the two perspectives ;)
20:18:52 <ku> no problem
20:19:08 <ku> nand`, you would have been closer to spoiling it if I understood what it meant :P
20:19:18 <nand`> :t snd &&& fst
20:19:20 <lambdabot> forall a c. (a, c) -> (c, a)
20:19:25 <ku> 23:17 < lambdabot> uncurry (flip (,))
20:19:33 <nand`> what I would have come up with sans the ‘only Prelude’ requirement
20:19:39 <ku> what is (,)?
20:19:45 <nand`> (,) x y = (x, y)
20:20:04 <nand`> it's just the function that constructs a 2-tuple
20:20:09 <nand`> from two arguments
20:20:12 <ku> hmm, strange
20:20:28 <ku> oh, I think I get it, thanks
20:20:29 <latro`a> (x,y) is just sugar
20:20:32 <latro`a> so is (x,y,z) and so on
20:20:34 <ku> I don't know &&& yet though
20:20:36 <nand`> recall that ‘flip f x y = f y x’; so flip (,) x y = (y, x)
20:20:37 <latro`a> all of them have prefix constructors
20:20:38 <aristid> > 1 , 2
20:20:40 <lambdabot>   <no location info>: parse error on input `,'
20:20:52 <latro`a> for these purposes: f &&& g x = (f x,g x)
20:20:55 <aristid> (,) is a weird section for something that isn't an operator :P
20:21:02 <nand`> and ‘uncurry f (x,y) = f x y’; so ‘uncurry (flip (,) (x,y) = flip (,) x y = (y, x)’
20:21:09 <nand`> aristid: yeah :(
20:21:13 <ku> What would the prefix cons be for a 3-tuple?
20:21:16 <latro`a> (,,)
20:21:34 <ku> Is there such a thing as a variable-type list?
20:21:35 <latro`a> there are around...15 of these or so?
20:21:39 <aristid> nand`: you think it should be? :)
20:21:45 <edwardk> latro`a: an unbounded number
20:21:51 <latro`a> built in?
20:21:52 <edwardk> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:21:54 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
20:21:54 <lambdabot> t63 t64 t65 t66. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 ->
20:21:55 <lambdabot> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 ->
20:21:55 <lambdabot> t63 -> t64 -> t65 -> t66 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45,
20:21:55 <lambdabot> t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66)
20:21:55 <edwardk> yeah
20:21:57 <latro`a> huh
20:22:06 <latro`a> but they don't have instances of stuff
20:22:08 <latro`a> past ~15
20:22:11 <latro`a> right?
20:22:13 <aristid> edwardk: lambdabot-spammer!
20:22:20 <latro`a> also
20:22:23 <edwardk> thats because there isn't an unbounded amount of code written about them ;)
20:22:23 <latro`a> that t27 thing
20:22:23 <sentientwaffle> any tips on reasoning about memory usage in haskell? i.e., when is stuff copied?
20:22:26 <latro`a> still baffles me
20:22:27 <nand`> aristid: not really, but the built in tuple / list syntaxen are a bit.. unsettling. I guess I would be fine with an infix operator × for these, mind :)
20:22:31 <ku> Some stuff in Haskell actually seems unpure, like how tuples are implemented
20:22:41 <ku> * impure
20:22:46 <aristid> nand`: next you'll ask for a sigma
20:22:49 <latro`a> how are tuples impure
20:22:55 <nand`> by ‘unsettling’ I mean that they are built into core Haskell. It's awfully nice in practice, but the idea of having a type built-in is unsettling in the first place
20:22:56 <edwardk> ku: they are perfectly pure, they just have a special class of constructors
20:23:05 <ku> they're defined one-by-one for each size
20:23:09 <aristid> ku: you mean unclean?
20:23:11 <latro`a> that's necessary
20:23:17 <latro`a> welll
20:23:19 <latro`a> *well
20:23:19 <aristid> latro`a: is it?
20:23:19 <latro`a> ish
20:23:20 <nand`> especially an algebraic type that is not a primitive like Int#
20:23:40 <latro`a> heterogenous lists make it hard to be sure what you can and can't do with the elements
20:23:42 <edwardk> ku: the thing is they store n fields all together in a continuous region of memory, so they aren't like lists, etc.
20:23:51 <aristid> nand`: you can pretend pretty well that lists are not built-in tho
20:24:03 <latro`a> because the lists hold polymorphic values
20:24:08 <ku> edwardk, that reminds me of C arrays, although nothing is quite as bad as them
20:24:16 <edwardk> besides, you can access them consistently with _4 and such now ;)
20:24:22 <latro`a> tuples don't, they just hold different values which are generally monomorphic
20:24:31 <latro`a> also that's TH hackery, afaik :p
20:24:36 <aristid> if it wasn't for the bottom-handling and boxing sure, i'm sure a 2-tuple type would suffice instead of this infinite number of n-tuple types
20:24:59 <latro`a> well yeah you can recursively build 2-tuples
20:25:02 <latro`a> it would be terrible
20:25:04 <latro`a> but you could do it
20:25:05 <aristid> edwardk: but does _20 work?
20:25:10 <edwardk> aristid: i hate working with nested 2-tuples, that 'if it wasn't for' is a pretty big restriction
20:25:18 <aristid> @hackage lens
20:25:18 <latro`a> (a,(b,(c,(d,(e,f)))))
20:25:18 <lambdabot> http://hackage.haskell.org/package/lens
20:25:20 <edwardk> aristid: i've been thinking about adding a TH splice you can use ;)
20:25:21 <latro`a> or whatever
20:25:45 <edwardk> $(field 38)
20:25:47 <MostAwesomeDude> edwardk: I tried to use your makeLenses but it told me that it didn't know what "f" was.
20:25:47 <aristid> edwardk: w00t you added pseudo-UML graphs to the docs?
20:25:55 <MostAwesomeDude> edwardk: Is my GHC too old or something?
20:25:59 <edwardk> MostAwesomeDude: ack, can you give me the type you tried it on?
20:26:03 <edwardk> and what ghc?
20:26:28 <nand`> tuples give rise to the kind of ugly code that coworkers can pull it front of you to force you to hang your head in shame
20:26:36 <nand`> it makes claims of “haskell avoids code duplication” seem outlandish
20:26:39 <MostAwesomeDude> edwardk: Sure, one second.
20:26:48 <nand`> pull out*
20:26:48 <edwardk> MostAwesomeDude: also, if you try lens-family-th does it generate correct code?
20:27:03 <edwardk> the former two are more important though
20:27:11 <nand`> when you have instances like edwardk's generic _n
20:27:39 <edwardk> nand`: well, tuples are a different beast. i wrote those _n just to put all the duplication in one place
20:27:40 <latro`a> I didn't realize _n were actually generic until today
20:27:40 <aristid> .oO(maybe i should not write words like "w00t". not really appropriate for the #haskells)
20:27:51 <startling> is there a way I can make a data's show instance show all of its numerical members in hex without writing the whole thing by hand?
20:27:52 <edwardk> latro`a: they only went generic a few hours ago ;)
20:27:56 <latro`a> ...lol
20:28:06 <latro`a> then I guess I shouldn't feel bad
20:28:11 <edwardk> latro`a: its in 2.0, not yet on hackage
20:28:36 <ku> Is it abnormal to find myself wanting Python features in Haskell, and vice-versa?
20:28:44 <startling> ku: like what?
20:28:56 <startling> I want haskell features in python all the time though
20:29:09 <startling> like Maybe rather than None
20:29:16 <hpaste> MAD pasted “makeLenses failure” at http://hpaste.org/72948
20:29:25 <nand`> ku: vice versa is fine
20:29:27 <MostAwesomeDude> edwardk: ^^
20:29:27 <nand`> I do that too
20:29:29 <MostAwesomeDude> edwardk: Text/Lye/Types.hs:55:1: Not in scope: `f'
20:29:42 <edwardk> MostAwesomeDude: hrmm, let me try it
20:29:48 <ku> startling, some object features
20:29:49 <MostAwesomeDude> This is GHC 7.0.4 and lens-1.7.1
20:30:03 <startling> ku: oh. well, you'll get over that soon enough
20:30:06 <startling> :)
20:30:16 <ku> will I? I've been using python for years
20:30:21 <ku> I'm an OOP abuser
20:30:26 <edwardk> MostAwesomeDude: it works here
20:30:26 <nand`> I'd been using C# for years before I came to Haskell
20:30:29 <edwardk> can you try a newer lens?
20:30:45 <startling> ku: python was my first and only language for a few years too. :)
20:30:53 <edwardk> 1.9.1 is a pretty big step forward
20:30:53 <edwardk> and i made some TH improvements along the way
20:30:59 <startling> wellllll, my first real language
20:31:07 <startling> I wrote some cgi stuff in perl but I try not to remember
20:31:12 <nand`> my first real language was German, followed by English :)
20:31:24 <MostAwesomeDude> edwardk: Still happens with lens-1.9.1, same error.
20:31:28 <aristid> edwardk: the arrows in the diagram mean "specializes to"?
20:31:31 <edwardk> MostAwesomeDude: =(
20:31:31 <adnam> ku: you will get over it :)
20:31:36 <ku> startling, well, I've used quite a few, C, Ruby, JavaScript, etc., but Python remains my favorite (Haskell is gradually taking the spot though)
20:31:42 <edwardk> aristid: thats one way to read it, yes
20:31:47 <edwardk> 'isa'
20:32:12 <startling> ku: sounds like me last year
20:32:22 <adnam> ku: example of a feature you miss?
20:32:28 <edwardk> MostAwesomeDude: guessing its 7.0.4. if you don't mind i'd like to try a couple experiments with you to see if i can figure out if its just the way i bind the names that makes old TH unhappy
20:32:28 <ku> adnam, OOP
20:32:35 <aristid> edwardk: what's another good way to read it?
20:32:36 <latro`a> he means more specific
20:32:46 <edwardk> aristid: as 'is a'
20:32:51 <aristid> oh
20:32:52 <MostAwesomeDude> edwardk: Okay, sure.
20:32:52 <startling> oh ugh, Data.Binary.get for WordXs is big-endian???
20:32:58 <adnam> ku: oh, well :)
20:33:13 <MostAwesomeDude> I won't lie; it's nearly impossible to read through the TH stuff, so I don't know what is wrong.
20:33:17 <edwardk> MostAwesomeDude: going to hunt for how i generate them real quick
20:33:21 <MostAwesomeDude> 'k.
20:33:34 <aristid> edwardk: hmm the is-a probably makes more sense
20:33:50 <nand`> applicative: were you the author of http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/ ?
20:33:54 <edwardk> oh i think i have it
20:33:59 <edwardk> it looks like a bug =)
20:34:08 <MostAwesomeDude> Yay?
20:34:15 <edwardk> makeFieldLensBody uses mkName "f" rather than the 'f' in scope
20:34:29 <startling> can I reverse the endianity of some arbitrary Get Binary?
20:34:36 <startling> well, Binary b => Get b
20:34:44 <MostAwesomeDude> Aha.
20:34:46 <edwardk> that'll make me ship 2.0 earlier than i planned, give me a couple minutes
20:35:07 <shachaf> What's new in 2.0?
20:35:09 <MostAwesomeDude> No rush at all; I'm playin' Civ while pondering other puzzles, so I'm not exactly busy. :3
20:35:25 <edwardk> the fact that that worked on newer ghc gives me some pause ;)
20:35:36 <BMeph> nand`: isn't that ezyang?
20:35:39 <edwardk> guess it makes sense, it _is_ the f in scope
20:35:42 <shachaf> edwardk: Shouldn't a bugfix in 1.9 just be cause for 1.10?
20:36:06 <nand`> BMeph: perhaps. I don't have a very good BiMap of IRCNick <-> Name
20:36:07 <edwardk> shachaf: i've already locally added a bunch of stuff for 2.0 i was just going to bundle more in the release
20:36:29 <edwardk> and i kinda got sick of long second-major numbers after trifecta hit 0.53 ;)
20:37:02 <JoeyA> Is there a library or something that defines this?  data StateFunc a b = forall s. StateFunc s (a -> State s b)
20:37:40 <nand`> startling: maybe you could apply your reverse-endianness transformation on the ‘ByteString’ before you apply runGet to it; but that only works if it applies to the whole
20:37:48 <JoeyA> My particular application: translating application messages to and from a slightly lower-level representation.
20:38:17 <edwardk> JoeyA: the existential adds no real information that you can't capture in the current closure there
20:38:24 <startling> nand`: yeah, but this is for a Binary instance (that's necessarily little-endian)
20:38:57 <startling> stupid network byte order
20:39:14 <JoeyA> edwardk: Are you sure?  The idea is, my send loop marshals state for the translation function.
20:39:19 <startling> everyone should just use little-endian like god intended
20:39:32 <nand`> startling: there are both little-endian and big-endian versions of the integer primitives if that helps
20:39:44 <JoeyA> .htrae eht dna snevaeh eht detaerc doG ,gninnigeb eht nI
20:40:03 <edwardk> JoeyA: compare your definition with a mealy machine: newtype Mealy a b = Mealy { runMealy :: a -> (b, Mealy a b) }
20:40:05 <shachaf> edwardk: What's wrong with .53?
20:40:13 <shachaf> I mean, as long as it's an obvious sequence.
20:40:21 <nand`> lexicographic ordering sorts it before 0.6
20:40:32 <startling> nand`: you mean WordX and IntX? where are they?
20:40:53 <edwardk> JoeyA: the Mealy a b value represents the current state. it can be anything it wants to be
20:41:05 <nand`> startling: getWord16le, getWord16be, same for 32/64; in Data.Binary.Get
20:41:19 <edwardk> if you want to record the current state, just pass around the whole machine, its purely functional
20:41:20 <nand`> I'm suddenly unsure about IntX
20:41:31 <startling> nand`: oh yeah, thought you meant for the data types themselves
20:41:37 <nand`> oh
20:41:42 <nand`> sorry, no, that is not what I meant
20:41:46 <nand`> I meant the parser primitives
20:41:52 <edwardk> JoeyA: you can make machines that count, that represent edge transitions in finite and infinite automata, etc.
20:41:52 <startling> nand`: yeah, the problem is that this is an instance Binary x => Binary (Mything x)
20:41:59 <JoeyA> edwardk: Ah, okay.
20:42:10 <edwardk> JoeyA: the 's' _is_ the environment, no need to reify it explicitly
20:42:12 <startling> nand`: so there's no unified way to get little-endian
20:42:32 <nand`> startling: I don't think ‘little-endian’ would make sense for Binary instances that are not integers in the first place
20:43:01 <JoeyA> I suppose I could, if I wanted to, write a function that translates (s, a -> State s b) into a Mealy machine.
20:43:05 <nand`> you could work around it by adding a typeclass LittleEndian x which has a ‘leGet’ primitive; then defining instances on that for all of the integer Gets
20:43:10 * JoeyA does it as an exercise.
20:43:13 <edwardk> yep
20:43:27 <startling> nand`: yeah. :/
20:43:27 <nand`> that way your data structure won't be usable with non-numbers either; at least not in ways that would break with your intended just-reverse-bytes implementation
20:43:36 <nand`> won't be parseable*
20:43:40 <edwardk> mealy and moore machines are pretty powerful toys ;)
20:43:56 <startling> this sucks. I'm surprised this isn't a solved problem
20:44:23 * hackagebot lens 2.0 - Lenses, Folds and Traversals (EdwardKmett)
20:44:27 <nand`> it may be and I may have no clue what I'm talking about
20:45:03 <startling> nand`: heh. Copious googling doesn't seem to get me anywhere at least
20:45:21 <JoeyA> Is there a library providing Mealy machines and the Monad and Arrow instances they probably have?
20:45:34 <edwardk> what happens when you need to run your code on a PDP-11 in middle endian order?
20:45:56 <JoeyA> And probably Comonad, which I don't quite grasp.
20:45:58 <nand`> Mealy machines? is that like an automaton arrow?
20:46:05 <nand`> (sorry, wasn't paying attention)
20:46:11 <edwardk> JoeyA: i never bundled them
20:46:13 <JoeyA> newtype
20:46:16 <JoeyA> whoops
20:46:20 <edwardk> JoeyA: we use them a lot here at capital iq though
20:46:38 <startling> edwardk: dunno why they would be parsing x86 mach-o headers!
20:46:51 <aristid> edwardk: travis-ci is failing, but it's not because of a real problem in 2.0? http://travis-ci.org/#!/ekmett/lens
20:46:56 <JoeyA> nand`: newtype Mealy a b = Mealy { runMealy :: a -> (b, Mealy a b) }
20:47:17 <aristid> oh yeah something with wiki is probably not that crucial
20:47:19 <edwardk> aristid: ah one sec.
20:47:19 <JoeyA> I suppose if you made a monad out of that, you'd get some sort of left recursion problem.
20:47:26 <startling> JoeyA: you can probably get a decent amount with GeneralizedNewtypeDeriving
20:47:35 <NemesisD> is it possible to derive an instance for a type separate from where that type is defined? i'm using a library that neglected to create a trivial Eq instance for something
20:47:50 <nand`> JoeyA: Automaton (->) ?
20:47:56 <aristid> NemesisD: yes, with StandaloneDeriving or so
20:47:56 <nand`> from Control.Arrow.Transformer.Automaton
20:48:20 <aristid> NemesisD: but consider contacting the library author.
20:48:30 <nand`> compare newtype Automaton a b c = Automaton (a b (c, Automaton a b c))
20:48:42 <edwardk> aristid: yeah i'd edited the wiki to add the 2.0 hierarchy image locally but not pushed
20:48:49 <edwardk> aristid: so the git submodule complained
20:48:50 <nand`> no monad on it, but it is an applicative
20:49:00 <nand`> (for Arrow a)
20:49:07 <aristid> edwardk: git submodules are a bit of a PITA
20:49:13 <edwardk> aristid: noticing ;)
20:49:33 <startling> bleh, I could just un-generalize this and have tons of boilerplate
20:49:45 <NemesisD> aristid: yep. submitting a pull request for it now
20:50:01 <edwardk> i did find it nice that i can mount my repository as a submodule of my repository to get gh-pages in a place i can manipulate them
20:50:10 <aristid> NemesisD: you can also use this extension for GADTs btw
20:50:15 <edwardk> basically i mount the gh-pages branch of my repo in the docs directory of my repo
20:50:29 <aristid> NemesisD: so if you ever wondered how to automatically generate the Show instance for GADTs now you know
20:50:35 <edwardk> for a while i had it as dist/doc/html but then a cabal clean broke the repository
20:50:41 <latro`a> NemesisD, StandaloneDeriving makes an orphan instance; you should look that up to understand what it means
20:50:47 <edwardk> whew. 2.0 buildbots clean
20:50:47 <latro`a> before jumping to use it
20:51:03 <latro`a> s/what it means/what that means
20:51:25 <startling> what's good for parsing binary data?
20:51:34 <edwardk> JoeyA: also useful is Moore
20:51:37 <startling> if I were to not use Data.Binary
20:51:53 <edwardk> data Moore a b = Moore b (a -> Moore a b)
20:52:32 <startling> oh also: are hex literals read little or big endian, or is it host-dependent?
20:52:46 <edwardk> JoeyA: comonad.com/haskell/Origami.hs and comonad.com/haskell/Mealy.hs might be useful to you. i wrote them off the cuff for copumpkin a few years back
20:52:57 <latro`a> ...that type declaration
20:52:59 <latro`a> I don't even
20:53:03 <NemesisD> aristid: in my haskell education so far I haven't even touched or read about GADTs yet
20:53:12 <latro`a> that seems like you'd recurse with it, but...how
20:53:22 <latro`a> you get a new b, with which you do...what? to get an a
20:53:31 <edwardk> latro`a: Moore?
20:53:34 <latro`a> yeah
20:53:43 <nand`> latro`a: think of automatons that can be observed repeatedly
20:53:43 <edwardk> latro`a: the b is the 'current state', when you feed it an 'a' you go to a new state
20:53:48 <nand`> and may have changing state in between observations
20:53:50 <latro`a> where do you get an a
20:53:50 <edwardk> the b is like the value of the current state
20:53:57 <latro`a> outside?
20:53:58 <roconnor_> edwardk: data Moore a b = Moore b (a -> Moore b a)  ?
20:53:59 <nand`> yes
20:54:05 <edwardk> consider a finite automaton, b could be 'accept?'
20:54:09 <edwardk> roconnor_: yeah
20:54:12 <latro`a> oh wait
20:54:14 <latro`a> that's very different
20:54:18 <aristid> NemesisD: nevermind then
20:54:25 <latro`a> that was what was throwing me off
20:54:35 <edwardk> latro`a: the Mealy machine on the otherhand doesn't give values to states, it gives values to transitions
20:54:58 <dfeuer> Cale: I'm an idiot. It's perfectly obvious that k-way merge is best done by divide-and-conquer, at least in Haskell, but I had the broken idea in my head that it would be slow.
20:55:23 <edwardk> latro`a: when i have a moore machine and don't feed it anything i already have a value. when i have a mealy machine i have to feed it something to know my value.
20:55:29 <roconnor_> edwardk: oh maybe I'm wrong
20:55:34 <edwardk> they are sort of yin and yang
20:55:43 <edwardk> roconnor_: ?
20:55:48 <latro`a> I take it by that you mean they are literally dual
20:55:51 <latro`a> because it sounds like they are
20:55:54 <roconnor_> edwardk: I though a and b get swapped
20:55:58 <latro`a> eh, s/literally/categorically
20:56:02 <edwardk> Moore a b = Moore b (a -> Moore b a) -- you want the b covariant
20:56:20 <edwardk> otherwise you can't fmap them =)
20:56:47 <edwardk> latro`a: they aren't technically dual, but do each arise from the chained composiiton of the same adjunction flipped
20:57:07 <latro`a> close enough
20:57:25 <roconnor_> Moore a b = (b, a -> (b, a -> ( b, a  ... or  Moore a b = (b, a -> (a, b -> (b, a -> ....
20:57:29 <edwardk> latro`a: you can 'drive' a moore machine with a mealy machine and vice versa
20:57:30 <edwardk> the moore machine gives you some b you can feed the mealy machine to get an answer you can feed back to the moore machine
20:57:40 <edwardk> the moore machine is the mealy machine 'shifted' by one half
20:57:55 <latro`a> should probably spend some time studying automata before trying to get this :p
20:58:17 <Cale> dfeuer: interesting -- so you have a fast way to do it now? :)
20:58:33 <edwardk> you can make the duality clearer by using data Moore a b = Moore b (Mealy a b);  newtype Mealy a b = Mealy (a -> Moore a b)
20:58:41 <edwardk> er s/duality/relation/
20:59:00 <latro`a> ....speaking of divide and conquer, I wonder how hard the divide-and-conquer eigenvalue algorithm would be to make in haskell
20:59:19 <dfeuer> Cale: Yeah. Without a priority queue.
20:59:34 * latro`a detects a use for ixmap
20:59:38 <Cale> oh, nice
20:59:44 <edwardk> i found the connection of those types to mealy and moore machines by accident back in like 2007 or so and it greatly amused me. i'm sure folks have seen it before me though
20:59:52 <latro`a> ixmap can get you subarrays
21:00:04 <dfeuer> I'd still like to know how to implement a fast single-threaded priority queue in Haskell, but it's not the way for k-way.
21:00:20 <edwardk> latro`a: just think of it like a stream transducer that must produce a value for every one it sees
21:00:57 <hpaste> “Joey Adams” pasted “Convert State action and initial state to a Mealy automaton” at http://hpaste.org/72949
21:01:01 <startling> is there some language extension that'll give me n-sized arrays?
21:01:05 <startling> *as a type
21:01:07 <edwardk> dfeuer: if you don't want single threaded my heaps package gives you asymptotically optimal priority queues
21:01:31 <edwardk> dfeuer: (they are asymptotically optimal even for single threaded use but they support persistence)
21:01:58 <latro`a> ixmap ((1,1),(m-1,n-1)) (\(i,j) -> (i+1,j+1))
21:02:00 <edwardk> they are based on brodal-okasaki skew binomial priority queues
21:02:02 <latro`a> ^that is elegant
21:02:03 <danil> startling: hmatrix-static supplies those, but they're rather painful to use
21:02:47 <dfeuer> edwardk: asymptotically optimal is just not fast enough, and the pqueue is used in a single-threaded fashion for this algorithm. However, it appears that to make it fast requires a lot more optimization skill than I have.
21:03:03 <latro`a> hmm, not as nice to define arbitrary minors, though
21:03:07 <edwardk> dfeuer: fair nuff. have fun bit banging ;)
21:03:21 <dfeuer> edwardk: even Brodal and Okasaki say their queues are way too slow in practice. They are rather pretty, though.
21:04:12 <edwardk> i mostly wanted to bundle them up because at the time nobody had a version for haskell that felt 'haskelly'
21:04:28 <edwardk> jim apple had a coq extracted version but it didn't have all the improvements in the end of the paper
21:04:34 <edwardk> and the api felt strange
21:05:07 <startling> danil: darn
21:06:04 <edwardk> MostAwesomeDude: does 2.0 solve your problem?
21:06:22 <dfeuer> edwardk: Hackage now has a carefully optimized binomial heap package that uses nested types to enable unpacking in the trees.
21:06:27 <dfeuer> Very cool.
21:06:43 <edwardk> nice
21:06:54 <nand`> edwardk gives Google a run for their money when it comes to increasing version numbers :)
21:06:59 <dfeuer> edwardk: of course, B-O could be built on top of that....
21:07:11 <edwardk> which package?
21:07:17 <aristid> nand`: that's the real reason why google don't show version numbers
21:07:21 <dfeuer> It's just called pqueue.
21:07:32 <dfeuer> There's a whole big discussion of it on some mailing list.
21:07:38 <edwardk> oh that one
21:08:05 <dfeuer> But it allocates way too much for my purpose.
21:08:22 <dfeuer> I implemented binary heaps in an STArray, which brought allocation down a bunch, but not enough.
21:08:39 <JoeyA> edwardk: Thanks for the help.
21:08:47 <dfeuer> So then I just switched to an algorithm that doesn't use a priority queue at all, which is faster.
21:09:22 <dfeuer> Well, faster on my system, not on this stupid broken SPOJ thing.
21:09:55 <edwardk> what is the algorithm for?
21:12:07 <edwardk> re the pqueue stuff i don't recall it benchmarking all that well, so i find it odd that you refer to it as some awesomely optimized thing
21:12:27 <MostAwesomeDude> edwardk: Lemme install and test.
21:12:44 <edwardk> hence my lackluster 'oh that one' response
21:12:53 <edwardk> running through the code, it hasn't really changed
21:14:10 <edwardk> i thought for a minute you meant it did things like the adaptive-containers/unboxed-containers libs did
21:14:58 <JunkBee> How does Haskell handle the scenario where a function uses a variable but doesn't specify it? e.g. f = foldl addDigit 0 where addDigit num d = 10*num + d
21:15:07 <JunkBee> and f is called like ` f [1,2,3]`
21:15:14 <edwardk> one of the problems with the big nested data type is that it allocates a lot of useless intermediate nodes, top-down polymorphically recursive data types are hard to optimize
21:15:20 <edwardk> you need to use the bottom up tricks
21:15:48 <roconnor_> @type foldl ?addDigit 0
21:15:49 <lambdabot> forall a b. (?addDigit::a -> b -> a, Num a) => [b] -> a
21:16:05 <roconnor_> JunkBee: f ends up with type [b] -> a
21:16:12 <johnw> JunkBee: f becomes a function that expects another argument
21:16:24 <johnw> you can then pass that argument later by calling f with one
21:16:39 <JunkBee> oh
21:16:48 <edwardk> :t (+)
21:16:50 <lambdabot> forall a. (Num a) => a -> a -> a
21:16:52 <edwardk> :t (+) 1
21:16:54 <lambdabot> forall t. (Num t) => t -> t
21:16:56 <johnw> for example, f = (+1), f becomes a function that expects an argument for the left side of +.  You can later call f 10 => 11
21:16:57 <MostAwesomeDude> edwardk: Rockin', that did it.
21:16:58 <edwardk> :t (+) 1 2
21:17:00 <lambdabot> forall t. (Num t) => t
21:17:06 <edwardk> MostAwesomeDude: good catch =)
21:17:21 <roconnor_> JunkBee: since f = foldl addDigit 0   then `f [1,2,3]` is equivalent to `foldl addDigit 0 [1,2,3]`
21:17:29 <johnw> JunkBee: it's called partial application, or "currying"
21:17:37 <roconnor_> JunkBee: you can always replace defined constants with what they are defined to be
21:17:44 <johnw> and it's as awesome as pea soup in winter
21:18:11 <edwardk> in haskell every function is actually 'a function of one argument' it just returns a function of the remaining arguments.
21:18:25 <latro`a> (if there are any)
21:18:41 <edwardk> :t foldr
21:18:42 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:18:55 <avpx> I like this example:
21:18:56 <avpx> :t map
21:18:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:18:59 <edwardk> so foldr is a function that takes a function and gives you a function from b to a function from [a] to a b
21:19:03 <johnw> JunkBee: I highly recommend reading this: http://learnyouahaskell.com/higher-order-functions#curried-functions
21:19:03 <edwardk> thats a lot of functions ;)
21:19:29 <avpx> A nice way to see map is (a - > b) -> ([a] -> [b]). That is, it takes a function on values to a function on lists of those values.
21:19:50 <JunkBee> Oh geez. I am reading a haskell book; however, I start to write a little code when I need a break from studying.
21:20:39 <aristid> JunkBee: write haskell code while reading the haskell book, ghci is your friend
21:21:11 <JunkBee> I just learned foldl :)
21:21:21 <JunkBee> Oh, from the book of course.
21:22:35 <JoeyA> > foldl (\a x -> x) (error "last: empty list") [undefined, undefined, undefined, 3]
21:22:36 <lambdabot>   3
21:22:41 <JoeyA> @src last
21:22:42 <lambdabot> last [x]    = x
21:22:42 <lambdabot> last (_:xs) = last xs
21:22:42 <lambdabot> last []     = undefined
21:23:07 <JoeyA> Hey, now I know a "practical" use case for non-strict foldl.
21:23:07 <ReinH> edwardk: quit your derping
21:23:13 <edwardk> ?
21:23:17 <ReinH> https://github.com/ekmett/lens/commit/eba5f14731cbe837f4e43af76f0833ae9a6d8765
21:23:18 <JoeyA> > foldl' (\a x -> x) (error "last: empty list") [undefined, undefined, undefined, 3]
21:23:19 <edwardk> oh the patch names?
21:23:19 <lambdabot>   *Exception: Prelude.undefined
21:23:26 <edwardk> heh
21:23:28 <ReinH> :p
21:23:36 <edwardk> i had two derps in a row
21:23:39 <ReinH> I saw
21:23:40 <ReinH> lmao
21:23:50 <edwardk> it was a pretty bad derp too
21:24:02 <ReinH> when I was employee 1 of a startup the code I inherited from the founder had commits like "fix" "type" "fix again"
21:24:05 <edwardk> i saw it and was about ready to rip out all the new polymorphic _4 stuff
21:24:06 <ReinH> it was a wreck
21:24:06 <johnw> howdy ReinH
21:24:13 <ReinH> johnw: hai!
21:24:21 <ReinH> *typo
21:24:26 <edwardk> when i have more people actively committing the quality of my commit messages improves dramatically
21:24:27 <johnw> I've seen your nick often enough now to feel like I should know you :)
21:24:32 <ReinH> edwardk: ;)
21:24:36 <ReinH> johnw: :)
21:24:52 <edwardk> when its just me it is mostly a cue of what i was thinking at the time for short horizon recall
21:25:00 <ReinH> edwardk: I know. It was just funny.
21:25:08 <JoeyA> What are some neat things you can do with arrow composition of Mealy machines (besides define a bunch of instances I don't understand) ?
21:25:41 <edwardk> JoeyA: paul chiusano has a whole framework for those things, he's pchiusano here on irc from time to time
21:26:54 <edwardk> he gave a boston haskell talk on them at one point, and has spoken at scala conferences about them
21:27:36 <JoeyA> Thanks
21:27:50 <JoeyA> In my application, I'm sending data to a server, and delta-compressing entries.  E.g. instead of sending [a,b,c,d], send [a, b-a, c-b, d-c].
21:28:35 <JoeyA> I'm fantasizing here, but I suppose I can define a Mealy machine to delta-compress individual entries.
21:28:37 <edwardk> they make a pretty nice stream transduction model when you don't need to allow for rates to differ
21:28:50 <edwardk> yeah that works fine
21:28:51 <JoeyA> Then transform it to multiplex the delta compression to multiple channels.
21:29:47 <edwardk> in fact the delta-compression thing is one of the common examples we use
21:29:48 <edwardk> =)
21:29:56 <JoeyA> E.g. the state underlying the single-stream automaton is Maybe ByteString
21:30:11 <JoeyA> And for the multi-stream automaton, Map ChannelId ByteString.
21:30:20 <latro`a> we = ?
21:30:28 <edwardk> s&p capital iq
21:30:33 <latro`a> ah
21:30:39 <edwardk> we have a bunch of functional guys up here in boston
21:30:55 <edwardk> so by we i mostly mean that team
21:34:17 <ReinH> edwardk: I just saw that your wiki has things in it
21:34:21 <ReinH> awesomesauce!
21:34:23 <edwardk> heh
21:34:26 <JoeyA> So here's another exercise for myself: write multiplex :: Mealy a b -> Mealy (Int, a) (Int, b).  That looks an awful lot like 'second', so I'm not sure I got the type right.
21:34:36 <ReinH> as of 2 days ago apparently :D
21:34:41 <edwardk> i'm planning on adding a writeup motivating the isomorphism hack and the way i do indexed types
21:35:19 <edwardk> i also want a much much longer tutorial
21:35:29 <edwardk> the tutorial started as the first page of the derivation doc
21:35:38 <edwardk> and it doesn't do a good job
21:35:43 <ReinH> edwardk: your (.) for lenses
21:35:48 <ReinH> (.) :: Simple Lens a b -> Simple Lens b c -> Simple Lens a c
21:35:51 <ReinH> isn't that backwards?
21:35:54 <edwardk> nope =)
21:35:54 <ReinH> :t (.)
21:35:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:35:59 <edwardk> lenses compose the opposite way around
21:36:08 <ReinH> also wtf lambdabot?
21:36:20 <JoeyA> The idea is, given an automaton for transforming a stream, turn it into an automaton for maintaining state on multiple channels keyed by Int.
21:36:26 <Enigmagic> :t (Prelude..)
21:36:28 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:36:40 <ReinH> what . was I getting?
21:36:47 <edwardk> thats http://comonad.com/reader/2006/generalizing-dot/
21:36:47 <roconnor_> I suppose we could swap the order of the parameters to Lens if it makes people feel better about composition :D
21:36:59 <Enigmagic> ReinH: it's generally referred to as Caleskill
21:37:04 <Enigmagic> err
21:37:04 <edwardk> ReinH: back in 2006 cale and i both noticed we can generalize (.)
21:37:07 <Enigmagic> Caleskell
21:37:23 <edwardk> lambdabot doesn't use haskell proper, its got a number of generalizations baked in
21:38:48 <edwardk> ReinH: that was just a few months after i joined the haskell community it seems
21:40:06 <Enigmagic> back when we were all just wee lads
21:40:14 <ReinH> this is me right now http://i.imgur.com/D3lON.gif
21:41:59 <ReinH> ok back to reading the tutorial ;)
21:43:06 <mm_freak_> btw, i find the kind of generalization of (.) in lambdabot pretty dumb
21:43:13 <mm_freak_> Control.Category is a much more sensible generalization
21:43:15 <monochrom> hehe
21:43:40 <mm_freak_> and i wish that some day that one will be in the Prelude
21:44:42 <Enigmagic> yeah, and then we can have a different Prelude called the n00bPrelude with specialized versions of (.) and map
21:44:44 <ReinH> -- definitely a bad idea, sorry Cale!
21:44:45 <ReinH> http://www.haskell.org/haskellwiki/The_Other_Prelude
21:44:47 <ReinH> lulz
21:45:32 <monochrom> there are now several "better prelude" packages on hackage
21:45:44 <mm_freak_> JoeyA: Mealy is generally called Auto or Automaton…  and if you understand Auto, you understand AFRP =)
21:45:58 <ReinH> oh look Monad is now a Functor ;)
21:46:05 <edwardk> yeah cale and i split over the (.) as fmap vs (.) as categorical composition thing. he likes (.) for fmap because you use it more. i want the actual intuition of composition to hold
21:46:26 <startling> I asked this before but I don't think I got an answer: what should I use for parsing binary?
21:46:42 <roconnor_> startling: cereal
21:46:42 <mm_freak_> edwardk: yeah, in particular the category laws
21:46:47 <monochrom> consider the package called "binary"
21:47:00 <edwardk> startling: http://hackage.haskell.org/packages/archive/binary/0.5.1.1/doc/html/Data-Binary-Get.html
21:47:04 <Enigmagic> startling: binary (for simple decoding) or cereal (for parsing)
21:47:07 <edwardk> startling: its not a bad place to start
21:47:10 <JoeyA> mm_freak_: Arrowized functional reactive programming?
21:47:13 <startling> edwardk, I started there already!
21:47:24 <startling> edwardk: my data isn't context-free though
21:47:34 <mm_freak_> startling, roconnor_, monochrom: cereal/binary aren't exactly for /parsing/ binary, but rather for deserializing it…  i'd prefer attoparsec for binary parsing
21:47:39 <edwardk> get is a monad, so it doesn't have to be
21:47:44 <edwardk> read something, and choose what to do from there
21:47:55 <monochrom> oh, I forgot attoparsec. yes that's a good candidate too
21:47:56 <Enigmagic> mm_freak_: it has an Alternative instance..
21:47:58 <mm_freak_> JoeyA: yeah, although i prefer to think of the "A" as Applicative…  notice how your Mealy forms an applicative functor
21:48:00 <startling> well, I coudn't get it to read  little-endian either
21:48:15 <mm_freak_> Enigmagic: "it"?
21:48:20 <startling> Data.Binary
21:48:21 <edwardk> http://hackage.haskell.org/packages/archive/binary/0.5.1.1/doc/html/Data-Binary-Get.html#v:getWord32le
21:48:26 <edwardk> startling: done ;)
21:48:26 <Enigmagic> mm_freak_: cerela's Get type
21:48:48 <edwardk> you can choose big endian, little endian or host order
21:48:58 <startling> edwardk, sigh
21:49:02 <mm_freak_> Enigmagic: yeah, cereal is more expressive, but still it's not really a library designed for parsing
21:49:03 <edwardk> startling: ?
21:50:16 <Enigmagic> mm_freak_: what is it designed for then? basically everything that binary supports plus Alternative and resumable parsing?
21:50:34 <startling> edwardk: I went through this all a couple hours ago (before you were here?). I need to parse little-endian integer.
21:50:36 <Enigmagic> just slower than attoparsec for complicated parses?
21:50:37 <startling> s
21:50:50 <edwardk> startling: parse it as a word32, then fromIntegral it
21:50:51 <startling> attoparsec looks promising though, thanks!
21:51:01 <edwardk> fromIntegral <$> getWord32le
21:51:21 <edwardk> that'll give you a 32 bit integer, etc.
21:51:36 <monochrom> wait, "little-endian integer" how many bits?
21:51:54 <edwardk> > fromIntegral (-2 :: Word32)  :: Int32
21:51:56 <lambdabot>   -2
21:52:08 <mm_freak_> Enigmagic: let me state it this way:  attoparsec has more feature-rich and you get rid of all the other stuff that cereal is about
21:52:16 <mm_freak_> in other words:  attoparsec is a more focussed library
21:52:44 <Enigmagic> mm_freak_: like what?
21:53:16 <edwardk> startling: that take care of your problem?
21:53:20 <mm_freak_> Enigmagic: please compare yourself…  i'm not going to enumerate the differences =)
21:53:48 <startling> edwardk: my other problem was that parsing could either get me a MyThing Int32 or a MyThing Int64, but I guess I can just not make it a Binary and do it outside of that
21:53:51 <Enigmagic> mm_freak_: 'more focused' isn't really saying anything useful. i find that all of the haskell parsers are too slow for dealing with large volumes of data so i write most of mine in C.
21:54:05 <mm_freak_> let me put it this way:  i would use attoparsec, unless it's actually serialization i'm doing
21:54:28 <edwardk> you need to do something to distinguish between the 2, parsing elf or something?
21:54:43 <mm_freak_> Enigmagic: attoparsec gets close to C speed according to an old benchmark, and i'm sure that it improved further over the years
21:55:23 <monochrom> it is now superluminal :)
21:55:31 <mm_freak_> also writing parsers in C is very dangerous
21:55:46 <ReinH> edwardk: reading the derivations wiki page
21:55:53 <Enigmagic> mm_freak_: *shrug* i write them in a high level language that compiles to C. it's significantly faster than Haskell for my application.
21:56:00 <ReinH> mind still blown
21:56:06 <edwardk> ReinH: =)
21:56:07 <Enigmagic> i've benchmarked attoparsec, binary and cereal for my data.
21:56:18 <startling> Enigmagic: what language?
21:56:23 <ReinH> edwardk: you're good at this haskell thing ;)
21:56:24 <Enigmagic> startling: ragel
21:56:29 <startling> Enigmagic: ah
21:56:35 <edwardk> been at it for a while now
21:56:36 <ReinH> ragel is pretty great
21:57:02 <edwardk> Enigmagic: what won?
21:57:11 <startling> edwardk: yes, I'm distinguising between 32-bit and 64-bit Mach-O by a magic number
21:57:13 <mm_freak_> Enigmagic: i highly doubt it…  attoparsec wants to be used properly
21:57:17 <Enigmagic> edwardk: ragel
21:57:50 <mm_freak_> there is a potential for unnecessary memory/CPU bloat in attoparsec, if you don't combine your parsers properly
21:57:56 <edwardk> startling: check the magic number, then call one parser for it in 64 bit or the other parser for it in 32, if you set up a typeclass right they can be the same parser with different types chosen
21:58:04 <Enigmagic> mm_freak_: i'm parsing terabytes a day :P
21:58:04 <mm_freak_> this also leads to unnecessary GCs
21:58:16 <edwardk> mm_freak_: even if you do. it does unbounded backtracking
21:58:50 <edwardk> bos found the problem, fixed it, didn't like the speed and reverted ;)
21:58:54 <startling> Enigmagic: what do you do, if you don't mind answering?
21:58:56 <mm_freak_> edwardk: exactly that is the problem i'm referring to…  in that regard parsec actually has an advantage
21:59:01 <edwardk> yeah
21:59:15 <Enigmagic> startling: build automated trading software in haskell
21:59:22 <startling> Enigmagic: neat
21:59:26 <edwardk> i need to ship the streaming version of the trifecta parser as well, (though i still have the diagnostics that assume the data is human readable)
21:59:57 <startling> Enigmagic: you get tbs of incoming data a day? or is this historical data?
22:00:01 <zzing_> If I have a function 'checkError' that will return a list indicating errors or an empty list on no error, what would be the best way to handle it to clean anything up that is needed and leave the function? (It is in IO)
22:00:03 <mm_freak_> Enigmagic: if you were to parse 16 TiB a day that's 194 MiB per second…  attoparsec can do that
22:00:42 <zzing_> The specific example is on line 51 of http://hpaste.org/72950
22:00:48 <Enigmagic> mm_freak_: not for what i'm parsing, thanks. i've benchmarked it and the fastest is can get is about 30% the speed of the ragel parser.
22:00:50 <edwardk> mm_freak_: assuming he isn't getting it in bursts, etc.
22:00:54 <NemesisD> i'm having a really hard time using the Maybe Monad instance inside of an IO Monad, i'm trying to do something like: close <$> maybeHandle
22:01:17 <edwardk> :t mapM
22:01:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
22:01:24 <edwardk> NemesisD: look at that ;)
22:01:33 <edwardk> er
22:01:37 <edwardk> :t Data.Traversable.mapM
22:01:39 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
22:01:44 <edwardk> where t = Maybe
22:01:52 <edwardk> :t Data.Foldable.mapM_
22:01:54 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
22:01:59 <sayuke> Would someone be able to explain this signature in english. (XMLGen m, ~ * (XMLType m) x) => EmbedAsChild m x
22:02:01 <edwardk> the latter is probably better
22:02:16 <edwardk> the ~ * is a mess caused by ghc 7.4 and haddock
22:02:17 <mm_freak_> NemesisD: or a small utility function:  maybe (return ()) close
22:02:24 <edwardk> read the ~ as XMLType m ~ x
22:02:27 <mm_freak_> if that's what you want to do
22:02:28 <Enigmagic> startling: historical mostly. it's about 12GB of raw tick data per day, plus other stuff
22:02:33 <mm_freak_> :t maybe (return ()) close
22:02:34 <lambdabot> Not in scope: `close'
22:02:36 <mm_freak_> uhm
22:02:39 <edwardk> thats saying that the XMLType m is equal to the type x
22:02:39 <mm_freak_> :t maybe (return ()) hClose
22:02:40 <lambdabot> Not in scope: `hClose'
22:02:46 <mm_freak_> :t maybe (return ()) System.IO.hClose
22:02:47 <lambdabot> Maybe GHC.IO.Handle.Types.Handle -> IO ()
22:03:12 <edwardk> or XMLGen m => EmbedAsChild m (XMLType m)
22:03:31 <startling> Enigmagic: so you'll run out eventually. :)
22:03:36 <sayuke> edwardk: i just looked at the source, makes a bit more sence now. Thanks
22:03:52 <Enigmagic> startling: run out of data?
22:04:03 <startling> yeah
22:04:20 <Enigmagic> startling: i wish, doing optimization runs means iterating over large amounts of data a lot of times
22:04:33 <NemesisD> hmm, the foldable instance is good to know, though totally nonobvious to me
22:04:55 <startling> Enigmagic: heh
22:04:58 <edwardk> NemesisD: you get better at it with time
22:05:25 <edwardk> NemesisD: the other way to do it is to make a big production out of using case on the Maybe
22:05:28 <NemesisD> edwardk: yeah that seems to be the way, which is why i'm going to use it here. i've definitely hit this case before
22:05:40 <edwardk> case m of Just h -> close h; Nothing -> return ()
22:06:11 <edwardk> or more idiomatically perhaps "maybe (return ()) close mh"
22:07:15 <zzing_> :t fail
22:07:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
22:09:09 <zzing_> :t <$>
22:09:11 <lambdabot> parse error on input `<$>'
22:09:17 <zzing_> :t (<$>)
22:09:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:09:38 <zzing_> :t (<*>)
22:09:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:11:46 <zzing_> @hoogle forall (m :: * -> *) a. (Monad m) => (a -> m b) -> (m a) -> m c
22:11:47 <lambdabot> Parse error:
22:11:47 <lambdabot>   forall (m :: * -> *) a. (Monad m) => (a -> m b) -> (m a) -> m c
22:11:48 <lambdabot>          ^
22:11:58 <zzing_> @hoogle (m :: * -> *) a. (Monad m) => (a -> m b) -> (m a) -> m c
22:11:58 <lambdabot> Parse error:
22:11:59 <lambdabot>   (m :: * -> *) a. (Monad m) => (a -> m b) -> (m a) -> m c
22:11:59 <lambdabot>      ^
22:12:07 <zzing_> @hoogle (Monad m) => (a -> m b) -> (m a) -> m c
22:12:09 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
22:12:09 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
22:12:09 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
22:12:29 <zzing_> @hoogle IO String
22:12:30 <lambdabot> Did you mean: :: IO String
22:12:30 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
22:12:30 <lambdabot> System.IO.Error ioeSetErrorString :: IOError -> String -> IOError
22:12:49 <zzing_> @hoogle a -> IO String
22:12:50 <lambdabot> System.IO hGetContents :: Handle -> IO String
22:12:50 <lambdabot> GHC.IO.Handle hGetContents :: Handle -> IO String
22:12:50 <lambdabot> System.IO hGetLine :: Handle -> IO String
22:13:48 <zzing_> @hoogle Handle
22:13:49 <lambdabot> System.IO data Handle
22:13:49 <lambdabot> GHC.IO.Handle data Handle
22:13:49 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
22:14:58 <Guest52245> Could anyone explain to me the how functional programming works?
22:15:15 <Guest52245> as opposed to structured programming
22:15:57 <latro`a> control flow is structured primarily around function calls
22:16:13 <zzing_> Guest52245, such a broad question. Best way I have heard is that it is all about manipulation of data using functions.
22:16:15 <Guest52245> So how does it decide where to start?
22:16:22 <latro`a> not sure what you mean
22:16:46 <johnw> Guest52245: usually a function called "main"
22:17:05 <Guest52245> Well if you create a file rather than the real-time interpreter. Where does the program start? If that still doesn't make sense then sorry, I just learned about this today
22:17:23 <Guest52245> oh ok cool
22:17:31 <zzing_> Guest52245, have you looked at a tutorial or some introduction?
22:17:33 <latro`a> it's sorta the other way: you define what things *are*, and then a single value, main, gets "executed" by the runtime system
22:17:35 <isomorphic> Guest52245:  I think if it a little but like functions from math
22:17:36 <zzing_> That would likely inform you better
22:17:53 <isomorphic> @lyah
22:17:54 <lambdabot> Unknown command, try @list
22:17:57 <latro`a> @where lyah
22:17:57 <lambdabot> http://www.learnyouahaskell.com/
22:18:09 <isomorphic> latro`a: thanks :)
22:18:18 <latro`a> now, "what things are" includes, for example, "in which order these actions occur"
22:18:37 <Guest52245> Ok thanks guys I'll go read this
22:18:50 <latro`a> sounds like a plan :)
22:19:14 <isomorphic> Guest52245: Have you downloaded the Haskell Platform?
22:19:42 <latro`a> if not, you should probably go ahead and do that while you read LYAH
22:19:52 <latro`a> it's a fairly large download, a bit over 1 GB
22:20:08 <johnw> functional programming is quite a different beastie; you won't "get it" from our comments here
22:20:10 <latro`a> (iirc that big anyway)
22:20:30 <latro`a> (at least 600 MB, as the compiler alone is that big)
22:20:55 <YayMe> Ahhh! Why wasn't I warned???
22:21:06 <latro`a> hm, maybe it expands
22:21:09 <YayMe> "Learn haskell, it will make you a better programmer"
22:21:12 <latro`a> because the windows setup is only 100 MB
22:21:48 <monochrom> wait, it is not a big download, but after installing (decompressing) it is big
22:22:22 <YayMe> No one anywhere mentioned "and it will make you realize an easier way to write business rules and calculations, which will make using non-functional mechanisms to do so drive you crazy"
22:23:00 <monochrom> see my http://hpaste.org/52480 for a program you can already enter and run. relate its behaviour with its code
22:23:13 <latro`a> small functions that have minimal effects, YayMe
22:23:21 <latro`a> you can do that to a fair extent in imperative languages too
22:23:48 <zzing_> Where is that website that you could enter haskell code in the browser as part of a tutorial?
22:23:52 <latro`a> tryhaskell?
22:23:56 <zzing_> that is it
22:24:00 <latro`a> @where tryhaskell
22:24:00 <lambdabot> http://tryhaskell.org/
22:24:13 <YayMe> I spent 2 hours at work today trying to convince myself that I could put up with my coworkers shitting themselves when they saw me using curried Func<>s
22:24:32 <zzing_> YayMe, c++?
22:24:44 <zzing_> noticed the <> :P
22:24:46 <YayMe> but inevitably rewrote it because I know they wouldn't crap their pants, they would just presume I was an idiot
22:24:48 <YayMe> C#
22:25:02 <latro`a> you can still use closures without currying, no?
22:25:20 <YayMe> partially applied functions make repetitive pieces of business logic sooo much easier
22:25:22 <latro`a> like, the equivalent of \x -> foo y x rather than just foo y
22:26:07 <monochrom> IMO you don't need to rewrite, and they won't take you as an idiot. the code works. they can test and see. code works => writer not idiot
22:26:33 <YayMe> monochrom: You don't work in an "enterprisey" C# shop I see
22:26:36 <latro`a> still, writing the plumbing for currying might be more trouble than just making little closurse
22:26:36 <monochrom> the hard part for them to swallow, though, is: code works, reader no understand => reader idiot
22:26:38 <latro`a> *closures
22:26:55 <Enigmagic> monochrom:  other people typically end up maintaining it. clarity > cleverness.
22:27:14 <latro`a> for instance, it's really easy to write curried functions in python, that doesn't mean it's pretty or saves much space
22:27:36 <latro`a> (haven't tried it in C# so I wouldn't know)
22:27:54 <YayMe> latro`a: var curriedTriple = a => b => c => Tuple.Create(a, b, c);
22:28:18 <latro`a> that compiles as is?
22:28:22 <monochrom> you can write comments to explain. you can explain in person. cleverness is a gray area moving target
22:28:24 <latro`a> if so that's not bad at all?
22:28:29 <YayMe> well not quite
22:28:31 <latro`a> s/?/.
22:28:33 <YayMe> needs type casts
22:28:35 <YayMe> but otherwise yes
22:28:49 <YayMe> it needs (int a) or whatever, C#'s type inference is shit
22:30:15 <YayMe> latro`a: The "architects" I work with are very leery of the lambda operator because it's too confusing.
22:30:26 <latro`a> oh dear
22:30:52 <YayMe> latro`a: This system is very enterprisey, they have a god object and think copy/paste is a good technique for rapid development
22:32:36 <YayMe> at my last job I would have put up with the developers crapping themselves when they saw partially applied functions with a good day to you, but I'm new here so I would just be told to change it..
22:33:06 <monochrom> IO enjoys the full exception mechanism
22:33:21 <latro`a> monochrom, ????
22:33:37 <monochrom> random wisdom of the night
22:33:58 <YayMe> that's ironic, it's about IO, but random is a member of IO so it's also brought to us by IO
22:34:07 <YayMe> self application, I like it.
22:34:12 <monochrom> heh
22:34:38 <latro`a> I'd say random = fix random
22:34:41 <latro`a> but that would be ill-typed
22:34:42 <latro`a> :(
22:34:50 <scri> what's the easiest way to go through a list n elements at a time?
22:34:56 <latro`a> take n?
22:35:03 <scri> match with a:b:c:rest?
22:35:15 <latro`a> if n is small that works well
22:35:17 <latro`a> if not not so much
22:35:45 <scri> like if you want to find sums of consecutive elements
22:35:51 <YayMe> The imperative way to do it as fast as possible would be to first n = 0; and then the rest of it will perform as quickly as it possibly could.
22:36:00 <monochrom> write a recursion that calls splitAt
22:36:15 <latro`a> splitAt is a powerful choice, yeah
22:36:30 <scri> @hoogle splitAt
22:36:31 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
22:36:31 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
22:36:31 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
22:36:47 <scri> hm, thanks
22:36:49 <monochrom> splitAt returns (the first n guys, the rest). now recurse over it
22:37:22 <latro`a> be sure to match carefully though
22:37:54 <monochrom> yeah, when the list has fewer than n elements, take care
22:38:07 <YayMe> monochrom: What if you get to n-1 left, do you get ([n-1 elements],[])?
22:38:13 <latro`a> yes
22:38:13 <monochrom> yes
22:38:35 <YayMe> seems reasonable
22:38:49 <latro`a> if splitAt was the right solution for your problem, though, that either won't happen or you'll know what to do when it happens :)
22:38:50 <monochrom> the interesting case though is when the list has 0 items. if you forget that case, you tend to write an infinite loop, whee
22:39:31 <mm_freak_> scri: takeWhile (not . null) . map (take n) . iterate (drop n)
22:39:32 <zzing_> If I have a function   niceErrors es = map (++) (map errorStrings es)      where es is a [GLenum], and errorStrings is a GLenum -> String,  how does this function become niceErrors :: Data.String.IsString [a] => [GLenum] -> [[a] -> [a]]?    I cannot figure how the datatypes work out there.
22:39:35 <latro`a> oh, scri, sums of consecutives would be done with matching, because you want to grab two but step forward one
22:39:38 <latro`a> like
22:39:45 <mm_freak_> :t \n -> takeWhile (not . null) . map (take n) . iterate (drop n)
22:39:47 <lambdabot> forall a. Int -> [a] -> [[a]]
22:39:56 <YayMe> Can the Y combinator be written in haskell without self application?
22:40:07 <mm_freak_> YayMe: the Y combinator can't be written in haskell at all
22:40:11 <latro`a> sumConsecutive [] = []; sumConsecutive [_] = []; sumConsecutive (x:y:xs) = (x+y):(y:xs)
22:40:39 <latro`a> that *can* be implemented with splitAt, but it's awkward, because you're stepping in units of 1 but using in units of 2
22:40:45 <YayMe> mm_freak_: whoa. guess I'm not an idiot for not figuring that out, does it *require* a dynamically typed language?
22:40:48 <monochrom> if you use a newtype, you can write the Y combinator, but you may dislike it
22:40:58 <mm_freak_> YayMe: the (!) Y combinator is a specific fixed point combinator that is illtyped in a statically typed language like haskell
22:41:06 <monochrom> but plain (\x -> x x) does not type-check
22:41:41 <zzing_> newtype Mu a = Mu (Mu a -> a) ; y f = (\h -> h $ Mu h) (\x -> f . (\(Mu g) -> g) x $ x)   from http://stackoverflow.com/questions/4273413/y-combinator-in-haskell
22:41:45 <scri> latro`a: ok, i shall tinker
22:41:47 <mm_freak_> YayMe: in a non-static language…  a static language can well be dynamically typed
22:41:51 <Okasu> YayMe: http://rosettacode.org/wiki/Y_combinator#Haskell
22:42:55 <mm_freak_> haskell in particular supports dynamic typing…  what it doesn't support is casting
22:42:57 <YayMe> mm_freak_: thankyou, I feel slightly less stupid for not coming up with a way to do it in my attempts, I just figured I was failing because I don't have any math or theory training
22:43:30 <mm_freak_> YayMe: well, note that you can write a fixed point combinator in haskell…  just not the Y combinator (directly)
22:45:30 <zzing_> I need a paddling. I was trying to use map instead of foldr
22:45:52 <zzing_> and unlines does exactly what I need
22:46:45 <Okasu> i did a little research about FP
22:46:58 <zzing_> What could you name a function that takes a list of error codes, converts them to string representations all in one string ready for output?
22:47:00 <YayMe> seriously, I need to stop studying functional techniques, I am really starting to hate writing imperative code..
22:47:14 <mm_freak_> zzing_: errorString
22:47:26 <zzing_> YayMe, most of my code tends to be in IO :-(
22:47:28 <mm_freak_> YayMe: it will become worse and worse
22:47:32 <YayMe> zzing_: formatErrorCodes
22:48:05 <mm_freak_> i prefer to name non-monadic things as nouns instead of verbs
22:48:15 <mm_freak_> hence "errorCodes" or perhaps "formattedErrorCodes"
22:48:21 <latro`a> zzing_, have you read the stuff on the new buzzword, "free monads"?
22:48:32 <latro`a> that may help to get some of your code out of the IO monad
22:48:38 <latro`a> rather, to get as much as you can out of there
22:48:45 <zzing_> using my new function, I can now convert another one to point free
22:48:52 <YayMe> mm_freak_: thanks. you're helping. time for more bushmills.. maybe I can kill those brain cells that understand one partially applied function to generate 7 slightly modified functions is cleaner than 7 complete functions..
22:48:57 <mm_freak_> latro`a: the result is still monadic, though with jailed effects
22:49:00 <Okasu> and found out that there i no winners in programming contests using FP
22:49:05 <Okasu> haskel/caml whatever
22:49:07 <latro`a> I know, mm_freak_
22:49:08 <zzing_> latro`a, ignored that because I was doing C++ work during the week that was popular
22:49:13 <latro`a> but it's easier to look at, still
22:49:19 <Okasu> all first places always took by java and cpp
22:49:20 <latro`a> at least in principle
22:49:28 <mm_freak_> latro`a: i don't find IO code particularly hard to look at (in haskell)
22:49:32 <latro`a> maybe
22:49:33 <zzing_> latro`a, if you can suggest a good place to look, I will look at it tomorrow though
22:49:36 <latro`a> depends on how giant it is
22:49:38 <Okasu> strange isn't it?
22:49:57 <mm_freak_> YayMe: as soon as you get into more advanced concepts you won't just dislike imperative languages…  you will hate them
22:50:18 <latro`a> even without free monads there are often ways to take the stuff you're going to do to the data you get via IO out of the IO monad
22:50:26 <mm_freak_> YayMe: knowing how nice the haskell web frameworks are makes me HATE HATE HATE programming in PHP
22:50:37 <YayMe> mm_freak_: Let's just hope my undegreed nature will keep me from being capable enough to wrap my head around any of those
22:50:38 <zzing_> Can this be made point free?   formattedErrorCodes es = unlines (map errorStrings es)
22:50:49 <latro`a> unlines . map errorStrinsg
22:50:51 <latro`a> *Strings
22:50:51 <latro`a> also
22:51:00 <latro`a> @pl formattedErrorCodes es = unlines (map errorStrings es)
22:51:01 <lambdabot> formattedErrorCodes = unlines . map errorStrings
22:51:21 <latro`a> not necessarily a powerful tool, because...well
22:51:24 <latro`a> some examples are just bad
22:51:35 <YayMe> mm_freak_: blech.. php is downright awful even among imperative languages heh.. and I've played with warp but none of the full frameworks like snap or yesod yet...
22:51:47 <latro`a> some examples can reduce the number of points without bringing it to zero, and @pl won't help with that
22:51:59 <mm_freak_> YayMe: you should (or probably not)
22:52:45 <zzing_> I actually tried that and got an error just above, but it worked out with another composition
22:52:45 <mm_freak_> latro`a: i always try to come up with a simple DSL, before i write a monadic DSL
22:52:53 <mm_freak_> but for monadic DSLs free monads are amazing
22:53:06 <mm_freak_> write the verbs and get a whole programming language for free =)
22:53:11 <mm_freak_> haskell is unique in this regard
22:53:19 <latro`a> I still need to find a decent project to write, tbh
22:53:31 <latro`a> I made a little text scrabble program that was pretty fun, but it was also pretty trivila
22:53:32 <latro`a> *trivial
22:53:46 <YayMe> mm_freak_: Iduno.. I'm frankly so unbelievably tired of markup altogether, if all I ever had to do was generate json objects from now on I would count myself blessed... I would love to just work on backend servers and generate models for the UX devs to jQuery and present however they like
22:53:49 <mm_freak_> latro`a: recently i wrote a monte-carlo monad using 'free'
22:53:52 <latro`a> the nuts and bolts amount to three pure functions and four functions that build up an IO chain
22:54:05 <zzing_> latro`a, are you into opengl and graphics?
22:54:07 <Okasu> latro`a: pick up lambdabot project, please
22:54:21 <YayMe> Am I the only person here who uses and likes leksah?
22:54:22 <mm_freak_> YayMe: you may fall in love with yesod's shakespearean templating
22:54:24 <latro`a> lambdabot seems like a rather daunting task, frankly
22:54:28 <johnw> mm_freak_: is the monte-carlo code on the web?
22:54:34 <latro`a> like...what to pick to do there
22:54:40 <latro`a> and zzing_, I could start being so, but I am not now
22:54:49 <mm_freak_> johnw: no, it was just a quick test, but if you want, i can rewrite it quickly
22:54:53 <latro`a> my a priori interests are mostly numerical solutions of PDEs
22:55:01 <latro`a> which are probably not going to be pretty even in haskell
22:55:07 <johnw> i'd be very curious to see more examples of the free monad
22:55:13 <zzing_> latro`a, I am starting a 2d graphics ontop of opengl with the idea being to do something as easy as processing is.
22:55:26 <zzing_> Lots of work to do with openglraw though before something real useful comes out
22:56:02 <latro`a> it might be interesting to try implementing a neat idea I saw a talk about, which was parallel-in-time solution to ODEs
22:56:07 <mm_freak_> johnw: you're in luck, i didn't delete the code =)
22:56:10 <mm_freak_> let me put it on hpaste
22:57:00 <zzing_> Something that Haskell is allowing me to do - glGetError with *every* function call, but hiding it in nicer functions so a regular one doesn't need to do it.
22:57:12 <zzing_> One problem - if something fails can I get a stack trace?
22:57:13 <hpaste> “Ertugrul Söylemez” pasted “Monte Carlo monad based on Free” at http://hpaste.org/72952
22:57:13 <YayMe> mm_freak_: I think the biggest reason I've avoided digging closely into monads is because understanding them well would make haskell easy enough to make me truly despise working in imperative languages
22:57:19 <mm_freak_> johnw: see the paste
22:57:27 <johnw> i want to create a DSL for filesystem traversal, something better than the command-line language accepted by UNIX's find
22:57:31 <johnw> thanks!
22:57:46 <zzing_> johnw, right the functional shell - completely replace *sh
22:58:11 <mm_freak_> johnw: note that my functor is very unusual…  most functors for free monads are more like small keyword DSLs
22:58:16 <mm_freak_> mine is a higher rank function
22:58:20 <johnw> I more just want to have a find that doesn't need wicked predicates
22:59:03 <mm_freak_> originally my monad was defined as:  type MC = Free ((->) Double)
22:59:07 <johnw> how do I get the raw text from the pastie?
22:59:13 <mm_freak_> but the one i have now is more flexible and faster
22:59:26 <mm_freak_> johnw: http://hpaste.org/raw/72952
22:59:32 <YayMe> johnw: pasties cover something completely different and way cooler than text
23:00:10 <johnw> got it, will digest when once the ghost of Obe Wan comes and tells me I'm ready
23:00:23 <mm_freak_> johnw: or see the "Expand" link in the header…  it's a bit hidden on hpaste
23:00:37 <johnw> ah, so that's where it is
23:00:53 <johnw> I was expecting a "Raw" link at the same level of visibility as "Expand"
23:01:10 <mm_freak_> yeah, that's where it /should/ be =)
23:01:29 <zzing_> Can this be flattened? http://hpaste.org/72953       This is a pattern that might reoccur in some functions, but I think it is butt ugly.
23:01:48 <YayMe> Anyone got suggestions on best books or online sources to learn algorithms or data structures?
23:02:01 <startling> @hoogle m a -> Integer -> m [a]
23:02:02 <lambdabot> Text.ParserCombinators.ReadP manyTill :: ReadP a -> ReadP end -> ReadP [a]
23:02:02 <lambdabot> Text.ParserCombinators.ReadP endBy :: ReadP a -> ReadP sep -> ReadP [a]
23:02:03 <lambdabot> Text.ParserCombinators.ReadP endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
23:02:03 <zzing_> YayMe, there is a book on functional data structures
23:02:04 <mm_freak_> zzing_: well, one obvious way is MaybeT
23:02:15 <mm_freak_> a less obvious way is ContT
23:02:26 <YayMe> Never learned any of that, and have realized the good companies all require that shit to pass the interview, and I'm bloody tired of working with dingy wankers
23:02:30 <mm_freak_> an ad hoc way is to just use 'where' and a number of individual computations
23:02:32 <startling> @hoogle [m a] -> m [a]
23:02:33 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
23:02:33 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
23:02:33 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
23:02:53 <mm_freak_> YayMe: come to germany and visit one of my workshops =)
23:02:55 <zzing_> mm_freak_, I need to keep the errors I get
23:03:10 <startling> @hooge a -> Integer -> [a]
23:03:11 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
23:03:11 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
23:03:12 <lambdabot> Prelude const :: a -> b -> a
23:03:20 <startling> @hooge a -> Int -> [a]
23:03:21 <lambdabot> Prelude replicate :: Int -> a -> [a]
23:03:21 <lambdabot> Data.List replicate :: Int -> a -> [a]
23:03:21 <lambdabot> Prelude drop :: Int -> [a] -> [a]
23:03:26 <startling> oh right
23:03:28 <mm_freak_> zzing_: this really sounds like EitherT
23:03:39 <zzing_> mm_freak_, I see how that could be
23:03:48 <zzing_> But can EitherT do the fail at the end?
23:04:07 <mm_freak_> EitherT can do better
23:04:18 <mm_freak_> you would use something like the EitherT [Error] IO monad
23:05:06 <YayMe> So after no one responded, I guess I'm the only person who uses leksah... I don't understand why, it really seems quite stable and fluid
23:05:13 <zzing_> mm_freak_, is there a relevant example that might show me how this works?
23:05:15 <mm_freak_> zzing_: you should probably never use 'fail' explicitly
23:05:29 <mm_freak_> zzing_: i'll rewrite your code to EitherT pseudo-code
23:05:56 <zzing_> mm_freak_, I am going on the advise given in http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors/   at #4 "If you’re writing new Haskell libraries for public consumption, and all your errors are strings, please consider using this error-reporting method."  which is "Use Monad and fail to generalize 1–3"
23:06:22 <YayMe> mm_freak_: I would love to drop by germany.. I've heard various people say if you have provable heritage their you can immigrate quite easily, is that true?
23:07:11 <hpaste> “Ertugrul Söylemez” annotated “flatten?” with “flatten? (annotation)” at http://hpaste.org/72953#a72955
23:07:21 <mm_freak_> zzing_: see the annotation
23:07:27 <mm_freak_> this is how it would look like with EitherT
23:08:12 <mm_freak_> YayMe: yeah, germany is quite easy to immigrate to (although it used to be easier)
23:08:37 <zzing_> :t (<*)
23:08:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
23:08:58 <mm_freak_> zzing_: (<*) is like (>>), but the result of the first computation is returned
23:09:07 <zzing_> ok
23:09:16 <mm_freak_> > Just 3 <* Just 4
23:09:17 <lambdabot>   Just 3
23:09:35 <YayMe> mm_freak_: Does the tech industry their have a strong degree-required culture? That's another thing I've heard of some european countries (makes sense over there, degrees are easy to get there)
23:09:39 <mm_freak_> > runState (get <* put 4) 7
23:09:41 <lambdabot>   (7,4)
23:10:16 <mm_freak_> YayMe: depends…  self-employed people can get along without any degree
23:10:28 <mm_freak_> i know that because i am self-employed =)
23:10:39 <mm_freak_> and have almost no degree =)
23:10:47 <YayMe> mm_freak_: oo and self-employed people don't need to pay for health insurance! I like this idea..
23:10:57 <YayMe> that's the one thing keeping me from self-employment right now
23:11:02 <zzing_> mm_freak_, I am trying to integrate this stuff fairly seemlessly into code from line 45 to 55 of this: http://hpaste.org/72956    So that the function that does the real work is fairly clean.
23:11:15 <zzing_> EitherT makes it looks noisey
23:11:29 <zzing_> specifically line 47 and 48 would be replaced
23:11:36 <mm_freak_> YayMe: not paying for health insurance = not having health insurance…  in germany you /must/ be treated, and if you don't have insurance, you'll have to pay it yourself
23:11:44 <YayMe> with my wife and kid's health issues, my health insurance would be a solid $3-4k/month :D woot
23:11:51 <mm_freak_> in other words:  effectively self-employed people must have insurance
23:11:57 <YayMe> mm_freak_: Oh, I thought germany had government provided insurance?
23:12:20 <mm_freak_> YayMe: not for self-employed people…  you give up most services
23:12:49 <YayMe> mm_freak_: If I might ask, what do you pay monthly for it?
23:13:09 <mm_freak_> zzing_: this is because my pseudo-code doesn't use EitherT wrappers for those functions
23:13:23 <mm_freak_> zzing_: also it's not noisy, it just needs some lifting
23:13:39 <zzing_> mm_freak_, more lifting?
23:13:54 <zzing_> mm_freak_, could I create my own monad that does this error checking for me?
23:13:55 <mm_freak_> YayMe: sorry, i'd prefer not to tell =)
23:14:24 <YayMe> no worries
23:14:30 <mm_freak_> YayMe: but to answer your question you can have anything from 100 euros to 10000 euros per month
23:14:44 <mm_freak_> (the minimum depends on your current fitness)
23:14:53 <YayMe> mm_freak_: ah, so not dissimilar to here I suppose
23:15:03 <mm_freak_> zzing_: there is really no need to invent your own monad
23:16:07 <mm_freak_> zzing_: you would effectively reinvent EitherT and write the same wrappers you would have written for EitherT =)
23:16:37 <zzing_> Is the EitherT package the one that has EitherT or is this another one?
23:16:40 <YayMe> zzing_: Is your experience more with openGL in another language than with haskell? Just curious, you clearly know more about both than me (but you don't know how to calculate a sleep apnea patients apnea-hypopnea-index! hah!)
23:16:49 <mm_freak_> zzing_: what would be reasonable is not to depend on an EitherT library, but to roll your own free monad…  let me show you how
23:16:59 <zzing_> ok
23:17:04 <zzing_> YayMe, c++
23:17:23 <zzing_> mm_freak_, I know nothing about free monads
23:17:52 <latro`a> he did say "let me show you how" :p
23:17:57 <latro`a> also, *listening*
23:18:01 <YayMe> they're like free tibetans; they're just misplaced chinese people?
23:18:15 <zzing_> YayMe, best keep the politics away
23:18:29 <mm_freak_> YayMe: i'm not an opengl wizard, but i've made most of my experience in C++ and just kept using it in haskell
23:18:31 <YayMe> zzing_: It was a joke but aye
23:18:38 <mm_freak_> oh
23:18:41 <mm_freak_> you were asking zzing_ =)
23:19:07 <zzing_> YayMe, my jaw dropped when you said that. I know it was a joke, just one with an extreme lack of tact :P
23:19:47 <latro`a> mm_freak_, waiting on this exception handling free monad
23:19:48 <latro`a> :p
23:19:56 <YayMe> zzing_: I've been told tact exists, just haven't quite found it yet.. I best keep looking
23:20:08 <mm_freak_> latro`a: thinking…  it should be a monad /transformer/ after all =)
23:20:16 <latro`a> true; there's a FreeT though, no?
23:20:31 <latro`a> or wait, nvm, I see the catch
23:20:36 <zzing_> YayMe, tact is really something you have to feel for, it varies by audience.
23:21:31 <latro`a> the type that goes into Free is a Functor, then you need something that maps functors to functors, right?
23:21:51 <mm_freak_> latro`a: i'd like to get along without FreeT
23:22:17 <mm_freak_> but it doesn't seem possible
23:24:04 <mm_freak_> FreeT doesn't have all those nice instances =/
23:24:32 <mm_freak_> and defining them yourself either requires FlexibleInstances or orphans =/
23:24:43 <YayMe> I've heard word that C++ is on it's way out due to being a language that aims in too many directions at once, you two are C++ folks, what do you guys think of that? Is that just random bashing from outsiders or is their any similar view from folks who write C++?
23:24:55 <scri> @hoogle foldi
23:24:56 <lambdabot> No results found
23:25:11 <mm_freak_> @tell edwardk are you planning to add a transformer variant of Free to your 'free' library?  the FreeT from transformers-free lacks all the nice instances, in particular for Alternative, etc.
23:25:12 <lambdabot> Consider it noted.
23:25:17 <YayMe> I'm honestly curious, I don't know any folks who really know/write any C++
23:26:00 <mm_freak_> YayMe: can't tell…  i really wrote C with classes and exceptions, not C++
23:27:11 <YayMe> mm_freak_: I've heard C++ folks dislike that, but then most non-C++ folks I've read tends to find C quite good and C++ something like C with 1300 arms thumbwrestling eachother
23:27:54 <mm_freak_> no, C++ does have at least two features i miss in C
23:28:03 <YayMe> I have no insight on either, I wrote VB at the end of the last decade and C# most of this one
23:28:16 <mm_freak_> organizing effects (classes) and sensible error handling (exceptions)
23:28:22 <zzing_> YayMe, expect C++ to become even more popular
23:28:36 <YayMe> zzing_: Yeah?
23:28:37 <zzing_> Because it catches up on some of the functional stuff.
23:28:51 <zzing_> It basically does more than any other language, and does it fast and you don't pay for what you don't use
23:28:55 <YayMe> that seems to be the key to the future in my eye
23:29:10 <YayMe> the functional stuff allowing scale/concurrency
23:29:17 <zzing_> YayMe, and once 'concepts' are finalized and out there, we can have type checking on templates
23:29:20 <YayMe> C++ has that stuff eh?
23:29:46 <zzing_> YayMe, I can curry functions with bind(), lambda functions are [](…){ easy };
23:29:47 <YayMe> zzing_: What's that like, contraints on the types in the templates?
23:29:54 <mm_freak_> i always have the impression that C++ approaches something like an ugly mixture of haskell and java
23:29:58 <zzing_> YayMe, basically in a broad sense
23:30:12 <NemesisD> hmm is there a concise way to apply an argument to a list of functions? something like [(a -> b)] -> a -> [b]
23:30:14 <mm_freak_> but it's funny that java/c# have a less expressive type system
23:30:26 <mm_freak_> NemesisD: map ($ x)
23:30:29 <startling> NemesisD: myfns <*> pure arg
23:30:36 <YayMe> zzing_: Sounds like basically what I've mostly figured, C++ is akin to C# with performance
23:30:53 <zzing_> YayMe, probably decent high level overview
23:31:00 <mm_freak_> YayMe: C# is nicer syntactically, but C++ has a more expressive type system
23:31:05 <NemesisD> startling: ah. i'm not used too starting out with <*> instead of <$>
23:31:08 <zzing_> mm_freak_, I think I must sleep now
23:31:10 <startling> :t \fs a -> fs <*> pure arg
23:31:12 <lambdabot> Not in scope: `arg'
23:31:14 <startling> :t \fs a -> fs <*> pure a
23:31:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
23:31:18 <YayMe> zzing_: take it easy
23:31:40 <mm_freak_> zzing_: go ahead, good night =)
23:31:59 <startling> NemesisD: yeah! I always forget what applicative really means
23:32:04 <zzing_> YayMe, haben eine gute Nacht.
23:32:11 <startling> and just use it as an n-ary liftM/whatever
23:32:23 <zzing_> mm_freak_, thank you for your assistance. Can I ask you tomorrow about the free monad stuff?
23:32:31 <mm_freak_> startling: Applicative is a generalization of the SK calculus
23:32:37 <mm_freak_> (<*>) = S, pure = K
23:32:48 <startling> mm_freak_: oh what
23:33:03 <YayMe> zzing_: haha, wrong direction but schlaffe du gern auch
23:33:05 <mm_freak_> zzing_: you can ask any time
23:33:08 <startling> mm_freak_: kestrels and starlings, huh
23:33:15 <zzing_> mm_freak_, merci.
23:33:33 <mm_freak_> startling: in SK calculus S f g x = f x (g x) and K x y = x
23:33:57 <mm_freak_> you might interpret S as distribution:  take an argument and pass it to a function application
23:34:11 <NemesisD> startling: something is not quite right. my functions i want to apply are IO
23:34:15 <mm_freak_> this is exactly what happens in the ((->) e) instance of Applicative
23:34:33 <startling> NemesisD: your functions are IO? what does that mean?
23:34:34 <mm_freak_> > (<*>) f g x :: Expr
23:34:35 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:34:35 <lambdabot>    `SimpleReflect.FromExpr ...
23:34:46 <mm_freak_> > (<*>) f g x
23:34:47 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:34:47 <lambdabot>    `SimpleReflect.FromExpr ...
23:35:01 <mm_freak_> > (<*>) f g x :: Expr ()  -- ?
23:35:02 <lambdabot>   `SimpleReflect.Expr' is applied to too many type arguments
23:35:05 <mm_freak_> :t f
23:35:06 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
23:35:23 <startling> mm_freak_: very cool
23:35:38 <NemesisD> [store, statsDPush] <*> (calculateMetrics' =<< gatherResults ids)
23:35:52 <mm_freak_> anyway, i'd use the 'map' variant
23:35:59 <mm_freak_> > map ($ 3) [sin, cos, tan]
23:36:01 <lambdabot>   [0.1411200080598672,-0.9899924966004454,-0.1425465430742778]
23:36:15 <mm_freak_> that one can be understood at first glance
23:36:23 <startling> > [sin, cos, tan] <*> pure 3
23:36:24 <lambdabot>   [0.1411200080598672,-0.9899924966004454,-0.1425465430742778]
23:36:29 <startling> mm_freak_: I can't, tbh
23:36:37 <startling> the ($ 3) kind of weirds me out
23:36:45 <mm_freak_> well, ($) is function application
23:36:48 <startling> yeah, I know
23:36:55 <startling> it makes sense after inspection
23:37:28 <NemesisD> startling: sorry, the functions are of type [ProductMetric] -> IO (), calculateMetrics' :: IO [ProductMetrics]
23:37:28 <startling> NemesisD: but yeah, do whatever.
23:37:53 <mm_freak_> NemesisD: mapM
23:38:33 <mm_freak_> > mapM (join . ($ 3)) [Just, Just . succ, Just . pred]
23:38:35 <lambdabot>   No instances for (GHC.Num.Num (Data.Maybe.Maybe b),
23:38:35 <lambdabot>                    GHC....
23:38:55 <mm_freak_> > mapM ($ 3) [Just, Just . succ, Just . pred]
23:38:57 <lambdabot>   Just [3,4,2]
23:39:00 <mm_freak_> oh yes, sure =)
23:39:06 <mm_freak_> just mapM instead of map
23:39:16 <YayMe> Is it bad practice to maintain your state near entirely on stack as opposed to using any of the variety of monads for such?
23:39:23 <zzing_> mm_freak_, btw, is http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html  a good start or is there a better one for free monads?
23:39:45 <mm_freak_> YayMe: what stack?  haskell programs don't have a stack in the same sense as a C program
23:40:13 <YayMe> mm_freak_: I know that, but I think of stack as the stacking of method calls
23:40:15 <Mortchek> If YayMe means passing state through recursive calls to some function, I am also interested in the answer
23:40:22 <mm_freak_> zzing_: i don't know…  for me they just made click by looking at the API
23:40:25 <NemesisD> i think this needs do notation, this is getting silly
23:40:26 <mm_freak_> and by writing my own Free
23:40:37 <zzing_> me no click immediately
23:40:41 <mm_freak_> YayMe: the question is too general to be answered sensibly
23:40:52 <mm_freak_> zzing_: just do what the title says
23:40:56 <mm_freak_> reinvent Free =)
23:41:07 <mm_freak_> data Free f a = Pure a | Free (f a)
23:41:36 <mm_freak_> NemesisD: are you even reading my suggestions?
23:41:52 <YayMe> mm_freak_: Would that mean sometimes maybe othertimes maybe not? That's what I figured but I was hoping I could be told "yes, it's bad; don't do it"
23:42:00 <zzing_> time for bed really now. bbl.
23:42:34 <mm_freak_> YayMe: it highly depends on the application and the kind of state
23:43:27 <YayMe> mm_freak_: Any general guidelines exist around when your state should be abstracted into a monad rather than just pushing mutations into functions to form your state
23:43:44 <NemesisD> mm_freak_: i am, but the code in my particular case becomes unreadable as a one-liner
23:44:09 <mm_freak_> YayMe: the general guideline for haskell programming is:  do what is natural
23:44:15 <mm_freak_> haskell is a natural language
23:44:23 <YayMe> eh.. makes sense I guess
23:44:55 <NemesisD> i find it more readable as: do { metrics <- calculateMetrics' =<< gatherResults ids; mapM ($ metrics) [store, statsDPush]
23:45:04 <NemesisD> so i did use your suggestion, just broke it up for readability
23:45:07 <mm_freak_> YayMe: you'll get the intuition as you delve deeper into haskell, but you'll need to be patient =)
23:45:45 <mm_freak_> NemesisD: why didn't you just break the right part into multiple indented lines?
23:45:55 <YayMe> mm_freak_: Yeah, I got that after the first week with haskell when I still felt like a bumbling fool; no language has done that to me since my first heh
23:46:34 <NemesisD> mm_freak_: indented under the do or are you saying don't use do
23:46:41 <Mortchek> YayMe, but then when you learn it, you get to feel pretty smart :)
23:46:51 <Mortchek> I am still in the process of doing that myself. :P
23:47:32 <NemesisD> YayMe: i use haskell in my free time to exercise my brain after munging about in Ruby all day at work
23:47:36 <mm_freak_> NemesisD: oh, i misread your code…  it's fine the way it is now
23:47:42 <YayMe> Mortchek: same, and true, but today and yesterday at work I wanted to tear my eyes out for not being allowed to use functional features I learned in haskell at work
23:47:52 <Mortchek> YayMe, what language do you use at work?
23:48:19 <YayMe> imperative languages can be learned in a day or two usually, the first few nights I was dreaming in haskell however was terrible because I didn't understand any of it, seriously worst sleep ever.
23:48:22 <YayMe> Mortchek: C#
23:48:53 <mm_freak_> YayMe: don't worry, i'm programming haskell for more than four years now, and even now i'm still learning…  haskell is like a parallel universe and you can always explore further =)
23:49:46 <NemesisD> every once in a while at work we'll come across some problem that could be solved beautifully with functional programming, then my coworker writes some ugly imperative method to do it and it makes me sad
23:50:18 <mm_freak_> it has given me the most numerous and most intense epiphanies of all programming languages, and i know quite a lot of them =)
23:50:20 <YayMe> NemesisD: Yeah, I wrote about 200 lines today under protest that would have been ~30-40 in haskell
23:50:48 <Mortchek> Ever since I started learning FP, I have stayed as far away from for loops as possible. It's fortunate that JS has map and reduce methods and such on arrays.
23:51:09 <startling> I wish more languages had Maybe
23:51:17 <NemesisD> like when we needed some method to generate permutations of arrays, i did a nice one FP style, he did a nasty imperative mess, did some tricks to get negligible performance gain (only on ridiculously large values of N), he committed his version. i wanted to smack him in the face
23:51:27 <YayMe> startling: RIGHT??
23:51:37 <mm_freak_> i wish all languages had IO
23:51:48 <Ralith> I wish more languages had Arrow
23:51:50 <Mortchek> startling, depending on the language, there's a null or none value of some sort, which can serve a similar purpose.
23:52:10 <NemesisD> Mortchek: its the evil cousin of maybe if you don't have typechecking though
23:52:46 <YayMe> I just wish more languages allowed currying and partial application to be done so tersely, many languages can do them, but the verbosity to do it is so yuck
23:52:56 <mm_freak_> Mortchek: null is not captured by the type system
23:52:58 <mm_freak_> Maybe is
23:53:06 <mm_freak_> further Maybe is a monad, null doesn't form one
23:53:15 <mm_freak_> all in all null is /very/ inconvenient
23:53:27 <NemesisD> one of our apps has millions of logged exceptions from calling methods on nil over the years
23:53:41 <mm_freak_> lack of a monadic/implicit-checking interface, lack of a special type, etc.
23:54:12 <Mortchek> Haskell has certainly given me renewed appreciation of static typing.
23:54:28 <mm_freak_> anyway, IO is one of the main features of haskell i miss in imperative languages
23:54:29 <NemesisD> in those languages its often a good idea to change the type into something benign when nil, i.e. instead of a Foo or nil, have the output be a list of Foos
23:55:20 <YayMe> mm_freak_: sure beats return 0 or throw exception sometimes though.. I admit I've made the habit of returning nulls and forcing an if for them on consumers. It's just the best option available to me
23:55:45 <mm_freak_> YayMe: no, there is a hidden Maybe in most languages, including C#
23:55:48 <rosie> When would you want to :add a module, but not :module (or :load) it
23:55:48 <mm_freak_> throw/catch
23:56:38 <YayMe> mm_freak_: that will get you throw/caught on your arse often times, I quite like to use it but you do not understand how completely afraid most C# folks are of exceptions
23:56:39 <Mortchek> mm_freak_, surely that's more like Either?
23:57:03 <mm_freak_> YayMe: i wouldn't care…  my libraries always threw exceptions
23:57:17 <NemesisD> tbh i'm pretty afraid of exceptions in haskell
23:57:22 <YayMe> To be fair, exceptions do come with a performance hit in C#, but that aside, really, I think most C# developers are just spooked because exceptions are what define many of their bugs
23:57:25 <mm_freak_> YayMe: it's stupid at best and dangerous at worst to return null in a language with exceptions
23:57:43 <YayMe> mm_freak_: I wouldn't either if corporate policy in enterprisey shops wasn't to follow orders
23:57:45 <mm_freak_> Mortchek: indeed
23:58:08 <mm_freak_> in fact Either SomeException is the implicit exception monad you find in imperative languages
23:58:18 <mm_freak_> with SomeException from Control.Exception
23:58:39 <mm_freak_> YayMe: your company /forced/ you to return null?
23:59:12 <Ralith> C# actually *has* a maybe-like type, it's just kind of pointless because regular types can hold null too
