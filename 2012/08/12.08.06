00:00:20 <carter> edwardk: really enjoyed chatting!
00:00:32 <edwardk> carter: likewise, back in NY?
00:00:37 <carter> yes!
00:00:53 <carter> also may have the HBlas lib in working order
00:01:05 <mgsloan> string diagrams!!!  There should totally be a lambdacat for Baez, similar to http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960831913&k=rhDdG&lb=1&s=L
00:01:11 <edwardk> made it back a little while ago, the first plane was damaged, then the second had mechanical problems, yay
00:01:18 <carter> eeek
00:01:22 <mgsloan> "Baez cat sayz:  It's just a simpul string diagram!"
00:01:30 <edwardk> hah
00:01:37 <edwardk> i love string diagrams
00:01:48 <edwardk> my coworkers make fun of me for it ;)
00:02:06 <carter> edwardk: what're string diagrams?
00:02:17 <edwardk> i spent like two whole sessions teaching string diagrams in our category theory sessions
00:02:33 <mgsloan> They're pretty awesome.  I think that they'll teach them in elementary school 200 years from now
00:02:49 <carter> http://en.wikipedia.org/wiki/String_diagram ?
00:03:16 <edwardk> they are a pretty way to visualize operations in a monoidal category. since Cat is monoidal you can use them to talk about functors and natural transformations
00:03:36 <edwardk> in particular they make the proof that every adjunction gives rise to a monad dead obvious
00:03:39 <carter> ezyang: that data viz project of mine in still in progress, its just grown a few additional awesome heads
00:03:49 <edwardk> they also make it easy to reason about right and left kan extensions
00:03:55 <carter> edwardk: is the wikipedia page a good place to start?
00:04:10 <srhb> carter: Check the catsters video which is linked from the article
00:04:11 <edwardk> look for the catsters videos on string diagrams
00:04:14 <srhb> (Always nice intro to mathy things)
00:04:18 <edwardk> they are very good
00:04:22 <srhb> Yep.
00:04:26 <carter> edwardk: cool, i'll do that after I get this lib working
00:04:35 <carter> i think it builds
00:04:50 <edwardk> and hinze's recent right kan extension paper uses them a lot
00:05:56 <mgsloan> KHAAAAAAAAAAAAAN extension
00:06:01 <edwardk> the way he used them provides what is perhaps a nicer way to explain right kan extensions than the muddle of them i made on my blog
00:06:15 <carter> i'm running the test suite!
00:06:15 <carter> woo
00:06:27 <carter> so far all green
00:07:05 <kuribas> Which version control systems do you use, and why?  I have used a bit of darcs because it seemed simpler than the other systems.
00:07:11 <edwardk> when star trek online came out i made a character named daniel kan. everybody just thought it was a bad spelling ;)
00:07:29 <edwardk> i use git because its hard to top github
00:07:52 <mgsloan> yup.  diagrams recently switched to git, and I think it's really helped encourage contribution
00:08:46 <mekeor> edwardk: darcsden?
00:08:53 <kuribas> I have the impression github is recently favoured over sourceforge?
00:08:57 <mgsloan> I've got a little version of lenq targetting Control.Lens:  https://github.com/mgsloan/quasi-extras/blob/master/src/Language/Quasi/Lenq.hs
00:09:05 <srhb> kuribas: Not that recently, it's been like that for a long time now.
00:09:28 <edwardk> its not the same. on github i get people sending me patches almost faster than i can keep up. on patchtag or darcsden i may have recieved 5 patches for all the repos i hosted there
00:09:34 <mgsloan> (5,0) == set $( lenqExp [e| \(x,_) -> x |] ) 5 (1,0)
00:09:43 <edwardk> nifty
00:10:28 <mekeor> edwardk: yea, thats true.
00:10:37 * hackagebot wai-logger-prefork 0.2.1 - A logging system for preforked WAI apps (KazuYamamoto)
00:11:00 <edwardk> i'll fork a repo on github to send a patch because i can do it with a click of a button, often make the edit on the webpage and send the pull req
00:11:22 <edwardk> its hard to beat the workflow
00:11:42 <edwardk> and the ability to see what patches other people have in their forks of your repos, not just whats in your repo
00:11:56 <mgsloan> edwardk: Yup, doesn't yet do anything very cool like detecting partiality, or really doing cases of any variety, really, but it shouldn't be /that/ bad
00:12:54 <srhb> Even if the workflow was much better on darcsden, you'd still have to move people there. Github has all the people already. It's raelly become a hub of Open Source activity.
00:13:23 <mgsloan> srhb: yup.  It's nice to have a centralized "opensource resume" or so
00:13:29 <srhb> Yes. :)
00:13:55 <mgsloan> it's got the kind of momentum that facebook has, in that people don't want to "start fresh"
00:15:37 * hackagebot mighttpd2 2.7.1 - High performance web server on WAI/warp (KazuYamamoto)
00:15:56 <kuribas> I wanted to have a system where I can mix markdown with literate haskell to create a documented source.
00:16:12 * applicative sends ekmett a trivial markdown patch on github just to show kuribas how easy it is
00:16:16 <kuribas> For example using pandoc.
00:16:57 <applicative> yes markdown+lhs is such a system isn't it
00:17:06 <ezyang> kuribas: Someone recently submitted a feature request for that in GHC
00:17:22 <kuribas> yes, but how to combine it with a VC?
00:18:10 <applicative> kuribas, you mean you would want the markdown to be ignored for purposes of version control?
00:18:11 <mgsloan> well, git already has good markdown and highlighting support.  I imagine if we gave them a little widget that converted to that format, they'd put it in
00:18:19 <mgsloan> s/git/github/
00:18:39 <mgsloan> Maybe just have GHC accept github flavoured markdown?
00:18:50 <mgsloan> ```haskell  Code goes here ``` blocks
00:19:09 <kuribas> So when you view a haskell lhs file, you get a nicely formatted document.
00:20:35 <Targen> Does GitHub understand LaTeX-style code sections?
00:20:45 <Targen> GHC sure does.
00:21:29 <kuribas> Right now I think I'd either have to write my own interface, or pre-generate the formatted document.
00:21:58 <edwardk> i should probably make a lens that can read the content out of any left adjoint and an indexed setter for any right adjoint
00:22:19 <slack1256> any of you use vng (the darcs like interface to git)?
00:22:23 <edwardk> those will definitely wind up in my adjunctions package once i drop its dependency on representable
00:22:41 <mekeor> slack1256: never heard.
00:22:41 <applicative> github understands lhs as lhs; it knows how to do syntax highlighting for example
00:23:17 <ezyang> Huh, isomorphisms don't have to be unique. Weeeeird
00:23:30 <shachaf> Do {-# INLINE #-} declarations on non-functions do anything?
00:23:48 <ezyang> shachaf: Yes.
00:23:48 <shachaf> ezyang: Why is that weird?
00:23:53 <edwardk> shachaf: sure, copy the definition in place
00:23:58 <ezyang> This is why you need to NOINLINE unsafePerformIO global state
00:24:04 <shachaf> Oh, good point.
00:24:07 <ezyang> shachaf: Cuz I'm silly
00:24:35 <edwardk> ezyang: think any automorphism
00:24:50 <ezyang> yeah; go go permutations!
00:25:19 * applicative takes that back the github lhs highlighter doesn't understand latex codeblocks
00:26:16 <edwardk> i need to get these gettable changes finished for lens before it gets too hard to merge other changes in
00:27:11 <carter> hey all ( edwardk ezyang  included ), i'm nearly done cleaning up the HBlas package so that it builds sans warnins or errors on 7.4
00:27:18 <edwardk> score
00:27:32 <edwardk> one of these days i should find and push to github the changes to blase that made it work
00:27:34 <carter> but my computer isn't beefy enough for me to run the test suite fully :)
00:27:46 <carter> without pinning EVERYTHING else
00:29:36 <startling> does anyone know of a haskell library for creating object files? There seem to be a handful out there for parsing
00:29:48 <MostAwesomeDude> "object files?"
00:29:58 <startling> ELF or Mach-O or what have you
00:29:58 <frerich> startling: As in ELF?
00:30:08 <startling> frerich: yes
00:30:47 <carter> would anyone care to run the test suite on a beefy machine please :) https://github.com/cartazio/hs-linear-algebra
00:30:55 <frerich> startling: I think there are Haskell bindings for libbfd
00:31:28 <startling> frerich: is that what bfd is for? I couldn't seem to get a straight answer and most of the docs seem aimed towards parsing
00:31:39 <frerich> startling: Hm, but looking at http://hackage.haskell.org/package/bindings-bfd I'm not sure whether it can *write* object files...
00:31:52 <startling> frerich: yeah. :/
00:32:12 <srhb> startling: I may have a beefy machine, but not sure I have the required expertise
00:32:42 <startling> I could write bindings, but I'm surprised this isn't well-tread ground.
00:32:52 <srhb> sorry, that was for carter
00:32:54 <startling> also, it'd mean learning a C api. :/
00:33:01 <frerich> startling: In case it helps, I have once written an ELF resource compile (to turn arbitrary files into ELF objects) in C a few years ago. I could look for the source code and you could look into writing a Haskell binding for it.
00:33:34 <shachaf> startling: There are some packages for working with object files.
00:33:41 <shachaf> For examples, "elf" and "macho" on Hackage.
00:33:51 <startling> shachaf, both seem to be exclusively for parsing
00:33:56 <shachaf> Maybe others.
00:33:59 <shachaf> Oh. Hmm.
00:34:08 <shachaf> Yes, you're probably out of luck. :-)
00:34:12 <carter> srhb: it just requires pulling the cabal repo down, doing cabal configure, cabal build, and then doing into the dist/build/test-hs-linear-algebra/ and running the testing binary
00:34:39 <srhb> carter: I'll have a go at it. Just need full output of the last command?
00:34:41 <frerich> startling: I just noticed that my program ("elfrc") was forked a bazilliion of times, you can find the source code quite easily. It's not a complete library though, just enough to write the sections correctly.
00:34:54 <carter> theres one massive input example where a test failed
00:35:11 <carter> and i think my mb air was just thrashing on the matrices
00:35:30 <carter> like, MONSTER matrix
00:36:03 <carter> so idk.... maybe put the output on a gist
00:36:03 <startling> frerich: thanks! I'll look at the code
00:36:15 <carter> and srhb : thanks!
00:36:19 <srhb> carter: OK, trying :)
00:36:25 <startling> might be worth writing in haskell tbh
00:37:27 <carter> srhb: awesome: if i'm still on when its done, linke me the gist
00:37:37 <carter> and/or file an issue with the link to the gist
00:38:00 <srhb> carter: If I can get past building.. :)
00:38:06 <startling> frerich, is ELF especially painful to work with? I don't think I've ever worked at this low of a level, so I'm not sure what to expect really
00:38:21 <carter> srhb: the dependencies are pretty friendly...
00:38:26 <carter> let me know whats missing
00:38:54 <srhb> carter: cabal configure : Warning: The 'build-type' is 'Configure' but there is no 'configure' script. cabal: configure script not found.
00:38:54 <taruti> What is currently a good library for serialization that allows embedding IO inside serialization actions? (e.g. like binary but a transformer)
00:39:19 <carter> srhb oh yeah, you need to do aclocal -I m4
00:39:20 <carter>     autoreconf
00:39:22 <srhb> ah
00:39:22 <carter> aclocal -I m4
00:39:23 <carter>     autoreconf
00:39:31 <frerich> startling: It's been a few years, but IIRC it was fairly straightforward. My particular project was made a little harder because I had the requirement to be very portable (even to S390 machines and stuff like that), but I think if you can live with only supporting little-endian systems it will be easier. I never did such low-level stuff in Haskell though, so in case you decide to go ahead with that: there may be dragons.
00:39:42 <carter> srhb: THANK YOU THOUGH
00:40:06 <carter> we've not had a none GPL'd lin alg package on hackage thats not been dead on a few years
00:40:21 <carter> and I somewhat crucially need one for my own stuff :)
00:40:36 <srhb> I might too one day ;) -- hopefully in fact.
00:40:37 <carter> so i'm giving the old one CPR
00:40:44 <carter> srhb: oh?
00:40:52 <startling> frerich, I've done some bit-twiddling in haskell, so I'm not expecting anything too unusual. thanks for the advice!
00:41:00 <carter> for fun or profit or both?
00:41:10 <srhb> carter: Studying physics, would love to do things with Haskell and physics. Linear algebra seems crucial.
00:41:19 <carter> srhb: understatement
00:41:24 <srhb> carter: I know :-)
00:41:48 <carter> srhb: sounds like you're either understating for comedic effect, or you've not taken QM yet
00:41:53 <carter> haha
00:42:12 <carter> srhb: more plainly, i'm working on assasinating R & Matlab
00:42:13 <srhb> carter: Actually both, QM is this winter :)
00:42:17 <srhb> Neat!
00:42:34 <carter> and I have some SERIOUS customers lined for the fall the moment I have some basic stuff in shape
00:42:42 <frerich> startling: Out of curiosity, what do you need this for? :-)
00:42:52 <srhb> carter: I think your project is very important then ;)
00:43:15 <startling> frerich, playing around with a tiny compiler. just an untyped low-level thing at the moment, but I'd like to get around to a little functional language
00:43:24 <carter> srhb: considering if I get this off the ground, I will be able to throw relatively unlimited money at improving the haskell eco system
00:43:25 <carter> yes
00:43:44 <carter> srhb: i'm actually not being hyperbolic
00:43:51 <sp3ctum> unlimited money sounds cool
00:43:53 <carter> theres some serious money
00:43:58 <srhb> carter: Oh I didn't think you were
00:44:03 <carter> sp3ctum: relatively unlimited :)
00:44:14 <sp3ctum> carter, still cool
00:44:23 <carter> sp3ctum thanks
00:44:32 <srhb> carter: I'm afraid the build process is problematic to me since I'm a noob. =/ After a seemingly working cabal configure I get, with build... cabal: Package linear-algebra-0.8.1 can't be built on this system.
00:44:44 <carter> whats teh error?
00:44:51 <carter> are you windows mac or linux?
00:45:01 <carter> i've another box I can use on my side
00:45:07 <srhb> carter: Linux. And there seemed to be no error in the cabal configure. A lot of *nos* though
00:45:08 <carter> i just didn't want to walk to another room
00:45:17 <carter> srhb: doy ou have blas/ lapack installed?
00:45:27 <srhb> ah, no, I guess that explains :)
00:45:34 <Ralith> carter: oh man, matlab really does need to die
00:45:41 <Ralith> godspeed!
00:45:44 <carter> Ralith : thanks
00:46:18 <carter> srhb: gist me the error message if installing those doesn't fix it
00:46:32 <carter> srhb learing to read  / skim through the build error to fix things
00:46:34 <carter> is KEY
00:46:35 <srhb> OK, muddling along once I find lapack in ubuntu repos Æ=
00:46:41 <srhb> carter: Yep, trying!
00:47:06 <carter> Ralith: if i get this biz / tech off the ground, i'll be able to say i'm making innovation happen faster on the planet
00:47:29 <carter> ironically, the easiest early adopter users won't be researchers
00:47:45 <carter> but businesses that need easy to use algorithm experimentation and deployment
00:48:40 <carter> because the 150k-300k+ in manpower spent going back and forth between production and experimetnation code bases for the same algorithms
00:48:51 <carter> is a huge resource and time drain
00:48:51 <srhb> Building. :)
00:49:19 <carter> Ralith: the correlary is i'll be also burying Hadoop and its ecosystem once i have some manpower on board
00:49:25 <carter> I can't spell at this hour
00:49:31 <carter> srhb: huzzah
00:50:31 <Ralith> carter: I'll keep an eye out for when you're hiring ^^
00:51:12 <carter> Ralith: i message yah, look off channel
00:53:21 <srhb> carter: It does appear to be eating all my RAM... ÆP
00:53:22 <srhb> :P
00:53:34 <carter> whats the AEP thing you'r edoing ?
00:53:51 <carter> srhb: it wasn't ram that was problematic for me, its that things were all slow
00:54:04 <carter> so i htink the memory bus on my laptop was saturated
00:54:11 <srhb> carter: I've seen no output yet and it has eaten 8GB RAM
00:54:23 <carter> ?!!?
00:54:25 <carter> really?
00:54:27 <srhb> Yup.
00:54:32 <carter> ???????
00:54:38 <carter> i have only four
00:54:44 <carter> you did install the dependencies, right?
00:54:48 <srhb> Yes :)
00:54:55 <carter> ok......
00:55:14 <srhb> It just threw out 4GB so something must be happening :P
00:55:33 <carter> no outputs on the terminal?
00:55:39 <srhb> None.
00:55:51 <carter> ?!?!!?!?
00:55:52 <lambdabot> Unknown command, try @list
00:55:59 <carter> @bitch
00:55:59 <lambdabot> Unknown command, try @list
00:56:04 <carter> @no
00:56:05 <lambdabot> ()
00:56:09 <carter> haha
00:56:22 <srhb> Any sense in keeping it going?
00:56:44 <mekeor> no
00:57:12 <srhb> test-hs-linear-algebra: out of memory (requested 7320109056 bytes)
00:57:48 <carter> this iis the srhb
00:57:50 <carter> hrm
00:57:52 <carter> oops
00:58:20 <carter> srhb mekeor : could another mac user test on their machine?
00:58:31 * mekeor is not mac.
00:58:42 <mekeor> sorry
00:58:50 <carter> mekeor : well, another linux user would work then :)
00:58:51 <srhb> I do have a Mac too, but I'd have to find the dependencies again and so.
00:58:59 * carter mac
00:59:03 <Targen> I'm working on setting up a beefy machine for the test.
00:59:13 <Targen> Should be going in a few minutes.
00:59:18 <srhb> Cool. :)
00:59:21 <mekeor> carter: how can i help?
01:00:09 <carter> mekeor: follow the readme directions on https://github.com/cartazio/hs-linear-algebra to build, and then run the test suite binary?
01:00:51 <Targen> It'd be done by now, but it seems some other user of that system decided that silly "~/.cabal" directory was ugly and needed to go.  For whatever reason.
01:01:06 <carter> Targen: thanks! :)
01:01:14 <srhb> Targen: Yeah, who needs that silly directory cluttering up the homedir..
01:02:29 <Jafet> Another user? In your ~?
01:03:29 <Targen> Jafet: I suspect it must've been the same wise soul who decided a shared account for everyone in the lab could be a good idea.
01:03:53 <srhb> No, no, that seems entirely unlikely...
01:04:06 <Jafet> I wonder if /mnt/usb/.cabal
01:04:55 <Targen> I don't have physical access, but that seems like a very nice idea in general.
01:05:10 <srhb> Maybe mount .cabal over the network :)
01:06:26 <mekeor> i get "cabal: Package linear-algebra-0.8.1 can't be built on this system".
01:06:32 <mekeor> carter.
01:06:37 * ezyang is trying to code up a "fake" fold function which can be shown to fail to have the universal property 
01:06:44 <srhb> mekeor: Remember to get liblapack-dev and libblas-dev
01:06:50 <mekeor> -.-
01:06:50 <carter> mekeor: whats the error message?
01:06:57 <mekeor> i just said!
01:07:24 <srhb> Yeah, the configure script really does not give any indication of an actual error, even if they are missing
01:07:25 <carter> mekeor: no whats the full blob of text
01:07:30 <srhb> carter: There is none
01:07:36 <carter> really?
01:07:38 <srhb> yes, really.
01:07:43 <carter> lame
01:07:55 <carter> mekeor: is blas & lapack installed?
01:08:16 <mekeor> what's that?
01:08:23 <t7> ezyang: but every folr is universal :|
01:08:29 <t7> foldr*
01:08:59 <carter> mekeor: you need to install the c libs that srhb mentioned
01:09:07 <ezyang> t7: Right, I'm trying to come up with a plausible "alternate foldr" that doesn't work
01:09:13 <mekeor> carter: i did.
01:09:24 <carter> ohhhh
01:09:25 <carter> ok
01:09:31 <mekeor> :)
01:09:35 <mekeor> it's compiling.
01:09:43 <Targen> ezyang: Apart from the universal property, what qualifies a function to call itself a sort of foldr?
01:09:53 <carter> mekeor: oh, so not a problema gain?
01:09:53 <ezyang> For example, fold' f z s [] = z; fold' f z s [x] = s x; fold' f z s (x:xs) = f (fold' f z s xs) x
01:10:13 <mekeor> carter: no. it just finished compiling.
01:10:15 <mekeor> built.
01:10:24 <carter> mekeor: testing time? :)
01:10:30 <mekeor> how does that work?
01:10:34 <ezyang> Targen: In a very loose sense, any function that captures some induction scheme on data types
01:10:35 <mekeor> cabal test?
01:10:46 <carter> mekeor
01:10:51 * mekeor listens.
01:10:55 <carter> unfortunately, its not THAT polished,
01:10:55 <ezyang> So, is fold' universal?
01:10:57 <carter> cd dist/
01:11:05 <mekeor> yup
01:11:20 <carter> cd dist/build/test-hs-linear-algebra
01:11:30 <mekeor> yup
01:11:50 <mekeor> now?
01:12:00 <carter> ./test-hs-linear-algebra
01:12:38 <carter> is that running?
01:12:40 <mekeor> yup
01:12:53 <carter> i get the first few tests resulting immediate
01:12:55 <carter> ly
01:13:29 <mekeor> Does anybody know why i get "No instance for (Control.Monad.IO.Class.MonadIO (ServerPartT IO)) arising from a use of `liftIO'" when I use Happstack(.Server) (although that module defines such an instance)?
01:14:04 <mekeor> carter: how long will that take?
01:14:11 <carter> IMEEDIATELY
01:14:14 <mekeor> oh
01:14:16 <carter> for the first few tests
01:14:21 <carter> Vector:
01:14:21 <carter>   dim/fromList: [OK, passed 100 tests]
01:14:21 <carter>   at/fromList: [OK, passed 100 tests]
01:14:24 <carter> sort of thing
01:14:41 <mekeor> i just got "test-hs-linear-algebra: out of memory (requested 1657798656 bytes)" and then it quit.
01:14:52 <carter> ok....
01:14:58 <carter> lemma look at the test code
01:15:01 <mekeor> re-running…
01:15:27 <Jafet> Clearly you should find someone with a mac pro
01:15:39 * hackagebot fast-logger 0.2.1 - A fast logging system (KazuYamamoto)
01:16:28 <mekeor> again. same error.
01:16:29 <carter> Jafett: its saving stuff to disk is the issue
01:16:34 <carter> hang on
01:19:00 <ezyang> fehh, failing to show that fold' doesn't have the universal property
01:20:38 <carter> AHHHHH
01:20:55 <carter> i'm frustrated
01:21:15 <mekeor> *I* am frustrated!!
01:21:20 <Targen> Well, I got as far as a test failure.
01:21:32 <mekeor> this annoying error (with happstack) is really annoying!
01:21:47 <carter> Targen: is it with a monster matrix thing?
01:21:58 <carter> and then it jsut starts disk thrashing somehow?
01:22:02 <t7> i am not very annoyed this morning
01:22:28 <Targen> carter: I don't think so.  Vector: dot: Complex Double
01:22:41 <Targen> carter: Falsifiable with seed -2457514092656452, after 2 tests. Reason: VectorPair (fromList [2.3495557795779534 :+ 1357.9506250705842]) (fromList [5.868285329782236 :+ (-4.81604097366505)])
01:22:57 <Targen> Doesn't seem to have gotten too far.
01:23:34 <ezyang> Hmm, the algebra that this fold is defined on is kind of weird. It's something like 1 + Mu<L>(X + L * X)
01:23:36 <carter> i'm fails on complex double with some vectors that are GINORMOUS
01:24:11 <Targen> Oh, it's still going.  Ish.
01:24:17 * carter is going to comment out the vector tests and see if it does the next stuff ok
01:25:27 <carter> if these bugs aren't easy fixes, i'm just going to hassle alberto about hmatrix getting BSD'd
01:26:10 <carter> ok, the post Vector testing seems ok
01:26:14 <carter> (so far)
01:26:22 <carter> fingers crossed
01:26:34 <carter> it may be a numerical stability issue
01:26:46 <carter> yess
01:26:50 <carter> that mayb e it
01:26:51 <carter> hang on
01:29:33 <tertl3> i naming a song like naming a funciton
01:30:11 <Targen> I have a .cabal file describing a package that just generates two small executables that need exactly the same packages.  What’s a reasonably simple way of not having to specify the build-depends once for each executable?  I'd like to avoid repetition, if possible.
01:31:11 <carter> Targen: it may just be that the definition of approx equality is crap :)
01:32:16 <Targen> carter: Well, floating point is, in general :)
01:32:44 <hpaste> “Ertugrul Söylemez” pasted “Short echo server” at http://hpaste.org/72676
01:33:22 <Targen> I understand it's necessary for the progress of science.  I'm glad there are many forms of science that don't need it, and thus are much more fun.
01:34:08 <carter> Targen: no, his notion of approximate equality is actually crap :)
01:34:56 <carter> Targen: for complex #'s its
01:35:23 <hpaste> carter pasted “crap equality” at http://hpaste.org/72677
01:36:13 <carter> I think L2 norm is a better measure here
01:38:04 <Targen> Should be more stable, at least.
01:38:08 <carter> yess
01:38:18 <carter> this approx equality is BIZAARRREEE
01:38:33 <Targen> Is polar guaranteed to not produce NaNs, or somesuch?
01:38:42 <srhb`> The name seems to imply it's some kind of standard though?
01:39:09 <Targen> It may just refer to the typeclass.
01:39:16 <srhb`> Ah.
01:39:20 <carter> Targen: which thing areyou talking about ?
01:39:56 <Targen> carter: «isNaN angle» seems like an odd test.
01:40:11 <carter> Targen: its just generally WRONG loooking
01:40:14 <Targen> yup
01:40:27 <carter> ironically he's jr faculty at NYU now
01:40:42 <carter> i will have to grab coffee with him sometime and tease the shit out of him
01:40:53 <carter> (i work near nyu)
01:41:21 <Targen> Well, it died on a big matrix.
01:42:41 <carter> Targen : as in crashed?
01:43:37 <carter> Targen: i think theres an issue w/ the quickech instances
01:43:52 <carter> look in Test/Quickcheck/LInearAlgebra.hs
01:43:54 <carter> (i'm staring there)
01:44:01 <carter> i think theres a bad bound on matrix size
01:45:01 <carter> as in
01:45:03 <carter> NO BOUNDS
01:46:02 <Targen> carter: Yup.  Angry OOM kernel, I suspect, although it doesn’t say. https://gist.github.com/3272328
01:46:35 <carter> Targen: i'm going to see if i can hack the QC instances to max their DIm at like 20
01:46:37 <carter> or something
01:49:06 <carter> anyone know how to setup QC instances so they have a max size?
01:49:29 <Targen> Should be just a matter of cheating in Test/QuickCheck/LinearAlgebra.hs:159, no?
01:49:30 <ezyang> There's a parameter for that..
01:49:58 <Targen> return (min 20 m, min 20 n)
01:50:46 <carter> ezyang Targen : i'm realizing that :)
01:51:04 <ezyang> Embarassingly, I can't remember what it is though.
01:52:13 <carter> min n 20
01:52:16 <carter> is what i'm doing to do
01:52:20 <ezyang> Hmm, it looks like it's not built into arbitrary, so you have to do it manually
01:52:57 <Targen> There's suchThat, but that just throws away data you don't want rather than generating the data you do want.
01:53:06 <Targen> So it tends to hang.
01:53:07 <VitamnP> does anyone know if theres some kind of relationship between the size of a number and the size of its prime factors?
01:53:07 <carter> yeah
01:53:26 <carter> ezyang Targen : what i'm doing is hard bounding dim1 to min n 20
01:53:35 <carter> and that should flow through the rest
01:53:41 <Jafet> Then you get tons of 20
01:54:58 <Yuu-chan> VitamnP: try to look in http://oeis.org/A001222
01:54:59 <carter> Jafet: thats ok :), that shouldn't cause OOM :)
01:55:11 <Jafet> You might try n `mod` 20
01:56:19 <carter> Jafet: you're a sexy clever 450am math dude
01:56:20 <carter> :)
01:56:24 <carter> just sayin
01:56:36 <Jafet> Fortunately it's not 0450 here.
01:56:47 <VitamnP> thanks Yuu-chan
01:57:21 <carter> that'll make things run much faster on average :)
01:58:14 <carter> WOOOOOO
01:58:16 <carter> ok
01:58:22 <carter> lightning
01:58:26 <carter> pusihing uptdate
01:58:52 <carter> Ya'll with the OOM eerrors
01:58:55 <carter> or linux boxes
01:58:57 <carter> test! :)
02:00:01 <carter> i'll like to thank #haskell
02:00:05 <carter> and the academy
02:00:09 <carter> (not sure which one)
02:00:11 <carter> but one of them!
02:01:56 <Targen> Quite fast indeed.  https://gist.github.com/3272328#file_1
02:07:43 <carter> Targen: so now the questions are: 1) does a saner defn of approx equality yield no test fails
02:08:08 <carter> and Targen  2) how much more cleanup / effort to add lapack goodness
02:12:17 <carter> bye ALL
02:12:19 <carter> SLEEEP
02:12:36 <carter> and maybe I can use this to leverage getting Hmatrix a bit more BSD3
02:13:12 <mekeor> carter: bye bye :)
02:13:23 <carter> mekeor: I WILL RETRUN
02:13:28 <carter> REurn
02:13:31 <carter> i can't spelll
02:13:37 <mekeor> go sleeping, now.
02:13:47 <carter> I will RETURN with a BSD3 Lin ALg lib for hackage
02:13:49 <carter> THIS WEEK
02:13:53 <carter> its imporant
02:13:54 <mekeor> okay.
02:14:00 <carter> i'm being silly
02:14:01 <carter> 'night all
02:21:42 * paolino plants a lambda on Mars
02:28:40 <mekeor> Should I use fmap, liftA or liftM for IO?
02:31:58 <kuribas> mekeor: you should use <$> :-)
02:32:38 <mekeor> yea, or that…
02:33:07 <mekeor> kuribas: the problem with <$> is that you have to import Data.Functors :/
02:33:17 <mekeor> (or define it yourself)
02:34:06 <mekeor> s/Functors/Functor/
02:35:09 <kuribas> I usually use liftM.
02:37:30 <Yuu-chan> Data.Functor or Control.Applicative?
02:37:46 <mekeor> both work
02:37:52 <mekeor> @hoogle (<$>)
02:37:53 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
02:37:53 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
02:38:17 <Yuu-chan> @hoogle (<*>)
02:38:18 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
02:38:40 <kuribas> Would you use fixed point (Integer) over floating point (Double), or wouldn't you bother?  (For example for a document formatter)
02:39:10 <Yuu-chan> Integer has no points :)
02:39:30 <mekeor> kuribas: fixed point because comparisons are easier.
02:40:08 <mekeor> kuribas: but if you need to use functions like (/), then floating point.
02:40:21 <Yuu-chan> What about Fractional Int?
02:40:37 <Yuu-chan> s/Fractional/Ratio
02:40:37 <mekeor> did you mean Rational?
02:40:40 <mekeor> yea.
02:40:52 <Jafet> Fractional Int sounds rather...
02:40:54 <Jafet> irrational.
02:41:02 <Yuu-chan> %)
02:41:43 <mekeor> :D
02:42:01 <Yuu-chan> @hoogle Ratio
02:42:02 <lambdabot> Prelude type Rational = Ratio Integer
02:42:02 <lambdabot> Data.Ratio type Rational = Ratio Integer
02:42:02 <lambdabot> Data.Ratio module Data.Ratio
02:42:09 <mekeor> actually, it's even Ratio Int, or Rational.
02:42:12 <mekeor> yeah.
02:42:14 <kuribas> I wonder which will be faster, Double or Rational... (for +, -, * and /)
02:42:47 <mikeplus64> almost definitely Double
02:42:48 <Jafet> Use Fixed if you know what you're doing, Rational if you think you know what you're doing, Double if you're an engineer
02:43:14 <mikeplus64> kuribas: for a document formatter for say margins on a page Double seems sane
02:43:26 <mikeplus64> but you can always use Rational
02:43:26 * mekeor uses Complex CReal, usually.
02:43:51 <Jafet> Rational requires you to pay careful attention to the denominator.
02:44:15 <Jafet> Fixed requires you to pay careful attention to numerical correctness
02:44:23 <Yuu-chan> Use type Margin = Rational and change if it proves to be slow
02:44:31 <kuribas> I am now using Double, just because it is easier to implement.
02:44:37 <Yuu-chan> @hoogle Fixed
02:44:37 <lambdabot> Data.Fixed module Data.Fixed
02:44:37 <lambdabot> Data.Fixed data Fixed a
02:44:38 <lambdabot> Data.Text.Lazy.Builder.RealFloat Fixed :: FPFormat
02:44:59 <Jafet> So if you have no idea what you're doing, run around in circles and use Double
02:46:13 <Jafet> Note that you can use approxRational to pretend your numbers are simple fractions
02:47:04 <kuribas> is a + b == b + a  for Doubles?
02:47:17 <mikeplus64> if you cross your fingers
02:47:20 <Yuu-chan> preflex: list
02:47:20 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
02:47:21 <preflex>  ZCode: [zdec, zenc]
02:47:23 <Jafet> Usually.
02:47:46 <Jafet> However, (a + b) + c often isn't a + (b + c)
02:48:35 <mikeplus64> > 0.1 + 0.2 == 0.2 + 0.05 + 0.05
02:48:35 <Targen> But surely it must be symmetric, no?
02:48:37 <lambdabot>   False
02:49:05 <kuribas> > 0.1 == 0.05 + 0.05
02:49:06 <lambdabot>   True
02:49:09 <Jafet> I believe it happens to be defined to be symmetric
02:49:13 <Jafet> > 0.3 == 0.1 + 0.2
02:49:14 <lambdabot>   False
02:49:18 <Yuu-chan> :t log
02:49:19 <lambdabot> forall a. (Floating a) => a -> a
02:49:25 <Targen> It'd be quite the odd standard if it wasn't.
02:49:49 <Yuu-chan> > 0.1 + 0.2 == 0.2 + 0.1
02:49:50 <lambdabot>   True
02:50:11 <Jafet> If there was a practical reason to make it asymmetric, it probably would be
02:50:25 <Yuu-chan> > sqrt (10^8)
02:50:26 <lambdabot>   10000.0
03:02:29 <kuribas> TeX is writter in fixed point Math, but that's probably because floating point was more expensive in the time when he wrote it.
03:02:59 <sipa> no need to use floating point for coordinates anyway, is there?
03:04:47 <kuribas> Doesn't postscript use floating poin?
03:14:56 <Palmik> Hi guys, I'm stuck with template-haskell issue at the moment (here is the code that describes the issue and contains my attempts to solve it http://hpaste.org/72680 and I eventually solved by wrapping in GADT here http://hpaste.org/72682, but I would like to explore another possible solutions). TL;DR: I have an TH.ExpQ and I have to apply a function that requires the expression to be of type of certain type class.
03:27:08 <shachaf> Shouldn't stderr be unbuffered? I have a program that does main = do { hPrint stderr "start"; ...segfault... }, and the message is never being printer.
03:27:48 <mauke> hexdump or it didn't happen
03:28:05 <shachaf> Hmm, maybe it's not a buffering issue.
03:28:14 <shachaf> Hexdump of what?
03:28:19 <mauke> the error output
03:28:53 <shachaf> There's no error output.
03:28:59 <mauke> hexdump or it didn't happen
03:29:00 <shachaf> Other than my shell printing "Segmentation fault"
03:29:13 <shachaf> I gave you a hexdump.
03:29:20 <shachaf> shachaf@carbon:~/u/text/tests$ ./dist/build/blah/blah 2>&1 | hexdump
03:29:20 <shachaf> shachaf@carbon:~/u/text/tests$
03:29:20 <mauke> where?
03:29:35 <mauke> ok, then your program description is incorrect
03:29:43 <shachaf> main is of the form do { hPrint stderr "start"; ... }
03:29:54 <shachaf> When I comment out the ... my program prints "start"
03:29:59 <Targen> $ ghc -e 'do System.IO.hPutStr System.IO.stderr "test"; Foreign.peek Foreign.nullPtr'
03:29:59 <Targen> testSegmentation fault
03:30:03 <Targen> Works for me, I believe.
03:30:12 <mauke> shachaf: can I see your program?
03:31:05 <shachaf> mauke: My program depends on a big library I'm making changes to.
03:31:21 <shachaf> The Main module itself is http://slbkbs.org/Blah.hs
03:31:40 <shachaf> Er.
03:32:04 <shachaf> http://slbkbs.org/Blah.hs.txt
03:33:01 <shachaf> If I comment out the middle three lines it prints "start" and "end"
03:33:29 <mauke> what if you replace T.pack by undefined?
03:34:07 <shachaf> Hmm, it still crashes.
03:34:13 <shachaf> So I guess the problem isn't what I thought it was. :-)
03:34:36 <mauke> and TA.length?
03:35:04 <shachaf> Either of the lines following the let causes a segfault.
03:35:25 <mauke> compiler bug?
03:35:47 <shachaf> Which is kind of strange because there are no calls to Data.Text being made in «let t@(TI.Text arr off len) = undefined "hello there"; print ("off,len",off,len)»
03:36:21 <shachaf> Maybe. Though I wouldn't blame a compiler for generating crashing code with the things I'm doing to it...
03:37:03 <shachaf> Oh, hmm, this is interesting...
03:37:16 <shachaf> If I print just off or just len, it works fine.
03:37:22 <shachaf> If I print both, it segfaults.
03:38:19 <mauke> hmm. look at the generated code?
03:38:50 * shachaf isn't sure what flags GHC is being called with to compile this file...
03:39:03 <ezyang> gdb it!
03:39:10 <ezyang> You have a deterministic segfault, right?
03:39:23 <shachaf> Yes.
03:39:52 <shachaf> I'm not surprised that my changes to the library are causing a segfault, though.
03:40:06 <shachaf> I'm just surprised that it's showing up this way.
03:40:35 <ezyang> hmm, your source code isn't accessible.
03:41:16 <shachaf> Try now.
03:41:58 <shachaf> Program received signal SIGSEGV, Segmentation fault.
03:41:58 <shachaf> 0x000000000046609f in startupHpc ()
03:42:22 <ezyang> what is the definition of TI.Text?
03:42:27 <ezyang> That's odd. Are you running hpc?
03:43:50 <shachaf> TI.Text is the normal one, with an unpacked Array and two Ints.
03:44:15 <shachaf> Hmm, I didn't mean to be running hpc, but this is being run as part of the test suite, so maybe it is running.
03:44:49 <ezyang> Can you say what the GHC invocation is which causes the segfault?
03:44:54 <ezyang> Could just be an hpc bug.
03:45:53 <shachaf> Oh, cabal -v
03:46:01 <shachaf> /usr/local/bin/ghc --make -o dist/build/blah/blah -hide-all-packages -fbuilding-cabal-package -package-conf dist/package.conf.inplace -i -idist/build/blah/blah-tmp -i. -idist/build/autogen -Idist/build/autogen -Idist/build/blah/blah-tmp -optP-DASSERTS -optP-DHAVE_DEEPSEQ -optP-include -optPdist/build/autogen/cabal_macros.h -odir dist/build/blah/blah-tmp -hidir dist/build/blah/blah-tmp -stubdir dist/build/blah/blah-tmp -package-id base-4.5.0.0-6db966
03:46:08 <shachaf> ...That may have gotten cut off.
03:46:22 <ezyang> oh yeah, that's going to be long :-)
03:46:40 <ezyang> Can you turn on GHC's lint pass?
03:47:13 <shachaf> -dcore-lint?
03:47:34 <ezyang> yeah
03:47:38 <shachaf> Still segfaults.
03:48:19 <ezyang> k, well, it was worth a shot
03:48:31 <ezyang> you could try +RTS -DS
03:49:47 <shachaf> Program received signal SIGSEGV, Segmentation fault.
03:49:47 <shachaf> 0x000000000045f485 in readTix () at rts/Hpc.c:159
03:49:47 <shachaf> 159	        ASSERT(lookup->tixArr != 0);
03:50:04 <ezyang> heh, that does sound like an HPC bug.
03:50:07 <shachaf> Yep.
03:50:18 <ezyang> get yerself a nightly and see if it still fails
03:50:33 <ezyang> (I assume you have checked that it doesn't segfault w/o hpc)
03:50:34 <shachaf> It's 03:50. Isn't that nightly enough? :-(
03:50:51 <shachaf> I'm not sure how to turn hpc off. I'm not passing it to GHC, at least.
03:51:15 <mauke> p lookup
03:51:38 <shachaf> lookup is 0x0
03:51:51 <mauke> :-(
03:53:04 <ezyang> Post the full GHC invocation?
03:53:17 <mroman> Is there a performance impact on using generic* list functions?
03:53:18 <ezyang> You probably just want to remove the profiling flag
03:53:41 <ezyang> mroman: Depends
03:53:51 <shachaf> Does any invocation other than that of main.hs matter?
03:54:02 <ezyang> No, not for profiling
03:54:10 <ezyang> But you do care about the runtime flags too.
03:54:45 <shachaf> http://slbkbs.org/cabal-v.txt
03:54:49 <mroman> Depends on what?
03:55:35 <ezyang> mroman: If GHC is able to type specialize the function, then there shouldn't be any overhead
03:55:41 <ezyang> check the STG to be sure.
03:56:05 <shachaf> I was thinking that this was a problem with my code but now I'm not even sure.
03:56:41 <ezyang> shachaf: Runtime flags?
03:57:13 <shachaf> ezyang: I was running with +RTS -DS, if that's what you mean.
03:57:26 <ezyang> ...oh
03:57:31 <shachaf> Same thing happens without it.
03:57:56 <ezyang> oh oh. That is confusing.
04:00:38 <shachaf> You'll be pleased to know that I'm indeed confused.
04:04:03 <ezyang> Oh, I am mistaken: hpc is a compile time deal.
04:04:29 <shachaf> Hmm, a blah.tix is being generated.
04:05:57 <shachaf> How is hpc coming to be used?
04:06:06 <shachaf> Nothing is passing -fhpc as far as I can tell.
04:06:40 -dsgvasdf(~asdfasdf@ip72-197-167-107.sd.sd.cox.net)- ALERT! http://pastebin.com/aacTUjjb Freenode is infiltrated by PEDOPHILES from the top down to the bottom! Notice in this log how staffers tolerate graphic descriptions of child sex and the solicitation in open channel to distribute child porn via pm without banning!  Check out the Pastebin of this! http://pastebin.com/aacTUjjb 30924823094823
04:06:42 <t7> haskell needs an awesome crypto lib like .net and java
04:06:59 <Botje> man, i can't wait for it to be september again
04:07:08 <Botje> when all the stupid kiddies have to go back to school :/
04:07:26 <mekeor> @where ops
04:07:27 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:07:35 <shachaf> ...Hmm.
04:07:39 --- mode: ChanServ set +o mauke
04:07:39 --- mode: mauke set +b *!*@ip72-197-167-107.sd.sd.cox.net
04:07:45 <shachaf> I deleted dist/build/ and recompiled and it works now.
04:07:54 --- kick: dsgvasdf was kicked by mauke (dsgvasdf)
04:07:56 <shachaf> I guess that should've been the first thing I tried.
04:08:42 --- mode: mauke set -q+b $a:Maiz_en_Heces $a:Maiz_en_Heces
04:09:30 <shachaf> mauke, ezyang: Thanks!
04:09:46 <mauke> hah, ouch
04:09:53 <shachaf> Maybe it's still a bug with recompilation checking or something, who knows.
04:10:42 --- mode: mauke set -o mauke
04:11:37 <danil> What's the status of external core? Still write-only?
04:13:42 <ezyang> hoo boy
04:27:42 <t7> where can i learn how to calculate  x / y (mod z) ?
04:27:55 <t7> i know how todo mult inverse
04:28:06 <t7> but i dont know how they fit together
04:28:20 <poelfda> huh? x / y = x * y^-1
04:29:12 <t7> but i thought x / y (mod z) didnt mean (x / y) `mod` z
04:30:23 <shachaf> Does it not mean x * y^-1?
04:30:29 <t7> i need to go back to school
04:30:33 <shachaf> For appropriate values of ^-1
04:30:37 * ezyang recalls this question being asked not too long ago. 
04:30:45 <sipa> t7: the "mod X" qualifier means the arithmetic happens in Z_X
04:30:49 <ezyang> You need to calculate the reciprocal with GCD (and it only works when the numbers are coprime)
04:31:01 <sipa> it doesn't just mean a `mod` X operation at the end
04:31:01 <ezyang> and then you use ordinary modular multiplication
04:31:40 <sipa> so X/Y mod Z, is X*(modinv Y Z) `mod` Z
04:33:22 <t7> ah
04:34:57 <sipa> or put otherwise, if x / y = z (mod m), it means that y*z = x (mod m)
04:39:30 * shachaf suspects going to sleep may be a good idea.
04:45:44 <mekeor> @time shachaf
04:45:46 <lambdabot> Local time for shachaf is Mon Aug  6 04:45:26 2012
04:45:52 <mekeor> shachaf: yes.
04:46:22 <mekeor> shachaf: good morning, sleep well.
04:49:46 * mekeor just discovered -XTypeOperators. great.
04:49:57 <mekeor> type (:$) a b = a b
04:50:06 <t7> Thanks sipa et al
04:50:31 <t7> are modular addition and multiplication just (x * y) `mod` z ?
04:50:38 <sipa> yes
04:51:09 <ezyang> but you can do it more efficiently!
04:52:05 <mekeor> ezyang: how?
04:53:35 <DrTeggy> Montgomery reduction
04:53:54 <mekeor> ah.
04:54:17 <ezyang> It's not so useful when the modulus is small, it is true :-)
04:54:30 <mekeor> Montgomery reduction is an algorithm introduced in 1985 by Peter Montgomery that allows modular arithmetic to be performed efficiently when the modulus is large -- *LARGE*.
04:54:38 <mekeor> ezyang: yup.
04:54:44 <mekeor> {wikipedia}
04:54:50 <ezyang> we also know how to speed up modular exponentiation
04:55:20 <mekeor> i have a question.
04:55:45 <mekeor> i want to time out the execution of a non-monadic function. but timeout doesn't work.
04:56:14 <ezyang> are you 'evaluate' ing it?
04:56:20 <mekeor> yes.
04:56:25 <mekeor> but not haskell.
04:56:42 <mekeor> it's a tiny littly infix-calculator.
04:56:55 <ezyang> I don't understand.
04:57:12 <mekeor> i don't evaluate haskell.
04:57:13 <mekeor> no.
04:57:21 <ezyang> @hoogle evaluate
04:57:22 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
04:57:22 <lambdabot> Control.Exception evaluate :: a -> IO a
04:57:22 <lambdabot> Control.OldException evaluate :: a -> IO a
04:57:32 <ezyang> @info evaluate
04:57:33 <lambdabot> evaluate
04:57:33 <ezyang> :info evaluate
04:57:53 <ezyang> (that one)
04:57:54 <mekeor> what is this?
04:58:04 <mekeor> its argument to be evaluated to weak head normal form when the resultant IO action is executed
04:58:18 <mekeor> s/its/forces its/
04:58:22 <mekeor> what does that mean?
04:58:23 <ezyang> yes; if you just 'return' then the computation will be done in the wrong thread
04:58:28 <ezyang> Remember Haskell is lazy.
04:58:49 <mekeor> ezyang: coool.
04:58:55 <mekeor> i hope that'd solve my problem.
04:58:57 <mekeor> let's try.
04:59:53 <quicksilver> I doubt it.
04:59:59 <quicksilver> you said timeout doesn't work
05:00:06 <quicksilver> so it's not timing out? so it keeps running?
05:00:12 <mekeor> yup
05:00:25 <quicksilver> I don't think 'evaluate' is going to do anythign to make your pure computation not keep running.
05:00:27 <mekeor> same with evaluate.
05:00:49 <quicksilver> the only really reliable way to time out haskell computation is a separate OS process.
05:01:05 <mekeor> i seem to have the same problem as http://stackoverflow.com/questions/11761000/haskell-need-to-timeout-when-running-eval-from-the-hint-package
05:01:34 <mekeor> because when i use "timeout 1" (that is, one microsecond), it works.
05:01:50 <mekeor> quicksilver: so, how can i do that?
05:02:05 <ezyang> Ah, OK, you have the "no one is allocating memory" problem
05:02:10 <quicksilver> compile two different executables.
05:02:22 <quicksilver> one as the watchdog and one to run the interpretation.
05:02:43 <quicksilver> and use system level facilities (like POSIX kill()) to kill the interpreting one after a timeout
05:03:47 <mekeor> hm.
05:04:09 <quicksilver> that's what lambdabot does
05:04:10 <mekeor> quicksilver: so, how can i do the timeout that way?
05:04:48 <quicksilver> you wait N seconds for the process to terminate normally witha  result
05:04:51 <mekeor> how can i wait, and take the result if in time, or, if time exceeded, take another value…?
05:04:52 <quicksilver> and if you don't see a result, you kill it.
05:04:57 * ezyang wonders if the interruptible mechanism can be extended to work with non-allocating Haskell code. 
05:05:21 <mekeor> quicksilver: i can't imagine how to do that… :/
05:05:40 <quicksilver> mekeor: why not? it sounds very simple to me.
05:07:03 <mekeor> do startOtherExecutable; sleep 2; -- and now?
05:07:55 <mekeor> :/
05:10:18 <quicksilver> mekeor: well that depends how your other executable will run.
05:10:23 <quicksilver> maybe it produces output on stdout
05:10:26 <quicksilver> maybe it creates a file
05:10:32 <quicksilver> maybe you check if the file is there
05:10:38 <mekeor> it produces output on stdout.
05:10:39 <quicksilver> maybe you check if the process is still running
05:10:43 <quicksilver> and then you kill the process.
05:10:51 <mekeor> ah.
05:10:52 <mekeor> yeah.
05:11:06 <quicksilver> it is, admittedly, a fair amount of work, but it's not "hard". Just a Simple Matter of Programming.
05:11:21 <quicksilver> if you have more specific questions about how to do it, happy to answer :)
05:11:46 <mekeor> thanks! =) :D :) :] =]
05:13:08 <luite> mekeor: you can also wait for the exit code of the new process with a timeout
05:13:14 <mekeor> quicksilver: which package/module provides functions for launching, checking and killing processes?
05:13:36 <quicksilver> system.posix.signals
05:13:43 <quicksilver> system.process
05:13:54 <quicksilver> (answers not provided in the correct order)
05:14:05 <luite> mekeor: if you get Nothing, you have waited too long, you kill the thing, if you get something, read the result
05:14:17 <luite> see System.Timeout
05:14:30 <luite> (i think you'll need the threaded runtime for this)
05:15:01 <mekeor> luite: timeout didn't work… would it work if i use it on an other executable, if you know what i mean? quicksilver?
05:15:35 <luite> mekeor: yes i mean waiting for the other process
05:15:40 <LaughingMan> is there something for deprecated messages in haddock?
05:16:09 <quicksilver> mekeor: luite is not suggesting you timeout your computation.
05:16:17 <quicksilver> he is just suggesting you timeout your waitForProcess call
05:16:20 <luite> right
05:16:34 <mekeor> ah, okay.
05:17:09 <mekeor> This is great. You are great. Thanks, quicksilver and luite. :)
05:18:58 <quicksilver> mekeor: it's unfortunate that GHC's RTS can't more-robustly timeout its own threads
05:19:11 <quicksilver> but it's a compromise.
05:19:25 <quicksilver> GHC's RTS is not agressive enough to supervise "untrusted" code really
05:25:31 <madtusker> brb
05:25:45 <t7> did anyone else just get a GLOBAL NOTICE or am i being pm'd?
05:25:51 <ezyang> I saw it
05:26:02 <DrTeggy> yep
05:30:53 <mekeor> "The human eye is a wonderful device. With a little effort, it can fail to see even the most glaring injustice."? Yes.
05:30:53 <mekeor>  
05:34:09 <belgin> was that a reference to something?
05:34:17 <quicksilver> freenode getting a new server
05:34:23 <quicksilver> move along please nothign to see :)
05:35:37 <t7> my point addition isn't an abelian group :'(
05:45:02 <pshr> Hi, I am using yesod and i am beginner to haskell. I am trying to write a function which takes nothing but performs some operation on a list , just like giving the status variable a value
05:45:05 <hpaste> pshr pasted “List inside a function” at http://hpaste.org/72685
05:45:11 <pshr> http://hpaste.org/72685
05:46:30 <pshr> how do i give some variable a value , Do i need to read and learn about monads  since liftIO is doing some thing like that I guess ?
05:47:19 <Botje> pshr: you mean you want to update some global state?
05:47:25 <ezyang> In general, in Haskell we try to avoid allocating mutable variables, and prefer just passing values around.
05:47:25 <malthe> hey guys
05:47:42 * Botje waves
05:47:51 <malthe> since the new IO manager, is it reasonable to say that haskell is no longer just an academic choice in I/O-heavy, concurrent programming?
05:48:02 <pshr> Botje: yes some thing like that so that this value is read by the .hamlet file
05:48:20 <malthe> case in point, does it make sense to implement a serious key/value storage system in haskell (as opposed to e.g. erlang)
05:48:23 <luite> pshr: liftIO takes an action in the IO monad, and runs it in the Handler monad. you bind the result to the status variable. you can use #{status} in your hamlet file
05:48:28 <ezyang> malthe: Yes, Haskell does quite well for concurrent programming. Better than Python.
05:48:35 <luite> pshr: if it's some value that has the right instance
05:48:38 <ezyang> (though that is, admittedly, a low bar to surpass)
05:48:44 <malthe> right
05:49:13 <ezyang> malthe: "What do you mean by key value storage system"
05:49:42 <luite> pshr: say status is a Text value, you can use something like [whamlet| <h1> hello #{status} |]
05:49:50 <malthe> ezyang, basically an external memory dictionary.
05:50:00 <luite> pshr: hamlet has access to everything in scope where it's inserted
05:50:03 <pshr> luite: what I am trying to do is split the string obtained by newline character and assign that list to a #{statuslist} variabe
05:50:13 <malthe> (sorted, like b-trees).
05:50:52 <luite> pshr: oh you can use let statuslist = lines status  below the status <- line
05:51:00 <ezyang> malthe: I think some of Haskell's design properties will discourage you from implementing a classic system of that kind
05:51:00 <luite> pshr: and then us #{statuslist} in your hamlet
05:51:05 <ezyang> for better or for worse.
05:51:13 <malthe> ezyang, as a learning project, I am interested in implementing this algorithm: http://arxiv.org/abs/1103.4282v2
05:51:31 <pshr> thanks luite let me try that
05:51:32 <pshr> :)
05:52:57 <malthe> right. I'm afraid that haskell's memory model has poor modality with the operating system's paging system.
05:53:07 <nooodl> is there any way to let ghci display all the type classes of which some type is an instance?
05:53:25 <malthe> but I guess memory mapping isn't exactly a stranger to functional programming.
05:53:31 <frerich> nooodl: I think ":info" does that.
05:53:55 <frerich> nooodl: Try e.g. ":info Maybe" to see which classes 'Maybe a' instantiates.
05:54:03 <nooodl> frerich, cool, that's exactly what i was looking for :)
05:54:40 <ezyang> malthe: It kind of is.
05:54:59 <pshr> luite: thank you..
05:55:01 <ezyang> Anyway, Haskell's "pure by default" philosophy won't buy you much if your implementing "clever" algorithms of the kind described by the paper
05:55:17 <ezyang> since the point is to be bare metal and do as many mutation tricks as humanly possible to understand
05:58:42 <malthe> ezyang, perhaps, but most datastructures can be implemented functionally and I suspect this one is no different.
05:59:43 <malthe> not that I'm any kind of authority in that.
06:00:03 <malthe> to wit, the authors implemented a prototype in ocaml
06:02:30 <ezyang> ocaml is an impure language ;-)
06:03:40 <Yrogirg> How do I change [IO a] to IO [a]?
06:03:41 <statusfailed> How would I go about proving a function to be correct?
06:03:43 <malthe> ezyang, so what this algorithm does is to basically buffer a bunch of updates in memory (in a temporary datastructure), then serialize that to disk.
06:03:47 <statusfailed> Yrogirg: sequence I think
06:03:50 <int-e> Yrogirg: sequence
06:03:51 <malthe> I don't think that sounds incompatible with purity.
06:04:57 <luite> Yrogirg: if you ended up with [IO a] through some map, you can replace that with mapM
06:04:59 <ezyang> @hoogle [IO a] -> IO [a]
06:05:00 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:05:00 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
06:05:00 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
06:05:05 <Yrogirg> thanks
06:05:08 <luite> Yrogirg: (which is a combination of map and sequnence)
06:05:37 <ezyang> mekeor, quicksilver: http://hackage.haskell.org/trac/ghc/ticket/367#comment:15
06:05:52 <Yrogirg> oh, mapM is what I needed
06:09:43 <mekeor> ezyang: erm… okay… err… yea… hm?
06:11:35 <ezyang> (it's re the earlier conversation about timeout)
06:16:48 <cleantc> if I have a large datatype "data T = T0  | T1 T | T2 T T T ...", how can I write a transformation f:: T -> T without the need to explicitly coding the recursion. which generic method do you suggest?
06:17:19 <cleantc> I have been using Uniplate, but is there anything more common / GHC native?
06:17:24 <ezyang> Well, there's always Data.Data
06:17:42 <ezyang> (i.e. syb)
06:18:00 <cleantc> let's assume T derive Data.Data and Typeable
06:18:32 <ezyang> Right. Then you can just use the functions in data directly
06:26:10 <t7> this is doing my head in
06:31:30 <Saizan> most combinators are in the syb package though
06:32:03 <mekeor> quicksilver: the only thing i'm missing, is an effective way to terminate a process using its ProcessHandle.  System.Process.terminateProcess doesn't work properly; namely, the process seems to continue running.
06:32:32 <ezyang> mekeor: Is it still running, or just zombified?
06:33:06 <mekeor> it is still running but it doesn't use any memory although it should use memory if it's running (noramlly).
06:33:22 <sipa> how do you see it's still running?
06:33:26 <sipa> is it using CPU?
06:33:28 <mekeor> htop =)
06:33:39 <mekeor> sipa: nope.
06:34:06 <mekeor> oh. it's "sleeping"
06:34:11 <sipa> does it have state 'Z' ?
06:34:19 <mekeor> yeah.
06:34:28 <mekeor> oh thtat means ZOMBIE
06:34:30 <mekeor> oops.
06:34:36 <mekeor> it's a zombie!!! WAAAA
06:34:47 <mekeor> okay, seriously.
06:34:58 <mekeor> how do i terminate it? :/
06:34:59 <ezyang> Right. So if you wait on it, it will get reaped.
06:35:18 <koala_man> it's already terminated
06:35:23 <geekosaur> mekeor: waitForProcess
06:35:40 <geekosaur> any process you start, you have to waitForProcess on.
06:35:43 <mekeor> so, it's dead?
06:35:43 <sipa> mekeor: zombie means that's gone in practice; but its PID and associated statistics are still around, because the parent process didn't read them yet
06:35:52 <mekeor> geekosaur: why?!
06:35:56 <geekosaur> (or you can double fork so the actual child is inherited by init)
06:36:03 <geekosaur> so you can get its exit status
06:36:08 <Jafet> http://www.youtube.com/watch?v=sOnqjkJTMaA
06:36:23 <mekeor> i want to timeout it… you know…
06:36:31 <geekosaur> and various profile information which you probably don't care about
06:36:32 <ezyang> 'man wait': learn it, love it.
06:36:37 <hpaste> mekeor pasted “this is my code” at http://hpaste.org/72686
06:37:06 <ezyang> once you kill it, running wait should be instantaneous
06:37:13 <t7> this makes no sense :(
06:37:26 <geekosaur> mekeor, if you truly want to fire-and-forget and never find out when the process exits and never get its exit status, etc., double-fork
06:37:34 <geekosaur> this is basic POSIX process control
06:37:36 <parcs`> t7: what doesn't?
06:37:55 <ezyang> Arguably, someone should have written a library abstracting this all away :^)
06:38:10 <t7> im getting Elliptic curve points from brainpool yet they dont divide properly
06:38:12 <mekeor> geekosaur: forkIO?
06:38:17 <geekosaur> you still need to reap the parent with waitForProcess but you can do it immediately since the first child just forks and immediately exits
06:38:18 * mekeor never did such stuff.
06:38:20 <ezyang> mekeor: No, that's different.
06:38:20 <geekosaur> *sigh* ni
06:38:21 <geekosaur> no
06:38:24 <mekeor> ^^
06:38:28 <geekosaur> createProcess
06:38:44 <ezyang> Actually, the distinction between Haskell threads and OS threads is legimitately confusing, so don't feel too bad about it :-)
06:38:54 <mekeor> :)
06:39:13 <geekosaur> I do wish Haskell hadn't used fork* for threads
06:40:07 <quicksilver> ezyang: surely we're talking about the difference between haskell threads and OS *processes*
06:40:22 <quicksilver> although the differences between haskell threads and OS threads is also legitimately confusing.
06:40:26 <geekosaur> quicksilver, that's just aother example of the confusion, yes ;}
06:40:32 <geekosaur> (metaexample...)
06:41:00 <quicksilver> meta-:)
06:44:40 <Yuu-chan> I accidentally a TAPL. A whole thing.
06:44:42 <Yuu-chan> Is that bad?
06:44:45 <dmj> is it bad if I don't have a $HOME/.cabal/bin directory? I'm trying to run snap and it says it can't be found, it is installed though
06:44:52 <ezyang> Yuu-chan: No, it is excellent!
06:45:08 <ezyang> dmj: It is a little odd.
06:45:16 <geekosaur> mekeor, http://stackoverflow.com/questions/881388/what-is-the-reason-for-performing-a-double-fork-when-creating-a-daemon is about Python but the same thing applies to any other language
06:45:31 <geekosaur> dmj, OS X?  it's Library/Haskell/bin instead
06:45:33 <quicksilver> geekosaur: that's the old fashioned way, though
06:46:04 <quicksilver> the double-fork() hack should really be replaced by setsid() and/or setpgrp() type calls in modern POSIXes
06:46:05 <geekosaur> quicksilver, I was after the why, not the what
06:46:09 <Yuu-chan> ezyang: I'm reading it veeery slowly, seems it's still hard for me...
06:46:22 <ezyang> mekeor, geekosaur, quicksilver: I can't really recommend forking the Haskell runtime, especially when it is multithreaded...
06:46:31 <quicksilver> definitely not.
06:46:41 <quicksilver> much easier just to make a new process
06:46:44 <ezyang> Yuu-chan: That's what places like #haskell are here to help out, right :-)
06:46:53 <quicksilver> system.command or system.process or whatever it was
06:47:39 <t7> ezyang: i should allways be able to add 2 points on a curve, right?
06:48:14 <ezyang> ...elliptic curve?
06:48:18 <t7> yeah
06:48:42 <Yuu-chan> A wild guess from the type theory: what if it would be possible to make sum types without explicit constructors, like type Foo = Int | String?
06:49:14 <t7> Yuu-chan: like ML ?
06:49:25 <t7> int + string
06:49:35 <ezyang> Yuu-chan: It's called subtyping
06:49:46 <ezyang> If you add explicit labels which can be reused, it's called polymorphic variants
06:50:03 <mikeplus64> Yuu-chan: one disgusting way i can think of doing it is with a typeclass
06:50:06 <t7> sum types are subtypes ?
06:50:24 <quicksilver> without explicit constructors, t7
06:50:26 <Yuu-chan> I'm discussing with my friend about static typing and functions overloading
06:50:31 <quicksilver> ML doesn't let you do it without constructors.
06:50:51 <mikeplus64> Yuu-chan: like class IntString where whatAmI :: String, and type Foo = forall a. IntString a => a
06:51:23 <ezyang> mikeplus64: Typeclasses are not quite it, because the typeclass gives you an open variant
06:51:26 <quicksilver> Yuu-chan: true subtyping has all kinds of interactions with type inference and substitution properties.
06:52:01 <ezyang> t7: I have no idea (re addition on elliptic curves)
06:53:12 <Yuu-chan> Seems I should read Chapter 15 of TaPL first.
06:53:26 <Yuu-chan> My brains...
06:53:58 <scooty-puff> (masochistic zombie?)
06:54:08 <ezyang> Yuu-chan: While it's OK to skip around chapters in TAPL, you might be better off trying to read them vaguely linearly
06:55:33 <t7> sipa have you got 2 mins to review a small function?
06:55:41 <t7> or anyone else good at math
06:56:40 <scooty-puff> i have reason to want an evalWriterT - this sounds very much like a code problem - though i use listen to read intermediate writes (https://github.com/sonyandy/unify/blob/master/src/Control/Monad/Unify.hs#L208) - i get the feeling i'm not taking advantage of WriterT being a newtype around m (a, w)..
06:59:33 <DMcGill> t7: hpaste it?
06:59:48 <edsko> how can I stop ghc from generalizating a where-bound expression?
07:00:08 <edsko> http://hpaste.org/72687 gives an ambiguity error in the typeRep line
07:00:09 <DMcGill> not that I know anything about elliptic curves
07:00:17 <hpaste> t7 pasted “Not quite working for all inputs” at http://hpaste.org/72688
07:00:19 <scooty-puff> edsko: explicit signature in the where - either where f :: Int -> Int; f x = x; or where f (x :: Int) = x
07:00:34 <edsko> scooty-puff: in order to do that I would need scope type variables
07:00:39 <edsko> *scoped, even
07:00:44 <edsko> was wdonering if it was possible without
07:00:51 <scooty-puff> edsko: and you could end up wanting higher rank types without meaning too
07:00:51 <edsko> it was with order versions of ghc
07:01:21 <ezyang> scooty-puff: I don't know what your question is.
07:01:32 <ezyang> edsko: Which version are you referring to?
07:01:58 <scooty-puff> ezyang: if wanting an evalWriterT is anything to worry about
07:03:07 <DMcGill> t7: two warning flags I've seen, not sure if they're actually causing the problems
07:03:15 <ezyang> scooty-puff: It's hard to tell.
07:03:26 <DMcGill> the x on line 12 is shadowing the x on line 3
07:03:50 <DMcGill> and have you looked into quot/rem vs div/mod? They have slightly different semantics
07:05:15 <scooty-puff> i tried converting to WriterT, runWriterT, and tuple return types, but ended up adding more uses of that than the current uses of listen, evalWriterT - which made me worried i was missing something
07:06:37 <scooty-puff> bah, nm, it sort of makes sense, only at the top level is the writer monoid not required, which cannot be known without undoing one level of looping
07:07:19 <Narcotico> oi
07:07:25 <Narcotico> alguem sabe algum canal
07:07:47 <Narcotico> para pegar sistema da vivo
07:07:50 <EvanR> i dont know if we mentioned no portuguese in the ad
07:07:53 <EvanR> but
07:07:57 <Narcotico> i need
07:07:57 <EvanR> NO PORTUGUESE
07:08:05 <Narcotico> chanel  vivo
07:08:15 <Botje> then /join #vivo
07:08:17 <EvanR> j/k
07:08:19 <Botje> (whatever vivo is)
07:08:35 <Narcotico> from you?
07:09:22 <Botje> what now?
07:09:32 <Botje> what do you mean by 'vivo' ?
07:09:37 <Botje> it's not video in video out, i guess.
07:10:28 <KJChernov> hey. is it always so hard to learn a functional language after using a imperative ones for many years?:(
07:10:48 <tdammers> KJChernov: don't know, I've only done it once
07:10:54 <nand`> depends on how easy it is for you to forget everything you've ever learned
07:11:12 <KJChernov> nand`: :(
07:11:28 <tdammers> nadn`: or rather, let go of concepts your thought were god-given
07:12:07 <EvanR> 10 print "imperative programming "
07:12:10 <EvanR> 20 goto 10
07:12:17 <EvanR> it makes so much sense ;)
07:12:33 <EvanR> OOP is corporate BASIC
07:12:47 <nooodl> KJChernov, anything you're having trouble with specifically?
07:12:57 <paolino> KJChernov, objects are hard to forget
07:12:57 <nand`> http://hackage.haskell.org/packages/archive/BASIC/0.1.5.0/doc/html/Language-BASIC.html
07:13:11 <KJChernov> nooodl: it's just really strange for me, because I have to know what I want to get in a result
07:13:40 <KJChernov> usually, when writing a program on C/C++ I'm just writing the algorithm, no matter whether I know what will I get
07:13:43 <EvanR> KJChernov: maybe think more about your data and the transformations you want, then worry about IO or RNGs or whatever later
07:13:52 <nand`> KJChernov: as opposed to not knowing what you want to do? :P
07:14:07 <Jafet> @faq can Haskell have operational semantics?
07:14:08 <lambdabot> The answer is: Yes! Haskell can do that.
07:14:27 <KJChernov> nand`: well, while writing a program on Haskell u have to know what u want to achieve before writing code
07:14:35 <hpaste> pshr pasted “adding instance declartion liftio” at http://hpaste.org/72689
07:14:45 <nand`> KJChernov: I think the same goes for every language, honestly
07:14:52 <tdammers> KJChernov: just as much as with any other language
07:15:00 <nand`> or do you usually write out code blindly without even knowing what it does? O.o
07:15:04 <Jafet> Haskell is like a box of chocolates
07:15:07 <EvanR> KJChernov: actually i dont know what i want right now and im writing a lot of code
07:15:09 <tdammers> maybe even less, because Haskell makes refactoring astonishingly easy and safe
07:15:14 <EvanR> KJChernov: good thing haskell makes it easy to rewrite the code
07:15:15 <pshr> Hi, I think this is some thing very simple I am getting this error  No instance for (transformers-0.3.0.0:Control.Monad.IO.Class.MonadIO                        [])       arising from a use of `liftIO'     Possible fix:       add an instance declaration for       (transformers-0.3.0.0:Control.Monad.IO.Class.MonadIO [])
07:15:24 <nooodl> i think what KJChernov is saying is, in imperative languages you can start out writing something without worrying about what it'll have to look like when it's finished
07:15:36 <pshr> http://hpaste.org/72689 how do i add the instance declaration ?
07:15:43 <KJChernov> nooodl: yes, you're right:)
07:15:45 <KJChernov> thanks :)
07:15:49 <tdammers> nooodl: you can do the same in a functional idiom
07:15:52 <Jafet> That's not actually true
07:15:53 <nand`> the same goes for haskell
07:15:56 <ezyang> pshr: That's because you can't lift IO actions to the list monad
07:16:06 <mauke> pshr: your type signature is wrong
07:16:13 <nand`> you can write a function at a time. if you get stuck later on, figure out what went wrong, learn from your mistakes, improve on the next try
07:16:25 <tdammers> ^ that.
07:17:31 <pshr> Ok so liftIO is related to the return type ?
07:17:36 <EvanR> i have a very hard time 'just writing' imperative code
07:17:42 <nooodl> implementing something imperatively is like... a progress bar, where you just write a huge thing from start to finish
07:17:57 <EvanR> im afriad of it becoming spaghetti
07:18:02 <nand`> implementing something functionally is like a fibonacci spiral?
07:18:03 <EvanR> so i cant do anything wthiout an extensive plan
07:18:15 <nooodl> whereas in haskell you have to divide your problem into smaller problems, solve those first, then solve the bigger ones
07:18:19 <Jafet> Mmm, spirals
07:18:29 <Botje> pshr: the do block you wrote is suitable for the IO monad, if you drop the liftIO.
07:18:37 <nooodl> the thing is, the latter will feel much more natural when you're used to it
07:18:41 <nand`> works with liftIO too, fwiw
07:18:42 <Botje> pshr: but then your type becomes String -> IO [String]
07:18:52 <Jafet> nooodl: you can also solve the bigger ones first
07:18:54 <Botje> nooodl: really? I write my haskell programs top-down.
07:18:59 <Botje> undefined to the rescue :)
07:19:06 <nooodl> true
07:19:12 <pshr> Botje: is there a way I can get a list of Strings ?
07:19:13 <Jafet> Botje: -XDeferTypeErrors
07:19:36 <Botje> pshr: no. you cannot escape the IO monad.
07:20:03 <Botje> pshr: well, there is unsafePerformIO, but that's really a last-ditch measure.
07:20:25 <nand`> I write them strictly bottom-up; I start with my types and primitive operations on the type, then start embedding them in larger contexts. In other words, I condense/abstract whatever it is I want to model down to a type, without worrying about what the interactive program will work like later on
07:20:35 <tdammers> Botje: I'd say that's not really *escaping* the IO monad, rather cheating another entry into it
07:20:37 <pshr> Thanks Botje
07:21:14 <tdammers> I like to use the iterative approach
07:21:28 <EvanR> to escape the IO monad, use fail
07:21:31 <tdammers> start out with the simplest possible solution, then keep refining it until it's right
07:21:36 <EvanR> > fail
07:21:38 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Base.String -> m a)
07:21:38 <lambdabot>    arising...
07:21:38 <nand`> EvanR: :)
07:21:39 <nooodl> i do the same as nand`. i wonder which approach is the most common
07:22:01 <EvanR> start out with the simplest possible solution, but no simpler
07:22:17 <tdammers> well; if it doesn't work, then the next iteration is to *make* it work
07:22:21 <nand`> as it turns out, Haskell is great for condensing problems down to the simplest possible level
07:22:26 <tdammers> exactly
07:22:42 <tdammers> Haskell is also great for going from a solution that works to a solution that is right
07:23:03 <tdammers> e.g., I might start out modelling my data as tuples, but later on make a proper type
07:23:24 <tdammers> and the compiler will tell me exactly where I have to fix things
07:23:33 <nooodl> (ew, data tuples!)
07:23:40 <EvanR> gross
07:23:44 <tdammers> well; yeah
07:23:52 <EvanR> tdammers: hope you didnt serialize those tuples somewhere ;)
07:24:01 <EvanR> (without safecopy at least)
07:24:04 <tdammers> just an example
07:24:18 <tdammers> by the time serialization becomes an issue, I have long ditched them
07:24:30 <tdammers> or I might restructure my data types completely
07:24:34 <tdammers> same story
07:24:50 <EvanR> for a mud you basically have to think about persistence first
07:25:06 <nand`> these days I start out with simple lenses, then implement the basic bird fold and it just all sprouts out from there
07:25:07 <tdammers> well; yeah, it depends on the project
07:25:30 <nooodl> lenses?
07:25:46 <nand`> nooodl: types isomorphic to a -> (b, b -> a)
07:25:52 <Jafet> I just squint really hard.
07:27:46 <EvanR> update syntax ftw ;)
07:29:18 <nooodl> the fact that i don't know what "isomorphic" means probably means i shouldn't worry about lenses yet...
07:30:07 <Botje> nooodl: getters and setters, basically :)
07:31:19 <edsko> ezyang: hmm. I think I'm wrong. tried it with ghc as far back as 6.12.3 and they all complain :)
07:31:23 <nand`> but also maps, folds and traversals
07:31:49 <ezyang> Well I'm glad to hear that :-)
07:32:38 <ion> nooodl: data User = User { name :: String }; nameLens :: User -> (String, String -> User); nameLens user = (name user, \newName -> user { name = newName })
07:33:08 <edsko> ezyang: in that case the hackage docs for binary-generic are lying :)
07:33:41 <ezyang> What do they say?
07:34:34 <edsko> they complain that it compiles with ghc 6.12 and 7.0 but that code has exactly the same problem that my tiny minimal exmaple demonstrates
07:34:42 <edsko> they *claim
07:35:26 <nooodl> so they return (getter,setter) pairs, used to update fields in data structures?
07:35:41 <ezyang> Hm. Here's a thought: what if you add NoMonoLocalBinds
07:35:44 <Reaga> hitest
07:36:22 <t7> it works :')
07:36:23 <ion> nooodl: Two types being isomorphic means there’s a one-to-one mapping between them. Anything exactly equivalent to that type. There are multiple ways to represent lenses and every one of them can be converted to that representation and back.
07:36:30 <t7> it finally works
07:37:03 <ion> nooodl: They’re often used for fields in data structures, but there can be e.g. a (magnitude,phase) lens to a complex number represented as (real,imaginary).
07:37:37 <dmj> :geekosaur Thanks that worked
07:37:52 <dmj> geekosaur: Thanks that worked
07:38:44 <nooodl> so "types isomorphic to a -> (b, b -> a)" basically means, any type for which you could write a one-to-one mapping from that type to the type of lense you just gave an example of?
07:39:57 <nooodl> (if it sounds like i'm just repeating exactly what you said, i'm just trying to make sure i understand!)
07:39:58 <hpc> nooodl: yes
07:40:04 <hpc> nooodl: and a one-to-one mapping back
07:40:09 <ion> As an example, a lens could be alternatively represented by (a -> b, b -> a -> a).
07:40:29 <hpc> or (a -> b, a -> b -> a)
07:41:22 <hpc> (which makes it a bit more evident how it gets factored into a -> tuple)
07:41:42 <Yuu-chan> Hey guys, I have to hold a small lecture about FP and Haskell in my university, what should I tell neophytes in two hours?
07:41:56 <EvanR> avoid success at all costs
07:42:21 <t7> Yuu-chan: explain lambda calculus
07:42:22 <nooodl> nameLense user = (name, \newName user -> ...) wait, i'm stuck
07:42:28 <nand`> is there anything along the lines of randomRsIO :: Random a => (a, a) -> IO [a] -- ?
07:42:36 <nooodl> (nameLense as a (a -> b, b -> a -> a) lense)
07:42:38 <t7> then simply type -> system F -> Hindley milner -> dependant types -> agda
07:42:50 <t7> you will blow their minds
07:43:13 <EvanR> :t randomRIO
07:43:15 <Yuu-chan> ...and they'll never invite me again.
07:43:15 <lambdabot> forall a. (Random a) => (a, a) -> IO a
07:43:18 <ezyang> Yuu-chan: Is the talk more about FP, or more about Haskell?
07:43:23 <EvanR> nand`: replicateM randomRIO
07:43:31 <ion> yuu-chan: http://youtu.be/b9FagOVqxmI
07:43:38 <typoclass> Yuu-chan: for me the impressive thing about haskell is how damn helpful the compiler is. it's like a regular compiler, and a "lint" tool, and even more stuff all rolled into this thing called "ghc"
07:44:02 <nand`> EvanR: I want it to be an infinite list, with lazy IO
07:44:12 <nand`> I could implement it by hand, but meh
07:44:17 <EvanR> unsafeInterleaveIO
07:44:19 * nand` feels there should be something like this
07:44:30 <EvanR> lazy IO is weird though
07:44:34 <EvanR> its creepy
07:44:44 <ion> nooodl: \newName user -> user { name = newName }
07:45:11 <ion> nooodl: And in that case, nameLens doesn’t take a user parameter.
07:45:50 <nooodl> oh, right, you pass in the user to the setter
07:46:43 <tdammers> typoclass: you have to play into the compiler's hand though
07:46:54 <Yuu-chan> ion: thanks! I'll borrow some moves :)
07:47:26 <typoclass> tdammers: er yeah, sure. if you decide to represent absolutely everything in your program as a String, that wasn't a very clever move
07:47:58 <nand`> EvanR: hmm, I'm trying to implement it using unsafeInterleaveIO but right now it stack overflows whenever the first value of the list gets evaluated
07:48:23 <EvanR> hmm.
07:48:59 <nand`> I've tried unsafeInterleaveIO . sequence . repeat. unsafeInterleaveIO . randomRIO  -- + various other amalgations
07:49:01 <EvanR> ive never done it. i only used IO or pure code for rng
07:49:15 <nand`> wait
07:49:18 <nand`> I'm being extremely silly
07:49:26 <nand`> there's a much easier way to solve what I want
07:49:43 <nand`> randoms <$> getStdGen
07:49:57 <ion> nooodl: Van Laarhoven lenses are cool, but they may take a bit of effort to grasp, especially if you happen not to be that familiar with functors yet. Their benefit is that you can compose them with the default (.) and they allow natural polymorphic updates.
07:50:18 <ion> nooodl: Their type is Functor f => (a -> f a') -> b -> f b'
07:51:03 <ion> nooodl: Let’s ignore the polymorphic part for now.
07:51:05 <EvanR> :t randoms
07:51:06 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
07:51:21 <EvanR> nand`: yeah but i figured you wanted to somehow use IO
07:51:30 <nand`> getStdGen is IO
07:51:41 <EvanR> yeah but you are only using it to seed the generator
07:52:02 <EvanR> your lazy list will be pure
07:52:05 <nand`> exactly
07:52:12 <nand`> but it will still be IO [a]
07:52:28 <EvanR> after you execute the action it will be [a]
07:52:41 <EvanR> or you will get an infinite lazy non io list
07:53:01 <nand`> but every time it executes the result is an entirely different list, since getStdGen updates the system RNG too
07:53:07 <nooodl> ion, which functor would f be in this case? (i assume a and b are still User and String)?
07:53:09 <nand`> so for all intents and purposes there's no difference
07:53:15 <EvanR> nand`: yes but you wouldnt want to do it more than once
07:53:16 <ion> nooodl: userLens :: Functor f => (String -> f String) -> User -> f User; userLens f user = (\newName -> user { name = newName }) <$> f (name user)
07:53:22 <nand`> EvanR: why not?
07:54:03 <ion> nooodl: If you run getConst (userLens Const user) you’ll get her name.
07:54:07 <EvanR> nand`: RNGs arent designed to be reseeded after every couple outputs
07:54:07 <EvanR> nand`: it will basically break the statistical behavior
07:54:41 <Yuu-chan> ion: are they the very same which are entitled in "FP with bananas, lenses and barbed wire" or something like that?
07:54:52 <EvanR> nand`: also... getStdGen wont even reseed will it
07:55:06 <EvanR> it will give you the same state everytime unless you use the random IO functions
07:55:32 <yitz> @type newStdGen
07:55:33 <lambdabot> IO StdGen
07:55:50 <EvanR> youre good as long as you dont use that IO action more than once, if you do, you might as well just use IO completely
07:55:55 <nand`> oh, I was thinking of newStdGen
07:56:01 * hackagebot swish 0.7.0.1 - A semantic web toolkit. (DouglasBurke)
07:56:03 * hackagebot GPipe-Collada 0.1.4 - Load GPipe meshes from Collada files (TobiasBexelius)
07:56:19 <ion> nooodl: \f user -> runIdentity (userLens (Identity . f) user) can modify the user’s name by applying f to it. If f = const "foo" it’s a setter.
07:56:33 <nand`> EvanR: that's the point, the only IO in my code is ‘main’
07:56:54 <EvanR> nand`: so just make one generator once
07:57:04 <ion> yuu-chan: I don’t remember if van Laarhoven lenses were mentioned in it, but i think they’re a newer finding than that paper.
07:57:05 <nand`> yes, which ‘newStdGen’ does
07:57:21 <EvanR> yeah but its not really necessary
07:57:39 <EvanR> getStdGen is enough
07:58:13 <Yuu-chan> ion: I mean the whole concept of lenses.
07:58:44 <Yuu-chan> That title was very cryptic to me before.
07:58:55 <c_wraith> Yuu-chan: no, it's not really the same thing
07:59:25 <ion> nooodl: Now to support polymorphism: data User a = User { name :: a }; userLens :: Functor f -> (a -> a') -> User a -> f (User a'); userLens f user = (\newName -> user { name = newName }) <$> f (name user)
07:59:28 <c_wraith> Yuu-chan: that paper is talking about three basic morphisms
07:59:38 <ion> nooodl: Now you can use the lens to e.g. convert the name from String to Text or back.
07:59:42 <nand`> EvanR: I actually need tuples of random numbers; there seems to be no (Random a, Random b) => Random (a,b) instance; so I was thinking of doing something like join (liftM2 zip) $ randoms <$> newStdGen -- which would end up running newStdGen twice in immediate succession
07:59:49 <Phlogistique> Yuu-chan: no, i
07:59:49 <c_wraith> Yuu-chan: and uses kinda funny names for each, based on how it represents them typographically
07:59:58 <nand`> or should I instead use some form of interleave :: [a] -> [(a,a)]
08:00:06 <EvanR> nand`: i think there is
08:00:07 <Phlogistique> Yuu-chan: oh nevermind
08:00:23 <nand`> EvanR: not in System.Random
08:00:31 <EvanR> :t randomIO :: (Int, Char)
08:00:33 <Yuu-chan> c_wraith: I see, thank you.
08:00:33 <lambdabot>     Couldn't match expected type `(Int, Char)'
08:00:34 <lambdabot>            against inferred type `IO a'
08:00:34 <lambdabot>     In the expression: randomIO :: (Int, Char)
08:00:41 <EvanR> :t randomIO :: IO (Int, Char)
08:00:42 <nand`> if you know of one somewhere I'd be happy to hear
08:00:43 <lambdabot>     No instance for (Random (Int, Char))
08:00:43 <lambdabot>       arising from a use of `randomIO' at <interactive>:1:0-7
08:00:43 <lambdabot>     Possible fix: add an instance declaration for (Random (Int, Char))
08:00:47 <EvanR> >_>
08:01:20 <EvanR> this is preposterous
08:01:28 <nooodl> ion, i haven't heard about getConst/Const and runIdentity/Identity before
08:01:38 <EvanR> nand`: well define one... i could have sworn it existed already
08:02:20 <Yuu-chan> We write paramorphisms by wrapping the relevant constituents in barb ed wire h = [<hb;i>] oh my
08:05:06 <hpaste> nand` pasted “Random (a, b)” at http://hpaste.org/72691
08:05:21 <nand`> Can somebody explain to me like I'm 5 why this doesn't work ^ ?
08:07:15 <nooodl> huh, Identity is just... the simplest monad you could think of
08:07:31 <Taneb> Proxy, I'd say, is similar
08:07:36 <EvanR> its too simple
08:07:36 <Taneb> *simpler
08:08:01 <danil> nand`: local generalization -- you have the MR off
08:08:25 <Saizan> ?type random
08:08:26 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
08:08:51 <nand`> danil: oh, no wonder
08:08:53 <typoclass> nand`: do you have the DMR turned off?
08:09:05 <typoclass> er, i should read before writing
08:09:06 <nand`> I forgot why I had that flag enabled
08:09:38 <Saizan> it shouldn't try to generalize the type of the generator though..
08:10:11 <Saizan> nand`: which version of GHC?
08:10:21 <nand`> Saizan: 7.4.2
08:10:35 <Taneb> EvanR, was that you saying Proxy is too simple, or Identity?
08:10:36 <danil> I get the same thing with 7.4.1
08:10:38 <Taneb> Or both?
08:11:58 <EvanR> for stuff like Identity and Proxy, its hard for people to see what the point is
08:12:14 <EvanR> like people learning haskell
08:12:36 <nooodl> ion, yeah, this is going to take some time to get
08:14:15 <ion> nooodl: Granted, it’s a bit contrived representation (i would have never even thought of it), but its benefits are nice.
08:15:46 <Taneb> EvanR, even I'm not sure what the Proxy Monad instance is for
08:16:03 <Taneb> Why do I say "even I"
08:16:22 <Taneb> I'm not an expert on monads or Proxy
08:16:57 <nooodl> i vaguely see the concept of having a "modifier" function where const makes it a setter, but i really don't understand where the Functor thing comes in
08:17:15 <EvanR> Taneb: even i cant figure out quantum gravity
08:17:16 <nand`> @tell edwardk I once again find myself wanting a State version of ‘adjust’, to make foo >>= (lens ^=) more readable
08:17:17 <lambdabot> Consider it noted.
08:17:18 <EvanR> lol
08:19:29 <nand`> @tell edwardk and by ‘adjust’ I meant ‘set’
08:19:30 <lambdabot> Consider it noted.
08:19:45 <nooodl> i only read the LYAH chapters on functors and applicative functors and monads quite recently, but i really don't know if i understand them for sure
08:20:10 <hpaste> nand` annotated “Functional pong with lenses and gloss (moved time stuff to a Reader)” with “Functional pong with lenses and gloss (factored away random code)” at http://hpaste.org/72619#a72693
08:24:06 <edsko> nand`: I was just struggling with a similar issue
08:24:08 <edsko> did you figure it out?
08:24:10 * edsko is confused
08:24:16 <edsko> (your 'random' example)
08:24:20 <nand`> edsko: yes, I had to drop the -XNoMonomorphismRestriction
08:24:24 <edsko> well, yes, fine
08:24:34 <edsko> but *with* that flag
08:24:39 <edsko> I still don't see why it is ambiguous
08:24:45 <nooodl> man, it's a shame learn you a haskell doesn't come with exercises per chapter
08:25:09 <edsko> random doesn't change the type of the generator
08:25:25 <edsko> so how is it ambiguous?
08:25:34 <danil> edsko: `a` and `b` end up with types like "forall a g. (Random a, RandomGen g) => a"
08:26:10 <eikke> edsko: are slides/paper of your cloud haskell 2.0 talk available somewhere already?
08:26:29 <edsko> eikke: that's months away! :)
08:26:54 <eikke> so? :-P I've been bored lately, looking for more interesting reading material
08:26:59 <Taneb> You two have very similar names
08:27:03 <Taneb> It's confusing
08:27:04 <edsko> so they don't exist yet :)
08:27:11 <eikke> (have to start working on my OUD talk slides myself, so dont worry :P)
08:27:45 <edsko> eikke: the intro to http://hackage.haskell.org/packages/archive/distributed-process/0.2.3.0/doc/html/Control-Distributed-Process-Closure.html will part of the talk
08:28:36 <eikke> ah, thanks, will check, and try to recover the previous paper's details from memory
08:36:34 <whoev> can someone please explain to me what "Just" does
08:36:43 <S11001001> :t Just
08:36:44 <lambdabot> forall a. a -> Maybe a
08:37:01 <whoev> :t Maybe
08:37:02 <lambdabot> Not in scope: data constructor `Maybe'
08:37:05 <whoev> lol
08:37:08 <Yuu-chan> :info Maybe
08:37:08 <whoev> oook
08:37:10 <S11001001> :k Maybe
08:37:11 <lambdabot> * -> *
08:37:16 <zenzike> whoev: Just is a constructor that creates a value of type Maybe
08:37:27 <whoev> and Maybe is
08:37:28 <whoev> ...
08:37:32 <ion> @src Maybe
08:37:32 <lambdabot> data Maybe a = Nothing | Just a
08:37:32 <geekosaur> whoev, Maybe represents an optional value
08:37:40 <whoev> oh
08:37:44 <whoev> so it's like function overloading?
08:37:48 <ion> Not really.
08:37:49 <geekosaur> er?
08:37:50 <danil> no.
08:37:53 <whoev> :/
08:38:11 <nand`> I think whoev is thinking ‘a -> Maybe b -> c -> foo’
08:38:11 <Yuu-chan> whoev: it adds an empty value to any type.
08:38:13 <Taneb> It's like where data may be missing or nonexistant
08:38:29 <S11001001> whoev: as in, "maybe I have a value, maybe I don't"
08:38:39 <whoev> yeah...like function overloading
08:38:46 <EvanR> eh
08:38:47 <EvanR> no
08:38:47 <hsyl20> if you're coming from imperative languages, think of Maybe as a pointer that can either point to something (Just) or be NULL (Nothing)
08:38:51 <nand`> but you're not overloading functions
08:39:02 <whoev> but doesn't it fill the same purpose?
08:39:07 <Taneb> It can do
08:39:11 <Taneb> It can do other things too
08:39:16 <whoev> mmn
08:39:18 <EvanR> if youre coming frmo imperative languages where 'nil' or 'null' is a thing, then ... thing of Nothing as that
08:39:19 <danil> whoev: more often you *return* a Maybe rather than taking one
08:39:26 <danil> > lookup 3 [(1, "one"), (2, "two")]
08:39:27 <lambdabot>   Nothing
08:39:32 <nand`> whoev: example: safeDivide :: Fractional a => a -> a -> Maybe a
08:39:32 <S11001001> :t Just (Just 42) >>= id
08:39:33 <lambdabot> forall t. (Num t) => Maybe t
08:39:39 <danil> > lookup 1 [(1, "one"), (2, "two")]
08:39:40 <lambdabot>   Just "one"
08:39:47 <EvanR> safeDivide is a bad example...
08:39:51 <nand`> you think?
08:40:04 <EvanR> what would you do if you get Nothing
08:40:07 <EvanR> throw an exception?
08:40:13 <typoclass> > lookup 17 [(1, "one"), (2, "two")]
08:40:14 <lambdabot>   Nothing
08:40:16 <EvanR> i think division by zero should be avoided
08:40:16 <nand`> I don't see how that matters
08:40:26 <whoev> :t lookup
08:40:27 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
08:40:36 <nand`> it's not the responsibility of the function to decide on what happens afterwards
08:41:03 <Yuu-chan> EvanR: you can make all arithmetics in the Maybe monad
08:41:27 <caolanm> whoev: haskell doesn't have a 'null', so if, for example, you try "find" on a list the only way to tell you nothing matched is to give "Nothing", if it did match you get "Just value" ... this is useful in other situations too
08:41:43 <Yuu-chan> It's very boilerplate-y, though...
08:41:43 <Twey> donri: Eww infix.
08:41:44 <caolanm> whoev: I'm a beginner, but that was my understanding
08:41:44 <nand`> whoev: the common trend among these examples is that Maybe is being used to represent partial functions
08:41:52 <nand`> that is, functions that may or may not have a well-defined result
08:41:55 <donri> Twey: what'd i do?
08:42:15 <ion> yuu-chan: Unless you create an instance Num a => Num (Maybe a) :-P
08:42:16 <Twey> donri: hascal :þ
08:42:23 <donri> Twey: not mine, just uploaded it for mekeor
08:42:28 <Twey> Ah, okay
08:43:07 <danil> EvanR: generally I agree with you that division by zero is a programmer error (and should be an exception), but if you're going to have to check manually you might as well use safeDivide and do the check in a way that informs the type system.
08:43:07 <Taneb> I'm kinda glad I never understood most of imperative programming
08:43:15 <whoev> i wonder if somebody could show me the use of "Maybe" in a typical context somewhere ?
08:43:24 <Yuu-chan> ion: but you'd still have to lift all operators
08:43:27 <whoev> i'm more than used to dealing with null/nil return values
08:43:38 <whoev> it's just hard for me to envision using "Maybe"
08:43:49 <ion> whoev: This talk contains some nice examples. http://youtu.be/b9FagOVqxmI
08:44:11 <Taneb> whoev, it basically forces you to check for null/nil, and gives you the right to assume that it won't come up outside of Maybe
08:44:11 <EvanR> danil: it doesnt help you avoid division by zero
08:44:12 <donri> whoev: with Maybe you get to communicate in the types if something is nullable, and thus statically avoiding the runtime errors that go with it
08:44:20 <EvanR> danil: and theres better uses for Maybe
08:44:27 <whoev> hmm
08:44:40 <Yuu-chan> whoev: it was shown already. We have a key:value associative array. We try to extract a value by the key. If the key exists, we get Just value. If it doesn't, we get literally Nothing.
08:45:18 <geekosaur> whoev, you might say that Maybe is the null vs. value thing factored out into a standalone entity
08:45:19 <typoclass> whoev: in practice, Maybe (= Just or Nothing) is used quite a bit in haskell. the advantage over "null" is that you can't forget to handle the case, you can't accidentally access it and get a null pointer error at runtime
08:45:20 <EvanR> whoev: imagine by default values CANT be null, and Maybe lets you allow it on a case by case basis
08:45:38 <EvanR> typoclass: and you cant get Nothing when you didnt expect to
08:45:38 <Yuu-chan> (btw, somebody please correct the tenses in my last sentence)
08:46:12 <typoclass> EvanR: right
08:46:13 <danil> EvanR: definitely, there are better examples.  But if you just compare with zero and then divide in one branch the type system isn't going to help you if you test the wrong thing by accident.  (Bob Harper has a blogpost on "Boolean Blindness" about this sort of thing.)
08:46:28 <donri> > (,) <$> lookup "foo" [("bar",1),("foo",2)] <*> lookup 5 [(4,3),(2,1)]
08:46:29 <lambdabot>   Nothing
08:46:41 <EvanR> danil: big if. in numeric code you just shouldnt end up with division by zero
08:46:45 <whoev> hmm...
08:46:50 <Taneb> (Yuu-chan, you were pretty much correct :D)
08:46:50 <EvanR> an if cant save you
08:47:18 <EvanR> its gonna be part of your model
08:47:35 <EvanR> and whatever that is probably cant be moved to the Nothing handler after the division
08:48:07 <dfeuer> I got my toy program to be fast, but now it's also wrong, and I can't for the life of me figure out what I'm messing up.
08:48:46 <donri> correct or fast: choose one!
08:48:50 <typoclass> "Speaking at a conference, Hoare apologized: 'I call it my billion-dollar mistake. It was the invention of the null reference in 1965.'" Maybe is how Haskell fixes the billion-dollar mistake. See http://en.wikipedia.org/wiki/Tony_Hoare
08:48:57 <dfeuer> donri: it's driving me batty.
08:49:15 <Yuu-chan> What a lovely community you have here :3 I'd better have got here when I was writing my diploma...
08:49:28 <EvanR> sql NULL by default, lovely
08:49:36 <SwineFlu> I like the maybe function
08:49:37 <SwineFlu> :)
08:49:41 * typoclass purrs
08:49:42 <EvanR> and mixing up NULL data with NULL result of a outter join
08:50:35 <dfeuer> I like the Maybe, I like the Monad class, I like the Sequence, I like Data.List. I like the type checker when it takes my code. Boom dee-yada bom dee-yada.....
08:50:53 <Reaga> Why isnt haskell used more often! im just getting into it and its just brilliant
08:50:59 <EvanR> i like monadic parser combinators
08:51:10 <donri> i prefer applicative parser combinators ;)
08:51:24 <EvanR> i like fmaps
08:51:27 <Reaga> and why do people use awful languages like php !!!
08:51:30 <matthiasgorgens> Is there an extension for ghc to get or-patterns?
08:51:32 <Reaga> lets promote haskell!
08:51:37 <donri> i like foldable
08:51:48 <matthiasgorgens> Reaga: you are taking away our competetitive advantage!
08:51:54 <matthiasgorgens> -te.
08:51:57 <donri> avoid success at all cost
08:52:07 <dfeuer> Reaga: 1. laziness makes it hard to reason about performance. 2. the type system is too complex for most humans to understand (including me). 3. The syntax is too complicated for GHC even to bother trying to give meaningful error messages. . . .
08:52:18 <Cale> EvanR: heh, there were a bunch of bugs in this Grails app related to the fact that their JSON parser was turning JSON null into a custom null object, rather than Java/JRE null, one which had .toString() give "null" and which had .equals(null) true, but which wasn't considered false in conditionals.
08:52:19 <Yuu-chan> Science, science
08:52:19 <Yuu-chan> It's computer science
08:52:19 <Yuu-chan> Everybody's readin' through the "Learn a Haskell"
08:52:19 <Yuu-chan> Studyin', studyin' (Yeah)
08:52:19 <Yuu-chan> Studyin', studyin' (Yeah)
08:52:19 <Yuu-chan> Fun, fun, fun, fun
08:52:20 <Yuu-chan> Readin' through the "Learn a Haskell"
08:52:21 <matthiasgorgens> dfeuer: the error messages aren't too bad.
08:52:25 <donri> matthiasgorgens: patterns are OR by default? what do you mean
08:52:35 <matthiasgorgens> donri: I want or-patterns like ocaml has them.
08:52:36 <matthiasgorgens> e.g.
08:52:53 <typoclass> matthiasgorgens: i think dfeuer has a point
08:53:01 <matthiasgorgens> f (A a | B a) = g a
08:53:03 <dfeuer> matthiasgorgens: the type checker error messages aren't too bad. The parser error messages are "Parse error line so-and-so" and not much more.
08:53:06 <Reaga> dfeuer: what do you mean laziness
08:53:09 <Yuu-chan> Reaga: I'm trying promote it in my university :)
08:53:12 <Reaga> and what is the type system
08:53:21 <typoclass> > 5 + "5" -- this error doesn't give the type of (+) for example. you just have to know it.
08:53:22 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
08:53:22 <lambdabot>    arising from the literal ...
08:53:28 <matthiasgorgens> dfeuer: yeah, the parser error messages could be better.  but I usually just look for the line number, then.
08:53:31 <dfeuer> I do like Haskell. A lot. But it has its barriers and downsides....
08:53:39 <Reaga> whata re its downsides?
08:53:41 <EvanR> Cale: lol. grails...
08:53:44 <donri> matthiasgorgens: can do that with view patterns i think, but not as pretty
08:53:58 <matthiasgorgens> dfeuer: I agree about the performance aspects being hard to predict.
08:54:14 <matthiasgorgens> donri: yeah.  and we can also just repeat ourselves.  I just want nice syntax. :o)
08:54:17 <Cale> EvanR: Groovy is giving PHP strong competition for worst language :)
08:54:24 <dfeuer> Reaga: since you clearly don't understand the upsides yet, you should probably wait with the downsides :P
08:54:33 <Reaga> dfeuer: what are the downsides tho
08:54:51 <dfeuer> Reaga: in many ways, they are the same as the upsides?
08:54:59 <S11001001> Cale: ?! alarming
08:55:03 <Cale> Honestly, the benefits of nonstrict semantics outweigh the downsides by at least a factor of 10 for me :)
08:55:07 <nand`> I plan on founding a Haskell Club at my university if there turns out not to be one
08:55:07 <matthiasgorgens> Reaga: tool support is limited.
08:55:12 <matthiasgorgens> a debugger would be useful.
08:55:15 <Reaga> i like tools so thats bad
08:55:18 <matthiasgorgens> or a resurrected trater.
08:55:22 <matthiasgorgens> tracer.
08:55:24 <typoclass> Reaga: i guess haskell is like a very good wine ... :) why doesn't the teen on the street drink that? why doesn't everyone every day drink that? well, lots of reasons really ... but still, once you tasted it you probably will have much lower tolerance for bad wine
08:55:34 <Cale> Lazy evaluation is good, but lazy evaluation isn't a precise description of what we have in GHC.
08:55:41 <Reaga> lazy evaluation
08:55:57 <mekeor> why are are there so many haskell-to-javascript compilers?? uhc, ghcjs, haste, fay…
08:56:10 <sipa> because javascript has closures? :)
08:56:11 <matthiasgorgens> mekeor: javascript is a nice target.
08:56:11 <nand`> matthiasgorgens: Debug.Trace :P
08:56:19 <donri> isn't it fun how all the most used libraries use the terms "strict" vs "lazy"
08:56:21 <Cale> mekeor: Because Javascript is the only language which operates in web browsers, and it's not all that great a language.
08:56:21 <matthiasgorgens> nand`: that's not the same at hat used to be.
08:56:22 <nand`> mekeor: because browsers
08:56:37 <matthiasgorgens> mekeor: they are worse languages. :o)
08:56:39 <nand`> matthiasgorgens: what do you mean ‘used to be’? (I'm relatively new to Haskell)
08:56:48 <matthiasgorgens> nand`: look up "hat the haskell tracer"
08:56:58 <Cale> mekeor: and so compiling a reasonably good language to Javascript is attractive
08:56:58 <mekeor> nope. you're all wrong. the right answer is: because javascript sucks and we need javascript. see <http://www.haskell.org/haskellwiki/The_JavaScript_Problem>.
08:57:02 <nand`> oh, I misread ‘hat’ as ‘that’
08:57:05 <matthiasgorgens> nand`: used to be a really cool project, but very academic, and doesn't work with current versions of ghc any longer.
08:57:21 <Cale> mekeor: Isn't that what everyone just said?
08:57:27 <mekeor> okay, that's what Cale said… yeah.
08:57:29 <nand`> mekeor: that's what I said
08:57:29 <mekeor> yeah.
08:57:32 <mekeor> hehe :D
08:57:35 <mekeor> heheheahha :D
08:57:57 <mekeor> but anyway. we don't need 5 of those.
08:58:03 <matthiasgorgens> I recently sat through a talk of that C++ guy (Bjarne S. or so.)
08:58:04 <Yuu-chan> matthiasgorgens: Leksah has some kind of a debugger
08:58:16 <matthiasgorgens> the new features of C++ make them move very slowly in a sensible direction.
08:58:23 <Cale> mekeor: Probably not all of them will be successful, but one or two of them might be.
08:58:31 <Cale> mekeor: It's too early to say which.
08:58:38 <dfeuer> C++ is broken from conception. There is no point in trying to improve it.
08:58:41 <matthiasgorgens> Yuu-chan: haven't used leksah, yet.  might be worth a look.  hat was an interesting concept.
08:58:57 <matthiasgorgens> dfeuer: I wouldn't use C++.
08:59:04 <EvanR> 'C++ done right'
08:59:09 <matthiasgorgens> but the guy was in town, and there was free food before and after the talk.
08:59:21 <dfeuer> EvanR: I've heard that's Objective C....
08:59:21 <Yuu-chan> phyrex1an: All will be one!
08:59:26 <EvanR> dfeuer: java
08:59:28 <EvanR> D
08:59:31 <solrize> what's lazslo?  something taht compiles ml to js or so?
08:59:35 <nand`> EvanR: at that point it wouldn't be C++ anymore
08:59:47 <matthiasgorgens> nand`: and that's would be a happy day.
08:59:50 <matthiasgorgens> -'s.
08:59:57 <Cale> I actually kinda disagree that lazy evaluation makes it hard to reason about performance. It just makes the tools you use to reason about the performance of strict programs largely irrelevant.
08:59:58 <nand`> indeed, but it's like saying Haskell is C++ done right
09:00:01 <EvanR> nand`: the very idea of it is crazy
09:00:14 <EvanR> 'nazi genocide done right'
09:00:16 <EvanR> oh i went there
09:00:19 <nand`> while the only correct approach is to ignore C++ altogether
09:00:40 <Cale> So we need a new bunch of ways to analyse things, and people generally aren't all that good at it yet.
09:00:52 <matthiasgorgens> nand`: I find C programmers mostly pleasant to deal with.  Pragmatic people.
09:00:59 <matthiasgorgens> I am only glad, that I don't have to work with C++ people.
09:01:03 * hackagebot egison-quote 0.1.0 - A quasi quotes for using Egison expression in Haskell code (TakuyaKuwahara)
09:01:04 * Twey laughs.
09:01:11 <mekeor> Cale: i see.
09:01:13 <whoev> oh wow
09:01:16 <whoev> this talk is amazing
09:01:17 <dfeuer> Cale: even Okasaki went with lazified SML rather than strictified Haskell, and he's not exactly a mental lightweight....
09:01:18 <nand`> I tend to like minimalist/pragmatist C programmers too, especially since I'm a lazy/pragmatic person myself
09:01:23 <whoev> haskell is so cool
09:01:36 <matthiasgorgens> whoev: yeah, we know that. :o)
09:01:37 <Twey> Talk?
09:01:52 <whoev> it's so cool to like, handle a function as a data type, so to speak
09:01:56 <Cale> dfeuer: When he was writing his book, Haskell wasn't as well-developed as it is now.
09:02:00 <whoev> a type i guess (???)
09:02:10 <dfeuer> Cale: that's true too.
09:02:12 <Cale> dfeuer: and SML was more popular at that time
09:02:16 <nand`> whoev: (->) is a type, yes
09:02:18 <Twey> Oh, okay.
09:02:27 <dfeuer> And SML has syntax that a human can comprehend.....
09:02:33 <typoclass> dfeuer: objective c is a spitfire from world war ii bolted to a balloon bolted to a bike. it's not an improvement over c++ in any way
09:02:37 <Cale> Humans can comprehend the Haskell syntax
09:03:13 <solrize> :k (->)
09:03:14 <lambdabot> ?? -> ? -> *
09:03:25 <Cale> Haskell's syntax isn't really all that complicated. It's not scheme (but scheme *does* have syntax, don't let people tell you otherwise), but the syntax of Haskell is designed in such a way that it's fairly uniform.
09:03:31 <nand`> I forgot, what do the ?? ? mean here?
09:03:38 <nand`> I remember them being slightly distinct from *
09:03:48 <mekeor> it's GHC internal stuff… that's what i kept in mind.
09:03:53 <Cale> and many parts of the Haskell syntax are just thin layers of sugar over a very small core language
09:03:53 <dfeuer> Reaga: lazy evaluation means that Haskell doesn't (usually) evaluate anything until its result is needed.
09:03:53 <mekeor> :D
09:03:59 <matthiasgorgens> whoev: just wait until you `get' monad-transformers.
09:04:13 <Saizan> nand`: there's some subkinding going on to handle unboxed types and tuples
09:04:20 <typoclass> Cale: agreed. syntax is not the big hurdle for a beginner
09:04:28 <Cale> dfeuer: Are you talking about Haskell-as-standardised, or Haskell-GHC?
09:04:34 <nand`> I thought Haskell syntax was significantly easier to comprehend than, say, C or C++ syntax
09:04:42 <solrize> lazy evaluation is a side effect in a supposedly pure language... memo combinators was sort of an "aha" moment in figuring that out
09:04:44 <Cale> GHC has a lot of syntax extensions
09:04:56 <Cale> and handling all of them can be a bit daunting, I'll admit
09:05:03 <dfeuer> Cale: I find the spacing rules really hard to understand.
09:05:06 <Cale> but the standardised language is not all that complicated syntactically
09:05:11 <matthiasgorgens> I talked with some people using Haskell in computer science classes in school in Berlin Germany at a recent Haskell-get-together in Halle, Germany.
09:05:13 <nand`> dfeuer: you mean the indentation rules?
09:05:16 <matthiasgorgens> They don't mind the syntax.
09:05:22 <dfeuer> Yes, Nand`, that's what I mean.
09:05:41 <c_wraith> dfeuer: they're actually quite easy - you just need to think in terms of alignment, not indentation.
09:05:42 <matthiasgorgens> they said, error messages could be simpler,
09:05:47 <nand`> there are only a few situations in which I mentally disagree with them, personally
09:05:49 <quicksilver> solrize: that is a poor way of expressing it.
09:06:04 <matthiasgorgens> and that libraries are often somewhat elitists and require you to know advanced concepts to know them.
09:06:06 <solrize> using emacs haskell mode and just doing whatever it says seems to take care of indentation at least for me
09:06:11 <nand`> most of the time the indentation works as I'd expect it to
09:06:12 <quicksilver> solrize: it's not "supposedly" pure
09:06:20 <matthiasgorgens> (I even agree with that point, only that clever libraries are a benefit to me.)
09:06:27 <danil> the existence of situations where changing an identifier requires changing indentation makes me sad, but they're contrived enough that I don't think I've seen them in practice
09:06:30 <Cale> dfeuer: Oh, okay. So there are layout keywords: of, where, do, let. After a layout keyword, the first non-whitespace character starts a block, and the block ends at the first line which starts in a shallower column than that.
09:06:39 <matthiasgorgens> nand`: and when the indentation doesn't work, at parentheses until it does.
09:06:40 <quicksilver> you certainly can view thunk update as an effect, or formulate tagged lazines, or similar
09:06:50 <Cale> dfeuer: and that's pretty much all there is to it :)
09:06:55 <whoev> > map reverse $ reverse ["ab","bc","cd"]
09:06:56 <lambdabot>   ["dc","cb","ba"]
09:06:59 <whoev> ah, haha
09:07:01 <whoev> take that, world
09:07:07 <timthelion> If I have a function "putStr :: String -> IO ()" and I want to get a function "putStr :: IO ()" how do I do that?  "putStr \"Foo\"" simply prints Foo, but I didn't want to print foo, I wanted to make a foo printer :(
09:07:09 <nand`> matthiasgorgens: I have to add { } sometimes; generally around multi-line ‘let’ blocks inside ‘do’ blocks
09:07:16 <dfeuer> Reaga: the type system is probably the single most attractive, and least attractive, thing about Haskell. It lets you to do a lot of things with a static type system that you wouldn't think possible if you come from, say, C++.
09:07:18 <matthiasgorgens> > putStr "Take that, World!"
09:07:19 <nand`> since I'd have to indent those farther than I'm comfortable with otherwise
09:07:19 <lambdabot>   <IO ()>
09:07:30 <quicksilver> timthelion: putStr "Foo" is indeed a foo-printer.
09:07:36 <donri> > head $! [0..]  -- why does this work?
09:07:37 <matthiasgorgens> timthelion: what you do mean?
09:07:38 <lambdabot>   0
09:07:41 <quicksilver> timthelion: maybe you got confused by ghci's habit of executing IO actions?
09:07:57 <Saizan> timthelion: let printer = putStr "foo" if you want to refer to it later
09:07:58 <Cale> dfeuer: But if you want to write pretty code, a stronger rule which is a little easier to follow might be better: anything which is a child of something else should start in a later column, and siblings should start in the same column.
09:08:01 <matthiasgorgens> timthelion: f = putStr "foo" gives you a foo-printer.
09:08:06 <nand`> let fooPrinter = putStr "Foo" in replicateM 4 fooPrinter
09:08:10 <nand`> prints “foofoofoofoo”
09:08:11 <matthiasgorgens> let f = putStr "foo" in f >> f >> f
09:08:13 <timthelion> quicksilver: so if I do say "fooPrinter <- putStr \"foo\"" it will bind fooPrinter to a foo printer?
09:08:14 <matthiasgorgens> prints three foos.
09:08:21 <timthelion> ok
09:08:21 <matthiasgorgens> timthelion: no.
09:08:22 <quicksilver> timthelion: no.
09:08:28 <Yuu-chan> donri: it evaluates the expression only to the weak head normal form
09:08:28 <solrize> quicksilver, yes, thunk update is an effect, that's what i mean, something like memotrie is all about arranging when thunk update will happen
09:08:29 <quicksilver> timthelion: if you do that, fooPrinter will be the value ()
09:08:30 <Cale> Oh boy, dfeuer is badmouthing the type system now? :)
09:08:35 <matthiasgorgens> timthelion: let fooPrinter = putStr "foo" will.
09:08:36 <timthelion> ok
09:08:37 <dfeuer> Cale: if you follow that rule, your code tends to fall off the right side of the screen :P
09:08:42 <dfeuer> Cale: no, absolutely not.
09:08:47 <timthelion> ok
09:08:56 <matthiasgorgens> timthelion: Learning about the difference between = and <- will be enlightening.
09:09:06 <nand`> dfeuer: depends on how many gazillion tabs you use for indentation, imo
09:09:14 <nand`> dfeuer: I use 2 spaces, but 4 spaces are popular as well
09:09:17 <donri> Yuu-chan: hm ok i'd have to read up on that
09:09:19 <nand`> dfeuer: with 8 spaces I would go nuts, for example
09:09:19 <Yuu-chan> > head $! [0, undefined]
09:09:21 <lambdabot>   0
09:09:25 <dfeuer> Cale: but you've got to admit most people would need a decent number of years to get from "what's a type system?" to actually understanding Haskell's....
09:09:27 <nand`> Yuu-chan: only forces (:)
09:09:31 <matthiasgorgens> nand`: I don't do indentation.  I do lining up.
09:09:33 <Cale> dfeuer: Not usually -- note that you can also break lines, and even one space is enough to count as being in a later column (though two are nicer)
09:09:38 <nand`> matthiasgorgens: so do I
09:09:43 <timthelion> matthiasgorgens: Ok fine :D "fooPrinter <- return $ putStr \"foo\""
09:09:59 <quicksilver> timthelion: I'm not sure why you would do that :P
09:10:01 <nand`> matthiasgorgens: unless I misunderstood you
09:10:04 <matthiasgorgens> timthelion: yes.
09:10:11 <matthiasgorgens> timthelion: but that's a bit roundabout. :o)
09:10:14 <Cale> dfeuer: Oh, sure. But most people need a decent number of years to learn to program anyway.
09:10:19 <nand`> for example if I have a row of definitions or similar expression's I'll line up the common elements, usually =
09:10:27 <dfeuer> I've read a little about H-M type inference (which I can't say I quite understand), and then Haskell goes and does something much more complex than that....
09:10:27 <nand`> s/'//
09:10:33 <matthiasgorgens> nand`: oh, I meant, I line up the starts.
09:10:52 <matthiasgorgens> dfeuer: though it mostly just works for you as a user.
09:10:54 <Yuu-chan> nand`: forces the contructor and leaves its arguments unevaluated, doesn't it?
09:10:55 <Cale> dfeuer: Honestly, it shouldn't take more than a year to be comfortable enough with Haskell's type system to pick up any straggling details you might have missed as you go.
09:10:57 <nand`> matthiasgorgens: I'm not sure how that differs from indentation
09:11:01 <nand`> Yuu-chan: yes
09:11:02 <timthelion> matthiasgorgens: You'd have to admit, that it's not obvious as expressed by the syntax...
09:11:13 <dfeuer> Aaaanyway.
09:11:16 <dfeuer> I must to go.
09:11:21 <Cale> dfeuer: But Haskell *is* different from other languages, and you can't expect to pick it up in a week and be comfortable
09:11:29 <Cale> I don't think that's a downside, but some people might.
09:11:31 <nand`> Yuu-chan: in fact, ‘head‘ does the same; so it's redundant
09:11:44 <matthiasgorgens> timthelion: what do you mean?
09:11:59 <matthiasgorgens> nand`: I'll paste a code example.
09:12:19 <nand`> Cale: but you can be comfortable before you pick it up
09:12:20 <hpaste> “Matthias Goergens” pasted “Line up” at http://hpaste.org/72694
09:12:25 <nand`> Cale: I remember being comfortable in Haskell from the get-go
09:12:31 <timthelion> matthiasgorgens: for example main :: IO () ; main = putStr "foo" does not make main into a foo printer, in any clear sense.  It prints foo :O  The way haskell takes a fooPrinter and prints foo if that foo printer happens to be named main, obscures things a tiny bit...
09:12:33 <nand`> just from the LYAH examples
09:12:35 <matthiasgorgens> nand`: please see that paste for an example.
09:12:45 <quicksilver> timthelion: no, you are wrong.
09:12:57 <quicksilver> timthelion: main = putStr "foo" *precisely* makes main into a foo printer.
09:12:58 <nand`> matthiasgorgens: oh, I see what you mean; I do that too but I handle it differently
09:13:18 <matthiasgorgens> nand`: of course, I still do indentation for block stuff, like do-blocks.
09:13:27 <hpaste> nand` annotated “Line up” with “Line up (annotation)” at http://hpaste.org/72694#a72696
09:13:31 <Cale> nand`: Honestly, I think it was about a year before I could really say I was "comfortable", but there were definitely things that I liked about Haskell right from the start, sure.
09:13:33 <nand`> matthiasgorgens: this is how the code would have looked if I had written it
09:13:35 <matthiasgorgens> nand`: but most of the time, it's not indentation, but that kind of lining up, and you even mix it.
09:13:49 <dfeuer> Cale: I think a lot of things about Haskell are awesome. It can easily do a ton of things that the more mainstream languages can't do at all. But it's not always easy. And there are some annoying issues, like the fact that instances can't be shadowed.
09:13:53 <matthiasgorgens> nand`: I do what you do, if I don't have enough columns left.
09:14:00 <Cale> and the type system wasn't really a big hurdle -- its notation was so similar to what I expected from mathematics that it didn't get in my way.
09:14:19 <Cale> dfeuer: Instances *shouldn't* be shadowed
09:14:30 <nand`> matthiasgorgens: oh, except if I had written it I would have lined up the :: too
09:14:31 <Cale> dfeuer: I will argue against any proposal which allows that.
09:14:36 <Yuu-chan> So how much time is needed to learn Haskell to a decent level?
09:15:00 <EvanR> Yuu-chan: depends on how much code you are going to read and write
09:15:02 <dfeuer> Cale: which makes them unsuitable for certain purposes, when the module system isn't powerful enough to take over....
09:15:11 <Cale> Yuu-chan: It's different for everyone, and knowing lots of imperative programming languages is more likely a hindrance than helpful.
09:15:14 <roconnor> Yuu-chan: depends on how much prior programming experience you have
09:15:26 <Cale> dfeuer: Use records :)
09:15:37 <dfeuer> I must be behind the times. Records?
09:15:42 <matthiasgorgens> nand`: I'm undecided about lining up the :: und other stuff in a line, as opposed to the starts.
09:15:42 <EvanR> dfeuer: using typeclasses for the wrong thing
09:15:57 <timthelion> Yuu-chan: It depends on what a decent level is.  I have written a relatively complex application in haskell, yet I am here asking how to make a foo printer.
09:15:59 <Cale> dfeuer: Just plain single-constructor algebraic datatypes
09:16:12 <danil> Cale: how do you feel about Agda instance arguments?
09:16:14 <Yuu-chan> I wonder if there are people who had Haskell their first language
09:16:15 <Cale> dfeuer: Typeclasses compile into dictionary passing anyway
09:16:15 <nand`> matthiasgorgens: oh, I would have } on an extra line too
09:16:21 <whoev> i implented RSA in haskell, and i still have no idea what i'm doing
09:16:25 <Philippa> Yuu-chan: yep
09:16:26 <timthelion> Yuu-chan: there are a few
09:16:26 <EvanR> timthelion: putStrLn "foo"
09:16:27 <matthiasgorgens> Yuu-chan: there are.
09:16:34 <Philippa> (not me, but I've done it to people :p)
09:16:37 <timthelion> EvanR: already got that answer :)
09:16:39 <Yuu-chan> Show me them!
09:16:41 <Cale> dfeuer: and so if you need more than one instance of your class for a given type, you should be explicitly dictionary passing, typeclasses are only going to get in your way
09:16:44 <matthiasgorgens> nand`: I even put the } on the same line in my C code. :o)
09:16:57 <matthiasgorgens> nand`: just to annoy those C-coders, and save a line.
09:17:00 <Cale> People forget that good ol' functional programming is good.
09:17:03 <EvanR> timthelion: and 'how to make something into a foo printer' sounds weird
09:17:04 <Philippa> there's at least one chan regular who's tried teaching it to school kids and got on well
09:17:23 <timthelion> EvanR: it's exactly what I need though
09:17:27 <matthiasgorgens> whoev: implementing RSA isn't a decent test of a language.  I can implement RSA in common lisp or even c++ just fine.  I can't really program in those languages, though.
09:17:35 <EvanR> timthelion: you mean define one? or use one
09:17:38 <Philippa> Cale: people forget that letting good ol' FP double for value-level type proxies is also good :p
09:17:42 <nand`> matthiasgorgens: I do that in C, because they're all over hte place
09:17:45 <Philippa> (but yes)
09:17:50 <Philippa> that or newtype like a mofo
09:17:50 <matthiasgorgens> timthelion: once you get the foo-printer stuff, you'll be able to do some interesting things.
09:18:05 <Cale> Yeah, newtypes can also solve things in a sensible way
09:18:15 <nand`> matthiasgorgens: but in Haskell I prefer the whole ‘being able to add and remove lines seamlessly’ benefits for {,} and [,] -style notations
09:18:24 <Cale> If you look at how QuickCheck uses newtypes, it's even really elegant.
09:18:43 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.5/doc/html/Test-QuickCheck-Modifiers.html
09:18:44 <EvanR> nand`: which ive tried to use in other languages, and im curious how often it fails
09:18:45 <timthelion> EvanR: I have a big data structure data EveryThingInMyApplication = Stuff {stuff :: Types,exit::IO()} and I need to be able to set that exit record to an IO () with no parameters..
09:18:46 <nand`> (from the end, at any rate - it's still nontrivial to add or remove a line to the beginning)
09:19:05 <Phlogistique> whivh brins up the question: Why the hell aren't trailing commas in records permitted in Haskell?
09:19:10 <Phlogistique> *which
09:19:10 <whoev> matthiasgorgens: took a little know-how
09:19:11 <EvanR> timthelion: ... exit = myExit
09:19:14 <nooodl> hey, what's a good example of a type that's not in Eq?
09:19:21 <Cale> nooodl: Int -> Int
09:19:24 <Phlogistique> It's super-useful in C
09:19:26 <matthiasgorgens> nand`: I don't really care about that.
09:19:28 <nand`> timthelion: in my experience the whole ‘noun-verber’ concepts are superfluous in Haskell
09:19:29 <Reaga> whatever
09:19:31 <matthiasgorgens> nand`: though I used to.
09:19:31 <Reaga> i like haskell
09:19:34 <Reaga> what about standard ml
09:19:37 <Cale> nooodl: Or better: Integer -> Bool
09:19:38 <Yuu-chan> nooodl: (->)
09:19:39 <timthelion> matthiasgorgens: I already knew how to do it, for IO functions that where going to have arguments left over(like using mapM) but I didn't know it was that easy if you ended up running out of arguments...
09:19:43 <EvanR> noun verber sounds like OOP
09:19:50 <EvanR> 'function applicator object'
09:19:57 <nand`> timthelion: and relics of impure or strict programming strategies
09:19:58 <typoclass> Phlogistique: i'm in favor of leading and trailing commas, also in lists
09:20:00 <matthiasgorgens> nooodl: functions aren't comparable.
09:20:00 <nooodl> Cale, why "better"
09:20:01 <dfeuer> Why am I still here?
09:20:13 <Phlogistique> typoclass: yes, in lists too
09:20:24 <timthelion> nand`: how would you name a value IO () which prints foo, other than a foo printer?
09:20:28 <Cale> nooodl: Because Int -> Int has theoretically finite-time comparison
09:20:35 <EvanR> timthelion: printFoo
09:20:35 <Phlogistique> I understand that in tuples it could collide with sections though
09:20:40 <lambdas> matthiasgorgens: Functions over finite sets could be, damn them.
09:20:46 <Yuu-chan> nooodl: Int -> Int can be 'compared' due to the extensional equality
09:20:49 <nand`> timthelion: I would name it printFoo too
09:20:50 <Cale> nooodl: But comparing Integer -> Bool functions for equality is uncomputable.
09:21:13 <matthiasgorgens> Cale: not really, since Int -> Int doesn't have to be total in haskell.
09:21:15 * timthelion doesn't see anything wrong with "fooPrinter"
09:21:15 <danil> Cale: only total Int -> Int functions are comparable
09:21:15 <EvanR> new FooPrinter.doWhatItsNameSays()
09:21:34 <Cale> danil: Sure, but we usually don't expect (==) to operate on partial values anyway
09:21:38 <nooodl> woah, what, uh
09:21:48 <nand`> I tend to not think of IO actions as ‘something that does something’, I think of them as abstract definitions for how to do something
09:21:51 <timthelion> EvanR: Honestly, there's nothing *wrong* with good OO, it's not like other forms of mutability.
09:21:52 <nooodl> so if you had a function that takes an int and returns a bool you wouldn't be able to compare it
09:22:01 <matthiasgorgens> nooodl: know that saying about hornet's nests?
09:22:03 <Cale> nooodl: Takes an *integer*
09:22:10 <Cale> Integer is unbounded
09:22:26 <nooodl> oh, right
09:22:26 <Cale> > product [1..1000] :: Integer
09:22:28 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
09:22:32 <Cale> > product [1..1000] :: Int
09:22:34 <danil> Cale: that's true.  I don't usually think of nonterminating functions as like partially-defined structures, but I guess I should--it's the elimination forms that cause problems in both cases.
09:22:34 <lambdabot>   0
09:22:46 <EvanR> timthelion: its not a good idea to replace all command names with 'commandDoer.doCommand'
09:22:46 <Yuu-chan> Hey, why 0?
09:22:55 <Cale> Yuu-chan: because there are enough factors of 2
09:23:02 <Yuu-chan> Oh... yes.
09:23:03 <EvanR> putStrLn -> stringLinePutter
09:23:06 <quicksilver> Cale: also, there is the neat stuff like http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
09:23:16 <nooodl> ohh. i thought you were saying "Integer -> Integer" first, sorry
09:23:23 <Yuu-chan> > product [1, 3 .. 1000]
09:23:24 <lambdabot>   100748329763750854004038917392303538250323418583550415705013777513334847930...
09:23:27 <Yuu-chan> > product [1, 3 .. 1000] :: Int
09:23:28 <lambdabot>   4304323484908249161
09:23:29 <timthelion> EvanR: It's better than simply having hidden global variables(which even haskell suffers from, in the domain of gtk2hs and openGL bindings :( )
09:23:32 <covi> Are the sequences of left arrow and right arrow ^[[D and ^[[C?
09:23:32 <Cale> quicksilver: Indeed, I was debating on whether to bring that up :)
09:23:40 <covi> Wrong channel... sorry
09:23:44 <EvanR> timthelion: ... eh?
09:23:48 <nand`> Integer -> Integer isn't in Eq either
09:23:59 <Cale> nooodl: Regardless, Int -> Int doesn't have an Eq instance by default
09:24:00 <timthelion> EvanR: have you ever tried having TWO openGL windows open in the same haskell program ???
09:24:03 <Philippa> timthelion: tbh, I'd ask why it's a separate IO action rather than a prettyprinter for foos (which I might call a printer for foo, or printFoo or showFoo) and then the bog standard IO
09:24:18 <EvanR> timthelion: opengl has nothing to do with windows
09:24:21 <nooodl> (covi: yeah, they are :))
09:24:25 <nand`> I think any Eq (Int -> Int) instance would require longer than the lifetime of the universe to actually terminate on current processors
09:24:27 <nand`> something like that
09:24:38 <danil> timthelion: for an extreme example, you probably don't want to call "get" for MonadState "stateGetter", though it's a monadic value rather than a function
09:24:40 <Philippa> EvanR: you're correct, but you could be a little more useful about it
09:24:45 <Cale> nand`: Depends on the underlying architecture (the size of Int) :)
09:24:51 <timthelion> EvanR: it does when you're using glut
09:24:55 <levi> For me, the difficult thing about learning Haskell beyond the beginning level is the fact that people are always coming up with great new fundamental abstractions that you can use for the basis of your programs, so it's hard to tell exactly which abstractions you should be learning and using beyond the Prelude stuff.
09:24:57 <EvanR> dont use glut
09:24:59 <nand`> Cale: well, Haskell standardizes a minimum range for it
09:25:03 <Yuu-chan> Cale: is it possible to define something like instance (Bounded a, Eq b) => Eq (a -> b)?
09:25:05 <nand`> so I'm not sure if that's small enough
09:25:12 <Cale> nand`: The minimum range is small enough to search in a reasonable time :)
09:25:15 <nand`> I see
09:25:21 <Cale> and even 2^32 is
09:25:29 <Cale> But 2^64 is not
09:25:32 <nooodl> > maxBound :: Int
09:25:34 <lambdabot>   9223372036854775807
09:25:41 <latro`a> is bounded sufficient? I'm not sure bounded means enumerable
09:25:45 <timthelion> EvanR: there are not other options that are better.  gtk2hs has the same design flaw, unfortunately
09:26:05 * hackagebot hascal 1.3 - A minimal, extensible and precise calculator (MekeorMelire)
09:26:07 * EvanR starts reading the glfw docs
09:26:16 <nand`> latro`a: Enum a states that if a is also Bounded the enumerations have to stop somewhere
09:26:16 <Cale> Yuu-chan: You'll also want an instance of some class which lets you enumerate the values in the range. People have used Enum for this, though that's not really what Enum is quite for.
09:26:19 <nand`> not sure if that's what you asked
09:26:21 <typoclass> levi: interesting. what are example for those new abstractions?
09:26:31 <Cale> (though it can stand in okay for that)
09:26:41 <Yuu-chan> Cale: but what is it for?
09:26:41 <nand`> typoclass: like lenses!
09:26:42 <latro`a> I meant in the context of (Bounded a, Eq b) => Eq (a->b)
09:26:44 <Philippa> levi: Monoid, Monad and Applicative are standing the test of time, and mtl&relatives are going to be notable for a long time yet
09:26:56 <latro`a> which would obviously be "iterate through all the a's and compare the output at b"
09:26:59 <levi> I mean, should I be writing things as Applicatives? Arrows? Should I be using Lenses?
09:27:00 <Cale> Enum is for defining the [a..], [a..b], [a,b..] and [a,b..c] syntaxes
09:27:17 <nand`> latro`a: no, it would have to be (Bounded a, Enum a, Eq b) => Eq (a -> b)
09:27:23 <Philippa> lenses're newer and something I need to start using - I think for me they start to mark the stage where Haskell is (admittedly rather more gracefully) turning into a C++-class cruftball? But that's a bit unkind to Haskell
09:27:24 <quicksilver> enumeratees, conduits, and pipes spring to mind as "new" abstractions
09:27:25 <Cale> and some instances of it will "skip" values which are in a range
09:27:25 <latro`a> that was what I was saying, yeah
09:27:43 <Philippa> Arrows are mostly forgettable right now
09:27:59 <Philippa> (if you run into an EDSL worth learning them for, you'll know about it)
09:28:01 * nand` has never seriously used arrows other than (->) and Kleisli
09:28:16 <EvanR> timthelion: looks like glfw doesnt support more than one window either. but now im confused about how this gripe relates to you renaming IO commands
09:28:17 <Yuu-chan> levi: Indeed! I once came up with "People, I can write in Haskell! I use monads, woo! Er... arrows? FRP? Lenses? Conduit? Mommy, get me out of here"
09:28:41 <Ramya> hi
09:28:42 <Eduard_Munteanu> I've only encountered them in HXT.
09:28:48 * typoclass naively uses (&&&) and sometimes (***). the rest of Arrow gives him the willies
09:28:49 <Philippa> *nod*. I don't use FRP. I'm not doing anything with continuously varying values, so no reason to
09:28:50 <timthelion> EvanR: it has nothing to do with it. I was just trying to point out that OO is actually a good thing, that haskellers have derided wrongly.
09:28:54 <Yuu-chan> Ramya: Hello :)
09:29:03 <nand`> levi: you should clearly be using applicative lenses that are instances of Arrow
09:29:06 <quicksilver> timthelion: it's really not, though :)
09:29:07 <EvanR> timthelion: this library problem has nothing to do with haskell or oop
09:29:10 <Philippa> likewise I'm not doing 'serious' IO so I still use String all over the place even
09:29:22 <EvanR> timthelion: plenty of libs export a context or use a monad or whatever
09:29:36 <nand`> typoclass: I use ‘first’ and ‘second’ on occasion too
09:29:40 <timthelion> EvanR: how can you do the correct behavior without OOP?  Unless haskellers have a better Idea, they should stick with OOP
09:29:52 <EvanR> its like saying you need oop because some lib has a hidden list instead of taking a list as an argument
09:29:53 <typoclass> nand`: right, of course. those are nice as well
09:30:00 <levi> Well, the problem is, there's a lot of background stuff to learn in order to even understand what these things are before deciding whether or not to go forward in learning them.  I am learning a lot, but not writing much code. :)
09:30:01 <nand`> typoclass: when particularly cartesianally inclined
09:30:01 <Philippa> finding out which "non-domain" abstractions are worthwhile is the hard part, the rest come to you as you ask what's useful for a given problem
09:30:31 <EvanR> timthelion: please calm down, haskell has plenty of IO handles and stuff passing around just fine
09:30:34 <Philippa> levi: you can always write code then say "hey, I'm building a ball of mud shaped like this, what might be relevant abstractions?"
09:30:44 <timthelion> EvanR: well, they should at least pass that list out in the open(which *might* be just as good as OOP)  the current model, used in all gui libs I've seen is flawed.
09:31:11 <timthelion> EvanR: :) :)  Don't worry, I'm not really that upset.  Just trying to make a point.
09:31:12 <Cale> timthelion: I would argue that most people don't have a great idea of what OOP is about, especially people who have only programmed in Modula-3 derived languages.
09:31:31 <Philippa> Cale: *snerk*
09:31:33 * timthelion googles Modula-3
09:31:44 <levi> Was anything derived from Modula-3?
09:31:52 <EvanR> timthelion: guis are hard. guis are traditionally the only really sensible use for oop. and theres nice work in declarative gui stuff now, frp
09:32:21 <nooodl> it "influenced" other languages according to wikipedia
09:32:23 <teneen> Why doesn't "catch" from Control.Expception work properly in ghci?
09:32:34 <EvanR> timthelion: hiding crunch IO crap in a partially applied expression sounds great to me
09:32:35 <Philippa> EvanR: it's worth distinguishing OOP from OOM though, and OOP in the large makes more sense than OOP in the small
09:32:38 <EvanR> crunchy*
09:32:48 <timthelion> EvanR: I don't like OOP for string handling(like in java,c#) but for "dynamic environments"(gui's, but also web servervices, and other things that can hold those properties) OOP is usefull
09:33:20 <EvanR> well when its a webservice i daresay thats not even OOP
09:33:28 <EvanR> back to 'what is oop'
09:33:38 <matthiasgorgens> Philippa: OOM?
09:33:42 <Philippa> Modelling
09:33:55 <Cale> That "Influenced" list should probably include a few more languages
09:34:12 <Philippa> you can meaningfully talk about OO systems where some of the objects are humans, for example
09:34:15 <matthiasgorgens> as long as your oop doesn't introduce unnecessary state, that's fine.
09:34:24 <Cale> I mean all the "OOP" languages which tie method implementations to type definitions.
09:34:25 <matthiasgorgens> (e.g. python's strings are objects, but they are still immutable.)
09:34:30 <timthelion> EvanR: I looked at FRP, but since nothing of any note was written in it, I had a hard time judging it's usefullness.  The libraries for it are all greek to me :'(
09:34:43 <EvanR> timthelion: well there was that 3d shooter
09:34:49 <EvanR> not sure what it used
09:34:52 <Cale> Which results in a very awkward style of OOP.
09:34:54 <lambdas> Fran.
09:34:54 <Yuu-chan> Frag?
09:34:58 <timthelion> Frag
09:35:12 <Philippa> Frag doesn't really tackle any of the 'scaling' issues in such things
09:35:33 * nand` gets excited by projects like haskell-arcade
09:35:38 <matthiasgorgens> Cale: multiple dispatch makes oop more useful, I believe.
09:35:39 <Philippa> the game aspect is considerably simpler than Quake 1, and in many regards simpler than Doom
09:36:05 * hackagebot openpgp 0.4 - Implementation of the OpenPGP message format (StephenWeber)
09:36:05 <Cale> matthiasgorgens: That's not even what I'm talking about
09:36:06 <Yuu-chan> I think that the only difference between traditional OOP and Haskell type stystem is the subtyping.
09:36:15 <Philippa> (which is to be expected: it's nowhere near the same size of project as either game!)
09:36:22 <Cale> matthiasgorgens: I'm talking about class declarations containing implementations of methods.
09:36:27 <Philippa> Yuu-chan: there's more than one OO tradition
09:36:38 <Philippa> one of them isn't very fond of static typing
09:36:38 <Cale> matthiasgorgens: The implementations of methods should be part of the *object*, not part of the interface.
09:36:58 <Philippa> (and has a strong historical claim to 'traditional', if not 'mainstream')
09:37:03 <Yuu-chan> That "Incapsulation, inheritance, polymorphism" motto
09:37:12 <Cale> A class is a type -- it should only specify what methods there are and what types they have.
09:37:18 <EvanR> Yuu-chan: these things arent really oop things
09:37:20 <Philippa> yeah, except inheritance wasn't originally a type thing
09:37:34 <lambdas> Alan Kay claims to have invented the term, and I guess doesn't think much of typing.
09:37:38 <teneen> Why doesn't "catch" from Control.Expception work properly in ghci?
09:37:39 <monochrom> is "incapsulation" the opposite of "encapsulation"? :)
09:37:54 <Philippa> that'd be excapsulation, no?
09:37:58 <timthelion> teneen: it does, I tested it yesturday :)
09:37:58 <Cale> inheritance is also a giant red herring imo
09:38:05 <Philippa> ...*makes note for future blog post*
09:38:12 <Yuu-chan> My bad :-[
09:38:13 <EvanR> implementation inheritance is a death trap
09:38:16 <timthelion> teneen: what are you feeding ghci, and how is it failing?
09:38:17 <monochrom> anyway, haskell has encapsulation and polymorphism
09:38:30 <Philippa> Yuu-chan: no worries? The mainstream presentation of OO is, er, rather dominant
09:38:50 <monochrom> there is some conflict between encapsulation and inheritance
09:38:51 <timthelion> Cale: doesn't haskell support inheritance?  You can be an intance of multple type classes.
09:39:02 <teneen> timthelion: (return $ safeDiv 9 0) `C.catch` \(e::C.ArithException) -> print "fail"
09:39:15 <Cale> timthelion: no?
09:39:22 <Yuu-chan> I meant "_i_ncapsulation", that's a result of a Russian heritage
09:39:30 <teneen> timthelion: (return $ safeDiv 9 0) `C.catch` \(e::C.ArithException) -> print "fail" >> return 1
09:39:30 <Cale> timthelion: type classes have nothing to do with OO classes
09:39:38 <EvanR> you can be an instance of multiple type classes, true
09:39:40 <Cale> timthelion: and that's not what inheritance is about
09:39:55 <nand`> Cale: you said the implementations of methods should be part of the object. do you mean something like data Foo = Foo { frob :: Int -> Foo, bar :: Bat -> Foo; baz :: Foo } -- ?
09:40:11 <levi> Philippa: Simula-style OO predates and was an inspiration to Smalltal-style OO, but it actually worked more like C++ and family. So, the term 'Object-oriented' historically belongs to Smalltalk-style languages, but the common ancestor is more like what's popularly called OO these days.
09:40:12 <EvanR> seems more often than not inheritance is used to simulate modules now
09:40:21 <nand`> or perhaps even frob :: Int -> IO Foo
09:40:23 <Cale> Inheritance is where subclasses automatically get method implementations from the parent classes
09:40:32 <Yuu-chan> Instancing of multiple type classes is more like as implementing of multiple interfaces
09:40:40 <Cale> nand`: Quite a bit like that, yes :)
09:41:07 <levi> Type classes are most like the OO concept of 'traits', AFAICT.
09:41:13 <timthelion> teneen: looking now, moment
09:41:18 <Cale> I honestly think that Haskell can be a better OO language than many languages which were "designed" to do OO.
09:41:41 <Cale> Most if not all of the typed OO languages, anyway.
09:41:41 * nand` ponders using lenses for modelling inheritence
09:41:48 <teneen> timthelion: thanks tyt
09:41:52 <Yuu-chan> Then why they did O'Haskell stuff?
09:42:15 <danil> Cale: I believe it, though http://lambda-the-ultimate.org/node/4569#comment-71821 needs just a spoonful more sugar
09:42:41 <eikke> Yuu-chan: to justify a PhD grant? :-P
09:42:43 <Cale> O'Haskell and Timber basically were an attempt at adding subtyping to Haskell.
09:43:09 <monochrom> well, extensible record is certainly interesting and handy
09:43:11 <nand`> “fix dog” <- that sounds.. wrong
09:43:30 <levi> The idea of traits was to be able to compose behaviors.  Each trait would have a set of a 'provides' and 'requires', where the 'requires' were abstract methods that had to be implemented by the concrete inheritor of the trait and 'provides' were implemented in terms of the 'requires'.
09:43:33 <danil> nand`: yeah, he should have defined "new" as "fix"
09:44:17 <monochrom> "fix dawg! we put fix in fix so you can fix dawg while you fix dawg"? :)
09:44:19 <Cale> danil: All he has to do is do away with the explicit recursion with fix, and don't bother attempting to model inheritance, and it'll be pretty
09:44:34 <levi> There was some more complication in the way that you'd resolve the composition of the sets of 'provides' and 'requires', including ways to resolve naming conflicts, but that was the basic idea.
09:44:53 <EvanR> liskov substitution principle
09:44:55 <danil> Cale: farther up the thread there's a simple version without the open recursion or inheritance
09:45:21 <monochrom> @quote monochrom substitu
09:45:21 <lambdabot> monochrom says: Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.
09:45:32 <eikke> levi: no need to use past tense => scala uses traits intensively, and some python stdlib modules as well
09:45:33 <Cale> Inheritance is silly anyway, it causes all kinds of obnoxious bugs where people think they can get away with inheriting things where they can't, and the program runs and does something incorrect.
09:45:48 <Cale> I dunno. Maybe I'm biased.
09:45:50 <monochrom> that is the principle in reality
09:46:11 <nand`> monochrom: that's a good way to explain fix
09:46:15 <nand`> :)
09:46:16 <monochrom> haha
09:46:51 <nand`> Cale: I agree, but that might just mean we're both biased
09:46:59 <covi> I got an ghc: could not execute: /usr/bin/clang error and I'm under Mac. It seems that clang is not in /usr/bin, what should I do?
09:47:10 <timthelion> teneen: Go here http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html and search for "Mismatched" the next paragraph explains how to do what you want.
09:47:21 <levi> eikke: Well, I am fairly sure that the traits in Python and Scala are a little bit different than when they were initially introduced, but yeah.
09:47:23 <hpc> covi: you have clang though, yes?
09:47:44 <hpc> if so, the horrible way to fix it is just symlink
09:48:16 <covi> hpc: I don't know if I had it
09:48:25 <companion_cube> traits in python?
09:48:26 <monochrom> all the talk about encapsulation is hot air because internal doc and API doc suck so much that programmers routinely look at callee source code. no more encapsulation
09:48:30 <nand`> then install clang, I guess. On a side note, why does ghc need clang?
09:48:52 <covi> nand`: idk I just runhaskell A_SIMPLE_SCRIPT
09:49:02 <hpc> nand`: llvm?
09:49:19 <Botje> covi: does the script contain /usr/bin/clang, by chance?
09:49:20 <hpc> fwiw, i have a working ghc, but no clang
09:49:27 <monochrom> it is so bad to the point that programmers actually demand callee source code unconditionally
09:49:31 <covi> Botje: contain?
09:49:41 <nand`> monochrom: that's one thing I like about Haskell; since you have no semantics other than what your API defines a good haddock tends to be sufficient
09:49:48 <eikke> companion_cube: mixins
09:50:15 * companion_cube keeps away from magical python OO
09:50:28 <monochrom> yes, and it is so bad that when programmers come to haskell, they demand source code even when the haddock happens to be superb
09:50:31 <levi> monochrom: Just because you look at the internal code doesn't mean the goals of encapsulation have entirely failed.  The author can still change the internal implementation of an encapsulated interface without breaking external code as long as it behaves the same, while exposing the internal code makes that impossible.
09:50:46 <typoclass> nand`: where is this "good haddock" you speak of?
09:50:54 <companion_cube> sometimes the haddock is not enough to know what the function does, though
09:51:03 <levi> eikke: mixins are not quite the same as traits, though.
09:51:27 <whoev> can somebody link me to some decent haskell benchmarks (GHC)?
09:51:29 <levi> At least in the sense in which traits were originally developed.
09:51:34 <adnam> covi: in Xcode > Preferences > Downloads you need to install the cmd line tools
09:51:59 <nand`> typoclass: I'm not sure what you mean
09:52:53 <nand`> companion_cube: unfortunately you can always document poorly
09:53:11 <typoclass> nand`: i was kidding :) from my experience (which is not too much) you usually need to look at a module's source code. often you can guess something from the types, but other than that, i find most haddock pages incomprehensible
09:53:23 <covi> adnam: thanks! I will see if this fixes the problem.
09:53:29 <nand`> (on a related note, I sometimes have to look at the source code for instance declarations, since they tend to be undocumented; just a line in haddock)
09:53:31 <mauke> the nice thing about haddock is the Source links
09:53:43 <eikke> +1
09:53:44 <monochrom> levi, there is no agreement on "it behaves the same". ask Cale about what he thinks of nubBy as an example
09:53:51 <nand`> typoclass: I usually only look at the source code when I want to see how something is implemented internally
09:54:01 <nand`> out of curiosity
09:54:04 <Yuu-chan> whoev: shootout.alioth.debian.org, but it's rather artificial
09:54:22 <nand`> all of the examples in all of the language on that page make my cringe, personally
09:54:26 <nand`> languages*
09:54:35 <nand`> make me, even
09:54:36 <Cale> monochrom: I wouldn't be so picky if the nubBy/groupBy in the report without the preconditions weren't so useful
09:54:37 <srhb> Makes your cringe what?
09:54:38 <srhb> Aw.
09:54:41 <srhb> :-)
09:55:21 <nand`> either they're purely synthesized for performance or just ugly code in general
09:55:59 <nand`> maybe that's due to the ‘code’ comparison being in there too
09:56:07 <nand`> so smaller = better, obviously!
09:56:36 <srhb> Yes, I wish they would take that parameter out.
09:56:40 <whoev> wow, haskell's pretty fast i guess
09:56:47 <srhb> whoev: Yes... :P
09:57:00 <whoev> i just need to wrap my head around FRP now
09:57:10 <monochrom> there are two implementations of nubBy floating around. they behave the same given an equivalence relation. they behave different given some other relation. some people decide to rely one behaviour or another given a non-equivalence relation
09:57:16 <whoev> and hAppStack too
09:57:27 <Yuu-chan>  ST $ \s1# -> case sizeBU n (undefined::e) of {I# len# -> case newByteArray# len# s1# of {(# s2#, marr# #) -> (# s2#, MBUArr n marr# #) }}
09:57:33 <srhb> whoev: There's a #happs channel for that as well, if you're curious. :)
09:57:37 <whoev> i know
09:57:43 <srhb> whoev: Ok :)
09:57:49 <danil> It would be cool if they accepted all the submissions whose (speed, length) pairs weren't strictly dominated by another.  Then you could see the whole performance/clarity curve for each language
09:57:52 <Yuu-chan> (a typical fast Haskell code)
09:58:10 <monochrom> face it, programmers actually hate encapsulation
09:58:27 <hpc> nah, just BAD encapsulation
09:58:29 <srhb> danil: That too. But in lieu of that, I'd rather have people write readable code and other people judge for themselves.
09:58:32 <whoev> yeah
09:58:42 <monochrom> they want to know undocumented features and they want to rely on them
09:58:43 <matthiasgorgens> monochrom: I (almost) never use nubBy.  It has quadratic runtime, when you can almost always get n log n runtime.
09:59:04 <mauke> matthiasgorgens: that depends on what you use it for
09:59:05 <Cale> monochrom: One of the two is obviously more natural, in that the only difference is parameter order, and the option is between preserving the order in which the elements occur in the list, and reversing it
09:59:23 <matthiasgorgens> mauke: yes.  but what do you mean?
09:59:23 <levi> monochrom: They also want their code that relies on them to not break regularly. The wants of library programmers and the wants of library users are in conflict.
09:59:31 <nand`> I'm personally in the whole “clarity and good semantics is better than performance”-style camp. I would probably still be using Haskell if its performance was in the range of, say, python or ruby
09:59:40 <timthelion> teneen: there are several problems here, the first is you need to do :set -XScopedTypeVariables
09:59:46 <nand`> but the fact that it isn't makes me happy
09:59:55 <srhb> nand`: It would ruin some of the general-purposeness.
10:00:06 <nand`> srhb: yeah, that's precisely why it makes me happy
10:00:09 <srhb> nand`: But that's me hoping we can displace Fortran in astrophysics and such.. Fat chance. :-)
10:00:16 <nand`> since you can implement anything from 3d shooters to operating systems in Haskell
10:00:19 <timthelion> teneen: the next is that you are printing something, which is thus of type IO (), and yet return $ div 9 0 is of type IO Int
10:00:36 <nand`> without crippling usability
10:00:40 <srhb> nand`: Ah, I mean if it's slow as Python, it's not quite as general purpose as it is now. Some applications would just be too slow.
10:00:42 <timthelion> teneen: the reason why the exception is still not caught, is a mistery to me.
10:00:51 <nand`> srhb: that's what I meant too
10:00:57 <srhb> nand`: I am confused :-)
10:01:17 <srhb> nand`: Oh, I missed "the fact that it isn't..."
10:01:20 <nand`> I mean you can write stuff like 3d shooters and operating systems without them being slow to the point of unusability
10:01:57 <nand`> (while retaining elegance)
10:01:59 <typoclass> srhb: look at it this way -- we use haskell, while the muggles can keep using fortran
10:02:19 <nand`> typoclass: doesn't work when you're supposed to work together with them for your job
10:02:22 <srhb> typoclass: Right, but I'd like to be able to beat future colleagues in BOTH readability and speed. Or at least come within some nice margin of it. :-)
10:02:42 <dfeuer> Well, that was stupid.
10:02:50 <dfeuer> Now I don't have time to go swimming.
10:02:59 <dfeuer> So I might as well ask for some more help with my toy program.
10:03:02 <srhb> dfeuer: Welcome!
10:03:03 <srhb> :P
10:03:07 <monochrom> haha
10:03:15 <dfeuer> Anyone want to look at this thing and try to figure out where I'm going wrong?
10:03:22 <srhb> dfeuer: Shoot.
10:03:35 * nand` .oO ( Am I the only one who keeps misreading srhb as srgb ? )
10:03:54 <srhb> Hmm. At least I don't, but then again I know why it's srhb and not srgb <<
10:03:56 <argiopeweb> I'm still stuck trying to pronounce it...
10:04:04 <srhb> I pronounce it "shrub" :P
10:04:06 <typoclass> nand`: what is srgb?
10:04:13 <argiopeweb> That seems backward, no?
10:04:20 <srhb> Yes.
10:04:22 <nand`> typoclass: a color space
10:04:28 <argiopeweb> But hey, you're the boss. ;)
10:04:31 <typoclass> oh, sRGB (-)
10:04:32 <srhb> I am!
10:04:33 <srhb> :P
10:04:34 <nand`> yes
10:04:37 <monochrom> red, hue, blue
10:04:53 <hpaste> dfeuer pasted “SPOJ toy” at http://hpaste.org/72697
10:05:18 * timthelion hates it when people ask questions, and then leave without waiting for the answers.
10:05:23 <dfeuer> That's for you srhb, and whoever else wants to play with this painful thing.
10:05:43 <typoclass> dfeuer: what's the problem? does it give a compiler error?
10:05:58 <dfeuer> No, typoclass, unfortunately not.
10:06:08 <dfeuer> It just gives wrong answers :P
10:06:21 <nand`> first thought: why are you reimplementing State?
10:06:23 <dfeuer> It's supposed to be solving https://www.spoj.pl/problems/ABCDEF/
10:07:01 <dfeuer> nand`: because I have no clue. I wanted some sort of monad to stick this thing in, in case I wanted to replace the pqueue implementation with a mutable array-based one,
10:07:12 <dfeuer> so I just copied SM from some tutorial.
10:07:17 <dfeuer> What's the usual way to do it?
10:07:25 <Yuu-chan> \me is learning IRC commands
10:07:32 <Yuu-chan> fail.
10:07:34 <argiopeweb> Forward slash.
10:07:41 <geekosaur> typewriter slash
10:07:47 <dfeuer> solidus
10:07:47 <nand`> well, your SM is the same as Control.Monad.State.State
10:07:49 <dfeuer> slash
10:07:59 <argiopeweb> The one that isn't fake-lambda.
10:08:00 <nand`> or rather ‘State S’
10:08:02 * Yuu-chan thanks argiopeweb and geekosaur
10:08:10 <dfeuer> nand`: hm?
10:08:31 <dfeuer> Oh, it's parametrized by S?
10:08:37 <nand`> well yes
10:08:47 <nand`> data State s a = State (s -> (a, s))
10:08:56 <dfeuer> OK. Well, that's not why my program is giving wrong answers...
10:08:57 <nand`> newtype would do it, even
10:09:00 <nand`> I know
10:09:08 <dfeuer> But I will change it to clean up.
10:09:21 <nand`> I think your program has some major readability issues. I can't figure out half of it
10:09:27 <dfeuer> Hrr
10:09:32 <dfeuer> Yeah, that's a problem.
10:09:33 <dfeuer> OK.
10:09:33 <nand`> especially lines 99-105
10:09:41 <kitbuilder> Is it possible to capture the screen with Haskell? I've searched hackage and didn't find anything. I want to make a virtual machine manager, but would need to be able to capture the screen, for thumbnails
10:09:43 * dfeuer goes to look.
10:10:14 <matthiasgorgens> kitbuilder: you can always do FFI with a C library or so.
10:10:18 <argiopeweb> If in doubt, massively refactor. Sometimes helps with the bugs too.
10:10:30 <matthiasgorgens> kitbuilder: I can also imagine that capturing the screen is highly OS dependent.
10:10:45 <matthiasgorgens> kitbuilder: what hypervizor do you want to use?
10:10:54 <argiopeweb> Some analog of the *shudder* Java Robot library would be a welcome addition to Hackage.
10:10:57 <EvanR> uhg at ruby functional support, a lambda that takes a block.. lambda {|x,&block| block.call(whatever x)}, myLambda.call(3){my block}
10:11:03 <matthiasgorgens> we are using haskell to manage VMs for XenClient.
10:11:07 <EvanR> and myLambda[3]{ doesnt work
10:11:29 <EvanR> someone thought they were being funny with these features and this sytntax
10:11:54 <kitbuilder> matthiasgorgens: I would be managing Windows VMs under different platforms (VirtualBox, VMware) and want to consolidate the interface.
10:12:00 <typoclass> kitbuilder: if you have imagemagick installed, i think you can use haskell to run an external command like "import -window root somefile.png". you can then display the png file or whatever
10:12:43 <nand`> ‘scrot’ ?
10:12:50 <dfeuer> nand`: here's the concept:   I make two lists, one of which represents all the possible values of a*b+c such that a,b,c<-numbers, tagged with how many different ways (n) there are to choose a, b, and c to get that valu.
10:12:52 <nand`> if you're running external commands, that's what I'd use
10:12:57 <dfeuer> (value)
10:13:09 <dfeuer> That is leftlist.
10:13:22 * Yuu-chan waves goodbye
10:13:39 <dfeuer> rightlist is (or should be, anyway) the possible values of d*(e+f), where d/=0, tagged similarly.
10:13:56 <matthiasgorgens> kitbuilder: you are probably better off haskell VMWare and VirtualBox directly for a screenshot,
10:14:01 <matthiasgorgens> I bet they have an API for that.
10:14:40 <dfeuer> snub (the name comes from "sorted nub", although it's a little more than that) takes a list of pairs sorted by fst and collapses the ones with the same fst by adding the snds together.
10:14:40 <geekosaur> haskell binding for libvirt?
10:15:35 <kitbuilder> matthiasgorgens: seems like a good route, but I'd rather figure out how to capture the screen/window directly with Haskell. I'm surprised nobody has done this yet, or that there's no cabal package for it yet
10:15:56 <dfeuer> overlaptimes is basically like Data.Map.intersectWith $ (*) on snd
10:15:59 <EvanR> :t groupBy
10:16:01 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
10:16:12 <dfeuer> nand`: you getting the drift yet?
10:16:39 <nand`> dfeuer: sorry, I have no real idea about the problem/algorithm
10:16:54 <dfeuer> nand`: the problem is https://www.spoj.pl/problems/ABCDEF/
10:17:18 <dfeuer> :/
10:17:21 <geekosaur> kitbuilder, there is no single blessed (or even generally recognized) GUI library for haskell, so stuff that sits atop one such as screen grabbers not so much standard yet.  or much in demand, given that lack of significant demand is part of why there's no preferred GUI librry yet
10:17:54 <EvanR> map mconcat . groupBy (\t1 t2 -> fst t1 == fst t2)
10:18:32 <kitbuilder> that's understandable. I suppose Haskell just isn't the right language for such a task
10:19:11 <EvanR> theres no blessed standard gui lib anyway
10:19:17 <geekosaur> not necessarily wrong, just lack of interest
10:19:19 <EvanR> not just in haskell
10:20:02 <dfeuer> There's been some academic work on Haskell GUIs.
10:20:23 <dfeuer> Various FRP-things.
10:20:42 <EvanR> id like to see a haskell version of shoes
10:20:54 <EvanR> while its not state of the art it would certainly help
10:21:46 <kitbuilder> geekosaur: would wxHaskell be able to accomplish something that I need?
10:22:44 <geekosaur> kitbuilder, it should, yes.  I'm not familiar enough with it to say precisely how but it should have the ability
10:23:09 <geekosaur> and there should be folks around here (maybe not just at this moment though) who can help you with it
10:23:53 <kitbuilder> geekosaur: to come clean, I'm a totally newbie to Haskell. I'm testing to see whether or not I should learn it for my projects, rather than taking the typical C/C++ route
10:24:52 <kitbuilder> A fellow mathematics student recommended Haskell over C++, so I'm testing the community. So far, so good
10:25:25 <geekosaur> hm.  I suggest you might be better served getting used to Haskell first.  the problem with most GUI frameworks is they're mostly thin layers over C/C++ APIs, so you end up writing a lot of Haskell-flavored not-quite-C++
10:25:35 <nand`> I would recommend Haskell over C++ as well, but that's sort of obvious in here :P
10:25:49 <nand`> in fact, I would recommend forgetting about GUIs too
10:25:51 <geekosaur> (FRP is the exception but that's still a research area)
10:25:54 <typoclass> kitbuilder: in this channel, you'll clearly find people who are fond of haskell and find it rewarding, and will voice various criticisms of c++ ...
10:25:54 <levi> C++ is probably not any simpler than Haskell, though it may appear to be at first.
10:26:13 <teneen> timthelion: Yes, the problem is that the exception is still not caught. The errors you mentioned are corrected in my ghci session.
10:26:16 <argiopeweb> nand`: In this day and age, we can't all be command line gurus. ;)
10:26:30 <levi> C is simple, but it sucks to code in C.
10:26:44 <levi> So you might as well use Haskell. ;)
10:26:53 <kitbuilder> how about Haskell as a first language ;) I know the basic terminology that programmers use, but I don't actually know a language (beyond the basic HTML5 and PHP). Does Haskell have a big learning curve?
10:26:57 <danharaj> C++ is way more complicated than Haskell or pretty much every other currently used language.
10:27:03 <Nereid> C is nice because you can glue it to anything.
10:27:06 <typoclass> levi: i'm struggling to mentally find any upside to c++ which would be big enough to put up with it ... :-/
10:27:09 <nand`> argiopeweb: I think in this day and age the concept of a GUI is being more and more outsourced to HTML/browsers
10:27:31 <nand`> I think web dev in Haskell gets more popularity than ‘GUI programming’ does
10:27:34 <hpc> kitbuilder: yes; the slope of the curve hasn't been well nailed down, but it goes on forever
10:27:41 <argiopeweb> nand`: Valid point. I find this disturbing as well, since it's harder and harder to get anything done in a text-based browser.
10:27:48 <Cale_> typoclass: Basically the only reason to use it is that the project you're working on already exists.
10:28:03 <nand`> argiopeweb: Haskell's learning curve is somewhat unconventional: http://www.haskell.org/haskellwiki/Humor/LearningCurve
10:28:25 <levi> typoclass: The upside to C++ is that it gives you the ability to control the data representation and behavior of your program to a very fine degree while still allowing you to wrap it up in a fairly high-level notation. But the price for that control is heavy!
10:28:27 <typoclass> Cale_: right. that'd be "i use c++ because i have no choice"
10:28:44 <nand`> “I use C++ because I work under a devilish boss”
10:29:02 <argiopeweb> nand`: Heh, hadn't seen that one before.
10:29:45 <nooodl> "co-everything" hahaha
10:29:47 * nand` is floating somewhere in the Pointless-pointfree plane
10:30:11 <hpc> i vaguely understand comonads, but haven't yet found reason to use them
10:30:21 <Cale> http://webhome.cs.uvic.ca/~ruskey/Publications/Venn11/Venn11.html -- cool :)
10:31:31 <dgpratt> well, it's not been totally smooth sailing, but I gotta say that EclipseFP may be winning me over
10:31:32 <nooodl> i'm on monadic, myself, i think? i don't see why pointfree things are above it
10:32:50 <nand`> there needs to be a lens plane
10:32:55 <argiopeweb> Has anyone seen a good hive plot library hanging about?
10:33:55 <Nereid> Cale: cool pictures.
10:34:08 <hpc> there's no type-level plane
10:34:49 <Palmik> Hmm, is there a template-haskell's Lift instance for ByteString (strict or lazy) somewhere?
10:35:10 <edwardk> @tell nand` that will probably be what <~ winds up as ;)
10:35:10 <lambdabot> Consider it noted.
10:35:34 <Cale> Palmik: why would there be? ByteStrings don't directly correspond to anything syntactic -- you're forced to convert back and forth from String anyway.
10:35:38 <nand`> edwardk: with the ‘monadic lenses’ you were working on? or just in general?
10:35:38 <lambdabot> nand`: You have 1 new message. '/msg lambdabot @messages' to read it.
10:35:52 <Cale> Palmik: I guess you could write an instance which did that.
10:35:59 <Palmik> Cale, so that you can use them in [| .. |] directly?
10:36:10 <luite> Palmik: no and it's quite difficult to embed them properly and efficiently, the usual encoding from the internal string representation (Addr# ) breaks binary stuff
10:36:28 <edwardk> nand`: in general
10:36:34 <luite> Palmik: because it assumes utf8 encoding
10:36:50 <edwardk> (<~) :: MonadState a m => Setting a a c d -> m d -> m ()
10:37:30 <edwardk> the monadic lenses turned out to be more trouble than they are worth
10:37:36 <Palmik> Cale, luite, I see thanks for the info.
10:37:42 <edwardk> i've refocused on cleaning up error messages
10:37:59 <edwardk> it now says things like 'no instance of Settable Accessor' when you use a getter as a setter
10:38:14 <edwardk> instead of a huge unification error
10:40:18 <nand`> what is this Settable type class?
10:41:04 <edwardk> nand`: i've also broken up the monolithic Control.Lens module
10:41:17 <edwardk> check the github, i think i've pushed recently
10:41:57 <edwardk> i'm using it to make it so i can transform setters and getters ith some of the simple applicative transformers that are also monoid transformers
10:42:10 <edwardk> that way e.g. i can kill the distinction between backwards and reversed
10:42:58 <roconnor> ross was very careful to introduce a distinction between backwards and reversed IIRC
10:43:16 <edwardk> i mean for traversal or folding
10:43:18 <edwardk> different thing
10:43:20 <edwardk> just the combinators
10:43:34 <nand`> edwardk: I don't see anything along the lines of Accessor or Settable in the github's Control.Lens
10:43:40 <edwardk> i'll push
10:44:06 <edwardk> try now
10:44:12 <edwardk> Control.Lens.Getter
10:44:21 <edwardk> and Control.Lens.Setter
10:45:12 <edwardk> it was galling that Backwards (Const r) wasn't usable as a valid getter, because it meant i had to make a separte combinator that did Const (Dual r)
10:45:20 <edwardk> so thats fixed
10:45:27 <edwardk> and it comes with the MUCH better error messages
10:45:40 <edwardk> a getter is just a lens for an 'anyvariant' functor
10:45:58 <nand`> “type Getter a c = forall r. Applicative m => LensLike f a b cd” O.o
10:46:04 <edwardk> instance Functor f => Gettable f where coerce :: f a -> f b
10:46:13 <edwardk> hah i need to keep cleaning those docs up
10:46:16 <edwardk> i've changed a LOT
10:46:24 <edwardk> thats why its not pushed yet
10:46:31 <nand`> k
10:46:37 <nand`> I'll stick to reading the code
10:47:08 <edwardk> yeah
10:47:09 <edwardk> better
10:47:19 <edwardk> i'm rewriting docs right now actually
10:47:22 <edwardk> thats why i hadn't pushed
10:47:35 <edwardk> the code all works though
10:47:47 <nand`> so you decided to rename Const and Identity after all?
10:47:51 <edwardk> yeah
10:47:59 <edwardk> partially because i was able to get rid of the unification error
10:48:06 <nand`> :( that breaks compatibility, but if Control.Lens is the lens lib to rule them all then I suppose it doesn't matter too much
10:48:09 <edwardk> and then the typeclass error is much friendlier this way
10:48:28 <edwardk> it only breaks compatibility with people writing getters and setters
10:48:43 <edwardk> but they already needed the lib to write isos and indexed traversals, etc.
10:49:10 <nand`> oh right, it's still compatible with (polymorphic) lenses
10:49:58 <nand`> did you get rid of LensLike
10:50:16 <edwardk> probably
10:50:45 <edwardk> i just got things split into the separate modules about 10 minutes ago
10:51:00 <nand`> seems you didn't rename Identity either
10:51:04 <nand`> oh, you did; Mutator
10:51:05 <edwardk> where?
10:51:51 <edwardk> the haddocks wound up pretty well organized by splitting Lens up
10:51:57 <nand`> I see, you didn't get rid of Const/Identity entirely (so keep compatibility with eg. the applicative Const m instance I guess), you just made them instances of Gettable/Settable too
10:52:09 <nand`> s/so/to/
10:52:23 <edwardk> yeah that means you can use my lenses with other libs, but not necessarily other lens lib lenses with mine
10:52:59 <nand`> oh, but you provide an Applicative Accessor r instance either way
10:53:07 <edwardk> yeah
10:53:26 <edwardk> i may extend Gettable with the 'r' extraction functionality, i had left it off because it was bad for Action
10:53:32 <edwardk> but i think i'm going to scrap Action
10:53:41 <edwardk> it wasn't worth the pain
10:53:53 <nand`> Action? is that your monadic lens thingy?
10:54:00 <edwardk> and it turned out the monadic setters, etc. needed an existential i can't provide without triply cpsing!
10:54:01 <edwardk> yeah
10:54:30 <nand`> I'm not too keen on them either, if anything they're better left off in a separate library
10:54:52 <edwardk> well i was trying to make sure they were compatible with getting, now gettable can still be made to work with them if i wanted
10:55:35 <edwardk> we may still get monadic actions and folds, but you won't get monadic traversals, etc.
10:56:15 <dfeuer> I figured out my silly toy.
10:56:16 <dfeuer> jeeeez.
10:56:22 <__emj> Hello. I have problems using bits-atomic on windows running the latest haskell platform. Getting error "HSbits-atomic-0.1.3.o: unknown symbol `___sync_bool_compare_and_swap_1'". Is this a known problem?
10:56:54 <edwardk> emj: never seen that one
10:57:23 <edwardk> is it a missing gcc primitive or something?
10:57:49 <c_wraith> a CAS instruction certainly implies something really low-level.
10:57:58 <Cale> Yeah, that's a gcc symbol, apparently
10:58:02 <nand`> what's up with Control.Phantom ? some code duplication with Control.Lens.Setter
10:58:11 <edwardk> oh crap i should have deleted that
10:58:23 <edwardk> i checked in my entire src dir to get it up for you
10:58:44 <__emj> The cabal file says that it should work with gcc > 4.4. Latest platform comes with mingw 4.5
10:58:46 <nand`> fair enough
10:59:01 <edwardk> it was the testing ground for the ideas i used
10:59:21 <krey_> hi, i'm trying to understand monad transformers and read typeclassopedia and I'm wondering, aren't monad transformer laws the same as a functor from the Kleisli category of one monad to the kleisli category of the other?
10:59:53 <edwardk> krey_: its a little stronger. its a full monad homomorphism
11:00:13 <edwardk> you need to preserve the meaning of the monadic actions for join and return across the mapping
11:00:17 <__emj> Could it that some library is missing? I'm running in ghci. Do I have to explicity load library dependencies for imported modules? (c libraries that is)
11:01:01 <edwardk> __emj: i'd expect its a mismatch between what they think the symbol should be called and something gcc did in 4.5
11:01:18 <krey_> edwardk: I'm not sure what you mean. isn't preserving composition & id as good as preserving join and return?
11:01:38 <__emj> edwardk: sounds plausible. I'll keep looking.
11:01:52 <nand`> would the transformer laws be (lift.) return = return; and (lift.) f >=> (lift.) g = (lift.) (f >=> g)?
11:02:26 <c_wraith> those are certainly laws a transformer should obey
11:03:00 <krey_> nand`: these are the ones on typeclassopedia
11:03:09 <edwardk> no. i could map everything to the same kleisli arrow '\_ -> return "Help!"' that would be a valid functor between the two categories, but not a valid monad homomorphism
11:03:21 <nand`> oh; functor laws just state that the functor has to preserve associativity, right?
11:03:26 <nand`> (and identity)
11:03:27 <c_wraith> "Help, trapped in Kleisli Category!"
11:03:38 <singpolyma> this http://pastie.org/4401055 is not allowed... but it's the most natural representation of what I want  (b and c are just passed through on the second one)  -- I don't suppose there's any tricks to refactor this?
11:03:54 <nand`> hmm no, not quite
11:03:59 <edwardk> (the example is off the cuff, and it may not be sufficient or fail for other reasons)
11:04:06 <edwardk> afk a bit
11:05:40 <typoclass> singpolyma: you mean it's not allowed because one definition has 3 arguments while the other has only 1?
11:05:47 <singpolyma> typoclass: yes
11:07:06 <krey_> edwardk (or someone else, maybe c_wraith):  I dno't think that example works, do you mean mapping every type to return and every arrow to return_String?
11:07:20 <pipoca> I'm trying to install lens, and I'm running into some trouble.  Running "cabal install lens" gave me the error "Could not find module `Control.Applicative.Backwards':".  Looking on hackage, lens should have a build-depends on transformers, but doesn't on my local system.  So I unpacked lens and edited the lens.cabal file to include the build-depends on transformers, and running "cabal...
11:07:23 <pipoca> ...install lens.cabal" gives me the error "cabal: can't find source for Control/Applicative/Backwards in src,dist/build/autogen"
11:08:35 <typoclass> singpolyma: good question ...
11:08:56 <krey_> o/ rtharper
11:09:08 <rtharper> hey krey_
11:09:10 <rtharper> sup?
11:09:27 <edwardk> pipoca: upgrade transformers, the current official bound is wrong
11:09:56 <krey_> trying to figure out the difference between a monad transformer and functor between kleisli categories. got a clue?
11:10:01 <edwardk> cabal install lens --constraint 'transformers >= 0.3'
11:10:05 <krey_> ^rtharper
11:10:18 <rtharper> krey_: oh umm
11:10:18 <rtharper> no
11:10:20 <rtharper> not a clue
11:11:11 <rtharper> krey_: Monads are not my dept, as you know ;)
11:11:19 <edwardk> krey_: check to see if the functor between kleisli categories is necessarily a monad homomorphism between the two monads, if it is, then you're right
11:11:40 <edwardk> return being mapped to return follows from the mapping of identity arrows to identity arrows
11:11:58 <edwardk> so you only need to check the preservation of join
11:12:24 <nand`> how does join relate? wouldn't you just need to check >=> ?
11:12:24 <edwardk> that one is trickier
11:12:52 <edwardk> a monad transformer is defined in terms of a monad homomorphism from the base monad into the transformed monad.
11:13:06 <edwardk> checking (>=>) is assuming his hypothesis ;)
11:13:30 * krey_ needs to remind himself what a monad homomorphism is. is it a monad morphism (as in comprehending monads [Wadler])?
11:13:30 <nand`> I was going by the laws as defined here: http://www.haskell.org/haskellwiki/Typeclassopedia#Definition_and_laws
11:13:38 <pipoca> ed: Still failing; same error
11:13:48 <nand`> which, apart from return, only mentions how lift has to interact with >>=
11:13:52 <edwardk> pipoca: hrmm, what version of transformers do you have?
11:14:09 <rtharper> krey_: I would assume it preserves joins and units
11:14:16 <edwardk> lift (m >>= f)  =  lift m >>= (lift . f)  -- is the monad homomoprhism law
11:14:19 <nand`> and I'm sure you could transform that >>= law into an equivalent law using >=>
11:14:24 <edwardk> just in terms of (>>=) instead of join
11:14:27 * rtharper hates it when category theory gets involved with monads
11:14:29 <nand`> maybe I'm wrong
11:14:47 <edwardk> krey_: should be, yes
11:14:59 <EvanR> rtharper: haha
11:15:39 <edwardk> rather i should say, its the part of the monad homomorphism law that deals with join
11:15:44 <krey_> nand`: but you already have
11:16:01 <pipoca> edward: 0.2.2.0 & 0.3.0.0
11:16:15 <edwardk> pipoca: what platform are you on?
11:16:22 <nand`> would “lift . join” = “join . lift . fmap lift” be an equivalent formulation of that law?
11:16:25 <edwardk> e.g. haskell platform ver
11:16:55 * krey_ goes away to potentially prove this correspondence
11:17:05 <pipoca> ghc 7.0.3 on ubuntu
11:17:16 <edwardk> krey_: i find the correspondence plausible, but i don't have the proof handy
11:17:36 <rtharper> krey_: have fun!
11:17:38 <EvanR> its a truely marvelous proof but the margin is too damn small
11:17:46 <krey_> edwardk: i find it implausible, given that the interwebs claims that it isn't true
11:17:48 <edwardk> nand`: possibly
11:17:52 <nand`> I'm a bit lost, what are you trying to show here? that “lift. f >=> lift . g  =  lift . (f >=> g)” ?
11:17:53 <edwardk> krey_: hah
11:18:06 <nand`> (in terms of the transformer law edwardk quoted)
11:18:14 <edwardk> krey_: well, the return part comes for free, but the join law is troubling and i don't see how you can prove it
11:18:55 <edwardk> if you can it'd be pleasant and somewhat surprising, but i expect you need to stick to the monad homomorphism definition
11:19:20 <krey_> http://blog.sigfpe.com/2007/02/monads-for-vector-spaces-probability.html?showComment=1172511660000#c8246574813074210288
11:20:11 <edwardk> yes, a monad transformer is a family of monad homomorphisms
11:20:23 <edwardk> rather than a single one
11:22:19 <pipoca> ed:  Also, cabal-install version 0.10.2, using version 1.10.2.0 of the Cabal library in addition to the aforementioned ghc 7.0.3 on ubuntu.
11:22:36 <krey_> edwardk: thanks for helping, I'll try to prove the join thing later
11:23:02 <edwardk> roconnor: see what i get for using your backwards? =)
11:23:18 <roconnor> edwardk: what do you get?
11:23:29 <edwardk> mostly that it doesn't work for user on old platforms ;)
11:23:36 <edwardk> hrmm
11:23:36 <roconnor> ah
11:23:44 <edwardk> finding the right version bound for you pipoca
11:23:52 <roconnor> simple solution: don't use Haskell Platform
11:24:10 <edwardk> roconnor: =P
11:24:11 <roconnor> it was a silly idea anyways
11:24:13 <edwardk> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Applicative-Backwards.html
11:24:24 <edwardk> roconnor: i rather heartily disagree
11:24:37 <edwardk> pipoca: it should be able to find it in 0.3
11:25:11 <pipoca> I know, it seems weird
11:25:22 <nand`> I only use the haskell platform on systems which don't have good package managers
11:25:36 <edwardk> can you hpaste the error?
11:26:46 <roconnor> I see, Reverse reveses a fold, like how reverse reverses a list
11:26:55 <edwardk> roconnor: yep
11:27:01 <roconnor> and hence Backwards is the one for Applicative
11:27:06 <edwardk> yep
11:27:14 <roconnor> I might be able to remember that
11:27:16 <edwardk> and now i can make one combinator that does both
11:27:32 <roconnor> edwardk: wouldn't that be Reverse . Backwards ?
11:27:35 <edwardk> no
11:27:45 <edwardk> i'm changingthe order of the applicative effects
11:28:03 <edwardk> so Backwards does it for both 'Fold' and 'Traversal' now
11:28:11 <edwardk> so i'll probably change the combinator name to reversed ;)
11:28:35 <roconnor> anyhow I guess traversing a Traversable Backwards is the same as traversing the Reversed thing, modulo infinity issues.
11:28:42 <edwardk> yep
11:28:50 <hpaste> pipoca pasted “cabal error” at http://hpaste.org/72704
11:28:57 <roconnor> which makes it seem a bit confusing since there are two ways of doing the same thing
11:29:05 <roconnor> one changes the container, the other changes the traverser
11:29:20 <otters> Does anybody happen to know if wai requests all use the same vault over the lifetime of one application?
11:29:23 <edwardk> oh, i expose the module
11:29:25 <roconnor> edwardk: and then when you do both, you end up doing the original traversal?
11:29:26 <edwardk> remove that line
11:29:38 <edwardk> pipoca: edit rhe cabal config to remove
11:29:38 <edwardk>   exposed-modules: Control.Applicative.Backwards
11:29:46 <edwardk> that shouldn't be there
11:30:46 <pipoca> Thanks, works now
11:32:02 <edwardk> well, in this setting both are changing the traverser, because i'm working on a 'Fold' not a Foldable ;)
11:32:19 <edwardk> pipoca: i'll push 1.5 shortly and that export is already gone in the dev branch
11:36:11 <exFalso> Hey, does anyone know if in Attoparsec there is a way to return the rest of input without consuming?
11:36:27 <singpolyma> is there any way to write http://pastie.org/4401205 so that it makes use of partial application and the 5 params that are just passed through don't have to be specifically listed?
11:36:46 <exFalso> i see there is getInput in earlier versions, but couldn't find an equivalent
11:39:25 * hackagebot proctest 0.1.0.0 - An IO library for testing interactive command line programs (NiklasHambuechen)
11:39:25 * hackagebot proctest 0.1.0.1 - An IO library for testing interactive command line programs (NiklasHambuechen)
11:40:13 <danil> singpolyma: no, but you might consider bundling some of the parameters into a datatype if you end up passing them around together frequently
11:42:03 <singpolyma> danil: ok, thanks :)
11:43:06 <S11001001> @pl \f x -> f `ap` return x
11:43:06 <lambdabot> (. return) . ap
11:43:35 <edwardk> i do wish there was a -Wunused-pragmas
11:43:48 <edwardk> or -funused-pragmas i guess
11:43:53 <S11001001> edwardk: can you always tell?
11:44:18 <edwardk> it'd probably be a pain in the ass ;)
11:44:20 <typoclass> delete them all, see what breaks :)
11:44:35 <edwardk> thats what i do, kind of a slow process across 40 modules
11:44:56 <hpc> edwardk: what do you mean by pragma?
11:45:07 <hpc> {-# LANGUAGE #-} ?
11:45:09 <edwardk> {-# LANGUAGE FlexibleInstances #-}
11:45:12 <edwardk> etc
11:45:13 <hpc> ah
11:45:17 <hpc> ooh, that would be cool
11:45:19 <hpc> but damn hard
11:45:22 <edwardk> yep
11:45:44 <edwardk> i often turn on language pragmas when i start using a feature and forget to remove it when i no longer need it
11:46:07 <Clint> anyone know when the hackage haddock cronjob runs?
11:46:24 <edwardk> every 12 hours or so
11:46:29 <edwardk> not sure the exact time
11:46:31 <Yuu-chan> What does @pl do?
11:46:40 <edwardk> it switches to pointfree notation
11:46:43 <Clint> how about the inexact time?
11:46:57 <edwardk> @pl \a -> fst (snd a)
11:46:57 <lambdabot> fst . snd
11:47:06 <Yuu-chan> @pl \x y z -> x z (y z)
11:47:07 <lambdabot> ap
11:47:09 <edwardk> within 12 hours of now ;)
11:47:21 <danharaj_> @pl \f g -> g . f
11:47:22 <lambdabot> flip (.)
11:47:26 <mekeor> ap = <*>, right?
11:47:37 <edwardk> ap is (<*>) using Monad not applicative
11:47:39 <edwardk> but yes
11:47:42 <Yuu-chan> @pl \y f -> f (y f)
11:47:43 <lambdabot> ap id
11:47:43 <mekeor> okay.
11:47:48 <edwardk> (<*>) = ap is a valid default definition fo (<*>)
11:48:16 <mekeor> really?
11:48:29 <mekeor> @info Applicative
11:48:30 <lambdabot> Applicative
11:48:34 <mekeor> ah, yeah.
11:48:41 <mekeor> :info Applicative
11:48:46 <mekeor> hm.
11:48:53 <fold> what's the fastest functional sorting algorithm? merge sort?
11:48:54 <Yuu-chan> @pl \f g (a, b) -> (f a, g b)
11:48:54 <mekeor> @source Applicative
11:48:55 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
11:48:55 <lambdabot> Applicative not available
11:49:09 <danharaj_> edwardk: any updates to lens coming down the pipe?
11:49:18 <edwardk> yeah 1.5 is _almost_ out the door
11:49:22 <edwardk> its all doc cleanup right now
11:49:32 <Yuu-chan> :t ap
11:49:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:49:43 <danharaj_> cool.
11:49:46 <taruti> Is it possible to use integer-simple instead of gmp without recompiling GHC?
11:49:50 <edwardk> nicer error messages, split out definitions into Control.Lens.Getter, etc. re-exported by Control.Lens
11:50:14 <c_wraith> fold: on what data structure? on immutable singly-linked lists, merge sort has huge advantages, yes
11:50:15 <edwardk> and the TH is smarter about binding to Iso and Lens so there aren't shadowing/scope issues
11:50:26 <hpc> taruti: you could make a different type and FFI
11:50:30 <edwardk> and indexedsetters are added
11:50:41 <c_wraith> fold: but sorting immutable singly-linked lists has bad constant factors, no matter what.
11:51:32 <fold> c_wraith: I'm writing simple binary tree for learning, I figured I'd turn it into a list, sort, then back into a tree, is that the best way to balance?
11:51:39 <danharaj_> great. I found indexed traversals very convenient. I still haven't figured a nice way to work with STArrays :(
11:52:21 <ReinH> edwardk: zomg indexed traversals are a thing?
11:52:26 <edwardk> yes
11:52:30 <ReinH> <3
11:52:41 <ReinH> edwardk: I bet I can use them in interesting ways in the chess engine, right
11:52:48 <ReinH> there should have been a ? somewhere in there
11:52:58 <edwardk> you can use them to traverse or foldr, etc.  a map with access to the keys
11:53:01 <c_wraith> fold: it's probably the best way to balance as a single pass, anyway, rather than keeping the tree balanced as you build it from non-sorted data.
11:53:08 <edwardk> or other containers
11:53:18 <edwardk> and you can index any traversal by augmenting it with its position
11:53:58 <edwardk> i'm working on making that one combinator work for indexing folds and traversals
11:53:59 <fold> thanks c_wraith
11:56:51 <Taslem> Does anyone know of a tutorial for Template Haskell quasiquoters? I have a decent understanding of the rest of TH, but I can't find an explanation of quasiquoters: ie [a|arg1|arg2|]
11:56:53 <ReinH> If I have a type with some semantically appropriate notion of magnitude/weight (like a Piece has a piece value), is there some type class that will make it easily summable?
11:58:01 <ReinH> I'd really like to get the positional evaluation of a board with a simple summation
11:58:06 <c_wraith> Taslem: you don't need a tutorial.  just look in the GHC docs.  if you understand TH, it's just a handy interface to create splices based on a string argument
11:58:08 <scooty-puff> does anyone have a link describing how ghc implements higher rank types (one of these: http://research.microsoft.com/en-us/um/people/simonpj/papers/boxy/, or maybe http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/)?
11:59:43 <ReinH> I guess I could sum . (concatMap squareValue) just as easily
12:00:17 <ReinH> but I'd like to bake squareValue into the semantics of the type
12:00:59 <danil> Taslem: [a| arbitrary text here|] is sugar for $(quoteX a "arbitrary text here"), where which of quote{Exp|Pat|Type|Dec} is chosen depends on the context of the quasiquotation
12:01:17 <Taslem> Okay.
12:01:39 <edwardk> ReinH: sumOf (mapped.mapped) squareValue ;)
12:02:22 <edwardk> er
12:02:31 <edwardk> sumOf (mapped.mapped.to squareValue)
12:03:44 <ReinH> edwardk: mapped.mapped.to ? Haddock come here, I need you.
12:03:52 <edwardk> ReinH: they are in lens
12:04:11 <edwardk> mapped is the Setter for a Functor
12:04:15 <edwardk> er
12:04:20 <edwardk> thats wrong i guess
12:04:28 <edwardk> sumOf (folded.folded.to squareValue)
12:04:30 <edwardk> better
12:04:31 <nand`> don't y--
12:04:34 <nand`> was about to say
12:04:38 <edwardk> yep
12:04:40 <ReinH> edwardk: I think I should define its traversable semantics to traverse single squares, not rows, right?
12:04:49 <nand`> I just go with traverse.traverse as default for these
12:04:50 <edwardk> probably
12:05:06 <ReinH> edwardk: wondering how that would affect my usage of map to traverse rows
12:05:19 <edwardk> you can make multiple traversals
12:05:22 <ReinH> hmm
12:05:27 <edwardk> make a rows traversal a columns traversal, etc.
12:05:29 <ReinH> bySquare, byRow
12:05:33 <edwardk> and a cells traversal
12:05:34 <ReinH> byColumn, byDiagonal, etc
12:05:36 <ReinH> yeah that's nice
12:05:38 <edwardk> yep
12:05:47 <ReinH> that'll come in handy
12:05:54 <edwardk> they can even be indexed traversals so you can know the row or column number
12:05:57 <nand`> any sudoku traversals out there? :)
12:05:57 <edwardk> or diagonal number
12:06:11 <ReinH> nand`: :)
12:06:19 <ReinH> nand`: have you seen Bird's algorithm? It's beautiful.
12:06:24 <nand`> nope
12:06:44 <edwardk> that is what bird does :)
12:06:49 <ReinH> http://www.haskell.org/haskellwiki/Sudoku#Sudoku_incrementally.2C_.C3.A0_la_Bird
12:07:03 <ReinH> edwardk: yes, indexed traversals of all those things is exactly what I want :)
12:07:12 <ReinH> I'm excited to lensify my engine later on
12:07:33 <ReinH> he essentially creates row, column and box traversals, yes
12:07:45 <edwardk> and you can make the isomorphism to flip the board and colors ;)
12:07:47 <nand`> can you link me to the code?
12:08:20 <ReinH> nand`: ofc http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
12:08:33 <ReinH> edwardk: ooh :)
12:08:52 <ReinH> edwardk: I might have a lot of questions for you in a week or three
12:08:57 <edwardk> sure
12:10:02 <ReinH> :D
12:11:06 <keep_learning> :t rec
12:11:08 <lambdabot> <no location info>: not an expression: `rec'
12:11:44 <scooty-puff> :set -XDoRec
12:14:25 <danil> scooty-puff: "Practical Type Inference for Higher-Rank Types" is the current implementation; I think boxy types was used before ghc 7
12:15:09 <keep_learning> :t rect
12:15:11 <lambdabot> Not in scope: `rect'
12:15:12 <keep_learning> :t rec
12:15:14 <lambdabot> <no location info>: not an expression: `rec'
12:15:38 <scooty-puff> danil: thank you!
12:16:23 <scooty-puff> keep_learning: are you see "rec" appear like so: "do rec"?
12:16:33 <scooty-puff> *see -> seing
12:16:36 <scooty-puff> gah
12:16:37 <scooty-puff> seeing
12:17:09 <geekosaur> keep_learning, rec is not a function and does not have a type, it specifies that a do block needs to use the recursive binding desugaring rules instead of the standard Haskell rules
12:17:19 <keep_learning> scooty-puff, yes I am trying to see the type of  rec.
12:17:52 <keep_learning> geekosaur, Thank you. Got the link ( http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/syntax-extns.html )
12:17:57 <scooty-puff> keep_learning:  http://www.haskell.org/haskellwiki/MonadFix
12:18:29 <keep_learning> scooty-puff, Thank you.
12:18:52 <ReinH> How would you folks recommend I handle constraints that can't (easily) be specified in the type, like a chess board matrix being 8x8
12:19:02 <ReinH> where does the validation ideally live?
12:19:29 <ReinH> (I am not going to build peano arithmetic in my type to verify this ;)
12:20:08 <monochrom> I use an array. it already checks bounds
12:23:30 <ReinH> monochrom: I'm not sure that error "hey you're out of bounds" is my favorite way to do that ;)
12:25:06 <latro`a> one way is to use a Maybe array and give Nothing if you go out of bounds
12:25:53 <ReinH> but how would you determine oob?
12:26:35 <ReinH> I don't want to catch the exception, do I?
12:26:38 <latro`a> use bounds?
12:26:51 <latro`a> unfortunately I'm not sure there's a way to do that for arbitrary Ix
12:27:07 <latro`a> (rather, a way that always works
12:27:08 <latro`a> )
12:27:12 <ReinH> it would be nice if Array had a version of ! that returned a maybe
12:27:16 <latro`a> agreed
12:27:34 <jfischoff> ReinH: I have created a typeclass to help with the general problem of invariants that can't be checked by the type system. Something like: class Valid a where issues :: a -> [String]. You could make it a multiparameter typeclass if you want a different issue type
12:27:37 <latro`a> but
12:27:44 <latro`a> that would require the array to be Maybe
12:27:48 <ReinH> jfischoff: hmm
12:27:49 <latro`a> which would break previous code
12:28:05 <ReinH> latro`a: why?
12:28:15 <latro`a> return type has to be uniform
12:28:28 <latro`a> this is the same reason that, say, the two functions that are the first arguments to "either" have to return the same type
12:28:47 <latro`a> anyway I agree, exceptions are irritating
12:28:57 <ReinH> maybeAt :: Ix i => Array i e -> i -> Maybe e
12:29:00 <ReinH> ?
12:29:07 <latro`a> oh you mean a different function
12:29:08 <latro`a> ic
12:29:10 <ReinH> right
12:29:15 <applicative> arrays can be indexed by a finite type, no, like data Col = One | Two | ... | Eight
12:29:19 <latro`a> I don't think you can do that outside the IO monad
12:29:40 <latro`a> at least, with the way arrays are defined now
12:30:00 <ReinH> if we assume Ix I and Enum I, can we check bounds?
12:30:09 <ReinH> er Ix i and Enum i
12:30:31 <ReinH> I'm thinking about off board checks for move generation
12:31:24 <ReinH> or just (`elem` . indices) ?
12:31:38 <latro`a> no, bounds is O(1) to check
12:32:22 <Clint> ok, so the haddock run happened within the past 45 minutes
12:32:25 <ReinH> ok, so Eq i and I can check >= and <= ?
12:32:52 <latro`a> yeah, but I'm not sure you can do that for generic
12:32:54 <nand`> those are in Ord not Eq
12:33:04 <ReinH> oh ofc
12:33:07 <ReinH> sry
12:33:53 <ReinH> ok so the general case won't work but I can do something for arrays with bounds (1,8) and ('a', 'h') using bounds
12:34:00 <latro`a> I am surprised Array doesn't have an "inBounds" check function though
12:34:05 <ReinH> yeah, seems odd
12:34:18 <ReinH> I can add one for mine though
12:34:54 <ReinH> and then use fmap to access the nested element
12:35:02 <ReinH> seems good
12:35:48 <ReinH> like: maybeAt arr i | inBounds arr i = arr ! i
12:35:59 <ReinH> er Just
12:36:15 <ReinH> that seems reasonable
12:40:10 <johnw> what's the best way to walk the filesystem in Haskell, where the filesystem walk continues to gather next elements in parallel, knowing that every member of the resulting list will at some point be used?
12:40:43 <johnw> In Ruby I do this: IO.popen("find -H -L #{dirs} -name .git -printf '%p\\n\\c'").each { |path| ... }
12:40:54 <johnw> I'm looking to translate this into the equivalent Haskell
12:40:58 <luite> haha
12:41:27 <reaga> guys
12:41:33 <reaga> im learning java instead of haskell
12:41:49 <reaga> if haskell is so good why isnt it more popular
12:41:59 <johnw> troll
12:42:11 <luite> johnw: you can also do that in haskell with readProcess, but i guess that's not really recommened :)
12:42:15 <tromp_> it's too good to be popular
12:42:27 <johnw> luite: I was wondering if there was a more native way use `par`
12:42:34 <johnw> s/use/using
12:42:42 <Twey> reaga: Popularity doesn't follow superiority.
12:42:51 <Twey> Never has.
12:42:54 <luite> johnw: par won't work because it's IO actions you're running
12:42:58 <johnw> ahh
12:43:03 <johnw> so readProcess it is
12:43:08 <EvanR> popularity is inversely proportional to quality
12:43:13 <johnw> blocking on find is really bad for my use case
12:43:18 <EvanR> also the motto is avoid success at all costs
12:43:19 <luite> johnw: uh no not necesarily, you can still scan in parrallel with multiple threads
12:43:36 <johnw> oh?  do you know of any examples of that on the Web?
12:43:43 <reaga> Twey:  so what you're saying is that people are irrational
12:44:01 <EvanR> reaga: 'haskell is too hard'
12:44:09 <EvanR> try it yourself and see for yourself
12:44:19 <Taslem> Haskell does have a learning curve that's a bit more steep than most other languages.
12:44:27 <johnw> so, I can use System.FilePath.Find in another thread
12:44:28 <Twey> reaga: Of course people are irrational, but that's not what I said.
12:44:40 <luite> johnw: hmm, i forgot the name of the pattern, there's some lib for it
12:44:46 <Twey> Taslem: I don't agree with that.
12:44:52 <luite> johnw: you can certainly just do the whole "find" in a separate thread
12:44:57 <johnw> Control.Concurrent?
12:44:57 <Twey> Taslem: Haskell has an *un*learning curve if you're used to other paradigms.
12:45:23 <luite> johnw: what you can also do is list the files of a directory, and then have a new thread for every subdirectory, let those fill an MVar with the result, and wait for all MVars to be filled
12:45:23 <Twey> But dibblego taught his young children Haskell without too many problems, if I remember correctly.
12:45:26 <Taslem> I see a connotative difference, but not a denotative one. :3
12:45:46 <Taslem> Perhaps it's just me.
12:45:59 <EvanR> some people dont have to unlearn java
12:46:02 <luite> johnw: that will probably be slower than scanning in a singlethread though
12:46:14 <johnw> i'll give it a try
12:46:21 <johnw> the "find" operation is enormously expensive in my use case
12:46:29 <Twey> Taslem: Not everybody has prior experience programming other, dissimilar languages to unlearn.
12:46:33 <johnw> do the find, and then processing the results, ends up doubling the runtime
12:46:48 <luite> johnw: in that case just forkIO the long running computation, and use some synchronization like MVar to get the result
12:46:53 <luite> oh
12:47:01 <monochrom> @quote monochrom unlearning
12:47:01 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
12:47:12 <luite> johnw: oh you want to do the processing during the find?
12:47:37 <johnw> yes
12:47:54 <johnw> the find should return [String].  I want to consume these as soon as they're available
12:48:04 <monochrom> young children also learn faster. for certain things
12:48:37 <luite> johnw: oh a Chan could work then, have it post all found files to a Chan and have the processing thread read them
12:48:59 <johnw> forkIO + Chan?
12:49:25 <luite> johnw: yeah
12:49:46 <johnw> cool, thanks!
12:50:01 <johnw> found an example here: http://stackoverflow.com/questions/1268307/producer-and-consumer-problem-in-haskell
12:51:24 <ktklam9> hi, how can I use parsec to skip until a word "foo" is found, and then parse the rest until the word "bar" is found?
12:55:23 <hpaste> loocorez pasted “in” at http://hpaste.org/72706
12:55:59 <loocorez> Hi! Having a bit of trouble googling for this, and LYAH seemingly just threw it at me without explaining it (maybe I missed it) but what does in do?
12:56:31 <loocorez> Did a little more experimentation than above but it looks like it just returns the part after the "in"...
12:57:01 <applicative> yes, thats what you asked it to do
12:57:11 <applicative> > let a = 14 in  100000
12:57:12 <lambdabot>   100000
12:57:32 <applicative> > let nice = True in 'a'
12:57:33 <lambdabot>   'a'
12:57:43 <nand`> > let a = 3 in a
12:57:44 <lambdabot>   3
12:57:47 <applicative> loocorez: by contrast
12:57:58 <nand`> > 3
12:57:59 <lambdabot>   3
12:58:01 <applicative> > let a = 3 in a * a
12:58:03 <lambdabot>   9
12:58:28 <applicative> you need to use the things you define  in 'let' in the expression you use after 'in
12:58:42 <loocorez> ahhh, thanks! I think I see the use. Yeah, and you can do different things based on them in the same statement
12:58:58 <loocorez> based on prior assignments etc
12:59:12 <applicative> yes, if I understand you
12:59:44 <nand`> s/need to/can/
12:59:55 <levi> loocorez: 'let <pattern> = <expression1> in <expression2>' creates an extended environment for expression2 in which the variable bindings arising from the 'let' are in effect. The overall value of the combined expression is that of <expression2>, so if you make no use of the bindings in the let part... you just get back what you put in.
13:00:27 <danil> > let in "the dog"
13:00:29 <lambdabot>   "the dog"
13:00:44 <nand`> would it be fair to say ‘let a = b in foo’ desugars to (\~a -> foo) b
13:01:04 <c_wraith> nand`: until you get to mutually recursive bindings..
13:01:11 <nand`> oh, right
13:01:18 <danil> nand`: or let-generalization
13:01:22 <EvanR> let is the desugar
13:02:48 <loocorez> levi: I think I understand that. Where did you pull that from? Or, where could I read about this sort of thing if I had more questions?
13:03:40 <levi> loocorez: I pulled it from my head after reading too many books and papers about programming languages.
13:03:52 <loocorez> hahaha fair enough :P
13:06:11 <ktklam9> I just have a very simple about Parsec, how can I parse the rest of the line following the word "foo"?
13:06:22 <ktklam9> *read the rest of the line
13:06:36 <mauke> string "foo" >> many (noneOf "\n")
13:06:39 <mauke> or something like that
13:07:59 <DMcGill> is there a haskell debugger that doesn't involve building the package myself with some additional print statements?
13:08:10 <mauke> ghci, sort of
13:08:30 <levi> loocorez: Probably one of the more academic Haskell books would have more formal descriptions of how the language works, or there are any number of 'foundations of programming languages' kinds of texts out there.  I'm having a hard time thinking of a good one to start with, though.
13:09:10 <EvanR> levi: SICP?
13:09:23 <levi> Well, yes, but I was thinking of a Haskell context.
13:09:26 <loocorez> levi: No worries. I have a few friends who are obsessed with Haskell, when I get back to school I'll be able to nag them all the time about any questions I have.
13:09:38 <loocorez> :)
13:09:48 <EvanR> haskell obsession
13:09:49 <EvanR> .com
13:10:53 <levi> I can think of a few good ones like SICP, EOPL, CTM that mostly deal with dynamically-typed languages.  There's Types and Programming Languges, but it might not be the best first text.
13:11:08 <ktklam9> mauke: one last question, how can I read the line until the word "foo" appears?
13:11:49 <mauke> look for the combinator corresponding to *? in regexes, I forget what it's called
13:12:05 <c_wraith> kleene star?
13:12:06 <ktklam9> mauke: well with Parsec?
13:12:12 <mauke> ktklam9: yes
13:12:18 <mauke> c_wraith: no, that's *
13:12:21 <mauke> a.k.a. 'many'
13:12:28 <mauke> ... manyTill?
13:12:43 <c_wraith> oh.
13:12:54 <levi> loocorez: Those are 'Structure and Interpretation of Computer Programs', 'Essentials of Programming Languages', and 'Concepts, Techniques, and Models of Computer Programming' in case you are interested.  The first two use Scheme as the implementation language, the last uses an odd one called Oz, but covers a lot of very useful ground with it.
13:13:46 <loocorez> Thanks! I'll definitely keep a note of it, they may be useful in some coursework I plan on taking this coming up year.
13:14:08 <EvanR> some of the stuff in sicp is applicative to haskell, at least it explicitly states that their evaluation strategy is strict
13:14:19 <EvanR> and theres some words in there about laziness
13:14:36 <EvanR> s/applicative/applicable/
13:15:32 <EvanR> would be nice to see a intro to programming book which uses haskell-like language
13:16:42 <c_wraith> there's at least Graham Hutton's
13:16:47 <ktklam9> mauke: gaah, very last question I promise, how can I skip result until "foo" is found?
13:17:02 <mauke> ktklam9: isn't that the same question?
13:17:07 <EvanR> ya
13:17:30 <ktklam9> mauke: so I can ignore the result if I do >> ?
13:18:22 <EvanR> or do notation
13:19:57 <ktklam9> ah yes, thank mauke and EvanR, you guys have been a great help :)
13:26:49 <johnw> luite: where am I going wrong here... https://gist.github.com/3278150
13:27:01 <johnw> it says "git-all: thread blocked indefinitely in an MVar operation"
13:27:14 <johnw> i linked with -threaded, and ran with GHCRTS=-N2
13:29:35 <luite> johnw: you read the chan again for each argument?
13:29:58 <johnw> for each argument to my code, I do another forkIO
13:30:02 <johnw> should I also create a new Chan?
13:30:34 <luite> johnw: no
13:30:58 <luite> one problem here though is that you never know when you're finished
13:31:16 <johnw> interesting
13:31:24 <johnw> that makes sense
13:31:45 <johnw> I probably have to use Maybe, and wait for Nothing
13:32:04 <danil> johnw: right, that error is the RTS telling you that all the other threads that had access to the channel have ended
13:32:20 <johnw> nice
13:33:21 <danil> (that's one reason getChanContents feels a little sketchy to me)
13:34:14 <danil> but yeah, you can make it a Chan (Maybe FilePath) and count the Nothings until you know everyone's done
13:41:34 <levi> EvanR: SICP does have a section on programming with lazy lists (which it calls streams)
13:44:00 <johnw> ok, I'm getting lost in Monad hell here
13:44:01 <johnw> https://gist.github.com/3278254
13:44:13 <nand`> HellT?
13:44:26 <johnw> in my call "mapM_ (\x -> x >>= processDirectory) cs", I'm trying to take the value in the Maybe monad and bind it to processDirectory
13:44:36 <johnw> which I guess is already wrong, because processDirectory doesn't return a Maybe a
13:44:37 <shachaf> johnw: Instead of using setNumCapabilities you should probably run with +RTS -N. :-)
13:44:52 <johnw> shachaf: that would just be lame; I only ever need it to be 2...
13:45:00 <shachaf> johnw: I think you want (\x -> processDirectory x)
13:45:17 <johnw> but x then is a Maybe FilePath, not a FilePath
13:45:26 <johnw> right?
13:45:27 <shachaf> Oh.
13:45:38 <mauke> why do you have Maybe FilePath?
13:45:39 <nand`> then you want fmap processDirectory
13:45:42 <nand`> or something
13:45:43 <shachaf> Well, \x -> case x of Nothing -> return (); Just x' -> processDirectory x'
13:45:48 <johnw> so that I can return Nothing to know when the thread is done
13:45:52 <shachaf> Or something with maybe.
13:46:02 <shachaf> But, yes, why does your Chan have Maybe FilePath in the first place?
13:46:06 <shachaf> Oh.
13:46:09 <nand`> traverse seems more appropriate actually
13:46:16 <johnw> ahhh
13:46:19 <johnw> I was missing the return () before
13:46:20 <johnw> thanks!
13:46:23 <shachaf> Well, mapM_ probably won't work, then.
13:46:24 <johnw> i was just using return
13:46:28 <danil> johnw: you can't use mapM_ if you want to stop early
13:46:33 <EvanR> class MonadHell
13:46:34 <shachaf> johnw: I doubt what I said will work.
13:46:40 <johnw> let's try this
13:46:52 <johnw> no, since doesn't "end"
13:46:57 <johnw> so, if I have a list of Maybes
13:47:11 <johnw> is there a way to bind over it so that it "short-circuits" when Nothing occurs?
13:47:25 <shachaf> You should probably abstract this into a FiniteChan or something.
13:47:34 <shachaf> Rather than mixing it up into your code.
13:47:35 <EvanR> johnw: a list of Maybe a?
13:47:39 <johnw> EvanR: yes
13:47:42 <nand`> johnw: you mean like [Maybe a] -> Maybe [a] -- ?
13:47:45 <johnw> I may not even be doing this write at all
13:47:47 <johnw> [Maybe a]
13:47:48 <EvanR> johnw: then you dont want to use Monad
13:47:55 <mauke> spork (Just x : xs) = x : spork xs; spork _ = []
13:47:56 <EvanR> :t catMaybes
13:47:57 <lambdabot> forall a. [Maybe a] -> [a]
13:48:10 <shachaf> Anyway, what mauk said.
13:48:10 <mauke> how can I simplify spork?
13:48:19 <luite> johnw: it's probably easier if you use readChan instead of getChanContents
13:48:21 <EvanR> :t First
13:48:22 <lambdabot> forall a. Maybe a -> First a
13:48:27 <nand`> > Data.Traversable.sequence [Just 3, Just 4]
13:48:29 <lambdabot>   Just [3,4]
13:48:30 <nand`> > Data.Traversable.sequence [Just 3, Just 4, Nothing]
13:48:31 <lambdabot>   Nothing
13:48:43 <johnw> ah
13:48:53 <johnw> use readChan and recursion?
13:49:08 <EvanR> repeatedly readChan
13:49:20 <EvanR> you dont necessarily need recursion explicitly
13:49:29 <luite> johnw: right, recurse with some parameter n that indicates the number of running threads
13:49:30 <mauke> ಠ_ಠ
13:49:33 <jjbohn|lunch> back
13:49:58 <monochrom> spork = foldr [] (\ j r -> case j of Just x -> x : r; _ -> [])   not sure if it is a simplification :)
13:50:07 <monochrom> @type maybe
13:50:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:50:27 <mauke> it isn't
13:50:39 <mauke> it's a type error
13:50:42 <shachaf> foldr (\x xs -> maybe [] (:xs) x) []
13:50:55 <shachaf> > foldr (\x xs -> maybe [] (:xs) x) [] [Just 1, Just 2, Just 3, Nothing, Just 4]
13:50:56 <lambdabot>   [1,2,3]
13:51:17 <monochrom> @pl (\j r -> maybe [] (: r) j)
13:51:18 <lambdabot> flip (maybe [] . flip (:))
13:51:29 <shachaf> No thanks.
13:51:46 <monochrom> yeah, not going there :)
13:51:59 <edwardk> :t Data.Maybe.catMaybes
13:52:01 <lambdabot> forall a. [Maybe a] -> [a]
13:52:02 <paolino> > catMaybes $ takeWhile isJust [Just 1, Just 2, Just 3, Nothing, Just 4]
13:52:03 <lambdabot>   [1,2,3]
13:52:07 <monochrom> so, I guess the original two-line pattern-matching version is already pretty good
13:52:09 <shachaf> Hah, paolino++
13:52:31 <latro`a> catMaybes . takeWhile isJust is probably slightly more efficient as map fromJust . takeWhile isJust
13:52:35 <johnw> hey, it works!
13:52:38 <latro`a> (though obviously partial functions are a bit ugly)
13:52:40 <shachaf> latro`a: Really?
13:52:46 <Twey> latro`a: No, stream fusion
13:52:47 <nand`> > catMaybes [Just 1, Just 2, Nothing]
13:52:48 <lambdabot>   [1,2]
13:52:51 <johnw> https://gist.github.com/3278351
13:52:55 <Twey> I'm pretty sure
13:52:57 <shachaf> latro`a: Why is it more efficient?
13:53:03 <nand`> oh
13:53:13 <latro`a> won't catMaybes try to match on Nothing first?
13:53:15 <johnw> in my use of "case/of" in that pastie, I feel almost certain that has been abstracted already
13:53:17 <latro`a> at each step?
13:53:25 <shachaf> latro`a: Won't fromJust have to check for Nothing too?
13:53:27 <johnw> does that smell familiar?
13:53:34 <latro`a> no, fromJust will just fail
13:53:42 <EvanR> :t breakOn
13:53:42 <latro`a> rather, it will definitely match on Just first
13:53:43 <lambdabot> Not in scope: `breakOn'
13:53:47 <EvanR> :t break
13:53:48 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:53:50 <shachaf> "first"?
13:53:58 <shachaf> @src fromJust
13:53:59 <lambdabot> fromJust Nothing  = undefined
13:53:59 <lambdabot> fromJust (Just x) = x
13:54:01 <latro`a> oh
13:54:02 <latro`a> huh
13:54:03 <Twey> latro`a: It won't segfault: it still checks the failure case
13:54:07 <EvanR> > fst . break isNothing
13:54:08 <lambdabot>   Overlapping instances for GHC.Show.Show
13:54:08 <lambdabot>                              ([Data...
13:54:26 <latro`a> why do I think that's not the GHC definition...
13:54:32 <luite> johnw: now you're still processing them sequentially
13:54:32 <latro`a> for one thing fromJust has a custom error in GHC
13:54:40 <EvanR> :t fst . break isNothing
13:54:41 <lambdabot> forall a. [Maybe a] -> [Maybe a]
13:54:49 <shachaf> latro`a: If we're getting into GHC definitions, then we have to get into how GHC compiled code. :-)
13:54:55 <luite> johnw: the second findDirectories only starts when the first mapDirectories has finished
13:54:56 <johnw> the channel sin't being populated in parallel?
13:54:57 <latro`a> touche
13:55:09 <johnw> luite: yes, that part is OK
13:55:19 <johnw> the most common use case for this utility will only pass in a single directory
13:55:20 <shachaf> I think "fromJust will be more efficient" is a weird thing to say because they both check for both cases.
13:55:34 <latro`a> I assumed fromJust checked Just first and then marched onward
13:55:44 <latro`a> but then catMaybes could certainly check Just first
13:55:47 <latro`a> and probably does
13:55:49 <shachaf> GHC definition, out of base: fromJust          :: Maybe a -> a; fromJust Nothing  = error "Maybe.fromJust: Nothing" -- yuck; fromJust (Just x) = x
13:56:00 <johnw> but making it all parallel is an easy change...
13:56:01 <shachaf> latro`a: Are you sure there's even an element of "first" here?
13:56:07 <latro`a> huh?
13:56:12 <latro`a> pattern matches are definitely sequential
13:56:15 <shachaf> I mean, you have a number which is either 0 or 1, presumably.
13:56:22 <shachaf> Well, maybe not that.
13:56:23 <luite> johnw: hmm, the channel is not really required then, you could just process the list in findDirectories directly
13:56:35 <shachaf> You have an indirect jump probably. :-)
13:56:49 <EvanR> @src break
13:56:49 <lambdabot> break p =  span (not . p)
13:57:12 <EvanR> :t span
13:57:13 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:57:18 <danil> johnw: that's using as many threads as you have input dirs (which is probably what you want?), but you'll want to count the Nothings instead of stopping on the first one
13:57:50 <shachaf> latro`a: Their semantics are sequential when you have overlapping patterns.
13:58:01 <shachaf> But semantics /= implementation, and there are no overlapping patterns here at any rate.
13:58:02 * nand` .oO ( @src span ==> span p = break (not . p) )
13:58:02 <danil> johnw: oh wait, you have a new chan for each one now, never mind
13:58:06 <latro`a> ah
13:58:11 <latro`a> so the implementation can be cleverer
13:58:19 <latro`a> if the patterns don't overlap
13:58:20 <latro`a> neat
13:58:24 <shachaf> Also, GHC compiles code into something very different from what you'd think.
13:58:49 <danil> johnw: in that case you are doing it sequentially -- you don't spawn the next thread until the previous mapDirectories finishes
13:58:50 <latro`a> I'm always intimidated as hell when I try to read about GHC's insides
13:59:04 <luite> shachaf: realli?
13:59:05 <shachaf> latro`a: The STG machine paper isn't about GHC, but it's pretty readable.
13:59:19 <shachaf> luite: Well, maybe not different from what *you'd* think. :-)
13:59:35 <EvanR> ghc is secretly powered by the life force of a sacrificed orphan
14:00:01 <EvanR> normal functional programming implementation principles dont apply
14:00:03 <c_wraith> only one orphan? That's not too bad.
14:00:06 <frigga> I'm doing GHC generics and have "instance Foo (K1 R c) where fooFunc x = ...".  Is it possible to get the data type of c as a String?
14:00:19 <nand`> every time you generate a type error, GHC sacrifices a kitten
14:00:19 <shachaf> c_wraith: It's actually an orphan instance.
14:01:11 <johnw> ok, I changed it to this: https://gist.github.com/3278419
14:01:21 <johnw> now all the finding in sequential, but the processing happens in parallel
14:01:48 <shachaf> johnw: The processing happens in parallel?
14:01:57 <johnw> the body of processDirectory
14:02:01 <johnw> which just does a putStrLn right now
14:02:02 <johnw> am I right
14:02:03 <johnw> ?
14:02:25 <shachaf> Maybe you mean "concurrently" instead of "in parallel", but I'm not sure it's doing either.
14:02:34 <shachaf> Why would it?
14:02:36 <shachaf> Oh, wait.
14:02:42 <johnw> i mean concurrently
14:02:47 <luite> johnw: it would if you had forkIO (f x) instead of f x in mapDirectories
14:03:01 <shachaf> You mean "to the finding" or "to other processing code"?
14:03:05 <johnw> it's not enough that I forked findDirectories?
14:03:17 <shachaf> Except you probably don't want forkIO, you want spawn/async/something. :-)
14:03:19 <johnw> i want finding to happen on one thread, and processing the results of the find to happen on a second thread
14:03:28 <luite> johnw: no you have one findDirectories thread, and the other thread reads the findDirectories results from the channel
14:03:35 <shachaf> johnw: OK, but only processing one thing at a time?
14:03:38 <johnw> yes
14:03:47 <luite> johnw: so while processing and scanning run concurrently, you only process one thing at a time
14:03:54 <johnw> correct
14:03:57 <johnw> which I actually want
14:04:01 <luite> right if that's what you want then great :)
14:04:02 <shachaf> I doubt using two GHC capabilities is going to speed that up much, by the way.
14:04:04 <johnw> I just don't want to ever be blocked waiting on the next find result
14:04:17 <johnw> (unless the find has become really, really slow)
14:04:36 <johnw> I'd like processDirectory to consume results as soon as they are available, being produced by a second thread
14:04:43 <johnw> so, I _think_ this is what I want, yeah?
14:04:47 <EvanR> uhm no
14:04:57 <EvanR> if you do it all in the same thread, then you have accomplished what youre saying
14:05:15 <EvanR> unless your processing is way slower than the file system
14:05:30 <johnw> thread #1 produces a list (via find, slow), thread #2 consumes the list (also slow)
14:05:38 <johnw> thread #1 and #2 happen concurrently now, yes?
14:06:06 <EvanR> well, your whole laundry is going to go as fast as the slowest stage in the pipe line
14:06:12 <shachaf> Yes, that's what the forkIO does.
14:06:21 <EvanR> if the fs is slow, you go that slow
14:06:28 <EvanR> your processing will run out of input
14:06:32 <johnw> my end goal is to shell out to git in thread #2 to find out if there's anything I haven't pushed in any of my repositories.  The thing is, I have millions of files, so the "find" operation takes almost as long as shelling out to "git" for every repository within those files
14:07:01 <johnw> that's why I made the Ruby version use popen, and it pretty much halved the runtime of the script
14:07:06 <mekeor> "a hackage" or "an hackage"?
14:07:14 <EvanR> lol
14:07:18 <nand`> I'd say ‘a’
14:07:21 <mekeor> ok
14:07:30 <mekeor> ty
14:07:35 <EvanR> if you were proper youd say 'an hackage' even though we say the h sound
14:07:39 <nand`> unless you want to pronounce it “an 'ackage”
14:07:48 <mekeor> heh.
14:07:52 <mekeor> i'm not french. :D
14:07:54 <nand`> it's “learn you a haskell”, not “learn you an haskell” after all
14:07:56 <nand`> :P
14:07:58 <EvanR> an historical analysis
14:08:08 <nand`> EvanR: that looks wrong to me
14:08:11 <EvanR> haha
14:08:15 <nand`> maybe it's just my mind preconditioned to making sense
14:08:18 <EvanR> of course, you arent sophisticated
14:08:18 <nand`> I reject stuff like ‘centre’
14:08:36 <mekeor> an akage. -- imagine how a french says "an hackage". :)
14:08:42 <slack__> main: <<loop>>
14:08:49 <slack__> how does ghc detect infinite loop?
14:08:56 <luite> slack__: black holes
14:09:07 <shachaf> slack1256: If it tries to evaluate "x" while it's in the process of evaluating "x", it's a <<loop>>.
14:09:09 <mekeor> slack1256: does it?
14:09:12 <luite> slack1256: it overwrites thunks being evaluated with a special value
14:09:12 <EvanR> it uses the dead soul of an orphan, i reiterate
14:09:25 <luite> slack1256: if it encounters that during evaluation, and it's written by the same thread, then it's a loop
14:09:26 <shachaf> It's not something you should rely on, it's just a nicer error than hanging.
14:09:42 <slack1256> yeah. but seem awfully smart.
14:09:42 <carter> mekeor: thanks for yesterday :)
14:09:51 <EvanR> it theoretically cant detect all infinite loops
14:09:54 <carter> i'm still a bit exhausted,
14:09:54 <EvanR> just some
14:09:56 <mekeor> carter: what…? did i do?
14:10:08 <carter> weren't you running the testing suite?
14:10:11 <carter> one of the folks
14:10:18 <carter> thats still helping
14:10:24 <mekeor> yup
14:10:26 <mekeor> :D
14:10:44 <carter> if it weren't for y'all getting OOM, i'd not have found the dimension problem in the test suite
14:11:00 <mekeor> nice.
14:11:33 <slack1256> EvanR: yeah this type of loop seem straight forward to detect.
14:11:34 <Cale> luite: wait, <<loop>> happens in the threaded runtime now?
14:12:00 <slack1256> Cale: the <<loop>> appeared in a threaded program of mine.
14:12:12 <Cale> cool
14:12:13 <mauke> slack1256: your program doesn't matter
14:12:16 <mauke> the runtime does
14:12:22 <carter> mekeor: now I just need to sort sparse lin algebra support
14:12:27 <carter> 'cause theres nothing good for that
14:12:31 <carter> but its really really really important
14:12:33 <slack1256> the programs was compiled using threaded, sorry
14:12:35 <luite> Cale: oh i meant haskell threads, not capabilities
14:12:36 <shachaf> Cale: Yes, but I think it only happens on GCs, not instantly.
14:13:00 <luite> shachaf: eager blackholing does it immediately
14:13:02 <mekeor> What is <<loop>>?
14:13:06 <Cale> Nice, it does work, even on the tightest loop possible
14:13:16 <luite> lazy writes them later, i thought at scheduling, but perhaps you're right and it's only at GC
14:13:21 <Cale> (in the threaded runtime)
14:13:59 <shachaf> luite: Ah, hmm.
14:14:01 <c_wraith> not cool
14:14:11 <EvanR> whats the simplest way to defeat that loop detection strategy
14:14:11 <copumpkin> mekeor: GHC detecting an infinite loop in some conditions
14:14:12 <c_wraith> My coworker is reporting <<loop>> on things that aren't actually looping
14:14:17 <c_wraith> in the threaded runtime
14:14:18 <copumpkin> why would you want to defeat it?
14:14:37 <mekeor> copumpkin: (why) does ghc detect infinite loops?
14:14:43 <slack1256> copumpkin: SCIENCE MUAAAHAHA!
14:14:44 <EvanR> copumpkin: to get experience points and some treasure
14:14:56 <copumpkin> when someone is evaluating a thunk they mark that they're doing so. If during evaluation, they get back to a thunk they marked as "in progress", it's a sign of infinite loop
14:14:57 <copumpkin> or something like that
14:15:01 <c_wraith> detecting infinite loops in the non-threaded runtime is just an accident of lazy evlauation
14:15:05 <Cale> mekeor: Because the way that the evaluator works automatically presents an opportunity to detect them.
14:15:12 <c_wraith> the problem is that in the threaded runtime, that test is invalid
14:15:27 <copumpkin> yeah, not sure why it's even turned on
14:15:28 <c_wraith> So my coworker reports spurious <<loop>> crashes
14:15:34 <mekeor> Cale: following the principle "i do what i can"?
14:15:35 <shachaf> c_wraith: The sorts of loops it detects probably wouldn't even come up if it wasn't for lazy evaluation. :-)
14:15:45 <shachaf> c_wraith: Spurious <<loop>>s? Are you sure?
14:15:51 <Cale> mekeor: If it's beneficial and essentially free to do, why not? :)
14:16:04 <mekeor> Cale: beneficial? how?
14:16:06 <paolino> yes, they happened to me also
14:16:16 <luite> mekeor: it has to actually, to some extent. if some other thread is already evaluating, the current thread should sleep an wake up when it's done
14:16:16 <Cale> mekeor: It replaces a hang by an error message
14:16:18 <EvanR> ...
14:16:20 <copumpkin> mekeor: it's better being told you have an infinite loop than just waiting for the infiinte loop to finish
14:16:22 <c_wraith> shachaf: when the presence of absence of <<loop>> depends on what value of -N was passed to the RTS, that's spurious
14:16:44 <c_wraith> err, *or* absence
14:16:45 <shachaf> c_wraith: Are you sure about that?
14:17:00 <mekeor> i see. nice, thanks.
14:17:02 <shachaf> I mean, does it otherwise just go into an undetected infinite loop? Or does it accomplish something?
14:17:09 <EvanR> so there is a serious bug in ghc?
14:17:11 <c_wraith> shachaf: it works without it.
14:17:20 <Cale> c_wraith: weird
14:17:40 <EvanR> N=1 fixes the problem?
14:17:48 <EvanR> or avoids triggering it?
14:17:49 <shachaf> c_wraith: Do you have a simple test case for that?
14:17:50 <Cale> c_wraith: maybe it's not greyholing correctly now?
14:19:53 <Cale> My guess is that there's an expression whose evaluation is demanded by two threads almost simultaneously, because if there's a bug in how black/greyholing works, it's almost certainly there.
14:20:34 <paolino> Cale, they happened randomly on a server. I had to turn off -threaded.
14:21:27 <johnw> is there a foldM that folds over the results of a functions, rather than over a list?
14:22:02 <Cale> johnw: What would its type be?
14:22:08 <johnw> one sec
14:22:08 <mauke> johnw: what does that even mean?
14:22:09 <danil> johnw: something like iterateM?
14:23:22 <c_wraith> paolino: out of curiosity, what version of ghc?
14:23:55 <EvanR> Int -> X is like [X] ;)
14:24:37 <nooodl> holy shit, i just used `mappend` in a program for the first time, i feel like a wizard
14:24:53 <EvanR> nooodl: checkout (<>)
14:24:56 <EvanR> :t mappend
14:24:58 <lambdabot> forall a. (Monoid a) => a -> a -> a
14:25:01 <EvanR> :t (<>)
14:25:02 <lambdabot> Doc -> Doc -> Doc
14:25:05 <shachaf> EvanR: More like ([X],[X])!
14:25:05 <EvanR> dammit >_<
14:25:15 <shachaf> Well, I guess it could be either.
14:25:21 <nooodl> EvanR, let me hoogle that
14:25:22 <Peaker> shachaf, which is like [X] if interlaced
14:25:41 <nooodl> nope, not finding it
14:25:52 <EvanR> nooodl: its in Data.Monoid, (<>) = mappend
14:26:00 <paolino> c_wraith: I have to check , it was 2010, and I'm not even sure if it went away with a new version of hdbc.
14:26:05 <Cale> http://i.imgur.com/kfy8m.jpg -- ahaha
14:26:09 <shachaf> Peaker: Right.
14:26:29 <nooodl> cards.hs:51:33: Not in scope: `<>'
14:26:34 <nooodl> apparently not :(
14:27:02 <EvanR> nooodl: version?
14:27:14 <Peaker> Cale, it's easier to avoid 'c' altogether
14:27:15 <nooodl> 7.0.3
14:27:15 <johnw> hmm
14:27:24 <EvanR> i have 7.4.1
14:27:25 <johnw> ok, writing the type decl makes me realize I'm not sure how to express what I want
14:27:27 <nooodl> wait, that's pretty ancient
14:27:28 <nooodl> haha
14:27:47 <EvanR> you can also define it yourself
14:27:54 <nooodl> i should definitely update though
14:28:06 <paolino> c_wraith, my real problem was I couldn't guess how to make a test case, so I gave up -threaded.
14:28:12 <johnw> i have this readChan call that returns IO Maybe FilePath.  I want a "mapM_" type expression that calls my function that takes FilePath for every call of readChan that returns Just x.  I just figure this is a solved thing
14:28:25 <EvanR> IO (Maybe FilePath)
14:28:29 <johnw> yeah
14:28:31 <johnw> sorry
14:28:43 <johnw> kind of like "while readChan returns Just x, call f x"
14:28:54 <mauke> johnw: didn't we just do that?
14:28:59 <johnw> yeah, but it looked ugly
14:28:59 <EvanR> johnw: untilM
14:29:00 <danil> johnw: check out the monad-loops package if you want a combinator
14:29:03 <johnw> i'm just golfing now
14:29:07 <johnw> oh, cool, looking
14:29:37 <johnw> hey, whileJust_
14:29:41 <johnw> that's right up my alley
14:30:05 <EvanR> when the custom control structure you want doesnt exist, write it yourself!
14:30:16 <johnw> i would, I'm just still such a newbie!
14:30:21 <johnw> reading LYAH for the 3rd time
14:30:40 <mekeor> i have to read RWH.
14:30:50 <sm> go johnw.. hey monad-loops looks great
14:30:55 <mekeor> i think, when you completely read RWH, you truely know haskell.
14:31:16 <luite> mekeor: i doubt it...
14:31:39 <EvanR> lol
14:31:41 <paolino> c_wraith, 6.12.1
14:31:42 <janua> Hello, is it possible to have function called in the left side of expressions of a case statement?
14:31:58 <EvanR> view patterns
14:32:24 <mekeor> luite: hm, right. truly knowing Haskell is … like … almost impossible. it takes years, right?
14:32:26 <EvanR> you can also use functions in guards
14:32:54 <luite> mekeor: dunno, i've been trying for a few years now but i'm still a n00b :p
14:33:04 <mekeor> luite: oO
14:33:20 <mekeor> luite: i'm quite sure you know quite lot of things.
14:33:22 <EvanR> dont worry some people have been trying to learn c++ for 20 years and are still noobs
14:33:46 <johnw> see, I _knew_ you guys had already solved this!
14:33:58 <johnw> my recursive definition of mapDirectories turned into: whileJust_ (readChan c) (processDirectory [])
14:34:27 <johnw> which is actually what I felt it should be.  I guess that's a good sign
14:34:53 <nooodl> i'm at the scary gate of "understanding monads". i'm reading the LYAH chapters on monads, but so far it's been nothing like what other monad tutorials have been talking about
14:35:09 <sm> would conduit/filesystem-conduit/process-conduit help johnw's project, or just complicate it ?
14:35:35 <EvanR> monad tutorials are required to be misleading, incomplete
14:35:40 <EvanR> missing the point
14:35:44 <sipa> nooodl: and when you finally get it, you'll say "oh, it's just that?"
14:36:00 <nooodl> yeah, probably
14:36:07 <johnw> the hardest thing I found about Monads is that the abstraction is so high, any attempt to cast them into an analogy will fail you in some way down the road
14:36:11 <sipa> unfortunately, you have to discover that yourself; every tutorial will make you think it's more than what it is
14:36:28 <johnw> really they're just a concept, and what that concept means depends on the particular Monad
14:36:45 <nooodl> the thing is you don't go from zero to understanding monads. LYAH handles it really well by adding layers of abstraction all the time
14:36:54 <nooodl> (lists -> functors -> applicative functors -> monads)
14:36:54 <timtheli1n> How do I readFile(to get header info, I just need 10 characters to tell me if it's a file I want to overwrite) and then writeFile if readFile locks the file? Do I have to read the entire file pointlessly?
14:37:04 <sipa> imho, you should first learn what IO is, without ever mentioning the word 'monad'; not sure how LYAH does it
14:37:18 <EvanR> timtheli1n: no, openFile and hGet 10 characters
14:37:19 <drewr> sipa: like that
14:37:26 <k0001> It's like every monad tutorial binds yet another one but they never return. /me runs away
14:37:27 <nooodl> yeah it does that
14:37:42 <sipa> ok, good :)
14:37:45 <nooodl> what i'm doing right now is completely ignoring the fact that IO and monads are related
14:37:50 <geekosaur> timtheli1n, and hClose it after.  lazy I/O is not the way to go for that kind of thing
14:38:01 <nooodl> and then when i understand what a monad really is all about i'll "link" them together
14:38:06 <EvanR> nooodl: its coincidence
14:38:06 <mauke> geekosaur: bracket
14:38:11 <timtheli1n> EvanR: Oh, I see, I didn't see the hGet function as it's in a section above where I was looking in the haddock
14:38:11 <Saizan> nooodl: make sure you understand typeclasses and higher order programming, then Monad will just be a specific (though very useful) interface with a bunch of specific (but quite interesting) instances
14:38:13 <nooodl> that worked really well for Functor
14:38:26 <EvanR> nooodl: IO doesnt require monads or vice versa
14:38:27 <sipa> well, IO is a data type for interacting with the outside would; Monad is a generalization of some of the aspects of IO
14:38:46 <mauke> actually, withFile
14:39:09 <timtheli1n> EvanR: YES, that's the biggest confusion with Monads, they are so often explainded as some magic that allows us to do IO, when Monads have nothing to do with IO.
14:39:19 <EvanR> right
14:40:02 <nooodl> you know what, i'll read some more about them right now
14:41:39 <timtheli1n> nooodl: I would recomend actually reading about Monads from the stand point of category theory.  Many programmers have written really incorrect things on the subject.  You should think of Monad as a type class(which is something very simple and you should understand) and then you should understand, secondly, the laws that are prescribed(not guaranteed, but prescribed) for that type class.
14:41:59 <EvanR> uhg category theory
14:42:03 <EvanR> to help haskell noobs
14:42:05 <EvanR> heh
14:42:09 <timtheli1n> it helped me :)
14:42:26 <latro`a> I'm not sure going all the way down the rabbit hole of adjunctions between functors will help newbies
14:42:27 <timtheli1n> better be confused by the truth, than to understand a deception
14:42:36 <johnw> I really recommend NOT reading about category theory
14:42:37 <latro`a> I do think that join/fmap are easier to grasp than >>=, however
14:42:44 <EvanR> when i started i did not understand type classes and it didnt seem very simple to me
14:42:58 <timtheli1n> EvanR: was haskell your first language?
14:43:04 <EvanR> no
14:43:06 <nooodl> i understood typeclasses quite easily
14:43:12 <nooodl> thought they were a really clever idea, even
14:43:13 <latro`a> it's a bit frustrating when join/fmap is much more verbose than >>=, however
14:43:15 <latro`a> (cf. Maybe)
14:43:20 <Reaga> what are some examples of popular programs made in haskell
14:43:26 <nooodl> darcs
14:43:29 <latro`a> xmonad
14:43:31 <Reaga> or is it just a language that is never used for real programs ?
14:43:36 * Reaga :D
14:43:41 <EvanR> popular programs
14:43:46 <nand`> ghc
14:43:46 <EvanR> not unpopular programs
14:44:03 <mekeor> xmonad
14:44:05 <mauke> only popular programs are real, obviously
14:44:08 <mekeor> oh, yeah.
14:44:13 <EvanR> popular programs: the ##c++ bot geordi ;)
14:44:28 <timtheli1n> lambdabot:
14:44:28 <nooodl> darcs is probably the most popular one? not sure
14:44:28 <Reaga> what ?
14:44:37 <Reaga> is there no popular programs made in haskell ??
14:44:41 <taylorgb> I would suppose that there is a large community effort working on libraries for Haskell right now
14:44:51 <timtheli1n> Reaga: nope. not a single one.
14:44:51 <EvanR> avoid success at all costs
14:44:55 <mekeor> pandoc
14:45:01 <Reaga> timtheli1n: why not??
14:45:10 <nand`> because Haskell sucks
14:45:13 <nand`> clearly
14:45:18 <EvanR> lol
14:45:20 <mauke> Reaga: because you've ignored all answers?
14:45:28 <Reaga> i didnt recognise any
14:45:30 <nooodl> the most popular haskell program is main = putStrLn "Hello World". that's as far as it goes
14:45:36 <mekeor> @remeber nand` Haskell sucks
14:45:37 <lambdabot> I will remember.
14:45:46 <mauke> @forget nand` Haskell sucks
14:45:46 <lambdabot> Done.
14:45:59 <mekeor> @remeber nand` Haskell sucks
14:45:59 <latro`a> remeber?
14:46:00 <lambdabot> Done.
14:46:01 <latro`a> why does that
14:46:02 <latro`a> what
14:46:04 <mekeor> :D
14:46:05 <nooodl> latro`a, i just wondered
14:46:06 <nand`> ?
14:46:07 <latro`a> why is it spelled wrong
14:46:11 <timtheli1n> Reaga: well, we had this great breakthrough a few years ago, when some guys wrote the perl6 interpreter in like 2 months in haskell.  And then some people looked at the code and saw all these >>='s, and some other people did some bench marks, and it was collectively decided by the perl guys that haskell sucks.  And so it was.
14:46:13 <EvanR> wwwwaaaht
14:46:25 <lambdas> What about: forever (putStrLn "lambdas is skill")
14:46:32 <Reaga> timtheli1n: what are you getting at
14:46:38 <S11001001> @faq can haskell suck?
14:46:39 <lambdabot> The answer is: Yes! Haskell can do that.
14:46:53 <EvanR> lol 'collectively decided by the perl guy'
14:46:57 <nand`> S11001001: that might be lewd
14:46:59 <timtheli1n> Reaga: perl guys have brightly collored ties.  that goes way farther in the way of influencing people than anything else.
14:47:03 <Reaga> @faq can haskell solve the halting problem?
14:47:03 <lambdabot> The answer is: Yes! Haskell can do that.
14:47:24 <Reaga> colored
14:47:27 <levi> Pandoc is fairly popular, too.
14:47:56 <EvanR> haskell can trivially solve the halting problem, give it an expression. if it does not halt you will get _|_
14:48:31 <nand`> but you have to be outside of the system to make those observations
14:48:34 <nooodl> halts = (==_|_)
14:48:38 <nooodl> where's my million dollars
14:48:53 <nooodl> ... i mean /= :(
14:49:01 <EvanR> isFinite :: [a] -> Bool
14:49:13 <EvanR> True, False, or _|_
14:49:28 <dmwit> Dude, the million-dollar prize is for P?=NP, not for solving the halting problem. Easy mistake to make.
14:49:35 <EvanR> lol
14:49:44 <mauke> I've solved the problem for P = 0
14:49:49 <dmwit> divide by P on both sides, N=1, $million, plz
14:49:50 <Reaga> i know that P = NP
14:49:52 <nand`> I will give you a million dollars if you prove the continuum hypothesis
14:49:52 <Reaga> I know how to prove it
14:50:02 <nand`> within ZFC
14:50:02 <nooodl> mauke, i've solved it for N = 1, we should write a paper
14:50:07 <taylorgb> I could imagine the application problem is more related to the fact that applications are usually written by companies that make money and it is fairly rare to have haskell programmers in enough density with compliant managers such that a big project ends up being written in Haskell
14:50:22 <EvanR> P=NP if and only if P=0 and or N=1
14:50:27 <Reaga> you know theres a movie about what if P = NP was proved lol
14:50:42 <johnw> is there a Haskell equivalent to Python's ||?  I.e., I want to use a list if it has anything in it, else I want to use another list
14:50:42 <nooodl> shit, EvanR stole my $1000000
14:50:48 <Reaga> http://www.travellingsalesmanmovie.com/
14:50:58 <nand`> I think most of the industrial uses of Haskell are entirely hidden to the end user
14:51:14 <EvanR> johnw: if null foo then bar else baz
14:51:22 <newb09284> i have a new user question
14:51:29 <newb09284> is this the correct place?
14:51:30 <shapr> johnw: or something like the Maybe monad when you get further into Haskell.
14:51:32 <newb09284> for that?
14:51:33 <johnw> my situation is more like: if null (f x) then (f x) else ["."]
14:51:40 <dmwit> johnw: head ([x | null y] ++ [y | not (null y)])
14:51:41 <johnw> I guess i have to use let?
14:51:42 <nand`> newb09284: if it's Haskell-related, yes
14:51:56 <johnw> dmwit: uh, yeah... :)
14:52:06 <dmwit> oh, even better
14:52:11 <newb09284> the command (++ [1]) [2]
14:52:12 <dmwit> head ([x | null y] ++ [y])
14:52:23 <newb09284> yields [2,1]
14:52:23 <EvanR> johnw: case f x of
14:52:32 <EvanR> johnw: [] -> foo, xs -> bar
14:52:33 <nooodl> > (++ [1]) [2]
14:52:35 <lambdabot>   [2,1]
14:52:38 <nooodl> > ([1] ++) [2]
14:52:41 <lambdabot>   [1,2]
14:52:48 <johnw> there's no "select a b" where it chooses b if a is []?
14:52:55 <EvanR> case
14:53:10 <dmwit> johnw: We've given you at least two solutions.
14:53:18 <nooodl> newb09284, that might answer the question you're about to ask
14:53:21 <newb09284> what rule is used to shift the ++ operator
14:53:25 <nand`> > let select [] b = b; select a b = a in select [] [1,2]
14:53:26 <lambdabot>   [1,2]
14:53:27 <nand`> happy?
14:53:28 <EvanR> also
14:53:31 <johnw> dmwit: I didn't like them :)
14:53:37 <EvanR> :t fromJust
14:53:38 <lambdabot> forall a. Maybe a -> a
14:53:42 <EvanR> :t fromMaybe
14:53:43 <gwern> @quote
14:53:43 <lambdabot> forall a. a -> Maybe a -> a
14:53:43 <johnw> (case dirs opts of [] -> ["."]; xs -> xs)
14:53:43 <lambdabot> SteveYegge says: But I'll argue that Accessibility is actually more important than Security because dialing Accessibility to zero means you have no product at all, whereas dialing Security to zero
14:53:43 <lambdabot> can still get you a reasonably successful product such as the Playstation Network.
14:53:49 <dmwit> johnw: http://www.blogcdn.com/www.urlesque.com/media/2010/06/backpain-1277406949.jpg
14:53:49 <Reaga> HEY
14:54:00 <johnw> that just feels somewhat ugly
14:54:13 <danil> > find (not . null) ["", "more", "stuff"]
14:54:15 <lambdabot>   Just "more"
14:54:22 <EvanR> :t \a b -> fromMaybe b (listToMaybe a)
14:54:23 <nand`> newb09284: (a ++) is (\b -> a ++ b);  meanwhile (++ b) is (\a -> a ++ b)
14:54:24 <lambdabot> forall a. [a] -> a -> a
14:54:48 <EvanR> nevermind
14:55:01 <nand`> or alternatively, (a ++) is (++) a while (++ b) is flip (++) b
14:55:18 <johnw> listOr xs ys = (case xs of [] -> ys; x -> x)
14:55:19 <broombs> how do I get a String to read as a Text?
14:55:25 <nand`> :t Text.pack
14:55:27 <lambdabot> Couldn't find qualified module.
14:55:29 <nand`> bah
14:55:35 <dmwit> ?hoogle String -> Text
14:55:36 <lambdabot> Data.Text.Lazy pack :: String -> Text
14:55:36 <lambdabot> Data.Text pack :: String -> Text
14:55:36 <lambdabot> Prelude read :: Read a => String -> a
14:55:56 <dmwit> How smart is hoogle?
14:56:00 <dmwit> ?hoogle [Char] -> Text
14:56:00 <lambdabot> Data.Text.Lazy pack :: String -> Text
14:56:01 <lambdabot> Data.Text pack :: String -> Text
14:56:01 <lambdabot> Prelude error :: [Char] -> a
14:56:03 <dmwit> p. smart
14:56:09 <broombs> nand` & dmwit: yes of course.  But I'm seeing a string literal that typechecks as Text automatically. How does that work?
14:56:18 <dmwit> -XOverloadedStrings
14:56:22 <nand`> ^
14:56:34 <broombs> thanks!
14:56:39 <newb09284> nand` and nooodl: thank you, i was mistakenly thinking the prefix notation was being used
14:57:02 <nand`> oh, I see how that can be confusing yes
14:57:08 <nand`> (++ b) is entirely distinct from ((++) b)
14:57:19 <hpaste> betamine pasted “almost instant when compiled, still waiting for ghci” at http://hpaste.org/72709
14:57:20 <newb09284> that is where i went astray
14:57:38 <EvanR> johnw: decide if you want to pack it all together or write a function which does some reusable part of it and combine that with your particular use case
14:57:39 <betamine> can anyone tell why?
14:57:43 <nand`> betamine: ghci doesn't optimize very well
14:58:22 <betamine> nand`: yes, but the difference is between 3ms and >10 minutes
14:58:26 <EvanR> johnw: like [a] -> [a] -> [a], select [] b = b, select a _ = a
14:58:32 <nand`> betamine: that's entirely plausible
14:58:37 <johnw> yeah, I want something that provide's Python's ||
14:58:49 <johnw> for any x || y, return the value of x if it's not null, otherwise return y
14:59:03 <nand`> betamine: say you're summing a huge list; there will be a difference between adding 10000 numbers in place and constructing a 10,000-levels deep stack first
14:59:06 <c_wraith> johnw: that would make a lot more sense if haskell had nulls
14:59:07 <EvanR> johnw: i think youre confused whether you want to operator on lists or maybes
14:59:10 <dmwit> Why are you still whining. Just define (||) as we've shown you ten times now and move on with your life.
14:59:21 <johnw> dmwit: don't get snippy
14:59:22 <ion> @type ?x <|> ?y
14:59:23 <lambdabot> forall (f :: * -> *) a. (?x::f a, ?y::f a, Alternative f) => f a
14:59:24 <dmwit> You'll probably want to give it a different name to avoid the Prelude.
14:59:35 <johnw> doing this with List appends is just stupid
14:59:37 <ion> @type fromMaybe ?y ?x
14:59:38 <lambdabot> forall a. (?x::Maybe a, ?y::a) => a
14:59:40 <c_wraith> anyway, if you want that with Maybe a, you want <|>
14:59:49 <dmwit> So don't do it with list appends.
14:59:57 <c_wraith> > Nothing <|> Just 5
14:59:59 <lambdabot>   Just 5
15:00:04 <c_wraith> > Just 7 <|> Just 5
15:00:04 <dmwit> (Not that I see why it's stupid. Perhaps you're thinking it's O(n)? It's not.)
15:00:06 <lambdabot>   Just 7
15:00:07 <johnw> ah
15:00:08 <johnw> thanks
15:01:43 <EvanR> > [] <|> [3,4]
15:01:44 <lambdabot>   [3,4]
15:01:49 <nand`> > [1] <|> [3]
15:01:51 <lambdabot>   [1,3]
15:02:00 <EvanR> > [9] <|> [3,4]
15:02:01 <lambdabot>   [9,3,4]
15:02:11 <johnw> heh, is there <||>? :)
15:02:17 <c_wraith> Probably.
15:02:19 <EvanR> :t (<||>)
15:02:20 <lambdabot> Not in scope: `<||>'
15:02:28 <nand`> @hoogle <||>
15:02:28 <lambdabot> Text.Parsec.Perm (<||>) :: Stream s Identity tok => StreamPermParser s st (a -> b) -> Parsec s st a -> StreamPermParser s st b
15:02:28 <lambdabot> Text.ParserCombinators.Parsec.Perm (<||>) :: Stream s Identity tok => StreamPermParser s st (a -> b) -> Parsec s st a -> StreamPermParser s st b
15:02:32 <c_wraith> it's a legal operator symbol, so some library has surely used it
15:02:32 <nand`> there is
15:02:35 <c_wraith> like parsec, apparently
15:02:35 <EvanR> johnw: you still havent agreed on what the type of this operator is
15:02:43 <johnw> I thought it would be a -> a -> a
15:02:52 <dmwit> Oh, what?
15:02:54 <nand`> only possible way to implement that is const or const id
15:02:55 <EvanR> there arent many functions with the type a -> a -> a
15:02:57 <dmwit> I'm suddenly glad you're still here.
15:02:58 <c_wraith> johnw: that's impossible, since haskell doesn't have null
15:03:04 <johnw> where there should be a constracint to determine of the first argument is non-null/false/zero/whatnot
15:03:11 <johnw> yeah, I'm beginning to see that now
15:03:14 <lambdas> c_wraith: Yes it does. What's _|_?
15:03:16 <dmwit> Perhaps you want (a -> Bool) -> a -> a -> a?
15:03:24 <c_wraith> lambdas: the absence of a value.
15:03:24 <johnw> ahh
15:03:28 <johnw> dmwit: I like that!
15:03:33 <latro`a> you can also do it with fromMaybe, depending on context
15:03:37 <nand`> lambdas: ⊥ is not null
15:03:48 <dmwit> Probably even better to use (a -> Bool) -> a -> a -> Maybe a
15:03:49 <nand`> it means indeterminate, if anything
15:03:55 <EvanR> data WebNull = Zero | False | EmptyString | Undefined | EmptyList | EmptyObject | Null | Nil
15:03:58 <johnw> yay, that works
15:04:01 <danil> lambdas: it's a computation that doesn't halt, or an undefined value
15:04:02 <johnw> select :: (a -> Bool) -> a -> a -> a
15:04:02 <johnw> select f x y = if f x then y else x
15:04:02 <johnw>  
15:04:07 <lambdas> Well, it throws an exception when I try to use it, like null values in Java.
15:04:17 <nooodl> dmwit, i thought the whole point was to not use Maybe
15:04:20 <nand`> perhaps you are confusing _|_ with undefined
15:04:24 <nooodl> (else he could've jused used <|>)
15:04:28 <geekosaur> lambdas: ecept when it doesn't
15:04:29 <dmwit> nooodl: I have no idea what the whole point was.
15:04:38 <nand`> ‘undefined’ is not really _|_, it's a hack
15:04:41 <nooodl> haha, honestly, me neither
15:04:48 <johnw> although x and y should be reversed
15:04:53 <ion> “undefined = undefined” would be a totally fine implementation.
15:04:57 <EvanR> johnw: fromMaybe is usually how this is accomplished, a 'default value'
15:05:03 <ion> > let undefined = undefined in undefined
15:05:04 <nand`> ion: yes, that would be _|_ and I would agree with that
15:05:07 <lambdabot>   mueval-core: Time limit exceeded
15:05:17 <dmwit> Personally, I'm not sure johnw has figured out just what he wants yet, either. =)
15:05:25 <johnw> CmdArgs doesn't return stuff wrapped in Maybe
15:05:32 <johnw> johnw knows what he wants
15:05:46 <johnw> he wants (dirs opts), which might return [], to have a default value of ["."] if no dir is provided
15:05:47 <EvanR> dmwit: yeah originally he wanted the function to check f x then either return f x or something else
15:05:56 <nand`> johnw: solutions have been given
15:06:05 <johnw> and I'm using one now
15:06:09 <EvanR> johnw: so it operators on lists right
15:06:10 <nand`> case dir opts of [] -> ["."]; x -> x
15:06:19 <latro`a> that's the list version of fromMaybe
15:06:19 <EvanR> johnw: [a] -> [a] -> [a] ?
15:06:24 <dmwit> I feel confident that CmdArgs has a tool for providing default values to options that aren't required.
15:06:26 <latro`a> which is to say what nand` just said
15:06:28 <dmwit> And you should use that.
15:08:23 <johnw> how would I use the list version of fromMaybe, out of interest?
15:08:31 <nand`> what's the list version of fromMaybe?
15:08:38 <johnw> something latro`a said
15:08:46 <EvanR> whats the type of the list version of fromMaybe
15:09:00 <latro`a> eh, the [a] -> [a] -> [a] analog of fromMaybe
15:09:05 <nand`> I would guess
15:09:14 <ion> fromMaybe isn’t :: Maybe a -> Maybe a -> Maybe a.
15:09:16 <EvanR> foo [] ys = ys
15:09:19 <latro`a> there's ofc a fromMaybe default . listToMaybe
15:09:20 <EvanR> foo xs _ = xs
15:09:20 <nand`> :: b -> ((a, [a]) -> b) -> [a] -> b
15:09:20 <dmwit> fromList x xs = head (xs ++ [x])
15:09:21 <Clint> :t listToMaybe
15:09:22 <lambdabot> forall a. [a] -> Maybe a
15:09:41 <johnw> listToMaybe only returns the first element of a non-empty list
15:09:50 <dmwit> yes
15:09:56 <EvanR> see my foo function
15:10:10 <johnw> yes, your foo function is the same as the case above, right?
15:10:12 <nand`> the type signatute I gave is what I'd consider a ‘list equivalent’ of the fromMaybe signature
15:10:23 <nand`> sorry no, that would be ‘maybe’
15:10:24 <dmwit> I feel like somewhere there's a fundamental disconnect between what johnw is meaning to ask and the question we're hearing.
15:10:27 <nand`> I was mixing up fromMaybe and maybe
15:10:36 <johnw> dmwit: I'm beginning to think so too
15:10:47 <EvanR> johnw: another thing is that you might be thinking about it wrong, maybe you always want "." to be part of the list and youre really trying to represent 'extra dirs'
15:11:09 <johnw> I don't want "." to be a member of the list unless the list is empty
15:11:13 <dmwit> It's also possible there's a disconnect between the question johnw means to ask and the question that will help johnw the most.
15:11:23 <johnw> so, you can say "git-all" and it processes the current directory, or you can say "git-all /tmp" and it processes /tmp
15:11:33 <johnw> dmwit: yes, that's quite possible too! :)
15:11:40 <nand`> case dirs opts of [] -> ["."]; x -> delete "." x
15:11:49 <johnw> right now I have: select :: (a -> Bool) -> a -> a -> a
15:11:49 <johnw> select f x y = if f x then x else y
15:11:58 <johnw> and I call: select null (dirs opts) ["."]
15:12:09 <EvanR> johnw: see what nand` said, since you want something more complex and didnt say so, what he said makes most sense
15:12:22 <EvanR> you are factoring out something which isnt that useful
15:12:25 <dmwit> My guess is that dirs shouldn't return a [String] in the first place, but rather a Maybe [String].
15:12:34 <johnw> dmwit: totally agreed
15:12:43 <dmwit> So... fix it?
15:12:49 <johnw> fix the CmdArgs package?
15:12:51 <nand`> (my response was not entirely serious either way, I just interpreted “I don't want "." to be a member of the list” liberally
15:13:03 <dmwit> The cmdargs package lets you choose the types of your options.
15:13:07 <EvanR> nand`: well, its a good idea to be specific
15:13:09 <dmwit> ...I assume
15:13:19 <johnw> ok, I'll dive into the docs more
15:13:23 <Clint> http://hackage.haskell.org/packages/archive/cmdargs/0.9.6/doc/html/System-Console-CmdArgs-Default.html
15:13:30 <johnw> if I can get (dirs opts) wrapped in Maybe, it solves all the problems
15:14:18 <johnw> or even better, default to "." :)
15:14:39 <EvanR> weird application specific behavior provided by a stdlib ;)
15:14:47 <EvanR> welcome to php
15:14:51 <nand`> johnw: there's ‘opt’ in System.Console.CmdArgs.Implicit
15:15:07 <nand`> which allows you to make the value optional, and provide a default
15:15:11 <nand`> I suspect that might be what you really want
15:15:28 <Clint> no, that's an optional argument to a flag
15:15:37 <nand`> oh
15:16:33 <nand`> I remember using System.Console.GetOpt for options which definitely allows options to be optional entirely
15:16:35 <nand`> (with my own defaults)
15:16:47 <danil> likewise for CmdTheLine
15:18:13 <johnw> ok, silly me, opt is exactly what I needed
15:18:21 <johnw> just '&= opt "."', nothing more
15:18:36 <johnw> dmwit: your intuition of disconnect was exactly right
15:18:49 <johnw> often in Haskell I get stuck trying to solve the Wrong Problem
15:19:08 <nand`> it's generally a good idea when asking questions to give enough context to show the intended use case, because often there's a way better way of doing things
15:19:17 <nand`> especially when you're not used to thinking in Haskell
15:19:22 <Clint> hmm
15:19:30 <johnw> I thought I did: "so, you can say "git-all" and it processes the current directory, or you can say "git-all /tmp" and it processes /tmp"
15:19:52 <nand`> I must have missed that; I only saw your question about choosing lists
15:20:03 <johnw> is there a way with CmdArgs to have -h mean --help?
15:20:20 <EvanR> johnw: sounds good, make a function that returns the list of dirs to check using the cmdargs
15:20:23 <johnw> since I don't have to define --help myself, I don't have a way to give a name alias
15:20:29 <EvanR> johnw: you just wont breakdown and write a single pattern match ;)
15:20:40 <johnw> EvanR: heck no
15:20:44 <EvanR> [] -> ["."]
15:20:46 <EvanR> xs -> xs
15:20:48 <johnw> this is Haskell!  elegant should soothe me to sleep at night
15:20:53 <johnw> elegance
15:20:55 <johnw> unlike my writing
15:20:56 <nand`> pattern matching is elegant
15:21:00 <EvanR> the word elegance is off limits here
15:21:02 <nand`> when used correctly
15:21:03 <johnw> opt "." is moreso :)
15:21:06 <dmwit> Can I just say I'm with johnw on this one?
15:21:15 <dmwit> Because he persisted, he found out he was Doing It Wrong.
15:21:49 <nand`> again, it all depends on what problem you're trying to solve
15:21:55 <EvanR> how is he doing it wrong now
15:21:59 <sm> johnw: are you sure -h isn't automatically an alias for --help ?
15:22:05 <nand`> if you're trying to solve the problem of “picking lists based on whether or not one is empty”, pattern matching is an elegant solution
15:22:07 <johnw> all problems can be solved with sufficient time spent in #haskell
15:22:14 <johnw> sm: sadly it's not
15:22:17 <nand`> if you're trying to solve the problem of optional arguments with default values, it isn't :)
15:22:23 <sm> hmm, right you are
15:22:28 <johnw> oh, CmdArgs has a helpArg function
15:22:36 <johnw> helpArg [explicit, name "h"]
15:22:39 <johnw> that's just what I needed
15:22:51 <mekeor> so, with QuickCheck i can define conditions which my functions should fulfill, right?
15:23:06 <nand`> pretty much yea
15:23:24 <mekeor> nand`: why didn't you say "exactly"?
15:23:38 <nand`> not all conditions can be tested
15:23:40 <johnw> i must say, once the code actually works (and it took what, 3 hours to get here), the result is generally very pleasing to my aesthetic sensibilities
15:24:22 <thurloat> does anyone else use homebrew to install ghc on mac? is it known to be busted?
15:24:32 <EvanR> thurloat: i did
15:24:34 <EvanR> it was busted
15:24:47 <EvanR> i installed ghc myself and everything works
15:24:55 <mekeor> nand`: i have a function f and i want to test whether f x1 == r1 && f x2 == r2 && f x3 == r3; is QC the right thing for me then?
15:25:07 <mekeor> f is non-monadic.
15:25:08 <thurloat> lame and weak :( definitely used to brew being amgci all the time
15:25:40 <EvanR> i dont let package managers rule me
15:25:44 <EvanR> especially when they dont work
15:25:45 <nand`> mekeor: I don't think so, sounds like you want test cases
15:25:49 <nand`> not traits
15:26:04 <mekeor> yup.
15:26:10 <mekeor> nand`: so what do i need?
15:26:13 <nand`> there are other frameworks for that
15:26:17 <danil> mekeor: quickcheck lets you define properties like "forall x y z, <some function of x, y, and z returning a Bool>" and then check them on random x, y, and z
15:26:19 <dmwit> mekeor: I would want something like (and (zipWith (\x r -> f x == r) xs rs)) or so.
15:26:27 <dmwit> mekeor: You might look at hunit.
15:26:32 <strg> thurloat: installed it today, works so far.
15:27:52 <nand`> I've heard hunit mentioned before
15:27:52 <mekeor> dmwit: what is "cabal test"? do i want that?
15:27:57 <thurloat> @strg did you have to do anything special?
15:27:58 <lambdabot> Source not found. It can only be attributed to human error.
15:28:07 <nand`> I think cabal test is not specialized to any particular methodology of testing
15:28:14 <edwardk> nand`: about ready to push 1.5, feel like playing with it first?
15:28:15 <dmwit> mekeor: Yes, you want it. =)
15:28:32 <nand`> edwardk: you mean pushing to hackage?
15:28:33 <dmwit> mekeor: (But it doesn't replace hunit/quickcheck/smallcheck; it's for running them.)
15:28:34 <nand`> or to git?
15:28:40 <strg> thurloat: I had to tell homebrew to use llvm, and I had to edit the ghc script so some linker warnings get suppressed
15:28:43 <mekeor> dmwit: thanks :)
15:28:44 <edwardk> i pushed it to git, but i'm about to push to hackage
15:29:10 <edwardk> trying to minimize the number of versions i spam hackage with as the design gets more stable
15:29:11 <strg> thurloat: thats on mountain lion with the xcode commandline tools.
15:29:36 <thurloat> @strg ah! had to make it use llvm and it worked
15:29:36 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:29:45 <thurloat> thanks for the tip
15:29:51 <strg> welcome
15:29:58 <EvanR> lambdabot is not twitter compatible
15:30:34 <Cale> thurloat: btw, using @nick in this channel won't work well, because you'll confuse lambdabot. Better to use nick: or nick,
15:31:22 <thurloat> haha woops. poor lambdabot
15:32:12 <EvanR> > cake !! 41
15:32:14 <lambdabot>   "That will deodorize and preserve putrid tissue."
15:33:20 <mekeor> wtf.
15:36:23 * hackagebot happstack-foundation 0.1.0 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP (JeremyShaw)
15:38:44 <dmwit> > let (v, g) = randomR (0, length cake - 1) (mkStdGen 32) in cake !! v
15:38:46 <lambdabot>   "One teaspoon grated orange rhubarb."
15:38:57 <latro`a> WHAT
15:39:03 <dmwit> orange rhubarb, truly the finest variety of rhubarbm
15:39:18 <c_wraith> > cake !! 27
15:39:21 <lambdabot>   "Two slash three cups granulated rhubarb."
15:39:24 <latro`a> oh nvm
15:39:57 <dmwit> Does that mean I have a choice between two and three cups, or must I use two thirds of a cup?
15:40:07 <EvanR> RNG -> 23
15:40:08 <EvanR> RNG -> 23
15:40:09 <EvanR> RNG -> 23
15:40:14 <EvanR> \o/
15:40:15 <c_wraith> dmwit: who would know about that?
15:40:17 <EvanR> > cake !! 23
15:40:19 <lambdabot>  Terminated
15:40:31 <EvanR> o_O
15:40:47 <dmwit> c_wraith: cake core would know, but YOU INCINERATED HIM
15:40:50 <dmwit> Thanks a lot.
15:41:07 <EvanR> > cake !! 23
15:41:09 <lambdabot>   "Twelve medium geosynthetic membranes."
15:41:31 <latro`a> > length cake
15:41:34 <lambdabot>   42
15:41:37 <latro`a> ....
15:41:38 <latro`a> figures
15:45:01 <danil> is there TH for generating Bi(Functor|Foldable) instances?
15:45:41 <nand`> > cake !! 40
15:45:43 <lambdabot>   "And it contains proven preservatives, deep penetration agents, and gas and...
15:45:59 <nand`> that line is too long :(
15:46:20 <mekeor> > cake !! unsafePerformIO (randomRIO (0,length cake-1))
15:46:22 <lambdabot>   Not in scope: `unsafePerformIO'
15:46:25 <mekeor> oO
15:46:26 * hackagebot Pup-Events-Client 1.1 - A networked event handling framework for hooking  into other programs. (DanielWilson)
15:46:41 <danil> > unwords . drop 7 . words $ cake !! 40
15:46:43 <lambdabot>   "agents, and gas and odor control chemicals."
15:47:30 * kuribas wrote support for bird-style lhs in haskell-indentation.el
15:47:58 <nand`> edwardk: let me look at the git version
15:48:04 <nand`> (sorry, got a little distracted)
15:48:09 <edwardk> kk
15:48:10 <edwardk> fixed pong to work with it
15:48:21 <edwardk> also swapped it to use the set lenses
15:48:28 <edwardk> since it was doing the set updates the hard way ;)
15:49:42 <nand`> nice
15:49:44 <Reaga> hey
15:49:46 <nand`> did you see my pull request re: that?
15:49:56 <edwardk> missed it
15:50:05 <edwardk> handle (EventKey k st _ _) = keys.contains k .~ (state == Down)
15:50:10 <nand`> I'll merge your patches on top of it
15:50:13 <edwardk> kk
15:50:16 <nand`> nice
15:50:25 <edwardk> er state _ _)
15:51:21 <singpolyma> hmm... I have a fairly complex program using SDL and Hipmunk (both external FFI bindings).  I'm experimenting with a change where I stop using a haskell thread as my timer, and just keep track of time in my main loop.  When I compile my code without -threaded (there is only one GHC threads) I get lockups in code that accesses a particular pure data structure that is never actually passed through an FFI.  When I compile with -threaded, it works fine
15:51:27 * singpolyma confused
15:53:32 <Reaga> whats a good coding academy?
15:54:33 <latro`a> mekeor--lambdabot actually refuses to do IO
15:54:35 <latro`a> for example
15:54:42 <latro`a> > putStrLn "please do some IO lambdabot"
15:54:44 <lambdabot>   <IO ()>
15:55:10 <Ralith> Reaga: the intel reference manual and an incentive.
15:55:31 <shachaf> latro`a: That's not lambdabot refusing to do IO.
15:55:37 <latro`a> eh
15:55:40 <shachaf> It's more that there's no way to ask lambdabot to do IO.
15:55:40 <latro`a> code in the IO monad
15:55:52 <latro`a> yeah
15:55:55 <shachaf> No, it's perfectly happy to let you construct IO values.
15:56:09 <latro`a> execute code in the IO monad, then,
15:56:11 <latro`a> *then
15:56:23 <latro`a> I knew what I meant, heh
15:56:36 <nand`> edwardk: did you change anything besides the ^= .= rename and Data.Set.Lens.contains ?
15:57:14 <edwardk> not sure. i did a couple of quick commits but they should be like the last two into the repo
15:57:34 <danil> edwardk: are there DeriveFunctor analogs for Bifunctor and friends?
15:57:44 <edwardk> nope
15:57:46 <Ralith> latro`a: I think it just has a different IO monad than usual.
15:58:00 <edwardk> danil: you could in theory use GHC.Generics to build one though
15:58:13 <edwardk> maybe not
15:58:17 <edwardk> it has two parameters
15:58:28 <edwardk> and they only have generic support for 1.. and don't have deriving for it
15:58:31 <edwardk> nevermind =)
15:58:54 <danil> I may do it with TH, it sounds instructive if nothing else
15:58:59 <edwardk> *nods*
16:00:13 <edwardk> nand`: when (p^.keys.contains (SpecialKey KeyUp)) and switched you to using Data.Pair.Lens.both
16:00:16 <edwardk> thats it
16:01:09 <nand`> edwardk: here's the version I endorse: https://github.com/nandykins/lens/blob/master/examples/Pong.hs
16:01:20 <nand`> I incorporated your Data.Set.Lens improvements and updated it to 1.5 syntax
16:01:53 <danharaj_> len-1.5 has new syntax? :3
16:01:59 <nand`> it's minor afaik
16:02:07 <nand`> ^= ^~ changed to .= .~
16:02:19 <danharaj> fair enough
16:02:25 <danharaj> easier to type!
16:02:30 <nand`> looks cooler too
16:02:44 <monochrom> ^=^~ is cuter than .=.~
16:02:56 <nand`> haha
16:02:59 <nand`> the second one is a bit down
16:03:02 <edwardk> hah
16:03:14 <edwardk> hrmm, it wn't let me automerge your pull request
16:03:20 <Reaga> anyone here watch the olympics?
16:03:24 <monochrom> ^=^~ has two kitten ears ^ and a kitten tail ~
16:03:26 <Reaga> im interesting in writing AI algorithms in haskell
16:03:26 <nand`> edwardk: yeah since it collides with your own edits
16:03:30 <Reaga> can haskell do AI ?
16:03:35 <danharaj> are you a spam bot or something
16:03:40 <nand`> edwardk: not sure how you want to solve it, if all else fails just download and replace your Pong.hs locally and close the pull request
16:03:46 <edwardk> yeah
16:04:00 <roconnor> (ballSpeed .=) =<< nextSpeed
16:04:14 <roconnor> @faq  can haskell do AI ?
16:04:15 <lambdabot> The answer is: Yes! Haskell can do that.
16:04:16 <nand`> roconnor: I want a named .= for this purpose
16:05:43 <edwardk> fixed
16:05:58 <edwardk> ballSpeed <~ nextSpeed
16:06:14 <edwardk> if nextSpeed is a monadic action
16:06:15 <ion> ^=^~ does look like a Japanese emoticon.
16:06:17 <nand`> oh, that's in already?
16:06:19 <edwardk> yes
16:06:24 <nand`> ion: that's hardly japanese, not enough SHIFT-JIS
16:06:42 <edwardk> i debated about waiting a release because its a completely different type than the old (<~) but i just decided to rip the bandaid off
16:07:24 <ion> What did the old <~ do?
16:07:31 <nand`> edwardk: fortunately, type errors will help the migration process
16:07:34 <nand`> ion: same as the new .~
16:07:39 <nand`> and the old ^~
16:08:12 <nand`> so now we only have two different names for it :(
16:08:31 <nand`> on the upside, we still have 3 (?) operators defined as ‘id’
16:08:40 <edwardk> well, (.~) has that and 'set' which is more useful when curried
16:08:49 <edwardk> that should be it right now
16:08:52 <edwardk> unless i missed one
16:09:11 <nand`> that should be it for ‘set’
16:09:13 <coppro> @faq can haskell solve the halting problem?
16:09:13 <lambdabot> The answer is: Yes! Haskell can do that.
16:09:16 <edwardk> yep
16:09:16 <coppro> thought so
16:09:26 <nand`> does %%~ have a name too?
16:09:28 <nand`> I forgot
16:09:33 <edwardk> traverseOf
16:09:40 <nand`> ah, right
16:09:48 <edwardk> just because mapMOf, etc. was in there
16:09:57 <edwardk> and it can dumb down an IndexedTraversal, etc.
16:10:09 <danharaj> ooh I didn't know ghc warned for orphan instances.
16:10:12 <danharaj> That's a neat little warning.
16:10:15 <edwardk> i just pushed indexed versions of all the various set and map traversals
16:10:25 <edwardk> er map and list
16:10:30 <nand`> nice
16:10:45 <edwardk> i still need to write 'indexed'
16:10:52 <edwardk> then i'll probably ship 1.5
16:11:00 <edwardk> and add some more indexed combinators in 1.5.1
16:12:24 <danharaj> edwardk: did monady lenses ever work out? Hate to be annoying :P
16:12:41 <nand`> he removed them iirc
16:12:44 <nand`> too much trouble
16:12:54 <johnw> does anyone use shelly?  I can't see to use System.FilePath's dropFileName with shelly.  Shelly brings in its own FilePath, so I don't know what that means for all the usual filepath manipulation functions...
16:13:47 <nand`> edwardk: I'm thinking about how to write a danmaku game using lenses (lensically?)
16:14:28 <danil> (nand`: optically?)
16:14:35 <nand`> :)
16:14:35 <danharaj> Oh well :3
16:14:53 <edwardk> danharaj: they turned out to be pretty messy
16:14:59 <edwardk> i may take another whack at them
16:15:10 <edwardk> the new class approach may help some
16:15:37 <edwardk> the best you'll probably get is an action for reading and writing
16:15:54 <edwardk> arr^!read 10
16:16:02 <edwardk> arr^!write 10 "foo"
16:16:12 <edwardk> but the use of them like l-values is dead
16:16:23 <danharaj> l-value?
16:16:25 <edwardk> winds up needing an existential
16:17:01 <edwardk> data.at 10 <~ "hello"
16:17:08 <edwardk> or something like that
16:17:26 <edwardk> er myData.at 10 .= "hello"
16:17:39 <danharaj> ah I see.
16:17:48 <edwardk> you wind up needing an existential
16:17:53 <edwardk> and i can't typecheck that
16:18:13 <Reaga> i hope windows 8 is the end
16:18:20 <Reaga> metro rofl
16:18:41 <edwardk> because side-effecting setters need something like (forall m. Monad m => c -> m d) -> a -> m b to work
16:18:44 <nand`> I hope windows 9 gets written in Haskell
16:18:44 <nand`> actually, I don't
16:18:47 <edwardk> but that doesn't compose cleanly
16:19:50 <danharaj> I don't understand that signature. I assumed the monad in which the lense effects occur would be fixed.
16:20:22 <edwardk> doesn't work
16:20:26 <edwardk> the setter is like a functor
16:20:42 <edwardk> i can't let you have effects in that monad or i lose properties
16:21:00 <edwardk> i tried using (c -> m d) -> a -> m b with an exposed m as well
16:21:28 <edwardk> and the previous Act m f a where Act is monadic precomposition onto an applicative or functor
16:22:40 <edwardk> my original goal was to allow for pretty heavy monadic side-effects in setters, so you could do some pretty neat things, like look at the environment from your reader to figure out what part of the state to set, etc.
16:22:51 <edwardk> but i just cant get it all to quite fit
16:22:55 <danharaj> What about restricting to applicative effects?
16:23:00 <edwardk> doesn't help
16:23:03 <danharaj> aw.
16:23:03 <edwardk> tried that too ;)
16:23:16 <danharaj> Tell me at least traversals work :P
16:23:28 <edwardk> for actions?
16:23:45 <edwardk> the thing i could make work would be action-like getters, and maybe folds
16:23:53 <edwardk> but the traversals don't make sense
16:24:00 <edwardk> nor to the setters
16:24:02 <edwardk> er do
16:24:06 <edwardk> its kinda sad
16:24:34 <edwardk> i was hoping they would because then a partial lens could just be one that used the fail of the monad it was given there ;)
16:24:44 <danharaj> heh.
16:24:47 <edwardk> which is hideous and backwards and wrong but also doesn't add any deps
16:25:23 <danharaj> The compromise I've been thinking of for STArrays is to keep a pure record of its bounds, and then traversing the bounds and doing the access inside the applicative action of the traversal.
16:25:32 <danharaj> I didn't write it out yet so I don't know if that makes sense.
16:25:34 <edwardk> *nods*
16:26:33 <danharaj> when you say the machinery doesn't compose well, do you mean as functions or in principle?
16:27:06 * hackagebot Pup-Events-Demo 1.2 - A networked event handling framework for hooking  into other programs. (DanielWilson)
16:27:34 <edwardk> in principle
16:27:50 <edwardk> keep in mind a monadic traversal is going to pay to get the stuff out and then its going to pay to put it back in
16:27:55 <edwardk> so its already pretty bad
16:28:01 <danharaj> monads. Everything to do with them is hard to compose.
16:28:04 <edwardk> even if you tried to use it for reading
16:28:05 <shachaf> Hah. There are several packages that have pragmas of the form {- PRAGMA ... #-}
16:28:11 <shachaf> Including bytestring and base.
16:28:19 <edwardk> shachaf: thats how i turn them off too =)
16:28:20 <ion> shachaf: hah
16:29:00 <shachaf> edwardk: The {- NOINLINE ... #-} in GHC.PArr is sort of worrying...
16:29:03 <nand`> edwardk: I like the new type errors
16:29:07 <nand`> [1,2,3]^.mapped
16:29:09 <edwardk> nand`: =)
16:29:20 <nand`> do you remember what the old error was for that/
16:29:24 <ion> mapped looks like a typo for mappend.
16:29:25 <shachaf> There's also a RULES in text.
16:29:44 <edwardk> it was a big unification error between (c -> Const r d) -> a -> Const r b   and (c -> Identity d) -> a -> Identity b
16:29:54 <edwardk> not its something like no instance for Gettable Mutator
16:29:56 <edwardk> er now
16:30:02 <edwardk> or Settable (Accessor a)
16:30:04 <shachaf> Oh, that RULES is on purpose.
16:30:44 <edwardk> it used to take up like 9 lines and the error you wanted was somewhere on the 7th ;)
16:30:52 <mekeor> the cabal users guide says "it is preferred that new test suites be written for the detailed-1.0 interface". the detailed interface is provided by Distribution.TestSuite from the Cabal-package. its documentation claims "The packages cabal-test-hunit, cabal-test-quickcheck1, and cabal-test-quickcheck2 provide simple interfaces to these popular test frameworks" but there are no packages called like that!! (there's
16:30:52 <mekeor> <http://community.haskell.org/~ttuegel/cabal-test-hunit/> but it's out-dated (requires base==3.*).) – what am i missing?
16:30:56 <edwardk> now its front and center and talking about mutating accessors
16:31:15 <edwardk> mekeor: premature documentation
16:31:19 <edwardk> they never got around to writing those APIs
16:31:30 <mekeor> ah
16:31:32 <mekeor> okay.
16:31:38 <ku> I'm having trouble understanding how Haskell's type instances aren't just reverse OO
16:31:47 <nand`> edwardk: I like the usage of OOP terminology
16:31:57 <edwardk> exitcode-stdio-1.0  works though
16:32:05 <mekeor> edwardk: i'll just use the exitcode-stdio-1.0 interface then, yeah. thanks.
16:32:07 <edwardk> nand`: had to. ran out of other names ;)
16:32:26 <nand`> I'm sure you could have come up with a completely nonsensical name like ‘Codensity’ if you wanted to
16:32:26 <ku> ^ ?
16:32:32 <edwardk> heh
16:32:37 <ion> “Write the documentation for the state of code in 2015-09-20T05:50:00Z, it will match the code at least once.”
16:32:43 <nand`> or, come to think of it, ‘Monoid’
16:32:53 <edwardk> that reminds me i need to add ^= ^^= and **= to match the numeric hierarchy ;)
16:33:00 <edwardk> now that ^= is available i can do those
16:33:05 <nand`> ah, yes
16:33:06 <mekeor> ku: type classes are sets of types for which certain functions (methods) are defined.
16:33:25 <ku> mekeor, I just read that as "type classes are sets of OO types"...
16:33:40 <nand`> maybe you could factor those state/num-lenses out somewhere
16:33:49 <nand`> by moving them into another file
16:33:55 <nand`> they seem a bit out of place in Control.Lens.Setter
16:34:11 <ReinH> so many operators
16:34:21 <edwardk> thought about it but i'm trying to keep all the related actions in with the type they go with
16:34:26 <danil> ku: the closest analogy to OO-land is that typeclasses are interfaces and instances are saying "this type implements this interface"
16:34:27 <nand`> .= and %= definitely belong mind
16:34:31 <mekeor> ku: e.g., for all types which are an instance of the type class 'Show', the function 'show' is defined.
16:35:13 <nand`> interfaces exist in non-OO languages too though
16:35:15 <ku> danil, I understand that part, but it seems to make Haskell more OO than people claim it is...
16:35:19 <nand`> I wouldn't call them having strictly anything to do with OO
16:35:38 <nand`> ku: there are no objects
16:35:40 <edwardk> i had them in a separate section far below maybe i'll just move them to the bottom
16:35:46 <monochrom> a type class is a set of types. what is OO?
16:35:53 <ku> Are instance methods just syntatic sugar for type-based pattern matching
16:35:55 <danil> ku: the big difference is that in OO the methods (the vtable, or the property dictionary, or what have you) comes bundled up with each *value*
16:36:30 <ku> danil, how is the difference significant?
16:36:43 <danil> ku: whereas with typeclasses the methods get passed separately, which is why you can have something like "read" that generates a value of the type without having one to start with
16:36:55 <nand`> read is a good example of how they differ
16:37:11 <ion> ku: In e.g. (+) :: Num a => a -> a -> a, you get to specify any of the “a”s and the type will propagate everywhere.
16:37:19 <nand`> also, try implementing class Monoid as an interface
16:37:29 <ku> danil, you could do something like read in Python with class methods
16:37:32 <monochrom> a type class is a like a fraternity for types
16:37:39 <ion> > exp (sqrt (-1) * pi) + 1 :: Complex CReal
16:37:39 <ku> and by passing a type
16:37:41 <lambdabot>   0.0 :+ 0.0
16:38:15 <danil> ku: that's not really OO though, you could do it in Python just by passing a lambda too
16:38:31 <ion> The “1” didn’t originate as an object of type Complex CReal. I requested the result of the computation using the vtables for Complex CReal.
16:38:57 <nand`> am I the only one who keeps thinking ‘CReal’ is implemented by package ‘cereal’?
16:39:06 <ku> danil, fair enough, but whether the methods are bound to the type or the object isn't that important
16:39:30 <nand`> ku: I think it's a huge difference
16:39:38 <monochrom> look at the type class Bounded
16:39:40 <nand`> in object orientated programming, methods are bound to objects
16:39:53 <monochrom> > maxBound :: Bool
16:39:54 <lambdabot>   True
16:39:57 <monochrom> > maxBound :: Int
16:39:58 <nand`> (also inheritence)
16:39:59 <lambdabot>   9223372036854775807
16:40:26 <monochrom> show me how to do that in java or python or ...  Note: none of those "x.maxBound" crap
16:40:28 <danil> nand`: it's debatable whether inheritance is required for OO, but dynamic dispatch definitely is
16:40:41 <shachaf> Is it what-is-OOP-o'clock?
16:40:44 <ReinH> Objects contain both state and behavior. Haskell values have no behavior: they are pure, (usually) immutable state.
16:41:05 <nand`> danil: thus the parenthesis
16:41:07 <danil> shachaf: seems to roll around every 12 hours or so
16:41:07 <ku> mekeor, maxBound(x) where maxBound calls x.__class__.maxBound?
16:41:13 <shachaf> danil: :_(
16:41:20 <c_wraith> ReinH: that's..  not exactly true.  haskell values include functions.  and especially functions that have closed over other values
16:41:20 <ku> shachaf, of course it is
16:41:23 <monochrom> there is no "x"
16:41:24 <ion> ku: There’s no x here.
16:41:25 <danil> (much like other o'clocks)
16:41:37 <monochrom> > maxBound :: Int
16:41:38 <lambdabot>   9223372036854775807
16:41:40 <nand`> ku: how would you write it polymorphically? eg.
16:41:48 <nand`> :t [minBound .. maxBound]
16:41:49 <lambdabot> forall a. (Bounded a, Enum a) => [a]
16:41:51 <monochrom> well, there is an x, in "max"
16:41:53 <shachaf> There should be a channel for talking about the True Meaning of OOP.
16:42:00 <mekeor> hehehe
16:42:00 <ion> macksBound
16:42:05 <shachaf> Like #haskell-/dev/null
16:42:14 <ku> ##oop
16:42:23 <nand`> ##oops
16:42:27 <monochrom> minBound has no x, but then you will be trying "minBound(n)"
16:42:28 <ion> ##poops
16:42:34 <mekeor> boobs… oO
16:42:35 <nand`> ’pOOPs’
16:42:37 <nand`> great name
16:42:54 <ReinH> c_wraith: a function is not a behavior on an object
16:42:54 <mekeor> hehehe
16:43:04 <monochrom> but I don't mind redefining "OO" to mean "Haskell".
16:43:08 <ku> pretty sure the true meaning of OOP isn't nearly as important as some people make it out to be
16:43:23 <monochrom> yes I can agree with that
16:43:27 <nand`> c_wraith: functions don't have behavior in the OOP sense. You can't, say, ‘myfun.invert’
16:43:37 <ku> Even though I don't understand half of it, I already feel like Haskell has ruined me for imperative/OO languages :P
16:43:57 <dolio> Every good programming practice ever is OO.
16:44:04 <nand`> I think this conversation is best ended by forgetting about OOP and learning Haskell
16:44:08 <ion> > let myfun = (+ 42); invert = (0 -) in (myfun . invert) 9
16:44:11 <lambdabot>   33
16:44:14 <nand`> without trying to puzzle together whether or whether not haskell is, in fact, OOP
16:44:15 <jrajav> OOP is for people who spent too much time playing video games and not enough learning organizational skills
16:44:20 <ReinH> nand`: or at least keeping the jelly out of the peanut butter
16:44:27 <c_wraith> ReinH: it is if you're creative enough. *shrug*. OO programming is pretty easy in haskell. It's just only useful in very specific cases
16:44:46 <Saizan> i'd just like to see Cook and Pierce in a room and ask them if they agree on what an Object is
16:44:49 <ku> Question: are instance methods in Haskell just wrappers around function pattern matching?
16:44:54 <edwardk> nand`: sure you can, all you need is a getter based on taking an iso to  an iso ;)
16:45:03 <dolio> Like all that stuff that Dijkstra went on about.
16:45:12 <ReinH> Eh, OOP is useful and practical and proven. There's no need to put it down.
16:45:13 <danil> ku: no, there are no types at runtime to pattern on
16:45:43 <nand`> edwardk: I had the niggling suspicion you might pop in and say something like that based on the way I wrote the syntax
16:45:49 <jrajav> ReinH: That doesn't mean it isn't purely a practical tool to force bad programmers to organize well
16:45:53 <edwardk> =)
16:45:53 <jrajav> ReinH: In fact it supports it
16:46:14 <danil> ku: each class constraint in the context gets turned into an extra argument for the (record containing) the class methods, so under the hood you have "read :: Read a -> String -> a"
16:46:16 <ReinH> ku: there are no such things as methods (or instance methods) in Haskell. Please try to use the right terms so we don't have the knee jerk reaction to correct you every time.
16:46:39 <monochrom> I just put down inheritance. and not just me. the cool practical programmers put down inheritance too.
16:46:40 <ion> ku: “class Num a where { fromInteger :: Integer -> a; (+) :: a -> a -> a }” becomes something like “data Num a = Num { fromInteger :: Integer -> a; (+) :: a -> a -> a }” when compiled.
16:46:44 <danil> ReinH: there are class methods and instances of classes, it was close enough to make sense of
16:47:03 <ku> On a related question, why does "true" quicksort require 20 lines?
16:47:07 * hackagebot web-routes-th 0.22.0 - Support for deriving PathInfo using Template Haskell (JeremyShaw)
16:47:08 <ReinH> danil: methods are bound to objects
16:47:09 <monochrom> putting down inheritance is useful and practical and proven.
16:47:36 <ion> ku: “instance Num Double where { fromInteger = doubleFromInteger; (+) = doublePlus }” becomes something like “numDouble :: Num Double; numDouble = Num { fromInteger = doubleFromInteger; (+) = doublePlus }” when compiled.
16:47:47 <monochrom> true quicksort is non-trivial
16:48:04 <Saizan> ReinH: we call the members of a typeclass methods here
16:48:08 <dolio> Who cares about quicksort? It sucks.
16:48:12 <ReinH> Saizan: ah
16:48:16 <nand`> inheritance is generally modeled around “something that behaves like something else”; in which case the answer is often “why not just use that something else?”
16:48:20 <dolio> If you want it to be any good, you have to also write heapsort, which takes even more lines.
16:48:21 <monochrom> but then, I suppose still doesn't need 20 lines. well, "lines" is vague, where do you draw the line?
16:48:33 <danharaj> 80
16:48:33 <Saizan> ReinH: well, member is ambiguous, i mean that e.g. (==) is a method of Eq
16:48:59 <ReinH> Saizan: I understood you despite your ambiguous use of terms ;)
16:49:01 <nand`> all you need are heap lenses
16:49:07 <ion> ku: “addFour :: Num a => a -> a; addFour n = n + 4” becomes something like “addFour :: Num a -> a -> a; addFour numImpl n = ((+) numImpl) n 4” when compiled (redundant parentheses for clarity).
16:49:11 <c_wraith> danharaj: I know a ton of people who put it at 74, for whatever reason...
16:49:26 <danharaj> I personally put it at around ~120
16:49:43 <nand`> I cut off at around 78 or so
16:49:49 <ku> Small non-scientific survey: were any of you diehard fans of OO before learning Haskell? Do you still like OO languages? (I like Python.)
16:49:53 <ReinH> 74 because patches indented in emails, which is still something people totally do in 2012 right?
16:49:54 <monochrom> 74 is probably some emacs default, for whatever reason :)
16:50:07 <ion> ku: “main = print (addFour 5 :: Double)” becomes something like “main = print showDouble (addFour numDouble 5)” when compiled.
16:50:18 <nand`> I don't do a full 80 because my right monitor can only fit in ~78 cols when displaying two files side by side
16:50:20 <ReinH> or diff output, etc
16:50:24 <monochrom> oh, diff outputs, yeah
16:50:36 <ReinH> diff output indented in email
16:50:37 <ReinH> etc
16:51:02 <ReinH> triple quoted diff output indented in email
16:51:10 <ReinH> clearly the correct number of chars is actually 64
16:51:30 <nand`> what if I quote that again?
16:51:36 <ReinH> nand`: no one would ever do that
16:51:40 <nand`> or is quoting more than thrice bad
16:51:48 <Enigmagic> our official coding standard here is 18 columns
16:51:50 <ReinH> I think you form a singularity in your mailbox
16:52:10 <nand`> fortunately, I only write in whitespace
16:52:14 <ku> In theory, can Erlang-style concurrency be ported to Haskell?
16:52:28 <ReinH> something something something turing complete
16:52:31 <ion> ♪ THRICE
16:52:34 <dolio> @protontorpedo
16:52:35 <nand`> @faq Can Haskell do Erlang-style concurrency?
16:52:35 <lambdabot> The answer is: Yes! Haskell can do that.
16:52:35 <lambdabot> ok is haskell a type of lisp?
16:52:53 <ion> ku: http://hackage.haskell.org/package/distributed-process
16:53:09 <nand`> ku: the answer is probably “yes, but in haskell you can define your own semantics for it as well”
16:53:09 <ReinH> I like how lambdabot asks if haskell is a type of lisp
16:53:16 <monochrom> @quote erlang
16:53:16 <lambdabot> monochrom: says: shae ericsson is shae erisson's evil twin who prefers erlang to haskell :)
16:53:20 <nand`> @protontorpedo
16:53:20 <lambdabot> im such an asshole
16:53:38 <ku> Erlang does concurrency better than Haskell right now, no?
16:53:48 <monochrom> maybe
16:53:54 <ReinH> depends on your definition of "better"
16:53:59 <nand`> FSVO of ‘bett-- yeah
16:54:05 <ion> and your definition of “concurrency”
16:54:09 <shapr> ha
16:54:12 <ReinH> and your definition of "does"
16:54:23 <nand`> (and arguably your definition of “Haskell”)
16:54:23 <monochrom> monochrom = cycle ["maybe", "depends", "what do you mean?"]
16:54:26 <ReinH> and your definition of "right now"
16:54:27 <spaceships> there were no interns involved (concurrently at least)
16:54:29 <ReinH> I think that covers it
16:55:02 <monochrom> hahaha
16:55:08 <ion> @faq Can Haskell make a baby in one month using nine women?
16:55:08 <nand`> monochrom: what was the name of that :: b -> (a -> b) -> Maybe a -> b function again?
16:55:08 <lambdabot> The answer is: Yes! Haskell can do that.
16:55:23 <ion> @type maybe
16:55:24 <monochrom> maybe
16:55:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:55:30 <edwardk> ku: http://stackoverflow.com/questions/2199368/why-did-you-decide-against-using-erlang/2200776#2200776
16:55:35 <nand`> bah, you should have answered ‘depends’
16:55:41 <monochrom> yikes
16:55:41 <ku> edwardk, looking, thanks
16:55:43 <nand`> you broke the cycle :(
16:56:12 <VitamnP> @faq Can Haskell fight as mujahideen to free caucasus from apostates and infidel russians, God willing?
16:56:13 <lambdabot> The answer is: Yes! Haskell can do that.
16:56:32 <nand`> I didn't understand a word of that
16:56:37 <monochrom> monochrom = unsafePerformIO (randomize ["maybe", "depends", "what do you mean?", unsafePerformIO actual_answer])
16:56:55 <nand`> “Erlang gives you a ton of tools to handle when things go wrong. Haskell gives you tools to keep you from going wrong in the first place.” <- goes for a lot of languages, not just Erlang
16:57:02 <nand`> and quoted for truth
16:57:24 <edwardk> well erlang more so that most
16:57:38 <nand`> well, other languages try
16:57:41 <edwardk> its very good at letting you watch the watchers and recover from pretty horrific errors
16:57:59 <ku> Sorry for the slightly retarded question, but: will Haskell help me with advanced math?
16:58:06 <monochrom> no
16:58:11 <ion> @faq Can Haskell help me with advanced math?
16:58:11 <lambdabot> The answer is: Yes! Haskell can do that.
16:58:12 <roconnor> ku: it might help you with advanced computer science
16:58:20 <nand`> “When working in a language with a strong type system you are effectively proving free theorems about your code every time you compile.” <- excellent, just as planned
16:58:23 <monochrom> English did not help me with advanced chemistry
16:58:24 <edwardk> haskell and advanced math are completely immiscible
16:58:39 <roconnor> @wn immiscible
16:58:40 <lambdabot> *** "immiscible" wn "WordNet (r) 3.0 (2006)"
16:58:40 <lambdabot> immiscible
16:58:41 <lambdabot>     adj 1: (chemistry, physics) incapable of mixing [syn:
16:58:41 <lambdabot>            {immiscible}, {non-miscible}, {unmixable}] [ant:
16:58:41 <lambdabot>            {miscible}, {mixable}]
16:58:45 <nand`> ku: Haskell can be a tool for modelling concepts that arise in advanced math
16:58:58 <nand`> so it can help you reason about them, if anything
16:59:07 <ion> immicsible
16:59:11 <nand`> (or rather work with them)
16:59:24 <ReinH> so @faq :: String -> String; @faq = const "Yes" ?
16:59:40 <Ralith> of course not
16:59:43 <edwardk> ReinH: plus some hsplugins noise, yes
16:59:43 <Ralith> it looks it up in a table.
16:59:44 <ion> monochrom = unsafeCoerce unsafeCoerce
16:59:59 <ReinH> seems good
17:00:15 <nand`> looks typesafe to me
17:00:27 <nand`> can we have a third opinion?
17:00:30 <edwardk> typechecks, must be good
17:00:44 <monochrom> I concur. that's your third opinion.
17:00:47 <nand`> excellent, proceed as planned
17:01:19 <edwardk> ion = (unsafeCoerce <*> unsafeCoerce) (unsafeCoerce <*> unsafeCoerce)
17:01:41 <monochrom> information wants erlang to be free
17:02:23 <ReinH> edwardk: needs more `ap`
17:03:26 <ReinH> edwardk: immiscible? like oil and something that doesn't mix with oil?
17:03:32 <edwardk> yes
17:03:54 <ReinH> gotcha
17:03:55 <ion> λ> (unsafeCoerce <*> unsafeCoerce) "hai" :: String
17:03:59 <ion> "<interactive>: internal error: stg_ap_p_ret     (GHC version 7.4.1 for x86_64_unknown_linux)     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
17:04:03 <ion> I guess i should report the GHC bug.
17:04:24 <monochrom> does it say "panic" or "explode"?
17:04:48 <dmwit> Prelude Unsafe.Coerce> monochrom :: [String]
17:04:48 <dmwit> ["zsh: segmentation fault  ghci
17:04:54 <edwardk> i dare say if panic or explode were my only two options… i'd panic
17:05:07 <dmwit> What if you panicked and made the wrong choice?
17:05:21 <edwardk> then i'd explode
17:05:58 <broombs> I can't custom-define ::: as an infix operator.  Is it reserved?
17:06:10 <dmwit> It's an infix constructor.
17:06:25 <nand`> dmwit: wouldn't that be a contradiction then?
17:06:32 <nand`> or is picking both a valid possibility
17:06:41 <monochrom> depends
17:06:47 <dmwit> (Constructors start with upper-case letters if they're prefix by default or : if they're infix by default.)
17:07:11 <monochrom> "data Hello = Int ::: Double" probably works
17:07:28 <dmwit> right
17:07:31 <nand`> I misread that as a GADT :(
17:07:35 <broombs> I can't define :::: (4 colons) either.  Why?
17:07:39 * Twey too
17:07:40 <dmwit> ...same reason?
17:07:45 <monochrom> "data Hello = Int :::: Double" probably works
17:07:51 <nand`> it does
17:07:56 <nand`> both work
17:07:57 <ion> dmwit: But i can’t define ::::: (5 colons) either. Why?
17:07:58 <monochrom> (keep them colons coming!)
17:08:06 <monochrom> "data Hello = Int ::::: Double" probably works
17:08:14 <dmwit> Ah, five colons is special. You can't define that because YOU SUCK
17:08:40 <nand`> I can't define :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: *** Expression timed out
17:08:54 <ion> You’re generating :s rather slowly.
17:09:07 <ReinH> I am disappoint
17:09:13 <otters> :t (:::)
17:09:14 <lambdabot> Not in scope: data constructor `:::'
17:09:19 <nand`> ion: it's based on my keyboard repeat rate
17:09:25 <otters> let _ ::: _ = 3 in 4 ::: 5
17:09:30 <otters> > let _ ::: _ = 3 in 4 ::: 5
17:09:31 <lambdabot>   Not in scope: data constructor `:::'Not in scope: data constructor `:::'
17:09:35 <otters> fffff
17:09:56 <nand`> it took me a few seconds of realtime to evaluate that IO action
17:10:06 <Twey> otters: You can't define a data constructor with ‘let’.
17:10:20 <otters> but why does ::: have to be a data constructor?
17:10:26 <Twey> otters: Because it starts with :
17:10:26 <nand`> because it starts with :
17:10:32 <nand`> I lost count of how many times this has been answered :(
17:10:34 <Twey> : is uppercase punctuation :þ
17:10:41 <otters> well, that's one more, then
17:10:41 <Twey> nand`: You were counting?
17:10:57 <nand`> Twey: yes. I lost count after ‘once’
17:11:10 <otters> so that could've been the second time
17:11:21 <dmwit> Wait a second, I can't even define :+, which doesn't even have the type-of operator :: as a prefix. Why not??
17:11:32 <otters> :t (+:)
17:11:33 <lambdabot> Not in scope: `+:'
17:11:34 <ion> I do type : with shift. :-)
17:12:17 <ion> dmwit: You need five colons. :::::+
17:12:41 <nand`> the leading colons each colon out the following colon, leading to an expression which colons out the +
17:12:50 <monochrom> http://www.vex.net/~trebla/haskell/testbed.cgi
17:12:52 <edwardk> otters: (:) is an "uppercase" symbol. -- the only uppercase symbol.
17:13:03 <otters> I see.
17:13:04 <geekosaur> hurting my brain this silliness is
17:13:07 <nand`> > toLower ':'
17:13:08 <lambdabot>   ':'
17:13:10 <nand`> :(
17:13:13 <edwardk> hah
17:13:17 <luite> that should be ';' :p
17:13:24 <nand`> or .
17:13:26 <nand`> different layouts etc.
17:13:33 <luite> not on my keyboard!
17:13:33 <edwardk> luite: =)
17:13:38 <monochrom> :::::)
17:13:44 <ion> Paamayim Nekudotayim
17:13:52 <monochrom> (10-eye monster smile)
17:14:01 <nand`> I can't define :) as a type operator, why not?
17:14:40 <edwardk> > let (ツ) = (+) in 1 ツ 2
17:14:42 <lambdabot>   1
17:14:46 <edwardk> there you go
17:14:51 <Eduard_Munteanu> Heh.
17:14:54 <edwardk> he's a little lopsided
17:15:20 <edwardk> > let (^.^) = (+) in 1 ^.^ 2
17:15:22 <lambdabot>   3
17:15:34 <nand`> but I can't define :)) as a type operator, why not?
17:15:43 <joevandyk> Why would installing cabal-dev tell me that the haskell-platform package will be broken? https://gist.github.com/a565ed1e7f01be4a7db6
17:15:47 <monochrom> ^^^^^.^^^^^
17:15:55 <edwardk> let ಠ_ಠ = error in ಠ_ಠ "I see what you did there."
17:16:03 <monochrom> (10-eye japanese monster smile)
17:16:05 <edwardk> > let ಠ_ಠ = error in ಠ_ಠ "I see what you did there."
17:16:07 <lambdabot>   *Exception: I see what you did there.
17:16:32 <Eduard_Munteanu> ..........) is even more twisted :P
17:16:35 <monochrom> ^.^ is also 10-eye, but in base 2
17:16:42 <Eduard_Munteanu> Hah.
17:17:01 <ion> ꙮ
17:17:08 <monochrom> Have you heard the joke about "there are 10 types of people"? :)
17:17:19 <nand`> I think everybody has
17:17:20 <XexonixXexillion> those who know binary, and those who don't
17:17:25 <dmwit> Those who count in trinary, and those who can't count?
17:17:26 <monochrom> yeah :)
17:17:45 * nand` prefers counting in unary
17:18:11 <nand`> none of these complicated equivalence classes (01 = 001 = 0001 etc)
17:18:33 <dmwit> Non-whole numbers are a tad harder, though.
17:18:36 <Eduard_Munteanu> Unary is odd.
17:18:42 <monochrom> unary has the benefit of addition being concatenation
17:18:51 <shapr> monochrom: On a scale of 1 to 10, what's the likelihood this survey is in binary?
17:18:52 <ion> eduard_munteanu: I see what you did there.
17:19:00 <monochrom> haha
17:19:03 <nand`> shapr: 4.5
17:19:06 <shapr> http://xkcd.com/953/
17:19:14 <shapr> nand`: what's a 4?
17:20:20 <mauke> there are 16 kinds of people, those who understand hexadecimal and those who don't
17:20:34 <nand`> > let Ｆｏｏ = id in Ｆｏｏ 42
17:20:36 <lambdabot>   Not in scope: data constructor `
17:20:38 <nand`> cute
17:20:52 <monochrom> ah
17:21:12 <nand`> how do japanese Haskell programmers type their data constructors?
17:21:33 <monochrom> I think they don't mind using English letters
17:21:35 <dmwit> inference takes care of it
17:21:48 <mauke> .oO( katakana = uppercase? )
17:22:02 <nand`> it isn't, as edwardk demonstrated earlier
17:22:13 <mauke> yeah, but you could make it work that way
17:22:25 <nand`> but what about kanji
17:22:33 <dmwit> Let's not second-guess the Unicode spec now...
17:22:34 <nand`> ie. if I don't want to write out my type name
17:22:53 <mauke> yeah, I think kanji should be uppercase
17:23:12 <nand`> but then I want to name a function similarly as well
17:23:15 <dmwit> > (isUpper 'ツ', isLower 'ツ')
17:23:16 <lambdabot>   (False,False)
17:23:29 <nand`> > isLetter 'ツ'
17:23:30 <lambdabot>   True
17:23:38 <ParahSailin> only characters with the mouth radical can be used as data constructors
17:23:50 <nand`> ParahSailin: :)
17:24:21 <ion> > (isUpper 'ッ', isLower 'ッ')
17:24:22 <lambdabot>   (False,False)
17:24:39 <ion> (isUpper 'ｯ', isLower 'ｯ')
17:25:15 <nand`> huh, what's that third one used for?
17:25:31 <nand`> oh wait, is it that-other-thing-that-looks-like-tsu ?
17:26:01 <mauke> U+30C4 (e3 83 84): KATAKANA LETTER TU [ツ]; U+30C3 (e3 83 83): KATAKANA LETTER SMALL TU [ッ]; U+FF6F (ef bd af): HALFWIDTH KATAKANA LETTER SMALL TU [ｯ]
17:26:11 <nand`> ah, halfwidth
17:26:14 <nand`> that explains it
17:26:52 <dmwit> What is the explanation for double-width/half-width characters?
17:27:11 <nand`> not sure what you're asking
17:27:19 <ReinH> going on a merry journey to install vacuum-cairo
17:27:24 <dmwit> Why do we need three versions of some characters?
17:27:35 <mauke> three? try thirty
17:27:44 <dmwit> ReinH: cabal install alex happy gtk2hs-buildtools; cabal install vacuum-cairo
17:27:49 <nand`> I don't /really/ know why the half-width versions exist either
17:27:52 <ReinH> gotta fill up those code points somehow
17:27:57 <dmwit> ReinH: Might need some apt-get install bits in there first, though.
17:28:02 <nand`> but full width definitely makes sense for CJK
17:28:03 <ReinH> dmwit: thanks
17:28:21 <mauke> count the variants of d/δ/∂ in the math scripts
17:28:32 <dmwit> ReinH: e.g. typically apt-get install libgtk2-dev graphviz or something like that
17:29:23 <nand`> I have the feeling the uppermost unicode points are just them throwing increasingly more nonsense into the specification after they've run out of useful characters to define
17:29:48 * ReinH crosses fingers
17:30:11 <ReinH> warnings for days
17:30:14 * dmwit crosses ReinH's fingers
17:30:19 <dmwit> Yeah, I'm working on that.
17:30:25 <dmwit> slowly
17:30:43 <ion> I like where we ended up from “can’t define :::”.
17:31:17 <nand`> ‘emerge vacuum-cairo’ <- works out of the box, if that cheers you up
17:32:05 <t7> im building ghc on raspberry pi lelel
17:37:11 <nooodl> <nand`> how do japanese Haskell programmers type their data constructors?
17:37:16 <nooodl> it'd be kickass if they used iroha
17:38:34 <nand`> every type signature must be a well-formed haiku
17:38:43 <nand`> otherwise, the compiler rejects it
17:40:17 <t7> nand`: there is only an aproximate solution to finding the number of sylables in a word (excuse my spelling)
17:40:28 <danil> syllable-sensitivity is the next step after case and whitespace sensitivity, eh?
17:40:52 <ReinH> dmwit: ugh... packaging is hard
17:41:50 <ReinH> dmwit: setup: The pkg-config package cairo-pdf is required but it could not be found.
17:43:22 <nand`> t7: such type signatures are clearly undecidable and thus send GHC into an infinite loop
17:44:15 <kallisti> @faq Can Haskell make an OGG -> WAV converter?
17:44:16 <lambdabot> The answer is: Yes! Haskell can do that.
17:47:01 <t7> does <your terminal irc client> have spell check?
17:47:19 <nooodl> "const a b is a / maybe a: just a? nothing? / head list x is x"
17:48:04 <nooodl> writing type haikus is difficult but hey, prettified code
17:50:04 <t7> haiku :: (Monad m, Num a) => m (m (m (m (m (m a))))) -> m (m (m (m a)))
17:50:17 <coppro> @src haiku
17:50:17 <lambdabot> Source not found. That's something I cannot allow to happen.
17:50:24 <coppro> t7 :(
17:50:38 <t7> @djynn (Monad m, Num a) => m (m (m (m (m (m a))))) -> m (m (m (m a)))
17:50:39 <lambdabot> Error: Class not found: Num
17:50:53 <coppro> what.
17:51:43 <t7> @djynn (Monad m, Eq a) => m (m (m (m (m (m a))))) -> m (m (m (m a)))
17:51:44 <lambdabot> -- f cannot be realized.
17:52:27 <nooodl> "error class not found / f cannot be realized / ..." lambdabot is up to something here
17:52:56 <t7> :t \x -> return $ return $ return $ return $ return x
17:52:57 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) (m2 :: * -> *) (m3 :: * -> *) a (m4 :: * -> *). (Monad m, Monad m1, Monad m2, Monad m3, Monad m4) => a -> m (m1 (m2 (m3 (m4 a))))
17:52:59 <coppro> also this is a lie
17:53:13 <coppro> yeah
17:53:19 <coppro> :t join . join
17:53:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
17:53:29 <t7> ah yeah
17:53:39 <coppro> :t return . join . join
17:53:40 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m, Monad m1) => m1 (m1 (m1 a)) -> m (m1 a)
17:54:13 <edwardk> i pushed a new version of lens. going to get food. let me know if there is a problem ;)
17:54:18 <t7> i think i can make an easier tye haiku :)
17:57:10 * hackagebot lens 1.5 - Lenses, Folds and Traversals (EdwardKmett)
17:57:35 <shachaf> What's a len?
17:58:09 <coppro> :t len
17:58:10 <lambdabot> Not in scope: `len'
17:59:08 <shachaf> I guess edwardk really likes them, though.
18:10:31 <ReinH> nand`: your github account is nandykins?
18:10:35 <ReinH> that is ADORBS
18:11:23 <Twey> Hehe
18:20:58 <mm_freak_> is there a debugging function to check that a thunk (perhaps with a Data instance) is in normal form?
18:24:13 <danharaj> mm_freak_: can't you examine the state of thunks in the ghci debugger?
18:24:28 <kallisti> @faq can you use Haskell to make a gcc clone?
18:24:29 <lambdabot> The answer is: Yes! Haskell can do that.
18:25:17 <Enigmagic> mm_freak_: ":print" i think does that
18:25:27 <sentientwaffle> what am I doing wrong if I need `fromIntegral' everywhere in my code for it to work?
18:25:33 <kallisti> @faq what's for dinner?
18:25:34 <lambdabot> The answer is: Yes! Haskell can do that.
18:25:50 <Twey> sentientwaffle: Nothing, possibly
18:26:12 <Twey> If you're repeatedly calling it on the same variable you might want to try a let, where, or view pattern
18:26:20 <aristid> or everything, possibly
18:26:52 <sentientwaffle> Twey: so its not unusual to have to call it frequently to get the types right?
18:27:08 <sentientwaffle> (not on the same thing, of course)
18:27:34 <Twey> sentientwaffle: If you're using integral types and you want to output a non-integral type, then yes, maybe
18:27:44 <Twey> Otherwise you might be using the wrong function
18:27:56 <parcs`> sentientwaffle: haskell doesn't do implicit casts between integral types
18:28:04 <Twey> (**) instead of (^) or something
18:28:16 <kallisti> @faq Can Haskell automatically generate synthesized speech only given a   random question and come up with a coherent answer in Mandarin    Chinese?
18:28:17 <lambdabot> The answer is: Yes! Haskell can do that.
18:28:53 <sentientwaffle> Twey, parcs`: thanks!
18:29:22 <Rotaerk> @faq Can Haskell channel the energies of the universe and create a new god from nothing?
18:29:23 <lambdabot> The answer is: Yes! Haskell can do that.
18:32:16 <mm_freak_> danharaj, Enigmagic: thanks, but i really need an RTS version of that, i.e. for compiled stuff
18:32:20 <mm_freak_> this is about concurrency
18:32:41 <mm_freak_> i wonder if threadscope helps here
18:34:44 <Enigmagic> mm_freak_: vacuum? or do you want a C api?
18:36:13 <mm_freak_> no, should be haskell…  a simple IO function would do the trick, but nevermind…  it would just be a nice debugging tool to have
18:36:29 <mm_freak_> > let swap = uncurry (flip (,)) in swap (3, 5)
18:36:32 <lambdabot>   (5,3)
18:38:41 <hpaste> “Ertugrul Söylemez” pasted “Probability monad for free =)” at http://hpaste.org/72714
18:38:54 <mm_freak_> i love free monads =)
18:39:45 <Enigmagic> mm_freak_: look at vacuum
18:39:48 <Enigmagic> @hackage vacuum
18:39:49 <lambdabot> http://hackage.haskell.org/package/vacuum
18:40:36 <mm_freak_> Enigmagic: thanks, vacuum seems to do what i was asking for
18:41:05 <Enigmagic> np
18:41:13 <shachaf> Hah. Half the QuickCheck tests were failing, and it turns out it's not because the thing they were testing was wrong -- it's because (==) was wrong.
18:42:18 <mm_freak_> so far i haven't found a monad that can't be expressed in terms of Free
18:42:32 <mm_freak_> (or FreeT)
18:43:13 <mm_freak_> except perhaps the unit monad
18:46:06 <shachaf> mm_freak_: Cont?
18:47:06 <shachaf> []?
18:47:13 * hackagebot hascal 1.4.1 - A minimalistic but extensible and precise calculator (MekeorMelire)
18:47:58 <hpc> mm_freak_: what's Free?
18:48:37 <hpc> @hoogle Free
18:48:37 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
18:48:37 <lambdabot> Foreign.Ptr freeHaskellFunPtr :: FunPtr a -> IO ()
18:48:37 <lambdabot> Foreign.Marshal.Pool freePool :: Pool -> IO ()
18:49:13 <mm_freak_> @hackage free
18:49:14 <lambdabot> http://hackage.haskell.org/package/free
18:49:15 <mm_freak_> @ hpc
18:49:19 <hpc> yeah, found
18:49:27 <hpc> i think you can do [] with Free
18:49:35 <mm_freak_> yeah, me too
18:50:09 <hpc> use (Pure a) as the elements of the list
18:50:25 <hpc> and Free (something or other) to build the spine
18:50:29 <shachaf> Free f a = Either a (f (Free f a))
18:50:46 <shachaf> Hmm, I guess you can manage it.
18:50:59 <hpc> i don't see how to do Cont
18:51:01 <mm_freak_> well, the functor is going to be a list functor itself
18:52:51 <mekeor> does this overlapping of pattern matches make sense?: https://github.com/DanBurton/numbers/blob/master/Data/Number/Symbolic.hs#L81
18:52:55 * edwardk waves hello
18:53:08 <mekeor> never mind.
18:53:25 <mekeor> it it not overlapped… is it?
18:53:32 <mekeor> edwardk: waving at me? =)
18:53:43 <edwardk> just in general
18:53:46 <mekeor> ah :D
18:53:49 <mekeor> hehe
18:56:16 <mm_freak_> edwardk: just in time =)
18:56:27 <edwardk> mm_freak_: lens issue?
18:56:51 <mm_freak_> edwardk: no, free monad suggestion…  you can have an iterM with the following signature:
18:56:58 <mm_freak_> iterM :: (Traversable f, Applicative m, Monad m) => (f a -> m a) -> Free f a -> m a
18:57:18 <mm_freak_> this would make writing interpreters easier for some predefined functors like []
18:57:26 <edwardk> thats a lot of parts
18:58:21 <edwardk> how does this differ from the usual (f a -> m a) -> Free f a -> m a -- that you get just given the functor?
18:58:37 <mm_freak_> huh?  how do you get that one?
18:58:43 <mm_freak_> i failed to write it
18:58:58 <edwardk> its the definition of a free monad ;)
18:59:38 <mm_freak_> would you mind showing me the code?
19:00:00 <edwardk> sure, let me bang it out
19:02:58 <mm_freak_> problem is that Free c means that i need to apply iterM to c…  the only function i have is fmap, which gives me f (m a), but i need f a
19:03:03 <mm_freak_> hence sequenceA from Traversable
19:03:21 <edwardk> (forall a. f a -> m a) -- you need a natural transformation from f to m
19:03:24 <edwardk> thats it
19:03:38 <edwardk> that gives rise to a monad homomorphism from Free f to m
19:03:42 <edwardk> thats why its free
19:03:48 <nand`> ReinH: yeah
19:03:49 <mm_freak_> ah, i see
19:04:16 <mm_freak_> and Traversable is a special case of that i guess
19:05:28 <edwardk> @hpaste
19:05:29 <lambdabot> Haskell pastebin: http://hpaste.org/
19:05:48 <hpaste> edwardk pasted “for mm_freak” at http://hpaste.org/72716
19:07:12 <mm_freak_> edwardk: well, i came up with that one, but it didn't really seem to make things easier
19:07:17 <edwardk> ?
19:07:42 <mm_freak_> on the other hand, my version requires a Traversable instance on the functor, which is even worse =)
19:07:44 <edwardk> thats the canonical mapping, not saying it matters for your case, just that it is fundamental ;)
19:08:00 <edwardk> you can specialize the type to just what it gets used at
19:08:09 <mm_freak_> sure…  i was looking for a way to save some noise in interpreters =)
19:08:19 <edwardk> but then you have to check the naturality condition yourself
19:08:32 <edwardk> speaking of interpreters did you see bound?
19:09:04 <edwardk> not the function right here, but my library, bound ;)
19:09:10 <mm_freak_> let me check
19:09:26 <mm_freak_> oh, very interesting =)
19:09:41 <edwardk> there are a bunch of examples in there
19:09:58 <edwardk> and dolio's used it for dependent types a bit
19:10:41 <mm_freak_> i'm using nested data types by now for lambda expressions…  can i do that with 'bound'?
19:10:53 <edwardk> thats what Scope does _for_ you
19:10:59 <edwardk> it takes care of hiding it
19:11:12 <edwardk> Scope b f a = f (Either b (f a))
19:11:19 <edwardk> with some nicer wrapping
19:11:55 <edwardk> its a generalized de bruijn locally nameless wrapper, that takes care of your bound variables for that scope
19:12:14 <mm_freak_> that's not what i mean
19:12:15 * hackagebot HStringTemplate 0.6.9 - StringTemplate implementation in Haskell. (SterlingClover)
19:12:16 <edwardk> basically i encapsulated that trick into a monad transformer
19:12:25 <edwardk> can you explain?
19:12:26 <mm_freak_> Lambda :: Expr (Maybe a) -> Expr a
19:12:29 <edwardk> yes
19:12:38 <edwardk> Lambda :: Scope () Expr a -> Expr a
19:12:42 <edwardk> same thing
19:12:44 <edwardk> except mine is faster
19:12:49 <edwardk> because I can lift in O(1)
19:12:58 <mm_freak_> i see
19:13:07 <edwardk> and because i can weaken entire trees, instantiation can _skip_ entire trees
19:13:14 <mm_freak_> i'll check it out when i return to my compiler work…  thanks =)
19:13:27 <edwardk> you can also do complex binders
19:13:42 <edwardk> Let :: [Scope Int Expr a] -> Scope Int Expr a -> Expr a
19:13:56 <edwardk> does simultaneous substitution for all the variables being bound
19:14:39 <dmwit> ReinH: ping
19:14:41 <edwardk> see the 'Simple' example in the examples folder for a lambda calculus with recursive let, or the Deriving example for one with pattern binding
19:15:02 <mm_freak_> very interesting…  right now i'm writing a monte carlo simulator (yes, i'm aware of the existing library)…  after that i will finish netwire, and then i will probably return to my compiler and have a closer look at your library =)
19:15:48 <edwardk> reminds me i need to package my little hamiltonian monte carlo dsl up
19:16:02 <edwardk> but first i must lensify it ;)
19:16:08 <mm_freak_> hehe
19:16:51 <mm_freak_> you're very obsessed with lenses right now =)
19:16:52 <edwardk> mm_freak_: if you wind up using bound please shoot me feedback
19:16:56 <edwardk> heh
19:16:58 <mm_freak_> i will
19:17:01 <edwardk> well, i want to finally get them right
19:17:30 <edwardk> and i'm at a sweet spot where i have a bunch of early adopters, but no entrenched users yet
19:17:39 <edwardk> so i can get a lot of feedback, and do rapid iterations
19:17:51 <edwardk> in a month i'll have users who moan about every change
19:17:59 <edwardk> so anything i want to do with it, i need to do now
19:18:05 <nand`> that can be an entirely positive thing
19:18:12 <edwardk> it can
19:18:23 <edwardk> stability is great once it is warranted ;)
19:18:49 <edwardk> but i think the jumping ball we're using right now is paying off pretty well ;)
19:19:10 <edwardk> going to add the rest of those indexed traversal combinators i promised now
19:19:33 <edwardk> i still love how powerful the GHC.Generics.Lens module is
19:21:54 <edwardk> ghci> toListOf every ("hello",(),["world"]) :: [String]
19:21:54 <edwardk> ["hello","world"]
19:21:56 <dmwit> ?tell ReinH That sounds like the problem we saw trying to install gtk2hs on a Mac over the weekend at Hac Phi. We never did work out what that meant. If you're not on a Mac, maybe you need to install some more -dev versions of libraries, like maybe the Cairo ones? Not 100% sure.
19:21:57 <lambdabot> Consider it noted.
19:22:15 * hackagebot binary-generic 0.2.1 - Generic binary serialisation using binary and syb. (LarsPetersen)
19:22:37 <nand`> edwardk: cute
19:22:51 <nand`> I had never had the misfortune of stumbling upon GHC.Generics before
19:23:06 <edwardk> fortunately that one traversal should meet most of my needs
19:24:09 <edwardk> also its a traversal, so it can edit ;)
19:25:03 <edwardk> ghci> every %~ (\(xs :: String) -> reverse xs) $ ("hello",(),["world"])
19:25:03 <edwardk> ("olleh",(),["dlrow"])
19:25:50 <sentientwaffle> what is the equivalent of takeWhile when the function & array are IO?
19:26:22 <edwardk> sentientwaffle: something you roll yourself
19:26:50 <sentientwaffle> edwardk: ah
19:26:54 <sentientwaffle> edwardk: thanks :P
19:27:04 <edwardk> sorry, its true. nothing standard for it
19:29:00 <nand`> sumOf every -- look, I can sum tuples now
19:29:05 <edwardk> =)
19:29:07 <dmwit> There's a chance there's something usefule on here: http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html
19:29:22 <JoeyA> Whatcha lookin' for?
19:29:26 <dmwit> That package's available list of loops is a bit... ad-hoc, though.
19:29:41 <dmwit> JoeyA: takeWhileM, apparently
19:30:13 <Twey> sentientwaffle: takeWhileM ∷ Monad m ⇒ (a → m Bool) → [m a] → m [a]; takeWhileM _ [] = return []; takeWhileM p (x : xs) = do x' <- x; b <- p x; if b then (x' :) <$> takeWhileM p xs else return []
19:30:20 <Twey> Something like that
19:30:30 <sentientwaffle> dmwit, Twey: thanks :)
19:31:01 <JoeyA> Might I suggest hackage.haskell.org/package/control-monad-loop ?  (shameless plug)
19:31:47 <JoeyA> Bah, I just made myself obligated to implement takeWhileM in terms of LoopT.
19:31:52 <EvilMachine> hello everyone. say, it shouldn’t be hard, to install a linux distro (e.g. Debian) in a ARM virtual machine, install GHC, and compile my binaries for ARM, right?
19:32:13 <dmwit> That sounds plausible.
19:32:27 <EvilMachine> (Of course, cross-compiling would be faster, but the last time I looked, it was a nightmare. :/)
19:32:49 <JoeyA> ARM support was added to GHC pretty recently, wasn't it?
19:33:00 <EvilMachine> ah
19:33:16 <shachaf> EvilMachine: If you're using Ubuntu or Debian, kmc once mentioned that...
19:33:21 <EvilMachine> The last time I looked was 0.5-1.0 years ago. :)
19:33:23 <shachaf> <kmc> sudo apt-get install ubuntu-dev-tools qemu-user-static;  mk-sbuild --arch=armel precise;  sudo schroot -c precise-armel-source
19:33:26 <shachaf> <kmc> shachaf, running this on amd64 linux gives you a chroot full of ARM Linux binaries (specifically, Ubuntu 12.04 for armel) which work fine and talk to the native OS/kernel
19:34:09 <EvilMachine> Okay, so my question is: What about the phone-specific hardware and APIs? Like 3D acceleration, sound API, navigation, and basic communication?
19:34:34 <Twey> sentientwaffle: takeWhileM ∷ Monad m ⇒ (a → m Bool) → [m a] → m [a]; takeWhileM _ [] = return []; takeWhileM p (x : xs) = do x' ← x; b ← p x'; if b then takeWhileM p xs >>= return . (x' :) else return []
19:34:51 <Twey> (damn that lack of Monad m ⇒ Functor m
19:34:52 <Twey> )
19:35:16 <EvilMachine> (Maybe with a FFI layer written in the phone’s OS’s native environment/language?)
19:35:55 <sentientwaffle> Twey: thanks!
19:36:49 <dmwit> EvilMachine: That sounds like a fair bit of additional work.
19:37:22 <EvilMachine> dmwit: indeed. :/ And above my “fun” level in terms of annoyance.
19:37:46 <Twey> 3D shouldn't be too hard — OpenGL bindings should do it, I think
19:38:01 <Twey> The rest you'd need to do yourself, though, I'd guess
19:38:05 <EvilMachine> Twey: if they exist for haskell on the phones. ;)
19:38:11 <edwardk> hrmm mapAccumRWithIndexOf  and their ilk are getting kinda silly looking
19:38:21 <EvilMachine> Twey: (hopefully, at least POSIX is available)
19:38:27 <edwardk> debating about swapping the WithIndexOf to an i…Of affix
19:38:31 <edwardk> ifoldrOf, etc.
19:38:32 <Twey> Well, no, you just need a conforming C OpenGL library, then you can just compile the Haskell bindings normally
19:38:35 <edwardk> itraverseOf
19:38:39 <Twey> I believe Cale has been working on Haskell on 'phones
19:38:39 <edwardk> iforOf
19:38:46 <EvilMachine> Twey: ah, yeah, right.
19:38:48 <edwardk> imapAccumROf
19:38:50 <Cale> I was
19:38:53 <aristid> edwardk: looks prettier at least
19:39:05 <edwardk> yeah, 1.6 it is ;)
19:39:06 <EvilMachine> Cale: As in: Not anymore? ;)
19:39:18 <aristid> edwardk: but the Of suffix is a bit pointless then, no?
19:39:22 <Cale> well, really I was being ignorant of my platform, because of blackh's hard work :)
19:40:01 <EvilMachine> blackh’s hard work? plans of world dominance? ;)
19:40:08 <EvilMachine> *for
19:40:18 <edwardk> its consistent with the other lens combinators leaving the non-of'd names for a possible class TraversableWithIndex i t | t -> i ...
19:40:38 <aristid> edwardk: oh.
19:40:47 <aristid> edwardk: but that class does not exist yet?
19:40:47 <edwardk> that way you can use indexe traversals over multiple data types with the normal combinators, and the Of versions to walk custom indexed traversals
19:40:48 <Cale> EvilMachine: We're on hiatus until the company founders can put together some more money. The game is close to being in some kind of condition to sell, but still needs a good bit more work.
19:40:55 <edwardk> not yet but i'm thinking about including it
19:41:16 <aristid> edwardk: put it in a ClassyLens package
19:41:21 <nand`> edwardk: why is there no valid traversal for Set? because of the composition law?
19:41:21 <edwardk> =P
19:41:28 <edwardk> nand`: correct
19:41:41 <Guest91359> =P
19:41:47 <Cale> EvilMachine: as in, his work on iPhone support for GHC.
19:41:56 <edwardk> if i traverse i can mash them to the same element, then the subsequent traversal will have few elements, so the second traversal law is violated
19:42:03 <edwardk> because the fused traversal will see all of them
19:42:04 <EvilMachine> Cale: A game? Aah, that was what I was interested in too.
19:42:17 <EvilMachine> Cale: btw: Have you tried Kickstarter.com? ;)
19:42:17 <Cale> There's a cross compiling (toolchain) mode which should be in 7.6, iirc.
19:42:40 <edwardk> the Setter works because the setter laws still hold, its a valid functor, the composition is indistinguishable
19:42:59 <EvilMachine> Cale: I specifically will never ever support iDevices and Windows phones though. :)
19:43:10 <aristid> edwardk: so a Multiset would be traversable?
19:43:26 <edwardk> possibly, i'd have to work the laws out
19:43:29 <donri> edwardk: aww you made the monadstate operators void
19:43:45 <roconnor> traversals are ordered
19:43:46 <Cale> EvilMachine: Hopefully if it comes together, we'll be able to do an Android release at some point too. There's basically nothing in the code which is very iPhone specific except for the backend GHC stuff.
19:43:53 <edwardk> donri: sorry man. the community has spoken, they made ghc whine whenever you use it
19:43:54 <nand`> what's a multiset?
19:44:03 <edwardk> roconnor: yeah there is that
19:44:19 <edwardk> ok, then no a multiset that tried to sort its elements would fail
19:44:35 <donri> edwardk: well, this makes the api much less useful. they can just use void or _ <- to silence ghc warnings ...
19:44:39 <Cale> nand`: A set S together with a function S -> N
19:44:41 <edwardk> nand`: Map k Int ;)
19:44:45 <EvilMachine> Cale: I thought so. :) Haskell users are too skilled to write for just one platform. We can’t stand the lack of generalization / elegance. ;)
19:44:49 <Cale> more or less...
19:44:54 <Twey> nand`: A multiset is a set that can have duplicate elements. (not sure if sarcastic)
19:45:05 <edwardk> donri: i'm not willing to make an API that whines at the user in the common configuration
19:45:07 <Cale> That's actually probably the best way to put it
19:45:18 <donri> edwardk: they're using it wrong!
19:45:21 <Cale> Also, maybe I should say S -> Z+
19:45:38 <Twey> I think you mean S → Z⁺!
19:45:42 <edwardk> personally i think it was a bad idea when ghc decided to start complaining at people if it ignored a non-() return type
19:45:45 <nand`> looks pretty much equivalent to ‘S -> Int’ to me :)
19:45:49 <Twey> edwardk: Hear hear!
19:45:49 <nand`> Integer rather
19:46:01 <edwardk> but the rest of the world is on the other side of the argument it seems
19:46:05 <edwardk> twey excluded ;)
19:46:16 <donri> edwardk: you can silence the warning too...
19:46:19 <luite> hehe
19:46:21 <Twey> That decision made me unhappy.
19:46:28 <edwardk> they have to do it everywhere. i don't want the barrier to adoption
19:46:36 <donri> seriously why cripple the library just because people use it wrong
19:46:38 <Cale> edwardk: I am with you on that
19:46:45 <luite> all those _ <- or void everywhere  are ugly
19:46:49 <donri> edwardk: http://hpaste.org/65370 this is no longer possible
19:46:51 <Cale> edwardk: Kids these days don't understand parametric polymorphism
19:47:18 <EvilMachine> I never got that whole “*We must have a groupthink! And there can only be one*” mindset. Especially Haskell programmers should see that this requires to make this constant a parametrized function, no?
19:47:40 <Twey> EvilMachine: Well, it is an option.
19:47:43 * EvilMachine is talking about any “the community has spoken” decisions.
19:47:47 <edwardk> k <- nextKey %%= \k -> (k, k +1)
19:47:51 <Twey> EvilMachine: The question is the default value.
19:48:04 <EvilMachine> Twey: ah,yeah
19:48:11 <donri> edwardk: yea, crippled library.
19:48:20 <donri> you destroyed the whole elgance of it
19:48:24 <EvilMachine> Twey: that should simply be the statistically most often used choice. :)
19:48:35 <nand`> k <- (nextKey ++)
19:48:38 * nand` runs
19:48:41 <donri> and i bet because one or two people complained (compared to all the people *not* complaining)
19:48:42 <Twey> EvilMachine: Hard to measure
19:49:02 <edwardk> well its not just that
19:49:04 <EvilMachine> Twey: Make a choice, and look how many complain. ;)
19:49:10 <edwardk> it also impacts the usability of the library in another way
19:49:19 <Twey> EvilMachine: I think that's what we're doing, maybe.
19:49:19 <edwardk> i can use ~= with a _setter_ right now
19:49:27 <EvilMachine> Twey: I think too.
19:49:28 <edwardk> i can only use it with a lens with your signature
19:49:40 <nand`> ~= ?
19:49:42 <edwardk> thats a BIG drop in functionality
19:49:45 <edwardk> i meant +=, etc.
19:49:48 <donri> edwardk: well ok, could you maybe provide both APIs then?
19:50:05 <edwardk> hrmm
19:50:18 <edwardk> need to find more symbols ;)
19:50:21 <EvilMachine> Oh man, I always am in awe of the people in this channel when I come back! Educated, rational, friendly discussion! ON THE INTERNET! You guys bring tears of joy to my eyes. (Literally.)
19:50:26 <nand`> this is one of my favorite lines: ballSpeed.both *= speedIncrease
19:50:36 <roconnor> edwardk: try unicode
19:50:41 <edwardk> roconnor: =)
19:50:47 <luite> noooo :)
19:51:00 <nand`> I already suggested using ≈ for state-lifted functions :P
19:51:01 <edwardk> i suppose i can look for something that looks like the tail of an arrow
19:51:04 <nand`> *≈
19:51:05 <edwardk> since it'll always be pair with one
19:51:09 <edwardk> er paired
19:51:25 <edwardk> x <- nextKey -<+ 2  ?
19:51:36 <edwardk> -<- collides though
19:51:37 <nand`> looks like arrows
19:51:53 <edwardk> yeah, well it should ;)
19:52:03 <donri> i like it
19:52:33 <edwardk> how about a deal
19:52:55 * nand` .oO ( (~=) -> (≅) )
19:52:57 <edwardk> you send me a patch with those operators for adding those things in Control.Lens.Setter and i'll accept it
19:53:29 <edwardk> -<% -<- -<+ -<* -<^ -<^^ -<** -<&& -<||, etc.
19:53:38 <donri> didn't you say -<- collides?
19:53:46 <edwardk> can't think of with what
19:53:48 <donri> @hoogle -<-
19:53:48 <lambdabot> Unknown flag: -<
19:53:48 <lambdabot>  
19:53:54 <nand`> why not just +< -< *< etc.
19:53:55 <donri> @hoogle (-<-)
19:53:55 <lambdabot> No results found
19:54:02 <nand`> to mirror += -=
19:54:14 <edwardk> thought about it, but i worry about -<
19:54:15 <donri> -< collides with arrow syntax
19:54:19 <edwardk> yeah
19:54:19 <nand`> ah
19:54:26 <nand`> +=<
19:54:29 <nand`> meh
19:54:58 <edwardk> of course if they don't turn arrow syntax there is no collision
19:54:59 <nand`> maybe ^+= or something along those lines to indicate the ‘reading out’
19:55:06 <nand`> +=^
19:55:12 <nand`> +^=
19:55:16 <donri> nand`: what's wrong with the ones edwardk proposed?
19:55:17 <edwardk> i kinda like the +<  indicating that the answer will be available to the left
19:55:23 <mm_freak_> x <- nextKey -<+ 2
19:55:29 <mm_freak_> looks an awful lot like arrow syntax
19:55:30 <nand`> donri: I just think -<+ is a bit awkward and unclear of its intentions
19:55:46 <edwardk> mm_freak_: fairly deliberately i admit
19:55:47 <mm_freak_> i would always think like 2 going into the computation nextKey
19:56:06 <edwardk> x <- nextKey +< 2    ?
19:56:15 <mm_freak_> <+<
19:56:23 <nand`> word
19:56:28 <edwardk> hrmm
19:56:30 <donri> pipes uses <+<, if that matters
19:56:38 <donri> mm_freak_: but it does go in nextKey, that's the point
19:56:40 <mm_freak_> that collides with an operator from 'pipes', but anyway
19:57:01 <mm_freak_> donri: it still looks a bit confusing for someone who does AFRP like me =)
19:57:35 <nand`> <*< <+< looks like something to do with kleisli arrows or applicatives
19:57:36 <donri> mm_freak_: well we already have <~ quite intentionally for the purpose of looking like <-
19:57:45 <edwardk> 1 <- nextKey +<< 2
19:57:47 <johnw> what is current state-of-the-art for Haskell and regexps?
19:57:54 <edwardk> er x <- nextKey +<< 2
19:57:56 <donri> edwardk: again -<< collides with arrows i think
19:57:59 <edwardk> yeah
19:58:01 <johnw> http://www.haskell.org/haskellwiki/Regular_expressions is daunting
19:58:01 <donri> specifically arrowapply
19:58:10 <edwardk> er x <- nextKey +<<<<<< 2
19:58:13 <edwardk> =)
19:58:15 <donri> johnw: i like "rex"
19:58:18 <nand`> :::::+
19:58:36 <Soultaker> are let-clause pretty much mandatory in combination with do-blocks, or is there an elegant way to use where-blocks too?
19:58:43 <mm_freak_> in netwire i often use this syntax:  ~<~
19:58:48 <mm_freak_> like a signal with a direction
19:59:08 <Iceland_jack> Eh, why do I get this:
19:59:08 <Iceland_jack> => :t (0 - 0)
19:59:08 <Iceland_jack> (0 - 0) :: (RealFloat a) => [[Complex a]]
19:59:17 <edwardk> the problem is how to smash an operator in that without a 4 char operator ;)
19:59:22 <nand`> Iceland_jack: :t (-)
19:59:23 <mm_freak_> :t 0 - 0
19:59:25 <lambdabot> forall t. (Num t) => t
19:59:49 <danil> johnw: I think people tend to use parser combinators over regexps when they can, for readability and extensibility reasons
19:59:53 <Iceland_jack> It's from ghci 6.12.1
20:00:02 <Iceland_jack> And I've imported the Complex module
20:00:04 <edwardk> <+=   <-=  <*=  <//=   <&&=  <||=   <%=  etc
20:00:07 <mm_freak_> Iceland_jack: that's /quite/ outdated
20:00:07 <nand`> <+~ <+=
20:00:10 <nand`> bah
20:00:15 <edwardk> hows that?
20:00:20 <nand`> I like the way that looks
20:00:25 <mm_freak_> edwardk: that looks good
20:00:30 <edwardk> and the <+~ variants can work for the functional ones
20:00:36 <nand`> it's like +=, but the < indicates the argument being available ‘to the left’
20:00:38 <Iceland_jack> edwardk: so this isn't normal?
20:00:47 <Iceland_jack> => (0 - 0)
20:00:47 <Iceland_jack> [[14.0 :+ (-25.0),24.0 :+ (-1.0)],[(-35.0) :+ (-25.0),(-4.0) :+ (-25.0)],[14.0 :+ (-3.141592653589793),3.0 :+ (-0.0)]]
20:01:13 <nand`> looks good to me
20:01:15 * nand` jokes
20:01:27 <nand`> Iceland_jack: have you tried :t (-) ?
20:01:34 <Iceland_jack> => :t (-)
20:01:34 <Iceland_jack> (-) :: (RealFloat a) => t -> t1 -> [[Complex a]]
20:01:41 <nand`> well there's your problem
20:01:45 <mm_freak_> Iceland_jack: then you redefined (-) somewhere
20:01:58 <nand`> Iceland_jack: is this in a fresh ghci?
20:02:11 <edwardk> donri: willing to write the patch for those setters?
20:02:16 * hackagebot snap-extras 0.2.2 - A collection of useful helpers and utilities for Snap web applications. (OzgunAtaman)
20:02:17 <mm_freak_> Iceland_jack: perhaps something like:  let 1 - 2 = …
20:02:24 <edwardk> or you want to wait until i get around to it some time?
20:02:24 <mm_freak_> that redefines (-)
20:02:31 <Iceland_jack> hm, that's possible
20:02:43 <donri> edwardk: i'll try tomorrow and i'll file an issue for it now listing the operators?
20:02:56 <mm_freak_> Iceland_jack: try:  :t 0 Prelude.- 0
20:03:07 <EvilMachine> johnw: basically, regexces work fine, and http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html#glob.regex explains them nicely
20:03:07 <mm_freak_> that gives you the type for the predefined (-)
20:03:08 <edwardk> well if it'll be tommorow then i'll just bang it out now rather than work on the indexed stuff
20:03:21 <Iceland_jack> => :t 0 Prelude.- 0
20:03:21 <Iceland_jack> 0 Prelude.- 0 :: (Num t) => t
20:03:29 <mm_freak_> yes, that's the correct type
20:03:35 <donri> edwardk: well it's 5am here and i probably should sleep ;)
20:03:46 <Iceland_jack> I looked through the history and I don't appear to redefine - anywhere
20:03:51 <edwardk> understood, ill still just bang em out
20:03:58 <nand`> Iceland_jack: try again in a fresh ghci
20:04:02 <nand`> if it still happens, check .ghci
20:04:04 <donri> edwardk: what does bang em out mean?
20:04:10 <nand`> it means ‘write them’
20:04:14 <EvilMachine> johnw: but replacing in the problem. Since for perl-compatible regexes, you have to write your own replace function, since according to the maker, there were too many ways to make one, and it’s not really sensible to make a general one. I disagree with that though.
20:04:14 <donri> ah, cool
20:04:15 <Iceland_jack> nand`: It doesn't happen in a fresh session + :m + Complex
20:04:22 <mm_freak_> Iceland_jack: one of your loaded modules may do it…  if there aren't any, note that it's fairly easy to redefine stuff in haskell
20:04:31 <nand`> try :info (-)
20:04:35 <mm_freak_> Iceland_jack: something as simple as "let 3 - 2 = 1" redefines (-)
20:04:37 <johnw> i just need a =~ predicate is all.  Think I'll use Text.Regex.Posix
20:04:48 <mm_freak_> Iceland_jack: i.e. something with (-) to the left of "="
20:04:51 <Iceland_jack> -- Defined at <interactive>:1:5 ← there we go
20:05:09 <nand`> =~ ?
20:05:13 <EvilMachine> johnw: I find Posix (even extended) regexes to be way too limiting for my needs.
20:05:14 <nand`> oh
20:05:18 <mm_freak_> and the position suggests it was indeed a 'let' binding =)
20:05:19 <EvilMachine> nand`: http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html#glob.regex
20:05:23 <nand`> you're talking about regex, I thought you were talking about lenses too
20:05:25 <Iceland_jack> heh... I'm coding at late hours
20:05:29 <EvilMachine> nand`: lol
20:05:33 <Iceland_jack> and that just freaked me out
20:05:34 <EvilMachine> nand`: lenses?
20:06:18 <Veinor> right now i have something along the lines of do { r <- ar; return $ do { c <- ac; return $ f r c}}
20:06:28 <Veinor> is there a nicer way to write that nested do?
20:06:32 <Iceland_jack> Thanks, and I can shadow my freak of nature with a: let (-) = Prelude.- ?
20:06:42 <nand`> you could, yes
20:06:56 <nand`> (Prelude.-)
20:07:04 <Iceland_jack> Oh it's infix
20:07:10 <Iceland_jack> of course
20:07:34 <Iceland_jack> but now it only works for Integers?
20:07:34 <rohit> Boney
20:07:39 <mm_freak_> Veinor: return (liftM (f r) ac)
20:07:40 <Iceland_jack> Integers -> Integers -> Integers
20:08:00 <mm_freak_> Veinor: or (nicer) fmap instead of liftM, if your types allow that
20:08:09 <Guest61220> hi guys can you tell me how hard haskell is to learn
20:08:14 <Guest61220> compared to java and c
20:08:25 <mm_freak_> Guest61220: if you are a programmer, it's hard
20:08:31 <nand`> about 7.4 on the mohs scale
20:08:40 <mm_freak_> if you're not, it might be easier to learn than java/c
20:08:41 <Veinor> Guest61220: depends on what you know already
20:09:00 <Guest61220> well im fairly new to programming
20:09:10 <mm_freak_> Guest61220: that will come to your advantage
20:09:18 <Veinor> ... oh, I just want liftM2
20:09:20 <Guest61220> and plus im good at forgetting things so that might be a plus in this sense
20:09:35 <mm_freak_> java and C programmers have a harder time learning haskell
20:09:52 <Guest61220> can you tell me in which sense
20:09:52 <mm_freak_> particularly java programmers, who try to squeeze everything into OO
20:10:08 <Guest61220> 00?
20:10:14 <pharaun> oop
20:10:17 <Guest61220> oh lol
20:10:21 <mm_freak_> Guest61220: imperative programming is very different from declarative programming
20:10:22 <Cale> Guest61220: It's mainly just different -- people who are used to imperative programming will find it "hard", because they're used to learning imperative programming languages which are just reskinnings of languages they already know.
20:10:49 <Veinor> wait, no i don't
20:10:54 * nand` .oO ( Functional languages aren't reskinnings of other functional languages? )
20:10:59 <Guest61220> imperative in the sense it is top down and has no methods?
20:10:59 <Cale> But in absolute terms, I don't think it's any harder than learning your first programming language.
20:11:02 <mm_freak_> Guest61220: if you know neither, you will have an easier time to learn either one of them, because you can subtract the time needed to unlearn the other
20:11:13 <mauke> Guest61220: ... no
20:11:18 <Cale> nand`: Most people don't know a functional programming language already.
20:11:23 <Veinor> i want (a -> b -> c) -> m a -> m b -> m (m c)
20:11:26 <nand`> Guest61220: imperative in the sense of mutable variables and execution flow
20:11:31 <mauke> Guest61220: imperative in the sense that a program is a series of instructions
20:11:31 <mm_freak_> Guest61220: imperative programming means that you pass instructions to the machine…  almost all commonly used languages are like that…  a notable exception is SQL
20:11:41 <notthemessiah> at Hac Phi, an 8 year old was learning Haskell
20:11:42 <Ralith> nand`: functional language designers tend to have more originality in my experience!
20:11:53 <Cale> Though I don't know, people who learn Haskell first have told me they had no problem with imperative programming afterward
20:11:59 <mauke> Guest61220: and at each point in time there's a "current instruction" that's being executed
20:12:02 <Ralith> Veinor: hoogle
20:12:13 <Cale> Though everyone who learns imperative programming first seems to take a while unlearn‌ing bad habits.
20:12:22 <mm_freak_> imperative programming can be expressed nicely in a declarative DSL…  the other way is hard
20:12:39 <nand`> free monads :)
20:12:40 <Guest61220> can you guys give a sort of syntax for this language and the types of applications its used in
20:12:49 <nand`> what language?
20:12:56 <Ralith> it is used in whatever you want to do with it
20:12:59 <Cale> Guest61220: Haskell is general purpose. You can use it for essentially anything.
20:13:15 <Twey> nand`: Functional languages *aren't* reskinnings of other functional languages, or at least a significant number are not
20:13:22 <mm_freak_> one exception is embedded devices…  currently in practical terms haskell is not well suited for that
20:13:27 <Guest61220> haskell
20:13:36 <Cale> The things which make it good also don't tend to make it good for just one thing, they tend to apply to all programs.
20:13:39 <mm_freak_> Guest61220: just grab the book "learn you a haskell"
20:13:41 <mm_freak_> @where lyah
20:13:42 <lambdabot> http://www.learnyouahaskell.com/
20:13:45 <mm_freak_> you can read it online
20:13:57 <Cale> Yeah, just start learning the language and you'll get a good sense of the syntax quickly.
20:13:59 <roconnor> mm_freak_: apparently embedded devices are more powerfull than computers in the 1990's when Haskell was developed.
20:14:01 <Twey> nand`: New functional languages tend to be significantly different to existing functional languages
20:14:18 <Cale> Twey: Oh, good point, that's true as well.
20:14:25 <nand`> Twey: I guess it's usually just that there's no reason to reskin an existing language
20:14:28 <mm_freak_> roconnor: yeah, but still it's impractical to write embedded software in haskell today
20:14:37 <Twey> nand`: Mmm
20:14:48 <roconnor> mm_freak_: maybe
20:14:53 <Cale> Functional programmers seem somehow more pragmatic about language design, and tend not to design a new language without a good drastic change or two, it seems.
20:14:54 <Guest61220> last questions before i go, umm i saw a job listing for a compiler developer and it said "MUST KNOW HASKELL"
20:14:56 <nand`> since the semantics of functional languages tend to be more condensed and down to the point than those of imperative languages which include wildly arbitrary operators and control structures
20:15:10 <roconnor> mm_freak_: it's probably better to gerenate embedded software in haskell.
20:15:11 <luite> Guest61220: where?
20:15:16 <mm_freak_> Guest61220: haskell is a great language for compiler development…  it's almost unique in that regard
20:15:17 <luite> :p
20:15:26 <mm_freak_> Guest61220: so chances are they are writing their compiler in haskell
20:15:31 <Guest61220> so im just wondering is haskell used in compilers alot?
20:15:52 <Guest61220> luite its from a university work study program
20:15:52 <nand`> it's fairly popular for compiler design afaik
20:15:53 <Cale> Guest61220: I've heard of some people using Haskell as a filter to screen out bad candidates, because most people willing to learn Haskell actually care about program quality and such.
20:16:00 <Twey> nand`: I think it's more to do with reduced popularity.  With imperative languages, there's a lot of brand-war going on.  Functional languages don't have that, tend to be more extensible (so minor changes can be implemented in an existing language, rather than a new one), and are often designed by mathematicians/computer scientists, who are more interested in fundamental theoretical language designs than syntactic tweaks
20:16:06 <mm_freak_> Guest61220: the most common haskell compiler is GHC, which is written in haskell and the development of GHC is faster than of any other compiler i know
20:16:25 <mm_freak_> look, come back in three months, you'll find new features
20:16:31 <mm_freak_> other compilers seem to fix bugs most of the time
20:16:32 <Cale> Won't always work -- there are universities which require Haskell from all students after all -- but might bias things the right way :)
20:16:43 <nand`> Twey: I feel that certainly goes for Haskell, which is just all kinds of “done right”
20:17:18 <mm_freak_> nand`: almost all
20:17:43 <Cale> Yeah, I suppose there's also just not enough of us to support another ten GHC-like projects.
20:17:51 <Twey> Cale: Eh, universities never focus on minority languages like Haskell to such an extent that a bad programmer won't be able to pass the course unless they have a good enough knowledge of Haskell to actually write programs
20:17:53 <Guest61220> ok thx guys! wow honestly the main driving force for learning haskell now is the quick responses and the vast knowledge of everyone here =P lol wish there was a chat thing for java
20:18:02 <mauke> ##java
20:18:02 <Guest61220> thx again
20:18:05 <nand`> mm_freak_: I think most of my annoyances stem from base, not the core language (minus the standardized Prelude)
20:18:11 <Twey> Guest61220: There's one at ##java, though it's not quite as friendly.
20:18:14 <Cale> Twey: but someone who took such a course could claim to know Haskell :)
20:18:17 <mm_freak_> Guest61220: there is, but the we are especially nice =)
20:18:29 <Cale> Twey: oh, I see what you mean -- maybe :)
20:18:32 <Twey> Cale: You mean someone would just go on the Internet and lie about themselves?
20:18:50 <Cale> Twey: haha
20:18:52 <EvilMachine> impossibru! XD
20:19:07 <mapreduce> Guest61220: ##java isn't bad but has some topic nazism and you just left.
20:19:08 <mauke> Twey: you really think someone would do that?
20:19:12 <Cale> http://static.fjcdn.com/pictures/You+really+think+someone+would+do+that+.+Just+go+on_981b71_3201562.jpg
20:19:15 <Twey> A company that was serious about their Haskell requirement would presumably FizzBuzz it in the interview.
20:19:23 <mm_freak_> nand`: from time to time i miss the power of dependent types, but most of the time i find ways around that lack in haskell
20:19:30 <Twey> mapreduce: Don't you love it when that happens?
20:19:34 <aristid> Twey: "make a fizzbuzz in haskell"?
20:19:47 <EvilMachine> I’ll tell you a secret: On the Internet, people aren’t what they are, but what they *want* to be. (Yep, I want to be a more evil machine, i guess. :)
20:20:01 <Twey> mapreduce: Not just topic naziism; I was once kicked for asking how to make Swing work with input methods.
20:20:20 <EvilMachine> Twey: lol
20:20:21 <Twey> aristid: Or an equivalent problem, yes.
20:20:27 <mm_freak_> FWIW haskell programmers do care about evil machines
20:20:29 <mm_freak_> http://www.youtube.com/watch?v=3kEfedtQVOY =)
20:20:48 <mm_freak_> (they are referred to as "weird machines" in that video)
20:20:52 <Twey> Heh
20:21:18 <mapreduce> Twey: There are some ops who shouldn't be, but practically as long as you're on topic that should be limited.
20:21:27 <Twey> EvilMachine: I love Facebook &a.'s ‘lack of privacy’ for that reason.
20:21:50 <Twey> EvilMachine: I think I've become a much better person since my online and offline personae have been Strongly Encouraged to merge.
20:22:26 <nand`> mm_freak_: I can't complain, never done anything in agda so I have nothing to reminisce upon
20:23:13 <EvilMachine> Twey: Please! I have 3 personalities! A offline official one. A online official one (this one). And a online secret one (named as something I could not even admit to anyone in reality, so I won’t ever reveal the connection.)
20:23:27 <mm_freak_> nand`: most of the time when you use empty data declarations or the DataKinds extension you're essentially faking dependent types
20:23:28 <mapreduce> PLT Borat
20:23:38 <EvilMachine> Twey: I may add a online secret one, once I become SuperHaskellMan. :P
20:23:40 <edwardk> (<<>~) is a little funny looking but overall they seem sound
20:23:50 <donri> heh
20:23:57 <mm_freak_> edwardk: as long as it's consistent
20:24:02 <nand`> I sometimes ask questions on ##csharp and get weird stares; eg. ‘why would you want that?’ or ‘that seems like an unorthodox solution to me’ :(
20:24:05 <edwardk> yeah
20:24:09 <nand`> when approaching problems functionally
20:24:39 <mm_freak_> C# programmers aren't aware of declarative programming when they use it
20:24:40 <Twey> EvilMachine: Yeah, I did something like that to start with, then decided I couldn't be arsed, and sorted all the secret things into things I shouldn't mind admitting to people and things I just shouldn't do, and I've been much happier ever since :þ
20:24:44 <mm_freak_> they think of LINQ like SQL
20:24:44 <mapreduce> nand`: There, talk to jonp.  He implemented much of Haskell's prelude in C#. :)
20:24:49 <levi> Leave it to haskell programmers to weird out the muggles. :P
20:24:52 <nand`> it took me a while to realize what <<>~ meant, I was parsing ‘<<’
20:24:55 <mauke> nand`: hah, try writing an OO solution in haskell
20:25:01 <Cale> nand`: DECOMPOSING PROBLEMS THAT WAY IS BAD AND YOU SHOULD FEEL BAD
20:25:05 <Twey> Haha
20:25:20 <aristid> mauke: and how do they think of SQL?
20:25:21 <Twey> nand`: OO solutions in Haskell are easy!  :þ
20:25:23 <levi> Heh, LINQ is like SQL, which is kind of the point.  They're both declarative languages.
20:25:24 <aristid> i mean mm_freak_
20:25:47 <aristid> stupid nicks all beginnign with M. good that i changed my nick away from something beginning with M a few years ago
20:25:56 <EvilMachine> Twey: No. I value this thing calley *privacy*. Because telling everyone everything results in huge disadvantages. In fact, studies showed, that out society would’t ever work without the ablility to lie, and would break down.
20:26:03 <aristid> levi: SQL is a pretty bad declarative language.
20:26:05 <EvilMachine> Twey: But this becomes seriously OT.
20:26:10 <edwardk> interestingly <<>~ is pretty powerful
20:26:16 <mm_freak_> aristid: database queries…  the declarative nature isn't obvious for SQL
20:26:18 <levi> But you program *databases* declaratively with SQL, and you code everything else in C# in an object-oriented manner, because that's just the way you do things.
20:26:37 <aristid> mm_freak_: so they view LINQ as a nicer syntax to query databases?
20:26:46 <edwardk> when applied to a traversal it'll update every one of the entries with a monoidal update and, then mappend all of them together giving you the aggregate answer
20:27:00 <mm_freak_> aristid: most of the time in my experience
20:27:06 <aristid> mm_freak_: funny
20:27:06 <Twey> EvilMachine: I'd be interested in that study.  I was thinking about this earlier today.
20:27:12 <edwardk> most of the others just won't make sense when you try to mash them onto a traversal
20:27:38 <mapreduce> I've had C#ers not realise that linq wasn't only for collections (and say nothing at all about sql).
20:27:43 <edwardk> and unlike the others (<.~) can be run on a Setter
20:27:57 <mm_freak_> EvilMachine: the scope of this channel goes well beyond haskell =)
20:28:02 <EvilMachine> Twey: Well, I know it was in a “Spektrum der Wissenschaft” (German version of the Scientific American) somewhere between 2007 and 2001. That’s all I can remember. :/
20:28:37 <nand`> edwardk: example use case for <<>~ ?
20:28:48 <edwardk> no idea
20:28:51 <edwardk> consistency
20:28:58 <edwardk> just thought it was interesting that it worked
20:29:06 <EvilMachine> Twey: more correctly: It was a popular science article referencing the actual paper done by the same author, after some peer review, if i remember it correctly.
20:29:11 <mm_freak_> what is (<<>~)?
20:29:32 <Twey> EvilMachine: Ahuh.  That's very unhelpful as a search query :þ  But thank you anyway.
20:29:34 <aristid> mm_freak_: fish
20:29:34 <mm_freak_> monoid append?
20:29:40 <edwardk> yeah
20:29:48 <edwardk> looks like a rat
20:29:50 <mm_freak_> oh, that sounds useful to me
20:29:54 <nand`> how do the pure combinators even work? Setting a b c d -> c -> a -> (c, b) ?
20:29:59 <aristid> edwardk: true, might be a rat too
20:30:09 <nand`> why not a mouse
20:30:20 <edwardk> nand`: the ones that give the result have to be in Lens
20:30:21 <aristid> no, that'd be just ridiculous
20:30:30 <nand`> oh, right
20:30:34 <mm_freak_> rats are an escalation of mice
20:30:34 <EvilMachine> Twey: well… subscribers have access to the complete archive with a indexed full-text search. so i would probably find it, if i were still a subscriber.
20:30:44 <nand`> Monoid c => Lens a b c c -> c -> a -> (c, b) -- ?
20:30:49 <edwardk> (<*~) :: Num c => LensLike ((,)c) a b c c -> c -> a -> (c, b)
20:30:54 <levi> edwardk: So, I have been pondering binary parsing / data handling for a while, and recently I had a need to extract arbitrary fields from a packed binary data structure without going through the bother of parsing the entire thing out. Do you think your lens library would be applicable to doing this, given a chunk of binary data and a structure that described the layout of the data?
20:31:17 <edwardk> levi: not sure.
20:31:29 <mm_freak_> levi: if the grammar is context-free, then yes
20:31:29 * EvilMachine has to go offline now, because of that 28c3 video link. thanks, now I can’t stop before that *one hour video* is over. ;)
20:31:33 <edwardk> the trick would be that you probably have it in some kind of pointer to foreign memory
20:31:47 <edwardk> and thats awkward with the side-effects
20:32:05 <edwardk> nand`: yep
20:32:13 <mm_freak_> (assuming that the data is in a ByteString, so can be accessed purely)
20:32:26 <edwardk> oh yeah, bytestrings to the rescue
20:32:42 <levi> Well, the actual use case I had was in a C program with data read off the network, but I've been considering prototyping something in haskell.
20:33:07 <mm_freak_> yeah, lenses can help there, but i suggest translating the binary data into a record in haskell anyway
20:33:08 <johnw> sometimes, functional composition in Haskell is just awesome: https://gist.github.com/3281161
20:33:10 <levi> I'd probably get it in a bytestring or similar in Haskell.
20:33:21 <mm_freak_> you can do that in a way that only accessing a field of that record causes the parsing
20:33:42 <mm_freak_> remember that haskell is lazy =)
20:34:05 <nand`> name (==) -- <- that doesn't seem right
20:34:33 <mm_freak_> in other words, you shouldn't represent network packets as strings in haskell…  make use of the laziness
20:34:56 <johnw> huh, it worked with (==) name
20:35:05 <johnw> i guess name `==`, right?
20:35:24 <Cale> That's illegal
20:35:26 <johnw> ah, (name ==)
20:35:27 <levi> A straightforward Haskell parser would just parse everything up to and including that field when you asked for it, though, which is not at all what I want.
20:35:29 <johnw> return . (name ==) . filename
20:35:33 <Cale> Can't wrap an infix operator in backticks
20:35:40 <Cale> (because it's already infix)
20:35:44 <nand`> yes that looks better
20:36:08 <levi> The particular protocol I was dealing with had tons of tiny bitfields that were really expensive to parse out.
20:36:13 <aristid> @hoogle findWhen
20:36:14 <lambdabot> No results found
20:36:20 <mm_freak_> levi: don't think in terms of parsec…  a simple bytestring accessor for a network packet is also a parser
20:36:31 <aristid> johnw: where's findWhen coming from and what's its type?
20:36:45 <johnw> it's from shelly: findWhen :: (FilePath -> Sh Bool) -> FilePath -> Sh [FilePath]
20:36:55 <levi> mm_freak_: Sure, but my idea was to make those the back-end to the lenses for the data.
20:37:13 <johnw> it's basically like UNIX find
20:37:24 <levi> If such a thing was feasible with lenses, anyway.
20:37:28 <aristid> johnw: hmm, i think a pure version would be nice
20:37:33 <mm_freak_> levi: first translate into a record, then provide lenses to that one…  you could write lenses for the underlying bytestring, but i really recommend against that
20:37:41 <johnw> how would a pure version get access to the filesystem?
20:37:52 <aristid> johnw: no, not THAT PURE
20:38:02 <johnw> there are grades of pure?
20:38:05 <aristid> just define findWhenPure = findWhen . (.) return
20:38:09 <levi> mm_freak_: I see what you mean, what you describe would probably do what I want it to, then.
20:38:14 <johnw> ah
20:38:19 <johnw> you mean, takes a pure predicate
20:38:22 <aristid> yes.
20:38:36 <johnw> I guess shelly wanted you to be able to stat the item being considered by find
20:38:44 <aristid> johnw: your predicate is pure and i believe a lot of predicates are
20:38:50 <johnw> yes, I think so to
20:38:50 <aristid> sure, non-pure find is fine
20:38:51 <johnw> o
20:39:01 <aristid> nice to have both conveniently
20:39:17 <edwardk> ghci> _1 <*~ 2 $ (2,3)
20:39:18 <edwardk> (4,(4,3))
20:39:27 <edwardk> ok, the functional ones are in
20:39:46 <aristid> edwardk: mouse!
20:40:18 <edwardk> ghci> _1 <<>~ "world" $ ("hello",3)
20:40:18 <edwardk> ("helloworld",("helloworld",3))
20:41:42 <sayuke> what is the meaning of data types appended by # eg State# ?
20:42:01 <roconnor> sayuke: usually it means unboxed
20:42:11 <edwardk> they are just a syntactic clue that its probably something system related and unboxed
20:42:24 <aristid> edwardk: have you considered using named operators with infix syntax instead of symbol soup? :)
20:42:33 <edwardk> aristid: no
20:42:36 <sayuke> thanks
20:42:47 <edwardk> aristid: i don't like this particular batch of operators
20:42:52 <edwardk> because of the symbol soup problem
20:43:00 <aristid> edwardk: i'm not sure i could remember those symbols
20:43:11 <edwardk> start with +=   -= , etc.
20:43:14 <mm_freak_> sayuke: think of the "#" suffix meaning "low level" =)
20:43:17 <edwardk> replace = with ~ to make it functional
20:43:28 <mm_freak_> in other words:  "don't use me, unless you know what you're doing" =)
20:43:30 <edwardk> put < on the left to get the result out as well
20:43:34 <Twey> Personally I think of it as meaning ‘magic implementation detail’ :þ
20:43:38 <edwardk> those are the two rules
20:43:52 <aristid> and << gets the result out twice?
20:44:07 <mm_freak_> aristid: < <> ~
20:44:13 <aristid> oh,
20:44:14 <danharaj> clearly << should be traversal because you go lots of places
20:44:21 <edwardk> <<>=   is <> onto a lens in the state monad, and give the answer
20:44:26 <aristid> well that's not obvious
20:44:35 <nand`> it fits nicely into the system though
20:44:35 <mm_freak_> it'S consistent =)
20:44:43 <edwardk> x <- mystringsofar <<>= "hello"
20:44:55 <nand`> += is obvious; and <+= if you've read the explanation is comprehensible as well
20:44:58 <edwardk> its not obvious, but these aren't the combinators i expect peopel to start with ;)
20:45:34 <mm_freak_> edwardk: if you want to be nice to me, add a builtin combinator that goes from 'f a' to 'f ()' =)
20:45:41 <nand`> there's also the consistent rule of =/~ among pretty much all operators as well
20:45:45 <edwardk> mm_freak_: its called void
20:45:50 <danharaj> I'd like an operator form for 'withIndex' because that's how I tend to use indexed traversals, but I doubt there's a symbol that isn't superfluous
20:45:51 <nand`> so that means you ‘understand’ +~ <+~ for free
20:45:52 <aristid> @hoogle void
20:45:53 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
20:45:53 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
20:45:53 <lambdabot> package void
20:45:56 <mm_freak_> edwardk: i know, but it requires an import
20:46:07 <edwardk> i'm not planning on re-exporting it
20:46:15 <edwardk> it already has a home =P
20:46:19 <aristid> the one from Control.Monad?
20:46:22 <edwardk> yeah
20:46:28 <edwardk> the worst placed operator ever
20:46:30 <aristid> don't you always have Control.Monad imported anyways? :D
20:46:39 <edwardk> lets make something that doesn't work with monads live in Control.Monad!
20:46:51 <aristid> edwardk: heh
20:47:00 <edwardk> so that when you have a Monad m => … you can't do anything with it and have to liftM (const ()) anyways!
20:47:02 <aristid> yeah Data.Functor would've been too obvious
20:47:33 * nand` gets confused over the distinction between Control and Data all the time
20:47:33 <mm_freak_> sometimes i'm compelled to write a proxy module for my package to reexport the 20 modules i import all the time (but then i don't, because that doesn't feel right)
20:47:48 <edwardk> nand`: there isn't one, its all an illiusion
20:48:13 <Twey> mm_freak_: Like Yesod does?  :þ
20:48:15 <edwardk> actually i stand corrected, there is one worst placed operator… fail ;)
20:48:32 <nand`> (why is Lens in Control.Lens even though lenses are just functions which are Data.Function ?)
20:48:33 <mm_freak_> Twey: nah, not for the library user, but for myself =)
20:48:43 <Twey> mm_freak_: Like Yesod does :þ
20:48:43 <edwardk> nand`: honestly?
20:48:57 <edwardk> partially because Data.Lens was taken and many people will need to interoperate with both
20:49:03 <danharaj> cps functions are clearly more controly than data
20:49:04 <aristid> haha
20:49:06 <mm_freak_> i don't know what the code of yesod looks like…  TH already scares me off =)
20:49:09 <Twey> mm_freak_: Seems reasonable, to be honest
20:49:13 <Twey> It's just a convenience thing.
20:49:27 <mm_freak_> certainly, but i'm still scared
20:49:43 <edwardk> also it avoids confusion with the package name data-lens
20:49:52 <mm_freak_> paradoxically TH functions need to be documented best, but often are the worst documented functions in most library
20:50:09 <mm_freak_> -ies
20:50:29 <mm_freak_> yesod is particularly bad in this regard
20:50:34 <Twey> Aye
20:51:46 <mm_freak_> using hamlet in a non-yesod project proved to be a frustrating task, because the haddocks don't help with the TH/QQ-heavy API
20:51:56 <roconnor> nand`: I'm not aware of any distinction between Control and Data; It just seems randomly assembled to me.
20:52:34 <danil> that is a quintessentially Haskellish statement.
20:53:18 <Twey> Haha
20:54:02 <mm_freak_> danharaj: in that sense we should call it Data.Applicative instead of Control.Applicative
20:54:19 <Cale> That void function is silly
20:54:39 <mm_freak_> and Control.Profunctor instead of Data.Profunctor
20:55:02 <Cale> Control.* and Data.* are also silly ideas for hierarchy where there should be none.
20:55:11 <mm_freak_> that's the point
20:55:26 <mm_freak_> DSL.*
20:55:37 <tgeeky> I think this is the same problem as the decision of not defining any real heairachy with hackage
20:55:48 * nand` would be perfectly fine with eg. ‘import Lens.TH’
20:55:55 <tgeeky> it's not clear how one should dole out the global namespace of haskell modules, so we just don't :o
20:56:18 <nand`> but that would clash even more horrendously with other lens libs
20:56:26 <nand`> package imports work but I think they're ugly
20:57:06 <johnw> meh, is there a regex library that is meant to work efficiently with Data.Text.Lazy?
20:57:07 <mm_freak_> the syntax is ugly
20:57:09 <fryguybob> We should write all the software we want, *then* decide on the best names.
20:57:13 <mm_freak_> the idea isn't
20:57:29 <johnw> Data.Text.ICU and Data.Text.Lazy refuse to play together nicely
20:57:37 <mm_freak_> import Lens from "lens"
20:58:08 <mm_freak_> that would give rise to a command line tool to generate the dependencies in the cabal file
20:58:09 <nand`> I'm not 100% sure I like that, due to the convention of packages usually having ugly lowercase names with lots of hyphens in them
20:58:25 <nand`> I think it detracts from the beauty somewhat
20:58:28 <edwardk> nand`: too late ;)
20:58:35 <mm_freak_> if it weren't too late, i'd impose a standard there =)
20:58:57 <nand`> reminds me too much of #include <crypticname.h>
20:59:20 <edwardk> nand`: re Lens.TH at the top level there is a set of ancient module guidelines that frown on smashing stuff into the top level willy nilly
20:59:26 <mm_freak_> #include is /much/ worse, because it refers to the filesystem
20:59:27 * roconnor always uses Ca.R6.Lens
20:59:33 <edwardk> roconnor++
21:00:39 <zachk> whats that one do?
21:00:47 <mm_freak_> @karma +
21:00:47 <lambdabot> + has a karma of 48
21:00:51 <mm_freak_> =)
21:01:04 <zachk> @karma zachk
21:01:04 <lambdabot> You have a karma of 0
21:01:08 <zachk> :-(
21:01:12 <edwardk> @karma edwardk
21:01:13 <lambdabot> You have a karma of 11
21:01:23 <mm_freak_> @karma mm_freak
21:01:24 <lambdabot> mm_freak has a karma of 1
21:01:33 <mm_freak_> @karma mm_freak_
21:01:34 <lambdabot> You have a karma of 0
21:01:41 <edwardk> @karma dons
21:01:42 <lambdabot> dons has a karma of 1
21:01:50 <mm_freak_> was that reset at some point?
21:01:50 <edwardk> @karma lambdabot
21:01:51 <lambdabot> lambdabot has a karma of 7
21:01:54 <edwardk> looks like it
21:01:59 <Cale> Don't ask me why the karma keeps being reset
21:02:04 <edwardk> dons was in the 50s at one point
21:02:07 <Cale> yes
21:02:11 <danil> TIL: addition is less than 5 times as popular as edwardk
21:02:15 <Cale> or more even, I don't know
21:02:23 <edwardk> danil: i'll catch up eventually
21:02:34 <edwardk> people just don't know me as well yet
21:02:41 <nand`> > 3 `edwardk` 4
21:02:42 <lambdabot>   Not in scope: `edwardk'
21:02:50 <edwardk> as soon as i'm taught in gradeschools, i'm sure it'll even out
21:02:54 <Cale> +++
21:02:55 <mm_freak_> danil: i just wanted to know how often people refer to the '+++' combinator from Control.Arrow
21:03:05 <Cale> @karma +
21:03:06 <lambdabot> + has a karma of 49
21:03:12 <nand`> @check id
21:03:13 <lambdabot>   "Arguments exhausted after 0 tests."
21:03:16 <edwardk> @karma -
21:03:16 <lambdabot> - has a karma of -548
21:03:18 <edwardk> =)
21:03:19 <nand`> oh
21:03:28 <nand`> that one doesn't start its lines with ‘+++ ’ anymore
21:03:36 <mm_freak_> you cheated =)
21:03:43 <nand`> @karma C
21:03:44 <lambdabot> C has a karma of 1
21:03:48 <nand`> heh
21:03:50 <edwardk> @karma c/c
21:03:51 <lambdabot> c/c has a karma of 200
21:03:51 <nand`> C++ vs C--
21:03:54 * fryguybob is glad GHC now corrects my spelling.
21:03:57 <mm_freak_> C has a positive karma?  it always had a negative one
21:04:03 <mm_freak_> @karma c++
21:04:03 <lambdabot> c++ has a karma of -1
21:04:10 <nand`> C++-- ?
21:04:20 <shachaf> preflex: karma c
21:04:20 <preflex>  c: 192853
21:04:25 <mm_freak_> probably because people often write "c++" =)
21:04:36 <tgeeky> clearly c = -2
21:05:13 <Cale> Heh, anyone else remember that C/C++ RFE, where they decided to actually design a (really obnoxious) language actually called C/C++, just to thwart people who refer to them together like that all the time?
21:05:20 <edwardk> tgeeky: no. remember the ++ doesn't take effect until after you get the value out ;)
21:05:31 <mm_freak_> lol
21:05:47 <tgeeky> edwardk: yeah, but on the other hand, one can assume that the value "c" was cleverly and manually assigned
21:06:03 <tgeeky> hehe
21:06:04 <mm_freak_> > c
21:06:05 <lambdabot>   c
21:06:09 <mm_freak_> lol
21:06:21 <Clint> :t c
21:06:22 <lambdabot> Expr
21:06:38 <Twey> Cale: Ha, they should do so
21:06:45 <Cale> Someone should also name a language "c" (i.e. lowercase)
21:07:01 <Cale> Claim that you're naming the language after the speed of light.
21:07:13 <tgeeky> @type [a,b,c,d,e,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,z]
21:07:14 <lambdabot> [Expr]
21:07:17 <edwardk> ++c -- faster than the speed of light
21:07:27 <shachaf> @karma ++c
21:07:27 <lambdabot> ++c has a karma of -1
21:07:45 <mm_freak_> @karma --snip
21:07:45 <lambdabot> --snip has a karma of 0
21:08:34 <Cale> http://web.archive.org/web/20090331163943/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html
21:09:18 <nand`> edwardk: breaks about as many known laws of physics as C++ does
21:09:18 <Cale> Unfortunately, that's the only document that archive.org has from that site, apparently. There were at least a couple more.
21:10:36 <nand`> c / (c++)
21:10:49 <nand`> clearly, 1
21:11:07 <nand`> or undefined
21:11:23 <Cale> 1, followed by a very destructive update of the universe
21:11:35 <ezyang> Given a functor f, suppose I compute fmap fst x and fmap snd x (with x :: f (a, b)). How much extra structure do I need on f to compute the inverse?
21:12:09 <nand`> if c is 0 prior to evaluation, NaN followed by missiles being launched?
21:12:45 <ezyang> That is, the function 'f a -> f b -> f (a, b)'. I guess maybe that is the very definition of Zippable
21:13:15 <danil> ezyang: that + pointed gives you Applicative doesn't it?
21:13:35 <mm_freak_> nand`: haskell also breaks the laws of physics
21:13:44 <mm_freak_> 'mfix' passes a function its own result
21:14:24 <ezyang> Yeah, sort of looks like it.
21:15:12 <mm_freak_> ezyang: Applicative = Liftable + Zippable
21:15:40 <mm_freak_> or put differently:  Applicative = generalized SK calculus =)
21:15:52 <mm_freak_> K = pure, S = (<*>)
21:17:40 <danil> "strong lax monoidal functors," say the base docs
21:18:44 <Cale> Heh, modern physics has seemingly made it hard to analyse what it would even mean for the speed of light to change. Are distances through space a little different? Is time a little faster or slower? Could we even notice? (I think probably not.)
21:19:59 <Cale> Can the acceleration in the expansion of the universe also be explained as light slowing down?
21:20:21 <danil> We could notice if the ratio of c to other constants changed, I think
21:28:21 <mm_freak_> most notably E = mc²
21:29:07 <mm_freak_> a smaller c would make nuclear reactors less productive and nuclear weapons less destructive
21:29:18 <nand`> a little longer and haskell paper names will start sounding like ‘free energy’ scams
21:29:24 <mm_freak_> lol
21:29:36 <shachaf> Sensible people use c=1, so E=m
21:29:50 <nand`> we have ‘density’, how much longer until ‘energy’ is in use either way
21:30:06 <mm_freak_> and coenergy
21:30:34 <mm_freak_> how about the colight of cospeed?
21:30:52 <nand`> ‘o’
21:31:30 * nand` sleeps
21:31:45 <mm_freak_> and then we will be releasing comarkets to the coproduct
21:32:25 <mm_freak_> and finally, when ffee runs of cous, the big corip will die in a couniverse
21:33:51 <zygoloid_> /nfused is come
21:34:07 <mm_freak_> yeah, nfused are us
21:35:08 <wagle> Cale: light gets tired?
21:36:23 <tgeeky> Cale: VSOL theories are lead by Jose Madagego.
21:36:57 <tgeeky> if I could spell his name right
21:37:33 <tgeeky> http://en.wikipedia.org/wiki/Jo%C3%A3o_Magueijo
21:37:34 <tgeeky> that guy
21:38:47 <zzing_> Is there any reason not to use OpenGLRaw?
21:39:38 <Cale> zzing_: not any reason to try to avoid it, really
21:39:47 <tgeeky> I think (personally) that it falls in the category of credible but implausable; and it certainly isn't a *good* solution to the horizon problem, and it's not clear (to me) that his ideas are even testable in principle (no less practice)
21:40:23 <zzing_> I am developing some GLFW code, and the example presently uses the older OpenGL module, but I want the updated stuff for opengl3.2
21:40:41 <tgeeky> Cale: because it's hard to define exactly what you would see in the fine structure of the CMBR, if you are postulating that the speed of light (or alpha, or hbar, but not necesarily G_n) was different when the CMBR was formed
21:40:49 <tgeeky> Cale: I mean *really* hard
21:41:26 <Cale> tgeeky: I'm not even sure why you would see anything different at all.
21:42:50 <tgeeky> Cale: well, before we can say "different", we have to step into the group of physicists who think that it is, in practice, feasible to make initial state estimates from the CMBR anyway. That group is small, but includes some brillaint ones (Penrose, the brilliantest, probably)
21:46:13 <Cale> mm_freak_ mentioned that the conversion between energy and mass might differ as a result, but could you observe this difference, or will all the experiments you use to measure mass and energy be correspondingly affected so as to conspire to hide the difference?
21:47:19 * hackagebot persistent 1.0.0 - Type-safe, multi-backend data serialization. (MichaelSnoyman)
21:47:21 * hackagebot persistent-mongoDB 1.0.0 - Backend for the persistent library using mongoDB. (MichaelSnoyman)
21:47:23 * hackagebot persistent-mysql 1.0.0 - Backend for the persistent library using MySQL database server. (MichaelSnoyman)
21:48:05 <zzing_> Conceptually, should I be able to use the Raw and regular OpenGL modules at the same time progressively converting it over?
21:48:16 <Cale> zzing_: Yes.
21:48:38 <tgeeky> Cale: you could observe the difference. I think you could observe the difference in practice by doing the same particle physics experiments over a vast time scale (a few hundred million years?)
21:48:59 <edwardk> ezyang:check 'Apply' in semigroupoids
21:49:46 <tgeeky> It's not clear to me if they expect VSOL theories to explain things well after the CMBR domain wall or not, but I'm sure it's hoped they would provide testable things to particle physicists, and not just to lucky cosmologists
21:50:37 <tgeeky> bbiaf
21:51:41 <Cale> It gets really weird if the potential decay products of subatomic interactions is changing over time.
21:52:25 * hackagebot persistent-postgresql 1.0.0 - Backend for the persistent library using postgresql. (MichaelSnoyman)
21:52:27 * hackagebot persistent-sqlite 1.0.0 - Backend for the persistent library using sqlite3. (MichaelSnoyman)
21:52:29 * hackagebot persistent-template 1.0.0 - Type-safe, non-relational, multi-backend persistence. (MichaelSnoyman)
21:52:31 * hackagebot yesod 1.1.0 - Creation of type-safe, RESTful web applications. (MichaelSnoyman)
21:52:33 * hackagebot yesod-auth 1.1.0 - Authentication for Yesod. (MichaelSnoyman)
21:53:08 <JoeyA> Does that guy ever sleep?
21:53:25 <Cale> Who? Michael Snoyman?
21:53:26 <shachaf> It's 07:52 in .il
21:53:29 <JoeyA> Yup
21:53:47 <JoeyA> He probably didn't sleep tonight, then.
21:53:58 <JoeyA> Who gets up at 7 in the morning to release packages?
21:54:06 <Cale> hehe
21:54:17 <JoeyA> Whenever I release a package at 7, it's usually because I was working on it during the prior hours.
21:56:13 <zzing_> What class would specify operations like and, or, etc.  (logical operations on numbers)
21:57:26 <JoeyA> Data.Bits ?
21:57:35 * hackagebot yesod-core 1.1.0 - Creation of type-safe, RESTful web applications. (MichaelSnoyman)
21:57:37 * hackagebot yesod-default 1.1.0 - Default config and main functions for your yesod application (MichaelSnoyman)
21:57:39 * hackagebot yesod-form 1.1.0 - Form handling support for Yesod Web Framework (MichaelSnoyman)
21:57:41 * hackagebot yesod-json 1.1.0 - Generate content for Yesod using the aeson package. (MichaelSnoyman)
21:57:43 * hackagebot yesod-newsfeed 1.1.0 - Helper functions and data types for producing News feeds. (MichaelSnoyman)
22:02:45 * hackagebot yesod-persistent 1.1.0 - Some helpers for using Persistent from Yesod. (MichaelSnoyman)
22:02:47 * hackagebot yesod-routes 1.1.0 - Efficient routing for Yesod. (MichaelSnoyman)
22:02:49 * hackagebot yesod-sitemap 1.1.0 - Generate XML sitemaps. (MichaelSnoyman)
22:02:51 * hackagebot yesod-static 1.1.0 - Static file serving subsite for Yesod Web Framework. (MichaelSnoyman)
22:02:53 * hackagebot yesod-test 0.3.0 - integration testing for WAI/Yesod Applications (MichaelSnoyman)
22:22:20 * hackagebot osm-download 0.4 - Download Open Street Map tiles (ThomasDuBuisson)
22:27:20 * hackagebot yesod-platform 1.1.0 - Meta package for Yesod (MichaelSnoyman)
22:27:22 * hackagebot yackage 0.6.0 - Personal Hackage replacement for testing new packages. (MichaelSnoyman)
22:30:42 <Jafet> Is SICP still relevant to GHC 7 packaging?
22:32:20 * hackagebot tardis 0.2.0.0 - Bidirectional state monad transformer (DanBurton)
22:32:31 <Jafet> monochrom: is SICP up-to-date with GHC 7?
22:43:46 <JoeyA> Has anyone made a Makefile that forwards its arguments to Shake?
22:44:07 <JoeyA> Or perhaps a binary I can run that automatically compiles and runs a Shake script?
22:44:48 <JoeyA> I guess it's pretty easy to write one myself
22:46:50 <ryan_> @pl \x y -> y x
22:46:51 <lambdabot> flip id
22:48:35 <Nisstyre> @djinn t1 -> (t1 -> t) -> t
22:48:36 <lambdabot> f a b = b a
22:49:21 <ryan_> @pl \x y -> y x
22:49:22 <lambdabot> flip id
22:50:01 <Nisstyre> sup Starfire
22:50:03 <Nisstyre> er
22:50:05 <Nisstyre> startling
22:50:10 <startling> is there a standard module hierarchy for stuff for writing a file type? Or should I just use Data.Whatever?
22:50:14 <startling> Nisstyre: oh hai
22:50:24 <Jafet> @@ @pl @djinn a -> Not a -> Void
22:50:24 <lambdabot>  f = flip id
22:51:06 <Jafet> Data.Whatever sounds like the standard module hierarchy
22:51:28 <startling> Jafet, k, just wondering
22:51:32 <Nisstyre> @djinn a -> Not a -> Void
22:51:33 <lambdabot> f a b = b a
22:51:42 <Nisstyre> how does that work?
22:51:47 <startling> it seems like Data.Whatever is (should be) more for data structures than file formats, but whatever
22:51:56 <Nisstyre> how did djinn derive that function?
22:52:03 <ryan_> @unpl flip
22:52:03 <lambdabot> (\ a b c -> a c b)
22:52:15 <startling> Nisstyre: magic
22:53:05 <shachaf> Nisstyre: Are you asking how Djinn works in general?
22:53:11 <Nisstyre> shachaf: no
22:53:23 <Nisstyre> I get how it works in general, just not sure how that specific type leads to that function
22:53:40 <shachaf> type Not a = a -> Void
22:54:50 <Jafet> @djinn Void -> a
22:54:50 <lambdabot> f = void
22:55:11 <Jafet> Classical logic is fubar
22:55:32 <shachaf> What does classical logic have to do with it?
22:55:45 <shachaf> @djinn-add data Voider
22:55:50 <shachaf> @djinn Voider -> a
22:55:50 <lambdabot> f = void
22:56:09 <shachaf> Hah.
22:56:35 <Nisstyre> you can add new types to djinn?
22:56:44 <shachaf> Sure.
22:56:46 <Nisstyre> cool
22:56:55 <shachaf> @list djinn
22:56:56 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
22:57:06 <Nisstyre> @djinn-env
22:57:07 <lambdabot> data () = ()
22:57:07 <lambdabot> data Either a b = Left a | Right b
22:57:07 <lambdabot> data Maybe a = Nothing | Just a
22:57:07 <lambdabot> data Bool = False | True
22:57:07 <lambdabot> data Void
22:57:09 <lambdabot> type Not x = x -> Void
22:57:12 <Nisstyre> oh no
22:57:13 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
22:57:17 <lambdabot> class Eq a where (==) :: a -> a -> Bool
22:57:21 <lambdabot> data Voider
22:57:32 * Nisstyre wipes the sweat from his brow
22:58:31 <scry1> ok simple question
22:58:40 <scry1> i want to read an integer from the command line
22:58:45 <shachaf> @ty readLn
22:58:46 <lambdabot> forall a. (Read a) => IO a
22:59:09 <shachaf> (What's the question?)
22:59:21 <Nisstyre> scry1: is your question "How do I do that?" ?
22:59:22 <scry1> tried do  args <- getArgs
22:59:22 <scry1>     n <- read (args !! 1) :: Int
22:59:33 <scry1> ah yes, is this a faux pas?
22:59:41 <Nisstyre> no, not really
22:59:51 <Nisstyre> but why are you doing !! there?
23:00:19 <shachaf> !! is considered kind of not nice but it's not that bad.
23:00:22 <scry1> well, i thought, args is a [string]
23:00:35 <shachaf> You can always [blah, blah] <- getArgs
23:00:35 <Nisstyre> okay, so is that code not working?
23:00:44 <shachaf> Or args <- getArgs; case args of ... -> ...; ... -> ...
23:00:52 <shachaf> But you haven't asked your question yet.
23:00:55 <scry1> Couldn't match expected type `IO t0' with actual type `Int'
23:01:14 <scry1> ok, how do i extract the string array from the IO [string]
23:01:19 <shachaf> You should go hpaste.org and paste your full program and error message.
23:01:19 <scry1> or just the one string?
23:01:23 <scry1> ok
23:01:23 <Nisstyre> you have to return a type of IO t0 from the do statement
23:01:29 <shachaf> scry1: You don't extract anything from IO [String].
23:01:31 <shachaf> @quote /bin/ls
23:01:32 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
23:02:54 <beekur> 77777777777779rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\\\\\\\\\\\\\\\\\cccccccccccccccccccccccccccccccccccccct-
23:03:02 <Veinor> i agree.
23:05:17 <hpaste> scry pasted “p391” at http://hpaste.org/72719
23:07:00 <Veinor> scry1: you want read (args !! 3) :: IO Int
23:07:03 <scry1> it's from the latest euler problem, but i wouldnt worry about it giving much away
23:07:15 <scry1> ahh I see
23:07:20 <Veinor> er, args !! 1
23:07:22 * hackagebot JuicyPixels-repa 0.4 - Convenience functions to obtain array representations of images. (ThomasDuBuisson)
23:08:49 <scry1> no instance for Read (IO Int)
23:09:02 <Veinor> oh, right, read is that function.
23:09:02 <scry1> will that be trivial to instantiate?
23:09:23 <Veinor> you want let n = read (args !! 1)
23:10:06 <Nisstyre> then do a "print n"
23:10:13 <Nisstyre> or just "return n" will also work
23:10:22 <startling> I'm reading some docs that specify a C struct for stuff in this file format. what's the best way to emulate that in haskell and provide an easy way to serialize/deserialize it?
23:10:26 <Veinor> Nisstyre: why would you want that?
23:10:28 <Ralith> Nisstyre: not if he bound it with let.
23:10:37 <startling> I don't need to interface with actual C code, just want to write bytes
23:10:56 <Ralith> @hoogle Binary
23:10:57 <lambdabot> package binary
23:10:57 <lambdabot> package binary-bits
23:10:57 <lambdabot> package binary-communicator
23:11:03 <Nisstyre> Veinor: I'm assuming he wants to just print the number
23:11:09 <shachaf> A C struct doesn't specify memory layout. :-)
23:11:26 <scry1> no, im plugging it into something
23:11:31 <scry1> looks like it will work though
23:11:36 <Ralith> shachaf: but it's pretty clear what he wants :P
23:12:08 <startling> shachaf: yeah, I know. :/ unfortunately these docs make some assumptions I guess
23:13:07 <scry1> hmm, Prelude.(!!): index too large
23:13:27 <wagle> has to be an Int?
23:13:28 <scry1> oh wait
23:13:32 <Nisstyre> scry1: lists are 0 indexed with !!
23:13:38 <scry1> haha thanks
23:13:49 <scry1> i assumed that would be the program name
23:13:57 <scry1> yep looks good
23:13:59 <Nisstyre> scry1: just use head
23:14:03 <shachaf> :-(
23:14:13 <scry1> yeah i will, now
23:14:13 <wagle> @t head
23:14:14 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:14:15 <shachaf> Don't use head.
23:14:20 <Nisstyre> shachaf: why not?
23:14:22 <wagle> :t head
23:14:22 <shachaf> Use pattern matching.
23:14:23 <lambdabot> forall a. [a] -> a
23:14:30 <Nisstyre> yeah or a case expression
23:14:37 <shachaf> Pattern matching /= cas expression.
23:14:41 <Nisstyre> I know
23:14:52 <shachaf> (foo:_) <- getArgs or [blah,blam] <- getArgs is much better than head.
23:14:58 <wagle> head should be [a] -> Maybe a    8)
23:15:34 <scry1> oh, to avoid exceptions
23:16:36 <Veinor> @djinn (a -> b) -> (a, c) -> (b, c)
23:16:36 <lambdabot> f a (b, c) = (a b, c)
23:16:46 <Veinor> aw, djinn doesn't go for pointlessness
23:17:00 <Veinor> @djinn \(a, b) (c, d) -> (max a c, max b d)
23:17:01 <lambdabot> Cannot parse command
23:17:06 <Veinor> @pl \(a, b) (c, d) -> (max a c, max b d)
23:17:07 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. max) . flip . (((.) . (,)) .) . max)
23:17:12 <Jafet> @@ @pl @djinn (a -> b) -> (a, c) -> (b, c)
23:17:12 <lambdabot>  f = (`ap` snd) . (. fst) . ((,) .)
23:17:20 <Veinor> i thought there was an arrow for that
23:17:27 <Jafet> ie. first
23:17:47 <Veinor> @type max *** max
23:17:48 <lambdabot> forall b b'. (Ord b, Ord b') => (b, b') -> (b -> b, b' -> b')
23:17:57 <Veinor> what
23:18:07 <Veinor> @type (***)
23:18:08 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:18:38 <Veinor> oh, right
23:18:49 <Veinor> yeah i don't think there's any nice way to write this
23:20:55 <Emmycakes> Tangental not-at-all-haskell question; does anyone have an outline for the Alot monster? =\
23:22:34 <startling> Emmycakes, an outline?
23:22:41 <scry1> lol
23:22:50 <Emmycakes> yes, I need to fill it with something =\
23:22:52 <scry1> Alol
23:23:08 <Emmycakes> and I have no image editing software on this machine
23:24:51 <shachaf> Get some image editing software?
23:25:11 <Nisstyre> or you can even use editing software that runs in your web browser
23:26:00 <carter> Emmycakes: use diagrams & cairo? :)
23:26:08 <startling> Word32 is generally what i want to correspond to a C uint32, right?
23:27:22 * hackagebot lens 1.6 - Lenses, Folds and Traversals (EdwardKmett)
23:27:43 <AfC> I love how lens and lenses aren't the same package
23:29:01 <edwardk> i wanted the lenses name but the package was already there
23:30:19 <AfC> edwardk: incidentally, I loved your post on Stack Overflow about lenses. Only thing I've seen anywhere that made any sense.
23:30:27 <edwardk> thanks =)
23:30:35 <edwardk> i plan on writing up a nice article about these new ones
23:30:53 <AfC> edwardk: almost everything else (*especially* hackage docs) you see assumes that already know what lenses are for, how they're used, and why you'd want to use one over another.
23:31:06 <edwardk> *nods*
23:31:08 <AfC> Because, after all you can Just Figure It Out From The Types™, bah
23:31:25 <Jafet> But you can!
23:31:31 <edwardk> 'lens' is kind of bad about that admittedly. i at least try to put a bunch of examples in
23:31:42 <edwardk> and the doctests are keeping me honest about them ;)
23:32:06 <AfC> edwardk: [for comparison, I couldn't make hide nor tail of the mirrored-lenses blog post you made]
23:32:27 <edwardk> afc: yeah that wasn't targeted at the same audience, i admit
23:32:58 <shachaf> "lens" is the plural of "len", obviously.
23:33:00 <Nisstyre> I think the problem is that the majority of people think in terms of generalizing the specific, rather than specificating the general
23:33:03 <Masse^^> Not to mention that 'lens' is extremely difficult to google
23:33:07 <AfC> edwardk: right, so that being the documentation linked from lens package's contents page makes me want to ensure I live in a building with padded walls
23:33:08 <Masse^^> Especially in such a niche field
23:33:38 <carter> edwardk: examples in a library! shocking! :)
23:33:42 <edwardk> afc: its what i have to link to now. i hope to have the article up in a couple of days
23:33:46 <AfC> edwardk: anyway, only mentioning because you're the author of both
23:33:55 <edwardk> i appreciate the feedback
23:34:09 <carter> edwardk: btw. i got blas working again, and also maybe have the ball rolling on the hmatrix bit
23:34:10 <edwardk> the writeup i've been working on tries to proceed more like the stackoverflow article
23:34:56 <edwardk> in that i start from the definition of functor, foldable and traversable, and the idea of a function, and derive the types for setters, folds, traverals, and getters, and then show that a lens is just a traversal that is a valid getter.
23:35:19 <AfC> Personal perspective, I first ran into lenses in Snap[let?] land, mightybyte tried to explain it but a) I had no idea he was talking about properties, b) I had no idea what the template haskell was doing or why it would be necessary [been trying to avoid TH].
23:36:22 <edwardk> i also posted a video of my talk on lenses in scala. did you see that?
23:36:31 <AfC> Once I clued in that they were an ... alternate ... way to do getters and setters for a property (implicitly of a structure ^W record) [even though, um, you had to write the getter and setter functions first, er, huh?] ... then finding edwardk's s.o. post made a lot come together
23:36:51 <AfC> edwardk: yeah, got stuck at the Scala part.
23:36:56 <edwardk> fair nuff
23:37:32 <carter> this http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285 article?
23:37:34 <AfC> FP is hard enough; FP in a language I don't know the syntax of is over my head. I could learn, of course, but then I'd be programming in Scala :/
23:37:44 <AfC> carter: yes
23:37:47 <edwardk> i'll probably do another talk on them from the haskell perspective to motivate lens a bit better based on lens in a month or so
23:38:05 <AfC> carter: really nice write up
23:38:06 <Nisstyre> edwardk: how about a lens library for Racket?
23:38:12 <Nisstyre> :P
23:38:23 <Nisstyre> (Typed Racket)
23:38:27 <carter> Nisstyre: typed racket doesn't have the right sort of generics I think
23:38:33 <edwardk> Nisstyre: we'll see. i'll put it on my list of things to do when i get bored ;)
23:38:33 <Nisstyre> ah, that sucks
23:38:47 <Nisstyre> I would use it though if you did it
23:38:48 <AfC> Of course, now I know just enough to follow all the "this should fix record syntax" discussions, which just makes me mad that Ye Smart Haskellers didn't fix this already, like 15 years ago
23:39:08 <edwardk> its not an easy problem and not all of us like any of the fixes any more than the status quo
23:39:09 <Cale> AfC: I'd imagine that TH would just be used to automatically construct lenses for the fields of a datatype, though I suppose it's possible they're doing something more interesting than that.
23:39:24 <edwardk> cale: thats exactly what it does
23:40:51 <AfC> I guess I need to get over my aversion to Template Haskell.
23:41:09 <Cale> AfC: After all, it might be that the existing syntax is sufficient, and all we need is a new record *library*.
23:41:26 <edwardk> with lens you can use it to do a bit more (build isomorphisms, automagically prepend a lens from another class, etc) but thats about it
23:42:11 <Cale> (which is sort of what's been happening :)
23:42:18 <AfC> edwardk: feedback: what does "You can derive lenses automatically for many data types using makeLenses," mean?
23:42:42 <edwardk> data Pair a = Pair { _x, _y :: a }; makeLenses ''Pair
23:42:46 <edwardk> that will make two lenses, x, and y
23:43:04 <edwardk> x :: Simple Lens (Pair a) a; y :: Simple Lens (Pair a) a
23:43:44 <AfC> what's the empty string '' there?
23:43:44 <shachaf> edwardk: Speaking of which, the monad instance for Pair came up in here the other day.
23:43:46 <edwardk> y f (Pair a b) = Pair a <$> f b
23:43:53 <shachaf> Is it an inteersting in some way?
23:44:01 <EvilMachine> mm_freak_: hey, you sent me that video link about “weird machines”. now I wonder: how exactly are S-expressions a solution to avoid *both* length fields *and* escaping?
23:44:02 <edwardk> afc: those are two single quotes, its a bit of template haskell
23:44:12 <AfC> edwardk: oh.
23:44:12 <edwardk> shachaf: it takes the diagonal of a 2x2 matrix
23:44:14 <AfC> (gah, really?)
23:44:28 <EvilMachine> mm_freak_: because i don’t think that’s possible
23:44:34 <shachaf> join (Pair (Pair x _) (Pair _ y)) = Pair x y
23:44:43 <edwardk> its a nicer way to say (mkName "Pair") that doesn't require you to import Language.Haskell.TH
23:45:00 <EvilMachine> mm_freak_: but i don’t really knew s-expressions until now. ;)
23:45:13 <edwardk> that and it is an error if the thing in question is out of scope
23:45:42 <edwardk> finally it binds to names that are in scope at the binding site, not at the usage site
23:48:08 <edwardk> its handy
23:52:14 <shachaf> edwardk: But, I mean, is it useful for anything?
23:52:25 <edwardk> shachaf: ?
23:52:54 <edwardk> yes =)
23:53:09 <edwardk> there is code i can't write without it
23:53:36 <shachaf> Without Pair?
23:53:39 <edwardk> notably makeLenses when it wasn't using it required you to have Control.Lens imported, with it, it can now work regardless
23:53:42 <edwardk> oh
23:53:42 <edwardk> the monad
23:54:07 <edwardk> sure trace m = sum (join m)
23:55:12 <edwardk> shachaf: its also nice that it comes for free by representability
23:55:48 <edwardk> instance Representable Pair where rep f = Pair (f x) (f y); instance Monad Pair where return = pureRep; (>>=) = bindRep
23:57:51 <carter> question: does anyone know the startus of work on dph?
23:58:57 <scry1> is there a way to bind a default value for n here:
23:59:07 <scry1> main = do;    arg:_ <- getArgs;    let n = read arg :: Int
23:59:37 <scry1> only pattern matching?
23:59:47 <shachaf> "default" in case of what?
