00:00:47 <johnw> i read an article last night on the merits of favoring the applicative over monads
00:00:59 <johnw> i want to read more on that; anybody have good links?
00:01:32 <paolino> well a 10 Ä/month server should suffice for hackage, if galois is dediceted to other tasks and it's fine to have it down more often than hackage
00:01:54 <ivanm> johnw: I don't have any links off hand, but when parsing, if your parser has specialised Applicative instances and you use those instances more than the Monad ones, then it's possible to speed up your parsing; this is the idea (or at least part of it) behind edwardk's trifecta library
00:02:11 <ivanm> paolino: someone before said they were going to be discussing this at next week's haskell.org committee meeting
00:02:39 <paolino> ok, it was not a rant btw
00:03:19 <ivanm> who mentioned ranting?
00:03:25 <edwardk> paolino: this is something i'm hoping to address at the next committee meeting, the current state of affairs is just sad
00:03:27 <johnw> when hackage is up i'll read about trifecta :)
00:03:33 <startling> the hackage thing is pretty ridiculous
00:04:22 <edwardk> johnw: https://github.com/ekmett/trifecta gives you source code to skim, but its not for the faint of heart
00:04:42 <paolino> ivanm, it was just to be clear, as I have some expressing problems with people lately :-)
00:04:42 <lightquake> hackage being down is killing my ability to look at docs :(
00:05:02 <ivanm> paolino: heh, I quite often have expression problems ;-)
00:05:20 <johnw> man, using Parsec is like a dream come true
00:05:24 <ivanm> lightquake: you can always view the documentation of packages you've installed if you enabled documentation building...
00:05:41 <ivanm> johnw: I prefer polyparse over parsec btw because the API is much smaller :p
00:05:58 <johnw> is it also monadic?
00:05:59 <startling> oh whoops, guess I have problems if my directory-tree-reading follows "." and "..". :)
00:06:03 <ivanm> johnw: yup
00:06:31 <ivanm> johnw: the main difference is that in polyparse, you don't need to use the `try' combinator, as backtracking is the default
00:06:31 <Twisol> Speaking of parsers, are there any good tutorials for parsing network data?
00:07:34 <startling> Twisol: cereal and/or binary seem good for that
00:07:38 <lightquake> ivanm: haskell platform didn't appear to enable them :( i've only got the htmlified source for GLUT
00:07:46 <startling> Twisol: binary if you want lazy bytestrings, cereal if you're okay with strict
00:07:48 <sheldonh> can i disable a type from Prelude? i want Left and Right for myself
00:07:57 <ivanm> lightquake: oh, the packages that came with the platform?
00:08:02 <ivanm> sheldonh: you can, but you shouldn't
00:08:07 <Twisol> startling: that's probably a good follow-up question.. How do I decide between lazy and strict bytestrings?
00:08:10 <lightquake> yeah
00:08:11 <ivanm> import Prelude hiding (Either(..))
00:08:11 <sheldonh> ivanm: oh, okay. i won't then :)
00:08:24 <lightquake> oh wait, weird, it's showing up for other packages
00:08:29 <ivanm> Twisol: will your entire data fit into RAM comfortably?
00:08:33 <sheldonh> ivanm: so common practice is to just choose non-conflicting names, yes?
00:08:34 <startling> Twisol: dunno. cereal is much nicer, though, so I'd go with strict. :)
00:08:39 <lightquake> just not GLUT :(
00:08:50 <ivanm> lightquake: stuff you built yourself with cabal-install will have documentation if you enabled it in ~/.cabal/config
00:08:57 <ivanm> sheldonh: yup
00:08:58 <lightquake> right
00:09:00 <Twisol> ivanm: I expect to be handling an event protocol, not a document protocol, so I guess that's "yes".
00:09:08 <lightquake> but GLUT came with the haskell platform and doesn't have docs for whatever reason
00:09:10 <startling> Twisol: I think strict bytestrings are okay if you're not worried about your data eating up all your memory
00:09:22 <ivanm> sheldonh: it avoids confusion when other people read your code :)
00:09:27 <startling> oh, ivanm already covered that
00:09:39 <ivanm> startling: well, I didn't make it explicit; you beat me to that :)
00:09:48 <sheldonh> ivanm: i take it prelude doesn't grow very fast, then :)
00:09:52 <Twisol> startling: I'll look into cereal then. I guess hackage is down though :(
00:10:16 <ivanm> sheldonh: nope
00:10:46 <ivanm> sheldonh: changing the Prelude would require changing the Haskell standard IIUC
00:11:03 <ivanm> changing other main-line packages requires approval via the haskell libraries mailing list
00:11:16 <ivanm> changing other packages is up to the maintainer to do as they see fit ;)
00:11:49 <sheldonh> ivanm: redux: "this ain't ruby, sonny boy" :)
00:12:02 <ivanm> hmmm?
00:12:13 <startling> Twisol: yeah. :(
00:12:33 <sheldonh> ivanm: i'm used to another environment in which things change quite a bit faster than i like :)
00:12:47 <ivanm> ahhhhh
00:13:02 <ivanm> sheldonh: our arguments tend to be how strict we should make version dependencies :p
00:13:23 <Twisol> Does anyone here code in Haskell exclusively?
00:13:33 <ivanm> some people prefer being strict wrt upper bounds, other people prefer not to
00:13:42 <sheldonh> Twisol: jesus, that would take some stamina!
00:13:49 <Twisol> That's why I'm asking! :D
00:14:20 <paolino> Twisol, I count 0 , as I'm a farmer but yes
00:14:27 <sheldonh> Twisol: this is the first time i've needed very frequent breaks while learning a language
00:14:45 <ivanm> Twisol: if you discount the occassional bash script, then yup
00:14:45 <Twisol> paolino: Nice. :)
00:15:03 <lightquake> oh, awesome
00:15:17 <lightquake> apparently GLUT in ghci works on os x if you just do -fno-ghci-sandbox
00:15:29 <ivanm> though I might need to do something in C soon; my supervisor doesn't trust anything except C for speed :s
00:15:30 <Twisol> sheldonh: have to agree there, I still <3 Ruby and JS
00:15:57 <startling> Twisol: I haven't written any non-haskell code for some time
00:16:06 <startling> oh, wait, I was dicking around in C yesterday
00:16:37 <sheldonh> Twisol: ugh. i'm pretty over OO, which is why i'm trying to get into this. have you seen Rich Hickey's "The Value of Values"? :)
00:16:49 <Twisol> sheldonh: No, I don't think I have
00:16:55 <startling> I have tons of trouble going back to OO, too
00:16:57 <startling> it's so messy
00:17:51 <Twisol> once you've seen Haskell's type system, everything else looks bad
00:17:52 <sheldonh> Twisol: it's mind-blowing. well, it blew my mind. twice. it's kind of an empirical affirmation of your intuitive dread that all your OO programs will eventually devolve into a pile of shit
00:18:05 <startling> sheldonh: heh
00:19:12 <sheldonh> Twisol: if you're into visciuos cocktails of despair and hope, i heartily recommend making an hour of it: http://www.infoq.com/presentations/Value-Values
00:19:33 <Twisol> sheldonh: I'm on it. :)
00:19:35 <Twisol> Thanks!
00:19:56 <sheldonh> Twisol: you shouldn't be thanking me, but i'll take it :)
00:19:59 <Twisol> ('cept I found a post on cereal, so that's first in the queue)
00:20:05 <sheldonh> LOL
00:20:22 <Twisol> The Haskell library cereal, not the cereal that goes with milk. :(
00:20:38 <ivanm> @wn cereal
00:20:39 <lambdabot> *** "cereal" wn "WordNet (r) 3.0 (2006)"
00:20:39 <lambdabot> cereal
00:20:39 <lambdabot>     adj 1: made of grain or relating to grain or the plants that
00:20:39 <lambdabot>            produce it; "a cereal beverage"; "cereal grasses"
00:20:39 <lambdabot>     n 1: grass whose starchy grains are used as food: wheat; rice;
00:20:41 <lambdabot> [5 @more lines]
00:20:48 <johnw> if I have IO (Maybe a), can I turn it into Maybe (IO a)?
00:20:48 <ivanm> ;)
00:20:56 <sheldonh> oh wow, hackage still down?
00:21:23 <ivanm> @hoogle (Monad m1, Monad m2) => m1 (m2 a) -> m2 (m1 a)
00:21:23 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
00:21:23 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
00:21:24 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
00:21:37 <johnw> cool
00:21:39 <shachaf> johnw: No.
00:21:41 <startling> johnw: nope
00:21:45 <startling> well, not in general
00:21:52 <johnw> isn't that what sequence is doing?
00:21:57 <shachaf> No.
00:21:58 <ivanm> oh, right
00:22:06 <paolino> IO is not Traversable lately
00:22:09 <johnw> > sequence [Just 10]
00:22:10 <lambdabot>   Just [10]
00:22:15 <ivanm> johnw: sequence would do the other way round
00:22:20 <ivanm> it wouldn't do the IO
00:22:23 <shachaf> johnw: [Maybe a] /= IO (Maybe a)
00:22:30 <johnw> i actually need this for Parsec.Parser
00:22:32 <shachaf> johnw: Think about it and you'll see why it doesn't make sense. :-)
00:22:36 <johnw> so maybe it would work
00:22:51 <ivanm> the only way to go from IO a to anything else is to use unsafe functions
00:23:03 <shachaf> ivanm: ...Or to, you know, do the IO.
00:23:10 <shachaf> Don't tell people to use unsafe functions. :-(
00:23:17 <shachaf> johnw: "whether the value is a Just or a Nothing" is information that you need to execute the IO action to find out.
00:23:22 <ivanm> shachaf: I wasn't recommending it!
00:23:47 <ivanm> shachaf: I meant that there's no way to magically get rid of or replace an outer IO monad like that
00:23:50 <shachaf> You *can* turn IO (Maybe a) to Maybe (IO a)
00:23:59 <shachaf> But it's a very boring function: foo _ = Nothing
00:24:03 <startling> heh
00:24:05 <shachaf> There's nothing else you can do.
00:24:06 <ivanm> heh
00:24:14 <startling> johnw: use do notation
00:24:24 <paolino> :t return . fmap fromJust
00:24:25 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f) => f (Maybe a) -> m (f a)
00:24:36 <shachaf> paolino: :-(
00:24:39 <johnw> shachaf: that makes complete sense
00:25:24 <Twisol> paolino: keep that partial function away from me! :(
00:26:57 <sheldonh> can i just say, exercise 10 in chapter 3 of real world haskell (determine left or right turn made by 3 2D points)... bastard!!!
00:27:18 <Twisol> :D
00:27:29 <startling> sheldonh: nope
00:27:31 <bartavelle> I am using a simple channel pattern to distribute work (see the second listing at http://hpaste.org/73711)
00:27:42 <Twisol> sheldonh: Isn't that just comparing the direction of two vectors?
00:27:47 <bartavelle> however, using -threaded for compilation and -N8 at runtime results in 88% idle
00:28:13 <bartavelle> my actual program is more complex, but I made sure everything that was passed to "purecomputation" was strictly computed
00:28:25 <sheldonh> Twisol: that's one way :)
00:28:28 <bartavelle> where can I find what is stalling everything ?
00:28:41 <startling> hmmm, would be super cool if we could have files and directories encoded in the type system
00:29:06 <paolino> file types ?
00:29:22 <paolino> permissions and such
00:29:33 <c_wraith> bartavelle: the problem is that your main thread is doing all the work
00:29:48 <bartavelle> c_wraith, what's the point of forkIO then .
00:29:49 <bartavelle> ?
00:29:50 <c_wraith> bartavelle: because the evaluation of the pure computation isn't happening until the print
00:29:55 <bartavelle> ahhhhh
00:29:58 <bartavelle> obviously
00:30:00 <bartavelle> thank you !
00:30:29 <c_wraith> bartavelle: it's a common pitfall with chan
00:30:40 <bartavelle> yeah I should have realized :/
00:31:08 <bartavelle> what's the syntactic nicest way to force evaluation ? Doesn't seem like I can (\!x -> purecomputation x)
00:31:48 <ivanm> seq
00:31:50 <paolino> deepseq ?
00:32:00 <ivanm> or deepseq as paolino says
00:32:07 <ivanm> depends on the type whether you need deepseq or not
00:32:31 <shachaf> deepseq is often not what you want.
00:32:55 <ivanm> there's also evaluate
00:32:57 <paolino> iirc it boils down to rnf
00:33:04 <ivanm> yup
00:33:14 <paolino> shachaf, can you elaborate more please ?
00:33:18 <ivanm> aka "let's evaluate it completely"
00:33:33 <ivanm> paolino: it can get expensive to do lots of deepseqs for starters
00:34:17 <NullSoldier> So... the haskell platform download isn't really available.
00:34:22 <NullSoldier> The page it's on seems to be not responding
00:34:34 <NullSoldier> Not sure if anyone could provide a recent working mirror
00:34:40 <ivanm> NullSoldier: hackage is down atm
00:34:43 <bartavelle> c_wraith, works like a charm now, thanks
00:43:40 <ivanm> Adding a new instance requires me to make a major version bump, doesn't it :s
00:44:22 <c_wraith> yep
00:44:35 <ivanm> *sigh*
00:44:54 <ivanm> so a major version bump just for adding a single instance that's probably never bothered anyone before...
00:46:34 <Cale> ivanm: "requires"?
00:46:41 <ivanm> according to the PVP
00:47:43 <Cale> Any attempt to globally standardise version numbers seems kinda silly to me
00:48:05 <ivanm> why? it helps you tell API breakages
00:48:12 <paolino> ivanm, if I don't use deepseq and I need to go deeper than seq, the idea is to deconstruct the value e bit and apply seq to pieces ?
00:48:14 <ksf> primitive type-level lists would be cool.
00:48:18 <ivanm> otherwise you'd have to check your code every single time a new version came out
00:48:23 <ksf> or, you know just *closed* type functions.
00:48:28 <ivanm> paolino: something like that
00:50:14 <paolino> ivanm, this means I have access to the constructors, and I know the structure of the values, isn't it what RNF instance is for ?
00:50:39 <ivanm> paolino: with deepseq, you recursively seq every little part of your data structure
00:50:53 <ivanm> with seq, you just evaluate it to WHNF (i.e. "what is the constructor")
00:51:18 <paolino> it depends on the RNF instance how much it goes down
00:51:31 <ivanm> there are in-betweens: for example, you can seq the length of a list: that will then make it spine-strict ("I know all the values") but not what the values are
00:51:49 <ivanm> paolino: ummmm.... the definition of rnf in the NFData instance _should_ fully evaluate it
00:53:00 <paolino> I see
00:56:09 <paolino> ivanm, what is a NFData instance for a structure containing an infinite list ?
00:56:25 <ivanm> paolino: one that never ends ;-)
00:56:26 <johnw> the getInput/setInput worked like a charm, btw
00:56:31 <johnw> the parser works!
00:56:54 <johnw> (I'm porting my C++ subconvert utility to Haskell)
00:57:25 <paolino> ivanm, I'd consider it a bug if a library exports that
00:57:35 <ivanm> why?
00:58:28 <paolino> how should I use the rnf mwthod of it ?
00:58:42 <ivanm> if you _know_ it's infinite, don't use rnf
00:58:42 <paolino> *method
01:00:04 <paolino> you export a function which break my code however I use it and just tell me not to use it in the docs?
01:02:12 <ivanm> shachaf _did_ say that deepseq is often not what you want
01:02:46 <paolino> I think I'm having problems with this story of deepseq/rnf/NFData
01:04:11 <paolino> because it can match an infinite evaluation ?
01:04:33 <ivanm> paolino: you use rnf/deepseq when you want to fully evaluate the value
01:04:39 <ivanm> if you don't want to fully evaluate it, don't use it
01:04:44 <ivanm> if you're relying on laziness, don't use it
01:05:36 <ivanm> what's so hard to understand?
01:06:59 <johnw> something I don't get about ($)
01:07:01 <johnw> > (,) a b
01:07:02 <lambdabot>   (a,b)
01:07:04 <johnw> > (,) $ a b
01:07:05 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> a'
01:07:05 <lambdabot>         against infe...
01:07:09 <johnw> why does the second fail?
01:07:11 <johnw> oh
01:07:14 <johnw> > (,) $ a $ b
01:07:15 <lambdabot>   Couldn't match expected type `a -> b'
01:07:15 <lambdabot>         against inferred type `Simple...
01:07:17 <johnw> why does *that* fail
01:07:17 <ivanm> because it's the wrong type?
01:07:22 <ivanm> > (,) a $ b
01:07:23 <lambdabot>   (a,b)
01:07:26 <ivanm> ^^
01:07:27 <johnw> ahh
01:07:32 <johnw> thank you
01:07:32 <shachaf> johnw: (,) $ a $ b === (,) $ (a $ b)
01:07:36 <shachaf> it's because $ is weird.
01:07:42 <johnw> right associativity gets me again
01:08:01 <shachaf> Cale would sympathise.
01:08:34 <johnw> I have this function in my code: getField f name = fromJust . maybe f name
01:08:40 <johnw> if I drop name from both side, it fails to type check
01:08:46 <johnw> why would that be?
01:08:53 <shachaf> Don't use fromJust. :-(
01:09:12 <shachaf> It's because fromJust . maybe f name === (.) (fromJust) (maybe f name)
01:09:17 <johnw> hmm.. @pl says: getField = ((fromJust .) .) . maybe
01:09:29 <c_wraith> fromJust *and* maybe?  how bizarre
01:09:43 <johnw> my function is named maybe, bad naming I know
01:09:46 <c_wraith> oh.
01:09:49 <shachaf> Don't name your function maybe.
01:09:54 <c_wraith> you know there's already a function with that name
01:09:58 <shachaf> maybe is an existing function which is much more useful than fromJust.
01:10:01 <johnw> ok, renaming
01:10:16 <johnw> ah, very nice
01:10:26 <shachaf> But also don't use fromJust. :-(
01:10:33 <johnw> yeah, yeah
01:10:44 <c_wraith> maybe and fromMaybe are handy
01:10:45 <johnw> i'm an evil little non-functional programmer
01:10:47 <shachaf> No, seriously. Better to say "let Just x = ... in x" than "fromJust ..."
01:10:50 <johnw> switching to maybe
01:11:07 <shachaf> Your "maybe" function should probably be called "getField". :-)
01:11:10 <yitz> oh noes looks like hackage just went down
01:11:15 <shachaf> "just"?
01:11:24 <yitz> well it worked for me earlier
01:11:26 <paolino> fromJust!
01:11:27 <shachaf> yitz: 18:05 <mauke> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
01:11:39 <yitz> ok thanks shachaf !
01:11:42 <shachaf> It's been down for quite a while already. Maybe it came back up for a little bit?
01:11:47 <yitz> could be
01:12:20 <yitz> people are working on the hackage2 migration, although that wasn't supposed to affect the current hackage server until a few weeks from now
01:12:23 <ivanm> @where+ hackage-mirror  remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
01:12:23 <lambdabot> I will remember.
01:12:42 <yitz> good idea ivanm
01:12:51 <paolino> ivanm, nevermind, thanks for remembering me the story of rnf and firends
01:12:53 <ivanm> I do have them sometimes ;)
01:13:45 <johnw> maybe "" id == fromMaybe ""
01:15:05 <arcatan> fromJust vs. unJust
01:15:21 <yitz> ivanm: we notice your good ideas often when you are active on #haskell. we don't notice them as much when you're not. ;)
01:15:22 <johnw> soon there will be a vindicate, just for shachaf
01:15:31 <ivanm> yitz: touche!
01:16:58 <ivanm> I was just about to upload a package... then remembered that hackage is down :s
01:17:21 <shachaf> Just upload to the mirror!
01:17:30 <ivanm> shachaf: will that then get synced to the real hackage?
01:17:40 <shachaf> No.
01:17:42 <ivanm> does luite even support directly uploading to the mirror?
01:17:48 <shachaf> I doubt it.
01:18:10 <ivanm> so your suggestion helps me _how_ precisely? :p
01:18:10 <shachaf> I can run an upload-only mirror if you like, just to calm the withdrawal symptoms down.
01:18:18 <ivanm> heh, I'm not that desperate!
01:18:38 <donri> ivanm: hey are you miljenovic?
01:18:47 <ivanm> Ivan Miljenovic, yes
01:19:01 <donri> ah cool, i'm dag
01:19:20 <ivanm> ahhhh
01:19:54 <ivanm> coincidentally, I just realised that your patch for the Show instance could have been done just by fixing the showsPrec definition...
01:20:02 <ivanm> (I think)
01:20:12 <donri> quite possible :)
01:21:01 <donri> i pushed more patches to http://www.darcsden.com/dag/wl-pprint-text/changes btw
01:22:04 <yitz> showsPrec can be annoying at times
01:22:16 <johnw> if I have data Foo = Bar | Baz, do I need to explicitly export all three names in my module declaration?
01:22:31 <donri> johnw: you can export "Foo(..)"
01:22:33 <yitz> johnw: no, unless you have an export list.
01:22:47 <johnw> so just Foo will do, or do I need Foo(..)?
01:23:02 <donri> just Foo will export only the type
01:23:07 * yitz guesses that donri's answer is more to the point
01:23:12 <ivanm> donri: heh, the documentation is all copy-pasted, so don't blame me for grammatical errors :p
01:23:21 <donri> ivanm: not blaming, just fixing :)
01:23:42 <ivanm> not sure I get the s/layed/laid/ patch
01:23:56 <ivanm> oh, right
01:23:57 <donri> ivanm: it's a "darcs replace" patch type
01:24:03 <ivanm> never seen that before
01:24:25 <ivanm> I wouldn't call layed "archaic"
01:24:30 <ivanm> I think I still see it used at times
01:24:44 * ivanm makes a wild guess that it's a British vs USA English difference
01:24:45 <donri> yea not sure, wiktionary called it archaic
01:24:50 <donri> i thought it was a typo :)
01:25:17 <donri> i thought i'd just make the patch and let you decide/cherry-pick
01:25:29 <ivanm> *nod*
01:27:02 <ivanm> looks like you're correct; can't find a single reference to "layed" being a correct term
01:28:39 <ivanm> donri: do you have a usage case for exporting displayB, or is it just a matter of "might as well" ?
01:29:10 <paolino>  
01:29:58 <donri> ivanm: the use case was from discussion on reddit that later turned out to not be needing pprinting... but could still be useful, e.g. i think wai lets you use a builder for the request body to concat the whole response in one go?
01:30:14 <ivanm> well, just the text builder then
01:30:17 <ivanm> that's all I'm using
01:30:30 <ivanm> unless people explicitly want to construct SimpleDocs themselves
01:31:30 <donri> what do you mean?
01:32:00 <ivanm> well, displayB converts SimpleDoc to a Builder
01:32:21 <donri> yea, but you get the simpledoc by using the render functions yea?
01:32:59 <ivanm> sure, but is it likely that someone is going to want to construct a Builder from their pretty-printed document
01:33:05 <ivanm> wait, when I put it like that... :p
01:33:31 <donri> basically exporting displayB allows you to do the same thing as "fromText . displayT" but with less syscalls for concatenation... IIUC
01:34:08 <donri> if you're using wl-pprint-text together with other text builders, for something
01:34:22 <ivanm> OK, I'll buy that
01:35:36 <ivanm> not sure about the line behaviour patch; will need to think about it
01:35:57 <ivanm> then again, a lot of this library was just copy + paste + edit to use Text + fix weird alignment issues I found by copying code from pretty :p
01:36:18 <donri> the one for renderOneLine is needed to not break some code printed by the pprinter
01:36:34 <ivanm> which pprinter?
01:38:30 <donri> for example I'm printing CSS with it and have like, the effect of, align ("5px" </> "solid" </> "black")
01:38:39 <donri> with renderOneLine it becomes "5pxsolidblack"
01:40:08 <ivanm> OK, I'll apply that.
01:40:24 <ivanm> can you create another patch describing that behaviour to the documentation of line?
01:40:32 <donri> sure
01:40:51 <LordBrain> Is hackage.haskell.org mirrored anywhere?
01:40:56 <sheldonh> oooo, infix notation. nyomnyomnyom
01:40:59 <donri> also i probably worded that patch name wrong, don't i mean softline?
01:41:04 <ivanm> I was about to ask you to fix the @space@ -> 'space' patch so that it remains monospaced, but remembered that links don't look monospaced in haddock :/
01:41:09 <ivanm> @where hackage-mirror
01:41:09 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
01:41:12 <ivanm> LordBrain: ^^
01:41:15 <LordBrain> ty
01:41:17 <ivanm> add that to your ~/.cabal/config file
01:41:47 <donri> ivanm: hm 'foo' links are monospaced for me
01:41:59 <ivanm> donri: I think the behaviour you added works for line in general as well
01:42:04 <ivanm> want to test that first?
01:42:26 <ivanm> in that case, can you re-do that patch (or make another one) to add the @'s back in?
01:42:54 <donri> ivanm: i mean that it's already monospaced just by being 'space'
01:43:04 <ivanm> oh?
01:43:06 <ivanm> hmmm
01:43:13 <ivanm> OK, might be my fonts or osmething
01:43:14 <ivanm> *shrug*
01:44:11 <donri> ivanm: also this is consistent with the docs for the other similar combinators; I kept the use of @@ for example documents and just used '' for the references to other combinators
01:44:40 <ivanm> OK
01:44:48 <ivanm> I'm trying to understand your spacebreak combinator
01:45:05 <ivanm> Doc doesn't have a Spaces constructor...
01:45:15 <LordBrain> is there a hackage mirror that has the docs?
01:45:16 <donri> oh right softline is just group line... yea
01:45:41 <donri> ivanm: i added it in "Smarter treatment of filler spaces"
01:45:49 <ivanm> oh, missed that patch
01:45:51 <donri> ivanm: this allows me to render my CSS fully minified
01:46:11 <donri> by semantically separating necessary spaces from prettifying whitespace
01:47:20 <ivanm> so you only use it for spacebreak?
01:47:27 <ivanm> LordBrain: no :(
01:47:36 <ivanm> oh, right, spaced uses it
01:48:13 <donri> ivanm: no, the patch introducing Spaces use it to make renderCompact (and renderOneLine) consistently not render any indentation/filler whitespace
01:48:18 <johnw> is there a mode that makes Parsec very verbose about what it's doing and trying?
01:48:19 <donri> yea
01:48:52 <ivanm> donri: I meant that I didn't see any combinators using it because I missed you changing the definition of spaced
01:49:41 <ivanm> OK, I've applied them all
01:49:44 <donri> cool!
01:49:51 <sheldonh> the gap in my education is killing me here. i need to study maths :(
01:50:35 <ivanm> donri: though you mucked up the indentation of the -> in renderCompact, *tsk, tsk* :p
01:50:53 <donri> oh?
01:51:04 <Yrogirg> What are the generaliztions of flip :: (a -> b -> c) -> (b -> a -> c) for higher number of arguments?
01:51:11 <ivanm> donri: there's an extra space in there!
01:51:15 <donri> ah!
01:51:34 <donri> ivanm: probably i just copied it from renderOneLine :P
01:51:51 <donri> want me to fix, or did you already?
01:51:56 <ivanm> I did already
01:52:11 <ivanm> can you just check the behaviour of line for renderOneLine and document accordingly please?
01:52:23 <ivanm> and lemme know when you've made enough patches and I can release :p
01:53:41 <donri> sure!
01:54:26 <ivanm> one thing that I do miss from git in darcs: the ability to name and remember external repos
01:54:28 <sheldonh> is there something like :type in ghci, that shows all the signatures of a function?
01:54:36 <ivanm> sheldonh: "all" ?
01:54:52 <ivanm> how can a function have more than one signature?
01:54:57 <sheldonh> sorry
01:54:58 <edwardk> @tell roconnor i was able to switch over to the new Bazaar. its much faster than the old one now
01:54:58 <lambdabot> Consider it noted.
01:54:59 <sheldonh> patterns
01:55:01 <ivanm> (barring printf-style hackiness)
01:55:15 <donri> ivanm: you can use bash completions for URLs in push/pull
01:55:18 <ivanm> sheldonh: can you give an example?
01:55:49 <ivanm> :o never noticed that before!
01:55:57 <sheldonh> ivanm: um... like if i have 2 equations for a function, based on two patterns. so f (x:y:z:xs) = ... and then f [] = ...
01:56:06 <donri> :)
01:56:14 <ivanm> but starting by doing "darcs pull http://<tab>" then gives me my root file system :(
01:56:33 <donri> ivanm: darcs pull h<tab>?
01:56:34 <yitz> ivanm: other than _darcs/prefs/repos?
01:56:57 <ivanm> sheldonh: ... so you want ghci to give you the source?
01:57:01 <ivanm> or missing patterns?
01:57:10 <donri> ivanm: http://www.darcsden.com/dag/wl-pprint-text/patch/20120826085554-6eb02 good enough?
01:57:14 <ivanm> donri: yes, but as soon as I type http I lose completions
01:57:19 <sheldonh> ivanm: yes. i guess i wanted ghci to give me the source *blush*
01:57:47 <ivanm> yitz: sure, but I then have to copy those values out rather than being able to attach a name to them
01:57:50 <donri> ivanm: for me if i type http:// i get no completions at all
01:57:56 <ivanm> sheldonh: no need to blush ;)
01:58:04 <ivanm> sheldonh: but no, ghci can't give you the source
01:58:17 <sheldonh> ivanm: i'm sure i can find it if i look really hard ;)
01:58:29 <ivanm> donri: oh, and export displayB from Monadic please
01:58:34 <yitz> ivanm: is what you want a bash-completion plugin that takes darcs repos from prefs/repos? that would be pretty easy (if it doesn't already exist)
01:58:49 <donri> ivanm: already did!
01:59:49 <ivanm> yitz: well, donri pointed out that it already does that, but a name -> url mapping would be more convenient IMO
02:00:01 <ivanm> donri: huh, I thought the patch missed it
02:00:47 <ivanm> donri: fixity of <++> in Monadic is missing though!
02:00:55 <donri> ivanm: ahh
02:01:37 <ivanm> I didn't realise you could have that kind of documentation in export lists though
02:02:02 <adimit> Is something up with hackage? I can't seem to download some packages via cabal-install.
02:02:04 <donri> http://www.darcsden.com/dag/wl-pprint-text/patch/20120826090123-6eb02
02:02:23 <ivanm> @where hackage-mirror
02:02:23 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
02:02:31 <ivanm> adimit: ^^ add that to your ~/.cabal/config
02:02:35 <ivanm> hackage is currently down
02:02:40 <adimit> ivanm: thank you very much!
02:02:54 <ivanm> np
02:03:30 <sheldonh> ivanm: aha! i've figured out what my question really is. can ghci tell me whether a function is safe/unsafe?
02:03:39 <ivanm> sheldonh: define safe/unsafe
02:03:46 <sheldonh> ivanm: total/partial
02:03:53 <ivanm> if you mean "is it missing any patterns", then ":set -Wall" can do that for you
02:03:58 <ivanm> along with other warnings
02:04:11 <ivanm> (there's a flag you can use just for missing patterns, but I don't recall what it is)
02:04:16 <shachaf> sheldonh: No.
02:04:22 <ivanm> donri: yup
02:04:30 <shachaf> sheldonh: No program can tell you whether your function is total. :-(
02:05:00 <sheldonh> owch. and i see it's typically not documented either
02:05:28 <sheldonh> it's a pity, i was hoping to preempt "Calling a partial function with an input that it can't handle is probably the single biggest source of straightforward, avoidable bugs in Haskell programs."
02:05:33 <ivanm> donri: I think the auto-completion doesn't work for me because I have "http://code.haskell.org" called just "haskell" in my ssh config, so one of the repos listed there is haskell:....
02:05:53 <ivanm> sheldonh: well, I told you how you can do that!
02:06:00 <donri> aha
02:06:04 <ivanm> but you can't guarantee _safety_ in general
02:06:10 <ivanm> infinite loops, etc.
02:06:23 <donri> ivanm: what about "ht<tab>"?
02:06:42 <sheldonh> ivanm: let me see if the warnings give me what i'm looking for. thanks
02:06:59 <ivanm> it completes it to http:// but then I can't select the next one
02:07:07 <donri> ah, heh
02:07:24 <ivanm> and doing it within quotes doesn't work either :/
02:07:58 <donri> ivanm: echo "set show-all-if-ambiguous on" >>~/.inputrc ?
02:08:35 <sheldonh> ivanm: this one? -fwarn-incomplete-patterns
02:08:54 <ivanm> no difference
02:08:58 <ivanm> sheldonh: yup, that'd be it
02:09:06 <ivanm> but you might as well use -Wall to get all the warnings
02:09:16 <ivanm> you can also add ":set -Wall" to ~/.ghci to enable it globally
02:09:24 <donri> oh yea that wouldn't help
02:09:50 <donri> sounds like darcs completions are buggy then
02:10:02 <sheldonh> ivanm: okay. it looks like this only helps with the code i write. i was hoping for some way to predict, for example, that head [] explodes
02:10:09 <ivanm> sheldonh: ahhh, no
02:10:26 <ivanm> I think the safe package on hackage can do something about that
02:10:52 * sheldonh eagerly awaits the return of hackage :)
02:10:53 <donri> or the aptly named listToMaybe
02:11:50 <ivanm> yeah, listToMaybe is great
02:11:57 <ivanm> as is maybeToList
02:12:57 <loreints> what does it mean when I do "runhaskell" and it just hangs until I C-c?
02:13:16 <sheldonh> loreints: everything's fine :)
02:13:29 <donri> loreints: probably that it reads a program on stdin until ^D
02:13:49 <loreints> I'm not touching stdin though...
02:13:57 <donri> exactly, so it waits.
02:14:02 <ivanm> loreints: runhaskell is provided with a script that it runs
02:14:05 <sheldonh> loreints: no, i think it wants its input program from stdin
02:14:06 <ivanm> it's not meant to be interactive
02:14:26 <donri> $ echo 'main = print "ohai"' | runhaskell
02:14:27 <loreints> sorry, I mean I'm running "runhaskell foo.hs"
02:14:33 <loreints> and it hangs
02:14:46 <sheldonh> loreints: try runhaskell < foo.hs
02:14:52 <donri> loreints: and it doesn't if you compile it with ghc and run the executable?
02:14:57 <loreints> same
02:15:59 <ivanm> loreints: what's foo.hs ?
02:16:05 <ivanm> maybe there's a loop or something there?
02:16:06 <loreints> when I compile and run it I get: Stack space overflow: current size 8388608 bytes.
02:16:06 <loreints>  
02:16:14 <sheldonh> loreints: infinite recursion
02:16:17 <ivanm> loreints: then that suggests there's something buggy with your code :)
02:16:18 <loreints> sorry, here is the code: http://hpaste.org/73715
02:17:11 <loreints> I think line 11 is causing it via the show method somehow, because that's the only recent change.
02:17:13 <sheldonh> i wonder whether you can get a function trace out of it
02:17:53 <donri> compile with -prof -fprof-all -rtsopts and run with +RTS -xc
02:18:12 <ivanm> donri: you need the -f now?
02:18:21 <donri> @where+ stacktrace compile with -prof -fprof-all -rtsopts and run with +RTS -xc
02:18:22 <lambdabot> Done.
02:18:28 <donri> ivanm: -fprof-all is the new -auto-all
02:18:32 <ivanm> oh?
02:18:34 <ivanm> how does it differ?
02:18:38 <donri> same thing :)
02:18:39 <ivanm> and which version of ghc introduced it?
02:18:43 <donri> 7.4.1
02:18:44 <ivanm> what about -caf-all ?
02:18:54 <ivanm> so... why the name change?
02:18:57 <donri> -fprof-auto-caf or something like that
02:19:08 <donri> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-compiler-options.html
02:19:15 <loreints> my current error via that method: <Main.peekByte,Main.runParse,Main.parseState,Main.main><Main.peekByte,Main.runParse,Main.parseState,Main.main>Stack space overflow: current size 8388608 bytes.
02:19:20 <donri> -fprof-cafs
02:19:23 <loreints> I guess that's a view of the stack?
02:19:37 <donri> ivanm: it just says "-fprof-auto was known as -auto-all prior to GHC 7.4.1."
02:19:48 <FatPhil> Total beginner's question: I've got a list [v1,...,vn] of vertices (pairs of floats) and a function direction that takes three vertices and returns an int (-1, 0 or 1). What's the best way to test if direction v1 v2 v3 == direction v2 v3 v4 .... == direction vn v1 v2, i.e. with a sliding window of three vertices which wraps around to the beginning?
02:19:58 <loreints> also, I'm using an old v. of ghc (7.0.4)
02:20:25 <ivanm> donri: that text doesn't appear in that link for me...
02:21:12 <donri> @where+ stacktrace compile with -prof -fprof-auto -rtsopts and run with +RTS -xc
02:21:13 <lambdabot> Good to know.
02:21:18 <FatPhil> Apologies if this isn't an appropriate place to turn up and start requesting answers to stupid questions!
02:21:28 <shachaf> @where rts-xc
02:21:28 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
02:21:38 <sheldonh> FatPhil: see the comments for Exercise 11 at the bottom of http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
02:21:43 <ivanm> FatPhil: zipWith3 with appropriate cycling
02:21:44 <donri> sheldonh: sorry it's -fprof-auto not -fprof-all
02:22:05 <donri> ivanm: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html#ftn.id658686
02:22:11 <donri> footnotes
02:22:33 <ivanm> -auto-all still seems to work here, unless it's being automagically turned on by Cabal...
02:23:03 <donri> ivanm: yea http://www.haskell.org/ghc/docs/latest/html/users_guide/release-7-4-1.html#id526936
02:23:10 <FatPhil> Great, thanks ivanm and sheldonh
02:23:41 <ivanm> donri: that's going to be fun for keeping backwards-compatability for compiler options in .cabal files when it gets deprecated...
02:23:53 <donri> heh
02:24:08 <ivanm> I've also never been sure if ghc-prof-options needs -prof or not...
02:24:11 <donri> although stack traces with -xc is new in 7.4.1 anyway?
02:24:14 <sheldonh> FatPhil: this is what i cam up with, such that i then got the right answer from turns [p1,p2,p3,p4,p5]  http://pastie.org/4590509
02:24:24 <donri> ivanm: not. you use --enable-library-profiling etc
02:24:37 <ivanm> *nod* which makes sense...
02:24:48 <ivanm> but I've been copy/pasting a lot of my .cabal configs from file to file :p
02:24:50 <sheldonh> FatPhil: but i'm on haskell day 2, and you asked about the "best way", so... :)
02:25:04 <donri> :)
02:25:07 <donri> i use vim snippets
02:25:16 <donri> https://github.com/dag/vim2hs
02:26:17 <FatPhil> sheldonh: that doesn't deal with wrapping indices, right?
02:26:47 <FatPhil> sheldonh: But thanks anyway
02:26:52 <sheldonh> FatPhil: yeah, sorry, i should have said. the exercise i was doing just had to describe the turns in a journey :(
02:28:10 <donri> sheldonh: heh new monad reader talks specifically about head [] errors and making them total
02:28:14 <donri> http://themonadreader.files.wordpress.com/2012/08/issue20.pdf
02:28:38 <sheldonh> donri: oooooh, a magazine.... i'd forgotten about those :)
02:29:03 <sheldonh> in many ways, C++ ruined my life
02:36:29 <FatPhil> Another simple question: how do I tell if a list is constant without pattern matching? I want to iterate along the list, check whether each successive pair is equal and And some bool as I go
02:37:00 <donri> what's a constant list
02:37:03 <FatPhil> I've only programmed in C++ and I fear it might take a while to be able to start thinking of algorithms in terms of anything other than mutable state
02:37:04 <FatPhil> Sorry
02:37:08 <FatPhil> All elements equal
02:38:13 <ivanm> FatPhil: all (==) . zip`ap`tail
02:38:19 <mikeplus64> FatPhil: all (== head xs) xs ?
02:38:20 <ivanm> no, wait, that won't work
02:38:31 <ivanm> @type all (uncurry (==)) . zip`ap`tail
02:38:32 <lambdabot>     Precedence parsing error
02:38:32 <lambdabot>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression
02:38:34 <ivanm> bah
02:38:38 <ivanm> @type all (uncurry (==)) . (zip`ap`tail)
02:38:39 <lambdabot> forall a. (Eq a) => [a] -> Bool
02:38:43 <ivanm> \o/
02:41:21 <adimit> ‚Ä¶ stupid question. I've been trying to figure out a "good" way to add escapes to a Text string, but finding an *efficient* way to do so seems difficult. Text.replace is Text -> Text -> Text, but I'd need a pattern or (Char -> Bool) instead of Text as a condition. So I thought of using regexes, but there doesn't seem to be an 's/pat/rep/' kind of functionality, some I'm back to manually glueing Text
02:41:23 <adimit> chunks together, but that seems tedious. Is there anything I'm overlooking?
02:41:32 <donri> ivanm: won't that do more == than necessary?
02:41:58 <ivanm> donri: how?
02:41:59 <adimit> (i.e. what I want is "abbb$foo" -> "abbb\\$foo", where $ is among the chars I want to escape.
02:42:10 <ivanm> all is implemented using foldr, so it's lazy
02:42:34 <ivanm> adimit: parse it and use a pretty-printing library to put it back together?
02:42:39 <donri> oh yea, i'm stupid
02:43:23 <mikeplus64>  adimit can't you already have escaped characters in Text literals?
02:43:30 <donri> adimit: Data.Text.map?
02:43:39 <shachaf> adimit: replace s d = intercalate d . splitOn s
02:43:45 <ivanm> donri: you'd want more of a concatMap
02:43:51 <shachaf> splitOn :: Text -> Text -> [Text]
02:44:01 <shachaf> split :: (Char -> Bool) -> Text -> [Text]
02:44:06 <adimit> ivanm: wouldn't that be kinda‚Ä¶ overengineered?
02:44:24 <ivanm> adimit: depends on how complicated your escaping is
02:44:29 <adimit> mikeplus64: the idea is to escape certain characters because I'm sending a query to a search server that needs certain characters escaped.
02:44:38 <adimit> ivanm: it's really simple per-character escape.
02:44:49 <ivanm> then yes, it might be a tad over-engineered :)
02:44:51 <adimit> donri: map won't work, because I can't *insert* something with it.
02:44:53 <FatPhil> ivanm: and $ map (== head xs) (tail xs) works and looks simple enough. I'm still concerned that everything I write will turn out to be wildly inefficient, but I'll worry about that when I at least have a basic grasp of the syntax of the language!
02:44:59 <shachaf> adimit: Did you see what I said there?
02:45:02 <donri> ah yea
02:45:06 <shachaf> You should be able to put it together from that. :-)
02:45:08 <adimit> shachaf: sounds good!
02:45:20 <ivanm> FatPhil: that is just as efficient, but it will fail on the empty list case
02:45:21 <adimit> shachaf: yeah, sorry, I had to answer everybody in turn :-)
02:45:36 <shachaf> (I'm not sure if it'll fuse nicely or not... At least it's short.)
02:45:49 <adimit> I'm just a bit concerned about efficiency (this function might be called a whole damn lot server-side.)
02:46:29 <adimit> ‚Ä¶ well, I guess I'll have to try it out.
02:46:56 <donri> "not sure if smart or haddocks" when hackage is down, truth will out!
02:47:21 <shachaf> adimit: If it doesn't fuse nicely, there are probably better ways to do it.
02:47:33 <shachaf> But you should try this first and see if it's acceptable. Since it's a one-liner. :-)
02:47:45 <adimit> premature optimization and all that‚Ä¶
02:47:57 <donri> adimit: if it turns out to be a bottle neck, fix it *then* :p
02:48:02 <shachaf> At any rate this is a thing that can be nicely abstracted from the rest of your code.
02:48:40 <adimit> donri: it's library code. I don't even have an app to stress test it, but I know others do.
02:48:57 <FatPhil> ivanm: what's ap in your version? can't see it on hoogle except as a monad operator, and ghci doesn't know what it is
02:49:06 <ivanm> donri: local install of installed documentation; :browse in ghci, etc.
02:49:08 <adimit> so I'll have to set up a benchmark. *sigh*. But yeah, it encapsulates nicely.
02:49:13 <ivanm> FatPhil: that's the one
02:49:22 <ivanm> you might need to import Control.Monad.Instances for that code snippet to work
02:51:30 <donri> (zip`ap`tail) xs == zip xs (tail xs)
02:51:42 <donri> shouldn't need .Instances
02:51:47 <donri> can also use Control.Applicative and <*>
02:51:59 <shachaf> @quote zip`ap
02:52:00 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
02:53:17 <ion> heh
02:53:53 <mikeplus64> ap zip tail is also fairly mesoamerican sounding
02:53:54 <ivanm> donri: .Instances is for the ((->)a) instance
02:54:25 <donri> ivanm: but you get it from Control.Monad anyway
02:54:36 <ivanm> do you?
02:54:38 <mikeplus64> no
02:54:49 <donri> I do
02:54:53 <mikeplus64> i don't :(
02:54:56 <donri> >>> :m Control.Monad
02:54:56 <donri> >>> :t (zip`ap`tail)
02:54:56 <donri> (zip`ap`tail) :: [b] -> [(b, b)]
02:55:25 <ivanm> donri: it type checks, but when you try to use it it doesn't work
02:55:31 <mikeplus64> Prelude Control.Monad> (zip`ap`tail) [1..10]
02:55:31 <ivanm> try it if you don't believe me!
02:55:33 <donri> oh duh
02:55:33 <mikeplus64> <interactive>:5:5:
02:55:35 <mikeplus64>     No instance for (Monad ((->) [b0]))
02:55:39 <donri> why am i ircing before morning coffee
02:55:48 <shachaf> IRC *is* morning coffee.
02:56:12 <ivanm> donri: note that without importing Instances the type it gives includes a Monad constraint
02:57:11 <donri> ivanm: also note that it didn't, in my paste
02:57:20 <donri> >>> :m Control.Monad
02:57:20 <donri> >>> (zip`ap`tail) [1,2,3]
02:57:20 <donri> [(1,2),(2,3)]
02:57:20 <donri> ^ also
02:57:30 <ivanm> huh
02:57:38 <ivanm> what's your .ghci contain?
02:57:45 <ivanm> do you import a lot of stuff by default?
02:57:50 <donri> nope
02:57:53 <donri> and :m resets that
02:57:59 <ivanm> well, you have a non-standard prompt...
02:58:13 <donri> :set prompt ">>> "
02:58:13 <donri> :set +m -w
02:58:13 <donri> :set -XQuasiQuotes -XOverloadedStrings
02:58:23 <ivanm> what does the +m -w do?
02:58:52 <ivanm> and you're not in a project with it's own .ghci file?
02:58:54 <donri> enable multiline editing and disable warnings
02:59:02 <donri> i'm not
02:59:12 <ivanm> does the -w affect it maybe?
03:00:07 <adimit> shachaf: so, the "good" way to escape chars seems this (split and splitOn won't work, they "consume" the character they split on:) intercalate "\\" . groupBy (\_ x -> not $ x `elem` escapeChars)
03:00:28 <adimit> (where escapeChars is a String that holds all chars you want to put a backslash in front of.
03:00:37 <donri> ivanm: type error with -ignore-dot-ghci
03:00:37 <ivanm> adimit: see the split package
03:00:38 <donri> weird
03:00:45 <adimit> ivanm: won't work with Text.
03:01:00 <ivanm> adimit: oh, I thought you were using String since you listed list functions there
03:01:05 <shachaf> adimit: Are these lazy or strict Texts?
03:01:10 <adimit> shachaf: strict.
03:01:19 <ivanm> donri: hmmm?
03:01:51 <adimit> ivanm: yeah, I was tacitly assuming everybody knew I was using their equivalents from Data.Text ;-)
03:01:57 <donri> ivanm: oh, type error with fresh ghci. looks like :m doesn't reset imported instances
03:02:00 <shachaf> adimit: I wonder whether T.concatMap would be any good.
03:02:01 <shachaf> Probably not.
03:02:19 <ivanm> donri: yeah, instances are sneaky, remember? ;-)
03:02:22 <adimit> shachaf: I don't see how you could *insert* something with concatMap‚Ä¶
03:02:26 <donri> yea
03:02:32 <ivanm> adimit: how couldn't you?
03:02:40 <ivanm> @hoogle Data.Text.concatMap
03:02:40 <lambdabot> Data.Text concatMap :: (Char -> Text) -> Text -> Text
03:02:40 <lambdabot> Data.Text.Lazy concatMap :: (Char -> Text) -> Text -> Text
03:02:48 <donri> ivanm: works with Control.Applicative alone though, so that means less imports required
03:03:09 <adimit> ivanm: hm‚Ä¶ you're right. lemme try it.
03:03:40 <donri> what's the motivation for .Instances anyway
03:03:47 <ivanm> donri: because it imports .Instances
03:03:56 <ivanm> and my guess is to avoid circular imports somewhere along the line
03:04:00 <donri> oh dear
03:06:16 <adimit> ivanm: you were right: X.concatMap (\x -> if x `elem` escapeChars then X.pack ('\\':[x]) else X.singleton x) works (X being the qualified import of Data.Text)
03:06:57 <adimit> cool stuff. Thanks ivanm, shachaf. Now I'll have to benchmark that stuff :-D
03:07:17 <shachaf> adimit: I expect that there can be a much more efficient way to do it if these end up being slow.
03:07:49 <ivanm> attoparsec + builder! :p
03:07:55 <donri> ivanm: looks like applicative defines its own (->) actually
03:08:58 <donri> and .Instances is deprecated in git
03:09:19 <donri> https://github.com/ghc/packages-base/blob/master/Control/Monad/Instances.hs#L16
03:09:23 <ivanm> donri: it has its own Applicative instance
03:09:42 <donri> https://github.com/ghc/packages-base/commit/7c1dff56f8071e62c708679d79299b062806ff91
03:10:02 <donri> ivanm: yea i didn't test it with `ap`, just <*>
03:10:19 <adimit> shachaf: that's true. I guess I'll have to dive into the internals of Text to find a better way.
03:10:32 <ivanm> huh, wouldn't deprecating a module in base require a libraries request?
03:10:37 <ivanm> I don't recall seeing one about it...
03:11:43 <donri> doesn't look deprecated with pragma yet though
03:17:54 <shachaf> adimit: I've read quite a lot of the internals of Text recently.
03:18:23 <shachaf> Most of it is written using all sorts of horrible unsafe functions, naturally.
03:18:39 <ivanm> yeah :(
03:18:41 <shachaf> But you shouls only worry about all this if it turns out to matter.
03:18:54 <shachaf> Also: What are you going to be doing with this Text?
03:18:54 <adimit> yeah, I've dabbled in the code before.
03:19:09 <adimit> shachaf: make a ByteString and send it over a TCP socket.
03:19:14 <shachaf> Maybe you'll be encoding it to a ByteString, in which case the escaping could be folded into the encoding or something?
03:19:26 <adimit> true that.
03:19:41 <shachaf> I mean, there might be no point in making a whole new Text if you're just encoding it right after that.
03:19:51 <ivanm> shachaf: wait, use a custom encoding? :/
03:20:15 <shachaf> Also, if you use a Data.Text.Lazy, you might be able to reuse chunks of the original Text, which might or might not be a good idea.
03:20:20 <adimit> well, it'll go into a binary Builder to put together the exact binary format the server wants.
03:20:33 <shachaf> ivanm: Who knows? It depends on the circumstances.
03:21:14 <adimit> it does. If the escaping function turns out to be too slow, I'll have to go with that. Though, the rest of the library isn't particularly well-written. My guess is that I'd find other bottle-necks first.
03:21:41 <adimit> (it's the haskell-shpinx-client, if you're interested :-)
03:23:28 <adimit> What I gathered from the Text internals is that it basically uses tons of arrays and pointers, and all sorts of unsafe functions to manage them. I'm really quite impressed by bos' work on it. It looks like it should be horribly buggy, but it turns out to be really good.
03:24:15 <shachaf> I wish it was more composable without losing performance.
03:24:28 <shachaf> There are all sorts of implementation details in pretty much every single function.
03:24:39 <shachaf> So trying to change it to use a new encoding isn't fun.
03:24:46 <shachaf> (Well, less fun than you'd expect, even.)
03:26:12 <MHD> is Hackage still down?
03:26:22 <adimit> yeah. That's why I'm gonna stick with concatMap until someone files a bug, methinks.
03:26:52 <ivanm> @where hackage-mirror
03:26:52 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
03:26:53 <ivanm> MHD: ^^
03:27:18 <ivanm> shachaf: if you think that's bad: he almost seems to purposefully use Text internals in attoparsec when there are perfectly good safe variants available
03:28:31 <adimit> he probably knows the internals better than the interface :-P
03:29:37 <ivanm> heh
03:38:21 <ivanm> if I have that "go (Just a) = liftM (DL.cons a) . go =<< mf", then will the cons happen _before_ mf is evaluated?
03:39:07 * ivanm is still trying to work out what is causing his code to run so slowly when allowing multiple component traversal
03:45:17 <hpaste> LordBrain pasted ‚ÄúGHC Bug?‚Äù at http://hpaste.org/73718
03:46:26 <ivanm> loreints: what's the actual error?
03:46:42 <ivanm> oh, that
03:46:48 <LordBrain> you mean me?
03:46:49 <ivanm> try disabling monomorphism restriction
03:46:53 <ivanm> ummm, yes
03:46:57 <ivanm> sorry loreints
03:47:35 <ivanm> {-# LANGUAGE NoMonormorphismRestriction #-} IIRC
03:47:58 <ivanm> I think you've been bitten by a recent change in how the MMR interacts with let statements
03:48:44 <ivanm> @src foldr1
03:48:44 <lambdabot> foldr1 _ [x]    = x
03:48:45 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
03:48:45 <lambdabot> foldr1 _ []     = undefined
03:48:45 <LordBrain> it still fails to compile
03:49:02 <ivanm> LordBrain: what's the actual error message it gives you?
03:49:30 <LordBrain> Could not deduce (HReverse' (HCons a' HNil) l' (HCons a l),
03:49:30 <LordBrain>                       HReverse' (HCons a HNil) l (HCons a' l'))
03:49:30 <LordBrain>       arising from a use of `bug' ...
03:49:51 <LordBrain> it works fine without the let
03:50:20 <ivanm> I'm assuming HReverse' is some other class that defines hReverse ?
03:50:26 <LordBrain> ye
03:50:27 <LordBrain> yes
03:50:54 <ivanm> *shrug*
03:50:56 <LordBrain> it's copied straight from HList code
03:51:08 <LordBrain> except i put this let bug =
03:51:11 <ivanm> I've never used hlist
03:51:19 <ivanm> so I'd rather leave this to someone that has
03:52:30 <LordBrain> the funky thing is i don't see why let bug = ... in bug should have such an effect, unless there is recursion which their isn't... or monomorphism like you said
03:53:32 <ivanm> can you just double check the code your compiling that it is definitely a good case of hBuild2' l x = foo, and bad case of hBuild2' l x = let bug = foo in bug ?
03:54:14 <LordBrain> yeah, i've double checked
03:55:28 <LordBrain> i even made bug have an argument, let bug l = hReverse (HCons x l) in bug l
03:55:44 <LordBrain> in case monomorphism was slipping thru a crack somehow..
04:04:05 <LordBrain> hackage is down, and i guess that means ghc's bug tracking system too
04:04:21 <Botje> no bug tracker; no bugs!
04:04:32 <sheldonh> holiday!
04:04:40 <Yorik> Hello there! May I ask a question here?
04:04:49 <ivanm> Yorik: you just used your one question of the day!
04:04:50 <ivanm> :p
04:05:29 <Yorik> getRandAge::IO Int             getRandAge = getStdRandom( randomR (20,50))                  army = array (1,100) ([(i,Soldier (Male) (Age (getRandAge))) | i <- [1..100]])
04:05:54 <LordBrain> there goes your layout
04:06:03 <Yorik> How to translate IO Int to  Int?
04:06:12 <Botje> you can't.
04:06:27 <Yorik> yeah, excuse my English
04:06:39 <LordBrain> technically it is possible, but not what you want to do
04:07:11 <Yorik> I want to create  array of "Soldier" with the random ages
04:07:24 <LordBrain> getRandAge >>= \age -> DoSomethingWithAgeAsPureValue
04:07:56 <LordBrain> or do { age <- getRandAge; doSomethingToIt age }
04:08:13 <Yorik> Wow!  Where it should be?
04:08:17 <Yorik> army = array (1,100) ([(i,Soldier (Male) (Age (getRandAge))) | i <- [1..100]])
04:08:25 <Botje> army <- listArray (1,100) . map (\age -> Soldier Male (Age age)) `fmap` replicateM 100 randomRIO (20,50)
04:08:44 <Botje> needs parens around the randomRIO, too.
04:09:10 <Botje> or you rewrite getRandAge as randomRIO (20,50) and use that.
04:11:10 <daniel_-> anyone here using sublimehaskell plugin?
04:13:10 <sheldonh> for function f, is (not f) a predicate?
04:13:29 <Botje> not . f, rather.
04:13:31 <hpaste> timthelion pasted ‚Äúwow!‚Äù at http://hpaste.org/73719
04:13:35 <adimit> if it typechecks yes, but that also entails that f is a Boolean.
04:13:45 <timthelion> Anyone seen THAT before???
04:13:57 <Botje> timthelion: did you forget --make?
04:13:59 <adimit> (in which case, all of it is a boolean, not a predicate. See what Botje said.)
04:14:17 <timthelion> Botje: what do you mean?
04:14:44 <Botje> does adding --make solve the error, i mean :P
04:14:47 <timthelion> Botje: Why would I need --make
04:14:58 * timthelion hasn't played arround yet.
04:15:06 <Botje> it's worth a shot
04:15:06 <timthelion> nope
04:15:08 <timthelion> same error
04:15:13 <Botje> boo.
04:15:31 <LordBrain> --make is the default with recent ghc
04:16:14 <timthelion> Botje: it looks like I have an invalid .o file somehow.  I created a test dir without the .hi's and the .o's and tried again, no error.
04:16:20 <Yorik> Maybe I can rewrite " data Age = Age Int deriving(Eq) " to contain Int IO ?
04:16:47 <LordBrain> Yorik,... no you don't want to do that
04:16:53 <sheldonh> Botje: sorry, i didn't get that. are you saying i negate my predicate with a period, e.g. break (. f) xs
04:16:54 <timthelion> Botje: it was caused by a bad .o file
04:17:13 <Botje> sheldonh: no, you use "not . f"
04:17:20 <sheldonh> ah, phew.
04:17:21 <Yorik> Is it a bad idea?
04:17:22 <Botje> which expands to \x -> not (f x)
04:17:36 <Botje> Yorik: that is a very bad idea.
04:18:22 <Yorik> Ok, I'll trust you.
04:18:28 <LordBrain> Yorik, keep your data type pure if you can  help it.
04:19:50 <LordBrain> you have functions that return into the IO monad, but that is fine, use >>= or fmap to operate on values while they are in the monad. Make all your functions operate on pure values if you can at all help it.
04:20:39 <LordBrain>  you are best served if your code is as pure as possible
04:22:50 <donri> is hackage hosted by the haskell.org folks? will hackage2 be?
04:22:53 <LordBrain> you will often have input from the user or some other such thing inside the IO monad, but you can apply pure functions  to it with fmap and impure functions with (>>=) "bind"
04:23:12 <Yorik> How to keep  random int data pure? I can't understand
04:23:33 <LordBrain> post your code to hpaste
04:23:53 <Botje> Yorik: do all the nasty IO stuff up front, then use the results to create pure values.
04:23:58 <taylorgb> functions that use the data don't need to know that it is random, it is only at the point when the random data is computed that it needs to be in IO
04:24:46 <Botje> something like do { ages <- replicateM 100 getRandAge; return $ listArray (1,100) $ map (\age -> Soldier Male (Age age)) ages }
04:24:53 <Yorik> Thanks a lot!
04:25:08 <Botje> note that the return value of that expression will be IO (Array Int Soldier)
04:25:24 <LordBrain> technically it is always in IO, but the functions that operate on it should accept pure values and be transformed by fmap or bind
04:29:56 <cheater__> @type replicateM
04:29:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
04:30:25 <daniel_-> is there any hackage mirrors?
04:30:30 <daniel_-> for the haddoc documentations?
04:30:42 <cheater__> can a Monad m be of any other kind than * -> * ?
04:30:42 <LordBrain> seems not
04:30:55 <byorgey> cheater__: no
04:30:58 <adnam> daniel_-: http://hdiff.luite.com/packages/archive
04:30:58 <LordBrain> but you can grab the source
04:31:02 <cheater__> then why is the constraint there?
04:31:19 <Yorik> How to get pure array of random int ?
04:31:35 <cheater__> define "pure array"
04:31:40 <Botje> Yorik: by executing that block inside a do block and passing the value down to a pure function...
04:31:50 <cheater__> oh, non-IO
04:31:59 <Botje> Yorik: can you just put your current code on hpaste?
04:32:10 <Yorik> give example, pleasr
04:32:11 <Botje> Yorik: then we can help you identify the place where you want to go from IO to non-IO.
04:32:31 <cheater__> Botje: at the very top probably ;)
04:32:32 <Yorik> army = array (1,100) ([(i,Soldier (Male) (Age ( random (20,50) ))) | i <- [1..100]])
04:32:35 <LordBrain> do { array <- impureArray; ... }
04:32:51 <byorgey> cheater__: it's not a constraint.  It's just a kind annotation.
04:33:11 <cheater__> byorgey: ok. what's it for?
04:33:25 <byorgey> cheater__: documentation
04:33:41 <Botje> Yorik: is that your entire code?
04:33:44 <cheater__> ok
04:33:44 <LordBrain> or impureAray >>= yadayada
04:33:47 <cheater__> thanks
04:35:32 <ivanm> wait, maybe my problem isn't to do with DList or State: it's the fold I'm using to merge all the results together!
04:35:37 * ivanm facepalms
04:36:23 <Yorik> main = do       army<-array (1,100) ([(i,Soldier (Male) (Age ( random (20,50) ))) | i <- [1..100]])      putStrLn(show(army ! 7))   --something like this
04:38:29 <LordBrain> are you using quickcheck?
04:38:37 <hpaste> Botje pasted ‚ÄúExample for Yorik‚Äù at http://hpaste.org/73721
04:38:49 <Botje> Yorik: see there.
04:39:06 <Botje> it's untested, of course.
04:47:26 <Yorik> I'm sorry but it doesn't work (http://hpaste.org/73721 Example for Yorik) even with import Data.Sequence
04:50:41 <hpaste> yorik pasted ‚ÄúYorik's soldiers :)‚Äù at http://hpaste.org/73723
04:56:40 <sanjoyd> Is http://hackage.haskell.org/ down?
04:56:42 <sanjoyd> I get a 504.
04:57:35 <ion> Topic
04:57:46 <Botje> Yorik: and which error do you get?
04:58:12 <Yorik> ghc --make "soldiers.hs" (in directory: /home/geo/haskell/problems) [1 of 1] Compiling Main             ( soldiers.hs, soldiers.o ) soldiers.hs:32:85:     Couldn't match expected type `[Int]' with actual type `Seq a0'     In the second argument of `map', namely `ages'     In the second argument of `($)', namely       `map (\ age -> Soldier Male (Age age)) ages'     In the second argument of `($)', namely       `listArray (1, 100) $ ma
04:58:20 <Botje> Yorik: don't paste in channel.
04:58:22 <sanjoyd> ion: ah, thanks!
04:58:26 <Botje> Yorik: annotate the paste instead :)
04:58:29 <Yorik> –æ–∫!
04:58:36 <Botje> but i've downloaded your paste now. let's see ..
04:59:54 <Botje> Yorik: oh, duh.
05:00:08 <Botje> you're importing Data.Sequence unqualified and it's providing the wrong replicateM.
05:00:13 <Botje> I meant the one in Control.Monad
05:00:18 <Botje> @hoogle Control.Monad.replicateM
05:00:18 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
05:00:18 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
05:00:44 <Botje> Yorik: replacing Data.Sequence with Control.Monad makes your program print something.
05:01:15 <Yorik> Thanks a lot! Such a difficult programming language..
05:05:00 <Botje> it's just asking you to be precise :)
05:05:04 <Botje> what other languages do you know?
05:06:05 <daniel_-> why did happstack decide to that everything is needed to be encapsulated in the ServerPart monad? it really makes it awkward to do IO
05:06:08 <daniel_-> or am i doing it wrong?
05:06:19 <daniel_-> with liftIO everywhere
05:06:38 <ivanm> write your own combinators to avoid using liftIO so much?
05:06:41 <ivanm> *shrug*
05:06:50 <ivanm> I've never dealt with IO-wrappers before
05:09:42 <msieradzki> daniel_-, as far as I understand it's because ServerPart has more context than just IO
05:10:14 <msieradzki> but when it comes to simple question how to minimalize count of lift $ I don't know
05:10:53 <sheldonh> wow. all this time, i've been waiting for the chapter on loops :)
05:11:17 <byorgey> sheldonh: loops? what are those?
05:11:20 <byorgey> ;)
05:11:57 <permagreen> Loops? We don't need no stinkin' loops!
05:13:39 <qwr> daniel_-: write aliases for common functions needing liftIO and/or use liftIO $ do
05:14:09 <koko_> helo
05:14:17 <koko_> is the haskell download platform link down?
05:14:45 <koko_> i mean this link : hackage.¬≠haskell.¬≠org/¬≠platform/¬≠
05:14:47 <sayuke> I was looking through the blaze builder code, and theres two types BuildSignal a <-> BuildStep a which are recursively defined in terms of one another. The 'a' is only present in the terminal Done (Ptr Word8) a constructor. The only use of the Done constructor designates 'a' as unit (). Any ideas on why this is needed? Thanks.
05:14:51 <sheldonh> koko_: see topic :)
05:15:00 <koko_> oh lawl thanks
05:15:14 <koko_> just when i wanted to start learning too!
05:15:32 <sheldonh> koko_: time to lean on a distro's packaging :)
05:17:10 <koko_> is that some alternate way to get the platform? i don't really understand what you mean by 'lean on a distro's packaging'
05:18:03 <sheldonh> koko_: like, a lot of operting system distributions include packages for haskell. so on Fedora, all i had to do was "yum install haskell-platform"
05:18:04 <tdammers> hackage down? not again...
05:18:17 <ivanm> koko_: if you use a linux distro - especially one of the binary ones - you can that way use a compiled version that is hosted elsewhere and not on hackage
05:18:34 <ivanm> @where hackage-mirror
05:18:34 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
05:19:00 <hpaste> LordBrain pasted ‚ÄúFor Yorik, a QuickCheck.Gen version‚Äù at http://hpaste.org/73724
05:19:31 <sheldonh> is the single quote (') generally accepted notation for "subsequent"?
05:19:48 <daniel_-> is hackage just down or is it planned maintenance or anything?
05:19:52 <Yorik> Thank you very much!
05:19:58 <ivanm> daniel_-: galois' site is down, and they host hackage
05:20:02 <adnam> sheldonh: i think so, but i cringe a little everytime i write it
05:20:06 <LordBrain> it's been down since yesterday
05:20:41 <sheldonh> adnam: i'm suspending disbelief with the whole naming thing in haskell :)
05:20:51 <ivanm> sheldonh: there are three primary uses of ' in Haskell: 1) denotes strictified version, as in foldl'; 2) an updated/altered version of another function; 3) the next version of a variable (typically only within a where block or something)
05:21:00 <ivanm> the third case also applies to Haskell'
05:21:13 <adnam> sheldonh: well if you can replace it with something point-free that's nicer
05:21:18 <adnam> (maybe)
05:21:30 <sheldonh> ivanm: cool, thanks
05:21:31 <ivanm> the second case isn't used as often; typically a function ending in ' means it's a stricter version than the original
05:22:09 <sheldonh> ivanm: in a way, (1) is a special case of (2) (and arguably of (3))   ;)
05:22:28 <ivanm> heh
05:23:39 <ivanm> OK, so the problem I've spent most of the last week on has just been solved, by adding a single ~ :s
05:24:33 <sheldonh> does haskell do something magical to reduce the cost of recursion, because there seems to be a *lot* of reliance on recursion. maybe thunking reduces stack consumption, or these things end up inlined and unrolled?
05:24:55 <sheldonh> ivanm: that'll learn you. always care a spare tilde in your pocket
05:25:04 <ivanm> heh
05:25:10 <ivanm> sheldonh: laziness
05:25:27 <Botje> sheldonh: haskell's evaluation process is comparable to graph rewriting.
05:25:29 <ivanm> GHC doesn't implement TCO, because laziness often means it isn't needed
05:29:55 <tdammers> I thought newer versions did
05:30:32 <dmwit> Calls don't happen the same way in Haskell that they do in other languages.
05:30:44 <dmwit> As a result, tail-calls don't happen the same way, either.
05:31:59 <tdammers> well, yeah, but you have to evaluate at *some* point
05:32:19 <permagreen> I remember coming from Scheme and very carefully writing a tail-recursive factorial function in Haskell, only to feel dumb later on when I realized it didn't really matter
05:32:37 <pbaldanta> hi
05:32:40 <pbaldanta> from spain
05:32:48 <Botje> hallo
05:32:48 <dmwit> I don't understand how "you have to evaluate at some point" and "tail calls don't happen the same way" are in conflict.
05:32:52 <danr> hi from uk :)
05:35:48 <tdammers> hola from holanda
05:36:02 <tdammers> dmwit: not sure myself either
05:37:01 <dmwit> Oh, I see the top-level question now.
05:37:19 <dmwit> sheldonh: You should read the canonical STG-machine (spineless, tagless G-machine) paper.
05:37:47 <dmwit> It discusses some of the groundwork you need for efficiently implementing a lazy functional language.
05:38:32 <dmwit> In short: recursion does not create a stack frame. Only evaluating deeply-nested thunks uses a stack.
05:38:53 <dmwit> (And when writing Haskell, you must be careful to avoid making deeply-nested thunks, or you will have performance and possibly termination problems.)
05:39:03 <sheldonh> weird to have so many axioms challenged at once :)
05:39:51 <sheldonh> in my head, a non-lined function call has always meant a stack frame :)
05:40:00 <tdammers> I think I get it
05:41:09 <dmwit> Yes, it's a very unusual evaluation model.
05:41:42 <tdammers> the evaluation model is one of the most attractive things about haskell imo
05:42:07 <tdammers> I mean, the syntax is concise and works and all that, but it's not particularly elegant or anything
05:42:09 <dmwit> Calls are just jumps into another bit of code.
05:42:15 <dmwit> No saving anything on the stack, just jump.
05:42:17 <dmwit> (!)
05:42:24 <sheldonh> terrifying :)
05:42:26 <tdammers> yeah, that's what I figured
05:42:33 <tdammers> glorified goto ;)
05:42:35 * tdammers ducks
05:42:39 <dmwit> very much so =)
05:42:42 <LordBrain> laziness is a virtue indeed
05:42:52 <sheldonh> isn't there a big functional conference called goto? ;)
05:43:05 <Jeanne-Kamikaze> when you say "recursion does not create a stack frame", you mean tail recursion, right ?
05:43:35 <tdammers> Jeanne-Kamikaze: doesn't matter, I think
05:43:53 <tdammers> evaluation order != declaration order
05:45:54 <LordBrain> he said nested thunks creates a stack frame, so probably the stack frames generated by recursions (when stack is necessary) are actually resulting from nested thunks
05:46:15 <tdammers> yep, that's how I understand it
05:47:25 <sheldonh> dmwit: having trouble finding this paper on the canonical STG-machine. i've found ministg. is that it?
05:47:34 <dmwit> sheldonh: One moment.
05:48:11 <dmwit> Jeanne-Kamikaze: For example, if I define x = 1:x, there are no stack frames (maybe one stack frame total for the (:)) despite the fact that x is not tail recursive.
05:48:44 <Jeanne-Kamikaze> true shit
05:49:07 <dmwit> sheldonh: http://scholar.google.com/scholar?cluster=9795042292187145048&hl=en&as_sdt=0,39 I think
05:49:38 <sheldonh> dmwit: great. thanks for looking it up for me :)
05:51:47 <dmwit> On the other hand, if I define "fancyId' x 0 = x; fancyId' x n = fancyId' (x+1) (n-1); fancyId = fancyId' 0", then fancyId 10 will create 10 stack frames, even though fancyId' is tail-recursive.
05:52:51 <dmwit> Or rather, fancyId 10 itself creates no frames, but demanding the result from fancyId 10 spontaneously causes 10 stack frames to appear from thin air. =P
05:53:23 <byorgey> POOF
05:53:49 <byorgey> "dang, where did all these stack frames come from"
06:02:18 <aristid> byorgey: and it always makes that sound, too
06:03:35 <dmwit> http://i.imgur.com/PNpNk.jpg
06:04:16 <aristid> dmwit: i once searched for that picture, but with bananas. no luck :(
06:04:44 <aristid> (reason was that somebody had captioned it with catamorphisms, and iirc catamorphisms are bananas!)
06:05:02 <dmwit> http://i.ytimg.com/vi/5bODn-q0g68/0.jpg
06:05:20 <Baughn_> Hackage still has no per-package authentication or transfer signatures, right?
06:05:27 <Baughn_> (Shouldn't it at least use HTTPS)?
06:05:32 <dmwit> Baughn_: Coming in the next few weeks!
06:05:37 <dmwit> Hackage2 just went online.
06:05:42 <tdammers> wheeeeeeee!
06:05:45 <dmwit> And it has per-package ownership.
06:05:46 <aristid> dmwit: haha
06:05:50 <dmwit> dunno what "transfer signatures" are
06:06:08 <aristid> dmwit: that one makes for good catamorphism jokes too, i guess
06:06:16 <Baughn_> dmwit: Signing packages so I can be sure they're from who I think they are
06:06:21 <tdammers> a signature tacked onto each upload and download to make sure it's from the official author?
06:06:29 <Baughn_> Yes
06:06:41 <tdammers> I'd actually like to see that too
06:06:46 <dmwit> I think Hackage2 doesn't have these but has code structured in such a way that it's (supposed to be) easy to add such a feature.
06:07:01 <Baughn_> Even just using HTTPS would be an improvement, but then an intruder could still alter the code on the hackage server
06:07:06 <aristid> it has download counts!
06:07:18 <tdammers> I think Haskell would be a perfect fit for a few security-related tasks, but as long as the package manager basically downloads untrusted sources, I'd hesitate to use it for such things
06:07:49 <mroman> @unpl (.f) . g
06:07:50 <lambdabot> (\ d i -> g d (f i))
06:07:54 <aristid> tdammers: i guess that's a not entirely unreasonable point
06:08:06 <byorgey> aristid: http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960824968&k=hNkLy
06:08:10 <tdammers> or at least, I would have to restrict myself to packages available via debian or something, and cabal-dev would be out
06:08:17 <Baughn_> aristid: Or to put it another way, I refuse to run hackage code outside of a virtual machine, at the moment.
06:08:31 <mroman> @unpl (.f) . g $ x
06:08:31 <lambdabot> (\ k -> g x (f k))
06:08:43 <aristid> byorgey: ah yeah :)
06:09:01 <aristid> Baughn_: that seems mildly paranoid to me
06:09:18 <tdammers> the attack vector is just too easy - find a popular package, inject malicious code, bump third version digit, upload
06:09:23 <Baughn_> aristid: It's only paranoid if you don't have access to internal google systems on the same machine.
06:09:36 <aristid> Baughn_: fair enough. i happen not to.
06:09:37 <tdammers> you don't even need your own hackage PW if you have successfully sniffed a legitimate user's traffic before
06:09:56 <dmwit> Yes, Hackage's security model can improve a lot. =)
06:10:04 <Baughn_> Hackage doesn't /have/ a security model
06:10:05 <ivanm> tdammers: why third version? make it fourth version so it looks like a bug fix!
06:10:11 <tdammers> yeah, sure
06:10:20 <ivanm> Baughn_: right, so it can't get any worse! :p
06:10:20 <aristid> it has the trivial security model of having no security :P
06:10:22 <tdammers> those who use cabal won't notice anyway
06:10:47 <aristid> doesn't hackage 2 introduce the concept of maintainers?
06:10:47 <Baughn_> Furthermore, without a good security model, mirrors are impossible
06:10:54 <dcoutts_> aristid: yes
06:11:01 <aristid> so when we have maintainers we can add maintainer keys
06:11:03 <Baughn_> dcoutts_: Aren't those enforced by the server, though?
06:11:27 <dcoutts_> Baughn_: yes, only those in the package's maintainers group are allowed to upload
06:11:37 <Baughn_> dcoutts_: Right, so mirrors still won't work
06:11:57 <tdammers> something like debian's keyring system would be great
06:12:03 <tdammers> but then, debian is more centralized
06:12:16 <Baughn_> It shouldn't be that /hard/
06:12:16 <dcoutts_> Baughn_: right, there's no signing of the package collection, nor per-package
06:12:20 <kmels> @where hackage-mirror
06:12:20 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
06:12:22 <aristid> Baughn_: sign and hash all the things!
06:12:27 <tdammers> signing would solve the mirror problem
06:12:42 <Baughn_> I'd prefer maintainer keys, but if we're willing to trust the hackage server (I'm not!), we could have /that/ sign the packages for mirrors
06:12:55 <aristid> how about both?
06:12:56 <dcoutts_> we're not going to have compulsory individual package signing
06:12:57 <Baughn_> Still, it doesn't seem worth implementing that. Maintainer keys are easy.
06:13:02 <Baughn_> dcoutts_: Why not?
06:13:20 <dcoutts_> Baughn_: because it's too high a barrier for authors
06:13:29 <Baughn_> dcoutts_: gpg --sign is a high barrier?
06:13:33 <dcoutts_> yes
06:13:34 <Baughn_> It could be done by cabal upload, even
06:13:39 <aristid> dcoutts_: how likely is optional package signing? then baughn could install all his packages with --maintainer-signed-only
06:13:51 <Baughn_> If signing is optional, lots of people won't do it.
06:13:52 <dcoutts_> aristid: that on the other hand is quite possible
06:13:56 <Baughn_> And I won't install anything that's not signed.
06:14:01 <tdammers> Baughn_: yes, but maintainers would still have to have a key and link it to their hackage account
06:14:09 <Baughn_> So as far as I'm concerned, anyone who uploads unsigned packages might as well not have bothered
06:14:14 <aristid> Baughn_: but you would install server-signed packages?
06:14:22 <Baughn_> aristid: No thank you.
06:14:35 <dcoutts_> Baughn_: what we can have is server-side signing of the whole collection, which will make mirroring ok (and can be checked reasonably easily by the client)
06:14:36 <Baughn_> aristid: It's an improvement, but not really /enough/ of one.
06:14:36 <tdammers> personally, I think the signing should be included in cabal
06:14:52 <tdammers> optional, but with a setting that you could automatically refuse unsigned packages
06:14:53 <aristid> Baughn_: well then just email all the people to sign their stuffs :) i would even do it because i have a GPG key which i currently never use but i have it.
06:15:09 <dcoutts_> Baughn_: the other reason is that we cannot sensibly make all client to the gpg check, since we don't have gpg etc on windows
06:15:19 <mikeplus64> > succ ()
06:15:20 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
06:15:23 <tdammers> I'd sign my stuff if all it takes is pointing cabal to my key
06:15:24 <Baughn_> dcoutts_: So let's not use gpg. There are plenty of RSA libraries on hackage.
06:15:27 <mikeplus64> why on earth does () have an Enum instance
06:15:49 <aristid> Baughn_: i'd feel better if it used GPG.
06:16:05 <dcoutts_> mikeplus64: so you can use it in situations where an Enum constraint is needed
06:16:06 <tdammers> dcoutts_: if you make it optional through a setting, default to "no checking" on Windows and "mandatory checking" on *nix, everything's peachy
06:16:08 <aristid> mikeplus64: why on earth not?
06:16:16 <gdeest> hackage is down (again)...
06:16:24 <tdammers> gdeest: see /topic
06:16:26 <aristid> gdeest: i thought that was a "still"
06:16:48 <Baughn_> aristid: We can't have everything, I guess, but..
06:16:55 <mikeplus64> aristid: mone of the functions seem useful, or raise exceptions
06:16:57 <mikeplus64> > [()..]
06:16:58 <lambdabot>   [()]
06:16:59 <Baughn_> Maybe we can use GPG on linux, and some internal thing on windows?
06:17:04 <mikeplus64> none*
06:17:12 <Eduard_Munteanu> > minBound :: ()
06:17:13 <lambdabot>   ()
06:17:17 <Eduard_Munteanu> > maxBound :: ()
06:17:18 <lambdabot>   ()
06:17:37 <tdammers> doesn't anyone else think that it's odd how the language itself is elegant, robust, efficient, and very suitable to secure programming, but vital parts of the ecosystem are brittle and lack a security model?
06:17:47 <aristid> Baughn_: well i think OpenPGP is a standard
06:17:54 <dcoutts_> Baughn_, aristid: anyway the place to start is not individual signing, but securing the upload path and collective server side signing, then optional individual signing
06:18:01 <Eduard_Munteanu> > fromEnum ()
06:18:02 <lambdabot>   0
06:18:03 <aristid> dcoutts_: yes
06:18:08 <aristid> dcoutts_: but both are good things to have
06:18:26 <aristid> dcoutts_: i think limiting uploads to maintainer only is a good first step
06:18:40 <tdammers> dcoutts_: yeah. As long as the server can guarantee authentic uploads, and the downloading client can verify the server's identity, the easiest attacks are prevented
06:18:41 <aristid> dcoutts_: can a package have multiple maintainers?
06:18:56 <dcoutts_> Baughn_, aristid: and then if people can demonstrate that the individual signing and checking infrastructure is sufficiently reliable,easy,etc on all major platforms then we can think about making it more compulsory
06:19:00 <dcoutts_> aristid: yes
06:19:14 <dcoutts_> tdammers: right
06:19:37 <tdammers> I'm all for it.
06:20:16 <aristid> dcoutts_: i suppose you want no dependency on this on windows? http://gpg4win.org/
06:20:49 <mapreduce> For Java, the maven central repository requires GPG and the instructions for windows use gpg4win
06:21:02 <mapreduce> I've used it and it's painless.
06:21:09 <dcoutts_> aristid: it adds a lot of bother to the packaging etc to require it be bundled with all installs
06:22:50 <aristid> oh, does hackage 2 require packages to have a maintainer to accept uploads, or does it also still work in the traditional free for all mode?
06:24:16 <dcoutts_> aristid: you have to be in the uploaders group to be able to upload a new named package
06:24:37 <dcoutts_> aristid: at which point you become the only member of a new maintainer group for that package
06:24:48 <dcoutts_> and you can add other people to that maintainer group
06:25:18 <dmwit> How is the transition going to work? Who will be the maintainer for all the Hackage1 packages?
06:25:25 <dmwit> The last person who did an upload?
06:25:34 <dmwit> If so, I've got to take over the "encoding" package soon...
06:25:39 <dcoutts_> dmwit: the collection of people who ever uploaded
06:26:40 <aristid> dcoutts_: "new named package" means that existing packages are not affected by that rule? or do you mean for all new versions of any (existing or new) package?
06:27:36 <aristid> and i suppose if a maintainer orphans a package, somebody needs to email the hackage admins to take over maintainership?
06:27:58 <dcoutts_> aristid: it's very simple: every existing package name (ie all versions of that package) has a maintainer group. Only people in that group can upload new versions. For new names, you only need to be in the uploader group (at which point you become the only member of the new maintainer group for that package).
06:28:59 <aristid> "name" is a name-version combination? i think the terminology is confusing me.
06:29:17 <dcoutts_> aristid: no, name is name, "foo", not "foo-1.0"
06:29:50 <dcoutts_> aristid: transferring maintainership will usually work by the existing maintainer adding the new person to the group. In the rare cases where the maintainer is uncontactable then it'll require admin intervention to adjust the maintainer group
06:30:36 <aristid> oh, and existing packages have an automatically determined maintainer group by taking the set of previous uploaders?
06:30:41 <dcoutts_> yes
06:31:16 <aristid> and uploader group is the set of all people with hackage accounts?
06:32:03 <dcoutts_> aristid: right, currently the only people with hackage accounts are those who can upload. In future there can also be accounts for people who cannot upload.
06:32:52 <aristid> i see. well, that clears things up i think, thanks :)
06:36:51 <Yuu-chan> @src Maybe
06:36:51 <lambdabot> data Maybe a = Nothing | Just a
06:37:29 <Yuu-chan> @hoogle [(a, b)] -> ([a]. [b])
06:37:29 <lambdabot> Parse error:
06:37:29 <lambdabot>   [(a, b)] -> ([a]. [b])
06:37:29 <lambdabot>                   ^
06:37:35 <Yuu-chan> @hoogle [(a, b)] -> ([a], [b])
06:37:35 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
06:37:35 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
06:37:50 <Yuu-chan> @pl \x y z -> x z y
06:37:50 <lambdabot> flip
06:38:19 <Yuu-chan> Don't mind, I'm introducing newbies to Haskell :)
06:46:49 <joe9>  what is the function to do this: (f :: a -> b -> c) -> [a] -> [b], where f needs to be applied on (a1, b1), (a1, b2) .. (a1, bn)... (a2, b1) ... (a2, bn) .. etc.
06:47:17 <joe9> it should be (f :: a -> b -> c) -> [a] -> [b] -> [c]
06:47:23 <fmap> :t zipWith
06:47:23 <plat0> Can there be more than one Functor instance for any given type constructor?  Or is it a "theorem for free" that there is at most one?
06:47:24 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
06:47:25 <joe9> any suggestions, please?
06:47:35 <joe9> fmap:  thanks.
06:47:45 <Jeanne-Kamikaze> no not zipWith
06:47:55 <joe9> fmap: but, zipWith is (a1, b1) (a2,b2) etc
06:48:05 <joe9> not (a1, b1), (a1, b2) ..
06:48:11 <fmap> oh, yes
06:48:16 <Jeanne-Kamikaze> I think the list monad does that
06:49:32 <Jeanne-Kamikaze> foo f xs ys = do x <- xs; y <- ys; return $ f x y
06:49:48 <Jeanne-Kamikaze> joe9: ^
06:50:39 <LordBrain> or a comprehension
06:51:14 <LordBrain> [ f x y | x <- xs, y <- ys]
06:51:27 <Jeanne-Kamikaze> yeah
06:53:18 <joe9> LordBrain: that is still zipWith, isn't it?
06:53:50 <joe9> what i am looking for is a 2 dimensional for-loop
06:54:17 <Jeanne-Kamikaze> no that's not zipWith
06:54:27 <Jeanne-Kamikaze> zipWith applies f to ai bi
06:54:50 <joe9>  [ map (f x) y | y <- ys]
06:54:57 <joe9> probably, what I looking for.
06:55:07 <joe9>  [ map (f x) ys | x <- xs]
06:55:08 <LordBrain> doing the monad approach or the list comprehension approach will result in a sort of product operation
06:55:24 <joe9> LordBrain: oh, ok. thanks.
06:55:24 <LordBrain> you get every combination
06:55:46 <joe9> LordBrain: is there a function to do that?
06:56:11 <ksf> @seen roconnor
06:56:11 <lambdabot> Unknown command, try @list
06:56:13 <LordBrain> in the prelude?
06:56:17 <ksf> preflex, seen roconnor
06:56:17 <preflex>  roconnor was last seen on #haskell 7 hours, 43 minutes and 8 seconds ago, saying: I'll sleep on it some more
06:56:31 <dolio> plat0: The latter.
06:56:46 <LordBrain> i dont think so, not that specifically,
06:56:56 <LordBrain> you could write one easily enough
06:57:08 <joe9> > sequence  [[1,2,3],[4,5,6]]
06:57:09 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
06:57:26 <joe9> http://stackoverflow.com/questions/4119730/cartesian-product -- found it here.
06:57:47 <Jeanne-Kamikaze> you can also do applicatives
06:57:51 <LordBrain> oh i thought you meant with the function application
06:57:55 <Jeanne-Kamikaze> foo f xs ys = f <$> xs <*> ys
06:58:52 <ksf> preflex, seen ekmett
06:58:52 <preflex>  ekmett was last seen on #haskell-blah 160 days, 13 hours, 42 minutes and 53 seconds ago, saying: * ekmett waves hello
06:58:56 <ksf> ouch
06:59:38 <LordBrain> map f xs `ap` ys
06:59:52 <dmwit> preflex: seend edwardk
06:59:53 <LordBrain> lots of ways to do it
06:59:57 <dmwit> preflex: seen edwardk
06:59:57 <preflex>  edwardk was last seen on #haskell 5 hours and 5 minutes ago, saying: @tell roconnor i was able to switch over to the new Bazaar. its much faster than the old one now
06:59:59 <ksf> the problem with lens is that it doesn't track uninitialised fields.
07:00:09 <joe9> LordBrain: ok, thanks.
07:00:12 <LordBrain> ap from Control.Monad
07:03:48 <hpaste> ksf pasted ‚Äúinitialisation-safe lens‚Äù at http://hpaste.org/73729
07:04:11 <ksf> does anyone have an idea how to expand that for sum types?
07:04:38 <ksf> that is, have insXXX that accept any of the types in line 29, packing them into Eithers.
07:06:12 <ksf> oh, and line 46 should have Foo instead of an explicit list in the argument to the first Foo_T
07:07:59 <grault> hey
07:08:12 <joe9> is there a better way of writing this code: http://codepad.org/gRaysP2t
07:08:45 <ksf> that's not valid haskell
07:08:51 <LordBrain> i guess you could consider liftM2 to do it
07:09:08 <LordBrain> is that in the prelude?
07:09:17 <joe9> ksf, yes, not yet.
07:09:31 <Guest20996> ok, so probably many people already asked, but what's up with hackage, it seems to be down or something
07:10:05 <ksf> it's down.
07:10:14 <Guest20996> any ETA?
07:10:26 <ksf> monday. when people are at work, again.
07:10:30 <ksf> @where hackage-mirror
07:10:30 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
07:10:41 <ksf> you can put that into your ~/cabal/config
07:10:48 <ksf> ~/.cabal/config
07:11:05 <Guest20996> cool, thanks ksf
07:13:30 <LordBrain> joe9 you mean asside from apparently missing characters, like :: for type signatures and you need an = on the definition of nexts
07:13:55 <joe9> nexts cur incr max = takeWhile (< max) [cur, (cur + incr) .. ] ++ [max]
07:13:56 <joe9> t
07:14:04 <joe9> sorry, wrong paste.
07:14:15 <joe9>  http://codepad.org/9CsAj19i
07:16:22 <LordBrain> until (>max) (+increment) current
07:17:14 <LordBrain> that's for you joe9
07:17:21 <LordBrain> until is a prelude function
07:17:29 <joe9> LordBrain: cool, thanks.
07:18:24 <joe9> LordBrain: i am looking for the list as the output.
07:18:30 <joe9> not a fold operation.
07:18:57 <joe9> > (takeWhile (< 10) [1,3 ..]) ++ [10]
07:19:00 <lambdabot>   [1,3,5,7,9,10]
07:19:25 <joe9> > until (> 10) (+10) 1
07:19:27 <lambdabot>   11
07:20:03 <joe9> LordBrain: i think the solution I have is reasonable. do not bother with any more brain cycles on it. thanks for your help.
07:27:55 <Peaker> I know the Curry Howard correspondence, what's the third element in the "trinity" that Harper keeps on talking about?
07:28:17 <hpc> Peaker: what are the first two elements?
07:28:59 <Peaker> Types/Values : Propositions/Proofs
07:29:11 <Peaker> Programming : Logic
07:29:17 <Peaker> but there's supposed to be a third one
07:29:44 <latro`a> are you sure the first one isn't supposed to be two?
07:30:16 <plat0> Is there a standard name for this: \k -> fmap k . return
07:30:36 <Peaker> @type \k -> fmap k . return
07:30:37 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => (a -> b) -> a -> f b
07:30:58 <Peaker> @type \k -> return . k
07:30:59 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
07:31:10 <hpc> @hoogle (a -> b) -> a -> f b
07:31:10 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:31:11 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
07:31:11 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
07:31:15 <Peaker> damn Caleskell :(
07:31:41 <Peaker> plat0, \k -> return . k :: Monad m => (a -> b) -> a -> m b   <-- slightly simpler
07:32:07 <LordBrain> lol
07:32:11 <Peaker> plat0, nothing special for applying "return" or "pure" on the result of a function
07:32:31 <Peaker> (pure .)  <-- doesn't deserve its own name :)
07:32:50 <plat0> Fair enough :)
07:33:53 <Peaker> "As ever, enduring principles emerge from the interplay between proof theory, category theory, and type theory" <-- I guess category theory is supposed to be the third one
07:33:57 <LordBrain> the applicative paper had a special bracket thing
07:34:02 <LordBrain> if i recall
07:34:31 <LordBrain> hmm
07:34:38 <LordBrain> that would be for ap not return tho
07:34:45 <geekosaur> idiom brackets [| ... |]
07:36:13 <Peaker> I don't understand why it was named "idiom"
07:44:06 <raek> is hackage down?
07:44:27 <bartavelle> as hackage seems down, does anyone know of a thing that works like System.Random but that is significantly faster ?
07:44:44 <bartavelle> doesn't need to be cryptographically random
07:45:16 <bartavelle> just with statistically "flat" distribution
07:45:31 <execc_13> @type ($)
07:45:32 <lambdabot> forall a b. (a -> b) -> a -> b
07:46:14 <jfischoff> bartavelle: so fair enumeration?
07:46:28 <dmwit> Do you need to use split?
07:46:28 * jfischoff was just reading monad reader 
07:46:36 <byorgey> Peaker: because it corresponds to doing function application in some "idiomatic" way, i.e. in the context of some sort of effects.
07:46:39 <dmwit> If not, then there's a few choices, mwc-random and friends.
07:46:58 <dmwit> Not that that helps much while Hackage is down. =P
07:47:36 <bartavelle> ok, I also need subsequent outputs to be somehow unrelated
07:47:43 <bartavelle> I will just write my own
07:55:06 <latro`a> is system.random really all that slow?
07:56:54 <merijn> latro`a: Presumably it uses /dev/urandom or /dev/random. In which case, yes, it will be slow
07:57:32 <merijn> Reading from /dev/unrandom can block you for an indeterminate amount of time, for example
07:57:49 <latro`a> OK, but what if you use Rand
07:58:04 <latro`a> with only one check from dev/urandom
07:58:14 <sully> /dev/random blocks, /dev/urandom doesn't
07:58:16 <merijn> latro`a: The difference is that Rand is semi-rando/pseudo-random
07:58:18 <timthelion> deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a] -- Am I correct that it is a bug in base that this type isn't :: (a -> b -> Bool) -> [a] -> [b] -> [a] ???
07:58:30 <latro`a> true, but wouldn't that be sufficient for bartavelle's case?
07:58:46 <merijn> latro`a: I missed his code, it might be
07:58:58 <merijn> latro`a: For most applications where security is not an issue Rand is fine
07:58:59 <latro`a> he said "doesn't need to be cryptographically random"
07:59:00 <latro`a> seems fine
07:59:12 <merijn> Oh, yeah. In that case just use Rand
07:59:15 * timthelion wonders how many people actually have an external random number generator attached to their computer.
07:59:43 <merijn> timthelion: Just use the quantumrandom bit generator API?
07:59:45 <merijn> :p
07:59:46 <latro`a> lol
08:00:11 <statusfailed> Hackage is down?
08:00:31 <merijn> timthelion: They have (I think) 7.9something bits of entropy per byte
08:00:40 <adimit> @where hackage-mirror
08:00:40 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
08:00:45 <statusfailed> cheers :P
08:01:05 <statusfailed> oh, i'm just looking for docs
08:01:08 <merijn> 7.9979 bits of entropy per byte, apparently
08:01:22 <nus> timthelion, there's always one between keyboard and chair (-:
08:01:42 <latro`a> that is surprisingly false
08:01:44 <SLi> Humans are notoriously bad at being random.
08:01:51 <timthelion> merijn: There is actually a driver somewhere for plugging an antena into /dev/random.  can't find it right now though.
08:01:56 <applicative> bartavelle: https://github.com/bos/mwc-random for example
08:01:57 <latro`a> you would expect we'd be pretty damn good at it, but we are not
08:02:12 <SLi> Although measuring precise timings for key presses etc. provides quite good randomness, as long as you don't overestimate the entropy it provides.
08:02:16 <applicative> oh I didn't know you could get cabal to use hdiff.luite.com
08:02:29 <nus> latro`a, just throw dice
08:02:40 <statusfailed> Surely human randomness follows a distribution?
08:02:43 <latro`a> do you have 2^32 sided dice?
08:02:44 <adimit> statusfailed: you're out of luck, afaik. Try google cache. or, next time, switch on the option to compile with docs in your ~/.cabal/config
08:03:01 <statusfailed> adimit: cheers. Cache it is :)
08:03:02 <timthelion> nus: you realize, that there is a very high chance that a user when asked to type in 128 "random" bytes will type multiple instances of the string "asdf"?
08:03:13 <latro`a> I suppose you could throw log_20(2^32) d20
08:03:43 <latro`a> which is about 8
08:03:53 <latro`a> that's not too bad
08:03:59 <SLi> Of course that can be applied to any human random source. If you ask a human to provide ten random 8-bit integers, assuming good faith I think it would be safe to assume you have as a result 8 good bits of entropy, but not safe to assume that you have 72 bits.
08:04:06 <bartavelle> latro`a, /dev/urandom would be sufficient, but reading a char device that will run stuff in kernel land is way too slow for my usage
08:04:40 <bartavelle> I just wrote a linear congruential generator
08:04:42 <latro`a> what does the global stdgen reference anyways
08:04:49 <SLi> bartavelle, a would a cryptographically secure RNG be good enough?
08:04:55 <latro`a> (if you haven't set it yourself)
08:05:19 <latro`a> anyway, bartavelle
08:05:23 <tommd> merijn: System.Random does not user urandom, it is a pure PRNG
08:05:23 <bartavelle> SLi, I just need it to do statistical sampling, I do not have crytographic requirements
08:05:26 <latro`a> use Rand with a seed from IO
08:05:34 <latro`a> tommd--no
08:05:40 <tommd> Yes
08:05:42 <latro`a> there's IO and there's threading generators
08:05:46 <latro`a> both are in system.random
08:05:49 <SLi> bartavelle, ah, ok.
08:06:05 <dmwit> All randomness (human or otherwise) follows a distribution.
08:06:05 <tommd> Those are available but the core (StdGen) is just two integers that get mixed.
08:06:20 <dmwit> I also suggested mwc-random a while ago and bartavelle rejected it silently.
08:06:23 <timthelion> latro`a: you realize, that seeded randomness is only as random as the number of bits of the seed?  So if you seed a 128bit key with 32 bits you can't get anything stronger than a 32 bit key...
08:06:30 <latro`a> true
08:06:43 <bartavelle> dmwit, I haven't looked at it, sorry, I already implemented my LCG when I saw your answer
08:07:11 <latro`a> but again, timthelion, we're not talking about cryptography
08:07:15 <dmwit> You implemented an LCG in the two minutes between question and answer?
08:07:18 <dmwit> That's darn impressive.
08:07:20 <tommd> There is a really fast mwc package (or two), the StdGen is rather slow, and urandom is actually much faster than many people think.
08:07:25 <bartavelle> it's just y = a*x+b
08:07:52 <dmwit> anyway
08:08:04 <SLi> bartavelle, but a reasonably good solution ever for crypto and faster than urandom solution would be to read a 128-bit integer x from /dev/urandom, and then use it in counter mode so that you get a stream of 128-bit random integers by (map AES [x, x+1, x+2...]), always encrypting with the same key.
08:08:11 <bartavelle> dmwit, full source http://hpaste.org/73734 :)
08:08:28 <SLi> Certainly good enough for statistic purposes, if it's fast enough :)
08:08:44 <bartavelle> yes it would be fine for most usages I recon
08:08:56 * timthelion thinks that there is a use for a lazy IO clock in the random number generation world of haskell.  Imagine the lazy list IO [PicoseccondsSinceStart]
08:09:07 <dmwit> bartavelle: Well, I'm impressed. Maybe an expert wouldn't be. =)
08:09:24 <hpc> timthelion: it's not really random though, just nondeterministic
08:09:27 <SLi> LCGs are surprisingly good (with correct parameters). Not for crypto, but for other purposes.
08:09:42 <hpc> it's roughly analogous to seeding your PRNG with the current time before every sample
08:10:14 <timthelion> Could we make a lazy IO list for /dev/rand?
08:10:44 <latro`a> getRandoms and getRandomRs for MonadRandom IO should be that
08:10:55 <SLi> In that they are very fast, don't have too much discernable pattern (but are not cryptographically secure) and with right parameters they can be proven to traverse the entire 2^statebits (in some cases -1) space.
08:11:02 <dmwit> timthelion: Is this not essentially what randomRIOs is?
08:11:13 <latro`a> ^or that, derp
08:11:19 * timthelion realizes that he came here 15 minutes ago with a question about a bug in base and still hasn't gotten an answer.
08:11:22 <tommd> timthelion: That is exactly what crypto-api does
08:11:45 <sully> timthelion: hackage being down probably hasn't helped :P
08:12:11 <timthelion> sully: I noticed that.  It wasn't down when I asked...  But it was down by the time I pressed "show source" :/
08:12:24 <tommd> timthelion et al: If you want to stream urandom then use Cypto.Random's SystemRandom generator.
08:13:02 <raek> is there an easy way to test all properties in a file whose name begin with "prop_" with quickcheck?
08:13:03 <applicative> timthelion: how could an IO () be called Pruhlednik with a capital
08:13:33 <tommd> raek: yes, there is TH to do that.  Google should show you the light.
08:13:40 <latro`a> timthelion, looks like you're right, and that in particular the error is in deleteBy's type
08:14:05 <timthelion> applicative: Wow, responding to a comment I made this morning :)  It doesn't want a function name, but a Module name.  The help text is wrong.
08:14:25 <timthelion> latro`a: OK, do bugs get sent to ghc trac for base, or where?
08:14:40 <latro`a> you would probably know better than I
08:15:00 <timthelion> applicative: perhaps I should report that documentation bug as well.  I had noticed it, but it didn't really bug me.
08:15:04 <applicative> timthelion: oh, sorry, I was looking in history for your 'bug in base'
08:15:14 <latro`a> then again I'm not sure why deleteBy even exists in that form
08:15:21 <timthelion> latro`a: why?
08:15:26 <latro`a> that is why it isn't just (a->Bool) -> [a] -> [a]
08:15:46 <timthelion> latro`a: then it would be filter
08:15:57 <latro`a> doesn't it only delete once?
08:16:04 <latro`a> if so, no it's not filter
08:16:45 <latro`a> indeed, it's not filter
08:16:55 <latro`a> filter recurses whether the predicate is satisfied or not
08:16:56 <timthelion> latro`a: anyways, I was looking at deleteFirstsBy...
08:17:02 <latro`a> irrelevant
08:17:11 <latro`a> because deleteFirstsBy calls deleteBy
08:17:32 <timthelion> OK, well it's all wrong then :D
08:18:32 <latro`a> also
08:18:39 <latro`a> deleteFirstsBy calls regular foldl
08:18:40 <latro`a> :(
08:19:15 <SLi> Or you could do RNG like bash (the shell) does it. Use a theoretically good (IIRC) 32-bit RNG, but always return only the lowest 15 bits, and to "improve randomness" throw away all 15-bit numbers that are the same as the previous one returned!
08:19:45 <SLi> Reading that code caused me to cringe.
08:19:50 <sully> that is really awful.
08:20:09 <latro`a> why would you throw out bits
08:20:10 <latro`a> I don't
08:20:14 <latro`a> what
08:20:26 <applicative> bartavelle: I take it  you noticed https://github.com/bos/statistics which integrates mwc-random
08:20:30 <latro`a> the "improve randomness" thing is at least understandable even if blatantly wrong
08:20:55 <SLi> Plus it actually works a bit weirdly on 64-bit platforms because the LCG used assumes that long is 32 bits wide.
08:21:43 <SLi> But it still has the same cycle length, that just took a while to figure out :)
08:22:52 <latro`a> again though timthelion there's no reason for deleteBy to be two parameter
08:23:14 <applicative> SLi: what code caused you to cringe?  I guess it wasnt haskell...
08:23:26 <latro`a> delete' x xs = deleteBy' (==x) xs
08:23:26 <bartavelle> applicative, I only briefly glanced at this
08:23:37 <latro`a> eh, eta reduce that >.>
08:23:44 <SLi> In all honesty, I think that code may have been written in the 80s, when even a fairly good hacker would not necessarily have understood random numbers but in an ad hoc way.
08:24:30 <SLi> applicative, the random number generator in the bash shell's source... It's C, and I think the code in question might be from the 80s.
08:24:33 <ParahSailin_> maybe it was a special application
08:24:45 <applicative> SLi, ah I see
08:25:12 <applicative> my preferred RNG is the one on hackage that uses the atmosphere...
08:26:05 <applicative> of course if you want a new seed you have to use http etc
08:26:55 <SLi> Certainly not something you would use for crypto then :)
08:27:06 <applicative> SLi: hah, no
08:27:57 <applicative> bartavelle: Its used in criterion, for example; I  just mention it in the belief that whatever bos is up to is state of the art, but its probably not the kind of art you need
08:28:18 <bartavelle> yeah I don't even know what is the distribution of the thing I am sampling
08:28:50 <bartavelle> not even sure what I am doing has a meaning :/
08:29:36 <statusfailed> I can't find the functions "getM, setM, and modM" described in this comment: http://blog.ezyang.com/2010/04/inessential-guide-to-fclabels/comment-page-1/#comment-363
08:29:43 <statusfailed> anybody know where they are?
08:29:44 <SLi> Also not for anything where it would be security or safety critical that it actually is random :)
08:31:58 <thirsteh> is it safe to hPutStrLn and hGetLine concurrently on a network conn so long as only one thread is doing either?
08:32:12 <thirsteh> or perhaps it's safe anyway?
08:32:39 <hpc> thirsteh: i believe so, yeah
08:32:44 <thirsteh> awesome
08:32:48 <geekosaur> read and write on a socket are independent, on POSIXish systems at least
08:32:58 <hpc> i expect any issues you would see will come up right away
08:33:08 <thirsteh> yeah
08:33:11 <hpc> so long as there's no funky data dependencies in your code, it will work fine
08:34:28 <statusfailed> oh my god how can you function without hackage documentation ;_;
08:34:40 <hpc> statusfailed: very good memory ;)
08:34:50 <statusfailed> hahah
08:34:54 <thirsteh> "cached:" behind the URL
08:34:55 <thirsteh> :)
08:35:08 <statusfailed> is that browser cache?
08:35:15 <thirsteh> Google cache, if you're using Chrome
08:35:21 <statusfailed> ooh, funky
08:35:22 <statusfailed> I am
08:35:34 <statusfailed> Google cache seems to take a good minute or so to load for me
08:35:34 <statusfailed> sad
08:35:45 <hpc> if you use duckduckgo, !cache hackage.haskell.org
08:36:02 <statusfailed> I may switch, I know they have !hackage as well
08:36:04 <thirsteh> or if you're desparate, archive.org
08:36:06 <statusfailed> and !hoogle, right?
08:36:07 <statusfailed> haha
08:36:17 <hpc> they have !hoogle and !hayoo
08:36:32 <hpc> and i added the red box at the top of "hayoo blahblah" searches
08:36:43 <hpc> https://duckduckgo.com/?q=hayoo+runParse
08:36:52 <applicative> statusfailed: https://github.com/sebastiaanvisser/fclabels/blob/86fa82d4237dc9cbd787dac82b899bbb36a89304/src/Data/Record/Label.hs
08:37:55 <end3rW> When designing own data types, what's the most convient way to handle field access? I heard about lenses, anyone got some overview about the benefits of certain methods?
08:38:08 <statusfailed> applicative: I think they've moved, the cache for 1.04 says they're at Data.Label.PureM now
08:38:08 <applicative> statusfailed: anyway, of course everyone's using edwark's Control.Lens these days, no?
08:38:14 <statusfailed> applicative: .... they are!?
08:38:21 <statusfailed> man, i _do_ want to be fashionable...
08:38:32 <applicative> statusfailed: ah
08:38:34 <hpc> end3rW: records are the "old" way of doing it
08:38:34 <ion> end3rw: The lens package.
08:38:41 <hpc> i haven't used lenses enough to judge how well they work
08:38:45 <statusfailed> which funnily enough happens to be what we're talking about :D
08:39:11 <statusfailed> applicative: Advantages of Control.Lens?
08:40:26 <ion> Its design is elegant and you can compose lenses with plain (.)
08:40:29 <applicative> No special lens type, the ambient category is ->
08:40:45 <statusfailed> what does ambient category mean?
08:40:54 <applicative> statusfailed: the one in which you work.
08:41:24 <applicative> there is no special type and no special category, and no special id and (.)
08:41:31 <statusfailed> surely the ambient category is then not concrete?
08:41:39 <statusfailed> i'm confused
08:41:55 <thirsteh> <3 STM: http://hpaste.org/73738
08:41:55 <applicative> it isn't a technical expression
08:42:02 <aristid> statusfailed: lenses are just polymorphic functions
08:42:18 <statusfailed> so I can use a lens bi-directionally with Control.Lens ?
08:42:39 <applicative> statusfailed: you mean bidirectional the way any lens is?
08:42:50 <statusfailed> I only know about fclabels
08:42:52 <statusfailed> quite possibly?
08:43:00 <statusfailed> :)
08:43:24 <statusfailed> oh, Snap uses Control.Lens
08:43:30 <ion> Oh, snap!
08:43:32 <statusfailed> I recognise the makeLenses ''Foo
08:43:36 <statusfailed> >_>
08:43:44 <applicative> yeah, like they use an  olde fashioned iteratee lib
08:44:14 <statusfailed> do you work on Yesod? :P
08:44:31 <applicative> statusfailed: kidding of course
08:44:34 <statusfailed> hehe
08:45:10 <applicative> https://github.com/ekmett/lens I was just pointing out it is new, and edwardk should be praised for an unusual labor of documentation.
08:45:17 <statusfailed> So what's the Control.Lens equivalent of fclabels' getM/setM ?
08:46:34 <applicative> in a state monad  you modify thuspaddle1 %= clamp (paddleHeight/2
08:46:53 <applicative> increment thus  paddle1 += paddleMovement
08:47:42 <bartavelle> probably stupid question : let's say I have this huge HashMap that took forever to compute. I "show" it into a file, and use "read" to read it again. Problem is, the map is large and it takes forever too. Is there a faster general purpose serializer ?
08:48:30 <timthelion> So I'm trying to build my program with profiling.  It first tells me it needs JuicyPixels to be built with profiling.  Then it tells me it needs cereal to be built with profiling.  Then that tells me it needs vector to be built with profiling.  vector tells me that darcs and vty will have to be reinstalled.  Seems this is endless! :(
08:48:56 <applicative> lens .= value   sets the field of the state associated with the lens
08:49:07 <daniel_-> i wish there would be something like readthedocs.org for haskell and not just haddock API docs
08:49:09 <timthelion> tell me guys.  Is there hope?
08:49:17 <ion> bartavelle: cereal probably has one for Data.Map.
08:49:38 <statusfailed> applicative: Ah, so .= is the direct equivalent of fclabels' =:
08:49:43 <ion> Oh, HashMap. Perhaps it has one for that, too. You‚Äôll need to look at the docs.
08:49:50 <statusfailed> ion: TOO BAD :D
08:49:57 <bartavelle> :)
08:50:03 <roconnor> timthelion: AFAIU everything needs to be built with profiling
08:50:04 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
08:50:09 <applicative> statusfailed: anyway, check it out, edwardk can talk you into using it here.
08:50:33 <applicative> statusfailed: or maybe roconnor can tell you why Control.Lens is better than fclabels  :)
08:50:37 <statusfailed> applicative: I swear, he's indirectly rewritten most of the code I write just via advice :D
08:50:46 <roconnor> @ask edwardk how did you make Bazaar faster.
08:50:46 <lambdabot> Consider it noted.
08:50:51 <hpc> hah
08:50:52 <timthelion> roconnor: so is my best bet to delete ~/.cabal and reinstall everything with -p?
08:51:11 <roconnor> timthelion: that I don't know.  Maybe cabal-dev would be good?
08:51:22 <timthelion> perhaps
08:51:26 <applicative> timthelion: thats what i do, crudely put.  you can put 'compile profiling' in your ~/.cabal/config
08:51:42 <applicative> of course compile times all double :(
08:51:43 <roconnor> statusfailed: Control.Lens is vastly more general and built upon a sound theoretical basis.
08:51:44 <statusfailed> applicative: Thanks for the advice btw, it's hard to choose from all the options :D
08:52:05 <timthelion> applicative: but I need to profile my programs...  So I have no choice...
08:52:06 <statusfailed> roconnor: I'm pretty sold :)
08:52:16 <statusfailed> now how do I add mirrors with cabal....
08:52:29 <roconnor> statusfailed: it lets traversals and lenses and others compose automatically
08:52:35 <roconnor> statusfailed: ah
08:52:37 <roconnor> :)
08:52:42 <statusfailed> Not sure what a traversal is :D
08:52:46 <applicative> timthelion: yeah i just have it in my config file and forget about the shock that came the first day I did it :)
08:53:43 <roconnor> statusfailed: it is like a lens that referes to multiple locations.
08:54:00 <roconnor> statusfailed: every Traversable is a canonical traversal
08:54:03 <statusfailed> roconnor: Could those locations be in different records?
08:54:19 <roconnor> the references are all within a single type
08:56:00 <applicative> roconnor: well there is the class nonsense for tuples _1 _2 _3
08:56:14 <roconnor> right
08:56:29 <statusfailed> Ah, so is there a class for "things that have a _1"?
08:56:43 <applicative> yeah
08:56:55 <roconnor> statusfailed: so bytes :: Traversal ByteString Word8  is a traversal that references each Word8 element of a ByteString
08:57:01 <statusfailed> I was wondering how you might do 'single lens for many types', and that's the only way I could think of
08:57:10 <roconnor> the references in a traversal are ordered
08:57:10 <statusfailed> roconnor: oh, I get you
08:57:20 <statusfailed> oh, so it's essentially a lens onto a sequence...?
08:57:26 <applicative> i think i discovered yesterday that _2 works for things that dont have a second position...
08:57:27 <statusfailed> it refers to all the items, not just one
08:57:30 <roconnor> statusfailed: that's a resonable way of looking at it
08:57:47 <statusfailed> Cool :)
08:57:52 <statusfailed> applicative: wat
08:58:00 <atriq> A good thing to see just as I join the channel
08:58:00 <roconnor> statusfailed: so for a traversable functor you get an (order) sequence of references to the values in the container
08:58:13 <applicative> statusfailed: not sure, I am still figuring it out
08:58:35 <statusfailed> roconnor: by references, do we mean "lenses" or something else?
08:58:53 <jmcarthur> not sure why i found this so neat, but...    const = curry fst
08:59:13 <applicative> @type curry  fst
08:59:14 <roconnor> statusfailed: lets say that lenses are a way of realizing function references.
08:59:14 <lambdabot> forall a b. a -> b -> a
08:59:34 <applicative> @type uncurry id
08:59:35 <lambdabot> forall b c. (b -> c, b) -> c
08:59:39 <roconnor> statusfailed: so they can be used interchangebly when speaking informally
08:59:41 <applicative> oops
09:00:27 <statusfailed> roconnor: ok, making sense :)
09:02:18 <applicative> do the other lens libs have polymorphic setting like   _2 .~ "hello" $ (1,())
09:02:24 <Phil> cabal update returns "cabal: failed" Not a very useful error message. Any idea what might cause this?
09:02:45 <applicative> Phil: hackage is down
09:03:00 <Phil> applicative: Oh, balls. Thanks
09:03:02 <applicative> Phil is it something likely  to have tons of dependencies
09:03:43 <Phil> applicative: SOEGraphics; graphics package for the Haskell School of Expression. Not sure of the dependencies. Will have a look. Can presumably download it directly from somewhere
09:03:57 <applicative> Phil in any  case the expedient  of swapping out the line from .cabal/config to use remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/ is said to work
09:04:01 <bgamari> bah, hackage is down again
09:04:14 <applicative> Phil, oh SOE might be trouble.
09:04:47 <roconnor> say you have a Map k1 (Map k2 Int) and you want to increment the value held at (x, y) if it exists and return Nothing if it doesn't.
09:05:08 <applicative> Phil, but only because if I remember its trouble to install even on the best of days; but this is an old memory
09:05:35 <Phil> applicative: Ah, shame. Haven't actually read the relevant chapter yet. Maybe I can get by using some other package
09:06:23 <bartavelle> roconnor, you could "let q1 = Map.lookup k1 mp" and then "case (q1, Map.lookup k2 q1) of"
09:06:59 <bartavelle> and you have (Just _, Just v)  and (Nothing, _) matches
09:07:18 <bartavelle> the second lookup shouldn't be evaluated if the first one isn't Just something
09:07:54 <bartavelle> there is probably a better way to do this in the maybe monad
09:07:59 <applicative> Phil: do you have the deps for it from that cabal file here? http://hdiff.luite.com/cgit/soegtk/tree/
09:08:35 <Phil> applicative: looks like I can't connect to that server
09:08:56 <roconnor> let ref = at x . traverse . at y . traverse in do { guard . not . nullOf $ ref map; return (ref +~ 1 $ map)}
09:09:32 <applicative> Phil oh http://hdiff.luite.com/packages/archive/ has all the tarballs.  I think the server is under a little pressure at the moment
09:09:42 <roconnor> let's walk through this a bit
09:10:07 <Ornedan> How do I get access to the messages logged from the GHC runtime via debugTrace?
09:10:10 <Phil> Thanks applicative
09:10:37 <roconnor> at x -- this gives you a (Lens (Map k v) (Maybe v)) when x :: k
09:10:58 <roconnor> it is a lens that refers to the map location at x
09:11:19 <aristid> roconnor: and it can insert or delete elements, too?
09:11:39 <roconnor> it is a (Maybe v) because the value might not be in the Map.  The lens lets you insert and delete by chaging the referenced location to Just or Nothing.
09:12:09 <roconnor> next traverse :: Travsersal (Maybe v) v
09:12:30 <roconnor> this gives a partial lens pointing to the value held my a maybe, if it exists.
09:12:55 <roconnor> updating a reference that doesn't will do nothing.
09:13:22 <applicative> thats the surprise I found with _2 yesterday
09:13:46 <applicative> I updated what didnt exist, where I might have hoped for a type error
09:14:10 <applicative> but thats another matter to do with the tuple classes
09:14:17 <roconnor> let ref = at x . traverse . at y . traverse -- this compose all of our elements together.  at x gives us a reference into the map from our first coordinate, traverse gives us access to the value held by the maybe (if it exists). at y gives us a references to the second coordinate, and again traverse accesses the Maybe's value if it exists.
09:14:49 <roconnor> all in all ref :: Travesal (Map k1 (Map k2 v)) v
09:15:04 <roconnor> now the body of the code:  do { guard . not . nullOf $ ref map; return (ref +~ 1 $ map)}
09:15:16 <roconnor> the intension is to operate in the Maybe monad.
09:15:23 <timthelion> anyone know how big hackage is in gigabytes?
09:15:46 <hpc> not large
09:15:47 <roconnor> the first command (guard . not . nullOf $ ref map) which now I see I miswrote
09:15:50 <hpc> not even a gig
09:15:59 <roconnor> should be (guard . not $ nullOf ref map)
09:16:03 <timthelion> hpc: I could totally provide mirror hosting then...
09:16:16 <timthelion> hpc: I have a 45Gb VPS without limits.
09:16:16 <hpc> there's already a few mirrors
09:16:44 <roconnor> (nullOf ref map) checks to see if the travesal ref is pointing to anything in map or not.
09:16:51 <k0ral> is hackage down ?
09:16:59 <statusfailed> k0ral: yup
09:17:17 <timthelion> k0ral: It seems to be as down as much as it is up!
09:17:37 <roconnor> so the (guard . not $ nullOf ref map) will fail with Nothing if the ref for map isn't refering to anything; i.e. if either of the two keys were not in their respective maps.
09:18:06 <timthelion> hpc: if that's the case, then they(who are they anyways) should link a routing server to the hackage URL, and then pass on the requests to whichever mirror happens to be up at a given time...
09:18:10 <roconnor> return (ref +~ 1 $ map) yeilds our updated map
09:18:57 <roconnor> ref +~ 1 produces a map-updating function that increments by 1 all the values referenced by ref.
09:19:02 <roconnor> we apply that to map
09:19:08 <roconnor> and return the resulting map.
09:19:18 <belgin> When we do "data Either a b = Left a | Right b", what is Either called?
09:19:24 <roconnor> so there you go. No crazy nested case statements.
09:19:41 <roconnor> just straightforward imperitive code.
09:19:48 <Eduard_Munteanu> belgin: an algebraic data type?
09:19:51 <applicative> Either is called a type constructor, Left Right data constructors
09:20:03 <applicative> but the jargon is fluid
09:20:16 <davidsd> Is there a simple way to define an Ord instance for a TChan?
09:20:22 <k0ral> timthelion: I was supposed to understand "it's up now" ?
09:20:26 <hpc> you can also say Either is a sum type
09:20:36 <timthelion> k0ral: ?
09:20:46 <applicative> belgin: or if you mean what is Either itself, they type, we can respond with a kind signature
09:21:04 <applicative> Either ::  * -> * -> *
09:21:37 <applicative> belgin: it  is emerging that we need a few more questions from you to answer well
09:21:38 <statusfailed> IT'S UP
09:21:40 <k0ral> timthelion: nevermind
09:21:42 <statusfailed> THANK THE MAKER
09:22:05 <timthelion> statusfailed: everyone, lets log on at once and crash it again!
09:22:19 <statusfailed> :D
09:22:23 <k0ral> who logs on hackage anyway ?
09:22:34 <k0ral> what's the use ?
09:22:47 <atriq> :t getFirst . foldMap (First . Just)
09:22:47 <timthelion> statusfailed: like the redit error message with the <F5> hammer.
09:22:48 <lambdabot> Not in scope: `foldMap'
09:22:51 <merijn> davidsd: There is a simple way to do it, yes. It'll mostly be nonsensical, though
09:23:09 <timthelion> k0ral: you only actually log on to submit packages, but you get my gist.
09:23:14 <applicative> roconnor: are you finding edwardk's library a decent development of the main ideas?
09:23:47 <roconnor> applicative: to be honest I haven't used it much myself yet;  But from what I've been following it is.
09:23:54 <merijn> davidsd: Just do "instance Ord (TChan a) where compare = ...", having a sensible definition of compare will be hard, though
09:24:10 <roconnor> applicative: I don't quite understand the theory behind IndexedTraversals yet.
09:24:26 <k0ral> timthelion: cabal upload does it for you, no use of logging in then
09:24:31 <applicative> roconnor:  i skipped those when I was having another go yesterday.
09:25:01 <roconnor> applicative: traversals are going to change how haskell programs are written.  I think they are bigger than monads.
09:25:13 <timthelion> wait, I rm -r 'd my .cabal file.  And it still "thinks" that the old packages are installed.  Where is it thinking up this madness?
09:25:17 <applicative> roconnor: it's a little confusing how there are separate modules for the core Lens , Getter and Setter types though it sort of follows from the main idea
09:25:23 <Ralith> roconnor: traversals?
09:25:25 <roconnor> timthelion: ghc-pkg list will show you your packages.
09:25:39 <hpc> timthelion: .ghc is where your per-user package db is
09:25:41 <squidz> how are kinds different than type signatures=?
09:25:42 <timthelion> roconnor: yes, but where are they, if not in ~/.cabal/?
09:25:51 <timthelion> hpc: aha, thanks
09:25:57 <hpc> cabal is just the build tool, and .cabal is just the config for the build tool
09:26:08 <roconnor> applicative: how do you mean?
09:26:34 <davidsd> merijn: That's basically what I'm asking: Is there a simple way for me to write compare.  Naively, I would wrap each TChan in a datatype together with an id of some sort, and generate a new unique id whenever I want a new TChan.  But that's annoying.
09:26:35 <timthelion> hpc: except for the world file, which is, ya know, related to the stuff in .ghc.
09:26:44 <Ornedan> What exactly is a GHC "worker task"? The things created in rts/Task.c startWorkerTask?
09:27:04 <applicative> well, its just that some of the obvious bread and butter operations that you would use right away in a tutorial that begins with  a custom record type
09:27:18 <Ornedan> My program seems to be leaking those things. And I'd really like to know if it's a bug in my code or the runtime
09:27:21 <applicative> are associated with a weaker type than Simple Lens orLense
09:27:40 <roconnor> applicative: like ^. and .= ?
09:27:44 <applicative> yeah
09:27:51 <adnauseam> hmm, this isn't exactly haskell related but i'm reading something here and the guy is talking about using the "sliding window approach. google is turning up too many results of what a sliding window could be
09:28:01 <roconnor> applicative: this is why API docs don't make good tutorials
09:28:23 <applicative> I had figured all that out before yesterday. It was a hurdle before when I looked
09:28:40 <Clint> adnauseam: is he talking about tcp?
09:28:48 <applicative> roconnor: yes, exactly.
09:28:54 <merijn> davidsd: In that case you probably want to define an Ord instance for the wrapped TChan
09:29:11 <roconnor> applicative: well we need BONUS to write a book on lenses and traversals
09:29:35 <squidz> are lenses important to learn?
09:29:46 <applicative> roconnor: yesterday I was thinking of writing an idiot's guide, maybe I should keep track of what things surprise me as I fiddle with it
09:30:04 <adnauseam> Clint: no, he's implementing a "substring" function to check of a string is a substring of another
09:30:06 <applicative> squidz: no, they're just nice
09:30:19 <k0ral> do you think guys that one day haskell will be widely used by industries ?
09:30:20 <squidz> so more of a convenience than a necessity
09:30:31 <merijn> davidsd: i.e. "newtype MyChan a = MyChan (Int, TChan a)" and then "instance Ord (MyChan a) where compare (MyChan id1, c1) (MyChan id2, c2) = compare id1 id2"
09:30:33 <adnauseam> clint: http://sdasrath.blogspot.de/2009/05/20090510-haskell-road-to-logic-math-and.html
09:30:40 <applicative> squidz: the vogue for them is recent
09:30:50 <adnauseam> clint @ /"I will use the sliding window approach here"
09:30:51 <applicative> squidz: if that tells you anything....
09:30:53 <merijn> davidsd: Although that means you'd have to define wrapper functions for MyChan to read/write
09:31:06 <squidz> applicative: yes it does
09:31:13 <merijn> squidz: Lenses are extremely convenient and relatively easy, but not very important overall
09:31:22 <plat0> roconnor: What's BONUS?
09:31:24 <squidz> merijn: what are they normally used for?
09:31:30 <hpc> plat0: author of LYAH
09:31:32 <applicative> squidz: some of the complaints about the recod system are helped by them
09:31:37 <merijn> squidz: Are you familiar with record syntax?
09:31:37 <hpc> preflex: seen BONUS
09:31:37 <preflex>  BONUS was last seen on #haskell 1 year, 118 days, 21 hours, 3 minutes and 40 seconds ago, saying: yeah i think that's better as well
09:31:44 <applicative> BONUS wrote LYAH
09:31:57 <squidz> merijn: yes, but im not sure what the big fuss is. They seem alright to me
09:32:10 <Clint> adnauseam: i think that's a silly use of "sliding window"
09:32:26 <adnauseam> so basically ignore what he's talking about
09:32:33 <roconnor> squidz: when lenses are combined/generalized to traversals, they become a necessity :D
09:32:44 <adnauseam> i'm thinking of implementing subsrting with the Maybe monad too
09:32:54 <adnauseam> unlike his implementation
09:32:57 <plat0> roconnor: can you explain what you mean about traversals being the next big thing?
09:33:11 <squidz> roconnor: traversals? like folds? or something else?
09:33:25 <merijn> squidz: Well, imagine having nested records, updating a single record syntax value is okay (i.e. "myFoo {foo = 2}") but imagine updating nested values "myFoo {bar = ((bar myFoo) { xyzzy = 1})}"
09:33:37 <roconnor> well, take my example of given a Map k1 (Map k2 Int) and you want to increment the value held at (x, y) if it exists and return Nothing if it doesn't.
09:33:38 <applicative> squidz: so for example if you have a record type with a field that is a record type with a field thats a tuple, it is amuse childsplay to do rec ^. lens1 . lens2 . lens3 to access the inner element
09:33:42 <adnauseam> Clint: thanks for clarifying btw
09:34:00 <Clint> adnauseam: http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/src/Data-ByteString.html#findSubstring
09:34:01 <applicative> amusing childsplay
09:34:14 <merijn> squidz: The idea of lenses is that you have an "accessor" (i.e. getter+setter) that you can compose. So composing the "bar" and  "xyzzy" accessors would let you easily update a nested structure
09:34:14 <squidz> merijn: ah okay, yeah that can become cumbersome
09:34:40 <merijn> squidz: Basically, they are composable getter+setter combinations for data structures
09:34:53 <adnauseam> clint: it's just an academic exercise - i'm trying to dive back into haskell
09:34:54 <roconnor> plat0: with lenses and traverals, that update is easy to write; and without lenses/traverals it is a morass of lookups and modifies.
09:35:21 <applicative> squidz: on the other hand the lookups and modifies are fairly easy to understand ...
09:35:25 <adnauseam> and that is a damn nice implementation \
09:35:36 <merijn> squidz: You have "get :: Lens a b -> a -> b" and "set :: Lens a b -> a -> b -> a" and a functions "compose :: Lens a b -> Lens b c -> Lens a c"
09:35:52 <squidz> seems similar to OO programming languages
09:36:18 <squidz> dot notation
09:36:19 <merijn> squidz: Personally I use them a lot for imperative things, i.e. updating a global state in a StateT
09:36:32 <applicative> squidz: this is one of the charms people find in it, thouh I think the analogies break down pretty soon
09:36:44 <merijn> squidz: Yes, that's sorta what they're for, although they're more general than that
09:37:15 <merijn> Anyhoo, just meditating on the type signatures of (for example) data-lens should make most things obvious
09:37:19 <squidz> applicative: yeah i guess the advantage to this is that these topics are intially intuitive to grasp, but can cause confusion on further inspection
09:37:49 <squidz> like do/return
09:37:58 <adnauseam> Clint: is it better to use bytestring than to use string ?
09:38:00 <squidz> at firt you think, ah yeah, i got this
09:38:14 <applicative> squidz: I think the leading lens libraries are pretty easy to grasp just by example and use, but I'm not sure
09:38:16 <squidz> then later, you realize, oh thats how it is
09:38:46 <squidz> well i guess until my structures get too complex I wont have to dig into them, but its nice to have a general idea. thanks
09:38:51 <sixohsix> The initial paper I read on Lenses made sense until after composability, then it went suddenly complex.
09:39:25 <merijn> squidz: Once you find yourself doing StateT with frequent updates it is *very* worth looking into lenses, it makes the code much nicer
09:39:29 <roconnor> squidz: the real power comes from traversals; unfortunately we don't have good guides and tutorials yet since the concept is, what 1 or 2 months old.
09:39:36 <sixohsix> Which I find is true about a lot of Haskell docs. I need wide, not deep documentation, usually.
09:40:09 <squidz> merijn: good tip
09:40:26 <sixohsix> Has anyone here used vty or similar to write terminal applications?
09:40:49 <sixohsix> I am using hscurses but it doesn't handle Unicode well at all. I need something else.
09:41:06 <merijn> Since there's special combinators that let you do "foo ~= 5" to set the foo field inside the state monad, without all the ugly stuff to read the record, update the field and put it back
09:43:59 <applicative> squidz: the Pong.hs in the examples file sort of makes merijn 's point about state https://github.com/ekmett/lens/blob/master/examples/Pong.hs
09:44:24 <squidz> applicative: thanks, ill take a look
09:44:41 <squidz> ive been wanting to work with state, so this may be my opportunity
09:45:13 <applicative> it's looking a little more complicated now than at first, but see if you can make sense of it
09:46:13 <merijn> Ha, now I just need an FRP example of pong that is as readable and I'm happy :p
09:49:42 <hpaste> timthelion pasted ‚Äúprofiling‚Äù at http://hpaste.org/73739
09:50:13 <timthelion> Why does it just tell me that http://hpaste.org/73739 99.8% of the time was spend in the MAIN module instead of anything usefull?
09:50:55 <Ralith> because you are ignoring the useful parts?
09:51:27 <danr> timthelion: did you compile with -fprof-auto?
09:51:33 <timthelion> Ralith: I don't know how to interpred the useful parts if there are any here.
09:51:36 <timthelion> danr: yes.
09:51:55 <danr> and you're on >=7.4.1 then?
09:51:58 <bogwonch> ;/list
09:52:11 <timthelion> Ralith: but in the example http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/profiling.html there IS clear usefull info..
09:52:11 <bogwonch> ignore misstyped sorry
09:52:32 <timthelion> danr: yes $ ghc -v
09:52:32 <timthelion> Glasgow Haskell Compiler, Version 7.4.2, stage 2 booted by GHC version 7.4.1
09:53:09 <danr> that is curious!!! I don't know what's going on. What happens if you add own SCC pragmas?
09:53:37 <timthelion> danr: I'll try it, as soon as I google the syntax :)
09:53:53 <Ornedan> What exactly is a GHC "worker task"? The things created in rts/Task.c startWorkerTask?
09:53:56 <Ornedan> My program seems to be leaking those things. And I'd really like to know if it's a bug in my code or the runtime
09:53:56 <danr> {-# SCC "foo" #-}
09:54:20 <danr> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/profiling.html#scc-pragma
09:55:55 <timthelion> does GHC by any chance not know how to profile multithreaded apps?
09:56:55 <timthelion> danr: it seems that that helped...
09:59:55 <latro`a> how much work would it be to get links to instance declarations into hackage?
10:01:08 <sixohsix> woohoo! hackage is back up!
10:01:57 <mgccl> It would be cool if there is an online judge delicated for Haskell.
10:02:22 <hpc> a judge?
10:02:55 <hpc> "you are found guilty of violating type safety; I sentence you to 6 years of System F"
10:02:59 <mgccl> something like this http://www.spoj.pl/
10:09:05 <edwardk> ksf: ?
10:09:05 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
10:10:01 <squidz> applicative: i took a look at the pong exmaple, it seems pretty intuitive. I wanted to play around with it but i couldnt import Gloss.Interface.Pure.Game do you know which package it is from since i already installed Gloss from caba
10:10:45 <edwardk> @tell roconnor not sure. but it definitely benchmarks better than my first few attempts from back when it was "Mall" - before it was losing by a factor of 2, now its winning by the same factor and adds almost 0 overhead for cloning
10:10:46 <lambdabot> Consider it noted.
10:11:02 <edwardk> @tell roconnor : maybe i'd just read the benchmarks backwards at first ;)
10:11:02 <lambdabot> Consider it noted.
10:11:37 <timthelion> http://hackage.haskell.org/packages/archive/JuicyPixels/latest/doc/html/Codec-Picture.html#v:generateFoldImage is about 10-20x slower than the equivalent C code.  Is there hope of making up that difference?  I looked at the source, and it's already writting to a mutable array.
10:12:16 <roconnor> edwardk: but the various duplicates don't matter?
10:12:16 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:12:20 <roconnor> edwardk: do you even call duplicate?
10:12:33 <edwardk> timthelion: run a strictness pass over it and see if it helps
10:12:37 <edwardk> roconnor: i don't
10:12:46 <edwardk> roconnor: duplicate is mostly a cute trick
10:12:49 <roconnor> edwardk: extend?
10:12:54 <edwardk> nada ;)
10:12:57 <roconnor> hmm
10:13:10 <roconnor> well, I'm sure it will be useful for someone one day
10:13:31 <edwardk> the comonad is basically available to enable you to split up the mapping from c -> d into smaller steps
10:14:00 <edwardk> i also largely deprecated cloning traversals in the first place
10:14:23 <timthelion> edwardk: that is put a ! before it's name?
10:14:55 <edwardk> i added a bunch of newtype ReifiedTraversal a b c d = ReifyTraversal { reflectTraversal :: Traversal a b c d } newtypes that can be used to 'package' up a traversal,etc.  for containment
10:14:59 <edwardk> that way it comes out with 0 overhead
10:15:47 <edwardk> timthelion: basically going through the code, looking for things that can generate boxed values, and making the strict with ! or seq, or switching parts from Int to Int# etc.
10:16:35 <timthelion> edwardk: OK, will look into it.
10:17:30 <edwardk> a quick look at it shows its pretty boring
10:18:06 <edwardk> major changes i'd make to try to speed it up: add an {-# INLINE generateImage #-} pragma
10:18:07 <roconnor> edwardk: Traversal is a synonym?
10:18:19 <edwardk> and break up the forM_ into two forM_'s nested
10:19:18 <edwardk> forM_ [0 .. h-1] $ \y -> forM_ [0..w-1] $ \(x,y) -> writePixel mutImage x y (f x y)
10:19:34 <edwardk> finally, the Storable vetor is pretty slow compared to the other vector types
10:19:45 <edwardk> er
10:19:55 <edwardk>  forM_ [0 .. h-1] $ \y -> forM_ [0..w-1] $ \ x -> writePixel mutImage x y (f x y)
10:20:40 <edwardk> the major overhead youre going o have left over is that unlike the c version you are recalculating offsets everywhere rather than just starting on the next entry
10:21:39 <hpaste> timthelion pasted ‚Äúslow image processing(in gimp, acutal inversion takes almost no time.  Saving takes longer than for us though...  Here, I loose more than half my time inverting the image...‚Äù at http://hpaste.org/73741
10:21:40 <edwardk> you need to gamble that inlining will be aggressive enough to get all the way down to writePixel, which also means you'd want an INLINE on writePixel for your particular data types as well to go for the absolute craziest performance
10:23:00 <timthelion> edwardk: now I have to read what you wrote and think about it, before I can come up with an inteligent responce.
10:26:30 * hackagebot HGamer3D-Data 0.1.7 - Library to enable 3D game development for Haskell - Data  http://hackage.haskell.org/package/HGamer3D-Data-0.1.7 (PeterAlthainz)
10:26:32 * hackagebot HGamer3D-Ogre-Binding 0.1.7 - Library to enable 3D game development for Haskell - Ogre Bindings  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.1.7 (PeterAlthainz)
10:26:34 * hackagebot HGamer3D-SFML-Binding 0.1.7 - Library to enable 3D game development for Haskell - SFML Bindings  http://hackage.haskell.org/package/HGamer3D-SFML-Binding-0.1.7 (PeterAlthainz)
10:26:36 * hackagebot HGamer3D 0.1.7 - Library to enable 3D game development for Haskell  http://hackage.haskell.org/package/HGamer3D-0.1.7 (PeterAlthainz)
10:26:53 <jmcarthur> interesting...
10:27:12 <jmcarthur> windows only :(
10:27:15 <edwardk> ahwell
10:27:20 <edwardk> start porting ;)
10:32:00 <atriq> You know what annoys me? mzero, empty, mempty
10:32:11 <latro`a> the monadplus thing has its own thread
10:32:24 <mroman> SFML bindings should be portable to linux.
10:32:29 <latro`a> because there are at least two ways in which mzero is expected to interact with the monad functions depending on context
10:32:59 <atriq> Why is Alternative the one without the letter?
10:33:19 <edwardk> atriq: you'll pry the distinction between mempty and empty from my cold dead hands ;) we can talk about mplus though ;)
10:33:37 <edwardk> er mzero
10:33:46 <atriq> edwardk, I recognise they're different
10:33:58 <atriq> I really just don't like the name of empty
10:34:06 <atriq> I think it should be emptyA or something
10:34:29 <edwardk> i rather like having the prettier name used somewhere. i rather dislike random suffixes on everything
10:34:54 <atriq> I'd prefer either both to have an ugly name, or neither
10:35:14 <atriq> If, say, empty was called zero and mempty was called empty
10:35:18 <atriq> That would be perfect for me
10:35:28 * timthelion cares more about the semantic transparency of the lexeme than the asthetics of it's name.
10:35:35 <atriq> But zero is somewhere else?
10:35:39 <edwardk> mempty and mappend are just horribly named
10:35:54 <atriq> timthelion, what I care about and what annoys me do not correlate at all, negatively or positively
10:35:55 <edwardk> i feel no need to replicate their naming pattern elsewhere ;)
10:36:05 <atriq> timthelion, the word "math" annoys me.
10:36:36 <timthelion> atriq: the only thing that annoys me, is cabal, and being hungry and not having food availiable.
10:36:43 <timthelion> * things
10:37:01 <atriq> I'm easily annoyed, I guess, but only about things that I don't really care about
10:37:58 <atriq> Hmm
10:38:59 <c_wraith> timthelion: did you see the recent updates to cabal? they should help a ton
10:40:26 <timthelion> c_wraith: where where they written about?  I only saw the bikeshedding on cafe about version numbers.
10:40:44 <timthelion> s/where/were/
10:41:06 <ksf> edwardk, http://hpaste.org/73729
10:41:26 <plat0> I keep parsing mappend as "map pend"
10:41:59 <ksf> (I'm currently lost on how to add sum types, but that'll hopefully subside)
10:42:05 <edwardk> ksf: i actually thought about building something like that but its pretty hideous to use
10:42:27 <ksf> the type errors are hidious, yes.
10:42:57 <timthelion> c_wraith: honestly, where were they written about???
10:42:59 <edwardk> right now i basically export constructors for construction sans field names, and then use lenses for updates rather than starting from undefineds
10:43:01 <applicative> plat0: just use <> the new mappend
10:43:27 <plat0> I do now :)
10:43:29 <ksf> the problem with that is default values. some things just don't have defaults.
10:43:46 <applicative> mempty should be called o or i, but that would be chaos
10:43:51 <edwardk> sure. then write a smart constructor or something for the type
10:44:36 <edwardk> using classes to model row types is painful ;)
10:44:46 <ksf> Ideally I'd like something like oleg's keyword arguments, but his implementation is broken
10:44:49 <ksf> (on current ghcs)
10:44:56 <edwardk> if i want row types i'll just write ermine =)
10:45:09 <atriq> Hmm
10:45:55 <ksf> e.g. createwindow (x11) has 10 required and 15 optional parameters.
10:46:15 <atriq> I think my data-lenses in Data.FamilyTree break the lens laws
10:46:20 <atriq> Specifically, the third one
10:46:38 <edwardk> atriq: where are they?
10:46:51 <atriq> family-tree package
10:46:59 <ksf> edwardk, ermine? http://www.blueplanetbiomes.org/images/mustela_erminea2.jpg
10:47:06 <atriq> Which needs a complete rewrite anyway
10:47:26 <edwardk> ksf: that would be the weasel we named it after =P
10:48:12 <edwardk> ksf: its the language we have here at s&p capital iq.
10:48:58 <ksf> yes. language extensions is what I usually come up with when thinking "ok, this works/doesn't work, how to do it properly?"
10:49:24 <ksf> closed type families would be a great start.
10:49:36 <edwardk> closed type families would be handy
10:50:04 <edwardk> overall, records are hard. lenses take away the practical pain i have of using them
10:50:24 <edwardk> and so i don't really feel the need to sign up for something that will likely have terrible asymptotics for field update, etc.
10:50:50 <edwardk> or if not asymptotic nastiness, at least awkward linked-list like memory layout, etc.
10:50:53 <ksf> ideally all the type magic should just inline away.
10:51:12 <edwardk> requires too much magic and some deep compiler support
10:51:30 <ksf> I'd be perfectly content with better uninitialised-tracking for records, btw.
10:58:36 <raek> I'm looking for beatiful code to learn haddock style (and layout style too, I suppose) from.
10:58:47 <raek> anyone have any recommendation?
11:04:48 <parcs`> raek: the snap code is really well formatted
11:05:06 <ReinH> So is anyone using smallcheck or lazy smallcheck in practice?
11:05:17 <raek> parcs`: ok, thank you!
11:10:17 <ksf> implementation of closed type families seems to lay aslunder.
11:10:47 <ksf> s/d/b
11:12:23 <geekosaur> (thank you, I kept trying to read that as "asunder")
11:26:31 * hackagebot spelling-suggest 0.5.1 - Spelling suggestion tool with library and command-line interfaces.  http://hackage.haskell.org/package/spelling-suggest-0.5.1 (BartonMassey)
11:26:33 * hackagebot scrypt 0.3.3 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.3.3 (FalkoPeters)
11:26:35 * hackagebot hdm 0.0.1 - a small display manager.  http://hackage.haskell.org/package/hdm-0.0.1 (TimothyHobbs)
11:29:09 <JuanDaugherty> interesting that haskell.org uses mediawiki and not one of the haskell web frameworks, was HaWiki one of them?
11:29:50 <merijn> JuanDaugherty: I think haskell.org predates most (all?) haskell web frameworks
11:30:03 <Clint> there was talk about moving it to gitit, i thought
11:31:21 <JuanDaugherty> ah
11:46:35 <Yiq> So anyone managed to use a database on heroku? or you use some external one? Is there soem other cloud hosting app that you could run haskell on?
11:49:10 <thirsteh> is there a function in the stdlib that takes a Maybe a and throws an exception if it is Nothing?
11:49:30 <Eduard_Munteanu> :t fromJust
11:49:31 <lambdabot> forall a. Maybe a -> a
11:49:31 <srhb> @hoogle Maybe a -> a
11:49:32 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
11:49:32 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
11:49:32 <lambdabot> Data.Monoid First :: Maybe a -> First a
11:49:43 <srhb> > fromJust Nothing
11:49:44 <lambdabot>   *Exception: Maybe.fromJust: Nothing
11:49:46 <hpc> thirsteh: it doesn't throw a catchable exception though
11:49:52 <thirsteh> Ah, great
11:49:53 <hpc> (not an easily catchable one)
11:50:03 <thirsteh> that's fine. This should never happen/is a truly exceptional condition
11:50:18 <Eduard_Munteanu> thirsteh: why not use the maybe monad instead?
11:50:34 <sheldonh> Yiq: some interesting looking answers (including heroku for yesod) to your question on stackoverflow
11:50:36 <Eduard_Munteanu> Nothing is failure there.
11:51:03 <thirsteh> Eduard_Munteanu: I'll take a look, thanks
11:51:09 <sheldonh> i just don't believe any more, in shit that should never happen
11:51:44 <merijn> sheldonh: That's why you'd normally use fromMaybe instead :p
11:51:51 <Eduard_Munteanu> @src Maybe (>>=)
11:51:51 <lambdabot> (Just x) >>= k      = k x
11:51:51 <lambdabot> Nothing  >>= _      = Nothing
12:03:54 <latro`a> that's cute
12:04:02 <latro`a> being able to @src SomeMonad (>>=)
12:04:14 <latro`a> @src IO (>>=)
12:04:14 <lambdabot> m >>= k     = bindIO m k
12:04:20 <latro`a> nice
12:07:19 <sheldonh> in an expression like foldr step 0 (reverse xs) ... is a reverse copy of xs made up front of foldr's traverse, or has haskell got some cleverness that makes this less inefficient than it looks?
12:09:20 <sheldonh> i can kind of imagine foldr asking the (reverse xs) thunk, "hey, can i have whatever's next, please"
12:09:33 <roconnor> sheldonh: a reverse copy is mostly made upfront.  The elements of the two lists are shared.
12:10:51 <roconnor> edwardk: small lens example: http://hpaste.org/73749 What do you think?
12:11:23 <edwardk> cute
12:11:27 <sheldonh> roconnor: okay, then some of these solutions really stink :)
12:11:46 <roconnor> sheldonh: where?
12:16:41 <Eduard_Munteanu> sheldonh: only the spine of the reversed list is recreated
12:16:44 <iamtakingiteasy> hi, is there any clever way to split list in three parts in all possible ways, just like ``let list = [1,2,3,4,5,6,7,8,9] in zip (inits list) (tails list)'' splits it in two parts in all possible ways?
12:17:01 <iamtakingiteasy> all i can think of is pretty damn inefficent ``let list = [1,2,3,4,5,6,7,8,9]; sublists = subsequences list in [ (a,b,c) | a <- sublists, b <- sublists, c <- sublists, (a ++ b ++ c) == list ]''
12:17:08 <Eduard_Munteanu> The rest is shared.
12:18:21 <timthelion> roconnor: +~ being a special kind of +?
12:18:59 <roconnor> > let splits = zip (inits list) (tails list) in let foo x = [(a,b,c) | (a,y) <- splits x; (b, c) <- splits y] in foo [1,2,3]
12:19:00 <lambdabot>   <no location info>: parse error on input `;'
12:19:06 <roconnor> > let splits = zip (inits list) (tails list) in let foo x = [(a,b,c) | (a,y) <- splits x, (b, c) <- splits y] in foo [1,2,3]
12:19:07 <lambdabot>   Not in scope: `list'Not in scope: `list'
12:19:14 <roconnor> > let splits list = zip (inits list) (tails list) in let foo x = [(a,b,c) | (a,y) <- splits x, (b, c) <- splits y] in foo [1,2,3]
12:19:15 <lambdabot>   [([],[],[1,2,3]),([],[1],[2,3]),([],[1,2],[3]),([],[1,2,3],[]),([1],[],[2,3...
12:19:23 <roconnor> iamtakingiteasy: ^^
12:19:26 <iamtakingiteasy> oh, awesome!
12:19:31 <iamtakingiteasy> roconnor: thank you!
12:19:33 <roconnor> timthelion: +~ is a combinator from lens.
12:20:12 <timthelion> roconnor: and where to you "increment" the Integer in the "lensWay"
12:20:16 <roconnor> timthelion: it takes a reference to a Num and increments the reference by the second parameter.  It very roughly corresponds to += from C.
12:20:41 <sheldonh> roconnor: looking through the comments on realworldhaskell.org. but i shouldn't be surprised -- it's a bunch of people at my level :)
12:21:07 <srhb> timthelion: It gets better if your lens is in State, then you really do get to say lens += 1 . As far as I recall
12:21:24 <timthelion> roconnor: you're aware that your code is "bad" in that you shouldn't use names from Prelude like "map" as variable names...
12:21:42 <roconnor> timthelion: meh
12:21:54 * timthelion had to look at it twice to get that.
12:22:02 <roconnor> I can see it being confusing
12:22:08 <roconnor> now that you mention it
12:22:30 <timthelion> -Wall would yell at you.  Indeed, I think even without -Wall you get a warning.
12:23:17 <roconnor> I'm fairly certain I would not get a warning without something like -Wall
12:23:26 <timthelion> srhb: and then I'll be back to programming in C#.  Why do I feel sometimes, that the latest tricks in haskell are just convoluted ways of being imperitive :/
12:24:27 <srhb> timthelion: Sometimes imperative is quite good. And often you can still keep it pure. This makes that possible without the pain. :)
12:24:29 <roconnor> timthelion: in C# you cannot pass a nested member access (.foo.bar.baz) around as a first class value.
12:25:13 <timthelion> roconnor: true.
12:25:23 <roconnor> like how I define ref = at x . traverse . at y . traverse
12:25:49 <roconnor> oh, maybe I'm supposed to remove the spaces around the .
12:25:57 <roconnor> according to edwardk style
12:26:00 <timthelion> srhb: it's just that I find that a lot of people write in very complicated syntax in haskell.  When I am able to do the same thing trivially without abstractions.  I find the first example far easier to read...
12:26:21 <srhb> timthelion: Hmm. I might just not be skilled enough.
12:26:30 <edwardk> roconnor: heh
12:26:50 <edwardk> its optional when the lenses take arguments ;)
12:27:10 <edwardk> at x . traverse.at y . traverse doesn't look bad though =)
12:27:14 <roconnor> timthelion: to read the lens way you need understand the lens abstraction.  But once you do, it becomes quite natural and powerful.
12:27:48 <timthelion> roconnor: I can see how having the ref could be usefull in a longer bit of code.  But for that scenario there is no point :)
12:28:23 <timthelion> roconnor: like if you where going to be doing many things with the same set of refs.  But then again, if I was doing that, it would be more efficient just to do many things, THEN pack the result all at once.
12:29:58 <roconnor> timthelion: I like the lens way because the whole nonsense about naming "innerMap" is gone.
12:30:35 <timthelion> roconnor: It's a good thing we can have both :)
12:30:38 <edwardk> lenses typically let you avoid giving names to a bunch of crap you don't care about
12:30:51 <roconnor> timthelion: yep
12:31:43 <timthelion> That's actually what I love the most about programming.  Is that no matter how strongly two people dissagree, unless it's over systemd or audio architecture it doesn't harm either to keep on dissagreeing.
12:31:56 <edwardk> btw, there is 'traverseAt' which provides the composition for you
12:32:04 <edwardk> traverseAt x . traverseAt y
12:32:15 <timthelion> oh, that's much easier to read(for me)
12:32:16 <roconnor> ah
12:32:24 <edwardk> its provided because its actually an indexed lens
12:35:36 <timthelion> roconnor: if you don't like naming innerMap, lookup k1 map >>= lookup k2
12:36:06 <roconnor> timthelion: okay, now do the update
12:36:23 <edwardk> timthelion: you have to name it on the way back through for the update
12:37:34 <timthelion> do{value<-lookup k1 map >>= lookup k2;return (insert k1 (insert k2 (value + 1) innerMap) map)} -- No one said you cannot mix do notation with binds
12:37:41 <timthelion> oh
12:37:42 <timthelion> shit
12:37:45 <timthelion> I see
12:37:54 <timthelion> you need the name again in the seccond case
12:38:38 <timthelion> OK, you've sold it.
12:38:39 <timthelion> :)
12:39:52 <edwardk> timthelion: same thing comes up with editing a record in a record
12:39:57 <roconnor> timthelion: this discussion has been very helpful for me in clairifying why I like the lens way
12:40:37 <edwardk> timthelion: record update, map update, etc. aren't easily compositional. thats what lenses give you is easy composition
12:41:01 <scshunt> Is there a library for writing directly to a Haskell file as a means of data storage?
12:41:21 <timthelion> scshunt: ?
12:41:33 * hackagebot reactive-banana 0.7.0.0 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.7.0.0 (HeinrichApfelmus)
12:41:35 * hackagebot reactive-banana-wx 0.7.0.0 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.7.0.0 (HeinrichApfelmus)
12:41:37 <roconnor> scshunt: like the xmonad configuration file?
12:42:40 <timthelion> scshunt: Derived instances of "Show" happen to be valid haskell source :D :D :D
12:42:49 <scshunt> roconnor: yeah
12:43:03 <scshunt> timthelion: yes, but I still need to add some wrapping around it
12:43:19 <timthelion> scshunt: so you want to generate haskell source?
12:43:36 <hpc> read the template haskell docs
12:43:39 <JoeyA> Is it possible to {-# DEPRECATE #-} instances?
12:43:56 <JoeyA> Or in some way produce a compile-time warning if a user uses the instance?
12:43:59 <scshunt> timthelion: yeah
12:44:30 <timthelion> scshunt: I generate a lot of haskell source.  I do so, by ++'ing a lot of strings, using concatMap a lot, and unwords some. and unlines rarely.
12:44:46 <timthelion> Works great!
12:44:49 <scshunt> *sigh*
12:44:50 <scshunt> ok
12:44:50 <hpc> sounds hacky
12:45:13 <timthelion> hpc: what, manipulating strings using the String type is about as not hacky as you can get.
12:45:29 <timthelion> hpc: it's when EVERYTHING becomes a String that things are hacky...
12:45:35 <hpc> perl!
12:46:05 <timthelion> https://github.com/timthelion/haskarrow/blob/master/HaskarrowPrecompile/CodeGenerator.lhs
12:46:20 <timthelion> something like that.  Simple code.  Easy to edit.  Why would you need something more complex???
12:47:23 <shachaf> That's not simple code.
12:47:45 <timthelion> shachaf: and how should I be doing it???
12:48:11 <shachaf> With fewer question marks, for one.
12:48:43 <timthelion> shachaf: and how should I be doing it??
12:50:24 * timthelion thinks his code is pretty darned simple.  If not a bit disorganized.
13:02:24 <adnauseam> hmmm, Eq is a type classMaybe is a type constructor, what is Just ?
13:02:44 <adnauseam> s/classMaybe/cass, Maybe
13:02:59 <shachaf> A data constructor.
13:03:38 <mvj4> anyone know if accelerate-quickcheck tests should pass? they don't, but the examples work great.
13:06:31 <adnauseam> shachaf: righton
13:09:04 <hiptobecubic> mvj4, i know one is known to fail for sure.
13:14:07 <timthelion> How many people within the haskell community use FRP?
13:14:28 <danr> hard question to answer, isn't? :)
13:14:42 <danr> but there are some libraries under active or semi-active development for sure
13:15:16 <timthelion> I saw today that bannana just got updated.  But I don't know what packages use bannana..
13:15:52 <edwardk> roconnor: finally adding the filtering by keys
13:16:03 <edwardk> thinking about something like:  indexed traverse `whereIndex` (>2) *~ 10 $ [1..4]
13:16:23 <edwardk> the other names i was choosing were too likely to collide with other useful lens/traversal names
13:17:47 <edwardk> otoh i don't really like infix lens construcotrs because they don't compose with . nicely
13:20:00 <edwardk> of course. its a package about lenses, so clearly it should be 'iwhere' ;)
13:21:06 <JoeyA> timthelion: http://packdeps.haskellers.com/reverse/reactive-banana
13:22:01 <Yuu-chan> Today I told my friend a few of Haskell. A simple definition of "data Maybe a = Nothing | Just a" blew up their minds :(
13:22:22 <hiptobecubic> Yuu-chan, do they know any other languages?
13:22:25 <zhulikas> heh
13:22:30 * Yuu-chan wonders how to give them a gentle introduction
13:22:38 <zhulikas> I learned about EBNF before Haskell
13:22:45 <zhulikas> so Haskell data definitions were awesome for me
13:22:51 <zhulikas> I seriously enjoyed them
13:23:12 <edwardk> @google a gentle introduction to haskell
13:23:13 <Yuu-chan> hiptobecubic: yes, one of them is a C++ expert
13:23:14 <lambdabot> http://www.haskell.org/tutorial/
13:23:14 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
13:24:01 <roconnor> I remember someone saying that their company liked the idea of an option type for their internal language, but so no reason for nested option types, so they cannot be nested in their language.
13:24:30 <hiptobecubic> Yuu-chan, then that's pretty sad I think. They understand unions and enums I assume?
13:25:06 <edwardk> roconnor: sun? =)
13:25:32 <Yuu-chan> hiptobecubic: yes. And he considers a 9-line —++ counterpart with templates and tagged unions more understandable >_<
13:25:41 <shachaf> roconnor: :-(
13:25:48 <shachaf> Nested Maybe is the best thing.
13:26:05 <plat0> I like the idea of √ë++
13:26:33 <merijn> @quote gentle.introduction
13:26:33 <lambdabot> kmc says: i started to read the "tutorial" and it was incomprehensible. makes the Gentle Introduction to Haskell look like Teach Yourself PHP in 24 Hours
13:26:45 <merijn> hmm, wrong quote
13:26:50 <mvj4> hiptobecubic: alright, thanks! for me it's 38/180 failing, with some inconsistencies in other code. might end up posting an issue.
13:27:10 <merijn> @quote Brend gentle.introduction
13:27:10 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
13:27:14 <Yuu-chan> However, they seem to understand a theoretical approach to GADTs
13:27:15 <merijn> :>
13:27:24 <Yuu-chan> Maybe I'm just a bad lector.
13:27:53 <hiptobecubic> Yuu-chan, what you know will always be more understandable
13:29:37 <Yiq> :t unlines
13:29:38 <lambdabot> [String] -> String
13:30:01 <Yiq> > unlines $ intersperse " " ["hello","there"0]
13:30:02 <lambdabot>   Couldn't match expected type `t -> GHC.Base.String'
13:30:02 <lambdabot>         against inferre...
13:30:13 <Yiq> :t intersperse
13:30:14 <lambdabot> forall a. a -> [a] -> [a]
13:30:33 <Yiq> > intersperse " " ["hello", "there"]
13:30:34 <lambdabot>   ["hello"," ","there"]
13:30:42 <Yiq> > unlines $ intersperse " " ["hello","there"0]
13:30:43 <lambdabot>   Couldn't match expected type `t -> GHC.Base.String'
13:30:44 <lambdabot>         against inferre...
13:31:12 <Yiq> > foldl (++) "" $ intersperse " " ["hello","there"0]
13:31:13 <lambdabot>   Couldn't match expected type `t -> [GHC.Types.Char]'
13:31:13 <lambdabot>         against inferr...
13:31:24 <merijn> You have a zero
13:31:32 <merijn> > unlines $ intersperse " " ["hello","there"]
13:31:33 <lambdabot>   "hello\n \nthere\n"
13:31:44 <merijn> Also, you probably want unwords
13:31:49 <merijn> > unwords $ intersperse " " ["hello","there"]
13:31:50 <lambdabot>   "hello   there"
13:32:02 <merijn> > unwords ["hello","there"]
13:32:03 <lambdabot>   "hello there"
13:32:18 <Yiq> > foldl (++) "" $ intersperse " " ["hello","there"]
13:32:20 <lambdabot>   "hello there"
13:32:25 <Yiq> > unlines $ intersperse " " ["hello","there"]
13:32:26 <lambdabot>   "hello\n \nthere\n"
13:32:33 <Yiq> > unwords $ intersperse " " ["hello","there"]
13:32:33 <lambdabot>   "hello   there"
13:32:40 <Yiq> @src unlines
13:32:40 <lambdabot> unlines = concatMap (++ "\n")
13:32:48 <Yiq> @src unwords
13:32:48 <lambdabot> unwords [] = ""
13:32:48 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
13:32:57 <belgin> in the type constructor definition data Either a b = Left a | Right b, a and b are type variables, right?
13:32:59 <Yiq> using (++)
13:33:06 <pharaun> belgin: yeah
13:33:26 <sipa> b
13:33:32 <merijn> Yiq: unlines appends a \n after every string in the list, unwords a space
13:33:52 <merijn> Well, except the last string, that is
13:34:34 <belgin> so a call to Left 2 produces something like an Either Integer b, no?
13:35:03 <merijn> belgin: Correct
13:35:04 <mapreduce> :t Left 2
13:35:05 <lambdabot> forall t b. (Num t) => Either t b
13:35:09 <jmcarthur> > Left 2 :: Either Integer a
13:35:10 <lambdabot>   Left 2
13:35:31 <plat0> :t Left 2 :: Either Integer a
13:35:32 <lambdabot> forall a. Either Integer a
13:35:32 <hiptobecubic> > intercalate "\n" ["Two", "lines."]
13:35:34 <lambdabot>   "Two\nlines."
13:35:58 <jmcarthur> > unlines ["Two", "lines."]
13:35:59 <lambdabot>   "Two\nlines.\n"
13:36:35 <jmcarthur> > unlines $ words "Two lines."
13:36:36 <lambdabot>   "Two\nlines.\n"
13:36:47 <thirsteh> is there an efficient way to trim trailing whitespace or is it just reverse . dropWhile isSpace?
13:36:56 <thirsteh> and the reverse of that
13:37:16 <shachaf> Not asymptotically.
13:37:32 <thirsteh> alright
13:37:47 <jmcarthur> if you are using Text it can be pretty efficient
13:37:54 <thirsteh> I was curious about that: howcome lists in Haskell don't know their length?
13:38:07 <thirsteh> when they're evaluated, I mean
13:38:09 <jmcarthur> because they are just linked lists, and that's it
13:38:15 <shachaf> How would they?
13:38:25 <jmcarthur> they are definable as   data List a = Nil | Cons a (List a)
13:38:25 <thirsteh> ah, ok
13:38:35 <shachaf> thirsteh: Try to make a list structure in Haskell that "knows its length" and look at the trouble you run into. :-)
13:38:43 <monochrom> because I don't use their lengths. would be waste of time to record lengths if I don't use them
13:38:55 <shachaf> One way of thinking abou tit is that lists in Haskell are like for loops in other languages.
13:39:03 <shachaf> "why doesn't a for loop know how many times it'll run?"
13:39:10 <jmcarthur> if you need to know the length of a list, that often means you should consider a different data structure instead
13:39:11 <thirsteh> yes, I'm used to slices from e.g. Python, that's why I was wondering
13:39:24 <jmcarthur> python "lists" are actually more like arrays
13:39:25 <shachaf> Python's "lists" are arrays.
13:39:25 <monochrom> haskell list != python list
13:39:37 <monochrom> haskell class != python class
13:39:44 <monochrom> haskell variable != python variable
13:39:49 <thirsteh> monochrom: yes, thanks, I'm not completely stupid
13:39:49 <monochrom> I thought all these were obvious
13:39:55 <pettter> in short, haskell != python
13:39:57 <Yuu-chan> Simplify: haskell != python
13:40:01 <Yuu-chan> :)
13:40:02 <jmcarthur> *sigh*
13:40:06 <thirsteh> I was just curious why lists don't know their length
13:40:11 <sipa> in particular, a "variable" in haskell doesn't vary at all
13:40:12 <shachaf> That's not simplifying, it's losing information!
13:40:13 <thirsteh> thanks for the answer jmcarthur
13:40:20 <merijn> thirsteh: Python use array lists which are more like "vectors" (in C++ STL terminology)
13:40:23 <mapreduce> thirsteh: Some lists are infinite.
13:40:37 <pharaun> actually on the topic of lists i do have a related question.
13:40:38 <jmcarthur> thirsteh: they don't mean to be condescending
13:40:59 <thirsteh> no, they just seem to continue piling on after it was settled
13:41:00 <thirsteh> :D
13:41:06 <sipa> sure
13:41:08 * shachaf didn't notice condescension.
13:41:10 <pharaun> i have an api which takes Strict ByteString, and i want to support lazy bytestring, which is basically a "list" of strict bytestring chunks right?
13:41:11 <jmcarthur> @quote fugue
13:41:11 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
13:41:17 <thirsteh> haha
13:41:26 <sipa> even if you'd leave the channel now, the discussion about lists that know their length will probably last for a few hours still
13:41:48 <shachaf> pharaun: Yes, with an API that behaves as if it was a single ByteString.
13:41:50 <pharaun> so can i take a lazy bytestring and chunk it into pieces of strict bytestring and feed it into my strict bytestring function, and repeat, the list of strict bytestring is lazy evaulated so i wouldn't have space explosion
13:42:03 <shachaf> Yes.
13:42:05 <shachaf> Lazy.toChunks
13:42:10 <thirsteh> sipa: I'm glad I was able to fuel the discussion
13:42:19 <Yuu-chan> shachaf: why not? data LenList a = Nil | Cons a Int (len List a); (:) a Nil = Cons a 1 Nil; (:) a as@(Cons _ len _) = Cons a (len + 1) as; length Nil = 0; length (Cons _ len _) = len
13:42:19 <shachaf> Alternatively you can write your code to operate on the lazy ByteString directly.
13:42:31 <pharaun> shachaf: alright :) yeah that's what i figured, i just was wary of having it being strictly evaulated
13:42:48 <pharaun> shachaf: i'm not sure how i could do that, i could try
13:43:04 <pharaun> shachaf: but isn't lazy bytestring basically a list of strict bytestring?
13:43:11 <jmcarthur> Yuu-chan: that memoizes the length, but doesn't necessarily make it inexpensive until the whole spine has been evaluated
13:43:26 <Yuu-chan> Oh, and it forbids infinite lists
13:43:38 <shachaf> pharaun: Yes, but its API is like a single long ByteString.
13:43:44 <jmcarthur> well, it doesn't forbid it any more than out current lists do
13:43:52 <jmcarthur> just don't try to take the length of an infinite list
13:44:01 <jmcarthur> *our current
13:44:09 <monochrom> you can certainly define a cons list that has length. like I said, I am not going to use that length, so it's computation and memory wasted
13:44:22 <shachaf> jmcarthur; No, (:) is strict in the tail in that definition.
13:44:34 <shachaf> So it does restrict it.
13:44:37 <Yuu-chan> Is there some sort of mutable string type, like ByteString + STArray?
13:44:45 <shachaf> (You could rewrite it not to, though.)
13:45:00 <adnauseam> functors take concrete types, and return concrete types, or is a functor a concrete type  ?
13:45:03 <shachaf> You mean mutable array of bytes? Yes, there are lots of them.
13:45:13 <pharaun> shachaf: so for me to provide an api for my stuff to run over lazy bytestring i would just take in a lazy bytestring, chunk it up then process each chunk or some such?
13:45:17 <monochrom> I'm going to use lists like "forM_ [1.. f x] blah" it'd better not keep track of lengths
13:45:18 <jmcarthur> shachaf: ah, i didn't actually pay attention to the (:) function as much as i did the type
13:45:45 <pharaun> shachaf: or is there a different approach for actually supporting lazy bytestring?
13:45:48 <shachaf> pharaun: You might not even nned to pay attention to chunks explicitly.
13:45:50 <monochrom> there are other data structures for lengths and random access
13:45:58 <shachaf> pharaun: It depends on how your code is written.
13:46:02 <pharaun> shachaf: ohh i see, alright i'll play with that then
13:46:05 <Eduard_Munteanu> adnauseam: functors are type functions
13:46:27 <adnauseam> mhm
13:46:32 <shachaf> Yuu-chan: Lists in Haskell are control structures just as much as, or more than, they are data structures.
13:46:33 <latro`a> functors are a little more specific than just type functions
13:46:45 <shachaf> That's one of the nicest things about laziness.
13:46:52 <latro`a> any type constructor is a type function; functors are then "type homomorphisms"
13:47:14 <monochrom> thirsteh: haskell list ‚âí python generator, therefore neither keeps track of length
13:47:38 <adnauseam> latro`a: can you tell me the attributes of this type homomorphism? (including a bit of what a homomorphism means in terms of haskell)
13:47:46 <Yuu-chan> shachaf: probably not bytes, but unicode Chars like in ordinary Strings
13:47:48 <latro`a> just means it preserves id and composition
13:47:53 <monochrom> this is also why I am skeptical to "meaningful name"
13:47:57 <shachaf> Yuu-chan: ByteString isn't for unicode characters.
13:48:03 <adnauseam> mhm
13:48:06 <shachaf> Yuu-chan: Text is for Unicode characters (but it's also immutable).
13:48:06 <latro`a> i.e. fmap preserves id and composition
13:48:08 <thirsteh> monochrom: ah, good analogy
13:48:27 <shachaf> You can get mutable arrays of characters too, though.
13:48:28 <Eduard_Munteanu> Also, the existence of fmap f for any f.
13:48:38 <Eduard_Munteanu> :t fmap
13:48:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:48:53 <adnauseam> aslong as f takes 1 parameters, no ?
13:49:00 <latro`a> that's necessary for a homomorphism anyways
13:49:40 <latro`a> but yes, there's always an fmap f, and id and composition are preserved, and you have a type function
13:49:42 <latro`a> that's a functor
13:49:47 <Yuu-chan> shachaf: I know, so I said "like a ByteString" (in matter of space and time efficiency) and "like a STArray" (so there could be a way to modify certain symbols). Unfortunately I don't know much about Text
13:49:53 <latro`a> note that a type function does NOT mean you have a "value function"
13:50:02 <Eduard_Munteanu> adnauseam: Functors are endofunctors on Hask in the CT sense.
13:50:28 <Eduard_Munteanu> If you know a bit of CT, that is.
13:50:48 <adnauseam> no :p nor what endofunctors are, or what Hask is :p
13:51:02 <latro`a> Hask is the category of haskell types whose morphisms are given by (->)
13:51:16 <Eduard_Munteanu> adnauseam: do you know what a functor is, at least?
13:51:18 <adnauseam> righto
13:51:41 <Eduard_Munteanu> But I think you already answered that, sorry.
13:51:48 <adnauseam> i know what it does, but not really beyond using it like a robot. i don't understand what a functor is
13:52:05 <avpx> Well to know what a functor is, you have to know what a category is
13:52:13 <adnauseam> mhm
13:52:20 <shachaf> But to know what "Functor" is, you don't.
13:52:37 <adnauseam> i see, so that's where my education rift is
13:52:54 <latro`a> you (with one exception) have some values of type "f a", and a way to turn a->b into f a -> f b
13:52:57 <Dashkal> A Functor in the haskell sense is a mapping from one /type/ to another /type/.  For example, the [] Functor maps from a -> [a] (the type is changed to a list type)
13:52:59 <latro`a> which preserves id and (.)
13:53:00 <Eduard_Munteanu> Functors are homomorphisms for categories, if you understand e.g. group homomorphisms.
13:53:22 <Yuu-chan> Eduard_Munteanu: a functor which maps a category to a subset of that category is still an endofunctor, right?
13:53:33 <Eduard_Munteanu> Yuu-chan: sure
13:53:43 <adnauseam> how is the haskell functor different from the prolog functor ?
13:54:13 <shachaf> You're best off not trying to find similarities between things that are called "functors" in different programming languages.
13:54:17 <monochrom> hmm, what does the prolog functor do?
13:54:17 <Eduard_Munteanu> Yuu-chan: it needn't be injective or faithful or anything
13:54:29 <latro`a> Yuu-chan, it can be encoded as an endofunctor, but the codomain can be fixed as the "range" too
13:54:31 <adnauseam> Dashkal: yeah that much i understand. It's why i can use it. It just bothers me saying the name without being able to fully understand the concept
13:54:32 <latro`a> in which case it isn't
13:54:38 <monochrom> oh, you mean I get to harp my != lines again? :)
13:54:51 <monochrom> haskell variable != prolog variable. etc. etc. :)
13:54:54 <Eduard_Munteanu> Wait, I thought he meant the image is a subcategory.
13:55:01 <Dashkal> adnauseam: The concept is simpler than you're fooling yourself into thinking.  This is not intended as flippant.  That's literally all a Functor is.
13:55:05 <Yuu-chan> Eduard_Munteanu: it's injective but not surjective in that case
13:55:08 <adnauseam> monochrom: it queries the knowledge base (prolog facts and rules) and produce a result of some type
13:55:21 <avpx> I'm probably going to upset some category theorists with this rough description, but you can see a category as basically a kind of digraph. You have objects (vertices) and edges (which are called arrows). A category has some extra properties, namely that each object has an identity arrow and each pair of arrows f and g such that cod f = dom g have a composition g . f which is another arrow in the category.
13:55:24 <monochrom> ok sounds unrelated to haskell Functor
13:55:37 <monochrom> fwiw there is also SML functor
13:55:39 <avpx> A functor is a homomorphism of categories, so it assigns each arrow another arrow, and each object another object
13:56:08 <Eduard_Munteanu> Yuu-chan: yes, but you're talking about the image, not the codomain right?
13:56:14 <latro`a> the slightly subtle thing is that an object is a type, not a value
13:56:17 <latro`a> in Hask
13:56:39 <avpx> Because it's a homomorphism it has to preserve some structure, but basically that's what the Haskell Functor is.
13:56:52 <avpx> fmap takes an arrow in one category and gives you an arrow in another.
13:57:15 <Cale> In the same category, in the case of Haskell
13:57:21 <Eduard_Munteanu> fmap f is merely F(f) in CT notation.
13:57:23 <Dashkal> adnauseam: Now, a Haskell Functor is not entirely a CT functor.  A CT functor can do more.  In CT, A Category is simply a collection of Objects, and a collection of morphisms or arrows between those objects.  Also, there's always an identity arrow for each object.  Follow?  (No tricks here, it's that abstract, objects and arrows between)
13:57:26 <adnauseam> avpx: holy damn i kind of understood that
13:57:27 <avpx> Right, we're always dealing with the category Hask of Haskell types
13:57:42 <avpx> adnauseam: Glad to hear it.
13:58:21 <monochrom> fwiw there is also Leibniz monad which is unrelated to Haskell Monad :)
13:58:21 <Yuu-chan> Eduard_Munteanu: I suppose that my sound weird, but I'm a she :) Yes, I meant the codomain is not empty (if I use terms right ._.)
13:58:58 <Eduard_Munteanu> Nope, good to know.
14:00:46 * Eduard_Munteanu should use "they" more often
14:01:02 * Dashkal mutters about english's need to gender pronouns
14:01:04 <adnauseam> Dashkal: digesting
14:01:25 <raek> monochrom: what? haskell monads are not the fundamental elements of the universe? :P
14:01:41 <ranger66> hello, can someone give me a simple example of a Functor, that cannot be made an instance of Applicative?
14:01:50 <Dashkal> adnauseam: The 'concrete' example for this is that there's a Cateogry Hask where the objects are the types (Int, Integer, Boolean, etc) and the arrows are functions (Int -> Boolean) and such
14:02:20 <ben> Why's the category called Hask anyway, where did the other syllable go
14:02:28 <Cale> A category C consists of the following: A collection Ob(C) of objects of C, for each pair of objects X,Y in C, a set C(X,Y) of arrows from X to Y, when f is in C(X,Y), we write f: X -> Y. For each three objects X, Y, Z, a function (.): C(Y,Z) x C(X,Y) -> C(X,Z), called composition, such that for any object X in C, there is an arrow id_X such that for any arrows f: W -> X and g: X -> Y we have id_X . f = f and g . id_X
14:02:29 <Cale> = g. Lastly, for any four objects X, Y, Z, W and arrows f: Z -> W, g: Y -> Z, and h: X -> Y, we have (f . g) . h = f . (g . h)
14:02:29 <Dashkal> note the lack of mention of values in that description.  They don't exist at this level of abstraction.  We only care about Types and Functions
14:02:31 <avpx> Categories often have these short, abbreviated names
14:02:34 <latro`a> fairly normal nomenclature in CT
14:02:35 <Eduard_Munteanu> ben: same reason they call Cat Cat :)
14:02:36 <avpx> Cat, Grp, etc
14:02:41 <Clint> mm_freak_: what's the story on yesod-tableview?
14:03:18 <latro`a> cale--C(X,Y) is *often not* a set
14:03:21 <permagreen> The Monadology actually started as an early attempt at a Haskell tutorial, but it was deemed too difficult to understand, so Leibniz changed it to a philosophy paper instead
14:03:27 <latro`a> do please use "collection" in both cases :
14:03:29 <latro`a> *:p
14:03:50 <Cale> latro`a: I'm aware, but locally small categories are easier to formalise.
14:04:06 <Cale> and I didn't expect anyone to complain :P
14:04:41 * Eduard_Munteanu turns off #haskell's -pedantic CFLAG
14:04:50 <Eduard_Munteanu> :P
14:04:55 <latro`a> insufficient permissions
14:04:55 <Dashkal> Where's the fun in that?
14:05:06 <Yuu-chan> So, monads are warm fuzzy things...
14:05:14 <Dashkal> Clouds, damnit
14:05:17 <Dashkal> >.>
14:05:50 <Cale> permagreen: Leibniz?
14:06:13 <Cale> permagreen: that's a completely unrelated notion of monad
14:06:25 <Cale> permagreen: It's not even etymologically the same word :)
14:06:51 * Eduard_Munteanu thinks Cale missed the joke
14:07:03 <Cale> well, I know there's a joke there
14:07:23 <permagreen> Cale: I was building off an earlier comment by monochrom
14:07:27 <Dashkal> adnauseam: Keep asking questions if you get stuck :)
14:07:34 <Eduard_Munteanu> So Leibniz didn't write the first monad tutorial? :P
14:07:39 <Cale> Oh, I see, he made it clear already
14:08:58 <permagreen> The Monadology would be a good name for a haskell tutorial though
14:09:28 <Yuu-chan> It startles.
14:09:55 <belgin>  in the (Either a) functor, by doing fmap f (Left x) = Left (f x), and x is of type a1, it errors because it expects Left (f x) to produce an Either a1 b because of the pattern match, but in fact it produces an Either b b. Is my thinking correct?
14:10:19 <latro`a> you actually can't even call f on the Left type
14:10:39 <scshunt> fmap f (Left x) = Left x
14:10:41 <latro`a> if you have Either a b then f is b -> c, and you can't call it on an a
14:10:59 <Yuu-chan> @src Either fmap
14:10:59 <lambdabot> fmap _ (Left x) = Left x
14:10:59 <lambdabot> fmap f (Right y) = Right (f y)
14:11:09 <latro`a> I think he's asking why it's like that
14:11:10 <Yuu-chan> Interesting.
14:11:35 * hackagebot derive 2.5.11 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.11 (NeilMitchell)
14:11:55 <Yuu-chan> I'd want to work out myself :)
14:12:50 <Yuu-chan> Meh, that was simple after latro`a's description.
14:16:35 * hackagebot unfoldable 0.7 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.7 (SjoerdVisscher)
14:19:53 <Jesin> ooh, latro`a is active
14:19:58 <Jesin> hi latro`a ^_^
14:20:01 <latro`a> hi jesin
14:21:52 <Jesin> hm, I have to go to dinner it seems.
14:25:40 <Yuu-chan> Good bye!
14:43:47 <LordBrain> woohoo hackage is up
14:43:59 <pharaun> yup
14:44:46 <Hadaka> a newbie question - with just Warp, how do I dump the requestBody in to a file - I guess that should be requestBody req <something> sinkFile path, and that needs to be lifted etc. but being a haskell newbie I just can't fathom it out
14:45:54 <LordBrain> What's a Warp? What's a requestBody?
14:46:01 <LordBrain> a sinkFile
14:46:12 <LordBrain> Think i must have walked in in the middle here
14:46:15 <pharaun> LordBrain: warp is a http server in yesod/etc
14:46:20 <pharaun> requestBody is http request
14:46:22 <LordBrain> oh
14:46:29 <pharaun> sinkFile is conduct thing for sinking data to a file
14:46:43 <Hadaka> indeed
14:47:05 <ranger66> Hadaka: did u read the conduit chapter in the yesod book?
14:47:55 <Hadaka> ranger66: mostly, yes
14:49:22 <Hadaka> if requestBody is a source that produces bytestrings, and sinkfile is a sink that takes in bytestrings, then just doing requestBody req $$ sinkFile path should work, but either I can't manage to wrap that call correctly inside my Wai application request handler, or I need to convert data somehow in the middle
14:55:55 <joseanpg> Hello
14:56:17 <Hadaka> ach, I've been an ass, let me try this again
14:56:17 <scshunt> hello
14:56:50 <joseanpg> I would like to know who invented/discovered the State Monad Transformer. Anyone knows?
14:57:23 <Hadaka> I've truly been an ass! In the code that I copy pasted, $$ was imported from Data.Enumerator, and I though it was Data.Conduit.$$ when I typed it
14:57:48 <pharaun> working? :)
14:57:48 <scshunt> haha
14:57:55 <scshunt> Hadaka: this is why you selectively import
14:57:59 <scshunt> (/me never selectively imports)
14:58:30 <scshunt> Show and Read instances are supposed to show/read haskell code, right?
14:58:47 <Hadaka> scshunt: it was selectively imported, I just failed to see it
14:59:09 <joseanpg> > 1+2
14:59:10 <lambdabot>   3
14:59:16 <geekosaur> haskell-compatible constructors, but not general code
15:18:11 <ivanm> preflex: seen mgsloan
15:18:12 <preflex>  mgsloan was last seen on #haskell 18 hours, 32 minutes and 26 seconds ago, saying: ... within Haskell ;)
15:18:25 <mgsloan> :D
15:19:02 <ivanm> mgsloan: I just wanted to say "hear, hear!" for your comments wrt github on the xmonad mailing list!
15:19:36 <mgsloan> oh yeah? cool, thanks!  I've been really liking github lately
15:19:51 <ivanm> wait, weren't you arguing _against_ github? :/
15:20:05 <mgsloan> hahaha
15:20:12 <thirsteh> This sentence is false
15:20:18 <mgsloan> So I think you want to "hear, hear!" carsten :)
15:20:43 <mgsloan> I sent out an email in support of github, but only to him.  He responded to me
15:20:43 <ivanm> oh, yeah
15:20:47 <ivanm> you just forwarded it :s
15:20:53 <mgsloan> and I forwarded both.  Confusing, I know
15:20:55 * ivanm blames gmail from hiding signatures
15:21:14 <mgsloan> ahh :/
15:21:15 <ivanm> *for
15:21:36 <ivanm> I went to see who wrote it and you were the one that sent it to the list...
15:21:57 <mgsloan> I probably shouldn't have, I suppose
15:22:10 <mgsloan> not sure what the best way to handle that is
15:22:22 <mgsloan> This actually kinda ironically illustrates the debate
15:22:23 <ivanm> I normally email the person and say "did you mean to CC the list"
15:22:28 <ivanm> heh
15:22:50 <mgsloan> as it is somewhat "fancy website" vs "email"
15:23:00 <ivanm> well, "darcs send" _does_ send to the list... ;)
15:23:09 <mgsloan> I don't do email for dev much - I like fancy websites
15:23:27 <ivanm> git is also way too stupid for my liking
15:23:58 <mgsloan> I agree, I like darcs' UI better.  I heard that git's cli wasn't even really intended to be used - more as a backend for other stuff
15:23:58 <ivanm> I was thinking of using github for a new project I plan on starting Real Soon Now just in the vain hopes of it making it easier for others to contribute, but git and github piss me off too much
15:24:03 <ivanm> yeah
15:24:16 <ivanm> I've tried a few porcelains; they also seem to suck
15:24:22 <Okasu> i'm trying to use plot lib now, but i'me getting 'perturbed-sine: Data.hs renderSeries: cannot have single error value with points type' error every time i run plot's example
15:24:54 <mgsloan> I used to prefer darcs, and really liked interactive darcs record.
15:25:33 <mgsloan> However, I kinda prefer the git model now, because darcs record is kinda brittle - it encourages you to commit piecemeal patches without actually testing the intermediary states
15:25:45 <ivanm> Okasu: which example? it shows a few ways of doing it
15:25:47 <mgsloan> now, granted, git has this issue too because you can select a subset of your files to include in the patch
15:26:23 <ivanm> I admit that I do find the expected "darcs rebase" feature to possibly useful
15:26:36 <Okasu> ivanm: https://github.com/amcphail/plot/blob/master/examples/perturbed-sine.hs this one
15:26:54 <Okasu> or maybe you reccomend me better lib for plotting with haskell?
15:27:01 <ivanm> as I find myself going "I'll wait until I get this worked out before I record a nice patch" and then end up commenting stuff out, etc. everywhere rather than creating a patch, reverting it, etc.
15:27:06 <Okasu> i'm still not sure which one to choose
15:27:21 <ivanm> Okasu: I've used Chart before, and also manually mangled stuff with gnuplot
15:27:27 <ivanm> but that was a few years back
15:27:54 <mgsloan> ivanm: yeah, I've found git rebase to be pretty handy when making pull reqeusts
15:28:25 <Okasu> ivanm: yeah, me too, but i'm tired of messing with gnuplot manually
15:28:43 <ivanm> Okasu: well, your example isn't _exactly_ the same...
15:28:51 <ivanm> your rs definition is different for starters
15:29:37 <Okasu> ivanm: it's not mine example, it's lib's author's
15:29:58 <ivanm> OK, so he copy/pasted wrong :)
15:31:06 <ivanm> Okasu: try copy/pasting the actual example from Graphics.Rendering.Plot and see if it works better
15:51:38 * hackagebot diagrams-builder 0.2.0.0 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.2.0.0 (BrentYorgey)
15:56:38 * hackagebot graphviz 2999.14.0.0 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.14.0.0 (IvanMiljenovic)
15:59:02 <deech> Hi all, can someone explain why "join" is a useful function? Why would you have a value wrapped up more than once?
15:59:38 <shachaf> deech: Because a value of type "m a" isn't a "wrapped" a.
16:00:54 <shachaf> For example, a value of type IO (IO a) is an IO action that, when run, gives you another IO action.
16:00:59 <shachaf> When you run *that* action you get an a.
16:01:21 <shachaf> There's a function spawn :: IO a -> IO (IO a)
16:01:57 <shachaf> When you run "spawn x", it forks a thread that runs "x" in the background and gives you an "IO a".
16:02:17 <shachaf> When you run the thing it gives you, it waits for the thread to finish and then gives you the value it produced.
16:03:20 <deech> shachaf: So join is just a way of avoiding a bind operation?
16:03:33 <shachaf> Not really?
16:03:47 <shachaf> You can define join in terms of (>>=) or (>>=) in terms of join (and fmap).
16:04:01 <deech> shachaf: I just haven't seen it used much in practice and I run into it in tutorials.
16:04:17 <shachaf> Well, you can ignore it.
16:04:35 <shachaf> It's useful for specific things depending on what monad you're talking about.
16:04:39 <shachaf> > join ["abc","def","ghi"]
16:04:40 <lambdabot>   "abcdefghi"
16:04:51 <shachaf> > map join [Nothing, Just Nothing, Just (Just "hello")]
16:04:52 <lambdabot>   [Nothing,Nothing,Just "hello"]
16:05:01 <shachaf> > join (+) 5
16:05:02 <lambdabot>   10
16:05:09 <Hadaka> hmmh, I need to write a really simple parser - one that parses ByteStrings of the form "bytes 4-30/80" or "bytes 4-30/*" or "bytes */*" - should I just use ByteString.split etc. until I get it all done or write a tiny Parsec parser or write a regexp or what?
16:05:23 <shergill> on hackage, is there a way to check reverse depenencies? to see which packages depend on a given package?
16:05:44 <shachaf> @google hackage reverse dependencies
16:05:45 <lambdabot> http://packdeps.haskellers.com/
16:05:46 <lambdabot> Title: Hackage dependency monitor
16:05:57 <shergill> lol
16:06:04 <shergill> thanks shachaf
16:06:14 <deech> shachaf: how does 'join (+) 5' work?
16:06:22 <byorgey> Hadaka: well, if it were me, I would write a tiny Parsec parser
16:06:47 <byorgey> Hadaka: it's surprisingly lightweight, once you get past the inevitable energy required to figure out the API
16:06:57 <shachaf> deech: Look at the types!
16:07:02 <shachaf> join :: m (m a) -> m a
16:07:05 <shachaf> m a = r -> a
16:07:15 <shachaf> join :: (r -> r -> a) -> r -> a
16:07:32 <Hadaka> byorgey: sounds good - I was wondering if it was reasonable to use it for such a tiny thing
16:07:46 <byorgey> Hadaka: definitely
16:08:24 <danharaj> What flag do I pass to GHC so that it typechecks without emitting objects?
16:08:24 <lambdabot> danharaj: You have 1 new message. '/msg lambdabot @messages' to read it.
16:08:32 <deech> shachaf: I never made the 'm a = r -> a' connection before.
16:08:43 <ifnspifn> Heya. I'm attempting to think my way through implementing groups in Haskell, and I'm running into some issues implementing a group as a datatype. In theory, a group should just be a tuple, (G, *) where G is [a] and * is a -> a -> a. Is there a way to store the operator * in a data type?
16:09:12 <shachaf> deech: instance Monad ((->) r) where ...
16:09:17 <shachaf> deech: Fill in ..., and prove the monad laws!
16:10:08 <danharaj> data Group a = Group [a] (a -> a -> a)
16:11:05 <ifnspifn> danharaj: ah, I tried "data Group a = [a] (a -> a -> a)", so it was just me screwing up the syntax. Thanks
16:12:34 <deech> shachaf: Holy moly, I never put it together that (->) was a data type. I always thought it was a keyword in Haskell.
16:12:49 <shachaf> deech: It's a special type, to be fair. :-)
16:13:08 <danharaj> ifnspifn: right. Group on the left side and on the right side are two different things. It can be a pitfall when learning.
16:13:10 <Jesin> also, it is technically a type constructor
16:13:18 <deech> shachaf: No different than IO though right?
16:13:22 <Jesin> (->) a b
16:13:25 <Jesin> is a type, though.
16:13:26 <Jesin> :p
16:13:26 <shachaf> Well, it's different.
16:13:46 <shachaf> I like it when people say "technically" and then provide their own pet definition for a word. :-(
16:13:53 <shachaf> Anyway it doesn't matter.
16:14:01 <shachaf> (->) is "type-level", just like IO.
16:14:05 <Jesin> shachaf: wait did I do that?
16:15:02 <deech> shachaf: I feel like I understand the language better now. Thanks!
16:15:05 <ifnspifn> danharaj: thanks. So, now, assuming I correctly describe a type class "BinaryOperator" or some such, could I describe the function (a -> a -> a) as being of that typeclass? perhaps a where clause?
16:15:24 <Jesin> umm
16:15:55 <shachaf> ifnspifn: Are you sure you want G to be [a] and not a type?
16:15:59 <Jesin> ifnspifn: well... what sort of methods would a "BinaryOperator" have to implement
16:16:10 <popl> How would you explain to an elderly, maybe not-so-quick person what Haskell does?
16:16:31 <danharaj> shachaf: It would be nice to have an explicit enumeration of the group elements in some applications.
16:16:44 <danharaj> ifnspifn: I don't understand the question.
16:17:15 <shachaf> danharaj: Yes, but it's hardly part of the definition.
16:17:35 <danharaj> fair enough.
16:17:43 <shachaf> ifnspifn: Maybe you can take inspiration from the type classes "Semigroup" and "Monoid".
16:17:57 <danharaj> ifnspifn: by the way, you need an inverse function and identity element too.
16:17:58 <shachaf> Those are one way of talking about algebratic structures in Haskell, at least.
16:18:13 <shachaf> Yes, that too. :-)
16:19:16 <ifnspifn> danharaj: Well, this could stem from my misunderstanding the purpose/place of a typeclass, but if I wanted to describe the group axioms as properties of the function (a -> a -> a) (e.g. the typeclass "BinaryOperator"), could I force the type constructor to only generate Group objects if the function is of the "BinaryOperator" typeclass?
16:19:51 <shachaf> Yes, I suspect you're misunderstanding type classes a little bit.
16:20:26 <shachaf> With that said, there is a type class Semigroup defined as "class Semigroup a where { (<>) :: a -> a -> a }", along with the law that (<>) is associative.
16:20:29 <danharaj> ifnspifn: no. But any function operating on Groups could add the constraint 'BinaryOperator'. However it's not really profitable to use typeclasses to mark laws.
16:21:11 <ifnspifn> hmm‚Ä¶ how might associativity be enforced? or is it treated like the monadic laws, left to the programmer to implement?
16:21:27 <danharaj> It's up to the programmer.
16:22:22 <danharaj> I tend to shy away from using typeclasses. I would probably use something like data Group a = Group a (a -> a) (a -> a -> a)
16:23:18 <shachaf> Type classes aren't that great for this sort of thing because you can only have one instance per type.
16:23:45 <shachaf> So you end up with things like newtype Sum a = Sum { getSum :: a }
16:23:48 <danharaj> Right, making a data type and passing it around is essentially the same thing except you are explicitly passing around the dictionary.
16:23:57 <danharaj> so you can have multiple groups indexed by the same type.
16:24:03 <shachaf> danharaj: On the other hand, you lose uniqueness guarantees.
16:25:06 <danharaj> That's true. It depends on what you're using groups for that determines whether it is more convenient to have unique indices or explicit dictionaries.
16:25:50 <ifnspifn> Well, I shouldn't need any grandiose uniqueness statements -- this is just me trying to augment an intro course to abstract algebra :)
16:26:58 <ifnspifn> I guess what I was looking for was some sort of compile-time guarantee that (G, *) satisfies the group axioms at a superficial level (as I've seen some computational group theory, and it looks nasty), hence the typeclass route
16:29:01 <shachaf> ifnspifn: Try Agda. :-)
16:29:15 <shachaf> You're not going to get *real* compile-time guarantees in Haskell.
16:29:43 <shachaf> But there's not too much of a difference between "made an instance of Group, promised it was valid" and "made a value of type Group a, promised it was valid".
16:30:35 <gwern> @quote promise
16:30:35 <lambdabot> kmc says: The actual pattern is that you *first* do a breathlessly excited post about how Haskell is ninja pirate awesome because quicksort is so short, and it has closures, and you're going to
16:30:35 <lambdabot> learn Haskell and write all your software in Haskell... then a week later you do the bitter "debunking" post. Monads are hard and Maybe isn't any different from Java's null and I was promised a pony,
16:30:35 <lambdabot>  where's my pony
16:31:39 * hackagebot unix-bytestring 0.3.5.4 - Unix/Posix-specific functions for ByteStrings.  http://hackage.haskell.org/package/unix-bytestring-0.3.5.4 (WrenThornton)
16:32:54 <pharaun> haha, basically software development is hard, fin :)
16:32:55 <ifnspifn> shachaf: oy, Agda's way deep down the rabbit hole
16:40:04 <mapreduce> Agda seems quite good, ifnspifn, simple in a way.
16:40:37 <joe9> how about idris?
16:40:48 <joe9> it seems more straightforward
16:47:59 <Hadaka> byorgey: never used parsec before, and the parser came out great, thanks!
16:48:38 <Hadaka> now time for some sleep
16:55:14 <mgsloan> ivanm: just used darcs to send a patch to xmonad, and gotta admit, that was pretty painless - been a while since I've darcs sent.  Still, there's no "merge this patch" button on the other side
17:16:21 <LordBrain> hows the development activity on darcs, is it well maintained?
17:17:29 <mapreduce> joe9: Idris looks pretty much the same as Agda from my uneducated point of view.  It might be closer to Haskell syntax, and the documentation seems not to use unicode, which for me is a plus.
17:17:53 <mapreduce> It seems to know IO without having to use an FFI.
17:20:06 <thirsteh> is there a shorthand for constructing a "copy" of something but with one more attributes altered?
17:20:13 <thirsteh> a data type
17:22:23 <mgsloan> LordBrain: I think there're definitely a few people working on it - the performance is far improved, but still slower than git
17:22:41 <HugoDaniel> is there any js module that tries to simulate haskell ?
17:22:42 <mgsloan> and there are a number of github-like sites for it (darcsden, patchtag)
17:22:48 <thirsteh> HugoDaniel: Fay
17:22:56 <thirsteh> HugoDaniel: http://fay-lang.org/
17:23:22 <mgsloan> HugoDaniel: This isn't a js module, but ghcjs allows you to compile a good deal of Haskell to javascript
17:23:35 <fmap> thirsteh: does lens count as "shorthand"?
17:23:54 <HugoDaniel> oh
17:23:55 <HugoDaniel> cool
17:26:09 <edwardk> thirsteh: foo { bar = 10 } edits the bar field of foo
17:26:48 <thirsteh> fmap, edwardk: oh, thanks. I keep thinking it's more complicated than it turns out to be :)
17:26:55 <edwardk> thirsteh: and returns a new copy
17:27:00 <thirsteh> edwardk: that's exactly what I want
17:27:24 <edwardk> lenses can be used for more advanced edits, but aren't necessary especially when you are getting started
17:29:12 <thirsteh> I was using a bunch of TVars for everything, but the majority of the fields only changed rarely, so I might as well just replace the copy
17:30:00 <thirsteh> I'm not sure I totally understand how TVars work with respect to copying: If I have a Foo with some TVars and I pass an instance of Foo, foo, around, put it in lists, etc. its non-TVar fields are copies and the TVar fields are essentially pointers to the same values, right?
17:30:19 <thirsteh> those being copies of pointers, too
17:31:44 <edwardk> think of a tvar like a pointer and your intuiton will be okay
17:32:07 <thirsteh> ok
17:32:14 <mauke> thirsteh: the other fields aren't copies
17:33:56 <thirsteh> mauke: so if I put something in 10 different lists, there's only one copy of it?
17:34:01 <mauke> yes
17:34:05 <thirsteh> great
17:34:06 <mm_freak_> Clint: that package is terribly outdated and i have no plans to update it right now
17:34:28 <mauke> haskell won't copy things behind your back
17:36:18 <jmcarthur> well, not anything nontrivial at least
17:36:32 <thirsteh> is there a FAQ/doc somewhere that describes when something DOES get copied?
17:37:18 <jmcarthur> you usually can just lean on call-by-need as a reasonable enough approximation
17:37:24 <thirsteh> if I understand you correctly then if I do foo { fourthField = 5 } then I'm only allocating a new instance of fourthField's type, and whatever's needed to represent foo, not the other fields?
17:38:02 <thirsteh> where "allocate" is loosely defined
17:38:23 <jmcarthur> in fact, the new foo just points to whatever existing values you tell it to. nothing is really created that you don't construct yourself
17:38:30 <mauke> thirsteh: things get copied when you copy them
17:38:53 <jmcarthur> @src repeat
17:38:53 <lambdabot> repeat x = xs where xs = x : xs
17:39:10 <thirsteh> jmcarthur: thanks, that's great
17:39:27 <jmcarthur> thirsteh: in that definition of repeat, every x is exactly the same x, for example. and in fact, every cons node of the list it creates is the same one! it's just cyclic
17:40:01 <jmcarthur> thirsteh: the thing it actually allocates is the (:)
17:40:28 <thirsteh> ok, I think I understand
17:46:41 * hackagebot BlogLiterately 0.5.2 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.5.2 (BrentYorgey)
17:50:36 <mk> are all monadic values monoids?
17:51:09 <scshunt> mk: No.
17:51:18 <LordBrain> monoid is unrelated word, it just sounds the same
17:51:34 <mauke> ...
17:51:44 <LordBrain> well everything is related in some way
17:51:49 <scshunt> mk: A monoid is a type with an associative operation on itself (mappend) with an identity (mempty)
17:52:17 <scshunt> Some monads are also monoids (list comes to mind), but this is mostly circumstantial
17:52:22 <LordBrain> but as far as i know monoid and monad have different etymology...
17:52:37 <Cale> Ordinary monoids are monoid objects in Set, while monads are monoid objects in the category of endofunctors on a fixed category.
17:52:51 <Cale> monad is a portmanteau of monoid and triad.
17:52:56 <mauke> LordBrain: I thought monads were named after monoids
17:52:58 <LordBrain> ah
17:53:05 <LordBrain> i didn't know
17:53:08 <Cale> Which were both words originally used to refer to them
17:53:23 <LordBrain> there are a lot of monoids
17:54:49 <Cale> mk: However, the monadic values themselves aren't monoids
17:54:57 <mk> I'm fine with the distinction between monad and monoid. I suspect though that most (or all) monadic values actually are monoids.
17:55:10 <Cale> A monoid is a set with an associative operation on it
17:55:30 <Cale> Individual monadic values aren't easily construed as sets.
17:55:49 <Tekmo> How is the free monad a monoid?
17:55:52 <Cale> (let alone carrying additional associative operations)
17:55:58 <LordBrain> a naive lex of the word might lead a person to think monoid is to monad as humanoid is to human or something like that.
17:56:07 <mk> one must assume that monadic values that store "no values" (like Nothing) contain an empty list, and that monads that store a single value contain a singleton list
17:56:38 <Cale> What?
17:56:48 <mauke> mk: monads don't store values
17:57:03 <Tekmo> So what would be the "no value" for the identity monad?
17:57:16 <mk> mauke: assume they do, under an appropriate interpretation of "store"
17:57:22 <mauke> mk: monads don't store values
17:57:38 <mauke> this is non-negotiable
17:58:00 <Tekmo> I think he means it in a non-rigorous sense
17:58:04 <mk> mauke: not really interested in having that argument
17:58:29 <Tekmo> He's probably referring to the fact that the monad is a functor and the functor is parametrized on the value that he considers "stored"
17:58:32 <mauke> Tekmo: I think he means it in a non-true sense
17:58:38 <Cale> A monad is a type constructor
17:58:42 <Tekmo> Right
17:58:46 <Tekmo> He means it in the type constructor sense
17:58:49 <mauke> wat
17:59:01 <Cale> It takes a type as a parameter and gives another type
17:59:10 <Cale> It doesn't store a value
17:59:13 <mauke> how does a type constructor store anything, let alone values?
17:59:15 <mk> Tekmo: the identity monad's "no value" is an empty list. Interestingly, no monadic value in identity can be created that contains that list
17:59:25 <ddarius> LordBrain: There is a notion of "oidification", though a monoid isn't the "oidification" of a monad, rather a category is the "oidification" of a monoid.
17:59:28 <mk> mauke: it doesn't. Don't worry about it.
17:59:41 <mauke> mk: I know it doesn't. you claimed it does
17:59:56 <LordBrain> heh
18:00:10 <mk> mauke: I'm talking about "type constructors" storing things. Monadic values (except for trivial) do store original values.
18:00:23 <loreints> can someone help me figure out why adding a case statement to my main makes my code run forever? http://hpaste.org/73758
18:00:24 <LordBrain> so lets call categories monadoids
18:00:32 <LordBrain> lol
18:00:33 <mauke> mk: you said monads, not monadic values
18:00:37 <Tekmo> Not necessarily
18:00:40 <ddarius> LordBrain: They would be monoidoids, not monadoids.
18:00:41 <Tekmo> consider the "Unit" monad
18:00:45 <Tekmo> data Unit a = Unit
18:00:48 <LordBrain> oh oops
18:00:49 <Tekmo> return _ = Unit
18:00:55 <mauke> not this shit again
18:00:56 <Tekmo> join Unit = Unit
18:01:04 <LordBrain> wait is that right
18:01:05 <mk> mauke: where did I say that?
18:01:05 <Tekmo> No value is stored there
18:01:15 <LordBrain> lol
18:01:22 <mauke> mk: "... and that monads that store a single value contain a singleton list"
18:01:24 <ddarius> mauke: I presume the conversation has (cyclically) continued unabated the entire time I've not been here.
18:01:24 <mk> Tekmo: that's called the Trivial monad
18:01:32 <ddarius> (plus the time before of course)
18:02:04 <mauke> to which <mauke> mk: monads don't store values
18:02:06 <Cale> How about Cont Bool, wherein return turns the value it's given into a function which answers yes or no questions about that value -- from which the original value can't necessarily be recovered?
18:02:32 <Tekmo> Well, i don't think that he's arguing the value is retrievable
18:02:32 <mk> mauke: typo, look at what I wrote directly before that. Forget it
18:02:43 <Tekmo> He's just saying the implementation has it in there, "somewhere"
18:02:53 <mauke> mk: you made a similar error with monoids, which is what Cale was objecting to
18:03:27 <mk> Cale: yeah I'm not too sure about Cont, because I haven't looked at it well enough yet. Can your example work with the state or reader monads?
18:03:32 <mk> mauke: thanks
18:03:41 <Cale> Not quite.
18:04:15 <Tekmo> Trivial example, then:
18:04:17 <Tekmo> State Void a
18:04:20 <mk> Cale: can you give me an example of a bind invocation?
18:04:22 <Tekmo> You can't recover a from that
18:04:48 <mk> Cale: for Cont, which roughly demonstrates your example?
18:04:52 <Tekmo> Or just Reader Void a
18:04:52 <Cale> mk: Okay let me define this in a specialised way so we can look at it
18:05:15 <Cale> newtype Query a = Q ((a -> Bool) -> Bool)
18:05:49 <mauke> mk: new rule. you must present actual code or math to support your claims
18:05:54 <Cale> A value of type Query a is a black box which accepts yes or no questions about potential values of type a, and answers them (possibly un-truthfully)
18:06:07 <mauke> like "I think monads are monoids with these definitions of mempty/mappend ..."
18:06:16 <Tekmo> Relax, mauke
18:06:18 <mk> mauke: I am totally not interested
18:06:31 <mauke> mk: I am bored by famine.
18:06:37 <Cale> runQuery :: Query a -> (a -> Bool) -> Bool
18:06:38 <Tekmo> He's just trying to learn,  and we all make mistakes when we learn
18:06:46 <Cale> runQuery (Q f) q = f q
18:06:50 <mauke> Tekmo: [citation needed]
18:06:52 <LordBrain> i think it makes sense to say all types contain values, because types are like categories
18:06:53 <mk> mauke: "you must talk to this channel using only advanced Haskell" - no thanks ;)
18:07:02 <Cale> Now, we can turn this into a monad
18:07:06 <mauke> mk: I never said that
18:07:16 <Cale> return v will be the box which answers questions truthfully about v
18:07:17 <mk> mauke: ok
18:07:29 <Cale> return v = Q (\q -> q v)
18:07:31 <mauke> besides, defining two functions isn't "advanced haskell"
18:07:43 <LordBrain> so in a denotational semantic sort of sense, Integer contains 3
18:07:54 <Cale> That is, given a question q, it just applies the question q to v and gives the answer directly
18:08:00 <mk> Cale: what does bind look like for that? Most importantly, what does it take as its second arg?
18:08:05 <Cale> Okay, so bind :)
18:08:22 <Tekmo> Can we get lambdabot to paste the source for the cont monad?
18:08:23 <LordBrain> IO Monad contains (IO 3)
18:08:32 <LordBrain> or well... actually
18:08:51 <Tekmo> m >>= k = Cont $ \c -> runCont m $ \a -> runCont (k a) c
18:09:02 <LordBrain> IO 3 contains (return 3)
18:09:24 <LordBrain> (return 3::IO 3)
18:09:27 <LordBrain> heh
18:09:36 <Tekmo> return 3 :: IO Int
18:09:43 <LordBrain> yeah
18:09:55 <LordBrain> of course
18:10:11 <Cale> x >>= f = Q (\q -> runQuery x (\v -> runQuery (f v) q))
18:10:19 <LordBrain> sorry, wires in my head must have got crossed when i typed that
18:10:27 <Tekmo> No worries! :)
18:10:33 <Tekmo> I get corrected all the time
18:10:51 <LordBrain> Anyway, :: is like contains in a denotational semantic sense...
18:11:35 <mk> what is the type of f?
18:11:44 <Tekmo> a -> Query b
18:11:48 <Cale> So what this says is that x >>= f is the box which when asked a question q, asks x the question "If your value is v, how will f v answer the question q?"
18:12:04 <Tekmo> (>>=) :: Query a -> (a -> Query b) -> Query b
18:13:05 <Cale> Now it might look like return v "contains" the value v somehow, but asking yes-or-no questions, we might not actually be able to recover all of the value v, depending on what type it is.
18:14:10 <Tekmo> Cale, you can use the simpler example of Reader Void a
18:14:15 <Cale> (we can recover one bit of information at a time about v, and for specific types, we might be able to ask the right questions to try to recover all the information, but we might have to ask infinitely many)
18:14:58 <mk> yeah I think I follow that. But it looks like the monadic values might be associative, and may be composed, and the remaining reqs for monoids
18:15:19 <Cale> Sorry, what?
18:15:46 <Tekmo> Maybe it would help if you wrote out the type you have in mind for composition
18:15:47 <mauke> mk: composed how?
18:15:49 <mk> Query is an instance of monoid?
18:15:50 <Cale> You're saying that each monadic value is its own monoid somehow?
18:15:59 <mauke> mk: kind error
18:16:04 <Cale> Or that the set of all monadic values form a monoid?
18:16:05 <Tekmo> If it were an instance of monoid
18:16:07 <Cale> Or... what?
18:16:12 <Tekmo> you would need the following operation:
18:16:15 <Tekmo> mempty :: Query a
18:16:20 <Tekmo> mappend :: Query a -> Query a -> Query a
18:16:21 <mk> Cale: no, they form the set, which along with a neutral value, and a combining operation forms a monoid
18:16:32 <Tekmo> So, what is the neutral value of Query a?
18:16:46 <mauke> and what is the combining operation?
18:17:07 <mk> a Query "containing" some sort of identity function
18:17:11 <Cale> What is the set we're talking about?
18:17:13 <mk> mauke: functional composition
18:17:15 <Cale> I'm confused
18:17:23 <mauke> mk: less words, more code/math
18:17:25 <mk> Cale: the set of all query values, I think?
18:17:28 <Tekmo> mk
18:17:28 <mauke> I want to see the actual definition
18:17:32 <Tekmo> Perhaps I can articulate
18:17:35 <Tekmo> what you are thinking
18:17:46 <Tekmo> So, all monads form a category called the Kleisli category
18:17:58 <Tekmo> The neutral value in the Kleisli category is "return"
18:18:01 <Tekmo> return :: a -> m a
18:18:10 <Tekmo> The combining operation in the Kleisli category is (>=>)
18:18:16 <mk> mauke: unsure how to provide this, or I'd just know the answer to my own question via inspection :/
18:18:23 <Tekmo> (>=>) :: (a -> m b) -> (b -> m c) -> (a -> m c)
18:18:24 <Cale> return gives the identity arrows in the category, and (<=<) gives the composition
18:18:29 <mauke> mk: by typing symbols with your keyboard
18:18:40 <Tekmo> So perhaps
18:18:45 <Tekmo> that might be what you are thinking of
18:19:08 <mk> Tekmo: this isn't the usual "monads are monoids in the category of endofunctors" thing
18:19:12 <Cale> Categories look a bit like monoids, so yeah, maybe that's what you're thinking of
18:19:19 <mauke> Tekmo: that seems unlikely to me
18:19:36 <mauke> Tekmo: you're assuming mk is making sense
18:19:38 <Cale> mk: Right, that's not the category of endofunctors thing, that's different
18:19:48 <Tekmo> Well, technically it is equivalent
18:19:53 <mk> ...here's how things would work with the state monad
18:20:46 <mk> bind for the state monad takes two values - the first parameter of a two-param function, and then that very two param function. The two param function spits out a one-param function which takes the second argument, that second argument is the state
18:20:58 <mauke> mk: stop
18:21:05 <mk> mauke: don't interrupt
18:21:09 <Tekmo> I'll type out that type
18:21:13 --- mode: ChanServ set +o mauke
18:21:13 --- mode: mauke set +q $a:mk
18:21:14 <Tekmo> (s, a) -> (s, b)
18:21:17 <Tekmo> uncurried
18:21:19 <mauke> I said "stop"
18:22:28 <Tekmo> (>>=) ~~ (a -> (s, b)) -> ((s, a) -> (s, b))
18:22:50 <shachaf> What?
18:23:02 <Tekmo> With arguments reversed and uncurried
18:23:11 <Tekmo> Fine, I"ll be explicit
18:23:13 --- mode: mauke set -o mauke
18:23:55 <Tekmo> :t uncurry . (=<<)
18:23:56 <lambdabot> forall b c a. (a -> b -> c) -> (b -> a, b) -> c
18:25:20 <shachaf> Are you looking for something like (s -> (s,a)) -> ((s,a) -> (s,b)) -> s -> (s,b) ?
18:25:30 * shachaf isn't sure what type Tekmo is trying to say.
18:25:35 <Tekmo> haha
18:25:42 <Tekmo> It's because I don't have runState in there
18:25:55 <Tekmo> But basically, I'm just showing that bind converts the State monad into ordinary composition of functions
18:26:13 <shachaf> I don't think (>>=) is isomorphic to the type you gave.
18:26:40 <copumpkin> =<< is
18:26:47 <Tekmo> (=<<) :: (a -> State b) -> State a -> State b
18:26:53 <copumpkin> and >>= probably is too, since you can flip
18:27:28 <shachaf> (=<<) :: ((s,a) -> (s,b)) -> (s -> (s,a)) -> s -> (s,b)
18:27:39 <shachaf> Does that work out to be isomorphic?
18:27:46 <Tekmo> Yes
18:27:48 <Tekmo> No
18:27:48 <Tekmo> I mean
18:27:53 <Tekmo> What you wrote
18:27:56 <Tekmo> is what I had in mind
18:28:26 <Tekmo> Bleh, what I was trying to get at was the Kleisli formulation
18:28:38 <Tekmo> I always define state this way
18:28:58 <Tekmo> return = uncurry id
18:29:01 <shachaf> Oh.
18:29:26 <Tekmo> Wait
18:29:29 <Tekmo> got it backwards again
18:29:30 <shachaf> ((a,s) -> (b,s)) -> ((b,s) -> (c,s)) -> ((a,s) -> (c,s)) ?
18:29:35 <Tekmo> Yes
18:29:46 <shachaf> OK.
18:30:00 <Tekmo> :t curry id
18:30:01 <lambdabot> forall a b. a -> b -> (a, b)
18:30:06 <adnauseam> Dashkal: i think i understand functors now :o
18:30:07 <Tekmo> There
18:30:09 <Tekmo> retur = curry id
18:30:15 <adnauseam> Dashkal: or better yet, for now
18:30:20 <Tekmo> f >=> g = curry $ uncurry f . uncurry g
18:30:20 <Dashkal> :)
18:30:21 <adnauseam> and a bit of category theory o_0
18:30:34 <Tekmo> Then you see that Kleisli composition of state arrows
18:30:39 <adnauseam> sorry for the radio silence, i had to go and look up most of the things you guys said
18:30:47 <Tekmo> is just ordinary composition of functions of type (s, a) -> (s, b)
18:31:34 <loreints> can I have a case statement inside of a 'do' block or is that only for function definitions?
18:31:37 <Tekmo> My favorite is the application of this same trick for the cont monad
18:31:45 <Tekmo> You sure can
18:31:47 <adnauseam> is it better to search strings as byte strings ?
18:31:53 <shachaf> adnauseam: What?
18:32:24 <shachaf> Hmm, (a -> Cont r b) = (a -> (b -> r) -> r)
18:32:31 <shachaf> = ((a -> r) -> (b -> r))?
18:32:31 <Tekmo> It comes out to
18:32:37 <Tekmo> returm = flip id
18:32:44 <adnauseam> i'm just wondering why findSubstring is implemented with Bytestring
18:32:53 <Tekmo> f <=< g = flip $ flip g . flip f
18:33:01 <shachaf> adnauseam: ?
18:33:10 <adnauseam> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/src/Data-ByteString.html#findSubstring
18:33:13 <shachaf> @hoogle findSubstring
18:33:13 <lambdabot> Data.ByteString findSubstring :: ByteString -> ByteString -> Maybe Int
18:33:13 <lambdabot> Data.ByteString.Char8 findSubstring :: ByteString -> ByteString -> Maybe Int
18:33:13 <lambdabot> Data.ByteString findSubstrings :: ByteString -> ByteString -> [Int]
18:33:13 <parcs`> adnauseam: i'd imagine it's much more efficient
18:33:26 <shachaf> adnauseam: It's implemented with ByteString because it's in the ByteString package?
18:33:26 <Tekmo> :t flip id
18:33:27 <lambdabot> forall a b. a -> (a -> b) -> b
18:33:31 <ddarius> Tekmo: Note that that construction works for defining the Kleisli category of any monad given an underlying adjunction.
18:33:34 <Tekmo> :t \f g -> flip $ flip g . flip f
18:33:35 <lambdabot> forall a b (f :: * -> *) a1 b1. (Functor f) => f (a1 -> b1) -> (a -> f b1 -> b) -> a -> a1 -> b
18:34:23 <Tekmo> How do you derive it from the adjunction?
18:34:31 <adnauseam> parc`: yeah, me too. i was just wondering why is that. i'm guessing strings are graphical representations of of the bytes that encode them. so searching a bytestring is searching a more novel data structure.
18:34:43 <adnauseam> but then that's what i think, no idea if it has any truth
18:34:54 <Tekmo> a bytestring is like a C array of Chars
18:35:09 <shachaf> No, it's like a C arrays of "char"s.
18:35:17 <Tekmo> It's basically a thin layer over the equivalent C implementation
18:35:17 <adnauseam> but then isn't a string a [Char] too
18:35:18 <shachaf> Which are very different from Haskell "Char"s.
18:35:29 <geekosaur> normal strings use Data.List.isInfixOf, I believe
18:35:30 <shachaf> Actually it's like a pointer + offset + length.
18:35:34 <Tekmo> Yeah
18:35:39 <Tekmo> It caches length and offset information
18:35:42 <shachaf> adnauseam: String is [Char]; the equivalent of ByteString would be [Word8]
18:35:50 <shachaf> It's not about caching.
18:35:53 <Tekmo> But the string itself is basically just like "char *str"
18:36:02 <geekosaur> but that's more general, it searches for a list within another list
18:36:13 <shachaf> There's no caching. ByteString isn't 0-terminated or anything like that.
18:36:27 <Tekmo> I meant "stores" when I said cache
18:37:08 <shachaf> OK. :-)
18:37:16 <Tekmo> The important part is that it is an array of characters
18:37:18 <shachaf> Anyway, what was the question?
18:37:21 <Tekmo> not a Haskell linked list
18:37:26 <shachaf> ByteString is *not* an array of characters.
18:37:28 <shachaf> It's an array of bytes.
18:37:36 <Tekmo> I mean it in the C sense
18:37:40 <Tekmo> I come from a C background
18:38:02 <Tekmo> So character is synonymous with "char" from my background
18:38:04 <Tekmo> not Haskell Char
18:38:06 <shachaf> OK, so you can say "array of C chars" or something. It's important to distinguish these.
18:38:10 <adnauseam> i see
18:38:10 <Tekmo> Ok
18:38:13 <Tekmo> An array of C chars
18:38:23 <shachaf> Which the rest of the world calls bytes. :-)
18:38:35 <Tekmo> :)
18:38:43 <shachaf> (ByteString is actually specified to be an array of octets, I think.)
18:38:44 <dolio> Kleisli category has underlying objects as objects, and arrows A -> MB as morphisms from A to B. A -> MB = A -> GFB ~ FA -> FB.
18:38:59 <adnauseam> C chars as in the data type char in C?
18:39:00 <Tekmo> Well, a C char is specified to be an octet
18:39:04 <ddarius> Tekmo: An adjunction is a natural isomorphism f :: (Functor f, Functor u) => Hom (f a) b -> Hom a (u b) (i.e. there is a g :: (Functor f, Functor u) => Hom a (u b) -> Hom (f a) b such that f . g = id and g . f = id).
18:39:05 <Tekmo> Yes
18:39:11 <Tekmo> char *str
18:39:14 <adnauseam> which is equivilanet to Word8 in haskell ?
18:39:19 <Tekmo> Yeah
18:39:26 <shachaf> A C char is specified to be CHAR_BITS big, which can be more than 8.
18:39:27 <Tekmo> C defines char to be exactly one byte
18:39:38 <adnauseam> and a Bytestring is then a list of Word8 ?
18:39:46 <adnauseam> [Word8]
18:39:49 <shachaf> Yes, but it doesn't define a byte to be 8 bits.
18:39:53 * shachaf sighs.
18:39:54 <Tekmo> Oh damn
18:39:57 <Tekmo> Never realized that
18:40:17 <shachaf> I recommend keeping bytes very separate from characters.
18:40:25 <Tekmo> You mean bits!
18:40:46 <adnauseam> so Word8, is equivalent to C's char, which is a byte, but is itself not limited by being a single octate ?
18:40:47 <shachaf> adnauseam: A ByteString is an immutable contiguous-in-memory array of octets.
18:40:52 <ddarius> Tekmo: For Haskell, we can just take Hom to be (->).  Then, using crappy names, curry :: ((a, c) -> b) -> (a -> (c -> b)) and uncurry is it's inverse. (The functors are f a = (a, c) and u b = c -> b.)
18:40:53 <Tekmo> Word8 = 8 bits
18:41:14 <Tekmo> Thanks, ddarius
18:41:32 <Tekmo> So basically the two morphisms that define the adjunction
18:41:40 <Tekmo> sorry, the isomorphisms
18:41:52 <ddarius> Tekmo: So, return = f id, h <=< k = g (f h . f k), for any adjunction with natural isomorphism witnessed by f and g.
18:41:53 <Tekmo> Are what you use to define the Kleisli composition interms of ordinary composition
18:42:06 <Tekmo> So if I have some adjunction between f and g
18:42:14 <Tekmo> I forgot the notation
18:42:18 <Tekmo> is it F |- G?
18:42:22 <ddarius> Other way.
18:42:24 <ddarius> F -| U
18:42:28 <Tekmo> F -| U
18:42:36 <Tekmo> The monad is UF, right?
18:42:42 <ddarius> Yes.
18:42:45 <Tekmo> Ok
18:43:00 <Tekmo> So let's say the isomorphisms are
18:43:23 <Tekmo> fw :: (F a -> b) -> (a -> G b)
18:43:31 <Tekmo> bw :: (a -> G b) -> (F a -> b)
18:43:36 <Tekmo> fw . bw = id = bw . fw
18:43:53 <Tekmo> Then you build Kleisli composition as
18:43:55 <Tekmo> 50/50 guess
18:44:00 <Tekmo> return = fw id
18:44:11 <Tekmo> f <=< g = fw (bw f . bw g)
18:44:32 <Tekmo> It's either that or switch fw and bw
18:44:57 <Tekmo> Let me think
18:45:06 <Tekmo> fw id :: a -> G (F a)
18:45:11 <Tekmo> Yeah, that's right
18:46:43 <byorgey> bw f . bw g  does not type check
18:47:11 <ddarius> Tekmo: Of course, you can also define a coKleisli category just as easily.
18:47:12 <dolio> ddarius: I guess that gives you the connection between the Kleisli category as objects with A ->MB morphisms and as the category of free algebras pretty nicely.
18:47:40 <byorgey> oh, sorry, yes it does
18:47:44 <Tekmo> :)
18:48:00 <Tekmo> Yeah
18:48:05 <Tekmo> So for CoKleisli it would be
18:48:08 <Tekmo> extract = bw id
18:48:16 <Tekmo> f =<= g = bw (fw f . fw g)
18:48:55 <Tekmo> So, in the more general case
18:49:18 <Tekmo> I suppose if your adjunction was over another category other than that of Haskell of function
18:49:28 <Tekmo> i.e.
18:49:44 <Tekmo> fw :: cat (F a) b -> cat a (G b)
18:50:00 <Tekmo> Then would it still be the same except you use composition from that category?
18:50:05 <shachaf> Hey, ddarius is back.
18:50:13 <Tekmo> Oh, byorgey
18:50:19 <Tekmo> You're at Penn, right?
18:50:27 <ddarius> Tekmo: Yes.
18:50:30 <byorgey> Tekmo: yes
18:50:31 <Tekmo> It's a shame
18:50:38 <Tekmo> I was there until a year ago
18:50:54 <Tekmo> I never got a chance to meet you
18:51:05 <byorgey> oh! That is a shame.  I have been here for four years.
18:51:12 <byorgey> where are you now?
18:51:15 <Tekmo> Yeah, I was a graduate student there
18:51:27 <shachaf> All the cool people are at Penn, I hear.
18:51:27 <Tekmo> But my professor got a better offer from UCSF
18:51:32 <Tekmo> So I'm still getting my degree at Penn
18:51:35 <Tekmo> but working out in San Francisco
18:51:38 <byorgey> aha, I see
18:51:46 <Tekmo> This is my 4th year, too
18:52:10 <byorgey> will you need to physically come back to Penn for your defense?
18:52:13 <Tekmo> Yeah
18:52:16 <djahandarie> A haskell / category theory fan who was a graduate student at Upenn really never once met brent?
18:52:21 <Tekmo> In fact, I need to go there soon for a committee meeting
18:52:22 <djahandarie> That sounds very hard to believe
18:52:27 <byorgey> ok, well, let me know!
18:52:30 <Tekmo> Yeah
18:52:39 <Tekmo> I will stop by and meet you when I go there for my meeting
18:52:45 <byorgey> djahandarie: I don't understand how it's possible either
18:52:55 <byorgey> Tekmo: great! I look forward to meeting you
18:53:05 <djahandarie> Maybe there's an entirely seperate PL/CT club which none of you guys know about
18:53:16 <Tekmo> Nah
18:53:19 <Tekmo> It's pretty much just me
18:53:31 <Tekmo> Practicing category theory among a sea of infidels
18:53:32 <byorgey> hehe
18:54:01 * byorgey -> bed
18:54:41 <loreints> what does this stack trace mean?: http://hpaste.org/73760
18:55:22 <ddarius> loreints: It looks like main is a loop.
18:55:36 <ddarius> I think.
18:55:51 <Tekmo> Oh, that reminds me
18:55:59 <Tekmo> I have an idea I wanted to run by you guys
18:56:09 <Tekmo> It's something I came across inadvertently while working on pipes
18:56:10 <ddarius> I missed the >< in the middle.
18:56:27 <loreints> here is the code, I don't get how the case statement is creating this loop: http://hpaste.org/73758
18:56:48 <Tekmo> So one thing I noticed is that some monad transformers can define a principled way to lift the monad transformer over an outer monad transformer
18:56:58 <Tekmo> For example, the classic case is the EitherT monad transformer
18:57:05 <loreints> when I comment out the case statement it's fine, which makes me think that somehow it's executing something I don't understand
18:57:12 <Tekmo> if EitherT is the outermost monad transformer you have a catch/throw operation available to you
18:57:20 <Tekmo> If it's not, then you have to use something like the mtl
18:57:27 <Tekmo> to lift catch/throw over the outer transformers
18:57:48 <Tekmo> However, as far as I know, there's no clear equations for what constitutes a correct lifting
18:58:02 <Tekmo> but, while working on something similar for pieps
18:58:12 <Tekmo> I found a way, at least for EitherT, that you can prove a lifting is correct
18:58:31 <Tekmo> So the hpaste in question is right here:
18:58:32 <Tekmo> http://hpaste.org/73329
18:58:48 <Tekmo> Basically, the trick to proving a lifting is correct
18:59:29 <Tekmo> is to show that the "lift" operation from MonadTrans
18:59:43 <Tekmo> is a functor over several other categories
18:59:54 <Tekmo> Ok, let me step back a secon
19:00:04 <mapreduce> The first rule of category theory club is Don't write another monad tutorial.
19:00:21 <Tekmo> So, lift from MonadTrans defines a functor from the base monad's Kleisli category to the transformer monad's Kleislic ategory
19:00:26 <Tekmo> (lift .) return = return
19:00:36 <Tekmo> (lift .) (f <=< g) = (lift .) f <=< (lift .) g
19:00:47 <ddarius> loreints: I suspect it's just the fact that parseAll is not tail recursive and you are going byte by byte apparently.
19:01:06 <Tekmo> So that ensures that bind and return are lifted correctly
19:01:19 <Tekmo> However, if you want to lift other operations to the transformed monad
19:01:30 <Tekmo> You need to formulate those operations as categories
19:01:46 <Tekmo> and then show that the lift operation is a functor from those categories to the corresponding transformed ones
19:02:04 <Tekmo> I'll use specific examples from the hpaste
19:02:20 <Tekmo> So, one property of EitherT is that it's a monad over the flipped type variables, too
19:02:24 <Tekmo> i.e.
19:02:42 <Tekmo> throw = flipEither . return
19:03:01 <Tekmo> catch m f = flipEither (m >>= (flipEither . f))
19:03:12 <Tekmo> with the usual monad laws
19:03:27 <Tekmo> So, if lift were to preserve that category
19:03:49 <Tekmo> You would say that:
19:03:55 <Tekmo> (lift .) throw = throw
19:04:10 <Tekmo> define (<|<) as the catch equivalent to (<=<)
19:04:22 <Tekmo> (lift .) (f <|< g) = (lift . f) <|< (lift . g)
19:04:29 <Tekmo> But there's still more
19:04:40 <Tekmo> That's not the only property the transformer must preserve
19:05:09 <Tekmo> For example, another important property of EitherT is that a "left" aborts the normal onad
19:05:15 <Tekmo> and that "return" aborts the symmetric monad
19:05:22 <Tekmo> You can formulate that categorically as
19:06:08 <Tekmo> (fmap .) returnE = returnE
19:06:10 <Tekmo> Sorry
19:06:14 <Tekmo> (fmap .) throw = throw
19:06:24 <Tekmo> Sorry
19:06:31 <Tekmo> (fmap k .) throw = throw
19:06:55 <Tekmo> (fmap k .) (f <|< g) = (fmap k . f) <|< (fmap k . g)
19:07:01 <Tekmo> And if you define a symmetric fmapE
19:07:07 <Tekmo> You have the symmetric equations
19:07:27 <Tekmo> (fmapE k .) (f <=< g) = (fmapE k . f) <=< (fmapE k . g)
19:07:37 <Tekmo> (fmapE .) return = return
19:07:55 <Tekmo> So all you have to do to prove a lifting is correct
19:08:15 <Tekmo> Is to show it behaves as a functor from the base Kleisli category to the lifted Kleisli category
19:08:31 <Tekmo> show it behaves as a functor from the base flipped Kleisli category to the flipped lifted Kleisli category
19:08:43 <Tekmo> and show that it observes those last functor laws
19:08:53 <Tekmo> given that those functor laws were true for the base Kleisli category
19:09:12 <Tekmo> So you end up with an equationally principled way to lift monads over their outer monad transformers
19:09:31 <Tekmo> and prove that an "mtl-style" lifting is correct
19:10:07 <Dashkal> I find myself wanting to invent the dual to hlists (disjoint types generalized over arity).  Can someone point me in the direction of existing research here?  It seems unlikely that this hasn't been done.
19:10:36 <ddarius> Dashkal: You can look at HList.
19:11:15 <Dashkal> I actually have no idea how to render an hlist in haskell
19:11:25 <Dashkal> The context here is scala, but I'd rather implement here first then port.
19:11:38 <Dashkal> ambigious statement is ambigious
19:12:35 <Dashkal> ok, got some resources.  away with me
19:12:50 <Dashkal> paywall...
19:14:15 <Dashkal> Has this really not been done yet?  Interesting.
19:14:26 <ddarius> Dashkal: It's done in HList.
19:14:41 <ddarius> It's been done multiple times over at least like 17 years.
19:14:48 <ddarius> Dashkal: You realize a "hlist" is just a nested sequence of pairs.  At a basic level, the only thing (for those) that HList provides is type level computations for doing concatenation etc.
19:15:05 <loreints> ddarius: thanks!
19:15:30 <ddarius> Dashkal: The problem you'll likely have in Scala is not how to represent HLists, that's trivial, it's how to do type level calculations.
19:15:45 <Dashkal> I know how to do type level folding in scala thanks to a good set of articles.
19:16:28 <Dashkal> I'm just trying to put the pieces together.  I know this is representable.  But again, I'm content to start in haskell.  Cleaner type system to get the concept down.
19:16:39 <Dashkal> So much noise in scala...
19:17:20 <ddarius> Tekmo: You may find these interesting if you haven't already watched them: http://www.youtube.com/playlist?list=PLEC25F0F5AC915192
19:17:21 <edenc> scala is noisy indeed, hate it
19:17:53 <Dashkal> Sadly, the project I want to apply this concept to is on the JVM, so far that means Scala.
19:18:20 <Tekmo> ddarius: Thanks, I will check that out
19:18:27 <Dashkal> I want to see if I can use this to handle arbratrary sets of possible exceptions.  Make the subtyping tree vanish in a puff of smoke.
19:19:58 <danharaj> Can trace give incorrect output for pure values?
19:20:10 <shachaf> Debug.Trace trace?
19:20:14 <danharaj> yes
19:20:15 <jmcarthur> what do you mean by incorrect?
19:20:20 <shachaf> I wouldn't call anything trace does "incorrect".
19:20:41 <jmcarthur> shachaf: because you wouldn't call anything it does "correct" either
19:21:02 <shachaf> jmcarthur: Well, yes. :-)
19:21:11 <shachaf> I mean that trace's behavior isn't really specified.
19:21:13 <danharaj> I have a function that produces the correct output when tested in ghci but is giving garbage results in another function, and when I trace its arguments and its outputs in that function, it is just wrong.
19:21:20 <shachaf> The compiler is free top optimize it in all sorts of strange ways.
19:21:27 <shachaf> What's just wrong?
19:21:30 <ddarius> Ugh, the way Variant is actually implemented in HList is disgusting.
19:21:35 <jmcarthur> yeah that sounds like it's just the optimizer
19:21:36 <shachaf> You mean you do "trace x" and it prints a value that x should never end up being?
19:21:54 <jmcarthur> ah yeah, if it actually prints something wrong then that sounds more buggy
19:21:55 <shachaf> I wouldn't expect that to ever happen with Debug.Trace.
19:22:03 <danharaj> yes
19:22:11 <jmcarthur> but if it's just a matter of printing or not printing then i wouldn't necessarily call it a bug
19:22:13 <ddarius> Dashkal: What's wrong with using the structural types already in Scala?
19:22:17 <danharaj> that is what is happening, also the algorithm is behaving as if the function is giving the wrong result.
19:22:27 <shachaf> It sounds to me like your code is wrong.
19:22:31 <jmcarthur> oh, then that sounds like the algorithm is wrong :)
19:22:51 <danharaj> The algorithm isn't wrong.
19:23:01 <jmcarthur> maybe you should hpaste this
19:23:26 <Dashkal> ddarius: Here's a use case.  I want to take a function that returns an a, but can throw one of e, f, g, and turn it into a function that returns Either a (e |:| f |:| g)
19:23:51 <danharaj> I will, but it probably will require more context than is economical.
19:24:02 <jmcarthur> ah
19:24:03 <Dashkal> or if prefered (a |:| e |:| f |:| g), but I suspect pulling the a out is clearer
19:24:25 <shachaf> What's the difference between |:| and Either?
19:24:41 <Dashkal> |:| chains to an arbratrary arity
19:24:42 <ddarius> Dashkal: Um, I wasn't asking you to justify why you a structural variant type, I was asking why you don't already use the structural typing that Scala provides rather than reinvent your own structural types?
19:24:44 <danharaj> http://hpaste.org/73761
19:24:48 <jmcarthur> Dashkal: i'm guessing you're wanting the lifting to be automatic without you having to specify which injection to use?
19:25:24 <danharaj> the trace in the second case of lookupR gives nonsensical results for r. When I paste (r0,r',r) into ghci and do intersect r0 r', I get the correct result for r.
19:25:47 <danharaj> So trace is lying to me and but I do not think it is trace's fault.
19:25:59 <Dashkal> ddarius: I can use structural types, but unless I'm missing some features of them I'd have to do the "plumbing" in every single function.
19:26:08 <jmcarthur> but what was this about the algorithm behaving as though the function is giving the wrong result?
19:26:22 <danharaj> It is returning leaves that aren't in the test rectangle.
19:26:54 <jmcarthur> only when compiled?
19:26:54 <shachaf> danharaj: Are you sure what you're running "intersect" on in ghci is the same as what you're running it on in the program?
19:26:55 <Dashkal> jmcarthur: ideally, but I think I may need to head into macro/template territory to generate the appropriate try/catch blocks.  Less of a concern.  I'm more interested in the dual to hlists.  More general than just this one use case.
19:27:04 <danharaj> shachaf: yes, it is defined only in one place.
19:27:08 <danharaj> I checked everything.
19:27:21 <shachaf> Do you have an @paste that people can run in ghci? :-)
19:27:29 <ddarius> Dashkal: In the vein of reinventing stuff, you realize to implement "arbitrary variants" a la HList, they would be just nested Eithers.
19:27:43 <Dashkal> ddarius: Much as hlists are really just nested tuples.  Yes
19:27:56 <danharaj> shachaf: I'll try to craft something up.
19:29:24 <Dashkal> as I read through type based indexing in hlists, this is looking like something I can use for sure.  Just not sure how to formulate inject in this language.
19:30:06 <Dashkal> in scala it'd be inject[(A |:| E |:| F |:| G), Four) :: G => (A |:| E |:| F |:| G).  Type level Four to look into the "HMaybe".
19:30:24 <Dashkal> Folding out would simply require an hlists of functions
19:31:52 --- mode: ChanServ set +o mauke
19:31:52 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by mauke
19:33:52 --- mode: mauke set -o mauke
19:34:22 <danharaj> shachaf: ok I annotated it with something self-contained http://hpaste.org/73761
19:36:47 <mauke> instance (Monoid a) => Monoid (Monad a) where { mempty = return mempty; mappend = liftM2 mappend }
19:36:52 <mauke> comments?
19:38:08 <Cale> mauke: itym  instance (Monad m, Monoid a) => Monoid (m a)
19:38:26 <mauke> well, it's more like "for any Monad Monad"
19:38:32 <Cale> ah
19:38:32 <mauke> it wouldn't actually work in practice
19:38:43 <Cale> right
19:38:52 <Cale> yes, you can do that
19:38:53 <Tekmo> Can't you just weaken it to applicative?
19:39:18 <Tekmo> instance (Monoid a, Applicative f) => Monoid (f a)
19:39:28 <Tekmo> I believe this was discussed on reddit quite recently
19:39:31 <Tekmo> Let me get the link
19:39:45 <shachaf> danharaj: What's the correct and incorrect behaviour?
19:39:51 <Tekmo> http://www.reddit.com/r/haskell/comments/yqt89/is_this_monoid_instance_in_the_standard_library/
19:40:23 <mauke> Tekmo: clashes with []
19:40:33 <Tekmo> How so?
19:40:37 <jmcarthur> it's still a valid monoid
19:40:48 <shachaf> A different monoid, though.
19:40:50 <mauke> Tekmo: [] has a different Monoid instance
19:40:53 <jmcarthur> right
19:40:54 <shachaf> (The [a] instance is better, of course.)
19:40:54 <Tekmo> Right
19:40:56 <Tekmo> the reddit comment
19:40:58 <Tekmo> wraps it in a newtype
19:41:03 <Tekmo> Read the link
19:41:13 <Tekmo> instance (Applicative f, Monoid a) => Monoid (WrappedApplicative (f a)) where
19:41:50 <shachaf> danharaj: You should write types. :-(
19:41:51 <danharaj> shachaf: test does a lookup on a rectangle that is 1 cell large at coordinate (1,0), and the only thing in the quadtree is at (1,3), so the lookup should return []. The trace returns three rectangles (r0, r', r), and r = intersect r0 r', but by examining the trace output it's totally not true.
19:41:52 <jmcarthur> i don't know. i wouldn't mind using Alternative for the current behavior of the [] monoid, really
19:42:01 <danharaj> shachaf: yes. yes I should.
19:42:25 <jmcarthur> i dunno. it's convenient as it is, too
19:44:06 <Tekmo> ddarius: Thanks again for the Distributive Law link.  These are really good
19:44:09 <shachaf> danharaj: I'm not sure I see the inconsistency.
19:44:17 <shachaf> Œª> let (r0,r',r) = (Rect {_pos = Pos 1 3, _ext = Ext 1 1},Rect {_pos = Pos 1 0, _ext = Ext 1 3},Rect {_pos = Pos 1 2, _ext = Ext 1 2})
19:44:35 <shachaf> Main.intersect r0 r' -- => Rect {_pos = Pos 1 2, _ext = Ext 1 2}
19:46:00 <ddarius> jmcarthur: I don't know.  It's hard to justify [a] having a monoid instance other than the one it has as the default.
19:46:11 * shachaf wonders whether you're supposed to use Control.Lens.Internal.coerce
19:46:22 <ddarius> shachaf: No.
19:46:28 <edwardk> shachaf: what has left you in a place where you need it?
19:46:35 * ddarius doesn't know what it is, but is pretty sure the answer is "no."
19:46:41 <shachaf> edwardk: I don't. danharaj is using it.
19:46:44 <edwardk> ddarius: its safe
19:46:58 <danharaj> I used it to define some indexedLenses because the compiler complained about rigid type variables.
19:47:03 <shachaf> It's just the phantom argument, right?
19:47:07 <ddarius> edwardk: Safe doesn't mean it should be used.
19:47:07 <danharaj> yeah.
19:47:11 <shachaf> For functors like Const.
19:47:13 <edwardk> yeah
19:47:27 <edwardk> class Functor f => Gettable f where coerce :: f a -> f b
19:47:38 <edwardk> danharaj: do you have an example?
19:47:45 <ddarius> danharaj: Okay.
19:47:57 <ddarius> er edwardk
19:48:25 <edwardk> danharaj: you should be able to use ifolded and ifolding in 2.5 to build them without mucking around in internals like that
19:48:34 <edwardk> i'm about to push 2.5 out the door now
19:48:35 <ddarius> edwardk: Why did I think Scala had free universals (sanely)?  I think I was confusing it with Obsidian.
19:48:37 <edwardk> just doing a last pass over the docs
19:48:57 <shachaf> edwardk: (Do you have a hilight on "lens"?)
19:49:18 <edwardk> yes =P
19:50:03 <ddarius> (er, I guess Quest was what I was thinking I might be thinking of, not Obsidian.)
19:50:35 <edwardk> i don't know what Quest or Obsidian are
19:50:37 <shachaf> Are you sure you were thinking of what you think you were thinking of?
19:51:23 <ddarius> If I'm not mistaken, Quest was a research language that Luca Cardelli worked on that had a pretty rich type system (but no inference.)
19:51:45 <ddarius> But I could have sworn there was another such language that Luca worked on that started with an "O".
19:52:58 <edwardk> danharaj: i just pushed 2.5 out to hackage. it should have ifolded and ifolding in it so you no longer have to hand roll indexed traversals
19:53:08 <shachaf> edwardk: :-(
19:53:14 <edwardk> danharaj: let me know if you still feel the need to use coerce after that
19:53:16 <shachaf> I just installed 2.4.0.4 to run danharaj's thing.
19:53:36 <edwardk> then uninstall and install 2.5 ;)
19:53:38 * shachaf can't keep up with the lenses.
19:53:49 <shachaf> "uninstall"? What does that word mean?
19:53:53 <shachaf> I'm using cabal here.
19:53:56 <edwardk> you do realize this is the first undate i've shoved to hackage in a week or so
19:53:59 <edwardk> er update
19:54:10 <edwardk> you just have crap timing
19:54:43 <shachaf> One of us does, at least.
19:54:44 <edwardk> anyways 2.5 is a huge jump
19:54:47 <shachaf> It deppends on your perspective.
19:54:56 <shachaf> 2.5 has the new plate thing?
19:55:02 <edwardk> you get all the uniplate goodness, yeah
19:55:07 <edwardk> and TraversableWithIndex, etc.
19:55:19 <shachaf> match_co baling out <ghc-prim:GHC.Types.Int{(w) tc 3J}>
19:55:22 <edwardk> so you don't need to use a dozen different traverseList, etc.  combinators
19:55:29 <edwardk> those are harmless doc things
19:55:43 <ddarius> Any recommendations for a linear algebra library that is not GPL, that is reasonably pleasant to use, uses good algorithms and implementations, and just needs basic matrix/vector code up to matrix inversion (and/or LU,QR,SVD)?
19:55:46 <edwardk> it doesn't like generating the haddocks for things with (c ~ d) constraints
19:56:02 <edwardk> ddarius: write one. i'll use it
19:56:15 <dolio> I thought you were writing one.
19:56:17 <dolio> Oh waiat.
19:56:19 <edwardk> ddarius: or better yet, just contribute the code you need to linear and we can ship it ;)
19:56:30 <ddarius> Where is linear?
19:56:35 <edwardk> github.com/ekmett/linear
19:56:41 <edwardk> i've been working on it slowly with acowley
19:56:44 * hackagebot lens 2.5 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-2.5 (EdwardKmett)
19:56:54 <edwardk> its mostly the low dimensional linear algebra stuff from my started physics package
19:56:55 <lightquake> lens keeps getting updates!
19:56:55 <ddarius> Though, the problem is I'm happy enough with hmatrix, I just don't want a GPL dependency just because I don't want to write a matrix multiplication/inversion routine.
19:56:58 <edwardk> quaternions, etc.
19:57:09 <edwardk> lightquake: the benefits of an active maintainer ;)
19:57:56 <shachaf> How are you supposed to make a Plated instance?
19:58:00 <edwardk> ddarius: its not yet to the point where i want to shove it to hackage, its mostly the stream of consciousness worth of code i had in physics, plus some stuff acowley contributed so he could use it
19:58:08 <johnw> edwardk: when I try to install lens, I get this: https://gist.github.com/3485191
19:58:09 <shachaf> Oh, plate = Data.Data.Lens.uniplate?
19:58:11 <johnw> should I be concerned?
19:58:24 <edwardk> import Data.Data.Lens; instance Plated Foo where plate = uniplate
19:58:29 <shachaf> edwardk: That looks suspiciously like it has something to do with data-lens.
19:58:51 <shachaf> You should separate the code out into a package called data-data-lens.
19:58:53 <edwardk> johnw: those are fine, force-reinstalls and reinstall those packages
19:59:02 <edwardk> shachaf: =) thought about it
20:00:21 <ddarius> edwardk: I'm more looking at moderately large matrices, i.e. N = 10-100 or so.
20:00:34 <edwardk> basically Data.Data.Lens exports the smart data traversals that uniplate had, except they are faster here
20:01:20 <edwardk> hand written uniplate instances  and hand written plates are within the margin of error of each other. the data versions are about 25% faster using plated than uniplate
20:01:50 <lightquake> sigh, every time i use the unsafeperformio hack for iorefs i feel dirty
20:02:02 <ddarius> lightquake: Stop doing that then.
20:02:13 <lightquake> but it's so convenient!
20:02:21 <ddarius> lightquake: ...
20:02:22 <johnw> i think it's meant to feel dirty
20:02:29 <johnw> what are you doing that requires it?
20:02:32 <Tekmo> Why are you using unsafeperformIO for iorefs?
20:02:42 <Tekmo> Do you hate the Reader monad?
20:02:43 <ddarius> Tekmo: To implement global mutable variables.
20:02:46 <johnw> i still haven't had a need for unsafePerformIO yet
20:02:46 <Cale> There are not many good reasons to ever do that
20:03:09 <johnw> I've used the io-storage packgae to simulate global mutables
20:03:11 <Tekmo> Why not just use State?
20:03:20 <lightquake> i need IORefs because i'm using OpenGL/GLUT
20:03:29 <lightquake> and i need to share a world variable between the keyboard callback and the display callback
20:03:43 <shachaf> y <- return $ fromParseResult $ unsafePerformIO  $ parseFile x
20:03:44 <ddarius> lightquake: That doesn't mean they need to be global.
20:03:45 <Tekmo> Then
20:03:48 <Tekmo> You pass both of them
20:03:54 <Tekmo> a reference to the same IORef
20:03:59 <Tekmo> and have them mutate it as necessary
20:04:03 <lightquake> well, right
20:04:07 <lightquake> i'm not actually using it now
20:04:11 <loreints> is there an easy way to find incorrect indentation (cli tool/emacs specific)?
20:04:15 <lightquake> but i feel like at some point in the future i might need to
20:04:27 <ddarius> loreints: No, because the compiler can't read your mind.
20:04:30 <lightquake> johnw: io-storage uses unsafePerformIO internally ;)
20:04:34 <ddarius> s/compiler/tool/
20:04:43 <johnw> oh, haha
20:04:46 <danharaj> shachaf: The bug was a function I don't remember changing that was changed in the last two hours.
20:04:46 <loreints> not fix it, just find it
20:04:56 <danharaj> I am going to blame cosmic rays.
20:04:59 <johnw> well, as long as I'm not using it ;)
20:04:59 <ddarius> loreints: I didn't say anything about fixing.
20:05:03 <Cale> lightquake: Just pass the same IORef as a parameter to both of the callbacks while setting them.
20:05:16 <Cale> lightquake: and then you don't need unsafePerformIO
20:05:18 <lightquake> Cale: right, right, that's what i'm doing no
20:05:21 <lightquake> *now
20:05:34 <ddarius> Then the unsafePerformIO hack is doing its job.
20:06:28 <Cale> lightquake: So, you're currently *not* using unsafePerformIO? Why are you tempted to do it? :)
20:06:37 <loreints> ddarius: so no tools outside of the compiler being able to compile?
20:06:37 <lightquake> i'm not... right now
20:06:50 <Cale> You can also define a data structure for all the various things that your callbacks share.
20:06:55 <lightquake> ddarius: i think loreints is asking for detecting indentation that cannot possibly be valid
20:07:06 <ddarius> lightquake: The compiler already does that.
20:07:09 <Cale> In case you're worried about proliferation of parameters
20:07:25 <danharaj> why is this coming up in my compilation logs: match_co baling out     <( i{tv i4V4} [tv] :: ghc-prim:GHC.Prim.*{(w) tc 34d} )>
20:07:37 <Clint> mm_freak_: gotcha
20:07:40 <Tekmo> I had that happen to me, too
20:07:41 <ddarius> loreints: There are tools that will probably give some other warnings/messages when it comes across code that will no doubt be silly if the indentation is wrong, such as hlint, but they won't say "wrong indentation"
20:07:47 <wywy> hello, is it a good style to write this knd of list comprehension (using "let"): [bmi | (w, h) <- xs, let bmi = w / h ^ 2]  ?
20:08:12 <Cale> wywy: So long as you're aware that you can do that without let
20:08:24 <Tekmo> Also, you can use map
20:08:32 <Tekmo> map (\(w, h) -> w / h^2) xs
20:08:36 <ddarius> loreints: Also, if you are using tabs you can either (1) stop, or (2) have your editor highlight (bad) mixes of tabs and spaces that are the cause of a lot of, not immediately obvious, indentation related errors.
20:08:50 <lightquake> i recommend (1)
20:08:59 <johnw> @pl map (\(w, h) -> w / h^2) xs
20:08:59 <lambdabot> map (uncurry ((. (^ 2)) . (/))) xs
20:09:02 <ddarius> Otherwise, the compiler is pretty close to the error when you mess up indentation and it's usually pretty obvious to see.
20:09:06 <wywy> Cale: well, I mean, in a "general" sense ?
20:09:23 <lightquake> wywy: in general, i'd use map for that
20:09:30 <Tekmo> Good style is whatever you can get away with
20:09:36 <wywy> It looks confusing... because that doesn't look like a normal let
20:09:38 <hpaste> edwardk pasted ‚Äúhigher order bound‚Äù at http://hpaste.org/73764
20:10:01 <wywy> Tekmo: I don't believe you :-P
20:10:04 <Cale> wywy: It's part of the Haskell syntax, and not the same thing as  let <decls> in <expr>  -- though it translates into one.
20:10:37 <ddarius> edwardk: Did you do something with that yet?
20:11:00 <edwardk> someone was asking about indexing into an hlist, so i wanted the example
20:11:09 <Jesin> [23:08:40]	lambdabot	map (uncurry ((. (^ 2)) . (/))) xs
20:11:09 <wywy> Cale: so my guess was right. I just wonder whether this is encouraged or discouraged
20:11:10 <Cale> wywy: In general, there are a lot of cases where you might want to use let inside a list comprehension -- that's not really one which really requires it in your case.
20:11:11 <Jesin> lol
20:11:11 <edwardk> (was in scalaz)
20:11:20 <Cale> wywy: But it's in the language for a reason
20:11:21 <Jesin> the @pl command is not a good coding style guid
20:11:23 <Jesin> e
20:11:24 <Jesin> :p
20:11:39 <lurchwurm> what is the best example of haskell being used in professional software engineering?
20:11:44 <edwardk> ddarius: been too busy playing with the machines package and lens to do much on arcade
20:11:47 <ddarius> edwardk: Did Runar put the crazy hacky universal stuff into Scalaz or does Scalaz already have some thing?
20:11:52 <Tekmo> wywy, are you familiar with the relationship between list comprehensions and the list monad?
20:11:56 <edwardk> universal stuff?
20:12:03 <ddarius> edwardk: Free foralls.
20:12:17 <edwardk> oh thats a scalaz thing runar added at some point
20:12:17 <wywy> Cale: In fact I have a general questions about list comprehensions. Are they really the same as map, filter, ...?
20:12:37 <ddarius> wywy: No, they are really concatMaps.
20:12:38 <Tekmo> List comprehensions translate to the list monad
20:12:48 <Tekmo> And they are effectively equivalent
20:12:50 <Cale> wywy: they're the same as a bunch of concatMaps
20:12:59 <Tekmo> Do you understand how the list monad works?
20:13:02 <ddarius> @undo [f x | x <- g y; x > 10]
20:13:02 <lambdabot>  Parse error at ";" (column 16)
20:13:07 <ddarius> @undo [f x | x <- g y, x > 10]
20:13:07 <lambdabot> concatMap (\ x -> if x > 10 then [f x] else []) g y
20:13:14 <Cale> wywy: http://www.haskell.org/onlinereport/exps.html#list-comprehensions
20:13:28 <Cale> See the section marked "Translation"
20:14:11 <wywy> Cale: alright. concatMap is what I meant... what I really wanted to see is whether list comprehension can buy me more than concatMaps
20:14:30 <Cale> wywy: It can't, but it can be clearer than a bunch of nested concatMaps to read
20:14:33 <Tekmo> Here's an example
20:14:37 <Tekmo> Let's say you write:
20:14:47 <Tekmo> [f x | x <- xs]
20:15:01 <Tekmo> @undo [f x | x <- xs]
20:15:01 <lambdabot> concatMap (\ x -> [f x]) xs
20:15:12 <Tekmo> concatMap = concat . map
20:15:15 <Tekmo> So we can rewrite that was
20:15:17 <shachaf> @@ @undo @src catMaybes
20:15:17 <lambdabot>  ()
20:15:19 <Cale> @undo [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
20:15:20 <lambdabot> concatMap (\ x -> concatMap (\ y -> concatMap (\ z -> if x ^ 2 + y ^ 2 == z ^ 2 then [(x, y, z)] else []) [y .. 20]) [x .. 20]) [1 .. 20]
20:15:25 <wywy> Cale: what if the compiler generates parallel code for list comprehensions? Since it is a special syntax, it is reasonable to do so I guess.
20:15:30 <shachaf> lambdabot: Impressive.
20:15:32 <shachaf> @src catMaybes
20:15:32 <lambdabot> catMaybes ls = [x | Just x <- ls]
20:15:41 <shachaf> @undo catMaybes ls = [x | Just x <- ls]
20:15:42 <lambdabot> catMaybes ls = concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) ls
20:15:55 <Cale> wywy: It doesn't. I suppose it could, but often that would just result in worse performance.
20:16:17 <Tekmo> That would be equivalent to parallelizing concatMap
20:16:37 <Cale> The tricky part is getting the right amount of granularity
20:17:00 <pharaun> is there a good data type for representing "Either X or Y" but is not the Either, cos that's usually used with error/correct result
20:17:02 <wywy> Tekmo: but concatMap has a function definition and will take substantial more effort in dependency analysis
20:17:08 <Cale> There's a lot of work going into a new feature in GHC called Data Parallel Haskell
20:17:09 <pharaun> or am i just going to have to create my own data def for this?
20:17:18 <Cale> which gives you a new datastructure called parallel arrays
20:17:40 <ddarius> wywy: Not really, no.
20:17:50 <Cale> They're strict arrays with a list-comprehension-y syntax, and operations on them automatically parallelise in a load-balancing way.
20:17:58 <ddarius> List comprehension syntax does not really make things any clearer to the compiler.
20:18:24 <edwardk> shachaf: i went and decided to rip out all the uniplate-like boilerplaty instances for Plated that were just saying 'no children' at the last minute. i should probably go through and spend some time writing uniplate style code with this system to see how i like it
20:18:42 <wywy> ddarius: It seems to me that it at least get around the definition of map
20:18:59 <edwardk> i like the fact that because you can work with explicit traversals polymorphic instances aren't a problem, unlike with traditional uniplate
20:19:02 <ddarius> wywy: I'm not sure what that sentence is intended to mean.
20:19:06 <roconnor> Does GHC's rebindable do syntax make it possible to work with an indexed state monad with do notation?
20:19:11 <Tekmo> Yes
20:19:12 <edwardk> roconnor: yes
20:19:12 <shachaf> I've never written code with Uniplate, only with SYB.
20:19:15 <Tekmo> See, index-core library
20:19:18 <roconnor> oh nice
20:19:19 <Tekmo> where I implement this
20:19:20 <wywy> ddarius: well what ever :)
20:19:26 <Tekmo> and import Control.IMonad.Do
20:19:29 <Tekmo> and extensions
20:19:59 <ddarius> wywy: It's easier (very slightly) for the compiler to recognize a map as map than a particular form of list comprehension as map.
20:20:02 <wywy> speaking of parallelism, anybody knows what was going on with pH ?
20:20:27 <Tekmo> Also, wywy, I'd recommend at least practicing using map
20:20:29 <Cale> wywy: Well, usually the list comprehensions translate *into* applications of map (or concatMap anyway), but you can do it the other way around. I think perhaps Hugs does, or did at one point.
20:20:44 <Tekmo> A list comprehension is not easy to decompose into smaller functions
20:20:53 <Tekmo> But if you learn to write things in terms of smaller list functions
20:20:57 <Tekmo> like take, map, etc.
20:21:00 <Cale> I seem to recall seeing a Prelude for Hugs with  map f xs = [f x | x <- xs]
20:21:02 <wywy> Tekmo: I know how to translate that into map actually :-)
20:21:09 <Tekmo> RIght, the point, though is
20:21:15 <Tekmo> Your programs will be moer decomposable
20:21:22 <Tekmo> if you stick to functions like map rather than use list comprehensions
20:21:28 <Tekmo> whenever it's possible
20:21:32 <ddarius> Cale: That would just be defining map in terms of concatMap, if Hugs used the Report translation.
20:21:41 <ddarius> Actually, the Report may even define map that way.
20:21:42 * ddarius checks.
20:21:51 <wywy> Tekmo: so you prefer map than list comprehensions?
20:21:57 <Tekmo> Yes
20:21:57 <Cale> ddarius: I suppose it would :)
20:22:37 <wywy> Tekmo: I kinda think in the same way as you, although I'm self-doubting. haha
20:23:08 <Tekmo> Think of it this way
20:23:14 <Tekmo> List comprehensions are just the list monad in disguise
20:23:21 <Tekmo> If you use the list monad, then a list comprehension is appropriate
20:23:27 <wywy> Tekmo: I guess list comprehension originated from an over-belief in the syntax of mathematics
20:23:32 <Tekmo> but if you aren't using the monad instance and you just need thef unctor instance, then just use the functor
20:23:35 <ddarius> Cale: The Haskell 98 Report uses the explicit recursive definition.
20:23:53 <Jesin> [23:20:40]	Cale	I seem to recall seeing a Prelude for Hugs with map f xs = [f x | x <- xs]
20:23:54 <Jesin> :(
20:24:06 <ddarius> Jesin: ?
20:24:20 <lightquake> edwardk: do you have any suggestions for dealing with not shadowing lens names?
20:24:26 <Jesin> that's backwards
20:24:31 <Cale> List comprehensions are good in any case that you have more than one generator, or you're making use of the fact that elements which don't match a pattern on the left of <- get skipped.
20:24:43 <Tekmo> Speaking of which
20:24:44 <wywy> I guess my pH questions was swamped... anybody knows whether pH has developed into something else or just died?
20:24:53 <Cale> For example, it's sometimes nice to be able to write something like [e | Left e <- xs]
20:24:54 <ddarius> Jesin: It's probably the most compact definition of map you can make.  List comprehensions desugar into concatMap.
20:24:56 <Tekmo> Shouldn't Alternative or MonadPlus replace fail?
20:25:03 <ddarius> Tekmo: See Haskell 1.4.
20:25:17 <edwardk> Tekmo: when you feel comfortable with it. turning on {-# LANGUAGE PolyKinds #-} in index-core would actually let me use it in some code ;) even if its only with an if impl(ghc >=7.4.1) or if impl (ghc >= 7.6)
20:25:26 <Cale> Also, it's handy to use the trivial case of a list comprehension with no generators but with one condition sometimes
20:25:35 <Tekmo> I wouldn't mind at all!
20:25:37 <Jesin> ddarius: yeah... isn't concatmap defined in terms of concat and map?
20:25:38 <Cale> [x | someCondition]
20:25:42 <Tekmo> But you have to be more specific
20:25:46 <edwardk> lightquake: you mean the compiler complaints?
20:25:46 <ddarius> Jesin: In the Report, yes.
20:25:51 <Cale> is a list which is empty if the condition fails, and has x in it otherwise
20:26:26 <Tekmo> Also, should I just change it to "natural transformation core"?
20:26:29 <ddarius> Jesin: But if you implement concatMap, you get concat, map, filter quickly and with brief syntax
20:26:29 <edwardk> Tekmo: basically its just that. adding the language pragma there to the cabal config under extensions on ghc >= 7.4.1 would make it so the kinds of he indices can be things other than kind *
20:26:33 <Tekmo> Because none of it is really specific to indices
20:26:48 <ddarius> filter p xs = [x | x <- xs, p x]
20:27:00 <Tekmo> Oh, so PolyKinds does that automatically?
20:27:02 <lightquake> edwardk: no, i mean 'what do i call the things so i don't shadow?'
20:27:02 <wywy> Cale: I'll keep that in mind and see if it looks better
20:27:03 <edwardk> yes
20:27:18 <Tekmo> Alright, let me try that out
20:27:39 <edwardk> lightquake: oh, my usual rule of thumb with lenses is to talk about them more declaratively, or in past tense. and failing everything else just prefix them with an _ because that is a portion of the namespace nobody uses ;)
20:27:44 <lightquake> like, i'm kind of loath to do data Position = Position { _x :: Int, _y :: Int } because then i can't use x or y as variable names without shadowing the lenses
20:27:57 <edwardk> e.g. i have lenses for _x, _y, _z in my linear package
20:28:00 <Tekmo> Use "_" to prefix them
20:28:04 <Tekmo> It's the one true way
20:28:07 <wywy> conclusion: pH is completely forgotten ;-)
20:28:32 <edwardk> lightquake: use __x, __y and then you get lenses _x and _y ;)
20:28:46 <Cale> I hate underscores
20:29:00 <lightquake> ___xXx_lensluvr420_xXx___
20:29:06 <Cale> I don't know what it is about them, I just consider them typographically abhorrent
20:29:06 <ddarius> edwardk: What happens if I use _'foo?
20:29:12 <wywy> Cale: reminds me of __C
20:29:21 <Tekmo> I use underscores for the record definition
20:29:24 <Tekmo> and no underscore for the len
20:29:26 <Tekmo> *lens
20:29:32 <edwardk> ddarius: it gives you a compile time error
20:29:48 <edwardk> i tend to as well, unless the lens has unusually short names
20:29:56 <Cale> like the slugs which TeX places in the margin when it overfills a line
20:30:22 <edwardk> _e, _i, _j, _k make better lens names for working with quaternions though, because e i j and k are really valuable variable names ;)
20:30:59 <edwardk> and being able to just write q^._i  to extract is nice
20:31:07 <Tekmo> I keep every lensed type in its own module
20:31:09 <Tekmo> So I can namespace them
20:31:11 <wywy> Is there anything in Haskell equivalent to "cond" of Lisp?
20:31:20 <ddarius> wywy: lookup
20:31:20 <johnw> case of
20:31:24 <ddarius> Or case
20:31:50 <johnw> but if you mean a series of predicates, then no
20:31:52 <wywy> but you need patterns for case of
20:32:02 <Cale> case () of _ | ...
20:32:04 <johnw> you could use the Maybe Monad for that
20:32:06 <Tekmo> multiway if!
20:32:07 <ddarius> case () of _ | cond1 = .. | cond2 = ..
20:32:15 <johnw> pattern matching with guards is close to cond
20:32:24 <lightquake> the problem that i'm running into right now is that i have a World datatype which contains a _player record, but i'm also going to want to write functions that take in a player value
20:32:34 <johnw> let x | y > 10 = x + y
20:33:03 <ddarius> lookup True [(cond1, ..), (cond2, ..)]
20:33:30 <johnw> ddarius: yeah, that would be the closest
20:33:38 <wywy> ddarius: cool. a little ugly but it works
20:33:40 <johnw> you want a series of predictase that returns the result associated with that predicate
20:33:58 <edwardk> lightquake: what about making the record field __player, the lens _player and then using player for the variable or adopting a single character convention for talking about the local player variable
20:34:16 <Tekmo> Two underscores is asking for trouble
20:34:31 <Tekmo> Visually hard to distinguish
20:34:46 <edwardk> yes, but the two underscored version need never been seen outside of the module
20:34:47 <ddarius> Tekmo: What font are you using?
20:34:47 <johnw> the case () of _ is probably cleaner
20:35:03 <Tekmo> Any font
20:35:08 <Tekmo> forall font
20:35:12 <Tekmo> You want it to be robust
20:35:23 <Tekmo> You NEVER KNOW
20:35:31 <lightquake> what if i'm using a font that only has one glyph, huh?
20:35:35 <edwardk> anyways you can name the member whatever you want, it doesn' thave to be tied to the name of the lens you can use makeLensesFor, etc. to rename fields arbitrarily
20:35:46 <wywy> I kind of think "cond" should be part of the syntax. Is has a finer granularity than patterns
20:35:57 <lightquake> edwardk: right, right
20:35:58 <ddarius> Tekmo: For all monospaced fonts, it will be pretty clear.  Clear enough certainly.  If you aren't using a monospaced font, you're wrong.
20:36:07 <Tekmo> The problem is not monospace
20:36:14 <Tekmo> It's if the underscores join into a single line
20:36:26 <lightquake> though to be honest i can't see me needing an explicit player variable and needing to keep around the player lens
20:36:28 <Tekmo> It's mentally taxing to read
20:36:29 <lightquake> that often
20:36:50 <Cale> wywy: but are you going to steal a keyword for it, or just have something like  cond = lookup True  in the Prelude?
20:36:58 <edwardk> lightquake: i usually just adopt one or two character variable names locally and then use the long names for lenses
20:37:17 <ddarius> wywy: if should probably be -removed- from the syntax.  There is no reason we should be adding cond.
20:37:25 <lightquake> yeah
20:37:26 <edwardk> Tekmo: its visually taxing in the precisely zero places outside of the record declaration that it occurs in your code =P
20:37:37 <Tekmo> That's true
20:37:50 <edwardk> so i don't see why its such a bugaboo for you =)
20:37:55 <Tekmo> Because I come from C
20:37:59 <Tekmo> and people abuse underscores
20:38:12 <Tekmo> So it's a reflex
20:38:13 <edwardk> i do to, but here its for a good cause ;)
20:38:20 <wywy> Cale: The issue I can think of "lookup True" is that "cond" is more fundamental than lookup..
20:38:22 <Cale> Use a different one-letter-prefix
20:38:26 <ddarius> edwardk: You abuse everything.
20:38:28 <lightquake> lPlayer?
20:38:33 <Cale> wywy: are you sure? :)
20:38:37 <edwardk> ddarius: i will take that as a compliment
20:38:49 <lightquake> you know what we need? if there are multiple variables in scope, but only one of them has a type that checks, it uses that one
20:38:56 <wywy> Cale: see... lookup has a function definition... which is recursive ...
20:38:58 <lightquake> what could possibly go wrong?!
20:39:03 <Cale> wywy: they seem interdefinable
20:39:14 <edwardk> lightquake: i tend not to like to mangle my lens names with arbitrary characters, _ is the one exception i allowed myself because it largely vanishes next to .
20:39:19 <Tekmo> lightquake: you mean a type class?
20:39:36 <edwardk> older lens packages (even my own used names like fooLens all over
20:39:38 <Cale> lookup x = cond . map (first (== x))
20:39:44 <edwardk> which was just awful when you strung them together
20:39:55 <ddarius> Tekmo: Not necessarily, because as he put it, it would need to backtrace in the equivalent of instance resolution.
20:40:04 <lightquake> Tekmo: no, i mean like... if i have player :: Player and player :: SomeOtherType, and only the former would typecheck, then it uses that one
20:40:15 <lightquake> if both typecheck, it errors out
20:40:21 <lightquake> it's like TDNR on krokodil!
20:40:48 <Tekmo> class NamedPlayer t where player :: t
20:40:48 <wywy> Cale: lookup has to use "cond" in some sense, so ...
20:41:17 <Tekmo> laws: It shall be named player
20:41:28 <wywy> Cale: there is a circular reasoning here ;-)
20:41:33 <lightquake> Tekmo: hahah
20:41:41 <ddarius> wywy: lookup doesn't use cond.  In Haskell (and in many ways generally) pattern matching is fundamental.
20:42:18 <wywy> ddarius: but sometimes you need guards, and cond is the guards
20:42:31 <ddarius> wywy: I can always reduce guards to pattern matching.
20:42:51 <Cale> Guards are really a bunch of pattern matching on Bool.
20:42:53 <ddarius> if b then t else e === case b of True -> t; False -> e
20:43:38 <wywy> ddarius: not really true in Haskell I guess. guards provides a finer granularity. for example how do you express the guard "x < 10000"?
20:43:48 <edwardk> Tekmo: alas, you can't make the lens for player an instance of that ;)
20:43:51 <Tekmo> case (x < 1000) of ...
20:43:52 <ddarius> wywy: That's not a guard, that's just an expression.
20:44:20 <wywy> f x | x < 10000 = ... | otherwise = ...
20:44:30 <Tekmo> edwardk: Do you have an example project I can crib from the cabal file for implementing the ghc-restricted extension?
20:44:38 <edwardk> Tekmo: sure
20:44:47 <ddarius> f x = case x < 10000 of True -> ...; False -> ...
20:44:49 <johnw> anybody know of a small to medium size subversion repository?
20:44:52 <johnw> i need something to build a test
20:44:58 <Cale> wywy: cases which match against complicated patterns and which have guards in them are all compiled down to nested cases which match against one data constructor at a time, some of which are matching against Bool.
20:45:20 <edwardk> https://github.com/ekmett/lens/blob/master/lens.cabal#L173    -- instead of saying other-extensions: Trustworthy say extensions: PolyKinds
20:45:57 <edwardk> other-extensions just says you might use it, extensions:  actually puts in effect for module
20:46:10 <wywy> Cale: I guess there is a devil in the "matching against Bool" part
20:46:21 <Cale> wywy: Why?
20:46:23 <edwardk> oh wow, i have needless parens in there, going to go excise them
20:46:49 <ddarius> In Haskell 2010, you could, theoretically, view pattern matching as a bunch of if tests provided things like isTrue, isCons, etc. were provided by the compiler.  However in more rich languages, including some GHC extensions, this fails.  The pattern matching provides information that couldn't be provided by an if statement.
20:47:15 <Cale> > let f x = case x < 5 of True -> "small"; False -> "big" in map f [1..10]
20:47:16 <lambdabot>   ["small","small","small","small","big","big","big","big","big","big"]
20:47:19 <Tekmo> For example, with pattern matching you can check if a function is total
20:47:35 <wywy> Cale: there involves complicated computation before it can be matched against True
20:47:43 <Tekmo> Plus it lets you bind the matched parameters
20:47:49 <Tekmo> For example
20:47:54 <Tekmo> consider if you are matching an Either
20:48:02 <Tekmo> If you use if statements
20:48:05 <Tekmo> You'd have to write
20:48:15 <Tekmo> if (isRight e) ... fromRight e <-- yuck
20:48:21 <Cale> wywy: Well, every guard has type Bool already, right?
20:48:53 <Cale> wywy: So you can translate the guards into a nested case expression, where if one fails, the next guard is matched on, etc.
20:48:55 <ddarius> Tekmo: Yes, but that's technically possible to do and get the same types in Haskell 2010.
20:49:03 <Tekmo> Is the cabal manual really out of date?
20:49:29 <dcoutts> Tekmo: yes, it doesn't even mention cabal-install
20:49:38 * dcoutts has started rewriting it
20:49:44 <Tekmo> Thanks!
20:50:00 <Tekmo> So I didn't quite understand the distinction between extensions and other-extensions
20:50:22 <edwardk> other-extensions was added in 1.10. it is intended to be a place where you mention every extension your package uses anywhere
20:50:23 <Cale> wywy: One sneaky little thing about the translation being the fall-through semantics of guards
20:50:24 <ddarius> The pattern calculus is an extreme example where attempting to reduce everything to if fails.
20:50:30 <wywy> Cale: hmm... the questions is getting philosophical. let me think for a while...
20:50:38 <edwardk> extensions: get turned on in every module for you
20:50:48 <edwardk> it was originally the only place to talk about them
20:50:54 <edwardk> but people like to turn them on module by module
20:50:58 <dcoutts> Tekmo: an old misfeature of cabal was that whatever you listed in extensions was passed to ghc for all modules, but that's not helpful when you have different extensions in different modules
20:50:58 <Cale> (but this isn't so hard to deal with, just makes the intermediate code a bit messy)
20:51:03 <edwardk> so it was split into default-extensions: and other-extensions:
20:51:13 <dcoutts> Tekmo: that feature dates from before the LANGUAGE pragma
20:51:29 <artelius> Hi, what's the best way to construct a copy of an MArray (or specifically an IOArray)?
20:51:54 <edwardk> default-extensions: are what you want to turn on everywhere, other-extensions are in theory the ones used anywhere in the package. some day dcoutts may with sufficient warning give us a way to enforce that every extension is named in other-extensions
20:52:06 <dcoutts> right
20:52:20 <dcoutts> think of other-extensions as a kind of dependency
20:52:22 <edwardk> the benefit then is that the cabal file would then be useful for documenting what language features a pckage needs
20:52:44 <dcoutts> and it does mean that cabal will check that the Haskell compiler actually supports the extension
20:52:47 <edwardk> in general i try to be good about using other-extensions everywhere for documentation purposes
20:52:48 <Cale> artelius: Looking at the documentation, it looks like  mapArray id  should work.
20:52:55 <ddarius> wywy: It's not even the case that the underlying system needs to do a compare and branch.  I can implement (regular) algebraic data types without having anything but functions.  GHC's implementation, in some cases, uses such a representation so that certain case analyses don't do any branching.
20:53:07 <edwardk> alas, it gets a little annoying when it gives warnings about extensions
20:53:26 <edwardk> because i have to debate between supporting a not-yet-terribly-active feature and having my users get warnings
20:53:39 <Tekmo> So how does it know where to use PolyKinds then without the LANGUAGE pragmas?
20:53:58 <edwardk> Tekmo: cabal passes the flag to ghc everywhere
20:54:24 <Cale> artelius: yes, that works
20:54:28 <wywy> ddarius: not sure what that means. can you give an example?
20:54:44 <Tekmo> So what's the difference when using extensions, then?
20:54:50 <Tekmo> I thought extensions also was applied everywhere
20:54:56 <artelius> @Cale: Thanks, that's what I was thinking
20:54:56 <lambdabot> Unknown command, try @list
20:55:07 <artelius> @Cale thanks, that's what I was thinking
20:55:07 <lambdabot> Unknown command, try @list
20:55:10 <dcoutts> Tekmo: the old extensions is deprecated, the new thing is default-extensions and other-extensions
20:55:19 <Tekmo> Or, default-extensions, then
20:55:28 <edwardk> my usual preference is to use something like: if impl(ghc>7.4) other-extensions: PolyKinds   and then manually use {-# LANGUAGE CPP #-} #if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ > 704       {-# LANGUAGE PolyKinds #-} #endif
20:55:35 <Cale> artelius: btw, if you want to direct a message at me, it's enough just to use my name, the @ sign isn't required.
20:55:36 <dcoutts> Tekmo: the behaviour of the old extensions field is the same as the new default-extensions
20:55:38 <edwardk> but that adds an annoying preamble to every module
20:55:42 <ddarius> wywy: It means I can implement Bool and if (and thus anything implementable with them) without doing a pattern match or "internal" if or compare CPU instruction ever.
20:55:44 <artelius> Thanks, that's what I was thinking but was wondering if something else was better
20:56:11 <Tekmo> The part I'm missing is what was wrong with the old behavior
20:56:13 <Tekmo> Since I never used it
20:56:23 <dcoutts> Tekmo: it "applied" the extension to every module
20:56:24 <Tekmo> I would always declare extensions using LANGUAGE pragmas
20:56:39 <edwardk> that ensures that cabal knows about the extension being used and that it only gets turned on in ghc, but its not very good from a minimal noise perspective or from future proofing in the presence of other compilers supporting polykinds.
20:57:11 <dcoutts> Tekmo: right, so then if you listed them in the extensions field too, then all your modules would be compiled using all those extensions in effect, and you would not be able to tell if you listed your LANGUAGE pragmas accurately
20:57:15 <edwardk> Tekmo: i always use LANGUAGE pragmas as well. the problem is that then the .cabal file doesn't know that someone who is using a compiler that doesn't support those pragmas can't compile your code
20:57:25 <artelius> I must work on my IRC-fu, I see
20:57:52 <dcoutts> Tekmo: so the right thing for you to do is to list them all in the other-extensions field
20:58:03 <wywy> ddarius: I guess I see what you mean. You mean you can define "if" as a function because Haskell is lazy?
20:58:04 <Cale> artelius: You could unsafeFreeze and then thaw or freeze and then unsafeThaw, and one of those two might be faster, but I don't know. It shouldn't be really significantly better, but I haven't profiled.
20:58:05 <Tekmo> Alright, I will do that and test to make sure it worked
20:58:15 <ddarius> wywy: Laziness has nothing to do with it.
20:58:33 <edwardk> Tekmo: extensions: would turn the on everywhere for all modules, but it was for the longest time the only place _to_ document what extensions you were using that cabal could see, hence the split
20:58:35 <Cale> ddarius: Well, it has something to do with it...
20:58:43 <wywy> ddarius: well if it's not lazy then both branches will be evaluated
20:59:01 <ddarius> wywy: I can make them functions.
20:59:19 <Tekmo> So default-extensions applies it everywhere, whereas other-extensions says that some files might use it, as indicated by LANGUAGE pragmas?
20:59:22 <ddarius> But yes, to make it look nice, laziness helps.  I was talking about the fundamental "choice" behavior.
20:59:23 <wywy> ddarius: any way I guess I see what you mean
20:59:27 <edwardk> Tekmo: exactly
20:59:43 <artelius> Cale: I suspect freeze then unsafeThaw makes more sense
20:59:48 <edwardk> Tekmo: but still indicates that it will be probably used somewhere so you better not try to build on a compiler that doesn't havethat extension
20:59:49 <Tekmo> So how will turning on PolyKinds work without the LANGUAGE pragmas?
20:59:51 <wywy> ddarius: but calling different functions according to different values is a kind of branching, I think
21:00:10 <edwardk> Tekmo: if impl(ghc>=7.4) default-extensions: PolyKinds
21:00:19 <Tekmo> Oh
21:00:25 <Tekmo> I thought you said to use other-extensions
21:00:28 <Tekmo> That was were I was confused
21:00:48 <edwardk> no, i was saying instead of using other-extensions, you can use extensions, but i should have said default-extensions for safety
21:00:54 <Tekmo> Ok
21:00:58 <Tekmo> Now everything is crystal clear
21:01:05 <artelius> Cale: from a safety perspective, that is
21:01:34 <dolio> wywy: True _is_ a function that returns its first argument, and False is one that returns its second.
21:01:58 <dolio> It is not doing any comparison or branching.
21:01:59 <edwardk> then i indicated that you _could_ go through with a longer preamble in every module that turned it on using the #if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ >= 704
21:02:12 <ddarius> wywy: If you want to take that view, that is still much closer to general pattern matchng and not to cond.
21:02:16 <edwardk> but that that becomes a tradeoff
21:02:38 <edwardk> i tend to prefer that model because it is more robust in the presence of someone just starting ghci in the project folder and using :load or :m + ...
21:02:49 <Cale> dolio: :)
21:02:50 <edwardk> that way the code still compiles when run from outside of cabal
21:03:00 <edwardk> but i'm also paranoid
21:03:09 <carter> edwardk: very nice for people playing with code to learn :)
21:03:11 <Cale> wywy: dolio is suggesting a possible implementation of data constructors which is not actually the one used by GHC
21:03:23 <Cale> wywy: (but it's a nice one nonetheless)
21:03:26 <dcoutts> edwardk: do you really use PolyKinds in such a way that it works with older ghc?
21:03:41 <ddarius> Cale: Actually, it is the one used by GHC for large sums.
21:03:48 <edwardk> dcoutts: the way it would apply in his code there would work fine in 7.4.1
21:03:54 <wywy> ddarius: That's a philosophical question :-) In a sense you are right. Anything including machine integers are matched against some patterns
21:04:09 <johnw> is there a module for reading xzip files, like Code.Compression.GZip?
21:04:17 <johnw> xz, lzma
21:04:34 <Cale> ddarius: How large?
21:04:34 <edwardk> dcoutts: basically he has a library that juts has a bunch of monads that take an extra type parameter
21:04:48 <Tekmo> It basically raises everything in Haskell one type variable
21:04:50 <edwardk> this simply enables it on newer ghc's to support that parameter having kinds other than *
21:04:56 <Tekmo> Oh, funny story
21:05:01 <Tekmo> I used the library to define free monad comprehensions
21:05:14 <ddarius> Cale: It depends on your CPU, but 3 or 7 (or 4 or 8?).
21:05:15 <Tekmo> Which reduce to list comprehensions when the functor is ((,) a)
21:05:27 <edwardk> Tekmo: btw- did you see the fact that i added the free monad transformer stuff to free?
21:05:32 <Tekmo> Yeah, I saw
21:05:37 <Tekmo> I will be switching to free fo rmy library
21:06:01 <edwardk> i kept your choice of base functor names to make sure it'd be as painless for you as possible
21:06:09 <Tekmo> Oh, don't worry about that
21:06:15 <Tekmo> The core code is incredibly small
21:06:21 <Tekmo> Control.Pipe is like 20 lines of code
21:06:26 <Tekmo> It's not a hard switch
21:06:29 <ddarius> @hoogle lzma
21:06:29 <lambdabot> package lzma-enumerator
21:06:31 <edwardk> also, did you get a chance to look at machines?
21:06:34 <Tekmo> Yeah, i did
21:06:45 <dcoutts> edwardk: ok, odd case where the same code compiles fine with and without the extra extension
21:06:48 <wywy> Cale: it's the same way as church encoding of "if". came to think of it. It is interesting... indeed I don't see "comparison" in it...
21:06:50 <Cale> ddarius: There's still an integer tag marking which constructor you have even if it's not using pointer tagging though, no? It's just that you have to follow the pointer (and execute the code there) to obtain it.
21:06:50 <carter> i'm excited about machines :)
21:06:52 <Tekmo> I assume you had the Plan type in mind
21:06:58 <edwardk> dcoutts: yeah the extension just helps users
21:07:01 <ddarius> edwardk: What are you using machines for?
21:07:17 <Tekmo> By the way
21:07:20 <Tekmo> The next release of pipes
21:07:26 <Tekmo> will have parsing and error handling
21:07:30 <dcoutts> edwardk: also slightly surprising that it needs to be used where the data is defined rather than just where it's used
21:07:32 <ddarius> Tekmo: ?
21:07:40 <edwardk> ddarius: dolio and Apocalisp ported it to scala and are using it to do lots of sql munging in memory, copumpkin is looking at it for portfolio valuation, etc.
21:07:41 <Tekmo> and a non-indexed finalization
21:07:56 <Cale> I didn't think it compiled non-pointer-tagged sums via Scott encoding or Church encoding...
21:08:15 <ddarius> Cale: It definitely, at one point, compiled sums into vectored calls.
21:08:24 <edwardk> dcoutts: yeah, alas, its needed when you typecheck the class/data type definitions because it generates different code, passing an extra 'type-like' parameter for the kind
21:08:43 <dcoutts> I see
21:09:01 <edwardk> dcoutts: the reason i asked for {-# LANGUAGE PolyKinds #-} to be turned on in base for 7.6.1 for the Control.Category module is the same thing
21:09:11 <edwardk> that is the only module in base that really benefits from the extension
21:09:16 <edwardk> and it benefits with 0 code changes
21:09:17 <dcoutts> makes sense
21:09:28 <Tekmo> Edward
21:09:39 <Tekmo> So one thing that you can use for machines
21:09:49 <Tekmo> is something I'm releasing in the next pipes release
21:10:00 <Tekmo> Let me link the branch so you can see it, hold on
21:10:04 <edwardk> k
21:10:29 <Tekmo> https://github.com/Gabriel439/Haskell-Pipes-Library/blob/monadpipe/Control/Pipe/Trans.hs
21:10:29 <edwardk> i still need to add a fair bit of resource finalization code to machines. its not up to snuff with conduits/pipes in that regard
21:10:37 <Tekmo> The trick is
21:10:48 <Tekmo> You can very easily left comopsition over any outer monad transformer
21:10:53 <Tekmo> and there are laws for a correct lifting
21:11:13 <Tekmo> You define a liftE operator which is like lift in that it obeys the monad transformer laws
21:11:25 <Tekmo> but the additional constraint is that it must form a functor from the base pipe to the extended pipe
21:11:26 <Tekmo> i.e.
21:11:30 <edwardk> in machines its a bit easier because you can just transform the base monad for the plan,etc.
21:11:32 <Tekmo> Sorry, liftP
21:11:40 <Tekmo> liftP idP = idP
21:11:50 <Tekmo> liftP (p1 <-< p2) = liftP p1  <-< liftP p2
21:11:56 <Tekmo> and it's still a monad transformer, so
21:12:00 <Tekmo> (liftP . return ) = return
21:12:05 <ivanm> @hoogle (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
21:12:06 <edwardk> hrmm
21:12:06 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:12:06 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:12:06 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
21:12:15 <wywy> If we encoding True as \x y -> x, False as \x y -> y, and if as \t c a -> t c a, then indeed we don't seem to need the comparison instructions of the processor ...
21:12:17 <Tekmo> (liftP .) (f <=< g) = (liftP .) f <=< (liftP . g)
21:12:19 <ivanm> > liftA2 (+) (Just 3) Nothing
21:12:20 <lambdabot>   Nothing
21:12:23 <ivanm> :(
21:12:35 <Tekmo> So if you make your plan an instance of "MonadPIpe" (still need a better name for it)
21:12:41 <Tekmo> You automatically get those extensions for free
21:12:41 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/ptr-tagging.pdf has a description of what heap objects look like in GHC which suggests that a field in the info table (which you get to by following the info pointer for the value and then looking backwards a bit in memory), contains the constructor tag, even if the info pointer isn't itself tagged
21:12:45 <ivanm> is there a version of liftA2 where if one of the values is Nothing then the other value is used?
21:12:49 <edwardk> anyways, i just shuffled my arguments so the monad is in the real monad transformer position for plan
21:12:59 <johnw> can I build and run Cabal tests that depend on the library I'm building, without installing it into ~/.cabal?
21:13:01 <carter> edwardk Tekmo : I've been enjoying the evoluation of all the pipes libs this past year :)
21:13:05 <edwardk> since i was already moving everything when i compile it to a machine anyways
21:13:16 <Tekmo> Also, a cool new feature of the non-indexed finalization
21:13:25 <Tekmo> Will be that youc an suspend and reinitialize a resource where you left it off
21:13:26 <dcoutts> johnw: yes, just like you can have exes in the same package as a lib
21:13:33 <edwardk> ivanm: (<|>) ? =)
21:13:39 <johnw> when I try to configure, It says the dependency is missing
21:13:47 <edwardk> ivanm: oh you want to combine the function nm
21:13:52 <ivanm> yup :)
21:13:59 <dcoutts> johnw: and the test can either import the modules directly or via the lib
21:14:00 <ivanm> I can obviously write one myself
21:14:01 <wywy> but then where are True and False from? ... we still seem to need the CPU's help..
21:14:16 <johnw> never mind, it's working
21:14:18 <johnw> thanks
21:14:33 <edwardk> ivanm: you're stuck writing it
21:14:40 <carter> Tekmo: so you can interrupt & resume computations? :)
21:14:49 <Tekmo> Well, it's not as sexy as that sounds
21:14:50 <ivanm> edwardk: yeah, was afraid of that
21:14:55 <ivanm> oh well, I'm sure I'll survive :)
21:14:56 <Tekmo> You still have to implement the resumption routine yourself
21:14:56 <wywy> unless we don't use machine integers ...
21:15:02 <Tekmo> But it lets you hook into that
21:15:03 <carter> Tekmo, thats fine by me
21:15:09 <Tekmo> Basically the sematnics are
21:15:14 <Tekmo> when you "close" upstream
21:15:16 <Tekmo> it finalizes itself
21:15:19 <Tekmo> and then when you await
21:15:25 <Tekmo> it can choose to reinitialize itself however it wants
21:15:35 <Cale> wywy: Well, it depends on what language we're compiling this stuff to
21:15:37 <carter> I was planning on doing something like that on top of pipes or the like later this fall
21:15:40 <Tekmo> including continuing where it left off
21:15:43 <carter> *anyways*
21:15:49 <edwardk> Tekmo: you'll likely remain far ahead of machines on that front for a long time. i have a pretty limited set of scenarios i need it for for now
21:15:54 <Tekmo> Well
21:15:55 <Tekmo> thep oint is that
21:16:00 <Tekmo> Most of these extensions are layerings
21:16:04 <Tekmo> So if you implement MonadPipe
21:16:07 <Cale> wywy: Whether we're compiling to another lambda calculus or compiling to x86 machine code will make a big difference on how these things are ultimately represented.
21:16:08 <Tekmo> You get these extensions for free
21:16:14 <Tekmo> For example
21:16:17 <Tekmo> I'll show an hpaste
21:16:27 <Tekmo> where I layer pipe-local state and error handling to transparently add parsing
21:16:29 <edwardk> sure, in machines the extensions are being built as transformers for the input type
21:16:34 <wywy> Cale: yep. The processor just spend up things I guess
21:16:40 <luite> ddarius: which what kind of code should a vectored return be produced? i just tried with a simple enum type with 9 constructors and it made a regular switch
21:16:50 <edwardk> and thats where you pick up leftover handling, exotic inputs, commands to the upstream, etc.
21:17:04 <luite> also i thought it was removed completely :)
21:17:05 <Tekmo> http://hpaste.org/73647
21:17:05 <wywy> Cale: binary numbers are much more efficient than unary church numerals ;-)
21:17:29 <Cale> wywy: If you're interested in how to do this in a practical way, the place to start is the original paper on the Spineless Tagless G Machine, which is where GHC got started (various things have been changed, but the fundamental machine is still there)
21:17:45 <ddarius> Cale: See section 7.2 of that paper.
21:17:58 <ddarius> Cale: But yes, it explains in that paper, why they moved away from that.
21:18:20 <Cale> http://www.ncc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
21:18:59 <ddarius> luite: Apparently with pointer tagging they also eliminated vectored returns for branch trees.
21:19:07 <Cale> ddarius: aha, okay
21:19:09 <edwardk> Tekmo: also i noticed that you seemingly rather deliberately didn't cps pipes. given that you have the monad there and do a fair bit of substitution have you seen places where poorly written pipes code slows down asymptotically on you?
21:19:20 <luite> ddarius: ah right
21:19:37 <Tekmo> So I have shown the asymptotic effect
21:19:40 <Tekmo> i.e. if I do
21:19:51 <Tekmo> do { x <- someLargePipe; someThing else }
21:19:57 <Tekmo> Then you can see it take that toll
21:20:08 <edwardk> with machines my model was to cps the plan construction which is the monadic component, and then compile it to a non-cps'd machine
21:20:12 <Tekmo> However, I tried switching to cps style
21:20:16 <Tekmo> but the problem is that
21:20:22 <edwardk> that way the machines are easy to work with, but the plans don't suffer slowdown
21:20:23 <Tekmo> You take a huge penalty in the implementation of composition
21:20:31 <Tekmo> which does a lot of manipulations at the head of the free monad
21:20:35 <Tekmo> so it's kind of a wash
21:20:51 <edwardk> well, thats why i switch styles before i get to composition ;)
21:20:56 <Tekmo> Remember that pipes are essentially
21:21:01 <Tekmo> just merging free monads
21:21:04 <edwardk> sure
21:21:11 <Cale> wywy: You might also be interested in hearing about the Reduceron :)
21:21:24 <carter> edwardk: where in the machines source can I see that difference?
21:21:25 <wywy> Cale: that's cool name :)
21:21:40 <Tekmo> So if you imagine pipes as lists and codensity pipes as diff lists
21:21:42 <edwardk> carter: compare Data.Machine.Plan with Data.Machine.Type
21:21:46 * hackagebot LDAP 0.6.8 - Haskell binding for C LDAP API  http://hackage.haskell.org/package/LDAP-0.6.8 (EdwardYang)
21:21:46 <Cale> http://vimeo.com/16539288
21:21:47 <Tekmo> composition is optimal for lists since it's head-biased
21:21:49 <ddarius> edwardk: Hmm, machines might be useful for mem.
21:21:54 <ddarius> s/mem/me.
21:22:06 <edwardk> Tekmo: yes i'm very familiar with the different ways to speed up free ;)
21:22:32 <edwardk> this is why i split machines the way i did.
21:22:33 <artelius> Cale: thanks for the paper, as it happens I'm designing my own abstract machine
21:22:44 <wywy> Cale: compiling FP into FPGA?
21:22:46 <edwardk> the plans are set up so the stuff you can write monadically doesn't slow down
21:23:04 <edwardk> while the machines are already converted to list form so head inspection doesn't have to force the entire thing
21:23:09 <Tekmo> edwardk: The reason I pointed out the extensions is because I saw the Fail "constructor" in your plan type
21:23:18 <edwardk> ddarius: nifty =)
21:23:20 <Cale> wywy: Well, using an FPGA to prototype an architecture which would very efficiently evaluate FP code
21:23:32 <Tekmo> You can separate that out as the EitherP pipe transformer
21:23:41 <edwardk> i could.
21:23:42 <ddarius> edwardk: I await a Delta machine.
21:23:56 <edwardk> the original design was for infinite only streams, etc.
21:24:11 <ddarius> s/very efficiently//
21:24:13 <wywy> Cale: How does that compare with some Bluespec work?
21:24:48 <edwardk> however, i find that this model is cleaner for me to use. the noise is less programming in this style than with an arbitrary transformer stacking up on top of everything
21:24:59 <edwardk> plus, note i don't have a value type in my final machine
21:25:07 <edwardk> so i have no good place for either T to live
21:25:14 <edwardk> i don't want it infecting the 'm' type
21:25:20 <edwardk> since that becomes user visible on the result
21:25:20 <Tekmo> I don't see a composition operation, though
21:25:23 <Tekmo> Or is that in a different module?
21:25:31 <edwardk> Plans get compiled to Machines
21:25:35 <Cale> wywy: Well, I've not heard of Bluespec being used to try to design machines to run functional programs faster.
21:25:40 <edwardk> Machines give you a Category for Processes
21:25:54 <edwardk> other styles of machines offer more exotic compositions
21:25:59 <wywy> Cale: There are some related ones like http://csg.csail.mit.edu/pubs/memos/Memo-506/memo506.pdf
21:26:03 <edwardk> Data.Machine.Type has a category in it
21:26:12 <edwardk> and it has the compilation from plan
21:26:38 <Cale> wywy: I can imagine Bluespec being used to specify and implement the Reduceron, but that's another thing, I guess?
21:26:48 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Type.hs#L196
21:27:29 <wywy> Cale: That theiss is kinda strange language with so-called Guarded Atomic Actions, not exactly FP-like
21:27:49 <Cale> wywy: The Reduceron just gets flashed once onto the FPGA, and then is controlled by software to evaluate expressions.
21:28:02 <Cale> (and it's the same Reduceron regardless of which program you're evaluating)
21:28:15 <ddarius> edwardk: "Portability: rank-2" ...
21:28:34 <edwardk> ddarius: i should update that with the extra requirements its incurred
21:28:34 <wywy> Cale: so is it an interpreter compiled into hardware?
21:28:47 <Cale> wywy: yeah, kinda like that :)
21:28:52 <Tekmo> edwardk: How do you bind the result of composition?
21:29:04 <Tekmo> i.e. what's the equivalent of the following pipes code:
21:29:06 <wywy> Cale: that makes much sense...
21:29:08 <Tekmo> r <- p1 <+< p2
21:29:10 <edwardk> Tekmo: i don't have it
21:29:16 <Tekmo> Oh, I see
21:29:19 <edwardk> Tekmo: deliberately not at this point
21:29:20 <Tekmo> the machine is the final destination
21:29:23 <edwardk> yes
21:29:26 <edwardk> you generate machines
21:29:29 <edwardk> and then you compose machines
21:29:29 <wywy> Cale: then we will not need any compiler from FP into some ugly processor instructions sets ... haha
21:29:38 <Cale> wywy: Though it still requires fairly serious compilation of the original program into a form which is suitable for the processor to execute -- but that translation is a lot more straightforward.
21:29:38 <edwardk> the plan is a dsl for building small machines
21:29:53 <edwardk> remember, unlike pipes i can have multiple inputs to a machine
21:29:56 <ddarius> I think I kinda want something pipes/machines like but more synchronous.
21:30:02 <edwardk> so i can get away with simpler individual machines
21:30:07 <Tekmo> You can do it with pipes, too
21:30:17 <Tekmo> Pipe a b (Pipe c d m) r
21:30:27 <edwardk> yes, but that is a god awful programming model =P
21:30:41 <Tekmo> It actually works really well for me, but probably because I'm biased :)
21:30:45 <wywy> Cale: I guess that only involves some optimizations, like partial evaluation and supercompilation. Well there is exactly one paper on supercompilation there
21:30:56 <edwardk> thats the same crap i need for working with iteratees
21:30:56 <edwardk> anyways the machine model was deliberately constructed to avoid that model
21:31:13 <edwardk> it also lets you do things like non-deterministically wait on multiple inputs of a y, which are hard to encode that way
21:31:26 <Tekmo> Which machine does that?
21:31:32 <edwardk> Data.Machine.Wye
21:31:55 <edwardk> the wye combinator is rather gruesome
21:32:00 <edwardk> but its written once at least ;)
21:32:05 <Cale> wywy: It also makes sure that certain local size constraints get met so that these things can be represented by bounded width instructions and so that each evaluation step happens in one cycle.
21:32:29 <carter> ooop, its gruesomehttps://github.com/ekmett/machines/blob/master/src/Data/Machine/Wye.hs
21:32:32 <carter> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Wye.hs
21:32:53 <Tekmo> It's in CPS style, so I can't tell where the scheduling takes place
21:32:54 <wywy> Cale: interesting
21:32:54 <edwardk> wye will ultimately wind up being the lmap for Wye machines when using them as a profunctor.
21:32:58 <Tekmo> How does it schedule multiple inputs?
21:33:01 <wywy> Cale: how does it do memory management?
21:33:47 <Tekmo> Like, for pipes the way I have to do this is by using IO to schedule multiple producers without poll-waiting
21:33:55 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Wye.hs#L67 is when the 'wye' machine goes to read from either input, when it does it demands from the left first, if it would block, then it starts demanding from the right unless that would finally block too
21:34:25 <edwardk> by block i mean it would have to await upstream
21:34:47 <Tekmo> What if it's an identity machine?
21:35:01 <Tekmo> That trivially generates a new await?
21:35:07 <Cale> wywy: There's a garbage collector on the chip, from what I understand. According to the original paper it's just a stop-and-copy two space collector.
21:35:14 <edwardk> wye id id is basically the machine you started with
21:36:06 <edwardk> it just tries to avoid waiting on things farther down the chain and yields everything it can before it starts to await
21:36:06 <wywy> Cale: I'm currently assigned a project on region-based memory management. I don't know if that can work out ;-)
21:36:26 <edwardk> wye is horrible and evil and nondeterministic, etc.
21:36:31 <edwardk> tee is the safe version
21:36:32 <Tekmo> Wait
21:36:42 <edwardk> but it can only block on one input at a time deterministically
21:37:11 <Tekmo> Ok, I see
21:37:12 <edwardk> with Tee you can 'awaits L' or 'awaits R' but you block deterministically on one input
21:37:25 <edwardk> with Wye, you can awaits Y or awaits Z which are both deterministic
21:37:30 <wywy> Cale: I have the intuition that regions, reference counting and garbage collector must be combined together to get the optimal result
21:37:50 <edwardk> but you can also awaits Z, which can continue with either input
21:37:57 <edwardk> it gets handed an Either
21:38:12 <edwardk> and the choice of which gets fired is made by whatever is driving it
21:38:53 <edwardk> either an external driving harness, the fact that you used run and we just starved the machine, or that you used wye' to get something larger and it tried to do as much as it could emission wise without demanding from its upstreams
21:39:31 <Cale> wywy: Oh yeah, another nice thing about the Reduceron is that the design of the FPGA configuration is also written in Haskell.
21:39:35 <edwardk> the reason this is exiled to another type from Tee is that of course, its nice to know that a machine is deterministic. ;)
21:39:45 <Cale> wywy: (Using a library called York Lava)
21:40:30 <edwardk> if you want to turn a wye or tee into a process so you can compose it, you use one of the cap combinators to attach a (possibly monadic) source to one of its inputs
21:40:47 <Cale> wywy: You can see the garbage collector in reduceron/fpga/Collect.hs in http://www.cs.york.ac.uk/fp/reduceron/reduceron.tar.gz
21:40:49 <edwardk> and then you are left with a process(t) on the remaining input
21:41:46 * hackagebot svndump 0.1.0 - Library for reading Subversion dump files  http://hackage.haskell.org/package/svndump-0.1.0 (JohnWiegley)
21:42:32 <edwardk> the model with machines is a bit different than the iteratee/pipes/conduit model, you build machines, cap them off with (monadic) supplies, supply pipes some data, then run the machine, getting either a monadic or pure result that is the stream of tuples it generated
21:42:41 <carter> edwardk: and for processes, the after combinator is the compose?
21:43:12 <edwardk> after can be used to attach a process to any other machine's output yielding a longer machine.
21:43:32 <carter> yes, so its more general than a compose
21:43:46 <edwardk> but (.) = after, when you extend a process ;)
21:43:52 <edwardk> yep
21:44:24 <edwardk> also you can build machines up from things other than plans, e.g. you can work with mealy or moore
21:44:32 <edwardk> mealy is an arrow, moore is a comonad
21:45:03 <edwardk> so you get other compositions that are afforded by their more restricted i/o style
21:45:07 <Tekmo> Wait
21:45:10 <Tekmo> I have another question
21:45:14 <edwardk> sure
21:45:19 <Tekmo> So let's say I have two IO-based sources
21:45:23 <Tekmo> that are synchronous
21:45:40 <Tekmo> What do you do to merge them without blocking on one
21:45:58 <edwardk> i punt. ;)
21:46:00 <Tekmo> :)
21:46:02 <Tekmo> Well
21:46:03 <edwardk> literally thats the best solution for me
21:46:05 <Tekmo> I was just curious
21:46:11 <edwardk> what i can do is this
21:46:15 <Tekmo> Because right now I have to use Control.Concurrent to do it
21:46:35 <edwardk> i can make a monadic source for each, but then a wye has to demand one or the other in the end
21:46:36 <Tekmo> I was trying to figure out if it was generalizable
21:46:41 <Cale> Tekmo: Control.Concurrent is often the best way to wait on multiple things
21:46:46 <edwardk> i can defer the question to the driver
21:46:47 <Tekmo> Right, I understand
21:46:48 <ddarius> wywy: Read http://www.google.com/url?sa=t&rct=j&q=garbage%20collector%20duality&source=web&cd=1&cad=rja&ved=0CCIQFjAA&url=http%3A%2F%2Fwww.pm.inf.ethz.ch%2Feducation%2Fseminars%2Fverification%2Farchive%2F2005_2006%2Fseminar%2Fslides%2F23.1.A_Unified_Theory_of_Garbage_Collection.pdf&ei=mvs6UJzXCKiT6wH1y4DIBA&usg=AFQjCNFysZETklPgUyj2jkL3MDGYyzHNmA
21:46:53 <edwardk> which can inspect the different requests
21:46:58 <Tekmo> But I often get the impression that concurrency is a special case of something else
21:47:04 <Tekmo> although I can't quite articulate quite what yet
21:47:04 <edwardk> and can know how to read from the combination using select, etc.
21:47:33 <ddarius> edwardk: Are you intending people to write X,Y,Z or is that just for now to be replaced/wrapped?
21:47:39 <Cale> GOOGLE WE LOVE YOU. YOUR URL MANGLING IS MAGNIFICENT AND NOT OBNOXIOUS AT ALL.
21:47:58 <Tekmo> Use duckduckgo and pretend it doesn't suck
21:48:07 <Cale> lol
21:48:20 <edwardk> so basically you need to choose between where you push your effects. they can live in an external driver, you can issue them as 'commands' using a custom k, or you can put them in the monad
21:48:39 <edwardk> the machines model itself is pretty neutral about what choice is best
21:48:48 <ddarius> I used duckduckgo for a while then I either upgraded my OS and/or got a new laptop and haven't re-setup my browser configuration.
21:49:08 <Tekmo> Also keep in mind that you can also parametrize the base monad of pipes on a driver, too
21:49:10 <edwardk> ddarius: i'll probably make a more HListy version of wye and tee that will go in the final version
21:49:14 <Tekmo> simply by making the base monad a Consumer
21:49:15 <edwardk> sure
21:49:44 <edwardk> i don't claim that machines is terribly novel except in that it supports a more explicit notion of fanout
21:49:54 <edwardk> in exchange i had to give up a lot
21:50:06 <edwardk> but its a better fit to the domain of problems we're using it on
21:50:12 <carter> edwardk: what pieces do you have to give up?
21:50:21 <Tekmo> The monad post-category
21:50:38 <edwardk> i don't support parsing as elegantly, pushback is ugly, doing compositons and then going back to monadic operations is gone, etc.
21:50:40 <carter> Tekmo could you rephrase that again please ;)
21:50:43 <Tekmo> I mean
21:50:50 <Tekmo> Using a composition within a monad
21:51:00 <Tekmo> i.e. do r <- p1 <+< p2; f r
21:51:00 <carter> yes
21:51:12 <Tekmo> I'm telling you, though Edward
21:51:15 <Tekmo> If you implement MonadPipe
21:51:18 <Tekmo> you get parsing for free
21:51:33 <carter> so are there any pipe libs that have the nice notation, and the cps piping where it'd help?
21:51:34 <edwardk> otoh, that last thing is exactly what is _asymptotically_ bad to do over in pipes ;)
21:51:46 * hackagebot resource-pool 0.2.1.1 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.1.1 (BryanOSullivan)
21:51:59 <carter> edwardk: that composition piece creates the bad asymptotics?
21:52:08 <Tekmo> He means this
21:52:13 <Tekmo> In a free monad that is head-biased
21:52:16 <Tekmo> It's expensive to do this
21:52:17 <edwardk> i'm really not concerned with parsing at this point, we're pushing financial data through it, not text.
21:52:27 <edwardk> when i want http-machines or something i'll worry more about the parsing side of things
21:52:28 <Tekmo> do { r <- largeFreeMonad; f r }
21:52:39 <Tekmo> so if large free monad is a composition, it's probably expensive
21:52:55 <johnw> does a lazy list ever get represented as a list?  Or, if it's read from serially, is it merely a kind of "producer of values"?
21:52:57 <Tekmo> My experience with pipes
21:53:06 <Tekmo> Is that pipes are not the rate-limiting factor
21:53:07 <ddarius> johnw: It's always represented as a list.
21:53:09 <Tekmo> everything I do is always IO bound
21:53:20 <Tekmo> even when doing high-efficiency parsing
21:53:42 <edwardk> johnw: consider what happens if i need to take the length and the sum of the list entries, the compiler usually won't be smart enough to fuse those.
21:53:45 <johnw> so I'm wondering something.  If adding a new element to the end of a list is expensive, and Parsec returns things as lists in order, then wouldn't parsing of a very long list of terms be quadratically bad?
21:54:14 <wywy> ddarius: thanks that's very relevant
21:54:55 <lightquake> johnw: i don't think parsec uses linked lists internally
21:55:07 <edwardk> anyways, my main concern with machines is that they don't turn into the asymptotic slowdown. and i'm not entirely concerned with the haskell implementation, but rather with the scala implementation
21:55:15 <edwardk> the haskell implementation was more or less a template for that
21:55:19 <lightquake> and even if it did, there are ways to make that linear (by appending to the front and then reversing at the end)
21:55:30 <edwardk> because its awful to -think- in scala when trying to design this stuff
21:55:45 <ddarius> edwardk: But it's fun to write in Scala after it's designed?
21:55:58 <edwardk> ddarius: no, but Apocalisp and dolio can deal with that part ;)
21:55:59 <carter> edwardk please still make the haskell one nice none the less, i may find myself using it heavily this fall
21:56:08 <carter> :)
21:56:13 <edwardk> carter: i'm planning on continuing to improve it
21:56:19 <carter> yay
21:56:21 <edwardk> notice that i went out of my way to fully haddock it, etc.
21:56:22 <carter> just double checking
21:56:26 <carter> true
21:56:31 <edwardk> and i'll even be adding some benchmarks, etc. soon
21:56:48 * hackagebot svndump 0.1.1 - Library for reading Subversion dump files  http://hackage.haskell.org/package/svndump-0.1.1 (JohnWiegley)
21:56:57 <carter> cool
21:57:02 <edwardk> i'm wafflingbetween using Process as Process = Machine (->)    or Process = Machine Is
21:57:12 <carter> whats the distinction per se
21:57:14 <carter> i mean
21:57:17 <Cale> ddarius: It's always represented as a list* ... *lists are possibly not represented how you think :)
21:57:19 <carter> i understand that Is = Eq
21:57:21 <carter> sort of
21:57:26 <edwardk> the former is slightly nicer when i go to explain how i make machines into profunctors. the latter yields prettier code in Wye and Tee, etc.
21:57:45 <dolio> ddarius: It was a complete fucking nightmare.
21:57:49 <edwardk> the former i have to plumb the functions through, the latter i just use 'Refl' and ghc patches it in
21:58:13 <johnw> so I guess is probably handing out cons cells to represent each result, with the CDR of each being the promise to get the next
21:58:19 <johnw> ^Parsec is
21:58:21 <carter> my abstraction fu is weak enough that I don't quite grok what that means from a users view
21:58:39 <carter> (and I guess i'm wondering about it from that perspective :) )
21:58:45 <edwardk> carter: here let me show you
21:58:52 <edwardk> end users don't see it, ever.
21:59:01 <carter> ok
21:59:03 <ddarius> johnw: That's a lazy list, though what happens depends on what code you write.
21:59:18 <carter> so its just an internal engineering decision
21:59:33 <Tekmo> edwardk: I can't add Polykinds to index-core just yet
21:59:39 <Tekmo> PolyKinds causes one module not to compile
21:59:52 <edwardk> carter: https://github.com/ekmett/machines/commit/eb6548b1363e3565df33ae4b49710a987e78a925#L5L52
21:59:59 <edwardk> Tekmo: which?
22:00:10 <Tekmo> Control.IMonad.Trans
22:00:13 <edwardk> are you on 7.4.1 or 7.6.1?
22:00:15 <johnw> I have a Data.Map question.  I need to represent a series of SVN revisions as a map of revisions to filetrees, where each file tree has leaves and branches that refer to previous revisions (a DAG).  Is a Data.Map that contains Data.Map values good for this?
22:00:18 <Tekmo> 7.4.1
22:00:48 <edwardk> tekmo: i wonder if that'll compile with 7.6.1rc1
22:00:56 <Cale> johnw: Yes
22:01:01 <Tekmo> Well, remember that index-core is still a dependency for pipes
22:01:04 <edwardk> sure
22:01:06 <Tekmo> Until I remove Frame
22:01:07 <ddarius> UpStar,  DownStar.  Jesus.
22:01:19 <edwardk> ddarius: profunctor-extras?
22:01:23 <ddarius> profunctors
22:01:24 <carter> edwardk: ok, so in that case its a difference of a wee bit of extra parameter passing
22:01:28 <edwardk> ddarius: ah
22:01:42 <Tekmo> Oh wait
22:01:46 <edwardk> ddarius: i'll take better names for them
22:01:48 <Tekmo> But for 7.4.1 it should still compile
22:01:55 <edwardk> i just wanted compatibility with sigfpe's articles by default
22:02:03 <ddarius> edwardk: PreCompose PostCompose
22:02:10 <Tekmo> I will test it with 7.6.1 then
22:02:15 <Cale> johnw: If you need a little more performance, you may consider using an IntMap, but other than that, Map is pretty good at handling data structures which you might otherwise represent by a (possibly cyclic) graph of pointers in memory.
22:02:25 <johnw> ok
22:02:32 <edwardk> Tekmo: yeah if it compiles with 7.6.1 then just bump the if impl(ghc>=‚Ä¶) version
22:02:37 <Tekmo> Yeah
22:02:45 <johnw> I was wondering whether I needed to use Sequences or something to make my in-memory directory trees
22:02:47 <Tekmo> If it works, just look for index-core-1.0.2
22:02:50 <edwardk> if it doesn't its probably a bug ghc hq needs to hear about ;)
22:02:56 <wywy> ddarius: what's their conclusion? Mostly reference counting, plus occasional GC for the cycles?
22:03:02 <johnw> recursive Maps are how I'm doing it in C++
22:03:13 <edwardk> ddarius: or Before, After, etc.
22:03:18 <Cale> johnw: It's also a nice proof that you can implement any algorithm using mutation with immutable structures and taking at most a logarithmic hit to time.
22:03:28 <carter> edwardk: i found a few 7.6 bugs last week.... made me decide that i should camp in 7.4 for now :)
22:03:51 <LordBrain> Where's a nice gentle explanation of what a profunctor is?
22:03:54 <ddarius> wywy: I doubt they have such a conclusion, if anything there conclusion would be "you probably want to be somewhere in the middle", but the point is to explicate that there is a continuum and what you trade-off as you move along it.  Where you want to be on it depends on your goals.
22:04:00 <edwardk> i just want to finally be able to update categories to support a lot of interesting stuff
22:04:14 <edwardk> LordBrain: http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
22:05:01 <wywy> ddarius: What's the disadvantage of ref counting except it can't collect cycles?
22:05:02 <LordBrain> oh
22:05:13 <LordBrain> thanks
22:05:17 <carter> i really should reread all the sigfpe stuff myself
22:05:24 <edwardk> LordBrain: profunctor k a b is contravariant in a and covariant in b.
22:05:41 <amiller> what should i call this?      data Trunk m x = Tip | Bin (m x) (m x)
22:05:41 <amiller> so far i have determined that:    instance (Monad m) => Functor (Trunk m)
22:05:48 <edwardk> wywy: thats a pretty damning disadvantage
22:05:48 <ddarius> wywy: Well that alone is a pretty big disadvantage, but basic reference counting can lead to arbitrarily large amounts of work when freeing.
22:06:06 <carter> sigfpe blog articles are some of the more concrete expositions of using cateogorical machinery generailly, right?
22:06:07 <Tekmo> amiller, check out free
22:06:09 <Tekmo> I mean
22:06:12 <Tekmo> the "free" package
22:06:22 <edwardk> carter: yeah
22:06:25 <LordBrain> i'm not sure on the meanings of contravariant and covariant to be honest, but i think some of the cloud is dissapating nevertheless
22:06:31 <wywy> ddarius: you mean when freeing a list?
22:06:40 <carter> edwardk: awesome, thats going to be a lot of my side reading this week then
22:06:47 <ddarius> wywy: That would be an example.
22:07:10 <wywy> ddarius: I guess I understand their point now
22:07:20 <carter> well
22:07:22 <carter> I should crash
22:07:38 <carter> even though i'm re realizing how much more nifty stuff I need to learn  / re familiaraize myself with
22:07:45 <wywy> ddarius: it depends on "do you have more useful data or do you have more garbage" :-)
22:07:46 <carter> night all
22:08:55 <Cale> LordBrain: Are you familiar with what a category is?
22:09:59 <LordBrain> yes, and wikipedia helped with contravariance, i get that now
22:10:08 <edwardk> LordBrain: ever used an Arrow?
22:10:12 <LordBrain> yeah
22:10:13 <Cale> okay :)
22:10:20 <edwardk> LordBrain: a Profunctor is something weaker than an Arrow.
22:10:31 <edwardk> you can't stick two of them together but you can bolt functions on either side
22:10:58 <ddarius> Profunctor = categorical C-D bimodule
22:11:01 <wywy> ddarius: That's not a good feeling... Why is memory management so imperfect ;-)
22:11:06 <Tekmo> That was the best explanation of Profunctors I've ever heard
22:11:10 <Tekmo> Not being sarcastic
22:11:14 <edwardk> in a category theoretic sense, the functions get replaced with morphisms from a couple of different categories
22:12:11 <ddarius> A profunctor is a functor C -> Set^(D^op) or D^op -> Set^C, or, most simply, D^op x C -> Set.
22:12:33 <edwardk> its a desirable property for me to say, keep all the machines in the machines package profunctorial, because then you can rmap to change their results
22:12:34 <Tekmo> That was the worst explanation of Profunctors I've ever heard
22:12:38 <Tekmo> :)
22:12:43 <edwardk> or lmap to change the inputs they require
22:12:55 <dolio> I guess the first part explains why they write C -/> D, even though that's crazy.
22:13:01 <edwardk> by comparison, iteratees can't be lmapped
22:13:03 <ddarius> dolio: Yes.
22:13:11 <ddarius> There is a category of profunctors.
22:13:13 <wywy> Is region-based memory management still alive ?
22:13:16 <Cale> Tekmo: lol
22:13:31 <ddarius> Though it's Rel-like, so an directional arrow notation is a bit much.
22:13:38 <ddarius> wywy: Yes.
22:13:43 <edwardk> wywy: not _very_
22:14:02 <edwardk> wywy: there was a retrospective a few years back by mads tofte on what went well and what went horribly wrong
22:14:14 <edwardk> its worth reading to understand region based memory management
22:14:23 <wywy> edwardk: I just read that paper
22:14:39 <ddarius> "Horribly wrong - our systems just led to everything being in the root region and being GCed normally anyway"
22:14:48 <edwardk> overall, i was sad, because i had high hopes for it
22:14:52 <ddarius> I found the URAL system interesting and potentially promising.
22:15:02 <tibbe> edwardk: that sounds interesting
22:15:06 <tibbe> edwardk: will read the paper
22:15:07 <edwardk> ddarius: fluet and those guys?
22:15:10 <ddarius> edwardk: Yes.
22:15:21 <edwardk> yeah, though the step-indexed modeling made me cringe
22:15:33 <wywy> edwardk: I kinda think that region-based memory management is just trying to use the stack as much as possible by putting non-escaping values on stack...
22:15:50 <edwardk> wywy: thats the naive ordered region model, its a lot nicer with linear regions
22:16:04 <edwardk> and linear regions still offer O(1) region freeing, etc.
22:16:05 <cads> ddarius, this profunctor stuff looks a bit insane, but I guess it'll look nicer once I'm more comfy with presheaves
22:16:08 <tibbe> edwardk: http://www.cs.ucla.edu/~palsberg/tba/papers/tofte-talpin-iandc97.pdf ?
22:16:09 <u_> parsec's try is annoying. am i in trouble if i redefine <|> to always use it?
22:16:42 <cads> holy wow.
22:16:47 * hackagebot spelling-suggest 0.5.2.1 - Spelling suggestion tool with library and command-line interfaces.  http://hackage.haskell.org/package/spelling-suggest-0.5.2.1 (BartonMassey)
22:16:48 <ddarius> cads: Being more comfortable with presheaves wouldn't hurt since a profunctor C -/> D is C -> Psh(D).
22:16:48 <edwardk> tibbe: http://dl.acm.org/citation.cfm?id=993040
22:16:49 <Tekmo> I'm pretty sure <|> is already bankrupt
22:16:54 <Tekmo> So I'd go for it
22:17:06 <edwardk> the one you found is more of a 'what are regions' paper
22:17:22 <u_> also Botje: instead of returning "parsed command" datatype i'm just returning the IO action itself. hope that's ok...
22:17:33 * cads just installed gtk2hs, cairo and diagrams in almost one go, with absolutely zero problems in his handy arch linux VM
22:17:45 <Tekmo> So, what's the major application of profunctors?
22:17:47 <cads> coming from debian this is... like freaking magic!
22:17:59 <edwardk> Tekmo: see profunctor-extras ;)
22:18:21 <ddarius> u_: Yes, you will probably get in trouble since Parsec has no way to "undo" try, so you will get the naive exponential backtracking behavior if you start doing heavier potentially non-deterministic stuff.
22:18:44 <ddarius> Tekmo: In Haskell or generally?
22:18:44 <wywy> edwardk: what are linear regions?
22:18:55 <edwardk> wywy: are you familiar with linear logic?
22:19:03 <wywy> edwardk: yep
22:19:11 <Tekmo> Let's start with Haskell
22:19:15 <edwardk> great, just make region variables linear
22:19:18 <cads> ddarius, yeah.. it also makes me happy to know you can lift a functor to a profunctor using yoneda goodness
22:19:21 <u_> oh
22:19:23 <u_> :(
22:19:30 <edwardk> then you can know that you allocated the region, and that you'll eventually dispose of it
22:19:40 <edwardk> and then thread it through every attempt to read or write from that region
22:19:46 <ddarius> cads: There are some good papers on profunctors used for combinatorial species.
22:19:46 <Cale> Bittorrent Corollary to Murphy's Law: Regardless of when you start two torrents relative to one another, if they overlap in time while downloading, they will magically conspire to finish at the same time.
22:20:05 <monochrom> ha ha ha
22:20:09 <edwardk> then when the linear variable is disposed you know nobody can legally read from or write to it ,so you can throw it away, even if there are dangling pointers to it
22:20:22 <monochrom> (can we generalize it to infinitely many torrents?)
22:20:26 <edwardk> this frees you from the stack discipline that tofte and talpin originally proposed
22:20:26 <u_> it's annoying to look through the list of words i'm parsing to check if one of them starts with the same letter as another
22:20:39 <u_> each time i write a parser for one of them
22:20:48 <edwardk> this is important because tofte and talpin's model can't be used to say, implement a cheney style copy collector.
22:20:51 <wywy> edwardk: makes sense... it seems to be able to track down some escaped values
22:21:11 <ddarius> u_: It's fine to use try over "small" things.  This is how the Parsec lexeme parsers work.  reserved just uses try.
22:21:20 <edwardk> because you need to allocate one region, copy stuff into it, discard your old region, then allocate a new region, etc.
22:21:47 <edwardk> you need open 1, open 2, close 1, open ‚Ä¶ close 2,
22:21:54 <edwardk> that fails the stack discipline
22:21:56 <wywy> edwardk: feels like what the C programmers are doing?
22:21:59 <ddarius> It's completely legitimate to write (Foo <$ reserved "foo") <|> (Fin <$ reserved "fin")
22:22:16 <edwardk> wywy: well, the difference is the linearity can be typechecked
22:22:33 <edwardk> wywy: cyclone has regions based on this model
22:22:47 <edwardk> and is by many of the same people who worked on lambda refURAL, etc.
22:23:39 <Tekmo> The thing I hate most about Parsec's try is that it's so opaque
22:23:46 <ddarius> Regions are still (or were a couple of years ago) relatively popular for typed "systems" level languages / typed assembly languages.
22:23:51 <ddarius> Tekmo: ?
22:23:52 <Tekmo> You can't tell from looking at a parser whether or not it will backtrack
22:23:54 <edwardk> in fact one of the reasons i moved to boston was i was thinking about going to harvard to do my ph.d with morrisett and those guys, and then they did a hard left turn and started focusing on hoare type theory, and ynot. and i decided i would rather make money
22:24:08 <Tekmo> Assuming the parser's implementation is a black box
22:24:21 <Tekmo> So you end up preemptively guarding everything with try
22:24:29 <ddarius> Tekmo: What?
22:25:05 <ddarius> edwardk: You were going to do academic work?
22:25:22 <wywy> edwardk: interesting... I think of it this way: the whole point is to pass information (a message) to another procedure, so the space used to contain the original value can be reclaimed after the message was sent...
22:25:26 <edwardk> ddarius: still are. eli, a guy we had work for us a year or so ago had a whole systems programming language with region based memory
22:25:42 <u_> small as in word length or number of possibilities?
22:25:47 <edwardk> ddarius: then matt sucked me in. you know how it goes ;)
22:26:13 <ddarius> edwardk: Even without Matt, I can't see you being an academic.  If nothing else, you'd have to publish.
22:26:32 <edwardk> ddarius: i rather enjoy the freedom to just code
22:26:40 <ddarius> edwardk: It is nice.
22:26:47 <edwardk> speaking of publishing, how goes the writing? ;)
22:27:22 <edwardk> the world needs more geometric coalgebra
22:27:27 <Tekmo> Speaking of academics, I've always been curious where computer scientists get grants
22:27:34 <ddarius> u_: Both-ish.  Arguably, something like "identifier" can consume arbitrarily large amount of input.  The possibilities is more crucial as that leads to the exponential blow-up.  As a rule of thumb, you almost never want to use try over a recursive parser.
22:29:18 <ddarius> edwardk: I was thinking about it and how I should finish it like six hours ago, but then I also thought about how I have a ton of work and then more work and then more work and then side projects and then personal projects and then entertainment.  Right now side projects is pretty minor, but I don't have enough time for all my personal projects, though this would fall under personal projects.
22:29:41 <ddarius> Tekmo: It says in the papers.
22:30:30 <edwardk> tekmo: if you guard unknown parsers with try you're doing it wrong
22:30:35 <ddarius> edwardk: I've actually been thinking about not working for a while (though not right now) just so I could have a lot of time to work on what I felt like.
22:30:41 <ddarius> edwardk++
22:30:48 <ddarius> edwardk: Hence my "What?" response.
22:31:01 <Tekmo> What's the correct solution, then?
22:31:35 <wywy> edwardk, ddarius, Cale: have to go to sleep ... zZZ. Thank you all. I learned quite a lot tonight :)
22:33:35 <edwardk> you put parsers together in a block with <|> to model a single LL(1) style production.  some times its not convenient to factor your grammar all the way there, so you use try when you need multiple symbols of lookahead but you should always be trying for just a few symbols of known terminals for a reason. or have some exotic grammar where you need to use longer tries to skip over patterns, etc.
22:33:53 <ddarius> Tekmo: First, you shouldn't have completely unknown parsers to begin with.  For generic combinators, you shouldn't be putting try around parameters because you can't "untry", the user can use try or not as needed.  Typically it is pretty clear what the backtracking behavior of the combinator would be.
22:34:32 <ddarius> Otherwise, the "goal" is LL(1) as edwardk said, with try used sparingly for things that would otherwise be awkward and won't lead to exponential blow-up.
22:34:34 <edwardk> if you didn't write the parser, don't 'try' it, it should decide how to succeed or fail
22:35:05 <Tekmo> The reason I'm asking is that I maintain a PDB parsing library for my lab
22:35:21 <Tekmo> And I don't want them to have to browse through the source code of it to know whether or not to guard a parser in a try
22:35:47 <ddarius> You should rarely be using try at all.  They shouldn't need to look at the source to know whether they should use try or not.
22:35:54 <ddarius> They shouldn't need to use try.
22:36:16 <Tekmo> simple example
22:36:39 <Tekmo> A PDB record begins with a record label
22:36:42 <ddarius> However, if they are adding productions to a grammar, then they need to know the impact on the grammar, and if it will take it out of LL(k), then they know that from the grammar, not the source, and they should resolve that, not just slap try on it.
22:36:56 <u_> i don't wanna keep doing string "s" <|> (string "etposition" <|> string "ingleoption") or whatever
22:37:08 <Tekmo> Just imagine that my users
22:37:11 <Tekmo> don't know what a grammar is
22:37:35 <Ralith> the current LLVM bindings don't support LLVM 3.1, correct?
22:37:44 <edwardk> the problem with parsec is the class of langauges it describes aren't closed under extension. so it matters a lot how you edit a production
22:38:50 <ddarius> u_: Use the lexeme parsers, or simply write your own reserved = try . string and then you can write reserve "foo" <|> reserved "fin" with no trouble.
22:39:05 <Saizan> btw of parsing, any suggestion on how to do error reporting from a DCG?
22:39:06 <Ralith> has anyone looked into doing an arrow-based parser that can resolve that sort of thing itself?
22:39:10 <edwardk> so you have a bunch of combinators that know how to read a HEADER section or a REVDAT block, etc?
22:39:12 <u_> lexeme parser?
22:39:22 <edwardk> and are making the end user string them together?
22:39:35 <ddarius> u_, Tekmo: Basically what try does is makes something "atomic".  As the word suggests, "atomic" things should be small/simple (as opposed to compound.)
22:39:53 <Tekmo> Right, I understand that
22:40:10 <u_> so string "anyenglishword" is ok to use try on
22:40:10 <Tekmo> and I understand the performance reason for it
22:40:20 <edwardk> u_: yes
22:40:31 <u_> ok :)
22:40:37 <ddarius> Tekmo: If your users don't know anything about parser theory, then they probably shouldn't be updating a parser.  If you want to add some extension mechanism, that should be at a layer above Parsec (assuming doing it on Parsec makes sense, which it probably does.)
22:40:44 <edwardk> u_: its hen you don't know how long the thing is going to be, that its a pretty bad idea to try ;)
22:41:06 <Tekmo> Well, the simple use case is
22:41:07 <edwardk> er its when
22:41:07 <ddarius> edwardk: That's a bit fuzzy.  identifiers can be arbitrarily long.
22:41:12 <Tekmo> I give them a skeleton PDB parser
22:41:19 <Tekmo> They have a file format which deviates from the PDB
22:41:19 <edwardk> ddarius: true
22:41:27 <Tekmo> by including some non-standard extension
22:41:42 <Tekmo> Ideally I'd like them to be able to do it instead of me
22:41:51 <edwardk> Tekmo: this is exactly the sort of thing for which parsec is a really ugly tool to use
22:42:01 <ddarius> Tekmo: Yes, and I'm saying make a system on top of Parsec that makes that simpler.
22:42:29 <edwardk> because extending the grammar to support a new kind of rule requires manipulating potentially all the existing rules under the class of languages parsec supports
22:42:35 <ddarius> Also, typically format extensions for artificial languages are somewhat structured to not destroy the grammar.
22:42:54 <Tekmo> So you're basically saying the problem is the notion of extending the grammar, not parsec
22:42:57 <edwardk> if you had, say, a context free grammar based parser, then they could just add rules
22:43:15 <edwardk> but parsec isn't targeted at that class of languages
22:43:19 <ddarius> edwardk: Yes, and then specify how to deal with the 2^20 new parses.
22:43:24 <edwardk> correct
22:43:46 <edwardk> Tekmo: now, there are good tools for this sort of thing
22:43:55 <loreints> what's a good small project idea for a haskell idiot such as myself to work on, considering the state of current libraries?
22:43:59 <edwardk> i mean, heck, you can have them use happy with the GLR extension turned on
22:44:23 <loreints> normally I would want to make a game, but the state of graphics libraries and the difficulty of haskell make me question that
22:44:33 * ddarius finds GLR parsing just moves the problem around (as indicated.)
22:44:35 <edwardk> that gives you a style of parser that is robust in the presence of changes
22:45:11 <zzing> How could I expand "~" and "~user" appropriately within the standard api (if possible)?
22:45:15 <edwardk> well, it has the benefit that it moves the problem around in a manner that if you have two extensions to a base grammar the language that incorporates both extensions is well defined
22:45:23 <edwardk> it may be nigh useless
22:45:27 <edwardk> but it is well defined
22:45:51 <edwardk> this is nice if you want to define parser transformers, etc. =)
22:46:17 <edwardk> one of these days i'll figure out how to package my GLL combinators up into a usable library, and this will all be a moot point
22:46:18 <edwardk> ;)
22:46:52 <ddarius> edwardk: Until people complain that they can't parse their CSV rows at a billion rows per second.
22:47:13 <edwardk> ddarius: heh, then i send them to attoparsec ;)
22:48:54 <ddarius> Tekmo: Basically, I'm betting the extensions, non-standard or not, probably follow a reasonable structure so as not to cause complete havoc to the grammar.  They are probably somewhat delimited essentially.  If they are relatively delimited, you can provide combinators that will include them into the overall grammar without any (user-visible) try being needed or damage to the rest of the grammar.
22:49:13 <Tekmo> So you're basically saying
22:49:18 <Tekmo> I should layer a user-friendly API on top
22:49:24 <Tekmo> that mitigates the scope of the grammar changes
22:49:37 <edwardk> yes
22:49:52 <edwardk> especially since you are talking about a pretty basic format
22:49:52 <ddarius> Tekmo: That and that this is probably relatively easily doable given the structure of the extensions (though maybe they are crazy.)
22:50:01 <Tekmo> No, they are pretty mild
22:50:10 <Tekmo> Usually it's a matter of adding a new field to a record
22:50:17 <Tekmo> or changing how a field is parsed
22:50:48 <zzing> Is there any reason why missingH is not included in the haskell platform?
22:51:06 <ddarius> zzing: I don't think there is any desire from anyone to include it there.
22:51:54 <zzing> When I did a search for a thing to expand ~ into /home/... it was the first thing that came up and I was surprised because I would have expected that to be much more common
22:52:17 <Tekmo> There's a higher standard for inclusion into the platform
22:52:36 <LordBrain> backing up to an earlier topic, let me test my understanding.  cofunctor = contravariant functor, cofunctoriality = contravariance
22:52:51 <ddarius> LordBrain: Don't say "cofunctor".
22:52:56 <edwardk> cofunctor = functor
22:52:57 * ddarius hopes edwardk didn't call it that.
22:52:57 <zzing> Tekmo, what does that mean exactly?
22:52:58 <edwardk> its boring
22:53:07 <edwardk> i refuse to ever call anything a cofunctor
22:53:16 <ddarius> edwardk: Good.
22:53:35 <Ralith> you should name a pet cofunctor
22:53:38 <Ralith> just to mess with people
22:53:41 <LordBrain> not sure where i picked it up, maybe the blog post, it uses the word cofunctoriality
22:54:08 <LordBrain> this one http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
22:54:08 <edwardk> LordBrain: when you flip the arrows in a functor (a ~> b) -> (f a ~> f b) you get (b ~> a) -> (f b ~> f a) -- that is alpha equivalent to where you started
22:54:09 <zzing> What about "contravarient functor"?
22:54:16 <ddarius> LordBrain: Whoever said it, probably did mean it in that sense.
22:54:28 <Tekmo> zzing: It's just a utility library with no rhyme or reason
22:54:32 <ddarius> It has no common meaning and "covariant" functoriality is just functoriality.
22:54:36 <Tekmo> zzing: Hackage is full of those
22:54:38 <edwardk> he probably should have said contrafunctoriality
22:54:43 <edwardk> or something like it
22:54:49 <ddarius> In fact, contravariant functoriality is just functoriality.
22:54:52 <zzing> On wikipedia "Contravariant functors are also occasionally called cofunctors."
22:55:03 <edwardk> zzing: contravariant functor is fine =)
22:55:05 <LordBrain> i think he could have said contravariance
22:55:09 <Tekmo> zzing: If you think those functions are really useful you should try to move them into a more appropriate library
22:55:26 <edwardk> zzing: http://hackage.haskell.org/package/contravariant
22:55:46 <edwardk> zzing: if you look up the edits those edits are mostly by a few people who started abusing the term a few years ago
22:55:52 <edwardk> and then it spread like a cancer =P
22:56:04 <ddarius> Except it didn't spread.
22:56:16 <ddarius> No one who actually does category theory says "cofunctor."
22:56:20 <zzing> edwardk, I would look it up if wikipedia was geared that way to find when a specific text was modified :P
22:56:29 <LordBrain> lol
22:56:34 <LordBrain> someone must
22:57:02 <LordBrain> but i just wanted to be sure i understood
22:57:04 <edwardk> LordBrain: conal used it and it spread from there to a number of FP users, he was infected by someone else
22:57:15 <zzing> Tekmo, I am doing something that is using shelly, and could use that functionality ‚Äî but that said this is something that I could see many people finding useful. I suspect Shelly would be a good place for it, should I just use MissingH for now for the functionality and suggest the addition to Shelly?
22:57:16 <ddarius> edwardk: Argh.
22:57:30 <edwardk> but its not a term used inside the actual category theory community and its very wrong
22:57:40 <edwardk> because it leads to all sorts of misunderstandings
22:57:54 <ddarius> It's just non-sensical and, yes, even in its intended meaning rather ambiguous.
22:58:08 <LordBrain> maybe they just want to save some key presses over contravariant functor
22:58:15 <zzing> Isn't the word functor abused to no end?
22:58:19 <ddarius> LordBrain: That's basically it.
22:58:39 <ddarius> zzing: It's used in a few ways in a few, rather different, contexts.  I don't find this overloading particularly abusive.
22:58:39 <edwardk> there is a similar reason to stamp out 'costate' etc. the store comonad isn't dual to the state monad, its what you get when you compose the adjunction the other way
22:58:45 <Tekmo> zzing: Maybe.  Or perhaps directory-based packages
22:59:01 <edwardk> this is why in comonad-transformers, they aren't coreader, costate, cowriter, etc.
22:59:08 <edwardk> because that vocabulary is quite wrong
22:59:26 <zzing> Tekmo, so basically you advocate against large collections of functionality "hapazardly" put together, and in more focused packages?
22:59:52 <ddarius> zzing: ~ expansion is something that is done by the shell, so it can vary based on which shell you are using let alone which operating system you are using.  I don't think Windows users would find having such a function available that useful.
23:00:03 <Tekmo> Sorry, accidentally closed the window
23:00:07 <edwardk> missing h would be a nice collection of small packages. as it is, there is no scope. no reason why anyone should stop accreting things into it
23:00:08 <Tekmo> Could you repeat that?
23:00:15 <zzing> Tekmo, so basically you advocate against large collections of functionality "hapazardly" put together, and in more focused packages?
23:00:24 <Tekmo> Yeah, it should be focused
23:00:36 <Tekmo> Otherwise people don't know what they are getting when they make it a dependency
23:00:47 <ddarius> zzing: There's not really -that- big a problem with such packages, but they certainly shouldn't be part of the platform.
23:00:51 <edwardk> my original 'category-extras' package suffered that diseases, my 'lens' package is actually dangerously close since many things can be considered a traversal
23:01:03 <edwardk> er disease
23:01:25 <Tekmo> Alright, I'll get some sleep
23:01:31 <Tekmo> See you guys later
23:01:32 <zzing> I think I understand. I will have to use it for now, but will have to see about removing it at some point. I can probably just figure out the code used and extract that.
23:01:35 <zzing> later
23:01:55 <Ralith> Does the maintainer of the LLVM bindings come on here?
23:02:01 * ddarius needs to buy more naan when he gets hummus.
23:02:02 <edwardk> but the value of lens would be severely decreased if i broke it into a dozen packages, so i've been limiting its scope in other ways (trying to stick close to the platform, etc)
23:02:06 <edwardk> Ralith: no
23:02:25 <Ralith> what's the best way to contact him? There's a pull request that needs attention that's been unattended for 3 months
23:03:11 <edwardk> preflex: xseen augustss
23:03:12 <preflex>  augustss was last seen on freenode/#haskell 292 days, 5 hours, 31 minutes and 6 seconds ago, saying: > div (-1) 2
23:03:13 <ddarius> zzing: If you are considering this as a dependency for a package you're making, I think you can start to see the problem with large unfocused packages.  You probably don't need a python bridge or a mail parser.
23:03:26 <zzing> certainly not
23:03:34 <Enigmagic> edwardk: bos maintains the llvm repo
23:03:47 <zzing> hmm, apparently this is not what I need anyways :P
23:04:02 <edwardk> Enigmagic: ah then in that case he may have better luck ;)
23:04:07 <edwardk> not much, but somewhat =)
23:04:18 <Ralith> preflex: xseen bos
23:04:18 <preflex>  bos was last seen on freenode/#haskell 2 days, 1 hour, 28 minutes and 19 seconds ago, saying: no
23:04:24 <Ralith> sweet
23:04:28 * Ralith will keep an eye out
23:04:31 <Enigmagic> Ralith: my experience is that he looks at it every 6 months or so.
23:04:41 <edwardk> Ralith: contact him by email, not irc, if you leave him a bot msg it'll be months before he sees it
23:04:47 <edwardk> trust me on that i speak from experience ;)
23:04:51 <Ralith> hah
23:05:04 <Ralith> he seems to be active on github, and I've left a comment there
23:05:07 <Ralith> will give that some time
23:05:09 <edwardk> yeah
23:05:23 <ddarius> Yes, its best to contact bos through email or at least something other than irc.
23:05:26 <Ralith> at least by default github forwards pull request comments to email
23:06:05 <zzing> I think I am going to change what I am doing, and just use an environment variable instead of just doing ~/.[something], that way I don't have to worry about this and it is more flexible
23:06:18 <ddarius> zzing: I recommend that.
23:06:45 <zzing> My whole goal behind this is flexibility
23:06:49 <Enigmagic> Ralith: fwiw there are a lot of active forks of the llvm bindings. someone should really dig through them all and cherry pick the best work and merge it all into a new branch. the current state of things leaves a lot to be desired imo.
23:07:29 <zzing> This project is so important to my haskell education too because I am doing applicative parsing, and learned to apply that elsewhere
23:08:03 <zzing> Is there any better way of saying    execute Setup = echo =<< LT.pack <$> (show <$> canonic "blah")
23:08:56 <ddarius> (LT.pack . show) <$>
23:09:29 <ddarius> The pack . show irks me though.
23:09:30 <zzing> Is that generally true if I find myself with multiple <$> in a row like this?
23:09:46 <ddarius> Yes, that's one of the functor laws.
23:09:50 <johnw> @pl echo =<< LT.pack <$> (show <$> canonic "blah")
23:09:50 <lambdabot> echo =<< LT.pack <$> (show <$> canonic "blah")
23:09:53 <ddarius> fmap f . fmap g = fmap (f . g)
23:10:03 <ddarius>  @pl doesn't know what (<$>) is.
23:10:30 <edwardk> you don't even need the ()'s around the .
23:10:36 <zzing> The problem is that I have a FilePath from canonic, but I need to turn it into a String, and it didn't like it when I didn't have a show even though FilePath is a string really
23:10:51 * cads wonders if conal has some sibling that's named simple 'nal'
23:10:54 <johnw> Is the precedence right here: echo =<< LT.pack . show <$> canonic "blah"
23:10:58 <ddarius> zzing: What?
23:11:02 <cads> simply*
23:11:06 <ddarius> zzing: "Didn't like it" how?
23:11:22 <zzing> Give me a sec and I will get the error
23:11:45 <scshunt> man, the Q monad is the best
23:11:57 <zzing>     Couldn't match expected type `String'                with actual type `Shelly.FilePath'      I have to find out to make sure this FilePath is what i am expecting
23:12:12 <ddarius> zzing: That's a different FilePath.
23:12:21 <zzing> yeah it is
23:12:23 <ddarius> You should see what the correct function is to render it (which may be show).
23:12:24 <zzing> opaque
23:12:34 <luite> shelly reexports the one from system-filepath
23:12:35 <ddarius> Though I dislike abusing show (though this isn't that bad.)
23:12:39 <johnw> it's toTextIgnore
23:12:46 <johnw> or toText, if you want an exception
23:13:15 <johnw> then you don't need the pack
23:13:22 <zzing> Is this really necessary all this rigmoral?
23:13:23 <ddarius> scshunt: You can have your users email spam as the build your code!
23:13:25 <johnw> echo =<< toTextIgnore <$> canonic "blah"
23:13:38 <scshunt> ddarius: .. that is hilarious
23:13:43 <scshunt> ddarius: I want to implement this now :P
23:15:09 <zzing> I decided to use shelly because bash is just finicky I have found and I want this to be mostly bulletproof
23:17:02 <ddarius> zzing: The tao of Haskell is explicitness.
23:18:02 <luite> zzing: shelly uses the system-filepath FilePath type ince the FilePath = String from Prelude is not quite right, unix filepaths are sequences of bytes, not sequences of unicode characters
23:18:23 <johnw> i like shelly too
23:19:03 <zzing> ddarius, would it be possible to make a haskell lookalike that could detect a lot of usages and sort of make certain things implicit - so maybe be able to detect where it has to lift or the common <$> <*> patterns
23:19:45 <johnw> you know, while that sounds like it would make code easier to write and read, I don't think it would beyond simple cases
23:19:54 <Nafai> shelly gives me an idea.  Perhaps I'll rewrite one of my small utilities written in Python in Haskell
23:20:10 <johnw> imagine the type errors if you had layers of implicit function calls between you and the code
23:20:21 <zzing> johnw, would that be an interesting topic for a research paper?
23:20:23 <johnw> Nafai: I've done that too
23:20:30 <johnw> zzing: others have written about this befoer too
23:21:05 <Nafai> johnw: I've been meaning to add features to this anyway: https://github.com/travisbhartwell/utilities/blob/master/HOME/bin/stow-in-home.py
23:21:12 <zzing> I am very interested in how haskell could be used as a vehicle to liberate the world from the tyranny of the dynamic scripting language‚Ä¶ :P
23:21:30 <johnw> zzing: I have a blog article you might like coming up tomorrow
23:21:45 <zzing> johnw, where is your blog
23:21:51 <johnw> you can go far with the Free monad toward liberated DSLs
23:21:55 <johnw> http://www.newartisans.com
23:22:30 <zzing> I liked the "monads in pictures" it was very useful
23:22:31 <Ralith> Enigmagic: can you elaborate?
23:24:53 <zzing> those letters to the fsf, was there ever a response?
23:25:46 <johnw> you mean, from RMS?
23:25:49 <johnw> yes, several letters
23:26:00 <johnw> but it isn't my place to publicize his words
23:27:26 <zzing> Can you say whether or not he accepted your arguments or if he elaborated on his own?
23:28:08 <johnw> he most certainly did not accept them
23:28:19 <zzing> Now that I get to one paragraph I can certainly what he would not agree with :p
23:28:50 <pharaun> what letter?
23:29:04 <zzing> http://newartisans.com/2011/04/letter-to-the-fsf/#more-229
23:29:17 <pharaun> reading
23:29:31 <Enigmagic> Ralith: there are 5 or so forks that have patches that are all trying to do the same thing..
23:30:20 <Enigmagic> since pull requests don't get looked at in a timely manner myself and other fork maintainers don't make it a priority to get patches in a merge-ready state for pull requests
23:30:43 <Ralith> Enigmagic: what thing is it that needs doing?
23:30:47 <Ralith> (beyond 'build')
23:31:22 <Enigmagic> Ralith: supporting different versions of llvm is the most common
23:32:02 <zzing> johnw, one point "copyright cannot exist in yours" his world relies heavily on copyright to protect and enforce the license. I believe he was fairly clear on that point. Otherwise i do like the general letter you wirite.
23:32:04 <Ralith> Enigmagic: perhaps you should merge things together and submit an alternative package, then?
23:32:24 <johnw> zzing: that is a fair point
23:32:31 <johnw> mind adding a comment to the discussion?
23:32:43 <zzing> yeah, i can do that
23:33:36 <zzing> johnw, is that a wordpress blog?
23:33:48 <johnw> i host it on my own server, running wordpress there
23:34:14 <zzing> Only thing that gave it away was the login links
23:34:32 <Enigmagic> Ralith: i'm going to dedicate time to migrating to the native type-nats extension once it gets merged into ghc, whenever that happens, and i'll be merging in patches from various forks at that time.
23:35:05 <zzing> I am trying out clckwrks, but need the thing I am writing now to be able to manage the stuff because I am doing some development with it too
23:35:12 <Ralith> Enigmagic: what bearing does that have on llvm?
23:35:58 <Enigmagic> Ralith: faster compiles for me :-) our builds of the packages that use the llvm bindings take about 20 minutes
23:36:57 <Ralith> oh damn
23:37:13 <Ralith> that's pretty terrible
23:38:00 <Enigmagic> Ralith: yeah... mostly due to llvm's usage of the type-level package. i've basically had to stop working on our compiler for the time being since compiles are so slow. i'm hoping that native type-nats support in ghc can bring that down to a reasonable time.
23:38:31 <scshunt> anyone know a library for sending email?
23:38:32 <Ralith> Enigmagic: could just use llvm-base >_>
23:39:02 <Enigmagic> no point in writing it in haskell then :P if i'm going to give up compile time type safety i'll just write it all in c++ instead
23:39:31 <zzing> johnw, comment added, I even found where RMS said about copyright
23:40:11 * Ralith hasn't looked much at the bindings yet, but suspects that you can manage basic type safety without needing to do crazy slow-compiling shenanagans
23:41:12 <zzing> Its kind of a look back in history: http://onlamp.com/pub/a/onlamp/2005/09/22/gpl3.html?page=1   In 2005, there was the talk of open source vs. free software, I don't know if that discussion really died in the community, and back then I might have cared.
23:42:38 <bindy> hi guys, I realized that my results are cached when using HDBC. This means that a particular query returns the same result using the same connection every time, regardless of the state of the db. Am I using it wrong?
23:43:53 <Enigmagic> Ralith: certainly yes, the examples that come with the bindings don't take very long to compile.
23:47:27 <Enigmagic> Ralith: i at least understand why it's slow but the alternative is to give up type safety. instead i'll just wait for type-nats support in GHC and fix the library.
23:48:07 <zzing> Thank you all and good night
23:48:24 <Ralith> Enigmagic: surely it's not black and white
23:48:34 <belgin> How would Map's (from Data.Map) data constructors look like? data Map a b = [(a, b)] ? what if a or b are empty lists?
23:49:28 <belgin> i'm following LYAH and i can't figure out how to make a Map functor and looking at the source doesn't help much either
23:49:58 <u_> belgin: if map were like that there would be no reason to use it instead of lists
23:50:14 <u_> belgin: it's a tree of some sort. for faster lookup
23:50:28 <ddarius> This "Supremely Spicy Hummus" has some kick to it.
23:50:58 <belgin> u_: i know it's some sort of tree structure, but let's pretend it's not, how would its data constructors look like?
23:52:35 <u_> i don't know what you mean. its a tree because of what data constructors it has
23:53:21 <belgin> i mean, let's pretend Map is implemented with lists
23:54:00 <u_> then its data constructors would be : []
23:54:48 <belgin> so then how would "data Map a b" look like? like i said above?
23:56:08 <Enigmagic> Ralith: it pretty much is in this case. it's either going to happen at compile time or runtime. i picked compile time and it's slow.
23:56:10 <ddarius> belgin: data is used to declare a new data type with its own constructors.  If you want to represent Map directly as a list, then you would use 'type'.
23:56:52 <ddarius> belgin: You could make Map a data type that just wraps a list in which case it would have a single data constructor containing the list.  In this scenario, newtype is typically preferred.
23:57:04 <belgin> i see
23:57:24 <Ralith> Enigmagic: well, the C++ isn't entirely unsafe and compiles fairly fast (as far as C++ goes)
23:59:30 <Enigmagic> Ralith: yep but it loosely enforces type checks at runtime. i've written a number of llvm based compilers in C++ and i definately prefer compile errors vs runtime asserts :-)
23:59:57 * Ralith has written a number in lisp, and reluctantly agrees
