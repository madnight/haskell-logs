00:00:24 <morel> gui programming sucks.
00:01:06 <Nereid> yep, time for bed
00:01:08 <Nereid> bye
00:03:05 <savask> Hello. Is there a way to specify another compiler in cabal file? I have to install GHC 7.4.2 because of the MVar bug, but I don't want to spoil system's package management.
00:09:08 <Enigmagic> savask: if you upgrade compilers (even dot builds) you'll need to rebuild your packages.
00:09:33 <savask> Enigmagic: All of them?
00:09:38 <Enigmagic> savask: yes.
00:09:42 <savask> Noooo
00:10:15 <savask> Enigmagic: I need 7.4.2 only for one build, maybe there is another way?
00:10:39 <Enigmagic> savask: is it a compiler bug or a library bug? if it's in base you'll need to rebuild everything.
00:11:03 <savask> Enigmagic: Probably it's compiler bug, but I'm not sure.
00:12:05 <Enigmagic> savask: if it's this bug http://hackage.haskell.org/trac/ghc/ticket/5943 you'll definitely need to rebuild everything.
00:12:55 <savask> Enigmagic: Yeah, this one. God why...
00:13:40 <Enigmagic> savask: in this particular case you're boned because the bug will be inlined across all your packages
00:14:24 <Enigmagic> you can probably automate most of the rebuild if you haven't patched any packages manually
00:14:42 <savask> I patched some.
00:14:55 <Maiz_en_Heces> Why does Freenode tolerate child pornography?
00:14:55 <Maiz_en_Heces> http://pastebin.com/aacTUjjb
00:14:56 <mauke> The paste aacTUjjb has been copied to http://hpaste.org/72588
00:15:15 <Enigmagic> ghc-pkg list > old.packages && upgrade compilers && cat old.packages | xargs cabal-install --dry-run
00:15:51 <savask> Enigmagic: What does that do?
00:16:19 <Enigmagic> savask: nothing. 'ghc-pkg list > old.packages' will save your currently installed package list to a text file named old.packages
00:17:02 <Enigmagic> savask: do that first, then upgrade your GHC version. running "cat old.packages | xargs cabal-install --dry-run" will tell you if cabal could install all your old packagse
00:17:36 <savask> Hmm
00:17:52 <ReinH> Ok, so I think I'm finally starting to grok lenses a big <3
00:17:58 <savask> Looks like I'm going to spoil the whole thing.
00:18:52 --- mode: ChanServ set +o mauke
00:18:53 --- mode: mauke set +q $a:Maiz_en_Heces
00:18:54 <Axman6> Maiz_en_Heces: this is definitely not the place to discus the issue. if you have a problem, then you were already in the right channel in #freenode
00:19:12 <mauke> Maiz_en_Heces: come to #haskell-ops if you want to discuss your mute
00:20:39 * morel waves to Axman6 (while) slowly mouthing "hello" =)
00:20:53 --- mode: mauke set -o mauke
00:21:06 <Axman6> helloÖ that is not a nick I'm familiar with...
00:21:20 <savask> Enigmagic: I'm repeating myself, I think, but it there a way to install GHC without overwriting my current version? So I could use it for compiling that "bad" program without the need to recompile everything.
00:21:23 <ReinH> If I have a lens into [a], is there an simple way to create a lens into [[a]]?
00:22:29 <Enigmagic> savask: no, it's not a compiler bug. it's a library bug that may have propagated through all of your packages. upgrading the compiler by itself (it is technically possible) wouldn't fix all of your bad packages.
00:23:11 <savask> Enigmagic: Maybe I can update only that library then?
00:23:15 <Enigmagic> savask: or to your point, it is possible to install multiple versions of GHC side-by-side. just put it in a new location and update your PATH.
00:24:43 <Enigmagic> savask: you'll need to upgrade all packages that depend on the bad library. in this case, it's in base... and all packages depend on base. and base ships with the compiler... so you'll need to upgrade the compiler and rebuild all your libraries
00:25:09 <savask> Oh, I see.
00:25:12 <Enigmagic> or fix your code to work around the bug
00:25:24 <savask> It's not even my code...
00:32:27 * edwardk waves hello.
00:32:28 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
00:32:44 <Franciman> hi all
00:35:46 <Macil> What's the most simple and fool-proof way to make a persistent key-value storage in haskell?
00:37:26 <latro`a> persistent?
00:38:51 <latro`a> I don't know what you mean by persistent
00:39:34 <thetallguy> Macil: perhaps you are looking for acid-state?
00:39:57 <latro`a> the absolute simplest key-value type is Data.Map
00:40:06 <latro`a> it may or may not do what you want
00:40:37 <morel> no, the absolute simplest is [(key,value)] (or ([key],[value])).
00:40:38 <thetallguy> simple and fool-proof are not necessarily compatible
00:40:42 <latro`a> er
00:40:45 <latro`a> touche, morel
00:41:54 <ReinH> ALs ftw
00:42:11 <ReinH> Macil: what does persistent here mean for you
00:42:11 <latro`a> if the number of associations is small at least
00:42:50 <Macil> ReinH: that data outlives it's creator
00:43:31 <latro`a> are you new to haskell, macil? because that notion doesn't really make sense in this context
00:44:19 <ReinH> persistent within some context is possible with f.e. Control.Monad.State
00:44:23 <latro`a> eh, ish
00:44:49 <ReinH> persistent within the context of the entire program is possible by f.e. wrapping IO with StateT
00:44:58 <ReinH> there are other options that are more performant, etc, but that's the basic idea
00:45:40 <ReinH> the idea of a "persistent storage" isn't very meaningful unless you know in what context you want to share that state
00:46:49 <levi> All values in Haskell persist indefinitely conceptually, it's just that some of them are no longer referred to.
00:47:32 <morel> latro`a: huh?
00:47:38 <latro`a> huh @ what
00:47:39 <ReinH> levi: I'm not sure how that's a useful definition of persistent here :p
00:47:48 <Macil> ReinH: Some demon periodically wakes up to do some job. It needs some storage to keep "state" between wake-ups, as well as terminations.
00:48:08 <levi> Well, elaboration on that idea leads to 'persistent data structures'.
00:50:08 <levi> You probably want to serialize and store data somewhere, and then retrieve it later, somewhat transparently?
00:50:09 <ReinH> Macil: read-only state? mutable state?
00:50:31 <ReinH> and you want this state to be durable across restarts of the process?
00:50:54 <Macil> thetallguy: already found... but I'm really scared by it's serialization format.
00:51:02 <ReinH> then you probably want to talk to some external persistence (file, database, etc)
00:52:14 <morel> so what's the difference between acid-state and hdbc-sqlite3?
00:53:44 <donri> acid-state is in-memory for arbitrary haskell data structures, scales well concurrently and provides strong ACID  semantics
00:54:00 <ReinH> Macil: if you want process-local state, wrap a Map in a State monad
00:54:09 <Enigmagic> and it apparently takes forever to start up on a small database like hackage ;)
00:54:18 <ReinH> Macil: if you want external state, use a Redis monad or write to a file or whatever
00:54:34 <ReinH> or do something cool/crazy like Acid.State
00:54:44 <morel> donri: so i can't save it in a file?
00:55:04 <donri> morel: it is logged to files
00:55:16 <donri> morel: it's similar to redis
00:55:44 <ReinH> donri: very interesting :)
00:55:49 * morel doesn't know redi‚Ä¶ oO
00:55:58 <morel> *redis
00:57:06 <Macil> ReinH: Redis is good... but for this task i'ts too complicated
00:57:38 <Macil> ReinH: BerkeleyDB is good, but it's the pain to use i'ts bindings
00:58:44 <ReinH> Macil: figure out what kind of storage you want and then look for a package :)
01:01:47 <mikeplus64> is it possible to have a QuasiQuoter return something Num a => a ?
01:02:38 <Macil> donri: Is it simple to write serialization back-end for acid-state?
01:04:00 <mikeplus64> (to answer my question: yes, integerL works fine)
01:05:17 <donri> Macil: not sure what you're asking. the networked backend is less than 100 lines IIRC
01:05:25 <donri> http://hackage.haskell.org/packages/archive/acid-state/0.6.5/doc/html/src/Data-Acid-Remote.html
01:06:29 <donri> although it just exposes another backend like local, also not that many lines: http://hackage.haskell.org/packages/archive/acid-state/0.6.5/doc/html/src/Data-Acid-Local.html
01:08:22 <donri> although if you're going to try something like sharding, that's much more complicated because the data isn't partitioned in a known way (arbitrary haskell structures)
01:15:36 <Macil> donri: no I don't. The storage is neither high-load nor high-volume...
01:16:25 <thetallguy> Macil: you just have to use data structures that can be serialized.  Most can be handled with automatic deriving.
01:22:29 <Macil> thetallguy: well, acid-states seems fit although low-level it is
01:23:12 <thetallguy> Macil: what would you define as high level?
01:23:33 <PaulVisschers> Is it possible to rebind the list syntax?
01:23:38 <thetallguy> you manipulate your data with Haskell, acid-state stores it to disk.
01:24:33 <thetallguy> PaulVisschers: no, but you might be interested in monad comprehensions
01:25:26 <PaulVisschers> thetallguy: I actually want to use it for vectors (with lengths indexed in types)
01:26:51 <PaulVisschers> thetallguy: but that wouldn¥t work I guess, even if you could make [1,2,3] to rewrite to fromList [1,2,3] everywhere you still couldn¥t use it for pattern matching
01:27:02 <thetallguy> PaulVisschers: conal did something with vectors with length in the types not long ago
01:27:40 <thetallguy> PaulVisschers: right, though you might be able to do something with quasiquoting
01:28:31 <Macil> thetallguy: something that don't distracts you from your domain
01:28:44 <thetallguy> PaulVisschers: http://conal.net/blog/posts/fixing-lists
01:31:54 <PaulVisschers> thetallguy: I can already define vector types myself, but it¥s cumbersome to write Cons x (Cons y Nil) instead of [x, y]
01:32:36 <thetallguy> PaulVisschers: you can define infix constructors
01:32:40 <PaulVisschers> I would actually like to overload [x,y], (:) and [] and still be able to pattern match on them
01:33:12 <thetallguy> PaulVisschers: Instead of Cons, define (:+) or similar
01:33:37 <PaulVisschers> thetallguy: I know, but that¥s only slightly less annoying
01:34:01 <thetallguy> PaulVisschers: well, all that's left is quasi-quoting
01:34:15 <PaulVisschers> thetallguy: yeah I¥ll look into that, thanks
01:35:33 <thetallguy> you can write a wee parser, with a tag, then write [tag|x,y,z|]
01:35:43 <thetallguy> but you can't write patterns
01:35:58 <thetallguy> that is, you can't pattern match using the same syntax
01:40:11 <PaulVisschers> thetallguy: that¥s not really all that great though
01:41:20 <thetallguy> PaulVisschers: no. The infix constructors are the closest to what you want.
01:41:45 <thetallguy> PaulVisschers: and really, they are quite good compared with what you can get elsewhere.
01:41:49 <PaulVisschers> thetallguy: yup, seems that way
01:42:05 <thetallguy> you could use the quasiquoting for input
01:42:15 <thetallguy> and pattern match with the infix constructors
01:42:44 <thetallguy> but then, that's about the same as using fromList
01:42:58 <PaulVisschers> thetallguy: maybe I¥ll write my own extension for overloaded data constructors, could be interesting
01:43:38 <thetallguy> you might want to look at haskell-src-exts
01:43:57 <thetallguy> and packages like hsx that use it.
01:44:40 <thetallguy> harp is part of that.  It looked great when I read about it, but in practice, I found it all quite frustrating.
01:44:52 <thetallguy> but I have colleagues who use it regularly.
01:44:52 <PaulVisschers> thetallguy: thanks
01:45:05 <thetallguy> me, I just suck it up and write the haskell these days.
01:45:07 <PaulVisschers> thetallguy: I¥m actually not familiar with harp, what is it?
01:45:09 <PaulVisschers> brb
01:45:16 <thetallguy> I like the consistency of the error messages
01:45:32 <thetallguy> PaulVisschers: harp is regular expression pattern matching
01:45:51 <thetallguy> PaulVisschers: http://hackage.haskell.org/package/harp/
01:47:01 <thetallguy> PaulVisschers: http://hackage.haskell.org/package/haskell-src-exts/
01:48:50 <donri> thetallguy: you can use QQs in patterns
01:49:17 <donri> quotePat
01:49:46 <Palmik> Hi guys. I'm using haskell-src-exts for parsing expression with decorated identifiers that get later transofrmed. The thing is that the decoration ({<ident>}) makes the identifiers invalid and so I would have to run the transformation beforehand (otherwise the "parseExp" fails), but that is also troublesome since I want to enable only identifier decoration (only Var . UnQual . Ident)... so I'm stuck in this weird cycle. One solution would be to
01:49:47 <Palmik> choose a decoration that does not invalidate an identifier (for example __<ident>__), another would be to modify the "parseExp" parser (I would rather avoid that) but none of these is ideal for my cause. Does anyone here have another idea?
01:52:20 <donri> Palmik: maybe your best bet is to contribute an extension to HSE :(
01:56:45 <Palmik> donri, hmm, that might be the case indeed.
02:02:30 <jirka> info ido
02:05:34 <jaredc> @hpaste
02:05:34 <lambdabot> Haskell pastebin: http://hpaste.org/
02:06:46 <hpaste> jaredc pasted ‚Äútype inference question‚Äù at http://hpaste.org/72593
02:07:12 <jaredc> why can't ghc infer the type here without an annotation?
02:07:57 <jaredc> the only thing i can think of is that i am using a list type
02:08:37 <donri> @wiki MR
02:08:37 <lambdabot> http://www.haskell.org/haskellwiki/MR
02:08:40 <donri> jaredc: ^
02:09:32 <jaredc> thanks
02:09:51 <latro`a> damned MR errors that don't cause it to whine about MR itself....
02:15:47 <mekeor> this might interest you: http://www.freetechbooks.com/functional-programming-f34.html
02:16:28 <Skola> I've been playing a bit with the code @ haskelllive.com, and was wondering what a good data structure might be in Haskell to store a chess position (keeping in mind that it will have to change very often)
02:17:23 <Skola> with mutable data updating a board would simply be board[1][2] = x
02:17:59 <srhb> Skola: Yes, but assuming you throw away the old board, the compiler can be smart about the structure. Consider for instance updating a map of coordinates.
02:18:21 <latro`a> depends how you want to do it really; there's simple list of lists, there's maps, there are immutable arrays, and there are mutable arrays
02:18:32 <latro`a> probably plenty more
02:18:36 <Skola> right now I have a string of 64 chars
02:18:49 <donri> Skola: data Row = A | B ... H; data Col = C1 | C2 ... | C8
02:18:57 <shachaf> srhb: The compiler can be smart how?
02:19:52 <Skola> donri: It's not hard to elegantly define a board, but I am mostly concerned about the way I update it
02:20:48 <latro`a> using a slower data structure might make it take slightly longer to show a premade game
02:20:57 <donri> data Pos = Pos Row Col; data Piece = Knight | Queen | ...; type Board = Map Pos Piece
02:21:07 <shachaf> Skola: The important thing is probably to make some abstract board type so that you can switch implementations if necessary.
02:21:12 <latro`a> but when actually playing a game, any of the data structures will be fine
02:21:13 <srhb> shachaf: I was thinking about things like diffarray mostly. I'm not sure if Maps are implemented similarly.
02:21:16 <latro`a> and yeah, that's also for the best
02:21:30 <donri> Skola: ^ with that, updating is easy as cake
02:21:42 <shachaf> Data.Sequence is a nice alternative to what might elsewhere be a mutable array.
02:22:00 <shachaf> srhb: DiffArray. :-(
02:22:01 <Skola> hm donri, yes it does look interesting
02:22:05 <srhb> shachaf: That bad?
02:22:19 <latro`a> starting out with [[Square]] like haskelllive did, and then making a little mini API that does everything you need, is probably ideal
02:22:24 <donri> Map.insert (Pos B C3) Knight board
02:22:56 <Skola> yes donri, you've convinced me :D
02:23:00 <Skola> looks good
02:23:17 <shachaf> srhb: In general the "you can write functional code and the compiler will turn it into code that does mutation" thing is a lie.
02:23:33 <donri> among the benefits are also that you can't put pieces outside the valid board or two pieces on the same position
02:23:34 <srhb> shachaf: I see.
02:23:54 <shachaf> It's very tricky to do well and it's unclear whether you want to do it at all.
02:23:56 <srhb> BUt that must mean a lot of unnecessary copies when an old value is never reused.
02:24:41 <donri> there's a lot of sharing and garbage collecting going on
02:24:43 <shachaf> A lot of the benefits of "functional data structures" come from the nature of the data structures.
02:28:17 <Skola> thanks for your input guys :}
02:28:39 <donri> have fun!
02:28:43 <Skola> cheers
02:43:10 <frerich> Hm, I have a little Haskell pet project which typechecks (and compiles without warnings) but running it yields 'main.hs: Prelude.(!!): negative index'; how would you guys debug this? I figured there are no stack traces available, but maybe there is some sort of 'reasoning tool' which works along the lines of "Well (!!) is called in these functions, and the index argument is coming from this other place..."
02:43:49 <donri> frerich: you could try compiling with -prof -rtsopts -with-rtsopts=-xc
02:44:19 <donri> but if the error is coming from your code i'd suggest grepping for !! and replace it with lookup
02:44:39 <donri> hm not lookup :) i guess safe package has safe !!
02:45:15 <frerich> Oh since the project is not big, I could probably just read the code very closely to find out what'sg oing on. I was just wondering whether tere's a technique which also works for bigger projects.
02:45:21 <frerich> Some function yielding an error.
02:45:50 <donri> the technique is to avoid partial functions :)
02:46:04 <frerich> Well yeah :-)
02:46:37 <donri> also if you find yourself using !! you should probably either refactor the code to use recursion patterns instead or replace the list with a vector or something
02:46:52 <frerich> Of course. The code is very inefficient as it is (it uses nested lists and (!!) ...)
02:47:20 <frerich> I was planning to replace the plain ol' lists with something more suitable, but now that I have this error it would be a good exercise in debugging :)
02:47:55 <frerich> donri: FWIW, compiling with the options you suggest makes the program yield '<GHC.List.CAF>main: Prelude.(!!): negative index'. A bit more verbose, but not much. :-}
02:47:58 <donri> sadly such errors aren't all that easy to debug in haskell currently
02:48:31 <frerich> Hm, I see. Of course I totally agree that it would be better if the code didn't allow this kind of problem to occur in the first place (by not using partial functions, for instance).
02:48:36 <donri> frerich: hm ok. in theory it's supposed to give you stack traces "sort of", but i've never gotten much useful info from it myself either
02:48:49 <frerich> Actually, even with partial functions - somebody could still use "error".
02:48:50 <frerich> err
02:48:54 <frerich> with total functions.
02:49:04 <donri> yes there are better ways to write partial code that yields better errors
02:49:21 <donri> > let Just x = Nothing in x
02:49:23 <lambdabot>   *Exception: <interactive>:3:4-19: Irrefutable pattern failed for pattern Da...
02:49:52 <donri> that's the same as fromJust, but shows the source location
02:50:16 <donri> > fromJust Nothing
02:50:17 <lambdabot>   *Exception: Maybe.fromJust: Nothing
02:50:53 <donri> there's also things like "assert" and the file-location package
02:51:18 <donri> http://www.haskell.org/haskellwiki/HaskellImplementorsWorkshop/2012/Marlow
02:52:21 <frerich> hmm...
02:54:11 <donri> frerich: what happens if you also add these flags:  -fprof-auto or -fprof-auto-calls
02:54:45 <frerich> donri: My ghc doesn't know either, must be a newer feature?
02:54:49 <donri> aha
02:55:04 <donri> http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Debug-Trace.html#v:traceStack
02:56:11 <frerich> Ah, that looks interesting
02:57:33 <frerich> assert() is quite nice.
02:57:54 <frerich> At least it gives the file name/line number.
02:58:35 <hpaste> trem pasted ‚Äúindex out of bounds‚Äù at http://hpaste.org/72594
02:59:24 <trem_> in the paste above, can someone explain to me how to avoid getting index out of bounds errors on line 14?
03:00:06 <trem_> i'm checking for the empty vector case on line 5 already, but recently it starts to slip through
03:01:27 <donri> ah yea -fprof-auto actually works, cool!
03:01:51 <warpy> hi, i am trying to play with parsec in ghci. when i type let eol = char '\n', i get an error saying "No instance for (Stream s0 m0 Char) arising from a use of `char'"
03:02:02 <warpy> what am i doing wrong?
03:03:38 <frerich> donri: Currently updating to ghc 7.4.1, let's see...
03:04:35 <mauke> warpy: :set -XNoMonomorphismRestriction
03:05:39 <warpy> mauke: it worked. what was i doing wrong?
03:05:53 <mauke> nothing
03:06:39 <warpy> then why did ghci threw that error?
03:07:36 <srhb> Is there any way for Haskell to move the mouse cursor?
03:07:51 <mauke> warpy: because the type of eol was too polymorphic
03:08:08 <mauke> http://www.haskell.org/haskellwiki/Monomorphism_restriction
03:13:18 <warpy> mauke: thanks
03:32:49 <iamtakingiteasy> hi, how do i express a data type that holds a list of values which are types instantiated for specific typeclass?
03:33:04 <mauke> why do you want that in the first place?
03:33:52 <sipa> sounds like you want an existential
03:34:19 <Athas> iamtakingiteasy: [forall a. Foo a => a]
03:34:56 <mauke> Athas: no
03:35:05 <Athas> Oh, right, you have to wrap it in another type first.
03:35:05 <iamtakingiteasy> i want to handle any [value] for which my class is implemented
03:35:19 <mauke> iamtakingiteasy: stop repeating yourself
03:35:26 <iamtakingiteasy> i am answering your question
03:35:30 <mauke> no, you're not
03:35:32 <frerich> donri: Indeed, with ghc 7.4.1 and -fprof-auto-calls I get stack traces :-)
03:35:41 <shachaf> Athas: It's not just "wrapping it in another type", it's a completely different thing.
03:35:48 <Athas> shachaf: I am aware.
03:36:28 <mikeplus64> what's the equivalent of mapM_ for repa arrays?
03:36:31 <shachaf> Also, mauke's question.
03:37:08 <iamtakingiteasy> mauke: then what do you want from me? i have a base class with some methods defined and i wish to have a list of values for which this base class is implemented, so i can call methods on this values and get the job done
03:37:57 <shachaf> iamtakingiteasy: Type classes are not OO classes.
03:38:24 <shachaf> One question is whether type classes are what you want in the first place.
03:38:25 <mauke> iamtakingiteasy: yes, why do you have that?
03:39:24 <iamtakingiteasy> i wish to have an extendable system where new type of value can be added merely by implementing this class interface for this new type
03:39:58 <Athas> iamtakingiteasy: http://hpaste.org/72595 <- I think this shows you one way in the direction you're going, but that direction is probably not a good idea.
03:40:09 <mauke> iamtakingiteasy: why?
03:40:32 <Athas> Be wary of straying too close to OOP with type classes.  They're not really meant for that.
03:41:07 <Athas> If a pseudo-OO approach really is needed, I generally find it better to use explicit dictionaries.
03:41:43 <shachaf> iamtakingiteasy: mauke's question is probably a good one to answer. :-)
03:41:59 <frerich> iamtakingiteasy: If you wish to allow your function to deal with different types of values, you could also consider to pass functions instead of values. Like, instead of 'f :: (Eq a) -> a -> Bool' you could also have 'f :: (a -> a -> Bool) -> Bool'
03:42:22 <frerich> (forgot one 'a')
03:42:33 <mikeplus64> iamtakingiteasy: another way you could do an "extensible" sort of system, is to have a list of functions
03:42:48 <mikeplus64> (that match the type you want)
03:43:01 <shachaf> I think all the answers people are giving are useless without knowing the answer to mauke's question.
03:43:37 <statusfailed> iamtakingiteasy: Can we get a more concrete example of what you're doing?
03:44:27 <iamtakingiteasy> mauke: because i want each user of my library to have ability to add own new types and make them work together with pre-defined types and types defined by other users; so he can add new type, implement class methods to it and then use them as othes trhough class interface
03:44:34 <iamtakingiteasy> statusfailed: yes, i am implemnting a brainfuck interpreter
03:44:59 <iamtakingiteasy> i wish to have not only usual instructions, but also ability to add compeltly different and new insturction sets
03:45:48 <iamtakingiteasy> so bf extentions can be implementing merely by implementing methods of BFCmd typeclass for this instruction sets
03:45:50 <Athas> Instead of using a type class with methods, why not represent a new instruction/instruction set as a value of some type, that contains functions for changing the machine state?
03:45:54 <mikeplus64> iamtakingiteasy: for that, a list of functions providing each instruction might work
03:46:38 <Athas> Like, data Instruction = Instruction { execute :: MachineState -> Maybe MachineState }.
03:46:59 <frerich> Now, of course one might wonder why that is any better than a type class...
03:47:17 <Athas> Because you don't need heterogeneous collections.
03:47:41 <Athas> It's far simpler for the type system.
03:48:07 <shachaf> It's far simpler in general.
03:48:19 <frerich> How so?
03:48:45 <Athas> An array of instructions when defined as above is just 'Array Int Instruction'.
03:49:16 <Athas> If an instruction is just some value that's an instance of an Instruction typeclass, you need to pack it in some other type and do all sorts of boilerplate.
03:50:08 <frerich> I think now you're at the point the whole discussion should've started.
03:50:26 <frerich> Giving an answer, then showing the issues with it (so that you have a motivation to look for something else), then suggest the better alternative
03:51:25 <Athas> Also, with a few extensions, you can still do neat things like giving each instruction some internal state: data Instruction = forall a . Instruction { execute :: MachineState -> (MachineState, a), internalState :: a }.
03:51:25 <Athas>  
03:51:36 <Athas> I used something like that when implementing an interpreter for an object oriented language.
03:52:02 <Athas> Er, that execute should probably also take an 'a' as input.
03:52:06 <iamtakingiteasy> oh, thats exactly what i was looking for!
03:52:27 <iamtakingiteasy> some instruction state or attached context
03:52:48 <iamtakingiteasy> Athas: thank you!
03:54:03 <shachaf> Athas: Hmm?
03:54:07 <shachaf> Are you sure you need that?
03:54:41 <Athas> shachaf: yes.  How else would the instruction know its own state?
03:55:27 <shachaf> I'm not sure what you mean.
03:55:35 <shachaf> For tat matter I don't see how the type you gave is useful.
03:55:40 <shachaf> Oh, you added an "a" argument.
03:56:02 <hpaste> Athas pasted ‚ÄúFor iamtakingiteasy, fuller example‚Äù at http://hpaste.org/72598
03:56:04 <shachaf> How do you propose to use this?
03:56:21 <shachaf> Oh, you're returning a new Instruction.
03:56:37 <Franciman> hey people, is there the equivalent of ArrowLoop or MonadFix for Applicative?
03:56:40 <shachaf> So why not return a new execute function that has the state in it already?
03:57:03 <Athas> shachaf: in this case, that is what you should do.  For my interpreter, there are many functions ("methods"), though.
03:57:12 <Athas> My example is more general.
03:57:38 <shachaf> So "this is the wrong thing to do in this case, but the right thing to do in some other unspecified case"?
03:58:01 <Athas> Yes, this is a demonstration of a general technique, which is more valuable in the long run.
03:58:17 <shachaf> If so maybe it's not good advice to give to someone who is clearly already trying to fit OO things where they don't belong. :-)
03:58:29 <shachaf> Athas: Can you give an example where this technique is more valuable?
03:59:35 <Athas> I mean, if you want it as simple as possible, then 'newtype Instruction = Instruction (MachineState -> (MachineState, Instruction))'.
03:59:50 <nand`> ReinH: it just occurred to me that you could use indexed traversals very elegantly for your use case. If you have a ‚Äòtwo dimensional‚Äô array (in reality nested arrays) and indexed traversals into each of these, you can combine them to get an indexed traversal with index Ix a => (a, a)
03:59:50 <Athas> shachaf: as I said, if you have more than one function that operates on the state.
04:00:19 <Athas> Particularly if you have some container of functions, as for example a Data.Map of methods.
04:00:39 <shachaf> Athas: Any reason not to do the same thing?
04:01:20 <Athas> shachaf: then as input the execute function would take a list of all available methods, and similarly return a new list of methods?
04:01:32 <Athas> That seems less robust against programming errors.
04:01:41 <shachaf> I'm not saying there's no use to this "general technique", but it seems a bit special-purpose.
04:02:42 <Athas> It's the most general technique I know of for associating a datum with operations.
04:02:45 <shachaf> In particular the idea of "keeping state in lexical scope" seems in general to be a lot more valuable to me. :-)
04:02:49 <nand`> ReinH: there's an indexed traversal in Data.Array.Lens
04:04:15 <Athas> I don't think it's an accident that I used this technique to implement an interpreter for an object oriented language, and iamtakingiteasy could use it for a Brainfuck interpreter.  It's pretty much only useful for state encapsulation in a way that you won't need in most Haskell programs.
04:04:36 <Athas> I had to model stateful objects, and he has to model stateful... well, also objects, really.
04:04:58 <Athas> I would never use this for more general Haskell programming.
04:05:30 <shachaf> What isn't a stateful object?
04:05:32 * dottedmag looks at MachineState
04:05:44 <dottedmag> Looks suspiciously similar to State monad
04:06:00 <shachaf> The internal state iamtakingiteasy presumably wants also involves interaction of two instructions, [ and ]
04:06:33 <sipa> when was the Functor typeclass introduced?
04:07:01 <nand`> ReinH: sorry, no, there isn't an indexed traversal in Data.Array.Lens
04:11:43 <Athas> dottedmag: it *is* a State monad.  In fact, for my own uses, the execute method is actually a monadic action whose state is both the machine- and instruction state.
04:12:01 <Athas> I suppose my demonstration wasn't general enough.
04:12:46 <nand`> @ask edwardk I've noticed that traversals, folds and maps can often be interchanged, eg. adjust mapped = adjust traverse; is there any general example for when this is not the case? Eg. why does Data.Array.Lens.amapped exist?
04:12:47 <lambdabot> Consider it noted.
04:13:24 <nand`> @tell edwardk (apart from trying to read from a map or write to a fold, I meant)
04:13:24 <lambdabot> Consider it noted.
04:18:02 <donri> edwardk's uncanny ability to join just after someone leaves a lambdabot message
04:20:34 <theadmin> So I have a String with a bunch of stuff in it. In this String, there's a sequence of characters enclosed in "" (double quotes). I need to extract the said sequence. Sorry, noob here.
04:21:16 <theadmin> Example: "blah blah \"foo bar\" blah" -> "foo bar"
04:21:38 <Athas> theadmin: look into dropWhile and takeWhile.
04:21:44 <donri> or parsec
04:21:59 <Athas> (Also: obligatory "don't use Strings, they're inefficient".)
04:23:41 <ion> (Also: obligatory ‚Äúpremature optimization is stupid‚Äù.)
04:24:16 <theadmin> Athas: Uh... Well... I'm somewhat familiar with those. They take a predicate and "take" (or "drop") while it's true, but I somehow don't see how to apply them here
04:24:45 <Athas> theadmin: drop characters until the first double quote, then take from the remaining until the next double quote.
04:25:25 <Athas> > :t dropWhile (/='"')
04:25:27 <lambdabot>   <no location info>: parse error on input `:'
04:25:33 <Athas> :t dropWhile (/='"')
04:25:34 <lambdabot> [Char] -> [Char]
04:25:43 <Athas> Try seeing how that behaves.
04:25:53 <donri> although if you need to e.g. skip escaped quotes it's trickier (probably easier with parsec)
04:26:04 <Athas> Yes, use Parsed for anything that's not trivial.
04:26:25 <theadmin> No escaped quotes here (I know the exact file I will be parsing, though it's too big to handle manually -_-)
04:27:04 <Athas> I can give you the entire solution if you want, but it's probably instructive to become familiar with the drop/take family of functions.
04:27:18 <ion> That kind of a thing could be done trivially to a number of lines in Vim, too.
04:27:22 <theadmin> Athas: I think I almost figured it out :D
04:28:18 <Athas> ion: yes, by using :! to execute ghci with the proper Haskell program!
04:28:24 <ion> heh
04:31:10 <nand`> @ask edwardk Also, are you going to be adding special operators for interacting with indexed traversals or just relying on stuff like ‚ÄòtraverseWithIndexOf‚Äô? I've noticed you're using .@ for composing indexed lenses, is this going to be a pattern?
04:31:10 <lambdabot> Consider it noted.
04:31:55 <theadmin> Bah, I ended up dropping everything BUT the double quotes :/
04:32:37 <theadmin> Well, that's *some* progress
04:32:43 <Athas> > drop 1 . dropWhile (/='"') $ "foo \"bar\" baz"
04:32:45 <lambdabot>   "bar\" baz"
04:33:15 <Athas> That's the first part.
04:34:16 <theadmin> Athas: Beat you to it, actually :P
04:34:40 <Athas> How can you get the desired result from that?
04:34:58 <theadmin> It works now, now I only have to figure out why my other function misbehaves but I'll get that one... I think my file has invalid newlines -- Haskell assumes UNIX-style line endings, right?
04:35:19 <theadmin> Athas: takeWhile (/='"') that
04:35:40 <Athas> I think Haskell, by default, assumes the default line-ending on your platform.
04:36:16 <danil> lines "foo\r\nbar" is giving me ["foo\r", "bar"] on Windows
04:36:35 <danil> (is that the right order?  I always forget)
04:37:00 <Athas> You can use hSetNewlineMode to change it.
04:50:15 <theadmin> And let me guess, that's defined in System.IO
04:50:30 <donri> danil: CRLF where CR=\r LF=\n
04:51:04 <donri> carriage Return / liNe feed
04:51:06 <Athas> theadmin: yes.
04:58:31 <Skola> has anyone on MacOSX gotten lambdabot to compile? specifically dealing with the libreadline problems?
05:04:06 <pshr> Hello, Can any one point me to an example of usage of runProcess from System.Process with handle instead of printing the output to stdout i need to capture the output of the command to a String so that I can display that on a webpage , I am using yesod.
05:07:21 <srhb> pshr: Wouldn't readProcess be simpler?
05:07:42 <srhb> pshr: Otherwise you should probably use runInteractiveProcess to get the handles returned.
05:08:22 <pshr> Thanks srhb will give it a try
05:09:09 <srhb> for instance, readProcess "ls" [] "" should give you the directory contents as an IO String
05:17:55 <timthelion> Hello, I'm writting a program which does Pixel Buffer opperations.  It then draws a series of pixel buffers onto the screen.  Is it somehow "better" to use OpenGL, if my transformations are all going to happen on the CPU?
05:18:21 <timthelion> Like is there any preformance gain over cairo, when simply drawing buffers of pixels?
05:19:08 <Athas> timthelion: Cairo can also use OpenGL for its rendering.
05:19:41 <Athas> There could be a performance difference, depending on how they do buffering or how they interact with the graphics hardware, but you can generally expect Cairo to be efficient.
05:19:52 <Athas> Especially for something relatively simple.
05:20:18 <timthelion> My next question, is if gtk2hs even supports this, I don't see any like [[Pixel]]->Pixbuf function :/
05:21:25 <timthelion> The main preformance drag for this program(as it's an advanced sort of image viewer) is scaling, and scrolling(the images are larger than the screen)
05:24:17 <MagneticDuck> hey, I'm learning the cabal package system
05:24:25 <MagneticDuck> can a package have multiple top level modules?
05:24:30 <MagneticDuck> exposed modules that is?
05:24:57 <Athas> MagneticDuck: yes.
05:25:07 <MagneticDuck> cool
05:25:08 <Athas> You just list them all under Exposed-Modules.
05:25:13 <MagneticDuck> alright, thanks
05:25:23 <Athas> There's no enforcing of any kind of hierarchy.
05:25:29 <MagneticDuck> ah
05:33:49 <ezyang> Is there a name for "generalized" difference lists (i.e. the difference list analogues for non-list data structures)
05:42:15 <danil> monoid morphisms to Endo ;)
05:42:43 <ezyang> ...I need to unpack that.
05:42:52 <ezyang> What is a monoid morphism? Do you mean monoid homomorphism?
05:43:25 <danil> yeah
05:45:03 <ezyang> What is monoidal in this case: the list?
05:45:29 <ezyang> I thought trees don't form a monoid...
05:46:53 <danil> the idea is that lists with append become difference lists with compose -- I'm not sure if that generalizes the way you want, though
05:51:19 <ezyang> Yeah, the construction is a bit more delicate ad not straight up function compositoin, alas.
05:53:27 <danil> What does the generalization look like on trees?  Do you represent a tree with a (single) hole in it as a function Tree -> Tree?
05:54:04 <ezyang> I only have it working for nested data-type trees, and there is a lot of gunk
05:55:06 <hpaste> ezyang pasted ‚ÄúcataLB‚Äù at http://hpaste.org/72599
06:05:17 <ezyang> ^-- that's it
06:15:36 <danil> Hmm, I see, you're building up a function that consumes a structure rather than one that produces one.  Reminds me more of implementing foldl with foldr than difference lists, honestly.
06:16:24 <ezyang> Well, if you pass in the appropriate constructors you end up with a binary tree :-)
06:16:33 <ezyang> so, it's more like implementing foldr with foldl
06:19:14 <heatsink> Outer a and inner r are the same
06:20:11 <hpaste> heatsink annotated ‚ÄúcataLB‚Äù with ‚ÄúRemoved an unnecessary type variable‚Äù at http://hpaste.org/72599#a72602
06:20:52 <ezyang> Huh, I was pretty sure I couldn't get that to type check.
06:21:28 <ezyang> ah, I see what you did there.
06:22:12 <t7> > find (\x -> x ^ x ^ x >= 2 ^ 64) [1..]
06:22:14 <lambdabot>   Just 4
06:22:24 <ezyang> then we can get rid of the 'n' argument
06:22:51 <ezyang> ...or not?
06:23:13 <ezyang> That is puzzling.
06:24:06 <heatsink> Yeah, you can
06:25:06 <hpaste> ezyang pasted ‚ÄúObvious version which doesn't work‚Äù at http://hpaste.org/72603
06:25:24 <ezyang> oh duh, because I need to adjust the type signature
06:29:23 <t7> @tell roconner how do i do modular division? because apparently its (a / b) `mod` c   /=     a / b (mod c)
06:29:24 <lambdabot> Consider it noted.
06:31:37 <heatsink> t7, I think you compute the modular reciprocal first
06:32:55 <danil> which only exists if b and c are coprime
06:33:24 <t7> and then what?
06:33:45 <ezyang> multiply
06:33:50 <danil> http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
06:34:27 <t7> yeah i wrote that bit
06:34:42 <t7> danil: where did you read this
06:34:47 <t7> i cant find it on wikipedia
06:35:05 <t7> i mean ezyang
06:36:09 <ezyang> Well, if you have the reciprocal, then "dividing" is just modular multiplication...
06:45:12 <akosch_> what if I have a list of functions with the type [(a -> Bool)] and want to combine them using (&&) to a single function (a -> Bool). I guess I'd need a version of `on` (from Data.Function) which uses two different functions on the same argument instead of one and then fold over the list. Is there a more elegant solution for this?
06:46:03 <Axman6> :t foldr (liftM2 (&&)) (const True)
06:46:05 <lambdabot> forall b. [b -> Bool] -> b -> Bool
06:47:10 <danil> :t \fs x -> all ($ x) fs
06:47:11 <lambdabot> forall a. [a -> Bool] -> a -> Bool
06:47:13 <akosch_> Axman6: thanks, exactly what I was looking for: I thought you can use lifting somehow
06:47:22 <parcs`> :t fmap and . sequence
06:47:23 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
06:47:45 <Axman6> :t fmap and
06:47:46 <lambdabot> forall (f :: * -> *). (Functor f) => f [Bool] -> f Bool
06:47:55 <Axman6> huh, I like that
06:48:40 <Axman6> though, what's the laziness like in all these cases. I think mine at least executes all predicates
06:48:54 <akosch_> ok, now I just have to figure out how these work :)
06:50:06 <applicative>  and <$> sequence preds is pretty good
06:50:28 <Axman6> yeah, I was looking for an applicative version, but too sleepy
06:51:23 <applicative> it's obvious, but parcs` idea of using sequence wouldn't have occurred to me
06:56:16 <dottedmag> What language extension the following syntax uses? (Monoid w, Monad m) => MonadWriter w m | m -> w where
06:56:37 <dottedmag> I haven't seen the | m -> w part in the tutorial.
06:56:47 <heatsink> functional dependences
06:56:48 <Athas> dottedmag: Functional Dependencies.
06:56:52 <dottedmag> Thanks
06:56:55 <danil> Functional dependencies.  It means the type m determines what w is.
06:56:56 <Athas> And multi-parameter typeclasses.
06:58:31 <akosch_> parcs`: I understand how (fmap and . sequence) works on monads (if I had [Maybe Bool] for example), but how should it work on a list of functions?
06:59:24 <parcs`> akosch_: functions form a monad
07:00:01 <akosch_> parcs`: sorry, this is new to me: how is that monad defined?
07:00:30 <danil> return = const, join f = \x -> f x x
07:00:39 <parcs`> instance Monad ((->) e) where return = const; m >>= f = \ e -> f (m e) e
07:02:04 <akosch_> this is really nice, but now I have to think about it :)
07:02:32 <parcs`> > (do { a <- (+1); b <- (*10); return (a + b) }) 5 -- akosch_
07:02:33 <lambdabot>   56
07:02:44 <danil> This is actually the Reader monad without the newtype
07:04:55 <akosch_> parcs`: thanks for the example, it looks immensely useful (although only if you have one parameter for each function).
07:07:33 <geekosaur> akosch_, you'd be surprised.  consider that every Haskell function actually has exactly one parameter
07:09:16 <akosch_> geekosaur: I know, but you loose the syntactical advantage with multiple parameters
07:09:44 <parcs`> you can always uncurry the function
07:09:48 <parcs`> :t uncurry
07:09:50 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:10:49 <geekosaur> my point was more I've used it in multiple parameter cases --- but it is rather restricted
07:11:10 <geekosaur> only a handful of cases where it works nicely, compared to the 1-parameter version
07:11:48 <akosch_> parcs`: hm, interesting
07:13:28 <akosch_> parcs`: btw, I tried your example of fmap and . sequence on  [(Integer -> Bool)] in ghci, but it says I don't have an instance declaration for (Functor ((->) Integer)) and an instance declaration for (Monad ((->) Integer))
07:13:42 <parcs`> akosch_: import Control.Applicative
07:16:07 <akosch_> parcs`: ok, I thought they were defined in the prelude. Strange how you can define these things with the language itself, feels a lot like lisp :)
07:18:02 <hpaste> zipbang pasted ‚Äú* vs (*) argument‚Äù at http://hpaste.org/72606
07:18:42 <zipbang> hey y'all, how come (zipWith *) has a different type from (zipWith (*))
07:18:49 <danil> zipbang: without the parentheses you're not passing it as an argument, you're making a section
07:18:56 <danil> :t (1 +) -- same idea
07:18:57 <lambdabot> forall t. (Num t) => t -> t
07:19:57 <zipbang> section?
07:20:47 <danil> it's how you partially apply infix functions
07:21:51 <danil> > ("hello" ++) . (++ "world") $ ", " -- you can do it on the left or the right
07:21:53 <lambdabot>   "hello, world"
07:22:51 <applicative> the idea of multiplying something by zipWith is difficult, but fine
07:26:24 <zipbang> danil: so i created a section which was zipwith on the left side of a multiply
07:27:25 <applicative> yeah so map (zipWith *) [2,3,4] multiplies the numbers by zipWith.  lambabots Num instances are so perverse it might work...
07:27:39 <applicative> @type map (zipWith *) [2,3,4]
07:27:40 <lambdabot> forall a b c. (Num [c]) => [(a -> b -> c) -> [a] -> [b] -> [c]]
07:28:07 <applicative> hm Num [c] isn't likely
07:28:22 <zipbang> i have trouble understanding that, to say the least
07:28:42 <zipbang> if i say (*) is that also considered a section?
07:28:53 <hpaste> ezyang pasted ‚ÄúGADT fun‚Äù at http://hpaste.org/72607
07:29:04 <applicative> zipbang: I think the way it works out you can think of it that way
07:29:11 <ezyang> ^-- is fromListL inhabited (is it possible to write that function?)
07:29:36 <danil> You could think of it as a degenerate section (which supplies no arguments), but it's really just a way to turn an infix operator into a regular name
07:29:46 <applicative> so when you apply (*) to 3 it takes the arg  and gives you (3*) and so on
07:30:23 <danil> > 10 `mod` 2 -- is the inverse; you can surround a regular name in backticks to get an infix operator
07:30:25 <lambdabot>   0
07:31:20 <zipbang> so, for functions with normal characters, i can pass them into a function without anything special ... for functions with special characters, i need to make a 'degenerate' section out of them (to turn them into a function)
07:31:33 <zipbang> err.. turn them into a normal function name
07:31:50 <applicative> but I was thinking the choice of (*) to make the operator prefix must have been associated with sections in the Haskell committees mind -- if it wasn't already in Miranda
07:35:39 <zipbang> applicative: danil: thanks to you both!
07:36:48 <applicative> > foldr max 0 [1..10]
07:36:49 <lambdabot>   10
07:36:53 <hpaste> ezyang annotated ‚ÄúGADT fun‚Äù with ‚ÄúGADT fun (annotation)‚Äù at http://hpaste.org/72607#a72608
07:36:55 <applicative> > foldr (+) 0 [1..10]
07:36:56 <lambdabot>   55
07:37:36 <ezyang> I wonder if I can get rid of that N i term
07:38:51 <timthelion> Is there a way to tell ghc to make an excecutable from a module that's not named "Main"?
07:39:26 <guidj0s> I'm attempting to model different random variable distributions by writing and instanciating a single Distribution typeclass. So, I have Binomial Distribution, Exponential Distribution, etc. Is there a way to deal with the fact that different distributions are parameterized differently?
07:39:49 <danil> timthelion: cabal files have a Main-is: property, but I'm not sure what option that passes on to ghc
07:40:33 <timthelion> danil: thanks
07:42:49 <danil> guidj0s: you could add a parameter or an associated type to the class for the type of the parameters
07:43:05 <applicative> timthelion: ghc --main-is foo Bar.hs
07:43:15 <applicative> Or something like that
07:43:19 <timthelion> applicative: thanks :)
07:43:40 <guidj0s> danil: They also vary in quantity.
07:44:46 <guidj0s> danil: For instance, the poisson distribution is only parameterized by a rate, while the binomial distribution takes both a probability and a number of bernoulli trials.
07:45:09 <danil> you'd have to bundle them in a tuple or record then
07:49:14 <guidj0s> I see. And what's your take on the signature for the probability mass function in Distribution? Do you consider the use case 'Binomial.pmf(n, p)' sane?
07:50:28 <ezyang> How can I construct a GADT with some of the type variables existentially quantified? This seems difficult....
07:50:45 <danil> guidj0s: what does a value of type Binomial or Exponential look like, anyway?
07:51:19 <ezyang> The Haskell wiki remarks that most parsing functions that create GADTs should be existential types, but then doesn't say how to actually do it...
07:51:33 <guidj0s> danil: I don't know, but I can ask it what the chance of it being 30 is.
07:52:26 <guidj0s> danil: The value must be a random variable, following the particular distribution.
07:53:12 <guidj0s> Then I can ask for the mean, variance, covariance, probability of it acquiring some exact value or a range of values.
07:55:37 <danil> guidj0s: you may want to put the parameters in when you construct one, then.  E.g. "data Normal = Normal { sigma, mu :: Double }".  Then the class can just be about getting properties of distributions and doesn't need to know what the parameters are.
07:57:08 <guidj0s> danil: Sounds a lot more sane. Thank you.
07:59:00 <danil> ezyang: I've seen it done CPS-style, something like withParsedThing :: (forall n. Thing n a -> b) -> [a] -> Maybe b.  No idea if that's any easier to write than returning an existential wrapper though.
08:00:31 <ezyang> danil: CPS is clever.
08:01:02 <ezyang> But my particular example has trouble even when you return existential wrappers
08:01:24 <ezyang> The big problem is you need the equality proof of the types on the left and right subtrees, and returning existentials destroys any hope for that.
08:05:23 <ezyang> Which is probably why I like the nested data-type encoding of perfect trees better :-)
08:13:38 <Y0Gi> I'm getting started with HUnit. is there a way to create multiple test cases from a map/assoc. list?
08:13:50 <Y0Gi> i.e. (expected, actual) pairs?
08:14:33 <guidj0s> join ##C
08:18:08 <jmcarthur> ezyang: maybe you could pass a reified depth as a singleton type up from the recursive calls to do an explicit comparison and obtain a proof that the depths are the same
08:19:13 <jmcarthur> ezyang: that is, the existential would scope over both a tree and a depth, not just a tree
08:21:16 <ezyang> Right, that seems pretty reasonable
08:23:53 <mekeor> how long does it roughly take to get an user account on hackage after having written ross@soi.city.ac.uk an e-mail?
08:25:34 <mekeor> i wished i'd get it immediately :/ :(
08:25:47 * mekeor wants to upload his first package on hackage ‚Äì oO
08:25:54 <donri> i think i got it within a day
08:26:38 * mekeor is looking forward. =)
08:27:24 <mekeor> cool, there's an upload-log: http://hackage.haskell.org/packages/archive/log (warning: big file!)
08:28:31 <hpaste> jmcarthur annotated ‚ÄúGADT fun‚Äù with ‚ÄúGADT fun (annotation) (annotation)‚Äù at http://hpaste.org/72607#a72610
08:28:44 <jmcarthur> ezyang: ^^
08:30:51 <fragamus> ugh I need to split a StdGen but I don't trust the math
08:32:23 <mjga_> hi, anybody knows how to statically link libffi with GHC?
08:32:38 <mjga_> so that binaries can be run on any LSB-based distro?
08:33:50 <geekosaur> mjga_, depends on the distribution, IIRC stock GHC ships a libffi it links statically but Debian and the like patch it out in favor of their shared library
08:33:56 <ezyang> jmcarthur: fancy!
08:34:14 <mjga_> so I need to look for Debian patches and reverse them?
08:34:26 <geekosaur> or install ghc from source, or something
08:34:50 * geekosaur should verify, it's possible debian convinced ghc hq to stop using its own static libffi
08:35:02 <geekosaur> they keep trying to do that since obviously their way is Better(tm)
08:36:39 <geekosaur> libffi is still part of the ghc repo, so yes
08:37:23 <fragamus> the thing is that I have to split again and again
08:38:47 <Y0Gi> ah, figured it out.
08:40:46 <gertc> Left _ -> liftIO $ print ""
08:40:55 <gertc> how do you do nothing at all?
08:41:05 <mjga_> geekosaur: thanks :-), I will try it
08:41:36 <mjga_> geekosaur: so sorry that it breaks idea of "semi-static" linking that is LSB conformant
08:42:09 <gertc> Left _ -> "what ever skip this"
08:42:10 <geekosaur> mjga_, Debian's position on LSB is that it's Red Hat forcing itself to be the only real Linux
08:42:19 <joeyh> gertc: return ()
08:42:25 <gertc> thx :)
08:42:39 <geekosaur> see for example that it specifies RPM as package manager
08:42:39 <joeyh> fwiw, I have noop = return ()
08:43:06 <mjga_> geekosaur: so no hope there for any non-fully-static binaries that would be portable?
08:43:41 <mjga_> geekosaur: then why does Debian have "lsb-*" packages in repo?
08:43:44 <geekosaur> again, if you build GHC from source --- or if there's a generic-Linux tarball of GHC and/or Haskell Platform --- that should do it
08:44:16 <geekosaur> mjga_, debian is minimally compliant with LSB but refuses to turn into a Red Hat clone
08:44:53 <geekosaur> they do various parts of LSB but still prefer e.g. their own init setup, apt over rpm, etc.
08:45:26 <geekosaur> and being as much of a closed ecosystem as possible so using shared objects from standard packages instead of statically linked compoents etc.
08:45:36 <mjga_> geekosaur: since it seems that only libffi would have to be linked statically to make it portable to SUSE and REDHAT, what's wrong with providing such an option?
08:45:52 <geekosaur> you could say they make an erffort to allow RH stuff to run on Debian but not Debian stuff to run on RH
08:46:17 <geekosaur> mjga_, I get the impression you think I have some say over Debian.  I don't; I'm just relatying the bad news
08:46:36 <geekosaur> (I used to beinvolved with FSSTND/FHS, bailed due to the politics.  of which this is a prime example)
08:46:54 <mjga_> geekosaur: just wondering where to submit the bug "ghc -static produces binaries that do not run on other platforms"
08:47:39 <geekosaur> if youre on debian, send it to them.  again (I thinkI;m saying this for the third time now?), if you download the generic-Linux GHC or HP it should produce the kind of binaries you want
08:49:29 <geekosaur> because stock GHC *does* link statically; it's the debian package that has been modified to use debian's shared libraries
08:50:13 <joeyh> seems to me you could use ghc -no-link, then look at ghc -v's output to get all the stuff it links in and substitute /usr/lib/i386-linux-gnu/libffi.a for -lffi, and link your own more static executable
08:50:33 <joeyh> (but then, what do I know, I've developed debian for 15 years)
08:51:56 <geekosaur> yes, just automating that so it will work on later ghcs can be ... iffy
08:51:59 <mekeor> hrmph, hrmph; may i ask for a moment of silence? i'd like to introduce a new‚Ä¶
08:52:09 <mekeor> world oder:
08:52:11 <hpaste> mekeor pasted ‚ÄúWho has most uploads on Hackage? ‚Äì Here's the full ranking!‚Äù at http://hpaste.org/72612
08:52:28 <mekeor> Isn't this just awesome? ‚Üë
08:52:58 <joeyh> ghc -v is machine parsable, but it seems to me it would be better to patch a --no-link-lib=ffi into ghc
08:53:03 <joeyh> (upstream)
08:53:16 <mekeor> (346,"DonaldStewart"),(346,"JeremyShaw"),(369,"BryanOSullivan"),(437,"HenningThielemann"),(1152,"EdwardKmett"),(1506,"MichaelSnoyman") have most uploads on hackage.
08:53:33 <edwardk> yeah but snoyman automates ;)
08:53:33 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
08:54:25 <srhb> edwardk: The cheat! :-)
08:54:26 <edwardk> nand`: around?
08:54:27 <mekeor> oh, okay.
08:56:29 <edwardk> @tell nand` .@ is because indexedtraversals don't form a category. amapped is because arrays aren't fully polymorphic. and you can always use traverse instead of mapped when you have a traversable. its the same relationship as between Traversable and Functor. mapped is using fmap traverse is using effectively fmapDefault (and the attendant bigger constraint)
08:56:30 <lambdabot> Consider it noted.
08:56:37 <mjga_> joeyh: wow, thanks for the hint! That should let me hopefully produce something that links only to ffi and pthreads
08:57:50 * hackagebot imm 0.4.0.0 - Retrieve RSS/Atom feeds and write one mail per new item in a maildir. (koral)
09:01:34 <applicative> edwardk: http://stackoverflow.com/questions/11808539/monoidal-parsing-what-is-it enquiring minds want to know, What was monoidal parsing?
09:02:31 <edwardk> its something i was doing a lot of a few years ago that is probably still doable, but didn't pay out enough performance wise to justify the mental inversions ;)
09:03:21 <edwardk> the short version is the 'visibly pushdown languages' (and some generalizations) can be recognized in a monoidal fashion
09:03:43 <edwardk> google for dan piponi's monoid for tabulating regular expressions
09:03:58 <edwardk> and he also has an article on recognizing the dyck language for balanced parentheses
09:04:09 <edwardk> both of these are simple versions of this
09:04:30 <edwardk> i can parse haskell-style layout using a generalized dyck language
09:16:17 <joeyh> mjga_: I think I share your pain -- I'd also like to make a nearly static binary (of git-annex)
09:16:48 <joeyh> I thought statically linking libc was pretty much impossible, though. I'm curious to see what you come up with
09:17:57 <geekosaur> it's possible but it actually *reduces* portability.  you really need to use dynamic libc
09:18:26 <joeyh> yeah, libc dlopens stuff. it may work for some select programs that don't use certian parts of libc
09:22:34 <gwern> @quote
09:22:34 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:27:10 <nand`> edwardk: about the @ thing, I meant are we going to see other operators for indexed traverals with @ in their names
09:27:10 <lambdabot> nand`: You have 1 new message. '/msg lambdabot @messages' to read it.
09:27:18 <edwardk> probably
09:27:34 <edwardk> for doing things with %~, etc.
09:27:39 <nand`> (also, if I'm in the channel but not responding just message me directly)
09:27:44 <nand`> (I get them when I sign in)
09:27:47 <edwardk> kk
09:29:56 <nand`> I'm also not sure how that answers my question about amapped; since you can always just use traverseArray instead of amapped, can't you?
09:30:09 <edwardk> amapped can be more efficient
09:30:13 <nand`> ah
09:30:17 <edwardk> amap is built in
09:30:27 <nand`> that makes sense, thanks
09:30:40 * nand` tends to forget about performance
09:32:14 <nand`> also what are your ideas on http://hpaste.org/72560 for syntax?
09:34:41 <donri> what's wrong with qluux <~ y $ quack <~ () $ New{}
09:35:09 <nand`> well, I was going for similarity to existing record syntax
09:37:21 <hpaste> nand` annotated ‚ÄúLens-based records‚Äù with ‚ÄúLens-based records (annotation)‚Äù at http://hpaste.org/72560#a72613
09:37:39 <nand`> or replace the $ by . for that matter
09:38:22 <nand`> oh, no, using . won't work
09:38:25 <frerich> I'm currently working on a tiny Haskell module for generating mazes. I'm using "runhaskell" to execute my test program (which prints mazes in ASCII). However, using ghc 7.4.1 on OS/X, I noticed that every few runs (say, every fourth run) the program doesn't print anything at all. Instead it seems to be doing something for a few moments and then it returns to the command line.
09:38:33 <nand`> because of precedence with the lens operators
09:38:37 <frerich> The code is at http://hpaste.org/72614 - can anybody explain or reproduce this?
09:39:13 <frerich> It  looks like a race condition to me, but I don't understand how the code could trigger this.
09:39:43 <otters> hpaste doesn't have a "raw" link :|
09:40:03 <donri> otters: sure, click expand
09:40:48 <frerich> I just run 'runhaskell main.hs' and every fourth run or so it just returns without printing anything.
09:41:34 <otters> frerich: for me, runhaskell doesn't print anything and if I load it in ghci and execute "main" it prints the same thing
09:41:35 <nand`> it's especially confusing because the only impure thing in your code is putStrLn
09:41:43 <nand`> frerich: does main = print () or so have the same effect?
09:41:45 <applicative> frerich: hm yes, it did nothing twice then printed a maze, then did nothing
09:41:50 <danil> nand`: if `with` is free you could do: New{} `with` (qluux <~ 7 |. quack <~ () |. frob <~ "new")
09:42:00 <frerich> applicative: Phew! At least I'm not seeing things...
09:42:01 <otters> I can't get it to print anything
09:42:04 <otters> also, it exits with status code 127
09:42:14 <nand`> danil: `where` heh, too bad it's a keyword
09:42:53 * hackagebot boolsimplifier 0.1 - Normal form representation for boolean expressions. Typically simplifies such expressions, but is not guaranteed to produce the absolute simplest form. (GershomBazerman)
09:43:29 <frerich> nand`: Actually, yes!
09:43:49 <frerich> Just a source file with a single line "main = print ()" triggers this for me, too.
09:44:26 <luite> frerich: what does echo $? do if it crashes?
09:44:53 <otters> frerich: heh, I can't get it to print anything
09:44:58 <applicative> frerich: are you on os x?
09:45:08 <frerich> luite: If it doesn't print anything, the error code is 11
09:45:14 <frerich> applicative: Yes
09:45:32 <applicative> do you get a segfault opening ghci sometimes?
09:46:01 <otters> I'm just getting exit code 127 over and over
09:46:18 <frerich> otters: FWIW my current test case for this issue is not the program I pasted but just 'main = print ()'
09:46:22 <frerich> It appears to cause the same symptom.
09:46:28 <nand`> edwardk: it goes against the trend, but I think .= could work well for ^~; ie. New{} `with` foo .= 3
09:46:34 <frerich> applicative: Just launching ghci, or also loading a program?
09:46:41 <applicative> either
09:46:47 <otters> Hmmmm
09:46:48 <nand`> I just wish ‚Äò|,‚Äô was a valid operator
09:46:59 <otters> But it works if I load it into ghci!
09:47:04 <luite> hmm it's stable here
09:47:21 <roconnor> nand`: I prefer defOld; seems safer.
09:47:24 <edwardk> .~ and .= ?
09:47:29 <edwardk> thats not bad
09:47:34 <applicative> frerich is it a 64bit ghc?
09:47:38 <edwardk> kill ^~ and ^=
09:47:44 <nand`> I was thinking .= for ^~ actually
09:47:45 <nand`> but you're right
09:47:45 <edwardk> sold
09:47:54 <edwardk> .~ is a lot easier to type
09:47:54 <nand`> .~ .= is better than ^~ ^=
09:47:58 <edwardk> and its a lot quieter
09:48:25 <applicative> the ^s are pretty hideous, but I assumed they came with the territory
09:48:26 <nand`> but it might be confusing that the . is in there
09:48:32 <luite> hm .= is already in use by aeson :p
09:48:33 <frerich> applicative: Interesting, maybe you're on to something: starting ghci caused http://hpaste.org/72615 for me, starting it again worked fine.
09:48:40 <frerich> I just launched it two times in a row...
09:48:42 <edwardk> oh well
09:48:43 <roconnor> applicative: they come from Pascal
09:48:46 <edwardk> i'm still taking it ;)
09:48:46 <nand`> ‚Äúfoo.bar .= bat‚Äù
09:48:50 <edwardk> foo.bar.= baz
09:48:54 <nand`> not too bad
09:48:55 <frerich> applicative: As for the architecture, let me check (I see that `which ghc` is a shell script)
09:49:01 <applicative> roconnor: ah
09:49:02 <donri> .~ is a lot harder to type on swe layout :P
09:49:10 <nand`> edwardk: haha, going with the OOP lookalikes it seems like = is a member function
09:49:24 <edwardk> yeah
09:49:42 <applicative> frerich: your error suggests 64 bit.  there's some bug about the haskell platform 64 bit ghc
09:50:04 <edwardk> that also frees up ^= for (^) =
09:50:07 <frerich> applicative: It seems I have a 64bit build, yes
09:50:09 <nand`> I wonder how far one could write a joke Haskell tutorial that only introduces lens syntax and do-notation and calls Haskell an OOP language
09:50:14 <edwardk> and **= and ^^= can come in
09:50:21 <frerich> applicative: Hum...
09:50:46 <donri> nand`: https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs
09:50:47 <luite> applicative: there was a bug that crashes ghci and runhaskell in situations where the linker needs to load zerofill segments from object files, causing a segfault. is there more? perhaps it's similar
09:50:50 <applicative> frerich: http://www.reddit.com/r/haskell/comments/wqn8a/ghci_is_segfaulting_on_startup_from_a_fresh/  If i build my own ghc-head locally, I dont have this problem, otherwise i do
09:50:52 <sm> nand`: sounds interesting
09:50:55 <nand`> donri: I've seen it, it's funny :)
09:51:10 <applicative> frerich: the same would apply to runhaskell.  with ghc itself i never have a problem
09:51:16 <danil> nand`: ruby actually works that way; object.field = foo is sugar for calling the "field=" method on object with foo as an argument
09:51:26 <nand`> donri: it showcases beautifully the whole concept of ‚ÄúHaskell lets you define your own language semantics‚Äù though
09:51:46 <frerich> applicative: Interesting, http://trac.haskell.org/haskell-platform/ticket/199 seems to cover this.
09:51:49 <applicative> frerich: apparantly the 32 platform doesnt have this problem.  I
09:51:58 <luite> frerich: you have an old xcode?
09:52:02 <frerich> applicative: I'll try a 32bit build
09:52:05 <edwardk> fmap = mapped.~ f
09:52:27 <nand`> heh
09:52:28 <edwardk> er fmap f = mapped.~ f
09:52:39 <nand`> that syntax looks so wrong :)
09:52:53 * hackagebot boolsimplifier 0.1.5 - Simplification tools for simple propositional formuals. (GershomBazerman)
09:52:55 * hackagebot boolsimplifier 0.1.6 - Simplification tools for simple propositional formulas. (GershomBazerman)
09:52:55 <frerich> luite: I have XCode 3.2.4 which is slightly outdated I believe (3.2.6 and 4.x are current, but the latter is not available on snow leopard)
09:53:12 <edwardk> debating about killing <~ since .~ is so quiet
09:53:51 <nand`> <~ does break <= after all
09:53:52 <donri> ._.
09:53:58 <edwardk> yeah
09:54:03 <edwardk> <~ dies
09:54:10 <edwardk> then we can use it later for lens assignment from monadic actions ;)
09:54:20 <nand`> yes, perfect
09:54:32 <luite> frerich: ah ok. even with newer xcode, 64 bit ghci and runhaskell are unstable with foreign libs
09:54:37 <donri> can't we use =: and ~:
09:54:44 <edwardk> (<~) :: MonadState a m => Setting m a b c d -> m d -> m ()
09:54:49 <luite> so running 32 bit is probably an ok workaround :)
09:55:03 <nand`> edwardk: love it
09:55:05 <edwardk> so instead of pattern matching you can use <~ for assignment from a monadic action
09:55:22 <donri> not sure if crazy or awesome
09:55:35 <roconnor> applicative: well, in the Pascal report, ‚Üë is used instead of ^
09:55:57 <roconnor> applicative: and apparently the Pascal report has Set types for some reason !?
09:56:28 * dottedmag even remembers working on the machine with ‚Üë character
09:56:33 <joeyh> c
09:56:41 <roconnor> dottedmag: :O
09:56:51 <edwardk> we lost a bunch if isomorphismish combinators when i added monadic setters and actions
09:56:59 <edwardk> they just because normal combinators
09:57:01 <edwardk> but its worth it
09:57:18 <applicative> luite, its strange though, I just added to the trak that if I build my own ghc-head or whatever locally, I dont have the problem
09:57:24 <nand`> edwardk: another advantage is that ^ is now only used for reading out lenses
09:57:25 <edwardk> its kinda nice that you can make monadic lenses that read from other parts of the state to determine what they are setting
09:57:29 <edwardk> yep
09:57:32 <nand`> well, except for the proposed (^)
09:57:33 <edwardk> i love the consistency of that
09:57:34 <dottedmag> roconnor: It was Soviet home computer. It even had ¬§ instead of $
09:57:45 <roconnor> dottedmag: well that is normal
09:58:37 <edwardk> bitAt 0 .~ True $ 0   follows the usual . before $ pattern too
09:58:50 <nand`> edwardk: maybe ^. could be renamed to .^ to fit
09:58:57 <nand`> foo.^ for reading, foo.~ for setting
09:58:57 <edwardk> don't like it
09:58:59 <nand`> foo.% for modifying
09:59:00 <luite> applicative: hm interesting. you also have an older xcode?
09:59:27 <edwardk> hrmm
09:59:35 <nand`> oh, that would break %= though
09:59:44 <edwardk> yep
09:59:46 <nand`> yeah, %~ and ^. are probably best left untouched
09:59:55 <nand`> especially since ^. is going to be at the end of an expression most likely
10:00:08 <edwardk> yep
10:00:15 <nand`> err, nonsense
10:00:24 <edwardk> foo^.bar.baz.quux  the ^ is a good indication that the thing on the left is what all this is being applied to
10:00:31 <nand`> what I meant to say is that yeah
10:00:33 <nand`> that
10:00:34 <edwardk> foo^!act.bar.baz.quux also fits the pattern
10:00:36 <mgsloan>  /me needs to make pointless plumber variants for the new lenses ;)
10:00:38 * roconnor thinks that <~ is pretty sweet
10:00:48 <nand`> ^! strict?
10:00:58 <edwardk> no
10:01:03 <edwardk> ^! can run actions
10:01:04 <donri> I like how ^. reads with .
10:01:06 <nand`> oh
10:01:11 <danil> sounds like someone should make a google doc with a grid of the various attributes and example code that interpolates operators from the cells
10:01:26 <edwardk> (^!) :: a -> Getting m c a b c d -> m c
10:01:44 <nand`> (m c)?
10:01:50 <edwardk> so given an Action m a b which is basically a -> m b   you can run an action
10:01:58 <danil> roconnor: I liked how <~ looked until I tried to type it, but then I realized my hands don't know which shift key to use
10:02:00 <edwardk> but you can compose actions with getters, etc.
10:02:03 <donri> lol Getting m c a b c d ^_^
10:02:04 <Taneb> Oh dear, I'm still trying to figure this thing out
10:02:17 <Taneb> edwardk, what's it like being a celebrity in the Haskell community?
10:02:21 <edwardk> donri: thats far from the worst combinator
10:02:26 <nand`> I do like how <~ looks but I like the ~/= consistency more
10:02:31 <nand`> @quote mappend
10:02:32 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
10:02:36 <edwardk> more or less like being a celebrity in other communities ;)
10:02:42 <edwardk> well
10:02:53 <edwardk> i'm just going to repurpose <~ for a nicer use
10:02:56 <Taneb> Do you get people asking you to marry them on Facebook?
10:03:08 <edwardk> my wife might get upset if i did
10:03:17 <donri> who's got edward fever
10:04:35 <donri> edwardk: so you're adding a parameter to Getting?
10:04:37 <nand`> Fold a c = forall m. Monoid m => Getting m a a c c -- ?
10:04:58 <edwardk> nand`: well getting picked up a monad as the first parameter
10:05:23 <edwardk> then Getter a c = forall m r b d. Monad m => Getting m r a b c d
10:05:25 <nand`> oh, it would be forall m b d. either way
10:05:52 <edwardk> since the getter doesn't know _which_ monad its given it can only just pass the answer through
10:06:08 <edwardk> it also gives me an _insidious_ way to make partial lenses that i don't think i'll use
10:06:11 <ReinH> nand`: why yes, that thing that doesn't exist sounds great for my use case :)
10:06:11 <edwardk> ;)
10:06:13 <edwardk> fail ;)
10:06:21 <nand`> edwardk: :)
10:06:27 <ReinH> edwardk: hi!
10:06:35 <ReinH> edwardk: I think I'm starting to grok lenses
10:06:36 <nand`> ReinH: :( it should exist soon
10:06:44 <nand`> edwardk:  ^ talking about an indexed traversal for Data.Array
10:06:44 <ReinH> a bit. maybe.
10:06:46 <edwardk> ReinH: gratz =)
10:06:49 <ReinH> :D
10:07:03 <edwardk> oh yeah i need to build the indexed traversals still
10:07:09 <ReinH> So if I have a nested array (2d array), can I compose ix somehow to get a lense into it?
10:07:34 <edwardk> is it an array of array or an array with a compount index?
10:07:42 <ReinH> array of array
10:07:50 <edwardk> ix 2.ix 3
10:07:58 <edwardk> foo^.ix 2.ix 3
10:08:11 <edwardk> ix 2.ix 3 .~ "hello" $ ...
10:08:12 <ReinH> right
10:08:31 <ReinH> and if I want a lense that takes a tuple of indexes?
10:08:33 <nand`> right, but that's not an indexed traversl :P
10:08:37 <nand`> traversal*
10:08:54 <edwardk> @pl \a b -> ix a . ix b
10:08:55 <lambdabot> (. ix) . (.) . ix
10:09:22 <edwardk> nand`: i just need to write the indexed traversal for arrays
10:09:25 <ReinH> ah my old friend . (.) .
10:09:51 <edwardk> @pl \ a -> ix (fst a) . ix (snd a)
10:09:52 <lambdabot> ap ((.) . ix . fst) (ix . snd)
10:09:53 <nand`> right, thus ‚Äúit should exist soon‚Äù
10:09:56 <edwardk> yeah
10:10:04 <edwardk> you can write it for now and i'll add it or take a patch
10:10:16 <ReinH> edwardk: so I just write the function that composes them and I end up with a lense I can use
10:10:21 <ReinH> because, of course, lenses are composable
10:10:22 <edwardk> yep
10:10:24 <ReinH> gratz
10:10:27 <whittle> I‚Äôm trying to contribute to a library with an HSpec test suite, but I think I‚Äôm missing a step. I added a test for the function `searchObjects`, then I added the function `searchObjects` to the library, then I added an export for `searchObjects` to the module it‚Äôs in and the top-level module that exports that module, but when I `runghc tests/runtests.hs` from the command line, I still get "Not in scope: searchObjects
10:10:27 <whittle> ".
10:10:45 <edwardk> ReinH: i have a lot of flag lenses that look like
10:10:48 <ReinH> edwardk: lenses are awesome
10:10:53 <edwardk> foo = myFlags.contains Foo
10:10:58 <edwardk> bar = myFlags.contains Bar
10:11:00 <whittle> Is there something I need to clear between test runs? Should I be compiling each time?
10:11:02 <nand`> (why did you comment out traverseList btw? Anything wrong with it or just because you haven't prepped other indexed lenses yet?
10:11:11 <edwardk> the latter
10:11:14 <edwardk> it belongs elsewhere
10:11:30 <edwardk> and i'm thinking about making an MPTC for traversableWithIndex
10:12:11 <edwardk> that way Map, etc. can all use the same combinator for the default indexed traversal
10:15:23 <donri> edwardk: "Lenses are a great way to deal with functional references, but there are two common issues that arise from their use." then you proceed to list three issues. :)
10:15:36 <edwardk> hahahaha
10:15:43 <edwardk> where is that blurb?
10:15:48 <donri> mirrored lenses
10:16:04 <edwardk> ah
10:16:24 <nand`> donri: perhaps one issue is not common? :)
10:16:31 <donri> :)
10:16:46 <edwardk> noted to fix ;)
10:21:16 <nand`> hmm, it took me a while to realise that traverseAt only type checks if v in Map k v is a monoid
10:22:53 <nand`> sorry, I meant reading it out
10:23:52 <edwardk> well, if you use it directly
10:24:26 <edwardk> ^.traverseAt isn't the usual usage pattern
10:24:59 <nand`> foo ^. traverseAt i . to Just   <- works like foo ^. at i, very cool
10:25:38 <MHD> :t (^.)
10:25:39 <lambdabot> Not in scope: `^.'
10:26:00 <MostAwesomeDude> We gotta teach lambdabot the magic of lenses.
10:26:20 <nand`> I just noticed that lenses provide a funny way of composing functions in the ‚Äòreverse order‚Äô
10:26:32 <nand`> foo . bar . bat $ x  =  x^. to bat . to bar . to foo
10:26:50 <edwardk> yep
10:26:53 <edwardk> and you can flip some backwards
10:27:02 <MHD> should I look into lenses?
10:27:03 <edwardk> foo . bar . bat = x^.to (bar . bat) . too foo
10:27:05 <frerich> After watching the excitement over lenses for some time, I wonder - what is it that lenses can't do? Teach my children the piano?
10:27:29 <nand`> frerich: there's a traversable lens into their brains
10:27:44 <edwardk> and yeah thats one of the to laws
10:27:53 <edwardk> (its a free theorem)
10:27:54 * hackagebot her-lexer 0.1 - A lexer for Haskell source code. (TimothyHobbs)
10:28:00 <MHD> what paper is lenses built on?
10:28:13 <edwardk> frerich: you can make a subtype of PianoLenses that does that
10:28:18 <edwardk> i just haven't added it to the main package yet
10:28:29 <edwardk> MHD: comonad.com the mirrored lenses post
10:28:42 <nand`> and van laarhoven lenses in general
10:28:43 <edwardk> i'll be writing up a more significant paper on the topic soon
10:28:49 <nand`> there might be some papers on those
10:28:54 <edwardk> there isn't
10:28:56 <MHD> edwardk: are they crazy-awesomely mathy like, say, arrows?
10:28:57 <edwardk> that was a post
10:29:00 <nand`> k
10:29:03 <edwardk> MHD:
10:29:21 <edwardk> type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b  -- with a few laws
10:29:42 <donri> edwardk: yes please :) i suspect there are tons of patterns i could use in my code, which is still written basically as with data-lens
10:29:44 <edwardk> you can use it like it was: a -> (c, d -> b)
10:30:37 <edwardk> MHD: if you read the haddocks on the 'lens' package they give a decent overview of what the types mean, and show a ton of combinators
10:30:43 <MHD> ok
10:31:00 <mjga_> geekosaurus: I managed to compile my code with ghc --static -optl-static, but it still links to libc :-(
10:31:16 <MHD> So, now we have what... Monads, Arrows and Leses in the awesome-combinator package
10:31:18 <edwardk> the top level haddock for the package goes through getters, setters, folds and traversals by analogy to functions, functors, foldables and traversals
10:31:31 <nand`> I think it's a bit unfortunate that the comments at the top of http://hackage.haskell.org/package/lens-1.4.1 come before the ‚ÄòProperties‚Äô section
10:31:47 <edwardk> mhd: basically with lenses the api i use to talk to 'text' is dumbed down to 2 combinators and a bunch of stuff that works with everything
10:32:04 <edwardk> its a bit longwinded i admit
10:32:04 <MHD> cool
10:32:08 <MHD> can they parse?
10:32:12 <edwardk> not yet ;)
10:32:30 <mjga_> geekosaur: I managed to compile my code with ghc --static -optl-static, but it still links to libc and checks version :-(. It seems very hard to produce portable Linux binaries with GHC. Now I get the following error: version `GLIBC_2.15' not found
10:32:33 <MHD> I will write a lense parser when I am done with my MegaParsec arrow parser
10:32:46 <edwardk> megaparsec?
10:32:57 <MHD> It's an unreleased thing still a WIP
10:33:01 <edwardk> kk
10:33:24 <MHD> it's based loosely on parsec's continuation structure and Swierstra & Duponcheel's paper
10:33:39 <edwardk> ok, i've done that one before =)
10:33:41 <clsmith> hey all. do you think it would it be relatively easy to circumvent GHC's [Core -> STG -> C--] part of the pipeline to use something other than STG?
10:34:02 <edwardk> i was looking to include that as a parser in trifecta
10:34:02 <monochrom> glibc's nsswitch part relies on dynamic linking. reads /etc/nsswitch.conf at runtime before deciding which code to load for getuid etc
10:34:07 <edwardk> but the performance didn't pan out
10:34:18 <donri> weren't arrows meant to improve performance originally
10:34:32 <MHD> clsmith: no, STG is the magic part
10:34:34 <edwardk> arrows were motivated by an example that is better implemented as an applicative ;)
10:34:40 <edwardk> that should tell you something ;)
10:34:46 <donri> =)
10:34:55 <monochrom> essentially, if glibc and you can't nail the version, give up static linking
10:34:58 <clsmith> MHD: well, by 'easy' i mean more the replacement of it than actually writing that replacement
10:35:02 <edwardk> maybe 5% of arrows should actually be arrows
10:35:11 <MHD> edwardk: it is also an applicative, of course
10:35:19 <edwardk> mhd: sure
10:35:37 <edwardk> MHD: you may want to look at my 'parsers' package to get most of the combinators for your parser type for free
10:35:44 <donri> i read something to the effect of that arrows were meant to allow for broader static analysis and therefore optimization
10:35:54 <edwardk> yes
10:36:03 <donri> does applicative allow the same?
10:36:06 <luite> clsmith: uh it's possible but it would require a lot of rewriting :)
10:36:07 <edwardk> yes
10:36:11 <donri> ah, cool
10:36:18 <Peaker> edwardk, does the lens library have TH to auto-generate record field lenses?
10:36:24 <clsmith> basically i'm going to be writing a compiler and i was hoping to commandeer GHC's pipeline so i only need to write the [Core -> C--] bit
10:36:27 <edwardk> Peaker: yep. Control.Lens.TH
10:36:35 <edwardk> Peaker: you can makeLenses makeIso, etc.
10:37:01 <luite> clsmith: thats more or less the whole code generator...
10:37:05 <Peaker> edwardk, great, will try that out, thanks :)
10:37:13 <donri> i want an applicative(/category?) xml parser
10:37:35 <MHD> edwardk: Is there some easy way to solve the problem you get with having a class TokenSet z t | z -> t, and a class TokenStream s t | s -> t, and then having the typechecker barf when you try to make a generic anyToken?
10:37:36 <edwardk> i'm also looking to give you nice splices for $(compound [''_foo, ''_bar, ''_baz])  so you can do multifield lenses for type changing assignment
10:37:39 <luite> clsmith: what can you do with core that you can't with stg?
10:37:44 <clsmith> luite: pretty much, but it would mean i'd be stealing GHC's optimisations, etc. i'm aware it'd still be a lot of work, though.
10:38:48 <edwardk> MHD: i need a longer example
10:38:49 <clsmith> luite: basically i'm going to be experimenting with a new way of compiling functional languages, for a phd.
10:38:52 <ReinH> edwardk: what does this makeLenses generate? https://github.com/ekmett/lens/blob/master/examples/Test.hs#L8
10:38:53 <edwardk> or rather more context
10:39:11 <Saizan> clsmith: LHC takes Core from GHC, but it doesn't try to feed C-- back to it
10:39:13 <edwardk> it makes no lenses ;)
10:39:16 <ReinH> :)
10:39:27 <edwardk> if you use makeIso there it makes an iso named 'foo'
10:39:29 <clsmith> Saizan: the large hadron collider?
10:39:51 <ReinH> edwardk: which seems rather unnecessary, but there it is ;)
10:40:14 <luite> clsmith: ah... perhaps it's simpler to generate llvm bitcode instead of cmm
10:40:15 <Saizan> clsmith: Lemmih's Haskell Compiler, not sure if it's been active very recently, but it was a thing ~1 year ago
10:40:33 <Saizan> yeah, LHC produces llvm
10:40:37 <edwardk> ReinH: the iso is handy because you can turn it around
10:40:40 <luite> clsmith: but core is still not too far from stg
10:40:41 <edwardk> from foo. foo
10:40:50 <ReinH> ah
10:41:00 <clsmith> hmm, llvm might be easier, i don't know it very well
10:41:01 <geekosaur> mjga_, I see you missed my comment that linking glibc statically *decreases* portability
10:41:26 <geekosaur> the resulting binary will only run properly on a system with exactly the same glibc version that was used to link it
10:41:33 <Peaker> edwardk, what names do field lenses get?
10:41:34 <luite> clsmith: or write javascript :p
10:41:45 <geekosaur> i.e. leave glibc dynamic if you actually want portabilitt
10:41:46 <MHD> edwardk: It's an ll1 Swierstra & Duponcheel parser which uses parsec style continuations is generic over both lead token set and token supply stream. The token set class has a member 'full' which is all possible tokens. When I try to make a polymorphic anyToken combinator which has it's lead set be 'full' and just calls the success continuation with the next token, the typechecker barfs.
10:41:48 <clsmith> luite: D:
10:41:56 <Saizan> it'd be cool to use a memory layout matching what's expected from GHC's RTS, so you don't have to write a GC etc
10:42:01 <luite> clsmith: hey that's what i'm doing :p
10:42:04 <timthelion> geekosaur: that's some messed up "claiming to be static, but not actually being static" linking then eh :D
10:42:10 <luite> clsmith: from stg though, not core
10:42:16 <nand`> Peaker: if the field is _foo the lens is named foo
10:42:38 <Peaker> oh, same as the other lens libs
10:42:40 <Clint> geekosaur: not _exactly_
10:42:41 <edwardk> Peaker: by default they strip the _ and lowercase it, but you can configure it
10:42:56 * hackagebot matchers 0.2.0.0 - Text matchers (OmariNorman)
10:43:06 <luite> clsmith: what's the new way that you're going to explore?
10:43:09 <edwardk> Peaker: also makeClassy will make a class for the data type, and prepend that lens on the lenses it builds
10:43:41 <Peaker> edwardk, btw: Your TH relies on imports of Control.Lens.Lens -- maybe the TH should do its own dependent imports?
10:43:53 <clsmith> luite: it involves modelling the program as an interaction net
10:44:16 <geekosaur> Clint, if you want to be hyperpedantic it has to have the exact same linkage for NSS and possibly some other plugins.  glibc docs only guarantee same exact version, because the absolute ultrapedantic truth is (a) difficult (b) not served by enough documentation to determine unless you work with glibc source
10:44:25 <edwardk> data Foo = Foo { _fooInt :: Int, _fooBar :: Double }; makeClassy ''Foo --will make class HasFoo t where foo :: Simple Lens t Foo; fooYear :: HasFoo t => Simple Lens t Int , etc.
10:44:31 <edwardk> er fooInt ::
10:44:41 <edwardk> Peaker: does TH let me do that?!
10:44:43 <geekosaur> you're welcome to play that level of pedanticism but given the glibc devs *don't* it's not worth it for anyone who isn;t a glibc dev
10:44:52 <Peaker> edwardk, I'm pretty sure it does, I can try to find an example
10:44:57 <edwardk> great!
10:45:02 <Clint> geekosaur: in practice the nss abi doesn't change with hypergranularity
10:45:07 <clsmith> luite: for extra clever term/context sharing, basically. :p but i won't say much because i've not done much yet, and all i'll do is spread lies and misinformation :)
10:45:14 <Clint> but fine
10:45:22 <geekosaur> Clint, no, but its changes are not documented in a useful way
10:45:36 <geekosaur> if they were it might be worth keying off them.
10:46:16 <Clint> in conclusion, statically-link your binaries with ¬µc or diet
10:46:41 <luite> clsmith: hehe, are interaction nets trees or directed graphs?
10:47:06 <clsmith> luite: technically they're undirected graphs, but for all intents and purposes they're dags
10:47:17 <clsmith> luite: uh, not dags, sorry.
10:47:24 <clsmith> luite: directed *cyclic* graphs
10:47:30 <luite> hmm, ok
10:47:33 <nand`> edwardk: have you given my ‚Äòset-from-other‚Äô operators a thought?
10:47:56 * hackagebot penny-lib 0.2.0.0 - Extensible double-entry accounting system - library (OmariNorman)
10:48:16 <luite> clsmith: is hoopl suitable for that kind of thing?
10:48:17 <Clint> hmm
10:48:21 <srhb> What exactly does ByteString.Char8.drop drop? Bits? Bytes?
10:48:33 <applicative> char8s
10:48:34 <luite> bytes
10:48:49 <timthelion> I've written a precompiler for haskell, that lets you write imperative code in order of "dependency resolution" rather than the typical top down approach.  What should I name such a package ;)?
10:48:57 <clsmith> luite: i'm actually reading about hoopl right now to find out ;p
10:49:19 <luite> clsmith: all the hoopl magic in ghc happens after stg
10:49:21 <ReinH> edwardk:
10:49:24 <ReinH> er
10:49:42 <ReinH> edwardk: I'm planning on abstracting piece access in my chess engine behind a lens so I can change representations easily
10:49:43 <timthelion> Each command has a set of dependencies(other commands that have to be run before it.)  and the precompiler puts things in the right order to be run.
10:49:45 <luite> though haven't checked the new code generator yet
10:49:46 <edwardk> nand`: well, it may come for free with <~ being the new thing
10:49:49 <edwardk> foo <~ use bar
10:50:06 <clsmith> luite: is it [STG -> C--], or is it just a part of the general C-- stuff?
10:50:23 <ReinH> justneed to change the lens
10:50:25 <MostAwesomeDude> Hm. This whole Pipes to Conduits series is fascinating. Is this normally how people build things, by composing functors and the free monad?
10:50:31 <applicative> ReinH , dont tell me lenses solve  the expression problem too...
10:50:35 <luite> clsmith: i think it's both in the new codegen, and mostly Cmm or something that's close to Cmm in the old
10:50:44 <ReinH> applicative: no but they may be useful for move generation
10:51:10 <danil> clsmith: Cmm and the native codegen both use hoopl to represent graphs of blocks of some kind of instruction
10:51:13 <ReinH> applicative: wait, what do you mean by expression problem?
10:52:20 <applicative> oh http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt and anything you'd see googling 'expression problem'
10:53:06 <applicative> in functional languages, you write new functions as you please, but everything is trashed if you change a type; in oo languages the reverse ... very crudely
10:53:29 <danil> MostAwesomeDude: it's getting more popular, but I wouldn't say it's the norm yet (at least not the extreme approach in that series)
10:54:07 <timthelion> applicative: if you don't give a damn about preformance, then the types can be changed at will, all you need is a converter :)
10:54:12 <ReinH> applicative: for most things the board type can be abstracted away
10:54:38 <iamtakingiteasy> @src foldr
10:54:39 <lambdabot> foldr f z []     = z
10:54:39 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:54:57 <ReinH> if I have getPiece :: Board -> Coord -> Maybe Piece and I change the type of board
10:55:05 <ReinH> assuming I change my lense, I don't have to change getPiece
10:55:09 <ReinH> *lens
10:55:11 <MostAwesomeDude> danil: 'k. I'm just puzzling over a classic problem that is not really obviously solved by conduits.
10:55:29 <nand`> edwardk: I meant for eg. ‚Äòlens .~ other^.lens‚Äô
10:55:32 <MostAwesomeDude> Conduits don't appear to let me write things that can generate output in response to a combination of input and timers.
10:55:49 <merijn> MostAwesomeDude: Sounds like FRP to me
10:55:59 <edwardk> sure. just not sure i'm sold on that one
10:56:24 <ReinH> applicative: like anywhere else, changing the board type just means changing the board interface to support the new structure
10:56:25 <edwardk> the fairbairn threshold kinda steers me away from it
10:56:45 <ReinH> and if a large part of that interface is a lens into pieces or rows or diagonals or w/e, I'm hoping to minimize the amount of change
10:57:01 <ReinH> it doesn't have to bubble up into everything
10:57:37 <ReinH> I am curious how performant this approach will be, but we shall see
10:58:26 <qnikst> how to convert Double to CDouble?
10:59:15 <Axman6> realToFrac possibly?
10:59:27 <Axman6> @hoogle CDouble
10:59:27 <lambdabot> Foreign.C.Types data CDouble
10:59:48 <qnikst> thanks, it works (at least compiles)
11:00:54 <hpaste> nand` annotated ‚ÄúFunctional pong with lenses and gloss‚Äù with ‚ÄúFunctional pong with lenses and gloss (improvements throughout)‚Äù at http://hpaste.org/72509#a72618
11:01:59 <nand`> ^- finally got rid of the code duplication in ‚ÄòcheckBounds‚Äô
11:02:04 <nand`> well, some of it
11:02:16 <MostAwesomeDude> merijn: I was not under the impression that FRP in Haskell was suitable for networking.
11:03:02 <ReinH> nand`: (improvements sparsely throughout)
11:03:02 <ReinH> ;)
11:03:09 <nand`> :)
11:03:10 <c_wraith> MostAwesomeDude: that's kind of exactly what the netwire library was built for
11:03:19 <Peaker> edwardk, now that I looked up how I did the imports in TH, I think I just used quasi-quoting to get the names I needed, which required an import in the TH module itself, and then iirc removed the need to import it in the TH call-site
11:03:35 <edwardk> aha!
11:03:37 <Peaker> I'm trying to do that in Control.Lens.TH now to see if that works
11:03:39 <nand`> the CPU player no longer ‚Äògoes crazy‚Äô bouncing back and forth when it reaches the optimal position either
11:03:42 <edwardk> i would love that
11:03:51 <applicative> nand`: you keep re-defining `at` and assigning fixity
11:04:19 <nand`> applicative: why do you mention this?
11:04:44 <applicative> wait, sorry,  I am looking at several pastes simultaneously as if they were one !
11:04:57 <nand`> ah
11:05:52 <Peaker> edwardk, where's TypeQ from?
11:05:52 <merijn> MostAwesomeDude: Ah, networking...don't must of the networking functions support timeouts?
11:05:53 <t7> ghc on arm uses llvm?
11:06:03 * applicative now has the text in his editor
11:06:05 <edwardk> Language.Haskell.TH
11:06:06 <Peaker> oh, I see
11:06:08 <edwardk> Q Type
11:06:22 <merijn> MostAwesomeDude: Alternatively, set up a separate timer thread that essentially does nothing but "block until time t, then do something, repeat"?
11:06:37 <edwardk> i originally wrote it using the constructors, then switched to the method style
11:06:49 <edwardk> easier to be consistent
11:06:59 <Peaker> edwardk, why aren't apps/appsT just a foldl?
11:07:11 <ReinH> nand`: perhaps factor out moveUp and moveDown out of `paddleSpeed * time` and `-moveup`?
11:07:13 <MostAwesomeDude> merijn: I need something more robust. I need to be able to set many timers and have things happen based on those timers.
11:07:24 <edwardk> yes
11:07:51 <ReinH> and throw clamping in?
11:07:53 <nand`> ReinH: that could work
11:08:35 <srhb> Hmm. Perhaps someone knows a good channel for asking this question: How does one break a four-byte challenge/response if you have a handful of valid challenge/response pairs? What are the algorithms needed for the problem?
11:08:43 <edwardk> switched
11:09:32 <jdnavarro> anyone knows how to trick ghc-mod into not complaining about an import
11:09:52 <donri> complain?
11:10:25 <jdnavarro> donri: I'm using `path_mypackage` to obtain the package version
11:10:40 <applicative> nand`: nice
11:10:53 <donri> jdnavarro: but...?
11:11:19 <applicative> if we knew this was the lens library to end all lens libraries, it would be awesome to get a suitable supply of combinators in lambdabot
11:11:44 <donri> or a lensbot
11:11:56 <applicative> hm lensbot
11:11:59 <carter> hello other hackphiers
11:14:48 <nand`> edwardk: ‚Äòview‚Äô has ‚Äòuse‚Äô, but ‚Äòadjust‚Äô doesn't have a State-monadic counterpart that isn't an operator
11:14:55 <edwardk> true
11:15:12 <edwardk> but there is less pressure on it
11:15:16 <edwardk> i need the named use
11:15:25 <edwardk> because its a single argument function
11:15:41 <edwardk> and we want adjust because %~ is ternary
11:15:44 <nand`> edwardk: I want to write something along the lines of ask >>= f . (%=) lens
11:15:46 <edwardk> and so its not always good
11:15:50 <nand`> err, (%=) lens . f
11:16:10 <timthelion> Is there some standard gitignore file for haskell projects, that would ignore dist/ *.o *.hi ect?
11:16:33 <edwardk> i'll add it to my 'list of operators that need a good name' ;)
11:16:47 <edwardk> change?
11:16:48 <Eduard_Munteanu> timthelion: try snatching it from GHC maybe?
11:16:54 <ReinH> edwardk: at least you're only solving one of the two hardest problems in CS
11:16:58 <timthelion> edwardk: doesn't that include pretty much all of your opperators ;)
11:17:04 <ReinH> edwardk: wait, do you have any off by one errors?
11:17:20 <edwardk> timthelion: i welcome suggestions for improvements
11:17:21 <timthelion> Eduard_Munteanu: that's what I'll do next, I wondered if there isn't one distributed somewhere.
11:17:47 <timthelion> edwardk: as soon as I understand your library, I'll begin submitting them :D
11:18:03 <edwardk> change, tweak, modifying, etc.
11:18:06 <ReinH> timthelion: waiting is
11:18:16 <timthelion> ReinH: ?
11:18:33 <ReinH> timthelion: stranger ina strange land quote
11:19:08 <ReinH> one day you will grok in fullness
11:19:08 <ReinH> etc
11:19:20 <timthelion> oh, haven't read that since middle school ;)
11:19:36 <ReinH> good choice
11:19:44 <ReinH> (reading it in middle school)
11:19:56 <timthelion> I won't read it again.  The end ruined it for me.
11:20:15 <JerMenKoO> how to turn a float into integer? (I am aware I will lose the decimals, I just want to know)
11:20:21 <JerMenKoO> same goes how to turn a integer into a string
11:20:31 <edwardk> > show 1234
11:20:33 <lambdabot>   "1234"
11:20:37 <edwardk> :t ceiling
11:20:39 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:20:45 <edwardk> > ceiling 1.4
11:20:46 <lambdabot>   2
11:20:49 <edwardk> :t floor
11:20:50 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:20:52 <edwardk> :t round
11:20:53 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:21:06 <timthelion> > (read::Int (show 1.3))
11:21:07 <lambdabot>   <no location info>: parse error on input `1.3'
11:21:16 <JerMenKoO> thank you very much!
11:22:44 * merijn is unreasonably annoyed that round implements banker's rounding
11:23:59 * timthelion prefers rounding where 0.5 is randomly rounded up or down.
11:24:39 <edwardk> great for functional languages ;)
11:26:17 <timthelion> edwardk: is it really so hard to pass a seed around?
11:27:30 <c_wraith> merijn: isn't that the algorithm for round specified by IEEE754?
11:27:43 <edwardk> yes
11:27:52 <c_wraith> merijn: it would be bad for Float/Double to not follow IEEE754 semantics
11:28:01 <monochrom> Knuth proves the superiority of rounding to even. it is not just bankers
11:28:14 <c_wraith> I'm told bankers don't even use it
11:28:30 <monochrom> bankers probably don't know what is used
11:28:44 <c_wraith> well, that's certainly true
11:28:51 <c_wraith> I suppose I meant "financial software" :)
11:29:06 <merijn> c_wraith: Sure, but who says Prelude.round needs to follow the IEEE754 for all fractionals?
11:29:21 <merijn> More annoying is that there appears to be no "normal" round in the Prelude
11:29:25 <c_wraith> apparently knuth does
11:29:49 <c_wraith> then add .5 and floor
11:34:43 <yrlnry> Where's the hac phi channel?
11:35:06 <fryguybob> yrlnry: #haskell-hacphi
11:35:16 <yrlnry> Thanks.
11:35:29 <yrlnry> I should have looked on the web site first, sorry.
11:35:41 <toki78> Hi guy, I can factorize a 40 bit integer in 8 minutes
11:35:47 <toki78> guys
11:35:55 <MostAwesomeDude> toki78: Cool story.
11:35:58 <toki78> is that good ?
11:37:00 <yrlnry> toki78:  is that average time, or what?
11:37:15 <toki78> it is about the maximum
11:37:30 <toki78> i treid 2 numbers
11:37:44 <Enigmagic> sounds like a good sample size ;-)
11:38:07 <shachaf> That's over twice as many numbers as 1 number!
11:38:08 <shachaf> (Almost.)
11:38:15 <nand`> ReinH: I'm factoring out the ‚Äò* time‚Äô stuff, and I'm looking for a good operator for the ‚Äòtime-based add/subtract‚Äô, right now I have eg. ballPos +=? mul ballSpeed
11:38:27 <nand`> but I don't really like the way that looks
11:39:11 <toki78> is there a channel for computational complexity ?
11:39:29 <yrlnry> toki78:  No, 8m is terrible.
11:40:01 <yrlnry> The command-line "factor" program on my laptop factored 6913595986426429 in < 0.2 seconds.
11:40:21 <toki78> ah ok, thanks, I didnt know
11:40:25 <yrlnry> That is a product of two 27-bit numbers.
11:40:38 <yrlnry> toki78:  glad to be of service.
11:41:05 <toki78> yrlnry, are these 2 27 bit numbers prime numbers ?
11:41:10 <yrlnry> yes.
11:41:43 <yrlnry> Obviously it is easy to factor smooth numbers. :)
11:41:45 <toki78> ok, I did it with a sat solver
11:42:42 <toki78> that command line tool is amazing
11:43:13 <yrlnry> It must be relatively low-tech.
11:43:25 <yrlnry> I don't know how it works though, but it is standard with most Linux installs.
11:43:45 <toki78> thanks
11:44:21 <yrlnry> Anyway, since it is Linux, the source code is widely available, so...
11:44:24 <toki78> bye
11:44:27 <yrlnry> Au revoir.
11:47:55 <applicative> :( no factor on homebrew
11:52:20 <hpaste> nand` pasted ‚ÄúFunctional pong with lenses and gloss (moved time stuff to a Reader)‚Äù at http://hpaste.org/72619
11:52:26 <nand`> I'm honestly not sure if this version is an improvement
11:53:23 <geekosaur> applicative, it's part of gnu coreutils
11:53:49 <Eduard_Munteanu> "The Pollard Rho algorithm used by `factor' is particularly effective for numbers with relatively small factors." -- from the info page
11:54:26 <applicative> yeah, I guess not in the bsd ancestor of os x
11:55:53 <geekosaur> yeh, that fails to surprise me actually.  it would have been based on the original BSD MP library, which was never freed --- gmp is the successor
11:57:03 <applicative> ah i see
11:57:04 <geekosaur> sorry, from V7 not BSD
11:57:50 <geekosaur> just best known as being from BSD, because it was in the fork that BSD derived from but not the one System III/V did
11:58:23 <applicative> ah, but I see coreutils.rb in the homebrew list
11:58:23 <copumpkin> edwardk: spamming twitter again :)
11:59:26 <copumpkin> edwardk: it claims to be via web, so maybe you have a chrome plugin doing it, or you should just change your twitter credentials
11:59:36 <edwardk> hrmm
11:59:55 <nand`> edwardk: I actually managed to beat the CPU
12:00:45 <edwardk> signed out of twitter to see if its something local
12:00:54 <edwardk> but its happened before when i've been completely off the computer
12:01:02 <TURK182> CIAO
12:01:08 <TURK182> !LIST
12:01:09 <copumpkin> have you changed your twitter credentials?
12:01:14 <copumpkin> TURK182: wrong channel
12:01:19 <timthelion> edwardk: mcookie is your friend :D
12:01:22 <t7> vector wont build on arm :(
12:01:24 <t7> no ghci
12:01:30 <t7> for annotations or something
12:01:53 <edwardk> changed the password, etc.
12:02:02 <copumpkin> weird
12:02:24 <applicative> geekosaur: ah homebrew prefixes the coreutils with 'g'  so now i have gfactor etc
12:02:59 * hackagebot language-ecmascript 0.9 - JavaScript analysis tools (AndreyChudnov)
12:03:01 * hackagebot haskarrow 0.0 - A dialect of haskell with order of execution based on dependency resolution (TimothyHobbs)
12:03:31 <timthelion> :) and there's my new package :D :D
12:03:43 <geekosaur> that's surprisingly sane of it, considering.  (there are a lot of collisions between coreutils and native utilities; lots of things break if you don't rename.  homebrew usually thinks that's your poroblem, not theirs
12:05:10 <applicative> geekosaur: Yes, I think they might be getting more sophisticated. On the other hand the scrapped iconv completely since the problems were insuperable.
12:05:17 <applicative> they scrapped it  rather
12:05:49 <mroman> How did I end up implementing prelude functions with Java classes o_O
12:06:32 <luite> t7: you need ghc 7.4.2 for ghci on arm, do you have that?
12:07:04 <t7> erm nope i got the platform
12:08:53 <McManiaC> haddock down?
12:08:57 <McManiaC> hackage*
12:09:08 <Enigmagic> up for me
12:09:12 <applicative> its okay here
12:09:28 <McManiaC> I only get white pages, e.g. on http://hackage.haskell.org/package/happstack-server
12:11:35 <t7> i dont think im gonna be able to build 7.4.2 on pi :(
12:13:07 <ReinH> nand`: not sure the operators are gaining you anything in terms of readability
12:13:34 <applicative> McManiaC: baffling, it looks fine
12:13:39 <ReinH> nand`: how about something like ballPos `step` ballSpeed
12:13:55 <copumpkin> edwardk: http://stackoverflow.com/questions/11808539/monoidal-parsing-what-is-it
12:13:56 <nand`> I'm thinking `addWith` `subWith`
12:14:10 <McManiaC> applicative: weird, I can view the pkg-list.html but I cant view any packages :(
12:14:11 <ReinH> nand`: and I'm thinking about intention revealing rather than implementation revealing :)
12:14:17 <McManiaC> applicative: only get white pages
12:14:18 <edwardk> yeah, i replied here, i'll follow up on stackoverflow when i can get clear of the current round of lens changes
12:14:25 <Enigmagic> McManiaC: try a different browser?
12:14:38 <ReinH> nand`: why not just make a vector of ball motion?
12:15:12 <McManiaC> Enigmagic: no difference
12:15:32 <McManiaC> Enigmagic: the HTML just stops here: http://npaste.de/rceg/
12:15:48 <ReinH> nand`: then just transform the ballPos point
12:15:52 <nand`> ReinH: so I can do (pos + speed) and, pos is needed as (Float, Float) because of `at`
12:16:07 <nand`> also the .both lens works nicely with tuples
12:16:34 <nand`> but I could factor it out to some vector library if I provide lenses for the vectors + change `at`
12:16:54 <ReinH> nand`: not even a Vector, just another tuple of (xSpeed, ySpeed)?
12:16:55 <Enigmagic> McManiaC: i dunno then.
12:17:23 <ReinH> nand`: then you have nice properties around flipping magnitudes at bounds as well
12:17:54 <srhb> Why is the type of Data.Hex.unhex :: Monad m => m [Char] ?
12:17:58 <Peaker> edwardk, sent a pull request
12:18:02 <srhb> I don't get what the Monad bit is for.
12:18:11 <edwardk> score
12:18:14 <edwardk> it worked?
12:18:16 <nand`> ReinH: I'm not sure what you mean, what would be the type of _ballSpeed?
12:18:16 <Peaker> edwardk, with it, there's no need to import extra stuff at the call-site. But I added a bit of ugly partiality
12:18:18 <Peaker> edwardk, yeah :)
12:18:25 <edwardk> partiality?
12:18:34 <Peaker> edwardk, not too bad, look at: "let [t0, t1, t2, t3] ="
12:18:34 <fran> srhb: the type is: Monad m => m [Char]
12:18:45 <edwardk> ok, so i could split that up?
12:18:48 <Peaker> edwardk, I wanted to "map return" on it so my QQ can use it with $t0 $t1 ...
12:18:57 <srhb> fran: Sorry, I forgot the argument
12:19:02 <Peaker> edwardk, maybe there's a nicer way (or perhaps just call return 4 times)
12:19:06 <ReinH> nand`: _ballSpeed :: (XMag, YMag)
12:19:33 <ReinH> nand`: newPos = ballPos |+| ballSpeed where  (a,b) |+| (c,d) = (a+b, c+d)
12:19:56 <nand`> ReinH: what are XMag, YMag?
12:20:06 <ReinH> maybe ballVelocity is a better term as it indicates it's vector
12:20:16 <ReinH> nand`: Float probably?
12:20:27 <nand`> ReinH: then I don't see how that differs from what I'm currently doing
12:20:27 <Peaker> "return" is an awfully long name, especially in the Q monad where you often have to Q-wrap stuff...
12:20:28 <ReinH> in terms of dx/t, dy/t
12:20:39 <ReinH> nand`: let me look again
12:20:40 <edwardk> yeah
12:20:44 <ReinH> nand`: can you link to that hpaste?
12:20:47 <Peaker> [t| Type $(return x) $(return y) $(return z) |] <-- bah
12:20:51 <nand`> ReinH: http://hpaste.org/72619
12:20:53 <ReinH> ty
12:21:02 <ReinH> nand`: er.
12:21:08 <ReinH> I'm sorry, I must have been confused
12:21:14 <edwardk> i'd rather have the safer version though
12:21:15 <nand`> type Vector = (Float, Float) -- from Graphics.Gloss
12:21:16 <Peaker> edwardk, I wonder if there's a more direct reason for the lack of need to import (I'd expect the QQ to expand to something one could write directly..)
12:21:25 <ReinH> nand`: ok perfect, yes, sorry
12:21:29 <ReinH> nfi why I thought you were doing something different
12:21:30 <Peaker> edwardk, If you want I can convert it to just use return 4 times
12:21:31 <edwardk> well, mkName goes fishing for it
12:21:35 <edwardk> sure
12:21:43 <edwardk> hack that in and send a pull req
12:21:47 <ReinH> nand`: although I would define a nice operator to add the speed vector to the position point :)
12:21:55 <edwardk> and i'll merge it into my branch as soon as i get through adding actions
12:22:22 <ReinH> nand`: maybe that doesn't work very well with the lens though?
12:22:27 <nand`> ReinH: I use (+)
12:22:57 <ReinH> nand`: er... ballPos +=? \t -> (t*u, t*v) ?
12:23:01 <ReinH> oh
12:23:02 <ReinH> that's step
12:23:07 <nand`> that's for the time
12:23:07 <ReinH> sorry
12:23:09 <hayashi> Arch gets more rice every time someone talks about it
12:23:14 <ReinH> nand`: I can totes read code :/
12:23:16 <hayashi> Woops
12:23:29 <ReinH> nand`: I promise
12:23:31 <nand`> there's no scalar multiplication in Graphics.Gloss's Vector implementation
12:23:33 <nand`> :(
12:23:45 <ReinH> nand`: strange
12:23:55 <ReinH> you'd think that would be useful
12:24:03 <Peaker> edwardk, https://github.com/ekmett/lens/pull/4/files <-- now safe
12:24:22 <hayashi> Wrong channel _entirely_
12:24:36 <ReinH> nand`: nice use of ReaderT there for game clock
12:24:40 * nand` reverts to the version with manual passing-around of ‚Äòtime‚Äô, he thinks it was clearer than the +=? stuff
12:24:43 <timthelion> hayashi: were you talking about the linux distribution, or hentai?
12:25:14 <ReinH> nand`: +1
12:25:49 <ksf> argh what happened to sodium's asynchronously?
12:26:10 <ReinH> nand`: so +=? somehow takes a function from time to the second arg to +?
12:26:17 <ReinH> magic? :D
12:26:23 <nand`> ReinH: exactly
12:26:33 <ReinH> nand`: ... how?
12:26:51 <nand`> but paddle2 += time * paddleSpeed is so much clearer than paddle2 += (* paddleSpeed)
12:26:58 <nand`> +=? even
12:27:01 <ReinH> yes, it is
12:27:10 <nand`> ReinH: I don't know how to explain, look at the definition?
12:27:17 <ReinH> nand`: I was suggesting factoring (time * paddleSpeed), not lifting time :p
12:27:22 <nand`> oh
12:27:23 <nand`> :(
12:27:32 <ReinH> sorry
12:27:39 <ReinH> nand`: oh with ask
12:27:47 <ReinH> inside ReaderT Time
12:27:49 <ReinH> duh.
12:28:18 <danil> Peaker: mkName ends up getting evaluated in the environment of the module using the macro, but names in QQs (and 'quoted names) get resolved when you define the macro.  (You could also use name = $(mkName "TheName") at the top level of the defining module to have the right things be in scope.)
12:28:27 <ReinH> nand`: Time * Vector is instantaneous moment of something or other
12:28:36 <edwardk> hrmm it won't automatically merge, did you rebase it over the previous commit?
12:28:39 <ReinH> I can't math
12:28:52 <Peaker> edwardk, I amended the previous commit
12:28:56 <roconnor> +=? ??
12:29:09 <ReinH> roconnor: yeah, operators like that make me a bit o_O as well
12:29:13 <Peaker> danil, $(mkName ..) would work? Even though it's not a Q thing?
12:29:23 <edwardk> ah, i'd already merged, not sure how to take your pull req =/
12:29:26 * roconnor thinks there still might be a place for lens-family :D
12:29:44 <edwardk> roconnor: =P
12:29:47 <hpaste> nand` annotated ‚ÄúFunctional pong with lenses and gloss (moved time stuff to a Reader)‚Äù with ‚ÄúFunctional pong with lenses and gloss (got rid of +=? silliness)‚Äù at http://hpaste.org/72619#a72621
12:29:54 <nand`> ReinH: there, should be much cleaner ^
12:29:57 <edwardk> +=?
12:30:03 <Peaker> edwardk, you can undo the merge (reset --hard <ref>) and merge again?
12:30:09 <roconnor> edwardk: but it is super awesome, as you note, that the lens representation is divorced from the lens library.
12:30:10 <danil> Peaker: um, needs a `return` in there, but I think it should
12:30:30 <edwardk> i merged it i did it by just clicking on a button on the website
12:30:42 <edwardk> roconnor: well, sadly my getters and setters will be incompatible with yours soon
12:30:50 <roconnor> ah
12:30:51 <roconnor> so sad
12:31:02 <edwardk> er they probably already are
12:31:05 <edwardk> i use identity/Const
12:31:06 <roconnor> I guess
12:31:07 <Peaker> danil, nope, it complains that it wants a Q Exp, not Q Name
12:31:09 <edwardk> you have Getting/Setting
12:31:24 <roconnor> ya
12:31:33 <roconnor> though I'm not strongly committed to it
12:31:34 <Peaker> edwardk, if you didn't do anything else you can undo the merge with "reset --hard <ref before the merge>" and "push -f"
12:31:41 <Peaker> edwardk, but wait, I'll just make a new commit instead
12:31:43 <nand`> compatibility with other implementations is exactly the reason why I prefer Identity/Const over newtypes
12:31:45 <Peaker> edwardk, that's not amended
12:31:48 <nand`> or custom implementations*
12:32:04 <edwardk> now I'm using type Getter a c = forall m r b d. Monad m => (c-> Act m (Const r) d) -> a -> Act m (Const r) b
12:32:11 <edwardk> Peaker: that'd be easiest for me
12:32:20 <nand`> Act? Great, more type aliases to memorize
12:32:32 <sdsad> hello room
12:32:39 <applicative> hello sdsad
12:32:41 <sdsad> just checking
12:32:42 <edwardk> otherwise i need to deal with either making another repo to edit github, or risk losing stuff by swapping branches, etc. but i haven't branched
12:33:00 <roconnor> nand` edwardk: had any experince with using MultiLenses in place of partial lenses?
12:33:09 <nand`> MultiLenses?
12:33:39 <edwardk> oh i have a horrible story for partial lenses that fit this new model, but i'll explain more later -- there is a talk going on here at hac phi ;)
12:33:56 <roconnor> nand`: ewardk calls multilenses "traversal" or something like that
12:33:59 <edwardk> its a hack that lets me use partial lenses without requiring any new classes
12:34:02 <nand`> ah
12:34:16 <roconnor> edwardk: does it involve "fail"?
12:34:21 <edwardk> maybe =P
12:34:46 <edwardk> it fits pretty elegantly into the action framework
12:34:55 <roconnor> nand`: personally I'd rename Traversal into "MultiLens" :P
12:35:05 <Peaker> edwardk, sent a new pull request that should merge cleanly
12:35:06 <edwardk> thats not going to happen =)
12:35:10 <edwardk> Peaker: great!
12:35:12 <roconnor> edwardk: I'm not aware of any theory for monadic lenses
12:35:14 <srhb> I am confused again. How is it that readHex "ed0c8cb0" defaults and gives [(3977022640,"")], but readHex "ed0c8cb0" :: [(Int,String)] gives [(-317944656,"")] ?
12:35:20 <edwardk> i have laws for them
12:35:28 <edwardk> and i have motivations
12:35:33 <roconnor> > 3977022640 :: Int32
12:35:34 <lambdabot>   -317944656
12:35:38 <Cale> srhb: the default numeric type is Integer
12:35:41 <srhb> Oho
12:35:52 <roconnor> edwardk: interesting
12:35:52 <srhb> Obvious. Thanks. *headdesk*
12:36:01 <edwardk> missing a nice talk on 'cyclotomic', afk
12:36:44 <roconnor> oh, is it ITP weekend in philidelphia?
12:38:07 <edwardk> hac phi
12:38:36 <roconnor> ah
12:38:40 <roconnor> ITP isn't until next weekend
12:38:52 <Rc43> Hi, guys.
12:38:53 <roconnor> and it is in princeton
12:39:22 <srhb> Hmm. Now how do I go the other way though...
12:39:32 <hpaste> ReinH annotated ‚ÄúFunctional pong with lenses and gloss (moved time stuff to a Reader)‚Äù with ‚ÄúFunctional pong with lenses and gloss (with a couple extracted functions)‚Äù at http://hpaste.org/72619#a72622
12:39:47 <ReinH> nand`: just a couple very simple refactors
12:40:47 <ReinH> (lines 91,92)
12:41:33 <Rc43> Anybody uses vim for haskell?
12:41:37 <ReinH> Rc43: yes
12:41:38 <danil> Peaker: you're right, to do it with $() you'd need to generate the AST for 'ident as a Q Exp, which I don't see a way to do (and would be convoluted anyway).  But the idea is that quoted idents and quasiquotes are early bound/hygenic and mkName is not.
12:41:39 <nand`> Rc43: yes, many
12:41:51 <ReinH> it's p good
12:42:14 <Rc43> I am about that there are a lot of cool things for emacs; are there anything similar in vim?
12:42:33 <ReinH> you need a bit of external tooling to get a really good environment imo compared to emacs but it's very functional, especially with vim-haskellmode
12:42:35 <applicative> Rc43 there was a video demo the other day, it sort of made me want to learn vim
12:42:39 <Rc43> haskell-mode/cabal-mode/ghc-mod/scion
12:42:42 <ReinH> applicative: probably mine?
12:42:54 <ReinH> haskellmode.com ?
12:42:55 <ReinH> ER
12:42:57 <ReinH> haskelllive.com ?
12:43:24 <applicative> ReinH: oh maybe http://www.youtube.com/watch?v=ScS8Q32lMxA
12:43:33 <ReinH> applicative: yep that's me
12:43:34 <nand`> ReinH: thanks, you need to wrap (keyPressed KeyUp) also
12:43:38 <ReinH> nand`: sorry
12:43:54 <ReinH> "I have only proved it correct", except not
12:44:16 <applicative> it was awesome but I think you were showing vim mastery that you'd spent years acquiring...
12:44:21 <ReinH> applicative: emacs with haskell mode can do all that and more tbh, I'm just way better at vim
12:44:33 <ReinH> yes, a decade or so
12:44:42 <ReinH> but the point was for the editor to largely be transparent
12:44:50 <ReinH> it's not a vim video after all
12:45:11 <ReinH> and emacs is just as good or better for haskell
12:45:20 <Rc43> I just donwloaded emacs, opened it and couldn't even close it. LIke vim some time ago :)
12:45:20 <applicative> ReinH: of course, except for someone who knows  haskell but not vim it is interesting
12:45:21 <ReinH> minor modes are truly a thing of beauty
12:45:34 <ReinH> applicative: :) if you have any vim questions I'm happy to answer
12:45:43 <alpounet> Rc43, Ctrl-X Ctrl-C
12:45:49 <ReinH> (and major modes, for that matter)
12:45:58 <Peaker> danil, that means QQ are the only way to do some things
12:45:59 <frerich> Rc34: Some people consider that a feature; a colleague patched his emacs to disallow quitting him, so that he never loses any buffers.
12:46:06 <pipocaQuemada> What's the best rng library in haskell?
12:46:26 <ReinH> frerich: I can see how being able to quit your OS with a simple keystroke might be viewed as a disfeature
12:46:27 <applicative> thats' okay i dont think i'm ready. I use emacs for agda, but just a tiny fragment of general emacs keybindings
12:46:33 <alpounet> pipocaQuemada, mersenne-random is cool
12:46:34 <ReinH> frerich: ;)
12:46:45 <frerich> ReinH: Yes ;-)
12:47:05 <Rc43> ReinH, only now have seen your message "<ReinH> you need a bit of external tooling to get a really good environment imo compared to emacs but it's very functional, especially with vim-haskellmode"
12:47:07 <danil> Peaker: if the 'identifier syntax counts as QQ then it appears so
12:47:08 <ReinH> ok, three simple keystrokes
12:47:15 <Rc43> RainH, external tools - which ones?
12:47:40 <danil> (but there's really nothing quasi about it)
12:47:41 <ReinH> Rc43: in my video I have ghci and a file watcher running runghc on saves in tmux splits
12:48:00 <ReinH> sort of an "ide" experience (but definitely not an IDE experience, if you will)
12:48:37 <Rc43> Splits aren't huge advantage for me, I intensively use terminal tabs.
12:48:54 <Rc43> ReinH, but differen autocomplete fetures would be greate.
12:49:08 <Rc43> *great
12:49:18 <ReinH> Rc43: vim-haskellmode gives you tag and ghci browser based omnicomplete
12:49:20 <Peaker> danil, I'm using: [t| SomeName ... |]  (not ' syntax) but maybe I'm misunderstanding you
12:49:23 <applicative> pipocaQuemada: like alpounet I found mersenne-random pleasing. I was introduced to it by the vector tutorial http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
12:49:24 <ReinH> it's very nice
12:49:31 <Peaker> danil, and already the effect of early-binding that seems impossible to replicate
12:49:33 <ReinH> Rc43: you could read the help docs
12:50:35 <ReinH> applicative: btw I'm recording another video this weekend. If you're feeling extremely generous, you could code review the last episode's code and tell me what you dislike :D
12:51:24 <Rc43> ReinH, tag? You mean ctags-like thing? It is based on compiler infrastructure or like ctags for C++? C++ tags generator is not cool, it makes mistakes often.
12:51:39 <ReinH> Rc43: yes, ctags
12:51:46 <ReinH> and also based in reflecting on ghci runtime
12:51:55 <pipocaQuemada> Is there a version of mersenne that doesn't live in IO?
12:52:28 <ReinH> two different completion modes
12:52:52 <ReinH> Rc43: you should RTFM :)
12:54:01 <applicative> Rc43: did you see dons other package http://hackage.haskell.org/packages/archive/mersenne-random-pure64/0.2.0.3/doc/html/System-Random-Mersenne-Pure64.html
12:54:45 <Rc43> ReinH, ok-ok :)
12:55:05 <ReinH> applicative: I think you meant pipocaQuemada
12:55:12 <Rc43> applicative --> pipocaQuemada
12:55:29 <applicative> oops yes I did
12:55:41 <applicative> pipocaQuemada: did you see dons other package http://hackage.haskell.org/packages/archive/mersenne-random-pure64/0.2.0.3/doc/html/System-Random-Mersenne-Pure64.html
12:56:44 <danil> Peaker: I just mean that [t| SomeName |] and (return (ConT ''SomeName)) should have the same effect
12:57:56 <timthelion> When I have tuple (Int,String) and I apply fmap f myTuple how do I know which side of the tuple is mapped across?  Does functor map not work for "complex types" that have more than one internal type?
12:58:19 <applicative> the right side since it's the second argument of (r,a)
12:58:37 <timthelion> (r,a) ?
12:58:47 <applicative> timthelion: there are other concepts like Bifunctor around.
12:58:57 <Peaker> danil, oh.. right. I might be able to get rid of the QQ after all
12:59:04 <Peaker> danil, using that equivalence.. gonna try now
12:59:23 <applicative> timthelion: the instance reads something like:  instance Functor ((,) r) where fmap f (r,a) = (r,f a)
12:59:39 <timthelion> applicative: so if I understand it correctly, with complex types, there is a rule for determining which type is mapped across, and then there are other Functor like classes that handle complex types "better"?
13:00:22 <Peaker> danil, yeah, it does work.. thanks
13:00:30 <Peaker> danil, no need for QQ for early-binding :)
13:00:50 <applicative> timthelion: it's always the last parameter in the general type.  So Either a b has functor instance Functor (Either a) where fmap f (Left a) = Left a ; fmap f (Right b) =RIght (f b)
13:01:26 <ReinH> Peaker: that's funny because "QQ" in the gaming community means whining or complaining.
13:01:32 <ReinH> Peaker: so less QQ is definitely a good idea.
13:01:49 <timthelion> applicative: the article I read on functors said that there is one and only one valid functor instance per type.  Was this correct?
13:01:58 <timthelion> applicative: ok, thank you, I think I understand it better now.
13:02:00 <applicative> timthelion: there are a million definitions of something like bifunctor on hackage e.g. http://hackage.haskell.org/packages/archive/bifunctors/3.0/doc/html/Data-Bifunctor.html
13:02:22 <Peaker> ReinH, :)
13:02:34 <applicative> timthelion: i think there is only one Functor instance if you leave out trivial fmap f fx = undefined and so on.
13:02:42 <Peaker> edwardk, Would you prefer a QQ-less version of the same thing? I'll send a pull request, it's not better, it's just without QQ, if you want
13:02:55 <applicative> timthelion: I remember seeing a simple proof of this  by roconnor
13:03:14 <danil> timthelion: like on the value level, every type constructor (not-so-)secretly takes only one argument; in the case of (a, b) it's actually ((,) a) applied to b.  The functor typeclass only works on the last type argument, because if f is a functor then "f a" has to be a fully-formed type (of kind *) and not a thing-expecting-more-type-arguments (of kind * -> *, say).
13:04:04 <edwardk> dropping the QQ would be nice
13:04:06 <timthelion> danil: oh! so there IS logic to it! it's not just arbitrary :D
13:04:10 <edwardk> using reify?
13:04:24 <nand`> edwardk: what would you call :: (RandomGen g, Random a, MonadState s m) => SimpleLens s g -> m a;  I'm thinking ‚ÄòrandomOfM‚Äô, with M signalling the state-monad
13:04:26 <ReinH> If I have a product type like data Piece = Piece PColor PType that is composed of sum types, how can I prove (or at least reason about) whether a function from Piece is total?
13:04:30 <Peaker> edwardk, Using (ConT ''Lens)
13:04:49 <Peaker> edwardk, more minor change of ''Lens rather than mkName was enough, apparently
13:05:12 <edwardk> nice
13:05:16 <edwardk> thats quite pretty even
13:06:03 <Peaker> https://github.com/ekmett/lens/pull/5/files
13:06:33 <edwardk> perfect
13:06:47 <hpaste> nand` annotated ‚ÄúFunctional pong with lenses and gloss (moved time stuff to a Reader)‚Äù with ‚ÄúFunctional pong with lenses and gloss (random starting speed)‚Äù at http://hpaste.org/72619#a72623
13:07:13 <applicative> timthelion: I cant find roconnors email but the proof proceeds by supposing two functions fmap and gmap each satisfying the functor laws then reduces them to the same.
13:07:35 <applicative> the laws being fmap f . fmap g = fmap (f . g) and fmap id = id
13:08:07 <byorgey> applicative, timthelion: http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
13:08:24 <applicative> oh byorgey thats it thanks
13:08:30 <edwardk> you start with the free theorem for each, then the fmap id = id    and gmap id = id, and you get there pretty fast
13:08:31 <timthelion> thanks
13:08:37 <Peaker> due to parametericity, any 1 of those laws is enough?  Or one of them is powerful enough?
13:08:58 <edwardk> yes
13:09:07 <Peaker> either, or one particular one, I meant?
13:09:09 <edwardk> fmap id = id with the free theorem forces fmap f . fmap g = fmap (f . g)
13:09:21 <edwardk> fmap f . fmap g = fmap (f . g) isn't enough
13:09:33 <edwardk> because it could make a single idempotent edit
13:10:02 <Peaker> that clears it up quickly :)
13:10:31 <ReinH> I just stumbled on rconnor's PhD thesis, proving Godel's first incompleteness using type theory. Awesome.
13:11:56 <nand`> curry-howard style?
13:12:27 <avpx> Hey folks, where is the instance of Functor ((->) a) located?
13:12:35 <nand`> Control.Monad.Instances
13:12:38 <avpx> Thanks
13:12:45 <Nereid> alright, turns out that I could compile an older ghc snapshot.
13:13:03 <parcs`> avpx: which is reexported by Control.Applicative instead
13:13:25 <roconnor> edwardk: instance Focus ReaderT doesn't use Getting ?
13:13:47 <edwardk> can't
13:13:53 <edwardk> doesn't know what the type is
13:14:00 <edwardk> i could make an MPTC, etc.
13:14:06 <edwardk> but thats messier
13:14:27 <edwardk> i'm not against doing so
13:14:39 <roconnor> edwardk: doesn't know what what type is?
13:14:49 <edwardk> how would the instance look?
13:15:30 <roconnor> ya well, it isn't possible with the class mechanism I guess
13:21:26 <nand`> edwardk: why does instance Functor (Focusing m c) require a Monad m instead of a Functor m? isn't it just fmap (second f) ?
13:21:51 <edwardk> because if i work in a monad transformer i only get the Monad for m
13:21:51 <nand`> or is this deliberate to help the type checker infer stuff
13:22:15 <edwardk> go fix the Functor/Monad hierarchy and i'll dumb it down ;)
13:22:21 <nand`> oh
13:22:28 <latro`a> lol
13:22:36 <nand`> I hate that
13:23:00 <danil> heh, "go fix".  Exactly the kind of tool we'd need to get that done
13:25:02 <ReinH> Haskell jokes!
13:25:58 <danil> (was actually a golang joke--they have a tool that updates your code when they change libraries, and you call it with "go fix")
13:26:10 <ReinH> ah
13:26:18 <ReinH> I thought it was some sort of fixed point combinator joke ;)
13:26:24 <geekosaur> surely the haskell one would be fix go?
13:26:37 <geekosaur> well, ok, it'd have to be IO.  mfix
13:26:46 <ReinH> geekosaur: I'm pretty sure Haskell can't fix Go.
13:26:48 <ReinH> Zing.
13:27:04 <geekosaur> go's beyond help...
13:28:50 <danharaj> edwardk: I saw an interesting paste on hpaste the other day... :P
13:30:06 <edwardk> ?
13:31:02 <danharaj> http://hpaste.org/72552
13:32:36 <danharaj> edwardk: active lenses
13:32:49 <ben> What's the syntax for guards if not using layout?
13:32:49 <Rc43> ReinH, which version of vim do you use? (I started to install haskellmode only now.)
13:33:07 <Rc43> ReinH, somehow haskellmode.vba can't be installed
13:33:15 <danil> ben: you actually don't need any delimiters, it's super gross
13:33:18 <timthelion> I could have saved myself a lot of case statements if I had realised that fmap works with Maybe :)
13:33:57 <Rc43> Not an editor command: UseVimball
13:34:19 <danil> > (let f x | x == 1 = "one" | x == 2 = "two" in f 2) -- ben
13:34:20 <lambdabot>   "two"
13:34:39 <ben> Ah
13:35:23 <timthelion> danil: do you need the parens there?
13:36:55 <geekosaur> no
13:38:06 <timthelion> I'm reading roconnor's uniquenes of functor proof, and I'm stuck on
13:38:07 <timthelion> foo (g . f) = fmap g . foo f
13:38:27 <timthelion> I presume because I don't know what the "free theorem for foo" is
13:38:56 <augur> anyone seen ski?
13:39:05 <danharaj> @seen ski
13:39:06 <lambdabot> Unknown command, try @list
13:39:08 <danharaj> oops.
13:39:10 <timthelion> preflex: seen ski
13:39:10 <preflex>  ski was last seen on #haskell 5 days, 22 hours, 41 minutes and 31 seconds ago, saying: * ski should look more at how packages the work, ty for the reminder
13:39:34 <timthelion> augur: he's looking at how packages work...
13:39:45 <avpx> timthelion: Well thanks for the reminder.
13:40:15 <timthelion> avpx: :P ?
13:40:24 <augur> timthelion: what
13:40:30 <augur> oh
13:40:31 <augur> heh
13:41:15 <timthelion> so what is the free theorem for foo? http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
13:41:59 <danil> timthelion: the paper is Wadler's "Theorems for Free!".  Basically, you can prove things about polymorphic functions from their type alone. http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9875
13:42:45 <timthelion> danil: oh, that was the first google result for "free theorem" and I scanned right over it thinking it was a joke or a political tyrade about how everything should be open source like math.
13:42:56 <timthelion> :D
13:44:40 <lamefun> what to do in case array out of range?
13:45:00 <lamefun> crash?
13:45:38 <timthelion> Ironically, that article isn't free :/
13:45:43 <timthelion> so I cannot read it
13:45:51 <timthelion> bastards :/
13:47:28 <ReinH> Rc43: don't use vimballs, they're the worst packaging system ever
13:47:38 <ReinH> Rc43: use https://github.com/tpope/vim-pathogen/
13:47:48 <ReinH> it lets you have a directory per plugin
13:47:50 <danil> timthelion: do the little icons under "cached" not work for you?  I'm not logged in or on a university network right now, so if they don't I have no idea why
13:47:56 <ReinH> rather than spreading them out across vim's retarded directory structure
13:48:20 <ReinH> if you're using git you can just git git clone into your ~/.vim/bundle directory
13:48:26 <ReinH> s/git git/git
13:48:52 <roconnor> timthelion: what is the type for foo?
13:48:56 <ReinH> otherwise you can just untar the tarball
13:49:15 <ReinH> roconnor: saw your PhD thesis on proving godel in type systems, very cool
13:49:20 <roconnor> :)
13:49:25 <ReinH> roconnor: is it available anywhere?
13:49:37 <roconnor> http://r6.ca/thesis.pdf
13:49:37 <augur> timthelion: i have a copy of it
13:49:45 <ReinH> awesome ty
13:50:27 <alpounet> i think it's available (for free) from wadler's page
13:50:32 <ReinH> roconnor: I suppose we now have yet another way to misinterpret godel in a lay context though :p
13:50:49 <ReinH> "your program obviously has bugs in it because godel" etc
13:52:46 <Veinor> roconnor: is it called the fluorine revision because it's the 9th?
13:52:56 <timthelion> danil: Oh, I see, so they are trying to sell me something that is free :)
13:52:58 <augur> alpounet: aha yep you're right
13:53:01 <augur> timthelion: http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html
13:53:08 <Rc43> ReinH, installed pathogen. It talks to mkdir for my plugin and do "UseVimball ...". But "UseVimball" is incorrect command.
13:53:30 <ReinH> Rc43: might want to bring it to #vim, but you shouldn't be using vimballs ever
13:53:41 <alpounet> augur, it's just that as great as wadler is, i don't think i'd have paid for that article when 19 years old :D and i know i've read it, so i did the maths :p
13:54:02 <Rc43> Rc43, but on single page about haskellmode (http://projects.haskell.org/haskellmode-vim/) there is only vimball download link.
13:54:08 <Rc43> ReinH, but on single page about haskellmode (http://projects.haskell.org/haskellmode-vim/) there is only vimball download link.
13:54:16 <ReinH> Rc43: github clone...
13:54:23 <Rc43> ReinH, hm, ok
13:54:27 <ReinH> Rc43: https://github.com/lukerandall/haskellmode-vim
13:54:32 <ReinH> git clone or download tarball
13:54:36 <Rc43> ReinH, thank you
13:54:39 <ReinH> np
13:55:19 <Rc43> ReinH, do you store all your plugins as just cloned repo?
13:55:32 <ReinH> Rc43: submodules actually, since I track my .vim
13:55:38 <timthelion> danil: reading just the intro to that article really goes to cement a sentiment that I've been growing, that mathematical papers in the last 10 years have been becoming harder for the layperson to read.  This is almost english :)
13:55:45 <ReinH> although tbh I haven't been managing it very well b/c of laziness
13:56:05 <ReinH> timthelion: which?
13:56:11 <ReinH> I like reading almost english mathematical papers
13:56:12 <theadmin> Is there a way to list running processes in Haskell? I need a simple list of Strings, preferably -- something along the lines of ["Xorg", "firefox", "bash", "ssh"]
13:56:17 <timthelion> ReinH: Theorems for free
13:56:31 <theadmin> Staring at System.Process doesn't give me anything similar yet >.<
13:57:06 <Veinor> what's the datatype i want if I need O(1) in-place updates?
13:57:26 <luite> some mutable array probably
13:57:34 <timthelion> ReinH: you know, most of the trouble with the papers isn't their complexity, it's their affinity for naming simple ideas after germans who's last names do nothing in the way of reminding us as to what the original concept was.
13:58:02 <mornfall> Which papers? :-)
13:58:24 <timthelion> mornfall: Two collumn papers on mathematics :)
13:58:39 <mornfall> Oh, okey. Makes sense.
13:58:45 <ReinH> timthelion: :)
13:59:12 <ReinH> timthelion: prefer intention revealing names to author revealing names?
13:59:25 <timthelion> ReinH: yes, always
14:00:34 <lamefun> what is the common behaviour for Haskell in situations, eg. when array member is requested that's out of range?
14:00:46 <lamefun> crash or return default value?
14:00:53 <luite> exception usually
14:01:10 <luite> but some packages can be compiled unchecked, so you can also have undefined behaviour and crashes
14:01:11 <timthelion> lamefun: old functions crash, but if you are writting a NEW function, you should use Maybe
14:01:12 <mornfall> Try head [] or tail [].
14:01:36 <theadmin> lamefun: It errors out.
14:01:43 <ReinH> :t (!!)
14:01:45 <lambdabot> forall a. [a] -> Int -> a
14:01:51 <theadmin> lambdabot: Well, depends on the function actually
14:01:51 <mornfall> timthelion: Maybe is a lot of hassle if you know it's going to be a Just nevertheless.
14:01:57 <ReinH> > [1,2]!!5
14:01:58 <lambdabot>   *Exception: Prelude.(!!): index too large
14:01:59 <theadmin> > [1,2,3]!!100500
14:02:01 <lambdabot>   *Exception: Prelude.(!!): index too large
14:02:17 <timthelion> mornfall: no excuse
14:02:37 <timthelion> mornfall: the only case I take that excuse is div.  Can't imagine doing math with Maybes :D
14:02:50 <luite> maybe has also an extra level of indirection and pattern matches
14:02:51 <srhb> More >>=s
14:02:52 <srhb> :P
14:03:04 <luite> can be a problem if you used arrays for maximum performance
14:03:10 <avpx> Maybe / Either are a good solution for pure code
14:03:22 <mornfall> @src safeHead
14:03:23 <lambdabot> Source not found. Maybe you made a typo?
14:03:26 <mornfall> Blah.
14:03:31 <ReinH> if you're using unpacked, unboxed arrays for performance, Maybe is a lot of overhead
14:03:37 <mornfall> timthelion: Use the safe functions if you care. :-)
14:03:43 <luite> mornfall: listToMaybe
14:03:51 <theadmin> Is there a way to list running processes in Haskell? I need a simple list of Strings, preferably -- something along the lines of ["Xorg", "firefox", "bash", "ssh"]. The actual purpose is to check if a process with a specific name exists (thinking of using elem, heh)
14:04:16 <mornfall> timthelion: I am all for head [] being a crash.
14:04:26 <mornfall> timthelion: Although it'd be much better if it actually gave you a hint what went wrong.
14:04:46 <mornfall> Afterall, Just foo <- safeHead ... is the same crash.
14:04:50 <timthelion> mornfall: then go out near a club at 5 am, you'll see a lot of empty heads crashing
14:05:27 <timthelion> mornfall: that's why you use a case...
14:05:46 <mornfall> timthelion: Well, only that if you already matched on the list it's totally redundant.
14:05:50 <avpx> You could easily define a head which never crashes, but it's a tradeoff.
14:05:52 <theadmin> mornfall: safeHead :: [a] -> Either String a; safeHead (a:_) = Right a; safeHead _ = Left "hint!"; -- no?
14:05:53 <mornfall> timthelion: And, what you put in the Nothing branch anyway?
14:06:34 <timthelion> mornfall: even if I type "error "empy list"" at least I as the programmer thought about it for more than 3 nanosecconds :)
14:06:38 <mornfall> Winding Maybe through everything is... tiresome, and probably more error prone.
14:06:59 <mornfall> timthelion: error "empty list" solves nothing. :-)
14:07:23 <timthelion> mornfall: except making me think twice before asking the head of a list.
14:07:40 <timthelion> actually, just yesterday, I found a crash in ghc from a head on an empty list.
14:07:51 <mornfall> Bummer. :-)
14:08:11 <mornfall> If everything was wrapped in a Maybe, you'd probably never find it in the mess. :-P :-P
14:09:07 <timthelion> mornfall: the real problem with Maybe is that it fucks with lazyness sometimes...  If you cannot tell if the function will return Nothing or a Just untill the end of the list, then the list must become strict.  So there is a preformance gain to simply crashing.
14:09:34 <timthelion> for example, take.
14:09:42 <mornfall> I still think there's also a readability gain to crashing.
14:09:51 <timthelion> would be a strict function rather than a lazy one, of it returned a Maybe
14:10:03 <mornfall> But, it would *really* help if it at least said which line crashed.
14:10:06 <timthelion> s/of/if/
14:10:16 <timthelion> it soo would :)
14:10:17 <iamtakingiteasy> hi, is it possible to make a haskell typeclass which automatically ineherits all instances of other typeclass, say (Num a)?
14:10:23 <timthelion> I just grep for head...
14:10:29 <mornfall> The precondition to head is that the list is non-empty.
14:10:41 <iamtakingiteasy> i mean, i am creating class BFDataStack and i want all (Num a) instances be part of my typeclass automatically
14:10:42 <mornfall> And if a precondition fails, it's reasonable to crash.
14:10:51 <luite> iamtakingiteasy: talk to mgsloan :p
14:10:59 <avpx> iamtakingiteasy: Unfortunately, you can't do something like instance Num a => BFDataStack
14:11:04 <timthelion> mornfall: maybe with McBrides new type system we could make EmptyList and NonEmptyList ...
14:11:08 <avpx> Erm, BFDataStack a
14:11:19 <mornfall> timthelion: You can in Agda, I presume. :-)
14:11:21 <iamtakingiteasy> :/
14:11:34 <danil> avpx: you can do that, you just can't define any other instances without overlapping that one
14:11:42 <avpx> danil: Err, right
14:11:47 <mornfall> timthelion: But the thing is, there are always going to be pre-conditions.
14:12:00 <latro`a> the solution is to wrap up the numbers in a newtype, yes?
14:12:00 <avpx> The issue is that it's the instance head (that is, the part after =>) that gets matched
14:12:07 <avpx> Yeah, that is the common solution
14:12:08 <mornfall> timthelion: And making everything give a Maybe is as about as useful as not having Maybe at all.
14:12:16 <mornfall> timthelion: Think about null references. :-)
14:12:29 <timthelion> null references?
14:12:34 <mornfall> timthelion: The Java Nothing.
14:12:46 <latro`a> instance Num a => BFDataStack (NumStack a) where
14:12:47 <latro`a> or such
14:12:50 <latro`a> will work
14:12:58 <timthelion> mornfall: there are a lot of functions that don't have an error condition.
14:13:08 <timthelion> it is usually not documented that they do.
14:13:08 <avpx> iamtakingiteasy: latro`a's solution is the common way to get around this
14:13:21 <timthelion> > take 3 []
14:13:22 <lambdabot>   []
14:13:34 <timthelion> oh, take doesn't error. that's weird.
14:13:41 <mornfall> timthelion: How's that weird?
14:13:50 <mornfall> timthelion: take is total, for one. :-)
14:14:08 <mornfall> Any list can be made at most N elements long.
14:14:33 <timthelion> mornfall: it's "take" not "clip"
14:14:49 <iamtakingiteasy> latro`a: errm, how (NumStack a) is defined ?
14:14:55 <mornfall> timthelion: Yeah, take at most N elements. :-)
14:15:03 <latro`a> newtype NumStack a = NumStack a
14:15:06 <timthelion> mornfall: this conversation is over :)
14:15:27 <avpx> iamtakingiteasy: You can also define an accessor function, like newtype NumStack a = NumStack { getNum :: a }
14:15:30 <latro`a> that too
14:15:33 <mornfall> Okey okey.
14:15:34 <Veinor> @djinn (a -> b -> c) -> b -> a -> c
14:15:35 <lambdabot> f a b c = a c b
14:15:38 <avpx> iamtakingiteasy: Then NumStack and getNum are inverses
14:24:59 <xplat> you know, it just figures that now that we have a package called 'lens' it is full of things that aren't lenses :)
14:26:59 <iamtakingiteasy> avpx: latro`a: thank you! got it working!
14:28:52 <avpx> iamtakingiteasy: Great :)
14:29:04 <latro`a> awesome
14:38:24 <xplat> clsmith: are you planning to compile haskell using a 'lazier than lazy' evaluation like complete laziness or optimal evaluation, or are the interaction nets just for 'boring' technical reasons?  :)
14:39:48 <clsmith> xplat: haha, yes, optimal reduction is the plan
14:58:41 <Lajla> @quote Kukka
14:58:41 <lambdabot> No quotes match. Wrong!  You cheating scum!
14:58:44 <Lajla> @quote Kukkua
14:58:44 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
14:58:53 <Lajla> Quite
14:58:56 <Lajla> I take that back
14:59:05 <Lajla> THere are three things, continuations, monads, and syntax-case
14:59:06 <srhb> What exactly causes Network to send fin/ack?
15:00:03 <shachaf> srhb: Network as in the GHC module?
15:00:07 <srhb> Yes.
15:00:50 <shachaf> I think that would be up to the OS to send.
15:01:06 <srhb> Eck. Why am I getting them all over the place. ._.
15:01:13 <srhb> I'll have a test on Linux instead.
15:02:06 <shachaf> srhb: FIN/ACK sounds like acknowledgement of FIN.
15:02:49 <srhb> Can't it also be acknowledgement of (something) and request to fin?
15:03:02 <srhb> Otherwise I'm getting out of order packets. o_O
15:03:43 <geekosaur> srhb, FIN+ACK is a response to FIN (i.e. close()/shutdown() for write)
15:03:54 <srhb> Alright. That is odd.
15:04:32 <shachaf> srhb: What OS are you using?
15:04:42 <srhb> shachaf: OS X
15:04:54 <srhb> I don't see any plain FIN packet in either direction, should I not have seen that before fin/ack?
15:05:16 <shachaf> srhb: Maybe you can use "dtruss" to see what network calls are actually being made.
15:05:28 <srhb> Oh I didn't know that tool, thanks, will check it out.
15:05:34 <geekosaur> you should have, yes.
15:05:44 <srhb> geekosaur: Then weirdness is afoot.
15:06:11 <geekosaur> something like iptraf or tcpflow might also be instructive
15:06:35 <srhb> I think that's what I'm getting from Wireshark?
15:08:53 <geekosaur> yes.  wireshark and tcpdump show you packets, they don't know or show much about how successive packets fit into a flowe
15:09:07 <srhb> Alright. :)
15:09:26 <geekosaur> tcpflow and iptraf follow circuits/connections; a FIN+ACK without a prior FIN will be pointed up as a protocol failure
15:10:05 <srhb> Great, I'll check them out as well :) Hopefull I can figure out what is going on.
15:11:23 <jfischoff> Would it be a good idea to make Multiplates for the Aeson Value datatype, for JSON modification?
15:12:39 <hpaste> gertc pasted ‚Äúcabal not working?‚Äù at http://hpaste.org/72627
15:13:45 <gertc> why does the configure tels me i need packages that i already have?
15:13:56 <geekosaur> gertc, add --user
15:14:15 <geekosaur> runhaskell Setup.lhs only considers global packages by default; cabal installs user packages by default
15:14:40 <geekosaur> better perhaps is "cabal install" in the package directory without a package name
15:14:47 <gertc> works :)
15:16:02 <gertc> so what nobody uses the Setup thing?
15:16:27 <gertc> just cabal install ... ?
15:17:23 <Peaker> gertc, cabal's bootstrapping does :)
15:18:41 <gertc> hmm confusing
15:18:44 <jfischoff> gertc: The Setup.hs is used if have special installation needs.
15:19:00 <gertc> like?
15:19:26 <geekosaur> also used to install bootstrap packages (installing the Platform from source, for example)
15:20:34 <jfischoff> gertc: the http://hackage.haskell.org/package/cabal-macosx package using it to perform dependency chasing of shared libraries and bundle into an OSX application bundle
15:21:01 <gertc> ok thx
15:21:37 <monochrom> cabal install does more
15:21:47 <gertc> rm -f Setup.hs :)
15:22:21 <monochrom> cabal install may call up Setup.hs
15:22:43 <gertc> doh!
15:22:48 <jfischoff> yeah
15:23:41 <jfischoff> I wonder if it will regenerate it ...
15:23:45 <xplat> no
15:24:02 <monochrom> there is real information loss
15:24:08 <xplat> cabal init might, cabal install won't.
15:24:15 * jfischoff nods
15:26:58 * roconnor broke hackage.haskell.org
15:27:10 <monochrom> achievement unlocked!
15:27:15 <roconnor> w00t
15:27:17 <hpaste> gertc annotated ‚Äúcabal not working?‚Äù with ‚Äúcabal not working? (annotation)‚Äù at http://hpaste.org/72627#a72628
15:27:57 <monochrom> I don't think "cabal install chat.cabal" is the right syntax
15:28:29 <monochrom> I guess it is right
15:28:48 <donri> gertc: do you have a src dir?
15:29:42 <Igloo> roconnor: Hmm?
15:29:43 <monochrom> yeah, where do you put Server.hs?
15:30:03 <gertc> donri, https://github.com/gertcuykens/haskell-design
15:30:03 <roconnor> Igloo: I was uploading a new multiplate when it died
15:30:09 <Igloo> what died?
15:30:29 <roconnor> oh it is back
15:30:34 <monochrom> well then there is no Server.hs
15:31:37 <ReinH> roconnor: did you try to upload your godel proof?
15:31:59 <ReinH> there's a joke here somewhere with uncomputable numbers
15:32:00 <roconnor> ReinH: :D nope
15:32:13 <xplat> roconnor: so how do multiplates compare to multilenses/traversals?
15:32:19 <ReinH> or possibly decidability
15:32:28 <roconnor> xplat: they are multisorted traversals
15:32:42 <monochrom> or rather "other-modules: Db Server Login Server" contains a lot of junk
15:32:52 <roconnor> xplat: they are multisorted non-family traversals
15:32:56 <ReinH> oh ofc. roconnor: did you accidentally make hackage try to solve the halting problem?
15:33:08 <monochrom> and missing "Chat"
15:33:12 <xplat> roconnor: aha
15:33:23 <edwardk> hahahahaha
15:34:15 <Taneb> edwardk, I'm really struggling to grasp the lens package
15:34:27 <Taneb> But that may be because I only try after 10 pm?
15:34:28 <ReinH> Taneb: welcome to the club :)
15:34:31 <roconnor> ReinH: http://tachyos.org/godel/Godel_number.html
15:34:47 <edwardk> ghci> traverseGeneric (\x -> x <$ putStrLn x) ("hello",[(2 :: Int, "world!")])    prints "hello" and "world"
15:34:50 <edwardk> =)
15:35:02 <xplat> i wondered why one might be more useful than the other for json values
15:35:03 <ReinH> I think one issue is Control.Lens's representation of (iirc) setter <$> getter vs a more simple representation
15:35:39 <Taneb> edwardk, congratulations. You've invented the new Monad
15:35:44 <edwardk> Taneb: have you looked at the overview on http://hackage.haskell.org/package/lens
15:35:46 <edwardk> ?
15:35:49 <Taneb> Tried to
15:35:51 <xplat> ReinH: Control.Lens's representation is actually very simple, it's just not obvious
15:36:08 <ReinH> xplat: yes, please replace accordingly above ;)
15:36:25 <ReinH> once I figured it out I was able to compose a lens pretty easily though
15:36:36 <ReinH> so yes, it is simple
15:36:40 <ReinH> and also yes, it is non-obvious :)
15:36:45 <Taneb> I see how the getters work
15:36:51 <ReinH> especially if you don't have a great intuition for applicatives
15:37:04 <xplat> edwardk: it's probably pretty intimidating to most people to have the first explanation include 'oh, this is just a function, but we CPS it and wrap the return value in an identity functor'
15:37:07 <Taneb> I'm not really comfortable with the rampant polymorphism
15:37:13 <xplat> er, a const functor
15:37:16 <edwardk> xplat: well, we wrap it in const
15:37:22 <ReinH> Taneb: maybe start with Simple Lens then
15:37:39 <Taneb> ReinH, I'm used to data-lens
15:37:39 <edwardk> and actually i wrap that in another identity and then in a 'act' for monad/functor composition ;)
15:37:44 <gertc> aha i think i got it :)
15:37:52 <xplat> whew, i really had to rush that through to correct myself before being corrected :)
15:37:58 <Taneb> Hackage seems really slow for me
15:38:07 <ReinH> xplat: just barely too
15:38:22 <edwardk> xplat: in the article i'm writing i start with the signature of traverse
15:38:42 <ReinH> xplat: in fact given that irc isn't order guaranteed he could well have corrected you first :p
15:38:42 <edwardk> and then i look at fmapDefault, and replace 'traverse' in that definition with a function argument
15:38:54 <edwardk> and then do the same with foldMapDefault
15:39:08 <ReinH> edwardk: yes please write more articles :)
15:39:10 <edwardk> that gives me the signatures of Setter and Fold directly from traverse
15:39:18 <ReinH> edwardk: and do try to dumb some of them down a bit ;)
15:39:22 <edwardk> and the type of something i can pass to both of those is a traversal
15:39:59 <edwardk> then it comes back to cpsing the function, and a lens is something that can be used as a cps'd function or traversal
15:40:15 <edwardk> and finally isomorphisms and actions
15:40:22 <edwardk> (and indexed traversals)
15:40:42 <edwardk> actions require you to go back and edit all the type signatures you've figured out though
15:42:47 <A1kmm> Is the result of this a bug in abs? (abs (0x8000 :: Int16))
15:44:35 <Peaker> edwardk, ^~ and <~ are the same function? when is one to be used rather than the other?
15:44:46 <Peaker> hmm, and "set" too
15:44:50 <edwardk> they are both being replaced with .~
15:44:51 <edwardk> ;)
15:45:12 <edwardk> set is useful because its a ternary function so it curries better when partially applied
15:45:21 <xplat> so now all that remains is to use lens to create a proper option/configfile system
15:45:35 <monochrom> > 0x8000 :: Int16
15:45:36 <lambdabot>   -32768
15:45:48 <Peaker> edwardk, hmm.. Why (.~)?  I personally preferred <~, that read nicely
15:45:58 <edwardk> because <~ has a nicer purpose ;)
15:46:06 <edwardk> and .~ and .= work
15:46:08 <monochrom> > abs (0x8000 :: Int16)
15:46:09 <lambdabot>   -32768
15:46:10 <edwardk> with less hand strain
15:46:22 <edwardk> well not than <~, but the .= is better than ^=
15:46:26 <Veinor> edwardk: I want to learn more about lenses; is there a paper or something I should look at?
15:46:34 <edwardk> and the = ~ equivalence is maintained
15:46:36 <t7> monochrom: you broke haskell?
15:46:52 <edwardk> Veinor: the mirrored lenses post, and i'm working on an article
15:46:54 <monochrom> I think it can't be helped. there is no "correct" answer
15:47:04 <Peaker> edwardk, kinda hard for me to remember the operator names.. any glossary?
15:47:06 <t7> > 0x8000 :: Word16
15:47:07 <lambdabot>   32768
15:47:13 <edwardk> Peaker: <~ is being repurposed to write to a setter with a monadic action inside of a state monad
15:47:19 <edwardk> Peaker: it winds up really elegant
15:47:22 <shachaf> > abs (-32768) :: Int16
15:47:23 <lambdabot>   -32768
15:47:31 <avpx> Hmm, yeah, abs should always yield the positive representation if it exists.
15:47:33 <avpx> That's interesting
15:47:39 <edwardk> because you can go and replace do x <- foo    with do x <~ foo  --- when x is a lens
15:47:42 <Veinor> > 32768 :: Int16
15:47:43 <lambdabot>   -32768
15:48:09 <t7> yes! now we can finaly make a WTF haskell video like that WTF javascript one
15:48:11 <Peaker> edwardk, yeah, that's cute.. though I think having multiple operators with identical meanings is probably bad.. canonicalization is good, I think
15:48:16 <Veinor> positive 32768 has no 16-bit representation
15:48:18 <edwardk> yes
15:48:23 <ion> > [abs (-0x7e), abs (-0x7f), abs (-0x80)] == ([0x7e, 0x7f, 0x80] :: Int8)
15:48:24 <lambdabot>   Couldn't match expected type `GHC.Int.Int8'
15:48:25 <lambdabot>         against inferred type `...
15:48:31 <edwardk> i'm killing the <~ ^~ pun by fusing them into .~
15:48:35 <ion> > [abs (-0x7e), abs (-0x7f), abs (-0x80)] == ([0x7e, 0x7f, 0x80] :: [Int8])
15:48:36 <lambdabot>   True
15:48:42 <ion> > [0x7e, 0x7f, 0x80] :: [Int8]
15:48:43 <broombs> anyone else experiencing delays/failures in Hackage?
15:48:43 <lambdabot>   [126,127,-128]
15:48:47 <ion> That‚Äôs the only way that makes sense.
15:48:50 <edwardk> i'm keeping 'set' though
15:49:06 <edwardk> view and (^$) do the same thing
15:49:10 <Peaker> how do you lift a SEC to a setter?
15:49:13 <monochrom> I guess it's time to...
15:49:16 <edwardk> SEC?
15:49:17 --- mode: ChanServ set +o monochrom
15:49:18 <edwardk> oh
15:49:23 <edwardk> semantic editor combinator
15:49:25 <Peaker> edwardk, yeah
15:49:28 <edwardk> :t (.).(.)
15:49:30 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:49:30 <Taneb> A 500 error?
15:49:34 <Taneb> :(
15:49:36 <edwardk> should be 'sets'
15:49:43 --- topic: set to '["hackage down", "Identify with NickServ to speak","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
15:49:54 <Taneb> Oh, that explains the server error
15:49:57 <edwardk> ghci> :t sets $(.).(.)
15:49:57 <edwardk> sets $(.).(.) :: Setter (a -> a1 -> c) (a -> a1 -> d) c d
15:50:23 <A1kmm> Okay, thanks, I want saturation but I'll just make my own version of abs that does it.
15:50:50 <t7> to whom do i send donations too for running hackage?
15:51:05 <roconnor> Peaker: the old <~ is slated for lens-families :D
15:51:06 <edwardk> t7: haskell.org  or the industrial haskell group
15:51:14 <edwardk> haskell.org runs infrastructure
15:51:19 <edwardk> IHG funds development mostly
15:51:30 <monochrom> I think hackage being down is a bug rather than lack of money
15:52:02 <edwardk> t7: the best donation approach at this point would probably be to go to SPI's website and make a donation tagged for haskell.org (they hold our money)
15:52:31 <Urthwhyte> so if hackage is down did I pick a bad weekend to start playing around with Haskell seriously?
15:52:32 <alpounet> edwardk, is that also where the money from GSoC goes?
15:52:37 <edwardk> yep
15:52:45 <edwardk> Urthwhyte: yes
15:52:46 <alpounet> ok cool (i guess?)
15:52:52 <Urthwhyte> bummer :(
15:53:05 <edwardk> alpounet: it keeps us in the green
15:53:25 <Peaker> translating a large code base to use lens is going to take a while :P
15:53:46 <edwardk> Peaker: =)
15:53:54 <Taneb> Will cabal work if Hackage is down?
15:53:58 <edwardk> i'm working over the snap guys here at hac phi ;)
15:54:06 <edwardk> talk about large code bases
15:54:11 <Peaker> edwardk, How large is it?
15:54:18 <alpounet> Taneb, nope
15:54:18 <roconnor> Taneb: cabal-install will not work without referencing a backup hacakge
15:54:28 <alpounet> although you can use the factis research mirror i guess
15:54:32 <Taneb> :(
15:54:36 <edwardk> (they say the lens usage isn't that bad)
15:54:40 <Peaker> edwardk, I want to translate bottle, ~7.5KLOC
15:54:44 <edwardk> ah
15:54:46 --- mode: monochrom set -o monochrom
15:55:00 <Peaker> edwardk, firstly to get rid of our own TH hack for field SECs
15:55:11 <edwardk> *nods*
15:55:13 <ReinH> monochrom: I think roconnor broke it when he pushed his new control-skynet package
15:55:18 <ReinH> I'm sure it's nothing to worry about
15:55:25 <edwardk> yeah i can see how that would be handy
15:55:28 <Peaker> edwardk, but as I do so I find nice opportunities to make things nicer, but for now in order to do it incrementally, I have lots of ugly stuff like:  (myField ^$) . fst . ...
15:55:33 <monochrom> oh I don't worry about it
15:55:46 <edwardk> Peaker: view myField . fst
15:55:52 <srhb> Did hackage die again?
15:55:56 <ReinH> monochrom: I for one welcome my new Haskell overlords
15:56:01 <Peaker> edwardk, ah, nice :)
15:56:11 <edwardk> thats why i have those named puns
15:56:15 <Peaker> edwardk, though it would be nicer to translate everything else to be a lens, rather than coerce the lens back into a function
15:56:19 <edwardk> sure
15:56:39 <edwardk> snaplet code seems to be ~4600 lines per mightybhte
15:56:44 <edwardk> er mightybyte even
15:56:44 <Taneb> Well, I'm going to take this opportunity to sleep while Hackage comes back up
15:57:03 <Peaker> edwardk, mightybyte? I use "cloc" which counts code lines without blanks/comments
15:57:25 <edwardk> Peaker: well, i just asked him and he rattled off a number, avoided me having to do it. ;)
15:57:34 <edwardk> he has a very intuitive user interface
15:58:48 <srhb> In goes food and beer, out goes information?
15:59:30 <srhb> One of the few true standards in this world.
16:06:10 <Peaker> edwardk, I convert lens back to SECs similarly, via an infix section with (%~) which is ugly
16:06:14 <Peaker> edwardk, any way to do that nicer?
16:06:34 <Peaker> Something like:  atThisAndThat . (Vector2.first %~)
16:07:01 <roconnor> Peaker: sec = (%~)
16:07:26 <Peaker> roconnor, where is that defined?
16:07:32 <roconnor> Peaker: in your module :P
16:07:35 <Peaker> oh, heh
16:07:37 <Peaker> too many modules
16:07:47 <Peaker> would be nicer to have it come from Lens
16:08:00 <roconnor> proj = flip (^.)
16:08:11 <roconnor> I guess I could add these to lens-families
16:08:55 <roconnor> project maybe is better
16:11:13 <gertc> it works weeeee :)
16:18:36 <gertc> is hws recommended for static files only?
16:20:27 <xORioN63> hey. I'm new to Haskell, and well...type classes are in the way? Would you kindly explain them to me, or indicate a good resource...
16:21:17 <JoeyA> > maxBound - minBound :: Int
16:21:18 <lambdabot>   -1
16:21:45 <JoeyA> Does Haskell have well-defined behavior when doing arithmetic on signed integers (including CInt and Int32 and such) ?
16:21:52 <JoeyA> Or is overflow undefined, like in C?
16:22:08 <alpounet> xORioN63, have you read http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101 ?
16:22:17 <mikeplus64> xORioN63: an abridged explanation is that type classes are groups of functions with different definitions but the same types and names
16:22:42 <mikeplus64> xORioN63: for instance, 'map' for lists is defined differently for 'map' for arrays
16:22:48 <xORioN63> alpounet: yep, using that tutorial
16:22:57 <mikeplus64> differently to*
16:22:59 <JoeyA> More specifically, can I assume Int32 or Int64 arithmetic is modulo 2^whatever like I can with the unsigned variants?
16:23:12 <alpounet> xORioN63, the explanations there were not sufficient?
16:23:41 <notthemessiah> xORioN63: www.haskell.org/haskellwiki/Typeclassopedia
16:24:07 <xORioN63> alpounet: not really :P, I think I understand what they are, which I'm confirming with mikeplus64 answer, but why do you use them?
16:24:12 <ktvoelker> JoeyA: http://www.haskell.org/onlinereport/haskell2010/haskellch18.html#x26-22400018.1
16:24:37 <JoeyA> Awesome, thanks.
16:24:45 <alpounet> xORioN63, what's your programming background?
16:24:46 <JoeyA> Also, in Data.Int, it says: "All arithmetic is performed modulo 2^n, where n is the number of bits in the type."
16:24:52 <xORioN63> alpounet: Python
16:24:57 <alpounet> i'll illustrate with stuffs you already know, will be easier
16:25:43 <mikeplus64> xORioN63: convenience and polymorphism are probably the motivating factors
16:25:50 <mikeplus64> > sizeOf (1::Int)
16:25:51 <lambdabot>   Not in scope: `sizeOf'
16:26:01 <mikeplus64> derp
16:26:04 <alpounet> alright xORioN63 do you see how virtual functions let you have different implementations depending on the derived class they're in?
16:26:31 <xORioN63> alpounet: yes
16:26:35 <alpounet> it's a bit the same with typeclasses
16:26:59 <alpounet> type classes are used when you want to introduce some variability depending on the types that are concerned in the function call
16:27:30 <alpounet> there are a bunch of significant differences
16:27:45 <mikeplus64> > isSigned (0 :: Int)
16:27:47 <lambdabot>   True
16:27:50 <mikeplus64> > isSigned (0 :: Word8)
16:27:52 <lambdabot>   False
16:28:04 <mikeplus64> xORioN63: in instances like these typeclasses are very convenient
16:28:43 <alpounet> xORioN63, for example, Eq is a typeclass that represents the concept of being able to compare for... yes, you guessed it, equality. obviously, there isn't a single implementation that will work for all types
16:29:18 <xORioN63> hm, I'm getting there
16:29:42 <xORioN63> could you please explain this to me
16:29:43 <xORioN63> http://pastebin.com/U3tEBnsr
16:29:47 <mauke> The paste U3tEBnsr has been copied to http://hpaste.org/72629
16:30:34 <xORioN63> I was trying to make a function from 99_questions, and well, I have no idea why do you use them there
16:30:56 <geekosaur> xORioN63, pattern matching against a literal number requires  Num constraint.  Numeric literals are somewhat strange in Haskell
16:31:03 <alpounet> xORioN63, alright, so here, the type of your index is "whatever type thats an insance of the Num typeclass"
16:31:29 <alpounet> because of what geekosaur said and because of the "i-1" you wrote there
16:31:45 <geekosaur> it gets translated into a guard doing a (==) against the literal numver which is secretly an applcation of the fromIntegral function
16:31:46 <slack1256> hackage seems down.
16:31:57 <alpounet> however, in the second version of your function, you tell the compiler "the index type can really be any type"
16:32:00 <alpounet> with no constraint
16:32:05 <xORioN63> so, whenever I need to use a function specific to a type I need to call that typeclass?
16:32:10 <alpounet> and well, GHC is right to disagree with you there :)
16:32:26 <alpounet> xORioN63, specific to a typeclass, you meant?
16:32:43 <xORioN63> maybe? :P
16:32:47 <xORioN63> probably
16:33:12 <xORioN63> right, I think I got it
16:33:18 <xORioN63> thanks ;)
16:33:23 <alpounet> xORioN63, you have to understand a bit how GHC infers the types
16:33:46 <alpounet> any constraint that arises in your code (using ==, +, show, etc)
16:33:54 <alpounet> will be "propagated"
16:34:14 <xORioN63> hm, ok
16:34:34 <alpounet> for example, what type would "f x y = if x == y then x+1 else y-1" have?
16:35:36 <xORioN63> ::(Num x y) => x -> y
16:35:39 <xORioN63> something like this?
16:36:09 <xORioN63> forgot the result
16:36:36 <mauke> (Num a, Eq a) => a -> a -> a
16:37:01 <xORioN63> isn't Num a member of eq?
16:37:07 <mauke> wat
16:37:13 <alpounet> alright, it's not really fair here because Eq and Num are somewhat related, so the Eq constraint "disappears" (is contained in the "Num" constraint actually)
16:37:29 <mauke> alpounet: I hear that bug is fixed in newer ghcs
16:37:47 <roconnor> mauke: it is
16:38:05 <xORioN63> I'm confused
16:38:06 <alpounet> mauke, it is, but not in 7.0.x iirc
16:38:09 <alpounet> anyway
16:38:15 <alpounet> xORioN63, alright, simpler
16:38:35 <alpounet> xORioN63, what's the type of: f x = x+1
16:38:54 <xORioN63> (Num a) => a -> a
16:39:07 <mauke> f x y = x + y
16:39:31 <xORioN63> (Num a) => a -> a -> a
16:40:13 <alpounet> xORioN63, what about: f x y = if x < y then x+1 else y+1?
16:40:53 <xORioN63> (Num a, Ord a) => a -> a -> a
16:41:11 <alpounet> now suppose i have a typeclass like
16:41:20 <monochrom> Num is no longer related to Eq
16:41:32 <shachaf> monochrom: Unless you believe the report...
16:41:32 * slack1256 wonders if there is an graph with the current situation of typeclasses.
16:41:36 <shachaf> f x = f x + 1
16:41:45 <alpounet> class Fooable a where toFoo :: a -> Foo
16:42:02 <slack1256> shachaf: are the developers going to change the report?
16:42:04 <alpounet> where Foo is a dumb type i have in my project
16:42:16 <shachaf> slack1256: You don't "change" the report.
16:42:20 <monochrom> right, it's a rather recent change
16:42:22 <shachaf> You make a new report.
16:42:27 <slack1256> shachaf: :O
16:42:37 <alpounet> so now xORioN63, what's the type of: f x = let y = x+1 in toFoo y
16:43:01 <monochrom> you can use a slightly older compiler to regain Eq for Num :)
16:43:39 <xORioN63> ::(Num a, Fooable a) -> a -> Foo
16:43:41 <xORioN63> ?
16:43:53 <alpounet> replace the first -> by =>
16:43:58 <xORioN63> right
16:44:00 <alpounet> and it's all good :)
16:44:12 <xORioN63> thanks ;)
16:44:17 <alpounet> i think you got the basics of typeclasses
16:44:24 <xORioN63> one more thing
16:44:30 <monochrom> oh, hackage seems to be up
16:44:34 --- mode: ChanServ set +o monochrom
16:44:34 <alpounet> so this lets you write code that is generic in the types of values you can pass it
16:44:42 --- topic: set to '["Identify with NickServ to speak","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
16:44:47 --- mode: monochrom set -o monochrom
16:44:52 <shachaf> thonochrom
16:44:56 <xORioN63> in 'learn you a haskell' it says "To be a member of Ord, a type must first have membership in the prestigious and exclusive Eq club."
16:45:12 <alpounet> ah alright xORioN63
16:45:22 <alpounet> typeclasses can be related between each other
16:45:25 <xORioN63> does that mean that if I want use for example (<) and (==) I can just use the ord typeclass
16:45:31 <monochrom> yes
16:46:05 <xORioN63> and why isn't Num no longer related to Eq?
16:46:19 <shachaf> Num *is* no longer related to Eq.
16:46:35 <monochrom> a committee discussed and decided it
16:46:39 <xORioN63> ahah sorry about that
16:47:56 <xORioN63> hm, ok
16:48:07 <xORioN63> thank you all
16:48:36 <slack1256> xORioN63: go out a hack some great code.
16:51:56 <Cale> xORioN63: the reason that Num isn't related to Eq anymore is that there are plenty of good Num instances for which Eq doesn't make sense, because equality isn't computable for one reason or another, even though arithmetic operations can be defined.
16:52:42 <xORioN63> oh, the old floating point problem?
17:04:54 <roconnor> xORioN63: more like functions
17:05:20 <shachaf> It's true that Eq doesn't make *too* much sense on floating point numbers. :-)
17:05:31 <roconnor> > (1 + id) 6
17:05:33 <lambdabot>   7
17:05:48 <shachaf> Also CReal.
17:05:48 <roconnor> > (id + id) 6
17:05:50 <lambdabot>   12
17:06:24 <ion> Eq makes perfect sense on anything that can be represented in bits, it just might not be the most useful kind of equality depending on your purposes. :-P
17:06:56 <ion> > (0/0) == (0/0)  -- although‚Ä¶
17:06:57 <lambdabot>   False
17:07:18 <mapreduce> > 1 + id
17:07:20 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:07:20 <lambdabot>    arising from a use of `...
17:07:23 <roconnor> ion: PERs are nice; even nicer than Setoids
17:07:34 <mapreduce> :t 1 + id
17:07:36 <lambdabot> forall a. (Num a) => a -> a
17:07:58 <mapreduce> Is that something lambdabot-specific?
17:08:25 <ion> @hackage NumInstances  -- mapreduce
17:08:26 <lambdabot> http://hackage.haskell.org/package/NumInstances  -- mapreduce
17:08:57 <ion> > (sin^2 + cos^2) 42 :: CReal
17:08:58 <lambdabot>   1.0
17:09:33 <shachaf> > ((sin^2 + cos^2) 42 :: CReal) == 1
17:09:34 <lambdabot>   True
17:10:00 <ion> > (sin^2 + cos^2) 42
17:10:01 <lambdabot>   1.0
17:10:03 <ion> > (sin^2 + cos^2) 42 == 1
17:10:04 <lambdabot>   True
17:10:11 <ion> Oh, cool
17:10:32 <roconnor> > 1 + 0.00000000000000000000000000001 == (1 :: CReal)
17:10:34 <lambdabot>   False
17:10:41 <roconnor> > 1 + 0.000000000000000000000000000000000000000000000000000000000001 == (1 :: CReal)
17:10:41 <shachaf> > (sin^2+cos^2)==1
17:10:42 <lambdabot>   *Exception: (==): No overloading for function
17:10:42 <lambdabot>   can't find file: L.hs
17:10:59 <roconnor> > 1 + 0.000000000000000000000000000000000000000000000000000000000001 == (1 :: CReal)
17:11:00 <lambdabot>   True
17:11:25 <ville> Don't know if it's been mentioned. Haskell mention by Carmack at quakecon 2012 keynote. FWIW. Someone might find it fun.
17:11:32 <ion> roconnor: ‚Äú1e-60‚Äù
17:11:58 <ion> ville: Thanks, i‚Äôll have to check it out.
17:12:22 <ion> I take it you don‚Äôt have a link closer than i do?
17:12:29 <ville> I do hold s ec
17:12:34 <alpounet> http://www.youtube.com/watch?v=wt-iVFxgFWk
17:12:42 <ion> Thankes.
17:12:45 <ville> http://www.youtube.com/watch?v=-_xhuHTMspY at around 33:40 ish
17:13:32 <ville> probably worth listening 2 or 3 minutes before anyway to ge the context
17:14:22 <augur> > fix (\x -> 1 + 1/x)
17:14:27 <lambdabot>   mueval-core: Time limit exceeded
17:14:30 <augur> hmm
17:14:47 <augur> is there a way to get some of that out?
17:15:07 <ville> anyway carry on, thought it might be of interest to some.
17:15:26 <alpounet> augur, with iterate i guess
17:15:35 <alpounet> doing some continued fractions?
17:15:40 <augur> its phi :)
17:15:48 <augur> iterate huh
17:15:50 <alpounet> yup
17:15:53 <augur> :t iterate
17:15:55 <lambdabot> forall a. (a -> a) -> a -> [a]
17:15:55 <ion> > let go f x | x' == x = x' | otherwise = f x' where { x' = f x } in fix (go (\x -> 1 + 1/x))
17:15:59 <lambdabot>   mueval-core: Time limit exceeded
17:16:07 <ion> meh
17:16:29 <ion> (Duh, of course that doesn‚Äôt work.)
17:16:29 <augur> > take 10 $ iterate (\x -> 1 + 1/x) 1
17:16:31 <lambdabot>   [1.0,2.0,1.5,1.6666666666666665,1.6,1.625,1.6153846153846154,1.619047619047...
17:16:54 <ion> > let go f x | x' == x = x' | otherwise = f x' where { x' = f x } in go (\x -> 1 + 1/x) 42
17:16:56 <lambdabot>   1.9767441860465116
17:16:58 <augur> > take 10 $ drop 10 $ iterate (\x -> 1 + 1/x) 1
17:17:00 <lambdabot>   [1.6179775280898876,1.6180555555555556,1.6180257510729614,1.618037135278514...
17:17:28 <augur> > take 10 $ iterate (\x -> 1 + 1/x) 2
17:17:30 <lambdabot>   [2.0,1.5,1.6666666666666665,1.6,1.625,1.6153846153846154,1.619047619047619,...
17:18:16 <augur> > take 10 $ iterate (\x -> 1 + 1/x) 0.1
17:18:17 <lambdabot>   [0.1,11.0,1.0909090909090908,1.9166666666666667,1.5217391304347827,1.657142...
17:18:29 <augur> hm. interesting
17:18:38 <alpounet> continued fractions converge very quickly
17:18:47 <augur> seems so!
17:18:50 <augur> > take 10 $ iterate (\x -> 1 + 1/x) 100
17:18:52 <lambdabot>   [100.0,1.01,1.99009900990099,1.5024875621890548,1.6655629139072847,1.600397...
17:18:58 <augur> wow, look at that
17:19:06 <ion> The ‚Äútake 10‚Äù is redundant with lambdabot.
17:19:14 <augur> ion: o tru
17:19:30 <alpounet> augur, i can dig up the book i've learned about them with if you want
17:19:44 <augur> alpounet: nah, im just messing around
17:19:54 <alpounet> alright
17:19:59 <augur> actually sure, why not
17:20:02 <ion> > let go f x | x' == x = x' | otherwise = f x' where { x' = f x } in go (\x -> 1 + 1/x) 1 == go (\x -> 1 + 1/x) 1e6
17:20:03 <lambdabot>   False
17:20:08 <alpounet> there are crazy stuffs they are related to
17:20:11 <augur> > iterate (\x -> 1 + 1/x) 1 !! 20
17:20:12 <lambdabot>   1.618033985017358
17:20:30 <ion> > let go f x | x' == x = x' | otherwise = f x' where { x' = f x } in [go (\x -> 1 + 1/x) 1, go (\x -> 1 + 1/x) 1e6]
17:20:32 <lambdabot>   [1.5,1.999999000001]
17:20:43 <nand`> > (1 + sqrt 5)/2
17:20:44 <lambdabot>   1.618033988749895
17:21:16 <ion> Whoops, a stupid bug in ‚Äúgo‚Äù.
17:21:35 <ion> > let go f x | x' == x = x' | otherwise = go f x' where { x' = f x } in [go (\x -> 1 + 1/x) 1, go (\x -> 1 + 1/x) 1e6]
17:21:37 <lambdabot>   [1.618033988749895,1.618033988749895]
17:21:46 <augur> also
17:21:49 <augur> anyone seen ski?
17:24:25 <xORioN63> could anyone see, why this gives an error? http://pastebin.com/hbS08uKj
17:24:27 <mauke> The paste hbS08uKj has been copied to http://hpaste.org/72630
17:24:55 <alpounet> augur, alright, i think it was the Hardy & Wright, "An introduction to the Theory of Numbers"
17:25:02 <ion> I fail to see the error message in your paste.
17:25:31 <xORioN63> wait a sec
17:25:55 <nand`> xORioN63: works for me
17:26:15 <xORioN63> http://pastebin.com/krgUbq91
17:26:17 <mauke> The paste krgUbq91 has been copied to http://hpaste.org/72631
17:26:23 <xORioN63> really?
17:26:26 <xORioN63> that's weird
17:26:42 <nand`> oh
17:26:43 <xORioN63> works only on lists
17:26:45 <nand`> your type sig
17:26:47 <xORioN63> not on strings
17:26:52 <nand`> :: (Num b) => [a] -> b
17:27:19 <nand`> you have ‚Äòa‚Äô in both places, so as a result you can only apply it to numeric lsits
17:27:38 <xORioN63> oh, ok
17:28:31 <jfischoff> is there Template Haskell magic for deriving instances for mulitplate?
17:28:34 <xORioN63> thanks
17:30:23 * hackagebot multiplate 0.0.2 - Lightweight generic library for mutually recursive data types. (RussellOConnor)
17:30:25 * hackagebot jmacro-rpc 0.1 - JSON-RPC clients and servers using JMacro. (GershomBazerman)
17:30:27 * hackagebot NXT 0.2.2 - A Haskell interface to Lego Mindstorms NXT (MitarMilutinovic)
17:46:01 <MagneticDuck> lessee..
17:46:28 <copumpkin> lessor!
17:46:45 <MagneticDuck> what's the code to turn a list of functions a -> m a (m being a monad) named [a, b, c..] into {do a; b; c;..}
17:46:47 <MagneticDuck> lol
17:46:52 <MagneticDuck> well
17:46:59 <latro`a> sequence?
17:47:02 <latro`a> erm
17:47:04 <latro`a> sequence_
17:47:09 <MagneticDuck> aah
17:47:11 <copumpkin> nope
17:47:13 <latro`a> though that's not what you actually meant
17:47:19 <copumpkin> :t foldr (>=>) return
17:47:20 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
17:47:25 <latro`a> but you can't do "do {a;}" if a has that type
17:47:26 <MagneticDuck> !
17:47:29 <copumpkin> yeah
17:47:32 <MagneticDuck> yeah
17:47:34 <MagneticDuck> I was going to say
17:47:36 <latro`a> yeah, >=> is what you meant
17:47:42 <MagneticDuck> >=>?
17:47:43 <dmj> does anyone know why ghci wouldn't be working on mountain lion? "ghc: could not execute: /usr/bin/gcc"
17:47:47 <MagneticDuck> @src >=>
17:47:48 <lambdabot> Source not found. You type like i drive.
17:47:53 <MagneticDuck> >:|
17:47:57 <latro`a> f >=> g = \x -> f x >>= g
17:47:59 <ion> Because it could not execute /usr/bin/gcc.
17:48:23 <dmj> i thought all macs came with gcc
17:48:25 <latro`a> this can also be considered a primitive, as the Kleisli composition operator
17:48:40 <latro`a> that is, the thing you use to compose a->m b and b->m c to get a->m c
17:48:41 <dmj> :ion isn't gcc the C++ compiler?
17:48:52 <latro`a> no
17:48:52 <MagneticDuck> mhm
17:48:55 <latro`a> that's g++
17:49:08 <MagneticDuck> ..?
17:49:16 <latro`a> gcc is a C compiler
17:49:26 <MagneticDuck> General C Compiler
17:49:33 <latro`a> is it General or GNU?
17:49:34 <ion> ‚ÄúGeneral‚Äù?
17:49:36 <MagneticDuck> arr
17:49:37 <MagneticDuck> Gnu
17:49:39 <MagneticDuck> Gnu
17:49:41 <shachaf> GNU Compiler Collection
17:49:46 <nand`> ^
17:49:49 <MagneticDuck> oh
17:49:50 <adnam> macs don't come with gcc, you need the developer tools
17:49:51 <latro`a> indeed, I was mistaken, it's not just a C compiler
17:49:55 <ion>        gcc - GNU project C and C++ compiler
17:49:57 <MagneticDuck> ahah
17:50:00 <dmj> I have xcode installed though
17:50:05 <latro`a> C++ too?
17:50:20 <geekosaur> since 4.2 the standalone compilers are a separate download from Xcode
17:50:38 <adnam> oh right
17:50:38 <geekosaur> you can get it from Preferences > Downloads, or download the Command Line Utilities from connect.apple.com
17:50:42 <latro`a> btw, MagneticDuck, m >>= f = (const m) >=> f ()
17:50:55 <latro`a> (the () is just an arbitrary choice, you can put any value whatsoever there)
17:51:07 <MagneticDuck> @type >=>
17:51:08 <lambdabot> parse error on input `>=>'
17:51:10 <ion> (const m >=> f) ()
17:51:13 <geekosaur> (if you don;t need the GUI you may be able to skip Xcode entirely and just download the CLU package)
17:51:13 <dmj> oh, it looks like when I upgraded to Mountain Lion it removed the command line tools
17:51:14 <MagneticDuck> @type (>=>)
17:51:15 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:51:24 <latro`a> gah, what ion said, yeah
17:51:27 <geekosaur> yes, the ones for lion don't work right on ML
17:51:30 <latro`a> infix stuff throws me off occasionally
17:51:49 <latro`a> there is also a <=<, which goes in the usual function composition order
17:51:53 <latro`a> (i.e. right to left)
17:52:29 <latro`a> hrm, is there a "newbie's explanation" of monads via >=>/return?
17:53:00 <dmj> ok, ghci is working again
17:53:02 <dmj> thanks guys
17:53:11 <MagneticDuck> @type foldl (>=>)
17:53:12 <latro`a> (just curious; if there isn't I might be interested to write one, to fill the tiny niche of "mathematicians interested in haskell who don't know any category theory")
17:53:12 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m c) -> [c -> m c] -> a -> m c
17:53:26 <ion> The ‚Äúnewbie‚Äôs explanation‚Äù of monads should start with functors and continue with applicative functors.
17:53:32 <latro`a> sure
17:53:52 <latro`a> but that also depends on your level of background, there's a small niche that would probably appreciate Kleisli composition with its identity
17:54:00 <ion> Also, another monad tutorial is always great, preferably with food-related analogies.
17:54:04 <latro`a> without needing extra context
17:54:05 <nand`> ion: doesn't LYAH do this? or does it have monads before applicatives?
17:54:18 <MagneticDuck> it has monads after applicatives
17:54:21 <latro`a> it sorta does, but it bends towards practicality a little bit
17:54:22 <MagneticDuck> after functors
17:54:25 <latro`a> and so it introduces IO before monads
17:54:29 <MagneticDuck> yeah
17:54:53 <MagneticDuck> which often makes newbies believe "do" notation is really procedural programming
17:55:49 <nand`> helps when you add State monads and syntax like ‚Äúfoo.bar += 3‚Äù
17:56:13 <ion> It‚Äôs fine to assume ‚Äúdo‚Äù is just for IO in the very beginning.
17:57:20 <nand`> just as it's fine to assume list comprehensions are only for lists? :P
17:59:33 <ion> ‚ÄúOh, this thing you‚Äôre already used to can be generalized like this‚Äù can be nicer than ‚Äúthis thing you have never seen before is syntactic sugar for this totally general burrito-like concept you‚Äôve never seen before‚Äù
18:00:12 <ion> s/general/generic/
18:00:40 <monochrom> Piaget's theory. concrete before abstract.
18:01:36 <mikeplus64> :t \y -> [ x | x <- [1..], then y ]
18:01:38 <lambdabot>     Illegal transform or grouping list comprehension: use -XTransformListComp
18:02:19 <nand`> when approaching new concepts I tend to familiarize myself with simple examples of them first
18:02:26 <nand`> it does seem like the right order
18:02:53 <nand`> many concepts are there to generalize other concepts
18:04:05 <roconnor>     No instance for (Arbitrary UTCTime)
18:04:07 <roconnor> :(
18:19:23 <JoeyA> Would it be safe to compare two IORefs of different value type using unsafeCoerce?
18:19:38 <JoeyA> I have an IORef behind existential quantification.
18:19:45 <danharaj> if and only if their underlying representation is identical.
18:19:52 <danharaj> (depending on your compiler)
18:19:55 <danharaj> (and RTS)
18:19:58 <danharaj> (and phase of the moon)
18:20:10 <JoeyA> The underlying representation of the value inside of the IORef may vary.
18:20:27 <JoeyA> (the underlying type may be different)
18:21:11 <danharaj> Then no, you can't. Use Dynamic or make a GADT and pattern match on that by unwrapping the existential.
18:24:00 <JoeyA> Thanks
18:30:31 <Cale> danharaj: Are you sure?
18:31:00 <Cale> I'm pretty sure that if you're comparing *the IORefs*, they'll have the same representation at least in GHC, regardless of what the type of value is that they contain.
18:31:21 <JoeyA> Cale: I agree.
18:31:41 <EvanR> :t toInteger
18:31:42 <Cale> But it's not very nice to rely on this
18:31:43 <lambdabot> forall a. (Integral a) => a -> Integer
18:31:49 <JoeyA> Since it's for a nice-to-have Eq instance, I'll just not add an Eq instance.
18:32:56 <JoeyA> I'd rather not risk the garbage collector yadda yadda.
18:33:22 <EvanR> is there a string / text type for just ascii characters
18:33:30 <nand`> ByteString
18:33:40 <nand`> well, extended ASCII
18:33:52 <shachaf> "extended ASCII" :-(
18:34:00 <EvanR> yeah i was about to vomit
18:34:01 <nand`> shachaf: shush your exact names
18:34:17 <EvanR> you talking about ByteString.Char8 ?
18:34:21 <shachaf> Also the "ByteString = text type for ASCII" bit.
18:35:28 * hackagebot penny-bin 0.2.0.0 - Extensible double-entry accounting system - binary (OmariNorman)
18:38:38 <xplat> ooh, more monad tutorials with food-related analogies?
18:39:05 <xplat> "monads are like tootsie-roll pops" would be a good one
18:39:56 <xplat> no matter how many times you lick an IO TootsieRoll you cannot get to the delicious TootsieRoll center.  you can unsafeBiteIO but that's cheating.
18:40:08 <latro`a> lol
18:40:26 <EvanR> ...
18:40:36 <latro`a> only unhelpful thing is that not every monad lacks a coreturn
18:41:03 <latro`a> (and even many of the ones that do have a partial one)
18:41:49 <EvanR> yes thats not a monad tutorial thats a weird IO tutorial
18:42:54 <latro`a> instance BadCopointed Maybe where badCoreturn = fromJust
18:42:55 <cleantc> How does Haskell 98 (2010) infer kinds for type variables if not provided explicitly?
18:42:56 * latro`a ducks
18:43:12 <xplat> EvanR: but confusing monads and IO is traditional for bad monad tutorials
18:43:51 <latro`a> ....huh, no one threw anytihng at me
18:44:01 <latro`a> *anything
18:44:28 <xplat> latro`a: i threw Nothing at you, shortly you will die of a pattern-match error
18:44:33 <latro`a> lol
18:47:00 <EvanR> 'bad monad tutorial tradition'
18:47:09 <EvanR> not good
18:47:24 <ReinH> I think it's some sort of right of passage for haskell bloggers
18:47:40 <nand`> cleantc: by seeing how many variables it's applied to?
18:47:44 <startling> but like I really *get* them now, you know?
18:47:54 <startling> monads are just sandwiches
18:48:04 <ReinH> startling: let me explain it to you with this food-related analogy
18:48:09 <EvanR> comonads are like nightclubs
18:48:18 <ReinH> imagine you want to build a bridge
18:48:22 <ReinH> and that bridge is made up of burritos
18:48:23 <alpounet> so monads are like conightclubs
18:48:25 <alpounet> awesome
18:48:41 <ReinH> and on that burrito bridge is a series of semi trucks
18:48:41 <startling> monads are like bondage gear.
18:48:54 <startling> you can only return it in certain circumstances
18:49:13 <alpounet> binding makes sense now
18:49:32 <xplat> and the semi trucks are wearing spacesuits
18:49:51 <ReinH> and in each semi truck is an assembly line
18:50:02 <EvanR> more interesting would be good help on functor, applicative, monoid, and monad
18:50:08 <nand`> now imagine on this bridge is a delivery truck carrying sandwiches
18:50:09 <ReinH> and that assembly line makes space suits
18:50:10 <nand`> those are like monads
18:50:12 <ReinH> there, I think that covers it
18:50:17 <ReinH> that's what a monad is
18:50:17 <nand`> does the analogy help?
18:50:18 <ReinH> SIMPLE
18:50:55 <xplat> now whenever i see (>>=) i get hungry
18:51:10 <latro`a> lol
18:51:13 <ReinH> oh also the space suits are then put into nuclear waste containers
18:51:23 <ReinH> and fed to monsters
18:51:28 <ReinH> http://www.haskell.org/haskellwiki/Monad_tutorials_timeline
18:51:31 <ReinH> I am not making any of this up
18:51:42 <startling> the monsters one is pretty good
18:52:06 <xplat> monad tutorials are like embarrassing baby pictures
18:52:28 <startling> I just wish I had fully understood typeclasses and algebraic structures before I had tried to understand monads
18:52:34 <startling> monads are like babies
18:54:33 <startling> you can feed them to each other? I don't know
18:54:48 <EvanR> :|
18:56:36 <ReinH> monads are like human centi... nope. NOPE.
18:56:45 <byorgey> @where typeclassopedia
18:56:46 <ReinH> but, I mean, yeah kind of
18:56:46 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
18:56:55 <byorgey> EvanR: "more interesting would be good help on functor, applicative, monoid, and monad"  ^^^ does this count?
18:56:57 <EvanR> ReinH: good one
18:57:05 * startling reaches enlightenment.
18:57:06 <EvanR> byorgey: yes
18:57:29 <byorgey> ok. =)  Though of course it's not a "tutorial" exactly.
18:58:10 <startling> the typeclassopedia is pretty cool, though I'm not sure it's beginner-leve
18:58:12 <startling> l
18:58:24 <byorgey> true, it's not really
18:58:54 <startling> someone should write an introduction to category theory + some haskell
18:59:02 <startling> I think that might be a better approach
19:00:03 <latro`a> a thing that's bothered me for ages: in category theory every monad has a comonad, no? but in haskell almost no monads have a comonad
19:00:15 <latro`a> do I misunderstand something in one or the other?
19:00:57 <ReinH> wow, Typeclassopedia is pretty great
19:01:03 <ReinH> and I like the tone
19:01:04 <EvanR> latro`a: well reader and writer do
19:01:12 <parcs`> http://www.haskell.org/haskellwiki/HaskellImplementorsWorkshop/2012#Programme -- i really hope all these talks are recorded
19:01:20 <latro`a> sure
19:01:20 <byorgey> latro`a: "every monad has a comonad" <-- what do you mean?
19:01:21 <latro`a> but
19:01:27 <latro`a> I mean exactly what I said
19:01:34 <latro`a> the adjunction that makes a monad automatically makes a comonad
19:01:42 <latro`a> if I understand category theory monads correctly
19:01:45 <byorgey> true
19:02:02 <byorgey> though note there can be several adjunctions giving rise to the same monad
19:02:15 <xplat> latro`a: the comonad isn't based in the same category
19:02:19 <byorgey> latro`a: well then I don't understand your statement "in haskell almost no monads have a comonad".
19:02:36 <byorgey> ah, good point xplat
19:02:45 <latro`a> being in a different category might explain it
19:02:48 <latro`a> so, say
19:02:57 <xplat> (and in fact there can be several, based in different categories, depending how you divvy up the monad into left and right adjoint)
19:02:59 <latro`a> what's the coreturn associated to List
19:03:17 <latro`a> it isn't a [a] -> a, correct?
19:03:20 <byorgey> parcs`: they probably will be... I think they were the last two years
19:03:41 <parcs`> byorgey: yay, great
19:03:50 <byorgey> latro`a: List isn't a comonad
19:04:00 <copumpkin> [a] -> a is a lie!
19:04:02 <copumpkin> always
19:04:04 <latro`a> that's why I said associated
19:04:05 <startling> maybe just an introduction to abstract algebra + haskell? even playing with groups and rings helped me a lot
19:04:13 <latro`a> there's an adjunction that gives List
19:04:21 <latro`a> what comonad does that adjunction give
19:04:23 <copumpkin> latro`a: I implemented it in agda once upon a time
19:04:36 <copumpkin> latro`a: it lives in a different category
19:04:39 <latro`a> I know
19:04:40 <latro`a> but which
19:04:46 <copumpkin> category of monoids
19:05:06 <latro`a> that's fine, so what does it do?
19:05:21 <copumpkin> https://gist.github.com/2663881 is the monad
19:05:48 <latro`a> (I have never seen agda before at all, so that doesn't really help me)
19:05:55 <latro`a> (I have only heard the name)
19:06:05 <copumpkin> it mostly looks like haskell, so shouldn't be impossible to figure out :P
19:06:22 <latro`a> it's pretty dense to my eyes, frankly
19:06:23 * copumpkin doesn't know what the comonad "does"
19:06:23 <xplat> latro`a: counit at line 116 is the coreturn for the comonad
19:06:24 <t7> can i cross compile with ghc somehow?
19:06:29 <t7> using llvm or something?
19:07:15 <mikeplus64> t7: you might have to "just" use a chroot or similar
19:07:27 <geekosaur> t7, cross compilation is still very much a work in progress.  suggest you ask in #ghc
19:07:55 <xplat> in particular, it's the field on line 117, line 118 is just the proof it's a natural transformation
19:08:59 <roconnor> what is Categorical Programming?
19:09:17 <xplat> so counit takes a list of lists (a free monoid on the underlying set of a free monoid) and gives you the list you get by concatenating all its elements
19:09:45 <xplat> this is a common pattern for these associated comonads -- the coreturn on the comonad is like the join on the monad
19:10:06 <xplat> similarly extend on the comonad is like the return on the monad
19:11:41 <EvanR> the day python embarassed imperative programming
19:11:46 <EvanR> wow.
19:12:17 <EvanR> "in python every type is an instance of Monad"
19:12:18 <EvanR> lol
19:12:41 <xplat> oh, and if the comonad lives in the E-M category rather than the Kliesli category, you just have a list of elements of a monoid
19:13:26 <xplat> hey, you can actually write this in Haskell almost
19:14:13 <xplat> coreturn :: (Monoid t) => [t] -> t; coreturn = mconcat
19:14:45 <startling> I have a function that gives [Either a b]; I'm trying to use that action in do notation for something that returns Either [a] b. Is there a nice way to call the first action and return the a values if there are any?
19:15:05 <xplat> extend : (Monoid t) => [t] -> [[t]]; extend xs = [xs]
19:15:20 <xplat> er, that might not be extend, but the other one
19:15:30 <xplat> it's cojoin, not cobind
19:15:56 <ReinH> How does one say <$> and <*> in english?
19:16:04 <copumpkin> quack and oink
19:16:07 <startling> fmap and apply
19:16:17 <ReinH> makes sense
19:16:17 <startling> (that's how I say them)
19:16:21 <copumpkin> damn, I've been doing it wrong
19:16:21 <xplat> liftA and app
19:16:27 <xplat> er, ap
19:16:34 <EvanR> dont try to pronounce haskell unless you are a modem
19:16:44 <mzero> :t lefts
19:16:46 <lambdabot> forall a b. [Either a b] -> [a]
19:16:50 <ReinH> I've always thought it ironic taht <$> is not the applicative equivalent of $
19:17:00 <startling> ReinH: it is, though
19:17:02 <startling> isn't it?
19:17:09 <ReinH> :t ($)
19:17:10 <EvanR> its the functor equivalent
19:17:10 <lambdabot> forall a b. (a -> b) -> a -> b
19:17:10 <mzero> startling: the question is - what do you want to return if the list is all Right? what if the list is empty?
19:17:10 <xplat> no, <*> is
19:17:13 <ReinH> :t <*>
19:17:14 <lambdabot> parse error on input `<*>'
19:17:18 <ReinH> :t (<*>)
19:17:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:17:25 <startling> oh, that's true
19:17:34 <xplat> "the lists are all Right"
19:17:45 <ReinH> xplat: more haskell jokes?
19:17:47 <ReinH> excellent
19:17:52 <startling> mzero: I want to do further stuff if there are no Lefts
19:18:28 <Raynos> What's an alternative more correct terminology for the word upvalue ?
19:18:30 <copumpkin> I was surprised that the monads are actually _equal_
19:18:34 <roconnor> <*> would be better named <@>
19:18:35 <copumpkin> in agda
19:18:51 <ReinH> roconnor: it's too late now ofc :/
19:18:52 <copumpkin> awfully convenient :P
19:19:04 <xplat> Raynos: that depends what upvalue means
19:19:04 <roconnor> and <*> can maybe be liftA2 (,)
19:19:13 <Raynos> xplat: http://en.wikipedia.org/wiki/Closure_(computer_science)
19:19:23 <Raynos> > An upvalue is a free variable that has been bound (closed over) with a closure.
19:19:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:19:25 <mzero> well then, I'd do soemthing like:       case lefts eabs of  [] -> ---otherstuff----;  as -> return $ Left as
19:19:29 <roconnor> though <,> is probably better for liftA2 (,)
19:21:44 <ReinH> today I learned of DeriveFunctor
19:21:49 <ReinH> awesome
19:23:02 <xplat> Raynos: i guess you could just leave it on wikipedia for 10 or 20 years and then it will be the correct term
19:24:36 <ReinH> and DeriveFoldable. awesomer
19:24:50 <Raynos> xplat: I want to know the correct word instead :P there must be a name for a bound variable that is used in the outer scope of a closure
19:25:23 <startling> nonlocal
19:26:00 <startling> though that's more vague
19:26:05 <shachaf> Lexically-bound?
19:26:08 <shachaf> Hmm, maybe not.
19:26:54 <xplat> i know they're free variables (more precisely, variables free in the inner function), i don't know if they're called anything else
19:27:12 <shachaf> "free in the inner function" is clear, at least.
19:27:15 <xplat> upvalue sounds kind of tcl-inspired
19:28:24 <shachaf> Apparently Lua uses it.
19:30:13 <xplat> well, lua sounds like it came out of the same kind of culture, or attracted the same kind of culture, as tcl
19:31:02 <xplat> so it's not surprising they'd use similar terms
19:32:34 <xplat> i mean, they're both reknowned for being small embeddable languages focused on being for glue instead of real programming (although tcl abandoned being small for speed since 8.0, and lua managed to get fast while still staying pretty small)
19:33:10 <xplat> and also out of all the un(i)typed languages out there they're among those that actually take unityping seriously
19:34:03 <xplat> (in tcl you're either a string or you aren't a first-class value, and in lua you're a table.  you just are.  even if you're obviously not a table, you're still a table.)
19:34:40 <startling> someone should write a dependently-typed lua. :S
19:37:31 <xplat> in dependently-typed lua, functions are tables that return a table, a table, a table, or a table, depending which table you supply as an argument?
19:37:54 <startling> haha
19:38:21 <startling> couldn't you do "table with x, y, and c keys" with dependent typing?
19:38:54 <xplat> you could already do some of that with row polymorphism
19:40:02 <roconnor> Package lens-family-0.1.0 contains no fatal errors.
19:40:03 <roconnor> However the package generated the following warnings:
19:40:05 <roconnor>     Exposed modules use unallocated top-level names: Lens
19:40:13 <augur> xplat: tables?
19:40:14 <augur> explain?
19:40:50 <xplat> tables aka dictionaries, associative arrays, or (javascript/json) 'objects'
19:41:17 <startling> augur, it's the basic data type in lua
19:41:20 <augur> yes but i mean how is everything a table in lua?
19:41:50 <xplat> well, for example, in lua lists are just tables with numeric keys
19:42:12 <startling> they're array-backed in the background, though
19:42:19 <startling> but that's an optimization
19:42:21 <augur> what about numbers or functions?
19:43:12 <xplat> yeah, actually they compromise more than i let on
19:43:21 <xplat> i'm giving them too much credit!  :(
19:43:36 <xplat> i meant :) but :( also works
19:43:58 <startling> not sure about numbers, but I think tables can have a special entry that points to another function to call
19:44:04 <startling> like python's __call__
19:45:22 <xplat> ‚ÄòWeeChat IRC client allows scripts to be written in Lua.‚Äô [--wikipedia] -- to be more precise, weechat allows scripts to be written in C and transliterated into any language you desire before execution :)
19:47:40 <xplat> (well, that's not totally fair -- only the parts of a script that actually interface with weechat need to be written in C-in-your-favorite-scripting-language)
19:48:34 <startling> what if C is my favorite scripting language?
19:48:50 <xplat> but it seems somewhere along the line i forgot i was not in #-blah
19:49:11 <startling> C's JIT is pretty great. Also, the vm is really close to the bare metal
19:49:39 <xplat> startling: it means you're free to write very non-idiomatic C where it doesn't interface with weechat, for example you could use some code from the original Bourne shell
19:49:57 <shachaf> I don't know of any C JITs.
19:50:06 <shachaf> edwardk wrote part of a C++ JIT.
19:50:16 <shachaf> Actually it was an x86_64 JIT.
19:50:18 <startling> shachaf, `id`. :)
19:50:31 <shachaf> startling: Huh?
19:50:52 <xplat> shachaf: there's a C JIT in an x86 processor that translates a C bytecode into a VLIW RISC machine code
19:51:12 <startling> shachaf, I was being farcical.
19:51:19 <shachaf> xplat: Calling x86 machine code "C bytecode" is a stretch.
19:51:34 <startling> cvm bytecode
19:52:05 <shachaf> startling: Even with farce I don't understand.
19:53:22 <xplat> shachaf: a slight one, but evolution of microprocessor architectures was very influenced by C (and by the C ripoff versions of Pascal)
19:54:27 <jfischoff> is it possible to make a function like this:  f :: (Applicative f) => (b -> f c) -> (a -> f b) -> a -> f c
19:54:38 <jfischoff> or do I need join?
19:54:39 <shachaf> No.
19:54:46 <jfischoff> that's what I thought
19:54:51 <shachaf> @ty (<=<)
19:54:52 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
19:54:54 <xplat> just as C itself was very influenced by minicomputer and later microcomputer architectures in its turn
19:54:57 <jfischoff> yeah
19:55:09 <shachaf> jfischoff: You can make (>>=) from that, though it's a little bit annoying.
19:55:32 * hackagebot lens-family-core 0.1.0 - Haskell 98 Lens Families (RussellOConnor)
19:55:34 * hackagebot lens-family 0.1.0 - Lens Families (RussellOConnor)
19:55:36 <jfischoff> aye
19:56:13 <shachaf> @ty (id>=>id)
19:56:14 <lambdabot> forall (m :: * -> *) c. (Monad m) => m (m c) -> m c
19:56:27 <shachaf> Hah.
19:56:31 <latro`a> cute
19:56:55 <xplat> i don't even think you can make f (a -> b) -> f (b -> c) -> f (a -> c) with Applicative f
19:56:55 <jfischoff> @ty join
19:56:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:57:33 <shachaf> @ty liftA2 (.)
19:57:34 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
19:57:39 <shachaf> @ty liftA2 (Prelude..)
19:57:41 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
19:57:49 <xplat> hm, i guess you can
19:58:16 <xplat> then why do people say you need a category instance to make an applicative into an arrow?
19:58:50 <xplat> i must be misunderstanding something
19:59:19 <latro`a> is there an unzipWith? I guess there doesn't need to be, it'd just be unzipWith f = map (uncurry f), at least in the binary case
20:00:49 <xplat> latro`a: i would think the signature of unzipWith was (a -> (b, c)) -> [a] -> ([b],[c])
20:01:12 <latro`a> um
20:01:16 <latro`a> that seems a little weird to me
20:01:26 <xplat> but still you wouldn't 'really' need it in the same way you don't 'really' need zipWith, and it probably comes up less
20:01:36 <latro`a> I was thinking of unzipWith :: (a->b->c) -> [(a,b)] -> [c]
20:01:54 <xplat> latro`a: how does that even unzip?  you don't get two lists
20:02:05 <latro`a> true
20:02:14 <latro`a> well, you split and merge, basically
20:02:16 <latro`a> using the function
20:02:19 <copumpkin> :t map . uncurry
20:02:20 <lambdabot> forall b a b1. (a -> b1 -> b) -> [(a, b1)] -> [b]
20:02:32 <latro`a> you could unzip and then zipWith
20:02:32 <xplat> latro`a: that's more like zipWith . unzip
20:02:35 <latro`a> and it would be the same transformation
20:03:03 <shachaf> @ty trueZip
20:03:04 <lambdabot> forall a b t. [a] -> [b] -> [(a -> b -> t) -> t]
20:03:13 <xplat> whatever it is i don't think it's the right thing to be called unzipWith, because it can be implemented as a simple map
20:03:13 <copumpkin> lol
20:03:21 <latro`a> right
20:03:25 <latro`a> was just pondering
20:03:29 <latro`a> not necessarily a good idea >.>
20:03:36 * copumpkin unponders!
20:03:54 <shachaf> @ty \f -> map (uncurry f) .: zip
20:03:55 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
20:04:00 <shachaf> Can also be implemented as a simple map!
20:04:08 <xplat> think of it this way: for zipWith, you supply a pairing function to use instead of (,).  for unzipWith, you should supply functions to use instead of fst and snd
20:05:18 <xplat> so maybe (a -> b) -> (a -> c) -> [a] -> ([b],[c]), but that's basically the same thing
20:05:42 <latro`a> no, I see what you meant
20:05:50 <xplat> shachaf: what's that '.: zip' then?
20:05:51 <latro`a> no need to elaborate :p
20:06:10 <shachaf> xplat: Oh, I misunderstood.
20:06:13 <shachaf> Right, that's silly.
20:06:33 <shachaf> ((r->b),(r->c)) -> [r] -> ([b],[c])
20:06:50 <shachaf> (r->(b,c)) -> [r] -> ([b],[c])
20:09:00 <shachaf> xplat: Maybe unzipWith should also get a function to use instead of (,)
20:09:18 <shachaf> [(a,b)] -> ([a] -> [b] -> r) -> r
20:09:50 <xplat> heh, i suppose it could :)
20:10:42 <shachaf> Or maybe it should work directly with zipWith.
20:10:47 <xplat> then the original thing would be unzipWith . zipWith
20:11:05 <xplat> originally-mentioned thing
20:11:28 <shachaf> ((a -> b -> c) -> [c]) -> ([a] -> [b] -> r) -> r
20:11:40 * shachaf doesn't really know what he's saying anymore.
20:12:28 <xplat> remember that when data is code, lists are actually loops
20:12:38 <xplat> list overdose makes you loopy!
20:13:39 <shachaf> But a sufficiently smart compiler makes you listless?
20:14:34 <latro`a> dem puns
20:15:53 <xplat> funpuns has a right to make all the puns he wants, but i must be violating some kind of law
20:17:06 <xplat> (i rot13 to 'kcyng' and i have no idea what that means, except that it's almost certainly Welsh)
20:30:35 <hpaste> gertc pasted ‚Äúhttp-conduit version‚Äù at http://hpaste.org/72633
20:30:56 <gertc> https://github.com/gertcuykens/haskell-design
20:31:16 <gertc> does this mean i am ****?
20:31:36 <gertc> or just i did somthing stupid again
20:31:53 <tgeeky> gertc: can't both be true?
20:32:05 <gertc> maybe
20:32:46 <gertc> funny thing is leksah does not mention a error but ghci does
20:33:05 <startling> can I use guards with lambdas?
20:33:29 <latro`a> iirc no, at least not directly
20:33:34 <gertc> running it does not start websocket
20:33:42 <startling> darn
20:33:57 <latro`a> can use case, though
20:34:02 <latro`a> and hence now LambdaCase
20:34:11 <startling> yeah
20:34:12 <slack1256> startling: Maybe I am wrong. but IIRC guard are just sugar for case
20:34:33 <latro`a> rather heavily nested case, though
20:34:59 <slack1256> heavily useful case. but a case in the end.
20:35:02 <startling> yeah, I know; using case rather than guards for Bool would be useless though, if I could
20:35:07 <startling> hence the question
20:35:34 * hackagebot simple-actors 0.3.0 - A library for more structured concurrent programming, based  on the Actor Model (BrandonSimmons)
20:36:07 <slack1256> in fact. almost any reduction in haskell is expressed in terms of case pattern matching.
20:36:15 <slack1256> kind of great.
20:36:35 <latro`a> sorta, except the level of nesting in a typical desugared code block is absurd
20:37:03 <latro`a> eh, "typical", that is "slightly large"
20:37:18 <startling> yeah
20:46:57 <startling> is there an operation on monads that sequences two actions but returns the result of the first (and throws out the result of the second)? I guess it'd be m a -> (a -> m b) -> m a; hoogle doesn't seem to know anything
20:47:54 <copumpkin> > let zomg x f = do q <- x; f q; return q
20:47:56 <lambdabot>   not an expression: `let zomg x f = do q <- x; f q; return q'
20:48:01 <copumpkin> :t let zomg x f = do q <- x; f q; return q in zomg
20:48:02 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> (b -> m a) -> m b
20:48:35 <startling> that works, thanks
20:48:52 <startling> just thought there might be a fancy infix operator around somewhere
20:49:02 <copumpkin> nope
20:49:15 <startling> darn. there usually is
20:53:51 <JoeyA> What does "Nominal" in NominalDiffTime mean?
20:54:00 <otters> why would you throw out the result of the second?
20:55:12 <xplat> otters: imagine the second is 'print'
20:55:29 <xplat> or
20:55:38 <xplat> 'guard' would also be appropriate
20:55:45 <hpaste> ‚ÄúJonathan Fischoff‚Äù pasted ‚ÄúMultiplate diverging‚Äù at http://hpaste.org/72634
20:55:47 <startling> yeah, I've got something similar to guard
20:55:52 <roconnor> JoeyA: it means not counting leap seconds
20:56:18 <JoeyA> ah, okay
20:56:42 <jfischoff> ^ Writing my first Multiplate instance and a simple traversal is diverging. Any ideas?
20:56:56 <JoeyA> I'm working on a monotonic time library.  Would DiffTime be the appropriate type for "amount of time since the clock was created" ?
20:57:26 <JoeyA> (for monotonic timing, I don't want any crap like leap seconds to affect the clock)
20:57:30 <roconnor> JoeyA: yes
20:57:37 <JoeyA> Thanks.
20:57:45 <roconnor> JoeyA: POSIXTIme is a synonym for NominalDiffTime
20:58:41 <roconnor> jfischoff: looking
20:58:50 <xplat> if we didn't have leap seconds, i wonder how long it would be before the clock wrapped around
20:59:15 <jfischoff> roconnor: :)
20:59:41 <xplat> actually that's probably a deceptive measure of how useful leap seconds actually are
21:00:44 <xplat> because probably almost all of the difference in the first full day would be accumulated after the earth's rotation had slowed enough to make leap seconds seriously insufficient
21:01:32 <xplat> they'd be happening sometime between monthly and daily at that point, which violates the specs for them
21:05:55 <roconnor> jfischoff: I'm suspicious of buildInteger and buildDouble which don't appear to be referencing strict substructures.
21:06:37 <roconnor> jfischoff: and buildString and buildBool
21:06:51 <jfischoff> roconnor: strict in what sense
21:06:52 <jfischoff> ?
21:06:57 <gertc> q
21:07:32 <roconnor> jfischoff: well they way they are written they are referencing the entire structure instead of a strict component
21:07:44 <jfischoff> ah
21:07:53 <roconnor> jfischoff: I'd replace buildInteger through buildBool with pure
21:07:59 <jfischoff> right
21:08:40 <jfischoff> roconnor: same with all the leafs
21:08:40 <jfischoff> ?
21:09:05 <roconnor> jfischoff: the others are fine I think
21:09:20 <jfischoff> roconnor: seems to work. Thanks!
21:13:53 <roconnor> jfischoff: as it stands, your multiplate won't traverse into the keys of an object
21:14:01 <roconnor> jfischoff: prehaps this is what you want
21:14:25 <jfischoff> roconnor: it is what I meant, but know that you mention it, that would be nice
21:14:31 <jfischoff> *now
21:15:11 <roconnor> jfischoff: you have to pick what order you want to traverse the keys and values
21:15:48 <jfischoff> maybe it should traverse pairs (key, value)?
21:16:50 <roconnor> jfischoff: HashMap has a traverseWithKey function which is close to what you will want
21:18:32 <roconnor> jfischoff: actually now that I think about it you cannot traverse the keys; they won't satify the multiplate laws
21:18:45 <roconnor> jfischoff: mostly because you cannot rewrite a key into a key that already exists.
21:19:06 <roconnor> so what you have is probably best
21:19:53 <jfischoff> roconnor: have any of the new lens learning affecting your thoughts on multiplate?
21:20:15 <roconnor> jfischoff: it has clairified my understanding of multiplate
21:20:27 <jfischoff> roconnor: how so?
21:21:46 <roconnor> jfischoff: that multiplate is a multi-sorted Traversable but without the ability to change type parameters.
21:22:56 <jfischoff> roconnor: what does multi-sorted mean?
21:23:17 <roconnor> jfischoff: the multiple types that are in a plate
21:23:24 <jfischoff> ok
21:23:40 <roconnor> jfischoff: perhaps it is my understanding of Traversable that has been affected more so
21:24:45 <jfischoff> I keep forgetting the type signature of traversable, its annoying :P
21:25:14 <jfischoff> roconnor: thanks again. I now can start the great multiplate instancing of my code:)
21:25:20 <roconnor> (Applicative f) => (b -> f b') -> a -> f a'
21:25:20 <jfischoff> goodnight!
21:25:25 <roconnor> good night
21:25:33 * roconnor -> sleep
21:36:28 <startling> question on the term "lambda-lifting": is it just turning closures into functions that take some arguments and some closure data?
21:36:59 <copumpkin> are there any persistent data structures with fast (sublinear) union?
21:37:05 <copumpkin> (of sets or set-like things)
21:38:39 <startling> some sort of tree maybe? I don't think you can have fast union and fast membership checking
21:41:29 <JoeyA> copumpkin: You mean, have the union of two large sets be sublinear?
21:41:39 <copumpkin> yeah
21:42:50 <copumpkin> hmm, in my case I might be able to get away with something sneakier
21:43:00 <shachaf> What's your case?
21:43:33 <JoeyA> By the way: according to the documentation of Data.Map.union, it's O(n+m).  But I did a little simple benchmarking, and it appears better than that.
21:43:45 <copumpkin> shachaf: that order book datastructure I keep going on about
21:43:51 <JoeyA> E.g. if you have someHUGEset `union` reallysmallset, it's quick.
21:44:06 <JoeyA> I think this remains true if you flip the arguments.
21:44:11 <latro`a> um
21:44:18 <latro`a> O is a worst-case notation in the first place, no/
21:44:19 <latro`a> *?
21:44:25 <JoeyA> Yes
21:44:30 <latro`a> that is, the worst case is when they're the same size
21:44:50 <JoeyA> But it's acting more like O(min(n, m))
21:44:52 <latro`a> obviously singleton `union` bigmap is not O(n), where n is the size of the big map
21:44:53 <shachaf> copumpkin: You keep going on about it?
21:45:00 <copumpkin> well, every couple of months
21:45:00 <shachaf> This is the first time you've gone on about it in months!
21:45:50 <latro`a> (since singleton `union` bigmap is just a lookup and an insert)
21:46:28 <shachaf> JoeyA: Data.Map.union is O(min(n,m))?
21:46:30 <shachaf> That's surprising.
21:46:47 <JoeyA> I don't know if it is or not, but it acts sort of like it.
21:47:08 <latro`a> it should take m lookups, each of which is logm, and then m insertions, which integrate over logn to log(n+m), no?
21:47:17 <latro`a> oh wait
21:47:20 <latro`a> no need for the lookups
21:47:22 <JoeyA> If it (and other merge operations) do have a complexity like that, it means bulk insertion with union is faster than doing a bunch of inserts.
21:47:26 <latro`a> since you're merging the whole thing
21:47:55 <latro`a> (i.e. you can go through the whole smaller map in O(m) time, not O(mlogm) time)
21:49:06 <JoeyA> So a tighter upper bound on the asymptotic speed of Data.Map.union and its ilk would be helpful.
21:50:47 <latro`a> seems like it would be (in the m << n limit) O(mlogn)
21:50:54 <latro`a> no?
21:51:48 <latro`a> at least, that'd be the complexity of m insertions in an n member map
21:53:11 <latro`a> you have to get the values of course, but you can do that in O(m) time, so it absorbs through
23:43:12 <startling> is there a nice way to map something over the value of an Either if this particular value is a Left?
23:44:26 <Catnaroek> Something like "map (either f id) xs"?
23:44:31 <Catnaroek> @type either
23:44:33 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:44:57 <Veinor> @type \f -> either f id
23:44:58 <lambdabot> forall a b. (a -> b) -> Either a b -> b
23:45:21 <Veinor> @djinn (a -> b) -> Either a c -> Either b c
23:45:22 <lambdabot> f a b =
23:45:22 <lambdabot>     case b of
23:45:22 <lambdabot>     Left c -> Left (a c)
23:45:22 <lambdabot>     Right d -> Right d
23:45:48 <Catnaroek> More like
23:45:55 <Veinor> @type \f -> either (Left . f) Right
23:45:57 <lambdabot> forall a b a1. (a1 -> a) -> Either a1 b -> Either a b
23:46:02 <Catnaroek> @djinn (a -> b) -> Either a b -> b
23:46:03 <lambdabot> f a b =
23:46:03 <lambdabot>     case b of
23:46:03 <lambdabot>     Left c -> a c
23:46:03 <lambdabot>     Right d -> d
23:46:13 <Veinor> ahh, that'd be either f id then
23:46:33 <Catnaroek> Well, at least, that's how I interpreted the question.
23:46:41 <latro`a> FWIW people usually do their twiddling on the Right value, though
23:46:52 <latro`a> (maybe you're doing both, in which case carry on)
23:47:25 <startling> latro`a: yep
23:47:34 <startling> Catnaroek: oh nice, didn't think of that
23:47:49 <copumpkin> :t (?f +++ id)
23:47:50 <lambdabot> forall b c b'. (?f::b -> c) => Either b b' -> Either c b'
23:47:56 <latro`a> if you're doing both then you might be interested in lefts and rights
23:47:59 <startling> latro`a: (I'm giving more context to an error value)
23:48:02 <latro`a> there is also a partitionEither-ish thing
23:48:09 <startling> yeah, I'm using lefts and rights too. :)
23:48:11 <latro`a> I forget if that's actually its name
23:48:21 <Veinor> :t (+++ id)
23:48:23 <lambdabot> forall b c b'. (b -> c) -> Either b b' -> Either c b'
23:48:28 <Veinor> @type (+++)
23:48:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
23:48:36 <latro`a> ooh
23:48:37 <latro`a> snazzy
23:48:55 <Catnaroek> Dang, I wish I could understand arrows. What would be an arrow that is not a monad?
23:48:58 <latro`a> had forgotten about some of the Arrow subclasses
23:49:04 <Catnaroek> an example of an arrow that is not a monad?
23:49:08 <copumpkin> Catnaroek: I don't think they're all that interesting
23:49:15 <copumpkin> but there are some useful combinators in them
23:49:21 <latro`a> there's an example of a parser that doesn't evaluate all branches
23:49:25 <latro`a> in that introductory paper
23:49:29 <latro`a> that can't be done monadically
23:49:45 <startling> Catnaroek, they make sense as "functions that carry some extra information"
23:49:50 <startling> (to me anyway)
23:50:04 <copumpkin> and sadly, they all have to be at least functions
23:50:22 <startling> arrow parsers make more sense than monad parsers to me.
23:50:47 <startling> copumpkin: indeed
23:50:51 <Catnaroek> Well, I guess I should stop toying with @djinn and start writing real code. :P
23:51:50 <latro`a> eh, so do monads, though
23:51:55 <latro`a> @ copumpkin
23:52:04 <copumpkin> they do?
23:52:15 <latro`a> monads are strictly weaker than arrows
23:52:34 <copumpkin> "weaker"
23:52:40 <latro`a> iirc you have a Monad iff you have a type with both an Arrow and an ArrowApply instance
23:53:06 <copumpkin> monads don't need an "arr" combinator
23:53:12 <latro`a> it can be constructed
23:53:15 <copumpkin> sure
23:53:18 <copumpkin> but you don't need to provide one
23:53:24 <copumpkin> it comes naturally via >=> if you want it
23:53:27 <latro`a> sure, but it can be inferred, so it conceptually exists
23:53:37 <copumpkin> that's not saying much
23:53:40 <copumpkin> if anything at all
23:53:49 <latro`a> whereas not all Arrow's arr arises that way, to my knowledge at least
23:54:13 <latro`a> I agree with you, though, I've had trouble seeing a clear, well-motivated example of an Arrow that isn't an ArrowApply
23:54:24 <copumpkin> all I'm saying is that all arrow instances need to arise from functions
23:54:43 <latro`a> sure; but all monad instances need to be *able* to arise from functions
23:54:44 <copumpkin> need to have some way of embedding functions into them, that is
23:54:58 <latro`a> or are you not comparing arrows to monads
23:55:02 <copumpkin> not really, because they don't "deal" with that
23:55:05 <latro`a> and are just stating a weakness of arrows that carries over to monads too
23:55:14 <latro`a> eh, they do, they just cover it up in notation
23:55:25 <copumpkin> how?
23:55:46 * hackagebot yesod-platform 1.0.6.1 - Meta package for Yesod (MichaelSnoyman)
23:55:46 <latro`a> you're not looking at the functions because of the way bind is written, but all your >>= code could be rewritten as >=> code
23:55:56 <latro`a> in which case functions are suddenly staring you in the face
23:55:58 <Veinor> i wish there was a djinn-like that you could tell about functions
23:56:23 <Veinor> so, like, if i'm working with yesod or whatever, i can say 'i have values of these types, how do i get to this type?'
23:56:38 <copumpkin> latro`a: not really, unless you wanted to throw undefineds in there
23:56:49 <latro`a> what undefineds?
23:56:51 <latro`a> there are none
23:57:03 <latro`a> m >>= f = (const m >=> f) x, for any x
23:57:15 <copumpkin> well yeah, dummy arguments
23:57:24 <latro`a> no need for undefined, though
23:57:27 <latro`a> x can be ()
23:57:36 <copumpkin> yeah, but this is all kind of irrelevant to anything :P
23:57:43 <latro`a> eh, kinda
23:57:46 <copumpkin> these are embedded haskell functions
23:57:48 <latro`a> just saying, it's a difference of emphasis
23:57:50 <copumpkin> you have them all the time everywhere
23:57:51 <latro`a> not a difference of semantics
23:58:10 <copumpkin> saying that you need to be able to provide them is like saying you need to be able to write haskell
23:58:14 <copumpkin> I'm not worried about that
23:58:26 <copumpkin> for arr, you actually need to be able to write it
23:58:33 <copumpkin> for your particular type
23:58:37 <latro`a> I think the fact that they have to be explicitly functions comes about because arrows have a natural dependence on input
23:58:44 <latro`a> which is why the input is actually a type parameter
23:58:45 <copumpkin> yeah
23:58:56 <copumpkin> except arr is what makes arrows less interesting
23:58:58 <copumpkin> and isn't fundamental
23:59:01 <latro`a> the natural dependence on input is what makes them more general in the first place
23:59:11 <latro`a> I doubt arr can be inferred
23:59:13 <latro`a> from other stuff
23:59:18 <copumpkin> I'm not saying it can
23:59:19 <latro`a> I mean, return is basically the same thing
23:59:26 <latro`a> the definition of return is almost always boring
23:59:28 <copumpkin> I'm saying the model is less interesting than it could be because of it
23:59:50 <latro`a> I'm sure there's something that gets in the way if it's not there
