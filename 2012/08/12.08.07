00:00:04 <shachaf> In case the argument list is empty?
00:00:07 <scry1> no argument, an empty list
00:00:19 <shachaf> Pattern-matching isn't a bad thing. :-)
00:00:37 <shachaf> You can make a separate function for it.
00:00:57 <scry1> suppose so
00:01:12 <shachaf> You can do something like "maybe defaultValue read (listToMaybe args)"
00:01:13 <shachaf> Or something.
00:02:10 <scry1> okay, what if i wanted to pattern-match in the do-expr though?
00:02:26 <scry1> let n | args == []    = default....
00:02:37 <scry1> wait, case args of...
00:02:54 <shachaf> Yes, don't use (==[]).
00:03:00 <Targen> scry1: args <- getArgs; if null args then ...
00:03:05 <shachaf> Targen: :-(
00:03:12 <Jafet> if length args == 0
00:03:14 <shachaf> Pattern matching is much better than "if null"
00:03:20 <shachaf> Jafet: Oh, stop it!
00:03:22 <Targen> Indeed.
00:03:47 <Jafet> Actually, the real reason is that case indentation is much better than if indentation...
00:04:22 <scry1> haha, that is true
00:05:24 <Targen> scry1: You could also bring out the big guns.  The cmdargs package is nice.
00:06:39 <scry1> eventually, but here i'm just testing something for my _real_ question...
00:07:19 <wagle> does ghci crash for anyone else on snow leopard?
00:07:34 <Targen> Well, niceish.  There's a nice interface that's unsafe and breaks whenever GHC's optimizations outsmart it, another interface that's very much safe yet equally ugly, and some TH magic that lets you write in the former to obtain the latter, but it's not too flexible.
00:07:41 <wagle> from the latest haskell-platform
00:08:22 <Targen> It's not quite Boost::program_options yet, but it's getting there.
00:08:50 <Jafet> You want other libraries to become like program_options?
00:09:22 <edwardk> i've been meaning to take a whack at a command line option library using some of the stuff i wrote a while back for kata
00:09:25 <scry1> i'd settle for optparse
00:09:37 <Targen> Humor me—I've become immune to the horrors of C++ TMP error messages.
00:10:44 <Targen> The interface to CmdArgs is in fact rather similar in terms of the sort of syntax you end up with.  I'd dare venture that's what it shoots for.
00:11:32 <shachaf> All the Haskell command-line option libraries I've seen have annoyed me some way or another.
00:12:11 <Jafet> C++ http://hpaste.org/51091
00:13:10 <edwardk> shachaf: likewise
00:13:58 <Targen> Jafet: To be fair, there's *two* errors there :)
00:15:35 <Jafet> Nope, just one
00:15:55 <Jafet> The library manages to expand it into two
00:16:17 <Targen> heh
00:20:39 <EvilMachine> shachaf: i did my own command-line option library.
00:21:14 <hpaste> scry pasted “p391” at http://hpaste.org/72720
00:22:05 <scry1> so i have this program, and the exact same thing in ocaml: http://codepad.org/8RmrrQzA
00:22:40 <scry1> what's bugging me is the ocaml is way faster
00:22:55 <scry1> also haskell takes up all my memory
00:23:25 <scry1> wait..
00:23:50 <shachaf> Haskell and OCaml aren't the exact same language, so it's not surprising that the exact same program behaves differently.
00:23:54 <EvilMachine> scry1: about the memory: laziness… you’re doing it wrong! ^^
00:25:53 <m3ga> scry1: where is the haskell version?
00:26:08 <scry1> okay, i figured it was the thunks but
00:26:21 <scry1> m3ga: the last hpaste
00:26:49 <scry1> ocaml here: http://codepad.org/zzStwgDY
00:27:00 <scry1> haskell http://hpaste.org/72720
00:27:26 <frerich> scry1: What strikes me as odd is that in the ocaml version, can_force_win uses 'tl $ take_while ((>=) n) pop_sums)' whereas the Haskell flavor uses 'tail $ takeWhile (<= n) popSums)'. Is that intentional?
00:27:34 <frerich> scry1: The <= vs. >= difference, I mean.
00:27:58 <scry1> yes - ocaml doesnt support infixes like haskell
00:28:14 <scry1> so ((>=) n) is (n >=)
00:28:27 <frerich> Interesting, I didn't know that
00:28:53 <frerich> I see, the same is true in other cases...
00:28:58 <scry1> i wish it did, and actually its probably not hard  to tweak
00:29:21 <scry1> i havent gotten into camlp4 yet
00:30:28 * EvilMachine really really hopes, scry1 is using his OCAML skills to fix the aging parts mldonkey. ;)
00:32:25 * hackagebot system-time-monotonic 0.2 - Simple library for using the system's monotonic clock (JoeyAdams)
00:32:45 <scry1> hah, ocaml itself needs some work first
00:33:10 <scry1> no excuses for bad concurrency these days
00:33:28 <JoeyA> Bad concurrency?
00:33:51 <JoeyA> There's a big tradeoff to adding lightweight threads to a programming language.
00:34:18 <JoeyA> Namely, when you have lightweight threads and asynchronous exceptions, you have to worry about code being interrupted *anywhere*.
00:35:38 <JoeyA> OCaml didn't want to deal with that.  Concurrent Haskell is dealing with it.
00:36:16 <Cale> scry1: how long do the programs each take to run?
00:36:49 <JoeyA> (err, lightweight threads and async exceptions)
00:37:02 <MostAwesomeDude> I just want an event loop that I can touch.
00:39:04 <scry1> Cale: ocaml is about .750 for n=15,
00:39:23 <scry1> haskell just starts thrashing at 15
00:39:53 <scry1> definitely doin it wrong here
00:40:33 <Cale> ah, okay, that helps to know
00:40:55 <Cale> I guess I can take a look for a minute, but I really should be sleeping :)
00:41:41 <JoeyA> Compile with -Wall, to see if anything is being defaulted to Integer (which can hurt performance)
00:42:05 <Cale> I very much doubt it's just that
00:42:10 <scry1> JoeyA: i just wish there was more research going into the subject, since it's essential for the language to compete
00:42:11 <Cale> there's something much more serious going on
00:43:17 <scry1> JoeyA: no, it just complains about no signatures
00:44:09 <shachaf> preflex: seen ddarius
00:44:09 <preflex>  ddarius was last seen on #haskell 4 days, 6 hours, 51 minutes and 30 seconds ago, saying: Damn you Nishimura.
00:44:44 <JoeyA> (ruling out another obvious thing to check) Are you compiling with optimization?  e.g. ghc -O2 foo.hs
00:44:57 <scry1> just -O
00:45:49 <scry1> btw, can i make ghc recompile if nothing has changed?
00:45:51 <Cale> Okay, so here's a hint: it's basically all list cells.
00:46:55 <JoeyA> ghc -Wall -O2 -fforce-recomp
00:47:03 <scry1> no change with -O2. so it's about .4s ocaml, 2.4s haskell with n=10
00:47:06 <scry1> ah, thanks
00:47:26 <JoeyA> (though ghc -O1 and -O2 tend to be pretty similar, from my experience)
00:47:59 <scry1> list cells?
00:48:30 <scry1> what's wrong with that
00:48:34 <scry1> no unboxing?
00:50:43 <Cale> scry1: It means that you're making lists which are sticking around for a long time
00:51:07 <Cale> specifically, the memory usage drops drastically when I deepseq the 'choices' list before the 'any'
00:51:23 <Cale> (however, the program is still slow)
00:53:06 <mikeplus64> > let _scc_ = 1 in _scc_
00:53:07 <lambdabot>   <no location info>: parse error on input `='
00:53:11 <mikeplus64> > _scc_
00:53:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:55:43 <shachaf> scry1: Turning your infinite list into a list ..1000, like the OCaml code, seems to make the program much faster.
00:56:30 <Cale> Oh, yeah, it does
00:56:35 <Cale> I didn't even check that
00:57:21 <Cale> In fact, it's so much faster that it makes me wonder whether the program is correct
00:57:43 <Cale> (I don't know what it's meant to compute exactly)
00:57:51 <scry1> ok with deepseq, do i want Control.DeepSeq?
00:58:33 <Cale> Yeah, if you're going to do that at all
00:59:03 <Cale> The other change is the big one
00:59:24 * shachaf is suspicious of this ..1000 but doesn't quite understand the program yet.
00:59:45 <scry1> really? making the list finite doesnt seem to help me
00:59:53 <shachaf> Are you sure you're recompiling?
01:00:01 <shachaf> It makes it way faster for me.
01:00:08 <Cale> Yeah, it makes a *huge* difference
01:00:11 <scry1> oh shit, ok sorry
01:00:19 <Cale> It should be competitive with the O'Caml program then.
01:00:37 <scry1> i named the executable wrong
01:00:46 <Cale> The deepseq hurts time performance, so you probably don't want it at that point.
01:00:51 <shachaf> Cale: OCaml has been renamed!
01:00:56 <shachaf> There's no '\'' anymore.
01:01:08 <scry1> yes.. wow!
01:01:11 <Cale> But I like the '
01:01:39 <shachaf> O'well.
01:01:40 <scry1> wait, i thought lazy meant i didn't have to worry about this?
01:01:55 <Cale> scry1: Your program isn't computing the same thing anymore
01:02:05 <shachaf> scry1: If your takeWhile is going beyond 1000 elements, then you do.
01:02:17 <shachaf> Possibly the slow infinite-list version is more correct.
01:02:22 <Targen> What's the nice way of doing this? case event of { TheOneConstructorICareFor foo bar -> doSomething foo bar; _ -> return undefined }
01:02:43 <shachaf> "return undefined"?
01:02:53 <Targen> Basically, I don't care for the value of the whole thing.
01:03:07 <scry1> ah, but it should never get near 1000
01:03:17 <Cale> scry1: it does! :)
01:03:25 <srhb> Targen: Unit is more idiomatic.
01:03:27 <shachaf> scry1: It gets much past 1000.
01:03:33 <srhb> Targen: Consider putStrLn which return IO ()
01:03:46 <shachaf> It goes all the way to c+n, which is almost 5000.
01:03:52 <srhb> Targen: () has exactly one possible value, namely (), so it must be insignificant.
01:04:24 <shachaf> (() has two values. :-( )
01:04:26 <Targen> srhb: But doSomething isn't m ().  Is it better to do _ <- doSomething foo bar; return ()?
01:04:26 <Cale> shachaf: you're talking about for 10 or 15?
01:04:34 <shachaf> Cale: Er, for 20.
01:04:37 <srhb> shachaf: Are you including bottom?
01:04:52 <shachaf> But the same thing happens for 15.
01:04:52 <Targen> shachaf: For a generous definition of "value" :-)
01:04:55 <shachaf> And 10.
01:04:58 <shachaf> srhb: Yep.
01:05:02 <srhb> Targen: If i had to do that, yes.
01:05:05 <srhb> shachaf: Well, that's cheating. :P
01:05:06 <Cale> For 15 as input, cutting the list off at 5000 makes it terminate with a result after 18 seconds or so
01:05:15 <Cale> So I'm betting it's going beyond that
01:05:31 <shachaf> Hmm.
01:05:37 <shachaf> Well, it goes at least that far. :-)
01:05:43 <Cale> Time to import Debug.Trace ;)
01:05:45 <shachaf> (I just added a traceShow (c+n).)
01:06:00 <srhb> Targen: Since it is idiomatic in Haskell, ie. you already have functions that do side effects but return no meaningful value, just like putStr :: IO ()
01:06:26 <scry1> mmm, yes
01:07:12 <Targen> hm.
01:07:38 <scry1> my god, what was i thinking...
01:07:50 <Cale> I ran the original program on 15, and it got up to computing popCount of 21422 before running out of memory
01:08:31 <scry1> of course
01:08:48 <shachaf> popCount :: Integer -> Int is kind of an odd function...
01:09:14 <Cale> It counts how many 1 bits
01:09:15 <scry1> this grows like 2^(2^n) or something then
01:09:25 <scry1> yeah, hamming weight
01:09:33 <scry1> oh right - this is http://projecteuler.net/problem=391
01:09:38 <Cale> > map popCount [0..]
01:09:39 <lambdabot>   Not in scope: `popCount'
01:09:43 <scry1> for the record
01:09:43 <Cale> > map Data.Bits.popCount [0..]
01:09:45 <lambdabot>   Not in scope: `Data.Bits.popCount'
01:09:51 <Cale> blah
01:09:57 <scry1> yeah i had to get the latest GHC for that one
01:10:03 <Cale> oh, right
01:10:10 <Cale> It's new too :)
01:10:12 <shachaf> Cale: It seems to behave like id on positive Integers and to hand on negative Integers.
01:10:28 <Cale> shachaf: oh really?
01:10:44 <shachaf> That doesn't seem right...
01:10:51 <Cale> yeah, it sure doesn't
01:10:52 <shachaf> Well, I can understand hanging on negative numbers.
01:11:15 <scry1> have to cast to Int first right?
01:11:33 * ezyang is wrapping up the long delayed TMR Issue 20, and wondering what he should write for the editorial 
01:11:36 <Cale> Yeah, for Integer, popCount of a negative number, if anything, should be considered infinite :)
01:12:08 <scry1> *Main> popCount (4::Int)
01:12:08 <scry1> 1
01:12:16 <Cale> But it should still count the 1 bits correctly in the positive case. I say that's a bug.
01:12:21 <shachaf> Yep.
01:13:50 <shachaf> Hmm, I don't see where this definition is coming from.
01:14:43 <Taneb> I think I've just completely misunderstood what "Monads are just monoids in the category of endofunctors" means
01:15:05 <Taneb> mempty = return, mappend = (>=>)
01:15:06 <shachaf> Oh, it's fixed in base==4.5.0.1
01:15:10 <shachaf> It was broken in base==4.5.0.0
01:15:15 <Cale> > fix ((0:) . drop 1 . (>>= \n -> [n,n+1]))
01:15:17 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
01:15:45 <Taneb> That sequence looks familiar...
01:15:55 <shachaf> It went from «go c w = go (c+1) (w .&. w - 1)» to «go c w = go (c+1) (w .&. (w - 1))». :-)
01:15:57 <Cale> It should, it's the one we've been talking about
01:16:04 <Taneb> I just joined the channel
01:16:05 <scry1> yep
01:16:12 <Uakh> excuse me, but in a nutshell what would be the big differences between 'data' and 'newtype' ?
01:16:20 <shachaf> @google haskell data newtype
01:16:22 <lambdabot> http://www.haskell.org/haskellwiki/Newtype
01:16:22 <lambdabot> Title: Newtype - HaskellWiki
01:16:26 <shachaf> Uakh: That page explains it. :-)
01:16:56 <Cale> Uakh: Newtype only allows one constructor with one field.
01:17:02 <Taneb> The main difference is that newtype can only have one thing in it, but has less overhead?
01:17:08 <shachaf> (I mean 4.5.1.0.)
01:17:10 <Cale> Uakh: Pattern matching against a data constructor forces evaluation of the scrutinee
01:17:19 <Cale> Pattern matching against a newtype constructor does not
01:17:38 <Uakh> thanks, I actually don't know too much about Haskell, I mainly do Python, but one of my buddies who would port his mother to Haskell if he could is having an argument over these two and I just want him to shutup so we can resume talking about python idioms xD
01:18:08 <srhb> Uakh: If you'd told us first, we wouldn't have humored you. Entrapment, I say!
01:18:09 <Cale> Uakh: what's the argument?
01:18:32 <scry1> wow i pulled 4.5.0.0 like.. yesterday
01:18:38 <scry1> bad timing
01:18:49 <Uakh> whether it would be possible to merge this two and have automatic convertion as an optimization
01:19:00 <Uakh> since "newtype is a special case of data"
01:19:00 <Cale> Uakh: Basically, newtype has a semantics whereby the compiler can compile the constructor tag away to nothing.
01:19:01 <shachaf> scry1: It should work with Int in 4.5.0.0.
01:19:15 <shachaf> I think upgrading base isn't really a thing you do...
01:19:21 <Cale> Uakh: The semantics of data are such that the compiler isn't allowed to perform that optimisation.
01:19:23 <frerich> Hrm, I need to start noticing good use cases for 'fix'. The function always looks useless to me but everytime somebody who actually knows Haskell uses it I'm mucho impressed :-}
01:19:32 <Uakh> and I meant "these* two" obviously </grammar_nazi>
01:20:09 <scry1> yeah, totally not recompiling to save five keystrokes
01:20:21 <Cale> (they're different in terms of not only the operational semantics, but also the denotational semantics)
01:20:47 <Cale> In a way that affects termination behaviour.
01:21:00 <Uakh> scry1: the point wouldn't be to save keystrokes but to streamline the language
01:21:02 <Cale> In *most* programs I'd say it doesn't make a difference termination-wise
01:21:14 <Uakh> Haskell /= C ffs
01:23:31 <Uakh> oh thanks Cale, have fun with Haskell. Might learn it eventually. Or Clojure, though these are fairly different. ^_^
01:23:38 <danr> I find myself wishing for a function (k -> v) -> [k] -> Map k v too often
01:24:04 <shachaf> M.fromList . map (\x -> (x, f x))?
01:24:09 <Cale> danr: Or even  (k -> v) -> Set k -> Map k v
01:24:14 <danr> shachaf: yeah that one
01:24:32 <danr> Cale: yeah I guess we could put a traversable k even
01:24:36 <Botje> map (ap (,) f) -- surely
01:24:46 <danr> ooh
01:24:49 <danr> there is a fromSet
01:24:51 <danr> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map-Lazy.html#v:fromSet
01:24:54 <danr> @hoogle fromSet
01:24:55 <lambdabot> No results found
01:24:55 <scry1> Uakh: i'll streamline it after i solve this thing. compiling takes a while
01:25:01 <Cale> which *seems* like it could be written much more efficiently in an ideal world than flatting the Set via a list.
01:25:21 <danr> Cale: it is ^^
01:25:25 <typoclass> hoogle doesn't search the containers package?
01:25:42 <danr> it's containers 0.5, maybe it hasn't reindexed?
01:25:48 <shachaf> typoclass: It doesn't search packages unless you ask.
01:26:24 <srhb> You can ask Hoogle to search packages?
01:26:28 <typoclass> shachaf: fair point. does it count if danr asks? ;-)
01:26:42 <shachaf> typoclass: I'm afraid it has to be you.
01:26:44 <shachaf> Or geheimdienst.
01:26:50 <Cale> Taneb: figure out what that sequence was?
01:26:51 <shachaf> Or djahandarie, of course.
01:26:59 <danr> Botje: yeah I think I'll just go with <*> or ap for now
01:26:59 <Taneb> Haven't been thinking about it
01:27:06 <typoclass> @hoogle fromSet
01:27:06 <lambdabot> No results found
01:27:07 <Cale> Taneb: It's the number of 1's in the binary expansion of n.
01:27:17 <typoclass> shachaf: she's not humoring me
01:27:26 <danr> @hoogle flattenBinds +ghc
01:27:27 <lambdabot> Could not find some databases: ghc
01:27:27 <lambdabot> Searching in:
01:27:27 <lambdabot>   .
01:27:32 <Taneb> Cale, oh, cool
01:27:39 <Cale> > fix ((0:) . drop 1 . (>>= \n -> [n,n+1]))
01:27:40 <danr> works on the web interface at least
01:27:41 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
01:28:14 <typoclass> srhb: there's a command-line tool "hoogle" which can search your locally installed haddock documentation. it's handy, but last i checked, it was kinda complicated to set up
01:29:02 <srhb> Ah, right.
01:29:14 <Botje> ooh, fractally.
01:29:23 <danr> > let xs = 0 : drop 1 (xs >>= \n -> [n,n+1]) in xs
01:29:25 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
01:29:31 <frerich> > fix ((0:) . drop 1 . (>>= \n -> [n,n-1]))
01:29:33 <lambdabot>   [0,-1,-1,-2,-1,-2,-2,-3,-1,-2,-2,-3,-2,-3,-3,-4,-1,-2,-2,-3,-2,-3,-3,-4,-2,...
01:29:39 <frerich> Pity.
01:30:04 <danr> that's one weird sequence
01:30:08 <Targen> Well, this is certainly a bit mind-boggling.  This yields 0, of course.  newtype X = X (); case undefined of X _ -> 0
01:30:09 <Nereid> > fix ((0:) . drop 1 . (>>= \n -> [n,1-n]))
01:30:11 <lambdabot>   [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,...
01:30:52 * frerich is royally impressed by Cale being able to whip that up as if it's the easiest thing in the world :-)
01:30:53 <Nereid> Targen: of course. for a newtype, _ and X _ match the same way.
01:30:53 <Cale> > map (`mod` 2) $ fix ((0:) . drop 1 . (>>= \n -> [n,n+1]))
01:30:56 <lambdabot>   [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,...
01:31:03 <danr> Targen: for newtypes, we have X u = u, and case undefined of _ -> 0 is also 0
01:31:12 <Nereid> ^
01:31:13 <Targen> Indeed.
01:31:32 <Cale> frerich: :)
01:32:26 * danr is also impressed
01:33:43 * scry1 is a bit intimidated
01:34:10 <scry1> fix, huh? looks like black magic to me
01:34:25 <Cale> fix f = x where x = f x
01:34:55 <Cale> > fix (0:)
01:34:56 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
01:35:02 <shachaf> Expand it out:
01:35:03 <shachaf> fix ((0:) . drop 1 . (>>= \n -> [n,1-n]))
01:35:10 <shachaf> let x = ((0:) . drop 1 . (>>= \n -> [n,1-n])) x in x
01:35:15 <Cale> > fix ((0:) . map (+1))
01:35:17 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
01:35:43 <Cale> > fix ((0:) . scanl (+) 1)
01:35:46 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:35:47 <scry1> oh man...
01:35:54 <Cale> :D
01:36:02 <Nereid> just expand out the first couple steps of the recursion and you'll see.
01:36:12 <scry1> oh i see.
01:36:21 <scry1> black magic as i suspected
01:36:23 <scry1> :P
01:36:27 <Nereid> any recursive can be written with fix (and no other recursion).
01:36:41 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
01:36:42 <lambdabot>   3628800
01:37:09 <scry1> that is pretty sick
01:37:25 <Cale> fix makes a good compiler primitive to compile recursion into so as to be able to handle it in one place uniformly
01:37:27 <shachaf> fun fact 0 = 1
01:37:39 <Nereid> I just noticed that I a noun in my last line.
01:37:42 <Targen> The fun part is that fix is just foldr. :)
01:37:50 <shachaf> Targen: Huh?
01:38:04 <Targen> Well, not directly, of course.
01:38:05 <Cale> Well, you can implement fix using foldr in a funny way
01:38:11 <shachaf> Cale: Can fix do polymorphic recursion?
01:38:28 <Nereid> > let fun = id; fact n = product [1..n] in fun fact 0
01:38:30 <lambdabot>   1
01:38:45 <shachaf> Ah, I guess type-checking is a different level from where you'd use it in the compiler.
01:39:07 <Cale> shachaf: It depends, I think
01:39:18 <Cale> You might need to take fixed points of higher rank things?
01:39:35 <startling> Nereid: that's a fun fact if I ever saw one
01:40:03 <Targen> fix f = foldr (\_ -> f) undefined (repeat undefined)
01:40:30 <shachaf> "you can define fix in terms of foldr if you have repeat!"
01:40:41 <Targen> http://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf explains it.
01:40:46 <shachaf> (Which you need fix or something equivalent to define, on non-co-lists.)
01:42:12 <Cale> shachaf: Still, repeat undefined makes a pretty nice primitive :)
01:42:40 <Cale> (and I suppose foldr itself is already recursive too)
01:42:46 <shachaf> Cale: Can we at least use repeat ()?
01:42:52 <Cale> NO
01:42:58 <shachaf> OK, OK!
01:43:22 <Cale> actually, that does work here too
01:43:28 <Cale> but still
01:43:44 <shachaf> You still need undefined for the other part too?
01:43:46 <Nereid> map (const ()) (repeat undefined)
01:43:47 <shachaf> :-(
01:43:48 <Cale> yeah
01:43:56 <bartavelle> there should be a generic way to debug obviously right algorithms that produce obviously wrong values
01:44:28 <Targen> bartavelle: grep Double :)
01:44:31 <Nereid> there is -- it's the obvious way
01:44:37 <bartavelle> ;)
01:44:38 <typoclass> bartavelle: i think there is. it's called computer science ;-)
01:45:05 <Cale> There should be a generic way to fix obviously right proofs that produce obviously wrong conclusions
01:45:34 <ezyang> import Philosophy; ...
01:46:33 <quicksilver> Cale: legislation?
01:47:35 <Taneb> Entirely new system of logic?
01:48:21 <startling> Cale, fire
01:49:24 <Cale> There's someone in the bar, who if he's drinking, then everyone in the bar is drinking.
01:49:49 <typoclass> "what barber is he shaved by?"
01:49:56 <Cale> (this is true, btw, and it's not really all that mysterious)
01:49:58 <ezyang> Ah, that's easy: exclude the axiom of excluded middle :-)
01:50:01 <startling> typoclass: himself
01:50:12 <shachaf> Cale: For any bar!
01:50:24 <Cale> shachaf: indeed
01:50:36 <startling> Cale, is he the only person in the bar?
01:50:43 <Jafet> This is logic on beer
01:50:49 <shachaf> Yay, Smullyan.
01:51:00 <Cale> More generally,  exists x. (D(x) -> forall y. D(y))
01:51:03 <shachaf> startling: The statement is true for any bar.
01:51:21 <Cale> For any predicate D
01:51:26 <Targen> Do we even know if a bar exists?
01:51:31 <ezyang> http://logitext.mit.edu/logitext.fcgi/proving/exists+x.2E+.28D.28x.29+.2D.3E+forall+y.2E+D.28y.29.29
01:51:53 <Cale> Hint: it's equivalent to  exists x. (not (forall y. D(y)) -> not D(x))
01:54:29 <quicksilver> Cale: "true"
01:54:41 <quicksilver> it does depend rather on your notion of logical semantics.
01:55:29 <quicksilver> if you have a possible worlds semantics in which you require the representative (x) be uniformly chosen across other worlds y in which various combinations of drinkers exist
01:55:35 <quicksilver> then it's not valid.
01:55:50 <quicksilver> (which is roughly the intuition formed by people who think it doens't sound like it should be valid)
01:56:03 <Cale> http://cale.yi.org/share/DrinkingParadox.png -- proof!
01:56:49 <ezyang> :-)
01:57:23 <typoclass> cale: many of your letters seem to be so drunk they've fallen over
01:57:37 <JoeyA> Cale: What did you use to make that logic tower thingy?
01:57:44 <Cale> http://logitext.mit.edu/logitext.fcgi/proving/exists+x.2E+.28D.28x.29+.2D.3E+forall+y.2E+D.28y.29.29
01:57:59 <ezyang> sorry, website is being buggy, just a moment
01:58:25 <JoeyA> (the drinking paradox requires the assumption that at least one person in the bar exists, right?)
01:58:38 <Cale> JoeyA: no.
01:58:52 <Cale> It is unconditionally true.
01:58:58 <JoeyA> Oh
01:59:02 <ezyang> ok, website has been kicked
01:59:47 <Cale> JoeyA: exists x. D(x) -> (forall y. D(y)) is even true regardless of what the predicate D is
01:59:50 <JoeyA> Actually, I disagree.  exists x. (not (forall y. D(y)) -> not D(x)).  If the bar is empty, then there doesn't exist an x such that anything.
01:59:56 <Cale> For example, D could be "is made of cheese"
02:00:30 <Cale> And we're forced to conclude that there is an x such that if x is made of cheese, then everything is made of cheese :D
02:00:47 <ezyang> forall y. D(y) is true when the universe is empty
02:01:14 <ezyang> and implications are true when their hypothesis is false
02:01:39 <yitz> Cale: for example, if this paradaox is made of cheese
02:03:26 <yitz> JoeyA: i think you are saying what quicksilver said above
02:04:25 <Cale> It basically just sounds a bit weird when worded that way because the way we use words in English and in logic are not always identical.
02:05:08 <Cale> In particular, we have certain expectations that creep in when someone says "if ... then ..." which aren't logically required.
02:05:19 <Cale> (at least by classical logic)
02:05:44 <barrucadu> if/then in everyday English is more of ain intuitionist way of doing it
02:05:48 <JoeyA> For every bar, there exists a person such that, every time he drinks, everybody drinks.
02:05:59 <JoeyA> That's what it sounds like the drinking paradox is saying.
02:06:11 <Cale> and if you formalise that, it's true.
02:06:25 <barrucadu> In a given bar, there is some person such that if he is drinking, everyone is drinking
02:06:31 <JoeyA> No, I'm saying *every day*, that *same person*.
02:07:26 <Cale> JoeyA: except that there can be more than one
02:07:41 <Cale> Usually most of the people satisfy the condition :P
02:08:07 <Cale> Depending on how hard people are drinking, I guess :)
02:08:17 <barrucadu> Wikipedia has a little explanation of it which I found handy
02:08:21 <barrucadu> http://en.wikipedia.org/wiki/Drinker_paradox
02:08:49 <startling> does he never drink?
02:09:00 <barrucadu> He can do
02:09:00 <JoeyA> forall bar, exists person, forall day, Drinking person day -> forall person', Drinking person' day.
02:09:04 <Cale> JoeyA: Sometimes in order to show that P -> Q is true, it's easier to show P false than to prove Q :)
02:09:37 <startling> ahhh, I understand
02:09:42 * startling reaches enlightenment
02:09:48 <quicksilver> Cale: if you formalise it *in certain logical frameworks* it's true *in the sense shown by that framework*.
02:10:17 <Cale> JoeyA: All I have to do is, for each day, either find a person who isn't drinking on that day, in which case "Drinking person day -> anything"
02:10:36 <Cale> JoeyA: or if I can't do that, well, then everyone must be drinking, so the conclusion is true
02:10:50 <startling> either a) at least one person is not drinking, or b) everyone is drinking
02:11:03 <Cale> oh, quantifier order :P
02:11:41 <JoeyA> What I mean is: for what I posted to be true, you have to pick a person, and they have to be the person that implies that everyone drinks *every day*.
02:11:47 <Cale> Right
02:12:02 <Cale> Which isn't true anymore, I think.
02:12:04 <barrucadu> But what you posted is a different proposition
02:12:10 <JoeyA> Indeed.
02:12:20 <startling> why does Data.ByteString.index take Int rather than Integer?
02:12:24 <JoeyA> What I'm saying is, that's what it sounds like someone's saying.
02:12:30 <JoeyA> Why should it take Integer?
02:12:44 <startling> JoeyA: what if my ByteString is bigger than my machine word?
02:12:51 <startling> :P
02:13:03 <startling> it just seems like an odd place to stick that restriction
02:13:17 <JoeyA> Well, Integer is less efficient.
02:13:48 <typoclass> JoeyA: let's all use assembler!
02:13:53 <JoeyA> Especially for tight loops involving strings.
02:15:16 <quicksilver> startling: bytestrings bigger than machine words are quite hard to manage
02:15:28 <quicksilver> startling: (since machine words are, typically, also your available memory space)
02:15:34 <barrucadu> Would it using Integral be a way around that (speed for "small" indices, whilst allowing massive indices)?
02:15:38 <Twey> startling: ByteString is a list, and list indexing &c. uses Int
02:15:38 <startling> quicksilver, what if it's lazy and contains the same element over and over again?
02:15:48 <quicksilver> Twey: ?
02:15:54 <Twey> :t (!!)
02:15:55 <lambdabot> forall a. [a] -> Int -> a
02:15:57 <quicksilver> bytestring certainly isn't a list.
02:16:07 <Twey> Lazy bytestring is, no?
02:16:08 <quicksilver> startling: containing the same element over and over again is not relevant.
02:16:14 <Twey> List of chunks, I thought.
02:16:30 <startling> quicksilver, I could have such a bytestring, though, without running out of memory, couldn't I?
02:16:31 <quicksilver> startling: however, it's certainly true that you *can* have bytestrings longer than a machine word. I'm just syaing it's quite hard to acheive.
02:16:33 <Targen> Can a cyclic lazy bytestring be constructed?
02:16:54 <quicksilver> startling: you can have a lazy bytestring longer than memory, if you only access it bit by bit.
02:16:56 <Targen> (through the regular API, of course)
02:17:02 <quicksilver> startling: but having the same element over and over again is not relevant.
02:17:06 <quicksilver> it doesn't save any space.
02:17:07 <startling> Targen: from what I understand, lazy bytestrings are kind of like lists of strict bytestrings
02:17:15 <quicksilver> bysestrings don't do run-length encoding
02:17:18 <quicksilver> or anything similar.
02:17:22 <quicksilver> Targen: no.
02:17:27 <startling> quicksilver, ah, alright
02:17:44 <Targen> startling: Internally, yes.  But I don't think it's actually possible to construct such a list with a cyclic reference through the regular ByteString.Lazy API.
02:17:46 <quicksilver> Twey: lazy bytestrings are indeed basically lists of chunks, but I don't think that's particularly relevant to why Int is used.
02:18:11 <startling> Targen: oh hmm, dunno
02:19:32 <Nereid> Targen: fromChunks?
02:20:57 <Targen> Actually, never mind.  Data.ByteString.Lazy.cycle
02:22:42 <JoeyA> Data.ByteString.Lazy.index takes an Int64 argument.
02:23:12 <quicksilver> Targen: well I never :)
02:23:17 <quicksilver> Targen: I did not know that....
02:23:23 <Targen> Ditto.
02:29:25 <pozic_> Are there any completely lockless multi-threaded message passing implementations with such operations as createMailbox, getMessageFromMailbox, etc. ?
02:29:59 <pozic_> By that, I mean that not only on API user level there are no locks, but I mean that there are no locks at all.
02:30:30 <pozic_> (and there is no O(n^2) overhead)
02:31:01 <ezyang> Not in Haskell :^)
02:31:25 * hackagebot network-metrics 0.2.2 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
02:32:04 <pozic_> ezyang: I meant more like anywhere.
02:32:22 <pozic_> Or an impossibility proof of something like that.
02:32:42 <scry1> how could there be?
02:32:44 <ezyang> So, is this "lockless" in the sense of "lockless data structures"?
02:33:20 <pozic_> ezyang: perhaps I should have said 'no explicit synchronization'.
02:33:38 <pozic_> ezyang: but you could interpret it as lockless as in lockless data structures.
02:33:48 <scry1> at that point how is it different from multiple processes?
02:34:21 <ezyang> I don't understand the 'no explicit synchronization' sense. "What about STM?"
02:34:40 <ezyang> Or, are you referring to STM when you talk about O(n^2) overhead?
02:34:59 <pozic_> ezyang: are you sure there are no atomicity operations in STM?
02:35:18 <ezyang> pozic_: There are no locks in STM :-)
02:35:23 <pozic_> ezyang: e.g. no compare and swap, etc.
02:35:55 <ezyang> See, this is what I mean by "I don't understand what you mean by no explicit synchronization"
02:36:04 <pozic_> ezyang: I am also not talking about STM, because threads can still step on each other's toes, although there is progress.
02:36:10 <ezyang> Of *course* STM is implemented with locks. Even vanilla Haskell is implemented with locks
02:36:51 <ezyang> "threads can still step on each other's toes" --> what do you mean?
02:37:47 <ezyang> To be more clear, there is a difference between a lock free *programming model*, and a lock free *implementation method*
02:38:07 <pozic_> I am merely talking about having N threads on M<<N cores that do message delivery of byte streams without explicit synchronization.
02:38:13 <quicksilver> I think pozic_ you have in your head a longer set of requirements but you're not going to get good answers unless you can share that.
02:38:16 <pozic_> So, the CPUs do not support any CAS.
02:38:23 <quicksilver> you initially forbade locks and now you're forbidding CAS
02:38:57 <pozic_> Any synchronization can only be linear in the length of the messages sent.
02:39:27 <pozic_> quicksilver: sure, you can also implement locks via Lampport's algorithm, IIRC.
02:39:54 <ezyang> That's a really weird restriction on what synchronization you can do. Or maybe I'm misunderstanding.
02:44:41 <pozic_> ezyang: I think it can even be done with O(1) time.
02:45:03 <typoclass> pozic_: "linear in the length of the messages" -- so you have only one channel that all those messages are transmitted over?
02:45:36 <pozic_> typoclass: every thread has one mailbox.
02:45:56 <pozic_> typoclass: but you can send messages to any thread.
02:46:24 <pozic_> I have already seen MPI implementations which are lockless, but I wonder how they are implemented.
02:49:28 <zaargy> not sure where to ask this but is there a word for the kind of polymorphism you get by passing first-class functions as parameters?
02:50:15 <frerich> zaargy: Are you thinking of "higher order functions"?
02:50:54 <zaargy> that's when functions return other functions no?
02:51:06 <Nereid> or take functions as arguments
02:51:16 <zaargy> fair enough
02:51:31 <pozic_> zaargy: higher rank polymorphism?
02:51:42 <pozic_> zaargy: or rank-N polymorphism.
02:51:46 <Nereid> zaargy: I don't see what that has to do with polymorphism though
02:52:10 <zaargy> Nereid: could you clarify?
02:52:12 <pozic_> He likele means that his functions take polymorphic functions are arguments.
02:52:15 <frerich> Nereid: To be fair, I suggested 'higher order functions', not him.
02:52:26 <Nereid> hm
02:52:39 <Nereid> I don't know what he means.
02:52:40 <pozic_> as arguments*
02:52:51 <zaargy> what pozic_ said
02:52:59 <Nereid> then that's rank-2 polymorphism.
02:53:10 <zaargy> okay
02:53:33 <pozic_> zaargy: there is a paper on that which will teach you what is rank 1, rank 2,... rank N.
02:53:40 <typoclass> i thought half of the lockfree thingies are just optimistic. they try to let every thread have his way, detect collisions, and rollback if necessary *shrug*
02:53:49 <zaargy> oh yeah? that might be good to have a look at
02:53:59 <Targen> This one explains how Haskell makes sense of it: http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/
02:54:27 <Targen> But not what it is in a general sense.
02:55:05 <Targen> (well, it *is* explained, but quite tangentially)
02:55:39 <hiptobecubic> zaargy, I had a similar question the other day. Maybe this will help. I don't know if you can read haskell or not. http://hpaste.org/71938
02:56:43 <hiptobecubic> zaargy, the type of doStuff on line 12 is only rank1, so this does not type check because line 14 and 15 would require that f be polymorphic INSIDE the dostuff function
02:57:45 <typoclass> does RankNTypes imply NoMonomorphismRestriction?
02:57:48 <hiptobecubic> using the (commented out) type on line 11 *does* work, because now we've stated explicitly that f is polymorphic in c (given that c is also a Foo), so the dostuff function knows that f will work on both line 14 and 15
02:58:33 <hiptobecubic> typoclass, that's how stm work i think. (the rollback)
02:59:03 <zaargy> but i don't see what rank-2 polymorphism has to do with my question? :S
02:59:52 <Nereid> rank-2 polymorphism is when you have a function which takes a (rank-1) polymorphic function as an argument
02:59:58 <typoclass> zaargy: folks were not exactly sure what you were asking, but the word polymorphism was in there :-)
03:00:44 <Nereid> (or returns such a function, perhaps, but you don't get anything new in that case)
03:00:52 <Targen> zaargy: let foo f = (f [1,2,3 :: Int], f ['a', 'b', 'c']) in foo reverse
03:00:58 <hiptobecubic> zaargy, in the example. 'f' is polymorphic. but if you pass it as a paramter, the type gets "fixed" by the caller and so it can't be polymorphic inside the calling function. you need rank2 (or 3 or n) to get the higher order polymorphism
03:00:59 <Targen> zaargy: What is the type of foo?
03:02:05 <scry1> :t let foo f = (f [1,2,3 :: Int], f ['a', 'b', 'c']) in foo reverse
03:02:07 <lambdabot>     Couldn't match expected type `Char' against inferred type `Int'
03:02:07 <lambdabot>       Expected type: [Char] -> t
03:02:07 <lambdabot>       Inferred type: [Int] -> t1
03:02:15 <scry1> > let foo f = (f [1,2,3 :: Int], f ['a', 'b', 'c']) in foo reverse
03:02:17 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
03:02:17 <lambdabot>         against inferred type...
03:02:25 <Targen> Indeed.
03:02:34 <Nereid> haskell doesn't infer higher-rank polymorphic types.
03:02:50 <Nereid> well
03:02:50 <hiptobecubic> Why not though?
03:02:52 <quicksilver> but did zaargy really mean to ask about polymorphism at all?
03:02:58 <Jafet> > let foo :: (forall a. [a] -> [a]) -> ([Int], [Char]); foo f = (f [1..3], f "abc") in foo reverse
03:02:59 <Targen> Probably not.
03:03:00 <lambdabot>   ([3,2,1],"cba")
03:03:04 <ezyang> It's undecidable, IIRC
03:03:10 <Jafet> cubic: it's pretty hard to do
03:03:12 <scry1> so typeclasses are really a bit of a hack
03:03:14 <Jafet> What ezyang said
03:03:16 <quicksilver> it's worse than undecidable
03:03:17 <Targen> It's decidable, but ugly.
03:03:18 <scry1> is it decidable?
03:03:25 <quicksilver> it's non-confluent
03:03:46 <hiptobecubic> oh no! non-confluent!?
03:04:03 <quicksilver> you can find multiple possible ways to type a single expression.
03:04:05 <Jafet> The most general type isn't unique
03:04:08 <ezyang> Wait, I didn't know type inference could be non-confluent
03:04:11 <Targen> oh, oops, I misspoke.
03:04:13 <hiptobecubic> i hate things that aren't confluent.
03:04:14 <ezyang> Oh, that's what you mean?
03:04:22 <mekeor> Is anyone using arrow syntax nowadays?
03:04:25 <ezyang> I'm pretty sure confluence means something else...
03:04:48 <Jafet> Shush, we're doing lambda calculus at the type level now
03:05:00 <zaargy> i don't know if polymorphism is the word i wanted
03:05:00 <quicksilver> ezyang: confluence - as a property of a set of rewrite rules - means that if two different rules apply, it doesn't matter which you choose, you will reach the same place later in the reduction.
03:05:06 <zaargy> i used it to mean can take many forms
03:05:19 <zaargy> i was just using the language i know, rightly or wrong in this context :P
03:05:36 <ezyang> Right. I thought type inference was definitely /not/ a set of rewrite rules >:-)
03:05:54 <mikeplus64> mekeor: i haven't seen it in use, but i remember on the multiwayif/lambdacase issue/bug tracker someone saying that it'd be convenient in arrow notation
03:05:58 <mikeplus64> so i guess someone does
03:06:23 <Nereid> zaargy: well we still don't know what you meant, then...
03:06:42 <Nereid> maybe an example would help?
03:06:49 <zaargy> what's the problem with polymorphism?
03:07:03 <quicksilver> ezyang: typing rules are rewrite rules (in the term language of typing judgements)
03:07:07 <Nereid> problem?
03:07:10 <mekeor> mikeplus64: hm, okay
03:07:12 <zaargy> um maybe i see
03:07:24 <zaargy> the probelm is describing functions as polymorphic?
03:07:47 <ezyang> quicksilver: Even the constraints? :-)
03:07:52 <quicksilver> ezyang: yes.
03:08:03 <quicksilver> ezyang: you can put it all together as a set of rewrite rules if you want to.
03:08:10 <ezyang> Oh. Ok.
03:08:32 <Jafet> Well, every turing machine is a set of rewrite rules
03:08:33 * ezyang files away 'lacks principle types' as 'not confluent' 
03:10:02 <quicksilver> ezyang: it's certainly abusing terminology since principle typing is a property of the system, whilst confluence is a property of an *algorithm*
03:10:07 <quicksilver> but well, the notions are all related.
03:11:16 <scry1> Jafet: are you sure? then lambda calculus is as well?
03:13:10 <Jafet> Lambda calculus is one rewrite rule: (\x. t) y ::= t[x <- y]
03:13:26 <scry1> i thought rewrite rules basically correspond to a CFG
03:14:18 <Jafet> Context-free grammars consume input, they don't rewrite it
03:14:24 <mekeor> can i define "class synonyms"? i'd like to be able to write (Arrow (:->) => x :-> y) (using -XTypeOperators) instead of (Arrow a => a x y).
03:15:06 <Twey> mekeor: That's not really something that makes sense
03:15:13 <mekeor> Twey: it looks nicer.
03:15:31 <quicksilver> you don't need class synonyms to be allowed to use variable names
03:15:40 <mekeor> Twey: it's more similar to (->) which is also an arrow.
03:15:41 <Twey> mekeor: Your declaration would change from ‘Arrow a ⇒ a x → a y’ to ‘(:->) a ⇒ a x → a y’
03:15:48 <quicksilver> Arrow (~>) => x ~> y
03:15:49 <mekeor> (the most important one, even, probably.)
03:15:51 <quicksilver> used to work fine
03:16:04 <quicksilver> I have some vague memory of a change in typeoperators which broke everything though
03:16:07 <Twey> mekeor: The nice thing to do (which many people do) is to make the *instance* an operator, as quicksilver just demonstrated
03:16:15 <quicksilver> that's not an instancew
03:16:21 <quicksilver> it's just a type variable in a signature
03:16:31 <quicksilver> wherever you use signatures, you get to choose your variables
03:16:34 <Twey> Ehh
03:16:49 <Twey> quicksilver: A type variable that's restricted to be an instance of Arrow
03:16:55 <quicksilver> it always used to be permitted to choose symbolic variables for binary classes
03:17:07 <quicksilver> but, as I said, I do remember reading something about a change in TypeOperators breaking this
03:17:09 <Twey> Why'd they change TypeOperators?
03:17:59 * quicksilver doesn't remember, but is trying to find the thing he was talking about
03:18:22 <mekeor> quicksilver: thanks, couldn't think about that :D
03:18:35 <Twey> « A type variable can be an (unqualified) operator e.g. +. The lexical syntax is the same as that for variable operators, excluding "(.)", "(!)", and "(*)". In a binding position, the operator must be parenthesised. » — GHC 7.2.2 docs
03:19:00 <quicksilver> here you are:
03:19:01 <quicksilver> http://www.haskell.org/pipermail/glasgow-haskell-users/2012-January/021611.html
03:19:08 <mekeor> Twey: also, "Arrow a ⇒ a x → a y" is wrong since Arrow is a multi-parametric class…
03:19:34 <quicksilver> they wanted to permit type constructors to begin with anythign not just :
03:19:44 <quicksilver> sorry that wasn't clear
03:19:51 <quicksilver> they wanted to permit *infix* type constructors to begin with anythign not just :
03:20:05 <quicksilver> and the trade-off is that you lose the ability to have infix type variables at all
03:20:13 <quicksilver> since all infix types are assumed to be constructors.
03:20:29 <quicksilver> I'm not sure if the plan went ahead or which GHC version it went into though
03:20:37 <Twey> mekeor: Yes, but you get the idea.
03:21:11 <Twey> Making the variable an operator is nicer than making the class an operator.
03:21:11 <mekeor> quicksilver: oh.
03:21:17 <Twey> quicksilver: But, but why?  ☹
03:21:44 <mekeor> Twey: aah, yeah. now i got it :D
03:21:46 <Nereid> ☃
03:22:07 <quicksilver> well the why is mostly in that email I think
03:22:18 <quicksilver> the namespace for type operator syntax constructors was too small
03:23:40 <Twey> quicksilver: Nonsense… it's as big as the normal operator space, just with a : prepended
03:24:23 <Twey> Requiring : is a *trivial* downside compared to having no operator variables at all.
03:24:26 <Jafet> But think of the huffman codes
03:24:37 <Twey> Heh
03:36:29 * hackagebot wai-routes 0.2 - Typesafe URLs for Wai applications. (AnupamJain)
03:38:15 <Philippa> mornin'
03:38:43 * typoclass waves
03:39:12 <Philippa> hey. Nice nick!
03:39:29 <typoclass> thanks ;-)
03:39:30 <Philippa> it's, um. Too damn early for me to be coding on a train, even if I am supposedly on UK time
03:39:42 <Philippa> but I had an amusing realisation about my current project, at least
03:42:10 <Philippa> so I'm building this little language which exists solely to try out a variation on extensible syntax, right?
03:42:22 <Philippa> you have to declare new keywords in advance, to give the lexer a chance
03:43:06 <Philippa> the bit of fun? When you import a keyword from a module, I could offer the facility to /rebind/ it. import Control.Monad (keyword do = mdo); import Control.Applicative (keyword do = ado)
03:43:35 <mauke> btdt
03:44:37 <typoclass> sounds pretty handy so far
03:45:00 <Philippa> mauke: which bit of the design space did you end up in?
03:45:09 <mauke> huh? I wrote a Perl module
03:45:25 <Philippa> ah, missing context from before I joined?
03:45:28 <mauke> no
03:45:43 <Philippa> oh, perl's even worse than I remember then :-)
03:46:02 <mauke> the module I wrote implements keywords, and you can customize them on import
03:46:23 <mauke> use Function::Parameters; fun foo($x, $y, $z) {}
03:46:36 <mauke> use Function::Parameters { proc => 'function' }; proc foo($x, $y, $z) {}
03:46:43 <Philippa> I've picked what should actually be a pretty well-behaved design, though. Fairly limited in capability (you won't be doing case compilation with it!), using a grammar formalism that lets me check for collisions and stuff still
03:48:15 <Philippa> re. Did I mention I'm on a train? Not the most stable of connections
03:48:24 <typoclass> of course perl doesn't so much count as part of the design space as it counts as part of the design atmosphere. a thick, toxic, abrasive atmosphere
03:48:50 <mauke> typoclass: s/perl/haskell/ and it's equally true
03:49:43 <Philippa> mmm. There are a few things you can distill as quintessentially haskell, but the range of type system extensions contains some surprisingly fast-moving, rapidly-interacting stuff
03:51:30 <Philippa> mauke: I'm poking around on CPAN, if I've understood correctly you basically use part of perl's own implementation code to do it?
03:51:46 <typoclass> mauke: i was kidding, in case that wasn't apparent. but i don't subscribe to the theory that every programming language is as good as any other
03:52:10 <Philippa> (which is to say: fair play, insofar as that's a concept in such languages, but I'm aiming at something that doesn't require an implementation-defined language?)
03:52:19 <benmachine> am I the only one who thinks the behaviour of Arbitrary Rational is a bit silly?
03:52:42 <mauke> Philippa: I use Perl's parser to process subroutine bodies
03:53:00 <mauke> because I don't feel like reimplementing all of Perl :-)
03:53:21 <Ngevd> My quest to explain what is meant by "Monads are just monoids in the category of endofunctors" has hit a nasty stumbling block
03:53:22 <mikeplus64> with typeclasses, is it enough to inline just the type definition, or do I have to put inline around the function definitions as well?
03:53:25 <Ngevd> I can't explain what a category is.
03:53:38 <Ngevd> Or an endofunctor, for that matter
03:53:47 <mikeplus64> (nevermind you can't put inline above just the type)
03:54:49 <benmachine> Ngevd: an endofunctor is a functor whose domain and codomain are the same
03:54:57 <benmachine> (i.e. from a category back into itself)
03:55:09 <Philippa> mauke: right :-)
03:55:14 <Ngevd> benmachine, right.
03:55:24 <Ngevd> I'm going to slowly gain intuition about this
03:55:26 <typoclass> Ngevd: i think that quip was meant as a joke. it may make sense to experts, but it wasn't written to really explain anything to anyone
03:55:36 <Philippa> (similarly I'm not going to reimplement all of Haskell, in fact my 'core' language doesn't even have let right now. Or an evaluator...)
03:55:54 <benmachine> Ngevd: I'm not sure you /need/ to know this; it's probably not helpful unless you already understand it :)
03:56:07 <Ngevd> typoclass, I'm hoping that by doing this I'm going to end up as an expert. I can live in hope.
03:56:08 <Philippa> typoclass: sort of. It's one of those "just" things where if you've understood what monoids and endofunctors are it might *really* be a 'just' realisation?
03:56:12 <Philippa> brains are funny like that
03:56:36 <benmachine> yeah, I mean, it's interesting to me, because I've done some category theory and lots of maths
03:56:38 <Ngevd> benmachine, I'm going to make the most sidetracking monad tutorial ever.
03:57:03 <benmachine> but I don't think it's particularly fundamental to how we use monads in haskell
03:57:11 <Philippa> done well, that could be a really good thing
03:57:24 <typoclass> Philippa: you're right, if you know all the component terms, you might learn that connection as something new
03:57:27 <Philippa> yeah. Honestly? The way we use monads in haskell, what matters are things like "why is bind called bind?"
03:57:44 <Philippa> typoclass: and even simplifying, yeah
03:57:54 <mauke> "because >>= is hard to pronounce"
03:57:57 <benmachine> I like the fish operator as the core of monads
03:58:04 <benmachine> :t (<=<) -- i.e. this one
03:58:06 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
03:58:15 <mauke> <))><
03:58:30 <owst> benmachine: it certainly made the monad "laws" (in haskell) make more sense
03:58:30 <benmachine> it's like composition only more so?
03:58:35 <Philippa> >>= has a nice relationship to the natural transformations that are the 'traditional' core of monads, but yeah
03:58:45 <Philippa> you end up drowning in .s
03:59:13 <benmachine> owst: yep. but it's also a great perspective (imo) on why monads are interesting, cf. http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
03:59:22 <typoclass> benmachine: sounds good. "it's like (.) but inside the whole monad business"
03:59:43 <benmachine> typoclass: right. I find it interesting that everyone goes on about how you can also define bind in terms of join
03:59:45 <quicksilver> Twey: sure. I wasn't defending it.
03:59:45 <int-e> mauke: yeah monads are fishy like that
03:59:50 <benmachine> but no-one mentions that you can define bind in terms of fish
04:00:19 <Philippa> join is interesting because you can see that signature and immediately conclude that "monadic languages" are higher-order, though
04:00:43 <Philippa> in a way that's amusingly related to the history of lisp, in fact :-)
04:00:54 <Twey> Oh?
04:00:54 <benmachine> well, lots of things are interesting :P
04:00:59 <mauke> mx >>= f = (<=<) f (const mx) ()
04:01:17 <Philippa> Twey: join is "runMonadM". That's *exactly* how they first did HOFs in lisp - using eval
04:01:25 <Philippa> I'm going to disappear in a mo btw, my train's pulling in
04:01:25 <Twey> Huh.  Neat.
04:01:38 <benmachine> :t \mx f -> f <=< id $ mx
04:01:40 <lambdabot> forall b (m :: * -> *) c. (Monad m) => m b -> (b -> m c) -> m c
04:01:59 <mikeplus64> @pl let f x y = f (append x y)
04:02:00 <lambdabot> (line 1, column 27):
04:02:00 <lambdabot> unexpected end of input
04:02:00 <lambdabot> expecting variable, "(", operator, ";" or "in"
04:02:01 <benmachine> mauke: are our definitions the same?
04:02:07 <mikeplus64> @pl f x y = f (append x y)
04:02:08 <lambdabot> f = fix ((. append) . (.))
04:02:11 <zaargy> is it correct to call a function polymoprhic e.g. there is no difference between + and -?
04:02:19 <benmachine> I suppose they are
04:02:41 <benmachine> zaargy: I have no idea what you are talking about
04:03:05 <mauke> benmachine: what definitions? I've just tried to make the types line up
04:03:12 <zaargy> i guess it's not correct then
04:03:13 <benmachine> mauke: so did I, but in a different way
04:03:16 <zaargy> ...
04:03:18 <zhulikas> :t (<=<)
04:03:19 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
04:03:28 <benmachine> zaargy: that doesn't necessarily follow :P
04:03:32 <zaargy> re: earlier conversation
04:03:59 <zaargy> rank-2 polymorphism is when you have a function which takes a (rank-1) polymorphic function as an argument
04:04:04 <zaargy> someone said earlier
04:04:13 <zaargy> what does it mean for a function to polymorphic is my question?
04:04:31 <benmachine> zaargy: it can adopt more than one type, I suppose
04:04:51 <typoclass> @type (+)   -- this is an example of a polymorphic function. it can take an Integer, or an Int, or a Float, etc. it can take anything for which we have a Num instance
04:04:53 <lambdabot> forall a. (Num a) => a -> a -> a
04:05:21 <typoclass> zaargy: (the primary part is to the right of =>)
04:06:02 <zaargy> so if you have a function that takes + or - as a parameter (for example)
04:06:03 <quicksilver> zaargy: Int -> Int is not polymorphic.
04:06:11 <zaargy> what do you call that?
04:06:14 <quicksilver> zaargy: a -> a is polymorphic.
04:06:34 <quicksilver> depends what you mean by "takes + - as a parameter"
04:06:43 <mikeplus64> @pl format x y = format (x <> single y)
04:06:44 <lambdabot> format = fix ((. ((. single) . (<>))) . (.))
04:06:50 <mikeplus64> oh god
04:06:57 <quicksilver>  a function with type (Double -> Double -> Double) -> String can take (+) or (-) as its parameter
04:07:02 <zaargy> i don't know haskell so i'm trying to use general terms that i know (i was referred to this channel).
04:07:05 <quicksilver> but it's not polymorphic.
04:07:57 <typoclass> zaargy: following up on what quicksilver said, in haskell, a capital letter indicates a type (e.g. "Int"), while a lower-case letter in that place indicates a type variable (e.g. "a"), aka polymorphism
04:08:01 <sipa> zaargy: better learn some haskell at least, before diving into rank-2 types :)
04:08:54 <typoclass> zaargy: if a function takes (+) or (-) as an argument, i'd call that just functional programming. you can pass functions into other functions, put them in variables, etc.
04:09:16 <Yuu-chan> :t (<>)
04:09:18 <lambdabot> Doc -> Doc -> Doc
04:09:27 <Twey> mikeplus64: format = format . uncurry (<>) . (id *** single)
04:09:28 <quicksilver> sipa: I don't think zaargy is trying to "dive into" higher rank types. I think he's just trying to get some terminology clear.
04:09:33 <Yuu-chan> :t fix
04:09:34 <lambdabot> forall a. (a -> a) -> a
04:09:49 <Twey> Err
04:09:50 <typoclass> Yuu-chan: i think that's mappend in recent versions of the base package. the "Doc" stuff seems to be misleading
04:10:00 <Twey> format = format . uncurry (<>) . (id *** single) . (,)
04:10:15 <zaargy> typoclass: lol okay
04:10:24 <Twey> Oh, we have a mappend operator now?  Nice.
04:10:36 <Twey> I always thought it was going to be (++).
04:10:44 <typoclass> Twey: not entirely sure :) i think so
04:10:52 <Yuu-chan> > [1,2,3] `mappend` [4,5,6]
04:10:53 <lambdabot>   [1,2,3,4,5,6]
04:10:53 <mikeplus64> Twey: i think i'll stick to the pointy version lol
04:11:07 <Twey> mikeplus64: A wise choice
04:11:13 <Twey> (that's not right, either :þ)
04:11:16 <Yuu-chan> :t mplus
04:11:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
04:11:19 <Yuu-chan> :t mappend
04:11:21 <lambdabot> forall a. (Monoid a) => a -> a -> a
04:12:09 <Twey> I think I meant to say: format = curry $ format . uncurry (<>) . (id *** single)
04:12:11 <Yuu-chan> My mind is full of theorcat
04:12:38 <zaargy> thanks all
04:12:42 <Twey> Yuu-chan: MonadPlus is similar to Monoid but for monads
04:13:07 <Yuu-chan> Twey: why to make two typeclasses?
04:13:30 <Twey> Yuu-chan: Because they're different
04:13:39 <Twey> Yuu-chan: MonadPlus applies to the m
04:13:40 <quicksilver> Yuu-chan: they apply to entirely different kinds of types.
04:13:42 <Yuu-chan> @source MonadPlus
04:13:43 <lambdabot> MonadPlus not available
04:13:51 <Yuu-chan> @info MonadPlus
04:13:52 <lambdabot> MonadPlus
04:14:05 <Twey>  @info is very unhelpful.
04:14:36 <Yuu-chan> @help
04:14:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:14:40 <typoclass> Yuu-chan: mappend is the main function of the Monoid class, which is the class of things that you can append something to. lists are an obvious example; you used that instance in your expression above
04:14:44 <mauke> there is no @info
04:14:52 <mauke> and @source works on module names
04:14:52 <mekeor> are there "kind variables"?
04:15:00 <typoclass> (i fear the mathheads will come at me with pitchforks for that characterization :-/ )
04:15:54 <mekeor> @source Control.Monad
04:15:55 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
04:15:58 <mekeor> ah.
04:16:16 <Yuu-chan> A monoid is a group with a neutral element, right?
04:16:38 <mauke> wait, wasn't a group a monoid with inverses?
04:17:21 * Yuu-chan went to Wikipedia
04:17:28 <mekeor> a group is a monoid with inverse, i think.
04:17:33 <mekeor> yes.
04:17:35 <mauke> Yuu-chan: which page?
04:18:07 <typoclass> Yuu-chan: yeah, a neutral element is involved (called mempty.) for the list instance, it's the empty list []
04:18:22 <mekeor> mauke: http://en.wikipedia.org/wiki/Magma_%28algebra%29#Types_of_magmas
04:18:24 <sipa> mekeor: that's require types-of-kinds, to be useful, no?
04:18:36 <mauke> yay, magmas
04:19:00 <mekeor> sipa: is this an english phrase?
04:19:14 <Yuu-chan> Well, it's a SEMIgroup with a zero. A group is a monoid with inverses.
04:19:19 <sipa> mekeor: yes, with a typo
04:19:23 <mekeor> ah, okay.
04:19:25 <mauke> mekeor: probably a typo for "that'd"
04:19:29 <mekeor> yup
04:19:37 <mekeor> sipa: dunno, may be.
04:20:12 <Yuu-chan> I mix up these abstract algebra terms each time ._.
04:20:35 <Yuu-chan> typoclass: so, what's a MonadPlus then?
04:21:00 <mauke> @src MonadPlus
04:21:01 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:21:33 <typoclass> Yuu-chan: dunno. i think it's a monad with 1 or 2 additional things. haven't looked into it yet :)
04:22:01 <Yuu-chan> But isn't a monad a monoid itself by definition?
04:22:06 <Twey> A MonadPlus is basically a monad that forms a monoid *when applied*.
04:22:40 * Yuu-chan scratches her head
04:22:51 <mekeor> would anybody mind showing me how to define "mapA :: Arrow (~>) => [x ~> y] -> [x] ~> [y]"?
04:23:07 <mikeplus64> using IncoherentInstances (don't hurt me) why does GHC default to the (Show x, Format a) => Format (x -> a) instance instead of Format a => Format (Text -> a)  ?
04:23:23 <mekeor> sorry.
04:23:24 <mekeor> i mean:
04:23:32 <mekeor> would anybody mind showing me how to define "mapA :: Arrow (~>) => (x ~> y) -> [x] ~> [y]"?
04:23:41 <Twey> mikeplus64: Because you used IncoherentInstances
04:23:59 <t7> @djynn  Arrow A => [A x y] -> A [x] [y]
04:23:59 <lambdabot> Error: Undefined type []
04:24:05 <mikeplus64> Twey: what would you instead?
04:24:31 <t7> @djynn  (Arrow A, Monad m) => m (A x y) -> A (m x) (m y)
04:24:32 <lambdabot> Error: Undefined type A
04:24:35 <Twey> mikeplus64: Not use IncoherentInstances :þ  What are you trying to do?
04:24:44 <t7> @djynn  (Arrow a, Monad m) => m (a x y) -> a (m x) (m y)
04:24:45 <lambdabot> Error: Class not found: Arrow
04:24:47 <t7> poo
04:24:51 <mekeor> hehehe
04:25:11 <mikeplus64> Twey: i have a function like printf, but for Text, and without having to do %ds and stuff (ie it just concatenates it's arguments)
04:26:18 <mikeplus64> and it's more efficient when it's just given Text to default to the "special" Text instance than to show and then pack it
04:26:36 * typoclass . o O ( maybe there should be a wiki page that lists the extensions ranked by danger. many are uncontroversial, some can really bite you. it's not always clear for a beginnerish intermediateish guy which are which )
04:27:29 <t7> typoclass: some guy just made a hackage with voting (and comments i think)
04:27:40 <t7> i mean a browser hackage plugin
04:27:47 <Twey> mikeplus64: A variadic function?
04:28:00 <mikeplus64> Twey: yeah, the variadic-ness is fine and dandy though
04:28:17 <Twey> Mmm
04:28:25 <typoclass> t7: hm interesting
04:28:30 <dzhus> how can you have variadic function in Haskell?
04:28:38 <dzhus> what type it would have?
04:28:44 <mikeplus64> dzhus: type classes
04:28:47 <mauke> dzhus: (Foo b) => a -> b
04:28:49 <sipa> :t printf
04:28:51 <lambdabot> forall r. (PrintfType r) => String -> r
04:29:07 <Twey> mikeplus64: I'm not seeing the problem.  Can't you just use the ‘special’ method in the Text instance?
04:29:12 <mikeplus64> dzhus: http://okmij.org/ftp/Haskell/types.html
04:29:20 <Twey> If it's given text you'll get the Text instance
04:29:22 <quicksilver> mekeor: my recollection is you can't define that.
04:29:26 <hpaste> mekeor pasted “do i need ArrowChoice in the definition of mapA??” at http://hpaste.org/72723
04:29:35 <typoclass> dzhus: it's somewhat funky, but it works. check the source code of the printf function, for example
04:29:39 <mekeor> quicksilver: but with ArrowChoice?
04:30:07 <quicksilver> mekeor: not sure :) sorry
04:30:21 <mekeor> quicksilver: see paste. that compiles.
04:30:38 <mekeor> and works.
04:31:15 <quicksilver> mekeor: ok then. I think arrowchoice will be required, if that's what you're asking.
04:31:27 <mekeor> hehe :D yeah. thanks.
04:31:39 <mikeplus64> Twey: hm, is there a way to sort of see the typechecker resolving instances in ghci?
04:35:33 <mikeplus64> Twey: you're right, the Text one was being chosen after all
04:36:35 <mikeplus64> Twey: but, is there a way to define a String instance as well as the Show x => ... one? (for efficieny's sake, and for the sake of not having quotes around the concatenated string because of show's behaviour with strings)
04:39:22 <mekeor> so, runKleisli is for Kleisli what ($) is for (->), right?
04:39:45 <mekeor> no.
04:40:03 <mekeor> so, runKleisli is for (Monad m => Kleisli m) what ($) is for (->), right?
04:43:40 <mauke> mikeplus64: http://ideone.com/Kal57 ?
04:44:48 <Targen> Is anyone here familiar with the Process monad in the Cloud Haskell proposal?
04:45:42 <Targen> More specifically, in the distributed-process implementation...
04:45:55 <mikeplus64> :t cast
04:45:57 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
04:46:16 <mikeplus64> > cast ("looks neat mauke..." :: String)
04:46:17 <lambdabot>   Nothing
04:46:25 <mikeplus64> > cast ("looks neat mauke..." :: String) :: Maybe String
04:46:27 <lambdabot>   Just "looks neat mauke..."
04:46:32 <mikeplus64> > cast ("looks neat mauke..." :: String) :: Maybe ByteString
04:46:33 <lambdabot>   Not in scope: type constructor or class `ByteString'
04:46:38 <mikeplus64> > cast ("looks neat mauke..." :: String) :: Maybe Int
04:46:39 <lambdabot>   Nothing
04:46:41 <mikeplus64> ah
04:46:53 <mikeplus64> that's very cool
04:47:04 <mauke> "..." :: String? wtf?
04:47:22 <Botje> it could become a bytestring if you have overloadedstrings
04:47:31 <mikeplus64> force of habit sorry
04:47:35 <Targen> Or Text, or a bunch of other things.
04:47:36 <mikeplus64> (what Botje said)
04:47:43 <mauke> ah
04:48:36 <Targen> > [toDyn "Even cooler:", toDyn 42]
04:48:38 <lambdabot>   [<<[Char]>>,<<Integer>>]
04:54:42 <Yuu-chan> > cast ("12" :: String) :: Maybe Int
04:54:44 <lambdabot>   Nothing
04:54:55 <Yuu-chan> > cast 12.0 :: Maybe Int
04:54:56 <lambdabot>   Nothing
04:55:10 <mikeplus64> > cast 12.0 :: Maybe Double
04:55:11 <lambdabot>   Just 12.0
04:55:23 <Yuu-chan> > cast (12 :: Int) :: Maybe Double
04:55:25 <lambdabot>   Nothing
04:55:26 <t7> mauke: coolio
04:56:06 <hiptobecubic> What is cast good for?
04:56:24 <t7> changing type
04:56:25 <hiptobecubic> it doesn't look particularly effective
04:56:27 <t7> ;)
04:56:37 <mauke> hiptobecubic: did you see the program I pasted?
04:56:50 <hiptobecubic> mauke, ... no. scrolling...
04:57:44 <typoclass> hiptobecubic: giving beginners something that they *think* will solve all their problems
04:57:45 <quicksilver> cast is useful for not-changing the type :)
04:58:03 <quicksilver> it's useful for doing something only if two types match, and doing Nothing if they don't match.
04:59:06 <t7> but if you dont know the types then you are silly
04:59:14 <t7> unless parsing something silly
04:59:26 <hiptobecubic> mauke, it looks like you just reinvented (concatMap show) ?
04:59:36 <mauke> hiptobecubic: look at the output
04:59:45 <hiptobecubic> i am
04:59:58 <typoclass> hiptobecubic: i think the point was to demonstrate varargs in haskell
05:00:01 <hiptobecubic> everything is made a string and concatenated?
05:00:14 <mikeplus64> hiptobecubic: if it were concatMap show then you'd have quotation marks around foo and bar and baz
05:00:18 <mauke> > concat [show "foo", show (), show "bar", show 42, show "baz"]
05:00:20 <lambdabot>   "\"foo\"()\"bar\"42\"baz\""
05:00:23 <mauke> compare and contrast
05:01:01 <hiptobecubic> ah ok. so if it's a string, you don't show it. otherwise you do?
05:01:09 <quicksilver> (quite apart from the fact that concatMap show is a kind of impredicative polymorphism which haskell doesn't support :P )
05:01:15 <hiptobecubic> i see
05:01:35 * hackagebot OpenCL 1.0.3.2 - Haskell high-level wrapper for OpenCL (LuisCabellos)
05:02:03 <quicksilver> t7: it lets you design more open-ended interfaces.
05:02:22 <quicksilver> t7: it's never *actually* any different from using a sum type like data SomeValue = S String | I Int
05:02:37 <quicksilver> but it automatically has a case for every haskell type you want it to have a case for.
05:07:41 <t7> quicksilver: ah thats very true
05:22:47 <mekeor> so, hackage has a cron daemon which generates the documentation of new releases of packages and that why it needs some time?
05:24:28 <typoclass> mekeor: yeah. but you can always have a look at the previous version
05:24:39 <mekeor> typoclass: yup.
05:24:55 <mekeor> tanx
05:28:10 <lamefun> a...
05:28:14 <lamefun> Either
05:28:19 <lamefun> omg
05:28:31 <lamefun> what is this for?
05:28:56 <lamefun> Why does Learn Yourself a Haskell recommend it for error reporting O_o?
05:29:06 <MasseR> lamefun: Because it's good at it
05:29:21 <MasseR> lamefun: We have a function, it can return either a proper value or an error
05:29:27 <lamefun> thats
05:29:28 <lamefun> ...
05:29:35 <Philippa> if it's not Right, it's gone wrong
05:29:48 <lamefun> why not data Fallible x e = Success x | Error e
05:30:02 <Philippa> honestly? I agree with you, though they're isomorphic
05:30:03 <MasseR> lamefun: Because Either is more general
05:30:15 <Philippa> but not all use cases for Either are about something being Fallible
05:30:42 <Philippa> you can use Control.Error if you prefer (and you're using monadic style with it)
05:30:44 <sipa> and Either already has some infrastructure that you can reuse, instead of needing to reimplement it simply to give it another name
05:31:10 <Philippa> but lamefun's got a genuine point: it's not the highest-level piece of code in the libraries when used that way
05:31:21 <lamefun> the problem is such naming makes everything incomprehensible
05:31:26 <Philippa> (attention to the irrelevant, yadda yadda)
05:31:45 <Philippa> lamefun: that's a bit strong. One mnemonic - or having understood what one of the simplest possible types in Haskell does - suffices
05:32:12 <Philippa> it's a bit of a hysterical raisins case though
05:32:19 <MasseR> lamefun: I agree it's a bit wtf for a new user
05:32:43 <MasseR> But after you know the convention that 'Right' is a proper value and 'Left' is an error, it works
05:32:45 <Philippa> *nod*. But compared to the encoding issues I've run into as a newbie in other languages, it's pretty tame
05:33:03 <danil> > partitionEithers . map (\x -> if isUpper (head x) then Left x else Right x) . words $ "Here are Some Differently capitalized words"
05:33:06 <lambdabot>   (["Here","Some","Differently"],["are","capitalized","words"])
05:33:11 <MasseR> And like Philippa said, it's one of the simplest types (after maybe?) in haskell so meh
05:33:27 <Philippa> MasseR: it's a bool with values attached :-)
05:33:31 <sipa> after Bool and Maybe, I'd say
05:33:37 <benmachine> Either really needs to be just Either, and not Error
05:33:41 <benmachine> it's used for all sorts of things
05:34:04 <Philippa> benmachine: Haskell's not quite as good at navigating isomorphisms as'd be ideal. But a newtype'd be nice
05:34:05 <sipa> Just Either, or Nothing!
05:34:20 <benmachine> and well, Either a b either contains a value of type a or a value of type b
05:34:43 <benmachine> if it's type a then it's on the Left and if it's type b then it's on the Right
05:35:12 <benmachine> Philippa: perhaps. but Either isn't an error type, Either Error a is
05:35:18 <Philippa> mmm. And if you're going to have to learn Either anyway, there's something to be said for economy of names
05:35:20 <benmachine> Philippa: I think the latter reads quite naturally
05:35:43 <Philippa> benmachine: there's an Error monad, which is what I was referring to
05:35:45 <t7> Symmetric-key encryption is an isomorphism?
05:36:09 <benmachine> t7: not necessarily?
05:36:10 <typoclass> lamefun: i think of Either as an extended Maybe. sometimes you'd like to use Maybe, but if your function can plausibly go wrong in several ways and you give back only a Nothing, the caller can't tell what exactly went wrong. Either comes in as a variant of maybe that lets you attach something (error string ...) to the "Nothing"
05:36:39 <benmachine> (an encryption function need not be surjective, for example)
05:36:56 <Philippa> benmachine: It does, yes. Fallible is a good name there, actually - our monad names aren't grammatically ideal, I reckon
05:37:06 <Philippa> anyway, I should go. Later!
05:37:14 <zaargy> sorry it's me again! trying to find words to seed my googles. is there a general word for when a function takes another function as a parameter but doesn't know which function will be executed until runtime?
05:37:32 <Philippa> zaargy: "statically unknowable"?
05:37:33 <benmachine> zaargy: possibly you mean a higher-order function (sometimes abbreviated HOF)
05:37:35 <sipa> zaargy: higher-order function?
05:37:37 <typoclass> lamefun: but you have a point that the name Either is pretty abstract (like many names in haskell), and more abstract often means less comprehensible
05:37:49 <quicksilver> zaargy: surely that's what you'd expect if you take a function as a parameter.
05:37:59 <benmachine> typoclass: I don't see what's so abstract about it
05:38:01 <quicksilver> zaargy: (if you knew in advance what it would be, what would be the point of making it a parameter?)
05:38:06 <benmachine> it tells you exactly what the thing contains
05:38:12 <benmachine> it doesn't tell you what to use it for
05:38:21 <benmachine> but something like Either Error a does, imo
05:38:29 <zaargy> i have got the higher-order function part
05:38:35 <MasseR> Could someone explain philippas 'Haskell's not quite as good at navigating isomorphisms as'd be ideal'? (Still trying to grok isomorphism, and when it's used just like that in a sentence, I can't read it)
05:38:52 <quicksilver> zaargy: but, as Philippa says, people will routinely use the adverb "statically" for things which you know at compile-time in stead of runtime.
05:39:03 <typoclass> benmachine: he gave the example Fallible = Success s | Error e, which i'd argue is more concrete (though it has other problems)
05:39:22 <sipa> zaargy: not sure what else you're looking for?
05:39:30 <quicksilver> MasseR: she means that, for example, if we had two types like Either, being Either = Left | Right and Fallible = Success | Error, we would have to duplicate all the functions which operate on that type.
05:39:48 <quicksilver> MasseR: even though the two types are isomorphic = structurally the same.
05:39:58 <quicksilver> (parameters missed out for brevity and/or laziness)
05:39:59 <danil> MasseR: Or at least keep manually converting between them, with a runtime cost.
05:40:05 <sipa> let's introduce a typeclass EitherLike !
05:40:16 <MasseR> quicksilver, danil thanks
05:40:22 <quicksilver> danil: in fact we can do it at zero runtime cost with newtype. But it is still inconvenient.
05:40:39 <danil> quicksilver: right, but the newtype makes one of them awkward to use
05:40:44 <quicksilver> and you don't get to rename the constructors that way.
05:40:50 <typoclass> zaargy: tell us a little more about the context. what material are you learning and what's tripping you up?
05:42:09 <mekeor> are there other nice tools like cabal-dev, hlint and stylish-haskell which help you during development?
05:42:18 <benmachine> typoclass: I kind of think that if you have a Fallible Int Char, it's not clear what that is, whereas if you have an Either Int Char, anyone can guess
05:45:01 <zaargy> typoclass: sporadic reading really
05:45:11 <danil> can you do "Char `OrFailWith` Int" with -XTypeOperators?
05:45:23 <zaargy> i just do a lot of function passing in my regular ruby code, so was just looking for more stuff to read up on out of interest..
05:45:37 <typoclass> benmachine: yes, and i also don't like that the word Fallible might just as well be the name of a type like Maybe. there's problems with that suggestion. but it seemed really just off the cuff, so i don't think we should put each word on a pedestal
05:45:40 <tdammers> mekeor: hoogle, hayoo, lambdabot, ghci, ...
05:46:08 <quicksilver> danil: you don't need typeoperators to do that I don't think?
05:46:23 <quicksilver> although I'm not entirely sure
05:46:33 <quicksilver> > Left 1 :: (Int `Either` Char)
05:46:35 <lambdabot>   Left 1
05:46:36 <benmachine> danil: yes, but that's the wrong way round, you want the failure type to be the first argument
05:46:40 <benmachine> (usually)
05:46:51 <mekeor> tdammers: those are quite obvious. any utils which i'm not aware of?
05:47:05 <benmachine> quicksilver: LB has TypeOperators
05:47:06 <typoclass> danil: you know, that's a really good way of putting it. i like it :)
05:47:06 <danil> benmachine: yeah, I was golfing readability not compatability
05:47:23 <danil> benmachine: but of course you want Functor et al and so can't really have it in that order
05:47:24 * benmachine nearly called them TypoEperators
05:47:45 <benmachine> quicksilver: :k Int `Either` Char fails in my ghci
05:47:53 <quicksilver> benmachine: sure, I appreciate showing it in lambdabot didn't prove it :)
05:48:31 <mekeor> tdammers: thanks anyway. i think that's enough :)
05:49:01 <typoclass> i just checked, if you do :set -XTypeOperators you can do :k Int `Either` Char
05:49:34 <benmachine> typoclass: right, but if you don't you can't
05:50:35 <typoclass> benmachine: sure. i believed what you said about your ghci :) i just wanted to know that it's really TypeOperators that turn on the backticks
05:50:58 <benmachine> yeah, just corroboratin'
05:53:53 <danil> I almost feel like infixified functions should take their arguments in the opposite order.  Often the order you want for currying is the backwards for using them infix(mod, elem, member; sortBy, filter, map)
05:54:22 <ezyang> With the power of tickmarks!
05:54:37 <danil> (s/is the backwards/is backwards/)
05:54:50 <benmachine> danil: yeah, it's kind of annoying
05:55:58 <danil> it would be pretty confusing the other way though, especially because you *don't* want operators to flip when you parenthesize them
05:57:37 <quicksilver> there is always section notation
05:57:41 <quicksilver> (`f` a) b
05:57:46 <quicksilver> but it's slightly obscure :)
05:58:43 <typoclass> why not introducing ´´ which are like backticks but flip the arguments, while also keeping the `` syntax unchanged? ;) you'd have to squint very hard at a few little pixels to figure out what's going on
05:59:32 <tdammers> a `flip f` b -- does that work? guess not.
05:59:46 <sipa> > 3 `flip subtract` 4
05:59:47 <lambdabot>   <no location info>: parse error on input `subtract'
06:00:04 <tdammers> 3 `flip (-)` 4
06:00:05 <typoclass> > let (␣) = flip in (map ␣ [1..3]) succ -- quicksilver, check this out ;-)
06:00:07 <lambdabot>   [2,3,4]
06:00:57 <quicksilver> typoclass: yes, seen that trick before :)
06:01:27 <quicksilver> slightly surprised that _ is a valid operator since it is special syntax in patterns
06:01:56 <typoclass> it's very cute, except it starts to fall apart in irritating ways for >= 3 arguments
06:02:21 <hpc> > "_" == "␣"
06:02:22 <lambdabot>   False
06:02:44 <quicksilver> oh, what was it then hpc?
06:02:54 <hpc> yep
06:03:00 <danil> typoclass: clearly we just need more unicode characters that look like underscores ;)
06:03:13 <hpc> since i am on slow nets right now i can't screencap
06:03:19 <hpc> but on my screen it renders as |_|
06:03:23 <hpc> only smaller
06:03:34 <typoclass> quicksilver: a "hole" character from somewhere deep in unicode. i have it in my compose table. not sure what the number is
06:03:36 <quicksilver> not only do they look like underscores but my terminal's ascii fallback actually renders them as underscores :)
06:03:43 <hpc> ouch
06:03:57 <hpc> my terminal falls back to empty space :D
06:04:07 <hpc> makes reading #agda kinda hard though
06:05:11 <typoclass> there we go, that's what i meant http://www.fileformat.info/info/unicode/char/2423/index.htm
06:05:59 <typoclass> it's unfortunate that rendering troubles are so prevalent
06:09:15 <quicksilver> ah OK that is actually sufficiently different
06:09:30 <quicksilver> although even once you've chosen a character simple-placeholder syntax is not a panacea
06:09:41 <quicksilver> it would be handy sometimes
06:11:30 <lamefun> Does any of Web 3.0 languages support pure functions?
06:12:16 <danil> what's a web 3.0 language?
06:12:17 <typoclass> ah right, clojure has anonymous arguments in lambdas ... they might write that as "#(map % [1..3]) succ", if you don't mind the haskell functions and list notation
06:12:18 <ezyang> Ur/Web does!
06:12:20 <typoclass> quicksilver: how do you mean simple-placeholder syntax?
06:12:34 <lamefun> danil: I don't know.
06:12:35 <t7> danil: node
06:12:39 <t7> :)
06:16:39 * hackagebot IntervalMap 0.3.0.1 - Maps from Intervals to values, with efficient search. (ChristophBreitkopf)
06:18:25 <quicksilver> typoclass: things like (f a _ b _ c) for (\ x y -> f a x b y c)
06:18:37 <quicksilver> as I recall it's called 'burning' in some esoteric language or other.
06:19:42 <danil> Mathematica has F[a, #1, b, #2, c]&
06:25:08 <drunK> can anyone explain, why http://codepad.org/ai7w6Emv continues to execute only first thread (and blocks in killThread until it enters release block)? documentation for mask says "Executes an IO computation with asynchronous exceptions masked. That is, any thread which attempts to raise an exception in the current thread with throwTo will be blocked until asynchronous exceptions are unmasked again." according to this, 'killThread b'
06:25:09 <drunK> should also block. or am I missing something?
06:26:18 <mekeor> would be nice if ghci had a command :time which stops time.
06:28:13 <ezyang> Seems like the behavior I would expect.
06:31:28 <t7> mekeor: like in max payne?
06:31:40 * hackagebot happstack-server 7.0.4 - Web related tools and services. (JeremyShaw)
06:31:58 <mekeor> t7: i actually meant "measure time of execution"
06:32:36 <quicksilver> mekeor: :set +s
06:32:43 <mekeor> oh, cooool
06:35:06 <zhulikas> @src for
06:35:06 <lambdabot> Source not found. Do you think like you type?
06:35:12 <mekeor> for = flip map
06:35:25 <zhulikas> oh, right
06:35:45 <hiptobecubic> for is nice
06:35:51 <mekeor> sometimes.
06:35:58 <mekeor> when the function is long.
06:36:08 <hiptobecubic> well sure. everything sucks if you abuse it
06:36:25 <sipa> > for [2,3,4] (+1)
06:36:27 <lambdabot>   Not in scope: `for'
06:36:28 <mekeor> sometimes map is nice, too, when the list is long ;), you know :P
06:36:33 <mekeor> @let for = flip map
06:36:35 <lambdabot>  Defined.
06:36:37 <mekeor> > for [2,3,4] (+1)
06:36:39 <lambdabot>   [3,4,5]
06:37:51 <zhulikas> I love how everything is a function
06:38:01 <zhulikas> even a simple (+1) is a function
06:38:15 <sipa> 1, however, is not a function
06:38:19 <sipa> except in lambdabot
06:38:24 <mekeor> yeah :D
06:38:30 <mekeor> > 1 2
06:38:31 <lambdabot>   1
06:38:36 <sipa> but (1 :: Int) definitely isn'
06:38:37 <sipa> t
06:38:49 <zhulikas> so
06:38:59 <zhulikas> if function always has one argument and returns one result
06:39:03 <zhulikas> what is 1?
06:39:07 <zhulikas> it doesn't take an argument
06:39:08 <sipa> not a function
06:39:13 <mekeor> :t 1
06:39:14 <zhulikas> a value?
06:39:14 <lambdabot> forall t. (Num t) => t
06:39:27 <sipa> a polymorphic expression
06:39:30 <zhulikas> I am wondering about a term for it
06:39:34 <mekeor> :t 1 `asAppliedTo` 2
06:39:36 <lambdabot> forall t b. (Num b, Num t) => t -> b
06:39:38 <benmachine> "value" is pretty good
06:39:40 <mekeor> huh! that's it!
06:39:41 <benmachine> mekeor: shh
06:39:52 <byorgey> zhulikas: there is no term which means "thing which is not a function"
06:40:01 <sipa> non-function value
06:40:03 <byorgey> "value" does not work. functions are values too.
06:40:12 <mekeor> yup
06:40:23 <benmachine> byorgey: well, it works but it's insufficiently specific
06:40:24 <zhulikas> @t asAppliedTo
06:40:24 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:40:25 <byorgey> (also, the word "value" is so overloaded as to be almost useless unless you precisely define what you mean by it first)
06:40:27 <roconnor> value of ground type
06:40:31 <zhulikas> @type asAppliedTo
06:40:33 <lambdabot> forall t b. (t -> b) -> t -> t -> b
06:41:11 <sipa> that's the point exactly: functions are *just* values (but not the only sort of values)
06:41:12 <roconnor> term of ground type
06:41:31 <sipa> roconnor: prolog terminology?
06:41:35 <quicksilver> I think "non-function" or "non-function value" are both fine
06:41:37 <danil> roconnor: does "ground type" have a precise meaning?  Are type constructor applications "ground"?
06:51:31 <zhulikas> @type retry
06:51:32 <lambdabot> Not in scope: `retry'
06:52:04 <zhulikas> I am reading a couple of examples on STM
06:52:18 <Eduard_Munteanu> @hoogle retry
06:52:19 <lambdabot> Network.HTTP.Base Retry :: ResponseNextStep
06:52:19 <lambdabot> GHC.Conc.Sync retry :: STM a
06:52:20 <lambdabot> GHC.Conc retry :: STM a
06:52:22 <zhulikas> and they do something like:
06:52:35 <hpaste> zhulikas pasted “example” at http://hpaste.org/72727
06:53:03 <zhulikas> so it means that if value cannot be read, it blocks and retries when value is available
06:53:26 <JorgeArbusto> C code but:  listobj *alloc_listobj(TCB *tcb_object); //how would you comment that? just @param tc_object to generate the doc for the param or dont comment at all?
06:53:51 <zhulikas> but... if I have multiple processes reading/writing a single value is something like "retry" being done internally?
06:54:13 <zhulikas> I mean - do threads wait when value is being accessed/changed in TVar
06:54:18 <zhulikas> by other threads
06:54:25 <zhulikas> or do I always need to make checks on that myself
06:54:29 <Eduard_Munteanu> JorgeArbusto: why are you asking that here?
06:54:31 <zhulikas> whether the TVar is available
06:55:46 <roconnor> zhulikas: do you want to know how STM actually works, or what its semantics is?
06:55:56 <zhulikas> how it works
06:56:20 <roconnor> zhulikas: during an attomic transaction a log of all variables read and written is generated.
06:57:22 <roconnor> zhulikas: at the end of the transaction, the written variables are commited atomically so long as the read values were not touched by another thread
06:57:32 <JorgeArbusto> Eduard_Munteanu: general commenting advice
06:57:39 <roconnor> zhulikas: if the read values were touched by another thread, the entire transaction is retried
06:57:39 <JorgeArbusto> #c esta muerte
06:58:19 <roconnor> zhulikas: when "retry" is encountered during an attomic transaction the whole thread is retried; however the retry will block until at least one of the read variables has changed.
06:58:21 <Eduard_Munteanu> That's not even specific to C. :/
06:58:44 <roconnor> *the whole atomic transaction is retried; ...
07:01:37 <zhulikas> what do you mean by read and written variables?
07:01:48 <zhulikas> are we talking about reading and writing to one specific variable?
07:02:08 <roconnor> zhulikas: reading/writing to TVars
07:02:27 <roconnor> in your example decT
07:02:46 <roconnor> it reads the TVar v
07:03:18 <roconnor> the value is 0, it retries; otherwise it decriments the variable's value by 1
07:03:30 <mm_freak_> @tell EvilMachine s-expressions are context-free…  they will need escaping (as noted in the video)
07:03:31 <lambdabot> Consider it noted.
07:03:41 <nand`> when omitting the $() for top-level splices, do you still need the -XTemplateHaskell flag?
07:03:46 <roconnor> the new value for the variable is only committed if no other thread has written to the variable
07:04:00 <roconnor> otherwise the whole transaction is retried
07:05:26 <zhulikas> so if a thread reads a value and just before writing notices that it was being written before this thread had a chance to do it, thread restarts the transaction?
07:05:45 <quicksilver> it's helpful to use the word 'commit', zhulikas
07:05:51 <zhulikas> I might just be rephrasing what you just said
07:05:54 <quicksilver> to distinguish between the two parts
07:06:03 <quicksilver> the writes "don't really happen" until the commit
07:06:10 <roconnor> zhulikas: almost; IIUC the check isn't done until the end of the transaction.
07:06:14 <roconnor> I could be wrong though
07:06:29 <quicksilver> each transaction does some computation and sets up the TVar changes it would make
07:06:50 <JorgeArbusto> Quiza un poco estupido, perro Haskell es un computer programming language?
07:07:02 <quicksilver> then at commit time, a check is made that no other transaction has changed any of the variable used
07:07:08 <zhulikas> so, basically: read a variable. try to write. If it's been modified from outside - restart the whole action
07:07:24 <quicksilver> zhulikas: it *anything* relevant has been modified.
07:07:24 <zhulikas> ah
07:07:26 <otters> doesn't "perro" mean "dog"
07:07:26 <quicksilver> not just "it"
07:07:45 <quicksilver> but any of the variables read from or written to
07:07:45 <zhulikas> but reading by other threads is fine, right?
07:07:51 <quicksilver> yes.
07:08:19 <zhulikas> <roconnor> zhulikas: if the read values were touched by another thread, the entire transaction is retried
07:08:21 <quicksilver> JorgeArbusto: this is an english language channel for discussing the Haskell programming language, yes.
07:08:23 <zhulikas> so I probably misread this
07:08:56 <JorgeArbusto> si perro=do, tal vez=maybe
07:09:05 <roconnor> zhulikas: read a variable, write the variable to the transaction; commit the transaction  if the variable *read* hasn't changed otherwise retry
07:09:07 <JorgeArbusto> si perro=dog, tal vez=maybe
07:09:19 <lamefun> What is the recommended way to integrate resource loading?
07:09:39 <danil> zhulikas: "touched" in this case means written to (read might be "looked at")
07:09:48 <zhulikas> what if I don't retry?
07:09:53 <quicksilver> roconnor: I have a feeling it checks variables written to as well?
07:09:58 <JorgeArbusto> necessito rety
07:10:00 <quicksilver> zhulikas: you don't need to explicitly retry
07:10:01 <zhulikas> it will just fail ?
07:10:04 <zhulikas> aaa
07:10:07 <quicksilver> retry is automatic
07:10:13 <JorgeArbusto> si automatic
07:10:14 <quicksilver> the explicit retry is when you want to force one yourself
07:10:14 <JorgeArbusto> o
07:10:23 <quicksilver> JorgeArbusto: english please.
07:10:30 <zhulikas> so how implicit retry is different from explicit one?
07:10:45 <quicksilver> the implicit one occurs only when one of the variables you use has been changed by another transaction
07:10:52 <quicksilver> the explicit one happens whenever you ask it to
07:11:01 <quicksilver> so they differ in what makes them happen
07:11:21 <zhulikas> so the condition for explicit reply can be specified
07:11:29 * roconnor wonders if fail calls retry
07:11:32 <zhulikas> but they both do the same thing, right?
07:11:40 <quicksilver> yes, the effect is the same
07:11:43 <zhulikas> perfect
07:11:47 <danil> zhulikas: the implicit one is if there's some reason this transaction shouldn't get committed aside from conflicts with other threads
07:11:47 <zhulikas> thank you guys :)(
07:11:48 <zhulikas> :)
07:11:49 <quicksilver> all changes are lost and the transaction is retired form the beginning
07:12:10 <quicksilver> roconnor: I think you get a retry even if a variable you merely wrote to has changed.
07:12:16 <quicksilver> I'm not sure though.
07:12:19 <roconnor> quicksilver: you think?
07:12:23 <danil> zhulikas: since STM is deterministic, if you retry explicitly there's no reason to try again until another thread changes something you read from, or the same thing will happen
07:12:41 <roconnor> quicksilver: one side of me agrees with you; that's what I read; the other side says there is no reason to check that condition
07:12:46 <danil> zhulikas: wheras the automatic one doesn't have to block because it only happens after something has changed already
07:13:15 <quicksilver> roconnor: yes, I remember thinking about this more carefully before but I don't remember all the conclusions I came to :)
07:13:57 <danil> quicksilver: if nothing you've read has changed you're going to write the same thing anyway
07:14:19 <roconnor> there is no point in retrying a transaction if the path through the code is going to be the same.
07:14:23 <zhulikas> what is considered a beginning for a transaction when it retries (both implicitly and explicitly)
07:14:56 <quicksilver> the "STM a" action goes back to the start, zhulikas
07:14:56 <danil> zhulikas: the action you pass to "atomically" is the transaction
07:14:59 <quicksilver> the parameter to atomically
07:15:01 <roconnor> zhulikas: AFAIU all the way back to the beginning of the atomically block
07:15:15 <quicksilver> danil, roconnor : I even filed a bug about it http://hackage.haskell.org/trac/ghc/ticket/2028
07:15:39 <quicksilver> to be fair it was 5 years ago which is why I can't remember all the things I was thiking at the time.
07:16:18 <zhulikas> ah yes, so atomically forms a transaction
07:16:26 <roconnor> quicksilver: oh interesting
07:16:41 * hackagebot web-routes-th 0.22.1 - Support for deriving PathInfo using Template Haskell (JeremyShaw)
07:16:54 <zhulikas> so if I don't use atomically and do reading/writing a TVar, it may fail because of multiple threads working on it?
07:17:07 <zhulikas> I mean... if I am not doing it in transactions
07:17:12 <zhulikas> using atomically
07:17:13 <mauke> zhulikas: no, you can't just read/write TVars
07:17:15 <quicksilver> well if you try to read/write a tvar you *are* using atomically
07:17:23 <zhulikas> aaa
07:17:24 <mauke> look at the types
07:17:24 <quicksilver> readTVarIO is just atomically . readTVar
07:17:29 <quicksilver> or whatever it's called
07:17:33 <zhulikas> well, I didn't try to read it without atomically
07:17:45 <zhulikas> so it forces to use transactions
07:17:50 <mauke> this is like the GPL
07:17:59 <roconnor> zhulikas: yep!
07:18:03 <zhulikas> purrfect
07:18:24 <mauke> if you manage to get a court to declare the GPL unlawful, you're left with no license at all
07:18:25 <zhulikas> thank you guys :)
07:18:51 <mauke> and if you remove 'atomically' from the picture, there's no way to do anything with STM actions
07:19:52 <roconnor> priority changed from low to lowest
07:19:55 <roconnor> :(
07:21:22 <quicksilver> I'm not sure how widely used STM is, in fact.
07:22:02 <quicksilver> I remember discussing how nice it would be to have a safe way to augment STM with other external resources (with the constraint that they be rollback/commitable in the way you'd need to make it sound)
07:22:47 <hiptobecubic> How well does STM really do? I get that it's easier to reason about whether or not your program will work, but performance wise does it manage well?
07:23:07 <danil> hiptobecubic: it's much better than locking if contention is low
07:23:28 <quicksilver> it does brilliant in some use case and terribly in others
07:23:48 <quicksilver> and I'm not aware of much in the way of public discussion on which are the good/bad ones :)
07:24:14 <quicksilver> you can certainly engineer cases where the commit-check takes too long (O(n^2)) and other cases where transactions get starved.
07:24:22 <lamefun> I still miss RTTI :( How do I, for example, implement resource loader that supports with user-defined resource types?
07:24:43 <quicksilver> by making the resources confirm to a common interface which you represent as a data type
07:25:17 <quicksilver> data Resource = Resource { loader :: IO (), do_something_cool :: IO (), unloader :: IO () }
07:25:31 <lamefun> uhm, it's well, how's that possible? for example, what common interface do texture and sound have?
07:25:44 <Cale> I'm not sure what is meant by "resource loader" here. Will you be parsing values?
07:25:55 <Cale> lamefun: ah, file resources?
07:25:56 <quicksilver> you must have some common interface in mind.
07:27:05 <Cale> lamefun: The idea here being that your user is going to have some parser for turning their files into Haskell values, and you want to manage reading them from disk, applying their parser and loading/unloading them from memory or something?
07:27:44 <mauke> lamefun: if they have nothing in common, why are you trying to write shared code for them?
07:27:48 <nand`> loadResource :: ResourceName -> (ByteString -> a) -> IO a -- ?
07:28:15 <roconnor> loadReasource :: (Seralize a) => ResourceName -> IO a -- ?
07:28:25 <mauke> needs more fail
07:28:57 <EvanR> mauke: somehow it must be possible, i mean, the java class hierarchy is a tree, all data descends from a common ancestor
07:29:00 <roconnor> loadResource :: ResourceName -> (ByteString -> Maybe a) -> MaybeT IO a -- ?
07:29:25 <nand`> I included the possibility of errors in my type, fwiw
07:29:42 <nand`> but I imagine ‘class Serialize a’ probably has some -> Maybe a
07:29:52 <nand`> (is that an actual class or did you just make it up?)
07:30:11 <mauke> EvanR: and java classes have a common interface
07:30:46 <roconnor> @type (=<<) . getContents
07:30:48 <lambdabot>     Couldn't match expected type `a -> m b'
07:30:48 <lambdabot>            against inferred type `[Char]'
07:30:49 <lambdabot>       Expected type: IO (a -> m b)
07:31:27 <Cale> :t (=<< getContents)
07:31:27 <roconnor> @type (>>=) . getContents
07:31:28 <lambdabot> forall b. (String -> IO b) -> IO b
07:31:28 <lambdabot> forall b. IO ((Char -> [b]) -> [b])
07:31:42 <roconnor> @type (>>=) . hGetContents
07:31:43 <lambdabot> Not in scope: `hGetContents'
07:31:59 <EvanR> :t unsafeInterleaveIO
07:32:01 <lambdabot> Not in scope: `unsafeInterleaveIO'
07:32:08 <roconnor> @type (>>=) . Data.ByteString.hGetContents
07:32:09 <lambdabot> forall b. GHC.IO.Handle.Types.Handle -> (BSC.ByteString -> IO b) -> IO b
07:32:18 <astory> is there a way to get `cabal configure` to automatically install dependencies of my package?
07:32:24 <roconnor> tada!  loadResource
07:32:39 <roconnor> maybe fmap is better
07:32:49 <roconnor> @type liftM . Data.ByteString.hGetContents
07:32:50 <lambdabot>     Couldn't match expected type `a1 -> r'
07:32:51 <lambdabot>            against inferred type `IO BSC.ByteString'
07:32:51 <lambdabot>     Probable cause: `BSC.hGetContents' is applied to too many arguments
07:32:54 <roconnor> :/
07:33:04 <roconnor> @type (flip liftM) . Data.ByteString.hGetContents
07:33:06 <lambdabot> forall r. GHC.IO.Handle.Types.Handle -> (BSC.ByteString -> r) -> IO r
07:33:13 <roconnor> tada!  loadResource
07:33:52 <roconnor> nand`: http://hackage.haskell.org/packages/archive/cereal/0.3.5.2/doc/html/Data-Serialize.html#t:Serialize
07:33:58 <nus> astory, cabal install <yourpackage> --dry-run
07:34:13 <nand`> ah
07:34:24 <astory> nus: I have a .cabal file, but it's not on hackage
07:34:29 <nand`> -> Either String a
07:34:49 <astory> so I don't know how to get cabal install to work
07:35:33 <quicksilver> astory: just run "cabal install" from isndie the directory
07:35:51 <quicksilver> with no arguments, it attempts to install the package in the current directory.
07:36:43 * edwardk waves hello.
07:37:00 * mekeor waves back.
07:37:04 <astory> quicksilver: great, thanks!  :D
07:38:03 <edwardk> my current quest to make sure all the references to types and method names are hyperlinked is exhausting
07:38:05 <mekeor> is there a way to make (Monad m => a -> m b) directly (without using the newtype Kleisli) an instance of, for instance, Arrow? that'd be sooo great!
07:38:17 <edwardk> (in lens)
07:38:33 <mekeor> edwardk: what's the best way to learn lenses?
07:38:53 <edwardk> mekeor: did you read my stack overflow post on them?
07:38:54 <nand`> edwardk: are you doing it in quadratic time by iterating each file for each name or building a dictionary of names and running a single pass?
07:39:03 <edwardk> quadraticish time
07:39:21 * mekeor doesn't use stackoverflow… should sign up…
07:39:25 <edwardk> sadly i have to do a lot of things where i break up the >'s into @….@'s
07:39:34 <quicksilver> you don't need to sign up to read edwardk's post though, mekeor
07:39:40 <mekeor> yeah.
07:39:46 <edwardk> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
07:39:49 <mekeor> where's the SO pos… ah
07:39:50 <mekeor> thanks
07:39:58 <edwardk> that explains the normal notion of lenses pretty thoroughly
07:40:04 <mekeor> wow. long answer.
07:40:18 <edwardk> the 'lens' library is based on a series of generalizations to them
07:40:53 <mekeor> haha. i like that comment on your post, edwardk: "Oh no! I was the original author of data-accessor, and then I passed it over to Henning and stopped paying attention. The a -> r -> (a,r) representation also makes me uncomfortable, and my original implementation was just like your Lens type. Heeennnninngg!! – luqui"
07:40:54 * nand` found http://comonad.com/reader/2012/mirrored-lenses/ to be quite useful (which should be linked to from the SO post)
07:40:59 <edwardk> =)
07:41:15 <edwardk> true i'll add the link
07:41:33 <edwardk> oh i already did
07:41:41 <nand`> that's what I meant to say
07:41:43 * hackagebot egison 2.4.1 - An Interpreter for the Programming Language Egison (SatoshiEgi)
07:41:56 <edwardk> the 'generalized van Laarhoven lenses' link is to it
07:44:06 <edwardk> basically with the lens library i went out of my way to figure out what all the laws should be for lens families based on the intersection of what you can do with a function and what you can do with Traversable, and then added types for progressively weaker restrictions
07:44:16 <edwardk> in such a way that they can all compose
07:45:01 <edwardk> getters act like functions, folds act like Foldable containers, traversals act like Traversable, setters act like Functors -- and all the laws you'd expect from those analogies hold
07:45:11 <edwardk> a  Lens then is just a Traversal you can use like a Getter
07:46:10 <edwardk> and more importantly all the combinators you have for working with functions, foldables, traversables, and functors have analogues in lens that can work on almost anything in the hierarchy
07:46:12 <nand`> 1.6 already?
07:46:41 <edwardk> the various ifoo methods and the <+= and <+~ combinators
07:46:48 <edwardk> i work fast
07:47:12 <mauke>   data Iso a b = Iso { hither :: a -> b, yon b -> a }
07:47:17 <mauke> missing :: after yon
07:47:20 <nand`> ‘class Furled r f’
07:47:23 <nand`> interesting name
07:47:29 <edwardk> oh did i still have that in a comment?
07:47:41 <edwardk> nand`: heh its partially from a joke at the office
07:49:23 <nand`> ‘folds :: ((c -> r) -> a -> r) -> (c -> Accessor m d) -> a -> Const m b’
07:49:29 <edwardk> woops
07:49:33 <nand`> this definition seems all over the place
07:49:45 <nand`> should be (c -> Accessor r d) -> a -> Accessor r b I guess
07:50:30 <edwardk> yep
07:50:39 <edwardk> i probably searched without the /g
07:51:19 <edwardk> oh and accessor shouldn't be there
07:51:30 <JorgeArbusto> > let len = foldl (\_ l -> l + 1) 0 in (len [1..],len [])
07:51:35 <lambdabot>   mueval-core: Time limit exceeded
07:52:03 <JorgeArbusto> ?
07:52:11 <nand`> > length [1..] -- infinite list
07:52:15 <lambdabot>   mueval-core: Time limit exceeded
07:52:17 <JorgeArbusto> > let len = foldl (\_ l -> l + 1) 0 in (len [1..10],len [])
07:52:19 <lambdabot>   (11,0)
07:52:57 <JorgeArbusto> > let len = foldl (\_ l -> l + 1) 0 in (len [1],len [])
07:52:58 <lambdabot>   (2,0)
07:53:00 <JorgeArbusto> why 11?
07:53:03 <otters> @pl \f l -> l + 1
07:53:03 <lambdabot> const (1 +)
07:53:11 <nand`> :t foldl
07:53:14 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:53:19 <otters> > let len = foldl (const succ) 0 in len [1..10]
07:53:20 <lambdabot>   11
07:53:32 <nand`> > let len = foldl (\l _ -> l + 1) 0 in (len [1..10], len [])
07:53:33 <otters> :t foldl1 (const succ)
07:53:34 <lambdabot>   (10,0)
07:53:35 <lambdabot> forall a. (Enum a) => [a] -> a
07:53:35 <JorgeArbusto> :t const
07:53:37 <lambdabot> forall a b. a -> b -> a
07:53:49 <JorgeArbusto> > foldl1 (+) 0 [1..3]
07:53:51 <lambdabot>   No instance for (GHC.Num.Num [[t] -> a])
07:53:51 <lambdabot>    arising from a use of `e_11013'...
07:53:57 <JorgeArbusto> :t foldl1
07:53:58 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:54:06 <JorgeArbusto> > foldl1 (+) [1..3]
07:54:07 <lambdabot>   6
07:54:20 <JorgeArbusto> @src foldl1
07:54:21 <lambdabot> foldl1 f (x:xs) = foldl f x xs
07:54:21 <lambdabot> foldl1 _ []     = undefined
07:54:37 <JorgeArbusto> > foldl1 (+) []
07:54:38 <lambdabot>   *Exception: Prelude.foldl1: empty list
07:54:47 <JorgeArbusto> @src length
07:54:48 <lambdabot> Source not found. Wrong!  You cheating scum!
07:54:53 <JorgeArbusto> hey
07:55:31 <nand`> JorgeArbusto: are you still puzzled over why your function returns the wrong result?
07:55:31 <Veinor> @pl \x y -> f x `g` f y
07:55:32 <lambdabot> (. f) . g . f
07:56:19 <typoclass> there's no stock function (a -> b) -> (a,a) -> (b,b), right?
07:56:26 <nand`> typoclass: join (***)
07:56:32 <nand`> is as close as it gets, I'd say
07:56:43 <Veinor> @type join (***)
07:56:44 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:56:45 <JorgeArbusto> Nand: yes
07:56:54 <nand`> JorgeArbusto: try this and the reason should be clear:
07:57:05 <nand`> > let len = foldl (\_ l -> l + 1) 0 in len "hello"
07:57:06 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:57:06 <lambdabot>    arising from a use of `len'...
07:57:25 <typoclass> nand`: uh wow, interesting use of join there :)
07:57:40 <coppro> not really ;)
07:57:49 <coppro> that's what join does on functions
07:57:50 <nand`> typoclass: it's pretty common for ‘joining’ functions like that
07:58:02 <otters> > (join (***) show) (3,6)
07:58:03 <lambdabot>   ("3","6")
07:58:05 <Veinor> i think that's actually the most common use of the function monad
07:58:15 <coppro> > let double = join (+) in double 5
07:58:16 <lambdabot>   10
07:59:18 <otters> @src join
07:59:19 <lambdabot> join x =  x >>= id
07:59:19 <nand`> Veinor: depending on how far you want to bend newtypes, ‘Reader’ is arguably more popular :)
07:59:27 <otters> @src (>>=)
07:59:27 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:59:33 <nand`> >>= is a type-class function
08:00:02 <otters> right
08:00:09 <otters> I forgot how to ask for a specific instance
08:00:17 <nand`> @src ((->) r) (>>=)
08:00:18 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:00:19 <nand`> :(
08:00:22 <nand`> @src Maybe (>>=)
08:00:22 <lambdabot> (Just x) >>= k      = k x
08:00:23 <lambdabot> Nothing  >>= _      = Nothing
08:00:28 <otters> @src (->) (>>=)
08:00:28 <lambdabot> f >>= k = \ r -> k (f r) r
08:00:31 <otters> that's the stuff
08:00:32 <JorgeArbusto> > let len = foldl (\a b -> a + 1) 0 in (len [1],len [])
08:00:34 <lambdabot>   (1,0)
08:00:43 <JorgeArbusto> > let len = foldl (\a b -> a + 1) 0 in (len [1..10], len [1],len [])
08:00:44 <lambdabot>   (10,1,0)
08:00:58 <nand`> JorgeArbusto: that looks better :)
08:00:59 <Veinor> nand`: ... huh. i hadn't realized that Reader and (->) were isomorphic until you mentioned it
08:01:23 <JorgeArbusto> > let len = foldl (\_ l -> l + 1) 0 in (len [10,9..1])
08:01:25 <lambdabot>   2
08:01:30 <otters> I knew that and I don't even know what "isomorphic" means
08:01:43 <Veinor> @pl \x y -> x + 1
08:01:44 <lambdabot> const . (1 +)
08:01:46 <JorgeArbusto> pretty funny mistake, made me think i was one-off, instead i was just stupid :)
08:01:51 <typoclass> i dunno. i'm probably being uncivilized, but i think a function "both f (a, b) = (f a, f b)" is perfectly fine. it's much more clear (to me) than the function monad, which i haven't encountered before
08:01:55 <JorgeArbusto> :t const
08:01:57 <lambdabot> forall a b. a -> b -> a
08:02:06 <JorgeArbusto> > const 45
08:02:08 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
08:02:08 <lambdabot>    arising from a use of `...
08:02:12 <Veinor> > const 45 ()
08:02:14 <lambdabot>   45
08:02:32 <otters> dictionary defines isomorphic as just "similar in form" but I'd think there would be a mathematical definition
08:02:41 <nand`> JorgeArbusto: you can define fold both ways so it's not really an embarrassing mistake
08:02:53 <nand`> you just mixed up the order of arguments :P
08:03:32 <nand`> otters: usually two things (a, b) are isomorphic if there exist functions f :: a -> b and g :: b -> a such that f . g = id and g . f = id
08:03:36 <JorgeArbusto> can you give me an example of a simple isomorphism?
08:03:43 <otters> I see
08:03:44 <typoclass> can anyone think of an example where "join" would have an advantage over "both"? i guess it'd have to be something where you want to use join to handle monads of any sort and not care whether it's a function monad or what
08:03:46 <nand`> JorgeArbusto: Maybe a and Either () a
08:04:09 <JorgeArbusto> nand`: like a simple mathematical one?
08:04:21 <otters> f (Just 3) = Right 3; f _ = Left ()
08:04:32 <otters> okay I see
08:05:02 <nand`> JorgeArbusto: for an example, the sets {a,b,c} and {1,2,3} are isomorphic; you can construct a mapping that assigns ‘1’ to ‘a’, ‘2’ to ‘b’ and ‘3’ to ‘c’; and the same in reverse
08:05:57 <cokanut> Hi, I've a newbie question - if this is the right place to ask. How do I interpret the parentheses in the pattern `quicksort (x:xs) = .. `
08:06:00 <Veinor> note that 'isomorphism' also implies some kind of extra structure that gets preserved
08:06:07 <otters> cokanut: you just need () around the data constructor
08:06:11 <nand`> or in the example of Maybe / Either (); you can write maybe (Left ()) Right :: Maybe a -> Either () a; and either (const Nothing) (Just) :: Either () a -> Maybe a
08:06:16 <otters> (Just n), (a:b), (a,b,c)
08:06:18 <otters> etc.
08:06:19 <cokanut> Isn't () a tuple declaration? or is it a grouping
08:06:24 <Veinor> it's a grouping
08:06:24 <hiptobecubic> cokanut, it's just parens like you know them
08:06:26 <otters> (:) is the data constructor
08:06:34 <Veinor> it's only tuples if there are commas involved
08:06:36 <nand`> Veinor: not really, it's encapsulated in the ‘f .g = id ∧ g . f = id’ thing if you ask me
08:06:42 <cokanut> Oh. Thanks otters and Veinor .
08:06:44 <nand`> so that law is sufficient to describe isomorphisms
08:06:59 <nand`> cokanut: Haskell has no 1-tuples
08:07:13 <typoclass> cokanut: it's a little subtle, when you see () in that place, you have to check if it has a "," in it or a ":". you're right that it's a tuple with ",". but with ":", it's a list
08:07:17 <Veinor> nand`: i can come up with f :: Integer -> Rational and g :: Rational -> Integer such that f.g = g.f = id, but i wouldn't say they're isomorphic
08:07:33 <nand`> Veinor: give me an example of g
08:08:03 <cokanut> typoclass: great. I was following learnyouahaskell and this stumped me for a bit. Thanks for the help everyone.
08:08:04 <Veinor> there exists a bijection from N to Q
08:08:15 <danil> Veinor: they're isomorphic as sets, but the isomorphism doesn't preserve other structure they both have (e.g. addition)
08:08:18 <lamefun> Does Haskell corrupt one's mind?
08:08:29 <nand`> oh, right, by enumerating the rationals
08:08:33 <Veinor> yeah
08:08:33 <typoclass> cokanut: you're welcome
08:08:39 <JorgeArbusto> > fromJust $ Just ()
08:08:41 <lambdabot>   ()
08:08:44 <nand`> Veinor: I'd call them isomorphic in that case
08:08:51 <danil> Veinor: so they're not isomorphic in the category of monoids, say
08:08:56 <Veinor> that's fair
08:09:16 <otters> "bijection"
08:09:50 <nand`> danil: if you're considering monoids, then I'd say the functions would have to be f :: (ℤ,+,0) -> (ℕ,+,0)  and vice versa, not ℤ -> ℕ
08:09:58 <otters> hmmm, if a bijection exists between two sets, does that make them isomorphic?
08:10:06 <hiptobecubic> you loonies and your unicode
08:10:16 <nand`> otters: yes
08:10:21 <JorgeArbusto> you unicodes and your loonies
08:10:22 <danil> otters: in the category of sets the arrows are functions, so yes
08:10:31 <nand`> danil: to be more pedantic, I say we drop the word ‘function’
08:11:31 <nand`> Veinor: the fully category-theoretic definition of isomorphisms regards two morphisms f/g, not two functions; so if all morphisms in say the category of Monoids have to adhere to certain laws, then your isomorphisms have to as well
08:12:28 <nand`> (but in the category Hask, morphisms are simply haskell functions; so it's again valid to say two haskell types are isomorphic if you can define haskell functions such that f.g = id and g.f = id)
08:14:16 <Veinor> nand`: sure :)
08:14:28 <JorgeArbusto> Whats the resason some signs like $,<, can be infix but not words(without the `` quotes)
08:14:46 <JorgeArbusto> > let add = (+) in 5 `add` 7
08:14:47 <lambdabot>   12
08:14:48 <nand`> JorgeArbusto: because Haskell treats them differently, one is an ‘operator’ and the other is a ‘letter’
08:14:58 <copumpkin> JorgeArbusto: a syntactic design decision?
08:15:01 <Veinor> so Integer and Rational are isomorphic in Hask, but Z and Q aren't isomorphic in Grp, or Pos
08:15:09 <nand`> I think this derives from the unicode specifications for the
08:15:12 <nand`> them*
08:15:22 <Veinor> or... probably much of anything interesting besides Set
08:15:42 <nand`> Veinor: probably
08:15:56 <Veinor> makes sense
08:15:58 <JorgeArbusto> template haskell good for making dsls?
08:16:15 <nand`> JorgeArbusto: I wouldn't be too keen on that personally
08:16:44 * hackagebot pointed 3.0.0.1 - Haskell 98 pointed and copointed data (EdwardKmett)
08:16:48 <nand`> great DSLs can be made using simple Haskell data types + your own combinators and interpreters
08:17:23 <Veinor> yeah
08:21:02 <t7> i vote we bring agda style function/operator definitions
08:21:18 <t7> because they can be any case
08:21:19 <t7> :)
08:21:24 <nand`> I want my post/prefix operators damnit :)
08:22:02 <cleantc> any solutions to spread the code of one module to multiple files without introducing new modules? The code has many mutually recursive definitions.
08:22:10 <JorgeArbusto> I like post fix, line em up and smack em with an operator
08:22:40 <nand`> (I'm just secretly trying to make x++ and ++x valid lens code)
08:23:03 <danil> cleantc: there are .hs-boot files that make recursion across module boundaries work
08:24:05 <danil> nand`: there's -XPostfixOperators
08:24:20 <nand`> yeah, but they still require ugly parenthesis
08:24:22 <nand`> this ain't lisp damnit
08:27:38 <JorgeArbusto> can you do multiple-line fun-defs in ghci?
08:28:54 <danil> yes, the :{ command makes it accept lines without evaluating them until you do :}
08:29:25 <nand`> GHCi is sad that it can't interpret your haskell code
08:30:41 <JorgeArbusto> > let f [] = 99; f xs = length xs in f [],f[1..19]¨
08:30:43 <lambdabot>   <no location info>: parse error on input `,'
08:30:43 <JorgeArbusto> > let f [] = 99; f xs = length xs in f [],f[1..19]
08:30:45 <lambdabot>   <no location info>: parse error on input `,'
08:30:49 <JorgeArbusto> > let f [] = 99; f xs = length xs in (f [],f[1..19])
08:30:51 <lambdabot>   (99,19)
08:31:05 <nand`> @tell edwardk let (++) l = l %%= (id &&& succ) in x++ -- how evil?
08:31:06 <lambdabot> Consider it noted.
08:31:28 <JorgeArbusto> > let f [] = 99; f xs = length xs in (f &&& f) [1]
08:31:30 <lambdabot>   (1,1)
08:31:42 <JorgeArbusto> :t (***)
08:31:44 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:32:03 <JorgeArbusto> @src (***)
08:32:04 <lambdabot> f *** g = first f >>> second g
08:32:29 <JorgeArbusto> > let f [] = 99; f xs = length xs in (f *** f) ([],[1..10])
08:32:31 <lambdabot>   (99,10)
08:32:54 <JorgeArbusto> :t foldM
08:32:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:33:14 <cleantc> lambdabot is coded on top of GHC  API?
08:34:17 <quicksilver> it uses mueval
08:34:21 <quicksilver> (which uses the GHC API)
08:34:31 <JorgeArbusto> > foldM (\ a b -> Just $ a + b) 0 [Just 5, Nothing, Just 7]
08:34:33 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
08:34:33 <lambdabot>    arising from a use of...
08:34:36 <JorgeArbusto> > foldM (\ a b -> Just $ a + b) 0 [Just 5, Just 7]
08:34:37 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
08:34:38 <lambdabot>    arising from a use of...
08:34:43 <JorgeArbusto> > foldM (\ a b -> Just $ a + b) 0 [5,7]
08:34:44 <lambdabot>   Just 12
08:35:04 <JorgeArbusto> @src foldM
08:35:05 <lambdabot> foldM _ a []     = return a
08:35:05 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
08:35:08 <JorgeArbusto> > foldM (\ a b -> Just $ a + b) 0 [5,7,9]
08:35:09 <lambdabot>   Just 21
08:49:06 <dfeuer> Hey peeps.  I've written a k-way merge function that uses Control.Monad.State.State to thread a priority queue through the computation. Now I want to replace that (purely functional) priority queue with one based on a mutable array.
08:49:20 <dfeuer> What's the best way to do that?
08:50:02 <dfeuer> Do I maintain my State monad, and add an ST monad to implement the operations?
08:51:18 <n-dolio> If you want to use mutable arrays, you'll have to use ST or IO, pretty much.
08:51:42 <n-dolio> And at that point, passing the queue in an extra state wrapper on top is dubious.
08:51:48 <c_wraith> You start by benchmarking and then tagging your code, such that you can check to see if performance actually improved
08:52:09 <n-dolio> At best you'd need reader, but that probably won't be a lot better than just passing it as an argument.
08:52:12 <zhulikas> @src readTVarIO
08:52:13 <lambdabot> Source not found. Take a stress pill and think things over.
08:52:27 <zhulikas> I assume it's atomically . readTVar ?
08:52:43 <dfeuer> n-dolio: can you explain a little better?
08:52:56 <dfeuer> I can sort of see how ST works,
08:53:08 <dfeuer> but I don't see how it allows me to thread the queue through.
08:53:17 * t7 wonders how tin eye works so fast...
08:53:18 <n-dolio> It doesn't.
08:53:23 <t7> maybe theres a paper
08:53:39 <c_wraith> zhulikas: semantically, yes.  But the actual implementation is going to be entirely different, due to limitations in how STM interacts with things like unsafePerformIO
08:53:47 <dfeuer> So what's the easiest way to accomplish both?
08:53:52 <zhulikas> ok, I see
08:54:02 <n-dolio> You could write 'ReaderT Queue ST a' functions, but that's unlikely to be better than 'Queue -> ST a'.
08:54:20 <dfeuer> I wish I knew what ReaderT was ....
08:54:39 <n-dolio> It is just a wrapper around 'Queue -> ST s a'.
08:54:55 <n-dolio> But it will make all ST operations less convenient to use.
08:54:57 <dfeuer> I don't have a Queue on the outside..... Unless Queue is just a reference of some sort?
08:55:27 <linduxed> is there a prettier way of writing this exhausting pattern match? https://gist.github.com/3286595
08:55:41 <MostAwesomeDude> t7: It hashes images based on a hashing function that is tailored to images. Check out libpuzzle for an example implementation.
08:56:00 <quicksilver> linduxed: you can move the three error cases to the bottom, and turn them into one case
08:56:15 <danil> dfeuer: yes, mutable things (e.g. STArrays) are just references
08:56:18 <quicksilver> pointsToDirections _ = error "Needs three points."
08:56:36 <dfeuer> n-dolio: I don't need ST operations except within the queue implementation....
08:56:50 <nand`> linduxed: I would probably write a helper function group3 :: [a] -> [(a,a,a)] and then map threePointDirection over that
08:56:53 <n-dolio> But using the queue will be an ST operation.
08:57:02 <n-dolio> Enqueue, dequeue, etc.
08:57:04 <dfeuer> Right.
08:57:50 <dfeuer> So can you explain the ReaderT just a tad maybe?
08:57:56 <n-dolio> If you don't use ReaderT, your functions will all have an extra argument, the queue.
08:58:44 <parcs`> dfeuer: are you familiar with the (e ->) monad?
08:58:50 <dfeuer> No.
08:59:27 <dfeuer> I'm familiar with the IO monad. I'm somewhat familiar with the list monad and the Maybe monad.
08:59:28 <parcs`> dfeuer: it operates on functions by implicit passing an argument to each function
08:59:35 <danil> dfeuer: "ReaderT r" is a monad transformer that gives you an operation "ask :: ReaderT r m r" -- that is, computations that have a shared value of type r accessible to them which they can ask for whenever they want
08:59:35 <linduxed> nand`: that's a good idea i guess
08:59:52 <linduxed> quicksilver: oh... but how would i group them?
08:59:53 <parcs`> > (do { a <- (+1); b <- (*2); return (a + b) }) 5 -- dfeuer
08:59:54 <lambdabot>   16
09:00:15 <n-dolio> What do your commands for using the queue look like now?
09:00:36 <quicksilver> linduxed: I don't understand your question
09:00:53 <dfeuer> parcs`: that looks like an entry to the Obfuscated Haskell Code Contest.
09:01:39 <quicksilver> linduxed: http://hpaste.org/72736
09:02:18 <dfeuer> But there never will be an Obfuscated Haskell Code Contest, because it's too easy to write obfuscated Haskell. A real challenge would be an obfuscated LOGO contest....
09:02:19 <parcs`> dfeuer: yeah, nobody directly uses that monad. instead Reader and ReaderT are used, which are simply newtype wrappers over that monad
09:03:25 <nand`> dfeuer: the obfuscated version of that would be (+)<$>(+1)<*>(*@)
09:03:28 <nand`> (*2) even
09:03:32 <dfeuer> o.O
09:03:45 <nand`> > (+)<$>(+1)<*>(*2)$3
09:03:47 <lambdabot>   10
09:03:54 <nand`> > (3+1) + (3*2)
09:03:55 <lambdabot>   10
09:04:08 <dfeuer> That is disgusting.
09:04:11 <danil> > (runWriter . flip runReaderT "Dave") (do { name <- ask; tell ("Hello, " ++ name); tell ("I can't let you do that, " ++ name) })
09:04:17 <lambdabot>   mueval: ExitFailure 1
09:04:17 <lambdabot>  mueval: Prelude.undefined
09:04:34 <hpc> dfeuer: it has its uses
09:04:47 <nand`> one was demonstrated earlier - join
09:04:53 <parcs`> > runReader (do { a <- get; return (a+1+a*2) }) 3
09:04:54 <lambdabot>   No instance for (Control.Monad.State.Class.MonadState
09:04:54 <lambdabot>                     s...
09:05:00 <hpc> > join (*) 5
09:05:01 <lambdabot>   25
09:05:04 <dfeuer> Why is runReaderT backwards (when compared to fold)?
09:05:04 <parcs`> > runReader (do { a <- ask; return (a+1+a*2) }) 3
09:05:05 <hpc> > 5 * 5
09:05:06 <lambdabot>   10
09:05:06 <lambdabot>   25
09:05:24 <hpc> dfeuer: runReaderT is a record access
09:05:30 <danil> dfeuer: it's the newtype unwrapper, so it has to take the ReaderT first
09:05:33 <nand`> > runreader (do { a <- asks (+1); b <- asks (*2); return (a+b)}) 3 -- a closer version
09:05:35 <lambdabot>   Not in scope: `runreader'
09:05:37 <nand`> > runReader (do { a <- asks (+1); b <- asks (*2); return (a+b)}) 3 -- a closer version
09:05:38 <lambdabot>   10
09:05:57 <parcs`> i don't really like how the 'run*T' functions are record selectors
09:06:28 <parcs`> most of the time you want the transformer to be the last argument
09:06:52 <hpc> parcs`: just stylistically?
09:06:55 <nand`> I often want the parameter to be the last; eg. I want to write some function s -> s using a State monad for the internals
09:06:57 <dfeuer> Yes.
09:07:16 <hpc> so like runStateT initial $ do
09:07:17 <hpc>   ...
09:07:18 <nand`> then I can just write ‘evalState $ do ...’, instead of needing an ugly pointful \s -> evalState s $ do ...
09:07:59 <dfeuer> Because having the starting thingum last makes it look like it's just hanging on there at the end. Also, you're likely to actually write it first...
09:08:10 <MostAwesomeDude> flip is your friend.
09:08:26 <parcs`> (`runReader` 3) $ do ....
09:09:01 <LambdaDusk> anyone knowing how to resolve the "unknown symbol `__dso_handle'" error for wxhaskell on ubuntu?
09:09:31 <dfeuer> So now how would you use this ReaderT thingum to help threading something in the ST monad?
09:10:12 <typoclass> LambdaDusk: what ghc compiler are you using? if it's 6.* i think you need to do --make (7.* has it on by default)
09:11:07 <danil> you'd work in ReaderT (Queue s) (ST s), and "q <- ask" would give you the queue so you don't have to pass it around
09:11:12 <LambdaDusk> typoclass: 7.4.2, currently, and it occurs on ghci
09:12:21 <geekosaur> only in ghci?  sounds like ghci's custom linker strikes again
09:13:10 <parcs`> did wxhaskell ever work in ghci?
09:13:12 <LambdaDusk> geekosaur: according to my research, it also occurs when you use wxhaskell in template haskell... but my entire development cycle revolves around ghci
09:13:53 <geekosaur> LambdaDusk, yes, ghci and TH (and runhaskell and ghc -e) all use the same mutant linker
09:14:38 <LambdaDusk> So there's no hope there?
09:15:16 <geekosaur> there's some work on using the system linker but I don't know when it'll be done.  otherwise, I don't think so
09:16:27 <LambdaDusk> damn, but it's the only lib integrated to reactive-banana
09:19:40 <JorgeArbusto> basically could you do a lambda machine? where the hardware was defined functionally? i mean youd have state at that level so how could you?
09:20:20 <sipa> i consider VHDL a functional language
09:20:24 * zhulikas just did producer/consumer problem with Control.Concurrent.Chan
09:20:37 <zhulikas> it's amazing how simple it was to solve the problem
09:20:39 <JorgeArbusto> combinatorial/sequential?
09:20:48 <zhulikas> compared to Java as I did it a year ago
09:29:32 <jerojasro> how can I replace all the matches of a regex in a string?
09:30:07 <jerojasro> I've found a lot of info about *matching*, but not about replacing
09:31:10 <JorgeArbusto> WHy use the short Chan for Channel? it is 3 letters...
09:31:25 <JorgeArbusto> I assume Control.Concurrent.Chan is Channel?
09:31:31 <Cale> yes
09:32:16 <EvanR> if you type Chan 97 times
09:32:19 <EvanR> then you have
09:32:24 <EvanR> > 3 * 97
09:32:25 <lambdabot>   291
09:32:28 <EvanR> more characters
09:32:53 <EvanR> Chan is also half as many syllables to say
09:32:54 <zhulikas> whoa that's a lot
09:33:04 <zhulikas> that is a serious optimisation
09:33:04 <zhulikas> :D
09:33:07 <Cale> lol
09:33:10 <zhulikas> saving me tons of time
09:33:21 <EvanR> it saves me repetative stress injury
09:33:31 <zhulikas> you'll get it anyway :D
09:33:32 <EvanR> and makes my code more likely to fit on the screen
09:33:36 <Cale> It's not a big deal, but this kind of thing does add up when you do it to everything.
09:33:44 <EvanR> next stop, java
09:33:47 <quicksilver> I disagree, actually. I thnk it's a mistake.
09:33:47 <zhulikas> haha
09:34:01 <Cale> If you have a culture of long names, then you force people into using IDEs and tab completion
09:34:01 <quicksilver> pointless abbreviations just make things harder to remember
09:34:25 <typoclass> > length " Chan is also half as many syllables to saymore characters3 * 97then you haveif you type Chan 97 timesit saves me repetative stress injuryand makes my code more likely to fit on the screennext stop, java" `div` 3
09:34:27 <lambdabot>   67
09:34:29 <zhulikas> I really appreciate how EclipseFP is done
09:34:29 <quicksilver> there is a point at which I'd agree
09:34:41 <quicksilver> however, Chan -> Channel is not at that point
09:34:44 <zhulikas> like - I can hover the function and it will give me it's definition
09:34:55 <typoclass> EvanR: you could have written 67 "nel"s for 67 "Chan"s with those keystrokes
09:34:57 <quicksilver> MVar -> MutableVariable is probably.
09:35:08 <zhulikas> or autocomplete includes only functions available through imports
09:35:10 <Cale> I actually *say* Chan and not Channel anyway.
09:35:11 <zhulikas> and default ones of course
09:35:27 <quicksilver> also, MVar gained a life of its own as a genuinely named concept with specific slightly idiosyncratic semantics.
09:35:35 <quicksilver> Cale: yeah, I say "Em-Var"
09:35:36 <Cale> and of course MVar is pronounced Em-Var
09:35:38 <Cale> yeah
09:35:40 <zhulikas> MVar TVar
09:35:48 <zhulikas> confusing
09:35:49 <c_wraith> IVar
09:35:52 <EvanR> quicksilver: at this point Chan isnt an abbrievition
09:35:55 <Cale> InputOutputReference
09:35:57 <nand`> I would be fine with ‘MutVar’
09:35:59 <EvanR> abbrieviation
09:35:59 <zhulikas> c_wraith, apple will sue you for that
09:36:02 <Cale> lololol
09:36:05 <quicksilver> perhaps not, EvanR
09:36:06 <c_wraith> InputOutput ()
09:36:17 <quicksilver> Chan doesn't bother me much, certainly
09:36:20 <c_wraith> zhulikas: no, they'd sue me for iVar.  IVar is fine!
09:36:22 <nand`> I think ‘IO’ is clear; unless people get into a habit of confusing it with moons of jupiter
09:36:32 <EvanR> Io
09:36:34 <EvanR> iO
09:36:35 <nand`> or esoteric languages
09:36:36 <quicksilver> but I do strongly disagree with the general argument that you do it to save characters
09:37:01 <nand`> I think it's less about keystrokes and more about 80col
09:37:01 <zhulikas> it's probably part of Haskell culture
09:37:05 <zhulikas> writing as little code as possible
09:37:22 <EvanR> smaller code is easier to read and verify
09:37:24 <zhulikas> keeping it ellegant
09:37:34 <zhulikas> I wish I could use Haskell in my work
09:38:29 <nand`> by that argument (+)<$>(+1)<*>(*2) is easier to read than liftM2 (+) (+1) (*2) or even do { a <- (+1); b <- (*2); return (a+b) } or perhaps even \c -> 2*c + c + 1
09:38:40 <nand`> easier to read/verify
09:39:13 <zhulikas> daamn :|
09:39:18 <nand`> hmm
09:39:19 <nand`> (*3)+1
09:39:21 <nand`> there we go
09:39:29 <zhulikas> also how could you do a <- (+1) ?
09:39:36 <nand`> zhulikas: ((->) r) monad
09:39:49 <nand`> > (*3)+1  $ 3
09:39:51 <lambdabot>   10
09:39:52 <EvanR> nand`: how is that code smaller
09:40:05 <EvanR> seems about the same
09:40:09 <zhulikas> it will give you finger cancer
09:40:13 <zhulikas> to write that first example
09:40:15 <nand`> EvanR: well, it's definitely smaller than the do-version
09:40:22 <nand`> especially if you write it out over three lines
09:40:30 <EvanR> definitely
09:40:37 <nand`> but the latter can be much clearer, is what I'm saying
09:40:50 <nand`> in general Haskell programmers prefer clarity and elegance; rather than small code
09:41:02 <zhulikas> > do a <- (+1); return (a 0)
09:41:03 <lambdabot>   Overlapping instances for GHC.Show.Show ((t -> b) -> b)
09:41:04 <lambdabot>    arising from a u...
09:42:01 <Cale> > (do a <- (+); return (a 1)) 5
09:42:02 <lambdabot>   6
09:42:11 <zhulikas> so...
09:42:27 <otters> @undo do a <- (+); return (a 1)
09:42:29 <lambdabot> (+) >>= \ a -> return (a 1)
09:42:34 <iamtakin1iteasy> :t (>=>)
09:42:35 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:42:37 <zhulikas> > (do a <- (5+); b <- (4+); return (a + b)) 5
09:42:38 <otters> @pl \a -> return (a 1)
09:42:39 <lambdabot> return . ($ 1)
09:42:39 <lambdabot>   19
09:42:54 <zhulikas> wait.
09:42:54 <otters> > (fmap ($ 1) $ (+)) 4
09:42:56 <lambdabot>   5
09:42:57 <zhulikas> > (do a <- (5+); b <- (4+); return (a + b)) 5
09:42:58 <lambdabot>   19
09:43:01 <zhulikas> whoa
09:43:14 <Cale> > (do a <- id; b <- reverse; c <- map toUpper; return (a,b,c)) "hello"
09:43:15 <lambdabot>   ("hello","olleh","HELLO")
09:43:22 <zhulikas> > ((5+) . (4+)) 5
09:43:26 <lambdabot>   14
09:43:36 <otters> zhulikas: (5 + 5) + (4 + 5)
09:43:43 <nand`> > (5+) + (4+)  $ 5
09:43:43 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
09:43:44 <lambdabot>   19
09:43:44 <lambdabot>   can't find file: L.hs
09:43:46 <danil> I think my intuitive measure of code complexity is the length of time it would take me to read it aloud
09:43:46 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
09:43:48 <lambdabot>   [5,7,10,25,32]
09:44:07 <zhulikas> I am still wondering what happens in that do block
09:44:11 <zhulikas> like
09:44:14 <zhulikas> a <- (5+)
09:44:14 <Cale> > map (ap (,) (^2)) [1..10]
09:44:16 <lambdabot>   [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
09:44:17 <zhulikas> so what is a at that moment?
09:44:22 <nand`> zhulikas: do you know how the Reader monad works?
09:44:28 <zhulikas> a function inside some monad?
09:44:35 <iamtakin1iteasy> from which module >=> comes from?
09:44:37 <nand`> no ‘a’ is a number when it gets bound
09:44:40 <typoclass> i think that obj-c-style names like "(firstElementOfTheList:restOfTheElementsOfTheList)" are detrimental to readability and should be shortened to "(x:xs)", or "(point:points)", or whatever. but that reaches its maximum at a dozen chars or so. i see no point in shaving the last 3 chars off of a 7-char name
09:44:43 <Cale> zhulikas: a is 5 + the function parameter
09:44:53 <nand`> the result of 5+r where r is what you pass in at the end
09:44:56 <Cale> zhulikas: Look at this example:
09:44:58 <Cale> > (do a <- id; b <- reverse; c <- map toUpper; return (a,b,c)) "hello"
09:44:59 <lambdabot>   ("hello","olleh","HELLO")
09:45:20 <nand`> > runReader (do a <- asks id; b <- asks reverse; c <- asks (map toUpper); return (a,b,c)) "hello"
09:45:21 <lambdabot>   ("hello","olleh","HELLO")
09:45:29 <JorgeArbusto> Can you def datas in ghci?
09:45:31 <typoclass> @hoogle (>=>)
09:45:31 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
09:45:38 <iamtakin1iteasy> ah
09:45:39 <danil> JorgeArbusto: in 7.4 and up, yes
09:45:39 <nand`> JorgeArbusto: after version 7.4.1 yes
09:45:39 <typoclass> iamtakin1iteasy: ^^ here you go
09:45:40 <nand`> maybe 7.0
09:45:40 <iamtakin1iteasy> thank you!
09:45:44 <parcs`> zhulikas: in a <- ma, a is whatever 'ma >>= \a -> ...' defines it to be
09:45:48 <otters> heh
09:45:50 <otters> "datas"
09:45:55 <zhulikas> damn you!
09:45:55 <otters> it's a hyperplural
09:46:07 <nand`> dat as
09:46:11 <zhulikas> :))
09:46:17 <Cale> peoples
09:46:22 <parcs`> zhulikas: do you understand the implementation of >>= for ((->) e)
09:46:42 <Cale> It's easier to understand what the function monad does first
09:46:48 <zhulikas> I never came across ((->) e)
09:46:51 <Cale> Than to understand the implementation of >>= :)
09:47:00 <JorgeArbusto> @src monad
09:47:01 <lambdabot> Source not found. Where did you learn to type?
09:47:10 <Cale> Once you understand what the function monad is trying to do, then the implementation of >>= is fairly obvious
09:47:13 <nand`> the function monad is for ‘environment sharing’
09:47:34 <parcs`> Cale: yeah but even when i understood the function monad, 'a <- (+1)' still kind of perplexed me like it does zhulikas
09:47:44 <JorgeArbusto> Maybe is a data and a monad? just the type Maybe isnt a Monad aight?
09:47:52 <Cale> "Running" a function here means applying it to the argument to which the whole function has been applied.
09:47:54 <nand`> Maybe is a Monad
09:47:59 <otters> and a datatype
09:48:00 <nand`> not sure what you're asking
09:48:09 <otters> yeah, Maybe is both a datatype and a Monad
09:48:18 <Cale> > (do a <- id; b <- (+10); c <- (+20); return (a,b,c)) 5
09:48:19 <nand`> Maybe is a datatype with a Monad instance
09:48:20 <lambdabot>   (5,15,25)
09:48:22 <JorgeArbusto> > (do { a <- length >>= return a) [1..10]
09:48:24 <lambdabot>   <no location info>: parse error on input `)'
09:48:31 <Cale> zhulikas: ^^ does that help?
09:48:42 <nand`> It's a type constructor, perhaps more formally
09:49:07 <JorgeArbusto> > (do { a <- length; return a) [1..10]
09:49:08 <lambdabot>   <no location info>: parse error on input `)'
09:49:17 <JorgeArbusto> > (do { a <- length }; return a) [1..10]
09:49:18 <lambdabot>   <no location info>:
09:49:19 <lambdabot>      The last statement in a 'do' construct must be an ...
09:49:19 <zhulikas> > map 5 [(id, (+10), (+20)]
09:49:21 <lambdabot>   <no location info>: parse error on input `]'
09:49:28 <Cale> > (do a <- length; return a) [1..10]
09:49:29 <lambdabot>   10
09:49:32 <zhulikas> I was expecting same result as for Cale's example
09:49:40 <Cale> > (do a <- length; b <- reverse; return (a,b)) [1..10]
09:49:40 <zhulikas> whoops, error
09:49:41 <lambdabot>   (10,[10,9,8,7,6,5,4,3,2,1])
09:49:43 <JorgeArbusto> > (do a <- length; return a) [1..10]
09:49:45 <zhulikas> > map 5 [id, (+10), (+20)]
09:49:45 <lambdabot>   10
09:49:46 <lambdabot>   [5,5,5]
09:49:50 <zhulikas> heh
09:49:53 <Cale> hah
09:49:55 <nand`> zhulikas: you want map ($5)
09:50:00 <Cale> now you're using the Num instance for functions :)
09:50:08 <otters> lambdabot has some fucked up num instances
09:50:09 <otters> > 5 5
09:50:11 <lambdabot>   5
09:50:13 <zhulikas> but how is that different from what Cale wrote?
09:50:14 <Cale> It's not fucked up
09:50:16 <JorgeArbusto> map ($5) [id, (+10), (+20)]
09:50:17 <zhulikas> except the tuple thingie
09:50:20 <MostAwesomeDude> > 5 6
09:50:21 <lambdabot>   5
09:50:25 <Cale> It's exactly what you'd expect of a Num instance for functions.
09:50:28 <JorgeArbusto> > map ($5) [id, (+10), (+20)]
09:50:30 <lambdabot>   [5,15,25]
09:50:35 <otters> Cale: just what I said
09:50:56 <zhulikas> :t (->)
09:50:58 <lambdabot> parse error on input `->'
09:51:00 <Cale> zhulikas: How is what different from what I wrote?
09:51:02 <nand`> > length + 1 $ "hello"
09:51:03 <lambdabot>   6
09:51:04 <Peaker> Some might expect no such instance :)
09:51:11 <nand`> :)
09:51:20 <zhulikas> <JorgeArbusto> > map ($5) [id, (+10), (+20)]
09:51:20 <zhulikas> <Cale> > (do a <- id; b <- (+10); c <- (+20); return (a,b,c)) 5
09:51:23 <zhulikas> results are the same
09:51:38 <Cale> zhulikas: yes, apart from the type
09:51:42 <Cale> zhulikas: so?
09:51:44 <zhulikas> so what's the type?
09:51:48 * hackagebot not-gloss 0.4.2 - Painless 3D graphics, no affiliation with gloss (GregHorn)
09:51:49 <zhulikas> I understand how map works here
09:51:50 <LambdaDusk> Is there a way to put a callback for new data on a socket stream in haskell?
09:51:58 <zhulikas> but not the do block
09:52:12 <zhulikas> maybe there is a document I could read online about this?
09:52:21 <nand`> Peaker: I'd expect a num instance for any applicative :P
09:52:26 <Cale> zhulikas: a = id 5 = 5, b = (+10) 5 = 15, c = (+20) 5 = 25
09:52:41 <Cale> zhulikas: The entire do-block is a function
09:52:48 <otters> :t 5
09:52:49 <lambdabot> forall t. (Num t) => t
09:52:52 <otters> :t 5 5
09:52:53 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
09:52:55 <Cale> zhulikas: "running" a function inside that do block, like  x <- f
09:52:56 <otters> :t (5 $)
09:52:57 <zhulikas> but why use <- instead of 'let'
09:52:58 <lambdabot> forall a b. (Num b) => a -> b
09:53:13 <nand`> zhulikas: because you don't have access to ‘5’ inside the do-block
09:53:19 <otters> > (5 $) + (4 $)
09:53:20 <Cale> zhulikas: Means  x = f v, where v is the parameter to the whole function
09:53:20 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
09:53:21 <lambdabot>    arising from a use of `...
09:53:28 <otters> > ((5 $) + (4 $)) 3
09:53:29 <lambdabot>   9
09:53:40 <nand`> (5 $) is 5
09:53:46 <zhulikas> so you run a function and apply an argument afterwards? O.o
09:54:00 <nand`> so that's (5+4) 3 = 9 3 = 9
09:54:05 <Cale> "afterwards" and "before" have no place here
09:54:14 <zhulikas> is it like - you "construct" a function inside that do-block out of three different functions?
09:54:18 <Cale> > (do a <- id; b <- reverse; c <- map toUpper; d <- length; return (a,b,c,d)) "hello"
09:54:19 <lambdabot>   ("hello","olleh","HELLO",5)
09:54:20 <nand`> zhulikas: you define a function
09:54:27 <zhulikas> so
09:54:28 <nand`> you construct it, yes
09:54:31 <nand`> the entire do block is a function
09:54:32 <zhulikas> it's like
09:54:38 <zhulikas> Num a => a -> (a,a,a)
09:54:40 <zhulikas> right?
09:54:41 <parcs`> zhulikas: personally it helped to desugar do into >>= and return, and then to use equational reasoning to decompose >>= and return
09:54:44 <zhulikas> after you write the do-block
09:54:56 <Cale> > (\v -> let a = id v; b = reverse v; c = map toUpper v; d = length v in (a,b,c,d)) "hello"
09:54:56 <nand`> :t do a <- id; b <- (+10); c <- (*3); return (a,b,c)
09:54:57 <lambdabot>   ("hello","olleh","HELLO",5)
09:54:58 <lambdabot> forall a. (Num a) => a -> (a, a, a)
09:55:00 <danil> zhulikas: yes, exactly -- a do block in the monad M takes a bunch of M-ish things and builds you a bigger M-ish thing
09:55:01 <nand`> zhulikas: correct
09:55:11 <Cale> zhulikas: yes, that's right
09:55:16 <zhulikas> mind = fucked
09:55:18 <nand`> the monad here is Num a => ((->) a)
09:55:30 <nand`> so the result is ‘m (a,a,a)’ in this monad, or (a -> (a,a,a))
09:55:34 <Cale> zhulikas: It's similar to writing a lambda, plus some parameter passing?
09:55:42 <JorgeArbusto> > \a -> 2 * a $ 5
09:55:44 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> b)
09:55:44 <lambdabot>    arising from a u...
09:55:48 <otters> @undo do a <- id; b <- (+10); c <- (*3); return (a,b,c)
09:55:49 <lambdabot> id >>= \ a -> (+ 10) >>= \ b -> (* 3) >>= \ c -> return (a, b, c)
09:55:49 <Cale> zhulikas: I mean, it should be no more confusing than this:
09:55:52 <JorgeArbusto> > (\a -> 2 * a) $ 5
09:55:54 <zhulikas> @type (do a <- (+10); b <- id; return (a, b))
09:55:54 <lambdabot>   10
09:55:55 <JorgeArbusto> > (\a -> 2 * a) 5
09:55:55 <otters> @. pl undo do a <- id; b <- (+10); c <- (*3); return (a,b,c)
09:55:55 <lambdabot> forall a. (Num a) => a -> (a, a)
09:55:55 <lambdabot> ((10 +) >>=) . ((((3 *) >>=) . (return .)) .) . (,,) =<< id
09:55:56 <lambdabot>   10
09:55:59 <Cale> > (\v -> (v, v+10, v+20)) 5
09:55:59 <zhulikas> here we go
09:56:00 <lambdabot>   (5,15,25)
09:56:04 <zhulikas> <lambdabot> forall a. (Num a) => a -> (a, a)
09:56:08 <typoclass> JorgeArbusto: lambdabot is also available privately
09:56:18 <JorgeArbusto> how
09:56:23 <nand`> /query lambdabot
09:56:30 <JorgeArbusto> sorry
09:56:38 <typoclass> JorgeArbusto: don't worry :)
09:56:54 <zhulikas> so (->) is a monad and can work in a do-block as any other monad
09:57:05 <nand`> not quite
09:57:08 <nand`> ((->) r) is a monad
09:57:13 <zhulikas> yes
09:57:18 <zhulikas> because it takes a type
09:57:21 <zhulikas> argument
09:57:29 <zhulikas> like Maybe a
09:57:29 <Cale> Which you might also write (r ->) if you were allowed to
09:57:30 <otters> (r ->)
09:57:30 <nand`> > (id >> reverse) "hello"
09:57:31 <JorgeArbusto> how do i anonymous recursion with fix?
09:57:32 <lambdabot>   "olleh"
09:57:34 <JorgeArbusto> @src fix
09:57:35 <lambdabot> fix f = let x = f x in x
09:57:39 <JorgeArbusto> :t ype fix
09:57:40 <lambdabot> Not in scope: `ype'
09:57:50 <JorgeArbusto> :t fix
09:57:52 <lambdabot> forall a. (a -> a) -> a
09:58:00 <typoclass> zhulikas: the best 'document' to read might be http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad-Instances.html . it says "f >>= k = \ r -> k (f r) r", which means it will give you a function (represented by the lambda), which will take one argument and pass it into f. then it will take the result and the original argument, and pass it to k
09:58:01 <zhulikas> so, can anyone point me to some online article about ((->) a) ?
09:58:19 <Cale> zhulikas: There's not much more to say about it than what we already have
09:58:28 <nand`> JorgeArbusto: ‘fix’ passes the result of a function to itself; so if the first parameter to your function is some ‘f’ then that can be used to refer to itself
09:58:33 <typoclass> zhulikas: (you know how do blocks desugar into a long chain of "x >>= y >>= z", right?)
09:58:50 <zhulikas> typoclass, sure
09:59:05 <MostAwesomeDude> zhulikas: Given that ((->) e) is a Monad, go write out, on paper, the Functor and Monad instances for it.
09:59:13 <MostAwesomeDude> It's quite an enlightening exercise.
09:59:24 <Cale> If you write down the types, there's only one way to do things.
09:59:28 <nand`> there's another interesting thing about ((->) a): it, like any monad, is also an applicative; but the applicative instance for it is exactly the SK calculus - which is based around a similar concept of ‘environment sharing’
09:59:55 <Cale> nand`: Yeah, that's very enlightening in one way or another :)
10:00:12 <Cale> If you already know about the SK calculus, you might be convinced of the relevance of Applicative by it.
10:00:30 <Cale> If you already know about Applicative, you might be convinced of the relevance of SK calculus by it :)
10:01:04 <nand`> if you know both, then you think it's cute
10:01:06 <Cale> (In my case, it was the first of the two)
10:01:39 <nand`> I was convinced by the relevance of Applicative when confronted with applicatives that are *not* monads
10:02:00 <Cale> There are not so many of those though.
10:02:34 <Cale> The question being, do we really want to start getting all these libraries to support this interface that only very few of them really *need*
10:02:55 <Cale> and the answer is probably yes, but when Applicative had just been introduced, that was less clear to me
10:03:22 <nand`> right; well, it's useful for other reasons too
10:03:51 <nand`> since a certain subset of expressions involving monads is also applicable to applicatives (pardon), you can use applicative syntax to shorten them
10:03:57 <nand`> even though you're working with monads
10:04:15 <Cale> <*> is nice notation to have, but it could just as well be a Monad operator if we didn't like Applicative
10:04:23 <Peaker> nand`, Yeah, I just don't know if "it does what you'd expect" is a great explanation :)
10:04:30 <nand`> yes, but my point is that the library itself is not useless for that reason
10:04:40 <Peaker> nand`, it is good enough for people familiar with Applicative/Num, covariance, etc
10:04:44 <nand`> and the different type may as well be decoration for those use cases, no effort is wasted either way
10:05:11 <linduxed> quicksilver: thx, that was the explanation i was looking for
10:05:33 <nand`> (well, that would be assuming class Applicative m => Monad m either way)
10:05:58 <Peaker> what good examples of non-Monad Applicatives do we have?
10:06:13 <nand`> ZipList and Const m are the first two I can think of
10:06:24 <Peaker> I like the example of efficient parser-combinators, but unfortunately I don't know any library that actually takes advantage of non-monadicness in parser-combinators
10:06:36 <Philippa> uu-parselib, IIRC
10:06:50 <JorgeArbusto> who was doing producer consumer with Chan before?
10:06:52 <Peaker> nand`, ZipList is an Applicative without same-length constraint and Monad only with it?
10:06:55 <frerich_> Does '&&&' have a pronounceable name? Talked about some code on a whiteboard involving it today, it was a bit odd to stand there with the pen in my hand saying 'You can apply both head and length to, uhm, and-and-and, and then pass that to map'.
10:06:56 <JorgeArbusto> can yopu hpaste yer stuff?
10:07:07 <Philippa> I don't know if Trifecta will exploit it where it can or not. I've toyed with writing one myself, but I was working with some very specific things and didn't finish
10:07:07 <JorgeArbusto> :t const
10:07:08 <lambdabot> forall a b. a -> b -> a
10:07:11 <nand`> for example, Traversables work with all applicatives, not all monads; so you can traverse over ‘Const m’ to use a Traversable as a Foldable instead; not something you could do it it required a monad
10:07:18 <JorgeArbusto> > (const succ) 1
10:07:19 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:07:20 <lambdabot>    arising from a use of `...
10:07:22 <zhulikas> where else can I find code of ((->) r) ?
10:07:28 <zhulikas> except Control.Monad.Instances
10:07:32 <nand`> Peaker: I'm not entirely sure
10:07:37 <edwardk> it?
10:07:37 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
10:07:41 <Peaker> Philippa, ah, cool, do you know how they take advantage of it? if they do a Non-deterministic automaton conversion to deterministic or such?
10:07:47 <typoclass> zhulikas: there is only that code. honestly.
10:07:52 <zhulikas> I am not entirely sure how it works and constructs functions
10:07:52 <Peaker> nand`, Why is Const m  not a monad?
10:07:56 <edwardk> oh the applicative structure
10:08:09 <nand`> Peaker: well, you can make it a monad in a trivial way
10:08:10 <edwardk> i had a test that used the extra char header information but it never benchmarked faster
10:08:17 <nand`> Peaker: but then you lose the properties of the applicative const m
10:08:20 <zhulikas> what is ((->) r) besides being a monad/functor instance?
10:08:25 <nand`> Applicative :P
10:08:35 <Philippa> Peaker: I can't remember off-hand, though that sounds about right. My own was going somewhat further, but it was limited to finite grammars :-)
10:08:35 <zhulikas> :D
10:08:40 <Peaker> nand`, newtype Const a b = Const a  <-- this Const?
10:08:44 <nand`> Peaker: yeah
10:09:03 <Peaker> nand`, what is the interesting applicative?
10:09:12 <nand`> Peaker: Const a <*> Const b = Const (a <> b); but you can't write >>= in a reasonable way because you can't actually extract the ‘b’ in order to pass it to the function
10:09:14 <edwardk> @tell nand` too evil. the ability to 'section' an operator as a function that takes one argument is a ghcism and its ugly with the ()'s around it you need
10:09:14 <lambdabot> Consider it noted.
10:09:23 <nand`> so the only valid >>= is Const m >>= _ = Const m
10:09:24 <lambdabot> nand`: You have 1 new message. '/msg lambdabot @messages' to read it.
10:09:30 <Peaker> nand`, ah, I see.. like a variant of Writer
10:09:40 <edwardk> hah, maybe i shouldn't have @tell'd ;)
10:09:41 <JorgeArbusto> > (const succ) [] 6
10:09:43 <lambdabot>   7
10:09:43 <nand`> edwardk: well, I meant for the semantics of ++ itself
10:09:45 <JorgeArbusto> > (const succ) 6 []
10:09:47 <lambdabot>   No instance for (GHC.Enum.Enum [a])
10:09:47 <lambdabot>    arising from a use of `e_16' at <int...
10:10:06 <nand`> (apart from the evil -XPostfixOperators and shadowing the existing (++) etc.)
10:10:08 <JorgeArbusto> > SUCC 5
10:10:09 <lambdabot>   Not in scope: data constructor `SUCC'
10:10:12 <JorgeArbusto> > succ 5
10:10:14 <lambdabot>   6
10:10:23 <JorgeArbusto> const throws away its second arg?
10:10:26 <zhulikas> @type (>>)
10:10:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:10:31 <nand`> Peaker: yes exactly; Traversables are a good use case; see also lenses
10:10:39 <nand`> JorgeArbusto: yes
10:10:39 <edwardk> you could make preincrement and postincrement operators that i wouldn't reject
10:10:47 <Peaker> nand`, What about lenses?
10:10:58 <JorgeArbusto> so: (const succ) [] 5; means it throws away [] and then comes 5 in
10:11:02 <JorgeArbusto> obv
10:11:06 <zhulikas> @type (\a -> a)
10:11:08 <lambdabot> forall t. t -> t
10:11:18 <edwardk> Peaker: i use 'Const' (or something like it) to read from a lens
10:11:21 <zhulikas> @type ((->) \a a)
10:11:21 <JorgeArbusto> > (const succ) [] 5 1
10:11:23 <lambdabot> parse error on input `->'
10:11:23 <lambdabot>   No instance for (GHC.Enum.Enum (t -> a))
10:11:23 <lambdabot>    arising from a use of `e_151' a...
10:11:31 <Peaker> edwardk, do you use the Monoid-applicative instance of Const?
10:11:32 <nand`> Peaker: reading from a van-laarhoven style lens requires using the Const m functor; but if you're trying to read from a traversal (which requires an applicative, not a functor) it involves that instance; if traversals instead required monads it would not work
10:11:33 <zhulikas> I imagine (->) also being a constructor
10:11:33 <edwardk> Peaker: when i have a monoid on the argument to const then i can use a Fold
10:11:34 <JorgeArbusto> > (const (const succ) [] 5 1)
10:11:36 <edwardk> Peaker: yes
10:11:36 <lambdabot>   2
10:12:16 <edwardk> A Fold looks like (modulo the class machinery to make pretty errirs): forall r. Monoid r => (c -> Const r d) -> (a -> Const r b)
10:12:30 <nand`> edwardk: (if you just joined, this is about examples of what Applicative is good for, as compared to simply using return and ap instead)
10:12:53 <edwardk> since a Traversal works for any applicative, and the monoid for m, gives you an applicative, you can use a Traversal as a Fold
10:13:02 <edwardk> zipList
10:13:08 <Lajla> The point is
10:13:12 <nand`> already mentioned :P
10:13:16 <Lajla> LGBT makes no sense, I mean, grouping the T with the LGB
10:13:24 <nand`> Lajla: wrong channel?
10:13:26 <Lajla> Surely T is completely orthogonal and unrelated to LGB?
10:13:42 <copumpkin> o.O
10:13:43 <Lajla> nand`, true, but you have to agree.
10:13:51 <copumpkin> Lajla: take it elsewhere
10:13:52 <Lajla> Also, why do L and G get their own letters.
10:13:53 <edwardk> Lajla: not here
10:13:58 <Lajla> Okido
10:14:51 <Peaker> edwardk, I wish you changed all these "a,b,c,d,r" to two-letter typevar names that had some sort of convention to remind you who they were.. even if by analogy (e.g: outer-record, outer-field, even if in the generalized case it's not actually a record/field)
10:14:53 <edwardk> applicatives are useful when you have context insensitivity, monads give you a notion of context sensitivity
10:15:13 <nand`> Peaker: I suggested a a' b b' already, which is better than a/b/c/d imo
10:15:26 <nand`> but by now I've gotten used to a/b/c/d either way
10:16:29 <Philippa> edwardk: or equivalently, when you want the possibility of a static structure. Not all analyses are used for optimisation: sometimes it's just not worth the pain of figuring out how to do it in the type system!
10:17:37 <edwardk> the convention is a b c d r ;)
10:17:42 <Peaker> nand`, yeah, I prefer that too.  though a/b also doesn't emphasize that one of them is the "whole" and the other is a "part"
10:17:42 <Peaker> or maybe some generalized notion of that
10:18:03 <Peaker_> edwardk, that's a convention that's hard to remember...
10:18:08 <Peaker_> edwardk, the usual "excuse" for one letter names is "it's so general there's nothing more to say"
10:18:12 <Peaker_> but here it's not really true
10:18:20 <typoclass> how about "a" and a cyrillic thing that looks exactly like "a" 8-)
10:18:26 <edwardk> it'd be thousands of lines of changes, i'm not in a hurry to make for longer types
10:18:41 <nand`> Peaker_: maybe you would like Lens o o' i i'
10:18:46 <Peaker_> edwardk, Would you accept a pull request of all these changes?
10:18:51 <Peaker_> nand`, that sounds great to me
10:18:54 <edwardk> honestly? probably not
10:18:58 <edwardk> i consciously decided not to use the 's
10:19:06 <Peaker_> edwardk, why not?
10:19:12 <nand`> I don't like the ways the ' look either; they're great for blog posts and understanding
10:19:24 <nand`> but they create a sort of visual clutter
10:19:36 <Peaker> nand`, less clutter than oa ob ia ib
10:19:36 <edwardk> because they look cluttered
10:19:41 <Philippa> hell, I'd love to have subscripts?
10:19:53 <Philippa> still cluttering, but at least optionally meaningful clutter
10:20:07 <nand`> I want to use ⟨x₁,x₂⟩ for my tuples :(
10:20:15 <danil> clearly we should write lens types as commutative squares and dispense with names
10:20:24 <Peaker> edwardk, hmm.. if pragmatism and aesthetics conflict -- I think it's important to choose the former..
10:20:46 <nand`> when pragmatism and aesthetics conflict I think it's important to spend more time finding a solution that fulfils both
10:20:53 <Peaker> edwardk, the type signatures take me a long time to decipher, each time :(
10:21:01 <edwardk> and i think its quite pragmatic to see the four parameters separately ;)
10:21:14 <Peaker> nand`, but apparently nobody is satisfied with the aesthetics of the pragmatic solutions here
10:21:29 <edwardk> once you get into the (c -> f d) -> a -> f b  pattern the names are used consistently
10:21:30 <nand`> one good thing I like about your haddock is the way you often mention the ‘expanded’ form of a lenslike type as well
10:21:47 <nand`> I've gotten good at reading the Monoid m => (c -> Const m d) -> a -> Const m b style types
10:21:54 <nand`> so often those will clear up any confusion
10:22:15 <lamefun> hi
10:22:27 <Peaker> I've used it for some hours now and still have difficulty -- it's hard to imagine the a's and b's will be as easy as something slightly suggestive of the function, but maybe...
10:22:31 <edwardk> yeah i included the expanded versions where it makes sense and isn't too much of a lie
10:22:41 <Peaker> yet another reason we need a structural editor -- we could "skin" edwardk's library with different typevar names :)
10:22:46 <edwardk> =P
10:23:05 <Philippa> Peaker: hell, that's a reason for a full-blown IDE
10:23:20 <Peaker> I'd be able to skin away all the unicode so many FP users use too :)
10:23:24 <artagnon> http://pastie.org/4406959 -- I'm stuck because readCase returns an IO [Int] when I want just an [Int].  Any clues?
10:23:38 <Peaker> Philippa, yeah -- the structural editor we're working on is supposed to become a full-blown IDE
10:23:43 <geekosaur> artagnon, might want to visit a Haskell tutorial.
10:23:59 <geekosaur> @quote contains.*file
10:24:00 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
10:24:01 <artagnon> geekosaur: Could you suggest one?
10:24:06 <geekosaur> @where LYAH
10:24:07 <lambdabot> http://www.learnyouahaskell.com/
10:24:17 <artagnon> Oh, I've already read that.
10:24:20 <zhulikas> @type (>>=)
10:24:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:24:25 <zhulikas> artagnon, ^^
10:24:37 <geekosaur> meaningof that quote:  you are probably looking for a way to get the [Int] out, and you don't.
10:24:52 <Philippa> Peaker: so when it's comfortably and readily usable on my system I shall be duly impressed :-) (much as you're welcome to not be /that/ impressed by my own unimplemented ideas)
10:24:59 <astory> is there a way to get cabal to automatically download documentation for dependencies?  I'm trying to generate some local haddock documentation but it's not finding the documentation for stuff like base
10:25:07 <artagnon> geekosaur: Right.
10:25:20 <Peaker> Philippa, that was not supposed to be impressive, just agreeing that we need a full blown IDE.. maybe that "structural editor" is not a good description of it either
10:25:20 <Philippa> and I appreciate that I'm being picky about where I set the bar there too, so don't worry 'bout it?
10:25:26 <artagnon> zhulikas: Right, so that's what the `do` is doing.
10:25:37 <nand`> “First line of input contains number of test cases” <- does anybody else think this type of input is clearly biased towards imperative languages / for loops? I would have expected ‘the input is terminated by EOF’ or something
10:25:54 <artagnon> nand`: It is.
10:26:07 <artagnon> ... I want to solve it using Haskell nevertheless.
10:26:13 <artagnon> As a learning exercise.
10:26:21 <Peaker> nand`, it just makes it easier in imperative langs -- closer to how it is in functional ones
10:26:22 <geekosaur> artagnon, "x >>= \y ->" in do notation is "y <- x"
10:26:29 <Philippa> Peaker: yeah, it's tricky naming things at times. "Semantically aware editor"?
10:26:32 <typoclass> artagnon: to fix your problem, you might change the caseList function so that is in IO as well. then you can use readCase sensibly in there
10:26:41 <Philippa> (now there's a gap we've got into arguments about before)
10:26:42 <geekosaur> note that it's incomplete and you have to do something else to complete it
10:26:57 <artagnon> typoclass: Okay, then what do I do in `main`?
10:27:04 <t7> AST editor :)
10:27:08 <t7> with opengl
10:27:09 <geekosaur> hm, ok, should maybe load the paste before commenting on chatter...
10:27:13 <t7> spinning functions
10:27:15 <typoclass> artagnon: you'll have to make a few changes in main as well
10:27:16 <zhulikas> artagnon, first of caseList should be Int -> [Int] -> IO [Int] if you want to use readCase inside of it. Because readCase :: IO [Int]
10:27:26 <Peaker> Philippa, I used similar terms at first, but that is a bit problematic too, since everything the editor can do (almost by definition) is in the realm of syntactic things... the semantics are an interpretation of what the editor does
10:27:29 <JorgeArbusto> :t atomically
10:27:31 <lambdabot> Not in scope: `atomically'
10:27:39 <artagnon> zhulikas: Right, got it.  What do I do in `main`?
10:27:46 <Peaker> t7, are you talking about bottle or something else?
10:28:20 <JorgeArbusto> cant i just writeChane 5?
10:28:40 <typoclass> artagnon: having said that, when going from beginner to intermediate haskeller, it's probably a good goal to try to have as few functions in IO as possible, and as many functions pure as possible. (on that front you're doing quite well currently, readCase is IO, the other 2 functions are pure, except that it doesn't quite work of course :-) )
10:29:03 <artagnon> typoclass: Right :)
10:29:45 <Peaker> artagnon, also, don't use booleans and guards when your condition is essentially a pattern-match
10:30:08 <argiopeweb> JorgeArbusto:  Because Monads. :P Technically you can if you use Control.Concurrent.Chan instead of Control.Monad.STM, but it may not do what you want.
10:30:09 <t7> Peaker: im still waiting for some example code in bottle
10:30:10 <Peaker> artagnon, parseString [] = [] ; parseString xs = ...
10:30:11 <nand`> “boolean blindness” hehe
10:30:18 <Peaker> t7, you mean, realistic code? :)
10:30:27 <Philippa> Peaker: "Semantically aware" mostly means that you can ask questions that make use of the semantics. Manipulating bound variables and binders is still at least moderately semantically aware even if it's a "syntactic" issue
10:30:28 <artagnon> Peaker: Right, thanks for that.
10:30:41 <Philippa> (foundationally, it's *all* syntax, the question is how nested...)
10:30:47 <t7> just hello world and 99 bottles of bear
10:30:48 <Philippa> (what is meaning?)
10:30:55 <t7> or fib
10:30:56 <argiopeweb> JorgeArbusto:  Oh, and apologies. Read that as "why can't I"
10:31:18 <JorgeArbusto> how do i shop Just 5 to print? like Just 5 >>= print ?
10:31:22 <t7> bottles of bear :| beer*
10:31:30 <nand`> that's a type error
10:31:36 <nand`> and I don't understand your question
10:31:43 <typoclass> JorgeArbusto: you can just do "print (Just 5)"
10:31:48 <t7> > return (Just 5) >>= print
10:31:49 <lambdabot>   <IO ()>
10:32:02 <Philippa> typoclass: working in tightly-chosen monads rather than pure qua pure is an option as you're becoming intermediate too, but it does require a certain attitude towards layering
10:32:08 <Peaker> t7, Well, we generally test bottle by writing factorial in it :)
10:32:19 <t7> show me the codez!
10:32:21 <Peaker> t7, (recursively)
10:32:30 <hpaste> zhulikas pasted “artagnon” at http://hpaste.org/72740
10:32:33 <typoclass> Philippa: sure yes. i was focused on IO really
10:32:35 <zhulikas> artagnon, try something like this
10:32:50 <artagnon> zhulikas: Thanks, looking into it.
10:32:50 <zhulikas> and change your main a bit
10:33:46 <typoclass> zhulikas: wait, IO [Int] -> IO [Int]?
10:33:51 <artagnon> zhulikas: I would have liked to keep caseList pure.
10:34:09 <zhulikas> hehe
10:34:19 <zhulikas> ok, not the best solution
10:34:36 <zhulikas> you'd need an inner recursive function
10:34:47 <zhulikas> but hey, I tried!
10:34:56 <artagnon> Why should this be so hard?
10:35:05 <zhulikas> because I'm still a noob
10:35:09 <artagnon> It's a standard programming challange type input.
10:35:28 <artagnon> Oh, thanks for trying :)
10:35:53 <JorgeArbusto> >>= return == id ?
10:35:54 <lamefun> why do people use $?
10:36:01 <nand`> lamefun: precedence
10:36:16 <Cale> lamefun: because it reduces the need for parentheses that end far away from where they begin
10:36:18 <typoclass> lamefun: largely to avoid some closing parens
10:36:18 <Peaker> t7, https://github.com/Peaker/bottle.factorial.example/raw/master/bottle.db.tgz <-- unpack this to your home-dir (it will create ~/bottle with factorial db in it)
10:36:19 <artagnon> lamefun: It saves a lot of ()
10:36:22 <nand`> compare (f g) (x y) with f g $ x y
10:36:33 <Peaker> t7, then run the most up-to-date bottle
10:36:39 <Peaker> t7, and you'll see factorial
10:37:01 <Cale> lamefun: consider something like  withFoo $ \foo -> do ... long block of code ...
10:37:20 <Cale> lamefun: vs.  withFoo (\foo -> do ... long block of code ... )
10:37:23 <nand`> Should sharing files really constitute passing around ~/bottle ?
10:37:30 <Cale> lamefun: It sucks to have to remember that )
10:37:33 <Peaker> nand`, no :)
10:37:45 <Peaker> nand`, you know we have a *lot* of work to do before we release it, right? :)
10:37:51 <nand`> fair enough
10:38:37 <zhulikas> I just looked into what is this program trying to do
10:38:48 <zhulikas> (should have done it in the beginning)
10:38:58 <Peaker> nand`, it will probably constitute of pulling from a URL.. i.e: instead of "git clone" to check out code, you'd "bottle pull" it or such
10:39:07 <Peaker> nand`, though a web service could probably render it, too
10:39:18 <Cale> lamefun: Also, consider something like  (map head . group . sort) xs  versus   map head . group . sort $ xs
10:39:22 <nand`> Peaker: I imagined it would be something like that, with the way you're doing structural diffs and whatnot
10:39:22 <Peaker> but it won't be a text file or a set of text files
10:39:47 <Peaker> nand`, we've got a very long way to go before we are free to work on the revision control, remote synchronization (push/pull), etc.
10:39:49 <lamefun> is it just for not typing parens?
10:39:51 <Cale> lamefun: Less of a big deal, but the farther apart that the parens get, the more $ does a better job
10:39:57 <Cale> yes, pretty much
10:40:00 <Cale> Well...
10:40:02 <nand`> lamefun: there's another use case
10:40:05 <nand`> ($ x)
10:40:05 <Cale> there are a few other uses
10:40:23 <Cale> > zipWith ($) [(*2), (*3), (*5)] [10,20,30]
10:40:25 <lambdabot>   [20,60,150]
10:40:28 <Peaker> lamefun: It also makes it slightly easier to refactor sub-expressions out to their own definitions
10:40:34 <Cale> It conveniently represents function application
10:40:37 <Cale> as a function
10:40:40 <nand`> note that ($) = id so that can also be written (`id` x) but ($ x) is clearer
10:40:42 <Peaker> [(*2), (*3), (*5)] <*> [10,20,30]
10:40:45 <Peaker> > [(*2), (*3), (*5)] <*> [10,20,30]
10:40:46 <lambdabot>   [20,40,60,30,60,90,50,100,150]
10:41:06 <nand`> > ZipList [(*2), (*3), (*5)] <*> ZipList [10,20,30]
10:41:08 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
10:41:08 <lambdabot>    arising ...
10:41:10 <nand`> bah
10:41:13 <nand`> no show instance on that? how useless
10:41:13 <zhulikas> artagnon,
10:41:15 <zhulikas> what about this?
10:41:16 <zhulikas> caseList :: Int -> IO [Int]
10:41:16 <zhulikas> caseList x = fmap concat $ replicateM x readCase
10:41:18 <typoclass> lamefun: it'd be possible to remove ($) from haskell. this wouldn't change anything fundamental; things would just get a little less convenient
10:41:22 <c_wraith> I don't really understand why ZipList has no show instance
10:41:28 <nand`> I don't either
10:41:31 <nand`> add one?
10:41:35 <aristid> @free zipWith
10:41:37 <lambdabot> (forall x. h . k x = p (f x) . g) => $map h . zipWith k xs = zipWith p ($map f xs) . $map g
10:41:40 <Peaker> I wish there was a "DebugShow" instance that everything had, always
10:41:47 <artagnon> zhulikas: Just a sec -- let me parse that.
10:41:47 <c_wraith> It's in base. Adding an instance is painful. :)
10:41:50 <Cale> ZipList is a kinda silly instance of Applicative to begin with. Apparently its main role is to prove that there are Applicatives which are not Monads.
10:42:01 <zhulikas> @type replicateM
10:42:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:42:07 <Cale> It won't actually help you make code prettier
10:42:12 <qnikst> is there a way to make a conduitional define in hcs2hs, i.e. if definition exists set it, otherwise set default?
10:42:12 <Cale> afaict
10:42:13 <artagnon> Ah.
10:42:33 <aristid> Cale: zipWith id would make for a nice infix operator in itself i think
10:42:39 <qnikst> I need it because in old version of libraries there is not all constants that are in mine
10:43:11 <zhulikas> caseList x = replicateM x readCase >>= return . concat
10:43:11 <zhulikas> or this
10:43:21 <zhulikas> better than fmap I think
10:43:23 <JorgeArbusto> Who was doing Control.Concurrent before?
10:43:24 <artagnon> zhulikas: Looks good.  Now I can extract the [Int] from IO [Int] in `main`?
10:43:58 <nand`> replicateM x (concat readCase) -- ?
10:44:02 <nand`> wait, no
10:44:16 <zhulikas> heh, would be nice
10:44:31 <nand`> replicateM traverses afterwards, forgot about that
10:44:55 <artagnon> I'm trying to extract the [Int] from IO [Int] using <- in `main`
10:44:56 <danil> Peaker: I want that too, but I'm not sure how it would work.  I guess GHC could derive it in any module that defines a type and doesn't write their own instance; no real need to allow people to make orphan versions.
10:45:12 <jfischoff> Whats the name of string substitute function? Something like gsub :: String -> String -> Sting -> String; gsub find replace x = …
10:45:44 <zhulikas> @hoogle [a] -> IO ()
10:45:44 <lambdabot> Control.Concurrent.Chan writeList2Chan :: Chan a -> [a] -> IO ()
10:45:44 <lambdabot> Test.HUnit.Base listAssert :: ListAssertable t => [t] -> Assertion
10:45:46 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer clear :: [ClearBuffer] -> IO ()
10:45:52 <zhulikas> there was something like a "mass printing"
10:45:53 <typoclass> artagnon: good plan
10:46:10 <JorgeArbusto> > map ($ 6) map (+) [1,2,3]
10:46:11 <lambdabot>   Couldn't match expected type `[a -> b]'
10:46:11 <lambdabot>         against inferred type `(a1 ...
10:46:15 <JorgeArbusto> > map ($ 6) $ map (+) [1,2,3]
10:46:16 <lambdabot>   [7,8,9]
10:47:34 <zhulikas> @type forM
10:47:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
10:47:45 <artagnon> Still some problem -- http://pastie.org/4407084
10:47:50 <zhulikas> forM_ it is I think
10:47:51 <ReinH> good morning or other time zone appropriate greeting
10:47:51 <lambdabot> ReinH: You have 1 new message. '/msg lambdabot @messages' to read it.
10:48:50 <hpaste> zhulikas pasted “does it look better nao?” at http://hpaste.org/72741
10:49:08 <zhulikas> although I excluded your myProgram
10:49:14 <zhulikas> because I didn't have source code for it
10:49:40 <zhulikas> and lazyness didn't allow me to figure the type and define a substitude for it
10:49:54 <zhulikas> artagnon, ^^
10:50:06 <artagnon> zhulikas: Thanks for replicateM -- it simplifies my program greatly.
10:50:18 <zhulikas> also for forM_
10:50:26 <zhulikas> but I was happy when I found those too!
10:50:35 <artagnon> zhulikas: Beautiful!  Thanks :D
10:51:05 <zhulikas> you are welcome :)
10:51:40 <artagnon> Btw, why didn't you like the fmap version as much?
10:51:49 <artagnon> Why do you prefer >>= return . concat?
10:52:00 * hackagebot git-annex 3.20120807 - manage files with git, without checking their contents into git (JoeyHess)
10:52:04 <zhulikas> fmap is supposed to work on lists
10:52:11 <zhulikas> and here we have a single value
10:52:13 <Cale> fmap works on any Functor
10:52:18 <zhulikas> true....
10:52:30 <artagnon> Oh, okay.
10:52:31 <zhulikas> well, map then
10:52:32 <Cale> If you're specialising to lists, you might as well use map
10:52:56 <zhulikas> there are probably no performance issues in having fmap though instead of >>= return . concat
10:53:06 <zhulikas> (silly me)
10:53:07 <Cale> In fact, performace may be better
10:53:10 <zhulikas> really?
10:53:13 <zhulikas> hm
10:53:17 <Cale> only slightly
10:53:18 <Cale> but yes
10:53:21 <joevandyk> cabal question: i'm using yesod. the cabal file for the application seems to list all the 30 or so dependencies for yesod. wouldn't it work to include only yesod-platform (which depends on all the other packages) in the cabal file?
10:53:25 <zhulikas> I just love to make it as strict as possible
10:53:33 <mekeor> you could use "f <$>" instead of ">>= return. f". it ĺooks good, too.
10:53:48 <zhulikas> I never got used to <$> <*> etc
10:53:49 <zhulikas> :/
10:53:50 <JorgeArbusto> So im gonna write a SAT-solver. So what do I do? I use de morgans laws to reduce the expression as much as possible and then enumerate all possibilities and check?
10:53:58 <Cale> there is no semantic difference between the two
10:54:05 <Cale> Strictness-wise, they are identical
10:54:08 <joevandyk> i.e. with rails, all you have to do is include the 'rails' gem in the Gemfile. that will generate a Gemfile.lock file that describes all the packages that rails depends on. so if you want to upgrade the rails version, you just have to bump one line.
10:54:18 <zhulikas> @type fmap
10:54:19 <c_wraith> hmm.  edwardk vanished. And I was going to report a documentation bug.
10:54:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:54:22 <ReinH> if performance of fmap is a concern, you're probably doing something wrong
10:54:42 <Cale> Or you are doing *a lot* of things right :)
10:54:43 <c_wraith> @tell edwardk in lens 1.6, <*~ is documented as subtracting, not multiplying
10:54:43 <lambdabot> Consider it noted.
10:54:49 <zhulikas> performance isn't a concern. Trying to make it too perfect is though
10:54:50 <joevandyk> with yesod, if i want to bump the version, i'd have to go in and change most of the versions in the cabal file, instead of just bumping the yesod-platform version and letting cabal figure out what versions i should be using
10:54:55 <ReinH> Cale: heh
10:55:28 <zhulikas> @src fmap
10:55:28 <lambdabot> Source not found. That's something I cannot allow to happen.
10:55:31 <zhulikas> oh, right.
10:55:53 <zhulikas> but why fmap is slightly better than >>= ?
10:56:03 <c_wraith> zhulikas: because it is more limited
10:56:16 <c_wraith> zhulikas: so you know there are more things the operation can't be doing
10:57:22 <zhulikas> is there an easy way to compare performance of two functions?
10:57:27 <zhulikas> some benchmarking facilities
10:57:32 <c_wraith> the criterion library
10:57:42 <zhulikas> which would automatically assign proper arguments and evaluate it like a million times
10:57:44 <zhulikas> ok
10:58:15 <mekeor> zhulikas: btw, also read those message at the bottom of <http://hpaste.org/72741>. they are generated by hlint.
10:58:19 <JorgeArbusto> So im gonna write a SAT-solver. So what do I do? I use de morgans laws to reduce the expression as much as possible and then enumerate all possibilities and check?
10:58:52 <zhulikas> @type liftM
10:58:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:59:00 <zhulikas> hmm
10:59:11 <c_wraith> liftM is the same as fmap, except for the context
10:59:16 <c_wraith> it indicates the same operation
10:59:40 <Tomsik> JorgeArbusto, I'd start by googling some papers :P
10:59:42 <c_wraith> and it has the same rules
10:59:46 <zhulikas> caseList x = liftM concat $ replicateM x readCase
10:59:48 <zhulikas> like this? ^^
11:00:01 <Tomsik> I think many of SAT solvers use some kind of resolution machine
11:00:05 <zhulikas> so many useful functions!
11:00:25 <zhulikas> and suddenly context isn't a problem anymore!
11:00:32 <c_wraith> zhulikas: yes, though that's also equivalent to    caseList x = concat <$> replicateM x readCase
11:00:39 <zhulikas> :DD
11:00:40 <c_wraith> zhulikas: and I'd probably go with that version
11:00:41 <zhulikas> damn it
11:00:50 <zhulikas> I need to get used to applicatives
11:01:07 <c_wraith> zhulikas: the "problem" is there are a bunch of names for the exact same function, because it's such a handy function. :)
11:01:14 <zhulikas> @type (<$>)
11:01:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:01:25 <zhulikas> that's easier to read than definition for liftM
11:01:38 <zhulikas> a b is better than a1 r
11:01:54 <zhulikas> @type (<*>)
11:01:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:02:08 <zhulikas> I think I am starting to flood
11:02:09 <mekeor> zhulikas: <$> has nothing to do with applicatives. (<$>) = fmap…
11:02:29 <mekeor> > Just (*2) <*> Just 8 -- this is <*>
11:02:31 <lambdabot>   Just 16
11:02:39 <mekeor> > (*2) <$> Just 8 -- this is <$>
11:02:41 <lambdabot>   Just 16
11:03:07 <c_wraith> mekeor: well, historically it does.  It came from the same paper that developed Applicative.  But semantically, it doesn't.
11:03:14 <linduxed> for the line  | isPotEmpty $ head $ drop (startingPot - 1) listOfPots = error "Can't start from an empty pot."   hlint tells me that i should "Use !!" instead of head
11:03:16 <mekeor> > (*2) $ 6 -- this is $ ;) :D
11:03:18 <lambdabot>   12
11:03:21 <linduxed> how do i use !! ?
11:03:37 <c_wraith> > [1..10] !! 5
11:03:38 <lambdabot>   6
11:03:38 <scry1> @hoogle WHNF
11:03:39 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
11:03:41 <mekeor> c_wraith: yea, it's also defined in Control.Applicative (and Data.Functor).
11:03:54 <scry1> @google WHNF
11:03:54 <c_wraith> zero indexing, nice
11:03:56 <lambdabot> http://foldoc.org/WHNF
11:03:56 <lambdabot> Title: Weak Head Normal Form from FOLDOC
11:04:21 <c_wraith> linduxed: !! is zero-based indexing into the list.  it's the equivalent of the head and drop thing you're doing.
11:04:36 <linduxed> c_wraith: ok, thank you
11:06:01 <JorgeArbusto> > (head &&& drop) [1..10]
11:06:03 <lambdabot>   Couldn't match expected type `[c]'
11:06:03 <lambdabot>         against inferred type `GHC.Types...
11:06:07 <JorgeArbusto> > (head *** drop) [1..10]
11:06:09 <lambdabot>   Couldn't match expected type `([c], GHC.Types.Int)'
11:06:09 <lambdabot>         against inferre...
11:06:16 <JorgeArbusto> :t head
11:06:18 <lambdabot> forall a. [a] -> a
11:06:21 <JorgeArbusto> :t (***)
11:06:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:06:25 <JorgeArbusto> :t (&&&)
11:06:27 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:06:46 <ReinH> JorgeArbusto: or look at things like gecode (http://www.gecode.org/)
11:07:45 <ReinH> I often find actual code more enlightening than an equivalent weight in doctoral papers ;)
11:08:39 <ReinH> Ah Arrows, my next major frontier of knowledge after lenses
11:08:41 <mekeor> > let l = [1..10] in (head *** tail) (l,l)
11:08:43 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10])
11:08:57 <ReinH> it only took me a few years to grok monads, so hopefully I'll get Arrows some time before 2015
11:10:14 <sp3ctum> i often feel like i understand monads, but then something more difficult of them comes up
11:10:27 <mekeor> > (head *** tail) $ (id &&& id) [1..10]
11:10:29 <lambdabot>   (1,[2,3,4,5,6,7,8,9,10])
11:10:39 <danil> ReinH: arrows other than (->) come up very rarely
11:10:51 <mekeor> ReinH: arrows are damn easy.
11:11:00 <sp3ctum> -> is clearly an arrow
11:11:01 <mekeor> ReinH: just think of arrows as (->).
11:11:04 <c_wraith> ReinH: Arrow is not *nearly* as fundamental.  The arrow combinators are really handy to use with (->), but the abstraction in general isn't really anything that useful
11:11:38 <mekeor> danil: the other commond arrow is Kleisli
11:12:22 <c_wraith> Kleisli is handy theoretically, but actually using it is a pain, due to newtype wrapping and unwrapping.
11:12:45 <c_wraith> Much easier to just use <=< instead of doing all the wrapping to use .
11:13:16 <mekeor> speaking of arrows… why does "mapA ((?) Just) # [1..5]" work but "mapA (Just?) # [1..5]" give me the error "The operator `(?)' takes two arguments…"?  ((?) = Kleisli)
11:13:22 <johnw> I'm trying to use [FilePath] with CmdArgs, and it's having trouble with the type, saying "unexpected flag".  I've found mention on the Web that the author "fixed" this, but I'm not sure if it requires me to do something special to get this type to play nicely with CmdArgs?
11:14:10 <mekeor> @type let (?) = id in 5?
11:14:12 <lambdabot> parse error (possibly incorrect indentation)
11:14:22 <JorgeArbusto> is there an axutal complete mirc-app in haskell that people are using?
11:14:23 <mekeor> @type let (?) = id in (5?)
11:14:24 <lambdabot> forall t. (Num t) => t
11:14:26 <JorgeArbusto> irc-app
11:14:41 <hpaste> nand` pasted “Cons lens” at http://hpaste.org/72746
11:14:50 <JorgeArbusto> Would you people want a webapp or a GUi or  just a command line?
11:15:09 <danil> mekeor: do you have PostfixOperators on?  You can define operators whose types don't have two arrows without it, but you can't use them in sections
11:15:27 <nand`> @ask edwardk Can you think of a way to improve http://hpaste.org/72746 ? In particular, I feel like it should be :: Lens a b c d -> Lens a b [c] [d] -> Lens a b [c] [d] -- but I can't think of a way to do both updates ‘at the same time’ as to preserve the type
11:15:27 <lambdabot> Consider it noted.
11:15:38 <mekeor> johnw: when did the author say he fixed it? recently? 10 years ago?
11:16:08 <mekeor> danil: cool. a lang-ext?
11:16:20 <johnw> he said he fixed it in 0.6.9
11:16:30 <danil> mekeor: yep
11:16:35 <johnw> i'm using 0.9.6
11:16:50 <johnw> he did it around 4/3/11
11:17:41 <mekeor> hm
11:17:43 <johnw> well, it's not that I can't work around it using String, it just feels like I shouldn't have to
11:18:12 <mekeor> johnw: FilePath = String, you know that, right?
11:18:26 <johnw> i'm using Filesystem.Path.FilePath, not System.Path.FilePath
11:18:28 <johnw> FWIW
11:18:32 <mekeor> oh, okay :D
11:18:42 <johnw> yeah, that distinction has bitten me many times over already
11:18:48 <mekeor> :D
11:19:43 <mekeor> johnw: dunno… hm… what does "unexpected flag" mean?
11:19:56 <johnw> you've got me there!
11:20:06 <mekeor> :)
11:20:29 <mekeor> danil: but the operator still has to be of arity two? (i mean, has to have two arrows?)
11:20:37 <johnw> but moments ago I just finished completing the rewrite of this Ruby script into Haskell
11:20:51 <johnw> it's only about 5% faster, but that's no surprise (it mostly shells out to the system)
11:21:14 <typoclass> johnw: folks can give you more concrete advice if you paste the code that is giving you trouble, and the error message you're seeing (use hpaste)
11:21:15 <johnw> but what's interesting is that concurrency was much easier, and most of my debugging time was spent at compile-time rather than at run-time
11:21:18 <typoclass> @where hpaste
11:21:19 <lambdabot> http://hpaste.org/
11:21:27 <johnw> thanks, I have gist all plugged into my Emacs
11:22:00 <johnw> so, the code is here: https://github.com/jwiegley/git-all/blob/master/Main.sh
11:22:14 <johnw> on line 46 I have to use [String]
11:22:25 <johnw> and on line 90: L.map (fromText . pack) (dirs opts)
11:22:36 <johnw> if line46 were [FilePath], line 90 could just be "(dirs opts)"
11:23:19 <Cale> hehe, just because you're using Shelly doesn't mean that .sh is the right file extension to use ;)
11:23:28 <johnw> sorry, that was flyspell
11:23:36 <johnw> the extension is .hs
11:23:37 <johnw> :)
11:23:44 <Cale> (yeah, I noticed the dead link)
11:23:59 <johnw> (added .hs to my personal dictionary)
11:24:26 <nand`> autocorrect strikes again?
11:27:15 <johnw> my brain reels every time I read lines 239-242 in that script.  There's just too much going on in that short span of text :)
11:27:52 <johnw> and yet, in the end it's really not complicated...
11:28:41 <typoclass> johnw: you could do "when" there instead of if then else, it'll get slightly shorter
11:28:43 <typoclass> @hoogle when
11:28:43 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
11:28:43 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
11:28:44 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
11:29:01 <typoclass> (Control.Monad is already imported)
11:30:30 <hpaste> teepark pasted “julian date” at http://hpaste.org/72747
11:30:42 <JorgeArbusto> can u see me?
11:31:11 <Cale> JorgeArbusto: nope ;)
11:31:27 <shirt> anyone using virthualenv/hsenv? it seems to be broken with latest GHC HEAD / cabal HEAD
11:31:34 <teepark> why is the conversion of a Data.Time.Calendar.Day to julian date giving the wrong day?
11:31:40 <teepark> (from my pated snippet)
11:31:43 <teepark> *pasted
11:31:46 <Cale> teepark: Is that incorrect?
11:32:15 <teepark> it's 8/7 today, that shows 7/25
11:32:18 <Cale> teepark: We use the Gregorian calendar normally, if you weren't aware.
11:32:18 <typoclass> teepark: the julian calendar is practically never used. what are you trying to do there?
11:32:27 <teepark> hah gotcha
11:32:45 <teepark> trying to get *gregorian* month/day out of it
11:33:07 <Cale> Well, try the corresponding one from that module :)
11:34:03 <Cale> Well, specifically, toGregorian from Data.Time.Calendar
11:34:11 <johnw> typoclass: nice, thanks!
11:34:21 <zhulikas> No instance for (Benchmarkable (a0 -> a0))
11:34:21 <zhulikas>   arising from a use of `bench'
11:34:26 <typoclass> teepark: you may want to pay attention to your timezone as well. currently you're using UTC time (time in england). try getZonedTime
11:34:31 <zhulikas> I just tried 'bench "test" id'
11:34:38 <edwardk> danharaj, nand`: i just got actions to work
11:34:39 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:34:40 <JorgeArbusto> Would you people want a webapp or a GUi or just a command line for a irc-client?
11:34:59 <teepark> Cale: thanks, looks perfect
11:35:01 <nand`> edwardk: do share
11:35:11 <edwardk> one sec let me clean it up and paste
11:35:15 <JorgeArbusto> is there an actual written irc-app in haskell that people are using?
11:35:25 <teepark> typoclass: timezone actually isn't important in this instance, thanks though
11:35:26 <Cale> JorgeArbusto: GUI probably. An optional commandline would be nice.
11:35:30 <edwardk> re the lens to get a list out you probably can't do that. ;)
11:35:54 <c_wraith> edwardk: while I'm going through the lens docs, the docs for (<~) have a haddock formatting error, where / is being interpreted as italicise"
11:36:12 <edwardk> thanks. i'll fix both
11:36:20 <Cale> JorgeArbusto: Not that I'm aware of, a very long time ago, there was an IRC client called hircules in Haskell.
11:36:52 <Cale> oh, it looks like that's been more or less kept up to date
11:36:59 <Cale> http://hackage.haskell.org/package/hircules
11:37:28 <Cale> The last I heard of it would have been back in 2003, but it's quietly been updating I guess :)
11:37:55 <JorgeArbusto> Cale: what gui is available for arch? webapp everyone could use the same...
11:38:11 <joevandyk> so i'm looking at making a blackjack game. this is what i have so far. https://gist.github.com/f3e7711ab81d666c2672 not much yet, i know. :) I'm working on the Deck datatype. My first thought was to make it a list of Cards, but I'm not sure if that's the best approach. Thoughts?
11:38:22 <mekeor> cooool: http://bm380.user.srcf.net/cgi-bin/stepeval.cgi -- "stepeval operates on haskell-src-exts ASTs, performing a single evaluation step […] at a time"
11:38:32 <joevandyk> if it was a simple list/array, nothing would prevent me from having two Ace of Clubs, for example, right?
11:38:39 <Cale> JorgeArbusto: I guess, but if something is going to replace XChat for me, it's pretty unlikely to be a web app somehow.
11:38:40 <edwardk> both haddock patches are in and pushed to github
11:38:55 <edwardk> i'm slowly grinding through linking all the examples as well
11:38:59 <c_wraith> edwardk: nice turnaround time.
11:39:00 <edwardk> now, back to Action
11:39:35 <edwardk> @hpaste
11:39:36 <lambdabot> Haskell pastebin: http://hpaste.org/
11:39:42 <Cale> joevandyk: Sure. You could have it be a (Set Card), but then that conveys no particular order
11:39:56 <edwardk> http://hpaste.org/72748
11:40:09 <joevandyk> Cale: yeah, I want the Deck to be shuffled, I guess
11:40:20 <edwardk> You can chain them with getters
11:40:20 * nand` .oO ( Was writing @hpaste really better than writing hpaste.org ? )
11:40:27 <edwardk> its a habit
11:40:29 <joevandyk> Cale: in a particular order
11:40:57 <edwardk> also means i don't have to go open a browser ;)
11:40:58 <shapr> Does ghci work on armv7?
11:41:04 <shapr> or am I imagining that?
11:41:08 <Cale> shapr: I think no
11:41:11 <shapr> :-(
11:41:15 <Cale> shapr: But GHC does?
11:41:16 <c_wraith> shapr: for sufficiently new ghc, maybe
11:41:27 <shapr> c_wraith: got details?
11:41:28 <Philippa> GHC's worked on ARM for ages
11:41:32 <c_wraith> I know that work has gone into making ghci run on arm recently.
11:41:39 <Philippa> haven't specifically tested v7, but it ran on my old Zaurus
11:41:56 <luite> shapr: there's ghci support since 7.4.2
11:42:21 <shapr> luite: for arm specifically?
11:42:26 <luite> for arm, yeah
11:42:29 <edwardk> you only have a couple of combinators for interacting with Actions
11:42:32 <edwardk> act and (^!)
11:42:49 <Philippa> awesome, so I'm just waiting for that to hit the Platform and then I should go root an Android device, pull the chroot trick and try it out?
11:42:52 <luite> shapr: but i'm not familiar with all the specific instruction set differences that might or might not be supported :)
11:42:59 <shapr> luite: thanks :-)
11:43:03 <edwardk> ghci> 2 ^! act (\a -> [(a,a),(a,a)]) . _2    => [2,2]
11:43:06 <mikeg> JorgeArbusto: IMO the perfect IRC client be a bouncer that has a good web app. Let me connect from other clients if I want, but the web app would e.g. have infinite scrollback
11:43:51 <luite> shapr: i've never tried though, don't have an arm. my brother ordered a raspberry pi, so maybe i can play with it :)
11:43:52 <mikeg> No more of this ZNC buffer playback junk, why can't it just load older lines from the log if I want to see them?
11:44:01 <keep_learning> > let f (Just x) = 1 in f (Just undefined)
11:44:02 <lambdabot>   1
11:44:08 <shapr> luite: I'll give you a shell account on mine :-P
11:44:19 <keep_learning> > let f ~(Just x) = 1 in f (Just undefined)
11:44:20 <lambdabot>   1
11:44:39 <shapr> Although I've noticed significant lag on my RPi with two users ssh'd in, much less compiling with GHC.
11:44:46 <luite> shapr: raspberry pi probably doesn't have enough ram to run ghc comfortably
11:45:05 <weexplat> joeyh_: is git-annex's --in= option not supposed to work on bup remotes?
11:45:18 <Philippa> luite: it's enough for small things
11:45:23 <Philippa> just leave off -O
11:45:40 <shapr> luite: I tried to build haskell-platform with 220mb of ram but gave up after four or five hours of insane amounts of swapping.
11:45:40 <keep_learning> > let f ~(Just x) = x in f (Just undefined)
11:45:42 <lambdabot>   *Exception: Prelude.undefined
11:45:43 <luite> Philippa: yeah but even small things might want to install dependencies like text or vector
11:45:45 <Philippa> (am I the only one who remembers having a new, shiny and highly impressive machine with that much RAM?)
11:46:06 <shapr> Philippa: I could talk about my timex sinclair :-P
11:46:20 <zhulikas> any thoughts on running haskell platform on raspberry pi?
11:46:21 <hpc> > let f ~(Just x) = 1 in f undefined -- keep_learning
11:46:22 <lambdabot>   1
11:46:23 <johnw> I think my first hard drive had that much storage :)
11:46:25 <hpc> > let f (Just x) = 1 in f undefined -- keep_learning
11:46:26 <lambdabot>   *Exception: Prelude.undefined
11:46:31 <shapr> johnw: howdy!
11:46:32 <Philippa> zhulikas: it sounds like having a binary package would be a good thing
11:46:32 <joevandyk> why doesn't this work? data Deck = [Card] ?
11:46:34 * shapr hugs johnw for being awesome
11:46:37 <johnw> shapr: hey, shapr!
11:46:48 <Philippa> given that... well, it should work a lot better than it did on my Zaurus
11:46:55 <shapr> johnw: eshell is awesome!
11:46:58 <Philippa> it might be a good idea to have something faster than the SD card for swap though
11:47:07 <johnw> shapr: heh, I'm glad you like it!  are you just starting to use it?
11:47:13 <keep_learning> hpc why undefined matched to Just x ?
11:47:14 <luite> it would be nice if they sold 2GB versions for development
11:47:24 <zhulikas> Philippa, well, I have a few spare HDDs
11:47:26 <Philippa> for 1GB, get a pandaboard?
11:47:28 <shapr> johnw:  Nah, I've been using eshell for years, but it still makes me especially happy!
11:47:34 <johnw> :)
11:47:39 <shapr> johnw: Did you do some work on org-mode?
11:47:47 <Philippa> it's not the same hardware for everything else, of course
11:47:59 <johnw> shapr: quite a bit
11:48:02 <shapr> johnw: Oh! I enjoyed your video with Sacha Chua!
11:48:10 <hpc> keep_learning: look up irrefutable patterns
11:48:11 <johnw> shapr: maybe we're in the wrong channel for this kind of love
11:48:16 <shapr> hehe, maybe so
11:48:25 <danil> joevandyk: datatypes need to have constructors; you can use a type synonym instead if you don't want any (type Deck = [Card])
11:48:25 * shapr goes back to talking about Haskell
11:48:38 <johnw> oh, feel free to praise me in #emacs, I won't mind ;)
11:48:55 * shapr grins
11:49:00 <luite> is johnw a famous emacser?
11:49:08 <Clint> yep
11:49:22 <keep_learning> joevandyk, You need data constructor something like this data Deck = Deck [ Card ]
11:49:31 <zhulikas> hmm what if I build on my PC and run it on raspberry pi
11:49:42 <zhulikas> ahh, not really possible probably
11:49:50 <johnw> shapr: I'm into Haskell for the third time
11:49:53 <zhulikas> because of different architectures
11:50:02 <johnw> shapr: reading LYAH on my Kindle again
11:50:04 <keep_learning> or if you have defines the Card then you can use as suggested by danil  type Dek = [ Card ]
11:50:07 <shapr> johnw: How's it going?
11:50:09 <johnw> shapr: and this time, things are really starting to gel
11:50:13 <shapr> yay!
11:50:18 <shapr> brain stretching and all that?
11:50:23 <johnw> I finally get that Monads are just a concept, not a "thing"
11:50:34 <johnw> that makes all the difference
11:50:37 <johnw> (for me)
11:50:41 <shapr> right! they're just an abstraction, in the way that objects are an abstraction
11:50:49 <johnw> in the way that mapping is an abstraction
11:50:55 <johnw> in the way that identity is an abstraction
11:50:55 <shapr> yup
11:51:30 <cokanut> johnw, shapr : i'm just lurking and reading your conversation. thanks for sharing the monad is a 'concept' not a 'thing'. I think it'll make a lot of difference in my learning as well.
11:51:52 <keep_learning> hpc, thank you
11:52:14 <edwardk> nand`: ghci> (1,(2, 3))^!_2._2.act (\x -> [x,x])      ==> [3,3]
11:52:19 <shapr> johnw: First time I got monads I realized they chain state around the program, where objects are isolated chunks of state, each with its own interface
11:52:25 <edwardk> fixed the type of ^! to allow it
11:52:42 <johnw> shapr: they *can* chain state, you mean, but that's by no means a required part of the picture
11:52:49 <Philippa> no, it is
11:52:56 <Philippa> just not the way you think shapr means
11:53:00 <johnw> ah
11:53:00 <shapr> johnw: that night I dreamed the whole world was written in Haskell, and I was using unsafePerformIO to see five seconds into the future :-)
11:53:03 <shapr> Philippa: explain?
11:53:04 <johnw> yes, the type is chained
11:53:15 <Philippa> abstract machine states very much *are* chained
11:53:38 <edwardk> need to work on errors though
11:53:40 <Philippa> (monads corresponding to embedded languages with abstract machines that run them, possibly fused away so that their states are their only residue)
11:53:48 <edwardk> when you go to compose an action with a fold you get     No instance for (Furled r0 (Effect [] [Char]))
11:53:56 <edwardk> which is at least not a unification error
11:54:20 <edwardk> Furled probably needs to become something like CanFoldWith
11:54:24 * shapr composes an ode to actions
11:54:55 <n-dolio> Like the free covector over a basis machine.
11:55:00 <johnw> when I think of chaining state, I'm back in the OO world where the "state" is an object being handed between statement.  But although Monads can model that concept, they don't have to.  The Maybe monad, for example, chains the idea of continuing validity (non-Nothing-ness), and the chain ends when Nothing appears
11:55:25 <Philippa> johnw: how's it evaluated?
11:55:34 <johnw> "evaluated"?
11:55:40 <linduxed> why is hlint saying that this line "returnPotWithOneMoreMarble pot = pot { marbleCount = (marbleCount pot + 1) }" has got a "Redundant bracket" at the start of the second "pot" ?
11:55:40 <n-dolio> Or the completion of a metric space machine.
11:56:14 <johnw> binding any function over Nothing returns Nothing
11:56:23 <nand`> CanFoldWith is too long
11:56:26 <nand`> sounds Javish
11:56:29 <Philippa> johnw: like I said, monads correspond to embedded languages. How is the language of the Maybe monad evaluated? Well, you build that chain of validity. Those validities are intermediate states in a machine for evaluating the Maybe language
11:56:30 <typoclass> linduxed: you can leave out the parens if you want. it's fine to say "marbleCount = marbleCount pot + 1"
11:56:53 <johnw> Philippa: ah, I see what you mean by state now
11:57:02 <Philippa> sometimes, the states don't flow linearly because evaluation isn't linear :-)
11:57:07 <johnw> Philippa: yes, it chains "machine states"
11:57:08 <danil> n-dolio: "metric space machine" sounds like a properly-functioning Mars probe
11:57:08 <typoclass> Philippa: overloadabe semicolon! 8-)
11:57:31 <n-dolio> No, (completion of a metric space) machine.
11:57:48 <edwardk> nand`: well its not user visible mostly
11:57:53 <edwardk> nand`: and its for the error message
11:57:56 <n-dolio> Not completion of a (metric space machine).
11:58:01 <linduxed> typoclass: so wait, what would the altered line look like?
11:58:03 <edwardk> no instance of CanFoldWith … (Effect …)
11:58:14 <danil> n-dolio: I know, I know, just joking about a space machine that failed for lack of metric ;)
11:58:56 <typoclass> linduxed: exactly like the one you pasted, but with no "(" and no ")"
11:59:39 <linduxed> oooh, so it's the () not the {}
11:59:46 <Philippa> johnw: The fun bit? That *almost* gives you a relationship between objects and monads, if you'll grant me the notion of a monad-runtime-state
12:00:17 <johnw> Philippa: I can see that, certainly with the State monad
12:00:46 <johnw> it's a very powerful abstraction
12:00:55 <johnw> sometimes the syntax of using them gets a little unfortunate
12:01:02 <Philippa> an object 'at rest' is much like a monad-runtime-state (sans its return continuation), it's waiting for a message that supplies it 'code' to run
12:01:13 <Philippa> except most of the time we pointedly *don't use monads that way*
12:02:34 <Peaker> danil, maybe even just disallow custom instances, so you can know exactly what the output you see means -- just make the default instance really awesome :)
12:02:55 <otters> my runhaskell doesn't do anything and returns exit code 127
12:02:56 <otters> :|
12:02:59 <Peaker> danil, perhaps allow some customization of the desired output at the call-site
12:03:09 <shapr> johnw: going to write something nifty in Haskll?
12:03:11 <Peaker> otters, paste the script?
12:03:19 <otters> Peaker: "main = print 1"
12:03:27 <johnw> shapr: I want to use it as my general language
12:03:38 <donri> otters: hm wasn't that some osx bug
12:03:44 <johnw> shapr: I switched from Python to Ruby, but I'd prefer to just use Haskell everywhere
12:03:51 <otters> donri: was it? I didn't hear about it
12:04:02 <johnw> i like that type errors make me think about my code
12:04:10 <johnw> it's like having a code reviewer watching over your shoulder
12:04:14 <otters> cursory google shows me something similar but it's from 2007
12:04:28 <danil> Peaker: hmm, maybe.  I think the most useful kind of customization would be to suppress (or compress) some of the information
12:04:54 <donri> otters: i think 127 usually means that some executable wasn't found in $PATH
12:04:56 <danil> Peaker: of course, you could just have the compiler generate the class uniformly and have your editor know how to fold the output
12:04:56 <typoclass> otters: i think runhaskell is a shell script
12:04:59 <otters> oh
12:05:13 <geekosaur> exit 127 typically indicates an executable wasn't found for some reason.  runhaskell is a shell script that runs the real thing with some runtme paths
12:05:45 <geekosaur> so if you have runhaskell in the right place, "cat" it and make sure the real program is where it is expected to be
12:06:20 <otters> oh, yeah, found it
12:06:27 <otters> it wanted /usr/local/bin/ghc but I have /usr/bin/ghc
12:06:37 <otters> I wonder why that is :|
12:07:23 <JorgeArbusto> so the avg hskr likes abbrevs, but whats so bad about auto-complete?
12:08:12 <donri> JorgeArbusto: readability, but it's subjective and depends on the case
12:08:25 <geekosaur> otters, this is os x?  maybe you have a leftover from a homebrew install, but you now use the official HP package?
12:08:28 <JorgeArbusto> uh you think abbrevs are more readable?
12:08:37 <donri> JorgeArbusto: can be, but depends
12:09:04 <donri> JorgeArbusto: especially when there are established, recognizable conventions, you can see more at a glance
12:09:14 <otters> geekosaur: I had an installation from source
12:09:19 <otters> but updating with that is not as easy
12:09:29 <otters> homebrew can't install it at all, there's a segfault or something, I don't remember
12:10:04 <geekosaur> oh yeh, source install also goes to /usr/local.  but the HP is in /usr/bin (well /Library/Frameworks/GHC.framework with symlinks)
12:10:19 <geekosaur> so sounds like you incompletely uninstalled the source build
12:11:38 <Philippa> ...huh. I really ought to write up that monad/object connection, not least to explain why objects-in-the-small can seem so misguided
12:11:50 <Philippa> (and how objects in a monad other than IO can be kinda awesome)
12:11:58 <Peaker> danil, yeah, and maybe it would be interesting to even show even ptr values (breaking referential transparency) to make it easier to debug sharing issues
12:13:06 <johnw> Philippa: and include how monads are not objects, but they can model the behavior of objects.  That analogy of monads being like tacos was very misleading for me in that respect
12:13:11 <danil> Peaker: at some point this becomes vacuum
12:13:42 <Peaker> danil, or subsumes it?
12:14:35 <matthiasgorgens> johnw: that's the problem with analogies.
12:15:08 <donri> a monad is like an analogy: confusing, unless you already understood it
12:15:16 <johnw> lol
12:15:22 <johnw> the hyperbolic monad
12:15:35 <matthiasgorgens> johnw: and monads are objects.
12:15:56 <matthiasgorgens> to be more precise: monads are a monoid objects in the category of Haskell endofunctors.
12:16:11 <johnw> you and I are using different meaning for the word 'object', I think
12:16:13 <matthiasgorgens> they are just not the objects of oop, but the objects of category theory.
12:16:23 <johnw> yes, and I don't know category theory
12:16:26 <matthiasgorgens> which is of course highly misleading to most people. :o)
12:16:31 <typoclass> matthiasgorgens: that clarifies it nicely ...
12:16:54 <lamefun> I have game entities  step :: TimeInterval -> World -> Entity -> Entity  , but how do I give them identities? Just assign an integer to each entity?
12:17:21 <matthiasgorgens> I guess the pragmatic solution is to just keep using them following formulaic rules, until the rules make intuitive sense.
12:17:24 <johnw> lamefun: do you need two entities of equal value to not compare ==?
12:17:41 <adnam> donri: that was a simile
12:17:44 <adnam> sorry, couldn't resist
12:18:10 <lamefun> I don't know what I need.
12:18:30 <matthiasgorgens> lamefun: what do you want to accomplish?
12:19:58 <lamefun_> I want to do what I'd do in normal languages:  entity1 == entity2, but as entities are immutable and I have to regenerate world each step, I can't use that.
12:20:38 <Philippa> johnw: monads aren't objects, they're the worlds 'objects' live in. Very important intuition, that
12:20:53 <johnw> ah, yes, that is very nice
12:20:57 <shirt> where did Prelude.catch go?
12:20:59 <johnw> *very* nice
12:21:02 <johnw> include that in your article
12:21:10 <Philippa> lamefun_: assign an integer to each then, yeah
12:21:38 <tdammers> lamefun_: you regenerate the world, syntactically speaking, but because of lazy evaluation, that's not what really happens behind the scenes
12:22:13 <tdammers> and if, for example, you update an object using, say, record syntax, the parts of it that don't change are reused
12:22:42 <johnw> what's that data sharing called again?
12:22:47 <johnw> i just learned the term for it, but forgot...
12:23:42 <tdammers> and then if you like, you can wrap this mechanism in a monad (or use the existing state monad implementation)
12:23:48 <donri> shirt: still there?
12:24:14 <johnw> Philippa: but in the end, a "Monad" is just any type that implements return and >>= and abides by the Monad laws.  What you model with that interface determines what analogy to use to describe it, right?
12:24:51 <johnw> I can make a monad that isn't a "world" for value to live in
12:25:08 <johnw> I could have a Null monad, that only ever yields the value Null and calls no functions bound over it
12:25:43 <tdammers> johnw: that would still be a 'world' for 'objects' to live in, about as much as /dev/null is a 'file'
12:26:00 <johnw> a null world, when object live by not existing? :)
12:26:04 <johnw> s/when/where
12:26:13 <tdammers> :set philosophy
12:26:15 <johnw> see, there the analogy breaks down
12:26:28 <tdammers> just like the file analogy breaks down on /dev/null
12:26:50 <tdammers> you can use file syntax on it, but the general assumption that what you write to it goes 'somewhere' doesn't hold
12:26:58 <johnw> yep.  But if you describe the Monad as something "except for this case", it doesn't present the abstraction at the right level (for me)
12:27:18 <lamefun_> Also, for example, I have a homing missile. How do I ensure that missile knows that the target it chases has already been destroyed? I can't just save ID in it, since it might be reused by another object later.
12:27:24 <tdammers> well, the file abstraction still works for /dev/null, and the monad abstraction still works for your Null monad
12:27:28 <johnw> Monads are an interface, all bets are off until you see what the interface does for a given Type
12:27:40 <shapr> @remember johnw Monads are an interface, all bets are off until you see what the interface does for a given Type
12:27:41 <lambdabot> I will never forget.
12:28:00 <tdammers> lamefun_: simple - don't reuse your IDs
12:28:07 <danil> A monad is an analogy between Haskell types and Haskell types, along with an analogy called "return" between (the analogy between a thing and itself) and (the analogy that is the monad), and an analogy called "join" between (the analogy between the monad-analog of the monad-analog of a thing and the monad-analog of that thing)) and (the analogy that is the monad).
12:28:58 <tdammers> well isn't that a useful explanation :P
12:29:03 <danil> Someone once told me that natural transformations are like analogies between analogies; I don't think it helped.
12:29:15 <BMeph> johnw: it's still a world, it's just going into a black hole. It goes in, but you can't get it back out again.  :-)
12:29:27 <nand`> a monad analogy as analogies?
12:29:53 <Ralith> johnw: except, hopefully, for the monad laws.
12:30:07 <johnw> BMeph: I'm not arguing that it's not a world.  I'm just saying that the term "world" guides the reader in a certain direction, which may not be abstract enough for them to really appreciate the level at which the concept applies
12:30:22 <johnw> you really have to know you reader in this case
12:30:25 <johnw> s/you/your
12:30:33 <nand`> I have zero clue what ‘world’ and ‘object’ is supposed to mean
12:30:37 <nand`> these analogies are lost entirely on me
12:30:46 <lamefun_> tdammers: O_o
12:30:48 <lamefun_> why?
12:30:56 <johnw> nand`: yeah, that's my point exactly :)
12:30:58 <lamefun_> what if I run out of them?
12:31:08 <johnw> I get it, only because I get it, but if I didn't get it, I wouldn't
12:31:13 <nand`> running out of integers?
12:31:24 <Philippa> johnw: I'm happy talking about a "world of null" personally. Much like the type in question
12:31:24 <johnw> lamefun_: use Integer :)
12:31:27 <tdammers> lamefun_: if you use Ints for your IDs, you'll run out of RAM long before you reach INT_MAX
12:31:39 <nand`> tdammers: he's not reusing identifiers
12:31:59 <nand`> lamefun_: if using Int on a 64-bit system you shouldn't run out of identifiers before the heat death of the universe on current processors
12:32:05 <tdammers> 21:26 < lamefun_> Also, for example, I have a homing missile. How do I ensure that missile knows that the target it chases has already been destroyed? I can't  just save ID in it, since it might be reused by another object later.
12:32:35 <Philippa> johnw: I believe the same thing crops up in (models of) modal logic, in fact
12:33:25 <joevandyk> someone mind helping me with the newDeck method? https://gist.github.com/f3e7711ab81d666c2672 I'd like to create an array of all the cards, but not sure how to do it without a lot of typing. Can I zip together all the combinations of the Ranks and Suits?
12:34:06 <joevandyk> and am i doing this somewhat reasonably?
12:34:41 <johnw> Philippa: and what if the Monad models a function, so that binding your function over it results in passing a function (rather than a value) to your bound function.
12:34:42 <nand`> [ Card r s | r <- [Two..Ace]; s <- [Hearts .. Diamonds] ] -- ?
12:34:43 <hpc> joevandyk: first, newDeck isn't a method
12:34:52 <johnw> this is where I stop being able to think in simple terms anymore
12:34:57 <hpc> second... what nand` said
12:35:05 <danil> johnw: (more seriously,) monads were introduced to CS as ways of interpreting imperative computations.  The "world of nothing" might be a strange way to phrase things;"the stupid interpreter that interprets every instruction as 'do nothing'" is perhaps more likely to make sense.
12:35:07 <joevandyk> hpc: it's not yet
12:35:10 <johnw> well, aside from the fact that functions are values
12:35:25 <johnw> danil: I like that
12:35:26 <joevandyk> nand`: ah, right
12:35:33 <Philippa> danil: worlds, languages that describe how they behave, what's the difference? :p
12:36:12 <johnw> A monad (can be) an interpreter for what it means to bind a given function over than monad
12:36:14 <Philippa> johnw: tbh, I'm sufficiently tired I probably can't find a good answer for you tonight. I might have a go another time, especially if you've got an example monad to poke at (but I suspect it's going to be a relative of Reader?)
12:36:20 <Cale> Philippa: Reasonable philosophy :)
12:36:47 <johnw> which finally explains to me what the Free Monad is about!
12:36:47 <johnw> yay
12:37:32 <johnw> "Monad as world", "Monad as interpreter", "Monad as object of category theory", "Monad as interface", "Monad as concept", "Monad as state machine"
12:37:35 <johnw> they all are valid
12:37:36 <joevandyk> nand`: is there a way to do it without specifying Two..Ace and Hearts..Diamonds?
12:38:03 <nand`> joevandyk: you could add ‘Bounded’ to your deriving list and do [minBound .. maxBound] I guess
12:38:04 <Cale> johnw: "Monad as state machine" seems questionable though
12:38:08 <nand`> but that's not much of an improvement
12:38:11 <eikke> anyone ever worked on something like 'scratchpads' in haskell?
12:38:21 <johnw> "Monad as model of machine state"?
12:38:27 <Cale> johnw: Unless you have a sufficiently generalised idea of what a state machine is.
12:38:27 <eikke> i.e. allocation regions not managed by the GC
12:38:30 <johnw> haha
12:38:41 <johnw> let's just keep generalizing until we can just write "mu"
12:38:45 <johnw> then we will have arrived
12:38:45 <Cale> (that doesn't line up with most people's expectations)
12:38:49 <zhulikas> I was wondering if Control.Concurrent.Chan works like a buffer
12:38:55 * roconnor could see indexed Monads as state machines
12:39:09 <roconnor> are indexed Monads "the same as" Synek-Peterson trees?
12:39:19 <hpc> zhulikas: kinda - you could probably use it as one
12:39:21 <Philippa> johnw: so "world" is an informal analogy. The interpreter and state machine bits aren't quite direct analogies, but there's an important connection when you're talking about monads-in-FP
12:39:24 <Cale> Some monads can be thought of as state machines though.
12:39:24 <zhulikas> so if I have multiple threads listening for data... do all threads get the same data?
12:39:33 <Philippa> that connection works because the base category is already a language
12:39:43 <hpc> if you are using it single-threaded and try to take from an empty chan though, you will lock up
12:39:43 <zhulikas> or only the 'fastest' thread gets one specific bit of data
12:40:01 <hpc> zhulikas: threads get data in the order requested
12:40:21 <hpc> so if you have 3 threads, with one doing nothing but feeding data
12:40:31 <hpc> if threads 1, 2 request stuff in the order
12:40:35 <hpc> 1, 2, 1
12:40:42 <hpc> thread 2 will get stuff
12:40:55 <hpc> but not the same as thread 1
12:41:01 <zhulikas> oh, perfect
12:41:12 <JorgeArbusto> Do I have to do ./dist/build/App/App to run my prog or can I somehow run the program with just ./App ? im on ubuntu so i can add to path somehow? does it also install in some ProgramFolder ?
12:41:26 <hpc> zhulikas: MVars work roughly the same way
12:41:37 <projirc> #HASKELL
12:41:46 <hpc> if multiple threads block on an empty MVar, it passes values to them in order of request
12:41:53 <geekosaur> JorgeArbusto, sounds like you did the build step but not the install
12:42:00 <hpc> Control.Concurrent is pretty solid
12:42:02 <joevandyk> nand`: i get 'Not in scope `Two..`. using min and maxBound worked though
12:42:03 <projirc> HELLO
12:42:18 <JorgeArbusto> hmm it cuts it off after space
12:42:24 <Taneb> YOU ARE VERY LOUD. CAPS LOCK IS NOT NECESSARY.
12:42:38 <zhulikas> I actually read it louder in my head
12:42:41 <zhulikas> stop messing with my brains
12:42:42 <nand`> I do too
12:43:03 <JorgeArbusto> Sorry I will use my own channel. My parser caps locks and cuts off the sentences
12:43:10 <projirc> /QUIT
12:43:28 <johnw> me too
12:43:32 <Taneb> (he isn't very good at this, is he?)
12:43:39 <nand`> joevandyk: oh, you need a space between Two and .. because it's ambiguous with module syntax
12:43:41 <johnw> i need half-case, so I can whisper
12:43:50 <zhulikas> :))
12:43:57 <JorgeArbusto> who isnt Taneb? im learning
12:44:02 <Taneb> projirc,
12:44:32 <joevandyk> nand`: thanks! if i want to shuffle the deck, i need to use monads or something, right?
12:44:45 <nand`> joevandyk: you'd need some way to deal with randomness
12:45:27 <nand`> http://hackage.haskell.org/packages/archive/random-shuffle/0.0.4/doc/html/System-Random-Shuffle.html
12:45:28 <nand`> sounds related
12:45:30 <lamefun_> Is there Gloss with resource loading, textures and sound?
12:46:08 <Cale> Ⓘ ⓐⓜ ⓢⓞ ⓟⓐⓡⓔⓝⓣⓗⓔⓣⓘⓒⓐⓛ ⓣⓗⓐⓣ ⓔⓥⓔⓡⓨ ⓛⓔⓣⓣⓔⓡ ⓘⓢ ⓔⓝⓒⓛⓞⓢⓔⓓ⊙
12:46:17 <otters> god I can't read that
12:46:33 <mekeor> whuut?
12:46:41 <mekeor> me, too.
12:46:42 <nand`> ‘I am so parenthetical that every letter is enclosed.’ ?
12:46:54 <johnw> yeah, I can read that
12:46:56 <johnw> good job, Emacs
12:47:01 <mekeor> yup
12:47:01 <nand`> I could make it out if I squint, and the first letter was a box (probably my font doesn't have the upper case equivalents)
12:47:22 <mekeor> johnw: yeah :D but i think it's rather a matter of the font (and encoding).
12:47:30 * nand` feels like those should be full-width chars so they aren't squished together on monospace fonts
12:47:32 * johnw hugs Emacs
12:48:04 <joevandyk> in blackjack, the suit doesn't matter (I think). So I have a Card { Rank, Suit }. I would want to define methods for the Eq and Ord type classes for Card, right?
12:48:10 <mekeor> i use emacs, too =) johnw, which irc-client do you use?
12:48:16 <johnw> ERC
12:48:22 <mekeor> me, too! :D
12:48:28 <tdammers> joevandyk: you can just derive those
12:48:42 <nand`> joevandyk: for blackjack, don't you basically want a mapping Card -> Int ?
12:48:46 <nand`> since you need to add them up and compare with 21
12:49:01 <joevandyk> nand`: hm, possibly. haven't thought that far ahead yet.
12:49:02 <nand`> oh, it would have to be Card -> [Int] since Ace has multiple possibilities
12:49:49 <nand`> then you could do scoring in the list monad and assign a final score based on whatever blackjack rules I can't remember right now
12:50:50 <adnam> is it possible to have ghc perform type checking but not produce any output files?
12:51:03 <nand`> hmm; with the Prelude ‘sort’ is head . sort O(n) ?
12:51:20 <JorgeArbusto> lol
12:51:39 <nand`> adnam: you could probably use ghci to :l the file, at any rate
12:52:00 <tdammers> nand`: I'd expect the same big-O as sort alone
12:52:24 <adnam> nand`: how about using `minimum`?
12:52:31 <danil> adnam: you can do it with the ghc api, not sure if there's a command-line flag
12:52:32 <nand`> adnam: I know, just curious
12:52:39 <adnam> nand`: ok:)
12:52:45 <nand`> adnam: eg. what about take 2
12:53:14 <JorgeArbusto> > sort[4,5,2,2,1,3]
12:53:15 <lambdabot>   [1,2,2,3,4,5]
12:53:36 <JorgeArbusto> > fmap sort (Just [4,5,2,2,1,3])
12:53:38 <lambdabot>   Just [1,2,2,3,4,5]
12:53:45 <JorgeArbusto> @src fmap
12:53:46 <JSchwag> wow lists are so cool
12:53:46 <lambdabot> Source not found. There are some things that I just don't know.
12:53:58 <nand`> JorgeArbusto: fmap is a class function
12:54:07 <nand`> @src Maybe fmap
12:54:08 <lambdabot> fmap _ Nothing       = Nothing
12:54:08 <lambdabot> fmap f (Just a)      = Just (f a)
12:54:20 <JorgeArbusto> @src Either fmap
12:54:20 <lambdabot> fmap _ (Left x) = Left x
12:54:21 <lambdabot> fmap f (Right y) = Right (f y)
12:55:07 <joevandyk> is there a better way to define this? instance Ord Card where (<=) (Card rank _) (Card rank1 _) = rank <= rank1
12:55:13 <JorgeArbusto> @slap JSchwag
12:55:14 * lambdabot orders her trained monkeys to punch JSchwag
12:56:02 <nand`> joevandyk: instance Ord Card where compare = comparing rank -- ?
12:56:26 <JorgeArbusto> :t sortOn
12:56:28 <lambdabot> Not in scope: `sortOn'
12:56:31 <JorgeArbusto> :t sortBy
12:56:33 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:56:47 <JorgeArbusto> > sortBy (<) [1,2,3,2,3,1]
12:56:49 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
12:56:49 <lambdabot>         against inferr...
12:56:58 <JorgeArbusto> > sortBy (>1) [1,2,3,2,3,1]
12:57:00 <lambdabot>   Couldn't match expected type `a -> GHC.Ordering.Ordering'
12:57:00 <lambdabot>         against i...
12:57:04 <JorgeArbusto> :t sortBy
12:57:05 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:57:07 <joevandyk> nand`: comparing?
12:57:17 <nand`> :t comparing -- joevandyk
12:57:19 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:57:22 <JorgeArbusto> :t Ordering
12:57:24 <lambdabot> Not in scope: data constructor `Ordering'
12:57:46 <adnam> JorgeArbusto: you can also pm the bot if you want to play around :)
12:58:14 <JorgeArbusto> > sortBy (\a b -> comparing (<) a b) [12,3,1,2,34]
12:58:16 <lambdabot>   *Exception: (==): No overloading for function
12:58:36 <JorgeArbusto> > sortBy (comparing (<)) [12,3,1,2,34]
12:58:37 <lambdabot>   *Exception: (==): No overloading for function
12:58:42 <JorgeArbusto> > sortBy (comparing (==)) [12,3,1,2,34]
12:58:44 <lambdabot>   *Exception: (==): No overloading for function
12:58:53 <johnw> JorgeArbusto: he means, do a /query lambdabot and talk to it directly
12:58:53 <nand`> > sortBy (comparing compare) [12,3,1,2,34]
12:58:54 <lambdabot>   *Exception: (==): No overloading for function
12:58:56 <johnw> we don't all need to watch
12:59:04 <nand`> oh, right
12:59:07 <nand`> it would be sortBy compare
12:59:07 <EvanR> some like to watch
13:00:24 <joevandyk> nand`: i'm sort of confused how `compare = comparing rank` works.
13:00:36 <joevandyk> i know i'm defining a compare function, leaving out the two arguments
13:00:54 <nand`> rank :: Card -> Rank
13:00:57 <nand`> :t compare
13:00:58 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:00:59 <nand`> err
13:01:02 <nand`> :t comparing
13:01:03 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:01:09 <nand`> so comparing rank :: Card -> Card -> Ordering
13:01:16 <parcs`> nand`: pretty sure 'head . sort' is O(n)
13:01:24 <danil> > sortBy (comparing last) $ words "boy is it hard to think of words that don't end in 'e'"
13:01:24 <nand`> which is what your define ‘compare’ for instance Ord Card needs
13:01:25 <lambdabot>   ["'e'","hard","end","of","think","in","to","is","words","it","that","don't"...
13:01:45 * mekeor likes the Monad instance of Either (esp. when using sequence).
13:02:14 <nand`> joevandyk: to perhaps enlighten how it works; compare = comparing rank could be expanded to compare a b = compare (rank a) (rank b)
13:02:39 <EvanR> mekeor: is that different from mconcat?
13:03:06 <joevandyk> nand`: i'm going to need to read more about why that works. :)
13:03:27 <mekeor> EvanR: oO dunno
13:03:36 <nand`> > mconcat [Left (), Right 3, Right 4, Left ()]
13:03:37 <lambdabot>   No instance for (Data.Monoid.Monoid (Data.Either.Either () b))
13:03:37 <lambdabot>    arising f...
13:03:48 <nand`> uhm
13:03:51 <nand`> > msum [Left (), Right 3, Right 4, Left ()]
13:03:53 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error ())
13:03:53 <lambdabot>    arising from a use ...
13:04:01 <EvanR> nevermind
13:04:06 <EvanR> Monoid is for all the same type
13:04:10 <EvanR> Monad is for any type
13:04:16 <mekeor> ?
13:04:35 <EvanR> instance Monad (Either e)
13:04:36 <mekeor> there could be a Monoid instance for (Either a b)
13:04:37 <JorgeArbusto> > msum [Nothing, Just "nand"]
13:04:39 <lambdabot>   Just "nand"
13:04:50 <nand`> yeah
13:04:58 <joevandyk> Hm. if a type is a member of the Ord typeclass, shouldn't it also be a member of the Eq one?
13:04:59 <nand`> > msum [Nothing, Just 3, Just 4, Nothing]
13:04:59 <EvanR> mekeor: but everything in the list would have to have the same a and b
13:05:00 <lambdabot>   Just 3
13:05:03 <nand`> ^ takes on the first non-Nothing value
13:05:05 <JorgeArbusto> > catMaybes [Nothing, Just "nand"]
13:05:07 <lambdabot>   ["nand"]
13:05:11 <mekeor> EvanR: yes.
13:05:15 <nand`> > sequence [Just 3, Just 4, Nothing, Just 5]
13:05:16 <lambdabot>   Nothing
13:05:21 <nand`> ^- but this one short-circuits on errors
13:05:23 <nand`> they're distinct
13:05:33 <mekeor> EvanR: isn't it same with Monad?
13:05:41 <EvanR> :t sequence
13:05:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:05:46 <mekeor> > sequence [Left 5, Left "foo"]
13:05:48 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
13:05:48 <EvanR> yeah... nevermind
13:05:48 <lambdabot>    arising from the literal ...
13:05:50 <mekeor> see.
13:05:52 <mekeor> EvanR: :P
13:06:32 <mekeor> EvanR: but mempty is difficult for Either.
13:06:44 <nand`> I think there are a few valid Either a b monoids
13:06:49 <nand`> prolly something like Monoid b => Either a b
13:07:01 <nand`> where mempty = Right mempty; and Either _ acts as a second identity
13:07:12 <nand`> maybe Default a, Semigroup b => Either a b -- ?
13:07:21 <mekeor> yeah, so you can't make (E a b) generally an instance of monoid, true?
13:07:33 <EvanR> wrong
13:07:37 <nand`> false
13:07:42 <nand`> data Void2 a b = Void2
13:07:44 <mekeor> E = Either.
13:07:46 <nand`> oh
13:07:48 <mekeor> :D
13:07:56 <mekeor> didn't want to write…
13:07:58 <mekeor> sorry
13:08:20 <EvanR> agree that all Left are the same ;)
13:08:21 <nand`> in that case you're right; there's no way to construct a general ‘a’
13:08:30 <EvanR> even if they are not
13:08:48 <nand`> so you'd need some form of constraint on them
13:09:19 <mekeor> btw, i forgot what the '|' between 'class' and 'where' means.
13:09:31 <nand`> fundeps?
13:09:36 <EvanR> Right x `mappend` Right y = Right y
13:09:39 <mekeor> what's that?
13:09:44 <nand`> class Foo a b | a -> b -- each ‘a’ can only be associated with a single ‘b’
13:10:06 <weexplat> mempty = undefined ; mappend a b = undefined.  you're welcome :)
13:10:08 <EvanR> foo `mappend` Left _ = foo
13:10:23 <EvanR> Left _ `mappend` foo = foo
13:10:24 <hpaste> “-” pasted “sieve” at http://hpaste.org/72749
13:10:38 <mekeor> nand`: so i can't make both Foo Bar and Foo Baz an instance of such a class?
13:10:40 <EvanR> empty = Left undefined
13:10:48 <nand`> mekeor: eg. instance Foo () Int; if I have some Foo a b => constraint somewhere and I infer a to be (), I can automatically know b must be Int because there can be no valid other instance
13:10:53 <nand`> mekeor: correct
13:11:03 <mekeor> nand`: thank you.
13:11:08 <weexplat> (of course you need the custom Eq instance that is (==) = const (const True), the regular one won't work with this definition :)
13:11:24 <EvanR> no one said you needed an Eq instance
13:11:27 <EvanR> just a Monoid
13:12:03 <weexplat> EvanR: you can't make sense of the monoid laws without at least a notion of equality, and the Eq instance, if it exists, shouldn't conflict with that
13:12:14 <mekeor> is there an type class (Equals a b)?
13:12:25 <weexplat> mekeor: a ~ b
13:12:25 <EvanR> weexplat: they wouldnt, because the only one that makes sense involves _|_
13:13:03 <EvanR> weexplat: the monoid laws can be satisfied without Eq
13:13:13 <mekeor> weexplat: ? where's it definedß
13:13:13 <scooty-puff> mekeor: maybe take a look at http://hackage.haskell.org/package/convertible (though i haven't used it much)
13:13:14 <belgin> hello! when does the function "mark" stop marking numbers here: http://hpaste.org/72750
13:13:18 <mekeor> s/ß/?/
13:13:18 <weexplat> EvanR: i think Eq should not yield _|_ when comparing things with mempty
13:13:21 <nand`> ‘equality’ in a denotational sense has little to do with class Eq
13:13:36 <belgin> i have a problem understanding lazy lists
13:13:46 <belgin> can someone please help me?
13:14:00 <EvanR> weexplat: well fine, define one that just looks at constructors, but thats beyond the scope of Monoid and monoid laws
13:14:02 <johnw> what do you need to know in particular?
13:14:08 <mekeor> belgin: never because the list is infinite.
13:14:09 <nand`> mekeor: I'm not sure what your ‘class Equals a b’ would imply
13:14:53 <mekeor> nand`: class Equals a b where (===) :: a -> b -> Bool
13:15:02 <nand`> mekeor: then you don't want ~
13:15:04 <belgin> i need to understand when "mark" stops marking numbers after a single call to it http://hpaste.org/72750
13:15:05 <nand`> ~ is for type equality
13:15:11 <mekeor> ah.
13:15:36 <weexplat> mekeor: oh, that's a weird class
13:15:37 <nand`> as for that, I don't think so; but there are a lot of ==='y operators (often jokingly) defined somewhere in lambdabot involving Read instances :)
13:15:39 <mekeor> belgin: mark stops marking when the list is empty
13:15:54 <nand`> mekeor: heh, because it errors
13:15:55 <mekeor> belgin: but the list never becomes empty because it's infinite.
13:16:12 <mekeor> nand`: hehe.
13:16:28 <belgin> mekeor: so you're saying it enters an infinite loop and "primes" never gets evaluated?
13:16:41 <nand`> belgin: no. it evaluates lazily
13:16:55 <mekeor> exactly.
13:17:03 <ion> class Equals a b c | a b -> c where (===) :: a -> b -> c
13:17:04 <nand`> belgin: basically, the calculations ‘stops’ as soon as you stop looking at the result
13:17:18 <nand`> (or the other way around, they only get calculated when you look at the result in the first place)
13:17:31 <mekeor> ion: what's that?
13:17:31 <n-dolio> ion: Not general enough.
13:17:35 <nand`> belgin: so if you write say ‘take 10 primes’, then ‘mark’ keeps marking until ‘primes’ has spit out the first 10 primes
13:17:41 <johnw> lazy evaluation is like having an infinitely long Snickers Bar you eat whenever you're hungry
13:17:41 <n-dolio> class Equals f where (===) :: f
13:17:45 <nand`> after that it just stops, because nobody's asking it to evaluate further
13:17:52 <ion> n-dolio: Ah, great.
13:17:56 <scooty-puff> i often see undefined used where you really need to specify a type - i.e. bitSize (undefined :: Int)
13:17:56 <nand`> johnw: finite lists are lazy too
13:18:04 <johnw> nand`: true, true
13:18:13 <johnw> nand`: was just trying to get in the Colbert reference :)
13:18:14 <belgin> nand`: what i don't understand is, during the first call to "mark", how far does it go in the list?
13:18:22 <scooty-puff> wouldn't you be better off with data Ph a = Ph; bitSize (Ph :: Ph Int)?
13:18:25 <mekeor> nand`: infinte
13:18:31 <mekeor> oh, finte, too, yeah.
13:18:34 <scooty-puff> since the fact that the argument isn't used is explicit?
13:18:40 <mekeor> s/finte/finite/g
13:18:52 <belgin> it has to stop sometime because then, the rest of "sieve" wouldn't get evaluated
13:18:53 <nand`> belgin: well, say you're evaluating the head of ‘primes’; in this scenario ‘mark’ wouldn't get executed at all
13:19:06 <n-dolio> ion: It's fully standards compliant, too. No extensions.
13:19:51 <nand`> but if you evaluate the second place; ‘sieve’ itself evaluates the head of ‘mark xs 1 n’; which means mark does exactly one step
13:20:14 <nand`> (unless the result is 0, in which case ‘sieve’ recurses a second time)
13:20:33 <nand`> belgin: basically, every time you read out another prime; ‘mark’ keeps looping until the ‘k == m’ no longer holds
13:20:58 <nand`> (to be more precise, mark and sieve loop in tandem)
13:22:10 <danil> belgin: when you pattern match on a value, only enough of it gets evaluated ("forced") in order to figure out which branch of the match to take
13:23:18 <weexplat> isn't there a nice web demo of some things being lazily evaluated somewhere?
13:23:39 <nand`> sorry, no, I was misreading the code somewhat
13:23:42 <belgin> this is what i (don't) understand is happening: sieve is called with argument [2..], then mark [3..] 1 2, then mark [4..] 2 2, then mark [5..] 1 2 when does this recursion of mark stop?
13:24:23 <paolino> belgin, they are definition of what to do
13:24:24 <nand`> never
13:24:27 <nus> when you stop consuming
13:24:27 <mauke> belgin: immediately
13:24:36 <nand`> and thus, three entirely different answers
13:24:40 <nus> heh
13:24:47 <mauke> that's what happens when you ask ambiguous questions
13:24:48 <danil> belgin: mark return immediately every time, because it always gives a (:)
13:24:50 <nand`> it depends on how you approach the problenm
13:24:59 <nand`> the definitions ‘never’ stop
13:25:04 <nand`> but the evaluation only goes as far as it needs to
13:25:14 <weexplat> three entirely different answers that are all correct
13:25:21 <nand`> :)
13:25:22 <danil> belgin: that is, you only need to go one step to get the front of the list returned by mark, and if you look at the tail you force another step
13:27:04 <weexplat> when you call mark, the recursion stops immediately
13:27:48 <weexplat> as you evaluate an unfolding of sieve, mark unfolds once and then stops
13:28:18 <weexplat> as you evaluate mark deeper and deeper, the recursion never stops
13:28:43 <nand`> maybe it would help to look at a simpler example of recursive definitions
13:28:54 <paolino> @src repeat
13:28:54 <lambdabot> repeat x = xs where xs = x : xs
13:28:58 <weexplat> three answers, three contexts, each answer is true in its context
13:29:04 <nand`> > let cat = "meow " ++ cat in take 3 (words cat)
13:29:06 <lambdabot>   ["meow","meow","meow"]
13:29:14 <nand`> belgin: do you understand how this works ^ ?
13:29:39 <mauke> preflex: seen chrisdone
13:29:39 <preflex>  chrisdone was last seen on #haskell 4 days, 20 hours, 24 minutes and 46 seconds ago, saying: * chrisdone disappears
13:30:05 <weexplat> must be a siamese cat :)
13:30:06 <belgin> nand`: yes
13:30:45 <EvanR> > let x = 1:x in x
13:30:47 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:31:06 <johnw> EvanR: that's cool
13:31:12 <johnw> didn't know you could do that
13:31:24 <danil> > let count n = n : count (n + 1) in take 5 (count 1)
13:31:26 <lambdabot>   [1,2,3,4,5]
13:31:35 <EvanR> johnw: its the same thing as the source for repeat above
13:34:16 <weexplat> > 1 :: (Int,(Int,(Int,Int)))
13:34:18 <lambdabot>   (1,(1,(1,1)))
13:34:36 <EvanR> tite
13:34:40 <weexplat> (unrelated)
13:34:48 <nand`> > let foobar = "foo bar " ++ (unwords . map reverse . words) foobar in foobar
13:34:50 <lambdabot>   "foo bar oof rab foo bar oof rab foo bar oof rab foo bar oof rab foo bar oo...
13:34:57 <EvanR> > (1,(1,(1,1))) + (5,(2,(5,3)))
13:34:58 <lambdabot>   (6,(3,(6,4)))
13:35:15 <nand`> > (1,2) * (3,4)
13:35:16 <lambdabot>   (3,8)
13:35:34 <DMcGill> why on earth do the versions of HTTP on hackage start with 4000?
13:35:38 <DMcGill> i.e. 4000.2.3
13:35:40 <nand`> oh good, the last unfortunate Num (a, b) instance I had come across error'd on (*)
13:35:45 <EvanR> > (1 :+ 2) * (3 :+ 4)
13:35:46 <lambdabot>   (-5.0) :+ 10.0
13:35:50 <weexplat> > ((1,2),1) + (5,(2,(5,3))
13:35:52 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:35:52 <xcvii> hi, is there an easy way to create a syntax tree out of the textual representation of some haskell code (ie. a String)?
13:35:58 <weexplat> > ((1,2),1) + (5,(2,(5,3)))
13:36:00 <lambdabot>   ((6,7),(3,(6,4)))
13:36:16 <geekosaur> xcvii, haskell-src-exts package?
13:36:18 <nand`> > (2,3) * 4
13:36:19 <lambdabot>   (8,12)
13:36:23 <nand`> this is actually surprisingly useful
13:36:30 <Nereid> > Left 2 * 5
13:36:32 <lambdabot>   No instance for (GHC.Num.Num (Data.Either.Either t b))
13:36:32 <lambdabot>    arising from a us...
13:36:34 <Nereid> aww.
13:36:36 <nand`> I could refactor pong with that instance
13:36:43 <danil> DMcGill: probably they used some strange version numbering scheme without periods and then converted to the official package versioning policy, which required that they use that number as the major version
13:36:50 <Nereid> > Right 5
13:36:52 <lambdabot>   Right 5
13:36:52 <Nereid> > Right 5 * 3
13:36:54 <lambdabot>   No instance for (GHC.Num.Num (Data.Either.Either a t))
13:36:54 <lambdabot>    arising from a us...
13:36:56 <Nereid> bdgfdgh
13:36:57 <weexplat> DMcGill: it's to remind you not to use HTTP ...
13:37:11 <xcvii> geekosaur, cheers, don't know that package, willcheck!
13:37:39 <nand`> ugh
13:38:02 <DMcGill> what should I be using instead of http and why?
13:38:04 <nand`> “Overlapping instances for Num Point” -- I wish I could get rid of the broken Graphics.Gloss.Data.Point instance
13:38:20 <weexplat> nand`: :(
13:38:35 <Nereid> nand`: you can!
13:38:46 <nand`> I can?
13:39:15 <weexplat> DMcGill: http-conduit (or is it http-conduits?  i'm always forgetting) is probably better for most uses
13:39:29 <Clint> the former
13:39:44 <weexplat> Nereid: he can?
13:40:02 <nand`> yes we can
13:40:14 <nand`> (sorry)
13:40:35 <Nereid> write a patch
13:40:47 <weexplat> .
13:41:26 <weexplat> where's a kannada IM when you need one?
13:46:22 <xplat> iow ಠ_ಠ
13:48:50 <nand`> well, I've sent them an email, for all the good it will do me
13:56:27 <kallisti> how do you go about making changes to the haskell wiki?
13:56:50 <johnw> isn't in immutable?
13:56:53 <johnw> s/in/it
13:57:01 <johnw> you just make new pages with the changes you want
13:57:19 <kallisti> how fitting.
13:57:39 <kallisti> will someone else come and merge it into the main page? because I don't want a new page.
13:58:04 <johnw> i was just kidding :)
13:58:11 <kallisti> >_>  oh. right. yes.
14:09:13 <wuttf> hello guys
14:10:11 <wuttf> can i load code dynamically in haskell?
14:10:23 <t7> yes
14:10:32 <t7> using the Dynamic type class
14:10:56 <Nereid> t7: that's not what that does
14:11:08 <ion> There’s a Dynamic type class?
14:11:12 <wuttf> will using code loaded dynamically will differ from using statically imported packages?
14:11:20 <johnw> ion: http://sequence.complete.org/node/263
14:11:30 <t7> wuttf: theres haskell interpretters on hackage
14:11:31 <Nereid> yeah, it's not a typeclass either.
14:11:38 <johnw> ah, that's not right
14:11:48 <johnw> ion: wrong link
14:11:54 <Nereid> wuttf: there is a "plugins" package on hackage
14:12:20 <stepkut> plugins or hint
14:12:21 <wuttf> t7 but i would like to compile most of my app statically, i just want to load code here and there
14:12:29 <wuttf> Nereid: i will look into it
14:12:41 <Nereid> or hint
14:12:53 <shapr> hint is pretty awesome
14:12:53 <stepkut> wuttf: on linux you can use plugins-auto, which will use inotify to automatically reload code
14:13:19 <wuttf> stepkut like hotswapping in erlang?
14:13:27 <stepkut> wuttf: yes, one moment
14:13:56 <stepkut> a demo: http://www.youtube.com/watch?v=ok_gf0QVLnE
14:14:23 <wuttf> anyway i am a total beginner never written a line of haskell
14:14:32 <stepkut> we need to switch to the new portable inotify from GSoC.. but I am not sure it released yet
14:14:37 <wuttf> im just meditating on learning it
14:15:01 <ion> I don’t think that’s like the hot code upgrades in Erlang.
14:15:51 <stepkut> ion: it is 'like' for some definition of like..
14:15:53 <johnw> ah, Data.Dynamic lets you do boxing and unboxing
14:16:05 <johnw> kind of like what C's void pointers were often used for
14:16:11 <stepkut> ion: what part do you think is different ?
14:16:15 <c_wraith> Data.Dynamic isn't designed to handle code reloading, though.
14:16:22 <c_wraith> Nor is the GHC api, really
14:16:28 <stepkut> i have never used erlang so I don't know
14:16:43 <johnw> no, it's not
14:16:50 <johnw> lazy loading of code is something else entirely
14:17:10 <shapr> Also, Erlang's code reloading is flippin' awesome in ways most languages have never even thought of...
14:17:14 <c_wraith> stepkut: the biggest difference is that erlang is dynamically typed, meaning that things can't become incorrectly-typed with a code reload
14:17:46 <c_wraith> stepkut: and that's a more severe issue than you might think, as things can become spuriously incorrectly-typed
14:18:09 <roconnor> shapr: how does code-reloading work?
14:18:25 <roconnor> shapr: the whole concept is foreign to me
14:18:28 <shapr> Erlang can have many multiple versions of the same code loaded. Newer invocations of that code will always use the most recent version, but the older versions are still there while they're being used.
14:18:44 <ion> stepkut: In Erlang you load a new version of a module and then send a message to the process running the old code telling it to upgrade. It will then handle the message at some time it feels like it and jump to the new version’s main loop, passing its state along (at which time the new code may or may not upgrade the state data structure to a new format). In addition Erlang/OTP has supervision trees which
14:18:46 <ion> handle the case that something goes wrong by restarting the processes and everything that depends on them.
14:19:10 <wuttf> you can just do a compilation/static analysis/type checking at loading and ignore the new code if there is a compilation error
14:19:13 <shapr> roconnor: Have you read dons thesis?
14:19:15 <roconnor> shapr: can the type of these functions change?
14:19:18 <roconnor> shapr: no
14:19:30 <n-dolio> Erlang doesn't have types.
14:19:48 <shapr> roconnor: The Haskell approach to code reloading started when ghci's ability to 'reload' code got integrated into lambdabot by Andre Pang.
14:19:49 <roconnor> n-dolio: not even # of parameters?
14:20:11 <shapr> roconnor: After which Ganesh Sittampalam improved the code greatly, and then Don Stewart made it industrial quality.
14:20:16 <shapr> preflex: seen Heffalump
14:20:16 <preflex>  Heffalump was last seen on #darcs 1 day, 19 hours, 54 minutes and 52 seconds ago, saying: sm: my guess was that the message came from the hub side of things, but I could be wrong
14:20:22 <roconnor> shapr: ghci reloading destroys my existing context of definitions.
14:20:34 <johnw> here's an oldish article on hs-plugins: http://www.bluishcoder.co.nz/2008/11/dynamic-compilation-and-loading-of.html
14:21:12 <n-dolio> roconnor: It has that, at least as far as importing, I think.
14:21:18 <shapr> I find it nifty that lambdabot was a big part of the reason Haskell can do runtime code reloading.
14:21:29 <roconnor> n-dolio: okay can updated versions of function in erlang change the number of arguments?
14:21:34 <n-dolio> No idea.
14:21:46 <roconnor> shapr: can updated versions of function in erlang change the number of arguments?
14:22:17 <shapr> roconnor: I don't know, I don't actually *use* Erlang, I just read about its code reloading in an effort to discover what had been implemented.
14:22:28 <shapr> when lambdabot was getting all these awesome features
14:22:31 <roconnor> hmm
14:23:02 <roconnor> shapr: so what are some of these awesome featchrs of code reloading that Erlang has that other languages haven't even thought of?
14:23:07 <roconnor> *features
14:23:20 <n-dolio> If you want typed version of this stuff, I think Alice ML is the place to look.
14:23:28 <n-dolio> Where you can runtime load arbitrary ML modules.
14:23:55 <roconnor> n-dolio: so long as the follow a defined at compile-time ML module signature?
14:23:58 <shapr> roconnor: As far as I know, hs-plugins can reload a symbol, but only one version can be in memory at any given time, you don't get multiple versions at the same time that get GC'd later.
14:24:41 <n-dolio> roconnor: Yes. Presumably there's some code that ensures that the dynamically loaded module matches the statically checked signature.
14:24:55 <roconnor> n-dolio: okay, this I can imagine.
14:25:10 <c_wraith> n-dolio: so it can't handle reloading code that defines types in the signature?
14:25:10 <roconnor> though to make use of it you probably need heavy use of modules
14:25:42 <c_wraith> err, types in the signatures of *other* modules
14:26:32 <wuttf> wtf http://www.youtube.com/watch?v=iSmkqocn0oQ
14:26:46 <wuttf> its not convincing me to learn the language
14:27:15 <c_wraith> well, then, farewell!
14:27:36 <n-dolio> c_wraith: I'm not sure exactly what you mean.
14:28:50 <c_wraith> n-dolio: you dynamically load module A, which defines a type, A.  Then you dynamically load module B, which uses type A in its interface...  Is that much even possible?  Maybe not..
14:29:13 <c_wraith> n-dolio: but if it is, what happens when you then reload module A?
14:29:17 <n-dolio> B would need to be a functor, presumably.
14:29:41 <stepkut> wuttf: which part is not convincing you?
14:29:48 <gwern> @remember Evbn I heard that Untyped and Well Typed tried to set up a corporate softball league, but they couldn't agree on a ruleset to use.
14:29:49 <lambdabot> Done.
14:29:51 <gwern> @flush
14:29:53 <n-dolio> Load A, load B, pass A to B, reload A, pass new A to B.
14:30:06 <wuttf> stepkut: when that simon guy classifies haskell as "safe but useless"
14:30:14 <stepkut> wuttf: :)
14:30:22 <c_wraith> wuttf: he's using a *very* specific definition of useless.
14:30:32 <Nereid> @where lyah
14:30:33 <lambdabot> http://www.learnyouahaskell.com/
14:30:38 <Nereid> wuttf: get started with this ;)
14:31:02 <stepkut> he is also talking about the history of Haskell.. prior to GHC 5.x Haskell was pretty useless..
14:31:03 <c_wraith> n-dolio: that works because B is parameterized over types, and doesn't actually use A in its signature.  Not really the question.
14:31:39 <shapr> stepkut: 5.04 was a good version
14:31:43 <c_wraith> n-dolio: I think the answer is actually "I can't express the types I mean"
14:31:58 <c_wraith> n-dolio: nothing wrong with that - I was just hoping it had a solution for it.
14:32:06 <stepkut> shapr: yup, that was the first version I used.. even then, it still didn't have hierarchical modules I think..
14:32:15 <shapr> Yup, it didn't
14:32:20 <Okasu> hello
14:32:21 <stepkut> shapr: I think those were added in 6
14:32:30 <shapr> privyet Okasu!
14:32:37 <Okasu> :)
14:32:42 <luite> i've only used 6.10+ :(
14:32:46 <Cale> wuttf: Yeah, he's really talking about the history. Haskell started out from a position of safety but relative uselessness, and moved toward adding the things which would make it practical, rather than starting from utmost pragmatic practicality, and trying to hack on things to make it safe.
14:32:48 <shapr> Okasu: Are you learning Haskell?
14:32:53 <Okasu> shapr: yeah
14:33:05 <shapr> Okasu: got any questions?
14:33:13 <stepkut> when was the IO monad added ?
14:33:27 <Okasu> is it possible to read file without tainting it with IO monad?
14:33:29 <stepkut> sometime before H98 I am guessing
14:33:33 <Cale> stepkut: Haskell 1.3?
14:33:40 <Okasu> i just want get string from file
14:33:46 <wuttf> Cale, Nereid im going to test drive myself and see how useful it is ;)
14:33:48 <stepkut> Cale: any idea what year that was (approximately)
14:33:48 <Cale> Maybe earlier
14:33:52 <shapr> Okasu: Not really. But you can untaint the result.
14:34:01 <Okasu> how?
14:34:12 <ion> pureFunction <$> ioAction
14:34:30 <Nereid> (returning another IO action)
14:34:31 <jfischoff> @src (<$>)
14:34:31 <lambdabot> f <$> a = fmap f a
14:34:39 <Okasu> oh ok, thanks
14:34:57 <Cale> stepkut: 1996
14:34:57 <Nereid> equivalent to do { x <- ioAction; pureFunction x }
14:35:13 <ion> nereid: do { x <- ioAction; return (pureFunction x) }
14:35:15 <Nereid> er
14:35:16 <Nereid> yeah.
14:35:26 <jfischoff> Cale: when did you start using Haskell?
14:35:32 <Cale> jfischoff: 2001 or so
14:35:37 <stepkut> Cale: thanks
14:35:37 <jfischoff> nice
14:35:40 <n-dolio> c_wraith: If B references a type defined in some specific structure A, then loading a new module with the same structure as A over the wire wouldn't necessarily make it work with B. Unless there were some constraint that the types defined in the new A were the same as those in the old A. But I don't know how much of that Alice ML handles. I've only glanced at it.
14:35:41 <fryguybob> #define S_UNLOCK(lock)          (*((volatile slock_t *) (lock)) = 0)
14:35:45 <startling> is there an instance of Bifunctor for Map somewhere?
14:35:47 <fryguybob> oops :D
14:35:51 <n-dolio> Same signature as A, even.
14:36:19 <danil> startling: there can't be, you need Ord on the keys
14:37:22 <startling> danil: oh ugh
14:37:38 <Nereid> and even if you had that
14:37:41 <Nereid> it still wouldn't work
14:38:01 <Nereid> for a good reason
14:38:09 <startling> :'(
14:38:11 <n-dolio> Yeah, what does bimap (const k) id do?
14:38:27 <Nereid> you could try to make it contravariant in the first argument but even that doesn't work because a Map can only have finitely many keys
14:38:46 <startling> guess I need to go back to association lists !
14:38:49 <n-dolio> Also bimap f id . bimap g id /= bimap (f . g) id necessarily.
14:39:15 <startling> yayyy O(n)
14:39:21 <Nereid> n-dolio: really? that sounds wrong.
14:39:24 <Cale> Well, actually, it was 2002 before I really started trying to use it. I remember GHC 5.02 being released around the time I was starting.
14:39:50 <danil> startling: don't alists have all the same problems as maps?
14:40:17 <Nereid> actually
14:40:22 <n-dolio> Nereid: Well, maybe it would work out.
14:40:35 <Nereid> startling: there was some discussion some time ago on how to make something like Map k v -> Map k' v from k -> k'
14:40:48 <Nereid> where v is a Monoid
14:40:58 <Nereid> (imagine if k -> k' wasn't injective)
14:41:06 <Nereid> what was that thing called?
14:41:09 <startling> Nereid: right, understood
14:41:12 <Nereid> the thing that was like Map but had a default value.
14:41:14 <n-dolio> Right, non-injective funcions are the problem.
14:41:21 <startling> what we really need is injectivity-checking
14:41:25 <Nereid> no
14:41:34 <startling> danil, what problem?
14:41:39 <Nereid> if v is a Monoid then you can just msum all the values together.
14:41:45 <startling> danil: oh, Eq. dang
14:41:45 <Nereid> er, mconcat
14:41:57 <danil> startling: Eq, and a need to do something when your keys collide
14:42:07 <startling> danil: I could live with duplicates
14:42:18 <Nereid> maybe, but Map can't.
14:42:21 <startling> indeed
14:42:29 <Nereid> argh, I forget what it was called. Cale ?
14:42:56 <Cale> What was what called?
14:43:04 <startling> in fact, I probably should allow dupes, since this is a data type for object files
14:43:07 <Nereid> the thing that was like Map but had default values.
14:43:32 <Cale> I don't know -- a Map whose codomain is a monoid will.
14:43:52 <Nereid> I think it had a T in the name.
14:43:55 <jfischoff> TotalMap?
14:44:09 <n-dolio> The other weird thing is that you also want (k2 -> k1) -> Map k1 v -> Map k2 v.
14:44:09 <Cale> That'd make sense :)
14:44:19 <n-dolio> Since it's a mapping from ks to vs.
14:44:26 <jfischoff> http://hackage.haskell.org/package/total-map
14:44:27 <Nereid> yes, totalmap is it.
14:45:03 <Nereid> that would let you write (k' -> k) -> Map k v -> Map k' v
14:45:17 <Nereid> and, if v was a commutatuve Monoid, you could map keys covariantly too.
14:45:19 <Nereid> commutative.
14:46:03 <Nereid> (provided mempty is the default value.)
14:48:06 <n-dolio> You cannot have contramap without dropping some of the Map interface.
14:48:17 <Okasu> meh, i still don't understand, mine target is to read file(contents: "foo", "bar") and construct list from it with 'read ["["] ++ content ++ ["]"]'
14:48:44 <Okasu> but i can do  return $ read ("[" ++ content ++ "]")
14:49:32 <Okasu> is it possible?
14:50:36 <ion> do s <- getContents "file"; readIO ("[" ++ s ++ "]")
14:50:57 <Veinor> @src readIO
14:50:58 <lambdabot> Source not found. My brain just exploded
14:51:26 <ion> Whoops, not getContents. readFile.
14:51:32 <Okasu> yeah
14:52:15 <jfischoff> splitOn ","  <$>  readFile "file" ?
14:52:31 <Veinor> what's readIO do?
14:54:08 <n-dolio> readIO is a read that throws an IO exception instead of error.
14:54:59 <Veinor> ah
14:55:39 <jfischoff> is there a readEither :: Sting -> Either String a?
14:56:00 <n-dolio> It's written in the GHC.something libraries, but not exported anywhere.
14:56:01 <Veinor> what's readEither "hi" :: Either String Integer evaluate to?
14:56:31 <jfischoff> Left "parse error: 'hi' is not an Integer"
14:56:44 <jfischoff> or equivalent
14:58:14 <danil> jfischoff: if it uses Read there's no way to get a useful error message
14:58:31 <danil> jfischoff: I guess it could require Typeable and use that to tell you what type it tried to read it as
14:58:41 <Clint> you're probably better off with (atto)parsec
14:59:08 <Veinor> sometimes i wish everything had a typeable instance
14:59:21 <n-dolio> The one written in GHC tells you if the parse was ambiguous, for instance.
14:59:29 <jfischoff> I wonder if you could use spoon and readIO to make readMaybe
15:00:24 <c_wraith> wouldn't it be easier to just use reads?
15:00:31 <c_wraith> :t reads
15:00:32 <lambdabot> forall a. (Read a) => String -> [(a, String)]
15:00:35 <jfischoff> yes
15:00:42 <jfischoff> I'm just curious
15:00:54 <c_wraith> Spoon is actually very careful about what exceptions it catches
15:01:06 <c_wraith> I'm not sure it'd catch what readIO generates
15:01:16 <ion> Spoon is actually very evil.
15:01:33 <jfischoff> if spoon did though, would it be possible?
15:01:51 <c_wraith> with some unsafePerformIO in spoon, sure..
15:02:00 <c_wraith> Which is hilarious, come to think of it.
15:02:08 <c_wraith> Since it's already in terms of unsafePerformIO
15:03:06 <danil> @hoogle Monad m => Maybe a -> (a -> m ()) -> m ()
15:03:07 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:03:07 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:03:07 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:05:29 <wuttf> what the heck is this in haskell ($$)
15:05:40 <coppro> :t ($$)
15:05:41 <lambdabot> Doc -> Doc -> Doc
15:05:49 <coppro> good question :P
15:05:58 <jfischoff> @hoogle ($$)
15:05:58 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
15:05:58 <lambdabot> Text.PrettyPrint ($$) :: Doc -> Doc -> Doc
15:05:58 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
15:06:00 <wuttf> i know $ lets you spare parens, i have even written a small language which worked the same way. but wtf is that $$
15:06:15 <startling> wuttf, probably unrelated
15:06:16 <MostAwesomeDude> @ty ($$)
15:06:18 <lambdabot> Doc -> Doc -> Doc
15:06:26 <coppro> @hoogle ($$)
15:06:26 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
15:06:26 <lambdabot> Text.PrettyPrint ($$) :: Doc -> Doc -> Doc
15:06:26 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
15:06:42 <Twey> wuttf: conduits uses ($$) for conduit-combination
15:06:43 <jfischoff> wuttf: it is a function that someone defined to be infix
15:06:44 <coppro> wuttf: look into those libraries to see
15:06:52 <coppro> Data.Conduit also uses it
15:06:58 <Twey> That's where you're most likely to see it these days, I guess
15:07:01 <coppro> but I don't see that in the hoogle output :/
15:07:11 * hackagebot natural-sort 0.1.2 - User-friendly text collation (JohnMillikin)
15:07:14 <Twey> It's probably truncated to three lines
15:08:04 <wuttf> ty guys indeed conduit is imported
15:11:04 <coppro> I should upload my package of conduit utilities
15:12:24 <wuttf> why must i type impor at every line?
15:12:30 <wuttf> seems like boilerplate
15:12:36 <wuttf> import*
15:13:03 <Twey> Yeah, comma-separated modules would be nice
15:13:09 <Twey> But oh well
15:13:24 <Twey> You can probably TH it if you care enough.
15:13:48 <danil> IIRC you can't generate imports with TH
15:13:58 <jfischoff> You could use CPP though
15:14:24 <jfischoff> not sure how better you can get with CPP
15:16:20 <startling> I like imports on separate lines
15:16:56 <Enigmagic> i've started coding whole modules on one really long line
15:21:34 <startling> is there an auxilary class to Monoid for lengths of things such that length mempty = 0 and length (mappend a b) = length a + length b?
15:22:23 <Cale> startling: That doesn't make sense for most monoids.
15:22:29 <jfischoff> yes
15:22:34 <jfischoff> what Cale said
15:22:48 <Cale> But you could consider something like perhaps Foldable.
15:23:02 <mauke> startling: why not just use lists?
15:23:16 <roconnor> startling: you could form the product of Sum Integer and an arbitrary monoid
15:23:26 <Cale> Well, length is awkward for lists.
15:23:31 <startling> mauke, because this needs to work for ByteStrings too, at the least
15:23:40 <mauke> startling: you can convert ByteStrings to lists
15:23:43 <startling> also length of lists is O(n)
15:24:02 <Cale> But yeah, another option is maybe just use the Sum Integer monoid
15:24:13 <startling> Cale: what's that?
15:24:26 <Cale> > (Sum 6) `mappend` (Sum 10)
15:24:28 <lambdabot>   Sum {getSum = 16}
15:24:40 <Cale> It's a monoid instance which adds numbers.
15:25:06 <Cale> i.e. take the lengths earlier
15:25:14 <mauke> > (Sum 3, "abc") `mappend` (Sum 2, "de")
15:25:15 <lambdabot>   (Sum {getSum = 5},"abcde")
15:25:26 <Cale> that too :)
15:25:32 <startling> ooh
15:26:00 <roconnor>  > (Sum 3, ()) `mappend` (Sum 2, ())
15:26:00 <startling> why aren't numbers already a monoid, btw?
15:26:06 <roconnor> > (Sum 3, ()) `mappend` (Sum 2, ())
15:26:08 <lambdabot>   (Sum {getSum = 5},())
15:26:10 <mauke> startling: because they're two monoids
15:26:15 <roconnor> > (Sum 3, Product 3) `mappend` (Sum 2, Product 2)
15:26:17 <lambdabot>   (Sum {getSum = 5},Product {getProduct = 6})
15:26:19 <startling> mauke: so are lots of things
15:26:19 <Cale> startling: Because there are at least two monoids on every type of number
15:26:23 <startling> ohhh
15:26:32 <startling> so there's Sum and Product (?) monoids?
15:26:35 <Cale> yeah
15:26:44 <Nereid> Sum should be a group
15:26:45 <Cale> They're just instance-selecting newtypes
15:26:48 <startling> yeah
15:27:07 <c_wraith> and product shouldn't?
15:27:17 <Nereid> you can't always divide
15:27:21 <Nereid> particularly not by 0
15:27:22 <startling> kind of annoying that there's not a language-level way to do
15:27:25 <statusfailed> Hmm, how might I modify the "body" part of a page in Hakyll?
15:27:31 <wuttf> i currently use mainly Go, what is your opinion about that language? i am looking into haskell for even more productivity gains
15:27:53 <Cale> wuttf: My opinion is that go is kinda boring as far as new languages go.
15:27:55 <roconnor> wuttf: AFAIK Go has no disjoint sum types.
15:28:01 <Cale> Especially compared to Haskell.
15:28:01 <startling> oh, can I always get the length of foldable?
15:28:22 <jfischoff> startling: yes
15:28:32 <startling> yeah, I think I can use that
15:28:34 <startling> jfischoff: thanks!
15:28:39 <nand`> go is good in some ways and bad in some ways
15:28:41 <jfischoff> np
15:28:43 <Cale> No disjoint sum types, no parametric polymorphism.
15:29:18 <wuttf> what the heck is a disjoint sum type?
15:29:18 <nand`> it doesn't have any form of polymorphism other than casting to/from interfaces, even
15:29:20 <nand`> which is very crude
15:29:21 <S11001001> :t ala
15:29:22 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
15:29:24 <nand`> wuttf: Maybe
15:29:26 <nand`> wuttf: Bool
15:29:28 <nand`> etc.
15:29:33 <startling> wuttf: data Bool = True | False
15:30:16 <wuttf> for me Go feels like a swiss army knife but i have a feeling that haskell is the future
15:30:20 <nand`> the only real improvements I feel go brings to the table is lack of pointer arithmetic, lightweight threads and not being object oriented
15:30:25 <nand`> well, s/improvements/good things/
15:30:32 <roconnor> startling: Go might an enumerations though?
15:30:47 <roconnor> *have
15:30:56 <nand`> go has a few built-in sum types, bool and int are among them
15:30:59 <nand`> enum types are just aliased ints
15:31:07 <roconnor> nand`: not typechecked?
15:31:13 <nand`> roconnor: I'm not sure
15:31:33 <Cale> Go seems not so different from Algol 68 with some spit and polish. It doesn't really capture any new ideas from the last 30 years, afaict.
15:32:46 <Cale> I mean, there's some not-completely-terrible concurrency stuff in there. It's not half as comprehensive as the basic concurrency support in GHC, even ignoring STM and pure parallelism and the fancy new nested data parallelism stuff.
15:32:48 <roconnor> If I don't have a Maybe/option type, my code would be filled with akward special cases littered randomly about.
15:33:55 <roconnor> Can I write functions that return anonymous product types in Go?
15:33:57 <Cale> Go is an improvement on C, but that's a really bad baseline :)
15:34:02 <wuttf> i like its simplicity even i can absorb it. but since i read about functional programming and tried to incorporate ideas from it my code got much better. i think i could use a compiler which enforces those principles
15:34:11 <wuttf> thats why i am looking forward to learn haskell
15:34:40 <Cale> wuttf: Get ready to feel disappointed with the industry of programming.
15:34:49 <Cale> :D
15:34:50 <jfischoff> :)
15:34:52 <nand`> roconnor: I checked, it doesn't have enum types - just ways of automatically counting constants
15:35:01 <nand`> ie. just integers
15:35:10 * roconnor sighs
15:35:17 <wuttf> roconnor: i am not familiar with that terminology, sorry (what is a product type?!)
15:35:27 <roconnor> wuttf: the type of pairs
15:35:32 <Cale> wuttf: Are you familiar with the Cartesian product of sets?
15:35:33 <roconnor> @type ('a',1)
15:35:35 <lambdabot> forall t. (Num t) => (Char, t)
15:35:43 <wuttf> Cale: yes
15:35:44 <roconnor> okay bit of a bad example
15:35:46 <roconnor> @type ('a',True)
15:35:48 <lambdabot> (Char, Bool)
15:35:53 <Cale> wuttf: Like that, considering types to be sets of values.
15:36:10 <wuttf> omg why the fuck would you need that? :D
15:36:31 <Cale> wuttf: Product types are everywhere. Object oriented languages are practically built entirely around products.
15:36:52 <nand`> wuttf: in category theory terms, it goes something like this: a product type of A and B, eg. (A, B) in Haskell, has two functions ‘fst’ and ‘snd’ going from the product type to A and B, respectively; that is fst :: (a, b) -> a; and snd :: (a, b) -> b
15:37:29 <nand`> meanwhile the coproduct lives in the evil world with reversed arrows, meaning it has functions from A to A+B and from B to A+B instead; ie. Left :: a -> Either a b; Right :: b -> Either a b
15:37:44 <nand`> (there's a little more to it, but that demonstrates how sums are just coproducts)
15:37:59 <Cale> I'm not sure that wuttf is not going to be completely confused by that nand` :)
15:38:04 <nand`> oh, sorry
15:38:17 <wuttf> I got the first sentence
15:38:25 <wuttf> completely panicket when reading the second
15:38:29 <wuttf> panicked*
15:38:57 <Cale> Okay, so like pair types are the canonical example of a product
15:39:04 <wuttf> but i always love to learn, with my limited hardware
15:39:08 <Cale> Tagged union types are the canonical example of a sum
15:39:17 <Cale> So in Haskell's Prelude library:
15:39:24 <Cale> data Either a b = Left a | Right b
15:39:29 <Cale> This says that a value of type Either a b
15:39:37 <Cale> is either:
15:39:47 <Cale>   the data constructor Left applied to a value of type a
15:40:00 <Cale>   or the data constructor Right applied to a value of type b
15:40:29 <Cale> So for example, the following values have type Either Integer String
15:40:31 <Cale> Left 5
15:40:34 <Cale> Left 10
15:40:40 <Cale> Right "Hello"
15:40:43 <Cale> Right ""
15:40:47 <Cale> Left (-7)
15:40:50 <Cale> you get the idea
15:41:20 <Cale> So that's a sum type -- it's like the disjoint union of sets
15:41:33 <Nereid> it's more than just "like" disjoint union
15:41:42 <Cale> Well, it is :)
15:41:57 <wuttf> i am in the process of getting :D  its hard to understand you because i have learnt math in hungarian only
15:41:59 <Cale> It's isomorphic to any description of the disjoint union you'd care to give :)
15:41:59 <Nereid> well, it almost is.
15:42:10 <Cale> wuttf: okay
15:42:12 <Nereid> but bottom gets in the way.
15:42:36 <Cale> Yeah, let's not get into that :)
15:42:38 <Nereid> :)
15:42:48 <nand`> roconnor: apparently there's some degree of type safety in go's ‘enum’ types it seems; (go has an analog of newtypes, it seems these ‘enums’ are newtyped ints)
15:42:54 <Cale> wuttf: Simpler example:
15:43:01 <Cale> data Maybe a = Nothing | Just a
15:43:20 <Cale> wuttf: This is what we use in Haskell where people in C land might choose to use nullable pointers
15:43:39 <Cale> wuttf: Or silly things like special int values to represent failure
15:43:53 <wuttf> Cale: read about that!
15:44:10 <Cale> I'm sure you know what I'm talking about -- something which might produce a positive integer result, or -1 if it fails, say.
15:44:28 <Cale> In Haskell, we would just have that thing produce a Maybe type of result
15:44:30 <wuttf> Cale: yes i got it, i just cant imagine it in practice yet
15:44:32 <Cale> Maybe Integer, say
15:44:45 <Cale> and if it succeeded, it would give a result like Just 5
15:44:51 <Cale> Or Just (-1)
15:45:01 <Cale> and if it failed, it would give a result Nothing
15:45:04 <wuttf> Cale: in go we solve this problem by functions having multiple return values, the last having a type of errror
15:45:20 <Cale> wuttf: Right, so you're using product types in a funny way
15:45:32 <Cale> What do the first fields mean if the last one is an error?
15:45:44 <Cale> There's some "slack" in the representation there
15:45:52 <Cale> which we wouldn't have in Haskell with sum types
15:46:05 <wuttf> Cale: the default value of a given type 0 for numbers, "" for strings, nil for maps, arrays etc
15:46:25 <nand`> wuttf: so you're using product types because coproduct types aren't available? :P
15:46:38 <Cale> nand`: Yes, that's what they do
15:46:50 <wuttf> nand`: seems like
15:46:54 <Cale> and hope that there are default values
15:47:09 <Cale> (I don't know what to do when the result is a function, but presumably that's uncommon)
15:47:19 <Nereid> Cale: const (default value of return type)
15:47:19 <Nereid> ;)
15:47:25 <Cale> Nereid: ;)
15:47:26 <wuttf> empty function is nil too
15:47:36 <wuttf> functions are a type too
15:47:46 <mauke> no, the point is that functions are pointers
15:47:50 <Cale> wuttf: In any case, you risk the error being ignored, too.
15:47:52 <mauke> otherwise they couldn't be nil
15:48:05 <Cale> wuttf: because those other values are still there
15:48:05 <wuttf> Cale: yes, you risk, but thats a malpactice
15:48:16 <Cale> Right, so we do away with that malpractice structurally
15:48:20 <Cale> with sum types
15:48:21 <Nereid> wuttf: and the compiler will happily let you ignore the error
15:48:21 <wuttf> mauke: interface is nil too, and they are still not a pointer
15:48:28 <mauke> wuttf: of course they're pointers
15:48:30 <Nereid> not so in haskell ;>
15:48:55 <wuttf> mauke: nope.
15:49:50 <d-best> oO I had to compile my go bot with ghc -O2 to make it fast enough to reply to my moves
15:49:59 <d-best> I think I need to work on optimizing my haskell
15:50:18 <wuttf> interfaces are interfaces, pointers are pointers which can point to instances of types.
15:50:36 <wuttf> let me show you
15:50:40 <Nereid> d-best: you should always -O2.
15:51:14 <Cale> @let quadratic a b c = if disc > 0 then Just ((-b + sqrt disc)/(2*a), (-b - sqrt disc)/(2*a)) else Nothing where disc = b^2 - 4*a*c
15:51:16 <lambdabot>  Defined.
15:51:22 <Cale> > quadratic 1 0 (-2)
15:51:25 <lambdabot>   Just (1.4142135623730951,-1.4142135623730951)
15:51:29 <Cale> > quadratic 1 0 2
15:51:31 <lambdabot>   Nothing
15:51:40 <Nereid> > sqrt (-1)
15:51:42 <applicative> d-best, 02 is all there is
15:51:42 <lambdabot>   NaN
15:51:59 <Cale> wuttf: ^^ there's a simple example
15:52:06 <Cale> Here's another:
15:52:08 <danil> wuttf: golang interfaces are (pairs of) pointers under the hood: http://research.swtch.com/interfaces
15:52:28 <wuttf> danil: Yes, i know that. they are implemented in the C runtime as a pair of pointers
15:52:38 <wuttf> danil: but
15:52:40 <Cale> > let dict = [("hello","world"),("foo","bar")] in lookup "hello" dict
15:52:41 <lambdabot>   Just "world"
15:52:45 <Cale> > let dict = [("hello","world"),("foo","bar")] in lookup "help" dict
15:52:46 <lambdabot>   Nothing
15:52:46 <wuttf> a., a struct containing two pointers is not a pointer
15:53:09 <wuttf> b., the implementation of the runtime in C has nothign to do with the Go terminology of the type system
15:53:13 <applicative> d-best have you read any of the tutorials by tibbe on 'high performance haskell'? they helped me quite a bit
15:53:46 <Cale> wuttf: So basically, in Haskell, when you define a datatype, you define a bunch of data constructors, and each data constructor is allowed to have a different bunch of parameters of various types.
15:54:14 <Cale> wuttf: Datatypes are allowed to be recursive (so you can build tree structures by having fields which are other trees)
15:54:19 <danil> wuttf: I just wasn't sure which sense of "pointer" you meant -- "Xs aren't Ys" can be ambiguous when Xs are in fact implemented as a pair of Ys
15:54:36 <wuttf> danil: see point b
15:54:36 <Cale> wuttf: and datatypes are allowed to have type parameters, which let you specify later what types of elements things have in them
15:54:41 <thurloat> does anyone have an example of some code that uses Shelly for a shell script?
15:55:04 <Nereid> so one can, for example, do
15:55:16 <Nereid> data Tree a = Leaf a | Branch (Tree a) (Tree a)
15:55:42 <applicative> d-best for what they're worth:  http://www.slideshare.net/tibbe/highperformance-haskell http://johantibell.com/files/stanford-2011/performance.html#(1)
15:56:08 <Nereid> and then make a tree like Branch (Leaf 1) (Branch (Leaf 2) (Leaf 3))
15:56:22 <Nereid> (which could have type, say, Tree Int)
15:56:32 <Cale> Branch (Leaf "hello") (Branch (Leaf "there") (Leaf "world")) :: Tree String
15:56:33 <wuttf> i think i have to learn this language, the type systems i know just dont feel right
15:57:05 <wuttf> but i cant articulate my concerns about them
15:57:08 <Nereid> hehe
15:57:46 <Cale> Haskell has probably the best type system of any programming language which can be used for everyday practical work right now.
15:57:57 <Eduard_Munteanu> @remember wuttf i think i have to learn this language, the type systems i know just dont feel right
15:57:58 <lambdabot> Done.
15:58:23 <slack1256> Cale: baseless_assumption.jpg :-)
15:58:54 <Peaker> wuttf, I feel there are lots of bubbles in the PL world.. and that some have advanced far more than others.. I think the authors of Go are stuck in the past and are trying to improve on the state of the art of the 70's because they don't explore other bubbles
15:58:55 <Cale> slack1256: There are some with more expressive fancier type systems, but the languages don't yet have that much library and tool support yet.
15:59:26 <wuttf> Cale: for example?
15:59:26 <c_wraith> I think Go was mostly an attempt at "java done right".  They may have succeeded there.
15:59:34 <Cale> wuttf: Agda
15:59:39 <applicative> wuttf Agda of course
15:59:44 <parcs`> rust too
15:59:47 <wuttf> Cale: just saw a presentation about that
15:59:55 <slack1256> Cale: yeah I know, is just that the yesod blogpost mentioned that specific phrase, I couldn't resist myself.
15:59:57 <Peaker> wuttf, they looked at Java, Python, C, C++ and made something that they think is nicer than all of those... instead of studying the state of the art
15:59:59 <nand`> c_wraith: except for the fact that they forgot polymorphism
16:00:02 <d-best> is there any way to do non-painful 2-dimensional array operations in haskell?
16:00:06 <wuttf> c_wraith: C++ done right i think
16:00:08 <slack1256> although I am hoping to see more agda libraries.
16:00:08 <Eduard_Munteanu> You also mean #agda *grin*
16:00:10 <nand`> I think go was intended to replace C
16:00:24 <parcs`> although rust is not stable yet, its type systems lacks some things haskell's has, but it also has things that haskell doesn't have, like regions and uniqueness types
16:00:46 <Eduard_Munteanu> d-best: hmatrix?
16:00:56 <danil> parcs`: you can implement regions with parametrized monads, it's just not really worth it in Haskell
16:01:02 <Eduard_Munteanu> @hackage hmatrix
16:01:03 <lambdabot> http://hackage.haskell.org/package/hmatrix
16:01:07 <Cale> d-best: How is using the pair instance for Ix so painful?
16:01:11 <Peaker> parcs`, Rust makes some trade-offs I disagree with.. easing name resolutions via single-dispatch semantics is one
16:01:34 <Peaker> parcs`, I think type-class semantics are far more important than name resolution issues
16:01:42 <Cale> d-best: You're aware that you can index arrays with pairs of values, right? :)
16:01:56 <applicative> d-best, the standard arrays can be 2d.   Repa is the avant gard library i guess
16:02:23 <d-best> Cale: I was using a list of lists
16:02:29 <Cale> d-best: oh, I see
16:02:36 <Peaker> wuttf, it's a bit depressing even to see the authors of Go replicate the nullability mistake for the 999th time
16:02:38 <d-best> I am quite newbish at this
16:02:42 <Eduard_Munteanu> Right, so not quite an array.
16:02:46 <nand`> you can use lists of lists too
16:02:47 <Cale> d-best: You said arrays, so I assumed you were already using the array library :)
16:02:52 <nand`> just use the traverse.@traverse lens
16:02:57 <nand`> but that's a bit advanced
16:03:01 <wuttf> this really bothered me: https://groups.google.com/forum/?fromgroups#!msg/golang-nuts/BnjG3N77Ico/ltLWZMdFE5kJ
16:03:09 <d-best> ok I will research the array library
16:03:09 <applicative> d-best what are you putting in the arrays
16:03:09 <wuttf> Russ Cox go author asked
16:03:13 <Eduard_Munteanu> d-best: look at Haskell's Array first then
16:03:23 <Eduard_Munteanu> @hackage array
16:03:24 <nand`> wuttf: I can't load that site
16:03:24 <lambdabot> http://hackage.haskell.org/package/array
16:03:27 <wuttf> "How does immutable differ from the C/C++ const fiasco? "
16:03:39 <wuttf> nand`: :S
16:03:42 <d-best> applicative: a go board, depending on the purpose either just floats, or ints
16:04:04 <wuttf> when i read that sentence i kinda froze
16:04:05 <Veinor> nand`: works for me
16:04:25 <applicative> d-best: then you can use unboxed arrays.
16:05:02 <Cale> wuttf: From the perspective of a Haskell user, all of these languages, go included, have started the race by shooting themselves squarely in the foot, and are trying to hobble along, struggling to provide ways to control the mutation which is implicitly built into almost every meaningful operation
16:05:03 <wuttf> i mean how is that possible that a Go author asks such a question?
16:05:47 <applicative> d-best: it might not matter so much for a go board but in general int float double can be 'unboxed' which generally give a smashing performance advantage
16:06:02 <Cale> wuttf: A less difficult way to provide useful concurrency is just to adopt a programming model which doesn't have you updating things destructively all the time.
16:06:25 <Cale> and where if you really need to do that, you think about it first
16:06:26 <mauke> wuttf: why does that bother you?
16:06:36 <Cale> So *most* things are threadsafe by default
16:06:37 <c_wraith> wuttf: that question indicates a severe meta-level failure.  c/c++ const is a language construct that conveys little meaning, and what it actually does is often useless.  That's entirely orthogonal to the advantages of not actually mutating data.
16:06:50 <latro`a> though as anyone in large-scale, say, finite element analysis would tell you, frequent reconstruction is a problem, too
16:07:09 <mauke> c_wraith: you've lost me
16:07:24 <Cale> I'm not saying don't provide any way to do mutation -- I just mean don't make it the default.
16:07:24 <d-best> alright nice
16:07:34 <latro`a> (have fun reconstructing anything when a single representation of your data structure takes all your memory)
16:07:51 <c_wraith> mauke: the things that make const a mess are language issues unrelated to the concept of immutability - they're just implementation issues.
16:08:07 <mauke> c_wraith: and?
16:08:13 <wuttf> mauke because consts imho has nothing to do immutability. and by asking that Russ seemed like a person who knows fuckall about functional programming/immutability etc. i find that hard to believe, but maybe i have too much respect for Russ and the Go authors
16:08:36 <mauke> const has a lot to do with immutability
16:08:37 <wuttf> Cale: in haskells mutation is done with monads?
16:08:41 <wuttf> -s
16:08:43 <mauke> the proposal isn't about immutability
16:08:48 <mauke> it's about an "immutable" keyword
16:09:05 <mauke> wuttf: monads aren't magic
16:09:17 <Cale> wuttf: There are some libraries which *happen* to be monadic, but that's actually really less relevant
16:09:24 <c_wraith> wuttf: Nah, mutation is done via systems like IO or ST that give some kind of semantics to mutation.
16:09:29 <danil> Cale: what do you think about Disciple's approach?
16:09:41 <c_wraith> wuttf: the fact that those systems form monads just makes them easier to deal with.  Monads are a nice pattern.
16:09:50 <wuttf> Cale i see what is a monad then? a function taking one parameter, no?
16:09:58 <nand`> nope :)
16:09:58 <Cale> danil: I think it's a bit odd. I feel like building a monadic interface around it anyway.
16:10:03 <nand`> that's an entirely different interpretation of the word
16:10:04 <wuttf> nand`: lol i see
16:10:24 <Cale> wuttf: Monad is just a particular "shape" that many library APIs fall into in functional programming.
16:10:30 <nand`> (doesn't APL use the term monads and dyads for functions of arity 1/2)?
16:10:47 <nand`> Cale: oh, another analogy! monads are just like shapes :))
16:10:47 <c_wraith> wuttf: Monads are a pattern for composing functions that operate on... umm...  decorated... things...  It's such an abstract pattern, it's hard to put in english without just giving a precise mathematical definition.
16:10:49 <wuttf> nand`: thats the only interpretation i know and i am just trying to find some solid ground :D
16:10:50 <danil> Cale: I'm pretty sketched out by how big the full types are, but I do see the allure of putting the effect information "in" the arrows instead of to the right
16:10:51 <Cale> wuttf: It's like a design pattern that we've defined as something in the language so that it can stop being a design pattern.
16:10:55 <nand`> wuttf: forget that
16:10:59 <Cale> wuttf: A specific one:
16:11:01 <aristid> nand`: i think it does, is that an invalid way to use these words?
16:11:10 <nand`> aristid: I don't think so
16:11:17 <aristid> nand`: i thought math words can often be heavily overloaded
16:11:18 <d-best> how do I create a 2 dimensional array with array?
16:11:28 <nand`> ‘dyadic functions’ are functions with arity 2
16:11:32 <Cale> A monad is a type constructor M together with operations return :: a -> M a, and (>>=) :: M a -> (a -> M b) -> M b, satisfying some conditions.
16:11:42 <slack1256> wuttf: to see "why do you need a monad " read the original paper (it isn't scary) it tell you why would you use one when there are easier options :-)
16:11:43 <danil> d-best: you use (Int, Int) as the index type
16:11:46 <nand`> it wouldn't surprise me to see ‘monadic function’ for arity 1. The term just means something completely different in Haskell, that's why I said to forget about it
16:11:48 <slack1256> @src wdl87
16:11:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:11:59 <Cale> and lots of libraries provide a type constructor M like this, with functions like return and (>>=) that fit that pattern
16:12:00 <d-best> ah
16:12:16 * hackagebot aws 0.6.2 - Amazon Web Services (AWS) for Haskell (AristidBreitkreuz)
16:12:18 <MostAwesomeDude> @where wdl87
16:12:18 <lambdabot> I know nothing about wdl87.
16:12:18 * hackagebot cabal-meta 0.2.3.2 - build multiple packages at once (GregWeber)
16:12:25 <Cale> wuttf: so we give that pattern a name, and allow code to be written which works with anything that's a Monad
16:12:37 <Cale> wuttf: now, how to interpret these operations?
16:12:43 <wuttf> some mins guys im reading your lines
16:12:53 <Cale> wuttf: let me know when you're ready :)
16:13:23 <Cale> I should probably take this to #haskell-overflow or something, so we don't flood out the rest of the discussions, and it's easier to follow
16:13:35 <slack1256> wuttf: homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
16:13:55 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
16:14:28 <Cale> ^^ this explains the purpose of monads
16:14:32 <nand`> a motivating reason to look for monads (perhaps more often than other patterns) is so you get do notation for free
16:14:38 <wuttf> bookmarked both of those
16:14:46 <Cale> Like any abstraction we make, a large part of it is saving on code
16:14:59 <Cale> There are functions which operate with any library which happens to define a monad
16:15:10 <wuttf> but i think its start to collapse into the bed its 1:15 here
16:15:20 <Cale> and by defining an instance of this type class, you get a whole bunch of functionality for free
16:15:34 <wuttf> its time to * not start
16:15:37 <wuttf> omg i cant even speak
16:15:44 <wuttf> thats what you get when you code 20 hours straight
16:16:02 <nand`> I perpetually code into the english language, it's not that hard :P
16:16:11 <Cale> So maybe you're writing a parsing library, and you discover that your parsers have a return and bind operation, and then you get things like for-each loops and concatenation of parsers for free :)
16:16:11 <Veinor> the best way to understand monads is to write a lot of haskell code imo
16:16:14 <k0001> It seems I forgot that musical instruments existed, but then I recall I have a bass back home, and I was shocked.
16:16:17 <Veinor> and then you'll notice that you keep using them!
16:17:23 <wuttf> yes exhaustion is like some good weed, makes you pseudohallucinate and sleep
16:17:59 <slack1256> Veinor: I once met someone who started writing haskell code avoiding monad trying to use CallCC á la scheme. A month after I told him that ConT was a monad he understood them
16:18:12 <slack1256> Veinor: Is a good way, not for everybody though
16:18:15 <Cale> wuttf: Oh, here's another little quick thing if you want to understand just how IO works in Haskell (rather than the whole monadic abstraction thing)
16:18:24 <samnardoni> is   do { foo <- bar; baz foo }   always equal to   bar >>= baz    ?
16:18:26 <wuttf> Cale: im all ears
16:18:29 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
16:18:47 <Veinor> samnardoni: yes.
16:18:49 <danil> samnardoni: yes, that's exactly what the do notation means
16:18:50 <applicative> samnardoni: yes
16:18:56 <Veinor> they're syntactically equivalent, even
16:19:16 <applicative> samnardoni: or maybe  bar >>= \foo-> baz foo
16:19:18 <mauke> no, syntactically it's bar >>= \foo -> baz foo
16:19:26 <Veinor> well... yes
16:19:45 <scry`> Cale: can you explain the >>= operator in this from yesterday
16:19:58 <scry`> > fix ((0:) . drop 1 . (>>= \n -> [n,n+1]))
16:19:59 <Eduard_Munteanu> @undo do { foo <- bar; baz foo }
16:20:00 <lambdabot> bar >>= \ foo -> baz foo
16:20:00 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
16:20:14 <Cale> scry`: In the list monad, xs >>= f is the same thing as  concat (map f xs)
16:20:14 <applicative> samnardoni: with the lambda you can see that desugaring is a pretty superficial flipping around, basically
16:20:28 <samnardoni> i seem to get errors when changing from do{} to >>=
16:20:43 <samnardoni> expected type ... actual type ... errors
16:20:43 <Cale> scry`: So this will take a list, and map (\n -> [n,n+1]) over it, and then concatenate the results
16:21:06 <scry`> > concat [1,2,3,4]
16:21:07 <lambdabot>   No instance for (GHC.Num.Num [a])
16:21:07 <lambdabot>    arising from a use of `e_11234' at <in...
16:21:08 <applicative> samnardoni: if you paste on on hpaste.org our panel of experts will diagnose it
16:21:14 <Cale> > concat [[1,2],[3,4],[5,6]]
16:21:16 <lambdabot>   [1,2,3,4,5,6]
16:21:25 <scry`> ahh, flatten?
16:21:31 <Cale> yes
16:21:34 <Eduard_Munteanu> Also, x >>= f = join (fmap f x)
16:21:45 * nand` .oO ( “... our panel of trained monkeys will diagnose it” )
16:21:56 <applicative> like nand` says
16:22:11 <danil> > concat [[[1], [2]], [[3], [4]]] -- scry`: flatten one level
16:22:12 <lambdabot>   [[1],[2],[3],[4]]
16:22:23 <Cale> > map (\n -> [n,n+1]) [10,20,30,40]
16:22:24 <lambdabot>   [[10,11],[20,21],[30,31],[40,41]]
16:22:29 <Cale> > concat (map (\n -> [n,n+1]) [10,20,30,40])
16:22:30 <lambdabot>   [10,11,20,21,30,31,40,41]
16:22:39 <Cale> > [10,20,30,40] >>= \n -> [n,n+1]
16:22:40 <lambdabot>   [10,11,20,21,30,31,40,41]
16:22:52 <Cale> This is also rather like:
16:23:05 <Cale> > [k | n <- [10,20,30,40], k <- [n,n+1]]
16:23:07 <lambdabot>   [10,11,20,21,30,31,40,41]
16:23:16 <Cale> and this is not a coincidence
16:23:32 <Cale> The monad instance for lists is the heart of list comprehensions
16:23:43 <scry`> right! it's all coming together now
16:23:54 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
16:23:56 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
16:24:11 <Cale> > [(x,y,z) | x <- [1,2,3], y <- [4,5], z <- [6,7,8]]
16:24:12 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
16:24:25 <wuttf> thank you for all your help
16:24:30 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; guard (even (x + y + z)); return (x,y,z)
16:24:31 <lambdabot>   [(1,4,7),(1,5,6),(1,5,8),(2,4,6),(2,4,8),(2,5,7),(3,4,7),(3,5,6),(3,5,8)]
16:24:37 <Cale> > [(x,y,z) | x <- [1,2,3], y <- [4,5], z <- [6,7,8], even (x + y + z)]
16:24:38 <lambdabot>   [(1,4,7),(1,5,6),(1,5,8),(2,4,6),(2,4,8),(2,5,7),(3,4,7),(3,5,6),(3,5,8)]
16:24:42 <wuttf> gtg sleep now
16:24:47 <Cale> wuttf: cheers!
16:24:47 <wuttf> batteries are low
16:24:54 <hpaste> “Sam Nardoni” pasted “Why doesn't >>= work?” at http://hpaste.org/72751
16:25:00 <wuttf> Cale: thank you again, cheers.
16:25:03 <Cale> wuttf: Feel free to return and ask questions any time
16:25:09 <nand`> (in fact, list comprehensions can be generalized to monad comprehensions)
16:25:17 <samnardoni> http://hpaste.org/72751
16:25:19 <nand`> > [ x+y | x <- Just 3, y <- Nothing ]
16:25:20 <lambdabot>   Couldn't match expected type `[t]'
16:25:20 <lambdabot>         against inferred type `Data.Mayb...
16:25:22 <nand`> oh
16:25:28 <nand`> lambdabot doesn't have -XMonadComprehensions enabled
16:25:38 <d-best> wow porting that was easy, significantly less code using array :)
16:25:38 <Cale> It doesn't even have a new enough GHC
16:25:44 <samnardoni> if I change line 16-17 to the line 18 commented out, it fails (http://hpaste.org/72751)
16:26:11 <Cale> It's still back on 6.12.3
16:26:28 <d-best> the code isn't faster though, it seems even slower :|
16:26:42 <samnardoni> (I'm using conduits, by the way, and I don't _really_ know what I'm doing)
16:26:51 <Cale> samnardoni: It might help people if you provided the error message
16:26:54 <danil> samnardoni: >>= and $$+- can't cross over that way
16:27:01 <Cale> Oh, okay :)
16:27:04 <nand`> samnardoni: because in line 18 the result of ‘http request manager >>= responseBody’ lives in the IO monad; which can't be used by $$+-
16:27:23 <nand`> you would have to write something like http request manager >>= ($$+- sinkImageSize)
16:27:32 <nand`> no, not quite
16:27:38 <samnardoni> ah right, okay
16:27:40 <nand`> you would have to write something like http request manager >>= ($$+- sinkImageSize) . responseBody -- might do it
16:27:48 <samnardoni> i'll give it a go
16:27:59 <nand`> at any rate, your original version is clearer
16:28:05 <nand`> I would stick with that
16:28:45 <samnardoni> nand`: that worked :) thanks
16:29:06 <samnardoni> but I agree that the first version is clearer
16:29:15 <nand`> note that what I wrote is basically (\foo -> foo $$+- sinkImageSize) . responseBody
16:29:29 <nand`> which is basically \foo -> responseBody foo $$+- sinkImageSize
16:29:40 <nand`> it's just a point-free version of what the do notation expands to either way
16:29:47 <samnardoni> ah okay :)
16:29:54 <samnardoni> thanks guys and nand` :)
16:30:03 <nand`> @. pl undo do { res <- http request manager; responseBody res $$+- sinkImageSize }
16:30:03 <lambdabot> ($$+- sinkImageSize) . responseBody =<< http request manager
16:30:06 <nand`> cute
16:30:26 <nand`> any reason why @pl prefers =<< over >>=
16:30:44 <nand`> oh, so the composition order fits with (.) ?
16:31:17 <applicative> d-best that was.  It is true that you are depriving yourself of the insane optimizations ghc has for lists by using arrays, but I wonder if there is some other problem.
16:35:39 <danil> d-best: are you repeatedly updating each part of the array one element at a time?  There are a lot of useful functions in the Array module that work in one pass.  It's possible that copying an array takes longer than copying a list (on average you can reuse half of the old list), so the array version might be slower if the reason the list code was slow was lots of copying.
16:38:11 <Cale> If you're doing lots of updating, Data.Map might be better for you
16:38:42 <Cale> (or just rethinking things a bit to operate more uniformly, if possible)
16:39:04 <hpaste> d-snp pasted “Slow threatMap” at http://hpaste.org/72752
16:39:40 <d-best> so this is the problematic code
16:39:55 <d-best> the threatMap function is slow, I need to run it for every position on the board
16:40:30 <d-best> and it itself does 12 array updates per position on the board
16:40:35 <d-best> and 12 reads
16:40:51 <d-best> so that's 12 * 12 * 19 * 19 * 19 * 19 operations..
16:41:19 <d-best> that's 18 million.. I can see why its slow :P
16:41:24 <d-best> I need to make a better algorithm..
16:42:23 <d-best> the array version takes 30 seconds, the list version about 3-5
16:43:33 <d-snp> woopsy
16:45:25 <danil> d-best: arrays work well when you can update the whole thing in parallel rather than one entry at a time.  If you can't phrase your algorithm that way, maybe Data.Map would be better.
16:46:48 <d-snp> why would a data.map be better then?
16:47:13 <d-snp> isn't data.map only better for when the array is sparse?
16:47:22 <d-snp> this array is as dense as can be
16:47:37 <danil> to update a member of a map you only need to copy the (logarithmically long) path from the root to that node
16:52:34 <danil> in effect the array version has O(1) reads and O(n) writes (but allows you to write to as many locations as you want for that cost), while the map has O(log n) reads and writes
16:53:16 <d-snp> the matrix has O(n) writeS?
16:53:22 <d-snp> ehh array?
16:53:29 <d-snp> ohhh
16:53:34 <danil> it has to copy the whole thing, it's immutable
16:53:48 <d-snp> alright
16:54:22 <d-snp> I get why the list of lists is faster now
16:55:46 <danil> yeah, the list of lists is about O(sqrt n) for both reads and writes, since you only have to traverse/replace part of the outer list and part of one of the inner lists
16:56:52 <d-snp> the list of lists implementation takes 12 seconds
16:58:42 <Nereid> ST gives you mutable arrays
17:01:33 <Nereid> http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-MArray.html
17:01:33 <Nereid> http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-ST.html
17:03:47 <d-snp> wtf, it just GSOD'ed my poor laptop
17:03:58 <mauke> this paper is trolling me
17:04:08 <d-snp> damn you osx and your poor resource management
17:04:45 <mauke> it appears to be citing itself
17:04:53 <d-snp> :D
17:05:00 <Ralith> haha
17:05:08 <d-snp> that's way of filling your quotum
17:06:57 <ozataman_> what's a good way to trap SIGHUP?
17:07:11 <mauke> it's actually citing a previous version of itself
17:07:16 <d-snp> :P
17:07:39 <mauke> same author/title, obviously
17:07:47 <scry`> is there a better way to do last . takeWhile p ?
17:08:07 <shachaf> What's wrong with last . takeWhile p?
17:08:16 <shachaf> (Other than being partial.)
17:08:17 <scry`> or rather, last.takeWhile.not p
17:08:23 <Nereid> ozataman_: System.Posix.Signals ?
17:08:33 <shachaf> last.takeWhile.not p doesn't typecheck.
17:08:35 <scry`> well, nothing now i think about it
17:08:43 <Nereid> lol
17:09:00 <ozataman_> Nereid: ah thanks, I missed the bottom part where installHandler is
17:09:22 <Nereid> (and I hope you meant last . takeWhile (not . p)
17:09:44 <d-snp> wow, my go bot is actually not making total bullshit moves, even if it takes 12 seconds to think about it :D
17:09:55 <d-snp> we're fighting about corners..
17:10:06 <Nereid> d-snp: mutable arrays!
17:10:43 <scry`> what i mean is last $ takeWhile (not . (== 5)) [1,2,3,4,5,6]
17:10:44 <d-snp> oh yeah you told me about that, I'll look into state monad :D
17:10:47 <d-snp> thanks
17:10:57 <scry`> get the first thing satisfying the predicate
17:11:04 <scry`> that's the best way to do it?
17:11:06 <Nereid> d-old: ST, not State.
17:11:09 <Nereid> d-snp: ;)
17:11:12 <d-snp> oh :P
17:11:14 <luite> ooh finally some go bot i can win againt
17:11:16 <luite> +s
17:11:18 <danil> scry`: head . filter p
17:11:39 <Nereid> danil: surely that does something different.
17:11:45 <shachaf> Are you sure you don't mean dropWhile?
17:11:58 <teneen> How can I convert an ascii string to [Word8]?
17:12:03 <d-snp> luite: if I can get it to respond in under 3s I'll put it online for you you to play :P
17:12:23 <Nereid> teneen: first figure out how to convert a Char into a Word8
17:12:47 <scry`> nope that looks good
17:12:50 <d-snp> or you can download it here and run it locally: https://github.com/d-snp/Ergo
17:12:57 <shachaf> teneen: What's an ASCII string?
17:13:04 <Nereid> I was assuming Char.
17:13:11 <Nereid> but Char can contain non-ASCII things.
17:13:23 <scry`> thanks
17:13:42 <teneen> shachaf: A string which know that all it's characters are ascii characters
17:13:49 <shachaf> [Char] isn't a type that means "ASCII string".
17:13:55 <shachaf> Oh, by string you mean "String"?
17:13:55 <danil> scry`: the safe version is actually Data.List.find
17:14:20 <shachaf> teneen: Well then, what Nereid said.
17:14:26 <Nereid> @type fromIntegral . ord
17:14:27 <lambdabot> forall b. (Num b) => Char -> b
17:14:57 <scry`> what if i want the index of that element?
17:15:00 <teneen> Nereid: Is there something standar on how to convert a Char to a Word8?
17:15:09 <scry`> zip it with [1..]?
17:15:32 <shachaf> teneen: What, a function :: Char -> Maybe Word8?
17:15:49 <Ralith> @djinn Char -> Word8
17:15:50 <lambdabot> Error: Undefined type Char
17:15:50 <teneen> shacaf: yes
17:15:51 <Ralith> aw
17:16:06 <Nereid> teneen: I just wrote one
17:16:13 <weexplat> > fromIntegral . org $ 'a' :: Word8
17:16:15 <lambdabot>   Not in scope: `org'
17:16:20 <weexplat> > fromIntegral . ord $ 'a' :: Word8
17:16:22 <lambdabot>   97
17:16:29 <shachaf> @djinn-add data Char = Char'a' | Char'b'
17:16:46 <shachaf> @djinn-add data Word8 = Word8_0 | Word8_1
17:16:47 <lambdabot> Cannot parse command
17:17:00 <shachaf> Whatever. The point is not to use Djinn for that sort of thing.
17:17:12 <Nereid> djinn is not hoogle.
17:17:20 <MostAwesomeDude> @hoogle Char -> Word8
17:17:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:17:21 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
17:17:21 <lambdabot> Prelude error :: [Char] -> a
17:17:26 * hackagebot kit 0.7.9 - A dependency manager for Xcode (Objective-C) projects (NickPartridge)
17:17:29 <MostAwesomeDude> ...Thank you, Hoogle.
17:17:32 <weexplat> > fromIntegral . ord $ '❂ ' :: Word8
17:17:33 <Nereid> hoogle doesn't help either. :V
17:17:34 <lambdabot>   <no location info>:
17:17:34 <lambdabot>      lexical error in string/character literal at chara...
17:17:36 <Ralith> right, I was just hoping for an amusing example of why you type signatures alone don't specify the function you need
17:17:48 <weexplat> lambdabot: fail
17:17:52 <Ralith> i.e. what teneen probably actually wants is an ASCII encoder
17:17:56 <mauke> weexplat: fail
17:17:58 <Nereid> ascii package has Data.Ascii.ascii :: Char -> Word8
17:18:10 <Ralith> not just a "function that converts"
17:18:10 <shachaf> Ralith: > fromIntegral . ord $ '❂' :: Word8
17:18:14 <MostAwesomeDude> TBH I use toEnum . fromEnum when I need this kind of thing.
17:18:15 <gatlin> I'm trying to install the orc package via cabal. Cabal informs me that it'll have to reinstall a few packages (process and stm are examples) even though they're within the version requirements of the package. —force-reinstalls has exit errors. I'm lost
17:18:16 <shachaf> > fromIntegral . ord $ '❂' :: Word8
17:18:19 <shachaf> Ralith: Right.
17:18:19 <lambdabot>   66
17:18:21 <Nereid> which is defined as fromIntegral . ord
17:18:22 <Nereid> heh
17:18:24 <MostAwesomeDude> But there's probably something better.
17:18:28 <shachaf> Ralith: charToWord8 _ = 0
17:18:42 <Ralith> shachaf: it would've been funnier if djinn said it! :P
17:18:57 <teneen> Hackage says the ascii package is obsolete!
17:19:16 <weexplat> weechat: fail
17:19:40 <weexplat> (or was it gnome-terminal?  :()
17:20:13 <nand`> presumably missing fonts
17:20:31 <nand`> oh, I jumped to conclusions about what your issue was
17:20:35 <nand`> nvm me
17:20:42 <weexplat> i guess it was probably gnome-terminal displaying the wrong selection width
17:21:35 <teneen> Is it a bad idea to use a package marked as obsolete?
17:21:41 <weexplat> > fromIntegral . ord $ '☠' :: Word8
17:21:44 <lambdabot>   32
17:22:36 <edwardk> slowly working up quickchecks for lens
17:23:49 <weexplat> edwardk: maybe you should use quickspec and sanity-check the specs instead of writing them by hand
17:24:03 <nand`> quickspec?
17:24:17 <nand`> edwardk: you testing stuff like set l a . set l b = set l a ?
17:24:22 <edwardk> quickcheck is straightforward enough and the laws involve types i can't use directly
17:24:22 <edwardk> yeah
17:24:38 <weexplat> this sounds like a good sort of package for that approach, provided quickspec doesn't explode
17:25:37 <edwardk> i welcome a patch that contributes a quickspec test suite ;)
17:26:01 <edwardk> i'm using doctest for some small examples in-line
17:26:03 <Nereid> @type fromIntegral . fromEnum
17:26:04 <lambdabot> forall b a. (Num b, Enum a) => a -> b
17:26:16 <Nereid> > fromIntegral . fromEnum $ 'a' :: Word8
17:26:19 <lambdabot>   97
17:26:32 <weexplat> nand`: quickspec is an addon to quickcheck that generates the test cases for you (yes, really)
17:27:48 <weexplat> > map (toEnum . fromEnum) $ ['a', '!', '☠'] :: [Word8]
17:27:50 <lambdabot>   [97,33,*Exception: Enum.toEnum{Word8}: tag (9760) is outside of bounds (0,2...
17:28:10 <scry`> is there a way to stop imports from cluttering the GHCi prompt e.g. '*Main Data.Function Data.Bits Data.List> '
17:28:22 <Nereid> :set prompt "> "
17:28:31 <MostAwesomeDude> > map (toEnum.fromEnum) "a!?" :: [Word8]
17:28:33 <lambdabot>   [97,33,63]
17:28:43 <nand`> weexplat: but.. doesn't quickcheck already generate test cases for me?
17:29:12 <Nereid> > map (fromIntegral . fromEnum) &&& map (fromIntegral . fromEnum) $ "a!☠" :: ([Word8], [Integer])
17:29:14 <lambdabot>   ([97,33,32],[97,33,9760])
17:29:19 <scry`> very nice
17:29:19 <nand`> or do you mean it gives me concrete values and lets me confirm their correct result and add them to a list of unit tests?
17:29:49 <nand`> Nereid: unfortunately, doesn't work for multi-line inputs
17:29:54 <nand`> at least not without GHCi patches
17:30:03 <nand`> I remember somebody writing a patch to this effect not too long ago
17:30:06 <weexplat> nand`: quickcheck generates ground test cases by sampling a distribution of possible test cases supplied by you.  quickspec generates the distribution.
17:31:03 <Nereid> multi-line inputs??
17:31:13 <nand`> quickcheck samples test cases supplied by me?
17:31:30 <nand`> I thought quickcheck tests properties and generates its own test cases
17:32:12 <Nereid> nand`: it generates them via the Arbitrary typeclass, which you can supply instances for
17:32:24 <nand`> oh, that; yes
17:32:29 <nand`> (I've never written an arbitrary)
17:32:39 <weexplat> nand`: what you hand quickcheck resembles a property, but strictly speaking it's a distribution over specific cases that are implied by the property
17:33:23 <weexplat> even more strictly speaking it's a sampler for a distribution over etc
17:34:15 <parcs`> bah, i'm getting infinitely repeating data (bad) when i do 'forever $ atomically (many (readTQueue event_queue))' but when i recurse explicitly with 'atomically (tryReadTQueue event_queue)' i don't (good)
17:35:21 <nand`> Nereid: :{ :}
17:36:11 <Nereid> ooh, never knew about this
17:36:33 <nand`> I avoid it, due to aforementioned issues
17:36:37 <Nereid> heh
17:36:43 <nand`> weexplat: I don't understand any of those words :(
17:36:54 <nand`> well, mainly ‘sampler’ ‘distribution’
17:37:40 <nand`> I'll probably have to look at QuickSpec in action to figure out what it does
17:38:16 <danil> nand`: quickspec generates sample data in order to figure out what equations appear to hold between your functions
17:38:23 <weexplat> nand`: basically: you're not just telling quickcheck which abstract property to check instances of, you're also telling it stuff about how to generate instances to test, and that can affect how thoroughly the property actually gets tested
17:39:10 <weexplat> (and we're not even at the point of talking about what quickspec does, but danil seems to have a good take on it)
17:40:09 <danil> weexplat: I actually just skimmed the first 3 pages of the paper, I'd never heard of it before now.  I'm glad I sound like I know what I'm talking about though.
17:40:18 <danil> (it looks very cool)
17:40:28 <nand`> it does sound interesting
17:41:52 <weexplat> the idea is if you have a nice simple implementation of something you're pretty sure is right, you can ask quickspec to make you some properties and nail down what it does so you can then evolve it to be more complex in implementation without evolving it to be, well, wrong
17:43:39 <weexplat> likewise, if you think your code should obey some laws, but you expect there to be a lot of them, and you think the code is probably correct and you're not sure, you can have quickspec spit out testcases it thinks your code will pass and you can check if they look right or if there are any obviously missing
17:46:35 <Veinor> that's really neat
17:46:53 <weexplat> basically with quickcheck and quickspec you can do sort of a power-assisted version of the sort of exploration one normally does at a REPL
17:46:57 <k0001> reply 28 Justo hoy charlabamos del asunto con @manuelaristaran y llegamos a lo mismo. Eliminemos esa hostilidad, que vuelva el amor al software.
17:47:13 <danil> Disregarding how much easier it is to use, is it (for the first use case) any more robust than quickhecking that the reference implementation and the complicated one agree?
17:47:22 <k0001> (oops, wrong window, sorry)
17:49:25 <weexplat> danil: having the reference implementation's behaviour described by properties can make the testing more focused on edge cases where disagreement is likely to manifest, as well as making it easier to pinpoint where the problems are
17:51:43 <weexplat> also, if your requirements change as well as your implementation, it may be easier to maintain a suite of properties than a reference implementation in the long term
17:52:04 <shirt> donri: yeah
17:52:51 <danil> yeah, having the properties is definitely more useful to humans than having a pile of code
17:53:59 <weexplat> 'simple enough that it can't be wrong' is a much easier property to attain at a point in time than maintain over time
17:55:00 <AfC> Any idea what I need to install to satisfy
17:55:07 <AfC> Not in scope: type constructor or class `SafeHaskellMode'
17:55:09 <AfC> ?
17:55:51 <mauke> AfC: what's the context?
18:00:28 <AfC> mauke: I'm trying to build Haddock
18:00:50 <AfC> (used cabal configure && cabal build)
18:01:01 <AfC> mauke: [I should have said what I was building, sorry]
18:04:19 <danil> that's defined inside ghc; you probably have some kind of version issue
18:05:31 <AfC> danil: hm. I took it from git, the ghc-7.4.2-release tag. Hm.
18:06:25 <AfC> Bah humbug
18:06:43 <AfC> So I just rolled back to ghc-7.4.1-release and it builds.
18:07:11 <AfC> that's really annoying. I'm not used to trying to hack on projects whose head or most recent release you can't even build.
18:09:06 <AfC> Is haddock actually supposed to be built inside a GHC tree or something? The Makefile it comes seems to assume that.
18:10:12 <nand`> that surprises me, haddock builds fine here (GHC 7.4.2; haddock 2.10.0-r2)
18:10:40 <AfC> nand`: so, I didn't realize it'd make a difference, but yeah, I have GHC 7.4.1 here
18:10:56 <nand`> what ver of haddock are you building?
18:11:33 <AfC> well, at first I tried to build head, but I looked at the revisions and realized there was all sorts of ghc-next stuff. So then I pulled back to the ghc-7.4.2-release tag, thinking that would Just Work™
18:11:42 <AfC> seeing as how it's a release, but no
18:12:37 <AfC> nand`: I'm having a go adding another output formatter. At least I can build now. Thanks everyone.
18:12:50 <nand`> and thus, my question remains unanswered :(
18:12:58 <AfC> er?
18:13:04 <nand`> or maybe I'm misunderstanding
18:13:12 <AfC> nand`: I said already. I'm trying to build from git
18:13:15 <nand`> oh
18:13:19 <nand`> let me try
18:14:04 <AfC> nand`: and I had to roll it back from head to tag:ghc-7.4.2-release to (just now) tag:ghc-7.4.1-release before it would work.
18:14:06 <nand`> haddock-9999 requires ghc-9999 for me
18:14:19 <AfC> didn't occur to me that I'd have to match the haddock version to the GHC version
18:15:05 <nand`> but haddock-2.10.0 should build using 7.4.2
18:15:08 <nand`> yeah
18:15:10 <mm_freak_> why would you build haddock from git?
18:15:13 <nand`> I see what you mean now
18:15:29 <nand`> AfC: you're talking about tags in the haddock git repo?
18:15:37 <AfC> maybe I picked the wrong tag. Should have gone with tag:2_10_0 instead, perhaps
18:15:45 <AfC> nand`: yes
18:15:51 <nand`> I thought you were talking about rolling back ghc itself
18:15:53 <nand`> thus my confusion
18:15:55 <AfC> mm_freak_: I want to hack on it, that's why
18:15:56 <mm_freak_> when i install GHC through my package manager i get haddock, too
18:16:00 <mm_freak_> ah, i see
18:16:02 <nand`> yeah, apparently git haddock requires git ghc
18:16:15 <nand`> this is why you use a package manager capable of telling you these things :)
18:16:24 <AfC> {grr}
18:16:27 <AfC> yes, no shit
18:16:49 <AfC> I said I was trying to hack on it, and for that you kinda need to work from source, y'know?
18:17:01 <nand`> I don't see a contradiction there :P
18:17:07 <mm_freak_> what does the cabal file tell you?  it gives an explicit GHC dependency
18:17:13 <mm_freak_> (as well as a cabal dependency)
18:17:26 <AfC> mm_freak_: well, that was the part that mislead me;
18:17:34 <AfC> mm_freak_: (I think); cabal configure passed
18:17:46 <mm_freak_> AfC: i mean, look into the cabal file of haddock
18:17:54 <AfC> mm_freak_: that's what I'm talking about
18:18:34 <AfC> says ghc >= 7.4 && < 7.8
18:18:43 <AfC> has a bunch of
18:18:49 <AfC> if flag(in-ghc-tree)
18:18:51 <AfC> conditionals
18:18:52 <mm_freak_> well, in that case i'd recommend visiting #ghc or the GHC mailing list and pasting the error message
18:19:15 <AfC> mm_freak_: ok, will do
18:20:01 <mm_freak_> in this channel GHC-related issues can be overlooked, because of high traffic
18:20:30 <mm_freak_> and i'd expect a large intersection between the GHC and haddock developers =)
18:20:50 <AfC> mm_freak_: sure. I wouldn't have identified this as a GHC issue per se, so thanks for confirming I should wander over that way. Cheers
18:23:43 <nand`> (maybe the .cabal is just bugged, and it really needs ghc >=7.5 or so?)
18:24:05 <AfC> nand`: if that's their intent. I'll ask them.
18:24:19 <nand`> I imagine there's a reason the gentoo-haskell maintainers made it depend on live ghc
18:24:28 <nand`> eg. it being incompatible with everything else
18:24:34 <nand`> yeah, they should be better at clearing up this mystery
18:31:58 <JSchwag> wow haskell is pretty fun to learn
18:32:02 <JSchwag> i must say
18:32:37 <sm> yup!
18:32:44 <JSchwag> it really breaks you out of the box
18:32:55 <JSchwag> sort to speak
18:33:03 <JSchwag> sorta speak
18:33:04 <JSchwag> lol
18:33:12 <aristid> JSchwag: it's like eating so much that you explode the box!
18:34:00 <JSchwag> yea and then it turns into an even bigger box
18:34:08 <JSchwag> which you're then stuck in again
18:34:47 <aristid> JSchwag: but then you need cathegory theory to the rescue. which is to mean: you're REALLY stuck
18:35:30 <JSchwag> googling "cathegory theory", please wait. 30% done
18:35:36 <JSchwag> 60%
18:35:39 <JSchwag> 100%
18:35:45 <JSchwag> agreed
18:36:51 <Nereid> what's wrong with category theory
18:36:57 <aristid> nothing :)
18:37:19 <mm_freak_> it's the outermost box, so you're stuck forever there =)
18:37:36 * hackagebot cse-ghc-plugin 0.1.1 - Compiler plugin for common subexpression elimination (AustinSeipp)
18:37:55 <mm_freak_> although from a different viewpoint (one that i understand much better) type theory is the outermost box
18:38:58 <mm_freak_> it basically tells you that haskell sucks, but it does that with elegance =)
18:39:42 <JSchwag> dont talk about haskell that way
18:40:38 <mm_freak_> JSchwag: haskell has the potential to ruin you for most other programming languages…  but there are languages with the potential to ruin you for haskell
18:40:50 <mm_freak_> it's a great language, but not the top of the evolutionary ladder
18:41:04 <Nereid> I wish haskell had dependent types.
18:41:08 <shachaf> mm_freak_: There even exist two alnguages X and Y such that X can ruin you for Y and Y can ruin you for X.
18:41:10 <roconnor> Epigram is at the top of the ladder
18:41:11 <aristid> mm_freak_: is singleton types a sign of somebody who's been ruined for haskell? :)
18:41:14 <roconnor> well, Epigram 2
18:41:33 <mm_freak_> aristid: definitely =)
18:42:08 <mm_freak_> roconnor: i'd expect agda to be higher and yet nowhere near the top
18:42:26 <mm_freak_> don't measure the quality of a language solely by the power of its type system
18:42:30 <roconnor> does agda have surjective pairing?
18:42:44 <mm_freak_> roconnor: what exactly is that?
18:43:47 <roconnor> the eta rule for pairs, that (fst x, snd x) = x
18:43:54 <mm_freak_> shachaf: do you have two particular languages in mind?
18:43:56 <Saizan> roconnor: yep
18:44:05 <shachaf> mm_freak_: NO, I don't have a constructive proof.
18:44:18 <mm_freak_> hehe ok
18:44:25 <shachaf> s/O/o/
18:44:36 <mm_freak_> roconnor: i doubt that you need this rule explicitly in agda
18:44:37 <aristid> shachaf: it works with O
18:44:53 <shachaf> mm_freak_: (There's a strange _ sticking from your nick.)
18:44:54 <roconnor> mm_freak_: by = I mean convertable
18:45:15 <mm_freak_> roconnor: in what sense?  for type checking?
18:45:19 <ion> shachaf: (There’s a strange hachaf sticking from your nick.)
18:45:29 <aristid> shachaf: how about perl and pythong?
18:45:37 <roconnor> mm_freak_: for type checking or anywhere else you use convertability
18:46:14 <mm_freak_> roconnor: type checking is the only place where i see a use case…  and yes, any language based on typed lambda calculus does that
18:46:19 <Saizan> you get that eta rule for everything you define as a record
18:46:25 <shachaf> Unfortunately "s" is taken.
18:46:35 <aristid> shachaf: how surprising
18:47:00 <roconnor> Saizan: I'm sort of assuming so.
18:47:00 <mm_freak_> roconnor: type checking involves comparing normal forms of expressions and (fst x, snd x) has the same normal form as x
18:47:17 <mm_freak_> (assuming that we mean the same by 'fst' and 'snd')
18:47:27 <mm_freak_> (and _,_)
18:47:31 <roconnor> mm_freak_: (fst x, snd x) is the eta-long normal form for a variable x where x is a pair.
18:47:33 <Saizan> mm_freak_: even Agda doesn't have that rule you define pair types with "data" instead of record
18:47:37 * hackagebot unroll-ghc-plugin 0.1 - Compiler plugin for loop unrolling (AustinSeipp)
18:47:39 * hackagebot strict-ghc-plugin 0.1.1 - Compiler plugin for making Haskell strict (AustinSeipp)
18:47:41 * hackagebot unroll-ghc-plugin 0.1.1 - Compiler plugin for loop unrolling (AustinSeipp)
18:47:51 <mm_freak_> Saizan: that's what i'm saying
18:48:20 <mm_freak_> that "rule" comes naturally with the way types are defined and checked in agda
18:48:30 <Saizan> mm_freak_: it's not enough to be based on LC to have it
18:49:22 <mm_freak_> Saizan: true, but i know no example of a dependently typed language that doesn't compare normal forms to check types
18:49:44 <Saizan> mm_freak_: that's weird, since it got introduced not too many versions ago, actually
18:50:03 <mm_freak_> Saizan: in agda?
18:50:26 <Saizan> mm_freak_: yeah
18:50:51 <Saizan> mm_freak_: comparing normal form is the norm, but (fst x , snd x) being the normal form of x isn't
18:51:32 <mm_freak_> Saizan: given fst (x , _) = x and snd (_ , y) = y?
18:52:20 <mm_freak_> Saizan: oh, you may have misunderstood me
18:53:04 <mm_freak_> to check that x : X is of type Y, you compare the normal forms of X and Y
18:53:08 <roconnor> the lack of surjective pairing in Coq kinda annoys me.
18:53:27 <roconnor> Reductiong let (a,b) = z in foo a b always gets stuck when z is a variable.
18:53:45 <Saizan> mm_freak_: yeah, i know
18:53:48 <roconnor> And I'm always rewriting this has (foo (fst a) (snd b)) by hand
18:53:52 <roconnor> *as
18:54:07 <roconnor> It is much more annoying when z is a dependent record
18:54:12 <aristid> foo (fst z) (snd z) you mean?
18:54:17 <roconnor> aristid: yes sorry
18:54:27 <dolio> Eta long normal forms are less common than the reverse, I think.
18:54:39 <mm_freak_> Saizan: ok, now you may need to prove that (fst x , snd x) = x, if that ever occurs on the type level…  isn't that again just comparing normal forms?
18:54:39 <dolio> You'll find some papers referring to them as 'non-computational' even.
18:54:48 <mm_freak_> and if the normal forms are different, then it's a type error
18:55:02 <roconnor> I've recently become a fan of eta-long normal forms
18:55:18 <aristid> which one is the eta-long one?
18:55:28 <roconnor> However the fact that they appear to be undecidable for Void types and maybe sum types bothers me greatly :/
18:56:01 <dolio> I thought the point of eta expansion was that that isn't a problem.
18:56:21 <Saizan> mm_freak_: i know
18:56:23 <roconnor> dolio: eta-long forms for functions and records is fine AFAIU
18:56:47 <Saizan> mm_freak_: well, that's not entirely correct
18:56:54 <hpaste> Mandarin pasted “Homemade sort” at http://hpaste.org/72754
18:56:58 <mm_freak_> Saizan: then again the rule that roconnor wants emerges naturally, doesn't it?
18:57:13 <Saizan> mm_freak_: you can prove that x == (fst x , snd x) in every language, when you take == to be the propositional equality
18:57:25 <Mandarin> I'm having trouble with a very basic sort function, it's in the paste: http://hpaste.org/72754
18:57:36 <Saizan> mm_freak_: where languages differ is whether x = (fst x , snd x) holds, when = is convertibility
18:57:39 * hackagebot rpc-framework 1.0.0.0 - a remote procedure call framework (MatthewMirman)
18:58:11 <dolio> roconnor: I thought I'd seen something that treated sums, too. But maybe not. The one paper that I can think of on the subject (The Virtues of Eta Expansion) doesn't have it now that I look.
18:58:28 <mm_freak_> Mandarin: first of all a small style note:  sort [x] = [x]
18:58:56 <mm_freak_> Mandarin: and you don't want to sort 'xs' and then append [x]
18:58:59 <Saizan> mm_freak_: and for convertibility the rule roconnor wants is entirely dependent on how your normalization works, and it's not natural at all if you are doing untyped normalization for example
18:59:03 <mm_freak_> you want to sort (xs ++ [x])
18:59:27 <roconnor> Saizan: oh ya, without typed directed normalization, eta would never work
18:59:32 <shachaf> Hah, that's an exciting new sorting algorithm.
18:59:35 <Mandarin> mm_freak_: thanks! You're a time- and life saver!
18:59:36 <mm_freak_> Saizan: but for the total agda?
18:59:38 <shachaf> I guess it's sort of a selection sort.
19:00:10 <mm_freak_> shachaf: it's interesting, but inefficient
19:00:20 <shachaf> mm_freak_: Sure.
19:00:50 <mm_freak_> actually it could be an efficient algorithm for Data.Sequence
19:00:56 <mm_freak_> but not for lists
19:00:56 <Saizan> mm_freak_: even for the total Agda if the procedure that's evaluating the terms doesn't take the type into consideration, which is the case of Coq
19:01:02 <dolio> roconnor: Type-directed normalization interferes with other stuff I'm interested in, too. Like erasure.
19:01:30 <dolio> But not having eta is probably worse than not doing fancy erasure.
19:01:44 <roconnor> dolio: you don't need to do type-directed normalization in the empty context.
19:01:58 <roconnor> there are no variables to make eta-long
19:02:10 <mm_freak_> Saizan: then i should ask:  what exactly is "convertibility"?
19:02:17 <dolio> This is erasure in non-empty contexts.
19:02:23 <roconnor> :O
19:02:51 <mm_freak_> because in a language with opaque functions i'd expect the notion of "convertibility" to be based on the equality of normal forms
19:03:04 <mm_freak_> or rather alpha-equivalence
19:04:15 <Saizan> mm_freak_: each language gets to decide which are its normal forms, that's most of the point
19:04:48 <hpaste> Mandarin pasted “Homemade sort (2)” at http://hpaste.org/72755
19:04:51 <Mandarin> Sorry for asking again, but I must have misunderstood your explanation. The problem is shown in the paste:
19:04:54 <mm_freak_> Saizan: would you mind giving an example?
19:05:08 <mm_freak_> Mandarin: no worries…  questions are always welcome here =)
19:05:38 <Saizan> mm_freak_: by convertibility we refer to the relation appearing in the conversion rule (e : X), X = Y |- e : Y
19:06:03 <mm_freak_> Mandarin: another pattern-matching hint:  sort (x1:x2:xs) = …
19:06:29 <dolio> roconnor: Basically, you can have modal quantifiers that track which things are parametrically polymorphic (unused outside of types), and do open erasure on such things. But if you do that, you might throw away something you need to figure out an eta rule.
19:06:40 <Saizan> mm_freak_: example of what?
19:06:43 <Mandarin> x1 :: a, x2 :: a, xs :: [a]?
19:06:56 <mm_freak_> Mandarin: also consider that your sorting algorithm needs to be run in multiple passes
19:07:09 <dolio> Agda does some of it.
19:07:23 <mm_freak_> Mandarin: consider [2, 3, 1]
19:07:24 <dolio> But not the good stuff, because of the eta problems.
19:07:41 <mm_freak_> Mandarin: that should result in [2, 1, 3]
19:07:56 <roconnor> mm_freak_: Having beta-short eta-long normal forms is still basing convertabiliity on normal forms.
19:08:01 <mm_freak_> Saizan: oh, i see now what you mean
19:08:29 <mm_freak_> Mandarin: and yes, the types are correct
19:09:33 <Mandarin> Why should [2, 3, 1] result in [2, 1, 3]?
19:09:53 <mm_freak_> Mandarin: by your definitions:  sort [2, 3, 1] = 2 : sort [3, 1] = 2 : sort [1, 3] = 2 : 1 : sort [3] = 2 : 1 : 3 : []
19:10:42 <Mandarin> mm_freak_: Didn't see that, thanks!
19:10:50 <mm_freak_> Mandarin: in other words the code is correct…  it just doesn't perform a full sort =)
19:10:51 <Mandarin> back to the drawing board
19:11:56 <dolio> Anyhow, eta is a little odd, because it's not something you would (or even could) do at runtime to drive computation.
19:12:06 <dolio> It's a typing-time only thing.
19:12:15 <mm_freak_> Mandarin: and as a side note pattern matching is /very/ powerful in haskell…  if you're ever thinking, "this should be possible", then it probably is possible =)
19:12:34 <dolio> But, I'm kind of on board with making the decidable equality intelligent.
19:12:39 * hackagebot shake-extras 0.1 - Extra utilities for shake build systems (AustinSeipp)
19:12:43 <dolio> Because it's really convenient.
19:13:07 <dolio> Conor wants to put stuff like 'map id => id' into Epigram if I'm not mistaken.
19:13:21 <Mandarin> mm_freak_: Sweet, that's actually why I've gotten so addicted to haskell. My mind can really express itself before I lose the thought. Quick, sleek and powerful solutions :)
19:13:35 <mm_freak_> =)
19:13:36 <Mandarin> mm_freak_: Except this time :P
19:14:06 <Mandarin> mm_freak_: recursion really messes with you if you've got a imperative background
19:14:37 <mm_freak_> Mandarin: thinking in terms of data and folds helps a lot
19:15:25 <Mandarin> I've heard many times, but what does thinking in data mean?
19:15:34 <dolio> Typical imperative teaching doesn't equip you to do recursion well. Which is probably why it's regarded as one of the hardest things there.
19:15:45 <mm_freak_> Mandarin: in other languages what is typically control in haskell it's typically data
19:15:45 <dolio> Because executing recursion (in general) is hard to do in your head.
19:15:50 <mm_freak_> you have lists instead of for loops
19:16:17 <mm_freak_> in fact in haskell there is really no difference between data and control
19:16:20 <dolio> Harder than executing loops.
19:16:45 <aristid> mm_freak_: there is, it changes the module names
19:16:46 <Twey> I don't really agree… it's just *different*.
19:17:13 <mm_freak_> really?  i always found recursion easier to follow than iteration…  i used recursion as a 12 year old in qbasic
19:17:24 <mm_freak_> aristid: hehe
19:17:36 <dolio> It's not harder to follow, necessarily.
19:17:44 <dolio> But executing it in your head is harder.
19:17:51 <Twey> In both loops and recursion, the trick is to look at what changes with a step, rather than trying to take it all in at once.  You just have to look at slightly different things to work that out for recursion vs. looping.
19:18:08 <dolio> Because you have to keep track of a stack of all state instead of just the current state in an iteration.
19:18:14 <mm_freak_> dolio: not really…  as Twey noted it's just different…  and when you're used to it it's actually easier to think in terms of composition and recursion
19:18:33 <mm_freak_> loops on the other hand don't compose, hence they get large and complicated quickly, thus much harder to follow
19:18:46 <dolio> No, you're talking about understanding recursion properly by considering appeal to solved subproblems.
19:18:48 <Twey> I remember that when I started programming loops confused me *terribly*, especially when doing things like nested loops.
19:18:58 <dolio> I'm talking about emulating a machine doing recursion in your head.
19:19:17 <dolio> Which is how you're typically taught to understand imperative code.
19:19:21 <Twey> Aye
19:19:25 <mm_freak_> dolio: i find lambda calculus reductions quite easy to imagine
19:19:29 <Twey> I can agree with that
19:19:40 <Twey> mm_freak_: But that's not how an imperative programmer would try to understand it
19:19:48 <mm_freak_> Twey: true
19:19:55 <dolio> I agree that it's pretty easy when you actually approach it correctly.
19:21:04 <mm_freak_> it's just funny that i always preferred recursion over loops, but started functional programming very late
19:21:44 <mm_freak_> recursion always seemed more natural to me…  it 'made sense'
19:21:51 <Mandarin> mm_freak_: very.. recursive of you
19:22:40 <mm_freak_> in fact i remember that i once complained that tail calls blow the stack before even knowing the term "tail call" =)
19:22:47 <Twey> mm_freak_: Until quite recently, functional programming wasn't really something the average programmer knew about.
19:24:04 <aristid> Twey: i'd say even now a good majority doesn't
19:24:23 <Twey> aristid: I think most people have at least heard of it now
19:24:33 <Twey> Even if they don't really know what it is
19:24:34 <mm_freak_> and another majority denies its superiority
19:24:57 <weexplat> dolio: it's more like eta is an open-evaluation-only thing, but typechecking isn't necessarily the only time you'd do open evaluation, you also do it in partial evaluation, staged metaprogramming, compile-time reflection, etc
19:25:07 <aristid> mm_freak_: or decries its supposed smugness to immediately render it uninteresting
19:25:17 <mm_freak_> Twey: i really doubt that…  in germany you don't get taught that in school, only in university and only marginally in many universities
19:25:37 <Twey> mm_freak_: But anybody who follows a programming community will have heard about it
19:25:45 <dolio> weexplat: I'm not sure you'd want to bother with eta there, either. But you could do it.
19:26:12 <mm_freak_> Twey: unfortunately most programmers are commercial programmers and only follow application-specific communities, where the topic doesn't arise often
19:26:32 <EvanR> hey
19:26:41 <Twey> If you follow Java, you'll hear things about Scala and Clojure.  If you follow C#, you'll have heard all the recent F# propaganda.  If you follow C/C++ you'll have heard about TCO and probably the reasons for that will lead to functional programming.
19:26:42 <mapreduce> Although at least making things immutable is less and less of an alien idea each year in imperative languages.
19:26:56 <EvanR> i want a single combinator to return ()
19:27:01 <aristid> Twey: and i think that most programmers don't follow anything they don't absolutely have to :)
19:27:10 <mm_freak_> Twey: and then there is the army of PHP deprogrammers
19:27:51 <weexplat> deprogramming in PHP?  or deprogramming from PHP?  because the former is more a rabble than an army
19:27:51 <Twey> PHP has first-class functions now too; same argument as C/C++ (though I admit that's more tenuous than the others)
19:27:57 <mm_freak_> EvanR: done = return ()  -- and that's not a combinator
19:28:08 <mm_freak_> weexplat: the former
19:28:21 <EvanR> mm_freak_: yeah but, i dont know a word 'a single variable' 'a single word'
19:28:36 * Twey blinks.
19:28:49 <Twey> EvanR: Parse failure
19:29:00 <weexplat> (as many armies learned, though, a rabble will trounce an army in the right circumstances)
19:29:02 <EvanR> i dont know what to call it
19:29:11 <EvanR> a b c d -> a
19:29:15 <EvanR> or e
19:29:16 <mm_freak_> Twey: it has anonymous functions and broken closures…  it doesn't really have first class functions in the same sense as haskell…  and the syntax is sufficiently ugly, even worse than javascript, to keep PHP programmers away from that feature
19:29:17 <EvanR> or something
19:29:24 <Twey> mm_freak_: const?
19:29:27 <Twey> Er, EvanR**
19:29:40 <EvanR> done instead of return ()
19:29:43 <mm_freak_> EvanR: "done"
19:29:47 <EvanR> done exists?
19:29:51 <mm_freak_> no
19:29:54 <EvanR> damn
19:29:57 <mm_freak_> but why would you want that anyway?
19:30:03 <Twey> mm_freak_: Eh, I don't think syntax is a big argument here: people do functional Javascript all the time.
19:30:03 <EvanR> so i dont need parentheses
19:30:14 <Twey> :-\
19:30:20 <Twey> EvanR: So define it
19:30:24 <mm_freak_> EvanR: you're not using parentheses there…  it's a syntactical peculiarity of haskell
19:30:28 <mm_freak_> () is actually a constructor
19:30:29 <luite> oh in what version did php get first class functions?
19:30:35 <mm_freak_> luite: 5.3
19:30:36 <EvanR> maybe done (f . g) foo
19:30:38 <Twey> luite: 5.3
19:30:42 <luite> cool
19:30:48 <EvanR> better than maybe (return ()) (f . g) foo
19:30:58 <luite> now i can swithc back to php from haskell ;p
19:31:00 <mapreduce> Just leaves Java and C in the top 10 TIOBE without functions.
19:31:08 <mapreduce> lambdas, even
19:31:33 <Twey> EvanR: return () `maybe` f . g $ foo
19:31:33 <Mandarin> How do you calculate Big O of a sorting function?
19:31:41 <mm_freak_> EvanR: better write a combinator for that one
19:31:41 <Twey> EvanR: If you care that much :þ
19:31:45 <EvanR> Twey: hmm
19:31:53 <Twey> Er, might need to bracket f . g
19:31:58 <weexplat> Twey: i think functional javascript is driven more by functional programmers forced to use javascript to get things to run in the browser than by people just experimenting with functional programming
19:32:05 <Twey> I can never remember how backticks interact
19:32:05 <EvanR> yeah i do want maybe (return ()) f
19:32:19 <luite> Mandarin: master theorem
19:32:28 <mm_freak_> EvanR: maybeM :: (Monad m) => b -> (a -> m b) -> Maybe a -> m b
19:32:36 <weexplat> Mandarin: you don't if it's shellsort :)
19:32:38 <Twey> Mandarin: Recurrence relation
19:32:44 <mm_freak_> maybeM () (f . g) foo
19:32:56 <EvanR> @hoogle maybeM
19:32:56 <lambdabot> No results found
19:33:00 <EvanR> shite
19:33:01 <Mandarin> Thanks! Got some reading for tonight :)
19:33:13 <luite> Mandarin: (or when it does not apply, some other way to solve the recurrence relation)
19:33:20 <EvanR> ok back to reality
19:33:22 <weexplat> otherwise, it's the same way you calculate it for any other algorithm
19:33:28 <mm_freak_> EvanR: in any case, i'd rather go with your original 'maybe (return ()) (f . g)'
19:33:49 <Twey> I'm guilty of having used ‘return () `maybe` (f . g)’ on occasion.
19:33:58 <mm_freak_> EvanR: another way is this:  liftMaybe :: (Monad m) => Maybe (m ()) -> m ()
19:34:02 <Twey> Oh, you could use fmap of course
19:34:13 <weexplat> Twey: O_o\
19:34:14 <mm_freak_> EvanR: then just use this:  liftMaybe . fmap (f . g)
19:34:19 <Twey> EvanR: ‘return () `maybe` fmap f g $ foo’
19:34:26 <Twey> EvanR: Look ma, no brackets!
19:35:14 <stepkut> too bad this is not a valid haskell operator, (:þ)
19:35:16 <mm_freak_> i think the liftMaybe concept is quite elegant
19:35:29 <mm_freak_> stepkut: it is, but not on the value level =)
19:35:33 <Twey> It isn't
19:35:37 <Twey> þ is alphabetic
19:35:46 <mm_freak_> oh
19:36:05 <Twey> The liftMaybe is nice, but I think EvanR doesn't want solutions that involve defining things.
19:36:24 <weexplat> what is that letter called again?  thorn?
19:36:24 <mm_freak_> declarative programming is about defining things =)
19:36:29 <Twey> weexplat: Yes
19:36:39 <Twey> weexplat: Or þorn to the initiated ;)
19:36:50 <mm_freak_> lol
19:37:58 <weexplat> ᴼᴥᵒ
19:38:50 <Draconx|Laptop> þ iſ quite a ſplendid letter.
19:39:13 <Twey> Draconx|Laptop: is**
19:39:19 <Draconx|Laptop> yeah, I just saw that :(
19:39:21 <Twey> :þ
19:39:32 <weexplat> :t let ᴼᴥᵒ = (P..) in ᴼᴥᵒ ᴼᴥᵒ ᴼᴥᵒ
19:39:34 <lambdabot> <no location info>: not an expression: `let'
19:40:05 <Twey> :t let (ᴼᴥᵒ) = (P..) in (ᴼᴥᵒ) ᴼᴥᵒ (ᴼᴥᵒ)
19:40:06 <lambdabot> parse error (possibly incorrect indentation)
19:40:11 <Twey> ☹
19:40:17 <weexplat> > let ᴼᴥᵒ = (P..) in ᴼᴥᵒ ᴼᴥᵒ ᴼᴥᵒ f g x y
19:40:18 <lambdabot>   <no location info>: lexical error at character '\7484'
19:40:18 <BMeph> If you're into hard-core þ
19:40:23 <mm_freak_> :t let (ᴼᴥᵒ) = (P..) in (ᴼᴥᵒ) ᴼᴥᵒ (ᴼᴥᵒ) in (ᴼᴥᵒ)
19:40:26 <lambdabot> parse error (possibly incorrect indentation)
19:40:33 <mm_freak_> is that alphabetic?
19:40:39 <Draconx|Laptop> in other news, https://en.wikipedia.org/wiki/Talk:Long_s is one of the greatest pages on the English wikipedia.
19:40:40 <weexplat> it should ought to be
19:40:40 <Twey> No idea
19:40:54 <Twey> Oh, that would explain it
19:40:55 <mm_freak_> :t let ᴼᴥᵒ = (P..) in ᴼᴥᵒ ᴼᴥᵒ ᴼᴥᵒ in ᴼᴥᵒ
19:40:57 <lambdabot> <no location info>: not an expression: `let'
19:41:12 <Twey> > map isSymbol "ᴼᴥᵒ"
19:41:13 <lambdabot>   [False,False,False]
19:41:20 <Twey> > map isAlpha "ᴼᴥᵒ"
19:41:22 <lambdabot>   [True,True,True]
19:41:26 <Twey> Oh right
19:41:34 <weexplat> in the middle is an 'ain'
19:41:39 <mm_freak_> > let ᴼᴥᵒ = id in ᴼᴥᵒ "yeah"
19:41:41 <lambdabot>   <no location info>: lexical error at character '\7484'
19:41:41 <Twey> :t let ᴼᴥᵒ = (P..) in ᴼᴥᵒ ᴼᴥᵒ ᴼᴥᵒ
19:41:42 <lambdabot> <no location info>: not an expression: `let'
19:41:48 <mm_freak_> perhaps it's just lambdabot
19:41:49 <Twey> :-\
19:41:53 <Twey> Maybe
19:42:06 <mm_freak_> but GHCi doesn't accept it either
19:42:41 <weexplat> ᵹ_ᵹ
19:42:41 <Mandarin> neither does GHC
19:42:52 <scry`> > let id = λ x -> x
19:42:54 <lambdabot>   <no location info>: parse error on input `->'
19:42:54 <Twey> I get a lexical error on the ᴼ
19:43:01 <scry`> lame
19:43:04 <scry`> da
19:43:10 <Twey> scry`: Not allowed because λ is a letter ☹
19:43:13 <donri> is it lowercase?
19:43:22 <donri> the strange unicode above
19:43:23 <shachaf> Also, not allowed because it's not an expression.
19:43:28 <Twey> donri: No
19:43:39 <mm_freak_> just use emacs with haskell-mode =)
19:43:46 <Twey> It's neither upper- nor lowercase
19:43:50 <Mandarin> let ☹ = id in ☹ "yeah"
19:43:56 <Mandarin> :t let ☹ = id in ☹ "yeah"
19:43:57 <lambdabot> <no location info>: not an expression: `let'
19:44:08 <Twey> Mandarin: That's a symbol.
19:44:11 <weexplat> > let ᵹ_ᵹ = (P..) in ᵹ_ᵹ ᵹ_ᵹ ᵹ_ᵹ f g x y
19:44:12 <lambdabot>   Ambiguous occurrence `x'
19:44:12 <lambdabot>  It could refer to either `L.x', defined at <local...
19:44:14 <mm_freak_> sometimes i'm even compelled to use a variable width serif font when programming haskell
19:44:17 <mm_freak_> almost looks like math
19:44:23 <Twey> mm_freak_: *gasp*
19:44:30 <weexplat> :t let ᵹ_ᵹ = (P..) in ᵹ_ᵹ ᵹ_ᵹ ᵹ_ᵹ
19:44:31 <lambdabot> <no location info>: not an expression: `let'
19:44:47 <weexplat> > let ᵹ_ᵹ = (P..) in ᵹ_ᵹ ᵹ_ᵹ ᵹ_ᵹ f g y z
19:44:48 <lambdabot>   Ambiguous occurrence `y'
19:44:48 <lambdabot>  It could refer to either `L.y', defined at <local...
19:44:59 <Twey> I don't really like mathematical syntax from anything other than an aesthetic perspective
19:45:03 <scry`> doesn't it mess up indentation?
19:45:22 <mm_freak_> scry`: you can program in a way that it doesn't
19:45:24 <Twey> scry`: No, because only initial indentation is important
19:45:38 <Twey> Spaces are all the same width
19:45:41 <mm_freak_> but it certainly makes reading some other people's code awkward
19:45:51 <Twey> Heh
19:46:26 <weexplat> i like a lot of aspects of mathematical syntax, dislike some others
19:46:51 <mm_freak_> Twey: it's hard to tell when the needed indentation is reached, so in a variable font you tend to indent much more than necessary making the code harder to read for other people
19:46:53 <weexplat> certainly there's a large fraction of it that's not exactly suitable for programming as-is
19:47:10 <mm_freak_> Twey: think of a let binding that starts indented
19:47:15 <Twey> mm_freak_: I keep mental track of how many spaces I've issued
19:47:23 <scry`> and haskell-mode can handle the tabbing?
19:47:31 <mm_freak_> Twey: then you're not using haskell-mode's indentation facility
19:47:45 <ion> Elastic tab stops and a variable-width font would be awesome with any programming language.
19:47:54 <mm_freak_> ion: i agree
19:47:57 <Twey> Ah, true (I wasn't thinking of Haskell specifically; I've never tried variable-width Haskell)
19:48:05 <mm_freak_> scry`: yes
19:48:20 <monochrom> that redeems the sin of tab :)
19:48:28 <mm_freak_> now i'm using dejavu sans mono with unicode representations =)
19:48:41 <scry`> inconsolata is nice
19:48:43 <weexplat> i'd like to use a display mode that starts throwing in column alignment when you have more than one space in a row
19:48:48 <mm_freak_> also i changed some of the characters…  most notably i changed "->" from a short arrow to a long one
19:49:01 <monochrom> I just use ubuntu's fonts out of the box. largest coverage, least hassle
19:49:04 <scry`> dejavu has a tiny -
19:49:19 <mm_freak_> scry`: dejavu sans mono
19:49:39 <scry`> thats what i meant
19:49:48 <scry`> you can barely see that thing!
19:49:51 <mm_freak_> huh?  it has a tiny dash?  can't confirm that
19:49:58 <monochrom> I understand that other people prefer to split hair on fonts because "the t has one more pixel than I like, and it's driving me nuts"
19:50:01 <weexplat> dejavu sans mono is actually mono where it covers, but it has some surprising gaps
19:50:04 <mm_freak_> scry`: perhaps your hinting settings are broken
19:50:23 <weexplat> also it's pretty systematically clueless about combining characters
19:50:34 <luite> consolas ftw, your fonts are all stupid!
19:50:46 <mm_freak_> well, i haven't found a nicer font so far…  i'd love to have a nice serif mono font
19:50:55 <weexplat> some always look right, some never look right, some only look right with certain renderers or when combined with certain other characters
19:51:03 * Twey likes ‘Monospace’.
19:51:07 <Twey> :þ
19:51:08 <mm_freak_> i really dislike sans serif, even on screen
19:51:14 <scry`> mm_freak_: how dare you
19:51:28 <weexplat> the usual thing being that they appear one box to the right of where they're supposed to be
19:51:30 <luite> consolas looks a tad too blurry in emacs on mac though
19:51:56 <scry`> no really, inconsolata has me hooked
19:52:06 <monochrom> my software is rendering your "dislike sans serif" in sans serif :)
19:52:09 <scry`> recommended
19:52:54 <weexplat> any monospace font with small unicode coverage drives me nuts these days
19:53:00 <scry`> Twey: i think they still use that in Iceland
19:53:10 <Twey> scry`: Yep
19:54:04 <weexplat> because inevitably my screen will get filled with obscure unicode characters and suddenly whatever was depending on having an actual monospace font fails spectacularly
19:54:05 <mm_freak_> i think #haskell is the only channel where you can talk so long about fonts without getting kicked
19:54:20 <shachaf> mm_freak_: What about #haskell-blah?
19:54:33 <weexplat> mm_freak_: there's probably some channels about fonts too
19:54:37 <mm_freak_> shachaf: the only programming language channel
19:54:37 <Twey> mm_freak_: All my channels have the same policy on off-topic
19:54:58 <Twey> Enforcing strict topic adherence doesn't really seem to do much good
19:55:18 <monochrom> I think we're just not trigger-happy
19:56:12 <Saizan> now please return to fonts..erhm..haskell
19:57:41 * BMeph hums "Come, Thou Font of Every Blessing"
19:58:41 <weexplat> does anybody have a good library for opengl font rendering in haskell?  ᵔ˾ᵔ
20:01:50 <Mandarin> APL must have many font discussions
20:02:14 <monochrom> interesting. happy-1.18.9 (current version), "cabal build" succeeds, "./Setup build" doesn't
20:04:30 <shachaf> monochrom: Works for me.
20:04:34 <monochrom> "./Setup buiid" just says "The program happy is required but it could not be found" and quits
20:05:04 <shachaf> Wait, are you talking about building happy or building something htat uses happy?
20:05:16 <monochrom> is your environment a clean environment? i.e., ghc 7.4.1/2 with mtl and nothing else, especially no happy
20:05:22 <monochrom> building happy
20:05:34 <shachaf> No, my environment is quite unclean.
20:05:42 <shachaf> How does cabal run ./Setup?
20:05:47 <roconnor> dolio: do you know if eta-long forms for dependent records are fine?
20:05:54 <monochrom> I don't really know
20:06:05 <monochrom> I will find out by a lot of -v's
20:06:15 <shachaf> strace -f -e trace=process -o OUT cabal build
20:06:16 <dolio> roconnor: Agda does them.
20:06:18 <shachaf> ...Or cabal -v, right.
20:06:26 * shachaf tends to forget about that. :-)
20:06:45 <Veinor> hahaha
20:06:51 <dolio> Or, it did. Now it expands on demand to try to avoid blowing up memory.
20:08:17 <mm_freak_> weexplat: there is FTGL, but the last update was in 2009…  i think your best bet is to use freetype directly
20:13:48 <scry`> anyone have a go at http://projecteuler.net/problem=391 ?
20:17:46 * hackagebot pcap-conduit 0.1 - Conduit <-> libpcap (AustinSeipp)
20:21:48 <sentientwaffle> what is "Can't make a derived instance of `.. ..'"? how do you make a class derivable?
20:21:55 <Veinor> you don't, afaik
20:21:57 <mauke> you don't
20:22:16 <latro`a> in special cases there's an extension that will do it, but for the most part you don't
20:22:25 <latro`a> (for example there is an extension DeriveFunctor)
20:22:40 <Nereid> on the other hand
20:22:43 <latro`a> in the case of newtypes there is also GeneralizedNewtypeDeriving
20:22:49 <Nereid> you can derive any class for newtypes
20:22:50 <Nereid> ^
20:23:01 <Veinor> yeah
20:23:07 <nand`> you write TH helpers to create instances
20:23:18 <latro`a> in the general case you either do it by hand or with TH, yeah
20:23:28 <sentientwaffle> so if I create a class how do I use it if I cant derive it?
20:23:42 <nand`> you can instantiate it manually
20:24:04 <sentientwaffle> can you point me to an example :)
20:24:23 <nand`> instead of data Foo = ... deriving Bar; write instance Bar Foo where ...
20:24:33 <latro`a> erm, not instead of
20:24:37 <Nereid> @where lyah
20:24:37 <latro`a> you still have a data Foo =
20:24:38 <lambdabot> http://www.learnyouahaskell.com/
20:24:42 <sentientwaffle> ah, ok
20:24:42 <nand`> well, instead of the ‘deriving’ bit I meant
20:24:42 <latro`a> but no deriving
20:24:51 <latro`a> what are you trying to instantiate, sentientwaffle
20:25:06 <Nereid> "Typeclasses 102"
20:26:02 <sentientwaffle> lastr`s: I think this is what I want -- I am trying to do mixins (sort of..)
20:26:27 <roconnor> dolio: oh so agda has surjective pairing?
20:26:35 <roconnor> man, Coq is really out of date.
20:26:36 <Nereid> "how do I do <imperative/object-oriented programming idiom> in haskell"
20:26:42 <latro`a> lol
20:27:04 <Nereid> at least half the time the answer is "you don't"
20:27:24 <shachaf> Sounds like @faq needs a random number generator!
20:27:32 <sentientwaffle> Nereid: whats the right way to do this, then?
20:27:37 <Nereid> depends on what you want to do!
20:27:47 <Saizan> roconnor: i told you hours ago!
20:28:05 <roconnor> Saizan: I guess I lost it in the noice
20:28:11 <roconnor> *noise
20:28:39 <Rotaerk> imperative and OO are easy in haskell
20:28:43 <sentientwaffle> Nereid: I am trying to follow http://stevelosh.com/blog/2012/07/caves-of-clojure-04/ using haskell (specifically the 'aspects' at the moment)
20:28:51 <mm_freak_> i'm really impressed
20:28:58 <mm_freak_> newtype Prob a = Prob (forall g. (RandomGen g) => g -> (a, g))
20:29:04 <mm_freak_> GHC can actually derive Functor for this type
20:29:41 <latro`a> that doesn't seem that impressive to me?
20:29:49 <latro`a> find the a, apply the function to it
20:30:21 <latro`a> what impresses me is functor derivation for complicated recursive typse
20:30:22 <latro`a> *types
20:31:24 <mm_freak_> that one on the other hand doesn't seem impressive to me
20:31:31 <latro`a> weird
20:31:35 <mm_freak_> the impressive thing is that the function is higher rank
20:31:39 <latro`a> oh
20:31:46 <latro`a> still, the a is always in the same place
20:32:48 <mm_freak_> wow, that type is really useful for fast monte carlo simulation
20:32:57 <mm_freak_> type MC = Free Prob
20:33:16 <latro`a> fmap f (Prob h) g = let (a,x) = h g in (f a,x) --find the a, apply the function :p
20:33:20 <dolio> roconnor: Yeah. It eta expands records, but not one-constructor data.
20:33:32 <roconnor> dolio: that almost makes sense
20:33:40 <sentientwaffle> is there a right way to do polymorphism in haskell, or is that the wrong solution?
20:33:41 <roconnor> records are records but data is inductive
20:33:56 <latro`a> there are several different sorts of polymorphism in haskell
20:34:07 <latro`a> again, depends on what you want to do
20:34:34 <roconnor> w00t my first serious of Maybe (Maybe Foo)
20:34:37 <sentientwaffle> lastro`a: can you give me a top-level of them so i can do some research :)
20:34:40 <weexplat> the main thing is you can't really make a recursive type that eta-expands
20:34:46 <roconnor> *serious use of
20:36:16 <startling> how do I refer to [(a, b)] without any type variables? Say I want to make it an instance of some class with kind * -> * -> *
20:36:41 <dolio> roconnor: It's actually used for some trick now. I think they use Unit -> A with an inductively defined Unit to delay something-or-other based on the fact that Units don't expand to record {} automatically.
20:36:47 <parcs`> startling: newtype
20:37:13 <jamiltron> Are there any good resources on composing lenses (Data.Lens) for nested data types?
20:37:19 <startling> parcs`, couldn't I do it with type?
20:37:30 <shachaf> jamiltron: (.)
20:38:18 <mm_freak_> sentientwaffle: haskell's main kind of polymorphism is parametric polymorphism, i.e. one code, many possible meanings
20:38:41 <sentientwaffle> mm_freak_: e.g. map, filter?
20:38:46 <mm_freak_> sentientwaffle: in haskell "123" can mean the integer 123, the double 123 or the constant function that returns 123
20:38:52 <shachaf> jamiltron: (Control.Category..), I guess.
20:38:53 <weexplat> dolio: was that how inspect-on-steroids worked?
20:38:58 <startling> @type 12
20:38:59 <lambdabot> forall t. (Num t) => t
20:39:00 <Veinor> mm_freak_: constant function?
20:39:02 <nand`> or many other thigns that are numbers
20:39:09 <Veinor> ... oh right, caleskell. i wouldn't talk about that right now
20:39:11 <latro`a> ....that constant function bit is only in lambdabot >.>
20:39:11 <mm_freak_> > 123 :: a -> Integer
20:39:13 <lambdabot>   Overlapping instances for GHC.Show.Show
20:39:13 <lambdabot>                              (a -> ...
20:39:14 <nand`> Veinor: I assume he's talking about instance Num a => Num (b -> a)
20:39:19 <mm_freak_> > 123 ()
20:39:20 <Veinor> that's a silly instance
20:39:21 <lambdabot>   123
20:39:23 <dolio> weexplat: I think so.
20:39:25 <mm_freak_> Veinor: it isn't
20:39:31 <mm_freak_> > (sin + cos) 3
20:39:33 <lambdabot>   -0.8488724885405782
20:39:33 <dolio> But I haven't looked at it, really. Just heard rumors.
20:39:44 <startling> mm_freak_: oh neat
20:39:48 <nand`> > length + 1 $ "hello"
20:39:49 <lambdabot>   6
20:39:52 <Veinor> i mean i know why it's there, it's just not one i'd ever use in normal code
20:40:08 <mm_freak_> that's because you need to define it, because it's not in the base library 0)
20:40:09 <mm_freak_> =)
20:40:10 <weexplat> dolio: you should never trust rumours.  after all, they might turn out to be true
20:40:15 <nand`> or import it, rather
20:40:18 <nand`> Data.NumInstances
20:40:39 <mm_freak_> oh, interesting
20:40:39 <johnw> :t length
20:40:40 <lambdabot> forall a. [a] -> Int
20:40:42 <johnw> :t length + 1
20:40:43 <lambdabot> forall a. [a] -> Int
20:40:50 <johnw> very cool
20:41:07 <parcs`> jamiltron: doesn't that have a category instance?
20:41:12 <startling> couldn't Bool easily be a Monoid?
20:41:19 <danharaj_> edwardk: I was trying to approach the active lens deal from another angle: trying to figure out what 'lens' would look like for a monadic getter and setter. I found that you need a traversable instead of a functor in the definition of Lense.
20:41:22 <nand`> > False ++ True
20:41:23 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Bool.Bool)
20:41:23 <lambdabot>    arising from a use of...
20:41:36 <mm_freak_> startling: not Bool itself, but And or Or
20:41:39 <nand`> startling: well, there are at least two ways of making it one
20:41:40 <edwardk> i have actions now ;)
20:41:43 <mm_freak_> newtype And = And Bool
20:41:44 <danharaj> o rly
20:41:52 <edwardk> yeah
20:41:54 <nand`> startling: so instead of deciding which one should be default, the decision is to not make it one by default and instead use newtype wrappers
20:41:58 <startling> mm_freak_: oh, is that defined somewhere?
20:42:00 <mauke> > And False ++ And True
20:42:02 <lambdabot>   Not in scope: data constructor `And'Not in scope: data constructor `And'
20:42:07 <edwardk> finishing up a documentation binge and i'll push up to hackage in a sec
20:42:09 <mauke> > All False ++ All True
20:42:11 <edwardk> got them working early today
20:42:12 <lambdabot>   All {getAll = False}
20:42:12 <danharaj> exciting times.
20:42:17 <mauke> > Any False ++ Any True
20:42:20 <lambdabot>   Any {getAny = True}
20:42:20 <edwardk> they still don't have setter equivalents
20:42:21 <mm_freak_> startling: no, but just see how Sum and Product work
20:42:28 <startling> mm_freak_: right, understood
20:42:36 <startling> is ++ in lambdabot mappend?
20:42:40 <nand`> yes
20:42:43 <edwardk> but the 'Action m a b' type we talked about works great
20:42:44 <nand`> :t (<>)
20:42:46 <lambdabot> Doc -> Doc -> Doc
20:42:47 <nand`> :(
20:42:49 <Veinor> i've been thinking about how to handle entities in my roguelike code, actually, and i'm not sure
20:42:52 <parcs`> startling: nope, type synonyms have to be fully applied otherwise bad things happen
20:43:07 <mm_freak_> in base 4.5 Data.Monoid defines (<>)
20:43:08 <Veinor> i mean, in an OO language i'd just use mixins or what have you. but haskell isn't OO
20:43:24 <mm_freak_> Veinor: what's the matter?
20:43:45 <sentientwaffle> Veinor: thats exactly what I'm trying to figure out!
20:43:47 <shachaf> Veinor: "OO" is pretty vague. Haskell can do some some things that some people call "OO" quite well.
20:43:49 <Veinor> mm_freak_: i'm not sure what i want my datatype to look like!
20:43:49 <edwardk> i also have to hack in indexed actions and indexed monadic folds
20:43:50 <startling> Veinor, I had a data Monster = Monster { species :: Species, stats :: Stats, controller :: World -> Action }
20:44:03 <mm_freak_> Veinor: there are lots and lots of ways to do it
20:44:12 <mm_freak_> one way is FRP, the other is ExistentialQuantification
20:44:22 <sentientwaffle> startling: can you explain the 'controller'?
20:44:30 <nand`> many types of existentials can also be remodelled as regular data types
20:44:30 <mm_freak_> data GameObj = forall a. GameObj a (a -> IO ())
20:44:32 <edwardk> i've been building quickchecks for a little while as well
20:44:36 <mm_freak_> an object together with a drawing function
20:44:39 <shachaf> mm_freak_: There are also ways that are neither FRP nor existential quantification. :-)
20:44:42 <mm_freak_> but FRP is usually nicer and more declarative
20:44:57 <mm_freak_> shachaf: i meant to say "another", not "the other" =)
20:45:00 <shachaf> I don't think FRP is "well-understood" enough that I'd recommend it.
20:45:00 <Veinor> so what would FRP look like?
20:45:15 <shachaf> That is: Has anyone ever written an actual program that actually uses FRP?
20:45:17 <mm_freak_> shachaf: i'm using FRP in production
20:45:25 <startling> sentientwaffle, it took the World (or the monster's view of the world) and decided what to do from it
20:45:27 <edwardk> shachaf: there have been some with arrow frp
20:45:39 <Veinor> shachaf: if nobody uses FRP because nobody uses FRP, there's a problem
20:45:39 <parcs`> shachaf: yeah, all 5 of them
20:45:45 <Veinor> :v
20:45:51 <sentientwaffle> startling: ah, ty
20:45:53 <mm_freak_> i'm using AFRP (read the "A" as "arrow" or "applicative", whatever you prefer)
20:46:39 <danharaj> edwardk: this is what I was playing with: http://hpaste.org/72762
20:46:43 <mm_freak_> it's probably noteworthy that i don't write games or GUIs…  i'm using FRP mainly for networking stuff
20:46:59 <edwardk> mine is rather different
20:47:01 <startling> sentientwaffle: that was verified afterwards to make sure it didn't move further than it was allowed to etc
20:47:12 <startling> sentientwaffle: oh also the interface was a controller. :)
20:47:30 <sentientwaffle> startling: Im gonna have to thing about that one for a while... :P
20:47:31 <mm_freak_> Veinor: if you're looking for production-ready FRP libraries, there is at least netwire…  i also believe that reactive-banana is production-ready
20:47:44 <edwardk> let me run my tests one more time and push to github
20:47:53 <danharaj> great :)
20:48:21 <sentientwaffle> startling: so what was Action?
20:48:22 <luite> bluh why didn't anyone warn me that writing a new ghc code generator would require actual work
20:48:34 <edwardk> ok, i've pushed
20:48:35 <Veinor> mm_freak_: so, here's my question about FRP
20:48:50 <edwardk> i'm still working on haddock doc issues and such
20:48:59 <shachaf> luite: You're writing a GHC code generator?
20:49:03 <shachaf> Oh, is that GhcJs?
20:49:04 <luite> shachaf: well ghcjs
20:49:08 <startling> sentientwaffle: data Action = Move Coords | UseAttack Attack Monster, etc
20:49:12 <Veinor> suppose i want a monster that has an ability to clone itself. how do i tell the world 'okay, now you have a new instance of the Cloner datatype in your entity list'?
20:49:20 <startling> i never got too far because I couldn't get a decent UI. :/
20:49:27 <luite> the code generator is not part of ghc itself, and not really planned to ever be
20:49:33 <danharaj> Another insight I had was, at least with STArrays, your code would only have one point in a lense stack where you need to have actions occur. I wonder if, say restricting actions to occur at the end of a lense stack would enable setters?
20:49:43 <edwardk> yeah
20:49:43 <shachaf> Veinor: How would you do it in any other language?
20:49:43 <edwardk> er
20:49:45 <edwardk> no
20:49:50 <edwardk> it works great now with
20:49:51 <mm_freak_> Veinor: in FRP you don't have a "world"…  your "world" is your set of equations in source code…  note that FRP is declarative
20:49:53 <startling> Veinor, my Species type had a list of Actions it could use
20:49:54 <luite> unless javascript is going to become the next cpu instruction set
20:49:56 <edwardk> foo^!read._2.read
20:49:57 <sentientwaffle> startling: ah, neat, hadn't thought about organizing that way
20:50:09 <mm_freak_> Veinor: but you can have:  "monsters = …"
20:50:16 <edwardk> you can even make actions that do writing, etc.
20:50:23 <edwardk> foo^!write 12
20:50:24 <Veinor> shachaf: i'm not sure!
20:50:34 <shachaf> Veinor: Well, you can probably do something similar in Haskell. :-)
20:50:35 <Veinor> like, i don't know if the monster has a reference back to the global state or not
20:50:37 <mm_freak_> Veinor: now 'monsters' is itself a time-varying value
20:50:40 <edwardk> and you can run them in loops by chaining in folds
20:51:05 <shachaf> Veinor: For example, if you want the monster to have a function :: World -> (blah,World), you can do that. But you probably don't want quite that much control over the world.
20:51:27 <mm_freak_> shachaf: you're answering a different question =)
20:51:37 <mm_freak_> Veinor asked about how this would look like in FRP
20:52:00 <Veinor> ... actually, hm, yeah that is how i'd write it in an OO-y language.
20:52:20 <Veinor> mm_freak_: is there a decent example of FRP i can look at somewhere?
20:52:26 <shachaf> mm_freak_: Oh, I thought he was asking about the other way.
20:52:36 <latro`a> reactive banana has a whole bunch of examples on the wiki
20:52:52 <mm_freak_> Veinor: i'm going to update the wiki page on netwire once version 4.0.0 is out
20:53:14 <edwardk> danharaj: ["hello","world"]^!folded.act putStrLn
20:53:22 <Veinor> latro`a: pff! who reads things these days
20:53:28 <edwardk> danharaj: (1,"hello")^!_2.act id.to succ
20:53:34 <mm_freak_> Veinor: the current one gives a somewhat clean introduction, but is far from comprehensive…  the haddocks are comprehensive, though
20:53:56 <parcs`> Veinor: check out "The Yampa Arcade" paper
20:54:09 <danharaj> edwardk: what does that last one do?
20:54:20 <parcs`> i believe there's also a successor to that paper..
20:54:21 <edwardk> it runs in the list monad and produces "ifmmp"
20:54:40 <danharaj> ah nice
20:54:57 <danharaj> `ineffective'
20:55:03 <danharaj> nice.
20:55:24 <Veinor> mm_freak_: interesting. so FRP is all about event-based programming?
20:55:35 <Veinor> 'when this happens, do that and the other'
20:55:35 <monochrom> happy builds fine (cabal-install or Setup.lhs) if I refrain from "cabal clean" or "Setup clean". there are important files under dist/ that come with the source. if they are erased, happy is needed to regenerate them, that's the problem I ran into
20:55:45 <mm_freak_> Veinor: about declarative programming of stateful systems, most notably systems with local state
20:55:47 <nand`> I think FRP is all about time-based programming
20:55:55 <nand`> but I know nothing about FRP
20:55:57 <mm_freak_> no, FRP is not about time
20:56:03 <mm_freak_> time is an addon
20:56:10 <edwardk> =)
20:56:34 <danharaj> I never found frp to be adequate because it can't handle dynamically generated signals very well.
20:56:37 <luite> shachaf: hopefully in a few days i'll be able to run benchmarks against the old code generator and competitors like haste and uhc-js
20:56:55 <mm_freak_> danharaj: then you never went past 'reactive' and yampa =)
20:57:00 <Cale> Veinor: It's all about describing the connection between things which occur discretely and have a value at each occurrence (Events), and things which always have a value which may be different at any given time you observe it (Behaviours)
20:57:02 <danharaj> I tried banana.
20:57:15 <mm_freak_> danharaj: banana is also not about dynamic systems…  netwire is the one to go there
20:57:15 <Veinor> Cale: interesting.
20:57:18 <mm_freak_> + with
20:57:26 <danharaj> never got netwire :P
20:57:31 <baywatch> can someone please tell me why I am getting a msg "Not in scope: sort"
20:57:36 <Cale> Veinor: and each FRP system will define possibly very different ways to look at those and tie them together.
20:57:41 <luite> baywatch: it's in Data.List
20:57:44 <Veinor> mm_freak_: i sense a slight bias!
20:57:50 <baywatch> ty
20:57:54 <mm_freak_> Veinor: i'm the author of netwire =)
20:58:16 <danharaj> Here's a test case for a gui abstraction I once saw: display a list of counter widgets, two buttons to add and remove the last counter, each counter widget has an increment and decrement button and a destroy button, and there's a widget that displays the sum of all counters.
20:58:27 <mm_freak_> to be fair, reactive-banana is the one to go with, if you want to design GUIs
20:58:40 <danharaj> yeah, reactive-banana doesn't do that sort of thing cleanly.
20:59:06 <Veinor> danharaj: oh, that's a nice test case
20:59:11 <danharaj> It gets worse if, say, you want to give a different callback to each widget in the dynamic collection.
20:59:17 <mm_freak_> reactive-banana is less powerful, but there is a ready-made GUI library, and i'm not planning to write one for netwire any time soon
20:59:36 <mm_freak_> that's why reactive-banana is definitely the one to go with for GUIs
20:59:47 <mm_freak_> but there is another very nice concept for GUIs:  tangible values
20:59:56 <mm_freak_> turn ordinary haskell types into GUIs
21:00:28 <danharaj> I saw the TV library and it also seemed inadequate when it comes to complicated dynamic guis.
21:01:01 <mm_freak_> TV is actually about dynamic GUIs, but i haven't used it myself…  i just saw the video talk about it, and the concept is really great
21:01:28 <mm_freak_> anyway, to comment on your test case:  netwire can do that easily, and everything you need is already in the latest release
21:01:34 <dmwit> Last time we were discussing it here (can't remember with who), it seemed to be a little bitrotted.
21:01:47 <roconnor> I used GuiTV many years ago;  It was nice for making very simple UIs
21:01:53 <roconnor> which is better than no UIs
21:02:03 <roconnor> But it has bitrotted so much I was unable to reserect it.
21:03:46 <nand`> roconnor: I got fragments of it working a few weeks back; but I couldn't visualize any form of generated images
21:04:08 <spaceships> can someone point me to a clear explanation of @?
21:04:18 <mauke> spaceships: aliasing
21:04:29 <tommd> The Haskell2010 standard
21:04:49 <spaceships> cool. thanks.
21:05:06 <mauke> > let f x@y = x + y in f 2
21:05:08 <lambdabot>   4
21:05:24 <spaceships> oh its that simple, huh?
21:05:32 <spaceships> facepalm
21:05:40 <mm_freak_> spaceships: gives a pattern a name
21:05:50 <danharaj> edwardk: do you think there's anything interesting to be had with comonads and lenses? :P
21:06:02 <edwardk> not really
21:06:04 * spaceships nods
21:06:16 <mm_freak_> > let brokenId a@(x:xs) = a in brokenId [0,1,2]
21:06:18 <lambdabot>   [0,1,2]
21:06:28 <VitamnP> would it be viable to write a porn sitein haskell
21:06:37 <mm_freak_> VitamnP: yes
21:06:54 <wagle> does does the latest haskell-platform ghci sgefault on startup for anyone else?
21:07:06 <startling> wagle, on os x?
21:07:20 <wagle> on macosx snow leopard
21:07:23 <mauke> algorithmically generated erotic literature
21:07:31 <Veinor> monads for your gonads
21:07:38 <startling> wagle: yep, switch to 32-bit
21:07:58 <jamiltron> parcs`: It does. Its weird, I couldn't get two lenses to compose with (.), but I was able to with (>>>)
21:08:00 <wagle> ahh cool, thanks
21:08:28 <startling> wagle: something is weird about snow leopard and 64-bit is unsupported for it. dunno the exact cause, but switching to 32-bit fixed it for me
21:08:29 <mm_freak_> jamiltron: (>>>) = flip (.)
21:08:38 <mauke> :t (>>>)
21:08:39 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
21:08:40 <mm_freak_> where (.) is from Control.Category
21:09:00 <edwardk> jamiltron: using what lens lib?
21:09:01 <luite> startling: i heard that newer xcode solves the problem, but that isn't available for snow leopard?
21:09:12 <startling> luite: could be
21:09:16 <jamiltron> edwardk: Data.Lens
21:09:21 <edwardk> jamiltron: and was (.) from Control.Category or Prelude?
21:09:34 <edwardk> jamiltron: did you remember to hide (.) from the Prelude?
21:09:49 <edwardk> (of course you could switch to 'lens' and not have that problem) ;)
21:10:45 <luite> startling: 64 bit (7.4.2) still has other problems on lion and mountain lion btw
21:11:34 <startling> luite: o rly
21:12:24 <jamiltron> edwardk: I thought I did but I screwed up the import, thanks!
21:13:07 <wagle> hmm..  well it works so far on my mtlion machine
21:14:06 <luite> wagle: try ghci with some foreign bindings lib, like sqlite
21:15:20 <wagle> using gitit, which is essential..  not sure i want to break it
21:15:34 <wagle> breaking the snowleopard is ok
21:17:32 <EvanR> is there something like hackage docs i can view in the shell like man pages
21:18:41 <mm_freak_> EvanR: set "Documentation: True" in your ~/.cabal/config
21:18:46 <mm_freak_> then just use the local documentation
21:19:01 <mm_freak_> i'm using my regular browser, which is sufficient
21:19:22 <EvanR> id rather not leave fullscreen iterm
21:19:35 <Veinor> open it in lynx?
21:20:21 <EvanR> heh
21:20:38 <EvanR> after setting the cabal config
21:20:51 <EvanR> cabal update?
21:21:09 <luite> you don't get source links in those docs though :(
21:21:39 <mm_freak_> EvanR: you'll need to reinstall your packages
21:21:53 <mm_freak_> which is about equivalent to an update
21:21:58 <mm_freak_> upgrade
21:22:01 <hpaste> Mandarin pasted “Style help” at http://hpaste.org/72763
21:22:25 <Mandarin> Are there any idioms that I can use in my code? ^^
21:22:36 <mm_freak_> Mandarin: using (==) on lists is almost always the wrong way to do it
21:23:22 <mm_freak_> see 'null'
21:23:25 <mm_freak_> > null []
21:23:26 <lambdabot>   True
21:23:36 <tommd> > const True []
21:23:37 <lambdabot>   True
21:23:45 <mm_freak_> but a better way here is to use a pattern guard
21:23:46 <tommd> Yay, functionally equal!
21:23:52 <mm_freak_> | (x:xs) <- keys = x
21:23:57 <mm_freak_> | otherwise = -2
21:24:35 <mm_freak_> you can also use 'case'
21:24:46 <baywatch> must I cast calculations between floating points and integers?
21:24:55 <mm_freak_> baywatch: convert, yes
21:25:05 <baywatch> ty
21:25:07 <EvanR> cast is something else
21:25:29 <Mandarin> mm_freak_: can one choose freely when to use case and guards?
21:25:37 <mm_freak_> Mandarin: of course
21:25:44 <baywatch> where is convert?
21:25:47 <mm_freak_> as long as both make sense =)
21:25:59 <mm_freak_> baywatch: 'fromIntegral', 'round', 'truncate', etc.
21:26:07 <mm_freak_> > fromIntegral (1 :: Integer) :: Double
21:26:09 <lambdabot>   1.0
21:26:11 <EvanR> > floor 3.00
21:26:12 <lambdabot>   3
21:26:25 <Mandarin> mm_freak_: Let me rephrase that: are there any scenarios where one should preferably use case or guards?
21:26:35 <baywatch> ty
21:27:07 <mm_freak_> Mandarin: if you have a predicate, you will need guards…  if you pattern-match you can use either pattern guards or classic pattern matching (case)
21:27:24 <mm_freak_> usually you should prefer 'case', but in some cases pattern guards can be better
21:27:48 <mm_freak_> one idiom i often use is this:  | Just x <- M.lookup k m
21:28:15 <startling> mm_freak_: isn't that just >> ?
21:28:22 <EvanR> what is <- in a guard?
21:28:33 <startling> oh, read the arrow the wrong way
21:28:34 <mm_freak_> if the element at key 'k' exists in 'm', call it 'x'
21:28:39 <mm_freak_> EvanR: pattern guard
21:28:47 <mm_freak_> | pattern <- expr = …
21:29:08 <EvanR> if it doesnt match the pattern, try next alternative?
21:29:13 <mm_freak_> yeah
21:29:21 <baywatch> sorry, first time user here... what is the best haskell reference site? new to functional, traditionally a C#, Sql, guy. My use of haskell will be confined to maths
21:29:23 <EvanR> is that an extension
21:29:34 <mm_freak_> EvanR: it used to be, but is now standard haskell 2010 =)
21:29:50 <mm_freak_> baywatch:
21:29:52 <mm_freak_> @where lyah
21:29:53 <lambdabot> http://www.learnyouahaskell.com/
21:29:59 <EvanR> baywatch: good, sql is pretty declarative
21:30:11 <EvanR> if pretty baroque
21:30:29 <Lajla> I feel that sql is designed by the same people who produced COBOL in a way
21:30:30 <aristid> EvanR: and inconsistent
21:30:34 <tommd> lyah is the goto site.  Gone are the days we point people to YAHT and A Gentle Introduction.
21:30:39 <mm_freak_> baywatch: as a side note, confining haskell to math is a bad idea…  haskell is extraordinarily great at real world stuff, at which most other languages suck
21:30:47 <baywatch> I have lots of statistical functions in sql, take too long to run. I want to convert to haskell or R
21:30:47 <Lajla> Well, so is Haskell, depending on your definition of inconsistency
21:31:20 <aristid> Lajla: i think SQL is worse :)
21:31:36 <Lajla> Haskell is extraordinarily bad at real world stuff compared to most languages desiged to do real world stuff, it's just better than most langauges designed by a bunch of nerds out for theoretical perfection
21:31:46 <baywatch> this is all real world stuff. backtests and financial attributions against TB's of data
21:32:13 <Lajla> aristid, you don't like to form pseudo-English sentences in all caps now do you?
21:32:29 <tommd> Lajla: Please stop trying to start a flame war.
21:32:31 <aristid> Lajla: no, SQL also admits lowercase, that is not the problem.
21:32:50 <Lajla> True, but it's a convention, and it looks like you're shouting
21:32:54 <Lajla> which is what you are, incidentally
21:33:20 <EvanR> haskell is awesome at real world stuff, stfu
21:33:23 <EvanR> no you
21:33:34 * EvanR slings some shit
21:33:49 <Lajla> Good vintage
21:34:05 <EvanR> out of battery
21:34:11 <Lajla> Do you have that stuff too dressed up in a catholic schoolgirl uniform?
21:34:32 <baywatch> in you folks opinion, should I just conform to the hipsters at work and refactor all my sql into python? I wanted to use something a buit more nerdy
21:34:58 <startling> baywatch, hipsters would be using ruby
21:35:00 <startling> or node
21:35:11 <baywatch> lol.
21:35:12 <Lajla> Either I'm not getting soemthing or Python and SQL are completely different things.
21:35:55 <baywatch> yes. python is the language du jour at work currently. everything is  being redone in python. its silly. hence the hipster tag
21:36:10 <Lajla> No, I mean, SQL is a query language, python a programming langauge.
21:36:34 <baywatch> bottom line is we have tons of formulas and calculations that need to be refactored out of sql for various reasons.
21:36:59 <Lajla> I agree with whoever decided to make that investment into the future, give them a peck ont he cheek.
21:37:09 <baywatch> sql does more than querying, just not well
21:37:23 <aristid> baywatch: they should read some joel spolsky on rewriting.
21:37:30 <Lajla> Indeed, I read that apparently it's TC, learn something new every day.
21:38:01 <mekkz> If you're doing just formulas and calculations, Haskell is the way to go. IO is where things get murkey.
21:38:01 <aristid> baywatch: http://www.joelonsoftware.com/articles/fog0000000069.html
21:38:19 <aristid> @faq Can Haskell do IO very well?
21:38:19 <lambdabot> The answer is: Yes! Haskell can do that.
21:38:47 <mekkz> Yes, but it can seem awkward for those who aren't used to the language
21:39:28 <dibblego> but a little less awkward than in their preferred language
21:39:48 <baywatch> hmm
21:39:56 <Lajla> I think that asking here if you should use Haskell will give you more biased answers than asking Bill O'Reilly
21:40:52 <baywatch> haskell seems a bit more intuitve to me so far, but python has simple IO and numpy libs
21:41:12 <tommd> Lajla: If you wish to engage in productive discussion then that's neat.  So far you've engaged in baiting, unsubstantiated bashing, and sensationalist comparisons.
21:41:13 <baywatch> either way, I like haskell so far
21:41:21 <tommd> I hope you can see how you're marginalizing yourself.
21:41:43 <dibblego> :(
21:41:48 <Lajla> tommd, what's unproductive about pointing that out honestly?
21:41:52 <Lajla> would you say it isn't true?
21:42:07 <dibblego> it is not true, nor interesting
21:42:18 <Lajla> If you ask most programmer, I'd reckon 90% will say that Haskell isn't that suited for real world stuff, the fact that people say otherwise here idnicates a bias
21:42:19 <dibblego> the "not interesting" bit being most prevalent
21:42:47 <dibblego> yes, we all meet these people all the time, then we give them an informed opinion and your made-up 90% decreases ever so slightly
21:42:54 <Lajla> It's quite true that people are biased towards haskell here, you will get that in any channel topicalized regarding a certain language.
21:42:54 <pharaun> hehe
21:42:56 <dibblego> it is *uninteresting*
21:43:32 <startling> Lajla, a lot of people who haven't tried haskell are biased against it, I think
21:43:40 <Lajla> I'm pretty sure the opinion of Haskell programmers about C++ will also decrease ever so slightly after informed opinions
21:43:44 <tommd> Lajla: Yes, I am aware of the possibility of bias.  I would argue Haskell is quite good at 'real world work' and there is plenty of evidence.
21:44:04 <tommd> OTOH the idea that 90% of programmers have an opinion one way or another is funny.
21:44:24 <startling> @pl \a b -> b + 1
21:44:25 <lambdabot> const (1 +)
21:44:27 <edwardk> its more like 90% of programmers haven't heard of it ;)
21:44:29 <startling> oh duh
21:44:32 <tommd> At any rate, I'm not making time for IRC tonight - have a blast.
21:44:39 <Lajla> I would say that haskell is good for real life work for people who like working with haskell, the issue is pretty subnhjective
21:44:47 <Lajla> I would however say trhat for the majority of people, it's definitely not suited
21:44:52 <dibblego> edwardk: a bit like Bill O'Reilly and how the tides work realy :)
21:45:08 <JSchwag> 'zip' is cool
21:45:16 <JSchwag> perfect name for it
21:45:19 <dibblego> JSchwag: wait until you see liftA2
21:45:35 <JSchwag> sounds interesting
21:45:49 <latro`a> (the joke-ish-thing is that zip = liftA2 (,))
21:45:50 <dibblego> it is a generalised zip, not just for zipping lists
21:45:59 <JSchwag> haha awesome
21:46:03 <latro`a> (except liftA2 (,) is more polymorphic)
21:46:06 <dibblego> @type liftA2
21:46:07 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
21:46:23 <startling> my length function for Foldables is foldr (const (1 +)) 0 -- does that seem right?
21:46:27 <pharaun> Lajla: if they have even heard of it :p
21:46:42 <dibblego> startling: you probably want foldl rather than foldr if you are going to use Integral
21:46:47 <dibblego> foldl'
21:46:53 <sinestro> I just tried step 11 on tryhaskell.org and I just get a string instead of a list.
21:47:00 <latro`a> strings are lists
21:47:08 <dibblego> startling: but yes, both will give a correct answer, but foldl' will use constant space
21:47:13 <latro`a> rather Strings are lists
21:47:18 <dibblego> @info String
21:47:19 <lambdabot> String
21:47:22 <dibblego> boo
21:47:24 <JSchwag> lol
21:47:26 <dibblego> type String = [Char]
21:47:31 <latro`a> strings (lowercase) might not be lists
21:47:46 <dibblego> > take 3 "abcdef"
21:47:47 <lambdabot>   "abc"
21:47:52 <Lajla> I'm pretty sure most people have heard of Haskell, for me, it works, but I also realize that it's not for everyone and the way most people think, side effect-based programming seems tow ork better.
21:48:04 <JSchwag> "super" = ['s','u','p','e','r']
21:48:29 <sinestro> That will take a while to make sense.
21:49:02 <mekkz> Newbie question: Could anybody explain the use of forall? Is it necessary?
21:49:06 <Lajla> THis is by the way one of the reasons Haskell for some people does not make sense for real life stuff.
21:49:16 <Lajla> Having strings as merely a sequence of characters has its unicode problems
21:49:31 <dibblego> mekkz: it's just an explicit qualification that can be used either for clarification or in some contexts, it is required in order to position the forall quantifier correctly
21:49:38 <Rotaerk> Lajla, why?
21:49:50 <Lajla> Combining characters
21:50:01 <Rotaerk> unicode is just a sequence of characters
21:50:02 <Lajla> THere are a lot of different ways in unicode to form a character 'ä'
21:50:09 <Lajla> It's far more comlpicated than that
21:50:15 <Rotaerk> isn't that just a matter of encoding
21:50:17 <Lajla> Nope
21:50:31 <Lajla> 'ä' has its own codepoint in unicode, but there's also a combining character
21:50:43 <sinestro> I keep getting random parse errors
21:50:53 <sinestro> > map (+1) [1..5] <hint>:1:25: parse error on input `else'
21:50:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:50:56 <mekkz> dibblego: Is it at all like type constraints?
21:51:03 <Lajla> And a+combining diarases after each other also generates 'ä', unicode considers these identical characters and identical strings if they feature them, haskell does not
21:51:16 <sinestro> fuck haskell
21:51:21 <dibblego> mekkz: it is like generics in Java or C# if you are familiar with that — though those languages also leave out the forall quantifier
21:51:22 <Lajla> Which is why a lot of modern languages have a dedicated string datatype to solve issues with this
21:51:23 <mekkz> Lalja: Does that problem exist with bytestrings?
21:51:26 <edwardk> Lajla: do you have a point beyond trolling about how nobody who uses haskell has any real life purpose to do so? because its late, i'm tired, and /kickban is easier than looking at the flood of your noise
21:51:47 <dibblego> I vote +1
21:51:59 --- mode: ChanServ set +o edwardk
21:51:59 <Lajla> ..., read what I just wrote about.
21:52:02 <Lajla> above*
21:52:03 --- mode: edwardk set +b *!~Lajla@2001:0:5ef5:79fd:8cd:2beb:ae33:eb94
21:52:03 --- kick: Lajla was kicked by edwardk (Your behavior is not conducive to the desired environment.)
21:52:06 <dibblego> thanks
21:52:13 <latro`a> +1
21:52:22 --- mode: edwardk set -o edwardk
21:52:36 <edwardk> the signal to noise ratio wasn't worth it
21:52:38 <scry`> Lajla: how does e.g C handle the Unicode thing then?
21:52:48 <dibblego> it was garbage, yes
21:52:50 <scry`> oops
21:52:51 <dibblego> thank you
21:52:52 <latro`a> lol, C and strings
21:53:01 <latro`a> (built-in, anyway)
21:53:04 <VitamnP> i thought c didnt have strings
21:53:34 <mekkz> dibblego: Yes I'm familiar with them, but how is it different than just not adding type constraints? For example, is "myFunct :: a -> b" any different from "forall a b. myFunct :: a -> b"
21:53:53 <dibblego> mekkz: no, they are the same here — you are just being explicit
21:54:10 <dibblego> mekkz: however, data X a = X a and data Y a = Y (forall a. a) are different
21:54:17 <scry`> c has char*'s
21:54:44 <Veinor> there's something to be said about String being a pretty bad datatype
21:54:46 <scry`> or char[] -- just like haskell!
21:55:04 <mekkz> dibblego: i guess that makes sense. i've got to go now; thanks for your help
21:55:07 <spaceships> edwardk: the high quality of #haskell has been a huge motivator to me these last couple weeks in learning haskell. thanks
21:55:10 <dibblego> mekkz: no problems
21:55:25 <dibblego> spaceships: we endeavour to keep it that way :)
21:55:28 <edwardk> spaceships: happy to do my little part ;)
21:56:12 <aristid> Veinor: and that's why there's Text :)
21:57:23 <scry`> @hoogle :: String -> Text
21:57:24 <lambdabot> Data.Text.Lazy pack :: String -> Text
21:57:24 <lambdabot> Data.Text pack :: String -> Text
21:57:24 <lambdabot> Prelude read :: Read a => String -> a
21:57:59 <scry`> wait, Read is Text?
21:58:04 <aristid> no
21:58:21 <scry`> i mean, Text is a Read...
21:58:23 <aristid> hoogle is not matching precisely, you need to look at the type
21:58:39 <aristid> scry`: yes, Text is a Read
21:59:07 <aristid> but i really doubt that hoogle is taking that into consideration
21:59:18 <aristid> @hoogle A -> A
21:59:19 <lambdabot> Prelude id :: a -> a
21:59:20 <lambdabot> Data.Function id :: a -> a
21:59:20 <lambdabot> GHC.Exts breakpoint :: a -> a
21:59:25 <dmwit> ?hoogle String -> (a -> b)
21:59:26 <lambdabot> Debug.Trace trace :: String -> a -> a
21:59:26 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
21:59:27 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
21:59:35 <aristid> there's not even an A type, yet it finds something
21:59:36 <dmwit> aristid: seems to be taking it into account after all =)
21:59:54 <aristid> dmwit: huh?
22:00:42 <dmwit> If it were not taking into account Read-ness, I would expect the query I gave to return "read" somewhere near the top.
22:01:02 <aristid> dmwit: your query has a function-thing as the result
22:01:24 <aristid> dmwit: so i don't think that's apples for apples
22:01:25 <dmwit> Yes.
22:01:29 <dmwit> Why not?
22:01:35 <aristid> @hoogle String -> CookieMonster
22:01:36 <lambdabot> Warning: Unknown type CookieMonster
22:01:36 <lambdabot> Prelude error :: [Char] -> a
22:01:36 <lambdabot> Debug.Trace trace :: String -> a -> a
22:01:37 <scry`> but it's right associative
22:02:07 <scry`> so it shouldn't matter?
22:02:18 <aristid> well maybe it does look at the Read constraint.
22:02:56 <dmwit> ?hoogle String -> Parser a
22:02:56 <lambdabot> No results found
22:03:06 <dmwit> there, that should be sufficiently convincing
22:04:01 <aristid> dmwit: it just reduced my confidence in what hoogle does, so as far as i'm concerned it might be magic
22:04:22 <aristid> (confidence in the sense that i don't know what it does, not in the sense that i distrust it)
22:04:41 <dmwit> yeah, seems magical to me, too =)
22:04:56 <dmwit> (By the way, I'd point out that your A -> A query didn't return any typeclass-polymorphic functions.)
22:05:26 <aristid> dmwit: yeah but it did replace the A by forall a. *shrug*
22:05:31 <dmwit> Hm, though the web interface does.
22:05:32 <dmwit> yeah
22:06:02 <dmwit> magic
22:06:11 <aristid> indeed
22:06:26 <fronglong> I remember read somewhere that haskell people consider the haskell repl to be superior to the lisp repl, but now I can't find that source and I can't tell if that's what it really said. does anyone have the opinion on the superiority of one repl to the other?
22:06:32 <fronglong> remember reading*
22:07:04 <dmwit> Can't we all just get along?
22:07:19 <edwardk> we used to have an inferiority complex because the ghc repl couldn't define data types, but thats largely rectified so its more of a toss up
22:07:28 <scry`> @hoogle Read a
22:07:29 <lambdabot> Did you mean: :: Read a
22:07:30 <lambdabot> Control.Monad.Reader module Control.Monad.Reader
22:07:30 <lambdabot> Control.Monad.Trans.Reader module Control.Monad.Trans.Reader
22:07:41 <aristid> edwardk: can it really define _all_ data types now? including GADTs and stuff?
22:07:52 <scry`> @hoogle :: Read a
22:07:53 <lambdabot> Warning: Unknown type Read
22:07:53 <lambdabot> Prelude undefined :: a
22:07:53 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
22:07:55 <JSchwag> learnyouahaskel chapter one complete. see you folks tomorrow bright and early
22:08:12 <edwardk> yep
22:08:20 <edwardk> you can't set defaulting, i think thats about it
22:08:20 <aristid> edwardk: wow
22:08:28 <edwardk> ghci> data Foo a where Foo :: Int -> Foo Int
22:08:32 <edwardk> does right in
22:08:37 <edwardk> er goes
22:08:37 <aristid> ghci ftw
22:09:15 <mm_freak_> edwardk: do you think it's possible to make Free an instance of MonadFix?
22:09:38 <edwardk> not sure if i ever thought about it
22:09:45 <edwardk> give it a shot and let me know
22:09:55 <edwardk> i'd have thought i'd have taken a whack at it
22:09:57 <mm_freak_> your library doesn't provide an instance unfortunately, and i'm not even sure whether it's possible
22:10:01 <edwardk> but i don't remember one way or the other
22:10:03 <mm_freak_> probably only if the functor is a comonad
22:10:09 <edwardk> blech
22:10:15 <edwardk> thats a pretty odd limitation
22:10:38 <mm_freak_> well, you need to extract future values, don't you?
22:10:46 <mm_freak_> after all you have the future wrapped in an 'f'
22:10:59 <edwardk> yes and no, the naive form should work
22:11:09 <edwardk> bah you're going to make me write it
22:11:10 <edwardk> ;)
22:11:18 <mm_freak_> that's my goal =)
22:11:30 <mm_freak_> but i'll give it a shot, too
22:12:32 <edwardk> it seems screwed
22:13:09 <mm_freak_> i don't even know how to start
22:13:15 <edwardk> yep
22:13:23 <mm_freak_> there is nothing i can apply to the function
22:13:28 <mm_freak_> apply the function to
22:13:30 <edwardk> exactly
22:13:32 <edwardk> =)
22:13:47 <mm_freak_> hmm…  Comonad won't even help there
22:14:00 <edwardk> no dice man
22:14:19 <edwardk> you can make one for left adjoints or something thats about it
22:14:27 <scry`> > [1,2,46,73,6] >>= flip divMod 5
22:14:28 <lambdabot>   Couldn't match expected type `[b]' against inferred type `(t, t)'
22:14:43 <mm_freak_> hmm…  so i can't use Free, when i want MonadFix =/
22:14:44 <edwardk> but those are boring cases here since the functor doesn't recurse
22:15:03 <mm_freak_> scry`: you probably want 'map'
22:15:05 <edwardk> you can probably lift the monad from f if its also a monadfix
22:15:16 <mm_freak_> yeah, that sounds possible
22:15:17 <edwardk> but in general yes, you're hosed
22:17:12 <scry`> mm_freak_: trying to grok (>>=)
22:17:20 <mm_freak_> scry`: for lists it's just flip concatMap
22:17:22 <scry`> >[1,2,46,73,6] >>= \n -> let x = divMod 5 n in [fst x, snd x]
22:17:34 <scry`> > [1,2,46,73,6] >>= \n -> let x = divMod 5 n in [fst x, snd x]
22:17:36 <lambdabot>   [5,0,2,1,0,5,0,5,0,5]
22:18:01 <mm_freak_> > concatMap (\x -> [Left x, Right x]) [1,2,3]
22:18:02 <lambdabot>   [Left 1,Right 1,Left 2,Right 2,Left 3,Right 3]
22:18:16 <mm_freak_> > [1,2,3] >>= \x -> [Left x, Right x]
22:18:17 <lambdabot>   [Left 1,Right 1,Left 2,Right 2,Left 3,Right 3]
22:19:08 <scry`> yay! i think i get it
22:19:26 <mm_freak_> scry`: may make more sense in do-notation or list comprehensions
22:19:44 <mm_freak_> > do x <- [1,2,3]; y <- ["a", "b", "c"]; return (x, y)
22:19:46 <lambdabot>   [(1,"a"),(1,"b"),(1,"c"),(2,"a"),(2,"b"),(2,"c"),(3,"a"),(3,"b"),(3,"c")]
22:20:23 <scry`> [(x,y) | x <- [1,2,3], y <- ['a', 'b', 'c'] ]
22:20:32 <scry`> > [(x,y) | x <- [1,2,3], y <- ['a', 'b', 'c'] ]
22:20:34 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
22:20:42 <scry`> mm yep
22:21:16 <scry`> so i heard list comprehensions can be generalized to monad comp's
22:21:32 <scry`> how does that work?
22:21:40 <mm_freak_> > concatMap (\x -> concatMap (\y -> [(x, y)]) ["a", "b", "c"]) [1,2,3]
22:21:42 <lambdabot>   [(1,"a"),(1,"b"),(1,"c"),(2,"a"),(2,"b"),(2,"c"),(3,"a"),(3,"b"),(3,"c")]
22:21:46 <latro`a> list comprehensions parse to do notation parses to >>=
22:21:47 <dmwit> mm_freak_: There's always the free MonadFix.
22:22:03 <aristid> :t mfix
22:22:04 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
22:22:14 <scry`> right, i get that now
22:22:23 <mm_freak_> latro`a: list comprehensions aren't parsed to do notation
22:22:30 <latro`a> they could be, though
22:22:36 <mm_freak_> nope
22:22:38 <latro`a> wot
22:22:42 <dmwit> wot
22:22:49 <scry`> but they're all isomorphic, right
22:22:58 <mm_freak_> > [ x | x <- [1..9], even x ]
22:23:00 <lambdabot>   [2,4,6,8]
22:23:10 <mm_freak_> if you parse that to do notation, you'll likely get a "not in scope" error
22:23:12 <latro`a> that parses to do notation with guard
22:23:16 <dmwit> > do { x <- [1..0]; guard (even x); return x }
22:23:17 <lambdabot>   []
22:23:21 <dmwit> uh
22:23:28 <scry`> lol
22:23:28 <dmwit> > do { x <- [1..9]; guard (even x); return x }
22:23:29 <lambdabot>   [2,4,6,8]
22:23:33 <mm_freak_> 'guard' is likely not in scope
22:23:50 <dmwit> Is that seriously your objection?
22:23:56 <mm_freak_> yes
22:24:05 <dmwit> Because I can whip up a syntactic-sugar-expansion in 30s that doesn't refer to guard.
22:24:14 <wagle> :t guard
22:24:15 <mm_freak_> if you parse to do-notation, you reparse to core
22:24:15 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
22:24:24 <mm_freak_> the reparse requires 'guard' to be in scope
22:24:51 <dmwit> > do { x <- [1..9]; let { guard False = mzero; guard True = return () } in guard (even x); return x }
22:24:52 <lambdabot>   [2,4,6,8]
22:25:16 <mm_freak_> parsing to do-notation will cause problems
22:25:27 <dmwit> I think you're confused.
22:25:45 <dmwit> Also possible: I'm confused.
22:25:49 <scry`> why would you parse to an extra stage?
22:25:55 <dmwit> You wouldn't.
22:26:00 <dmwit> But I don't see why it would cause problems.
22:26:09 <mm_freak_> scry`: you don't /parse/ to extra stages, but you convert to them
22:26:27 <mm_freak_> GHC converts source code to AST to core to some low level language to STG assembly
22:26:31 <scry`> ok but if they're isomorphic, its all simple translations
22:26:38 <mm_freak_> scry`: nope
22:26:47 <mm_freak_> 'guard (even x)' is opaque
22:26:57 <mm_freak_> 'even x' in a list comprehension is not
22:27:21 <mm_freak_> so at least the translation from do-notation back to list comprehension is not that straightforward =)
22:27:42 <dmwit> isomorphic is the wrong word, yeah
22:27:46 <mm_freak_> in any case, do-notation is still syntax, so you need some trickery to deal with scope, while when you're in core this is not a problem
22:28:12 <mm_freak_> concrete syntax that is
22:28:14 <dmwit> I don't see why "guard" would be a harder problem than, say, (>>=) is for do-notation desugaring.
22:28:39 <mm_freak_> dmwit: because the backward way is /sugaring/, not desugaring
22:28:48 <dmwit> backward... what
22:28:55 <mm_freak_> read my line again =)
22:29:18 <dmwit> I'm confused. The top-level question is "can you translate monad comprehensions to do notation".
22:29:26 <dmwit> Are you saying that no, you can't do that?
22:30:07 <mm_freak_> not straightforwardly, because do-notation is still concrete syntax, and you need to make sure that Control.Monad.guard is in scope for this particular do-block, but for nothing else, including the parts the do-block is composed of
22:30:08 <wagle> i've done it..  didnt seem hard, but this seemed surprising to others
22:30:37 <dmwit> wat
22:30:37 <mm_freak_> dmwit: think in AST terms
22:30:57 <dmwit> Okay, I'm going to make a similar argument. Tell me why it doesn't hold.
22:31:36 <dmwit> We can't desugar do-notation to plain old functions, because you need to make sure that (Prelude.>>=) is in scope for this particular function call, but for nothing else, including the parts the function call is composed of.
22:32:33 <mm_freak_> dmwit: do-notation isn't desugared to plain old functions, but to core
22:32:35 <wagle> let guard x = 1 [ x | guard (even x)]
22:32:40 <mm_freak_> if it were, you would run into the same problem
22:32:47 <wagle> > let guard x = 1 [ x | guard (even x)]
22:32:48 <lambdabot>   not an expression: `let guard x = 1 [ x | guard (even x)]'
22:32:50 <dmwit> The Report specifies it as a desugaring to plain old functions.
22:32:59 <wagle> > let guard x = 1 in [ x | guard (even x)]
22:33:01 <lambdabot>   Ambiguous occurrence `x'
22:33:01 <lambdabot>  It could refer to either `L.x', defined at <local...
22:33:07 <dmwit> There's no reason the specification can't specify monad comprehensions as desugaring to do-notation similarly.
22:33:28 <mm_freak_> dmwit: but that's not what is done, and i'm pretty sure that the report is relaxed enough that you are allowed to translate into something equivalent =)
22:33:39 <dmwit> So saying that monad comprehensions can't desugar to do-notation just because "that's not how GHC does it" seems very disingenuous.
22:33:54 <mm_freak_> that's not what i'm saying
22:33:54 <wagle> > let guard x = 1 in [ x | x <- [1..9] ; guard (even x)]
22:33:55 <lambdabot>   <no location info>: parse error on input `;'
22:33:59 <wagle> nm
22:34:23 <mm_freak_> again, think in AST terms
22:34:30 <wagle> > let guard x = 1 in [ x | x <- [1..9] , guard (even x)]
22:34:31 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
22:34:31 <lambdabot>    arising from a use of `guard...
22:34:32 <mm_freak_> you have [ x | x <- [1..9], even x ]
22:34:35 <dmwit> I don't want to think in AST terms. That's implementation details.
22:34:37 <mm_freak_> what would you desugar that into?
22:34:53 <dmwit> do { x <- [1..9]; guard (even x); return x }
22:35:03 <mm_freak_> compiling that will give you:  guard is not in scope
22:35:09 <mm_freak_> alternative?
22:35:24 <wagle> guard is defined where?
22:35:30 <mm_freak_> Control.Monad
22:35:32 <dmwit> Fine, if you want, do { x <- [1..9]; Control.Monad.guard (even x); return x }
22:35:38 <mm_freak_> still not in scope
22:35:46 <dmwit> That's okay. It doesn't have to be in scope.
22:35:58 <mm_freak_> the compiler would disagree =)
22:36:02 <pharaun> why would it not be in scope?
22:36:13 <dmwit> What does do { x <- [1..9]; return x } desugar to? [1..9] >>= \x -> return x, even though Prelude.>>= may not be in scope.
22:36:14 <mm_freak_> pharaun: because you can't assume that Control.Monad is imported
22:36:23 <dmwit> Your objections are stupid objections.
22:36:31 <mm_freak_> dmwit: it desugars to core
22:36:33 <mm_freak_> (again)
22:36:43 <dmwit> In GHC, it desugars to core.
22:36:44 <mm_freak_> everything desugars to core…  there are no intermediary haskell steps
22:36:52 <dmwit> In GHC, everything desugars to core.
22:36:57 <pharaun> mm_freak_: i see, but couldn't you desugar the control.monad.guard for that statement by dmwit to core ?
22:37:08 <mm_freak_> dmwit: you're not suggesting desugaring into do-notation
22:37:21 <mm_freak_> you're suggesting desugaring into "do-notation with reference extensiosn"
22:37:24 <mm_freak_> extensions
22:37:41 <mm_freak_> and yes, this matters
22:37:54 <dmwit> Alright. I've said my piece, and you've said yours. Continuing this argument will get us nowhere.
22:38:01 <wagle> plain vanilla ghci: Prelude> do { x <- [1..9]; Control.Monad.guard (even x); return x }
22:38:02 <wagle> [2,4,6,8]
22:38:03 <mm_freak_> right =)
22:39:01 <mm_freak_> wagle: that's a convenience feature of GHCi
22:39:15 * wagle rofls
22:39:23 <mm_freak_> the compiler doesn't allow that
22:39:53 <wagle> where does guard come from, then, in comprehensions?
22:40:11 <pharaun> mm_freak_: so this is a ghci specific feature, i can't do that in plain ghc?
22:40:30 <mm_freak_> pharaun: correct
22:40:45 <pharaun> interesting wasn't aware that ghci had those
22:41:59 <dmwit> wagle: (Currently, list comprehensions do not rely on guard.)
22:42:14 <mm_freak_> anyway, i think that dmwit and wagle just have a different notion of "tranlating into do-notation"…  for me it means:  desugarListComp :: ConcreteSyntax -> ConcreteSyntax
22:42:27 <dmwit> (...and their desugaring, *even* the specification, don't refer to it, though they do refer to concatMap.)
22:43:02 <dmwit> s/don't/doesn't/;s/they do/it does/
22:44:15 <mm_freak_> btw, GHC has an extension for rebindable syntax, which actually does do this translation
22:44:18 <wagle> ConcreteSyntax is a TH thing?
22:44:27 <mm_freak_> and hence runs into exactly the problem i have described above =)
22:44:44 <dmwit> No, he just made up that type, though there's undoubtedly something with a similar name deep in GHC's bowels.
22:44:46 <mm_freak_> no, it's just an ADT
22:45:12 <mm_freak_> i borrowed the name from agda's internals, but GHC does something similar
22:45:37 <dmwit> TIL about System.CPUTime
22:47:17 <wagle> oic...  comprehensions pay attention to the type while "translating" to do notation
22:47:47 <mm_freak_> in fact if you use RebindableSyntax and MonadComprehensions 'guard' must indeed be in scope, so you must import Control.Monad
22:47:54 <mm_freak_> otherwise you get the "not in scope" error i mentioned
22:51:15 <mm_freak_> scry`: btw, do-notation can't be translated back into comprehension syntax anyway, because you can't express 'if'
22:51:42 <wagle> ok, how do you print a string without importing anything in ghc?
22:51:58 <scry`> > print "Yo"
22:51:59 <lambdabot>   <IO ()>
22:52:12 <scry`> > do print "Yo"
22:52:13 <mm_freak_> you can't (assuming that Prelude isn't imported implicitly)
22:52:13 <lambdabot>   <IO ()>
22:52:23 <wagle> tried write and put, oh wwell
22:52:26 <Jafet> You can make ghc print strings
22:52:40 <scry`> > putStrLn "Yo?"
22:52:41 <lambdabot>   <IO ()>
22:52:43 <mm_freak_> well, ok
22:52:49 <mm_freak_> you can interface to the RTS using the FFI
22:53:28 <Jafet> ...without importing anything?
22:53:33 <mm_freak_> yeah
22:53:39 <mm_freak_> foreign import …
22:53:53 <mm_freak_> hmm, no
22:53:58 <mm_freak_> you need some types for that =)
22:54:19 <Jafet> You could unsafeCoerce them, but then you'd need to import unsafeCoerce
22:54:42 <mm_freak_> it's probably possible using some pragmas
22:54:53 <wagle> ok, print worked, and I surmounted the "aie, xquartz changed the x windows icon!" problem, but now i'm confused..
22:54:56 <scry`> why wouldn't you ever have prelude?
22:55:16 <mm_freak_> scry`: there are some alternative preludes on hackage
22:55:26 <mm_freak_> classy-prelude, awesome-prelude, etc.
22:55:28 <Jafet> Perhaps you're porting GHC.Prim
22:56:02 <scry`> yeesh
22:56:08 <shachaf> Jafet: I think you can write unsafeCoerce using enough type extensions.
22:56:11 <mm_freak_> but getting rid of Prelude entirely isn't possible in standard haskell
22:56:17 <scry`> mm_freak_: no `if' in comprehensions?
22:56:27 <mm_freak_> scry`: nope
22:56:43 <mm_freak_> no 'if', no 'case', …
22:57:08 <mm_freak_> well, there are 'if' and 'case', of course, but not in a way that changes the structure of the computation
22:57:19 <mm_freak_> like:  do x <- c; if p x then return "a" else return "b"
22:57:25 <mm_freak_> this is impossible in comprehension syntax
22:57:38 <scry`> > [if even x then "_" else "^" | x <- [1..20] ]
22:57:39 <lambdabot>   ["^","_","^","_","^","_","^","_","^","_","^","_","^","_","^","_","^","_","^...
22:58:06 <mm_freak_> try to convert this:  do x <- c1; if p x then c2 else return "b"
22:58:37 <Jafet> I love abstractions because they let me do exactly the same thing
22:59:36 <mm_freak_> comprehensions are about equivalent in power to Category + Applicative
22:59:43 <mm_freak_> they don't expose the full power of Monad
22:59:56 <shachaf> mm_freak_: I think they do.
23:00:05 <shachaf> If you use enough <-s?
23:00:14 <mm_freak_> shachaf: try to convert the code i've given above
23:00:20 <mm_freak_> do x <- c1; if p x then c2 else return "b"
23:01:25 <mm_freak_> you could nest comprehensions to achieve that, though
23:01:31 <scry`> mm_freak_: can you be tad more specific there?
23:02:04 <shachaf> [y | x <- c1, y <- if p x then c2 else return "b"]
23:02:09 <mm_freak_> [ y | x <- c1, y <- if p x then [ … ] else return "b" ]
23:02:43 <latro`a> can also do it with a map
23:02:45 <latro`a> on c1
23:02:49 <latro`a> but that's probably cheating
23:02:59 <shachaf> latro`a: map is easy -- join is the tricky one.
23:03:08 <mm_freak_> i think the nesting is already cheating
23:03:20 <latro`a> I didn't mean a map at top level
23:03:23 <latro`a> I meant a map in the comprehension
23:03:30 <latro`a> though ofc at that point you can still do it at top level
23:03:34 <shachaf> latro`a: Right. So did I, I think.
23:03:39 <shachaf> mm_freak_: I don't think nesting is cheating.
23:03:47 <latro`a> you're right though, the built-in return for comprehensions makes join tricky
23:03:55 <latro`a> without cheating, obviously
23:04:24 <shachaf> mm_freak_: The problem is that comprehension-notation lets you write join.
23:04:41 <shachaf> So it's more powerful than Applicative no matter what you do.
23:04:59 <mm_freak_> true
23:05:25 <scry`> so what's wrong with the example you just gave? seems to work
23:05:54 <mm_freak_> yeah, it does…  and nesting isn't really cheating, because you do that with do-notation as well
23:05:59 <mm_freak_> so i retract my statement =)
23:06:36 <scry`> cool beans
23:07:30 <mm_freak_> i wonder when we get arrow comprehensions…  that would be quite a nice feature =)
23:07:58 <scry`> anyone use BlazeHTML?
23:08:22 <wagle> do compresions with a -> Bool 's actually go looking for Control.Monad.guard?
23:08:23 <mm_freak_> scry`: the yesod project makes heavy use of blaze-html, particularly the hamlet template engine
23:08:50 <wagle> s/comprehensions/
23:08:59 <mikeplus64> mm_freak_: what would an arrow comprehension look like?
23:09:27 <wagle> dont use BlazeHtml, use whatever gitit uses though
23:10:08 <mm_freak_> mikeplus64: i could imagine something like:  [ (y, z) | proc x -> y <- c1 -< x; z <- c2 -< (x, y) ]
23:10:17 <wagle> Happstack
23:10:38 <wagle> owww
23:11:03 <wagle> hey guys, you thought apl was dead?
23:11:35 <wagle> any day now i'm going to figure out arrows and applicatives
23:12:09 <mikeplus64> mm_freak_: i don't think i've ever seen arrows actually used outside of hakyll :(
23:12:22 <mm_freak_> mikeplus64: AFRP
23:12:29 <wagle> i hng out here, and i really regret my round tuit shortage
23:12:33 <mm_freak_> animas, netwire, yampa
23:12:51 <wagle> hxml
23:12:55 <mm_freak_> hxt
23:12:59 <mikeplus64> i'll check them out
23:13:07 <wagle> that's what i wass trying to say
23:13:41 <mm_freak_> i also found myself using the raw automaton arrow from time to time
23:13:52 <wagle> i need xml for controlling my mac, so obviously need to do that in hxt
23:14:40 <wagle> i jusst keep finding things to do first
23:15:10 * wagle blames his keyboard, not his fingers, for any typos
23:15:37 <scry`> wagle: please clarify 'tuit'
23:16:07 <wagle> i cant do that until i get a round tuit
23:16:13 <wagle> around to it
23:16:40 <scry`> lol
23:17:15 <liyang> wagle: would you accept a slightly oblong tuit?
23:18:52 <wagle> wouldnt i need a pointy one to learn arrows?
23:22:29 <scry`> how do i get around name clashes in ghci?
23:22:43 <scry`> i imported Data.Text, now 'map' is ambiguous
23:22:50 <mm_freak_> scry`: if your GHC is recent enough, you can use 'import'
23:22:55 <shachaf> Don't import Data.Text.
23:22:55 <mm_freak_> just like in source files
23:23:02 <shachaf> Or import it qualified, the way you do in source files.
23:23:09 <shachaf> Otherwise, qualify your names, the way you do in source files.
23:23:12 <shachaf> It's the same as source files.
23:23:24 <scry`> i just dont want to have to restart the session
23:23:32 <shachaf> So unimport Data.Text.
23:23:37 <shachaf> :m - Data.Text -- or something
23:24:20 <scry`> aha!
23:24:26 <scry`> ty
23:24:38 <scry`> ok, ill look at :h in the future
23:24:57 <shachaf> mm_freak_: Sorry!
23:26:11 <mm_freak_> shachaf: for what?
23:27:18 <shachaf> Mentioning your name randomly in another channel.
23:27:44 <mm_freak_> no worries
23:35:44 <\rs> does lambdabot support logging?
23:36:17 <shachaf> Yes.
23:36:33 <shachaf> But the lambdabot running here doesn't do it, I think.
23:37:54 <\rs> how to make homebrew lambdabot write to log files?
23:37:58 * hackagebot fay 0.5.1.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
23:39:21 <shachaf> There's a "log" plugin.
23:42:39 <wagle> \rs read the topic for logs
23:42:53 <shachaf> wagle: I don't think that's what \rs is asking.
23:42:58 * hackagebot stylish-haskell 0.3.2.0 - Haskell code prettifier (JasperVanDerJeugt)
23:45:09 <\rs> how to enable specified plugins for homebrew lambdabot?
23:45:49 <\rs> wagle: sorry but i'm looking for approaches to enable logging for homebrew lambdabot
23:47:59 <wagle> \rs oh ok, sorry
23:48:45 <wagle> lambdabodt does crash, though
23:53:29 <scry`> :t (|||)
23:53:30 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
23:54:08 <scry`> forall and exists are GHC extensions, no?
23:54:29 <shachaf> Not "exists".
23:54:42 <shachaf> forall isn't in the Report but is a pretty standard extension.
23:55:40 <mm_freak_> scry`: existential quantification works differently in GHC
23:56:06 <mm_freak_> and universal quantification is always there, but is implicit in standard haskell
23:56:13 <mm_freak_> a -> b = forall a b. a -> b
23:57:26 <mm_freak_> what requires an extension is higher rank types:  (forall g. (RandomGen g) => g -> (Int, g)) -> Int
23:58:43 <scry`> hmm, so where does exists come from
