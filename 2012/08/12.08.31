00:00:38 <johnw> if I have two separately generated haddock doc directories (one in cabal, one downloaded from haskell.org), can I merge them?
00:00:44 <johnw> to avoid having two sets of indices?
00:05:54 <certainty> shachaf: why? (Can I even understand the answer, without knowing it?)
00:07:00 <johnw> certainty: just because shachaf doesn't like something, doesn't mean you shouldn't use it
00:09:12 <shachaf> certainty: Because you should know Haskell pretty well before you use it.
00:09:15 <certainty> johnw: i thought there might probably be a good reason, he/she didn't say he/she does or doesn't like it, right? But i figure that this topic might be subjective, as there are certainly people using it. There is a webframework which does, as i read
00:09:24 <shachaf> It's a solution to some problems, but not as many as you might think.
00:09:43 <johnw> it can avoid boilerplate, when there is no other way to avoid boilerplate
00:10:16 <certainty> yeah i suspected something like that. I've enough to learn with Haskell alone
00:10:18 <johnw> so far, I haven't read of other compelling use cases, but the night is young
00:10:26 <certainty> :)
00:10:56 <johnw> it's one of those tools that it's awesome to know it's there, but it's one of the last ones that you reach for
00:11:21 <certainty> i see. Just like continuations in scheme
00:11:28 <johnw> I feel that way about unsafePerformIO: I'm glad to know it exists, but I hope to never use it
00:11:48 <certainty> i hear it is the swiss army knife of haskell debugging
00:11:48 <johnw> Haskell has continuations too :)
00:12:05 <Jafet> @quote oasis
00:12:06 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
00:12:17 <johnw> I use trace all the time
00:12:31 <johnw> don't know what I'd do without it, actually
00:13:21 <certainty> Jafet: i see. I'm not a big fan of "printf debugging", myself. Nice that there is some alternative
00:13:35 <johnw> here's something I'd like to know: every author who talks about the Cont monads mentions that it provides early termination *and* resume semantics.  How does it allow resuming?
00:14:11 <certainty> johnw: yeah i recently stumbled upon unsafePerformIO, it somehow disturbed me, as one of the most appealing features of haskell was that I make strong assumptions about pure functions
00:14:32 <certainty> *can
00:14:48 <Jafet> johnw: return the current continuation
00:14:55 <Ralith> certainty: so only use safe haskell
00:14:59 <statusfailed> certainty: I think Debug.Trace is preferred to unsafePerformIO
00:15:02 <Jafet> into the to-be-current continuation
00:15:18 <johnw> how do I get the current continuation?
00:15:42 <Jafet> How does Cont work again?
00:16:20 <certainty> Ralith: i see
00:16:29 <certainty> statusfailed: nice, i will remember that.
00:16:42 <certainty> Ok time to get some work done. Thanks for the help sofar
00:16:45 * certainty &
00:17:57 <johnw> oh, I see
00:18:03 <johnw> you return a lambda from the continuation
00:19:44 * hackagebot HTTP 4000.2.4 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.4 (GaneshSittampalam)
00:19:53 <b__> what tools exist for refactoring other than HLint/HaRe/pl?
00:34:50 <johnw> Jafet: ok, this is no masterwork of beauty
00:34:54 <johnw> but it shows resumption
00:35:09 <hpaste> johnw pasted ‚Äúcont.hs‚Äù at http://hpaste.org/73971
00:35:43 <Jafet> ContT plumbing invariably looks like motorcycle maintenance.
00:36:18 <Jafet> Though just returning a function was not what I had in mind
00:36:20 <johnw> it's the need to use both Cont and IO which hidifies this
00:36:29 <johnw> using Cont in pure code would be much nicer
00:38:32 <shachaf> call cc statement considered harmful
00:38:45 <johnw> i kind of thought you wouldn't care for that one ;)
00:39:05 <nobdrais1ntone> @hoogle (IO a, IO a) -> IO (a,a)
00:39:05 <lambdabot> No results found
00:39:26 <johnw> @hoogle (m a, m a) -> m (a, a)
00:39:26 <lambdabot> No results found
00:39:32 <Jafet> :t uncurry (liftM (,))
00:39:33 <lambdabot> forall a1 b b1. (b1 -> a1, b1) -> b -> (a1, b)
00:39:41 <Jafet> :t uncurry (liftM2 (,))
00:39:42 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
00:39:48 <johnw> there you go
00:40:09 <johnw> @pl uncurry (liftM2 (,))
00:40:09 <lambdabot> uncurry (liftM2 (,))
00:40:49 <johnw> is that the same uncurry . liftM2 . (,)?
00:41:03 <nus> @unpl uncurry (liftM2 (,))
00:41:03 <lambdabot> uncurry (\ d e -> d >>= \ b -> e >>= \ a -> return ((,) b a))
00:41:09 <johnw> probably not..
00:41:13 <mikeplus64> :t uncurry . liftM2 . (,)
00:41:14 <lambdabot>     Couldn't match expected type `a2 -> r'
00:41:14 <lambdabot>            against inferred type `(a, a1)'
00:41:15 <lambdabot>     Probable cause: `(,)' is applied to too many arguments
00:41:18 <johnw> i sense a (. (,)) in there somewhere
00:41:19 <shachaf> johnw: Inline the (.) and see for yourself. :-)
00:41:29 <shachaf> There is absolutely no (. (,)) in there.
00:41:38 <shachaf> (,) is a direct argument to uncurry.
00:41:40 <johnw> what do you mean by "inline the (.)"?
00:42:06 <johnw> @pl uncurry (liftM2 (,)) (a,b)
00:42:06 <lambdabot> liftM2 (,) a b
00:42:10 <shachaf> I mean replace the (.) with its definition, then beta-reduce. You'll see why it doesn't work. :-)
00:42:20 <Jafet> That expression is already point-free -- it has no bound variables.
00:42:22 <johnw> what is "beta-reduce"?
00:42:25 <shachaf> Maybe you're looking for (uncurry . liftM2) (,)
00:42:30 <shachaf> But I'm not sure why.
00:42:33 <johnw> :t (uncurry . liftM2) (,)
00:42:34 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
00:42:36 <Jafet> So @pl doesn't do anything.
00:42:38 <johnw> was just wondering
00:42:57 <shachaf> Jafet: @pl does plenty to point-free expressions.
00:43:00 <shachaf> @pl (uncurry . liftM2) (,)
00:43:00 <lambdabot> uncurry (liftM2 (,))
00:43:16 <shachaf> It has a whole bunch of simplifications that it applies regardless of the original form of your input.
00:43:22 <Jafet> Well, it didn't have to do anything to that one
00:43:42 <shachaf> Right.
00:43:51 <Jafet> So doing that was...
00:43:54 <Jafet> ...pointless.
00:44:07 <shachaf> U+1F60E
00:44:35 <johnw> :)
00:44:56 <johnw> DOMINO TILE VERTICAL-01-04?
00:45:27 <shachaf> No.
00:45:36 <Jafet> I don't have a font that looks like Horatio.
00:45:53 <johnw> that's what Unicode Checker said U+1F60E was
00:46:00 <shachaf> johnw: I don't believe you.
00:46:53 <johnw> oh
00:46:58 <johnw> SMILING FACE WITH SUNGLASSES
00:47:06 <johnw> üòé
00:47:12 <shachaf> üòé
00:47:18 <johnw> wonder why it showed me that other one before...
00:47:49 <johnw> Unicode is too bizarre
00:48:15 <johnw> why isn't there a SMILING FACE WITH SUNGLASSES WITH FRECKLES
00:48:23 <shachaf> 1F06E   DOMINO TILE VERTICAL-01-04     [<U+1F06E>]
00:48:33 <johnw> doh
00:54:03 <sheldonh> woot! i cracked the non-monadic json parser without reading chapter 5 :) :) :)
00:54:45 * hackagebot quicklz 1.5.0.10 - QuickLZ compression for ByteStrings  http://hackage.haskell.org/package/quicklz-1.5.0.10 (AustinSeipp)
01:01:40 <Enigmagic> sometimes i'm glad my terminal doesn't have unicode support enabled :P
01:03:51 <Z`> I'd like to write a function that reverses the elements of a list
01:04:01 <Z`> I suppose in-place swaping is disallowed
01:04:07 <Z`> given that functions can't have side-effects
01:05:00 <shachaf> The short answer to that is "yes".
01:05:13 <shachaf> Write a function that takes a list and makes a new reversed list.
01:05:25 <Enigmagic> @src reverse
01:05:25 <lambdabot> reverse = foldl (flip (:)) []
01:05:34 <Z`> alright cool . thanks shachaf for the advice
01:05:51 <Z`> I will just traverse a list and prepend the current element to the new one
01:05:59 <Z`> with the ':' operator
01:07:23 <Dashkal> indeed that's the way.  One traversal required and you're done.
01:08:57 <johnw> sometimes cabal is bizarre
01:09:05 <johnw> I run cabal test, it detects that it needs to reconfigure
01:09:11 <johnw> but then it configures without --enable-tests
01:09:23 <johnw> so it then says, "Did you remember to configure with --enable-tests?"
01:09:32 <johnw> dude, you just did the auto-configure for me *because I asked to run tests*
01:09:44 * johnw shoots self
01:09:44 <Enigmagic> johnw: i think that is fixed in the main git repo
01:09:54 <Enigmagic> cabal-install is not my friend though.
01:10:08 <Z`> Should I use recursion and let ghc do the tail call elimination ?
01:10:32 <Z`> besides reursion and map I can't remember any other way to visit the leements of a list
01:11:10 <shachaf> map is a recursive function.
01:11:31 <shachaf> Anything you do on lists will eventually reduce to some recursive definition.
01:11:39 <Z`> mm ok
01:13:33 <johnw> Enigmagic: where is the main git repo?
01:15:54 <statusfailed> > take 10 $ let x = 1:x in x
01:15:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
01:15:59 <statusfailed> it's STILL MAGIC ;_;
01:16:45 <Z`> oO
01:16:52 <Z`> isn't x = 1:x in x infinite ?
01:16:57 <statusfailed> yeah, hence "take 10"
01:17:03 <shachaf> Which part is magic?
01:17:08 <Enigmagic> > take 10 . fix $ (1:)
01:17:11 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
01:17:12 <statusfailed> defining values in terms of themselves
01:17:15 <statusfailed> I just can't get around it
01:17:19 <Dashkal> Z`: That's the beauty of lazy evaluation.  While it's infinite, only as many as were requested will be calculated.
01:17:26 <Z`> neat
01:17:38 <Enigmagic> johnw: https://github.com/haskell/cabal
01:17:43 <statusfailed> for some reason accepting recursive functions is just fine though :P
01:18:07 <johnw> Enigmagic: thank you
01:18:13 <Dashkal> statusfailed: let x = x in x :P
01:18:29 <shachaf> statusfailed: x = ?
01:18:36 <johnw> statusfailed: think of x as a nullary function, and there should be no problems
01:18:37 <shachaf> Examine x, see that it's a (:)
01:18:41 <shachaf> Now you know that x = (:) ? ?
01:18:48 <shachaf> Examine the first ?: x = (:) 1 ?
01:19:02 <shachaf> Examine the ?: x = (:) 1 ((:) ? ?)
01:19:04 <shachaf> And so on.
01:19:19 <johnw> > take 1 $ let x = x in x
01:19:20 <statusfailed> I can make myself "get it", I just seem to have an aversion to it :P
01:19:22 <lambdabot>   mueval-core: Time limit exceeded
01:19:42 <Dashkal> johnw: let x - x in x is bottom.  Nothing can come from that.
01:19:45 * hackagebot svndump 0.4.1 - Library for reading Subversion dump files  http://hackage.haskell.org/package/svndump-0.4.1 (JohnWiegley)
01:19:49 <Z`> would I need some sort of accumulator to save the new list as I construct it ?
01:20:00 <Dashkal> @type foldl
01:20:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:20:04 <Dashkal> Z`: ^^
01:20:09 <johnw> yeah, I had guessed it was yhea
01:20:15 <Z`> thanks, I will read on foldl
01:20:19 <johnw> guessed it was ‚ä•
01:20:44 <Dashkal> I miss xcompose when in windows sometimes.  I have compositions for bottom and lambda
01:20:52 <johnw> Z`: no, you don't need an accumulator
01:20:56 <shachaf> Why is everyone recommending foldl when Z` is trying to figure out how to do this themselves?
01:21:17 <johnw> return "x:...", where ... is a recursive call to get the rest of the list
01:21:22 <shachaf> Z`: An accumulator would be the "standard" way of doing it. At least, that's how you'd implement what you described before.
01:21:46 <shachaf> It's also how the standard library reverse is implemented.
01:21:47 <Anpheus_> Suppose I am constructing a library wherein I want the user to be able to specify the "action" separate from the "types" involved, such that I want a syntax that looks like this:
01:21:48 <Z`> I thougt something like:  myReverse :: [a] -> [a]   and then   myReverse [x] = [x]    and myReverse (x:xs) = ... <-- remains to be written :P
01:22:12 <Anpheus_> char '<'    .> TagOpenState
01:22:18 <shachaf> Z`: You don't need a special case for a one-element list. Just for the empty list and for a nonempty list.
01:22:27 <Z`> ok
01:22:40 <johnw> myReverse (x:xs) = (myReverse xs)++[x], that's accumulator free, if inefficient
01:22:46 <Anpheus_> Where TagOpenState is an n-ary data constructor. Is there an easy way to specify "the constructor" TagOpenState in one place
01:22:49 <nobdrais1ntone> I'm using bytestring for text that possibly contains UTF-8, is it ok?
01:23:05 <Anpheus_> and then have (via typeclasses, etc) the consequence of the action elsewhere?
01:23:54 <Z`> If I omit the 1 element special case I get a non-exhaustive pattern in the function though
01:24:04 * shachaf wonders why, when someone has a good algorithm and asks questions about how to implement it, people say "no, here's a bad algorithm instead!".
01:24:06 <Z`> whereas with specializing 1 element list, it works
01:24:17 <shachaf> Z`: If you're matching on both foo [] and foo (x:xs), that should never happen.
01:24:26 <Botje> nobdrais1ntone: if you don't plan on manipulating the text, no.
01:24:29 <shachaf> If you're only matching on foo (x:x':xs), it might happen. But you shouldn't need that.
01:24:36 <johnw> shachaf: because more examples can sometimes help understanding
01:24:45 <Z`> oh you were right shachaf . thanks
01:25:00 <Botje> if it's just for dumping to a file or piping to an utf-8-capable prorgam, doesn't make sense to decode and encode again
01:25:02 <Dashkal> Z`: matching on (x:xs) will match one element.  x will be the element, and xs will get  []
01:25:36 <triyo> What is the easiest way to fold over [IO a]?
01:26:02 <johnw> sequence it
01:26:03 <shachaf> What does that mean?
01:26:27 <johnw> xs <- sequence <some [IO a]>
01:26:33 <shachaf> The easiest way to fold over [IO a] is foldr, just like any other list.
01:26:43 <shachaf> @src sequence
01:26:44 <lambdabot> sequence []     = return []
01:26:44 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:26:44 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
01:26:47 <johnw> return foldl f [] xs, etc.
01:26:55 <johnw> return $
01:26:57 <shachaf> (What?)
01:27:03 * shachaf sighs.
01:27:26 <johnw> you know, you could explain yourself rather than just expressing displeasure so often, shachaf
01:27:46 <triyo> Oh nice, `sequence' is cool Monad m => [m a] -> m [a]
01:27:53 <triyo> Thanks
01:28:06 <shachaf> It won't help.
01:28:17 <johnw> oh, it will
01:28:19 <Enigmagic> johnw: sequence is also a prime source of thunk chains.
01:28:30 <johnw> Enigmagic: that's good to know, and informative, thank you
01:28:40 <Enigmagic> for strict monads
01:29:05 <johnw> because it ruins the laziness of the list?
01:29:11 <Enigmagic> yeah
01:29:14 <johnw> makes sense
01:29:24 <Enigmagic> [IO a] is better served by foldM
01:29:56 <johnw> is IO strict?
01:30:32 <Enigmagic> yeah unless you use unsafeInterleaveIO
01:30:36 <triyo> Enigmagic: Thanks for that info regarding foldM
01:30:56 <johnw> i tend to not prefer functions that start with unsafe
01:30:57 <Enigmagic> IO is really meant to be strict though
01:31:03 <johnw> they should have called it buggyPerformIO
01:31:31 <Dashkal> yourProgramWillExplodeInFunAndInterestingWaysIO
01:31:39 <shachaf> johnw: The reason it's called that is that you shouldn't use it.
01:31:41 <statusfailed> acmeLaunchMissilesIO
01:31:41 <johnw> that's even better
01:32:02 <Z`> Quite often I get from ghci that ... no instance for <some type> ... possible fix: add an instance declararion for <same type> ... etc. What does this mean in noob's terms ?
01:32:13 <johnw> earnTheGlaringYetSubduedDisapprovalOfShachafOnPoundHaskellIO
01:32:38 <shachaf> Z`: That you have a type error.
01:32:53 <shachaf> (Can't say much more without seeing the code and the error.)
01:32:58 <statusfailed> ¬£haskell?
01:33:01 <johnw> Z`: It wants something that is a member of the some type type class, but your type is not an instance of some type
01:33:21 <shachaf> Z`: Are you writing explicit signatures on all your functions? If not, you should do it. It helps.
01:33:23 <johnw> not that the fix is not always to make it an instance
01:33:26 <johnw> note
01:33:27 <Z`> alright. thanks. I was under the impression that it couldn't just print the result unless I told it how to do that (for 'complex' types)
01:33:30 <shachaf> Helps you think about your code, that is.
01:33:35 <Z`> shachaf: I am
01:33:44 <Z`> although others said that thye should be omitted
01:33:47 <johnw> let me guess, the some type in question is Show?
01:33:58 <Z`> johnw: very often yes
01:34:06 <johnw> add deriving Show to your data type, if it isn't there already
01:34:16 <johnw> also, functions are unprintable
01:34:26 <Z`> ah ok
01:34:28 <johnw> and sometimes if you forget an argument you'll end up with a function value where you don't expect one
01:34:44 <johnw> (can you tell I get that same error for these reasons all the time?)
01:35:02 <Enigmagic> johnw: unless someone directly or indirectly imported Text.Show.Functions..
01:35:09 <johnw> waaa?
01:35:12 <johnw> what the heck is that?
01:35:15 <Enigmagic> then you get a very unhelpful Show instance for (a -> b)
01:35:39 <johnw> haha
01:35:41 <johnw> <function>
01:35:42 <johnw> that's cute
01:35:49 <Enigmagic> yeah, cute. that's the right word.
01:36:06 <magnus__> :)
01:36:10 <johnw> they should have made it #<function>, just to make us Lispers happy
01:36:11 <Enigmagic> (Typeable a, Typeable b) => Show (a -> b) would have been better
01:36:13 <shachaf> For my next trick: Text.Read.Functions
01:36:19 <magnus__> Had no idea you could print functions
01:36:21 <Z`> johnw: that was my expectation
01:36:35 <shachaf> Enigmagic: Except every non-concrete use of it would be terribly ambiguous.
01:36:45 <Enigmagic> shachaf: every use of it is terrible
01:37:11 <Enigmagic> i'd prefer that it was removed from base or whatever package it's in
01:37:15 <eikke> props if you write a Read instance as well
01:37:17 <johnw> at least now I can do map (+) [1,2,3] and see something with the right shape
01:37:26 <johnw> adding Text.Show.Functions to my .ghci...
01:38:56 <johnw> night all
01:39:52 <shachaf> Enigmagic: Wait, it's in base?
01:40:15 <shachaf> Weird.
01:40:22 <Enigmagic> shachaf: yes
01:40:45 <Enigmagic> ask me how i know!
01:41:01 <shachaf> Hah, and the instance for NHC is completely different.
01:41:15 <shachaf> How do you know?
01:42:15 <Enigmagic> someone called me over and was like "where the f%*@ is this <function> string coming from?"
01:42:39 <Enigmagic> printf debugging gone bad
01:42:54 <shachaf> Ah, things can indirectly import it without introducing an extra dependency.
01:43:46 <Enigmagic> yeah and a few packages out there import it
01:44:33 <Enigmagic> thus the ophan instances come out to torment our development staff after long nights coding :P
01:45:09 <shachaf> Is "our development staff" still you and one other person? :-)
01:45:26 <shachaf> Perhaps there should be a way to make instances "hidden" in a module for the purpose of type-checking.
01:45:28 <Enigmagic> nah there have been 3 of us for over a year and a fourth for a few months now
01:45:50 <shachaf> So you couldn't import new ones, but things that rely on those instances wouldn't type-check.
01:46:07 <shachaf> Ah, neat.
01:46:11 <AfC> aeson is rapidly becoming the de-rigour Haskell library for parsing JSON into records, but what happens if you want to load some JSON and just poke at various fields that may or may not be present? Can you still use aeson?
01:46:36 <Enigmagic> AfC: sure, just use the Value type directly
01:47:51 <AfC> Enigmagic: so instead of decode and encode, you use, er json?
01:48:33 <AfC> Calling attoparsec manually maybe?
01:49:21 <Enigmagic> AfC: yeah i think so, i can dig up the code we have if you can't figure it out
01:51:59 <Enigmagic> AfC: ok... we're using conduits but it's basically the same as running Data.Attoparsec.ByteString.parseOnly Data.Aeson.json' yourByteStringHere
02:00:46 <AfC> Enigmagic: ah, got it
02:01:14 <AfC> Enigmagic: I've had the impression that (since aeson came second) everyone already knew how to use attoparsec and so its assumed.
02:02:07 <Enigmagic> AfC: "everyone" ...
02:02:15 <AfC> yeah, exactly
02:02:33 <Enigmagic> i found the assumption terrible at the time and still do
02:02:55 <AfC> Enigmagic: I should probably write a documentation patch for bos and send it along.
02:03:02 <AfC> [assuming I figure it out :)]
02:03:49 <Enigmagic> a more useful set of helper functions might be in order too. i've answered related questions before on SO, it's a common enough problem that it should warrant more than doc fixes
02:04:02 <Enigmagic> i just like to sit on the sidelines and complain :-)
02:05:47 <Enigmagic> anyways probably bed time for me
02:05:51 <f4m8> as an pesonal exercise i write a little progamm. now i stuck at the function definiton
02:06:15 <shachaf> Wait, what's the question here?
02:06:21 <shachaf> How to decode to a Value?
02:06:31 <f4m8> i want to habe a function which returns a float and use two in vars; one a integer the second a float
02:06:51 <f4m8> "motor2raddrehzahl :: Float a => a ‚Üí a ‚Üí a"
02:06:55 <shachaf> f4m8: fromIntegral :: Integer -> Float
02:07:16 <Enigmagic> shachaf: yeah
02:07:16 <shachaf> Alternatively, round/truncate/floor/ceiling/... :: Float -> Integer
02:07:31 <shachaf> Enigmagic: Why not use decode?
02:07:49 <f4m8> "motor2raddrehzahl :: Float ‚Üí Integer" will do the trick?!?
02:07:54 <f4m8> i try it...
02:08:00 <shachaf> instance FromJSON Value
02:08:18 <Enigmagic> shachaf: oh right
02:08:20 <Enigmagic> that'd work too
02:09:04 <Enigmagic> just about every time i remember about that instance i forget about it :-)
02:09:06 <shachaf> (I was about to say: You can define your own newtype Foo = Foo Value and define a FromJSON instance for it. Then I realized that Value probably already has that.)
02:10:26 <Enigmagic> anyways bed time for me
02:11:38 <AfC> Enigmagic: thanks for your help
02:12:41 <AfC> shachaf: the problem class I have is that (my impression based on my testing so far) aeson seems very unforgiving of schema change
02:13:12 <AfC> shachaf: if you're using the decode / encode methods
02:13:17 <shachaf> AfC: Aeson will give you a Value, which you can do whatever you want with.
02:13:42 <AfC> [not to mention getting Nothing out of the parse and not an error message to be seen for miles, but that's performance related, I gather. Still]
02:14:31 <AfC> shachaf: well, aeson highlights at some length using encode / decode and the two related classes, right? That's fine if you are marshalling known schema into a defined data type
02:14:51 * shachaf doesn't know much about Aeson specifically.
02:14:52 <AfC> but if there's anything at all unusual about your incoming data you're kinda up the creek
02:16:16 <adimit> does compiling something with profiling enabled make normal execution slower?
02:16:19 <kstt> diffListsBy :: [a] -> [b] -> (a -> b -> Bool) -> ([a],[(a,b)],[b])   --  does not seem to be known by hayoo or hoogle. It gives a nice interface to diff a couple of lists and get ( what is missing, what is common, what appeared ).
02:16:38 <Z`> Is there a way to tell haskell print all the intermediate calculations?
02:17:04 <adimit> Z`: look at Debug.Trace, and at the ghci debugger.
02:17:13 <Z`> for example when I write foldl (flip (:)) [] [1,2,3,4] I'd like to print the contents fo the accumulator in every recursive step
02:17:15 <kstt> Z`: for debugging purpose, use debug.trace
02:17:15 <Z`> ah.
02:17:19 <Z`> thanks adimit / kstt
02:17:20 <shachaf> kstt: That type signature is pretty ad-hoc-looking -- I wouldn't expect to see it it in the standard library.
02:17:36 <shachaf> > foldl (flip f) z [1,2,3,4]
02:17:38 <lambdabot>   f 4 (f 3 (f 2 (f 1 z)))
02:18:01 <Z`> hah neat
02:18:13 <Z`> what does 'z' mean here ?
02:18:14 <shachaf> kstt: Is this for two lists that are the same length, or what?
02:18:22 <shachaf> Z`: It's just a letter.
02:18:27 <shachaf> > foldl (flip f) x [1,2,3,4]
02:18:29 <lambdabot>   f 4 (f 3 (f 2 (f 1 x)))
02:18:30 <Z`> ok :)
02:18:52 <Z`> haskell has assigned much meaning to cryptic symbols, so I wondered it had any special meaning. :D Thanks!
02:19:07 <kstt> shachaf: no, it is for two sets indeed
02:19:26 <AfC> anyway, Enigmagic was quite helpful in explaining you can use attoparsec to run the JSON parser and then work with the resultant Value. I expect that'll do the trick.
02:19:26 <AfC> shachaf: [it's just that doing so is not explained in the aeson docs at all]
02:19:27 <AfC> shachaf: [they emphasize marshaling into and out of types, which is wizard cool so long as your types and the incoming data correlate perfectly]
02:20:07 <shachaf> kstt: I don't understand the behavior of that function off-hand. :-)
02:21:50 <ocharles> is there an already made instance Traversable Identity anywhere?
02:22:30 <ocharles> aha, Data.Functor.Identity
02:22:36 <shachaf> Yes.
02:22:38 <kstt> shachaf: let's pretend your application user selected a collection of discs, and you stored his selection as a set of disc ids. Later he want to change his selection, so the app display the selection, and he tick and untick items. The application receive the new list of Discs, and needs to act upon (discs that must be removed, discs that stayed in the selection, discs that have been added).
02:23:07 <shachaf> kstt: You can probably describe your function much more concisely with code and/or examples than with prose. :-)
02:23:24 <kstt> probably yes :)
02:24:51 <kstt> I happen to need to do that very often, but that's probably because I work mainly on web interfaces
02:25:32 <shachaf> I don't think it has anything to do with web interfaces...
02:26:07 <shachaf> But I still don't know what your function does.
02:26:43 <shachaf> Oh, maybe I see. For each x :: a, if your predicate is true for any b, it puts it in the [(a,b)], else in the [a]?
02:29:54 <Dashkal> That function looks familiar.  Somewhat more general version of "venn" I had to write some months back.
02:34:38 <Jafet> diffLists a b = (a \\ ab, ab, b \\ ab) where ab = intersect a b
02:34:56 <Jafet> ...which isn't general enough
02:37:48 <Dashkal> nope.  His allows the lists to be of differing types.  Kinda nifty.  To generalize one step further: [a] -> [b] -> (a -> b -> Maybe c) -> ([a], [c], [b])
02:41:07 <kstt> Yes, this is a diff for a couple of heterogeneous sets. I usually have to act upon removed elements, and inserted element. These two actions are very differents, and naturaly act on different types. This function serves well this purpose.
02:41:07 <Jafet> This is premature generalisation
02:42:28 <kstt> As explained above, for web applications, when the user select a collection, I always have to run this type of function to delete models and create new ones.
02:42:43 <Dashkal> kstt: You do have a nasty situation, however.  the sum of the lengths of the final lists does not need match the sum of the lengths of the input lenghts (a given item from the a list may find more than one matching b)
02:43:28 <kstt> indeed, this is for Sets actually
02:43:55 <kstt> oh, I missed your point
02:44:02 <Dashkal> this applies to sets, or any other traversible for that matter.  The middle collection can have 0 though len a * len b items.
02:44:11 <kstt> indeed
02:46:28 <AfC> adimit: I remember reading that building with profiling doesn't, though I must admit I'm dubious. Certainly the code size will be bigger. The question is whether profiling gets in the way of any optimizations.
02:46:47 <AfC> adimit: certainly if there's one language I'd trust to be honest about it either way, it'd be Haskell.
02:48:03 <Dashkal> Time to sleep, but I think this is an interesting problem.  I wonder if there's a way to type encode the two ways of handling that function (items may match zero or once, items may match as many times as possible).
02:48:06 <kstt> Dashkal: the implementation could be such as at most one element of B will match A
02:48:36 <kstt> no static guarantee however, but we don't word with dependant types :)
02:48:38 <Dashkal> Oh yes, it's just that the implementation is ambigious from the types, and that bothers me :P
02:49:12 <kstt> intersect itself has no such guarantee
02:49:18 <Dashkal> Well, the type system is turing equivalent, so it /can/ be done.  It's just an interesting mental excercise figuring out a way to do it is all.
02:49:36 <Jafet> Turing equivalence doesn't mean anything in this context
02:49:50 <Jafet> You want a type that expresses isomorphism between a and b
02:49:52 <Dashkal> Jafet: it's enough that I can write a type function that calculates in one way or the other.
02:49:59 <Jafet> Well not that
02:50:15 <Jafet> A bijection between a and b
02:50:51 <Jafet> -> (Set a, Map2 a b, Set a)
02:51:18 <Dashkal> in any event, I must be up in 7 hours.  sleep time
02:51:24 <adimit> AfC: I don't exactly understand the process of putting in profiling information.
02:51:25 <Jafet> s/a)/b)/
02:52:10 <ocharles> 'arr (Identity . lens) ^^^ getCountry >>> demap >>^ runIdentity' Haskell, you're getting scarily close to line noise!
02:52:15 <adimit> it wasn't so important anyway. I was just wondering whether it might be detrimental to enable profiling by default in ~/.cabal/config
02:52:20 <ocharles> but I am falling in love with arrows, so I'll let it go
02:53:04 <Jafet> That looks more like befunge than line noise
02:53:55 <adimit> to be fair, the difference between befunge and line noise can be rather‚Ä¶ difficult to make out.
02:55:14 <nand`> ocharles: ain't line noise till you mix in some applicative style
02:55:52 <ocharles> i've written so much applicative that reads nicely now. but arrows are new so it takes a fair bit of mental parsing
02:56:02 <ocharles> especially when I invent my own combinators like (^^^)
03:00:34 <adnauseam> is there way to let ghci not get stuck on computing large numbers ?
03:00:57 <adnauseam> or is that a sign of me hitting some bound?
03:02:22 <nand`> what's a good type to use for storing a large sequence of items accessible in constant time with an integer corresponding to their location in the sequence? Array? The motivation is for a simulation of a state machine that has a large instruction sequence and a program counter, at each step the program counter is used to retrieve the next instruction from the instruction sequence and incremented by one
03:03:30 <Jafet> ghci cannot interrupt gmp calls, so it has to wait for the current one to finish
03:03:54 <Jafet> If for some reason the current call has stupidly large operands or results
03:04:04 <adimit> nand`: do you have to change the allocation size (frequently?)
03:04:17 <nand`> adimit: no; the code is read only
03:05:05 <adimit> nand`: then i really would go for an array. Esp. if it's read-only. IntMap would be the only other thing that comes to mind, but that one doesn't have constant lookup.
03:05:28 <Z`> mm, I'm writing a function to check if a list is palindrome. I was lured to do list == reverse list, but haskell doesn't know how to compare with ==
03:05:32 <Jafet> Actually, I can interrupt large calculations. Does ghc use pow_ui?
03:05:52 <Jafet> :t (==)
03:05:53 <lambdabot> forall a. (Eq a) => a -> a -> Bool
03:06:27 <Z`> No instance for (Eq a) arising from a use of `=='
03:06:41 <adimit> Z`: every list has type [a], i.e. a list of a, whatever a is. Now you need to make sure that a is an instance of class Eq. Most data types in Prelude are, but if you're using a custom one, you need to derive an instance for that.
03:06:53 <adimit> so something like data Foo = ‚Ä¶ deriving (Eq)
03:07:05 <Z`> a ha. alright, let me check my book. I recall reading on that topic. Thansk!!
03:07:13 <Jafet> Or z's type signature just doesn't have Eq
03:08:28 <adimit> Right. Though we'd need to have a look at the code in order to find out.
03:10:16 <Tinned_Tuna> Hi, does anyone in here work for Jane Street Capital? I'm sure I had a conversation with someone in here or ##proggit about them...
03:10:58 <Tinned_Tuna> (as in, we spoke about the company)
03:11:09 <Z`> I just wrote:   isPalindrome :: [a] -> Bool   isPalindrome [] = True        and then isPalindrome list = list == (reverse list)
03:11:23 <ivanm> Tinned_Tuna: there might be, but they tend to use OCaml if memory serves rather than Haskell
03:11:33 <Tinned_Tuna> ivanm: aye, they do use ocaml
03:11:34 <adimit> Z`: then you indeed need to put the Eq constraint in the type sig.
03:11:49 <adimit> Z`: isPalindrome :: (Eq a) => [a] -> Bool
03:11:50 <nand`> > [] == reverse []
03:11:51 <lambdabot>   True
03:11:54 <nand`> no need to specialcase it
03:12:19 <adnauseam> yeah, prime factorization
03:12:29 <Z`> it worked. thanks!
03:12:32 <adnauseam> i'll ctrl-c it
03:12:50 <Z`> thanks nand`
03:12:59 <adimit> don't tell me, your ghci is factorizing *ad nauseam*‚Ä¶
03:13:26 <adnauseam> *nods*
03:13:32 <Jafet> I thought you were saying that C-c didn't interrupt it
03:13:39 <Jafet> That happens sometimes
03:14:22 <DeadPanda> Hi, I'm having what's probably a very basic issue in my understanding of Haskell.  I've defined an ADT to represent the concept of "privilege", and derived Ord to give me a total-ordering on the set in terms of lexographical order
03:14:40 <adnauseam> hah, this algorithem is awesome
03:14:54 <adnauseam> it's pretty impressive
03:15:03 <Tinned_Tuna> is there a log of this channel?
03:15:12 <adnauseam> i think the problem with it taking so long is finding the primes
03:15:15 <DeadPanda> But... the ordering isn't total -- comparison between pairs that appear lexographicaly adjacent are fine, but given, for example data Privilege = Unprivileged | Privileged | Administrator deriving (Eq, Ord), comparing Unprivileged <= Administrator fails with a non-exhaustive pattern error
03:15:21 <ivanm> Tinned_Tuna: see the topic
03:15:32 <ivanm> but you said you were talking in ##proggit
03:15:44 <Tinned_Tuna> ivanm: it was either here or ##proggit
03:15:50 <Tinned_Tuna> so I am checking both :-p
03:15:51 <ivanm> *nod*
03:15:54 <ivanm> fair enough :)
03:15:57 <Jafet> Yes, you need to find the prime factors to do prime factorization. This step tends to take up most of the time
03:16:01 <Tinned_Tuna> that's how fuzzy my memory is!
03:17:22 <Jafet> panda: that's supposed to work
03:17:28 <DeadPanda> Jafet, I thought so too
03:18:07 <DeadPanda> Jafet, in that example, Unprivileged < Privileged, and Privileged < Administrator return the proper results -- is there any way I can dig into the assumptions/code generated by deriving (Ord)?
03:18:34 <Jafet> You can look at the ghc core, but you shouldn't need to
03:18:52 <Jafet> If the problem is as you described, then it's a bug
03:18:56 <ivanm> Tinned_Tuna: I tried to see if they had a listing of staff to see if any names looked familiar from here, but they don't seem to publish that information :/
03:19:21 <Jafet> The haskell report defines what derived Ord does, and it does what you expect
03:19:26 <DeadPanda> I'm running the latest Haskell Platform (2012.2.0.0) on Win_x86_64, and it's such a simple statement I can't see how I've gotten it wrong -- mind if I stick it up on a pasteboard just to have another pair of eyes look at it?
03:20:55 <adimit> DeadPanda: sure, you can use hpaste, it's in the /topic.
03:21:01 <hpaste> Jafet pasted ‚ÄúChaos‚Äù at http://hpaste.org/73972
03:21:18 <Jafet> That program works for me
03:21:41 <adimit> me too.
03:22:12 <hpaste> DeadPanda pasted ‚ÄúError in deriving (Ord)‚Äù at http://hpaste.org/73973
03:22:49 <DeadPanda> Jafet, hmm, could be my build, I'll fire up the mac and try it on there
03:22:55 <Z`> does haskell have namespaces or some other method for avoid symbol conflicts? I end up often defining my stup with 'my' prepended, whichi is boring
03:23:02 <Jafet> panda: run the program I pasted
03:23:10 <Z`> stup=stuff*
03:23:21 <Jafet> Haskell has a module system
03:23:27 <hpaste> DeadPanda pasted ‚ÄúOutput from sample statement‚Äù at http://hpaste.org/73974
03:23:31 <Z`> alright, modules then. thanks Jafet
03:24:04 <Botje> Z`: you are probably conflicting with functions defined in the haskell prelude
03:24:09 <DeadPanda> Jafet, will do
03:24:39 <Jafet> Well, you probably don't want to name your type Int (even though there are packages that do that)
03:25:18 <DeadPanda> Jafet, heh, that program's fine -- it was something stupid in how I was testing the code in ghci. /sigh/ a lot to learn about the language, thanks
03:26:09 <Jafet> Now with that out of the way, you can ask about the actual problem
03:28:04 <DeadPanda> Oh, there is none, that was it thanks -- the rest I can roughly figure out myself (the algorithm I'm implementing is O(N!) anyway, so I can't go too far wrong)
03:32:41 <squidz> which html templating does the haskell community prefer right now
03:32:58 <squidz> be it with snap or yesod
03:34:08 <lpvb> certainty: no
03:34:25 <lpvb> certainty: no
03:34:47 <lpvb> oh
03:35:03 <lpvb> I had the irc scrolled up, ignore me
03:35:19 <lpvb> no wonder the chat wasn't moving for a long time
03:35:21 <lpvb> :)
03:35:59 <vleis> as I have gathered from the book so far, yesod uses hamlet which is part of shakespear
03:36:17 <vleis> whether that is the preferred templating solution for html is another matter
03:36:32 <Z`> hm, in lisp I can create a list of inhomegenous elements. example:  (list 1 (list 2 (list 3)))
03:36:38 <Z`> how could I do that in haskell ?
03:36:57 <Z`> goal is to create a list with variable-depth nested lists so as to then write a flatten function
03:38:43 <Z`> unless.. I'd have to define a new data tuype
03:38:44 <Z`> like
03:39:27 <shachaf> Z`: That's called a "tree" in Haskell. :-)
03:39:28 <Z`> data MyList x = Elem x | List [MyList x]
03:39:31 <Z`> oh
03:39:37 <Z`> ok :)
03:39:45 <shachaf> That MyList data type defines a tree, if you look at it.
03:40:35 <mauke> :t Node
03:40:36 <lambdabot> forall a. a -> Forest a -> Tree a
03:41:08 <mauke> Z`: flatten functions are useless
03:41:37 <Jafet> You can define a heterogeneous list, but it is rather useless.
03:41:54 <Z`> useless as it may be, it is a nice exercise on basics of haskell
03:42:03 <Jafet> data List = Nil | Cons (forall a. a) List
03:42:09 <mauke> Z`: I disagree
03:42:16 <Z`> haskell has cons too? nice ;)
03:42:18 <Jafet> It is so useless that you can't get anything useful out of one
03:42:22 <mauke> Z`: no
03:42:35 <Jafet> The type of each item is just forall a. a
03:43:36 <shachaf> Jafet: Why is that a heterogeneous list?
03:43:53 <Jafet> You can put anything into the list
03:43:56 <shachaf> Wouldn't data List = Nil | forall a. Cons a List be heterogeneous?
03:44:14 <shachaf> It seems to me like you can put nothing* into the list.
03:44:16 <int-e> you can't do anything with elements of the list ;)
03:44:33 <Z`> so should I skip the excersise ?
03:44:33 <int-e> Cons undefined Nil
03:44:34 <Jafet> I don't remember where the quantifier goes
03:44:42 <mauke> Jafet: depends on what you want to do
03:44:51 <mauke> Z`: what exercise?
03:44:54 <shachaf> Cons (forall a. a) List means that Cons :: (forall a. a) -> List -> List
03:45:04 <int-e> Jafet: you need an auxilliary existential, data Box where Box :: a -> Box.
03:45:08 <Z`> mauke: of writing a flatten function
03:45:11 <shachaf> Z`: You shouldn't use a lisp book to learn Haskell.
03:45:18 <Jafet> Well, the list is useless either way so
03:45:22 <mauke> Z`: where did you find that exercise?
03:45:31 <Z`> in the www.haskell.org site
03:45:41 <mauke> where?
03:45:48 <Z`> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
03:46:00 <int-e> and then the list is just [Box]. But it's useless, because you can put anything inside, but not do anything useful with the elements later on.
03:46:16 <shachaf> In particular, problem 7.
03:46:20 <mauke> Z`: that doesn't contain "flatten"
03:46:30 <Z`> sosrry try http://www.haskell.org/haskellwiki/99_questions/1_to_10
03:46:49 <shachaf> Those are ported from 99 lisp problems or 99 Prolog problems or 99 INTERCAL problems or something.
03:47:02 <shachaf> Their own solution uses a tree instead of a list.
03:47:12 <shachaf> Writing flatten :: Tree a -> [a] might be a reasonable exercise.
03:47:14 <int-e> Z`: that's a different type: data Nest a = Elem a | List [Nest a]
03:47:37 <mauke> yes, that problem sucks
03:48:05 <int-e> or, using more standard names: data Tree a = Leaf a | Node [Tree a]
03:48:25 <mauke> @src Tree
03:48:25 <lambdabot> Source not found. Take a stress pill and think things over.
03:48:28 <mauke> aw
03:48:33 <int-e> That's what the problem is, really: flatten a tree.
03:48:38 <Z`> ok
03:49:02 <mauke> data Tree a = Node a [Tree a]
03:49:15 <Z`> what would the type signature be?  flatten :: Tree a -> [a] ?
03:49:20 <mauke> yes
03:49:25 <Z`> thanks
03:49:30 <int-e> mauke: well this one has labels at the leafs, not at internal nodes
03:50:19 <mauke> yes, but it's what lambdabot uses :-)
03:50:28 <int-e> (so yeah, it's not the same as Data.Tree.Tree)
03:50:51 <int-e> It's the other kind of trees *ducks*
03:51:37 <shachaf> data Val a = Atom a | Nil | Cons (Val a) (Val a)
03:51:47 <shachaf> If you want to mirror lisp more exactly. :-)
03:51:53 <shachaf> (A little bit more, anyway.)
03:52:08 <Z`> silly question, offtopic: would be easier to implement haskell in lisp or the other way around ?
03:52:10 <shachaf> Of course, (flatten (cons 1 2)) should probably not be allowed.
03:52:27 <shachaf> Z`: No.
03:53:07 <mauke> I think implementing lisp in haskell would be easier
03:53:21 <mauke> writing a naive interpreter is pretty straightforward
03:53:46 <shachaf> Haskell is a more complicated language. That's true.
03:54:00 <shachaf> But that has nothing to do with the implementation language.
03:54:09 <Jafet> I don't want to implement Common Lisp in any language
03:54:28 <int-e> because common lisp is big and ugly?
03:55:32 <mauke> because it's an incomplete, bug-ridden, and slow version of half of perl5
03:55:43 <int-e> (This was my impression when I looked at it. It's quite a complicated standard, but it comes with the attitude that all the world is lisp - there is no /common/ FFI.)
03:56:06 <shachaf> mauke: What about implementing Perl 5 in Haskell or implementing Haskell in Perl 5?
03:56:09 <mauke> CL wasn't designed for the world
03:56:23 <shachaf> Obviously the latter is easier because the former is impossible.
03:56:32 <mauke> there's an assumption that letters are A-Z, etc
03:57:16 <int-e> shachaf: why impossible?
03:57:58 <Jafet> You can't implement perl 5 because it is the implementation
03:58:55 <mauke> perl5 doesn't really exist in a fundamental sense
03:59:24 <shachaf> Hah, apparently the Perl 6 version of "Only perl can parse Perl" is "Only Perl 6 can parse Perl 6"
03:59:29 <shachaf> (With that capitalization.)
03:59:43 <mauke> only Lisp can parse Lisp
03:59:51 <mauke> same "problem"
03:59:57 <shachaf> ?
04:00:08 <mauke> you can run arbitrary code in the parser
04:00:19 <mauke> therefore your "parser" must contain a complete lisp implementation
04:00:36 <ksf> that's easy enough to write, though.
04:00:42 <mauke> uh. right
04:00:48 <ksf> writing a perl is harder.
04:01:16 <mauke> the point is not that it's hard
04:01:21 <ksf> in fact, I'd say implementing lisp is easier than parsing haskell.
04:01:35 <mauke> the point is that you can't have a pure parser
04:04:39 <timthelion> mauke: what do you mean that you cannot have a pure parser?
04:05:20 <mauke> I mean a function String -> Maybe AST
04:05:24 <ksf> the parser needs an interpreter.
04:05:58 <ksf> ...though that's true of TH-enabled haskell, too.
04:06:07 <mauke> instead you need an abomination that may 1) fail with a parse error, 2) return an AST, 3) go into an infinite loop, or 4) have arbitrary side effects
04:06:45 <mauke> this has some funny consequences, though
04:07:25 <mauke> "BEGIN { exit; } asdhfjdksjdfh~(@(3`" is a valid perl program because it doesn't even try to parse the stuff after }
04:07:38 <mauke> I'm not sure what the equivalent Lisp is
04:08:18 <Jafet> @let e s@(_:'\\':v:'.':l)=let(x,')':t)=e$d l in(take 4 s++x++")",t);e('(':s)=let(x,t)=e s;(y,')':u)=e$d t in(a x y,u);e s=splitAt 1$d s;d=snd.spa
04:08:18 <Jafet> n(==' ');a(_:'\\':v:'.':l)s=let f x|x==v=s|1>0=[x]in fst.e$init l>>=f;a f x='(':f++" "++x++")"
04:08:18 <lambdabot>  <local>:2:34:
04:08:18 <lambdabot>      Ambiguous occurrence `e'
04:08:19 <lambdabot>      It could refer to either `L...
04:08:27 <Jafet> @undef
04:08:36 <Jafet> @let e s@(_:'\\':v:'.':l)=let(x,')':t)=e$d l in(take 4 s++x++")",t);e('(':s)=let(x,t)=e s;(y,')':u)=e$d t in(a x y,u);e s=splitAt 1$d s;d=snd.span(==' ');a(_:'\\':v:'.':l)s=let f x|x==v=s|1>0=[x]in fst.e$init l>>=f;a f x='(':f++" "++x++")"
04:08:37 <lambdabot>  <local>:1:34:
04:08:37 <lambdabot>      Ambiguous occurrence `e'
04:08:37 <lambdabot>      It could refer to either `L...
04:08:44 <Jafet> Oh
04:09:42 <timthelion> mauke: you'd just have to have a parser of type  :: String -> IO (Maybe String) and then a loop in IO.
04:09:52 <mauke> timthelion: yes. "just".
04:10:05 <mauke> at which point it's not a pure parser anymore
04:10:12 <shachaf> mauke: To be fair, Haskell functions :: String -> Maybe AST may also go into an infinite loop. :-(
04:10:44 <mauke> true, but irrelevant :-)
04:10:53 <Jafet> > let tr 's' = "(\\x. (\\y. (\\z. ((x z) (y z)))))"; tr 'k' = "(\\x. (\\_. x))"; tr x = [x] in ev $ tr =<< "(((s k) k) x)"
04:10:55 <lambdabot>   "x"
04:11:17 <mauke> the point is that most languages can be parsed in finite time without side effects
04:11:30 <shachaf> Yes.
04:11:55 <ksf> well... you could have an infinite import tree.
04:11:58 <timthelion> mauke: see befunge :D
04:12:06 <shachaf> Jafet: @src ev
04:12:19 <shachaf> Is it just 'e' from above?
04:12:23 <Jafet> ev = let e ... in fst.e
04:12:56 <shachaf> Befunge isn't hard to parse, is it?
04:13:12 <Z`> is: myf :: [a] -> [a]     different from:     myf :: [a] -> [b] ?
04:13:14 <Jafet> I don't think befunge needs any parsing
04:13:18 <Z`> from the POV of the type system ?
04:13:21 <timthelion> shachaf: it's quite hard to compile :)
04:13:29 <ksf> Z`, yes.
04:13:32 <Z`> thanks ksf
04:13:48 <ksf> well, you can treat the latter as the former, but not the other way 'round.
04:13:59 <Jafet> z: the difference is clear if you write the types out completely
04:14:00 <Z`> how can I answer such a question myself? can ghci print the type of an expression ?
04:14:08 <Z`> Jafet: how do you mean ?
04:14:09 <Jafet> forall a. [a] -> [a]; forall a b. [a] -> [b]
04:14:15 <ksf> also, myf :: [a] -> [b] has only one possible implementation, and that's rather uninteresting
04:14:22 <ksf> ( myf _ = [] )
04:14:34 <Jafet> And undefined!
04:14:46 * ksf doesn't count that as possible implementation
04:14:48 <Z`> :)
04:15:18 <Jafet> How does an infinite import tree work?
04:15:29 <mauke> ksf: how do you get an infinite import tree without infinite program source?
04:15:39 <ksf> mauke, fuse.
04:15:47 <mauke> huh?
04:15:53 <ksf> generate files on the fly.
04:16:01 <mauke> how does that affect anything?
04:16:10 <Jafet> That's infinite program source, then
04:16:12 <ksf> even a pure parser wouldn't terminate.
04:16:21 <mauke> you don't need imports then
04:16:27 <mauke> that's a straight up infinite program
04:16:43 <ksf> I never said there was a difference
04:16:53 <shachaf> perl is such a well-behaved interpreter, it can parse infinite programs in finite time.
04:17:07 <mauke> shachaf: so does ghc
04:17:31 <shachaf> It does?
04:17:48 <mauke> hmm, not quite
04:18:09 <mauke> it fails on non-boring files because it wants to get the filesize beforehand
04:18:23 <mauke> tmp.hs: hFileSize: inappropriate type (not a regular file)
04:18:34 <shachaf> If it didn't do that, how would you do it?
04:18:49 <mauke> ln -s /dev/urandom tmp.hs && ghc tmp.hs
04:19:00 <shachaf> That's failing to parse in finite time.
04:19:03 <shachaf> Not succeeding.
04:19:07 <mauke> oh, ok
04:19:09 <shachaf> (echo 'BEGIN { exit; }'; yes hi) | perl
04:19:21 <mauke> shachaf: there's an easier way
04:20:01 <mauke> echo $'\x1a'; yes hi
04:20:22 <mauke> (perl treats ^Z as a virtual EOF)
04:20:40 <shachaf> echo __END__; yes hi
04:21:13 <mauke> or that
04:21:17 <mauke> (^D also works)
04:21:41 <Jafet> Wait, you can't use ^Z as an identifier?
04:21:47 <Jafet> Who designed this language
04:21:53 <Z`> Suppoes that I'd like to create a function that would operate on a list with 2 elements only, and return a true/false.     myf :: [a] -> Bool     or I could provide a less general type instead of [a] ?
04:22:00 <Z`> like, I don't know, [a, a] ?
04:22:25 <merijn> Z`: No, you can't specify a type like that in Haskell
04:22:28 <mauke> Jafet: who said you can't?
04:22:30 <shachaf> No, you can't specify normal lists' lengths in the type system.
04:22:46 <merijn> Z`: You could define a newtype and then have a smart constructor to check the invariant, though
04:22:47 <Z`> alright. so I would have to check the length in the equation part
04:22:53 <mauke> Z`: you could use a tuple instead of a list
04:23:01 <shachaf> Z`: Alternatively, you can use (a,a) or data Pair a = Pair a a
04:23:09 <shachaf> Or some other type that represents what you mean.
04:23:10 <Jafet> mauke: it's not considered EOF then?
04:23:21 <merijn> Z`: But using a tuple/pair would be better
04:23:27 <Z`> do prelude functions operate on lists and tuples interchangeably ?
04:23:31 <shachaf> No.
04:23:32 <mauke> Jafet: correct
04:23:39 <Jafet> I see
04:23:45 <shachaf> What Prelude function are you wanting to use on a two-element list?
04:23:56 <Z`> flip for example, but others as wll
04:23:57 <Z`> well*
04:24:13 <shachaf> @ty Prelude.flip [1,2]
04:24:15 <lambdabot>     Couldn't match expected type `a -> b -> c'
04:24:17 <lambdabot>            against inferred type `[a1]'
04:24:19 <lambdabot>     In the first argument of `GHC.Base.flip', namely `[1, 2]'
04:25:11 <ksf> > let swap (x:y:ys) = y:x:ys in swap [0..]
04:25:12 <lambdabot>   [1,0,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:25:22 <merijn> flip doesn't work on tuples or lists
04:26:14 <Jafet> :t uncurry (flip (,))
04:26:15 <lambdabot> forall b a. (a, b) -> (b, a)
04:27:36 <merijn> Jafet: Sure, but that doesn't have anything to do with the question of whether flip operates on lists/tuples
04:27:47 <Jafet> You're right
04:29:47 <kekido> hey all, what ide is preferred for haskell dev on mac?
04:30:10 <tdammers> kekido: whatever you like
04:30:24 <tdammers> many folks (including myself) just use vim or emacs or some such
04:30:53 <kekido> I've heard of haskell-mode for emacs
04:31:08 <tdammers> I'm a vi person
04:31:08 <kekido> but not sure if it was available for mac
04:31:12 <tdammers> vanilla vim works just fine
04:31:15 <merijn> kekido: I personally use vim
04:31:16 <tdammers> not sure about emacs
04:31:16 <kekido> me too
04:31:37 <tdammers> there is a haskell-mode-something for vim, but I haven't bothered trying it out
04:31:40 <kekido> but thought maybe emacs might support the debugger
04:31:51 <Jafet> I'm not sure how a mode can depend on whether emacs is on mac os
04:32:15 <tdammers> Jafet: that's what I thought too, but my actual emacs experience is roughly zero
04:32:29 <kekido> emacs is shipped with osx
04:32:35 <tdammers> so?
04:32:42 <shachaf> kekido: Do you use any other programming language?
04:32:48 <shachaf> Just use that editor for Haskell.
04:32:49 <kekido> java
04:32:50 <shachaf> It'll be fine.
04:33:06 <kekido> thought eclipse might be too bulky for it!
04:33:09 <shachaf> Oh... You did say "ide", not "editor", I guess.
04:33:13 <tdammers> yeah, one of the nicer things about haskell is that it has absolutely minimal demands editor-wise
04:33:23 <shachaf> OK, then find something simple.
04:33:32 <shachaf> I know one person who used TextWrangler.
04:33:35 <shachaf> That looked simple.
04:33:35 <trio> Is there a stricter version of foldM? It blows the stack.
04:33:38 <kekido> would like something with debugger built in
04:33:52 <shachaf> There are no debuggers for Haskell. Sorry.
04:33:58 <shachaf> (The previous statement is not quite correct.)
04:34:06 <tdammers> (might as well)
04:36:53 <Z`> Is it ok to decompose a list when doing pattern mathcing like:
04:37:02 <Z`> myf (x1:x2:x3:xs) = ...
04:38:03 <timthelion> Can someone remind me of the syntax for record selectors in patterns?
04:38:13 <trio> Any ideas anyone? So I have a folM mfn init [1..reallyBigNo] and this gives me a "Stack space overflow: current size 8388608 bytes.".
04:38:18 <merijn> Isn't there a FP plugin for Eclipse?
04:38:37 <Yuu-chan> Z`: if patterns are complete, why not?
04:38:42 <timthelion> aka Foo = Foo{foo::Int,bar::String};b (Foo{bar}) = bar
04:38:45 <trio> where mfn is a Map type structure
04:39:12 <trio> Oops I mean mfn is a function that takes an accumulator of type Map.
04:39:23 <merijn> Z`: Sure, just make sure you match all patterns (but the compiler should warn you if you forget one anyway)
04:39:23 <shachaf> Z`: It's OK but based on your earlier questions it might not be the right thing to do in your case.
04:39:28 <Jafet> :t foldM
04:39:29 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:40:30 <Yuu-chan> timthelion: b (Foo {bar=b}) = b?
04:40:53 <Jafet> Perhaps mfn should pseq its argument.
04:40:53 <timthelion> Yuu-chan: it's flipped around like that?
04:41:01 <timthelion> Thanks :)
04:41:08 <int-e> timthelion: see Yuu-chan; what you wrote works as a ghc extension (NamedFieldPuns)
04:41:09 <Jafet> But I'm guessing that won't solve it
04:41:21 <shachaf> > foldM mfn init [1..reallyBigNo]
04:41:22 <lambdabot>   Not in scope: `mfn'Not in scope: `reallyBigNo'
04:41:26 <shachaf> Looks like an out-of-scope error.
04:41:34 <timthelion> Yuu-chan: thanks.
04:41:57 * timthelion wonders why it's done with the = being left to right instead of the standard right to left.
04:42:16 <Jafet> > foldM M.insert M.empty [0..99999]
04:42:17 <lambdabot>   Occurs check: cannot construct the infinite type:
04:42:17 <lambdabot>    a = Data.Map.Map a b
04:42:33 <int-e> timthelion: to match record creation.
04:43:07 <Yuu-chan> timthelion: maybe it's something like "Structure where field = someValue" semantically
04:43:43 <timthelion> OK, I guess I can see how they might have thought it up.  But for anyone with an imperitive background it is SOO backwards! :D
04:43:56 <int-e> Foo{ bar = x } matches the value Foo{ bar = 42 }.
04:44:06 <int-e> it's a pattern!
04:44:11 <timthelion> I see that now :)
04:44:20 * Yuu-chan likes the idea of NamedFieldPuns
04:44:22 <timthelion> but can you see how I see it as backwards too :)
04:44:38 <int-e> timthelion: yes, but it isn't ;-)
04:44:41 <mauke> timthelion: no
04:46:35 <Jafet> > foldM (\x y -> [x+y]) 0 [0..300000]
04:46:38 <lambdabot>   [*Exception: stack overflow
04:46:52 <Jafet> trio: you may need to write foldM'
04:46:55 <Jafet> @src foldM
04:46:55 <lambdabot> foldM _ a []     = return a
04:46:55 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
04:48:38 <Yuu-chan> timthelion: when I was in high school, we had a pretty tough math task (involving a hypercubic equation), and someone offered a solution started with "Let 5 = a, and then we get a simple parameteric equation here..."
04:48:57 <statusfailed> Someone earlier mentioned "sequence" might run into problems with "thunk chains", whereas forM/mapM might not- could anyone elaborate?
04:49:07 <shachaf> @src mapM
04:49:07 <lambdabot> mapM f as = sequence (map f as)
04:49:17 <timthelion> Yuu-chan: :)
04:49:55 <nand`> Yuu-chan: let 1 = 2, and then it reduces to ..
04:50:03 <trio> Jafet: I thought that could be the way, thanks (the write foldM' part)
04:50:23 <statusfailed> shachaf: .... well shit :D
04:50:44 <trio> Or I could run sequence on the lazy list fold that..
04:50:46 <timthelion> Yuu-chan: There's also the trick of replacing a given number, say 5 with (5(^1/2))^2 to get it to fit into a parametric ...
04:51:04 <timthelion> quadratic
04:51:06 <timthelion> sorry
04:51:12 * timthelion shoots himself
04:51:34 * timthelion no longer knows math, hasn't taken a math class in 3 years.
04:51:49 <Jafet> > let foldM' _ a [] = return a; foldM' f a (x:xs) = f a x >>= \fax -> fax `seq` foldM' f fax xs;   in foldM' (\x y -> [x+y]) 0 [0..300000]
04:51:52 <lambdabot>   [45000150000*Exception: stack overflow
04:52:00 <Jafet> wat
04:52:21 * Yuu-chan is nostalgic about her school times
04:52:45 <Yuu-chan> timthelion: what about category theory? ;)
04:53:28 <timthelion> Yuu-chan: I read up on that of course. But really, that's mostly trivial compaired to the stuff I learned in high school.  It's just concepts.  None of those nasty - signs to mix up-
04:54:15 <latro`a> jafet: that's a shallow seq fail, I think
04:54:56 <latro`a> it matches the constructor and not the contents, so the inside is still a thunk
04:55:08 <sayuke> random question, how do you say "function foo a b returns the sum of its arguements" in haskell-y speak?
04:55:30 <latro`a> foo = (+)
04:55:30 <latro`a> ?
04:55:33 <nand`> function a returns a function which adds a to its argument :P
04:55:53 <nand`> or foo = (+), yeah
04:56:02 <sayuke> in particular i was curious if people use the word returns when referring to functions in haskell
04:56:12 <nand`> you can say ‚Äòevaluates to‚Äô if you want
04:56:15 <sayuke> and if you have a constant, meaning = 42, does meaning return 42?
04:56:25 <koala_man> how do you know that there are two arguments?
04:56:25 <nand`> ‚Äòreturn‚Äô is used for something else in Haskell
04:56:28 <nand`> so it's best to avoid that
04:56:48 <nand`> ‚Äòmeaning = 42‚Äô <- meaning *is* 42, it doesn't return it
04:57:10 <nand`> but ‚Äòevaluates to‚Äô is generally fine when you're dealing with functional things; since that's what they do - evaluate
04:57:19 <sayuke> 'evaluates to' sounds good
04:57:24 <sayuke> cheers :)
04:57:28 <mm_freak> sayuke: for function is say "results in", but i often accidentally say "returns" anyway
04:57:55 <mm_freak> i think i should just switch the two
04:58:15 <mm_freak> IO String results in a String and Int -> String returns a string
04:58:24 <mm_freak> both IO and (->) Int are monads anyway
04:58:42 <mm_freak> so it isn't too wrong to say that Int -> String returns a String =)
04:59:08 <latro`a> ....lol
04:59:11 <nand`> mm_freak: haha
04:59:25 <Jafet> Guys, first let's consider the category of numbers where the morphisms are additions
04:59:27 <latro`a> "functions are analogous to IO", cute
05:00:00 <Yuu-chan> timthelion: lucky you, those abstract concepts were much harder for me than a simple bunch of ways to manipulate numbers... :(
05:00:40 <nand`> numbers are just instances of the more abstract concepts, who cares about them? :P
05:01:12 <Yuu-chan> nand`: numbers are just instances of Num typeclass! :)
05:01:36 <timthelion> Yuu-chan: A math teacher of mine used to tell us that in math there exist only such abstract concepts.  The rest, he said, was just accounting.
05:01:40 <shachaf> Not all instances of Num are numbers.
05:01:41 <nand`> Jafet: you mean like the ‚â§ poset tagged with the difference? ie: (+3) points from 5 to 8
05:02:05 <nand`> shachaf: the way I understood it she was saying the inverse
05:02:14 <Jafet> nand: I think so
05:02:28 <Jafet> (Not to be confused with additive categories)
05:02:42 <shachaf> Coproductive categories.
05:03:07 <nand`> timthelion: accounting, and physics
05:03:24 <Yuu-chan> timthelion: you are that rightmost guy on the xkcd "sciences purity" comix
05:04:03 <Yuu-chan> "sorry my english"
05:04:14 <nand`> https://en.wikipedia.org/wiki/Mathematical_universe_hypothesis
05:04:43 * timthelion wonders if we should be in #-blah
05:04:51 <nand`> we should
05:04:57 <shachaf> Better yet: We should not be at all.
05:05:54 <osfameron> @faq can Haskell be nihilist?
05:05:54 <lambdabot> The answer is: Yes! Haskell can do that.
05:05:58 <timthelion> shachaf: If you want me to write that essay on GUI's in haskell, then you betten not encourage me to kill myself.
05:07:00 <Jafet> You can't kill something that isn't.
05:07:34 <timthelion> Jafet: if I don't exist, then I cannot be off topic either :D
05:07:48 <merijn> timthelion: Yes you can
05:08:13 <merijn> "forall a . a is off topic" is true if the set of a is empty
05:08:40 <Jafet> There is someone here so that if he's offtopic, then everyone is offtopic.
05:09:04 <timthelion> merijn: that still doesn't make a non existent entity a member of such a set.
05:09:05 <nand`> forall a. if a is in the channel, a is on-topic
05:12:13 <merijn> If I want to pass a struct to a C function I can only pass it as a pointer and not by value?
05:13:32 <tdammers> by value should work too
05:13:44 <tdammers> not sure though, my C is a bit rusty
05:14:41 <timthelion> merijn: you can pass by value. That is the reason why they have structs.  Any fixed length data type in C can be passed as a value.
05:14:42 <mauke> merijn: yes if FFI
05:14:56 <mauke> timthelion: wrong
05:15:03 <timthelion> mauke: example?
05:15:05 <merijn> tdammers: I know the C answer, I meant using the FFI
05:15:18 <mauke> timthelion: every data type in C is fixed length
05:15:47 <merijn> mauke: Is that "yes you can pass by value" or "yes you can only pass as a pointer"?
05:16:01 <timthelion> mauke: you're being pedantic.  I cannot pass a string by value, only by pointer.
05:16:14 <merijn> timthelion: C has not strings
05:16:17 <mauke> merijn: yes, if you want to pass a struct to a C function, you can only pass it as a pointer and not by value
05:16:24 <merijn> mauke: ok, thanks
05:16:29 <mauke> timthelion: what's a string?
05:16:30 <timthelion> merijn: char *
05:16:36 <merijn> timthelion: That's a char pointer
05:16:46 <merijn> Which are passed by value, btw
05:16:58 <mauke> everything in C is passed by value
05:17:41 <merijn> True
05:21:42 <Z`> I wrote ... = if x == y then (Maybe x) else Nothing and I get error:
05:21:48 <Z`> q1-10.hs:54:24: Not in scope: data constructor `Maybe'
05:21:56 <Yuu-chan> Z`: Just x
05:22:06 <Z`> ugh, what a dumbass.sorry
05:22:28 <Z`> (and thanks)
05:22:42 <Yuu-chan> btw, parentheses are excessive
05:22:54 <Z`> okay
05:24:18 <Z`> for people who also know C: is there something like the 'default' label in a switch-case statement ?
05:24:28 <Z`> I'd like to have 1 in a function
05:24:47 <Z`> basically: if there is no pattern match from the above statements, just return this
05:25:00 <Yuu-chan> Z`: _ as the last pattern
05:25:05 <krageon> Z`: It exists, but the exact name eludes me for a sec
05:25:06 <latro`a> you can use just any random symbol
05:25:07 <krageon> that's it.
05:25:15 <Z`> neat,thanks!
05:25:16 <latro`a> but _ is commonly used, because then it doesn't bind anything
05:25:27 <latro`a> f x = ...
05:25:32 <latro`a> will always match
05:25:48 <latro`a> another advantage of _ is that you can use it repeatedly
05:25:50 <chat> chat
05:25:51 <latro`a> f _ _ _ = ...
05:26:20 <Z`> hm, though I'll get a warning if f _ = ... is *after* the other patterns
05:26:32 <merijn> Z`: Why?
05:26:34 <Z`> because it will overlap with one of the above ?
05:26:48 <merijn> Z`: No, alternatives are tested in the order you write them
05:26:48 <Z`> f (x:xs) = ...
05:26:50 <Z`> f _ = ...
05:26:52 <Guest86434> lll
05:26:58 <Yuu-chan> Z`: if they are complete, you will.
05:27:12 <Yuu-chan> Z`: [] doesn't match the first pattern
05:27:22 <merijn> Z`: That'll work fine. If you write them in the other order (i.e. "f _" first) then it will always select that one, though
05:27:28 <sheldonh> wow, these SICP courses are fricken' awesome
05:27:58 <Z`> ok, my goal is to write a function:    f :: (Eq a) => (a, a) -> Maybe a
05:28:05 <merijn> Z`: Basically it'll select the first matching alternative that you write. If you have multiple overlapping alternatives that's not a problem (thought the compiler will complain if you're *missing* an alternative)
05:28:10 <sheldonh> SICP lectures, even
05:28:11 <merijn> s/thought/though
05:28:36 <Z`> and then:  f (x, y) = if x == y then Just x else Nothing
05:28:46 <Z`> but, also, I'd like to return Nothing for every other input
05:28:53 <Z`> say for input like: (x, y, z)
05:28:53 <mauke> Z`: what other input?
05:28:55 <nand`> there's no other possible input
05:28:57 <merijn> Z`: Which other inputs?
05:28:58 <nand`> Z`: that's il-typed
05:29:02 <Yuu-chan> Z`: which other output may be there?!
05:29:09 <nand`> (x,y,z) can't be of type (a,a)
05:29:13 <Z`> oh
05:29:15 <Yuu-chan> s/output/input
05:29:32 <Z`> ah, right, now I reread the error message. It is not a failure to match a pattern
05:29:39 <Z`> but rather a failure to match the expected type!
05:29:57 <Z`> <3
05:30:08 <Yuu-chan> Z`: by the way, why f (x, y), not f x y?
05:30:49 <merijn> Yuu-chan: Probably because he has a tuple instead of separate arguments?
05:30:55 <Z`> I wanted to compare tupples of numbers, so it seamed like a good idea.
05:31:15 <nand`> because ‚Äòuncurry‚Äô everywhere when it's unnecessary may not be what he wants
05:31:31 <Z`> what is uncurry ?
05:31:40 <nand`> :t uncurry
05:31:41 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
05:31:55 <nand`> :t uncurry (+)
05:31:56 <lambdabot> forall a. (Num a) => (a, a) -> a
05:32:05 <Yuu-chan> uncurry converts f x y to f (x, y)
05:32:13 <latro`a> it has an inverse-ish
05:32:15 <latro`a> :t curry
05:32:16 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
05:32:17 <Yuu-chan> :t curry
05:32:18 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
05:32:22 <nand`> latro`a: ‚Äòish‚Äô?
05:32:31 <Yuu-chan> inversish
05:33:05 <latro`a> if you treat them both as one parameter it actually is an inverse
05:33:07 <merijn> > uncurry (+) (1,2)
05:33:08 <lambdabot>   3
05:33:13 <latro`a> but if you don't it's merely ish
05:33:21 <nand`> uncurry . curry = id; curry . uncurry = id; looks like an inverse to me
05:33:38 <merijn> > let f (x, y) = if x == y then Just x else Nothing in f (1,1)
05:33:39 <lambdabot>   Just 1
05:33:46 <merijn> > let f (x, y) = if x == y then Just x else Nothing in curry f 1 1
05:33:47 <lambdabot>   Just 1
05:33:48 <Yuu-chan> merjin: I wanted to notice that novices with an imperative background somethimes use tuples of arguments because f(x, y, z) seems more natural to them
05:34:36 <Z`> so.. to sum up
05:34:43 <merijn> Style question: package local imports above or below global imports?
05:35:09 <Z`> f x y z is "call f with 3 arguments,namely x,y,z", whereas f (x,y,z) is "call f with 1 argument, namely being the tuple with 3 elements x,y,z"
05:35:09 <Yuu-chan> below
05:35:10 <Z`> ?
05:35:27 <Yuu-chan> Z`: yes.
05:35:35 <merijn> Z`: Actually, if you want to be pedantic it is slightly different still
05:35:39 <Z`> thanks
05:35:42 <latro`a> really precisely, f x y z is "call f with x, call f x with y, call f x y with z"
05:35:44 <Z`> merijn: care to explain ?
05:35:47 <Z`> ah
05:35:55 <merijn> Z`: What latro`a  said :p
05:35:56 <Z`> is this because I see in types constructs like:
05:36:01 <Z`> (a -> b) -> ...
05:36:20 <Yuu-chan> Z`: a -> b -> c is a -> (b -> c). That's called currying
05:36:33 <nand`> that's called right associativity
05:37:06 <Z`> I mean, If I have:  myf :: a b -> c
05:37:10 <Eduard_Munteanu> :t curry
05:37:10 <merijn> Z`: -> is right associative, so "a -> b -> c -> d" can be read as "a -> (b -> (c -> d)))" or "a function taking an a and returning a function that takes a b that returns a function that takes a c, returning a d"
05:37:11 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
05:37:12 <Z`> how would I write its type ?
05:37:24 <Z`> with parentheses and arrows :P
05:37:29 <nand`> a -> b -> c most likely
05:37:46 <Z`> ok. and a -> b -> c is the same as a -> (b -> c)
05:37:49 <byorgey> Z`: by  a b -> c  do you mean a function that takes two arguments of types a and b, and returns something of type c?
05:37:50 <nand`> yes
05:37:55 <merijn> Z`: Whereas "(a -> b) -> c" means "a function that takes a function (a -> b) and returns a c"
05:37:57 <Eduard_Munteanu> Z`: what do you mean  :: a b -> c?
05:38:00 <Z`> what would be an example of a function whose ttype would be:  (a -> b) -> c
05:38:00 <bartavelle> what should I do when hp2ps produces invalid postscript files ?
05:38:17 <merijn> Z`: Well, "(a -> b) -> c" is a silly type
05:38:18 <bartavelle> isn't there a nicer utility somewhere ?
05:38:23 <byorgey> @type \f -> f 3
05:38:24 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
05:38:29 <franco00> I am trying to inquire my pop3 mail via haskell. What's the most sensible  choice? haskellnet?
05:38:32 <Z`> byorgey: yes
05:38:39 <merijn> Z`: A more realistic function would be map "(a -> b) -> [a] -> [b]"
05:38:40 <byorgey> Z`: right, then a -> b -> c
05:39:02 <merijn> Z`: In that case maps takes a function as argument and returns a function that takes a list and returns a list
05:39:03 <Eduard_Munteanu> Z`: there's no fully defined function with that type
05:39:15 <merijn> Eduard_Munteanu: Sure there is, it'll just be useless
05:39:27 <nand`> I don't think he meant to quantify a/b/c, just used them as metavariables for actual types
05:39:29 <byorgey> franco00: what about http://hackage.haskell.org/package/pop3-client ?
05:39:32 <merijn> :t \_ _ -> undefined
05:39:33 <Eduard_Munteanu> @djinn (a -> b) -> c
05:39:33 <lambdabot> -- f cannot be realized.
05:39:33 <lambdabot> forall t t1 a. t -> t1 -> a
05:39:36 <nand`> like Int -> Char -> String
05:39:44 <Eduard_Munteanu> merijn: yeah, hence not fully-defined :)
05:39:53 <byorgey> franco00: (I just did a google search, I really don't know anything about that package)
05:40:04 <merijn> Z`: Compare the types of the following
05:40:06 <merijn> :t map
05:40:06 <franco00> thanks byorgey
05:40:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:40:11 <merijn> :t map (+1)
05:40:12 <lambdabot> forall a. (Num a) => [a] -> [a]
05:40:17 <merijn> :t map (+1) [1..10]
05:40:18 <lambdabot> forall a. (Num a, Enum a) => [a]
05:40:47 <merijn> Z`: See how the result of "map (+1)" is just another function?
05:40:55 <Z`> yes
05:41:02 <Z`> only that it maps lists of a to lists of a
05:41:29 <merijn> Z`: You can think of all functions having one argument and just lopping 1 from the start of the type signature
05:41:45 <merijn> (Actually, you can not only think that, that's what really happens)
05:42:18 <Z`> Thanks guys. I'm trying to excise the imperative mentality from my brain, but it is resisting.
05:42:45 <Yuu-chan> merijn: by "really happens" do you mean the implementation details?
05:43:06 <merijn> Yuu-chan: I mean in the denotational semantics
05:43:34 <merijn> Z`: What can really help is to grab a piece of paper/whiteboard and workout the type subtitutions in type signatures and function applications by hand
05:43:37 <franco00> byorgey: turns out it is way more simple than the other package. Thanks!
05:45:59 * Yuu-chan tries to invent foo :: (a -> b) -> c with no luck
05:46:11 <Botje> Yuu-chan: foo = const undefined
05:46:49 <nand`> @pl \a -> use (code . at a)
05:46:49 <lambdabot> use . (code .) . at
05:47:00 <merijn> Yuu-chan: Also "f _ = undefined"
05:47:14 <nand`> f = undefined
05:47:16 <nand`> works too
05:47:25 <nand`> so does ‚Äòf = f‚Äô
05:47:41 <Yuu-chan> That's not interesting! I mean a non-trivial one.
05:47:48 <merijn> :t let f _ = undefined in (f :: (a -> b) -> c) 1
05:47:49 <lambdabot> forall c. c
05:47:54 <merijn> > let f _ = undefined in (f :: (a -> b) -> c) 1
05:47:55 <lambdabot>   *Exception: Prelude.undefined
05:47:57 <sayuke> another random terminology question, when a type variable takes on a concrete type, what does one say. For example, in [a] :: [Int] 'a' "takes on" the value of 'Int'
05:48:44 <sayuke> or 'a' is assigned the value of 'Int'
05:48:55 <merijn> sayuke: Depending on context I'd say that "a is constrained to Int" or "a resolves to Int", there might be more terminology around, though
05:49:07 <sayuke> merijn:  thanks
05:49:15 <merijn> Oh, and "a unifies with Int"
05:49:27 <merijn> Since type checking is usually implemented as a unification problem
05:49:56 <Yuu-chan> :t let f = f in f
05:49:57 <lambdabot> forall t. t
05:50:08 <merijn> > let f = f in f
05:50:11 <lambdabot>   mueval-core: Time limit exceeded
05:51:16 <Jafet> sayuke: if your blank verse needs more syllables, instantiation
05:51:53 <Yuu-chan> A Haskell poem, neat!
05:52:02 <Jafet> Unified is the process of matching a with Int
05:52:31 <Jafet> Constrained is potentially misleading in any context I can think of
05:52:36 <nand`> my favorite Haskell poem: ‚ÄúA parser of things is a function from strings to lists of pairs of things and strings‚Äù
05:53:02 <nand`> parse :: String -> [(a, String)]
06:03:51 <merijn> Suppose I have a mutating graph (of chan's and forkIO threads), what would be the best way to keep a representation of the graph state that I can access globally?
06:04:38 <merijn> I guess I could have a separate thread receiving messages from everyone registering changes, or something using IORefs (although I'm not exactly sure how), any suggestions?
06:04:53 <franco00> mhhhhhhh, ok. Now I can check my pop3 mail via haskell. But the thing is, is that secure? I am basically writing my username and password, will that show in the executable? Will it suffice to chmod it to user only?
06:04:56 <statusfailed> Can Template Haskell do IO when generating code?
06:05:06 <merijn> statusfailed: afaik yes
06:05:16 <statusfailed> colbeans
06:05:18 <statusfailed> coolbeans*
06:06:13 <Z`> Why doesn't:  foldr (\ x -> x) [] [1,2,3,4] return the same list ?
06:06:26 <Z`> ah it's not binary operatro
06:06:53 <Yuu-chan> > map (\x -> x) [1..4]
06:06:54 <lambdabot>   [1,2,3,4]
06:07:21 <Z`> is the starting value optional ?
06:07:37 <merijn> Z`: Not, but there's a foldl1
06:07:44 <merijn> That uses the first item in the list
06:07:53 <merijn> > foldl1 f [a,b,c,d]
06:07:54 <lambdabot>   f (f (f a b) c) d
06:07:55 <Yuu-chan> @hoogle fold
06:07:55 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
06:07:55 <lambdabot> Data.List foldl :: (a -> b -> a) -> a -> [b] -> a
06:07:55 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
06:08:08 <merijn> > foldl f z [a,b,c,d]
06:08:09 <Yuu-chan> @hoogle foldr
06:08:09 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
06:08:09 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
06:08:09 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
06:08:09 <lambdabot>   f (f (f (f z a) b) c) d
06:08:40 <Z`> gr, puzzled
06:09:19 <merijn> > (foldl f z [a,b,c,d], foldl1 f z [a,b,c,d])
06:09:20 <lambdabot>   Couldn't match expected type `[a]'
06:09:20 <lambdabot>         against inferred type `SimpleRef...
06:09:22 <Z`> foldr1 (\x -> x) [1,2,3,4] says cannot construct infnite type: a0 = a0 -> a0
06:09:27 <merijn> > (foldr f z [a,b,c,d], foldr1 f z [a,b,c,d])
06:09:28 <lambdabot>   Couldn't match expected type `[a]'
06:09:28 <lambdabot>         against inferred type `SimpleRef...
06:09:44 <merijn> Z`: Because you're function has only one argument
06:09:47 <Yuu-chan> Z`: fold's require binary functions
06:09:54 <merijn> :t foldr1
06:09:54 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
06:10:02 <Z`> ah ok, so it's what I wondered before ( <Z`> ah it's not binary operatro )
06:10:02 <Z`> ok
06:10:25 <Yuu-chan> > foldr1 const [1..4]
06:10:26 <lambdabot>   1
06:10:43 <Yuu-chan> > foldr (flip const) [1..4]
06:10:44 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [t])
06:10:45 <lambdabot>    arising from a use ...
06:10:54 <Z`> ok so.. what binary operator could I use ?   foldr1 (\x y -> x:y:[]) [1,2,3,4] fails
06:11:02 <Yuu-chan> > foldr1 (flip const) [1..4]
06:11:04 <lambdabot>   4
06:11:20 <Z`> (I'd like to do it with a lambda function)
06:11:23 <merijn> Z`: you probably want "foldr (\x y -> x:y) [] [1..4]"
06:11:35 <merijn> > foldr (\x y -> x:y) [] [1..4]
06:11:36 <lambdabot>   [1,2,3,4]
06:11:41 <Yuu-chan> > foldr (:) [] [1..4]
06:11:42 <lambdabot>   [1,2,3,4]
06:11:50 <Z`> ok, it worked--thanks
06:12:37 <Z`> I get confused by x:y vs x:y:[]
06:12:52 <Z`> 1:2 :: (Num [a], Num a) => [a]
06:12:55 <Z`> 1:2:[] :: Num a => [a]
06:13:13 <merijn> Z`: Yes, but the end result of the first application gets used as input for the next
06:13:16 <merijn> Hold on
06:13:47 <tdammers> Z`: consider the type of (:)
06:13:51 <merijn> Z`: https://en.wikipedia.org/wiki/File:Fold-diagrams.svg
06:13:55 <tdammers> @type (:)
06:13:56 <lambdabot> forall a. a -> [a] -> [a]
06:14:11 <Yuu-chan> Z`: you may think of foldl in an imperative loop way
06:14:17 <tdammers> the first argument is an `a', the second one is a list of `a's
06:14:28 <tdammers> so in the expression 1:2
06:14:38 <tdammers> 1 must be of type a, and 2 must be of type [a]
06:15:04 <Yuu-chan> Z`: "take the initial value and the first element of list, apply the binary function, get the accumulator. Take the accumulator and the second value, apply the function, get the next accumulator..."
06:15:06 <tdammers> remember that numeric literals do not indicate a type in Haskell, just a typeclass
06:15:12 <Z`> ok, let me read that ... "a -> [a] -> [a]" means " a -> ([a] -> [a])" which means
06:15:48 <Z`> did I associate them correctly?
06:15:51 <tdammers> in this context, it is easier (though technically slightly incorrect) to think of a -> b -> c as "a function that takes two arguments of types a and b, and returns a c"
06:15:53 <Z`> -> is right associative
06:15:55 <Yuu-chan> foldr is similar, but in the other direction :)
06:15:56 <merijn> Z`: Yes
06:16:18 <Z`> ([a] -> [a]) is a function maping a list of a's to a list of a's ?
06:16:29 <bartavelle> now this is vexing. I wrote a program that works in (almost) constant memory. I modified it so that it is simpler, and now it uses O(n) memory
06:17:10 <tdammers> the expression 1:2 implies three type constraints:
06:17:30 <tdammers> 1. 1 must be a member of the Num typeclass
06:17:37 <tdammers> 2. 2 must be a member of the Num typeclass
06:17:47 <Yuu-chan> Z`: Yes
06:17:48 <tdammers> and 3. when 1 is of type a, 2 must be of type [a]
06:17:54 <merijn> Z`: "a -> [a] -> [a]" in this scenario means: "takes an a and returns a function (which takes a list of a's and returns a list of a's)", the list returns is basically the original list + the first item added in front
06:19:00 <Z`> ah ok, so when I read as a human being an a -> b -> c notation, I read from left to right, but I associate from right to left
06:19:36 <Z`> ok, got it. thanks people
06:19:50 <tdammers> it's a bit confusing, but right-associative means that you can consume arguments from the left
06:19:51 <Yuu-chan> a -> maps a to what's on the right
06:21:14 <krageon> I translate them with "goes into", but bear in mind I'm not much of a haskellian
06:21:33 <Yuu-chan> Z`: Arabs and Jews are human beings indeed, but they read from right to left :)
06:22:11 <Yuu-chan> "A Haskellian being"
06:25:36 <Z`> haha
06:25:44 <eikke> when using vector, what's the best way to "blit" a vector into another one at a certain offset?
06:26:03 <carpi> is there any take on when to use 'pattern matching' vs 'guards' vs 'where' vs 'let .. in' vs 'if .. then .. else'? cos i feel they all can be used almost interchangeably with some exceptions ?
06:26:25 <merijn> carpi: Whichever is more readable
06:26:59 <merijn> carpi: I usually prefer pattern matching/guards over if/else and case-of and where over let
06:28:35 <carpi> thanks.. makes sense. patterns and guards are definitly more readable
06:28:39 <danr> where is the Num Int instance defined in GHC?
06:28:58 <tdammers> I read -> as "to"
06:29:10 <carpi> danr: GHC.Num i think
06:29:37 <danr> carpi: thanks!
06:30:14 <Yuu-chan> tdammers: and <- as "from"?
06:31:03 <Eduard_Munteanu> I read B^A as B from A.
06:31:06 <bartavelle> ok the simplified program also runs in constant memory, but uses 7.5G instead of 35M
06:31:08 <bartavelle> wtf
06:33:12 <Eduard_Munteanu> Probably because "B to the A" is misleading.
06:34:13 <byorgey> carpi: they are not interchangeable.  You should always use pattern matching if you can.  After pattern matching, guards and if ... then ... else are interchangeable (though I think guards make for nicer style).
06:34:23 <byorgey> carpi: where and let .. in  are something else entirely.
06:35:03 <byorgey> carpi: to illustrate the first point, do not write   if xs == [] then ... else ... head xs ... tail xs ...
06:35:15 <byorgey> instead, you should use pattern-matching:   foo [] = ...;  foo (x:xs) = ...
06:37:39 <carpi> byorgey: thansks that helps. the reason i wanted to know this was cos I noticed i spent more time than i should thinking about whether to use patterns, guards or if's then writing the code..
06:37:52 <carpi> *than
06:39:02 <DeadPanda> on that topic, would a rough order of preference be patterns > guards > conditionals?
06:39:23 <merijn> DeadPanda: Yes
06:39:58 <DeadPanda> merijn, thanks, just working my way through RWH in time to get a fairly complex simulation running by monday :/
06:41:41 <carpi> DeadPanda: is that even possible? unless this is not your first time with haskell or rwh
06:42:09 <DeadPanda> carpi, well, it's not my first time with a functional language
06:42:17 <DeadPanda> carpi, and I understand the problem domain well enough
06:42:32 <DeadPanda> carpi, worst case, I'll abandon ship on Sunday and hack the thing together in Python
06:42:58 <Z`> I know it's meaningless, but why does: foldr (\x y -> if x == y then x:y else x:y) [] [1..4] fails with cannot construct the infinite type a = [a] ?
06:43:10 <Z`> fail*
06:43:14 <tdammers> Yuu-chan: yeah ;)
06:43:24 <merijn> Z`: y is a [a] and x is an a
06:43:31 <merijn> Z`: So comparing them is a type error
06:43:45 <Z`> oh
06:44:04 <Z`> sweet, so haskell infereed the types
06:44:08 <Z`> by looking at x:y ?
06:44:11 <DeadPanda> carpi, and, besides, calling it "complex" was probably a bit much -- the amount of data it churns through will be, but the algorithm is relatively simple
06:44:32 <merijn> Z`: Not only that, it also looks at the rest of the type of foldr
06:44:50 <merijn> Z`: You might want to look at the foldr implementation and do the substitution by hand to see what happens
06:44:54 <merijn> @src foldr
06:44:54 <lambdabot> foldr f z []     = z
06:44:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:45:13 <merijn> Z`: Try doing step by step substitution of your example on paper
06:46:11 <Z`> I'm not even sure if what I want is doable. My idea was to implement a pair comparison (if from 2 elements x,y x == y then return x, else return both), so that I could use foldr on a list with consecutive elements to eliminate them
06:46:51 <merijn> Z`: That should be possible, but you might want to write it without fold first, before trying to do it with fold
06:46:59 <carpi> DeadPanda: you should probably start writing the simulation and refer to RWH back and forth when you get stuck. Much better approach IMHO. But im no expert.
06:48:48 <DeadPanda> carpi, thanks, I've already defined most of the ADT's and the type of some important functions
06:49:21 <DeadPanda> carpi, got myself tangled up trying to make (Map a b) an instance of a class I'd declared to handle storing state, though :/
06:51:35 <Yuu-chan> > let f [] = []; f [x] = [x]; f (x:xs@(y:ys)) = if x == y then f xs else x:f xs in [1, 1, 2, 3, 3, 0, 0, 0, 4]
06:51:36 <lambdabot>   [1,1,2,3,3,0,0,0,4]
06:52:38 <merijn> DeadPanda: Why do you need a close to store state? You want to carry some state over multiple computations?
06:53:00 <merijn> DeadPanda: (Or, what I'm really asking, can't you solve that using State/StateT?)
06:53:13 <Yuu-chan> > let f [] = []; f [x] = [x]; f (x:xs@(y:ys)) = if x == y then f xs else x:f xs in f [1, 1, 2, 3, 3, 0, 0, 0, 4]
06:53:15 <lambdabot>   [1,2,3,0,4]
06:53:57 <DeadPanda> merijn, it's attack graph generation, thinking of the function definition recursively, the "container" would store the set of highest privileges gained on hosts for the current path
06:54:28 <b__> which would be faster? (liftM2 (&&) (>= 0) (<= 63)) or (`elem` [0..63])?
06:54:32 <merijn> DeadPanda: Sounds like you want State to me?
06:54:33 <b__> I assume the first?
06:54:40 <DeadPanda> merijn, thanks, I'll check it's documentation
06:58:38 <tromp_> silly article at http://www.infoworld.com/d/application-development/functional-programming-step-backward-196990 claims haskell has difficult unreadable syntax:(
06:59:38 <hpaste> merijn pasted ‚ÄúSimple state example‚Äù at http://hpaste.org/73987
06:59:39 <Rotaerk> tromp_, haskell code can be hard to read, but it's not because of the syntax
06:59:49 <merijn> DeadPanda: I pasted a completely trivial example for you
07:01:07 <tromp_> the example they give doesn't strike me me as hard to read
07:01:08 <merijn> DeadPanda: You can use whatever type you want for the actual state and (unlike my increment example) return some other value after messing with the state
07:01:25 <merijn> (Warning: I didn't actually check whether that code typechecks or runs :p)
07:01:33 <tromp_> i guess they got scared just from seeing `infixop`   \   and ->
07:01:45 <Z`> merijn: I did it, but I used an accumulator
07:01:57 <Z`> (with foldr)
07:02:03 <merijn> Z`: Nice :)
07:02:08 <Z`> yupi
07:02:24 <DeadPanda> merijn, hehe, don't worry -- I'm looking at it now
07:02:24 <Rotaerk> tromp_, it's hard to read for them because it's not basically the same language that they're used to with slight differences
07:03:18 <nand`> Rotaerk: amen
07:03:34 <DeadPanda> tromp_, I'm surprised people read that past the first sentence.  Anyone that starts an article like that obviously has an axe to grind.
07:04:29 <Rotaerk> another reason haskell code may be difficult to read is because of its power of abstraction
07:04:56 <Rotaerk> so being perfectly capable of reading one haskell program doesn't necessarily help with reading another haskell program if they're written in terms of very different abstractions
07:04:58 <tromp_> it just amuses me how they don't even try to make a convincing argument
07:05:06 <mm_freak> tromp_: the comments say it all
07:05:14 <mm_freak> "As for the author, my only advice is - "Better to remain silent and be thought a fool than to speak out and remove all doubt"."
07:05:24 <mm_freak> =)
07:05:28 <Rotaerk> I think some people just like all code to be written directly in terms of the raw fundamental mechanisms of the language
07:05:37 <Rotaerk> for instance someone at work was complaining that LINQ in C# was "hard to read"
07:05:45 <Rotaerk> simply because he has to actually... learn LINQ to do it
07:06:01 <carpi> byorgey: i think it sould be patterns > guards > case .. of > if .. then .. else
07:06:05 <Rotaerk> (as opposed to code written in terms of the raw mechanisms such as conditions, loops, etc)
07:06:38 * ksf prefers straight list code over comprehensions
07:08:23 <byorgey> carpi: I mostly agree, except guards and if .. then .. else are not really interchangeable with pattern matching/case
07:08:50 <byorgey> carpi: pattern matching is just syntax sugar for case, which is for branching on the *structure* of some value
07:09:04 <byorgey> carpi: guards and if/then/else are for branching on *Boolean expressions*
07:09:35 <franco00> http://hackage.haskell.org/packages/archive/pop3-client/0.1.4/doc/html/Network-POP3-Client.html#v:withPOP3 If I use this module, will my user and password be sent to the pop3 server unencrypted? It uses Network's connectTo, but I don't know wheter it is supposed to be secure or not
07:10:02 <thorsten`> hi, i'm trying to install hjvm via cabal but i get a strange error message: http://wwwcip.cs.fau.de/~re06huxa/p/dd8d0565f77a69bf559cf85d954ff678
07:10:32 <thorsten`> shouldn't the missing header file "hjvm.h" be included in the package?
07:11:57 <byorgey> thorsten`: no, it is apparently a binding to some external library
07:12:05 <byorgey> thorsten`: so you must have the development version of that library installed
07:12:22 <byorgey> actually, the error message explains all this
07:15:46 <thorsten`> ok, and how do i find out where to get that C library "jvm"?
07:18:37 <Yuu-chan> thorsten`: I suppose you should install JDK
07:21:47 <bartavelle> ok, my program, compiled at home, works in around 50Mb. Compiler at work, with a brand new ghc-7.4.2 and haskell platform uses all my memory
07:21:51 <thorsten`> i have openjdk-6-{jdk,jre,soucre}
07:22:01 <bartavelle> profiling says it's a bunch of MUT_ARR_PTRS_FROZEN
07:22:12 <bartavelle> what the hell ?
07:28:49 <alFReD-NSH> Hi, guys I'm trying to build a haskell shared library
07:29:07 <alFReD-NSH> and I'm following this guide: http://weblog.haskell.cz/pivnik/building-a-shared-library-in-haskell/
07:29:19 <alFReD-NSH> But I'm getting error on dlopen
07:29:38 <alFReD-NSH> /usr/lib/ghc/ghc-prim-0.2.0.0/libHSghc-prim-0.2.0.0-ghc7.4.1.so: undefined symbol: stg_forkOnzhWE
07:30:30 <thorsten`> Yuu-chan: is this library a general library (some jvm.*.so.*) or a special haskell thing?
07:32:39 <Yuu-chan> thorsten: I think it's the library included in the package
07:33:08 <Yuu-chan> https://github.com/JPMoresmau/HJVM/tree/master/src libjvm.so.a o_O
07:33:50 <Yuu-chan> s/so/dll
07:34:27 <Yuu-chan> I'm curious why the installer doesn't see it
07:35:04 <eacameron> are there less strict versions of *, /, +, -, etc.? I'm finding I have to do `fromIntegral` everywhere
07:35:45 <ksf> eacameron, http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
07:35:57 <ksf> ...the duck-typing example
07:38:28 <Yuu-chan> eacameron: maybe http://hackage.haskell.org/package/numeric-prelude will help
07:40:44 <thorsten`> Yuu-chan: dll.a? what's that? dll sounds like dynamic link library which sounds like windows (im on debian linux here)
07:43:37 <eacameron> ksf: Yuu-chan: thank you
07:44:46 <Yuu-chan> thorsten`: I'd want to know that too! .dll is dynamic in Windows, and .a is static in Linux...
07:45:30 <thorsten`> and it's a binary anyway... but added to the git repository..
07:45:53 <alFReD-NSH> How can we link to haskell runtime?
07:45:59 <alFReD-NSH> I'm making a shared library
07:46:07 <alFReD-NSH> but having an error on dlopen
07:46:21 <alFReD-NSH> thought maybe haskell runtime is not included
07:47:47 <alFReD-NSH> -L/usr/lib/ghc doesn't really
07:47:51 <alFReD-NSH> help
07:54:56 <bartavelle> ok, could there be a HUGE bug in unordered containers ?
07:55:30 <bartavelle> I have no space leak with Data.Map, but huge ones with Data.HashMap, -hy says it is MUT_ARR_PTRS_FROZEN
07:55:48 <bartavelle> and google says it comes from IORefs and STRefs
07:55:54 <bartavelle> unordered containers uses ST
07:58:42 <joe9> @seen archivist
07:58:42 <lambdabot> Unknown command, try @list
08:02:29 <carpi> is there a way to view standard library docs when i have no internet?
08:10:48 <timthelion> are there any good human readable texts on indexed types in haskell?
08:12:24 <Jeanne-Kamikaze> indexed types = type families ?
08:13:38 <timthelion> Jeanne-Kamikaze: I'm not even clear about that yet.  It's sugested on the wiki.  I'm talking about the indexed types as in the Repa paper.
08:14:35 <kstt> is there an equivalent to the "filepath" and "directory" packages, that uses ByteStrings instead of String ( FilePath ) ?
08:14:54 <mm_freak> a type index is a type argument that is chosen by the constructor
08:14:55 <Jeanne-Kamikaze> sounds like they are the same
08:15:04 <Jeanne-Kamikaze> timthelion: I find the wiki page on type families to be quite readable
08:15:28 <kstt> it does not make much sens to have to deal with encoding for paths
08:15:45 <mm_freak> data List :: * -> * -> * where Nil :: List () a; Cons :: a -> List n a -> List (Maybe n) a
08:15:54 <BMeph> timthelion: It's not strictly Haskell, but I found Tim Sheard's stuff informative.
08:17:41 <timthelion> OK, do I understand correctly, that this helps solve the problem expressed in McBrides Outrageous Fortune paper?
08:19:28 <n-dolio> Indexed types are families of types T : k -> * such that constructors can target arbitrary inhabitants of k.
08:19:58 <n-dolio> More or less.
08:21:56 <timthelion> n-dolio: somehow such a terse definition doesn't help :)  I'm wondering what their concrete usage is.
08:22:33 <n-dolio> mm_freak gave one. Lists with their length in the type.
08:24:21 <mm_freak> timthelion: a type argument is chosen by the user of the type‚Ä¶  a type index is chosen by the type itself (through its constructors)
08:25:28 <n-dolio> People also do stuff like indexing data types of syntax by their types, which allows only well typed syntax to be built.
08:25:47 <mun> hi
08:25:51 <timthelion> hi mun
08:26:08 <n-dolio> That general kind of thing is pretty long reaching, because there's lots of problems you can express by making syntax to represent a problem and then interpreting it.
08:26:32 <mun> generally, if i want to work with sets, would i need to explicitly have a type constructor for sets or could i just reuse the type constructor for functions?
08:26:58 <n-dolio> (That is, I don't buy it when some people say 'what are GADTs good for except well-typed syntax.' Well-typed syntax is huge.)
08:27:05 <Cale> mun: How exactly do you want to reuse the type constructor for functions?
08:28:01 <n-dolio> Technically, nested types are indexed types, as well.
08:28:33 <mun> Cale, hmm just use a predicate when i need a set?
08:28:45 <timthelion> n-dolio: the problem here, is that I still don't have enough info from this to write a 5 line program that prints something to stdout and uses indexed types.
08:28:55 <n-dolio> Because 'data Foo a = Bar (Foo (T a))' has to be an initial algebra in a category of indexed types to work out.
08:29:38 <n-dolio> What does that mean? You don't need indexed types to print to stdout.
08:29:50 <Cale> mun: You can do that, but implementing many operations efficiently will be hard without an explicit tree structure of some sort
08:30:12 <timthelion> n-dolio: What I mean, is that I don't have enough info here, to acually end up using an indexed type.
08:30:43 <Cale> mun: In general, to get efficient set operations, you'll want to take advantage of an ordering on the underlying type
08:30:49 <Cale> See Data.Set for that
08:31:10 <edwardk> timthelion: github.com/ekmett/indexed is turning into an implementation of the outrageous fortune paper in haskell using ghc's new polykinds
08:31:13 <mun> Cale, then does that mean one should have both list types and set types separately?>
08:31:27 <Cale> mun: yes, lists and sets are quite different
08:31:28 <edwardk> timthelion: it needs a current GHC head though to compile (rc1 isn't enough)
08:31:29 <timthelion> edwardk: thanks!
08:31:39 <edwardk> timthelion: its very much a work in progress
08:31:41 <Cale> mun: and finite maps as well
08:31:43 <mun> Cale, but can't lists be built on top of sets?
08:31:50 <Cale> mun: ?
08:31:57 <timthelion> edwardk: so my packaged ghc from archlinux won't cut it :/
08:32:11 <Cale> mun: Not really.
08:32:14 <carpi> can someone please tell me what this means ? -> " No instance for (Show (a (Btree a) (Btree a)))"?
08:32:20 <edwardk> timthelion: alas, no. you'd need to pull current GHC head using the build instructions, and let it build for an hour or two ;)
08:32:24 <Cale> mun: Data.Set provides an efficient representation for finite sets
08:32:31 <Cale> on a totally ordered type
08:32:56 <timthelion> edwardk: OK, at least it'll make interesting reading
08:33:02 <edwardk> timthelion: (i'm doing that now to work around a limitation of the release candidate w.r.t. fundeps on kinds)
08:33:05 <mun> Cale, right. well i read somewhere that product types can generally be considered 'built-in' in typed lambda calculii via currying, so a product type constructor isn't needed?
08:33:29 <hiptobecubic> carpi, it means that ghci doesn't know how to print a value of that type so you can look at it.
08:33:33 <edwardk> i should push up a more current version, one sec.
08:33:35 <Cale> mun: Oh, you can implement pretty much everything in terms of functions if you really want to.
08:33:53 <Cale> mun: But Haskell provides more structured ways to accomplish things than that.
08:34:08 <mun> Cale, sure. how about just in general -- not haskell specific
08:34:09 <edwardk> https://github.com/ekmett/indexed/blob/master/src/Indexed/Functor.hs
08:34:14 <carpi> thanks .. so i have to that type an instance of Shw
08:34:16 <Cale> mun: You can encode data structures with Church or Scott encodings.
08:34:25 <n-dolio> Just search google for GADTs, you don't need to learn from something that uses an unreleased version of GHC.
08:34:38 <hiptobecubic> carpi, if that's your own Btree implementation, you could try adding "deriving Show" to the data Btree = ...  definition
08:34:50 <mun> Cale, does the church encoding need only functions?
08:34:56 <carpi> I tried that .. its not working
08:35:02 <Cale> For example, you can represent a tree structure with the function  (\tip branch -> branch 2 (branch 1 tip tip) (branch 3 tip tip))
08:35:10 <mun> right
08:35:41 <mun> Cale, then why are product types, set types still implemented separately?
08:35:57 <timthelion> What brings me to this over and over again, is my hatered of "data Foo = Bar Int String | Baz String"  I'd love to be able to do "newtype Bar Int String;newtype Baz String;data Foo = Bar | Baz;f :: Foo -> String ; f b@Bar{} = g b; f _ = ...; g :: Bar"
08:36:14 <timthelion> soryy g :: Bar -> String
08:36:15 <edwardk> dolio: hrmm, the fix fixed return for thrists, but bind is still borked
08:36:24 <timthelion> and have g be type strict to Bar, and not to Foo.
08:36:55 <Cale> mun: Well, they needn't be internally
08:37:02 <timthelion> And I think that making Foo an indexed type could fix this, by allowing me to have "g :: Foo Bar -> String" ?
08:37:28 <mun> Cale, hmm how do you encode products using functions?
08:37:30 <n-dolio> Yes.
08:37:34 <Cale> mun: You can still compile something like  (a,b) into the function  (\f -> f a b)
08:38:01 <timthelion> right now I have a lot of code like "g :: Foo -> String; g Bar _ s = s; g _ = error "You suck""
08:38:06 <timthelion> which isn't good.
08:38:40 <n-dolio> But Foo is Either Bar Baz, and the f b@Bar{} is equivalent to f (Left b).
08:38:41 <Cale> mun: But GHC doesn't do this.
08:38:50 <mun> Cale, so, just in principle.
08:39:02 <Cale> mun: There are some implementations which do
08:40:10 <mun> Cale, are lists encoded using pairs?
08:40:12 <timthelion> n-dolio: I understand that I can do it like "newtype Bar = Bar Int String; data Foo = BarA Bar" but that is SOOOO ugly :/
08:40:36 <Cale> mun: At some level it's possible to think of it like that
08:41:25 <Cale> mun: I think it's better to keep the two concepts separate, myself.
08:42:29 <mun> Cale, hmm pairs are ordered and so are lists. but are sets encoded using pairs as well?
08:42:51 <Cale> mun: But [a] can be looked at as the sum of the unit type with the product of a with [a]
08:43:10 <Cale> They could be
08:43:25 <mun> hmm
08:43:32 <Cale> This discussion is *way* too vague to be meaningful right now
08:43:38 <Cale> Which implementation are you talking about?
08:43:45 <Cale> GHC?
08:43:59 <mun> Cale, i'm just looking at Church encoding.
08:44:14 <mun> just in principle, without a particular implementation.
08:49:16 <carpi> is it possible to pattern match in a guard?
08:49:50 <Cale> mun: In that case, you'd implement lists like (\nil cons -> cons 1 (cons 2 (cons 3 nil)))
08:50:16 <Cale> carpi: with pattern guards it is :)
08:51:13 <mun> Cale, sure, but how about products?
08:53:31 <Cale> (\pair -> pair 1 2)
08:55:40 * hackagebot cognimeta-utils 0.1.1 - Utilities for Cognimeta products (such as perdure). API may change often.  http://hackage.haskell.org/package/cognimeta-utils-0.1.1 (PatrickPremont)
08:57:10 <mroman> What's the super fancy trick again with record syntax to modify a single field of a data?
08:57:29 <mun> Cale, hmm is that a product?
08:58:01 <mroman> Although I'm thinking that wouldn't help very much.
08:58:28 <adnam> mroman: r { x = 1 }?
09:00:11 <mroman> I'm aiming for modify property value t = t { property = value } :)
09:00:43 <Cale> mun: yes.
09:00:59 <roconnor> mroman: surely you mean t' = t { property = value }
09:01:17 <Cale> mun: fst p = p (\x y -> x), snd p = p (\x y -> y)
09:01:57 <Cale> mun: pair x y = (\p -> p x y)
09:02:07 <edwardk> ibind f (a :- as) = herp (derp (f a) +++ derp (ibind f as))
09:02:14 <mroman> I have something like data Foo = {a :: Int, b :: Int, c :: Int}
09:02:17 <edwardk> i think i'm going to keep those combinator names
09:02:27 <mroman> and I want to access a,b,c depending on some input and modify them.
09:02:45 <Cale> edwardk: lol
09:02:47 <edwardk> https://github.com/ekmett/indexed/blob/master/src/Indexed/Thrist.hs#L21
09:03:07 <mroman> Maybe I need lenses.
09:03:09 <edwardk> cale: can't come up with a way to get ghc to know that the product kind is only inhabited by the product
09:03:12 <roconnor> mroman: probably
09:03:23 <Cale> edwardk: I've been reading the mailing list posts
09:03:37 <edwardk> cale: i got through the problem on the mailing list, but then bind breaks
09:03:40 <edwardk> this is the best fix i have so far
09:03:51 <Enigmagic> the herp-derp combinators?
09:04:02 <edwardk> https://github.com/ekmett/indexed/blob/master/src/Indexed/Thrist.hs#L21
09:04:05 <edwardk> they are unsafeCoerce
09:05:15 <edwardk> i should probably rename them to be something less dismissive when i go to follow up on the mailing list
09:05:28 <Cale> No, I like those names
09:05:30 <Cale> keep them
09:05:47 <Sculptor> hi
09:06:13 <edwardk> =)
09:06:33 <edwardk> i'll probably move them into Indexed.Functor. i get the impression i'll need them a lot
09:07:33 <Cale> I also love the syntax highlighting
09:07:49 <Sculptor> i'm @ partial function application. still a lot of stuff ahead, but i'm liking it
09:08:07 <Cale> Sculptor: cool :)
09:08:17 <Cale> Sculptor: let us know if you have any questions
09:08:31 <Sculptor> i will
09:08:37 <matthiasgorgens> Sculptor: haskell has partial function application? :o)
09:09:03 <Sculptor> matthiasgorgens, yeah, i was surprising
09:09:27 <matthiasgorgens> re.
09:10:15 <matthiasgorgens> Sculptor: Alternatively, you can pretend that all functions only ever take a single argument (but might return another function to take the next argument, and so on.)
09:10:27 <matthiasgorgens> Sculptor: with that viewpoint, there's no such thing as partial application.
09:12:35 <Sculptor> we can pretend alright
09:13:19 <Sculptor> that stuff is brilliant, but is it efficient
09:13:38 <wilfredh> is there any elegant way of going from [Maybe 1, Nothing, Maybe 2] to [1, 2] ?
09:13:57 <mauke> catMaybes
09:14:14 <timthelion> > catMaybes [Maybe 1, Nothing, Maybe 2]
09:14:15 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe'
09:14:31 <timthelion> > catMaybes [Just 1, Nothing, Just 2]
09:14:32 <lambdabot>   [1,2]
09:14:34 <timthelion> :)
09:14:36 <jfischoff> :)
09:14:39 <timthelion> Damned copy paste.
09:14:45 <jfischoff> hehe
09:15:11 <Cale> Sculptor: more efficient than you might think :)
09:15:59 <Cale> wilfredh: It's also worth noting that you can also use a list comprehension [x | Just x <- [Just 1, Nothing, Just 2]]
09:16:27 <wilfredh> thanks folks :)
09:19:43 <matthiasgorgens> wilfredh: and also be aware of mapMaybe
09:19:43 <matthiasgorgens> Sculptor: you can do some benchmarks, if you want to.
09:19:43 <Sculptor> i will, eventually
09:21:34 <matthiasgorgens> Sculptor: basically, the compiler knows quite a lot about all the data dependencies in your code.
09:21:43 <matthiasgorgens> Sculptor: so it can compile down to efficient code.
09:22:13 <matthiasgorgens> Sculptor: see https://donsbot.wordpress.com/2010/02/26/fusion-makes-functional-programming-fun/ for a good example of what's possible.
09:22:21 <matthiasgorgens> (and much harder to do in more conventional languages.)
09:22:46 <zhulikas> http://newartisans.com/2012/08/parsing-with-haskell-and-attoparsec/
09:22:48 <zhulikas> love this article!
09:23:07 <Sculptor> thanks matt
09:23:13 <matthiasgorgens> yeah, parsing is another success story for (statically-typed?) functional programming.
09:24:39 <matthiasgorgens> zhulikas: nice article!
09:24:48 <zhulikas> indeed
09:25:01 <zhulikas> it also makes me happy as I always was paranoid about performance
09:25:09 <performance> :)
09:25:18 <zhulikas> :)))
09:25:33 <dfordivam> Hello everyone
09:25:46 <zhulikas> performance, that's an awesome coinsidence
09:25:58 <dfordivam> Does anyone have any idea if Haskell has been used in some open source EDA tool
09:26:11 <dfordivam> EDA = Electronic Design Automation
09:26:42 <Sculptor> component level design, die level design, or transistor level design
09:26:43 <performance> dfordivam: BlueSpec is one but not opensource
09:26:46 <matthiasgorgens> zhulikas: if you can make the lazyness go away at just the right places (and stay at just the other right places), Haskell performance is pretty good.
09:27:07 <performance> zhulikas: happens more often than you think
09:27:30 <zhulikas> performance, not immediately after you enter I think
09:27:39 <dfordivam> yup I got to know about Bluespec and Haskell from My boss, He was a senior figure there a few years back
09:27:41 <zhulikas> otherwise yes, you should get spammed pretty often
09:28:09 <performance> :) yeah that is true, today was special in that i joined and it happened :) incidentally what was the article you guys were talking abt?
09:28:10 <matthiasgorgens> zhulikas: by recruiters?
09:28:24 <matthiasgorgens> performance: http://newartisans.com/2012/08/parsing-with-haskell-and-attoparsec/
09:28:52 <performance> oh yeah i read that yesterday.  But he is not clear in letting us know if the C++ version also skips the blobs or not
09:29:10 <zhulikas> matthiasgorgens, I had in mind performance's nickname :} it's a common word in CS industry :D
09:29:10 <performance> either case the Haskell code looks very clean and elegant compared to cpp
09:29:25 <matthiasgorgens> zhulikas: oh, yeah.
09:29:43 <matthiasgorgens> performance: it would be good to see the source of both versions.
09:29:51 <Philippa> I've seen blocked drains that look very clean and elegant compared to most cpp, though
09:29:54 <matthiasgorgens> oh, he has that. :o)
09:29:58 <dfordivam> Ok another question: any good article / publications regarding formal verification of software using Haskell
09:30:07 <performance> it is listed on his article i went through the Haskell version but not the cpp
09:30:15 <matthiasgorgens> dfordivam: the seL4 people did slomething like that.
09:30:24 <matthiasgorgens> they wrote a variant of the L4 kernel and proved it correct.
09:30:35 <matthiasgorgens> they employed a haskell prototype to inform their C product.
09:30:44 <performance> also some work on a C compiler using coq
09:31:07 <matthiasgorgens> performance: the c++ stuff doesn't look too bad.
09:31:10 <matthiasgorgens> looks almost like c.
09:31:29 <performance> yeah, wonder if he tries to improve that he might find more gains
09:32:14 <dfordivam> matthiasgorgens : Yes I see that
09:33:03 <performance> i am considering hiring a Haskell tutor, is anyone up for it?
09:34:22 <Philippa> huh. I think half the chan's been wondering when someone'd offer me something like that
09:35:06 <performance> does that mean you are interested in tutoring? or are you looking for one too?
09:35:12 <Philippa> the former
09:35:27 <performance> ok. then lets talk :)
09:36:27 <performance> Philippa: are you flippa?
09:36:43 <ReinH> Can someone try to tell me what algorithm I'm looking for if I give you a use case?
09:36:46 <Philippa> some people call me that, I go by flippac too
09:37:24 <dfordivam> matthiasgorgens : What is the area you will most likely use haskell for?
09:37:42 <Philippa> performance: are you anyone I might know of? (feel free to PM me the answer)
09:39:46 <timthelion> Rather than doing Data Foo a = Bar a has anyone ever created a metho free type class just to restrict what a can be?
09:40:17 <Philippa> it's not much of a restriction usually because classes are open world
09:40:42 * hackagebot errors 1.3.1 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.3.1 (GabrielGonzalez)
09:41:00 <timthelion> Philippa: sure, but at least it makes it clear than you don't mean "any a"
09:43:08 <triyo> What is the reason that the  Data.HashTable allows only for Int32 size keys?
09:43:18 <triyo> As oppose to Int64
09:44:24 <aristid> triyo: maybe you can to consider using Map or IntMap?
09:45:05 <Cale> I don't even think Data.HashTable should be exposed
09:45:20 <Cale> Isn't the main reason for it still existing that some bits of GHC use it?
09:46:17 <triyo> Right, that's what I'm currently using. However, those are self-balancing BST, hash table implementations perform better as far as I know.
09:46:29 <Cale> Not necessarily
09:46:36 <Cale> and Data.HashTable is bad
09:46:37 <triyo> So performance is the reason here, and what I'm after
09:47:03 <Cale> (from what I recall, it lost in performance benchmarks against Data.Map, let alone Data.IntMap)
09:47:46 <Cale> You might try the stuff in unordered-containers
09:47:53 <Cale> if you want better hash-based structures
09:47:55 <triyo> I just ran a test actually, and I seem to be getting the same behavior; that D.Map outperforms D.HT
09:48:11 <ReinH> Or just go with Data.Map until you actually need something faster
09:48:22 <ReinH> It's a sane starting point as it's quite efficient and usually fast enough
09:48:23 <Leif_Bork> Hi! Can anyone recommend a refactoring tool?
09:48:47 <Philippa> timthelion: so I'd be more likely to do it if closed classes exist. It's a nice thought though, maybe experiment with it?
09:48:53 <Cale> (also, Data.HashMap is *almost* a drop-in replacement for Data.Map, so it shouldn't be hard to switch if/when you really need to)
09:49:45 <ReinH> if you abstract data structure access behind an interface of "getter/setter" methods you only have one place to change if you change the impl
09:50:18 <ReinH> (some types might need to bubble out but that's easy)
09:50:30 <Cale> Leif_Bork: There was this thing called HaRe a long time ago, but I haven't heard anything about it in ages.
09:50:56 <Cale> Leif_Bork: Mostly when refactoring, the tool I use is just GHC. :)
09:51:21 <Cale> Leif_Bork: I make some change, and then run GHC and it gives me a list of type errors, and then I fix those and run GHC again
09:51:59 <Cale> and then when the thing compiles again, it almost always immediately works :)
09:53:08 <Cale> (I've even done this with refactorings involving hundreds of changes to a library which was a few thousand lines and had everything work out)
09:55:42 <triyo> Cale: Data.Map seems to outperform Data.HashMap in my test
09:55:59 <triyo> Quite interesting
09:56:13 <Leif_Bork> Cale: Thanks. Yea, I do the same thing, and it works out quite nicely, but sometimes you're forced into the Java world and Eclipse while working, and refactoring Java there is so excellent!
09:56:21 <Cale> Well, it's possible for Data.HashMap to do better sometimes, apparently
09:56:42 <hpaste> nand` pasted ‚ÄúSimple Core compiled to C#‚Äù at http://hpaste.org/73991
09:56:47 <ReinH> Leif_Bork: Java refactoring tools are good because trying to code Java without a refactoring crutch, I mean tool, is an exercise in pain and futility
09:57:02 <ReinH> so it's an itch that needed scratching
09:57:04 <triyo> Cale: yip it makes sense; under the right conditions...
09:57:36 <Cale> triyo: Data.Map gets used a lot, and it should be pretty well-tuned.
09:57:49 <timthelion> nand`: One is always glad, when generating code, that a language does not take indentation into account!
09:57:49 <Cale> So it's hard for other libraries to beat it.
09:58:08 <nand`> timthelion: I actually had indentation there in the first version, but deliberately removed it to increase the amount of noise
09:58:08 <lightquake> @pl \f g x -> if f x then g x else x
09:58:08 <lambdabot> flip flip id . (ap .) . liftM2 if'
09:58:12 <aristid> ReinH: the sad thing is just when java programmers refuse to look at other languages where those crutches/tools are not available
09:58:13 <nand`> and make it seem more complicated than it is
09:58:17 <Cale> Unless they really take good advantage of cache coherency or something, which Data.Map can't really.
09:58:38 <lightquake> @type flip flip
09:58:38 <Leif_Bork> ReinH: That's very true =)
09:58:39 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
09:58:46 <timthelion> nand`: what is the goal of your project?
09:58:49 <lightquake> caleskell strikes again!
09:58:57 <timthelion> nand`: obfuscated C#?
09:59:06 <nand`> timthelion: no. it is a Core dialect compiled down to C# :)
09:59:10 <lightquake> @type if'
09:59:11 <lambdabot> Not in scope: `if''
09:59:22 <aristid> Cale: well Data.Time is probably also used a lot, yet its time format/parse routines are known to be the performance bottleneck for a few people :P
09:59:22 <timthelion> nand`: then why did you want to make it seem more complicated?
10:00:04 <nand`> timthelion: to confuse myself, basically
10:00:12 <nand`> make sure I can never debug it
10:00:13 * timthelion sighs
10:00:29 <timthelion> nand`: I don't understand.  Why?
10:00:41 <ReinH> "Where's my refactoring tools?" "You don't need them. This langauge isn't a pain to work with without them."
10:00:48 <Cale> aristid: Possibly. I don't think they're that slow though -- nor do time formatting functions usually come under heavy performance scrutiny.
10:01:03 <nand`> timthelion: no real reason
10:01:10 <Cale> (whereas something like a finite map structure basically exists for performance benefit)
10:01:25 <timthelion> ReinH: hey, there are things, like changing types, that would really like some nice refactoring tools.
10:01:26 <dfordivam> Hey everyone To start with haskell I wrote a simple CSV to space separated convertor code its available here if u wanna look https://github.com/dfordivam/haskell_projects/blob/master/csvToSpaceSeparated.hs
10:01:31 <nand`> timthelion: I save a few bytes on my hard drive
10:01:38 <parcs`> hehehe derpendent types
10:01:42 <timthelion> nand`: then get rid of linefeeds too.
10:01:49 <dfordivam> What i wanna know is that what are good approaches of doing formal verification for such a code
10:02:10 <Cale> dfordivam: Check that you can round-trip?
10:02:13 <ReinH> timthelion: I find that s/OldType/NewType/gc is a pretty good type refactoring tool
10:02:49 <Cale> dfordivam: CSV -> Spaces -> CSV, and Spaces -> CSV -> Spaces should ideally both be identity functions.
10:02:59 <ReinH> and if you find that type spread out thorugh multiple files and that it's difficult to make that change
10:03:05 <ReinH> well you just learned something about coupling
10:03:18 <timthelion> ReinH: Coupling?
10:03:54 <dfordivam> Cale so for that you mean I need to write a Space -> CSV function also and use that for "round-trip" verification
10:04:06 <timthelion> dfordivam: of course.
10:04:43 <Cale> dfordivam: Yeah, for that approach, anyway
10:04:57 <ReinH> timthelion: yes, specifically connescence
10:05:06 <nooodl> guys! what's up with the etymology for "hylomorphism"? "hylo-" (·ΩëŒªŒø-) means "wood" or "matter", i don't see how that works
10:05:21 <timthelion> Cale: but how would that even be possible, How would you encode the CSV "Sally HammerSmith, Bob Tongsgot, Fred Jubulie" as Space seperated in a reversable fashion?
10:05:22 <dfordivam> ok that's 1st property, I think 2nd can be that the output should contain all the text in same order
10:05:25 <Cale> dfordivam: There might also be other properties of your encoding which you might want to check are always true.
10:05:33 <hpaste> nand` annotated ‚ÄúSimple Core compiled to C#‚Äù with ‚ÄúSimple Core compiled to C# (source)‚Äù at http://hpaste.org/73991#a73992
10:05:40 <Cale> timthelion: By quoting appropriately?
10:05:57 <jfischoff> has anyone ever used jmacro?
10:06:23 <ReinH> sorry, connascence
10:06:27 <Cale> timthelion: or at least ensuring that there's more than one space between the columns, so you don't have to quote things which have only single spaces in them.
10:06:34 <dfordivam> timthelion Nice catch!
10:06:35 <jfischoff> it is rejecting valid code, and I am not sure if it is worth sticking with
10:06:40 <performance> Cale: can i talk to you in PM
10:06:45 <Cale> performance: sure
10:07:18 <ben> :t (.)
10:07:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:07:33 <timthelion> dfordivam: program for a decade, and you'll think of that case before you hit the keyboard.
10:07:35 <performance> can you please ping me, i dont know how to start a PM on webchat
10:07:51 <timthelion> performance: /msg Nick stuff you
10:08:02 <Z`> Isn't 'group' in the prelude ?
10:08:10 <timthelion> performance: where "stuff you" is the message you want to send.
10:08:13 <Sculptor> performance, try: /query user
10:08:34 <timthelion> Z`: use Hayoo to find these things out.
10:08:38 <timthelion> Z`: or hoogle
10:08:41 <Z`> R lang has "?symbol" for searching across all packages to find 'symbol'. Does haskell have something related ?
10:08:42 <Z`> ah ok
10:08:45 <Z`> thanks timthelion
10:09:22 <performance> thanks Sculptor and timthelion
10:09:32 <dfordivam> Cale timthelion : One more thing My Space separated output is has all the columns aligned, so the amount of space between words is such that the words of a coloumn are all right aligned,   Any good approach to test this feature??
10:09:42 <Z`> It's in base Data.List, therefore it should be availaible without importing something. Right ?
10:10:01 <ReinH> timthelion: very complicated escaping or grouping, just like how you encode a field with a "," into CSV :p
10:10:24 <ReinH> the problem is that there are way more " " than "," in your average text, so space separated needs to do way more work
10:12:36 <timthelion> ReinH: the *real* problem is that the format is not standardized, and thus your output is kinda useless.
10:12:48 <ReinH> that's not a technical problem :p
10:12:50 <dfordivam> timthelion ReinH Cale : Let me repeat what I said last, The space separated output will have many rows/ lines and the content in all the "coloumns" in the output are right aligned. Any good approeches to verify that
10:13:10 <ReinH> dfordivam: really, why are you doing this?
10:13:15 <timthelion> ReinH: to learn
10:13:21 <ReinH> oh
10:13:23 <ReinH> weird
10:13:56 <dfordivam> ReinH timthelion : well actually I needed such functionality somewhere
10:14:10 <ReinH> o_O
10:14:51 <ReinH> seems unnecessarily complex to me
10:15:30 <dfordivam> ReinH timthelion : But ofcourse its for learning mainly, What kind of things will you do to learn haskell / or where will you apply haskell in practical code
10:15:56 <ReinH> dfordivam: I like to build systems that interest me, like chess engines http://haskelllive.com/
10:16:01 <timthelion> dfordivam: it's a fine project...
10:16:52 <dfordivam> ReinH: ooh that's way too complex for me!
10:17:00 <ReinH> dfordivam: maybe, maybe not
10:17:13 <ReinH> you just do it one step at a time
10:17:27 <ReinH> speaking of which, I'm late on my next episode :( getting sick sucks
10:19:03 <applicative> dfordivam: I don't think ReinH 's chess construction is too hard yet.   Maybe when he gets to IO or something
10:20:04 <timthelion> When I want to learn about something, I go on IRC and say "\"data\" in haskell sucks!!!111 because when I do data A = A Int | B String | C Cat and want a function that takes type :: C -> String, I have to redo my structure and it's ugly to do newtype A = A Int newtype B = B String newtype C = C Cat data A = A' A | B' B | C' C ; f :: C -> String...
10:20:20 <timthelion> And then people tell me that haskell doesn't suck.  And that it's really easy to do it in way X
10:20:20 <ReinH> applicative: more like when I get to iterative deepening search ;)
10:20:30 <ReinH> dfordivam: but yes, so far it's quite simple and not engine-ey at all
10:20:38 <dfordivam> Yup but apart from fun coding, where will you apply haskell on practical stuff,  i mean what are the areas where you will investing time and money on develping haskell code
10:20:50 <applicative> ReinH: yeah, actually maybe...
10:21:03 <ReinH> applicative: minimax is SUPER easy though, so there's that :)
10:21:33 <ReinH> applicative: simple interaction is just a print board -> read move -> make move -> print board loop :)
10:22:45 <ReinH> dfordivam: I'm mostly applying haskell to my brain to help me think in new ways about other problems I solve
10:23:21 <ReinH> at work we use Scala quite a bit, and I find that I write better Scala when I write it more like Haskell :)
10:23:44 <ReinH> but every now and then I do like to attempt an ICFP
10:27:47 <dfordivam> If my application involves more of data structure complexity and less algorithmic complexity, how do you think haskell will be beneficial for me
10:29:39 <matthiasgorgens> dfordivam: aren't algorithms and datastructures two sites of the same coin?
10:30:02 <matthiasgorgens> dfordivam: anyway, you are going to love algebraic data structures.
10:30:35 <nand`> matthiasgorgens: I seem to hate algorithms but love datastructures, if that makes any sense
10:30:56 <matthiasgorgens> nand`: have you read okasaki's purely functional data structure?
10:30:58 <matthiasgorgens> +s.
10:31:07 <ReinH> algorithms have structures, data has structures
10:31:20 <ReinH> haskell is good at structures
10:31:27 <nand`> matthiasgorgens: nope
10:31:36 <nand`> matthiasgorgens: is this about church encoding and the like?
10:31:39 <matthiasgorgens> also haskell unifies data structures and control structures.
10:31:55 <matthiasgorgens> nand`: I don't remember the book making use of church encoding.
10:32:01 <matthiasgorgens> they talk about queues quite a lot.
10:32:04 <ReinH> they are isomorphic and haskell presents this isomorphism in a very useful way
10:32:06 <matthiasgorgens> as the standard example.
10:32:08 <nand`> ah
10:32:27 <matthiasgorgens> okasaki's thesis, which was the basis for the book, is available online for free.
10:32:38 <dfordivam> matthiasgorgens: I find Haskell comparatively difficult in case of datastructures (wrt c++ for ex)
10:32:46 <nand`> so it's about actual algebraic data structures (for purely functional languages), as opposed to datastructures made from functions only (like church encoding)?
10:32:52 <ReinH> as in most algorithms become simple structure-independent operations (map, fold, unfold) over properly-chosen data structures
10:32:55 <dfordivam> matthiasgorgens: I have gone through both his book and thesis
10:33:06 <matthiasgorgens> dfordivam: interesting.  i find c++ and similar languages to be extremely clumsy at data structures, compared to haskell.
10:33:33 <nand`> I find every language without sum types to be clumsy at data structures
10:33:36 <ReinH> Haskell also makes it very easy to reason equationally about the behavior of algorithms
10:33:40 <matthiasgorgens> ReinH: also control structures become simple operations over the right data-structures.
10:33:48 <ReinH> matthiasgorgens: indeed
10:33:53 <matthiasgorgens> e.g. see monadic instances for Either to emulate error-handling.
10:34:13 <ReinH> Bird's Pearls of Functional Algorithms Design is a great book
10:34:21 <matthiasgorgens> nand`: yeah, tagged unions (to give a c-like moniker to sum-types) would make a good addition to almost any language.
10:34:35 <nand`> matthiasgorgens: haskell sum types *are* tagged unions :P
10:34:43 <matthiasgorgens> tagged unions are an idea, like garbage collection, that was born in FP, but I predict will be useful in all kinds of programming.
10:34:58 <ReinH> and it's all about algorithm design by equational reasoning (or "calculation", as he likes to call it)
10:35:07 <matthiasgorgens> nand`: yes.  it's just a different name.
10:35:27 <nand`> oh, yes; I thought you were implying that tagged unions are not true sum types
10:35:43 <matthiasgorgens> nand`: oh, no.  I was just giving c-like terminology.
10:35:49 <matthiasgorgens> http://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html
10:35:56 <matthiasgorgens> is a good example for red-black trees in haskell.
10:35:59 <Cale> dfordivam: You're crazy :)
10:36:20 <matthiasgorgens> Cale: what warranted that?
10:36:22 <Cale> dfordivam: It's way, way easier to define the datastructures you want in Haskell than C++
10:36:49 <matthiasgorgens> dfordivam: what features / pecularities of c++ and haskell contribute to your opinion?
10:37:00 <matthiasgorgens> (I can see that haskell record syntax is ugly. :o)
10:37:36 <Cale> We consider record syntax a bit ugly, but compared to what most languages have, I think it's not bad.
10:37:45 <nand`> lenses to the rescue?
10:37:48 <edwardk> ?
10:37:56 <nand`> re: ugly record syntax
10:37:58 <matthiasgorgens> yeah, lenses seem like a good idea.
10:37:59 <edwardk> ah
10:38:22 <matthiasgorgens> didn't common lisp have something similar to lenses (only imperative)?
10:39:26 <DT`> setf functions?
10:39:37 <DT`> or whatever they're called.
10:39:51 <matthiasgorgens> DT`: yeah, sounds about right.
10:40:26 <matthiasgorgens> but they are more about unifying L-values and R-values syntactically,
10:40:29 <matthiasgorgens> as far as I remember.
10:41:01 <DT`> setf expanders, that's the name.
10:41:02 <nand`> heap.traverseAt addr.ix i .= frame ! pos
10:41:05 <nand`> :)
10:41:29 <DT`> matthiasgorgens, indeed, IIRC there's an if-like setf expander too.
10:41:42 <dfordivam> Sorry folks I got logged out missed ur replies
10:41:56 <matthiasgorgens> dfordivam: what features / pecularities of c++ and haskell contribute to your opinion?
10:42:06 <ReinH> dfordivam: they were all to the effect that you're wrong and you should feel wrong ;)
10:42:08 <matthiasgorgens> on the relative ease of implementing data structures.
10:42:25 <ReinH> ok maybe not
10:42:41 <matthiasgorgens> (reinH, the bit about making him feel wrong comes later. :o)
10:42:45 <nand`> dfordivam: there are public logs: http://tunes.org/~nef/logs/haskell/12.08.31
10:42:50 <nand`> so you can read it up in full glory
10:42:56 <dfordivam> well in haskell if I write pure function I have to pass everything to it as arguments, In c++ I can just call An API in between to get details
10:43:21 <matthiasgorgens> yeah, that's a feature of haskell. :o)
10:43:28 <matthiasgorgens> though actually, you can hide the plumbing.
10:43:32 <matthiasgorgens> e.g. in a monad.
10:43:32 <nand`> because abstractions don't exist in haskell?
10:43:40 <Cale> dfordivam: You can bundle arguments together into data structures and write APIs for extracting the details you want.
10:44:25 <Cale> But even in C++ it's considered bad style to rely on global mutable variables.
10:45:36 <mausk> can anyone think of a tool or library that haskell actually needs, but hasn't been written only because nobody's written it?
10:45:52 <mausk> lookinh for a project
10:46:00 <dfordivam> Cale: u are right that way, But If I have a huge Data structure , passing that around to many APIs, will it not deteriorate the perf?
10:46:04 <matthiasgorgens> mausk: you could revive HAT.
10:46:07 <matthiasgorgens> the haskell tracer.
10:46:11 <matthiasgorgens> that was really useful, while it worked.
10:46:56 <Cale> dfordivam: It's just one pointer
10:47:24 <matthiasgorgens> dfordivam: haskell is basically copy-on-write anywhere.
10:47:31 <matthiasgorgens> so passing around huge data structures is way more efficient.
10:47:34 <Cale> dfordivam: Also, you're worrying about performance too much before profiling.
10:48:13 <matthiasgorgens> (of course the compiler is free to optimize away the copy on write, if it can prove that nobody has any reference to the old version.)
10:48:30 <Cale> Yeah, though that's never done in practice at the moment, I believe.
10:48:49 <matthiasgorgens> Cale: Clean supports that in the type system.
10:49:01 <matthiasgorgens> haskell doesn't, (yet?).
10:49:11 <mausk> matthiasgorgens: doesn't the recent stack traces in ghc make hat less interesting?
10:49:15 <ReinH> matthiasgorgens:  can I make him feel wrong now?
10:49:32 <mausk> would hat really be used much?
10:49:41 <dfordivam> Hmmm what If I write to a small part of the Big str? Will It create copies of the complete big thing?
10:49:46 <ReinH> You don't pass around a huge data structure
10:49:48 <matthiasgorgens> mausk: I don't know.  that was just the first thing at the top of my head.
10:49:49 <ReinH> You pass around a thunk
10:49:56 <ReinH> Don't forget about laziness
10:50:10 <matthiasgorgens> dfordivam: depends a bit on what string you are using.
10:50:25 <matthiasgorgens> for performance nobody uses the build in String as a linked list of chars any longer.
10:50:30 <matthiasgorgens> we use ByteString or so.
10:51:24 <matthiasgorgens> and if you are going to change stuff, having your data in a flat string is seldom the right choice.
10:51:25 <Cale> mausk: If by "stack traces" you mean the cost centre traces produced by code compiled for profiling, I don't think that's a reasonable replacement for Hat.
10:51:43 <matthiasgorgens> mausk: you can download an old version of ghc where hat works, and play around with it.
10:51:44 <Cale> mausk: Haskell evaluation in GHC doesn't involve a call stack.
10:51:55 <dfordivam> Ok If I have a collection of few hundred Map data structure in my "big" ds, will modifying one of the Map will create copies of "big" DS?
10:52:02 <Cale> mausk: and so any illusion of a call stack which is provided is really just that, an illusion.
10:52:18 <Cale> mausk: It doesn't really tell you anything about how things are *really* happening.
10:52:28 <mausk> right, of course, I was just reffering to the new flags
10:52:32 <DT`> dfordivam, depends on how your DS is structured.
10:52:40 <matthiasgorgens> Cale: hat also wanted to provide that kind of illusion.
10:52:41 <DT`> it might share big part of it.
10:53:14 <matthiasgorgens> dfordivam: I recommend (again) okasaki's Purely Functional Datastructures.
10:53:27 <Cale> matthiasgorgens: from what I understand, Hat was able to provide information about partially evaluated structures and could show lazy evaluation steps
10:53:30 <matthiasgorgens> dfordivam: but you say you've read it?
10:53:37 <matthiasgorgens> so you should know all about what we just told you.
10:53:44 <ReinH> It depends also on the laziness and strictness properties of your datastructure
10:53:47 <matthiasgorgens> about the sharing and stuff.
10:53:54 <matthiasgorgens> and lazyness and strictness.
10:53:57 <ReinH> spine strictness for instance can cause a lot of memory bloat
10:54:04 <ReinH> so strict is not always better
10:54:17 <dfordivam> matthiasgorgens : I read about how to create queue and binary trees etc
10:54:18 <Cale> It was really an illusion too, because Haskell isn't really lazily evaluated either, but lazy evaluation is a better illusion than call stacks from a fake strict evaluator :)
10:54:47 <ReinH> Cale: haskell also isn't really functional because processors are imperative, but please leave us our illusions :)
10:55:03 <Philippa> ReinH: not true in the slightest
10:55:06 <ReinH> and by illusions I mean models
10:55:22 <Cale> ReinH: Haskell has nonstrict semantics, but the language doesn't specify how those semantics are obtained
10:55:39 <Philippa> the underlying implementation doesn't have to be functional for the language to be functional
10:55:47 <Cale> Lazy evaluation is one particular implementation, and it's not even particularly realistic when it comes to how GHC will do things in reality.
10:55:51 <dfordivam> matthiasgorgens: I will get back, after having another look at the book,
10:55:57 <dfordivam> Bye all!
10:56:21 <ReinH> Cale, Philippa: it depends on what level you want to evaluate the system
10:56:30 <mausk> Is there general concern that too many functions use Int instead of Integer? I always thought it was a contradiction that haskell focuses on safety yet often uses unsafe types like Int
10:56:41 <Cale> mausk: I agree.
10:56:48 <ReinH> show me a non-procedural processor and I will show you a non-procedural haskell implementation
10:56:51 <Cale> mausk: Int shouldn't be in the Prelude, imo
10:56:56 <mausk> right
10:56:57 <ReinH> s/procedural/imperative
10:56:57 <Philippa> ReinH: 'haskell implementation' /= Haskell
10:56:57 <qwr> Cale: (stupid question...) what's the difference between lazy evalution and non-strict semantics?
10:57:12 <Cale> ReinH: http://www.cs.york.ac.uk/fp/reduceron/
10:57:16 <ReinH> Philippa: right, like I said, it depends on at what level you want to evaluate the system
10:57:19 <Philippa> but also: will someone hand-evaluating on a really big sheet of paper suffice?
10:57:34 <Philippa> well no. That's not levels, that's playing games about which level is called Haskell
10:57:54 <Cale> qwr: lazy evaluation refers to a specific order in which to evaluate expressions: it is outermost-first evaluation with sharing
10:58:01 <ReinH> Philippa: Haskell is modeled as a langauge
10:58:04 <ReinH> er
10:58:08 <ReinH> Haskell is modeled as a lazy langauge
10:58:27 <ReinH> if you want to say that the language is not lazy because its compiler is not lazy, I can also say that the langauge is not functional because its processor is not functional
10:58:30 <Philippa> ReinH: commonly, yes. Though that can be given a graph reduction semantics
10:58:53 <Cale> qwr: Nonstrict semantics means roughly that programs will have the same termination behaviour as outermost-first evaluation provides, and produce the same results, but opens up the potential for other evaluation orders.
10:58:55 <Philippa> no, you can't. Read what Cale is saying: the language is not lazy because the language is not, strictly (hah) speaking, lazy
10:58:56 <ReinH> we're both talking about implementation details
10:59:10 <qwr> Cale: ok.
10:59:17 <Philippa> it is 'non-strict', which is not a synonym for lazy
10:59:33 <ReinH> ok, s/lazy/non-strict and reevaluate
10:59:34 <Cale> Lazy people conflate the two though ;)
10:59:59 <Philippa> ReinH: at that point, non-strict is not an implementation detail
11:00:10 <ReinH> If the implementation of the compiler is relevant, so is the implementation of the processor that actually runs the machine code
11:00:30 <Philippa> and the compiler both uses a non-strict strategy and, being implemented in haskell, is itself non-strict
11:01:15 <ReinH> so you're saying it isn't lazily evaluated but it is non-strictly evaluated
11:01:15 <ReinH> ok
11:01:17 <ReinH> fine
11:01:39 <Lajla> No, it is lazily evaluated (depending on implementation)
11:01:46 <Cale> qwr: In particular, GHC does extensive analysis to discover cases where it's safe to evaluate things in a strict (innermost-first) order instead, and attain different performance behaviour than you'd expect from a lazy evaluator.
11:01:51 <ReinH> Lajla: then you're arguing at cross-purposes
11:01:56 <Lajla> No
11:02:10 <Lajla> As far as I know, the haksell specs do not define a particular evalauation strategy
11:02:29 <Lajla> However, the langauge is designed with a nod to allow a conforming implementation to be lazy and thereby optimize some things.
11:02:38 <Cale> "Non-strict semantics" only refers to the termination behaviour and results of programs
11:02:41 <Lajla> For a lot of languages, that is impossible.
11:03:01 <Cale> "Lazy evaluation" refers to the operational steps taken to reduce expressions to values
11:03:11 <ReinH> yes, I understand that
11:03:37 <Cale> In neither case is the underlying architecture of your CPU relevant.
11:03:54 <Lajla> I wouldn  be surprised (surprised if they didn't), force strictness in some cases to optimize based on some analysis.
11:03:54 <Cale> This is still above the layer of abstraction where everything can be written as an expression.
11:04:03 <ReinH> Right, so Haskell is not a lazy langauge, it has lazy implementations
11:04:08 <Philippa> Cale: Graph reduction. On paper. With no erasing and using => as appropriate :-)
11:04:08 <Cale> right
11:04:12 <Cale> :D
11:04:13 <ReinH> And haskell is not an imperative langauge, it has imperative implementations
11:04:20 <Lajla> As in, it would be surprising that if you have foo = 3 + 7 in your code that this is strictly evaluted, at compile time
11:04:25 <Lajla> Not just 'when you need it'
11:04:30 <Cale> Philippa: I have done this, on virtual paper more often than real paper :)
11:04:59 <timthelion> ReinH: well, you cannot really say that haskell is not a lazy language.  I can easilly show you things that without a lazy implementation will not run.
11:05:20 <Philippa> ReinH: Right. Except when we're punningly talking about the things embedded in it that make it "the world's finest imperative language"
11:05:21 <shapr> timthelion: It's non-strict, not lazy.
11:05:48 <ReinH> I love it when we violently agree
11:05:58 <Cale> timthelion: GHC, strictly speaking, doesn't implement lazy evaluation.
11:06:00 <Philippa> timthelion: I have every right to hand-evaluate that using call-by-name semantics, get bored as hell, and call what I'm doing "running a Haskell program"
11:06:03 <conal> saying that haskell is a lazy language is not even false. eager-vs-lazy is not a language property. strict-vs-nonstrict is.
11:06:03 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
11:06:19 <Philippa> conal: I disagree. A language can have resource semantics
11:06:30 <ReinH> conal: we're conflating the language and its implementations
11:06:33 <Philippa> The point is that Haskell doesn't have any defined
11:09:06 <Cale> Lajla: If that surprises you, you're in for a surprise, I think.
11:09:07 <timthelion> > let f n = (True, n); (bool,_) = f x ; x = if bool then 5 else 4 in x -- My favorite thing about laziness...
11:09:08 <lambdabot>   5
11:09:31 <Philippa> Cale: be fair, we don't have a type annotation for it :p
11:10:01 <Cale> foo = 3 + 7
11:10:01 <Cale> main = print foo
11:10:07 <timthelion> How can you define haskell, as being able to evaluate the example I just gave, without by doing so, saying it's lazy.
11:10:08 <Cale> ^^ compile that program with -ddump-simpl
11:10:15 <Lajla> Cale, really? Implementations do not just swap foo = 3 + 7 for foo = 10 at compile time?
11:10:18 <latro`a> timthelion: isn't that basically like fix $ const True
11:10:19 <latro`a> ?
11:10:20 <Philippa> Cale: yeah, that'll default
11:10:21 <Cale> Lajla: no, they do
11:10:28 <Lajla> Yes, that's what I'm saying.
11:10:30 <Cale> Philippa: right
11:10:47 <conal> timthelion: note what Cale is saying. GHC implements nonstrict semantics via a combination of lazy and eager evaluation.
11:10:49 <Cale> Lajla: okay, I think one of us inverted the sense of one of your sentences :)
11:10:51 <Philippa> (but once you have the type and the Num instance, you potentially know enough to know that it'll terminate and then the compiler can do what it likes)
11:10:56 <Lajla> Cale, ahh, okay
11:11:11 <Cale> <Lajla> As in, it would be surprising that if you have foo = 3 + 7 in your code that this is strictly evaluted, at compile time
11:11:15 <Lajla> What I'm saying is that int his case, a smart compile indeed uses very eager evaluation, one might argue that compile time evaluation is the most eager you can get.
11:11:17 <Lajla> Ohh
11:11:20 <Lajla> I meant 'wouldn't be surprising'
11:11:23 <Lajla> THe mistake is all mine.
11:11:25 <Cale> ah, okay :)
11:12:54 <Cale> timthelion: http://www.reddit.com/r/haskell/comments/ywula/yet_another_reason_not_to_be_lazy_or_imperative/c5znykk
11:14:20 * timthelion does not get fix...
11:14:33 <jfischoff> @src fix
11:14:33 <lambdabot> fix f = let x = f x in x
11:14:42 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
11:14:43 <lambdabot>   3628800
11:14:53 <Cale> > fix (1:)
11:14:54 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:15:38 * timthelion *still* doesn't get fix.
11:15:49 <Philippa> timthelion: take a recursive block, then pretend you're not allowed to use letrec. "Fix" this by parameterising it on itself. Use fix to tie the knot. That's about it
11:15:54 <Cale> fix finds the least-defined fixed point of a function
11:16:04 <Cale> If f _|_ = _|_ then fix f will be _|_
11:16:25 <Cale> But when f _|_ is at least partially defined, then so will its least fixed point
11:16:42 <Philippa> "fixed point" - the value that maps onto itself
11:17:03 <Cale> yeah, a fixed point of a function in general is a value x such that f x = x
11:18:00 <Cale> For example in the case of (1:),  (1 : undefined) is not undefined, (in particular, head (1 : undefined) = 1, so it had better not be the same thing as undefined)
11:18:41 * timthelion gets fix now :)
11:18:43 <Cale> and so we can expect the least fixed point of (1:) to be more interesting. It's a list which sticking a 1 onto the front of it won't affect its value
11:19:17 <joe9> need some advice please: code: http://codepad.org/F9g2a09F and I am trying to get to having this definition instead of single data declarations:  data Path    = Spiral | Parallel    deriving (Eq, Show)
11:19:18 <Cale> and of course, that's the infinite list that shows up there :)
11:19:31 <joe9> Is there anything I can do?
11:19:40 <wagle-prime> > fix (:1)
11:19:41 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
11:19:46 <joe9> such as Type dependencies or something like that?
11:19:51 <joe9> fundep?
11:19:54 <Yuu-chan> Hey, I got it too! So the [1..] is the fixed point of (1:) because (1:) [1..] is [1..]?
11:20:14 <Cale> Yuu-chan: yes
11:20:35 <latro`a> cept it's not actually [1..] :p
11:20:44 <Cale> it is!
11:20:50 <latro`a> > [1..]
11:20:50 <Cale> er, lol
11:20:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:20:53 <Cale> right
11:20:53 <latro`a> yeah, nitpick
11:20:56 <Cale> [1,1..]
11:20:56 <latro`a> > [1,1..]
11:20:57 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:21:07 <Cale> I auto-corrected both of those in my head
11:21:08 <Cale> heh
11:21:11 <lightquake> 1, 2, same difference
11:21:14 <latro`a> lol
11:21:35 <timthelion> let x = fix f in f x == id x === True for terminating functions?
11:21:36 <Cale> [1..] is the fixed point of (1:) . map (+1)
11:21:42 <Cale> > fix ((1:) . map (+1))
11:21:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:22:10 <latro`a> lol
11:22:11 <latro`a> cute
11:22:27 <latro`a> and more obvious from the "fixed point" definition than the operational one :D
11:22:36 <Cale> timthelion: yeah
11:22:45 <Cale> timthelion: well, look at the definition of fix, even
11:22:50 <Cale> fix f = x where x = f x
11:22:52 <Yuu-chan> But fixed point factorial still seems... mysterious.
11:23:00 <Cale> Okay, so for the factorial
11:23:20 <Cale> Well, we could approach the explanation from two sides
11:23:28 <Cale> Let's just evaluate first:
11:23:44 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
11:23:55 <Cale> = let x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x in x
11:23:56 <atriq> Hmm
11:24:17 <atriq> Is fix, (<*>), and pure turing-complete?
11:24:17 <Cale> = let x = \n -> if n == 0 then 1 else n * x (n-1) in x
11:24:28 <Cale> = let x n = if n == 0 then 1 else n * x (n-1) in x
11:24:37 <Cale> which is the same as your usual recursive definition of fac
11:24:38 <latro`a> atriq: <*> and pure alone are turing complete modulo type issues
11:24:40 <Cale> right?
11:24:55 <atriq> latro`a, I mean, does fix get around the type issues?
11:25:06 <latro`a> hm, interesting question
11:25:08 <Cale> atriq: I believe it ought to be
11:25:11 <atriq> I am the guy who wrote a factorial calculator using unsafeCoerce to get around the type issues
11:25:37 <latro`a> ah
11:25:52 <atriq> Just fix seems a lot less evil
11:25:54 <latro`a> reminds me of that SKI hello world
11:25:59 <Cale> adding fix to the simply typed lambda calculus makes it Turing complete, so it should do the same for the SK calculus.
11:26:07 <timthelion> latro`a: so how to you implement 5 + 5 with <*> and pure alone?
11:26:10 <atriq> Although, I suppose being evil was kind of the point...
11:26:23 <latro`a> timthelion: look up the SK calculus
11:26:42 <atriq> zero = \f x -> x = pure (pure <*> pure)
11:26:50 <latro`a> it has an analogue of the church numerals
11:27:01 <latro`a> along with church numeral arithmetic
11:27:25 <Yuu-chan> Thank you Cale!
11:27:51 <Cale> Yuu-chan: another thing to note is that applying (\fac n -> if n == 0 then 1 else n * fac (n-1)) to undefined doesn't give you a completely undefined function
11:28:03 <atriq> succ = \n f x -> f (n f x) = \n f -> pure f <*> n f = \n -> (\f -> (<*>) (pure f)) <*> n = (<*>) (pure (<*>) <*> pure)
11:28:05 <Cale> In particular, it will give you a function which is defined at 0
11:28:17 <Yuu-chan> I think I should solve a couple of examples myself and develop an intuitive understanding
11:28:24 <latro`a> > (\fac n -> if n == 0 then 1 else n * fac(n-1)) undefined 0
11:28:25 <lambdabot>   1
11:28:27 <latro`a> :)
11:28:29 <atriq> With those you can get 5 = succ (succ (succ (succ (succ zero))))
11:28:33 <Cale> and by applying that function more times, you get functions which are defined on successively more values
11:29:00 <Cale> let f = (\fac n -> if n == 0 then 1 else n * fac(n-1)) in map (f (f undefined)) [0,1,2]
11:29:06 <Cale> > let f = (\fac n -> if n == 0 then 1 else n * fac(n-1)) in map (f (f undefined)) [0,1,2]
11:29:07 <lambdabot>   [1,1,*Exception: Prelude.undefined
11:29:09 <nh2> how do I query what OS I'm running at runtime?
11:29:18 <Cale> > let f = (\fac n -> if n == 0 then 1 else n * fac(n-1)) in map (f (f (f undefined))) [0,1,2,3]
11:29:19 <lambdabot>   [1,1,2,*Exception: Prelude.undefined
11:29:47 <atriq> plus = \m n f x -> m f (n f x) = \m n f -> pure (m f) <*> n f = \m n -> (\f -> (<*>) (pure (m f))) <*> n yadda yadda yadda
11:29:49 <atriq> point is, you can
11:30:11 <Cale> Another implementation of fix (which is slightly worse performance-wise) is  fix f = f (fix f), and so fix f is like  f (f (f (f (...))))
11:30:48 <lightquake> nh2: System.Info.os
11:30:55 <lightquake> (note that this is a String, not an IO String!)
11:31:00 <Cale> lightquake beat me to it :)
11:31:05 <atriq> fix f is only useful if f sometimes ignores its first argument
11:31:15 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/System-Info.html
11:31:27 <lightquake> i just want to know what we'll do in the super-awesome future when programs change what OS/architecture they're running on!!!
11:31:35 <Cale> atriq: well, "ignores" :)
11:31:45 <Cale> (1:)
11:31:57 <atriq> Or is like that
11:32:06 <lightquake> fix f is only useful if f is not strict
11:32:24 <atriq> Yeah, I forgot about stuff like that
11:32:33 <Cale> You might be able to say that (1:) always ignores its argument, because it is able to produce a cons cell immediately without having to pattern match
11:32:58 <atriq> It ignores its first argument if the tail of the list is never asked for
11:33:04 <nh2> lightquake: very helpful!
11:33:12 <nand`> you mean ‚Äúis not strict in its first argument‚Äù ?
11:33:13 <wagle-prime> there are strict fixpoint operators, but i forget how to compute them
11:33:27 <lightquake> nand`: yes
11:34:15 <Yuu-chan> Combinatory logic is dreadfully powerful.
11:34:50 <wagle-prime> (:1) doesn't pattern match, but it does do an occurs check
11:35:02 <Cale> hah
11:35:08 <lightquake> i think you mean (1:) :P
11:35:15 <wagle-prime> not i
11:35:26 <lightquake> oh
11:35:30 <wagle-prime> fails the occurs check
11:35:49 <wagle-prime> > fix (:1)
11:35:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
11:36:13 <wagle-prime> </trivia>
11:36:30 <Lajla> Philippa, anyway, you wouldn't know per chance a way to overload a function for arbitrary types except making a typeclass for all the types a function would be able to handle?
11:36:51 <Lajla> As in, say I have a numberToString 13 which does it in base 10, but numberToString (13, 16) does it in base 16
11:40:41 <Rc43> Hi, guys.
11:40:47 <atriq> Hello
11:40:47 * hackagebot GLFW-task 0.1.0.1 - GLFW utility functions to use together with monad-task.  http://hackage.haskell.org/package/GLFW-task-0.1.0.1 (PaulLiu)
11:41:07 <Rc43> Is there something standard for building sorted binary trees from list of values?
11:41:20 <atriq> Hmm
11:41:23 <Philippa> Lajla: I'm not sure that description makes sufficient sense to me, sorry
11:41:23 <Cale> Lajla: Typeclasses are the right way to handle that.
11:41:28 <kashyap> Hi all, I need a quick advice .... is this a good type for a handler function - StateT T1 (ErrorT T2 IO) T3 - say, if I want to write an HTTP server then would it be the right type for the handshake function for example
11:41:48 <atriq> Rc43, is Data.Set what you're looking for? It's a long shot, but it sounds like the closest in the Haskell Platform
11:41:49 <kashyap> Or should ErrorT be the outermost wrapper
11:42:06 <Cale> Lajla: Though, tbh, two separate functions are probably moreso the right way.
11:42:10 <Rc43> I have a thought about how to implement binary expressions parsing with such thing (with any priorities, etc.).
11:42:15 <Lajla> Cale, indeed, it's just that I would have to define a typeclass for all such functions, gets cumbersome.
11:42:18 <Cale> Lajla: as I can't imagine requiring polymorphism
11:42:28 <Cale> (between those two cases)
11:42:49 <Lajla> Cale, it of course doesn't, as it's just different functions with the same name for ease, but I'm personally not a fan of longAndDescriptiveFunctionsInCamelCase
11:42:54 <Rc43> atriq, no, I need tree structure, not sorted colelction
11:43:09 <Cale> Lajla: hehe, just add a ' to the end of the name :)
11:43:28 <atriq> Rc43, sorry, I can't help you, then, beyond telling you to skim through Hackage.
11:43:49 <Rc43> atriq, ok :)
11:44:22 <Cale> numberToString' 16 13 --> "d"
11:44:29 <Lajla> That would probably confuse people reading the code though, including myself. But yeah, type classes are obvious a solution, just cumbersome, it would be nice if you could just use a simple union type and go numberToString :: (num x, num y) => x | (x, y) -> String or something
11:44:38 <Cale> numberToString = numberToString' 10
11:44:47 <jdnavarro> is there an equivalent of Python `strip` string method for Haskell ByteStrings? http://docs.python.org/library/stdtypes#str.strip
11:45:25 <Cale> Lajla: there's another advantage to defining it with two parameters rather than a pair :)
11:45:34 <jfischoff> jdnavarro: that is basically filter
11:45:48 <Cale> (in that you can take the base first, and get a function which converts numbers to strings)
11:46:21 <Rc43> atriq, btw, there is AVL tree on hackage (may be it will help me)
11:46:23 <Lajla> Cale, indeed, I'd rather just have an easy way of basically overload and give two different functions the same name but a different type signature a la C
11:47:06 <jdnavarro> jsaacmk: I was already implementing it with filter but if there is a character in the middle of the ByteString I don't want it stripped
11:47:13 <Cale> Lajla: yeah, that's not allowed basically because it screws with type inference (making it easy to get situations which hit exponential blowup in possibilities to try in order to be able to typecheck an expression)
11:47:47 <Rc43> But thought about building AST like AVL seems bad now; because AVL has many ways to be built, but AST only one (if I am right).
11:47:49 <jfischoff> jdnavarro: good point
11:47:53 <joeyh> I'm looking for a good/simple example of using STM TArray
11:48:03 <wagle-prime> jdnavarro: http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html
11:48:06 <Rc43> *not AVL but sorted binary tree
11:48:31 <wagle-prime> hmm..  that URL looks suspicious
11:48:39 <jfischoff> jdnavrro: I can think how you could do it with dropWhile and reverse, but it wouldn't be fast
11:49:06 <Lajla> Cale, indeed, would be nice if it was allowed if you explicitly typed it like that though.
11:49:21 <Lajla> Or maybe require you to give two different type annotations for the same function if such a thing happened.
11:49:41 <Cale> Lajla: I dunno, I've gotten used to the fact that any given name has a well-defined type.
11:49:49 <Cale> and I rather like things that way
11:50:14 <jdnavarro> wagle-prime: that's exactly what I need, thanks!
11:50:17 <Lajla> Well, I've gotten used and I don't like it, ahaha. A function can be identified by a combination of its name and its type signature I feel.
11:50:29 <Lajla> They are just two different functions if you will who share the same name, but not the same type.
11:50:42 <Cale> Well, typeclasses give you a more principled way to do that.
11:50:42 <wagle-prime> jdnavarro:  looks obselete
11:50:48 <wagle-prime> but
11:50:48 <Cale> which even admit polymorphism
11:50:52 <kashyap> Dear all ....I need a quick advice .... is this a good type for a handler function - StateT T1 (ErrorT T2 IO) T3 - say, if I want to write an HTTP server then would it be the right type for the handshake function for example
11:51:23 <Cale> kashyap: That's a hard question to answer without seeing the rest of the application.
11:51:25 <wagle-prime> @hoogle strip
11:51:25 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
11:51:26 <lambdabot> Data.Text strip :: Text -> Text
11:51:26 <lambdabot> Data.Text.Lazy strip :: Text -> Text
11:51:39 <Cale> kashyap: Personally, I try to hide the fact that I'm using monad transformers as much as possible
11:51:56 <latro`a> jdnavarro, isn't that essentially init . tail?
11:51:58 <fmap> jdnavarro: you shouldn't use ByteString for text processing
11:52:20 <fmap> and Data.Text.Lazy has `strip'
11:52:27 <latro`a> so it does
11:52:33 <jfischoff> the Text.Data.strip is fast
11:52:34 <jdnavarro> fmap: I'm dealing with network data...
11:52:36 <Lajla> Cale, well, typeclasses basicalyl do the same thing except globally, in this case I only need it for a single function and therefore creating a whole typeclass containing Num and (Num, Unsigned) just for this one function is cumbersome and a bit of hacking around.
11:52:45 <kashyap> <Cale> so essentially, I need to take a Handle and do some IO but at each read I could decide to abort the the rest of the computations
11:52:57 <jfischoff> unlike the MissingH version
11:52:58 <Lajla> But obviously the 'haskell way' in this case is just giving the two functions different names.
11:53:15 <Cale> kashyap: My advice is to start with the simplest, most straightforward implementation, without any new monads to speak of, and then see if it fits some pattern.
11:53:42 <Cale> Lajla: right
11:53:49 <Cale> Lajla: and that's what I'd recommend doing
11:53:59 <Cale> showInteger, showIntegerAtBase
11:54:09 <jdnavarro> do you recommend using text even for network data?
11:54:12 <Cale> it makes the code clearer too
11:54:54 <latro`a> bah, handwaving use of big O notation :|
11:54:55 <lightquake> jdnavarro: for a stream of bytes, you want ByteString
11:55:03 <latro`a> (Data.Text.replace)
11:55:04 <fmap> jdnavarro: i'd recommend using Text if you treat your data as text
11:55:06 <Cale> Lajla: In the extreme case, lol, I'm currently maintaining this pile of crappy groovy code which has 13-parameter functions distinguished only by the types of a few of the parameters.
11:55:08 <Lajla> Cale, it's an opinion I guess, I find longAndDescriptiveFunctionNames to add too much weight to code to comfortably read it. I'm one of those people who feel that a lot of punctuation and very little keywords make code the most readable, it differs from person to person
11:55:20 <Lajla> Cale, indeed, that might be a bit too much
11:55:38 <Lajla> You do want to be able to instantly recognise the type of the argument of course for this too work and know which it is
11:55:39 <kashyap> <Cale> Here's the code I have so far ...https://github.com/ckkashyap/haskell-websocket/blob/master/src/lib/Net/WebSocket/Request.hs
11:55:47 * hackagebot snaplet-postgresql-simple 0.2.0.1 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.2.0.1 (DougBeardsley)
11:56:21 <Cale> kashyap: btw, there are tab characters in this code
11:56:31 <Cale> you should expand them to spaces, and configure your text editor to do that for you
11:56:44 <joe9> does the haskell float suffer from IEEE precision issues?
11:56:48 <kashyap> will do
11:56:51 <jdnavarro> fmap: makes sense, I'll use the strip function from the text package then, thanks
11:56:55 <joe9> is it better to use double?
11:57:09 <Cale> joe9: They're both IEEE floating point
11:57:22 <Cale> joe9: Float is single precision, Double is double precision
11:57:36 <Cale> Usually it's better just to use Double
11:57:42 <byorgey> joe9: if you care about precision, consider using something like Rational instead
11:57:52 <joe9> Cale, I tried double. but, I could not get printf to work with it.
11:58:02 <byorgey> which doesn't work for every use case but it's worth considering whether you really need floating point.
11:58:07 <lightquake> use ByteString if you're dealing with a bunch of bytes, like a PNG file or something. use Text if you're using Text
11:58:09 <joe9> byorgey: thanks. yes, i care about precision. will check out rational.
11:58:15 <Cale> printf should work with Double, but... ugh, printf
11:58:28 <byorgey> joe9: what are you using it for?
11:58:30 <lightquake> in haskell we do not print things!
11:58:33 <joe9> http://codepad.org/67Mg8upH
11:58:56 <Cale> > printf "%f" (pi :: Double) :: String
11:58:57 <lambdabot>   "3.141592653589793"
11:59:08 <joe9> byorgey: a cnc gcode value. I am doing everything in Int (micrometer units). but, the printing needs to be in millimeter.
11:59:09 <jfischoff> why would I get type errors in ghci but not when building with cabal, assuming I have the same settings in both?
11:59:23 <jfischoff> are the ghci defaults different?
11:59:34 <Cale> joe9: That sounds like you're trying to use the result of printf as a Double
11:59:34 <joe9> I am converting the unit from micrometer to mm with (fromIntegral x) / 1000
11:59:48 <Cale> joe9: PrintfType is the class of types of results of printf
11:59:50 <dcoutts> jfischoff: if the settings are really the same then you should not
11:59:51 <joe9> Cale, yes, stupid of me.
12:00:00 <joe9> Cale, a mistake. thanks for catching it.
12:00:03 <jfischoff> hmm I check again
12:00:44 <Cale> thank GHC for catching it, you mean :)
12:00:46 <dcoutts> jfischoff: note that old cabal files that don't specify "default-language:" end up using H98, while ghc/ghci now defaults to H2010
12:01:13 <jfischoff> ok i'll try adding H2010
12:01:14 <byorgey> joe9: oh, don't convert that way!  Use `div` to do integer division.
12:01:30 <dcoutts> jfischoff: default-language: Haskell2010
12:01:31 <joe9> byorgey: but, the result can have decimals
12:01:42 <jfischoff> dcoutts: thanks
12:01:43 <byorgey> joe9: oh, I see what you mean
12:02:10 <joe9> i am checking out rational.
12:02:20 <Cale> I don't actually recommend using printf
12:02:32 <byorgey> joe9: ok, then Double should work just fine.  It will certainly be able to give you 3 decimal places of precision.
12:02:53 <byorgey> Cale: what's the alternative to printf if you want to print a fixed number of decimal places?
12:03:08 <Cale> show*Float in Numeric
12:03:23 <byorgey> aha
12:03:49 <byorgey> joe9: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Numeric.html
12:03:56 <Cale> > showFFloat (Just 3) pi ""
12:03:57 <lambdabot>   "3.142"
12:04:03 <rzys> hm somebody got an idea for a little haskell project? got some spare time this weekend
12:04:04 <Cale> > showEFloat (Just 3) pi ""
12:04:04 <joe9> cale, instead of converting to micrometers, can I just use rational and stick with millimeters?
12:04:05 <lambdabot>   "3.142e0"
12:04:08 <Cale> > showGFloat (Just 3) pi ""
12:04:09 <lambdabot>   "3.142"
12:04:19 <joe9> the only reason I converted to micrometers is to avoid losing precision.
12:04:28 <timthelion> rzys: implement conways life with one thread per cell
12:04:32 <joe9> if rational can maintain precision, then I would use it.
12:04:49 <Cale> joe9: *maybe* you can do that
12:05:07 <Cale> joe9: If you need trig functions or square roots or anything like that, then Rational is insufficient
12:05:30 <joe9> oh, ok. will stick with int's then.
12:05:33 <Cale> joe9: also, you have to be a little careful about the unbounded precision of Rational
12:05:34 <rzys> timthelion, ah good idea! thanks
12:05:43 <joe9> btw, how can I printf a rational?
12:05:44 <Cale> You may also be interested in Data.Fixed
12:05:46 <byorgey> Cale: but in that case so are Ints.
12:05:50 <joe9> > printf "%0.4" (0.05 :: Rational)
12:05:51 <Cale> which is for fixed point arithmetic
12:05:51 <lambdabot>   No instance for (Text.Printf.PrintfArg
12:05:51 <lambdabot>                     (GHC.Real.Ratio ...
12:05:59 <joe9> > printf "%0.4f" (0.05 :: Rational)
12:06:00 <lambdabot>   No instance for (Text.Printf.PrintfArg
12:06:00 <lambdabot>                     (GHC.Real.Ratio ...
12:06:04 <Cale> Yeah, you can't
12:06:08 <joe9> > printf "%0.4f" . fromIntegral $ (0.05 :: Rational)
12:06:09 <lambdabot>   No instance for (GHC.Real.Integral GHC.Real.Rational)
12:06:09 <lambdabot>    arising from a use...
12:06:13 <Cale> printf doesn't know how to deal with Rational values
12:06:15 <Cale> use show
12:06:30 <joe9> > show (0.05 :: Rational)
12:06:31 <lambdabot>   "1 % 20"
12:06:34 <geekosaur> and it'd be fromRational, not fromIntegral
12:06:43 <joe9> cale. ok, thanks.
12:06:51 <joe9> > printf "%0.4f" . fromRational $ (0.05 :: Rational)
12:06:52 <lambdabot>   Ambiguous type variable `b' in the constraints:
12:06:52 <lambdabot>    `Text.Printf.PrintfType ...
12:06:53 <mauke> joe9: or use Text.Printf.Mauke
12:07:09 <Cale> joe9: I think you really want Data.Fixed
12:07:11 <joe9> mauke: thanks, will check it out.
12:07:21 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/Data-Fixed.html
12:07:22 <joe9> Cale:  let me check Data.Fixed
12:09:06 <Cale> > (fromIntegral 473829) / 1000 :: Milli
12:09:07 <lambdabot>   473.829
12:09:15 <nh2> why could it be that this blocks forever (on windows only)? timeout 1000000 $ withSocket (\s -> accept s >> print "yeah")
12:09:47 <joe9>  > (fromIntegral 473829) / 1000 :: Micro
12:09:50 <nh2> I was relying on timeout killing the IO action after that 1s, but apparently on windows, that doesn't always work
12:09:54 <joe9> > (fromIntegral 473829) / 1000 :: Micro
12:09:55 <lambdabot>   473.829000
12:10:18 <joe9> > show ((fromIntegral 473829) / 1000 :: Micro)
12:10:19 <lambdabot>   "473.829000"
12:10:22 <Cale> joe9: Of course, milli-millimetres are micrometres.
12:10:34 <ziman> what happens if you lower the timeout? is that number guaranteed to be interpreted as microseconds?
12:10:45 <wavewave> hi
12:10:49 <joe9> Cale, thanks for your help.
12:11:01 <nh2> ziman: yes, it's microseconds, from System.Timeout
12:11:08 <joe9> mauke: checked out Text.Printf.Mauke. it looks pretty cool too.
12:13:01 <nh2> the nice thing is I cannot even ctrl-c or ctrl-break it
12:13:18 <byorgey> does Malcolm Wallace hang out in here?
12:14:30 <nh2> byorgey: I have a question about your recent highlight-versions
12:14:37 <byorgey> nh2: ask away
12:14:55 <nand`> > (1 :: Micro) + (1 :: Milli)
12:14:56 <lambdabot>   Couldn't match expected type `Data.Fixed.E6'
12:14:57 <lambdabot>         against inferred type ...
12:14:59 <nand`> ah
12:15:04 <nh2> byorgey: could you also make one that just operates on ghc-pkg list and shows you all packages which are newer on hackage than in your .cabal?
12:16:05 <dcoutts> nh2: cabal install world --dry-run would do that (with the modification following byorgey's suggestion)
12:16:39 <byorgey> nh2: it already can operate on ghc-pkg list, just do  ghc-pkg list | highlight-versions  to see installed packages that have newer versions on hackage
12:16:59 <byorgey> nh2: I don't understand what you mean about "in your .cabal"
12:17:37 <merijn> Suppose I have a mutating graph (of chan's and forkIO threads), what would be the best way to keep a representation of the graph state that I can access globally?
12:18:12 <nh2> byorgey: I just meant "that you installed with cabal install into your home folder (in contrast to base and so on which are in that first section of ghc-pkg list). But if that already works, perfect!
12:18:31 <byorgey> nh2: I am pretty sure it works, I'm double-checking now
12:18:47 <byorgey> nh2: whoops, it doesn't
12:18:48 <merijn> dcoutts: I ran into a problem where unix-time and a bunch of packages using C sources wouldn't compile on OSX due to the way cabal calls configure, I did a pull request on github with the fix.
12:18:52 <byorgey> I will fix it, it should
12:19:10 <nh2> dcoutts: yes I tried this, but I tend to get conflicts with that before it spits out the results
12:20:05 <dcoutts> merijn: btw, do you have any idea how to get an rss feed with these kind of notifications, so I'll notice when people make pull requests etc?
12:20:31 <jfischoff> @tell bos why doesn't Data.Aeson.Value have a Data instance?
12:20:32 <lambdabot> Consider it noted.
12:20:57 <merijn> dcoutts: I made an RSS feed of pull request for myself, but I don't remember how, let me check :p
12:21:15 <nh2> byorgey: yep, it's the whitespace, ghc-pkg list | cut -d' ' -f5 | highlight-versions works
12:21:20 <t7> @ pl \x -> f x == x
12:21:29 <byorgey> dcoutts: look for your "notification settings" on github, I think
12:21:30 <t7> @pl \x -> f x == x
12:21:30 <lambdabot> (==) =<< f
12:21:35 <byorgey> nh2: yes, exactly
12:21:40 <dcoutts> byorgey: yes that's there but there's no rss
12:21:50 <byorgey> dcoutts: oh, ok, I don't know then
12:22:25 <jfischoff> dcoutts: the language specification didn't fix it. The error is odd. It is compiling that I am using `H.HashMap T.Text Value` instead of `Object` which is defined as: type Object = HashMap Text Value
12:22:36 <dcoutts> byorgey: or rather, it has a totally useless rss that contains all *my* actions, like me commenting on patches but doesn't things that need my attention
12:22:39 <jfischoff> dcoutts: works fine when compiling still
12:22:50 <byorgey> nh2: it's kind of a hack, probably to do it properly I should look for things that look like package identifiers anywhere, instead of just at the beginning of the line
12:22:53 <byorgey> dcoutts: hehe
12:22:53 <merijn> dcoutts: They seem to have removed per-repo RSS feeds, the best way seems to be to add the RSS feed of your profile and then use the notification center to change the number of notifications yoou get?
12:23:09 <dcoutts> jfischoff: then it's a package/dependency difference. ghci is picking up different deps.
12:23:20 <jfischoff> dcoutts: ah cool
12:23:35 <nh2> byorgey: maybe just lstrip each line?
12:23:51 <byorgey> nh2: yes, that's what I'm going to do for now
12:23:53 <dcoutts> merijn: do they have an rss feed of your notifications though? I could only find a feed of my own actions
12:25:39 <merijn> dcoutts: On my homepage I see a "News feed" link which seems to contain pull requests and comments on my pull requests
12:26:58 <dcoutts> merijn: oooh, that looks like just what I need
12:27:31 <nh2> I hate how on windows everything seems to be magic ... it makes me feel so out of control
12:29:46 <bgamari> nh2, amen
12:30:02 <carter> byorgey: btw, mac homebrews changes a wee bit so that the cairo installing stuff needs slightly different directions now :)
12:30:21 <byorgey> of course =P
12:30:36 <byorgey> carter: will you write them up?
12:30:42 <carter> have I ever not :)?
12:31:04 <byorgey> thanks
12:31:11 <byorgey> that's what I pay you the big bucks for
12:31:22 <byorgey> =)
12:31:29 <carter> exactly
12:31:52 <carter> you pay me in great BSD3 stuff i'm going to use heavily in my awesome proprietary pending haskell platform distro :)
12:33:34 <enth> what jobs are available for 'professional haskell coders?
12:33:54 <enth>  ones that pay in a versatile currency
12:34:10 <t7> not many
12:34:23 <Clint> mongodb evangelist
12:34:39 <Eduard_Munteanu> Versatile how?
12:34:51 <enth> isn't mongodb c++ though?
12:34:52 <t7> mongodb uses javascritp for queries
12:35:08 <MrZepeda> http://www.haskellers.com/jobs
12:35:12 <enth> Eduard_Munteanu: not bitcoin
12:35:20 <BMeph> enth: Just curious, but what is a "versatile currency"? Do euros count?
12:35:33 <t7> dollar isnt in that set
12:35:40 <enth> BMeph: sure, for the next little while
12:35:51 <Eduard_Munteanu> Heh.
12:40:48 * hackagebot highlight-versions 0.1.2.0 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.2.0 (BrentYorgey)
12:41:18 <byorgey> nh2: ^^^
12:41:58 <edwardk> byorgey: trying to figure out how to really use product kinds
12:42:28 <byorgey> edwardk: fun
12:42:48 <edwardk> byorgey: i think more work might be needed on how to deal with equality and polymorphism over data kinds.
12:43:28 <byorgey> edwardk: you say that as if I know anything at all about the current implementation.
12:43:46 <byorgey> edwardk: or do you mean in a theoretical sense?
12:43:53 <edwardk> byorgey: well, going back to the paper even, theory not practice
12:43:58 <byorgey> ah, ok
12:44:07 <edwardk> simon is bogged down in the current practice
12:44:12 <byorgey> you say that as if I remember anything about the paper.
12:44:17 <edwardk> i'm bogged down in trying to use them ;)
12:44:19 <edwardk> haha
12:44:22 <nh2> what was the reason again why cabal update is so incredibly slow?
12:44:23 <edwardk> good answer
12:45:06 <nh2> byorgey: works well
12:45:12 <byorgey> nh2: great!
12:45:37 <edwardk> basically my issue seems to boil down to when i have a polymorphic product kind (or any other single constructor data type) i can't refine it to know that its inhabitants are all '(a,b) for some a and b.
12:46:06 <edwardk> and there isn't any incantation i can come up with that doesn't involve an unsafeCoerce to do it
12:46:15 <parcs`> nh2: because you haven't made it faster!
12:46:44 <edwardk> i can make a type family that projects out Fst and Snd, but i have no way to prove that '(Fst ij,Snd ij) ~ ij
12:48:15 <Dashkal> edwardk: the other day we were talking about adjoints and isomorphisms, but I forget to what end.  Do you recall?  (I just reached adjoints in the CT text I'm reading)
12:48:17 <wavewave> hi, is there any way to make ghc choose different directory than .ghc in one's home directory?
12:48:25 <wavewave> also cabal.
12:49:21 <dcoutts> wavewave: yes, there's a flag to specify the package db, and another to tell it not to look at the user package db. This is also doable via cabal.
12:49:52 <edwardk> Dashkal: we were talking about how you get a monad when you compose an adjunction one way and a comonad when you compose it another, and how free monads are left adjoint to the forgetful functor from the category of monads to the category of endofunctors, and how cofree comonads arise similarly from the right adjoint to a forgetful functor from a category of comonads to the category of endofunctors.
12:50:27 <edwardk> and i think we worked through roughly the adjunction that gives rise to lists as the free monoid.
12:50:44 <edwardk> not sure if that part was with you or tnks
12:50:46 <Dashkal> we started walking through that, but I lost you there.  danke.
12:50:58 <wavewave> dcountts: is it  -no-user-package-conf?   thanks.
12:51:11 <Dashkal> And so I picked up my CT book again to learn adjoints so as to understand what you were saying.
12:52:17 <nand`> half of every CT book is introducing primitive abstractions that will all be forgotten later on when you learn about the more general concept of which they're all examples
12:52:22 <Dashkal> wow, now that I can parse that better, I have some ways to go before all that becomes clear
12:52:46 <Kaidelong> I think the main problem I've had with CT books so far is how dense they are
12:52:59 <Dashkal> nand`: Indeed.  THe part that amuses me is that while right now this is the single most dense book I've ever read, when I reach the other side of this learning, it'll all seem so trivial.
12:53:04 <Kaidelong> it's probably best to read it, but then ask someone else about it
12:53:14 <nand`> Dashkal: which book are you reading?
12:53:27 <nand`> MacLane?
12:53:28 <drdo> The main problem i have is that CT books don't appeal to someone with my background
12:53:33 <mvj4> is there any good course material on category theory as discussed above? my university doesn't offer any course on this matter.
12:53:34 <Dashkal> "Basic Category Theory for Computer Scientists" by Benjamin Pierce
12:53:41 <nand`> ooh, that one; I've read it too
12:53:44 <Kaidelong> I've read that one
12:53:48 <Kaidelong> I think
12:53:51 <Dashkal> It's good, but very very dense.
12:53:55 <nand`> (it's the only book on CT which I've read)
12:53:59 <Kaidelong> making a version of it that is written as poetry
12:54:04 <Kaidelong> might be a worthwhile endeavour
12:54:06 <nand`> Dashkal: yeah I often had to put down the book and re-read the same paragraph a day later or so to really understand it
12:54:34 <Dashkal> Yep, that's what I'm doing.  I read it over and over.  If I get stuck, I read ahead a bit, put it down, then start the whole section over, hoping things fall into place.
12:54:39 <Kaidelong> I think poetry is probably a good way to explain a lot of algebra, really
12:54:44 <nand`> Dashkal: that sounds familiar
12:54:46 <Dashkal> Along with asking people on particular points, it's working.
12:55:12 <nand`> poetry is a great way to explain anything
12:55:20 <nand`> ‚Äúa parser of things is a function from strings to lists of pairs of things and strings‚Äù
12:55:21 <Dashkal> The problem with it is it stays so very abstract, it takes me a good deal of time to "connect the dots" from what I already know to what it's trying to convey.
12:55:41 <Kaidelong> Dashkal: if you pick up something like "the manga guide to linear algebra"
12:55:51 <Kaidelong> a good exercise is discovering the category for matrices on your own
12:55:54 <nand`> Dashkal: yeah it doesn't present a lot of connections to the ‚Äòreal world‚Äô of concrete mathematics
12:56:09 <nand`> other than some basic examples near the beginning
12:56:11 <Kaidelong> since they're a relatively representative category
12:56:20 <Kaidelong> that isn't too complicated but isn't too simple
12:56:27 <Dodek> i think the main problem with category theory is that CS people who read them don't know algebraic topology
12:56:36 <Dashkal> I'm not an expert in set theory, so that makes most of his examples that much more difficult to parse.  (Though by the time I'm done, I think I will be...)
12:56:47 <Dodek> so half the stuff in there won't make sense to them
12:56:50 <mvj4> nand`: is the book easy to connect with standard haskell type classes or is it more theoritic/generialized?
12:56:51 <drdo> Dodek: Yeah, that sort of thing is the main problem
12:57:03 <drdo> The sort of intuition they try to get at doesn't exist for me
12:57:12 <carter> edwardk: i've been following the associated ghc-users thread with interest :)
12:57:21 <Kaidelong> I don't know algebraic topology, I did read a lot about set theory so I understood the motivation behind category theory in terms of the barber's paradox but books like The Philosophy of Set Theory mainly deal with stuff like cardinalities
12:57:23 <Dashkal> "algebraic topology" is not a term that has any meaning for me whatsoever.
12:57:25 <nand`> mvj4: it doesn't reference Haskell or functional programming at all (except in the last chapter, which shows an example of using CT to model type theory)
12:57:40 <nand`> there aren't any connections shown to Hask or otherwise eg. for functors as class Functor
12:57:44 <nand`> so you'd have to connect the dots youtself
12:57:54 <mvj4> alright, thanks :)
12:58:00 <Kaidelong> from what I understood, the hard (and interesting) part of category theory is how you can transform one category into another
12:58:04 <Dashkal> It very briefly showed a connection to a Hask-like category in the very beginning, then just moved on.
12:58:11 <Kaidelong> which I still do not grasp
12:58:18 <Dashkal> Functors are really really cool.
12:58:21 <drdo> It's not very interesting to make the connection to Haskell
12:58:22 <Dodek> Kaidelong: because you haven't seen that many categories
12:58:37 <Dodek> Kaidelong: in haskell, almost all functors you deal with are endofunctors
12:58:44 <edwardk> i keep wanting to write a 'category theory for haskell users' series
12:58:50 <Kaidelong> yeah, lately my focus has shifted away from pure mathematics, and not willingly
12:58:51 <edwardk> but i never find the time
12:58:53 <Dashkal> I had no idea how powerful the concept was until I realized what they really are
12:59:06 <Dodek> while if you do algebraic topology, you travel between categories with functors all the time
12:59:08 <Dashkal> edwardk: My money, let me throw it at you, make this book happen.
12:59:28 <Kaidelong> well what I'm working on right now is something like conal's monoid morphisms which I think has some relation to a functor
12:59:31 <t7> edwardk: kickstarter :P
12:59:39 <Kaidelong> something along the lines of "an animation can be composed if the frames can"
12:59:44 <Dashkal> Dodek: here's the part that scares me, were I to push "algebraic topology" onto my stack of things to learn, what else would I have to push to learn that concept?
12:59:47 <edwardk> Dashkal: for what it is worth, you can repeat all this stuff parameterized on kinds. https://github.com/ekmett/indexed/blob/master/src/Indexed/Functor.hs#L32
12:59:47 <Kaidelong> and implementing this efficiently with SDL blits
12:59:59 <Kaidelong> (not in haskell sadly, F#)
13:00:07 <edwardk> type f ~> g = forall x. f x -> g x
13:00:18 <Dodek> Dashkal: don't push it on the stack, it takes too much time
13:00:35 <Dashkal> heh, I'm still trying to grasp forall x.  I haven't figured out how I'm overcomplicating the concept yet.
13:00:40 <edwardk> leave algebraic topology off the stack for now ;)
13:01:10 <nand`> Kaidelong: afaik CT was pretty much invented to study the properties of natural transformations; or transformations between transformations between categories :P
13:01:18 <Kaidelong> oooh
13:01:19 <Dashkal> I'm not sure if it's more or less frustrating knowing I'm having issues due to overcomplicating the matter, given that I don't see how yet...
13:01:24 <drdo> Dashkal: Just think of it as an abstraction at the type level
13:01:27 <Kaidelong> I should revise my linear algebra stuff then
13:01:35 <Dodek> nand`: natural transformation are transformations between functors, not categories
13:01:41 <nand`> the entire concept of a category seems like a boring implementation detail at that point
13:01:45 <Kaidelong> nand: the way I understood it though, it was meant to formulate something like set theory where there was no barbershop paradox
13:01:48 <Dashkal> meta-transforming!
13:01:58 <t7> Dashkal: whats not to get about forall?
13:02:07 <Dashkal> t7: That's just it, I don't know!
13:02:08 <Kaidelong> maybe
13:02:11 <Dashkal> hence my frustration
13:02:14 <nand`> Kaidelong: no, that's what the systems like ZF are for
13:02:17 <Kaidelong> both those were motivations for different people
13:02:21 <Dodek> Kaidelong: linear algebra is also quite nice for category stuff. you can travel from vector spaces category to matrices, or take dual vector space etc
13:02:36 <edwardk> Dashkal: think of it adversarially. when i give you a function (a -> a)   for a function (a -> a) -> Int -> Bool - i get to pick a to be as hard as i want them to be for you to work with, and you can't know anything about it. on the other hand when i give you a function (forall a. a -> a)  for (forall a. a -> a) -> Int -> Bool then i cripple myself and empower you. i have to give you a function that works for any type you want to give
13:02:36 <nand`> CT wasn't meant as a replacement for ST; the two don't extend eachother
13:02:43 <Kaidelong> yes I noticed that, projections between matrices of different sizes immediately made me think of functors
13:02:55 <t7> forall things in this universe, this holds
13:03:09 <edwardk> so you could pass that function any argument you want, and i have to deal with it. and i an't know anything about the a's you pass me.
13:03:11 <Kaidelong> nand: original motivations don't neccessarily have anything to do with what you get as a result
13:03:16 <parcs`> nh2: looks like cabal update will be faster in the next? version https://github.com/haskell/cabal/commit/85ad9f848cdae7eab80c76a5ec2772d5f35d852b
13:03:17 <Dashkal> edwardk: ok, that's getting a glimmer of understanding out of me.  I'm not entirely clear on how that "power" is used by one side or the other.
13:03:24 <Dashkal> oh!
13:03:24 <Dodek> nand`: some people actually try to do set theory in the categorical world
13:03:30 <Dashkal> edwardk: that did it for me.  thank you!
13:03:31 <edwardk> the game theoretic understanding of quantification is probably the most useful
13:03:51 <dcoutts> parcs`: I don't think that's particularly significant. It's not like incremental update.
13:03:52 <Dodek> nand`: the keywords are "toposes", "subobject classifiers" etc
13:04:00 <drdo> Dashkal: reverse ‚à∑ forall x. [x] -> [x]
13:04:07 <nand`> Dodek: sounds like something taken straight out of topology
13:04:08 <edwardk> foo :: (forall a. a -> a) -> (Int, Bool); foo idLike = (idLike 12, idLike True)
13:04:10 <drdo> reverse Int ‚à∑ [Int] -> [Int]
13:04:14 <Dashkal> If the forall is at the top, I have to deal with the unknown 'a'.  If I wrap it into the function argument itself, you do.  Yep, overcomplicating things as usual.
13:04:17 <drdo> It's just a function on types
13:04:36 <Dashkal> where I wrote the type sig, and you are calling the func.
13:04:44 <edwardk> but if you remove the forall. all you told me was that here is a function that converts a -> a for some type a that i'm not going to tell you about, nya nya nya nya nya
13:04:48 <Dodek> nand`: i don't think that toposes are that much related to topology. i'm not really into that kind of stuff, though.
13:04:49 <Kaidelong> would [forall x. x] -> [forall x. x] be any different from forall x . [x] -> [x]?
13:05:02 <drdo> yes
13:05:06 <Kaidelong> I'm guessing forall doesn't distribute
13:05:07 <drdo> those x's are not the same
13:05:10 <Kaidelong> yeah
13:05:11 <drdo> in the first one
13:05:11 <nand`> Dodek: I see. I was just commenting on the name
13:05:11 <edwardk> Kaidelong: yes
13:05:20 <nand`> topology has some crazy names (as does algebra in general)
13:05:22 <Dodek> Kaidelong: the first one is the same as [forall x. x] -> [forall y. y]
13:05:25 <Saizan> how is x :: (a,b) translated into System Fc when x is a type?
13:05:50 <Kaidelong> so it's just like a lambda
13:05:55 <Dashkal> ok, time to look over these lenses and see if I can grasp that just a bit better then.  the forall f. Functor f => bit still has no meaning
13:05:55 <edwardk> the former basically has to take [] -> []  and can ignore any other case. the latter any function that shuffles duplicates or forgets its arguments.
13:05:58 <Dashkal> (to me)
13:06:13 <Dodek> Kaidelong: it all boils down the distinction between free and bound variable.
13:06:18 <Dodek> to the*
13:06:31 <nand`> for lenses it's an example of ‚Äúthe caller can provide whatever type they want, provided it's still a functor‚Äù
13:06:37 <edwardk> Dashkal: a lens is a function that you can pick any functor you want to call it with, and give it a function from c -> f d for that functor, and a value a. and it'll give you back an f b.
13:07:05 <nand`> so I could (as a caller) provide Identity to set it out; or I could provide Const m to read it out
13:07:07 <nand`> the lens can't distinguish
13:07:15 <nand`> s/set it out/set it/
13:07:21 <edwardk> now, since i don't know anything about 'f' other than that its a Functor, and you cooked it up, all i can do is use the function c -> f d to build it up, and then use fmap to fiddle with the 'd' i smuggled through to the other side
13:07:46 <edwardk> those are the only tools i've left myself by quantifying over f.
13:08:18 <edwardk> the only formulas i have that involve f. are (c -> f d)    and that fmap has type forall a b. (a -> b) -> f a -> f b.
13:08:21 <Dashkal> side question: Do any interesting operations come of feeding a lens a functor aside from Id/Const?  Eg, Maybe, []
13:08:46 <Kaidelong> @djinn forall f. (forall a. forall b. f a -> f b) -> (forall c. forall d. (c -> f d)) -> (forall a. forall b. a -> f b)
13:08:46 <lambdabot> Error: cyclic kind
13:08:47 <Dashkal> s/Eg,/eg./
13:09:55 <nand`> Dashkal: yeah you can basically use it to traverse over any functor, the same way you'd use the function ‚Äòtraverse‚Äô itself
13:09:57 <Kaidelong> did functors have any methods other than fmap?
13:10:06 <Kaidelong> oh
13:10:10 <nand`> eg. with Maybe I could choose to overwrite it or not; and the result I get will then also live in Maybe
13:10:19 <Dashkal> "traverse".  Ok, time to punt "essence of the iterator pattern" back to the top of the stack.
13:10:23 <Kaidelong> @djinn forall f. (forall a. forall b. (a -> b) -> f a -> f b) -> (forall c. forall d. (c -> f d)) -> (forall a. forall b. a -> f b)
13:10:23 <lambdabot> Error: cyclic kind
13:10:39 <Dashkal> I think I'll get a much better understanding out of that paper this time around.
13:10:49 <nand`> Dashkal: lenses are just more powerful traversals :)
13:10:58 <Dashkal> *nods*
13:10:58 <nand`> they have the exact same type signature except replace Applicative by Functor
13:11:12 <edwardk> > let both f (a,b) = (,) <$> f a <*> f b in both (\a -> [a, a + 1]) (1,2) :: [(Int,Int)]
13:11:13 <lambdabot>   [(1,2),(1,3),(2,2),(2,3)]
13:11:15 <Kaidelong> mm, is it possible to get djinn to generate an example of a trivial lens?
13:11:24 <Dashkal> That does explain the reason for the "Traversal" type's name
13:11:36 <roconnor_> @wn yeild
13:11:36 <lambdabot> No match for "yeild".
13:11:39 <roconnor_> @wn yield
13:11:39 <lambdabot> *** "yield" wn "WordNet (r) 3.0 (2006)"
13:11:39 <lambdabot> yield
13:11:39 <lambdabot>     n 1: production of a certain amount [syn: {output}, {yield}]
13:11:39 <lambdabot>     2: the income or profit arising from such transactions as the
13:11:39 <lambdabot>        sale of land or other property; "the average return was about
13:11:41 <lambdabot> [38 @more lines]
13:11:52 <Dashkal> @djinn forall f. Functor f => (a -> f a) -> a -> f a
13:11:52 <lambdabot> Error: Class not found: Functor
13:12:01 <Dashkal> Guess not
13:12:02 <roconnor_> Dashkal: id
13:12:05 <edwardk> Kaidelong: no. its rank 2.
13:12:43 <edwardk> roconnor_: =)
13:13:14 <Dashkal> @djinn (a -> Identity a) -> a -> Identity a
13:13:14 <lambdabot> Error: Undefined type Identity
13:13:19 <Dashkal> fine then...
13:13:27 <edwardk> anyways, the use of other functors for lenses is largely boring, because it uses the function exactly once.
13:13:37 <edwardk> the function from c -> f d that is
13:13:40 <Dashkal> @djinn (a -> b) -> a -> b
13:13:41 <lambdabot> f a = a
13:13:46 <edwardk> for traversals its very useful
13:13:46 <t7> type sig for functor is modus ponens ...
13:14:12 <edwardk> :t ($)
13:14:13 <lambdabot> forall a b. (a -> b) -> a -> b
13:14:22 <edwardk> 'if a entails b, and a, then b
13:14:22 <Dashkal> Well, the Maybe example nand` suggested sounds of interest.
13:15:15 <t7> someone should make a game out of first order logic. Like find a proof for this with these props
13:15:16 <Kaidelong> I'm not familiar with the term lens, is this a good place to get acquianted?: http://stackoverflow.com/questions/8307370/functional-lenses
13:15:26 <t7> you have 30 secs and these rules to use
13:15:27 <nand`> let safeDiv _ 0 = Nothing; safeDiv a b = Just (a/b) in (_1 %%~ safeDiv 5) (0, 4)   => Nothing
13:15:37 <byorgey> t7: they have!  It's called Coq.
13:15:42 <edwardk> Kaidelong: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
13:15:49 <t7> byorgey: gamify it more
13:15:51 <jfischoff> dcoutts: Thanks for helping me. Its was a package issue as you described
13:15:53 <byorgey> =)
13:15:58 <t7> with achievements(tm)
13:16:05 <Kaidelong> t7: a lot of existing puzzles probably reduce to that, working up from it to somethng more thematic like angry birds might be a good way to design a puzzle
13:16:12 <edwardk> t7: here's a copy of emacs and a chess clock. ;)
13:16:13 <Dashkal> edwardk: *blinks* I totally missed that connection.  5^.($) does indeed work fine.
13:16:23 <dcoutts> jfischoff: btw in future there'll be a cabal ghci command so you can get a ghci session exactly the same as a normal build
13:16:34 <edwardk> Dashkal: ($) = id, id is a lens ;)
13:16:40 <edwardk> 5^.id
13:16:54 <edwardk> (1,2)^.id.id.id.id._2
13:17:03 <jfischoff> dcoutts: ah cool.
13:17:15 <t7> Kaidelong: yes i should make a kickstarter
13:17:18 <jfischoff> will it work with sandboxing?
13:17:25 <t7> an then give up after i make my money
13:17:26 <edwardk> Achievement unlocked: My Brain Exploded!
13:17:26 <nand`> t7: https://github.com/tomahawkins/theoremquest
13:17:28 <Dashkal> ($) is id... *blinks* so it is
13:17:41 <dcoutts> jfischoff: they're orthogonal features, when we have both then both will work together
13:17:47 <edwardk> Achievement Unlocked: The Impossible Happened
13:17:48 <jfischoff> awesome
13:18:13 <Kaidelong> so if I were to rewrite a and b
13:18:18 <edwardk> now i want to make a thin wrapper around ghc that pops up those xbox style achievements in the corner of your scrreen
13:18:35 <rking> edwardk: notify-send ?
13:18:36 <t7> haha
13:18:37 <edwardk> maybe using growl or something
13:18:41 <rking> Yeah.
13:18:48 <t7> edwardk: visual studio actually had this
13:18:53 <edwardk> t7: yeah
13:19:26 <t7> shipped a product with no unit tests +5 points
13:19:29 <Kaidelong> Lens underlying-implementation visible-property = Lens { get :: (underlying-implementation -> visible-property), set :: (visible-property -> (underlying-implementation -> underlying-implementation)) }
13:20:02 <edwardk> Kaidelong: yep, that'd be the zed shaw version
13:20:23 <Kaidelong> and this is interesting because set can work for functors via fmap . set
13:20:45 <edwardk> t7: compiled on first attempt +10 points
13:20:50 <Kaidelong> you just can't neccessarily get for an arbitary functor
13:21:13 <nand`> what an awfully verbose way to say Lens a b = (a -> b, b -> a -> a)
13:21:23 <edwardk> Kaidelong: good eye. if you look at Setter in the 'lens' package, it is precisely the part of lenses that can work with Functors ;)
13:21:31 <Dashkal> > zipWith (id) [(+1), (+1), (+1)] [1, 2, 3] -- That this works is proof I need to work on my mental model for currying
13:21:32 <lambdabot>   [2,3,4]
13:22:14 <merijn> Dashkal: You could also use "
13:22:14 <edwardk> Kaidelong: type Setter a b c d = (c -> Identity d) -> a -> Identity b      -- if a were f c   and b were f b, that would be the signature of fmap (ignoring the Identity noise)
13:22:23 <merijn> Dashkal: "zipWith ($)"
13:22:34 <merijn> Dashkal: Also, parenthesis around id are redundant
13:22:55 <Dashkal> merijn: I knew $ worked, it was id working in its place that surprised me
13:22:56 <edwardk> > zipWith id [(+1), (+1), (+1)] [1, 2, 3]
13:22:57 <lambdabot>   [2,3,4]
13:22:59 <nand`> mapped :: Functor f => Setter (f a) (f b) a b
13:23:03 <nand`> ^- equivalent of fmap
13:23:54 <edwardk> that too =)
13:24:20 <nand`> (and expanded that is exactly the case that edwardk described)
13:25:25 <Dashkal> @src ($)
13:25:26 <lambdabot> f $ x = f x
13:25:49 * hackagebot GLUtil 0.1.4 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.1.4 (AnthonyCowley)
13:25:51 * hackagebot GLUtil 0.2 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.2 (AnthonyCowley)
13:26:56 <nand`> $ is a very low preceding way of doing absolutely nothing
13:28:24 <t7> function application is fundamental
13:28:33 <nand`> indeed
13:28:35 <Dashkal> Indeed.  I can now see it in terms of id.  It's nothing more than id constrained to function types.
13:28:59 <Dashkal> And of course a handy way to avoid icky parens :P
13:29:04 <nand`> application, abstraction and pattern matching - the holy trinity of fundamental operations :P
13:29:37 <nand`> (of course ski guys would come in here and argue that pattern matching and abstraction are like, totally useless)
13:30:05 <t7> iota guys would then come...
13:30:14 <Dashkal> Yeah, I have this funny thing about wanting to complete my programs before heat death of the universe...
13:31:08 <Kaidelong> $ is also nice for writing sections
13:31:28 <c_wraith> though (foo $) is pretty useless :)
13:31:32 <Kaidelong> ($x) is a function that applies x to another function
13:31:48 <Dashkal> :t flip ($)
13:31:49 <lambdabot> forall a b. a -> (a -> b) -> b
13:31:58 <Dashkal> that one is kinda nice from time to time
13:32:07 <c_wraith> :t flip id
13:32:08 <lambdabot> forall a b. a -> (a -> b) -> b
13:32:17 <c_wraith> slightly shorter!
13:32:21 <Dashkal> hah
13:32:28 <Kaidelong> Dashkal: F# has |> which is flip ($) and you use it pretty much all the time
13:32:51 <t7> :t let s x y z = x z (y z); k x y = x; u = \f -> (f s) k in u u
13:32:52 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t -> t2
13:32:52 <lambdabot>       Expected type: ((t1 -> t -> t2) -> (t1 -> t) -> t1 -> t2)
13:32:52 <lambdabot>                      -> ((t1 -> t -> t2) -> t1 -> t)
13:32:53 <Dashkal> I normally don't like "pipeline style".  My uses of flip ($) tend to come up with applicatives
13:32:54 <Kaidelong> it's especially useful due to how type inference works there but it's also just often very idiomatic to have an implicit parameter being acted on in steps
13:33:17 <nand`> I've felt the need for flip ($) when working with lenses
13:33:20 <Dashkal> But that's very much a style concern.  Not important.
13:33:33 <t7> :t let s x y z = x z (y z); k x y = x; u = \f -> (f s) k in u
13:33:34 <lambdabot> forall t t1 t2 t3 t4 t5. (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (t3 -> t4 -> t3) -> t5) -> t5
13:33:35 <Kaidelong> Dashkal: there's somewhat more of a motivation there because of type inference being sensitive to the order in which you use things
13:33:36 <nand`> record |> lensop
13:33:52 <Dashkal> Though your inference argument makes me ponder.  I wonder if scala's crippled type inference can better cope with pipeline style in some cases.
13:33:54 <edwardk> nand`; hrmm
13:34:09 <Dashkal> I suspect it can, actually
13:34:12 <nand`> foo { a = b }; contrast  foo |> a .~ b
13:34:15 <edwardk> Dashkal: it can. thats why |@| is as borked as it is
13:34:15 <Dashkal> This is worth investigating
13:34:25 <t7> @djinn (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (t3 -> t4 -> t3) -> t5) -> t5
13:34:25 <lambdabot> f a = a (\ b c d -> b d (c d)) (\ e _ -> e)
13:34:28 <Kaidelong> scala and F# have a lot in common so it would not surprise me
13:34:29 <edwardk> Dashkal: this is also why f# uses |>
13:34:34 <Dashkal> *nods*
13:34:39 <Kaidelong> |> surprised me very pleasantly though
13:34:45 <Kaidelong> when I first started using it
13:34:46 <Dashkal> Yeah, now I have a compelling argument.  I'm going to dig into this.
13:34:53 <Kaidelong> it was an adjustment but it quickly becomes very natural
13:35:04 <Dashkal> scala's broken inference defeated me just recently.  I want to get that point back :P
13:35:09 <Kaidelong> and I think even in the case of haskell where the type inference argument isn't there
13:35:16 <Dashkal> Part of why I'm hiding in here, nursing my wounds :P
13:35:21 <Kaidelong> it sometimes is much more natural to write things like that
13:35:30 <Kaidelong> and do syntax basically is a specific version of that
13:35:30 <nand`> fortunately, in haskell, you have nobody stopping you from defining |> and using it yourself
13:35:44 <Kaidelong> it's not idiomatic though
13:35:50 <Kaidelong> there is <$$> I suppose
13:35:57 <nand`> :t (<$$>)
13:35:57 <Kaidelong> I could use that
13:35:58 <lambdabot> Not in scope: `<$$>'
13:36:12 <edwardk> we have <**> but not <$$>
13:36:17 <Kaidelong> oh
13:36:21 <Kaidelong> well
13:36:23 <atriq> Does <$$> exist?
13:36:23 <Kaidelong> that's unfortunate
13:36:38 <Dashkal> Well, it's often the case that I know the type of the innermost argument, but have to type annotate things later in the pipe so scalac stops getting pissy.  So yeah, |> is very likely something I should be looking into
13:36:43 <nand`> flip (<$>) is still a different beast from flip ($) though isn't it?
13:36:45 <edwardk> atriq: no
13:37:01 <edwardk> atriq: i export a $> but not a <$$> in Control.Comonad, IIRC.
13:37:03 <nand`> except for left-to-right composition, but >>> exists for that
13:37:27 <edwardk> https://github.com/ekmett/comonad/blob/master/Control/Comonad.hs#L304
13:37:27 <Kaidelong> oh, I never really messed with arrows much
13:37:35 <Kaidelong> perhaps arrow style is both idiomatic and F#-esque
13:37:40 <nand`> well you can use >>> for left to right ‚Äòpipeline‚Äô composition
13:37:47 <nand`> notably (<<<) = (.)
13:37:49 <edwardk> it comes up a lot when you use wfix: https://github.com/ekmett/comonad/blob/master/examples/History.hs#L54
13:38:19 <nand`> I use >>> (over <<< or .) a lot when composing arrows (eg. signal arrows)
13:38:44 <ion> @hoogle ($>)
13:38:44 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
13:38:45 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
13:38:45 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
13:38:52 <ion> What‚Äôs the type of ($>)?
13:38:55 <nand`> it does seem like a more natural order for composition (me being used to reading left to right and all that); I often find myself writing out large compositions right-to-left
13:39:12 <nand`> but that's inefficient since I have to go to the start of every function after I wrote it to prepend another
13:39:31 <Cale> nand`: Of course, when you write (f . g . h) x in Haskell, it's f which gets evaluated first ;)
13:40:00 <parcs`> deep
13:40:11 <Cale> (at least, under lazy evaluation!)
13:40:15 <nand`> Cale: :)
13:40:16 <ion> Not (.)?
13:40:26 <nand`> ion++
13:40:29 <Cale> Oh, well, yes, (.) gets evaluated a couple times
13:40:35 <Cale> but of the variables there
13:40:36 <edwardk> ion: Functor f => f a -> b -> f b
13:40:50 <ion> edwardk: So‚Ä¶ just flip (<$)?
13:40:53 <edwardk> yes
13:40:55 <ion> ok
13:40:59 <parcs`> > (error "a") (error "b")
13:41:00 <lambdabot>   *Exception: a
13:41:04 <edwardk> fibo d = wfix $ d $> fby 0 . extend (\dfibo -> extract dfibo + fby 1 dfibo)
13:41:05 <Cale> actually, it's (.) and then f, and then (.) and then g and then h and then x
13:41:27 <Cale> (because (.) is infixr)
13:41:36 <edwardk> is a lot prettier than fibo d = wfix $ fby 0 . extend (\dfibo -> extract dfibo + fby 1 dfibo) <$ d  -- since by then you've forgotten what d was ;)
13:42:04 <edwardk> especially when the thing to the right of the $> is a lambda
13:42:07 <parcs`> <$ is the most underrated combinator ever
13:42:17 <edwardk> fibo d = wfix $ d $> \ x -> fby 0 (extend (\dfibo -> extract dfibo + fby 1 dfibo) x)
13:42:20 <Kaidelong> @ty (<$)
13:42:21 <ion> How is it underrated?
13:42:21 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
13:42:24 <Dashkal> oh wow, scalac has a (>|) operator that does exactly what you have ($>) do.  Could have used that for a good while...
13:43:01 <parcs`> ion: because it's unknown!
13:43:13 <ion> It is? :-P
13:43:43 <parcs`> seems that way
13:43:47 <Kaidelong> ((a -> b) -> (f a -> f b)) -> a -> (f b -> f a) ... ?
13:43:57 <Kaidelong> how would that work
13:44:18 <Kaidelong> oh
13:44:20 <Kaidelong> you can do
13:44:28 <Kaidelong> @ty fmap . const
13:44:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
13:44:58 <nh2> I shall contribute this pearl to you, fair #haskell: http://hpaste.org/73995
13:45:06 <Kaidelong> so is (<$) just fmap.const?
13:45:11 <parcs`> yeah
13:45:23 <byorgey> AGH my eyes!
13:45:28 <ion> kaidelong: ((a -> b) -> (f a -> f b)) -> b -> (f a -> f b)
13:45:46 <nh2> :D
13:45:50 <parcs`> it's mainly useful for eliding do { a; return b }
13:46:08 <parcs`> > let x = 5 in x <$ guard (even x) :: Maybe Int
13:46:09 <lambdabot>   Nothing
13:46:36 <ion> > let swap (a,b) = (b,a) in unfoldr (\n -> swap (n `divMod` 10) <$ guard True) 1234567890
13:46:37 <lambdabot>   [0,9,8,7,6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:46:43 <ion> whoops
13:46:51 <parcs`> unfoldr is a good one
13:46:52 <ion> > let swap (a,b) = (b,a) in unfoldr (\n -> swap (n `divMod` 10) <$ guard (n /= 0)) 1234567890
13:46:53 <lambdabot>   [0,9,8,7,6,5,4,3,2,1]
13:48:11 <ion> @djinn ((a -> b) -> (c -> d)) -> b -> (c -> d)
13:48:11 <lambdabot> f a b c = a (\ _ -> b) c
13:48:53 <parcs`> $> would be nice to have though
13:55:35 <t7> @djinn ((g, a) -> s) -> (g -> Either s a) -> g -> s
13:55:35 <lambdabot> f a b c =
13:55:35 <lambdabot>     case b c of
13:55:35 <lambdabot>     Left d -> d
13:55:35 <lambdabot>     Right e -> a (c, e)
13:56:00 <t7> so clever...
13:56:24 <t7> i couldnt even work out that in my head
13:56:55 <t7> now i feel silly
14:00:30 <hpc> t7: it's the (g ->)-expanded version of either
14:00:32 <hpc> :t either
14:00:33 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:00:43 <hpc> or something along those lines
14:04:31 <Cale> Here's what would go through my head. We have values of type ((g,a) -> s), (g -> Either s a), and g, and we want to make a value of type s. We don't yet have a value of type a, so we can't apply our function ((g,a) -> s), so the only thing we can do is apply the function (g -> Either s a) to the value of type g, and we get an Either s a. So either we have a Left x where x :: s and we're done, or we have Right y where y
14:04:31 <Cale>  :: a, in which case we have (g,a), and can apply the function (g,a) -> s to get an s.
14:05:14 <lpvb> can I display the source of haskell stuff in ghci, or do I have to go to hoogle & hayoo for that?
14:05:15 <parcs`> :t ap . either id
14:05:16 <lambdabot> forall a b b1. (b1 -> a -> b) -> (Either (a -> b) b1 -> a) -> Either (a -> b) b1 -> b
14:05:43 <parcs`> :t ap . (either id .)
14:05:43 <lambdabot> forall (m :: * -> *) a b. (Monad m, Functor m) => m (b -> a) -> m (Either a b) -> m a
14:06:03 <parcs`> :t ap . (either id .) . uncurry
14:06:04 <lambdabot> forall a b a1 b1. (a1 -> b1 -> b -> a) -> ((a1, b1) -> Either a b) -> (a1, b1) -> a
14:08:47 <nand`> lpvb: you can generally show the definitions of types, but that's about it
14:09:23 <Cale> lpvb: The haddock documentation also has links to source
14:12:17 <xazax_> hi, is there a nicer method to create a record from a list, than just Record (list !! 0) (list !! 1) ...
14:12:19 <xazax_> ?
14:13:48 <nand`> case list of [a,b,c,d] -> Rec a b c d -- is one improvement over !! 0 !! 1 etc.
14:14:06 <parcs`> xazax_: or [a,c,d,e,f] <- return list; return (Record a b c d e f) if you want to return a Maybe Record
14:14:33 <nand`> listToMaybe [ Rec a b c d | [a,b,c,d] <- foo ] :P
14:14:55 <parcs`> [foo]
14:15:09 <parcs`> that's nicer
14:15:10 <xazax_> woot, thanks
14:18:42 <parcs`> with type hackery you can do 'apply Rec list' to get a 'Maybe Rec' but that's too heavyweight a solution
14:19:32 <xazax_> heavy weight, you mean performance wise or code wise?
14:20:48 <parcs`> code-wise, and probably performance-wise. also maintainability-wise
14:21:12 <parcs`> http://paste.debian.net/186999/
14:21:45 <parcs`> in that snippet it's called fromList and its arguments are reversed
14:21:49 <t7> > let a ‚ä¢ b = b - a in 2 ‚ä¢ 5
14:21:50 <lambdabot>   3
14:22:18 <mauke> > 2 `subtract` 5
14:22:19 <lambdabot>   3
14:22:41 <t7> it wont let me do    data A = A ‚ä¢ A
14:23:12 <ziman> a data constructor operator must begin with a colon
14:23:32 <t7> really?
14:24:01 <t7> more than a year of haskell and i never knew that
14:24:04 <parcs`> not for long
14:24:11 <mauke> : is the only uppercase symbol
14:24:18 <ziman> the best one is taken by (:) :P
14:24:25 <hpc> > isUpper ':'
14:24:26 <lambdabot>   False
14:24:30 <parcs`> in ghc 7.6 ‚ä¢ is a constructor
14:24:40 <Cale> parcs`: which, btw, I hate, because ~> is a really nice infix type variable in Arrow-y settings
14:24:56 <t7> haskell should start using agda style infix defs
14:24:59 <ziman> parcs`, is it ad-hoc or is there a larger shift?
14:25:01 <t7> so much niver
14:25:05 <t7> nicer*
14:25:11 <parcs`> > generalCategory '‚ä¢'
14:25:12 <lambdabot>   MathSymbol
14:25:39 <ziman> > generalCategory '‚óÖ'
14:25:40 <lambdabot>   OtherSymbol
14:27:19 <monochrom> oh, hrm, wait, ghc 7.6 makes ‚ä¢ a constructor?!
14:27:28 <parcs`> type constructor*
14:27:37 <monochrom> interesting
14:27:44 <monochrom> actually, it may be a good idea
14:28:19 <parcs`> Cale: `arr` isn't so bad
14:28:38 <parcs`> it's also mildly amusing
14:28:38 <Cale> It's not good
14:29:56 <Cale> Perhaps ~ could be marked as lowercase in types. But tbh, I liked the consistency of how things have been done up to this point
14:30:11 <Cale> I don't see why we need infix type constructors which don't begin with :
14:30:44 <parcs`> type nats?
14:30:56 * timthelion realises that after having discovered GATDs he will never write another line of standard haskell code again.
14:31:31 <monochrom> I like consistency too
14:31:40 <Cale> Generalised algebraically transmitted diseases?
14:31:52 <timthelion> GADTs?
14:31:56 <hpaste> ixmatus pasted ‚ÄúCrypto Random‚Äù at http://hpaste.org/73998
14:32:00 <monochrom> infectious!
14:32:06 <ixmatus> can someone help me with generating a cryptographic random number? I have some code down from crypto-api - but I'm getting a type error that I can't figure out (I'm a noob)
14:32:09 <parcs`> algebraically diseased transmissions?
14:32:20 <ixmatus> I'm using, pretty much what I found in the doc
14:32:48 <Cale> ixmatus: You didn't paste the type error with your code
14:33:08 <Cale> putStrLn int  looks suspicious
14:33:22 <Cale> Also, getCRandom :: CRandom
14:34:07 <ixmatus> yeah the error was on getCRandom
14:34:10 <ixmatus> lemme try that Cale
14:34:13 <Cale> (CRandom is probably a monad, and certainly you're using some monad because you're writing a do-expression, which means that there has to be a type constructor)
14:34:21 <ixmatus> okay
14:34:30 <ixmatus> lemme paste the error
14:34:41 <Cale> Each line in a do-block has to be of type m a for some fixed type m
14:34:59 <hpaste> ixmatus pasted ‚ÄúError‚Äù at http://hpaste.org/73999
14:35:03 <hpc> or a let statement
14:35:15 <hpc> (which has some minor sugar)
14:35:25 <Cale> Okay, so the error says that it wants one more argument to CRandom
14:35:27 <Cale> right?
14:36:01 <Cale> What's the type of getCRandom?
14:36:02 <ixmatus> well
14:36:03 <ixmatus> so
14:36:07 <ixmatus> okay
14:36:09 <Cale> (in the documentation)
14:36:13 <ixmatus> this line: int <- getCRandom :: CRandom
14:36:17 <Cale> (or you could ask ghci)
14:36:28 <ixmatus> I put :: CRandom because I thought it needed it
14:36:29 <ixmatus> with out it
14:36:49 <hpaste> ixmatus pasted ‚ÄúError‚Äù at http://hpaste.org/74000
14:36:52 <ixmatus> I get that
14:37:17 <Cale> Right, because you're using the result of this computation as a String later in the computation
14:37:31 <Cale> (in particular, you're applying putStrLn to it)
14:37:55 <Cale> and it's apparently complaining that there's no instance of this class CRandom for String values
14:38:38 <Cale> and apparently getCRandom produces a result of any type which is an instance of that typeclass
14:39:04 <Cale> (and apparently String is not an instance)
14:39:27 <ixmatus> okay
14:39:31 <Cale> I'm guessing that because you named the variable int that you didn't expect to produce a String
14:39:53 <ixmatus> I copy pasted the code from this page: http://hackage.haskell.org/packages/archive/monadcryptorandom/0.2/doc/html/Control-Monad-Crypto-Random.html#t:CRandom
14:40:03 <ixmatus> I'm still getting used to Haskell's type system, coming from Python
14:40:14 <Cale> okay
14:40:34 <ixmatus> so I can't putStrLn an integer
14:40:42 <Cale> right, you need to use  print
14:40:43 <ixmatus> how do I convert it to a String type then?
14:40:48 <ixmatus> interesting
14:40:52 <Cale> which is the same thing as putStrLn . show
14:41:04 <Cale> > show 5
14:41:05 <ixmatus> show is the Data.Text concat function, right?
14:41:05 <lambdabot>   "5"
14:41:10 <Cale> no
14:41:19 <Cale> show is a Prelude function
14:41:27 <ixmatus> okay
14:41:30 * ixmatus goes to look it up
14:41:38 <ixmatus> Cale thank you for your help
14:41:40 <Cale> It's defined by the class declaration for the Show class
14:41:43 <ixmatus> also
14:41:46 <ixmatus> one more quick question
14:41:47 <Cale> class Show a where
14:41:51 <Cale>   show :: a -> String
14:41:56 <Cale>   ... other stuff ...
14:47:18 <letrec> Why can't I write:   data SafeL a b where \n Nil :: SafeL a True \n Cons :: a -> SafeL a b -> SafeL a False
14:47:35 <mauke> because it's ;, not \n
14:47:53 <mauke> also because True is not a type
14:48:04 <hpc> mostly the latter
14:48:21 <letrec> Yes but it's a ctor
14:48:31 <mauke> and?
14:49:19 <hpc> letrec: it's at the wrong level
14:49:37 <hpc> letrec: what other language do you know that lets you mix types and values interchangably?
14:50:02 <cwraith> Ok, immutable data is great and all - but sometimes optimizing with mutable cells is worth it.  Especially when you can do it with ST cleanly
14:50:37 <t7> @hoogle intersperse
14:50:37 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:50:37 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
14:50:37 <lambdabot> Data.ByteString.Lazy.Char8 intersperse :: Char -> ByteString -> ByteString
14:50:56 <monochrom> I think you have to paste actual file so we can first confirm it is not just a silly indentation error
14:51:02 <t7> > intersperse "," ["hello", "goodbye"]
14:51:03 <lambdabot>   ["hello",",","goodbye"]
14:54:40 <shachaf> letrec: data SafeL a (b :: Bool) where { Nil :: SafeL a True; Cons :: a -> SafeL a b -> SafeL a False }
14:54:58 <shachaf> With DataKinds.
14:56:17 <letrec> shachaf: Thanks
14:56:37 <rosie> Let's say we have  "class Doc d v where ‚Ä¶" and  "instance Val v => Doc Document v where
14:56:37 <rosie>   find n doc = find n doc >>= fromVal"  What does the 'n' refer to?
14:56:58 <shachaf> rosie: n's first argument.
14:57:07 <shachaf> Er, find's first argument.
14:57:38 <shachaf> That definition looks a bit weird.
14:57:51 <monochrom> dunno, you don't show the methods of class Doc
14:58:15 <geekosaur> {{{ find n doc = find n doc >> (anything) }}} is kinda broken, no?
14:58:19 <monochrom> and if there are other things we need to know about Doc, you are not telling them
14:58:38 <shachaf> geekosaur: The (>>= fromVal) *might* make it resolve into a different instance of whatever class has "find".
14:58:52 <geekosaur> hm, point
14:58:56 <shachaf> Though that code is still somewhat strange.
14:59:26 <shachaf> What good do values do me if I don't know the types? :-)
14:59:43 <hpc> shachaf: you know the kind!
15:00:14 * t7 made a sequent pretty printer :3  ‚àÄx.F ‚ä¢ A ‚à® (‚àÉb.C),G
15:00:21 <shachaf> hpc: The kind of person who asks questions without giving types?
15:00:32 <t7> are you allowed to use inference rules on sub terms ?
15:01:11 <monochrom> no
15:01:53 <t7> that makes my life easier
15:01:54 <Philippa> that's called Deep Inference, and it's an active research area
15:02:02 <monochrom> but in the particular example of blah ‚ä¢ A ‚à® (‚àÉb.C),G, you can apply "‚à® right" to get blah ‚ä¢ A, (‚àÉb.C), G first
15:02:02 <Philippa> (but that's not a sequent system any more)
15:02:25 <rosie> ah, call the second find "find2". So we just defined a class function that doesn't have restrictions on types? e.g. n could be any type?
15:02:30 <ddarius> @google "Deep Inference"
15:02:32 <lambdabot> http://alessio.guglielmi.name/res/cos/
15:02:32 <lambdabot> Title: Deep Inference
15:02:56 * ddarius dislikes implicit capture.
15:03:14 <t7> im not sure this game is gonna be as fun as i thought
15:03:24 <t7> even with the competition aspect
15:03:40 <monochrom> game of proving theorems? :)
15:04:08 <companion_cube> there's also some paramodulatio calculi that rewrite inside terms
15:04:11 <companion_cube> there are*
15:04:40 <geekosaur> rosie, n will be inferred as the most general type that works, we can't guess what that will be without knowing more details
15:05:05 <t7> i feel like clicking and mouse guestures on sub terms would be more fun
15:05:19 <geekosaur> it could indeed be completely unconstrained if it doesn't get constrained by find2 somehow
15:05:33 <shachaf> rosie: Is this code that you're writing or code that you're reading?
15:05:40 <rosie> geekosaur: thanks! shachaf: code that I'm reading
15:06:28 <Cale> In a zero player game, everyone is a winner!
15:06:37 <monochrom> hahaha
15:07:16 * shachaf once lost a zero-player game. :-(
15:07:20 <monochrom> t7: Jim Grundy's "window inference" is a way to operate on subterms, especially interactively
15:07:21 <shachaf> ShachafFacts
15:07:41 <shachaf> @quote OlegFacts
15:07:41 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
15:07:44 <t7> cheers, i will have a butchers
15:08:34 <nand`> I solve NP-hard problems in O(1) time by deferring the calculations to the type system in a static manner. For some reason, compilation takes a while though ..
15:09:35 <companion_cube> so NP-complete problems are solved in less than constant time?
15:10:16 <ddarius> @google "Display Logic"
15:10:18 <lambdabot> http://www.displaylogic.com/
15:10:37 * edwardk still loves display logic
15:10:51 <companion_cube> the link does not work :(
15:10:59 <edwardk> http://www.pitt.edu/~belnap/87displaylogic.pdf
15:11:02 <edwardk> try that one
15:11:05 <ddarius> edwardk: You and your panoply of non-standard logics that you don't write about.
15:11:17 <edwardk> got bored with them
15:11:22 <edwardk> i'd rather write haskell
15:11:43 <shachaf> Haskell is a terrible logic.
15:11:47 <monochrom> make edwardk write in ATS. then it is both non-standard code and non-standard logic
15:11:49 <edwardk> yay! just found out i'll have my sticker order in time for the mentor summit.
15:11:52 <shachaf> But very non-standard, as logics go.
15:11:57 <edwardk> 250 haskell logos coming soon ;)
15:12:11 <edwardk> monochrom: and non-logical syntax ;)
15:12:35 <monochrom> perhaps someone should compile Agda to ATS for the kicks
15:12:37 <edwardk> depending on how they turn out i may order more, they were rather cheap
15:12:39 <crdueck> @hoogle Eq a => [a] -> [a] -> [a]
15:12:39 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
15:12:39 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
15:12:39 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
15:13:21 <edwardk> i'll probably try to do the next batch with custom die cutting though, the current batch is just stippled black and white to get the right grays
15:13:41 <edwardk> and it'd be nice to have a sticker that followed the contours of the haskell logo
15:13:46 <rosie> is it possible to have instance Hey h without defining Hey as a value constructor?
15:13:58 <shachaf> Hey is a type class, isn't it?
15:14:10 <rosie> shachaf: er yeah, sorry
15:14:11 <edwardk> rosie: 'value constructor'?
15:14:13 <monochrom> Hey is a type class, so it is not a value constructor. you are done.
15:14:44 <companion_cube> I don't understand anything in this "display logic" paper
15:15:00 <companion_cube> what's the point this thing is trying to make? -_-
15:15:14 <edwardk> re display logic: http://www.pitt.edu/~belnap/104LinearLogicDisplayed.pdf is a good followup article
15:16:00 <edwardk> followed, finally by http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.7956
15:16:09 <monochrom> trilogy?!
15:16:34 <jfischoff> @preflex ski
15:16:34 <lambdabot> Unknown command, try @list
15:16:43 <t7> 54 pages
15:16:49 <geekosaur> preflex: seen ski
15:16:49 <preflex>  ski was last seen on #haskell 33 days, 19 minutes and 10 seconds ago, saying: * ski should look more at how packages the work, ty for the reminder
15:16:51 <edwardk> 2 are y belnap. the last is by rajeev gore. so its more like 2 books and a work of fan fiction ;)
15:16:56 <shachaf> companion_cube: "I don't understand this article at all" edwardk: "Well, when you finish reading it, here's a follow-up article"
15:16:57 <edwardk> er by
15:17:05 <edwardk> shachaf: hahahahahhaa
15:17:10 <monochrom> haha fan fiction
15:17:22 <edwardk> companion_cube: the idea of display logic is deceptively simple
15:17:45 <edwardk> the goal is to make it so you can prove the admissability of cut in a logic without having to do the boring proof you usually do
15:18:05 <monochrom> yikes
15:18:16 <edwardk> the usual proof involves manually expanding out everything by distributive connectives over each other to show that you could have written that proof without building lemmas first
15:18:45 <companion_cube> ok, so it's purely a proof-theory artefact
15:18:48 <edwardk> this has unfortunate complexity from the logician's perspective. he has to work with n connectives, and there are n^2 ways they can interact
15:19:18 <monochrom> (I would teach computer programming to the logician)
15:19:23 <edwardk> display logic provides a set of conditions you can place on each connective you want to throw into the pot, that make it so that the admissability of cut follows from those properties.
15:19:43 <edwardk> this is sort of a 'hack' from a logical perspective ;)
15:19:59 <edwardk> but the nice thing is the display logic properties hold for almost all of the connectives from any logic you know and love already
15:20:08 <edwardk> so you can throw them into a blender and get out a well formed logic
15:20:08 <companion_cube> typeclasses for connectives!
15:20:21 <edwardk> without the need for the laborious traditional proof
15:20:38 <edwardk> i got really excited about display logic back in 2006 or so
15:21:00 <edwardk> companion_cube: but thats all there is to it.
15:21:10 <monochrom> hmm, do you happen to know why the name "display"?
15:21:13 <t7> i dont think this maps to my game idea very easily
15:21:19 <edwardk> when you use the curry howard correspondence display logic turns into a particularly hairy type system ;)
15:21:33 <edwardk> monochrom: the display property is how you get the admissability of cut.
15:21:54 <edwardk> basically its the property that enables you to get each thing in isolation on either side of the |- so you can cut it
15:22:11 <edwardk> thats 'putting it on display'
15:22:15 <companion_cube> oh, since you're good at logic... using Simple Type Theory with the curry howard isomorphism means that higher order terms are the program's types, right?
15:22:23 <monochrom> could I call it "expose"?
15:22:27 <companion_cube> so the types of the program can contain lambdas and stuff?
15:22:35 <edwardk> belnap named it in 87. so he has priority ;)
15:22:51 <edwardk> and he came up with little things like relevance before that, so he had some street cred
15:22:56 <monochrom> yeah I respect Belnap too
15:23:34 <monochrom> thanks edwardk
15:24:14 <edwardk> anyways i went and started a whole language project called nuel right after i found display logic, but i found i wasn't smart enough to program in it
15:24:23 <companion_cube> :D
15:33:25 <tew88> Was wondering if anyone has read 'The Haskell Road to Logic, Maths and Programming', and if so, what their thoughts were.  I think I'm quite close to buying it.  Background: Haskell beginner, jumping between LYAH, RWH and All About Monads
15:34:00 <hpc> i recognize the title, but that's it
15:34:27 <t7> tew88: i have it in my drawer
15:34:31 <t7> never read it :|
15:34:54 <t7> its quite big
15:36:42 <arjovr> /NAMES
15:37:40 <monochrom> it also depends on you
15:38:29 <Philippa> edwardk: that's generally a fatal flaw in a language, yeah :-) What about it was doing your head in?
15:39:06 <edwardk> Philippa: lots of -> like connectives. how to understand what contexts can capture what, etc.
15:39:28 <edwardk> Philippa: take every linear logic-like connective you can think of and throw it in a blender
15:39:48 <danharaj> Is GHC supposed to give me different float results depending on whether I compile with -O2?
15:39:51 <edwardk> now a.) type check it and then b.) program with it ;)
15:39:54 <edwardk> danharaj: yes
15:40:12 <danharaj> It is ironic that -O2 is giving me the correct result.
15:40:36 <Philippa> edwardk: ah, ouch :-)
15:40:36 <edwardk> it probably would -O2 is probably keeping it in registers where it gets expanded to 80 bits
15:40:54 <Philippa> I mean, I keep wanting something in that ballpark? *And the abstractions to make it tolerable*
15:41:05 <danharaj> Hmm then I need to modify my algorithm. I don't want to rely on excess precision.
15:41:09 <danharaj> That sounds like trouble.
15:41:41 <monochrom> yes, -O2 can affect floating point answers on x87 etc
15:42:12 <edwardk> are you using Float or Double?
15:42:16 <danharaj> Double
15:42:20 <monochrom> affects Double too
15:42:53 <hpaste> ixmatus pasted ‚ÄúPrint out a random val?‚Äù at http://hpaste.org/74001
15:42:56 <ixmatus> I'm severely confused here
15:43:19 <monochrom> difference between "load x, load y, add, load z, add" and "load x, load y, add, truncate to double, load z, add, truncate to double"
15:43:39 <ixmatus> can someone help me with the above
15:43:55 <monochrom> (if you don't explicitly truncate, it means intermediate answers can have super-Double precision)
15:44:36 <monochrom> "truncate to double" means "store into memory while truncating to double, then load back as double"
15:45:08 <fanthom101> its full of stars!!
15:45:53 * hackagebot perdure 0.2.0 - Robust persistence for acyclic immutable data  http://hackage.haskell.org/package/perdure-0.2.0 (PatrickPremont)
15:46:53 <monochrom> there are supposedly -fexcess-precision and -fno-excess-precision to control it, but there is also some issue in the code generator that doesn't honour it always
15:49:19 <rosie> How should I go about using a do block inside a nested case statement? I'd assume myFunction g = case x of Just y -> case y of Just z -> do $ putStrLn "something"; case z of ‚Ä¶ would work
15:49:37 <ddarius> rosie: do blocks are expressions like any other.
15:49:57 <rosie> ddarius: thanks
15:50:28 <rzys> a little newbie question: suppose you had a program which reacts to user input, but you need to store some data throughout the lifetime of the program. is there a better approach than a function which loops recursively passing itself the datastructure again and again until something happens and it can modify the datastructure again?
15:50:54 <nand`> StateT s IO ?
15:52:23 <hpaste> r pasted ‚Äútesting cases and prints‚Äù at http://hpaste.org/74002
15:52:32 <edwardk> @remember shachaf companion_cube: "I don't understand this article at all" edwardk: "Well, when you finish reading it, here's a follow-up article"
15:52:33 <lambdabot> I will remember.
15:52:58 <rosie> ddarius: any idea why I get a parse error on the second case?
15:53:14 <rzys> ahem, ok ty ill have a look at the docs
15:53:14 <monochrom> bad alignment
15:53:27 <monochrom> of code or stars
15:53:38 <hpc> @remember edwardk @remember shachaf <absolutely nothing to do with shachaf>
15:53:39 <lambdabot> Okay.
15:53:58 <shachaf> hpc: Well, I did say that earlier...
15:54:00 <edwardk> hpc: shachaf actually summarized what i said in his comment ;)
15:54:02 <companion_cube> too bad, posterity will remember me as someone who cannot read complex logic papers :>
15:54:06 <hpc> oh
15:54:11 <hpc> @forget edwardk @remember shachaf <absolutely nothing to do with shachaf>
15:54:12 <lambdabot> Done.
15:54:30 <shachaf> That's some delayed-action @remembering, though.
15:54:42 <rosie> monochrom: where?
15:55:08 <monochrom> depends on actual code
15:55:09 <shachaf> edwardk: I will outdo you.
15:55:11 <danharaj> How do I enable/disable optimization on a per module basis?
15:55:26 <edwardk> was distracted by other things
15:55:27 <eikke> GHC_OPTIONS pragma?
15:55:42 <monochrom> unless it's bad alignment of stars, then the position is "in the sky"
15:55:43 <rosie> monochrom: I posted the code on haste
15:55:45 <shachaf> ...Actually, never mind.
15:55:46 <rosie> *hpaste
15:56:00 <monochrom> and your name is "r"?
15:56:06 <rosie> yep
15:56:13 <shachaf> rosie: Indent the "Just" past the "case".
15:56:31 <shachaf> Also, that do isn't necessary.
15:56:32 <monochrom> "do $ ..." looks wrong
15:56:38 <shachaf> That $ is even less necessary -- it's invalid.
15:57:02 <shachaf> > do (+1) $ do 5
15:57:03 <lambdabot>   6
15:57:12 <monochrom> do you really understand "$"? if not, I suggest forgetting it
15:57:12 <shachaf> INTERCASKELL
15:57:49 <hpc> perhaps you are thinking of "$ do ..."?
15:58:04 <rosie> monochrom: ah, sorry, hpc you're right
15:58:18 <nand`> INTERCALESKELL
15:58:30 <rosie> taking it out‚Ä¶ and reposting
15:59:45 <rosie> nvm it works
15:59:52 <rosie> thanks!
16:11:28 <danharaj> so my floating point weirdness still occurs when I compile with -msse2. Shouldn't that avoid ever using extended precision?
16:12:41 <davean> no?
16:13:54 <ixmatus> I'm having a really hard time understanding how to use the Crypto.Random api
16:14:08 <ixmatus> I'm a noob and my understanding of Haskell's type system is lacking
16:14:13 <ixmatus> I'm just trying to do something very basic
16:14:32 <ixmatus> I have this down: random (mkStdGen 100) :: (Int, StdGen)
16:14:41 <ixmatus> from learn you a haskell
16:14:48 <ixmatus> but it isn't cryptographically secure
16:14:52 <ixmatus> er
16:14:57 <ixmatus> cryptographic rng
16:15:10 <shachaf> What do you need a "cryptographic rng" for?
16:15:45 <ixmatus> I don't "need" it but I got curious and dug in deep and now I'm stuck and I want to understand it
16:15:51 <ixmatus> that's all
16:17:07 <ixmatus> I just need a few minutes of help so I can understand this - I know it's just me missing a critical piece of this and I've been at it for 4 hours now
16:17:14 * shachaf isn't very enthusiastic about most Haskell cryptography-related packages.
16:17:48 <shachaf> This Crypto.Random thing seems to be no exception -- it defines a type class with exactly one instance, of which it says "Not that it is technically correct as an instance of CryptoRandomGen"
16:18:15 <shachaf> Anyway, what's your question?
16:19:23 <ixmatus> in learn you a haskell; there's this example: random (mkStdGen 100) :: (Int, StdGen)
16:19:30 <ixmatus> works wonderfully
16:19:35 <ixmatus> now
16:19:50 <ixmatus> I'm completely at a loss for how to do the SAME EXACT thing but with cryptographic rng using the crypto-api
16:20:14 <ixmatus> I tried a bunch of stuff - but really, it's just a noob guessing
16:20:33 <shachaf> According to crypto-api's documentation, its one RNG isn't actually "technically correct".
16:20:38 <shachaf> Anyway, do you know how IO works?
16:21:04 <ixmatus> for a noob to Haskell, yes
16:21:57 <ixmatus> shachaf see this, code that doesn't work
16:22:06 <shachaf> Looks like this API is for generating bytes, not arbitrary values.
16:22:23 <hpaste> ixmatus pasted ‚ÄúGrrr‚Äù at http://hpaste.org/74003
16:22:34 <shachaf> Which may be reasonable when your application is cryptography.
16:23:32 <shachaf> Oh, Control.Monad.CryptoRandom.
16:24:48 <hpaste> letrec pasted ‚ÄúSafeTail‚Äù at http://hpaste.org/74004
16:24:57 <shachaf> Why are you doing this? You probably shouldn't be. It looks like it's meant to be a low-level API for people who know both Haskell and some cryptography. :-)
16:25:03 <shachaf> Anyway, just look at the list of instances for CRandom.
16:25:22 <shachaf> They're things like Int and Word64.
16:25:30 <ixmatus> right yes
16:25:43 <shachaf> There's no (x,y) instance, so trying to use a pair won't work.
16:25:54 * hackagebot GLFW-task 0.2.0 - GLFW utility functions to use together with monad-task.  http://hackage.haskell.org/package/GLFW-task-0.2.0 (PaulLiu)
16:26:08 <ixmatus> okay
16:26:22 <letrec> I understand why my code (http://hpaste.org/74004) doesn't typecheck. Is there a way to make it work though?
16:26:57 <shachaf> If you want an Int, you can presumably just match Either GenError (Int, YourGenType)
16:27:11 <shachaf> I don't see where "bytes" is getting into it.
16:27:26 <ixmatus> okay
16:27:31 <ixmatus> lemme try something
16:28:59 <shachaf> (But you didn't say why you're doing this. :-( )
16:29:46 <hpaste> ixmatus pasted ‚ÄúNew‚Äù at http://hpaste.org/74005
16:29:53 <ixmatus> shachaf ^
16:30:09 <mauke> letrec: http://hpaste.org/74006
16:31:10 <ixmatus> it's almost acting like a IO action
16:31:58 <ixmatus> shachaf all I want to do is print a random value out
16:32:00 <ixmatus> I don't' have much reason
16:32:04 <ixmatus> I'm just learning
16:32:13 <shachaf> mauke: Wait a minute, that's not maukebot.
16:32:55 <shachaf> ixmatus: The type of (Right int) *also* doesn't unify with the type I gave.
16:33:05 <ivanm> > random (mkStdGen 3) :: (Int, StdGen)
16:33:06 <lambdabot>   (5541392136091291592,1090583934 2103410263)
16:33:07 <shachaf> Either GenRandom (Int, YourGenType)
16:33:15 <shachaf> Right (x :: Int, y :: YourGenType)
16:33:24 <ivanm> I realise I've come in late, but isn't that an easier way to print a random value out?
16:33:26 <shachaf> ixmatus: I don't recommend using this API to learn Haskell.
16:33:56 <shachaf> 16:14 <ixmatus> I have this down: random (mkStdGen 100) :: (Int, StdGen)
16:34:03 <ivanm> ahhhh, k
16:34:16 <ixmatus> ahhh! okay, I didn't realize when doing the pattern match you could specify the :: Int and y :: GenType
16:34:33 <shachaf> ixmatus: I was just saying that for clarification -- you don't need to specify those.
16:34:44 <shachaf> Well, you might, but you can certainly get away with not doing it.
16:35:09 <shachaf> ixmatus: Type classes will just make your life hard. You shouldn't use this package right now.
16:36:05 <ixmatus> mk mk
16:36:28 * shachaf has the feeling everything a direct answer to the question will be ignored.
16:37:01 <ixmatus> shachaf I'm not trying to get code out of you :)
16:37:32 <shachaf> I'm not talking about code.
16:38:11 * ixmatus is confused then
16:38:28 <mrlemao> How do I putStrLn within a Process () do block?
16:39:08 * ddarius should write some malware in Haskell to give the computer security people something novel.  "This malware developer used an exceedingly strange obfuscation mechanism."
16:39:57 <shachaf> ddarius: That would be great!
16:40:12 * shachaf wonders how difficult GHC-compiled code is to reverse-engineer.
16:40:37 <ddarius> shachaf: It depends on whether you know it's GHC-compiled code.
16:41:18 <MostAwesomeDude> Any time there's a GC, it gets pretty tricky.
16:41:26 <ddarius> It's probably not hard to reverse-engineer the "function call" mechanism, but laziness probably massively distorts the control flow.
16:41:29 <ggreif> shachaf: it tends to call a bunch of AP_* symbols
16:41:29 <lambdabot> ggreif: You have 1 new message. '/msg lambdabot @messages' to read it.
16:42:59 * ddarius bets most malware doesn't "ship" with a symbol table.
16:43:16 <MostAwesomeDude> For wrapping a well-behaved C API, what's the right preprocessor, if any? There are no macros, all data is either primitive or opaque, and I'm forced to use type-safe new() and delete() functions to allocate my objects.
16:43:35 <shachaf> Why would you need a preprocessor?
16:43:39 <ddarius> MostAwesomeDude: Using the raw FFI is pleasant enough.
16:43:57 <shachaf> kmc had a nice talk on it.
16:43:58 <ddarius> The only thing that really calls for more is structure fields.
16:43:59 <shachaf> @google t0rch.org ffi
16:44:00 <lambdabot> http://ugcs.net/~keegan/talks/high-level-ffi/talk.pdf
16:44:00 <lambdabot> Title: High-level FFI in Haskell
16:44:01 <MostAwesomeDude> shachaf: I hear that that's what all the kids are doing.
16:44:35 <MostAwesomeDude> But yeah, so if I have no structs with data fields, I can just go ahead and write raw FFI?
16:44:51 <shachaf> Yes.
16:45:00 <MostAwesomeDude> Sweet.
16:45:03 <shachaf> You might get some good idea from reading that PDF, though.
16:45:44 <MostAwesomeDude> Yeah, I'll do that.
16:45:50 <monochrom> you can always write FFI by hand
16:46:01 <MostAwesomeDude> I'm on a roll today; I finally found a real use for RWS and I'm so excited.
16:47:12 <parcs`> MostAwesomeDude: bindings-DSL and hsc2hs
16:47:34 <MostAwesomeDude> parcs`: And those help?
16:48:36 <shachaf> parcs`: Did you read the context here?
16:49:31 <parcs`> they are immensely helpful for more complex C bindings involving macros, structs (opaque or not), typedefs, global variables etc
16:49:40 <parcs`> shachaf: maybe
16:51:44 <noor__> man CS is hard :(
16:52:10 <shachaf> Don't be sexist.
16:52:44 <MostAwesomeDude> parcs`: Yeah, I bet they are, but there's none of that here. It's the nicest C API I've ever dealt with; I've already wrapped it in Python and I'm just doin' it in Haskell now since nobody else has gotten to it.
16:52:50 <MostAwesomeDude> (This is Fluidsynth, BTW.)
16:53:06 <jfischoff> I'm starting to see the value in Text or other alternatives to String for writing instances. If I write an instance for [a] I probably don't want it to work the same way for String.
16:53:47 <shachaf> jfischoff: newtype String = String [Char] would serve the same purpose.
16:53:53 <shachaf> Text is a very different data type.
16:53:54 <jfischoff> yes
16:53:56 <parcs`> MostAwesomeDude: nice
16:53:59 <jfischoff> sure
16:54:05 <MostAwesomeDude> parcs`: Very nice.
16:54:22 <parcs`> ffi bindings are probably the most mind-numbing thing you can do in haskell
16:54:37 <jfischoff> shachaf: but I am going to make a newtype for String I might as well make just use Text
16:54:51 <shachaf> jfischoff: That depends.
16:55:04 <jfischoff> shachaf: true
16:55:09 <MostAwesomeDude> parcs`: I'll see that, and raise you with typing out enums for standardized but unformatted enumerations.
16:55:09 <shachaf> Do you want all the nice parts of lists?
16:55:18 <shachaf> Like, say, consing?
16:55:40 <jfischoff> shachaf: In my particular case, it is not important, but in general yes
16:58:53 <parcs`> MostAwesomeDude: usually a vim macro can do that for me
16:59:44 <MostAwesomeDude> parcs`: If the data starts out relatively formatted, then yes. If not, then, well.
17:01:47 <MostAwesomeDude> Oh! I did have another FFI question. ForeignPtrs look pretty awesome for automagic cleanup using the GC. But, what if I have an object that depends on another object? How do I keep it  alive?
17:02:11 <ddarius> @hoogle touch
17:02:11 <lambdabot> Foreign.ForeignPtr touchForeignPtr :: ForeignPtr a -> IO ()
17:02:11 <lambdabot> System.Posix.Files touchFile :: FilePath -> IO ()
17:02:11 <lambdabot> Data.Array.Storable touchStorableArray :: StorableArray i e -> IO ()
17:02:47 <MostAwesomeDude> But how do I keep that touch alive? The docs for touchForeignPtr and withForeignPtr indicate that it's only in that action.
17:03:25 <MostAwesomeDude> I want to attach a reference from one ForeignPtr to another persistently. Do I just have to cross my fingers and hope that things happen in the right order?
17:03:30 <MostAwesomeDude> Or maybe I'm overthinking this.
17:03:44 <MostAwesomeDude> Meh. Plane time, I'll figure it out later. Thanks!
17:08:21 <parcs`> MostAwesomeDude: usually you hold the ForeignPtr inside a data type
17:13:12 <parcs`> if Object2 depends on Object1 then you can do something like newtype Object1 = Object1 (ForeignPtr A) data Object2 = Object2 (ForeignPtr B) Object1
17:14:37 <parcs`> you can also probably use touchForeignPtr within the finalizer of another ForeignPtr to express a dependency
17:16:45 <ixmatus> shachaf I finally figured it out and got working code
17:18:23 <ixmatus> I didn't realize in the case ‚Ä¶ of
17:18:30 <ixmatus> I could/had to also put the type definition
17:18:37 <ixmatus> it was throwing the ambiguous type error
17:20:07 <shachaf> ixmatus: It is also possible to do it without putting the explicit type annotation, by using the value with the appropriate type.
17:20:14 <shachaf> But you really oughtn't be doing this. :-(
17:20:44 <ixmatus> by using the value with the appropriate type?
17:22:12 <hpaste> ixmatus pasted ‚ÄúCRNG‚Äù at http://hpaste.org/74008
17:22:41 <ixmatus> shachaf ^ is that considered the right or wrong way to do it? (tell me to bugger off if I'm being annoying)
17:22:52 <ixmatus> I'm not pursuing it further, just wanted to get it to work
17:23:27 <deech> Hi all, the last I looked hasktags was somewhat temperamental, is there a better tagging system available now?
17:24:47 <byorgey> I have not heard of any other tagging system.
17:29:08 <shachaf> ixmatus: That way is probably fine.
17:29:29 <shachaf> ixmatus: You can also Right (i :: Int, _) -> print (abs i)
17:29:31 <shachaf> Or something.
17:30:03 <ixmatus> I get a, use -XScopedTypeVariables message though
17:30:10 <ixmatus> when I try that
17:30:15 <ixmatus> (I did try that too)
17:31:12 <ddarius> Having type annotations in patterns is a minor extension.
17:31:48 <ixmatus> is that better than not having them?
17:36:10 <startling> I suppose it could get around the monomorphism restriction in some cases
17:36:17 <startling> dunno why else that's nice
17:38:56 <spark_> Hi again #haskell
17:39:44 <spark_> How hard is to switch a map to a  parallel map? Does it depends on data type or whenever I have map I can switch to parmap?
17:40:05 <t7> i thought you just write pmap instead?
17:40:35 <spark_> t7: I'm asking to be sure/not fall into a trap D:
17:40:54 <t7> i dont know i only saw it in a video years ago
17:41:02 <startling> :t pmap
17:41:03 <lambdabot> Not in scope: `pmap'
17:41:35 <spark_> :t parmap
17:41:36 <lambdabot> Not in scope: `parmap'
17:41:49 <spark_> :t parMap
17:41:49 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
17:42:16 <spark_> (I also need a strategy, let me figure that out myself)
17:43:06 <spark_> he, the documentat explains all
17:46:38 <ddarius> spark_: Welcome to purely functional programming.
17:47:45 <shachaf> -funpuresafe-math
17:50:24 <spark_> ddarius: D:
17:50:52 <spark_> Hmm, I guess I have to create a strategy
17:51:48 <noor_> has anyone ever discussed making haskell so it didn't need to make C calls in any other instance than in peak performance issues?
17:52:01 <noor_> expanding I should say
17:52:40 <shachaf> What does that mean?
17:53:02 <Dashkal> error: unable to parse query
17:54:01 <noor_> is there no IO, IPC, or system call that can not be done with pure Haskell, I suppose is the first question.
17:55:17 <Dashkal> If you want to re-implement libc, I suppose you could go ahead, but system calls are a posix api.  You get no choice in how to invoke one of those.
17:55:32 <Dashkal> Or rather, at that point you're now writing the OS.
17:55:53 <noor_> could you write an OS in pure haskell?
17:56:25 <n00b6502> haskell os hehe. they keep talking about a lisp os on #lisp
17:56:39 <ddarius> There are at least two OSes implemented in Haskell.
17:56:58 <n00b6502> what type of oses
17:57:02 <noor_> list please.
17:57:53 <noor_> so you can pass and read from pointers in haskell..
17:58:39 <n00b6502> is there literally poke :: Int -> Int -> IO () perhaps
17:58:45 <n00b6502> etc
17:59:52 <noor_> one of those ints is treated as a pointer? (never heard of poke)
18:00:18 <ddarius> noor_: There's House, hOp, and Kinetic.
18:00:19 <n00b6502> in BASIC back in the days of LP-ROM drives etc , it was always "PEEK" and "POKE" to acess memory directly
18:00:30 <ddarius> n00b6502: There is a poke and a peek.
18:00:33 <ddarius> @hoogle poke
18:00:33 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
18:00:33 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
18:00:33 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
18:00:55 <noor_> int is a member of Ptr?
18:00:56 * hackagebot metadata 0.1.2.0 - metadata library for semantic web.  http://hackage.haskell.org/package/metadata-0.1.2.0 (KatsutoshiItoh)
18:01:09 <n00b6502> or storable
18:02:13 <Cale> noor_: There's an IntPtr type which you can cast to a Ptr
18:03:07 <Cale> (as well as an unsigned WordPtr type)
18:03:18 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
18:03:28 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html#t:Storable
18:06:25 <Cale> this is also pretty cute:
18:06:31 <Cale> @hoogle malloc
18:06:31 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
18:06:31 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
18:06:32 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
18:06:37 <n00b6502> ah nice
18:06:59 <n00b6502> malloc ,free, realloc even ?
18:07:05 <Cale> yep
18:07:09 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Alloc.html
18:07:23 <n00b6502> hell i could be more at home than in idiomatic C++
18:07:23 <Cale> as well as alloca
18:07:41 <Cale> (which is a bit safer)
18:07:55 <n00b6502> allocais nice
18:08:30 <n00b6502> could you serialize/deserialize a haskell object to/from a byte array in a standardized manner i wonder..
18:08:40 <n00b6502> and query its size for a malloc
18:08:41 <Cale> and then all that stuff again, but for arrays, both 0 terminated and not: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Array.html
18:08:57 <Cale> Well, that's what instances of Storable are for
18:09:44 <Cale> You'll notice that malloc doesn't take a size parameter
18:09:59 <Cale> because the Storable instance will provide the size needed
18:10:05 <Cale> (and alignment constraint)
18:10:37 <Cale> I wonder how well it deals with weird alignment constraints :)
18:11:20 <n00b6502> you even have problems in C there
18:11:53 <n00b6502> eg declaring stack locals for use with SIMD didn't always work so well..
18:12:17 <ddarius> alloca in Haskell is just a wrapper around malloc.
18:12:53 <parcs`> @hoogle with
18:12:53 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
18:12:53 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
18:12:53 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
18:12:54 <n00b6502> that will get 'freed' on stack-unwind?
18:13:14 <Cale> apart from the fact that there isn't a stack, yes ;)
18:13:40 <n00b6502> does a sequential monadic block emulate one
18:14:08 <parcs`> @hoogle new
18:14:08 <lambdabot> System.Event new :: IO EventManager
18:14:08 <lambdabot> Data.HashTable new :: (key -> key -> Bool) -> (key -> Int32) -> IO (HashTable key val)
18:14:08 <lambdabot> Foreign.Marshal.Utils new :: Storable a => a -> IO (Ptr a)
18:14:38 <Cale> Well, if there's an exception, it'll free.
18:16:04 <Cale> But there's no call stack to speak of, the stack you might hear of if you get a stack overflow is a stack of pattern matches waiting for their scrutinee to be sufficiently evaluated to match a constructor.
18:17:59 <Cale> @hoogle with
18:17:59 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
18:17:59 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
18:17:59 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
18:19:14 <parcs`> 'instance FromString CString where fromString = unsafePerformIO . newCString' good or bad idea?
18:21:26 <Cale> I'm thinking bad idea... the memory will never be freed then.
18:22:23 <Cale> Though I guess you might be able to live with that.
18:22:31 <noor_> back
18:22:33 <noor_> so if I wanted to make a bit of memory shared for IPC, i would malloc it, give a pointer and a size to a foreign c system library call, and that would be the end of it?
18:23:59 <geekosaur> I odubt it
18:24:25 <Cale> I guess it might be that simple in some cases.
18:25:06 <spark_> welp, changing to parMap made use 8 threads, but didnt get any faster D:
18:25:06 <noor_> minus keeping everything safe and free of race conditions etc
18:25:13 <Cale> I've never really done IPC via shared memory.
18:25:39 <geekosaur> on hackage there's mmap, vector-mmap, and bytestring-mmap
18:25:41 <Cale> spark_: maybe try chunking
18:26:15 <noor_> thanks
18:26:32 <geekosaur> I havent worked with any of them; just keep in mind you need to deal with atomicity across processes if you're using shared memory
18:26:56 <spark_> callen: I guess parMap (rpar >>=) list makes a spark for every single thing and run at once, in place of buffering
18:27:24 <Cale> spark_: yes
18:27:47 <Cale> well, I don't really know what that >>= is doing there...
18:27:58 <Cale> actually, what?
18:28:15 <Cale> usually it'll be something like parMap rseq
18:28:24 <Cale> or  parMap rdeepseq
18:28:35 <spark_> but does that make it sequential?
18:28:58 <Cale> no
18:29:05 <Cale> parMap is inherently parallel
18:29:26 <crdueck> i have a normal haskell list of values in a file, i want to get the list from the file and treat it as a list, not a String. Obviously readFile doesnt work here, how can I do this?
18:29:32 <Cale> it sparks the evaluation of all the elements of the mapped-over list with the strategy that you give it
18:30:01 <Cale> crdueck: How did you serialise the list?
18:30:16 <Cale> crdueck: fmap read <$> readFile "foo"?
18:30:20 <Cale> er
18:30:20 <spark_> hmmm, well i probably need bufering still, since profiling shows my program stays 70% in idle
18:30:22 <Cale> derp
18:30:27 <Cale> crdueck: read <$> readFile "foo"
18:30:38 <shachaf> fmap (fmap read <$>) (fmap readFile "foo")
18:30:42 <Cale> :)
18:30:46 <Cale> or fmap read (readFile "foo")
18:30:50 <Cale> but not both :)
18:30:59 <crdueck> Cale: thanks :) i'll try it out
18:31:11 <Cale> I changed my mind about which combinator to use, but didn't delete the other one :)
18:31:21 <shachaf> Cale: I just felt like... U+1F60E
18:31:22 <Cale> (they're equivalent)
18:31:23 <shachaf> Joining in.
18:32:42 <Cale> crdueck: Note that the type that you use the result at will determine which parser that it'll use :)
18:42:21 <spark_> waaaaait a second
18:42:43 <spark_> if I have a map (f ) . map (g), and change it to parMap (f) . map (g)
18:43:09 <spark_> the map on the right will bottleneck the speed gain from the first right?
18:43:57 <startling> spark_: map f . map g is usually a mistake
18:44:05 <startling> spark_: it's equivalent to map (f . g)
18:44:16 <spark_> startling: I know, it's more hypotetically speaking
18:45:08 <startling> spark_: but yeah, the regular `map` will take longer
18:45:18 <startling> well, assuming parMap is smart
18:47:23 <applicative_> that it sees map f . map g as map (f.g) or something equivalent is typical of foldr / build optimizations, no?
18:47:34 <applicative_> that ghc sees this, I mean
18:48:24 <spark_> applicative_: well, the other day I had a speed gain by manually fusing two consecutive maps...
18:48:30 <spark_> even with O2
18:48:59 <applicative_> hm, well, no so reliable as one would hope I guess.
18:49:21 <spark_> or maybe it was something else, too bad I don't have a test case
18:49:55 <spark_> but someone else cam to the channel this week with a similar case, iirc
18:50:41 <applicative_> in theory it should catch parMap strat f . map g -- parMap strat f = (`using` parList strat) . map f
18:55:44 <ddarius> parMap still has to walk the list at which point all the work that was necessary from map g will have been done.
18:56:30 <timemage> is there an easy way for a program compiled with ghc to determine whether or not it was built with -threaded either runtime or compiletime.
18:57:52 <shachaf> Why do you want to know?
18:57:53 <applicative_> it has to walk the list given to the composed function, yes
18:57:55 <ddarius> I believe you can query the flags with TH.  Also, there are probably defines.  For run-time, I believe numCapabilities will be 1 for any program called with +RTS -N n
18:58:21 <shachaf> ddarius: You can query compile flags, but link flags?
18:58:28 <ddarius> shachaf: Point.
18:58:40 <ddarius> But you may just get all flags passed to GHC.
18:58:48 <shachaf> That sounds unreliable.
18:58:49 <ddarius> But someone could link after they built.
18:59:03 <shachaf> getNumCapabilities might close to what you want, depending on why you want it.
18:59:33 <shachaf> I think -threaded still behaves differently from non--threaded, even with +RTS -N 1
18:59:45 <ddarius> Yes it does.
18:59:48 <shachaf> For example, with the FFI, or forkOS, or something.
19:00:37 <timemage> network.sockets problem with blocking on windows has caught me a number of times.    figured i could put a warning in if i detect no -threaded option.    getNumCapabilities doesn't seem to be accessable.  numCapbilities returns 1 regardless of whether or not i specify -threaded.  it's no big deal, just thought it would be nice to put directly in the code.
19:01:23 <shachaf> GHC doesn't use the IO port thing on Windows?
19:02:52 <shachaf> Hmm, "It is possible to ask the RTS to give some information about itself."
19:04:04 <timemage> shachaf, yeah, i noticed that.
19:05:01 <applicative_> main = getNumCapabilities >>= print -- this prints 23 if I give it +RTS -N23
19:05:58 <timemage> applicative_, unfortunately that won't solve the problem.
19:05:59 <shachaf> applicative_: Yes, but that's not the question here.
19:06:30 <ddarius> It could be used to answer the question by hard-coding the RTS flags.
19:06:39 <applicative_> no, Im just surprised. The pseudo-pure numCapabilities used to act differently
19:07:04 <ddarius> applicative_: I.e. your program gives that result even without -threaded?
19:07:14 <shachaf> Presumably if you know that link-time flag, you also know the other link-time flag.
19:07:35 <ddarius> shachaf: I'm talking about the run-time flag.
19:08:01 <shachaf> Oh.
19:08:45 <spark_> Question: a really good paralel implementation means that N1 and unthreaded are the same speed
19:08:47 <spark_> ?
19:09:12 <applicative_> if i give it -N2 without having used -threaded it gives an ugly error statement, even if I used -rtsopts
19:09:24 <spark_> Or are there tools to help deciding how to make better strategies?
19:09:28 <ddarius> applicative_: Okay, that's what I thought.
19:10:01 <ddarius> spark_: Typically you care more about scaling than sequential performance, though you should start with good sequential performance.
19:11:02 <ddarius> In general you need a good sequential implementation anyway, because high performing parallel code usually will switch between parallel and sequential modes (e.g. data parallel programming.)
19:11:11 <spark_> sequential 2.29, N1, 6.19
19:11:23 <spark_> Guess I'm doing it wrong
19:11:53 <noor_> guru question:
19:11:53 <noor_> Can I ru-in a haskell program by calling foo undocumented c binary? EG can it alter the code segment in a nice OS like OSX latest? Do haskell programs have a stack and heap? Does the OS care about stacks and heaps or only the memory the process contains in total?
19:12:16 <ddarius> spark_: Maybe, but you'd have to compare to no annotations at all.  It could be that the Simon's are "doing it wrong" for a very mild value of "wrong."
19:12:44 <spark_> ddarius: what you mean by no annotations?
19:12:54 <ddarius> spark_: No par or things that use par.
19:13:03 <c_wraith> noor_: you *can* do anything you want.  You can call native code arbitrarily.  You just don't, usually.  It's considered bad code.
19:13:06 <shachaf> @yarr
19:13:07 <lambdabot> I'd like to drop me anchor in her lagoon
19:13:22 <ddarius> @hackage harpy
19:13:22 <lambdabot> http://hackage.haskell.org/package/harpy
19:13:46 <spark_> ddarius: Iare you talking about dph?
19:13:55 <shachaf> @yarrpy
19:13:55 <lambdabot> Get out o' me way, yeh landlubber
19:14:15 <spark_> (Im using control strategies
19:14:15 <spark_> )
19:14:27 <noor_> I'm asking if this is permissible by the OS, changing the code segment at runtime, or if OSes somehow protect this.
19:14:40 <ddarius> noor_: Yes.
19:14:46 <noor_> hmm
19:14:55 <c_wraith> noor_: oh.  yeah, modern OSes generally make you jump through hoops to do it
19:14:59 <spark_> ddarius: I think yes is ambiguous there
19:15:07 <ddarius> spark_: In some ways.
19:15:18 <spark_> D:
19:15:21 <ddarius> spark_: In other ways, the ambiguity doesn't matter.
19:15:56 <c_wraith> as a general security thing, compilers and OSes are generally set to mark executable segments non-writeable
19:16:11 <c_wraith> the main exception is when doing JIT compilation
19:16:22 <applicative_> spark_ is the module you are talking about pastable or some complicated monster?
19:16:38 <noor_> ...so if I call the wrong c file my factorization program could open photoshop?
19:16:50 <noor_> or become photoshop?
19:17:02 <shachaf> What?
19:17:03 <applicative_> you can open photoshop more easily than that
19:17:16 <spark_> applicative_: ahm, I would say it's kinda messy, but the core of the application is 1 line
19:17:16 <ddarius> If you don't know the answers to these questions already, I'm not sure why you are asking them here.
19:17:53 <shachaf> If you do know the answers to these questions already, why you're asking them here is even more mysterious.
19:17:54 <noor_> ok so the compiler can set the code segment to non alterable, if it wants to?
19:18:04 <noor_> but it doesn't HAVE to?
19:18:29 <shachaf> This has little to do with the compiler.
19:18:40 <ddarius> This has little to do with Haskell.
19:19:10 <hpaste> spark_ pasted ‚ÄúfftAcross is the core‚Äù at http://hpaste.org/74009
19:20:12 <noor_> I'm asking if the code segment can be set to unalterable by an OS like OSX and if it can but doesn't have to be, how often and for what reasons is it ever set to mutable?
19:20:26 <spark_> this is an OS question noor_
19:21:05 <noor_> anyone know the answer?
19:21:07 <shachaf> noor_: The question "why are you asking it here?" is a reasonable one.
19:21:10 <noor_> I like this channel :)
19:21:46 <spark_> noor_: afaik there is no distintion between code and data segment nowdays
19:21:58 <noor_> hmm
19:22:04 <spark_> or maybe they reemplemented it for pipelining purposes
19:22:19 <spark_> but anyway, it's a messy topic, it's not done
19:24:04 <noor_> I guess its because I don't like the idea of calling c things I don't know about. I was wondering how far you could break or compromise your code by calling a foreign anything. It sounds like completely probably.
19:24:46 <shachaf> Cale: Yay, double (double 5) made its way to Reddit!
19:24:56 <Ralith> noor_: believe it or not, executing untrusted code is unsafe!
19:25:02 <zzzzzbogus> @pl \x y -> x y
19:25:02 <lambdabot> id
19:25:07 <c_wraith> if it's on the other end of a dynamically loaded library, it could be anything, and you never know in advance.  There are points at which you just have to assume the OS isn't compromised
19:25:15 <ddarius> zzzzzbogus: It's a lie.
19:25:15 <noor_> can you call a check for bounds of memory in process and get back two pointers?
19:25:16 <gwern> Ralith: heck, executing trusted code is unsafe
19:25:37 <ddarius> c_wraith: Like at all points.
19:25:39 <zzzzzbogus> @pl \g (_,b) (a',b') -> (a',g b b')
19:25:39 <lambdabot> (. snd) . flip flip snd . (ap .) . flip flip fst . (((.) . flip ((.) . (,))) .)
19:25:52 <zzzzzbogus> @ddarius yes I know
19:25:52 <lambdabot> Unknown command, try @list
19:25:57 <c_wraith> ddarius: yeah, those ones
19:25:59 <noor_> never mind, unsafe code is unsafe, question answered.
19:26:07 <zzzzzbogus> ddarius: yes I know
19:26:14 <Ralith> gwern: well, depends how you define trust.
19:26:42 <ryant5000> hi guys, i've got a couple haskell job openings in NYC; message me if you're interested
19:26:56 <gwern> constant vigilance!
19:27:20 <crdueck> i have an implementation of conway's game of life. I'm trying to use parallelism to speed up the generation of the next world-state, but my parLife function is slower than my life function. I'm compiling with the -threaded flag and using the +RTS -N3 runtime options. heres the source file: http://sprunge.us/hHgc Am I using parMap incorrectly? or is there some other reason why its running slower?
19:34:27 <spark_> did you try r.seq in place of rdeepseq?
19:40:29 <spark_> crdueck: parMap is usefull when map f has a heavy f, if you have a long input you probably want to do chunking or similar
19:40:51 <spark_> crdueck: but im learning parallel atm, so better find someone more experienced
19:45:10 <zzzzzbogus> @unpl (.) ((. snd) . flip (second . flip ($))) . second
19:45:10 <lambdabot> (\ o c x -> second (\ j -> j (snd x)) (second o c))
19:47:06 <ixmatus> Haskell‚Ä¶is‚Ä¶AWESOME
19:47:47 <c_wraith> well.  It's at least pretty darn cool.
19:50:00 <Ralith> it's neat, anyway.
19:51:12 <Sculptor> guess it's ok
19:52:41 <shachaf> HASKELL IS THE WORST THING
19:53:20 <Ralith> heretic!
19:53:40 <avpx> shachaf: Basically
19:54:43 <ixmatus> beats the pants off of Erlang's dialyzer (as cool as it is)
19:55:31 <ddarius> ixmatus: That's not much of comparison...
19:56:10 <ixmatus> yes, hence my exclamation above
19:56:40 <ixmatus> don't get me wrong, I love Erlang - but programming in Haskell has been awesome so far
19:57:06 <Lutin`> Yeah one thing Haskell has finally let me do is code without having to compile
19:57:19 <Lutin`> And not have to worry for the most part
19:57:21 <ddarius> Comparing Erlang and Haskell makes more sense.  Comparing Haskell's type system to Dialyzer is doable but rather unfair to Dialyzer.
19:57:57 <startling> Lutin`: how do you mean?
19:58:29 <ixmatus> ddarius this is true, but the only thing in Erlang that remotely resembles type checking IS the dialyzer :-/
19:58:32 <Lutin`> Just being able to reason more easily about what things do and such
20:18:19 <gadtfly> So I just spent a good long time trying to figure out how the hell something I did was typechecking... and it turns out that I had the reader monad in my environment from important Text.Parsec.  Why the heck is that?
20:18:33 <gadtfly> *importing Tet.parsec
20:18:50 <Cale> You mean the (->) e monad?
20:18:52 <gadtfly> Yeah
20:19:03 <Cale> I kinda wish that one was in the Prelude myself ;)
20:19:10 <avpx> 'tis a good one
20:19:25 <Cale> But it's likely that Text.Parsec imports Control.Monad.Reader somewhere
20:19:36 <Cale> and the instances are impossible to not export
20:20:18 <gadtfly> Well it's a cool thing, but it really screwed me up for a while trying to figure out how the hell something I did worked when it clearly shouldn't.  I thought my entire understanding of haskell and types was completely faulty.
20:21:29 <gadtfly> Is it really impossible not to export the modules you import?  So if I imported something that imported Data.List, all the list functions would be in scope?
20:22:00 <Cale> No
20:22:03 <Cale> Just the instances
20:22:43 <gadtfly> Well shit.  I feel like this is dangerous and should be more common knowledge.
20:23:03 <avpx> Definitely something I hadn't encountered before
20:24:59 <gadtfly> Especially with (->) e, because that works invisibly with normal function applications.
20:26:15 <parcs`> > execState ((>>) modify modify succ) 0
20:26:16 <lambdabot>   Ambiguous type variables `m', `s' in the constraint:
20:26:16 <lambdabot>    `Control.Monad.Stat...
20:26:57 <parcs`> meh, works better with IO:
20:27:24 <wavewave> hi
20:27:55 <parcs`> (>>) putStrLn putStrLn "foo" (foo gets printed one) vs liftM2 (>>) putStrLn putStrLn "foo" (foo gets printed twice)
20:28:45 <gadtfly> putStrLn "foo" >> putStrLn "foo", no?
20:28:58 <parcs`> what about that?
20:29:07 <lightquake> @type (>>) putStrLn putStrLn "foo"
20:29:08 <lambdabot> IO ()
20:29:12 <avpx> parcs`: My brain just asploded trying to understand that
20:29:34 <avpx> This is using the monad instance for (->) e?
20:29:54 <parcs`> yeah
20:29:55 <gadtfly> Definitely
20:30:06 <gadtfly> See, that's what I mean!
20:30:19 <gadtfly> That shit is implicitly in scope for lambdabot, apparently!
20:30:38 <ddarius> It's explicitly in scope for lambdabot.
20:30:50 <amosr> this is a strange question, but do any papers say how tedious plumbing a unique name supply through a (pure) compiler/transform is?
20:31:05 <gadtfly> ddarius: Explicitly where
20:31:07 <ddarius> amosr: Plenty say that.
20:32:03 <gadtfly> :t (>>) putStrLn putStrLn "foo"
20:32:04 <lambdabot> IO ()
20:32:24 <gadtfly> Should not work
20:32:26 <osfameron> "gadtfly" is an excellent nick!
20:32:39 <ddarius> gadtfly: In L.hs where it explicitly imports both Control.Monad.Reader and Control.Monad.Instances.
20:33:28 <gadtfly> Okay, I mean implicitly here, using lambdabot
20:34:16 <parcs`> m >>= f = \a -> f (m a) a; m >> n = m >>= const n = \a -> const n (m a) a = \a -> n a
20:35:03 <parcs`> so essentially "m >> n = n" for the (->) e monad. therefore (>>) putStrLn putStrLen "foo" is just putStrLn "foo"
20:38:51 <gadtfly> @pl foo xs = map (zip xs) . filter (isIsomorphic xs)
20:38:52 <lambdabot> foo = ap ((.) . map . zip) (filter . isIsomorphic)
20:39:37 <zzing> If I wanted to use a configuration library, is there any in particular that I should take a close look at?
20:40:46 <applicative_> > (>>) even odd 3
20:40:47 <lambdabot>   True
20:40:51 <mikeplus64> @pl foo xs ys = map (zip xs) (filter (isIsomorphic xs) ys)
20:40:52 <lambdabot> foo = ap ((.) . map . zip) (filter . isIsomorphic)
20:41:07 <mikeplus64> pl is smart
20:44:02 <amosr> ddarius: do you know any names/authors offhand? I can only find a functional pearl "on generating unique names"
20:50:27 <applicative_> gadtfly I think its because it imports Control.Applicative that parsec ends up with instance Monad ((->)e)
21:08:09 <ddarius> amosr: It sounds like you want a paper that solves the problem, not one that complains about it.
21:18:58 <amosr> ddarius: heh, well, not really. I just wanted to say "plumbing name supply can be quite tedious [cite] because X Y Z. we sidestep this by allowing named and anonymous (de bruijn) binders"
21:19:43 <amosr> ddarius: perhaps I'm cheating though because I'm looking for a paper to fit my pre-existing hypothesis :)
21:22:31 <amosr> oh, I guess if one solves it with de bruijn & named that'd be extra hunky dory. *searches*
21:25:02 <BoerJellema> Cale, anyway, surely record syntax does just that?
21:25:14 <Cale> BoerJellema: what?
21:25:56 <BoerJellema> Enabling different function to share the same name but be identitied by type signature?
21:26:33 <BoerJellema> The lookup functions, I mean.
21:26:58 <Cale> no
21:27:17 <Cale> The lookup functions are functions, and must have consistent types.
21:27:51 <Cale> (It's just syntax sugar and adds no power to the type system)
21:27:54 <ddarius> amosr: I imagine some of the GHC papers will have such grousing.
21:28:11 <ddarius> It's not too often when one implements a compiler purely functionally.
21:29:41 <Enigmagic> i don't write compilers often, but when i do i use dependent types.
21:31:31 <ddarius> s/use/prefer/
21:32:05 <Enigmagic> no, i use them up.
21:33:21 <Enigmagic> after we're done compiling ghc doesn't want them back.
21:34:09 * ddarius is not sure how Enigmagic is interpreting "prefer" as "borrow."
21:35:00 <Enigmagic> i'm not sure that i'm interpreting anything :-/
21:35:35 <shachaf> Enigmagic: Obviously not -- you're compiling.
21:36:24 <Enigmagic> that was my understanding too
21:38:25 <amosr> hmm, I think I'll just cite this functional pearl, which almost says "name supplies are awkward, we use unsafePerformIO"
21:38:51 <amiller> i'm confused about the syntax using TypeCompose
21:38:52 <amiller> data Trunk x = Tip | Bin x x
21:38:53 <amiller> instance Monad m => Functor (Trunk :. m) where fmap _ Tip = Tip
21:39:23 <amiller> or is there a better way of doing that? http://stackoverflow.com/questions/1827645/haskell-typeclass i'm not sure what to make of this post
21:40:00 <shachaf> Why are you making a type class? :-(
21:40:10 <shachaf> Anyway, (MVar []) is a kind error.
21:40:35 <amiller> (er that's not my stackoverflow post, that was where i found out about typecompose though)
21:41:09 <shachaf> Oh.
21:43:27 <ddarius> Trunk is a functor and any monad is a functor, and you don't really need a monad for this, and I'm sure TypeCompose already has a Functor instance for (:.), so you should just make a Functor instance for Trunk.
21:44:11 <shachaf> Right -- the point of TypeCompose is presumably to save you from having to write those instances by hand.
21:45:28 <amiller> yeah you're right, there is an instance for  (Functor f, Functor g) => Functor (f :. g)
21:46:20 <shachaf> Doesn't that conflict with the instance (Functor g, Functor f) => Functor (g :. f) ? :-)
22:15:06 <amiller> er, well that above example was unnecessary but i still haven't figured out how to handle this type syntax
22:15:08 <amiller> insertM :: Monad m => (Trunk :. m) a -> (Trunk :. m) a
22:15:08 <amiller> insertM Tip = Tip
22:15:34 <amiller> that has a pattern matching problem with the leftmost Tip, i think i need to add something to it
22:16:50 <ddarius> (:.) is a normal data type.
22:47:24 <amiller> hrm, even though (:.) is a normal data type, i don't see how to do case matching on value of type (Trunk :. m)
22:47:49 <amiller> there is no associated data constructor
22:47:57 <shachaf> Yes there is.
22:48:05 <shachaf> :i (:.)
22:49:32 <amiller> oh. O is a data constructor for (:.)
22:49:50 <amiller> and _also_ a type synonym for (:.)
22:50:19 <ion> Oooh
22:54:59 <zzo38> How to program in Haskell, a internet service serving multiple clients simultaneously, which must wait for data from all of them and allow them to interfere with each other?
22:58:53 <shachaf> What sort of interference are we talkin'?
22:59:30 <zzo38> I mean simply that the connections run in the same thread so that they can share data.
23:00:55 <ddarius> You don't need to run in the same thread to share data.
23:00:57 <shachaf> Things can share data without being run in the same thread.
23:03:44 <zzo38> But I intend to run in the same thread, so that, for example, a loop waits for data from any client, and then does something possible sending data to that and other client and then wait again, until it is finished.
23:04:49 <shachaf> You can do that without running in the same thread, presumably.
23:05:25 <ddarius> That describes an algorithm that does not service multiple clients simultaneously, but rather sequentially.
23:06:14 <zzo38> Well, yes, it is sequentially, I mean multiple clients are connected simultaneously; they don't receive data exactly simultaneously, but I mean any one can send data you don't know who to receive from.
23:07:25 <ddarius> So your requirement is reduced to a non-deterministic merge.
23:09:16 <zzo38> OK
23:09:49 <ddarius> You fork a thread waiting for each client and feed all the received requests into a single channel that is waited on by your loop.  You can, if you want, have an acknowledgement channel if you don't want the client thread to receive again until after the loop has gone through.
23:09:51 <zzo38> That still does not tell me what codes I need to make this internet service.
23:21:09 <zzo38> But what kind of functions and so on do I need to make it to listen and wait for each client? (Even note that some client might have to receive data even though it has not sent any data) And how do you make thread in Haskell to send a data to the other one? Is there no command to wait on multiple clients and continue when receiving from any one?
23:22:18 <shachaf> zzo38: The standard way to do that is to make one thread per client and have them all write data into a channel.
23:24:11 <zzo38> shachaf: OK, but what is a code to do that (including to listen for connections, create threads, send data, receive, etc)? I don't know very well how to write programs connecting to internet at all except PHP and shell scripts, and I don't know much at all about multithreaded programming.
23:24:47 <shachaf> zzo38: As far as concurrent Haskell code, JaffaCake1's slides are pretty nice.
23:25:06 <shachaf> zzo38: See 3,4,5 in http://community.haskell.org/~simonmar/slides/cadarache2012/
23:25:11 <ddarius> shachaf: Give me the codes!
23:25:22 <amiller> bah, i'm getting stuck at each step
23:25:24 <amiller> tip :: Algebra (Trunk :. m) a => a :< (Trunk :. m)
23:25:24 <amiller> tip = phi $ O Tip
23:25:29 <zzo38> OK I will look later, and see if it help.
23:25:37 <amiller> i earlier have tip :: Algebra (Trunk :. m) a => a :< (Trunk :. m); tip = phi $ O Tip
23:25:44 <amiller> er wrong paste
23:25:56 <amiller> this is what i meant: instance Algebra f m => Algebra f (m :< f) where phi x = phi (fmap value x) :< x
23:26:29 <shachaf> zzo38: #5 in particular has "the codes" you're looking for.
23:26:46 <zzo38> shachaf: OK, I will look at that later, thanks for telling me.
23:28:46 <amiller> i would expect the phi in the right hand side there to be from an instance of  Algebra (Trunk :. m) (a :< Trunk :. m) but the two (Trunk :. m)'s are not the same
23:29:29 <shachaf> :< is a very sad-looking type constructor.
23:29:35 <shachaf> Maybe that's why your code isn't working.
23:30:03 <amiller> i think it looks like the creeper from minecraf
23:41:06 * hackagebot ghc-vis 0.2 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.2 (DennisFelsing)
23:43:13 <tessier> What does it mean for a variable to not be "bound"?
23:43:19 <tessier> Is that just undefined?
23:43:47 <shachaf> Would you prefer "not in scope"?
23:43:49 * tessier is trying to understand combinators and the definition of a combinator seems to be a function with no free variables
23:43:59 <tessier> That would work too, I suppose.
23:44:11 <shachaf> Are you asking what "free" means?
23:44:16 <ddarius> A combinator is indeed a function with no free variables.
23:44:19 <tessier> schroedinbug: Yes
23:44:35 <tessier> er...
23:44:38 <shachaf> It's OK.
23:44:41 <tessier> shachaf: Yes
23:44:42 <shachaf> You don't need to say my name. I saw it.
23:44:46 <shachaf> :-(
23:44:51 * ddarius doesn't believe shachaf.
23:45:00 * tessier is also suspicious
23:45:14 <Lutin`> shachaf: I am also suspicious
23:45:26 <Lutin`> shachaf: In case you were wondering
23:45:55 <shachaf> Good to know.
23:46:06 <tessier> I think that's enough probable cause...
23:46:54 * tessier has been avoiding learning haskell partially due to the yak shaving problem: Already so many unsolved problems which could probably be addressed by the Python which I already know.
23:47:02 <tessier> But every once in a while I dip my toe in.
23:48:13 <shachaf> ddarius: How can a function have free variables?
23:48:24 <shachaf> I'd think that "having free variables" would be a property of an expression.
23:49:32 <ddarius> shachaf: True.
23:50:50 <Lutin`> You could say a function uses no free variables in it's definition
23:51:05 <Lutin`> Wait
23:51:07 * hackagebot ghc-vis 0.2.1 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.2.1 (DennisFelsing)
23:51:29 <shachaf> You could say a function uses no variables at all in its definition!
23:51:37 <Lutin`> Yeah
23:51:44 <tessier> Haskell involves so much nomenclature...
23:51:46 <ddarius> It is interesting to compare how defunctionalization, combinators, and closures handle representing higher order functions.
23:52:04 <ddarius> tessier: This is not Haskell-specific terminology.
23:52:32 <tessier> ddarius: True, but I didn't have to learn any of these things to be production in all of the various other languages I already know or have forgotten...
23:52:38 <ddarius> Python also has free and bound variables.  In fact, almost every language in existence has such a notion and this is a generally important concept in and outside of programming and computer science.
23:52:39 <Lutin`> I was reading an article on Java and switched back to this window with the wrong mindset
23:52:40 <tessier> s/production/productive/
23:52:42 <shachaf> tessier: You had to learn "not in scope" for Python, presumably.
23:52:47 <tessier> Indeed.
23:52:59 <shachaf> That's just as much nomenclature.
23:53:12 <tessier> Yes but that is nomenclature I have encountered before. :)
23:53:36 <ddarius> tessier: "Free" and "bound" are terms you should have encountered before.
23:53:48 <tessier> One of these days I'm just going to sit down with LYAH and figure it all out.
23:54:00 <typoclass> tessier: what were you reading when you came across the term combinator? i think it's often used to just mean a function that takes another function as a parameter
23:54:03 <tessier> declared and undeclared are how those things have been approached in my experience.
23:54:18 <shachaf> http://docs.python.org/reference/executionmodel.html -- "Names refer to objects. Names are introduced by name binding operations. Each occurrence of a name in the program text refers to the binding of that name established in the innermost function block containing the use."
23:54:28 <ddarius> tessier: I'm actually pretty sure that Python documentation uses the term "free" as well.
23:54:43 <shachaf> "If a name is bound in a block, it is a local variable of that block. If a name is bound at the module level, it is a global variable. (The variables of the module code block are local and global.) If a variable is used in a code block but not defined there, it is a free variable."
23:54:48 <shachaf> Note that analogies to Python are usually not the best way to learn Haskell.
23:54:54 <shachaf> These terms just happen to be very common.
23:55:18 <tessier> typoclass: http://newartisans.com/2012/08/parsing-with-haskell-and-attoparsec/ is where I encountered combinator. I've always been interested in parsing with haskell, even though I currently have no idea how to go about it. I'm impressed with the results others seem to be getting.
23:55:21 <shachaf> Where did you come across the term "free", anyway? I don't think it shows up in GHC error messages.
23:55:33 <shachaf> "combinator" is a weird word.
23:55:49 <ddarius> If there is any notion of scope, particularly nested scope, free and bound variables become important.  For example, quantifiers in e.g. first order logic also have a notion of free and bound variables and use those terms.m
23:55:56 <tessier> shachaf: In the definition of combinator
23:56:18 <ddarius> Unfortunately, many people use the word "combinator" in a fairly meaningless way.
23:56:20 <shachaf> I think you can pretend that "combinator" means "function".
23:56:39 <ddarius> It is rarely used in the technical sense.
23:56:52 <tessier> And yes, python analogies aren't particularly helpful and often lead me astray in haskell-land.
23:57:03 <shachaf> "A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments."
23:57:06 <shachaf> Is that the technical sense?
23:57:38 <ddarius> That's equivalent to the technical sense.
23:57:41 <shachaf> Isn't any lambda-calculus function a combinator in that sense?
23:57:49 <ddarius> No.
23:58:05 <ddarius> Though a combinator doesn't need to be higher order.
23:58:06 <shachaf> Assuming you allow S and K to be "previously-defined".
23:59:09 <typoclass> tessier: er, i don't think the blog post's using some technical meaning of the term. he just means "*>" and "<|>" and such, as in "(char 'u') <|> (char 'x')"
