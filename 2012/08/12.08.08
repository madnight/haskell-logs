00:00:07 <shachaf> Logic.
00:00:27 <mm_freak_> scry`: data Successive = forall a. Successive a (a -> a)
00:00:29 <scry`> well i mean in GHC :)
00:00:53 <mm_freak_> 'Successive x f' contains an existential type 'a'
00:01:14 <mm_freak_> this means that you have no information about 'a', but you have a value of that type as well as a function
00:02:03 <mm_freak_> data Movie = forall a. Movie { firstFrame :: a, nextFrame :: a -> a, frameImage :: a -> ByteString }
00:03:50 <frerich> Anybody from FH Wedel (Hamburg, Germany) here?
00:08:26 <\rs> lambdabot-4.2.3.2(Plugin.Log) doesn't build with ghc-7.4.2
00:10:36 <wagle> scratch that itch!  8)
00:20:42 <shachaf> Hmm, is there a channel for Accelerate?
00:21:23 <zzo38> Can you make a monad transformer    newtype Readself r m x = Readself { runReadself :: m r -> m x }; join (Readself f) = Readself $ \r -> f r >>= ($ (r <* f r)) . runReadself; lift = Readself . const;
00:21:56 <zzo38> Can you make a monad from a transformer as    data TransFree t x = TransPure x | TransFree (t (TransFree t) x); join (TransFree x) = TransFree (x >>= lift); return = TransPure;
00:40:21 <\rs> lambdabot(Plugin.Log) failed to build with ghc-7.4.2:  http://pastebin.ca/2178417
00:45:30 <shachaf> -- | Yield the first 'n' elements of the input vector. The vector must contain no more than 'n' elements.
00:46:44 <edwardk> ?
00:47:04 <opqdonut> heh
00:47:31 <opqdonut> edwardk: it probably should've said no _less_
00:47:47 <sp3ctum> that would make more sense, yes
00:48:03 <edwardk> was wondering where it was from, data.vector?
00:48:10 <shachaf> Accelerate
00:48:14 <edwardk> ah
00:48:38 * shachaf is trying to wrap head around this API.
00:48:41 <shachaf> It's a strange way to write code.
00:49:16 <shachaf> Maybe it would be easier if I was familiar with CUDA.
00:49:31 <shachaf> Also, if it had documentation. :-)
00:49:50 <edwardk> heh
00:52:53 <hiptobecubic> shachaf, cuda puts a lot of annoying restrictions on the way memory is used.
00:53:58 <edwardk> thats for sure
00:54:15 <edwardk> nowhere near as bad as it used to be though
00:55:03 <shachaf> hiptobecubic: Sure -- I'm not saying it's restrictions Accelerate invented to annoy people.
00:55:41 <shachaf> I've never done any GPU anything, though.
00:55:56 <edwardk> run away, while your sanity is still intact
00:57:06 <shachaf> edwardk: Too late. :-(
00:57:33 * shachaf has already gone crazy trying to do simple things.
01:19:03 <scry`> anyone know if you can get inf-haskell-mode to show type signatures like haskell-mode?
01:22:37 <shachaf> backpermute :: (Shape ix, Shape ix', Elt a) => Exp ix' -> (Exp ix' -> Exp ix) -> Acc (Array ix a) -> Acc (Array ix' a)
01:22:50 <shachaf> Documentation: "Backward permutation"
01:23:00 <sp3ctum> hehe
01:39:36 <jre2> what's the best option for running haskell on android?
01:44:36 <tew88> jre2: I was interested in this myself.  Short answer is: it'll be difficult.  For the longer answer, your question is addressed in detail on stackoverflow
01:50:50 <\rs> lambdabot(Plugin.Log) failed to build with ghc-7.4.2:  http://pastebin.ca/2178417
01:52:23 <mauke> maybe (fail "not found") return .
01:54:00 <adnam> in haskell-src-exts, RecDecl is defined as `RecDecl Name [([Name], BangType)]`, when does [Name] contain more than one element?
01:54:07 <edwardk> preflex: xseen nand`
01:54:07 <preflex>  nand` was last seen on freenode/#haskell-blah 4 hours, 29 minutes and 15 seconds ago, saying: sleep works
01:54:28 <edwardk> @tell nand` updated your pong game to add a little bit of english to the paddle and make the ai tunable
01:54:29 <lambdabot> Consider it noted.
01:54:32 <sopvop> oh noes it's `fail`, everybody run! (or runErrorT)
01:54:55 <benmachine> adnam: I believe you can do data RecordType = RT { field1, field2 :: Int }
01:55:03 <benmachine> adnam: and both will be Int fields
01:57:01 <adnam> benmachine: yeah, that's what i tried but I didn't manage to get a bug in my code from not handling the rest of the names with it :D but I'll dig into it some more
01:58:02 <benmachine> adnam: it's not very often used
01:58:17 <benmachine> but it probably wouldn't be very hard to expand it into an equivalent [(Name, BangType)]
01:59:23 <benmachine> something like [(n,t) | (x,t) <- xs, n <- x]
01:59:39 <benmachine> :t \xs -> [(n,t) | (x,t) <- xs, n <- x]
01:59:41 <lambdabot> forall t t1. [([t1], t)] -> [(t1, t)]
02:01:21 <mauke> :t concatMap ((uncurry . flip) (map . flip (,)))
02:01:23 <lambdabot> forall b a. [([a], b)] -> [(a, b)]
02:21:21 * mekeor waves =)
02:24:14 * Yuu-chan smiles :)
02:25:28 <shachaf> hi mekeor, Yuu-chan
02:26:22 <edwardk> hrmm, is there a way to make dependencies of an executable that is hidden behind a flag not show up in the build-dependencie on hackage?
02:26:27 <edwardk> it is quite misleading
02:26:45 <shachaf> What's the package?
02:26:49 <edwardk> lens
02:26:56 <shachaf> Should've known.
02:26:59 <edwardk> =)
02:27:18 <shachaf> Oh, you have an example executable?
02:27:28 <edwardk> yeah
02:27:57 <shachaf> What generates Hackage pages, anyway?
02:28:07 <shachaf> (No points for the answer "Hackage".)
02:28:11 <MostAwesomeDude> Hackage fairy, obviously.
02:28:33 <edwardk> hackage and haddock ;)
02:28:51 <shachaf> Is the code for that public?
02:29:13 <edwardk> should be
02:30:48 <edwardk> its kind of annoying that i have no way to test what it'll say except to upload another version
02:31:17 <Yuu-chan> @hoogle [a] -> Bool
02:31:18 <lambdabot> Prelude null :: [a] -> Bool
02:31:18 <lambdabot> Data.List null :: [a] -> Bool
02:31:18 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
02:31:29 <shachaf> Yes, that's a rare event.
02:32:28 <benmachine> edwardk: how about just not making the example executable installable? just include it with the source in an examples directory or something
02:32:41 <edwardk> thats what i had before hand
02:32:57 <edwardk> i was sick of going in there and having it piss all over the folder with .hi and .o and executable files
02:33:05 <benmachine> well, give it its own cabal file?
02:33:14 <edwardk> thats kinda what i'm leaning towards now
02:33:45 * benmachine switched to this tab to close the window on account of how it was distracting him from work, but then...
02:33:49 * benmachine silly
02:34:15 <shachaf> edwardk: Why not just runghc?
02:34:24 <edwardk> hrmmm
02:34:51 <edwardk> wonder if i can make it literate and put the bang path at the top
02:35:22 <shachaf> You don't even need to make it literate.
02:36:00 <edwardk> well if i do that then it can run itself
02:36:08 <shachaf> shachaf@carbon:~/q$ echo $'#!/usr/bin/env runghc\n\nmain = print 1' > foo && chmod +x foo && ./foo
02:36:11 <shachaf> 1
02:36:17 <edwardk> jut with the \begin{code} \encode{block}
02:36:27 <shachaf> GHC has a special case for files that start with #!
02:36:28 <edwardk> er end{code}
02:36:37 <edwardk> oh? neat
02:36:38 <shachaf> So you don't even need that, if you're just using GHC.
02:37:08 <edwardk> well, the thing is you still need to call runghc that way
02:37:16 <edwardk> rather than just executing the .lhs file
02:37:37 <shachaf> ?
02:38:57 <edwardk> i usuallly set up my Setup.lhs files to look like: https://github.com/ekmett/speculation/blob/master/Setup.lhs
02:39:08 <edwardk> so they can be run directly by someone who doesn't know about cabal, etc.
02:39:32 <shachaf> Right, but the same thing works without the lhs. :-)
02:39:40 <shachaf> See my command line above.
02:39:56 <shachaf> It might be reasonable to use lhs anyway, though -- I don't know if that's a standard Haskell behavior.
02:40:15 <shachaf> (By which I mean "works with, uh, Hugs?".)
02:41:08 <edwardk> hrmm that doesn't seem to be working
02:41:53 <edwardk> #!/usr/bin/env runghc  doesn't seem to be kicking off the pong example, worried its the ghci/opengl interaction issue on a mac
02:42:14 <shachaf> Blah, OpenGL interactions.
02:42:24 * shachaf remembers something similar with gtk2hs.
02:43:06 * hackagebot acid-state 0.6.6 - Add ACID guarantees to any serializable Haskell data structure. (DavidHimmelstrup)
02:43:31 <shachaf> Lemmih is alive?
02:44:56 <Lemmih> shachaf: Kinda.
02:45:24 <shachaf> hi mmelstrup
02:45:55 <Lemmih> Sup?
02:47:48 <edwardk> shachaf: just gave in and made a nested cabal project in the examples folder
02:48:05 <shachaf> edwardk: That works too.
02:48:12 <shachaf> That's how text does it.
02:57:07 <codertux> koala_man: ping
03:02:44 <edwardk> ok, packaged and pushed
03:03:07 * hackagebot lens 1.7.1 - Lenses, Folds and Traversals (EdwardKmett)
03:05:21 <quicksilver> edwardk: new package name?
03:10:05 <shachaf> quicksilver: lens /= data-lens
03:10:25 <shachaf> data-lens was just about, y'know, getters and setters and that sort of thing. lens is about taking over the world.
03:11:10 <Taneb> lens lets you refract light and make pretty patterns like rainbows and stuff
03:11:20 <Taneb> It also can improve your eyesight :)
03:11:34 <Taneb> And is useful for making telescopes and cameras etc.
03:11:56 <Taneb> On a more serious note, I may try to right a lens tutorial to help me understand it
03:16:25 <quicksilver> shachaf: yes, I gathered that now
03:17:31 <\rs> lambdabot-4.2.3.2(3) Plugin.Log doesn't work
03:22:19 <Franciman> hi all
03:22:33 <Franciman> can you guys tell my why this line doesn't typecheck
03:22:35 <Franciman> head.drop 1.dropWhile (~=="lolface") tags
03:22:39 <Franciman> ?
03:22:51 <fmap> \rs: do you have any errors to paste?
03:23:13 <Taneb> Franciman, what's ~==?
03:23:30 <Taneb> Also, try putting a $ inbetween e") and tags
03:23:36 <shachaf> Franciman: GHC can probably tell you why.
03:23:36 <fmap> Franciman: `dropWhile (~=="lolface") tags' isn't a function
03:23:44 <shachaf> Apparently, so can Taneb and fmap. :-)
03:23:48 <Franciman> tags is a list and (~=="lolface") is a predicate that returns true when an element in a list is equal to lolface
03:24:02 <shachaf> But in general please provide more details than "why doesn't this work?".
03:24:11 <Franciman> I was doing
03:24:13 <Franciman> :(
03:24:17 <shachaf> ~== is the same as /= ?
03:24:19 <\rs> fmap: http://pastebin.ca/2178417   this is my workaround: getChannel c = (readMS >>=) . (return.) . (fromJust.) . M.lookup $ c
03:24:39 <Franciman> shachaf, almost
03:24:42 <shachaf> Franciman: The best way to get help is to go to hpaste.org and paste in your code and the complete error message you get.
03:24:52 <Franciman> you can assume they're the same yes
03:24:55 <\rs> fmap: though i still cannot get Plugin.Log work
03:24:57 <shachaf> Er, equal to == , I mean.
03:25:18 <shachaf> Anyway, fmap answered your question and Taneb told you how to fix it. :-)
03:25:23 <fmap> \rs: well, paste says that's 4.2.3.2. did you try 4.2.3.3?
03:25:32 <Taneb> :-) indeed, shachaf
03:25:54 <\rs> fmap: 4.2.3.3 doesn't work either
03:26:01 <fmap> same error?
03:26:16 <\rs> fmap: Plugin.Log is not enabled in Modules.hs by default
03:26:22 <Franciman> thanks a lot, fixed, shachaf, yes next time I'll procede that way, thanks for the advice
03:26:50 <fmap> so lambdabot upload is broken
03:27:28 <fmap> nobdrais1ntone: ^
03:28:24 <\rs> fmap: this plugin (Plugin.Log) seems to be ignored for years since the last copyright info says 2005
03:29:19 <Taneb> Hmm
03:29:57 <Taneb> More forms of potential obfuscation would be useful, I think...
03:30:12 <Taneb> More, that is, than using pure, (<*>), and unsafeCoerce as SKI calculus
03:33:10 * hackagebot snaplet-hdbc 0.9.1 - HDBC snaplet for Snap Framework (JurrienStutterheim)
03:34:27 <Peaker> the "lens" TH side depends on KindSignatures? hmm...
03:37:32 <Peaker> @tell edwardk The auto-generated TH seems to depend on KindSignatures -- which is probably not needed.. My record is: "data P m a = P { v :: a, s :: a -> m () }"
03:37:32 <lambdabot> Consider it noted.
03:37:44 <kuribas> If it interests anyone, I have added birdtrack support to haskell-indentation.el.
03:37:48 <kuribas> https://github.com/kuribas/haskell-mode
03:39:51 <Peaker> what's birdtrack support?
03:40:08 <Taneb> Literate Haskell, I think
03:40:36 <amatsu> Silly question, but how does one show instances for a data type using ghci?
03:41:04 <Taneb> For simple things you can do "Data Foo a = Foo a a deriving (Show)"
03:41:28 <Jafet> :info
03:41:28 <quicksilver> amatsu: :info <typename>
03:41:32 <Lemmih> amatsu: :i <Type>
03:41:35 <Taneb> Oh
03:41:43 <Taneb> I thought you meant making Show instances
03:41:50 <Taneb> :/
03:42:00 <quicksilver> Peaker: birdtrack is >-style LHS. As opposed to \begin{code} style LHS.
03:42:10 <amatsu> Taneb, quicksilver, Lemmih, Jafet: thanks, guys!
03:42:17 <Taneb> :)
03:42:24 <Taneb> I completely misunderstood you, though
03:42:35 <Taneb> Everyone else deserves a thousand times the thanks of me
03:43:10 <Peaker> quicksilver, ah
03:43:29 <Jafet> A little known fact is that you can buy gratitude with cookies
03:43:46 <Taneb> Or milk duds
03:43:50 <Taneb> What even is a milk dud
03:44:24 <t7> am i missing a common pattern here:    (r, s) <- maybe (sign z privKey c g n h) return (getRS k)
03:44:40 <t7> the maybe _ return _
03:44:47 <t7> seems a bit suspect
03:45:36 <Jafet> aka >>=
03:45:37 <quicksilver> fromMaybe, I think
03:45:50 <quicksilver> someone did a nice table of the maybe/fromMaybe/>>= choices
03:45:52 <quicksilver> was it mauke?
03:45:55 <jre2> tew88: thanks
03:46:01 <t7> thats in IO monad do
03:46:04 <t7> (btw)
03:46:22 <t7> sign is an ... -> IO a
03:46:27 <Jafet> :t maybe
03:46:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:46:40 <Jafet> Ok, it's not >>=
03:47:01 <Peaker> \f -> maybe f id = fromMaybe     with return it does something else
03:47:10 <quicksilver> :t \x -> maybe f return
03:47:12 <lambdabot> forall t a (m :: * -> *). (SimpleReflect.FromExpr (m a), Monad m) => t -> Maybe a -> m a
03:47:14 <Peaker> @type \f -> maybe f return
03:47:15 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> Maybe a -> m a
03:47:31 <Jafet> @hoogle m a -> Maybe a -> m a
03:47:32 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
03:47:33 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
03:47:33 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
03:47:33 <Taneb> @pl maybe f return
03:47:34 <lambdabot> maybe f return
03:47:44 <Jafet> Ok, just write it
03:48:10 <hpaste> t7 pasted “context” at http://hpaste.org/72768
03:49:47 <kuribas> Has anyone used mmm-mode succesfully?
03:49:52 <quicksilver> one of the haskell idioms that arouses the strongest and yet most irrational disklike is the "foo = short_expr thingOnlyUsedOnce where thingOnlyUsedOnce = .....
03:50:19 <Peaker> quicksilver, if "thingOnlyUsedOnce" has a useful descriptive name, it could be ok
03:50:31 <quicksilver> I admitted it was irrational :)
03:50:33 <Jafet> k <- head . catMaybes . map getRS <$> randomRIOs (1, n-1)
03:50:49 <Jafet> I'm not sure if that idiom is disklike.
03:50:50 <Peaker> Haskell code tends to have less useful names though, due to cultural norms and the typical genericness
03:50:54 <Taneb> kuribas, what's mmm-mode?
03:51:01 <t7> quicksilver: i getRS isnt short
03:51:04 <quicksilver> kuribas: briefly, but I never stuck with it.
03:51:07 <t7> :)
03:51:09 <Jafet> @hoogle randomRIOs
03:51:10 <lambdabot> No results found
03:51:23 <kuribas> Taneb: multi major mode for emacs.
03:51:37 <kuribas> Taneb: For example combining LaTex mode with haskell-mode
03:51:38 <Taneb> Hah, yeah, things like emacs scare me for no good reason
03:51:53 <Jafet> multi major sounds like confusion waiting to happen
03:53:22 <kuribas> Well, if it works, it would be pretty cool.
03:55:04 <Mandarin> What can the prelude function const be used for?
03:55:13 <Mandarin> const 1 2
03:55:17 <Taneb> :t fmap (const ())
03:55:18 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ()
03:56:29 <quicksilver> > map (const "rainbow") [1,2,3,4,5,12]
03:56:30 <lambdabot>   ["rainbow","rainbow","rainbow","rainbow","rainbow","rainbow"]
03:56:37 <shachaf> > zipWith const "hello there" "abcde"
03:56:38 <lambdabot>   "hello"
03:57:33 <Taneb> > ap (ap (const ap) const) (ap (ap (const ap) const) id) (+ 1) 0
03:57:34 <lambdabot>   3
03:58:14 <Taneb> > const <$> "hello " <*> "abc"
03:58:15 <lambdabot>   "hhheeellllllooo   "
03:59:36 <Taneb> Trivia: const can, in some places, be replaced by pure or return
04:06:09 <sopvop> So, I've envisioned `BiDirectional a b = BiDir (a -> b) (b -> a)`  which is instance of Control.Category. So, Is there anything by edwardk already there?
04:06:28 <dmwit> yes =)
04:07:21 <sopvop> which package?
04:07:41 <shachaf> It's often called "Iso".
04:07:47 <dmwit> http://hackage.haskell.org/packages/archive/groupoids/3.0/doc/html/Data-Isomorphism.html
04:07:55 <shachaf> "lens" has it (of course!). A bunch of others do as well.
04:08:11 <shachaf> Oh, "lens" doesn't export it.
04:08:12 <dmwit> And yes, there's an Isomorphic class and an Isomorphism type in lens.
04:08:19 <shachaf> Wait, it does.
04:08:46 <dmwit> http://hackage.haskell.org/packages/archive/lens/1.6/doc/html/Control-Lens-Iso.html
04:09:14 <shachaf> lens 1.6? Isn't that way deprecated by now?
04:09:25 <Taneb> Is there anyone other than edwardk doing the theoretical stuff?
04:10:03 <Jafet> I thought edwardk is doing the practical stuff
04:10:06 * sopvop today have learned: If you envision something clever, edwardk already did it! And better than you.
04:10:07 <Jafet> Like writing code
04:10:31 <dmwit> shachaf: probably, but the newer versions don't have doc links yet =)
04:10:40 <dmwit> s/probably/maybe/
04:21:20 <nobdrais1ntone> > <fmap> so lambdabot upload is broken
04:21:21 <lambdabot>   <no location info>: parse error on input `<'
04:21:23 <nobdrais1ntone> Why?
04:22:46 <hpaste> t7 pasted “Elliptic curve signatures :D” at http://hpaste.org/72769
04:24:30 <t7> oh bummer i got a warning
04:24:40 * t7 hands in his haskell card
04:28:16 <Botje> t7: all we have left are ruby and visual basic cards. better trade up soon!
04:40:32 <mroman> @quickcheck f == f
04:40:33 <lambdabot> Unknown command, try @list
04:40:46 <mroman> @check f == f
04:40:47 <lambdabot>   Add a type signature
04:41:48 <mroman> @check \f xs -> (map f xs) == (map f xs)
04:41:49 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
04:41:49 <lambdabot>    arising from a use of `...
04:42:06 <mroman> :(
04:42:11 <Botje> @check f == f where types = f :: Int
04:42:11 <lambdabot>   Parse error at "where" (column 8)
04:42:14 <Botje> oh, boo.
04:42:24 <Botje> that's how you'd solve it normally.
04:42:27 <mauke> I don't think that would typecheck anyway
04:42:32 <mauke> > f :: Int
04:42:33 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Types.Int)
04:42:34 <lambdabot>    arising from a us...
04:42:53 <Botje> damn you Expr!
04:43:20 <mroman> @check \xs -> (map reverse xs) == (map reverse xs)
04:43:22 <lambdabot>   "OK, passed 500 tests."
04:44:30 <t7> @check \xs -> xs == reverse xs
04:44:32 <lambdabot>   "OK, passed 500 tests."
04:45:31 <mroman> @check \xs -> (map id xs) == ((\f xss@(x:_)->f x:tail(scanl1(\_ c->f c)xss))id xs)
04:45:32 <lambdabot>   "*Exception: <interactive>:3:39-82: Non-exhaustive patterns in lambda
04:46:01 <Nereid> @check \xs -> xs == reverse xs :: [Int] -> Bool
04:46:02 <lambdabot>   Couldn't match expected type `[GHC.Types.Int] -> GHC.Bool.Bool'
04:46:14 <Nereid> @check (\xs -> xs == reverse xs) :: [Int] -> Bool
04:46:15 <lambdabot>   Couldn't match expected type `[GHC.Types.Int] -> GHC.Bool.Bool'
04:46:18 <Nereid> eh
04:46:19 <mroman> ^- that doesn't seem right @non-exhaustive patterns
04:46:28 <mauke> mroman: why?
04:46:33 <mroman> @check (\xs -> (map id xs) == ((\f xss@(x:_)->f x:tail(scanl1(\_ c->f c)xss))id xs))
04:46:34 <lambdabot>   "*Exception: <interactive>:3:40-83: Non-exhaustive patterns in lambda
04:46:40 <Nereid> mroman: what if xss = []
04:46:59 <mroman> Yeah. Then it won't work.
04:49:06 <mroman> although I had expected 499 test passed or so.
04:49:42 <mroman> @check \xs -> head xs == (reverse [head xs])
04:49:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
04:50:08 <mroman> eh
04:50:31 <mroman> @check \xs -> [head xs] == (reverse [head xs])
04:50:32 <lambdabot>   "*Exception: Prelude.head: empty list
04:50:36 <mroman> Yeah ok.
04:50:42 <mroman> It can't catch errors?
04:50:44 <t7> whats the compiler flag for universe polymorphic dependent types?
04:51:02 <t7> language pragma*
04:51:16 <mroman> Or just lambdabot can't.
04:51:25 <mroman> I might want to test non-total functions.
04:51:27 <zhulikas> @check id (==)
04:51:29 <lambdabot>   "OK, passed 500 tests."
04:51:51 <quicksilver> mroman: catching pure exceptions is yuck.
04:52:15 <quicksilver> (I do agree this is something you'd ideally like to test, though)
04:58:09 <t7> :t catch
04:58:11 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
04:58:31 <t7> quicksilver: how do you catch pure ones?
04:58:47 <quicksilver> I don't remember.
04:58:51 <quicksilver> I never do it.
04:59:04 <shachaf> Pure as in error?
04:59:05 <int-e> t7: evaluate + catch from Control.Exception
04:59:08 <quicksilver> there is some incantation with some version of Control.Exception which will catch them
04:59:16 <quicksilver> or you can use 'spoon', which is obscene.
04:59:19 <int-e> @type Control.Exception.catch
04:59:20 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
04:59:24 <t7> why did neil stop working on totality checking :(
05:01:20 <shachaf> try is nicer than catch for some things.
05:01:50 <shachaf> It's funny that in Haskell try and catch are two functions that accomplish the same thing, as opposed to things that you use together.
05:11:23 <sopvop> is there a function to make single element list besides (:[]) ?
05:11:32 <mauke> return
05:11:54 <sopvop> oh
05:13:19 <sipa> :t pure
05:13:20 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
05:13:30 <sipa> > pure 1 :: [Int]
05:13:31 <lambdabot>   [1]
05:26:00 <pchiusano> I feel like I have heard somewhere that in Haskell, fmap id == id implies fmap (f. g) == fmap f . fmap g, because all functors are strong or something...
05:26:21 <pchiusano> anyone have a proof of that, or a pointer to where that is explained
05:26:30 <hpc> pchiusano: it's not an implies
05:26:41 <hpc> they're two laws both required by Functor
05:27:05 <quicksilver> no, pchiusano was right.
05:27:06 <pchiusano> hpc: yes, but I think the second law is a free theorem
05:27:12 <hpc> oh
05:27:15 <pchiusano> guaranteed by parametricity given the first
05:27:17 <hpc> :t fmap
05:27:18 <quicksilver> the second law does come for free
05:27:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:27:21 <hpc> huh
05:27:26 <quicksilver> precisely, because of parametricity
05:27:31 <pchiusano> quicksilver: can you explain though
05:27:35 <quicksilver> nope :)
05:27:50 <quicksilver> I can only suggest you read one of theorems for free papers
05:27:58 <quicksilver> but I can't explain it confidently and concisely
05:28:03 <quicksilver> in an IRC channel :)
05:28:13 <pchiusano> quicksilver: okay fair enough :)
05:28:41 <t7> > 100 ^ 3
05:28:43 <lambdabot>   1000000
05:28:47 <t7> wut
05:28:55 <Botje> ^ is not xor.
05:29:08 <Botje> > 100 `Data.Bits.xor` 3
05:29:10 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:29:10 <lambdabot>    `Data.Bits.Bits a'
05:29:10 <lambdabot>      a...
05:29:15 <Botje> > 100 `Data.Bits.xor` 3 :: Int
05:29:17 <lambdabot>   103
05:29:56 <t7> "e.g. a 4 bit number 1101 can be represented by polynomial as x&3 + x^2 + 1
05:30:38 <Botje> well, yes
05:30:42 <sipa> x^3 + x^2 + 1
05:30:42 <Botje> if you let x = 2 :)
05:30:48 <sipa> Botje: no
05:30:58 <mietek> When running a test suite for lifted-base, cabal tells me "1 of 1 test suites (1 of 1 test cases) passed.", but the actual test suite log contains 42 test cases
05:31:07 <mietek> A bug?
05:32:00 <quicksilver> you can set x=2 to get the standard evaluation, but you might also manipulate the polynomial algebraically for some purposes.
05:32:06 <quicksilver> no idea what t7's context is.
05:32:28 <quicksilver> http://www.dkrypt.com/home/ecc apparently
05:33:45 <t7> theres some plagiarism going on here
05:34:41 <t7> oh its just the webpage for the paper i printed out
05:35:20 <t7> does overloaded strings not work in ghci
05:38:30 <t7> can i calculate the order of an elliptic curve in a reasonable amount of time?
05:38:59 <shachaf> pchiusano: Do you allow seq on functions?
05:39:03 <Taneb> Define reasonable.
05:39:19 <shachaf> Or is that just generally disallowed when talking about parametricity? :-)
05:39:22 <Taneb> Also define elliptic curve, this isn't my area of expertise.
05:40:01 <pchiusano> shachaf: does the presence of `seq` affect whether it is a free theorem?
05:40:48 <shachaf> If you have seq you can write a Functor instance that satisfies fmap id = id but not fmap (f.g) = fmap f . fmap g
05:41:34 <shachaf> (Just by seqing the function before returning a value.)
05:42:22 <t7> is there a binary search function in the platform?
05:42:28 <shachaf> E.g. data Id x = Id x; instance Functor Id where fmap !f (Id x) = Id (f x)
05:42:37 <shachaf> t7: Binary search on what?
05:42:43 <t7> generic
05:42:46 <t7> lists
05:42:55 <shachaf> Binary search on lists is rarely a sensible operation.
05:42:57 <t7> or vector, w/e
05:43:01 <shachaf> Not never, but usually not what you want.
05:43:26 <sipa> lookup key (Set.fromAscList l) ?
05:43:55 <pchiusano> shachaf: interesting, can you give an example of such a functor instance
05:44:12 <shachaf> Set would be the natural way to do that sort of thing, yes. :-)
05:44:16 <sipa> it's O(n) that way, but a direct binary search on lists isn't better than O(n)
05:44:23 <zhulikas> any thoughts on controlling GPIO on Haskell?
05:44:26 <shachaf> pchiusano: The functor I gave above does it.
05:45:14 <zhulikas> I wonder how low-level can I actually reach with Haskell
05:45:36 <Botje> if you can teach the runtime about volatile pointers, sure
05:45:47 <t7> sipa on vector it should be O(log n)
05:45:49 <t7> i think
05:46:53 <shachaf> pchiusano: In particular fmap (const x . undefined) /= fmap (const x) . fmap undefined
05:48:00 <pchiusano> shachaf: ah, I see
05:48:11 <zhulikas> https://github.com/zouppen/radiation/blob/master/GpioAccess.hs
05:48:13 <quicksilver> shachaf: If I'm not mistaken, the laws don't hold for seq anyway
05:48:14 <zhulikas> this is lovely!
05:48:20 <quicksilver> even for existing "well behaveD" instances
05:48:22 <pchiusano> shachaf: though you had to use bottom as well, not just seq
05:48:36 * hackagebot spatial-math 0.1.5 - 3d math including quaternions/euler angles/dcms and utility functions (GregHorn)
05:49:33 <jaxtr> ahh it's a wonderful day
05:49:34 <shachaf> pchiusano: Right.
05:49:52 <shachaf> pchiusano: This thread is probably relevant: http://www.haskell.org/pipermail/haskell-cafe/2010-January/071631.html
05:50:48 <shachaf> In particular e.g. http://www.haskell.org/pipermail/haskell-cafe/2010-January/071636.html
05:51:03 <shachaf> pchiusano: seq without bottom isn't very interesting.
05:51:26 <pchiusano> shachaf: ah, that is a great link, thank you
05:51:27 <shachaf> (It only has an operational meaning, that is. If that.)
05:51:45 <shachaf> ddarius saves the day!
05:52:25 <pchiusano> yes, he has the proof i was looking for here: http://www.haskell.org/pipermail/haskell-cafe/2010-January/071636.html
05:53:34 <mikeplus64> anyone have a quick example usage of gmapM/gmapQ/gfoldl/... ?
05:53:47 <mikeplus64> (or Data functions in general really)
05:54:12 <shachaf> mikeplus64: The SYB paper/slides are probably a good introduction.
05:54:18 * shachaf ought to goto sleep;
05:54:52 <Taneb> shachaf, sleeping means that they can see you and you can't see them
05:55:20 <mikeplus64> shachaf: yeah, the paper is fairly dense for a measily haskeller like me though
05:55:48 <shachaf> mikeplus64: SPJ's slides were pretty introductory.
05:55:55 <pshr> Hi, I have some text which I got when I ran arp -an using readProcess now I need to run some thing similar to that of grep "macaddr" on the retrieved text ? Is there any thing similar to grep ?
05:56:29 <shachaf> mikeplus64: https://docs.google.com/viewer?url=http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/Boilerplate%20v3.ppt
05:56:34 <mikeplus64> shachaf: i never looked (i will now though), i suppose i'm biased against ppt :)
05:57:09 <memerase> Anyone here that would actually use a webapp irc client(coded in haskell, extensible in fortran)?
05:57:11 <shachaf> mikeplus64: That's why I put the docs.google.com/viewer?url= in front!
05:57:21 <mikeplus64> shachaf: you're a hero
05:57:37 <mikeplus64> (google gets no credit)
05:58:46 <shachaf> mikeplus64: Anyway, those slides are complete with an introduction to how type classes are implemented and everything. At worst you'll learn something.
05:58:50 * shachaf now >>= sleep
05:59:05 <mikeplus64>  haha, alright
06:11:28 <memerase> Anyone here that would actually use a webapp irc client(coded in haskell, extensible in fortran)?
06:12:07 <frosch03> if it is usable without a mouse :)
06:12:40 <memerase> maybe
06:14:58 <mikeg> memerase: IMO the perfect IRC client would use a bouncer to write log files, and a Webapp reads them to give unlimited playback history
06:15:50 <valtih> I can interpret a→(a→a) as 'given a returns a function' but does (a→a)→a has interpretation?
06:16:02 <Botje> given a function a -> a, return an a
06:16:14 <Botje> g f = f 3, for example.
06:16:24 <valtih> but function needs an argument to return a
06:16:37 <tdammers> valtih: not necessarily, no
06:16:55 <tdammers> let g f = f 3 -- does not need an argument
06:17:22 <memerase> > let g f = sum $ map f [1,2,3] in g (+1)
06:17:24 <lambdabot>   9
06:17:33 <valtih> it is a kind of function with embedded argument?
06:17:50 <memerase> hardcoded arg?
06:18:16 <mikeg> There's one way to write it without an embedded argument
06:18:27 <mikeg> :t let x = f x in x
06:18:29 <lambdabot> forall t. (Show t, SimpleReflect.FromExpr t) => t
06:18:37 * hackagebot List 0.4.3 - List monad transformer and class (YairChuchem)
06:18:48 <mikeg> :t \f -> let x = f x in x
06:18:49 <lambdabot> forall t. (t -> t) -> t
06:18:56 <tdammers> in other words, you can use a closure to get the missing argument into the function without hardcoding anything
06:21:22 <roconnor> which haskell webserver supports HTTP auth?
06:21:37 <mikeplus64> i thought they all did
06:21:43 <roconnor> maybe
06:21:44 <mikeplus64> well, snap, happstack and yesod anyway
06:21:49 <roconnor> thanks
06:21:50 <mikeplus64> i don't know about others
06:22:02 <roconnor> although that doesn't help me pick one :D
06:23:40 <mikeplus64> personally i like snap
06:23:54 <roconnor> :)
06:24:39 <mikeplus64> yesod is very heavy weight with boilerplate and stuff, happstack seems nice though
06:25:36 <luite> mikeplus64: meh i disagree, a basic yesod site with a single page is 10 lines with routing
06:25:38 <parcs`> happstack has a great tutorial
06:26:01 <sopvop> So, using snap I barely write any snap specific code. Means snap is good.
06:26:30 <pshr> I have the following string "? (10.48.81.147) at 0:50:56:24:41:27 on en0 ifscope [ethernet]" how do I get the value which is inside the parenthesis in haskell ?
06:26:55 <Botje> i'd say a regular expression
06:27:02 <DrTeggy> "10.48.81.147"
06:27:35 <ocharles> it's tricky picking a haskell web app framework, cause they all kick ass
06:28:10 <pshr> Botje: DrTeggy how exactly to that I am beginner
06:28:31 <mikeplus64> > words "? (10.48.81.147) at 0:50:56:24:41:27 on en0 ifscope [ethernet]"
06:28:33 <lambdabot>   ["?","(10.48.81.147)","at","0:50:56:24:41:27","on","en0","ifscope","[ethern...
06:28:38 <mikeplus64> > words "? (10.48.81.147) at 0:50:56:24:41:27 on en0 ifscope [ethernet]" !! 1
06:28:40 <lambdabot>   "(10.48.81.147)"
06:28:48 <Aune> So Im trying to install SDL-image, but it fails. The messages that seems important are: configure:
06:29:01 <Aune>  WARNING: unrecognized options: --with-compiler, --with-gcc
06:29:06 <mikeplus64> > words init . drop 1 $ "? (10.48.81.147) at 0:50:56:24:41:27 on en0 ifscope [ethernet]" !! 1
06:29:08 <lambdabot>   Couldn't match expected type `GHC.Base.String'
06:29:08 <lambdabot>         against inferred typ...
06:29:19 <Aune> and : "checking whether the C compiler works... no"
06:29:31 <roconnor> > init . drop1 $ words "? (10.48.81.147) at 0:50:56:24:41:27 on en0 ifscope [ethernet]" !! 1
06:29:32 <Aune> any idea how I can fix this?
06:29:33 <lambdabot>   Not in scope: `drop1'
06:29:33 <mikeplus64> Aune: do you have gcc installed
06:29:39 <Aune> it says so
06:29:44 <parcs`> Aune: osx?
06:29:45 <roconnor> > init . drop 1 $ words "? (10.48.81.147) at 0:50:56:24:41:27 on en0 ifscope [ethernet]" !! 1
06:29:47 <lambdabot>   "10.48.81.147"
06:30:01 <mikeplus64> pshr: 6
06:30:03 <mikeplus64> 6*
06:30:05 <Aune>  which gcc =>  /usr/bin/gcc
06:30:07 <mikeplus64> ^* damnit
06:30:18 <Aune> no, ubuntu
06:30:31 <parcs`> why use drop 1 in conjunction with init?
06:30:37 <parcs`> might as well use tail
06:30:54 <nus> > take 12 . drop 3  "? (10.48.81.147) at 0:50:56:24:41:27 on en0 ifscope [ethernet]"
06:30:55 <lambdabot>   Couldn't match expected type `[a]'
06:30:56 <lambdabot>         against inferred type `GHC.Types...
06:30:56 <mikeplus64> parcs`: because we all have brainfarts every now and then on functions we rarely use
06:31:03 <nus> > take 12 $  drop 3  "? (10.48.81.147) at 0:50:56:24:41:27 on en0 ifscope [ethernet]"
06:31:05 <lambdabot>   "10.48.81.147"
06:31:08 <nus> :-P (-;
06:31:58 <parcs`> > (zipWith const <*> drop 1) . drop 1 $ words "? (10.48.81.147) at 0:50:56:24:41:27 on en0 ifscope [ethernet]" !! 1
06:32:00 <lambdabot>   "10.48.81.147"
06:32:13 <pshr> Thanks guys :)
06:32:15 <Aune> Seems like someone has had the same problem: http://hpaste.org/71366
06:32:35 <mekeor> pshr: no problem :)
06:32:35 <parcs`> Aune: what os?
06:32:43 <parcs`> oh, ubuntu
06:32:53 <parcs`> Aune: do you have 'build-essentials' installed
06:32:59 <mikeplus64> Aune: i'm not sure that's a cabal or SDL-image problem, maybe as in #ubuntu
06:33:02 <mikeplus64> and that
06:33:04 <mikeplus64> lol
06:33:20 <Aune> parcs`, ubuntu
06:34:30 <parcs`> Aune: also make sure youv' installed the appropriate dev libraries
06:34:37 <mekeor> parcs`: just in order to say it one more time: ubuntu.
06:34:45 <parcs`> libsdl1.2-image-dev, etc
06:35:19 <t7> ubuntu; soon with steam
06:35:30 <Aune> ok, I will go through all the packages and then rewume in #ubuntu
06:35:37 <Aune> *resume
06:35:43 <strg> normally ./configure uses some short piece of C code to see if the compiler works. Maybe config.log can shed light on the error.
06:35:58 <Aune> where is confog.log?
06:36:28 <strg> should be in the directory where you called ./configure
06:53:38 * hackagebot hamlet 1.1.0.1 - Haml-like template files that are compile-time checked (MichaelSnoyman)
06:57:35 <memerase> all those nice abbrevs or not so obvious in your own code when you come back to it 2 months later...
06:59:15 <Mandarin> that comment made me think about the story of babylon, where god created different languages so we couldn't cooperate anymore. Maybe he made diffrent abbrevations while at it
07:00:20 <mietek> t7: ghci -XOverloadedStrings
07:07:25 <kuribas> A good argument for literate programming...
07:10:41 <t7> is there a bytestream class
07:11:01 <t7> for all types of bytestream? lazy strict etc
07:11:12 <nand`> strict stream?
07:11:12 <lambdabot> nand`: You have 1 new message. '/msg lambdabot @messages' to read it.
07:11:26 <t7> bytestring*
07:11:35 <nand`> oh
07:11:53 <nand`> I don't see why you wouldn't just use lazy bytestrings, which are essentially just lists of strict bytestrings
07:12:12 <t7> well not everyone on hackage thinks that way
07:12:28 <t7> i prefer lazy by default too
07:12:45 <nand`> I meant for your streams
07:12:47 <nand`> not in general
07:13:54 <edwardk> heya nand
07:13:55 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
07:15:19 <nand`> edwardk: hi
07:15:32 <edwardk> @tell Peaker hrmm. you don't have anything in there that fixes the kind? perhaps it got set to a KindedB by the monomorphization pass
07:15:33 <lambdabot> Consider it noted.
07:15:48 <edwardk> nand`: did you try the updated pong?
07:15:58 <nand`> I haven't, still reading the commits
07:16:27 <edwardk> i added english to the paddle, sped it up a little, and made the ai adjust based on whether or not it was winning to rubberband it a bit
07:16:34 <Spockz_> is there an official publication for the Haskell Language Report?
07:16:49 <nand`> edwardk: sounds neat, but less silly :P
07:17:15 <Spockz_> ah probably it is this one: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.179.2870
07:17:31 <edwardk> basically the ai difficulty is the ratio between the ball's current position and its actual destination that the paddle goes to, and it assumes you'll put no english on regardless
07:17:41 <nand`> ah, so it's just a good/bad switch depending on who has more points?
07:17:43 <edwardk> so the paddle does _some_ tracking
07:17:56 <edwardk> rather than just sit there like a dick
07:18:42 <edwardk> this has the consequence that it looks like its trying to spin the ball, because of your 'it only moves if it needs to get more than a third of the paddle under the ball' trick, it deliberately tries to put english on the ball ;)
07:19:42 <nand`> oh nice, you added that
07:19:45 <edwardk> pretty much, the new 'good' is still beatable, as the amount of english you can put on the ball makes it possible to get past it
07:21:40 <fmap> nobdrais1ntone: some plugin doesn't build, see discussion
07:21:52 <edwardk> i could have done a more physically accurate update, preserving a vector length, etc. but this one encourages good pong style and plays more like the original
07:22:15 <nand`> agh, it already 3-0'd me
07:22:28 <edwardk> heh
07:22:55 <edwardk> i definitely feels more 'active'
07:22:57 <edwardk> er it
07:22:58 <nand`> yes
07:24:07 <nand`> edwardk: re: preserving vector length maybe an iso lens could be constructed between x/y and angle/magnitude
07:24:21 <edwardk> true
07:24:32 <nand`> but then calculating which way to scale the angle may be more involved
07:26:10 <edwardk> yeah i had it written but it was uglier and less demonstrative
07:28:53 <nand`> one consequence of this method is that you can slow the ball down significantly by hitting it on the ‘opposite’ end of where it's going
07:28:57 <nand`> but I guess that's more accurate
07:29:37 <nand`> edwardk: I guess the next step would be building a networked pong via haskell-arcade?
07:29:42 <nand`> prolly as a separate project
07:29:42 <edwardk> =)
07:30:12 <frerich> nand`: It would be great if you could have a simple physics model including friction, so you could do banana shots.
07:31:17 <nand`> while we're at it we could add gravitational holes and make the playing field hyperbolic :)
07:33:02 <edwardk> well, adding gravity to the ball makes a fun game ;)
07:33:16 <edwardk> can even put a net in ;)
07:33:24 <nand`> ‘powerups’ in general could be fun
07:33:38 <nand`> like, wider paddle, or slow motion
07:33:51 <t7> whats the easiest way to read bytes as Integer
07:34:01 <t7> Binary?
07:34:03 <nand`> or adding gravity to your paddle :)
07:34:43 <nand`> t7: probably the Get monad or similar
07:35:05 <t7> i guess i will have to put a size tag infront of the number
07:35:20 * t7 cant find the instance for Binary Int
07:35:31 <edwardk> if i were to change anything i'd probably change the up down movement to speeding up and slowing down the paddle, that way you _can_ catch the faster balls
07:35:46 * t7 means Get
07:36:12 <edwardk> t7: read a platform specific size and convert it with fromIntegral
07:36:22 <quicksilver> t7: if you don't care about the precise format, you can use the binary instance for Integer
07:36:25 <edwardk> Int varies from machine to machine
07:36:28 <quicksilver> it does "something sensible"
07:36:50 <nand`> t7: what I did for p2p-chat was using a base64-encoded [Word8] for arbitrary integers
07:36:53 <nand`> with specified order
07:37:01 <quicksilver> if you need to match some precise format then you can use the Get primitives to read the bytes out as appropriate.
07:38:00 <nand`> get :: Get Integer -- should work
07:39:07 <memerase> @hoogle SOAP
07:39:09 <lambdabot> No results found
07:39:14 <memerase> @hoogle soap
07:39:15 <lambdabot> No results found
07:39:18 <memerase> srsly?
07:39:24 <memerase> @hoogle s
07:39:25 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
07:39:25 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
07:39:25 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
07:39:34 <memerase> @hackage SOAP
07:39:35 <lambdabot> http://hackage.haskell.org/package/SOAP
07:41:44 <t7> wikipedia doesnt give the endian-ness of ECDSA :(
07:43:06 <otters> I hear SOAP is frowned upon
07:43:29 <Palmik> Hmm, why are instances for associated data types marked as "orphaned" even though the instance (of the type class) is defined in the same file as the instance (of the data family), but the data type that has the data family instance is declared in different module. I would understand the data family instance being orphaned, but why also the instances for the associated type?
07:44:08 <memerase> otters: which is why they are updating to REST but it isnt done yet so SOAP is what i need
07:46:08 <otters> so use a different langugae
07:46:10 <otters> language
07:46:24 <memerase> i have, i wanted to do it in haskell tpop
07:46:58 <Palmik> Hmm, also deriving Typeable for associated data types results in overlapping instances.
07:47:10 <quicksilver> memerase: neither @hoogle nor @hackage is a way to search for haskell packages
07:47:37 <quicksilver> memerase: the only SOAP tool I've heard of is HAIFA which I think is dormant or dead project though
07:48:14 <sm> doesn't hayoo include all packages, including their names
07:48:15 <sm> ?
07:48:34 <quicksilver> sm: no.
07:48:53 <sm> some large subset of hackage from some date in the past, then ?
07:49:32 <quicksilver> I think it contains everything on hackage, sm
07:49:41 <quicksilver> but there is plenty of haskell not on hackage.
07:49:58 <sm> ok, that's what I meant
07:50:01 <quicksilver> (haifa, for example, is not on hackage but it certainly exists)
07:50:24 <sm> no disrespect things not on hackage, but usually I don't care about those as much
07:50:29 <memerase> why isnt this possible:
07:50:45 <memerase> > let f = sum $ catMaybes in f [Just 6, Just 7]
07:50:46 <lambdabot>   Couldn't match expected type `[a]'
07:50:47 <lambdabot>         against inferred type `[Data.May...
07:50:51 <memerase> > let f = sum . catMaybes in f [Just 6, Just 7]
07:50:54 <lambdabot>   13
07:51:01 * sm resolves to try hayoo more.. I wish hoogle included all packages by default
07:51:15 <quicksilver> memerase: not sure what you mean? sum takes a parameter which is a list of numbers.
07:51:23 <quicksilver> memerase: "catMaybes" is not a list of numbers, it's a function
07:51:30 <quicksilver> so you can't give it as a parameter to sum.
07:51:39 <t7> \n c -> n + fromIntegral c
07:51:43 <t7> @pl \n c -> n + fromIntegral c
07:51:43 <lambdabot> (. fromIntegral) . (+)
07:51:47 <memerase> processin
07:51:53 <memerase> affirmative
07:52:12 <EvanR> "catMaybes" is not a list of numbers, it's a function <- would be nice if compiler said stuff like this ;)
07:53:09 <fmap> doesn't compiler say this?
07:53:16 <parcs`> ghc should insult you whenever there's a type error
07:53:19 <EvanR> in so many words
07:54:02 <EvanR> prepending the long list of output with some basic english would be nice, i suggest
07:54:45 <EvanR> after all the compiler should be helping people, not language implementors ;)
07:55:07 <quicksilver> many many people have tried to write friendly error messages EvanR
07:55:10 <quicksilver> it's not easy to do so
07:55:15 <EvanR> i imagine
07:55:25 <quicksilver> if you could submit a patch to GHC which made things unconditionally better it wouuld be accepted :)
07:55:39 <quicksilver> hugs and helium both try different ways to word the errors
07:57:54 <nand`> parcs`: -Wall -fdemoralizing
08:00:01 <EvanR> output: why the hell are you trying to add a number to a string?
08:00:12 <EvanR> works in php ._.
08:00:25 <mm_freak_> all ways to improve GHC's error messages are bound to special cases, like:  "No instance for Num (a -> a).  Did you try to use a number as a function?"
08:00:46 <mm_freak_> so you can only add more and more of them
08:01:00 <mm_freak_> it's a never ending story in any case, but it would be helpful to beginners
08:01:01 <EvanR> "you idiot, you tried to use a blank as a blank"
08:01:20 <EvanR> politeness is counterproductive
08:01:49 <EvanR> next time try putting the round peg in the round hole
08:02:35 <mm_freak_> i always feel dizzy when a computer says "please"
08:02:43 <mm_freak_> almost like skynet is next door
08:02:43 <quicksilver> a special case for numeric literals could go a long way
08:02:59 <quicksilver> basically "this error occurred because you used the literal "2" as the argument to map"
08:03:08 <quicksilver> > map 2 "hello"
08:03:09 <lambdabot>   [2,2,2,2,2]
08:03:15 <quicksilver> stupid caleskell
08:03:23 <EvanR> indeed
08:03:53 <EvanR> the more stuff thats valid, the less errors can be detected
08:04:10 <t7> > let bytesToInteger = foldl (\n c -> n * 256 + fromIntegral c) 0 in bytesToInteger [1,0,0,0,0]
08:04:12 <lambdabot>   4294967296
08:04:48 <EvanR> t7: foldl' ?
08:06:17 <EvanR> > let bytesToInteger = foldl (\n c -> n * 256 + fromIntegral c) 0 in bytesToInteger [0,0,0,1,0]
08:06:18 <lambdabot>   256
08:07:09 <mm_freak_> > let bytesToIntegerLSB = sum . zipWith (*) (iterate (* 256) 1) in bytesToIntegerLSB [0,0,0,0,1]
08:07:12 <lambdabot>   4294967296
08:08:13 <dylukes> Anyone here want to take a look at a tricky type error?
08:08:32 <dylukes> It involves indexed free monad transformers and types with at least eight parameters!
08:08:43 * hackagebot una 2.0.0 - Universal un-archiver utility (JohnWiegley)
08:10:14 <mm_freak_> dylukes: i hate to say this, but stackoverflow might be a good place to ask such a question =)
08:11:05 <dylukes> https://gist.github.com/3295746
08:11:11 <dylukes> Well, here it is for a first stab.
08:11:24 <dylukes> It's actually a lot simpler than it looks I think, there's just a lot of noise.
08:14:26 <jtanguy> Is it possible to extend a data declaration in another type?
08:14:42 <jtanguy> I have a grammar for a subset of boolean propositions
08:15:16 <jtanguy> phi = true | x < k | x<=k | not phi | phi and phi
08:16:18 <jtanguy> I can encode it in a datatype data Phi = True | LTE Int Int | LT Int Int | Not Phi | And Phi Phi
08:16:18 <exFalso> Hi, i'm trying to build an unregisterised version of ghc for sun solaris. I've followed the guide on the Porting ghc page (which is a bit outdated). I generated and copied the .hc to the target machine, but when i run make it gives this: http://pastebin.com/LN7iSPmT
08:16:23 <mauke> I have copied your paste LN7iSPmT to http://hpaste.org/72782 - pray I don't copy it any further.
08:16:56 <exFalso> i think some global flag is not set properly, any ideas where to look to find out which one?
08:17:29 <jtanguy> and I would like to restrict this grammar in another datatype (i.e. mask the data constructor Not)
08:17:32 <exFalso> ahh silly bot assuming all pastebins are haskell code
08:18:15 <exFalso> jtanguy: you can define the restricted type first, and then extend it like so:
08:18:25 <mauke> exFalso: how is it assuming that?
08:18:28 <exFalso> data Restricted = Whatever
08:18:49 <exFalso> data Unrestricted = Unrestricted Restricted SomeOtherField
08:19:39 <exFalso> mauke: don't know how the bot works, but it copied my paste to hpaste, even though it's not haskell
08:20:00 <geekosaur> it doesn't check
08:20:23 <jtanguy> exFalso: thanks
08:20:32 <exFalso> yeah... i think we're all saying the same thing:)
08:21:03 <geekosaur> exFalso, right at the top of the Porting page it links to a bug noting that unregisterised builds are currently broken :( http://hackage.haskell.org/trac/ghc/ticket/3472
08:21:46 <exFalso> geekosaur: i've seen that and pretended i didn't:) i was hoping maybe there is a way
08:22:33 <exFalso> also, that ticket is very very old...
08:22:56 <mm_freak_> just paste to hpaste right away =)
08:23:07 <geekosaur> very old, yes, but has current changes (sadly just to bump its milestone to 7.6)
08:23:54 <geekosaur> might try in #ghc if you truly believe the ghc team just notes "doesn't work" for reasons other thanb because it actually doesn't work
08:31:18 <t7> :t replicate
08:31:19 <lambdabot> forall a. Int -> a -> [a]
08:31:26 <memerase> can i define a data in ghci?
08:31:53 <memerase> > replicate 5 5
08:31:55 <lambdabot>   [5,5,5,5,5]
08:32:50 <monochrom> yes if you use ghc 7.4
08:33:18 <jcao219> > succ 5
08:33:19 <lambdabot>   6
08:33:44 * hackagebot persistent-mongoDB 1.0.0.1 - Backend for the persistent library using mongoDB. (GregWeber)
09:04:27 <exFalso> :t exitWith
09:04:28 <lambdabot> Not in scope: `exitWith'
09:04:38 <exFalso> import System.Exit
09:05:04 * mekeor . o O ( ex falso quod libre )
09:05:15 <exFalso> : )
09:05:40 * mekeor . o O ( exFalso doesn't have a nose )
09:05:51 <Clint> libet
09:05:55 <mekeor> tibet
09:06:04 <mekeor> oh, libet, yeah.
09:06:31 <mekeor> or, more precisely, ex falso sequitur quodlibet.
09:10:21 <mompff_> hi
09:10:41 <mekeor> hi mompff_
09:10:44 <mekeor> :)
09:14:48 <mompff_> one question regarding point free programming:
09:15:18 <mekeor> go ahead!
09:15:18 <Taneb> Fire away
09:15:23 <mekeor> shoot!
09:15:29 <sm> wait!
09:15:31 <sm> ok go
09:15:40 <mekeor>  Get cracking!
09:15:41 <mompff_> conj = foldr (&&) True
09:15:45 <mekeor> 	 Piss off!
09:15:52 <mompff_> (conjunction)
09:15:58 <mekeor> okay, yeah.
09:16:00 <mompff_> now i want to implement universality test
09:16:08 <mompff_> univ f  = conj . (map f)
09:16:11 <mompff_> works like this
09:16:15 <mekeor> there's alreaddy a standard function for this: and
09:16:24 <mompff_> but not like this univ = conj . map
09:16:32 <nand`> mompff_: you need (conj.) . map
09:16:34 <nand`> or conj .: map
09:16:39 <mompff_> .: :)
09:16:40 <mompff_> thx
09:16:47 <Taneb> .: is not in Prelude, though
09:16:56 <mekeor> mompff_: also, see @pl
09:17:07 <mekeor> @pl univ f = conj . (map f)
09:17:08 <lambdabot> univ = (conj .) . map
09:17:08 <nand`> mompff_: reason being that you already have a . in the pointful version, so when you make it pointless you have to shift it ‘backwards’ another level
09:17:19 <Taneb> :t foldr (&&) True . map f
09:17:20 <lambdabot>     No instance for (SimpleReflect.FromExpr Bool)
09:17:21 <lambdabot>       arising from a use of `f' at <interactive>:1:22
09:17:21 <lambdabot>     Possible fix:
09:17:25 <Taneb> :t \f -> foldr (&&) True . map f
09:17:26 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:17:30 <Taneb> :t and
09:17:31 <lambdabot> [Bool] -> Bool
09:17:35 <Taneb> :t all
09:17:35 <nand`> :t all
09:17:35 <mekeor> oh, oops
09:17:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:17:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:17:48 <mekeor> :t foldr (&&) True
09:17:50 <lambdabot> [Bool] -> Bool
09:17:52 <mekeor> ah, okay.
09:17:57 <mekeor> so, conj = and, right?
09:18:05 <mompff_> jop
09:18:16 <mompff_> and yes forall should to the trick as well
09:18:49 <mompff_> was more interessted in which operator can perform composition on non uniary functions
09:18:53 <Taneb> forall is an optional part of the type signature. The function is "all"
09:19:44 * mekeor was confused…
09:20:20 <monochrom> Taneb means that the correct function name is "all"
09:20:29 <nand`> map $:: id ~> id ~> and -- works too :P
09:20:50 <mekeor> monochrom: yeah. i *was* confused.
09:21:19 <mekeor> nand`: wtf.
09:21:33 <mekeor> :t ($::)
09:21:34 <monochrom> sorry! :)
09:21:35 <lambdabot> Not in scope: `$::'
09:21:48 <nand`> mekeor: it's from Data.Function.Pointless; lifts the ‘map’ function by running ‘id’ and ‘id’ on f and [a] respectively; then ‘and’ on the result
09:22:00 <mekeor> nand`: cooool
09:22:24 <mekeor> nand`: but, does Data.Function.Pointless have any meaning?
09:22:28 <nand`> useful for stuff like (+) $:: unIdentity ~> unIdentity ~> Identity
09:22:31 <mekeor> real-world meaning, i mean.
09:23:02 <nand`> mekeor: I'm not sure I've ever seen it used with too much enthusiasm, but it can have use cases
09:23:05 <mekeor> cool. i have to take a look at that.
09:24:09 <mekeor> btw, someone here recently said Categories (Control.Category) doesn't have a practical meaning. but: Hakyll uses it!
09:25:14 <nand`> I've seen it every now and then; basically whenever you have some form of associative composition function with an identity
09:25:49 <quicksilver> I think it's pretty practical.
09:25:55 <quicksilver> lenses are another popular example
09:26:12 <quicksilver> and various kinds of pseudo-function or materialised function come up quite naturally
09:26:16 <quicksilver> that can still be composed.
09:26:38 <quicksilver> however it's true that it's not an abstraction which gives you a wealth of useful generic combinators.
09:26:41 <nand`> yeah, many lens packages use (Control.Category..) for composition
09:26:52 <quicksilver> apart form the ability to use (.) you don't actually *gain* much by making the instance
09:27:44 <mekeor> oh, the base-package includes experimental modules? didn't know about that…
09:28:46 * hackagebot git-all 1.0.1 - Determine which Git repositories need to actions to be taken (JohnWiegley)
09:28:49 * hackagebot swish 0.7.0.2 - A semantic web toolkit. (DouglasBurke)
09:28:53 <mekeor> > (Control.Category.id :: a -> a) 5
09:28:55 <lambdabot>   Not in scope: `Control.Category.id'
09:30:43 <mekeor> ah, so (>>>) is the same as (>=>), cool.
09:30:56 <nand`> not quite
09:30:59 <nand`> different type signatures
09:31:02 <mekeor> yeah.
09:31:05 <mekeor> but for kleisli
09:31:15 <nand`> you still need to wrap/unwrap by hand for (>>>)
09:31:30 <nand`> (>=>) = (>>>) $:: runKleisli ~> runKleisli ~> Kleisli -- :P
09:31:31 <mekeor> (.) ≈ (>>>) ≈ (>=>)
09:31:38 <mekeor> hehe :D
09:31:40 <nand`> flip (.) you mean
09:31:46 <mekeor> oh, yeah.
09:32:03 <mekeor> (.) ≈ (<<<) ≈ (<=<) -- true?
09:32:12 <nand`> FSVO of (≈)
09:32:17 <nand`> s/ of//
09:32:29 <stepcut> is there a function like readProcess which returns a ByteString (instead of a String)? Or a reason there shouldn't be a  function like that ?
09:33:42 <quicksilver> stepcut: just history.
09:33:48 <mekeor> stepcut: i think you could just use createProcess, no?
09:34:14 <Taneb> Holy netsplits, batman substitute!
09:34:14 <quicksilver> stepcut: (part of which is that bytestring wasn't traditionally in base while the process stuff is)
09:34:22 <mekeor> but, yeah, dunno why there's no such function already…
09:34:22 <stepcut> mekeor: yes.. to implement readProcessBytesString :p
09:34:27 <mekeor> yup :)
09:34:42 <mekeor> s/Bytes/Byte/
09:35:11 <stepcut> I have implementations here: http://hackage.haskell.org/packages/archive/Unixutils/1.50/doc/html/src/System-Unix-Process.html, but.. seems like they should go into some standard package?
09:38:37 <sm> stepcut: did you see process-conduit ?
09:40:07 <sm> how do I tell GHC to ignore missing top-level type signatures in a particular file ?
09:41:00 <stepcut> sm: not what I want
09:45:24 <tnks_> this group has strong mathematic leanings.
09:45:41 <tnks_> someone on Twitter broached the idea of an "open algebra"
09:46:46 <tnks_> they were really talking about non-exhaustive pattern matching
09:47:41 <tnks_> but I felt this isn't what an "open algebra" would be in a mathematical sense.
09:48:03 <Cale> tnks_: Well, "open" usually refers to the topological property in a mathematical context
09:48:41 <memerase> opposite of shadow = ?
09:48:47 <monochrom> different communities use the same word for different purposes
09:48:50 <Cale> Here it's being used in a programming sense of being able to extend the datatype in future modules.
09:49:50 <tnks_> Cale: when I think of non-closed mathematical operations, I think of things like `/` which are not closed over the sets they operate on.
09:50:08 <Cale> open is usually not the opposite of closed
09:50:11 <tnks_> which makes me think of "open algebras" haven't type constructors that /may/ make instances of another type.
09:50:33 <Cale> also, that's yet another definition of closed :)
09:50:37 <Cale> lol
09:50:52 <tnks_> Cale: the idea of open not being the opposite of closed is interesting too.
09:51:11 <tnks_> I completely get that mathematicians are just making up terminology. . . same as computer scientists.
09:51:46 <Cale> In topology, an open set is the complement of a closed one (and vice-versa), but there are sets which are neither open nor closed, and sets which are both.
09:51:47 <tnks_> and there is probably no God-like Kabbalah congruence between all these terms.
09:52:07 <n-dolio> I'm not sure "usually" is accurate.
09:52:14 <n-dolio> Open is not the opposite of closed in topology.
09:52:51 <copumpkin> clopen!
09:52:55 <copumpkin> hitler is not pleased
09:53:06 <Cale> n-dolio: Can you think of a context in mathematics where open *is* the opposite of closed?
09:53:13 <Cale> (i.e. straight negation)
09:53:30 <memerase> temperature in the shadow - opposite is?
09:53:44 <Cale> memerase: what the heck are you talking about?
09:54:05 <Cale> memerase: I know we're a little off-topic for #haskell, but that's just weird :)
09:54:07 <nand`> temperature outside the shadow, clearly
09:55:58 <tnks_> copumpkin: I'm trying to understand the hitler comment. . . still stuck.
09:56:59 <copumpkin> tnks_: http://www.youtube.com/watch?v=SyD4p8_y8Kw
09:58:42 <nus> Cale, was Tarski a mathematician?-)
09:59:50 <tgeeky> nus: he was, with the magical property that he could disassemble himself into two Tarskis!
09:59:59 <tgeeky> nus: that was a great episode of Futurama
10:01:20 <Cale> nus: That sounds like a question for Wikipedia to answer.
10:01:29 <Cale> http://en.wikipedia.org/wiki/Alfred_Tarski
10:02:33 <nus> Cale, was suggesting opposition of semantically open vs closed
10:03:05 <tnks_> copumpkin: that's hilarious.
10:06:48 <tgeeky> It's not your fault, you barely know any topology!
10:09:19 <jfischoff> @tell roconnor have you put any thought it the design of Multiplate TH lib?
10:09:20 <lambdabot> Consider it noted.
10:16:59 <Taneb> Is Gregor's new bot here yet
10:17:02 <Taneb> Wait
10:17:04 <Taneb> Wrong channel
10:17:05 <Taneb> Hello
10:18:49 * hackagebot reform 0.1.2 - reform is an HTML form generation and validation library (JeremyShaw)
10:27:17 <nand`> copumpkin: heh
10:27:31 <nand`> copumpkin: the same rant could work for many mathematical names
10:27:54 <copumpkin> it does ;)
10:27:58 <copumpkin> that thing is a meme
10:28:04 <copumpkin> people stick loads of subtitles on it
10:28:55 <nand`> I know
10:29:09 <nand`> it's a bit hard to read them when you understand what he's actually saying
10:35:24 <henk> hi
10:36:51 <madtusker> hi
10:54:34 <mysticc> @hoogle liftIO
10:54:35 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
10:54:35 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
10:54:35 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
10:58:54 * hackagebot histogram-fill 0.7.2.0 - Library for histograms creation. (AlexeyKhudyakov)
11:04:16 <mekeor> wow. yeah. huge massive split! WOW!
11:10:56 <Fullmoon> I have an understanding problem, why doesn't map (\x -> x) "Hello, World"
11:10:56 <Fullmoon> > "Hello, World"
11:10:58 <lambdabot>   "Hello, World"
11:11:12 <Fullmoon> Return ['H', 'e', 'l', 'l', ... instead?
11:11:19 <mekeor> it's the same.
11:11:20 <Taneb> Because it does.
11:11:23 <Taneb> They are equivalent
11:11:33 <Taneb> The string notation is just syntax sugar
11:11:35 <typoclass> > "abc" == ['a', 'b', 'c']
11:11:36 <lambdabot>   True
11:11:40 <mekeor> > ['H','e','l','l','o'] == "Hello"
11:11:40 <Fullmoon> Oh, so GHCI will import [Char] that way?
11:11:41 <lambdabot>   True
11:11:47 <danil> Fullmoon: strings are just lists of characters, so lists of characters show with quotes instead of written out in full
11:11:49 <mekeor> typoclass: :/
11:11:57 <Fullmoon> Oh yes, I understand
11:12:26 <mekeor> i just wonder whether this works…:
11:12:33 <mekeor> > read "['H','e','l','l','o']" :: String
11:12:34 <lambdabot>   "Hello"
11:12:37 <mekeor> yeah.
11:12:45 <c_wraith> Fullmoon: it's just an artifact of how show is implemented..  It has a special case for showing lists of characters differently from lists of anything else.
11:13:21 <Fullmoon> c_wraith: First day, please bear with me ;) Show is functionality to print to IO?
11:13:39 <mekeor> :t show
11:13:41 <lambdabot> forall a. (Show a) => a -> String
11:13:43 <c_wraith> Fullmoon: oh, no.  show is the function used by ghci when it displays a value
11:13:45 <Botje> show is object.toString
11:14:22 <mekeor> Fullmoon: show gets a value of nearly any type, and returns a String.
11:14:41 <c_wraith> > show [1,2,3]
11:14:42 <lambdabot>   "[1,2,3]"
11:14:49 <c_wraith> > show ['a', 'b', 'c']
11:14:51 <lambdabot>   "\"abc\""
11:15:13 <Fullmoon> Oh, it's like Lisp print, got it.
11:15:41 <c_wraith> does lisp print just convert to a string, and not cause it to be displayed in particular way?  If so, then yes.
11:15:51 <Fullmoon> So I actually mapped over the String, and got [Char] back, which is the very same thing that I fed into it. Cool!
11:16:04 <danharaj> well, you'd hope so because you mapped identity over the string.
11:17:00 <parcs`> :t shoWList
11:17:01 <lambdabot> Not in scope: `shoWList'
11:17:03 <parcs`> :t showList
11:17:04 <lambdabot> forall a. (Show a) => [a] -> String -> String
11:17:16 <c_wraith> yeah..  it's actually kind of a rule that for a correct implementation of map, map id = map
11:17:21 <c_wraith> err, map id = id
11:17:26 <c_wraith> stupid brainos. :)
11:17:28 <luite> hehe
11:17:50 <mekeor> parcs`: isn't that function redundant since there's an "instance Show a => Show [a]" already?
11:18:01 <mekeor> oh, wait.
11:18:07 <c_wraith> mekeor: it's part of the class, actually.  it's the mechanism for the String hack.
11:18:08 <mekeor> parcs`: what does showList do?
11:18:39 <c_wraith> mekeor: (personally, I think the String hack is *terrible*, and should have been used as evidence that type String = [Char] is not a great idea)
11:18:48 <danil> mekeor: it's the method of the Show class that lets [Char] get overloaded separately but still coexist with the Show a => Show [a] instance
11:19:05 <mekeor> danil: ah, interesting.
11:19:15 <danil> (and yes, it's a terrible hack)
11:19:32 <mekeor> where can i find it? i mean, where's the code?
11:19:42 <c_wraith> @src Show
11:19:42 <lambdabot> class  Show a  where
11:19:42 <lambdabot>     showsPrec :: Int -> a -> ShowS
11:19:42 <lambdabot>     show      :: a   -> String
11:19:42 <lambdabot>     showList  :: [a] -> ShowS
11:19:59 <danil> mekeor: GHC.Show
11:20:10 <mekeor> AH, it's a method of Show, i see.
11:20:35 <mekeor> and it has a default-definition which is overwritten by [Char]
11:20:39 <mekeor> right?
11:20:52 <iamtakin1iteasy> hi, i have written a simple "stack walker" state-monad-studying program which offers to hypotetic user an endless in both ways stack and allows user to explore this stack, by moving right or left or incrimenting or decrimetnting current stack cell. i already fixed all hlint-complaining problems, but i can't tell how bad or good my code is. may i ask you to review it?
11:20:57 <hpaste> iamtakingiteasy pasted “Here is my code” at http://hpaste.org/72791
11:21:02 <c_wraith> mekeor: correct
11:21:27 <c_wraith> mekeor: well, actually, not quite.  it's overridden for Char, not [Char]
11:21:37 <mekeor> c_wraith: oh, right :D
11:21:40 <c_wraith> mekeor: which is how the Show instance was made H98 compatible
11:21:47 <mekeor> mekeor: see <mekeor: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Show.html#Show>
11:22:06 <c_wraith> holy repetition of your own name. :)
11:22:10 <mekeor> hehe :D
11:22:41 <danharaj> iamtakin1iteasy: looks good at a first glance
11:24:04 <iamtakin1iteasy> danharaj: thank you, but there got to be a lot of flaws which i accidently allowed to come into my code
11:25:29 <mekeor> if i need a helper function for a function "f", is it generally better to do "f x = f' x []" or "f x = f' [] x" (considering currying)?
11:25:51 <c_wraith> mekeor: depends on if anything else is going to call f'
11:26:04 <Botje> mekeor: will both arguments change often during recursion?
11:26:08 <c_wraith> mekeor: also, if you can close over an argument, rather than passing it, that's better
11:26:10 <iamtakin1iteasy> pretty frustrating bit of hsaskell, i'd say
11:26:12 <mekeor> c_wraith: no. f' is only called by f.
11:26:20 <Botje> otherwise put the least-changing one first
11:26:31 <nobdrais1ntone> iamtakin1iteasy: hi wooga! there is a nice dead codereview stack overflow, btw → http://codereview.stackexchange.com/
11:26:36 <iamtakin1iteasy> fist you do f x [] and then realises that you need to do f [] x an deither flip f or re-write a lot of signatures
11:26:37 <mekeor> Botje: oh. why?
11:26:58 <hpaste> danr annotated “Here is my code” with “Here is my code (annotation)” at http://hpaste.org/72791#a72792
11:27:03 <iamtakin1iteasy> nobdrais1ntone: thank you!
11:27:03 <mekeor> c_wraith: what does "to close over an argument" mean?
11:27:37 <Botje> mekeor: more opportunitied for currying
11:27:37 <danr> iamtakin1iteasy: I had a go at your `walkStack` function (didn't test it though)
11:27:53 <c_wraith> mekeor: it means making it part of a closure
11:27:54 <danr> (obviously as there is a typo on one of the <- arrows)
11:28:12 <iamtakin1iteasy> danr: where?
11:28:28 <iamtakin1iteasy> it compiles and works fine
11:28:34 <danil> iamtakin1iteasy: you should probably take the StackSignalOver constructor out of DataStack and instead return a Maybe DataStack in places where there might not be a stack
11:28:40 <danr> iamtakin1iteasy: my annotation at http://hpaste.org/72791#a72792
11:28:56 * hackagebot happstack-authenticate 0.9.4 - Happstack Authentication Library (JeremyShaw)
11:28:59 <iamtakin1iteasy> danil: thanks, a good idea
11:29:18 <mekeor> c_wraith: erm… what's a closure? :/ (the wiki isn't clear about that (<http://www.haskell.org/haskellwiki/Closure>))
11:29:33 <danr> I'm allergic to too much code, so I would rename the DataStack constructor to Stk or something :)
11:29:44 <danr> I mean it's short lived, anyway
11:29:47 <iamtakin1iteasy> danr: ah, sorry, missed hpaste bode message
11:29:59 <iamtakin1iteasy> danr: thank you for your review!
11:30:18 <Botje> mekeor: a closure is a function with associated environment.
11:30:22 <danr> good luck, keep thim coming
11:30:24 <danr> them
11:30:46 <danil> iamtakin1iteasy: it's also possibly cleaner to have DataStack { stackBefore :: [a], stackValue :: a, stackAfter :: [a] } to make it clearer where the "current value" is, rather than having to remember it's the first one in the "before" list
11:30:47 <Botje> let x = ...; f = ... x ... in f -- f 'closes over x'
11:31:02 <mekeor> ah
11:31:11 <mekeor> and f is a closure?
11:31:14 <Botje> yes
11:31:16 <mekeor> ah
11:31:21 <iamtakin1iteasy> danil: yeah, probably premature optimization from me :/
11:31:56 <mekeor> Botje: so, a closure is approximately and vaguely a function which calls other functions?
11:33:27 <Botje> mm, no
11:33:35 <danil> mekeor: a function whose body refers to non-global names
11:33:42 <typoclass> mekeor: yeah, a closure is a function that refers to outside stuff. doesn't need to be an outside function, could be another value as well
11:33:45 <Botje> a closure is a function pointer plus its lexical environment.
11:34:33 <mekeor> typoclass: yeah, that's how i see it.
11:35:19 <mekeor> and now … danil VS typoclass … fight!! (you're opinions are contradictionary, aren't they?)
11:35:47 <mekeor> oh, and Botje, fight also.
11:36:19 * mekeor got childish, i think.
11:36:22 <Botje> typoclass' definition agrees with mine
11:36:26 <Botje> so does danil's
11:36:30 <Botje> no need for fighting :P
11:36:54 <danil> I would ammend mine to be "non-global names defined outside the function itself", but yes we all agree
11:36:54 <mekeor> okay :) thanks, btw :)
11:37:03 <c_wraith> mekeor: for example, here's a worker-wrapper transform on map.   « map f = go where go [] = [] ; go (x:xs) = f x : go xs ».  This is actually part of a useful optimization technique in GHC.
11:37:28 <c_wraith> mekeor: but it works by creating a smaller recursive worker function that closes over the value of f passed in.
11:37:28 <MagneticDuck> hey, just a question that I can't find online... how would I make a left hand side in one match of a case statement that could match more then one value?
11:37:31 <MagneticDuck> I forgot the syntax
11:37:56 <c_wraith> MagneticDuck: case can only match one value.  If you want a more complex match, you can match a pair, though
11:38:05 <MagneticDuck> aw
11:38:06 <MagneticDuck> k
11:38:21 <MagneticDuck> that would be really helpful though!
11:38:21 <mekeor> c_wraith: oh, wow, okay… exciting…
11:38:46 <MagneticDuck> I have quite a bit of code behind this, so I'll have to make a definition in a let statement
11:39:10 <c_wraith> mekeor: the key insight there is that f doesn't change in the recursion, so it doesn't need to be passed every time - it's kind of wasted effort to pass it through every time.
11:39:27 <mekeor> MagneticDuck: or you could take a look at pattern guards which are sometimes useful in such cases, too.
11:39:50 <mekeor> c_wraith: aaah, yeah. i see
11:40:08 <mekeor> thanks, c_wraith =)
11:40:44 <MagneticDuck> mekeor: I ended up using an if statement actually now
11:41:09 <mekeor> MagneticDuck: heh. pattern guards are cool anyway.
11:41:52 <MagneticDuck> if a `elem` [c, d] then...
11:41:54 <MagneticDuck> =P
11:42:11 <mekeor> yup, that's fine.
11:43:05 <mekeor> MagneticDuck: i think you had to describe more of the context to make us able to criticise your solution…
11:47:57 <gertc> http://hackage.haskell.org/packages/archive/cereal/0.3.5.2/doc/html/Data-Serialize.html#t:Serialize
11:48:35 <gertc> what does safe haskell mean in the corner?
11:49:33 <MagneticDuck> it means the haskell contained in that package won't kill you
11:49:36 <MagneticDuck> not suprising
11:49:43 <MagneticDuck> *surprising
11:49:56 <MagneticDuck> (I don't know)
11:49:56 <mekeor> gertc: i don't know but you could read <http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell>
11:50:23 <n-dolio> Safe Haskell tries to identify things that could subvert the type system and allow you to write unsafeCoerce.
11:51:06 <n-dolio> Safe inferred means it didn't make use of anything that wasn't trustworthy already.
11:54:00 * hackagebot factual-api 0.5.0 - A driver for the Factual API (RudigerLippert)
11:54:21 <gertc> ok thx
11:57:59 <gertc> can you just use Data.Serialize and di SafeCopy only when you need it to convert stuff?
12:00:19 <Cesur> help me
12:03:06 <danharaj> edwardk: is it possible to write a monad instance for Effect m _ a?
12:03:17 <edwardk> no
12:03:55 <edwardk> same as Const
12:03:59 <edwardk> brb
12:04:03 * hackagebot stickyKeysHotKey 0.1.0.0 - get and set STICKYKEYS.SKF_HOTKEYACTIVE (SoenkeHahn)
12:04:16 <Cale> Cesur: I'm sure that people would help you if they had some idea of what you needed help with, but you haven't given any indication of that.
12:06:59 <sp3ctum> i have an instance of Arbitrary of my type for quickcheck. the instance works fine, but i've bound it to the name gen_foo and done instance Arbitrary Foo where arbitrary = gen_foo
12:07:18 <sp3ctum> i did that since i thought it would be easier to test whether the generator works.
12:08:11 <sp3ctum> i'm wondering if there is a way to only have the instance and not gen_foo separately - and still be able to test it with e.g. vectorOf 3 gen_foo
12:08:29 <sp3ctum> :t vectorOf
12:08:31 <lambdabot> forall a. Int -> Gen a -> Gen [a]
12:09:11 <sp3ctum> so i need the generator, but if the generator is only the instance of arbitrary, how can i use it with vectorOf?
12:10:13 <danil> > vectorOf 5 (arbitrary :: Gen Int)
12:10:14 <lambdabot>   No instance for (GHC.Show.Show
12:10:15 <lambdabot>                     (Test.QuickCheck.Gen.Gen...
12:12:06 <sp3ctum> thanks danil!
12:12:37 <sp3ctum> seems so simple now. i only tried that with (arbitrary :: Int)
12:13:43 <danil> Yeah, sadly there's no way to specify the value of the type variable without writing out the whole type
12:16:18 <latro`a_> hm, I wonder if there'd be any way to feed individual type values into the inference system
12:16:27 <latro`a_> like... foo :: _ -> _ -> Int -> _
12:16:56 <latro`a_> where _ is not an arbitrary type variable, but the same as what you'd get if you didn't say anything
12:17:34 <danil> there's no practical difficulty with that, the typechecker just makes a new unification variable for each _
12:18:16 <mdeboard> Hi, I'm watching http://channel9.msdn.com/Series/C9-Lectures-Greg-Meredith-Monadic-Design-Patterns-for-the-Web/C9-Lectures-Greg-Meredith-Monadic-Design-Patterns-for-the-Web-Introduction-to-Monads and I want to make sure I understand something he said about monads.
12:18:29 <Cale> mdeboard: okay
12:18:40 <mdeboard> He said that the major scale (WWHWWWH) is a monad
12:19:02 <sp3ctum> musical scale?
12:19:02 <Cale> That sounds incredibly misguided
12:20:56 <Cale> But go on.
12:20:56 <mdeboard> I'm probably misquoting, trying ot find exactly what he said
12:20:56 <mdeboard> the way he said it made a lightbulb come on about monads; my question was "is the major scale a monad?" which means that's not what he said explicitly. I'm trying to find that spot in the video
12:21:46 <Cale> The answer to that is probably "no, except in some trivial way"
12:22:10 <Taneb> Major scale? As in from music?
12:22:17 <sp3ctum> Taneb, yes.
12:22:20 <mdeboard> "You don't have to remembder the G-major scale, and the D-major scale, and the F-major scale, there's one major scale. If you remember it like this: whole step, whole step half step whole step whole step whole step half step, you don't have to remember 7 major scales, you remember one scale."
12:22:20 <Taneb> !!!
12:22:34 <Taneb> Wow
12:22:37 <Taneb> Everything is a monad
12:22:42 <Taneb> Except what isn't
12:22:43 <mdeboard> I think he was just using that as an illustration though, it's at 14:38 in the video
12:22:56 <mdeboard> 14:35
12:23:02 <latro`a_> I think that was probably about abstraction in general, not monads in particular...
12:23:07 <Cale> That has to be the least helpful analogy I have ever heard.
12:23:12 <sp3ctum> odd analogy. perhaps to emphasize that it's a type class (~interface)
12:23:13 <mdeboard> latro`a_: Agreed
12:23:16 <Cale> Including the one about spacesuits
12:23:20 <Cale> lol
12:23:25 <mdeboard> That's why my question is: So is that major scale pattern monadic? Or something.
12:23:27 <Enigmagic> monads are tacos
12:23:34 <mdeboard> lol
12:23:52 <mdeboard> so what you're saying is, anything is a monad if I want it hard enough
12:24:02 <Cale> mdeboard: No, it's not. It's like he's using some kind of Chewbacca defence to get out of having to explain what monads are.
12:24:13 <mdeboard> lolirl
12:24:17 <sp3ctum> chewbacca defence :D
12:24:18 <Enigmagic> these are not the monads you're looking for
12:24:36 <sp3ctum> mind trick to know monads?
12:24:41 <Cale> "What is a monad?" "Chewbacca is a monad. This does not make sense. You must acquit."
12:25:15 <Cale> mdeboard: read this: http://www.haskell.org/haskellwiki/Monads_as_computation
12:25:21 <Taneb> A monad is something that you can map over, put something into, and collapse?
12:25:38 <copumpkin> Taneb: such that ...
12:25:40 <copumpkin> :)
12:25:46 <mdeboard> something something applicative functors
12:25:48 <Taneb> Such that's it a monad
12:25:51 <latro`a_> I think the "collapse" part is the hardest to intuit about in non-container-y settings
12:26:04 <Enigmagic> it produces burritos in space suits when collapsed
12:26:07 <sp3ctum> a context you can do stuff in, preserving the context
12:26:20 <Taneb> Possibility in modal logic is a monad.
12:26:29 <Taneb> Certainty, similarly, is a comonad
12:26:31 <latro`a_> join definitely looks like a collapse, but, say, join :: State s (State s a) -> State s a doesn't really look like collapse
12:26:44 <Taneb> I'm not sure how that join works
12:26:44 <sp3ctum> :t join
12:26:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:26:47 <Taneb> Wait, I do
12:26:56 <latro`a_> run the first one, then run the second one on the new state
12:26:56 <latro`a_> :p
12:27:01 <Taneb> :)
12:27:04 <certainty> i'm a comonad?
12:27:08 <certainty> :)
12:27:22 <Taneb> I, for one, would like to extract you
12:27:27 <Taneb> ;)
12:27:35 <monochrom> I guess he just means that monad is a generalization and abstraction
12:28:29 <Taneb> If something is true in this universe, and you give me a different universe, it's possible it's true (this is pure/return)
12:28:41 <monochrom> a/the major scale is not a monad. has no return bind join etc
12:29:00 <Taneb> If it's possible that something is true in a universe, and if I can prove that if I have it, I have something else too, that something else is possible in that universe (fmap)
12:29:22 <Cale> mdeboard: It's kind of sad to have to say this, but almost everything out of channel 9 I've ever seen about monads has ranged from unhelpful to outright wrong.
12:29:25 <mdeboard> This is the most surprisingly hilarious IRC channel
12:29:49 <Taneb> If it's possible that it's possible that something is true in a universe, it's possible that something is true in a universe (join)
12:30:05 <Taneb> Hence possibility is a monad
12:30:07 <c_wraith> Cale: the presentation about the Game (Conway's version) monad in Scala wasn't bad
12:30:08 <latro`a_> this reminds me of the categorical definition of a single poset
12:30:19 <latro`a_> where the arrows have no meaning, only their existence has meaning
12:30:22 <Cale> c_wraith: I haven't seen that one
12:30:23 <dgpratt> Cale: the good thing about C9 is that it brings concepts such as Monads to a much wider audience; then they can come here and you can straighten them out :)
12:30:32 <Cale> I guess that's true
12:30:33 <Taneb> If across every  universe, X must be true, it's true in this universe.
12:30:37 <Taneb> (extract)
12:30:43 <dgpratt> (like you did me :D )
12:30:51 <mdeboard> FWIW this has been a test and you guys passed, Applebee's gift certificates for everyone
12:30:51 <Eduard_Munteanu> c_wraith: is there a GoF monad? I thought it's more like a comonad.
12:30:55 <Taneb> Damn, certainty isn't a comonad after all
12:30:56 <Eduard_Munteanu> *GoL
12:31:02 <sp3ctum> mdeboard, true, also easy to get sidetracked once conversation picks up
12:31:04 <Taneb> It doesn't have fmap
12:31:06 <Taneb> :'(
12:31:23 <Taneb> Hang on
12:31:30 <monochrom> but you can harp (pun intended!) the same analogy for every abstraction. take stuff from the java standard library. "there are LinkedList, ArrayList, YourOwnList... but you can just talk about List"
12:31:35 <certainty> damn
12:31:40 <c_wraith> Eduard_Munteanu: no, Game as in his study of endgames of Go (and a generalization of zurreal numbers), not Game of Life.  he did too many things with names that were too similar.
12:31:44 <Taneb> Can't you express fmap using comonad stuff?
12:31:52 <cokanut> Taneb: I'm thoroughly confused trying to follow your conversation. I hope the 'possibility that it is a possiblity' reasoning is not some joke.
12:31:52 <Taneb> You need extend...
12:31:54 <c_wraith> err, surreal numbers
12:31:56 <Eduard_Munteanu> Ah, heh.
12:32:01 * certainty extends
12:32:07 <latro`a_> *generalization* of surreal numbers
12:32:08 <danil> Taneb: if it's certain that A and A implies B it had better be certain that B
12:32:10 <latro`a_> what in the hell....
12:32:23 <Taneb> danil, if it's not certain, it may only apply to this universe...
12:32:33 <monochrom> so the problem is that the analogy tells you almost nothing. too many things fit the analogy.
12:32:39 <Taneb> cokanut, it isn't a joke, merely badly expressed
12:32:52 <mdeboard> Cale: Why is it said you have to say that about C9
12:33:03 <cokanut> Taneb: Oh. Thanks.
12:33:03 <c_wraith> latro`a_: they actually were developed before surreal numbers.  They relax the restriction that the all elements in the set of lower bounds be less than all elements in the set of upper bounds (and vice versa)
12:33:20 <mdeboard> (I have never been to C9 before yesterday)
12:33:25 <danil> Taneb: oh, arrows are universe-local, that makes sense.
12:33:48 <Cale> mdeboard: It's sad because they're kinda popular and would serve as a great way to inform a lot of programmers about this stuff
12:34:05 <Taneb> extend :: w a -> (a -> w b) -> w b...
12:34:13 <Cale> mdeboard: But they seem to butcher it pretty badly for the most part
12:34:15 <Taneb> No
12:34:22 <Taneb> extend :: w a -> (w a -> b) -> w b
12:34:29 <Taneb> Certainty is not a comonad
12:34:29 <tdammers> surreal numbers? are we doing that philosophy thing again?
12:34:35 <certainty> :/
12:34:37 <Taneb> :'(
12:34:49 <Taneb> certainty, I can't map over you
12:34:59 <mdeboard> Cale: So is there no value in the concept of the "WWHWWWH" pattern of major scales as an abstraction?
12:35:28 <Taneb> mdeboard, it means you can start at B and a bit, and still work?
12:35:43 <Taneb> B and a bit major
12:35:46 <monochrom> there is very little value
12:35:49 <Cale> mdeboard: It's an abstraction, but it's one which is otherwise completely unrelated to monads
12:35:52 <mdeboard> I see
12:36:06 <monochrom> see my List analogy
12:36:08 <Cale> mdeboard: Unless you're having trouble with the concept of what an abstraction is, it's probably not a good analogy
12:36:13 <mdeboard> bummer, it was the first simile I'd seen that was like "ahh ok"
12:36:36 <danil> mdeboard: scales are (an example of) an abstraction, and monads are (an example of) an abstraction, but that's about the extent of the ways monads are like scales
12:36:42 <mdeboard> I see
12:36:52 <mdeboard> Noted
12:36:54 <Cale> mdeboard: Read my Monads as Computation article, I'd like to think it's fairly accurate as to why we as programmers are interested in monads as an abstraction.
12:37:05 <mdeboard> that guy has long hair anyway, he can't be trusted
12:37:32 <mdeboard> I've got it bookmarked
12:37:42 <monochrom> "irc client" is like monad. there is xchat irc client, irsii irc client, mirc irc client... but you can just talk about "irc client"
12:37:56 <neutrino2000> why are groups not interesting as an abstraction?
12:38:04 <Cale> neutrino2000: what?
12:38:13 <monochrom> "cup" is like monad. there is coffee cup, paper cup, styrofoam cup... but you can just talk about "cup"
12:38:13 <Cale> neutrino2000: Groups are one of the most useful abstractions in mathematics
12:38:17 <Taneb> monochrom, liftM id leafchat = leafchat
12:38:20 <Taneb> :)
12:38:23 <neutrino2000> but not in computer science
12:38:30 <neutrino2000> i don't see a lot of Group api's
12:38:34 <tdammers> monochrom: wouldn't that make cup rather like a typeclass?
12:38:35 <monochrom> see how much value a cheap analogy has
12:38:35 <neutrino2000> i see lots of Monad api's
12:38:50 <danil> neutrino2000: there are a lot of monoids, but many useful things to compute with aren't invertable
12:38:56 <monochrom> the major scale is like a type class :)
12:39:01 <Cale> neutrino2000: Well, Group and Monad aren't straightforwardly comparable.
12:39:08 <Cale> neutrino2000: Maybe you mean Group and Monoid?
12:39:10 <tdammers> also, note the lack of precision in the English language
12:39:18 <Taneb> Monads (well, Kleisli arrows) are a generalization of mathematical functions that are actually useful for computing
12:39:20 <Cale> Or Monad and HopfAlgebra?
12:39:29 <tdammers> paper cup: made of paper. styrofoam cup: made of styrofoam. coffee cup: ?
12:39:38 <neutrino2000> no i mean Group and Monad
12:39:47 <monochrom> oh, yeah, tdammers, you nail another point
12:39:51 <Taneb> tdammers, coffee cup is a cocup. It's comade of fee.
12:39:54 <neutrino2000> a Monad is a set with some operations closed in that set
12:39:59 <Cale> neutrino2000: no
12:40:03 <Taneb> edwardk help
12:40:06 <edwardk> ?
12:40:06 <neutrino2000> that's how i view a monad
12:40:19 <neutrino2000> why is my view wrong?
12:40:22 <monochrom> monad is like empty. there are empty set, empty string, empty map, empty cup... but you can just talk about empty
12:40:22 <tdammers> Taneb: I think you mean ffee
12:40:27 <Taneb> Typo, yeah
12:40:41 <monochrom> which is precisely what my students do to argue that empty set = empty string
12:40:47 <Cale> neutrino2000: A monad is, as far as we're concerned here, a type constructor with some operations defined related to that type constructor, which are polymorphic over all underlying element types.
12:40:57 <Taneb> This seems to be the best place to ask my not-entirely-related question regarding trigonometry
12:41:06 <monochrom> and therefore they can't grok this non-empty set: { empty-string }
12:41:07 <Taneb> Does the co in cosine mean the same as the co in comonad?
12:41:22 <monochrom> they probably can't grok { {} } either
12:41:23 <Cale> Specifically, if the type constructor is M, then we need  return :: a -> M a, and (>>=) :: M a -> (a -> M b) -> M b
12:41:30 <Cale> and those have to satisfy some laws
12:41:41 <neutrino2000> you're using very fancy wording to say the same thing as i
12:41:55 <neutrino2000> yet because you use different words you think you're saying something else (you are not)
12:41:58 <danil> neutrino2000: a monad is more like a group homomorphism than a group
12:42:03 <Cale> By contrast, a Group typeclass would not have a type *constructor*, just a plain type
12:42:04 <neutrino2000> i don't see that
12:42:20 <latro`a_> taneb: not really
12:42:34 <latro`a_> in an extremely vague sense yes
12:42:37 <Cale> A group G has an identity :: G, multiplication :: G -> G -> G, and inverse :: G -> G
12:42:38 <neutrino2000> i see a specific monad, eg list monad, operates on lists, can join them, and can perform actions that give you new lists
12:42:44 <Cale> satisfying some laws
12:42:56 <Taneb> latro`a_, :'(
12:43:12 <latro`a_> there are a whole pile of categorically dual concepts with the prefix co-
12:43:21 <latro`a_> that *are* related in the same way as monad and comonad
12:43:24 <copumpkin> like me
12:43:26 <Cale> A monoid M has an identity :: M, and a multiplication :: M -> M -> M, satisfying some laws
12:43:27 <monochrom> Group is an interesting abstraction
12:43:27 <latro`a_> i.e. everything's the same but with the arrows reversed
12:43:39 <monochrom> haha copumpkin
12:43:42 <Cale> (just not necessarily an inverse, like a group would)
12:43:48 <neutrino2000> oops, i gtg
12:43:50 <Cale> We *do* have a Monoid class
12:43:51 <neutrino2000> bbl
12:43:58 <Cale> and it sees lots of use
12:44:03 <neutrino2000> but i do think there should be more things than just Monad and Monoid being considered
12:44:10 <Cale> There are!
12:44:18 <neutrino2000> not in haskell
12:44:24 <latro`a_> uh
12:44:25 <neutrino2000> there's so much stuff not being touched upon which is useful
12:44:26 <latro`a_> yes in haskell
12:44:26 <Cale> It's not like people aren't using Group as an abstraction in Haskell
12:44:38 <Cale> there are libraries for this stuff on hackage
12:44:43 <Cale> multiple ones, in fact
12:44:46 <neutrino2000> abstract algebra is like a huge library of concepts
12:44:47 <latro`a_> Applicative comes up in lots of places, including places where Monad doesn't make sense
12:44:48 <tdammers> Functor... Applicative...
12:44:49 <neutrino2000> but
12:44:52 <neutrino2000> i still have to go
12:44:55 <neutrino2000> bbs
12:45:06 <danil> neutrino2000: the difference is that the set of Haskell types has structure (given by Haskell functions), and the list type constructor takes each type A to the type [a] while *preserving* that structure (the Functor law) and giving you new operations that *interact with* that structure (the Monad operations)
12:45:13 <latro`a_> it's actually a really neat exercise to show that ZipList can't have a monad if you enforce pure = return
12:45:54 <Cale> neutrino2000: for later: http://hackage.haskell.org/package/algebra-2.1.1.2
12:46:05 <hpaste> effereti pasted “type error” at http://hpaste.org/72794
12:46:20 <Cale> (I'd link to 3.0, but the documentation seems to not be generated (yet?))
12:46:44 <latro`a_> that is awesome
12:46:50 <latro`a_> but it makes me sad that it's in Numeric
12:47:10 <effereti> can somebody please help me with this typing error? http://hpaste.org/72794
12:47:23 <effereti> ( parsec related )
12:47:29 <latro`a_> it says rigid type variable, try commenting out the signature
12:47:29 <scry1> latro`a_:what's wrong with Numeric?
12:47:39 <latro`a_> nothing, but abstract algebra isn't really about numbers
12:47:42 <Cale> effereti: replace the st in your type signature with ()
12:48:13 <effereti> Cale: that's a solution, but still, I tought manyTill accepter Parse *and* CharParse st
12:48:16 <Cale> effereti: Or fix termPar such that it is polymorphic in the same way
12:48:18 <effereti> it should work imho
12:48:31 <latro`a_> if it needs to be st then you need to convert it inside the function
12:48:38 <Cale> Can you show the code/type for termPar?
12:49:05 <Cale> oh, hmm
12:49:38 <Cale> no, that's right
12:49:43 <effereti> Cale: I can do better than that
12:49:51 <effereti> substitute termPar with ter
12:49:57 <Cale> oh, it's there, I see
12:49:58 <effereti> (in line 111)
12:50:02 <effereti> same error
12:50:07 <effereti> I kind of don't get it
12:50:15 <Cale> AHA
12:50:18 <danil> effereti: manyTill will accept non-() state types, but both its arguments and its return value have to have the same state type. If some other part of your code assumes it's (), this function has to too.
12:50:24 <Cale> {-# LANGUAGE NoMonomorphismRestriction #-}
12:50:30 <Cale> put that at the top of your file :)
12:50:33 <latro`a_> ...lol
12:50:57 <latro`a_> we should really just start putting that at the top of every file and then attempting to remove it afterwards
12:51:03 <Cale> termPar is a pattern binding without an explicit type signature and the MR is biting you by making it monomorphic
12:51:21 <Cale> and it's doing that by defaulting st to ()
12:51:22 <effereti> Cale: so putting a type sign there will do the trick?
12:51:24 <Cale> yes
12:51:27 <effereti> gah!
12:51:29 <Cale> or turning off the MR
12:51:31 <latro`a_> as will enforcing NoMR
12:51:34 <Cale> because it's stupid
12:51:43 <effereti> that's pretty, mhhh, is it haskell98?
12:51:51 <Cale> Haskell 98 has the MR
12:51:55 <effereti> (i.e. standard stuff)
12:52:02 <MagneticDuck> hey, I'm learning haddock and I have a little question... if I make a module with haddock comments, is there any way to make a html documentation for that one source file in place? I tried --gen-contents but the link to the module seems to be broken in index.html...
12:52:05 <danil> Cale: wait, defaulting to ()?  I thought that was only with extended defaulting in ghci.
12:52:11 <Cale> But I don't even remember a time when there wasn't a flag to disable the MR
12:52:21 <monochrom> I am not convinced either
12:52:22 <effereti> danil: I am using ghci
12:52:48 <Cale> danil: That's also probably questionable about it.
12:52:57 <danil> effereti: I mean only for things you type at the prompt, not for source files you load
12:53:05 <Cale> danil: I've seen it happen without having extended defaulting turned on thouhg.
12:53:07 <Cale> though*
12:53:32 <Cale> Maybe they only locally turn it on when trying to enforce the MR or something
12:54:29 <Cale> It may be a bug
12:55:33 <latro`a_> incidentally, I'd write subP with do notation, but that's personal preference >.>
12:56:12 <monochrom> "ter = ..." is not suffering from MR
12:56:19 <effereti> Cale: did put  {-# LANGUAGE NoMonomorphismRestriction #-} at the top of the file. Reloaded with ghci and same error
12:56:51 <monochrom> p :: CharParser st a -> CharParser st a; p x = y where y = x;  works
12:57:25 <latro`a_> ghci reads language pragmas right?
12:57:34 <monochrom> well, it is MR'ed, sure, but retains the type st. afterall, in that scope, there is only one st.
12:57:46 <effereti> I see I haven't pasted the relevant imports. Do you want to see them?
12:57:49 <geekosaur> yes, it does
12:57:50 <monochrom> ghci ignores pragmas entered at the prompt
12:58:01 <geekosaur> ... but that yes, not at the prompt
12:58:14 <mekeor> but you can :set -XExt
12:58:23 <latro`a_> wait, it ignores it if you do, say
12:58:28 <latro`a_> ghci -XNoMonomorphismRestriction
12:58:29 <latro`a_> ?
12:58:40 <latro`a_> (at the shell)
12:58:42 <monochrom> the use of "parse" introduces the () type
12:58:43 <geekosaur> no
12:59:07 <latro`a_> just internally, then?
12:59:11 <geekosaur> it ignores {-# ... #-} inside the REPL
12:59:19 <effereti> :set ghci -XNoMonomorphismRestriction doesn't make ghci stop complaining, too :c
12:59:26 <geekosaur> because that kind of pragma is defined only to the start of a file
12:59:29 <dmwit> latro`a_: It ignores {-# LANGUAGE NoMonomorphismRestriction #-} if you type that at the > prompt.
12:59:41 <geekosaur> repl is not the start of a file, it's at a state where it's too late for pragmas
13:00:16 <latro`a_> ahh
13:02:11 <scooty-puff> can hoogle or hayoo do data type searches based on shape of the type?  i would like to search if data Proxy a = Proxy already exists (by any named)
13:02:13 <effereti> do you think I should file a bug report? Or is it "works as expected"?
13:02:28 <scooty-puff> *named -> name
13:02:35 <danil> effereti: do you get the same thing with the MR off and no type signature?  That type signature looks very suspicious, since you take a parser that uses state and return only non-state Parsers
13:02:49 * MagneticDuck is away: Outta the house.. be back later
13:03:22 <monochrom> this is not a ghc bug
13:03:49 <DMcGill_> it however, a much debated feature
13:04:12 <effereti> danil: /without/ type sig it works
13:04:21 <danil> effereti: that means your type signature is lying
13:04:26 <effereti> :s
13:04:33 <monochrom> without type sig, you get a different type sig
13:04:55 <tdammers> explicit type signatures are just double checks most of the time. very useful ones though.
13:04:58 <DMcGill_> efferetui: what does ghci say the type is?
13:08:46 <effereti> DMcGill_: http://hpaste.org/72795
13:10:12 <mysticc> I was setting up emacs and haskell mode .. When I try to find by tags I get error .. function definition void : haskell-sessions-tags-filename
13:10:23 <mysticc> any help from emacs users ?
13:11:13 <danil> effereti: that part is fine, it's the return type your signature claims that isn't okay
13:11:40 <danil> effereti: (it should also be a CharParser st rather than a Parser)
13:13:44 <effereti> your rock danil
13:14:28 <effereti> I suppose, once with a state, you can't just return a nonstate stuff
13:14:40 <effereti> the error wasn't very descriptive
13:15:20 <mekeor> mysticc: what are tags? oO
13:15:40 <scry1> mysticc: did you run etags?
13:15:42 <effereti> thanks for the help, #haskell
13:16:04 <Mandarin> Haskell does some beautiful magic with : iterate (*2) 1
13:16:05 <mekeor> effereti: np
13:16:07 <Mandarin> http://s17.postimage.org/kffi5lrfh/parabel.png
13:16:07 <geekosaur> mekeor: `man etags` or C-h f visit-tags-table for anintroduction
13:16:23 <effereti> now I have got another question: vim or emacs?
13:16:28 <mekeor> Mandarin: same happens with fibonacci.
13:16:33 <effereti> </troll>
13:16:41 <mekeor> Mandarin: i once investigated that.
13:16:47 <danil> I recently watched one of Lennart's talks, and his Mu has the wonderful feature of telling you what term introduced each non-matching type in a type error
13:16:52 <Mandarin> mekeor: Thanks, gonna play with that now :D
13:17:06 <mekeor> geekosaur: ty
13:17:10 <effereti> danil: and by letting ghci infer the sig, my error is pretty obvious
13:17:26 <monochrom> neither vim nor emacs. nano.
13:17:34 * effereti notes
13:17:43 <monochrom> actually, make it pico or notepad
13:17:53 <danil> effereti: yeah; the problem with signatures is that sometimes you can't infer the type without them, so the compiler can't figure out when they're the problem
13:18:49 <danil> I guess you could attempt to infer a type for the expression after failing to unify with a rigid variable to maybe improve the error message
13:19:02 <monochrom> type errors cannot be descriptive. type errors are conflicts between several things. can't say which party is being wrong.
13:19:10 <mekeor> Mandarin: the number of digits of a number is \n -> floor (logBase 10 n) + 1.
13:19:12 * hackagebot persistent-protobuf 0.1.5 - Template-Haskell helpers for integrating protobufs with persistent. (MichaelStone)
13:19:30 <scry1> mysticc: http://www.haskell.org/haskellwiki/Tags#Haskell_tag_generators and http://www.haskell.org/ghc/docs/6.10.2/html/users_guide/utils.html
13:20:22 <effereti> monochrom: I suppose i expected to see "error in line (some line near the end of the function)"
13:20:31 <danil> monochrom: they *can* be more helpful in identifying just which parties are involved, which is what impressed me about Mu
13:20:34 <monochrom> in this case, who is to guess that "-> Parser b" is being the wrong guy? given that, obviously "manyTill anyChar termPar" seems like the wrong guy. once you assume that, it further narrows to termPar, naturally
13:21:07 <monochrom> does Mu identify the "-> Parser b" party?
13:21:32 <mekeor> Mandarin: and n is growing exponentially. so, (map (\n -> floor (logBase 10 n) + 1) (iterate (*2) 1) is growing linearly, i think.
13:21:36 <monochrom> that is, does Mu suspect your type sigs too, not just suspect subexpressions?
13:24:05 <effereti> anyone using Yi here?
13:24:25 <mekeor> i've installed it, but not using.
13:24:39 <danil> monochrom: I'm not sure, but I think it could.  He only demoed it briefly, but my guess is that it just keeps track of where each concrete type came from.  So in this case, it would say that both the 'st' and the '()' came from the type signature.
13:25:14 <danil> monochrom: of course, if you have more than one thing that assumes A and more than one thing that assumes B it's not going to be able to tell you all of them (too much bookkeeping)
13:25:41 <monochrom> I know only one kind of helpful type errors. it tells you the whole inference process, so you can step through it and compare with your guess. this also means a very slow algorithm.
13:26:02 <johnw> slowness at error generation time isn't that bad of a thing
13:26:16 <johnw> it's not a case you usually need to optimize for
13:26:19 <monochrom> true
13:26:37 <danil> well, the constraint-based formulation of HM doesn't imply an order to solve the constraints in
13:26:40 <monochrom> run the fast algorithm. hit an error, re-run slow algorithm to explain
13:26:46 <johnw> yeah, that sounds good
13:26:54 <mekeor> > map (sum . flip take (map (\n -> floor (logBase 10 n) + 1) (iterate (*2) 1))) [1..]
13:26:57 <lambdabot>   [1,2,3,4,6,8,10,13,16,19,23,27,31,35,40,45,50,56,62,68,75,82,89,96,104,112,...
13:27:00 <johnw> it's a cost well worth spending
13:27:42 <danil> there's been some work on showing the whole conflict graph when there's an error, and on pruning it to guess which things are wrong (basically telling you the fewest number of edges to remove to make it consistent)
13:28:20 <monochrom> I don't actually want it to guess. show me the whole thing. I do the guessing
13:29:12 <monochrom> it is the same thing as: if my program gives wrong answers or crashes, don't guess why, show me the execution trace, I do the guessing
13:30:08 <johnw> I agree.  Showing me with a marker where you might prune something is OK, but show me
13:30:49 <dmwit> Mandarin: cute
13:34:35 <ique> Hey, I'm using a matrix as my fundamental datatype for a project (cluster analysis) and it gets _a lot_ of "random" access reads. So i'm currently running benchmarks between using Data.Vector and Data.Vector.Unboxed (unboxed for each row and boxed for outer structure), Repa, and UArray with a tuple as index and I'm finding that Repa get's a better results, anyone have experience with matrices?
13:35:45 <ique> I'm afraid my benchmarks might be badly formed: http://hpaste.org/72797
13:38:33 <iamtakin1iteasy> > let; f x y = x * y; g x = x - 1;  in {- how to make more strightforward this part: -} (f . g ) 3 2 {- ? -}
13:38:35 <lambdabot>   4
13:39:01 <iamtakin1iteasy> so it won't be like `(f . g)` and two mysterious numbers one after another
13:39:31 <Cale> (f . g) 3 2 = f (g 3) 2
13:40:19 <Cale> Or you could simplify the entire thing to 4, lol
13:40:30 <typoclass> iamtakin1iteasy: if g is really "x - 1", you might use the standard function "pred"
13:40:31 <mekeor> :D
13:40:41 <danil> ique: I used hmatrix a bit, mostly for the blas/lapack stuff it has.  Nothing's obviously wrong with those benchmarks, but you probably want to vary the array sizes a bit, especially if you're going to end up using big ones.
13:42:14 <finnrobi> what's a good project to check out to learn about project structure and code standards?
13:42:42 <iamtakin1iteasy> typoclass: Cale nope, it is just (over)simplified example. the real code is: http://hpaste.org/72798
13:43:06 <iamtakin1iteasy> the point at line #38
13:44:05 <ReinH> Hi folks
13:44:05 <iamtakin1iteasy> i am not even sure if i can remove operateValue's `stack` argument to make it more cryptic
13:44:05 <Cale> you can remove one of the two occurrences of stack if you'd like
13:44:05 <Cale> er
13:44:05 <Cale> no
13:44:09 <Cale> because it would entail removing the other
13:44:15 <Mandarin> dmwit: tell that to haskell :)
13:44:18 <Cale> I guess you could use join :)
13:44:21 <Cale> hah
13:44:36 <Cale> operateValue f = join (setValue . f . currentValue)
13:45:46 <ReinH> So for my chess engine I created a type: data Square' a = Empty | Occupied a; type Square = Square` Piece; it's basically just a Maybe with better semantics. I'm wondering if there are ways to use that isomorphism to maybe this code any cleaner:
13:45:50 <ReinH> https://gist.github.com/a8a03d7801a36672e0cb
13:46:13 <ReinH> *to make this cod ecleaner
13:46:20 <ReinH> ok I give up on typing, I think you get the point ;)
13:46:26 <iamtakin1iteasy> Cale: omg. it worked even without monadic context i am aware of. may you give some literature on join function?
13:46:36 <latro`a_> how exactly is that better semantics than Maybe
13:46:48 <ninegrid> when i cabal install compact-string i get a not in scope error for `userErrors', how do i fix this?
13:46:50 <ion> The Cod eCleaner™ sounds great. Where can i sign up for your newsletter?
13:46:52 <Cale> iamtakin1iteasy: It's join for the function monad
13:47:02 <fmap> iamtakin1iteasy: you can even remove `f' argument..
13:47:02 <Cale> ((->) r) is a monad for any fixed r
13:47:03 <ReinH> latro`a_: it allows me to later on make a distinction between a char that represents a square (Just Square) and a char that doesn't (Nothing)
13:47:07 <monochrom> by the equation "meaningful name = semantics"
13:47:12 <iamtakin1iteasy> oh
13:47:23 <Cale> join :: m (m a) -> m a
13:47:25 <Cale> specialises to
13:47:28 <latro`a_> um
13:47:30 <latro`a_> ReinH
13:47:33 <iamtakin1iteasy> amazing
13:47:35 <Cale> join :: (r -> (r -> a)) -> (r -> a)
13:47:36 <latro`a_> that means you just want Maybe (Maybe a)
13:47:37 <latro`a_> later
13:47:46 <ion> @djinn (r -> r -> a) -> (r -> a)
13:47:47 <lambdabot> f a b = a b b
13:47:47 <iamtakin1iteasy> thinking about functions as monads really makesme carve my skull
13:47:55 <ReinH> latro`a_: you don't see any value in using labels from the domain of knowledge when specifying types?
13:48:01 <monochrom> functions are not monads
13:48:03 <latro`a_> there's some value I guess
13:48:04 <typoclass> iamtakin1iteasy: if i'm reading this correctly, you could replace it with "flip setValue stack . f . currentValue stack", or possibly "(\x -> setValue x stack) . f . currentValue stack" if you prefer
13:48:09 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; w <- length; return (x,y,z,w)) "hello"
13:48:11 <lambdabot>   ("hello","olleh","HELLO",5)
13:48:14 <ion> iamtakin1iteasy: http://heh.fi/haskell/functors/#function-instance
13:48:14 <Cale> iamtakin1iteasy: ^^
13:48:26 <Cale> look at my example there, and you should get the idea
13:48:33 <iamtakin1iteasy> thanks!
13:48:51 <ReinH> latro`a_: so you would just keep type Square = Maybe Piece ?
13:48:55 <ique> danil: thanks, gonna add hmatrix as well. And good tip about different sizes, I will indeed be using larger matrices
13:49:15 <latro`a_> maybe @ ReinH, depends how often the Maybe (Maybe a) case comes up
13:49:20 <typoclass> iamtakin1iteasy: (i think when you mentioned "mysterious numbers far from where they belong", you meant the one "stack" that is far from the setValue, right? that's a smart observation, by the way)
13:49:24 <latro`a_> I agree that the nested Maybe case obscures the semantics somewhat
13:49:53 <ReinH> latro`a_: I have a choice to make: what do I do with a Char outside the domain of "chars that represent pieces"
13:50:06 <typoclass> iamtakin1iteasy: er, i also forgot some parens earlier, but it should be obvious 8-)
13:50:10 <ReinH> latro`a_: I have to chose between "it's an empty square" and "it's an error condition"
13:50:12 <iamtakin1iteasy> typoclass: well, it just not obvious for me that one 'stack' binds to setValue and other to point-free expression as whole
13:50:33 <typoclass> iamtakin1iteasy: absolutely. if you ask me, you got that exactly right
13:50:34 <ReinH> latro`a_: if I chose the former, like here, then readSquare has to deal with the Maybe ( Maybe Piece ) situation and that's probably it
13:51:02 <ReinH> latro`a_: if I chose the latter, then I will probably fail early when I do IO, so wither way it should only come up in one place
13:53:17 <ReinH> latro`a_: I think it might be nice once the data enters the board's type system to refer to squares as empty or occupied rather than nothing or just, which is why I wanted to add the Square type
13:53:27 <dmwit> Choosing between your data type and a type synonym for Maybe is an aesthetic choice.
13:53:32 <dmwit> So, "go with your heart".
13:53:52 <latro`a_> this is all aesthetics, yeah
13:54:09 <dmwit> As for how to use the isomorphism with Maybe to clean up code, well... that code looks pretty clean to me already.
13:54:11 <ReinH> well, naming things is both hard and important
13:54:27 <danil> ReinH: an option in between is to use Maybe but define empty = Nothing and occupied = Just; it gets a bit awkward for pattern matching though
13:54:43 <applicative> finnrobi: not sure I follow, are you looking for something like exemplary projects, well organized Hackage packages so to say?
13:54:54 <ReinH> I could at least derive Functor and Monad using the derive package right?
13:55:23 <ReinH> hmm
13:55:29 <danil> functor you can derive with -XDeriveFunctor; I'm not sure if derive will get you Monad too
13:55:36 <ReinH> oh right
13:55:57 <ReinH> I was just reading that yesterday, silly me
13:55:59 <dmwit> Seems a bit unlikely that you'll want to derive Monad for this.
13:56:11 <dmwit> s/derive Monad/use Monad methods/
13:56:41 <ReinH> yeah
13:56:55 <ReinH> I thought join might simplify things a bit
13:57:12 <ReinH> but I'm not really using Square as a monad per se, you're right
13:57:50 <ReinH> wait, join is monomorphic so I can't join Maybe (Occupied piece) anyway, right?
13:58:24 <danil> monomorphic isn't that thing you mean, but yes
13:58:27 <ReinH> sorry
13:58:46 <ReinH> I meant that the monads have to be of the same type
13:58:53 <ReinH> what is the thing I mean?
14:01:20 <danil> "join isn't that polymorphic", maybe.  Both (\a b -> head [a, b]) and const are polymorphic, but you could say const is more polymorphic because it doesn't require the two type variables to be the same
14:01:24 <monochrom> newtype Square a = Square (Maybe a)
14:01:42 <monochrom> actually, newtype Square = Square (Maybe Piece)
14:01:52 <ReinH> monochrom: I don't think I need that?
14:02:06 <monochrom> no, just another option
14:02:08 <ReinH> right
14:02:40 <applicative> ninegrid compact-string is deprecated.  Interestingly though there is compact-string-fix that uses the newer exceptions machinery
14:02:45 <ReinH> monochrom: once I'm dealing purely with boards and squares I want the simplest representation of Squar epossible
14:02:56 <ReinH> so I think I'll stick with type Square = Maybe Piece
14:03:18 <ReinH> and the weirdness of Maybe ( Maybe Piece ) will also be a reminder that something odd is going on (error condition checking)
14:03:21 <scry1> > :t (do x <- id; y <- reverse; z <- map toUpper; w <- length; return (x,y,z,w))
14:03:21 <ReinH> seems ok
14:03:22 <lambdabot>   <no location info>: parse error on input `:'
14:03:27 <scry1> :t (do x <- id; y <- reverse; z <- map toUpper; w <- length; return (x,y,z,w))
14:03:29 <lambdabot> [Char] -> ([Char], [Char], [Char], Int)
14:03:41 <scry1> which monad is that?
14:04:03 <scry1> i get "no instance for Monad ((->) [Char])
14:04:14 <iamtakin1iteasy> no Show instance?
14:04:19 <applicative> import Control.Monad.Instances
14:04:28 <scry1> No instance for (Monad ((->) [Char]))
14:04:32 <iamtakin1iteasy> mrm, then i am wrong
14:04:50 <latro`a_> it's in Control.Monad.Instances yeah
14:06:02 <scry1> ah, ty, i searched hoogle, but ...
14:06:09 <latro`a_> I think doing case join sq of ...
14:06:14 <latro`a_> is quite clear
14:06:15 <latro`a_> @ ReinH
14:06:34 <scry1> does it not give instances? how would you find something like that
14:06:54 <latro`a_> finding something involving (->) would probably be hard
14:07:16 <parcs`> can arbitrary data types with a storable instance be arguments to an ffi-imported function?
14:07:33 <applicative> scry1: Yeah, I that would be hard to search for
14:07:41 <Nereid> (->) is the best
14:07:59 <edwardk> nand`: just changed out all the type signatures on you =P
14:08:37 <edwardk> getters and folds are no longer quite so polymorphic in their result type
14:09:22 <ReinH> latro`a_: actually if I write readPiece as a total function Char -> Maybe Piece where unknown chars are Nothing then readSquare = readPiece
14:09:46 <ReinH> latro`a_: and I still get the semantic distiction between Maybe Piece and its isomorphism Square
14:10:04 <ReinH> (Maybe Piece is either a piece or an error, Square is either occupied with a piece or empty)
14:10:35 <latro`a_> I think I see what you're going for
14:10:40 <ReinH> and later if I decide to fail fast on unknown chars I still have a nice seam to break
14:11:04 <ReinH> latro`a_: what I wanted to do was make the semantic distinction between Maybe Piece and Square more clear
14:11:08 <dmwit> parcs`: No, there's a very small collection of types which may be arguments to FFI functions.
14:11:41 <nand`> edwardk: in 1.7.1 or in git?
14:11:55 <dmwit> the variations on Ptr, the C* types (CInt, CDouble, etc.) and I think that's sort of it
14:11:57 <latro`a_> ReinH, to me it's not at all unclear if Square's Nothing is an error, its Just Nothing is an empty square, and its Just somePiece is an inhabited square
14:12:04 <latro`a_> but again, this is just aesthetics
14:12:08 <edwardk> pushing right now to git
14:12:13 <edwardk> i've got some haddocks to clean
14:12:20 <edwardk> pushed so you can get a feel for it
14:12:21 <nand`> k
14:12:22 <ReinH> latro`a_: right now type Square = Maybe Piece, not Maybe ( Maybe Piece )
14:12:27 <latro`a_> I know
14:12:32 <latro`a_> but you could model it the way I just described
14:12:32 <ReinH> ok
14:12:35 <ReinH> yes true
14:12:38 <dmwit> What is with all these people with backticks in their name.
14:12:38 <parcs`> dmwit: that's unfortunate. i wonder why that limitation exists
14:12:51 <edwardk> it makes the types for the fold operations a lot less horrific
14:12:55 <latro`a> in my case the symbol should be an ', because it's from a foreign language
14:12:59 <ReinH> latro`a: ok I see what you mean
14:13:01 <latro`a> but ' isn't valid, so ` instead
14:13:09 <ReinH> latro`a: readSquare should be Maybe Square to represent an error when reading a square
14:13:12 <parcs`> dmwit: i lost my password to the 'parcs' name so i copied ski and appended a backtick to my new name
14:13:14 <dmwit> parcs`: Because it makes marshalling easy, I guess.
14:13:15 <ReinH> since there are chars that are not a piece or an empty square
14:13:20 <dmwit> parcs`: hahaha
14:13:52 <latro`a> ReinH, that's true, if you have functions that try to return Squares it would be nice if their Nothing was an error in getting a square
14:13:59 <ReinH> yes
14:14:12 <ReinH> thanks for the clarification
14:14:19 * hackagebot kevin 0.1.5.3 - a dAmn  IRC proxy (JoelTaylor)
14:14:37 <joevandyk> I have this: data Hand = Hand [Card]. I want to map over the cards in the hand and calculate the score. But I get the following error: Couldn't match expected type `[Card]' with actual type `Hand'
14:14:42 <ReinH> latro`a: then that goes all the way up to readBoard -> Maybe Board right?
14:14:43 <joevandyk> but [Card] is a Hand?
14:14:53 <joevandyk> map (\c -> fromEnum $ rank c) hand
14:15:05 <dmwit> No, [Card] is not a Hand.
14:15:06 <ReinH> latro`a: or I can make the decision at some level that all unknown chars are an empty square
14:15:07 <geekosaur> no, [Card] is a list.  Hand requires a constructor
14:15:28 <dmwit> If v :: [Card], then Hand v is a Hand.
14:15:42 <dmwit> Likewise, if Hand v is a Hand, then v is a [Card].
14:15:53 <applicative> joevandyk: you  could just say  'type Hand = [Card]'
14:16:02 <danil> ReinH: you could also use Either for errors, which has the advantage of both avoiding possibly-confusing nesting and providing error messages
14:16:08 <ReinH> joevandyk: as an aside, if a hand has an fixed number of cards you might prefer to define it as a tuple so that invalid number of cards = invalid type
14:16:15 <ReinH> danil: that's true
14:16:23 <joevandyk> ReinH: not fixed number of cards
14:16:26 <nand`> edwardk: I'm trying to think of situations where this change will break something that was possible before; are there any?
14:16:37 <edwardk> nothing should break if you wrote legal lenses
14:16:39 <ReinH> joevandyk: ok please proceed ;)
14:16:53 <scooty-puff> i'm having trouble with type-indexed identifiers and a monad to supply them - have MonadIdent i m where newIdent :: Index a -> m (i a), where Index :: forall k . k -> *
14:16:56 <Veinor> ReinH: mehhhh. i'd only be in favor of doing that if the number is small, and you never need to use the nice stuff that [] gives you, like map or fold or whatever
14:17:06 <scooty-puff> and the functional dependency on MonadIdent i m | m -> i
14:17:06 <ReinH> Veinor: fair
14:17:15 <joevandyk> map (\c -> fromEnum $ rank c) hand -- hand is a Hand. Why does the error say "expected [Card]"?
14:17:16 <edwardk> you could in theory have had someone pass you a Lens a b c d that you go to 'view' etc, but really you should have been able to get it as a Simple Lens a c at that time
14:17:21 <ReinH> danil: I guess I have to decide between being maximally accepting of input in the unixy sense or failing fast on invalid boards
14:17:38 <edwardk> so in the limited scenarios you can't apply this you don't actually have a lens ;)
14:17:47 <dmwit> joevandyk: Because map (\c -> fromEnum $ rank c) is a function that acts on [Card] values.
14:17:54 <nand`> right
14:18:09 <applicative> joevandyk:rank attaches to Card, so if your map assumes hand is a list of them
14:18:10 <nand`> any way, sounds cool - the phantom b/d types were a bit confusing at times
14:18:12 <edwardk> it cleans up a hell of a lot of signatures
14:18:21 <ReinH> dmwit: it's easy to use some error-handling functor (Maybe, Either) to read Maybe Board and fail at the IO level if the board is invalid
14:18:22 <joevandyk> dmwit: bah. so what's the way to sum up the rank of a Hand?
14:18:23 <scooty-puff> is there such a thing as a kind for a :: (forall k . k -> *)
14:18:35 <joevandyk> ranks of a Hand, I mean
14:18:38 <ReinH> dmwit: but it's also easy to assume unknown char = empty square and just go right on ahead building the board
14:18:50 <dmwit> joevandyk: Write "unHand (Hand v) = v" and then "map (...) (unHand hand)".
14:18:51 <edwardk> i also only have a few more modules to have the documentation fully hyperlinked throughout -- haddock is a pain
14:18:56 <danharaj> edwardk: should (^!) be infixl or infixr? infixr would allow chaining of ^! on actions.
14:18:59 <ReinH> well Functor f => f Board ofc
14:19:03 <parcs`> dmwit: the struct is just 4 Word8s. would using an Int32 in place of the struct in the type of the ffi import work?
14:19:04 <dmwit> joevandyk: Or just use "type Hand = [Card]", as somebody suggested above, if you don't mean to have a separate type.
14:19:05 <edwardk> you chain with .
14:19:05 <danil> scooty-puff: yes, but you can't write them in kind signatures yet IIRC
14:19:06 <Veinor> joevandyk: do you want there to be a difference, semantically, between a Hand and a list of cards?
14:19:16 <dmwit> parcs`: Not portably.
14:19:19 <edwardk> there was a reason for the other fixity, i just forget it =)
14:19:23 <joevandyk> Veinor: I'm not sure yet.
14:19:32 <latro`a> so many layers of Maybe @ ReinH
14:19:37 <ReinH> latro`a: :)
14:19:38 <joevandyk> dmwit: I'm not sure if Hand should be a separate type yet.
14:19:41 <edwardk> it came up with ^.
14:19:42 <Veinor> if you don't, just write type hand = [Card], as applicative suggested
14:19:43 <latro`a> maybe it'd be better to do it in the Maybe monad instead
14:19:48 <ReinH> latro`a: it really just hinges on what I want to do with invalid input: be accepting or fail fast
14:19:50 <scooty-puff> danil: and i assume definitely not in type class instances
14:19:51 <danharaj> edwardk: weird. I guess I messed up the first time I tried that :P
14:19:56 <ReinH> and that's a decision I have to make for myself
14:19:59 <Veinor> if you do, use dmwit's unHand solution (or do data Hand = Hand { unHand :: [Card] })
14:20:01 <latro`a> like
14:20:06 <edwardk> danharaj: foo^!bar.baz not working for you?
14:20:16 <danharaj> it is now
14:20:16 <latro`a> try to read the board, if it's completely the wrong format fail, if it's the right format try to check each square, if the square fails then fail through, etc.
14:20:17 <danil> scooty-puff: ghc will infer them (hopefully) if you turn on -XPolyKinds, but if it doesn't you have no recourse until 7.6
14:20:17 <dmwit> parcs`: (The layout of structs in memory changes a lot from architecture to architecture.)
14:20:30 <danharaj> I think I know what I got wrong earlier.
14:20:33 <edwardk> how are the actions working out?
14:20:34 <latro`a> then the Maybe monad would automatically propagate your failures
14:20:42 <ReinH> latro`a: well I just compose readBoard of readSquare and fmap makes any error halt computation right?
14:20:50 <edwardk> i wish i had a good story for monadic setters
14:21:34 <dmwit> ReinH: Why not both?
14:22:04 <danharaj> edwardk: I like how I can do arr!^writeA i1 x1 . writeA i2 x2 ....
14:22:05 <dmwit> ReinH: Output a successful parse and a collection of warnings telling which squares got defaulted to empty outside the spec.
14:22:12 <scooty-puff> danil: i think that was it - i missed a module when adding PolyKinds
14:22:14 <ReinH> dmwit: yes
14:22:17 <latro`a> ReinH, you want to be able to get a Just with invalid data and have that become a Nothing
14:22:20 <latro`a> you need >>= to be able to do that
14:22:55 <ReinH> latro`a: in this case a board is [[Square]] so I need the same but for the list monad
14:23:14 <latro`a> close enough
14:23:17 <ReinH> any Nothing in [[Maybe Square]] = Nothing board, yes
14:23:18 <hpaste> scooty-puff pasted “PolyKinds, foral, AnyK” at http://hpaste.org/72801
14:23:49 <ReinH> or [] board, I guess, which is the same
14:24:08 <ReinH> FSVO "the same"
14:24:22 <scooty-puff> maybe as an associated type it will work better
14:24:26 <latro`a> you could also do Square = Either String (Maybe Piece)
14:24:39 <edwardk> danharaj: oh that doesn't work probably unless the write operation returns the array
14:24:45 <latro`a> that is, you either have an error, no piece but no error, or a piece
14:24:52 <ninegrid> so whats the most succinct databse binding for haskell?
14:24:56 <ReinH> latro`a: I think I want to restrict the error handling to the board building process rather than have it in the board types themselves
14:24:58 <danharaj> edwardk: Yeah that's what I'm doing since writing doesn't return a useful value anyway.
14:25:05 <latro`a> you could do it that way too
14:25:29 <latro`a> this way is a bit more flexible because it lets there be a variety of different error messages during a game
14:25:33 <latro`a> (assuming you add IO later)
14:25:36 <danharaj> I need a combinator for modifying Effects though, so I could have writes that depend on, say, a value from an RNG. That's why I asked about them being monads in the effect value.
14:25:45 <ReinH> latro`a: perhaps
14:25:48 <dmwit> String is such a lousy data type.
14:26:10 <nand`> you think?
14:26:13 <latro`a> but then, there are really only two errors in chess
14:26:25 <edwardk> danharaj: you can always chain another action in to check the rng
14:26:26 <ReinH> latro`a: I have a tension to keep the board very simple so that a) it is more performant and b) it can be replaced more easily with a more performant type if necessary
14:26:33 <latro`a> "you can't do that" and "that's not a character that represents a piece"
14:26:37 <tgeeky> dmwit: perhaps the availability of type-level strings will finally deprecate value-level strings
14:26:54 <ReinH> latro`a: "you can't do that" is represented by move :: Board -> Maybe Board
14:27:02 <ReinH> or Either for error reporting
14:27:06 <joevandyk> puts "There are " ++ (show $ length newDeck) ++ " cards in this deck." gives me :    Couldn't match expected type `IO a0' with actual type `[a1]'
14:27:07 <latro`a> true
14:27:08 <monochrom> type-level strings?!
14:27:23 <ReinH> latro`a: the plan is to use functor properties so that I can start with Maybe (simplest error reporting) and move on to Either if I want more
14:27:25 <nand`> joevandyk: precedence
14:27:27 <latro`a> that reminds me of that one derpy fixed point combinator
14:27:31 <edwardk> danharaj: i'm willing to revisit the fixity of ^! and ^. if it helps here, i've just checked and have no real justification for it
14:27:47 <dmwit> joevandyk: Perhaps you meant puts ("..." ++ ... ++ "...")
14:27:47 <latro`a> that spells out t h i s i s a f i x e d p o i n t c o m b i n a t o r
14:27:48 <joevandyk> Ah, I need a $ after puts
14:27:57 <joevandyk> need to remember the rules
14:28:13 <danharaj> edwardk: My justification turned out to be bunk so it's fine :P I'm not sure how to add an rng call to the chain, I'll try it now.
14:28:14 <ReinH> joevandyk: rule: when in doubt add some $
14:28:19 <ReinH> also a perfectly valid life rule
14:28:23 <latro`a> lol
14:28:28 <dmwit> Also, I find (foo $ bar) quite amusing, considering the usual defense of ($) being that it removes parentheses.
14:28:35 <dmwit> just foo (bar) instead
14:28:36 <edwardk> i'm working with dolio here to see if we can make the infixr 8 ^. make sense
14:28:42 <nand`> (L L L L L L L L L L L L L L L L L L L L L L L L L L) where L = λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
14:28:46 <latro`a> yes that one
14:29:11 <parcs`> i'm getting "Warning: accepting non-standard pattern guards (use -XPatternGuards to suppress this message)" for the guard 'key > 0, key < 256'
14:29:18 <parcs`> what is non-standard about that?
14:29:23 <dmwit> the comma, probably
14:29:27 <latro`a> the comma, yeah
14:29:33 <latro`a> you can use &&
14:29:38 <latro`a> without PatternGuards
14:29:43 <joevandyk> If I want to print an integer, I need to do: putStrLn $ show 3, right?
14:29:52 <dmwit> That works fine, yes.
14:29:58 <scooty-puff> will using AnyK act as a workaround, AnyK -> * for forall k . k -> *
14:29:59 <latro`a> without any context whatsoever, that will give an ambiguous type
14:30:03 <parcs`> aren't pattern guards a part of h2010?
14:30:05 <latro`a> @ joevandyk
14:30:07 <dmwit> You can also use print 3, putStr $ show 3, printf "%d" 3, or half a dozen other things.
14:30:42 <joevandyk> why does `print 3` work?
14:30:47 <edwardk> i'm sticking to infixl, we managed to show you can't use the other one meaningfully without impredicativetypes turned on
14:30:52 <c_wraith> print = putStrLn . show
14:30:53 <dmwit> because print x = putStrLn (show x)
14:30:57 <joevandyk> ah
14:31:07 <danharaj> edwardk: okeydokey.
14:31:17 <joevandyk> i thought it just didn't add the newline
14:31:29 <edwardk> so you need to call the rng to get the element to look up or something?
14:31:36 <c_wraith> nah, putStr is the one that leaves out the newline. And it only works with String
14:32:49 <danharaj> edwardk: well, say I want to write something depending on the RNG, but I think I figured it out: Make the rng an Action polymorphic in the second type argument?
14:32:57 <ReinH> latro`a: if I have [[Maybe a]] and I want a Maybe b where any Nothing in the list of lists = Nothing, what are my options? (Specifically [[Maybe Square]] -> Maybe Board)
14:33:21 <edwardk> danharaj: just write the imperative function writeM :: ValueToWrite -> YourArray -> m YourArray -- for your monad m, and lift it using write v = act . writeM; then foo^!write value can write to whatever random place the writeM code picked
14:33:43 <latro`a> if any isNothing (concat listoflistofmaybes) then Nothing else ...
14:33:47 <latro`a> seems simplest
14:33:49 <joevandyk> Thanks all. Here's where I'm at now: https://github.com/joevandyk/haskell/blob/3f79a81e289b855bcb64424d64ba9c1db319ec12/blackjack.hs Any obvious stupid things?
14:34:02 <ReinH> latro`a: ok that was my thought, I was wondering about any magic functor properties
14:34:06 <danharaj> edwardk: Mm, so compose first, then lift the whole thing when I want to use it as an action.
14:34:15 <edwardk> yeah
14:34:25 <latro`a> I don't think there's any other way to do it because you've got two different functors
14:34:30 <joevandyk> this is sort of fun :)
14:34:34 <ReinH> latro`a: ok ty
14:34:49 <danharaj> I am not a very good two-dimensional composition programmer, it seems.
14:35:32 <edwardk> programming with actions has all the same pain points as programming with arrows, sans the sugar ;)
14:35:40 <latro`a> with explicit recursion you could start building the Maybe Board up
14:35:44 <latro`a> and then return Nothing partway through
14:35:45 <latro`a> I think
14:35:46 <latro`a> but
14:35:46 <latro`a> eh
14:36:16 <edwardk> actually belay that. you _can_ use arrow sugar
14:36:18 <nand`> nice, “focus gen (state random)”
14:36:18 <typoclass> joevandyk: looks pretty good to me :) congrats
14:36:22 <edwardk> you use the arrow sugar for (->)!
14:36:29 <edwardk> so you can compose lenses with arrow sugar
14:36:54 <edwardk> not sure what that looks like in the end
14:36:58 <nand`> what does arrow syntax even look like?
14:37:05 <danil> :t sequence . map sequence -- ReinH
14:37:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
14:37:14 <ninegrid> i'm curious as to why, when following the mongodb driver quickstart that something like this: access pipe master "test" allCollections ~ implicitly treats "test" as the type Database (which is Data.Text) rather than [Char], however, when doing this in ghci it reats "test" as [Char] and i need to load the Data.Text module and pack it
14:37:40 <danharaj> edwardk: wouldn't it 'flow backwards' because we're composing backwards?
14:37:44 <edwardk> yes
14:37:49 <edwardk> the arrows read backwards
14:37:54 <edwardk> like they do for my linear map arrow
14:38:20 <latro`a> ah
14:38:20 <typoclass> nand`: never used it, but i think it involves lots of "-<"
14:38:22 <latro`a> danil is right
14:38:36 <edwardk> linear maps between vector spaces (b -> r)  and (a -> r)  form an arrow Map r a b
14:38:37 <danil> ninegrid: you may not have -XOverloadedStrings set in ghci, and you might be being bitten by ghci's more aggressive defaulting rules
14:38:37 <Botje> ninegrid: maybe you didn't enable OverloadedStrings in ghci?
14:38:51 <parcs`> ninegrid: the OverloadedStrings extension makes string lits polymorphic like integer literals are
14:38:52 <Nereid> ninegrid: maybe you want -XOverloadedStrings?
14:38:57 <edwardk> and all the arrow operations on them (and monad operations) are legal linear transformations
14:38:57 <parcs`> damn
14:39:00 <Nereid> lol
14:39:04 <danharaj> cool
14:39:42 <edwardk> now i need to check what happens with the arrow operations on parts of lenses
14:39:57 <danharaj> so the Action machinery is really just Const applied to a monadic value. I guess there's no real analogue for Identity to get something for Setters.
14:40:05 <ReinH> danil: oh. that's what sequence does.
14:40:07 <ReinH> <3
14:40:10 <otto_> how do i convert int to string?
14:40:17 <danharaj> > show 3
14:40:19 <lambdabot>   "3"
14:40:26 <otto_> ty
14:40:28 <edwardk> danharaj: yes and no, you could in theory swap Identity in there, and basically get the monadic value
14:40:29 <ReinH> danil: so monadic properties, not functor properties. Got it.
14:40:31 <ReinH> very nice, thanks
14:40:36 <edwardk> but it gets messy
14:40:46 <edwardk> because the quantification story for it when you mix it with other setters is wrong
14:40:47 <latro`a> not exactly monadic properties; that one is special with how monads interact with lists in particular
14:41:05 <latro`a> but yes, sequence is snazzy
14:41:10 <edwardk> getters/folds are universally polymorphic in the monad.
14:41:18 <edwardk> setters on the other hand would drift existential
14:41:21 <ninegrid> danil, Botje: when I do :l mystuff.hs, does ghci not interpret the language pragma?
14:41:21 <ninegrid> i suppose i've answered my own question with the results of this excersize
14:41:21 <ninegrid> thank you both
14:41:29 <ReinH> danil: bloody brilliant, thank you
14:41:42 <danil> ninegrid: it does for the file you load, but it doesn't change what you have on at the prompt
14:41:45 <danharaj> edwardk: curious and messy duality. do you have a code scrap on the subject?
14:41:46 <Nereid> ninegrid: you can :set -XOverloadedStrings in ghci
14:41:52 <Nereid> if you don't want to restart it
14:41:55 <edwardk> not that i've kept
14:42:02 <edwardk> i did one at hac phi with dmwit
14:42:07 <ninegrid> Nereid: alright, thanks
14:42:14 <dmwit> ninegrid: ghci and your file have separate flags
14:42:27 <edwardk> speaking of which, dmwit, i got actions to work ;)
14:42:28 <danharaj> I'll copy the Action code and try to replace Consts with Identys then.
14:42:37 <joevandyk> btw, searching google for 'hunit' brings up this page: http://hunit.sourceforge.net/ which seems to be very outdated
14:42:44 <dmwit> edwardk: oh, nice!
14:42:49 <dmwit> What's new?
14:42:59 <joevandyk> links to http://hunit.sourceforge.net/HUnit-1.0/Guide.html, which says to do 'import HUnit', which no longer works
14:42:59 <edwardk> basically swapped the way i was plumbing them
14:43:25 <hpaste> scooty-puff pasted “PolyKinds troubles” at http://hpaste.org/72803
14:43:32 <edwardk> getter was type Getter a c = forall f. Gettable f => (c -> f c) -> a -> f a
14:43:32 <dmwit> hm =)
14:43:38 <joevandyk> is HUnit the best way to unit test stuff, other than quickcheck?
14:43:41 <dmwit> Oh, good, there's more text on the way. =P
14:43:54 <edwardk> and fold is type Fold a c = forall f. (Gettable f, Applicative f) => (c -> f c) -> a -> f a
14:44:05 <edwardk> Gettable you may recall was 'anyvariant' with coerce :: f a -> f b
14:44:08 <ParahSailin_> this code works fine-- i just wonder if thats the nicest way to write it http://hpaste.org/72804
14:44:19 <ReinH> :t mapM sequence -- danil
14:44:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
14:44:29 <latro`a> ...indeed
14:44:31 <Nereid> ParahSailin: instead of "x <- return y" use "let x = y"
14:44:34 <edwardk> Then: type Action m a c = forall f r. Effective m r f => (c -> f c) -> a -> f a
14:44:44 <edwardk> Where class (Monad m, Gettable f) => Effective m r f | f -> m r where  effective :: Isomorphic k => k (m r) (f a)
14:44:49 <danil> ReinH: oh, yes.
14:44:50 <n-dolio> Effective?
14:44:53 <edwardk> is the isomorphism we were chasing
14:44:54 <n-dolio> Like, in the effective topos?
14:45:11 <edwardk> as in 'has an effect' ;)
14:45:12 <dmwit> right, good
14:45:24 <Nereid> ParahSailin_: *
14:45:50 <edwardk> then Every Getter works as an Action that doesn't use the effect plumbing
14:46:09 <edwardk> and i swapped all the code for working with getters and folds to stay in the 'anyvariant' applicative
14:46:18 <edwardk> rather than come down to the monoid
14:46:20 <edwardk> and it all works
14:46:32 <acowley> edwardk: I started using lens yesterday and nothing caught fire!
14:46:32 <dmwit> cool =)
14:46:38 <shapr> don't come the raw monoid to me!
14:46:40 <edwardk> acowley: great!
14:46:58 <ParahSailin_> Nereid: cool wizardry
14:47:21 <typoclass> joevandyk: i'm pretty happy with doctest as well. your unit tests double as code examples in the documentation, which is always good
14:47:33 <latro`a> I wonder if I'd be OK using haskell in a scientific computing course
14:48:05 <S11001001> ParahSailin_: shuffled = (liftM2 (altShuffle lines `on` P.lines) `on` readFile) input1 input2
14:48:15 <joevandyk> typoclass: huh, interesting
14:49:23 <S11001001> ParahSailin_: unless your readFiles and P.lineses are constrained differently in each case, but a nice liftM2 should still fit in there
14:49:59 <edwardk> acowley: 1.8 will have nicer looking type signatures, a better test suite and i'm hoping i'll have the tutorial done by then
14:50:08 <edwardk> i may release it before the tutorial is ready though
14:50:20 <ParahSailin_> :t on
14:50:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:50:22 <edwardk> i have the start of the writeup at least
14:50:31 <ParahSailin_> S11001001: even cooler wizardry
14:50:47 <acowley> edwardk: The best part is that it actually worked before I really understood what I was doing
14:50:54 <edwardk> =)
14:51:11 <edwardk> thats a good sign
14:51:31 <acowley> edwardk: I just skimmed through the haddocks looking for something vaguely right-looking, and next thing you know I was poking record fields in a state monad
14:51:38 <edwardk> =)
14:52:17 <Nereid> why not (liftM2 (altShuffle lines) `on` (fmap P.lines . readFile)) input1 input2 or something
14:52:48 <edwardk> as an aside if you want to chain the assignment e.g. both write and read what you wrote you can use the <+= variant   of +=, etc.
14:53:03 <S11001001> Nereid: same reason I f . g <$> x instead of f <$> g <$> x
14:53:04 <edwardk> v <- fresh <+= 1
14:53:13 <Nereid> oh I probably did this wrong.
14:53:48 <Nereid> w/e, something ilke it.
14:53:49 <Nereid> like.
14:53:55 <scooty-puff> danil: ended up just using the slightly inadequite EmptyDataDecls thing instead of higher kinds
14:54:14 <scooty-puff> blah, inadequate spelling of inadequate
14:57:14 <latro`a> actually, has anyone written anything scientific computing-y in haskell?
14:57:23 <latro`a> I know there are libs and bindings to foreign libs and whatnot
14:57:56 <danharaj> http://www.eecs.tufts.edu/~ndaniels/Noah_files/mrfy_experience_report.pdf
14:58:17 <deckeraa> Is it possible to modify the code of a running program on the fly with GHCi?
14:58:19 <latro`a> relevant to my interests, thank you sir
14:58:42 <deckeraa> For example, changing a function and reloading without restarting the child process?
14:59:04 <danharaj> I think GHC supports hot-swapping modules
14:59:32 <ku> What are the top reasons to learn HS?
14:59:39 <joevandyk> there a better way to write this scoreHand function? https://gist.github.com/977b396effb086c0e8b1
14:59:54 <S11001001> ku: The number one reason is to understand the output of @pl better
15:00:01 <danharaj> deckeraa: http://hackage.haskell.org/package/plugins-1.5.2.3
15:00:36 <deckeraa> Thanks danharaj, I'll take a look at that.
15:02:29 <S11001001> @pl \as li pl rf i1 i2 -> as li <$> (pl <$> rf i1) <*> (pl <$> rf i2)
15:02:30 <lambdabot> flip flip (ap (ap . ((flip . (((.) . (<*>)) .)) .) . (.) . (<$>)) ((.) . (<$>))) . (((.) . (.) . (.) . (.) . (<$>)) .)
15:02:47 <Cale> joevandyk: Rather than using == a whole bunch, you could use case.
15:03:10 <S11001001> ku, when you understand what lambdabot just said you will have achieved true..something true.
15:03:21 <n-dolio> Or elem, since they're all the same.
15:03:29 <ReinH> :t mapM . mapM -- danil
15:03:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [[a]] -> m [[b]]
15:03:42 <Cale> case rank card of Jack -> 10; Queen -> 10; King -> 10; Ace -> 11; r -> 2 + fromEnum r
15:04:00 <S11001001> ParahSailin_: incidentally that's another way to write it, if you like applicative style
15:04:40 <ParahSailin_> what is @pl
15:04:57 <ku> @help
15:04:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:05:04 <S11001001> ParahSailin_: I mean what I said to @pl, not the result :)
15:05:04 <ku> @list
15:05:05 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:05:19 <typoclass> ku: for me the advantage that haskell offers is how damn helpful the compiler is. you do most of the debugging at compile-time, and there's little of the frustrating guesswork at runtime that you have in other languages
15:05:38 <joevandyk> Cale: there's an `otherwise` at the end of that, right?
15:05:42 <ReinH> danil: which is quite convenient given that my (a -> m b) is readSquare :: Char -> Maybe Square
15:06:13 <Cale> joevandyk: no? It's not a guard, it's just pattern matching. The last pattern, r, will match anything.
15:06:23 <typoclass> ku: lambdabot is also available in private chat for playing around. and that commands list is not very helpful, so feel free to ask here :) or check the lambdabot page on the haskell wiki. the most-used command is "> "
15:06:28 <typoclass> > 42+1
15:06:29 <lambdabot>   43
15:07:29 <ParahSailin_> what does the @pl command do i mean
15:07:48 <S11001001> ParahSailin_: takes out those nasty lambda expression arguments
15:07:53 <sipa> it converts an expression into pointftee notation
15:07:59 <ion> @pl \x -> foo (bar x)
15:07:59 <lambdabot> foo . bar
15:07:59 <sipa> pointfree
15:08:11 <Nereid> @pl f x = foo (bar x)
15:08:12 <lambdabot> f = foo . bar
15:08:25 <ion> In this case, it gets rid of the point “x”, resulting in equivalent code that may be better or worse than the original.
15:08:36 <ParahSailin_> ah
15:08:39 <sipa> @pl f x y z = x*y+z
15:08:39 <lambdabot> f = ((+) .) . (*)
15:09:01 <scry1> @pl (>>= \x -> reverse x)
15:09:01 <Nereid> @pl f a b c = b (a c)
15:09:02 <lambdabot> (reverse =<<)
15:09:02 <lambdabot> f = flip (.)
15:09:15 <sipa> @unpl ((+) .) . (*)
15:09:16 <ReinH> does Haskell have the (trivial) combinator f a = a . a lying around somewhere?
15:09:16 <lambdabot> (\ d g -> (+) (d * g))
15:09:26 <Nereid> @pl f a = a . a
15:09:26 <lambdabot> f = join (.)
15:09:48 <ReinH> oh I should have just asked pointfree
15:09:52 <ReinH> thanks
15:10:43 <ReinH> er.
15:11:27 <Nereid> @pl f a = g a a
15:11:28 <lambdabot> f = join g
15:11:28 <ReinH> I have a doubt
15:12:32 <ReinH> In any event, (a . a) is cleaner to write/read
15:12:37 <ReinH> I was just curious
15:12:46 <Nereid> depends on how much you like monads
15:13:35 <Nereid> the Monad instance for (->) t gives join :: (t -> (t -> a)) -> (t -> a)
15:14:21 <ReinH> and if a happens to be mapM?
15:15:39 <ReinH> :t join (.) mapM
15:15:41 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
15:15:41 <lambdabot>       Expected type: (a -> m b) -> [a] -> m [b]
15:15:41 <lambdabot>       Inferred type: (a -> m b) -> a -> m b
15:15:48 <ReinH> what does that mean?
15:17:14 <danharaj> :t join (.)
15:17:16 <lambdabot> forall a. (a -> a) -> a -> a
15:17:17 <danharaj> :t mapM
15:17:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:18:29 <ion> Yeah, “join (.)” results in “\f -> f . f” which doesn’t let f to have two types.
15:18:33 <t7> > 60000 / 24 / 60 / 60
15:18:34 <lambdabot>   0.6944444444444444
15:18:34 <ion> s/to have/have/
15:20:43 <ParahSailin_> say i have [[a]] and i want to "zip" all of the [a]'s together, is there some wizardry for that?
15:20:45 <scry1> an infinite type... is the same as no types?
15:20:58 <Reaga> how do i do factorials in haskell?
15:21:04 <Reaga> it'd be so much easier in java
15:21:05 <scry1> product
15:21:11 <Reaga> this language is stupid
15:21:12 <scry1> product [1..10]
15:21:16 <scry1> > product [1..10]
15:21:17 <lambdabot>   3628800
15:21:22 <danharaj> @src product
15:21:22 <lambdabot> product = foldl (*) 1
15:21:46 <Reaga> why isnt haskell used more often
15:21:49 <scry1> how is that easier in Java o.O
15:21:53 <danharaj> ParahSailin: Control.Applicative. In particular, ZipList
15:22:15 <Reaga> what is the biggest (smallest?) bottlenext with regards to improving haskell's popularity?
15:22:37 <sipa> avoid success at all costs
15:22:41 <MostAwesomeDude> Reaga: Well, what makes a language popular?
15:22:47 <ParahSailin_> danharaj: thanks
15:22:48 <danharaj> ParahSailin_: keep in mind that you can only zip as many elements as you expect.
15:23:04 <danharaj> you can't zip an arbitrary number because then you wouldn't know what type to give it.
15:24:14 <scry1> Reaga: teach programming in highschool. teach FP in college. teach haskell in FP
15:24:59 <edwardk> can someone skim through https://github.com/ekmett/lens/wiki/Tutorial and provide initial feedback?
15:25:05 <ReinH> GHC errors: illuminating as always ;)
15:25:07 <typoclass> Reaga: if you ask me, the haddocks for many packages could be better. i think everyone would benefit from that
15:25:22 <ReinH> latro`a: ping
15:26:25 <edwardk> i've just started it, but i'm trying to find the right shape for a decent lens tutorial
15:27:26 <Mandarin> edwardk: I began learning haskell this week so I can read it and try to tell you what I understand :)
15:28:00 <Aune> edwardk, takeing a really shallow look right now
15:28:00 <edwardk> it kind of assumes you already know Functor, Foldable, Traversable
15:28:33 <latro`a> hi ReinH
15:28:37 <edwardk> i'll probably elaborate on the 'extra power' granted by traversable over foldable/functor
15:28:45 <ReinH> edwardk: I would be super happy to review your lens tutorial to see how well it works for a beginner :)
15:28:47 <Mandarin> edwardk: I haven't read about them yet..
15:28:47 <c_wraith> edwardk: the third example appears to have a typo in the type..  the second arg should end with  -> a
15:29:00 <ReinH> latro`a: I came up with a way to read boards and report errors that I think is quite nice
15:29:06 <ReinH> latro`a: through the cunning use of (mapM . mapM)
15:29:14 <edwardk> which one?
15:29:30 <c_wraith> third example in the first block
15:29:40 <edwardk> ah
15:29:41 <latro`a> nice, ReinH
15:30:16 <edwardk> trying to figure out how to throw open wiki access so others can fix stuff
15:30:18 <edwardk> after all its a wiki ;)
15:30:30 <c_wraith> similar typo in the fmap block's third example. :)
15:30:38 <edwardk> heh
15:30:48 <otters> Isn't join (.) redundant?
15:30:58 <c_wraith> you need a type-checker for your block posts :)
15:31:09 <edwardk> heh
15:31:17 <edwardk> :t join (.)
15:31:18 <lambdabot> forall a. (a -> a) -> a -> a
15:31:34 <edwardk> > join (.) (+1) 2
15:31:37 <lambdabot>   4
15:31:40 <edwardk> no ;)
15:31:45 <c_wraith> it looks like id... but it isn't!
15:31:59 <ion> The type matches, it must be the same.
15:32:05 <latro`a> lol
15:32:21 <otters> > join (+1) 2
15:32:22 <typoclass> edwardk: so, the tutorial is written for someone looking to implement a lens library?
15:32:23 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
15:32:26 <otters> oh
15:32:31 <otters> :t join (+1)
15:32:32 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
15:32:32 <lambdabot>     Probable cause: `+' is applied to too many arguments
15:32:32 <lambdabot>     In the first argument of `join', namely `(+ 1)'
15:32:36 <otters> oh, it's because
15:32:38 <otters> okay
15:32:53 <edwardk> typoclass: the current thrust is that i'm trying to motivate the laws of lenses and how to compose them from typeclasses you already know
15:33:18 <ReinH> latro`a: thoughts? https://gist.github.com/923787572e65ae79f6c6
15:33:26 <edwardk> so setters are functors, folds are foldables, traversals are traversables, getters are functions, and lenses are just a traversal that is a valid getter at the same time
15:33:41 <edwardk> and as a result, the laws for all of these things are the same laws you already know
15:33:51 <typoclass> hm ok
15:33:52 <edwardk> just extended to work with monomorphic containers
15:34:01 <latro`a> technically if you're at all concerned with performance I'd use some sort of lookup table
15:34:10 <ReinH> latro`a: yes
15:34:10 <latro`a> but beyond that, very nice
15:34:13 <edwardk> I plan on adding a preamble to that effect ;)
15:34:23 <ReinH> latro`a: now how do I make readBoard accept any Monad m?
15:34:38 <latro`a> by just removing the signature?
15:34:46 <ReinH> then HLint yells at me :)
15:34:49 <ReinH> wait
15:35:12 <latro`a> actually, it shouldn't make sense in an arbitrary monad
15:35:15 <latro`a> because of the type of readSquare
15:35:34 <ReinH> latro`a: I would like to change the type of readSquare from, say, Maybe to Either without changing readBoard
15:35:43 <ReinH> I'm probably trying to solve the Expression Problem
15:36:00 <ReinH> latro`a: like to *be able to* change the type
15:36:33 <latro`a> uh
15:36:40 <latro`a> hm
15:37:05 <ReinH> latro`a: specifically because this is for a tutorial series and I want to show moving from the generic "there was an error" Maybe to the specific "there was an error with string x" Either monad as needed
15:37:20 <latro`a> oh I see
15:37:22 <latro`a> um
15:37:30 <latro`a> one way, which is specific to changing between Maybe and Either
15:37:35 <avpx> ReinH: You seem to be repeating yourself a lot. You may consider using a case expression to make this a bit shorter.
15:37:36 <latro`a> would be to use hush and note
15:38:02 <ku> How can I easily benchmark without memoization getting in the way?
15:38:05 <latro`a> indeed, this can be made much briefer even without a lookup table
15:38:18 <ParahSailin_> @pl asn l = (map head l) ++ asn (map tail l)
15:38:19 <lambdabot> asn = fix (ap ((++) . map head) . (. map tail))
15:38:42 <ParahSailin_> :t ap
15:38:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:39:20 <ReinH> avpx: yes I'll move to a lookup for Char -> Maybe Piece to dry up readPiece
15:39:35 <latro`a> @ ReinH, hush and note are in Control.Error.Util
15:39:51 <ReinH> one sec
15:39:58 <latro`a> unfortunately it's a little bit subtler than that here, because you have two layers
15:40:08 <latro`a> you have an error and you have an absence-which-is-not-an-error
15:41:07 <latro`a> anyway, one thing that would save a lot of repetition (and that I actually noticed even in the original video) would be to check the case of the letter separately for color determination
15:41:18 <avpx> Left "Error message", Right (Nothing), and Right (Just n) could be a fine way to deal with those three cases.
15:41:36 <ReinH> avpx: yes, Square is Maybe Piece
15:41:42 <latro`a> yes, he's trying to work out a way to smoothly move from Maybe (Maybe a) to Either String (Maybe a)
15:41:54 <danil> ReinH: the simplest thing is to take a (String -> m Square) as an argument, replace Right with return and Left with that function
15:41:56 <latro`a> what he has now works fine, but he's trying to figure out how to transition between those two codebases
15:42:03 <latro`a> which basically amounts to using note
15:42:11 <danil> ReinH: that even lets you get the "accept it as a blank space, but give a warning" behavior
15:42:26 <ion> edwardk: It talks about mapOf and fmapOf. They’re the same thing, right?
15:42:35 <edwardk> yeah
15:42:40 <edwardk> i renamed fmapOf to mapOf
15:42:43 <edwardk> fixing
15:43:36 <ReinH> sorry was in a quick meeting thing, reading
15:43:37 <latro`a> example of what I meant, ReinH: readSquare c = readSquare' (if isUpper c then White else Black) (toUpper c)
15:43:55 <latro`a> eh, cleaner
15:43:56 <ReinH> latro`a: right, totes
15:44:11 <latro`a> readSquare c = readSquare' (toUpper c), and then refer to c in a where
15:44:18 <latro`a> to get the color if you found a letter
15:44:18 <ReinH> yep
15:45:12 <ReinH> So I can't parameterize readBoard in a way that I can specify a polymorphic Monad m?
15:45:26 <ReinH> even though it can be inferred if I leave out the type hint?
15:46:29 <ReinH> what I'd like is to be able to change the monad that showSquare uses without having to change the type signature of readBoard
15:46:48 <latro`a> the problem is readSquare, not readBoard
15:46:56 <latro`a> in terms of polymorphism
15:47:17 <ReinH> Let's ignore the repetition for now. Your concerns are duly noted. ;)
15:47:27 <latro`a> that's not what I meant, though, wrt polymorphism
15:47:29 <ReinH> latro`a: I am fine with redefining the type of readSquare
15:47:32 <latro`a> the repetition is a separate issue
15:47:34 <danil> ReinH: see above for my solution, with readBoard :: Monad m => (String -> m Square) -> String -> m Board
15:47:53 <latro`a> isn't that just =<<
15:48:01 <latro`a> oh wait nvm
15:48:39 <ReinH> I'm actually tempted to just let haskell-mode change readBoard's type signature when I change readSquare from Maybe to Either
15:48:58 <latro`a> you should be able to move from Maybe to Either by inserting note in judiciously, though
15:49:26 <dmj> hi, I have an EC2 instance with ghc 7.4.1 and haskell-platform 2012.2. When attempting to configure haskell-platform I get an error saying my ghc installation doesn't work. It tells me libgmp3-dev might be missing, but I did a sudo yum install gmp. Also, runhaskell -v says I have ghc 7.4.1
15:49:33 <ReinH> right now I can move from Maybe to Either by removing the type signature from readBoard ;)
15:49:35 <danil> ReinH: you'd pass in Left, or const Nothing, or (\_ -> tell "Warning: invalid square, assuming blank" >> return Nothing) as needed
15:49:49 <ParahSailin_> how do i make this one stop safely when list elements exhausted? asn l = (map head l) ++ asn (map tail l)
15:50:08 <ReinH> (and telling HLint to shup up about the top-level binding with no type signature)
15:50:11 <mysticc> @hoogle forever
15:50:12 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
15:50:50 <monochrom> "yum install gmp" is likely not enough. you need the "development" files, i.e., the "development" package
15:50:58 <nand`> edwardk: why do you use the verbose name for set but the operator for view?
15:51:04 <gatlin> has anyone successfully installed the orc package from cabal?
15:51:15 <edwardk> nand`: was debating about that
15:51:24 <monochrom> fortunately for me, unfortunately for you, I don't know the yum name for the right package. I only know the ubuntu or debian name. it's libgmp-dev
15:51:30 <edwardk> the fixity for the examples with .~ and ^. is a little tricky
15:51:34 <nand`> edwardk: I think for the lens laws the verbose names might be clearer
15:51:39 <edwardk> yeah
15:51:49 <edwardk> just 'set and view' don't line up so well ;0
15:51:55 <dmj> monochrom: I'm using the generic linux ami, and following instructions from this blog http://jpmoresmau.blogspot.com/2011/04/install-ghc7-and-yesod-on-amazon-linux.html
15:51:58 <nand`> “view l (set l b a) = b”
15:52:03 <monochrom> err libgmp3-dev
15:52:29 <monochrom> after you fix that, you will run into the same problem all over again, this time for openGL
15:52:41 <monochrom> and finally for zlib
15:52:53 <edwardk> yep
15:53:01 <edwardk> i'll revert to that
15:53:04 <latro`a> ReinH: if you start out with readSquare :: Char -> Maybe (Maybe Piece), then you can compose that with note to get readSquare' :: Char -> Either String (Maybe Piece)
15:53:10 <latro`a> since you only have one possible error
15:53:22 <monochrom> and yeah libbsd
15:53:38 <dmj> monochrom: so should I scrap this ec2 instance altogether and try an ubuntu one? What's best?
15:53:58 <nand`> you could link to the typeclassopedia when mentioning Functor/Foldable/Traversable
15:54:22 <nand`> so user who eg. don't know what traversables are could look them up easily
15:54:27 <monochrom> I don't know what is best. I am not using ec2.
15:55:08 <monochrom> not to mention that people can totally hate ubuntu just on account of its GUI
15:55:33 <scry1> @pl \(a,b) -> b < n
15:55:34 <lambdabot> (< n) . snd
15:55:38 <c_wraith> edwardk: I'm not too far into the actual meat of the tutorial, but I am learning about the library's implementation from it. So, the overall goal is working.
15:55:49 <edwardk> =)
15:56:11 <monochrom> but it is strange that the blog says it has no gmp and you have to build it yourself. is ec2 that bad?
15:56:24 <ReinH> latro`a: right
15:57:41 <hpaste> typoclass pasted “suggestion for ReinH (untested)” at http://hpaste.org/72807
15:59:13 <ReinH> typoclass: I was just fixing that :)
15:59:15 <ReinH> my version: https://gist.github.com/e2035709b2946087b161
15:59:52 <ReinH> (can switch easily from AL to Map for performance)
16:00:08 <typoclass> ReinH: yeah, that kind of lookup table is possible as well
16:00:55 <ReinH> typoclass: also for me my version is a bit easier to follow than the pointfree constructor p
16:01:01 <ReinH> but I do like it
16:02:04 <latro`a> that case statement is the notemap that I wrote a while ago
16:02:24 <latro`a> eh, something like it rather
16:02:33 <latro`a> note errmsg . fmap
16:02:45 <ReinH> latro`a: looking
16:03:04 <scry1> someone said (!!) isn't cool, so what's the preferred way to handle lists with indexing?
16:03:08 <latro`a> (I was mistaken about it being notemap)
16:03:10 <dmj> monochrom: what host do you use?
16:03:18 <latro`a> scry1: ideally you don't index with lists at all
16:03:26 <monochrom> I use my own laptop and I put ubuntu on it
16:03:34 <latro`a> if indexing is required, another type is usually better
16:03:43 <dmj> and its public facing
16:03:47 <monochrom> no
16:03:53 <ReinH> latro`a: did you have some example code? I can't find any
16:04:00 <scry1> but see, i need to calculate a sublist based on the values
16:04:08 <scry1> takeWhile seems inefficient
16:04:10 <latro`a> no, I can write up a little one though
16:04:22 <ReinH> latro`a:  that would be great!
16:04:22 <latro`a> depends how many passes you make, scry1
16:04:24 <monochrom> so, I don't know what to use in your setting
16:05:07 <scry1> it's gonna be a lot of passes
16:05:11 <ReinH> latro`a: oh note is obvious
16:05:24 <scry1> let me get more specific
16:05:29 <dmj> amazon seems best for scalability, I could be wrong. Too bad there isn't a git deployable haskell web host like appharbor or heroku
16:05:36 <latro`a> note and hush are the best function names I've seen in ages
16:06:17 <ReinH> latro`a: clever :)
16:06:34 <latro`a> (I didn't come up with them)
16:06:37 <typoclass> latro`a: do you have a link to those functions?
16:06:43 <latro`a> Control.Error.Util
16:06:52 <typoclass> thanks
16:06:54 <latro`a> np
16:07:18 <latro`a> (I didn't make them, though I did rediscover them, as many people do :))
16:07:44 <dmj> monochrom: what do the yesod people use for hosting?
16:07:50 <scry1> it's from this; http://projecteuler.net/problem=391 - the list is the sums of the hamming weights from 1..n for n <- [0..]
16:09:02 <scry1> > scanl1 (+) $ fix ((0:) . drop 1 . (>>= \n -> [n,n+1]))
16:09:04 <lambdabot>   [0,1,2,4,5,7,9,12,13,15,17,20,22,25,28,32,33,35,37,40,42,45,48,52,54,57,60,...
16:09:38 <scry1> there's a game being played, where each turn
16:09:52 <scry1> you choose a new number in the set
16:10:24 <scry1> from 1..n for a fixed n
16:10:39 <scry1> that's from the problem site
16:10:57 <scry1> anyway, i don't want to compute the new list with takeWhile every time
16:11:11 <c_wraith> edwardk: trivial note in the tutorial..  the example referring to Data.ByteString.map probably should be (Word8 -> Word8) instead of (Char -> Char)
16:11:23 <edwardk> woops
16:11:27 <edwardk> yeah i started with Text =)
16:11:36 <edwardk> maybe Text is a better example
16:11:39 <scry1> so I thought, ok pass the remaining list into the next turn
16:11:45 <c_wraith> hmm.  Text probably is better
16:12:00 <scry1> but that seems bad too
16:12:23 <scry1> maybe this is too much detail, i just don't know how to handle haskell lists efficiently
16:13:27 <scry1> is it kosher to index by zipping the list with [0..]?
16:13:41 <Peaker> scry1, what kind of indexing do you need?
16:13:42 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
16:13:47 <edwardk> going to make the module links go to hackage as well
16:14:16 <edwardk> hrmm thats awkward because it needs the version number, perhaps not
16:14:17 <Peaker> edwardk, about the KindSignatures, the example I showed uses "m" as *->* and "a" as *
16:14:17 <scry1> i don't really want to index, i just don't want to do a takeWhile every time
16:14:25 <roconnor> scry1: yes, it is part of the Schwartzian transform
16:14:26 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
16:14:28 <Peaker> edwardk, so I guess *->* triggers the KindSignature? I am not sure
16:14:46 <roconnor> scry1: it's not great, but it isn't terrible
16:15:08 <edwardk> Peaker: i'm betting that what happens is that the types you have force kind defaulting to kick in and they replace your manual binders with typed ones, hrmm
16:15:18 <edwardk> maybe i can go through and replace all the signatures in the type that gets generated?
16:15:19 <roconnor> jfischoff: I don't know anything about template haskell I'm afraid
16:15:31 <mouna_> what does this command mean ? I'm doubting about it :  hPrintf stderr "Adding transactions to journal file \"%s\".\n" f
16:16:21 <shachaf> mouna_: Something very similar to what it would mean in C.
16:16:29 <scry1> roconnor: okay, ill give it a shot then
16:16:43 <Peaker> edwardk, do you do your own type generation?
16:16:58 <Peaker> edwardk, or just use TH/ghc's via some TH API?
16:17:03 <Peaker> (I don't know TH that well)
16:17:20 <jfischoff> roconnor: I do, but I'm still not sure what  good approach is. You can set the plates up in different ways, so I'm not sure what interface should be exposed to the user.
16:17:26 <scry1> is GHC at all aware of transitivity?
16:17:40 <mouna_> I'm doubting about that fact : is it going to print "Adding transactions to journal file ..." in the file specified by the variable f ?
16:17:42 <roconnor> jfischoff: some plates are semantic driven and cannot be derived
16:17:50 <jfischoff> exactly
16:17:59 <mouna_> because f is a file path
16:18:07 <edwardk> i use TH through Language.Haskell.TH but i have combinators in Language.Haskell.TH.Lens that do my substitutions
16:18:24 <scry1> i.e. if it computes 3 < 5 = True, and 2 < 3 = True, can it use that to say 2 < 5?
16:18:34 <byorgey> mouna_: yes.  type FilePath = String
16:18:46 <Peaker> edwardk, do you explicitly generate KindedB?
16:18:58 <avpx>  
16:18:58 <edwardk> oh, it may be easy then
16:19:03 <edwardk> i copy the KindedB i'm given
16:19:08 <edwardk> i can turn it into a Plain
16:19:10 <jfischoff> roconnor: but it might be that case that the 90% cases can be handled with the appropriate options/combinators.
16:19:19 <roconnor> jfischoff: probably
16:19:25 <edwardk> let me go do that
16:20:37 * mekeor just began to think that if the code type checks, it is correct.
16:21:19 <Peaker> edwardk, what gives you a KindedB?
16:21:53 <edwardk> they should be  unsign (KindedTV t _) = PlainTV t; unsign (PlainTV t)  -- and then i just apply that to the tyArgs i get from the reification of the data type
16:22:02 <edwardk> so i just need to map that over tyArgs everywhere
16:22:05 <edwardk> i'll bang it out
16:22:27 <edwardk> its KindedTVs that are the problem i think
16:22:47 <mouna_> just to be sure about understanding the whole thing because I'm confused between hprintf and printf : printf is to print in the default output and hprintf is to print in the file specified ??
16:23:24 <mekeor> :t hPrintf
16:23:25 <roconnor> edwardk: Tangable Values?
16:23:26 <lambdabot> forall r. (HPrintfType r) => GHC.IO.Handle.Types.Handle -> String -> r
16:23:28 <mekeor> :t printf
16:23:29 <lambdabot> forall r. (PrintfType r) => String -> r
16:23:30 <edwardk> tyvars
16:23:38 <edwardk> they come from TH
16:23:41 <roconnor> ah
16:23:54 <edwardk> lens goes out of its way to properly put signatures on everything in template haskell
16:24:00 <mekeor> mouna_: so, yes. with hPrintf you can print in any handler, e.g. in a file.
16:24:07 <edwardk> so it makes properly polymorphic lenses
16:24:10 <mekeor> mouna_: printf = hPrintf stdout
16:24:17 <edwardk> i had to write traversals for th types to go in and find all the names, etc.
16:24:47 <roconnor> edwardk: I was hoping you were linking lenses to tangable values
16:24:50 <mekeor> mouna_: … well, not exactly though…
16:24:54 <edwardk> apparently my habit of just copying out the binding with the signatures intact leads to a problem for peaker
16:24:59 <ReinH> :(
16:25:02 <edwardk> ah
16:25:04 <ion> edwardk: Hmm, is mapOf Data.Text/ByteString.map supposed to typecheck?
16:25:09 <ReinH> can someone help me refactor this using note:
16:25:11 <hpaste> ReinH pasted “readSquare using case” at http://hpaste.org/72809
16:25:13 <mouna_> @mekeor could you explain more please ?
16:25:14 <lambdabot> Unknown command, try @list
16:25:19 <edwardk> er my bad
16:25:33 <edwardk> i need to edit that it should be that you use sets Data.Text.map
16:25:37 <edwardk> and then you can mapOf that
16:25:40 <ReinH> my brain has apparently stopped working
16:25:52 <edwardk> can you tap in the edit for that?
16:26:06 <mekeor> mouna_: printf prints into stdout. with hPrintf you can print into any handler. this handler can be a file, or something different.
16:26:33 <ion> edwardk: Sure, in a minute.
16:27:19 <edwardk> Peaker: testing now
16:27:33 <Peaker> edwardk, great
16:29:07 <mouna_> @mekeor and for printf you just need to put what you want to print like printf " %s \n"  "mouna" and for hprintf " printing in the file %s" f with f = filepath will print in the file "printing in the file " right ?
16:29:07 <lambdabot> Unknown command, try @list
16:29:23 <edwardk> pushed to github
16:29:41 * hackagebot affine-invariant-ensemble-mcmc 0.1.0.0 - General-purpose sampling (JaredTobin)
16:29:43 <edwardk> it'll go to hackage as soon as i can get the rest of the 1.8 changes in
16:30:05 <edwardk> if you could pull and let me know if that fixes your problem that would be great
16:30:08 <mekeor> mouna_: do not use "@nickname …" format/syntax.
16:30:49 <mouna_> ok
16:31:11 <mekeor> mouna_: no, erm. it's like this:
16:31:15 <typoclass> mouna_: lambdabot thinks you're talking to her if you use "@"
16:31:18 <geekosaur> this is not twitter.  also not the only channel where @ starts a bot command.
16:32:22 <mekeor> mouna_: do { handle <- openFile "/path/to/file" ReadWriteMode; hPrintf handle "foobar" }
16:32:32 <mekeor> mouna_: BUT
16:32:39 <mekeor> mouna_: i don't think you want this.
16:32:57 <geekosaur> why ReadWriteMode?
16:33:25 <mekeor> yeah…
16:33:44 <mekeor> geekosaur: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#g:5
16:34:12 <mekeor> mouna_: you probably want this function: writeFile :: FilePath -> String -> IO ()
16:34:25 <geekosaur> mekeor, exactly, why is it not WriteMode?
16:34:36 <mekeor> geekosaur: oh, right… hehe :D
16:34:58 <mekeor> mouna_: see here <http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#g:7>
16:35:06 <mouna_> what I'm trying to understand is a code, here it is : do   hPrintf stderr "Adding transactions to journal file \"%s\".\n" f   where f = journalFilePath j
16:35:39 <mekeor> mouna_: you can just do this then: writeFile "/path/to/file" "some text which you wanna write there"
16:36:10 <mekeor> mouna_: that code snippet prints something to stderr.
16:36:15 <mouna_> and j is of type journal = a text file
16:36:38 <geekosaur> j is probably a record; journalFilePath would be grabbing the value of that field; hPrintf is just like in C and other languages, formatted print to the standard error/logging handle
16:36:50 <danil> edwardk: almost all the time I spent reading that was staring at type signatures trying to figure out what the variables meant. I'm not sure what to change to fix that, but I figure profiling is the first step of optimization.
16:37:10 <edwardk> fair nuff
16:37:22 <mouna_> stderr = standard error ??
16:37:27 <geekosaur> I would not have used hPrintf there because there's no point (even less than usual given that printf itself is a bit foreign to Haskell)
16:37:28 <mekeor> yes.
16:38:16 <mekeor> mouna_: so, your code snippet more or less equals this:  printf "Adding transactions to journal file \"%s\".\n" (journalFilePath j)
16:38:35 <mekeor> (except it uses stderr instead of stdout)
16:40:13 <hpaste> ReinH annotated “readSquare using case” with “readSquare using note” at http://hpaste.org/72809#a72811
16:40:25 <mouna_> 2 things I'm not getting : 1) does it print the string in the file specified or in stderr ? 2)  what is stderr ?
16:40:44 <ReinH> ok I think that looks reasonable ^
16:41:06 <mekeor> mouna_: (1) it prints into stderr
16:42:29 <geekosaur> mouna_, windows and unix have notions of standard output and standard error.  this is how you can redirect output from a command to a file, but still see error messages from it on the console
16:43:14 <mekeor> mouna_: (2) what you see on your terminal that a program prints, this is
16:43:19 <mekeor> oh foo, oops.
16:44:00 <geekosaur> on unix (and windows 7+, I am given to understand) you can redirect standard error to a file when running a command:  command ... 2>errfile (replace "errfile" with the name of the file); you can combine this with redirection of standard output
16:44:28 * mekeor doesn't know it good enough in order to be able to explain it.
16:44:34 <ReinH> is there a common idiom for naming a variable that contains a maybe value?
16:44:55 <ReinH> hopefully not some perverse hungarian notation mColor :: Maybe Color ?
16:45:15 <ion> edwardk: The “a” is extraneous in “sets l f a = Identity . l (runIdentity . f)”, right?
16:45:23 <edwardk> yeah
16:45:31 <edwardk> i pointfreed it after, my bad
16:45:51 <mekeor> ReinH: 'mv' for *m*aybe *v*alue :D
16:46:31 <ReinH> mekeor: Maybe DieInAFire
16:46:47 <ion> “Someone has edited the wiki since you started. Please reload this page and re-apply your changes.” Duh, one would think GitHub would use Git’s merge functionality for their wikis. :-P
16:46:49 <ReinH> mekeor: oh I forgot the :D
16:47:17 <mekeor> :D
16:47:21 <avpx> ion: huh
16:47:50 <ion> I see you already did the Data.Text.map change, too.
16:48:08 <mekeor> ion: which wiki are you editing?
16:48:33 <ion> mekeor: None, since edwardk already did the two changes i was thinking of. :-P https://github.com/ekmett/lens/wiki/Tutorial
16:48:50 <edwardk> hah
16:49:01 <mekeor> ooh, finally! a tutorial!! YAY
16:49:22 <edwardk> i'm almost to actually providing the derivation of the lens laws
16:49:53 <hpaste> ReinH annotated “readSquare using case” with “readSquare using note refactor (annotation)” at http://hpaste.org/72809#a72812
16:50:03 <edwardk> ion: you can pull it as a github repo then merges, etc work like you expect
16:50:08 <ReinH> ok does that look like reasonable haskell code? :D
16:50:20 <edwardk> git@github.com:ekmett/lens.wiki.git
16:50:39 <mouna_> so this code : hPrintf stderr "Adding transactions to journal file \"%s\".\n" f   where f = journalFilePath j         means that the handle is stderr and the string will be printed in stderr that means that you're getting it in the console as an error ?
16:50:45 <rofer> Can someone show me an example of loading data from a URL in Haskell? I seem to be completely lost on how to do this.
16:50:54 <roconnor> instanting lens updates with (Foo -> Maybe Foo) is really useful.
16:51:02 <ion> edwardk: ok
16:51:28 <edwardk> roconnor: oh for whether or not you bothered to edit so you can keep sharing?
16:51:35 <dropdrive> [How do I use the theorems-for-free stuff with lambdabot?]
16:52:16 <Nereid> @free f :: [a] -> [a]
16:52:17 <lambdabot> $map g . f = f . $map g
16:52:46 <typoclass> ReinH: sure, looks good to me
16:52:59 <typoclass> rofer: i think kids these days use http-conduit
16:53:04 <roconnor> edwardk: I'm using it for updating but when an error might occur
16:53:04 <ReinH> typoclass: thanks
16:53:06 <typoclass> @hackage http-conduit
16:53:07 <lambdabot> http://hackage.haskell.org/package/http-conduit
16:53:10 <rofer> typoclass: Thanks!
16:53:34 <edwardk> ah, i usually use that for when i'm updating but when i don't make an edit i just want to return the original structure unmolested by traversal
16:53:45 <roconnor> @type (>=>)
16:53:47 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
16:54:55 <dropdrive> Can one start with a theorem and get the type?
16:55:54 <Cale> dropdrive: depends, but usually it's possible to infer what was proved from a proof.
16:55:58 <Nereid> I cannot make sense of the question.
16:56:35 <Cale> Though, usually "theorem" still refers to a statement which happens to have a proof, rather than the proof itself.
16:57:18 <Cale> (i.e. it refers to an inhabited type, not a program which inhabits it)
16:58:45 <Nereid> I don't know how to make sense of wanting to go from a theorem about a function (which necessarily has a certain type) to a type, in a nontrivial way.
17:00:09 <mm_freak_> a theorem about a function /is/ a type
17:00:13 <mm_freak_> the function's type
17:00:50 <Cale> mm_freak_: yeah
17:01:21 <Cale> I'd sort of assumed he meant 'proof' or something, as in, the kind of thing that type inference does.
17:01:50 <mouna_> could anyone helps me understand this code : hPrintf stderr "Adding transactions to journal file \"%s\".\n" f   where f = journalFilePath j         means that the handle is stderr and the string will be printed in stderr that means that you're getting it in the console as an error ?
17:01:54 <mm_freak_> hmm…  that's actually turning a proof into a corresponding theorem
17:02:01 <mm_freak_> which is sort of an interesting concept
17:03:33 <mm_freak_> mouna_: you're getting it in, well, stderr
17:03:45 <mm_freak_> ./yourprogram > x.txt
17:03:51 <mm_freak_> stdout will be routed to x.txt
17:03:59 <mm_freak_> the stderr output will still be printed on the terminal
17:04:05 <edwardk> i may want to break this tutorial up into multiple pages
17:04:09 <edwardk> its going to get long ;)
17:05:11 <mm_freak_> mouna_: despite the name "stderr" is not for errors…  it's for any type of diagnostic that isn't part of the program's result
17:05:23 <mm_freak_> errors, warnings, progress, log, etc.
17:05:32 * geekosaur tried to explain that earlier... went flying overhead?
17:06:21 <mouna_> as I understand : if it was stdout, it would have been redirected to the file and the string would have been printed in this file but as it's stderr so the string is printed in the console right ??
17:06:41 <mm_freak_> mouna_: correct
17:06:52 <mm_freak_> just remember:  stdout for result, stderr for diagnostics
17:07:20 <mm_freak_> think about the user, who may want to redirect and parse the result, while ignoring the diagnostics
17:07:28 <mm_freak_> ./yourprogram | grep …
17:10:00 <acowley> Is there a monad transformer of attoparsec's Parser type?
17:10:08 <mm_freak_> acowley: nope
17:10:15 <acowley> shoot
17:10:17 <mm_freak_> unless it was added recently
17:10:24 <acowley> mm_freak_: thanks for confirming
17:10:30 <scooty-puff> acowley: partly for performance reasons i think
17:10:36 <scooty-puff> if not wholly
17:10:55 <fryguybob> edwardk: view (_2._1) ("hello",("world","!!!"))   <-- shouldn't this be "world"?
17:11:07 <edwardk> yes
17:11:09 <acowley> yes
17:11:10 <edwardk> feel free to edit
17:11:14 <fryguybob> ok
17:11:46 <acowley> backwards compositions make haskellers crazy even if they tickle our long-dormant OO syntactic muscle memory :P
17:11:51 <edwardk> =)
17:12:16 <scooty-puff> is there a release schedule for ghc 7.5, or if not, is there any reason to expect something fixed in 7.5 would be ported to a 7.4 release (specifically http://hackage.haskell.org/trac/ghc/ticket/5935)?
17:13:21 <c_wraith> scooty-puff: 7.5 will never be released.
17:13:44 <scooty-puff> o?
17:14:06 <scooty-puff> similar to debian.. whatever?
17:14:08 <c_wraith> .odd versions are development versions
17:14:29 <c_wraith> When it's ready for release, it'll be 7.6
17:14:32 <scooty-puff> k
17:14:44 * hackagebot shake-extras 0.1.1 - Extra utilities for shake build systems (AustinSeipp)
17:15:09 <edwardk> ok, i just did a merge of some edits i hope i didn't mangle what some others were writing, can you check?
17:16:12 <ReinH> Ok, so after I fix the warning for import Control.Monad.Instances by importing instances only, my vim haskell syntax marks a method as "hsImportIllegal". I realize this isn't a haskell question per se but: wtf?
17:16:57 <ReinH> I think hsImportIllegal is *supposed* to catch functions imported from multiple modules? But this is my own function.
17:17:43 <ReinH> s/method/function
17:18:11 <ReinH> I'm guessing the syntax lexer is broken but I wanted to make sure I wasn't missing a haskell problem
17:18:11 <roconnor> edwardk: how do I check if a traversal is null (ie length 0) or not?
17:18:17 <edwardk> nullOf
17:18:47 <roconnor> :)
17:18:48 <edwardk> ghci> nullOf traverse []
17:18:48 <edwardk> True
17:18:49 <ion> edwardk: It might be nice if many of the code examples – for instance “both :: Traversal (a,a) (b,b) a b” – included a version of the type signature with all type aliases expanded.
17:19:20 <edwardk> ion: feel free to push in the patch ;)
17:19:29 <edwardk> thats why i wanted this up on a wiki
17:19:57 <roconnor> I feel like I'm part of a revolution in functional programming
17:19:57 <edwardk> i'm happy to take feedback/updates
17:20:04 <edwardk> roconnor: =)
17:20:23 <roconnor> I can try to focus into a substructre
17:20:36 <roconnor> check if I'm null and fail, otherwise update
17:21:17 <roconnor> no matter how deep and obtuse said substructure is burried
17:21:30 <edwardk> have you used indexed traversals yet?
17:21:33 <roconnor> nope
17:22:05 <edwardk> they compose like everything else (you hav to use <.> <. and .> to compose the indices though
17:22:18 <roconnor> I'll wait for your blog post
17:22:21 <edwardk> and you can use any of the combinators on them or a bunch of ifooOf combinators
17:22:39 * roconnor thinks this might be bigger than monads
17:23:19 <roconnor> edwardk: is there a state version of nullOf?
17:23:53 <edwardk> gets (nullOf l)
17:23:54 <edwardk> =)
17:24:11 <roconnor> ha
17:24:14 <roconnor> oh well
17:24:40 <edwardk> its not an edit, so gets and use are pretty much what you get
17:24:50 <roconnor> fair enough
17:25:02 <roconnor> I can write my own function if I feel I need to
17:25:04 <edwardk> sure
17:25:14 <roconnor> espeically in combination with guard
17:25:24 <edwardk> i'll be porting my lensed monad back out of snap as well
17:25:35 <roconnor> edwardk: what does that mean?
17:25:40 <edwardk> so you'll have an efficient state-inside-larger-state monad
17:26:23 <edwardk> i wrote them a monad that keeps a 'whole' state, along with a lens down into part of it and the current value of the part, and does local edits like its a state monad on the part
17:26:33 <nand`> edwardk: some syntax errors near “but we can also compose them with a”
17:26:35 <edwardk> and when you're done it 'rolls it back into the whole
17:27:12 <edwardk> nand`: fixed
17:27:25 <roconnor> edwardk: how is it different from focus?
17:27:38 <edwardk> they use it in lieu of focusing, because they can go back to the root at any time
17:27:59 <edwardk> but the focus gives them efficient use of the same part of the state for long stretches
17:28:16 <edwardk> they can read their current lens, go up tot he root, do stuff, and refocus back down
17:28:38 <edwardk> focus requires you to come out of the monad do that
17:28:56 <roconnor> I see
17:29:06 <roconnor> so a state monad with a state focus?
17:29:10 <roconnor> hmm
17:29:11 <edwardk> yep
17:29:11 <ReinH> oh my haskell.vim syntax file has bug for instance only imports :(
17:29:16 <ion> edwardk: Btw, if you have some unpushed commits and the remote branch diverged from what you based the commits on, you can get a cleaner commit history without merges by running “git pull --rebase”. It will rebase your unpushed commits on top of the new HEAD of the remote branch instead of doing a merge.
17:29:16 <roconnor> edwardk: so it is indexed?
17:29:35 <edwardk> ion: fair nuff. i suck at git ;)
17:29:49 <edwardk> roconnor: it has two parameters, the base and the current state
17:29:50 <nand`> “but not we no longer known our function” this doesn't seem to parse as English
17:29:54 <ion> (git pull … is equivalent to git fetch … && git merge …. git pull --rebase … is equivalent to git fetch … && git rebase ….)
17:29:56 <edwardk> and the lens you have acts like a zipper
17:30:15 <roconnor> edwardk: the current focus must change type as you refocus
17:30:50 <edwardk> only if you refocus to a part with a different type than your current part ;)
17:31:02 <edwardk> istr they may use it with just a reader for the lens
17:31:15 <edwardk> which may defeat the purpose
17:31:43 <edwardk> guess the main benefit is they can focus down from the root
17:31:49 <edwardk> so its still a nested focus
17:31:55 <edwardk> but its letting it look 'up'
17:32:40 <nand`> edwardk: is the “(^.folded) :: Monoid m => a -> m” intentional? I have a feeling giving the exact type ((Foldable f, Monoid c) => f c -> c) would be clearer
17:32:52 * liyang would recommend always doing git pull --ff-only and actually having a look at the remote HEAD before deciding to merge or rebase.
17:32:53 <edwardk> oh yeah, feel free to elaborate it
17:33:40 <edwardk> i mostly live in a world where i am the only one using my git repo modulo some pull requests ;)
17:33:47 <edwardk> except when i work on scalaz
17:34:12 <rofer> Is there a way to make GHCi use Vim keys?
17:34:44 <ReinH> sweet I fixed the haskell.vim syntax bug
17:34:49 <nand`> edwardk: updated
17:35:04 <dolio> rofer: Yes.
17:35:22 <ReinH> liyang: you almost never want to merge
17:35:35 <ReinH> but --ff-only is better than no restrictions
17:36:10 <avpx> I usually just fetch, look at origin/master, and then react accordingly
17:36:27 <avpx> Worst case you accidentally merge and do some variation on git reset HEAD^
17:36:30 <geekosaur> rofer, http://haskell.1045720.n5.nabble.com/Vi-mode-in-ghci-td4477202.html
17:36:37 <dolio> rofer: Try 'editMode: Vi' in .haskeline
17:37:07 <edwardk> it at least seems like the bulk of the tutorial so far is coherent enough that people have made it to the bottom ;)
17:37:43 <edwardk> i'll type up some verbiage about the lenses themselves once i get on the T headed home.
17:37:52 <nand`> edwardk: it seems slightly less of a ‘how to use lenses’ and more of a ‘how I made lenses’ post
17:38:04 <liyang> ReinH: I know… I keep seeing people using git pull as if it were darcs pull. Anyway, I have ff aliased to pull --ff-only.
17:38:30 <edwardk> nand`: admittedly this is more of a 'how to obtain the laws' post, i may switch the title from Tutorial to something about deriving lenses
17:38:44 <edwardk> and make a separate usage tutorial that references this when things get hairy
17:38:45 <nand`> fair enough
17:38:56 <rofer> Thanks geekosaur and dolio
17:38:59 <ReinH> liyang: I just set my config to default pulls to rebase
17:39:03 <mysticc> @hoogle oneOf
17:39:04 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
17:39:04 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
17:39:04 <lambdabot> Test.QuickCheck.Gen oneof :: [Gen a] -> Gen a
17:39:31 <edwardk> hrmm, now i want a oneOf monadic fold that uses the random number generator
17:39:54 <nand`> I played with MonadRandom m => Action m's earlier
17:40:02 <MostAwesomeDude> edwardk: I think a page on how, why, and where would be good.
17:40:20 <MostAwesomeDude> How do lenses work? Why do we use lenses? Where should I use lenses in my program?
17:40:35 <edwardk> oneOf :: MonadIO m => Fold a c -> MonadicFold m a c  -- or some such
17:40:38 <edwardk> *nods*
17:40:44 <nand`> 1. magic, 3. wherever possible :P
17:40:44 <edwardk> well, its a wiki, start a page. ;)
17:40:51 <edwardk> i'm happy to contribute to it ;)
17:41:15 <nand`> MonadIO seems like an odd constraint
17:41:27 <edwardk> just for the RNG
17:41:33 <edwardk> there is a MonadRandom i guess that would work
17:41:38 <edwardk> but its not in base ;)
17:42:17 <edwardk> anyways, heading off, bbiab, unless my wife decides we're going out for my birthday or something
17:42:17 <nand`> maybe you could shoehorn RandomGen g => State g in somehow
17:42:23 <aristid> edwardk: how about oneOf :: Monad m => m Int -> Fold a c -> MonadicFold m a c -- or some such
17:42:33 <aristid> edwardk: where the first parameter is the generator for random numbers
17:42:38 <edwardk> aristid: that might work
17:43:04 <edwardk> probably with the first two args flipped
17:43:13 <edwardk> oneOf :: Monad m => Fold a c -> m Int -> MonadicFold m a c
17:43:32 <edwardk> the Of's universally take the lens or what have you first
17:43:54 * nand` .oO ( oneOf folded = one ? )
17:44:01 <edwardk> =)
17:44:11 <edwardk> bbiab
17:51:47 <otters> oh, .oO is THOUGHT BUBBLES
17:52:17 <aristid> somehow reading the lens tutorial is an unexpectedly emotional experience. :D
17:56:35 <mrotondo> Has anyone here used the new Cloud Haskell/distribute-process stuff yet?
17:58:12 <ion> @tell edwardk Added syntax highlighting <https://github.com/ion1/lens/wiki/Tutorial>. Please pull from https://github.com/ion1/lens.wiki.git
17:58:13 <lambdabot> Consider it noted.
18:01:55 <ReinH> At what point did mapM change to being defined in terms of sequence instead of the other way around (sequence = mapM id)?
18:02:33 <ReinH> (and what's the rational behind the change?_
18:02:54 <ReinH> rationale*
18:03:50 <ReinH> I find the former definition of mapM easier to understand than the current definition of sequence
18:04:34 <scooty-puff> :t sequence
18:04:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:04:46 * hackagebot egison-quote 0.1.1 - A quasi quotes for using Egison expression in Haskell code (TakuyaKuwahara)
18:05:04 <scooty-puff> weird, i almost never use sequence - though i use mapM, forM, for, traverse, etc., all the time..
18:12:05 <ReinH> it seems odd that for is flip traverse
18:12:36 <ReinH> wouldn't readSquare `for` "pppppppp" make more sense than readSquare `traverse` "pppppppp" ?
18:13:04 <ReinH> well, it doesn't seem odd that for is flip traverse, it seems odd that for isn't traverse and traverse isn't flip traverse
18:18:19 <scooty-puff> i think its for for xs $ ..., though i can't think of an similar situation for traverse - that reads like a control structure
18:18:29 <scooty-puff> bleh
18:18:57 <scooty-puff> or a situation where you could manage for xs $ ... without ... starting with do
18:21:02 <ReinH> scooty-puff: er... for xs $ ... would be traverse xs
18:21:06 <ReinH> :t traverse
18:21:07 <lambdabot> Not in scope: `traverse'
18:21:19 <ReinH> :t Data.Traversable.traverse
18:21:20 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:29:17 <Sopoforic> I'm trying to install criterion with "cabal install criterion" but it stalls on "Configuring abstract-par-0.3.1...". I'm using Haskell Platform 2012.2 on Windows Vista x64. What should I do?
18:29:46 * hackagebot vacuum 2.0.0.0 - Graph representation of the GHC heap (AustinSeipp)
18:29:48 * hackagebot vacuum-graphviz 2.0.0.0 - A library for transforming vacuum graphs into GraphViz output (AustinSeipp)
18:32:23 <ion> edwardk: Added syntax highlighting and expanded some type aliases: <https://github.com/ion1/lens/wiki/Tutorial>. Please pull from https://github.com/ion1/lens.wiki.git
18:32:28 <edwardk> great
18:32:28 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
18:34:11 <edwardk> ion: merged
18:34:49 <edwardk> wow the syntax highlighting helps a ton!
18:36:49 <aristid> .oO(pull request by IRC :D)
18:37:42 <edwardk> whatever workflow works ;)
18:38:01 <ion> aristid: Do GitHub’s internal pull requests even work for the wikis?
18:38:31 <ion> Oh, i forgot to mention i added the missing Ix constraints in the commit message. Oh well.
18:38:38 <aristid> ion: dunno
18:38:51 <aristid> ion: just found it funny, not saying it's bad! i'm easily amused
18:43:36 <spacebark> if I have 2 functions, f :: a -> IO Bool and g :: a -> IO Bool, what is the cleanest way to make a new function h :: a -> IO Bool which simply &&'s together the result of f and g?
18:43:38 <aristid> edwardk: i finished reading the tutorial about 10 minutes ago. assuming you want feedback, i think a bit heavier structure would help, it's sometimes hard to know "where" in the outline one is when reading. the first sentence is confusing, and i'm struggling to understand the section on traversals
18:44:03 <edwardk> fair nuff
18:44:10 <aristid> i realize it's a work in progress :)
18:44:19 <edwardk> i'm breaking it up into a separate 'Derivation' document and an actual Tutorial
18:44:35 <edwardk> with the Tutorial linking to the Derivation doc whenever it needs to expand on something
18:44:45 <startling> is this the long-anticipated lens tutorial? where is it?
18:44:50 <aristid> linking to specific sections of the derivation doc even?
18:44:58 <aristid> startling: https://github.com/ekmett/lens/wiki/Tutorial
18:44:59 <edwardk> yeah
18:45:10 <startling> aristid, edwardk: thanks
18:45:30 <aristid> edwardk: i love the elegance of the whole design by the way :)
18:45:53 <byorgey> spacebark: (liftA2 . liftA2) (&&) f g
18:45:55 <ion> @type \f g -> liftA2 (liftA2 (&&)) f g
18:45:56 <lambdabot> forall (f :: * -> *) (f1 :: * -> *). (Applicative f, Applicative f1) => f1 (f Bool) -> f1 (f Bool) -> f1 (f Bool)
18:46:36 <startling> edwardk: first sentence is pretty awkward; maybe "...that allow composition"?
18:46:38 <ion> @type \a f g -> liftA2 (&&) (f a) (g a)
18:46:39 <lambdabot> forall t (f :: * -> *). (Applicative f) => t -> (t -> f Bool) -> (t -> f Bool) -> f Bool
18:46:47 <edwardk> startling: will fix
18:47:41 <spacebark> byorgey: thanks!
18:48:08 <aristid> :t liftA2 . liftA2
18:48:10 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
18:48:15 <ion> TBH, i’d go with the pointful “a”.
18:48:29 <byorgey> aww, but that's no fun
18:48:32 <byorgey> =)
18:48:53 <ion> h a = liftA2 (&&) (f a) (g a)
18:49:12 <pushp0p> coming from scheme and ruby, haskell seems really interesting
18:49:31 <ion> h a = (| f a && g a |)  -- Where are the GHC-builtin banana brackets i ordered? :-(
18:49:46 <aristid> ion: i thought they are called idiom brackets!
18:50:23 <startling> pushp0p: it is!
18:50:47 <pushp0p> i think pattern matching and typing really cleans up a lot of stuff i found messy in scheme
18:51:37 <madhadron> pushp0p, There's actually no reason you can't do union types with pattern matching in Scheme. It's just that very few do.
18:51:55 <madhadron> They're not intrinsic to HM descended type systems in any way
18:52:04 <edwardk> aristid: thanks
18:52:09 <ion> aristid: I thought they are called both, but i might have misunderstood something.
18:52:24 <pushp0p> madhadron: i just like the way it's presented in haskell
18:52:32 <madhadron> pushp0p, It would be the same kind of pattern matching you can already do in Common Lisp and some schemes to access structures, lists, etc.
18:52:38 <madhadron> Oh, yes, Haskell's version of it is just gorgeous
18:52:46 <pushp0p> it makes things more readable
18:52:49 <madhadron> and you wouldn't think to do it that way until Haskell forced it on you
18:52:49 <pushp0p> than having internal conditions
18:53:44 <ion> 🍌 U+1F34C BANANA
18:53:52 <ion> Alas, there’s no LEFT BANANA and RIGHT BANANA. :-P
18:54:05 <shachaf> Is there YELLOW BANANA and GREEN BANANA and RED BANANA?
18:55:11 <aristid> ion: hmm, i think the pointfree idiom-bracket version would be | (liftA2 (&&)) f g |
18:55:38 <aristid> but maybe liftA2 (&&) <$> f <*> g is acceptable too
19:12:28 <ion> The Mutator sounds like a monster i’d rather avoid in a roguelike.
19:13:21 <aristid> ion: perhaps the Accessor can save you from its wrath?
19:13:24 <shachaf> Is that like the Tomator?
19:14:57 <aristid> shachaf: what does the Tomator do?
19:15:15 <typoclass> aristid: turns you into a tomato, obviously
19:16:10 <aristid> typoclass: i still need to decide whether that would be a good thing
19:16:38 <shachaf> aristid: http://i.ytimg.com/vi/8jz2BTPj6FA/0.jpg
19:16:46 <shachaf> The Tomator is that green thing.
19:17:58 <typoclass> aristid: in my opinion the tomator is better than the cucumberor, but slightly worse than the peaor. and clearly a lot worse than the carrotor
19:18:00 <DanC__> perhaps tonight will be the night I manage to write a bit of haskell...
19:18:50 <aristid> shachaf: uh
19:18:52 <parcs`> start with main = putStrLn "Hello World!"
19:19:21 <aristid> or main = putStr (cycle "A bit of Haskell!\n")
19:24:11 <pushp0p> lol
19:29:38 <DanC> to be more specific: I'd like to wrap my head around haskell web servers
19:30:34 <pushp0p> how do you zip entire strings
19:30:37 <Jafet> main = fix (putStr "A lot of Haskell!\n" >>)
19:30:43 <pushp0p> so that the output is ([], [])
19:30:45 * DanC browses http://www.haskell.org/haskellwiki/Web/Servers
19:30:46 <pushp0p> err
19:31:05 <startling> why in the world does Data.ByteString.Lazy.length return an Int64?
19:31:46 <Jafet> Int64 has alloyed rims
19:31:48 <DanC> how does this parse? putStrLn $ "Listening on port " ++ show port
19:32:03 <DanC> do I just have to know the relative precedence of $ and ++ ?
19:32:08 <startling> DanC: putStrLn ("Listening on port " ++ show port)
19:32:10 <DanC> how would I look them up?
19:32:11 <Jafet> $ has lowest precedence
19:32:12 <danil> startling: you can have lazy bytestrings bigger than can fit in your memory, so even on 32-bit platforms you might need an Int64 for the length
19:32:18 <typoclass> danc: putStrLn ("Listening on port " ++ (show port))
19:32:21 <Jafet> In ghci: :info $
19:32:43 <Jafet> (putStrLn ((++) "Listening on port " (show port)))
19:32:48 <startling> DanC: $ is lower than just about anything
19:33:11 <DanC> ghci doesn't seem to be installed here. apt offers: Candidate: 7.4.1-1ubuntu2
19:33:21 <DanC> is that anywhere near current?
19:33:26 <Nereid> yes
19:33:31 <Jafet> You haven't installed ghc?
19:33:40 <Nereid> current is 7.4.2
19:33:56 <Jafet> ghc should be distributed with ghci on any platform that has a ghci
19:33:57 <typoclass> DanC: $ has very low precendence. " ", i.e. function application, comes before anything else. ("map f . something" is "(map f) . something", "++ show port" is "++ (show port)", etc.)
19:33:57 <DanC> I probably have installed ghc at some point... but not on the machine that I'm currently using, no.
19:34:31 <DanC> is the precedence of $ part of the language, or just a standard library feature?
19:34:42 <typoclass> @src ($)
19:34:43 <lambdabot> f $ x = f x
19:35:12 <startling> DanC: standard library; fixity and precedence are declared with infixr and infixl
19:35:16 <Jafet> f $ x = f x; infixr 0 $;
19:35:21 <Jafet> Is the entire definition
19:35:33 <shachaf> I think there's a type signature too.
19:35:40 <typoclass> yeah, that's what i meant :) jafet is a little slower than lambdabot ;)
19:36:01 <shachaf> typoclass: But more complete!
19:36:15 <Jafet> infixr 0 $ is like 90% of the definition
19:36:18 <typoclass> DanC: if you just want to play around with a few one-liners, you can use tryhaskell.org or lambdabot (also available privately)
19:36:22 <typoclass> > 42 + 1
19:36:24 <lambdabot>   43
19:36:38 <DanC> I'd like to get past one-liners
19:36:54 <DanC> I've probably learned that bit about fixity before. It just hasn't stuck.
19:37:23 <ion> > let a = "infixr 0 $"; b = "f $ x = f x"; c = "($) :: (a -> b) -> a -> b" in genericLength a / genericLength (intercalate ";" [a,b,c])
19:37:24 <lambdabot>   0.20833333333333334
19:37:41 <DanC> but to confirm: haskell programmers know the fixity of $ and ++ like elementary school kids know that * binds tigher than +, yes? and there are about how many of these magic symbols?
19:38:00 <Jafet> > 0.9 / 0.208
19:38:01 <lambdabot>   4.3269230769230775
19:38:06 <Jafet> It's that important
19:38:25 <typoclass> DanC: my approach is to have not much clue about the precedence of anything, do what i want, then when the weird errors come, i stick in some parens 8-)
19:38:42 <Jafet> danc: depends on how many modules you import
19:38:44 <DanC> well, that doesn't help me *read* haskell
19:39:11 <Jafet> Every programmer knows all the symbols in their language's basic library
19:39:18 <Nereid> well-written code is readable without detailed knowledge of operator precedence, imo
19:39:23 <shachaf> typoclass: That approach leads to bugs!
19:39:26 <typoclass> nereid++
19:39:29 <ion> danc: Haskell programmers tend to know the fixity of ($) is very low and the fixity of function application is very high. It’s often a good idea to use parentheses to make what you mean explicit when using a bunch of infix operators in an expression.
19:39:30 <shachaf> Like the one in Data.Bits.popCount
19:39:40 <startling> DanC, there are lots of them. most behave exactly how you expect
19:39:45 <startling> $ is a weird one
19:40:43 <DanC> well, I expect ++ to work like in C. So this will take some adjustment.
19:41:01 <startling> DanC: ah. it's list concatenation in haskell
19:41:11 <Jafet> :t (++)
19:41:12 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:41:17 <Nereid> :t (Prelude.++)
19:41:19 <lambdabot> forall a. [a] -> [a] -> [a]
19:41:29 <startling> lambdabot has an unusual (++)
19:41:34 <DanC> (truth be told, I've done some scala hacking, so I have actually gotten used to ++. But " most behave exactly how you expect" is pretty close to worthless for this novice haskell reader)
19:41:35 <Jafet> Caleskell realskell
19:42:09 <avpx> :t "Hello, world!"
19:42:10 <lambdabot> [Char]
19:42:12 <Nereid> DanC: the type tells you a large part of what you need to know about the function
19:42:12 <Jafet> danc: it's excellent advice for people who expect how the code behaves
19:42:17 <avpx> Hmm, so no OverloadedStrings for lambdabot?
19:42:20 <startling> mannnn, I really wish there was a Lengthable typeclass
19:42:26 <Nereid> avpx: no, ghc version too old
19:42:31 <danil> DanC: in the Prelude, there are 2 operators for lists (++ and !!), three for monads (>>, >>=, and =<<), and lazy and strict application ($ and $!).  Then there are the usual math, boolean, and comparison operators.
19:42:34 <typoclass> shachaf: yeah i was being tongue-in-cheek. my opinion is to put in extra parens if you have to think twice, let alone if you have to look things up. (still doesn't help with reading dubious haskell code, admittedly)
19:42:39 <Jafet> It's called Traversable
19:42:46 <Nereid> =<< is just >>= flipped
19:43:05 <startling> Jafet: actually Foldable. but ByteString, for example, can't eb an instance of Foldable
19:43:16 <Nereid> just remember that /= is "not equal"
19:43:44 <avpx> Plus bitwise things aren't going to work the way you're used to
19:43:55 <avpx> > 2^5
19:43:57 <lambdabot>   32
19:44:02 <avpx> See? Totally not an XOR.
19:44:06 <startling> heh
19:44:21 <DanC> there have been about 4 different brief shining moments when I could read >>= and do notation and such; it always leaks out later though. Hence tonight's quest: to write enough code that it sticks.
19:44:36 <Nereid> the best way to make it stick.
19:44:43 <Jafet> > 1^0 -- sure it is
19:44:44 <lambdabot>   1
19:44:53 <avpx> Jafet: I had no idea...
19:44:54 <startling> > 0^1
19:44:56 <lambdabot>   0
19:44:57 <avpx> Jafet: Truly you have opened my eyes
19:44:58 <startling> oops
19:45:08 <Veinor> > 0 ^ 0
19:45:10 <lambdabot>   1
19:45:21 <startling> pretty close, though
19:45:23 <avpx> DanC: IMO, if you want to learn monads, you should start out by writing code without do notation
19:45:44 <startling> DanC, a good place to start is Maybe and then Parsec
19:45:45 <startling> fwiw
19:45:52 <avpx> DanC: You should write monadic code in easy monads like Maybe and List where you can think about what binding actually means
19:45:55 <Jafet> If you want to learn haskell, you should start out by writing code without "Monad"
19:46:13 <avpx> Jafet: That's a bit tricky because main :: IO ()
19:46:18 <Veinor> IMO, if you want to learn monads
19:46:24 <Jafet> And not main :: Monad m => m ()
19:46:25 <Veinor> write a lot of haskell
19:46:26 <zzing_> If I have a Text, is there any easy way to get a  Ptr (Ptr GLchar)   for an opengl raw call?
19:46:38 <Veinor> there's no magic bullet to learning them
19:46:44 <avpx> It's true, there really isn't
19:47:03 <avpx> You have to read articles, you have to write code, you have to study them from a couple of angles (the return/fmap/join one is helpful, I think)
19:47:08 <Jafet> Text isn't stored as UArray GLchar
19:47:22 <DanC> the example at the bottom of http://www.haskell.org/haskellwiki/Web/Servers ... I'm struggling to read it. Is it obscure code?
19:47:23 <avpx> Mostly, like anything else Haskell, you have to immerse yourself and then you will find victory.
19:47:39 <Nereid> DanC: not really
19:47:42 <Jafet> And even if it was, it probably wouldn't be in the right encoding
19:47:56 <Nereid> DanC: it just uses some Monoid and ByteString functions and such
19:48:08 <startling> DanC, which part?
19:48:15 <avpx> DanC: Yeah, once you're pretty familiar with Monoid, it should be pretty easy to understand
19:48:16 <Nereid> mconcat is a generalized concat
19:48:19 <Nereid> just like mappend is a generalized ++
19:48:19 <danil> it has no type signatures, seems pretty obscure to me ;)
19:48:20 <avpx> DanC: That's just another type class you have to learn
19:48:36 <zzing_> Jafet, I can convert it easily enough to a bytestring. I am just not sure how to get around those Ptr Ptr stuff
19:48:51 <DanC> I'm not sure where run is defined; does importing run_ define it?
19:49:32 <startling> DanC: no. probably from one of those other import
19:49:33 <startling> s
19:49:45 <startling> DanC: a trick: load that code in ghci and do :info run
19:49:47 <typoclass> DanC: yeah he's importing "run". my guess is it's from Network.Wai or Network.Wai.Handler.Warp
19:49:58 <Nereid> maybe it's a typo?
19:50:05 <Jafet> zzing: depending on what you do with it, you can use ByteString.Internal to grab an unsafePtr
19:50:11 <DanC> oh yeah... imports aren't always qualified. I'm spoiled by python.
19:50:12 <danil> it's on a line with 2 other unused imports
19:50:14 <ion> (\f -> mconcat . map f) == foldMap
19:50:36 <monochrom> IMO, if you want to learn monads, don't listen to suggestions of the form "IMO, if you want to learn monads..."
19:50:37 <zzing_> Jafet, I am giving opengl a shader source
19:50:52 <startling> DanC: yeah. :(
19:50:54 <zzing_> I think the foreign library might be part of a solution, I will look at the bytestring
19:51:12 <typoclass> DanC: you can also use hayoo to search for the package where a function comes form
19:51:14 <typoclass> @where hayoo
19:51:15 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
19:51:33 <otters> oh, "yahoo"
19:51:35 <otters> I get it
19:51:38 <DanC> and it's not usual to use Java-IDE-like tools that tell you where stuff comes from when you hover over it, right?
19:51:51 <DanC> (I'm an emacs addict; never quite got used to eclipse or the like)
19:53:05 <startling> DanC: correct
19:53:06 <typoclass> DanC: i think most people use emacs or vi. there is in fact a vim thingy that shows you the type of things in tooltips. it's very handy when it works (which is not often :-/ )
19:53:57 <startling> DanC: I usually qualify imports or use "import Data.Map (lookup)"
19:54:12 <zzing_> I might have something that might do it
19:54:24 <DanC> yeah... to what extent is that the norm in the community, startling?
19:54:48 <avpx> It's very common, especially for data structures that have operations similar to []
19:54:49 * hackagebot terminfo 0.3.2.5 - Haskell bindings to the terminfo library. (JudahJacobson)
19:54:52 <DanC> python has `from foo import *` but it's frowned upon and reasonably rare
19:55:15 <typoclass> startling: that sounds good, and i wish people would do that in general. and more so in example code on the wiki :-(
19:55:42 <avpx> I think qualified imports make your code a bit verbose, but I like import Foo (bar)
19:56:01 <monochrom> I like that too
19:56:29 <zzing_> ok, so I need a Ptr (Ptr GLchar)  which turns out to be a Ptr CString   - Is there a way to take a CString and get a Ptr CString?
19:56:34 <DanC> hmm... I started an abc.hs file, and emacs didn't switch to a haskell mode.
19:56:47 <DanC> emacs doesn't grok haskell out of the box? hmm.
19:56:52 <monochrom> @quote edwardk sticky
19:56:52 <lambdabot> No quotes match. That's something I cannot allow to happen.
19:56:56 <startling> DanC: does for me
19:57:00 <monochrom> hrm, lost
19:57:05 <edwardk> ah well
19:57:05 <Jafet> You're using the wrong box?
19:57:22 <monochrom> preflex: quote edwardk sticky
19:57:22 <preflex>  no quotes found for edwardk
19:57:26 <DanC> emacs 23.3+1-1ubuntu9
19:58:08 <monochrom> well, the quote is: "i think the comonads are warm fuzzy, and the monads are warm sticky. its easy to get out of a comonad, its soft and you like wearing it. monads on the other hand stick to you and are icky"
19:58:24 <startling> import qualified Data.Map as M seems reasonably common at least
19:58:25 <DanC> "The Scion IDE library can be used to complement the haskell-mode ..." <- is it widely used?
19:58:48 <avpx> monochrom: This would be a fun tone for a text on category theory
19:58:56 <monochrom> Data.Map has many name clashes with Data.List and Prelude, that's why
19:59:06 <startling> indeed
19:59:09 <avpx> "A functor is like a bus..."
19:59:19 <DanC> ah... ghc-mod integrates flymake. I like flymake.
19:59:21 <startling> avpx: it's fun at first?
19:59:23 <Nereid> and a monad is like a burrito!
19:59:32 <avpx> Nereid: Like a burrito in a space suit!
19:59:37 <Nereid> !!
19:59:40 <startling> eating a monster
19:59:51 <monochrom> is it a functor or a monad? it's both! http://www.vex.net/~trebla/photo/unorganized/burrito-salad.jpg
19:59:59 <adnauseam> wot
20:00:03 <avpx> monochrom: I laughed out loud.
20:00:10 <adnauseam> what is this madness
20:00:11 <Nereid> haha
20:00:24 <monochrom> ok, I'll stop my madness!
20:02:10 <zzing_> What is a good name for a function that takes does Text -> Ptr CString?
20:02:18 * DanC installs cabal... hopes folks don't mind my use of this channel as something of a lab notebook...
20:02:34 <monochrom> export_to_C
20:04:37 <startling> DanC: cabal is definitely useful
20:04:49 * hackagebot route-generator 0.1 - Utility to generate routes for use with yesod-routes (StephenWeber)
20:04:51 * hackagebot wai-dispatch 0.1 - Nice wrapper around yesod-routes for use with WAI (StephenWeber)
20:04:59 <Nereid> http://kourindou.exblog.jp/18582833/
20:05:04 <Nereid> oops.
20:05:05 <Nereid> wrong channel.
20:05:52 <zzing_> hmm, too bad that Data.ByteString.Unsafe doesn't let me do direct conversion to CString
20:05:57 <hpaste> startling pasted “ridiculous bolierplate” at http://hpaste.org/72815
20:06:22 <startling> ^ this is what I meant when I said I needed a Lengthable typeclass. any advice?
20:07:41 <edwardk> startling: lengthOf traverse ;)
20:07:50 <edwardk> not very fast, but it works ;)
20:08:24 <typoclass> startling: you're right. you could write that typeclass? with just those 3 instances you need?
20:08:29 <startling> edwardk, ByteString can't be a Traversable
20:08:43 <danil> startling: I would write my own class and feel bad about it
20:08:45 * DanC discovers a haskell-mode apt package; wonders why his earlier search failed to find it
20:08:55 <edwardk> Control.Lens.lengthOf Data.ByteString.Lens.bytes
20:09:12 <edwardk> however, it does have a traversal
20:09:22 <nand`> indexed traversal, even
20:09:25 <edwardk> yep
20:09:34 <edwardk> in case you want your predicate to care about the position in the bytestring
20:09:38 <startling> edwardk, alas, I think this is over my head
20:09:51 <ion> startling: Refactor those to functions like pieceMempty and pieceMappend (that takes B.length / fromIntegral . L.length / length as a parameter) and refer to them from the instance definitions.
20:10:12 <edwardk> ghci> lengthOf bytes $ "hello"^.packedChars
20:10:12 <edwardk> 5
20:10:45 <edwardk> startling: thats all there is to it
20:10:46 <JSchwag> is Leksah a good choice? or is there something more commonly used
20:10:50 <JSchwag> for an ide
20:10:53 <startling> ion: that's possible.
20:10:57 <startling> edwardk: hmm, interesting
20:11:09 <edwardk> ghci> lengthOf text $ "hello"^.packed
20:11:10 <edwardk> 5
20:11:19 <edwardk> does the same for Data.Text
20:11:59 <DanC> ouch: "Do not use indent-region"
20:12:02 <JSchwag> also, the ebook im reading shows syntax highling for ghci in the console. is there a way to turn this on somehow?
20:12:08 <edwardk> mind you lengthOf is the boring count up by 1 version of length, but it works on anything
20:12:10 <JSchwag> highlighting*
20:12:40 <edwardk> ghci> lengthOf (both.folded) ([1,2,3],[4,5,6])
20:12:41 <edwardk> 6
20:12:55 <typoclass> JSchwag: i think ghci doesn't support it
20:13:09 <startling> JSchwag, there are a couple hacks like piping it through something
20:13:28 <JSchwag> interesting, thanks ill just do without
20:13:31 <JSchwag> not a big deal
20:13:55 <Jafet> haskell-mode might do it
20:14:19 * danil just noticed that inferior-haskell-mode doesn't actually highlight haskell syntax.
20:14:31 <Jafet> Ok, so it might not
20:15:50 <DanC> is the compiler single-threaded? it doesn't seem to use more than 1 core
20:16:05 <shachaf> edwardk: So have you given up on functions?
20:16:15 <edwardk> ?
20:16:16 <shachaf> From now on, lenses only?
20:16:26 <nand`> Lenskell
20:16:28 <danil> DanC: yes, for embarrassing historical reasons
20:16:37 <nand`> instead of (f a) I write a^to f
20:16:39 <nand`> ^.
20:16:49 <startling> lensical programming
20:17:14 <DanC> danil, I'm curious. will I find those reasons with a straightforward web search? if not, care to suggest search keywords?
20:17:18 <nand`> as opposed to nonlensical programming?
20:17:28 <Nereid> edwardk: so what's the difference between data-lens and lens
20:17:42 <avpx> nand`: That doesn't make a sick of lense.
20:18:07 <Nereid> a lot, I guess.
20:18:12 <Nereid> I should probably at least look at the packages.
20:18:19 <nand`> Nereid: lens uses van laarhoven lenses which means it doesn't need Control.Category for composition/id
20:18:25 <edwardk> data-lens is a pocket knife. lens is a swiss army knife with an attached missile launcher.
20:18:26 <Nereid> yes I realize that now.
20:18:29 <startling> avpx: ha
20:18:30 <Nereid> haha
20:18:42 <nand`> Nereid: also it's much more generalized, he expanded it to folds, traversals, monadic actions, indexed traversals etc.
20:18:50 <Nereid> mhm.
20:19:02 <JSchwag> but will it blend
20:19:09 <edwardk> basically with data-lens you can compose some lenses
20:20:17 * DanC starts to think that installing ghc-mod is not the shortest path to his target...
20:20:30 <danil> DanC: http://www.aosabook.org/en/ghc.html , look for "crime doesn't pay"
20:20:45 <edwardk> with lens you can compose lenses, folds (like Foldable), traversals (like Traversable), getters (including arbitrary functions), setters (which act like Functors), indexed folds (like foldrWithKey for some containers), indexed traversals (like traverseWithKey), isomorphisms that act like functions, and arbitrary monadic actions, all with (.) and id
20:20:51 <DanC> thanks, danil!
20:20:56 <nand`> ‘SimpleLens’ is that type alias even still around?
20:21:01 <edwardk> yes
20:21:26 <edwardk> in case someone doesn't want to deal with risking a LiberalTypeSynonym error some day
20:21:34 <edwardk> or just wants to save a char
20:21:46 <shachaf> Smplns
20:21:57 <nand`> SL
20:22:19 <startling> simplens
20:22:40 <nand`> Simple N’s
20:22:47 <edwardk> Nereid: anyways you can use the same set of combinators for all of those things, and they just work, upgrading the requirements to include monoids, etc. as they go up or down the hierarchy as needed
20:23:14 <nand`> how are data-lens's error messages?
20:23:28 <edwardk> they are boring because they only have lenses to compose
20:24:14 <nand`> lens's are great at times: “    No instance for (Settable (Accessor a0))”
20:24:40 <DanC> uh-oh... aosabook looks compelling. how am I going to get any coding done with such a compelling distraction? ;-)
20:25:19 <edwardk> =)
20:25:20 <Nereid> edwardk: yeah, I see now.
20:25:53 <edwardk> as the original author of both, i definitely prefer the design of lens
20:26:03 <Jafet> There should be an error to error message metric for libraries
20:26:22 <Jafet> Then we can formally point and laugh at boost
20:26:44 <DanC> understatement "The configuration file acquired a reputation for being arcane. " -- http://www.aosabook.org/en/sendmail.html
20:27:13 <Jafet> http://okmij.org/ftp/Computation/sendmail-as-turing-machine.txt
20:27:31 <edwardk> as an aside, lens itself is designed to be more or less batteries included for base, if you need a version of lenses that is compatible with lens, but is haskell 98 you can either directly implement them with functor (with no import) or use lens-family-core, since lenses from lens-family-core are compatible with the lens library.
20:31:53 <Nereid> so many lens packages
20:32:54 <edwardk> lens is more or less my attempt to define a viable standard lens package with all the object lessons from the others, and a dose of compelling original research on top
20:34:23 <BMeph> Is there a "generic" version of the functions in Data.Bits?
20:34:42 <edwardk> BMeph: Data.Bits.Lens gives you stuff for them
20:34:45 <edwardk> what do you want?
20:35:12 <BMeph> Are there generic versions, rather, I guess.
20:35:35 <edwardk>  bitAt 3 .~ True $ 100
20:36:02 <edwardk> you mean as in GHC.Generics or something? or in that you have a data type that acts as an n bit value?
20:36:12 <edwardk> 'generic' is a pretty generic term ;)
20:36:25 <zzing_> if a GLchar is a newtype GLchar = GLchar Foreign.C.Types.CChar, is there a way to get the original CChar type to be accepted into something that takes a GLchar?
20:36:41 <edwardk> zzing_: unsafeCoerce =(
20:37:02 <edwardk> The GLfoo types were a _terrible_ idea
20:37:10 <zzing_> edwardk, probably right
20:37:16 <zzing_> I am doing OpenGLRaw :-)
20:37:20 <edwardk> i have a small army of unsafeCoerce wrappers for them because otherwise there goes all my performance =(
20:37:25 <BMeph> edwardk: Looking for get, set, test versions that can go higher than maxbound:: Int
20:37:35 <edwardk> oh, those, no
20:37:46 <zzing_> @hoogle unsafeCoerce
20:37:46 <edwardk> thats a big Integer you have there ;)
20:37:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
20:38:06 <zzing_> At least I will bottle up all the unsafe bits :P
20:39:31 <DanC> so I loaded the example from http://www.haskell.org/haskellwiki/Web/Servers into python and asked emacs to load it into ghci. I got:  Could not find module `Data.Enumerator'
20:39:39 <DanC> this is after I did `cabal install warp`
20:39:53 <DanC> does emacs haskell-mode know to look at cabal stuff?
20:40:09 <startling> DanC: might need to restart emacs
20:40:10 <startling> I forget
20:40:44 <DanC> still losing.
20:41:22 <danil> DanC: that example is very old, Warp uses Conduit now instead of Enumerator
20:42:03 <DanC> sigh.
20:42:26 <DanC> this is another way in which I feel spoiled by python: module docs routinely have lots of examples.
20:42:34 <DanC> I don't see any examples in http://hackage.haskell.org/packages/archive/warp/1.3.0.1/doc/html/Network-Wai-Handler-Warp.html
20:44:28 <startling> DanC: yeah, I think the python community is especially good at docs
20:44:35 <nand`> generally the idiom is that for well-designed (pure) libraries, the functions and their type signatures is all you need to use it effectively
20:44:38 <zzing_> edwardk (or anyone else), could I get some suggestions on this code that uses unsafe stuff a few times? This is the first time I am using this unsafe stuff. It does compile, but I can't test it until tomorrow.  https://gist.github.com/02836cf89eb27bf03067
20:44:54 <nand`> but I agree that this does not always work out very well, after a certain point of complexity
20:45:06 <Nereid> startling: they need the docs because you can't figure anything out by looking at types ;)
20:45:13 <aristid> DanC: wai and warp stopped using enumerators
20:45:22 <edwardk> zzing_: i'd recommend making a combinator for coerceChar :: CChar -> GLChar; coerceChar = unsafeCoerce
20:45:27 <edwardk> zzing_: then use that for sanity
20:45:38 <danil> nand`: that's the usual excuse, at least
20:45:47 <startling> Nereid: if only
20:45:54 <DanC> yeah... I've heard that story before, nand`. I'm all for formal specs and such, but the value of story-telling can't be over-estimated either.
20:46:04 <zzing_> edwardk, how would I use that with ((unsafeCoerce s)::(Ptr (Ptr GLchar)))
20:46:07 <DanC> (oops; didn't mean to make a pun on story there)
20:46:13 <edwardk> oh then you're hosed ;)
20:46:33 <edwardk> you can coerce ptrs slightly more safely
20:46:47 <edwardk> castPtr
20:46:53 <edwardk> from Foreign.Ptr
20:47:04 <danil> DanC: I think the Yesod people may have ulterior motives as far as Warp goes, though--they want you to use the framework and not just its WAI handler
20:47:19 <DanC> what's the usual way to look at types? using ghci? browsing the cabal web site? reading compiler errors?
20:47:39 <edwardk> coercePtrPtrChar :: Ptr (Ptr GLchar) -> Ptr (Ptr CChar); coercePtrPtrChar = castPtr ;)
20:47:40 <nand`> a mixture of haddock and ghci
20:47:56 <DanC> danil, is there a simpler web server? I'd like to grok the implementation
20:48:06 <DanC> I seem to have a rather large stack of concepts to climb.
20:48:08 <edwardk> DanC: snap is pretty easy to understand and is competitive
20:48:14 <DanC> ok.
20:48:53 <edwardk> also the installer gives you pretty much everything you need to get going, just 'snap init' in an empty folder named after the project you want to start
20:49:09 <stepcut> happstack has extensive documentation and is as fast as snap.. plus it offers many of the same features as yesod as optional components
20:49:14 <DanC> I read some Yesod docs; pretty nice. A little too much "don't worry about the details just now..." for tonight's excercise, though.
20:49:34 <nand`> How popular are conduits? Are there multiple (popular) different implementations or just the ‘conduit‘ package?
20:49:50 <nand`> I've seen them mentioned frequently but never got round to actually looking at or using them
20:50:03 <DanC> `snap init` smells like a framework. I'm not in the market for that, tonight.
20:50:17 <zzing_> edwardk, looks like it won't work, it really wants the cast in the middle of that code
20:50:20 <edwardk> yesod tends to focus on the pragmatics of being a better ruby, snap focuses on elegance, happstack is something different, its more of a roll-your-own-web-programming-stack. this is great because you get a ton of configurability and options, but the learning curve is steep
20:50:28 <edwardk> DanC: well snap init just spits out an example project
20:50:31 <startling> nand`: you can always tell how popular an idea is in haskell by the number of packages. :)
20:50:40 <edwardk> zzing_: then just put a castPtr
20:50:47 <nand`> startling: http://www.haskell.org/hoogle/?hoogle=conduit <- quite a few
20:51:01 <zzing_> ok, it does like castPtr there, I am glad of that, thank you
20:51:09 <zzing_> I did figure it out at least :-)
20:51:22 <zzing_> This dealing with foreign stuff is difficult but rewarding
20:51:26 <DanC> startling, not a novel idea. Google calls it "pagerank", though "impact factor" and "citation count" have a long history in academia
20:52:20 <startling> DanC: some people call it "the lisp curse"
20:52:48 <DanC> hmm... I would have thought that after `cabal install warp` I would have had much of the lower level libraries installed and `cabal install snap` would be quick.
20:52:49 <DanC> not so
20:53:02 <aristid> edwardk: snap doesn't use any streaming I/O library though, it seems?
20:53:03 <edwardk> they use somewhat different infrastructure
20:53:10 <edwardk> aristid: they use http-enumerator i think
20:53:52 <zzing_> Now, by avoiding String and such, and just doing Text -> ByteString -> CString, am I avoiding the bad performance hits?
20:54:04 <aristid> edwardk: i don't know what they would use http-enumerator for, given that it's a http _client_, but yeah it seems like snap-core uses enumerator
20:54:07 <DanC> zzing_, yeah, I read some haskell bindings for an ldap C library. interesting.
20:54:09 <edwardk> zzing: depends on what you're doing with them
20:54:26 <aristid> i was looking only at snap at first which uses neither
20:54:31 <zzing_> edwardk, just passing them to the C library
20:54:34 <edwardk> aristid: just remembered seeing it fly past when installing =)
20:54:51 <DanC> oops... maybe I wanted just snap-server
20:54:52 <edwardk> zzing_: well, if you don't munge them a lot in haskell then yes that'll be fine
20:54:53 <danil> nand`: there's one implementation of conduit and a ton of conduit-flavored-somethings that make use of it.  There are two different "pipes" packages that are (we all hope) converging with conduit, though.
20:55:08 <zzing_> Not that this is a big issue at this stage, it is simply loading up stuff
20:55:42 <edwardk> i've been porting something like pipes to scala, wondering if i should bring the innovations from that project back to haskell
20:55:50 <aristid> edwardk: i guess they're waiting out the whole pipes/conduits thing. not like anybody would keep using enumerator because he loves it so much (at least i can't imagine that)
20:55:54 <edwardk> but then there'll be yet _another_ point in the design space
20:56:14 <zzing_> edwardk, you would likely get some biased answer here :P
20:56:19 <edwardk> i confess neither design really wows me
20:56:31 <aristid> edwardk: you could also just put it on github and make clear it's only a demo (not putting it on hackage, i mean)
20:56:56 <edwardk> they are both okay but the frames stuff in pipes is pretty awful, and pipes tends to go nuts with free monads even when its not warranted which makes the code unreadable
20:57:10 <edwardk> aristid: i'm not very good at doing things like that ;)
20:57:23 * DanC finds snap module docs more to his liking
20:57:58 <edwardk> danc: i was able to get up and running with it in very short order
20:58:14 <aristid> edwardk: well all i know is conduits are much nicer to use than enumerator. i haven't really actually used pipes, so no idea how easy to use it is.
20:58:14 <zzing_> edwardk, what have you done with opengl in haskell?
20:58:56 <edwardk> zzing_: in haskell? not a whole lot, in the past? i used to license technology to game companies, so lots of stuff
20:59:24 <zzing_> I am interested in doing some 'processing' like stuff in haskell
20:59:27 <edwardk> more or less in haskell my opengl experience consists of smashing together cuda and opengl to get a drawing surface
20:59:52 <edwardk> (for dsl-generated code that is running in cuda)
21:00:05 <zzing_> ok
21:00:26 <edwardk> basically using automatic differentiation to build cuda code that would be arduous to write by hand
21:00:47 <DanC> hmm... What to make of this documentation?
21:00:48 <aristid> ok, so it was happstack the eschews streaming I/O libraries altogether.
21:00:49 <DanC> runSnap :: Snap a -> (ByteString -> IO ()) -> ((Int -> Int) -> IO ()) -> Request -> Iteratee ByteString IO (Request, Response)Source
21:00:50 <DanC> Runs a Snap monad action in the 'Iteratee IO' monad.
21:00:52 <aristid> sacrilege
21:01:16 <aristid> DanC: you're not supposed to use that function, i think :)
21:01:37 <edwardk> DanC: there is also a #snapframework channel full of people who know what the heck to do with this stuff ;)
21:01:47 <DanC> whimper. It's listed first.
21:01:58 <edwardk> DanC: did you take a look at the results of snap init?
21:02:07 <DanC> well, I'm not really trying to learn snap; I'm trying to learn haskell
21:02:34 <edwardk> fair enough
21:02:39 <DanC> I haven't even found reference to snap init in the docs
21:02:41 <rchatsiri> Scala code can call Haskell-actor,right?  Why some reference tell Scala-actor using Haskell-actor library?
21:02:46 <edwardk> you cabal installed snap?
21:02:51 <DanC> yes
21:03:04 <edwardk> go to an empty folder, and just type it in at the bash prompt ;)
21:03:14 <aristid> rchatsiri: is Haskell-actor some kind of scala-to-haskell adapter?
21:03:27 <edwardk> its like throwing the crystal to form the fotress of solitude or something
21:03:46 <DanC> well... maybe I will... but are people supposed to come to IRC to learn this stuff? how does one normally learn about `snap init`?
21:04:02 <edwardk> just make sure the folder has a name that you like coz it'll name the local project after it
21:04:14 <edwardk> DanC: there is a snapframework website with a tutorial
21:04:14 <aristid> DanC: don't assume the reference docs are the only docs. http://snapframework.com/
21:04:36 <edwardk> http://snapframework.com/docs/quickstart
21:05:06 <DanC> so... is that the norm? the hackage docs aren't really where one starts?
21:05:14 <edwardk> usually its the hackage docs
21:05:25 <edwardk> but web platforms are hairy beasts and you have lots of interrelated packages
21:05:40 <DanC> are there any web servers that are not hairy beasts?
21:05:48 <ninegrid> DanC: i usually google, hackage and hoogle until i am stumped or too stupid to continue and then I ask here
21:05:58 <edwardk> the snap guys were really the first out of the gate with good documentation (out of the haskell web frameworks) but now the others have caught up a bit
21:06:14 <aristid> yesod even has its own book :D
21:06:20 <DanC> No command 'snap' found
21:06:22 <DanC> hm.
21:06:31 <edwardk> PATH=$HOME/.cabal/bin:$PATH
21:06:34 <aristid> DanC: add ~/.cabal/bin to your pATH
21:06:48 <DanC> yet another magic spell... where is one expected to learn this?
21:06:53 <nand`> DanC: if you just want some proof of concept rather than an actual production server it may be possible to roll your own using basic networking stuff and some HTTP library
21:06:53 <edwardk> http://snapframework.com/docs/quickstart
21:06:54 <edwardk> ;)
21:06:58 <edwardk> first thing there
21:07:01 <DanC> (it's reasonably straightforward, but still... magic)
21:07:26 <stepcut> edwardk: caught up a bit? in my highly biased opinion, the happstack documentation far exceeds snap
21:07:36 <aristid> DanC: that's the first thing to do when you set up cabal :) it installs its binaries in ~/.cabal/bin - not just for snap, for every haskell executable.
21:07:45 <DanC> `snap init` exited silently
21:07:56 <edwardk> i was being diplomatic in that mightybyte can hunt me down, and i know he is capable of pressing me over his head ;)
21:07:58 <aristid> now you should have stuff(tm) in your directory
21:08:08 <stepcut> :)
21:08:14 <edwardk> whats in the directory now?
21:08:24 <aristid> stepcut: do you use lazy I/O?
21:08:25 <barrucadu> Non-interactive commands should be silent when things work, and noisy when things go wrong :)
21:08:30 <DanC> aristid, well, OK, I know that now, but to repeat: is one expected to come to #haskell to learn about ~/.cabal/bin? Or did I skip a step in my reading of docs?
21:08:42 <stepcut> aristid: personally? yes. I assume you mean in happstack though ?
21:08:55 <aristid> DanC: i don't know what you read before
21:08:59 <rchatsiri> aristid:  Yes, Hakell-actor adapt  to Scala-Actor, but Scalaz library has not method or class to call Haskell-actor. http://doc.akka.io/docs/misc/Comparison_between_4_actor_frameworks.pdf
21:09:02 <aristid> stepcut: i mean happstack, yes
21:09:11 <edwardk> DanC: they funnel people in through the website, the website gives a pretty concise list of things to do to get setup
21:09:15 <nand`> barrucadu: I'd expect them to show me progress / status / success reports in stdout and noisy errors in stderr; not be completely silent
21:09:35 <stepcut> aristid: yes, until pipes 3 comes out. Originally we were going to switch to hyena (before snap and yesod existed), but then hyena never really materialized
21:09:59 <stepcut> but pipes 3.x seems like it should be a pretty mature alternative
21:10:01 <aristid> stepcut: what was hyena?
21:10:07 <ninegrid> do most of you sandbox with cabal dev?
21:10:19 <edwardk> clearly i need to name my pipes library 'tubes'
21:10:21 <stepcut> aristid: the original left-fold enumerator based web server -- written by tibbe back in the day
21:10:33 <nand`> edwardk: yes
21:10:37 <tibbe> stepcut: those were the days!
21:10:41 <stepcut> :)
21:10:44 <nand`> edwardk: as long as you implement some form of networking lib on top of it
21:10:48 <DanC> hmm... none of the files from `snap init` is a README... order-N search for which-end-is-up...
21:10:48 <edwardk> heh
21:10:51 <stepcut> tibbe: alas.. I can't hold out any longer :)
21:10:54 <aristid> oh, conduit has another advantage: there's plenty of libraries around it already :D stuff like zlib-conduit. pipes is in a much more dire situation there
21:11:11 <stepcut> tibbe: but.. in the flip side.. having the new IO manager helps a ton :)
21:11:17 <tibbe> stepcut: but the next version will be out any day now ;)
21:11:17 <aristid> stepcut: the pre-iteratee iteratees?
21:11:21 <DanC> aha! the PATH clue is atop http://snapframework.com/docs/quickstart ; sorry.
21:11:22 <tibbe> stepcut: (just kidding)
21:11:52 <stepcut> tibbe: for handling network timeouts, should I be using the timeout stuff in the new event manager?
21:11:52 <tibbe> stepcut: we're looking at making it scale better
21:12:05 <edwardk> danc: there are a whole host of 'further reading' options on http://snapframework.com/docs
21:12:14 <tibbe> stepcut: I would hope that the generic timeout function would be enough.
21:12:37 <stepcut> tibbe: me too. but as you know, the old timeout code had horrible performance and did not scale at all :)
21:13:02 <tibbe> stepcut: the timeout function now uses the new I/O manager so it should scale much much better
21:13:04 <stepcut> tibbe: so now all the frameworks have their own special timeout handling code.. but I would rather just use the generic stuff it is works well now.. I don't care about supporting the old IO manager these days
21:13:07 <tibbe> (it used to be O(n^2)
21:13:09 <DanC> ok... I have a hello world web server running... now... let's see how I did that...
21:13:30 <tibbe> stepcut: to be fair, they might have a good reason to. I haven't looked at this in a while
21:13:36 <stepcut> tibbe: right, it totally killed performance before.
21:14:05 <stepcut> well, they were all written before the new IO manager.. I think people have not bother to fix what ain't broken
21:14:33 <stepcut> but, I'll do some tests when I add timeout support to the new happstack backend and let you know how to pans out
21:14:38 <DanC> where is LANGUAGE OverloadedStrings defined? by ghc?
21:14:41 <stepcut> s/how to/how it/
21:14:48 <stepcut> clearly time for me to head to bed
21:14:56 <edwardk> DanC: yeah its a ghc extension
21:15:22 <zzing_> j'aime OverloadedStrings!
21:15:27 <edwardk> DanC: also snap init takes a few different command line options about what kind of project/tutorial to install in the current directory
21:15:31 <edwardk> one of them iirc is a tutorial
21:15:31 <stepcut> tibbe: if the idea is that the new timeout stuff is supposed to be good enough, then I'd like to purpose that route and submit patches if it isn't
21:15:31 <DanC> is there a `ghc --what-extensions` doodad? I don't see one in `ghc --help`.
21:16:19 * DanC supposes he should do a bit more searching/studing before asking here so quickly...
21:16:20 <stepcut> DanC: the GHC manual describes them all
21:16:21 <edwardk> danc: go into $ ghci     and type :set -X<tab>
21:16:31 <edwardk> the tab will cause it to autocomplete the language options
21:16:45 <edwardk> you'll see about 170 of em
21:17:03 <tibbe> stepcut: I would benchmark, but sure. There are benchmarks in our I/O manager paper
21:17:14 <DanC> "A list of all supported language extensions can be obtained by invoking ghc --supported-extensions"
21:17:21 <edwardk> there ya go
21:17:28 <DanC> -- http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/pragmas.html
21:18:01 <DanC> edwardk, how many of them are in your working vocabulary? Do you often have to look them up?
21:18:31 <edwardk> i use maybe 10 or so regularly. most of my code uses no extensions at all
21:18:44 <aristid> seems like i only use 12 extensions in aws. surprising, i would have thought it's more.
21:18:52 <danil> Almost all of them will give you an error "You need -XSomeExtension to do that" if you forget one
21:19:07 <edwardk> out of everything in http://github.com/ekmett/  maybe a third of the packages use extensions at all
21:19:08 <aristid> danil: sadly not for -XOverloadedStrings :)
21:19:08 <DanC> the CPP extension makes me giggle.
21:19:23 <stepcut> tibbe: right. In the new pipes based backend, it is easy to swapout the parts that actually read and write the network connection, so it will be easy to test 'no timeouts' vs 'with timeouts' and things like that.
21:19:56 <tibbe> stepcut: cool
21:20:11 * nand` counts ~20 extensions he recognizes / has used
21:20:12 <aristid> i wonder if there will actually be a winnder in the pipes/conduits/edwardk's tubes "war" anytime soon
21:20:18 <stepcut> and, to create dummy sources/sinks that are backed by RAM and don't even do any real IO so that we can see the overhead of IO vs the rest of the code (the parser, etc)
21:20:20 <edwardk> heh
21:20:25 <nand`> note that half of them are just the same with ‘No’ in the front
21:20:35 <nand`> (why? aren't they off by default, most of them at least?)
21:20:52 <danil> aristid: pipes and conduits seem to be converging to some degree
21:21:04 <DanC> ok... so much for line 1 of Main.hs from `snap init` :)
21:21:06 <Jafet> Perhaps you have code that won't work with them on
21:21:22 <stepcut> tibbe: that is also part of the purpose of acme-http.. to provide a very simple (but useful) http server with a tiny code base, so that we can figure out what the IO related bottlenecks are
21:21:27 <aristid> danil: yes, the main type in conduits is even called Pipe now
21:21:28 <Jafet> Though why you need to name something "foreign" is another thing
21:21:35 <DanC> none of the imports are qualified. sigh.
21:21:49 <aristid> DanC: you can fix that!
21:21:57 <tibbe> stepcut: I'd love to see a tiny standalone HTTP server
21:22:03 <edwardk> running through the list i've probably used about 60 of them. didn't feel like that many
21:22:05 <danil> DanC: frameworks tend to be like that :(
21:22:08 <BMeph> nand`: monomorphic restriction
21:22:13 <tibbe> stepcut: for example, the ekg package uses snap which is too large for what it really needs
21:22:18 <DanC> aristid, well, maybe I can fix it in this one file, but I doubt I can change the community norm
21:22:39 <aristid> tibbe: warp is too large, too?
21:22:41 <DanC> my quest tonight is only partly to write haskell; it's mostly to READ haskell.
21:23:03 <edwardk> DanC: have you looked at something like "Learn You a Haskell"?
21:23:05 <tibbe> aristid: warp is better in size but I couldn't get it to compile when I needed it (cabal hell)
21:23:10 <aristid> DanC: a lot of haskellers use qualified imports extensively
21:23:18 <stepcut> tibbe: well, acme-http is not suitable for real world usage, just testing performance and stuff. But, the new happstack backend will be separate like warp.
21:23:25 <DanC> yup. read "Learn You a Haskell". Didn't write any code right after reading it though. :-/
21:23:28 <DanC> so it leaked out.
21:23:36 <nand`> BMeph: that covers one of ~80 :)
21:23:58 <nand`> BMeph: but I guess it's for future-proofing in case the default every changes
21:24:11 <edwardk> nand`: re -XNoFoo they are useful if you turn them on in cabal, to turn them off for specific modules
21:24:13 <tibbe> stepcut: I want something like Clojure's ring framework i.e. a web framework that doesn't follow the OO frameworks' path but instead has a more functional and compositional style
21:24:26 * DanC is curious... peeks at http://hackage.haskell.org/package/acme-http ...
21:24:35 <aristid> edwardk: or for NoMonomorphismRestriction
21:24:45 <tibbe> stepcut: today's haskell web frameworks all seem to have ended up in some big state monad
21:24:50 <nand`> that was mentioned :)
21:25:02 <aristid> nand`: sorry, missed that:)
21:25:46 <edwardk> tibbe: i'd love to see that actually
21:26:00 <DanC> {-# LANGUAGE DeriveDataTypeable, RankNTypes, RecordWildCards #-}
21:26:09 <DanC> ^ are those run-of-the-mill?
21:26:19 <DanC> (taken from Acme/Types.hs)
21:26:19 <Jafet> No
21:26:29 <aristid> i think they're fair game :)
21:26:41 <nand`> RankNTypes might be the most common of those
21:26:47 <DanC> qualified imports! yummy!
21:26:48 <nand`> I don't even know what RecordWildCards does
21:27:00 <stepcut> tibbe: yeah, I have been trying to split happstack up into smaller pieces. For example, the type-safe routing is a standalone thing, etc. But, building a big tower of monad transformers doesn't seem quite right either
21:27:12 <aristid> nand`: Foo{..} and all fields of Foo are in scope
21:27:12 <edwardk> nand`: they let you pattern match with Foo{..}  and bring into scope local named versions of all the fields of Foo
21:27:12 <Jafet> Every extension is use somewhere, but very little code uses any particular extension
21:27:20 <nand`> ah, that
21:27:23 <nand`> yes, I remember that
21:27:27 <aristid> nand`: you can also create records that way
21:27:29 <edwardk> nand`: they are kinda nice when youhave big nasty records
21:27:38 <aristid> can be convenient *shrug*
21:27:41 <stepcut> tibbe: I would love to discuss this again later though (as I am about to head to bed).
21:28:15 <edwardk> stepcut: clearly the answer is lenses ;)
21:28:43 * nand` will give a shot at transforming lenses using arrow notation tomorrow
21:28:48 <stepcut> edwardk: for some stuff… definitely. Something like IxSet that can actually support lenses correctly and auto-increment would be awesome
21:28:59 <nand`> I'm curious to see what kind of party tricks can be done that way
21:29:04 <tibbe> edwardk: I would write it myself if I had the time, but I have two other projects baking at the moment
21:29:12 <edwardk> tibbe: i feel your pain
21:29:13 <tibbe> stepcut: gnight, just grab me on irc at any time
21:29:29 <tibbe> edwardk: snap/yesod are good enough for now
21:29:37 <stepcut> it seems like collect types with multiple keys/indexes is a big hole in Haskell.. we have Set and Map.. but nothing with multiple keys
21:29:38 <edwardk> nand`: yeah i started a toy example earlier, still feeling out the space
21:29:38 <aristid> stepcut: there is no problem that can't be solved with lenses and isomorphisms!
21:30:04 <nand`> edwardk: I've just never used arrow syntax before, so I'll have to intuitize that f irst
21:30:16 <DanC> hmm... records don't seem to form their own namespace.
21:30:18 <edwardk> stepcut: yeah i think i ported the happstack ixset out some time long long ago so i could use it outside of the ecosystem for something datalogish
21:30:23 <edwardk> DanC: correct
21:30:27 <edwardk> its a good thing
21:30:31 <edwardk> well, some disagree
21:30:36 <nand`> “there's no problem that can't be solved with lenses, bananas and barbed wire”
21:30:36 <edwardk> but they are just functions like any other
21:30:36 <DanC> doesn't smell good to me.
21:30:46 <nand`> then again, lenses make bananas obsolete
21:30:51 <edwardk> you get used to it. it actually makes a big difference in the inferability of types
21:30:52 <stepcut> edwardk: it is a standalone library now.. IxSet.. though I think it depends on SafeCopy
21:31:33 * DanC tries to remember how scheme records work
21:31:34 <stepcut> but.. there are a lot of ways that IxSet could be improved on..
21:32:25 <stepcut> the hard part about supporting multiple keys on haskell data types is avoiding rebuilding all the indexes from scratch after a deletion/modification
21:32:31 <edwardk> yep
21:32:32 <nand`> DanC: usually the idiom is to export the fields of a data type in some module; then import that qualified instead; eg. import qualified Data.Bar.Foo as Foo; then you can refer to field names as Foo.x, Foo.bar, etc.
21:32:49 <nand`> or is that not what you meant by ‘namespaces’?
21:33:02 <DanC> yes, that's the sort of thing I was thinking
21:33:03 <edwardk> or to just use makeClassy to make a class for the data type, and prepend a lens from it on all the lenses
21:33:26 <stepcut> one option is to use a kdtree/kdmap, where you alternate which key you compare on every time you go down a level in the tree.. but the tree rebalances can be very expensive for kdtrees
21:33:37 <nand`> edwardk: the whole makeClassy thing reminds me an awful lot of subtyping
21:33:38 <edwardk> DanC: there are workarounds for it, in general we just don't use big record types
21:33:42 <edwardk> nand`: it should
21:33:46 <stepcut> tibbe: are you going to icfp?
21:34:06 <edwardk> DanC: overloading is better done by using a typeclass and putting the methods in that
21:34:11 <nand`> duck typing; even, ‘if it implements HasDuck where quack, walk; it's a duck’
21:34:15 <edwardk> DanC: then you can make instances for your respective types
21:34:51 <edwardk> stepcut: i'm tempted to see if some of my old columnstore tricks adapt to in memory haskell usage
21:35:12 <edwardk> i'm out of nda on that stuff finally, so i can think about it again
21:35:21 <stepcut> DanC: this was the acme-http release announcement, http://www.haskell.org/pipermail/web-devel/2012/002409.html
21:35:55 <nand`> edwardk: so now we have automatic subtyping analogs, OOP syntax for ‘accessors/mutators’ and pretty syntax for working with huge state monads
21:36:05 <nand`> next wave of imperative haskell comes when?
21:36:06 <edwardk> nand`: yep
21:36:19 <stepcut> edwardk: neat.. would we be really awesome is if we could store only the keys in RAM and store the values on disk, returning an enumerator-like thing that allows you to read the values. But still acting like a pure data structure
21:37:06 <DanC> "it should be very easy to understand"
21:38:18 <stepcut> ooo. I forgot that acme-http uses non-lazy IO, suck it conduits!
21:38:22 <tibbe> stepcut: yup! hosting the haskell implementors workshop
21:38:36 <edwardk> stepcut: if i were to do it all over again i'd probably go with an index in memory for the recently inserted/deleted rows and the big flat columnstore files on disk that the index supplements, traversal then is walking both in parallel skipping 'deleted' rows and inserting the missing ones on disk, and when the in memory tree gets too big you flush it to disk. durability requires an atom-style log on top, so its not all memory usage, 
21:38:36 <edwardk>  still better
21:38:38 <stepcut> tibbe: nice. What day is that ?
21:38:46 <tibbe> stepcut: Friday IIRC
21:39:25 <stepcut> tibbe: ah.. I will be doing a Happstack workshop at CUFP on Friday morning. :) So.. perhaps I'll buy you a drink and you tell me all your ideas for a non-sucky web framework :)
21:39:43 <stepcut> by 'doing' I mean 'giving'
21:39:56 <DanC> ok... I think I grok Echo.hs ...
21:40:17 <tibbe> stepcut: deal :)
21:40:25 <DanC> on to Acme/Serve.hs...
21:40:36 <tibbe> stepcut: I guess we have the whole week (if you're there) to have drinks. I plan to have many a beer on the water.
21:40:56 <stepcut> tibbe: yeah, I'll be there the 9th through the 16th
21:41:09 <tibbe> stepcut: I'll be there mon-sat
21:41:12 <stepcut> tibbe: any buying drinks for anyone that wants to talk about haskell web frameworks :)
21:41:19 <stepcut>  s/any/and/
21:41:29 <tibbe> stepcut: :)
21:41:50 <tibbe> stepcut: I'm up for it. I think I know how to port Ring to Haskell (and what to not mimic)
21:41:55 <stepcut> nice
21:43:46 <tibbe> afk
21:44:08 * stepcut heads to bed before he makes any more stupid typos
21:47:39 <edwardk> heh, lens is now more than 60% comments, i think thats a first
21:47:42 <edwardk> at least for me
21:48:22 <Cale> Is it in .lhs format? :)
21:48:56 <edwardk> heh, hs actually. should be at this rate ;)
21:52:07 <DanC> this "cannot find module" thing in ghci-under-emacs thing is getting annoying. Any idea how ghci knows about ~/.cabal stuff?
21:52:27 <pharaun> i got a parsec question, is it possible to make the error message on a parse fail generate/show where it came from?
21:52:34 <pharaun> i'm trying to trace a parsing failure
21:53:17 <danil> DanC: cabal registers packages with ghc when it installs them, but you have to restart ghci for it to see the new ones
21:53:34 <DanC> I restarted emacs. no joy.
21:53:48 <DanC> what does it mean to register a package with ghc?
21:54:25 <DanC> hmm.
21:54:32 <DanC> restarted again; now I seem to be winning.
21:54:34 <hpaste> pharaun pasted “parsec - parsing fail” at http://hpaste.org/72817
21:55:04 <danil> you shouldn't have to kill emacs, just the inf-haskell buffer
21:55:40 <pharaun> and yes i know the parsec code is awful, i'm working on it :) but anyway i seem to be choking up on the char ':' in the ipPort in the larger parser even tho it success when i try it on its own
21:56:08 <DanC> now `:info Control.Applicative` is losing with: Failed to load interface for `Control'
21:56:36 <aristid> DanC: :m +Control.Applicative to load the module
21:56:45 <aristid> :info is for info about already loaded types and functions
21:56:45 <DanC> hmm. ok.
21:57:25 <danil> :info works on things that aren't loaded, but not on modules -- if you say :info Control.Applicative it tries to look for a type or constructor named "Applicative" in the "Control" module
21:58:33 <danil> (:browse might be what you were expecting)
21:58:38 <aristid> danil: heh, i never even tried doing that, good to know
21:58:57 <DanC> I'm trying to use this inferior-haskell-find-haddock thing. feels like a tease!
21:59:16 <aristid> DanC: and i didn't even know about :browse! omg
21:59:22 <aristid> i mean danil
22:00:08 <danil> aristid: I do it all the time after I jump to a type error and want to know the type of some library function, because if you :reload and get a type error you no longer have the names you imported in scope
22:00:09 <pharaun> doh - re my parsec issue, i was able to resolve it by enclosing the do with a try before the <|> so that it would then fall back to return ("", "')
22:00:14 <pharaun> nvm my pastie
22:00:46 <DanC> man, I just can't figure this out. How do you use the types as documentation, in practice?
22:00:52 <DanC> how do you look them up?
22:00:59 <pharaun> hoogle
22:01:38 <pharaun> that's what i usually reach for when i'm looking up some type info that i'm not able to figure out via :t
22:02:23 <DanC> but don't I have to figure out which module a symbol is imported from? how can hoogle help, if it's not looking at my source file?
22:02:53 <startling> DanC: :t
22:03:00 <startling> DanC: (in ghci)
22:03:14 <DanC> Prelude> :t <|>
22:03:14 <DanC> <interactive>:1:1: parse error on input `<|>'
22:03:19 <startling> :t (<|>)
22:03:21 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
22:03:41 <DanC> but couldn't <|> be imported from somewhere else?
22:03:52 <startling> DanC: sure. that's why you use it in ghci
22:03:56 <DanC> :t echoHandler
22:03:57 <lambdabot> Not in scope: `echoHandler'
22:04:06 <edwardk> :info DanC use :info (<|>) to find out where it came from
22:04:24 <Boney>  /win 12
22:04:32 <DanC> Prelude> :info (<|>)
22:04:32 <DanC> Top level: Not in scope: `<|>'
22:04:35 <danil> if you load a module in ghci you get the same things in scope at the prompt as in the module
22:04:43 <edwardk> DanC: in practice you'll find there are a large number of standard operators you'll get from canonical locations, so the 'how to find where something came from' problem isn't that big of a deal
22:04:50 <edwardk> you have to have import Control.Applicative first
22:04:58 <edwardk> if you don't know at all use hoogle
22:05:01 <edwardk> @where hoogle
22:05:02 <lambdabot> http://haskell.org/hoogle
22:05:16 <jfischoff> hayoo is good too
22:05:41 <edwardk> i have no preference between hoogle and hayoo as i think i've used either maybe once in the last 12 months, go with what jfischoff says ;)
22:05:58 <danil> incidentally, is there a good reason :info works on operators but :type doesn't?
22:05:59 <edwardk> speaking of jfischoff
22:06:07 <startling> :type (<|>)
22:06:07 <jfischoff> hello hello
22:06:12 <DanC> I seem to be looking for an answer that I am evidently not going to get: you don't go into emacs, put the cursor over a symbol, and hit a few keys, and get the type and some documentation?
22:06:13 <edwardk> jfischoff: I think i have a fix for your sliding fourier transform window
22:06:22 <danil> (I know the actual reason is that :type tries to parse an expression, but that's not particularly convincing to me when it's clear how to do the right thing)
22:06:24 <jfischoff> do tell
22:06:34 <edwardk> what do you know about cyclotomic numbers?
22:06:59 <jfischoff> edwardk: that a magical package appeared on hackage a few weeks ago
22:07:13 <edwardk> uh-huh. do you know anything about their properties?
22:07:16 <aristid> DanC: well, maybe the github haskell-mode has some special mode for that
22:07:17 <startling> DanC: I don't. usually I have ghci open in m-x ansi-term, loaded with the thing I'm working on
22:07:24 <jfischoff> edwardk: very little
22:07:40 <ninegrid> does anyone use haskellmode in vim?  i'm curious as to how I go about generating the tags file when I import my own module from a file in the same project
22:07:46 <edwardk> like how they are basically extended over all of the various nth roots of unity exactly?
22:07:52 <aristid> DanC: https://github.com/haskell/haskell-mode - do not use haskell-mode 2.8.0 :)
22:07:56 <edwardk> hint hint
22:08:11 <jfischoff> edwardk: yes they are good candidate for an exact sdft
22:08:17 <edwardk> =)
22:08:23 <jfischoff> edwardk: I'm glad you reminded me
22:08:29 <edwardk> so you can do your rotation-based approach without losing accuracy
22:08:31 <DanC> I wonder what version I'm using...
22:08:35 <jfischoff> edwardk: yes
22:08:47 <DanC> Installed: 2.8.0-1
22:09:02 <aristid> DanC: or rather, by all means use haskell-mode 2.8.0 if it's too much hassle otherwise. it just doesn't have all the stuffs
22:09:13 <edwardk> i'd be curious to see where the factoring overhead of cyclotomic numbers and the number crunching overhead of fft meet
22:09:21 <aristid> DanC: but even with the new haskell-mode you need to explicitly enable many of the new fancy features
22:09:35 <jfischoff> edwardk: In fact I started to write one using the package on hackage but I didn't work in 30 minutes I put into for some reason, I and I haven't gotten back to it
22:09:48 <jfischoff> edwardk: they are so slow
22:10:01 <edwardk> sclv sat down with scott at hac phi and helped somewhat
22:10:08 <edwardk> but its currently bottlenecked on factorization
22:10:12 <jfischoff> edwardk: ah cool
22:10:32 <DanC> ok. I suppose I do the same thing with python (use the interpreter in a terminal, not tightly integrated with emacs). Though I have become addicated to flymake.
22:11:03 <jfischoff> well one more unfinished project to get too :)
22:11:14 <edwardk> let me know how it goes
22:11:26 <edwardk> i just wanted to make sure you were aware that there was a cyclotomic solution available
22:11:40 <edwardk> and that it fit the domain perfectly
22:11:43 <aristid> DanC: the new haskell-mode has what you need, and if you use MELPA it isn't all that hard to install, though (http://melpa.milkbox.net/)
22:11:51 <jfischoff> edwardk: yeah totally, I'll let you know
22:11:56 <jfischoff> well off to bed
22:12:00 <jfischoff> good night!
22:12:00 <edwardk> night man
22:12:31 <DanC> MELPA... er... that's _another_ emacs package manager?
22:13:51 <aristid> DanC: no.
22:14:03 <aristid> DanC: it's just a repository with bleeding-edge stuff for package.el.
22:14:05 <startling> DanC: it's a repository
22:14:13 <DanC> "... in your init.el file." seems to assume I have an init.el file.
22:14:22 <aristid> you probably have a .emacs
22:14:34 <aristid> init.el and .emacs are the same thing
22:14:51 <DanC> yes, and I have probably used package.el; I just have this thing about web pages that assume context, when it's so simple to add a link
22:15:44 <aristid> ok, good night.
22:17:00 <Sopoforic> I'm trying to use ghc on Windows, but gcc keeps failing to terminate--even when it is successful. It just sits there. Anyone know what might be happening?
22:22:46 <pharaun> is there any recommended doc for parsec ?
22:23:17 <pharaun> or is it just mainly poking at the hackage docs
22:23:19 <Cale> pharaun: There are two main things I'd recommend: http://hackage.haskell.org/package/parsec-3.1.3
22:23:25 <avpx> pharaun: The haddock documentation is a good reference. Real World Haskell has a chapter
22:23:27 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
22:23:38 <Jafet> The haddock is easy once you know how parsec works
22:23:39 <Cale> ^^ this one is old, and some things have moved around a bit
22:23:45 <Cale> but it's a good tutorial
22:24:09 <pharaun> heh sweet thanks :)
22:24:19 <avpx> Yeah, once you get what the bits of the Parsec monad do, it's not too bad. Just a lot of gluing parsers together.
22:24:33 <nus--> Sopoforic, do you have a testcase?
22:24:36 <pharaun> already read the chapter in the real world haskell, still trying to find my way around and finding where the relevant bits are at
22:25:09 <Sopoforic> nus, sure, but it happens universally.
22:25:27 <Jafet> The haddock could stand to use a few more words
22:25:36 <Jafet> Like what ParsecT actually means
22:25:58 <hpaste> Sopoforic pasted “gcc stall test case” at http://hpaste.org/72820
22:26:34 <Jafet> Oh, it does has a few words
22:26:42 <nus> how do you mean? you start ghc and it hangs indefinitely?
22:27:09 <Sopoforic> Yes. Sometimes it does succeed--there will be a working executable--and occasionally it even terminates.
22:27:17 <Sopoforic> 90% of the time, though, it just stalls.
22:28:07 <DanC> whee! got MELPA installed (ack: http://stackoverflow.com/questions/7287947/adding-marmalade-as-package-source ) and modern haskell-mode
22:28:15 <Sopoforic> If I kill ghc with ^C, the gcc process is still running. I have to kill it manually.
22:28:24 <DanC> and emacs looks up <|> for me.
22:29:14 <nus> Sopoforic, what does 'ghc -v' show?
22:29:19 <startling> DanC, how?
22:29:54 <DanC> C-c M-.		inferior-haskell-find-definition
22:30:30 <DanC> i.e. use the "Load file" menu option, then put the cursor on <|> and do C-c M-.
22:30:37 <hpaste> Sopoforic pasted “ghc -v” at http://hpaste.org/72821
22:30:47 <DanC> up pops the type in the ghci buffer, plus firefox with web docs.
22:31:11 <nus> Sopoforic, I meant when compiling the testcase
22:31:16 <Sopoforic> Ah, sorry.
22:32:39 <hpaste> Sopoforic pasted “ghc -v 004.hs” at http://hpaste.org/72822
22:33:04 <Boney> win 12
22:33:09 <Boney> oops agian.
22:35:35 <nus> Sopoforic, so, what's the gcc process doing at the time?
22:36:26 <Sopoforic> nus, nothing, as far as I can tell--no processor usage, and about a megabyte of memory.
22:37:06 <Sopoforic> 004.hi and 004.o have been produced, but that's it. It's still just sitting there.
22:37:48 <Sopoforic> If I rerun "ghc 004.hs" a few more times, I'll eventually get a linked executable. But it is just a matter of chance when this will happen.
22:38:15 <DanC> hmm. I guess <|> is abstract. Next question: how do I figure out which is the relevant concrete class/implementation?
22:39:04 <nus> Sopoforic, hmm, let's see if "ghc -optc=-v' would show anything useful
22:40:33 <Sopoforic> It just reads "[1 of 1] Compiling Main             ( 004.hs, 004.o )" and stalls, this time.
22:41:07 <pharaun> do we already have an parsec for ipv4/ipv6 or am i going to need to construct one?
22:41:12 <Sopoforic> I ran it a couple more times and it progressed... just a moment.
22:42:02 <slack1256> are hUnit and QuickCheck used for the same purpose or are for different cases?
22:42:25 <hpaste> Sopoforic pasted “ghcc -optc=-v 004.hs” at http://hpaste.org/72823
22:45:21 <XMan> Hello
22:45:30 <DanC> "ifTop only executes its argument if the client requested the root URL." <- how to square that with the lazy functional nature of haskell?
22:45:43 <slack1256> Hello Xman
22:45:47 <slack1256> *XMan
22:46:31 <XMan> How are you, slack1256?
22:46:40 <DanC> "If you’re not familiar with Haskell, you may be wondering about the <|>. It is simply a binary operator that evaluates its first argument, and if it failed, evaluates the second." hmm... what does "failed" mean?
22:47:12 <Sopoforic> nus, although gcc has still not terminated, it has produced a working 004.exe this time.
22:47:14 <shachaf> DanC: "failure" is something defined by the type of the first argument.
22:47:26 <avpx> DanC: An "expected" error, for instance.
22:47:37 <avpx> I expected a digit but saw a comma, now I'll try the alternative parser.
22:47:46 <DanC> defined how?
22:47:58 <slack1256> XMan: I'm ok, what about you.
22:48:10 <nus> Sopoforic, 'ghc -keep-tmp-files' and then manually execute the gcc command
22:48:27 <avpx> DanC: It's all in Text.Parsec.Prim. "The parsers fail, (<?>), and unexpected are the three parsers used to generate error messages."
22:48:45 <Sopoforic> nus, which gcc command, precisely?
22:48:53 <avpx> What failure *actually* is doesn't matter; it's all encapsulated in the implementation of the Parsec monad
22:48:55 <DanC> Snap is using Text.Parsec for routing?
22:49:46 <DanC> my quote above is from http://snapframework.com/docs/tutorials/snap-api
22:49:52 <XMan> slack1256: i'm ok too.
22:50:34 <Sopoforic> nus, also, it still stalls when running "ghc -keep-tmp-files"--do you intend for me to kill the process?
22:50:39 <shysoft> I'm attempting to pass an "IO Font" into a method like "draw :: Font -> String -> IO Surface". (let font = openFont "file.ttf"; draw font "string" surface) But, the compiler's complaining that "Font" doesn't match the expected type "IO Font". How do I fix this?
22:50:52 <nus> Sopoforic, the one `ghc -v' shows you
22:50:54 <shachaf> shysoft: You should read the FAQ about that.
22:50:58 <shachaf> @where faq
22:50:59 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:51:14 <shysoft> which section?
22:51:17 <shachaf> shysoft: One short answer is to do { font <- openFont "file.ttf"; draw font "string" surface)
22:51:18 <nus> Sopoforic, yep, kill it
22:51:43 <shachaf> shysoft: In particular 5.10, I guess?
22:52:05 <shachaf> shysoft: It's important to understand how IO works in Haskell. For example, a value of type "IO Font" doesn't contain a Font at all.
22:52:08 <shachaf> @quote /bin/ls
22:52:09 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
22:52:25 <DanC> ok... Snap is an instance of Alternative
22:52:28 <avpx> You could also consider (\font -> draw font "string" surface) =<< openFond "file.ttf"
22:52:33 <arcatan> DanC: no, <|> comes from the type class instance Alternative Snap.
22:52:35 <avpx> Basically the same as the do notation solution
22:52:45 <arcatan> DanC: yes, you beat me to it
22:53:49 <DanC> (<|>) = mplus
22:53:54 <DanC> hmm...
22:54:38 <DanC> ok... instance MonadPlus Snap where ...
22:57:04 <Sopoforic> nus, I can't make it work--it doesn't seem to actually keep the tmp files, because I get an error about a missing one.
22:57:30 <certainty> moin
22:58:20 <avpx> DanC: Essentially a monad endowed with an associative operation and an identity, making it a monoid.
22:59:11 <arcatan> here are Snap's relevant instances: https://github.com/snapframework/snap-core/blob/master/src/Snap/Internal/Types.hs
22:59:31 <Sopoforic> nus, and this time, gcc stalled when outputting 004.o, but it actually succeeded at that, and running that command again doesn't help.
22:59:43 <DanC> I get the monoid part (from algebra etc.). I'm still building intuitions around how that relates to a monad.
22:59:45 <Sopoforic> nus, I fear this may be intractable.
23:00:08 <nus> Sopoforic, most likely there's something wrong with your system
23:00:12 <avpx> DanC: That's understandable, so it may take some examples. For instance, the zero element in the list monad is the empty list, []
23:00:45 <DanC> mplus is ++?
23:01:01 <avpx> > [1,2,3] `mplus` [4,5,6]
23:01:03 <lambdabot>   [1,2,3,4,5,6]
23:01:04 <Sopoforic> nus, since it's Vista, I don't doubt it. I thought it less likely since the haskell platform includes its own gcc, but there may be some trouble here.
23:01:31 <Sopoforic> I'll just develop haskell from a linux machine, instead, I guess.
23:02:11 <Sopoforic> nus, thanks for all your assistance.
23:02:41 <avpx> DanC: MonadPlus is how you make a monad that can be filtered. If you want to remove an element, send it to [], otherwise send it to [a].
23:02:48 <sopvop> Snap alternative intance checks SnapResult from action on left of <|>, if it's SnapValue or EarlyTermination, it choses this result. if its PassProcessing -> runs action on the left.   https://github.com/snapframework/snap-core/blob/master/src/Snap/Internal/Types.hs#L135
23:03:07 <avpx> DanC: So it's got some cool connections in Haskell
23:03:39 <nus> Sopoforic, np... also checking if the gcc behaves same way on a hello world'ish testcase might help
23:03:40 <sopvop> runs action on the right
23:04:43 <DanC> this sort of thing hurts my brain: newtype Snap a = Snap { ... }
23:05:08 <DanC> just when I thought I knew what Snap was, I learn that "Snap" refers to more than one thing.
23:05:25 <startling> DanC: Snap is both the constructor and the name of the type
23:05:37 <DanC> type constructor, to be specific, right?
23:05:49 <DanC> er...
23:05:53 <sopvop> newtype is like data but with one constructor only
23:05:54 <shachaf> It's a type constructor, but startling meant the value constructor.
23:05:59 <startling> data constructor
23:05:59 <DanC> it's a type constructor and a data constructor, yes?
23:06:12 <startling> yes
23:06:33 <sopvop> Haskell has 2 namespaces, one for functions (constructors are just functions) and one for types. So one name can be in both.
23:06:48 <DanC> this is to make sure mere mortals stay away?
23:07:00 <sopvop> To make trolling #haskell harder
23:07:10 <DanC> heh
23:07:30 <DanC> scala does likewise. drives me bananas.
23:07:54 <DanC> coming from python, I often forget the new in: val x = new Widget()
23:08:16 <DanC> so the compiler says it has never heard of Widget, when Widget is defined 10 lines above.
23:08:39 <sopvop> I think you should start here http://learnyouahaskell.com/ then move to http://book.realworldhaskell.org/
23:08:57 <DanC> "oh... you mean _Widget_. You said Widget. Totally different."
23:09:00 <avpx> That's what I did, and look how I turned out.
23:09:07 <DanC> as I said, already read those.
23:09:42 <DanC> I don't recall reading any motivation for this 2 namespace stuff.
23:10:34 <avpx> DanC: I think it makes sense to want to have a constructor named the same thing as the type it constructs.
23:10:57 <startling> me too
23:12:06 <DanC> my instinct would be to have syntax for "a constructor that makes an X".
23:12:24 <DanC> but I guess that in general, there's a many-to-one relationship...
23:12:33 <DanC> between constructors and types
23:12:36 <iamtakin1iteasy> why can i do this:
23:12:38 <iamtakin1iteasy> > runReader (local id ask) ([1,2,3])
23:12:40 <lambdabot>   [1,2,3]
23:12:48 <iamtakin1iteasy> when i can't do this:
23:12:54 <sopvop> How about  data Color = Red | Green | Blue. Red, Green and Blue are constructors what make Color
23:12:56 <iamtakin1iteasy> > runReader (ask >>= local id) ([1,2,3])
23:12:58 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.Reader.ReaderT
23:12:59 <lambdabot>           ...
23:13:19 <iamtakin1iteasy> ah, got it
23:13:21 <avpx> iamtakin1iteasy: Because those are totally different things
23:13:24 <iamtakin1iteasy> i am an idiot
23:13:25 <iamtakin1iteasy> :)
23:13:29 <avpx> Naw man
23:13:38 <iamtakin1iteasy> bind de-composing m a to a
23:13:41 <startling> iamtakin1iteasy: that's what you get for taking it easy!
23:13:47 <startling> time to buckle down, son
23:13:54 <avpx> Yeah, taking it easy time is over
23:14:06 <iamtakin1iteasy> eye em not baka!
23:14:08 <avpx> Being really stressed out, that's just beginning
23:16:47 <avpx> DanC: Here's how I reason about it: data encompasses something like C unions (data Maybe a = Just a | Nothing) and something like structs, a bundling of data. When you're in that latter case, you really just want a constructor that takes some arguments and makes your type.
23:17:02 <avpx> newtype Foo a = Foo {getFoo :: a}
23:17:10 <shachaf> avpx: Sum types ("|") is very different from C unions.
23:17:19 <avpx> scgilardi: "Something like"
23:17:43 <shachaf> Right, but it's really different. :-)
23:18:12 <avpx> shachaf: It's hard to find analogues?
23:18:20 <DanC> I guess C had some of the same multi-namespace stuff around structs and types.
23:18:21 <sopvop> sum types are pretty much tagged unions of C
23:18:49 <DanC> with less shooting-yourself-in-the-foot-cuz-you-mixed-up-the-tag
23:18:54 <avpx> My point is that a function will never appear where a type will and vice-versa. So there's really no ambiguity in naming a constructor the same as the type it makes
23:19:06 <startling> yeah. so dumb that C unions aren't automatically tagged
23:19:32 <DanC> no ambiguity... which is fine for the machine, but this brain isn't trained to read it yet.
23:19:33 <avpx> Still, I wouldn't expect to see data Maybe a = Maybe a | Nothing, because that would be pretty ambiguous
23:19:46 <startling> avpx: how so?
23:19:49 <shachaf> DanC: It's mostly a matter of getting used to it.
23:19:57 <shachaf> DanC: Some people do things like data Foo = MkFoo { ... }
23:19:59 <avpx> startling: Hrrm, ambiguous isn't the right term
23:20:09 <DanC> struggling to figure out where Snap.Internal.Types gets StateT
23:20:19 <avpx> startling: It's perfectly meaningful, but it's just confusing
23:20:31 <startling> @hoogle StateT
23:20:32 <lambdabot> Control.Monad.State.Lazy StateT :: (s -> m (a, s)) -> StateT s a
23:20:32 <lambdabot> Control.Monad.State.Strict StateT :: (s -> m (a, s)) -> StateT s a
23:20:32 <lambdabot> Control.Monad.Trans.State.Lazy StateT :: (s -> m (a, s)) -> StateT s m a
23:20:34 <DanC> it imports Control.Monad.State, but I can't find that in hoogle
23:20:45 <hpaste> sopvop pasted “ADT in c, straigh from wikipedia” at http://hpaste.org/72824
23:21:28 <iamtakingiteasy> but btw, why may you want to use Reader monad instead of State monad?
23:21:40 <iamtakingiteasy> i can't see a big difference between them
23:21:49 <iamtakingiteasy> too easy? XD
23:22:21 <Veinor> if you use Reader, you can prove that you can't ever change the state
23:22:40 <DanC> startling, Snap.Internal.Types isn't importing any of those 3, as far as I can tell
23:22:54 <avpx> iamtakingiteasy: You can certainly use the State monad to do Reader tasks, but it's just a bit overkill
23:22:58 <startling> DanC, import Snap.Internal.Types and then :info StateT
23:24:31 <DanC> Top level: Not in scope: data constructor `StateT
23:25:24 <startling> oh right, :info is only for values
23:26:35 <iamtakingiteasy> ah, i think got it
23:26:54 <mightybyte_> DanC: There are a few links for Haskell documentation that I keep in my bookmark bar and use all the time.
23:27:03 <mightybyte_> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
23:27:03 <iamtakingiteasy> with Reader you're getting environmnet that can be changed only on current or deeper heirarchy levels
23:27:04 <DanC> found http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State.html
23:27:34 <mightybyte_> http://hackage.haskell.org/package/ (this one I make sure is always the first thing to come up in autocomplete when I type "hack")
23:27:39 <iamtakingiteasy> by passing current Reader state to deeper levels
23:28:11 <mightybyte_> Then I have bookmarks to both hoogle and hayoo
23:28:17 <iamtakingiteasy> so thay can may do their local changes and (if they wish) - to pass this state even deeper
23:28:24 <iamtakingiteasy> am i correct?
23:28:41 <mightybyte_> Also http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009 is sometimes useful.
23:29:41 <avpx> iamtakingiteasy: No, with reader you're not allowed to change the state
23:30:22 <iamtakingiteasy> that what (local) do ?
23:30:34 <iamtakingiteasy> then*
23:30:42 <avpx> What code are you referring to?
23:31:09 <iamtakingiteasy> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Reader-Class.html
23:31:43 <mightybyte_> DanC: The last to bookmarks in my toolbar are for the transformers and mtl packages because they are used all over the place.
23:31:45 <avpx> Ah, I see. Yeah, you're right.
23:31:46 <DanC> ooh! Control.Monad.State docs include an example!
23:31:51 <mightybyte_> http://hackage.haskell.org/package/transformers
23:31:58 <mightybyte_> http://hackage.haskell.org/package/mtl
23:32:13 <pharaun> best way to eat a space with parsec?  Basically i'm doing - codeString <- many1 (noneOf "-\n")  which yield "foobar ", "data" for the string "foobar - data", i have more code to handle the - data part.
23:32:39 <pharaun> i'm wondering how i can get rid of the space after foobar? i want to eat string till a " -" or '\n'
23:32:50 <DanC> mtl has some scary-looking labels: "non-portable" and "experimental". not really scary?
23:33:04 <startling> pharaun: skipMany, iirc
23:33:26 <startling> DanC: correct
23:33:41 <mightybyte_> DanC: http://donsbot.wordpress.com/2010/06/30/popular-haskell-packages-q2-2010-report/
23:33:41 <startling> DanC: non-portable means ghc only, which is common these days
23:33:45 <pharaun> startling: yeah i tried that but i was not sure how to construct it in the "many1 (noneOf "-\n")" expression, because it "eats" that extra space before the "-"
23:33:45 <mightybyte_> It's in the top 10
23:34:13 <pharaun> startling: i already use skipMany for the space after the "-" so i end up with "data" for the second part
23:35:26 <DanC> most popular apps all look like dev tools. hmm.
23:35:53 <pharaun> startling: as you can see here "codeString <- many1 (noneOf "-\n"); codeExtra <- option "" (char '-' >> skipMany space >> many (noneOf "\n"))"
23:37:08 <startling> wow, agda is in top 15
23:37:12 <DanC> liftM . hmm. too bad it's way past my bed time. I'm almost swapped-in enough to get my head around that now.
23:37:17 <startling> pharaun: dunno, sorry
23:37:31 <startling> :t liftM
23:37:33 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:37:47 <startling> @src liftM
23:37:48 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:37:53 <shachaf> DanC: liftM is just fmap
23:37:56 <porco> :T map
23:37:58 <porco> :t map
23:38:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:38:02 <pharaun> startling: hmm alright np :)
23:38:38 <startling> why isn't liftM just (return .)?
23:38:45 <startling> :t (return .)
23:38:46 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
23:39:00 <startling> oh wait
23:39:03 <Nereid> :t (return Prelude..)
23:39:05 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
23:39:12 <DanC> ok... the type signature of liftM is reasonably clear...
23:39:20 <c_wraith> :t (>>=) . (return .)
23:39:20 <Nereid> fmap = liftM
23:39:22 <lambdabot> forall (m :: * -> *) b a (m1 :: * -> *). (Monad m, Monad m1, Functor m) => m a -> (m1 a -> m b) -> m b
23:39:24 * DanC re-skims http://learnyouahaskell.com/for-a-few-monads-more
23:39:47 <startling> DanC, the idea is just to wrap the result of a function
23:39:50 <c_wraith> whoops.  wrong argument.  Oh well.
23:40:06 <shachaf> "wrap" :_(
23:40:10 <shachaf> s/_/-/
23:40:28 <startling> oh, and make it operate on a Monad too
23:40:41 <DanC> ok... so I guess I grok this now: evalStateT m s = liftM fst (runStateT m s)
23:41:01 <startling> shachaf, I understand that "wrap" is problematic, but how else would you describe "return"?
23:41:33 <shachaf> startling: I thought we were talking about fmap? :-)
23:41:44 <startling> shachaf: hm?
23:41:49 <startling> we were talking about liftM
23:41:58 <shachaf> liftM is fmap.
23:41:58 <Nereid> fmap = liftM
23:42:08 <shachaf> Better to understand fmap, which you don't need "return" for.
23:42:24 <startling> ah, i guess
23:42:43 <startling> Monads use return for their Functor instance though, right?
23:42:53 <mightybyte_> DanC: You should check out Brent Yorgey's Typeclassopedia.
23:42:54 <shachaf> "Monads" don't have a Functor instance.
23:43:17 <startling> :t (>>=) . (return Prelude..)
23:43:19 <lambdabot> forall b b1 (m :: * -> *) a. (Monad m) => (a -> b1) -> (m b1 -> a -> b) -> a -> b
23:43:21 <mightybyte_> It's really helpful for these concepts.
23:43:58 <startling> yeah, Im getting all mixed up. disregard me and read the typeclassopedia
23:45:51 <DanC> this one? http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
23:46:34 <shachaf> You can find it on the wiki.
23:46:40 <shachaf> @where typeclassopedia
23:46:41 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
23:47:09 <ninegrid> tinkering with literate haskell.. normally i code in vim, but this literate stuff is cool and has me thinking i should be using emacs multimode
23:47:40 <pharaun> startling: fwiw i was able to just workaround it for now via "init" to drop the space :)
23:47:53 <pharaun> not as nice as resolving it in the parsing but it works for now
23:47:59 <shachaf> ninegrid: vim supports .lhs.
23:48:47 <ninegrid> shachaf: yes, i've got it working and making ctags and writing signatures etc...
23:48:51 <DanC> hmm... tasty... yes... this looks like the rosetta stone that fills many a gap in my education.
23:49:10 <DanC> for stuff like StateT, I keep running into research papers from 1995.
23:49:39 <ninegrid> shachaf: but I recall doing some LaTeX in emacs before, and it was pretty ... this is why I was considering the multimode for *.lhs buffers
23:49:46 <DanC> they were written to an audience familiar with this stuff.
23:50:08 <shachaf> ninegrid: You can probably make vim do Haskell + TeX in .lhs (like it does JavaScript inside HTML), but I don't know if anyone's done it.
23:50:59 <ninegrid> shachaf: perhaps, but it wouldn't render say.. different fonts, and elegant symbols
23:51:11 <shachaf> Oh. Sure.
23:55:45 <augur> preflex: seen: ski
23:55:52 <augur> preflex: seen ski
23:55:52 <preflex>  ski was last seen on #haskell 10 days, 8 hours, 58 minutes and 11 seconds ago, saying: * ski should look more at how packages the work, ty for the reminder
23:55:56 <augur> :|
23:56:03 <augur> man where the hell has ski gone
23:57:02 <startling> augur, have you ever looked at how packages work?
23:57:04 <startling> it's tough
23:57:09 <augur> :|
23:57:37 <ninegrid> ski is online
23:57:53 <augur> wat
23:58:14 <ninegrid> . , o (in ##VillageGreen)
23:58:26 <DanC> "a value of type IO a represents a computation producing a value of type a which may have I/O effects" <- oddly sloppy, given the precision of the rest of this typeclassopedia
23:58:44 <startling> DanC: no, that's very precise
23:59:03 <shachaf> DanC: Why is that sloppy?
23:59:10 <shachaf> Maybe because no one knows what IO is? :-)
23:59:12 <MostAwesomeDude> DanC: What part of that seems sloppy to you?
23:59:44 <DanC> the more precise explanation I've seen is that IO a is an IO action resulting in a value of type a
23:59:48 <ReinH> what is fmap . return ? I feel like I'm being an idiot
23:59:57 <shachaf> @ty fmap . return
23:59:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
