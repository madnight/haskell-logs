00:00:02 <tgeeky_> latro`a: yes, in ghci
00:00:07 <hpaste> tgeeky annotated “tabs and stuff” with “tabs and stuff (annotation)” at http://hpaste.org/72536#a72537
00:00:09 <latro`a> are you just typing in the value
00:00:10 <latro`a> or what
00:00:13 <tgeeky_> yep
00:00:18 <tgeeky_> latro`a: pasted the example output
00:00:41 <latro`a> if you just type in a string in ghci
00:00:46 <latro`a> it will call print
00:00:54 <latro`a> which would cause your problems
00:01:15 <latro`a> if I'm understanding you correctly, that *is* your problem
00:02:48 <tgeeky_> latro`a: I think I understand. I was wondering if the issue was that this is an optimization of some sort, and only really *huge* chunks of text will get shown with tabs and newlines
00:02:53 <tgeeky_> but I realize that sounds absurd now :o
00:02:59 <latro`a> nope
00:02:59 <latro`a> heh
00:03:06 <latro`a> so
00:03:16 <tgeeky_> it must be related to the fact that those other huge blocks of tet
00:03:21 <latro`a> you want putStrLn $ followingTerms foo baz bar
00:03:28 <latro`a> not just followingTerms foo baz bar
00:03:30 <tgeeky_> text are called through the custom Show instance for CycA
00:03:31 <latro`a> in your ghci
00:03:44 <latro`a> um
00:03:54 <tgeeky_> latro`a: usually I'm entering cyclotomic numbers, so things like:
00:03:58 <tgeeky_> (1 + i) * (1 + i)
00:03:58 <liyang> edwardk: when you put several simple lenses together, you get a compound lens.
00:03:58 <latro`a> are you actually showing any CycA's?
00:04:07 <edwardk> liyang: yep =)
00:04:07 <tgeeky_> not in the example text, no
00:04:11 <latro`a> ok
00:04:25 <tgeeky_> latro`a: I should have just pasted all of this stuff up front
00:04:26 <latro`a> well, anyway, if you have a string with special characters in it
00:04:26 <tgeeky_> :/
00:04:27 <tgeeky_> failure
00:04:30 <latro`a> show will escape them
00:04:45 <latro`a> which would cause you to see \t instead of tabs, \n instead of newlines, etc.
00:05:33 <nand`> Control.Lens makes an excellent addition to .ghci
00:06:10 <edwardk> ok, TH out of the way, starting back on indexed traversals
00:06:19 <edwardk> it still amazes me that these work
00:06:27 <nand`> TH? or indexed traversals?
00:06:37 <edwardk> the indexed traversals
00:06:42 <edwardk> the TH was just elbow grease
00:06:48 <nand`> in that case I agree, though I haven't seen much of their usage yet
00:07:06 <nand`> but the concept is frightening but astonishing at the same time
00:07:10 <edwardk> as soon as i get a version with consistent names i'll post it up
00:07:26 <edwardk> i'll do the first few traverseWithKey-like combinators too
00:07:46 <nand`> if you haven't made half of Data.Map redundant by the end of the day I'll be disappointed
00:08:13 <edwardk> well traverseMap -- will just be an indexed traversal with the key as the index
00:08:23 <edwardk> andthen indexed will let you swap out the key for the position in the traversal
00:08:29 <nand`> foldrWithKey etc
00:08:33 <edwardk> yep
00:18:21 <edwardk> traverseWithIndexOf :: Index i (c -> f d) (a -> f b) -> (i -> c -> f d) -> a -> f b; traverseWithIndexOf = withIndex
00:18:39 <edwardk> withIndex is just the field access for a constructor
00:18:58 <edwardk> traverseOf = id, so it fits
00:24:35 <latro`a> so much of your stuff is id
00:24:39 <latro`a> it's kinda terrifying
00:24:57 <shachaf> Perfection has been achieved when everything is id.
00:25:01 <Nereid> ^
00:25:12 <shachaf> Or const. const is good too.
00:25:19 <edwardk> =)
00:28:59 <Ralith> that way lies complete programs written in the type system
00:29:50 <edwardk> thats oleg trick
00:29:56 <edwardk> i just write complete programs with id
00:30:24 <edwardk> when i need to read the output i measure the temperature of my cpu
00:30:32 <XexonixXexillion> edwardk: "main = unsafeCoerce id"? :p
00:30:49 <edwardk> (unsafeCoerce <*> unsafeCoerce) (unsafeCoerce <*> unsafeCoerce) =)
00:31:10 <shachaf> edwardk: Is that like callcc callcc (callcc callcc)?
00:31:11 <edwardk> alas <*> isn't id
00:31:17 <edwardk> shachaf: its SII (SII)
00:31:56 <shachaf> Oh, in a way that typechecks.
00:32:10 <edwardk> yeah
00:33:17 <XexonixXexillion> I was so happy when I realised <*> and return were S and K for ((->) r). Then I realised it had to actually type check
00:33:25 <edwardk> =)
00:33:42 <Yuu-chan> Scary people.
00:45:04 <Maiz_en_Heces> listen to this song and review please
00:45:04 <Maiz_en_Heces> http://www.youtube.com/watch?v=5cqy4-vCo0M
00:48:07 <latro`a> ..
00:48:13 <latro`a> what does main = unsafeCoerce id actually do
00:48:15 <latro`a> I may have to try this
00:48:30 <latro`a> various main = unsafeCoerce baz might be amusing
00:48:50 <latro`a> would be hilarious to do some weird low level bit twiddling and write a horrifyingly obfuscated program this way
00:48:59 <latro`a> that actually did something
00:49:03 <latro`a> maybe a quine
00:49:26 <amatsu> :t unsafeCoerce
00:49:27 <lambdabot> Not in scope: `unsafeCoerce'
00:49:40 <Yuu-chan> @source unsafeCoerce
00:49:41 <lambdabot> unsafeCoerce not available
00:49:45 <latro`a> :t Unsafe.Coerce.unsafeCoerce
00:49:46 <lambdabot> forall a b. a -> b
00:50:07 <Yuu-chan> Er. Cast (a -> a) to IO ()?..
00:50:19 <latro`a> yup, unsafeCoerce can do that
00:50:27 <latro`a> albeit not necessarily in a way that avoids crashes
00:50:29 <Yuu-chan> wat
00:50:42 <latro`a> it says unsafe in the name
00:50:52 <Yuu-chan> Sort of reinterpret_cast?
00:51:26 <latro`a> aw it doesn't do anything
00:51:26 <shachaf> That's the only kind of cast there is.
00:51:32 <latro`a> unsafeCoerce id :: IO ()
00:51:33 <latro`a> doesn't run
00:51:34 <latro`a> :(
00:51:43 <latro`a> well
00:51:44 <latro`a> "runs"
00:51:49 <latro`a> it doesn't break, it just apparently does nothing
00:52:07 <XexonixXexillion> latro`a: does it return a proper exit code?
00:52:42 <latro`a> I was doing it in ghci
00:53:03 <Yuu-chan> I tried and it siply does nothing
00:53:11 <Yuu-chan> > putStrLn "aaa"
00:53:12 <lambdabot>   <IO ()>
00:53:46 <Yuu-chan>  unsafeCoerce . unsafePerformIO $ putStrLn "WAT" :: IO () actually prints the string
00:54:07 <liyang> maybe unsafeCoerce id simply takes the RealWorld and returns it exactly as it is.
00:54:11 <latro`a> ...lol
00:54:13 <latro`a> no
00:54:56 <latro`a> that would be hilarious, though
00:55:03 <danr> > let k = unsafeCoerce :: Maybe a -> Bool in map k [Just (),Nothing]
00:55:05 <lambdabot>   Not in scope: `unsafeCoerce'
00:55:09 <danr> baaaap
00:55:16 <Nereid> break your own ghci ;)
00:55:37 <XexonixXexillion> liyang: so "main = unsafeCoerce . (const IdealWorld)" should fix all the problems in the RealWorld, right? :p
00:55:38 <latro`a> > let k = Unsafe.Coerce.unsafeCoerce :: Maybe a -> Bool in map k [Just (),Nothing]
00:55:40 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
00:55:41 <latro`a> aw
00:55:46 <danr> Prelude Unsafe.Coerce> let k = unsafeCoerce :: Maybe a -> Bool in map k [Just (),Nothing]
00:55:49 <danr> [True,False]
00:55:52 <danr> (on my machine, then)
00:56:08 <latro`a> same
00:56:17 <shachaf> @quote unsafeCoerce
00:56:17 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
00:56:19 <shachaf> @quote unsafeCoerce
00:56:19 <lambdabot> elliott says: <elliott> I like how edwardk's answer to every question always goes "most abstract solution to the problem possible --> microoptimisation details". <elliott> I swear I've seen him go
00:56:19 <lambdabot> from category theory to unboxed types and unsafeCoerce in a single line of IRC.
00:56:20 <shachaf> @quote unsafeCoerce
00:56:20 <lambdabot> shachaf says: isTrue :: Bool -> Bool; isTrue = unsafeCoerce
00:56:22 <shachaf> @quote unsafeCoerce
00:56:22 <lambdabot> elliott says: <elliott> I like how edwardk's answer to every question always goes "most abstract solution to the problem possible --> microoptimisation details". <elliott> I swear I've seen him go
00:56:22 <lambdabot> from category theory to unboxed types and unsafeCoerce in a single line of IRC.
00:56:24 <shachaf> @quote unsafeCoerce
00:56:24 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
00:56:26 <shachaf> @quote unsafeCoerce
00:56:26 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
00:56:50 <latro`a> lol
00:56:55 <latro`a> apparently that last one actually does work
00:56:59 <latro`a> which is kinda terrifying
00:57:01 <danr> ah so it's quite well-known
00:57:04 <Yuu-chan> I don't understand this street magic :(
00:57:24 <edwardk> Yuu-chan: look up 'dynamic pointer tagging'
00:57:28 <liyang> XexonixXexillion, latro`a: I actually meant that in a more literal sense. ghc-prim defines newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
00:57:33 <latro`a> I know
00:57:44 <latro`a> but unsafeCoerce id doesn't know what id actually is
00:57:54 <latro`a> it just sees a block of binary (more or less)
00:58:24 <edwardk> Yuu-chan: constructors are tagged with a few bits after being evaluated that describes their position in the ordering out of the constructors for their type
00:58:26 <XexonixXexillion> liyang: I know, but I'd like to be able to replace RealWorld with something better, like someone else's computer :p
00:58:34 <edwardk> this relies on that magic
00:58:42 <Yuu-chan> Oh. Thanks.
00:58:52 <Yuu-chan> edwardk++
00:59:25 <edwardk> i have a tag-bits package that lets you sneak in and inspect them to do nasty things
01:00:31 <Yuu-chan> XexonixXexillion: IdealWorld is undefined unfortunately :)
01:03:44 <edwardk> hah
01:14:06 <Yuu-chan> Which advantages has ByteString of ByteString.Char8?
01:14:35 <shachaf> ByteString.Char8 is a lie.
01:14:42 <mauke> it doesn't pretend to be made of Chars
01:14:59 <shachaf> (It's also the same type as ByteString. It's just the functions that are different.)
01:16:25 <Yuu-chan> So how to use functions such as unlines and unwords , which are only in the Char8 module?
01:16:35 <Nereid> import that module
01:16:37 <mauke> you don't
01:16:40 <Nereid> or don't
01:16:43 <mauke> they don't make sense on bytes
01:16:54 <mauke> words/lines are text properties
01:16:54 <Nereid> true, you probably want Text instead
01:18:24 <Yuu-chan> Well... I'm experimenting with the Cassy package and it uses lazy bytestrings internally.
01:18:55 <shachaf> Why do you care what a package uses internally?
01:21:01 <Yuu-chan> But I need to give ByteStrings to the functions.
01:21:12 <shachaf> Oh, so it uses them externally too?
01:21:26 <absence> mm_freak: yes, the code expands to this, so i guess that's sort of a custom switcher unless i misunderstand what a switcher is :) (w1 . while' (< d1) <|> w2 . while' (< d2) <|> ... <|> wn . while' (< dn)) . countFrom 0
01:21:37 <shachaf> Turning characters into bytes is called "encoding", and turning bytes into characters is called "decoding".
01:21:48 <edwardk> clearly you should use lens ;)
01:22:08 <edwardk> import Data.ByteString.Lazy.Lens; import Control.Lens
01:22:18 <edwardk> "hello"^.packedChars -- gives you a bytestring
01:22:29 <edwardk> foo^.from packedChars gives it back as a string
01:22:32 <Yuu-chan>     Couldn't match expected type `BS.ByteString'
01:22:32 <Yuu-chan>                 with actual type `Data.ByteString.Lazy.Internal.ByteString'
01:22:41 <shachaf> edwardk: Using lens is good, but understanding the distinction between bytes and cahracters is more important. :-)
01:22:46 <edwardk> heh
01:22:55 <shachaf> And between lazy and strict ByteStrings, it seems.
01:22:55 <edwardk> there is packedBytes as well ;)
01:23:09 <edwardk> Yuu-chan: import Data.ByteString.Lazy not Data.ByteString
01:23:40 <shachaf> We need a bot that looks at the last thing edwardk uploaded to Hackage and says <edwardkbot> clearly you should use X ;)
01:23:49 <edwardk> shachaf: =P
01:23:55 <davean> shachaf: I thought we had that
01:24:01 <Yuu-chan> shachaf: I wrote a Japanese linguistic parser for my diploma, so I should know the difference ;)
01:24:16 <edwardk> now if i wrote it, it would just say <edwardkbot> clearly you should use <edwardkbot> ;)
01:24:25 <shachaf> Yuu-chan: Ah, great. :-) In that case, ByteString is a sequence of bytes; String and Text are sequences of characters.
01:24:36 <shachaf> If Cassy stores bytes, you'll need to convert back and forth to use it.
01:25:00 <shachaf> edwardkbot: You would never write such a concrete bot.
01:25:20 <shachaf> You'd write a generic cofree bot or something.
01:25:35 <edwardkbot> nah, i'mnot a huge fan of building dsls on free/cofree directly
01:25:43 <Yuu-chan> I only wanted to learn how the types of the same name in different modules correlate with each other.
01:26:31 <edwardkbot> Yuu-chan: the two bytestrings are unfortunately named, they don't have much to do with one another
01:26:43 <edwardkbot> the Data.ByteString and Data.ByteString.Char8 versions are the same underlying type
01:26:50 <Yuu-chan> edwardk: Thanks, importing Lazy.Char8 has helped.
01:27:05 <edwardkbot> Data.ByteString.Lazy and Data.ByteString.Lazy.Char8 use the same rep
01:27:07 <Yuu-chan> So why are they "different"?
01:27:21 <davean> Char8 of course unsafely converts from chars to word8s
01:27:24 <edwardkbot> Data.ByteString is basically a pointer to memory and two offsets for where to start and end
01:27:42 <edwardkbot> Data.ByteString.Lazy makes a linked list of strict bytestrings to address some asymptotic concerns
01:27:58 <edwardkbot> Data.ByteString's API is correctly based on working with Word8s, because it holds bytes not chars
01:28:06 <edwardkbot> but thats really inconvenient at times
01:28:06 <Yuu-chan> Guess I should make a look inside
01:28:15 <edwardkbot> you have to convert all over the place back to char, etc.
01:28:17 <edwardkbot> to think about them
01:28:26 <edwardkbot> so Data.ByteString.Char8 is a compatibiity wrapper
01:28:42 <edwardkbot> that takes the combinators from Data.ByteString and does c2w and w2c everywhere
01:28:51 <davean> but it doesn't handle proper encoding and decoding
01:28:53 <younder> edwardkbot, inconvinient but nessecary
01:29:03 <edwardkbot> correct
01:29:04 <younder> lol
01:29:17 <edwardkbot> if you cant better encoding you can use Data.ByteString.UTF8 from utf8-string
01:29:37 <edwardkbot> younder: of course
01:29:45 <edwardkbot> er s/cant/want
01:29:51 <davean> Text also has encoding and decoding functions that work here
01:30:05 <edwardkbot> that too
01:30:07 <davean> Of course, then the question is "Why aren't you using Text?"
01:30:39 <younder> Can't type conversion be automated for this case?
01:30:49 <edwardkbot> ok, getting a couple hours of sleep before hopping a plane to hac phi
01:30:52 * davean looks at younder 
01:30:55 * hackagebot lens 1.4 - Lenses, Folds and Traversals (EdwardKmett)
01:31:16 <edwardkbot> that has the preliminaries for indexed traversals and folds and it has the new template haskell generator
01:31:21 <Yuu-chan> I heard something about overloaded string literals
01:31:37 <younder> If you have unicode wich nativly hs the double width, then no
01:31:37 <edwardkbot> i'll keep expanding the indexed foo support
01:32:08 <younder> This is what I expect you are doing
01:32:34 <Yuu-chan> Me?
01:32:52 <younder> Yuu-chan, no edwardkbot
01:36:57 <Yuu-chan> Meh. ByteString version of my script proved not to be faster than the simple String one :(
01:38:41 <younder> Yuu-chan, it is if you have massive volumes of text
01:42:14 <younder> haddoc is coughing again
01:42:44 <younder> I hate when it spits out worms
02:35:34 <Taneb> With the lens package, I can do a lot more with family-tree
02:35:57 * hackagebot IntervalMap 0.3.0.0 - Maps from Intervals to values, with efficient search. (ChristophBreitkopf)
02:51:49 <sopvop> So, I was thinking, how would gui toolkit look like if it was entirely done in haskell. Not wrapper to c or c++ library, or wrapper of wrapper to c library.
02:53:25 <sopvop> Was there any experiments with this?
02:53:50 <Taneb> I wouldn't know where to start
02:55:03 <sopvop> widget tree datatype? :)
03:05:47 <hpaste> sopvop pasted “This gonna eat memory and be slow” at http://hpaste.org/72541
03:06:33 <sopvop> Now what I've finished my coffee, I won't be bothering the good people of #haskell with random talk :)
03:07:35 <Taneb> sopvop, there isn't much other talk going on at the moment
03:24:57 <merijn> sopvop: Peaker is working on a structural editor in Haskell and I think he's using his own GUI toolkit implemented on OpenGL
03:26:19 <sopvop> Is it open source? Can I have a look? :)
03:26:35 <merijn> sopvop: He has a github repo: https://github.com/Peaker/bottle
03:26:57 <sopvop> Thanks
03:27:18 <merijn> sopvop: Also, since anything haskell is on-topic here I think that includes library design for things like GUI toolkits
03:28:45 <merijn> Also, maybe look at FRP bindings for existing toolkits and check what sorta combinators/data structures they use/implement?
03:29:18 <amliby> .window 9
03:31:48 <sopvop> AFAIK none of them do any drawing or event dispatching. FRP is like cool way to do callbacks, so it solves a different scope of problems.
03:32:50 <merijn> sopvop: True, I didn't mean that they solve the problem, but they have functionality that is sufficiently similar to your example that they might inspire cleaner/more efficient designs for that sorta thing
03:34:12 <merijn> FRP does filtering/triggering for events, so that is at least related to event dispatching (and the way they do it allows for IO behaviour inside callbacks too)
03:37:34 <sopvop> The Idea for filtering is this - it's a low level event, like key press or mouse. And it goes from top widget to one of it's children which have focus or are under cursor. So filter should filter this event going down. If event was not accepted by bottom widget, it goes back up the stack until someone accepts it
03:37:41 <sopvop> and maybe triggers FRP event
03:39:09 <sopvop> Otherwise the top widget would have to route all the events, and I don't think it's a good idea to put the dispatch burden on widget implementer. filter and handler would be enough. or maybe I'm wrong :)
03:39:21 <merijn> Don't you instead want widgets to tell their parent which events they except and then accumulate that going up the tree, meaning you don't have to backtrack?
03:39:21 <sopvop> Anythay, Parkers Bottle look interesting
03:40:23 <sopvop> With Qt I found it useful to be able to filter events going down.
03:41:27 <sopvop> Filter is just filter, it just yes or no. No state changes.
03:41:50 <merijn> sopvop: Of course, but I was talking implementation, not design. If a widget tells you which events it accepts then the events a widget accepts are the events it handles plus the aggregate of the events its children handle
03:42:27 <amatsu> Does anyone know of a tutorial or a quickstart for using QuickCheck?
03:42:29 <sopvop> Oh, yeah
03:42:47 <merijn> sopvop: That way you can avoid needing to deal with backtracking
03:43:29 <merijn> amatsu: RWH has a chapter on QuickCheck, might be a good start?
03:43:33 <merijn> @where rwh
03:43:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:43:39 <merijn> Chapter 11, I believe
03:44:03 <amatsu> merijn: OK, sounds good. Thanks!
04:16:56 <covi> I want to retrive a list of names of all files inside a dir (including its sub dirs). Should I implement it myself, or should I just call 'find dir -type f' in Haskell?
04:18:01 <Botje> it's not hard to implement yourself
04:18:05 <Botje> and good practice :)
04:19:17 <luite> there are also some packages for this kind of programming, like shelly
04:22:29 <covi> Botje:
04:22:34 <covi> I see
04:26:12 <covi> luite: this Shelly? https://github.com/yesodweb/Shelly.hs
04:30:58 <Taneb> Okay, family-tree is nigh unusable
04:31:22 <Taneb> I'm gonna try to rewrite it, basing it GRAMPS probably
04:36:54 <luite> covi: yeah it's still in development so the api might change a little, but it's useful for quick and dirty scripting (assuming that's what you're doing since you were considering calling 'find -type f' :) )
04:37:11 <luite> and it has this recursive find built in
04:43:07 <covi> luite: why not just call the command using System.Subprocess?
04:43:40 <covi> Sorry I meant System.Process
04:45:33 <luite> covi: uh that's possible but relies on external programs (the find you find in windows is different for example), and you have to deal with path encoding issues yourself
04:45:57 <luite> it's probably faster than shelly though
04:46:11 <covi> path encoding issues, such as?
04:46:42 <covi> And, is Shelly the only option for scripting nowadays?
04:49:23 <luite> covi: i think path handling is system dependent, the usual type FilePath = String you find in Prelude is actually wrong, since at least some operating systems treat them as sequences of bytes, not of unicode characters
04:49:36 <luite> shelly uses system-filepath instead that's supposed to be better for this
04:51:00 <covi> luite: I see, I will give shelly a try
04:51:12 <luite> shelly is a fork of shellish or something
04:51:35 <luite> and i think there might be more
05:00:03 <merijn> luite: "some" you mean "almost all unix systems"
05:01:27 <luite> merijn: i guess :)
05:01:34 <merijn> I think in SUS it is sequence of bytes with the ascii values for / and \NUL disallowed
05:01:44 <luite> merijn: unfortunately a lot of software does it wrong :(
05:02:27 <luite> at least if i mount a volume with fuse4x i don't see files with special chars in os x finder... dunno if it's apples or fuse4x's fault
05:05:26 <LambdaDusk> what would be an easy, re-producable way to compile a haskell program for, say, an ARM linux?
05:09:21 <merijn> LambdaDusk: I think ARM support is in progress? i.e. I believe it is fully supported in snapshots of GHC but not yet any release?
05:09:27 <merijn> I might be completely wrong, though
05:10:16 <LambdaDusk> what I found is some list that there is some support, but no information on how to use it at all
05:11:31 <merijn> LambdaDusk: Maybe some people in #ghc will know? It's a bit quiet in here right now and unfortunately I don't know
05:12:00 <m3ga> LambdaDusk: i believe ghc on debian arm systems is just an apt-get away
05:13:54 <luite> yeah it's quiet..... too quiet
05:14:21 <hpc> LambdaDusk: there's a bootstrap process, and you miiiiiiiiiiight be able to cross-compile by making GHC dump LLVM code
05:14:42 <hpc> but you will generally want to bootstrap
05:14:59 <hpc> the process is documented if you download the GHC source
05:15:10 <m3ga> LambdaDusk: what OS are you running on that arm?
05:15:44 <LambdaDusk> m3ga: None yet, but I am thinking about getting some open handheld console I'd like to program myself
05:16:03 <LambdaDusk> hpc: How would I dump LLVM code?
05:16:53 <hpc> -ddump-llvm
05:17:03 <LambdaDusk> hmm thanks
05:18:46 <m3ga> LambdaDusk: for powerpc64, i was able to grab the Fedora rpms, convert them the debs and install them on a debian powerpc64 system. from there i build ghc from git.
05:18:46 <luite> LambdaDusk: you won't have ghci unless you have at least version 7.4.2
05:19:48 <LambdaDusk> I don't really will be able to compile the code on the system, I have to cross compile from my pc
05:20:13 <luite> hmm, ghc isn't really a cross compiler, it's easier to run an emulator with the target architecture
05:20:32 <LambdaDusk> hpc: Also possible to dump llvm into a file?
05:20:46 <luite> some people are using it on raspberry pi with the available linux distros for that
05:20:48 <LambdaDusk> luite: Well that's a shame, potential use kind of wasted
05:21:13 <luite> you might want to grap a raspberri pi emulator and debian wheezy or something :)
05:21:23 <luite> grab
05:21:54 <LambdaDusk> luite or grab and raspberry pi entirely, is it's hardware strong enough for haskell compilation?
05:22:25 <luite> not really, not enough ram, 256MB
05:23:19 <LambdaDusk> shame
05:40:32 <LambdaDusk> whereas I wonder if Haskell is a good choice for a system with very limited RAM
05:46:20 * hackagebot conduit 0.5.2.3 - Streaming data processing library. (MichaelSnoyman)
05:48:05 <LambdaDusk> hpc Wouldn't I be able to just let the Haskell compiler output C code which I then cross compile for ARM?
05:52:27 <nand`> @ask edwardk Can we have something like utf8 = iso encodeUtf8 decodeUtf8; eg. “anyOf (from utf8.text) (=='c')”
05:52:45 <nand`> lambdabot?
05:52:54 <Botje> I think it's @tell
05:53:23 <nand`> Botje: ask works too, and if it didnt I'd get an unknown command message
05:53:26 <nand`> lambdabot is not in the channel
05:53:29 <Botje> oh :)
05:59:24 <Palmik> Hi guys, I'm working with attoparsec and would like to write a parser that consumes until it reaches a certain string in the stream without consuming the string (if I did not mind consuming it, the naive version would be quite trivial to write). It would be convenient to have something like "lookAhead" (or just be able to peek at next n bytes). But maybe there is another way to implement it that I did not think of. Does anyone have any ideas?
06:11:02 <Taneb> Is it bad that my mind wants classes to be as lightweight as possible, but there should be a lot of them
06:11:22 * hackagebot shelly 0.13.5 - shell-like (systems) programming in Haskell (GregWeber)
06:11:36 <mroman> Maybe.
06:11:49 <mroman> Sometimes I want that too.
06:15:36 <LambdaDusk> mroman, Taneb: I thought that was the point of classes?
06:16:12 <Taneb> As in, each class should only add one thing, or a couple of equivalent things
06:16:22 * hackagebot buildwrapper 0.6.1 - A library and an executable that provide an easy API for a Haskell IDE (JeanPhilippeMoresmau)
06:16:24 * hackagebot scion-browser 0.2.10 - Command-line interface for browsing and searching packages documentation (JeanPhilippeMoresmau)
06:16:34 <Taneb> type Applicative f = (Apply f, Pointed f)
06:16:43 <mroman> LambdaDusk: You could go to the extreme
06:16:45 <merijn> Taneb: Each class should add an orthogonal set of functionality
06:16:51 <mroman> like defining classes for reverse
06:16:52 <mroman> and such.
06:17:14 <Taneb> class Pointed p where pure :: a -> p a; class Functor f => Apply f where (<*>) :: f (a -> b) -> f a -> f b
06:17:38 <LambdaDusk> I think that standard haskell lacks type classes like "Iterable" and "Convertible"
06:17:44 <merijn> Taneb: Well, one question to ask will this functionality ever be used separately
06:17:59 <merijn> LambdaDusk: There's a Foldable and Traversable typeclass in a library
06:18:11 <merijn> LambdaDusk: Not realy any reason to need to have it built in
06:18:24 <Taneb> class Semigroupoid (~>); class Semigroupoid (~>) => Category (~>); class Category (~>) => Tensor (~>); class Tensor (~>) => Arrow (~>)
06:18:36 <LambdaDusk> merijn: But not in standard Haskell... I think there is, so you can use the same "map" on Strings as well as on Text or ByteString
06:18:45 <Taneb> They add id, (.), (***), and arr respectively
06:19:00 <Taneb> Except with id and (.) the other way round
06:19:14 <MHD> Can haskell have operator type names?
06:19:22 <MHD> that doesn't begin with ':'
06:19:29 <merijn> MHD: No
06:19:31 <LambdaDusk> not to mention that a "Convertible a b" class could make code a lot more readable and more concise
06:19:53 <merijn> MHD: Types start with capitals and since there's no capital operator the decision was made to use colon for that
06:20:01 <Taneb> LambdaDusk, Convertible a b where cast :: a -> b ?
06:20:02 <nand`> Iterable? Convertible?
06:20:04 <nand`> what would those do
06:20:20 <merijn> LambdaDusk: Many Prelude functions are restricted on purpose (e.g. map)
06:20:31 <LambdaDusk> merijn: And why...?
06:20:36 <merijn> LambdaDusk: The more generic functions result in unparseable errors
06:20:43 <merijn> It scares away newcomers
06:21:19 <merijn> Compare Prelude.. and Prelude.map with lambdabot's, which uses fmap for both
06:21:19 <LambdaDusk> nand`: Iterable would merely give you an "uncons" and "null :: a -> Bool" which can be used to implement almost all list functions
06:21:50 <merijn> Or the Control.Category functions (.) and id with those in prelude
06:22:02 <merijn> LambdaDusk: You can still import more generic ones if you want them instead
06:22:35 <nand`> LambdaDusk: pretty much all list functions can be obtained via traversals and folds
06:23:04 <nand`> so instead of a class I would just rely on polymorphic traversals/folds
06:23:05 <merijn> nand`: His idea for Iterable is essentially Traversable and/or Foldable
06:23:58 <LambdaDusk> the name is irrelevant, I just don't see why many standard Haskell function have to be more strict than they could be
06:27:30 <merijn> LambdaDusk: My point was that those functions/typeclasses exist (in libraries)
06:33:47 * nand` waits for the inevitable merger of ‘lens’ with ‘ImperativeHaskell’ rebranded as ‘H++’
06:36:27 <nand`> ugh, can GHCi commands be made case insensitive?
06:36:42 <nand`> I keep typing ‘:T’ instead of ‘:t’ since I'm already holding down shift for the :
06:36:49 <nand`> it happens a few times per day
06:38:51 <goemon> hi
06:40:08 <goemon> I'm trying to run a haskell program written with GHC 7.0 on GHC 7.4. Any ideas what needs to be imported to use isNothing, fromJust (from Maybe) ?
06:40:41 <mux> @index isNothing
06:40:56 <mux> well, lambdabot isn't here; it's in Data.Maybe
06:40:58 <mauke> nand`: echo ':def T \x -> return (":t " ++ x)' >> ~/.ghci
06:41:34 <mauke> preflex: seen Cale
06:41:35 <preflex>  Cale was last seen on #haskell 6 hours, 47 minutes and 25 seconds ago, saying: curious :)
06:41:40 <nand`> mauke: fair enough
06:42:42 <mauke> I have similar commands for :Q and :W in my vimrc
06:42:45 <goemon> thanks mux
06:43:18 <merijn> goemon: You can also try searching Hoogle: http://www.haskell.org/hoogle/
06:43:22 <fmap> mauke: what :W does?
06:43:40 <fmap> ah
06:43:42 <fmap> vimrc
06:43:46 <fmap> okay, nvm
06:43:56 <nand`> mauke: I believe you gave me those a while ago, since I do too
06:52:23 <toshublue> hello - I'm new to haskell, but known of it for a long time....are there any projects related to astronomy or cosmology?
06:52:43 <ciaranm> toshublue: i think there's a horoscopes package
06:52:44 * ciaranm runs
06:52:54 <toshublue> specifically, data management, processing data?
06:54:53 <timthelion> ciaranm: if there is, it's not in hackage
06:55:43 <LucasCampos> Is Real World Haskell  a good book?
06:55:55 <opqdonut> yes
06:55:57 <Jeanne-Kamikaze> LYAH is a better first book imo
06:55:58 <srhb> LucasCampos: I think so, especially for the practical examples.
06:56:12 <srhb> LucasCampos: But LYAH is the better book at getting the basics down.
06:56:26 <timthelion> LucasCampos: you really should just read GHC's source code though...
06:56:49 <sclv> haha
06:56:53 <nand`> but to understand GHC's source code, you must first learn Haskell
06:56:55 <ciaranm> LYAH and RWH in parallel!
06:56:59 <srhb> toshublue: Can you narrow down what you mean?
06:57:05 <LucasCampos> sthb: Thanks. I have that one already and am looking for something more applied
06:57:08 <Skola> is there a Haskell function that works like python's foo[3:12] without dropping and taking my way beyond the fold?
06:57:12 <srhb> toshublue: Data management and processing is a pretty wide spectrum
06:57:28 <toshublue> for instance, data from large telescopes or  observatories?
06:57:34 <srhb> Skola: No, lists are single linked, you'd need to use drop and take or analogues
06:57:38 <sclv> just use take and drop.
06:57:46 <sclv> they'll fuse neatly
06:57:50 <aristid> > take 9 . drop 3 $ [1..20]
06:57:56 <sclv> (so the generated code will be efficient)
06:58:06 <aristid> lambdabot?! y u no here
06:58:10 <srhb> :(
06:58:11 <sclv> @bot
06:58:12 <Skola> hm okay
06:58:12 <mauke> well, drop will be efficient
06:58:21 <mauke> take is necessarily "inefficient"
06:58:33 <sclv> mauke: how so?
06:58:38 <srhb> mauke: How on earth can take be inefficient?
06:58:44 <aristid> mauke: if the indexes are really just 3:12 i don't think it'll matter much
06:58:48 <sclv> by efficient btw i just meant single traversal
06:58:49 <mauke> aristid: right
06:59:13 <mauke> sclv, srhb: I meant that take constructs a new list
06:59:15 <dgpratt> I wonder what is the general sentiment towards F# among this group; would anyone care to share an opinion?
06:59:26 <timthelion> nand`: if there is some bit of GHC that you cannot understand, then you can always compile it to x86 code, to see what it does.  x86 code is very simple, even a computer can understand it.
06:59:26 <sclv> mauke: ok, sure :-)
06:59:46 <sclv> except again if you use its product with some other foldy thing, then that will get fused away too
06:59:48 <timthelion> nand`: but mostly haskell is self explanitory :D
06:59:52 <srhb> I think calling take inefficient in any manner is fairly misleading. I think it is _the_ most efficient version of taking n from a singly linked list. :P
07:00:08 <mauke> srhb: hence the quotes
07:00:11 <srhb> Right.
07:00:22 <aristid> srhb: not like there are really a lot of different ways of doing that
07:00:25 <srhb> drop is cheating and take is as efficient as it gets. :P
07:00:36 <aristid> drop is not cheating
07:00:52 <timthelion> dgpratt: well since many of us use linux, where the only .net crap is through mono, the vast majority of us have not tried f#
07:01:05 <srhb> it has to walk, but the computation you do on the rest of the element won't ever look inside the data constructors, would it
07:01:29 <nand`> my opinion on F# is ‘why use F# if you can just use Haskell instead?’
07:01:42 <srhb> That sums it up :P
07:01:46 <EvanR> f# is strict and impure
07:01:52 <aristid> nand`: isn't that your opinion on most programming languages? ;)
07:02:10 <sclv> f# has .net integration
07:02:19 <nand`> aristid: very many, yes. I do have a sweet spot for cute esoteric languages
07:02:26 <srhb> Wouldn't Haskell still be quite awesome without the laziness?
07:02:26 <EvanR> thats the same sort of argument for java, it has java integration
07:02:31 <srhb> I mean, not quite as much, but still.
07:02:36 <nand`> Haskell has Haskell integration
07:02:37 <EvanR> haskell without lazy wouldnt make much sense
07:02:39 <nand`> I think that about trumps the other two
07:02:39 <timthelion> srhb: NO, haskell is nothing without lazyness.
07:02:41 <sclv> + awesome database features + type providers + a system of units of measure
07:02:42 <srhb> Really?
07:02:54 <aristid> srhb: maybe take a look at disciple?
07:02:57 <srhb> I always saw it as a nice feature that I could probably live without :P
07:03:16 <sclv> I'm not a huge fan of F#, but there are certainly features I envy
07:03:17 <srhb> But I probably don't grasp the implications.
07:03:30 <sclv> it depends on your style of coding
07:03:45 <sclv> lots of my favorite tricks are terribly painful with only explicit laziness
07:03:49 <timthelion> srhb: all those "pipe stream modifications" we do using lazy lists, take only as much memory as it takes to process one element.  The memory requirements of haskell programs, even ones operating on finite data spaces, would become unmanagable very quickly without lazyness.
07:04:00 <merijn> srhb: Check out Habit
07:04:01 <srhb> timthelion: Ah yes.
07:04:17 <sclv> a classic example is that in a lazy language, you can write && as just any function
07:04:24 <merijn> srhb: Strict haskell for systems programming (also, type checked memory safety by using special kinds for pointers)
07:04:24 <sclv> and any other control operator as well
07:04:31 <srhb> merijn: Ok:)
07:04:42 <merijn> srhb: I'm not sure whether it is/will be open source, though
07:05:00 <nand`> without laziness you lose: 1. the ability to define your own programming constructs, pretty much; 2. the ability to work with infinitely recursive values (very common in Haskell); 3. the ability to write, well, lazy code
07:05:02 <sclv> in a runtime not built for laziness from the ground up you pay a much greater cost for simulating it too, efficiencywise. so lazy languages running on .NET or JVM, etc. pay a significant cost
07:05:03 <srhb> Well, I'm not specifically looking for a strict Haskell, I was just wondering: What would suck if Haskell were strict
07:05:05 <merijn> srhb: Also, instance chains are pretty cool. I can't wait for someone to implement them in Haskell
07:05:14 <merijn> srhb: Code readability
07:05:18 <sclv> instance chains are unsound :-)
07:05:24 <srhb> merijn: Why readability?
07:05:25 <timthelion> nand`: but as I pointed out, even finite lists benefite from lazyness.
07:05:45 <srhb> nand`: What do you mean your own programming constructs?
07:05:46 <merijn> srhb: I've had this discussion before, the big problem is that the naive definition of for example map is terrible in strict languages, but optimal in lazy languages
07:05:54 <nand`> timthelion: sort of what I meant with point 3
07:05:57 <sclv> closed instance chains are ok, but i think we'll get there in haskell, in essence if not syntax
07:05:59 <srhb> merijn: Right.
07:06:08 <merijn> sclv: How are they unsound?
07:06:37 <sclv> i don't remember all the details. basically if you give them the typical treatment as an logic, you can prove false
07:06:48 <sclv> + you can create loops and the usual junk
07:06:55 <sclv> erm, a logic, not an logic
07:07:23 <merijn> Treat instance chains as instances (i.e. unordered, non-overlapping), multiple chains for one class is an error if one or more are closed
07:07:36 <sclv> nobody i know of has really used them in anger yet, but i imagine they'd hurt local reasoning too
07:07:54 <mgsloan>  instance chains?
07:08:28 <sclv> http://web.cecs.pdx.edu/~jgmorris/pubs/morris-icfp2010-instances.pdf
07:08:30 <merijn> mgsloan: See J. Garret Morris & M.P. Jones - Instance Chains: Type Class Programming Without Overlapping Instances
07:08:37 <mgsloan> gotcha
07:08:49 <nand`> srhb: language doesn't have a built in if/then/else? No problem, make your own -> with laziness you can have expressions that just get thrown away
07:08:50 <merijn> They're a pretty neat idea
07:09:08 <nand`> want (&&) as a short-circuit operator? no problem, define your own
07:09:09 <nand`> etc.
07:10:44 <sclv> oh, right, and "fail" basically gives you all the problems with prolog's "cut"
07:11:44 <mgsloan> they are pretty neat.  Unfortunately I think that the problems and complexity of the solution quite outweigh the benefits
07:13:54 <Saizan> sclv: depends how fine you mean "local" to be, you can consider each chain in isolation as much as you can with each instance now
07:13:56 <mgsloan> (but I haven't really looked at them a long time, just these last 3 minutes ;)
07:15:51 <merijn> mgsloan: What complexity? Implementation or use, you mean?
07:16:03 <EvanR> i was reading some haskell vs scala thing and the dude said 'wtf, one single global instance of a class for each type?'
07:16:07 <EvanR> and i thought wait
07:16:11 <EvanR> how does that even work?
07:16:24 * hackagebot shelly 0.13.5.1 - shell-like (systems) programming in Haskell (GregWeber)
07:16:26 <merijn> I don't see why an implementation would have to complicated with the suggestion I offered? And with those limitations they'd still be useful
07:16:27 <Cale> huh?
07:16:30 <EvanR> if you have an alternative Ord instance in your module for like Maybe,
07:16:38 <EvanR> it cant link with other modules?
07:16:49 <luite> there can be only one instance in a program
07:17:03 <mgsloan> merijn: Both - more importantly complexity of use.  The issue with usage complexity is that you need to know the details of the chain of instances, and if that changes, clients might break in unforseen ways
07:17:14 <mgsloan> (I think the paper mentioned issues of modularity?)
07:17:23 <merijn> i.e. all chains disjoined and type error when there is more than one chain and one or more chains are closed
07:17:51 <Cale> EvanR: It's just kinda the price you pay for automatic delivery of instances to where they're needed. It would be nice to have a way to control import/export of instances though.
07:18:12 <luite> EvanR: so yes, it's tricky, you can't hide them from imports, orphan instances can break stuff
07:19:37 <merijn> EvanR: You could newtype Maybe and use that, while converting to Maybe at your module's boundaries
07:19:45 <mgsloan> merijn: yeah, that sounds good!  With language design, one of the main things I like to think about is "how does this effect API change?".  Currently typeclasses don't do a very good job here, but with a little bit of "spooky-action-at-distance" this can be fixed
07:19:56 <EvanR> merijn: right
07:20:12 <EvanR> but redefining standard instances will make you incompatible with everyone in the universe
07:20:15 <EvanR> interesting
07:20:57 <merijn> mgsloan: I mean, I can see not allowing arbitrary mixing, but most chains where you want to close them you want to disallow further instances anyway, so you could define everything in one big chain anyway
07:21:18 <luite> EvanR: you'd have to make a lib that has access to the class, but not the instances though, if they're defined in the same module, you can't even build your evil everythingbreaking lib :)
07:21:26 <Cale> There's also the fact that if you allow control of import and export of instances, and people start using this feature a bunch, then you run into the problem that it's hard to *see* exactly where the instances are applied in the program.'
07:21:57 <Cale> They get applied where types switch from being polymorphic to monomorphic, but there isn't a syntactic barrier there.
07:22:01 <merijn> mgsloan: The same goes for overlapping, many useful instance chain tricks you want to define overlaps within a single chain, but I don't see why you'd necessarily want to support overlap between chains
07:22:10 <EvanR> yeah it effectively forces standardized instances
07:22:19 <EvanR> which has worked out well for me so far
07:22:26 <EvanR> newtype works fine
07:24:56 <Cale> Right, and if you give up on the silent choice of instances at these invisible sites where things become monomorphic, and make some required syntactic marker to pick an instance, then you might as well do away with typeclasses altogether and switch back to good ol' functional programming passing around record datatypes.
07:25:19 <Cale> But there are a few things that are in-between which could be done
07:25:39 <Cale> Like having an optional instance selection syntax
07:25:40 <scooty-puff> is there a strong reason to unpack/inline monad stacks?
07:26:15 <Cale> scooty-puff: Monad transformers don't usually optimise away terribly well
07:26:45 <Cale> scooty-puff: One thing which GHC is not good at is forming specialised representations for compositions of data constructors.
07:26:49 <scooty-puff> i was hoping that wasn't still the case..
07:26:52 <Cale> (it doesn't do this at all)
07:27:25 <scooty-puff> well, i guess you just do it when its the problem and never otherwise, so thats still not bad
07:27:52 <Cale> right, and if you design your library properly, the thing should be wrapped in a newtype to begin with
07:28:05 <Cale> Nobody should have to know that you're using monad transformers
07:28:54 <scooty-puff> one thing that i'm still uncertain about if is requirements should be made on the base monad, or if instead a monad transformer satisfying the requirement should be added within the newtype
07:29:01 <Cale> So when you go and replace those monad transformers with some crazy continuation passing implementation of your monad or something, nobody who uses your library should have to change any of their code.
07:29:08 <scooty-puff> in some cases its easy - not exposing internals, etc.
07:30:20 <Cale> If the base monad is a type parameter and your library defines a monad transformer, I guess that's a question you can ask
07:31:15 <scooty-puff> mostly i was thinking about if using Codensity is enough, or if it should be manually changed
07:32:05 <Cale> You're using Kan extensions in daily programming? :)
07:32:18 <Cale> (not that there's anything wrong with that, it's just cool)
07:32:23 <sclv> scooty-puff: one way to tell, profile :-)
07:33:04 <scooty-puff> well, its just a side project, unfortunately
07:35:28 <applicative> does ghc has a sort of standard representation of each type I introduce, e.g. of Foo a = Null | Foo a, as 1+a or whatever; a representation that would be the same for Maybe?
07:35:40 <Cale> applicative: In a sense, yes
07:36:38 <Cale> applicative: Things get compiled down into a constructor tag, which is an integer, together with a sequence of pointers to the parameters
07:36:46 <applicative> It would be interesting if we could construe user made types as basically already newtypes of those things.
07:36:58 <nh2> how can it be that something compiles with cabal build but not with ghci? "No instance for (Example Test)"
07:37:14 <Cale> You *might* be able to get away with unsafeCoerce, but no guarantees that it won't segfault.
07:37:25 <applicative> I was thinking of the complain, type classes are mad, you can only give one instance for each type.
07:37:56 <EvanR> Cale: are strict fields still pointers
07:38:00 <applicative> the response would be actually, the 'real' types dont fall into type classes. newtypes (understood thus broadly) do
07:38:13 <dcoutts> EvanR: yes, only unboxed fields are "the real thing"
07:38:27 <Cale> EvanR: yes, unless you have the relevant pragma/option turned on...
07:38:27 <byorgey> nh2: cabal build and ghci involve different mechanisms for bringing things into scope etc.
07:38:39 <EvanR> unboxed fields?
07:39:00 <byorgey> nh2: but without seeing the code it's impossible to say exactly.  Do you think there *should* be an instance for Example Test?  If so, in what module is it declared?
07:39:07 <Cale> data T = T {-# UNPACK #-} !Int
07:39:23 <EvanR> interesting
07:39:29 <Cale> There's also -funbox-strict-fields
07:39:36 <dcoutts> EvanR: where as data T = T !Int, is a box called T containing one pointer to an Int box
07:39:47 <Cale> which is like adding {-# UNPACK #-} globally
07:40:16 <Cale> This isn't always a performance gain, iiuc
07:40:17 <EvanR> point to an Int box?
07:40:23 <EvanR> pointer
07:40:32 <dcoutts> EvanR: data Int = I# I#   :-)
07:40:52 <dcoutts> meaning it's a heap object with a tag called I# that contains a single field of type I#
07:40:53 <Cale> that'll compile down to something like  data T = T Int# with the Int# stored directly in the constructor
07:41:05 <dcoutts> the type I# is the primitive machine int
07:41:08 <hpaste> nh2 pasted “compile error” at http://hpaste.org/72545
07:41:17 <Cale> Oh, is it called I# now?
07:41:22 <EvanR> the machine int needs to be in a box? weird
07:41:24 <applicative> so data T = T {-#Unpack#-} Int is the same as int
07:41:25 <EvanR> is that for gc purposes
07:41:29 <dcoutts> Cale: oh hmm, perhaps Int#
07:41:37 <Cale> ghci> :info Int
07:41:37 <Cale> data Int = GHC.Types.I# GHC.Prim.Int# 	-- Defined in `GHC.Types'
07:41:38 <EvanR> is the int box a pointer to an int ;)
07:41:42 <dcoutts> data Int = I# Ini#
07:41:45 <nh2> byorgey: how can I investigate? I just use hspec/hunit. http://hpaste.org/72545 how can the instance be there for cabal build?
07:41:50 <dcoutts> Cale: yep, me forgetting
07:42:14 <Cale> EvanR: Guess again :)
07:42:22 <Cale> EvanR: hint: map
07:42:25 <EvanR> the int box contains an actual int
07:42:31 <EvanR> not a pointer
07:42:38 <Cale> right
07:42:43 <byorgey> nh2: do you have multiple versions of hpsec or hunit installed?
07:42:53 <byorgey> nh2: also, can you paste your .cabal file?
07:42:54 <Cale> and the main reason that the box is there is for polymorphism
07:43:08 <EvanR> right
07:43:08 <EvanR> but
07:43:16 <applicative> EvanR my impression or heuristic picture was that unboxing a field sort of makes it part of the constructor. so T a = T {-#Unpack#-} !Int a has not one constructor, but its as if it had Int many
07:43:21 <EvanR> what i was wondering why, why is it a pointer to an int box and not an int itself
07:43:26 <hpaste> nh2 pasted “cabal file” at http://hpaste.org/72546
07:43:34 <nh2> byorgey: http://hpaste.org/72546
07:43:48 <EvanR> oh i guess polymorphic code wouldnt work
07:44:01 <EvanR> it expects all fields to be pointer to boxes
07:44:07 <applicative> dcoutts, the that picture basicallywrong ^^^
07:44:18 <dcoutts> EvanR: for example, in data T = T Int, if T contained the real machine int, you could not have T undefined be distinct from undefined
07:44:19 <Cale> When you put an Int# in a data constructor, the meaning is that it is unpacked already
07:44:30 <applicative> I think i acquired it reading tibbe's tutorials
07:44:36 <MHD> Is there a big ol guide to polymorphism gotchas?
07:44:43 <EvanR> dcoutts: i understand that, was talking about the difference between it being a pointer to a int box and a pointer to the int
07:44:44 <nh2> byorgey: the only thing I have multiple of is hunit: HUnit-1.2.4.2 HUnit-1.2.5.1 but Test.Hspec.Hunit should declare that instance, let me check
07:44:55 <parcs`> why can't you unpack polymorphic fields?
07:44:59 <byorgey> nh2: yes, it does
07:45:10 <Cale> parcs`: because boxes are how polymorphism works in the first place
07:45:11 <dcoutts> parcs`: they might all have different sizes
07:45:18 <applicative> parcs`: you mean, when the specialization is to an unboxable type?
07:45:27 <byorgey> nh2: you could try unregistering the older version of HUnit though I'm not sure that's the problem
07:45:27 <parcs`> applicative: yeah
07:45:50 <EvanR> even more implementation questions, for sum types, is the box as big as the biggest alternative?
07:45:59 <dcoutts> applicative: um I would not see it as having multiple constructors, just shortening out a pointer indirection when that's possible and doesn't affect semantics.
07:46:02 <Cale> When you apply  map :: (a -> b) -> [a] -> [b]   to various functions where the list elements have all different sizes in memory, the compiler doesn't have to compile specialised implementations of map for each new datatype
07:46:21 <applicative> i  was reaading some letter by tibbe about  this and simon pj kept saying in his special way "I can't understand what you are saying'
07:46:28 <nh2> byorgey: uh, no, unregistering the newer one fixed it (hspec depends on the older one)
07:46:34 <Cale> The reason for this is that everything (of kind *) has a standard-size box wrapped around it
07:46:42 <byorgey> nh2: ahh, yes, that would explain it
07:46:52 <nh2> byorgey: thank you
07:46:56 <byorgey> nh2: sure
07:47:09 <dcoutts> EvanR: oh I see, well it's simply that all heap objects need a header, so you never have a single int allocated in the heap, you have at a heap object which has a one word header (this is basically the constructor tag) and it's needed in particular for the GC.
07:47:29 <Cale> and so polymorphic functions will operate without having to compile more and more code -- map *really* doesn't have to care about the types a and b right down to the level of processor instructions :)
07:47:34 <dcoutts> EvanR: in this respect it's just like Java or other GC languages
07:47:49 <applicative> dcoutts: yes, thats clear, I think i am missing a word, I am going by tibbe's diagrams to represent the layout of a type, or rather a value of a given type.
07:48:14 <dcoutts> EvanR: all heap objects have as their first word a pointer to some metadata that the GC uses to know things like how many fields, which ones contain pointers etc
07:48:30 <luite> dcoutts: are info table pointer, closure type and constructor tag combined in one word?
07:48:55 <EvanR> swizzlated
07:48:55 <Peaker> http://hackage.haskell.org/trac/ghc/ticket/7110 is getting no love
07:49:17 <nh2> I have a question about darcs workflow: Let's say I want to contribute to hunit, hosted with darcs at http://code.haskell.org/HUnit/. After doing my changes, what is the work flow to get the hunit maintainer incorporate them? Send patches? Push it somewhere? What do people prefer?
07:49:23 <Peaker> I think that with optimizations, there's some sort of stack space leak when a clause pattern-matches on multiple args, and the first match succeeds, and the second doesn'
07:49:36 <dcoutts> luite: see the ghc dev wiki on heap object layout
07:51:34 <dcoutts> luite: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
07:52:01 <applicative> @dcoutts, if you look at eg http://johantibell.com/files/stanford-2011/performance.html#(18) slide 18.  the space occupied by the constructor IntPair (and its pointers) is taken up by the values themselves, in the unboxed  case
07:52:23 <dcoutts> applicative: yes
07:52:43 <otters> does anybody here use vim2hs?
07:52:59 <geekosaur> nh2, if the repo was set up properly, "darcs send" will package up your changes and mail them to the maintainer's address.
07:53:11 <nh2> geekosaur: thanks
07:53:15 <applicative> i see more clearly the ineptness of what I said before, the constructor is propely the first of the three words
07:53:38 <EvanR> i see clearly now the rain is gone
07:53:49 <geekosaur> it may ask you to enter some information about yourself (primarily full name) and you'll need to have some MTA such as postfix or exim set up
07:54:07 <dcoutts> applicative: right, it's best to think of the constructor as being represented by the first word, and that's unaffected by unpacking
07:54:36 <nh2> when I use cabal configure -v on hspec, why would it configure against HUnit-1.2.4.2 instead of the newer HUnit-1.2.5.1 when the .cabal file just says HUnit >= 1 && < 2?
07:54:50 <dcoutts> applicative: we just change the field, we get rid of the pointer and insert the payload of the pointed-to object (which is just one word size in this case but can be bigger of course)
07:55:03 <applicative> but if by constructor I mean the thing that might or might not have pointers,  which I should rename, then my formula is right.  Of course its right but a trivial restatemnet
07:55:18 <applicative> somehow I am nevertheless helped by the abovementioned heuristic
07:55:40 <EvanR> alpha conversion
07:57:18 <applicative> it isn't too crazy to think of the constructor not as IntPair, but as  Intpair pointer1 pointer2 which is basically the same for all boxed intpairs
07:57:39 <applicative> but i need another name, not constructor, for my halfwit heuristic
07:57:47 <dcoutts> applicative: heap object?
07:58:03 <applicative> yick, too computery
07:58:18 * dcoutts thought applicative was talking about representations
07:58:29 <applicative> I was,
07:58:39 <applicative> dont worry, you are helping with my muddle
07:58:39 <EvanR> heap objects are still pretty abstract ;)
07:59:44 <applicative> i guess partly i was thinking simply of the size of the value as represented. the 'heap object' in either case is the same size, three words
07:59:45 <BrockObomba> @hoogle genetic
08:00:27 <BrockObomba> where is hoogle?
08:00:37 <sclv> lambdabot is down
08:00:39 <Cale> http://www.haskell.org/hoogle/
08:00:43 <Cale> oh
08:00:58 <luite> dcoutts: ah i had read that but didn't really know where the constructor tag was stored. but i guess it makes sense, the closure layout only depends on the constructor. i use the payload now, wonder if i should change it
08:01:27 * hackagebot cab 0.1.14 - A maintenance command of Haskell cabal packages (KazuYamamoto)
08:01:39 <Cale> haha, I had two lambdabots running, neither of which was actually connected
08:01:40 <applicative> i think i am seeing better now; i should investigate better the workings of the 'heap'
08:01:44 <EvanR> read command as comonad
08:05:37 <applicative> pointers  are kind of gross.  somewhere I read that they are not characteristic of Fortran, as of C and, implicitly, Haskell, and everything else
08:06:11 * applicative proposes to learn Fortran, and befome the experton Fortran ffi problems
08:06:22 <applicative> become the expert on ....
08:06:24 <EvanR> haha
08:06:46 <EvanR> you almost switched to baltic
08:07:15 <applicative> There are Fortran bindings on Hackage somewhere, maybe in one the matrix libraries
08:07:37 <Cale> Fortran FFI with the Fortran implementation in GCC "just worked" last time I tried it
08:07:44 <Cale> oh, cool
08:08:00 <applicative> cool?
08:08:00 <EvanR> you know, i suggested not using pointers (often a product a dynamic allocation in C and C++) in the c++ channel a lot
08:08:10 <EvanR> was ridiculed
08:08:11 <Cale> That people are actually binding to Fortran libraries :)
08:08:39 <dcoutts> luite: actually I think it's interesting that the constructor tag is extracted from the info table rather than calculated from the info table address.
08:08:42 <applicative> cale, yeah i'mnot sure what it was. I hadn't seen an .f file before :)
08:09:07 <EvanR> however it seems pointers are required for implementation of a functional language
08:09:15 <applicative> i fiddled a  bit with a fortran tutorial and was findling in surprisingly handsome
08:09:42 <applicative> EvanR but does something like APL use them as we do?
08:10:09 <Cale> EvanR: Well, pointers are kind of required to do much of interest at the level of machine code in most architectures. You don't have other abstractions built on top of raw numbers and memory locations yet.
08:10:10 <luite> dcoutts: i felt at first that the extra indirection would be slow in javascript, so i moved it into the payload. i'm trying to "macroify" these things now so that it's easier to experiment with differnt heap object layouts
08:10:42 <Cale> EvanR: It is kind of like trying to build a castle on a foundation of sand, but these are the architectures we have :P
08:10:45 <EvanR> Cale: i mean the classic demonstration of what function application means for an abstract syntax tree
08:10:51 <EvanR> has arrows all over it ;)
08:11:31 <applicative> Cale that's what I was thinking -- not really knowing anything - it's the element of abstraction, all the highlevelness that requires these dismal pointers to pointers etc
08:11:37 <Cale> Oh, well, trying to program without graph structures of any type showing up anywhere is pretty damn hard.
08:11:39 <dcoutts> luite: if you put the info tables for each constructor next to each other in memory (ie an array) then you should be able to calculate the index of the constructor just from the info table pointer address, subtract base pointer and bit shift
08:12:03 * EvanR proposes that all of computer science is actually hunter gatherer chauvinist dogma
08:12:20 <merijn> EvanR: Elaborate?
08:12:22 <luite> dcoutts: hmm, that's quite interesting... unfortunately not possible in javascript :)
08:12:26 <Cale> From an operational standpoint, functional programming is fundamentally about graph rewriting.
08:12:27 <EvanR> merijn: joking
08:12:45 <merijn> EvanR: Obviously, but I still demand an elabortion!
08:12:45 <applicative> is APL all about graph rewriting
08:12:48 <EvanR> merijn: but some people dont want to accept arrows in diagrams as obvious
08:13:06 <Cale> and even if your processor architecture is drastically different, at some point you're going to have to represent all those arcs somehow.
08:13:13 <EvanR> that its some not necessarily legitimate cultural thing
08:14:01 <EvanR> Cale: perhaps a functional machine can be built from a mobile, expressions hanging from wires ;)
08:14:34 <EvanR> garbage collection is as easy as severing a wire and letting it drop back into the free memory pool ;)
08:14:48 <Cale> applicative: That's a legitimate question, though kind of a weird one. :)
08:16:18 <luite> bah why doesn't javascript have pointers... or integers
08:16:41 <Cale> applicative: I'm not sure I'd consider APL to be a "functional programming language"
08:16:43 <EvanR> double processions is better at integers than word32
08:16:56 <applicative> it would be nice if Hackage-17.x made it easy to grep all of Hackage without downloading it.
08:17:30 <luite> EvanR: actually not, you can't do word32 or int32 with it without annoying hacks
08:17:41 <Cale> EvanR: http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
08:17:50 <EvanR> luite: well its simulated
08:18:02 <EvanR> 'will be treated as a 32bit int'
08:18:24 <luite> EvanR: yes if you do bitwise ops, but intermediate results are still double, which is a problem
08:18:31 <EvanR> for performance
08:18:43 <luite> EvanR: if you multiply two integers through a double, you can lose precision
08:19:11 <EvanR> you can, but your range is still wider than a normal int
08:19:29 <EvanR> you have to worry about 'overflow' either way
08:19:41 <luite> yes but javascript overflows differently
08:19:58 <EvanR> either way its not really 'integers'
08:20:12 <EvanR> and if you expect that then you need to put in checks
08:20:16 <luite> usually you just expect it to throw away the most significant bits
08:20:28 <EvanR> not in javascript
08:20:49 <luite> no, in javascript you lose both most significant and least significant bits when multiplying
08:21:04 <EvanR> ah youre relying on the overflow behavior for some hacks
08:21:09 <EvanR> oh well :)
08:21:26 <luite> no, it's just how Int32 is epxected to work
08:21:51 <EvanR> if Int32 is like C int, then no because signed overflow is undefined behavior (i think)
08:23:00 <byorgey> from the Int32 documentation: "All arithmetic is performed modulo 2^n, where n is the number of bits in the type. "
08:23:23 <EvanR> mod or rum
08:23:26 <EvanR> mod or rem
08:23:57 <sipa> > mod (-1) 5
08:23:58 <lambdabot>   4
08:24:03 <sipa> mod
08:24:04 <byorgey> there's no difference, because the modulus is a positive integer, namely 2^n
08:24:20 <sipa> > rem (-1) 5
08:24:21 <lambdabot>   -1
08:24:21 <EvanR> > rem (-1) 5
08:24:22 <lambdabot>   -1
08:24:25 <applicative> Cale ah well, I can't find my hackage example fo a fortran binding
08:24:42 <byorgey> @check \x y (Positive n) (x + y) `mod` n == (x + y) `rem` n
08:24:42 <lambdabot>   Parse error in pattern at "`mod`" (column 27)
08:24:49 <byorgey> @check \x y (Positive n) -> (x + y) `mod` n == (x + y) `rem` n
08:24:50 <lambdabot>   Not in scope: data constructor `Positive'
08:25:08 <luite> EvanR: hmm, perhaps these guarantees don't need to be made for the usual Int
08:25:22 <byorgey> @check \x y n -> (n > 0) ==> ((x + y) `mod` n == (x + y) `rem` n)
08:25:23 <lambdabot>   Not in scope: `==>'
08:25:28 <byorgey> arrggh
08:25:37 <luite> still 30 bits is too much precision for double
08:25:51 <EvanR> luite: im surprised javascript has the support it does for bit twiddling
08:26:06 <byorgey> how is ==> not in scope?
08:26:15 <luite> i'm disappointed it doesn't have more :p
08:26:32 <luite> oh and i should look into using typed arrays for deconstructing floating point numbers into bytes :)
08:26:42 <EvanR> js is nice for how relatively simple it is in the web world, but i wish it were simpler
08:27:29 <luite> it's a pretty horrible compilation target :)
08:27:35 <Cale> byorgey: I'm not sure. I remember being annoyed by that too. Maybe I should have a look at the lambdabot source at some point to see how it's determining imports for @check. It's probably that the version of QC is newer than the @check code was originally designed for.
08:27:36 <EvanR> heh
08:27:57 <EvanR> luite: what are you compiling into javascript?
08:28:00 <byorgey> Cale: could be, but I think ==> has been around for a long time
08:28:01 <luite> haskell
08:28:07 <EvanR> ah
08:28:12 <Cale> byorgey: yeah, but perhaps it's changed modules?
08:28:20 <EvanR> luite: dont implement Int ;)
08:28:22 <byorgey> Cale: ==> is exported from Test.QuickCheck
08:28:38 <EvanR> or implement Integer first
08:28:40 <byorgey> Cale: it would be nice if modifiers like Positive, etc. were in scope too
08:28:43 <EvanR> and Int in terms of Integer ;)
08:28:55 <Cale> In that case, I dunno, it's weird.
08:29:38 <Cale> Quite possibly it's using the same L.hs as everything else.
08:29:49 <luite> EvanR: nah Int is really necessary, but i guess one could try to get away with slightly different overflow behaviour, and only implement it correctly for Int32 etc... but i'm not really sure if it's possible to distinguish between the two once you get down to STG
08:29:53 <Cale> Let's try importing Test.QuickCheck
08:30:33 <EvanR> luite: what about Int and friends in terms of Integer
08:30:36 <luite> EvanR: Integer is really slow too :) it uses google closure library bignums to implement the necessary libgmp stuff
08:30:36 <Cale> @undefine
08:30:45 <Cale> @check \x y n -> (n > 0) ==> ((x + y) `mod` n == (x + y) `rem` n)
08:30:46 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:30:47 <lambdabot>                     (Test.QuickCh...
08:30:50 <Cale> ...
08:31:01 <EvanR> luite: ah well i guess you are on the performance train right now ;)
08:31:14 * EvanR gives luite a constant factor
08:31:28 <Cale> wat
08:31:28 * hackagebot distributed-process 0.2.3.0 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
08:31:29 <luite> EvanR: well the goal for now is to make something that's a lot faster and a lot less leaky than the old code generator
08:31:51 <nh2> geekosaur: seems like darcs send doesn't work: darcs failed:  Not a repository: http://code.haskell.org/HUnit (Server returned nothing (no headers, no data))
08:31:58 <nh2> geekosaur: what would I do in this case?
08:32:42 <Cale> :t (==>)
08:32:43 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
08:32:48 <EvanR> > realToFrac (9283748743428374928374 :: Integer) :: CReal
08:32:50 <lambdabot>   9283748743428374928374.0
08:33:24 <EvanR> > (floor . sqrt) (realToFrac (9283748743428374928374 :: Integer) :: CReal)
08:33:28 <lambdabot>   mueval-core: Time limit exceeded
08:33:34 <EvanR> :(
08:33:48 <byorgey> Cale: uh, weird
08:33:48 <Cale> > sqrt (9283748743428374928374 :: CReal)
08:33:53 <lambdabot>   mueval-core: Time limit exceeded
08:33:59 <EvanR> can i has integer square root
08:34:31 <byorgey> EvanR: http://hpaste.org/46245
08:34:56 <EvanR> awsome o_O
08:35:03 * applicative hadnt notice that the old code generator was leaking
08:35:23 <gwern> @quote leak
08:35:23 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
08:36:07 <Cale> Just what are time flies, and why do they like arrows so much?
08:36:25 <Palmik> Does anyone know the reason why "lookAhead" was removed from attoparsec?
08:37:02 <geekosaur> nh2: I just poked at the repo and it doesn't have a maintainer address set up.  suggest you read the cabal file to see where the maintainer/homepage are and contact the maintainer directly
08:38:33 <sm> Fruit flies like a Banana.
08:39:16 <trem> i'm currently optimizing some code and now i wonder if using existentials (ala ExistentialQuantification) ads another indirection to the data access and if it's therefore worth to get rid of it. any oppinions?
08:39:27 <trem> s/ads/adds
08:39:51 <EvanR> existentials just relaxes the type system right
08:39:56 <n-dolio> It adds as much overhead as wrapping it in a data without existentials.
08:41:10 <trem> EvanR, n-dolio : thanks, so i'll try to find something else I can do...
08:41:50 * copumpkin steals LtWorf's bat'leth
08:42:08 <EvanR> you are without honor
08:42:12 <donri> nuqneH!
08:43:16 * LtWorf larts copumpkin with bare hands
08:44:02 <EvanR> copumpkin cofilling goes coeverywhere
08:44:20 <beaky> since haskell is purely functional, are the numbers and empty lists in haskell actually functions themselves?
08:44:20 <sipa> s/goes/coes/ ?
08:44:27 <Cale> beaky: no
08:44:28 <beaky> like church numerals?
08:44:37 <donri> beaky: no
08:44:39 <sipa> purely functional does not mean that every value is a function
08:44:40 <EvanR> import Control.CoBasic
08:44:42 <donri> except in lambdabot ;p
08:44:44 <EvanR> coto
08:44:48 <sipa> it means that every functuon is a value
08:45:01 <LtWorf> well maybe 5 is a function that returns 5? :D
08:45:06 <donri> beaky: http://conal.net/blog/posts/everything-is-a-function-in-haskell
08:45:08 <sipa> it is not
08:45:15 <applicative> trem certainly some code with 'existentials' is absurdly fast, though perhaps for other reasons; cp the stream fusion libraries
08:45:16 <EvanR> :t const 5
08:45:19 <lambdabot> forall t b. (Num t) => b -> t
08:45:34 <donri> > 5 2
08:45:34 <sipa> const 5 is the function that always returns 5
08:45:38 <lambdabot>   mueval-core: Time limit exceeded
08:45:56 <Cale> also that every function is *actually* a function and not just a procedure which we're calling a function because it produces a result and we're bad at math
08:46:29 <EvanR> it triggers a function in the device were controlling
08:46:32 <EvanR> like firing missiles
08:46:37 <Cale> heh
08:47:03 <applicative> haskell isnt 'functional' its  'denotative' . Lets arbitrarily adopt Landins jargo
08:47:06 <applicative> jargon
08:47:09 <donri> @where+ function http://conal.net/blog/posts/everything-is-a-function-in-haskell
08:47:09 <lambdabot> I will remember.
08:47:23 <fmapE> I'm trying to use Data.Attoparsec.Text. There's supposed to be an IsString instance for Parser, but it complains that the instance is missing when I try to use an overloaded string in my parser. I tried importing Data.Attoparsec.Types () but that did not fix the error. How do I bring in the IsString instance?
08:48:12 <EvanR> in true object oriented systems, everything is an object
08:48:13 <Cale> Wait, what? Why would you... IsString for Parser?
08:48:22 <EvanR> in true functional systems everything is a function
08:48:25 <EvanR> \o/
08:48:40 <Cale> s/true/untyped/
08:49:00 <roconnor> applicative: how will denotative help?  Imperative programs have denotations.
08:49:02 <n-dolio> Everything may also be a pair there, too.
08:49:06 <MostAwesomeDude> EvanR: "true object oriented?" We normally just call them object-based.
08:49:15 <EvanR> even the if statement is an object
08:49:19 <EvanR> or function
08:49:28 <EvanR> and this somehow helps
08:49:54 <applicative> roconnor: landin and strachey agreed to make imperative and denotative a genuine opposition, it seems.  I have been reading up because of my 'enemy' Uday R
08:50:00 <donri> fmapE: perhaps you have multiple versions installed, that tends to mess with instances
08:50:10 <donri> fmapE: ghc-pkg list attoparsec
08:50:28 <roconnor> applicative: weird
08:50:46 <n-dolio> So that's a dichotomy, despite the fact that imperative languages can have denotational semantics?
08:50:58 <fmapE> donri: Nope I just have one. I already checked that just to make sure I had the latest attoparsec
08:51:10 <applicative> landin  recommends this in "the next 700...'
08:51:20 <Cale> fmapE: hmm, yeah, it does say there's an IsString instance in the haddock, but unfortunately, Haddock doesn't say which module the instance is in.
08:51:20 <dgpratt> is there an easy way to determine what locally installed packages depend on package X?
08:52:07 <fmapE> Cale: what if the instance is defined in an unexported module?
08:52:07 <donri> fmapE: ok... you have -XOverloadedStrings? you're not trying to use the Parser literal as a String? (e.g. using ++)
08:52:28 <Cale> fmapE: Then you have to import a module which imports that module
08:52:32 <applicative> fmapE Data.Attoparsec.ByteString.Char8 and Data.Attoparsec.Text have the instances
08:52:51 <fmapE> yes I have overloaded strings, and I'm trying to use a string literal as a Parser
08:52:51 <applicative> imported from corresponding internal modules, which should work
08:53:11 <fmapE> applicative: I'm importing Data.Attoparsec.Text
08:53:27 <Cale> I wonder why Attoparsec is in Data
08:53:46 <Cale> Our top level module hierarchy is silly
08:53:49 <donri> Cale: because it parses byte sequences, maybe
08:54:22 <applicative> fmapE well the instance is instance IsString (Parser Text) where     fromString = string . T.pack
08:54:44 <Cale> The first thing we did when hierarchical modules were added to Haskell was categorise everything into a few different boxes all labelled "miscellaneous"
08:55:01 <Cale> .___.
08:55:20 <Cale> Data.* and Control.* are silly
08:55:25 <donri> heh
08:55:45 <applicative> Control.Applicative  Data.Functor
08:55:50 <donri> also how some things are too deeply hierarchical
08:55:54 <fmapE> applicative: Hm. Could the problem be that type Parser = Data.Attoparsec.Internal.Types.Parser Text is the "Parser" exported from Data.Attoparsec.Text?
08:55:57 <donri> Text.XML.* why not just XML.*
08:56:25 <EvanR> down with the hierarchy
08:56:33 <ion> Net.Example.MySite.XML.*
08:56:36 <applicative> oh fmapE, but the parser type you are using, isn't that one maybe?
08:56:39 * ion ducks
08:56:54 <donri> System.Console.* why not just Console.*
08:57:04 <ion> Console.* why not just *
08:57:22 <roconnor> Cale: Hackage gives silly warnings when you do not use pre-approved top-level names
08:57:35 <Cale> roconnor: perfect
08:57:39 <donri> really?
08:57:57 <roconnor> donri: ya, I always get warnings when I use top level "Lens" for lens-families
08:58:04 <donri> huh, never seen it
08:58:15 <donri> and there are all these apps with their own top-level modules
08:58:22 <donri> Darcs.*
08:58:46 <applicative> well, you just need to write Ross P and tell him to admit Lens ....  he ought to know there are a million competing libraries in the works
08:59:02 <roconnor> oh I don't care about the warning
08:59:03 <applicative> import Lens.Awesome
08:59:04 <donri> Control.Lens vs Data.Lens ;)
08:59:12 <Cale> There are some things about old-timey Haskell that I sometimes miss, and one of them was the simplicity of imports to get all the stuff you needed.
08:59:15 <applicative> System.Lens.Awesom
08:59:19 <fmapE> applicative: I am using the Parser type alias exported by Data.Attoparsec.Text
08:59:22 <donri> roconnor: where do you get the warning? on upload?
08:59:24 <roconnor> I'm just noting the small pressure that we have to maintain this top-level stuff
08:59:33 <roconnor> donri: ya, on upload, and on check I beleive.
08:59:42 <donri> hm never seen it on upload
08:59:53 <roconnor> okay, I don't remember
08:59:55 <donri> is Happstack.* an accepted top-level? :P
08:59:57 <roconnor> maybe only one of the two
08:59:59 <Cale> I used to  import FiniteMap   now I have to  import qualified Data.Map as M; import Data.Map (Map)
09:00:04 <applicative> fmapE: if that is a different type, you could just write your own IsString but this cant have been bos's intention?
09:00:09 <EvanR> Cale: i find 30 to 50% of my modules are imports now ;)
09:00:11 <roconnor> donri: maybe it only applies to libraries and not applications?
09:00:27 <donri> roconnor: well i've uploaded happstack libraries
09:00:35 <roconnor> I don't know what to say
09:00:37 <applicative> yeah applications are totally different, its clear
09:00:46 <ion> Let’s use a DAG instead of a tree for the module hierarchy. {Control, Data} → Lens
09:00:52 <donri> roconnor: maybe it depends on what Category you put it in o_O
09:01:05 <EvanR> ion: i like it
09:01:12 <fmapE> applicative: Parser in Data.Attoparsec.Text is Parser from Data.Attoparsec.Internal.Types applied Text, for the compiler tells me so.
09:01:13 <EvanR> tree is the goto structure for so many bastards
09:01:21 <EvanR> when something else might make more sense
09:01:24 <donri> ion: i like seeing my name in all caps!
09:01:32 <fmapE> I could write the instance but you're right it can't have been his intent.
09:01:39 <donri> we could use a JOHAN instead of a DAG
09:01:43 <ion> donri: Your parents must like data structures.
09:01:47 <EvanR> JBOD
09:02:17 <donri> ion: or perhaps git, so they can revise me as needed
09:02:38 <roconnor> the nice thing about lenses for Maps is that I'm less likely to trample data with insert, which has always been a problem for me.
09:02:58 <roconnor> needs to be called "unsafeInsert" :D
09:03:19 <Palmik> Does anyone know the reason why "lookAhead" was removed from attoparsec (it has been quite a while since it has been removed)?
09:03:42 <roconnor> well, maybe it is still bad with lenses :/
09:04:10 <Cale> Palmik: Sounds like something which would be done for performance reasons
09:04:18 <donri> roconnor: or maybe you should use something like adjust const instead of insert
09:04:18 <Cale> But I don't know
09:06:18 <Palmik> Cale, well, it could (potentially) worsen performance but it would also make writing some parsers much easier (in my opinion)... I think being able to peek at n bytes would be sufficient in most scenarios.
09:06:24 <geekosaur> I find https://bitbucket.org/bos/attoparsec/issue/9/lookahead which has no explanation attached
09:07:24 <applicative> fmapE: hm, there is a comment on the use  of overloaded strings in the middle of Data.Attoparsec.Text but I don't see how it helps
09:07:50 <donri> geekosaur: well there is an explanation, but i'm not sure it's true
09:08:23 <geekosaur> the (anonymous?) bug submitter has something that might or might not be one; bos didn't answer
09:08:33 <donri> geekosaur: yes he did?
09:08:38 <donri> "Lookahead isn't necessary, as attoparsec parsers backtrack."
09:09:09 <geekosaur> oh, crap.  right, forgot I have commenting blocked by default :/
09:09:22 <donri> wat
09:09:28 <Cale> and yet the library includes peekChar :: Parser (Maybe Char) which doesn't consume input
09:09:30 <fmapE> applicative: lemme look, one sec
09:09:52 <geekosaur> donri, there's a browser extension called Shut Up that blocks comment sections of various websites
09:10:01 <geekosaur> it's known to be slightly overactive in the case of bug trackers
09:10:14 <geekosaur> (since it operates at the level of CSS, it can't really tell)
09:10:32 <applicative> fmap I  dont get it but I see that the 'string' used in the internal IsString instance is exported as I.string from ...Attoparsec.Text rather mysteriously
09:10:43 <donri> geekosaur: why would you use that
09:10:53 <Cale> geekosaur: Yes, why would you use that? :)
09:11:01 <donri> i guess blocking youtube comments would be nice ^_^
09:11:03 <Palmik> Not to get distracted? :)
09:11:06 <Cale> I understand ad blocking
09:11:29 * hackagebot shelly 0.14 - shell-like (systems) programming in Haskell (GregWeber)
09:11:31 * hackagebot shelly 0.14.0.1 - shell-like (systems) programming in Haskell (GregWeber)
09:11:35 <EvanR> not comments in the html
09:11:38 <EvanR> like blog comments
09:12:00 <EvanR> shelly is the one that breaks the monad laws right
09:12:04 <Cale> EvanR: Did anyone suggest that it blocked HTML comments?
09:12:20 <Cale> It's weird to block blog comments and stuff.
09:12:27 <EvanR> blog comment sections
09:12:32 <EvanR> thought of html comments
09:12:38 <EvanR> er block*
09:12:43 <donri> i don't usually comment on blocks in its html source
09:12:56 <EvanR> blahhhh
09:13:10 <donri> blogs* haha
09:13:12 <applicative> fmapE I don't know how qualified exports work, it occurs to me, but maybe this complicates things.  It seems imposisible
09:13:25 <Palmik> Anyway, it might be the case that you can express the same set of grammars with or without lookAhead (maybe not the same set of parsers though).
09:13:35 <donri> i don't think qualified imports affect instances at all
09:14:02 <geekosaur> mostly it;s about avoiding comment sections on news sites, although there are parts of reddit that are a lot more readable without the comments...
09:14:18 <fmapE> applicative: Time to define an instance. Silly, but it seems mandated at this point.
09:14:20 <applicative> qualified exports is what I was fretting about.  If you import Atto...Text, you see the "I.string" as "string"
09:14:28 <donri> geekosaur: so then don't open the comment pages on reddit? :P
09:14:55 <Cale> geekosaur: What's forcing you to read those in the first place?
09:15:12 <applicative> fmapE, maybe you should file a bug report.  It probably isn't a bug but some elucidation about how you use the IsString instance might be necessary.
09:15:13 <Cale> I mean, it's just text, usually at the bottom of the page...
09:15:31 <EvanR> for me, on reddit, its all comments
09:15:32 <Cale> If it were interspersed with the articles, then it would make sense to block it
09:15:36 <EvanR> but im not that familiar with reddit
09:15:42 <fmapE> applicative: I'll look into that.
09:16:05 <donri> comments do tend to be non-constructive on many websites, that much i can agree with
09:17:50 <JorgeArbusto> Fool me once, fool me twice
09:18:19 <JorgeArbusto> Anyone here used google visualization api?
09:18:31 <donri> fmapE: maybe if you hpaste the actual error you're seeing, someone will spot something you missed.
09:20:08 <JorgeArbusto> someone spanish in here?
09:20:37 <matthiasgorgens> What are some nice ways to write a function of type (a->Maybe b) -> a -> Maybe (a, b) ?
09:20:58 <hpaste> fmapE pasted “Attoparsec IsString instance error” at http://hpaste.org/72547
09:22:24 <applicative> fmapE note that in ghci it accepts e.g. try  "2"
09:22:43 <EvanR> :t \f a -> maybe (\b -> (a,b)) (f a)
09:22:44 <lambdabot> forall t t1 a. (t -> a -> t1 -> (t, t1)) -> t -> Maybe a -> t1 -> (t, t1)
09:23:03 <EvanR> :t \f a -> f a >>= (\b -> (a,b))
09:23:04 <lambdabot> forall a t. (Monad ((,) t)) => (t -> (t, a)) -> t -> (t, a)
09:23:07 <applicative> fmap it rejects signed (fmap read "2")
09:23:26 <MostAwesomeDude> :t \f a -> do { b <- f a; return (a, b) }
09:23:27 <lambdabot> forall (m :: * -> *) t t1. (Monad m) => (t1 -> m t) -> t1 -> m (t1, t)
09:23:50 <MostAwesomeDude> matthiasgorgens: ^^
09:24:05 <EvanR> @pl \f a -> do { b <- f a; return (a, b) }
09:24:05 <lambdabot> (line 1, column 12):
09:24:05 <lambdabot> unexpected "{"
09:24:05 <lambdabot> expecting variable, "(", operator or end of input
09:24:41 <EvanR> @pl \f a -> f a >>= \b -> return (a, b)
09:24:41 <lambdabot> (`ap` ((return .) . (,))) . ((>>=) .)
09:24:44 <EvanR> ^
09:25:06 <fmapE> applicative: really? I still get "no instance for..."
09:25:11 <donri> fmapE: "If we were to try to use *> above instead, the type checker would not be able to tell which IsString instance to use for the text in quotes. We would have to be explicit, using either a type signature or the string parser."
09:25:16 <donri> fmapE: maybe the same is true for (>>)
09:25:23 <donri> fmapE: try using .*> instead
09:25:40 <applicative> you have :set -OverloadedStrings on I guess?
09:25:40 <donri> fmapE: "ET_SPL" .*> pure TrackingFailure
09:25:47 <JorgeArbusto> > let g f a = case f a of Just b -> Just (a,b); Nothing -> Nothing; in g (\_ -> Just 5) 10
09:25:49 <lambdabot>   Just (10,5)
09:26:07 <JorgeArbusto> :t maybe
09:26:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:27:14 <donri> fmapE: (btw did you give that parser a type signature?)
09:27:15 <fmapE> donri: Yup that seems to be it.
09:27:31 <applicative> fmapE: I take it back, it gives me the right type for "try "3"""  but if I try to use it - parse (try "2") "2"  -- I get the error
09:27:52 <EvanR> :t \f a -> maybe (\b -> Just (a, b)) (f a)
09:27:53 <lambdabot> forall t t1 a. (t -> a -> t1 -> Maybe (t, t1)) -> t -> Maybe a -> t1 -> Maybe (t, t1)
09:28:11 <fmapE> donri: yes I gave it signature Parser Eye (where Parser is the type alias for Data.Attoparsec.Internal.Types.Parser Text)
09:28:43 <EvanR> :t fromMaybe
09:28:44 <lambdabot> forall a. a -> Maybe a -> a
09:28:53 <Palmik> matthiasgorgens, depends what you mean by nice. I would probably write (foo f x = maybe Nothing (\y -> Just (x, y)) $ f x) but someone might prefer this (foo f x = f x >>= (\y -> Just (x, y))) or something alse altogether.
09:28:55 <applicative> i still think if there isn't anything wrong with attoparsec, there's a communication failure
09:29:07 <applicative> which is a different kind of thing wrong
09:29:13 <donri> fmapE: maybe you need to give the actual string parser a type signature... etSPL = "ET_SPL" :: Parser Text
09:29:15 <EvanR> oh i kept missing the first arg of maybe
09:30:16 <applicative> fmapE: try :   parse (try "2"::Parser Text) "2"
09:30:54 <applicative> fmapE which is what donri was suggesting I guess
09:31:23 <ParahSailin_> there is a type defined "type SeqData = B.ByteString" -- how do i "cast" a ByteString as a SeqData in a constructor that takes SeqData
09:31:32 <fmapE> donri, applicate: Yea that works, but at that point I might as well say "string "ET_SPL"" and be done with it.
09:31:40 <donri> sure
09:31:45 <donri> or .*> :)
09:32:07 <geekosaur> ParahSailin, you don't, nor do you need to; "type" is a type synonym
09:32:11 <applicative> ParahSailin_: you dont need to cast it it already is a SeqData as long as the type synonym is in scope
09:32:34 <JorgeArbusto> Now lets eat some sushi
09:32:38 <ParahSailin_> "Couldn't match expected type `SeqData'
09:32:40 <ParahSailin_>                 with actual type `ByteString'"
09:32:40 <fmapE> This whole thing isn't preventing me from writing my program, it's just preventing me from using strings without annotation in my parser, which seems to be the whole point of the IsString instance.
09:32:44 <JorgeArbusto> 16 bits
09:32:58 <Palmik> ParahSailin_, maybe you are using the wrong bytestring? (lazy or strict)
09:33:02 <geekosaur> ParahSailin, that may indicate you really need to go from strict to lazy... that
09:33:04 <applicative> ParahSailin_: could it be e.g. Lazy versus Strict
09:33:06 <applicative> haha
09:33:11 <applicative> @quote fugue
09:33:11 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
09:34:13 <ParahSailin_> ok how do i construct with strict
09:34:54 <ParahSailin_> does it involve ! operator?
09:35:20 <applicative> which do you have in scope strict or lazy?
09:35:23 <donri> fmapE: i think the point is that it still works in some cases, like when you actually have top-level Parser Text parsers
09:35:29 <c_wraith> fmapE: using OverloadedStrings can only involve *more* annotation, not less
09:35:40 <applicative> and which is the  one SeqData is defined in terms of
09:36:10 <ParahSailin_> ah, lazy
09:36:22 <ParahSailin_> derp, ok thanks
09:37:36 <applicative> ParahSailin_: you can either get the modules on the same page by changing the iimport in this one; or by the usual fromChunks toChunks maneuvers
09:38:02 <EvanR> full laziness
09:38:06 <luite> dcoutts: does ghc actually use the optimization you described, with pointer tags from offsets? unsafeCoerce from Maybe a to some data X = Nil | Some a gives the "right" result
09:38:09 <applicative> the next version of ByteString will have "toStrict" and "fromStrict"
09:38:20 <dcoutts> luite: I don't think it does
09:41:51 <luite> ah it's still an interesting idea... but i guess it might be tricky to get the linker to arrange the info tables exactly right
09:43:02 <ParahSailin_> indentation seems to matter with where statement, but i dont know the rules
09:43:09 <luite> hm, it's per module so maybe the linker doesn't have to be involved
09:49:53 <monochrom> indentation guideline: siblings are aligned vertically, children deeper, parents shallower
09:54:01 <applicative> ParahSailin_: and the new alignment is determined by the first thing typed after the keyword
09:55:41 <donri> @tell edwardk I think you forgot to export defaultRules in 1.4
09:55:41 <lambdabot> Consider it noted.
09:56:24 <copumpkin> edwardk never forgets
09:56:49 <donri> u lie!
09:57:11 <EvanR> im going to get sicp for the office 'library'
09:57:17 <EvanR> is there a good haskell book to get
09:58:03 <donri> edwardkbot: what is this!
09:58:12 <edwardkbot> hah
09:58:34 <edwardk> left over joke from the other day
09:58:34 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
09:58:51 <Taneb> edwardk, while we're complaining, the documentation for Data.Functor.Extend in semigroupoids is dodgy
09:58:58 <edwardk> donri: yeah i forgot the export rules
09:59:02 <edwardk> Taneb: send a patch ;)
09:59:40 <edwardk> byorgey, dmwit, mgsloan: where are you guys hiding?
10:00:16 <edwardk> figured out how to make monadic actions also compose with other lenses
10:00:47 <edwardk> act :: Monad m => (a -> m c) -> Action m a c
10:00:55 <edwardk> and monadic traversals, monadic indexed traversals, etc.
10:02:27 <ParahSailin_> :src return
10:04:02 <DMcGill> ParahSailin_: `return' is different for each Monad
10:04:23 <edwardk> @hpaste
10:04:23 <lambdabot> Haskell pastebin: http://hpaste.org/
10:04:55 <hpaste> edwardk pasted “active lenses” at http://hpaste.org/72552
10:05:05 <edwardk> thats perhaps a bit wide
10:05:13 <Taneb> edwardk, define an Extend in one, category-theory-ish sentence
10:05:24 <ParahSailin_> :t zipWith
10:05:26 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:05:27 <edwardk> Taneb: cokleisli composition forms a semigroupoid
10:05:36 <edwardk> its a semicomonad
10:05:49 <ParahSailin_> :t zipWith3
10:05:50 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:05:55 <edwardk> or a comonad without counit
10:05:57 <Taneb> Similar to "a strong lax semimonoidal endofunctor" for Apply
10:06:04 <edwardk> yes
10:06:17 <edwardk> strong lax semicomonad
10:06:30 <edwardk> or cosemimonad or whatever
10:06:49 <edwardk> but if i called it a cosemimonad people'd run screaming
10:06:59 <Taneb> A cosemicomonad
10:07:13 <applicative> warm sticky?
10:07:19 <edwardk> applicative: hah
10:07:53 <edwardk> i think the comonads are warm fuzzy, and the monads are warm sticky. its easy to get out of a comonad, its soft and you like wearing it. monads on the other hand stick to you and are icky
10:09:27 <edwardk> donri: i'll push a 1.4.1
10:09:33 <donri> cool!
10:09:57 <jfischoff> @remember edwardk: i think the comonads are warm fuzzy, and the monads are warm sticky. its easy to get out of a comonad, its soft and you like wearing it. monads on the other hand stick to you and are icky
10:09:58 <lambdabot> I will never forget.
10:11:00 <edwardk> ok, its on hackage as of….
10:11:06 <edwardk> now
10:12:10 <edwardk> that and you can get a lot out of a comonad all at once. i mean, literally, you can see the whole thing, whereas a monad confines you to one little 'a' at a time. ;)
10:16:39 * hackagebot lens 1.4.1 - Lenses, Folds and Traversals (EdwardKmett)
10:20:04 <roconnor> http://en.wikipedia.org/wiki/Minimum-cost_flow_problem -- is there a haskell library for solving this?
10:20:29 <roconnor> maybe in the FGL?
10:29:00 <nh2> any way we can get killProcess as mentioned in http://hackage.haskell.org/trac/ghc/ticket/2954 ?
10:30:49 <geekosaur> nh2, see System.Posix.Process
10:31:13 <geekosaur> System.Process is the portable subset, so it's kinda limited in what it can do
10:33:02 <nh2> geekosaur: but killing should be OK on Windows as well, shouldn't it?
10:33:37 <geekosaur> I dont think Windows offers anything quite like kill -9, though, which is why System.Process doesn't offer it
10:34:17 <nh2> geekosaur: hmm, how would I then get "kill it as much as you can kill it per platform" behaviour?
10:34:20 <Blkt> good evening everyone
10:34:44 <DMcGill> some IFDEFINEDs?
10:35:08 <geekosaur> nh2, I am not a Windows API expert, I cannot help with that.
10:35:10 <Luke> shapr: you going to hacphi?
10:35:18 <Enigmagic> geekosaur: what about TerminateProcess()?
10:37:03 <nh2> DMcGill: even if I go for that, what would I use in the Unix part? there is no killProcess :: ProcessHandle -> IO () even in System.Process.POSIX
10:45:02 <k0ral> @hoogle timeout
10:45:02 <lambdabot> System.Timeout module System.Timeout
10:45:03 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
10:45:03 <lambdabot> System.Event type TimeoutCallback = IO ()
10:48:05 <danharaj> edwardk works fast :o
10:48:25 <donri> so he does!
10:55:54 <Cale> @check \n -> n >= 0 ==> sqrt (n^2) == n
10:55:56 <lambdabot>   No instance for (Test.QuickCheck.Testable
10:55:56 <lambdabot>                     (Test.QuickCh...
10:56:23 <Cale> oh, it's something weird about ShowQ
10:57:10 <Cale> no wait
10:57:45 <Cale> It's asking for an instance of Testable (Gen Prop)
10:57:58 <Cale> I wonder if I import Test.QuickCheck.Property
10:58:32 <donri> when a package says that strings are assumed to be utf8, what does that even mean?
10:58:48 <JorgeArbusto> Why is Erlang used and not Haskell? Erlang has Actor model concurrency and is a simpler language?
10:59:03 <Cale> JorgeArbusto: Are you trying to say that Haskell isn't used?
10:59:04 <c_wraith> donri: um..  it means it's broken, unless it's doing IO somewhere?
10:59:13 <donri> c_wraith: it's a binding to a C lib
10:59:19 <donri> http://hackage.haskell.org/packages/archive/stemmer/0.2/doc/html/NLP-Stemmer.html
10:59:29 <c_wraith> donri: ah.  then it assumes *C* strings are UTF-8?
10:59:38 <donri> c_wraith: but it takes String
10:59:40 <donri> not CString
10:59:48 <donri> note ByteString
10:59:53 <Enigmagic> donri: looks like bad bindings imo
11:00:06 <donri> well, it's from 2008 :)
11:00:39 <donri> s/note/not
11:00:39 <JorgeArbusto> Cale: Maybe it is used bot not much and not by something high-profile.
11:00:52 <c_wraith> donri: 50% chance meaningless, 50% chance broken :)
11:01:02 <donri> something like that
11:01:31 <Cale> JorgeArbusto: I dunno. Erlang isn't used that much either?
11:01:53 <Cale> JorgeArbusto: But Erlang has been around slightly longer, so maybe a few more projects have used it
11:02:53 <donri> JorgeArbusto: see cloud haskell / distributed-process for erlang-like distributed programming
11:03:36 <donri> JorgeArbusto: it's part more powerful (typed channels), part less powerful (not as powerful runtime introspection/debugging IIUC)
11:04:17 <JorgeArbusto> Not that much. But by Ericsson(ldo), Facebook, CouchDB.
11:04:50 <JorgeArbusto> Wouldnt it have been a good fit to code couchDB in haskell?
11:04:50 <donri> i would guess that erlang is used more than haskell, less than you think, and haskell more than you think. ^_^
11:05:14 <JorgeArbusto> typed channels?
11:06:07 <donri> JorgeArbusto: yes, messages in erlang are dynamically typed; cloud haskell offers strongly typed channels
11:06:24 <donri> (in addition)
11:06:48 <JorgeArbusto> haskell doesnt have as powerful runtime?
11:06:59 <donri> i think the closure serialization was supposed to be saner as well *handwaving*
11:07:08 <applicative> good day, Blkt
11:07:23 <Blkt> :D
11:07:34 <donri> JorgeArbusto: huh? haskell has a really capable IO manager if that's what you're on about
11:07:38 <applicative> Blkt do you have a question about Haskell?
11:08:47 <JorgeArbusto> Cale said one lang had a more powerful runtime, i first thought he meant haskel then i think he meant erlang
11:09:29 <geekosaur> I think "more powerful" there may depend on what youre trying to do with it
11:09:44 <donri> wait, when did cale say that
11:09:48 <dgpratt> donri: you mentiond the runtime not being as powerful, did you not?
11:09:58 <nand`> sometimes a simple RTS can be better than a complex/powerful one
11:10:35 <donri> dgpratt: not what i meant, but i guess you could conclude that if you wanted to :p
11:10:59 <donri> IIUC erlang allows you to connect to running processes and mess about with them live
11:11:01 <Blkt> is applicative a bot?
11:11:08 <dgpratt> donri: what are you on about? :p
11:11:08 <donri> Blkt: nope
11:11:12 <Blkt> ah
11:11:14 <Blkt> ops
11:11:23 <Blkt> sorry applicative, didn't mean to be rude
11:11:28 <applicative> Blkt: I don't type well enough to be a bot
11:11:37 <Blkt> ahahah
11:11:53 <Blkt> well, I don't have any question now, but thanks for the interest
11:12:17 <nand`> @ask edwardk Have you contemplated encoding lenses (eg. utf8)? What's the best approach here, a simple iso (with the possibility of uncaught failures), or is there some way to elegantly include the ‘Maybe’ for the ByteString -> String conversion?
11:12:17 <lambdabot> Consider it noted.
11:12:56 <donri> i mean even if you hooked up some ipc to hint or something in haskell i don't think you'd be able to do as much as in erlang, erlang being dynamic and whatnot
11:14:06 <danharaj> nand`: perhaps it would be best to have a Getter for validation and then a Lense for conversion.
11:14:06 <applicative> man these lens synonymns ar getting out of hand type IndexedMonadicFold i m a c  = forall k r b d. (Indexed i k, Monoid r)  => Overloaded k    (Act (Const r) m) a b c d  where type Overloaded k f a b c d = k (c -> f d) (a -> f b)
11:14:41 <danharaj> :P
11:17:45 <timthelion> applicative: is that a description for some new ultra portable apple computer?  The only part of that which I understood was  "Fold i m a c"
11:19:06 <applicative> timthelion: http://hpaste.org/72552 blame edwardk
11:19:30 <c_wraith> folding an imac?
11:19:37 <applicative> oh that's what you were referring to
11:19:51 <timthelion> :D
11:20:23 <danharaj> Lenses are the best thing since sliced monads.
11:20:33 <Gurragchaa> Lambdabot isn't responding to my private messages
11:20:38 <timthelion> I still don't get lenses, at all.
11:20:42 <timthelion> lambdabot:
11:20:53 <c_wraith> @botsnack
11:21:00 <timthelion> > putStr "I am not dead."
11:21:00 <c_wraith> yeah, lambdabot is just dead
11:21:48 <Gurragchaa> dang
11:25:14 <hpaste> nand` annotated “Functional pong with lenses and gloss” with “Functional pong with lenses and gloss (adjusted paddle position for clarity)” at http://hpaste.org/72509#a72556
11:26:45 <JorgeArbusto> hmm wouldnt it be sweet if you could runhaskell a paste?
11:28:30 <JorgeArbusto> where is hpaste serving? heroku?
11:32:04 <geekosaur> hm?  hpaste is based on http://hackage.haskell.org/package/snap-server
11:32:58 <t7> panic?
11:34:43 <nooodl> my entire scrollback log is one netsplit now
11:35:16 <SpecialEmily> yuuup
11:35:19 <byorgey> nooodl: you need a better IRC client =)
11:36:02 <nooodl> 500 lines is more than enough, honestly
11:37:40 --- mode: wolfe.freenode.net set +o ChanServ
11:37:53 <c_wraith> oh good.  I missed them all so much.
11:38:05 <nand`> timthelion: the example code I gave is a bit biased since portions of it live inside the state monad, but lenses can be used very purely as well, eg. when writing some traversal over a not-entirely-trivial type
11:38:43 <nand`> applicative: yeah, lenses would make great record systems
11:39:13 <applicative_> nand`: do  the other lens libraries permit this convenient use with state?
11:39:16 <nand`> you mean http://r6.ca/blog/20120623T104901Z.html ?
11:39:21 <applicative_> yes
11:39:45 <applicative_> Instead of introducing field names as projection functions pi1 :: Pair a b -> a and pi2 :: Pair a b -> b, he pursuade them to give field names the following unusual definitions instead."
11:40:31 <applicative_> I'm not sure what the equivalent proposal would be with kmetts lenses
11:40:31 <nand`> applicative_: most of htem do
11:40:34 <nand`> them*
11:40:42 <c_wraith> applicative_: it'd be pretty similar
11:40:46 <nand`> applicative_: the exact same, actually
11:41:04 <applicative_> ah, i figured.  this is the first lens library I have managed to get into
11:41:23 <nand`> note that pi1 and pi2 are :: Lens (Pair a b) (Pair a' b) a a'
11:41:57 <applicative_> mostly in the past it seemed motivated by people not liking the record system, but it took me forever not to find records disgusting...
11:42:58 <ReinH> applicative_: which lens library are you referring to?
11:43:11 <parcs`> quite impressive that the TH deriving stuff figures out the most general type signature for each lens
11:43:27 <applicative_> ReinH 'lens' https://github.com/ekmett/lens
11:43:37 <applicative_> ReinH: and on hackage
11:43:46 <ReinH> how many lens libraries are there now o_O
11:44:50 <cleantc> :t "test"
11:44:51 <lambdabot> [Char]
11:44:55 <ReinH> really nice to see meaningful examples like https://github.com/ekmett/lens/blob/master/examples/Pong.hs
11:45:11 <applicative_> ReinH: Indeed, thank nand`
11:45:13 <cleantc> let x = "test"
11:45:21 <cleantc> :t x
11:45:23 <lambdabot> Expr
11:45:43 <applicative_> ReinH: here is a blog post outlining some of the idea http://comonad.com/reader/2012/mirrored-lenses/ I think things are a bit different now
11:46:02 <nand`> not sure exactly why Pong is in /examples twice, once as Pong2.hs
11:46:11 <timthelion> So basically, lenses don't add new functionality, they simply unify syntax, such that operating on nested tuples and nested lists can use the same syntax?
11:46:34 <nand`> timthelion: they don't ‘add new functionality’ in that they don't extend Haskell
11:47:00 <applicative_> nand`: it looks like edwardk rewrote it according to his stylistic ideas?
11:47:20 <timthelion> Does the syntax have to be as awkward as it is in Control.Lens ? ;)
11:47:22 <applicative_> @tell edwardk "<ReinH> really nice to see meaningful examples like https://github.com/ekmett/lens/blob/master/examples/Pong.hs"
11:47:22 <lambdabot> Consider it noted.
11:47:39 <hpaste> cleantc pasted “GADT Inference” at http://hpaste.org/72559
11:47:56 <nand`> applicative_: oh, no; that's the version where the CPU auto-wins
11:48:00 <nand`> (Pong2)
11:48:04 <applicative_> oh
11:48:17 <nand`> (it calculates in advance where the ball will be and moves to the correct position right away)
11:48:22 <applicative_> i'll play pong1
11:48:28 <nand`> :)
11:48:37 <copumpkin> cleantc: that's kind of interesting
11:48:52 <copumpkin> I'd post on the GHC list about it :)
11:49:00 <nand`> actually, it's theoretically beatable since it doesn't take into account paddle height
11:49:02 <applicative_> actually i cant get the keys to work on os x but I hate games anyway :)
11:49:12 <cleantc> GHC list?
11:49:22 <copumpkin> ghc-users or whatever it's called
11:49:42 <nand`> (at any rate, I would use http://hpaste.org/72556 at this point, the others are somewhat outdated)
11:50:11 <JorgeArbusto> Lets say I have song where I love the instrumental part but not the singing, is there some (free software) that can delete the vocals?
11:50:52 <parcs`> :t let x = "test" in x
11:50:52 <roconnor> @faq Lets say I have song where I love the instrumental part but not the singing, is there some (free software) that can delete the vocals?
11:50:53 <lambdabot> The answer is: Yes! Haskell can do that.
11:50:54 <lambdabot> [Char]
11:51:09 <parcs`> copumpkin: what's interesting about that?
11:51:36 <nand`> is there a flip ($) anywhere I can use for prettifying some code?
11:51:38 <JorgeArbusto> @hoogle Quantum
11:51:38 <lambdabot> package quantum-arrow
11:51:39 <parcs`> oh, never mind. you were talking about the hpaste
11:51:42 <copumpkin> parcs`: index refinement should behave like an equality constraint
11:51:42 <JorgeArbusto> lol
11:51:44 <copumpkin> yeah
11:51:50 <JorgeArbusto> what is quantum-arrow?
11:52:07 <copumpkin> n-dolio: http://hpaste.org/72559
11:52:28 <copumpkin> cleantc: does that happen in latest GHC?
11:52:35 <cleantc> yep
11:52:53 <ben> > let € = flip ($) in 2 € succ
11:52:54 <lambdabot>   <no location info>: parse error on input `
11:53:00 <cleantc> well, 7.4.1
11:53:01 <applicative_> nand`: sometimes people have used the F#  |> as flip ($)
11:53:31 <dcoutts> > let (€) = flip ($) in 2 € succ
11:53:35 <lambdabot>   mueval-core: Time limit exceeded
11:53:41 <irene-knapp> amusement!
11:53:43 <ben> duh, sorry
11:54:01 <dcoutts> ben: the euro's an operator, obviously! ;-)
11:54:10 <n-dolio> I'm surprised line 10 even compiles.
11:54:43 <cleantc> n-dollio: why shouldn't it?
11:54:46 <copumpkin> cleantc: it all seems kinda funky :) I'd file a bug or at least bring it up on the mailing list
11:54:55 <copumpkin> doing irrefutable matches on those things is just wonky
11:55:04 <n-dolio> Because it normally gives one of those 'my brain exploded' messages.
11:55:13 <cleantc> haha
11:55:14 <ReinH> applicative_: I think piping makes more sense than composing to a large group of programmers
11:55:21 <n-dolio> Are you allowed to lazy match on the reflexive GADT? Because that's unsound.
11:55:26 <ReinH> especially those familiar with OO . syntax or, well, pipes
11:55:34 <ReinH> the dot hack is interesting as well
11:55:38 <n-dolio> Actually, that lazy match should allow you to write unsafe coerce, too.
11:55:40 <copumpkin> that'd be a fun way to write unsafeCoerce
11:55:40 <copumpkin> yeah
11:55:52 <c_wraith> n-dolio: I'm pretty sure you can't do any kind of lazy matching on GADTs without brain explosions
11:56:05 <n-dolio> Not according to that paste.
11:56:05 <ReinH> c_wraith: brainsplosions
11:56:12 <applicative_> ReinH yes, the Control.Arrow >>> frequently makes things more intelligle
11:56:24 <ReinH> yep, but it's so hard to type ;)
11:56:33 <cleantc> wait a second, thne how does a GADT pattern binding behave?
11:57:36 <c_wraith> n-dolio: hmm, yeah.  that shouldn't be allowed.  that's the exact same semantics as deconstructing a GADT with a let binding, which GHC doesn't allow
11:57:37 <cleantc> same problem
11:58:20 <n-dolio> c_wraith: copumpkin says it works, but doesn't refine the types.
11:58:23 <parcs`> same output on ghc 7.7 too
11:58:25 <n-dolio> Which is okay, I guess, but weird.
11:58:38 <applicative_> ghc 7.7??
11:59:07 <parcs`> yeah, ghc 7.6 has been branched so now the dev version is 7.7
11:59:23 <applicative_> ah, hadn't heard
11:59:27 <n-dolio> That explains how it's doing the inference.
12:00:22 <nooodl> haskell code golf: shortest ghc brain explosion
12:00:58 <hpaste> nand` pasted “Lens-based records” at http://hpaste.org/72560
12:01:06 <nand`> ^- some syntax ideas, how horrible are they?
12:01:25 <nand`> my main gripe is the fact that New{} throws a warning
12:01:32 <irene-knapp> have we even solved the "what type is a record accessor" problem yet?
12:01:44 <nand`> due to, from its point of view, uninitialized fields
12:01:47 * irene-knapp was initially excited about the proposals… then they dragged on for six months
12:02:02 <mroman> nooodl: fix(error)
12:02:22 <danharaj> > fix error
12:02:24 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:02:30 <nooodl> haha
12:02:47 <osfameron> @faq will Haskell do anything for love?
12:02:48 <lambdabot> The answer is: Yes! Haskell can do that.
12:02:54 <nooodl> @src fix
12:02:55 <lambdabot> fix f = let x = f x in x
12:03:34 <mroman> Sadly it doesn't really fix error
12:03:39 <nooodl> what's the "anagrammy" definition of fix again
12:03:45 <irene-knapp> @pl fix
12:03:46 <lambdabot> fix
12:03:50 <irene-knapp> oops, haha
12:03:52 <irene-knapp> dunno then
12:03:53 <nand`> anagrammy?
12:03:54 <EvanR> @unpl fix
12:03:55 <lambdabot> fix
12:03:59 <irene-knapp> @pl fix x
12:04:00 <lambdabot> fix x
12:04:00 <mroman> So if you tell ghc to fix error, it does not :(
12:04:15 <mroman> also
12:04:17 <hpaste> cleantc pasted “GADT Inference 2” at http://hpaste.org/72561
12:04:17 <mroman> :t fix error
12:04:18 <EvanR> @pl \f x -> f (f x)
12:04:18 <lambdabot> [Char]
12:04:19 <lambdabot> join (.)
12:04:20 <mroman> is actually [Char]
12:04:26 <mroman> so fix error would return a String
12:04:28 <nand`> > fix breakage
12:04:30 <lambdabot>   "No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No. No...
12:04:34 <mroman> > head "foo"
12:04:35 <lambdabot>   'f'
12:04:40 <mroman> > head $ fix error
12:04:41 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
12:04:48 <mroman> Doesn't really work the way one would expect.
12:05:00 <hughfdjackson> o.o fix?
12:05:04 <ben> > breakage ""
12:05:06 <lambdabot>   "No. "
12:05:15 <EvanR> :t fix
12:05:17 <lambdabot> forall a. (a -> a) -> a
12:05:38 <mroman> > (+1) $ fix error
12:05:39 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
12:05:40 <EvanR> :t join (.)
12:05:40 <lambdabot>    arising from the literal ...
12:05:41 <lambdabot> forall a. (a -> a) -> a -> a
12:05:41 <mroman> is a type error.
12:05:54 <nooodl> nand`: "fix f = fix where fix = f fix"
12:06:25 <EvanR> > reverse "fix f = fix where fix = f fix"
12:06:26 <nooodl> it's the same when (unwords.reverse.words)'d!
12:06:26 <lambdabot>   "xif f = xif erehw xif = f xif"
12:06:32 <nooodl> shhhh
12:06:51 <EvanR> > (unwords . reverse . words) "fix f = fix where fix = f fix"
12:06:54 <lambdabot>   "fix f = fix where fix = f fix"
12:07:14 <EvanR> fixed point of u . r . w
12:07:28 <nand`> :)
12:07:31 <applicative_> > (unwords . reverse . words) "fix     f          =               fix where              fix           = f fix"
12:07:33 <parcs`> hmm, edwardk should add 'words' and 'lines' isomorphisms
12:07:33 <lambdabot>   "fix f = fix where fix = f fix"
12:08:10 <ParahSailin_> if you have a list of maybes, is the default map function to just map to the just elements?
12:08:19 <ParahSailin_> and do you need to use mapmaybe instead?
12:08:25 <mroman> probably mapM?
12:08:38 <int-e> ParahSailin_: catMaybes?
12:08:51 <int-e> > catMaybes [Just 1, Nothing, Just 3]
12:08:52 <lambdabot>   [1,3]
12:09:02 <int-e> or (filter isJust)
12:09:07 <EvanR> ParahSailin_: no the default map function works the same for maybe as any other type
12:09:19 <mroman> > map (fmap (+3)) [Just 5, Just 3, Just 0, Nothing]
12:09:20 <lambdabot>   [Just 8,Just 6,Just 3,Nothing]
12:09:35 <danharaj> If you want to keep the Nothings apping over the justs, you need to map over the list structure and the Maybe structure.
12:09:38 <int-e> oh. mroman probably interpreted the question correctly.
12:09:55 <danharaj> so yeah, use fmap (fmap f) :P
12:09:57 <n-dolio> cleantc: It's new that that works.
12:10:12 <ParahSailin_> :t fmap
12:10:13 <JorgeArbusto> > catMaybes [Just 5, Nothing, Just 7]
12:10:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:10:15 <lambdabot>   [5,7]
12:10:23 <JorgeArbusto> > map Just $ catMaybes [Just 5, Nothing, Just 7]
12:10:25 <lambdabot>   [Just 5,Just 7]
12:10:40 <JorgeArbusto> > mapMaybes (+1) [Just 5, Nothing, Just 7]
12:10:42 <lambdabot>   Not in scope: `mapMaybes'
12:10:44 <ParahSailin_> map (+3) [Just 5, Just 3, Just 0, Nothing]
12:10:46 <cleantc> n-dolio: ? should it?
12:10:47 <EvanR> > fmap (+3) [Just 5, Just 3, Just 0, Nothing]
12:10:49 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
12:10:49 <lambdabot>    arising from a use of...
12:10:55 <mroman> :t mapF
12:10:56 <lambdabot> Not in scope: `mapF'
12:10:58 <mroman> hm.
12:11:01 <int-e> > map (fmap (+3))  [Just 5, Just 3, Just 0, Nothing]
12:11:01 <ReinH> applicative_: so if I want a lense into a chess board (data Board :: [[Square]]) to get/set pieces and I eventually want to change the representation to, say, a vector of vectors or an array (or maybe a repa array?), how easy would that be?
12:11:02 <lambdabot>   [Just 8,Just 6,Just 3,Nothing]
12:11:08 <danharaj> edwardk++ IndexedTraversals are a charm.
12:11:20 <mroman> > let mapF f = fmap (fmap f) in mapF (*3) [Just 3, Nothing]
12:11:20 <ReinH> *lens
12:11:20 <lambdabot>   [Just 9,Nothing]
12:11:25 <JorgeArbusto> > fmap (+1) [1,2,3]
12:11:26 <lambdabot>   [2,3,4]
12:11:43 <n-dolio> cleantc: It seems that the way it works prevents anything bad from happening. The naive way you'd implement it would let you coerce things.
12:11:43 <mroman> There should be a fmap (fmap f) function in Prelude :)
12:11:50 <JorgeArbusto> > flip fmap [1,2,3] (+3)
12:11:52 <lambdabot>   [4,5,6]
12:11:55 <mroman> It would be quite versatile.
12:12:02 <nand`>  (mapped.mapped) *~ 3
12:12:04 <nand`> :)
12:12:08 <nand`> parens unnecessary, actually
12:12:15 <danharaj> :t fmap fmap
12:12:16 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
12:12:34 <ReinH> > (fmap . fmap) (+3) [Just 1, Nothing, Just 3]
12:12:36 <lambdabot>   [Just 4,Nothing,Just 6]
12:12:46 <JorgeArbusto> > let ffmap f = fmap (fmap f) in ffmap (+1) [Just 7]
12:12:48 <lambdabot>   [Just 8]
12:13:00 <int-e> @type fmap . fmap
12:13:01 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:13:10 <ReinH> let fmapmap = fmap . fmap -- :p
12:13:17 <EvanR> @type fmap . fmap . fmap
12:13:18 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
12:13:19 <nand`> :type fmap fmap fmap
12:13:20 <JorgeArbusto> > (fmap . fmap) (+1) [Nothing, Just 7]
12:13:23 <lambdabot>   [Nothing,Just 8]
12:13:28 <nand`> @type fmap fmap fmap
12:13:29 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:13:46 <ReinH> it's fmaps all the way down
12:13:48 <nand`> @type (.:)
12:13:49 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
12:14:00 <int-e> > (+3) .: [Just 1, Nothing] -- in Caleskell at least.
12:14:02 <lambdabot>   [Just 4,Nothing]
12:14:04 <nand`> :)
12:14:35 <nand`> mapped.mapped *~ 3 is cleaner ;)
12:15:09 <simply-chris> Caleskell :D
12:15:47 <mroman> > let fmap' n = replicate n fmap
12:15:48 <lambdabot>   not an expression: `let fmap' n = replicate n fmap'
12:16:07 <simply-chris> fmap fmap.
12:16:12 <mroman> > let fmap' n = foldl1 (.) $ replicate n fmap in (fmap' 2) (+3) [Just 5, Nothing]
12:16:13 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
12:16:17 <mroman> :(
12:16:25 <mroman> How dare you deny my fold!
12:16:28 <EvanR> > fix ("fmap " ++)
12:16:31 <lambdabot>   "fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap...
12:16:33 <timthelion> I would so love to be able to have logic within patterns.  Like foo (LT|EQ) = "The value passed was less than or equal to."
12:16:39 <timthelion> Is this possible?
12:17:16 <mroman> > let inc' n = foldl1 (.) $ replicate n (+1) in (inc' 3) 4
12:17:18 <lambdabot>   7
12:17:23 <danharaj> There are 'or patterns' in some variants of ml.
12:17:26 <mroman> Why doesn't that work with fmap?
12:17:35 <danharaj> because the type depends on the number n
12:17:38 <timthelion> danharaj: that's it, I'm quiting haskell
12:17:40 <timthelion> :)
12:17:42 <danharaj> lol
12:17:58 <danharaj> What you can do is use pattern guards though.
12:18:07 <danharaj> To get something approximately the same.
12:18:25 <mroman> Ah yeah, right.
12:18:29 <timthelion> honestly, it would make the code I'm writting much more readable.  No, pattern guards are not the same :/  How would you write my example with pattern guards?
12:18:33 <mroman> . doesn't really work with stuff that takes two arguments.
12:18:36 <ParahSailin_> i need a function of type " (a -> [a]) -> m a -> [m a] "
12:18:38 <int-e> mroman: I would prefer  foldr (.) id  -- it works for empty lists and can exploit laziness.
12:18:53 <nand`> ParahSailin_: looks like a traversal of some sort
12:19:06 <nand`> oh, not quite
12:19:20 <nand`> wait, yes
12:19:27 <nand`> if m is traversable that's ‘traverse’
12:19:44 <int-e> mroman: and for that particular code,  inc' n x = iterate (+1) x !! n  is also an option
12:19:55 <mroman> int-e: I know.
12:20:03 <mroman> also
12:20:58 <ParahSailin_> :t traverse
12:20:59 <lambdabot> Not in scope: `traverse'
12:21:16 <JorgeArbusto> where is hpaste hosted? Could we add a runhaskell feature?
12:21:18 <nand`> :t Data.Traversable.traverse
12:21:19 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:21:56 <n-dolio> cleantc: The other thing you're seeing is that 'T2 :: Bool -> T Bool doesn't translate into '(a ~ Bool) => a -> T a' but '(a ~ Bool) => Bool -> T a'.
12:22:57 <sp3ctum> i'm learning quickcheck and created a generator for a group of characters. how do i use this generator in a test property?
12:24:08 <sp3ctum> should i define a newType for it and use the generator as some instance?
12:25:11 <mroman> > let mul = n x = (sum $ take n $ map ($x) $ zipWith (.) (cycle [id]) (cycle [(+1)])) - n in mul 6 6
12:25:11 <lambdabot>   <no location info>: parse error on input `='
12:25:20 <JorgeArbusto> :t cycle
12:25:22 <lambdabot> forall a. [a] -> [a]
12:25:22 <mroman> > let mul n x = (sum $ take n $ map ($x) $ zipWith (.) (cycle [id]) (cycle [(+1)])) - n in mul 6 6
12:25:25 <lambdabot>   36
12:25:28 <JorgeArbusto> no parse
12:25:39 <JorgeArbusto> > cycle [1,2,3]
12:25:41 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
12:26:02 <danharaj> edwardk: Is there an operator version of `withIndex` so that I can do `foo . barTraversal `withIndex` baz without parentheses?
12:26:31 <JorgeArbusto> > let a = [1,2,3] in take (2 * length a) $ cycle a
12:26:33 <lambdabot>   [1,2,3,1,2,3]
12:26:48 * hackagebot minimorph 0.1.0.0 - English spelling functions with an emphasis on simplicity. (EricKow)
12:26:50 * hackagebot hOpenPGP 0.4 - native Haskell implementation of OpenPGP (RFC4880) (ClintAdams)
12:26:57 <ReinH> applicative_: can I ask you a couple lens questions?
12:27:06 <ReinH> in lieu of asking edwardk ;)
12:27:20 <mroman> and you can use it for abs.
12:27:27 <nand`> > let a = [1,2,3] in join . take 2 $ repeat a
12:27:29 <lambdabot>   [1,2,3,1,2,3]
12:27:31 <mroman> > let mul = n x = (sum $ take n $ map ($x) $ zipWith (.) (cycle [id]) (cycle [(+1)])) - n in [mul 3 i, mul (-3) 1]
12:27:31 <lambdabot>   <no location info>: parse error on input `='
12:27:37 <applicative_> ReinH: no,  I'm just a learner, ask  eg danharaj or nand` :)
12:27:37 <cleantc> n-dolio: is there a difference between the two?  after the first unification (for example with  b -> T b) , typechecker should generate b~Bool  and b~a , I don't see where it makes a difference
12:27:41 <mroman> > let mul n x = (sum $ take n $ map ($x) $ zipWith (.) (cycle [id]) (cycle [(+1)])) - n in [mul 3 i, mul (-3) 1]
12:27:42 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:27:43 <lambdabot>         against inferred type ...
12:27:43 <ReinH> applicative_: ok!
12:27:50 <mroman> > let mul n x = (sum $ take n $ map ($x) $ zipWith (.) (cycle [id]) (cycle [(+1)])) - n in [mul 3 1, mul (-3) 1]
12:27:52 <lambdabot>   [3,3]
12:27:55 <ReinH> danharaj, nand`: mind if I ask either of you a couple lens questions?
12:28:04 <nand`> ReinH: sure, but I'm going to sleep rather soon
12:28:14 <ReinH> nand`: I'll try to make it quick!
12:28:20 <danharaj> I most likely can't answer any since I'm working it out myself.
12:28:21 <nand`> and I'm still wrapping my head around how to used indexed traversals, if that's what you're going to ask about
12:28:24 <danharaj> You should look at the Pong example.
12:28:30 <n-dolio> cleantc: The difference is when you throw away the constraint, one is 'a -> T a' and the other is 'Bool -> T a', which explains the lazy match inferred types.
12:28:54 <ReinH> nand`: first, is there some explanation of the differences between Data.Lens, Data.Lenses, and Control.Lens somewhere?
12:29:03 <nand`> edwardk: how horrible would this syntax be? http://hpaste.org/72560
12:29:12 <ReinH> I realize it's a newish topic and some fragmentation is expected and healthy
12:29:16 <nand`> ReinH: yeah, see http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285
12:29:26 <nand`> note that Control.Lens is not in that list
12:29:38 <nand`> but it uses the ‘van laarhoven lenses’ approach mentioned in the post
12:29:48 <JoeyA> Should I, or should I not, use Num for a time interval type?  What I don't like about Num is that it requires (*), which doesn't make sense for any kind of measurement.
12:29:55 <nand`> oh, it does mention Control.Lens now; never mind
12:29:56 <ReinH> nand`: second, if I want a lens to get/set piece positions on a chess board (Board = [[Square]]), that should be trivial right?
12:29:57 <JoeyA> e.g. 30ms * 30ms
12:30:11 <nand`> ReinH: there are lenses for this already
12:30:13 <nand`> I think
12:30:17 <cleantc> n-dolio: aha , makes sense now, so lazy match throws the constraints away ?
12:30:28 <n-dolio> Apparently.
12:30:31 <EvanR> JoeyA: right, so use monoid?
12:30:40 <ReinH> nand`: a lens for [[a]] should work ofc. Any handy links?
12:30:42 <JoeyA> Well, I *do* want (-)
12:30:55 <EvanR> JoeyA: then do addInterval diffInterval
12:31:07 <EvanR> JoeyA: see also NominalDiffTime
12:31:27 <jfischoff> i don't think you can make lenses for specific elements of a list, since they will fail for []
12:31:41 <nand`> EvanR: see ‘element’
12:31:48 <JoeyA> One thing I don't like about NominalDiffTime is its inefficient representation (picoseconds as Integer)
12:31:53 <nand`>  now you can make your pos (x,y) = element x . element y
12:31:55 <nand`> or w/e
12:32:01 <EvanR> nand`: wut
12:32:01 <ReinH> nand`: third and finally, I should be able to abstract board access behind the lens so that if I later switch to an Array (possibly repa) representation for perf, I need only change the lens, right?
12:32:07 <edwardk> danharaj: not yet but i'm open to adding it
12:32:07 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:32:18 <nand`> EvanR: element :: Traversable t => Int -> Simple Lens (t a) a
12:32:19 <ReinH> nand`: ok, fourth and really finally, is it "lens" or "lense"? :p
12:32:25 <nand`> ‘lens’
12:32:29 <EvanR> nand`: im not talking about lenses
12:32:42 <nand`> sorry, I mixed up some names there
12:32:49 <nand`> ReinH wanted ‘element’
12:32:57 <n-dolio> cleantc: It can't give you the constraint, because then you could just put 'undefined' in and get back a valid constraint, since the irrefutable pattern matches. So throwing the constraint away is the only valid thing to do except blow up, I guess.
12:32:59 <ReinH> nand`: oh, thanks
12:33:01 <danharaj> edwardk: we need to add more punctuation to standard keyboards.
12:33:16 <danharaj> I suppose ^@ could do?
12:33:21 <ReinH> nand`: right, so I can have a lense using my Pos = (x,y) tuple onto my board using `element`, thanks.
12:33:27 <nand`> ReinH: ‘element’ works with all traversables, so if your array or w/e is traversable, you can use it
12:33:45 <ReinH> nand`: which lens package's `element` are you referring to?
12:33:56 <timthelion> What can you guys tell me about dependency resolution?  I have a list of values, and I want to sort them in order, such the dependencies are fulfilled. data Value = Value {valueType :: [Tok],valueName::String,valueDependencies::[String]}
12:33:56 <nand`> "lens" Control.Lens
12:34:02 <ReinH> nand`: thanks so much for your time
12:34:05 <jfischoff> edwardk: is _head really better then a partial lens?
12:34:15 <cleantc> so having a GADT pattern binding, it doesn't leak local assumptions into the body? as a result no implication constraint?
12:34:20 <timthelion> Like if I have value "foo" and it depends on "bar", then it should come after "bar" in the list...
12:34:22 <ReinH> nand`: oh, ok, really last question, is Control.Lens the package you're involved in and is it the one you would recommend?
12:34:27 <ReinH> that's really the last question I promise :)
12:34:36 <nand`> FSVO of ‘involved’, and it's the one I like most
12:34:44 <nand`> it's the one me and edwardk and others have been discussing
12:34:47 <timthelion> Do I need to write this function by myself, or does it exist somewhere?
12:34:54 <ReinH> nand`: thanks
12:34:59 <ReinH> very helpful
12:35:55 <timthelion> The function should have a type like :: Eq a=> [(a,[a])] -> Either [a] ResolutionError
12:36:56 <Saizan> timthelion: graph libs should have a topological sort function
12:36:57 <nand`> timthelion: I think I did something like this by building a heap using a custom compare function that checked whether one was in the parents of the other
12:37:03 <copumpkin> data Bool = False | True | FileNotFound ?
12:37:13 <nand`> but I'm not sure if that's the best implementation, or even a meaningful one
12:37:16 <nand`> it's just an idea I had at the time
12:37:40 <nand`> (also breakage on cyclic dependencies)
12:38:38 <timthelion> nand`: thus the Either...
12:38:51 <timthelion> Saizan: I'll look into it
12:39:11 <nand`> something based on existing theories would be better than a homegrown approach at any rate :)
12:39:23 <timthelion> nand`: that's what I figure...
12:39:28 <S11001001> I'd like to replace the venerable third boolean of FileNotFound with something more suited to the modern programmer: Success
12:39:33 <timthelion> it's gotta have been done a million times before...
12:41:16 <EvanR> copumpkin: lol
12:41:29 <ReinH> nand`: I think I'm going to have to read that SO post by edwardk about 10 times before I start groking it
12:41:35 <ReinH> but it's very thorough
12:41:48 <nand`> ReinH: be sure to check out http://comonad.com/reader/2012/mirrored-lenses/ http://r6.ca/blog/20120623T104901Z.html
12:42:19 <EvanR> False | Null | Empty | Nil | EmptyString | Zero | Undefined
12:42:19 <ReinH> nand`: I will check out any and all things you are gracious enough to link me to :)
12:44:34 <timthelion> Saizan: Thanks, it looks like Data.Graph is what I want, though much more powerfull :)
12:45:01 <timthelion> EvanR: What is the difference between Null and Nil?
12:45:46 <nand`> they're for different kinds of failures
12:45:55 <nand`> in case the programmer needs to distinguish
12:45:58 <EvanR> > fromList "Null" \ fromList "Nil"
12:46:00 <lambdabot>   <no location info>: parse error on input `\'
12:46:12 <nand`> of course, Zero will be the canonical True value
12:46:26 <EvanR> toList it
12:46:34 <EvanR> "u"
12:46:41 <Gurragchaa> is point-free something to be striven for?
12:46:43 <dmwit> ?where sicp
12:46:43 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
12:46:43 <lambdabot> classes/6.001/abelson-sussman-lectures/>
12:46:53 <timthelion> nand`: :) Nice little beurocratic "well how can there be a problem, no one is complaining!"
12:46:54 <nand`> Gurragchaa: depends highly
12:46:56 <dmwit> ?where packages
12:46:57 <lambdabot> I know nothing about packages.
12:47:08 <dmwit> Who knows where the SICP that's about cabal lives?
12:47:25 <timthelion> Gurragchaa: no, it's just a kind of bigger dick contest.
12:47:46 <EvanR> i love those
12:47:46 <nand`> I tend to go point-free as long as the resulting code is shorter and cleaner than the original
12:48:03 <timthelion> EvanR: bigger dick contests?
12:48:07 <EvanR> definitel
12:48:15 <timthelion> :D
12:49:05 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml
12:50:03 <nand`> but I won't shy away from optimizations join (f . g) since I come across it often enough to expand it to “\a -> f (g a) a”
12:50:32 <EvanR> gross
12:50:35 <nand`> for some that's too pointless :(
12:51:01 <EvanR> and yeah 0 means true pisses me off
12:51:01 <nand`> optimizations like*
12:51:04 <EvanR> to no end
12:52:22 <nand`> almost as much as 1 meaning true?
12:52:40 <EvanR> way more
12:53:18 <EvanR> 0 means true, 1 means true, false means false, and nil means false
12:53:40 <EvanR> i mean someone sat down and decided this? thought long and hard?
12:54:37 <nand`> but comparing false against 0 results in an Object
12:54:56 <shachaf> EvanR: Are you talking about Ruby?
12:55:08 <dmwit> monochrom: thanks
12:55:12 <shachaf> "everything means true except for false and nil" isn't *that* bad.
12:55:31 <EvanR> 'not that bad' is a great excuse for so many bad things
12:55:42 <EvanR> at least it doesnt try to claim its not actually bad
12:56:01 <nand`> how about ’const’ is true, and ‘const id’ is false?
12:56:20 <shachaf> I think it's better than "0 is false, 1 is true".
12:56:28 <monochrom> implicit coercing a->Bool is worse than implicit coercing Int->Double
12:56:31 <shachaf> And "[] is false, [foo] is true".
12:56:54 <EvanR> if its implemented as 0 or const or whatever and its hidden as a newtype Bool, then who cares
12:56:55 <monochrom> haha nand`++
12:57:20 <EvanR> were not talking about implementation
12:57:44 <EvanR> and i dont get the defending of bad stuff by showing how it could be worse
12:59:46 <monochrom> "these many things are false, those many things are true" is clearly worse than "0 is false, 1 is true"
13:00:14 <EvanR> C is dead
13:00:16 <EvanR> long live C
13:00:28 <ParahSailin_> first working, useful haskell program compiled!
13:00:44 <nand`> EvanR: the problem is when it's not hidden inside a newtype, but instead everything in the entire world implicitly converts to some value of True|False
13:01:16 <EvanR> nand`: well yeah
13:01:34 <nand`> and that's pretty much what this anger is about
13:01:58 <monochrom> implicit coercions are penny wise, pound foolish
13:02:30 <EvanR> nand`: i wasnt about to come out and say the only thing that should implicitly convert to true is true and false is false
13:02:33 <timthelion> Hmm, I don't get the results of topSort :(
13:02:33 <timthelion> > (\(g,v,_)->map v $ topSort g) $ graphFromEdges [(1,1,[]),(0,0,[3,2]),(2,2,[1,0]),(3,3,[1])]
13:02:35 <lambdabot>   [(0,0,[3,2]),(2,2,[1,0]),(3,3,[1]),(1,1,[])]
13:03:14 <monochrom> @type topSort
13:03:15 <lambdabot> Graph -> [Vertex]
13:03:24 <timthelion> Wait, perhaps I'm just an idiot :)
13:04:07 <monochrom> I don't even know what the graph is, so I can't help you there :)
13:04:08 <Nereid> hmm
13:04:10 <Nereid> so
13:04:38 <Nereid> hmm
13:04:52 <timthelion> > reverse $ (\(g,v,_)->map v $ topSort g) $ graphFromEdges [(1,1,[]),(0,0,[3,2]),(2,2,[1]),(3,3,[1])]
13:04:54 <lambdabot>   [(1,1,[]),(3,3,[1]),(2,2,[1]),(0,0,[3,2])]
13:05:14 <timthelion> monochrom: dependency resolution
13:05:32 <timthelion> it doesn't do any error detection though
13:05:36 <EvanR> heh dependency graph
13:05:51 <monochrom> yeah I mean the notation [(1,1,[]),(0,0,[3,2]) etc
13:06:09 <timthelion> monochrom: (value,key,[key])
13:06:35 <ReinH> What is van Laarhoven using to generate this pdf? http://twanvl.nl/blog/news/2011-05-19-lenses-talk
13:06:39 <monochrom> my idea of edge is (3,2)
13:07:04 <timthelion> monochrom: edge?
13:07:53 <roconnor> ReinH: probably the beamer module for latex
13:08:04 <ReinH> roconnor: cool, thanks!
13:08:34 <timthelion> > (\(g,v,_)->map v $ topSort g) $ graphFromEdges [(1,1,[]),(0,0,[3,2]),(2,2,[1,0]),(3,3,[1])]
13:08:36 <lambdabot>   [(0,0,[3,2]),(2,2,[1,0]),(3,3,[1]),(1,1,[])]
13:09:03 <monochrom> yeah, an edge is a pair of vertices
13:09:47 <Nereid> hmm, ghc nightlies say 7.7 now
13:09:57 <Nereid> does that mean 7.6 is coming soon? :)
13:09:59 <monochrom> edge (v, w) means an arrow pointing from v to w
13:10:29 <ReinH> ok, rabbit hole avoided, back to reading about functional references
13:10:31 <ReinH> phew
13:11:25 <Nereid> I had an idea today that some sort of indexed state monad would give a slick way of doing something like global variables
13:11:42 <Nereid> so
13:12:16 <timthelion> Nereid: WHAT THE FUCKING HELL DO YOU WANT GLOBAL VARIABLES FOR YOU GOD DAMN FOOL???
13:12:19 <Nereid> lol.
13:12:22 <timthelion> ;)
13:13:00 <Nereid> I basically mean something that gives us mutable references, except
13:13:14 <timthelion> Nereid: MVars?
13:13:23 <Nereid> no no
13:13:38 <Nereid> creating them doesn't involve any new__Var or anything
13:13:42 <Nereid> you just make a type
13:14:01 <Nereid> uh
13:14:08 <Nereid> yeah so this needs type families too.
13:14:15 <Nereid> obviously.
13:14:32 <Nereid> but the type system would prevent you from reading a variable you haven't written to yet.
13:14:54 <Nereid> this is why we need an indexed monad
13:17:06 <ReinH> Nereid: remind me why you are programming Haskell again?
13:17:19 <Nereid> what?
13:17:38 <ReinH> it just seems to me like you're trying to make it not-Haskell
13:17:49 <Nereid> is using MVar/STRef/whatever not-haskell?
13:18:00 <ReinH> like what you really want is a truck but instead you come up with crazy schemes to rip out the boot of your car and install a bed
13:18:27 <timthelion> ReinH: There is a difference, between using imutable values within algorithms, and having a mechanism for different parts of a program to comunicate between one another. :)
13:18:28 <ReinH> global state and pointers seems like a very un-haskell-like goal is all
13:18:50 <Nereid> I'm basically trying to accomplish the same thing, except the references are types, not values
13:19:08 <timthelion> Nereid: I don't understand :)
13:19:17 <johnw> I'd like to see what he comes up with first, before deciding it leads to bad programs
13:19:21 <Nereid> yeah, so I need to code up a prototype.
13:19:33 <timthelion> Nereid: get coding then :)
13:19:35 <Nereid> it's probably going to need DataKinds or so.
13:19:43 <Nereid> I will as soon as I get this ghc nightly installed ;)
13:20:05 <Nereid> I ran into lots of troubles with DataKinds on 7.4
13:20:11 <Nereid> which was to be expected
13:21:26 <Nereid> how well does DataKinds interact with data families anyway?
13:21:29 <ReinH> Nereid: I'm wondering if you just want ST?
13:21:42 <Nereid> ReinH: you're missing the point.
13:21:49 <ReinH> Nereid: that's likely :)
13:22:02 <ReinH> anyone else getting the point and would care to fill me in?
13:22:04 <johnw> it's point-free :)
13:22:19 <Nereid> oh, why am I compiling this myself, I should just get the prebuilt binary./
13:23:06 <timthelion> can we change the 80 char limit per line to 200? :D
13:23:12 <timthelion> sortedValues = map (\(n,k,ks)->Value n k ks) $ (\(g,v,_)->map v $ topSort g) $ graphFromEdges $ map (\Value valueType valueName valueDepends -> (valueType,valueName,valueDepends)) values
13:23:36 <timthelion> I must be a real haskell programmer now that I can write such garbage :D
13:24:31 <Nereid> ReinH: for some background have a look at the index-core package and uh
13:24:35 <Nereid> @google kliesli fortune
13:24:37 <lambdabot> http://irc-logs.googlecode.com/svn-history/r52/trunk/logs/freenode/haskell/2011/2011-06-25
13:24:41 <Nereid> nope.
13:25:20 <Nereid> sorry, this paper http://personal.cis.strath.ac.uk/~conor/Kleisli.pdf
13:26:17 <Nereid> the rough idea is to encode pre- and post-conditions for actions at the type level
13:26:43 <Nereid> so, in the running example of this paper, the type system prevents you from reading from a closed file handle
13:26:50 <Ralith> timthelion: (map Value) is legal
13:27:01 <Ralith> oh, you've got a 3-tuple
13:27:12 <timthelion> Nereid: I read that article, and didn't see the advantage over normal boxed types like Either for error handling.
13:27:45 <timthelion> Ralith: I just don't want to rewrite the rest of my programs to use tuples instead of Values...
13:27:45 <Nereid> timemage: the point is to move the error handling into the type level
13:27:52 <Nereid> timthelion*
13:28:11 <hpc> timthelion: it's not a tuple, it's a lifted type... thingy
13:28:12 <timthelion> Nereid: how does this help us though?
13:28:15 <Nereid> so, say, trying to read from a closed file handle results in a type error
13:28:20 <Nereid> instead of a runtime error
13:28:25 <hpc> timthelion: suppose you had
13:28:32 <hpc> newtype OpenHandle = OH Handle
13:28:54 <hpc> lost my train of thought
13:29:01 <Nereid> newtype ClosedHandle = CH Handle
13:29:06 <hpc> something like that
13:29:11 <Nereid> and uh
13:29:21 <Nereid> yeah I don't know how you'd do it without indexed monads or so
13:29:23 <hpc> but eventually you get something like hClose :: OpenHandle -> IO ClosedHandle
13:29:29 <hpc> or something
13:29:36 <hpc> and yeah, it would probably be an indexed monad
13:29:41 <Nereid> that's along the right lines
13:29:55 <Nereid> but that doesn't prevent you from keeping the OpenHandle after you run hClose
13:30:00 <hpc> but then you get the opened-ness of the handle as a type-level property
13:30:20 <timthelion> hpc: isn't that perfectly possible with normal haskell?
13:30:23 <hpc> you don't need any error handling or extra values ANYWHERE, because that information gets compiled away
13:30:26 <hpc> timthelion: it is
13:30:47 <hpc> if you assume a handle isn't a network connection that was abruptly killed
13:30:51 <hpc> or something like that
13:30:57 <hpc> but for files it mostly works
13:31:11 <timthelion> data Handle = OpenHandle foo | ClosedHandle bar
13:31:12 <hpc> (mostly meaning, "what if you have a NAS, what if you open /tcp/..., etc"
13:31:31 <timthelion> oh, I see
13:31:35 <hpc> timthelion: that makes the opened-ness into runtime information
13:31:35 * timthelion is an idiot
13:31:38 <hpc> ;)
13:31:58 <timthelion> Thanks, now I finally get it.
13:31:58 <hpc> it's not Nothing vs Just, it's () vs 'a'
13:32:03 <hpc> :D
13:32:19 <timthelion> Yeah, that's a good idea.
13:32:21 <Nereid> I think the general principle is to move as much information into type level so that more stuff can be checked at compile time.
13:32:30 <Nereid> as much information as possible
13:33:09 <timthelion> Though I'd have to say, that his code is INSANE!  I'm using a bit of her(she) in the program I'm working on now, and... OMG, his types make NO sense, and not just their names :D :D
13:33:17 <hpc> ultimately, the goal is to get from "it runs without errors, so maybe it does the right thing" to "it compiles, therefore perfection"
13:33:52 <Nereid> anyway, the nice thing about using an indexed monad is that you can use the exact same monad syntax
13:33:55 <timthelion> McBride's code that is.
13:34:03 <Nereid> and still get the extra safety
13:34:12 <Nereid> with basically no impact on the appearance of the code
13:34:16 <Nereid> except for type signatures perhaps
13:34:35 <hpc> and in haskell, you can make indexed monads work with do-notation using some NoImplicitPrelude/RebindableSyntax magic
13:34:41 <Nereid> yeah
13:34:59 <mvj4> has there been any attempts at splitting up the RealWorld/IO type into different parts, like network, file handling and so forth? could you have a network-monadic function operating running across computers? I'm not thinking about making arbitrary restrictions on top of IO.
13:35:01 <Nereid> the pipes (not pipes-core) package uses indexed monads to statically enforce things like not reading from a closed pipe or so
13:35:11 <hpc> add OverlappingInstances and maybe something else, and you can have the same (>>=) overloaded for indexed and unindexed monads
13:35:15 <Nereid> it's quite elegant
13:35:31 <Nereid> hpc: no, (>>=) would have to have a polymorphic kind
13:35:37 <timthelion> mvj4: of course, we have Reader, Writer,  BS, MoreBS, and a hole host of other monands
13:35:48 <Nereid> or so
13:35:55 <hpc> Nereid: you could do it like MonadState, et al
13:36:12 <hpc> instance IndexedMonad (IxIO i) i where ...
13:36:21 <Nereid> I don't know
13:36:22 <hpc> instance IndexedMonad (IO) i where ...
13:36:34 <hpc> except... crap
13:36:36 <Nereid> yeah
13:36:45 <hpc> you do need PolyKinds
13:36:47 <Nereid> yes
13:36:58 <Nereid> and I started throwing something together along those lines a while ago
13:36:58 <hpc> someone should do a proof of concept on that
13:37:09 <hpc> it would be neat to be able to seamlessly drop indexed monads into the standard library
13:37:11 <mvj4> timthelion: Reader/Writer/.. is still just pure code. ST is an exception. I'm talking about placing restrictions surrounding the arbitrary effects of IO.
13:37:13 <Nereid> except I got stuck in the "try to implement this in full generality" trap and then I couldn't get around various kind errors
13:37:38 <timthelion> mvj4: java? :D
13:37:39 <Nereid> but it would be easy to make it just work for Monad and IMonad.
13:38:05 <Nereid> well, after IMonad is redefined to use newtype instead of type aliases
13:38:20 <hpc> IMonad is a type class
13:38:27 <Nereid> er
13:38:27 <hpc> oh, "to use"
13:38:34 <hpc> or maybe im confused
13:38:45 <Nereid> I mean
13:38:53 <cleantc> the patterns in guard pattern are  lazy?
13:39:01 <Nereid> we have things like (?>=) :: IMonad m => m a i -> (a :-> m b) -> m b i
13:39:04 <Nereid> the problem is that
13:39:13 <Nereid> type a :-> b = forall i. a i -> b i
13:39:46 <Nereid> which creates all sorts of problems when you try to make a poly-kinded >>= or so
13:39:59 <Nereid> well, a poly-kinded Monad class.
13:40:01 <mvj4> timthelion: yeah, that kind of environment might be preferred. still seems to boil down to arbitrary design choices and guarantees made by the library designer concering what laws the restricted instance abides.
13:40:13 <Nereid> because you can't write instances for partially applied type synonyms.
13:40:47 <Nereid> defining :-> with newtype gets around that.
13:40:50 <mvj4> still I believe you could argue about non-arbitrary side effects when dealing with networking etc
13:41:10 <Nereid> although then you don't get (.) and id for free and you have to write your own Category instance.
13:41:16 <Nereid> for a poly-kinded Category class.
13:42:30 <timthelion> mvj4: I want to do it for gtk2hs, make a GTK monad.  But for quite a different reason that restricting the IO of functions that use it.  The reason I have, is that there are threading issues involved.  So we would have "runGtkIO :: GtkIO -> IO" and that would make sure we were in the gtk thread.
13:43:16 <Nereid> and, last time I tried, PolyKinds broke some other extension
13:43:24 <mvj4> yeah, I have the same problem with allowing explicit thread creation :)
13:43:29 <nh2> can I make cabal aliases like git aliases?
13:43:29 <Nereid> I forget what it was, but I considered it a bug
13:43:50 <nh2> I want cabal rebuild = cabal clean -s && cabal build
13:44:15 <hpc> Nereid: it will get easier as GHC moves closer to full dependent types
13:44:28 <Nereid> full dependent types would be cool.
13:44:48 <timthelion> mvj4: well the problem with gtk, is that gtk is single threaded and NOT thread safe, so all actions actually have to be passed to the gtk thread. if you forget BAD things happen, and they can be impossible to debug.
13:45:21 <hpc> fortunately, the way to move actions into the gtk thread is clearly documented
13:45:38 <hpc> and if you feel like it, it's fairly friendly to higher-order functions that abstract it away
13:45:41 <timthelion> hpc: Still doesn't mean that type checking doesn't help you.
13:45:44 <mvj4> timthelion: ah, I see.
13:46:05 <timthelion> or maybe my double negative was incorect there?
13:46:12 <mvj4> nh2: you could do that with shell support (e.g. bash: alias="cabal...")
13:46:16 <timthelion> Still doesn't mean that type checking helps you.
13:46:38 <nh2> mvj4: that's what I'm doing currently, but I have to call it "cabalrebuild"
13:46:54 <Nereid> actually, the part I want to do right now probably works in 7.4
13:51:54 * hackagebot irc 0.5.1.0 - A small library for parsing IRC messages. (TrevorElliott)
13:54:06 <bobomanzz> hello haskell
13:54:40 <applicative_> hello bobomanzz , what are your expected and intended types?
13:55:37 <bobomanzz> applicative_:  ♀
13:55:53 <applicative_> or rather , what are your expected and actual types, as ghc now says
13:55:53 <osfameron> it's Mr Punch!
13:56:34 <bobomanzz> applicative_: I'm a ♂  and my prefered types are ♀
13:57:01 <applicative_> bobomanzz: our type system is a little more complicated; I recommend another programming language
13:57:52 <osfameron> well, gender itself is more complicated than:  data Gender = Male | Female;
13:58:25 <Taslem> I'm working from Windows, and relatively ignorant of command line programming. How can I set the default flags for GHCi?
13:58:25 <lambdabot> Taslem: You have 1 new message. '/msg lambdabot @messages' to read it.
13:58:36 <osfameron> according to both my A-Level psychology textbook, and the dreamwidth gender text field...
13:58:55 <Athas> osfameron: yes, so use data Sex instead!
13:59:03 <Nereid> hmm, I guess I do have to build the nightly from source :s
13:59:20 <osfameron> Athas: doesn't that just have a single constructor calles YesPlease? ;-)
13:59:24 <osfameron> *called
14:01:04 <bobomanzz> may I have a serious discussion with an op ? cause I've been banned here. Ok, I agree it was because I was trolling but uh...
14:01:08 <applicative_> Taslem in unixy things there is a hidden configuration file .ghci
14:01:09 <bobomanzz> I'd like to be unbanned..
14:01:16 <bobomanzz> so I thought I could discuss this with an op
14:01:17 <hpc> bobomanzz: #haskell-ops
14:01:18 <Saizan> Taslem: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
14:01:23 <hpc> and leave here, so you don't get nailed for ban evasion
14:01:31 <bobomanzz> ok
14:01:35 <applicative_> is #haskell-ops like the principal's office?
14:02:14 <applicative_> Taslem: ah I see, Saizan has found it
14:02:19 <Taslem> Thanks.
14:02:20 * osfameron wonders how bobomanzz was able to talk if banned
14:03:02 <Clint> magic
14:03:22 <Nereid> @pl \f -> j `c` m f
14:03:22 <lambdabot> (j `c`) . m
14:20:27 <otters> RebindableSyntax is scary
14:20:34 <dottedmag> :ghci says for :info Applicative: instance Applicative Maybe -- Defined in `Control.Applicative'
14:20:41 <dottedmag> How do I get a definition of this instance from ghci?
14:21:04 <dottedmag> Tried :browse Control.Applicative, no luck
14:21:12 <shachaf> dottedmag: You don't.
14:21:22 <c_wraith> dottedmag: ghci doesn't have that available.  It only has symbols and compiled object code, not source
14:21:40 <dottedmag> Got it, thansk.
14:21:42 <dottedmag> *ks
14:21:47 --- mode: ChanServ set +o monochrom
14:21:49 --- mode: monochrom set -b $a:spetrea-home
14:21:55 --- mode: monochrom set -o monochrom
14:23:54 <applicative_> c_wraith: if you import Control.Applicative,  :i Applicative will tell you the 'methods'
14:24:10 <copumpkin> :i Applicative
14:24:22 * copumpkin stares expectantly at applicative_ 
14:24:25 <applicative_> or rather dottedmag  if you import Control.Applicative,  :i Applicative will tell you the 'methods'
14:24:39 <applicative_> class Functor f => Applicative f where   pure :: a -> f a   (<*>) :: f (a -> b) -> f a -> f b   (*>) :: f a -> f b -> f b   (<*) :: f a -> f b -> f a
14:25:03 <c_wraith> that's the definition of the class, not of the instance
14:25:40 <applicative_> yes, I see that, that he wanted that, is entailed by what he said
14:26:12 <applicative_> anyway, there's surely only one serious possibility.....
14:26:51 <applicative_> pure = Just; Nothing <*> _ = Nothing; etc.
14:27:33 <applicative_> so dottedmag just as #haskell and they'll make something up for you....
14:28:27 <dottedmag> :)
14:28:52 <applicative_> maybe there should be a :haskell-irc plugin for ghci, so any user can type irate questions into the repl, and maybe get an answer
14:29:07 <applicative_> like the link to #haskell on Try Haskell
14:29:25 <dottedmag> applicative_: Actually I needed the definition of instance, not of the class, but thanks anyway.
14:30:09 <dottedmag> And not only for Applicative Maybe.
14:30:20 <applicative_> dottedmag: yes i realized that later; I was struck that what you did didnt give the methods, since Control.Applicative wasnt in scope, and this then misled me
14:31:49 <applicative_> dottedmag: you probably have the docs on your system but the main ones are easily visible here http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html
14:32:37 <dottedmag> applicative_: do you know is it linked from hoogle results?
14:33:14 <applicative_> notice that a lot of them take the low road of using pure = return ; (<*>) = ap, so actually seeing the implementation wouldn't tell you much....
14:33:15 <dottedmag> Ah, missed "source" links there.
14:34:19 <applicative_> everyone 'knows' it should be 'return = pure' instead.
14:34:38 <dottedmag> Well, legacy is so legacy.
14:35:55 <Nereid> man, this was easier in windows, I could just download the nightly binary and it would work. :s
14:36:17 <EvanR> haha low road
14:36:26 <EvanR> :t ap
14:36:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:36:30 <Nereid> I got the linux binary and then got some missing .so error and then I gave up.
14:36:34 <latro`a> incidentally, why does instance Foo a => Bar a where ... magically force the type system to be turing complete to work?
14:36:34 <Nereid> so I'm compiling it from source.
14:36:57 <EvanR> @src ap
14:36:57 <lambdabot> ap = liftM2 id
14:37:19 <Nereid> where id = ($)
14:37:22 <ParahSailin_> i sure get some big binaries for some trivial tasks
14:37:33 <monochrom> pretty sure there is an opposite scenerio where it's hassleless on linux and "missing .dll" on windows
14:37:33 <dottedmag> I wonder is there a generalization of applicative functors with analogue of <*> operator :: f (a -> b) -> g a -> g b
14:37:55 <latro`a> that sounds like it would require a functor from f to g
14:38:00 <latro`a> or an almost-functor from f to g
14:38:16 <Nereid> you mean natural transformation
14:38:30 <latro`a> wouldn't necessarily have to be natural
14:38:35 <latro`a> iirc
14:38:48 <Nereid> say we had that
14:38:53 <Nereid> then you'd get f a -> g a
14:39:00 <Nereid> so
14:39:10 <Nereid> say we had that <*>
14:39:11 <latro`a> you'd also have f (a->b) -> g (a->b)
14:39:20 <latro`a> so you'd be able to just compose that with g's <*>, if it had one
14:39:24 <Nereid> yes, now take a = (), and then () -> b ~= b
14:40:00 <Nereid> wait, how would you get g (a -> b)
14:40:17 <latro`a> because a is arbitrary?
14:40:26 <latro`a> f a -> g a; let a = b->c
14:40:35 <latro`a> forall a is big :p
14:40:38 <Nereid> from f a -> g a, obviously.
14:40:45 <dottedmag> I had in mind (Just id) <*?> [1, 2, 3] => [1, 2, 3], but then transformation Just x = [x]; Nothing = []
14:40:47 <Nereid> so let's implement that.
14:40:55 <Nereid> so, given x :: f a, we have
14:41:02 <Nereid> er
14:41:12 <latro`a> dottedmag: yeah that's what we have been describing
14:41:24 <latro`a> that's <*> . maybeToList
14:41:28 <latro`a> almost
14:41:33 --- mode: ChanServ set +o mauke
14:41:34 --- mode: mauke set +b $a:spetrea-home
14:41:38 <latro`a> actually it's <*> . pure . maybeToList
14:41:40 <Nereid> fmap const ::  f a -> f (() -> a)
14:41:43 <latro`a> or
14:41:44 <latro`a> something
14:41:49 <Nereid> (<*>) :: f (() -> a) -> g () -> g a
14:42:04 <latro`a> not really pure, but close-ish
14:42:22 <Nereid> hmm.
14:42:44 <Nereid> now we still need a g ()
14:43:23 <latro`a> pure' [] = []; pure' (x:_) = repeat x
14:43:30 <latro`a> is the "pure" I meant
14:43:31 <Nereid> and there is no reason we could get one
14:43:34 --- mode: mauke set -o mauke
14:44:13 <Nereid> hmm, no reason we need ()
14:44:17 <Nereid> we could take (b -> b)
14:47:37 <Nereid> no wait nm
14:47:52 <Nereid> yeah, we can't construct such a thing.
14:47:55 <Nereid> after all, we could take g a = Void
14:48:06 <dottedmag> In general case, no.
14:48:19 <Nereid> true.
14:48:20 <dottedmag> That is, what would be [id] <?*> Just 1?
14:48:52 <Nereid> right, we'd need some restriction on f and g.
14:48:56 <dottedmag> I just wondered maybe there is already typeclass for it.
14:48:58 <Nereid> like a 2-parameter typeclass.
14:49:40 <Nereid> I don't like it.
14:50:19 <Nereid> in Applicative, (<*>) could just as well be replaced by f a -> f b -> f (a,b)
14:50:30 <Nereid> (which is liftA2 (,))
14:50:45 <Nereid> hmm
14:51:01 <Nereid> maybe it makes sense.
14:51:16 <Nereid> like having your proposed <*> means there's an action of f on g, or something vague like that
14:52:23 <dottedmag> Probably it's just equivalent to having a natural transformation from f to g.
14:52:27 <Nereid> no.
14:53:00 <Nereid> what would f a -> g b -> g (a,b) look like?
14:53:33 <dottedmag> liftA2 (,) . transform ?
14:53:41 <Nereid> no I mean what would it mean
14:54:06 <Nereid> also
14:54:08 <Nereid> why not generalize?
14:54:13 <Nereid> f a -> g b -> h (a,b)
14:54:44 <Nereid> (equivalently, f (a -> b) -> g a -> h b)
14:56:59 <JorgeArbusto> > concat ["q","u","i","t"]
14:57:01 <lambdabot>   "quit"
14:57:20 <JorgeArbusto> > catMaybe [Just 5,Nothing]
14:57:21 <lambdabot>   Not in scope: `catMaybe'
14:57:26 <JorgeArbusto> > catMaybes [Just 5,Nothing]
14:57:27 <lambdabot>   [5]
14:57:47 <JorgeArbusto> :t catMaybes
14:57:48 <lambdabot> forall a. [Maybe a] -> [a]
14:57:53 <latro`a> huh, you're right: <*> = \fs xs -> fmap (\(f,x) -> f x) $ liftA2 fs xs
14:57:54 --- mode: ChanServ set +o mauke
14:57:54 --- mode: mauke set +b *!*@188.26.210.56
14:57:55 <latro`a> erm
14:58:00 <latro`a> *liftA2 (,) fs xs
14:58:02 <latro`a> interesting
14:58:44 <JorgeArbusto> catMaybes is unsafe?
14:58:53 <latro`a> erm
14:58:56 <latro`a> what do you mean by unsafe
14:59:26 <latro`a> catMaybes is a total function, if that's your question
14:59:54 --- mode: mauke set -o mauke
14:59:57 <donri> > Data.Foldable.concat [Just 5,Nothing]
14:59:58 <lambdabot>   Couldn't match expected type `[a]'
14:59:58 <lambdabot>         against inferred type `Data.Mayb...
15:01:17 <JorgeArbusto> total?
15:01:24 <donri> > Data.Foldable.asum [Just 5,Nothing]
15:01:25 <lambdabot>   Just 5
15:03:32 <mroman> > fmap (+3) (Left 5)
15:03:33 <lambdabot>   Left 5
15:03:39 <mroman> > fmap (+3) (Right 5)
15:03:40 <lambdabot>   Right 8
15:03:42 <latro`a> a total function has a return value for all its inputs
15:03:59 <latro`a> head is an example of a partial function
15:04:14 <Mortchek> > head []
15:04:15 <lambdabot>   *Exception: Prelude.head: empty list
15:04:16 <JorgeArbusto> i see
15:04:25 <JorgeArbusto> yeah i just implemented catMaybes
15:04:32 <EvanR> head has a return
15:04:35 <EvanR> _|_
15:04:36 <JorgeArbusto> first wondered if it needed fromJust
15:04:37 <EvanR> ;)
15:04:37 <donri> JorgeArbusto: so what did you mean by unsafe? curious
15:04:38 <latro`a> eh
15:04:47 <donri> oh, nope
15:04:50 <latro`a> has a non-bottom return, is what I meant
15:04:57 <latro`a> oh, nope
15:04:59 <latro`a> no fromJust
15:05:02 <donri> > mapMaybe [Just 5, Nothing]
15:05:03 <lambdabot>   Couldn't match expected type `a -> Data.Maybe.Maybe b'
15:05:03 <lambdabot>         against infe...
15:05:15 <latro`a> you can do catMaybes with just pattern matching
15:05:23 <donri> > mapMaybe id [Just 5, Nothing]
15:05:24 <lambdabot>   [5]
15:05:57 <latro`a> no isJust required either
15:06:19 <donri> catMaybes = mapMaybe id  -- ;)
15:06:28 <latro`a> indeed
15:06:50 <JorgeArbusto> :t mapMaybe
15:06:52 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
15:07:05 <donri> :t mapMaybe id
15:07:06 <lambdabot> forall b. [Maybe b] -> [b]
15:08:22 <donri> hackage should have an automatic ranking system based on number of partial functions used in a package ^_^
15:08:30 <latro`a> lol
15:08:57 <latro`a> a useful article, JorgeArbusto
15:09:04 <latro`a> http://www.haskell.org/haskellwiki/Avoiding_partial_functions
15:09:18 <dfeuer> How can I efficiently do something like list1 = [a | a<-foo, b<-bar, other stuff, a==b]   list2 = [a | a<-foo, b<-bar, other stuff, a/=b] ?
15:09:33 <latro`a> though some of the examples (such as the first one) can be replaced with builtin functions (like maybe, with a lowercase)
15:10:29 <donri> latro`a: (it's a wiki)
15:10:30 <hpc> latro`a: you can do it in one pass with list = [(a, a == b) | a <- foo, b <- bar, ..., a == b]
15:10:33 <hpc> er
15:10:36 <hpc> latro`a: you can do it in one pass with list = [(a, a == b) | a <- foo, b <- bar, ...]
15:10:46 <hpc> leave the condition out, do no filtering
15:10:55 <latro`a> I didn't ask
15:10:59 <donri> although i'd suggest keeping the examples and adding more, more beginner friendly
15:11:00 <hpc> oh
15:11:05 <hpc> dfeuer: what i said above
15:11:50 <dfeuer> hpc, I currently do it like that, but then I need to sort the thing,
15:11:52 <enigmuriatic> did anyone else here have ghci break when they updated OSX to mountain lion?
15:11:56 <dfeuer> and the sorting is taking too long,
15:12:13 <dfeuer> (using sortBy (comparing fst) )
15:12:15 <dottedmag> enigmuriatic: missing gcc?
15:12:25 <enigmuriatic> dottedmag: yup
15:12:30 <dfeuer> so I'm a-thinkin' if I filter that might speed up the sort.....
15:12:35 <dottedmag> enigmuriatic: just install "command-line tools" from XCode again.
15:13:05 <enigmuriatic> i was haivng trouble finding it for some reason. is that in the app store?
15:13:09 * dottedmag .oO(I miss apt-get on this system)
15:13:11 <hpc> dfeuer: yeah, you would get both lists out of that common list to reduce it to one pass
15:13:12 <dottedmag> enigmuriatic: yes
15:13:38 <dfeuer> hpc, huh?
15:13:42 <hpc> dfeuer: specifically with something like let (list1, list2) = something something list
15:13:56 <hpc> then sort list1 and list2 individually
15:14:09 <enigmuriatic> dottedmag: where exactly is it located? i can't find it
15:14:15 <dfeuer> hpc, if I start with the list of (a, a==b),
15:14:24 <dottedmag> enigmuriatic: ehm, I just searched for "xcode" in the search field
15:14:24 <dfeuer> you want me to separate them how?
15:14:37 <hpc> that i am too sleepy to answer
15:14:41 <hpc> ;)
15:14:56 <enigmuriatic> it says xcode is already installed tho :/
15:15:32 <dottedmag> enigmuriatic: ah. Open it, Preferences -> Downloads -> Components -> Command Line Tools.
15:15:42 <enigmuriatic> ah, there we go :P
15:15:44 <enigmuriatic> thanks :D
15:16:10 <dottedmag> welcome. I had to figure it out a few hours ago :)
15:16:25 <JorgeArbusto> catEither
15:16:26 <JorgeArbusto> catEithers
15:16:31 <JorgeArbusto> :t catEithers
15:16:32 <lambdabot> Not in scope: `catEithers'
15:16:48 <EvanR> there would be two catEithers
15:17:12 <EvanR> or just splitEithers :: [Either a b] -> [a] -> [b]
15:17:18 <EvanR> er
15:17:22 <donri> :t partitionEithers
15:17:23 <lambdabot> forall a b. [Either a b] -> ([a], [b])
15:17:29 <JorgeArbusto> > case Left 5 of Left 5 -> 5; Left _ -> 7
15:17:31 <EvanR> partitionEithers
15:17:31 <lambdabot>   5
15:17:34 <hpc> :t partition
15:17:35 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:17:35 <donri> :t rights
15:17:36 <lambdabot> forall a b. [Either a b] -> [b]
15:17:38 <donri> that's like catMaybes
15:17:39 <hpc> oh cool
15:17:39 <JorgeArbusto> > case Left 5 of Left 5 -> 5.1; Left _ -> 7.5
15:17:41 <lambdabot>   5.1
15:17:43 <shachaf> partitionEithers :: [Either a b] -> ([a] -> [b] -> r) -> r
15:17:52 <JorgeArbusto> > case Lefta 5 of Lefta 5 -> 5.1; Lefta _ -> 7.5
15:17:53 <lambdabot>   Not in scope: data constructor `Lefta'Not in scope: data constructor `Lefta...
15:20:07 <dottedmag> Is newtype an optimization or is it useful somewhere where data with single constructor and single field isn't?
15:20:12 <JorgeArbusto> I'm sorry about Guantanomo.
15:21:37 <latro`a> partitionEithers is interesting
15:21:47 <latro`a> easy to write, but might have some applications
15:21:57 <donri> latro`a: also "lefts" and "rights"
15:22:00 <c_wraith> dottedmag: it has slightly different semantics sometimes.  In particular, a pattern match against a newtype constructor doesn't force *any* evaluation, so it can help things remain lazier than you'd get without an irrefutable match on a data constructor
15:22:00 <latro`a> dottedmag, newtype allows for some optimizations that data doesn't
15:22:22 <latro`a> ah yes, that too
15:23:16 <dottedmag> Reading http://www.haskell.org/haskellwiki/Newtype -- so, unlifted _|_ is the main reason, right?
15:23:45 <dottedmag> Well, beside being faster/using less memory
15:24:36 <n-dolio> The main reason is to be optimized.
15:25:29 <donri> > case undefined of Just x -> ()
15:25:30 <lambdabot>   *Exception: Prelude.undefined
15:25:37 <donri> > case undefined of Const x -> ()
15:25:38 <lambdabot>   ()
15:25:42 <latro`a> huh
15:25:44 <donri> Just is a data, Const a newtype
15:25:46 <latro`a> neat
15:26:17 <c_wraith> > case undefined of ~(Just x) -> ()
15:26:18 <lambdabot>   ()
15:26:34 <c_wraith> newtype constructors automatically have irrefutable semantics
15:27:46 <dottedmag> Let me sum it up: newtype has a slightly different semantics from corresponding data declaration primarily because it allows to optimize better, and not due to be useful in another situations than data. Is that correct?
15:28:25 <dottedmag> (sorry for poor grammar, not sure how to make it more clear)
15:29:22 <latro`a> most of the time, the point is to perform the optimization; in circumstances involving lazy/strict evaluation of undefined, newtype's semantics are automatically lazier
15:29:48 <n-dolio> It's mainly that you want to distinguish between T and NT as types, while having the same representation.
15:30:18 <levi> 'newtype' is somewhere between 'type' and 'data'.  It's kind of like both of them, but in different ways.
15:30:26 <donri> newtypes are just for the type checker and stripped out from compilation
15:31:22 <Nereid> newtype and data do have different semantics though
15:31:39 <levi> 'type' makes a type alias, which mostly has the effect of cleaning up the type signature. 'newtype' does the same, but also makes it a distinct type according to the type system.
15:31:56 <donri> > case undefined of x -> ()
15:31:56 <n-dolio> Sometimes there are things that you have to make into datatypes (just an alias won't work), and newtype won't have overhead.
15:31:57 <lambdabot>   ()
15:32:12 <n-dolio> Like 'newtype State s a = State (s -> (s, a))
15:32:28 <n-dolio> If you want to partially apply 'State s' for instance.
15:32:43 <dottedmag> Why newtype was added in first place? To optimize the common case where single-constructor-data was used to create a separate type?
15:32:55 <dottedmag> I suppose it came after data :)
15:33:09 <levi> You also can't make class instances based on type aliases.
15:33:40 <donri> you can with extensions, but often a newtype is better
15:34:21 <levi> They're for when you are happy with an existing type's representation, but you need a new type for other reasons.
15:34:46 <n-dolio> Extensions only allow you to declare instances for aliases that you could have declared anyway for the underlying type.
15:34:55 <latro`a> hence the name, I suppose
15:34:57 <donri> also nice is you can derive arbitrary instances from the oldtype with GeneralizedNewtypeDeriving
15:35:04 <latro`a> you have a new type but you don't have new data
15:35:31 <EvanR> -XMassivelyMultiplayerOnlineRPGDeriving
15:35:39 <EvanR> should exist
15:35:47 <donri> yea it's perhaps the worst named extension :p
15:35:49 <S11001001> EvanR: what would it do?
15:35:54 <donri> NewtypeDeriving would have sufficed
15:36:19 <EvanR> S11001001: implements the boilerplate necessary for an MMO
15:36:28 <donri> also we have MultiParameterTypeClasses but GADTs
15:36:36 <donri> like hello, consistency!?
15:36:49 <S11001001> maybe it's to encourage/discourage use of particular extensions
15:37:00 <donri> S11001001: ah, it's a conspiracy!
15:37:01 <ReinH> current status: attempting to `cabal install lens`
15:37:22 <ReinH> this should be interesting
15:38:10 <ReinH> sigh... hidden packages
15:38:42 <JorgeArbusto> i like $
15:38:46 <JorgeArbusto> :t ($)
15:38:47 <lambdabot> forall a b. (a -> b) -> a -> b
15:39:10 <JorgeArbusto> > ($) (+1) 5
15:39:11 <lambdabot>   6
15:39:16 <Nereid> > id (+1) 5
15:39:17 <lambdabot>   6
15:39:20 <JorgeArbusto> > (+1) 5
15:39:22 <lambdabot>   6
15:39:27 <JorgeArbusto> @src ($)
15:39:28 <lambdabot> f $ x = f x
15:39:32 <Nereid> ($) = id
15:39:51 <JorgeArbusto> so how does that work?
15:39:57 <EvanR> @src ($)
15:39:58 <lambdabot> f $ x = f x
15:40:01 <EvanR> oh
15:40:03 <JorgeArbusto> > (+1) id 5
15:40:04 <lambdabot>   6
15:40:11 <JorgeArbusto> > (+1) $ 5
15:40:12 <lambdabot>   6
15:40:19 <EvanR> > (+1) `id` 5
15:40:21 <lambdabot>   6
15:40:23 <JorgeArbusto> > (+1) $ 5 + 3
15:40:25 <lambdabot>   9
15:40:28 <JorgeArbusto> > (+1) id 5 + 3
15:40:30 <lambdabot>   9
15:40:40 <EvanR> you can remove any occurance of id
15:40:44 <hpc> the reason that "(+1) id 5" works is because lambdabot is strange
15:40:45 <EvanR> > (+1) 5
15:40:46 <lambdabot>   6
15:40:54 <Nereid> > 7 + 5 id 8 ($) "hello"
15:40:55 <lambdabot>   12
15:41:36 <hpc> you should run it in ghci to see that id and $ parse differently
15:41:45 <Nereid> > ($) 5
15:41:47 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
15:41:47 <lambdabot>    arising from a use of `...
15:42:05 <EvanR> :t ($)
15:42:06 <hpc> but other than ($) being infix, they are the same
15:42:07 <lambdabot> forall a b. (a -> b) -> a -> b
15:42:08 <EvanR> :t id
15:42:09 <lambdabot> forall a. a -> a
15:42:17 <hpc> (and the constrained type...)
15:44:32 <ReinH> Am I dumb or does Control.Lens not define 'element' for lists?
15:45:42 <hpc> @hoogle element
15:45:42 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects ElementArrayBuffer :: BufferTarget
15:45:42 <lambdabot> Test.QuickCheck.Gen elements :: [a] -> Gen a
15:45:43 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
15:46:10 <donri> ReinH: it's generalized to Traversable which has a list instance
15:46:12 <hpc> that seems like something it ought to have
15:46:18 <ReinH> donri: oh!
15:46:31 <timthelion> Too bad we can't do (1,2)==(1,_)
15:55:51 <t7> anyone using haskell-platform on arm (spec. raspberry pi)
15:56:03 <hpc> t7: probably
15:59:37 <t7> report in all those who have used used haskell on RPi
16:00:53 <t7> not all at once
16:01:28 <gwern> t7: what is an RPi anyway?
16:01:41 <hpc> @google raspberry pi
16:01:43 <lambdabot> http://www.raspberrypi.org/
16:01:43 <lambdabot> Title: Raspberry Pi | An ARM GNU/Linux box for $25. Take a byte!
16:01:51 <gwern> oh
16:03:08 <Liskni_si> Does N900 count?
16:04:38 <Ralith> t7: I might give it a go when mine shows up in a week or so
16:05:36 <t7> Liskni_si: does it work :)
16:05:55 <Liskni_si> t7: Sure. :-)
16:07:28 <roconnor> t7: hi
16:07:37 <JorgeArbusto> list comprehensiosn are syntax not functions right?
16:07:41 <t7> hey
16:07:49 <sipa> yes, syntactic sugar
16:07:53 <roconnor> t7: did you manage to darcs get purecoin?
16:08:07 <donri> JorgeArbusto: you can generalize them to any monad though with -XMonadComprehensions
16:08:10 <t7> oo not yet
16:08:29 <JorgeArbusto> t7: i was thinking about that, getting a beagle or rpi
16:09:13 <t7> roconnor: can i have the url again please
16:09:23 <roconnor> t7: darcs get http://r6.ca/Purecoin
16:09:30 <roconnor> nand` said it worked for him
16:17:16 <sm> works for me
16:24:24 <nobdraisentone> I've installed and registered some package via cabal, but I cannot load a module from it. What should I check first?
16:24:36 <latro`a> does it export the module?
16:24:49 <mauke> nobdraisentone: define "cannot"
16:24:51 <latro`a> (probably yes, but always worth asking)
16:25:27 <nobdraisentone> mauke: `:m + ModuleName' failed
16:25:34 <mauke> nobdraisentone: define "failed"
16:26:12 <nobdraisentone> mauke: Could not find module
16:26:45 <mauke> what module is it?
16:26:45 <t7> roconnor: works thanks :)
16:27:45 <nobdraisentone> mauke: Network.Lastfm from liblastfm
16:28:57 <nobdraisentone> `ghc-pkg describe liblastfm' said that it's installed
16:32:30 <t7> @hoogle (<+>)
16:32:31 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
16:32:31 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
16:32:32 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
16:33:13 <t7> roconnor: what is <+> on points?
16:33:44 <t7> (is the dsa code)
16:34:35 <sipa> t7: adding them, i suppose
16:34:48 <t7> lol yes but i cant see where its defined
16:34:59 <t7> is it a infix for something else?
16:35:07 <t7> like <$> can be fmap
16:35:17 <sipa> it can be, but doesn't have to be
16:35:38 <sipa> infix operators are just functions, only they are written infix instead of prefix
16:35:53 <t7> what makes you think i dont know that? :p
16:36:05 <sipa> the fact that you ask whether it's like fmap
16:36:30 <t7> well i dont know all the type classes and their infix operators, true
16:37:16 <sipa> <+> is not an operator that is defined by default
16:37:23 <sipa> :t (<+>)
16:37:24 <lambdabot>     Ambiguous occurrence `<+>'
16:37:24 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
16:37:24 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
16:37:37 <sipa> hmm
16:38:44 <sm> nobdraisentone: works for me. Are your ghci and ghc-pkg from the same installation ? (check --version on both). Or, maybe you have a strange .ghci file or GHC-related env vars ?
16:39:58 <roconnor> t7: <+> is the group operation for elliptic curves
16:43:45 <k0001> Wasn't there a 〈[| f a b |]〉 or similar syntax for 〈f <$> a <*> b〉? I think I've seen that somewhere, but I can't seem to find it online.
16:43:47 <JorgeArbusto> t7: you gonna buy a rasbperryPI`
16:43:56 <t7> i have one
16:44:06 <t7> just set it up as a little webserver :)
16:44:06 <geekosaur> k0001, idiom brackets
16:44:26 <t7> http://www.tomcumming.co.uk/
16:44:31 <geekosaur> I don;t think idiom brackets are implemented in ghc although they're available in SHE
16:44:58 <ReinH> nand`: so if I want a lens into a point in a 2 dimensional array, I should be able to compose ix somehow right?
16:46:04 <Saizan> k0001: (| f a b |), the SHE preprocessor implements it
16:47:33 <k0001> geekosaur Saizan thanks! I wasn't aware of SHE :)
16:48:10 <geekosaur> anyway if you search for "idiom brackets" you can find more about it
16:48:32 <k0001> geekosaur: yes, I'm reading that now. Thanks.
16:49:30 <roconnor> k0001: http://www.haskell.org/haskellwiki/Idiom_brackets
16:49:41 <roconnor> iI f a b Ii
16:55:30 <k0001> roconnor: thanks.
17:01:05 <morel> Are there Haskell bindings to XCB?
17:03:31 <geekosaur> HCB on Hackage
17:03:36 <geekosaur> er, XHB
17:04:28 <morel> geekosaur: Thank you! :)
17:33:16 <Luke> hey
17:33:21 <irene-knapp> indeed
17:39:13 <irene-knapp> Benjamin Pierce has two books - Types and Programming Languages, and Advanced Topics in same
17:40:05 <wagle> dont forget his category thery book..  8)
17:40:30 <irene-knapp> okay hehe
17:41:10 <irene-knapp> <irene-knapp> Benjamin Pierce has two books - Types and Programming Languages, and Advanced Topics in same
17:42:45 <Y0Gi> hi. is there a way to define a data type that contains (primitive) values itself? something like this: data Color = Red 255 0 0 | Green 0 255 0 | Blue 0 0 255
17:43:13 <irene-knapp> not exactly, no, but what are you trying to achieve?
17:43:26 <wagle> red = color 255 0 0
17:43:35 <irene-knapp> you could have a function Color -> (Int, Int, Int) or whatever
17:43:51 <irene-knapp> but it depends on why you want it
17:43:58 <Y0Gi> yeah, I could "bolt" the values to the data types later on
17:44:45 <wagle> is there an unsigned byte type in haskell?
17:44:48 <Y0Gi> but I'd prefer to have data types and their different values (say, an RGB tuple, and a string representation) in the same place
17:44:57 <MostAwesomeDude> wagle: Yes, in Data.Word there is Word8.
17:45:08 <Y0Gi> just defining some functions and using them as values feels weird to me
17:45:23 <Y0Gi> data types feel more ... robust
17:45:27 <MostAwesomeDude> > (0x2 :: Word8) + (0xff :: Word8)
17:45:28 <lambdabot>   1
17:45:55 <wagle> data Color = Color Word8 Word8 Word8
17:46:05 <Y0Gi> what I'm thinking of is like this:
17:46:08 <wagle> red = Color 255 0  0
17:46:39 <wagle> ...
17:46:41 <Y0Gi> data Color = rgbTuple name
17:47:06 <Y0Gi> data Color = Red (255, 0, 0) "red" | Green (0, 255, 0) "green" | ...
17:47:16 <Y0Gi> or so. "nested data types", if you will
17:47:44 <MostAwesomeDude> data Color = Color (Word8, Word8, Word8) String
17:47:49 <Y0Gi> wagle: hmm. yeah. would "red" be something one would export from a module as a constant?
17:47:54 <MostAwesomeDude> red = Color (255, 0, 0) "red"
17:48:10 <MostAwesomeDude> pink = Color (255, 127, 127) "pink"
17:48:47 <Y0Gi> I also miss that those values (red, pink, ...) are not in a (closed) group like a data type
17:48:47 <wagle> data ColorList = ...
17:49:06 <Y0Gi> wagle: data ColorList = red | pink | ...?
17:49:11 <Y0Gi> would that work?
17:49:26 <MostAwesomeDude> You could do: data Color = Red | Pink | Green | Mauve | ...
17:49:37 <MostAwesomeDude> It depends on what you're gonna do with them.
17:50:01 <Y0Gi> MostAwesomeDude: how would those be related to RGB tuple and name, then?
17:50:03 <wagle> capitalization is important in haskell
17:50:11 <MostAwesomeDude> Y0Gi: However you like!
17:51:25 <wagle> invent a way, and refactor when you come up with a better way
17:51:30 <MostAwesomeDude> Y0Gi: You could define a function like: type Rgb = (Word8, Word8, Word8); colorRgb :: Color -> Rgb; colorRgb Red = (255, 0, 0); -- and so forth.
17:51:31 <Y0Gi> well, basically I think I want both `data Color = Red | ...` as well as `data Color = Color (Word8, Word8, Word8) String)` - one to define the color type, and the other to create color (in Java speak) "enums"
17:51:57 <MostAwesomeDude> There *is* a typeclass for enums, called Enum.
17:52:04 * hackagebot Pup-Events-Server 1.1 - A networked event handling framework for hooking  into other programs. (DanielWilson)
17:52:08 <MostAwesomeDude> But it doesn't really make sense here.
17:52:44 <Y0Gi> I'm uncomfortable with defining color constants as functions
17:52:45 <wagle> association list might be handy for mapping color name to rgb values
17:53:24 <MostAwesomeDude> Y0Gi: Why? It's not like they're gonna change.
17:53:52 <MostAwesomeDude> You could build a Map instead, I suppose.
17:53:58 <Y0Gi> MostAwesomeDude: I guess because they don't look like constants. I'd expect those to start with an uppercase letter.
17:54:16 <hpaste> enigmuriatic pasted “Sudoku” at http://hpaste.org/72568
17:54:20 <Y0Gi> a map would still be different to a data type
17:54:31 <enigmuriatic> what about that isn't valid?
17:54:32 <MostAwesomeDude> Y0Gi: In Haskell, lowercase first letters are for functions and values and variables, and uppercase letters are for types and constructors.
17:54:37 <Y0Gi> though I guess some `newtype`s could hide that
17:54:41 <enigmuriatic> it's something about the way i'm declaring myBoard
17:55:00 <MostAwesomeDude> Y0Gi: Well, a Map is a type, and a Map of Colors to Rgbs would be a type as well.
17:55:07 <Y0Gi> MostAwesomeDude: in that case, I could really go with the functions.
17:56:06 <Y0Gi> is there a module (in the stdlib) that exposes a bunch of constants, math-related or whatever, in whose source I can take a look to get a feel for that?
17:56:33 <xplat> @tell edwardk clearly Semimonad/Bind and Extend should be Nonad and Cononad :)
17:56:34 <lambdabot> Consider it noted.
17:56:44 <MostAwesomeDude> Not that I know of.
17:57:06 * hackagebot Pup-Events-Demo 1.1 - A networked event handling framework for hooking  into other programs. (DanielWilson)
17:58:04 <enigmuriatic> can anyone help me out? i think it's a pretty simple problem
17:58:29 <Y0Gi> MostAwesomeDude: so it would be a good choice to go with a data type for the color type, and functions for the actual values?
17:58:48 <MostAwesomeDude> Y0Gi: That's a way of doing things, sure.
17:58:55 <MostAwesomeDude> Y0Gi: It depends on what you're *actually doing* with them.
17:59:16 <Y0Gi> I'm not sure about that, yet :)
17:59:18 <MostAwesomeDude> enigmuriatic: Remember that Maybes have to be declared with either Just or Nothing.
17:59:29 <MostAwesomeDude> :t [Nothing, Just 3, Nothing]
17:59:30 <lambdabot> forall a. (Num a) => [Maybe a]
17:59:38 <enigmuriatic> thanks
18:23:13 <enigmuriatic> is there a native function to return each unique value in a list?
18:23:28 <byorgey> enigmuriatic: nub
18:23:46 <enigmuriatic> thanks
18:28:02 <Cale> enigmuriatic: Note that if the list is long, you might prefer to use something like map head . group . sort, or a variant of nub which collects a Data.Set of the elements seen so far
18:28:29 <Cale> (but worry about performance after your program works :)
18:30:27 <Enigmagic> do you know if there is a reason that nub doesn't use a Set internally?
18:30:39 <copumpkin> that would require more constraints
18:30:44 <copumpkin> and would lose the order
18:30:52 <copumpkin> you could use a Map and keep the order, but you'd still need more constraints
18:31:39 <Enigmagic> how important is the ordering of equal elements?
18:31:57 <hpaste> enigmuriatic pasted “Nub” at http://hpaste.org/72569
18:32:07 <enigmuriatic> why isn't that a valid version of nub?
18:32:20 <enigmuriatic> oh wait
18:32:33 <enigmuriatic> nevermind lol, dumb mistake, forgot to finish the case syntac
18:32:47 <Cale> copumpkin: you can use a Set and keep the order :)
18:32:48 <Cale> copumpkin: *and* keep the laziness
18:32:51 <Cale> also isElem isn't an infix operator
18:32:53 <Cale> and isn't defined
18:33:13 <copumpkin> Cale: oh yeah, I guess, but you lose memory efficiency
18:33:21 <Cale> copumpkin: only a little :)
18:33:27 <copumpkin> it depends on your input
18:33:38 <mikeplus64> enigmuriatic: replace isElem with `elem`
18:33:39 <Cale> You're still using O(n) space
18:33:44 <Cale> to get the nth element
18:33:51 <mikeplus64> enigmuriatic: (`f` means f but infix)
18:34:15 <Cale> er, to get to the nth element of the input :)
18:34:26 <vodik> also doesn't he want not elem, not elem?
18:34:52 <vodik> hes dropping the item if it doesn't appear in the list?
18:35:48 <hpaste> enigmuriatic pasted “Nub” at http://hpaste.org/72570
18:35:56 <enigmuriatic> i'm getting that error ^
18:35:58 <enigmuriatic> with this code:
18:36:14 <vodik> enigmuriatic: Eq a => [a] -> [a]
18:36:17 <hpaste> enigmuriatic pasted “Nub” at http://hpaste.org/72571
18:36:24 <Clint> you need the constraint
18:36:25 <mikeplus64> enigmuriatic: it says that the type of the variables isn't constrained enough
18:36:33 <Clint> and you can annotate your pastes
18:36:36 <enigmuriatic> why isn't it?
18:36:47 <hpaste> vodik annotated “Nub” with “Nub (annotation)” at http://hpaste.org/72569#a72572
18:36:56 <mikeplus64> enigmuriatic: because it hasn't got an Eq a context, meaning that the as in the type signature all have instances for Eq
18:37:02 <mikeplus64> ie they can use ==, /=
18:37:06 <vodik> enigmuriatic: because your doing comparisions
18:37:32 <enigmuriatic> ah, i figured you could always find out if one thing was equal to another thing
18:37:34 <hpaste> Cale pasted “Set nub” at http://hpaste.org/72573
18:38:01 <vodik> enigmuriatic: also your missing the | for the guard
18:38:09 <vodik> enigmuriatic: the rest of the pattern matching there
18:38:23 <vodik> enigmuriatic: and i think x `elem` xs logic is backwards
18:38:54 <enigmuriatic> i think you may be looking at the old version vodik
18:38:55 <hpaste> vodik annotated “Nub” with “Nub (annotation) (annotation)” at http://hpaste.org/72569#a72574
18:39:01 <enigmuriatic> i have one that almost works, one small bug
18:39:06 <enigmuriatic> i'll post it in a sec
18:39:15 <vodik> enigmuriatic: its not that version ^
18:39:33 <mewalz> How can I fold a very large generated list w/o overflowing the stack? Just as a benchmark I am trying to find the length. The list is generated by using iterate and being trunicated using take.
18:39:46 <vodik> mewalz: use a strict fold?
18:39:56 <vodik> like foldl'
18:39:56 <enigmuriatic> i'm not sure of how to handle the last item
18:40:17 <vodik> enigmuriatic: you don't
18:40:28 <mewalz> vodik: from Data.List?
18:40:31 <vodik> it won't have any duplicates since theres noything after it
18:40:39 <vodik> mewalz: yeah
18:40:55 <enigmuriatic> that's not the logic though
18:41:00 <enigmuriatic> oh right, it is
18:41:03 <vodik> yeah
18:41:08 <enigmuriatic> then why isn't it currently working... lol
18:41:16 <vodik> enigmuriatic: lets see it
18:41:22 <enigmuriatic> nub [1,1,2,2,3,3] currently returns [1,2,3,3]
18:41:26 <mewalz> Out
18:41:32 <vodik> enigmuriatic: show your work please
18:42:05 <enigmuriatic> ah, fixed it
18:42:13 <enigmuriatic> you were right, logic was backwards
18:42:21 <enigmuriatic> pasting now
18:42:48 <hpaste> enigmuriatic pasted “Nub” at http://hpaste.org/72575
18:43:01 <vodik> yeah
18:45:44 <enigmuriatic> how do you import a .hs file into another .hs when they're in the same directory?
18:46:06 <mikeplus64> enigmuriatic: module Foo where in one hs, and import Foo in the other
18:46:18 <mikeplus64> enigmuriatic: the filenames should reflect the module names
18:48:09 <enigmuriatic> thanks mikeplus64
18:55:00 <hpaste> mewalz pasted “stack overflow!!!!!” at http://hpaste.org/72576
18:56:07 <mewalz> still having the same problem, any ideas?
18:56:28 <vodik> tail recusion the issue?
18:56:32 <vodik> x : nextIndex' (y:xs) (i+1) (j-1)
18:57:14 <enigmuriatic> if i'm making a function whose possible inputs are "Nothing" or "Just a", why is the compiler telling me that they have different numbers of arguments
18:57:31 <otters> enigmuriatic: example?
18:57:34 <vodik> enigmuriatic: because your not doing it right? what are you doing?
18:57:49 <otters> enigmuriatic: if you're doing "somefunc Nothing = ...; somefunc Just a = ..."
18:57:53 <otters> you need to put () around Just a
18:58:06 <vodik> ^
18:58:21 <hpaste> enigmuriatic pasted “possibilities” at http://hpaste.org/72577
18:58:28 <enigmuriatic> ah, thanks
18:58:43 <mewalz> vodik: nextIndex' always generates a list of length c, so that shouldn't be a problem
18:58:50 <vodik> enigmuriatic: it still has to be in quotes there
18:58:51 <vodik> yeah
18:59:23 <vodik> mewalz: right, but it could be building up a trunk instead of evaulating, idk
18:59:41 <vodik> which is where the stack overflow comes in
19:10:24 <danharaj_> hmm
19:31:11 <hpaste> mikeplus64 annotated “stack overflow!!!!!” with “stack overflow!!!!! (annotation)” at http://hpaste.org/72576#a72578
19:31:26 <mikeplus64> mewalz: i added strictness annotations
19:32:09 * hackagebot Pup-Events-Server 1.1.1 - A networked event handling framework for hooking  into other programs. (DanielWilson)
19:32:27 <mikeplus64> mewalz: it seems to work fine in ghci if i do combinations (replicate 30000000 1) 10
19:32:50 <mikeplus64> mewalz: also oops i broke the guard alignment
19:34:40 <hpaste> mikeplus64 annotated “stack overflow!!!!!” with “stack overflow!!!!! (annotation) (superficial annotation)” at http://hpaste.org/72576#a72579
19:43:05 <morel> how can i do something like "if isJust a && isJust b && isJust c && isJust d then …" nicely? (the type of a, b, c and d do not equal. that's why i think i can't use sequence.)
19:43:22 <solrize> mikeplus64, what is that madness?
19:44:09 <Cale> morel: case (a,b,c,d) of (Just x, Just y, Just z, Just w) -> ...; _ -> ...
19:44:12 <solrize> :t isJust (a >>= b >>= c >>= d)
19:44:13 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `Expr'
19:44:13 <lambdabot>     In the first argument of `(>>=)', namely `a'
19:44:14 <lambdabot>     In the first argument of `(>>=)', namely `a >>= b'
19:44:38 <otters> :t \a b c d -> isJust (a >>= b >>= c >>= d)
19:44:40 <lambdabot> forall a a1 a2 a3. Maybe a -> (a -> Maybe a1) -> (a1 -> Maybe a2) -> (a2 -> Maybe a3) -> Bool
19:44:40 <mikeplus64> solrize: ask mewalz
19:44:47 <mikeplus64> (because i have no idea)
19:45:12 <otters> :t a
19:45:13 <lambdabot> Expr
19:45:16 <morel> solrize: i don't think that's what i need, is it?
19:45:33 <solrize> morel, no
19:46:01 <morel> then, i'll use Cale's suggestion. thanks :)
19:46:12 <solrize> what was cale's suggestion?
19:46:16 <solrize> i'm still thinking
19:46:18 <morel> read.
19:46:19 <gertc> Left e -> print "hello"
19:46:26 <gertc> how do i ignore e ?
19:46:32 <Clint> Left _
19:46:42 <gertc> thx
19:46:44 <morel> gertc: what Clint said.
19:46:49 <morel> :D
19:46:52 <solrize> oh, found it
19:46:58 <morel> :D
19:47:10 * hackagebot Pup-Events-Server 1.1.2 - A networked event handling framework for hooking  into other programs. (DanielWilson)
19:47:18 <mikeplus64> morel: you can do isJust (x >> y >> z >> ...)
19:47:36 <parcs`> case liftM4 (,,,) a b c d of Just _ ->
19:47:48 <morel> mikeplus64: oh, that'd be nice.
19:47:50 <solrize> :k All
19:47:51 <lambdabot> *
19:48:17 <solrize> :info All
19:48:28 <morel> mikeplus64: nice! thanks!
19:48:29 <gertc> 4 hours to find out what the ambiguous try error was ....
19:48:45 <coppro> ouch
19:48:52 <morel> Cale: did you read mikeplus64's suggestion. that's nicer :P
19:49:27 <solrize> oh nice, i was trying to figure out something like that with >>-
19:49:28 <morel> hmmm
19:49:29 <solrize> >>=
19:49:40 <morel> i don't know which advice to follow.
19:49:46 <morel> parcs` suggestion is nice, too.
19:50:33 <solrize> all [isJust a, isJust b, isJust c, isJust d]
19:50:36 <solrize> :t all
19:50:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:50:45 <solrize> hmm that isn't right
19:50:47 <parcs`> :t and
19:50:48 <lambdabot> [Bool] -> Bool
19:50:52 <solrize> yeah, and
19:51:02 <solrize> and [isJust a, isJust b, isJust c, isJust d]
19:51:20 <solrize> not much different than ... && ... && ...  i guess
19:51:22 <mikeplus64> morel: but if you are doing something with the values in the maybes, then it's probably better to just do case (a,b,c,d) of (Just x, Just y, Just z, Just w); ...
19:51:26 <morel> solrize: yup.
19:51:27 <mikeplus64> morel: or use the Maybe monad
19:51:52 <gertc> Left _ -> WS.sendTextData ("Facebook login " `mappend` url :: Text)
19:51:56 <mikeplus64> solrize: or all isJust [a,b,c,d]
19:52:02 <morel> mikeplus64: which methods of the maybe monad would you use?
19:52:05 <gertc> still give me error
19:52:11 <solrize> mikeplus64, a,b,c,d don't have the same type
19:52:19 <mikeplus64> morel: >> and >>=
19:52:22 <mikeplus64> solrize: oh right
19:52:26 <morel> ah, okay, yea.
19:52:43 <gertc> Left e -> liftIO $ print $ "error: " ++ show (e :: SomeException)
19:52:46 <gertc> not ?
19:52:55 <mikeplus64> > do { x <- Just 5; y <- Just 6; z <- Just 7; return ( x + y + z ) }
19:52:57 <lambdabot>   Just 18
19:52:59 <mikeplus64> morel:
19:53:05 <mikeplus64> > do { x <- Just 5; y <- Nothing; z <- Just 7; return ( x + y + z ) }
19:53:07 <lambdabot>   Nothing
19:53:08 <morel> yup
19:53:15 <morel> we talked about that above.
19:53:19 <mikeplus64> oh
19:53:22 <mikeplus64> lol
19:53:34 <morel> with you…
19:53:40 <morel> i mean, you suggested >>…
19:54:04 <solrize> i don't understand the purpose of that combinations paste with data.vector
19:54:07 * morel uses Cale's tip.
19:54:16 <mikeplus64> morel: but not >>=
19:54:22 <morel> ah
20:00:54 <hpaste> gertc pasted “Left _ -> WS.sendTextData ("Facebook login " `mappend` url :: Text)” at http://hpaste.org/72580
20:01:37 <gertc> why does my this Left not work ?
20:02:04 <gertc> --Left e -> works
20:02:26 <hpaste> dfeuer pasted “Crazy SPOJ thing” at http://hpaste.org/72581
20:02:40 <dfeuer> This silly thing is /still/ too slow.
20:02:48 <dfeuer> Can anyone help me out?
20:02:59 <mikeplus64> gertc: you need to give e a type
20:03:24 <mikeplus64> e :: SomeException or something like that
20:04:37 <gertc> but i just want to ignore e ?
20:04:57 <Clint> you can't ignore it if you're switching on its value
20:05:18 <Clint> Either SomeException (Maybe whatever)
20:05:41 <gertc> ok keep on breathing in and out relax :)
20:06:16 <Clint> it's the e in lines 61 and 62 that is ambiguous
20:06:27 <Clint> not any of your other e's
20:08:23 <parcs`> gertc: do you understand why 'case read "True" of _ -> ...' would be an error?
20:09:27 <Clint> maybe what you want is catch
20:11:09 <mewalz> mikeplus64: thanks, I tried all the changes but I still have the very same problem. I want to be able to fold the entire list generated by combinations using constant memory
20:11:41 <mewalz> but the strictness sped things up a bit
20:13:08 <hpaste> applicative annotated “Left _ -> WS.sendTextData ("Facebook login " `mappend` url :: Text)” with “Left _ -> WS.sendTextData ("Facebook login " `mappend` url :: Text) (annotation)” at http://hpaste.org/72580#a72582
20:13:46 <gertc> just one Left _ -> ... is possible rigth ?
20:14:24 <applicative_> gertc Just one as opposed to what?
20:14:46 <applicative_> gertc, did you see the signature I added, somewhat arbitrarily
20:14:48 <mewalz> Since the list can be generated step by step, would it make sense to use enumerator/conduit to perform the fold?
20:14:55 <mikeplus64> mewalz: it worked here, that's odd
20:15:06 <mikeplus64> mewalz: maybe you're using an older ghc?
20:15:12 <mikeplus64> unless your thing will take longer on different lists
20:15:17 <gertc> no?
20:15:33 <mewalz> 7.4.1 is recent
20:16:14 <mikeplus64> yeah
20:16:22 <applicative_> dfeuer why are you using Int32 ... just wondering
20:16:40 <mewalz> mkieplus64: you did try to find the length and not just the combinations?
20:16:51 <mikeplus64> mewalz: no
20:17:18 <dfeuer> applicative_: because I know Int32 is big enough, and I don't know if Int is big enough. Isn't Int32 just as fast in GHC?
20:17:26 <dfeuer> The target is 32-bit.
20:17:50 <applicative_> the Int will be Int32
20:17:58 <applicative_> > maxBound ::  Int
20:18:00 <lambdabot>   9223372036854775807
20:18:06 <applicative_> > maxBound ::  Int64
20:18:07 <lambdabot>   9223372036854775807
20:18:26 <applicative_> -- so lambdabot is Int = Int64 , crudely
20:19:06 <dfeuer> OK, applicative_. In any case, I don't see any way that could be the performance problem.
20:19:08 <applicative_> dfeuer: anyway, I'm not objecting.
20:19:19 <Clint> do you really want Int32 and not Word32?
20:19:24 <eden_> I've recently been using arrows with (a,b) tuples. I'd like to make the entries strict. Could anyone give me a hand defining an arrow instance for Data.String.Tuple from the strict package?
20:19:24 <applicative_> dfeuer: no, I was just studying it.
20:19:50 <dfeuer> Clint: some of the numbers are signed. If Word32 is faster, I can make the rest of them Words.....
20:20:49 <dfeuer> But I would think Word vs. Int would only make a difference for comparisons, no?
20:21:32 <Clint> oh, i wasn't suggesting that it was your performance problem
20:22:18 <dfeuer> Unfortunately, since this is a silly online programming thingum, they haven't upgraded their GHC since version 6.something.
20:22:30 <gertc> parcs`: case read "True"::Bool of _ -> print "hello"
20:23:26 <dfeuer> Specifically, this comes from https://www.spoj.pl/problems/ABCDEF/
20:23:47 <dfeuer> No one's managed to do it in Haskell yet.
20:24:44 <conal> sclv: ping.
20:25:13 <dfeuer> I'm wondering if I'm going to need to go to crazy shit like sorting in STUArrays (if those are even available in that ancient Haskell version)
20:25:24 <dfeuer> s/Haskell/ghc
20:25:40 <conal> @tell sclv I responded to your question on referential transparency definitions: http://www.reddit.com/r/haskell/comments/xgq27/uday_reddy_sharpens_up_referential_transparency/c5mq53n
20:25:40 <lambdabot> Consider it noted.
20:27:29 <dfeuer> Any more thoughts, Clint or applicative_?
20:29:41 <mikeplus64> dfeuer: maybe post on /r/haskell, also ask for them to upgrade their ghc
20:29:51 <mikeplus64> or the haskell cafe
20:29:59 <mikeplus64> probably the haskell cafe
20:30:08 <gertc> applicative_: thx works
20:31:06 <dfeuer> mike2: asking them has not yet yielded any response.
20:31:17 <dfeuer> um...
20:31:30 <dfeuer> Sorry, I meant mikeplus64. And I don't know what /r/haskell might be.
20:31:42 <mikeplus64> dfeuer: reddit.com/r/haskell
20:31:54 <dfeuer> Ah.
20:31:58 <dfeuer> Thanks.
20:33:53 <MagneticDuckling> Hey... should I use darcs or github for my project?
20:34:08 <gertc> how do people learn this stuff ? You cant just figure it out by reading this for example ? http://learnyouahaskell.com/syntax-in-functions#case-expressions
20:34:15 <dfeuer> MagneticDuckling: you should ask that question in a more relevant channel, I suggest.
20:34:23 <MagneticDuckling> Where?
20:34:38 <MagneticDuckling> But first, what do you guys use?
20:34:51 <MagneticDuckling> I don't have any specific needs for now
20:35:00 <MagneticDuckling> I'm just looking for a good system
20:35:16 <dfeuer> Yes, and you just walked into the cell phone store looking to buy a smock.
20:35:17 <gertc> even guido python creater has someone to explain how haskell works
20:35:52 <MagneticDuckling> I understand that github is also able to work online
20:36:11 <mapreduce> Is there any definition I can point someone at that says a type system is strictly a static one?  After all, that's what we normally mean by a type system but wikipedia et al mix in dynamic typing in there.
20:36:23 <MagneticDuckling> Which is cool and useful and cool
20:36:37 <Y0Gi> is there a function that takes a list of Maybes, drops the Nothings, and returns the values wrapped in Justs?
20:36:39 <MagneticDuckling> But I wouldn't be able to use darcs
20:37:13 <MagneticDuckling> filter isJust
20:37:23 <MagneticDuckling> ?
20:37:37 <mapreduce> MagneticDuckling: darcs is a VCS, github is a hosting site.  If you're unaware of the difference between the two then I'd have to say github.
20:37:49 <MagneticDuckling> Rrr
20:38:01 <MagneticDuckling> But is there any way to use darcs
20:38:10 <MagneticDuckling> And get the functionality
20:38:21 <MagneticDuckling> If the type of thing github does
20:38:44 <Y0Gi> MagneticDuckling: wow, thanks
20:38:45 <MagneticDuckling> I'm not a noob, k?
20:38:54 <MagneticDuckling> I'm typing on my phone
20:39:01 <MagneticDuckling> And didn't state everything
20:39:19 <Y0Gi> MagneticDuckling: I'm not aware of a community/web-based/hosting thing like Github for darcs
20:39:28 <MagneticDuckling> Yw, yogi
20:39:30 <MagneticDuckling> Mm
20:39:55 <Y0Gi> the only comparable site I know of is Bitbucket, and IIRC it started supporting Git next to Mercurial by now
20:40:09 <MagneticDuckling> Okay
20:40:16 <deckeraa> From a quick search it looks like http://patch-tag.com/ hosts darcs.
20:40:26 <Y0Gi> if you're looking for a VCS, you might be better off with Git because of the presumably larger user base
20:40:37 <MagneticDuckling> Btw mapreduce, I hate being mistaken for a noob
20:40:50 <MagneticDuckling> :P
20:40:55 <MagneticDuckling> Ty
20:41:04 <danil> mapreduce: here's a blog post about it, but it might not be the authority you're looking for http://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/ (emminent PL theorist = extremely biased)
20:41:20 <MagneticDuckling> Hehe
20:41:26 <MagneticDuckling> Thanks
20:41:30 <MagneticDuckling> I'll try both
20:43:27 <applicative_> MagneticDuckling: there is also e.g. http://darcsden.com/
20:45:44 <mapreduce> danil: Thanks, that's an article I'd read and forgotten about.  I think in this particular discussion (not ours, the one I want to give a pointer in) it'd be flamebait though.
20:45:49 <Y0Gi> ah, Data.Maybe.catMaybes is exactly what I was looking for.
20:46:04 <danil> mapreduce: yeah, I figured as much
20:50:13 <gertc> do you think haskell language is going to be to complex in the future? Do they for example try make a compiler that do not need {-# LANGUAGE -} anymore?
20:52:08 <latro`a> Y0Gi: there is also mapMaybe
20:52:28 <latro`a> which drops Nothings and applies the function to the Just values
20:52:33 <latro`a> (i.e. catMaybes = mapMaybe id)
21:03:32 <mikeplus64> gertc: i don't think compiler extensions will go away any time soon, the only one i can see being default in a future haskell is OverloadedStrings (or just a different default string type)
21:12:40 <mango-_> can anyone tell me why this fails, and how to fix it? http://pastebin.com/cZuQHY9n
21:12:45 <mauke> The paste cZuQHY9n has been copied to http://hpaste.org/72583
21:13:45 <jfischoff> mango: trying `cabal install alex` and see what it says
21:13:58 <jfischoff> err *try
21:15:04 <mango-_> it gave the same error
21:16:23 <jfischoff> marigo-_: try `cabal install alex -v3 `
21:19:33 <mango-_> it appears to be the same error
21:20:00 <jfischoff> that's all it says?
21:20:26 <jfischoff> I expect it fail
21:20:33 <jfischoff> I just want to know more information
21:20:57 <applicative_> mango-_: if you have the Haskell Platform package, you should already have the alex binary, by the way
21:21:28 <hpaste> mango pasted “alex cabal” at http://hpaste.org/72584
21:22:28 <mango-_> I'm trying to update it because the version that comes with the platform is too old for yesod
21:22:55 <applicative_> ah
21:24:43 <mikeplus64> mango-_: are you on an old haskell platform?
21:24:44 <applicative_> it's probably not related, but it bugs me youre installing with the cabal flag --global. This can lead e.g. to overwriting libs
21:24:59 <mikeplus64> (the ghc 7.0.3 says to me yes)
21:25:25 <mango-_> I'm using the 11.10 ghc package
21:25:35 <applicative_> 7.0.4 is not old
21:25:51 <jfischoff> mango-_: hmm, I don't really know.  I would `cabal unpack alex` and then cd into the directory and call `cabal configure` and see if you get a better error message.
21:27:07 <applicative_> it looks like the error message we would like is going to come from ld, not ghc or cabal
21:28:01 <applicative_> mango- can you see if ghc-pkg check suggests anything is wrong?
21:33:12 <hpaste> keep_learnig pasted “project euler 107” at http://hpaste.org/72585
21:33:31 <keep_learning> Hello all
21:33:39 <mango-_> ghc-pkg check doesn't complain, and what jfischoff suggested came back with the same error
21:33:50 <keep_learning> I am trying to solve project euler problem 107
21:33:57 <keep_learning> but I have weird problem
21:34:06 <keep_learning> while running the code with ghci is working fine
21:34:14 <jfischoff> mango-_: try it with -v3 maybe..
21:34:27 <keep_learning> but compiled code and taking input from file is giving  -1.
21:34:35 <keep_learning> http://hpaste.org/72585
21:34:58 <Nereid> whooooooooooa.
21:35:04 <Nereid> this is great.
21:35:21 <Nereid> :o
21:36:28 <Nereid> I've produced an indexed state monad, where the state is either empty or contains a value of some type
21:36:31 <Veinor> are there any good papers on lenses i can read?
21:36:33 <Nereid> so you can do stuff like
21:36:44 <Nereid> well,
21:37:36 <Nereid> so I made a kind with members Empty and Full t, for each type t
21:37:41 <Nereid> and functions
21:37:43 <Nereid> get :: State (Full t) Empty t
21:37:52 <mango-_> jfischoff: here is with -v3 http://hpaste.org/72584
21:37:54 <Nereid> put :: t -> State Empty (Full t) ()
21:38:14 <Nereid> runState :: State Empty Empty a -> a
21:38:27 <Nereid> and it's made into a restricted monad, so you can do things like
21:38:37 <mapreduce> cabal install terminfo fails because 'curses headers could not be found', but I've installed those in ~/include
21:38:45 <mapreduce> How can I tell cabal to look there?
21:38:57 <Nereid> runState do { put 5; modify (\x -> (x,x)); get } -- = (x,x)
21:39:00 <Nereid> er
21:39:02 <Nereid> = (5,5)
21:39:09 <Nereid> and runState $ ...
21:39:20 <Nereid> and of course it's type-safe.
21:39:55 <Nereid> wait.
21:40:56 <mikeplus64> mango-_: if you can, get the newest HP
21:41:19 <keep_learning> Any one please.
21:41:38 <Nereid> ok, so the do notation doesn't work.
21:41:53 <Nereid> but runState $ put 5 >> modify (\x -> (x,x)) >> get = (5,5), for instance.
21:42:38 <Nereid> let's find out if data families and DataKinds work nicely together.
21:42:42 <mikeplus64> keep_learning: that code is incredibly cryptic
21:43:03 <Nereid> wait, how could they even interact
21:43:49 <mikeplus64> Nereid: you can't do that
21:43:56 <keep_learning> mikeplus64, Sorry but I could not come up with better idea.
21:43:56 <mikeplus64> :t modify
21:43:57 <Nereid> do what
21:43:58 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
21:44:04 <Nereid> mikeplus64: no, I wrote my own.
21:44:05 <mikeplus64> Nereid: change the type with modify
21:44:09 <mikeplus64> oh
21:44:19 <Nereid> modify :: (t -> t') -> State (Full t) (Full t') ()
21:44:28 <mikeplus64> neat
21:45:09 <Nereid> note that I didn't need a starting state at all.
21:45:40 <Nereid> I couldn't get the latest ghc nightly to build on here. :(
21:45:50 <Nereid> so I'm stuck with 7.4
21:46:32 <Nereid> some of the things I wanted to do don't work in 7.4, but do in HEAD
21:49:50 <tertl3> hi
21:50:37 <Nereid> hmmm
21:50:42 <Nereid> did I just make this into a stack
21:52:06 <Nereid> nope, heh
21:54:02 <Nereid> yeah I would have just made an infinite type.
21:54:45 <Nereid> wait?
21:55:13 <Nereid> I'd have to think about it some more, but I feel like it wouldn't work anyway.
21:58:06 <solrize> nereid wha???  it's State s a    so how can you modify x to (x,x)  ?
21:58:15 <Nereid> solarus: it's not the standard State.
21:58:27 <solrize> oh indexed, cool
21:58:32 <solrize> didn't see further up
21:58:34 <Nereid> :p
21:58:51 <solrize> nice there are a few of those around
21:58:53 <Nereid> oops, failed tab completion. apologies to both of you.
22:01:56 <ReinH> Anyone have any trouble with haskell platform and ghc 7.4.2?
22:02:31 <Nereid> ReinH: what's the problem?
22:02:49 <ReinH> Nereid: nothing yet but I'd rather ask before compiling for an hour or so
22:03:07 <Nereid> should be fine
22:03:41 <ReinH> just ./configure with --enable-unsupported-ghc-version ?
22:04:10 <Nereid> oh, 7.4.2
22:05:31 <Nereid> should be fine?
22:05:39 <ReinH> we shall see
22:05:46 <ReinH> damn the torpedos and so forth
22:06:07 <ReinH> nothing obviously broken yet...
22:06:11 <ReinH> oh someone bottled a binary for it
22:06:15 <ReinH> awesome
22:16:18 <mikeplus64> keep_learning: the problem is i think in interact
22:17:01 <keep_learning> mikeplus64, Thank you
22:17:13 <hpaste> mikeplus64 annotated “project euler 107” with “project euler 107 (annotation)” at http://hpaste.org/72585#a72586
22:17:24 <mikeplus64> keep_learning: i went over your code and in trying to understand it reformatted it a bit
22:17:30 <mikeplus64> it seems to work like this
22:17:52 <keep_learning> mikeplus64, Its Prim's algorithm
22:18:11 <mikeplus64> Prim?
22:18:12 <keep_learning> Its correct except the main part
22:18:16 <mikeplus64> yeah
22:18:24 <keep_learning> yes for minimum spanning tree
22:22:30 <ReinH> I'm getting an error for this example code from Data.Array.Lens: https://gist.github.com/b9af900528112b0525e0
22:28:34 <ReinH> In fact for any use of ^=, including `_1 ^= 5 $ (1,4)`
22:28:37 <ReinH> what am I doing wrong?
22:40:05 <wavewave> hi guys
22:41:49 * morel waves to wavewave
22:48:03 <Nereid> hmm
22:48:07 <Nereid> I just made a stack
22:48:08 <Nereid> except
22:48:12 <Nereid> where the hell is it being stored
22:51:00 <Nereid> I just made a recursive kind and my mind exploded.
22:52:24 <Nereid> why does this work
22:52:24 <Nereid> what
22:52:56 <wavewave> ?
22:53:23 * wavewave waves to morel
22:53:47 <wavewave> Nereid: I do not understand what you said.
22:53:54 <Nereid> me either.
22:53:59 * morel goes to wavewave and slaps him.
22:54:45 * morel goes back and feels ashamed.
22:54:58 <Nereid> oh good, I can't actually make an infinite stack, because that would mean an infinite type.
22:55:20 <copumpkin> what'd you write?
22:55:27 * wavewave got dizzy
22:55:39 <morel> data InfiniteType = InfiniteType InfiniteType
22:56:08 <Nereid> copumpkin: I'm fiddling around with DataKinds.
22:56:12 <copumpkin> ah
22:57:05 <Nereid> and I apparently made an indexed state monad type thing
22:57:06 * wavewave wants to have KindKinds
22:57:07 * morel begins to read mm_freak 's tutorial "Understanding Haskell Monads" <http://ertes.de/articles/monads.html>.
22:57:23 <morel> wavewave: those are sometimes called "sorts".
22:57:30 <Nereid> State :: StateKind -> StateKind -> * -> *
22:57:31 <Nereid> more or less
22:57:39 <copumpkin> ah
22:57:43 <Nereid> where data StateKind = Nil | Cons a (StateKind a)
22:57:49 <copumpkin> I see :)
22:57:56 <Nereid> so I can do stuff like
22:58:00 <copumpkin> so a stack machine with a heterogeneous stack
22:58:07 <Nereid> yeah
22:58:08 <morel> wavewave: … but most programming languages which support values, types, kinds, and sort, and so on, usually just call them Set 0, Set 1, Set 2 &c.…
22:58:27 <Nereid> so I can runState $ put 1 >> put True >> get >>= \a -> get >>= \b -> return (a,b) -- gives (True,1)
22:58:29 <Nereid> but
22:58:32 <Nereid> where is the stack!!
22:59:03 <thetallguy> hehe
22:59:04 <copumpkin> oh yours isn't quite a stack machine, unless you treat it as one
22:59:13 <copumpkin> yours is just a single piece of state that can change type
22:59:13 * morel notices that he actually talks with himself because wavewave actually didn't ask him to talk about that stuff and maybe knows it himself, too. – maybe even better.
22:59:37 <Nereid> well, that's what it was when I had StateKind a = Nothing | Just a
22:59:51 <Nereid> (forgot the type/kind parameter earlier)
22:59:55 <wavewave> morel: keep going. ^^ I just read you.
22:59:56 <copumpkin> well, if you have a type indexed by StateKind that stores values
22:59:59 <copumpkin> then that's your stack
23:00:04 <Nereid> I suppose.
23:00:38 <Nereid> it must be in my wrapped up in my free monad GADT.
23:00:39 <thetallguy> It's  oddly amusing watching the imperatively trained mind learn functional programming.
23:01:09 <Nereid> hmm, it's isn't really a GADT.
23:01:09 <copumpkin> show me more code and I'll tell you where it is :P
23:01:13 <Nereid> :p
23:01:17 <wavewave> I feel like haskell is now seriously experimenting dependent types with DataKinds
23:01:43 <copumpkin> I wouldn't call them really dependent, but they do let you do some things that are typically associated just with dependent types
23:01:44 <wavewave> one level slipped dependent type
23:01:59 <wavewave> type is value and kind is type
23:02:04 <Nereid> let me cut out the irrelevant stuf
23:02:04 <Nereid> f
23:02:41 <wavewave> but language for kind is still weak.
23:04:21 <wavewave> I hope that type/kind language in haskell will  become more agda-like while value/type language will be intact.
23:04:59 <morel> wavewave: do you know agda?
23:05:25 <mapreduce> Agda's type and value syntaxes are pretty much the same as each other.
23:05:44 <wavewave> morel: I know it, but I cannot say I really know it.
23:05:50 <morel> ah.
23:06:04 <hpaste> Nereid pasted “uh” at http://hpaste.org/72587
23:06:10 <Nereid> copumpkin: ^
23:06:28 * morel sometime has problems with GADTs-syntax because he always thinks like the haskell-syntax.
23:06:34 <Nereid> I do not quite understand my code.
23:06:45 <wavewave> mapreduce : That's true dependent type. I like haskell to have such type/kind language.
23:07:04 * morel likes the first line of Nereid's paste.
23:07:12 <Nereid> yeah I probably don't need a bunch of those.
23:07:18 <morel> :D
23:07:31 <Nereid> I just put them in while writing other things and never took them out when I stopped needing them.
23:07:48 <morel> yea, i know that…
23:07:52 <Nereid> :V
23:08:27 <wavewave> Nereid : your Functor1 looks like the same as IFunctor in index-core package.
23:08:32 <Nereid> it is the same.
23:08:39 <Nereid> I like my name better though.
23:09:09 <Nereid> ideally I'd use PolyKinds to call both ordinary Functor and Functor1 the same thing
23:09:30 <Nereid> but I'm stuck on ghc 7.4 right now so I can't do that
23:10:25 <wavewave> Nereid: is it possible in the next version of ghc?
23:10:39 <Nereid> yes
23:10:40 <copumpkin> Nereid: from what I can tell, your stack lives in the closures of your calls to run'
23:11:33 <Nereid> right, so if I had an X on top of a Y,
23:11:45 <Nereid> uh
23:12:38 <wavewave> once true type/kind dep type is realized, then value-level proof can be done with GADT injection
23:12:43 <Nereid> right, I guess that makes sense.
23:14:09 <Nereid> copumpkin: what I want to do, though,
23:15:47 <Nereid> hmm, how do I explain
23:17:12 <Nereid> I think I want some kind, say K, which contains some types, together with a map f: K -> *
23:17:23 <Nereid> and the state would consist of
23:17:38 <Nereid> for each x in K, it may or may not hold a value of type f x
23:18:26 <Nereid> copumpkin: do you think this is possible?
23:18:58 <copumpkin> hm, I don't really know what you're asking :)
23:19:06 <copumpkin> what's your high-level goal?
23:19:32 <morel> to rule the world, probably.
23:19:40 <Nereid> some way to have mutable variables, where a variable is created simply by creating a type in K.
23:19:52 <Nereid> the state kind would not be K, it would be something else
23:20:02 <Nereid> like a product of (Maybe x) for each x in K
23:21:46 <Nereid> I guess this problem could be factored into two parts.
23:22:06 <Nereid> one of which I have a rough idea of how it might work.
23:22:31 <Nereid> which would be best explained if I actually implemented it.
23:22:35 <Nereid> which would require that I implement it.
23:22:59 <Nereid> well I dunno, I'd have to think about it.
23:23:00 <Nereid> it's getting late.
23:24:24 <wavewave> Nereid : sounds like your K is more similar to typeclass (or constraint)
23:26:09 <wavewave> Nereid : or if types in K are predefined, then you can use GADTs.
23:26:29 <Nereid> yeah, it might be a typeclass.
23:26:38 <Nereid> my goal is to have K be open.
23:26:46 <Nereid> so either typeclasses or type families or something.
23:26:52 <wavewave> okay. then GADT cannot
23:27:41 <wavewave> type class with existential may be enough, I guess.
23:28:31 <Nereid> hmm.
23:29:03 <wavewave> but my gut feeling is with all new exotic extensions, we can achieve isomorphic  type/kind level thing, too, as you are trying ;-D
23:29:09 <Nereid> like a class C (i :: k) (x :: *) | i ~> x
23:29:18 <Nereid> er, (i :: K)
23:29:29 <Nereid> I don't know what it would contain
23:29:34 <Nereid> perhaps nothing
23:29:46 <Nereid> probably nothing
23:30:18 <wavewave> class (K i ) => C i a where type T i = a
23:30:23 <wavewave> something like that
23:30:35 <Nereid> or that
23:30:41 <Nereid> also I meant ->, not ~>.
23:31:04 <Nereid> but I guess I like associated types better than fundeps anyway.
23:31:20 <wavewave> sorry , a should be removed.
23:31:32 <wavewave> class (K i) => C i where type T i :: *
23:31:46 <Nereid> not something like this? class C (i :: K) where type T i :: *
23:32:08 <wavewave> I don't see why you need K as  a kind.
23:32:22 <Nereid> I don't see why you need two typeclasses.
23:32:40 <ParahSailin> what does HOF stand for
23:32:44 <Nereid> higher order function?
23:33:10 <Nereid> wavewave: but then for each "variable" I'd need to declare two things
23:33:19 <Nereid> I'm hoping I'd only have to do one. I dunno.
23:33:39 <Nereid> worst case I could hide the mess behind some TH.
23:33:48 <Nereid> I think. I've never used TH.
23:34:29 <wavewave> or... class KC i where type T i :: * , f :: i -> T i  ?
23:34:48 <Nereid> no, there shouldn't be an actual function.
23:35:09 <wavewave> what is f for?
23:35:27 <Nereid> f is a type level function.
23:35:36 <Nereid> i.e. type constructor.
23:35:40 <Nereid> or something.
23:35:45 <Nereid> well
23:35:51 <Nereid> I was using it informally.
23:36:03 <wavewave> then type F i :: * -> *
23:36:16 <wavewave> using type family.
23:36:21 <Nereid> I don't know. I'll play with things.
23:36:32 <wavewave> class KC i where type T i :: *, type F i :: * -> *
23:36:42 <Nereid> well I should probably wait until I get home where I have a more recent GHC.
23:37:04 <Nereid> for some reason I can't compile ghc 7.7.20120802 here.
23:37:20 <wavewave> Nereid: using DataKinds is still very premature.
23:37:23 <Nereid> I know.
23:37:34 <Nereid> but there were some problems I had in 7.4 that were fixed in a newer one.
23:37:37 <wavewave> I just stopped using it because my ghc crashed.
23:38:06 <Nereid> what's wrong with researching the possibilities ghc 7.6 will bring.
23:38:09 <Nereid> :P
23:38:26 <wavewave> Nereid: I encourage you to do so of course :-D
23:38:32 <Nereid> :)
23:38:43 <wavewave> Nereid: just in case you want to solve some urgent prob.
23:40:32 <Nereid> how hard it is to jump into a grad CS program when my undergraduate degree is in not-CS, anyway?
23:40:34 <Nereid> because this stuff is cool.
23:41:01 <wavewave> I dunno. I am physics major anyway ;-P
23:41:01 <Nereid> and I'm starting to wonder why I'm doing math. :c
23:42:03 <Maiz_en_Heces> http://pastebin.com/aacTUjjb
23:42:09 <mauke> The paste aacTUjjb has been copied to http://hpaste.org/72588
23:42:09 <Maiz_en_Heces> omfg I have lost faith in humanity
23:42:11 <Maiz_en_Heces> :<
23:42:18 <Maiz_en_Heces> some people just need to be chemically castrated
23:42:37 <wavewave> btw, too tired. need to sleep.. see you guys.
23:44:14 <Nereid> I need sleep too.
23:44:47 <Nereid> maybe an older snapshot works.
23:51:19 <latro`a> what sort of math nereid?
23:51:35 <latro`a> (starting grad math program in <3 weeks)
23:52:10 <Nereid> heart weeks.
23:52:21 <Nereid> I'm doing stuff like algebraic topology.
23:52:27 <latro`a> ah, pure-y
