00:00:02 <johnw> essentially, yes
00:00:07 <OceanSpray> so have any of you ever missed type lambdas from ML
00:00:24 <OceanSpray> and found Haskell's lexically scoped type variables wanting
00:00:24 <johnw> findWhen :: (FilePath -> m Bool) -> FilePath -> [FilePath]
00:00:39 <mm_freak_> OceanSpray: we have type lambdas in a sense
00:00:44 <mm_freak_> OceanSpray: that's what 'forall' does
00:00:49 <ddarius> johnw: "Infectiousness" as people usually mean for monads is simply the fact that the effects modelled by monads requires a global transformation (monadic style).  The same is true for arrows.  As mm_freak_ said, there is no difference there.
00:00:55 <OceanSpray> mm_freak_, no not exactly
00:01:06 <johnw> ddarius: true, I see what you mean now
00:01:16 <OceanSpray> mm_freak_, it requires the term to have a full annotation
00:01:17 <johnw> (and what he meant)
00:01:31 <mm_freak_> OceanSpray: given type inference why would you want that?
00:01:35 <OceanSpray> whereas sometimes, I imagine, the programmer doesn't even know what the type of the term is
00:01:50 <OceanSpray> mm_freak_, want what
00:01:56 <OceanSpray> you confused me
00:03:10 <mm_freak_> OceanSpray: could you give an example?
00:03:45 <OceanSpray> mm_freak_, using forall as a type lambda requires a type annotation, since only in a type annotation can you write forall, correct?
00:04:09 <OceanSpray> whereas a type lambda can be used without annotating the term in which you want to scope a type variable
00:05:08 <OceanSpray> (Lambda t. lambda x : t. x) versus ((lambda x : t. x) :: forall t. t -> t)
00:05:34 <johnw> i still don't get forall
00:05:59 <shachaf> It means "for all".
00:06:02 <johnw> haha
00:06:06 <shachaf> Usually it's implied.
00:06:06 <mm_freak_> johnw: http://hpaste.org/73509
00:06:26 <johnw> I think I need a good example of something I couldn't do without it
00:06:31 <OceanSpray> > warning: use infix
00:06:31 <lambdabot>   <no location info>: parse error on input `infix'
00:06:50 <johnw> mm_freak_: ok, now what does that do for us?
00:07:03 <shachaf> hlint is a little aggressive sometimes.
00:07:05 <OceanSpray> am I the only one who thinks Haskell's backticks are evil
00:07:18 <johnw> they are a bit evillish
00:07:22 <mm_freak_> johnw: forall example:  getRandoms :: (Monad m) => (forall a. (Random a) => m a) -> m (Int, Double)
00:07:34 <mm_freak_> getRandoms getRandom = liftM2 (,) getRandom getRandom
00:07:46 <mm_freak_> the first argument to 'getRandoms' is a function that can handle every 'a'
00:07:48 <mm_freak_> hence "for all"
00:07:56 <mm_freak_> so getRandoms can choose the type
00:08:08 <johnw> why couldn't you just say getRandoms :: (Monad m, Random a) => m a -> m (Int, Double)
00:08:16 <mm_freak_> johnw: because that's a type error
00:08:29 <johnw> let me input it
00:08:30 <OceanSpray> is it really?
00:08:30 <mm_freak_> in that case the caller of getRandoms chooses 'a'
00:08:34 <mm_freak_> yes, it is
00:09:04 <mm_freak_> i'm using that style quite frequently when it comes to random numbers
00:09:11 <mm_freak_> (mainly because i don't like MonadRandom)
00:09:22 <OceanSpray> I can't figure out what getRandoms does
00:09:36 <OceanSpray> might have been easier to use the canonical example of ST
00:09:49 <mm_freak_> it uses its argument computation two times with two different 'a's
00:09:53 <shachaf> ST is way more complicated than other examples of forall.
00:10:00 <johnw> mm_freak_: your type signature type-checks here fine
00:10:01 <OceanSpray> oh
00:10:07 <johnw> did you mean the use doesn't?
00:10:08 <mm_freak_> that's fine, because the computation promises that it works "for every a"
00:10:18 <mm_freak_> johnw: yes
00:10:29 <mm_freak_> johnw: the type signature is certainly correct, but pretty useless =)
00:10:41 <OceanSpray> should have called it 'runWithRandomIntAndRandomDouble' then
00:10:59 <mm_freak_> other example:  f (+) = (3 + 3 :: Integer, 4 + 4 :: Double)
00:11:20 <mm_freak_> f :: (forall a. (Num a) => a -> a -> a) -> (Integer, Double)
00:11:54 <mm_freak_> the point is that 'f' itself chooses the type of 'a', not the caller of 'f'
00:12:09 <shachaf> @google forall mainisusuallyafunction
00:12:10 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/09/higher-rank-type-constraints.html
00:12:12 <mm_freak_> that's fine, because the argument function promises that it can handle every 'a' that is a Num
00:12:31 <OceanSpray> how about something simple:
00:13:03 <OceanSpray> contrived f = (f "foo", f 42)
00:13:12 <johnw> ok, without forall it doesn't work
00:13:16 <johnw> but with forall it doesn't work either
00:13:20 <johnw> Illegal polymorphic or qualified type: forall a. Num a => m a
00:13:32 <mm_freak_> johnw: enable the Rank2Types extension
00:13:34 <shachaf> johnw: Does GHC tell you how to fix it, right below that line?
00:13:43 <johnw> shachaf: yes, indeed it does
00:13:53 <shachaf> johnw: I suggest that you follow GHC's advice.
00:14:07 <johnw> shachaf: you're just a regular bottle of sunshine, aren't you?
00:14:07 <shachaf> (That'll be $100.)
00:14:19 <shachaf> johnw: Hmm?
00:14:19 * johnw pays shachaf
00:14:34 <mm_freak_> if you feel obligated, you can pay me as well =)
00:14:34 <johnw> hey, it works, cool
00:14:38 <shachaf> Not to me! To the #haskell fund.
00:15:09 <johnw> this is a great example, mm_freak_
00:15:46 <mm_freak_> this is a great way to get along without MonadRandom and yet get a nice random number interface =)
00:16:24 <johnw> so, if I have this right, the forall is letting me use two different flavors of getRandom in my function body?
00:16:25 <nand`> “Does GHC tell you how to fix it, right below that line?” hehe
00:16:43 <mm_freak_> johnw: it's a single flavor, but a polymorphic one
00:16:45 <shachaf> johnw: Did you read that mainisusuallyafunction link?
00:17:03 <johnw> oh, I missed that somehow
00:17:31 <johnw> was probably focused on ghci
00:18:49 <mm_freak_> in my ANN library i'm using this to generate neural networks and perform evolutionary transformations
00:19:19 <mm_freak_> buildMLP :: (Monad m) => (forall a. (Random a) => (a, a) -> m a) -> [Int] -> m Network
00:23:07 <mm_freak_> in IO you can pass randomRIO to that one
00:24:59 <shachaf> OceanSpray, Lemon: You should really do something about that.
00:25:04 <johnw> shachaf: so no clarification on your comment?  You've really got me wondering now
00:25:09 <shachaf> johnw: Which comment?
00:25:17 <johnw> losing something when using an arrow
00:25:23 <Lemon> look
00:25:27 <Lemon> internet is coming, okay
00:25:29 <shachaf> I thought ddarius clarified it a bit.
00:25:40 <johnw> the comment on context-sensitivity?
00:25:43 <Lemon> just a few more days of stealing wifi
00:26:08 <Lemon> anyway, I still need that question answered
00:26:28 <shachaf> johnw: An Arrow is more general than a Monad. That means that more things can be Arrows than Monads.
00:26:41 <Lemon> have any of you ever found yourself saying "man I really want to have a lexical type variable but I don't want to annotate this entire type to get one"?
00:26:53 <shachaf> johnw: But it also means that you can't do as much with some arbitrary instance of Arrow as with some arbitrary instance of Monad.
00:27:05 <shachaf> Lemon: Yes.
00:27:12 <shachaf> Lemon: But you should annotate types anyway, so it doesn't matter.
00:27:25 <amiller> i'm trying to figure out the right way of solving this problem in haskell
00:27:25 <johnw> ah, ok
00:27:29 <amiller> i'm trying to build a redblack merkle tree
00:27:34 <johnw> thanks, you guys are super helpful at trying to get this stuff
00:27:44 <amiller> redblack trees have a simple functional definition, but the 'merkle' part of it requires that it be a monadic computation
00:28:14 <amiller> because i have some 'digest' or 'accumulator' function that gives me a mapping from the set of nodes to a set of digests
00:28:49 <amiller> that mapping is typically a hash function
00:28:51 <shachaf> Why does that need to be monadic?
00:29:08 <amiller> i want to do something like this: every time a hash is computed, i store the hash and the preimage in a database
00:29:33 <amiller> that isn't important to the definition of the balancing rules
00:30:24 <amiller> so i want to be able to say something like:      hashComputation :: domain -> m range
00:30:35 <amiller> for some monad m
00:30:59 <amiller> it's tricky because there is also the branching
00:31:43 <shachaf> Branching?
00:31:46 <amiller> branching basically goes the other way since it would be like:    preimage :: range -> m (color, range, key, range)
00:31:53 <amiller> it's a binary search tree
00:32:44 <mm_freak_> why does it have to be monadic?  would you actually use any monadic effects?
00:32:50 <amiller> so i know that there is a red-black tree using a zipper, but what i can't figure out is how to compose that with these other two functions
00:33:19 <amiller> mm_freak_, i gave an example of one monadic effect - everytime i compute a hash, i want to use IO to store it in a hashgraph, and when i preimage the hash it's another IO lookup
00:33:47 <sanjoyd> amiller: you can do the store and lookup exploiting lazy eval.
00:33:52 <sanjoyd> Have you seen Data.MemoTrie ?
00:34:09 <sanjoyd> (I'm assuming by DB you mean some in-memory data structure, and not a real DB)
00:34:16 <shachaf> I don't think that's what amiller is looking for.
00:34:16 <amiller> no a real db
00:34:24 <Lemon> @hoogle (a -> m b) -> m a -> m b
00:34:25 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:34:25 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:34:25 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
00:34:41 <amiller> two other examples of monadic effects, more important but more subtle too: i want to have a recording monad, that records the sequence of nodes i visited
00:34:47 <Lemon> @hoogle (a -> b -> m c) -> m a -> m c -> m b
00:34:49 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
00:34:49 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
00:34:49 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
00:34:53 <amiller> so i can replay it in a 'validation' monad that recomputes the hashes to validate it
00:35:49 <amiller> in the case where doman = range, then it would be a normal pure functional redblack tree
00:36:18 <amiller> doman = range = (color, range, key, range)
00:37:18 <Lemon> @pl \x -> f >>= \y -> g y x
00:37:19 <lambdabot> (f >>=) . flip g
00:41:02 <Lemon> @pl \x -> (f x >>=) . g
00:41:03 <lambdabot> (. g) . (>>=) . f
00:41:22 <Lemon> this might be a bit too much
00:41:28 <johnw> yeah, that's not exactly obvious
00:43:05 <johnw> @unpl (. g) . (>>=) . f
00:43:05 <lambdabot> (\ d l -> (f d) >>= (g l))
00:43:32 <Lemon> @unpl (. flip g) . (>>=) . f
00:43:33 <lambdabot> (\ i o -> (f i) >>= \ c -> g c o)
00:45:11 <trem_> as there are STRef and IORef, is there something like PrimRef which works with any PrimState / PrimMonad?
00:45:40 <Lemon> @hoogle PrimMonad
00:45:40 <lambdabot> No results found
00:45:48 <Lemon> what are you talking about
00:46:16 <trem_> Lemon, http://hackage.haskell.org/packages/archive/primitive/0.2.1/doc/html/Control-Monad-Primitive.html
00:46:39 <Lemon> huh
00:46:40 <trem_> Lemon, just like the vector package, which works in both, ST and in IO
00:46:51 <shachaf> http://hackage.haskell.org/packages/archive/primitive/0.4.1/doc/html/Data-Primitive-MutVar.html ?
00:46:56 <shachaf> In the same package that you linked to.
00:47:37 <trem_> shachaf, yes! that's exactly what I was after. thanks.
00:47:54 <ddarius> MCMCMC
00:49:15 <srhb> What do you do when you get pattern match warnings that you know can't occur? The warning is sort of annoying sitting there. Should I just make a dummy case?
00:49:35 <srhb> ie, non-exhaustive pattern (that really isn't)
00:49:43 <shachaf> srhb: A dummy case like foo _ = error "this can't happen" is pretty common.
00:49:48 <srhb> Alright.
00:49:57 <shachaf> It shows that you thought about the problem, and you're claiming that you're smarter than the compiler.
00:50:05 <shachaf> Make sure you really *are* smarter than the compiler. :-)
00:50:26 <srhb> c <- oneOf "tf"; cae c of 't' -> ...; 'f' -> ...;
00:50:31 <srhb> case*
00:50:48 <trem_> the message given to error is also a great place to show some creativity!
00:51:05 <srhb> error "UNPOSSIBLE"
00:51:19 <trem_> > error "hell froze over"
00:51:20 <srhb> But assuming Parsec does the right thing, I think I'm safe with a dummy case :P
00:51:20 <lambdabot>   *Exception: hell froze over
00:52:50 <MostAwesomeDude> > error "Page fault: Could not access handle 0xedf3cb0: Bad file descriptor at location 0xad5719c"
00:52:51 <lambdabot>   *Exception: Page fault: Could not access handle 0xedf3cb0: Bad file descrip...
00:53:41 <nand`> > error "Trying to dereference NULL pointer"
00:53:42 <lambdabot>   *Exception: Trying to dereference NULL pointer
00:54:52 <CrypticSwarm> Is it possible to either have some data type callable like a function, or have a function that accepts a function as first arg (a -> b), but a restricted subset of all (a -> b) functions?
00:55:11 <MostAwesomeDude> error "Could not properly / acquire syllable lock / for a haiku"
00:55:18 <shachaf> CrypticSwarm: foo :: ((Int -> Char) -> ...)
00:55:35 <shachaf> That's restricted to functions where a is Int and b is Char.
00:55:49 <dmwit> CrypticSwarm: The usual thing is to define a type SmallFun a b that represents your restricted subset, then write a function interpret :: SmallFun a b -> a -> b
00:55:52 <dmwit> or some such thing
00:56:17 <shachaf> I think CrypticSwarm's question was way too vague for a concrete answer. :-)
00:56:27 <dmwit> It didn't seem vague to me.
00:56:45 <shachaf> Maybe I'm misunderstanding it, then.
00:56:54 <nand`> I interpreted CrypticSwarm's question as relating to subtyping, in the sense of eg. restricting Int to 0-10
00:57:02 <XexonixXexillion> are there any decent ray tracers implemented in Haskell?
00:57:21 <nand`> didn't Frag use one?
00:57:23 <nand`> I don't remember
00:57:30 <dmwit> Okay, fine. CryticSwarm, please tell us more about what you want to do.
00:57:39 <CrypticSwarm> shachaf,  more a restricted behavior. not types.  A function that preserves some type of structure.
00:57:54 * shachaf agolopizes.
00:58:18 <dmwit> I still think my suggestion is the right one.
00:58:22 <CrypticSwarm> dmwit, I'm doing something something similar to what you suggest I think.
00:58:31 <shachaf> dmwit: It's quite possible.
00:58:46 <nand`> if there is some concept of the types of structure you want preserved then you could accept that instead
00:58:52 <dmwit> CrypticSwarm: You might be interested in implementing the Category interface, as well.
00:58:58 <nand`> sorry if that sounds vague, I don't know how to say what I want to say
00:59:03 <dmwit> Rather than trying to pigeonhole your things into function arrows.
00:59:27 <CrypticSwarm> I looked into that, I couldn't get it figured out.
00:59:47 <CrypticSwarm> Need it to be similar in and out to be the same type more like monoid
01:00:25 <xkb> hmm normally nginx's proxy_pass passes all HTTP request types right? So including DELETE?
01:00:25 <dmwit> I couldn't parse the last sentence there.
01:03:37 <CrypticSwarm> Category wants * -> * -> *.  Couldn't figure it out.  Wanted to have the have the same parameter twice.
01:03:38 <shachaf> dmwit: I assume CrypticSwarm meant untyped like Monoid instead of typed like Category, i.e. anything composes with anything.
01:04:09 <nand`> oh. ‘in and out to be the same type’ yeah that does make sense with what shachaf said
01:05:38 <trem_> XexonixXexillion, I have a ray tracer around which has some features
01:06:15 <trem_> XexonixXexillion, whitted style, path tracing, bidir path tracing, metropolis light transport and stochastic progressive photon mapping, that is
01:07:28 <CrypticSwarm> Just posted up what I have working with a small description.  Been trying to read through a lot of tutorials and code today to learn enough haskell to try this idea out. (https://github.com/CrypticSwarm/monoid-morphisms/commit/552549c1d55c5022a5ee5d4f65f997b6d7e4b8d5)
01:08:44 <dmwit> uh
01:08:54 <dmwit> I've only read the English, but the claim doesn't seem correct.
01:08:59 <trem_> XexonixXexillion, what are your raytracing needs?
01:09:04 <shachaf> I'm not sure what the claim means.
01:09:23 <dmwit> Surely not every endomorphism in Monoid is exactly the partial application of mappend to some particular element of that monoid.
01:09:38 <nand`> mappend :: Monoid m => m -> (m -> m);   ($mempty) :: Monoid m => (m -> m) -> m
01:09:42 <dmwit> e.g. the constantly-mempty homomorphism isn't clearly such a thing
01:10:12 <dmwit> (indeed, is clearly *not* such a thing in any non-group monoid)
01:10:46 <CrypticSwarm> eh?
01:11:02 <XexonixXexillion> trem_: To be honest, I just need a simple ray tracer which won't use a lot of RAM
01:12:00 <trem_> XexonixXexillion, my kdtree implementation is not exactly space efficient, but scenes up to a few hundert thousands objects are not really a problem
01:12:06 <nand`> I think the two functions I gave should consitute an isomorphism from some monoid m to a subset of functions m -> m; but only a subset
01:13:04 <trem_> XexonixXexillion, here are some test renders: https://plus.google.com/photos/107968783614195434185/albums/5660724573840020945
01:13:42 <dmwit> Okay, I misread the English.
01:14:10 <trem_> XexonixXexillion, do you want to embed the ray tracer or use it from the command line?
01:14:26 <CrypticSwarm> nand`,  yes, only a subset of m -> m functions.
01:14:59 <CrypticSwarm> which is why I was wondering if I can restrict to a subset of m -> m functions
01:15:50 <XexonixXexillion> trem_: It doesn't really matter. I just need it for ray tracing various kinds of 3d fractals
01:16:20 * hackagebot vault 0.2.0.1 - a persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.2.0.1 (HeinrichApfelmus)
01:16:52 <trem_> XexonixXexillion, so i think it's a perfect fit! I already have these julia quaternion fractals implemented, maybe you want to add some?
01:17:16 <trem_> the code is here: https://github.com/waldheinz/bling
01:18:23 <dmwit> CrypticSwarm: But as you've proven (?), the subset is exactly the monoid m (up to isomorphism). So why not just use m?
01:18:29 <XexonixXexillion> trem_: thanks a lot
01:19:29 <trem_> my julia lives here: https://github.com/waldheinz/bling/blob/master/src/Graphics/Bling/Primitive/Fractal.hs -- there's also a menger sponge in that module, but honstly I don't think it belongs there, there are lots of places which need some cleanup in the code
01:19:36 <dmwit> CrypticSwarm: Rephrasing the question, why is "applyMorphism (MonoidMorphism (toMorphism m1)) m2" better than "mappend m1 m2"?
01:19:42 <nand`> CrypticSwarm: I don't think it's possible to enforce that with types alone
01:19:57 <dmwit> eh
01:20:00 <trem_> XexonixXexillion, actually, I'm currently preparing a release to hackage currently.
01:20:05 <dmwit> applyMorphism (toMorphism m1) m2, I mean
01:20:54 <nand`> it seems a bit useless in Haskell terms at any rate since anything that's going to be isomorphic to Monoid m => m is, of course, isomorphic to Monoid m => m; as dmwit showed there's not much you gain by using the morphisms instead
01:21:01 <trem_> XexonixXexillion, if you decide to use it and need some help to get started just let me know, the documentation is mostly absent currently
01:21:08 <nand`> morphism composition turns into mappend, and application turns into mappend mzero
01:22:28 <CrypticSwarm> dmwit, nand`, First, force myself to learn haskell. Second, refresh some math.
01:22:47 <XexonixXexillion> trem_: It seems straight forward enough to use. Thanks again
01:24:09 <paolino> is it possible to send pieces of code to a running ghci through a pipe ?
01:25:19 <paolino> shvim is not loaded in vim, maybe haskell-mode can do this ?
01:25:44 <CrypticSwarm> dmwit, it allows you to think of things in terms of composition of functions instead of mappend.  Except its doesn't do composition in the normal way.  If you think of adding two Vectors.  This composition gets the Vector that goes straight from  Point a to Point c.  Normal function composition would go from Point a to Point c via Point b.
01:26:09 <dmwit> paolino: Sure, it's possible. Just tested with (echo '"yup"' | ghci). =)
01:26:19 <shachaf> Ah, you're thinking of something like converting [] to DList?
01:26:23 <shachaf> But for arbitrary monoids?
01:27:07 <dmwit> It's not even as good as DList.
01:27:20 <dmwit> Everything he's doing is still closing over an actual value of the monoid underneath the hood.
01:27:52 <shachaf> dmwit: Function composition of values :: m -> m is a lot like DList.
01:27:53 <nand`> (Isn't that just what DList does?)
01:28:03 <dmwit> shachaf: He's not using function composition of values :: m -> m.
01:28:06 <nand`> it looks more like changing the associativity of mappend
01:28:12 <paolino> dmwit, ok, thanks . About haskel-mode ? Can it do it ?
01:28:15 <dmwit> shachaf: He's converting functions of type m -> m into a value of type m first.
01:28:17 <nand`> to always be right-associative when applied
01:28:20 <dmwit> paolino: no idea
01:28:24 <nand`> similar to what DList does
01:28:35 <nand`> oh
01:28:35 <dmwit> nand`: No, DList isn't just a closure over a list; it's a closure over a function which may contain many lists inside.
01:28:45 <mikeplus64> paolino: what i sometimes use is ConqueTerm, run ghci in that, and :set syntax=haskell in that buffer
01:28:57 <shachaf> I'm going by "dmwit, it allows you to think of things in terms of composition of functions instead of mappend."
01:29:05 <dmwit> I'm going by the code.
01:29:09 <nand`> hang on
01:29:35 <dmwit> Also, you missed the very next phrase, "Except its doesn't do composition in the normal way."
01:29:38 <nand`> wouldn't mappend = (.) work for his Monoid (MonoidMorphism m) thing? (modulo newtypes)
01:30:15 <shachaf> I think "DList parameterized on an arbitrary Monoid" is a thing that would make sense.
01:30:18 <nand`> it obviously preserves associativity and identity too, since mappend mempty = id and id . x = x
01:30:31 <nand`> so to do what shachaf said, change mappend to function composition and voila?
01:30:39 <shachaf> Some of my other interpretations of what CrypticSwarm was saying didn't make sense, so I decided on that one. :-)
01:31:31 <dmwit> nand`: Yeah, that seems more sensible.
01:34:14 <CrypticSwarm> nand`,  I don't think mappend = (.) would work directly.
01:34:30 <nand`> CrypticSwarm: yes, you need to wrap/unwrap the newtype
01:34:35 <CrypticSwarm> Would need to pattern match to extract the functions
01:34:36 <nand`> or is that not what you meant?
01:35:03 <CrypticSwarm> wrap/unwarp seems like what i meant ;)
01:37:06 <paolino> mikeplus64, thanks, very nice
01:39:33 <rosie> I'm a bit lost on the LYAH section on functions, where (->) r is introduced as a function. What does (->) do? Is that something the author made up?
01:39:44 <quicksilver> it's the function type
01:39:46 <quicksilver> a -> b
01:39:48 <quicksilver> function from a to b
01:39:50 <quicksilver> (->) a b
01:39:54 <quicksilver> alternative way of writing it
01:40:00 <sopvop> Directly downloading packages from hackage give me tar named as tar.gz. Is it me, or something is wrong with hackage?
01:41:19 <dmwit> Probably just something wrong with that particular package.
01:41:19 <rosie> quicksilver: thanks! What's the r?
01:41:22 <dmwit> I've made that mistake before.
01:41:37 <shachaf> rosie: It's any variable.
01:41:41 <shachaf> Any type, I mean.
01:41:56 <shachaf> For any type r, ((->) r) is a Functor.
01:42:11 <rosie> shachaf: thanks
01:42:53 <shachaf> rosie: Sometimes people write ((->) r) as (r ->) -- it's not valid syntax but it would be clearer if it were.
01:43:13 <sopvop> In thar case something is wrong with cabal-inasll and all its dependencies.
01:43:14 <quicksilver> only clearer to people who understand sections, probably
01:43:18 <quicksilver> but yes :)
01:43:22 <shachaf> Since obviously "(r ->) x" = "r -> x"
01:43:47 <quicksilver> sopvop: might just be your browser decompressing the gzip itself
01:43:53 <shachaf> quicksilver: True. But understanding sections probably comes before instance Functor ((->) r)?
01:44:00 <quicksilver> shachaf: who knows?
01:44:01 <sopvop> and wget too?
01:44:08 <shachaf> quicksilver: True.
01:44:14 <quicksilver> probably not, sopvop
01:44:38 <sopvop> So, can someone please check this file http://hackage.haskell.org/packages/archive/cabal-install/0.14.0/cabal-install-0.14.0.tar.gz ?
01:44:51 <sopvop> is it really gz
01:45:04 <mauke> kind of
01:45:20 <mauke> Content-Type is application/x-tar, but Content-Encoding is x-gzip
01:45:25 <nand`> do you think it would be clearer if left-sectioning type operators was valid in Haskell?
01:45:36 <shachaf> it's acting like a gz when I download it with curl.
01:45:37 <fmap> what's wrong with being gz?
01:45:43 <trem_> sopvop, it unpacks fine for me
01:46:10 <sopvop> wtf
01:46:16 <dmwit> sopvop: gunzip works okay for me
01:46:23 <sopvop> Thaks guys
01:46:59 <sopvop> I guess it's either my centos updated to something weird
01:47:09 <sopvop> or our IT guys made something dumb with proxy
01:48:22 <trem_> sopvop, i'd bet on the latter. give a man a proxy to play with and he'll mess it up.
01:56:13 <kfish> hi OceanSpray
01:56:25 <OceanSpray> hi kfish
01:56:51 <shachaf> hi OceanSpray
01:56:57 <Axman6> hi kfish
01:56:58 <OceanSpray> hi shachaf
01:57:01 <shachaf> hi Axman6
01:57:09 <Axman6> you broke it!
01:57:27 <dmwit> hi dmwit
01:57:39 <OceanSpray> broke what
01:57:44 <liyang> 'lo all
01:57:57 <shachaf> hiyang
02:00:06 <kfish> hi Axman6 :)
02:00:24 <shachaf> Oh, kfish is Conrad Parker.
02:05:38 <rosie> In: fmap :: (a -> b) -> (r -> a) -> (r -> b) , why do "We pipe the output of r -> a into the input of a -> b to get a function r -> b" ? The  r -> a was before a -> b originally…
02:06:05 <shachaf> I wouldn't use the word "pipe".
02:06:16 <shachaf> But ignore all the functor nonsense for a bit and just think of that as a regular old function.
02:06:19 <shachaf> You know functions, right?
02:08:17 <OceanSpray> I don't understand the question
02:08:30 <rosie> shachaf: yep. A function takes some parameters and returns a result… and the type of a function is declared as myfunc :: parameter1 -> parameter2 ->  result…. am I missing something?
02:08:42 <shachaf> rosie: Nope.
02:08:57 <shachaf> Do you understand the type (a -> b) -> (r -> a) -> (r -> b)?
02:09:34 <rosie> It looks like we take two parameters, which are two functions, and we return yet another function
02:09:45 <shachaf> Yep.
02:10:11 <shachaf> Write that function. It's a good exercise.
02:10:37 <quicksilver> and if you find a solution which has the right type, you got it right :)
02:10:50 <quicksilver> (except for some nasty tricks you're unlikely to use inadvertantly)
02:11:06 <shachaf> quicksilver: I can imagine someone accidentally writing a recursive definition of a function.
02:11:23 <shachaf> Well, not accidentally, but in the "combine random tokens until it typechecks" approach to things.
02:13:14 <rosie> shachaf: here are my thoughts -- I need a first function, we'll call it length. it'll take in a string and return an Int. Our larger function takes as the second parameter another function which…. I seem to be on the wrong track
02:13:39 <whatsyourname> should i learn python, c++ or haskell?
02:13:44 <shachaf> rosie: Making things concrete might help, but it's probably even easier to keep a,b,r unknown.
02:14:05 <whatsyourname> I am currently in the state of knowing nothing about programming
02:14:06 <quicksilver> whatsyourname: all three. But if you choose one, haskell of course.
02:14:08 <shachaf> rosie: If you introduce concrete types like Int, it's actually *easier* to make mistakes.
02:14:25 <srhb> > (fmap (+1) length) "foo" -- rosie was this what you were thinking?
02:14:27 <lambdabot>   4
02:14:29 <shachaf> rosie: Whereas if you stick with letters, there's only one way to fit them together. :-) It's like a puzzle.
02:14:42 <shachaf> srhb: rosie's puzzle is to write this function. :-(
02:15:03 <srhb> fmap? Sorry I just tabbed here. ._. *blush*
02:15:20 * srhb scampers off again
02:15:23 <mauke> srhb: no, (.)
02:15:49 <rosie> shachaf: If I have a result of 'a' from one function and a parameter of 'a' to another, they aren't the same value, just the same type, so how would I know what's input and output between the parameters?
02:16:07 <shachaf> rosie: I'm not sure I understand the question.
02:16:21 * hackagebot acid-state 0.7.1 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.1 (DavidHimmelstrup)
02:16:23 <shachaf> foo :: (a -> b) -> (r -> a) -> (r -> b), right?
02:16:32 <shachaf> So start writing foo. What is foo going to look like?
02:17:00 <shachaf> I wish we had a ghclive session -- that would make this much simpler. :-)
02:17:51 <srhb> Is anyone planning a public ghclive?
02:17:56 <srhb> With rooms and stuff (would be so cool)
02:18:07 <shachaf> srhb: Not in its current state, certainly.
02:18:30 <shachaf> We can use Etherpad, though!
02:18:33 <srhb> I'm not quite sure what its current state is, other than "awesome"
02:19:00 <shachaf> srhb: "no security", i.e., "lets anyone run arbitrary commands on the computer it's running on"
02:19:08 <srhb> Ah, right, that won't do :|P
02:19:32 <merijn> Complaints go to /dev/shapr :p
02:19:37 <shachaf> Let's try this, though: http://piratepad.net/4awLWogCc0
02:19:46 <shachaf> This channel is too big so it'll probably be filled with trolls soon.
02:20:42 <liyang> Oh wow. It's Google Wave!
02:20:51 <shachaf> liyang: It's better than Google Wave!
02:22:09 <srhb> Does it have password protection or do you just keep the url secret?
02:23:04 <rosie> shachaf: Does that exist? I'm going to SF on Thursday--it would be awesome to meet you
02:23:36 <shachaf> rosie: Does what exist?
02:24:00 <rosie> foo func1 func2 = func3 … where do I string together the input and output between the functions?
02:24:07 * shachaf lives in Palo Alto.
02:24:07 <rosie> shachaf: ghclive
02:24:27 <Botje> rosie: you can remove the parenthesis on the 'result'.
02:24:28 <shachaf> rosie: ghclive is a program shapr is working on to let people work on code together.
02:25:32 <rosie> so foo f1 f2 x = g x? I'm sure that's incorrect...
02:25:40 <mauke> rosie: what is g?
02:26:04 <rosie> shachaf: in the meantime, would a google doc be helpful?
02:26:08 <rosie> g is another function
02:26:12 <mauke> which one?
02:26:23 <shachaf> rosie: We're doing something similar in that piratepad link I posted above.
02:26:24 <rosie> it has type r -> b. It's the last one
02:26:30 <Botje> rosie: you can also write it as foo f1 f2 = \r -> ...
02:27:04 <srhb> rosie: Think maths. if you had f1(x) and wanted f2 of that.. (or vice versa)
02:27:52 <rosie> srhb: exactly. I'm not sure how the output of one function becomes the input to another
02:28:25 <srhb> rosie: How would you write it in maths?
02:28:30 <srhb> rosie: If you've never done that :)
02:28:57 <srhb> er, ever. :P
02:31:54 <srhb> Watching that pad go to hell is both fascinating and leaves me with this feeling of inevitability.
02:31:57 <srhb> :P
02:32:16 <shachaf> liyang left as soon as the conversation became about Haskell.
02:32:18 <srhb> The concept is great though.
02:32:32 <srhb> I was just watching. I like the idea.
02:32:57 <liyang> shachaf: I clicked the link because it said PIRATEpad.
02:33:22 <srhb> Ooooh it would be cool if you could annotate lines, and each annotation was a chat, and then you had one chat that ties them all together
02:33:33 <srhb> So to write anything you pick either no annotation or a specific annotation or place to annotate
02:33:57 <shachaf> @yarr
02:33:58 <lambdabot> I want me grog!
02:34:10 <shachaf> @liyarr
02:34:10 <lambdabot> Yarrr!
02:36:45 <shachaf> srhb: Are you the other aristid?
02:37:07 <srhb> Er, I don't think so.
02:37:08 <srhb> Am I?
02:37:11 <srhb> I never typed in a name.
02:37:23 <shachaf> Are you in the window?
02:37:29 <srhb> Yep, it is indeed me
02:37:30 <srhb> Weird
02:45:21 <tangentstorm> so... https://gist.github.com/3422302/abb9e78b148c6ad268562eaf95995022116cada2
02:45:59 <tangentstorm> it's basically a calculator for ohm's law on simple circuits.. tried to do it as a combinator library and got stuck at line 77/78 here
02:46:25 <tangentstorm> can anyone help me think through it?
02:47:08 <tangentstorm> the circuit is just the little structure on line 102
02:48:12 <Lemmih> tangentstorm: Is it homework?
02:48:36 <tangentstorm> Lemih : I think it might have been somebody else's homework
02:49:08 <tangentstorm> they wanted to know how to solve a problem in electronics, but they asked in a programming channel, so i said i bet we could figure this out... :)
02:50:54 <Axman6> heh
02:51:26 <Axman6> Float :(
02:51:27 <tangentstorm> i know what i want to do, i just don't know how to express it in haskell
02:53:29 <tangentstorm> Axman6 : what should it be?
02:54:28 <Axman6> some people disagree with me, but there only one reason to use Float over Double, when memory usage is important. Doubles are just as fast to compute as Floats, and have much greater precision
02:55:12 <iamtakingiteasy> hi, i am having trobules with this piece of code: http://hpaste.org/73511 . When executed with one million as argument, `problem14' function causes stack overflow. any chance to do something about that without touching compiler options?
02:55:42 <Ke> Axman6: last time I checked intel manual floats were twice as fast in throughput
02:55:42 <srhb> iamtakingiteasy: Have you read this page? http://www.haskell.org/haskellwiki/Stack_overflow
02:55:43 <tangentstorm> Axman6 : oh, i just didn't know there were Doubles. thanks. :)
02:55:52 <shachaf> iamtakingiteasy: Try "collatz !n"
02:55:59 * shachaf makes a random guess.
02:56:04 <Axman6> you'll need BangPatterns
02:56:10 <Ke> though I was only able to benchmark 8/9 difference
02:56:11 <shachaf> True.
02:56:20 <shachaf> You can emulate it with seq, but that's ugly. :-(
02:56:20 <iamtakingiteasy> srhb: no, thank you, i will now
02:56:29 <srhb> shachaf: One of us is bound to be right if we all make a different guess ;)
02:56:36 <Axman6> iamtakingiteasy: ass {-3 LANGUAGE Bang Patterns #-} as the first line of your file and do what shachaf said
02:56:54 <Axman6> uh, # not 3
02:57:03 <Axman6> and BangPatterns
02:57:04 <Axman6> -_-
02:57:08 <quicksilver> Ke: only with code smart enough to pack the floats into SSE-style vectors surely?
02:57:09 <alang> also add, not ass
02:57:09 <tangentstorm> actually... is there any way i can make it something like "newtype Volts = (Num a) => Volts a ... ?"
02:57:30 <Ke> quicksilver: sse/avx yes
02:57:46 <Axman6> Ke: GHC doesn't proceed vector code currently afaik
02:57:49 <quicksilver> Ke: ok, well GHC doesn't do that.
02:58:01 <quicksilver> and most compilers for most languages eiether don't, or are bad at it
02:58:06 <quicksilver> auto-vectorising is hard.
02:58:15 <shachaf> tangentstorm: Yes, but you probably don't want that.
02:58:21 <Axman6> you might be able to coax  LLVM to do it though
02:58:30 <Ke> gcc does it, though performance benefit is not full
02:58:40 <tangentstorm> schachaf :  ok.. well I'll just leave it alone for now then :)
02:58:55 <Axman6> Ke: GCC doesn't do a great job at it =)
02:58:55 <tangentstorm> vector pascal probably does it :)
02:59:55 <Ke> anyways gcc works much better than ekopath or clang
03:00:08 <bitonic> shachaf: no, you can't do that, with newtype
03:00:11 <bitonic> you need data
03:00:19 <quicksilver> tangentstorm: vector pascal isn't autovectorising is it? It's just got explicit vectors.
03:00:31 <srhb> Why aren't BangPatterns in the standard, anyway. They seem like such an obvious improvement over seq in many cases
03:00:32 <tangentstorm> quicksilver : as far as i know, yeah
03:00:43 <iamtakingiteasy> Axman6:  shachaf: i have tried that; adding LANGUAGE declaration and prefixing 'n' with bang in `collatz !n' function declaration, but it still crashes with the same error. haven't read through guide srhb gave me though.
03:00:49 <quicksilver> ghc has some explicit vectors in one of the dph packages, although that's a bit cutting edge.
03:01:00 <tangentstorm> quicksilver : sisal might be a little bit more toward the auto side... not sure
03:01:01 <srhb> iamtakingiteasy: In both cases? it should run in constant space
03:01:10 <iamtakingiteasy> both cases?
03:01:15 <shachaf> bitonic: It depends on what you're after.
03:01:21 <srhb> iamtakingiteasy: Oh, sorry, I misremembered
03:01:22 <shachaf> bitonic: It might be that tangentstorm is after a universal type.
03:01:30 <srhb> iamtakingiteasy: Nevermind. It really should run in constant stack though!
03:01:32 <shachaf> bitonic: Which would make a lot more sense, for Num, than an existential.
03:01:36 <bitonic> shachaf: well, that syntax means something else, but yes.
03:02:04 <shachaf> bitonic: Yes, but tangentstorm was asking a vague question.
03:02:05 <iamtakingiteasy> srhb: it is not collatz function that makes it fail; it is maximumBy which is when removed casues no such overflow
03:02:11 <iamtakingiteasy> i think so at least
03:02:14 <srhb> iamtakingiteasy: Are you sure you got it recompiled?
03:02:17 <iamtakingiteasy> yep
03:02:21 <bitonic> shachaf: I think that saying "you can do that" is misleading :)
03:02:31 <srhb> iamtakingiteasy: I can't see how maximumBy should cause that crash..
03:02:31 <shachaf> Possibly.
03:02:51 <iamtakingiteasy> srhb: if i remove maximumBy - it prints all nicely up to one million
03:03:05 <tangentstorm> schachaf : https://gist.github.com/3422302/abb9e78b148c6ad268562eaf95995022116cada2  we were talking about that... I had originally used Num for all the units at the top, and then changed to floats, and then Axman6 was sad about my use of Float :)
03:03:43 <srhb> iamtakingiteasy: Well, mine does not crash. It is extremely slow, but does not crash.
03:03:43 <iamtakingiteasy> but when maximumBy is used stack overflow showing up
03:04:04 <iamtakingiteasy> hmm
03:04:12 <quicksilver> tangentstorm: if you want to, just don't bother with the class constraint at all
03:04:13 <tangentstorm> what i really care about is line 77-78... i don't understand how to do an imperative loop
03:04:20 <quicksilver> newtype KOhms a = KOhms a deriving ( Num, Show, Eq, Fractional )
03:04:27 <iamtakingiteasy> srhb: maybe this stack size calculated differently on your system?
03:04:38 <tangentstorm> quicksilver : ah, nice. thanks!
03:05:05 <tangentstorm> quicksilver : Not in scope : type variable a
03:05:06 <srhb> iamtakingiteasy: I can't see why that should be the case
03:05:24 <quicksilver> really?
03:05:25 <iamtakingiteasy> srhb: does it crash without bang on your system?
03:06:08 <tangentstorm> quicksilver : oh, i missed the a on the left
03:06:12 <quicksilver> :)
03:07:43 <tangentstorm> quicksilver : but now the "a" has to be in Solve and Flow and I presume will propagate up through the rest of the code... :/
03:07:57 <quicksilver> yup.
03:08:00 <srhb> iamtakingiteasy: Yes
03:08:18 <tangentstorm> well i'll just stick with float then :)
03:08:27 <quicksilver> I would say Double :)
03:08:34 <quicksilver> as Axman6 said, there is no reason to use Float
03:09:27 <tangentstorm> well, okay, but there's no reason to use Double either if I can't actually print what i want to print... :)
03:10:00 <iamtakingiteasy> srhb: then i must be doing something wrong. here is the full code with added bang (kinda awkward, but i have no idea what think else about): http://hpaste.org/73513
03:10:51 <srhb> iamtakingiteasy: Looks identical. I get 837799
03:10:58 <iamtakingiteasy> >_<
03:11:37 <trem_> a project-euler - spoiler? :-)
03:11:42 <iamtakingiteasy> yeah
03:11:42 <srhb> Sorry!
03:11:45 <iamtakingiteasy> np
03:11:46 <tangentstorm> quicksilver / Axman6 : line 68 - 70 there... there has to be a better way to do loops than what i'm doing ... any thoughts?
03:12:12 <shachaf> aristid: OK, I'm going to sleep.
03:12:40 <srhb> iamtakingiteasy: Wait, are you compiling without optimizations?
03:12:44 <Axman6> tangentstorm: sorry just about to head out. others will be very helpful however
03:12:46 <quicksilver> tangentstorm: did you mean putStr " " by any chance?
03:12:52 <iamtakingiteasy> srhb: simple ghc --make crunch.hs
03:12:53 <aristid> shachaf: good night to you. good noon to me.
03:12:53 <quicksilver> tangentstorm: putStr "" seems a bit pointless
03:13:02 <srhb> iamtakingiteasy: Ah, there we have the difference.
03:13:21 <tangentstorm> quicksilver : yes. should be spaces, but i can't actually walk my tree yet so i didn't notice :)
03:13:30 <quicksilver> tangentstorm: assuming you did, then indent i = putStr (replicate i ' ')
03:13:56 <quicksilver> tangentstorm: could also be indent i = replicateM i (putStr " ")
03:14:04 <srhb> iamtakingiteasy: It runs with -O2
03:14:05 <quicksilver> replicateM is a simple loop in a monad
03:14:16 <quicksilver> but it seems to make more sense to build the indentstring in pure code
03:14:46 <srhb> iamtakingiteasy: I do admit I still don't see how that stack overflow would occur without optimizations. Guess you need to poke an expert, maybe on StackOverflow. I'd be interested. :)
03:15:15 <tangentstorm> quicksilver : hrm... ah, cool... maybe i want mapM for line 77 then? map of course didn't work and i was stuck
03:15:37 <srhb> Perhaps it's laziness in the list constructor? Hmm.
03:15:46 <quicksilver> tangentstorm: probably yes.
03:15:52 <iamtakingiteasy> srhb: with `ghc --make -O2 crunch.hs' it still crashes with SO
03:16:04 <quicksilver> tangentstorm: I'm not currently seeing what that code does
03:16:09 <iamtakingiteasy> ah wait
03:16:11 <quicksilver> iamtakingiteasy: did you delete the old .o files?
03:16:21 <quicksilver> changing optimisation levels wont' rebuild them.
03:16:24 <iamtakingiteasy> quicksilver: yeah, that what i missed
03:16:27 <shachaf> Which version of GHC is this?
03:16:36 <iamtakingiteasy> 7.4.1
03:16:48 <tangentstorm> quicksilver : nothing yet... i just wanted to walk through the tree and simultaneously apply a calculation and print the intermediate results at each step
03:16:49 <shachaf> Hmm, I'm pretty sure 7.4 does rebuild if you change -O
03:16:58 <iamtakingiteasy> it doesn't apparently
03:17:12 <srhb> Nope, definitely not.
03:17:51 <shachaf> Oh, weird.
03:18:16 <srhb> shachaf: Can you spot where the stack overflow is?
03:18:30 <iamtakingiteasy> btw, without bang pattern and with -O2 it doesn't crash
03:18:42 <shachaf> srhb: What code are we talkiing about?
03:18:52 <srhb> shachaf: http://hpaste.org/73513
03:19:22 <shachaf> srhb: Oh, that.
03:19:28 <srhb> I guess collatz should be made tail recursive..
03:19:31 <shachaf> Yes, the bang pattern shouldn't change it, now that I look at it.
03:19:37 <shachaf> No, why tail recursive?
03:19:50 <srhb> Shot in the dark, the list constructor must be the problem, right?
03:19:58 <srhb> I mean, where else can it happen.
03:20:03 <shachaf> What I said about bang patterns was nonsense -- the function is already strict in n.
03:20:13 <srhb> Why? O_o
03:20:21 <srhb> oh, because of the guards
03:20:22 <srhb> duh
03:20:27 <srhb> >_<
03:20:50 <iamtakingiteasy> guards can cause stack overflow?
03:20:53 <shachaf> That thing stack overflows?
03:20:58 <srhb> Yes, it does.
03:21:03 <srhb> iamtakingiteasy: And no, they are forcing the n
03:21:03 <iamtakingiteasy> without -O2 flag
03:21:04 <shachaf> iamtakingiteasy: No, but the guard has the same effect as the bang pattern.
03:21:07 <shachaf> So that shouldn't do anything.
03:21:09 <iamtakingiteasy> ah, i see
03:23:01 <shachaf> Oh, I know.
03:23:04 <shachaf> Wait, do I?
03:23:24 <srhb> length?
03:23:28 <srhb> hrmhrm no
03:23:48 <shachaf> Hmm, no.
03:25:22 <shachaf> Oh, wait, yes.
03:25:27 <shachaf> It's maximumBy.
03:25:27 <iamtakingiteasy> i got it?
03:25:38 <shachaf> @src maximumBy
03:25:38 <lambdabot> Source not found. My brain just exploded
03:25:47 <iamtakingiteasy> s/i/you/
03:25:52 <shachaf> maximumBy cmp xs = foldl1 maxBy xs where maxBy ...
03:25:59 <srhb> Oh, it's not strict..
03:26:14 <shachaf> If you copy maximumBy to your source file but change foldl1 to foldl1', it doesn't overflow.
03:26:30 <iamtakingiteasy> i see. thank you!
03:26:34 <shachaf> Presumably GHC figures out that the function is strict and optimizes it with -O2.
03:26:38 <shachaf> Kind of annoying.
03:27:23 <iamtakingiteasy> but why isn't maximumBy uses strict fold?
03:27:42 <iamtakingiteasy> just curious
03:27:42 <tangentstorm> quicksilver : mapM did what I wanted. thanks! now i can walk the parallel parts of the circuit. output at bottom of code in https://gist.github.com/3422302/e5c86f9d0bb86b19b0f23dbb7bee9674560f30b4  ... but where's foldrM ?
03:27:44 <shachaf> Because it's defined in the Report not to.
03:27:50 <iamtakingiteasy> oh
03:27:54 <shachaf> The Report doesn't have the strict functions at all, I think.
03:28:02 <shachaf> Everything there is defined with non-strict functions.
03:28:04 <quicksilver> shachaf: except seq itself :)
03:28:09 <shachaf> In practice it's not such a big problem with O2.
03:28:14 <aristid> quicksilver: is seq part of the report?
03:28:14 <shachaf> quicksilver: Sure.
03:28:16 <shachaf> @src sum
03:28:16 <lambdabot> sum = foldl (+) 0
03:28:21 <quicksilver> yes.
03:28:26 <shachaf> aristid: Definitely.
03:28:50 <shachaf> pseq isn't, but that's implementation business. seq is a very important denotational primitive that affects the language a lot.
03:29:15 <quicksilver> tangentstorm: there is a foldM in Control.Monad (which is a left fold) and foldrM in Data.Foldable
03:29:32 <srhb> maximumBy really ought to be strict. Seems like a bug in the definition.
03:29:39 <iamtakingiteasy> lol
03:29:49 <shachaf> srhb: That's arguable.
03:29:59 <shachaf> The people who wrote the Report argued the other way, anyway. :-)
03:30:00 <tangentstorm> quicksilver : thank you! i think i can finish this up now.
03:30:06 <shachaf> Just compile with -O2 when you want performance.
03:30:15 <int-e> aristid: foldl' and foldl1' were added in the haskell 2012 report, haskell 98 didn't have them.
03:30:19 <srhb> shachaf: I just can't think of use cases.. Ah well.
03:30:30 <shachaf> There's a Haskell 2012?
03:30:35 <srhb> I was just about to ask :P
03:30:42 <int-e> no. 2010
03:31:03 <int-e> I guess I get to type "2012" a lot more often.
03:31:14 <shachaf> int-e: But maximumBy still uses foldl1
03:31:18 <ocharles> uhhh, any conduit users around? If I do sourceFile "..." $$ sinkFile "..." I get :: m (), which is fine
03:31:25 <int-e> shachaf: right
03:31:55 <aristid> ocharles: go on
03:31:58 <ocharles> but if I do sourceFile "..." $= conduit =$ sinkFile "..." I don't, I get :: Source m Data.Void.Void
03:32:04 <ocharles> so how am I meant to run this?
03:32:16 <ocharles> why does fusing with a sink produce a source?
03:32:47 <aristid> i think you're meant to do sourceFile "..." $$ (conduit =$ sinkFile "...")
03:32:53 <aristid> the parens might not be necessary
03:33:02 <aristid> and you can put the $$ on either side
03:33:11 <ocharles> specifically: (sourceFile "before.txt" $= decode utf8) $= encode utf8 =$ sinkFile "combined.txt" :: MonadResource m => Source m Data.Void.Void
03:33:22 <ocharles> oh, I see
03:34:29 <ocharles> ah, yes: (sourceFile "before.txt" $= decode utf8 $= encode utf8) $$ sinkFile "combined.txt" :: MonadResource m => m ()
03:34:33 <aristid> ocharles: basically in the pipes-like concept you _can_ have pipes that have neither output nor input. that's this Source you get there.
03:34:34 <ocharles> that does the job
03:34:54 <aristid> ocharles: but ($$) is special-cased to unwrap that Pipe.
03:35:22 <aristid> you can unwrap it yourself, but just using ($$) is easier.
03:35:27 * ocharles nods
03:36:37 <aristid> i think this is all still way too confusing :/
03:36:58 <ocharles> it takes a bit of getting your head around it
03:37:07 <ocharles> i think conduits have lost there simplicity going into 0.5
03:40:29 <aristid> ocharles: well they internally are much more simple than in the pre-pipe days
03:40:36 <ocharles> right
03:40:39 <ocharles> ok, next question :)
03:41:11 <ocharles> I have a conduit, which is meant to read from a source (Text, Text) (which is fine, I have that from zip'ing 2 sources), and output everything where fst != snd, but at the moment it only outputs a single difference and then stops
03:41:22 <ocharles> yield seems to terminate the pipe. How do you yield and continue?
03:41:25 <aristid> ocharles: so the crazy thing is that internally you only need two composition operators now, but users are expected to use all of $$, $=, =$...
03:41:29 <ocharles> If my conduit is foo, should I yield "whatever" >> foo ?
03:41:59 <ocharles> maybe I want awaitForever
03:42:46 <ocharles> yay, that's got it!
03:42:53 <ocharles> now I have my own poor mans `diff` :)
03:43:19 <ocharles> except this one can actually handle the GB files I have
03:43:49 <aristid> ocharles: yield does not terminate the pipe
03:44:17 <ocharles> it's probably me just using a single 'await' then
03:46:28 <aristid> ocharles: awaitForever inner = awaitE >>= either return (\i -> inner i >> awaitForever inner)
04:10:44 <MarcWeber> A simple download application is 16MB in size using http-conduit complied for Windows (ghc-7.4). Is there any option I can use to reduce the size?
04:13:46 <quicksilver> it used to be with split-objs and a smart linker you could get smaller executables
04:13:51 <quicksilver> I don't know if that still works
04:15:18 <ocharles> is there a library on hackage to run Text values through regular expressions (substitution)?
04:15:26 <ocharles> or am I going to have to fudge around decoding and encoding?
04:16:35 <srhb> ocharles: Text.Regex? :-)
04:16:41 <srhb> Wait, it's called
04:16:43 <srhb> compat or something
04:17:16 <quicksilver> ocharles: http://hackage.haskell.org/package/text-icu
04:17:23 <quicksilver> srhb: Text.Regex is String only, is it not?
04:17:40 <srhb> Hmm, I was sure there was a Text counterpart, but now I can't find it. Perhaps I was just confused by the name.
04:17:45 <ocharles> quicksilver: awesome, this looks good
04:26:47 <randomclown> -funbox-strict-fields
04:26:53 <randomclown> heh "funbox"
04:27:52 <merijn> @quote lisp.without.defun
04:27:53 <lambdabot> Veinor says: <Veinor> can't spell -funbox without fun!  <djahandarie> Veinor, can't write LISP without defun :-(
04:33:20 <merijn> If writing a small webpage in Yesod would people recommend using Persistent + database or just use acid-state + haskell data structure?
04:34:15 <merijn> I guess acid-state would take up more memory if the dataset grows
04:34:47 <identity> http://hpaste.org/73517 <- Haskell exercise, defining fmap for Either, basically
04:34:51 <identity> Any takers?
04:34:57 <identity> (There is a question in the link)
04:36:25 <merijn> identity: You need help with the why question or with the actual code?
04:36:35 <identity> Basically the why question
04:36:41 <quicksilver> merijn: acid-state
04:36:42 <identity> I think I can handle defining fmap
04:37:02 <quicksilver> merijn: I would only use a database if I had specifically chosen to model my data relationally.
04:37:07 <quicksilver> which might be the right choice.
04:37:25 <quicksilver> (so, I'd never use Persistent - I'd use either acid-state, or a relational SQL style)
04:37:37 <srhb> identity: I think the only point is to obscure it slightly, but notice that EitherLeft is slightly different from Either, and has a slightly different functor instance.
04:37:41 <merijn> quicksilver: Suppose you have Map of id to article mappings, wouldn't that end up using a lot of memory keeping everything in RAM
04:38:01 <quicksilver> merijn: I don't know? It depends how many!
04:38:05 <identity> fmap for either would just be: fmap f (Right v) = Right (f v), and fmap _ left = left, no?
04:38:08 <merijn> identity: It's quite simple really, but to see why you need to be familiar with the notion that type functions also have types
04:38:17 <srhb> identity: In the typeclassopedia, the exercise is just to define the functor instance for Either e
04:38:29 <srhb> identity: Yes.
04:39:07 <identity> I see. Thanks. I'll take a crack at it.
04:39:12 <merijn> identity: Maybe is a type constructor/function, it takes an argument and returns something. In this case the "type of a type" (usually called kind) is *, and Maybe has kind * -> *
04:39:20 <quicksilver> I think the point of identity's "why" is simply that, because of a limitation in haskell, you can only ever define a Functor instance for a 2-parameter type by taking the *final* parameter as the variable.
04:39:27 <merijn> identity: i.e. Maybe takes a type as argument and returns a new type
04:39:31 <srhb> Oh.
04:39:40 <quicksilver> so with 'Either a b' you are forced to use 'b' as the variable.
04:39:46 <identity> quicksilver: Ah, I see.
04:39:47 <merijn> identity: Now, the definition of Functor is defined for types with kind "* -> *"
04:39:49 <quicksilver> and those newtypes give you access to the other option too
04:40:03 <quicksilver> so Either is a functor in two ways but the haskell language only lets us write one of them
04:40:08 <quicksilver> without using another wrapper type.
04:40:12 <srhb> Is there a type level flip? :-)
04:40:16 <quicksilver> yes
04:40:18 <identity> quicksilver: I understand. Thanks.
04:40:25 <quicksilver> newtype Flip t a b = Flip t b a
04:40:30 <srhb> Of course :P
04:41:04 <merijn> identity: Either has kind "* -> * -> *", whereas "Either a" has kind "* -> *", lacking a type level flip/sectioning you need the newtypes to work around the limitation to define a Functor that looks at the second argument of Either
04:41:18 <srhb> So the exercise is similar to implementing instance Functor (Flip Either e) ?
04:41:25 <srhb> Or really, identical.
04:41:29 <identity> merijn: I understand -- basically what quicksilver was saying
04:41:34 <merijn> identity: Yes
04:42:07 <merijn> quicksilver: I was hoping someone here had some kind of intuition on the memory usage of acid-state for that scenario, hence why I'm asking :p
04:42:54 <merijn> quicksilver: Considering the low memory budgets for many cheap VPS
04:42:59 <xz> will ghc's -fwarn-missing-methods warn if both of two methods with mutually recursive defaults are missing?
04:43:04 <xz> if not, how can I get a warning about that?
04:43:40 <xz> i think my infinite loop may be due to some bad instances or derivings
04:45:59 <parcs`> xz: you can't
04:46:31 <fmap> identity: `fmap _ left = left' is a type error
04:47:28 <merijn> fmap: How so?
04:48:52 <quicksilver> merijn: acid-state itself doesn't cost you much. The question is "would these haskell data structures fit in memory?"
04:49:03 <xz> parcs`: hmm that's annoying... do people not run into this problem much?
04:49:20 <xz> I guess I have to go look at all instances and derivings in my code manually...
04:49:25 <fmap> merijn: left is `Either e a', fmap is `(a -> b) -> Either e a -> Either e b'
04:49:31 <osfameron> the data structures aren't loaded into memory lazily?
04:49:39 <srhb> assuming I had data Flip t a b = Flip t b a, how would I go about writing the functor instance for Flip Either e?
04:49:56 <quicksilver> osfameron: Map is key-strict in any event.
04:50:03 <quicksilver> osfameron: but, I doubt it anyway.
04:50:18 <osfameron> ah
04:50:39 <quicksilver> it's hard to make general serialisation tools lazy in a useful sense
04:50:48 <quicksilver> and you may end up deferring IO to exactly the worst time.
04:50:58 <merijn> osfameron: I don't see anything in acid-state docs claiming or insinuating that it is fetched from disk on demand
04:51:01 <quicksilver> also, we don't call that laziness round here :)
04:51:36 <osfameron> oh?
04:51:41 <merijn> Well, I guess if it uses mmap internall it might get away with by letting the OS page it transparently (similar to Varnish)
04:51:56 <merijn> Is there an acid-state channel where I could ask? :p
04:52:07 <srhb> merijn: I think #happs knows a lot
04:52:40 <srhb> merijn: Lemmih is the author, I think?
04:53:00 <merijn> Hackage says DavidHimmelstrup
04:53:08 <srhb> That's him.
04:53:09 <dmwit> that is Lemmih
04:53:10 <merijn> Ah, yes
04:54:08 <quicksilver> osfameron: laziness is when you defer the evaluation of a pure expression until needed
04:54:27 <quicksilver> osfameron: you do this, because pure expressions are guaranteed to return the same result whenever you execute them
04:55:09 <quicksilver> osfameron: if you defer a piece of disk IO (or other IO) until needed, then it may turn into somethiing entirely different, or the handle may be closed and it may be an IO error which you have no sensible way to handle.
04:55:26 <quicksilver> osfameron: we don't call that laziness, we call it "vile", and "hideous" and "unforgiveable"
04:55:37 <quicksilver> sometimes we call it 'unsafeInterleaveIO' too.
04:55:51 <merijn> quicksilver: Well, you can do the IO "lazily" at a different (non-haskell) level
04:56:05 <merijn> By (as I said) using mmap and having the OS page your data on-demand
04:56:36 <merijn> That reduces memory pressure by reducing the number of active memory pages
04:56:40 <quicksilver> sure.
04:56:47 <jfischoff> how can I ensure that I am not using lazy IO?
04:56:49 <merijn> address space is cheap :p
04:57:10 <quicksilver> merijn: to some extent the disk cache does that for you even if you *don't* use mmap.
04:57:20 <quicksilver> readahead etc.
04:57:41 <quicksilver> but, I don't know if the on-disk format that acid-state uses is amenable to that kind of thing
04:58:15 <merijn> Me neither :p
05:00:20 <quicksilver> anyhow, certainly, acid-state is designed for the case when stuff fits in memory.
05:00:50 <quicksilver> but can't you manage the actual articles separately and just keep your metadata in acid-state?
05:00:55 <merijn> Ambitious new project! acid-state designed for stuff that doesn't fit in memory :p
05:01:49 <quicksilver> well, merijn, see the FAQ, last question : http://acid-state.seize.it/
05:03:30 <merijn> quicksilver: Yeah, srhb already pointed that out in #happs. Although, realistically I don't expect RAM to be an issue in the near future
05:03:37 <merijn> So I'll worry about it when it happens :p
05:04:00 <srhb> It's not difficult to move the data around at a later point if need be anyway. :)
05:05:06 <quicksilver> merijn: if RAM isn't going to be an issue in the near future
05:05:12 <quicksilver> than in the far future you will buy more RAM
05:05:27 <quicksilver> which will be cheaper than the food you will need to eat to think this one through.
05:05:32 <srhb> How much RAM can server systems run with these days anyway?
05:05:37 * srhb has no clue
05:05:43 <quicksilver> 128G is routine
05:05:48 <srhb> Nifty.
05:05:48 <quicksilver> much more for "serious" machines
05:06:04 <srhb> Thanks, it's been years and years since I was in that business.
05:06:25 <quicksilver> people have laptops with 16G after all :)
05:06:42 <srhb> RIght. I envy them. A friend of mine compiled Agda in 2 minutes. Took 40 on mine. Sigh!
05:08:11 <merijn> VPS tend to hang around 64-128MB, though
05:08:25 <merijn> The cheap ones, that is
05:11:12 <quicksilver> yes, RAM is the constraining resource for VPSes
05:12:53 <Botje> the one thing they can't oversell \o/
05:15:01 <quicksilver> Botje: they can with page deduplication?
05:15:24 <Botje> that sounds like more trouble than it's worth
05:15:37 <merijn> More likely by overcommitting :p
05:16:17 <shachaf> Hah, page deduplication between guests?
05:16:50 <quicksilver> Botje: not at all, it's very popular
05:17:10 <quicksilver> Botje: http://www.linux-kvm.org/page/KSM
05:17:11 <xz> are there any haskell reports after 2010?
05:17:20 <quicksilver> although KVM is by no means the only implementation
05:17:41 <dmwit> xz: no
05:17:44 <xz> there are some minor errors in chapter 5 of haskell 2010 report - where would be a good place to report them so it can be fixed?
05:17:46 <xz> dmwit: thx
05:17:57 <quicksilver> vmware call it "page sharing" http://www.vmware.com/support/ws55/doc/ws_performance_diskio.html
05:17:59 <merijn> xz: There's Haskell Prime (i.e. the "in development" version of the report)
05:18:40 <Botje> quicksilver: oh, okay. it needs application/library support.
05:18:46 <merijn> xz: I'm not sure, but the haskell-cafe mailing list seems like a good start?
05:19:05 <quicksilver> Botje: I don't think so. It's transparent to the guest.
05:19:31 <Botje> "KSM only operates on those areas of address space which an application has advised to be likely candidates for merging"
05:19:41 <quicksilver> Botje: to use it cooperatively in a single kernel requires the application to opt-in yes.
05:19:45 <Botje> unless you mean that the kvm userspace marks its guest memory as mergeable?
05:19:51 <quicksilver> exactly.
05:19:59 <Botje> ah.
05:20:06 <quicksilver> in the case of VM hosting, the entire guest is opted-in
05:20:25 <merijn> I guess that's a good way to eliminate the memory needed by for example the kernel
05:20:36 <Botje> and libc and stuff
05:20:37 <Botje> okay
05:20:39 <Botje> that's cool.
05:20:44 <quicksilver> and apache, and php
05:21:01 <quicksilver> (running PHP is essentially the only purpose of VPSes, right? :)
05:21:03 <merijn> quicksilver: Get with the times, no one uses those anymore xD
05:21:27 * hackagebot distributed-process-simplelocalnet 0.2.0.5 - Simple zero-configuration backend for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.0.5 (EdskoDeVries)
05:28:55 <jaxtr> ahh it's a wonderful day
05:29:40 <mun> hi
05:29:42 <mun> in logic, is there a way to distinguish between a definition and an equation?
05:29:52 <mun> e.g., does c ::= 0 mean that c is defined to be 0?
05:31:22 <krageon> In every programming language, provisions have been made to distinguish between definitions and equations
05:31:22 <dmwit> Distinguishing between the logic and meta-level is always hard.
05:31:32 <shurikas> definition is =, equation is ==
05:31:38 <dmwit> Typically, you will see some different typesetting for the two in papers.
05:31:51 <dmwit> But usually the distinction is left to context clues.
05:32:05 <dmwit> s/usually/often/
05:32:13 <mun> dmwit, right. but is ::= typically used?
05:32:23 <dmwit> I haven't seen ::= or := used very much.
05:32:25 <mun> or is that only used in something like BNF grammar?
05:32:40 <dmwit> If you did, with a brief sentence explaining your convention at the beginning of the paper, everyone will enjoy it.
05:33:24 <mun> dmwit, so if i want to type out some axioms, should the operator there just be =?
05:33:52 <dmwit> Pretty much, yup.
05:34:04 <int-e> mun: in principle, there is no need for such a distinction. adding "c = 0" as a axiom will act as defining c as 0.
05:34:11 <adinapoli> hi guys :)
05:34:14 <mun> yeah that was my next question
05:34:26 <mun> is there actually a need to draw a distinction between definitions and equations?
05:34:44 <dmwit> That depends on just how pedantic you're trying to be. =)
05:35:03 <DT`> mun, I've seen all of ≡, ≡_{def}, =_{def}, := and ::= being used as definition.
05:35:15 <shurikas> there is "a = 5" and "let a = 5"
05:35:48 <adinapoli> By chance, have someone read "Pearls of Functional Algorithm Design" by Richard Bird?
05:35:55 <ciaranm> adinapoli: yeah
05:35:57 <nand`> I have that book but I haven't finished it
05:36:02 <ciaranm> adinapoli: it's old school
05:36:15 <dmwit> new school is best school
05:36:24 <DT`> adinapoli, I skimmed it a bit, but I haven't finished it, too.
05:36:34 <adinapoli> got it. So you won'r recommend it?
05:36:41 <mun> is such a distinction useful only if one were mixing, say, theorems and definitions in the mix? e.g., suppose T is a theory T |- c ::= 0 and T |- c = 0 have slightly different meanings, as the inference is implied to be trivial in the former?
05:36:48 <ciaranm> adinapoli: oh, it's worth a read...
05:36:54 <adinapoli> just a tiny bg, I've already red LYHGG and skimmed over RWH
05:37:02 <mun> otherwise i can't quite think of why the distinction is needed....
05:37:15 <mun> DT`, oh yes, the x_{def} might be useful!
05:37:25 <adinapoli> I was searching for something to sharp my functional skills to a broader level
05:37:41 <ciaranm> adinapoli: Awodey is a better bet for that
05:37:42 <DT`> adinapoli, reading it won't do any bad, then.
05:37:43 * ciaranm runs and hides
05:37:45 <adinapoli> and also there exists a kindle edition of it :) so I asked :D
05:38:34 <adinapoli> sorry for the ignorance, Awodey stands for?
05:38:49 <merijn> adinapoli: The author of the book
05:38:50 <DT`> mun, as long people understands you, it doesn't matter which one you use. choose the one you like the best.
05:39:05 <merijn> adinapoli: I forgot the title, but googling his name should turn up the book
05:39:23 <mun> DT`, right. but do you know why some prefer the distinction to be drawn clear?
05:40:58 <adinapoli> I guess it's "Category Theory" by Steve Awodey right? :)
05:41:04 <DT`> mun, I don't know if there's a deeper reason, but I feel better separating the meta-logic from the logic, there's less source of confusion.
05:41:19 <ciaranm> adinapoli: that's the one
05:42:03 <mun> DT`, i see. but are definitions part of the meta-logic though? aren't they asserted within the object-logic?
05:42:04 <DT`> are TaPL and ATiTaPL still strong?
05:42:24 <ciaranm> DT`: meh
05:42:32 <ciaranm> particularly the latter
05:42:57 <merijn> What's ATiTaPL?
05:43:08 <adinapoli> Thanks for the tip, I'll take note :) Btw there is no kindle version, so if I want to read something "FP-ish" I have to stick with Functional Pearls I guess
05:43:18 <ciaranm> merijn: pierce cashing in on his fame
05:43:19 <dmwit> Advanced Topics in TaPL
05:43:20 <Expez> If I have something like putStrLn "Foo" >> getLine >>= putStrLn. Is it possible to insert pure functions into this sequence? Say I wanted to run (concat . drop 3 . words) on the result from getLine for instance.
05:43:41 <merijn> Expez: You probably want fmap
05:43:43 <merijn> :t fmap
05:43:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:43:50 <dmwit> putStrLn "Foo" >> getLine >>= putStrLn . concat . drop 3 . words
05:44:04 <dmwit> :t putStrLn "Foo" >> getLine >>= putStrLn . concat . drop 3 . words
05:44:05 <lambdabot> IO ()
05:44:12 <merijn> Expez: Note that IO is an instance of Functor, although I guess dmwit example also works
05:44:17 <DT`> mun, it depends. the logic might not even have ``definitions''.
05:44:27 <Expez> Cool, thanks guys!
05:44:39 <merijn> :t (<$>) -- or infix fmap
05:44:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:45:12 <DT`> ciaranm, I found them good. any better recommendation on the subjects?
05:45:20 <DT`> *subject
05:45:55 <ciaranm> DT`: what exact subject?
05:46:46 <DT`> ciaranm, type theory & type systems implementation.
05:47:17 <jpnurmi> anyone able to help with failing 'cabal install network'? http://hpaste.org/73521
05:48:12 <dmwit> Upgrade GHC, as we told you on StackOverflow. =P
05:49:17 <ciaranm> DT`: TaPL will do then
05:50:42 <jpnurmi> dmwit: you told me? good try, but i wasn't asking on stack overflow
05:50:50 <jpnurmi> thanks anyway :)
05:52:52 <dmwit> Okay, in that case, ghc --version?
05:53:08 <dmwit> If it's 6.12, the advice is "upgrade GHC, as we told that other guy on StackOverflow". ;-)
05:53:45 <jpnurmi> hmm, 7.4.1 as shown in the paste
05:53:53 <dmwit> huh
05:54:06 * dmwit looks more carefully
05:54:54 <int-e> jpnurmi: what parsec version do you have installed?
05:55:34 <int-e> (ghc-pkg list parsec)
05:55:50 <jpnurmi> int-e: 2.1.0.1
05:58:06 <int-e> hmm, network-3.1.3 is about a week old, let me try a build. but my guess is that parsec >= 3 will help.
05:58:47 <dmwit> Yep, looks like the type of notFollowedBy changed since parsec-2.
05:59:23 <int-e> (compiles fine with parsec-3.1.3 for me). Which means that the dependency listed in the network package needs a new lower bound
05:59:29 <dmwit> right
06:01:04 <dmwit> jpnurmi: Assuming you have a relatively recent cabal-install, try cabal install network --constraint 'parsec >= 3'
06:01:22 <dmwit> Oh, I see from above that you do have a quite recent cabal-install. So that should just work.
06:01:45 <jpnurmi> ok, let me try
06:04:53 <jpnurmi> looking good, since it takes so long to build :)
06:05:16 <jpnurmi> dmwit: int-e: works, thanks both!
06:19:48 <merijn> When will cabal finally get an uninstall command? :\
06:21:28 * hackagebot bson-generic 0.0.7 - Generic functionality for BSON  http://hackage.haskell.org/package/bson-generic-0.0.7 (PetrPilar)
06:22:15 <mm_freak_> merijn: don't hold your breath for it
06:22:43 <merijn> mm_freak_: Yeah, I figured
06:23:37 <mm_freak_> for the most part i find it sufficient to unregister packages
06:24:25 <merijn> Unrelatedly: The yesod mentions I should pick the "tiny" option for databases when I want to build a site with no datbase backing it, but when I run "yesod init" that's not a valid option? Any yesod users know the appropriate step to take?
06:31:22 <mun> could a function in FOL take functions as arguments? FOL only restricts on the order of the individuals being quantified, but if an expression doesn't involve quantifying over second-order or higher terms, would it still be valid in FOL?
06:31:54 <mun> e.g., f(g) where f :: ('a=>'b) =>'c and g:: 'a=>'b
06:32:12 <srhb> Does anyone know of a Parsec guide that uses a token parser? Most of the tutorials out there seem to take a different approach.
06:43:51 <quicksilver> mun: no.
06:44:06 <quicksilver> mun: in FOL, the domain for functions is things called "individuals".
06:44:27 <quicksilver> mun: and the functions themselves are not individuals.
06:44:42 <quicksilver> the individuals are just an unstructured set
06:44:48 <quicksilver> (in FOL, in my understanding)
06:50:55 <romildo> ghc-7.4.1 provides GHC.IO.Encoding.getForeignEncoding. Is there any equivalent in ghc-7.0.4?
06:52:16 * sopvop plz ignore: atheist snapped fay
06:53:13 <Botje> que?
06:53:51 <sopvop> just annoying some bots :)
06:53:58 <mun> quicksilver, right. but how come f(g) where f::('a=>'b)=>'c is not a valid FOL expression, given that there's no quantifier?
06:54:53 <quicksilver> "how come" ?
06:55:11 <quicksilver> because the rules for expression formation say that "f(g)" is valid when g is an individual
06:55:14 <quicksilver> not when g is a function.
06:59:43 <mm_freak_> every possible category i can think of has either only a single object, is one of the well known categories or is a poset category
07:00:02 <mm_freak_> a useful category that is
07:32:08 <mm_freak_> if C is a category with a single object, where every morphism is an isomorphism, then C is a group, correct?
07:33:48 <Cale> mm_freak_: yes
07:33:49 <DT`> mm_freak_, as far my limited understanding goes, yes, it should be.
07:33:55 <mm_freak_> thanks
07:34:35 <mm_freak_> and those isomorphisms are called automorphisms, right?
07:34:42 <Cale> Well, yes
07:35:03 <mm_freak_> sounds like there is a "but"
07:35:35 <Cale> In general, if C is any category and X is an object of C, then an automorphism of X is an arrow f: X -> X which is invertible.
07:35:45 <Cale> (i.e. is an isomorphism)
07:35:56 <srhb> What was the argument that I should use a TokenParser instead of just grabbing chars and strings directly with Parsec?
07:36:01 <Cale> and the set of all automorphisms of X form a group under composition
07:36:03 <mm_freak_> so endomorphism + isomorphism = automorphism?
07:36:07 <Cale> yes
07:36:15 <mm_freak_> makes sense
07:36:17 <mm_freak_> thanks
07:37:08 <mm_freak_> so in fact the automorphisms of every object form a distinct group?
07:37:09 <Cale> The reason groups are such a worthy object of study in my opinion is because essentially every object in mathematics has an automorphism group.
07:37:17 <Cale> yeah
07:37:19 <nand`> a category where every arrow is an isomorphism is also called a groupoid
07:37:25 <mm_freak_> very interesting
07:37:28 <nand`> perhaps unsurprisingly
07:39:22 <mm_freak_> does this mean that proofs regarding group theory can be lifted to category theory?
07:39:50 <mm_freak_> generic proofs like about the size of subgroups
07:40:16 <sclv> speaking from ignorance, i'd imagine you can embed them
07:40:35 <sclv> but if they use group structure, you're not really "lifting" them per se
07:40:49 <sclv> you're just searching and replacing some words
07:40:52 <quicksilver> some of them might have analogs, but most don't.
07:41:17 <typoclass> srhb: iirc you had some issue that when parsing "#0" vs. "#x", the parser for "#x" consumed the "#" and then failed on the "0"
07:41:18 <quicksilver> I mean obviously the subgroup size theorems apply to categories-which-happen-to-be-groups
07:41:26 <srhb> typoclass: Right
07:41:29 <quicksilver> (one object ones with every morphism iso)
07:41:51 <mm_freak_> well, the automorphism group may have subgroups
07:41:54 <quicksilver> but I think most things like that don't generalise in an interesting way to general categories + subcategories
07:42:29 <mm_freak_> then group theory proves that the order of every subgroup divides the order of the automorphism group
07:42:41 <mm_freak_> is that somehow applicable to CT?
07:42:55 <quicksilver> only within the automorphism group
07:43:01 <quicksilver> (where it really is exactly the same thing)
07:43:13 <quicksilver> I'm not aware of a generalisation to general finite categories.
07:43:16 <quicksilver> mind you I could be wrong :)
07:43:48 <quicksilver> finite categories were not a big part of the category theory I did.
07:43:57 <srhb> typoclass: Is it a general approach? To just use tokens instead? I suppose I could rather easily just determine "flow" by matching the # and then picking one of several paths from there.
07:44:10 <mm_freak_> the idea is:  if you can remove automorphisms of an object such that the remaining morphisms are still automorphisms, then the number of them is a divisor of the original number of automorphisms
07:44:14 <mm_freak_> does that make sense?
07:44:28 <mm_freak_> that sounds like a functor
07:46:19 <xmattdh> I'm still reading LYAH from yesterday and I must be missing something out since the book appears to be telling me to do things without explaining why or how they work... Maybe I should just reread the entire thing.
07:46:21 <nand`> well if you can turn the set of all automorphisms on an object into a group and apply the theorem there then I don't see the problem
07:46:32 <srhb> xmattdh: How far are you/
07:46:46 <xmattdh> I'm on the Texas Ranges chapter
07:46:53 <nand`> since you can show that no automorphisms exist outside this group the same statement must be true for the automorphisms
07:46:55 <srhb> xmattdh: And what did you feel was left unexplained? I think your best bet is to supplement with knowledge from here and elsewhere on the interwebs
07:47:12 <quicksilver> nand`: the set of automorphism on an object is always a group
07:47:16 <quicksilver> so it's just the same theorem.
07:47:25 <quicksilver> I'm not seeing it 'generalising'.
07:47:30 <quicksilver> it just 'embeds' - it's not new ideas.
07:47:31 <nand`> neither am I
07:48:32 <srhb> xmattdh: What I do, which I recommend if you can stand it, is take notes, especially with questions to myself. "What does it mean when lyah says...?" and then return or ask elsewhere.
07:48:33 <xmattdh> •srhb• Without really explaining what it does or what it means I am told to use this' '[ x | x <- [50..100], x `mod` 7 == 3]', I do not understand that at all and there does not appear to be an explenation. The issue is likely to be my extremely poor understanding of maths.
07:48:49 <typoclass> srhb: i have no idea. i usually just take a String and whack it with Prelude.lines and words and split. whenever i try parsec, it ends up being a complicated mess of "try" everywhere :)
07:48:55 <typoclass> i think i have some rare disease, something like dyslexia, that makes me unable to write straightforward parsec code
07:48:56 <srhb> xmattdh: Ah yes, he assumes the knowledge of set comprehensions
07:48:57 <mm_freak_> more concretely:  given a category C with a single object X where every morphism is an automorphism and there are p morphisms, where p is a prime, an endofunctor F : C -> C is either the identity functor or maps every morphism to id
07:49:07 <xmattdh> Oh
07:49:15 <srhb> xmattdh: It is fairly well explaining right under "I'm a list comprehension"
07:49:16 <mm_freak_> that would be an implication of group theory that is lifted to category theory…  does that make sense?
07:49:34 <nand`> xmattdh: perhaps it would help if I read it out loud: “the list of all x in [50..100] for which x `mod` 7 equals 3” ?
07:49:38 <quicksilver> mm_freak_: but it's not a generalisation. It's just the same theorem.
07:50:02 <xmattdh> I'm reading that now, attempting to understand
07:50:05 <quicksilver> mm_freak_: if you could use the same proof to prove something with a weaker antecedent than "with a single object X where every morphism is an automorphism"
07:50:12 <quicksilver> mm_freak_: then it would be a generalisation.
07:50:19 <srhb> xmattdh: But yeah, knowing that the pipe is read "for which it is true that... " helps a lot :-)
07:50:28 <quicksilver> because "category C with a single object X where every morphism is an automorphism" is just a long handed way to say "group"
07:50:43 <mm_freak_> quicksilver: i'm not saying it's a generalization…  it's just interesting that i can lift proofs from group theory
07:51:00 <deggis> uh, expected text-0.11.2.1:Data.Text.Internal.Text, actual T.Text (Data.Text as T) ideas?
07:51:22 <Cale> mm_freak_: It would be more interesting if you could weaken the conditions on them so that they don't just apply to groups-in-disguise
07:51:31 <mun> quicksilver, right. so you mean the rule of formation in FOL says that f(g) is valid as long as g is within the domain of f, despite the type of f? e.g., f could be 3rd or 4th order and it'd still be valid?
07:51:37 <nand`> mm_freak_: surely that could be extended to an arbitrary category in which every object has a prime number of automorphisms; F : C -> C maps every automorphism to itself or id; not sure how useful that'd be
07:51:39 <srhb> xmattdh: Though that should probably be shortened to "for which" so you can read <- as "is drawn from" :-)
07:51:57 <geekosaur> deggis, that usually means you have multiple versions of Data.Text installed and different things are using different versions
07:52:01 <mm_freak_> i'm still very new to CT and trying to find applications =)
07:52:02 <quicksilver> mm_freak_: in the nicest possible way it isn't interesting :) It's just like saying "a bench in Paris is also a bench in France (but it's still in Paris)".
07:52:17 <typoclass> xmattdh: it's unfortunate if lyah didn't explain list comprehensions sufficiently, but they're a fairly minor feature in my opinion. the function 'map' is much more common, at least in my code ...
07:52:22 <mm_freak_> quicksilver: interesting for me as a newbie
07:52:28 <quicksilver> mm_freak_: ok :)
07:52:29 <xmattdh> •srhb• But it still seems to assume I have knowledge... Of what?
07:52:30 <mm_freak_> i think this is an important step to understand CT
07:52:38 <srhb> xmattdh: Set comprehensions from math
07:52:43 <mm_freak_> understanding the power and expressiveness
07:52:48 <srhb> xmattdh: Most everyone see them in high school. But don't worry, it's a minor syntactic sugar.
07:53:04 <mm_freak_> because before i have only seen a large number of complicated definitions which didn't make sense to me =)
07:53:08 <xmattdh> I have an incredibly poor understand of maths, my most major downfall when understanding things such as that.
07:53:21 <nand`> xmattdh: perhaps a simple example would suffice to show the workings?
07:53:27 <nand`> > [ x | x <- [1..10], x < 5 ]
07:53:28 <lambdabot>   [1,2,3,4]
07:53:36 <nand`> read out loud “the list of all x from [1..10] for which x < 5”
07:53:46 <srhb> xmattdh: Really, all you need to know is how to pronounce it, the rest is obvious. [x^2 | x <- [1..10], x^2 < 50] becomes x squared for which x is drawn from 1 to 10 and for which x^2 is less than 50
07:53:52 <srhb> etc.
07:53:58 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
07:53:59 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
07:53:59 <typoclass> > filter (< 5) [1..10]
07:54:01 <lambdabot>   [1,2,3,4]
07:54:12 <srhb> Cale: Evil! :P
07:54:24 <deggis> geekosaur: ah, right. rings a bell
07:54:35 <xmattdh> Ok, I'll try and understand that now. I'm sorry that I'm so... Bad at understanding this.
07:54:39 <nand`> > [1 .. min 5 10]
07:54:40 <lambdabot>   [1,2,3,4,5]
07:54:45 <srhb> xmattdh: Don't, and don't bother getting stuck there.
07:54:46 <nand`> :(
07:54:49 <srhb> xmattdh: It is a minor feature.
07:54:51 <srhb> xmattdh: Move on. ;)
07:55:01 <Cale> xmattdh: It's okay. In fact, nobody has yet bothered to really explain what this is syntax sugar for.
07:55:03 <sclv> if you're only talking about a single sort of concrete category, you might as well just be talking about the things inside the category with different names. CT really comes alive when you have multiple categories, with functors and natural transformations and the like.
07:55:36 <srhb> Anything but the intuitive understanding at this point would surely scare you away forever. :P
07:55:39 <xmattdh> I think I get it now!
07:55:43 <srhb> Yay!
07:55:43 <typoclass> > [ x | x <- [50..100], x `mod` 7 == 3] -- xmattdh
07:55:44 <lambdabot>   [52,59,66,73,80,87,94]
07:55:48 <typoclass> > filter (\x -> (x `mod` 7 == 3)) [50..100]
07:55:49 <lambdabot>   [52,59,66,73,80,87,94]
07:55:57 <nand`> > [1,2,3] >>= (>>=) [4,5] . (,)
07:55:58 <lambdabot>   Couldn't match expected type `[b]' against inferred type `(t, t1)'
07:56:00 <nand`> :(
07:56:06 <nand`> oh
07:56:09 <nand`> missing a return
07:56:28 <Cale> xmattdh: (though I agree with them that the intuitive understanding of making selections in all possible ways and then insisting that certain conditions hold is much better to have before you try to understand the translation)
07:56:32 <xmattdh> So, let me check... x | x <- [1..10], x < 5 is basically drawing all the numbers from 1 to 10 that are < 5
07:56:35 <xmattdh> ?
07:56:39 <Cale> yes
07:56:54 <xmattdh> Achievement Get.
07:56:59 <nand`> > [ x ++ "!!!",  x <- ["yeah", "wow", "cool"] ]
07:57:00 <lambdabot>   <no location info>: parse error on input `<-'
07:57:00 <srhb> xmattdh: Ding :-)
07:57:02 <nand`> bah
07:57:06 <nand`> > [ x ++ "!!!" | x <- ["yeah", "wow", "cool"] ]
07:57:07 <Cale> Well, it picks x from [1..10] in all possible ways, and then insists that x < 5 before allowing that choice to become part of the list
07:57:09 <lambdabot>   ["yeah!!!","wow!!!","cool!!!"]
07:57:15 <srhb> > concat it
07:57:16 <lambdabot>   Not in scope: `it'
07:57:20 <srhb> baw :<
07:57:24 <Cale> > [10*x | x <- [1..10], x < 5]
07:57:26 <lambdabot>   [10,20,30,40]
07:57:47 <nand`> > [ 4 | x <- [1..10] ]
07:57:49 <lambdabot>   [4,4,4,4,4,4,4,4,4,4]
07:58:24 <xmattdh> I forget what the pipe means
07:58:47 <srhb> xmattdh: for which...
07:58:52 <xmattdh> Ok, sorry
07:58:57 <nand`> srhb: no that would be the comma
07:59:14 <srhb> nand`: Not if you pronounce <- drawn from :)
07:59:30 <srhb> I mean, it doesn't REALLY hold up to regular set builder notation
07:59:34 <nand`> you could try reading it as ‘for all’;  ‘10*x for all x drawn from [1..10] for which x < 5’
07:59:53 <nand`> but strict reading methods only get you so far
08:02:05 <xmattdh> Moving onto Tuples in LYAH
08:02:32 <srhb> xmattdh: Now there's something that you will probably use a lot :-)
08:04:18 <mwcampbell> I'm a little confused about how to use Haskell with something that has its own event loop, like a GUI toolkit. In _Real World Haskell_, there's an example that uses gtk2hs. This example sets up a GTK+ timer that runs every 100 ms to call yield so other Haskell threads can run. Couldn't this be avoided by using the multithreaded RTS?
08:04:19 <knz> hi all
08:04:43 <knz> I'm polling technically-minded people to help shape up a CS curriculum next year -- care to provide some input? http://tinyurl.com/d8yogwb
08:05:59 <quicksilver> mwcampbell: yes, it can.
08:06:22 <quicksilver> mwcampbell: although you have to be careful not to call any GUI calls from those threads, since GTK is not reentrant
08:06:27 <quicksilver> (in common with almost all GUI libraries)
08:06:38 <mhitza> do you guys know of any incremental csv parsing library?
08:07:26 <sclv> mhitza: http://hackage.haskell.org/package/csv-enumerator-0.10.1.1
08:07:41 <mhitza> sclv thanks, I'll check that out
08:07:43 <mwcampbell> quicksilver: So is it common in Haskell applications with a GUI to call yield from the GUI event loop as this example does?
08:10:13 <quicksilver> mwcampbell: no, personally I just use threads as you suggested.
08:10:39 <quicksilver> mwcampbell: although if you want to (for example) do animations then of course you need to ask the GUI event loop to wake up once per frame.
08:10:41 <timemage> mwcampbell, it may just be they wanted the opportunity to support cooperative multitasking.
08:11:30 <srhb> knz: Good job on that, it was even enjoyable. ;)
08:13:08 <armlesshobo> so, is (->) also a Functor? I don't see it when I do :i (->), so I guess not.
08:13:22 <srhb> armlesshobo: It is.
08:13:42 <srhb> armlesshobo: And you'd do :i Functor
08:13:48 <typoclass> armlesshobo: you may have to import something. try Control.Monad.Instances
08:13:52 <srhb> Oh hang on, that might be Contr -- yeah
08:13:54 <srhb> :P
08:14:27 <armlesshobo> ahhh
08:14:30 <armlesshobo> ok thank you
08:14:40 <quicksilver> srhb: you would see it from :i (->) also
08:14:46 <srhb> Oh really, I did not know that.
08:14:50 <quicksilver> instances show up under the type and the class both
08:14:51 <srhb> Shiny!
08:14:52 <quicksilver> with :info
08:14:57 <srhb> Great to know :D
08:15:22 <srhb> Hmm. But then it even finds non-imported things? That can't be right.
08:15:31 <typoclass> @info Shiny
08:15:31 <lambdabot> Shiny
08:15:41 <quicksilver> srhb: I don't think so. You do need to have it imported
08:15:50 <EvanR> armlesshobo: (->) has kind * -> * -> * so it cant be a functor
08:16:08 <abhi_> hi
08:16:24 <quicksilver> while that's true, it's very common to call the (->) r instance as if it was an instance for (->)
08:16:39 <EvanR> eh?
08:17:02 <quicksilver> EvanR: there is a Functor instance for (->) r
08:17:05 <EvanR> yeah
08:17:10 <quicksilver> EvanR: it's very common to call that a Functor instance for (->)
08:17:14 <EvanR> weird
08:17:17 <quicksilver> even though your remark was correct.
08:17:32 <quicksilver> just like one talks of the Monad instance for Either
08:17:34 <typoclass> we also say "the either monad", where it's technically the "the either e monad" or whatever, right?
08:17:41 <quicksilver> precisement.
08:17:43 <EvanR> i talk about monad instance for Either e
08:17:54 <quicksilver> then you are a precise man and we should applaud you :)
08:17:58 <ocharles> Calling it the (r ->) monad would actually probably be even more useful
08:18:11 <srhb> ocharles: What, the functor? :-)
08:18:26 <ocharles> the understanding of it (providing a fixed environment
08:18:28 <typoclass> i don't see what's unclear about "either monad", or what problem is resolved by the added precision ...
08:18:36 <ocharles> it takes a lot to get your head around '(->) r' meaning that
08:19:08 <EvanR> typoclass: because monad types have to be type constructors with one argument not two
08:20:29 <EvanR> which is important if you plan on inventing new monads ;)
08:20:49 <EvanR> but i daresay also if you intend to use existing ones
08:23:07 <ocharles> kinds. kinda important.
08:23:59 <typoclass> EvanR: yes they have one argument. (i said that a moment ago.) but it is not the case that there's an either monad, and additionally an either e monad, and people could easily confuse them. there is no potential for confusion, hence there is nothing wrong with the shorthand "the either monad"
08:24:41 <EvanR> well im not confused
08:29:16 <scooty-puff> are there any good examples of deforestation for explicitly infinite streams (data Stream a = a :| Stream a)?
08:34:39 <deggis> uh. what on earth is happening here, ghci session http://hpaste.org/73529
08:36:31 <deggis> i could not reproduce that with clear session & simpler types yet
08:37:58 <fmap> > [1,2,3] == [1,3,2]
08:38:00 <lambdabot>   False
08:38:20 <deggis> ah right, hmm
08:38:26 <srhb> > fromList [1,2,3] == fromList [1,2,3]
08:38:28 <lambdabot>   No instance for (GHC.Classes.Eq (m a))
08:38:28 <lambdabot>    arising from a use of `GHC.Classe...
08:38:30 <srhb> Aww.
08:39:50 <t7> is that Set from list?
08:39:53 <t7> :t fromList
08:39:54 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
08:40:16 <ocharles> :t fromList [1, 2, 3]
08:40:17 <lambdabot> forall a (m :: * -> *). (Num a, MonadRandom m) => m a
08:40:29 <t7> > Data.Set.fromList [1,2,3] == Data.Set.fromList [1,2,3]
08:40:31 <lambdabot>   Not in scope: `Data.Set.fromList'Not in scope: `Data.Set.fromList'
08:40:57 <deggis> aaaah. there never was a bug. when i reduced that list length to 5 i still could not see that it was a permutation
08:41:07 <xmattdh> heading back into LYAH territory I don't understand
08:41:13 <fmap> > let xs ==? ys = ((==) `on` sort) xs ys in [1,2,3] ==? [1,3,2]
08:41:15 <lambdabot>   True
08:41:47 <srhb> xmattdh: What's up?
08:41:55 <deggis> thanks for this sanity check
08:42:24 <dropdrive> Is there a way to wrap a function f :: a -> IO b into f' :: a -> IO b that simply calls f and caches the result to disk, and reads from this cache when passed the same value for a?
08:43:01 <t7> like memoize?
08:43:08 <dropdrive> I guess we need to assume (Eq a, Serialize a, Serialize b).  Yes, like memoize.
08:43:13 <xmattdh> I've reached the Types and Typeclasses section, but now I've found that I don't understand the meaning of things such as 'removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]' and almost everything else in that chapter.
08:43:28 <xmattdh> This is going to be a recurrence throughout the book, me not understanding things.
08:44:06 <srhb> xmattdh: Do you understand what c `elem` [...] means?
08:44:12 <t7> dropdrive: the wiki says write it yourself
08:44:14 <srhb> > 1 `elem` [2,3]
08:44:16 <t7> :*(
08:44:16 <lambdabot>   False
08:44:18 <srhb> > 2 `elem` [2,3]
08:44:19 <lambdabot>   True
08:44:21 <xmattdh> None of that
08:44:23 <dropdrive> t7: I know, so I came here :-(
08:44:36 <srhb> xmattdh: So elem is a function that takes an element and tells you if it's in a list
08:44:37 <xmattdh> And as usual I couldn't find an adequate explenation in LYAH
08:44:45 <srhb> xmattdh: I'm sure it's there..
08:44:51 <t7> i would just wrap with an IO Var Map thing
08:45:01 <xmattdh> Which chapter?
08:45:21 <dropdrive> t7: Anyway, my follow-on question is, is there a way to automatically invalidate the on-disk cache if the implementation of f changes?
08:45:25 <srhb> xmattdh: Either way, elem is just a function which has a name that's more or less obvious. But you can always look it up at hoogle :)
08:45:28 <srhb> @hoogle elem
08:45:29 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
08:45:29 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
08:45:29 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
08:45:40 <dropdrive> t7: IO Var Map thing?
08:45:50 <srhb> xmattdh: As you learned before the predicate part of a list comprehension restricts the elements that get through. Only those for which the predicates are true get through
08:46:17 <t7> IOVar
08:46:21 <t7> is that a thing
08:46:36 <srhb> xmattdh: isUpperCase c = c `elem` ['A'..'Z'] -- do you grasp this function intuitively?
08:47:11 <dropdrive> t7: IOVar does not appear to be a thing.
08:47:15 <srhb> > 'a' `elem` ['A'..'Z']
08:47:17 <lambdabot>   False
08:47:19 <srhb> > 'T' `elem` ['A'..'Z']
08:47:20 <lambdabot>   True
08:47:28 <t7> yeah its gonna get messy unless you wrap in a monad
08:47:34 <t7> like State or something
08:47:45 <dropdrive> t7: Do you know of any libraries that do this?
08:47:59 <xmattdh> Probably missed something out during reading, but unfortunately I couldn't grasp what a predicate is
08:48:20 <dropdrive> xmattdh: What languages are you familiar with?
08:48:22 <t7> dropdrive: yeah look on hackage
08:48:28 <srhb> xmattdh: A predicate is something that is either True or False for its argument. In this case, the predicate is things like x>4 or c `elem` ['A'..'Z']
08:48:29 <edwardk> roconnor: pong ;)
08:48:42 <srhb> xmattdh: If the predicate is true, the element is included, otherwise it is not.
08:50:04 <srhb> xmattdh: [x | x <- [1..10], x<5], [c | c <- foo, c `elem` ['A'..'Z']] -- the predicate is the last thing in these two. for those x, c where it is true, the element is included in the list.
08:50:07 <typoclass> xmattdh: predicate is just a fancy name for a function that gives Bool. you put in a Char or whatever, and the predicate isUpper gives True or False, telling you if it's an upper-case letter
08:51:00 <typoclass> @hoogle isUpper
08:51:00 <EvanR> predicate is also a fancy name for some esoteric c++ stl thing
08:51:01 <lambdabot> Data.Char isUpper :: Char -> Bool
08:51:02 <xmattdh> At a guess, ' 'T' `elem` ['A'..'Z']' checks if 'T' is in the list ['A'..'Z'] and returns a Bool as it's result - again that is probably wrong
08:51:13 <srhb> xmattdh: No, that's right
08:51:30 <typoclass> btw, the function toUpper i mentioned is a predefined thing from module Data.Char, as you can see above
08:51:31 <srhb> > 'T' `elem` ['A'..'Z'] -- xmattdh
08:51:33 <lambdabot>   True
08:51:37 <srhb> Notice that lambdabot tells us the result
08:52:23 <xmattdh> I understand what it does, but not the syntax
08:52:32 <dropdrive> > let x = 1:x:x in x `elem` x
08:52:32 <srhb> xmattdh: `foo` makes foo infix
08:52:32 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
08:52:39 <srhb> > elem 'T' ['A'..'Z']
08:52:40 <lambdabot>   True
08:52:41 <srhb> Same thing
08:53:14 <mm_freak_> > [x|x<-[x|x<-[x|x<-[x|x<-[x|x<-[x|x<-[x|x<-[x|x<-[]]]]]]]]]
08:53:16 <lambdabot>   []
08:53:30 <EvanR> let x = 1:x:x in x doesnt work because x cant be a list type of itself
08:54:52 <typoclass> xmattdh: normally, you write "foo 1 2" to apply function "foo" to the two arguments 1 and 2. you can equivalently also write "1 `foo` 2" if that makes things more readable. for example, most people find "1 `elem` [3..50]" more readable than the equivalent "elem 1 [3..50]"
08:55:14 <trem_> whew, i just managed to let GHC produce a 4000+ line error message. but it produces a running executable anyway. neat.
08:55:44 <EvanR> if it compiles its good, if it boots up its perfect
08:56:16 <fmap> and [3..50] is more readable than `enumFromTo 3 50' ;)
08:56:59 <EvanR> lispers are crying because of your remark
08:57:28 <Jesin> hmm
08:57:40 <Jesin> by the way
08:58:56 <Jesin> when defining, say
08:59:04 <Jesin> instance Enum Foo
08:59:25 <Jesin> is it possible to define the functions like, for example
08:59:52 <Jesin> instance Enum Foo where
08:59:53 <Jesin>   [a,b..c] = funcbody
08:59:55 <Jesin> ?
09:00:17 <Jesin> or does it have to be enumFromThenTo a b c = funcbody
09:00:28 <Cale> Jesin: I think not, but that would be super-cute if so.
09:00:42 <Cale> (why not try it?) :)
09:01:08 <EvanR> i know it doesnt let you define mappend using <>
09:01:18 <EvanR> but thats not syntax sugar
09:02:33 <xmattdh> > :t (>)
09:02:35 <lambdabot>   <no location info>: parse error on input `:'
09:02:46 <quicksilver> most of the GHC sugar desugars straight to core
09:02:48 <EvanR> :t (>)
09:02:49 <lambdabot> forall a. (Ord a) => a -> a -> Bool
09:02:50 <quicksilver> not into haskell
09:02:56 <xmattdh> :t (>)
09:02:58 <lambdabot> forall a. (Ord a) => a -> a -> Bool
09:02:59 <quicksilver> which means it's not valid on the left of a definition
09:03:00 <xmattdh> Ah
09:03:02 <quicksilver> I'm only guess, though.
09:03:16 <quicksilver> [a,b,c] is valid on the left of course.
09:04:50 <Yiq> How would I connect 2 people via webcam over a server in Haskell?
09:05:23 <sopvop> How would you do it without haskell?
09:05:23 <Yiq> Do I need to implement a protocol or can i just stream something via pipes?
09:05:59 <EvanR> get them to connect directly
09:06:13 <EvanR> man in the middle is so 2000s
09:06:16 <Clint> you could use xmpp/jingle
09:07:08 <Yiq> EvanR: yes but for chatroulette type webapp it is impossible i have been told unless they have to download a GUI-client that connects them. This because of same-origin-policy
09:11:01 <xz> does haskell have a formal (mechanised) semantics?
09:11:35 <Cale> xz: Someone wrote out the semantics for an earlier version
09:11:36 <EvanR> Yiq: you need a gui client anyway
09:11:58 <EvanR> unless you want ascii art webchat
09:12:11 <xz> Cale: any pointers? or do you know if it was formal and/or mechanised?
09:12:53 <Cale> xz: http://www.haskell.org/haskellwiki/Language_and_library_specification
09:13:24 <xz> At a glance, everything on that page looks informal
09:13:31 <xz> I have read the 2010 report
09:13:33 <Cale> At the very bottom of the page, there are links to some old papers
09:13:54 <Yiq> EvanR: chatroulette doesnt have a GUI, it is just a webapp.
09:13:59 <Cale> "The Static Semantics of Haskell"
09:14:04 <EvanR> Yiq: thats a gui
09:14:35 <xz> Cale: Thanks. Looks informal as well, but I'll have a read and/or email the author :)
09:14:43 <EvanR> and if youre talking about web browsers, then thats your protocol
09:14:48 <EvanR> its already defined
09:15:03 <Cale> looks formal to me
09:15:06 <Yiq> well, i think people would not mean a webapp if they said GUI. what i emant was they need a standalone gui to conenct to each other. i cant connect people direct to each other using a webapp. or so ive been told
09:15:08 <Cale> at least, the parts which are in boxes
09:15:19 <loreints> hey, I'm having a lot of trouble trying to get my parse example to work. I think I'm misunderstanding the type errors I'm getting, but I'm not sure. It's the instance Monad Parse (line 17): aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
09:15:30 <loreints> lol: https://gist.github.com/3427097
09:15:35 <EvanR> Yiq: which is unfortunate
09:15:36 <xz> Cale: yes, you're right. but it's probably not mechanised.
09:16:31 <Cale> By mechanized, do you mean implemented in a theorem prover?
09:17:07 <loreints> Specifically, my top case of Right (a, s) returning Right (a, s) somehow causes a type conflict, whereas the return immediately above returns the same type without causing an error.
09:17:29 <ReinH> morning
09:17:39 <EvanR> loreints: do you have a hpaste of source
09:17:50 <Yiq> lets say just 2 friends want to connect via webcam, how would they do it? they have each others IP. how woudl they connect?
09:18:15 <ReinH> So I'm looking at this http://www.haskell.org/haskellwiki/Principal_variation_search
09:18:25 <ReinH> and I have to say, those search algorithms don't look very... good
09:18:26 <EvanR> Yiq: xawtv
09:18:26 <loreints> EvanR: http://hpaste.org/73532
09:18:50 <loreints> Yiq: flash rtmfp
09:19:35 <EvanR> loreints: you have indentation problems
09:19:46 <EvanR> cases need to be indented more than the word case
09:20:08 <EvanR> case x of
09:20:12 <EvanR>   A ->
09:20:13 <EvanR>   B ->
09:20:56 <loreints> okay, I did that but I'm still getting the same error
09:20:59 <msa-baba> hi
09:21:26 <loreints> so the parser doesn't detect bad formatting?
09:23:40 <ReinH> it detects bad formatting; it can't detect ambiguous formatting.
09:24:34 <Yiq> loreints: id have to implement that protocol then?
09:24:59 <msa-baba> smtp server needed
09:25:11 <msa-baba> can any one help me out
09:25:21 <ReinH> loreints: wait, when you say parser are you talking about the Haskell parser or your own parser?
09:25:33 <ReinH> msa-baba: can you be a bit more specific?
09:25:59 <EvanR> loreints: repaste the new code, and paste the actual error too
09:26:04 <EvanR> in the hpaste
09:27:38 <msa-baba> p server for sending bulk message
09:27:46 <loreints> Yiq: http://labs.adobe.com/technologies/cirrus/samples/#resources and the oss implementation of stratus is https://github.com/OpenRTMFP/Cumulus
09:28:20 <loreints> Reinh: the haskell built in source parser; I'm nowhere near writing a parser myself
09:28:47 <ReinH> loreints: just making sure. Agree ith EvanR, please hpaste current code and current error
09:28:57 <loreints> EvanR: http://hpaste.org/73533
09:29:00 <ReinH> msa-baba: google is your friend
09:29:35 <loreints> error: http://hpaste.org/73534
09:32:09 <trem_> i'm getting some enormous output on stderr from GHC when compiling, starting with the line "dmdFix loop" and then it goes on for like 13000 lines. should I be worried?
09:33:23 <trem_> i found some discussion about it regarding old versions of GHC, suggesting it might be some kind of debug output. still, it makes it hard to see "real" warnings
09:33:42 <srhb> trem_: I bet you should't see that, do a bug report?
09:33:43 <EvanR_> you can redirect stderr or upgrade ghc
09:34:27 <trem_> srhb, i will file a bug
09:34:39 <srhb> trem_: Only if you're on the newest ghc, right? :-)
09:35:00 <trem_> EvanR_, i'm on 7.4.1 which is the latest I can get my hands on with fedora (at least without compiling)
09:36:10 <trem_> anyone likes to check if the message comes up for him/her running latest GHC before I file a bug? it's on github
09:36:43 <loreints> trem_: I have fedora 17, if you could direct me at the repo and tell me what to run I'll try
09:37:03 <EvanR_> trem_: well thats not really true but ok
09:37:06 <EvanR_> new enough
09:37:20 <trem_> loreints, you have something more recent than 7.4.1 on F17?
09:38:33 <trem_> the code is here: https://github.com/waldheinz/bling
09:39:04 <trem_> just checkout / cabal configure / cabal build should be enough. the problem is when it compiles the SPPM.hs module
09:39:48 <trem_> (it uses the LLVM backend by default, maybe you have to disable that if you don't have LLVM installed)
09:42:18 <loreints> trem_: I installed ghc through the repo and I have 7.0.4, so I don't think I can help much
09:46:04 <loreints> did you install ghc manually or is there a way to use the fedora 18 v or something? I usually use debian, only started trying fedora recently.
09:46:28 <EvanR_> make install represent
09:46:37 <EvanR_> all the way baby
09:46:48 <trem_> EvanR_, what's that?
09:47:13 <EvanR_> my own insanity catching up with me
09:47:40 <trem_> loreints, I installed it from the rawhide repo, there was a blog post about how to do it recently, also featured on reddit
09:49:56 <nh2> I'm slightly confused with some stacks. How do I turn c1 :: Conduit Int (S.StateT Int IO) Int into c2 :: Conduit Int IO Int?
09:49:58 <loreints> trem_: okay, I'll try that in a sec
09:50:05 <nh2> alias: where do I put the runStateT?
09:51:29 <nh2> I'm thinking of something like "source $= (run c1 here to turn it into c2) $$ sink"
09:54:42 <dispy> Hi
09:55:12 <dispy> http://ideone.com/CislK << how can I do something like that; using typeclasses with variable type for the other parameters?
09:56:26 <loreints> trem_: sorry, I have to go, I think I found that blog post and I'll post an update by 4 if you still need it
09:56:28 <loreints> thanks everyone!
09:57:18 <ReinH> can someone explain an idiom I feel like I should understand but don't?
09:57:21 <ReinH> :t  liftM ((,) x)
09:57:22 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (Expr, a1)
09:57:46 <johnw> in what contexts do you find it?
09:58:01 <ReinH> johnw: Traversable quite often
09:58:02 <johnw> it looks like it's a way to add auxiliary data to a monadic context
09:58:03 <ReinH> trees and lists
09:58:09 <ReinH> so annotating nodes
09:58:10 <ReinH> ?
09:58:12 <johnw> yeah
09:58:26 <EvanR_> eh?
09:58:27 <ReinH> so it takes a function to annotate a node?
09:58:38 <ReinH> or annotate some monadic value"?
09:58:48 <johnw> it turns Just 10 into Just (10,x), doesn't it?
09:59:07 <ReinH> right
09:59:11 <EvanR_> > liftM ((,) 4) (Just 10)
09:59:11 <ReinH> sorry
09:59:13 <lambdabot>   Just (4,10)
09:59:20 <johnw> > oh, x,10
09:59:22 <lambdabot>   <no location info>: parse error on input `,'
09:59:30 <ion> liftM :-(
09:59:42 <EvanR_> > fmap ((,) 4) (Just 10)
09:59:44 <lambdabot>   Just (4,10)
09:59:48 <ReinH> not a function, it expects x to be a monadic value , got it
10:00:16 <johnw> > liftM ((,) 4) <*> (Just 10)
10:00:18 <lambdabot>   Couldn't match expected type `(a -> a1) -> a'
10:00:18 <lambdabot>         against inferred type...
10:00:19 <dispy> any ideas ?
10:00:34 <ReinH> what if I want a function that takes a function and "annotates" a monadic using by (,)?
10:00:51 <johnw> isn't that what you just showed me?
10:01:05 <johnw> oh, you want a higher-order version of the same
10:01:07 <ReinH> so basically: m a -> (a -> b) -> m (a, b)
10:01:24 <ReinH> sorry flip that
10:01:31 <ReinH> (a -> b) -> f a -> f (a, b)
10:01:42 <johnw> liftM (\f -> (a, f a))
10:01:49 <ReinH> now pointfree :p
10:01:52 <johnw> @pl liftM (\f -> (a, f a))
10:01:53 <lambdabot> fmap ((,) a . ($ a))
10:01:59 <brisbin> can't something from Arrow do that?
10:02:09 <brisbin> the tuple part i mean
10:02:16 <int-e> @type \f -> fmap (id &&& f)
10:02:18 <lambdabot> forall a c' (f :: * -> *). (Functor f) => (a -> c') -> f a -> f (a, c')
10:02:27 <johnw> I don't know if arrow will merge input *and* output
10:02:28 <brisbin> int-e: thought so
10:02:31 <ReinH> brisbin: seems like arrow would be appropriate
10:02:33 <johnw> oh
10:02:36 <johnw> you're dead right
10:02:56 <johnw> @pl \f -> fmap (id &&& f)
10:02:57 <lambdabot> fmap . (id &&&)
10:03:00 <int-e> hmm.  fmap . (id &&&)  looks kind of cute :)
10:03:16 <johnw> (id &&&) makes sense now
10:03:31 <johnw> "pass the input unchanged and merge with the output from the second function"
10:03:35 <brisbin> can fmap be used in place of liftM always?
10:03:48 <johnw> I think liftM *is* fmap
10:03:48 <brisbin> depends on the monad i guess
10:03:50 <johnw> @src liftM
10:03:50 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:04:02 <johnw> :t liftM
10:04:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:04:06 <johnw> :t fmap
10:04:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:04:12 <int-e> brisbin: no, because the functor instance may be missing. but it *should* always work
10:04:13 <EvanR_> liftM is fmap if the type has a functor instance following the laws
10:04:16 <johnw> different type constraint
10:04:18 <ion> There would be no liftM in the first place if the type class hierarchy wasn’t broken.
10:04:21 <brisbin> int-e: thanks, makes sense
10:04:34 <EvanR_> screw hierarchies
10:04:40 <EvanR_> let chaos reign
10:06:43 * hackagebot keter 0.2.0.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.2.0.1 (MichaelSnoyman)
10:09:25 <ReinH> brisbin: if all Monads are actually Functors (which they should be) then yes
10:09:59 <brisbin> ReinH: yeah, i should've realized that. all monads i use are functors, thankfully
10:10:35 <ReinH> the class hierarchy should include Monad as a child of Functor, but every Monad instance I'm aware of is an instance of Functor as well
10:10:56 <ReinH> (and if one isn't, that's probably a bug)
10:11:00 <c_wraith> Applicative is the one that many Monads used to be missing.
10:11:11 <c_wraith> like, ST s being an instance of Applicative is relatively new
10:11:59 <parcs`> :t liftM2 id
10:12:00 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
10:12:38 <otters> @src liftM2
10:12:38 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:14:16 <mm_freak_> ReinH: you're lucky
10:14:29 <mm_freak_> on hackage there are numerous packages which provide monads that aren't Functor instances
10:16:25 <ReinH> mm_freak_: shun! shun the nonbelievers!
10:17:33 <johnw> can't they just be Functorized in your own module?
10:17:48 <mm_freak_> i hate orphan instances
10:18:23 <mm_freak_> not that i don't use them from time to time, but they are really unfortunate
10:18:34 <DanBurton> all monads are functors, where fmap = liftM
10:18:50 <mm_freak_> DanBurton: that's not the point
10:19:06 <DanBurton> what is the point?
10:19:25 <mm_freak_> that many packages on hackage provide Monad instances but lack Functor and Applicative
10:19:34 <S11001001> that boilerplate is boring, mm_freak_?
10:19:37 <Cale> DanBurton: The point is that while that instance is easy to write, it's not required to write it, when it should be
10:19:43 <DanBurton> well those packages are evil and need to die
10:19:45 <johnw> can you add "deriving" to a "type" synonym?
10:19:48 <mm_freak_> S11001001: what do you mean?
10:19:56 <mm_freak_> johnw: no
10:19:58 <brisbin> johnw: no
10:19:58 <johnw> :(
10:19:59 <ReinH> DanBurton: confirm
10:20:02 <DanBurton> johnw: nope; it doesn't make sense
10:20:08 <brisbin> it gets whatever you aliased as derived
10:20:14 <brisbin> has*
10:20:17 <johnw> it would have to be newtype then
10:20:35 <brisbin> er, shouldn't think of that that way. it doesn't /get/ anything it /is/ that type
10:20:51 <S11001001> mm_freak_: specifying fmap = liftM or using WrappedMonad is boilerplatey
10:20:53 <DT`> did I miss the weekly broken Functor-Monad hierarchy discussion again?
10:20:55 <Cale> DanBurton: i.e. should add a constraint Functor m => Monad m in the class declaration for Monad. Actually, given the usefulness of Applicative, I think it deserves a promotion, and we should have  class Applicative m => Monad m
10:20:56 <DanBurton> johnw: newtype deriving works simply by copying the instances of whatever is inside of it, plus the wrapping and unwrapping
10:21:02 <mm_freak_> S11001001: when implementing a monad i never write fmap = liftM
10:21:19 <Cale> mm_freak_: Why not? :)
10:21:34 <mm_freak_> feels dirty
10:21:36 <Cale> Sometimes that's the easiest way to make it into a functor
10:21:38 <johnw> I've got an article in my reading list about why (Functor m) => Monad m is bad
10:21:41 <johnw> haven't read it yet those
10:21:41 <ReinH> So I can think of plenty of ways to do this with points but I can't think of a reasonable pointfree version
10:21:54 <mm_freak_> usually fmap is really easy to implement and a direct implementation is often slightly faster than liftM
10:21:56 <DanBurton> johnw: do share
10:21:58 <johnw> DanBurton: does the newtype share all the same instances as the parent type
10:22:00 <Cale> ReinH: what in particular?
10:22:05 <mm_freak_> that's also why i prefer to use fmap over liftM
10:22:16 <DanBurton> johnw: it can, I believe, with GeneralizedNewtypeDeriving
10:22:18 <EvanR_> beat them like a red headed step-instance
10:22:29 <DanBurton> johnw: but for a newtype, you have to ask it to derive each instance that you want
10:22:34 <mm_freak_> johnw: i wouldn't make Monad a direct subclass of Functor
10:22:40 <mm_freak_> i'd add Applicative inbetween
10:22:55 <Cale> mm_freak_: For something like State, I wouldn't be bothered writing the Functor instance by hand. For a more container-y type, I likely would write fmap and join first, and then worry about >>=
10:23:20 <ReinH> :t fmap (id &&& x) -- Cale
10:23:22 <lambdabot>     Couldn't match expected type `a -> c'' against inferred type `Expr'
10:23:23 <lambdabot>     In the second argument of `(&&&)', namely `x'
10:23:23 <lambdabot>     In the first argument of `fmap', namely `(id &&& x)'
10:23:23 <mm_freak_> Cale: for a containery type i usually implement a fold and then implement all of Functor, Applicative and Monad in terms of the fold
10:23:29 <ReinH> sorry
10:23:44 <DanBurton> This is how I'd write the Monad class: https://github.com/DanBurton/sexy/blob/master/src/Sexy/Classes/Monad.hs
10:23:45 <ReinH> fmap (id &&& x)
10:23:55 <mm_freak_> Cale: fmap f = maybe Nothing (Just . f)
10:24:05 <Cale> fmap . (id &&&) $ x = fmap ((id &&&) x) = fmap (id &&& x)
10:24:10 <mm_freak_> fmap f = either Left (Right . f)
10:24:20 <roconnor> mm_freak_: why not implement traverse and then implement fold in terms of traverse?
10:24:45 <roconnor> mm_freak_: wait, you can implement Functor in terms of fold?!
10:24:52 <mm_freak_> roconnor: because i'm not familiar with the theory behind 'traverse'
10:24:52 * roconnor ponders that
10:25:04 <mm_freak_> there is strong theory behind folds
10:25:14 <DT`> DanBurton, switch (>>=) with (=<<) :: (a -> m b) -> (m a -> m b) and I'm sold.
10:25:25 <roconnor> mm_freak_: ha. Fair enough.  I didn't understand traverse until edwardk taught me it was simply a multilens with polymorphic update.
10:25:32 <edwardk> =)
10:25:37 <ReinH> Cale: are you sure?
10:25:41 <Cale> :t traverse
10:25:42 <lambdabot> Not in scope: `traverse'
10:25:58 <DanBurton> it should be no surprise that Functor is a superclass of Traversable
10:26:08 <Cale> ReinH: I mean, I just wrote a proof, so...
10:26:08 <mm_freak_> roconnor: also 'traverse' seems to be flat, whereas a fold reflects the structure of the data type at hand
10:26:13 <DanBurton> but fold?
10:26:36 <edwardk> foldMapDefault f  = runIdentity . traverse (Identity . f)
10:26:40 <edwardk> fold is using the Const functor
10:26:43 * hackagebot yesod 1.1.0.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.0.2 (MichaelSnoyman)
10:26:45 <Cale> :t Data.Traversable.traverse
10:26:46 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:26:47 <edwardk> er sorry that was fmapDefault
10:26:52 <roconnor> DanBurton: fold is (kinda) the other half of Traversable from Functor. ... from a mirrored multi-lens perspective anyways.
10:26:52 <DanBurton> DT`: I don't see why, since it's just the same thing flipped
10:26:55 <mm_freak_> edwardk: is this 'traverse' from Data.Traversable?
10:27:01 <edwardk> foldMapDefault f = getConst . traverse (Const . f)
10:27:04 <edwardk> mm_freak_: yes
10:27:16 <johnw> :type (const a)
10:27:31 <johnw> :t (const a)
10:27:32 <lambdabot> forall b. b -> Expr
10:27:40 <DanBurton> edwardk: you should write a book about the lens package
10:27:41 <edwardk> fmapDefault is traverse with the Identity functor, foldMapDefault is traverse with the Const functor
10:27:44 <mm_freak_> edwardk: 'traverse' is more general than a fold?
10:27:48 <johnw> edwardk: yes, absolutely
10:27:59 <DT`> DanBurton, it's nicer, i.e. for [] (=<<) = concatMap, (>>=) = flip concatMap.
10:28:01 <edwardk> mm_freak_: you can do more with a Traversal than you can with a Fold
10:28:31 <edwardk> mm_freak_: everything you can do with a Fold you can do with a Traversal
10:28:33 <mm_freak_> edwardk: i'm talking about a fold as specified by bananas, lenses and barbed wire
10:28:46 <roconnor> mm_freak_: technically this means traverse is *less* general than a fold, since Foldable has more instances than Traversable.
10:28:47 <edwardk> different beast
10:28:47 <mm_freak_> is a Fold a fold in that sense?
10:28:58 <edwardk> Fold as in Foldable
10:29:06 <mm_freak_> ok, that's a different thing then
10:29:13 <edwardk> Foldable is basically toList in typeclass form ;)
10:29:18 <mm_freak_> yeah =)
10:29:20 <roconnor> we are so screwed with multiple definitions of fold and lenses
10:29:37 <mm_freak_> i like the general idea of folds as defined by bird
10:29:46 <DT`> DanBurton, actually, IMO, it should just be called `bind', (=<<) should be the sugary operator for it like <$> is for fmap, (>>=) should be flip bind.
10:29:47 <mm_freak_> and i implement most of my data structure operations in terms of folds
10:30:03 <DT`> that way even the monad laws become simpler.
10:30:27 <edwardk> DT`: it is much nicer that way from a CT perspective, sadly users will never flip ;)
10:30:36 <srhb> @hoogle traverse
10:30:43 <johnw> i wouldn't really like having to call flip bind all the time
10:30:50 <srhb> lambdabot? :(
10:30:52 <roconnor> DT`: I think I used bind that way in my thesis.
10:31:01 <srhb> It dieded.
10:31:08 <edwardk> we actually define bind that way here in Ermine
10:31:13 <roconnor> bind takes a function and returns a function
10:31:31 <edwardk> yeah it takes a kleisli arrow and returns an arrow in the base category
10:32:02 <EvanR_> :t bind
10:32:20 <mm_freak_> is there a gentle introduction into categorical algebras?
10:32:33 <mm_freak_> the wikipedia page on F-algebras is a bit abstract
10:32:41 <edwardk> preflex: xseen alpmestan
10:32:55 <DT`> edwardk, that's too bad. the laws using bind become even understandable.
10:33:10 <johnw> i'm surprised I'm not hearing about join about now
10:35:10 <DT`> johnw, well, join is fine in the typeclass.
10:35:26 <DT`> there's no problem with it, afaik.
10:36:05 <DT`> the unfortunate ones are bind and fmap.
10:36:34 <mm_freak_> let's see…  Maybe together with fmap is an endofunctor…  an F-algebra might be Int together with 'maybe 0 id'…  is that correct?
10:36:40 <EvanR_> met a dude last night who works at that swedish haskell company
10:36:53 <mm_freak_> maybe 0 id :: Maybe Int -> Int
10:37:46 <ReinH> Cale: so this should work right? fmap . (id &&&) $ (+1) $ [1,2,3]
10:38:55 <mm_freak_> ok, reposting because of the split
10:39:06 <mm_freak_> let's see…  Maybe together with fmap is an endofunctor…  an F-algebra might be Int together with 'maybe 0 id :: Maybe Int -> Int'…  is that correct?
10:39:32 <DT`> mm_freak_, I think you should wait it stabilizes a bit.
10:39:36 <johnw> > fmap . (id &&&) $ (+1) $ [1,2,3]
10:39:36 <byorgey> mm_freak_: yes, that is a Maybe-algebra
10:39:37 <lambdabot>   Couldn't match expected type `a -> c'' against inferred type `[t]'
10:39:37 <mm_freak_> yeah
10:39:43 <ReinH> ugh netsplit :(
10:39:55 <ReinH> johnw: I don't think he's accounting for &&& being infix
10:39:57 <johnw> > fmap $ (id &&&) . (+1) $ [1,2,3]
10:39:58 <lambdabot>   Couldn't match expected type `b -> c'' against inferred type `[a]'
10:40:04 <johnw> ah
10:40:13 <mm_freak_> byorgey: thanks…  and the category of Maybe algebras is the class of all Maybe-algebras together with the homomorphisms between then, correct?
10:40:20 <byorgey> > fmap ((id &&&) . (+1)) $ [1,2,3]
10:40:24 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (b, c'))
10:40:25 <lambdabot>    arising from a us...
10:40:31 <johnw> > fmap . (id &&& (+1)) $ [1,2,3]
10:40:33 <DT`> wow.
10:40:33 <lambdabot>   Couldn't match expected type `a -> b'
10:40:33 <lambdabot>         against inferred type `(a1, a...
10:40:41 <byorgey> mm_freak_: correct
10:40:50 <johnw> > fmap (id &&& (+1)) [1,2,3]
10:40:50 <lambdabot>   [(1,2),(2,3),(3,4)]
10:40:53 <johnw> there we go
10:40:55 <johnw> even simpler
10:41:04 <mm_freak_> and an initial object in that category is an initial algebra?
10:41:12 <byorgey> mm_freak_: right
10:41:16 <mm_freak_> ok, thanks a lot
10:41:23 <copumpkin> hmm
10:41:32 <johnw> copumpkin: i like your handle
10:41:56 <cojohnw> i don't even know what "co-" means, but all the cool kids are doing it
10:42:03 <ReinH> cojohnw: that's what I started with
10:42:15 <DT`> *some ol cokids.
10:42:21 <mm_freak_> cojohnw: see duality in category theory
10:42:25 <ReinH> I want to get rid of the point (f) in fmap (id &&& f)
10:42:27 <mm_freak_> it's actually a very simple concept
10:42:32 <cojohnw> first i have to see category theory
10:42:40 <EvanR_> works at scrive
10:42:43 <cojohnw> ReinH ah, I see
10:42:43 <DanBurton> mm_freak_: everything is "actually a very simple concept" once you get it :P
10:42:48 <copumpkin> cojohnw: thank you!
10:42:49 <cojohnw> :t fmap . (id &&&) $ (+1)
10:42:50 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f (a, a)
10:42:52 <byorgey> mm_freak_: an initial Maybe-algebra is (isomorphic to) the natural number type, along with its constructors
10:43:03 <mm_freak_> DanBurton: yeah, but duality is one of the things i understood right away =)
10:43:06 <cojohnw> > fmap . (id &&&) $ (+1) $ [1, 2, 3]
10:43:07 <lambdabot>   Couldn't match expected type `a -> c'' against inferred type `[t]'
10:43:12 <cojohnw> so why does that fail?
10:43:15 <DT`> cojohnw, going out is cocoming coin.
10:43:27 <ReinH> so it's wierd
10:43:34 <ReinH> @pl f x = fmap (id &&& x)
10:43:35 <lambdabot> f = fmap . (id &&&)
10:43:37 <mm_freak_> byorgey: i'm working on getting there
10:43:42 <byorgey> cojohnw: (+1) cannot be applied to a list
10:43:45 <DanBurton> cojohnw: $ is right-associative
10:43:46 <ReinH> pointfree agrees with Cale
10:43:49 <ReinH> and I would agree too
10:43:51 <ReinH> except
10:44:00 <cojohnw> > (fmap . (id &&&) $ (+1)) $ [1, 2, 3]
10:44:02 <lambdabot>   [(1,2),(2,3),(3,4)]
10:44:02 <ReinH> > fmap . (id &&&) $ (+1) $ [1,2,3,4]
10:44:03 <lambdabot>   Couldn't match expected type `a -> c'' against inferred type `[t]'
10:44:04 <cojohnw> ah, right
10:44:13 <cojohnw> forget about right-associativity
10:44:13 <mm_freak_> seems like there is a strong connection between initial algebras and folds…  that's why i'm interested in the concept
10:44:16 <cojohnw> forgot
10:44:19 <Cale> ReinH: $ isn't left associative, sadly
10:44:28 <mm_freak_> sadly?
10:44:31 <mm_freak_> i'm glad it isn't
10:44:32 <Cale> YES SADLY
10:44:34 <DanBurton> > (fmap . (id &&&)) (+1) [1,2,3] -- space is left-associative
10:44:34 <ReinH> heh
10:44:36 <lambdabot>   [(1,2),(2,3),(3,4)]
10:44:49 <mm_freak_> there is already overuse of ($) in code
10:44:55 <DanBurton> Cale: why isn't $ left-associative in Caleskell?
10:44:58 <mm_freak_> left-associativity would make this even worse
10:45:12 <cojohnw> why $ do $ you $ say $ that?
10:45:25 <DT`> we should ditch whitespace and use only ($).
10:45:25 <brisbin> couldn't we all use a little more $$$
10:45:26 <EvanR_> (why . do . you . say) that
10:45:33 <cojohnw> lol
10:45:39 <Cale> mm_freak_: Making it left associative would kill the overuse of it (all the uses which can be replaced by composition), and open up new uses which can't be replaced with anything but parens
10:46:02 <mm_freak_> Cale: and that's exactly where i'd like to stick with the parens =)
10:46:06 <EvanR_> (void . forkIO) $ do :(
10:46:13 <mm_freak_> f (x + y) (a*b) (x^2)
10:46:22 <Cale> EvanR_: ?
10:46:26 <mm_freak_> much more readable than f $ x + y $ a*b $ x^2
10:46:29 <EvanR_> you need a $ there
10:46:43 <DT`> @pl \x y a b -> f (x + y) (a*b) (x^2)
10:46:43 <lambdabot> ap (flip . ((flip . (flip .)) .) . flip flip (*) . (((.) . (.) . f) .) . (+)) (^ 2)
10:46:54 <Cale> EvanR_: any expression with only one $ in it would not be affected by a change in the associativity of $
10:46:55 <DT`> much better.
10:46:59 <cojohnw> @pl f (x + y) (a*b) (x^2)
10:46:59 <lambdabot> f (x + y) (a * b) (x ^ 2)
10:47:03 <mm_freak_> flat code may give haskell newcomers boners, but it's a hazard to long-term readability
10:47:04 <cojohnw> @unpl f (x + y) (a*b) (x^2)
10:47:04 <lambdabot> f (x + y) (a * b) (x ^ 2)
10:47:06 <EvanR_> Cale: no but why do you need $ at all
10:47:14 <mm_freak_> EvanR_: good question
10:47:17 <mm_freak_> very good question
10:47:28 <Cale> EvanR_: That's some odd thing to do with parsing
10:47:35 <Cale> I'm not 100% sure why
10:47:36 <cojohnw> $ is nice in some cases
10:47:39 <EvanR_> fiddlesticks
10:47:40 <Cale> It's also true with lambda
10:47:44 <EvanR_> yes
10:47:50 <cojohnw> like >>= $ \x -> ...
10:47:54 <mm_freak_> ($) is nice in multi-line cases…  for everything else hlint should warn about it
10:48:03 <EvanR_> but yeah its not necessary with >>= \x ->
10:48:05 <cojohnw> mm_freak_ hrpmh
10:48:11 <Cale> mm_freak_: Consider expressions similar to that one but where each of the parameters to f is long and you're going to be lining them up vertically
10:48:23 <ReinH> so my plan is to use annotate = id &&& to annotate nodes with score for negamax search
10:48:32 <Cale> mm_freak_: It might be nice to be able to use $'s to set them off and not have to worry about the )'s
10:48:32 <cojohnw> where f returns a functions, sometimes f (x * y) (a + b) $ 4 is clearer
10:48:46 <cojohnw> than (f (x *) (a + b)) 4
10:48:51 <EvanR_> nah
10:48:54 <mm_freak_> Cale: yeah, that's one of the few cases where ($) is fine…  i'm just finding an overuse of it in haskell…  flat code is never good and even in the multi-line case i tend to use parentheses
10:48:57 <EvanR_> easier to type maybe
10:49:00 <Cale> Obviously, good judgement is important in any of this
10:49:22 <Cale> mm_freak_: Well, $ doesn't work in that case currently
10:49:25 <ReinH> Anyone think that using arrows for minimax/negamax/alpha-beta is a good/bad idea?
10:49:27 <Cale> because it's right-associative
10:49:39 <mm_freak_> Cale: it works for the obvious case:  f $ \x -> …
10:49:43 <Cale> So if there's more than one long parameter, you lose
10:49:48 <mm_freak_> for everything else i actually don't want it to work
10:49:56 <Cale> and you have to write the parens
10:50:16 <mm_freak_> i think this is the only case where i'm using ($)
10:50:25 <mm_freak_> when i have a function to the left and a multi-line lambda to the right
10:50:30 <mm_freak_> for everything else i use parentheses
10:50:40 <Cale> mm_freak_: Also, it will get rid of all the overuses where people write f $ g $ h $ x
10:50:46 <EvanR_> stuck in the middle with you
10:50:49 <Cale> and replace those with f . g . h $ x
10:50:58 <ReinH> or maybe just http://hackage.haskell.org/packages/archive/hxt/9.0.0/doc/html/Control-Arrow-ArrowTree.html
10:51:01 <mm_freak_> Cale: i'm afraid it will replace that overuse by another overuse
10:51:04 <Cale> (.) is truly associative
10:51:08 <EvanR_> (f . g . h) x
10:51:59 <mm_freak_> personally i wouldn't mind changing the type of ($) so that it doesn't associate at all
10:52:12 <mm_freak_> ($) :: ((a -> b) -> c) -> (a -> b) -> c
10:52:13 <apeschel> Is (f . g . h) preferrable to f . g . h $ x ?
10:52:21 <edwardk> ok, dumb question, trying to get hpc based testing set up for a project, what is the best way to get cabal to turn it on for the one test?
10:52:23 <mm_freak_> apeschel: personally i prefer it
10:52:24 <apeschel> (f . g . h) x
10:52:41 <edwardk> can i see the --enable-tests flag from within the cabal config?
10:52:41 <Cale> mm_freak_: how does that work?
10:53:00 <edwardk> preflex: xseen dcoutts
10:53:00 <preflex>  dcoutts was last seen on freenode/#haskell 1 day, 2 hours, 8 minutes and 42 seconds ago, saying: om: yes
10:53:05 <DanBurton> tbh sometimes "foo $ bar $ baz" is just prettier than "foo . bar $ baz"
10:53:07 <Cale> mm_freak_: That's a bad type, because it won't allow you to write things like  forkIO $ do ...
10:53:13 <mm_freak_> Cale: just a more type-strict version of ($), which forces the second argument to be a function…  that would eliminate a lot of abuses of ($)
10:53:20 <mm_freak_> true
10:53:23 <EvanR_> Cale: which shouldnt need a $ anyway
10:53:25 <ReinH> so a rose tree + Control.Arrow.ArrowTree seems like a reasonable way to represent minimax search functionally (rather than imperatively). Confirm/deny?
10:53:35 <mm_freak_> ($) :: (f a -> b) -> f a -> b
10:53:44 <EvanR_> ah
10:53:47 <dcoutts_> edwardk: --enable-library-coverage
10:53:49 <EvanR_> got it
10:53:49 <edwardk> i tend to prefer using $ to . because when the inlining fails it degrades slightly to a slightly higher performance code ;)
10:53:55 <DanBurton> :t ($)
10:53:56 <lambdabot> forall a b. (a -> b) -> a -> b
10:54:15 <edwardk> dcoutts_: is there a way to see the --enable-library-coverage or --enable-tests flags from within the cabal file?
10:54:23 <dcoutts_> edwardk: you shouldn't need to do that
10:54:25 <edwardk> e.g if flag(…) or something?
10:54:29 <ReinH> edwardk: zomg you're here! yay!
10:54:40 <ReinH> edwardk: did you ever find your old post on alpha-beta?
10:54:52 <Cale> ReinH: My advice would be to just write it in a plain style first, and then see if it lends itself to some kind of abstraction like with arrows. I'm not immediately convinced that it needs them.
10:54:52 <edwardk> dcoutts_: well, for example if i have a test i only want to run when library-coverage is enabled
10:55:14 <ReinH> Cale: good point, the only problem is that all the "plain" style implementations I've seen in Haskell so far look very imperative
10:55:31 <edwardk> ReinH: i found a link.. and it goes nowhere, because hpaste was rebuilt in the intervening years ;)
10:55:36 <ReinH> any good examples of dfs in Haskell in general?
10:55:40 <ReinH> edwardk: noooooooooooooooooooo
10:55:45 <dcoutts_> edwardk: sounds suspicious, but I guess it's there in the LocalBuildInfo if you really want to know
10:55:52 <edwardk> dcoutts_: fair nuff
10:55:58 <mm_freak_> ReinH: dfs?
10:56:05 <ReinH> mm_freak_: depth first search
10:56:16 <edwardk> ReinH: there is a whole library of search strategies
10:56:18 <dcoutts_> edwardk: why do you want to do that btw? I've never considered there to be a use case like it
10:56:51 <edwardk> dcoutts_: i have a bunch of tests i run with --enable-tests, but i also want to have a really expensive test suite i can use to check exhaustive code coverage
10:57:22 <dcoutts_> edwardk: would splitting it into two test suites help there?
10:57:38 <dcoutts_> you're allowed any number of them
10:57:40 <ReinH> edwardk: where is this whole library of search strategies?
10:57:40 <edwardk> running the 3 existing test suites takes an extra minute, adding the other will likely carry it to 5-6 minutes
10:58:45 <ReinH> so many cool things http://hackage.haskell.org/packages/archive/tree-monad/0.3/doc/html/Control-Monad-SearchTree.html
10:58:58 <edwardk> ReinH: i can avoid this by just making a flag to turn on the last test, or something
10:59:23 <edwardk> but it'd be nice to just piggyback on the existing coverage flag is all
10:59:43 <ReinH> edwardk: I think you meant dcoutts_ :)
10:59:50 <ReinH> edwardk: or that you meant to provide me with a link
10:59:51 <edwardk> ReinH: i did =)
10:59:54 <ReinH> or both
10:59:58 <edwardk> ReinH: it'll take me a minute ;)
11:00:10 <ReinH> edwardk: ok thanks!
11:00:10 <dcoutts_> edwardk: tbh, sounds like it's orthogonal to hpc, it's that you've got a default and expensive test suites
11:00:17 <edwardk> yeah
11:00:20 <edwardk> i can live with that
11:00:38 <ReinH> edwardk: I didn't realize that you were in a non-terminal state
11:00:59 <edwardk> dcoutts_: well, one of the things i was thinking about doing was having one of the tests be that i didn't drop below a certain level of coverage ;)
11:01:11 <dcoutts_> heh
11:01:13 <edwardk> dcoutts_: that is one test i can't run without knowing that i have the flag ;)
11:01:37 <edwardk> that was what prompted my initial question
11:01:48 <dcoutts_> though you'd need a lot more than the flag
11:02:10 <dcoutts_> cabal will run with hpc turned on, and stick the output files in a particular place
11:03:51 <edwardk> ReinH: check tom schrijvers' work http://users.ugent.be/~tschrijv/research.html
11:04:04 <edwardk> particularly on monadic constraint programming
11:05:11 <edwardk> dcoutts_: so there is some kind of hpcdir where the .tix files get dumped? i haven't used hpc in a couple of years
11:06:02 <dcoutts_> edwardk: yes but it's not obvious where you could hook in to report the test failed
11:06:24 <edwardk> dcoutts_: was thinking perhaps i could run the first test, then run the second to look at the .tix files
11:06:30 <tobiassjosten> Hey guys, I just wrote my first "complete" and functioning Haskell program. If anyone care to give me some feedback on it I would really appreciate that!
11:06:33 <tobiassjosten> https://github.com/tobiassjosten/hs-ascii-order/blob/master/AsciiOrder.hs
11:06:38 <edwardk> the first test checks the properties as it runs, the second checks coverage of the first
11:06:42 <dcoutts_> edwardk: there's no guarantee they'll be run sequentially
11:06:47 <edwardk> blech
11:07:01 <dcoutts_> edsko: perhaps you can use the HPC API directly
11:07:20 <edwardk> i have a similar set of headaches awaiting me when i go to add benchmarks, don't i? =)
11:07:22 <dcoutts_> at the end of main, to look at the results even before they're written out to a file
11:07:28 <edwardk> ah
11:07:49 <dcoutts_> edwardk: yes, because you're trying to look at the results of the test
11:08:46 <edwardk> dcoutts: normally i don't bother with little things like "documentation", "benchmarks" and "tests", but I recently discovered that when I do, I get these curious things called "users". ;)
11:08:54 <johnw> lol
11:08:57 <dcoutts_> :-)
11:09:10 <johnw> @remember edwardk normally i don't bother with little things like "documentation", "benchmarks" and "tests", but I recently discovered that when I do, I get these curious things called "users".
11:09:10 <lambdabot> I will never forget.
11:09:28 <dcoutts_> edwardk: with benchmarks, I guess you want to fail if the performance is below some threshold?
11:09:37 <edwardk> there i'm not sure
11:09:45 <edwardk> those probably don't fall in the test category to be honest
11:09:50 <johnw> I find a better idea is to fail if the difference falls below a percentile
11:09:52 <edwardk> i just want to get a feel for performance
11:09:57 <dcoutts_> edwardk: oh ok, then you're probably fine
11:10:05 <johnw> like a 50% drop is something serious that needs looking at
11:10:21 <dcoutts_> johnw: compared to a previous run, right. But that's something you check externally, not within the benchmark
11:10:29 <johnw> yes
11:10:35 <johnw> it is a job of the benching harness
11:10:38 <dcoutts_> right
11:10:45 <armlesshobo> edwardk: lol! quite curious indeed, they are. ha!
11:10:46 <edwardk> johnw: that requires me to keep the local performance around though, and there isn't any guarantee that it'll be compiled on the same machine
11:10:56 <dcoutts_> johnw: where as edwardk wants to look at the hpc results which are collected by the test harness
11:11:09 <dcoutts_> johnw: which isn't something we'd anticipated.
11:11:17 <johnw> well, it's just a yardstick anyway, not a hard-and-fast test of any kind
11:11:34 <johnw> if the past info is there, great, if not, no failure is possible
11:11:47 <nh2> can somebody tell me why in http://hpaste.org/73538 my StateT always has the same state instead of counting up?
11:11:59 <DanBurton> where can I find documentation about CPP macros such as MIN_VERSION_foo ?
11:12:13 <johnw> because you lifted your modify into Conduit?
11:12:42 <dcoutts_> DanBurton: I'm not sure they actually are documented. But you can look at the .h file in dist/
11:12:45 <johnw> or am I reading that in reverse?
11:12:46 <geekosaur> http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
11:13:02 <dcoutts_> oh nice :-)
11:13:05 <geekosaur> not fully documented perhaps but there's some stuff there
11:13:13 <Cale> nh2: I know absolutely nothing about Conduit, but I'm willing to bet that it's because you're evaluating a separate call to evalStateT each time.
11:13:44 <johnw> ah, yes
11:13:50 <johnw> state is not being shared
11:14:13 <Cale> StateT is not magic
11:14:17 <edwardk> the one thing i learned with MIN_VERSION_foo is to always be paranoid and surround them in ()'s when you go to negate them if you want to be compatible with old Cabals.
11:14:25 <Cale> It's just sugar for a bunch of parameter passing
11:14:40 <Cale> Since your monad m has to be in MonadIO here
11:14:56 <byorgey> mm_freak_: "seems like there is a strong connection between initial algebras and folds" -- I'd say!  folds are defined in terms of initial algebras.
11:14:58 <Cale> Probably the better thing to do is to set up an IORef for the thing to update.
11:15:25 <DanBurton> Cale: lies. StateT is magic, it's just not the magic you think it is
11:15:26 <byorgey> mm_freak_: the initiality of an initial algebra is what guarantees the existence of a fold -- and even shows you how to implement it.
11:15:39 <Cale> DanBurton: is it?
11:15:49 <mm_freak_> yeah…  i'm learning
11:16:03 <armlesshobo> what is (->) anyway?
11:16:06 <byorgey> mm_freak_: sure.  is there something in particular you're reading?
11:16:14 <Cale> armlesshobo: The type constructor for functions?
11:16:26 <dcoutts_> edwardk: yes, that bug has been fixed, but it did used to be a problem
11:16:30 <nh2> Cale: yes, but that means I don't understand conduit correctly. I would expect evalState to be called only once for the pipe
11:16:31 <Cale> armlesshobo: (->) Int String = Int -> String
11:16:31 <johnw> armlesshobo: it's a type constructor for function types
11:16:58 <byorgey> mm_freak_: I particularly recommend http://www.cs.ox.ac.uk/publications/publication2360-abstract.html
11:17:11 <DanBurton> nh2: I don't think transPipe is the right thing to use for this
11:17:14 <armlesshobo> Cale: I'm trying to implement an instance of Functor ((->) t) and want make sure it is the type constructor and not anything else
11:17:52 <mm_freak_> byorgey: currently i'm just reading about algebras, but i'll read your link as well, thanks
11:17:56 <Cale> armlesshobo: So fmap :: (a -> b) -> (f a -> f b) becomes fmap :: (a -> b) -> ((->) t a -> (->) t b)
11:18:05 <nh2> DanBurton: do you have a suggestion what to use instead?
11:18:09 <Cale> armlesshobo: which is  fmap :: (a -> b) -> (t -> a) -> (t -> b)
11:18:27 <edwardk> dcoutts_: i'm pretty much limited to 1.8+ so i can have test sections, so i think i'm safe these days
11:20:07 <DanBurton> nh2: I do, give me a second to test it and I'll hpaste it
11:22:34 <jjbohn> back
11:23:54 <DanBurton> nh2: I've annotated it with a working solution http://hpaste.org/73538
11:24:12 <DanBurton> nh2: I just moved evalState to the appropriate location in main
11:25:23 <DanBurton> nh2: make sense?
11:26:17 <xmattdh> Are services down or something?
11:26:28 <Clint> yes
11:26:31 <xmattdh> Ah
11:27:41 <EvanR_> :t foo
11:27:42 <lambdabot> Not in scope: `foo'
11:28:26 <nh2> DanBurton: yes, but that also means that the monad must draw through the whole conduit pipe. I find that surprising - I wonder what the reasoning behind that is
11:29:22 <nh2> as in my first try, I was expecting that if I have an IO pipe in my main conduit, I could easily run stuff on top of that in parts of the pipe
11:29:28 <DanBurton> That's because of the way conduit works. Control is transferred to and from the various portions of the pipeline in an unpredictable manner.
11:30:30 <DanBurton> Well, sure. But the way you do it is by lifting the IO parts via 'transPipe lift' rather than lowering the other parts
11:30:38 <DanBurton> iinm
11:31:11 <otters> uh
11:31:13 <otters> no nickserv?
11:31:14 <DanBurton> I'm not sure the lowering technique is possible; would have to think more about that
11:31:34 <byorgey> otters: nope
11:31:43 <otters> that explains it
11:32:15 <EvanR_> DanBurton: iinm?
11:32:21 <EvanR_> got it
11:32:44 <nh2> EvanR_: yes, there should be unicode symbols for that :D
11:33:07 <EvanR_> i wouldnt be able to see them through my broken screen session
11:33:53 <nh2> DanBurton: yes, there should also probably be something in the conduit docs to explain how this business works, otherwise I'm probably going to write a lot of compiling code that does things completely different from what I expect. I think posting it to -cafe sounds like a good idea
11:40:06 <xmattdh> Accidentally typed [2.. into GHCi, I hate it when that happens
11:40:36 <mcstar> F# monad explanation: "To avoid all of the abstract technical and mathematical theory underlying monads, a "monad" is, in very simple terms, a scary sounding word which means execute this function and pass its return value to this other function."
11:41:33 <mcstar> you have to fetch your wireless keyboard from the garage that has the ^c key?
11:41:46 * hackagebot QIO 1.1 - The Quantum IO Monad is a library for defining quantum computations in Haskell  http://hackage.haskell.org/package/QIO-1.1 (AlexanderGreen)
11:42:22 <xmattdh> Nope
11:42:32 <xmattdh> Fortunately I was using WinCHGi at the time
11:43:40 <EvanR_> im finding it easy to make modules that reference each others definitions
11:43:51 <EvanR_> and im thinking thats a bad thing to have
11:44:07 <EvanR_> so then i spend effort factoring so things dont have cyclic references
11:44:09 <EvanR_> is that normal
11:45:24 <byorgey> EvanR_: yes.
11:45:37 <EvanR_> ok
11:45:42 <EvanR_> gah :)
11:46:02 <mcstar> EvanR_: no.
11:46:14 <mcstar> (just to add a little variance to your query...)
11:47:10 <EvanR_> bah
11:47:37 <byorgey> mcstar: you're saying it isn't normal?
11:47:39 <Clint> it happened to me once
11:47:56 <mcstar> byorgey: im saying, i had little fun today :(
11:48:19 <byorgey> heh
11:48:23 <EvanR_> its like, easy if i put it all in the same file
11:48:24 <EvanR_> meh
11:49:37 <byorgey> EvanR_: you CAN have mutually recursive modules.  It's just a bit of a pain, since you have to create a .hs-boot file
11:49:43 <identity> Where is the source for the monad instance for []?
11:49:52 <identity> It's not in Control.Monad, though it says it's defined in there. :/
11:51:49 <byorgey> identity: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#Monad
11:51:56 <identity> byorgey: thanks!
11:52:02 <byorgey> identity: it's exported from Control.Monad
11:52:19 <identity> byorgey: I see.
12:00:37 <EvanR_> byorgey: nah i dont want to have to do that
12:09:17 <lewis1711> "return x >>= f ==  f x" is an identity of monads, correct?
12:09:54 <monochrom> yes
12:10:08 <johnw> in terms of math operators what does the x in a circle mean?
12:10:18 <lewis1711> lambdabot: return 3 >>= (+1)
12:10:23 <monochrom> depends on the author
12:10:26 <mcstar> location of the treasure
12:10:30 <johnw> i'm thinking of it in terms of arrows
12:10:32 <lewis1711> can't remember how to start the bot. but you get the  point
12:11:00 <monochrom> it's a generic symbol for the author to decide what it means
12:11:01 <johnw> i don't know if it's &&& or <+>
12:11:04 <johnw> ah, ok
12:11:10 <monochrom> just like "f" is up to the author, too
12:11:30 <byorgey> johnw: where did you see this circled x ?
12:11:36 <johnw> i'm trying to find it again
12:11:39 <monochrom> indeed, the author will still say "it's a generic symbol for stating general theorems"
12:12:04 <pdxleif> × and + already have expected meanings, so they'll put a circle around those to mean "some generic operator"
12:12:04 <johnw> damn, the Internet is a big place
12:12:15 <monochrom> > return 3 >> (+ 1) :: Maybe Integer
12:12:16 <lambdabot>   The section `GHC.Num.+ 1' takes one argument,
12:12:16 <lambdabot>  but its type `Data.Maybe.May...
12:12:24 <monochrom> oh, typo
12:12:28 <monochrom> > return 3 >>= (+ 1) :: Maybe Integer
12:12:29 <lambdabot>   No instance for (GHC.Num.Num
12:12:29 <lambdabot>                     (Data.Maybe.Maybe GHC.Inte...
12:12:49 <otters> :t ((return 3) >>=)
12:12:50 <lambdabot> forall t (m :: * -> *) b. (Num t, Monad m) => (t -> m b) -> m b
12:12:51 <monochrom> oh, wrong type, (+ 1) doesn't fit. I'll stop
12:13:03 <lewis1711> how does (+1) not fit?
12:13:12 <lewis1711> :t (+1)
12:13:13 <lambdabot> forall a. (Num a) => a -> a
12:13:14 <otters> because it's not Num t, Monad m => t -> m b
12:13:24 <lewis1711> I see
12:13:35 <otters> return . (+1) would work fine
12:13:39 <monochrom> using Maybe Integer, f has to be Integer -> Maybe Integer
12:13:41 <mm_freak_> > return 3 >>= (+)
12:13:42 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
12:13:42 <lambdabot>    arising from a use of `...
12:13:47 <mm_freak_> > (return 3 >>= (+)) 4
12:13:48 <lambdabot>   7
12:13:49 <otters> but then why use return in both places anyway
12:13:55 <byorgey> otters: but then you might as well just use fmap.
12:14:15 <lewis1711> Just trying to use these laws in ghci to convince myself
12:14:31 <monochrom> yes but you have to watch the types
12:14:36 <lewis1711> but of course, they're dependent on types which I should have guessed
12:15:59 <otters> @pl \f g x -> f x (g x)
12:15:59 <lambdabot> ap
12:17:33 <otters> @pl \f g x -> g x (f x)
12:17:33 <lambdabot> flip ap
12:20:35 <johnw> is () the same as the empty set?
12:20:58 <Veinor> no, () is a type that contains one value
12:21:04 <Veinor> and that value is also written ()
12:22:32 <thoughtpolice> johnw: Void is probably closer to what you want; it's the uninhabited data type (that is, it's definition is just 'data Void')
12:22:53 <thoughtpolice> which you can grab from edwardk's 'void' package
12:23:00 <DanBurton> @hoogle void
12:23:01 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
12:23:01 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
12:23:01 <lambdabot> package void
12:23:04 <EvanR_> neither of which is the empty set
12:23:04 <monochrom> () is pretty close to a singleton set
12:23:22 <mm_freak_> johnw: putStrLn :: String -> IO (), which is an action function that prints and then results in the value (), the only value of type ()
12:23:25 <EvanR_> Set.empty
12:23:26 <Yiq> > mapM_ print $ (\(x,y) -> "iteration " ++ (show x) ++ " is " ++ (show y)) $ zip [1..] ["PAT","Julia","Sven","Monochrom"]
12:23:27 <lambdabot>   Couldn't match expected type `(t, t1)'
12:23:27 <lambdabot>         against inferred type `[(t2,...
12:23:42 <mm_freak_> johnw: the reason we use () instead of Void is that you can't return a value of type Void
12:24:01 <Yiq> > mapM_ print $ map (\(x,y) -> "iteration " ++ (show x) ++ " is " ++ (show y)) $ zip [1..] ["PAT","Julia","Sven","Monochrom"]
12:24:01 <monochrom> our Void is not C's void. keep that in mind
12:24:03 <lambdabot>   <IO ()>
12:24:18 <johnw> mm_freak_: makes sense
12:24:21 <Yiq> > map (\(x,y) -> "iteration " ++ (show x) ++ " is " ++ (show y)) $ zip [1..] ["PAT","Julia","Sven","Monochrom"]
12:24:23 <lambdabot>   ["iteration 1 is \"PAT\"","iteration 2 is \"Julia\"","iteration 3 is \"Sven...
12:24:59 <DanBurton> > mapM_ text $ map (\(x,y) -> "iteration " ++ (show x) ++ " is " ++ (show y)) $ zip [1..]  ["PAT","Julia","Sven","Monochrom"]
12:25:00 <lambdabot>   Couldn't match expected type `m b'
12:25:00 <lambdabot>         against inferred type `Text.Pret...
12:25:05 <DanBurton> aw
12:25:10 <daniel_-> is there anything like a haskell equivalent for pythons virt env?
12:25:18 <DanBurton> > map text $ map (\(x,y) -> "iteration " ++ (show x) ++ " is " ++ (show y)) $ zip [1..]  ["PAT","Julia","Sven","Monochrom"]
12:25:20 <lambdabot>   [iteration 1 is "PAT",iteration 2 is "Julia",iteration 3 is "Sven",iteratio...
12:25:25 <DanBurton> there we go
12:25:30 <monochrom> what does python virt env do?
12:25:32 <mm_freak_> daniel_-: what's that?
12:25:43 <Yiq> so if u dont use something like appengine or heroku, u have to use your own server? isnt there somewhere you can just deploy your whole stack easily?
12:25:50 <DanBurton> @google virthualenv
12:25:52 <lambdabot> http://hackage.haskell.org/package/virthualenv
12:25:52 <lambdabot> Title: HackageDB: virthualenv-0.2.1
12:25:54 <daniel_-> best feature of python, it sandboxes small enviroments
12:25:55 <johnw> I ask because I'm looking for fancy symbols to use in Emacs' haskell-mode: https://gist.github.com/3428576
12:26:10 <daniel_-> so you can have different projects depending on different versions of packages or even python version
12:26:21 <daniel_-> and its veary easy to setup/manage
12:26:24 <mm_freak_> daniel_-: there are many approaches to this…  lambdabot for example uses mueval
12:26:38 <mm_freak_> oh
12:26:48 <leino> I am having some trouble with "memory leaks" (lazy evaluation fail). The following program consumes all of my memory and more: https://github.com/leino/hypergraphs/blob/master/represent.hs. I'd appreciate it if anyone would be willing to take a look and give me some pointers or comments.
12:26:48 <mm_freak_> that sounds more like cabal-dev
12:26:48 <Veinor> daniel_-: there's virthualenv and cabal-dev
12:27:27 <Veinor> the difference is in cabal-dev, you have to explicitly type 'cabal-dev install foo'; in virthualenv; it replaces cabal with a wrapper (i assume)
12:27:38 <daniel_-> ok
12:27:42 <mm_freak_> johnw: yeah, the symbol for () is a bit unfortunate
12:28:09 <DanBurton> () looks like the zero-tuple
12:28:25 <Veinor> i've considered using that but i could never deal with the fact that it makes alignment not work
12:28:27 <mm_freak_> DanBurton: in emacs mode with unicode symbols () is rendered as the empty set
12:28:28 <DanBurton> that's how I think of it anyways
12:28:46 <mm_freak_> Veinor: i use it…  it works if your coding style is compatible with it
12:28:48 <leino> (forgot to add: I have tried both quickQuery and quickQuery' with the same result)
12:29:39 <EvanR_> not sure why anyone would like to think of () as an empty tuple besides aesthetics
12:30:00 <dcoutts_> leino: how big is the dataset? are you expecting to do incremental processing to avoid loading all of the SQL results into memory at once?
12:30:01 <mm_freak_> DanBurton: emacs in haskell-mode with unicode symbols renders () as ∅
12:30:02 <Veinor> EvanR_: it means you have n-tuples for all n >= 0
12:30:22 <Veinor> (where a 1-tuple is identified with the thing it contains :v)
12:30:23 <EvanR_> do you?
12:30:41 <leino> dcoutts_: yeah, the database is about 20 megabytes now, but it will become much bigger pretty soon
12:30:55 <EvanR_> its a silly goal
12:31:09 <Veinor> i don't think it's particularly useful, yeah
12:31:11 <dcoutts_> leino: but you're expecting to have the whole query result in memory at once I presume
12:31:48 * hackagebot wtk 0.1 - Wojcik Tool Kit  http://hackage.haskell.org/package/wtk-0.1 (BartoszWojcik)
12:32:04 <leino> dcoutts_: no, I am simply doing some calculation for each row in the database, independently.
12:32:12 <EvanR_> wtk...
12:32:23 <DanBurton> There is also a package for "one-tuples", though this is redundant with the Identity functor
12:32:30 <monochrom> empty cartesian product is a singleton set. the analogy holds
12:32:44 <Veinor> DanBurton: haha
12:32:53 <EvanR_> :|
12:33:11 <DanBurton> http://hackage.haskell.org/packages/archive/OneTuple/0.2.1/doc/html/Data-Tuple-OneTuple.html
12:33:15 <EvanR_> anyway isnt the official name unit
12:33:22 <DanBurton> EvanR_: correct
12:33:23 <monochrom> yes
12:33:29 <dcoutts_> leino: oh, then you're doing it wrong. You're definitely loading the whole lot into memory, and retaining the whole lot.
12:33:33 <leino> dcouts_: or... that depends on what you mean. I certainly dont want to do the whole computation in memory before I start writing back to the database
12:34:34 <dcoutts_> leino: ok, so that is what you are doing, in particular the g6ToEdgeList
12:34:40 <bgamari> http://hpaste.org/73540
12:34:54 <bgamari> Is there any way to cast those operations into Traversable operations?
12:34:58 <leino> dcoutts_: sorry for misspelling your name, btw. (white on yellow is hard to read :)
12:35:04 <bgamari> or another common typeclass
12:35:20 <EvanR_> leino: tab complete
12:35:26 <dcoutts_> leino: note that you're unzipping the query result and then fully consuming one side of it. But that means the other side of it is also retained in memory
12:35:35 <leino> EvanR_: thanks!
12:35:55 <Veinor> i really hope lenses make it into 7.8 or something as the new record syntax
12:36:02 <pdxleif> Whoah, I've been using irssi for years, and never knew it could do that.
12:36:06 <dcoutts_> leino: you'll need to think about how to process it linearly
12:36:09 <Veinor> especially with something like TDNR
12:36:59 <dcoutts_> leino: think about what this is doing: es <- g6ToEdgeList g6s
12:37:40 <dcoutts_> leino: you're consuming the query result (g6s) but the query result must still be held in memory because ns will be used later.
12:38:01 <dcoutts_> leino: additionally, you're doing the g6ToEdgeList before writing anything back to the db
12:38:24 <dcoutts_> leino: so that fact alone means you're necessarily retaining all the result of g6ToEdgeList before writing anything to the db
12:38:45 <dcoutts_> leino: so this is not a lazyness fail at all, if anything you're not lazy enough :-)
12:39:36 <dcoutts_> let (as, bs) = unzip ...   is almost always a bad pattern if the list is long. Consuming this in a way that uses constant space is hard
12:39:48 <dcoutts_> the only way really is to zip them back together!
12:39:55 <dcoutts_> so you shouldn't have done it in the first place
12:39:56 <S11001001> bgamari: flipFrets is sequence ZipList if you have Traversable Fret
12:40:29 <dcoutts_> leino: am I making any sense?
12:40:50 <bgamari> S11001001: Ahhh
12:41:23 <leino> dcoutts_: probably, but I don't understand you
12:42:01 * dcoutts_ has to go
12:42:03 <leino> first of all, why is unzip bad?
12:42:17 * dcoutts_ hopes someone else can explain that to leino 
12:42:28 <leino> dcoutts_: oh ok, well thanks for your comments anyways!
12:42:52 <bgamari> S11001001: Which Traversable operation would you choose to implement in the instance?
12:43:05 <johnw> hmm... isn't calling that a singleton tuple a misnomer?
12:43:22 <johnw> a singleton tuple makes me thinks of a tuple that there could only ever be one of
12:43:31 <johnw> like () is a singleton
12:43:32 <S11001001> bgamari: they're all pretty trivial
12:43:48 <johnw> i think it should be called a unary tuple
12:44:35 <monochrom> I never called () a singleton tuple. I called either "empty tuple" or "singleton"
12:44:45 <johnw> i mean the package that was linked above
12:44:49 <johnw> Data.Tuple.OneTuple
12:45:14 <S11001001> bgamari: you should also write up Applicative Fret; more playing with ziplist might lead you to a traversal for unflip
12:45:17 <johnw> it's a "tuple" of one element
12:45:21 <Cale> @src unzip
12:45:21 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
12:45:23 <johnw> a oneple
12:45:41 <Cale> heh, of course
12:45:51 <monochrom> well yeah English is flexible. have fun
12:46:02 <bgamari> S11001001: Already have it
12:46:56 <DanBurton> sanity check: did I do this right? https://github.com/snoyberg/basic-prelude/commit/82335c1351c124598f1ea8b22fabefad43401a01
12:47:12 <DanBurton> (regarding CPP)
12:48:12 <monochrom> I think yes
12:49:06 <DanBurton> It seems to happily "cabal build", but now when I load the file into ghci, CPP gets grumpy at me and says error: missing binary operator before token "("
12:49:42 <DanBurton> what incantation do I have to do so that CPP can find the correct .h files when I want to load the file in ghci?
12:50:04 <Cale> leino: So, suppose you write something like (xs,ys) = unzip ps. If you consume a bunch of elements of xs, and then later return and consume the elements of ys, the elements of ys (or at least pointers to code for them) are going to be constructed at the same time as the elements of xs are
12:50:37 <Cale> leino: and so you'll use linear space
12:51:26 <monochrom> it's cabal who made the *.h files and defined those macros. if you haven't erased them, they are somewhere under dist/
12:51:31 <Cale> leino: If instead, you can process them in parallel or in an order where you handle one element of each, back and forth, then the ones you've already dealt with become garbage, and you have a shot at O(1) space
12:51:47 <Cale> leino: Does that make sense?
12:53:46 <DanBurton> monochrom: yes, they're at dist/build/autogen/cabal_macros.h, but I can't seem to find the ghci option that will let me communicate this
12:53:57 <leino> Cale: I am working on getting rid of the unzip totally. I dont need to read the ns at all, I can compute them from es trivially. I just read them since they're there.
12:56:56 <DanBurton> got it: ghci -optP-include -optPdist/build/autogen/cabal_macros.h test.hs
12:57:01 <johnw> when I run "lambdabot" from cabal on OS X, it initializes plugins and then just sits there (no prompt).  Any clues how to go about debugging this?
12:57:02 <leino> Cale: but I still dont understand: in my opinion I am kind of consuming the unzipped values in parallell, since I am doing zipWith on ns with es, and the es are computed from the g6s directly.
13:06:12 <mk> are booleans under xor a monoid?
13:06:40 <shachaf> Yep, xor and 0.
13:06:49 * hackagebot wtk-gtk 0.1 - GTK tools within Wojcik Tool Kit  http://hackage.haskell.org/package/wtk-gtk-0.1 (BartoszWojcik)
13:07:42 <mk> not included in Data.Monoid, though?
13:08:20 <shachaf> I don't think so.
13:21:49 * hackagebot haslo 0.1 - Loan calculator engine.  http://hackage.haskell.org/package/haslo-0.1 (BartoszWojcik)
13:26:49 * hackagebot hasloGUI 0.1 - Loan calculator Gtk GUI. Based on haslo (Haskell Loan) library.  http://hackage.haskell.org/package/hasloGUI-0.1 (BartoszWojcik)
13:29:26 <edenc> heh, my younger brother just started his CS major and he's learning programming with some bulshit pseudo-language, then I showed him the equivalent haskell solutions for his homework and he's like "wow, a lot easier", just thought I'd throw that out there :)
13:30:12 <DT`> edenc, pseudo-pascal, pseudo-C or pseudo-java?
13:30:35 <edenc> DT`: pseudo-pascal translated to portuguese
13:31:03 <zhulikas> that's just sad
13:31:07 <DT`> sounds bad.
13:31:17 <DT`> good luck to your brother, edenc.
13:31:18 <edenc> he's going to the same college I did
13:31:26 <Saizan> we had pseudo-pascal too
13:31:39 <edenc> 90% of the class flunks the initial algorithm semester
13:31:53 <edenc> because the way they teach things with those pseudo-languages is bulshit
13:32:25 <edenc> a particular exercise had him compare two numbers and say which is the greater of them, he was particularly shocked by my implementation using guards :)
13:32:35 <zhulikas> :D
13:33:38 <Cale> leino: hmm...
13:33:51 <Cale> leino: So long as you do consume both lists, I think everything should be okay
13:34:05 <Cale> leino: But I don't know what your code is actually doing.
13:34:56 <zhulikas> @pl f a b = if a > b then a else b
13:34:56 <lambdabot> f = join . (flip =<< (if' .) . (>))
13:35:00 <zhulikas> lovely :D
13:35:30 <ion> max a b
13:35:37 <zhulikas> oh yes, max
13:35:45 <zhulikas> @src max
13:35:45 <lambdabot> max x y = if x <= y then y else x
13:35:48 <shachaf> @pl f a b = if a < b then a else b
13:35:48 <lambdabot> f = join . (flip =<< (if' .) . (<))
13:35:53 <shachaf> Also known as "sam a b"
13:36:05 <look\AWAY> hi! sorry for interrupt but is there a channel for OOP on freenode?
13:36:19 <zhulikas> OOP is last century
13:36:26 <zhulikas> now all the cool kids do Haskell
13:36:29 <look\AWAY> yeah i know
13:36:34 <look\AWAY> yeah i know
13:36:43 <zhulikas> try #java
13:36:44 <ion> Perhaps #smalltalk or ##smalltalk exists.
13:36:50 <Saizan> look\AWAY: there are channels for many OOP languages, they likely know better there
13:37:05 <look\AWAY> ok thanks
13:37:19 <DT`> I feel kind of bad that there's no general compsci channel.
13:37:33 <zhulikas> there is #programming
13:37:49 <DT`> programming's not really compsci.
13:37:51 <edenc> compsci != programming
13:38:04 <DT`> and ##cs is deader than death.
13:39:50 <leino> Cale: basically it is reading two collumns from a database, g6s and ns, sending one of them (g6s) to an external command and reading back es as a result, then it combines es and ns with zipWith and writes the result of that into the database again
13:41:10 <Cale> leino: When you send the first element of g6s to that other function, do you get the first element of es back immediately? Or do you need to send the *whole* list before a single element of the result becomes available?
13:41:15 <leino> the external command is showg and should work with pipes, taking a line at a time and producing a few lines as a result
13:41:25 <Cale> hmm
13:41:34 --- mode: wolfe.freenode.net set +o ChanServ
13:42:28 <zhulikas> nice
13:42:40 <zhulikas> wait for more
13:43:30 <leino> Cale: I wonder if the parsing might be the issue?
13:43:52 <tew88> Anyone available to hold my hand through the following? http://hpaste.org/73542 -- I'm keen to see how the do notation could be rewritten in terms of bind
13:44:59 <hpc> tew88: instead of going through the example you gave, i will construct a simpler one
13:45:02 <hpc> foo = do
13:45:08 <hpc>   pat <- action 1
13:45:11 <hpc>   action 2
13:45:16 <hpc>   action 3
13:45:20 <hpc> this is translated to
13:45:23 <hpc> foo =
13:45:24 <Cale> [(c+2, r-1), (c+2, r+1), (c-2, r-1), (c-2, r+1),(c+1, r-2), (c+1, r+1), (c-1, r-2), (c-1, r+2)] >>= \(c',r') -> guard (c' `elem` [1..8] && r' `elem` [1..8]) >> return (c',r')
13:45:29 <hpc>   action 1 >>= \pat ->
13:45:34 <hpc>   action 2 >>= \_ ->
13:45:37 <hpc>   action 3
13:45:49 <zhulikas> @hoogle guard
13:45:50 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
13:45:50 <lambdabot> Language.Haskell.TH.Syntax data Guard
13:45:50 <lambdabot> Language.Haskell.TH data Guard
13:45:57 <timthelion> is single file deployment of haskell programs(including gtk) possible on windows yet?
13:46:02 <hpc> which translates to what Cale said
13:46:17 <S11001001> @pl p x -> if p x then return x else mzero
13:46:17 <lambdabot> (line 1, column 5):
13:46:18 <lambdabot> unexpected ">" or "-"
13:46:18 <lambdabot> expecting variable, "(", operator or end of input
13:46:20 <hpc> it's easier to see how the translation works if you write it out onto multiple lines the way i did
13:46:29 <S11001001> @pl \p x -> if p x then return x else mzero
13:46:29 <lambdabot> flip flip mzero . (`ap` return) . (if' .)
13:46:48 <tew88> hpc, Cale: Thanks a lot
13:49:49 <Cale> timthelion: Is single-file deployment of programs ever possible on Windows?
13:49:54 <Cale> timthelion: ;)
13:50:18 <hpc> Cale: of course
13:50:20 <hpc> install.exe
13:50:25 <Cale> hehe
13:51:50 * hackagebot QIO 1.2 - The Quantum IO Monad is a library for defining quantum computations in Haskell  http://hackage.haskell.org/package/QIO-1.2 (AlexanderGreen)
13:53:52 <hpc> well, with a description like that, there's no possible way i am not clicking through to docs on that package
13:56:09 <JoeyA> hpc: Why not?
13:58:25 <hpc> JoeyA: double negatives ;)
13:59:52 <JoeyA> h
13:59:54 <JoeyA> oh*
14:00:17 <JoeyA> Then why not not?  :-)
14:01:38 <DanBurton> question about type aliases, haddock, and ghci: http://hpaste.org/73543
14:04:14 <DanBurton> maybe this is a good use case for type signatures within the module export list
14:06:14 <DanBurton> any ideas? echoooooo echooo echoo
14:09:13 <hpc> echoooo
14:09:21 * hpc reads the paste
14:10:01 <hpc> yeah, no idea how to pull that off
14:18:17 <ReinH> edwardk: btw look what I found :) http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.49.2591
14:28:31 <DT`> continuations are functions at continuation-level, things at continuation-level are cothings at value-level, are continuation coexponentials?
14:28:38 <DT`> *continuations
14:41:51 * hackagebot fast-tagsoup 1.0.1 - Fast parser for tagsoup package  http://hackage.haskell.org/package/fast-tagsoup-1.0.1 (VladimirShabanov)
14:42:07 <newsham> can cabal build make a ctags tag file?
14:42:09 <daniel_-> API docs after API docs, never any real tutorial or howtos except for the web frameworks
14:42:42 <daniel_-> but damn have i learned much going to haskell from python and forcing me to just figure stuff out from the API docs
14:42:57 <NihilistDandy> I've always found API docs are much more helpful in Haskell than in other languages.
14:43:03 <daniel_-> yeah thats true
14:43:40 <NihilistDandy> Example code is great, but for a lot of plumbing it's not hugely necessary. The type system helps out a lot.
14:45:14 <BMeph> Is there a reason why 'join' hasn't been made a (defining) method of Monad?
14:45:23 <typoclass> NihilistDandy: sounds weird. which other languages are you comparing to?
14:46:15 <madjestic> BMeph, isn't 'join' a natural transformation of any Monad?
14:46:54 <NihilistDandy> typoclass: There's a very good chance I've just worked with shitty APIs. Mostly stuff in PHP, C, and Perl.
14:47:49 <mk> BMeph: why should it be?
14:48:36 <OceanSpray> so what's the deal with typeclass constraints in data definitions?
14:48:49 <jfischoff> don't
14:48:53 <typoclass> NihilistDandy: if comparing to java or python, haddock is not that great, has always been my impression
14:49:02 <daniel_-> anyone knows about any good resources for learning about conduits?
14:49:19 <OceanSpray> sometimes it allows me to omit the constraint in my functions, but in other places it doesn't and gives me weird type errors
14:49:42 <NihilistDandy> typoclass: I don't have much experience with either, so I'm sure that's colored my perception. Java's the implementation language in my upcoming algo course, though, so I guess I'll have to get the hang of it.
14:49:49 <typoclass> daniel_-: i think there's a chapter in the yesod book or something. it describes an older version, but you can easily get the gist
14:50:03 <daniel_-> thanks
14:50:34 <jfischoff> daniel_: I would also checkout DanBurton blogs to to get walk through of the types http://unknownparallel.wordpress.com/2012/07/25/pipes-to-conduits-part-1-yield-and-await/
14:50:44 <NihilistDandy> daniel_-: Snoyman made a blog post about them, too: http://www.yesodweb.com/blog/2011/12/conduits
14:51:16 <NihilistDandy> Again, probably a bit out of date, but worth a read
14:52:07 <daniel_-> jfischoff oh i had forgot about that, actually had it bookmarked for a later occasion, guess thats around now :)
14:52:15 <int-e> The Cabal testsuite is crazy ... it uses hpc for test coverage (laudible), with the same file collecting data from several executables (wacky, but they're produced from identical Setup.hs files). However, this only works if the modification times of the files are the same as well. Took ages to find :-(
14:52:58 <jfischoff> OceanSpray: type class constraints on data declarations are generally thought to be a mistake. I wouldn't use them. GADTs and do something similar, but most likely you want to have type class constraints on your functions
14:53:09 <OceanSpray> okay then
14:55:45 <dmwit> BMeph: No, no reason.
14:55:56 <dmwit> It would be quite convenient for certain monads, in fact.
14:58:20 <ReinH> it actually seems like minimax is easier to specify than negamax
15:00:15 <armlesshobo> anyone ever have Philip Wadler as a professor?
15:01:18 <dcoutts_> int-e: I don't follow
15:02:56 <NihilistDandy> armlesshobo: No, but if you do, I'm jealous.
15:07:13 <int-e> dcoutts_: I added a test below Cabal/tests/PackageTests, modelled after  tests/PackageTests/BuildDeps/SameDepsAllRound/* ... so I copied the Setup.hs file, made a new package, and a custom Check.hs file. Then I ran the testsuite and it would fail during "Setup clean" of all things. After adding some logging, I found that the executable complained about  ./dist/hpc/tix/unit-tests/unit-tests.tix  not matching its main module.
15:07:17 <nickmeharry> I'm having some trouble installing Pandoc. Any idea what went wrong here? http://pastebin.com/ugggQm1s
15:07:19 <mauke> The paste ugggQm1s has been copied to http://hpaste.org/73545
15:07:49 <dcoutts_> int-e: ahh, cabal's own testsuite
15:08:22 <dcoutts_> int-e: think you can fix it?
15:10:00 <int-e> dcoutts_: Don't use hpc? I'll think about it, there should really be only one Setup executable used for all the builds rather than one for each package.
15:11:36 <NihilistDandy> mauke: What version of GHC?
15:11:48 <dcoutts_> int-e: I'm still not sure I get what the problem is exactly. Are the .tix files for each part aliasing when they should be separate?
15:14:13 <int-e> dcoutts_: actually I suspect it's intentional; we want coverage information collected over all the tests rather than each test individually. but I can't pinpoint where the aliasing happens right now, so I'm not sure.
15:14:42 <rosie> What's the meaning of the dollar sign in: u <*> pure y = pure ($ y) <*> u
15:15:08 <dcoutts_> int-e: ok
15:15:08 <shachaf> rosie: it's the same as the normal $
15:15:09 <hpc> rosie: ($) is function application as an operator
15:15:11 <shachaf> f $ x = f x
15:15:13 <hpc> ($) f x = f x
15:15:17 <hpc> or (f $ x) = f x
15:15:22 <hpc> in this case, it's a section
15:15:27 <NihilistDandy> rosie: It's a section. Just like (+1)
15:15:28 <hpc> like (* 2)
15:15:35 <shachaf> rosie: Except it's a section. You know how (+ 5) = (\x -> x + 5), right?
15:15:41 <hpc> ($ x) = \f -> f x
15:15:55 <shachaf> Yes, what everybody else said.
15:16:00 <int-e> dcoutts_: more about this tomorrow (if you're there), I have to sleep, good night.
15:16:35 <hpc> rosie: everyone in #haskell has to meet their helpfulness quota for the month, hence lots of answers ;)
15:16:37 <ReinH> So this is my minimax using Data.Tree (rose tree) as the data structure: http://hpaste.org/73546
15:16:40 <ReinH> looks ok?
15:16:46 <dcoutts_> int-e: thanks, g'night
15:17:39 <ReinH> can I use the foldable or traversable instance properties of Data.Tree to make this even simpler?
15:20:58 <byorgey> ReinH: you can't, actually.
15:21:18 <byorgey> ReinH: Foldable/Traversable give you a scheme for iterating over a structure, but they don't let you take advantage of the shape of the structure itself
15:21:52 <byorgey> in this case you really do need the structure of the tree, because you use the White/Black information to decide how to process a node's children
15:22:37 <byorgey> ReinH: looks good, by the way.
15:23:59 <rosie> haha, thanks so much, all! shachaf: Yep, I just went and learned about sections -- I didn't know that's what they were called
15:25:01 <shachaf> rosie: Did you figure out the fmap thing?
15:26:23 <ReinH> byorgey: thanks
15:26:30 <ReinH> byorgey: and thanks
15:26:57 <rosie> shachaf: I'm going back through LYAH (I just learned about Applicatives, and am about to read about Monads). What's keeping me from answering the question is that it seems the value is generated based only on the state input. I'm not sure how an a -> b function could act directly on the values, when the states aren't affected. Does that make sense?
15:27:10 <shachaf> rosie: Not really. :-)
15:27:12 <ReinH> byorgey: the goal is to generate the tree rather than use an infinite search tree, since generation allows me to preorder
15:27:23 <ReinH> and add search extensions
15:27:29 <shachaf> rosie: I'm not sure what the "state input" is. There's no state, it's just a regular function.
15:27:34 <ReinH> preordering will come in handy when I add alpha-beta pruning
15:28:04 <rosie> shachaf: I'll probably get it by the time I finish reading LYAH… oh, by "state input" I mean s -> (a, s). The first 's' is what I call the "state input"
15:28:20 <rosie> shachaf: e.g. a random number generator would have the previous random generator as its state input
15:28:23 <shachaf> rosie: Oh, I thought you were talking about (a -> b) -> (r -> a) -> (r -> b)
15:28:38 <rosie> shachaf: Nope, I think I've figured that out.
15:29:36 <shachaf> OK. So my advice for State is to try to do some state-style things without actually using State, just to get a feel for how they work.
15:29:52 <shachaf> Once you get used to passing the state around manually, you can abstract it.
15:31:14 <shachaf> That is, first figure out what "s -> (a,s)" means and how it works.
15:31:45 <shachaf> rosie: (Also, you should get practice at writing functions based on their signatures!)
15:33:58 <armlesshobo> NihilistDandy: lol, i'd be too.
15:34:06 <armlesshobo> he looks like he'd be an awesome professor
15:34:09 <armlesshobo> to have
15:34:41 <rosie> shachaf: is this the right thinking on the ((->) r) question?  You take the product of the r->a, which is the 'a' (say that r -> a is (+200)) then (a->b) operates on the result of the (r -> a). Let's say (a->b) is (*3). Then what the whole function will return is a composition of the (r->a) function and the (a->b) function. So we could try the result of the whole function fmap (*3) (+200)  on the input parameter 40, and we'll get first 24
15:34:41 <rosie> and then feed this into the (a -> b) of the fmap, which is (*3), so we'll have 720. And so, for ((->) r), fmap = '.'   Yeah?
15:35:28 <danr> rosie: I couldn't follow through all of it, but I can affirm the last `Yeah?'
15:35:40 <shachaf> What danr said. :-)
15:35:45 <rosie> ha, thanks (:
15:35:54 <danr> :-)
15:35:56 <shachaf> rosie: I think you might be making it harder for yourself by using concrete types and functions, rather than easier.
15:36:34 <shachaf> rosie: When you have things like numbers, there are lots of functions :: Int -> Int. But when you're dealing as and bs, there's only a single function in the world of type a -> b
15:36:41 <armlesshobo> ((->) s as)
15:36:49 <armlesshobo> > ((->) Int String)
15:36:50 <lambdabot>   <no location info>: parse error on input `->'
15:37:07 <shachaf> rosie: Later you'll learn about Curry-Howard and it'll make even more sense!
15:37:08 <edwardk> shachaf: well a -> b if both are parametric is even easier ;)
15:37:24 <shachaf> edwardk: You mean (forall a b. a -> b)?
15:37:29 <edwardk> shachaf: yes =P
15:37:43 <edwardk> not sure if you meant a -> a
15:37:44 <shachaf> edwardk: undefined *and* const undefined!
15:37:47 <edwardk> =P
15:37:59 <shachaf> edwardk: We're talking about fmap :: (a -> b) -> (r -> a) -> (r -> b)
15:38:03 <rosie> shachaf: What do you mean there's only a single function in the world of type (a -> b) ? You could have length "cat", or fromInt 8.55
15:38:06 <edwardk> kinda figured
15:38:17 <shachaf> edwardk: And how it can be easier with abstract letters than concrete types.
15:38:25 <shachaf> rosie: No, because you don't know what a and b are.
15:38:28 <rosie> * fromInt 8
15:38:37 <shachaf> If you're dealing with Ints and Strings, there are lots and lots of functions.
15:39:02 <shachaf> But since your function is completely polymorphic, you don't know what a and b are. So the only function in the world of type (a -> b) is the one you were given.
15:39:06 <rosie> ahh, I see. So because a and b are par maters, we must have declared the function, and we can only use that function
15:39:23 <shachaf> Then it's like putting together a puzzle: I have an (a -> b) and a (b -> c), and an a. What can I do with them?
15:39:35 <shachaf> Well, I can put the "a" into the "a -> b", and now I have a "b".
15:39:43 <shachaf> Now I can put that "b" into the "b -> c", and now I have a "c".
15:39:45 <edwardk> rosie: if the only thing i know about a and b are that i have a function from (a -> b), given a function from r -> a, the only way i can get a function from r -> b is if I take the r, pass it to the function r -> a, get an a, and then pass it to the function a -> b to get a b. there is nothing else I can do that doesn't involve spinning forever.
15:39:48 <shachaf> That's pretty much the only thing you can do.
15:39:52 <edwardk> rosie: i have no other possible path to a b
15:40:14 <edwardk> since the only thing i know about b is that i have a function from a -> b
15:40:27 <shachaf> rosie: Whereas a valid implementation of foo :: (Int -> String) -> (Char -> Int) -> (Char -> String) is foo _ _ = \_ -> "hello"
15:40:27 <rosie> What if there are two b's in the declaration? Like, foo :: b -> b -> a ?
15:40:35 <shachaf> rosie: Then you can pick either one of them.
15:40:46 <edwardk> rosie: then you have more freedom in the implementation, and your function is less constrained
15:40:57 <danr> rosie: Yeah, so you can ask yourself how many functions there are of the kind "a -> a -> a", "a -> b -> a", or even "(a -> a) -> a -> a"
15:41:04 <shachaf> rosie: As it happens, in the exercises you get here, there's often only one possible implementation of the function you're given. :-)
15:41:13 <shachaf> rosie: (And in Curry-Howard it doesn't even matter.)
15:41:15 <danr> uh I guess that's better with s/kind/type/
15:41:18 <edwardk> in general making you fucntions as polymorphic as possible is a great way to constrain the possible space of implementations to where there are fewer ways you can screw up and still typecheck
15:41:37 <danr> couldn't agree more, edwardk
15:41:47 <shachaf> edwardk: Speaking of which, newsham once asked a question about counting the number of inhabitants of polymorphic functions.
15:41:47 <c_wraith> (a -> a) -> a -> a has a few possible implementations.
15:41:58 <edwardk> shachaf: dan piponi wrote a post on the topic
15:41:59 <shachaf> c_wraith: It has Nat implementations, in fact!
15:42:13 <c_wraith> shachaf: which is more than I want to write by hand.
15:42:16 <edwardk> c_wraith: as it should. ;)
15:42:20 <shachaf> (Since it's Nat.)
15:42:35 <hpc> c_wraith: flip const fix, flip const
15:42:40 <hpc> flip ($)
15:42:44 <hpc> and i think there's another
15:43:03 <shachaf> fix fox
15:43:04 <edwardk> hpc: you can iterate the function on the left n times before giving back the resulting a
15:43:09 <hpc> oh yes
15:43:14 <shachaf> edwardk: Or ∞ times!
15:43:24 <hpc> so it's kinda like Nat + 1
15:43:24 <rosie> edwardk: Thanks, do you mean we'll make our function polymorphic by parameterization, but that we'll reduce the number of parameters that are labeled with the same name, so that we don't use parameters in the wrong order?
15:43:27 <edwardk> hpc: since we're in a lazy language we have the one point compactification of that, so you can also use fix
15:43:38 <edwardk> rosie: correct
15:43:41 <c_wraith> however, the implementations have a common schema:  iterate f x !! n, for each n ≥ 0
15:43:51 <shachaf> c_wraith: Except for fix.
15:44:07 <ion> > fix fox
15:44:08 <edwardk> c_wraith: the compactification gives you infinity as well
15:44:09 <lambdabot>   "Fair and Balanced(TM)"
15:44:10 <shachaf> elliott once tried to figure out an implementation of iterate that let you get the fixed-point out of the return value without any special cases.
15:44:17 <danr> @src fox
15:44:17 <lambdabot> Source not found. Maybe you made a typo?
15:44:40 <shachaf> edwardk: What was dpiponi's post?
15:44:49 <danr> shachaf: I guess you can do it with data N = S N | Z, (!!) :: [a] -> Nat -> a
15:44:53 <edwardk> shachaf: look for something about memoizing polymorphic functions
15:44:55 <c_wraith> shachaf: hmm.  yes.  fix f is also an implementation.  Though not logically sound!
15:45:00 <danr> and then xs !! fix S
15:45:17 <edwardk> http://blog.sigfpe.com/2009/11/memoizing-polymorphic-functions-with.html
15:45:20 <shachaf> c_wraith: Logically you don't care about how many times you apply (a -> a) anyway.
15:45:23 <c_wraith> danr: that implementation is just _|_
15:45:25 <shachaf> edwardk: Thanks.
15:45:32 <edwardk> conal wrote something later: http://conal.net/blog/posts/memoizing-polymorphic-functions-via-unmemoization
15:45:48 <danr> c_wraith: hmm that is indeed a problem
15:46:02 <edwardk> c_wraith: its funny how useful logical paradoxes are in programming ;)
15:46:11 <shachaf> rosie: If you want some more interesting exercises of this sort, try writing the instances for Cont. :-)
15:46:13 <edwardk> loeb's paradox makes a great spreadsheet
15:46:23 <c_wraith> edwardk: just means our languages aren't good enough yet, right? :)
15:46:36 <shachaf> foo :: ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
15:46:48 <edwardk> @djinn  ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
15:46:49 <lambdabot> f a b c = a (\ d -> b d c)
15:46:52 <edwardk> done!
15:46:53 <NihilistDandy> Arr arr arr
15:46:56 <shachaf> edwardk: Spoilsport.
15:47:00 <shachaf> edwardk: Don't make me go rank-2!
15:47:04 <edwardk> =P
15:47:08 <NihilistDandy> Sorry, *arr, abrr, brr
15:47:21 <shachaf> @yarr
15:47:21 <lambdabot> Prepare to be boarded!
15:47:41 <monochrom> arr, prepare to be brr
15:47:43 <NihilistDandy> foo = (. flip) . (.)
15:48:26 <edwardk> newtype PlanT k i o m a = PlanT  { runPlanT :: forall r. (a -> m r) ->  (o -> m r -> m r) -> (forall z. (z -> m r) -> k i z -> m r -> m r) -> m r -> m r } -- is a monad i actually use ;)
15:48:35 <edwardk> rank-3 even ;)
15:48:51 <hpc> gadzooks
15:49:01 <NihilistDandy> My brain ಥ_ಥ
15:49:20 <shachaf> @remember edwardk newtype PlanT k i o m a = PlanT  { runPlanT :: forall r. (a -> m r) ->  (o -> m r -> m r) -> (forall z. (z -> m r) -> k i z -> m r -> m r) -> m r -> m r } -- is a monad i actually use ;)
15:49:20 <lambdabot> I will never forget.
15:49:25 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Plan.hs#L49
15:49:53 <shachaf> edwardk: Is that one of those CPSed-for-performance-or-something monads?
15:50:18 <edwardk> shachaf: its cps'd partially for performance but the existential turned universal that makes it rank 3 is for type inference
15:50:20 <NihilistDandy> That is an extremely descriptive readme :D
15:50:23 <hpc> it looks vaguely like Codensity (i think that's the right name?)
15:50:50 <edwardk> NihilistDandy: sorry. haven't gotten around to adding a bunch of complex examples and motivation to the readme yet =)
15:50:59 <NihilistDandy> Haha. Short version, maybe?
15:51:07 <NihilistDandy> Not sure what I'm looking at
15:51:07 <edwardk> basically you write plans for machines, plans are like pipes or conduits
15:51:17 <edwardk> you compile the plans into machines
15:51:19 <NihilistDandy> Oh, cool
15:51:38 <edwardk> machines, unlike pipes or conduits can read from multiple inputs, the 'shape' of their input space is determined by k
15:51:57 <edwardk> so you can have a 'Tee' machine, that can 'awaits L' or 'awaits R' to read from one of two inputs
15:52:05 <edwardk> instead of just being able to read from one supplier
15:52:25 <edwardk> and then you can attach one end of the tee to a source, and cap it off, leaving a linear process, etc.
15:52:35 <rosie> shachaf: I'll finish up LYAH on monads first.
15:52:41 <NihilistDandy> That's pretty neat, actually. Hell of a monad, though
15:52:55 <edwardk> basically they let you compose more complicated networks of machines than you can describe with iteratees, conduits or pipes
15:53:00 <edwardk> yep
15:53:29 <edwardk> the rank 3 type exists because otherwise type inference can't figure out how to default a certain functor that isn't needed when you build a source.
15:53:45 <edwardk> and it lets me avoid riddling code with type annotations
15:54:18 <edwardk> the first cps'ing was so you could build the plan using combinators without taking a performance hit
15:54:40 <edwardk> e.g. pipes if you aren't careful can actually get slower the deeper into your program you recurse
15:54:48 <edwardk> plans, being cps'd do not
15:54:55 <NihilistDandy> Very cool.
15:55:05 <NihilistDandy> Having the un-cps'd version in the haddock comments is a nice touch, too
15:55:09 <edwardk> and you compile the plan to a machine to get the flat representation that is cheap to inspect
15:55:22 <shachaf> edwardk: You should call them boats, after all the cpsizing they do.
15:55:30 <edwardk> shachaf: *groan*
15:55:40 * MostAwesomeDude starts slow clap
15:55:45 <edwardk> i was looking for good analogies when i was trying to name all this stuff. you should have spoken up then ;)
15:56:15 <MostAwesomeDude> edwardk: So how do these handle things like duplex proxies? Do you have a more elegant solution than the whole connect-and-resume thing?
15:56:18 <edwardk> NihilistDandy: anyways you can compile lots of other things to Machines
15:56:32 <edwardk> i still don't know what you mean
15:56:39 <edwardk> duplex proxy?
15:57:32 <MostAwesomeDude> Well, okay. So you've got a network server, and it's gotta handle two different clients. Once both clients are connected, it has to shuffle data between them. It *can't* ever block waiting for either client to say something; it has to move all available data from one to the other as soon as it's received.
15:58:06 <edwardk> MostAwesomeDude: you can use a Wye to wait for something from either of the inputs
15:58:15 <edwardk> MostAwesomeDude: A Tee is deterministic. A Wye is not
15:58:35 <edwardk> with a Tee you can 'awaits L' or 'awaits R' but you can't await on both
15:59:01 <edwardk> with a 'Wye' you can wait on X (the left input), Y (the right input) or 'Z' (either input in a driver-determined fashion)
15:59:46 <edwardk> this introduces non-determinism in the read order that is disambiguated by the driver
16:00:31 <hpc> edwardk: how do you come up with these things?
16:00:45 <edwardk> e.g. the 'wye' combinator attaches processes to each of the inputs of a wye, yielding a 'longer wye', that combinator tries to read in a left biased fashion, unless the newly bound process would block, then it switches to the other
16:00:49 <edwardk> hpc: ?
16:01:26 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Wye.hs#L57 is the most baroque function in the whole codebase
16:01:52 <hpc> edwardk: the structures in your code are massively more complex than anything i have ever seen
16:01:56 <edwardk> hpc: this came up because apocalisp, pchiusano and dolio were playing around with stream processing at the office and i wanted a nicer way to unify all their stuff into one construction
16:02:25 <edwardk> hpc: chronic overengineering? =)
16:02:43 <MostAwesomeDude> edwardk: Okay. So, this would let me construct a thing waits for (a) delicious data from a client, or (b) a timer which will ding when the next thing needs to happen?
16:02:56 <hpc> edwardk: oh, cool
16:02:58 <edwardk> MostAwesomeDude: yes
16:03:18 <hpc> edwardk: my overengineering is generally of the "testing this irc bot is too slow, let's make it self-modifying" variety
16:04:03 <MostAwesomeDude> edwardk: Haha, now I can finally build Twisted in Haskell!
16:04:29 <edwardk> hpc: this is what machines started from: https://github.com/runarorama/tuebz/blob/a988062a6ba61ba98152b4e8453a2cf2ff1bd0b6/src/Xylo.hs
16:04:41 <edwardk> MostAwesomeDude: =)
16:04:50 <Nafai> MostAwesomeDude: Yay
16:05:12 <edwardk> MostAwesomeDude: i'm adding some new 'k' types for channels that support pushback (making them invariant) or peeking and metered consumption (that do not)
16:05:31 <NihilistDandy> MostAwesomeDude: You'll have to call it Rolled or something. It's not right if it's not a pun.~
16:05:49 <edwardk> and for file machines that can 'awaits $ Opening "Foo.hs" to get a handle you can awaits for lines from
16:06:22 <edwardk> trying to find the right model under which i can make input transformers that add each of these capabilities in a layered fashion
16:06:34 <MostAwesomeDude> NihilistDandy: "Helix".
16:06:40 <NihilistDandy> Perfect.
16:06:52 <MostAwesomeDude> O
16:07:32 <MostAwesomeDude> I've been waiting for this for a while. The big problem is that the Twisted paradigm is to have the event primitives be (a) reading from a socket, and (b) waiting for the nearest timer in a series of timers.
16:07:46 <MostAwesomeDude> Which is great if you have a select() in your language's library! But Haskell doesn't.
16:08:57 <edwardk> MostAwesomeDude: i'm not yet to the point where i can unconditionally recommend machines over pipes and conduit. the latter do better resource management than i do
16:09:07 <edwardk> pure machines have no resources to deal with
16:09:19 <edwardk> but i don't have any good combinators for manual resource cleanup in there yet
16:09:48 <acowley> edwardk: I'd like to somehow fold a constructor along a list, can I do this using the machinery in Control.Lens.Internal?
16:09:49 <edwardk> also its fairly awkward to do things like 'zip these two inputs, but don't consume unless input is available on both channels'
16:09:56 <Nafai> MostAwesomeDude: Can't wait to see Twisted-in-Haskell :)
16:10:06 <edwardk> acowley: You have Foo a b c ?
16:10:21 <edwardk> er you have Foo and [a,b,c] and want Foo a b c?
16:10:25 <acowley> yes
16:10:27 <acowley> the latter
16:10:32 <MostAwesomeDude> Nafai: Well, don't hold your breath; my plate is piled high and deep already.
16:10:34 <edwardk> acowley: the type changes, you're screwed =P
16:10:45 <acowley> I thought I could become coscrewed
16:10:50 <edwardk> alas
16:11:14 <acowley> The problem just looked like FunLists to me
16:11:20 <edwardk> ah
16:11:33 <edwardk> yeah there are FunLists in there as Kleene
16:11:44 <edwardk> but they are used to characterize a traversal
16:11:50 <edwardk> not as something the user should be using
16:12:07 <armlesshobo> can lazy evaluation be done in C/C++?
16:12:13 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal.hs#L253
16:12:19 <armlesshobo> i say no, but a friend is trying to convince me that it can be
16:12:28 <edwardk> armlesshobo: yes. just make your own thunk type
16:12:29 <mauke> armlesshobo: of course it can
16:12:34 <mauke> armlesshobo: hugs is written in C
16:13:16 <acowley> edwardk: Yeah, that's just the data type that got me thinking on it
16:14:05 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Traversal.hs#L333 is the only use of them in the library
16:14:40 <edwardk> they let me take something monomorphic and make a traversal that can be used to apply any applicative functor
16:15:15 <edwardk> basically a much more complicated way to describe a Traversal is: a -> Kleene c d b
16:15:30 <edwardk> that would be the data-lens style encoding of it
16:15:58 <typoclass> armlesshobo: if you do f(g()) in c, it will at that point evaluate g() and then pass the result to f. i don't see how that could be made lazy. you could pass around a whole lot of function pointers, but ... yikes
16:16:14 <armlesshobo> typoclass: that's what I was getting at
16:16:29 <geekosaur> typoclass:  all you need is a closure.  closures can be done in C but are unwieldy at best
16:16:34 <shachaf> I think this is an argument about words rather than about meaning.
16:16:36 <armlesshobo> i tried to explain that you can't bind expressions to a variable in C, naturally.
16:16:48 <armlesshobo> geekosaur: ahhhh
16:16:48 <shachaf> First decide what "lazy" means and then you'll know whether C can do it or not.
16:16:49 <geekosaur> nevertheless it is possible, and as noted Hugs is proof
16:17:17 <edwardk> comonad coalgebras of the kleene store comonad describe non-type changing traversals. indexed comonad 'coalgebroids' of the indexed kleene store comonad are a great way to impress your friends and characterize 'Traversal'
16:17:36 <typoclass> shachaf: let's say that c can't comfortably do the sort of laziness we know from haskell
16:17:55 <shachaf> typoclass: I stand by what I said.
16:18:07 <shachaf> Except now you have to define "comfortably" as well as "laziness".
16:18:22 <edwardk> typoclass: it can do it, you just need to make data structures that represent the thunks
16:19:03 <typoclass> shachaf: if "the sort of laziness we know from haskell" is too undefined for you, you should ask the folks in #haskell
16:19:22 <acowley> Well, it certainly sounds exotic, but I don't know why I would want an indexed comonad coalgebroid of the indexed kleene store comonad.
16:19:50 <armlesshobo> edwardk: right
16:19:55 <edwardk> acowley: a -> Kleene c d b can be stored in a data structure without impredicative types. Traversal a b c d is higher rank and cannot
16:20:16 <armlesshobo> my issue was that i kept thinking incorrectly about it
16:20:18 <armlesshobo> it happens
16:20:25 <edwardk> a -> Kleene c d b requires nothing more than haskell 98. Traversal a b c d wrapped in a constructor requires rank 2 types
16:21:34 <edwardk> so if you want to store traversals, and have to work with people who don't understand rank 2 types, you can always revert to indexed kleene coalgebroids ;)
16:21:54 * hackagebot errors 1.3.0 - Simplified error-handling  http://hackage.haskell.org/package/errors-1.3.0 (GabrielGonzalez)
16:22:02 <NihilistDandy> "you can always revert to indexed kleene coalgebroids" he says~
16:22:34 <edwardk> NihilistDandy: that is deliberately tongue in cheek and obfuscatory
16:22:36 <mauke> yeah, I'm tempted to quote like half of what edwardk said out of context in other channels
16:22:46 <NihilistDandy> edwardk: Haha, I know. "~" is sarcasm
16:23:03 <edwardk> i was expecting:
16:23:16 <edwardk> Haha, I know. "~" is sarcasm~
16:23:25 <NihilistDandy> mauke: I'm headed to #php with that nonsense.
16:23:27 <Saizan> btw, we should think of Traversal a b c d as being made of cloneTraversal (composeCoalgebroids l) values, i guess? a bit like a DList + generalization
16:23:28 <acowley> edwardk: getB (More 1 (More 2 (More 2 (Done Foo)))) is basically what I want. It just seems so close to being workable!
16:23:48 <NihilistDandy> edwardk: heh
16:23:48 <mauke> NihilistDandy: report results in -blah!
16:24:10 <edwardk> Saizan: yes, a valid traversal shouldn't change under that operation
16:24:21 <edwardk> er rather
16:24:28 <edwardk> cloneTraversal l = l should hold
16:24:51 <Saizan> my l is (a -> Kleene c d b)
16:24:57 <edwardk> ah
16:25:37 <edwardk> mine is ((c -> Kleene c d d) -> a -> Kleene c d b) -- which i just pass the obvious c -> Kleene c d d
16:25:44 <edwardk> (More (Done id))
16:26:02 <edwardk> that way i take a traversal to a traversal
16:26:32 <acowley> apfelmus's putAs partial function is actually just about there
16:26:34 <edwardk> Saizan: i'll probably add 'reified' lenses, traversals, etc. that are just the appropriate coalgebroids
16:26:48 <acowley> all that's required is having a dummy FunList that matches the constructor's arity
16:27:02 <acowley> i.e. More undefined (More undefined (More undefined (Done Foo)))
16:27:15 <edwardk> acowley: looks like something out of Data.Data
16:27:15 <Saizan> edwardk: yep, as one applies an (Endo a) to mempty to get the 'a' out, i wanted to confirm if this was the right intuition
16:27:21 <acowley> then you can take a list of arguments, reverse it, then putAs then getB
16:27:27 <edwardk> Saizan: looks right
16:27:40 <acowley> so, getB . putAs dummy . reverse :: [a] -> Foo a
16:27:54 <edwardk> acowley: *twitch*
16:27:55 <lpsmith> why is it taking 500-600 mb of memory to link my programs,  sending my computer into a swap-fest?
16:28:00 <edwardk> acowley: that probably would work
16:28:10 <acowley> it does work, I tried it :)
16:28:15 <edwardk> its partial as all hell
16:28:24 <acowley> but the need for the dummy value associated with the type is a little janky
16:28:40 <Saizan> the dummy should be easy to build with typeclasses
16:28:51 <edwardk> maybe you can make a nicer version that succeeds with Just a Foo or fails with Nothing
16:29:03 <Saizan> and for constructors it shouldn't even give you ambiguity problems
16:29:10 <acowley> edwardk: your colleague already addressed the partiality issue on Twan's blog post
16:29:17 <acowley> putAs f [] = f
16:29:25 <acowley> the types check, I'm sure it's fine!
16:29:38 <acowley> Saizan: yes, that's what I'm thinking
16:29:44 <edwardk> acowley: thats only part of it, no? what happens when you underflow?
16:29:47 <squidz> does anybody know what i cant seem to import some libraries, even after installing them with cabal? here is my source http://hpaste.org/73547
16:29:49 <edwardk> oh you get undefines
16:29:52 <acowley> yea
16:30:14 <squidz> I cant import Network.Curl.Download, but i can import Network.Curl
16:30:15 <monochrom> ghc-generated code tends to drive up the linker. try the gold linker
16:30:18 <acowley> But perhaps we could use Nothings
16:30:31 <hpc> don't use gold if you have 7.4.1 though
16:30:37 <edwardk> acowley: you could also just traverse a mempty'd Foo and fill it in by folding the values out of the list
16:30:39 <hpc> there's a bug that makes it pass an unrecognized linker flag
16:30:48 <NihilistDandy> squidz: I don't think curl has such a module
16:31:09 <squidz> NihilistDandy: is this the wrong curl? http://hackage.haskell.org/packages/archive/download-curl/0.1.1/doc/html/Network-Curl-Download.html
16:31:09 <acowley> edwardk: is there an integer indexed setter in lens?
16:31:21 <edwardk> acowley: element and elementOf
16:31:24 <hpc> squidz: run "ghc-pkg list | grep curl"
16:31:28 <edwardk> they are full fledged lenses
16:31:32 <acowley> oh, I thought those were just getters
16:31:42 <monochrom> oh, I know that one. ghc adds an unrecognized linker flag when producing lib (vs exe). the flag precisely tries to tell the linker to use less memory!
16:31:47 <edwardk> almost everything runs both ways ;)
16:32:00 <NihilistDandy> Oh, look at that. I though you meant the curl lib. Hmm. That is odd, then.
16:32:12 <monochrom> so, for example, in practice, you run into it when "cabal install" only
16:32:13 <squidz> i had the same problem with another package
16:32:24 <mauke> squidz: what's the error message? what command did you use?
16:32:31 <frio> there are quite a few configuration libraries on hackage; does anyone have any recommendations/preferred solutions?
16:32:38 <edwardk> acowley: https://github.com/ekmett/ad/blob/master/src/Numeric/AD/Internal/Combinators.hs#L21 might just work
16:33:08 <squidz> mauke: Could not find module 'Network.Curl.Download'
16:33:43 <NihilistDandy> what does `ghc-pkg list | grep curl` say?
16:33:56 <mauke> squidz: and what's the actual error message?
16:33:58 <squidz> okay I figured it out. I had to cabal install download-curl
16:34:03 <squidz> and not just cabal install curl
16:34:03 <edwardk> acowley: zipwithT const xs (pure undefined)  would replace the elements of a Foo constructor with the elements of the list
16:34:14 <lpsmith> http://www.haskell.org/pipermail/glasgow-haskell-users/2010-April/018724.html
16:34:26 <lpsmith> Well, I'm not the only person to observe this phenomenon
16:34:41 <acowley> edwardk: now just to Maybe-ify it and we'll have something!
16:34:56 <edwardk> i use that all over inside AD, where i can know that i'm zipping 'f's with the same 'f' or a traversal of it that i was given
16:35:29 <edwardk> since i have no other supply of 'f's and i know traverse can't change the element count its safe for me to zip things that you can't zip safely after i hand them back to you
16:35:58 <edwardk> thats why all the ad combinators try to keep all the functors jammed together, and use cofree, etc.
16:36:08 <edwardk> rather than unzipping into a Jet by default
16:37:13 <acowley> don't I want flip const?
16:37:35 <edwardk> zipWithT :: (Foldable f, Traversable g) => (a -> b -> c) -> f a -> g b -> g c
16:37:42 <edwardk> you want the values from 'f' in your 'g'
16:37:54 <acowley> oops, right
16:42:28 <lpsmith> nice, that thread has a solution, now I just need to recompile binutils
16:46:59 <ReinH> edwardk: so I have a thing
16:47:12 <ReinH> edwardk: not sure about a/b but minimax is 3 lines http://hpaste.org/73546
16:50:58 <acowley> edwardk: http://hpaste.org/73549
16:51:04 <edwardk> ReinH: not bad
16:51:18 <ReinH> edwardk: not bad eh
16:51:36 <edwardk> ReinH: it has the benefit of being obviously correct
16:51:47 <ReinH> I like that benefit :)
16:52:57 <ReinH> edwardk: would you change anything
16:52:58 <ReinH> ?
16:53:26 <edwardk> ReinH: yes, from using minimax to negascout or alphaBeta ;)
16:53:32 <ReinH> edwardk: well yes :p
16:53:37 <edwardk> let me just bang out a negascout and see if i can make it pretty
16:53:43 <ReinH> edwardk: ok!
16:53:51 <ReinH> might be easier to start with alphabeta ofc?
16:54:06 <ReinH> edwardk: also wondering if this algo can be modified easily to incorporate pruning
16:54:11 <NihilistDandy> Has anyone in here read Modern Compiler Implementation in ML? I'm picking up the Dragon book soonish and I was thinking of grabbing that one, as well.
16:54:12 <ReinH> *this shape
16:54:33 <ReinH> edwardk: maybe with break?
16:55:00 <ReinH> (break would seem like the obvious choice for list pruning after all)
16:55:13 <dolio> I've read Modern Compiler Implementation in Java.
16:55:24 <dolio> A long time ago.
16:55:52 <dolio> I think it covers stuff not in the dragon book.
16:55:57 <monochrom> I like Modern Compiler Implementation in ML
16:56:13 <dolio> And the ML version might actually have code you might write.
16:56:43 <monochrom> it is a better start than the dragon book
16:56:49 <NihilistDandy> dolio: Yeah, I heard the Java version is basically a tortured translation of the ML version to Java :D
16:56:59 <dolio> Yes.
16:57:07 <dolio> It might have gone through the C version, too.
16:57:13 <dolio> ML written in C written in Java.
16:57:13 <ReinH> and maybe Perl?
16:57:19 <ReinH> just for good measure?
16:57:25 <dolio> Well, there's no perl version of the book.
16:57:35 <dolio> To my knowledge.
16:57:35 <ReinH> it's an IR
16:57:40 <NihilistDandy> monochrom: Cool. That's good to know. Hopefully I can find a decent price on it. I think the lowest I saw was $130, but I'll shop around. It looks like a good book
16:57:52 <ReinH> the perl compiler is an internal representation of the compiler
16:57:59 <monochrom> someone should impersonate Appel and write "Modern Compiler Implementation in PHP"
16:58:05 <ReinH> oh god
16:58:08 <ReinH> that isn't even funny
16:58:40 <edwardk> ReinH: hrmm, this isn't as pretty as i remember
16:59:02 <ReinH> someone by now has created an IO type signature that reads E -> I -> E -> IO () right?
16:59:06 <simon> NihilistDandy, yes, I like Modern Compiler Implementation in ML. I also like the one written by my professor: Basics of Compiler Design. it's supposed to be written language-agnostically, but the pseudo-code resembles ML.
16:59:11 <simon> NihilistDandy, http://www.diku.dk/~torbenm/Basics/index.html
16:59:26 <NihilistDandy> monochrom: The parser just makes hundreds of deep joins against a MySQL table. ಥ_ಥ
16:59:42 <ReinH> E for Either, I for Reader, ofc
16:59:43 <ReinH> right?
16:59:49 <NihilistDandy> simon: Nice! Thanks for the link!
17:00:01 <ReinH> (EitherT and ReaderT)
17:00:47 <ReinH> edwardk: a/b should break (beta <= alpha) xs right?
17:01:24 <edwardk> http://en.wikipedia.org/wiki/Alpha-beta_pruning#Pseudocode yes ;)
17:01:38 <ReinH> edwardk: I mean literally using break from Data.List :p
17:01:55 <NihilistDandy> *database, der
17:01:59 <ReinH> or Prelude, w/e
17:02:29 <edwardk> ReinH: the EIE -> IO () joke has made the rounds, yes ;)
17:02:38 <ReinH> edwardk: good to know
17:03:04 <edwardk> if you make the type for EIE right you can just use 'EIE IO'
17:03:10 <shachaf> edwardk: It has O(√n) complexity!
17:03:10 <ReinH> well yes
17:03:22 <ReinH> shachaf: which?
17:03:29 <shachaf> EIE -> IO ()
17:03:32 <ReinH> ...
17:03:36 <shachaf> https://en.wikipedia.org/wiki/The_Complexity_of_Songs
17:03:37 <ReinH> I thought you were talking about alphabeta
17:03:41 <ReinH> lulz
17:04:00 <ReinH> (which is O(root(d^b)) when optimally sorted)
17:04:15 <ReinH> Knuth... is so... funny.
17:08:47 <rofer> Is there a single function that forces a number within a min and max bound or do I have to use both min and max?
17:09:10 <shachaf> I don't think there's one in the standard library.
17:09:19 <shachaf> You can probably define one yourself, and call it "clamp" or something.
17:10:15 <rofer> Yeah, just felt like something that might already be there
17:11:32 <latro`a> uh
17:11:34 <latro`a> if you have an Ix
17:11:35 <latro`a> inRange
17:11:53 <latro`a> obviously Ix is stronger than Ord
17:11:54 <latro`a> but
17:11:55 <latro`a> yeah
17:12:39 <ReinH> edwardk: so how's it going? :p
17:12:47 <edwardk> distractedly ;)
17:12:51 <ReinH> :D np
17:12:56 <latro`a> (though actually inRange isn't quite the same thing)
17:13:09 <latro`a> in particular the inRange for a tuple isn't <= smaller >= bigger
17:13:13 <edwardk> wife just left the room. going to see if i can write a pretty version using lenses
17:13:24 <ReinH> lmao
17:13:25 <ReinH> yay
17:13:26 <edwardk> something 'obviously correct' as a transcription of the pseudocode
17:13:33 <ReinH> :)
17:14:22 <acowley> Hmph, my generic Traversable peek and poke operations are 5x slower than manual serialization for small structures
17:15:30 <squidz> how would i apply a function to the inner value of this type IO (Either String String) ?
17:15:45 <shachaf> fmap :: (a -> b) -> IO a -> IO b
17:16:20 <squidz> shachaf: so it doesnt matter that an Either is within the IO?
17:16:33 <scshunt> depends
17:16:34 <shachaf> squidz: It does. That's why you use fmap.
17:16:50 <latro`a> Either's Functor instance doesn't let you apply anything to the Left value however
17:16:58 <latro`a> erm
17:17:00 <latro`a> if you have a Left value
17:17:04 <shachaf> What do you mean by "inner value"?
17:17:30 <squidz> shachaf: the non failing string within the either
17:17:49 <latro`a> then you're doing fmap (fmap f)
17:17:58 <shachaf> fmap . fmap :: IO (Either e a) -> IO (Either e b)
17:18:04 <latro`a> erm
17:18:06 <latro`a> no
17:18:20 <latro`a> fmap . fmap :: (a->b) -> IO (Either e a) -> IO (Either e b)
17:18:35 <shachaf> Er, right.
17:19:21 <ReinH> fmap . fmap :: Monad m => (a->b) -> m m a -> m m b
17:19:26 <latro`a> uh
17:19:36 <latro`a> "m m a" is uh
17:19:37 <latro`a> no
17:19:38 <latro`a> lol
17:19:42 <latro`a> major kind error
17:19:49 <ReinH> m (m a) sorry
17:19:54 <latro`a> also no need for a monad and no need for it to be the same monad
17:20:03 <ReinH> right sorry
17:20:05 <latro`a> full type is
17:20:14 <ReinH> Functor and f (f a) -> f (f b)
17:20:33 <latro`a> fmap . fmap :: (Functor f,Functor g) => (a->b) -> f (g a) -> f (g b)
17:20:39 <ReinH> fair enough
17:20:52 <latro`a> rather important that there can be two Functors
17:20:55 <ReinH> totes
17:20:57 <latro`a> given, say, this example
17:21:02 <ReinH> YES THANKS
17:21:38 <ctype_real> language of birds  ? sorry
17:27:07 <mun> is polymorphism a feature of higher-order logic and not of first-order?
17:27:38 <hpc> first-order logic has rank-1 polymorphism
17:27:45 <hpc> see: https://en.wikipedia.org/wiki/First-order_logic#Free_and_bound_variables
17:28:10 <hpc> i am not sure how exists comes into it; someone else will have to answer that
17:28:26 <dolio> No. The polymorphic lambda calculus is typically considered equivalent to 2nd order or higher logic.
17:28:34 <dolio> You quantify over types/sets.
17:28:52 <dolio> And it's all arbitrary rank. Rank has to do with where you can put quantifiers.
17:29:07 <jaredc> question: why is <$> infixl? i wanted to write something with the same structure as read <$> (++) <$> getLine <*> getLine, but i need parens? shouldn't it be like ($) which is infixr? or am i missing something?
17:29:24 <hpc> jaredc: there's debate on the associativity of ($)
17:29:30 <shachaf> jaredc: That's backwards -- $ should be infixl.
17:29:47 <jaredc> mind blown, explain please?
17:29:50 <shachaf> jaredc: But even if you make $ infixr, <$> should still be infixl, because it's function application.
17:30:08 <shachaf> (Except "lifted". But it should still be left-associative just like regular function application.)
17:30:27 <dolio> First-order logic is equivalent to a dependent type system called the logical framework.
17:30:34 <mun> dolio, but how come quantifying over types/sets makes it second-order or higher? isn't what you can quantify over independent of whether you use FOL or HOL?
17:30:46 <latro`a> no
17:30:54 <ion> > let ($) = (Prelude.$); infixl 0 $ in (++) $ "foo" $ "bar"
17:30:56 <lambdabot>   "foobar"
17:31:17 <latro`a> in fact what you can quantify over is basically at the heart of the idea of higher order logic
17:31:26 <shachaf> ion: That's not a particularly good example because you can do that without $
17:31:42 <ion> You can do anything without $
17:31:47 <dolio> mun: First order logic has quantifiers over particulars. Second order has quantifiers over collections of particulars, etc.
17:31:56 <latro`a> > let ($) = (Prelude.$); infixr 0 $ in (++) $ "foo" $ bar
17:31:57 <lambdabot>   Not in scope: `bar'
17:32:00 <latro`a> erm
17:32:02 <latro`a> > let ($) = (Prelude.$); infixr 0 $ in (++) $ "foo" $ "bar"
17:32:03 <lambdabot>   Couldn't match expected type `a -> b'
17:32:03 <lambdabot>         against inferred type `[GHC.T...
17:32:04 <shachaf> ion: The point is that with infixl $, you can do "f x $ g y $ h z" without parentheses.
17:32:07 <latro`a> ahh
17:32:18 <dolio> mun: This can get a little confusing because set theory is first order, but the particulars are sets.
17:32:21 <shachaf> Given that $'s goal is mostly elimination of parentheses, that's important.
17:32:33 <dolio> Or, typically set theories are first order.
17:32:48 <mun> latro`a, dolio but say you want quantify over functions or sets, you could syntactically express the theory in multi-sorted FOL, right?
17:33:26 <mun> ZFC is first-order even when some axioms range over sets
17:33:45 <ctype_real> what mean defaultLayout $ do ? "do" not a function
17:33:52 <dolio> The particulars of the theory in ZFC are sets.
17:33:54 <ddarius> Set theory is an implementation of higher order logic in first order logic.
17:34:09 <latro`a> ctype_real, defaultLayout $ do means you're applying defaultLayout to the entire do block that follows
17:34:29 <dolio> I'm not very well equipped to explain exactly how it's different.
17:34:40 <geekosaur> do ... is an expression
17:35:17 <ctype_real> latro`a: but hen, what meaning of second $ here : defaultLayout $ do 	$(widgetFile "echo")
17:35:35 <latro`a> ...does that even parse?
17:35:44 <geekosaur> $() is a template haskell splice, no?
17:35:47 <ctype_real> defaultLayout(widgetFile "echo") ?
17:35:48 <latro`a> oh
17:35:53 <mun> so FOL or HOL depends on what you're ranging over are individuals alone or sets of individuals or sets of sets.. etc.?
17:36:10 <ctype_real> sample from yasod, it worked and compiled correctly
17:36:15 <mun> this seems to contradict with the comment at http://mathoverflow.net/questions/105234/second-order-term-in-first-order-logic
17:36:24 <latro`a> is there a TemplateHaskell flag anywhere?
17:36:28 <mun> "My point is "what you can quantify over" is independent of whether you use FOL or higher order logic. "
17:36:55 <hpc> latro`a: {-# LANGUAGE TemplateHaskell #-}
17:36:59 <dolio> mun: The basic difference is that first order set theory lets you quantify over sets as objects of the theory. Higher order logic has quantifiers that range over meta-sets, I believe. Which looks different.
17:36:59 <hpc> at the top of a source file
17:37:00 <geekosaur> yesod uses template haskell a lot.  essentially, $(widgetFile "echo") runs widgetFile "echo" and generates code which is spliced into the expression
17:37:06 <ddarius> System F2 corresponds to "second-order propositional logic".
17:37:06 <hpc> or -XTemplateHaskell on the command line
17:37:13 <geekosaur> that's something of an advanced topic
17:37:15 <latro`a> hpc--I was asking mun
17:37:18 <latro`a> erm
17:37:21 <latro`a> was asking ctype_real
17:37:34 <hpc> oh
17:37:39 <dolio> Meta-sets of particulars.
17:37:42 <ctype_real> latro`a:  I am newbie :( I see only {-# LANGUAGE TupleSections, OverloadedStrings #-} at top of file
17:37:42 <ctype_real>  
17:37:50 <geekosaur> latro`a, it's yesod, TH *is* involved somewhere
17:37:53 <ddarius> mun: FOL doesn't care what the individuals are.  This is how set theory works.
17:38:06 <latro`a> then yeah, ctype_real, it's probably TH
17:38:11 <ctype_real> wtf "template haskell" ? it is not real ?
17:38:14 <latro`a> the second one
17:38:23 <latro`a> template haskell is part of GHC
17:38:27 <mun> ddarius, but aren't the individuals in ZFC sets?
17:38:33 <ddarius> mun: Yes.
17:38:47 <mun> ddarius, hmm what did you mean by 'doesn't care'?
17:38:49 <hpc> ctype_real: do you know what language extensions are?
17:38:56 <geekosaur> I described it for you above
17:39:09 <geekosaur> [22 20:36] <geekosaur> yesod uses template haskell a lot.  essentially, $(widgetFile "echo") runs widgetFile "echo" and generates code which is spliced into the expression
17:39:33 <ctype_real> hpc: no. I am started learning haskell last 10 hours and browse over tutorials and docs
17:39:42 <hpc> neat
17:39:53 <geekosaur> it's an extension to haskell, can be very useful, can also be rather difficult to understand (especially since you don't literally splice in code, you splice in a runtime-generated syntax tree)
17:39:54 <ctype_real> i.e. I don't sure is here real haskell or not
17:39:55 <mun> ddarius, dolio so do you agree with the statement: "My point is "what you can quantify over" is independent of whether you use FOL or higher order logic. " (http://mathoverflow.net/questions/105234/second-order-term-in-first-order-logic)?
17:39:58 <hpc> a language extension is like... a browser extension kinda
17:40:07 <ddarius> That they are sets means nothing to FOL.  All FOL cares about is predicates and relations.  So you have your individuals, which for ZFC are sets, and you have your relation ∈ : Set x Set -> 2.
17:40:15 <hpc> you turn on the extension, and your browser behaves differently
17:40:29 <hpc> suddenly you get cool features like monad comprehensions, overloaded strings, etc
17:40:43 <ctype_real> ok. so what this mean under yasod extension ?
17:40:48 <dolio> mun: Depends on what "what you can quantify over" means exactly. If it means you can have a first order theory of whatever type of thing you want, then yes.
17:40:57 <ddarius> mun: Yes.  However, as I said, you do have to "define" what the individuals are.
17:41:08 <ctype_real> i.e. I understand from errors this is "precompilation" code
17:41:13 <hpc> yesod uses the extensions to do a few fancy things; template haskell is a "meta language"
17:41:16 <mun> ddarius, dolio the previous poster's post was "I see. So, to confirm my understanding, in FOL, we can quantify over variables of type, e.g., A→B→... as long as the individuals of the domain are of type A→B→...? If so, is this the reason why ZF is a first-order theory even some axioms quantify over sets, e.g., Axiom of union, i.e. the individuals are sets?"
17:41:19 <hpc> it gets run at compile-time, and the output is code
17:41:31 <hpc> that code is inserted in-place in your .hs file before compilation
17:41:43 <hpc> so it's kind of a macro system, only fancier
17:41:44 <mun> but then that guy seems to disagree
17:43:01 <ctype_real> hpc: hm, thanks, it really cool to have "before compilation" code :) another stupid question, why yesod don't use it everywhere ?
17:43:13 <ddarius> mun: Predicates are not individuals, however, you can have, as an individual, something that is isomorphic to a predicate, which is what typical set theories do, but it is not -actually- a predicate.
17:43:24 <hpc> ctype_real: TH is flawed in a few subtle ways
17:43:37 <hpc> a big one is that it makes the order of definitions significant
17:44:10 <mun> ddarius, right.
17:44:11 <hpc> part of coding in haskell is using the "dirty" stuff when necessary, but protecting the rest of the code from it as best you can
17:45:38 <ctype_real> ok, is it exists "pure" haskell web framework ? ( I am coming from c++/php experience and looking for best web framework for me)
17:47:31 <dolio> mun: I could have a two-sorted first-order theory of naturals and sets of naturals. But, if my meta logic has sets, then there are meta-sets of naturals that aren't necessarily identical to the sets of naturals described by my many-sorted first-order theory (generally, it would look like there are 'more' meta-sets than there are object-sets that can be guaranteed to exist by the first-order theory, probably). A second-order theory would
17:47:31 <dolio>  (I believe) allow quantification over those meta-sets.
17:47:33 <ddarius> mun: I was being a little fuzzy worded though, in set theory, you usually can't represent -all- predicates as sets and, essentially, the ones you can't represent as sets are proper classes, though sets model -a- notion of predicate.
17:47:44 <geekosaur> I think:  happstack, wash, snap
17:48:05 <hpc> ctype_real: a good way to go if you are coming from php is you can do CGI with plain old binaries
17:48:50 <hpc> httpd info and GET comes from getEnvironment, POST comes from stdin, and the html you produce goes to stdout
17:48:50 <armlesshobo> how do i view the possible values for (->)?
17:49:13 <hpc> it will be familiar and there's still quite a lot you can do to learn from
17:49:31 <hpc> one of my favorite functions is
17:49:31 <ion> armlesshobo: There’s just one meaningful value for (->): that is (->).
17:49:35 <dolio> So first-order theories generally have models that don't represent the object-sets by the set of all meta-sets of naturals. While second-order theories are required to represent the sets quantified over that way.
17:49:37 <hpc> wrap before after mid = do
17:49:41 <hpc>   putStrLn before
17:49:42 <hpc>   mid
17:49:46 <hpc>   putStrLn after
17:49:54 <mun> i see
17:49:56 <mun> i think i get it
17:49:56 <ddarius> ZF is very much like implementing a higher order functional language in C by making a data type of "primitive" HOFs and some "combinators" and showing that you can express all HOFs with them, but the HOFs themselves are not C functions.
17:49:59 <ctype_real> can anybody help me with selection of haskell web framework ? with all sugar like a regexp based url to controller mapping, manual sql and ability to run under highload (by example few instances on different hardware servers) ?
17:50:00 <hpc> -- and with that defined you can do
17:50:19 <hpc> html = wrap "<html>" "</html>" -- continue for all the html tags you feel like using
17:50:19 <armlesshobo> ion: hmmm ok.
17:50:24 <hpc> main = html $ do
17:50:27 <hpc>   head $ do
17:50:30 <hpc>     ...
17:50:32 <hpc>   body $ do
17:50:34 <hpc>     ...
17:50:45 <dolio> mun: And a similar thing goes on with set theory. ZF has countable models, and many different models for instance.
17:50:55 <ion> hpc: wrap before after mid = putStrLn before *> mid <* putStrLn after  -- More useful return value
17:51:09 <ion> s/return/result/
17:51:19 <hpc> ah, that's a good one too
17:51:30 <ctype_real> hpc: it does not look like functional programming :)
17:51:57 <hpc> ctype_real: i know; i like how it doesn't look particularly imperative either :D
17:52:01 <mun> dolio, ddarius so does that mean even if the individuals are of type, e.g., 'a, a sentence like f(g) where g::'a=>'b is still a valid sentence? that is because there's no quantification there.
17:52:23 <hpc> you will find that sometimes the best functional code doesn't really look functional from the outside
17:52:36 <hpc> because it does such a good job of abstracting away the rest of it
17:52:54 <ddarius> mun: The individuals have no meaning except in terms of the predicates and function symbols defined upon them.
17:53:34 <ion> ctype_real: You could implement the very same syntax with something else than IO.
17:53:44 <ctype_real> I agree, but my goal to have something non-imperative, for education, for brain, and if it work - for production
17:53:44 <ion> Say, Writer
17:54:50 <ctype_real> ok, with yesod - is it limited version of haskell or extended ?
17:55:12 <ddarius> Yesod is a library.
17:55:16 <mun> ddarius, right. but g is a function symbol. ranging over g requires second-order (right?), but what if there's no quantification?
17:55:51 <ddarius> mun: I can't really parse what your individual would be.
17:55:54 <ctype_real> and, .hamlet files , why its dislike tabs ("/t" ) ?
17:55:56 <luite> ctype_real: not much difference, there are a few places where a quasiquoter is used, a domain specific language that's parsed at compile time and converted to haskell
17:56:10 <ion> > let wrap before after mid = tell before *> mid <* tell after; html = wrap "<html>" "</html>"; foo = wrap "<foo>" "</foo>" in execWriter $ do html $ do foo (tell "bar"); tell baz
17:56:11 <lambdabot>   Not in scope: `baz'
17:56:16 <ion> > let wrap before after mid = tell before *> mid <* tell after; html = wrap "<html>" "</html>"; foo = wrap "<foo>" "</foo>" in execWriter $ do html $ do foo (tell "bar"); tell "baz"
17:56:17 <lambdabot>   "<html><foo>bar</foo>baz</html>"
17:56:25 <geekosaur> \t not /t
17:56:30 <hpc> :t let wrap before after mid = tell before *> mid <* tell after in wrap
17:56:31 <lambdabot> forall w (f :: * -> *) a. (Applicative f, MonadWriter w f) => w -> w -> f a -> f a
17:56:54 <mun> ddarius, right. so what more is needed in order to be able to tell?
17:56:56 <ddarius> mun: But, in FOL, function symbols and predicates only take individuals, so "g" needs to be an individual.
17:57:05 <ion> ctype_real: See? No IO.
17:57:07 <mun> ddarius, right
17:57:18 <ddarius> mun: I meant I couldn't even parse what you were trying to say.
17:57:27 <haqe17> Hi guys. Im trying to do an exercise in the wiki where I have to define log2. This is what I wrote, but Im getting errors. http://pastebin.com/GYF1Ta5T
17:57:29 <mauke> The paste GYF1Ta5T has been copied to http://hpaste.org/73550
17:57:59 <mauke> haqe17: you can't / Ints
17:58:01 <latro`a> you can't use (/) on Int
17:58:15 <ctype_real> luite: most hardest problem of learning haskell - a very "specific" dictionary. I am running to look what a quasiquoter mean :)
17:58:25 <hpc> replace "/" with "`div`" and it should at least typecheck
17:58:32 <hpc> it will probably have rounding errors
17:58:36 <mauke> hpc: you can't floor Ints
17:58:38 <mun> ddarius, but did i miss something in the way i phrase it? i think i said something along the lines of: if the individuals are of type 'a, would f(g) be a FOL sentence given g is of type 'a => 'b? or is that ambiguous? sorry...
17:59:24 <ddarius> mun: Okay, I'm parsing better now.
17:59:40 <luite> ctype_real: in case of yesod it means that you write templates like [hamlet| <div>#{title} |]
17:59:48 <mun> ddarius, sorry with my bad use of terminology
18:00:10 <ddarius> mun: It's not your terminology, it's the syntax.
18:00:20 <ddarius> But I think I know what you are saying now.
18:00:23 <luite> ctype_real: this particular quasiquoter is hamlet, and it parses an html-like syntax (indentation based), with #{} sections replaced by the value of the haskell variable
18:00:32 <mun> ddarius, oh. hmm is it because i had 'a as a type?
18:00:57 <ddarius> mun: The first time I thought you were trying to quote a phrase and it made no sense and was unbalanced.
18:01:08 <mun> ddarius, oh!
18:01:28 <mun> ddarius, s/'a/A/g; s/'b/B/g;
18:02:24 <squidz> i cant seem to chain these two functions. the first one is of type String -> IO (Either String String) and the second one is of type: String -> [Tag String]
18:02:41 <ctype_real> luite: yes, I am seen this :) I am don't knew about its non-default nature :)
18:02:42 <mun> ddarius, ok, then f(g) given g :: A => B whilst individuals are of atomic types, e.g., A, makes f(g) a second order sentence, right?
18:02:50 <ddarius> At any rate, it doesn't really matter.  Function symbols and predicates only take individuals.  In a multi-sorted FOL, you could have a sort that you wanted to correspond to a "function" and pass that around, but you can't pass function symbols themselves to function symbols or predicates since they aren't individuals.
18:02:51 <haqe17> mauke: latro`a hpc thx for the quick replies
18:03:05 <ddarius> mun: Yes, that would require f to be higher order.
18:03:16 <mun> ddarius, great. all clear now. :)
18:03:22 <mun> thanks so much for your patience
18:03:33 <luite> ctype_real: it requires the QuasiQuotes extension to be turned on, other than that you shouldn't notice any difference
18:03:38 <mun> dolio, and yours too.
18:03:46 <dolio> No problem.
18:03:54 <squidz> i think i am supposed to use >>= but i get the error:     Expected type: Either String String -> IO a0
18:03:57 <squidz>       Actual type: Either String String -> [Tag (Either String String)]
18:04:01 <ddarius> If you really wanted to you could do things like: forall x. apply("g", x) = g(x) and so forth to model higher order structure.
18:04:06 <squidz> am i missing something?
18:04:22 <ctype_real> other question - mulithreading - I looked at doc about sparks, is "sparks" "green-threads" or real OS threads (set by RTS -N) ?
18:04:27 <geekosaur> how exactly are you trying to chain them?  what do you expect to get?
18:04:37 <mun> ddarius, that's higher-order abstract syntax, right?
18:04:40 <ddarius> ctype_real: Sparks are not even green threads.
18:04:50 <squidz> i want to get an IO string in the end
18:04:51 <geekosaur> and what do you expect to happen with the Either?
18:05:17 <ctype_real> ddarius: docs not clear about this, so what is sparks when it run ?
18:05:39 <ddarius> mun: No.  It's just saying the apply function symbol, when passed a particular symbol and any other individual is equal to the particular function symbol g applied to that individual.
18:05:55 <squidz> geekosaur: i suppose the either will use the proper string if all goes well and the error message otherwise
18:06:11 <mun> ddarius, oh.. of course.
18:06:29 <ddarius> ctype_real: -When- it is run, it behaves more or less like a thread forked by forkIO which would be more or less "green threads".
18:06:52 <geekosaur> squidz, Either doesnt quite work that way
18:07:03 <ddarius> ctype_real: A spark is just some work that gets put on a queue that some worker threads may or may not dequeue and execute.
18:07:10 <squidz> then how do can I use it
18:07:39 <ddarius> So a spark doesn't even create threads generally, it just gets processed by a thread that probably already exists.
18:08:26 <geekosaur> an Either value is Left something or Right somethingelse.  You need to determine which one you want.  if you truly don't care, maybe 'either id id'
18:08:40 <geekosaur> func1 >>= func2 . either id id
18:09:32 <geekosaur> I would question wky you want to ignore the error though
18:09:36 <squidz> geekosaur: so say I want the right, how would i compose it
18:09:37 <geekosaur> this tends to be a bad idea
18:10:01 <geekosaur> you can;t just ignore the left, you have to decide what to do with it
18:10:02 <squidz> geekosaur: or then how would handle both situations
18:10:11 <squidz> with guards?
18:10:43 <geekosaur> you could use a case, or guards (same thing under the covers), or the either function.
18:11:35 <squidz> geekosaur: i could do this if it was just ehe either value, but im not sure how to go about when it is in the I monad
18:11:41 <ddarius> There is only case.
18:11:50 <ctype_real> thanks, and another question - which one is most feature-rich web framework for haskel, I am looking for websockets, ajax and other sugar ?
18:11:52 <geekosaur> I showed you one way to do it:  func1 >>= func2 . either id id
18:12:12 <geekosaur> in this case the 'either d id' just unwraps it whether it's a Left r a Right; bad idea in general
18:12:12 <squidz> geekosaur: not sure what you mean by the id id
18:12:26 <latro`a> :t either
18:12:27 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:12:32 <geekosaur> either takes a pair of functions.  the first is invoked if you give it a Left; the second with a Right
18:12:33 <latro`a> :t either id
18:12:34 <lambdabot> forall a b. (b -> a) -> Either a b -> a
18:12:36 <latro`a> :t either id id
18:12:37 <lambdabot> forall b. Either b b -> b
18:12:40 <frio> ctype_real: yesod seems to be the top gun these days
18:12:42 <ctype_real> or it stupid to develop web sites with haskell at all ?
18:12:42 <geekosaur> func1 >>= func2 . either (const "") id
18:12:56 <frio> it's nice, but it's got a steep curve (it uses a lot of template haskell and DSLs)
18:12:59 <geekosaur> would turn Left whatever to the empty string, or pass on the string in a Right
18:13:01 <hpc> ctype_real: well, my website is in haskell, so probably ;)
18:13:28 <frio> im currently using scotty (which is a sinatra-esque mini-framework), which is nice, but doesn't bake in websockets et all
18:13:36 <geekosaur> ("const a b" eats b and returns a)
18:13:43 <ctype_real> ok, thanks, so I am still normal :)
18:14:31 <squidz> geekosaur:  I see, but after trying it, it still doesnt work
18:14:41 <geekosaur> so what are you getting now?
18:14:42 <squidz> geekosaur: Actual type: b1 -> [Tag b1]
18:15:44 <squidz> geekosaur: here is my code if that helps http://hpaste.org/73551
18:16:46 <geekosaur> (anyone else want to jump in here?  I need to leave soon...)
18:17:10 <latro`a> squidz: those bottom types are very very very strange
18:17:18 <squidz> sorry, this is the first time im messing messing around with monads/functors and i seem to be stuck
18:17:29 <squidz> latro`a: which types?
18:17:34 <latro`a> the IO () -> a types
18:17:38 <geekosaur> oh, I see, parseTags is not in IO
18:17:47 <ctype_real> frio: as for me scotty over-low level and yesod very high-leveled :(
18:17:47 <geekosaur> but yes, that part also looked weird
18:18:00 <frio> yeah ctype_real
18:18:11 <geekosaur> func2 . either (const "") id `fmap` func1
18:18:13 <ctype_real> but may be I am not so experienced with its
18:18:16 <geekosaur> is more correcrt in that case
18:18:18 <latro`a> squidz: an IO a is a value that does some IO and returns an a
18:18:24 <frio> the tiny little blog engine im making (URL -> markdown document -> pandoc -> HTML) is perfect in scotty
18:18:36 <Cale> squidz: I think you should only need the IO monad for this code, so please have a quick read of this: http://www.haskell.org/haskellwiki/Introduction_to_IO
18:18:38 <frio> but for larger sites, yesod bakes in a lot more (but is a lot more complex)
18:18:39 <ion> @type [either (const "") id, left (const "")]
18:18:40 <lambdabot>     Couldn't match expected type `[Char]'
18:18:40 <lambdabot>            against inferred type `Either [Char] [Char]'
18:18:40 <lambdabot>     In the expression: left (const "")
18:18:40 <latro`a> so your IO () -> a should almost certainly be IO a
18:18:48 <ion> duh
18:19:10 <Cale> squidz: It should give you an okay idea of the basics of how IO actions work, that might save you some confusion
18:19:15 <latro`a> erm
18:19:22 <latro`a> *a value that, when executed, does some IO and returns an a
18:19:54 <ctype_real> frio: thanks, I will try with yesod, at least will have more feeling of language
18:20:02 <frio> maybe ctype_real :p
18:20:41 <frio> it's full of DSLs and template haskell, which might not have as much relevance in wider haskell
18:21:56 <squidz> geekosaur:  with actual type `IO (Either String String)'
18:22:07 * hackagebot iteratee 0.8.4.1 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.4.1 (JohnLato)
18:22:50 <squidz> Cale: thanks. I know my functions at the bottom probably need help but im only focusing on the main function right now, practicing composing
18:23:33 <latro`a> I haven't used TagSoup, but I may be able to help more if you give the types of the functions from TagSoup that you are using
18:23:36 <Cale> squidz: If you're not going to use do-notation, I recommend using a lambda as the right parameter to >>= to begin with
18:23:54 <Cale> squidz: It'll be less confusing because you'll have a name for the result of openURIString
18:24:17 <squidz> Cale: yes, i am purposely avoiding do notation for practice
18:24:43 <squidz> latro`a: http://hackage.haskell.org/packages/archive/tagsoup/0.6/doc/html/Text-HTML-TagSoup-Parser.html#v:parseTags
18:25:48 <Cale> squidz: If you can write the do-notation, you can also write it first, and then translate it away and see what you get
18:25:51 <squidz> Cale: once i crack this problem, I will do it in do notation, which i figure will be easier
18:26:11 <latro`a> ok, so part of the problem is that parseTags does not return an IO value
18:26:18 <squidz> latro`a: yes
18:26:20 <loreints> Hello everybody! I have had quite a bit of trouble trying to figure out how to write a Monad instance for this and I'm still a bit dumbfounded. I'd really appreciate any pointers/hints as to what my noggin is finding so hard to comprehend: http://hpaste.org/73552 (line 17 is where the instance is declared and relevant stuff right above)
18:26:34 <latro`a> this means you should really be using fmap
18:26:36 <latro`a> not >>=
18:26:38 <ddarius> Do-notation doesn't really save much.
18:27:13 <frio> when I was first learning haskell, i avoided do notation, because it looked very imperative
18:27:25 <frio> and I thought that using >>= would make things less so
18:27:32 <latro`a> fmap (parseTags . either id id) (openURIString totalURL)
18:27:44 <frio> but it's not really; it's just a functional chain with named intermediary variables
18:27:45 <latro`a> will at least typecheck (though it will give main the wrong type)
18:27:52 * ddarius considers making a simple particle filter as an exercise.
18:27:53 <latro`a> (main's type is always IO ())
18:27:53 <Cale> loreints: You want  p >>= f  to run the parser p on the initial input, and if it succeeds with value v and depleted input s', to run the parser (f v) on s'
18:27:59 <frio> so: don't be afraid of do notation :)
18:28:09 <ctype_real> hm, I am sorry, but again stupid question :) - where haskell is best fit  ? yes, I understand - math can be "haskelized" very easy but in "real life" ?
18:28:16 <jmcarthur> loreints: think about the type of "Right (f a, s)"
18:28:19 <byorgey> loreints: in  Parse a >>= f = ... , what is the type of a?
18:28:37 <NihilistDandy> ctype_real: What other languages have you used?
18:28:50 <jmcarthur> ctype_real: haskell is a general purpose language
18:29:23 <Cale> loreints: So start with  p >>= f = Parse $ \s -> ...  similar to what you had
18:29:24 <ctype_real> NihilistDandy: I am used c++ near 7 years, then jumped, latest 3 years in highload php
18:29:46 <Cale> p >>= f = Parse $ \s -> case runParse p s of ... -- and then run the parser p on s
18:29:52 <squidz> latro`a: ahh thank you
18:30:11 <Cale> p >>= f = Parse $ \s -> case runParse p s of Right (v,s') -> ... -- if it succeeds...
18:30:13 <ctype_real> i.e. looked at many like a jvm based etc
18:30:21 <NihilistDandy> Well, then whatever you can dream of
18:30:37 <Cale> p >>= f = Parse $ \s -> case runParse p s of Right (v,s') -> runParse (f v) s'; ... -- run the parser (f v) on s'
18:30:50 <Cale> p >>= f = Parse $ \s -> case runParse p s of Right (v,s') -> runParse (f v) s'; Left e -> ... -- if it fails
18:31:25 <Cale> p >>= f = Parse $ \s -> case runParse p s of Right (v,s') -> runParse (f v) s'; Left e -> Left e -- give the same error
18:31:28 <latro`a> though, squidz, I'm fairly sure that Curl doesn't actually use the same type
18:31:31 <latro`a> for the strings
18:31:37 <latro`a> pretty sure one is a String and the other is a ByteString
18:31:40 <squidz> latro`a: no it worked like a charm
18:31:46 <latro`a> ah nvm
18:31:47 <latro`a> my bad
18:31:59 <latro`a> openURI is the one that does String and ByteString
18:32:06 <squidz> curl has the funtion openURLString which returns it as a string
18:32:35 <ctype_real> NihilistDandy: :) right now I am trying to figure out what is functional programming is (yes, long time ago I am learned Prolog and theory of algorithms) , so .... hm ... I am looking for shorter way to develop web sites :)
18:32:39 <squidz> so that was a learning experience, the first time im really programming in haskell, and the first time ive touched functors/monads
18:32:57 <latro`a> bah, openURIWithOpts is ugly
18:33:03 <squidz> thanks again everybody for being so helpful
18:33:09 <loreints> Cale: Thank you so much! I'm going to have to study the heck out of this to make sure I'm getting it :)
18:33:20 <NihilistDandy> ctype_real: Pick up a copy of the Yesod book.
18:33:22 <squidz> i will probably wriet it again in do notaiton to get it down, and continue on my haskell adventures
18:33:24 <latro`a> nested case and so on
18:33:27 <NihilistDandy> Or read the Snap tutorials
18:33:36 <NihilistDandy> They're both powerful frameworks
18:34:03 <ctype_real> NihilistDandy: already reading "real word haskell" , will check snap
18:34:06 <NihilistDandy> Alternatively, you can roll your own, but I don't know if that will help you reach your immediate goal.
18:35:14 <ctype_real> I am not have "hard" immediate goal till not understand what haskell is :)
18:36:17 <NihilistDandy> ctype_real: If you're just doing static sites, hakyll is a good option. (http://jaspervdj.be/hakyll/)
18:37:54 <luite> frio: you can use websockets with scotty
18:38:28 <luite> frio: at least as far as i can tell from the source, you have scotty Options that contains settings for the Warp server
18:38:58 <luite> and for websockets, you tell warp to intercept connection upgrade requests for certain urls and pass them to your websocket hander
18:43:28 <ctype_real> NihilistDandy: thanks, but static sites dead in 90'th
18:44:48 <NihilistDandy> :/
18:45:31 <ctype_real> and, yet another stupid question - is any framework support so named "graceful degradation" ?
18:45:44 <ctype_real> *supports
18:46:32 <ion> I don’t expect any of the frameworks to work against it.
18:46:37 <NihilistDandy> Well, wouldn't that be up to your design?
18:48:03 <ctype_real> I am try to understand level of available features, really most advanced framework for me is http://www.webtoolkit.eu/wt , but it so complex to develop in c++ with reasonable speed
18:48:39 <NihilistDandy> What features, specifically?
18:50:25 <ctype_real>  stateful applications that are at the same time highly interactive (leveraging techinques such as WebSockets and Ajax to their fullest) and accessible (supporting plain HTML browsers), using automatic graceful degradation or progressive enhancement.
18:50:28 <luite> ctype_real: haskell frameworks are mostly server side, they don't offer a lot of abstraction for client side interaction, mostly page based
18:51:16 <ctype_real> luite: thanks, I should ask this question to be sure :)
18:51:26 <luite> yesod has widgets, which describe a part of a page, with dependencies (css, js, images), and they are fine for basic interaction, but if you want to build complex user interfaces with them, you have to write a lot of javascript
18:51:45 <NihilistDandy> I kinda wonder how this automatic degradation works
18:52:22 <luite> ctype_real: yesod (actually wai, its underlying framework, also used by scotty) and snap both support websockets. happstack doesn't, currently
18:52:43 <ctype_real> I am sorry if this look like advert, it not, but wt work well with js based browsers and some like lynx
18:52:59 <ion> This should work in any framework. Just serve static pages when a resource is requested as HTML and something like JavaScript/JSON when that’s requested. Then implement client-side enhancements in JavaScript.
18:53:25 <donri> needs moar fay
18:53:40 <luite> you mean ghcjs
18:53:42 <luite> :p
18:53:43 <NihilistDandy> Their site certainly reads like an advertisement
18:54:12 <donri> luite: :) btw how ready is ghcjs for OS packaging?
18:55:06 <luite> ctype_real: real client side interaction with haskell is not there yet, there are serveral compilers out there that compile to javascript, but it will take a while before proper libraries are really ready
18:56:00 <luite> still if you like experimental software, and haskell, you could already be more productive in fay than javascript for certain things
18:56:18 <luite> donri: not quite...
18:56:26 <donri> aww
18:56:42 <luite> donri: doesn't exactly help that i'm spending my time working on a new code generator instead of making it user friendly :)
18:57:03 <donri> i don't mind :)
18:57:29 <donri> how not ready is not quite ready though, fedora seems to be fine with shipping tech previews
18:57:38 <luite> i hope that fay will lead to some interesting ideas and libs for client side haskell and javascript ffi, and that ghcjs can replace the compiler later
18:57:49 <donri> i was thinking since ghcjs is more work to set up than a cabal install it could be interesting to package for distros
18:58:26 <ctype_real> hm, I am not advertising, really I am just trying to understand level of features already exists in hs to avoid creating own bicycle
18:58:34 <luite> donri: oh no, i think it should be just a cabal install
18:58:46 <donri> luite: should or is?
18:59:32 <amiller> i'm trying to do something where I have a possibly recursive type, and i want to make an instance of it that is recursive
18:59:37 <amiller> i'm not sure that made any sense, let me show my example
18:59:55 <amiller> data Node d = E | T d d
19:00:10 <amiller> newtype Tree = Node Tree
19:00:19 <luite> donri: both actually, i spent a bit of time earlier this year making the standalone compiler support cabal
19:00:24 <amiller> that doesn't work because newtype only permits one constructor
19:00:34 <amiller> it's not clear to me what the alternative is, or if there's a reason i can't do this
19:00:41 <luite> donri: the compiler itself actually works, and you can install ghcjs packages with ghcjs-cabal, ghcjs-pkg etc
19:00:45 <donri> luite: hm i thought you needed to compile ghc and shit
19:00:59 <donri> luite: i'm talking about ghcjs itself
19:01:03 <ddarius> amiller: That should work fine.
19:01:26 <luite> donri: you need some base libraries. the integrated ghcjs completely replaces the current ghc, and it outputs javascript for everythign you build
19:01:35 <luite> donri: so no separate cabal support is required there
19:01:37 <amiller> ddarius, "The constructor of a newtype must have exactly one field"
19:01:47 <amiller> should I just do:   data Tree = Node Tree
19:01:50 <ddarius> amiller: The code that you wrote works.
19:02:00 <luite> donri: the standalone one can be installed with cabal install, you get the ghcjs, ghcjs-cabal, ghcjs-pkg programs
19:02:10 <ddarius> Er, but it doesn't mean what you think.
19:02:12 <loreints> in record syntax, how do I say a list of bytes?
19:02:42 <Cale> loreints: [Word8]? ByteString?
19:02:58 <luite> donri: but in order to build the base libs, you need to get the ghc source and run ghcjs-boot there (actually downloading and unpacking the source should be automated by ghcjs-boot --auto, but i haven't tested that recently)
19:03:12 <loreints> Data.ByteString.Lazy.ByteString?
19:03:19 <donri> sounds interesting
19:03:22 <ctype_real> oh, ghcjs requires jvm
19:03:24 <loreints> is that too crazy?
19:03:30 <ddarius> newtype requires a constructor, so you'd write something like newtype Tree = In (Node Tree) where In would be the constructor that the newtype is declaring.
19:03:40 <luite> ctype_real: only if you want to use the closure compiler to minify the javascript output
19:04:10 <ddarius> data Tree = Node Tree would mean almost exactly the same thing as the newtype you wrote earlier, which is valid, but not what you think it means.
19:04:25 <luite> ctype_real: but it's really not userfriendly atm, better get fay if you want to get something to play with
19:05:00 <donri> luite: so you can't do ghcjs-cabal install base? :)
19:05:02 <luite> ctype_real: f ay is only a subset of haskell, but it's much easier to install
19:05:13 <luite> donri: no since base is not a cabal package
19:05:16 <ctype_real> probably I first will learn haskell before to move into freaks area ? :)
19:05:24 <luite> also base needs ghc-prim and integer-gmp
19:05:33 <donri> but http://hackage.haskell.org/packages/archive/base/4.5.1.0/base.cabal ?
19:05:38 <donri> aha
19:05:46 <luite> it's not really installable through cabal
19:05:49 <Cale> amiller: It's also worth noting that you can write more generally:  newtype Mu f = In (f (Mu f))
19:05:55 <arbn> So, I'm working with hlibgit2. What is the best way to get a Ptr for a revwalk? Do I have to use the GHC primitives?
19:06:01 <Cale> amiller: and then Mu Node will be your tree
19:06:12 <amiller> that's very interesting, thank you
19:10:15 <luite> donri: cabal install base --reinstall
19:10:37 <ion> That sounds like a scary command.
19:10:58 <donri> :D
19:11:01 <luite> it just refuses to do it :)
19:11:35 <donri> argh lots of deps not on hackage for ghcjs
19:11:54 <luite> two i guess? source-map and ghcjs-closure ?
19:12:08 * hackagebot concrete-relaxng-parser 0.1.1 - A parser driven by a standard RELAX NG schema with concrete syntax extensions.  http://hackage.haskell.org/package/concrete-relaxng-parser-0.1.1 (MarioBlazevic)
19:13:57 <mk> what are some other terms for "monadic value"?
19:14:09 <mauke> mote
19:15:00 <donri> mk: action
19:15:06 <donri> computation
19:15:17 <ion> container, like IO
19:15:42 <mk> mauke: how standard is that?
19:15:51 <ion> mauke: mote, huh?
19:16:12 <mauke> mk: 0%
19:17:17 <mk> donri: I don't understand how people think of monadic values as computations. Monadic functions are computations, but the values produced by them... aren't - are they?
19:17:39 <mauke> mk: if getLine isn't a computation, what do you call it?
19:18:42 <mk> mauke: isn't that a function?
19:18:47 <ion> no
19:18:54 <ion> Function is anything with -> in its type.
19:18:58 <mauke> mk: look at its type
19:19:51 <mk> I am. But when I scroll up a bit, the title says "input functions"
19:19:57 <pqmodn> i liked conor mcbride's description, something like values of type "m a" are a strategy to produce a value of type "a"
19:19:59 <mk> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:getLine
19:20:20 <mauke> mk: irrelevant
19:20:42 <mk> mauke: is getLine equal to getLine?
19:20:58 <mauke> what do you mean?
19:21:56 <mk> well, presumably getLine is a value, like True, or 5. But getLine is probably different at different times, no?
19:22:07 <latro`a> it is not, no
19:22:24 <latro`a> the string you get varies, but the procedure is the same
19:22:25 <mauke> mk: no
19:22:41 <latro`a> but that variation is in the semantics of bindIO, not the semantics of getLine
19:22:52 <ion> mk: When you look at /bin/ls twice, it’s the same file both times.
19:23:05 <ddarius> ion: Not necessarily...
19:23:22 <pqmodn> ion: mv /bin/rm /bin/ls
19:23:24 <latro`a> his point was that a description of a procedure and the output of a procedure are distinct
19:23:28 <ion> ddarius: Yeah, just like getLine may be implemented in a different way when you upgrade your system.
19:24:01 <latro`a> getLine, under some modest assumptions, is always the same object
19:24:14 <latro`a> the string you get to work with by using it isn't
19:25:56 <donri> luite: so ghcjs-boot needs to compile ghc?
19:26:21 <mk> what value is given to return so as to construct the mote/monadic value "getLine"?
19:26:29 <luite> donri: yeah at least part of it, so it still takes a lot of time
19:26:34 <donri> :(
19:26:56 <donri> so again, maybe it would make sense to package it for fedora?
19:26:58 <luite> donri: but at least you don't replace your real ghc anymore, so you can just delete the ghcjs executable and ~/.ghcjs to get rid of ghcjs completely
19:27:07 <ion> mk: What value is given to return :: a -> Maybe a to construct Nothing?
19:27:17 <mauke> mk: 'return' is not involved
19:27:29 <luite> donri: i think it only makes sense to package it if it's at least somewhat ready for end users
19:27:37 <mk> mauke: what monadic function was involved, then?
19:27:48 <donri> luite: aye
19:28:07 <mauke> mk: none
19:28:17 <mauke> what does "monadic function" even mean?
19:28:26 <mk> mauke: takes value, spits out mote
19:28:40 <mauke> ok, none then
19:28:43 <luite> donri: my first priority is seeing if i can get javascriot code out of it that's fast enough for my application (the current trampoline generator is far too slow)
19:29:12 <mauke> well, you could see it as getLine = hGetLine stdin
19:29:17 <mauke> but I don't think that helps much
19:29:32 <luite> donri: while not cheating, like fay
19:29:38 <donri> :)
19:29:46 <luite> grr, spy
19:29:53 <donri> mwahah
19:29:57 <ddarius> luite: How does fay cheat?
19:30:04 <mk> if I bind getLine with a function, what kind of value will be passed to that function?
19:30:19 <ion> luite: Is there code generated by ghcjs on some website? I’d like to look at its output the easy way.
19:30:30 <mauke> mk: a String (maybe)
19:30:47 <ion> @type (>>=) `asAppliedTo` getLine
19:30:48 <lambdabot> forall b. IO String -> (String -> IO b) -> IO b
19:31:01 <mk> ok. Does the same mote pass different strings on different occasions?
19:31:12 <pqmodn> @type asAppliedTo
19:31:13 <lambdabot> forall t b. (t -> b) -> t -> t -> b
19:31:14 <mauke> mk: the mote isn't doing anything
19:31:15 <mauke> mk: >>= is
19:31:24 <mauke> wait, that's not true either
19:31:24 <monochrom> sorry, what is mote?
19:31:30 <luite> ddarius: it only optimizes tail calls in some specific situations, many programs that would run fine in haskell (even with constant stack space) can blow the javascript stack with fay
19:31:33 <mauke> the runtime is doing it
19:31:36 <pqmodn> monochrom: an "m a" value
19:31:43 <monochrom> nice thanks
19:31:48 <ddarius> luite: Okay, that's what I figured.
19:31:54 <mk> mauke: add the appropriate correctins :) - what's the answer, though?
19:32:14 <mauke> mk: to what question?
19:32:24 <ddarius> luite: How are you planning on getting around this faster than trampolining?  (Not that it's hard to be faster than trampolining.)
19:32:39 <monochrom> if you bind getLine with a function? like "getLine >>= f"? a string kind of value will be passed to f
19:33:13 <monochrom> as to what will be in that string, I can't tell you upfront. run the program, let the user do something, then we will know
19:33:14 <ion> mk: “getLine >>= f” returns a new IO action (a mote) that potentially does something more than just a getLine. If you bind that value to “main”, the runtime will execute it. Upon the execution of getLine, different strings may be applied to “f”.
19:33:29 <luite> ddarius: actually i haven't found a good way that's actually faster than trampolining and still not impossible to implement
19:33:59 <mk> when the runtime does what have you with bind, which takes a mote m and f, and a string (maybe) is passed into f, is that string the same?
19:34:07 <ion> Err. “f” may be applied to different strings (upon separate invocations)
19:34:26 <luite> ddarius: but what can be done is avoiding javascript closures and vararg calls by passing arguments in global vars
19:34:31 <mauke> mk: when you do 2 + 3, is that 2 the same?
19:34:49 <ddarius> luite: Oy.
19:34:49 <monochrom> your wording "is that string the same" is wrong. but I can try to guess what you mean
19:34:55 <ReinH> edwardk: so how are alpha-beta-ey thiings going?
19:35:00 <mk> mauke: yes, assuming you're asking "when you repeatedly do it"
19:35:05 <mauke> mk: I'm not
19:35:07 <edwardk> working on something else at the moment
19:35:18 <edwardk> realized an improvement i could make to machines
19:35:23 <mk> mauke: is it selfsame? yes
19:35:32 <monochrom> running "getLine >>= f" at different times may lead to different strings given to f. because the user can enter different strings at different times
19:35:35 <ion> Open sesame
19:35:45 <edwardk> haven't forgotten, but you got pushed down the stack ;)
19:35:56 <luite> ddarius: i've run some benchmarks and the results were hopeful, but i still have no idea how a real haskell program performs with this
19:35:58 <ReinH> edwardk: haha ofc
19:36:31 <ReinH> as long as you pop me at some point
19:36:34 <ReinH> ... that was awkward
19:36:49 <ion> mk: main = forever (getLine >>= putStrLn)
19:37:20 <luite> ddarius: huge disadvantage is that everything needs ot be mananage manually now, so heap objects need to be collected/moved manually, that might easily negate any performance benefits
19:37:22 <loreints> is there an easy way to get a list of modules that contain a function of a given name at ghci?
19:37:33 <ion> mk: The runtime will input a line from you and pass whatever you wrote to putStrLn an infinite number of times.
19:37:35 <ddarius> luite: Yeah, that would be too extreme.
19:38:11 <mk> what is used in bind to extract the string from the mote?
19:38:14 <monochrom> your next question is "does this break purity, it's a different string at different time". my next answer is "no, it preserves purity, it's the same action every time"
19:38:32 <luite> ddarius: i'm not sure yet, but i'm going to try to get it to the point that i can run singlethreaded benchmarks with it
19:38:35 <mauke> mk: no
19:38:42 <ddarius> luite: Probably your best bet is to look into the kinds of techniques used for "local CPS".  Alternatively, possibly explicitly reifying the stack might work well.
19:38:54 <luite> ddarius: i already have explicit stacks
19:38:54 <mk> mauke: to which question?
19:38:56 <monochrom> bind does not extract. the runtime system sees ">>= f" and calls f
19:38:57 <mauke> mk: the mote doesn't contain a string and >>= doesn't extract it
19:39:35 <mk> mauke: how does the runtime end up holding a string in its hands, which it then feeds into f?
19:39:53 <mauke> mk: on unix systems? by calling read(2)
19:40:07 <monochrom> the runtime system is imperative, impure, etc etc
19:40:19 <monochrom> it can reboot your computer if it feels like
19:40:32 <luite> ddarius: function calls still seem to have a relatively large overhead, one thing i was thinking of is inlining a lot of things and make local jumps with a switch/while combination
19:40:56 <ddarius> luite: Yeah, I was just thinking about what would be nicer to the JITs that modern JS implementations use.
19:40:57 <luite> ddarius: the explicit stack and global arg argument passing makes this really simple
19:41:03 <ddarius> Of course.
19:41:04 <monochrom> it can also call C procedures if you want it too
19:42:08 <luite> ddarius: this is about how the code looks: http://hpaste.org/73503
19:42:10 <ion> In VaporHC, getLine contains a short piece of Perl code in a string, and (>>=) in “getLine >>= f” extracts the Perl scripts and returns an IO action that contains a combined, longer Perl script. The runtime system then feeds the Perl script contained by “main” to the Perl interpreter. :-P
19:42:29 <loreints> this is my error atm and I'm pretty sure prelude should include putStrLine, right?: http://hpaste.org/new
19:42:42 <monochrom> ion: is that real?!
19:42:44 <luite> ddarius: (before  the dataflow passes that should eliminate unused variables and a few more things, i'm still writing those)
19:42:45 <mk> obviously read(2) is an impure function call - why this way, instead of passing around fake state?
19:42:50 <mauke> loreints: no and no
19:42:56 <monochrom> no one passes fake state
19:43:06 <arbn> Is there any good tutorial or documentation on using a low-level FFI binding? Having trouble with all the Ptr types.
19:43:20 <mauke> mk: you can't pass the universe around
19:43:20 <mk> monochrom: sure, remove everything after comma
19:43:34 <ion> arbn: I love bindings-DSL. Perhaps some of its examples are helpful.
19:43:43 <monochrom> as for why "this way" --- I assume you mean why haskell separates IO from non-IO --- I like it, it's a healthy separation
19:43:49 <mk> what mote does bind-readLine return?
19:43:52 <arbn> ion: I'll have a look. Thanks.
19:43:57 <ddarius> luite: So why are you making the heap explicit again?
19:44:12 <ion> What’s bind-readLine?
19:44:12 <loreints> mauke: um... what am I screwing up? none of the tutorials are importing anything special it seems, or I'm missing something
19:44:17 <mk> monochrom: no, I mean why it's chosen this way to do it
19:44:24 <mauke> loreints: first off, that's the wrong url
19:44:25 <monochrom> put some restrictions on Int->Int. a function of that type won't "buy icecream" behind my back. I want that restriction. it preserves my sanity
19:44:39 <monochrom> ok, what is "this way"?
19:44:43 <mauke> loreints: second, you probably misspelled putStrLn but it's hard to tell without seeing the code
19:44:49 <luite> ddarius: returning new closures seems really slow in firefox at least, in particular nested ones
19:45:02 <mk> ion: err, what mote does the IO bind return?
19:45:20 <ddarius> luite: Just closures or objects in general?
19:45:29 <ion> mk: Do you mean when applied to two parameters?
19:45:36 <mk> ion: sure
19:45:40 <ddarius> Also couldn't you shove objects on the stack?
19:45:47 <ion> @type (>>=)
19:45:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:45:52 <loreints> mauke: I am a fool: http://hpaste.org/73553
19:45:58 <ddarius> (If it is the return itself that is slow, not the making of the object.)
19:46:00 <luite> ddarius: perhaps objects in general. with this explicit heap/stack, haskell can run without javascript allocation whatsoever until garbage collection is needed
19:46:02 <mauke> loreints: looks like I was right then
19:46:14 <loreints> haha yep
19:46:16 <ion> If the type of the second parameter is “a -> m b”, the expression will return a “m b”.
19:46:19 <loreints> mauke: thank you!
19:46:31 <ddarius> luite: I can't imagine that this plays to the strengths of the implementations.
19:46:59 <mk> ion: and that mote does contain a string?
19:47:09 <monochrom> no
19:47:10 <mk> (if we passed it to e.g. trim)
19:47:16 <ion> IO actions don’t contain a string.
19:47:31 <monochrom> that mote contains an action. is that action, too.
19:47:50 <haqe17> can anyone tell me what is wrong with this element-wise negation function:   let {OneA :: [Int] -> [Int] ; OneA = map negate ; }
19:47:51 <ddarius> And I have a hard time imagining that implementing allocation and garbage collection in Javascript is faster, overall, than the allocation and garbage collection already built in.
19:47:59 <ion> The “m b” contains a recipe the runtime system can use to generate a “b”.
19:48:00 <mauke> haqe17: O
19:48:03 <pqmodn> mk, consider "getLine >>= \x -> return ()" -- the result is IO (), which is an action that when "interpreted" produces ()
19:48:31 <monochrom> I will only leave it at: "getLine >>= putStrLn" is an action that read a line and writes that line. it doesn't have to be any simpler or any more complicated than exactly that
19:48:58 <mk> this lack of containment is only possible due to lazyness?
19:49:04 <haqe17> mauke: oh, stupid mistake. sorry
19:49:08 <ion> It has nothing to do with laziness.
19:49:15 <pqmodn> it doesn't contain a value because it's "a recipe to produce a value"
19:49:24 <monochrom> I won't play along with "what is" questions. askers of "what is" questions never make clear what they want
19:49:33 <mauke> mk: /bin/ls doesn't contain a list of files
19:49:39 <mk> pqmodn: that seems equivalent to "lazy"
19:49:42 <ddarius> luite: Possibly compiling to (super)combinators would be worth trying, though that doesn't solve the tail call aspect.
19:50:12 <ion> mk: And “ls | sort” doesn’t contain a list of files either.
19:50:38 <luite> ddarius: yeah i'm also not certain about that part, but these guys have a malloc iplmentation in a javascript array, and it's not slower than new: http://lljs.org/
19:50:55 <mauke> you could call a muffin recipe a "lazy muffin" but you'd be wrong
19:51:31 <monochrom> an I/O action (or procedure, or script, or recipe, whatever) doesn't contain data. /bin/ls does not contain a list of names; it contains a bloody recipe. read(2) does not contain an array of chars; it contains a bloody piece of kernel code to be run. this phenomenon is not confined to haskell
19:51:49 <ddarius> luite: I can conceive of it allocating faster, the allocator may not be tuned for latency, but once you have GC + allocation, the slow allocator may turn out to lead to faster GC.
19:52:14 <ddarius> Or possibly JS implementations just have horrible allocators (though you'd think you'd get that low hanging fruit before building a JIT compiler.)
19:52:30 <monochrom> your web browser does not contain gmail data
19:52:35 <mk> mauke: yeah, but when anyone thinks of /bin/ls they think of a function, which isn't correct. I think I roughly have the hang of motes not containing values, but it's surprising that "derived" motes (ie, ones that I might get from binding trim, or substring, or whatever) aren't containers - ok, they must be lazy (I think), because they must effectively cache all the functions, and do a lazy call to the runtime's readline whenever you need to use the "recipe"
19:52:43 <ddarius> monochrom: Is it important that the code be bloody?
19:53:10 <mauke> mk: no
19:53:12 <frio> ddarius: there's a reiserfs joke in there somewhere
19:53:12 <pqmodn> mk: motes don't contain values, not derived motes or otherwise
19:53:14 <monochrom> I think yes, some programmers are keen on sacrificing blood to debug code :)
19:53:29 <mk> pqmodn: I'm aware - so they must be lazy
19:53:36 <mauke> mk: no
19:53:43 <pqmodn> mk: no. you could have monads in a strict language
19:53:48 <ddarius> Having an abstract conversation about this wastes everyones time.
19:53:53 <mauke> mk: I don't know what you mean by "cache all the functions"
19:54:08 <mauke> functions are values
19:54:11 <monochrom> replace "derived" by "compound"
19:54:12 <mauke> you can store them directly
19:54:41 <mk> mauke: ok, then how does the mote that I generated using, say, getLine and then bound trim and then bound substring - how does it know to push the value it gets out of the runtime through trim and substring if it's not holding on to them, lazily?
19:54:43 <monochrom> if primitive actions don't contain future data, why should a compound action do?
19:54:58 <mauke> mk: it's holding on to them strictly
19:55:11 <mk> mauke: is "strictly" a special term?
19:55:21 <mauke> mk: well, non-lazily
19:55:33 <monochrom> if a single-line shell script "/bin/ls" doesn't contain a list of files, why should two lines "/bin/ls; rm -rf *" contain a list of files?
19:55:35 <mk> mauke: what's the difference?
19:55:50 <mauke> mk: I don't know, you keep talking about how this is all about laziness
19:56:07 <monochrom> >>= just helps you sequential-compose actions. you just get more actions. not sudden emergence of containers
19:56:22 <mk> monochrom: I'm not saying they contain a list of files, and we should be talking about pipes with that analogy
19:56:48 <monochrom> sure. so none of your previous questions make sense.
19:57:28 <mk> mauke: if we wanted to lazily evaluate -> "foo " trim reverse (producing "oof"), we'd hold on to the original value, as well as trim and reverse
19:57:43 <ion> data IO a where GetLine :: IO String; PutStrLn :: String -> IO (); Bind :: IO b -> (b -> IO a) -> IO a
19:57:53 <ion> GetLine `Bind` PutStrLn :: IO ()
19:57:56 <mauke> mk: irrelevant
19:58:16 <ion> That contains a data structure a runtime system can interpret to read a line and write it back.
19:58:35 <ion> s/contains/is/
19:58:40 <ddarius> ion: Using (Haskell) code to explain would require mk to be able to read Haskell code.
19:58:54 <mk> ion: sure, and that data structure presumably contains a reference to the runtime's read and write
19:59:03 <mauke> mk: no, it doesn't
19:59:03 <pqmodn> mk no it does not
19:59:06 <mauke> mk: where do you see that?
19:59:13 <luite> ddarius: i think it wouldn't be that much work to replace the large heap with a small array or object for every heap object, the same calling convention would still work. it's just a few places in the code that need to be changed for that
19:59:52 <mk> ddarius: passive aggressive much? Refrain from sniping me every time I ask a question, you make conversations hostile when they aren't
19:59:56 <ddarius> luite: Yeah, that would seem (to me, with no evidence) to look more sane to the imlementation.
20:00:00 <luite> ddarius: but i did some tests, like returning a two-element array vs setting two global vars
20:00:09 <luite> and overhead of the array return was quite considerable
20:00:31 <ddarius> luite: But what if you just have one variable that you set to the two-element array.
20:00:32 <NihilistDandy> http://c2.com/cgi/wiki?HostileStudent
20:00:40 <mk> suppose that I create a mote by binding getLine to trim, and the resulting mote to reverse. Now I have a mote, right?
20:00:52 <ddarius> mk: Am I making a non-factual statement?
20:00:54 <monochrom> type error
20:01:14 <mauke> mk: ok
20:01:16 <luite> ddarius: and then modify the elements? or set it to a new array every time?
20:01:29 * mauke is assuming liftM
20:01:34 <ddarius> luite: Set it to a new array each time would be the natural test.
20:01:49 <luite> right, haven't done that :)
20:02:09 <ddarius> luite: But this is just for testing.  In general, you would need multiple slots, hence using the stack.  Admittedly, the stack is not much different than the heap array.
20:02:37 <luite> the stack i use now is almost the same as what the native ghc uses its stack for
20:02:59 <mk> ddarius: if you were a jerk, you'd be a jerk. That's factual, but that's not something one says, right? (Not to imply that you're a jerk, or anything.)
20:03:33 <mk> anyway, this mote can presumably be used to write to the screen
20:03:41 <ddarius> mk: Okay.  Now, you have nothing to be upset about unless you read my statement as implying you don't know how to read Haskell.  Let's say that that was the case.  Now, do you know how to read Haskell?
20:04:25 <mk> ddarius: well enough for the conversation at hand, so you can sod right off
20:05:52 <mk> when the mote gets used to write to the screen, trim and reverse need to be invoked, and so does the runtime's read, right?
20:06:06 <monochrom> moo = getLine >>= \s -> putStrLn "hello" >>= \_ -> putStrLn s
20:06:08 <mauke> mk: depends on what you're talking about
20:06:17 <mauke> more code, less english
20:06:23 <ddarius> mk: Can you demonstrate that fact by correctly placing brackets in the IO type ion provided, and by saying what the type of (Bind GetLine) would be?
20:06:53 <monochrom> I wouldn't call moo "lazy". the sequence of events you will see is: wait for you to enter a line, then displays "hello", then displays what you enter
20:07:17 <monochrom> not: displays "hello", then oh! need s, now wait for you to enter a line
20:07:47 <monochrom> the latter hypothetical magicland would be rightfully called "lazy"
20:08:08 <monochrom> moo is defined with 3 >>='s and there is no laziness about it
20:08:34 <mk> ddarius: you mean  IO b -> ((b -> IO a) -> IO a)?
20:08:56 <luite> ddarius: do you have a source for this local cps optimization?
20:09:17 <pqmodn> mk, (String -> IO b) -> IO b
20:09:22 <NihilistDandy> ^
20:10:58 <pqmodn> mk, it might be instructive to build something similar to ion's IO adt in your language of choice, then build an interpreter for the adt in that language
20:11:31 <ddarius> luite: Not really handy, and not a good comprehensive one.  Try google.  Also, this is very speculative, so I wouldn't waste too much time on it unless it leaps out that it would help.  Specifically, what I'm suggesting is that trampolining isn't too horrible, but doing it everywhere is.  I'm guessing that you may be able to use the same techniques in local CPS work to make "local trampolining".
20:11:50 <pqmodn> something with first class functions would be a good choice, and choose a strict language just to see if it actually works
20:12:29 <mk> monochrom: no, that's still lazy. The "getLine" itself is being cached, lazily, right?
20:12:50 <mauke> mk: getLine is a constant
20:12:54 <mauke> there's nothing to "cache"
20:13:20 <monochrom> I don't know what you mean.
20:13:26 <ion> Also, nothing where lazy evaluation would be relevant.
20:13:55 <monochrom> with probability 0.6, "yes"
20:14:30 <monochrom> the probability is due to uncertainty in what you mean. upload your brain for a free comprehensive analysis!
20:15:04 <ddarius> mk: The type I was referring to was ion's IO type.  I don't even know where you think ion provided that type.  The closest is he asked lambdabot to provide the type of (>>=), but that's not what you wrote anyway (it's more general.)
20:15:34 <ddarius> luite: I believe there are papers on local trampolining too.
20:15:37 <mk> the mote has a structure. It's fine if every mote keeps a const reference to the runtime's getline
20:15:48 <pqmodn> mk, but why would it?
20:15:57 <pqmodn> mk, the mote doesn't need to know anything about the runtime
20:16:10 <pqmodn> mk, the runtime does the interpretation. the mote does nothing
20:16:32 <frio> OK, just so I can follow along in my own bumbling way (and it's proving hard to Google): what is a mote?
20:16:45 <latro`a> apparently a monadic value can also be called a mote
20:16:46 <pqmodn> frio, a value of type Monad m => m a
20:16:53 <edwardk> latro`a: ?
20:17:02 <mk> ddarius: I've told you before, I'm not interested in both a) trying to hold a difficult conversation where I'm trying to learn something and b) politely fending off your provocations. So stop, ok?
20:17:04 <frio> excellent, thankyou pqmodn
20:17:08 <latro`a> (I'm just following the discussion, edwardk)
20:17:10 <pqmodn> i think mark jason dominus came up with this term
20:17:12 <latro`a> (I have never heard this term used)
20:17:20 <monochrom> there are many ways to implement Haskell. you said one way. it works. there are other ways, they also work.
20:17:21 <luite> ddarius: right, i'll google a bit. problem is that with a lazy language, you often have to jump back and forth when you need to force some argument, so i have a feeling that it might not be as effective
20:17:51 <mk> latro`a: mauke brought it up at the start of the convo, I think it's from a ml
20:18:54 <mk> pqmodn: that's fine - forget the status of the runtime's read, whether it's cached or not
20:19:16 <ddarius> mk: I'm not interested either.  Other than in response to you directing me, my comments were not meant for you and I do not care if they make you happy or mad.  I'm more interested in making the other people involved aware of the context and taking perspective of the situation.
20:19:59 <ion> mk: Type “<io><bind><getLine/><putStrLn/></bind></io>” into main.xml and write a runtime system in any language of your choice that reads main.xml and does something useful based on it. In an implementation of Haskell, an IO action could contain a tree akin to what your XML document contains, and the runtime system could do things based on that tree.
20:20:24 <ddarius> latro`a: Someone suggested "mote" in some blog post for what people usually call "monad action/value/computation".  It didn't catch on.
20:21:44 <mk> ddarius: again, STOP. Your input is neither solicited nor necessary.
20:22:07 <mauke> heh
20:22:24 <ddarius> mk: Feel free to use your client's ignore function.  As I said, my comments aren't meant for you.
20:22:24 <mauke> mk: no, YOU stop!
20:22:37 <mk> mauke: no U ;)
20:22:49 <monochrom> I stop
20:22:58 <pqmodn> yeah :[
20:23:00 * ddarius applauds monochrom's sensibility.
20:23:14 <monochrom> I want to watch a movie anyway
20:23:26 <ddarius> monochrom: Me too, but I keep getting distracted by signal processing.
20:24:06 <ion> Or on this channel, noise processing
20:24:23 <monochrom> my advice: don't get distracted by signal processing. I got distracted by signal processing. it delayed my thesis work by 1 month
20:24:47 <monochrom> on the bright side, for signal processing, I learned to use the "vector" package!
20:24:49 <mauke> hah, and some people want to increase the S/N ratio
20:25:23 <shachaf> monochrom: How long has you thesis work taken so far?
20:25:30 <monochrom> don't ask
20:25:49 <mk> if the mote doesn't store the values, and it doesn't store the prior functions for lazy evaluation, then how does it know what to invoke? It wouldn't. So it either stores the value (it doesn't), or it stores the functions for lazy evaluation. What am I missing?
20:25:50 <ddarius> monochrom: Yeah, I'm using pipes-core, hmatrix, vector, and a few others.  I may release something to make these more suitable for signal processing work.
20:26:18 <monochrom> on the bright side, I decide to put a shameless plug in my thesis. I'm citing my own http://www.vex.net/~trebla/haskell/lazy.xhtml
20:26:21 <mauke> mk: you don't know what "lazy evaluation" means
20:26:56 <monochrom> of course, I clearly note "this is unrefereed and unofficial, it's just a tutorial"
20:27:10 <mk> mauke: s/for lazy evaluation//, or let me know what you take it to mean
20:27:21 <mauke> mk: it does store the functions
20:27:29 <mauke> problem solved
20:28:21 <mk> ok. And it uses those functions only when it needs to? And never invokes them, if it turns out not to need to do so?
20:28:36 <mauke> mk: how could you tell the difference?
20:29:49 <frio> mk: google "thunk"
20:29:51 <mk> mauke: by creating a mote, but never executing its action
20:29:57 <mauke> mk: huh?
20:29:57 <NihilistDandy> Actually, relevantly… mk, read this: http://www.vex.net/~trebla/haskell/lazy.xhtml
20:30:01 <mauke> frio: what
20:30:12 <frio> http://en.wikipedia.org/wiki/Lazy_evaluation in fact
20:30:17 <frio> and thunks, inside that article
20:30:29 <shachaf> I don't think anything here has to do with lazy evaluation.
20:30:32 <monochrom> I hate talking about thunks
20:31:01 <shachaf> I'm not quite sure what the conversation is about but I'm pretty sure the thing you're talking about would work in a strict language just fine.
20:31:03 <mk> frio, NihilistDandy: thanks
20:31:11 <shachaf> monochrom: How about graph reduction? Do you like talking about graph reduction?
20:31:23 <monochrom> yes
20:32:04 <shachaf> monochrom likes to talk about graph reduction. Who'da thunk it.
20:32:09 <frio> I'm not sure what it's about either, but being far, far from competent at Haskell, I recall learning about the concept of thunks as being reasonably useful
20:32:13 <monochrom> haha
20:32:41 <monochrom> yes, but it's equally useful without saying "thunk"
20:32:42 <NihilistDandy> Their seemed to be some Sicilian syndrome with regard to "laziness" earlier.
20:33:06 <shachaf> monochrom: Right. It's a much simpler concept.
20:33:28 <pqmodn> haha
20:33:44 <Saizan> NihilistDandy: Sicilian Syndrome?
20:33:51 <NihilistDandy> "You keep using that word. I do not think it means what you think it means."
20:33:54 <monochrom> a thunk is an internal representation of an expression. ok, so why not talk about expressions directly
20:33:58 <NihilistDandy> Saizan ^
20:34:04 <NihilistDandy> *^^
20:34:07 <Saizan> ah, didn't know it went by that name
20:34:40 <monochrom> ok, "but there is sharing and it is important to get right", so use expression graphs, which is what I exactly do
20:34:55 <frio> monochrom: because before you can be confident doing that, you need the mental abstractions to do so
20:35:13 <frio> and when they're not there, and you've come from an imperative background, haskell is extremely confusing
20:35:29 <Saizan> you don't use expressions in imperative langs?
20:35:33 <Cale> I agree with monochrom
20:35:50 <monochrom> work directly with expressions. it is here and now. you already learned it
20:36:15 <Cale> Expressions/expression graphs are much more the right thing to be thinking about than the details of thunks.
20:36:19 <monochrom> thunk : expression :: electrical signal : integer
20:36:47 <Cale> :: closure : function
20:37:01 <monochrom> thunk just brings you closer to hardware. otherwise it is still expression
20:37:25 <monochrom> if you want to count constant factors, "why is it 10 bytes rather than 1 byte", sure, go thunk
20:37:29 <Saizan> btw, you can do expressions graphs just by using let .. in ..
20:37:37 <frio> shrug
20:37:45 <frio> I'm not claiming to be right, or that I learnt things the right way
20:37:53 <monochrom> but if it's just O(n) vs (1), why bother
20:38:13 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html -- this is the sort of picture to have in your head :)
20:38:36 <Cale> (or maybe not exactly like that, but something like that will suffice :)
20:38:46 <monochrom> thunk : expression :: electrical signal : integer  is a powerful analogy to keep in mind. when you teach integers to 10-year-old's, do you tell them about electrical signals first?
20:38:59 <mauke> Cale: I disagree with your "closure", btw
20:39:00 <shachaf> monochrom: You might teach them about fingers first.
20:39:16 <mk> how can an io mote, which is the result of binding through trim and reverse, and which stores trim and reverse and only calls them when needed... not be lazy?
20:39:18 <shachaf> (Well, maybe not 10-year-olds.)
20:39:26 <mauke> mk: by not being lazy
20:39:59 <monochrom> finger is also good. note how finger is even further away from internal representations of integers
20:40:32 <mauke> http://hpaste.org/73555 - here's a sort of minimal IO monad written in a strict language
20:40:35 <mauke> no laziness
20:40:37 <shachaf> Lazy lazy lazy lazy lazy lazy Jane. She wants a drink of water so she waits and waits and waits and waits and waits for it to rain.
20:41:24 <Saizan> mk: btw the mote itself doesn't "call" anything
20:41:33 <monochrom> mauke, have you considered using PHP for that? :)
20:41:41 <mauke> monochrom: no, because I'm not crazy
20:41:58 <ion> monochrom: Of course i don’t tell them about electrical signals first, i teach them Maxwell’s equations and then wait until they figure out that could be used for signals.
20:42:05 <Saizan> mk: it's just a description of what needs to be called
20:42:22 <monochrom> ion wins!
20:42:24 <shachaf> "mauke not crazy", claims area mauke
20:42:41 * monochrom uses cations and anions to represent integers!
20:42:44 <mk> Saizan: yeah, I know, runtime etc. The thread is presumably messing about with the mote structure as it does this
20:42:57 <NihilistDandy> shachaf: "mauke experts still divided"
20:43:05 * ddarius uses spin states to represent rationals.
20:43:39 <ion> mk: See mauke’s link.
20:44:13 <ion> m(au)k(e)
20:44:20 * NihilistDandy has determined the universe to be unobservable, so the very concept of integer is an absurdity
20:44:43 <mk> ion: looking, though I don't know perl
20:44:54 * ddarius believes reality is observable but doesn't subscribe to it.
20:45:06 <mauke> I think it's pretty readable but I do know perl
20:45:16 <shachaf> mauke: I don't know Perl and think it's pretty readable.
20:45:27 <shachaf> But knowing Haskell is probably more helpful than knowing Perl for reading that snippet.
20:47:03 <monochrom> write an Agda version to complete the cycle :)
20:47:34 <monochrom> hi copumpkin, do you mind translating http://hpaste.org/73555 to Agda? hehehe!
20:48:43 <shachaf> monochrom: Ask conal to do it. He'll say that that code is meaningless and therefore there's nothing to translate.
20:49:14 <monochrom> that is just one possible outcome, the happiest one
20:50:04 <monochrom> the worst outcome is that he spends all his time to give meaning to perl
20:50:30 <mauke> http://mauke.hopto.org/stuff/perl/yes.pl
20:50:40 <shachaf> monochrom: He's already given up on giving meaning to IO. Why would he bother with Perl?
20:50:45 <mauke> should be easy to understand for haskellers
20:51:42 <ddarius> int () = 0
20:51:52 <mauke> hmm?
20:52:19 <ddarius> Er I forgot the argument.
20:52:20 <mauke> it's clearly int (//+$@)
20:52:50 <ddarius> mauke: Yes, I just did the latter part but forgot the former by then.
20:53:08 <ddarius> But yes, easy to understand for Haskellers.
20:53:23 <haqe17> Hi, can anyone tell me what is wrong with the following line. It is for the last part of the RLE exercise in the wiki.
20:53:26 <haqe17>  let {stringToRle :: String -> [(Int,Char)];stringToRle []=[]; stringToRle (i:c:ics) = ((read.show) i,c):(stringToRle ics);}
20:53:39 <mauke> the perl code mimics the haskell version
20:53:49 <dobblego> haqe17: are you getting a compiler error?
20:53:50 <ddarius> mauke: But the C doesn't.  Why not?
20:53:52 <mauke> they share the main code
20:53:59 <mauke> ddarius: I couldn't be arsed
20:53:59 <haqe17> dobblego: no, runtime error
20:54:21 <mauke> ddarius: I wrote the Perl/Haskell hybrid and someone asked me "what, no C version?"
20:54:22 <dobblego> haqe17: you handle the empty list and a list with at least two elements, but what about one-element lists?
20:54:24 <mauke> so I quickly added it
20:54:25 <pqmodn> haqe17, your function isn't defined for something like stringToRle (x:ics)
20:54:35 <ddarius> mauke: I deem your answer Acceptable.
20:54:40 <mk> mauke: can you give me a summary of what that paste code does?
20:54:43 <Cale> i is a Char, if you show it, you'll get a string like "'a'"
20:54:52 <mauke> mk: what programming languages do you know?
20:54:55 <Cale> and then if you read that as an Int, you'll get a parse error
20:54:55 <shachaf> Cale: i *am* a Char
20:55:03 <Cale> shachaf: lol
20:55:06 <pqmodn> heh
20:55:25 * ddarius tries not to offend shachaf's ethnic sensibilities.
20:55:35 <ion> I’m a Num a => a, not a Free m!
20:55:44 <mk> mauke: javascript, java, some clojure
20:55:45 <haqe17> dobblego: ok, but one element lists shouldnt exist. (all inputs would have an even length)
20:55:47 <ion> shachaf: I thought you are a Chaf.
20:55:51 <mauke> mk: ok, what's unclear?
20:56:11 <haqe17> Cale: inputs are of the form "1z2o1m1a1z2o1m1a1y1a1y"
20:56:16 <dobblego> haqe17: I think your runtime error disagrees doesn't it? You can be sure by handling the empty list with: stringToRle [_] = error "Surprise!"
20:56:32 <mk> mauke: the comma use in the my $main line
20:56:39 <dobblego> haqe17: do you see "Surprise!" when you change your code like that, then run it again?
20:56:40 <monochrom> then you just need "read i" for the Int
20:56:50 <mauke> mk: technically it's list concatenation
20:56:55 <dobblego> s/empty list/one-element list
20:56:56 <mauke> mk: practically it's an argument list
20:56:58 <monochrom> oh, sorry, "read [i]"
20:57:31 <mauke> mk: line 40 is a call to bind_, which takes two arguments
20:58:00 <haqe17> dobblego: no, i see the same error. that is: Exception: Prelude.read: no parse
20:58:25 <dobblego> haqe17: oh I see, that means your read function is trying to parse a String into a value and that value does not parse correctly
20:58:36 <pqmodn> > read "a" :: Int
20:58:37 <lambdabot>   *Exception: Prelude.read: no parse
20:58:55 * ddarius wonders why that sentence wasn't the second sentence from haqe17.
20:59:03 <mauke> > read "'1'" :: Int
20:59:04 <lambdabot>   *Exception: Prelude.read: no parse
20:59:12 <mk> ok, this returns a tuple, which is passed to rts. What is the for loop looping over?
20:59:13 <mauke> > read (show '1') :: Int
20:59:14 <lambdabot>   *Exception: Prelude.read: no parse
20:59:32 <mauke> mk: technically it returns a list, but whatever
20:59:49 <mauke> mk: it's "looping" over $m->[0]. think switch/case instead
21:01:04 <haqe17> ok, i see what the problem is. but anyone know how to solve it?
21:01:10 <mk> isn't m->[0] simply '>>='?
21:01:28 <mauke> mk: in the first call, yes
21:02:26 <mk> oh I see
21:03:20 <mk> so the mote might as well be storing a function composition
21:03:31 <mauke> er. yes, that's what it does
21:05:28 <haqe17> monochrom: ah, thanks. :)
21:07:18 <mk> ok, yes, function composition is difficult to call lazy, but structures that are not themselves functions that are used to produce a value on-demand (whether using a stored function or not) seem lazy, unless I'm missing something
21:08:45 <spark21> Hello, I  want to make a small UI that clicking left or right changes to the previous/next plot on a list, is this difficult/what libraries should I use? Thanks!
21:08:56 <mk> for example, clojure allows infinite sequences/lists that produce values based on a function
21:09:22 <ion> spark21: HTML
21:10:03 <NihilistDandy> > take 15 $ [1..]
21:10:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
21:10:11 <Saizan> mk: you're still missing the point that the "mote" doesn't produce anything
21:10:12 <spark21> ion: hmmm, having a webserver answering request?
21:10:54 <Saizan> mk: we may colloqually talk as if it does, but we're abusing language there
21:11:09 <ion> spark21: Or just static HTML files on the disk.
21:11:43 <mk> Saizan: I am colloquially talking as if it does. Even the runtime doesn't do anything - electrical signals are ultimately responsible.
21:12:42 <Saizan> mk: when you bring lazyness in the mix you're not allowed that confusion anymore
21:13:31 <Saizan> mk: in fact, a bit part of why IO is useful is recognizing that evaluation of descriptions is separate from performing the side-effects described
21:13:57 <Saizan> mk: and we reserve lazyness for talking about a mode of evaluation
21:14:08 <spark21> ion: and what could i use to build them?
21:14:47 <ion> spark21: A shell oneliner? I have no idea. You didn’t really specify what you’re doing.
21:14:51 <Saizan> mk: *big part
21:15:01 <mk> Saizan: there aren't any side-effects described, as far as I can tell - I'm not sure what you mean by "performing the side-effects", though
21:15:14 <johnw> spark21: what was the question?
21:15:24 <spark21> ion:  i just have a big list of list of points, and I want to be able to skim between them fast
21:15:36 <Saizan> mk: i mean the actual reading from stdin for getLine or writing to stdout for putStrLn
21:15:59 <Saizan> mk: for the getLine >>= putStrLn example
21:18:35 <spark21> johnw: I have a [[float]] and i want to be able to see every [float] and skim between them, does that make sense?
21:19:08 <mk> Saizan: sure. I mean, you need a string value for write, right? So you create this giant lazy thing, which is actually a mote. Much like you would a lazy list, but larger and more complex. And then it gets asked for the value, and produces it.
21:20:10 <mk> "takes part in the production", if you prefer
21:20:20 <monochrom> main = getLine >>= \_ -> putStrLn "hello"  is likely to destroy a lot of intuition
21:20:33 <monochrom> (have you run it?)
21:21:29 <Saizan> mk: i have no idea what you mean by that
21:21:44 <shachaf> mk: This has absolutely nothing to do with laziness.
21:21:56 <NihilistDandy> spark21: Skim?
21:23:11 <spark21> NihilistDandy: move between plots 'fast'
21:24:09 <mk> monochrom: what's wrong with that?
21:24:49 <NihilistDandy> spark21: I don't follow. Move how?
21:25:28 <mk> Saizan: a mote is an action or a computation. So is a lazy sequence based on a function. There doesn't seem to be much difference between the two, except that IO motes are very... customizable
21:25:32 <pqmodn> spark21: do you mean you want to convert [[float]] to [float]?
21:25:59 <pqmodn> > concat [[1.0,2.0],[3.0,4.0]]
21:26:00 <lambdabot>   [1.0,2.0,3.0,4.0]
21:26:25 <spark21> pqmodn: Think like that, I have a [[float]], I want a list of [plots] and a way to show that list of plots?
21:27:55 <spark21> NihilistDandy: The problem is that I can't show every plot at the same time, so I need to be able to control witch plot is being shown at runtime
21:29:32 <NihilistDandy> spark21: How do you define a plot?
21:29:53 <NihilistDandy> Is a plot just a list of floats?
21:31:03 <spark21> atm yes, but
21:31:41 <randomclown> type plot = [Float] ?
21:32:00 <spark21> yes
21:32:06 <frio> in practise, are plots actually [Float] or (Float, Float)?
21:32:21 <randomclown> then [plot] = [[Float]
21:32:24 <randomclown> ]
21:32:25 <frio> data Plot = { x :: Float, y :: Float } :)?
22:12:12 * hackagebot list-mux 1.0 - List Multiplexing  http://hackage.haskell.org/package/list-mux-1.0 (ChrisHeller)
22:14:56 <spark21> http://hpaste.org/73556 compiles to "the impossible happened please report", does that ring a bell to someone?
22:15:55 <shachaf> spark21: That shouldn't be happening.
22:15:58 <shachaf> Maybe ask in #ghc.
22:16:13 <spark21> Does the code seems correct at least?
22:16:22 <spark21> Or im trying to do something bad?
22:17:04 <spark21> (it's the deriving show that is creating the error)
22:17:12 <shachaf> Oh, wait.
22:17:19 <shachaf> I've heard of this bug before. I think it's fixed in HEAD.
22:17:29 <shachaf> You want deriving (Show) instead of deriving (show).
22:17:45 <nand`> oh yes
22:17:56 <nand`> nameModule show{tV afK} <- is the panic, btw
22:18:11 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/5961
22:18:46 <spark21> shachaf: that did it , thanks!
22:19:36 <spark21> I should re-estate that haskell errors are mind bogling
22:23:48 <ddarius> spark21: That was a compiler bug.
22:37:13 * hackagebot mustache2hs 0.1 - Utility to generate Haskell code from Mustache templates  http://hackage.haskell.org/package/mustache2hs-0.1 (StephenWeber)
22:40:55 <rking> Hrm. On https://github.com/singpolyma/mustache2hs/blob/master/example/Records.hs it says "data Blog = Blog { … }". What are the left and right "Blog"s about?
22:41:45 <nand`> the left blog is the type name, the right one is the constructor name
22:41:45 <shachaf> They're in different namespaces.
22:41:53 <shachaf> data Foo = MkFoo Int
22:41:59 <shachaf> MkFoo :: Int -> Foo
22:42:04 <frio> the right-hand Blog constructs types of the left-hand Blog
22:42:08 <shachaf> Except in this case "Foo" and "MkFoo" happen to have the same name.
22:42:23 <shachaf> "constructs types"? It constructs values.
22:44:07 <frio> that's what i meant shachaf :)
22:44:20 <weethawk> anyone home?
22:45:30 <mikeplus64> weethawk: yo
22:45:49 <NihilistDandy> Nope
22:46:11 <pharaun> is there a function like - fapp f x = f $ f x ? but for N?
22:46:49 <siracusa> What is N?
22:46:55 <shachaf> Apply f N times?
22:46:58 <pharaun> yes
22:46:59 <shachaf> iterate f x !! n
22:47:07 <rking> nand`/shachaf/frio: Hrm. Thanks so far.  I don't see anything "import"ed that would pull either of those in. Are they defined later?
22:47:11 <pharaun> shachaf: doh
22:47:20 <shachaf> rking: The "data" declaration defines them.
22:47:41 <shachaf> You should probably read an introduction to Haskell before that code. :-)
22:47:47 <rking> Yeah, you're right.
22:48:02 <rking> I keep taking these random stablets at understanding it, but I really need to allocate some up-front time.
22:48:16 <rking> What's an intro that isn't Learn you a Haskell?
22:48:17 <nand`> @where lyah
22:48:17 <lambdabot> http://www.learnyouahaskell.com/
22:48:19 <nand`> :(
22:48:28 <nand`> @where rwh
22:48:29 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:48:29 <frio> @where real world haskell
22:48:29 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
22:48:34 <frio> snap :p
22:48:38 <rking> Hehe
22:49:05 <frio> (also, lol at it being "the xmonad reference")
22:49:12 <nand`> hehe
22:50:25 <rking> Cool, looks good.
22:50:42 <rking> And I really like how each paragraph is commentable.
22:50:43 <NihilistDandy> The pointfree definition is fun: ((!!) .) . iterate
22:50:59 <nand`> :t ((!!) .) . iterate
22:51:00 <frio> yeah, I really like rwh rking :)
22:51:00 <lambdabot> forall a. (a -> a) -> a -> Int -> a
22:51:18 <NihilistDandy> @let g = ((!!) .) . iterate
22:51:19 <lambdabot>  Defined.
22:51:29 <NihilistDandy> > g (+1) 4 5
22:51:29 <lambdabot>   Ambiguous occurrence `g'
22:51:30 <lambdabot>  It could refer to either `L.g', defined at <local...
22:51:35 <NihilistDandy> > L.g (+1) 4 5
22:51:35 <rking> frio: This seems more my style than LYAH.
22:51:37 <lambdabot>   9
22:52:03 <nand`> I personally didn't enjoy the bits of RWH I read too much
22:52:18 <frio> rking: having both on hand is good
22:52:51 <nand`> I think it spends too much time on things that I think are less interesting and less time on things I think are more interesting; I also think the code examples it shows (especially later on) are horrendously ugly
22:53:04 <rking> I just needd to lock horns with some Haskell thing and go forward.
22:53:07 <frio> whenever I had an issue with a section in RWH, LYAH would generally have another take on it that'd help me grok it better :)
22:53:08 <shachaf> nand`: What about the parts that you just read a normal amount?
22:53:12 <rking> nand`: I felt like LYAH wasted my first 5 chapters.
22:53:18 <rking> I learned about 2.4 things about Haskell
22:53:21 <shachaf> rking: I don't think RWH is that great an introduction to Haskell.
22:53:25 <rking> Darnit.
22:53:26 <NihilistDandy> I really like The Craft of Functional Programming
22:53:28 <pqmodn> @hoogle (a -> b, a -> c) -> a -> (b, c)
22:53:29 <lambdabot> No results found
22:53:35 <nand`> shachaf: the ‘too much’ was in reference to enjoying; not reading
22:53:35 <shachaf> rking: A good book -- but not available online -- is Hutton's _Programming in Haskell_
22:53:38 <NihilistDandy> 3rd edition is great. Lots of QuickCheck goodness
22:54:02 <shachaf> rking: You can also read the Gentle Introduction -- it's the official tutorial! -- if you like denser material.
22:54:03 <rking> I'm an actual programmer, but I suck at FP things. I know this is a weak spot, but I can learn languages and concepts quickly if given the right input.
22:54:06 <shachaf> (At least, I hear it's denser.)
22:54:14 <shachaf> (I haven't really read it.)
22:54:15 <shachaf> @where tutorial
22:54:15 <lambdabot> http://www.haskell.org/tutorial/
22:54:20 <meiji11> I love YAHT
22:54:23 <nand`> I haven't read the gentle tutorial either; maybe I should so I can comment on it
22:54:33 <shachaf> I would strongly not recommend YAHT. :-(
22:54:34 <meiji11> but i wish hal daume would finish the advanced section.
22:54:37 <weethawk> I'm not sure if this is the right channel to ask, but I'm just asking any channels in general. Does anyone know a possible way to find out the creator/owner of a Facebook Fan Page?
22:54:40 <NihilistDandy> shachaf: I wouldn't say "not available online"
22:54:45 <meiji11> why's that, shachaf ?
22:55:02 <frio> yeah rking; RWH was good for me coming from the same perspective :)
22:55:02 <shachaf> meiji11: Because it's misleading and confusing.
22:55:16 <shachaf> It's also pretty outdated, I think.
22:55:18 <weethawk> there's a fan page out that's been troubling my family in particular for some time, and even after Facebook deleted them they keep coming back
22:55:19 <NihilistDandy> weethawk: :/
22:55:25 <frio> well; i say that, i'm now a year or so in my haskell odyssey and still pretty crap
22:55:41 <rking> YAHT wins early points by saying,
22:55:43 <nand`> from the gentle tutorial's intro page: “Our goal is to provide a gentle introduction to Haskell for someone who has experience with at least one other language, preferably a functional language (even if only an "almost-functional" language such as ML or Scheme).”
22:55:43 <rking> The "::" can be read "has type."
22:56:04 <weethawk> NihilistDandy: im just asking everywhere in general to find out a way, it's getting out of control. sorry if it's too much to ask
22:56:05 <shachaf> I read it "colon colon".
22:56:20 <NihilistDandy> frio: I'm with you. I've learned a lot (and learned a lot from a PL class in Ocaml), but I feel like there's a lot more
22:56:24 <shachaf> (Hmm, do I? I used to, but I'm not sure whether I still do.)
22:56:39 <NihilistDandy> nand`: I like that
22:57:35 <sully> YAHT?
22:57:41 <frio> yet another haskell tutorial
22:57:45 <sully> ah
22:57:47 <nand`> rking: LYAH has “:: is read as "has type of".”
22:58:11 <sully> what worked well for me was:
22:58:19 <sully> 1) have a very strong SML background
22:58:33 <sully> 2) listen to people talk about haskell for 18 months without really paying attention
22:59:09 <sully> 3) skim through like 3 popular tutorials to figure out syntactic differences and the stuff that is actually different
22:59:10 <NihilistDandy> frio: I feel like writing a proper library would be a good learning experience, but finding a motivating example is difficult. I'm working on a barebones text adventure engine based on someone else's work (I wanna say byorgey, but I can't remember now), so that's been fun. Still a ways to go, though.
22:59:13 <sully> 4) write a bunch of code
22:59:20 <rking> nand`: Aha, you're right. I missed it, then.
22:59:29 <NihilistDandy> sully: That's a good method
22:59:35 <frio> yeah NihilistDandy; writing stuff is definitely the only way to really learn it. it can be quite a grind though.
22:59:37 <sully> I feel like I would have been overwhelmed trying to learn haskell if I didn't have a strong backgroun in ML
22:59:57 <NihilistDandy> frio: I think once you have an idea, it gets much easier. Finding that idea seems like the hard part to me
23:00:45 <NihilistDandy> sully: I definitely learned quite a bit from my PL class. Ocaml felt kind of clunky compared to the Haskell I'd been learning up to then, but it was an illuminating experience
23:00:51 <rking> "an expression such as 1/0 is typable" ← Does that mean it's "capable of being typed on a Qwerty" or does that mean "Passes type checks"?
23:01:05 <NihilistDandy> rking: Yes.
23:01:05 <frio> definitely NihilistDandy :). I think just sitting in here and immersing yourself in it helps too (I just had to google "points-free style" after your example above :p)
23:01:24 <rking> Hehe, K. I was mostly making sure that the second meaning was a real definition of the word.
23:01:35 <sully> I should probably look at ocaml at some point
23:01:40 <nand`> I think one of the first bits of Haskell I've ever written (aside from small scraps while learning) was my xmonad configuration file
23:01:42 <sully> and figure out whether I like it more than SML
23:01:47 <NihilistDandy> frio: Yeah, a lot of my learning has just been absorbing and thinking about the things that get talked about here. Some great tuff to think about, surely.
23:01:51 <nand`> first bits of “real haskell” I'd say
23:01:58 <nand`> where ‘real’ means ‘really in use’
23:02:05 <frio> nand`: xmonad is what led me to the language :)
23:02:13 * hackagebot postgresql-simple 0.2.4.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.2.4.0 (LeonSmith)
23:02:24 <rking> nand`: Xmonad is driving me to it sooner than the "Oh, some day I might learn that" schedule I was on before.
23:02:38 <NihilistDandy> nand`: I've been thinking about that. I used xmonad briefly on OS X, but I didn't configure it much. Then again, I was very new to Haskell, at the time.
23:03:00 <nand`> frio: the language is what led me to xmonad :P
23:03:05 <NihilistDandy> *stuff
23:03:06 <frio> hahahahaha :)
23:03:34 <nand`> (I try and pick out programs written in haskell over alternatives if I can find a good one; since it gives me the ability to hack on its source code)
23:03:41 <sully> I'm not sure how I made the transition from learning haskell so I could make fun of it to my haskeller friends more effectively to actually using haskell for things
23:04:01 <rking> NihilistDandy: The trick there is that native OSX apps (not-X11 apps) don't tile or obey workspaces, right?
23:04:02 <sully> like, submitting papers about EDSLs I wrote in haskell
23:04:05 <shachaf> sully: That's dedicated mockery.
23:04:10 <NihilistDandy> nand`: The openness of source in the Haskell ecosystem is a huge boon.
23:04:12 <sully> (bad papers; rejected papers)
23:04:20 <c_wraith> sully: haskell is insidious
23:04:30 <sully> the story of how we picked haskell to use was sort of funny
23:04:40 <sully> I was an SMLer and my partner was an ocamler
23:04:44 <NihilistDandy> rking: That's true. I mostly used it for wine applications and other X stuff.
23:04:47 <sully> neither of us had ever used the other
23:04:52 <sully> and we both had some haskell background
23:05:28 <nand`> NihilistDandy: besides being a huge GPL fanboy in the past, I've come to enjoy the prevalence of BSD-style licenses throughout the Haskell ecosystem - it made me start to forget licenses exist for the most part
23:05:29 <sully> and so we used haskell instead, despite both preferring "ml"
23:05:29 <pqmodn> @pl curry (uncurry (mappend `on` fst), uncurry (mappend `on` snd)))
23:05:30 <lambdabot> (line 1, column 63):
23:05:30 <lambdabot> unexpected ")"
23:05:30 <lambdabot> expecting variable, "(", operator or end of input
23:05:34 <pqmodn> @pl curry (uncurry (mappend `on` fst), uncurry (mappend `on` snd))
23:05:34 <lambdabot> curry (uncurry (mappend `on` fst), uncurry (mappend `on` snd))
23:05:38 <sully> haskell was actually probably better for this though
23:05:42 <sully> mostly just because of do notation
23:05:48 <nand`> s/besides/despite/
23:06:29 <NihilistDandy> nand`: I definitely prefer the prevalence of BSD licenses over GPL. As much as I support the spirit of GPL, its fairly infectious nature always turned me off.
23:07:11 <nand`> I sometimes wish I never learned about the State monad, it tends to make me regress to imperative solutions
23:07:21 <nand`> in cases where much more elegant ones exist
23:08:23 <ddarius> nand`: Just don't use it.
23:09:03 <NihilistDandy> nand`: That desire for elegance is an attractive quality to me. It's part of what got me interested in Haskell in the first place.
23:09:13 <shachaf> nand`: I sometimes wish I never learned about PHP. :-(
23:09:20 <shachaf> But it's too late now.
23:09:30 <NihilistDandy> shachaf: I always wish that. :(
23:09:59 <rking> NihilistDandy:  I was just talking about that. Wondering why I blindly let myself use a virus-license of any sort.  I'm thinking I'll do everything under Public Domain and be happy.
23:11:23 <Nereid> shachaf: if anything, it serves as an example of what not to do :D
23:11:50 <nand`> NihilistDandy: I'm not sure what got me interested in Haskell, but what made me stick with Haskell is twofold: 1. the desire for elegant minimalism, and 2. the desire for elegant abstraction - the former is eg. having a tiny language at its core but still retaining the ability to create your own expressive language constructs; the latter is what allows such great amounts of code reuse
23:12:16 <NihilistDandy> rking: Right? If information wants to be free, let it be free. Even a permissive license like BSD or MIT is preferable to the strictness of GPL, at least in my mind.
23:12:27 <shachaf> #not-haskell
23:13:38 <rking> nand`: If it delivers on both of those things, then I'm definitely in. That's a neat summary of what I value.
23:14:23 <rking> 1) Does it work?  2) Does it have no unnecessary parts?  2) Does it communicate well to the programmer?
23:14:44 <NihilistDandy> nand`: I totally agree. The number of constructs that are defined in libraries that in other languages would be language primitives (or essentially so) was very interesting. Expressiveness is something I demand from the languages I work with, and when I can't have it I feel unnecessarily constrained.
23:14:46 <rking> I don't know if there's a (4).
23:15:04 <nand`> rking: or a (3), apparently
23:15:17 <rking> (2) and (2) are tied.
23:15:26 <NihilistDandy> nand`: (1, [2,2])
23:15:33 <johnw> NihilistDandy: I agree with you completely
23:16:35 <nand`> a great example would be ‘data Bool = True | False’ <- I can't say I know any other typed languages where booleans are not a built-in type
23:16:50 <NihilistDandy> Exactly.
23:16:56 <rking> nand`: Define "typed language"?
23:17:05 <NihilistDandy> Well, the whole ML family, I suppose
23:17:08 <nand`> rking: a language with more than one type, I guess
23:17:15 <nand`> well, no
23:17:17 <nand`> I'm not sure how to define it
23:17:23 <rking> Smalltalk treats true/false, and if-statements, nonspecially.
23:17:27 <nand`> a language that distinguishes values based on type; I suppose
23:17:33 <frio> it blew my mind when i read that data Bool = True | False thing in RWH
23:17:36 <nand`> eg. a counterexample would be the untyped lambda calculus
23:18:13 <shachaf> Booleans are definitely built-in in Haskell.
23:18:40 <mikeplus64> nand`: maybe a more useful definition is a language that doesn't coerce values automatically between what are really different types (ie double <-> int, float <-> double etc)
23:18:43 <ddarius> Haskell is a pretty inexpressive language.
23:19:06 <rking> ddarius: Cool, a devil's advocate.  Do elaborate on your advocation.
23:19:07 <nand`> shachaf: I should have used a better word; perhaps something like ‘primitive’, basically something that can't be expressed within the language itself
23:19:09 <pharaun> http://hpaste.org/73557 any reason why i can't do currying on - line 2? and is there any way i could improve these 2 functions?
23:19:10 <johnw> ddarius: how do you mean?
23:19:25 <shachaf> nand`: Bools are primitive. They're part of the syntax.
23:20:03 <ddarius> If we added mutable variables, first-class continuations, and/or LP style non-determinism, that would strictly, and significantly increase Haskell's expressiveness.
23:20:16 <nand`> shachaf: I don't think I agree with that; just because some syntax desugars to things that only compile with the existence of booleans doesn't mean booleans themselves can't be expressed in the language
23:20:19 <mikeplus64> pharaun: you can, but you have to compose the functions, ie getTag2 = map (charOrder !!) . fapp
23:20:29 <shachaf> ddarius: Lambda Prolog?
23:20:39 <ddarius> shachaf: Logic Programming.
23:20:43 <shachaf> Ah.
23:20:57 <ddarius> Though lambdaProlog is probably the nicest incarnation of LP that has a serious implementation.
23:21:00 <liyang> shachaf: in that case class Monad is primitive too.
23:21:14 <mikeplus64> @pl getTag2 n x = (charOrder !!) `map` fapp n x
23:21:14 <lambdabot> getTag2 = (fmap (charOrder !!) .) . fapp
23:21:17 <shachaf> nand`: A type isomorphic to Bool can be expressed in many languages.
23:21:19 <shachaf> liyang: Agreed.
23:21:33 <mikeplus64> pharaun: oh, sorry, because fapp takes 2 arguments, . will not work as you might expect
23:21:38 <pharaun> :\
23:21:40 <liyang> (But it's just sugar!)
23:22:13 <pharaun> mikeplus64: so it seems like i have this at a reasonable level of simplification, and to transfer to pointfree seems like it makes it a little more icky
23:22:13 <shachaf> liyang: Isn't that exactly what "built-in" means?
23:22:24 <pharaun> re more parens
23:22:35 <mikeplus64> pharaun: you could make your own combinator for it, but yeah i think it's fine as is (although i wouldn't really use the infix map
23:22:38 <mikeplus64> )
23:22:53 <shachaf> pharaun: Point-free code doesn't always work out to be nice in Haskell.
23:22:57 <pharaun> mikeplus64: any reason why not? i'm kind of used to thinking x apply to y?
23:23:03 <pharaun> shachaf: yeah :) i suppose
23:23:13 <mikeplus64> pharaun: easier on the eyes to me
23:23:24 <pharaun> i suppose yeah with the `'s
23:23:25 <nand`> shachaf: but that's not what I mean; arguably every turing complete language would give you that ability
23:24:33 <pharaun> @pl fapp n x = mod' `map` take n (iterate div' x)
23:24:33 <lambdabot> fapp = (fmap mod' .) . (. iterate div') . take
23:24:50 <shachaf> pharaun: Use <$> instead of `map`
23:24:51 <pharaun> hmm
23:25:21 <ddarius> Oh yes, going back to something earlier.  iterate f x !! n is generally a bad thing to do.
23:25:38 <shachaf> ddarius: Because of strictness issues?
23:25:43 <ddarius> Yes.
23:25:47 <pharaun> ddarius: got a better solution ? :) in this case it'll probably be max of maybe 4
23:25:49 <shachaf> Right.
23:26:03 <ddarius> (Among other things.)
23:26:12 <ddarius> Admittedly, if f is lazy it's fine if a bit wasteful.
23:26:25 <ddarius> (Though it may well fuse.)
23:26:48 <ddarius> pharaun: For n <= 4 it doesn't really matter
23:27:33 <shachaf> But for n=5, oh boy.
23:28:17 <ddarius> Hmm, id is strict (blatantly) and ($) is non-strict (not so blatantly), so arguably you should foldl' id but not foldl' ($).
23:28:58 <mikeplus64> foldl' ($!) perhaps
23:29:21 <shachaf> @src $!
23:29:21 <lambdabot> f $! x = x `seq` f x
23:29:32 <shachaf> $! is also non-strict. :-)
23:30:09 <ddarius> Well, at any rate, it just needs to be strict in the accumulator which it will be in both cases assuming the folded functions are strict.  If you don't assume that ($!) would be better.
23:31:07 <ddarius> Though now I'm curious if I can find an example where ($) v. id leads to significant performance differences in a relatively natural way.
23:31:29 <ddarius> s/that ($!)/that, ($!)/
23:33:02 <mikeplus64> with optimizations wouldn't ($) and id both be inlined anyway?
23:33:10 <c_wraith> usually.
23:33:15 <c_wraith> you can't always inline it.
23:33:30 <c_wraith> map ($ 5)
23:33:32 <c_wraith> for instance
23:33:38 <mikeplus64> yeah
23:33:44 <shachaf> That can still be inlined, presumably.
23:33:55 <shachaf> ($ 5) ==> (\x -> x $ 5) ==> (\x -> x 5)
23:34:19 <mikeplus64> i'd be sort of worried if $ had overhead considering how widely used it is
23:34:57 <ddarius> mikeplus64: The compiler can't change the semantics of your program.
23:35:08 <ddarius> (Well it -can- but it's not supposed to.)
23:35:39 <mikeplus64> doesn't ghc do it all the time through things like rewrite rules?
23:36:07 <shachaf> If rewrite rules change the semantics of your program, they're bad rewrite rules.
23:36:09 <ddarius> Rewrite rules are completely unrestricted, they can change your code arbitrarily.
23:36:33 <shachaf> (Or, at least, the compiler is no longer responsible.)
23:37:15 <ddarius> I wrote a CEK machine in rewrite rules a while back, that quite certainly would have done horrible damage to my code's semantics if it had had some.
23:39:16 <mikeplus64> checking some ghc core now, with -O2 at least, putStrLn $ "yes" ++ "no" has no difference to putStrLn ("yes" ++ "no"), i can rest easy polluting my code with $s
23:41:44 <ddarius> mikeplus64: The issue will be foiled strictness analysis.  This won't happen too often for the way ($) is typically used.
23:42:42 <mikeplus64> ddarius: any examples? (i'm not really sure how strictness analysis can be/is foiled)
23:52:29 <pharaun> @pl genTag k = genTag' 4 $ abs k
23:52:29 <lambdabot> genTag = genTag' 4 . abs
23:52:33 <pharaun> doh me
23:53:08 <johnw> it's was always strange to me that "point-free" style involves using more "." characters :)
23:53:24 <johnw> it's full of points!
23:53:25 <pharaun> i find it amusing :)
23:57:10 <NihilistDandy> (\ c -> t (hee (hee c)))
