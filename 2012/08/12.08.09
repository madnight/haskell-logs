00:00:20 <shachaf> @ty (<$)
00:00:21 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
00:00:32 <c_wraith> heh
00:00:34 <c_wraith> that return is const
00:00:34 <MostAwesomeDude> DanC: The action might not actually do any I/O work. vv
00:00:39 <shachaf> Yes.
00:00:46 <MostAwesomeDude> > return "asdf" :: IO String
00:00:48 <lambdabot>   <IO [Char]>
00:00:52 <DanC> well, that would be a noop IO action.
00:00:56 <c_wraith> > return 1 2
00:00:58 <lambdabot>   1
00:01:03 <shachaf> > fmap fix return 1
00:01:04 <DanC> but I suppose it amounts to the same thing
00:01:05 <lambdabot>   1
00:01:06 <startling> c_wraith: heh
00:01:56 <shachaf> @ty fmap fmap fmap fix fmap return
00:01:57 <lambdabot> forall a (m :: * -> *). (Monad m) => (m a -> a) -> m a
00:01:59 <DanC> " A notable exception is Set, which cannot be made a Functor in Haskell" <- head scratcher.
00:02:00 <shachaf> zomg
00:02:13 <pharaun> oh hey <3 whoever linked that wiki page
00:02:17 <pharaun> i've been reading it its great
00:02:44 <MostAwesomeDude> DanC: Set has an Ord constraint on its members, so it can't be made into a Functor.
00:03:06 <DanC> yes, made sense the 3rd time I read it
00:03:23 <startling> DanC, fmap would need to take a (Ord b => a -> b), not just an (a -> b)
00:03:27 <c_wraith> Ord isn't even really the problem.
00:03:46 <c_wraith> fmap on sets would violate either the Functor laws or the set properties
00:04:09 <c_wraith> fmap (const 0)
00:04:11 <ReinH> so assuming my functor is Either or Maybe
00:04:12 <dfeuer> Quaere: I'm (still) trying to implement an efficient k-way merge (with small k) of pairs to be sorted by their first elements, using a binary heap in an STArray. I realized that the approach I was pursuing (keeping an extra copy of the first element of the first pair of each list) would probably allocate a bunch of memory.
00:04:20 <startling> c_wraith: oh, that's a good point too
00:04:20 <dfeuer> Which I would like very much to avoid.
00:04:22 <shachaf> c_wraith: Not if it had a constraint!
00:04:32 <shachaf> ...In which case the Set could reorganize for the new ordering.
00:04:40 <ReinH> so if my monad is Maybe, what is the better way to say fmap . Just?
00:04:45 <c_wraith> shachaf: fmap (const 0) kind of breaks that, still.
00:04:52 <shachaf> Why?
00:04:53 <DanC> "The composition of two Functors is also a Functor." <- the article asks true or false? it seems nonsensical, to me; Functor is a type constructor. what does it mean to compose types?
00:04:59 <startling> ReinH: return .
00:05:15 <startling> :t (fmap . Just)
00:05:16 <lambdabot>     Couldn't match expected type `a -> b'
00:05:16 <lambdabot>            against inferred type `Maybe a1'
00:05:17 <lambdabot>     Probable cause: `Just' is applied to too many arguments
00:05:31 <shachaf> DanC: The composition of two functions, f and g, is a function \x -> f (g x)
00:05:36 <c_wraith> shachaf: because it either violates the set properties (the same element is in the set multiple times) or it alters the structure of the set (number of items in it)
00:05:37 <Cale> DanC: Well, thinking of type constructors as functions on types
00:05:38 <dfeuer> So one option is to use an immutable array of pairs of STRefs, which is kind of a nasty approach. The other option is not to keep an extra copy of the "key".
00:05:52 <shachaf> c_wraith: Altering the structure of the set is OK, isn't it?
00:06:23 <dfeuer> The latter option led me to wonder about whether there is a standard class similar to Ord, but for which order is defined between equivalence classes....  Anyone now of such?
00:06:27 <Cale> DanC: you could explicitly define   newtype Compose f g x = Compose (f (g x))
00:06:29 <shachaf> DanC: The composition of two functors, F and G, is a type function \x -> F (G x)
00:06:45 <c_wraith> shachaf: I suppose it is, since parametricity is already violated.. I can't depend on the free theorems from it.
00:06:47 <shachaf> So you might say newtype FdotG x = MkFdotG (F (G x))
00:07:10 <shachaf> c_wraith: This is not a Functor functor, clearly, because of the constraint, but it still obeys the laws.
00:07:14 <Cale> hehe, three different ways :)
00:07:18 <shachaf> You just have to work much harder at proving them. :-)
00:07:34 <Cale> For mine, you'd want to write an   instance (Functor f, Functor g) => Functor (Compose f g)
00:08:01 <startling> ReinH: I assume you meant "fmap someFn . Just"?
00:08:21 <DanC> seems an odd exercise at this point in the article.
00:08:23 <dfeuer> Specifically, I'm looking for a class for which the <= operation is transitive, total, and reflexive, but does not necessarily satisfy a<=b and b<=a -> a==b
00:08:47 <ReinH> startling: use case is: type Square = Maybe Piece; readSquare :: Char -> Maybe Square
00:08:58 <ReinH> readPiece :: Char -> Maybe Piece
00:09:03 <dfeuer> Because that's what you want for a priority queue without separate keys....
00:09:11 <ReinH> readSquare = fmap . Just readPiece
00:10:01 <Nereid> it's kinda scary how I independently come across the same category-theoretic things in math and in haskell
00:10:10 <ReinH> startling: an unknown char stays nothing, a piece becomes Just Square, which is Just ( Just Piece )
00:10:16 <Nereid> for instance, how (,) a is a monad when a is a monoid
00:10:51 <startling> ReinH, fmap's first argument is a function from a -> b.
00:11:00 <ReinH> :t just
00:11:01 <lambdabot> Not in scope: `just'
00:11:02 <ReinH> :t Just
00:11:03 <lambdabot> forall a. a -> Maybe a
00:11:05 <ReinH> so is just
00:11:25 <startling> ReinH: sure, but the results aren't
00:11:31 <Nereid> meanwhile, people make heavy use of the fact that, say, a ring (a monoid object in the category of abelian groups) gives a monoid on abelian groups
00:11:31 <ReinH> if something is a Just a, I want a Just (Just a)
00:11:45 <ReinH> if something is a Nothing, I want a Nothing
00:11:45 <Nereid> and then observe what happens when you replace it with a more general monad
00:11:52 <Nereid> oh, relatedly...
00:12:06 <ReinH> so basically the opposite of join?
00:12:07 <shachaf> ReinH: fmap Just?
00:12:14 <Nereid> or return
00:12:14 <ReinH> shachaf: yes, that's what I used
00:12:21 <shachaf> No, return doesn't do it.
00:12:22 <startling> ReinH, you said fmap . Just
00:12:23 <ReinH> Nereid: not return
00:12:25 <ReinH> startling: sorry
00:12:29 <Nereid> return (Just a) can give you Just (Just a)
00:12:30 <startling> you'd need return . return
00:12:33 <ReinH> errant (but significant) .
00:12:39 <Nereid> anyway
00:12:41 <startling> ReinH: ah, alright
00:12:41 <Nereid> here's the question.
00:12:51 <Nereid> in haskell, are there interesting monads for which join is an isomorphism?
00:12:58 <startling> ReinH: myValue >>= return . return
00:13:20 <Nereid> (because there sure are on the math side of things.)
00:13:23 <ReinH> hmm. I think fmap Join is a bit easier (for me) to understand.
00:13:25 <dfeuer> Here's the other question:  is [(,)] less efficient than ([],[])?
00:13:28 <ReinH> And if I can understand it, I can explain it ;)
00:13:30 <startling> ReinH: sure
00:13:41 <Nereid> dfeuer: they're not even equivalent.
00:13:49 <ReinH> startling: I thought I might be overlooking something very simple
00:13:53 <ReinH> like a single function
00:13:55 <ReinH> but I guess not
00:14:06 <ReinH> I guess "unjoin" is not a common thing to do woth monads?
00:14:07 <ReinH> *with
00:14:15 <Nereid> it is not an interesting thing to do
00:14:23 <ReinH> Nereid: maybe not, but it is useful
00:14:29 <Nereid> is it
00:14:44 <ReinH> it is, unless you'd like to show me an alternative that provides for the same use case
00:14:45 <startling> I don't see the use-case either tbh
00:14:53 <ReinH> ok I can show you some code
00:15:04 <startling> Just Nothing would be more informative, wouldn't it?
00:15:23 <dfeuer> What is the point of Maybe Maybe exactly?
00:15:35 <ReinH> let me show you
00:15:42 <startling> dfeuer: so you know where a computation failed, presumably
00:16:14 <Nereid> in that case you should use Either e
00:16:17 <Nereid> or something
00:16:27 <dfeuer> startling: by that point, some more sophisticated exception mechanism would seem to be in order.
00:16:33 <startling> s'true
00:16:36 <ReinH> indeed
00:16:40 <ReinH> *let me show you some code*
00:16:48 <Nereid> stop saying you'll show us some code and show us some code
00:16:49 <Nereid> ;
00:16:50 <Nereid> )
00:17:02 <ReinH> I am waiting for my browser :)
00:17:05 <ReinH> https://github.com/haskelllive/haskelllive/blob/master/Chess.hs#L36-39
00:17:19 <ReinH> comment is incorrect, ofc: empty squares are now '.'
00:17:24 <dfeuer> So does anyone have any thoughts on an order-like class of the sort I seek, or should I just write a little one of my own?
00:18:30 <Nereid> and the point is?
00:18:43 <Nereid> dfeuer: what sort?
00:18:47 <ReinH> Nereid: ?
00:19:01 <Nereid> ReinH: what about the code
00:19:17 <ReinH> Nereid: you asked some questions that could best be answered with the code
00:19:19 <ReinH> so there's the code
00:19:28 <Nereid> yes, how is it relevant?
00:19:31 <ReinH> ...
00:19:36 <dfeuer> Nereid:   it would support a <= relation that is total, transitive, and reflexive, but for which a<=b and b<=a does not imply a==b.
00:19:36 <ReinH> to my question about my code?
00:19:42 <ReinH> how is my code relevant to my question about my code?
00:19:44 <ReinH> ok, never mind
00:19:49 <Nereid> dfeuer: in other words, a partial order
00:19:56 <Nereid> oops.
00:20:02 <Cale> dfeuer: What's the overall goal?
00:20:02 <Nereid> wrong axiom dropped.
00:20:12 <dfeuer> Nereid: a partial order is not necessarily total. This is a partial order induced by a total order on equivalence classes.
00:20:13 <Cale> dfeuer: (what are you building this datastructure to do?)
00:20:13 <Nereid> can I call it a non-evil total order?
00:20:18 <startling> ReinH: oh, I see
00:20:39 <ReinH> startling: A Square is Maybe Piece, but Maybe Piece also represents an error in reading a piece in readPiece
00:20:44 <startling> yeah
00:20:58 <startling> might be worth a newtype for the Square
00:20:59 <ReinH> startling: I mention in the video that I should probably enrich the semantics by defining Square as Empty | Occupied Piece
00:21:09 <Nereid> or a total prorder
00:21:10 <ReinH> to make the distinction more clear
00:21:11 <Nereid> preorder
00:21:19 <ReinH> and, you know, avoid the confusion I've generated in here :)
00:21:29 <startling> ReinH: meh, I'd juse use Maybe
00:21:53 <startling> (with a newtype and GeneralizedNewtypeDeriving to derive a bunch of things)
00:21:58 <dfeuer> Cale: solve a toy problem on SPOJ that I mentioned earlier. I discovered that 1. the purely-functional pqueue package on Hackage that uses separate keys wasn't fast enough, 2. another package on Hackage that uses ordered elements instead of separate keys isn't applicable, because it requires Ord, a total order.
00:22:03 <ReinH> startling: go on :)
00:22:12 <DanC> "The fail function is an awful hack that has no place in the Monad class; more on this later." <- interesting.
00:22:31 <startling> ReinH: that way you get all the instances of Maybe without needing to write them themseves
00:22:43 <startling> *yourself
00:22:47 <ReinH> DanC: +1, although we don't have "monads that should also have fail" as the type that do notation operates under
00:22:49 <Cale> dfeuer: Did you try psqueue?
00:22:56 <dfeuer> And 3. I realized that using separate keys /efficiently/ in an STArray-based heap would almost certainly require some nasty things like parallel arrays or arrays of STRefs.
00:22:59 <ReinH> so it does sort of serve a purpose. sort of
00:23:01 <ReinH> it's still ugly
00:23:05 <Cale> http://hackage.haskell.org/package/PSQueue-1.1/
00:23:09 <dfeuer> Cale: no, I didn't run into that yet.
00:23:18 <ReinH> startling: I will check that out. Is it easy to demonstrate what you mean in code?
00:23:21 <Cale> Give that a shot, see if it's faster
00:23:24 <Nereid> ReinH: sure we do, MonadPlus
00:23:39 <Nereid> or MonadZero.
00:23:53 <dfeuer> Cale: why would a PSQueue be faster than a PQueue if I don't need searching?
00:23:56 <ReinH> Nereid: meaning that do notation isn't restricted to moands that (should) have fail
00:24:14 <Nereid> mm
00:24:17 <ReinH> do notation a) incorporates fail b) operates over all monads
00:24:21 <Cale> dfeuer: Because this one is particularly well-thought-out, and I've had good luck with it in the past.
00:24:26 <ReinH> that was my point
00:24:35 <Nereid> well of course fail is a bad idea.
00:24:42 <ReinH> so either all monads need to have fail or do notation needs to be more restricted
00:24:47 <ReinH> or fail needs to go away entirely
00:25:04 <Cale> dfeuer: It's likely that there's a plain priority queue which can do better, but I have no experience with pqueue, so this will give me a baseline :)
00:25:09 <dfeuer> Cale: I can give it a shot, but at this point I also just want to see if I /can/ implement an efficient STArray-based binary heap in Haskell.....
00:25:23 <ReinH> startling: so the point is that I can just derive Monad and Functor for my newtype Square, right?
00:25:41 <Cale> It's probably possible, but almost anything in ST is going to be a bit ugly
00:26:13 <ReinH> startling: newtype Square = Empty | Occupied a deriving (Monad Functor) ?
00:26:18 <startling> ReinH: oh wait, I'm mistaken
00:26:29 <shachaf> ReinH: GHC can probably autoderive Functor, but I doubt it can do Monad.
00:26:30 <frerich> ReinH: I'm not a terribly experienced Haskell developer, so take this with a grain of salt - but I think your code suffers a bit from having 'Maybe' propagated through the code. It seems to me that the only place where the 'Nothing' case of Square is needed is when turning a character into a Square. So one thing you could do is to verify that the given String passed to readBoard contains only valid characters up front.
00:26:36 <startling> well, not very mistaken. gimme a sec
00:26:43 <shachaf> It could probably do Monad if you did newtype Square a = Square (Maybe a)
00:27:18 <ReinH> frerich: I do, and I return a Left String with the error message from readBoard as soon as it encounters an invalid Char
00:27:23 <startling> ReinH: need a comma there, but yeah
00:27:32 <startling> deriving (Monad, Functor)
00:27:40 <ReinH> startling: yeah woops. It's late :)
00:27:46 <shachaf> Cale: What did you do to L.hs?
00:27:50 <shachaf> > 1 .&. 2
00:27:51 <lambdabot>   Ambiguous occurrence `.&.'
00:27:51 <lambdabot>  It could refer to either `Data.Bits..&.', impor...
00:27:51 <Cale> shachaf: ?
00:27:55 <Cale> oh
00:27:57 <Cale> errr
00:28:01 <frerich> ReinH: Yes, but the actual error is generated much further down, in readPiece: it has to handle the fact that a 'Char' value can be passed which is not in the list of valid characters.
00:28:20 <frerich> ReinH: And this 'Maybe Piece' the propagates through the whole code, a ripple effect.
00:28:33 <ReinH> frerich: wouldn't it make sense for the function that knows about reading pieces from characters to also know about which characters are valid?
00:28:39 <Cale> shachaf: I imported QuickCheck...
00:28:43 <Cale> > 1 .&. 2
00:28:43 <ReinH> frerich: no, it propagates through the code for unsafely reading things from strings
00:28:45 <lambdabot>   Ambiguous type variable `a' in the constraint:
00:28:45 <lambdabot>    `Data.Bits.Bits a'
00:28:45 <lambdabot>      a...
00:28:48 <ReinH> which is where I want it to propagate
00:28:49 <Cale> > 1 .&. 2 :: Integer
00:28:50 <frerich> ReinH: Yes, but how about giving it a proper type in the first place.
00:28:51 <lambdabot>   0
00:28:57 <ReinH> frerich: "it"?
00:28:59 <frerich> ReinH: I.e. not "Char", but only a type which allows valid cahracters.
00:29:00 <shachaf> Cale: Hmph. It's ruining my code golf.
00:29:04 <shachaf> > (!!1)<$>transpose[show$sum[100^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
00:29:04 <frerich> ReinH: "readPiece"
00:29:05 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
00:29:11 <shachaf> Oh, wait, it's working.
00:29:22 <shachaf> Did you change something?
00:29:27 <Cale> Yeah, I dropped the import of QuickCheck stuff
00:29:32 <shachaf> Ah, great.
00:29:33 <shachaf> Thanks!
00:29:35 <ReinH> frerich: what would that type look like?
00:30:07 <ReinH> frerich: and what would I do when it reads a char that is not a ValidPieceChar (or w/e)
00:30:13 <frerich> ReinH: It could be anything which is convenient, maybe a 'newtype PieceSymbol = PieceSymbol Char'.
00:30:27 <ReinH> frerich: how specifically would I encode the notion of "valid character" into the type?
00:30:27 <frerich> ReinH: The idea is to do this checking much earlier
00:30:58 <ReinH> frerich: I do the checking at the moment a character is read. How can I do it earlier than that?
00:31:18 <frerich> ReinH: No, you do the checking at the moment a Piece is constructed, or not.
00:31:46 <ReinH> specifically I do the checking at the moment the character is looked up in the AL of (Char, PType)
00:32:23 <frerich> ReinH: For instance, as a quick sample, you could have a "all (`elem` validChars) s" in your "readBoard" function.
00:32:45 <frerich> ReinH: So if the entire board consists of valid chars, you proceed (and you don't need "Maybe" anymore), if the board has at least one invalid character, you return an error.
00:32:46 <ReinH> I could, but to what end? I would still need to check again in readPiece
00:33:01 <ReinH> unless you're happy with readPiece being a partial function
00:33:03 <frerich> ReinH: I think you could either assert() or use a better type.
00:33:10 <ReinH> which is the reason i changed it in the first place
00:33:51 <ReinH> again, how would I encode the notion of a valid character into the type?
00:34:54 <ReinH> An assert is just a (slightly) kinder exception, which still results in a partial function unless you think AssertionFailed expections are part of the range of a function from Char -> Piece
00:34:56 <frerich> ReinH: You could have a "newtype PieceSymbol = PieceSymbol Char" and then "makePieceSymbol Char = ..." - and *this* function could error out if you like. Or be partial. Or you could do this checking inr readPiece itself.
00:35:15 <frerich> ReinH: The whole point is to weed out invalid boards at a much earlier stage so that Maybe doesn't propagate so far.
00:35:25 <ReinH> so you're suggesting that I replace Maybe, a monad designed to encode the notion of a computation that may fail, with assert
00:35:36 <ReinH> so that I can encode the notion of acomputation that may fail by raising an expection instead
00:35:42 <frerich> No, I'm not suggesting to *replacE* Maybe.
00:35:45 <frerich> I'm suggesting to *move* it.
00:35:46 <ReinH> which is exactly what my partial function did
00:36:25 <ReinH> readPiece :: Char -> Maybe Piece is exactly where I want a Maybe
00:36:29 <ReinH> rather than an exception
00:36:33 <frerich> I think your code would benefit from 'readPiece' not returning a Maybe in the first piece. So my suggestion is to either disallow passing invalid characters to it, or to assert() in readPiece but only let *readBoard* return a Maybe.
00:36:44 <frerich> err, in the first place.
00:36:54 <startling> frerich: why?
00:37:05 <ReinH> I don't understand how I can obtain a)
00:37:33 <ReinH> Obtaining (b) only reduces the locality of my code by putting the check for character validness and the function that needs to use it in different places
00:37:34 <frerich> startling: Because as it is, the entire code dealing with Squares has to be prepared for 'invalid' squares.
00:37:47 <ReinH> frerich: no
00:38:04 <frerich> ReinH: Case in point: 'showSquare' has to have a 'maybe' call.
00:38:07 <ReinH> the entire code dealing with *reading unsafe things* is wrapped in the monad used for *dealing with unsafe things*
00:38:22 <ReinH> (a monad)
00:38:35 <startling> frerich: you mean Nothing?
00:38:42 <frerich> startling: Yep
00:38:45 <ReinH> what I don't want is for readPiece to be a partial function from Char to Piece that depends on some other check in a different part of the code
00:38:50 <ReinH> that's exactly what I don't want
00:38:51 <startling> he should just write a makeBoard function and then lift it
00:39:15 <ReinH> startling: when I move the code out into modules I won't be exporting readPiece
00:39:16 <startling> frerich, isn't that what lift and >>= and so on are for?
00:39:17 <ReinH> just readBoard
00:39:26 <startling> ReinH: why not? readPiece could be useful
00:39:33 <frerich> ReinH: Unfortunately (?) I'm at work so I've got to do something which I'm paid for now, pity that I didn't managed to get my point across though. I still think that you would benefit from not using 'Maybe' so much. :-)
00:39:36 <ReinH> startling: well, I could, but I won't be using it
00:39:47 <startling> k
00:40:03 <ReinH> If this were written in do notation that hid the monadic nature I suspect the problem would just go away
00:40:24 <shachaf> "do notation that hid the monadic nature"?
00:40:28 <shachaf> do notation does the opposite of that.
00:40:46 <ReinH> shachaf: sorry, that exposes the monatic nature but hides the passing around of maybies and justs and fmaps?
00:40:58 <dfeuer> Cale: a k-way merge shouldn't really have to do any allocations at all, except at the beginning, but /any/ purely functional implementation will drop garbage on every update. For a 100-way merge, that's ~6.6 pieces of garbage per element.
00:41:02 <ReinH> that hides the trappings of monadic code and exposes the actual monadic nature?
00:41:10 <ReinH> I think maybe you know what I was trying to say?
00:41:28 <ReinH> (monad pun not intended)
00:42:25 <dfeuer> Cale: well, any except one that finds the minimum by a linear search.
00:42:32 <ReinH> as far as I understand it, the whole purpose of the Maybe monad is to thread the notion of "computation that may fail" through code that may be the result of a computation that fails
00:42:37 <ReinH> am I wrong?
00:42:41 <startling> maybe you meant either your reader will return a list or just nothing
00:43:00 <startling> :P
00:43:02 <ReinH> I want to make my code better but I honestly don't understand how using an assert or a guard in readBoard that makes readPiece a partial function is an improvement
00:43:18 <Cale> dfeuer: The important thing isn't whether you're doing allocations, it's whether your program is fast enough. The allocations take some time and space, but without profiling, it's hard to say that this is relevant :)
00:43:20 <startling> ReinH: yeah, I don't understand what he's saying either
00:43:51 <ReinH> as far as I see it you're just moving from correctness from the composition of correct things to correctness through the ad hoc correction of errors introduces through composition
00:43:59 <ReinH> *introduced
00:44:14 <ReinH> if readPiece is a partial function then it's incorrect, and it's harder to read about code when part of it is objectively incorrect
00:44:21 <ReinH> nonlocality etc
00:44:33 <dfeuer> Cale: switching to PSQueue looks like it would take some significant modification to my program, so I haven't tried it yet. But my profiling of the version using PQueue.Prio suggests that the priority queue is the main bottleneck.
00:44:35 <sopvop> So, is anyone here knowledgeable about Control.Lens.Iso?
00:45:43 <ReinH> startling: so having seen my code and hopefully groking my intent, would you be happy with the way I use Maybe and Either in the read* family of functions?
00:46:00 <ReinH> would it pass a code review?
00:46:04 <dfeuer> Cale: I would like very much to try using Data.Pqueue.Min instead of Data.Pqueue.Prio.Min, but I can't do that because that package has an Ord constraint I cannot satisfy.
00:46:43 <startling> ReinH: sure
00:46:54 <ReinH> startling: any suggestions?
00:46:57 <startling> I'd expect readWhatever functions to be String -> Maybe Whatever
00:47:11 <ReinH> rather than Char for readPiece?
00:47:21 <ReinH> or rather than Either?
00:47:34 <rosie> how do I pattern match on an array that contains only one element?
00:47:50 <shachaf> rosie: Are you sure you mean array?
00:47:51 <dfeuer> rosie: why would you have an array with only one element?
00:47:52 <rosie> that is, I want to distinguish between an input that is an array of five elements and an input of one element
00:47:56 <rosie> sorry, a list
00:47:59 <shachaf> Ah.
00:48:02 <shachaf> foo [x] = ...
00:48:09 <shachaf> Just like you make a list with one element. :-)
00:48:46 <ReinH> startling: or are you referring to making Whatevers match? or any of the above? ;)
00:49:28 <rosie> ah, of course! my apologies
00:50:24 <dfeuer> Night, all.
00:50:30 <shachaf> rosie: You can also use foo (x:[]) = ...
00:50:38 <shachaf> Which matches on the constructor directly.
00:53:13 <startling> ReinH, oh, yeah, Char makes sense for you. Just saying you're doing things how I'd expect them. :)
00:53:20 <rosie> shachaf: cool, thanks
00:53:47 <ReinH> startling: ty!
00:53:49 <ReinH> ok I'm off
00:54:00 * ReinH &
00:54:14 <Palmik> Does anyone here have a sample .vimrc that utilises vim2hs, ghcmod-vim, neco-ghc. I'm using vundle and after I have installed ghcmod-vim and neco-ghc (with their dependencies), it's as if every other bundle stopped working. This is my ~/.vimrc http://hpaste.org/72829 I did not change any settings of the used bundles yet.
00:54:30 <ReinH> Palmik: use pathogen
00:54:37 <shachaf> rosie: (Are you at Stanford? You should go to bahaskell next week!)
00:54:45 <ReinH> Palmik: I'm using haskellmode-vim, ghcmod-vim and neco-ghc in my Haskell Live videos
00:54:58 <rosie> lol how did you know??
00:55:02 <Palmik> ReinH, do you think that is the issue here or is that just yur preference over vundle?
00:55:17 <Palmik> s/yur/your/
00:55:49 <ReinH> Palmik: I trust tpope (author of pathogen and rails.vim and surround.vim and etc) more than anyone else who writes vim plugins
00:56:03 <ReinH> I don't know if it's your issue, but I'd be willing to be good money that pathogen works better than vundle
00:56:16 <ReinH> I also know that installing those plugins with pathogen Just Worked for me
00:57:25 <ReinH> and also that ghc-mod and neco-ghs are awesome, especially with syntastic
00:57:33 <Palmik> OK, I will try it out then, thanks.
00:57:52 <ReinH> Palmik: if still no luck try #vim, and try an empty .vimrc
00:58:07 <ReinH> if empty .vimrc works, binary search your .vimrc by removing half the file, then half of the half that was broken, etc
00:58:36 <ReinH> (obv break it apart in valid places ;)
00:59:14 <ReinH> ok seriously leaving :)
00:59:19 * ReinH sudo &
00:59:36 <rosie> shachaf: I'm curious!
00:59:43 <shachaf> rosie: ?
01:00:14 <rosie> shachaf: How do you know I'm at Stanford?
01:00:18 <shachaf> 00:47 -!- rosie [~rose@DNab42c4c9.Stanford.EDU] has joined #haskell
01:00:27 <rosie> haha
01:00:32 <rosie> are you on campus too?
01:00:40 <shachaf> Nope.
01:00:43 <shachaf> I live in Palo Alto, though.
01:00:48 <rosie> where do you work?
01:00:51 <rosie> just curious
01:01:25 <shachaf> Not anywhere, at the moment!
01:01:27 <shachaf> I worked in Mountain View in the past.
01:01:39 <Palmik> ReinH, is you .vimrc available somewhere by any chance?
01:01:40 <rosie> sounds fun!
01:01:56 <ReinH> Palmik: I thought I said I was sudo leaving ;) Yes, but it's out of date since I added this stuff :(
01:02:22 <ReinH> I haven't been committing like I should; I'm such a poor gardener of my ~ :(
01:02:26 <shachaf> Anyway, bahaskell is usually on the third Wednesday of the month, either in SF or Mountain View.
01:02:31 <shachaf> People in the area should go!
01:02:43 <rosie> shachaf: are you going next week?
01:02:47 <Palmik> OK, did not see that, you should have just ignored me then. :D
01:02:57 <shachaf> Probably!
01:04:29 <shachaf> rosie: (Are you learning Haskell in a class? I know they did cs240h last year but I don't know if that's still going on.)
01:05:23 <rosie> I checked and it's not offered this year. Just learning with a friend cuz it looks cool and I may want to do some research at Stanford that involves Haskell
01:05:57 <shachaf> Ah, neat.
01:06:25 <shachaf> I know a few people who were in that class. It seemed quite good.
01:07:27 <rosie> shachaf: I gotta learn Haskell well before I come to a bahaskell, but thanks for the heads up! I may see you in the future
01:08:18 <shachaf> rosie: A lot of the people there are beginners. You should come!
01:08:26 * shachaf is always encouraging people to go.
01:09:23 <rosie> Thanks, I appreciate the invite (:
01:17:43 <b__> I want to create a type (or type synonym) consisting of numbers within a certain range
01:17:46 <b__> is that possible?
01:18:08 <b__> basically [1..n]
01:18:17 <b__> where n is the maxBound
01:19:34 <opqdonut> yes and no
01:19:55 <dylukes> How would I unregister *all* packages from ghc?
01:19:55 <startling> b__: kind of.
01:20:14 <opqdonut> b__: there's only an ugly way to make that completely safe: data MyNum = One | Two | Three | ... | HundredOne
01:20:26 <pharaun> i would be interested in a such thing too but for me its between a known bound
01:20:28 <startling> b__: what you're asking about is possible with dependent typing, which haskell doesn't have
01:20:35 <pharaun> ah :\
01:20:36 <opqdonut> b__: but having "newtype MyNum = MyNum Int" and not exposing the MyNum constructor is  a working solution
01:20:47 <opqdonut> startling: it's not dependent if n is known compile-time
01:20:52 <startling> b__: but you can encode it into the type system like they're saying ^
01:20:58 <b__> hm okay
01:21:04 <pharaun> in my case N would be known compile-time
01:21:08 <frerich> b__: What I did in the past is to define a 'newtype MyIntLowerThan100 = MyIntLowerThan100 Int' in a separate module an then not export it's constructor. Instead, export a 'makeMyInt :: Int -> MyIntLowerThan100' which did the checkign at runtime.
01:21:09 <startling> opqdonut: sure. but it's possible with dependent typing (and i'd say easier)
01:21:11 <opqdonut> b__: this latter technique is known as "smart constructors"
01:21:23 <pharaun> opqdonut: the ones i've seen is exporting a custom constructor and having it fail if it falls outside bounds
01:21:27 <opqdonut> http://www.haskell.org/haskellwiki/Smart_constructors
01:21:31 <opqdonut> pharaun: indeed
01:21:35 <opqdonut> that's the standard solution
01:21:43 <pharaun> however i do wonder bout pattern matching with that
01:21:51 <b__> interesting :}
01:21:56 <startling> pharaun: just make it a Num
01:22:02 <pharaun> like if i wanted to pattern match on - 10, 11, 12...
01:22:06 <Nereid> startling: then what would 100 + 2 be?
01:22:09 <pharaun> startling: oh if i did it as Num it would... ?
01:22:11 <Nereid> if n = 101.
01:22:12 <Nereid> or so.
01:22:14 <startling> oh
01:22:15 <startling> right
01:22:35 <startling> man, haskell should have different types for addition and "readable from a numeric literal"
01:22:36 <pharaun> can i only drag out the pattern matching out of num?
01:22:41 <frerich> opqdonut: Interesting, I didn't know there's a conventional name for it.
01:22:47 <frerich> opqdonut: Thanks for pointing this out!
01:22:56 <b__> I basically want: data Type = 1 | 2 | 3 | 4 | 5 | 6
01:23:10 <b__> but I'll have a look at the wiki page you linked
01:23:27 <Nereid> can't you do something with a Nat kind or so
01:23:35 <pharaun> Nereid: so there's no way to get nice pattern matching without dragging in the addition/etc via Num ?
01:23:47 <Nereid> pharaun: just make a function MyNum -> Int or so
01:24:07 <startling> obvious solution: encode sk combinators into the type system
01:24:10 <pharaun> oh... that would work
01:24:12 <startling> and then write all your code in that
01:24:16 <pharaun> at least for my application
01:24:21 <pharaun> sk ?
01:24:24 <Nereid> and maybe Int -> Maybe MyNum going the other way
01:24:36 <Nereid> (or generalize Int to any Num type)
01:24:42 <Nereid> (well, not quite for the latter)
01:25:31 <b__> wouldn't a compiler be able to optimise a lot with dependent typing?
01:25:58 <Nereid> in the compiled program, the type information all disappears
01:26:02 <Nereid> at least, I think that's what happens
01:26:10 <startling> not necessarily with dependent typing
01:26:13 <Nereid> no
01:26:16 <dylukes> Nereid: A function MyNum -> Int can be from deriving Enum
01:26:21 <dylukes> then use fromEnum.
01:26:23 <Nereid> sure
01:26:59 <startling> can anyone think of a catchy name for my stupid Lengthable typeclass?
01:27:10 <dylukes> Lengthable?
01:27:40 <startling> dylukes: things of kind * on which a length function can work
01:27:55 <Nereid> yes, so how about "Lenghtable"?
01:27:57 <pharaun> iteratable?
01:28:00 <dylukes> So more generally, things of kind * with cardinality :P
01:28:01 <Nereid> htththth
01:28:17 <dylukes> "length", "size"… just some dimension?
01:28:30 <Nereid> Sizable ;)
01:28:40 <startling> yep. It's really useful for my code to be able to work on both ByteStrings and [a] and so on
01:28:45 <pharaun> YouHaveBeenSized ?
01:28:46 <dylukes> I would say Countable but that… has so much mathematical baggage...
01:28:50 <startling> dylukes: heh
01:28:57 <dylukes> that Georg Cantor would climb from his grave to beat you over the head for using it.
01:29:27 <dylukes> Measurable?
01:29:28 <shachaf> dylukes: What's with adding "able" to the end of type classes?
01:29:33 <dylukes> heh
01:29:35 <startling> dylukes: ooh, I like Measurable
01:29:36 <shachaf> It's not called Showable or Readable.
01:29:42 <startling> that's true
01:29:45 <Nereid> I was thinking about Measurable
01:29:49 <Nereid> but then I thought some more
01:29:52 <startling> just "Length" or "Measure" might work
01:30:05 <shachaf> "Measure" has more baggage than "countable".
01:30:16 <dylukes> shachaf: True enough.
01:30:19 <shachaf> On the other hand why does this even need to be a type class?
01:30:33 <Nereid> Lengthable doesn't make sense. how about Lengthed?
01:30:34 <dylukes> startling: oh by the way, what about ListLike?
01:30:48 <dylukes> In response to: "It's really useful for my code to be able to work on both ByteStrings and [a] and so on"
01:31:09 <startling> shachaf: so my data structure can be a monoid in certain circumstances
01:31:24 <startling> and also so my bagful of functions doesn't need to stick to one type
01:31:57 <startling> dylukes: hmm, interesting
01:32:28 <pharaun> iterable?
01:33:33 <startling> pharaun: I feel like iterable would mean something else
01:33:45 <startling> oh, maybe not. hm
01:33:51 <dylukes> As a matter of habit, I *try* to avoid places I'm using the length directly.
01:34:15 <dylukes> there are plenty of places to use it, for sure, but I like thinking of other ways.
01:34:27 <dylukes> Also, length is incompatible with infinite lists.
01:34:49 <neutrino2000> why
01:35:01 <neutrino2000> can't you just use cardinal numbers
01:35:10 <startling> dylukes: sure. but the idea is that this is some bit of code and a list of (Symbol, Integer)s that point to that code
01:35:16 <pharaun> neutrino2000: try counting from 0 to infinity?
01:35:22 <neutrino2000> i did many times
01:35:24 <neutrino2000> and?
01:35:34 <startling> dylukes: so in order to mappend them, I need to offset the second one's symbol list by the length of the first
01:35:35 <b__> are there any ghc extensions that allow enforcing of simple numeric bounds for types?
01:35:46 <neutrino2000> are we still in 4000 BC?
01:35:56 <dylukes> b__: We actually have DataKinds if you want to write length observed vectors or something...
01:36:08 <neutrino2000> because the concept of differently sized infinities is very old
01:36:23 <pharaun> oh i'm aware of those :)
01:36:36 <neutrino2000> then why are you not applying it
01:36:44 <neutrino2000> you have a hammer and a nail and you bang on that nail with your face
01:37:06 <pharaun> i haven't had a need :)
01:37:56 <dylukes> I personally found it very cool that an infinite set can be isomorphic to a proper subset of itself.
01:38:32 <dylukes> ie f(n) = 2n.
01:39:02 <startling> oh, never heard it said like that
01:39:05 <startling> that's pretty cool
01:39:28 <shachaf> That's not an isomorphism. :-)
01:39:36 <shachaf> (It is isomorphic, but that's only one direction.)
01:39:52 <dylukes> f(n) = 2n is invertible.
01:42:41 <Nereid> depends on what n is allowed to be.
01:43:18 <shachaf> Ah, as a function : Z -> evenZ, yes.
01:43:42 <shachaf> As a function : Z -> Z it's not, but I suppose that's not what you mean.
01:44:40 <dylukes> "isomorphic to a proper subset of itself."
01:45:27 <startling> it works for R -> R, doesn't it?
01:45:45 <dylukes> shachaf: N is not a proper subset of N. Neither is Z of Z.
01:46:07 <Nereid> it works for every infinite set
01:46:11 <Nereid> (assuming the axiom of choice)
01:46:28 <Nereid> (or is choice required for the converse, I forget)
01:47:01 <Nereid> hmm.
01:47:16 <Nereid> is there an infinite group that is not isomorphic to any proper subgroup of itself?
01:47:40 <Nereid> hmm, does Q/Z do it?
01:48:06 <Nereid> sure it does.
01:48:08 <Nereid> ok
01:48:11 <dylukes> I'm gonna play shachaf for a moment.
01:48:20 <dylukes> -> #haskell-in-depth / #haskell-blah
01:48:36 <Nereid> doesn't have much to do with haskell, really :>
01:48:53 <Taneb> There's a #haskell-in-depth channel!?
01:48:57 <dylukes> It's really not that we try to scare newcomers… We just get sidelined so easily.
01:49:12 <dylukes> If only they knew we're not mean, just easily distracted.
01:49:36 <Nereid> now that it's a different time, I can ask again, I guess.
01:49:43 <Nereid> are there any useful monads in haskell for which join is an isomorphism?
01:49:51 <Nereid> s/useful/interesting/
01:50:01 <shachaf> Nereid: By which you mean "not Identity/Null"?
01:50:08 <Nereid> those are not interesting
01:50:29 <shachaf> I *think* join will lose information for any nontrivial monad.
01:50:35 <Nereid> because
01:50:39 <Nereid> there are on the math side of things
01:50:47 <shachaf> Oh.
01:50:50 <Nereid> localization (of rings) is an example
01:51:02 <Nereid> (or more general kinds of localization)
01:51:13 <Nereid> I guess
01:51:22 <Nereid> any monoid for which its product is an isomorphism will do
01:51:23 <dylukes> I mean, theoretically you could stick some extra phantom types in to restore the original order…
01:51:27 <dylukes> without breaking the monad laws...
01:51:52 <dylukes> Or if you had some ordering property you could use to invert.
01:52:02 <shachaf> Any monoid for which its product is an isomorphism?
01:52:25 <Nereid> @type uncurry mappend
01:52:26 <lambdabot> forall a. (Monoid a) => (a, a) -> a
01:52:28 <Nereid> ^ this function
01:52:40 <shachaf> If you have such a Monoid, then Writer ThatMonoid?
01:52:43 <Nereid> yes
01:53:02 <shachaf> But are there any interesting monoids with that property?
01:53:07 <Nereid> good question!
01:53:23 <shachaf> Writer () ~ Identity, of course.
01:53:31 <Nereid> boring. :P
01:53:48 <Taneb> Fix WriterT? I have no idea if that's a thing
01:54:08 <Nereid> oh dear, I don't want to think about that.
01:54:14 <int-e> Nereid: but how do you know whether an 'a' value is that value or has to be decomposed further into a pair?
01:54:16 <Nereid> could be, though.
01:54:23 <Nereid> int-e: "has to"?
01:54:57 <int-e> Nereid: how do you distinguish  tell a; tell b from tell (a,b)?
01:55:22 <Nereid> int-e: type error
01:55:26 <shachaf> int-e: Easy: One of them type-checks. :-)
01:55:39 <Nereid> I guess we might not have such interesting things in haskell
01:55:44 <Nereid> since the monoidal product is cartesian product
01:55:58 <dylukes> Mu WriterT...
01:56:00 <dylukes> o.0
01:56:08 <Nereid> whereas, say, in abelian groups (with monoidal product = tensor product), multiplication Q (x) Q -> Q is an isomorphism, say
01:56:23 <Nereid> (making Q (x) - a monad for which join is an isomorphism)
01:56:27 <int-e> Nereid: (a,b) = a `mappend` b, modulo your isomorphism. ;)
01:56:34 <Nereid> int-e: obviously.
01:57:08 <dylukes> Hrm… I keep bouncing between different webservers on heroku.
01:57:23 <int-e> Nereid: I guess I'm fuzzy about what kind of loss of information you and shachaf are talking about.
01:57:29 <Nereid> no one's talking about loss of information.
01:57:31 <dylukes> I'm really just not ever happy with any webserver because I don
01:57:45 <dylukes> 't really feel comfortable in any commonly used web languages except Ruby and Erlang.
01:57:45 <shachaf> Nereid: I did!
01:57:56 <Nereid> int-e: anyway, you should know that tell a >> tell b = tell (a `mappend` b)
01:58:00 <dylukes> And I don't like rails, and Erlang's main perks are quashed on Heroku.
01:58:04 <Nereid> so you don't distinguish them
01:58:18 <startling> dylukes, ever used python + wsgi?
01:58:28 <dylukes> No, I haven't.
01:58:40 <dylukes> I've never really liked python as much as ruby.
01:58:40 <Taneb> Is data Fix m a = Fix (m (Fix m) a) useful?
01:58:50 <dylukes> @src Mu
01:58:51 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
01:58:54 <shachaf> dylukes: I'm going to play dylukes for a moment.
01:58:57 <Taneb> :k Mu
01:58:58 <shachaf> I'm gonna play shachaf for a moment.
01:58:59 <lambdabot> (* -> *) -> *
01:59:01 <shachaf> -> #haskell-blah
01:59:04 <dylukes> @src Free
01:59:04 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:59:20 <Taneb> data Free f a = Pure a | Free (f (Free f a))
01:59:21 <dylukes> Taneb: yes, that type is useful, slightly modified
01:59:26 <dylukes> yeah
01:59:28 <dylukes> beat me to it.
01:59:43 <dylukes> Free is Fix with a terminal.
01:59:48 <Taneb> It looks interesting, but I have no idea how to use it.
02:00:02 <dylukes> Here, one moment...
02:00:31 <Taneb> My Fix :: ((* -> *) -> * -> *) -> * -> *
02:00:52 <Taneb> It takes a monad transformer (or similar) and a type, and returns a type.
02:01:05 <Nereid> why not (* -> *) -> *?
02:01:08 <typoclass> > fix ("* -> " ++)
02:01:11 <Nereid> er oops.
02:01:11 <lambdabot>   "* -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * ->...
02:01:14 <Nereid> (k -> k) -> k
02:01:46 <kgzm> fix (a -> b)
02:01:48 <Taneb> Because it forces m to be (* -> *) -> * -> *
02:01:56 <dylukes> Taneb: http://hackage.haskell.org/packages/archive/transformers-free/1.0.0/doc/html/Control-Monad-Trans-Free.html
02:02:00 <dylukes> the example here is enlightening.
02:02:02 <Nereid> so let k = * -> *
02:02:23 <dylukes> follow it to its conclusion and you end up with types like
02:02:23 <dylukes> type Pipe a b m i i' o o' r = IFreeT (PipeF a b) (U m) (r := (i', o')) (i, o)
02:02:30 <kgzm> er, what exactly is that lambdabot?
02:02:37 <dylukes> @nixon
02:02:38 <lambdabot> Sure there are dishonest men in local government. But there are dishonest men in national government too.
02:02:45 <dylukes> Richard Nixon's brain in a jar, kgzm.
02:03:03 <dylukes> We taught him Haskell.
02:03:12 <shachaf> lambdabot is a robot that plays Half-Life.
02:03:26 <dylukes> RoboNixon*
02:04:06 <startling> @faq what exactly is that lambdabot?
02:04:07 <lambdabot> The answer is: Yes! Haskell can do that.
02:04:11 <startling> ^ see?
02:04:25 <dylukes> Okay guys let's not be asshats.
02:04:44 <dylukes> kgzm: It's a bot that evaluates a subset of Haskell, along with some other functions like quoting, looking up packages, etc.
02:04:54 <typoclass> kgzm: lambdabot is a program accessible from a few irc channels which does various things for us, mostly run haskell statements ("> ") and remember quotes and stuff
02:04:59 <typoclass> > 1 + 42
02:05:00 <lambdabot>   43
02:05:12 <Nereid> @type fmap fmap fmap
02:05:14 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:05:18 <Taneb> It's more a of a slight Haskell variant than a subset of Haskell, I think
02:05:20 <Taneb> :t (.)
02:05:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:05:22 <dylukes> But it has… Caleskell. (Cale's version of Haskell)
02:05:26 <dylukes> @src (.)
02:05:27 <lambdabot> (f . g) x = f (g x)
02:05:27 <lambdabot> NB: In lambdabot,  (.) = fmap
02:05:30 <dylukes> ^
02:05:39 <Nereid> @src id
02:05:40 <lambdabot> id x = x
02:05:44 <startling> @src (++)
02:05:45 <lambdabot> []     ++ ys = ys
02:05:45 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
02:05:45 <lambdabot> -- OR
02:05:45 <lambdabot> xs ++ ys = foldr (:) ys xs
02:05:53 <Taneb> :t id . [1,2,3,4]
02:05:53 <Nereid> @type (++)
02:05:54 <lambdabot> forall a. (Num a) => [a]
02:05:55 <lambdabot> forall m. (Monoid m) => m -> m -> m
02:05:56 <Taneb> id . [1,2,3,4]
02:06:01 <Taneb> > id . [1,2,3,4]
02:06:03 <lambdabot>   [1,2,3,4]
02:06:14 <startling> Cale: (++) isn't worth a nota bene?
02:06:16 <Nereid> > (+2) > [1,2,3]
02:06:17 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
02:06:20 <Nereid> > (+2) . [1,2,3]
02:06:23 <lambdabot>   [3,4,5]
02:06:38 <Nereid> > [1,2,3] . [5,6]
02:06:39 <kgzm> Ah, interesting.
02:06:39 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
02:06:42 <Nereid> aw.
02:06:48 <Nereid> > (*) . [1,2,3] . [5,6]
02:06:49 <lambdabot>   Couldn't match expected type `a1 -> a' against inferred type `[a2]'
02:06:52 <Nereid> blah.
02:06:53 <Nereid> forget it.
02:07:08 <startling> > [1, 2, 3] <*> [5, 6]
02:07:09 <kgzm> Do you use it to resolve debates?
02:07:09 <lambdabot>   [1,1,2,2,3,3]
02:07:12 <Cale> startling: it probably is, but I'm working for 5 more minutes and then sleep
02:07:12 <startling> ???
02:07:20 <startling> Cale: heh, alright
02:12:28 <Taneb> > (*) . [1, 2, 3] <*> [5, 6]
02:12:30 <lambdabot>   [5,6,10,12,15,18]
02:12:42 <Taneb> startling, lambdabot can treat numbers as functions
02:12:51 <dylukes> > 1 2
02:12:52 <lambdabot>   1
02:12:57 <Taneb> > 1 'a'
02:12:57 <dylukes> > 2 1
02:12:58 <lambdabot>   1
02:12:58 <lambdabot>   can't find file: L.hs
02:13:05 <Taneb> :)
02:13:25 <dylukes> Taneb: er, you have it backwards.
02:13:30 <dylukes> (* 1) has a Num instance in lambdabot.
02:13:40 <dylukes> > (* 1) + (* 2) $ 5
02:13:41 <lambdabot>   15
02:13:55 <Taneb> Which means the same as what I said
02:14:12 <Taneb> :t 1 :: Int -> Int
02:14:14 <lambdabot> Int -> Int
02:14:22 <Taneb> > 2 6
02:14:24 <lambdabot>   2
02:14:27 <dylukes> :t 1
02:14:28 <lambdabot> forall t. (Num t) => t
02:16:00 <Taneb> Well, I think it's time to reinstall Haskell...
02:16:29 <Taneb> My cabal docs page is getting cluttered with modules I'm never going to use
02:17:16 <lambdas> Still not much going when it comes to uninstalling cabal packages?
02:17:24 <Taneb> Nah
02:17:32 <dylukes> http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
02:17:34 <Taneb> I'm deleting everything and installing what I wanted
02:19:02 <lambdas> dylukes: I don't think I said it was. But does that mean that there can't be a package manager for Haskell?
02:19:58 <lambdas> (reading)
02:24:44 <lambdas> Okay, that all makes sense. Cheers.
02:35:26 <startling> @pl (\a, b -> a + 1)
02:35:26 <lambdabot> (1 +) . fst
02:35:33 <startling> @pl (\a b -> a + 1)
02:35:34 <lambdabot> const . (1 +)
02:35:47 <startling> @pl (\a b -> b + 1)
02:35:48 <lambdabot> const (1 +)
02:37:37 <Palmik> Hmm, syntastic reports "not in scope" errors even though the types/functions are imported (from the project's module)... is there a way to circumvent this?
02:38:37 <olegi> @djinn
02:38:37 <lambdabot> Cannot parse command
02:39:05 <olegi> @djinn a -> b -> a
02:39:06 <lambdabot> f a _ = a
02:40:52 <olegi> @djinn (a -> b) -> ((a -> b) -> b) -> b
02:40:52 <lambdabot> f a b = b a
02:42:27 <startling> @src flip
02:42:28 <lambdabot> flip f x y = f y x
02:44:03 <Nereid> @type flip
02:44:05 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
02:45:00 <Nereid> @type \x y -> fmap ($ y) x
02:45:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
02:45:04 <Nereid> @pl \x y -> fmap ($ y) x
02:45:05 <lambdabot> flip (fmap . flip id)
02:48:14 <asda8> hi, I'm trying to parse a csv-like format with parsec. the problem is, that it has escaped newlines inside cells which look like this: "\r\\\n"
02:49:08 <asda8> I'm using an approach like the csv-parser in real world haskell (http://book.realworldhaskell.org/read/using-parsec.html) under the section lookahead
02:49:46 <asda8> but don't know how I could extend it to match these escaped newlines
02:50:18 <asda8> since noneOf only accepts chars and not strings
02:51:58 <asda8> is there a version of noneOf, which takes a list of parsers instead of chars?
02:52:08 <mjga> asda8: maybe you need separate production for escaped cells, e.g.: '"' then noneOf ['"'], and then again '"'
02:52:41 <asda8> mjga: my cells are not quoted, so sadly no
02:53:08 <mjga> asda8: how do you make your grammar unambiguous then?
02:53:43 <asda8> mjga: separators and newlines are escaped inside cells
02:54:17 <lambdas> asda8: Could you use lookahead with a parser that fails for every possibility you want to avoid?
02:55:47 <asda8> lambdas: I was thinking the same, but don't know how to express it: a cell is anything except a newline (except when it is escaped) or a separator (except when it is escaped)
02:56:11 <mjga> asda8: so maybe something like: many ((noneOf ",\n\r") <|> (string "\r\\\n")). E.g. include escape character in noneOf, and then add alternative for escaped
02:57:05 <asda8> mjga: thanks, I'll try this approach
02:57:06 <lambdas> lookahead ((string "\\n" <|> string ""\\r") >> mzero) <|> ... ?
02:58:12 <lambdas> Well something like that.
02:58:13 <asda8> lambdas: interesting
02:58:22 <lambdas> I don't think that works.
03:01:11 <lambdas> Maybe try: lookAhead (((string "\\n" <|> string ""\\r") >> mzero) <|> return ())
03:01:11 <lambdas>  
03:02:38 <lambdas> I don't think you're going to get a nice analogue for noneOf.
03:14:24 <asda8> this seems to work: cell = many ((noneOf "|\n\r") <|> ((string "\r\\\n") >> return '\n'))
03:23:30 <Yuu-chan> Could someone please explain the lambda cube?
03:24:43 <t7> Yuu-chan: 3 options
03:24:46 <Yuu-chan> I don't get why Haskell 98 implements only System F (?2)
03:25:24 <t7> Yuu-chan: haskell is like system f omega
03:25:44 <companion_cube> Yuu-chan: to keep type inference decidable, I think
03:26:51 <Yuu-chan> F omega is "Types depending on types, or type operators", right? Aren't multiparameterized types (like data Either a b) the type operators?
03:26:59 <t7> yes
03:27:34 <t7> :k Either
03:27:35 <lambdabot> * -> * -> *
03:28:09 <Yuu-chan> So why is it said that Haskell 98 supports only System F, not omega? Are there some other restrictions?
03:28:15 <lambdas> asda8: Something like "noneOfP ps = ((msum  [try $ lookAhead p | p <- ps] >> return False) <|> return True) >>= guard" might work more generally, but it's not going to give any good error messages when it encounters one of the ps.
03:29:27 <t7> Yuu-chan: its not full system F because you couldn't do  \(x :: forall a. a) -> x
03:29:36 <lambdas> I thought System F allows for arbitrary rank polymorphism, but no higher-order kinds.
03:29:39 <t7> haskell used let polymorphism instead
03:30:09 <t7> but now you can do seconds order polymorphism as long as you specify the types
03:30:14 <t7> it gets a bit confusing
03:32:47 <Yuu-chan> Hope I'll understand it some time...
03:34:29 * Yuu-chan is reading Wikipedia
03:34:40 <Yuu-chan> "As of 2008, GHC, a Haskell compiler, goes beyond HM, and now uses System F extended with non-syntactic type equality, for example" - what does that mean?
03:36:05 <mm_freak_> Yuu-chan: that means it can prove 5 and 4 + 1 equal on the type level
03:36:17 <companion_cube> using extentionality?
03:36:49 <lambdas> Rewriting?
03:39:48 <mm_freak_> i mean it can prove S (S (S (S (S Z)))) = S (S (S (S Z))) :+: S Z equal
03:41:53 <Yuu-chan> Is it some extension?
03:42:09 <mm_freak_> well, (:+:) is a type family
03:43:26 <mm_freak_> the last time i checked (:+:) had to be defined corecursively, otherwise GHC was unable to establish the equality…  this is a bit sad
03:43:32 <nooodl> something about this code is ugly and i can't figure out how to fix it: http://hpaste.org/72834
03:43:49 <mm_freak_> i.e. works:  type instance S x :+: y = S (x :+: y)
03:43:57 <habyss> can someone help me write foo :: [a -> IO a] -> (a -> IO a) so that foo composes the list of actions into one action?
03:43:59 <mm_freak_> i.e. does not works:  type instance S x :+: y = x :+: S y
03:44:17 <Yuu-chan> :t quot
03:44:19 <lambdabot> forall a. (Integral a) => a -> a -> a
03:44:41 <mm_freak_> nooodl: put the 'let' on the next line
03:45:45 <Yuu-chan> :t foldl1 (>>=) (actions :: [a -> IO a])
03:45:47 <lambdabot> Not in scope: `actions'
03:46:07 <nooodl> :t sequence_
03:46:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
03:46:18 <habyss> :t foldl1 (>>=) (undefined :: [a -> IO a])
03:46:20 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
03:46:20 <lambdabot>     Probable cause: `>>=' is applied to too few arguments
03:46:20 <lambdabot>     In the first argument of `foldl1', namely `(>>=)'
03:46:46 <Yuu-chan> :t foldl1 (>>=) (undefined :: a) (undefined :: [a -> IO a])
03:46:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
03:46:48 <lambdabot>     Probable cause: `>>=' is applied to too few arguments
03:46:48 <lambdabot>     In the first argument of `foldl1', namely `(>>=)'
03:46:52 <nooodl> :t foldl1 (>>=) [putStrLn, putStrLn, putStrLn]
03:46:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
03:46:54 <lambdabot>     Probable cause: `>>=' is applied to too few arguments
03:46:54 <lambdabot>     In the first argument of `foldl1', namely `(>>=)'
03:46:54 <Yuu-chan> :t foldl (>>=) (undefined :: a) (undefined :: [a -> IO a])
03:46:55 <lambdabot> forall b. IO b
03:46:57 <nooodl> huh
03:47:22 <Yuu-chan> :t \a -> foldl (>>=) a (undefined :: [a -> IO a])
03:47:23 <lambdabot> forall b. IO b -> IO b
03:47:27 <Yuu-chan> tadaa
03:47:28 <mm_freak_> habyss: there are multiple ways to do it
03:47:47 <mm_freak_> habyss: one is:  \x -> sequence . map ($ x)
03:48:08 <nooodl> i like that
03:48:11 <fmap> :t flip (foldr (=<<) . return)
03:48:13 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> b -> m b
03:48:16 <mm_freak_> ah, no, that's not even a way
03:48:26 <habyss> I want the output of the first action to be passed to the second action, and so forth
03:48:26 <nooodl> :t \x -> sequence . map ($ x)
03:48:28 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => a1 -> [a1 -> m a] -> m [a]
03:48:39 <nooodl> isn't that just sequence?
03:49:24 <mm_freak_> :t flip (foldM (flip ($)))
03:49:26 <lambdabot> forall a (m :: * -> *). (Monad m) => [a -> m a] -> a -> m a
03:49:30 <mm_freak_> there you go
03:49:37 <mm_freak_> @ habyss
03:50:56 <Yuu-chan> > 10 `quot` 3
03:50:58 <lambdabot>   3
03:51:20 <mm_freak_> nooodl: i like that one much more…  foldM and me have become close friends =)
03:51:24 <Yuu-chan> > map (quot 10) [1..10]
03:51:26 <lambdabot>   [10,5,3,2,2,1,1,1,1,1]
03:51:33 <lambdas> mm_freak_: So it's establishing the equality through rewriting both sides using the standard definition of plus?
03:51:41 <Yuu-chan> > map (div 10) [1..10]
03:51:43 <lambdabot>   [10,5,3,2,2,1,1,1,1,1]
03:51:44 <habyss> mm_freak_: will that take the result of the first action and pass it as to the second action?
03:51:51 <mm_freak_> lambdas: there is no standard definition
03:51:53 <mm_freak_> habyss: yes
03:52:07 <habyss> cool, thanks
03:52:35 <mm_freak_> > flip (foldM (flip ($))) [\x -> Just (x + 1), \x -> Just (2*x)] 5
03:52:38 <lambdabot>   Just 12
03:52:42 <Yuu-chan> :t foldM
03:52:44 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
03:53:06 <habyss> > flip (foldr (=<<) . return) [\x -> Just (x + 1), \x -> Just (2*x)] 5
03:53:08 <lambdabot>   Just 11
03:53:11 <Yuu-chan> Eureka.
03:53:21 <lambdas> mm_freak_: I mean the one you usually get with Peano: x + S(y) = S(x+y)
03:53:36 <mm_freak_> lambdas: the former is that one
03:53:46 <prophile> hey everyone, is this the right place to ask about Cabal issues?
03:53:50 <mm_freak_> the latter is:  S x + y = x + S y
03:54:03 <habyss> > flip (foldl (>>=) . return) [\x -> Just (x + 1), \x -> Just (2*x)] 5
03:54:06 <mm_freak_> prophile: probably, just try
03:54:06 <lambdabot>   Just 12
03:55:00 <prophile> ok, cabal believes it has pandoc installed and it doesn't, trying to force reinstall reveals it has the same mistake about many of pandoc's dependencies. I've removed ~/.cabal completely but the issue persists, is there some other location where information about installed packages is stored?
03:55:28 <eikke> ~/.ghc
03:55:28 <mm_freak_> prophile: the GHC register…  such a problem is usually about versions
03:56:18 <mm_freak_> prophile: probably some package depends on 1.8.* and another depends on 1.9.*
03:56:54 <prophile> mm_freak_: I suspect some hackery of mine may be involved here relating to working around how home directories are mounted on these university machines
03:57:08 <prophile> that is, I created /tmp/cabal and symlinked .cabal into there
03:57:21 <prophile> I assumed that removing it and reinstalling when moving machines would work, it appeared not to
03:57:36 <mm_freak_> prophile: nope, you would need to symlink .ghc, too
03:57:55 <prophile> OK, giving it another shot now
03:58:22 <prophile> ah, grand, this seems to be working
03:58:28 <prophile> thanks muchly mm_freak_ and eikke
03:59:19 <mm_freak_> note that your systems should be as equal as possible…  it will fail, if you have mismatching glibc versions or something like that
03:59:30 <mm_freak_> and the linker errors will be quite strange
04:00:12 <prophile> mm_freak_: they're all indentical builds
04:10:43 <mekeor> hi! =)
04:10:58 * mekeor just learned about the 'until' function in the Prelude.
04:11:31 <Botje> yay! learning!
04:12:17 <t7> :t until
04:12:19 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
04:12:42 <t7> > until (> 10) (+ 1) 0
04:12:44 <lambdabot>   11
04:12:53 * mekeor asks himself whether 'Either a a' is isomorphic to 'a' or to '(a,Bool)'.
04:13:13 <sipa> (a,Bool), i'd sat
04:13:14 <Botje> the second, obviously.
04:13:28 <mekeor> fine.
04:14:28 <sipa> Left a | Right a  -> (False,a) | (True,a)
04:14:37 <mekeor> yup
04:15:01 <mekeor> is there a function 'updateIfElem :: (a -> Bool) -> (a -> a) -> [a] -> Maybe a' which updated those … – WAIT! it's just a map (with an if-expr as function)… oh my god…
04:15:56 <mekeor> mekeor: use 'any' and 'map.
04:16:07 <mekeor> ah, yeah. thanks.
04:18:01 <mekeor> hm, but any+map is actually not as efficient as a function from scratch, i think… :/
04:18:35 <typoclass> mekeor: what do you need 'any' for?
04:18:55 <mekeor> so, i want to update those elements of a list which satisfy a predicate. BUT: i want to know whether it has been updated.
04:19:13 <mekeor> that's why i need "Maybe a" as result in "updateIfElem", or i need "any".
04:20:14 * hackagebot dvda 0.3 - Efficient automatic differentiation and code generation (GregHorn)
04:20:41 <prophile> mekeor: Maybe a or Maybe [a]?
04:20:50 <mekeor> oh, right, sorry.
04:20:55 <mekeor> Maybe [a], of course.
04:21:36 <mekeor> updateIfElem _ _ [] = Nothing; updateFfElem p f (x:xs) | p x = f x : updateIfElem p f xs | otherwise = updateIfElem p f xs -- i think.
04:23:00 <mekeor> oh, i forgot "Just"…
04:23:14 <mekeor> but… erm… err…
04:25:08 <typoclass> mekeor: you could always use fold. personally, i think i'd try "break"
04:27:59 <typoclass> roughly "let case break pred xs of (_, []) -> Nothing ; (unchanged, xs') -> Just $ unchanged ++ map ... xs'" if that makes any sense ...
04:28:16 <typoclass> s/let//  ... :)
04:28:22 <typoclass> time for some coffee
04:28:26 <mekeor> :)
04:35:06 <mekeor> okay, using an advice from c_wraith to make ghc able to optimize it better, i solved it like this: http://hpaste.org/72837
04:35:58 <Botje> .oO(but that's just a fold!)
04:36:39 <mekeor> erm… is it?
04:36:48 <prophile> looks like it
04:37:01 <mekeor> the problem is the "r [] = alternative" case.
04:37:07 <mekeor> , i think.
04:37:32 <Botje> foldr f alternative where f x = if condition x then (update x :) else id
04:37:50 <mekeor> oh! neeeaaat! =)
04:38:04 * Yuu-chan read function name as "yiff"
04:38:13 <Botje> ewww.
04:39:03 <Philippa> aren't excited foxes kinda the definition of impure?
04:39:40 <mekeor> thanks, Botje
04:40:06 <Yuu-chan> Philippa: cuz they try to perform unsafe IO?
04:42:07 <Philippa> Yuu-chan: etc etc. The jokes've kinda been done to death. Much like the foxes, on occasion
04:42:23 <mekeor> Speaking of "pure"… what's its definition?
04:42:33 <typoclass> what's a fox, btw?
04:42:56 <prophile> typoclass: a type of omnivorous mammal belonging to the Canidae family
04:43:19 <typoclass> prophile: that was simultaneously helpful and not
04:43:21 <typoclass> :9
04:43:21 <Yuu-chan> @type fox
04:43:22 <lambdabot> [Char] -> [Char]
04:43:46 <prophile> wat
04:43:53 <mekeor> > fox "foobar"
04:43:55 <lambdabot>   "fox (foobar"
04:44:26 <mekeor> fox = "fox ("++
04:44:31 <typoclass> an excellent function to have. should be in base, if not in Prelude
04:45:00 <Yuu-chan> :t pure
04:45:02 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
04:45:08 <mekeor> yeah, it's very handy and generalizes many other functions.
04:45:45 <mekeor> So, is 'IO' "pure"?
04:45:48 <Yuu-chan> > pure "foo"
04:45:50 <lambdabot>   No instance for (GHC.Show.Show (f [GHC.Types.Char]))
04:45:50 <lambdabot>    arising from a use ...
04:45:59 <typoclass> mekeor: anyway, i'd say a pure function is a function that doesn't have side-effects
04:46:01 <mekeor> > pure "foo" :: Maybe String
04:46:02 <lambdabot>   Just "foo"
04:47:17 <mekeor> typoclass: why is haskell "purely" functional then? – 'cause *functions* can't have side-effects but *monads* can?
04:47:42 <mm_freak_> monads don't have side effects
04:47:46 <mm_freak_> unsafePerformIO has
04:48:01 <Botje> mekeor: monads don't have side effects.
04:48:01 <mekeor> that's exactly what i wanna understand.
04:48:12 <Botje> not even the IO monad.
04:48:13 <Philippa> monads are generally implemented in terms of pure functions
04:48:13 <mm_freak_> mekeor: IO is a recipe language
04:48:25 <Philippa> within the monadic language? Yeah, there are side-effects. But those aren't visible to Haskell
04:48:29 <mekeor> mm_freak_: you're saying IO actions, e.g. putStrLn, don't have side effects, right? why not?
04:48:30 <mm_freak_> mekeor: i.e. a pure description of what you want to happen in the real world
04:48:43 <Botje> mekeor: because they don't.
04:48:43 <mm_freak_> think of a GADT
04:48:51 <Philippa> so the only ones that "count" are IO. Which... is a little bit of a dodge, but less of one than you think. IO isn't evaluated, it's /executed/
04:49:00 <mm_freak_> data IO :: * -> * where PutStrLn :: String -> IO ()
04:49:04 <Philippa> they're two different things, and evaluation is side-effect free
04:49:05 <Yuu-chan> putStrLn :: RealWorld -> String -> RealWorld?
04:49:13 <Philippa> (within the language: obviously you can see the computer whir)
04:49:24 <mm_freak_> Yuu-chan: that's not a good approximation…  it runs into problems and is also not very useful
04:49:39 <sipa> mekeor: IO operations (primitives, return, >>=) only every build up more IO actions, combining smaller ones into larger ones
04:49:46 <sipa> mekeor: but the result is always just an IO action
04:49:54 <mm_freak_> mekeor: you can implement your own version of IO easily, e.g., in terms of the free monad constructor
04:50:01 <sipa> and at that point, nothing stateful has happened
04:50:13 <mm_freak_> mekeor: note how laziness is an integral part of this…  without laziness IO wouldn't be possible
04:50:14 <mekeor> sipa: ah, yeah.
04:50:20 <typoclass> mekeor: you basically use ghc to construct a big IO thingy (starting with main = ...). ghc writes that into a file, and later (when you launch it) the runtime comes along and actually runs the IO. as far as haskell (ghc) was concerned, it was all pure
04:50:25 <typoclass> (not sure if that made sense)
04:50:32 <sipa> it is only when that IO action is returned by main (which can be considered just one huge recipe for the IO action that is your program), it is executed
04:50:38 <Yuu-chan> I read in some blog that "even unsafePerformIO is pure, if called once. The only impure thing is the main function".
04:50:44 <mekeor> sipa: so, at the end, my main-function just is one IO action which discribes how to modify the world.
04:50:51 <sipa> mekeor: in practice, that execution and evaluation happen simultaneously
04:50:53 <sipa> indeed
04:51:04 <mm_freak_> mekeor: 'main' isn't even a function
04:51:09 <mm_freak_> it's just a "recipe" =)
04:51:11 <mekeor> yeah, oops
04:51:20 <mekeor> i see
04:51:37 <mm_freak_> 'return' is a function…  it takes a value and gives you a (side-effect-free) action that results in the given value
04:51:42 <mekeor> yup
04:52:02 <mekeor> so, actually it's impure that io actions aren't lazy?
04:52:09 <mm_freak_> they are lazy
04:52:16 <mm_freak_> (>>=) may not be strict
04:52:18 <mekeor> oh, okay
04:52:28 <mm_freak_> see what the run-time system does
04:52:31 * Yuu-chan wants to learn about uniqueness typing
04:52:34 <mm_freak_> you have getLine >>= putStrLn
04:52:44 <mm_freak_> the RTS sees:  Bind getLine SOMETHING
04:52:51 <mm_freak_> it runs getLine, then evaluates SOMETHING
04:52:55 <mikeplus64> @pl join (f <$> x <*> y <*> z <*> z <*> z <&> z)
04:52:56 <lambdabot> join (f <$> x <*> y <*> z <*> z <*> z <&> z)
04:53:00 <mm_freak_> this SOMETHING happens to be putStrLn
04:53:16 <mekeor> yup
04:54:03 <mm_freak_> mekeor: if IO weren't opaque, you could very well implement your own interpreter, but of course then you would need something else that is run by the RTS =)
04:54:51 <mekeor> :D
04:55:01 <mm_freak_> (note that "interpreter" is really a metaphor…  the underlying implementation is an STG machine, which gives you almost the code you would have written in C)
04:55:16 <mekeor> STG?
04:55:25 <mm_freak_> implementation detail…  don't worry about it
04:55:36 <mekeor> ok
04:55:59 <mm_freak_> think of it as:  haskell programs are compiled to native code and don't require an interpreter…  the RTS is really just a library that is called from your haskell program
04:56:15 <mm_freak_> it's a clever way of compiling nonstrict functional languages
04:56:22 <Yuu-chan> Spineless Tag Machine?
04:56:28 <mm_freak_> Yuu-chan: tagless
04:56:31 <mm_freak_> G-machine
04:56:56 <mekeor> mm_freak_: wow.. okay..
04:57:02 <sipa> spineless tagless g-machine
04:57:12 <frerich> mm_freak: One thing I didn't quite understand: You said "note how laziness is an integral part of this…  without laziness IO wouldn't be possible". Isn't laziness only relevant to evaluation of values? And if you evaluate an IO action you get, well, an IO action (i.e. isn't "running" an IO action different from evaluating it)?
04:57:16 <Yuu-chan> @hoogle haskell stg
04:57:17 <lambdabot> package haskelldb-hdbc-postgresql
04:57:17 <lambdabot> package haskelldb-hsql-postgresql
04:57:21 <Yuu-chan> Meh.
04:57:28 <Yuu-chan> @google haskell stg
04:57:29 <lambdabot> http://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler
04:57:30 <lambdabot> Title: Glasgow Haskell Compiler - Wikipedia, the free encyclopedia
04:57:30 <sipa> strict IO would work fine, no?
04:57:47 <mm_freak_> frerich: the application of (>>=) is evaluated lazily…  IO is just an EDSL
04:58:10 <mm_freak_> frerich: as said, when you compile "getLine >>= putStrLn", the RTS first sees SOMETHING and evaluates it
04:58:19 <mm_freak_> that SOMETHING evaluates to:  Bind GetLine SOMETHING
04:58:35 <mm_freak_> it pattern-matches the Bind and runs the action corresponding to GetLine
04:58:44 <mm_freak_> then it evaluates SOMETHING again
04:58:56 <mm_freak_> i pattern-matches again and finds PutStrLn
04:59:24 <mm_freak_> lazy evaluation like this is necessary, otherwise a combinator like 'forever' wouldn't work
04:59:40 <Yuu-chan> :t forever
04:59:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
04:59:48 <mm_freak_> Pass c (Pass c (Pass c (Pass c …
04:59:53 <mm_freak_> = forever c
05:00:05 <mm_freak_> the RTS sees:  Pass c SOMETHING
05:00:25 <tdammers> I like to think about code in the IO monad as a pure function that constructs an impure program
05:00:59 <tdammers> things like `if` and such work because the code that builds the program is evaluated lazily
05:01:29 <mm_freak_> 'if' works because of regular evaluation…  it's simplest to view IO as a simple GADT
05:01:55 <mm_freak_> data IO :: * -> * where GetLine :: IO String; PutStrLn :: String -> IO (); Bind :: IO a -> (a -> IO b) -> IO b; …
05:02:10 <mm_freak_> main = id (return ())
05:02:14 <mm_freak_> RTS: SOMETHING
05:02:21 <mm_freak_> evaluate:  id (return ())
05:02:32 <mm_freak_> result:  Return ()  -- an action
05:02:36 <mm_freak_> run, exit
05:02:56 <mm_freak_> main = if True then putStrLn "test" else return ()
05:03:00 <mm_freak_> RTS:  SOMETHING
05:03:08 <mm_freak_> evaluates to: putStrLn "test"
05:03:13 <mm_freak_> this is just regular haskell evaluation
05:03:30 <mm_freak_> pattern-matches, finds a PutStrLn action, runs, exits
05:04:00 <Yuu-chan> Seems there's a thousand ways to explain every feature of Haskell...
05:04:15 <mm_freak_> this is the way to explain what actually happens on a higher level =)
05:04:47 <mm_freak_> in actual code something equivalent happens that doesn't require the pattern-matching and the explicit passing…  that's why haskell programs are so fast
05:07:11 <frerich> mm_freak: What I look like right now: http://i3.kym-cdn.com/photos/images/newsfeed/000/317/278/f28.jpg
05:08:35 <frerich> mm_freak: your explanations are much appreciated, but I think I should read them again when I have some more time. Doing it with one eye while being at work doesn't work out. :-)
05:09:17 <tdammers> mm_freak: comes down to the same thing
05:09:46 <tdammers> you define a lazy data structure that defines your program, and the runtime evaluates it
05:10:10 <tdammers> and because evaluation is lazy, conditionals get resolved only when evaluation reaches that point
05:10:18 <Yuu-chan> Oh, another indecent question: who uses Haskell in their job?
05:10:34 <tdammers> just like you can define an infinite list and then only use the first few elements
05:22:04 <exFalso> why does haskell own every mainstream language so hard? i think by now it became -unfair- to compare haskell to say c++
05:22:29 <sipa> i like both :)
05:23:29 <Botje> exFalso: avoiding success. that's the path to .. uh..
05:23:51 <exFalso> how can you like c++! it is an endless list of not just bad, but simply wrong things
05:24:02 <tdammers> exFalso: try some PHP sometime
05:24:10 <exFalso> haha
05:24:20 <tdammers> seriously, I mean it
05:24:40 <tdammers> there's a ton of questionable design decisions in C++, but they are not plain out wrong
05:25:06 <prophile> some of them are
05:25:09 <prophile> :)
05:25:10 <tdammers> not on the order of PHP's register_globals, $this in a static object context, lack of roper scoping, etc.
05:25:29 <tdammers> I'll give you 'unfortunate'
05:25:31 <exFalso> this is a very long and very entertaining read on PHP: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
05:25:33 <prophile> you should read the aliasing rules some time
05:25:56 <tdammers> exFalso: I'm actually a bit tirerd of that one by now
05:26:12 <exFalso> well aliasing rules are not specific to c++
05:26:16 <tdammers> (also, much of it is just whining and/or outdated)
05:27:19 <exFalso> but for example using #include to simulate a "module system" in 2012...
05:27:52 <exFalso> the impossibility of parsing the language
05:28:00 <exFalso> the gajillion ambiguities
05:28:05 <donri> you're talking about ruby right
05:28:09 <parcs`> haskell is pretty damn hard to parse, too
05:28:33 <exFalso> you pretty much need to know how a c++ compiler works in order to exactly say what your code does
05:28:39 <Yuu-chan> parcs`: why?
05:28:53 <parcs`> Yuu-chan: layout rules
05:29:01 <mm_freak_> Yuu-chan: i'm a commercial haskell user
05:29:11 <zhulikas> is there a performance drop of using two threads instead of one for execution even though one would be enough?
05:29:26 <mm_freak_> zhulikas: yes, but negligible
05:29:35 <zhulikas> I am writing a generic implementation of some sort and in one scenario it needs two threads and a Chan
05:29:38 <Yuu-chan> parcs`: so what? Python, Ruby, F# use 2d syntax too.
05:29:44 <zhulikas> while on some cases it would work perfectly fine with just one thread
05:29:51 <donri> zhulikas: you can get a performance *increase* if you use SMP
05:29:55 <zhulikas> so I wonder about fallbacking to some overloaded functions instead
05:29:59 <tdammers> Yuu-chan: the rules for python are simpler though
05:30:02 <mm_freak_> zhulikas: view haskell threads as a logical execution unit, not a parallel execution thread
05:30:10 <tdammers> (from a compiler point-of-view)
05:30:11 <mm_freak_> zhulikas: i.e. threads are an abstraction
05:30:13 <tdammers> less forgiving
05:30:17 <parcs`> Yuu-chan: haskell's is much more flexible and advanced
05:30:33 <mm_freak_> Yuu-chan: haskell's power is not in syntax
05:30:34 <tdammers> parcs`: apples and oranges
05:30:59 <donri> python's grammar is designed to be LR parseable
05:31:06 <Yuu-chan> mm_freak_: I agree, but it is still pretty neat and concise
05:31:07 <exFalso> i think the shear fact that TH exists proves how simple the language is
05:31:13 <mm_freak_> Yuu-chan: lightweight syntax makes concise expression possible, but the true power comes from laziness, concurrency and the type system
05:31:18 <zhulikas> ok then
05:31:32 <mm_freak_> Yuu-chan: in particular the lightweight syntax allows you to embed DSLs cleanly, which is a unique feature of haskell
05:31:42 <zhulikas> I kinda ignored the actual meaning of having multiple threads on multicore processors
05:31:53 <zhulikas> it increases the performance
05:32:00 <tdammers> mm_freak_: ...and purity
05:32:05 <zhulikas> ok, thanks
05:32:32 <mm_freak_> tdammers: laziness basically requires purity
05:32:46 <mm_freak_> i think DSLs are the killer feature of haskell
05:32:53 <mm_freak_> this is what makes haskell both concise and correct
05:33:05 <donri> exFalso: not that TH is simple :P
05:34:21 <exFalso> donri: i meant that exposing an AST is a no-option in... well i actually can't think of a non-dynlang that could do that sensibly
05:34:22 <Yuu-chan> mm_freak_: unique? What about Lisp?
05:35:02 <MasseR> Yuu-chan: In my opinion you can create nicer DSL:s with haskell. Especially with the help of quasiquoting
05:35:03 <donri> exFalso: oh? java has that
05:35:07 <tdammers> mm_freak: not necessarily, but impure lazy code usually gets messy in no time
05:35:16 <tdammers> python has lazy data structures
05:35:29 <tdammers> yet doesn't enforce purity
05:35:36 <donri> exFalso: http://www.informatik.uni-marburg.de/~seba/projects/sugarj/
05:35:45 <exFalso> donri: thanks, will look into that
05:36:11 <Yuu-chan> MasseR: I thought that ability of redefining the syntax (such as in Lisp or in Nemerle) is very useful for eDSL
05:36:52 <tdammers> Yuu-chan: if I understand it correctly, you can't actually modify low-level *syntax* in lisp
05:36:53 <MasseR> Yuu-chan: It is, but there is still very little you can do to change syntax in lisp
05:36:58 <tdammers> it still has to be s-expressions
05:37:15 <Yuu-chan> MasseR: I used TH a little, but it gave me headaches
05:37:22 <MasseR> Compared to haskell where you can _completely_ redefine the syntax (inside quasiquoter)
05:37:42 <tdammers> in lisp, you are actually modifying the semantics, not the syntax
05:37:48 <MasseR> Yuu-chan: Can't argue with that
05:38:02 <Yuu-chan> MasseR: could you share some articles to learn more?
05:38:21 <MasseR> Yuu-chan: On what?
05:38:23 <simply-chris> You can create nice EDSL in haskell because everything is lazy
05:38:37 <donri> MasseR: well, not completely. QQ can't contain |]
05:38:47 <MasseR> donri: Damn
05:39:04 <Yuu-chan> MasseR: on eDSLs and syntax modifying via quasiquoting
05:39:39 <exFalso> donri: hmm i can't see how that (sugarj) is exposing the AST... javac has an API but i don't think that can be compared to TH
05:39:46 <MasseR> Yuu-chan: Not a document per se, but I like to give yesod as a good example
05:39:48 <donri> Yuu-chan: original paper http://www.eecs.harvard.edu/~mainland/publications/mainland07quasiquoting.pdf
05:40:10 <MasseR> Or maybe jmacro
05:40:11 <Yuu-chan> Thank you MasseR and donri.
05:40:27 <donri> exFalso: i think it's a preprocessor or something like that. TH is basically a preproc.
05:40:38 <tdammers> donri: QQ can contain something that the contained DSL interprets as a nested QQ...
05:40:49 <Yuu-chan> Now I just need about 48 hours a day to process my ToRead list
05:41:07 <MasseR> Yuu-chan: :D. That's why I didn't go and find you the link :D
05:41:18 <MasseR> I have plenty of documents on my hard-drive but no idea where they came from
05:41:19 <tdammers> Better check into Hotel Infinity
05:41:29 <donri> tdammers: sure, but not |]. so for example you can't have a completely and consistently quasi-quoted hsx.
05:41:56 <MasseR> Thinking of doing 'something' with haskell and edsls as my Bsc thesis. Still need to hone the ideas :D
05:42:04 <Yuu-chan> MasseR: I can't finish even some paper books on my shelf :(
05:42:17 <donri> tdammers: i'm just noting the limitation. it's not a big deal.
05:43:59 <exFalso> ... a very advanced preproc. When i'm comparing these meta features of a language i'd usually first check whether it allows automatic marshaling of internal datatypes some other representation. With TH this is very simple
05:44:23 <donri> exFalso: well, sugarj is more advanced than TH since you can extend the grammar.
05:44:24 <mm_freak_> Yuu-chan: common lisp exposes a similar power, but not as elegant and noise-free
05:44:35 <mm_freak_> think of common lisp as a better, but typeless TH
05:44:55 <Yuu-chan> mm_freak_: About your job: what do you develop, if that's not a secret?
05:45:24 <mm_freak_> Yuu-chan: mainly network services
05:45:41 <exFalso> donri: how is that different from quasiquoters?
05:46:03 <Yuu-chan> mm_freak_: what made your company to use Haskell?
05:46:08 <donri> exFalso: you don't need the QQ delims.
05:46:16 <exFalso> :)
05:46:22 <tdammers> CL isn't typeless - it just binds types to values instead of symbols
05:46:24 <donri> exFalso: and you can nest constructs naturally.
05:46:37 <donri> exFalso: we can do this with HSE in haskell too (and sugarhaskell from the same guys as sugarj)
05:46:59 <donri> exFalso: for example the hsx package which adds embedded xml literals in haskell source code without QQ
05:47:38 <exFalso> hmm... how do you even parse that if you don't have a delimiter>
05:47:49 <mm_freak_> Yuu-chan: i'm my own company, so it's my choice =)
05:48:13 <donri> exFalso: HSE aka haskell-src-exts is its own haskell parser, where XmlSyntax is an extension
05:48:33 <Yuu-chan> mm_freak_: oh, that's great :)
05:48:57 <exFalso> donri: good to know, thanks for all the new info:)
05:48:58 <donri> exFalso: but it also implements all of haskell 98/2010 and most ghc syntax extensions
05:49:08 <donri> exFalso: it's what hlint uses for example
05:49:38 <donri> and fay
05:49:55 <exFalso> is the ghc api too awkward to use for that?
05:50:15 <donri> also used to parse anti-quoted haskell inside many QQs like jmacro
05:50:35 <donri> i think ghc is designed for ghc :)
05:51:44 <luite> annoyingly, ghc doesn't expose a quasiquoter for parsing haskell expressions
05:54:36 <donri> apparently ghc exposes a module called DmdAnal
05:55:14 <exFalso> luite: where could one use that? isnt [| |] enough?
05:55:28 <exFalso> ah you mean ghc haskell
05:55:45 <luite> exFalso: if you have a larger quasiquoter and you want to pass part of what you get to the haskell expression quasiquoter
05:56:20 <exFalso> ah
05:58:52 <certainty> hi, i have a newbie question. Is the expression "my_name = 3" binding the name my_name to the value 3 or does it a create a thunk that allways returns 3?
05:59:04 <mauke> what's the difference?
05:59:30 <certainty> semantically there isn't a difference, but the implementation might differ
05:59:34 <exFalso> certainty: that's the decision of the compiler i thikn
06:00:14 <certainty> exFalso: i see
06:00:30 <quicksilver> certainty: your question isn't even well-formed
06:00:38 <quicksilver> thunks don't return things
06:00:53 <quicksilver> and what do you imagine 'a value' is? how is that different from a thunk?
06:01:12 <certainty> quicksilver: that was not my intention. Maybe i'm confusing things.
06:01:26 <quicksilver> a thunk normally refers to a piece of code which is run (normally at most once) and the RTS replaces it with a direct reference to the calculated result
06:01:53 <quicksilver> so if my_name did get compiled to a thunk, it would only still only "run" once.
06:02:09 <Yuu-chan> quicksilver: maybe (s)he meant and unboxed value?
06:02:13 <Yuu-chan> *an
06:02:40 <quicksilver> even with more careful wording the answer to your question is still "Who knows? It's up to the compiler and its optimisation settings"
06:03:13 <quicksilver> however in GHC, given monomorphic types, you can be pretty sure that "x = y" and then using 'x' is no more work than just using y directly.
06:03:36 <quicksilver> Yuu-chan: I doubt it :) But who knows...
06:05:37 <certainty> quicksilver: i think i can live with that explanation. Thanks. I need to be careful not to confuse terms from other languages. In this case a thunk as i took it is simply a zero argument procedure. And most likely haskell does things very differently. Is the term "binding" even apropriate?
06:06:34 <quicksilver> certainty: yes, binding is fine but the problem is the confusion of levels.
06:07:01 <quicksilver> certainty: binding is something 'syntactic' - it refers to haskell as the source language. Thunks are very much an implementation detail.
06:07:10 <certainty> quicksilver: aha!
06:07:38 <quicksilver> A thunk is something like a zero argument procedure which, once executed, replaces itself by a pointer to its result.
06:07:59 <certainty> quicksilver: yeah i understand that now. Thanks.
06:08:03 <certainty> That's pretty neat
06:08:06 <quicksilver> or you could say, a thunk is something like a code pointer which, once executed, replaces itself with a data pointer.
06:08:21 <quicksilver> since really a "procedure" is a higher-level notion again.
06:08:57 <strg> http://en.wikipedia.org/wiki/Thunk_(functional_programming)
06:08:58 <quicksilver> and "replaces itself" is a bit anthropomorphic. Thunks aren't self-aware :) The replacement is done by the RTS.
06:15:30 <parcs`> i am building both a library and an executable in a single cabal project. can i add the library to the build-depends of the executable?
06:17:42 <theadmin> Does the Haskell IO for numeric types follow the system locale with GHC by default?
06:18:08 <quicksilver> you mean the Show instances, theadmin ?
06:18:19 <quicksilver> no, it doesn't. The Show instances always follow haskell syntax.
06:18:34 <theadmin> Oh... Right. Hm...
06:18:56 <theadmin> Well, I'll figure it out
06:18:57 <theadmin> Thanks
06:19:12 <quicksilver> afaik there isn't any binding to the locale-sensitive number formatting stuff
06:19:21 <parcs`> never mind, it works if i move the executable sources to a separate directory
06:19:32 <quicksilver> the obvious place for it would be int he (old-)locale package, which only does dates
06:25:35 <Athas> quicksilver: exactly how are thunks implemented in the GHC RTS, actually?
06:26:41 <quicksilver> Athas: how much detail do you want?
06:26:45 <quicksilver> I can't give you much :)
06:27:04 <quicksilver> a haskell value is a little structure in memory which contains a few bits of flag information
06:27:30 <quicksilver> and either a pointer to a closure (code to execute) or a pointer to an actual value
06:27:38 <quicksilver> or in some cases an actual value unpacked directly
06:27:51 <Eduard_Munteanu> > maxBound :: Int
06:27:52 <quicksilver> and some information about unsaturated values (functions which need more arguments)
06:27:53 <lambdabot>   9223372036854775807
06:28:06 <Eduard_Munteanu> > 2^32
06:28:08 <lambdabot>   4294967296
06:28:10 <LambdaDusk> would there be any image converting lib that can be used with conduits?
06:28:11 <Eduard_Munteanu> > 2^64
06:28:13 <lambdabot>   18446744073709551616
06:29:12 <Eduard_Munteanu> > 2^63
06:29:14 <lambdabot>   9223372036854775808
06:30:07 <Eduard_Munteanu> Hrm, no reserved bits in that?
06:30:35 <Eduard_Munteanu> 63 + 1 sign bit.
06:30:40 <mm_freak_> Athas: if you want to know "exactly", i recommend reading SPJ's paper from 1987 and the tutorial based on it
06:30:52 <Eduard_Munteanu> (2's complement but you get that)
06:30:53 <Athas> mm_freak_: which paper is that?
06:31:09 <Taneb> > 2^32 + 1 :: Double
06:31:10 <lambdabot>   4.294967297e9
06:31:12 <Athas> Alternatively, just point me at the relevant source files in the RTS implementation.
06:31:39 <mm_freak_> Athas: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
06:31:51 <Taneb> > let x = 2^32  :: Double in x + 1 - x
06:31:53 <lambdabot>   1.0
06:31:57 <Athas> Oh, I've been meaning to read that one more closely.
06:32:01 <Taneb> > let x = 2^32  :: Float in x + 1 - x
06:32:02 <lambdabot>   0.0
06:32:07 <mm_freak_> Athas: the whole RTS and GHC are relevant…  this is not some isolated code…  thunks are not a feature, they are a concept
06:32:53 <mm_freak_> Athas: basically they allow a functional program to be translated to something like the code you would have written in C in the first place
06:33:15 <quicksilver> mm_freak_: well, how the GHC RTS implements Heap Object *is* an isolated concept.
06:33:20 <quicksilver> it's just a data structure.
06:33:43 <quicksilver> Athas: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
06:33:52 <quicksilver> Athas: the spj book is very interesting and well worth a read
06:33:57 <quicksilver> but it is of course completely wrong :)
06:34:08 <quicksilver> (as in, GHC doesn't do things that way anymore)
06:35:29 <Athas> Yeah, that's what I'm concerned about.  I've become reasonably knowledgeable about Core-level processing, but I realised I know too few specifics about the actual code generation.
06:36:49 <quicksilver> Athas: there is some quite good info on the wiki, poke around from the page I just linked
06:37:12 <Athas> Yep, reading it right now.
06:37:56 <scooty-puff> does anyone have any good papers or tutorials on implementing a constraint solver for a type system?  i have heard of the outsidein(x) paper - if this is the best, i will go with that
06:40:12 <scooty-puff> (though that paper deals with local assumptions, which i do not plan to handle)
06:41:32 <identity> Does anyone know of a library that will allow me to do some timing of computations? Resolution of milliseconds would suffice
06:41:50 <gienah> identity: criterion
06:42:03 <identity> gienah: Oh, I'm not specifically thinking benchmarking
06:42:08 <identity> just rather keep tracking of something
06:42:16 <identity> "yada yada.. took 50 ms" etc.
06:42:25 <identity> Can criterion do that?
06:42:25 <Eduard_Munteanu> scooty-puff: maybe look at the original Agda paper? Though it's quite old.
06:42:45 <typoclass> identity: a very basic possibility that is available with no extra packages is getPOSIXTime from Data.Time.Clock.POSIX
06:42:49 <Eduard_Munteanu> Ulf's thesis I mean.
06:43:02 <identity> typoclass: Oh, thanks!
06:43:20 <typoclass> identity: you're welcome
06:54:35 <zhulikas> @type <$>
06:54:36 <lambdabot> parse error on input `<$>'
06:54:40 <zhulikas> @type (<$>)
06:54:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:54:54 <identity> Integer isn't unpackable? :(
06:55:00 <identity> I guess that makes sense
06:56:38 <iamtakingiteasy> is there exists any stdlib function to do (\x -> [x]) ?
06:57:00 <danil> iamtakingiteasy: return or (:[])
06:57:14 <iamtakingiteasy> thanks, (:[]) is nice
06:57:35 <byorgey> identity: yeah, unpacking only applies to single-constructor types
06:58:42 <byorgey> identity: and while it isn't necessarily obvious that Integer does not have a single constructor, the fact that it can be arbitrarily large should give one pause
06:58:55 <byorgey> iamtakingiteasy: we call it the robot monkey operator
06:59:17 <identity> byorgey: Yeah
06:59:23 <identity> as soon as I asked I just thought.. "duh"
06:59:24 <luite> actually it's because it can be small that it has more than one constructor :p
06:59:49 <byorgey> luite: oh, right, it's implemented as Int when it's small enough?
07:00:24 <luite> right, i forgot the names, but something like S #Int | J #Int #ByteArray
07:00:25 <mm_freak_> quicksilver: GHC-produced code is not an STG machine?
07:00:43 <hpaste> marcot pasted “Parsec problem with Flexible Contexts” at http://hpaste.org/72844
07:01:09 <byorgey> identity: if efficiency really matters that much to you, then you should be using Int I guess
07:01:18 <marcot> Hi.  I'm having this strange type error with the code I pasted.  If I comment one of the marked lines, it works.
07:01:43 <luite> I'm not sure how the byte array is implemented, it's not immediately unpackable at least because it doesn't have a fixed size
07:01:50 <hpaste> marcot annotated “Parsec problem with Flexible Contexts” with “Parsec problem with Flexible Contexts (annotation)” at http://hpaste.org/72844#a72845
07:01:59 <identity> byorgey: Yeah, just can't in this case.
07:01:59 <marcot> I just pasted the error message.
07:02:46 <marcot> I wanted to make the definitions of Text.Parsec.Language more general, to be able to use it with Parsec Text, and not only with Parsec String.
07:06:56 <sopvop> Mother of god, what have I done? "ghc: panic! (the 'impossible' happened)"
07:07:21 <roconnor> sopvop: you used an extension
07:07:59 <sopvop> which one?
07:08:13 <roconnor> sopvop: one listed at the top of one of your files?
07:08:22 <typoclass> sopvop: welcome to the club. hang on, i think we still have some of the badges somewhere *rummage*
07:08:22 <roconnor> under the LANGUAGE pragma
07:09:02 <identity> there's still a bug in ghci regarding ctrl+c and stuff which makes it panic
07:09:03 <DMcGill_> pft, with the power of cygwin you can get those at will(ish)
07:09:06 <identity> So that happens regularly for me.
07:09:14 <DMcGill_> yeah, using ctrl+c
07:09:17 <identity> yeah, hehe.
07:09:24 <sopvop> I don't even know which file :(
07:09:27 <sopvop> it won't say!
07:10:47 <nooodl> hey, what's something cool i can implement a Functor instance for, as an exercise? (don't say "trees", that's what LYAH used already)
07:11:01 <sopvop> Guess it was the template haskell and something from Data.Lens.Template :(
07:11:08 <ion> nooodl: IO
07:11:28 <ion> nooodl: []
07:11:33 <DMcGill_> nooodl: reader and writer are cool
07:11:43 <nooodl> but but but fmap = map!
07:11:53 <DMcGill_> reader = Monad ((->) c)
07:12:22 <DMcGill_> writer = Monad (Pair a)
07:12:31 <DMcGill_> I mean
07:12:37 <DMcGill_> Monad ((,) a)
07:12:45 <DMcGill_> does that work or do you need a newtype?
07:13:09 <copumpkin> that's fine
07:13:24 <nooodl> i'm not sure what reader and writer are and i'm definitely not comfortable with monads yet
07:13:38 <DMcGill_> you can make functor instances for them now
07:13:41 <DMcGill_> and do the monads later
07:14:22 <DMcGill_> for example, fmap for writer would have type :: (b -> c) -> (a, b) -> (a, c)
07:14:34 <DMcGill_> and for reader would have type
07:14:46 <DMcGill_> (b -> c) -> (a -> b) -> (a -> c)
07:15:14 <sopvop> guess what, GHC was panicking from "deriving (show)" instrad of "Show"
07:15:23 <identity> sopvop: huh.
07:15:29 <identity> i've seen that before I believe
07:15:30 <identity> somewhere.
07:15:41 <DMcGill_> the idea of writer = (a, b) is that a function can return it's value (a) and something else too (b)
07:16:13 <nooodl> "fmap = (.)" for reader? and "fmap f (a,b) = (a,f b)" for writer?
07:16:23 <DMcGill_> indeed
07:16:40 <zzing_> What was the type that took [m a] and made an m [a]?
07:16:45 <zzing_> function rather
07:16:49 <DMcGill_> sequene
07:16:51 <DMcGill_> sequence*
07:17:07 <zzing_> :t sequence
07:17:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:18:11 <dfeuer> Cale: the sort of relation whose name I was seeking earlier is called a "total preorder", complementary to a "strict weak ordering", according to Wikipedia.
07:18:43 <scooty-puff> Eduard_Munteanu: i will try that - thanks for the help - there are way too many options..
07:18:46 <DMcGill_> zzing_: hoogle is good for that kind of thing
07:18:55 <DMcGill_> @hoogle Monad m => [m a] -> m [a]
07:18:56 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:18:56 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
07:18:56 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
07:19:57 <zzing_> I have a function, IO GLuint, that will return a different value each time, I need to extract all values out of it until it keeps returning a certain value.
07:20:07 <zzing_> How can I deal with this?
07:20:36 <fmap> @src Cont
07:20:36 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
07:20:40 <fmap> nooodl: ^
07:22:40 <Eduard_Munteanu> scooty-puff: http://www.cse.chalmers.se/~ulfn/papers/thesis.pdf
07:23:40 <Botje> zzing_: use the pattern in sequence, maybe?
07:23:48 <hpaste> DMcGill pasted “Checking the value of IO GLuint” at http://hpaste.org/72846
07:24:09 <Botje> DMcGill_++ # that!
07:24:12 <DMcGill_> that's a super rough example, it calls itself recursively checking the list
07:24:26 <DMcGill_> checking then building a list*
07:24:32 <DMcGill_> Botje: what do you mean?
07:24:46 <scooty-puff> Eduard_Munteanu: thanks!
07:25:30 <zzing_> DMcGill_: I appreciate the basic idea there. I will try it out. merci.
07:29:16 <DMcGill_> or even better now I think about it,
07:30:37 <hpaste> zzing annotated “Checking the value of IO GLuint” with “Checking the value of IO GLuint (annotation)” at http://hpaste.org/72846#a72847
07:30:48 <zzing_> DMcGill_: is that the functional equivalent?
07:31:02 <DMcGill_> takeWhile (/= target) <$> (sequence (repeat getValue))
07:31:38 <zzing_> :t repeat
07:31:39 <lambdabot> forall a. a -> [a]
07:32:05 <zzing_> DMcGill_: interesting solution
07:32:18 <DMcGill_> for your paste, you need to move the "return" on line 3
07:33:12 <DMcGill_> you can't factor it out like that - the "otherwise" branch is already in the IO monad thanks to the checkError
07:33:18 <parcs`> DMcGill_: that won't work, IO is strict
07:33:28 <DMcGill_> ah, never mind then.
07:33:29 <zzing_> I was wondering about that
07:33:46 <DMcGill_> Also, otherwise doesn't work like that - when pattern matching, use "_" to match anything
07:34:05 <DMcGill_> otherwise is a synonym for "True"
07:34:16 <parcs`> zzing_: case e of gl_NO_ERROR doesn't do what you think it does
07:34:19 <fmap> otherwise actually will match anything
07:34:42 <DMcGill_> and is used for guards, i.e. "f | bool1 = x; | otherwise = y"
07:35:13 <Mathnerd314> where's the latest Hoopl?
07:35:22 <parcs`> sometimes _otherwise is used instead of _ in a case expression because _ has too little noise
07:35:52 <MostAwesomeDude> I've never seen that before.
07:35:53 <parcs`> Mathnerd314: http://darcs.haskell.org/packages/hoopl.git i think
07:36:33 <zzing_> DMcGill_: can you be more specific about what you say 'move'?
07:37:43 <hpaste> DMcGill annotated “Checking the value of IO GLuint” with “Checking the value of IO GLuint (annotation) (annotation)” at http://hpaste.org/72846#a72848
07:38:40 <DMcGill_> you should read up on how monads work, return in Haskell is VERY different to return in C-like languages
07:39:13 <parcs`> in ghc 7.6 you can do 'if | e == gl_NO_ERROR -> .... | otherwise -> ...'
07:39:31 <DMcGill_> so the pattern match for "_" will always succeed
07:39:41 <DMcGill_> then we branch with the two cases
07:40:10 <DMcGill_> using guards (the "|")
07:40:24 <zzing_> DMcGill_: I often use pure instead of return. Does case match the first in order?
07:40:52 <DMcGill_> case tries to match from the top down, yes
07:41:28 <DMcGill_> actually, how do multiple guards work? Do they get compiles into multiple different matches?
07:41:41 <DMcGill_> i.e. "_ | bool1; _ | bool2"?
07:41:46 <zzing_> parcs`: I like the idea of that
07:41:51 <hpc> if-then-else, probably
07:42:09 <hpc> you should try dumping core code
07:42:15 <hpc> -ddump-something-or-other
07:42:22 <MostAwesomeDude> Shouldn't this be case e of { gl_NO_ERROR -> ... ; _ -> ... }
07:42:32 <geekosaur> -ddump-simpl
07:42:45 <geekosaur> or use the ghc-core package to automate it and prettify it
07:43:05 <DMcGill_> MostAwesomeDude: no, pattern matching only works on constructors, not values
07:43:26 <zzing_> DMcGill_: I have used this on values with no problem in the past I believe
07:43:28 <parcs`> MostAwesomeDude: that would bind e to 'gl_NO_ERROR' and overlap the second pattern
07:43:33 <DMcGill_> in your example, a new variable called gl_NO_ERROR is created which always matches and shadows
07:43:41 <geekosaur> zzing_, no, it doesn't work with values
07:43:41 <MostAwesomeDude> DMcGill_, parcs` : Derp, good point.
07:43:51 <zzing_> hmm, ok :-)
07:44:05 <DMcGill_> your code might coincidentally not break if things work out right
07:44:07 <zzing_> Now I want that if syntax for 7.6 :P
07:44:15 <parcs`> (and it would also shadow 'gl_NO_ERROR'. this is why you should always use -Wall)
07:44:17 <hpaste> marcot pasted “Indentation on case and if” at http://hpaste.org/72849
07:44:42 <marcot> Is there a reasonable intuitive explanation about why indentation groups a case statement but not an if statement?
07:45:27 <n-dolio> of introduces layout.
07:45:39 <n-dolio> case foo of { p1 -> ... ; p2 -> ... }
07:45:41 <dfeuer> Does Haskell have an equivalent to Scheme's "cond", or do I need to write  case () of _ | guard1 => val | guard2 => val .... ?
07:45:41 <DMcGill_> because case statements need layout
07:45:42 <hpc> if-then-else has different parsing rules
07:45:50 <hpc> namely, if EXPR then EXPR else EXPR
07:45:52 <DMcGill_> while if statements are more simple and don't need it
07:45:57 <zzing_> DMcGill_: thakn you, I am using your if version
07:46:03 <hpc> case creates a block kind of a thing
07:46:10 * hpc doesn't know the terminology very well
07:46:11 <parcs`> dfeuer: it will in the next version, for now you have to do the latter
07:46:14 <parcs`> dfeuer: next version of ghc*
07:46:16 <hpc> you should look at the report
07:46:19 <dfeuer> Ah, interesting.
07:46:21 <hpc> @where report
07:46:22 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
07:46:22 <DMcGill_> zzing_: there's probably a nicer way to factor it out
07:46:31 <zzing_> DMcGill_: I personally dislike the if
07:46:40 <zzing_> Is there an idea of when 7.6 will be available?
07:47:16 <n-dolio> Should be relatively soon, I think.
07:47:24 <n-dolio> They've already forked the development version.
07:48:08 <zzing_> This special case was a PITA on my brain
07:48:19 <DMcGill_> zzing_: for a state, I'd probably replace lines 5, 6, 7 with "| otherwise -> (e:) <$> checkError"
07:48:25 <DMcGill_> s/state/start
07:49:32 <DMcGill_> if you can make things point-free without making it too complex, I think one should
07:49:54 <zzing_> DMcGill_: that is more difficult with monads is it not?
07:50:54 <DMcGill_> do {x <- getValue; return (f x)} is the same as "liftM f getValue" which is the same as "f <$> getValue"
07:51:42 <DMcGill_> so do {es <- checkError; return (e:es)} is the same as "(e:) <$> checkError"
07:54:05 <hpaste> DMcGill annotated “Checking the value of IO GLuint” with “Checking the value of IO GLuint (annotation) (annotation) (annotation)” at http://hpaste.org/72846#a72852
07:54:15 <DMcGill_> note that those brackets aren't actually needed
07:55:35 <zzing_> yeah that version is what I am pretty much doing now
07:55:44 <marcot> n-dolio: DMcGill_: hpc: Thanks.
07:55:44 <Aune> is there a function for arrays that does this : " Array i e -> (i -> f) -> Array i f "? To clarify: a funtion that gives me a new array where the elements are decided by both position and content of the old array.
07:55:56 <zzing_> When 7.6 comes out, I will use that nicer if :P
07:56:06 <quicksilver> mm_freak_: not quite, no
07:56:16 <quicksilver> mm_freak_: although still strongly related
07:56:18 <Aune> I ment : Array i e -> (i -> e -> f) -> Array i f
07:56:23 <mekeor> yeah.
07:56:47 <mekeor> i mean, yes, you meant that.
07:58:02 <DMcGill_> map (\i -> let e = arr ! i in f i e) [minBound arr .. maxBound arr]
07:58:14 <guidj0s> Does anyone own or know where I can obtain an ebook version of the 2010 report?
07:58:37 <n-dolio> Aune: I don't see one.
07:58:41 <DMcGill_> Aune: that should work
07:59:23 <DMcGill_> by "map" I mean "fmap"
07:59:35 <n-dolio> Aune: vector has such an operation, though.
07:59:38 <mekeor> DMcGill_: isn't it a bit inefficient?
07:59:39 <n-dolio> If you switch to those arrays.
07:59:42 <identity> guidj0s: wut
07:59:52 <Philippa> guidj0s: will a PDF do?
07:59:53 <DMcGill_> O(1) access, so I don't think so
08:00:00 <mekeor> @where report
08:00:00 <Philippa> http://haskell.org/definition/haskell2010.pdf
08:00:00 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
08:00:05 <guidj0s> Philippa: I have the pdf, but I wanted something fit for a kindle device.
08:00:06 <randomclown> what's it called when you have a question on X but you ask how to do Y?
08:00:09 <guidj0s> identity: Heya ;->
08:00:12 <DMcGill_> if it were lists, then yes it'd be pretty horrible
08:00:16 <Philippa> ah. How well does it cope with the HTML?
08:00:22 * hackagebot fay 0.5.2.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
08:00:26 <parcs`> randomclown: XY problem
08:00:32 <guidj0s> Philippa: Not with the links. A single-page version would help.
08:00:49 <n-dolio> Aune: vector is a much better (certainly more comprehensive) API in general, I think.
08:00:52 <Philippa> failing that you'd probably have to run the HTML .tar.gz version through whatever toolchains exist, I'm afraid
08:00:53 <randomclown> thanks parcs`:
08:00:54 <DMcGill_> http://mywiki.wooledge.org/XyProblem
08:01:13 <Philippa> but if you do, I imagine we'd be happy to at minimum link to it from the wiki
08:01:23 <Aune> Hmm, will take a quick look at vector
08:01:35 <Philippa> (I'm afraid I don't know enough about the ebook toolchains to do the job myself today: if I weren't waiting to be picked up and head to a con I'd take a shot myself)
08:02:13 <n-dolio> Aune: imap in Data.Vector.Generic is the function you want.
08:02:50 <Aune> n-dolio, Ok, thanks.
08:03:00 <zzing_> :t putStrLn
08:03:01 <lambdabot> String -> IO ()
08:03:21 <guidj0s> Philippa: I'll let you know if I obtain it.
08:04:04 <Philippa> guidj0s: try running it through Calibre?
08:04:18 <guidj0s> Haven't yet.
08:05:09 <Aune> n-dolio, is Vector only indexable with Int?
08:05:12 <ParahSailin_> @pl altshuffle' n l = takeWhile (not . null) ((map (take n) l) ++ altshuffle' n (map (drop n) l))
08:05:13 <lambdabot> altshuffle' = fix (((takeWhile (not . null) .) .) . ap (ap . ((++) .) . map . take) . (`ap` (map . drop)) . ((.) .))
08:05:19 <n-dolio> Yes, I'm afraid so.
08:05:32 <n-dolio> They're all 0-based, too, if that matters.
08:05:43 <DMcGill_> Aune: you can use Data.Ix to convert your type into an Int
08:05:53 <zzing_> @hoogle (a -> b -> c -> d) -> (c -> a -> b -> d)
08:05:54 <lambdabot> Data.Sequence zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
08:05:54 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
08:05:55 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
08:06:16 <zzing_> Anything that can rotate parameters?
08:06:22 <DMcGill_> zzing_: woah, I don't think that needs to be point free
08:06:34 <zzing_> DMcGill_: ?
08:06:45 <Aune> DMcGill_, will the vector library accept that? Sounds magical.
08:06:57 <n-dolio> @pl \f z x y -> f x y z
08:06:57 <lambdabot> flip . (flip .)
08:06:58 <DMcGill_> just name your variables with a (\a b c d -> f b a b d) or whatever
08:07:12 <DMcGill_> do not use "flip . (flip . )"
08:07:17 <DMcGill_> that way lies madness
08:07:38 <n-dolio> Yes, that's not the sort of translation that makes things clearer.
08:07:54 <DMcGill_> Aune: it does, I've used it before
08:08:06 <Aune> DMcGill_, awesome
08:08:08 <DMcGill_> be aware that it's an extra layer onto all of your calls though
08:08:16 <DMcGill_> so if you can make things Int, it's better to
08:08:16 <sipa> @pl \f a b c d -> f b c d a
08:08:16 <lambdabot> flip . ((flip . (flip .)) .)
08:08:36 <sipa> @pl \f a b c d e -> f b c d e a
08:08:37 <lambdabot> flip . ((flip . ((flip . (flip .)) .)) .)
08:08:39 <n-dolio> Yeah, the Ix stuff is usually pretty slow.
08:09:07 <n-dolio> When people write high performance stuff on the old arrays, they tend to use unsafeIndex, because it doesn't go through all that.
08:10:16 <SwineFlu> Can anyone link me to a good explination of lambda calculus?
08:10:53 <DMcGill_> for example, my (Int, Int) newtype did two multiplications and an addition for "index"
08:11:15 <dylukes> DMcGill_: what about `fmap flip (flip fmap)'
08:11:18 <yitz> SwineFlu: i found wikipedia to be decent, but i'm sure it's not the best
08:11:32 <DMcGill_> :t fmap flip (flip fmap)
08:11:33 <lambdabot> forall a b a1. (a -> a1) -> a -> (a1 -> b) -> b
08:11:41 <dylukes> er, it'd be
08:11:41 <hpc> SwineFlu: lambda calculus is just a notation for functions, really
08:11:42 <dylukes> fmap flip (flip `fmap`)
08:11:47 <SwineFlu> yitz, Wikipedia looks scary
08:11:48 <DMcGill_> what about it?
08:11:55 <dylukes> Is that any less maddening?
08:12:11 <hpc> SwineFlu: say in a language like Java, you would write "int square(int x) {return x * x;}"
08:12:25 <hpc> SwineFlu: in lambda calculus, you would write "λx. x * x"
08:12:29 <DMcGill_> if you understand it intuitively then by all means put it in your code
08:12:35 <yitz> SwineFlu: the opposite extreme: http://worrydream.com/AlligatorEggs/
08:12:39 <nooodl> how do i make a newtype/data statement in ghci?
08:12:41 <dylukes> DMcGill_: hardly.
08:12:45 <DMcGill_> but I wouldn't be comfortable putting it in mine
08:12:46 <SwineFlu> yitz, thanks
08:12:48 <S11001001> @pl \f -> f f
08:12:48 <lambdabot> join id
08:12:51 <hpc> nooodl: you don't, i think
08:12:54 <yitz> SwineFlu: i think we're going to have to look for something in between :)
08:12:54 <exFalso> SwineFlu: here are the notes from my uni: http://www.doc.ic.ac.uk/~svb/TSfPL/notes.pdf
08:12:56 <SwineFlu> I assume its very easy and they symbols are just scaring me ;p
08:12:57 <danil> nooodl: on 7.4 it just works, before that you can't
08:13:00 <Philippa> SwineFlu: have you seen the notation that looks like: x |-> x+1?
08:13:03 <DMcGill_> it takes a while to figure out, doesn't make things any shorter
08:13:03 <nooodl> oh
08:13:04 <zzing_> Can this be made better? http://hpaste.org/72854
08:13:08 <exFalso> it also includes other type systems
08:13:13 <zzing_> Doing a reporting of errors from the previous check
08:13:24 <nooodl> man, i really need to get 7.4
08:13:48 <SwineFlu> Philippa, nope, I want to learn the "Real" notationt hough
08:13:58 <Aune> DMcGill_, Well, the type I wanted to use was (Int,Int,Int).
08:14:10 <Philippa> SwineFlu: it's another "real" one, just not lambda calculus :-)
08:14:13 <Aune> DMcGill_, so there shouldnt be a problem
08:14:16 <dylukes> …alligators
08:14:16 <dylukes> wut
08:14:18 <MostAwesomeDude> yitz: Wow, that's adorable.
08:14:27 <hpc> SwineFlu: go through the wikipedia article, and keep in mind that a "lambda" is just a function
08:14:31 <DMcGill_> Data.Ix might have a default instance, I'd recommend writing your own with a newtype
08:14:37 <Philippa> \ or the lambda sign just say "this here's a function". Then you get one (or more) variables that it binds, a separator (. in lambda calculus, -> in haskell) and then the function body
08:14:39 <hpc> most of the notation will not be too bad, i think
08:14:46 <hpc> just lots of "λ" and "."
08:14:54 <DMcGill_> as you can take shortcuts if it's just a 3D coord system
08:14:55 <Aune> DMcGill_, ok, will try that
08:14:56 <hpc> maybe some ":="
08:15:23 <DMcGill_> also: test properly, it took me ages to figure out mine was wrong :(
08:15:26 <dylukes> Wait, what do the old alligators represent?
08:15:36 <DMcGill_> also also use something like
08:15:43 <dylukes> oh, parens.
08:15:54 <DMcGill_> data ThreeD = ThreeD !Int !Int !Int
08:16:18 <DMcGill_> as opposed to newtype around (,,) and use the UNBOX pragma too
08:16:34 <DMcGill_> constantly putting things into and out of small data structures can really slow things now
08:16:36 <dylukes> or use (#,,#) directly?
08:16:38 <DMcGill_> s/now/down
08:16:43 <DMcGill_> or that
08:17:11 <DMcGill_> where is that? I've not seen unboxed tuples before
08:17:18 <dylukes> But you can't pass them around or have variables of that type.
08:17:40 <Aune> Ok, have to run but will try all this later.
08:17:41 <dylukes> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/primitives.html
08:17:44 <dylukes> section 7.22
08:17:49 <DMcGill_> would it work with a newtype wrapper?
08:18:14 <dylukes> "When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation."
08:18:16 <dylukes> ^ no
08:18:32 <DMcGill_> seems a less than useful suggestion for here then :p
08:18:38 <DMcGill_> good to know about though
08:20:07 <zzing_> Is     let !s = map putStrLn (map (\s -> Map.findWithDefault "Unknown error" s errorStrings) es)  acceptable to make sure it is run?  (BandPatterns enabled)
08:21:09 <exFalso> zzing_: that will compute a list of IO () computations...
08:21:45 <exFalso> :t mapM_
08:21:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
08:22:01 <exFalso> might be what you are looking for
08:22:14 <zzing_> I believe so
08:22:44 <zzing_> I love types :p
08:22:47 <zzing_> It compiles
08:22:55 <zzing_> Almost ready to test my collection
08:23:35 <zzing_> What is the best way to fail gracefully within IO?
08:23:38 <hpaste> DMcGill annotated “report Errors” with “report Errors (annotation)” at http://hpaste.org/72854#a72856
08:23:50 <DMcGill_> zzing_: return something of type Maybe
08:23:57 <DMcGill_> also that's probably how I'd do it
08:24:03 <exFalso> zzing_: nah just use System.Exit hehe
08:24:14 <zzing_> exFalso: "graceful" :P
08:24:22 <DMcGill_> there's no point in using Map, just pattern match
08:24:54 <zzing_> DMcGill_: point taken
08:25:00 <DMcGill_> remember: premature optimisation is the root of all evil
08:25:11 <zzing_> Bad Programmer, NO COOKIE!
08:26:03 <DMcGill_> oops, I meant "mapM_ (putStrLn . errorStrings)"
08:26:06 <zzing_> Merci all, I think I am going to head out now
08:26:57 <parcs`> is finalizeForeignPtr idempotent?
08:34:45 <guidj0s> Philippa: Ran the PDF through Calibre. Result's less than decent. Let me know if you want it.
08:34:48 <mekeor> parcs`: meaning, that "finalizeForeignPtr . finalizeForeignPtr = finalizeForeignPtr" ?
08:36:06 <geekosaur> calibre can;t do much with pdfs
08:37:32 <geekosaur> but I'm thinking it shoudl do okay converting from html... trying
08:38:03 <zhulikas> @hoogle [m a] -> m [a]
08:38:03 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
08:38:03 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
08:38:03 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
08:38:38 * jtza8 thinks, "I know nothing about monads, and it seems to be an esoteric subject... WAIT I think I've heard of them before ... 'Twas brillig and the slithy toves did gire and gimble in the wabe. All mimsy were the borogoves and the Monads outgrabe. ... nope that's not right..."
08:39:47 <Jafet> Beware the jubjub Birds
08:40:26 <zhulikas> can I specify a type for functions which are declared inside another functions?
08:40:30 <kanedank> um, I'm very new to haskell and just got this error trying to install a lib with cabal: https://gist.github.com/3305240
08:40:35 <Philippa> guidj0s: Try running the HTML through instead?
08:40:46 <Philippa> ah, geekosaur's doing it, cool
08:40:48 <zhulikas> as in: bla bla = let myfunc n = ... in myfunc 0
08:40:52 <zhulikas> and I want a type for myfunc
08:41:10 <S11001001> zhulikas: yes
08:41:21 <zhulikas> so how can I do that?
08:41:22 * Philippa thinks jtza8 is fishing to end up in HWN's quotes section
08:41:42 <jtza8> Jafet: Good advice. Thanks.
08:41:43 <Clint> it's prettier if you do it in a where
08:41:44 <Philippa> then again, it's a relief to know that these days I can make a bad sexual pun and not end up there
08:41:48 <S11001001> zhulikas: stick myfunc :: blah in same let binding list
08:42:06 <jtza8> Philippa: Didn't know there was one. :)
08:42:07 <mekeor> zhulikas: foo = bar where { bar :: Type; bar = … }
08:42:11 <DMcGill_> what's the best practice on data F = FA | FB | FC
08:42:23 <DMcGill_> vs data F = F Info; data Info = A | B | C?
08:42:28 <zhulikas> ah, yes
08:42:32 <zhulikas> S11001001 solution works
08:42:33 <zhulikas> thanks
08:42:46 <hpaste> mekeor pasted “zhulikas: that” at http://hpaste.org/72857
08:42:48 <Philippa> DMcGill_: you mean, marking Fingness separately from the info?
08:42:55 <S11001001> zhulikas: where clauses are at least 60% cooler than let clauses though
08:42:56 <zhulikas> or that
08:42:59 <zhulikas> that looks prettier
08:43:04 <zhulikas> :D
08:43:10 <Philippa> or just marking Fingness in the constructor names?
08:43:15 <zhulikas> S11001001, how do you measure coolness of syntax?
08:43:16 <zhulikas> ;D
08:43:37 <zhulikas> mekeor, thanks
08:43:48 <mekeor> zhulikas: did you test it? does it work?
08:43:58 <DMcGill_> the latter
08:44:01 <zhulikas> rewriting right now
08:44:09 * mekeor waits.
08:44:19 <Jafet> Haskell, where we let where clauses be 60% cooler than let clauses
08:44:29 <zhulikas> it works
08:44:30 <zhulikas> :)
08:44:30 <DMcGill_> if I should include the A or B or C information in different constructors or have one constructor with an additional field
08:44:35 <mekeor> Jafet: heh :D
08:44:35 <S11001001> zhulikas: I measure coolness of haskell by similarity to english, as I solve problems in haskell by writing answer in english, then adding type sigs and <*>s until everything works
08:44:37 <Philippa> zhulikas: you get the right pony to comment on it
08:45:00 <zhulikas> :D
08:45:02 <Philippa> let vs where is really a top-down vs bottom-up presentation issue
08:45:24 * hackagebot postgresql-simple 0.2.3.0 - Mid-Level PostgreSQL client library (LeonSmith)
08:45:44 <DMcGill_> I guess having data F = F FType | G; data FType = A | B | C
08:45:47 <DMcGill_> would be clearer
08:45:48 <S11001001> Philippa: not quite; semantics are different
08:47:03 <Philippa> S11001001: mildly so, sure
08:47:58 <Philippa> (*sigh* I really have forgotten more Haskell than the average newbie knows nowadays)
08:48:32 <geekosaur> dug out some useful metadata first (the html having none); conversion is churning.  to mobi instead of my usual epub, although the only viewer I have for the result is calibre's own
08:51:05 <kanedank> hello? can someone help me install the vec library?: https://gist.github.com/3305325
08:51:58 <DMcGill_> that looks like a Num/Eq problem
08:52:00 <geekosaur> if I had to guess it's another casualty of Num losing its Show and Eq
08:52:31 <DMcGill_> either use an old version of GHC or get somebody to update that library
08:52:43 <guidj0s> geekosaur: Can I grab a copy when you're done?
08:53:04 <geekosaur> guidj0s, if the conversion is reasonable I'll stick in my public dropbox space, sure
08:53:34 <DMcGill_> kanedank: depending on your needs, you could try either the vector or repa libraries
08:53:38 <kanedank> um... I'm using the haskell-platform that comes with a new install of fedora, I don't think I can easily install an older one. Can I?
08:54:09 <kanedank> DMcGill: well I'm trying to install the GPipe library that has vec as a dependency
08:54:17 <DMcGill_> oh dear :(
08:54:28 <mekeor> kanedank: i think you'd have to install it manually. but i don't recommend it.
08:54:38 <mekeor> oh :/
08:54:46 <DMcGill_> what was that nice wrapper over OpenGL?
08:54:52 <kanedank> hmm... well I guess I'll just wait a bit and try in a month, hopefully the lib will be updated by then
08:54:59 <DMcGill_> to use instead of GPipe
08:55:02 <colah_> So, I need to create a REST API for an existing pure haskell program. Since the work I need to do could be expensive, I need to do some sort of long-polling...
08:55:15 <colah_> Suggestions for how to go about this?
08:55:43 <colah_> I just need to be able to respond to one type of GET request.
08:55:45 <mekeor> DMcGill_, kanedank: that's weird. gpipe builds fine on ghc-7.4, according to hackage. see <http://hackage.haskell.org/package/GPipe>
08:55:53 <geekosaur> mmm, it converted but it's not very pretty.  that said it's all cosmetic issues with the table of contents
08:56:47 <geekosaur> looks like the actual content converted pretty well, actually, come ot think of it
08:59:16 <zhulikas> @hoogle a -> m [a] -> m [a]
08:59:17 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
08:59:17 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
08:59:17 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
08:59:41 <quicksilver> zhulikas: strange type. What did you want?
08:59:45 <zhulikas> I must be doing something really wrong
08:59:50 <nand`> :t liftM2 (:) . return -- this?
08:59:51 <lambdabot> forall a1 (m :: * -> *). (Monad m) => a1 -> m [a1] -> m [a1]
08:59:54 <zhulikas> a recursive function with IO [a] type
09:00:12 <quicksilver> why did you want a recursive function with IO type?
09:00:17 <quicksilver> that's not a real-world need :)
09:00:31 <quicksilver> typical IO functions will only have the IO tag on the return value.
09:00:39 <quicksilver> a -> [a] -> IO [a]
09:01:11 <DMcGill_> put some code on hpaste for us to have a look
09:01:40 <zhulikas> I am using Control.Concurrent.STM.TChan and it has a readTChan function. But instead I want to construct a lazy stream from a TChan and when the value is not available (check by isEmptyTChan), I want to return last available value
09:01:54 <zhulikas> otherwise I return a new value
09:02:17 <zhulikas> so my top-level function definition is:
09:02:18 <zhulikas> stream :: TChan Pulse -> IO [Pulse]
09:02:22 <zhulikas> type Pulse = Int
09:02:32 <zhulikas> and I want a recursive function inside this one
09:02:41 <zhulikas> and passing by a last known value every time
09:02:51 <zhulikas> so when requested from outside - I would always have a value
09:03:09 <zhulikas> and no need to wait/block until value in chan is available
09:04:15 <zhulikas> inner function is something like this
09:04:17 <zhulikas> stream' :: TChan Pulse -> Pulse -> IO [Pulse]
09:04:50 <zhulikas> but I need an IO monad here as inside I am dealing with the channel and STM
09:05:06 <zhulikas> any thoughts?
09:06:32 <hpaste> DMcGill pasted “TChan default value” at http://hpaste.org/72859
09:06:39 <quicksilver> my immediate thought is that what you are calling a "lazy stream" is a bitter abhorrance.
09:06:53 <quicksilver> and quite different from the powerful but safe pure laziness.
09:07:20 <DMcGill_> but you should probably just call tryReadTChan in your own code
09:07:58 <zhulikas> holy crap
09:08:06 <zhulikas> I was looking at old stm package
09:08:10 <zhulikas> damn google :|
09:08:17 <DMcGill_> hoogle is your friend :)
09:08:18 <zhulikas> so tryReadTChan wasn't there yet
09:08:25 <zhulikas> damn it
09:08:32 * zhulikas looking into newest API now
09:09:10 <DMcGill_> quicksilver: I think I should stop delivering what people ask for while you're trying to work out what they want, sorry
09:09:22 <DMcGill_> I'm an enabler for the XY problem people!
09:10:00 <quicksilver> DMcGill_: well I wasn't being very helpful in this instance :)
09:10:19 <quicksilver> I was genuinely struggling to decide what zhulikas actually does want
09:10:28 <zhulikas> :D
09:10:35 <quicksilver> zhulikas: I think the kind of lazy stream you're asking for needs unsafeInterleaveIO
09:10:41 <quicksilver> but I also think you shouldn't do that.
09:10:55 <zhulikas> I avoid any function with has unsafe written in it
09:11:05 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-March/023073.html
09:11:06 <zhulikas> which*
09:11:07 <pepijndevos> How do you solve the multiple index problem in Haskell?
09:11:43 <DMcGill_> what do you mean? Got a link explaining it?
09:11:43 * quicksilver has no idea what the multiple index problem is
09:11:50 <DMcGill_> googleing it turns up nothing
09:12:09 <DMcGill_> do you mean indexing values in an array with (x, y) coords for example?
09:13:08 <nand`> ‘multiple index problem’?
09:13:27 <sajith> is there a "ByteString -> Vector a" function somewhere?
09:13:30 <pepijndevos> DMcGill_: No. What I mean is that you need to lookup a value using different indexes. For example in a game, where you need collision detection
09:14:07 <Taneb> map (! stuff) coordsToCheck
09:14:17 <nand`> pepijndevos: what would the indices look like in this case?
09:14:18 <pepijndevos> So you stuff your objects in a quad tree, but now you can not look them up by id anymore
09:14:35 <mrg_> hi
09:14:39 <DMcGill_> ah, I suffered from this problem
09:14:46 <quicksilver> you keep a Map to look them up by ID as well as the quadtree?
09:14:50 <luite> pepijndevos: usually you can add a layer of indirection, store id in the quadtree
09:15:04 <DMcGill_> yeah, quicksilver's was the solution I used
09:15:09 <quicksilver> or that, indeed.
09:15:23 <pepijndevos> The other case is dijkstras algo
09:15:34 <luite> without this indirection, updates become difficult
09:15:38 <nand`> maybe just store a map from ID to whatever coordinates the quadtree uses for indexing
09:15:53 <DMcGill_> yeah, I ended up using two data structures
09:16:09 <DMcGill_> one Map Coord Object and one Map Id Object
09:16:16 <nand`> only problem with that is you need to enforce your invariants (quadtree index == map's index)
09:16:32 <nand`> or likewise when updating objects
09:17:00 <quicksilver> there are always some invariants you need to enforce
09:17:04 <pepijndevos> You can't really lookup anything in a quad tree or fibp
09:17:12 <pepijndevos> Fibonacci heap
09:17:20 <quicksilver> you just make the tradeoffs which work best for you
09:17:41 <quicksilver> (pick data structures which make some of the invariants automatic, and set up abstraction barriers to keep the others)
09:17:50 <zhulikas> @hoogle fromMaybe
09:17:51 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
09:17:53 <DMcGill_> talking about this is just making me realise how horrible my icfp2012 solution was :(
09:18:16 <DMcGill_> zhulikas: fromMaybe either returns what was in the Just or a default value
09:18:22 <zhulikas> I see
09:18:35 <zhulikas> eclipseFP is smart enough to provide documentation for it
09:18:36 <zhulikas> :)
09:19:07 <DMcGill_> fromMaybe x = maybe x id
09:19:16 <pepijndevos> So by definition the time complexity for dijkstras is suboptimal
09:19:41 <pepijndevos> Unless there is so
09:20:14 <quicksilver> I imagine most programs contain many many suboptimal time complexities.
09:20:15 <pepijndevos> Me functional equivalent with constant time lookup
09:20:33 <quicksilver> The important trick is to work out which ones actualy matter and fix only those ones.
09:20:45 <luite> pepijndevos: if really necessary, you can fall back to mutable arrays in ST or IO
09:20:48 <quicksilver> #insert <rant/constanttimeisalie.h>
09:20:51 <DMcGill_> pepijndevos: Data.Array and Data.Vector have O(1) lookup
09:21:15 <Jafet> Constant time is just O(1) for sufficiently large 1.
09:21:18 <DMcGill_> Data.Vector is considered better but can only index by Ints by default
09:21:19 <luite> DMcGill_: yeah but O(n) update, which is also required
09:21:33 <DMcGill_> Data.Vector.Mutable it is then, like luite said
09:21:35 <pepijndevos> DMcGill_: Lookup for minimum I mean
09:21:52 <pepijndevos> Like a min heap
09:22:04 <DMcGill_> http://hackage.haskell.org/packages/archive/queuelike/latest/doc/html/Data-Queue-PQueue.html
09:22:10 <quicksilver> Data.Vector.Mutable may well be slower than an IntMap
09:22:16 <quicksilver> it all depends what you're doing.
09:22:32 <DMcGill_> or http://hackage.haskell.org/package/pqueue
09:22:50 * quicksilver would always start with persistent data structures with convenient interfaces
09:23:11 <quicksilver> and only wire in the hard-work alternatives once it's clear where they're needed.
09:23:27 <mrg_> i've got a question: i think i'll just ask: i am working on piece of software which needs a heap (just an ADT with addresses to access data). i was adviced to use a typeclass to hide the implementation but i got stuck at the point where i tried to handle arbitrary types of data...
09:24:09 <DMcGill_> mrg_: you can't really have a type that's unknown at runtime
09:24:46 <Jafet> What did dijkstra do to be dragged into this
09:24:48 <pepijndevos> That heap looks good
09:25:10 <DMcGill_> mrg_: we can't really help you more unless you put your code on hpaste
09:25:36 <mrg_> ok.. ill try an give a better explaination
09:25:46 <pepijndevos> Jafet: Just that you need both a graph and a heap to keep tRack of
09:25:49 <DMcGill_> pepijndevos: I've used the pqueue package before and found it worked for my needs, I can't speak for the other
09:26:37 <hpaste> mrg_ pasted “adt” at http://hpaste.org/72860
09:27:13 <mrg_> this was my first try...
09:27:18 <Jafet> Mmm, design cascade
09:27:38 <Jafet> mrg: and what does that code mean to you?
09:28:38 <Jafet> You might want (heap dat) if you actually want heap to store dat
09:29:08 <mrg_> yeah i wanted to store dat on that heap
09:29:19 <quicksilver> using a class to hide implementation is probably wrong.
09:29:20 <mrg_> wit addresses of type addr
09:29:34 <quicksilver> classes are for overloading, not abstraction.
09:29:41 <nand`> ^
09:30:00 <nand`> if you want to hide implementation, don't export the constructors
09:30:04 <Jafet> data Heap a = Heap (Map Int a)
09:30:32 <quicksilver> it's probably the wrong place to start if you're a relatively new haskell programmer, anyway. Start by actually writing some of the implementation, rather than worry about the way the API will be exposed.
09:30:34 <S11001001> mrg_: replace addr with a and heap with b, only within the class, and you should see the problem
09:31:13 <quicksilver> you might try "Map Addr Dynamic"
09:31:25 <quicksilver> since I have a feeling you meant you wanted data of arbitrary types
09:31:37 <quicksilver> but Dynamic is a bit of a sledgehammer, without understanding your actual use-case
09:32:04 <mrg_> i know the type at runtime... i just want a flexible implementation
09:32:49 <EvanR> a good way to have flexible implementations is by using functions
09:32:52 <EvanR> rather than data structures
09:32:58 <mrg_> only thing i try is to hide the implementation... right now i am using a Map with Int as key and put in may data of some type
09:33:15 <quicksilver> if it's fixed in each particular case then maybe it's what Jafet said
09:33:22 <EvanR> if the implementations api is of the form A -> B, then values of that type can be all kinds of things
09:33:24 <quicksilver>  Heap a = Map Int a
09:33:29 <quicksilver> or Map Addr a
09:33:40 <Jafet> You normally hide the data type by writing instances that do specific things
09:33:42 <S11001001> mrg_: you may also wish to change get's sig to get :: heap addr dat -> addr -> dat, &c
09:33:47 <DMcGill_> or even IntMap
09:33:49 <Jafet> instance Functor Heap
09:34:02 <Jafet> Then you can replace every thing in a heap
09:34:05 <DMcGill_> speaking of, why isn't Map Int automatically optimised to IntMap?
09:34:33 <Jafet> Because they're in different packages
09:34:41 <Jafet> (intmap is a package?)
09:35:05 <DMcGill_> they're both in containers
09:35:13 <DMcGill_> as in, the 'containers' package
09:35:19 <quicksilver> DMcGill_: because GHC can't do that.
09:35:28 <Jafet> I don't know a simple way to make Map Int IntMap
09:35:29 <edwardk> hrmm. Does the diagram on https://github.com/ekmett/lens/wiki help clear up the way the lens class hierarchy works?
09:35:53 <Jafet> quicksilver: with RULES?
09:35:59 <Jafet> And some wizardry
09:36:03 <quicksilver> Jafet: RULES can't change data types wholesale like that.
09:36:15 <quicksilver> they could rewrite data-types at API boundaries
09:36:17 <DMcGill_> hmm, use the CPP?
09:36:22 <quicksilver> but not change them "inside" stuff they can't see.
09:36:23 <DMcGill_> now that seems horrible
09:36:26 <Jafet> data Map k a = GenericMap k a | SpecialMap ...
09:36:28 <c_wraith> edwardk: is that saying every lens is an iso, or the other way around?
09:36:37 <nand`> other way round
09:36:38 <edwardk> the other way around, every iso can be used as a lens
09:36:42 <quicksilver> there is a typeclass hack that UArray and Vector.Unboxed use
09:36:50 <quicksilver> but inevitably you lose polymorphism then.
09:36:55 <quicksilver> which is a shame, perhaps...
09:36:59 <edwardk> every lens can be used as a traversal, every traversal can be used as a fold or a setter, etc.
09:37:02 <DMcGill_> just replace all instances of "Map Int" with "IntMap" in the source code before compilation
09:37:12 <DMcGill_> modulo whitespace
09:37:16 <nand`> it wasn't clear to me what the arrows mean without knowing this in advance, perhaps add a small legend?
09:37:19 <nand`> or at least a note
09:37:29 <edwardk> well, it was a standard uml thing =)
09:37:31 <hpaste> zhulikas pasted “IO (IO [Pulse]) ??” at http://hpaste.org/72861
09:37:31 <EvanR> DMcGill_: but then how would other libraries already compiled deal with values of the optimized type
09:37:36 <Jafet> Map Int isn't ABI-compatible with IntMap
09:37:42 <EvanR> ^
09:37:44 <zhulikas> ahh, error is not visible
09:37:50 <edwardk> fair nuff
09:38:01 <nand`> edwardk: you could also add regions to indicate which of those are compatible with the ‘Getting’ interface, etc.
09:38:09 <nand`> since that includes action, fold, getter, lens and iso
09:38:13 <edwardk> do you want to add the blurb to the page? i'll go edit the image and add a few more methods
09:38:14 <nand`> oh and traversal
09:38:25 <nand`> actually that might be a bit too much clutter for that many
09:38:30 <edwardk> my thought on that was to just name the operations and show when they get refined
09:38:34 <EvanR> nand`: what is iso?
09:38:43 <nand`> EvanR: isomorphism lens
09:38:48 <edwardk> so (^.) is shown in both fold and getter
09:39:18 <mrg_> S11001001: "get :: heap addr dat -> addr -> dat" looks like addr and dat are parameters for heap, is that right?
09:39:23 <DMcGill_> zhulikas: that looks fine to me, what's the error you're getting?
09:39:33 <edwardk> EvanR: "text"^.packed    makes Data.Text from a String, but you can use foo^.from packed to turn a Text back into a String. an Iso is a Lens you can flip
09:39:34 <DMcGill_> mrg_: yes
09:39:35 <nand`> EvanR: constructed from either an isomorphism or a pair of isomorphisms using ‘iso/isos’, as seen in the diagram
09:39:51 <edwardk> from turns an iso around, and every iso works as a valid lens
09:39:52 <EvanR> cool
09:39:56 <DMcGill_> you have a fromList :: [(a, b)] -> Heap a b
09:39:59 <zhulikas> on line 5: expected type IO [Pulse], actual type IO (IO [Pulse])
09:40:10 <DMcGill_> ah yes
09:40:11 <Jafet> mrg: addr is always going to be an integer, so use Integer or Int
09:40:13 <DMcGill_> <$> is liftM
09:40:14 <nand`> edwardk: Iso is just defined as Isomorphic k => .. usual lens sig with k instead of ->, right?
09:40:19 <edwardk> yep
09:40:24 <DMcGill_> i.e. it puts a pure function into a monad
09:40:26 <DMcGill_> @hoogle liftM
09:40:26 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
09:40:27 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:40:27 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
09:40:41 <edwardk> and IndexedTraversal is just Traversal with Indexed i k =>   and k instead of ->
09:40:45 <mrg_> this is maybe what i am looking for
09:40:46 <S11001001> mrg_: yes
09:40:55 <DMcGill_> so you're calling return on a value already in the STM monad
09:41:11 <DMcGill_> I believe that was my mistake when I wrote that, sorry
09:41:18 <DMcGill_> just get rid of the "return $"
09:41:36 <zhulikas> then it whines about missing STM type
09:41:49 <edwardk> i'm adding mapped as an example constructor to Setter. forgot it
09:41:49 <zhulikas> because stream' is IO [Pulse]
09:41:52 <zhulikas> but this is STM monad
09:42:28 <c_wraith> zhulikas: it's intentional that it's hard to do IO in STM.  It's probably not what you want to do.
09:42:42 <zhulikas> and yet it's something I want to do :D
09:42:55 <zhulikas> unless you have other solution
09:42:56 <danil> zhulikas: and what do you want to do if the transaction restarts?
09:42:58 <EvanR> sometimes you want to shoot yourself in the face
09:42:59 <c_wraith> zhulikas: STM action can retry any number of times, silently.  Is your IO action going to be sane if it runs 1000 times before the STM action finishes?
09:43:16 <zhulikas> no idea
09:43:21 <EvanR> haha
09:43:25 <c_wraith> that's a "no", then
09:43:32 <c_wraith> So, no, you do *not* want to do IO in STM
09:43:36 <zhulikas> :D
09:43:53 <zhulikas> damn it.
09:44:29 <zhulikas> but I want to have a non-blocking lazy stream :D
09:44:42 <nand`> kleisli :: Isomorphic k => k (Action m a c) (Kleisli m a c); kleisli = iso (Kleisli . perfom) (act . runKleisli) -- ?
09:44:46 <zhulikas> where last value is repeated until new value is available
09:44:56 <edwardk> nand`: yep
09:45:05 <EvanR> maybe he wants to use frp
09:45:12 <edwardk> unfortunately you can't write that
09:45:20 <edwardk> because it requires impredicative instantiation
09:45:46 <edwardk> Action m a c can't be used directly as the field in Isomorphism without ImpredicativeTypes
09:46:00 <nand`> k
09:46:08 <zhulikas> hmm
09:46:19 <edwardk> thats why we lost so many Isomorphic  k => …. primitive operations when i added Action
09:47:47 <zhulikas> haha
09:47:57 <danil> Are there any plans to implement the stuff from "First-Class Polymorphism for Haskell," or does it not integrate well with the rest of the typechecker?
09:48:10 <hpaste> zhulikas pasted “IT COMPILES!!!” at http://hpaste.org/72862
09:48:20 <zhulikas> for all non-believers ^^
09:48:32 <donri> does $ create a thunk when the RHS is already strict?
09:48:33 <edwardk> going to run a quick scan of the docs to make sure i didn't do anything stupid and push up a copy of 1.8 to hackage
09:49:05 <zhulikas> DMcGill_, so I didn't need to put whole thing into atomically $
09:49:08 <zhulikas> just the part with reading
09:49:11 <zhulikas> and now it wokrs!
09:49:20 <zhulikas> anyway, thanks for the input
09:49:43 <EvanR> zhulikas: it should scared you when bad things pass the compilation step
09:49:46 <EvanR> scare*
09:50:02 <zhulikas> :D
09:50:07 <zhulikas> but this isn't bad, is it?
09:50:14 <zhulikas> also I simplified stream' definition
09:50:16 <EvanR> i dont know im not really paying attention
09:50:17 <zhulikas> (no need for TChan Pulse)
09:50:23 <zhulikas> heh
09:50:27 <zhulikas> you don't need to
09:50:33 <zhulikas> it was a simple problem
09:50:36 <EvanR> i just walk on egg shells when i write C code because basically anything compiles
09:50:44 <zhulikas> :))
09:50:54 <zhulikas> I love how Haskell never compiles
09:50:59 <EvanR> me too
09:51:00 <zhulikas> it could be even more strict
09:51:09 <zhulikas> I wouldn't be against that
09:51:28 <EvanR> but also, when haskell code compiles, you might be lured into a false sense of security
09:51:35 <EvanR> even in haskell compiling code might be totally wrong
09:51:53 <EvanR> so i walk on egg shells writing haskell code too ;)
09:51:55 <Jafet> Compilers are tools that turn code into errors
09:51:58 <zhulikas> I believe that then only logic can be wrong
09:52:16 <EvanR> type sanity is part of 'logic'
09:52:18 <nand`> which is why countless nights are wasted designing types to force invariants
09:52:37 <nand`> well, not wasted
09:53:08 <kallisti> EvanR: there is no hope for someone who can be lured into a false sense of security, regardless of what interpreter or compiler they're using.
09:53:24 <iamtakingiteasy> >> Image:Warn.png Abuse of the Continuation monad can produce code that is impossible to understand and maintain.
09:53:27 <EvanR> how would you know if your sense of security is false or not
09:53:32 <iamtakingiteasy> >> impossible to understand
09:53:38 <Jafet> It's not wasted if it gets you into sigplan!
09:53:43 <iamtakingiteasy> they not even pretending it is comprehensable!
09:53:55 <EvanR> iamtakingiteasy: please tell me that image exists ;)
09:54:04 <nand`> continuations seem largely to be a relic of scheme
09:54:08 <nand`> or other languages
09:54:08 <EvanR> or is it just an exclamation
09:54:08 <mietek> Huh
09:54:29 <zhulikas> Haskellers should be more parranoid about security than anyone else then
09:54:31 <iamtakingiteasy> EvanR: nah, i am not aware of it's existance
09:54:35 <EvanR> zhulikas: yeah
09:54:43 <zhulikas> because compiler is a conspiracy!
09:54:43 <EvanR> iamtakingiteasy: i was thinking it was a meme xD
09:55:35 <EvanR> in fact, after fiddling with haskells culture of safety/correctness you should probably end up walking on eggshells in any programming system
09:55:46 <Jafet> Abuse of callcc can lead to dizziness, faux eastern philosophy, and occasionally perceptions of enlightenment
09:56:04 <zhulikas> EvanR, I think haskell gave me some insights on how to make programs in other languages
09:56:13 <zhulikas> now I want to make everything as strict as possible
09:56:31 <zhulikas> also introducing algorithmic patterns into regular programming
09:56:47 <EvanR> huh
09:56:56 <nand`> I just wish other languages had generalized disjoint sum types and pattern matching, for that to work
09:56:57 <zhulikas> I mean...
09:57:13 <zhulikas> other languages don't really have or at least rely so heavily on polymorphic functions
09:57:20 <zhulikas> like folds/maps/etc
09:57:22 <kgzm> I've just started working with it but I like the idea of pure referentially transparent functions doing all the real work while IO is seperated.
09:57:34 <EvanR> zhulikas: i.e. reusable code
09:57:39 <zhulikas> so right now when I code in C#, I introduce such functions myself
09:57:44 <zhulikas> yes, indeed
09:58:03 <zhulikas> so I end up writing less and easier code
09:58:10 <Jafet> from __past__ import map
09:58:20 <EvanR> kgzm: yes, IO stuff is like second leading cause of failure, besides failure to type sane code
09:58:39 <EvanR> uhm
09:58:42 <EvanR> type type sane
09:58:56 <Jafet> We're all weak typists here
09:59:01 <Palmik> Hmm, why does not this (http://hpaste.org/72863) work?
09:59:13 <Dodek> nand`: continuations are very useful when you do denotational semantics
09:59:35 <nand`> remind me never to do denotational semantics
09:59:56 <EvanR> exactly what do we mean when we talk about continuations, does it have to mean callcc stuff?
10:00:03 <EvanR> or just functions that never return
10:00:27 <nand`> well, I'd say anything involving the Cont/ContT monad and its defined functions
10:01:02 <Dodek> nand`: it would be a shame. denotational semantics is very useful and often used.
10:06:22 <danil> Any emacs experts here? I upgraded emacs (to 24) and haskell-mode (via package-install, which I think just goes to git), and now it doesn't recognize errors in the inf-haskell buffer.
10:10:18 <nand`> edwardk: I feel like some better scaling function should be used to choose between losingAccuracy and winningAccuracy
10:10:29 <edwardk> feel free to patch
10:10:31 <nand`> to make it less of a drastic jump; ie. the harder you're losing, the easier it gets, down to a cap and vice versa
10:10:41 <nand`> I'm just thinking of a good way to define the function
10:12:02 <nand`> I'm thinking f (playerScore - cpuScore) for some f
10:13:49 <avpx> Anyone else watching the Snoyman "Designing Type-Safe Haskell APIs" webcast?
10:14:00 <mekeor> no
10:14:13 <harsh> hello
10:14:18 <mekeor> hi harsh :)
10:14:21 <avpx> Hello.
10:14:33 <gertc> can you migrate data that is not a safecopy type?
10:14:45 <harsh> wats happening mekeor
10:15:11 <harsh> is it a group chat?
10:15:20 <mekeor> yes :D
10:15:26 <mekeor> harsh: new to irc?
10:15:31 <harsh> yep
10:15:43 <mekeor> harsh: new to haskell, too?
10:15:54 <harsh> yeeep
10:16:05 <mekeor> nice :)
10:16:14 <harsh> thanx
10:17:20 <harsh> so wat exactly is this irc?
10:17:30 <mekeor> it's a group chat.
10:17:42 <mekeor> there are different channels on different topics.
10:17:49 <harsh> for haskell stuffs
10:17:49 <mekeor> this one is about haskell.
10:17:50 <harsh> ?
10:17:51 <avpx> It's an advanced protocol for the creation of netsplits
10:17:58 <mekeor> harsh: no. irc is not only for haskell.
10:18:04 <grasGendarme> harsh: http://en.wikipedia.org/wiki/Internet_Relay_Chat
10:18:18 <mekeor> harsh: join #haskell-blah if you wanna talk more.
10:18:29 <harsh> ow
10:18:32 <mekeor> harsh: this channel is about haskell only. ;)
10:19:16 <gertc> like for example "can you migrate data that is not a safecopy type?" :)
10:19:47 <harsh> n how to get out of this stuff?
10:20:11 <mekeor> harsh: depends on your irc-client… :/
10:20:27 <EvanR> harsh: /part
10:20:54 <Jafet> Help, I'm trapped in this channel
10:21:15 <EvanR> of all the channels to be trapped in...
10:22:08 <Jafet> I tried to escape but ghc said occurs check
10:22:40 <mekeor> :D
10:23:17 <mekeor> @remember Jafet <Jafet> Help, I'm trapped in this channel <Jafet> I tried to escape but ghc said occurs check
10:23:17 <lambdabot> I will remember.
10:30:28 * hackagebot cmdargs 0.9.7 - Command line argument processing (NeilMitchell)
10:31:28 <zhulikas> hmm
10:31:32 <zhulikas> > forever $ do { threadDelay 1000000; print "a" }
10:31:33 <lambdabot>   Not in scope: `threadDelay'
10:31:37 <zhulikas> heh :}
10:32:08 <mekeor> > print "a" -- zhulikas
10:32:09 <lambdabot>   <IO ()>
10:32:25 <harsh> m new 2 haskell where is it used?
10:32:27 <zhulikas> forgot to include forkIO
10:32:41 <mekeor> how can i find out a variable of which type GHC(i) expects at a point?
10:32:42 <zhulikas> I was just wondering if I can have multiple threads running in ghci
10:32:47 <zhulikas> and answer is yes, I can
10:32:58 <harsh> i mean in wat applications?
10:33:36 <scooty-puff> mekeor: i'd say lambda abstract it - :t \ x -> ... x ...
10:33:42 <harsh> where do we use pascal?
10:33:55 <harsh> my bad
10:34:02 <harsh> haskell*
10:34:06 <mekeor> lol
10:34:18 <jfischoff> harsh: its a general purpose language you can use it for whatever you want.
10:34:21 <DMcGill> do you mean "where is Haskell used in industry?"
10:34:26 <grasGendarme> harsh: lambdabot  is writte in haskell :p
10:34:33 <mekeor> harsh: http://www.haskell.org/haskellwiki/Haskell_in_industry
10:34:42 <danil> mekeor: if you use -XImplicitParameters and write ?someName, your function will get (?someName :: SomeType) inferred in its context
10:34:56 <mekeor> danil: GREAT! this is what i wanted!
10:35:06 <danil> mekeor: (approximately the same as adding a real parameter, but you only need to type it in one place)
10:35:29 * hackagebot cmdargs 0.10 - Command line argument processing (NeilMitchell)
10:35:29 <scooty-puff> danil: i'll have to remember that one..
10:35:34 <mekeor> danil: is this 7.4.2 only?
10:35:48 <danil> no, it's pretty old I think
10:35:50 <mekeor> danil: idris has the same feature, btw =)
10:36:12 <mekeor> danil: "Some flags have not been recognized: XImplicitParameters"
10:36:36 <scooty-puff> mekeor: ghci has autocomplete on them
10:36:37 <mekeor> ah, -XImplicitParams
10:36:38 <scooty-puff> so try:
10:36:43 <scooty-puff> :set -XImplic<tab>
10:37:09 * mekeor is using GHCI through Emacs where such autocomplete-mechanisms don't work…
10:37:16 <harsh> thanks mekeor
10:37:30 <mekeor> (maybe it works with the new emacs-haskell-mode-repl-thing, though)
10:37:39 <mekeor> harsh: you're welcome
10:38:21 <kuribas> I am looking for an algorithm to see how close I can move two (bezier) curves before they touch.
10:38:22 <timthelion> mekeor: emacs-shell doesn't support autocomplete?
10:38:35 <applicative> harsh some of the cooler executables on hackage  are maybe pandoc xmonad darcs
10:38:39 <kuribas> I wondering if I shouldn't just convert the bezier curves to polygons.
10:39:00 <mekeor> timthelion: the shell does… but (at least for me) the ghci-repl doesn't.
10:39:45 <harsh> aplicative: never heard of these stuffs preety naive to it
10:39:51 <timthelion> mekeor: and why are you using the ghci-repl? (that's not an insult, I'm rather wondering, does it have some magic other feature like evaluating selected bits of code or something?)
10:40:02 <nand`> edwardk: I've opened a pull request
10:40:07 <edwardk> k
10:40:19 <Dodek> kuribas: aren't bezier curves just "polygons" with non straight sides, i.e. using polynomial splines instead of straigth segments?
10:40:29 <edwardk> i'm supplementing the uml diagram with more methods
10:41:17 <applicative>  harsh http://xmonad.org/  http://johnmacfarlane.net/pandoc/index.html http://darcs.net/
10:41:53 <harsh> aplicative: delighted
10:42:04 <avpx> Most tools around Haskell are written themselves in Haskell
10:42:17 <kuribas> Dodek: they can be converted to polygons quite straighforwardly.
10:42:54 <mekeor> timthelion: i don't know to what extend the features which haskell-mode provide depend on that repl…
10:43:19 <timthelion> mekeor: fair enough
10:43:30 <Dodek> well sure. what i meant was maybe you should look for algorithm to find intersection of quadrics (or cubics)
10:43:42 <mekeor> timthelion: anyway, chrisdone wrote a new interactive mode which might provide autocomplete (see <https://github.com/haskell/haskell-mode#setup-for-new-interactive-mode>)
10:44:18 <mekeor> timthelion: and that new repl has a lot of nice features which a shell inside emacs couldn't provide for sure.
10:44:59 <kuribas> Dodek: I am not really looking for intersection, but rather for the minimum horizontal distance between two curves.
10:45:49 * timthelion begins reading the source to the emacs-mode(as it relates to his current project) hasn't read elisp in several years...
10:46:02 <chrisdone> edwardk: can you please change this http://hackage.haskell.org/packages/archive/semigroups/0.8.3.2/doc/html/Data-List-NonEmpty.html#v:fromList
10:46:02 <chrisdone> edwardk: to fromList :: a -> [a] -> NonEmpty a?
10:46:14 <mekeor> hey chrisdone … was talking about you :D
10:46:45 <chrisdone> edwardk: actually then it's just :|. i guess what i want is that function destroyed with fire. nevermind
10:46:47 <edwardk> chrisdone: ouch. that function was deliberately partial for a reason
10:46:48 <chrisdone> hi there
10:47:51 <chrisdone> edwardk: i started a discussion on g+ about using a nonempty list and yours is the best one. i want to advocate it but that function people will use, i know for sure
10:48:26 <edwardk> chrisdone: well, sadly you still need it from time to time when you know the list isn't empty, i can document it with lots of big scary 'this is partial' noises at least
10:48:50 <edwardk> but i can't actually kill that function with fire without having to rewrite a lot of code ;)
10:49:18 <chrisdone> sad
10:49:25 <edwardk> nonEmpty :: [a] -> Maybe (NonEmpty a)  is the safe version
10:49:26 <Dodek> kuribas: so this is basically an optimization problem. consider two parametrized curves p: [a, b] -> R^2, q: [c, d] -> R^2. we want to minimize their distance, that is, the function D: [a,b]x[c,d] -> R, D(s, t) = ||p(s) - q(t)||.
10:50:16 <nand`> edwardk: the CPU seems to maintain a 1-3 point lead over me now
10:50:18 <Dodek> kuribas: if you assume that p and q are differentiable (and in case of bezier curves they piecewise are), you can apply usual analytical methyods.
10:50:26 <chrisdone> edwardk: the thing about that function, at least for me personally, is that it just shifts the case analysis from one constructor to another
10:50:31 <edwardk> nand`: nice, smoother rubberband?
10:50:42 <nand`> rubberband?
10:50:59 <edwardk> gradient on the skill of the computer opponent
10:51:22 <edwardk> rubberbanding is the phenomenon of making computer ai scale with your ability to always make the game 'close'
10:51:35 <kuribas> Dodek: but the curve is a function of t, and I want to calculate the difference between the x coordinate.
10:52:21 <Dodek> kuribas: what is your representation of a curve?
10:52:26 <kuribas> Dodek: The same value of t may have a different values of x
10:52:39 <edwardk> chrisdone: i understand your objection to the function, but i also understand the need for it in real code. making everyone use fromJust . nonEmpty when they have a known non-empty list is awkward and requires a separate import
10:52:42 <chrisdone> edwardk: either you case analysis on case foo of (x:xs) -> x :| xs, or you case analysis on case nonEmpty foo of Just (x :| xs) -> …  but Maybe (NonEmpty a) is somehow encoded by [a]. eh, anyway. better than nothing but fromList endorses partiality to me
10:52:47 <kuribas> Dodek: Two points and two control points.
10:52:48 <nand`> edwardk: here's the accuracy function, from 10 point lead (player) to 10 point lead (CPU): [0.9,0.860266895,0.82021376,0.7801658650000001,0.7401234800000001,0.700086875,0.66005632,0.620032085,0.58001444,0.540003655,0.5,0.460003745,0.42001516,0.380034515,0.34006208,0.300098125,0.26014292,0.22019673499999998,0.18025984,0.140332505,0.10041499999999998]
10:53:08 <chrisdone> edwardk: fromJust would also defeat the purpose of having a total data structure
10:53:19 <kuribas> Dodek: a cubic bezier curve.
10:53:32 <Dodek> kuribas: i'm quite sure you'll find algoritm to convert this representation to parametrisation in every book
10:53:52 <edwardk> the main change i'm willing to make to it is to document the bejeesus out of its partiality
10:54:10 <Dodek> kuribas: anyway, that's all i can say.
10:54:24 <chrisdone> edwardk: yeah…
10:56:13 <kuribas> Dodek: Well, I have been searching for a numerical solution, but it's not that easy.
10:56:36 <kuribas> I think most programs, inkscape etc... use numerical methods for dealing with bezier curves.
10:56:54 <Dodek> kuribas: then go with linear approximation.
10:58:16 <kuribas> It's the easiest I think.
10:58:17 <nand`> come to think of it, a linear interpolation could work just as well for the scaling function
10:58:52 <nand`> let me fix that
10:59:54 <johnw> how do I tell cabal to remove an old version?
11:00:09 <Clint> you can unregister
11:00:31 <johnw> how?  "unrecognized command"
11:00:35 <Clint> oh, with ghc-pkg
11:01:00 <johnw> great, thanks!
11:01:24 <sm> note files are not removed, disk space still used
11:01:31 <johnw> that's fine
11:01:45 <johnw> i'm just to get inf-haskell to use the local Haddock docs for installed packages
11:01:56 <johnw> it can't find Shelly's docs in the default place, but they're there, in the ~/.cabal directory
11:02:04 <johnw> (after installing the latest with --enable-documentation)
11:02:58 <johnw> yay, it works!
11:05:55 <johnw> now I have C-c C-d jumping me directly to the docs that describe the function
11:06:02 <sm> nice, nice
11:06:20 <sm> and type of thing under point showing up in message area ?
11:06:30 <johnw> sadly, not if it's in an imported module
11:06:35 <johnw> C-c C-t shows the type
11:06:35 * sm had that working once, but only for some things
11:06:42 <johnw> yeah, it works for prelude, and my own functions
11:06:48 <johnw> I need to have it ask ghci
11:06:51 <johnw> doing that next...
11:07:25 <sm> chris done has some advanced alternate emacs mode with more integration, FYI
11:07:57 <johnw> and I have flymake working with both hlint and ghc -c
11:08:08 <johnw> so I get highlighting for both hlint warnings and ghc warnings and errors
11:08:30 <johnw> sm: what's his mode called?
11:08:46 <sm> smokin! (flymake)
11:09:06 <dwins> http://hackage.haskell.org/package/ghc-mod looks like nice emacs integration, i've been using it with vim recently
11:09:17 <johnw> i tried that, it didn't work too well for me
11:09:27 <johnw> and scion didn't work a all
11:10:07 <hiptobecubic> ghc is ok. but if your file is not currently compilable it produces lots of garbage errors in vim, which makes it kind of useless.
11:10:11 <sm> I'm not sure.. maybe it's within http://wikemacs.org/wiki/Haskell-mode
11:10:24 <hiptobecubic> I want to see types so i can fix the program, not to admire them afterward.
11:10:29 <johnw> haskell-mode is what I'm using, btw
11:10:39 <johnw> and it is much richer than earlier versions of haskell-mode that I'd seen
11:11:09 * sm thinks wait a minute, what the heck site is that..
11:11:22 <johnw> hey hey, haskell-doc now shows types for everything!
11:11:40 <johnw> awesome
11:11:59 <johnw> sm: you just need this: https://gist.github.com/3306656
11:12:13 <johnw> that way it uses inf-haskell to get the type, rather than haskell-doc's own logic
11:14:19 * sm adds to .emacs for later
11:14:27 <sm> I'm happy you're looking at this stuff
11:15:05 <nand`> Where can I find examples of netwire being used?
11:16:50 <ReinH> hello folks
11:18:03 <kuribas> johnw: What's the "(setq sym ..." for?
11:19:18 <johnw> oh, just a pasting artefact
11:19:25 <johnw> just pass down (haskell-ident-at-point)
11:19:37 <johnw> a lot of this haskell-mode stuff was not written by veteran elispers
11:19:50 <johnw> i found stuff like (cons (car a) (list (cdr b) foo))
11:19:56 <johnw> which is equivalent to (append a foo)
11:20:01 <johnw> s/(cdr b)/(cdr a)
11:22:05 <gertc> http://stackoverflow.com/questions/11889387/haskell-safecopy-example
11:22:31 <kuribas> johnw: I don't see how they are similar.
11:22:36 <aristid> oO standard chartered has its own haskell compiler? http://www.youtube.com/watch?v=hgOzYZDrXL0
11:23:03 <shapr> johnw: Are you using chrisdone's most recent version of haskell-mode?
11:23:13 <S11001001> johnw: no, it isn't
11:23:19 <danharaj> edwardk: How do I modify a lens with an iso?
11:23:23 <johnw> (cons (car '(1 2 3)) (append (cdr '(1 2 3)) '(4 5 6))) => (1 2 3 4 5 6)
11:23:32 <johnw> (append '(1 2 3)'(4 5 6)) => (1 2 3 4 5 6)
11:23:38 * shapr beats his glasses with a CD iso
11:23:53 <S11001001> johnw: you wrote (cons (car a) (list (cdr b) foo))
11:23:54 <edwardk> danharaj: (.)
11:24:05 <johnw> I had s/(cdr b)/(cdr a)/ just after :)
11:24:12 <S11001001> list, not append
11:24:22 <johnw> shapr: I'm using https://github.com/haskell/haskell-mode.git
11:24:32 <S11001001> moreover, what about the a => nil case?
11:24:32 <jamiltron> I think my sister
11:24:33 <johnw> oh
11:24:35 <jamiltron> mt
11:24:35 <johnw> typo
11:24:49 <danharaj> edwardk: I mean something like 'foo %~ iso $ x'
11:25:01 <kuribas> S11001001: But in that case the original is worse.
11:25:10 <edwardk> x'^.iso
11:25:18 <edwardk> or foo.iso %~ x
11:25:19 <S11001001> kuribas: depends on what was meant, which I can't tell
11:25:32 <edwardk> er for your iso
11:26:23 <danharaj> edwardk: foo.iso %~ x is a type error
11:26:39 <edwardk> what is your isomorphism?
11:26:42 <edwardk> and what is x?
11:27:04 <edwardk> iso was just a place holder for an isomorphism named bar
11:27:33 <shapr> johnw: submit patches! I got a tiny one already :-)
11:27:35 <danharaj> yes. x is a record that contains a rectangle with base, foo is the lens on the rectangle, the isomorphsim translates the base.
11:27:37 <edwardk> ghci> traverse.from packed %~ (++ "world") $ ["hello"^.packed, "there"^.packed]
11:27:37 <edwardk> ["helloworld","thereworld"]
11:28:12 <edwardk> packed is an isomorphism from string -> text, i want to go backwards across it after traversing the list
11:28:29 <edwardk> the result of all that is a list of Text
11:29:19 <edwardk> myIso.foo %~ whatIwanttodoWithx $ x
11:29:45 <nand`> or foo.myIso if I interpreted his data types correctly
11:29:54 <edwardk> or the other way if i misparsed you
11:29:55 <edwardk> yeah
11:30:17 <edwardk> oh foo is the lens on the rectangle, yes
11:30:22 <gertc> wich one of you *** -1 my question again :)
11:30:35 <johnw> submitted an issue against ghc-mod
11:30:43 <danharaj> ok I see. I was thinking there was a way to extract one of the functions that makes up the isomorphism.
11:31:03 <danharaj> So I wanted to do foo %~ something $ x
11:31:31 <nobdraisentone> gertc: ha-ha
11:31:50 <nand`> danharaj: maybe you want ‘via’
11:31:54 <kuribas> johnw: setq is dangerous in elisp, because it may destructively modify and existing binding.
11:32:13 <nand`> oh, sorry, no
11:32:34 <kuribas> johnw: I'd use (or sym (haskell-ident-at-point))
11:32:43 <nand`> danharaj: you want ‘view’
11:33:01 <nand`> view (iso f g) = f; view (from $ iso f g) = g
11:33:33 <danharaj> nand`: yes indeed, thanks.
11:33:41 <kuribas> johnw: Wait, that's what you meant, right?
11:34:12 <danharaj> While the monolithic module structure was bad in some ways in earlier versions, not being able to look at the entire api at once can get me stuck :P
11:34:21 <edwardk> nand`: updated the uml diagram on https://github.com/ekmett/lens/wiki
11:34:33 <edwardk> adding it to the front page of the lens.cabal file too
11:34:46 <johnw> kuribas: ah, you're right
11:34:51 <johnw> it's not what I mean,t but I was wrong
11:35:11 <edwardk> nand`: oh i should write those laws on the iso function
11:35:13 <johnw> ok, so now I'm using ghc-mod to get flymake behavior
11:35:24 <johnw> it's nice in that if there are errors, it doesn't also show warnings
11:35:54 <johnw> one thing i didn't like about ghc-mod is that it's a bit more draconion about indentation
11:36:03 <johnw> if it doesn't think you should indent the code somewhere, you just can't there with TAB
11:36:12 <johnw> haskell-indentation at least lets you shoot yourself in the foot if you want to
11:36:42 <johnw> but I'll try it out, see how it goes
11:37:13 <nand`> edwardk: perhaps it could be helpful to show the expanded versions of each type alias as well
11:37:29 <nand`> oh, you did
11:37:34 <nand`> but not for all of them
11:37:36 <edwardk> i added it to the ones that are easy ;)
11:37:43 <edwardk> the others are hard not to lie about
11:37:49 <nand`> yeah
11:37:55 <nand`> (at any rate, I was thinking of in the title)
11:38:22 <kuribas> johnw: btw, I have added support for birdtracks in haskell-indentation, though it totally doesn't work with mmm-mode.
11:38:23 <edwardk> oh as in instead of Fold a c, show type Fold a c = ?
11:38:41 <johnw> hmm.. with ghc-mod on, C-c C-t no longer shows types in my minibuffer
11:38:43 <johnw> interesting
11:38:54 <nand`> something like ‘Traversal a b c d   [Applicative f => (c -> f d) -> a -> f b]’ where the [ ] bit is less prominent
11:38:59 <johnw> oh, I see the problem
11:39:43 <edwardk> yeah i don't have much control over formatting these
11:40:13 <nand`> or just ‘Traversal a b c d = Applicative f => (c -> f d) -> a -> f b’ could work
11:40:24 <johnw> kuribas: what are birdtracks?
11:40:29 <nand`> might just keep the current version though
11:40:38 <kuribas> johnw: bird style literate haskell.
11:40:44 <johnw> ah. the > stuff
11:40:51 <kuribas> yeah
11:41:02 <edwardk> i tried putting it in the title of them but bolded it is pretty bad, and it runs too long
11:41:19 <nand`> yeah
11:42:28 <nand`> it's not exactly clear what the ‘Simple’ bit means
11:42:46 <nand`> it seems to read like “only Simple lenses can be used as Getters”
11:43:41 <roconnor> do all the haskell webframeworks support SSL?
11:45:30 <johnw> actually, I can plug inf-haskell into haskell-doc much more easily, with just: aesia
11:45:31 <johnw> (defalias 'haskell-doc-sym-doc 'inferior-haskell-type)
11:45:51 <johnw> but now I need to deal with stuff that inferior-haskell-type can't handle
11:46:32 <edwardk> yeah, which is true ish
11:47:36 <edwardk> maybe i'll try writing a = b, c = d instead of 'Simple
11:48:06 <rb10> @kind Maybe
11:48:08 <lambdabot> * -> *
11:48:18 <rb10> @kind [ Int ]
11:48:19 <lambdabot> *
11:48:23 <rb10> @kind [ Int, Int ]
11:48:25 <lambdabot> parse error on input `,'
11:49:10 <edwardk> nand`: http://creately.com/diagram/h5nyo9ne1/LBbRz63yg4yQsTXGLtub1bQU4%3D
11:49:37 <rb10> :k [ Int, Int ] works with ghci 7.4.1 and gives [ Int, Int ] :: [*], what version does lambdabot run on?
11:49:38 <lambdabot> parse error on input `,'
11:49:48 <nand`> edwardk: I don't see a thing, what scripts do I need to allow?
11:49:54 <edwardk> javascript and maybe flash
11:50:09 <nand`> I don't have flash
11:50:13 <edwardk> nm then
11:50:16 <edwardk> i'll just make the edit
11:50:25 <nand`> ah, it was amazonaws
11:50:33 <hiptobecubic> Is there a benefit to using Array instead of Vector?
11:50:37 <edwardk> ?
11:50:56 <nand`> edwardk: I needed to allow creately.com to access amazonaws.com
11:51:03 <edwardk> nand`: ah
11:52:35 <marcot> Is there a place where the format of the haddock header for modules is documented?
11:52:44 <coppro> in the haddock docs
11:53:45 <marcot> coppro: Well, this is where I thought too, but I could not find it there.
11:55:14 <rb10> @version
11:55:15 <lambdabot> lambdabot 4.2.2.1
11:55:15 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:57:26 <edwardk> nand`: i went and figured out how to embed the image directly from creately, and made the diagram itself a link to edit the creately diagram
11:57:37 <edwardk> figured that was wiki-ish behavior ;)
11:58:00 <rb10> @kind [ ( , ), ( , ) ]
11:58:02 <lambdabot> parse error on input `,'
11:58:13 <edwardk> was a bit tricky because i couldn't use their scripts but instead had to pull the image from amazonaws directly
12:01:20 <gertc> aaaaaa -3
12:14:59 <sykora> I'm reading http://www.haskell.org/haskellwiki/Generic_number_type#squareRoot, specifically the reasons why `isqrt x = floor . sqrt . (fromIntegral x)` is a bad idea. Can anyone give me examples for the three reasons they've mentioned? Because it's 5x faster than my own isqrt implementation, and I haven't seen any counter examples.
12:16:42 <luite> > let isqrt x = floor . sqrt . fromIntegral $ x in isqrt (1000000000000000000^2)
12:16:45 <lambdabot>   1000000000000000000
12:16:50 <luite> aw too small
12:16:57 <luite> > let isqrt x = floor . sqrt . fromIntegral $ x in isqrt (10000000000000000000000000000000000000^2)
12:16:59 <lambdabot>   9999999999999999538762658202121142272
12:17:21 <luite> that's the second
12:19:04 <nand`> sykora: at least three reasons are mentioned on that page
12:19:20 <sykora> at the rate I was testing, I wouldn't have reached that counter example for a while, but the point is well taken
12:20:15 <nand`> 1. floor might turn 2.999999999999999 into 2; 2. fromIntegral may lose precision or fail altogether for large integers
12:20:21 <teurastaja> why am i constrained to #haskell when i need an intelligent solution on irc in any field?
12:21:23 <teurastaja> looks like savvy programmers are haskellers
12:21:58 <Taneb> teurastaja, because a lot of Haskellers have a mathematical background, and a lot are nice, and these two categories overlap a lot?
12:21:59 <teurastaja> however, learning haskell, even though appealling
12:22:01 <nand`> you could try #haskell-blah for non-Haskell stuff
12:22:16 <teurastaja> however, learning haskell, even though appealling... is hard
12:22:17 <typoclass> s/intelligent solution/solution involving monads/
12:22:18 <luite> nand`: that one doesn't seem to actually be a problem for at least up to 10 million
12:22:43 <luite> the first one
12:22:45 <teurastaja> why monads exclusively?
12:23:05 <typoclass> Taneb: what does a math background have to do with it?
12:23:20 <typoclass> teurastaja: eh, i was just kidding :)
12:23:30 <Taneb> typoclass, because...
12:23:31 <Taneb> Um
12:23:36 <nand`> monads are overrated
12:23:42 <nand`> these days I prefer to use zygohistomorphic prepromorphisms
12:23:50 <luite> Taneb: if that was the reason, #math should be a friedlier channel than #haskell, right?
12:23:53 <teurastaja> math background means i can ask for clever algorithms here
12:23:55 <luite> friendlier
12:24:00 <Taneb> luite, no, because they're not nice
12:24:09 <Taneb> Haskell has people who are good at maths AND nice
12:25:51 <teurastaja> what the hell is a zygohistomorphic prepromorphism?
12:26:02 <Taneb> Yes
12:26:03 <teurastaja> seems like a real thing
12:26:13 <Taneb> Haskell can do that
12:26:18 <Taneb> It's in the FAQ
12:26:25 <otters> what's the command
12:26:31 <Taneb> @faq what the hell is a zygohistomorphic prepromorphism
12:26:32 <lambdabot> The answer is: Yes! Haskell can do that.
12:26:37 <typoclass> @faq what's the command for the faq?
12:26:38 <Taneb> Told you so
12:26:38 <lambdabot> The answer is: Yes! Haskell can do that.
12:26:45 <Taneb> @yes Is this right?
12:26:46 <lambdabot> Maybe you meant: let oeis yow
12:26:49 <Taneb> :(
12:26:56 <otters> @faq can haskell intuitively represent zygohistromorphic prepromorphisms?
12:26:57 <lambdabot> The answer is: Yes! Haskell can do that.
12:27:09 <otters> As I thought
12:27:12 <nand`> teurastaja: it's really simple: http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
12:27:17 <teurastaja> lambdabot: (speak? lambdabot scheme)
12:27:45 <Taneb> Zygo means union or pair-y
12:27:48 <otters> wait
12:27:58 <otters> if that's an actual thing, I need to take a 15 minute break
12:28:07 <Taneb> Histo means tissue-like
12:28:24 <Taneb> morphic means having a shape or form
12:28:36 <Taneb> pre means before
12:28:46 <teurastaja> tissue-like?
12:28:54 <Taneb> As in flesh, I believe
12:29:08 <teurastaja> can i have a non-haskell explanation?
12:29:09 <Taneb> pro can either mean agreeing with or in front of
12:29:27 <Taneb> A morphism is an arrow in a category
12:29:30 <nand`> teurastaja: I'm reasonably acquainted with Haskell and I didn't understand a word of what he said, if that cheers you up
12:29:56 <teurastaja> seems useful, rare, and monadic
12:29:57 <typoclass> teurastaja: it's a joke. it can be constructed, but i don't think anyone has ever used it for anything, other than for joking around
12:30:08 <teurastaja> really?
12:30:09 <Taneb> So a zygohistic prepromorphism is obviously something it's before agreeing with arrows and shaped like a pair of flesh
12:30:15 <Taneb> :)
12:30:50 <teurastaja> i guess no one understands that because there isnt a simple explanation
12:31:04 <typoclass> teurastaja: check this, it has more "zygo" and imho is funnier http://www.willamette.edu/~fruehr/haskell/evolution.html
12:31:09 <ahkurtz> "Used when you really need both semi-mutual recursion and history and to repeatedly apply a natural transformation as you get deeper into the functor." I might actually want to do that ...
12:31:28 <nooodl> > sequence [[1,2],[3,4],[5,6]]
12:31:30 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
12:31:37 <nooodl> ...this is dark, dark magic
12:31:59 <parcs`> @src sequence
12:32:00 <lambdabot> sequence []     = return []
12:32:00 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:32:00 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
12:32:10 <parcs`> @src [] (>>=)
12:32:11 <lambdabot> xs >>= f     = concatMap f xs
12:32:16 <parcs`> not anymore!
12:32:21 <teurastaja> isnt sequence like AMB?
12:32:26 <nand`> AMB?
12:32:57 <teurastaja> non-deterministic ambivalence operator
12:33:21 <teurastaja> can only be constructed from continuations
12:33:29 <teurastaja> not coroutines or anything
12:33:42 <nand`> hmm
12:33:55 <nand`> I didn't understand a word of that either, except for ‘continuations’
12:34:14 <srhb> "[syntax] (amb EXPRESSION...) => TOP  -- If the EXPRESSION has any parameters, the first one of them is evaluated and the result is returned. If a subsequent occurrence of amb fails, though, backtracking may cause the second of the given EXPRESSION... to be selected for evaluation, then the third and so forth until the whole program does not fail if at all possible."
12:34:22 <nooodl> uuuugh list monad
12:34:41 <avpx> nooodl: ?
12:34:41 <Taneb> nooodl, the list monad can be useful
12:35:01 <nooodl> my head hurts, i'm trying to convert "do v <- x; vs <- sequence xs; return (v:vs)" to >>= notation
12:35:09 <Taneb> > do {x <- [1..6]; y <- [1..6]; return (x + y)}
12:35:11 <lambdabot>   [2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10,6,7,8,9,10,11,7,8,9,10,11...
12:35:29 <avpx> x >>= \v -> sequence xs >>= \vs >> return (v:vs)
12:35:36 <Taneb> > do {x <- "HT"; y <- "HT"; return [x,y]}
12:35:37 <lambdabot>   ["HH","HT","TH","TT"]
12:35:41 <nand`> edwardk: in Data.Functor.Foldable why is Mu a newtype but Nu a GADT?
12:35:55 <Taneb> That's the results of flipping two coins
12:35:57 <edwardk> the latter is forced to be by the existential
12:36:02 <edwardk> no existential newtypes
12:36:05 <nooodl> > (,) <$> [1,2,3] <*> [2,3,4]
12:36:07 <lambdabot>   [(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,2),(3,3),(3,4)]
12:36:09 <edwardk> also it has two fields
12:36:17 <nooodl> it's exactly like this right?
12:36:32 <otters> @pl \x y -> (,) <$> x <*> y
12:36:33 <lambdabot> (((,) <$>) .) . (<*>)
12:36:43 <nooodl> wait, no, it has the product thing but not the concatenation thing
12:36:56 <nooodl> > concat $ (+) <$> [1..6] <*> [1..6]
12:36:57 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
12:36:57 <lambdabot>    arising from a use...
12:37:18 <nooodl> > (+) <$> [1..6] <*> [1..6]
12:37:20 <lambdabot>   [2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10,6,7,8,9,10,11,7,8,9,10,11...
12:37:33 <nooodl> oh it does, i'm just saying crazy things
12:37:46 <edwardk> teurastaja: i'm the inventor of the zygohistomorphic prepromorphism, its a real thingin that i use it to point out the absurdity of complex recursion schemes
12:37:49 <Dodek> nooodl: do you know how List monad works?
12:38:07 <nooodl> the horrible thing is i should know how it works because i read about it yesterday
12:38:17 <teurastaja> AMB causes a program to converge at its maximum without failing
12:38:22 <nooodl> but... apparently not :)
12:38:25 <kgzm> I don't have anyone in my life to discuss Haskell with.
12:38:39 <nooodl> what about the 923 people in here
12:38:40 <Dodek> kgzm: here, take this towel.
12:38:48 <srhb> kgzm: First step is realization of that, next stem is missioning.
12:38:51 <srhb> step*
12:38:55 <edwardk> teurastaja: basically catamorphisms, anamorphisms and hylomorphisms (folds, unfolds, and refolds) are fundamental, the rest are just a hack using a monad or comonad and a distributive law. i demonstrated that you can compose all the other ones by using monad and comonad transformers, so the zygo- in zygomorphism can be made into part of a larger scheme.
12:39:09 <nand`> kgzm: what do you mean? you have 923 people right here
12:39:10 <edwardk> and then i demonstrated you can make zygo-histo-prepro-morphisms
12:39:24 <nooodl> nand`: don't steal my joke! that was copyrighted
12:39:33 <nand`> oh, I missed that; sorry
12:39:58 <teurastaja> i dont know about hylomorphisms
12:39:58 <avpx> Yeah, poor form.
12:40:01 <kgzm> Well, I'm pretty new to it. I'm just pondering its mysteries.
12:40:12 <nand`> teurastaja: hylo f g = cata f . ana g
12:40:27 <avpx> kgzm: Basically I'm in the same boat, so I cope by talking about Haskell with people who don't care.
12:40:30 <edwardk> hylo http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)
12:40:40 <kgzm> avpx: I'm doing that too and it's very unsatisfying.
12:40:44 <edwardk> jut its just build something up and tear it back down
12:40:49 <kgzm> avpx: But I love the way it makes my brain tingle.
12:41:02 <edwardk> the main problem with the hylo-hierarchy is that the moment you have hylo you're already turing complete so there isn't much you can do
12:41:06 <nooodl> well, it's fun to talk about haskell to other coders, if they care
12:41:46 <nooodl> ten minutes of attention is enough to blow their minds! maybe even convert them to haskellites
12:42:04 <teurastaja> so hylos are like (fold (unfold ...) ...) ?
12:42:10 <nand`> yeah
12:42:58 <teurastaja> ive used that then
12:43:16 <edwardk> yep
12:43:19 <kgzm> nooodl: Most of the programmers I know aren't really interested in FP or anything really interesting. They just write C or Java or C++, maybe some JS or PHP if a project calls for it. And don't look at other languages,
12:43:40 <edwardk> thats all there is to them, they have some fusion laws, but transforming to/from hylo isn't something that is easy to do
12:43:46 <Taneb> I actually have someone I can talk to about Haskell IRL, but I can't stand his jokes
12:43:53 <Dodek> kgzm: some people like to create stuff more than to polish their craft.
12:44:06 <Dodek> kgzm: some of them also have family to feed.
12:44:17 <typoclass> kgzm: those muggles
12:44:41 <teurastaja> im interested in fp but haskell is a pain to learn. isnt there a way to learn from non-intersecting chunks?
12:44:44 <kgzm> Dodek: It's not a judgement. I just feel like I only improve as a programmer by doing new things.
12:45:02 <nooodl> non-intersecting chunks?
12:45:22 <Dodek> kgzm: i wasn't judgemental either. i just wanted to point out that there's more than meets an eye.
12:45:37 * hackagebot kure 2.4.0 - Combinators for Strategic Programming (NeilSculthorpe)
12:45:39 <teurastaja> no (or at least minimal) set intersections of knowledge chunks
12:45:55 <Dodek> kgzm: i write c++ code for a living, and i don't think i can get better job than i already have.
12:47:04 <teurastaja> you know.... you read a chapter, do something else, come back after a while and pick up another one without having to reread the first...
12:47:12 <typoclass> teurastaja: in my opinion, nothing beats writing code. even if it's only a few lines, even if it doesn't work, looks bad, or if it's a reimplementation of something that already exists. try to write the tiniest thing, put it on hpaste, get feedback from the folks in here
12:47:32 <Taneb> Heh, I remember some of my early programs
12:47:45 <nand`> heh, so do I
12:47:51 <teurastaja> im just overwhelmed by all these learning techniques
12:47:54 <nand`> I'd throw up if I saw it now
12:48:12 <teurastaja> ive tried a few but cant decide which subject i should learn first
12:48:21 <teurastaja> monads? typeclasses?
12:48:22 <nooodl> also for the love of god, don't try to port stuff you wrote in other languages to haskell, when you're new to it
12:48:23 <Taneb> Yeah, the family-tree package I've been trying to do for I while
12:48:30 <Taneb> I'll see if I can find an early version
12:49:01 <Dodek> teurastaja: the way that worked for me was to write real, useful programs in haskell
12:49:03 <nooodl> i tried to make a crossword puzzle generator once ("i did it in python, that was easy!") and it was physically painful
12:49:08 <nand`> typeclasses should be before monads because monads are typeclasses
12:49:10 <avpx> nooodl: See, Haskell is easy! You just write your C code in the IO monad
12:49:13 <Dodek> teurastaja: at first they will look like shit
12:49:40 <Dodek> teurastaja: but you show them someone more knowledgeable, he shows you abstractions you could have used
12:49:53 <Dodek> teurastaja: and at that point these abstractions become obvious
12:50:08 <Taneb> Oh god that's awful
12:50:17 <teurastaja> i usually dont read a haskell book from alpha to omega without stopping to do something else then come back to realize i should read it again
12:50:19 <Dodek> teurastaja: like, for instance, the State monad is obvious after writing lot's of code passing state as an additional parameter
12:50:29 <Dodek> s/lot's/lots
12:50:30 <otters> lot's
12:51:33 <nand`> Taneb: I don't seem to have my earlier programs anymore (they were on my netbook); but I distinctly remember doing stuff like arithmetic parsers in monolothic functions :: String -> Integer; using only tuples and lists as intermittent types
12:51:39 <avpx> teurastaja: I think a lot of it is getting used to the common abstractions (Functors, Monads, Monoids, ...) and being able to recognize when you want to do something that fits into that framework
12:51:55 <nand`> these days I would factor out every component (parsing, evaluation, etc.) into distinct elements and use an ADT for communication between them
12:52:01 <ReinH> I would humbly suggest that HaskellLive.com might be a good resource for beginner haskellers
12:52:01 <avpx> It just takes careful study and practice.
12:52:10 <otters> teurastaja: the thing you have to realize about haskell is, typeclass don't tell you anything about *what* something should do
12:52:14 <otters> all they tell you is "it should typecheck"
12:52:25 <otters> and there are the monad laws too, but still
12:52:26 <ReinH> I at least spend a fair amount of time in here having people tell me my code is stupid and then fixing it :)
12:52:31 <otters> that's the most important thing I realized early on
12:53:05 <Taneb> nand`, using data OIORef a = OIORef Int (IORef a) to make arbitrary graphs?
12:53:12 * nand` wants Haskell with built-in constructive proof requirements
12:53:20 <avpx> nand`: That would be cool
12:53:22 <nand`> Taneb: nah, I never was big on the whole IORef/State/imperative stuff
12:53:27 <Taneb> That... sounds like my idea of AGDA
12:53:49 <Taneb> nand`, I was, but that's because I thought they were cool
12:53:51 <timthelion> How might I use something like named pipes with haskell?  I need to communicate between two processes, one being the master and the other being the slave, and stdout and err do not suffice for me, I need a third...
12:53:54 <nand`> Taneb: I was thinking along the lines of basically current Haskell but if I make my type an instance of something I have to prove it conforms to the laws
12:54:00 <Taneb> And that, at the earliest, was October...
12:54:12 <frigga> Is there a cabal-install flag that shows me why a particular dependency version is being installed?
12:54:13 <Taneb> nand`, oh, that sounds cool
12:54:26 <nooodl> who $ else $ is $ guilty $ of $ writing $ these kinds of $ lines $ a lot $ as a novice coder?
12:54:32 <avpx> timthelion: Looks like createNamedPipe in System.Posix.Files is what you want
12:54:37 <otters> nooodl: me
12:54:38 <nand`> nooodl: not me, I used . . . . . . . . $
12:54:40 <timthelion> nooodl: nothing wrong with that
12:54:46 <otters> aren't you supposed to do . . . . $
12:54:48 <Taneb> no (I (ended (up (with (code (like this))))))
12:54:50 <typoclass> frigga: i think -v does that
12:54:50 <timthelion> avpx: I'll look at it.
12:54:53 <nand`> Taneb: yuck :)
12:54:59 <nooodl> Taneb: that (is (wonderful))
12:55:06 <avpx> Did you come from Lisp?
12:55:10 <typoclass> teurastaja: do you learn better in the abstract, by reading a lot of stuff? or do you learn better by coding? if the latter, just start. it's not that hard really. try solving fizzbuzz, for example
12:55:13 <hpaste> NemesisD pasted “infinite type” at http://hpaste.org/72873
12:55:16 <timthelion> avpx: google *really* failed me on that one, if such a function really exists!
12:55:20 <NemesisD> hi all. i'm quite stuck with the above error ^
12:55:32 <NemesisD> i'm just not seeing where an infinite type is being constructed
12:55:34 <Taneb> Nah, Python, from earlier VB
12:55:34 <avpx> timthelion: I just googled "haskell mkfifo"
12:55:42 <ReinH> typoclass: I find that for most people abstract knowledge needs to be cemented by practice
12:56:01 <ReinH> you can read a dozen haskell books and end up undertanding less than if you had read half of one and then tried to write a program
12:56:12 <timthelion> avpx: I didn't know the term fifo was what I wanted, thanks :)
12:56:23 <ion> edwardk, roconnor: Hmm, this change by roconnor seems to have disappeared from edwardk’s wiki branch at some point. I seem to have pulled it from the branch earlier.
12:56:25 <ion> -which just gives you back the value when used with `(^.)` and which when set completely replaces the old value.
12:56:27 <ion> +which just gives you back the value when used with `view` and which when set completely replaces the old value.
12:56:28 <kgzm> Out of curiousity, why do some people say 'you can't leave the IO monad once you go in there' like it's a pit of despair,w heny ou clearly can leave it whenever you want? And what do programs with no IO do?
12:56:38 <avpx> timthelion: Any time.
12:56:38 <edwardk> feel free to push it back
12:56:47 <edwardk> it proably collided with an edit i made locally and i missed it
12:56:49 <ReinH> kgzm: nothing. At least nothing we can see.
12:56:58 <ReinH> kgzm: they are very good at generating heat
12:57:02 <ion> edwardk: Did git want you to use --force when pushing at any point?
12:57:14 <timthelion> avpx: so those pipes won't actually write to disk, I hope :)
12:57:21 <edwardk> i pulled and merged a few weird ways
12:57:23 <typoclass> ReinH: sure, i'm the same type personally
12:57:38 <avpx> timthelion: Right
12:57:42 <ddarius> So I'm in the Bay area for today and most of tomorrow.
12:57:44 <frigga> typoclass: Ahhh, you have to do -v3
12:57:48 <timthelion> avpx: great, thanks!
12:57:54 <nand`> kgzm: they mean that there's no function IO a -> a; so if any of your subcomponents requires IO, as a result everything else does too
12:58:08 <avpx> kgzm: There actually is a function IO a -> a. It's called unsafePerformIO
12:58:14 <avpx> You probably shouldn't use it until you understand the implications of that.
12:58:16 <otters> but it's unsafe
12:58:32 <otters> unsafeRecommendUnsafePerformIO
12:58:38 <nand`> heh
12:58:40 <timthelion> otters: so are needles, and dirty people, that doesn't mean we never go to the city.
12:58:42 <typoclass> frigga: right, i didn't remember the details 8-) if you get stuck, feel free to copy-paste the output of cabal -v3 onto hpaste and ask in here
12:58:54 <ion> edwardk: I rebased the commit on top of your current master branch, it’s available in my branch for pulling now.
12:59:00 <hpaste> nand` pasted “FizzBuzz” at http://hpaste.org/72874
12:59:02 <otters> timthelion: yeah, but I'm sure you don't shoot up with the needles of others
12:59:04 <otters> as it's unsafe
12:59:05 <nand`> ^- my try at fizzbuzz
12:59:10 <ReinH> typoclass: my experience teaching and mentoring leads me to believe that people differ in how they learn information (auditory, visual, etc) but not much in how they *retain* information
12:59:17 <teurastaja> any sudoku programmers? pv
12:59:18 <edwardk> hrmm looks like i don't get to use pull requests on the wiki
12:59:28 <ReinH> teurastaja: the haskell wiki has a huge page of sudoku solvers
12:59:40 <teurastaja> i know but im not fluent
12:59:54 <ReinH> teurastaja: I'm particularly fond of Richard Bird's solution, which is in literate haskell and a presentation http://www.haskell.org/haskellwiki/Sudoku#Sudoku_incrementally.2C_.C3.A0_la_Bird
13:00:01 <edwardk> merged
13:00:02 <kgzm> avpx: I don't exactly understand what you mean. by IO a -> a but I might be thinking about this backwards. Or inside out.
13:00:02 <ReinH> it's very easy to follow
13:00:11 <kgzm> avpx: I mean, I just can't see any limitation.
13:00:40 <ion> > let fizz str modulo num = str <$ guard (num `mod` modulo == 0) in map (\n -> fromMaybe (show n) (f "fizz" 3 n ++ f "buzz" 5 n)) [1..]
13:00:41 <nand`> teurastaja: good example: http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
13:00:42 <lambdabot>   No instance for (SimpleReflect.FromExpr
13:00:42 <lambdabot>                     (Data.Maybe.May...
13:00:44 <nand`> (perhaps bookmark)
13:00:44 <teurastaja> i use a completed sudoku generator, i made my solver, im at the step of clue pruning
13:00:57 <ion> > let fizz str modulo num = str <$ guard (num `mod` modulo == 0) in map (\n -> fromMaybe (show n) (fizz "fizz" 3 n ++ fizz "buzz" 5 n)) [1..]
13:01:00 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
13:01:32 <ReinH> nand`: that's exactly the one I was referring to :)
13:01:43 <mekeor> BOLT
13:01:49 <typoclass> ReinH: i agree. my personal opinion is that the abstract mathy side is vastly overemphasized in haskell, and vastly overestimated as a teaching aid
13:01:59 <ReinH> reads a bit better with syntax highlighting though: https://gist.github.com/27c445a1bf1a2335128f
13:02:00 <nand`> ReinH: ah yes, missed that while I was digging out the URL
13:02:22 <ReinH> typoclass: it's good if you have a fluent, intuitive relationship with the maths
13:02:30 <ReinH> which, let's face it, most people decidedly do not
13:02:34 <pcapriotti> lens people: does something like 'Alternative f => (c -> f d) -> (a -> f b)' have a name?
13:03:05 <Taneb> Yes
13:03:09 <nand`> Traversable a b c d
13:03:10 <ReinH> it's nice to have *the* lens person here :)
13:03:12 <nand`> oh
13:03:14 <nand`> misread
13:03:17 <teurastaja> so... anyone wants to talk about sudoku algorithms? i know the wiki
13:03:22 <nand`> I read Applicative :(
13:03:22 <Taneb> Modifier, I think?
13:03:27 <Taneb> Oh, no
13:03:29 <Taneb> So did I
13:03:30 <ReinH> teurastaja: read through the richard bird vrsion
13:03:31 <Taneb> Um...
13:03:33 <teurastaja> s/know/know about/
13:03:37 <Taneb> I don't think it does, pcapriotti
13:03:39 <pcapriotti> it can model setters than can fail
13:03:42 <ReinH> it's a very nice one as it starts simply and progresses to more complicated improvements
13:03:45 <pcapriotti> s/than/that
13:03:49 <ReinH> and it's very well explained
13:03:56 <ReinH> teurastaja: if you have any questions about it, ask us
13:03:58 <timthelion> ReinH: the bigger problem, is that people who DO have an intimate relationship with math should be discouraged from using it.  In math, two things may be equal, that in haskell decidedly are not(for example, a cube drawn using an infinite number of vertexes, vs one which has only 8
13:04:12 <ion> If you have any questions about Italy, ask U.S.
13:04:12 <ReinH> timthelion: sure
13:04:28 <typoclass> reinh, there was a sudoku thing published as a functional pearl. is the richard bird solution you mentioned?
13:04:29 <ReinH> timthelion: and also almost no one who's trying to learn haskell will already understand the maths
13:04:35 <ReinH> typoclass: I'm unsure
13:04:41 <timthelion> ReinH: sadly, a lot of mathemeticians have trouble with this, leading to a huge amount of really crappy haskell code :(
13:04:44 <ReinH> typoclass: but I would like to know more about these functional pearls :)
13:04:56 <ReinH> typoclass: http://www.cs.nott.ac.uk/~gmh/sudoku.lhs or syntax highlighted https://gist.github.com/27c445a1bf1a2335128f
13:05:00 <teurastaja> im not at the step of solving, i already wrote a solver and a completed grid generator. i want to talk about efficient clue pruning algorithms
13:05:17 <ReinH> teurastaja: did you look at the pruning in bird's solution?
13:05:36 <nand`> pcapriotti: for what it's worth, you can still define your own: Alternative f => LensLike f a b c d
13:05:41 <teurastaja> hmm... hold on
13:05:52 <ReinH> teurastaja: it's added in a few increments
13:06:01 <ReinH> and it's quite easy to follow, and the results are pretty performant
13:06:15 <pcapriotti> nand`: yeah, that's what I've been doing
13:07:24 <typoclass> ReinH: i got it from here http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls and yes, it lists richard bird as the author
13:09:08 <teurastaja> the sources are unreadable in notepad and unexecutable in ghci
13:09:22 <teurastaja> there are no newlines
13:09:37 <ReinH> typoclass: ty
13:09:47 <ReinH> teurastaja: notepad? o_O
13:10:02 <ReinH> probably line ending conversion issues
13:10:04 <absence> mm_freak_: you mentioned earlier that netwire 4 would get the ability to have wires produce sequentially. how will that work internally? by comparing time with a thresholds?
13:10:07 <ReinH> windows has retarded line endings
13:10:26 <typoclass> teurastaja: i downloaded the .lhs file and it does have newlines for me (on linux). do you have another editor installed besides notepad?
13:10:31 <ReinH> you'll want to convert from sane *nix line endings to retarded windows line endings
13:11:00 <ReinH> windows, of course, does not have any built in tools to do this afaik, because it is retarded
13:11:03 <teurastaja> i know i hate windows installing linux is not straighforward on my laptop
13:11:10 <typoclass> i think the retarded thing is that there are two standards. i don't think it's windows' fault in this case
13:11:29 <ReinH> typoclass: the *nix standard prexisted
13:11:31 <ReinH> preexisted
13:11:39 <ReinH> they could have just used the same line endings as everyone else
13:11:50 <teurastaja> nevermind, github is the solution
13:11:55 <barometz> I don't think they were the first to use something else, either :P
13:12:32 <teurastaja> i asked already why crlfs are that way on windows
13:12:41 <E0F> Hi, I'm sorry if these are noob questions but I couldn't find a working answer on my own. Is there a way to convert an integer to a string like "show" does, but with ByteStrings ? Also, I have a list of ByteStrings like these ["\"FOO\"", "\"BAR\"",..], how can I remove the unecessary \" ?
13:12:56 <ReinH> barometz: non-unix and non-ibm systems iirc
13:12:59 <teurastaja> and about a lot of tcp/ip conventions, ascii, unicode and others
13:13:00 <E0F> I would have used read if they were Strings but it doesn't work here
13:13:17 <typoclass> ReinH: i'm not a historian, but i thought it was crlf first, then unix decided to deviate. in some areas like networking (http ...) people stuck with it and it has always been crlf there
13:13:39 <ReinH> barometz: stupid ISO/ANA/ANSI
13:13:41 <teurastaja> crlf is because of old typewriters
13:13:52 <barometz> Anansi?  :P
13:13:55 <ReinH> typoclass: I think it's actually DEC's fault
13:14:01 <ReinH> but yes, it predates windows
13:14:07 <ReinH> I just like spreading unjustified windows hate
13:14:12 <Taneb> Isn't lfcr used sometimes in rare circumstances?
13:14:31 <teurastaja> i also asked why ascii has SYN FIN ACK and others
13:14:34 <Taneb> Like, on old soviet computers or something
13:14:35 <Taneb> NAK
13:14:40 <barometz> Taneb: older Apple systems, I think.  Or something like that.
13:14:49 <barometz> I know it's existed.
13:14:51 <Taneb> Nah, they just used cr, I think
13:14:52 <teurastaja> and its because it was the way to communicate....
13:15:12 <Jeanne-Kamikaze> is there a version of advancePtr that takes an offset in bytes ?
13:15:31 <ReinH> originally it's because it took too long to move the print head or scoll the screen
13:15:32 <typoclass> Taneb: in case earth ever turns around and starts going east to west?
13:15:35 <teurastaja> predates internet
13:15:57 <Taneb> typoclass, like in Futurama? DEFINITE POSSIBILITY
13:16:08 <ReinH> teletypes, etc
13:16:26 <johnw> shapr, sm: ping
13:16:37 <typoclass> Taneb: oh i remember that! the kitty overlords were so cuuute! :-)
13:17:00 <ReinH> teurastaja: TYPE unix_file | FIND "" /V > dos_file
13:17:33 <teurastaja> (define possibilities amb)
13:17:56 <shapr> johnw: howdy!
13:18:04 <johnw> so I added the ability to get the type kind to inf-haskell.el
13:18:09 <shapr> oh cool
13:18:10 <johnw> from
13:18:17 <shapr> johnw: Do you have your own fork on github?
13:18:21 <shapr> I'll pull from it and start using it!
13:18:22 <johnw> and then i changed haskell-doc so that if it can't get the type of something, it tries to get the kind
13:18:27 <johnw> yeah, making forking now
13:18:39 * shapr looks for the repo on github
13:18:39 <ReinH> johnw: hardcore forking action
13:18:57 * shapr patiently F5s https://github.com/johnw
13:19:25 <shapr> hm, still not there..
13:19:54 <johnw> give me a sec
13:20:02 <shapr> Patience... never my strong point.
13:20:23 <johnw> ok, now you have inferior-haskell-kind
13:20:33 <johnw> and you'll need this in .emacs: https://gist.github.com/3307759
13:21:21 <johnw> that way if your cursor is on a function, you see the full type in the minibuffer, but if cursor is on "FilePath", you see: FilePath :: *
13:22:32 * shapr adds this to ~/.xemacs/shae-haskell.el
13:23:33 <shapr> johnw: Where's your fork?
13:23:58 <johnw> https://github.comjwiegley/haskell-mode
13:24:04 <johnw> add /
13:24:04 <ArtVandelay> http://perstaweatherstation.appspot.com/ <- how terrible is that design?
13:24:08 <johnw> also, see this file:
13:24:12 <ArtVandelay> (webdeswign)
13:24:19 <johnw> oh, weird
13:24:24 <johnw> hold on, my fork has a bizarre name
13:24:41 <johnw> shapr: ok, check this file out: https://github.com/jwiegley/dot-emacs/blob/master/lisp/haskell-config.el
13:24:52 <johnw> that will evolve over the course of tady
13:24:52 <johnw> todya
13:24:55 <johnw> today
13:25:12 <shapr> heh, awesome :-)
13:25:27 <nand`> what would the following Arrow syntax desugar to? “proc x -> do f -< x; g -< x”
13:25:57 <E0F> I don't mean to be too insisting, but does anybody knows an answer ?
13:26:09 <shapr> ArtVandelay: looks okay to me, is it written in Haskell?
13:26:44 <shapr> EOF: What's your question?
13:26:45 <nand`> E0F: sounds like you want to compose show :: Integer -> String with your favorite :: String -> ByteString
13:26:52 <shapr> I must have missed it.
13:27:18 <marcot> EOF: `pack . show` and `map (tail . init)`
13:27:21 <marcot> ?
13:27:24 <shapr> doh, e zero f
13:27:34 <shapr> That's culturally hard to type.
13:27:42 <E0F> My questions : Is there a way to convert an integer to a string like "show" does, but with ByteStrings ? Also, I have a list of ByteStrings like these ["\"FOO\"", "\"BAR\"",..], how can I remove the unecessary \" ?
13:27:52 <E0F> marcot: I'll try this thank you
13:28:07 <ArtVandelay> shapr: thing is im doing a project for a company, simple inroducion program, introducing me to the company. as an extra thing in thta prject i could try extracting info from their website and present it on appengine. they dont expect much and it is voluntarily and the problem is i cant do webdesign. so question is should i show it or skip it all together?
13:28:32 <shapr> ArtVandelay: If it's written in Haskell, I think it's fine :-P
13:28:36 <johnw> shapr: Ok, now re-clone https://github.com/jwiegley/haskell-mode
13:28:51 <shapr> ArtVandelay: if it's not written in Haskell, you should ask on another channel, as it's off-topic here.
13:29:08 <shapr> Though it may be on-topic on #haskell-web
13:29:10 <nand`> ArtVandelay: I don't see a thing on your website
13:29:15 <nand`> if that helps
13:30:03 <typoclass> E0F: pack can convert from String to ByteString, i think. as for \", i bet you're doing 'show' on those strings ...
13:30:06 <typoclass> > show "abc"
13:30:08 <lambdabot>   "\"abc\""
13:31:21 <roconnor> ion: I accidently summited the patch to your wiki instead of edwardk's wiki
13:31:27 <edwardk> ah
13:31:46 <nand`> > map (('"':) . (++['"'])) ["FOO", "BAR"] -- I think it's rather this
13:31:48 <edwardk> ion: does my version of the wiki let you commit directly?
13:31:48 <lambdabot>   ["\"FOO\"","\"BAR\""]
13:31:54 <ion> roconnor: Oh, so that’s where it came from. :-)
13:32:10 <nand`> > map (tail . init) $ map (('"':) . (++['"'])) ["FOO", "BAR"]
13:32:11 <roconnor> then I figured if I updated edwardk's wikit the same way you'd end up in patch hell
13:32:12 <lambdabot>   ["FOO","BAR"]
13:32:15 <roconnor> so I left it bee
13:32:20 <ion> edwardk: I don’t think i can push to your wiki’s git tree. I’ll try.
13:32:37 <E0F> thanks for all the answers, i'm gonna try all these
13:32:43 <edwardk> about ready to release 1.8
13:32:50 <roconnor> *be
13:33:05 <ArtVandelay> http://perstaweatherstation.appspot.com/ you dont see anything there?
13:33:08 <shapr> johnw: Your eval-after-load "haskell-doc" would fit in examples/init.el, that's where I look for new ideas.
13:33:09 <nand`> E0F: they're all reformulations of what marcot gave you
13:33:15 <ArtVandelay> nand: http://perstaweatherstation.appspot.com/ you dont see anything there?
13:33:18 <shapr> ArtVandelay: Dude, if it's not writen in Haskell, it's off topic here.
13:33:27 <ion> ERROR: Permission to ekmett/lens.wiki.git denied to ion1.
13:33:31 <E0F> just for info : I'm trying to do Project Euler's problem 22 with ByteStrings, the Haskell wiki uses String so I wana see if ByteStrings will make an improvement
13:33:37 <edwardk> damn
13:33:40 <E0F> nand`: sure but it's very instructive
13:34:15 <edwardk> ion: try now
13:34:16 <ReinH> Does anyone have Fifteen Years of Functional Pearls? http://dl.acm.org/citation.cfm?id=1159832&dl=ACM&coll=DL&CFID=138602874&CFTOKEN=73301154
13:34:49 <mm_freak_> absence: there will be a 'next' combinator like:  w1 `next` w2
13:34:53 <typoclass> E0F: if you put some code on hpaste, folks will give you feedback :) that kind of thing helps me a lot regularly
13:34:57 <mm_freak_> absence: as soon as w1 inhibits, it will switch to w2
13:34:59 <typoclass> @where hpaste
13:35:00 <lambdabot> http://hpaste.org/
13:35:11 <ion> edwardk: Alright, seems to work.
13:35:20 <edwardk> ion: i had to flag you as a collaborator
13:35:21 <ion> % git push upstream master
13:35:21 <mm_freak_> absence: then there will be a 'for' combinator that will run the wire for a given amount of time and then switch to 'never'
13:35:22 <ion> Everything up-to-date
13:35:52 <mm_freak_> absence: for 4 w1 `followedBy` for 7 w2 `followedBy` w3
13:35:56 * ion kills his fork.
13:36:17 <mm_freak_> absence: i don't know exactly what to call this "next"/"followedBy" combinator yet…  i want a short name
13:36:26 <E0F> typoclass: thank you :) I'll first try to make something working and as fast as possible though
13:36:26 <mm_freak_> perhaps something like ~>~
13:36:42 * kuribas would like to have "Pearls of Functional Algorithm Design"
13:37:15 <mm_freak_> absence: an FRP clock might then look something like this:  clock t = for 1 t ~>~ clock (t + 1)
13:37:39 <nand`> mm_freak_: is this about netwire?
13:37:46 <mm_freak_> nand`: yeah
13:38:12 <nand`> mm_freak_: do you know where I can find examples of netwire in use?
13:38:36 <timthelion> Anyone know how to get the current processes PID?
13:38:58 <mm_freak_> nand`: i know that some people use it, but i'm not sure whether others use it in production…  personally i do, but there is nothing public AFAIK
13:39:15 <nand`> mm_freak_: I see. Not even instructive examples / demos / tutorials?
13:39:22 <nand`> I'm having a hard time thinking of use cases for it
13:39:28 <mm_freak_> nand`: there is only the wiki page, which is far from comprehensive
13:40:05 <typoclass> timthelion: check this http://www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/System-Posix-Process.html#v%3AgetProcessID
13:40:06 <MostAwesomeDude> Hey, how does one do G
13:40:12 <MostAwesomeDude> Urg. SDL + GL, I mean to say.
13:40:20 <MostAwesomeDude> Is it possible? Fast? Enjoyable?
13:40:28 <ArtVandelay> can i list all funs in an imported module in ghci?
13:40:52 <typoclass> ArtVandelay: yes, use ":browse" or ":browse Data.Blah.Something"
13:41:07 <ReinH> disregard work acquire functional pearls
13:41:19 <timthelion> typoclass: thanks!
13:42:05 <mikeplus64> MostAwesomeDude: yeah, the SDL and GL bindings are fine
13:42:21 <ArtVandelay> Why the whole !r :? !i for Data.Complex? Why not just Complex 3 5 ?
13:42:24 <edwardk> uploaded http://hackage.haskell.org/package/lens should look a lot better
13:42:26 <mm_freak_> nand`: think of a system composed of many components that evolve individually and have local state…  this is probably a reactive system
13:42:37 <edwardk> ArtVandelay: looks prettier
13:42:54 <edwardk> and i guess they planned on a lot more people using them ;)
13:42:59 <ArtVandelay> can i allow bangpatterns in ghci?
13:43:06 <edwardk> :set -XBangPatterns
13:43:14 <MostAwesomeDude> mikeplus64: So I use the OpenGL package, right?
13:43:17 <edwardk> you can add that to your .ghci as well
13:43:20 <mm_freak_> nand`: you recognize a reactive system by the fact that you update it in individual instants and that the components have local state
13:43:28 <mikeplus64> MostAwesomeDude: yeah
13:43:44 <mikeplus64> and SDL for windowing (although you could also use glut)
13:43:54 <mikeplus64> (or glfw)
13:43:56 <mm_freak_> nand`: this is how you might represent a component:  data LocalState a b = forall s. LS s ((a, s) -> (b, s))
13:44:08 <mm_freak_> nand`: LocalState is a Category and an Arrow
13:44:13 <mm_freak_> and an Applicative
13:44:15 <MostAwesomeDude> mikeplus64: Okay, sweet. Are there any useful toolkits on top of this, or do I get to build my own stuff as I need them?
13:44:28 <edwardk> roconnor: kinda wish i'd named focus 'zoom' ;)
13:44:45 <roconnor> :/
13:44:47 <mikeplus64> MostAwesomeDude: not really, although there are other SDL packages
13:45:00 <edwardk> just because then i could name the other operation on Lensed 'pan' ;)
13:45:08 <mikeplus64> MostAwesomeDude: if all you want is 2D then you might want to look at gloss/gloss-raster though
13:45:26 <nand`> edwardk: ‘focus’ sounds better because of the connection to, well, actual lenses
13:45:31 <nand`> mm_freak_: so far so good
13:45:40 * hackagebot lens 1.8 - Lenses, Folds and Traversals (EdwardKmett)
13:45:45 <ArtVandelay> why does abs $ 3 :+ 4 return a complex nbr?
13:45:54 <ArtVandelay> > abs $ 3 :+ 4
13:45:55 <byorgey> @type abs
13:45:55 <edwardk> well, zooming, zoom lenses, etc
13:45:55 <lambdabot>   5.0 :+ 0.0
13:45:56 <lambdabot> forall a. (Num a) => a -> a
13:46:05 <nand`> mm_freak_: it looks to me like I can use this to model a ‘pipeline’ where each component has local state
13:46:21 <MostAwesomeDude> mikeplus64: Okay, that's fine. I'm not afraid of doing GL.
13:46:21 <ReinH> Fun of Programming, new from $302.01
13:46:23 <ReinH> sigh
13:46:25 <donri> so apparently infix functions must take two arguments but operators don't?
13:46:27 <byorgey> ArtVandelay: abs outputs the same type it gets as input.  It can't be used to give the magnitude of a complex number.
13:46:28 <nand`> mm_freak_: but what about a more complex system of interactions?
13:46:33 <mm_freak_> nand`: not just a pipeline
13:46:40 <MostAwesomeDude> mikeplus64: Hm, gloss seems chill, but it can't be decoupled from GLUT? Wonder if I can hack around that.
13:46:41 <mm_freak_> nand`: again, it's an Applicative =)
13:46:42 <edwardk> ArtVandelay: because they didn't have the notion of complex numbers as the cayley dickson construction of an algebra over a basic field type, and because to do so requires MPTCs and fundeps or type families
13:46:45 <byorgey> ArtVandelay: you can use 'magnitude' for that
13:46:49 <donri> > (3.0 `abs`)
13:46:50 <lambdabot>   3.0
13:46:56 <ReinH> considering acquiring this though http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383/ref=pd_sim_sbs_b_1
13:47:02 <edwardk> and magnitude let them avoid the whole issue
13:47:11 <mm_freak_> nand`: liftA2 (+) (countFrom 0) (countFrom 4)
13:47:16 <donri> only works in lambdabot due to NumInstances :p
13:47:22 <mm_freak_> where countFrom :: Int -> LocalState a Int
13:47:35 <mm_freak_> that gives you the sum of two counters
13:47:35 <edwardk> ReinH: its a great book for after you've absord LYAH and RWH
13:47:38 <edwardk> er absorbed even
13:47:45 <mm_freak_> 0 + 4 in the first instant, 1 + 5 in the second, and so on
13:48:01 <mm_freak_> that's a reactive system and basically how netwire and yampa/animas work
13:48:32 <ReinH> edwardk: awesome, and it's on google play for cheeper
13:48:35 <ReinH> cheaper
13:48:43 <ReinH> I can't spell things
13:48:51 <edwardk> richard bird has a particularly elegant way to think about things
13:50:02 <edwardk> roconnor: btw- been fiddling with composing multiplates with other traversals using arrow notation
13:50:21 <edwardk> roconnor: its kinda evil because the composition runs 'backwards'
13:50:35 <parcs`> ArtVandelay: what should it return?
13:50:47 <ArtVandelay> how can i convert from double to int?
13:50:53 <edwardk> :t floor
13:50:55 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:50:56 <edwardk> :t ceiling
13:50:56 <parcs`> floor, ceil, round
13:50:57 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:50:57 <edwardk> :t round
13:50:59 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:51:01 <mm_freak_> nand`: and one of the great things about netwire 4 is:  you can actually write "countFrom 0 + countFrom 4" =)
13:52:05 <nand`> mm_freak_: sounds like NumInstances
13:52:08 <johnw> I deleted ~/.cabal, to start over with locally installed packages, and now ghc-pkg check warns about a lot of stuff that no longer exists in that directory.  How do I reset ghc-pkg's notions?
13:52:11 <mm_freak_> yeah
13:52:33 <mm_freak_> in netwire 3 you can write countFrom 0 ^+^ countFrom 4, where (^+^) comes from the vector-space package
13:52:38 <c_wraith> johnw: delete ~/.ghc
13:52:42 <parcs`> johnw: ~/.ghc is the important dir to delete
13:52:50 <johnw> thanks!
13:52:57 <ArtVandelay> > msum [Nothing]
13:52:59 <lambdabot>   Nothing
13:52:59 <johnw> ghc-pkg cache is now clean
13:53:00 <ArtVandelay> > msum []
13:53:02 <lambdabot>   No instance for (GHC.Show.Show (m a))
13:53:02 <lambdabot>    arising from a use of `M6610173435...
13:53:03 <nand`> that combinator looks disturbingly happy
13:53:13 <mm_freak_> johnw: when you want to start over, delete:  ~/.cabal/{bin,lib,share} and ~/.ghc
13:53:17 <ArtVandelay> msum is incomplete?
13:53:28 <johnw> now cabal-install's bootstrap.sh is working
13:53:34 <mm_freak_> johnw: that's also how i update…  delete those directories, then do:  cabal update && cabal install world
13:53:43 <johnw> world?
13:53:45 <mm_freak_> yeah
13:53:47 <ArtVandelay> @hoogle msum
13:53:48 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
13:53:48 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
13:53:50 <mm_freak_> see ~/.cabal/world =)
13:53:51 <johnw> is that a meta-package you made?
13:54:01 <mm_freak_> no, it's a cabal-install feature
13:54:05 <johnw> cool
13:54:05 <nand`> ArtVandelay: it isn't
13:54:22 <nand`> > msum [] :: Maybe Int
13:54:23 <lambdabot>   Nothing
13:54:25 <monochrom> "cabal install world" installs what you have historically installed
13:54:27 <ArtVandelay> why doesnt ghci give error when it faisl imports? oh wait lazy imports?
13:54:31 <johnw> ooh, very nicE!
13:54:41 <monochrom> no, not nice if you think it through
13:54:44 <nand`> ArtVandelay: what ver of ghci?
13:54:49 <johnw> as in, better than what I had before
13:54:56 <mm_freak_> johnw: more technically it installs all packages in ~/.cabal/world
13:55:05 <monochrom> "cabal install world" is a kind of undo-start-over
13:55:23 <johnw> cabal install 7days-in-7mins
13:55:24 <geekosaur> ArtVandelay, there's a known bug in some ghc versions
13:55:32 * nand` has never deleted ~/.ghc <- why do people need to do this sometimes?
13:55:49 <mm_freak_> nand`: when i update, i don't want leftover packages
13:56:01 <shapr> nand`: cabal dependencies become completely broken
13:56:04 <shapr> as far as I can tell
13:56:09 <monochrom> so, you had junks that caused you problems. you start over. then you "cabal install world" to... bring in junks that caused you problems? great way to waste electricity
13:56:10 <geekosaur> nand`, when cabal has diamond dependency-d your package database into oblivion
13:56:15 <johnw> can I ask cabal to install documentation for a package it has already installed?
13:56:23 <monochrom> no
13:56:23 <geekosaur> which older versions were far too happy to do
13:56:33 <ArtVandelay> nand: 7.4.1 doesnt say anything(on ubuntu) 7.0.4 does on windows
13:56:37 <luite> ArtVandelay: it was a ghci bug
13:56:40 <johnw> found answer: http://stackoverflow.com/questions/1587635/haddock-for-cabal-installed-modules
13:56:43 <geekosaur> yhe, known bug
13:56:45 <nand`> ArtVandelay: I think it was fixed in 7.4.2
13:56:55 <nand`> I'm on 7.4.2 and it definitely errors
13:57:36 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml shows you how you can mess up your libs and need to reset .ghc
13:58:25 <monochrom> note that "--reinstall" is one of them
13:59:13 * nand` has all packages installed globally
13:59:42 <monochrom> I'm wondering if this sequence is a safer way: "cabal unpack it", "cd it-...", "cabal configure", "cabal haddock", "cabal copy"
14:01:01 <monochrom> you can mess up your global libs too
14:01:14 <monochrom> just add --global to most of my scenerios
14:02:49 <roconnor> edwardk: there is nothing evil about backwards composition
14:03:39 <roconnor> I'd argue mathematical composition is the one that is backwards
14:04:29 <edwardk> roconnor: its just particularly weird when you write a function and it uses proc notation and logic proceeds from bottom to top
14:04:52 <nand`> monochrom: I see.
14:05:27 <nand`> monochrom: it surprises me then that I've never run into it, since I wantonly upgrade packages and even GHC itself whenever a new version comes out
14:05:45 <nand`> maybe I'm misunderstanding some interaction
14:05:54 <byorgey> the order of composition in lens makes sense to me, it feels just like using 'semantic editor combinators'
14:06:08 <edwardk> basically looking at things like: (a -> f b) -> (c -> f b) -> Either a c -> f (Either b c)
14:06:14 <edwardk> yes, i love the ordering in lens
14:06:38 <edwardk> er c -> f d)       and -> f (Either b d)
14:06:44 <roconnor> edwardk: I see
14:07:01 <monochrom> if you upgrade GHC, all your past libs do not matter
14:07:10 <roconnor> byorgey: there is a reason lenses feel like using SECs
14:07:13 <edwardk> when tupled (a -> f b, c -> f d) -> Either a c -> f (Either b c)  -- you can use that with arrow sugar
14:07:19 <roconnor> byorgey: lenses are SECs
14:07:31 <edwardk> sets takes a SEC and makes a setter out of it
14:07:37 <edwardk> adjust takes a setter and makes a SEC
14:07:53 <edwardk> but you can do more with traversals, etc. that just sett
14:07:56 <byorgey> ok, fair enough
14:08:12 <edwardk> SECs are one corner of the diagram ;)
14:08:19 <byorgey> oh, I see, right, makes sense
14:08:33 <roconnor> still it took us a while to really see that lenses were SECs
14:08:45 <byorgey> the diagram? is there an actual diagram somewhere I can look at? =)
14:08:50 <edwardk> yes
14:09:01 <edwardk> http://hackage.haskell.org/package/lens
14:09:07 <edwardk> i put a UML diagram of the core of lenses in there
14:09:16 <roconnor> pfft
14:09:18 <byorgey> oh, I see it
14:09:28 * roconnor was expecting a lens cube
14:09:29 <byorgey> a UML diagram!!! =P
14:09:34 <byorgey> I want a commutative diagram
14:09:36 <edwardk> =)
14:09:52 <fryguybob> hehe
14:09:52 <edwardk> all the arrows would be 'id' it'd be boring ;)
14:10:02 <byorgey> ugh, you just gave me flashbacks to my days as a Java coder
14:10:08 <nand`> maybe ignoring everything during the UML classes wasn't such a smart idea?
14:10:25 <edwardk> well, basically i just wanted to show the relationships
14:10:29 <monochrom> the labels "Simple" and "forall m. Monad m" are interesting
14:10:31 <edwardk> its not _quite_ UML, but close enough
14:10:38 <luite> haha haven't seen these for a while :)
14:11:19 <edwardk> monochrom: i didn't want to let the change of type variables on those edges pass uncommented
14:11:39 <byorgey> edwardk: seriously though, that diagram is indeed helpful
14:12:02 * nand` still gets confused by the ‘Simple’ label; aren't b/d on Getter completely polymorphic?
14:12:04 <edwardk> i stopped the diagram there, rather than double down with all the IndexedFoo types which would make it too big
14:12:10 <edwardk> nand`: not any more
14:12:18 <edwardk> 1.8 made them match
14:12:20 <nand`> oh right, you changed that
14:12:30 <edwardk> which is great, the code reads a lot nicer
14:12:42 <absence> mm_freak_: maybe use an operator for next/followBy?
14:12:44 <byorgey> oh right, Indexed =)
14:12:48 <edwardk> and you should never need the extra functionality that existed
14:12:58 <byorgey> is there basically a parallel "indexed" world?
14:12:59 <mauke> "(or an error f that bound doesn't exist)"
14:13:10 <absence> mm_freak_: though i guess that's a bit untraditional compared to rest of netwire :)
14:13:14 <edwardk> byorgey: yep, (modulo isos)
14:13:47 <edwardk> everything indexed can be used as its unindexed equivalent
14:14:12 <edwardk> and for most combinators fooOf there is an ifooOf equivalent for the indexed variant
14:14:22 <edwardk> which gives you access to the index
14:15:07 <edwardk> e.g.  ifoldrOf :: IndexedGetting i (Endo e) a c -> (i -> c -> e -> e) -> e -> a -> e
14:15:23 <yitz> oh, i get to spend thousands of dollars on rational rose again! i haven't had a chance to do that in years!
14:15:24 <edwardk> can read from an indexed fold or indexed getter
14:15:30 <edwardk> yitz: =)
14:15:49 <ArtVandelay> > if [] then 5 else 6
14:15:51 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
14:15:51 <lambdabot>         against inferred type ...
14:15:59 <edwardk> i just hit google and looked for uml diagram generators and found one that let me draw visio-ish diagrams and collaborate
14:16:04 <typoclass> > if null [] then 5 else 6
14:16:06 <lambdabot>   5
14:16:07 <edwardk> the edit link for the diagram is on the wiki
14:16:12 <byorgey> edwardk: oh, nice =)
14:16:15 <yitz> or did they finally fix dia? haven't been following that world since i discovered haskell.
14:16:17 <ArtVandelay> ty typo
14:16:44 <yitz> oh right visio. forgot about that one.
14:17:08 <sclv> preflex: @seen mightybyte
14:17:08 <preflex>  mightybyte was last seen on #ghc 9 days, 2 hours, 41 minutes and 41 seconds ago, saying: -ddump-minimal-imports
14:17:09 <lambdabot> sclv: You have 1 new message. '/msg lambdabot @messages' to read it.
14:17:12 <roconnor> oh the %%~ operator is back
14:17:46 <edwardk> yeah its 'id' with a fancy name
14:18:10 <mauke> I thought that was ($)
14:18:18 <edwardk> id = ($) ;)
14:18:30 <ArtVandelay> what phones have people got haskell running on?
14:18:54 <edwardk> kmc ported it to android, and cale's old company ported it to the iphone
14:19:52 <ArtVandelay> How can msum be complete if it fails on []
14:19:55 <ArtVandelay> > msum []
14:19:56 <Taneb> If GHC goes to JVM, you've got pretty much every modernish phone out there
14:19:57 <lambdabot>   No instance for (GHC.Show.Show (m a))
14:19:57 <lambdabot>    arising from a use of `M3980646061...
14:20:02 <Taneb> :t msum []
14:20:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
14:20:05 <ArtVandelay> oh?
14:20:10 <Taneb> > msum [] :: Maybe ()
14:20:12 <lambdabot>   Nothing
14:20:18 <Taneb> > msum [] :: [()]
14:20:18 <edwardk> > msum [] :: Maybe Double
14:20:19 <lambdabot>   []
14:20:20 <lambdabot>   Nothing
14:20:34 <Taneb> That isn't what I call failure
14:20:39 <mm_freak_> absence: nah, there will be more operators in the new version
14:20:47 <Nereid> :t mempty
14:20:48 <roconnor> I'm finding it increasingly useful though.  Want to update but return some information on the side? (b -> (o,b)) -> (a -> (o,a));  Want update that can possibly fail:  (b -> Either String b) -> (a -> Either String a);  Indecisive about which update you want to make: (b -> [b]) -> (a -> [a]); ...
14:20:48 <lambdabot> forall a. (Monoid a) => a
14:20:57 <Nereid> er
14:21:09 <Nereid> I keep getting monadplus and monoid functions confused
14:21:21 <Nereid> :t mzero
14:21:23 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
14:23:41 <yitz> Nereid: monadplus methods sound like addition: mzero, mplus, msum. monoid methods sound like collections: mempty mappend mconcat
14:23:53 <edwardk> byorgey: i also added a doc motivating the derivation of these style of lenses: https://github.com/ekmett/lens/wiki/Derivation
14:24:06 <edwardk> still adding to it at the end, but wanted to ship 1.8 first
14:24:23 <Nereid> yitz: but when hear "monoid" I think of the thing in math.
14:24:37 <Nereid> both of those things look like monoids to me.
14:24:52 <Nereid> oh well.
14:25:18 <edwardk> Nereid: MonadPlus _is_ a monoid, but it also has laws interoperating with return and (>>=), etc.
14:25:35 <ArtVandelay> how do i get packagne names? like what is the package name for my glut?
14:25:36 <Taneb> In the case of Maybe, it's a different monoid
14:25:40 <Nereid> laws that make it a monoid object in the category of monads or so?
14:25:45 <edwardk> Nereid: (+) and (*) are both monoids as well ;)
14:25:52 <roconnor> edwardk: I SEE A TYPO in %%= in Traversal a b c d in your diagram
14:26:05 <edwardk> roconnor: i'm shocked. ;)
14:26:25 <Nereid> edwardk: they're not monoids without 0 and 1 too ;)
14:26:39 <edwardk> roconnor: what typo?
14:26:49 <edwardk> oh the a ->
14:27:08 <roconnor> oh wait nevermind
14:27:16 <roconnor> I withdraw my captialized remark
14:28:01 <S11001001> roconnor: that's okay I see a different typo, Traversal transposeOf
14:28:05 <edwardk> fixed
14:28:32 <edwardk> this is clearly why haskell needs a UML tool ;)
14:28:35 <EvanR> i hope im not the first to see this
14:28:38 <EvanR> http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags
14:28:57 <EvanR> see the answer with 4432 points
14:29:27 <edwardk> S11001001: fix that one too now =)
14:29:30 <edwardk> er fixed
14:31:22 <roconnor> EvanR: I suspect 4432 other people have seen it
14:31:45 <t7> i cant into html with regex
14:32:45 <avpx> EvanR: Last I did some processing on the SO database dumps, this was the highest-rated post on the whole site. Not sure if it's still true, but I'd imagine so.
14:33:39 <nand`> it doesn't look to me like he's trying to parse HTML with regex
14:33:46 <nand`> so what are all the answers going on about? am I wrong?
14:35:29 <johnw> shapr: an even better version: https://gist.github.com/3308169
14:37:32 <absence> mm_freak_: sounds really nice, looking forward to playing with it :) how far along is it approximately?
14:37:32 <shapr> johnw: That says "try to get the type" if that fails, get the kind" right?
14:37:54 <EvanR> nand`: obviously not important ;)
14:38:04 <shapr> Hm, I'd like to hook that into haskell-process-do-type as well.
14:38:19 <nand`> oh, I think I see what breaks it: <a b="/>">
14:38:28 <monochrom> I agree, the question seems more like "find open tags", which is pretty regular
14:39:16 <monochrom> unfortunately the thread is locked, you can't add to it :)
14:39:30 <nand`> monochrom: the answer with 52 upvotes seems to acknowledge this
14:40:28 <shapr> Can't you parse with regexes as long as backrefs are to patterns instead of matches? I think perl can do that.
14:40:29 <ion> I like those regexp questions. “I need to implement lock-free parallel FIFO… with a regexp. How to do that?”
14:40:40 <monochrom> when someone uses the word "parse", everyone goes crazy about CFG etc
14:40:42 * hackagebot GPipe 1.4.1 - A functional graphics API for programmable GPUs (TobiasBexelius)
14:40:43 <johnw> shapr: yes
14:41:01 <johnw> shapr: I've modified haskell-doc in my fork to have a `haskell-doc-use-inf-haskell' option
14:41:08 <johnw> that way you don't need to advise it
14:41:14 <EvanR> regex caught on fairly easily, is it because its so weird looking and complex to use?
14:41:27 <EvanR> i guess that would put haskell at the top of the charts ;)
14:41:48 <monochrom> it does not matter that the actual job description is "parse consecutive 1's"
14:41:49 <johnw> EvanR: did regex come about in the days when people coded in Forth and TECO?  So do you even need to ask? :)
14:41:58 <johnw> s/did/didn't
14:42:18 <nand`> EvanR: no, it puts C++ at the top of the charts
14:42:31 <monochrom> I think regex caught on because sed, awk, perl promoted it
14:42:50 <levi> Don't forget grep!
14:43:12 <monochrom> of course, it's also almost adequate
14:43:25 <startling> can I get something like lambdabot running locally? specifically I want @src and @pl
14:44:30 <shapr> startling: There was a project called ghci-on-acid that ran lambdabot inside ghci, but I don't know if it's still around.
14:44:46 <monochrom> the idea is you write a few characters to cut down the search space to just 1%, and then you use so other algorithms or yourself to filter further. so, those few characters do not have to be perfect
14:44:57 <nand`> startling: you could just run lambdabot locally
14:45:23 <startling> nand`: would it have to be through irc?
14:45:25 <hpaste> nand` pasted “Lambdabot local transcript” at http://hpaste.org/72882
14:45:26 <nand`> no
14:45:38 <nand`> just install lambdabot and run ‘lambdabot’
14:45:39 <startling> shapr: interesting, will google
14:45:46 <startling> nand`: ...oh.
14:45:50 <shapr> lambdabot also had an xmpp plugin at some point.
14:46:07 <monochrom> so I now think regex caught on because it is a sweet spot of how much you write : how much it cuts out
14:46:38 <shapr> Also, because regexes work quickly with tiny amounts of storage space.
14:46:50 <shapr> That's why sendmail compiled its configuration language directly to regexes.
14:47:15 <mm_freak_> absence: i think i'll just upload the whole thing to github =)
14:47:19 <shapr> I once had a job where the previous admin had deleted the sendmail config file and my boss assigned the task of recreating it from the regex output.
14:47:28 <monochrom> oh haha
14:47:31 <levi> Yow.
14:48:08 <nand`> and thus, company X learned the value of backups?
14:48:55 <johnw> what does "pl" do?
14:48:57 <rosie> Easy question: is it necessary to declare type definitions for functions?
14:49:03 <nand`> johnw: removes points (lambdas)
14:49:04 <shapr> @pl \x -> x + 1
14:49:04 <lambdabot> (1 +)
14:49:09 <johnw> ah
14:49:11 <johnw> an unpl?
14:49:14 <monochrom> not necessary
14:49:17 <nand`> does the opposite
14:49:19 <johnw> damn, just can't type today
14:49:23 <MostAwesomeDude> @unpl (1 +)
14:49:24 <lambdabot> (\ a -> 1 + a)
14:49:24 <johnw> @unpl (1 +)
14:49:24 <lambdabot> (\ a -> 1 + a)
14:49:54 <MostAwesomeDude> @unpl (.).(.)
14:49:54 <lambdabot> (\ i b c f -> i (b c f))
14:50:14 <startling> @unpl foldr (const (1 +)) 0
14:50:14 <lambdabot> foldr (\ _ b -> 1 + b) 0
14:50:16 <typoclass> rosie: nope, ghc infers it almost always. we write type signatures largely for the programmers' orientation
14:50:34 <rosie> typoclass: thank you!
14:50:46 * nand` would have expected \xs -> foldr (\_ b -> 1 +b) 0 xs
14:50:56 <typoclass> (the rule of thumb is, if it's top-level, write a signature, if it's lower-level, you don't have to bother)
14:50:57 <nand`> seems it doesn't do eta expansion in the general case?
14:51:01 <startling> @unpl foldr
14:51:02 <lambdabot> foldr
14:51:02 <rosie> typoclass: what if the declared type definition is erroneous?
14:51:03 <typoclass> rosie: you're welcome :)
14:51:07 <startling> :/
14:51:19 <nand`> @unpl (,)
14:51:19 <lambdabot> (,)
14:51:31 <nand`> @unpl (+)
14:51:31 <lambdabot> (+)
14:51:34 <ion> rosie: GHC infers the type no matter if you declare it or not. If you do declare it, it will work as useful documentation for humans reading the code and GHC will also check that its inferred type matches what you told it it should be.
14:51:43 <nand`> so there are some scenarios it expands and some it doesn't, eg (1 +)
14:51:53 <johnw> sometimes it can't infer due to an ambiguity, however
14:51:54 <typoclass> rosie: ghc will yell at you. so the signature is a way to cross-check things and make sure you got it right
14:51:54 <startling> @unpl (1 +)
14:51:55 <lambdabot> (\ a -> 1 + a)
14:52:02 <monochrom> if the type is erroneous, ghc assumes it is correct and calls your code erroneous
14:52:05 <johnw> in which case the signature is meaningful
14:52:08 <rosie> ion and typo class: cool, thanks!
14:52:49 <nand`> rosie: there are also some types GHC cannot infer automatically, but that can't happen without enabling certain language extensions first
14:53:11 <startling> also, the monomorphism restriction can be inconvenient
14:53:19 <johnw> monomorphism?
14:53:27 <nand`> http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:53:31 <monochrom> he's my friend
14:53:48 <typoclass> -XNoMonochromRestriction
14:53:54 <nand`> :)
14:53:58 <MostAwesomeDude> In a nutshell, if GHC tells you that the monomorphism restriction applies, just add an explicit type signature.
14:54:13 <ion> λ> let x = 42  \  λ> :t x  \  λ> :set -XNoMonomorphismRestriction  \  λ> let y = 43  \  λ> :t y  \  y :: Num a => a
14:54:29 <nand`> rosie: conversely, there are some types you *can't* write yourself without enabling certain language extensions
14:54:33 <typoclass> honestly, i don't know what the big deal is. everyone just turns off the DMR, problem solved
14:54:39 <ion> Beware that y is now pretty much a function.
14:54:43 <MostAwesomeDude> typoclass: Many of us don't.
14:54:55 <startling> typoclass: DMR?
14:55:11 <typoclass> startling: dreaded monomorphism restriction
14:55:21 <EvanR> y :: Num a => a
14:55:24 <EvanR> y = 9
14:55:27 <EvanR> CAF, not a function
14:55:35 <johnw> CAF?
14:55:42 <startling> typoclass: oh heh
14:56:05 <ion> It will be compiled into something like y :: Num a -> a
14:56:57 <ion> y numImpl = fromInteger numImpl TheInteger9
14:57:28 <ion> (Of course, it can be inlined.)
14:59:20 <nand`> I just disable the MR in ghci, but I leave it on when writing actual files because I provide type signatures for those either way
15:09:00 <autodidakto> I've been collecting good haskell-error-based names for a new band or a new blog. So far i got "Dreaded Monomorphism" (death metal?) and "The Inifinite Type"
15:09:25 <mauke> <<loop>>
15:10:22 <n-dolio> Brain Explosions
15:10:37 <mm_freak_> empty list
15:10:43 <EvanR> autodidakto: evil mangler
15:10:59 <ion> fix error
15:11:02 <SwineFlu> (λ xy.x+y 1) 2) <--- This means xy returns X, why i dont understand is why it beta reductions down to 1+2?
15:11:07 <SwineFlu> also i know i cant use "+"
15:11:09 <parcs`> my brain exploded
15:11:10 <autodidakto> EvanR: Hmm, I'll have to look that one up
15:11:11 <mm_freak_> NoN-eXhAuStIvE
15:11:27 <mm_freak_> NoN-eXhAuStIvE - My Brain Just Exploded
15:11:34 <EvanR> haskell rap
15:11:36 <EvanR> should exist
15:11:40 <autodidakto> heh heh
15:11:46 <johnw> shapr: got another cool thing for you
15:11:47 <n-dolio> Evil mangler isn't really err-related.
15:11:56 <n-dolio> But it's a good band name.
15:12:09 <autodidakto> it would help its image
15:12:16 <mauke> SwineFlu: what?
15:12:29 <SwineFlu> never mind i think i get it now
15:12:30 <shapr> johnw: yah?
15:12:31 <mauke> first off, did you mean (λxy.x+y) 1 2?
15:12:44 <SwineFlu> yes
15:12:51 <johnw> shapr: assuming you have installed hoogle and run hoogle data, this command will query Hoogle for the type of function at point: https://gist.github.com/3308477
15:12:52 <SwineFlu> as in 1 2 would be passed to it
15:12:56 <mauke> SwineFlu: no
15:12:56 <ku> Is Spin like Flask for Haskell?
15:13:06 <SwineFlu> im envisioning that like add(1 ,2)
15:13:06 <johnw> it would be easy to make it use Web hoogle too
15:13:10 <mauke> SwineFlu: ((λx.λy.x+y) 1) 2
15:13:13 <matthiasgorgens> how do you call the programming style, where you don't know what you are doing, but just make random little changes until the compiler is happy?
15:13:22 <johnw> but it's quick way of finding functions with the same type as the function under point
15:13:28 <mm_freak_> matthiasgorgens: PHP
15:13:29 <mauke> SwineFlu: (λy.1+y) 2
15:13:31 <shapr> that is neat, could cut down on duplication
15:13:32 <johnw> matthiasgorgens: spray and pray
15:13:32 <danil> autodidakto: Skolem Escape
15:13:50 <ku> *Snap
15:13:51 <matthiasgorgens> mm_freak_: php has a compiler that gives erros?
15:14:05 <matthiasgorgens> mm_freak_, johnw: the resulting code now looks actually just like if I had a clue.
15:14:11 <mauke> matthiasgorgens: T_PAAMAYIM_NEKUDOTAYIM
15:14:34 <johnw> bleh, ERC with highlight-nicks gets really slow over time
15:14:39 <mm_freak_> matthiasgorgens: yeah, the programmer compiles actual thoughts into this incomprehensible PHP soup
15:14:44 <danil> matthiasgorgens: sure it does, it says things like "unexpected T_PAAMAYIM_NEKUDOTAYIM"
15:14:50 <SwineFlu> mauke, i thought you could lambda abstract a bunch of vars like (λyx. z) so y and x returns z?
15:14:55 <shapr> truly
15:14:58 <autodidakto> danil: has a nice ring to it. thanks
15:15:12 <mauke> SwineFlu: I don't understand "y and x returns z"
15:15:14 <hpaste> “Matthias Goergens” pasted “Arrived at by Brownian motion” at http://hpaste.org/72885
15:15:27 <mm_freak_> matthiasgorgens: anyway, there is a different style, where you program until the types finally fit and the compiler is happy…  i'd call this style "brute-force proving" =)
15:15:36 <mauke> SwineFlu: λxyz.B is syntactic sugar for λx.λy.λz.B
15:15:46 <ku> Is Snap more like Sinatra and Yesod more like Rails?
15:15:49 <SwineFlu> Well i read that line as TAKE y and x and the result would be z
15:15:49 <matthiasgorgens> mauke: in haskell I'd put in some spaces.
15:15:52 <mauke> SwineFlu: which parses as (λx.(λy.(λz.B)))
15:16:03 <mauke> matthiasgorgens: in Haskell λ would be a variable
15:16:28 <parcs`> matthiasgorgens: can't you auto derive those instances?
15:16:33 <matthiasgorgens> mauke: yeah, that's true.  though on a screen spaces help in general. :o)
15:16:47 <matthiasgorgens> parcs`: that's what I suspected all along, but I couldn't make the compiler do that work for me.
15:16:54 <matthiasgorgens> parcs`: I guess I am just too dumb.
15:17:06 <matthiasgorgens> there are instances for ErrorT and ReaderT already defined.
15:17:19 <matthiasgorgens> I just didn't find there composition, or how to derive that.
15:17:30 <parcs`> matthiasgorgens: probably because of the 'Error e' constraint. if you enable StandaloneDeriving, you can do 'deriving instance Error e => MonadTrans (RpcT e)'
15:17:38 <matthiasgorgens> parcs`: I can try that.
15:17:57 <nand`> SwineFlu: see: currying
15:19:06 <matthiasgorgens> parcs`: yeah, now the impossible happened..
15:20:54 <shapr> gah, needs Haskell shell scripting
15:21:09 <johnw> shapr: I've been using Shelly for that
15:21:13 <johnw> shapr: Works rather well
15:21:23 <shapr> I'm convinced...
15:21:34 <johnw> shapr: I like that the default behavior for unhandled failures is to show you what happened and keep an output log
15:21:48 <johnw> it's actually more useful than regular shell scripting in that respect
15:21:51 <shapr> huh
15:22:04 <shapr> I'm tired of my very old code: http://hpaste.org/72884
15:22:15 <shapr> Figured I'd update it to use OSD or something.
15:22:28 <johnw> and Shelly is by that Yesod guy, Greg Weber, who has been very responsive to my e-mails thus far
15:22:39 <parcs`> matthiasgorgens: hah, really? compiler panic
15:22:39 * shapr installs Shelly
15:22:41 <parcs`> ?
15:22:52 <monochrom> hahaha
15:22:52 <matthiasgorgens> parcs`: using the current compiler (7.4.2) I only get a normal error message.
15:22:57 <matthiasgorgens> the panic was from 6.12.
15:23:06 <parcs`> ah. what's the error?
15:23:09 <johnw> the bare essentials (in IO): output <- shelly $ do run "command" ["args"...]
15:23:10 <matthiasgorgens> (which unfortunately, is our production compiler at the moment.)
15:23:19 <johnw> use run_ if you don't need outut
15:23:33 <avpx> I really want to like Shelly, but I've found it to be less lazy than I want
15:23:35 <johnw> and it has runFoldLines to avoid copying entirely in memory
15:23:37 <matthiasgorgens> parcs`: Can't make a derived instance of `MonadTrans (RpcT e)' (even with cunning newtype deriving) cannot eta-reduce the representation type enough
15:23:44 <shapr> Oh I didn't know Ravi got hired by Standard Chartered after he left BlueSpec.
15:23:52 <matthiasgorgens> In the stand-alone deriving instance for `Error e => MonadTrans (RpcT e)
15:24:05 <johnw> avpx: bring it up with Greg!
15:24:13 <johnw> i'd love to see Shelly become bullet-proof
15:24:15 <shapr> avpx: and include examples!
15:24:20 <matthiasgorgens> shapr: which ravi?
15:24:25 <parcs`> matthiasgorgens: bah, lame
15:24:26 <avpx> Yeah, it's a good idea.
15:24:28 <typoclass> johnw: if i'm reading this correctly, you can skip the "do" in your first bit of code :-)
15:24:29 <shapr> matthiasgorgens: nanavati
15:24:38 <johnw> typoclass: yeah, you're right
15:24:40 <shapr> matthiasgorgens: Which Haskell Ravis do you know?
15:24:43 <johnw> typoclass: hlint would have told me that :)
15:24:50 <shapr> I love hlint, and stylish-haskell
15:24:51 <matthiasgorgens> shapr: none.  Just stalking. :o)
15:25:00 <matthiasgorgens> which reminds me, I have to really finish my talk for CUFP.
15:25:02 * johnw greps for stylish-haskell
15:25:25 <shapr> matthiasgorgens: Heh, Ravi Nanavati brought cupcakes his wife made to several of the Boston Area Haskell Users Group meetings, so he deserves at least a free beer when you meet him :-)
15:25:26 <matthiasgorgens> parcs`: I guess I'll write to the mailing list, and ask for advice.
15:25:38 <shapr> or maybe just his wife deserves free beer...
15:25:54 <matthiasgorgens> a good wive is happy to see her husband happy.
15:25:56 <shapr> In any case, community support credits to Ravi Nanavati :-)
15:25:58 <johnw> shapr: does it reformat general Haskell code too?  Or just imports and prefixy stuff?
15:26:00 <sipa> he deserves free beer, which he is free to pass on to his wife?
15:26:08 <shapr> sipa: er. .. I think so?
15:26:27 <sipa> :)
15:27:30 <shapr> johnw: imports, LANGUAGE pragmas, trailing whitespace, tabs to four spaces, optionally does pretty-lambda ASCII to Unicode
15:27:56 <matthiasgorgens> import and pragmas are also done by hlint.
15:28:01 <Peaker> matthiasgorgens, There's EitherT in addition to ErrorT if you don't want the Error constraint
15:28:15 <shapr> johnw: Of course, most emacs users already have (setq-default show-trailing-whitespace t) (add-hook 'before-save-hook 'delete-trailing-whitespace)
15:28:38 <Peaker> shapr, the latter is a great idea, thanks :)
15:28:41 <shapr> show-trailing-whitespace is only irritating in ERC and twittering-mode
15:29:08 <hiptobecubic> why aren't Double and Float instances of Bounded?
15:29:15 <matthiasgorgens> Peaker: thanks.  but that constrains is part of some legacy code.  i don't want to refactor all at once.
15:29:24 <matthiasgorgens> it's a big enough change to move everything to lifted-base.
15:29:38 <matthiasgorgens> (which is why I have to write up instances for monadbasecontrol.)
15:29:48 <shapr> Peaker: props to - https://twitter.com/fitzgen/status/219566993249026049
15:29:53 <hiptobecubic> I guess they go to the ieee "infinity", which is unbounded of course... but that seems pretty lame
15:30:09 <hiptobecubic> there is MAX_FLOAT defined in float.h, for example
15:30:45 <Peaker> shapr, hmm.. downside: You might not want to strip whitespace of other lines to make a bigger VCS diff
15:30:57 <Peaker> shapr, stripping it only from "touched" lines would be nice
15:31:08 <Ralith> hiptobecubic: if it seems lame, make a newtype that doesn't admit infinity.
15:31:18 <matthiasgorgens> Peaker: git can do that automatically.
15:31:21 <shapr> Peaker: I see your point, but I don't care, I want to strip trailing whitespace if I'm working on the code at all.
15:31:40 <danharaj_> edwardk: I want you to know that the lens api is so good that I can use it without understanding it :3
15:31:42 <matthiasgorgens> (or rather, warn you when you make a mistake, so than you can fix it yourself, or just ignore the warning, when it's what you intend to do.)
15:31:48 <Reaga> in java, using recursive methods is computationaly expensive compared to iterative methods.  is this true of haskell?
15:31:51 <edwardk> =)
15:31:56 <edwardk> that was actually my goal
15:32:10 <matthiasgorgens> Reaga: depends on your definitions of recursive and iterative.
15:32:12 <shapr> Reaga: No: http://stackoverflow.com/questions/310974/what-is-tail-call-optimization
15:32:18 <VitamnP> REaga I imagine Haskell has tail call optimization
15:32:20 <edwardk> that you should be able to reach for any tool and apply it to anything it remotely sounded like it should fit
15:32:32 <matthiasgorgens> Reaga: there might be no iteration in haskell, or you might declare tail call optimizition to be iteration..
15:32:37 <Reaga> A recursive method is said to be tail recursive if there are no pending operations to be per-formed on return from a recursive call
15:32:48 <danharaj_> I sadly haven't used the Action api yet because I refactored my code to not use STArrays because the full set of lenses is too good to pass up.
15:32:56 <matthiasgorgens> also tail calls aren't the panacea in haskell that they are in strict languages.
15:33:09 <shapr> matthiasgorgens: Wait, they're not?
15:33:10 * shapr panics
15:33:17 * shapr hugs johnw 
15:33:37 * johnw hugs shapr back!
15:33:43 <matthiasgorgens> shapr: tail calls are strict.  if you want to preserve lazyness, you can't have tail calls.
15:33:43 * shapr boings cheerfully
15:33:50 <shapr> matthiasgorgens: ooh
15:34:06 <matthiasgorgens> shapr: try a tail recursive implementation of map on an infinite list.
15:34:27 <danharaj> @src map
15:34:27 <lambdabot> map _ []     = []
15:34:27 <lambdabot> map f (x:xs) = f x : map f xs
15:34:35 <VitamnP> no gay stuff in this chat please
15:34:44 <danharaj> what's that supposed to mean
15:34:44 <matthiasgorgens> VitamnP: ?
15:34:51 <timthelion> shapr: lazyness can only give you the informational ideal, it cannot preform miricles.  If you return a list Either [a] Error --then [a] is almost necessarilly not lazy
15:34:55 <gertc> i want my zero back http://stackoverflow.com/questions/11889387/haskell-safecopy-example
15:35:14 <matthiasgorgens> timthelion: what do you mean?
15:35:15 <timthelion> VitamnP: what do you have against homosexuality?  Is it somehow off topic?
15:35:23 <shapr> timthelion: It certainly is off topic.
15:35:35 <matthiasgorgens> timthelion: or he means an uplift of spirits?
15:35:37 <shapr> VitamnP: that sort of comment belongs on #haskell-blah
15:35:42 <shapr> VitamnP: but not on #haskell
15:35:53 <danharaj> It doesn't belong anywhere because it is offensive.
15:35:58 <shapr> Fair enough, I'm with danharaj
15:35:59 <danharaj> But that is also off-topic.
15:36:10 <shapr> VitamnP: Please don't say that sort of thing here again.
15:36:10 <matthiasgorgens> troll..
15:36:11 <VitamnP> i come here to discuss programming not men giving each other virtual hugs i find it offensive
15:36:12 <timthelion> matthiasgorgens: if you have to evaluate the whole list to figure out if there is an error of if it's valid...  then you have to evaluate the whole god damn list before you can return even one element of it.
15:36:21 <VitamnP> but nvm offtopic
15:36:34 <stephenjudkins> wow
15:36:34 <matthiasgorgens> timthelion: oh, you implied a semantics with that datatype.
15:36:46 <matthiasgorgens> VitamnP: please troll elsewhere.
15:37:00 --- mode: ChanServ set +o shapr
15:37:11 <shapr> VitamnP: Please drop that particular discussion.
15:37:45 <shapr> What's so awesome about ghc-mod? I've never tried it.
15:37:49 <danharaj> edwardk: what is the name for the clever pattern lens uses to overload composition for indexed lenses and isos and whatnot?
15:37:55 <danharaj> I don't think I've seen it in another library.
15:37:59 <VitamnP> you might be able to intimidate me into silence but that won't help you when you stand before God's throne
15:38:05 <Enigmagic> lol
15:38:06 --- kick: VitamnP was kicked by shapr (Kicked by shapr)
15:38:06 <edwardk> my goal now is to no idea, i just made it up ;)
15:38:07 --- mode: ChanServ set +o mauke
15:38:07 --- mode: mauke set +b $a:VitamnP
15:38:26 <shapr> I guess me getting ops didn't get through to him.
15:38:28 * shapr shrugs
15:38:30 <matthiasgorgens> shapr: thanks.
15:38:32 --- mode: shapr set -o shapr
15:38:38 <edwardk> er
15:38:42 <parcs`> shapr: mainly the flymake integration, i think
15:39:12 <edwardk> my goal now is to flesh out the test suite, the rest of the documentation, write up a robust tutorial and take over the world
15:39:14 <gertc> aaaaaaaaaa -4, zero is the other arrow
15:39:39 <edwardk> i'm trying to add nice doctests for most of the operations
15:40:07 --- mode: mauke set -o mauke
15:40:36 <danharaj> good plan. Seems like lens will be fairly stable by 2.0? Maybe one day someone will be up for figuring out that existential dilemma with monadic setters.
15:41:09 <typoclass> edwardk++ for adding example code (which is something haskell chronically has too little of, imho)
15:41:12 <avpx> johnw and shapr: Looks like Shelly has had a few new versions lately, I may see if my laziness concerns are addressed there.
15:41:27 <edwardk> typoclass: i'm historically the worst of the bunch
15:41:35 <edwardk> but i really want these to be used
15:41:42 <shapr> danharaj: Thanks for pointing that out
15:41:43 <danharaj> "I derived it from first principle what more do you want?"
15:41:56 <mekeor> does pandoc have an irc channel?
15:42:13 <typoclass> edwardk: you just said doctest, you're clearly on the right track now :)
15:42:17 <shapr> Does hledger have an irc channel?
15:42:24 <shapr> I can't figure out how to get started with hledger :-(
15:42:26 <shapr> sm: help!
15:42:42 <edwardk> i have doctests, a small template haskell regression test harness and a quickcheck test suite
15:43:02 <edwardk> easiest way to get started with hledger. 1.) uninstall hledger, 2.) install quickbooks ;)
15:43:20 <shapr> I don't think it runs on Linux.
15:43:25 <shapr> BUT HLEDGER DOES!
15:43:27 <edwardk> thats what vms are for
15:43:28 * shapr boings excitedly
15:43:31 <danharaj> edwardk: I assume taking over the world is code for get into the platform :P
15:44:11 <edwardk> danharaj: not right away. my main goal is to get things used for now. it is pretty extension heavy to get into the platform.
15:44:23 <edwardk> i don't think anything in there uses TH for instance
15:44:40 <danharaj> mm TH is probably the biggest stumbling block. What else does it use that isn't Haskell 2010?
15:44:45 <edwardk> but i wouldn't mind factoring out parts of it into the platform
15:44:54 <edwardk> rank2types for all the aliases
15:45:02 <danharaj> really? I thought rank2types was in 2010 :[
15:45:13 <edwardk> indexed versions use MPTCs
15:45:23 <edwardk> isomorphisms are 98 though
15:45:44 <danharaj> I'm surprised. I thought those extensions were well understood by then.
15:46:00 <edwardk> they are all understood but they have some nontrivial consequences
15:46:43 <edwardk> oh, and the code i use to define the Indexed instance for Index uses an (~) from type families rather than a flexible context to get better type inference
15:47:02 <edwardk> since i already depend on TH that isn't that damning
15:47:03 <danharaj> mm that's a big extension indeed.
15:47:19 <danharaj> Seems like ~ could be in its own extension though.
15:47:20 <Peaker> matthiasgorgens, I'd want git to strip the whitespace completely from lines I touched.. the warnings are annoying to fix manually, only on the lines I touched
15:47:33 <edwardk> well, once you have coercions TFs are easy to write =P
15:47:47 <matthiasgorgens> Peaker: git diff --check gives you warnings only on touched lines, I believe.
15:47:48 <edwardk> bbiab
15:48:02 <Peaker> matthiasgorgens, fixing just those later is a bit of a PITA
15:48:36 <matthiasgorgens> you can also just fix everything with a script once, and make a pure whitespace commit.
15:48:51 <matthiasgorgens> then when you run the script again later, it will only change the lines touched.
15:48:59 <matthiasgorgens> since only those lines could have introduced whitespace errors.
15:50:17 <Peaker> matthiasgorgens, In large projects where lots of people branch around any spurious conflict due to whitespace makes me regret the last 10 whitespace fixes I made
15:51:17 <matthiasgorgens> Peaker: I am glad our large product is pretty modular.
15:51:54 <Peaker> matthiasgorgens, the large project I'm talking about is actually at work, where we use C.. Not sure why modularity helps with this concern
15:52:07 <hiptobecubic> In the section on Automatic Derivation of instances, the file ch06/AutomaticDerivation.hs is wrong isn't it? http://book.realworldhaskell.org/read/using-typeclasses.html  It claims that CannotShow is not an instance of Show, but they obviously derive it in the previous line.
15:52:50 <c_wraith> hiptobecubic: looks like it.
15:52:59 <c_wraith> hiptobecubic: note that there are 14 comments on that code block.
15:53:18 <matthiasgorgens> Peaker: we also use haskell at work.
15:53:19 <matthiasgorgens> and C
15:53:22 <matthiasgorgens> and ruby and python.
15:53:25 <hiptobecubic> c_wraith, oh. i had js turned off. didn't see them
15:53:43 <matthiasgorgens> keeping it modular essentially splits it into smaller subprojects.
15:54:46 <Peaker> matthiasgorgens, if you have lots of code to work with, and people move it around/branch it, then merge conflicts are still a tough problem, whether that large code is monolithic or broken into smaller units
15:57:52 <matthiasgorgens> sure.
15:58:00 <matthiasgorgens> also other dependencies.
15:58:10 <matthiasgorgens> that's one reason we are still on ghc 6.12
15:58:15 <matthiasgorgens> haven't gotten around to updating in a while.
16:10:47 * hackagebot route-generator 0.2 - Utility to generate routes for use with yesod-routes (StephenWeber)
16:35:38 <Reaga> should haskell have been my first lanague
16:35:57 <monochrom> depends
16:36:37 <Cale> It's not a bad first programming language
16:37:55 <orzo> Is there a simple notation to create a new type class that has no extra elements apart from the union of two other type classes?
16:38:28 <monochrom> http://hackage.haskell.org/package/tardis sounds like fun
16:39:00 <monochrom> oh, it is not documented
16:39:39 <monochrom> the github page has a desscription
16:40:02 <aristid> i guess the real documentation is http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
16:40:06 <Ralith> orzo: can't you just have an empty body?
16:40:23 <aristid> orzo: class (Foo a, Bar a) => Zar a
16:40:35 <aristid> you can omit the "where" IIRC
16:43:42 <parcs`> orzo: with constraint kinds you can. it would look like 'type A a = (B a, C a)'
16:46:09 <dmwit> So far, everybody's suggestions have been about the *intersection* of two type classes.
16:46:54 <dmwit> I'm not even sure what the union of two type classes would mean, though, in terms of what methods would be usable. =P
16:46:56 <Peaker> Cale, Haskell as a first language probably makes it hard to learn and enjoy other languages
16:48:02 <ion> s/as a first language //
16:48:12 <ion> err, at least for the “enjoy” part.
16:48:32 <ion> I’m not sure how it makes other languages hard to learn. IO is an imperative programming language.
16:49:01 <monochrom> data Union = forall a. AClass a => ACase a | forall b. BClass b => BCase b
16:49:37 <dmwit> Yeah, that's not bad.
16:50:06 <monochrom> but it's lossy. you lose the concrete type
16:50:47 <ion> Heh, Tardis seems fun indeed.
16:51:04 <monochrom> I like its name :)
17:03:21 <roconnor> is tardis simply the product of the state monad and the reverse state monad?
17:04:55 <MostAwesomeDude> Looks like it?
17:05:42 <MostAwesomeDude> So! Cabal warns me that my package indirectly depends on multiple versions of the same package. This is apparently a Bad Thing. How do I fix it?
17:05:59 <coppro> first try updating all your dependencies
17:06:09 <coppro> second figure out which one is pulling in the old versions and yell at the maintainer
17:06:12 <mauke> @where sicp
17:06:13 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
17:06:13 <lambdabot> classes/6.001/abelson-sussman-lectures/>
17:06:19 <mauke> :-[
17:06:32 <mauke> http://www.vex.net/~trebla/haskell/sicp.xhtml
17:06:38 <hpc> heh, the wizard book
17:06:40 <dcoutts_> MostAwesomeDude: try: cabal install --dry-run, rather than cabal configure
17:07:10 <MostAwesomeDude> dcoutts_: This is a library I'm developing, BTW.
17:07:17 <dcoutts_> that's fine
17:07:19 <MostAwesomeDude> So I kind of just want to build it and not install it.
17:07:33 <MostAwesomeDude> install --dry-run doesn't complain.
17:07:44 <mauke> @where+ sicp http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | "Structure and Interpretation of Computer Programs"
17:07:44 <Peaker> ion, learning a language when it is tedious rather than fun is hard
17:07:44 <lambdabot> I will remember.
17:07:49 <dcoutts_> doing "install" will allow the solver to do things like installing different dependencies, where as configure forces it to stick to the versions of things that are already installed
17:08:01 <dcoutts_> MostAwesomeDude: you can use --only-dependencies
17:08:25 <startling> what's the trick to get readline to install on os x?
17:08:29 <dcoutts_> MostAwesomeDude: and --dry-run -v, you can see what changes it's going to make
17:08:40 <MostAwesomeDude> Hm.
17:08:59 <MostAwesomeDude> Well, okay, it appears to be building things again. Yay.
17:10:09 <dmwit> ?where sicp-cabal
17:10:09 <lambdabot> I know nothing about sicp-cabal.
17:10:20 <dmwit> ?where+ sicp-cabal http://www.vex.net/~trebla/haskell/sicp.xhtml
17:10:20 <lambdabot> Okay.
17:11:03 <dmwit> Is there a reverse-where search?
17:11:08 <dmwit> Like ?reverse-where trebla
17:11:20 <dmwit> =)
17:12:53 <tibbe> dcoutts: we're looking at having cabal test/bench imply both configure/build and also take the configure options (just like cabal install)
17:13:07 <tibbe> dcoutts: thomas tuegel has a patch out for review that makes that change
17:13:30 <tibbe> dcoutts: I told him to email cabal-devel to make sure we're not breaking some use case we're not aware of (like distro packaging)
17:13:33 <dcoutts_> tibbe: yes it should do a configure if needed. Less sure about all the config options.
17:14:05 <tibbe> dcoutts_: I think the configure options are neccesary if we want to move towards a simpler user model
17:14:24 <dcoutts_> tibbe: why not just use configure if you need any non-default options?
17:14:42 <dcoutts_> tibbe: combined with configure options being persistent
17:14:48 <tibbe> dcoutts_: right now I always have `cabal configure --some-flags && cabal build && cabal test` in my command history since there's no case where I don't want all the 3 to go together
17:14:56 <XexonixXexillion> Is there an idiomatic way of getting keyboard input in AFRP?
17:14:58 <tibbe> dcoutts_: it's a more stateful system
17:15:15 <tibbe> dcoutts_: if cabal test takes the configure flags it's totally selfdescribing
17:15:25 <dcoutts_> tibbe: why do you need to reconfigure in that use case?
17:15:35 <dcoutts_> tibbe: if you're not changing any config options
17:15:38 <tibbe> dcoutts_: if you run the same cabal test command later you can expect exactly the same thing to get built and run
17:16:03 <tibbe> dcoutts_: I might not remember how I configured things last time
17:16:44 <dcoutts_> tibbe: my concern is that there's just loads and loads of config options
17:16:59 <tibbe> dcoutts_: but there are very few test options :)
17:17:04 <dcoutts_> yes exactly
17:17:16 <tibbe> dcoutts_: so you're afraid users might not see the test options?
17:17:19 <dcoutts_> so you'll never find them
17:17:20 <dcoutts_> right
17:17:24 <tibbe> dcoutts_: we can try to improve the UI then
17:17:39 <tibbe> dcoutts_: how about each flag has an associated category and we list flags under category headings?
17:17:49 <dcoutts_> that'd help
17:17:49 <tibbe> dcoutts_: (I've seen such a system before, it works pretty well)
17:17:56 <tibbe> test options:
17:17:59 <tibbe> --foo
17:18:01 <dcoutts_> tibbe: note that it'll be stateful anyway with local config files
17:18:02 <tibbe> --bar: asdasd asdasd
17:18:31 <tibbe> dcoutts_: you mean the config files were you set: bar-pkg == 1.0, bar-pkg +bla-flag?
17:19:12 <tibbe> dcoutts_: I imagine those config files would be in source control and thus as long as you check out the same version as someone else your build command will do the same as theirs
17:19:22 <knrafto> \quit
17:19:26 <dcoutts_> tibbe: sure, but it is stateful
17:19:45 <dcoutts_> tibbe: which is fine, don't get me wrong
17:19:50 <tibbe> dcoutts_: sure, but it's more obvious state than the one configure sticks in it's file
17:19:54 <tibbe> but yes
17:20:00 <tibbe> well, the source code is also state :)
17:20:10 <tibbe> but at least it's tracked by the source control
17:20:16 <tibbe> and so will this new config file
17:21:23 <dcoutts_> tibbe: I'd been pondering having a more stateful UI where we record the configure flags in a user-visible file and those persist until you explicitly use other config flags
17:21:27 <tibbe> dcoutts_: I would like to understand how distros use cabal a bit better, so we don't break any of their use cases
17:21:46 <dcoutts_> tibbe: this would help with the issue where you do:  cabal configure --blah; cabal build; cabal install
17:21:58 <tibbe> dcoutts_: even if we did, I still think I prefer to: cd <project I want to work on>; cabal test
17:22:09 <dcoutts_> tibbe: so long as you don't break Setup.hs then it's fine, the distros do not use the cabal binary
17:22:25 <tibbe> dcoutts_: we're not touching Setup.hs
17:22:34 <kamatsu> anyone had any luck with SublimeHaskell?
17:22:59 <dcoutts_> tibbe: I mean the Cabal lib, so people invoking builds via Setup.hs
17:25:53 <Reaga> is haskell all about recursion?
17:26:21 <monochrom> maybe
17:26:38 <amindfv> Reaga: It's built on top of it, but you don't actually need to use it much in practice
17:26:50 <Cale> Reaga: Usually you want to avoid writing things recursively, and use higher-order functions instead.
17:27:01 <Reaga> recursion is good though
17:27:05 <monochrom> it is an unclear question
17:27:07 <amindfv> it's like how architecture is built on carpentry
17:27:09 <Cale> Using explicit recursion is admission of defeat
17:27:17 <Reaga> Cale:  ???????????
17:27:28 <monochrom> ok, the two of you can dance
17:27:46 <Reaga> recursion is admission of defeat? how can u s ay that
17:27:55 <Reaga> uve betrayed us all
17:29:00 <Cale> Either you don't understand your algorithm well enough to break it down into higher order functions, or you need to write the thing recursively to expose operational details for hand-optimising things.
17:29:14 <Cale> Either way, it's kind of like giving up on having a nice program.
17:29:40 <XexonixXexillion> Cale: Is using fixed point recursion cheating?
17:30:07 <Cale> XexonixXexillion: heh, good question
17:30:10 <hpc> XexonixXexillion: only if you don't need it
17:30:25 <hpc> fix makes a great tool for memoization, for instance
17:35:18 <chilldill> hello
17:35:25 <shapr> hiya
17:35:33 <chilldill> so, what exactly is this?
17:35:43 <shapr> This is a chat channel for the Haskell programming language.
17:35:47 <shapr> chilldill: Are you learning Haskell?
17:35:50 * hackagebot FixedPoint-simple 0.1 - Fixed point, large word, and large int numerical representations (types and common class instances) (ThomasDuBuisson)
17:36:05 <chilldill> I more want to know what it is and know what it does?
17:36:18 <shapr> chilldill: Are you familiar with other programming languages already?
17:36:29 <chilldill> No, but interested.
17:36:47 <shapr> In that case, you may find http://tryhaskell.org/ to be a short and sweet intro
17:36:54 <shapr> Or you could read one of the free online books
17:36:56 <chilldill> Thanks a lot
17:36:57 <shapr> @where lyah
17:36:57 <lambdabot> http://www.learnyouahaskell.com/
17:37:06 <ion> Haskell is mainly for computing the Fibonacci sequence over IRC.
17:37:07 <shapr> chilldill: and you are free to ask questions here when you have them
17:37:21 <chilldill> I'll go look at them. I'll see you later. Thanks for the info
17:37:27 <shapr> sure, feel free to ask more questions!
17:42:05 <luksow> it's always nice to meet people interested in haskell :)
17:43:59 <shapr> luksow: I agree!
17:44:40 <luksow> shame it's not very popular in my country.. I would like to see some conferences, uni communities and stuff
17:45:13 <luksow> not to mention interesting projects going on in the area ;)
17:45:34 <dgpratt> so the so called 'impedance mismatch" between relational and OO is a well known issue; what do we think, is this a problem for Haskell as well?
17:45:50 * hackagebot unix-time 0.1.1 - Unix time parser/formatter and utilities (KazuYamamoto)
17:45:52 * hackagebot hakyll 3.4.1.0 - A static website compiler library (JasperVanDerJeugt)
17:47:26 <luksow> dgpratt, I had to google this term, never head it before
17:48:12 <luksow> btw I think that rdbms are mismatched with everything
17:48:49 * geekosaur has the feeling RDBMSs are more like Prolog than other languages, thus making them an impedance mismatch with most other languages
17:49:26 <ion> I’m completely against people being interested in Haskell. We must avoid success at all costs!
17:49:52 <dgpratt> geekosaur: interesting thought
17:50:21 <dgpratt> ion: that ship has sailed and you know it!
17:53:20 <edwardk> after all they can write idiomatic looking oop code in haskell now ;)
17:53:36 <geekosaur> sailed, returned, and matured into a fleet
17:53:45 <dgpratt> pretty soon folks are gonna start hpaste-ing code into this channel with obvious SQL injection vulnerabilities and copy/pasted code all over the place
17:53:51 <edwardk> and that fleet came back and sacked the village
17:55:35 <c_wraith> edwardk: by the way, will the new lens package officially supersede the keys library?
17:55:40 <edwardk> yes
17:55:49 <c_wraith> nice
17:55:54 <edwardk> i will slim keys way way down if nothing else
17:56:11 <edwardk> is already subsumed representable functors
17:56:16 <edwardk> er it already
17:57:05 <tibbe> dcoutts_: sorry had to get off the shuttle
17:57:20 <dcoutts_> np
17:57:27 <edwardk> tibbe: so when does unordered-containers go into the platform? ;)
17:57:38 <dcoutts_> tibbe: earlier, I was referring to the Cabal lib, so people invoking builds via Setup.hs
17:58:01 <tibbe> dcoutts_: right, so these changes are to the cabal-install binary
17:58:03 <edwardk> i want to make instances for hashmap and hashset in lens but i'm restricting myself to platform packages for now
17:58:13 <dcoutts_> tibbe: ok, so no effect on distros
17:58:44 <tibbe> edwardk: when we have change the process so it doesn't make maintainers want to kill themselves (mea cupla: I pushed for this process to begin with, not understanding it wasn't applicable in its new context)
17:59:00 <edwardk> fair nuff
17:59:16 <dcoutts_> tibbe: as I was saying earlier, the use case I'm mainly thinking of where some degree of persistence would help is: cabal configure --blah; cabal build; cabal install
17:59:53 <dcoutts_> tibbe: you'd have the same issue if you make test etc take all the config options
18:00:03 <tibbe> edwardk: we wanted to give the community an opportunity to give some input but that privilege is mostly abused to try to mold everything to once wishes
18:00:45 <tibbe> dcoutts_: if we for one second imagine that configure doesn't exist and install, build, test etc all take the configure flags, would there be a need for persistence?
18:01:15 <tibbe> (of configure flags)
18:01:21 <dcoutts_> tibbe: yes, because you still need it for build vs install
18:01:28 <tibbe> I'm not talking about package version constraints which I think we agree will go in a new file
18:01:40 <dcoutts_> tibbe: the idea of separation into configure, build, install phases implies some statefullness
18:01:42 <tibbe> dcoutts_: I would have install imply build (which I think it already does)
18:02:01 <tibbe> dcoutts_: I guess I'm trying to make that statefullness all internal to cabal and undo it in the UI :)
18:02:07 <dcoutts_> tibbe: but currently "install" resets the config state
18:03:20 <dcoutts_> tibbe: and you'd have the same issue if you add config options to any other command
18:03:32 <tibbe> dcoutts_: so if configure doesn't exist, there's no config state, a build followed by an install are two completely independent actions
18:04:02 <tibbe> you could see it as every action resetting the config state, but that's the same as there being no config state
18:04:36 <dcoutts_> tibbe: but nobody expects that. they would think: cabal build --prof-blah; cabal install.  would install with the profiling enabled, where as actually it'll do a rebuild without the profiling
18:05:10 <dcoutts_> tibbe: my point is people do expect a stateful UI. The traditional separation of phases implies stateful config
18:05:36 <tibbe> dcoutts_: I guess Google has managed to untrain me here :)
18:05:46 <tibbe> dcoutts_: I'm used to the opposite in a build system now
18:05:54 <tibbe> dcoutts_: (but we don't really have an install command)
18:06:01 <dcoutts_> tibbe: in a GUI you could make it stateless, or rather explicit config state editable in the GUI. But the traditional CLI UI is stateful.
18:06:02 <tibbe> but only build, test, bench, and some other
18:06:27 <dcoutts_> tibbe: and if you do a test you don't get the same config as the most recent build?
18:06:30 <tibbe> dcoutts_: do lots of people cabal install a package under development?
18:06:42 <tibbe> dcoutts_: my guess is that cabal install is 99% cabal install <package>
18:06:50 <dcoutts_> tibbe: people do do it yes
18:07:32 <startling> someone needs to come up with a catchy symbol for mempty
18:07:38 <startling> oOo
18:07:39 <dcoutts_> []
18:07:52 <startling> :t []
18:07:54 <lambdabot> forall a. [a]
18:08:19 <c_wraith> -XOverloadedListLiterals
18:08:23 <monochrom> nothing
18:08:28 <ion> ∅
18:09:03 <startling> c_wraith, ooh, how does that work?
18:09:11 <c_wraith> it doesn't
18:09:12 <c_wraith> :)
18:09:15 <startling> :(
18:09:18 <ion> -XOverloadedEverything
18:09:29 <startling> -XOverloadedIdentifiers
18:09:34 <Jafet> OverloadOverload
18:09:44 <avpx> -XOverloadedLanguageExtensions
18:09:55 <tibbe> dcoutts_: alright, so what do we do?
18:10:19 <dcoutts_> tibbe: make configure settings temporarily persistent
18:11:06 <dcoutts_> tibbe: so cabal configure --blah, records that in a local file. That lets us reconfigure when needed. It also means cabal install will use the same settings (and so not need to reconfigure if there's no changes)
18:11:44 <tibbe> dcoutts_: what about specifying configure flags as part of e.g. build or test?
18:12:09 <dcoutts_> tibbe: I would simply avoid that. If you need anything non-default then you have to do the configure step.
18:12:34 <tibbe> dcoutts_: how about hpc coverage when running cabal test?
18:12:53 <dcoutts_> tibbe: perhaps that isn't really a config option at all
18:12:57 <tibbe> dcoutts_: we won't manage to simplify the UI if all actions still end up requring configure
18:13:09 <tibbe> dcoutts_: it has to do with how we build things
18:13:24 <dcoutts_> tibbe: avoiding using configure isn't a goal in itself if it complicates other things
18:13:29 <tibbe> dcoutts_: and perhaps more importantly, what about having e.g. cabal build imply install deps? don't we need configure flags then?
18:14:02 <tibbe> dcoutts_: sure, but I would of course argue that it simplifies this. the main argument against getting rid (i.e. not requiring) it seems to be that people are used to stateful UIs
18:14:02 <dcoutts_> when you do build/test from clean, then yes it should configure with the default options
18:14:46 <dcoutts_> tibbe: right, people are used to these stateful UIs
18:14:48 <gienah> tibbe: on gentoo we would not want ./setup build to imply install deps
18:14:51 <dcoutts_> in CLI at least
18:15:07 <tibbe> gienah: sure, I'm only talking about the cabal binary here, not Setup.hs
18:15:17 <gienah> tibbe: great, thanks
18:15:23 <tibbe> dcoutts_: but perhaps that's a bad idea and we should retrain them?
18:15:35 <tibbe> dcoutts_: it's definitely possible
18:16:11 <tibbe> dcoutts_: I've asked around a bit and cabal build today is really this command: cabal install --only-dependencies && cabal configure && cabal build
18:16:20 <tibbe> dcoutts_: I think cabal build should mean just that
18:16:46 <tibbe> "cabal do what I want", instead of "cabal tell me the steps I need to run"
18:16:50 <edwardk> added a ton of examples to the readme on https://github.com/ekmett/lens for folks who don't care to mine the wiki for what the types mean
18:17:02 <dcoutts_> tibbe: that's fine, but it's an orthogonal issue
18:17:19 <mekeor> (this is awesome: instance IsString Integer where fromString = fromIntegral . length)
18:17:21 <gienah> edwardk: awesome, thanks!
18:17:24 <tibbe> dcoutts_: I think the intersection is that once build implies install deps you need configure flags (but I could be wrong)
18:17:43 <Jafet> @hackage acme-php
18:17:43 <lambdabot> http://hackage.haskell.org/package/acme-php
18:17:49 <Jafet> instance Num String
18:18:20 <tibbe> dcoutts_: lets discuss that as well, lets say we don't have build take configure options, would you be find with it implying install deps?
18:18:31 <dcoutts_> tibbe: my point there is that once they want to say something more detailed about some sub-step of the overall thing then they can do that step directly and specify flags for that step
18:18:52 <tibbe> dcoutts_: OK
18:19:07 <dcoutts_> tibbe: maybe. It might rather surprise people.
18:19:16 <dcoutts_> tibbe: perhaps only in a sandbox context.
18:19:17 <tibbe> dcoutts_: I'm willing to hold off on passing the configure flags though and see how far just having build imply configure + install deps gets us
18:19:32 <mekeor> Jafet: hahahahaha
18:19:39 <tibbe> dcoutts_: we could experiment with it only in a sandbox context to start
18:20:11 <dcoutts_> tibbe: in a sandbox / defined environment context it makes a lot of sense, it's just a build target
18:20:29 <tibbe> dcoutts_: so my idea with sandboxes is to make the opt in through a configure option and then some day make it the default if we think it's a good idea
18:21:45 <Veinor> sandboxes in cabal proper?
18:21:52 <mekeor> Jafet: why does it re-export foldr etc?
18:21:56 <tibbe> Veinor: yes, it's a GSoC project this year
18:21:59 <Veinor> nice
18:22:18 <dcoutts_> tibbe: before we can make it default we'd need a mechanism to shift packages built in one environment (e.g. sandbox) into another (e.g. per-user default)
18:22:26 <tibbe> dcoutts_: so long term I hope sandboxes wont be needed (with a nix package store). The semantics should be as if in a sandbox though
18:22:53 <Veinor> nix package store?
18:23:06 <tibbe> dcoutts_: I think once we have immutable package stores and different builds can't affect each other you won't be able to tell if you have a sandbox or not
18:23:29 <dcoutts_> tibbe: the idea of explicit separate environments is still there, irrespective of underlying store mechanisms
18:23:35 <tibbe> Veinor: a package store based on nix-os. the idea is that the package db is immutable and you can have many builds of the same package and version
18:23:48 <tibbe> dcoutts_: what do you mean when you say environment here?
18:23:53 <dcoutts_> tibbe: you can because it's also about what's in the source package index, config flags etc
18:24:03 <dcoutts_> tibbe: http://hackage.haskell.org/trac/hackage/wiki/PackageEnvironments
18:24:19 <dcoutts_>  A package environment consists of:
18:24:19 <dcoutts_>     source package set
18:24:19 <dcoutts_>     installed package store
18:24:19 <dcoutts_>     constraints for package versions and flags
18:24:19 <dcoutts_>     other build configuration (profiling, optimisation, C lib locations etc)
18:24:41 <tibbe> dcoutts_: so if you have the source package index not be a mutable index but rather take --repo=../local/repo build options you cant tell the difference
18:24:51 <dcoutts_> tibbe: so a flexible nix-like store will make things a lot better, but the env notion still exists
18:25:01 <tibbe> dcoutts_: I've always seen the source package index as a mechanism, not a user visible thing
18:25:15 <tibbe> dcoutts_:  I dont think it has too
18:25:28 <dcoutts_> tibbe: it's very user visible, the user gets to decide if they want to include/exclude things from it
18:25:44 <dcoutts_> tibbe: e.g. the "use this local version of foo rather than the one from hackage"
18:25:47 <tibbe> dcoutts_: I don't think they should nor need to
18:26:02 <dcoutts_> tibbe: all the cabal-dev package source stuff
18:26:04 <tibbe> dcoutts_: if you have cabal build --repo=local/thing you dont need to ever talk about the store
18:26:05 <dibblego> @type \f x -> fmap snd $ zip x (fmap (f$) x)
18:26:06 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:26:30 <tibbe> dcoutts_: instead of adding something to the store and then building you mention the thing you want to use while building
18:26:31 <dcoutts_> tibbe: I'm not talking about the store either, I'm talking about the source package set
18:27:26 <tibbe> dcoutts_: I don't think it should be a standalone referencable entity (e.g. add-source) but rather an implicit result of the .cabal file, whatever we call the config file that locks versions etc., and build flags
18:27:38 <dcoutts_> tibbe: your example (cabal build --repo=local/thing) is just specifying that aspect of the environment on the command line
18:27:43 <tibbe> dcoutts_: none of the use cases I mentioned requires a user visible store
18:28:16 <tibbe> dcoutts_: sure, but a follow-up cabal build is not affected by the fact the last cabal build specified  --repo
18:29:19 <tibbe> so I want cabal to be less stateful, not more :)
18:29:45 <tibbe> a build is the function of the .cabal file, spec file, and the flags, nothing more
18:29:46 <dcoutts_> tibbe: yes, if it's in a local config file then it doesn't need to be implicit state
18:30:02 <tibbe> I want the more functional approach :)
18:30:08 <dcoutts_> tibbe: me too
18:30:11 <tibbe> the state is not needed so lets get rid of it
18:30:18 <dcoutts_> I do want an explicit representation of the package environment
18:30:32 <dcoutts_> and builds are pure functions of that environment
18:30:51 * hackagebot lens 1.9 - Lenses, Folds and Traversals (EdwardKmett)
18:31:04 <startling> wow, I'm continually struct by how orthagonal parts of haskell are. <3
18:31:12 <startling> *struck, not that other thing
18:31:24 <dcoutts_> tibbe: and I'm not sure about your statement about a follow-up cabal build is not affected by the fact the last cabal build specified  --repo
18:32:13 <dcoutts_> tibbe: the installed package store is indeed the least important and least user-visible part of the package environment
18:32:14 <tibbe> dcoutts_: I want the explicit representation of the package environment to only exist in RAM in the cabal command when it's running
18:32:23 <dibblego> is this default fmap (<.>) correct?
18:32:26 <dibblego> http://pastebin.com/n1N2BmNU
18:32:34 <mauke> The paste n1N2BmNU has been copied to http://hpaste.org/72891
18:32:42 <tibbe> dcoutts_: if we have explicit environments the two builds in `cabal build; cabal add-source foo; cabal build` are different
18:32:51 <tibbe> dcoutts_: even though they have the same flags
18:33:16 <tibbe> dcoutts_: if we don't have explicit (and stateful) environment they are not (and add-source doesn't exist accept as a --use-source flag to build)
18:33:18 <dcoutts_> tibbe: I don't think that's very consistent. We both agree we want to allow local config files. That covers much of the package environment, really all except the source package set.
18:33:32 <tibbe> hmm
18:33:44 <tibbe> I think that's different
18:34:00 <tibbe> the local config file is both user visible and consider to be part of the project (like .cabal file)
18:34:06 <tibbe> the other state isn't
18:34:24 <dcoutts_> the source package set is also very much part of the local config
18:34:32 <dcoutts_> and user visible
18:34:33 <startling> is there a way Either could be generalized for any number of types?
18:34:39 <dcoutts_> it's not internal hidden state
18:34:50 <startling> maybe using one of those crazy type arithmetic packages
18:34:52 <tibbe> dcoutts_: well the source set is also dependent on what exists on hackage
18:35:18 <dgpratt> dcoutts_, tibbe: do I understand correctly that you are discussing an idea where one could have (in essence) a partially cached copy of Hackage on their local machine and cabal would be able to reference one version or another of a package as necessary?
18:35:22 <dcoutts_> tibbe: yes, it's actually a stack of sets.
18:35:40 <tibbe> dcoutts_: if I want to switch between two versions of a local package I have to add, remove, add and I risk get the DB in some state I don't want, with --use-source flags I cant
18:36:05 <tibbe> dgpratt: think about an unreleased package instead, it's closer to the common use case
18:36:41 <startling> oh, I could do "Either a (Either b (Either c d))". hmmm
18:36:48 <startling> maybe with Fix?
18:36:49 <kamatsu> anyone here use Sublime Text?
18:37:06 <dgpratt> kamatsu: not in anger, but yes
18:37:19 <kamatsu> what about the SublimeHaskell plugin?
18:37:45 <dgpratt> kamatsu: I have a Haskell plugin of some sort...let me see what it is...
18:38:04 <dcoutts_> tibbe: if you want to think of it this way, suppose the local source package index was fully specified on the command line via configure. Then the local config file extends to that package index too. You can still extend/override on the command line.
18:38:14 <dgpratt> kamatsu: yes
18:39:07 <dcoutts_> tibbe: it's just particularly obvious in the case of local source packages that you don't want to have to specify them every time on the command line and you want a way to persist your config.
18:39:28 <kamatsu> dgpratt, does yours work?
18:39:53 <kamatsu> specifically, does it build projects configured with cabal on save as advertised?
18:40:00 <Jafet> > fix ("Either a ("++)
18:40:02 <lambdabot>   "Either a (Either a (Either a (Either a (Either a (Either a (Either a (Eith...
18:40:13 <dcoutts_> tibbe: logically there's the package environment. We can specify all of that on the command line, but it's rather useful to be able to write that environment down in a file.
18:40:30 <dgpratt> kamatsu: hmm...I don't think so, but I may have an earlier version
18:41:34 <Jafet> startling: that doesn't work because you have to mention n type variables whenever you use them
18:41:43 <redscare> I call multiple functions from a main loop, and I need to pass each function a separate state. Right now that's a dictionary in a state monad. Is there a better way?
18:42:06 <Jafet> And n cases
18:42:10 <tibbe> dcoutts_: was away, reading your reply
18:42:20 <startling> Jafet: indeed
18:42:29 <startling> could probably do a TH thing, but meh
18:42:50 <Jafet> Then you lose lots of polymorphism
18:42:50 <tibbe> dcoutts_: I see
18:42:55 <startling> Jafet: yeah
18:42:56 <tibbe> dcoutts_: so I think I agree to some point
18:43:01 <tibbe> dcoutts_: extent
18:43:39 <tibbe> dcoutts_: but I think local.config (this is what I'll call the local config from now on) is not the same as some state in e.g. dist/
18:43:51 <tibbe> dcoutts_: I see local.config as source
18:43:55 <Jafet> If all n types all have the same constraint, you could devise some way to pass the constraint around
18:43:56 <tibbe> dcoutts_: dist/ as artifact
18:44:00 <Jafet> I don't know how constraints work yet
18:44:06 <dcoutts_> tibbe: indeed those are quite different
18:44:19 <tibbe> dcoutts_: also, I image specifying source via search paths rather than by listing e.g. cabal build --repo-dir=~/src
18:44:47 <tibbe> dcoutts_: so I don't mind local.config state. It's obvious that it's there, it will be shared by other developers as it'll get check in together with the source
18:44:56 <dcoutts_> tibbe: yeah, I've always imagined that bit differently in UI terms
18:44:57 <tibbe> dcoutts_: it's visible
18:45:37 <roconnor> upperCaseLens :: Simple Traversal Char Bool
18:45:38 <tibbe> dcoutts_: the other kind of state has actually given me trouble, for example, I don't know how often I forgot that my last configure didn't specify --enable-tests so cabal test fails
18:46:02 <nand`> mm_freak_: what exactly is the (| |) syntax? in particular, x <- (| sample (noise -< ()) |) 0.5
18:46:03 <dcoutts_> tibbe: right, if it were a bit more persistent... :-)
18:46:19 <dcoutts_> tibbe: but also simply re-configuring with tests enabled
18:46:33 <dgpratt> kamatsu: correction: it 'attempts' to build, yes, but so far all I get is "build FAILED"
18:47:56 <tibbe> dcoutts_: right, it just ends up being annoying
18:48:19 <tibbe> dcoutts_: hence I resort to the this long command line that does everything every time, as I then don't have to think about which state I'm in anymore
18:48:35 <tibbe> it's a qualitative difference not to have to consider that state
18:48:41 <mm_freak_> nand`: that's for arrow combinators…  think of:  comb :: A a b -> A a b
18:48:41 <tibbe> it makes things more pleasant
18:48:43 <dcoutts_> tibbe: but it also means you're doing a lot more rebuilding
18:49:00 <dcoutts_> tibbe: especially if you change the source package index
18:49:05 <mm_freak_> nand`: you can now write:  (| comb (f -< 3) |)
18:49:09 <tibbe> dcoutts_: yes, that's unfortunate and should be neccesary (if I have all the deps dont build anything, if the config didn't change, dont rebuild)
18:49:11 <startling> who runs hoogle?
18:49:38 <tibbe> dcoutts_: I'm afraid I have to run. I think this would be a good thing to solve at ICFP (but I somehow also would like my gsoc student to make progress)
18:49:57 <startling> it'd be pretty cool if hoogle had an opensearch document, so I could tab-to-search in chrome
18:49:59 <mm_freak_> nand`: better example:  (| comb (f -< (x, y) |), where x and y are arrow variables
18:50:05 <mm_freak_> uhm
18:50:05 <dcoutts_> tibbe: right, your student doesn't have to solve this
18:50:09 <mm_freak_> nand`: better example:  (| comb (f -< (x, y)) |), where x and y are arrow variables
18:50:23 <tibbe> dcoutts_: depends on which UI he builds
18:50:25 <dcoutts_> tibbe: there's plenty of it that's clear what needs to be done. mechanims if not policy/ui
18:50:31 <tibbe> dcoutts_: right now he's copying cabal-dev:ish
18:50:39 <mm_freak_> nand`: without that you would have to pass the variables to the transformed arrow computation explicitly
18:50:47 <tibbe> dcoutts_: so he's building a stateful mechanism (which is fine)
18:50:55 <tibbe> dcoutts_: I gotta run I'm afraid. ttyl
18:50:59 <dcoutts_> tibbe: btw, I approve of the index command, that's useful in itself
18:51:02 <dcoutts_> tibbe: bye
18:51:15 <tibbe> dcoutts_: great, I will continue the review and get those parts of the changes in
18:51:33 <dcoutts_> e.g. one ought to be able to make a passive/static hackage archive that way
18:51:44 <mm_freak_> nand`: the GHC manual is also a good documentation source for that syntax:  http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
18:57:35 <nand`> ‘without that you would have to pass the variables to the transformed arrow computation explicitly’ <- what would this look like?
19:07:52 <nand`> mm_freak_: also, I don't understand what the argument after (| |) is doing; sampleInt :: Wire e >~ a b -> Wire e >~ (a, Int) b; but the invocation is (| sampleInt (noise -< ()) |) 10000 -- I would have expected (| sampleInt (noise -< ()) 10000 |) or something but the former to me makes no sense
19:08:02 <nand`> actually, neither make sense
19:08:05 <nand`> where's the tuple?
19:09:40 <bringel> How to find the size of an Array?
19:10:39 <bringel> Is it possible in O(1) time?
19:11:03 <geekosaur> it's part of the type, isn't it?
19:11:04 <Saizan> ?type bounds
19:11:06 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
19:11:23 <geekosaur> yeh, that
19:11:28 <Saizan> that's O(1) and calculating the size of the range should be too
19:12:05 <bringel> So numElements is O(1) too?
19:13:28 <bringel> Saizan: thanks s lot
19:13:43 <Saizan> ?type rangeSize . bounds
19:13:44 <lambdabot> forall a e. (Ix a) => Array a e -> Int
19:14:07 <Saizan> that's going to be O(1) for most Ix instances
19:14:23 <nand`> mm_freak_: does it desugar to something like: id &&& arr (const 10000) >>> sampleInt (noise -< ()) ?
19:14:44 <mm_freak_> nand`: i would really just copy what is already explained in the GHC manual
19:14:51 <mm_freak_> this is related to tuples
19:14:52 <nand`> *sampleInt noise
19:15:14 <mm_freak_> (| f (c -< x) |) y
19:15:46 <mm_freak_> passes (x, y) to 'f c'
19:16:00 <mm_freak_> sampleInt takes an additional signal, and that signal is 'y'
19:20:27 <ku> What is better, map/fold/filter or tail recursion?
19:20:59 <ku> @pl a (b (c (d e)))
19:21:00 <lambdabot> a (b (c (d e)))
19:21:39 <ku> @pl f e = a (b (c (d e)))
19:21:40 <lambdabot> f = a . b . c . d
19:21:45 <lukexi> re: sublime text, i have a ghci/live interpretation plugin underway here: http://github.com/lukexi/SublimeGHCi (alpha, but quite handy already)
19:22:10 <lukexi> (clone it into your packages dir, and it adds a ghci menu to Tools where you can learn the key commands)
19:22:12 <mm_freak_> ku: none of them is "better"…  what are you trying to do?
19:28:02 <ku> mm_freak_: which is faster?
19:28:29 <mm_freak_> ku: can't be answered without context
19:28:47 <mm_freak_> ku: the proper solution is usually the fastest solution
19:29:33 <mm_freak_> foldr will be slow for summing up Integers, foldl will be slow and wrong for list mapping, etc.
19:32:15 <aristid> mm_freak_: are there things for which foldl without ' is "right" and fast? :)
19:32:47 <johnny934759> is there natural way to convert "Array (Int, Int) Double" to "Vector Double" or "Vector (Vector Double)"
19:35:48 <mm_freak_> aristid: not sure, but i can imagine cases where the unevaluated thunks might be smaller than the result
19:37:14 <mm_freak_> johnny934759: i doubt it
19:38:17 <johnny934759> mm_freak_: guess i have to go the hard route :(
19:38:36 <redscare> I call multiple functions from a main loop, and I need to pass each function a separate state. Right now that's a dictionary in a state monad. Is there a better way?
19:39:29 <startling> redscare, an association list maybe?
19:39:49 <startling> [(aFn, aState), (bFn, bState)]
19:41:54 <redscare> startling: some functions don't take state though. Isn't searching through alists slow?
19:42:10 <startling> redscare, oh, you're searching through it?
19:42:57 <redscare> startling: well basically I have all these calls to functions in the main loop, but I want to be able to re-order them arbitrarily
19:43:08 <startling> ah, disregard that then
19:43:53 <mm_freak_> redscare: StateT sounds fine there
19:44:04 <mm_freak_> (or State)
19:44:22 <mm_freak_> if you want to get rid of StateT, you should probably change the whole design of your program
19:44:49 <mm_freak_> startling: i believe redscare's question is not about the data structure
19:45:09 <nand`> I can't infer what redscare's code looks like or what he's doing from his question
19:45:35 <startling> what's a nice general-purpose database to use with haskell?
19:45:42 <nand`> ‘calls to functions’ .. ‘re-order them arbitrarily’ ?
19:45:48 <mm_freak_> startling: what's a "database"?
19:45:57 <startling> mm_freak_: indeed. I think i misunderstood redscare a bit
19:46:13 <startling> mm_freak_, a file-backed place to store tables and look up entries
19:46:23 <startling> I don't want any of that hippy redis crap
19:46:25 <nand`> startling: if you need local state you can use something like acid-state
19:46:30 <mm_freak_> startling: acid-state
19:46:41 <nand`> which allows you to, essentially, store your own haskell data type on disc
19:46:48 <nand`> (or over network or whatever)
19:46:48 <redscare> nand`, mm_freak_, startling: this is pseudo-code: "main = do func1; func2; func3; main"
19:46:51 <mm_freak_> and if you insist on tables, you probably want to combine acid-state with IxSet
19:46:52 <startling> nand`, mm_freak_ : interesting, thanks
19:47:01 <nand`> redscare: ah, so this is about evaluating monad actions
19:47:02 <redscare> but only func1 and func3, for example, need state
19:47:07 <nand`> executing*
19:47:35 <mm_freak_> redscare: func1 :: MyMonad (); func2 :: IO (); func3 :: MyMonad ()
19:47:39 <redscare> nand`: well i guess it's about general haskell programming practice. if i need to pass a state around to func1, and a /different/ state to func3, what's the best way to do that?
19:48:03 <mm_freak_> redscare: main = runMyMonad (forever $ func1 >> liftIO func2 >> func3)
19:48:09 <nand`> redscare: you could have func1 / func3 live in different State monads and use focusing or so
19:48:13 <mm_freak_> but that doesn't seem like a good concept
19:48:33 <mm_freak_> redscare: do func1 and func3 interact?
19:48:33 <nand`> focus st1 func1 >> focus st2 func2; where st1 and st2 are lenses from your ‘global state’ to the individual states
19:48:51 <redscare> mm_freak_: nope, totally independent
19:49:02 <mm_freak_> redscare: then you don't want StateT at all
19:49:08 <nand`> eg. if your global state is a Map or list or whatever you could use existing lenses
19:49:25 <redscare> nand`: not familiar with lenses, i'll go read about those. would you say that is the standard way to implement what I'm doing?
19:49:33 <mm_freak_> redscare: as i understand if, you have components with individual local state, which get run independently, but may communicate through some kind of pipe, correct?
19:49:47 <mm_freak_> and they get run continuously
19:49:52 * nand` guesses mm_freak_ is about to suggest netwire :)
19:50:17 <mm_freak_> nand`: if redscare says yes, i'm about to suggest FRP, because this /is/ FRP
19:51:04 <nand`> if redscare says yes I would recommend netwire over State as well
19:51:26 <mm_freak_> netwire might be overkill…  the automaton arrow would suffice
19:51:48 <mm_freak_> netwire comes into play, as soon as you add events to the mix =)
19:51:53 <nand`> where's the automaton arrow defined?
19:52:07 <mm_freak_> either in the 'arrows' library, or define it yourself…  it's short
19:52:20 <nand`> ah, indeed; found it - hoogle wasn't picking it up
19:53:59 <redscare> they can't communicate in my instance. they actually perform almost orthogonal functions, which is the reason that they have totally separate state
19:54:31 <mm_freak_> redscare: liftA3 (,,) func1 func2 func3
19:54:44 <mm_freak_> where:  func1, func2, func3 :: Auto a ()
19:55:17 <mm_freak_> for simple cases you could define Auto as:  newtype Auto a b = Auto (a -> IO (b, Auto a b))
19:55:44 <mm_freak_> this is at least an Applicative, Arrow, Category and Functor
19:56:57 <dfeuer> I'm getting a stack overflow. How can I get the profiler to point to the likely culprit?
19:57:02 <redscare> mm_freak_: thank you, looks like i've got some reading to do
19:57:25 <shachaf> dfeuer: Maybe -xc?
19:57:29 <mm_freak_> redscare: do you understand monads somewhat well?
19:57:37 <shachaf> @where rts-xc
19:57:38 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
19:57:52 * shachaf isn't sure how that works with stack overflows, though.
19:58:01 <dfeuer> shachaf: that seems to work with hc to make weird graphs I don't understand :/
19:58:36 <redscare> mm_freak_: I feel pretty confident with monads, but I haven't gotten to arrows yet
19:58:49 <dfeuer> What does -osuf .p_o do?
19:58:59 <shachaf> -xc does? Are you sure?
19:59:00 <geekosaur> yes but -xc also dumps extra information in case of (most) exceptions
19:59:05 <redscare> mm_freak_: rather, i don't think i've used them. do they have anything to do with kinds? (thinking -> is arrow-like :))
19:59:13 <shachaf> dfeuer: It just makes the .o file be called .p_o.
19:59:16 <mm_freak_> redscare: i have started an arrow tutorial that introduces you into the automaton arrow…  it's not finished, but explains the basics:  http://ertes.de/new/tutorials/arrows.html
19:59:36 <mm_freak_> so far it got positive feedback
19:59:45 <shachaf> redscare: It's not really a natural progression, by the way.
20:00:11 <shachaf> It's not that you start out -> ... -> "learn monads" -> "learn arrows" -> now you know Haskell.
20:00:18 <dfeuer> So that does indeed dump extra info, but I don't know how to read it.
20:00:29 <Jafet> You can now replace -auto-all with -fprof-all
20:00:48 <Jafet> It magically sticks scc in every binding
20:01:15 <dfeuer> Jafet: it's also not a valid option.
20:01:45 <Jafet> -fprof-auto, whatever
20:03:06 <dfeuer> Hmm.
20:03:11 <redscare> shachaf: what is natural? i feel like i have a strong enough grasp of generic functional programming, haskell typeclasses/type-system, and haskell's use of monads
20:13:51 <Veinor> is opengl on os x horribly broken? i seem to recall hearing that somewhere
20:13:58 <pharaun> hello, its me again :p but i'm wondering if what i want to do is easy to do in parsec? basically i'm parsing a header, and if the first 2 bytes are 00, the rest of the header + data is compressed format, is there any easy way i can take the "remaining" input and decompress then feed it back into parsec ?
20:14:10 <startling> Veinor: I never got it to work
20:14:30 <geekosaur> not horribly broken, but it's difficult to use from ghci iirc
20:14:48 <Veinor> but compiled programs work?
20:15:40 <monochrom> pharaun: getInput and setInput may do what you want
20:16:05 <pharaun> monochrom: thanks i'll look at that
20:16:38 <Jafet> monochrom, is SICP still mostly correct for GHC 7?
20:16:45 <monochrom> yes
20:16:58 <Jafet> Deplorable
20:17:00 <geekosaur> Veinor, compiled should work depending on what complications are in your environment (macports' iconv confuses a lot of stuff if it gets pulled in, for example)
20:17:30 <Veinor> hmm. well, i guess one of the advantages of haskell is that it forces me to decouple the view from logic anyway, so...
20:17:42 <mm_freak_> pharaun: if you don't mind another dependency conduit+parsec can do that transparently
20:17:48 <nand`> doesn't force you, just good style
20:18:10 <shachaf> Veinor: Haskell forces you to do that?
20:18:12 <pharaun> mm_freak_: i think i already have conduct for another project but i have not worked with conduit directly, how tough would it be to pick up on conduit?
20:18:33 <Veinor> shachaf: somewhat
20:19:32 <nand`> certainly some libraries are designed that way (eg. gloss), but that's not due to a property of Haskell
20:19:32 <mm_freak_> pharaun: write a conduit that looks at the first two bytes…  if they are 00, it connects itself to (say) the zlib conduit, otherwise it streams verbatim
20:19:48 <nand`> rather it depends on some properties of Haskell (eg. lack of side effects)
20:19:51 <mm_freak_> pharaun: than just stick the parser (without the 00 handling) as the sink
20:20:00 <mm_freak_> s/than/then/
20:20:02 <pharaun> mm_freak_: ahh i see
20:20:45 <mm_freak_> the advantage is that this does the decompression transparently and on the fly
20:20:51 <Veinor> geekosaur: is the opengl badness still present in 7.4?
20:22:01 <geekosaur> um?  no idea.  but there is other badness in 7.4 that may play into it (like, the 64-bit 7.4.1 for OS X is apparently broken and can crash unpredictably)
20:22:06 <pharaun> mm_freak_: that does sound appealing :)
20:22:24 <pharaun> mm_freak_: i'll take a peek, reading up on the docs about it now let's see how hard it'll be for me to pick up on it
20:22:59 <mm_freak_> pharaun: the conduit library isn't that hard to pick up…  you can easily write conduits using the conduitState function
20:23:14 <mm_freak_> pharaun: and for zlib there is the zlib-conduit package
20:23:31 <mm_freak_> so you don't have to write the stream decompression yourself
20:24:07 <pharaun> mm_freak_: just checked, yeah i got the conduit/zlib/etc package
20:24:19 <pharaun> sweet there's a crypto one, that'll make a latter part of the project easier too
20:24:26 <mm_freak_> you probably have something from the yesod project installed =)
20:24:37 <pharaun> yeah i have yesod installed was playing with it
20:24:40 <mm_freak_> conduit is from the yesod guys
20:25:03 <pharaun> how stable is it, i noticed there was quite a bit of shifting around on the api/docs in the intro to it
20:25:08 <aristid> mm_freak_: i think you're no longer supposed to use conduitState
20:25:10 * shachaf is rather concerned about the state of most cryptography packages on Hackage.
20:25:29 <aristid> shachaf: in which way?
20:25:59 <mm_freak_> pharaun: if you want something more API-stable, check out the 'pipes' package…  it has less prefab features, but it's fundamentally more sound, because it uses some concepts from category theory
20:26:05 <mm_freak_> so you can expect the API to be very stable
20:26:07 <shachaf> aristid: For one, there's the thing where people seem to implement them in Haskell.
20:26:27 <shachaf> s/ in Haskell//, for that matter.
20:26:31 <pharaun> mm_freak_: ah i see, i'll probably play with conduits for now and then check out pipes or something
20:27:17 <mm_freak_> aristid: indeed…  haven't written custom conduits for some time =)
20:27:35 <aristid> shachaf: hmm i've never really looked at those internals
20:28:38 <mm_freak_> shachaf: it's not that bad actually, but i wouldn't count too much on the side-channel-safety of them
20:28:50 <shachaf> aristid: OK, the external API is also a bit worrying, if I remember correctly. :-)
20:28:57 <shachaf> mm_freak_: What's not that bad?
20:29:06 <shachaf> Implementing your own cryptography code from scratch?
20:29:12 <mm_freak_> shachaf: the state of the crypto packages on hackage
20:29:22 <aristid> shachaf: so i guess you consider the fact that http-conduit uses this a security risk? http://hackage.haskell.org/package/tls-0.9.8
20:30:29 <shachaf> aristid: I'd be concerned about it (but who am I to be concerned?).
20:30:39 <mm_freak_> one package i don't like in that regard is 'clientsession'…  it worries me that it's widely used
20:30:53 <mm_freak_> it uses skein instead of something like SHA-2
20:31:13 <aristid> mm_freak_: sadly yesod seems to use it by default
20:31:20 <mm_freak_> not only yesod
20:31:29 <pharaun> :S
20:31:34 <ku> Why is hs so addictive?
20:31:42 <mm_freak_> also snap, and there is a happstack package for clientsession
20:31:46 <Clint> it's not like the ssl/tls libraries in C are good
20:31:52 <aristid> mm_freak_: what does "side-channel safety" mean by the way? :D
20:32:00 <pharaun> openssl? isn't that pretty battle tested
20:32:20 <geekosaur> ^^
20:32:20 <mm_freak_> don't worry, it's not broken…  i just never understood why michael preferred the much too young skein over something well established like SHA-2
20:32:23 <Clint> it gets a lot of use
20:32:25 <Clint> but the API is terrible
20:32:27 <Clint> the license is terrible
20:32:33 <mm_freak_> aristid: a good search term is "side channel attack" or "timing attack"
20:32:36 <Clint> it lacks newer TLS support
20:32:48 <pharaun> Clint: yes but when it comes to encryption, you don't want to fuck around unless you are an expert
20:32:48 <mm_freak_> aristid: i expect pure haskell implementations of crypto to be /very/ prone to these attacks
20:32:55 <Vicfred> 
20:33:01 <pharaun> i would in general recommend taking the standard battle tested libraries
20:33:03 <Clint> upstream doesn't understand proper versioning or build systems
20:33:33 <mm_freak_> pharaun: openssl is well tested, but if you ever worked with the API directly, you know why openssl is bad =)
20:33:37 * nand` has used http://hackage.haskell.org/packages/archive/AES/0.2.8/doc/html/Codec-Crypto-AES.html on occasion - does this fall into the category of worrying?
20:33:40 <mm_freak_> crypto software should be /simple/
20:33:44 <aristid> mm_freak_: hmm, that's probably not the easiest attack to do
20:33:54 <shachaf> nand`: Use it how?
20:34:03 <aristid> the gnutls API isn't so terrible IIRC
20:34:09 <Clint> it's less terrible
20:34:14 <pharaun> mm_freak_: i have the luck of *not* working directly with the api :)
20:34:19 <mm_freak_> simplicity is the most important feature of crypto packages…  if the API is as complicated and as terribly documented as openssl, you should be /very/ wary…  it paints a picture of the code quality
20:34:19 <nand`> shachaf: to encrypt short text messages
20:34:21 <shachaf> nand`: That's a kind of low-level API -- using it wrong is as bad as using wrong code right.
20:34:22 <pharaun> mm_freak_: but yes i have heard horror stories :)
20:34:31 <shachaf> nand`: "to encrypt" isn't how you use it.
20:34:40 <mm_freak_> aristid: it's easy enough to do for a determined attacker
20:34:51 <shachaf> That API doesn't do any authentication, so it's probably terrible if you use it on its own.
20:34:55 <aristid> mm_freak_: with or without physical access?
20:35:01 <nand`> wait, maybe I'm looking at the wrong package
20:35:20 <mm_freak_> aristid: without
20:35:22 <JunkBee> What book is preferred for learning haskell?
20:35:27 <Clint> lyah
20:35:27 <pharaun> mm_freak_: thanks for pointing me at conduit, after reading the docs it looks like it'll do what i want ^_^
20:35:31 <dfeuer> So What's the right way to do this?   let npk=n+k in npk `seq` snub_ (x, npk) ps
20:35:34 <mm_freak_> aristid: search for "remote cache timing attack"
20:35:44 <pharaun> mm_freak_: and look like i'll be able to understand/figure out how to use it
20:35:55 <aristid> mm_freak_: i'm not sure if i want to be scared now :D
20:36:00 <mm_freak_> pharaun: if not, there is a tutorial in the yesod book
20:36:18 <pharaun> regarding conduits? mmk looking there now
20:36:29 <shachaf> dfeuer: You could "let !npk = n + k in snub_ (x, npk) ps", I guess?
20:36:31 <nand`> shachaf: I was using public/private key cryptography to authenticate the messages
20:36:48 <shachaf> dfeuer: I have no idea what you're doing, so I don't know the right way to do it.
20:36:52 <shachaf> nand`: ?
20:37:10 <nand`> shachaf: re: “That API doesn't do any authentication, so it's probably terrible if you use it on its own.”
20:37:22 <nand`> also “‘to encrypt’ isn't how you use it.” <- then I must have been using it wrong
20:37:28 <nand`> what do I use it for, if not to encrypt/decrypt?
20:37:33 <shachaf> nand`: "to encrypt" is what you do with it. It's not how you use it.
20:37:42 <dfeuer> shachaf: I was wondering if there was some good way to accomplish that without actually having to bind a variable to force an addition...
20:38:43 <mm_freak_> aristid: an inherent feature of a side channel vulnerability is that the attacker needs access to the side channel…  in the case of timing vulnerabilities the side channel is computation time, which can be measured remotely…  the art is to enforce certain patterns of computation time like cache misses
20:39:02 <dfeuer> In other news, I'm still struggling to find the source of this stack overflow :(.
20:39:19 <mm_freak_> so you send crafted packets to the implementation and measure the time it takes for the response to arrive…  this can be done from around the globe =)
20:40:00 <nand`> shachaf: I don't see the distinction
20:40:29 <mm_freak_> vulnerable (non-haskell) implementations of RSA have been attacked…  entire RSA keys have been extracted over the network (under lab conditions)
20:40:33 <shachaf> nand`: Never mind, then. It doesn't matter.
20:40:59 <aristid> mm_freak_: ok, i think for now if i'm doing HTTPS requests over http-conduit i'm not extremely worried though
20:41:06 <shachaf> nand`: But I'd guess that something about what you're doing is broken.
20:41:14 <aristid> mm_freak_: as a successful MITM would also require other things to fail i think
20:41:32 <mm_freak_> aristid: don't worry too much =)
20:41:38 <aristid> mm_freak_: hmm, but simple eavesdropping might work?
20:41:54 <shachaf> Don't worry too much, but don't trust your "cryptographic" code either.
20:42:07 <mm_freak_> side channel attacks are about crypto primitives…  you extract some working information, which depends on the attack
20:42:09 <aristid> i don't write cryptographic code myself :)
20:42:23 <nand`> shachaf: that's entirely possible, and it was a toy application so no harm done either way; what I was doing is using RSA to exchange AES keys between pairs of clients, then sending messages between said pairs, encrypted using AES
20:42:32 <mm_freak_> mostly keys are extracted, but some attacks also extract plaintext
20:42:36 <mm_freak_> this is really rare though
20:43:02 <pharaun> mm_freak_: so i would have a source that gets data from wherever, then read in first 2 byte, check to whats up, then stream it out or stream it via conduit-zlib ?
20:43:33 <aristid> mm_freak_: i think other attacks are probably easier
20:43:34 <shachaf> nand`: "encrypted using AES"?
20:43:39 <mm_freak_> pharaun: yeah…  if 00, ignore the bytes and pass control to the zlib conduit, otherwise act like the identity conduit
20:43:42 <aristid> mm_freak_: like installing a rootkit on my computer
20:43:51 <mm_freak_> aristid: don't count on it
20:44:05 <aristid> mm_freak_: or just fucking calling the apple hotline :D
20:44:13 <pharaun> heh
20:44:21 <mm_freak_> aristid: an exploit has to be written only /once/ by /someone/ who distributes the exploit =)
20:44:27 <mm_freak_> hehe
20:44:57 <mm_freak_> again, i expect pure haskell implementations to be especially prone to these attacks
20:44:57 <shachaf> nand`: If you're taking your message, passing it to that Codec.Crypto.AES.crypt function, and then sending it off over the network, then yes, it's broken.
20:45:10 <mm_freak_> this is really a case where you should probably interface to C code
20:45:12 <aristid> mm_freak_: the problem is so few things are secure, if you'd really think about it you'd go nuts
20:45:12 <nand`> shachaf: I'm not sure what's puzzling about that. I have a function encrypt :: Key -> ByteString -> ByteString  which I apply to the exchanged key and the plaintext, then the remote end has a corresponding function decrypt :: Key -> ByteString -> ByteString
20:45:20 <nand`> shachaf: then yes, it's broken
20:45:24 <aristid> mm_freak_: you can't sleep in a hotel, the locks are insecure... and so on
20:45:31 <shachaf> nand`: Yep.
20:45:53 <mm_freak_> aristid: other than crypto primitives haskell gives you have the most secure code you have ever seen in the programming wild…  this is really about one particular thing:  crypto primitives
20:46:00 <aristid> mm_freak_: you can't use a home router, it likely has a backdoor, or other blatant insecurities
20:46:03 <mm_freak_> block cipher functions, hash functions, etc.
20:46:32 <aristid> i'm on a more philosophical level right now :D
20:46:40 <mm_freak_> yeah, i figured =)
20:46:55 <mm_freak_> and i don't really agree ;)
20:47:38 <nand`> mm_freak_: (I haven't been paying much attention) Is your only argument against pure-Haskell implementations their relative not-being-tested; or is there some form of fundamental property of Haskell you are implying leads to poor cryptography implementations?
20:48:00 <mm_freak_> nand`: side channel vulnerabilities
20:48:19 <mm_freak_> haskell code is too unpredictable and you can't controll the low level timing/memory behaviour
20:48:26 <mm_freak_> -l
20:48:35 <shysoft> I want to get a job working with haskell. Who should I submit a resume to?
20:48:41 <nand`> ah
20:48:44 <nand`> I see what you mean
20:48:56 <shachaf> nand`: There's both.
20:49:00 <pharaun> its not the crypo itself that is the issue, its side-channel
20:49:01 <mm_freak_> shysoft: first step:  sign up here:  http://www.haskellers.com/
20:49:29 <mm_freak_> nand`: this is basically the reason why you probably shouldn't implement crypto in /any/ high level language
20:49:37 <nand`> shachaf: yeah the former is pretty much always an issue
20:49:37 <mm_freak_> be it haskell, C#, python or whatever
20:49:43 <Veinor> 23:49:07          <mm_freak_> nand`: this is basically the reason why you probably shouldn't implement crypto in /any/ high level language
20:49:46 <Veinor> yeah
20:49:56 <mm_freak_> well, crypto /primitives/!
20:50:04 <Veinor> right
20:50:05 <mm_freak_> you should implement all your crypto in haskell, except the primitives =)
20:50:07 <nand`> mm_freak_: do you think hardware-based cryptography would solve this problem?
20:50:17 <mm_freak_> nand`: either solve it or make it worse =)
20:50:25 <nand`> well-designed hardware*
20:50:34 <mm_freak_> nand`: power usage forms a side channel, which has been exploited in practice
20:50:59 <mm_freak_> to get around that you need constant power consumption, i.e. expensive
20:51:05 <nand`> what about heat distribution
20:51:21 <nand`> probably the circuitry would need to be laid out with that in mind
20:51:27 <Veinor> that's also possible, but harder
20:51:54 <Veinor> for example, you can sample power consumption without messing with the computer, if you're really clever
20:51:56 <mm_freak_> i haven't seen that one being exploited…  heat is very noisy and blurry, so i doubt you can really exploit that at all
20:52:34 <nand`> I imagine it'd be very difficult with CPU-based algorithms, but if all primitives were outsourced to special chips located elsewhere it might be possible; was my reasoning
20:52:57 <mm_freak_> even then heat is too slow and blurry
20:54:55 <pharaun> mm_freak_: primitives? as in the actual hashing, the block rotation, whatever
20:55:02 <pharaun> then composite them together into the actual clipher?
20:55:32 <mm_freak_> pharaun: the actual functions which hash a block, encrypt a block or produce the next block of random bytes
20:55:43 <pharaun> oh k
20:55:52 <startling> how should I represent one of those dumb c configuration things you get by xor-ing a bunch of constants?
20:55:59 <pharaun> mm_freak_: so like the stuff on the new intel aes in the cpu?
20:56:10 <startling> data Configuration = { fieldA :: Bool, fieldB :: Bool } etc?
20:56:26 <Veinor> @pl \(a, b) -> f [a,b]
20:56:26 <lambdabot> uncurry ((f .) . (. return) . (:))
20:56:40 <Veinor> @pl \(a, b) -> f a:b:[]
20:56:41 <lambdabot> uncurry ((. return) . (:) . f)
20:57:21 <mm_freak_> startling: either that or write a monoid
20:57:39 <aavogt> you can also write data Configuration = { fieldA, fieldB :: Bool }
20:57:43 <mm_freak_> startling: data Flags = SomeFlag | SomeOtherFlag | And Flags Flags
20:57:54 <startling> aavogt: oh, nice
20:58:00 <mm_freak_> SomeFlag <> SomeOtherFlag
20:58:03 <startling> mm_freak_: s'true
20:58:19 <mm_freak_> that makes flags composable
20:58:26 <Veinor> mm_freak_: why not data Flag = MyFlag | MyOtherAwesomeFlag; type Flags = [Flag]?
20:58:48 <mm_freak_> Veinor: yeah, that would be equivalent
20:59:02 <mm_freak_> but i prefer to stay in the domain
20:59:20 <mm_freak_> you can also turn the bit record into a monoid, btw
20:59:26 <nand`> you do lose information when moving from mm_freak_'s representation to Veinor's, but I don't think that's relevant
20:59:30 <mm_freak_> and you can provide lenses for the individual flags
20:59:41 <mm_freak_> nand`: not really relevant =)
20:59:43 <nand`> startling: if you don't need an ADT you can just use Ints and Data.Bits directly
20:59:46 <mm_freak_> you lose composition information
21:00:01 <startling> nand`: I want a higher-level API though
21:00:06 <nand`> they form a monoid under bitwise OR and zero
21:00:13 <nand`> fair enough
21:00:21 <mm_freak_> nand`: the bitfield also forms the same monoid and is higher level
21:00:26 <mm_freak_> the bit record that is
21:00:28 <nand`> I was just thinking if your only purpose is to build flags to pass to some dumb API
21:00:31 <startling> I'm not interfacing with C code (I'm writing a binary format) so I don't really care about having a separate "write" function
21:01:40 <mm_freak_> if you want to get /really/ fancy, make a configuration language…  that's two lines of code =)
21:02:01 <mm_freak_> data FlagF = SetFullscreen a | SetOpenGL a deriving (Functor)
21:02:10 <mm_freak_> data FlagF a = SetFullscreen a | SetOpenGL a deriving (Functor)
21:02:13 <mm_freak_> type Flags = Free FlagF
21:02:17 <nand`> :)
21:02:33 <mm_freak_> myFlags = do setFullscreen; setOpenGL
21:02:33 <mm_freak_> =)
21:02:50 <nand`> I'm not sure what you gain with that representation over using the free monoid instead, other than the do sugar
21:03:11 <nand`> myFlags = [Fullscreen] ++ [OpenGL] ++ otherFlags
21:03:21 <mm_freak_> you get a real extensible configuration language
21:03:36 <mm_freak_> of course if you'll never add something other than flags, then you really don't need this
21:03:48 <mm_freak_> i just wanted to point out how easy it is to write a configuration monad in haskell =)
21:03:49 <nand`> yeah fair enough
21:03:57 <nand`> free monads to the rescue
21:04:13 <mm_freak_> yeah…  dozens of instances for free
21:07:01 <nand`> re: interfacing with dumb C APIs, lenses to the rescue!  someFlag = bitAt 4;   myFlags^.someFlag :: Bool; (someFlag .~ True) myFlags; etc.
21:18:33 <dfeuer> I figured it out, I believe.
21:18:40 <dfeuer> Ayep.
21:18:48 <dfeuer> Pretty sure, anyway.
21:18:58 <dfeuer> I was assuming something was too lazy, but actually something is too /strict/.
21:20:01 <nand`> you were assuming the programmer was too lazy, but actually the boss was too strict?
21:27:12 <johnw> @version
21:27:12 <lambdabot> lambdabot 4.2.2.1
21:27:13 <lambdabot> darcs get http://code.haskell.org/lambdabot
21:30:20 <dfeuer> nand`: when I switched from using State to using ST,
21:30:31 <dfeuer> I forgot to pay attention to the fact that that made things stricter.
21:30:50 <dfeuer> So what I thought was producing a stream was instead accumulating a (huge) list.
21:31:24 <dfeuer> Switching to the lazy version of ST solves the stack problem, but murders performance. Therefore, I need to rething just how to do this thing.
21:32:17 <edwardk> nand`: re lenses and dumb c apis: =)
21:35:03 <dfeuer> I wonder if the EU could be convinced to ban C++.
21:35:17 <nand`> that sounds doable
21:35:55 <nand`> well, maybe not the EU. It might pass in some states in the US, notably ones where dihydrogen monoxide was nearly banned or methods for squaring the circle were legally granted
21:36:04 <startling> dfeuer: we could get one of those protections on C++ like they have for foods named after places
21:36:16 <startling> nand`: my new home!
21:36:31 <dfeuer> Speaking of C, I looked at some basic info about the C preprocessor recently, and was again astonished by how incredibly silly it is, compared to, say, syntax-case.
21:36:49 <shachaf> C++ commits the terrible crime of not being Haskell! Ban it immediately!
21:37:02 <c_wraith> isn't the C pre-processor not actually specified?
21:37:09 <dfeuer> shachaf: that's not among its terrible crimes.
21:37:33 <shachaf> c_wraith: It's not?
21:37:53 <nand`> would it be reasonable to say GHC actually implements at least 19342813113834066795298816 different Haskell-like languages? (for various permutations of language extensions)
21:37:55 <dfeuer> I hadn't heard that.
21:38:20 <c_wraith> shachaf: in particular, it has a bunch of corner cases that aren't specified.  (much like C itself)
21:40:41 <danharaj> edwardk: Can filtered be used to create IndexedFolds from Indexed* or do I need to write ifiltered?
21:40:49 <TeruFSX> okay, i'm having some trouble with basics here
21:40:56 <danharaj> Because simply composing it 'forgets' the indexed part.
21:40:59 <edwardk> it needs an ifiltered
21:41:11 <danharaj> Gotcha.
21:41:19 <edwardk> i'd love a patch if you write it ;)
21:41:47 <danharaj> That would be too much motivated to get set up with git and evaluating that thunk would give me a lot of side work :P
21:42:02 <edwardk> =P
21:42:04 <c_wraith> you could just hpaste it. :P
21:42:09 <edwardk> that too
21:42:33 <c_wraith> TeruFSX: what are you having trouble with?
21:42:38 <danharaj> Yes, yes I could. So I will file away an ifiltered thunk in my head and maybe it will get evaluated at some point ;)
21:42:52 <nand`> just unsafeInterLeaveIO it and defer the side effects to background threads
21:42:58 <edwardk> heh as you hope by laziness it forces me to force it first ;)
21:43:13 <c_wraith> danharaj has been added to the spark pool
21:43:19 <c_wraith> and sort of hopes he won't be converted
21:43:30 <danharaj> edwardk: I think library maintainer semantics work on a 'call-by-asked-for-twice' model :P
21:43:36 <edwardk> =)
21:43:55 <TeruFSX> i have a function that does trial division (because i'm a bit of a novice) with type Integral a => [a] -> [a] -> [a], and using last with the result of that function doesn't work.
21:44:11 <danharaj> TeruFSX: can you hpaste.org your code?
21:44:19 <startling> TeruFSX: what does "doesn't work" mean?
21:44:29 <TeruFSX> type mismatch
21:44:39 <danharaj> paste the type error too
21:46:45 <permagreen> Are you using the wrong division function? Because that has bitten me in the ass before
21:49:32 <hpaste> TeruFSX pasted “My code” at http://hpaste.org/72894
21:50:08 <TeruFSX> There it is, partially reconstructed from memory
21:50:40 <nand`> TeruFSX: looks like it's as simple as adding parentheses
21:50:48 <nand`> head (primeFinder [3, 5 .. 10000] [2])
21:51:01 <TeruFSX> i'll give that a shot
21:51:20 <nand`> note that function application is left-associative when left implicit; so your first code was equivalent to ((head primeFinder) [3, 5 .. 10000]) [2]
21:51:23 <permagreen> When in doubt, throw some parentheses at it
21:51:45 <nand`> and ‘head primeFinder’ doesn't make a lot of sense because ‘head’ takes a list and ‘primeFinder’ is a function, not a list
21:51:56 <nand`> as the type error is telling you
21:52:30 <TeruFSX> which the brackets denote, okay
21:57:41 <hpaste> dfeuer pasted “ST merge helper” at http://hpaste.org/72895
21:57:55 <dfeuer> That's the ST thingum I need to lazify.
21:58:41 <nand`> shachaf: reminds me of http://www.lisperati.com/landoflisp/panel57.html
21:58:44 <dfeuer> I need to convert it (and/or add some other functions) to produce a lazy stream.
21:58:50 <dfeuer> Is there a nice way to do this?
21:59:13 <dfeuer> The way I tried was to put a bunch of strictToLazyST calls all through,
21:59:20 <dfeuer> which was not so efficient....
22:00:28 <edwardk> danharaj: i wrote an ifiltered, testing it now
22:01:51 <danharaj> edwardk: are eager implementor semantics standard? :p
22:02:12 <edwardk> nah, i have nonstandard settings on this repo ;)
22:02:26 <scri> > concat [[n-1,n+1]|n<-[6,12..60]]
22:02:27 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61]
22:02:43 <scri> ^^ is there an even more concise way to do that?
22:02:57 <edwardk> the repo has it now, running tests and checking docs, then will hit hackage
22:03:32 <nand`> > [6,12..60] >>= (+1) &&& subtract 1
22:03:34 <lambdabot>   Couldn't match expected type `[b]' against inferred type `(t, t)'
22:03:37 <nand`> :(
22:03:48 <nand`> oh
22:03:52 <dfeuer> Ah.  I have no earthly clue what it does, but unsafeInterleaveST appears to work...
22:03:54 <tertl3> hi
22:04:05 <nand`> > [6,12..60] >>= \x -> [x+1,x-1]
22:04:06 <lambdabot>   [7,5,13,11,19,17,25,23,31,29,37,35,43,41,49,47,55,53,61,59]
22:04:15 <edwardk> danharaj: cabal update and you should see lens 1.9.1
22:04:19 <scri> ah yes... thats what i wanted
22:04:25 <scri> ty
22:04:54 <Ralith> dfeuer: probably best to avoid unsafe calls you don't understand.
22:05:32 <dfeuer> Ralith: it's not /documented/.
22:05:59 * hackagebot lens 1.9.1 - Lenses, Folds and Traversals (EdwardKmett)
22:06:20 <Ralith> dfeuer: some excuse that is!
22:06:39 <dfeuer> It's not an excuse; it's an expression of annoyance....
22:08:50 <Laguana> Hello, is anyone here particularly familiar with TDFA, one of the regex libraries?
22:10:43 <dfeuer> Ralith: I /think/ I sort of understand what it does, and I'm at least 60% sure it's safe to use in this context :P
22:10:54 <Ralith> oh, okay then.
22:11:13 <dfeuer> Also, this is a toy program that doesn't open any files, so it really doesn't matter.
22:12:15 <dfeuer> I'm going to let that be, and focus on why I'm still allocating 232 megabytes, mostly in an array-based heap-down procedure...
22:12:40 <nand`> mm_freak_: will you be continuing http://ertes.de/new/tutorials/arrows.html ? It's super-useful
22:16:07 <donri> way too many commas ;)
22:23:09 <scri> erm, where is the (%) operator located?..
22:23:19 <centrinia> @src (%)
22:23:19 <lambdabot> x % y = reduce (x * signum y) (abs y)
22:23:31 <danharaj> @hoogle (%)
22:23:32 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
22:23:53 <scri> nice!
22:23:55 <pharaun> any way i can make conduit consume all value out of the conduit and return a byteString
22:23:58 <pharaun> or just a string
22:24:16 <pharaun> closest i got was CL.consume -> [bytestring] list and its a mess
22:30:52 <pharaun> hm
22:31:18 <pharaun> i was able to resolve it via -> do b <- conduit stuff, b.fromChunks b
22:31:26 <pharaun> but i wonder why doing >>= wouldn't work
22:31:59 <pharaun> *Main> ((CL.sourceList $ B.toChunks testComp2) $= CZ.decompress CZ.defaultWindowBits $$ CL.consume) >>= B.fromChunks
23:07:00 <pharaun> sure goes quiet :p
23:09:08 <c_wraith> pharaun: oh.. Probably a precedence error.
23:13:29 <mm_freak_> nand`: yes…  some time =)
23:13:43 <pharaun> c_wraith: ah
23:37:08 <pharaun> This is probably a dumb question but - U.decode $ B.unpack $ Z.decompress $ B.pack $ U.encode $ U.decode $ B.unpack $ Z.compress $ B.pack $ U.encode "test"
23:37:22 <pharaun> causes zlib to fail with ""*** Exception: Codec.Compression.Zlib: incorrect header check"
23:37:38 <pharaun> but its the only way i've found to take a string, compress it, then turn it back in a string to feed it into parsec
23:38:09 <pharaun> I'm struggling with the fact that zlib/and etc wants lazy ByteString :\
23:39:04 <pharaun> lazy ByteString wants [Char8] and only way i found to convert [char] to char8 is via encode/decode
23:39:09 <pharaun> which is what is scrambling things up
23:41:03 <pharaun> S/char8/word8/
23:41:37 <shachaf> pharaun: You can't convert Char to Word8.
23:41:53 <shachaf> Ah, but you can encode [Char] into [Word8], yes.
23:42:14 <pharaun> i'm used to working with strict ByteString
23:42:21 <shachaf> U.decode $ B.unpack $ Z.decompress $ B.pack $ U.encode $ U.decode $ B.unpack $ Z.compress $ B.pack $ U.encode -- that's far too long a line. :-(
23:42:38 <pharaun> test line
23:42:49 <pharaun> to try to figure out what was going on
23:43:17 <shachaf> Oh, well, what you're doing there doesn't make sense. That's why it's not working.
23:43:26 <pharaun> cos if i encode/pack/compress... then decompress/unpack/decode
23:43:29 <pharaun> why does it not make sense
23:43:34 <shachaf> A ByteString of zlib-compressed data isn't a UTF-8-encoded string.
23:43:38 <shachaf> (Or whatever else U is.)
23:43:40 <pharaun> :|
23:43:48 <pharaun> then how the heck do i get it into parsec?
23:43:48 <shachaf> Why would you U.decode it?
23:44:06 <pharaun> all i know is i am getting data in the following format
23:44:08 <shachaf> Sounds like you're doing something wrong.
23:44:11 <Jafet> parsec is for parsing text
23:44:19 <pharaun> yes i know
23:44:21 <shachaf> Yes, what Jafet said.
23:44:24 <pharaun> *sigh*
23:44:25 <shachaf> Have you considered using AttoParsec?
23:44:29 <pharaun> no no no
23:44:32 <shachaf> I think that works on ByteStrings.
23:44:40 <pharaun> problem is the data is coming in as either a raw string
23:44:42 <pharaun> which i can parse
23:44:47 <pharaun> or if the first 2 byte is 00
23:44:48 <shachaf> What's a "raw string"?
23:44:55 <pharaun> its compressed
23:44:58 <shachaf> ?
23:44:59 <pharaun> "String" ?
23:45:05 <pharaun> regular ascii/utf8
23:45:20 <shachaf> OK, so you get data as a ByteString.
23:45:26 <pharaun> and i made a function in parsec that checks if first 2 byte is 00
23:45:26 <shachaf> Which might hold UTF-8 or might hold something else.
23:45:40 <pharaun> and i was able to getInput and feed it into decompress and put it back
23:45:45 <pharaun> so that parsec can parse the rest
23:45:53 <shachaf> Parsec is for parsing text. You shouldn't be checking the first two bytes in Parsec because they're not text. :-)
23:45:55 <pharaun> its basically compressed ascii
23:46:02 <pharaun> :|
23:46:07 <pharaun> then how do you propose i handle this
23:46:15 <pharaun> i tried it in conduct but its beyond my skill level right now
23:46:17 <shachaf> ASCII? Huh?
23:46:20 <pharaun> this *IS* text data
23:46:25 <pharaun> i am getting text data
23:46:29 <shachaf> No, it's not text data.
23:46:35 <pharaun> and in some case its compressed, its prefixed with 2 00 in front
23:46:41 <pharaun> to indicate its compressed, i want to decompress it
23:46:49 <pharaun> and then feed it back into parsec for regular parsing
23:46:56 <shachaf> Well, OK, it's "text data encoded in a strange encoding described as bytes".
23:47:03 <pharaun> i know its already textual data inside zlib
23:47:32 <shachaf> OK, so maybe decode it before passing it in to Parsec.
23:47:36 <Jafet> Then your "test" isn't at all relevant to what you are doing
23:47:43 <pharaun> and the conduit approach of transparently decompressing it if it sees 2 byte in front with 00 is proving to be too hard for me to do right now so i fell back to doing getInput/setInput
23:47:47 <pharaun> shachaf: how?
23:49:03 <shachaf> pharaun: I don't know. By not using Parsec at all until you've decoded it?
23:49:15 <pharaun> :|
23:50:14 <Jafet> bs <- B.readFile f; let text = parse . decodeUTF8 $ case bs of (0:0:bs') -> decompress bs'; _ -> bs
23:50:29 <shachaf> What Jafet said.
23:50:49 <shachaf> Well, I don't think you can actually case-match like that on a ByteString.
23:50:56 <Jafet> Probably not
23:51:14 <Jafet> Unless it IsString?
23:51:21 <shachaf> IsString /= IsList
23:51:41 <shachaf> (And ByteString *shouldn't* be IsString. That'll only confuse pharaun further.)
23:51:55 <shachaf> You can always resort to blah $ if (B.take 2 foo == B.pack [0,0]) then B.drop 2 foo else foo
23:52:01 <Jafet> Yes, that's pretty insane
23:52:04 <solrize> @pl \f x -> f x
23:52:04 <lambdabot> id
23:52:23 <shachaf> @pl \f f x -> f x
23:52:23 <lambdabot> const (const (join id))
23:52:32 <shachaf> Thanks, @pl.
23:52:44 <pharaun> shachaf: i just wanted to do everything in parsec if possible
23:52:55 <solrize> :t id
23:52:56 <lambdabot> forall a. a -> a
23:52:58 <Jafet> I want to drive everywhere in my car
23:52:59 <shachaf> pharaun: As Jafet mentioned, Parsec is for parsing text. This isn't text.
23:53:00 <pharaun> just seemed nicer to be able to grab the input, dump it into parsec and have it return nice data structure
23:53:12 <Jafet> Like into houses
23:53:14 <solrize> > zipWith id [sin,cos,sqrt] [1,2,3]
23:53:15 <lambdabot>   [0.8414709848078965,-0.4161468365471424,1.7320508075688772]
23:53:18 <pharaun> even with ByteString ?
23:53:25 <Vulpyne> How insane would it be to use the Judy library (which is really fast, but can only store word sized values) to store indexes into a Vector where the actual data resides? http://hpaste.org/72896
23:55:10 <Jafet> In what ways is that insane?
23:55:32 <Vulpyne> So it's not insane?
23:55:59 <pharaun> Jafet: shachaf i guess that'll work, just doesn't seem as elegant as letting it handle it all but ah well, at least it'll be a thin shim around it
23:56:28 <Vulpyne> It seems kind of a complicated way to solve the problem. Judy comes with a method for storing arbitrary values that uses StablePtr, but I ran out of memory when I tried to use that method. This one seems to work fairly well, but I am doubtful.
23:56:43 <donri> pharaun: data on the wire is a string of bytes (bits). here, "string" means something other than what the String type means.
23:57:05 <pharaun> you guys are right, i was just being dumb and trying to be lazy
23:57:15 <pharaun> was viewing [String] as a sequence of 8bit char
23:57:17 <Jafet> Is Judy much faster than IntMap?
23:57:51 <donri> pharaun: Char holds unicode characters. and yes it's confusing because i think char in C is byte? or something
23:58:10 <Vulpyne> I haven't tried IntMap, but I'm currently using the strict HashMap from unordered-containers.
23:58:13 <pharaun> i'm used to doing things in C where i can grab a char and sling it
23:58:16 <shachaf> donri: Char actually holds Unicode codepoints. :-)
23:58:28 <donri> yea, that
23:58:32 <pharaun> but yeah thinking about it i can see why my approach would be dunb
23:58:35 <Vulpyne> But it seems somewhat slow for large lists, and I have trouble predicting the memory usage and such.
23:58:39 <shachaf> Just to add to the confusion!
23:58:44 <pharaun> cos code point wouldn't enclose all possible bit values
23:58:51 <pharaun> at least not for utf8
23:59:03 <Jafet> IntMap is parametric in the value type
23:59:06 <donri> pharaun: you can fake it with the Char8 APIs if your data is really ascii but it's not usually a good idea
23:59:09 <pharaun> so stuffing raw bytes into a utf8 char...
23:59:29 <pharaun> donri: from the api spec its "ASCII/UTF8"
23:59:37 <Jafet> It's not usually a good idea because I want to physically harm anyone that imports Char8
23:59:45 <Vulpyne> I was under the impression that unordered-containers should be faster, but perhaps I am wrong.
23:59:49 <Jafet> It's comparable to gets()
