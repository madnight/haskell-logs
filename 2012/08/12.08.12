00:00:24 <callen> startling: okay, that's :t of queryGen, now what?
00:00:49 <Jurily> callen: you don't need Maybe if you don't return Nothing
00:01:02 <callen> I wasn't aware I was returning nothing
00:01:04 <adnam> @pl \x -> either x x -- @ startling you need parameters
00:01:05 <lambdabot> join either
00:01:27 <Jurily> you did a while back
00:02:10 <callen> Jurily: with an entire IRC channel telling you to change things, not much lasts for very long.
00:02:42 <Jurily> give us a new paste :)
00:03:07 <startling> callen: awesome, it's easy
00:03:22 <startling> unfortunately, I closed your tab of code
00:03:30 <startling> adnam: ah
00:03:36 <hpaste> callen pasted “do notation / maybe, thought I was returning bogus which is a Forecast?” at http://hpaste.org/73020
00:03:39 <callen> walla
00:03:58 <callen> Jurily: startling go on you vicious hounds, tear it to pieces ;)
00:04:30 <startling> callen: what's :t findElement ?
00:04:49 <callen> findElement :: QName -> Element -> Maybe Element
00:05:06 <startling> callen: cool. so I'd recommend taking that IO bit out
00:05:30 <Jurily> nooo
00:05:48 <Jurily> if you want putStrLn, you need IO
00:06:00 <startling> Jurily: yeah duh
00:06:04 <startling> so take out putStrLn
00:06:07 <callen> ...I need the putStrLn
00:06:14 <callen> I need to see the intermediate DOM structure
00:06:17 <callen> that's key to this whole thing
00:06:28 <Jurily> what you also need is to get the elements out of Maybe
00:06:38 <startling> callen, yeah, you can tack that on later
00:06:54 <startling> callen: and then "return $ Forecast temperatures precipitation "" date" at the end
00:07:07 <startling> callen: (because you haven't gotten a `description` yet?
00:07:21 <callen> that's not true yet.
00:07:26 <Jurily> :t fromMaybe
00:07:27 <lambdabot> forall a. a -> Maybe a -> a
00:07:39 <startling> callen: ...okay
00:07:55 <callen> I think I have it.
00:07:56 <callen> sort of.
00:08:19 <Jurily> I didn't realize findElement returned Maybe, sorry
00:08:27 <hpaste> callen pasted “returns [] btw. Sigh.” at http://hpaste.org/73021
00:09:35 <callen> Jurily: startling ^^
00:09:38 <hpaste> startling annotated “do notation / maybe, thought I was returning bogus which is a Forecast?” with “do notation / maybe, thought I was returning bogus which is a Forecast? (annotation)” at http://hpaste.org/73020#a73022
00:09:43 <callen> I can't seem to get the putStrLn to work though.
00:09:50 <startling> callen: don't worry about it yet dude
00:09:59 <callen> startling: what you just did is invalid.
00:10:06 <callen> startling: completely invalid
00:10:07 <startling> callen: what part?
00:10:11 <callen> startling: you are conflating unlike things
00:10:15 <callen> return $ Forecast temperatures precipitation "" date
00:10:18 <adnam> callen: that's because parseForecast runs in the Maybe monad, not the IO monad
00:10:31 <callen> adnam: I can only pick one?
00:10:44 <startling> adnam: you can do both, but it's a pain
00:10:55 <startling> er
00:10:57 <startling> callen: ^
00:11:16 <startling> oh right, those return strings?
00:11:31 <callen> startling: no
00:11:37 <callen> startling: findElement is Maybe Element
00:11:47 <callen> not Temperatures or Precipitation
00:11:52 <hpaste> startling annotated “do notation / maybe, thought I was returning bogus which is a Forecast?” with “do notation / maybe, thought I was returning bogus which is a Forecast? (annotation) (annotation)” at http://hpaste.org/73020#a73023
00:12:01 <callen> you're really fixating on the wrong things here
00:12:05 <startling> callen: haha
00:12:10 <adnam> callen: no you can have both, but you can't just putStrLn in in another monad
00:12:11 <callen> I'm not having trouble destructuring into the typeclasses
00:12:14 <callen> I'm having trouble printing.
00:12:19 <Jurily> callen: you need to get rid of the Maybes
00:12:20 <startling> callen: try that
00:12:25 <Jurily> :t fromMaybe
00:12:26 <lambdabot> forall a. a -> Maybe a -> a
00:12:36 <startling> callen: so, becaue you're doing <- in do notation for Maybe, you don't have to worry about Maybe
00:12:39 <startling> Jurily: no dude
00:12:41 <startling> Jurily: stop it
00:12:46 <callen> startling: they aren't strings either.
00:12:47 <adnam> O_o
00:12:48 * callen cries
00:12:54 <startling> callen: what type are they ???
00:12:58 <callen> Element!
00:13:00 <callen> I keep telling you that
00:13:01 <startling> oh!
00:13:03 <callen> They're Maybe Element
00:13:09 <callen> they're intermediate destructurings of the XML DOM
00:13:14 <hpaste> startling annotated “do notation / maybe, thought I was returning bogus which is a Forecast?” with “do notation / maybe, thought I was returning bogus which is a Forecast? (annotation) (annotation) (annotation)” at http://hpaste.org/73020#a73024
00:13:16 <callen> that's not really a part of this that I don't understand
00:13:19 <startling> callen: there
00:13:20 <callen> I understand it perfectly
00:13:25 <callen> I need to understand how the goddamn monads work.
00:13:46 <callen> interesting. I'll give it a whirl.
00:13:55 <callen> your code is broken, but I think I can adapt the concept.
00:14:06 <startling> callen: <- fails if you get a Nothing (and the whole do returns a Nothing) or gets the value out of the Just if it's a Just
00:14:23 <startling> callen: yeah, it's probably because I know nothing bout xml parsing. sorry. :/
00:14:39 <callen> startling: neither do I, just try to focus on the parts I don't understand.
00:14:48 <startling> callen: you probably don't want to stick those in a list, but that works for now if you just want to see what comes out
00:15:23 <callen> I'm not sticking them in a list
00:15:26 <callen> I'm using that print thing
00:15:32 <startling> callen: i mean what I did on line 26
00:16:55 <adnam> callen: I would suggest removing IO and putStrLn from your code first, and then after that you can change your function to IO (Maybe Forecast). Usually you want IO as the outermost monad
00:18:39 <adnam> that way parseForecast can be pure (no IO), and an outer function can do the IO (such as reading XML from disc and printing results to screen)
00:18:54 <startling> ^ right, agreed
00:20:12 <adnam> it will be easier to read and write
00:21:08 <callen> doing that
00:21:10 <callen> but new problem
00:21:23 <adnam> :O
00:21:50 <hpaste> callen pasted “[Maybe Element]” at http://hpaste.org/73025
00:22:01 <callen> ^^ what the fuck gives?
00:22:21 <startling> hpaste: no, it's Maybe [Element]
00:22:23 <adnam> okay so what's the type of [temperatures, precipitation, date] ?
00:22:26 <startling> er
00:22:29 <startling> callen: ^^
00:22:31 <callen> adnam: Element
00:22:44 <Jurily> [Maybe Element]
00:22:44 <adnam> and what's the type of return [temperatures, precipitation, date] ?
00:22:50 <callen> that worked.
00:22:56 <callen> it's weird though
00:23:00 <startling> callen, since you're in do notation, you're sticking all these actions together
00:23:02 <callen> returns nothing.
00:23:06 <startling> callen: if one fails, they all fail
00:23:28 <Jurily> why are we shoving him through a Maybe monad again?
00:23:35 <adnam> hehe
00:23:39 <Jurily> seriously
00:23:41 <callen> because the findElement returns Maybe Element?
00:23:45 <startling> Jurily: because all of his things return Maybe Element
00:23:48 <Jurily> :t fromJust
00:23:50 <lambdabot> forall a. Maybe a -> a
00:23:53 <Jurily> enjoy
00:23:57 <adnam> :(
00:23:58 <startling> Jurily: no what
00:24:00 <callen> oh how neat, I understand what's going on. Sort of.
00:24:21 <adnam> just to clarify, never use fromJust :P
00:24:41 <startling> callen: so a thing to do would be try running each thing (e.g. findElement (queryGen "Temperatures")) on your test input
00:24:47 <Jurily> the Maybe type is either Nothing, or Just a, where a is the value you want
00:24:49 <startling> callen: and see which fails and see why it fails
00:24:56 <adnam> callen: do you understand how to rewrite that function without using do-notation?
00:25:03 <callen> the code works now
00:25:08 <callen> adnam: not a goddamned clue
00:25:12 <Jurily> :D
00:25:25 <startling> Maybe is a pretty friendly monad to start with anyway
00:25:29 <callen> the code works because of the Maybe [Element] nothing.
00:25:32 <callen> thing*
00:25:40 <Jurily> IO is a friendly monad to start with
00:25:52 <callen>     let parsedForecasts = map parseForecast forecasts
00:25:52 <startling> callen: yeah, it can either return (Just someElements) or Nothing
00:25:54 <Jurily> for a recovering Python programmer
00:25:54 <callen> returns []
00:25:55 <hpaste> TotallyWorthIt pasted “...is a rigid type variable bound by  ..he type signature for ...” at http://hpaste.org/73026
00:26:06 <callen> Jurily: I am a python programmer.
00:26:13 <Jurily> I know.
00:26:14 <pharaun> haha
00:26:16 <callen> why does my let map return []?
00:26:23 <callen> I am sad :(
00:26:28 <TotallyWorthIt> can anyone help me??  I'm totally lost...
00:26:30 <adnam> > let f x = case x of Just x -> x + 1; Nothing -> Nothing in f (Just 2)
00:26:31 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
00:26:32 <lambdabot>    arising from a use of...
00:26:35 <adnam> woops
00:27:11 <startling> callen: whats the code?
00:27:23 <callen> startling: this is getting closer to XML parsing issues
00:27:26 <callen> but
00:27:30 <callen>     let forecasts = findElements (queryGen "forecast") doc
00:27:31 <callen>     let parsedForecasts = map parseForecast forecasts
00:27:35 <callen> that should be fairly intuitive
00:27:45 <callen> I'm aggregating the result of applying the parse function to each dom element
00:27:46 <callen> using map
00:27:49 <callen>     print parsedForecasts
00:27:55 <callen> then printing the aggregated result
00:27:59 <callen> only problem, it equals []
00:28:04 <callen> and I can't debug it
00:28:14 <callen> because you people told not to put IO in there.
00:28:30 <callen> so now that I'm bereft my only mechanism of debugging (printing), I have no idea what's going on.
00:28:34 <pharaun> callen: what does just plain forecasts return?
00:28:36 <pharaun> callen: ghci
00:28:56 <callen> ghci is not a debugging mechanism
00:28:58 <Jurily> wait
00:28:59 <callen> it's a repl
00:29:01 <callen> very big difference
00:29:05 <adnam> > let f x = case x of Just x -> Just (x + 1); Nothing -> Nothing in f (Just 2)
00:29:07 <lambdabot>   Just 3
00:29:10 <adnam> > let f x = do x' <- x; return (x' + 1) in f (Just 2)
00:29:11 <Jurily> what is the type of forecasts?
00:29:11 <startling> callen: yeah! so you can see what things return without print debugging
00:29:12 <lambdabot>   Just 3
00:29:17 <startling> Jurily: Element
00:29:22 <callen> startling: ah fuck. forecasts is null
00:29:25 <Jurily> no
00:29:25 <callen> that's really fucking annoying.
00:29:27 <startling> callen: heh
00:29:31 <Jurily> it's Maybe Element
00:29:43 <adnam> callen: those two lines are equivalent, but see how cluttery the first one looks?
00:29:49 <startling> Jurily: oh, in the new code
00:29:50 <startling> ueaj
00:29:58 <startling> *yeah
00:30:21 <callen> the main dom doc is working
00:30:41 <callen> I have it working now
00:30:43 <callen> sorta.
00:30:50 <startling> cool. :)
00:30:53 <callen> [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing]
00:30:56 <callen> which is bad
00:30:56 <adnam> callen: if you want some practice, rewrite your code to use case instead of do, and then see how ugly it gets :D
00:30:57 <Jurily> \o/
00:31:04 <callen> and means the do monad is short-circuiting
00:31:15 <startling> callen: "do notation", but yeah
00:31:29 <callen> so how do I inspect the inner behavior of the...Maybe monad which is being sugared by the do notation?
00:31:51 <Jurily> you don't...
00:32:03 <startling> callen: you can turn it into an Either String Element
00:32:12 <adnam> yes you do :)
00:32:14 <startling> callen: which is like Maybe but you get more debug information
00:32:34 <adnam> @src Monad Maybe -- perhaps?
00:32:35 <lambdabot> Source not found. Wrong!  You cheating scum!
00:32:40 <Jurily> why are we shoving him through a Maybe monad again?
00:32:40 <adnam> bah
00:32:59 <startling> callen: import Control.Error (note) and, if that fails, `cabal install error` on the command-line
00:33:14 <b_> cabal install errors
00:33:26 <startling> callen: actually just show us your code right now
00:33:29 <startling> ^^ er yeah
00:33:51 <hpaste> callen pasted “current” at http://hpaste.org/73028
00:33:54 <callen> startling: ^^
00:34:08 <adnam> callen: here you can see how Maybe (Monad a) is implemented: http://en.wikibooks.org/wiki/Haskell/Understanding_monads
00:34:16 <adnam> (don't know if the rest of the text is good or not)
00:35:19 <adnam> Monad (Maybe a) i meant of course...
00:35:20 <hpaste> startling annotated “current” with “current (annotation)” at http://hpaste.org/73028#a73029
00:35:36 <startling> ^ might give you more debug information
00:35:54 <startling> Either is basically Maybe but with a reason supplied
00:37:00 <callen> either-3.0.2 failed while downloading the package. The exception was:
00:37:00 <callen> connect: timeout (Operation timed out)
00:37:00 <callen> errors-1.2.1 depends on either-3.0.2 which failed to install.
00:37:05 <callen> startling: isn't hackage down?
00:37:09 <startling> oh right
00:37:10 <startling> ugh
00:37:48 <startling> note x Nothing = Left x; note _ (Just y) = Right y
00:37:54 <startling> ^ is the definition for note
00:38:25 <callen> [Left "failed finding temperature",Left "failed finding temperature",Left "failed finding temperature",Left "failed finding temperature",Left "failed finding temperature",Left "failed finding temperature",Left "failed finding temperature"]
00:38:33 <callen> why only temperature over and over?
00:38:33 <startling> yay
00:38:45 <callen> because it short-circuits?
00:38:47 <hpaste> TotallyWorthIt pasted “...is a rigid type variable bound by ” at http://hpaste.org/73030
00:38:47 <startling> callen: because they all failed your parse looking for Temperature
00:38:49 <TotallyWorthIt> I need help please , i don't know how to fix these problem...
00:39:02 <startling> callen: and then didn't continue
00:39:07 <latro`a> TotallyWorthIt, a good rule of thumb, if you see "bound type variable", uncomment your signature
00:39:08 <latro`a> then come back
00:39:37 <latro`a> usually if you see "bound type variable" it means your signature is actually more polymorphic than it is allowed to be
00:39:38 <callen> I found the problem
00:39:40 <callen> startling: I found the problem
00:39:52 <startling> callen: yay
00:39:52 <callen> startling: dumb motherfuckers who wrote this API I'm calling spelled it "Precipiation"
00:39:57 <startling> haaaa
00:39:57 <callen> I am going to kill someone.
00:40:09 <callen> oh looky.
00:40:12 <callen> I have a list of elements now.
00:40:17 <startling> good!
00:40:18 <callen> brb, making molotov cocktails
00:40:25 <callen> startling: thanks for that!
00:40:44 <startling> callen: no problem. do you feel like you're understanding a bit more?
00:40:48 <adnam> dude it's hard to spell that
00:40:58 <latro`a> TotallyWorthIt, did that help?
00:41:29 <latro`a> wait...wtf
00:41:32 <latro`a> I don't understand that error
00:41:37 <latro`a>  Expected type: ST s1 (STArray s1 (Int, Int) Char)
00:41:37 <latro`a>       Actual type: ST s (STArray s (Int, Int) Char)
00:41:41 <latro`a> how are those not the same type
00:42:03 <callen> startling: at a high level of abstraction, yes.
00:42:07 <callen> startling: I'm nowhere near grokking it though.
00:42:18 <startling> callen: cool. so, do notation desugars to >>=
00:42:19 <callen> startling: I mean, Either String [Element] is facile enough
00:42:40 <startling> callen: Nothing >>= whatever  == Nothing
00:42:45 <TotallyWorthIt> that the question...
00:42:47 <startling> callen: Just x >>= whatever = whatever x
00:43:05 <startling> callen: does that make a bit of sense?
00:43:18 <latro`a> anyone know how those two can be different types?
00:43:34 <startling> latro`a: it probably inferred a type like s -> s1 -> whatever
00:43:48 <latro`a> that doesn't make sense
00:43:52 <latro`a> there's only one s
00:43:57 <startling> hmm
00:43:59 <Jurily> but how is expected different from actual?
00:44:05 <latro`a> right
00:44:13 <latro`a> anyway
00:44:16 <latro`a> did uncommenting the signature help?
00:44:25 <palmfrond> let's say i have x + y = 3, and i have some area in my UI where x is a number slider and y is a number slider. what category of things would x and y be called in math please? metrics? configuration? ??
00:44:30 <callen> startling: Not especially?
00:44:30 <palmfrond> generally speaking
00:44:42 <callen> startling: I'm sorry, my brain's fried from the stress today
00:44:54 <Jurily> callen: you're doing better than I did
00:44:56 <callen> startling: I've actually got to stop the Haskell so that i can go parse an even more complicated API in python.
00:45:05 <startling> callen: k. come back if you're interested
00:45:05 <callen> startling: thanks for your time
00:45:07 <callen> Jurily: you too
00:45:10 <callen> Jurily: and for your time.
00:45:17 <latro`a> callen: basically, if you don't have a value, you can't apply the function; if you do have a value, you only apply the function
00:45:25 <latro`a> erm, *you can't apply the function, so you get Nothing
00:46:07 <latro`a> then each "x <- maybeval" desugars to "maybeval >>= \x -> ...", where ... is the rest of the desugared do block
00:46:32 <latro`a> so if any right hand side of a <- in a Maybe do block is Nothing, the whole block results in Nothing
00:46:41 <callen> I've gathered that much
00:46:54 <callen> at a high level, I appreciate that anytime it results in nothing, it short-circuits and returns that
00:47:03 <latro`a> there's not much low level to be seen here
00:47:04 <callen> I just don't understand the decomposition into lambdas
00:47:10 <latro`a> how is that?
00:47:16 <callen> latro`a: seriously, I'm fried. Leave it for another day.
00:47:17 <latro`a> k
00:47:23 <startling> callen: data Maybe a = Just a | Nothing
00:47:31 <callen> latro`a: thank you for trying. You'll have another chance to unfuck me later.
00:47:40 <startling> callen: the do notation relies on Maybe's Monad instance, which defines (>>=)
00:47:43 <callen> startling: that I've gathered as well.
00:47:52 <callen> well, the data decl you pasted
00:47:55 <latro`a> really though, if you understand that the only effect of Maybe is to shortcircuit if you get a Nothing
00:47:59 <startling> callen: so that's how it decomposes into lambdas
00:47:59 <callen> I don't really know what >>= does.
00:48:00 <latro`a> then there's not really anything left to understand
00:48:07 <startling> callen: its a typeclass method
00:48:10 <latro`a> callen: depends entirely on the monad
00:48:22 <callen> classic programmer answer, "it depends!"
00:48:25 <callen>  :P
00:48:31 <latro`a> in Maybe it's quite simple, Nothing in the first argument gives Nothing, Just in the first argument means you apply the second argument
00:48:46 <callen> wait a second
00:48:52 <callen> what's the arity of do notation?
00:48:58 <startling> callen: uh
00:49:02 <callen> does it get compiled statically into the n-arity of the statements?
00:49:07 <latro`a> n-arity?
00:49:17 * callen isn't sure how to explain
00:49:21 <latro`a> do notation parses into >>=, >>, and lambdas
00:49:24 <Jurily> the statements are just functions that take and return an extra state parameter
00:49:26 <latro`a> (and unfortunately fail)
00:49:27 <callen> each line in the do notation is an argument, yes?
00:49:28 <startling> callen: do x; y gets compiled into x >>= \_ -> y
00:49:45 <startling> callen: yeah, there's no specific arity; it chains them
00:49:51 <startling> with >>=
00:49:51 <callen> okay.
00:50:04 <callen> but seriously now, I have to go slay this other dragon in Python
00:50:05 <callen> bbl
00:50:08 <startling> yep
00:50:10 <callen> fucking Federal APIs
00:50:12 <callen> glkmserlkhrt
00:50:15 <Jurily> have fun
00:50:21 <callen> Jurily: gov't API? Never.
00:50:45 <startling> Precipiation
00:50:55 <startling> was that a government thing?
00:53:53 <zenzike> hackage down again :-(
00:54:12 <startling> yep
00:54:40 <Jurily> zenzike: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
00:55:18 <zenzike> Jurily: awesome, thanks
01:01:10 <beefcube> what is wrong with hackage?
01:01:43 <beefcube> (hackage.haskell.org)
01:02:50 <startling> beefcube: network upgrade or something
01:14:53 <TotallyWorthIt> can someone help me with these error ??
01:15:03 <TotallyWorthIt> http://hpaste.org/73030
01:16:26 <shachaf> TotallyWorthIt: What monad is that "do" in?
01:16:43 <shachaf> Oh, never mind.
01:17:02 <shachaf> What's the type of act?
01:17:08 <latro`a> wait...how do you get a [[Char]] out of a do block in ST
01:17:12 <latro`a> oh wait...nvm
01:17:20 <latro`a> the do block is in []
01:18:07 <shachaf> That ST thing is weird.
01:18:22 <shachaf> Maybe you mean :: (forall s. ST s ...) -> ...?
01:18:42 <phil_> is hackage down for you guys as well?
01:18:46 <shachaf> Hmm, that doesn't help you.
01:18:55 * shachaf can't figure out what you're trying to do.
01:19:05 <TotallyWorthIt> i tried... but it didn't change anything
01:19:13 <startling> so maybe I don't understand Reader
01:19:34 <shachaf> startling: It's just a function.
01:19:36 <latro`a> Reader is just a newtype around the "function monad" right?
01:19:41 <startling> is it common to just write functions that take the context of Reader? isn't that what Reader is supposed to avoid?
01:19:51 <latro`a> i.e. fmap = (.) and join f = \x -> f x x
01:19:52 <startling> shachaf: oh, I understand how it works, just not how to use it
01:21:27 <Taneb> phil_, look at the topic?
01:21:28 <startling> so I've got a Reader (a, b). right now I have a bunch of flip fmap ask $ \(a, b) -> ...
01:21:38 <shachaf> startling: Huh?
01:21:41 <shachaf> flip fmap ask?
01:21:55 <phil_> Taneb: oh :)
01:22:03 <startling> shachaf: yes, so the lambda doesn't need parens
01:22:19 <shachaf> What are you trying to accomplish?
01:22:24 <shachaf> @ty ask
01:22:25 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
01:22:33 <shachaf> do { (a, b) <- ask; ...a...b... }
01:22:49 <startling> shachaf: I don't know. I was told that Reader would simplify my code that keeps passing around those arguments
01:23:04 <shachaf> It might, but not if you flip fmap ask everything. :-)
01:23:05 <latro`a> it would do it the way he just said, I think
01:23:22 <startling> shachaf, so what should I do
01:23:28 <latro`a> is that lambda big?
01:23:31 <startling> yeah
01:23:38 <latro`a> then do what schachaf said
01:24:02 <startling> well, it's big but not complicated
01:24:04 <latro`a> (though I must admit, I still much prefer using fmap when it's sufficient)
01:24:14 <startling> I have "flip fmap ask $ \(v, _) -> Header <$> v <*> v <*> v <*> v <*> v <*> v <*> v <*> v
01:24:20 <latro`a> oh
01:24:31 <shachaf> startling: Your question is too narrow to be able to answer it.
01:24:36 <latro`a> that is a *lot* of <*>
01:24:41 <startling> latro`a: indeed
01:24:42 <latro`a> like...wtf
01:24:50 <startling> latro`a: it's a file format header
01:24:51 <latro`a> surely you could write that as a fold instead >.<
01:25:06 <shachaf> latro`a: That's less type-safe, if anything.
01:25:06 <latro`a> guess it'd be equally verbose, with replicate
01:25:23 <latro`a> how is that, shachaf
01:25:41 <latro`a> eh, I forget which associativity <*> is anyway
01:25:43 <shachaf> List lengths aren't verified at compile-time.
01:25:49 <phil_> wouldn't it be better to just have non monadic functions like :: Config -> a -> b -> c instead of monadic functions like a -> b -> Reader ... etc?
01:25:52 <Yuu-chan> Where to put the mirror repo in the cabal configuration?
01:25:52 <latro`a> eh, marginally then
01:25:59 <shachaf> Header :: Blah -> Blah -> Blah -> Header
01:26:00 <phil_> if they are not that deeply nested
01:26:18 <shachaf> I still think that v <*> v <*> v thing should be improved, mind you. :-)
01:26:30 <startling> shachaf: how so?
01:26:32 <shachaf> Yuu-chan: Try it somewhere. If it doesn't work, try somewhere else.
01:26:48 <shachaf> But at least it's localized, so it's not too bad.
01:27:10 <startling> @pl \(v, _) -> Header <$> v <*> v <*> v <*> v <*> v <*> v <*> v <*> v
01:27:11 <lambdabot> (Header <$>) . ((<*>) =<< (<*>) =<< (<*>) =<< (<*>) =<< (<*>) =<< (<*>) =<< join (<*>)) . fst
01:27:13 <phil_> shachaf: lift7? :D
01:27:15 <startling> o.o
01:27:16 <shachaf> startling: I don't know.
01:27:28 <startling> I'll just do that thing ^^^
01:27:40 <latro`a> startling--phil_ has a point
01:27:54 <latro`a> though it amounts to the same thing ofc, and I'm not sure the liftA series goes up to 7
01:28:08 <shachaf> Doesn't gain you much.
01:28:13 <startling> mhm
01:28:16 <shachaf> The part I don't like is how those vs don't have names.
01:28:17 <latro`a> also, the fact that @pl turns Applicative code into monadic cod
01:28:18 <phil_> well 7 less <*>s
01:28:23 <latro`a> *code
01:28:26 <latro`a> baffles me
01:28:46 <latro`a> how does it know there's a =<< to use
01:28:57 <shachaf> Give @pl a break.
01:29:01 <startling> latro`a: I think it's on (->)
01:29:10 <latro`a> oh oh
01:29:11 <latro`a> duh
01:29:13 <latro`a> nvm
01:29:31 <startling> anyway, yeah: if I only have a two-tuple, Reader is kind of pointless?
01:29:40 <shachaf> Is it?
01:29:41 <startling> which I guess was my question from the start
01:29:56 <startling> shachaf: dunno. it certainly makes my type signatures nicer
01:29:59 <shachaf> I don't get the flip fmap ask thing.
01:30:07 <shachaf> I still don't know what you're trying to do.
01:30:08 <MHD0> Has Data.Map.Map been made into a category yet?
01:30:31 <startling> shachaf, if i did (\(a, b) -> ..) <$> ask, the lambda needs to be in parens
01:30:32 <phil_> startling: but you now have monadic functions instead of normal functions
01:30:41 <shachaf> MHD0: Maybe after Data.Set.Set is made into a monad.
01:30:53 <startling> phil_: monadic monadic functions rather than monadic functions
01:30:57 <startling> phil_: but yes, also true
01:30:58 <startling> hmmm
01:31:11 <shachaf> startling: You can do (a, b) <- ask
01:31:19 <shachaf> That's pretty much the only thing Reader gets you.
01:31:29 <startling> shachaf: right
01:31:29 <phil_> oh well if they are already monadic anyway i guess its ok
01:31:48 <startling> phil_: ((->) a) is a monad
01:32:04 <MHD0> shachaf: m1 . m2 is a new map that maps the keys from m2 to the values of m1
01:32:36 <startling> well, we'll see I guess
01:32:51 <phil_> startling: what's the signature of your function?
01:33:05 <shachaf> MHD0: join s is the set of the union of the sets in s.
01:33:30 <MHD0> shachaf: high5
01:33:44 <startling> phil_: getHeader :: MState w Header
01:33:55 <startling> phil_: where MState is Reader (Get Word32, Get w) (Get x)
01:34:04 <startling> which could be a readerT I guess
01:39:23 <phil_> startling: so you are first parsing the tuple (Word32, w) and passing it as the environment?
01:39:55 <startling> no, the environment is a parser that results in Word32
01:39:59 <startling> and another Parser
01:40:29 <startling> hmmm, can I compose Readers parallelly?
01:41:00 <startling> like, they both take the same environment
01:41:07 <phil_> why don't you first parse Word32 and w and just them as arguments to getHeader?
01:41:59 <startling> phil_: because I need to use them lots
01:42:08 <startling> see \(v, _) -> Header <$> v <*> v <*> v <*> v <*> v <*> v <*> v <*> v
01:42:25 <startling> using a parser many times is not the same as using it once and passing around the result
01:45:13 <lapinferoce> join #php
01:46:14 <phil_> ah
01:46:44 <phil_> so you wanna parse (Word32, w) 7 times and create a Header out of the resulting values, right?
01:47:23 <startling> no, I want to parse 7 Word32s and create a Header out of the resulting values
01:47:25 <hpaste> “testicle eyes” pasted “State sponsored rootkits and the failure of malware scanners” at http://hpaste.org/73031
01:47:43 <startling> that particualar function doesn't use w at all
01:49:04 <phil_> startling: yes i see... if you can have a list in Header instead of 7 distinct fields you can simplify that expression by using replicateM, right?
01:50:35 <phil_> i.e. replicateM 7 parseWord >> Header
01:50:37 <phil_> I think
01:51:07 <phil_> >:>=
01:51:11 <phil_> >>=
01:52:05 <startling> phil_: yes but that's not type-safe
01:52:18 <startling> the header literally has 7 different fields
01:52:24 <startling> that are all parsed with this one parser
01:54:49 <startling> @hoogle (a -> b) -> (c -> d) -> Either a b -> Either c d
01:54:50 <lambdabot> No results found
01:54:53 <startling> :/
01:55:08 <startling> errr
01:55:12 <zhulikas> :D
01:55:18 <startling> @hoogle (a -> c) -> (b -> d) -> Either a b -> Either c d
01:55:19 <zhulikas> does't make sense to me
01:55:19 <lambdabot> No results found
01:55:29 <startling> still no results
01:55:53 <startling> I want to map a certain function over Lefts and another one over Rights
01:56:29 <Jurily> Either (a -> c) (b -> d) -> Either a b -> Either c d
01:56:50 <zhulikas> @hoogle (a -> b) -> (c -> d) -> [Either a c] -> Either b d
01:56:50 <lambdabot> No results found
01:56:57 <shachaf> Jurily: That doesn't make sense.
01:57:13 <startling> oh! it's <*>, isn't it
01:57:22 <zhulikas> or just map over Either
01:57:26 <startling> oh wait, no, that doesn't make sense
01:57:27 <zhulikas> and decide inside your function
01:57:34 <zhulikas> so it's a regular map :D
01:57:45 <startling> zhulikas, no, I need to map over both sides
01:58:25 <Jurily> what do you mean, both sides?
01:58:55 <startling> I have a function from a -> c and one from b -> d. I want to go from Either a b -> Either c d
01:59:38 <zhulikas> but Either a b is either Left a or Right b, it isn't Either a b when you have the value :D
01:59:40 <shachaf> @ty \f g -> either (Left . f) (Right . g)
01:59:41 <lambdabot> forall a b a1 b1. (a1 -> a) -> (b1 -> b) -> Either a1 b1 -> Either a b
01:59:58 <zhulikas> @type either
01:59:59 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
02:00:04 <zhulikas> oh, nice
02:00:46 <fmap> startling: (+++) ?
02:00:56 <startling> :t (+++)
02:00:58 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
02:01:18 <startling> shachaf: nice
02:01:41 <startling> fmap: also nice
02:03:21 <Jurily> well, that was educational.
02:03:59 <startling> zhulikas, yes, but you can dispatch depending on whether it's Left or Right
02:05:41 <phil_> > (+++) (\x -> x + 1) (\y -> y + 1) (Left 5)
02:05:42 <lambdabot>   Left 6
02:05:46 <phil_> awesome
02:06:12 <phil_> (+++) (\x -> x + 1) (\y -> y + 2) (Right 5)
02:06:21 <c_wraith> You can shorten \x -> x + 1 to (+ 1)
02:06:23 <phil_> > (+++) (\x -> x + 1) (\y -> y + 2) (Right 5)
02:06:24 <lambdabot>   Right 7
02:06:52 <phil_> c_wraith: oh yes :D
02:07:03 <Ippo> the same for the other lamda
02:07:04 <MHD0> :t Data.Either.either
02:07:05 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
02:07:07 <Ippo> it's just (+ 2)
02:07:08 <startling> (+ 1) +++ (++ " noes") $ Right "oh"
02:07:15 <startling> > (+ 1) +++ (++ " noes") $ Right "oh"
02:07:17 <lambdabot>   Right "oh noes"
02:07:33 <startling> MHD0: s'different
02:07:49 <MHD0> startling: I know, but it is the generalization
02:08:10 <MHD0> Or wayt
02:08:25 <startling> no, it's a specific case !
02:08:32 <MHD0> yes
02:08:36 <MHD0>  that is what I mean
02:09:04 <MHD0> there needs to be an accepted "is a mathematical generalization" operator
02:09:30 <fmap> :t (|||)
02:09:31 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
02:09:35 <fmap> that's "either"
02:09:53 <phil_> oh man :D
02:10:09 <phil_> arrows just generalize all of prelude
02:10:15 <zhulikas> interesting
02:10:18 * zhulikas never got into Arrows
02:10:34 <zhulikas> looks useful
02:10:49 <mm_freak> that's not arrows
02:10:53 <mm_freak> that's just the function arrow
02:11:21 <zhulikas> oh.
02:11:27 <startling> yeah, it's just a method of Arrow
02:11:39 <startling> still pretty handy though
02:11:43 <startling> &&& is nice, too
02:12:20 <mm_freak> Category + Applicative/Arrow become really useful, as soon as you're dealing with something other than the (->) category =)
02:12:46 <phil_> still trying to grok AFRP :)
02:13:25 <mm_freak> phil_: try to grok this one:  data Auto a b = Auto (a -> (b, Auto a b))
02:13:36 <mm_freak> just implement it…  it's pretty easy
02:13:46 <mm_freak> i.e. write Category, Applicative and Arrow instances
02:14:01 <phil_> what is it?
02:14:10 <mm_freak> it's the foundation of AFRP =)
02:14:27 <hpaste> scri pasted “threads?” at http://hpaste.org/73033
02:14:30 <mm_freak> a function that returns a result along with a new version of itself
02:14:30 <startling> how do you do case in one line for lambdabot?
02:14:38 <phil_> mm_freak: oh, ill try :)
02:14:57 <phil_> startling: with ; i think
02:15:00 <phil_> and {}
02:15:08 <scri> ^^ should this code be able to take advantage of threads?
02:15:11 <zhulikas> mm_freak, looks like conduit sources
02:15:12 <scri> green threads?
02:16:08 <mm_freak> zhulikas: it's a generalized ZipStream
02:16:09 <scri> i.e. so that if i compile with +RTS -N4 i can use all my cores?
02:16:23 <zhulikas> @hoogle ZipStream
02:16:24 <lambdabot> No results found
02:16:37 <mm_freak> understanding AFRP starts with the ZipStream type:  data ZipStream b = ZipStream b (ZipStream b)
02:16:40 <scri> http://hpaste.org/73033
02:17:01 <mm_freak> that's an Applicative
02:17:10 <shachaf> scri: Threads aren't what you want. Threads are for concurrency. You want parallelism.
02:17:20 <shachaf> But that program can be rewritten to use more cores, yes.
02:17:24 <mm_freak> once you realize that ZipStream is not composable you want to add an input type and get Auto
02:17:37 <mm_freak> newtype Auto a b = Auto (a -> (b, Auto a b))
02:17:43 <scri> shachaf: yes, good - hints?
02:18:07 <mm_freak> that's a generic automaton type…  composable machines with local state
02:18:10 <shachaf> scri: Look up "par" (and "pseq").
02:18:46 <mm_freak> by a simple change you add a notion of time:  newtype SF a b = SF (Time -> a -> (b, SF a b))
02:18:50 <mm_freak> then you have yampa
02:19:16 <mm_freak> and finally you realize that events suck in yampa…  you add yet one more ingredient
02:19:17 <zhulikas> uh-huh...
02:19:40 <mm_freak> newtype Wire a b = Wire (Time -> a -> (Maybe b, Wire a b))
02:19:43 <mm_freak> then you have netwire =)
02:20:03 <zhulikas> thanks for confusion
02:20:11 <zhulikas> :D
02:20:16 <mm_freak> just start with the ZipStream applicative functor
02:20:21 <mm_freak> then move of to Auto
02:20:31 <srhb> So I read the RWH chapter on Monad transformers, and it worries me that they call the file containing this example "uglystack" -- type App = ReaderT AppConfig (StateT AppState IO) -- is there really something inherently ugly about it? It seems like a kind of stack I'd often be using.
02:20:43 <PaulVisschers> when is hackage expected to be back up?
02:20:45 <mm_freak> simple counter ZipStream:  countFrom x = ZipStream x (countFrom (x + 1))
02:21:05 <phil_> this chatlog is going to prove useful :)
02:21:25 <mm_freak> simple counter Auto:  countFrom x = Auto (\_ -> (x, countFrom (x + 1))
02:22:10 <hiptobecubic> Doesn't anyone have a hackage mirror somewhere? This is like kernel.org going down...
02:22:15 <hiptobecubic> Life is hopeless without hackage
02:22:21 <srhb> hiptobecubic: Yes, luite does
02:22:40 <srhb> hiptobecubic: http://www.reddit.com/r/haskell/comments/y1tgc/any_hackage_mirrors_how_do_you_deal_with_hackage/
02:23:07 <hiptobecubic> srhb, thanks
02:23:32 <mm_freak> and if you want to learn arrows you can have a look at my unfinished arrow tutorial…  it covers most basics and introduces Auto
02:23:44 <mm_freak> http://ertes.de/new/tutorials/arrows.html
02:29:43 * talios posts a quick and nasty video showing Frege (Haskell on the JVM) running under OSGi.
02:30:15 <talios> http://www.youtube.com/watch?v=RDsuPdMptCU
02:32:39 <phil_> mm_freak: http://hpaste.org/73034
02:33:22 <phil_> is that correct?
02:35:59 <latro`a> mm_freak, you say you get >=> but that means you get >>=
02:36:04 <latro`a> in that arrow tutorial
02:36:16 <latro`a> you seem to get something like >=> but not quite the same
02:36:54 <latro`a> (m >>= f = (const m >=> f) undefined)
02:40:20 <flebron> Any ETA on hackage?
02:40:37 <flebron> (Or alternatives/mirrors for cabal?)
02:40:43 <Jurily> filebron: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
02:42:50 <srhb> > foldr (liftM2 (+)) (Right 0) [Right 1, Right 2]
02:42:52 <lambdabot>   Right 3
02:43:01 <srhb> OK, why does my ghci not find that either instance?
02:43:07 <srhb> > foldr (liftM2 (+)) (Right 0) [Left 0, Right 1, Right 2]
02:43:09 <lambdabot>   Left 0
02:43:16 <srhb> > foldr (liftM2 (+)) (Right 0) [Right 1, Left 0, Right 2]
02:43:18 <lambdabot>   Left 0
02:43:18 <latro`a> srhb: how did you import Either
02:43:23 <latro`a> the Monad instance isn't in Data.Either
02:43:30 <srhb> Oh. Where is it then?
02:43:38 <latro`a> Control.Monad.Either and also Control.Error
02:43:39 <srhb> Control.Monad.Either?
02:43:40 <latro`a> iirc
02:43:40 <srhb> Thanks.
02:43:47 <latro`a> unfortunately there's some conflict between the two
02:43:52 <latro`a> and the instances are also orphans
02:43:59 <srhb> Eck..
02:44:00 <shachaf> srhb: Control.Monad.Instances?
02:44:01 <mm_freak> phil_: yeah, so far it's correct
02:44:14 <shachaf> Just import C.M.I, you'll be fine.
02:44:22 <latro`a> oh, instances
02:44:26 <latro`a> cute
02:44:26 <srhb> Neat, thanks!
02:44:34 <latro`a> and by cute I mean better than the alternative
02:44:37 <mm_freak> latro`a: compare the types…  there is a nice comparison in the tutorial
02:44:37 <shachaf> They're orphan but very standard.
02:44:48 <mm_freak> latro`a: (.) corresponds to (<=<)
02:44:52 <latro`a> mm_freak, I think my gripe is about language
02:45:11 <latro`a> <=< is the composition in the Kleisli category but arrows aren't as "rich" as the Kleisli category
02:45:18 <latro`a> if they were, (.) would give you >>=
02:45:35 <mm_freak> (.) never gives you (>>=)
02:45:45 <latro`a> <=< does, however
02:45:47 <mm_freak> 'app' gives you 'join'
02:45:50 <mm_freak> no, it doesn't
02:45:54 <latro`a> yes it does
02:46:04 <latro`a> m >>= f = (const m >=> f) undefined
02:46:13 <shachaf> s/undefined/()/
02:46:15 <shachaf> Please.
02:46:17 <latro`a> eh
02:46:17 <mm_freak> write 'join' in terms of (<=<) without application
02:46:21 <latro`a> the value in question doesn't matter
02:46:39 <latro`a> join m = (const m >=> id) ()
02:46:45 <mm_freak> latro`a: you're using application, as such you're already leaving Category
02:46:58 <mm_freak> Category doesn't encode application
02:47:14 <latro`a> I doubt this'll work, but I'm still curious:
02:47:19 <latro`a> @pl join m = (const m >=> id) ()
02:47:20 <lambdabot> join = flip (>=> id) () . const
02:47:33 <shachaf> There's a much nicer way to get join from >=>
02:47:58 <shachaf> @ty id >=> id
02:47:59 <lambdabot> forall (m :: * -> *) c. (Monad m) => m (m c) -> m c
02:48:03 <mm_freak> there is /no/ way to get 'join' from (>=>)…  you're already using more than (>=>)
02:48:03 <latro`a> ah
02:48:08 <latro`a> also
02:48:15 <latro`a> I think shachaf just did it
02:48:34 <latro`a> without the shenanigans of my example
02:48:36 <nand`> :t Control.Category.id Control.Category.. Control.Category.id
02:48:38 <lambdabot> forall (cat :: * -> * -> *) b. (Control.Category.Category cat) => cat b b
02:48:46 <latro`a> erm, my translation
02:48:53 <shachaf> nand`: That's not the same id.
02:48:56 <mm_freak> the 'id' you should be using is 'return'
02:48:56 <nand`> oh
02:49:07 <nand`> you're right
02:49:09 <shachaf> You can't do it with just the Arrow/Category primitives, of course.
02:49:11 <mm_freak> you can't express 'join' in terms of (>=>) and 'return'
02:49:13 <shachaf> You don't have that "id".
02:49:29 <mm_freak> but you can express all of Category
02:49:32 <latro`a> I still think this distinction is rather subtle
02:49:39 <latro`a> and not at all clear in that article
02:50:05 <nand`> mm_freak: is this why you get monads from ArrowApply, btw?
02:50:06 <latro`a> (I know it's a draft, don't take this harshly)
02:50:24 <mm_freak> latro`a: i'll revisit it when i find time to continue the tutorial…  i should probably make this more clear
02:50:44 <mm_freak> nand`: ArrowApply implements 'join' basically
02:50:53 <latro`a> the point that "general categories don't actually have function application" is so subtle as to be unhelpful in building intuition
02:51:28 <latro`a> and without that point, ">=> is weaker than >>=" is deceptive if not false
02:51:51 <nand`> I disagree. I think that's what separates categories from (->)
02:51:54 <nand`> not being able to apply them
02:52:11 <latro`a> sorta true
02:52:32 <latro`a> but again, I don't see how that actually helps in building intuition
02:52:37 <latro`a> at least about arrows
02:52:39 <nand`> (Category/Arrow in the haskell sense, at least)
02:52:51 <mm_freak> not at all…  application is a feature of (->)
02:53:03 <latro`a> sure
02:53:10 <mm_freak> anyway
02:53:16 <latro`a> but it's a feature of many many other categories too
02:53:19 <mm_freak> i'm not sure i should mention it
02:53:24 <mm_freak> it may be more confusing than helpful
02:53:26 <nand`> because the point is; they seem like functions but really aren't. you can just compose them together
02:53:28 <nand`> that's the limitation
02:53:42 <latro`a> I think as an introduction to *arrows*, analogizing (.) and >=> isn't actually helpful
02:53:48 <latro`a> because if you have a sane >=> you have a monad anyway
02:54:28 <mm_freak> analogizing is fine, but i'll look for better ways to do it
02:54:48 <mm_freak> because it is /useful/ to know that (.) is like (<=<)
02:54:57 <latro`a> I'd say it's more useful to know the other way
02:55:12 <latro`a> especially since <=< is a little exotic to your audience already, I think
02:55:21 <mm_freak> one of the main aims of the tutorial is to make you /use/ arrows, not just understand them
02:55:28 <nand`> I think Kleisli/<=< should be shown as an example of Arrows, but Arrows shouldn't be explained in terms of them
02:55:31 <mm_freak> also i'll have to bring Applicative more into play
02:55:33 <latro`a> how does this help with getting use?
02:55:35 <nand`> not sure exactly which post this is about though
02:55:41 <latro`a> http://ertes.de/new/tutorials/arrows.html
02:55:51 <nand`> oh, that
02:56:02 <mm_freak> latro`a: the target audience understands monads (at least roughly)
02:56:05 <latro`a> I know
02:56:13 <latro`a> but monads in the context of haskell don't tend to actually use >=> much
02:56:29 <nand`> I didn't see that article as an ‘introduction to arrows’ in its own right; it's an introduction to “what do we get for types that are too weak to be monads?”
02:56:34 <mm_freak> yeah, because (>>=) is more convenient usually
02:56:46 <mm_freak> but sometimes i use (<=<)
02:57:05 <latro`a> the problem is that scoping of lambdas with >>= gives you something richer than a chain
02:57:16 <latro`a> it *is* a chain, obviously, as you can replace >>= with the const thing I described
02:57:17 <mm_freak> unless you cheat =)
02:57:29 <nand`> mm_freak: you mean how arrow notation does it?
02:57:30 <latro`a> but that chain is "unnatural" in some sense
02:57:43 <mm_freak> nand`: hmm?
02:57:52 <mm_freak> latro`a: uncategorical
02:58:16 <nand`> mm_freak: I'm talking about referring to variables from ‘earlier’ in the chain by abusing arr (\x -> (x,x)) and arr (\(x,y) -> (y,x)) heavily
02:58:21 <latro`a> eh, it *is* that, but it feels wrong on a more basic level
02:58:52 <mm_freak> nand`: but /what/ do i mean?
02:59:02 <mm_freak> <nand`> mm_freak: you mean how arrow notation does it?
02:59:21 <nand`> oh, that was a reply to “unless you cheat =)”
02:59:47 <nand`> which I inferred to be a reply to “scoping of lambdas with >>= gives you something richer than a chain”
02:59:58 <nand`> (which arrow notation does too, after all)
03:00:17 <mm_freak> nand`: nah, that was about using application or using non-objects in the category formed by 'type M m a b = a -> m b' and (<=<)
03:00:21 <nand`> oh, I see
03:00:42 <mm_freak> 'id' is not an instance of that M type
03:00:47 <nand`> yeah
03:05:24 <latro`a> arrow notation doesn't recover the "richness" I meant
03:05:31 <latro`a> because it's built into the signature of >>=
03:05:51 <latro`a> the point is that Arrow alone doesn't let you do arbitrary things with the "output" of the computation
03:07:00 <mm_freak> in fact it does…  but it doesn't allow the structure of the computation to depend on individual results
03:07:07 <mm_freak> which for a good reason sounds like Applicative =)
03:07:11 <latro`a> um
03:07:24 <latro`a> then it doesn't let you actually do arbitrary things
03:07:25 <nand`> you mean to say Arrow doesn't allow for branching?
03:07:40 <mm_freak> nand`: no, you need ArrowChoice for that
03:08:02 <latro`a> but you need to go all the way to ArrowApply to do completely arbitrary application, no?
03:08:03 <nand`> mm_freak: would ArrowChoice allow for results of computations to affect what paths are chosen?
03:08:20 <phil_> mm_freak: http://hpaste.org/73038
03:08:21 <nand`> or would ArrowApply be needed for that as well as latro`a said
03:08:21 <mm_freak> latro`a: yeah
03:08:29 <latro`a> that's what I meant
03:08:34 <latro`a> I was stressing *arbitrary*
03:08:46 <latro`a> Arrow restricts what you can do with the output, if only a little
03:08:55 <latro`a> if you don't have the other instances in addition, that is
03:09:38 <mm_freak> phil_: (<*>) is wrong
03:13:35 <hpaste> “Ertugrul Söylemez” annotated “Applicative (Auto a)” with “Applicative (Auto a) (annotation)” at http://hpaste.org/73038#a73039
03:13:41 <mm_freak> phil_: see the annotation
03:16:14 <hpaste> phil annotated “Applicative (Auto a)” with “Applicative (Auto a) (annotation) (annotation)” at http://hpaste.org/73038#a73040
03:17:00 <phil_> mm_freak: I think I got it, annotated
03:17:39 <phil_> but the infix syntax is of course much prettier
03:17:58 <mm_freak> phil_: no
03:18:05 <mm_freak> use my annotation as the basis
03:18:15 <mm_freak> most importantly:  don't replace anything by _
03:18:34 <srhb> I'm having some difficulty reading the Control.Lens docs. I think I can write let foo c = do ((c `member`) . _wWalls) `fmap` get -- in a better way, but I'm totally lost with all the getters. Can anyone lend a hint?
03:18:54 <srhb> ie. I have a wWall lens too, but how do I use it for this purpose?
03:19:16 <shachaf> srhb: :t view
03:19:21 <shachaf> (:t (^.))
03:19:23 <phil_> mm_freak: aren't our annotations identical except the fact that i'm using _? (just making sure)
03:19:39 <mm_freak> phil_: except for the {- ... -}
03:19:41 <phil_> mm_freak: and of course ignoring the in body
03:19:44 <phil_> ok
03:19:45 <srhb> shachaf: Thanks, trying that
03:19:58 <mm_freak> phil_: if you're not using the full result of 'fa' you're doing it wrong
03:20:01 <nand`> ignoring stuff in <*> or >>= in general is a good way to violate some of the monad identity laws
03:20:19 <nand`> (or applicative)
03:20:22 <shachaf> srhb: Oh, you're using Control.Monad.State.
03:20:27 <shachaf> srhb: :t use, I guess.
03:20:35 <mm_freak> phil_: as a hint the first component of your result tuple is correct
03:20:40 <shachaf> srhb: Better yet, :t uses
03:20:42 <mm_freak> but the second is very wrong
03:20:55 <shachaf> uses wWalls (c `member`)?
03:20:58 <shachaf> I don't know.
03:21:04 <nand`> what's `member` here?
03:21:14 <srhb> Data.Set.member
03:21:15 <mm_freak> phil_: notice that the first argument of (<*>) is a stream of functions, and the second argument is a stream of values
03:21:23 <srhb> And uses is the way to go, thanks!
03:21:23 <mm_freak> phil_: the resulting stream must be a stream of applications
03:21:27 <mm_freak> that is a zip
03:21:29 <hpaste> flebron pasted “Idiomatic enough?” at http://hpaste.org/73041
03:21:31 <nand`> srhb: let me ponder your code for a minute
03:22:10 <srhb> Basically I'm trying to rebuild that recent sokoban live coding from Youtube using State and lenses.
03:22:19 <srhb> So this is my isWall c = ... function
03:22:35 <srhb> And I think wWalls `uses` (c `member`) is correct :)
03:23:18 <mm_freak> phil_: the error in your code is that the same function is applied to the whole value stream…  every item in the function stream is ignored except the first one
03:23:23 <flebron> Is the above paste idiomatic? I didn't really like doing that for [1..2], and that (\_ -> do …) seems weird.
03:23:26 <nand`> _wWalls is some field in some record? srhb
03:24:00 <srhb> nand`: Right, which is made into a lens wWalls using Control.Lens.TH
03:24:30 <hpaste> phil annotated “Applicative (Auto a)” with “Applicative (Auto a) (annotation) (annotation) (annotation)” at http://hpaste.org/73038#a73042
03:24:31 <nand`> then I think you might want something like
03:24:33 <nand`> foo c = use (w.contains c)
03:24:43 <nand`> wWall.contains c*
03:24:50 <mm_freak> phil_: now you got it =)
03:24:51 <phil_> mm_freak: aaah, ofc, now i think i got it
03:24:55 <phil_> mm_freak: annotated
03:25:07 <phil_> :)
03:25:19 <mm_freak> moral of the story:  don't just try to match the types =)
03:25:20 <srhb> @index contains
03:25:20 <lambdabot> bzzt
03:25:21 <shachaf> srhb: Ah, there's also contains.
03:25:36 <shachaf> srhb: Data.Set.contains
03:25:38 <mm_freak> phil_: now implement Category
03:25:39 <shachaf> Er.
03:25:41 <shachaf> srhb: Data.Set.Lens.contains
03:25:44 <nand`> Data.Set.Lens.contains :: k -> Lens (Set k) Bool
03:26:04 <shachaf> Wait, it's Lens?
03:26:05 <nand`> Simple Lens even
03:26:06 <shachaf> Not Getter?
03:26:09 <srhb> Beautiful!
03:26:11 <phil_> mm_freak: ill try :)
03:26:12 <nand`> shachaf: yes, you can modify it
03:26:22 <nand`> contains 3 .= True
03:26:25 <shachaf> Oh, right, you can insert because you have the c.
03:26:29 <shachaf> Hah.
03:26:31 <flebron> If I do what hpaste suggests and remove the first "do" from main, ghc whines a lot about "    Warning: Top-level binding with no type signature: main :: IO [()]"
03:26:42 <nand`> srhb: :)
03:26:52 <nand`> srhb: reads much nicer than the old, don't you agree?
03:27:00 <shachaf> flebron: Use forM_
03:27:08 <mm_freak> phil_: runningSumFrom x = Auto (\dx -> (x, runningSumFrom (x + dx)))
03:27:11 <shachaf> Also, use replicateM_
03:27:18 <srhb> Yes, now to tie it together with the state though. :) I was kind of hoping for an operator a la %=
03:27:19 <flebron> I did, and explicitly used main :: IO (), now it whines about "    Warning: Defaulting the following constraint(s) to type `Integer'
03:27:30 <nand`> srhb: what do you mean?
03:27:32 <shachaf> These whines are all unrelated.
03:27:36 <mm_freak> phil_: use 'countFrom 0 . runningSumFrom 0 . pure 5' as your test case
03:27:47 <mm_freak> uh, no
03:28:01 <mm_freak> phil_: use 'runningSumFrom 0 . countFrom 0' as your test case
03:28:08 <flebron> shachaf, they didn't appear when I had the "do" in front of main...
03:28:12 <flebron> http://pastebin.com/cf0KFRuc
03:28:14 <mauke> The paste cf0KFRuc has been copied to http://hpaste.org/73043
03:28:20 <srhb> nand`: Well, it is a stateful computation. The record is in State
03:28:21 <mm_freak> phil_: it should output 0, 1, 3, 6, …
03:28:26 <nand`> srhb: yes, that's what ‘use’ is for
03:28:30 <srhb> oh..
03:28:40 <phil_> mm_freak: ok, will need some time
03:28:41 <nand`> note that you can drop the ‘use’ and use state operators instead
03:28:46 <nand`> wWall.contains k .= True
03:28:49 <flebron> Oh wait, ghc is doing stupid things.
03:28:54 <nand`> wWall.contains k %= not -- etc
03:29:01 <flebron> It's noticing my file hasn't changed and not even compiling it again.
03:29:11 <flebron> So the first time I compile, it whines. After that, it's silent.
03:29:49 <srhb> nand`: Agh, now I get it. use $ wWalls.contains c?
03:29:56 <nand`> yes
03:29:59 <srhb> Excellent. :D
03:30:00 <nand`> note
03:30:01 <nand`> you can also do this
03:30:01 <srhb> Thanks a lot
03:30:05 <nand`> x <~ wWalls.contains k
03:30:12 <nand`> for x <- use $ wWalls.contains k
03:30:17 <srhb> Thanks :)
03:30:22 <nand`> it's some very nice syntax ;)
03:30:28 <srhb> It really is.
03:30:43 <nand`> wait
03:30:43 <flebron> Cool, OK. I didn't remember replicateM_, thanks shachaf :)
03:30:47 <srhb> I find the type signatures of the Getters etc. really hard to read right now, but I'll get there.
03:30:52 <nand`> no, that's something else
03:30:54 <nand`> forget I said anything
03:31:28 <nand`> “bar <~ foo” is for “x <- foo; bar .= x”
03:32:31 <c_wraith> ah.  that makes way more sense.  I was wondering how it could bind a name
03:32:51 <nand`> c_wraith: exaclty, me too :)
03:32:52 <nand`> exactly*
03:33:28 <adnam> hackage mirror please? :)
03:33:35 <Jurily> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
03:33:50 <c_wraith> hackage is back up
03:34:03 <c_wraith> err.  maybe not.  it was earlier, though
03:34:09 <adnam> Jurily: thanks!
03:34:43 <Jurily> sporadic
03:34:54 <Jurily> Prelude is up, GIO is not
03:34:58 <mm_freak> phil_: sorry, the output should be 0, 0, 1, 3, 6, 10, …
03:35:40 <phil_> mm_freak: just a quick technical question? what is the preferred way of importing Control.Category? qualified or unqalified?
03:35:55 <mm_freak> unqualified
03:35:59 <mm_freak> import Control.Category
03:36:03 <mm_freak> import Prelude hiding ((.), id)
03:36:14 <phil_> perfect, thanks
03:37:45 <hpaste> Jurily pasted “Can I assume the file order is oldname -> newname on rename?” at http://hpaste.org/73045
03:43:35 <phil_> mm_freak: how is countFrom defined?
03:44:49 <phil_> mm_freak: or is this something i have to implement?
03:45:11 <nand`> countFrom n = mkPure $ \x -> (n, countFrom (succ n))
03:45:12 <nand`> right?
03:45:53 <rajeshsr> hi
03:45:57 <rajeshsr> if i do cabal update
03:46:01 <rajeshsr> i get:  cabal update
03:46:01 <rajeshsr> Downloading the latest package list from hackage.haskell.org
03:46:02 <rajeshsr> cabal: timeout
03:46:10 <nand`> rajeshsr: hackage is down for maintenance at the moment
03:46:19 <rajeshsr> nand`: ha, thanks!
03:46:32 <rajeshsr> any idea when it will come back?
03:46:33 <phil_> mm_freak: countFrom x = Auto $ \x -> (x, countFrom x + 1)?
03:46:49 <phil_> oops no
03:47:01 <nand`> rajeshsr: no idea
03:47:11 <rajeshsr> nand`: ha, ok!
03:47:15 <rajeshsr> thanks!
03:47:41 <phil_> countFrom x = Auto $ \a -> (a + x, countFrom $ a + x + 1)
03:48:15 <mm_freak> phil_: countFrom x = Auto $ const (x, countFrom (x + 1))
03:48:32 <mm_freak> otherwise countFrom is just runningSum =)
03:48:47 <mm_freak> you can also implement a general combinator
03:49:14 <mm_freak> accum f x' = Auto $ \x -> (x, accum f (f x' x))
03:49:23 <mm_freak> then:  runningSum = accum (+)
03:49:35 <mm_freak> and:  countFrom = accum (\x _ -> x + 1)
03:51:55 <phil_> first gotta figure out how to print Autos :)
03:53:00 <mm_freak> phil_: loop (Auto f) = let (x, a) = f () in print x >> loop a
03:53:26 <mm_freak> perhaps throw a threadDelay or getLine in there
03:53:57 * nand` .oO( instance Show a => Show (Auto () a) )
03:54:16 <nand`> \() -> (0, \() -> (1, \() -> (2 ...
03:54:46 <mm_freak> nand`: you've just become a minor contributor to netwire =)
03:54:59 <nand`> don't tell me you're actually implementing that
03:55:06 <mm_freak> why not?
03:55:11 <nand`> it would be funny
03:55:14 <nand`> :)
03:55:23 <mm_freak> i have so many utility instances already…
03:55:52 <mm_freak> Wire is a Num, a Fractional, a Floating, an IsString and even a Read =)
03:56:05 <nand`> though honestly I feel that can be better done as Auto () a -> [a]
03:56:10 <nand`> (and perhaps vice versa)
03:56:15 <nand`> then showing the [] instead
03:57:01 <phil_> mm_freak: http://hpaste.org/73046 and test works
03:57:31 <nand`> vice versa would look something like toAuto (x:xs) = Auto $ const (x, toAuto xs) -- no? would be partial though
03:57:33 <mm_freak> phil_: your instance is correct, though your names are a bit messed up
03:57:51 <mm_freak> nand`: well, toAuto is nontotal
03:58:08 <nand`> yeah
03:58:11 <phil_> mm_freak: yes, i just used unusual names in order to keep track of the types :)
03:58:11 <mm_freak> except perhaps when you add a 'cycle' in there
03:58:22 <mm_freak> phil_: i'm referring to ff and fx
03:58:32 <mm_freak> phil_: Auto f2 . Auto f1
03:58:39 <nand`> mm_freak: then I would go the route of toAuto :: Stream a -> Auto b a; and cycle' :: [a] -> Stream a
03:58:42 <mm_freak> Auto $ \x'' -> … x' … x
03:58:45 <nand`> with Stream = Free Identity or w/e
03:59:51 <mm_freak> nand`: a better way is not to produce a list in the first place
04:00:45 <nand`> I still might want to define my ‘cyclomatic ["foo", "bar", "bat"]’ though :(
04:00:57 <nand`> unless I'm misunderstanding you
04:00:59 <mm_freak> nand`: i'll add a wire for that =)
04:01:05 <mm_freak> nand`: but normally you wouldn't use that
04:01:06 <nand`> incidentally, that way countFrom = cyclomatic . enumFrom
04:01:19 <mm_freak> in netwire:  countFrom = accum (^+^)
04:01:27 <mm_freak> (^+^) is from the vector-space package
04:02:04 <mm_freak> but i might change that to (+), since with base 4.5 you won't need vector-space that often
04:02:19 <takemitsu> I would like to get myself involved with an Open Source project and I'm willing to spend some time on this.
04:02:27 <takemitsu> Do you guys have somme recommendations?
04:02:40 <takemitsu> Something up to a medium-sized project would be good.
04:02:58 <mm_freak> takemitsu: you may want to participate in one of the various web frameworks
04:03:06 <mm_freak> like happstack, snap or yesod
04:03:21 <takemitsu> Okay, sounds interesting.
04:04:10 <mm_freak> takemitsu: but you should know haskell well before doing that
04:04:42 <takemitsu> How well do you define "well"?
04:05:21 <nand`> takemitsu: I would ask what your interests are first; personally I wouldn't want to work on a project that doesn't interest me
04:05:28 <mm_freak> takemitsu: define Coroutine in terms of Free
04:06:26 <mm_freak> takemitsu: that's a nontrivial task that involves using GHC, cabal, DSLs and the type system properly =)
04:07:07 <DT``> if recursion is an effect, what's its monad? Identity, Cont?
04:07:20 <takemitsu> mm_freak: Looks like I don't know Haskell well enough :)
04:07:23 <nand`> [a]?
04:07:28 <mm_freak> DT``: recursion is not an effect
04:07:51 <mm_freak> takemitsu: my recommendation is to start your own project first and finish it
04:07:53 <nand`> mm_freak: Coroutine?
04:08:04 <DT``> I heard it was, though.
04:08:11 <nand`> what's an ‘effect’?
04:08:24 <Jurily> is (+‿+) a valid operator?
04:08:29 <shachaf> Try it out.
04:08:31 <mm_freak> nand`: see monad-coroutine
04:08:33 <xvilka> hi
04:08:40 <nand`> > generalCategory '‿'
04:08:41 <lambdabot>   ConnectorPunctuation
04:08:45 <nand`> hmm, probably
04:08:48 <DT``> nand`, whatever is the definition of computational effect.
04:08:57 <nand`> > let (+‿+) = (+) in 1 +‿+ 2
04:08:58 <lambdabot>   3
04:09:11 <xvilka> anyone know solvers like Z3 on haskell, or, at least, something that can be part of such solver/etc?
04:09:12 <Palmik> We need smiley face combinator library.
04:09:15 <nand`> new favorite mappend operator?
04:09:31 <nand`> mm_freak: hackage is down :(
04:09:34 <mm_freak> DT``: ContT allows you to implement 'goto', which is recursion
04:09:41 <Palmik> Yes, for many hours now.
04:09:51 <adnam> takemitsu: or http://fay-lang.org/ :)
04:09:54 <mm_freak> nand`: ok, but remember to look at it…  it's a useful package =)
04:09:56 <nand`> yes; but what I'm saying is I can't look at the haddock of monad-coroutine to see Coroutine's definition
04:09:59 <nand`> mm_freak: will do
04:11:05 <mm_freak> nand`: simplified:  newtype Coroutine f a = Stop a | Resume (f (Coroutine f a))
04:11:18 <mm_freak> and no, that's not Free =)
04:11:23 <nand`> that's not Free?
04:11:34 <phil_> adnam: how would you compare fay to https://github.com/valderman/haste-compiler?
04:11:37 <mm_freak> also s/newtype/data/
04:11:51 <mm_freak> nand`: data Free f a = Pure a | Free (f a)
04:12:00 <xvilka> i mean i've found a lot of them, but dont know which is closest to Z3
04:12:02 <mm_freak> uh
04:12:03 <mm_freak> wait
04:12:04 <nand`> no
04:12:09 <nand`> Free (f (Free f a))
04:12:16 <mm_freak> it is Free
04:12:18 <mm_freak> hmm
04:12:19 <nand`> :)
04:12:23 <nand`> well
04:12:27 <mm_freak> ok, that explains my love for Free
04:12:28 <nand`> I implemented Coroutine in terms of Free
04:12:34 <nand`> does that mean I can be a yesod dev now?
04:12:36 <mm_freak> i loved Coroutine before i got to know Free
04:12:45 <mm_freak> so monad-coroutine essentially implements FreeT
04:13:16 <end3rW> I could print a random line out of this channel's log file and it would be the most secure and awesome password ever generated.
04:13:29 <nand`> “:)”
04:13:30 <end3rW> * -out
04:13:31 <mm_freak> newtype Coroutine f m a = Coroutine (m (Either (f (Coroutine f m a)) a))
04:13:38 <adnam> phil_: I am not familiar with haste, but Fay has a lot of focus on the FFI so you can interoperate with js libs
04:13:44 <nand`> end3rW: you could use @quote
04:13:45 <shachaf> My password is "I could print a random line out of this channel's log file and it would be the most secure and awesome password ever generated."
04:13:45 <nand`> @quote
04:13:46 <lambdabot> Phyx- says: is @where ops the equivalent of displaying a bat signal in the sky?
04:14:05 <adnam> phil_: chrisdone can probably give you a more detailed answer :)
04:14:26 <end3rW> shachaf: So much for recursion. :)
04:14:33 <end3rW> @quote
04:14:34 <lambdabot> swix says: seriously though, this thing is too concise, it's scary, given what it does
04:14:44 <mm_freak> most awesome password ever:  "<lambdabot> [0,1,1,2,3,5,8,..."
04:14:46 <nand`> My password is “My password is “My password is “My password is “My password is ...
04:14:52 <phil_> adnam: but fay lacks fundamental things like typeclasses etc... haste seems to be able to compile a large part of prelude and generates small and fast code that can be additionally passed through the google closure compiler
04:14:55 <nand`> I have a hard time typing it. on the plus side, so do attackers!
04:15:00 <nand`> immune to brute force attacks :)
04:15:07 <mm_freak> because the probability to get the fibonacci sequence as your password is very high =)
04:15:20 <shachaf> nand`: That's a rather low Kolmogorov complexity.
04:15:47 <adnam> phil_: type classes are incoming, that said fay is a lot newer i suppose
04:16:11 <nand`> shachaf: yeah but even if the program knows perfectly well how to generate it how is it going to type it out to the server?
04:16:15 <adnam> phil_: as for performance, incoming :)
04:16:35 <shachaf> nand`: Challenge-response!
04:16:57 <shachaf> nand`: Alternatively, the program can upload a program that generates the sequence to the server.
04:17:18 <srhb> Can I do "monadic guards" - I have a number of function that return m Bool, and I want to "case" off of them.
04:17:26 <nand`> ah yes, excellent
04:17:45 <phil_> adnam: it's a pity there is so much duplication of effort when it comes to hs -> js compilers... fay, elm, haste, ghjs, yhs etc
04:17:49 <nand`> the server would have to be pretty sophisticated to verify it though, since the trivial version (just running it) would never terminate
04:18:49 <nand`> uhs -tjs
04:19:12 <adnam> phil_: yeah that's too bad... why can't we all get along? :)
04:19:27 <nand`> why are there so many? surely each team has sat down and said ‘these other compilers exist but they have deficit X which we aim to solve’ ?
04:19:40 <Jurily> why not just implement a haskell interpreter in browsers? :)
04:19:50 <nand`> no problem
04:19:52 <nand`> run ghc through ghcjs
04:20:00 <adnam> hehe
04:20:21 <nand`> (how portable is ghc itself? does it compile in other compilers, eg. uhc or hugs?)
04:21:18 <Jurily> it can be booted by running itself through the C backend
04:21:21 <adnam> Jurily: if you can get all brower vendors to hop on the fp train we'd all be ecstatic :)
04:21:59 <nand`> Jurily: excellent, so we just need a C -> JS compiler?
04:22:53 <Jurily> browsers are written in C/C++ :)
04:22:56 <adnam> there are a few on http://altjs.org/
04:23:25 <nand`> yeah, just saw
04:23:46 <nand`> one LLVM to JS compiler (GHC can compile to LLVM right? or does it just use LLVM for optimizing discrete parts?)
04:24:01 <adnam> oh no a new haskell->js project in the works :(
04:24:10 <nand`> and ‘Clue’ which is a C compiler for -> Lua/JS/Perl 5/C/Java/CL
04:24:20 <nand`> (doesn't a C -> C compiler seem fairly trivial?)
04:24:39 <sipa> already included on my system
04:24:41 <adnam> hehe
04:24:42 <sipa> it's called cat
04:25:03 <Athas> It has poor error detection, though.
04:25:03 <adnam> perhaps they felt the list was too short
04:25:23 <k0ral> is there a problem with hackage ?
04:25:29 <adnam> yes it's down down
04:25:32 <Jurily> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
04:25:33 <k0ral> ok
04:25:51 <Athas> nand`: you'd still need to port part of the GHC RTS to Javascript, wouldn't you?
04:25:55 <adnam> i mean, it's not down, it's never down, it's just temporarily unavailable while they're doing some maintenance that's all
04:26:02 <nand`> Athas: yeah :(
04:26:11 <k0ral> alright
04:26:48 <nand`> Athas: well, it's written in C; but the problem here that C -> JS compilers probably don't allow the kinds of arbitrary system manipulation that the RTS needs to, eg., facilitate IO
04:28:11 <Athas> nand`: that said, it's probably a very realistic task to write a Javascript backend.
04:28:47 <Athas> After all, it's only the very last stage of processing that needs to be replaced.  You can use anything up to and including STG-code without issue, and maybe even the Cmm.
04:29:04 <Athas> Actually, since many GHC intrinsics are written in Cmm, you'd probably want to use that as well.
04:29:13 <phil_> compiling ghc with a hs -> js compiler will probably result in a 50mb js file
04:29:17 <phil_> not very practical :)
04:29:46 <Jurily> we don't need to run ghc in js
04:29:51 <Jurily> just its output
04:30:08 <Targen> No, but with such a backend, you could run GHC natively to produce a JS version of any* Haskell program.
04:30:12 <talios> node.hs?
04:30:25 <phil_> that's what haste is doing
04:30:44 <phil_> it takes the STG output of ghc and translates it to js
04:31:05 <phil_> or whatever that language above Core is called :)
04:31:42 <Athas> Targen: what would you gain from that?
04:32:02 <Athas> phil_: above Core?  You mean Haskell?
04:32:48 <Athas> I don't see the purpose of being able to run GHC in Javascript if you're already able to target Javascript with GHC, especially since Javascript interpreters are pretty slow and bad.
04:33:06 <Targen> Indeed, that’s what I meant.
04:33:19 <yitz> hackage is actually not down. the server is up, and accessible. rather, this is a DNS problem.
04:33:28 <phil_> Athas: don't know if STG is above or below Core tbh
04:33:41 <k0ral> yitz: what's the IP ? :)
04:34:02 <nand`> Targen: no, you would just be running GHC in JS. That still doesn't mean you have a JS backend in your JS version of GHC, does it?
04:34:16 <yitz> galois changed ip addresses on their network - among other things, to make a lot more bandwidth available for hackage and haskell.org
04:34:22 <shachaf> ghci in JS!
04:34:23 <Targen> A possibly more interesting idea would be to get browser people to embed something like a LLVM interpreter.
04:34:53 <yitz> the correct IP address of hackage.haskell.org is 66.193.37.204
04:34:54 <phil_> Targen: yea, get ms to do that :)
04:35:02 <nand`> Athas: the original (non-serious) goal was to embed a haskell interpreter in JavaScript, so you could have Haskell source embedded in your .html file (eg. as string)
04:35:04 <Athas> phil_: Core is compiled to STG after optimisations.
04:35:09 <phil_> js is here to stay unfortunately
04:35:12 <yitz> so if, for now, you pop that into your hosts file, you can access hackage.
04:35:22 <nand`> using GHC and runhaskell both compiled to JS
04:35:25 <phil_> Athas: thanks, good to know
04:35:28 <Targen> nand`: If you have a JS backend in GHC, you have a JS backend in your JS version of GHC.  Not that it’d be of much use, save for indulging in masochism.
04:35:29 <adnam> yitz: oh cool
04:35:46 <nand`> Targen: yeah; I wasn't aware GHC had a JS backend though
04:36:02 <yitz> unfortunately, galois doesn't have access to the haskell.org domain zone files. not sure who does. may take another day or two before it gets fixed.
04:36:59 <Jurily> can someone put the mirror in the topic?
04:37:13 <hamishmack> nand`: https://github.com/ghcjs/ghcjs
04:37:43 <nand`> I thought that's an extra tool that just uses GHC for type checking and other pretransformations
04:38:03 <nand`> but I guess you can compile both GHC and ghcjs to JS
04:38:24 <Reaga> guys
04:38:31 <Reaga> is haskell better than C?
04:38:37 <nand`> @protontorpedo
04:38:38 <lambdabot> so how do you use haskell tools to build large programs?
04:38:40 <Athas> Reaga: yes, objectively so.
04:38:48 <phil_> hamishmack: https://github.com/valderman/haste-compiler
04:38:54 <shachaf> Reaga: Please don't troll.
04:39:06 <Targen> How does instance information work in GHCi?  Is it necessary to include the module that actually defines an instance for :info to note its existence?
04:39:08 <Reaga> im not trolling, im just a curious cat
04:39:10 <hamishmack> In integrated mode it spits out a .jf file along with every object file
04:39:29 * nand` .oO( didn't Reaga get banned for this kind of behavior before? )
04:39:38 <nand`> or am I thinking of somebody else
04:40:17 <nand`> Targen: you mean as opposed to other imports pulling the instance in?
04:40:26 <Reaga> i was banned for criticizing haskell's libraries
04:40:35 <Targen> nand`: Indeed.
04:40:55 <hamishmack> Here is the Fay compiler compiled to .js using ghcjs…. http://ghcjs.github.com/fay-hello-js.jsexe/
04:41:03 <nand`> Targen: I think it might be the latter; test it?
04:41:12 <Reaga> asking if its better than c is a legitimate question
04:41:17 <Reaga> you dont have to answer if you dont want
04:41:46 <Targen> nand`: I think I’ve stumbled into such a situation — was just looking for some form of confirmation or reference to an explanation of how it works :)
04:42:10 <nand`> Targen: what do you mean; what situation have you stumbled into?
04:42:30 <Targen> Reaga: Not really, it isn’t.  There isn’t much of a “better” ordering defined on programming languages.
04:42:47 <phil_> hamishmack: how does ghcjs compare to haste?
04:43:04 <Reaga> Targen: are you saying that no language is worse than haskell then?
04:43:13 <phil_> Targen: typical haskellish answer :D
04:43:15 <Reaga> my point is that not all languages are equal
04:43:44 <Athas> Reaga: indeed not.  Languages are instances of Eq, but not Ord.
04:44:01 <phil_> :)
04:44:02 <nand`> Athas: I would tend to disagree; there are just very many different instances of Ord
04:44:15 <nand`> which ordering you define needs to be taken from some context
04:44:16 <Targen> nand`: Incoherent instances, namely.
04:44:32 <nand`> eg. what you are comparing
04:44:43 <nand`> and who decides what's better
04:44:48 <phil_> nand`: are you trying to say "best tool for the job"?
04:45:07 <hamishmack> nand`: have not tried Haste
04:45:14 <yitz> another problem for answering Reaga's question is that languages are not an instance of Show
04:45:44 <hamishmack> right now I am working on webkit DOM bindings for gtk2hs's webkit package
04:46:09 <Reaga> Which is better? $1 or $100?  You'd say $100 because it's worth more. Now if i said how much is Haskell worth in $ and how much C is worth in $, you give me 2 numbers. I then say the better one is the one which is worth the higher $ amount
04:46:16 <hamishmack> This will be useful for all the Haskell -> JS projects I hope
04:46:24 <nand`> phil_: not necessarily; what I'm saying is that different languages have different attributes by which you can compare by
04:46:46 <Targen> nand`: M imports M.Internal; M.Internal defines some instances of C; if I import only M in GHCi, `:i C` tells me only of some instances, not all; if I import also M.Internal, I get all.[[M := Control.Distributed.Process; C := Process]]
04:46:49 <hamishmack> Because it will make it possible to develop and test code using native tooling.
04:47:02 <phil_> it would be good to somehow get all hs -> js compiler maintainers in one place and try to figure something out... the hs -> js landscape is just too fragmented atm
04:47:03 <hamishmack> before compiling it to JavaScript
04:47:05 <nand`> Reaga: Haskell is about ω²+3
04:47:52 <phil_> Reaga: which is better? to spend $1 or $100?
04:48:15 <Reaga> phil_: thats a tough question
04:48:28 <phil_> there are different contexts in which $1 and $100 can be compared
04:48:35 <Reaga> the answer isnt indeterminate
04:49:02 <nand`> Targen: could it be that the instances you get from importing M are the ones actually in use in M?
04:49:14 <nand`> (ie. M not using every instance defined in M.Internal)
04:49:35 <Targen> nand`: That makes sense.  I’ll check the source and count. :)
04:49:48 <Targen> (compare, really)
04:50:39 <Astro> hi
04:50:47 <Astro> any well-known hackage mirrors?
04:50:53 <Jurily> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
04:51:34 <Jurily> we need to lock the hs->js guys together in a dungeon until they settle on something
04:51:37 <Targen> By the way, I misspoke.  The class itself is not important; I’m asking GHCi about the type so it lists the classes it instantiates.
04:52:33 <phil_> Jurily: yea
04:53:01 <Targen> Jurily: I would have thought sufficient the cruelty of whatever coerces their attention to JS in the first place. :)
04:53:35 <Jurily> well they obviously need to be locked up :)
04:54:14 <phil_> they are heroes, fighting for a better world for us all
04:54:17 <phil_> show some respect
04:54:19 <phil_> :D
04:56:19 <MHD> What is the name of the actually populate computer science channel?
04:56:25 <MHD> populated*
04:57:25 <adnam> what's the difference between calling `error . show` or `throw`?
04:59:55 <Saizan> :t throw
04:59:56 <lambdabot> Not in scope: `throw'
05:00:05 <Saizan> :t Control.Exception.throw
05:00:06 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
05:00:34 <fmap> error ≡ throw . ErrorCall
05:01:51 <MHD> error works in the IO monad only or what?
05:01:51 <MHD> nvm
05:01:51 <MHD> no wait
05:01:57 <adnam> so is it just a matter of how to catch the exceptions?
05:02:16 <MHD> > do a <- error "lol"; Just 1
05:02:17 <lambdabot>   *Exception: lol
05:02:20 <MHD> hm
05:03:21 <Maxdamantus> [error "lol"]
05:03:25 <Maxdamantus> > [error "lol"]
05:03:27 <lambdabot>   [*Exception: lol
05:03:31 <k0ral> yitz: thank you, works fine
05:03:32 <Maxdamantus> Looks like it works in the list monad too.
05:03:45 <Maxdamantus> (actually, it doesn't really have anything to do with monads)
05:03:50 <Targen> error works in any context.  Its type is universal.
05:03:57 <Maxdamantus> :t error "lol"
05:03:58 <lambdabot> forall a. a
05:04:06 <MHD> > do a <- error "lol"; Right 1
05:04:07 <lambdabot>   *Exception: lol
05:04:12 <Guest54855> Jurily: thanks for the mirror link
05:04:14 <adnam> if that's the case i'm happy cause I can error . Data.Text.Groom.groom :)
05:04:39 <MHD> > do 2 <- Right 1; Right 1
05:04:40 <lambdabot>   *Exception: Pattern match failure in do expression at <interactive>:3:3
05:04:52 <yitz> Guest54855: (Astro): but you don't need a mirror. it's a DNS problem. if you put 66.193.37.204 hackage.haskell.org in your hosts file, you can access hackage itself. delete the entry in a few days, after the DNS problem is fixed.
05:05:06 <Guest54855> yitz: thank you very much!
05:05:12 <yitz> k0ral: great!
05:05:36 <Targen> Just noticed something quite amusing:
05:05:39 <Targen> > fix error
05:05:40 <phil_> mm_freak: http://hpaste.org/73051
05:05:41 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:06:08 <nand`> yitz: whoa, nice!
05:15:53 <hpaste> henk pasted “YAHT examples” at http://hpaste.org/73052
05:16:27 <henk> I’m reading YAHT By Hal Daume III et al. but some things don’t work as the document suggest. i.e. using both ghci and hugs I get errors running 'map Char.toUpper "Hello World"', leaving out 'Char.' as noted does not work either: http://hpaste.org/73052. The system is debian testing. What am I missing?
05:16:42 <srhb> Char, apparently :P
05:16:52 <srhb> Which is actually Data.Char I think
05:17:20 <adnam> yepyep
05:18:08 <adnam> henk: either import Data.Char and just use toUpper or import qualified Data.Char as Char and use Char.toUpper
05:18:13 <typoclass> henk: try importing Data.Char
05:18:21 <typoclass> > map toUpper "abc"
05:18:23 <lambdabot>   "ABC"
05:18:30 <srhb> > Data.Char.toUpper 'a'
05:18:31 <henk> srhb: Ah, 'map Data.Char.toUpper "Hello World"' does actually work fine in ghci, hugs still does not like it.
05:18:31 <lambdabot>   'A'
05:18:33 <srhb> SHould work fine
05:18:44 <srhb> henk: You shouldn't use hugs anyway.
05:19:49 <henk> adnam, typoclass: That works too, thank you :)
05:20:04 <Athas> The Char module is Haskell 98.
05:20:15 <henk> srhb: ok, I wanted to go with ghc anyway … Thank you very much :)
05:20:18 <Athas> Haskell 98 has a lower number than Haskell 2010, and is hence inferior.  Use Data.Char.
05:20:58 <adnam> importing Char does nothing? O_O not even a warning
05:20:58 <typoclass> henk: some background info -- the one-word module names ("Char") are often from haskell98 or other old stuff. the modern names are nearly always two or more words ("Data.Char"). it's usually no big deal
05:21:29 <typoclass> adnam: no, i think he had an error "can't be imported, is member of hidden package haskell98"
05:21:44 <typoclass> > 2010 - 98 -- Athas
05:21:45 <lambdabot>   1912
05:22:08 <yitz> ok just got word that Igloo fixed the DNS. so after propagation to your neighborhood DNS server, hackage should work normally without the hosts file entry.
05:22:28 <henk> Athas, typoclass: Good to know, thanks
05:23:25 <adnam> typoclass: ok, but just running `import Char` in ghci does nothing
05:23:54 <srhb> adnam: It would if you installed haskell98, pretty sure.
05:24:00 <srhb> adnam: Of course, everything would break. :-)
05:24:05 <adnam> T_T
05:24:22 <typoclass> adnam: not sure :) i was referring to henk's paste
05:24:40 <Athas> There's nothing wrong with having the haskell98 package installed.
05:24:46 <Athas> I'm pretty sure all Haskell installations have it, in fact.
05:25:06 <typoclass> srhb: i think the haskell98 it's installed by default, but not used (much)
05:25:12 <Athas> Hell, you can even import both Char and Data.Char in a module and it'll work fine.
05:26:10 <srhb> typoclass: I don't think it is.
05:26:23 <srhb>  typoclass: If you by default mean haskell platform
05:26:28 <Jurily> with ghc, it is
05:26:37 <Jurily> just hidden by default
05:27:01 <srhb> I certainly wonder where they put it then.
05:27:26 <Jurily> jurily@jurily ~ $ ghc-pkg list | grep haskell98
05:27:28 <Jurily>     (haskell98-2.0.0.1)
05:27:59 <srhb> Jurily: Right. It's in some weird place on Mac. :/
05:28:15 <typoclass> srhb: i don't have the platform, but when i do "ghc-pkg list", haskell98 is listed (but hidden). not sure who installed it. i suspect they just include it with ghc for backwards compatibility. it doesn't cost much to include it
05:29:13 <Jurily> it's in the ghc directory, right next to base
05:36:57 <Palmik> Hmm, is it possible to make vim's syntastic aware of the "extensions" field in cabal file?
05:47:26 <timthelion> is the source code to the IO data construct to be found somewhere, or is it a magic top level type in haskell?
05:48:28 <srhb> timthelion: If you're asking if the source for the IO Monad is Haskell, the answer is no.
05:49:40 * timthelion always was skeptical of their claims...
05:49:55 <nand`> it's magic
05:50:44 <srhb> timthelion: GHC defines return thusly, for instance: returnIO x = IO $ \ s -> (# s, x #)
05:50:59 <srhb> (Not that that means much)
05:51:54 <timthelion> I know.  That's what bugs me.  The whole Monadic IO thing has this mystic aura around it. If you reduce it down to(without ever using the word "Monad") "So we use a special data constructor that holds computations. And we make that data constructor a member of a type class that allows you to string those computations together, without actually seeing the stringing together of the computations."  Then it doesn't seem like such an ingeneous a
05:52:37 <srhb>  timthelion: Um, okay. :P
05:52:43 <nand`> it got cut off after ‘ingeneous [sic] a’
05:52:44 <srhb> timthelion: You try to come up with it then. ;)
05:52:59 <timthelion> an ingeneous and beautiful idea...
05:53:17 <srhb> timthelion: Well, it is. :-)
05:53:30 <timthelion> srhb: I'm not saying it's not cleaver.  I'm just saying that there's all this religeon about it, that is rather BSy
05:53:46 <srhb> timthelion: Okay. :P
05:53:52 <nand`> timthelion: the ingenious idea here is that any forms of IO (read: side effects) are encapsulated in a type which prevents it from interacting directly with pure functions
05:53:58 <nand`> not the particular system of representing this
05:54:47 <srhb> This idea is not necessarily new, but when you understand the strengths of this model, and you notice how few other languages uses this (ingenious, beautiful) model, you should realize how clever it really is.
05:56:09 <srhb> I don't see any religion about it really. People find it hard to comprehend, sure, and I guess that might be what you mean by religious. The benefit it gives you is factual.
05:56:19 <timthelion> srhb: I just think, that the fact that we name the idea after the type class who's laws are followed(aka the Monad) shows an utter lack of understanding of the triviality of THAT part of the equation.  Really, we could do the same thing, using a typeclass that DIDN't follow the monadic laws.
05:57:48 <timthelion> From a pedagogic standpoint, I think we should teach IO in haskell without refference to monads.  We should explain it only in reference to special data constructors and typeclasses(two things that are much easier to "Grok" due to the more familiar names)
05:58:09 <srhb> timthelion: So, you think Monadic IO is a bad idea?
05:58:36 <Saizan> timthelion: the laws are the bare minimum of properties you want to be able to reason about such code
05:58:46 <srhb> timthelion: I think this discussion is easier if you come up with the alternative to monadic IO.
05:58:53 <timthelion> srhb: I think it's a fine idea. But I think that naming it "Monadic" as if the fact that some of the functions are bound by the monadic laws had anything to do with it.
05:59:09 <srhb> Well, it does have something to do with it.
05:59:31 <srhb> But really, just come up with that "other and more pedagogical idea" and it'll be a much more interesting talk. :)
06:00:26 <srhb> I don't think renaming Monad Bloobab will make much of a difference. :-)
06:00:33 <nand`> there are much better ways of implementing IO internally than GHC's \s -> (# s, x #) stuff :)
06:00:54 <srhb> I don't think internally is the issue here, if I understand timthelion correctly.
06:01:02 <nand`> (that was not a reply to timthelion)
06:01:05 <timthelion> srhb: imagine, if in school they didn't teach "handwritting" but "slow graphite transfer techniques" and started to talk about the physics of graphite transfer onto paper in 1st grade.  How many people would learn to handwrite?  How many normally inteligent kids would fail to understand simply because they made the connection that "ink transfer" is similar(despite the teachers insistance that they have nothing to do with eachother)
06:01:09 <srhb> Ah
06:01:13 <nand`> it was a replay to the earlier ‘returnIO’ snippet
06:01:15 <nand`> reply*
06:01:39 <srhb> timthelion: I think that's why a lot of people teach do IO rather than Monad IO
06:02:10 <Targen> timthelion: I would venture Haskell simply isn’t a proper language for an informal introduction to programming, which may be the real issue here.
06:02:25 <Saizan> timthelion: people should learn to not get butthurt by things they don't understand ending up to devaluing such things just to feel safe afain
06:02:45 <timthelion> Targen: you would rather that people where introduced to a less formally sound, more conceptually chaotic language first?  Like Python?
06:03:08 <srhb> I've had fine success with skipping the whole Monad stuff, or just saying "understand that >>= does this conceptually"
06:03:23 <srhb> You don't need the bitshifting to understand the concept.
06:03:40 <Targen> timthelion: Not necessarily.  Perhaps one should first introduce massive amounts of theory, and then program formally, only to relax the bounds of the type system much later.  But I’m likely not in numerous company in this opinion :)
06:03:45 <Saizan> what keeps haskell formally sound is the focus on principle abstractions, e.g. typeclasses with laws
06:03:58 <Saizan> *principled
06:04:21 <phil_> buch of conservatives
06:04:26 <phil_> thats what yegge would say lol
06:04:43 <srhb> mentioning Yegge should cause an instaban. :P
06:04:57 <phil_> yes :D
06:05:07 * timthelion had to google the fella
06:05:37 <Targen> timthelion: Monads are a rather fantastic tool for formal reasoning about side effects, as they closely correspond to the natural representation of such things in denotational semantics.  I venture either formality or ease must be sacrificed, and if ease it must be, then monads are an excellent way of walking the formal route to teaching programming.
06:05:38 <Jurily> if that helps any, he got me interested in Haskell with that blog post of his
06:05:53 <srhb> Jurily: Just proves that there's always an upside. ;)
06:05:56 <timthelion> Is he a gun collecting person who just happens to have a "Haskell" section on his blog?
06:06:25 <srhb> timthelion: By asking such a question you're turning the chat to the topic of Yegge, which will not lead anyplace good. You can Google him :P
06:06:44 <Targen> timthelion: And if ease is to be preserved because it’s a first course in programming without the luxuries of a background in formal languages and their semantics, formality may happen to be an unavoidable casualty.
06:06:48 <timthelion> srhb: I'm going down that rabit hole now.
06:06:57 <srhb> timthelion: I will pray for you.
06:07:03 <timthelion> Targen: Fair enough
06:07:35 <timthelion> srhb: I can handle anything short of graphic --- abuse...
06:07:54 <Saizan> btw we should publicize (and maybe modernize) wadler's original papers about monads in FP, they are probably still the best resource
06:08:41 <timthelion> srhb: he's from my hometown
06:09:07 <nand`> timthelion: but can you handle the madness that is infinity?
06:09:28 <timthelion> nand`: of course.  I look in the mirror every day.
06:09:55 <nand`> I live in a perfect cube lined with mirrors
06:10:00 <Jurily> I'm not sure what all the fuss about monads is... in a lazy functional language, all you know is that in f (g (x)), g(x) will be evaluated first. It's just a small step from there to (>>=) :)
06:10:50 <Saizan> Jurily: actually, in f (g x) it's not (g x) that gets evaluated first
06:11:09 <barrucadu> Jurily: `f = const 5` - in f(g(x)), g(x) never gets evaluated there
06:11:53 <barrucadu> > let f = const 5 in f $ error "foo"
06:11:55 <lambdabot>   5
06:11:58 <Saizan> Jurily: but also, monads would work in an eager language too (some implementation details of specific monads would have to change though)
06:13:51 <phil_> i never had the impression that monads and laziness are conceptually coupled
06:13:53 <phil_> are they?
06:13:58 <Saizan> one of the points of writing monadic code is detangling the execution of effects from evaluation of expression
06:14:01 <phil_> they shouldnt be
06:14:26 <srhb> Only in #haskell... :-)
06:14:56 <Saizan> they aren't per se, but because of the detangling i'm mentioning above you get an easier time reasoning about effects in a lazy language thanks to monads
06:15:38 <Jurily> I meant that in the context of reproducing the imperative sequential semantics we all know and love in other languages
06:16:30 <Yenpi> can you dropwhile length > something?
06:16:33 <Yenpi> @src dropWhile
06:16:34 <lambdabot> Source not found.
06:16:49 <Yenpi> > dropWhile (<= 10) [1..20]
06:16:51 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
06:16:53 <nand`> > dropWhile (length > 3) ["hello", "world", "foo", "bar"]
06:16:55 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
06:16:55 <lambdabot>         against inferred ...
06:17:02 <Yenpi> :t dropWhile
06:17:04 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
06:17:14 <Yenpi> nand: the whole list
06:17:17 <srhb> Yenpi: The argument to the predicate is the currect element
06:17:23 <Yenpi> yeah i see
06:17:43 <nand`> there's no Ord a => Ord (b -> a) instance?
06:17:43 <Saizan> Jurily: you still got lazy evaluation backwards in that comment, and i don't see the context helping that :)
06:17:45 <nand`> what a shame
06:17:54 <srhb> Yenpi: It would also be horrible, you'd have to run length all the way through each time.
06:18:10 <nand`> wait, that would not make sense
06:18:13 <nand`> never mind my ramblings
06:18:25 <srhb> O(n^m), eek
06:18:34 <nand`> Yenpi: I don't know what you are asking for then
06:18:41 <srhb> drop until list is shorter than ...
06:19:02 <srhb> so it's basically drop (length xs - ...) xs
06:19:06 <nand`> reverse . drop n . reverse
06:19:08 <nand`> :P
06:19:13 <nand`> take n*
06:20:21 <Reaga> haskell isnt an equatio solving package
06:21:02 <Yenpi> :t drop
06:21:04 <Reaga> so if i say  (a + b) / a = a / b  ... what will it do
06:21:04 <lambdabot> forall a. Int -> [a] -> [a]
06:21:08 <Reaga> will it figure out the golden ratio
06:21:29 <srhb> > let (a + b) /a = a / b
06:21:31 <lambdabot>   <no location info>: Parse error in pattern
06:21:34 <srhb> Reaga: There you go
06:22:54 <Reaga> srhb: what is that
06:23:01 <srhb> Reaga: The error that you will get.
06:23:24 <Yenpi> > is there a list-data that has O(1) for length? like store the list length as an attribute?
06:23:25 <lambdabot>   <no location info>: parse error on input `data'
06:23:49 <ion> I like how far it parsed that.
06:24:00 <srhb> :D
06:24:25 <srhb> Yenpi: You can use arrays.
06:24:45 <Saizan> or Data.Sequence
06:27:47 <DMcGill> seconding Data.Sequence, arrays are very different from lists whereas Sequence is quite similar
06:31:03 <xorox90> haskell is really used in real business?..
06:31:16 <Jurily> define "real"
06:31:29 <phil_> banks are pretty real imo
06:31:44 <xorox90> hmm... easy develope, fast develop, many developed case.. so I can find example easilly
06:31:52 <phil_> anyway: http://www.haskell.org/haskellwiki/Haskell_in_industry
06:31:59 <xvilka> 'serious business' :D
06:32:05 <xorox90> thx...
06:32:24 <Jurily> whenever someone says "real world", it's usually a No True Scotsman
06:34:02 <phil_> got my first haste js program working \o/
06:34:03 <phil_> http://hpaste.org/73055
06:34:08 <hughfdjackson> Jurily: hadn't thought about it in those terms, but certainly seems to be n.n
06:35:12 <phil_> http://i.imgur.com/DAupm.png
06:35:45 <hughfdjackson> phil_: n.n nice
06:35:46 <phil_> uncompressed, unminified file size: 20kb
06:35:59 <phil_> so probably about 5kb compressed
06:36:01 <phil_> pretty nice
06:36:29 <efie> When I search hoogle for "letter +parsec" I get "Text.Parsec.Char" and "Text.ParserCombinators.Parsec.Char" - which one should I use and why?
06:37:56 <luite> the second one is mainly for compatibility with parsec 2
06:38:29 <luite> so the first if you just want 3
06:39:00 <efie> luite: parsec 3 is newer than parsec 2 I guess? So I should stick to the first?
06:39:42 <efie> thanks
06:39:45 <luite> efie: right
06:57:27 <phil_> google closure got that down to 3k
06:57:41 <phil_> ill never write js again
06:57:55 <silver> got what down?
06:58:10 <Jurily> yay!
06:58:53 <phil_> silver: the compiled js output of http://hpaste.org/73055
06:59:23 <phil_> and 90% of it is just the runtime
06:59:48 <silver> oh
07:05:17 <yitz> hmm the new IP for hackage hasn't propogated to me yet. i wonder what the ttl was set at.
07:06:18 <yitz> anyway, i've got to sign off now. so please, when people start seeing the new IP (see channel log above), please ask an op to remove the "haskell down" message from the topic.
07:13:30 <till_t> phil_: how are u compiling hs->js?
07:13:36 <nand`> till_t: haste
07:13:46 <nand`> https://github.com/valderman/haste-compiler
07:14:00 <nand`> till_t: but note that there are about half a dozen or so other HS -> JS compilers
07:14:28 <till_t> i'm currently using uhc with its js-backend but the experience isn't the best
07:14:32 <till_t> thank you
07:15:08 <adam_> Hello, does anybody know what's up with hackage?
07:15:33 <Jurily> [14:04] <yitz> Guest54855: (Astro): but you don't need a mirror. it's a DNS problem. if you put 66.193.37.204 hackage.haskell.org in your hosts file, you can access hackage itself. delete the entry in a few days, after the DNS problem is fixed.
07:15:55 <till_t> do i get the stdlibs with haste? like Data.Map and Data.Set that are not part of haskell98?
07:15:58 <hiptobecubic> adam_, for me it's up. Just wait for dns to propagate.
07:17:52 <nand`> till_t: looks like it judging by https://github.com/valderman/haste-compiler/blob/master/Tests/Map.hs
07:20:51 <till_t> nand`: great, i'll take a deeper look at haste
07:23:00 <Refried__> good morning
07:23:11 <hiptobecubic> Sure are a lot of warnings when building HaXML...
07:24:58 <phil_> till_t: yes, haste is a backend to ghc
07:25:10 <phil_> but its pretty clever and the generated code is pretty small
07:25:32 <LucasCampos> Hey there. Have any of you been successful when building Yi from darcs on a Fedora 17?
07:26:25 <adnam> is anyone developing yi nowadays?
07:27:00 <LucasCampos> I don't know
07:27:24 <adnam> oh seems like it
07:30:09 <tcrayford> anybody know why ghci is so slow to startup on my machine? It takes ~1s or so, which is *way* too slow for my purposes. Is a 1s ghci startup time normal?
07:30:40 <Botje> tcrayford: i have something similar.
07:30:59 <Botje> tcrayford: presumably it is reading ghc pkg_list and all that?
07:31:12 <tcrayford> Botje: I assume so
07:31:46 <geekosaur> I think most of the time is spent bootstrapping its bytecode interpreter with the prelude etc.
07:32:11 <tcrayford> yeah
07:32:27 <tcrayford> I'm probably just spoilt by interpreted language's startup speed :/
07:32:45 <geekosaur> unoptimized interpreted language
07:32:50 <tcrayford> yes
07:32:58 <tcrayford> I don't care about optimization in this case though
07:33:19 <geekosaur> I meant more the operations of the interpreter itself
07:33:35 <tcrayford> the code I'm running is finished in sub 100ms, so a 1s interpreter startup time is pretty bad
07:34:09 <geekosaur> most interpreted languages have had a lot of work put into making the interpreter's own operations fast; ghci isn't really intended for that kind of use, so it's had very little effort put into making it e.g. load modules quickly
07:34:10 <tcrayford> geekosaur: I don't really follow that :/
07:34:19 <tcrayford> oh, that's probably true
07:34:24 <luite> tcrayford: you can do faster if you're willing to make a daemon that preloads the interpreter and then forks for new requests
07:34:41 <geekosaur> the primary focus is debugging and such
07:34:47 <tcrayford> luite: you definitely can, but it's a lot of extra complexity
07:35:18 <Jurily> you shouldn't have to restart it a lot though
07:35:26 <tcrayford> it's true
07:35:33 <phil_> cant you just reload the module inside ghci?
07:35:37 <phil_> :r
07:35:48 <tcrayford> phil_: then the limitation is my typing speed ;)
07:36:23 <luite> use some emacs script to do reloads?
07:36:32 <tcrayford> cmd-shift :r <cr> :main<cr> takes long enough for me to type that ghci is faster
07:36:36 <tcrayford> luite: I'm in vim :/
07:36:44 <luite> oh i guess there must also be vim scripts
07:36:59 <phil_> i use vim-haskellmode
07:37:03 <tcrayford> yeah. I don't really want a ghci inside my vim though, but I guess I should look into it
07:37:30 <phil_> but it still has to restart ghci every time you wanna eval an expression, but its pretty fast on my end
07:37:36 <phil_> probably 300-400ms
07:37:41 <parcs`> tcrayford: there's an interpreter on hackage that compiles the script in your home directory on the first run and on subsequent runs runs the compiled binary
07:38:02 <tcrayford> parcs`: I'm changing the script that I'm running repeatedly
07:38:17 <Jurily> vim can't handle daemon-type helper programs?
07:38:41 <tcrayford> Jurily: it *can*, but vimscript is basically the worst programming language ever invented
07:38:43 <phil_> Jurily: it can, but haskellmode just isnt made that way
07:38:50 <phil_> agree
07:39:06 <Jurily> http://www.vim.org/scripts/script.php?script_id=2356
07:39:29 <phil_> but the clojure plugin *has* to talk to a daemon, because java startup times are ridiculous
07:39:42 <tcrayford> phil_: 300-400ms is far faster than my ~1s. I think this might be something to do with 64bit ghc on osx though
07:39:51 <tech2> Could always use Yi editor ;)
07:39:52 <tcrayford> phil_: I stopped using clojure because of startup time ;)
07:40:23 <phil_> tcrayford: there's a java daemon just for that :) btw im also on 64bit macos
07:40:25 <Jurily> I came from C++. When I want to typecheck, I compile :P
07:41:19 <phil_> tcrayford: however, startup time may also depend of file size and imported modules
07:41:33 <phil_> so 1sec is actually absolutely possible
07:42:05 <nand`> some 400ms or so on my machine ‘time echo ':q' | ghci’
07:42:06 <phil_> Jurily: you should try lisp :)
07:42:32 <tcrayford> phil_: that sounds about right here actually, which isn't so bad
07:42:41 <phil_> nand`: this is *way* faster here, 150-200ms
07:42:44 <tcrayford> I guess it must be the modules I'm importing and such then :/
07:42:44 <geekosaur> actually that's a good point re 64bit OS X, we know that one's broken (but unfortunately also mandatory in a number of cases... can't win)
07:42:58 <nand`> tcrayford: what are you using ghci for? maybe runhaskell would be better?
07:43:35 <rosie> I'm trying to divide two numbers, and I'm using this data constructor: data Term = Con Int | Div Term Term. Why do I get this error? No instance for (Num Term)      arising from the literal `8' Possible fix: add an instance declaration for (Num Term)    In the first argument of `Div', namely `8'
07:43:54 <geekosaur> nand`, runhaskell is indistinguishable from ghci whatever.hs <<< :main
07:43:59 <rosie> I'd be happy to provide more code
07:44:14 <ion> “:main”?
07:44:20 <geekosaur> er
07:44:31 <geekosaur> rosie, the constructor is always required.  Div (Con 8)
07:44:38 <geekosaur> :run
07:44:56 <ion> Oh, i hadn’t noticed :main before. I take it it’s different from just “main”?
07:44:59 <geekosaur> no, I did mean :main
07:45:15 <geekosaur> for one thing, parameters passed go into where getArgs will see them
07:45:16 <rosie> geekosaur: awesome, thanks!
07:45:21 <ion> ok
07:45:22 <tcrayford> yeah, I guess this must be a "you're importing too much"
07:45:50 <tcrayford> my project could probably be broken up into less files (it's ~30 right now)
07:45:57 <nand`> geekosaur: time runhaskell HelloWorld.hs => [168ms, 167ms, 168ms]; time echo ':main' | ghci HelloWorld.exe => [411ms, 416ms, 413ms]
07:46:01 <geekosaur> yeh, that will be slow with ghci or runhaskell
07:46:14 <geekosaur> hm, ok
07:46:27 <tcrayford> that is *weird* :/
07:46:58 <tcrayford> I'm getting things faster with runhaskell as well
07:47:14 <tcrayford> like maybe .6s of interpreter startup
07:47:55 <rosie> I've read that you can append a newline to a string using ++ "\n". Why am I seeing the literal \\n characters in the output?
07:48:07 <nand`> rosie: probably because you're using ‘show’ somewhere
07:48:14 <rosie> yes, thanks
07:48:27 <nand`> > show $ "foobar" ++ "\n"
07:48:29 <lambdabot>   "\"foobar\\n\""
07:48:54 <phil_> rosie: or print
07:48:57 <geekosaur> course that;s double-"show"ed because lambdabot already does show
07:49:15 <nand`> yeah that too
07:49:24 <nand`> it does generate a \\n though, maybe rosie is double-showing as well?
07:49:33 <nand`> > "foobar" ++ "\n"
07:49:35 <lambdabot>   "foobar\n"
07:49:48 <phil_> > print "\n"
07:49:49 <lambdabot>   <IO ()>
07:50:44 <Refried__> Doesn't it bug people that readFile :: FilePath -> IO String instead of       FilePath -> IO (Maybe String) ?
07:51:30 <nand`> Either FileError String
07:51:48 <DMcGill> is there a DerivingMonoidInstances flag?
07:51:51 <Jurily> *String*
07:52:00 <tcrayford> I guess I'ma try 32bit haskell platform, see if it's faster. Thanks nerds :)
07:52:08 <DMcGill> seems that Monoid a, b => data Foo = Foo a b
07:52:14 <DMcGill> has a pretty obvious Monoid definition
07:52:23 <Refried__> nand`: sure — FilePath -> IO (Either FileError String)
07:52:53 <nand`> though can be a bit misleading for lazy IO in general - the error could happen because a file got deleted before you finished reading it out
07:53:11 <Refried__> nand`: good point... hmm
07:53:16 <nand`> it'd still have situations in which it'd probably need to throw an exception
07:53:54 <Refried__> that makes sense
07:54:06 <Refried__> feels like "don't care if my executable crashes, as long as my code is pure" though
07:54:30 <phil_> well its in IO so it isnt pure anyways
07:54:48 <phil_> but having to catch exceptions goes a bit too far, i agree :D
07:54:49 <Refried__> i'm trying to put together a presentation on the benefits of pure FP for my impure coworkers, but struggling to really distill the value
07:54:58 <nand`> the thing is
07:55:05 <nand`> readFile makes sense for when you don't care about handling errors
07:55:06 <Refried__> i mean "how is this different from what we're already doing" sort of thing
07:55:06 <DMcGill> Aggressive optimisations
07:55:20 <DMcGill> data sharing and so on
07:55:22 <nand`> if you do, you probably shouldn't be using readFile
07:55:29 <geekosaur> ^^
07:55:40 <Refried__> nand`: I'm a haskell newbie myself — is there an alternative api to readFile?
07:55:41 <DMcGill> or were you after more impacts on your programming style?
07:55:44 <nand`> Refried__: static guarantees using the type system
07:55:53 <geekosaur> readFile is quick and dirty and kinda the opposite of what FP ois really about.  want something more FPish, take a look at enumerator-based I/O
07:56:11 <phil_> Refried__: do impure stuff and call pure functions from main
07:56:13 <nand`> many ways to do file I/O
07:56:17 <phil_> and then focus on the pure functions
07:56:30 <nand`> ranging from conduits to just loading out bytestrings in one big chunk
07:56:46 <DMcGill> idealy you'd have one impure top level function that calls a bunch of pure functions to do all the computation
07:57:04 <Refried__> DMcGill: I think I was shooting for "automagically eliminates big classes of common bugs that you coworkers make", but struggling to find good examples of such
07:57:23 <nand`> Refried__: forgetting to check for NULL pointers
07:57:28 <DMcGill> the flow of data is explicit
07:57:37 <nand`> Refried__: forgetting to check for integer overflow (Integer solves this)
07:57:42 <Refried__> DMcGill: but I like the data-sharing aspect;   not sure our applications are big enough to benefit hugely there
07:57:49 <Jurily> python runtime type errors, javascript automatic casting
07:58:09 <DMcGill> oh god javascript automatic casting
07:58:12 <DMcGill> awful by design
07:58:33 <nand`> Refried__: exact fractional reasoning, eg. guarantees that a/b*b = a for all b≠0
07:58:35 <rosie> phil_: how can I use "print" to print the newline? Let's say the code that needs modification is: line a = show a ++ "\n"
07:58:40 <Refried__> They are coming from Java
07:58:49 <nand`> (many people make the mistake of forgetting that in other languages)
07:58:50 <phil_> rosie: use putStrLn
07:59:02 <DMcGill> print x = putStrLn (show x)
07:59:03 <DMcGill> I think
07:59:03 <Refried__> nand`: ah
07:59:21 <phil_> Refried__: quickcheck!
07:59:35 <phil_> just show them something in quickcheck and you will win them over
07:59:42 <Refried__> phil_ :-D
07:59:54 <nand`> if you're *forced* to use print (eg. by some stupid API) you could newtype String and instance Show where show = id :)
07:59:54 <phil_> im serious :D
08:00:04 <nand`> quickspec!
08:00:13 <Refried__> phil_: yeah quickcheck is pretty cool; i've been looking at scalacheck, but haven't tried it
08:00:23 <rosie> phil_ and HMcGill: how do I  resolve this? It sources from my use of show a ++ print "\n".   Couldn't match expected type `[Char]' with actual type `IO ()'"F
08:00:32 <rosie> *no F
08:00:34 <Jurily> a big part for my Haskell conversion was the time complexities on Seq
08:00:40 <phil_> rosie: show a ++
08:00:45 <phil_> rosie: show a ++ "\n"
08:00:50 <Refried__> Jurily: ?
08:01:08 <phil_> nand`: what is quickspec?
08:01:19 <nand`> one of my favorite aspects about Haskell, besides the strict static typing, is the incredible amounts of code you can re-use; simply by generalizing concepts to absurdity
08:01:28 <rosie> phil_: What do you mean? where is the use of print?
08:01:42 <Refried__> phil_: "http://publications.lib.chalmers.se/records/fulltext/local_125255.pdfhttp://publications.lib.chalmers.se/records/fulltext/local_125255.pdf"
08:01:44 <Refried__> oops
08:01:45 <eevar> can someone confirm that the hackage server running on 66.193.37.204 is legit?
08:01:47 <nand`> phil_: the opposite of quickcheck: instead of you telling it tests and it checking them; it looks at a bunch of samples and tries to infer the laws on its own
08:01:47 <phil_> rosie: you don't need to use print in that case
08:01:50 <Refried__> "QuickSpec: Guessing Formal Specifications using Testing"
08:01:52 <nand`> at least that's how I understood it
08:01:56 <nand`> (I've never actually used it)
08:02:05 <rosie> I end up getting literal the \n in that case...
08:02:12 <rosie> phil_:
08:02:42 <phil_> rosie: ah, try putStrLn $ show a
08:03:02 <phil_> nand`: interesting
08:03:39 <rosie> phil_: how should I keep the result as a String and not an IO () ?
08:03:59 <phil_> rosie: what exactly are you trying to do?
08:05:12 <DMcGill> rosie: if you want a print statement in the middle of your code, use Debug.Trace.trace
08:05:27 <DMcGill> but as the name implies, it's for debugging
08:05:36 <rosie> phil_: I'm trying to print the result of a div operation that contains nested divs. As in: eval (Div (Con 1972) (Con 2)) <= 986
08:06:44 <phil_> if you want to just print it, then: main = putStrLn $ show $ eval (Div (Con 1972) (Con 2)), if you want to debug something, what DMcGill said
08:07:40 <rosie> phil_: hypothetically, what if I wanted to pass the String result to another function that expects a String before outputting it to main?
08:08:06 <nand`> the output of ‘show’ is a String
08:08:07 <phil_> then you would do otherFunc $ show $ eval ...
08:08:24 <DMcGill> rosie: read some of LYAH, it'll really help
08:08:26 <DMcGill> @where lyah
08:08:27 <lambdabot> http://www.learnyouahaskell.com/
08:08:31 <phil_> or alternatively let resString = eval ... in otherFunc resString
08:08:49 <rosie> thanks! I'll check out lyah
08:08:50 <DMcGill> rather than just muddling through and asking us step by step, lyah is really good
08:09:01 <rosie> sounds good
08:09:17 <phil_> yea, haskell cant be picked up like most other languages by just experimenting with stuff
08:09:21 <phil_> at least i couldnt
08:10:11 <rosie> phil_: thanks for the advice (:
08:14:37 <till_t> did anyone manage to install haste-compiler on a mac (mountain lion)?
08:14:52 <phil_> till_t: i just submitted a patch to do just that :)
08:15:04 <phil_> you cant compile the download package, right?
08:15:10 <till_t> oh, u fixed the libio-problem?
08:15:13 <till_t> yeah right
08:15:14 <phil_> yea
08:15:33 <phil_> https://github.com/pkamenarsky/haste-compiler
08:16:01 <phil_> get it from here until the pull request is (hopefully) accepted
08:17:50 <till_t> its compiling now :) thank you very much
08:17:58 <KJChernov_> is it ok to handle networking via Network module, not Network.Socket+Network.Socket.ByteString?
08:18:04 <phil_> np :)
08:18:14 <rtharper> KJChernov_: I won't judge you.
08:18:19 <KJChernov_> :)
08:19:34 <zmoazeni> Hi folks, I'm working on a CSS parser and slowly learning attoparsec. I've nailed down CSS colors, but I'm stuck on optional values. I thought that was what "try" was supposed to do, but no luck. Could someone give me a hand? (not homework): https://gist.github.com/3332258
08:20:06 <zmoazeni> Since image fails to parse, the whole parser fails
08:21:03 <geekosaur> zmoazeni, try *does* do that ... but you need to provide something *else* to do if it fails
08:21:13 <zmoazeni> geekosaur: Ah
08:21:58 <zmoazeni> geekosaur: Do you know of any handy examples? My google-fu is not coming up with anything
08:22:29 <geekosaur> something along the lines of:  image <- Just <$> try whatever <|> return Nothing
08:23:02 <zmoazeni> Oh I see
08:23:05 <zmoazeni> Thanks
08:23:24 <zmoazeni> I used <|> earlier in the color definition. That makes sense
08:28:42 <zmoazeni> geekosaur: Sweet, works like a charm. Even if I had remembered <|>, I wouldn't have thought to use <$> to fmap "Just"
08:31:33 <geekosaur> that's just one possibility; you might have some default image to use instead, for example
08:34:38 <jmcarthur> hackage is up!
08:34:44 <Taneb> Hurrah!
08:35:55 --- mode: ChanServ set +o jmcarthur
08:35:57 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by jmcarthur
08:36:02 --- mode: jmcarthur set -o jmcarthur
08:42:37 <dfeuer> Is the stream-fusion package incompatible with the latest GHC?
08:42:54 <dfeuer> cabal complains "ghc: unrecognised flags: -fno-method-sharing"
08:46:58 <jmcarthur> dfeuer: i'm guessing not, but depending on your application, vector might be appropriate
08:47:16 <jmcarthur> *guessing not compatible
08:48:00 <jmcarthur> shouldn't be hard to tweak it if you really want to use the stream-fusion package, though, but it's very out of date and probably not as optimized as vector is, although they do slightly different things
08:49:06 <danil> wasn't that kind of stream fusion going to replace build/foldr in base at some point?
08:49:11 <dfeuer> Hmm. I'll have a look at Vector. I've heard good things about it. I suppose for this application it would probably be okay to think in terms of vectors rather than lists.
08:49:21 <dfeuer> danil: http://hackage.haskell.org/trac/ghc/ticket/915
08:49:38 <jmcarthur> danil: concatMap is hard :(
08:50:03 <jmcarthur> we need to put static argument tranformation in the right places in ghc's simplifier, i think is the problem
08:50:28 <jmcarthur> the transformation itself is already implemented. seems like it should be easy, but i've experimented with it and i couldn't get it right
08:50:39 <till_t> phil_: which version of the ghc sources did u use for buidlibs.sh?  i always get "hastec: panic! (the 'impossible' happened) \n (GHC version 7.4.1 for i386-apple-darwin): module `GHC.Types' is a package module"
08:51:06 <phil_> till_t: i didnt build them at all, just used the default ones
08:51:30 <phil_> i.e. after compiling the compiler just do haste-boot and you're done
08:51:44 <till_t> ok, i'll go with that
08:51:45 <till_t> thx
08:52:41 <KJChernov_> is that possible to do that in one line: eof <- hIsEOF h; if eof then ...? I can't remember where I read about that :'(
08:52:42 <dfeuer> jmcarthur: the specific thing I'm trying to do is k-way merge. Using the pqueue package led to very poor performance and tons of allocation. Using a hand-written STArray-based pqueue led to much better, but still poor, performance, and much less, but still tons, of allocation. Switching to a divide-and-conquer approach increased performance some more, but led to a /huge/ amount of allocation.
08:53:34 <phil_> till_t: then you can try compiling that http://hpaste.org/73055
08:53:49 <dfeuer> I'm guessing the divide-and-conquer approach might be possible to optimize using the same kind of transformations as concatMap? I'm really, really ignorant in this realm.
08:55:50 <dfeuer> The divide-and-conquer approach appears to be implementable in an imperative language using a heap-ordered tree whose nodes store values and whose leaves store streams. The merge itself /should/ be a "good producer" and a "good consumer".....
08:56:33 <dfeuer> Aaaand silence.
08:57:29 <till_t> phil_: it works :)
08:57:50 <danil> I don't know that much about fusion, but you're probably better off worrying about GC time rather than allocation rate.  A copying GC only has to traverse the live parts of the heap, so they're not necessarily proportional.
08:58:33 <phil_> till_t: now compile with hastec -O2 --opt-google-closure test.hs and see what happens to file size :D
08:58:51 <jmcarthur> dfeuer: sorry, i went away for a moment
08:59:07 <dfeuer> danil: GC time is low. Am I wrong to think that huge amounts of allocation are poor for cache performance?
08:59:11 <dfeuer> *bad for
08:59:32 <jmcarthur> i wouldn't worry about it at all. a minor collection where most of the data is thrown away isn't so costly in ghc
08:59:55 <jmcarthur> and the minor heap is pretty cache friendly. it's only when you hit the major really hard that it's an issue
09:00:20 <till_t> 28K->4K sounds good to me
09:00:24 <antibot> Is there any way to use cabal's Paths_* in package with extensions: NoImplicitPrelude? Or the only way is to append {-# LANGUAGE NoImplicitPrelude #-} to each and every module?
09:00:30 <dfeuer> Well, /something/ is making performance bad. The profiler says that my "merge 2 lists" function is taking the vast majority of the time, and also doing the vast majority of the allocations.
09:00:31 <danil> dfeuer: if everything is getting collected right away it's probably reusing the same blocks for the nursery every gc cycle, so it shoudln't be too bad on the cache
09:00:52 <jmcarthur> dfeuer: that said, fewer allocations is still usually better
09:01:19 <dfeuer> danil, jmcarthur, isn't that only valid if the nursery is much smaller than the L1 cache?
09:01:25 <jmcarthur> lists can be pretty bad for allocation rates if they aren't fused away, so i do think you are looking in a reasonable direction
09:01:57 <jmcarthur> dfeuer: it's difficult to reason about anything smaller than L2 when thinking about most GCs anyway
09:02:17 <dfeuer> If the vast majority of the things getting cached are thrown away quickly, I just can't imagine that's good.
09:02:31 <jmcarthur> if you want L1 friendliness, you almost have to be working with arrays that hang around for a while
09:02:46 <jmcarthur> unboxed arrays, to be precise
09:03:00 <jmcarthur> or you have to quite drastically reduce allocations
09:03:16 <jmcarthur> which the suggestion of using unboxed arrays often does
09:04:21 <hiptobecubic> it's not a good sign that the happstack website has a broken link to the tutorial
09:04:24 <hiptobecubic> :(
09:04:51 <dfeuer> To use an unboxed array to implement either k-way merge algorithm would appear to require that the inputs be in arrays/vectors, so they can be indexed by integers stored in unboxed arrays, since lists cannot (I don't think) be stored so.
09:05:22 <dfeuer> Or am I missing some obvious way to do that?
09:05:52 <DMcGill> is there a type that's the same as "undefined"
09:05:55 <DMcGill> ?
09:06:09 <ion> Is “a” close enough?
09:06:21 <DMcGill> its for in a data type
09:06:26 <DMcGill> data Foo = Foo a doesn't compile
09:06:40 <DMcGill> data Foo = Foo (exists a. a) needs an extension
09:06:54 <dfeuer> DMcGill: you can use an extension to write just  data Foo
09:07:03 <ion> data Foo = forall a. Foo a
09:07:11 <geekosaur> you need an extension to do that regardless, I think?
09:07:16 <twanvl_> or use Data.Void from the void package, which does it for you
09:07:24 <DMcGill> I'll just leave it as () for now I think
09:07:25 <jmcarthur> dfeuer: i can't think of a great way to do this in a stream fusable way apart from writing my own stream-oriented code
09:07:27 <DMcGill> not quite the same thing
09:07:54 <ion> data Foo where Foo :: a -> Foo
09:08:11 <jmcarthur> dfeuer: to be clear, my understanding is that each input array is a good producer, and you just want to structure the k-way merge to be a good consumer?
09:08:37 <DMcGill> that's a GADT right? It's just as a placeholder, I don't really want to start changing multiple lines. () is fine if not what I originially asked
09:08:45 <dfeuer> jmcarthur: I believe that is correct, yes.
09:09:06 <dfeuer> jmcarthur: but I'm not nearly enough of an expert to be entirely sure of that.
09:09:52 <jmcarthur> i'm not very familiar with k-way merge, unfortunately, but i imagine you have to do something like keeping a collection of the heads of each input, where each time you pull out the min you replace it with the next head of the corresponding input stream?
09:10:25 <jmcarthur> that collection could itself be kind of problematic for allocation rates
09:10:32 <dfeuer> jmcarthur: in fact, whether the inputs are good or not, it should be possible to fuse away a whole bunch of intermediates within the merge.
09:10:43 <jmcarthur> maybe the collection could be a mutable hash table?
09:10:44 <jmcarthur> err
09:10:48 <jmcarthur> s/hash table/heap/
09:10:54 <jmcarthur> not sure why i said hash table at all
09:11:58 <jmcarthur> i think to summarize, this sounds perfectly doable via stream fusion / array recycling, but it will be some work
09:12:11 <dfeuer> jmcarthur: there are two standard approaches. One of them uses a priority queue holding the lists, prioritized by the list heads. The other approach (divide-and-conquer) divides the input list recursively,
09:12:25 <dfeuer> breaking it down ultimately into merging a bunch of pairs of lists,
09:12:53 <jmcarthur> the latter sounds a bit easier to code, but the former sounds more promising in terms of optimization
09:13:11 <jmcarthur> replacing "list" with "stream"
09:13:29 <dfeuer> which is isomorphic to a heap-ordered tree whose nodes contain the first k (or 2k?) elements, and whose leaves contain lists.
09:13:45 <jmcarthur> but not *much* more promising...
09:14:09 <jmcarthur> again, it's that collection that hurts. they both have one. the second algorithm just builds it implicitly
09:15:06 <unrar> hi!
09:16:39 <dfeuer> jmcarthur: it's rather annoying, since it's really easy to express the concept I want in Haskell, and it's really easy to see how it could be implemented imperatively in an efficient manner, but it's really hard to bring those two together.
09:17:06 <jmcarthur> dfeuer: how large is k going to usually be?
09:17:36 <dfeuer> In this particular (toy) program, k<=100. But now that I've gotten interested in the problem, well, I wouldn't mind coming up with something good enough for real work...
09:17:45 <jmcarthur> i see
09:18:28 <dfeuer> k>registers available, but k<<cache size....
09:18:57 <dfeuer> In any case, it seems an interesting challenge.
09:20:09 <jmcarthur> are all the input streams built using the same functions?
09:21:11 <jmcarthur> in other words, in the stream representation, would all the stepper functions be the same, where each stream just has different states?
09:21:43 <dfeuer> Not exactly. Some of them would be one, and some the other.
09:21:46 <jmcarthur> ah
09:22:54 <jmcarthur> if they were all the same, i could imagine a terrible optimization where you just store the heads and states of each stream in a priority queue, which could with enough work be unboxed
09:22:56 <dfeuer> some are of the form  map (x*) l, for various x, and others are of the form map (x*) (reverse l)
09:23:04 <jmcarthur> i doubt there is a way to get stream fusion to do that for you, though
09:23:16 <dfeuer> Where (reverse l) can be written as a stream producing backwards....
09:23:41 <dfeuer> I gotta go.
09:23:42 <dfeuer> Bye!
09:23:43 <jmcarthur> wait
09:23:50 <jmcarthur> are they really just multiplications?
09:24:24 <jmcarthur> if they are, you might be able to just change structure of your whole algorithm a bit
09:26:11 <hiptobecubic> Is anyone using happstack with a shared hosting like dreamhost? I can't run my own webserver, but fastcgi is available of course. I found a blog post that said "this mostly works with some config tricks". Has anyone here actually succeeded?
09:26:54 <stepcut> the happstack-fastcgi library is horribly out of date.. though it is also pretty small, so probably easy to fix
09:32:06 <shurikas> hackage still down? :(
09:32:25 <Taneb> shurikas, I don't think so
09:32:30 <shurikas> strange
09:32:31 <hiptobecubic> stepcut, so.. no then
09:32:47 <geekosaur> not loading here...
09:32:53 <hiptobecubic> stepcut, i'm by no means an experienced web developer. I just want to have some fun making something
09:33:02 <hiptobecubic> geekosaur, shurikas keep waiting. it's up here
09:33:09 <Taneb> I'm looking at the source of Data.FamilyTree on Hackage
09:33:30 <shurikas> looks down from here
09:33:30 <shurikas> http://www.downforeveryoneorjustme.com/hackage.haskell.org
09:33:32 <stepkut> yeah, adding support for cgi/fastcgi is on the Happstack 8 release plan..
09:33:48 <jmcarthur> it works for me, shurikas
09:33:52 <shurikas> damn :(
09:34:01 <Taneb> No, I can definitely get it?
09:34:10 <Taneb> Give me a package to look at
09:34:21 <jmcarthur> i just loaded one i've never looked at before
09:34:27 <Taneb> Same
09:34:46 <jmcarthur> maybe it's a dns thing?
09:34:53 <Taneb> Or an ISP?
09:36:29 <Taneb> Now I'm looking at Network.GitHub
09:36:34 <Taneb> Definitely up from here
09:37:33 <shurikas> brobably
09:37:44 <shurikas> UP!
09:39:51 <mnewton> Hey guys - I'm just starting to learn haskell and I want to make a binary sort function. I'm trying to make a lambda function that takes [x,y] and if x is bigger returns [x,y] else [y,x] I'm getting errors. Any suggestions? http://pastebin.com/PwXxkUsC
09:39:53 <mauke> The paste PwXxkUsC has been copied to http://hpaste.org/73065
09:41:28 <Peaker> mnewton, \[x,y] -> ...   is a partial function which will crash with any input that isn't of length 2
09:42:05 <monochrom> I think it's the monomorphism restriction. try "let a [x,y] = if ..."
09:42:28 <Peaker> mnewton, also:  a = \[x,y] -> ...   is better expression as:   a [x,y] = ...
09:42:28 <Peaker> mnewton, also, did you mean for "a" to return a tuple?
09:42:39 <monochrom> also you confuse [x,y] with (x,y)
09:42:51 <monochrom> in fact also with (x,[y])
09:42:52 <Peaker> mnewton, also:  x:[]  and  y:[]   are just   [x] and [y]
09:45:53 * hackagebot distributed-process 0.3.0 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
09:45:55 * hackagebot dvda 0.3.0.1 - Efficient automatic differentiation and code generation (GregHorn)
09:45:57 * hackagebot distributed-process-simplelocalnet 0.2.0.4 - Simple zero-configuration backend for Cloud Haskell (EdskoDeVries)
09:45:59 * hackagebot netcore 1.0.0 - The NetCore compiler and runtime system for OpenFlow networks. (ArjunGuha)
09:46:01 * hackagebot dvda 0.3.1 - Efficient automatic differentiation and code generation (GregHorn)
09:48:04 <Bynbo7> @hackage distributed-process
09:48:04 <lambdabot> http://hackage.haskell.org/package/distributed-process
09:51:04 * hackagebot dvda 0.3.2 - Efficient automatic differentiation and code generation (GregHorn)
09:51:05 * hackagebot dvda 0.3.2.1 - Efficient automatic differentiation and code generation (GregHorn)
09:51:07 * hackagebot basic-prelude 0.1.0.0 - An enhanced core prelude, meant for building up more complete preludes on top of. (DanBurton)
09:51:09 * hackagebot ThreadObjects 0.0 - Mutable objects that reside in their own threads. (TimothyHobbs)
09:51:11 * hackagebot imm 0.4.1.0 - Retrieve RSS/Atom feeds and write one mail per new item in a maildir. (koral)
09:52:28 <otters> o_o
09:54:50 <jrajav> Wow no one's chatting in here for the last 15 minutes
09:54:52 <jrajav> This is a first
09:55:18 <nand`> Haskell must be dying
09:55:51 <jrajav> Clearly irrelevant
09:55:54 <jrajav> Data doesn't lie
09:56:13 * hackagebot highlighting-kate 0.5.2 - Syntax highlighting (JohnMacFarlane)
09:56:16 * hackagebot penny-lib 0.4.0.0 - Extensible double-entry accounting system - library (OmariNorman)
09:56:18 * hackagebot penny-bin 0.4.0.0 - Extensible double-entry accounting system - binary (OmariNorman)
09:56:20 * hackagebot fay 0.6.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
09:56:22 * hackagebot lens 2.0 - Lenses, Folds and Traversals (EdwardKmett)
09:56:31 <edwardk> lolwut
09:56:42 <edwardk> hackagebot is a little behind
09:57:10 <adnam> i think those are repeats O_o
09:58:04 <edwardk> yeah
09:58:08 <edwardk> guessing hackage came back up
10:01:24 * hackagebot network-metrics 0.2.3 - Send metrics to Ganglia, Graphite, and statsd. (BrendanHay)
10:01:26 * hackagebot xmonad-utils 0.1.3 - A small collection of X utilities (LeifWarner)
10:01:28 * hackagebot abacate 0.0.0.0 - Parser for a language similar to Cucumber's Gherkin (MarcoSilva)
10:01:30 * hackagebot chuchu 0.0.0.0 - Behaviour Driven Development for Haskell (MarcoSilva)
10:01:32 * hackagebot ginsu 0.8.0.2 - Ginsu Gale Client (DylanSimon)
10:01:44 <otters> 2-4-6-8-10
10:01:46 <otters> right on the minute
10:01:54 <otters> or rather, not
10:02:40 <hiptobecubic> but no one could upload to hackage either, i assume?
10:03:23 <ion> I still can’t connect to hackage.
10:12:49 <Veinor> can anybody explain what exactly the point of the phantom type in ST stuff is?
10:13:16 <parcs`> Veinor: to prevent references from leaking out
10:13:41 <Veinor> right, but how does it do that?
10:13:56 <parcs`> :t newSTRef
10:13:57 <lambdabot> forall a s. a -> ST s (STRef s a)
10:14:04 <parcs`> :t newSTRef ()
10:14:05 <lambdabot> forall s. ST s (STRef s ())
10:14:10 <parcs`> :t runST
10:14:11 <lambdabot> forall a. (forall s. ST s a) -> a
10:14:14 <geekosaur> Veinor, in any situation where they would leak out the result can't be given a type
10:14:22 <geekosaur> so the compiler reports a type error
10:15:26 <parcs`> if you let 'a'= ~ 'STRef s ()' then 'runST' has the type '(forall s. ST s (STRef s ())) -> STRef ? ()'
10:15:30 <Peaker> Veinor, Mutable state in ST and ST computations are all tagged with the "s" variable. It must match everywhere, and it must be polymorphic (so cannot be hard-coded to match arbitrarily) if runST is used
10:16:26 <Peaker> runST will make the "s" variable exposed mutable state from the executed ST computation be existential -- and thus unusable in any other ST computation
10:16:41 <parcs`> Veinor: that type signature is impossible because the s is quantified to the left of a (->)
10:16:54 <Veinor> ahh
10:17:00 <Peaker> will make the "s" variable *of* exposed mutable state ...
10:18:00 <Veinor> i get it now, thanks :)
10:24:10 <Veinor> @pl \a b -> liftM2 (<>) (f a) (f b)
10:24:11 <lambdabot> (. f) . liftM2 (<>) . f
10:25:00 <danil> :t \f -> liftM2 (<>) `on` f
10:25:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m Doc) -> a -> a -> m Doc
10:25:23 <danil> :t \f -> liftM2 mappend `on` f
10:25:25 <lambdabot> forall a1 (m :: * -> *) a. (Monoid a1, Monad m) => (a -> m a1) -> a -> a -> m a1
10:25:39 <shurikas> :t (<>)
10:25:41 <lambdabot> Doc -> Doc -> Doc
10:29:09 <till_t> why does no hs->js compiler implement Data.Char#toLower?
10:29:42 <till_t> has anybody a working version for haste?
10:29:51 <till_t> my example is:
10:29:55 <till_t> > main = alert $ return $ toLower 'A'
10:29:56 <lambdabot>   <no location info>: parse error on input `='
10:30:12 <sipa> till_t: what type is alert?
10:30:35 <till_t> alert :: String -> IO ()
10:30:54 <ion> you $ have $ too $ many $ dollars $ although $ that $ didn’t $ cause $ this $ error
10:31:05 <sipa> till_t: try alert $ toLower 'A'
10:31:12 <sipa> without the return
10:31:26 <sipa> oh, you want return to turn the Char into String?
10:31:29 <sipa> nevermind, then
10:32:27 <till_t> it's not the haskell code that's wrong, its the (missing) implementation by haste
10:33:20 <edwardk> yay! i figured out how to make travis-ci pull packages from luite, so i can go back to having continuous integration
10:33:56 <edwardk> luite++
10:34:39 <edwardk> ion: but some of us like $ ;)
10:35:31 <shurikas> ion, but I like dollars :(
10:35:56 <ion> shurikas: You shouldn’t waste all of them in your code then.
10:37:29 <hiptobecubic> ion, :D
10:45:09 <hpaste> edwardk pasted “for jmcarthur” at http://hpaste.org/73067
10:46:26 <Guest24276> Given class (Show n) => N n,  class (N n) => NN a n where f :: a -> n,   and given x satisfying NN a n, why does ghc complain of an ambiguous type variable when it sees (show (f x))?
10:49:42 <danil> Guest24276: if 'x' has a polymorphic type, GHC can't tell what to instantiate 'a' to (and thus which instance of 'NN' to use)
10:52:37 <Guest24276> danil: the fix suggested by ghc would seem to spoil the polymorphism.  Do you have a suggestion of your own?
10:53:41 <parcs`> @hoogle Ptr a -> Ptr b
10:53:41 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
10:53:41 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
10:53:41 <lambdabot> Foreign.Ptr alignPtr :: Ptr a -> Int -> Ptr a
10:53:51 <ion> Huh, plusPtr does a cast?
10:54:39 <ion> I guess that makes sense for C-like structs.
10:54:42 <danil> Guest24276: I don't know what ghc suggests, but to make that work you have to add a type signature to x (either at its definition or use) that disambiguates which instance to use
10:57:22 <geekosaur> ion, I was thinking arrays, and plusptr is an indexing operation
10:57:39 <cleantc> having : "f :: a -> Bool;   f x = let g y = (x,y) in True " is it possible to give an explicit type to function "g" in vanilla Haskell 2010?
10:58:39 <scra88le> @help
10:58:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:00:09 <Peaker> > let g :: Int -> (Int, Int) ; g y = (1, y) in True
11:00:10 <lambdabot>   True
11:00:16 <Peaker> cleantc, ^^
11:02:38 <geekosaur> > let { f :: a -> Bool; f x = let { g :: Num a => b -> (a,b); g y = (1,y) } in True } in True
11:02:39 <lambdabot>   True
11:04:52 <paolino> hello, is there another way to self kill a thread then recursive do ?
11:05:17 <Peaker> paolino, what does recursive do have to do with killing of threads?
11:05:28 <paolino> *than, I guess
11:06:10 <Peaker> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#v:myThreadId
11:06:21 <c_wraith> paolino: what do you even *mean*?
11:06:26 <paolino> killThread needs a ThreadId, wich comes out from thread definition
11:06:53 <c_wraith> myThreadId
11:07:16 <paolino> do rec {t <- forkIO $ killThread t}
11:07:17 <XexonixXexillion> myThreadID >>= killThread
11:07:20 <carmelo81> "!lista"
11:07:56 <cleantc> Peaker,geekosaur: I want g to be polymorphic on the first parameter, what about: "f :: a -> [a];  f x = let  g y = (x,y)  in [fst (g 2),fst (g 'c')]" is it possible to give an explicit type to g in vanilla Haskell 2010?
11:08:25 <c_wraith> also, since killThread is not magic..
11:08:51 <c_wraith> you can just do throwIO WhateverExceptionItIsDocumentedAsThrowing
11:09:11 <c_wraith> the docs explicitly say what exception it is, I just don't have them on hand right now
11:10:06 <paolino> c_wraith, right
11:10:18 <Peaker> cleantc, should be ok -- ghc accepts it without any extensions enabled
11:10:29 <c_wraith> but in general, when you need the ThreadId for the current thread - that's what myThreadId is for
11:10:38 <sipa> :t throwIO
11:10:40 <lambdabot> Not in scope: `throwIO'
11:10:51 <paolino> .. if I'm not in STM ...
11:10:54 <cleantc> Peaker: with what explicit type annotation?
11:11:07 <Peaker> cleantc, oh, only if "x" itself was monomorphic
11:11:12 <xvilka> hm. hackage still down?
11:11:16 <Peaker> cleantc, otherwise you'll need scoped type variables
11:11:21 <geekosaur> supposedly not...
11:11:38 <geekosaur> and yes, looks like you need scoped type vars to give an explicit type
11:12:12 <cleantc> yep, thanks
11:12:14 <iamtakingiteasy> what is preferable in do-block: `let name = <expr>` or `name <- return $ expr` ?
11:12:16 <c_wraith> You can always get away without scoped type vars.  It's just clumsier to avoid it
11:12:28 <c_wraith> iamtakingiteasy: the first, because it doesn't do unecessary work
11:12:32 <iamtakingiteasy> c_wraith: thanks
11:12:40 <c_wraith> iamtakingiteasy: or have unnecessary semantic overhead.
11:13:17 <iamtakingiteasy> just met the second case at http://www.haskell.org/haskellwiki/All_About_Monads#StateT_with_List
11:13:28 <Peaker> iamtakingiteasy, the "let" makes it clear there are no effects going on
11:14:40 <iamtakingiteasy> Peaker: yes, that what i thought and why i asked
11:14:44 <iamtakingiteasy> thank you!
11:19:00 <Taneb> Can anyone explain what a hylomorphism is?
11:19:55 <shachaf> Fold + unfold.
11:20:04 <applicative> an unfold followed by a fold
11:20:28 <shurikas> what for?
11:20:35 <Taneb> How is it used?
11:20:42 <shachaf> It's not.
11:20:46 <shurikas> :D
11:20:55 <edwardk> shurikas: consider unfolding to build a tree from a list in sorted order, then folding it back into a new list
11:21:13 <jmcarthur> shurikas: if you apply a fold to the result of an unfold, it's possible to transform all that into a function that doesn't create that intermediate structure at all
11:21:24 <edwardk> some times
11:21:31 <shurikas> interesting
11:21:32 <jmcarthur> being handwavy
11:21:44 <edwardk> mostly its that you get fusion laws when you go to bold another unfold or fold on the sides
11:21:53 <Taneb> How would edwardk's evil twin use it?
11:22:12 <edwardk> we wouldn't. if he's a twin of me he'd better have better taste than that ;)
11:22:26 <Taneb> edwardk, he's evil, though
11:22:31 <Taneb> And has bad taste
11:22:37 <edwardk> evil doesn't imply tacky
11:22:41 <jmcarthur> how would coedwardk use it?
11:22:57 <Taneb> edwardk, I'm pretty sure it does
11:23:00 <Taneb> Look at Sauron
11:23:08 <scra88le> @help
11:23:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:23:24 <scra88le> list
11:23:28 <scra88le> @list
11:23:29 <Taneb> @list
11:23:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:23:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:23:52 <Taneb> I guess my point is, if I had to use hylomorphisms, for a bet or something, how would I use them?
11:24:04 <Apocalisp> in a type like (m a, m b) -> m (a, b), what is distributing over what?
11:24:25 <Taneb> :t liftM2 (,)
11:24:27 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
11:24:33 <edwardk> Apocalisp: you are factoring more than distributing there
11:24:39 <Taneb> :t uncurry (liftM2 (,))
11:24:41 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
11:24:51 <jmcarthur> :t uncurry (liftA2 (,))
11:24:52 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
11:24:56 <Taneb> :t uncurry (liftM2 (,)) ([1,2,3], [1,5,2])
11:24:58 <lambdabot> forall a1 a2. (Num a1, Num a2) => [(a1, a2)]
11:25:00 <Taneb> > uncurry (liftM2 (,)) ([1,2,3], [1,5,2])
11:25:02 <lambdabot>   [(1,1),(1,5),(1,2),(2,1),(2,5),(2,2),(3,1),(3,5),(3,2)]
11:25:15 <Apocalisp> edwardk: Looking for the correct terminology for what is happening with m and (,) there
11:25:28 <edwardk> Apocalisp: yeah, i'd say you are factoring. ;)
11:25:53 <jmcarthur> in one presentation of Applicative that is a fundamental operation. don't know what it's called, though
11:25:57 <edwardk> https://github.com/ekmett/categories/blob/master/Control/Category/Distributive.hs#L27
11:26:25 <edwardk> its the fact that you have a monoidal functor and the monoidal functor preserves *
11:27:33 <applicative> Taneb every 'divide and conquer' algorithm can be viewed as a hylo
11:28:06 <edwardk> and you can make a hylo out of a dynamorphism if you need dynamic programming
11:28:14 <Taneb> Hmm
11:28:22 <c_wraith> isn't a hylomorphism an unfold followed by a fold, more or less?
11:28:29 <edwardk> yep
11:28:42 <edwardk> build up the divisions, and then tear it back down
11:28:52 <c_wraith> yeah..  lots of things are hylomorphisms
11:28:54 <edwardk> you can fuse the two steps together somewhat
11:29:24 <Apocalisp> edwardk: If we go the other way (e.g. unzip), we would say we're "distributing m over (,)"
11:29:31 <edwardk> cata f = f . fmap (cata f) . outF      ana g = InF . fmap (ana g) . g
11:29:35 <Apocalisp> or that "m distributes over (,)"
11:29:40 <edwardk> hylo f g = f . fmap (hylo f g) . g
11:29:51 <edwardk> yes
11:29:52 <otters> factorial is a hylomorphism?
11:30:01 <shachaf> Everything is a hylomorphism!
11:30:05 <c_wraith> factorial is certainly a hylomorphism
11:30:06 <edwardk> the opposite direction of distribution is factoring ;)
11:30:22 <edwardk> a * b + a * c = a * (b + c) is factoring out a
11:30:34 <otters> :t unzip
11:30:36 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
11:30:38 <otters> :t unzipWith
11:30:39 <lambdabot> Not in scope: `unzipWith'
11:30:40 <applicative> Taneb http://patternsinfp.wordpress.com/2011/04/11/morality-and-temptation/ is a defense of 'laziness' as making hylos possible -- if you can tolerate that kind of theory
11:30:42 <otters> oh
11:30:43 <edwardk> but putting the a back in is distributing
11:30:51 <aristid> @hoogle unzip
11:30:52 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
11:30:52 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
11:30:52 <lambdabot> Prelude unzip3 :: [(a, b, c)] -> ([a], [b], [c])
11:31:00 <Apocalisp> edwardk: Yeah, I see
11:31:05 <aristid> otters: what would unzipWith do?
11:31:29 <aristid> @let unzipWith f = unzip . map f
11:31:32 <lambdabot>  Defined.
11:31:35 <aristid> :t unzipWith
11:31:35 <otters> heh
11:31:36 <jmcarthur> unzipWith :: (a -> (b, c)) -> [a] -> ([b], [c])  -- ?
11:31:36 <lambdabot> forall a1 a b. (a1 -> (a, b)) -> [a1] -> ([a], [b])
11:31:38 <otters> :t zipWith
11:31:39 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:31:40 <aristid> otters: this?
11:32:01 <otters> what jmcarthur said
11:32:10 <aristid> that's the same type
11:32:18 <otters> or possibly [a] -> [(b,c)]
11:32:28 <jmcarthur> that's just map then
11:32:28 <otters> no, that's silly
11:32:37 <otters> maybe map IS unzipWith
11:32:46 <jmcarthur> map composed with unzip is
11:32:53 <edwardk> unzip is always trivial
11:32:57 <jmcarthur> just like zip composed with map is zipWith
11:33:06 <edwardk> zipping is hard
11:33:49 <jmcarthur> edwardk: not if your type is   data Foo a where Foo :: Foo a -> Foo b -> Foo (a, b)  ;)
11:33:54 <edwardk> you can trivially unzip any functor, its zipping them up that needs a notion of alignment
11:34:00 <torkjak> Does anyone else have problem accessing hackage.haskell.org?
11:34:12 <LadyAurora> torkjak: yes.
11:34:14 <edwardk> torkjak: yes its down for scheduled maintenance
11:34:21 <edwardk> there are two workarounds mentioned on reddit
11:34:26 <applicative> torkjak: there are various expedients
11:34:30 <edwardk> one is to add the ip to your hosts fie
11:34:33 <jmcarthur> ... isn't hackage up now?
11:34:36 <edwardk> the other is to pull packages from luite
11:34:38 <edwardk> is it?
11:34:45 <edwardk> yay
11:34:45 <jmcarthur> it's been up all day for me
11:34:46 <edwardk> its up
11:35:11 <jmcarthur> but torkjak isn't the first to complain about it since i first discovered it was up
11:35:15 <torkjak> edwardk: what is the new ip?
11:35:38 <edwardk> PING hackage.haskell.org (66.193.37.204): 56 data bytes
11:36:37 <otters> as opposed to those nasty non-data bytes
11:36:52 <edwardk> time to remove the hack from the lens github that makes it load from luite's mirror
11:41:52 <scra88le> quit
11:43:10 <statusfailed> aaaaaahh, hackage is down :D
11:43:15 <statusfailed> Where do I get reference documentation? :D
11:43:27 <Jurily> ask cabal :)
11:44:27 <JoshTriplett> I'm currently trying to build some c2hs bindings, and I seem to have run into a rather nasty problem.
11:44:36 <statusfailed> Jurily: Is it hosted elsewhere?
11:44:39 <JoshTriplett> I have quite a few functions which construct an object and return an error code.
11:44:52 <JoshTriplett> If the function returns an error code, it doesn't construct the object.
11:44:55 <statusfailed> ooh, haskell.org/ghc
11:45:24 <applicative> what determines whether hackage is up or down for someone? it's  up for me statusfailed
11:45:53 <edwardk> applicative: it is a dns change, so it matters when your isp lat cached the ip address
11:45:58 <edwardk> er last
11:46:03 <applicative> ah of course
11:46:12 <JoshTriplett> I've written those functions like this: {# fun config_new as ^ { alloca- `Config' wrapConfig* } -> `' checkerr*- #}
11:46:20 <edwardk> you can work around it by entering the ip directly into your hosts or by using luite's mirror for the moment
11:46:32 <statusfailed> It's ok, I was actually just looking for the definition of liftM2
11:46:33 <JoshTriplett> The function has a type like int config_new(config **);
11:46:33 <statusfailed> heheh
11:46:55 <JoshTriplett> wrapConfig assumes a valid pointer and tries to wrap it, and checkerr checks the return code and throws an exception.
11:46:56 <edwardk> @src liftM2
11:46:56 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:46:59 <applicative> oh, I could have told you that statusfailed
11:47:16 <JoshTriplett> However, as far as I can tell, c2hs calls wrapConfig on the out parameter *before* calling checkerr on the return value.
11:47:24 <statusfailed> god damnit......
11:47:26 <JoshTriplett> Which promptly crashes.
11:47:35 <JoshTriplett> (Rather, non-promptly crashes, which is worse.)
11:47:42 <JoshTriplett> Any idea how to fix that?
11:47:45 <statusfailed> Well, I know how to write it, I just wanted to get the official implementation
11:47:53 <statusfailed> but @src is cool :)
11:48:17 <applicative> I'm not sure how credible @src is
11:48:39 <statusfailed> it checks out :)
11:48:47 <shurikas> is there analog to @src in ghci?
11:48:54 <statusfailed> good question
11:48:57 <applicative> no, unfortunately
11:49:00 <shurikas> :(
11:49:55 <applicative> JoshTriplett: I'm trying to think where a c2hs expert might best be found. I'm not sure any frequents e.g. stackoverflow, but maybe
11:50:13 <JoshTriplett> applicative: Much obliged.
11:50:55 <applicative> JoshTriplett: certainly there are times when someone here would know
11:51:11 <applicative> it's a little iffier than finding someone who can define liftM2 :)
11:51:17 <JoshTriplett> applicative: Yeah. :(
11:52:22 <ParahSailin> @src liftM2
11:52:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:52:33 <rosie> is there a way I can access the hackage server? It's been down for at least a couple days.
11:52:48 <Clint> flush your dns cache
11:53:01 <monochrom> it is up
11:53:04 <Clint> hackage.haskell.org has address 66.193.37.204
11:54:01 --- mode: ChanServ set +o monochrom
11:54:12 <rosie> Clint: Thanks. When I put that IP in my browser, I see "It works!" How can I flush my dns cache ? I'm using Firefox
11:54:18 --- topic: set to '["hackage new IP, YMMV","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
11:54:34 <applicative> ha
11:54:35 --- mode: monochrom set -o monochrom
11:54:51 <parcs`> It Works!
11:55:19 <monochrom> dns cache is more likely upstream then near you. very little you can do
11:55:28 <Clint> rosie: if you don't control your name server, you can't
11:55:33 <monochrom> (apart from "switch to a better ISP")
11:55:59 <shachaf> Upstream, then near you. That's how propagation usually works.
11:56:08 <Clint> you don't need to use your isp's name server
11:56:14 <Clint> (s)
11:56:21 <monochrom> haha you pick my typo
11:56:27 <sm> I can resolve the name correctly, but fetching http with curl hangs. Seems like some stale proxy in the way
11:56:28 <monochrom> s/then/than/
11:57:12 <rosie> thanks all! So is there a way I can access the site?
11:57:20 <DMcGill> it works for me now
11:57:21 <aristid> monochrom: you can switch DNS without changing ISPs :)
11:57:46 <shachaf> rosie: Put "66.192.37.204 hackage.haskell.org" in /etc/hosts?
11:57:48 <monochrom> yes but more and more DNS's refuse to serve non-customers. hard to find a really open one
11:57:55 <shachaf> 4.2.2.2
11:57:56 <Ralith> 4.2.2.1
11:57:56 <shachaf> 8.8.8.8
11:58:00 <Ralith> 8.8.4.4
11:58:01 <DMcGill> I'm on google;s
11:58:02 <shachaf> The latter is explicitly open.
11:58:03 <aristid> shachaf was faster
11:58:06 <DMcGill> what Ralith said
11:58:13 <aristid> i can't remember the IPs other than 8.8.8.8
11:58:14 <Ralith> shachaf was incomplete~
11:58:14 <monochrom> oh, then nice
11:58:30 <shachaf> Ralith: shachaf named the primary servers rather than the secondary ones.
11:58:42 <aristid> monochrom: i think you could even run your own DNS server
11:58:50 <aristid> although that'd be some amount of work :D
11:58:53 <Ralith> secondary servers are there for a reason!
11:59:02 <monochrom> yes, but using what as upstream?
11:59:17 <aristid> monochrom: authoritative DNS?
11:59:25 <aristid> i.e. roots
11:59:33 <shachaf> Ralith: Yes, to be named after the primary servers.
11:59:34 <monochrom> do they just allow you to access them?
12:00:00 <aristid> monochrom: hmm, i've used dig +trace, i think it uses them
12:00:15 <aristid> not sure how open they are
12:00:16 <rosie> Alright, edited my /etc/hosts and typed http://66.192.37.204/ in the browser, and it hangs. Ideas?
12:00:26 <JoshTriplett> rosie: No, go to hackage.haskell.org as normal.
12:00:49 <JoshTriplett> rosie: (And also, remember to remove that entry after however many hours/days it takes to propagate, or you'll get very confused later.)
12:00:51 <aristid> monochrom: but i imagine if you run your DNS server "nicely" and cache your stuff, they will let you use it
12:01:01 <shachaf> rosie: If you edit your /etc/hosts, you shouldn't need to type the IP in your browser.
12:01:01 <rosie> JoshTriplett: still hangs
12:01:10 <shachaf> But it doesn't look like that IP is actually responding...
12:01:20 <shachaf> Clint: Are you sure about it?
12:01:29 * sm corrects himself, my curl is using stale dns even though the host command isn't
12:01:31 <aristid> monochrom: probably easier to just use 8.8.8.8 though
12:01:43 <aristid> sm: try getent host
12:01:45 <Clint> shachaf: i can poke around hackage, so.. yes?
12:02:00 <shachaf> Clint: Using 66.192.37.204?
12:02:02 <aristid> sm: i think getent host uses the same lookup as the normal system commands
12:02:08 <shachaf> I can't, even sending it explicit HTTP requests with the right Host:.
12:02:19 <Clint> % getent hosts hackage.haskell.org
12:02:19 <Clint> 66.193.37.204   hackage.haskell.org
12:02:45 <monochrom> I confirm that hackage is 66.193.37.204 from here, and works
12:02:46 <aristid> who hosts the new hackage btw?
12:02:49 <shachaf> That's the address it resolves to for me.
12:02:50 <shachaf> No response.
12:03:03 <sm> aristid: thx, not on osx. No worries, I'll wait
12:03:19 <aristid> sm: oh, use ping then :)
12:03:19 <shachaf> Oh, it works from my server.
12:03:24 <shachaf> Just not from this computer.
12:03:29 <shachaf> Strange.
12:03:36 <aristid> ping -c 1 should do :D
12:04:10 <aristid> i get 66.193.37.204 for hackage.haskell.org \o/
12:04:23 <shachaf> aristid: So do I, but it won't respond!
12:04:24 <aristid> and it's up
12:04:24 <rosie> aristid: where do I run that ping command?
12:04:30 <aristid> rosie: command line.
12:04:30 <shachaf> Oh, now it responds.
12:04:32 <shachaf> rosie: Try it now.
12:05:36 <bonk> hi #haskell! is there a platform-agnostic library for event handling like epoll or kqueue or what have you for Haskell? there's GHC.Event (not sure if that's what I'm looking for) but it says it's GHC internal anyway
12:05:52 <shachaf> bonk: GHC will generally do it automatically for you.
12:06:12 <rosie> here's the output of ping. Did I miss something?
12:06:14 <rosie> ping -c 1 66.192.37.204
12:06:14 <rosie> PING 66.192.37.204 (66.192.37.204): 56 data bytes
12:06:15 <rosie> --- 66.192.37.204 ping statistics ---
12:06:16 <rosie> 1 packets transmitted, 0 packets received, 100.0% packet loss
12:06:21 <shachaf> rosie: No, that's good.
12:06:39 <monochrom> no platform-agnostic event lib
12:06:43 <rosie> shachaf: what do I do now?
12:06:44 <shachaf> bonk: I.e., you can spawn a thread per socket or what have you, and it'll internally only spawn up to N OS threads and use epoll calls for the IO.
12:06:51 <shachaf> rosie: Go to hackage.haskell.org in your browser.
12:06:51 <Jurily> bonk: if you really can't live without it, there's Glib.MainLoop
12:06:58 <rosie> still hangs
12:07:06 <applicative> rosie if you just want hackage for installing via cabal there is the http://hdiff.luite.com expedient
12:07:15 <rosie> ah, good yes
12:07:19 <shachaf> rosie: Try it in a different browser?
12:07:50 <aristid> i think the hackage host blocks ping requests, but ping also does a host lookup and that's what matters
12:07:50 <monochrom> interesting, hackage ignores pings
12:08:23 <monochrom> "ping --- platform-agnostic dns lookup command?" :)
12:08:59 <applicative> rosie: inyour ~/cabal/config you comment out the line mentioning hackage and replace it with remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive then do cabal update
12:09:06 <applicative> rosie, for what its worth
12:09:11 * shachaf wonders why connect()ing to 0.x.y.z for x+y+z>0 is "invalid argument".
12:09:20 <shachaf> applicative: Yes, but this shouldn't be necessary now.
12:09:43 <applicative> is rosie getting past the nonsense?
12:10:00 <monochrom> if you have the right IP and still can't connect, we can next impeach routing table caches...
12:10:56 <aristid> monochrom: well, host is relatively portable too, but it sometimes seems to look things up differently than other programs
12:10:57 <Jurily> I'm trying not to draw parallels between the hackage server and a drug dealer, but it's hard
12:11:11 <rosie> I found the lute site. just looking for how to download a commit. The download link leads me to a page with no obvious way to download. Any advice?
12:11:24 <aristid> monochrom: but ping even works on windows, so yes it's highly portable :D
12:11:39 <hiptobecubic> I don't understand why the regex library decided to make =~ overloaded like crazy instead of using some descriptive function names
12:11:47 <shachaf> rosie: Did hackage.haskell.org not work even in a different browser?
12:11:54 <rosie> not in safari
12:12:31 <aristid> hiptobecubic: there are multiple regex libraries i think. maybe one has a better API. generally haskellers avoid using regexes though.
12:13:23 <geekosaur> hiptobecubic, reminder that you're really writing perl in haskell?
12:13:29 <geekosaur> as opposed to writing haskell code?
12:13:40 <hiptobecubic> geekosaur, :)  perhaps so
12:14:03 <shachaf> Perl is hardly as insane as (=~).
12:14:14 <hiptobecubic> Why does it have a whole chapter of RWH abusing this poor operator
12:15:10 <Jurily> it's not abuse if she likes it :)
12:15:10 <pharaun> how come haskellers avoid regexes?
12:15:32 <monochrom> (=~) was a generalization gone wild, yes
12:15:43 <monochrom> "hey let's out-smart perl"
12:15:53 <applicative> rosie, i cant see you you might clone from luite or download a tarball, but I gave the familiar instructions for temporarily altering your .cabal/config above
12:15:53 <Jurily> pharaun: we have full parsers much easier
12:16:13 <pharaun> Jurily: fair enough, just got finished working up on a header parser in parsec and i'm amazed at how easy it is :)
12:16:22 <monochrom> I don't avoid regex
12:16:39 <pharaun> this was much shorter/easier than some of my older regex parser
12:16:40 <osfameron> regex and parsers should ideally be complementary
12:16:56 <rosie> applicative: I don't get have a .cabal file. I'm trying to download cabal
12:17:14 <applicative> rosie: oh how did you get ghc?
12:17:39 <rosie> brew install ghc
12:17:44 <Jurily> osfameron: is there any advantage of regexes in haskell?
12:17:59 <rosie> should I use brew again for cabal-install?
12:18:06 <applicative> rosie, is brew install haskell-platform not working?
12:18:34 <osfameron> Jurily: don't know.  Certainly in Perl for simple ad hoc tasks, I'd use a regex, and for parsing a well defined structure, I'd use a parser.
12:18:48 <applicative> rosie, there is also just the platform installer dmg thing. that's what I use.
12:18:57 <osfameron> Jurily: but certainly Parsec is *very* nice to use.  Perhaps it's not too heavyweight to consider using for tasks that I'd usually use a regex for?
12:19:32 <hiptobecubic> i think regex is pretty useful, but his (=~) is just unnecessarily overloaded. You have a type annotation and you still have no idea what it is going
12:19:34 <rosie> cool, the hack age platforme downloading in brew. where's the dmg?
12:19:48 <rosie> *is downloading
12:20:32 <applicative> http://hackage.haskell.org/platform/mac.html but if brew works it might be a little simpler to uninstall
12:20:35 <Jurily> osfameron: for regex-like tasks, check out Data.Attoparsec.Zepto
12:21:27 <Jurily> or maybe just Attoparsec
12:21:29 <applicative> rosie the haskell platform includes the cabal executable and a number of libraries you'd rather have an expert install
12:21:59 <hiptobecubic> (=~) :: (String, String, String, [String]) vs :: [(Int, Int)]
12:23:48 <applicative> rosie: I see that brew installs the 64 bit ghc.  does ghci open reliably for you? some obscure variables about your system seem to lead to difficultywith the 64 bit one, most people arent affected
12:23:55 <monochrom> right, (=~) also suffers from complete lack of docs
12:24:00 <Jurily> that's some descriptive typing right there
12:24:40 <monochrom> (=~) is the author's expression of two things: "generalization is so awesome", "guess semantics from types is so awesome"
12:25:03 <monochrom> exactly the two initial excitements of learning haskell
12:25:24 <monochrom> s/guess/guessing/
12:25:57 <habyss> what do I put in my .cabal file to copy an extra (non-haskell) binary to the resulting bin directory?
12:25:57 * hackagebot process-extras 0.1.2 - Process extras (DavidLazar)
12:25:59 <applicative> the docs for (=~) are that post by bos
12:26:09 <monochrom> something about "other-files"
12:26:11 <shurikas> u
12:26:24 <applicative> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
12:26:51 <monochrom> hmm, I misread the question. not "other-files". I don't know the answer
12:27:20 <mkCurry> I'm attempting to grok arrows, the tutorials I've seen have lead me to think of them as co-routines. Is this an accurate take away?
12:27:29 <c_wraith> not really
12:27:31 <Tekmo> No
12:27:31 <lambdabot> Tekmo: You have 1 new message. '/msg lambdabot @messages' to read it.
12:27:41 <Tekmo> Simple example is functions
12:28:51 <Tekmo> I have a weird question.  Why does `lift` from `MonadTrans` not have a (Monad (t m)) constraint?
12:29:06 <Tekmo> i.e. lift :: (Monad m, Monad (t m)) => m r -> t m r
12:29:30 <mkCurry> If that's not what an arrow is, then what is it?
12:30:00 <monochrom> that is like asking "what is monad" all over again. I think you know better than to ask it at all
12:30:39 <applicative> mkCurry any body  of types X a b with a general composition and identity and a couple other bells and whistles
12:30:40 <Tekmo> When trying to understand something, first start from the actual code
12:30:53 <Tekmo> It's just an interface that supports the "arr" and "first" functions
12:30:57 <Tekmo> Along with several laws
12:31:17 <applicative> mkCurry: you might make more progress thinking about the Category type class in Control.Category, which Arrow presupposes
12:31:37 <mkCurry> applicative, Tekmo: Ok, but I tend to understane things in how one uses them. For me, a monad is a way to type your execution, as opposed to data.
12:31:52 <Jurily> a monad is data
12:31:55 <Tekmo> Not necessarily
12:31:56 <mkCurry> Which may not be "accurate", but is what I need to know to feel I understand them.
12:33:04 <applicative> the general monad concept doesn't have much to do with execution, though the IO _ form a monad
12:33:16 <monochrom> I commend actual code and actual use. I disagree that one specific actual use is representative.
12:33:17 <applicative> the IO _ types form a monad
12:33:38 <Jurily> it's kinda like light is particles or waves, depending on how you interact with it
12:33:48 <monochrom> many wildly different things fit "Arrow". a->[b] is one. there are others totally unlike a->[b]
12:34:05 <mkCurry> Jurily: Yes, and I understand light in each use case, but the duality doesn't register with me :)
12:34:13 <monochrom> but you should play with a->[b] for a while. also a->IO b
12:34:44 <parcs`> Tekmo: probably because it requires FlexibleContexts
12:34:49 <danil> Tekmo: the monad transformer laws imply that you have Monad (t m) whenever Monad m, so I think they just reduced the context assuming the laws hold
12:35:26 <Tekmo> Well, the reason I'm asking is because I encountered a case where it would be useful to have that constraint
12:35:39 <Tekmo> Although, it's not a really huge issue
12:35:41 <Tekmo> Just a curiosity
12:36:27 <Tekmo> mkCurry, the trick to understanding a type class
12:36:34 <Tekmo> is to understand why it has its laws
12:36:45 <Tekmo> If you understand the laws you understand the type class
12:37:03 <Tekmo> Now, I don't know exactly the basis for the Arrow laws
12:37:13 <Tekmo> So I can't be too helpful in that regard
12:37:18 <Tekmo> But I can at least explain the Monad laws
12:37:39 <aristid> hi Tekmo, master of the free monads :)
12:37:44 <Tekmo> Hi!
12:38:42 <mkCurry> Tekmo: Thanks. It might help if I narrow my framing. I'm particularly interested in circuits and I noticed arrows have tutorials that explain them as circuits.
12:39:05 <Tekmo> Well, the most common usage of arrows is actually functions
12:39:06 <aristid> :t lift
12:39:08 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
12:39:11 <mkCurry> Tekmo: In this context an Arrow seems to be used to implement a coroutine...
12:39:18 <Tekmo> Well, for functions
12:39:23 <Tekmo> it's commonly used to split an input
12:39:31 <Tekmo> and process the two outputs separately
12:39:42 <Tekmo> for example, let's say I have some tuple (a, b)
12:39:46 <Tekmo> and some function (b -> c)
12:39:48 <mkCurry> *nods*
12:39:53 <Tekmo> That I only want to apply to the second argument
12:40:01 <Tekmo> I would just write "second function"
12:40:11 <Botje> or fmap *ducks*
12:40:20 <Tekmo> Well, that works for one side
12:40:26 <Tekmo> Unless you newtype the other half
12:40:37 <hpaste> applicative pasted “category arrow” at http://hpaste.org/73068
12:40:43 <applicative> mkCurry: here's a Category instance for monochrom's type, see if you can extend it to arrow convincing yourself of the laws. ^^^
12:41:04 <Tekmo> Is there a particular arrow you had in mind?
12:42:09 <mkCurry> applicative, Tekmo: Even if you didn't have a particular arrow in mind, it might help in preventing analysis paralysis to narrow it :)
12:42:49 <Tekmo> So what about circuits did you want to try out?
12:43:21 <applicative> mkCurry: one of  the xml libraries turns on an arrow instance for a type of the form X ([a] -> [b]) if I remember.  Nothing too circuity about that
12:43:41 <monochrom> no, xml uses a->[b] or a -> IO [b]
12:43:54 <monochrom> even a -> StateT Whee IO [b]
12:44:09 <applicative> ah, thats what I at first thought, but then changed my mind
12:44:20 <monochrom> HXT for example
12:44:43 <mkCurry> Tekmo: Well, I see how to do circuits within a Monad a la Bluespec.
12:44:44 <monochrom> http://www.vex.net/~trebla/haskell/hxt-arrow/index.xhtml
12:45:07 <mkCurry> Tekmo: I wanted to see if there was a way to simplify the syntax using Arrows.
12:45:17 <applicative> ah hxt
12:45:44 <Tekmo> So you mean a sort of circuit design in Haskell using Arrow syntactic sugar?
12:45:56 <mkCurry> Tekmo: Exactly.
12:45:59 <Tekmo> I think that should be possible
12:46:30 <Tekmo> At least, for a subset of diagrams
12:47:04 <mkCurry> Tekmo: Well, the way it works in most Haskell DSLs is that the context in which stuff is designed represents a clock cycle. This is an issue as you don't often know at the start of a design where clock boundries should be.
12:47:10 <pharaun> question. Any good way to parse "foo bar - barz darf\n" ? i am able to do (many1 (noneOf "-\n")) to get the "foo bar " part, then (char '-' >> char ' ' >> many1 (noneOf "\n")) to parse the second part
12:47:38 <mkCurry> Tekmo: Ideally one would design the circuit and be able to move the clock boundries without effecting the structure, and it's not clear how to do that in a Monad.
12:47:43 <pharaun> this is ok so far but how do i parse the first part as "foo bar" without that trailing space ? it sometime may have " - barz\n" othertime its "\n"
12:47:53 <Tekmo> Wait, what do you mean by the clock boundaries?
12:47:58 <pharaun> i would like to avoid having to trim the first part
12:48:04 <Tekmo> Do you want to just design the circuit layout or simulate it, too?
12:48:11 <mkCurry> Tekmo: Circuits are fully synchronous, and you define when each "cycle" ends.
12:48:54 <mkCurry> Tekmo: In the monadic approaches I've seen, you feel a context with content, and that equals one clock cycle. Ideally, you would define the circuit in general, and fill in the boundries later.
12:49:13 <mkCurry> Both.
12:49:31 <mkCurry> Tekmo: Output Verilog, and also simulate it.
12:51:07 <Targen> Given «type Foo = (T1, T2, ..., Tn)», I’d like to define «bar :: (TCa T1, TCa T2, ..., TCa Tn)» and «baz :: (TCb T1, TCb T2, ..., TCb Tn)» without specifying the types again.  What might be a good way to do this?
12:51:48 <mkCurry> Tekmo: http://www.haskell.org/arrows/examples/Circuits.las
12:52:03 <Tekmo> Let me check it out
12:52:26 <Targen> (T1, ..., Tn are specific monomorphic types, but my intention is to spell them out precisely once in a module that gets imported by the modules where bar and baz are defined)
12:56:29 <Tekmo> So the part where I get stuck is the notion of directionality for Arrows
12:57:01 <mkCurry> Tekmo: I'm stuck earlier than that :) There is a notion of time in circuits.
12:57:11 <Tekmo> Well, let me step back, then
12:57:19 <Tekmo> So with an arrow you have two distinct ends
12:57:22 <danil> Targen: you can do it with type families (define a bunch of "type instance Get1 (a, b, c, ...) = a", and then "bar :: (TCa (Get1 Foo), ...)"), but it's not pretty
12:57:26 <Tekmo> Those ends might have lots of subdivisions
12:57:36 <Tekmo> Like multiple inputs and multiple "outputs"
12:57:40 <mkCurry> Tekmo: Yes.
12:57:43 <Tekmo> But there are still two distinguishable ends
12:57:50 <Tekmo> But in a circuit that's not as clear cut
12:58:07 <monochrom> each small component in a circuit has them clear-cut
12:58:08 <Tekmo> Some circuits can certain be defined as a black box with an input and output
12:58:22 <Targen> danil: Oh, that shoud do it almost nicely indeed.  Thanks!
12:58:27 <monochrom> add ArrowLoop to build feedback circuits
12:58:43 <Tekmo> Ok, let me use a contrived example
12:58:49 <Tekmo> A node with three branches coming out of it
12:58:51 <Tekmo> each branch has a resistor
12:58:57 <mkCurry> monochrom: feedback as in digital, with registers?
12:59:10 <monochrom> no, as in circuits
12:59:53 <monochrom> all circuits allow feedbacks. analog circuits feed op amp output to op amp input all the time
13:00:08 <mkCurry> Tekmo, monochrom: The examples in that tutorial are all digital. But I'm still interested in how it applies to analog, even if I likely won't use it that way.
13:00:13 <monochrom> in fact that's the only way you get anything done in practice
13:01:02 <Tekmo> But anyway, go back to the 3-branched node
13:01:20 <Tekmo> Which of those would be assigned to the input and which to the output?
13:01:57 <mkCurry> Tekmo: You mean how do you choose that?
13:02:18 <Tekmo> I guess what I'm trying to say is that, at least for analog, that a category might not be the correct abstraction
13:02:34 <mkCurry> Tekmo: What about digital?
13:02:44 <mkCurry> Tekmo: Within a clock cycle it's a dag...
13:03:14 <Tekmo> Then it should be possible
13:03:35 <mkCurry> monochrom: And loops can only occur at clock cycle boundries, with one or more clock cycle between the feedback.
13:03:45 <mkCurry> monchrome: In digital...
13:05:08 <mkCurry> Tekmo: Their counter example, it wasn't clear to me how it's used.
13:08:09 <Tekmo> Ok, so from what I'm reading about Arrow instances
13:08:20 <Tekmo> First you want something that is an instance of ArrowLoop
13:08:27 <Tekmo> and you probably want the (->) instance
13:08:47 <zzing_> Hey Tekmo
13:08:50 <Tekmo> Hey
13:08:55 <mkCurry> Tekmo: Yes about ArrowLoop - http://www.haskell.org/arrows/arrows/Control.Arrow.Operations.html#t%3AArrowCircuit
13:09:02 <Tekmo> And then you want to define which instance of ArrowCircuit you want
13:09:10 <Tekmo> I think the one you want is the ArrowState one
13:09:11 <zzing_> Got a link to that errors library that doesn't require email to get a link?
13:09:19 <Tekmo> Oh yeah
13:09:26 <Tekmo> Actually, Hackage is up now
13:09:30 <Tekmo> You should be able to download it now
13:09:50 <zzing_> hackage isn't coming up
13:09:54 <Tekmo> Oh really?
13:10:00 <Tekmo> Then I'll link you to the back up one
13:10:02 <Tekmo> HOld on a second
13:10:09 <mkCurry> Hackage was up for me.
13:10:17 <rosie> was down for me...
13:10:19 <jmcarthur> it seems to be working for some people and not for others
13:10:39 * tgeeky votes up
13:10:54 <Tekmo> http://hdiff.luite.com/packages/archive/errors/errors-1.2.1.tar.gz
13:10:59 * hackagebot xmonad-utils 0.1.3.1 - A small collection of X utilities (LeifWarner)
13:11:35 <plat0> Can someone suggest a natural construct that is an arrow, but for which there is no monad instance that gives rise to that arrow?
13:11:51 <zzing_> hmm, says it needs either >=3.0.1, safe -any
13:12:40 <mkCurry> Try running cabal update
13:12:49 <Tekmo> let me find the links for those, then.  Hold o
13:13:01 <mkCurry> I did that this morning and everything's working fine.
13:13:05 <aristid> plat0: one example i saw was a DSL for assembly instructions that allowed composing operations and tell which registers are affected. it had no Monad instance because then arbitrary registers might be affected
13:13:16 <Tekmo> http://hdiff.luite.com/packages/archive/safe/safe-0.3.3.tar.gz
13:13:39 <mkCurry> aristid: Can you give an example?
13:13:44 <mkCurry> aristid: I mean, link
13:13:49 <Tekmo> http://hdiff.luite.com/packages/archive/either/either-3.0.2.tar.gz
13:14:03 <Tekmo> Although the either one may have a LOT of dependencies
13:14:10 <Tekmo> that you might need to further download
13:14:18 <Tekmo> Hold on
13:14:23 <plat0> aristid: yes I would be interested in seeing more about that
13:14:26 <Tekmo> I saw on reddit somebody mentioning a better way to do this
13:14:47 <Tekmo> http://www.reddit.com/r/haskell/comments/y1tgc/any_hackage_mirrors_how_do_you_deal_with_hackage/c5rk46g
13:14:50 <Tekmo> Follow those instructions
13:14:59 <Tekmo> So that cabal can automatically pull in the dependencies necessary
13:15:16 <Tekmo> Alright, back to circuits
13:15:21 <aristid> mkCurry: i don't currently have access to the code, sorry
13:15:22 <Tekmo> So I was checking out ArrowCircuit more
13:15:37 <Tekmo> It seems that only two of the instances are not transformers
13:15:50 <Tekmo> ArrowLoop a => ArrowCircuit (StreamArrow a)
13:15:58 <Tekmo> ArrowLoop a => ArrowCircuit (Automaton a)
13:16:05 <zzing_> Tekmo, one more question if I may - does your library fit in with free monads? I am somewhat interested in looking at that direction. I am also not sure why fail is bad.
13:16:13 <Tekmo> Which one?
13:16:18 <Tekmo> The errors library?
13:16:33 <Tekmo> Or the transformers-free library?
13:16:54 <zzing_> The errors
13:17:04 <aristid> mkCurry, plat0: but basically the type was this: data Operation = Operation { inputRegisters :: [RegisterName], outputRegisters :: [RegisterName], runOperation :: MachineState -> MachineState }
13:17:24 <Tekmo> I'll start by answering the question about "fail", first
13:17:46 <aristid> and for example in the ArrowChoice instance, it estimates conservatively that all registers might be affected
13:18:07 <Tekmo> So, probably the best replacement for fail is the MonadPlus class
13:18:13 <Tekmo> Where you would use "mzero" for a generic fail
13:18:27 <aristid> Tekmo: i think there used to be a MonadZero class
13:18:32 <Tekmo> Yeah, I know
13:18:39 <Tekmo> But I just checked and it was merged into MonadPlus
13:18:43 <Tekmo> And it probably should be that way anyway
13:18:52 <aristid> but they also added fail
13:19:11 <aristid> well i think IO might be an instance of MonadZero but not MonadPlus, for example
13:19:28 <jmcarthur> i think fail and zero should be different things, since zero doesn't allow you to include information about the failure. i just don't think fail belongs in the Monad class
13:19:52 <Tekmo> Well, here's the problem with including information
13:19:56 <Tekmo> It only really works for the IO monad
13:20:05 <Tekmo> For Maybe/[], the information gets discarded
13:20:12 <Tekmo> And for Either, you have to add an Error e constraint
13:20:20 <jmcarthur> it works for Either anythingThatCanBeMadeFromAString
13:20:27 <plat0> aristid: What is the arrow instance arising from "Operation"?
13:20:45 <jmcarthur> Tekmo: if MonadFail was a thing, that constraint would only need to be on that instance, not the whole Monad instance
13:20:49 <Tekmo> Yeah, but I often program with things that are not stringifiable
13:20:53 <Tekmo> as my Left values
13:20:56 <jmcarthur> exactly
13:21:07 <Tekmo> Right, MonadFail would be ok
13:21:10 <jmcarthur> in which case fail makes little sense
13:21:15 <Tekmo> But really, I think fail should just be specialized to the IO monad
13:21:23 <Tekmo> And for pattern matching, use MonadPlus as the constraint
13:21:25 <aristid> plat0: it's basically just the Arrow instance for (->), but it also sums the input and output registers
13:21:33 <Tekmo> fail :: String -> IO a
13:21:42 <Tekmo> That's the only monad that fail really "works" for
13:21:51 <Tekmo> So no sense in overloading it
13:22:19 <aristid> plat0: oh, i know another good example for an Arrow that is not an underlying Monad. mm_freak's netwire :)
13:22:26 <Tekmo> There's another reason you usually want to keep mzero with mplus
13:22:41 <aristid> although these days mm_freak emphasises the Category / Applicative API more than the Arrow stuff
13:22:44 <Tekmo> Which is that their behavior is then constrained by the lax monoid laws
13:22:54 <plat0> aristid: OK, I'm checking that out now ...
13:23:03 <aristid> @hackage netwire
13:23:04 <jmcarthur> presumably MonadPlus would still require MonadZero, in which case the laws still make sense
13:23:04 <lambdabot> http://hackage.haskell.org/package/netwire
13:23:21 <Tekmo> With an isolated MonadZero class, there really isn't anything constraining how mzero should behave
13:23:29 <jmcarthur> mzero >> a = mzero
13:23:33 <Tekmo> I don't buy that law
13:23:36 <jmcarthur> a >> mzero = mzero ?
13:23:47 <Tekmo> As far as I'm concerned, the only really legitimate laws for mzero are the monoid laws
13:23:51 <aristid> hmm i thought hackage was up again
13:23:57 <aristid> it's at least very slow right now for me
13:23:57 <Tekmo> mzero `mplus` a = a
13:24:05 <Tekmo> a `mplus` mzero = a
13:24:20 <Tekmo> (a `mplus` b) `mplus` c = a `mplus` (b `mplus` c)
13:24:24 <jmcarthur> then there is no point in mzero or plus to exist. might as well just use applicative or even FunctorZero and FunctorPlus
13:24:32 <jmcarthur> s/applicative/alternative/
13:24:46 <Tekmo> Yeah, I agree
13:24:50 <Tekmo> except those aren't super-classes of monad
13:24:56 <Tekmo> which is why they have separate classes
13:24:58 <jmcarthur> we're idealizing already ;)
13:25:00 <Tekmo> :)
13:25:40 <jmcarthur> i think MonadPlus makes sense if you assume additional laws over FunctorPlus, but otherwise there's no point
13:25:45 <jmcarthur> i also think they are pretty useful laws
13:25:46 <zzing_> Tekmo, so right now I am wrapping certain functionality in OpenGLRaw. Are you suggesting that it should be EitherT [GLEnum] IO on the interface?
13:25:50 <jmcarthur> the additional ones, that is
13:26:01 <plat0> aristid: Do you know what datatype of netwire has the arrow instance?  I can't find it.
13:26:02 <jmcarthur> of course, there's controversy about *which* of the additional laws should actually hold
13:26:11 <aristid> jmcarthur: how about Monoid1, which has not other constraints, but a * -> * kind?
13:26:26 <Tekmo> Let me first answer zzing_
13:26:31 <aristid> plat0: Wire. it's a data family / associated type (in netwire 4)
13:26:52 <jmcarthur> aristid: no complaints, although i do find that normally when i want something like that i also want functor as well. i have no understanding of why that tends to be, though
13:26:53 <Tekmo> So, zzing_, the error value you store in the left only depends on how you plan on handling it
13:27:01 <plat0> aristid: Oh I only found 3
13:27:10 <Tekmo> If you plan on only printing it, then you can just convert it to a string and store it that way
13:27:18 <aristid> plat0: mm_freak might not have released 4 yet
13:27:32 <jmcarthur> aristid: seems like kind polymorphism should make this world nicer...
13:27:33 <Tekmo> But if you want something more sophisticated where you work the original values, then keep the [GLEnum] in the left value and use that when you write your handler
13:27:47 <zzing_> Tekmo, mostly what comes out of this is going to be is output. Because most of the time this is the equivalent to a runtime error in a dynamic language - something that should not normally happen
13:27:47 <aristid> jmcarthur: i think ghc even has kind polymorphism now? :)
13:27:59 <jmcarthur> yes it does
13:28:02 <Nereid> it does, but it's still experimental in 7.4
13:28:03 <Tekmo> So, the nice thing about the errors library
13:28:03 <aristid> jmcarthur: but if it's like DataKinds, it might be better not to use it until 7.6
13:28:08 <jmcarthur> exactly
13:28:16 <Tekmo> is that it lets you change the type of the left value on the fly
13:28:21 <Tekmo> something that other error handlign libraries don't do
13:28:23 <aristid> i hope some people do use it, so the bugs are found :D
13:28:27 <Nereid> I found some issues in 7.4 that are fixed in recent snapshots
13:28:31 <Tekmo> So you can have part of your code retain the [GLEnum] as a precaution
13:28:39 <Tekmo> Then convert it to a String further downstream
13:28:45 <Nereid> so hopefully they're pretty usable in 7.6
13:28:50 <aristid> Nereid: ghc 7.6 will be glorious
13:28:52 <Tekmo> My advice, though, is that if you don't plan on using the GLEnum yet
13:28:56 <Tekmo> Just store it as a String
13:28:58 <aristid> i mean, the name says it even. :D
13:28:59 <Nereid> :)
13:29:05 <Tekmo> because it will be reallye asy to go back and change it later
13:29:05 <ion> Linux 7.6 will be great.
13:29:12 <mekeor> ?! oO
13:29:12 <lambdabot> Maybe you meant: . ? @ v
13:29:17 <zzing_> Tekmo, the string is probably best right now.
13:29:17 <aristid> ion: indeed.
13:29:20 <mekeor> oh, sorry, lambdabot
13:29:25 <Nereid> linux is already at 3.5, when did this happen.
13:29:27 <zzing_> I could even make a custom data type for it too
13:29:37 <ion> aristid: That will mark the year of Linux on the desktop.
13:29:39 <mkCurry> Tekmo: http://www.cs.berkeley.edu/~megacz/research/papers/megacz-ifl2011.pdf
13:29:46 <zzing_> Nereid, fast and loose with version numbers
13:29:54 <aristid> Nereid: linus randomly decided that the version number was too high and switched to 3.0 without major architectural changes :)
13:29:55 <Nereid> :P
13:30:00 <zzing_> ion, the century of linux on the desktop
13:30:08 <Nereid> yeah I didn't really get the point, but oh well.
13:30:10 <Tekmo> mkCurry: Yeah, I remember that paper
13:30:22 <Tekmo> Note that it represents a different kind of arrow
13:30:24 <parcs`> zzing_: are you on linux? you can easily debug opengl applications by setting the MESA_DEBUG=1 envvar
13:30:31 <zzing_> parcs`, mac
13:30:38 <parcs`> oH
13:30:41 <zzing_> Tekmo, now - the free monad thing. Should I pursue this? It looks interesting, but not sure if it is really worth it.
13:31:01 <Tekmo> No
13:31:05 <Tekmo> I don't know why they recommended that
13:31:15 <Tekmo> I love free monads a lot
13:31:24 <Tekmo> But I don't see how they help you with error handling
13:31:43 <Tekmo> Either(T) or Maybe(T) is always what you want for error handling
13:31:48 <zzing_> Tekmo, one thing I need to do is flatten my code a little, otherwise it is goes deeper and deeper potentially.
13:31:55 <Tekmo> Yeah, EitherT does that
13:32:01 <Tekmo> You can always flatten code using Either(T)
13:32:06 <mkCurry> Tekmo: I'm unable to find a package for ArrowCircuit anyway.
13:32:14 <mkCurry> s/anyway/anywhere
13:32:16 <Tekmo> Oh, I found ArrowCircuit
13:32:19 <mkCurry> Where?
13:32:26 <Tekmo> http://hackage.haskell.org/packages/archive/arrows/0.4/doc/html/Control-Arrow-Operations.html#t%3AArrowCircuit
13:32:36 <Tekmo> The arrows package
13:33:08 <Tekmo> zzing_: hpaste an example of where you are not sure how to flatten it
13:33:13 <Tekmo> I can help show you how to do it
13:33:18 <aristid> Tekmo: how would you type operations that can return multiple different types of errors?
13:33:31 <Tekmo> a sum type
13:33:49 <aristid> Either (Either FooError BarError) SuccessType?
13:34:00 <jmcarthur> basically....
13:34:01 <zzing_> This is an example: http://hpaste.org/72953    mm_freak was kind of enough to assist on the annotation. This is the point that I asked my question.
13:34:01 <Tekmo> Two things
13:34:02 <mkCurry> Tekmo: Ahhh, thanks.
13:34:27 <Tekmo> Well, normally I would just define a custom type like
13:34:32 <zzing_> Tekmo, this is the ful lmodule it goes into: http://hpaste.org/73070
13:34:37 <Tekmo> data Error = FooError | BarError | ...
13:35:01 <zzing_> makeShader I want to be fairly flat, and I can abstract the error handling (which is from checkError)
13:35:05 <aristid> it kind of bothers me that once you use IO you always get all of the SomeException hierarchy implicitly
13:35:22 <zzing_> checkError is difficult because it has to be called until it returns gl_NO_ERROR (inside IO)
13:35:29 <Tekmo> So what you do is define the tryGL function I mentioned in my reddit comment
13:35:39 <Tekmo> And then you just use it to wrap all your gl functions
13:35:53 <Tekmo> i.e. tryGL $ glCreateShader gl_VERTEX_SHADER)
13:35:56 <jmcarthur> wait... the gl bindings don't raise any exceptions do they? i thought you were using openglraw
13:36:04 <zzing_> jmcarthur, I am using raw
13:36:10 <zzing_> Tekmo, is it possible to build that into my wrappers?
13:36:19 <Tekmo> I'm going to hpaste an example
13:36:36 <parcs`> yay ghc 7.6 rc
13:36:51 <zzing_> Can we have 7.6 parties all around the world?
13:37:23 <hpaste> “Gabriel Gonzalez” pasted “GLError” at http://hpaste.org/73071
13:38:20 <Tekmo> Oh whoops
13:38:23 <Tekmo> Change out tryIO for liftIO
13:38:29 <Tekmo> Other than that, it should work for you
13:38:39 <Tekmo> tryIO is like liftIO, except it also catches errors:
13:38:50 <Tekmo> tryIO :: IO r -> EitherT SomeException IO r
13:39:18 <zzing_> Tekmo, ok, so what happens if there is an error on line 6, what occurs?
13:39:20 <osa1> I'm trying to use "evalStateT" to get return value of some stateful computation, but this code gives an error in line 124: https://gist.github.com/3334166 ("No instance for (Show (TC Ty))") it looks like it doesn't return the value of computation, but returns the monad type. can anyone help me?
13:39:37 <Tekmo> Oops, I made two typos
13:39:39 <Tekmo> Let me fix it
13:39:47 <zzing_> I saw them
13:39:49 <aristid> Tekmo: tryIO is more like the runEitherT for IO, i think
13:39:57 <hpaste> “Gabriel Gonzalez” annotated “GLError” with “GLError (annotation)” at http://hpaste.org/73071#a73072
13:40:05 <Tekmo> There, I fixed it
13:40:10 <sm> tip for OSX *lion users trying to use hackage: sudo killall -HUP mDNSResponder reset dns (must be a -HUP)
13:40:59 * hackagebot process-extras 0.1.3 - Process extras (DavidLazar)
13:41:02 <Tekmo> Found it: tryIO :: IO a -> EitherT String IO a
13:41:15 <Tekmo> It's a convenience function for when your error is a String
13:41:21 <aristid> sm: i can only get on the frontpage :(
13:41:37 <aristid> @hoogle tryIO
13:41:37 <lambdabot> No results found
13:41:53 <Tekmo> http://hackage.haskell.org/packages/archive/errors/1.2.1/doc/html/Control-Error-Script.html#v:tryIO
13:42:09 <zzing_> Tekmo, ok, I will give this stuff a shot and be back to see how it goes
13:42:14 <Tekmo> Alright
13:42:16 <zzing_> Tekmo, merci.
13:42:22 <Tekmo> No problem!
13:42:24 <zzing_> Tekmo, so where do you use free monads and where not?
13:42:35 <Tekmo> Free monads are like abstract syntax trees
13:42:43 <Tekmo> You use them when you may want to target multiple backends
13:42:50 <Reaga> rawr
13:42:57 <Reaga> I am bored
13:42:58 <danil> osa1: yes, evalStateT just unwraps the StateT, leaving a value in the inner monad
13:42:59 <aristid> like MonadPrompt?
13:43:02 <Tekmo> Exactly
13:43:05 <Tekmo> MonadPrompt is a free monad
13:43:11 <Tekmo> In disguise
13:43:20 <aristid> Tekmo: and Cont?
13:43:24 <Tekmo> Same thing with operational
13:43:24 <Tekmo> Both of them are isomorphic to free monads
13:43:34 <Tekmo> No, cont is more powerful than a free monad
13:43:46 <Tekmo> I've seen people use Cont wastefully when a free monad was all they needed
13:43:49 <osa1> danil: I couldn't find a function like evalErrorT, how can I get the value out of ErrorT ?
13:44:14 <aristid> Tekmo: it seems like there is rarely ever a use for Cont that isn't better served by something less powerful
13:44:22 <zzing_> Tekmo, I might want to go for direct3d at some point :-), but not now
13:44:33 <Tekmo> Well, that's the thing I love about free monads
13:44:38 <Tekmo> They let you decide later what you want to do
13:45:31 <Apocalisp> @hoogle w (Either a b) -> Either (w a) (w b)
13:45:31 <lambdabot> No results found
13:45:34 <Apocalisp> :(
13:45:39 <Tekmo> Oh, for people who can't find Hackage
13:45:46 <Tekmo> The header seems to indicate it has a new IP
13:45:51 <Tekmo> Try refreshing your DNS cache
13:45:55 <Tekmo> and you might be able to find it
13:46:19 <ion> w (Either a b) -> w (Either (w a) (w b)) would be easier. :-P
13:46:22 <zzing_> The main thing I want to be able to do is output the errors that happen and as a user be able to figure out where it happened
13:46:38 <zzing_> I hear we have no tracebacks or whatever you want to call them
13:47:03 <Tekmo> Well, Simon Marlow supposedly is presenting a way to do tracebacks
13:47:05 <danil> osa1: runErrorT.  There's no evalErrorT because there might not *be* a value -- unlike StateT where you can always ignore the extra state
13:47:14 <Tekmo> I don't know when they will be incorporated
13:49:09 <monochrom> onoes, GHC 7.6.1 already doing RC1
13:49:21 <Tekmo> In my own code I just keep each error message unique
13:49:36 <Tekmo> So I can pinpoint which function failed
13:49:45 <aristid> hmm
13:49:47 <Tekmo> I usually don't find myself needing a full stack trace
13:50:12 <Tekmo> The less state you pass around the less you worry about stack traces
13:50:27 <zzing_> Debug.Trace FTW :P
13:50:28 <aristid> monochrom: are the releases historically spaced more?
13:50:45 <Tekmo> Alright, I have to head out
13:50:54 <zzing_> merci
13:50:57 <monochrom> maybe
13:50:58 * zzing_ watches as Tekmo flies off
13:51:01 <Tekmo> lol
13:51:06 <Tekmo> *rides into the sunset*
13:51:27 <JunkBee> Does haskell have a convention for handling many predicates in a function? Right now I have my function check a base case if that fails then check 4 predicates. However the check for the predicates was done with nested if statements... is it better to check the predicates by calling a function that uses gaurds to handle this?
13:51:32 <aristid> monochrom: because you said _already_ :)
13:52:00 <ion> There’s usually a better way than nested if statements.
13:52:07 <zzing_> JunkBee, src?
13:52:15 <JunkBee> I have hacked the src :<
13:52:16 <JunkBee> lol
13:52:35 <zzing_> JunkBee, the source or it wasn't written !
13:52:36 <Cale> JunkBee: you can use  case () of _ | ... -> ...
13:52:44 <Cale> to artificially introduce guards
13:53:01 <Cale> which is often handy
13:53:08 <ion> eww :-P
13:53:24 <JunkBee> sec I will salvage this beast
13:53:30 <JunkBee> it is quite awful, I warn you now
13:53:37 <roconnor> you can define guards on constants in where clauses
13:53:45 <roconnor> which is often handy
13:55:08 <zzing_> JunkBee, I doubt there is something that you can come up with that the experienced people here haven't seen worse of
13:56:38 <zzing_> :t mapM
13:56:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:56:53 <zzing_> :t mapM_
13:56:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:57:29 <zzing_> @hoogle (Monad m) => (a -> b) -> m [a] -> m [b]
13:57:29 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
13:57:29 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
13:57:30 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
13:58:04 <zzing_> Is that a hoogle fail or a zzing fail?
13:58:11 <geekosaur> :t mapM
13:58:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:58:19 <geekosaur> hm, not quite
13:58:30 <Nereid> :t liftM . map
13:58:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m [a] -> m [b]
13:58:43 <geekosaur> but @hoogle only returns the top 3 matches, and the order is somewhat arbitrary
13:58:44 <Nereid> :t fmap . fmap
13:58:46 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:58:49 <zzing_> ok, very nice
13:59:02 <geekosaur> the web hoogle interface or hayoo might be better suited in general
13:59:10 <Nereid> :t fmap fmap fmap
13:59:11 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:59:13 <Nereid> ;)
14:03:19 <JunkBee> http://pastebin.com/ahAg1vhu
14:03:21 <mauke> The paste ahAg1vhu has been copied to http://hpaste.org/73073
14:03:31 <JunkBee> the second one isn't correct syntax, however it has the idea
14:03:38 <JunkBee> I would just call a function with my values into it
14:03:42 <JunkBee> then take its return value
14:05:40 <zzing_> Does this look like a reasonable what of converting IO [GLenum] to IO [Error]? http://hpaste.org/73074
14:05:43 <kuribas> IMO there should have been a elsif keyword in haskell...
14:05:54 <davesque> is there an official style guide for haskell (like pep8 for python)?
14:06:15 <zzing_> JunkBee, what does this do?
14:06:18 <roconnor> davesque: I'm not aware of any
14:06:20 <mekeor> kuribas: bah.. ugh, yuck!
14:06:54 <kuribas> mekeor: It's better than nested ifs!  And many languages have it.
14:07:17 <mekeor> kuribas: hm.
14:07:22 <zzing_> kuribas, many languages having it doesn't mean it is a good idea
14:07:37 * mekeor rethinks his opinion.
14:07:39 <davesque> i'm trying to make sure i don't develop any weird style habits.
14:07:45 <zzing_> If that were enough, then we would have ocaml's ;   :P
14:08:02 <monochrom> use your own aesthetics. that is sufficient
14:08:02 <mekeor> zzing_: but elseif is really better than nested ifs, actually.
14:08:07 <kuribas> zzing_: That's true of course, but I like having it in those languages.
14:08:21 <mekeor> monochrom: what do you thin about that?
14:08:25 <roconnor> davesque: reading example code can help develop your own unique style
14:08:26 <zzing_> mekeor, use a where or case instead
14:08:39 <mekeor> zzing_: where? how that?
14:08:40 <roconnor> my style has evolved over many years
14:09:03 <mekeor> zzing_: case? nah, that's different... isn't it? explain!
14:09:05 <davesque> roconnor: does haskell even have widely accepted style standards for certain structures?  or is it more free to the coder's choice?
14:09:19 <mekeor> davesque: https://github.com/tibbe/haskell-style-guide
14:09:30 <zzing_> mekeor, in an if    / else kind of functionality, it is easy to test coverage - how can you be sure you have it without overlapping cases?
14:09:59 <davesque> mekeor: yeah, i saw that.  wasn't sure if it was widely used or just some guy's idea of how to do it.
14:10:06 <roconnor> davesque: in some sense the 2-D layout rules enforce a certain styleish
14:10:22 <mekeor> davesque: it's quite widely used... not a standard but some projects use it.
14:10:26 <zzing_> Actually, somebody said the other day that we are getting something like guards on ifs, so you get that anyways
14:10:42 <roconnor> ha, oh ya, the use no TABs is a good rule
14:10:44 <mekeor> zzing_: neat
14:10:50 <monochrom> nested if-then-else is fine per se, if that is the true logic of your algorithm. the real question is why is that the true logic, it seldom is the right logic
14:10:57 <mekeor> roconnor: *heavy*nod*
14:11:12 <zzing_> JunkBee, why are you using foldl?
14:11:17 <mekeor> monochrom: ah
14:11:19 <davesque> roconnor: i never use tabs.  what are the 2-D layout rules?  guess i need to read up on those.
14:11:29 <kuribas> monochrom: Using that reasoning, guards are bad too.
14:11:36 * roconnor isn't sure what the rules are
14:12:15 <davesque> roconnor: hehe.  well thanks for giving me some info.
14:12:44 <roconnor> davesque: mekeor's link to tibbe's style guide is a pretty good starting place I think
14:12:54 <roconnor> I appear to follow most of those rules
14:12:57 <roconnor> though I indent less
14:12:59 <monochrom> you see I don't speak at the level of "if-then-else is bad" or "guard is bad"
14:13:38 <monochrom> get correctness first. then simplicity. then efficiency. then "style"
14:13:48 <roconnor> davesque: I think the most widely adopted conventions are no tabs and use camelCase.
14:14:11 <monochrom> and I'm happy to insert a dozen other concerns between efficiency and "style"
14:15:07 <plat0> Once you have simplicity style is less relevant.
14:15:08 <roconnor> My biggest style development was switching to aligning commas with braces.
14:15:40 <mekeor> roconnor: yeah, but that way it looks really great
14:16:00 <zzing_> :t (/=)
14:16:01 <lambdabot> forall a. (Eq a) => a -> a -> Bool
14:16:06 <zzing_> @src (/=)
14:16:06 <lambdabot> x /= y = not (x == y)
14:16:16 <roconnor> I kinda like the braced do block, even though I rarely use them.
14:16:16 <JunkBee> zzing_: it parses a very long integer array and calculates the product of every 5 consecutive elements and stores the maximum of this product in max
14:16:38 <JunkBee> zzing_: I used foldl because I was to lazy to import foldl'
14:16:48 <zzing_> why foldl instead of foldr?
14:16:58 <zzing_> JunkBee, can you provide an example usage
14:17:04 <zzing_> I think I will have a version for you in a second
14:17:13 <nwf> Has anybody tried bootstrapping GHC on a new platform recently?
14:17:32 <monochrom> I think ARM is the more recent platform
14:17:52 <monochrom> but I don't know whether those who did it are here or not
14:17:55 <shurikas> @src (==)
14:17:56 <lambdabot> x == y = not (x /= y)
14:18:00 <JunkBee> findProduct (charListToIntArray "23592830598230598203598203958023059823095...235890723958293") [] 0
14:18:00 <shurikas> :DD
14:18:04 <hpaste> mekeor pasted “roconner: my c-code layout” at http://hpaste.org/73076
14:18:18 <mekeor> :D
14:18:20 <shurikas> how does it work?
14:18:26 <JunkBee> and then it would find the largest product of 5 consecutive numbers zzing_
14:18:33 <shurikas> == and /= reference each other
14:18:39 <shurikas> is it a joke?
14:18:53 <nwf> Well, I am trying to follow the instructions using a FreeBSD/x86-64 box to bring up a FreeBSD/sparc64 build, and can't get past very early in the target machine's make.
14:19:00 <Nereid> shurikas: you define them whenever you write an Eq instance
14:19:06 <hughfdjackson> shurikas: in the Eq typeclass, == and /= reference each other so you only need to override one of them
14:19:06 <monochrom> you break the loop by providing your own code of one of them. then the other is free.
14:19:11 <Nereid> ^
14:19:14 <shurikas> oh, right.
14:19:14 <zzing_> Can't you define both in terms of <?
14:19:16 <shurikas> that makes sense :D
14:19:24 <monochrom> you can, too
14:19:24 <Nereid> zzing_: only if you have an Ord instance
14:19:27 <hughfdjackson> then the other would be automatically defined in terms of the one you defined n.n
14:19:51 <Nereid> but honestly, who defines /= without defining == :P
14:19:52 <mekeor> Nereid: but for Ord you need Eq, don't you?
14:19:58 <Nereid> mekeor: yes
14:19:59 <hughfdjackson> well, everyone
14:20:03 <JunkBee> zzing_: oh, the foldl is used to calculate the product of the 5 element list
14:20:06 <hughfdjackson> :p since there's absolutely no need to define more than one
14:20:08 <Nereid> so, "define" in some generalized sense
14:20:16 <hughfdjackson> o.o afaict
14:20:28 <Nereid> sometimes I wish join was part of the Monad class definition
14:20:28 <dolio> One or the other might be more natural.
14:20:40 <Nereid> so join and >>= are defined in terms of each other
14:20:47 <mekeor> Nereid: yeah, the alternative prelude has that...
14:20:49 <Nereid> because sometimes it's easier to define join than >=
14:20:50 <Nereid> >>=
14:20:51 <Nereid> heh
14:21:04 <zzing_> @hoogle charListToIntArray
14:21:04 <lambdabot> No results found
14:21:08 <zzing_> where does charListToIntArray come from
14:21:09 <Nereid> well I guess you need class Functor m => Monad m
14:21:14 <monochrom> so far I have only defined (==) myself. but this is a small sample space
14:21:18 <Nereid> since you need both fmap and join to get >>=
14:21:32 <Nereid> zzing_: try hayoo or something
14:21:36 <Nereid> which indexes all of hackage (I think)
14:21:39 <mekeor> btw, has (>>=) a symbol in mathematics?
14:21:54 <Nereid> I don't think so
14:21:55 <mekeor> it looks a bit like >λ-
14:21:57 <zzing_> hmm, it finds nothing
14:22:02 <geekosaur> no, since the mathy stuff typically uses join and fmap instead of bind and return
14:22:06 <Nereid> ^
14:22:06 <monochrom> the important part is that it costs implementations almost nothing to provide defaults for both (==) and (/=), so why not.
14:22:10 <zzing_> JunkBee, I need something without charListToIntArray to test with
14:22:16 <Nereid> geekosaur: wel, it uses return too
14:22:20 <Cale> mekeor: A 5-pointed star has been used for =<<
14:22:23 <zzing_> JunkBee, preferably something small
14:22:45 <Cale> mekeor: but basically, >>= will do.
14:22:52 <Nereid> but typically they write μ and η instead of join and return
14:22:54 <mekeor> geekosaur: aah, right. there is a monad/CT-tutorial on youtube where i saw that...
14:23:03 <Cale> mekeor: in TeX, you might want to put some negative space between the >'s and the =
14:23:07 <Nereid> and read "multiplication" and "unit"
14:23:09 <mekeor> ⋆
14:23:09 <Cale> to sort of compose them together
14:23:14 <JunkBee> zzing_: findProduct [1,2,3,4,5] [] 0
14:23:34 <geekosaur> right, join/fgmap instead of bind; return is the same either way.  bind is just more comvenient haskell-wise
14:23:34 <Nereid> (key observation: monads are monoid objects in an appropriate category)
14:23:35 <mekeor> Cale: ic :)
14:24:16 <zzing_> JunkBee, annotation: http://hpaste.org/73073
14:24:20 <mekeor> geekosaur: that's the video: http://www.youtube.com/watch?v=9fohXBj2UEI :D
14:24:25 <zzing_> I think it can be made better
14:24:47 <mekeor> geekosaur: also see the best comment there.
14:24:59 <zzing_> JunkBee, it looks to me like the conditions are overlapping
14:25:16 <mekeor> geekosaur: ... saying “μ is the mentioned Mu and is the Monadic equivalent of the "join" operator.” ;)
14:25:27 <zzing_> @src product
14:25:28 <lambdabot> product = foldl (*) 1
14:25:41 <JunkBee> zzing_: yeah they are some what :S
14:25:50 <zzing_> JunkBee, BTW  use product:                        where max' = product ys
14:25:55 * geekosaur getting regularly dragged away atm :/
14:26:20 <zzing_> JunkBee, can you come to #haskell-in-depth and we can talk about this more
14:26:45 <mekeor> η = return = pure = (:[]) = unit; μ = join = concat = multiplication
14:26:51 <monochrom> is it really in depth? :)
14:27:14 <zzing_> monochrom, sure considering 'in depth' can be just deeper
14:27:38 <scshunt> Does anyone know of a library which does lazy matrix multiplication?
14:27:56 <scshunt> I need a value at coordinates of a power of a matrix, but I don't know which power in advance and it would be nice if this was lazy
14:28:30 <Nereid> scshunt: lazy in what sense? in general you'll need to know the entire matrix
14:28:42 <scshunt> Nereid: In the sense that the multiplication is lazy
14:28:49 <monochrom> perhaps just a lazy list of matrices
14:29:09 <scshunt> A given coordinate in a matrix product does not depend on every element of the two operands
14:29:15 <monochrom> iterate (* mymatrix) identitymatrix
14:29:23 <Nereid> no, but each entry in the cube of a matrix depends on all the entries
14:29:27 <Nereid> I think
14:29:28 <scshunt> Nereid: this is true
14:29:35 <scshunt> still, I don't know which power in advance
14:29:45 <scshunt> I will know when to stop looking, but that's it
14:30:01 <Nereid> or do you have a sparse matrix?
14:30:01 <monochrom> iterate (* mymatrix) identitymatrix  does not know which power in advance
14:30:30 <Nereid> scshunt: whatever you write, it will be as lazy as it can
14:31:51 <aristid> @hoogle liftBase
14:31:52 <lambdabot> No results found
14:32:05 <scshunt> Nereid: By the second or third power it will be dense
14:32:37 <scshunt> Nereid: and that's not entirely true; the matrix operation needs to be index-aware
14:32:50 <Nereid> I'm not sure what that means.
14:32:55 <aristid> huh, seems like haskell-align-imports also sorts the lines now
14:33:02 <Nereid> or what you're trying to do.
14:33:32 <scshunt> Nereid: I'm trying to look at paths in a graph, using the adjacency matrix
14:33:59 <scshunt> it's got several hundred vertices
14:35:02 <scshunt> and I want to generate an ordering on vertices by "is the sum of all the paths from A to B of length n greater than the sum of all the paths from B to A of length n"
14:35:13 <scshunt> lexicographically, so I stop if they disagree at 1, and if they agree, go to 2, etc.
14:35:45 <scshunt> I expect it won't be that bad in this limited case
14:35:52 <scshunt> but I don't like "this code will just work" as an approach
14:35:59 <scshunt> it should scale
14:37:50 <aristid> huh, seems like hackage is up but unreliable?
14:38:33 <monochrom> reliable here. YMMV. this is because it switched to another network or ISP or something
14:38:48 <roconnor> scshunt: is that ordering transitive?
14:38:52 <scshunt> roconnor: no
14:39:07 <roconnor> how do you intend to sort using a non-transitive order?
14:39:10 <scshunt> I don't.
14:39:49 <roconnor> 14:35:02 <scshunt> and I want to generate an ordering on vertices
14:39:50 <scshunt> I intend to use this (and a weighting function that arises out of the ordering in this case) to run the beatpath algorithm and from there get a transitive ordering
14:39:55 <roconnor> Why do you use the word ordering?
14:40:06 <roconnor> oh
14:40:20 <scshunt> because I'm never sure if I can say 'relation'
14:40:50 <scshunt> and there's sufficient ambiguity in the word 'ordering'
14:41:47 <smokey991> hackage is still down?
14:42:13 <geekosaur> up but changed ISP; watch out for cached DNS information
14:42:18 <geekosaur> or routing
14:42:32 <smokey991> ok thanks
14:42:56 <geekosaur> (but I suspect dns, esepcially given Lion at least now caches DNS in ways "dscacheutil -flushcache" can't clear any more --- have to reboot or manually diddle the DNS settings in the Network prefpane to flush)
14:44:15 <monochrom> DNS is the most likely issue for most people. but we also heard an exception case where DNS was fixed but still no connection
14:45:02 <geekosaur> which could be ISP DNS caching
14:45:08 <geekosaur> hm, no, suppose
14:45:10 <monochrom> hmm! iirc ubuntu 12.04 also does some kind of its own DNS caching, is that right?
14:45:19 <geekosaur> most linuxes do, via nscd
14:45:52 <geekosaur> ubuntu may have switched to using something else on top or in place of that though
14:46:14 <monochrom> ubuntu didn't use nscd. at least, not out of the box
14:47:12 * geekosaur has not checked latest ubuntu, is not really in a position to do so, and generally doesn't actually care what it does any more anyway
14:49:19 <jmcarthur> are there are tentative release notes for ghc 7.6?
14:49:27 <jmcarthur> *are there any
14:50:01 <monochrom> dunno. not sure if the RC1 tarballs have it
14:50:18 <jmcarthur> eh, i'll just hunt around
14:50:48 <monochrom> I think the tarballs have it, but it's rude to ask you to download a gig of tarball just for a possible release notes :)
14:52:41 <monochrom> the trick of modifying the existing 7.4.2 urls to 7.6.1 doesn't work :)
14:53:10 <jmcarthur> heh, i'll live. thanks
14:53:38 <jmcarthur> there is this http://hackage.haskell.org/trac/ghc/wiki/Status/May12
14:55:12 <sm> geekosaur, smokey991: on *Lion, sudo killall -HUP mDNSResponder is the trick
14:56:24 <smokey991> im on windows. cant connect on here or my laptop running debian
15:07:14 <mekeor> What is ArrowChoice called in mathematics?
15:07:42 <ion> What is IO called in mathematics?
15:07:55 <jmcarthur> isn't ArrowChoice just a monoid on arrows?
15:08:01 <jmcarthur> or am i mixing it up?
15:08:16 <jmcarthur> ah, no
15:08:21 <aristid> jmcarthur: there really is a lot of Monoid classes in haskell :)
15:08:22 <jmcarthur> i'm thinking something else
15:08:34 <jmcarthur> ArrowPlus is what i'm thinking
15:08:36 <jmcarthur> yeah
15:08:40 <mekeor> there's ArrowZero and ArrowPlus
15:08:53 <aristid> ArrowChoice is more like EitherT, right?
15:08:55 <mekeor> jmcarthur: yup :)
15:09:03 <jmcarthur> not sure what to call ArrowChoice
15:09:38 <jmcarthur> looks like kind of a bifunctor, but then again so does Arrow
15:10:01 <jmcarthur> both are specialized, though
15:10:47 <mekeor> i'm just curious why i can't define map for Arrow but for ArrowChoice...
15:12:20 <jmcarthur> mekeor: what do you mean by map?
15:12:30 <jmcarthur> in a sense, arr is the closes equivalent to map, for arrow
15:12:37 <mekeor> mapA :: Arrow (~>) => (x ~> y) -> [x] ~> [y]
15:13:00 <jmcarthur> i see
15:13:15 <ParahSailin> :t (~>)
15:13:16 <lambdabot> Not in scope: `~>'
15:13:30 <jmcarthur> ParahSailin: it's polymorphic
15:13:55 <ParahSailin> :t (~>) :: Arrow
15:13:56 <lambdabot> Not in scope: `~>'
15:14:00 <mekeor> ParahSailin: it's a type variable
15:14:01 <jmcarthur> mekeor: ArrowChoice gives you the ability to do pattern matching and stuff
15:14:11 <jmcarthur> ParahSailin: Arrow is a type class, not a type
15:14:23 <mekeor> jmcarthur: http://uxl.dyndns.org/mekeor/blog/2012-08-12-arrow-map.html
15:15:19 <jmcarthur> yeah, you need arrowchoice to use case, in your definition
15:15:24 <mekeor> jmcarthur: ah. but why do i need ArrowChoice for pattern matching?
15:15:32 <mekeor> jmcarthur: y?
15:16:05 <jmcarthur> ArrowChoice is what allows you to say "if X this subgraph is shaped like Y else it's shaped like Z"
15:16:24 <jmcarthur> and case is, from some point of view, just nested ifs
15:16:39 <mekeor> did you mean: s/X/X then/
15:16:46 <jmcarthur> yes
15:16:55 <mekeor> hm, okay...
15:17:15 <jmcarthur> it basically gives you switching behavior
15:17:39 <jmcarthur> both possible subgraphs are static, but you get to choose which one to use based on dynamic information
15:18:19 <mekeor> jmcarthur: ah, yeah. just look at this method of ArrowChoice:   (|||) :: a b d -> a c d -> a (Either b c) d
15:18:27 <mekeor> this makes it clear.
15:20:09 <otters> @hoogle (|||)
15:20:09 <lambdabot> Control.Arrow (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
15:21:29 <jmcarthur> :t either
15:21:31 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:21:37 <jmcarthur> it's basically just that ^^
15:21:39 <mekeor> yeah :D
15:21:42 <mekeor> hehehe
15:22:11 <ion> @type [(|||), either]
15:22:13 <lambdabot> forall b d c. [(b -> d) -> (c -> d) -> Either b c -> d]
15:23:00 <jmcarthur> :t (|||) `asTypeOf` either
15:23:02 <lambdabot> forall b d c. (b -> d) -> (c -> d) -> Either b c -> d
15:23:17 <mekeor> nice =)
15:25:19 <ion> @type (|||) `asAppliedTo` (undefined :: a -> b)
15:25:20 <lambdabot> forall b d c. (b -> d) -> (c -> d) -> Either b c -> d
15:27:08 <arbn> This is a Yesod question... I'm having trouble adding a non-auth-related form inside the loginHandler provided by yesod-auth. I get a type error when I try to use generateFormPost inside loginHandler. Any tips?
15:27:34 <nh2> Hackage seems down. Where can I find my local documentation (e.g. haddocks about Control.Exception)?
15:28:22 <mekeor> nh2: hackage isn't actually down anymore. but the IP has changed, see /title.
15:28:34 <arbn>  "Couldn't match expected type GWidget Auth MyApp a0 with actual type (FormResult (InviteRequestGeneric backend0), GWidget Auth MyApp ())" is the error.
15:28:38 <mekeor> nh2: and i dunno where the local doc is, but please say me if you know.
15:28:40 <mekeor> =)
15:29:07 <arbn> To get the local docs, I just expand the cached package and run "cabal haddock", and it puts the docs in the dist folder.
15:29:08 <mekeor> arbn: there's also #yesod, i think.
15:29:15 <mekeor> yup
15:29:58 <arbn> mekeor: Yeah. I asked there, but this is a bigger channel, so I figure I'd at least give it one shot.
15:30:30 <mekeor> ok.
15:35:17 * ksksal LISTEN :: radio URL: http://playbackfm.listen2myradio.com
15:41:53 <wires> for simple string processing, which library do you recommend?
15:42:08 <wires> also, which regular expression library should I use?
15:42:37 <wires> any recommendations?
15:42:59 <HugoDaniel> hi
15:43:14 <HugoDaniel> wires: use Data.Text
15:43:46 <wires> HugoDaniel, thanks!
15:43:59 <wires> Was already using that with attoparsec, so that's cool
15:44:53 <wires> HugoDaniel, what about regular expressions on Data.Text ?
15:45:02 <wires> any thoughts?
15:47:24 <wires> Also, is there maybe a smart way to avoid having to pack all your string literals? such that "foo" :: Data.Text
15:48:07 <danil> you want {-# LANGUAGE OverloadedStrings #-}
15:49:03 <monochrom> I use the regex lib that comes with the haskell platform
15:56:06 * hackagebot gpx-conduit 0.1.1 - Read GPX files using conduits (ThomasDuBuisson)
15:56:32 <donri> is it a monoid law that mappending mempty on either side must return the other side, i.e. not change the internal representation even if the semantics stay the same?
15:57:29 <monochrom> IMO the law just says semantics
15:57:40 <sipa> i don't think any law ever considers internal state
15:57:53 <sipa> unless that state is observable
15:58:05 <monochrom> all laws just say observable semantics. representation is unobservable
15:58:31 <donri> well the representation is public
15:59:10 <monochrom> "5 + 0 = 5" does not say that the two 5's are stored at the same addresses. where 5's are stored is representation.
16:01:37 <donri> also criterion reports that my benchmarks run slower since modularizing the code. was that to expect?
16:02:41 <luite> donri: you mean splitting it up into multiple modules?
16:02:47 <donri> yea
16:02:56 <LadyAurora> Then yes.
16:02:58 <luite> yeah that's expected
16:03:02 <donri> aww
16:03:24 <LadyAurora> GHC is bad at intramodule optimizations.
16:03:25 <donri> "inline *all* the things"?
16:03:31 <luite> donri: ghc compiles one module at a time, it can do inlining and specialization within the module, inter module inlining requires pragmas
16:03:39 <sipa> LadyAurora: intermodule optimizations, you mean?
16:03:53 <LadyAurora> sipa: yes.
16:04:31 <donri> luite: how's that work, just INLINE at definition site?
16:05:26 <luite> donri: {-# INLINE my_function #-}
16:05:36 <donri> luite: but in which module?
16:05:47 <donri> the one using my_function or the one defining it?
16:06:01 <luite> donri: defining
16:06:03 <LadyAurora> The one where you define the function.
16:06:13 <donri> aye
16:06:18 <luite> donri: perhaps INLINABLE is closer to what GHC does usually
16:06:57 <donri> also how do you inline type class methods? i tried SPECIALIZE INLINE and also both of those alone and ghc said it was ignoring useless pragmas
16:07:45 <sipa> i suppose you put them in the instance defintion?
16:11:17 <triyo> Is there a flag for cabal through which I could remove a Build-Depends entry?
16:13:17 <triyo> Hmm, ignore
16:15:21 <parcs`> donri: i think you have to inline each instance definition separately
16:15:43 <parcs`> o sipa said that
16:24:16 <m3ga> anyone know who was doing the hackage upgrade? if so they need to set up reverse DNS on mail.galois.com. many mail servers (mine included) by default reject mail from hosts without valid reverse DNS.
16:32:17 <nh2> I get: "Exception: fd:8: commitBuffer: resource vanished (Broken pipe)". How do I find out which Exception type/constructor this is for catching?
16:38:29 <shirt> Anyone know what the release timeline is for ghc-7.6 / base-4.6.0.0, and when the core packages(HTTP, text...) will be patched to be compaible?
16:39:54 <broombs> Given data D ... , class I a where f :: a -> D,  class J a where g ::
16:39:54 <broombs> a -> Text,  instance J D where ..., why does ghc complain of
16:39:54 <broombs> overlapping instances when it sees instance (I a) => J a where g = g
16:39:56 <broombs> . f  ?
16:41:33 <monochrom> dunno 7.6 release time, but it will be soon, since RC1 just came out today
16:41:53 <monochrom> I think they aim at getting it done before ICFP
16:43:31 <broombs> nm, thx
16:43:41 <shirt> wow, didn't even notic RC1. but what about all these broken packages? The removal of Prelude.catch seems to be the main problem. HTTP and text and others are broken
16:43:54 <ion> They’ll be fixed sooner or later.
16:44:04 <ion> A similar thing happened with 7.4.
16:44:57 <monochrom> oh, taking away Prelude.catch? that may stir up a big controversy
16:45:18 <monochrom> but in a sense I would say good riddance
16:46:53 <ion> I’d have them do certain changes that would stir up much bigger controversy. :-P The more they wait, the more difficult it will be to fix certain things.
16:47:07 <shirt> i suppose. text is broken only because it deliberately imports Prelude hiding (catch)
16:49:04 <shirt> ion: like what?
16:50:21 <ion> shirt: Oh, the pet peeves that are discussed here every other day. The Functor/Applicative/Monad type classes etc.
16:52:46 <shirt> ion: like the monad "fail" method?
16:53:37 <ion> Including that, yes.
16:58:25 <JoeyA> Is there a convenient way to install the GHC 7.6 release candidate on Linux, without overwriting my ghc, ghci, ghc-pkg, and haddock links?
16:58:59 <JoeyA> Or should I just go back and change the links myself?
16:59:06 <xvilka> hi! trying this tutorial: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot but this bot can't connect IRC - just always writing connection timeout. Whats can be wrong? I'm using irssi from that machine - all ok
16:59:34 <xvilka> JoeyA: it depends from your linux distro too
16:59:44 <JoeyA> Ubuntu 10.04 64-bit
17:01:02 <JoeyA> xvilka: What happens if you do this?  telnet irc.freenode.org 6667 .  That is, make sure your address is correct.
17:01:12 <xvilka> JoeyA: write simple script, which will do symbolic links from one ghc version to anothe
17:01:14 <JoeyA> When I do the telnet, I get some *** lines, so apparently that's the right address and port.
17:01:35 <xvilka> JoeyA: as i said, i'm writing here from that machine
17:01:38 <ion> joeya: I’d get the binary distribution from http://www.haskell.org/ghc/dist/stable/dist/ and install it under ~ (<https://gist.github.com/2815423>).
17:02:01 <ion> joeya: You can select the GHC version by setting the proper PATH.
17:02:15 <ion> having installed them into separate directories under ~.
17:02:28 <JoeyA> ion: You can also do it with cabal install -w, if ghc-7.6.0 or whatever is in PATH.
17:02:32 <xvilka> also, it show messages, like NOTICE: No ident responce, etc, but then Connection timed out
17:03:03 <JoeyA> xvilka: Could you paste your code?
17:03:16 <nh2> I get: "Exception: fd:8: commitBuffer: resource vanished (Broken pipe)". How do I find out which Exception type/constructor this is for catching?
17:03:47 <xvilka> JoeyA: follow my - link , code from chapter 2
17:04:34 <JoeyA> nh2: Exception has a Typeable constraint.  Thus, every type of exception supports typeOf.
17:05:02 <JoeyA> xvilka: The link has the code all split up.  I'm wondering if you miscopied something.
17:05:31 <nh2> JoeyA: using typeOf, I always get "SomeException" on the Broken pipe
17:05:43 <JoeyA> nh2: Unwrap the SomeException
17:05:53 <JoeyA> e.g. `catch` \(SomeException e) => print (typeOf e)
17:06:40 <xvilka> bah, my bad, stupid error. Executed wrong file, with another code :D
17:07:36 <nh2> JoeyA: ohhh, of course, thank you.
17:09:11 <JoeyA> Hmm, I wonder what would happen if you did this: throwIO $ SomeException $ SomeException $ SomeException $ userError "Buried under existentialism"
17:09:45 <xvilka> Now it works now, with valid code :) Always check executed filename :)
17:10:30 <JoeyA> What I hate is: test, modify, test, modify, test, modify, then finding out I was testing the wrong program and thinking it was working
17:11:38 <JoeyA> "Oh cool, C *does* support polymorphic pointer types!  Oh wait, wrong file."
17:13:41 <monochrom> if you throw "SomeException (SomeException (..." and I catch it, if I just print it, I get the correct string (the string from the innermost exception). but if I do more, e.g., ask about its type, it's harder
17:15:05 <JoeyA> Hmm, I wonder if catching e.g. ErrorCall won't work if it's wrapped in too many SomeExceptions.
17:15:14 <monochrom> won't work
17:16:14 <monochrom> what will work: if you know, a priori, how many nesting levels there are, let's say 3, then you can explicitly pattern-match against SomeInception (SomeInception (SomeInception (ErrorCall ...
17:18:13 <nooodl> hey, i just accidentally stumbled upon this:
17:18:13 <monochrom> do write some code to test all these hypotheses
17:18:15 <nooodl> @kind 1
17:18:16 <lambdabot> *
17:18:28 <monochrom> @kind True
17:18:30 <lambdabot> Not in scope: type constructor or class `True'
17:18:40 <monochrom> hmm what is 1?
17:18:47 <nooodl> no idea
17:18:57 <mauke> > 1 :: 2
17:18:59 <lambdabot>   Only unit numeric type pattern is valid
17:19:23 <nooodl> > 2 :: 1
17:19:24 <lambdabot>   No instance for (GHC.Num.Num GHC.Generics.Unit)
17:19:25 <lambdabot>    arising from the literal...
17:19:36 <dmwit> > () :: 1
17:19:37 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
17:19:38 <lambdabot>         against inferred t...
17:19:42 <monochrom> oh interesting, generics
17:19:43 <dmwit> oh, Generics
17:20:06 <ion> @type undefined :: 1
17:20:07 <lambdabot> Unit
17:22:33 <mauke> > (undefined :: 1) :: Unit
17:22:35 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
17:22:35 <lambdabot>    arising from a use of ...
17:22:41 <mauke> nice
17:23:25 <nooodl> @type Unit :: 1
17:23:26 <lambdabot> Unit
17:27:09 <JoeyA> Some good news: with GHC, you won't have to do import Prelude hiding (catch) anymore.
17:27:16 <ion> > typeOf Unit
17:27:18 <lambdabot>   No instance for (Data.Typeable.Typeable GHC.Generics.Unit)
17:27:18 <lambdabot>    arising from ...
17:27:18 <JoeyA> Bad news: import Prelude hiding (catch) won't compile anymore.
17:27:38 <JoeyA> Unless you wrap it in a MIN_VERSION_base thingy.
17:27:59 <dstcruz> is there a way to save a ghci session?
17:28:11 <geekosaur> no
17:33:52 <dstcruz> pressing the up arrow in ghci seems to remember things, is that saved anywhere to a file? It seems to persist between sessions aswell
17:34:42 <ion> It’s in the second place you’d look.
17:34:47 <mauke> ion: haha
17:34:57 <mauke> more like third or fourth
17:35:22 <ion> .ghci_something? Nope. .ghc/something? Yep.
17:35:35 <mauke> ~/.haskeline something? nope
17:35:40 <mauke> ~/.history something? nope
17:35:46 <mauke> ~/.ghci something? nope
17:35:49 <mauke> ~/.ghc/history
17:35:52 <geekosaur> you only think of .haskeline if you pay too much attention to thebuild ;}
17:36:02 <geekosaur> and kow what haskeline *is*
17:36:10 * mekeor doesn't.
17:36:11 <ion> Nothing i’ve seen names their history files as .historysomething.
17:36:21 <ion> The de facto pattern seems to be .programname_history.
17:37:30 <mekeor> what is haskeline? "The Haskeline library provides a user interface for line input in command-line programs." what does that mean?
17:37:38 <mekeor> which programs use haskeline?
17:38:15 <ion> Even if Haskeline defaulted to some filename for history (and even if i had known ghci uses it) i’d have been truly surprised if ghci didn’t change it to a file of its own.
17:38:17 <mauke> mekeor: ghci
17:38:19 <geekosaur> ion, nothing since csh at least ;}
17:39:09 <mekeor> mauke: ah
17:39:20 <nh2> I am surprised about createProcess. If I run "asfd" with it, I would expect an exception. Instead, I can even call hGetContents on its stdout pipe and get ""
17:39:58 <mekeor> nh2: you get an Maybe Handle as stdout, right?
17:40:06 <mekeor> @hoogle createProcess
17:40:06 <lambdabot> System.Process CreateProcess :: CmdSpec -> Maybe FilePath -> Maybe [(String, String)] -> StdStream -> StdStream -> StdStream -> Bool -> CreateProcess
17:40:07 <lambdabot> System.Process data CreateProcess
17:40:07 <lambdabot> System.Process createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
17:40:24 <mekeor> yup
17:40:45 <ion> λ> rawSystem "asfd" []
17:40:46 <mekeor> nh2: so you can use that Maybe to check whether you have a stdout...
17:40:47 <ion> ExitFailure 127
17:40:57 <mekeor> but wait.
17:41:06 <mekeor> nh2: so you get a Just stdout?? oO
17:41:08 <nh2> mekeor: well but that *works*!!
17:41:26 <mekeor> erm... /me doesn't know
17:42:32 <nh2> mekeor: I actually use runInteractiveProcess, which uses fromJust inside, but that's perfectly fine. I get the handle out and I can read from it, just as if the process was spawned fine
17:42:43 <mauke> the process was spawned fine
17:44:05 <nh2> mauke: how am I supposed to check for the existence of the command then? Check for error code 127? Or is there a safer way?
17:44:17 <mauke> I don't know, I've never used it
17:45:14 <nh2> when I run subprocess.call("asdf") in Python I get OSError: [Errno 2] No such file or directory
17:45:23 <nh2> that sounds quite sane
17:45:23 <mekeor> nh2: are you sure you haven't got a program called asdf? :D
17:45:46 <nh2> mekeor: yeah I actually checked :D
17:45:59 <mauke> so apparently the python library communicates errors back to the parent process
17:47:30 <danharaj> edwardk: looks like the type operator change is going into 7.6.1
17:47:44 <edwardk> yep
17:47:50 <mekeor> danharaj: you mean -XTypeOperators? coool
17:47:56 <edwardk> see why i said not to rely on it? =)
17:48:13 <edwardk> mm_freak will have a bad day
17:48:19 <mekeor> why?
17:48:21 <rosie_> What's this arrow operator called? (\line -> length line < 10)
17:48:40 <mauke> rosie_: less than
17:48:43 <edwardk> he uses (>~) as a locally bound variable that is an operator a _lot_
17:48:45 <mekeor> rosie_: lambda expression
17:48:59 <danharaj> (<10).length
17:49:02 <mekeor> rosie_: http://www.haskell.org/haskellwiki/Anonymous_function
17:49:14 <jfischoff> edwardk: I didn't realize how easy Biplate was to use, so I guess your right about Multiplate being a pain to use.
17:49:19 <rosie_> ah my bad. thanks
17:49:21 <shirt> mekeor: is it accurate to call the arrow in a lambda expression an "operator"?
17:49:24 <edwardk> heh
17:49:28 <mekeor> shirt: nope
17:49:47 <mekeor> rosie_: did you hear that?
17:50:08 <rosie_> that it's not called an "operator" -- it seems like is more syntax for the lambda
17:50:14 <edwardk> jfischoff: it gets worse when you add the extra flexibility i need for families
17:50:20 <typoclass> shirt: not really, the "->" is part of the syntax. an operator is a function defined in some library ((+) or (++) or whatever)
17:50:20 <rosie_> to separate the parameter from the expression
17:50:28 <mekeor> rosie_: exactly. \ is λ
17:50:52 <rosie_> mekeor: thanks
17:51:00 <jfischoff> edwardk: I can only imagine.
17:51:00 <mekeor> yw =)
17:51:29 <edwardk> for instance most of the multiplate combinators only work for 'SImple' plates
17:51:47 <jfischoff> edwardk: those are where the types stay the same right?
17:51:51 <edwardk> yep
17:52:06 <jfischoff> which I assume applies to Uniplate/Biplate also
17:52:12 <edwardk> yeah
17:52:18 <edwardk> thats why they can't change types
17:52:22 <jfischoff> yeah
17:52:42 <edwardk> i can use a different kind to index the plate appropriately so i can at least talk about those plates
17:52:46 <edwardk> but its a bit awkward
17:52:58 <edwardk> e.g.
17:53:17 <edwardk> Plate f i j where i and j have kinds like (*,*,*)
17:54:02 <jfischoff> are those commas?
17:54:02 <edwardk> plate families sound a little silly admittedly
17:54:08 <edwardk> yes
17:54:19 <edwardk> data kinds
17:54:25 <edwardk> lifted tuples
17:54:54 <jfischoff> hmm how does that relate to the * -> * kinds I am familiar with?
17:55:36 * jfischoff is reading about promoted lists and tuples types
17:56:46 <edwardk> its just another kind, if you pretended * was a type, you can tuple up *'s, take lists of them, etc.
17:57:03 <jfischoff> okay
17:57:06 <mekeor> is < or <= more efficient?
17:57:08 <edwardk> '[Int,Double,Maybe Bool] :: [*]
17:57:19 <jfischoff> ok
17:57:21 <edwardk> <= is more likely to be implemented
17:57:30 <mekeor> ok
17:57:46 <mekeor> so it's generally more efficient, right?
17:57:48 <mekeor> thanks
17:58:03 <edwardk> that or using compare directly
17:58:16 <ion> [*, *, *] ::
17:58:24 <mekeor> ion: :D
17:58:39 <edwardk> ion: you can't lift twice =)
17:58:48 <mekeor> [*, * -> *, * -> * -> *] :: -- would have been a better example, IMHO
17:58:55 <ion> mekeor: yeah
17:59:15 <edwardk> and you can only promote simple types to kinds
17:59:36 <mekeor> wait, were you talking about haskell?
17:59:43 <edwardk> yes
17:59:44 <mekeor> is haskell going to support such things?
17:59:45 <mekeor> O_O
17:59:46 <edwardk> using DataKinds
17:59:48 <mekeor> O_O
17:59:48 <mekeor> O_O
17:59:49 <edwardk> it already does
17:59:49 <mekeor> O_O
17:59:52 <mekeor> wow
18:00:37 <ion> :k [Integer, Double, Maybe Bool]
18:00:38 <lambdabot> parse error on input `,'
18:00:40 <mekeor> hm, in ghci, with :set -XDataKinds, "let x = [Int, Double] :: *" doesn't work.
18:01:02 <mekeor> x = [Int, Double] neither
18:01:03 <ion> That’s not expected to work either.
18:01:09 <edwardk> mekeor: that is a term, not a type
18:01:16 <mekeor> hm?
18:01:22 <ion> You’re mixing up value- and type-level things.
18:01:37 <mekeor> erm... what is [Int, Double] ?
18:01:47 <aristid> not haskell
18:01:49 <mekeor> oh, wait. x is a value!
18:02:00 <mekeor> and [Int, Double] isn't...
18:02:00 <edwardk> data HList :: [*] -> * where HCons :: a -> HList as -> HList '(a : as); HNil :: HList '[]
18:02:18 <edwardk> then HCons 1 (HCons () HNil)
18:03:11 <mekeor> and what can i do with a HList?
18:03:36 <edwardk> mekeor: take a look at likes 93 and 97 of http://hpaste.org/73067
18:03:57 <edwardk> and the combinators in introduce afterwards
18:04:02 <edwardk> er I introduce
18:04:46 <mekeor> ah, so you can introduce Vectors and such things...
18:04:50 <edwardk> yes
18:05:14 <edwardk> there a Vec is actually an hlist of values under some other 'f'
18:05:20 <mekeor> so, what is the difference between haskell+datakinds and idris, e.g.?
18:05:31 <edwardk> idris lets you give your datakinds datakinds ;)
18:05:38 <edwardk> haskell gives you one level
18:05:45 <edwardk> but you get better inference properties
18:05:52 <mekeor> okay, so in idris i have * :: Set2 or something..
18:05:55 <dolio> Datakinds can't have datakinds. that makes no sense.
18:06:13 <edwardk> ok, your kinds can have interesting superkinds
18:06:20 <edwardk> better? =)
18:06:26 <dolio> Yes.
18:06:31 <mekeor> or "sorts"
18:06:45 <dolio> Sort generally refers to something else.
18:06:45 <mekeor> value -> type -> kind -> sort :D
18:06:46 <edwardk> sorts is tricky because types, kinds, etc are all distinct sorts
18:06:59 <mekeor> oh, okay then... :D
18:07:02 <edwardk> so calling superkinds sorts is a bit of an abuse of terminology
18:07:11 <dolio> Syntactic classes in the logic, more or less.
18:07:24 <mekeor> okay, so types, kinds and superkinds are all sorts?
18:07:33 <edwardk> yes
18:07:36 <dolio> Value is a sort, as well.
18:07:38 <edwardk> terms too
18:07:39 <mekeor> hehe that's funny :D
18:07:43 <mekeor> terms == values?
18:07:48 <edwardk> yeah
18:07:49 <dolio> Yes.
18:07:53 <mekeor> nice :)
18:08:03 <edwardk> basically you refer to the level itself as the sort
18:08:23 <jfischoff> edwardk: I was looking through lens and I noticed a major pattern is f . g . f^-1 where f is an isomorphism. Have you thought about adding a "conjugate"  combinator isomorphism to do that or do you already have one?
18:08:45 <mekeor> do languages with kind-classes exist? wait. can agda/idris do that? they should be able to do that, right?
18:09:11 <edwardk> jfischoff: do you have an example using it? i can see the pattern, but for isntance
18:09:20 <edwardk> from packed . traverse -- goes in and back out already
18:09:40 <edwardk> so thats already in essence conjugated
18:10:28 <dolio> That looks like ala.
18:10:38 <edwardk> mekeor: talking with stephanie weirich at hac phi, she seemed pretty keen on just using * :: *, which admittedly introduces paradoxes, but since the translation is to a typed intermediate language, there isn't any evaluation headaches
18:10:58 <jfischoff> edwardk: I was saying foldOf, andOf, orOf but now that Iook closer its slightly different
18:11:01 <ion> 42 :: 42
18:11:02 <edwardk> yeah
18:11:07 <edwardk> those are all 'ala' ish
18:11:19 <edwardk> i got djahandarie to add an alaF to newtype to match the pattern
18:11:26 <mekeor> omg
18:11:28 <edwardk> but i don't want to add the dependency directly
18:11:49 <mekeor> ala?
18:11:56 <edwardk> Control.Newtype.ala
18:11:57 <ion> @hackage newtype
18:11:57 <lambdabot> http://hackage.haskell.org/package/newtype
18:12:13 <mekeor> wtf
18:12:22 <edwardk> was sayig he should name the new operator Control.Newtype.mohammed, but that didn't go over very well.
18:12:41 * mekeor is moslem.
18:12:46 <edwardk> so we get alaF
18:13:00 <edwardk> mekeor: no offense intended
18:13:04 <mekeor> :)
18:14:40 <hpaste> mekeor pasted “my bubble sort doesn't work :/” at http://hpaste.org/73088
18:14:51 <mekeor> why does my bubble sort not work? :(
18:15:10 <mekeor> bubbleSort [5,3,1,9,5] == [3,1,5,5,9] -- in ghci
18:15:14 <edwardk> so whenever the next newtype release happens you'll be able to use them very easily with traversals and folds though there shouldn't actually be any of them out of the box that i don't already have in lens
18:16:00 <edwardk> mekeor: what happens when you keep bubbling it until it stops changing?
18:16:27 <edwardk> you forgot you need to bubble multiple times
18:16:35 <edwardk> as long as you continue swapping elements
18:16:44 <mekeor> oh
18:16:44 <dolio> Bubble sort is not O(n), unfortunately.
18:16:50 <mekeor> :D
18:17:03 * mekeor read that the best possible is O(n*log n)
18:17:08 <edwardk> mind you this 'single bubble' pass is a useful tool in things where you only need approximate sorting
18:17:12 <jfischoff> edwardk:  its almost like continuation passing conjugation, oh well conjugation still might be a useful function for Isomorphic
18:17:18 <edwardk> becaue you can run it every frame, etc.
18:17:44 <edwardk> jfischoff: too bad ala is already taken
18:18:00 <mekeor> thanks again, edwardk. you're awesome
18:18:09 <edwardk> np
18:18:55 <jfischoff> do recursion schemes related to multiplate and uniplate in anyway?
18:19:49 <nh2> mekeor: I sent it to haskell-cafe
18:19:50 <edwardk> in a kind of odd way.
18:19:55 <mekeor> edwardk: btw, do you teach CT?
18:19:56 <mekeor> nh2: ok
18:20:07 <edwardk> mekeor: no. i write code ;)
18:20:56 <edwardk> i used to teach math and CS, but never get to teach category theory
18:20:57 <mekeor> edwardk: are you at university or in industry?... oh right! you once said that you're writing a haskell-clone compiler or so...
18:21:08 <mekeor> edwardk: ah
18:22:18 <edwardk> I work with dolio, copumpkin, apocalisp, pchiusano, sclv, S11001111 and some others at S&P Capital IQ.
18:22:35 <mekeor> cooool
18:22:47 <mekeor> nice community
18:22:54 <edwardk> its a great team
18:23:07 <mgsloan>  RE: newtype, (also at hac-phi) byorgey pointed out that it'd actually be ideal if under / over were switched.  While over might make more sense mathematically, they don't make much sense as a visual metaphor
18:23:09 <mekeor> and you code in haskell, right?
18:23:24 <mgsloan> "over" seems like it would be 'around' the wrapper, whereas under would be "within"
18:23:33 <edwardk> scala and ermine (our haskell-clone) mostly
18:23:38 <mekeor> ah
18:23:55 <edwardk> too much we need to interoperate with lives on the JVM
18:24:10 <Apocalisp> it's not a straight Haskell-clone
18:24:10 <mgsloan> actually, maybe "using" and "within" would be better synonyms for "under" and "over"
18:24:21 <edwardk> wonder if another french combinator would make sense, like 'au' or something ;)
18:24:30 <mekeor> :D
18:24:30 <edwardk> for conjugate
18:25:00 <edwardk> au is a le right?
18:25:02 <mekeor> my favorite french word is "jouaient" because all vocals are in one sequence...
18:25:07 * edwardk forgot most of his french
18:26:31 <mekeor> so, after one bubble, i know that the maximum is at the end, right? that's the key
18:26:49 <edwardk> mekeor: just track whether or not you had to swap anything each pass
18:26:58 <edwardk> stop when you didn't swap
18:27:17 * mekeor is not going to actually use that function
18:27:46 <mekeor> edwardk: but... why? i mean, don't i have to go through the whole list??
18:27:53 <luite> yeah you can stop comparing the last n things after n passes, but it's more difficult to implement
18:27:53 <edwardk> well, yes.
18:28:07 <edwardk> luite: yeah the last n items are hard to cut off in haskell
18:28:19 <edwardk> mekeor: that is the nature of sorting ;)
18:31:13 <zzing_> Do I have to import something to get the list monad?
18:31:25 <edwardk> zzing_: no
18:31:38 <edwardk> > [1,2,3] >>= \a -> [a, a * 2]
18:31:39 <lambdabot>   [1,2,2,4,3,6]
18:33:08 <zzing_> ok, got it http://hpaste.org/73089    had to import Control.Monad for guard
18:34:12 <mm_freak> edwardk: oh yes, that change indeed will make me have a bad day
18:34:31 <zzing_> mm_freak, guten tag
18:34:34 <mm_freak> alo
18:35:07 <mm_freak> i wonder why they change the type operator syntax…
18:35:30 <mm_freak> after all you can have symbolic variables on value level
18:35:43 <mm_freak> foldl (+) z = …
18:36:43 <mm_freak> Cale will also have a very bad day
18:37:18 <mm_freak> while i could easily change it in netwire, Cale's FRP library relies heavily on stuff like:  X (~>) a b ~> …
18:39:03 <zzing_> Is FRP developed enough that it would be very easy for somebody to understand it and use it in a practical way?
18:40:39 <mm_freak> zzing_: FRP is a family of concepts
18:40:50 <zzing_> mm_freak, yes it is
18:41:07 <zzing_> With many implementations over the few years.
18:41:29 <mm_freak> personally i categorize into two branches:  classic FRP and AFRP
18:41:52 <mm_freak> classic FRP works with behaviors and events as separate types and is actually easy to understand
18:42:35 <mm_freak> AFRP is more more flexible and faster, but also more involved…  along with netwire 4 i'm writing a tutorial as part of the haddocks to remedy this
18:42:46 <zzing_> mm_freak, are you generally familiar with the product called "Processing"?
18:42:58 <edwardk> jfischoff: au :: Isomorphism o n -> ((o -> n) -> b -> n) -> b -> o; au (Isomorphism f g) h = g . h f  ?
18:42:59 <mm_freak> zzing_: nope
18:43:22 <edwardk> au sum foldMapOf [1,2,3,4]
18:43:46 <nh2> I asked earlier where I can find local haddocks. Found it in ~/.cabal/share/doc/index.html
18:43:55 <edwardk> assuming an isomorphism   sum :: Iso a b (Sum a) (Sum b)
18:44:09 <mekeor> nh2: thanks!
18:44:26 <zzing_> mm_freak,  "Processing is an open source programming language and environment for people who want to create images, animations, and interactions"   basically really easy to work with. I want to do something similar in haskell. For events, I am wondering if I could use FRP without hindering its usability for beginners
18:44:26 <edwardk> actually thats wrong
18:44:38 <edwardk> that assumes the wrong kind of isomorphism, it wants an Isomorphism, not an Iso
18:45:21 <mm_freak> zzing_: my suggestion is to wait for netwire 4…  events will be really easy to use
18:45:30 <zzing_> What is netwire4?
18:45:38 <mm_freak> an AFRP library
18:45:52 <zzing_> mm_freak, when do you expect it to land?
18:45:55 <mekeor> mm_freak: why don't you make netwire's source code publicly available, actually? or is it?
18:46:09 <jfischoff> edwardk: is it possible to make a function like that for the Isomorphic class?
18:46:14 <mm_freak> zzing_: today, maybe tomorrow
18:46:17 <edwardk> mm_freak: they changed it because its more powerful to be able to define things like type (+) = Either
18:46:22 <zzing_> mm_freak, that is really soon :P
18:46:28 <mm_freak> mekeor: i want to stabilize everything before doing that
18:46:33 <jfischoff> edwardk: I'm not even sure if it is that useful...
18:46:38 <zzing_> I better get my shader stuff done!
18:46:44 <mekeor> mm_freak: hm ok
18:46:59 <edwardk> jfischoff: well, you pass it something Isomorphic polymorphically and takes the choice of Isomorphism for k ;)
18:47:08 <mm_freak> edwardk: so symbolic type variables will be impossible?
18:47:16 <edwardk> mm_freak: yes
18:47:21 <edwardk> mm_freak: thats the tradeoff
18:47:26 <mm_freak> that's sad
18:47:29 <edwardk> locally your code switches style
18:47:39 <edwardk> i think its a net good, but its going to be a painful transition
18:47:44 <mm_freak> i don't even know what to call this (>~) =/
18:47:49 <edwardk> i use 'k'
18:47:57 <edwardk> maybe 'w' for wire?
18:48:01 <mm_freak> k reminds me too much of continuations
18:48:15 <mm_freak> no, the (>~) is the underlying category, not the wire category
18:48:27 <mm_freak> i guess i'll go with 'cat'
18:49:39 <mm_freak> i could also use a greek letter
18:51:28 <zzing_> mm_freak, write your entire library with greek letters
18:51:39 <mm_freak> i'll go with 'cat'
18:51:51 <mm_freak> a greek letter at that point wouldn't be a problem for library users
18:51:58 <zzing_> κατ
18:53:38 <zzing_> One thing that would be supercool is to be a researcher in 2100 reading the channel logs from today :-)
18:54:01 <guidj0s> You just need to travel to the future.
18:54:40 <mm_freak> accum :: (Reactive cat) => (b -> a -> b) -> b -> Wire e cat a b
18:54:44 <mm_freak> isn't that bad actually
18:54:51 <monochrom> we all travel to the future a bit
18:54:55 <mm_freak> also haddock has less problems with this
18:55:30 <mm_freak> zzing_: he would probably ask himself:  haskell was so cool…  why are we programming in C+=15?!
18:56:01 <zzing_> mm_freak, there would probably be a word for maintenance programmers :-)
18:56:02 <hpaste> M15k pasted “Linking Error Using HsLua on Windows” at http://hpaste.org/73090
18:56:04 <latro`a> erm
18:56:07 <latro`a> ++?
18:56:11 <latro`a> not +=?
18:56:12 * hackagebot unix-time 0.1.2 - Unix time parser/formatter and utilities (KazuYamamoto)
18:56:18 <Guest6383> why must i import Data.List in order to use fromIntegral, if it is already part of Prelude? isn't Prelude always imported?
18:56:21 <mm_freak> latro`a: that was intentional
18:56:25 <latro`a> oh
18:56:26 <latro`a> k
18:56:31 <mm_freak> latro`a: C++, C += 2, C += 3, …
18:56:38 <mm_freak> although C++ is not the same as C += 1
18:56:55 <latro`a> oh
18:56:57 <latro`a> ic
18:57:01 <latro`a> I had read a thing about C++11 today
18:57:04 <latro`a> so the thing confused me
18:57:22 <mekeor> c=1; c+=++c+c++; // result?
18:58:49 <Guest6383> nvm regarding that fromIntegral question
18:59:22 <zzing_> :t unsafeUseAsCString
18:59:23 <lambdabot> Not in scope: `unsafeUseAsCString'
18:59:36 <zzing_> :t ByteString.Encoding.unsafeUseAsCString
18:59:37 <itsamem15k> I have an error during linking with HsLua for Windows.  My error can be seen here: http://hpaste.org/73090
18:59:37 <lambdabot> Couldn't find qualified module.
18:59:46 <zzing_> :t Data.ByteString.Encoding.unsafeUseAsCString
18:59:47 <lambdabot> Couldn't find qualified module.
19:01:04 <zzing_> :t Data.ByteString.Unsafe.unsafeUseAsCString
19:01:06 <lambdabot> forall a. BSC.ByteString -> (Foreign.C.String.CString -> IO a) -> IO a
19:02:04 <zzing_> When I have a function such as   shaderSource :: GLuint -> T.Text -> EitherT Error IO ()     when I am running a 'do'   do I have to do something like liftIO on that unsafeUseAsCString?
19:03:09 <zmoazeni> Hey folks, I'm still rather new to type classes. Could someone take a look at this and tell me what boneheaded mistake I'm making?
19:03:12 <hpaste> zmoazeni pasted “New to typeclasses” at http://hpaste.org/73091
19:03:31 <zmoazeni> I'm trying to model type safe CSS Positions
19:04:03 <zzing_> zmoazeni, what line is line 60
19:04:12 <zmoazeni> the position line
19:04:19 <zmoazeni> data Position = Position...
19:04:56 <zzing_> What about   data Position a = Position (Horizontal a, Vertical a) | …
19:05:14 <zmoazeni> I gave that a shot too, and I get a "Not in scope" error
19:05:18 <zzing_> This is outside my main area of experience though, so just a guess
19:05:33 <zmoazeni> " Not in scope: type variable `a'"
19:05:54 <zmoazeni> I even tried "Horizontal h, Vertical v => Position (h, v)…." no dice
19:06:47 <zmoazeni> The only reason I went with a type class is so I could share the definition of Length
19:08:46 <zmoazeni> I might have figured out the secret sauce: http://stackoverflow.com/questions/1083508/type-classes-in-haskell-data-types
19:09:20 <mekeor> zmoazeni: http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
19:10:03 <zmoazeni> mekeor: Yeah, I (for the most part) get using typeclasses in function definitons
19:10:05 <zmoazeni> s
19:10:17 <zmoazeni> It's when I want to use a type class in a new data type definition that throws me
19:10:39 <hpaste> mekeor annotated “New to typeclasses” with “New to typeclasses (annotation)” at http://hpaste.org/73091#a73092
19:10:46 <mekeor> zmoazeni: did not test
19:11:20 <zmoazeni> I just typed that in myself. I think I need DatatypeContexts
19:11:46 <zmoazeni> Bummer: "Warning: -XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language"
19:12:12 <mekeor> yeah, you shouldn't use taht
19:12:18 <latro`a> mekeor: you need a parameter on the class declarations
19:12:20 <latro`a> I think
19:12:26 <latro`a> "class Horizontal h"
19:12:41 <latro`a> though this declarative, not-actually-providing-an-interface usage of typeclasses is kinda weird
19:12:52 <mekeor> latro`a: oh, yeah, that might be
19:12:52 <monochrom> you don't need data type contexts
19:13:22 <zmoazeni> latro`a  there a smarter way for me to group these types?
19:13:27 <zzing_> tekmo gave me some source code:    tryGL m = liftIO m <* checkError     but I don't know where to find liftIO, I think it is supposed to be in the EitherT but I still cannot find it.  The type of tryGL: tryGL :: IO r -> EitherT [Error] IO r    Any thoughts?
19:13:58 <latro`a> zmoazeni, depends
19:14:11 <latro`a> in a small case like this I'd just use one big type
19:14:30 <zmoazeni> latro`a: yeah I started that way, and thought there might be a safer route
19:14:30 <latro`a> data VerticalThing = P VerticalPoint | P' Length
19:14:33 <latro`a> or whatever
19:14:42 <latro`a> oh wait
19:14:45 <latro`a> zmoazeni,
19:14:49 <latro`a> I wasn't actually talking to you before
19:14:56 <latro`a> oh wait nvm
19:15:00 <latro`a> mekeor was annotating your thing
19:15:04 <parcs`> zzing_: Control.Monad.IO.Class
19:15:05 <latro`a> sorry, haven't been reading this whole conversation
19:15:18 <parcs`> from the 'transformers' package
19:15:26 <zzing_> oh that explains why I have it not
19:15:54 <zzing_> merci
19:18:38 <zzing_> ok, I have it, just no documentation for it
19:19:07 <boothead> Hi guys, could anyone tell me where liftIO might be imported from if transformers isn't available? I'm hacking on Fay and it's used in one file without an import to Control.Monad.IO.Class but I can't use it in my source file?
19:19:33 <zzing_> boothead, could be a reexport?
19:20:18 <boothead> yeah, I guess... is there any way to know where a function is re-exported from?
19:21:01 <zzing_> boothead, ghci import each one in turn and try it
19:21:14 <boothead> Control.Monad.IO is in the imports for the module in question
19:21:17 <kenshiro> I saw people saying 'custom monads' are better than monad transformers. But how come a 'custom monad' be diferent of a monad transformer(like ErrorT) if I need e.g. IO and error handling?
19:21:26 <boothead> ok zzing_ I'll try that
19:21:59 <c_wraith> kenshiro: the difference is the interface they provide, not how they work
19:23:00 <kenshiro> c_wraith, and so when should i prefer one or another?
19:24:02 <c_wraith> kenshiro: a transformer is better for more-or-less ad-hoc use.  A custom monad (possibly built with a transformer) is better when it has real semantic meaning and is an important part of your program
19:24:18 <zzing_> If I have cabal haddock run within an extracted package, is there a way to get the main index.html updated to include it?
19:24:54 <zzing_> hmm, nvm it put it in dist/doc/html/transformers/index.html  not the location i was thinking
19:26:34 <kenshiro> c_wraith, so you're saying a custom monad is worthy when is a particularity of my program?
19:27:15 <boothead> Control.Monad.Error seems to be the one - I'm still a bit confused that liftIO is available when transformers is a hidden package - but I guess the import commutes?
19:30:59 <zzing_> @src (<*)
19:30:59 <lambdabot> (<*) = liftA2 const
19:34:38 <zzing_> :t (<*)
19:34:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
19:37:49 <zzing_> Does anyone know how EitherT [Error] IO r   would work with (<*)?   I have a line  tryGL m = liftIO m <* checkError   but it does not compile properly.   It is expecitng `EitherT [Error] IO b0'   but it is an IO [Error]. I am thinking I need to change checkError to be a different type, but not entirely sure, the code does not originate with me.    ( http://hpaste.org/73071#a73072 )
19:39:10 <edwardk> hrmm, Control.Newtype.under is basically 'adjust' or 'mapOf' for a setter.
19:40:04 <edwardk> under _1 (+1) (1,2)   ==> (2,2)
19:40:32 <edwardk> over otoh needs an actual iso
19:40:51 <hpaste> teneen pasted “iterateM” at http://hpaste.org/73093
19:40:53 <teneen> My implementation of iterateM (in the hpaste) is not lazy enough. How can I make it work?
19:41:25 <edwardk> over = under . from
19:41:30 <Clint> zzing_: what's the type of checkError?
19:45:05 <overscore> is it possible to do something like   data Rating = 1 | 2 | 3 | 4 | 5 ?
19:45:27 <dmwit> data Rating = One | Two | Three | Four | Five; instance Num Rating where fromInteger 1 = One; etc.
19:45:27 <edwardk> data Rating = One | Two | Three | Four | Five deriving (Eq,Ord,Show,Read,Enum)
19:45:42 * dmwit high fives edwardk
19:45:47 <Veinor> edwardk: will 1 :: Rating be One or Two?
19:45:50 <edwardk> instance Num Rating where fromInteger = toEnum
19:45:58 <teneen> Can anybody explain why this http://hpaste.org/73093 iterateM is not lazy enough?
19:46:01 <edwardk> ah
19:46:04 <edwardk> then you'd need 0 there
19:46:06 <zzing_> Clint: checkError :: IO [Error]
19:46:08 <dmwit> toEnum . succ =)
19:46:13 <overscore> oh, :)
19:46:16 <edwardk> toEnum . … yeah dmwit wins
19:46:38 <zzing_> Clint, src: http://hpaste.org/73094
19:46:45 <edwardk> in practice its probably better to just use
19:46:48 <edwardk> type Rating = Int
19:46:51 <edwardk> and pass around those
19:47:07 <edwardk> unless you really need the invariants
19:47:16 <dmwit> teneen: eh... why isn't it just "l <- iterateM f fa"?
19:47:19 <ion> Or “newtype Rating = Rating Integer” for some additional type safety
19:47:23 <dmwit> Also, yes, I can explain why it isn't lazy enough.
19:47:24 <Clint> zzing_: and what are you trying to do?
19:47:28 <overscore> i'll go with the Int synonym then
19:47:39 <teneen> dmwit: both do not work
19:47:48 <ion> I.e. to avoid mixing number representations of different things with each other.
19:47:50 <dmwit> Yes, it is not lazy in the effects.
19:48:07 <dmwit> A more specific response will require you to say what you want to do.
19:48:11 <zzing_> Clint, the goal is to make it so I can do this:     vertex <- tryGL $ glCreateShader gl_VERTEX_SHADER    and it will check errors for me
19:48:35 <parcs`> zzing_: why are you using EitherT anyway? why not throw an exception, or complain to stderr when an error occurs?
19:48:38 <zzing_> Error checking is a different function that checkError iterates through
19:48:46 <teneen> dmwit: I just though about this function and was wondering how to implement it
19:49:04 <zzing_> parcs`, because tekmo suggest his Control.Error library
19:49:25 <teneen> dmwit: But I really can't see why it's not lazy
19:49:55 <dmwit> Try evaluating it by hand. =)
19:50:16 <overscore> also somethign i was wondering, is there a shortcut for   x <- blah; y <- bluh; foo x y.  for only one value you could do  foo =<< blah, but more than one?
19:50:40 <zzing_> It seems to me that how to control error handling to be a very opinionated topic
19:52:55 <teneen> dmwit: What I'm doing is equivalent to "fmap (fa:) undefined". Why is it not working? "fmap head . fmap (1:) $ undefined" works for example
19:52:57 <Clint> zzing_: so both glCreateShader and checkError generate IO actions?
19:53:10 <zzing_> Clint, yes
19:53:22 <zzing_> glCreateShader should be a IO (GLuint) or something like it
19:53:31 <Clint> perhaps you want to liftIO $ m <* checkError
19:53:35 <teneen> dmwit: errr Just undefined
19:54:03 <teneen> dmwit: fmap head $ fmap (1:) $ Just undefined
19:54:17 <dmwit> Because what you are doing is not equivalent to fmap (fa:) (Just undefined).
19:54:19 <zzing_> Clint, that appears to be it
19:54:35 <zzing_> I cannot believe how simple that was
19:55:34 <dmwit> (In particular: it's not obvious that the recursive call to iterateM will start off with a Just. Perhaps (indeed, it really does) it regresses infinitely before discovering that the constructor in front is Just.)
19:55:41 <dmwit> Like I said before: it is not lazy in the effects.
19:55:49 <dmwit> In the case of Maybe, the "effect" is success or failure.
19:56:03 <startling> ghci occasionally dies in m-x ansi-term; anyone else have this problem?
19:56:23 <zzing_> glGetError is peculiar in that every time you call it, it will pop off an error until it always gives you the gl_NO_ERROR
19:57:27 <teneen> dmwit: Is it possible to make it lazy in the effects?
19:57:42 <dmwit> nope
19:59:00 <Jesin> [22:52:36]	Clint	zzing_: so both glCreateShader and checkError generate IO actions?
19:59:07 <Jesin> that should be apparent in their type
19:59:17 <teneen> dmwit: But if it was implemented for a particular monad instance it might be possible? right?
19:59:23 <Jesin> if they are exported by anything
19:59:39 <dmwit> I suppose it depends on the monad.
19:59:41 <Jesin> and not just internal to the implementation of some library
19:59:46 <dmwit> It certainly doesn't seem possible for the Maybe monad.
19:59:55 <zzing_> So in EitherT   (<*)  will return the left on success, or the right on error?
19:59:59 <dmwit> (After all, how do you know f will return a Just every time?)
20:00:27 <teneen> dmwit: I see the point
20:00:39 <zzing_> Jesin, this is the creation of a library
20:02:08 <Jesin> ahk
20:06:47 <teneen> dmwit: it seems to work for the State monad
20:07:17 <dmwit> teneen: There is a lazy state monad whose effects are lazy, yes.
20:07:27 <dmwit> There is a strict state monad, too. It will not work for that one.
20:07:35 <dmwit> > 4400-3751
20:07:36 <lambdabot>   649
20:09:27 <teneen> dmwit: thanks for your help :)
20:12:15 <tgeeky> so many broken packages, so little time :(
20:15:32 <tgeeky> not having 'catch' breaks text
20:22:01 <startling> so why doesn't cereal have a thing that does (Get a -> ByteString -> Either Int a), where the Int is the position it failed at?
20:22:39 <startling> s'pretty painful to debug
20:25:41 <m3ga> how does one contact the haskell.org admins?
20:25:47 <tgeeky> m3ga: email
20:26:13 <m3ga> tgeeky: admin@haskell.org?
20:26:37 <tgeeky> m3ga: the e-mail address listed here: http://hackage.haskell.org/packages/accounts.html
20:27:19 <m3ga> tgeeky: thats for hackage.
20:27:30 <tgeeky> m3ga: oops! I read way too fast.
20:27:34 <m3ga> :-)
20:27:39 <startling> m3ga: you need to sacrifice a number of lepidopterans and bath in the blood while saying "morphism in the category of endomorphisms" three times fast
20:28:17 <startling> might also want to bind them to your bidding once they arrive
20:28:23 <edwardk> m3ga: describing how to learn category theory?
20:28:23 <startling> take this, you'll need it: (>>=
20:28:31 <edwardk> oh to contact the admins of haskell.org
20:28:39 <edwardk> there is a haskell-infrastructure mailing list
20:29:07 <edwardk> http://community.galois.com/mailman/listinfo/haskell-infrastructure
20:29:27 <m3ga> edwardk: thanks
20:29:31 <edwardk> if you want to know what is going on at the nitty-gritty level with servers, that is a pretty good list to subscribe to
20:30:14 <m3ga> i actually want to point out that mail.galois.com really should have working reverse DNS.
20:30:45 <edwardk> http://community.galois.com/pipermail/haskell-infrastructure/2012-August/000479.html for instance is the relevant post about the outage for hackage
20:32:04 <edwardk> startling: since the admins discovered comonads, they've learned they can 'extract' themselves from any binding, so that technique won't work any more. sorry.
20:32:22 <startling> >:(
20:33:08 <startling> you could probably counter that with return, though, no?
20:35:08 <startling> ah, I know, you could stick them in Reader.
20:35:36 <tgeeky> edwardk: I think you told me what to do last time ... when I see an error like this in ghci (where a type signature has a package name in it), what do I do again (in general?)
20:35:37 <tgeeky> Couldn't match expected type `time-1.4.0.1:Data.Time.Clock.UTC.UTCTime
20:36:26 <edwardk> probably have the wrong version of the package loaded relative to what the module you want to use in scope. is this in ghci?
20:36:29 <edwardk> oh you said it was
20:36:37 <tgeeky> well, i'm building shake in GHC 7.6.1
20:36:52 <edwardk> the combinator you are using comes from some package, that has a dep on a specific version of time
20:36:58 <edwardk> you probably have a newer version of time installed
20:37:02 <tgeeky> I am pretty sure the code in question is expecting stuff from the "old-time" module, and it's getting the stuff from the "time" module instead
20:37:04 <edwardk> hide it
20:37:17 <tgeeky> ok. I was going to go with package imports, but that seems better at first
20:37:25 <edwardk> the code inquestion looks like its expecting it from time 1.4.0.1
20:37:29 <edwardk> what versions do you have installed?
20:37:32 <tgeeky> that's it
20:37:43 <edwardk> thats the only version?
20:37:52 <tgeeky> time-1.4.0.1 and old-time-1.1.0.1
20:37:57 <tgeeky> edwardk: yep, I just wiped everything for ghc 7.6.1
20:38:12 <tgeeky> edwardk: the .cabal file lists both of these packages, but doesn't list a version for either
20:38:18 <edwardk> hiding old-time does that fix it?
20:39:19 <tgeeky> edwardk: nope, hiding either package doesn't work :(
20:39:25 <edwardk> hey if you have 7.6.1 installed can you check to see if polykinds is turned on for Control.Category?
20:39:34 <edwardk> otherwise i'll need to put in a frantic request before release
20:39:47 <tgeeky> edwardk: yep. one sec
20:40:42 <Veinor> what's in 7.6.1?
20:40:46 <tgeeky> edwardk: nope! just Trustworthy and CPP
20:40:51 <edwardk> tgeeky_: damn
20:41:01 <tgeeky> Veinor: kind poly is supported, among others
20:41:08 <tgeeky> Veinor: release notes in an XML link from reddit
20:41:15 <danharaj> The changelog example has a polykinded category class doesn't it?
20:41:27 <edwardk> better kind polymorphism support (it actually works), type operators changed so you can use type (+) = Either
20:41:35 <tgeeky> danharaj: the XML file does. The changelog included in the release just says "TODO" over and over
20:41:44 <tgeeky> edwardk: yes, beautiful :o
20:42:14 <tgeeky> I wonder if Haskell is the first "real world" language to have this kind of multilevel polymorphism
20:42:18 <tgeeky> value,type,and kind level
20:42:32 <danharaj> for certain values of "real world"
20:42:41 <tgeeky> I just used that to exclude Coq and Agda and the like
20:42:49 <tgeeky> which I assume have as much polymorphism as one's brain can handle
20:43:27 <roconnor> > 176*arctan(1/57) + 28*arctan(1/239) - 48*arctan(1/682) + 96*arctan(1/12943)
20:43:28 <lambdabot>   Not in scope: `arctan'Not in scope: `arctan'Not in scope: `arctan'Not in sc...
20:43:40 <beekor> haaay guys, i'm trying to get http://www.haskell.org/haskellwiki/Gtk2Hs/Demos/GtkGLext/terrain.hs to run, and i get Not in scope errors on the Gtk.Configure in:    Gtk.onConfigure canvas $ \ (Gtk.Configure _ _ _ w h) -> do     and i'm not sure what or where exactly Gtk.Configure is/shouldbe. any suggestions?
20:43:54 <roconnor> > 176*atan(1/57) + 28*atan(1/239) - 48*atan(1/682) + 96*atan(1/12943)
20:43:55 <lambdabot>   3.141592653589793
20:44:12 <mauke> > 355/113
20:44:13 <lambdabot>   3.1415929203539825
20:44:45 <tgeeky> roconnor: /me recently learned that the "feynman point" (a small string of 9s a few hundred digits in) is actually statistically significantly early :o
20:46:05 <roconnor> tgeeky: god said: let the 4th entry of the continued fraction squence for pi be 292
20:46:27 <roconnor> tgeeky: oh wait that is something else
20:46:34 <tgeeky> roconnor: hehe, yes :)
20:46:44 <tgeeky> roconnor: though I bet that is an abberation, too
20:47:14 <tgeeky> much smarter people than myself have proved various equidistribution characteristics of pi mod n
20:48:49 <zzing_> If I need to call a function that takes a Ptr GLint  (which is a CInt, which is an Int32), and the intention of the function is to give me data back, what is the best way to do that?
20:51:33 <zzing_> @hoogle Ptr a -> a
20:51:33 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
20:51:33 <lambdabot> Foreign.Ptr ptrToWordPtr :: Ptr a -> WordPtr
20:51:34 <lambdabot> Prelude id :: a -> a
20:51:41 <luite> zzing_: peek
20:52:39 <zzing_> glGetShaderiv :: GLuint -> GLenum -> Ptr GLint -> IO ()             peek :: Ptr a -> IO a
20:52:39 <monochrom> alloca (\p -> call_that_function p >> peek p)
20:53:17 <monochrom> alloca is in Foreign.Marshal.Alloc
20:54:16 <zzing_> I am reading it now
20:54:38 <zzing_> :t (>>)
20:54:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
20:54:55 <zzing_> Just have to work out types for a moment
20:55:14 <monochrom> (>>) is just de-sugared do. alloca (\p -> do { call_that_function p; peek p } )
20:55:50 <zzing_> I know what it does, I just want to go over it on paper
21:01:32 <zzing_> monochrom, this compiles, does it look right?      compileStatus (Shader shader) = alloca (\p -> glGetShaderiv shader gl_COMPILE_STATUS p >> peek p)
21:02:22 <tgeeky> edwardk: oh. ok. the package "directory"'s function 'getModificationTime' has changed from   :: FilePath -> IO ClockTime to  -> IO UTCTime  ... in the version that comes with GHC 7.6.1 (1.1.1.0)
21:02:36 <edwardk> ah
21:04:06 <edwardk> thinking i may want to rename 'au' to 'by', to get it to read better, by _sum foldMap [1,2,3,4]
21:04:31 <koninkje> what is au/by?
21:04:32 <tgeeky> almost any two character phrase is as good as any other :o
21:04:34 <zzing_> :t unsafeCoerce
21:04:35 <lambdabot> Not in scope: `unsafeCoerce'
21:04:40 <koninkje> How does it compare to ala?
21:05:07 <edwardk> ala takes Control.Newtype by is ala for an Iso from Control.Lens
21:05:15 * koninkje nods
21:05:26 <startling> in cereal, runGetState :: Get a -> ByteString -> Int -> Either String (a, ByteString) . what the hell is that Int?
21:05:29 <edwardk> au was be figuring au = a le ;)
21:05:34 <edwardk> we was me figuring
21:05:40 <edwardk> but it doesnt work the same linguistically
21:06:02 <edwardk> since a la is an idiom based on a longer contraction
21:06:09 <koninkje> what about auf?
21:06:13 <tgeeky> edwardk: I am pleased to see that you got your doctest config up and running!
21:06:18 <edwardk> =)
21:06:36 <edwardk> auf?
21:06:40 <zzing_> @hoogle Word32 -> Int32
21:06:41 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:06:41 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
21:06:41 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
21:06:42 <koninkje> http://en.wiktionary.org/wiki/auf
21:06:46 <edwardk> my french is really rusty
21:06:50 <startling> zzing_: fromIntegral
21:06:50 <zzing_> Can anyone suggest a way to convert a Word32 to an Int32?
21:06:55 <edwardk> ah german
21:06:56 <startling> zzing_: :)
21:06:56 <shirt> do you guys think that it's a bug in GHC that it doesn't give a deprecation warning when doing an import hiding of a deprecated function? People doing "import Prelude hiding (catch)" get no deprecation warning and are unprepared for the new base. and the docs for Control.Exception.catch even recommend importing Prelude this way!
21:06:58 <koninkje> That's good, cuz it's German ,)
21:07:17 <edwardk> thats not terrible
21:07:26 <edwardk> by may be a better choice though
21:07:39 <zzing_> :t alloca
21:07:41 <lambdabot> Not in scope: `alloca'
21:08:19 <edwardk> koninkje: taken a look at lens yet?
21:08:27 <koninkje> You'd probably want to flip the arguments for "auf": foldMap `auf` _sum
21:08:45 <koninkje> Not lately no.
21:08:54 <edwardk> koninkje: well, ala keeps them flipped the other way, so i'm kind of torn there
21:08:56 <koninkje> I've been following the blogs on lens families though
21:08:59 <edwardk> also you often want ala'
21:09:04 <edwardk> its a bit more than that ;)
21:09:13 <zzing_> :t fromIntegral
21:09:14 <lambdabot> forall a b. (Integral a, Num b) => a -> b
21:09:31 <edwardk> https://github.com/ekmett/lens/wiki/Derivation
21:09:37 <koninkje> Yeah, I think the ala ordering probably works petter programmatically; I was just saying re the linguistic pun...
21:09:39 <edwardk> motivates the new style of lenses i use
21:09:42 <edwardk> sure
21:09:53 <koninkje> er, "better"
21:10:49 <edwardk> basically taking the getter/setter approach from roconnor's polymorphic lens post and my lens family post and carrying it to its logical extreme
21:11:08 <zzing_> I wish openglraw didn't add on its own types
21:11:16 <edwardk> now you can program with isomorphisms, lenses, folds, traversals, kleisli actions, indexed versions of the same all using the same combinators
21:11:22 <ReinH> edwardk: you don't tweet very often.
21:11:27 <edwardk> ReinH: yeah
21:11:27 <koninkje> heh
21:11:44 <mapreduce> His type signatures don't fit in tweets.
21:12:01 <ReinH> they are too girthy?
21:12:03 <edwardk> mapreduce: sok, the function bodies all turn out to be 'id' anyways ;)
21:12:28 <zachk> edwardk: wgere us tgus>
21:12:31 <zachk> where is this?
21:12:47 <edwardk> zachk: the lens stuff?
21:12:50 <edwardk> github.com/ekmett/lens
21:12:59 <zachk> these super poly combinators... aight :D
21:13:04 <edwardk> there is a wiki with some extra contents about the derivation, etc.
21:13:20 <edwardk> lots of examples floating around in there too, including a full game of pong using gloss by nand
21:13:43 <zzing_> How can I import Data.Word.Word32   from haskell2010? ghci is not liking the import
21:13:49 <tgeeky> there could easily be several dozen examples
21:13:53 <edwardk> koninkje: i do like the fact that my entire api for working with text devolves to two combinators
21:14:13 <tgeeky> edwardk: are you going to be lensing-all-the-things in the future?
21:14:48 <edwardk> koninkje: one isomorphism from text to string: packed = iso pack unpack; then one traversal: text = from packed .> traverseList    -- (it could be from packed . traverse -- but this way its indexed)
21:14:48 <monochrom> import Data.Word(Word32)
21:15:25 <koninkje> nice.
21:15:34 <edwardk> koninkje: and with that you can use: anyOf text (=='c') $ "hello"^.packed
21:15:36 <edwardk> etc.
21:15:56 <edwardk> and anyOf, toListOf, mapMOf etc. all just work on text after that.
21:16:09 <edwardk> even though its a monomorphic container
21:17:30 <zzing_> I found this code for an Int32 -> Word32:    zzEncode32 x = fromIntegral ((x `shiftL` 1) `xor` (x `shiftR` 31))   and I use it   glIntToEnum (GLint (CInt x)) = GLenum (CUInt (zzEncode32 x))   to get what I need
21:17:50 <edwardk> tgeeky_: i've lensed pretty much base and the common stuff in the platform
21:18:03 <edwardk> adding lenses for Data.Monoid.* in 2.0.1
21:18:08 <edwardk> along with 'by'
21:18:10 <mm_freak> what's the space complexity of Data.Map?  O(n * log n)?
21:18:12 <edwardk> or whatever it gets called
21:18:31 <edwardk> mm_freak: every node has data in it. so O(n)
21:18:40 <dmwit> > 3600*0.81
21:18:41 <lambdabot>   2916.0
21:18:50 <mm_freak> edwardk: doesn't the tree itself also cost space?  i mean all the branches
21:19:25 <edwardk> Tips are empty, and there are at most 2x as many tips as bins, every bin has a value in it. so its O(n) =)
21:19:36 <mm_freak> ok, thanks =)
21:20:16 <edwardk> if they values all sat in the leaves then it'd be O(n log n)
21:20:28 <edwardk> er the
21:20:32 <zachk> edwardk: what ghc do I need to get this going? (your lens package on github)
21:20:41 <edwardk> zachk: 7.4.1 should work
21:20:53 <edwardk> it may work on the previous platform as well
21:20:57 <edwardk> but its less tested there
21:21:09 <tgeeky> does anyone know the name of the dates starting from jan-1-1970 , measured in seconds?
21:21:14 <tgeeky> or what the standard number is or something?
21:21:16 <edwardk> in 7.4.1 i have it running on travis and reporting to me on #haskell-lens every time i build
21:21:19 <latro`a> the unix epoch?
21:21:30 <startling> tgeeky: NormalizedTime or something
21:21:37 <startling> @hoogle NormalizedTime
21:21:38 <lambdabot> No results found
21:21:49 <startling> @hoogle Time
21:21:50 <lambdabot> System.Timeout module System.Timeout
21:21:50 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
21:21:51 <lambdabot> System.Event type TimeoutCallback = IO ()
21:21:56 <latro`a> tgeeky, I don't actually understand your question
21:22:11 <tgeeky> latro`a: is there an ISO standard for UNIX epoch time?
21:22:43 <latro`a> not sure, this runs into leap second issues
21:22:47 <latro`a> and so on
21:23:12 <latro`a> that is, the standard time for everything non-computing has leaps that the unix epoch time doesn't (to my knowledge)
21:23:29 <zzing_> What do I want to use for a generic length size?  Say my function is   infoLogLength :: Shader -> IO a    What do I want a to be or how should I constrain it
21:23:31 <tgeeky> latro`a: that's fine with me. I just want to compile. the new 'directory' package's "getModificationTime" returns a UTCTime (from 'time' package) instead of a TOD (from 'old-time' package)
21:23:38 <edwardk> koninkje: i could use au and auf for the versions that don't take and take a function argument, then i get the double pun ;)
21:24:09 <tgeeky> latro`a: the package "shake" uses, internally, a "newtype FileTime = FileTime Int" and just grabs the first paramter of old-time's TOD
21:24:24 <tgeeky> but it doesn't look like there's a correct way to do this, out of the box, with the new time package.
21:24:34 <latro`a> oh you want to convert from UTCTime to unix time
21:24:39 <tgeeky> (as you correctly argue, there wasn't a "correct" way to od this before)
21:24:42 <latro`a> I'm not sure that can actually be done in general
21:24:54 <latro`a> because the leaps are not perfectly regular
21:25:01 <latro`a> they're dependent on measurements
21:25:12 <tgeeky> all of this is specified in the time package
21:25:29 <tgeeky> latro`a: how do I destruct a UTCTime into an integer? :O
21:25:37 <latro`a> you can probably hack the internals
21:25:39 <tgeeky> into an Int, rather
21:25:50 <latro`a> lemme see if I can find the IO trickery it uses
21:26:10 <shirt> tgeeky: i just patched "cabal", which suffers from the same problem
21:27:08 <latro`a> looks like NominalDiffTime
21:27:16 <latro`a> will do what you want
21:27:26 <latro`a> potentially anyway
21:27:38 <shirt> tgeeky: try this: modTime <- getModificationTime path; let epoch = UTCTime (fromGregorian 1970 1 1) 0; let seconds = modTime `diffUTCTime` epoch; return (truncate seconds)
21:27:57 <latro`a> ah I see, build the UTC equivalent of the unix epoch
21:28:01 <latro`a> clever
21:28:02 <tgeeky> shirt: clever.
21:28:23 <tgeeky> shirt: we may need to get the maintainer of "time" to include this quickly, because otherwise lots of thigns are going to break in 7.6.1
21:28:41 <latro`a> that first let could just as easily be top level, by the way
21:28:53 <latro`a> which means that whole thing can actually be an fmap :p
21:29:46 <latro`a> fmap (\t -> truncate $ t `diffUTCTime` epoch)
21:30:33 <latro`a> oh wait
21:30:38 <latro`a> utcTimeToPOSIXSeconds
21:30:42 <latro`a> does that do what you want?
21:30:59 <tgeeky> latro`a: sigh. Thanks!
21:31:24 <koninkje> edwardk: :)
21:31:32 <latro`a> I'm not actually sure if that's exported
21:31:54 <edwardk> koninkje: going with au and auf, they are pretty
21:31:58 <latro`a> ah nvm, it's in Data.Time.Clock.POSIX
21:32:20 <tgeeky> latro`a: yeah. still need to get an Int out
21:32:37 <tgeeky> latro`a: that is exactly what I was asking. I should have been able to guess POSIX, with how often it's used to describe such things
21:32:41 <latro`a> to do what, exactly
21:33:01 <latro`a> POSIXTime is NominalDiffTime which seems to be Integer internally or something
21:33:15 <tgeeky> latro`a: in this case, "shake" uses the last modified date of a file as a stand-in for a hash of the file, to make it faster
21:33:17 <edwardk> half tempted to remove 'adjust' or rename it to 'under' to avoid conflict with adjust from Data.Map, etc.
21:33:48 <latro`a> if I can find where the Num instance is defined, that should show how the cast goes
21:33:51 <edwardk> but then the work i did avoiding ala for au/auf is kinda wasted for Control.Newtype
21:34:10 <latro`a> ah, there's a constructor
21:34:20 <latro`a> which....isn't exported?
21:34:23 <latro`a> apparently?
21:34:34 <edwardk> if i did that, then i can expose 'over' in Control.Lens.Iso
21:34:35 <latro`a> newtype NominalDiffTime = MkNominalDiffTime Pico
21:35:12 <latro`a> oh wait, dammit, I was looking at an old version
21:36:15 * koninkje wishes coqdoc was anywhere near as pretty as haddock
21:36:51 * koninkje also wishes Coq was anywhere near as pretty as Haskell.
21:37:15 <latro`a> yeah, tgeeky, the lack of an export of this constructor perplexes me
21:37:54 <tgeeky> latro`a: not everybody has Pico support
21:38:20 <latro`a> hmm
21:38:28 <JoeyA> :t toRational
21:38:29 <lambdabot> forall a. (Real a) => a -> Rational
21:38:41 <JoeyA> That's one way to read a (Nominal)DiffTime
21:38:42 <latro`a> owait....
21:38:48 <latro`a> *wait...
21:39:01 <latro`a> right, yeah
21:39:09 <JoeyA> It returns a Ratio Integer in seconds.
21:39:42 <tgeeky> JoeyA: I'm sure when I go to Neil with this, he'll be sad. Or maybe not. I'm not sure if Int is used because of performance, or just because of historical raisins
21:39:45 <latro`a> that's kinda counterintuitive, though the lack of universal Pico support is understandable
21:40:05 <JoeyA> tgeeky: Where is Int used?
21:40:21 <tgeeky> JoeyA: FileTime is a newtype wrapper around an Int
21:40:38 <tgeeky> JoeyA: evidently just changing that to a Rational works, though. lol.
21:40:49 <JoeyA> By the way, the system call for getting the time is around one microsecond.
21:41:02 <zzing_> If I have something like   allocaBytes logsize (\p -> glGetShaderInfoLog shader logsize nullPtr p >>    …    how do I get the CString  out of this? (p is going to be  a Ptr CChar)     I used peek with an integer, but this isn't the same.
21:41:04 <JoeyA> This pretty much dwarfs Integer overhead.
21:41:04 <tgeeky> JoeyA: do you mean, from the clock, or from a file?
21:41:09 <JoeyA> From the clock.
21:41:13 <tgeeky> JoeyA: this is always from a file
21:41:16 <zzing_> nvm, found it
21:41:25 <tgeeky> JoeyA: and he even cheats, too. I think he justs uses the number of seconds as an increment
21:41:47 <tgeeky> JoeyA: yes, that should make it even more irrelevant, unless he stores that in memory
21:42:51 <tgeeky> latro`a: shirt: thanks for the help. I got a compile! :O
21:43:55 <latro`a> woot
21:46:54 <callen> so what's the deal with the constant "blah blah package is likely to be broken by this" stuff I get from cabal?
21:47:52 <tgeeky> callen: newer cabals are more talkative when it comes to doing things that could break the world
21:48:02 <tgeeky> like reinstalls ("always dangerous")
21:48:36 <zzing_> @hoogle CInt -> Int
21:48:36 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
21:48:37 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
21:48:37 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
21:48:54 <callen> tgeeky: duly noted, thank you.
21:53:19 <zzing_> Any good functions to go from a CInt to an Int?
21:53:39 <dolio> fromIntegral?
21:55:17 <zzing_> dolio, tried that, it keeps giving me problems
21:55:51 <zzing_> hmm, I think it moved onto another error now
21:56:26 <dolio> It would be quite odd for it to generate errors.
21:57:13 <callen> does anyone here know of any Haskell Koans more comprehensive than https://github.com/roman/HaskellKoans/ ?
21:57:24 <callen> I love koans for learning and experimentation and was wondering if anybody knew of anything.
21:59:54 <startling> callen: not quite koans, but similar: http://www.haskell.org/haskellwiki/99_questions
22:00:31 <callen> startling: ooh, very similar.
22:00:42 <callen> startling: thank you very much.
22:01:23 <startling> no problem! that's where I got started
22:01:24 <callen> startling: also you've been very patient about helping me, if you're ever in the bay area let me know and I'll make certain you get some beer for your troubles!
22:02:11 <startling> thanks! :) I actually might end up around there sometime this winter
22:02:33 <callen> startling: well, I've been on freenode for ages, so just ping me.
22:02:38 <startling> callen: http://acm.wustl.edu/functional/hs-breads.php is similar, too, but it's more "examples to stare at" than "answer this question"
22:02:59 <callen> startling: ah indeed. I'm definitely the type to open a repl and tinker though.
22:03:09 <callen> startling: ex-lisper of sorts, I'm used to my programs being tangible "things"
22:03:41 <startling> understood. ghci seems to be one of the nicest repls out there, too
22:04:03 <callen> startling: uhm. it's one of the more thorough for a language default, but it's not what I would call the nicest.
22:04:10 <callen> startling: the nicest is the slime/shime family on Emacs.
22:04:21 <callen> startling: that experience is something rather more revelatory.
22:04:31 <startling> I never *got* slime
22:04:43 <callen> startling: the point of it?
22:04:44 <edwardk> mgsloan: awake?
22:04:53 <mgsloan> edwardk: yup
22:05:04 <edwardk> debating about that same under/over flip byorgey mentioned
22:05:14 <edwardk> i just added under/over to lens
22:05:18 <startling> callen: just never found it comfortable enough to be worth it for me
22:05:23 <startling> maybe I'll try shime
22:05:36 <callen> shime isn't quite as nice as slime proper, but it's in the same realm.
22:05:43 <callen> startling: you have to be a comfortable Emacs user.
22:05:58 <edwardk> the idea is that adjust then becomes under (or over in byorgeys flipped naming)   and the other works over an isomorphism
22:06:05 <callen> startling: if you don't come from the Emacs / Zmacs pedigree, it's hard to grasp why it's worthwhile.
22:06:19 <callen> startling: it's a programming style that is profoundly iterative and generally informal as well.
22:06:21 <edwardk> over _1 (+1) (1,2) ==> (2,2) isn't bad
22:06:44 <startling> callen: I use emacs as a better vim. could be that
22:06:48 <edwardk> of course, i just flipped everything to 'under', so changing it all to over now is kinda silly
22:06:58 <edwardk> but it probably would be for the best
22:07:03 <callen> startling: that would do it. I generally embraced the programmability of Emacs and made it "mine"
22:07:08 <edwardk> waffling ;)
22:07:15 <callen> startling: discovering Slime was...a good point in my life.
22:08:16 <startling> callen: could be because I ditched scheme after sicp, too
22:08:32 <callen> startling: schemers are less likely to use Slime anyway.
22:08:39 <startling> huh.
22:08:40 <callen> startling: it's more of a Common Lisp thing.
22:08:45 <startling> yeah, never learned common lisp really
22:08:54 <edwardk> over (at 12.mapped) (+1) i guess works
22:08:54 <callen> I mean, you can definitely use most schemes in Slime, but it's culturally not the norm.
22:09:14 <callen> startling: schemers and lispers are very much more different than people realize.
22:09:56 <mgsloan> edwardk: so you're using under to mean within the data structure? :D  Or using the Control.Newtype?  I can see reasonable argument sfor each
22:10:30 <edwardk> well, i swapped from adjust to under. now i'm thinking about swapping to 'over'
22:11:07 <jfischoff> edwardk: is there some more eloquent way, perhaps using filtered to write >  filter ((=3) . view l ) xs. I guess I'm struggling yo understand when I would want to use many of the combinators :(.
22:11:16 <jfischoff> hmm underline ….
22:11:57 <edwardk> hrmm, filtered is useful mostly when you want to take an existing fold and drop some of the elements
22:12:38 <edwardk> check filtered (==3) l
22:13:00 <edwardk> since a getter can be used as a fold
22:13:15 <edwardk> that gives you a fold that just returns the elements == 3 ;)
22:13:51 <startling> callen: apparently so!
22:13:54 <edwardk> toListOf (filtered (==3) l) [1,2,3,4]
22:14:08 <edwardk> where i guess l would be traverse
22:14:28 <edwardk> toListOf (filtered (==3) folded) [1,2,3,4]     should give [3]
22:15:48 <jfischoff> One thing I struggle with is, I look at that and think "why not filter (==3)?"
22:16:45 <jfischoff> I'm having an trouble imagining how to use them, even playing with them in ghci is pretty straight forward.
22:17:02 * jfischoff feels like he is missing something
22:17:14 <edwardk> sure
22:17:40 <edwardk> you can pretty much always just build a fold using folding and then do the filter, reverse, etc. there
22:18:01 <edwardk> but when you build it by composing other folds and getters into it, it may be more idiomatic to use filtered, etc.
22:18:30 <jfischoff> I assume so, it is the idiomatic cases I am looking for
22:19:04 <edwardk> toListOf (_2.filtered (<3) (folded.folded)) ((),[[1,2,3,4],[5,6,7]])
22:19:13 <edwardk> there i'm using nested folds
22:19:27 <startling> callen: shime does seem to be better than m-x ansi-term at least
22:19:34 * jfischoff is playing in ghci
22:21:29 <mgsloan> edwardk: it would be good to maintain consistency with Control.Newtype, but is it used enough to justify having somewhat less intuitive naming?  I probably just hadn't used Control.Newtype enough, but for a while every new usage would definitely require checking the types of under / over.
22:21:43 <edwardk> i think i'm going to flip them
22:22:17 <edwardk> "A foolish consistency is the hobgoblin of little minds"
22:22:24 <edwardk> or something equally demeaning ;)
22:25:04 <dmwit> That quote leaves a little something to be desired.
22:25:35 <dmwit> I mean, it just pushes the burden onto the word "foolish", really.
22:25:35 <mgsloan> edwardk: awesome :D  agreed!
22:25:50 <edwardk> dmwit: sure, its a dickish quote
22:26:18 <edwardk> but its a great way to justify doing whatever you want ;)
22:26:54 <dmwit> =)
22:29:06 <djahandarie> If there are suggestions to make Control.Newtype more intuitive I'm open ears
22:29:36 <edwardk> mostly it comes down to swapping over/under
22:29:45 <djahandarie> The names?
22:29:49 <edwardk> yeah
22:30:30 <edwardk> i went with au and auf for the ala and ala' clones using isomorphisms
22:30:37 <mgsloan> Yeah, it's a bit of a gnarly change as far as API compatibility goes :/
22:30:41 <edwardk> yeah
22:31:39 <mgsloan> edwardk: It doesn't really make sense to upgrade code that targets Control.Newtype to lens, though, right?
22:31:49 <mgsloan> (not upgrade)
22:31:54 <djahandarie> I do see how the other naming makes more sense
22:31:54 <edwardk> well, yes and no
22:32:13 <edwardk> Control.Newtype only provides newtypes, the lens over/under work with any isomorphism
22:32:15 <mgsloan> but under / over aren't related to Newtype now, right?
22:32:25 <mgsloan> right
22:32:57 <edwardk> au _sum and ala Sum do basically the same thing, except au can use chains of isos
22:33:03 <mgsloan> djahandarie: yeah, I can see how "over" could make more sense from a mathematical perspective, but once you have both under and over, it isn't very intuitive
22:33:34 <djahandarie> Blame math? I can go with that.
22:34:29 <edwardk> oh, and i guess the other difference is that over in lens now can work over any setter
22:34:46 <edwardk> so over (_2.mapped._4)  etc
22:34:59 <edwardk> basically you can work over functors, etc.
22:35:22 <edwardk> l +~ n = over l (+ n)
22:36:08 <djahandarie> All the combinators in this lens library are starting to make things more confusing than my xmonad config file
22:36:17 <edwardk> djahandarie: =)
22:36:35 <JoeyA> This took me way too long to realize: to give a network connection an STM interface, don't bother with intermediate channels.  Instead, have {nextMessageToSend :: STM Message, onReceive :: Message -> STM ()}
22:36:41 <djahandarie> Though, at least it's not Unicode.
22:36:45 <edwardk> there is an internal consistency to them… of course that is the hobgoblin of my little mind ;)
22:37:42 <JoeyA> Then the connection manager calls nextMessageToSend repeatedly for each message.
22:37:44 <edwardk> djahandarie: my goal is primarily to establish a decent vocabulary for working with these things, and a useful language has lots of words ;)
22:37:59 <Veinor> so wait, Arrow (~>) => a -> b breaks in GHC 7.6.1?
22:38:05 <edwardk> Veinor: yes
22:38:20 <Veinor> that's... unfortunate :/
22:38:28 <edwardk> Veinor: but you can make operators that don't start with : now!
22:38:32 <Veinor> true
22:38:43 <edwardk> thats a _huge_ win for type operator use
22:38:46 <Veinor> i wish there was some way to have both
22:38:52 <djahandarie> Languages also need a lot of usage to be learned properly (though I guess it's only a lexicon in this case, plus some fixity rules)
22:38:58 <edwardk> its better for library users and slightly harder for library writers
22:39:22 <djahandarie> For me personally, I still pull up a documentation page even when I'm using Data.Map or whatever generic core module you can think of
22:39:25 <edwardk> djahandarie: thats why i focus mostly on the core of the hierarchy and vocabulary in the diagram
22:39:35 <edwardk> rather than show it all
22:40:07 <JoeyA> So what does the Arrow (~>) constraint mean?  How is (~>) even a type?
22:40:09 <edwardk> once you know (^.) and (.~), from and withIndex you can basically do anything with anything.
22:40:23 <edwardk> JoeyA: he's making an Arrow k => k a b
22:40:32 <edwardk> its just a variable that happens to be infix
22:40:42 <JoeyA> oh
22:40:50 <edwardk> that used to work
22:40:53 <JoeyA> So that should read Arrow (~>) => a ~> b
22:40:53 <edwardk> and is being taken away
22:40:57 <edwardk> yes
22:41:19 <edwardk> i think its a net good, but its a point of pain for anyone who uses arrows in anger
22:42:07 <edwardk> e.g. i can add type a <-> b = forall k. Isomorphic k => k a b  -- to Control.Lens
22:42:15 <edwardk> where i couldn't before
22:42:20 <edwardk> it had to have a : on front
22:42:27 <JoeyA> ah
22:42:36 <edwardk> which made it like :-> or :<->: or :<-> or something equally wrong
22:42:47 <JoeyA> So all type operators are "capital" now?
22:42:49 <edwardk> yep
22:43:48 <kanedank> I'm having trouble understanding this line:
22:43:49 <kanedank> dropWhileEnd p = foldr (\x xs -> if p x && null xs then [] else x : xs) []
22:44:03 <kanedank> what does the \x at the beginning mean?
22:44:08 <edwardk> some of these combinators in lens are admittedly a little silly
22:44:12 <edwardk> under = over . from ;)
22:44:18 <mauke> kanedank: what source are you learning haskell from?
22:45:34 <kanedank> I have a copy of real world haskell and I'm looking at http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html
22:45:46 <mauke> @where rwh
22:45:47 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:46:22 <kanedank> so just keep reading rwh and come back?
22:46:27 <edwardk> kanedank: \ x y z ->    is making an anonymous function that takes 3 arguments named x y and z. The \ stands for lambda.
22:46:40 <edwardk> > (\x -> x + 1) 10
22:46:41 <lambdabot>   11
22:46:44 <kanedank> ah, okay
22:47:07 <edwardk> > (\a b -> a) 10
22:47:09 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
22:47:09 <lambdabot>    arising from a use of ...
22:47:17 <edwardk> > (\a b -> a) 10 20
22:47:18 <lambdabot>   10
22:47:38 <mauke> kanedank: http://book.realworldhaskell.org/read/functional-programming.html#fp.anonymous
22:47:38 <edwardk> @src const
22:47:39 <lambdabot> const x _ = x
22:47:45 <edwardk> > const 10 20
22:47:46 <lambdabot>   10
22:48:57 <mgsloan> edwardk: well, the "over . from" only reads weird because from is so overloaded.  You could always specialize it to flipIso :: Iso a b c d -> Iso c d a b
22:49:05 <edwardk> sure
22:49:20 <edwardk> i'm actually okay with how it reads, just find it funny =)
22:49:39 <edwardk> the prepositions are a nice way to build vocabulary here
22:50:41 <edwardk> i mean i already have after and meanwhile in Control.Parallel.Strategies.Lens ;)
22:51:21 <edwardk> after rdeepseq traverse ...
22:58:03 <ReinH> edwardk: can you explain the logic behind the naming of for vs. traverse (forM vs. mapM)?
22:58:07 <ReinH> it reads funny
22:58:31 <edwardk> ReinH: for [1,2,3,4] $ \x -> do stuff
22:58:51 <ReinH> hmm
22:58:51 <edwardk> is often a lot nicer to write than mapM (……huge block of code….) [1,2,3,4]
22:59:07 <ReinH> I was thinking infix
22:59:21 <ReinH> doStuff `for` list -- would make sense as well
22:59:32 <ReinH> but now I get it
22:59:45 <edwardk> yes, but think of it in the context of other languages with for/for each loops
22:59:48 <edwardk> and the naming makes sense
22:59:49 <ReinH> yep totes
22:59:52 <ReinH> thanks
23:00:06 <ReinH> although for x in xs is a terrible idiom in most langauges that provide it
23:00:11 <ReinH> ;)
23:00:24 <edwardk> heh, its better than the off by one soup you get otherwise =P
23:00:56 <ReinH> I greaty prefer Ruby's #each to Python's for x in xs
23:01:15 <ReinH> it doesn't help, however, that Ruby's version of for x in xs is broken
23:06:07 <ReinH> although to be fair, python's for x in xs is an actual list comprehension
23:14:18 <latro`a> erm
23:14:21 <latro`a> not for an iterator
23:14:25 <latro`a> eh
23:14:34 <latro`a> "generator comprehension" is the term they use iirc
23:14:39 <latro`a> so fair enough
23:18:02 <startling> generator expression
23:18:08 <startling> list comprehension
23:18:44 <startling> I like that python lets you omit the parens for a genexp if there are already parens, though
23:19:14 <startling> max(i for i in something if whatever
23:19:15 <startling> )
23:31:21 <avpx> I dislike that in Python the end of an iterator is signified by the StopIteration exception.
23:31:44 <NemesisD> i keep getting an error that theres no instane for IsString ByteString in a file but i'm doing import Data.ByteString (ByteString)
23:33:07 <avpx> Hmm, I wonder where that instance is.
23:33:08 <latro`a> avpx
23:33:23 <avpx> latro`a
23:33:27 <latro`a> you may be amused by this
23:33:28 <latro`a> https://github.com/wisp558/promptool/blob/master/helper.py
23:33:36 <NemesisD> i can't see anywhere else it would be
23:33:38 <latro`a> (scroll down to the try block)
23:33:47 <avpx> Oh wow.
23:34:13 <JoeyA> NemesisD: import Data.ByteString.Char8 ()
23:34:15 <latro`a> this is why StopIteration is bad, lol
23:34:31 <avpx> latro`a: See, and in Java there would be a function that asks if there is another element
23:34:34 <NemesisD> oh. i don't remember ever having to do that before
23:34:38 <avpx> But nooo, Python has to throw an exception
23:34:41 <latro`a> yup
23:34:53 <latro`a> and ofc haskell has pattern matching
23:35:16 <latro`a> if you do a thing different with (x:y:xs) than [x], you say so
23:35:17 <JoeyA> NemesisD: That's orphan instances for you.
23:35:49 <avpx> Hah.
23:49:12 <zzing_> Is there a reason why I can have a module named "Processing.Shader" but I cannot have a module named "Processing.Error"?  Both files are in a "Processing" directory, and Shader uses Error
23:51:06 <JoeyA> zzing_: I'm pretty sure you can do that.  What error are you getting?
23:51:23 <zzing_> File name does not match module name:
23:51:31 <zzing_> Saw: `Processing.Error   Expected: `Error'
23:52:49 <zhulikas> name your module after your file
23:53:21 <solrize> zzzz
23:53:27 <zzing_> zhulikas, I have Processing.Shader   in ./Processing/Shader.hs
23:53:45 <zhulikas> what about Error?
23:54:21 <zhulikas> it should be in .Processing/Error.hs and named as Error, not Processing.Error
23:54:29 <zhulikas> according to error above
23:54:37 <zzing_> Is it in the same location as Shader.hs
23:54:58 <efie> "cabal install gloss" worked for me, but when I try "cabal install gloss-examples" I get the following error: http://hpaste.org/73095 Does anyone know how to fix this base-dependency-error?
23:57:15 <startling> efie, upgrade ghc
23:57:19 <startling> efie: base comes with ghc
23:59:38 <efie> startling: thanks; what is the best way to upgrade it? I think I installed it by installing the Haskell Platform, is there a simple way to upgrade it? a command or such?
