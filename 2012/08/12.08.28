00:00:31 <johnw> edwardk: are you a mathematician?
00:00:40 <edwardk> johnw: sorta? =)
00:00:46 <LordBrain> I surmise then that extract, generally speaking is the comonad analog to return
00:00:56 <johnw> I feel like if I ever truly understood http://comonad.com/reader/2011/monads-from-comonads/, my head would burst into flames
00:01:12 <johnw> LordBrain: yes
00:01:16 <johnw> extract = coreturn
00:01:21 <johnw> extend = cobind
00:01:31 <johnw> johnw = coedwardk
00:01:36 <LordBrain> lol
00:01:53 <edwardk> i have masters' in math and cs, and a pretty odd background beyond.
00:02:22 <johnw> i would love to master all this stuff, it'll just take time and hard work
00:02:39 <vaflis> that kind of increases my confidence as I have none so I no longer feel so bad when I compare what you do with Haskell with what I do with it
00:02:53 <johnw> i also keep finding that most of this stuff is not nearly as complicated as it appears
00:02:55 <edwardk> i learned comonads because they intrigued me, and they were so underutilized it struck me as odd
00:03:27 <johnw> yes, it's like memristers
00:03:28 <Enigmagic> johnw: turns out most of it isn't that complicated, just that the documentation is always intended for someone else.
00:03:36 <umer> Any lambda installation experts there?
00:03:36 <johnw> it's a hole in the completeness of the picture
00:03:43 <umer> lambdabot installation experts*
00:03:55 <johnw> umer: i would love to find one too
00:04:06 <johnw> still can't get lambdabot to give me a prompt
00:04:16 <edwardk> vaflis: i did a lot of odd stuff before i found haskell. licensed technology to game companies, was cto for a nationwide dsl provider, worked on a holographic 3d display system, etc.
00:04:32 <vaflis> shit.
00:04:40 <edwardk> vaflis: and back then i didn't have a formal education =P
00:04:46 <vaflis> :D
00:04:48 <vaflis> how old are you?
00:04:49 <johnw> I would like two interactive buffers in my Emacs: a ghci with only the imports of my current module loaded; and a lambdabot with fixed set of imports for questions I like to ask
00:04:49 <umer> johnw: I wish it was simple to get it up. I've tried in both in arch and ubuntu but I keep running into weird issues.
00:04:52 <edwardk> 37
00:04:58 <vaflis> I have a very unhealthy habit of comparing myself with others
00:05:04 <vaflis> to see where I stand in life
00:05:05 <johnw> edwardk: we are very close in age
00:06:29 <johnw> "I wish it was simple to get it up".  Avoid that sentence in American English if you can.
00:06:31 <edwardk> i think the closest thing to a bio i have online is a blurb i wrote at linguist list: http://linguistlist.org/people/edward.html
00:06:39 <zhulikas> johnw, :))
00:07:03 <edwardk> of course that leaves of all the preacademc stuff
00:07:25 <shachaf> edwardk: Oh no, you're a linguist? :-(
00:07:31 <zhulikas> what the hell...
00:07:41 <zhulikas> "I recently decided to go back to college when I realized that having all of the certifications and work experience in the world wasn't going to do me any good unless I had a decent formal education."
00:07:47 <edwardk> shachaf: i took their money, and worked on grants, there is a difference. ;)
00:08:07 <zhulikas> how the hell work experience doesn't help you and formal education does?
00:08:11 <edwardk> zhulikas: i'd been a CTO for several years when the dot-com crash hit.
00:08:25 <edwardk> who hires a CTO without a formal education in that market?
00:08:55 <zhulikas> isn't the thing that you already were a CTO kind of proves your competences?
00:08:59 <augur> edwardk: do you know anything about institutions
00:09:02 <edwardk> nobody wants someone for an entry level job who has had millions of dollars before, they don't believe they'll stay. nobody wants them for an executive level position either.
00:09:07 <Enigmagic> yahoo doesn't do background checks on their execs
00:09:15 <Enigmagic> well, maybe they do now
00:09:33 <edwardk> zhulikas: honestly, i got a _lot_ out of going back and doing the degrees
00:09:49 <pharaun> sounds like it :)
00:09:50 <zhulikas> also you did like 10 degrees in 3 years
00:09:55 <edwardk> i look back at what i knew then and while i knew a lot about a lot of different things, my interests were surprisingly narrow
00:09:58 <edwardk> hahaha
00:09:59 <edwardk> true
00:10:26 <pharaun> i've been debating about going to school or just sucking it up and picking up some heavy duty theory/cs books and have a go at it
00:10:36 <edwardk> i mean i knew the way computers worked physically really well, but i knew surprisingly little real computer science
00:10:52 <johnw> edwardk: that's the boat I'm in
00:10:54 <pharaun> i'm kind of in the same boat
00:11:12 <edwardk> and i knew a lot about how to abuse calculus, linear algebra and geometry for graphics, but i knew very little about real mathematics
00:11:19 <johnw> i'm processor wise, theory foolish
00:11:30 <zhulikas> what do you mean by "real computer science"
00:11:30 <zhulikas> ?
00:11:32 <pharaun> graphics can be a blast :)
00:12:55 <edwardk> i mean i was very good at adapting what algorithms i knew to new situations, but i didn't know most data structures that didn't apply to graphics, for instance, had no real knowledge of how automata work, no idea about complexity theory beyond P=?NP, etc.
00:13:03 <nand`> algorithm design scares me, I think I'd rather be in the language design boat
00:13:26 <zhulikas> I see...
00:13:52 <nand`> and by algorithm design I mean I can always come up with fairly trivial or straightforward solutions that are slow; but never have the thinking power needed to come up with fast ones
00:14:25 <edwardk> i had been trying to design a programming language for about 15 years at that point, and had converge on liking pure functions (things that behaved like static functions in c where you could know you could move it around at compile time!), but i hadn't had any inkling that functional languages even really existed. i mean i'd written some lisp 10 years prior for something once and forgotten about it
00:14:26 <nand`> in my mind it's like ‘it's a solved problem, who cares how efficient it is?’
00:14:57 <edwardk> so going through the material formally was very good at straightening me out.
00:15:14 <edwardk> and then i discovered haskell
00:15:17 <nand`> edwardk: I've been interested in language design pretty much since I was very young; I've ‘designed’ probably over half a dozen or so languages by now of different flavors, mostly out of interest; none of them for serious use
00:15:21 <johnw> you must have fallen in love
00:15:23 <pharaun> i think i just need to pick up a good text book or two and just hit the books and study
00:15:33 <edwardk> johnw: it was like a religious coversion ;)
00:15:35 <LordBrain> nand`, what background are you coming from?
00:15:38 <johnw> i bet!
00:15:41 <johnw> how excellent
00:15:45 <nand`> LordBrain: what do you mean by ‘background’?
00:15:51 <zhulikas> pharaun, good luck with that :D like that ever works!
00:15:53 <LordBrain> what major perhaps
00:15:58 <johnw> for me the revelation was nothing immediate
00:15:59 <edwardk> johnw: all of a sudden there was a language that had better answers than i did and had all these neat tools i could use
00:16:06 <LordBrain> i'm trying to get an idea of what perspective you are looking
00:16:07 <pharaun> zhulikas: i'm probably not be able to make any time soon for going back to school really
00:16:14 <nand`> none; I don't have any education at the moment though I'm in the process of completing an Abitur
00:16:27 <edwardk> and most importantly for me, it was a language that encouraged you to just implement the _right_ thing once, and let laziness fuse it all together.
00:16:28 <LordBrain> what is an abitur?
00:16:30 <pharaun> zhulikas: and i've been feeling out of my element a bit in here and been wanting to increase my formal education in CS theory/harder theory
00:16:44 <edwardk> with strict languages there is always that need to go rewrite everything to merge another pass
00:16:57 <C-Keen> LordBrain: the exam you need to pass in germany's highschool to get admitted to university
00:16:58 <zhulikas> I am considering extending my studies for a couple more years instead of working in the industry, but am not entirely sure I will be motivated enough to efficiently use all the study time
00:17:03 <nand`> LordBrain: not sure how to describe or explain it in non-german terms but it's what you get after you finish 13th grade in the german Gymnasium (5-13)
00:17:31 <LordBrain> i thought there might be something in your background to explain the bias you professed to
00:17:45 <nand`> no, I don't think there is
00:17:48 <johnw> I _love_ programming in Lisp, and have been using C/C++ longer than I'd wished, and also about 20+ other languages off and on.  I came to Haskell because it seemed this is where some real thinking was going on, and also it has been showing itself capable of adapting to the new architectures more naturally (multicore, distributed, etc)
00:17:51 <zhulikas> we have abitur too (Lithuania)
00:18:07 <edwardk> anyways, in college i'd thought formal methods were things like hoare logic/separation logic. finding that they didn't suck nearly so much once you rendered the world immutable was like a bolt of lightning
00:18:57 <edwardk> so i went off and obsessed about substructural logic and pure type systems, etc. before i finally settled down and decided haskell was the place for me
00:19:09 <zhulikas> :)
00:19:17 <edwardk> the power to weight ratio is too good here to give up
00:19:25 <LordBrain> i think we have equivalents here... gre for grad school... um... not sure for undergrad i guess the sat
00:19:46 <LordBrain> sat is usually taken earlier than that tho
00:19:47 <zhulikas> yea, gre is similar
00:20:04 <zhulikas> and easier than abitur in some countries :P
00:20:06 <pharaun> edwardk: would i be able to pick up on some of the advanced stuff in haskell despite a lack of formal education?
00:20:13 <pharaun> i've been really enjoying the language so far
00:20:15 <edwardk> pharaun: definitely
00:20:26 <nand`> edwardk: agreed, Haskell has a large power to weight ratio that offsets some of its ‘drawbacks’ - it's more ‘this is the real world, let's get things done’ oriented than some of the languages with more powerful type systems or purity/safety out there
00:20:35 <nand`> pharaun: yes
00:20:35 <edwardk> i'll say this. my college didn't even acknowledge haskell or category theory existed ;)
00:20:39 <zhulikas> In my experience it's possible to understand any concept in Haskell if you look at it long enough
00:20:50 <pharaun> good to know :)
00:20:54 <paolino> hello, I have two StorableArray of same length. How can I zip them in new one so it has double length and interleaved elements? Not sure interleaved is the right word
00:20:59 <nand`> pharaun: if you're interested enough in something and more or less capable, you don't need any education - you can pick it all up
00:21:00 <edwardk> so not everything is about formal education. it helps, but a lot of it is smashing your head against it over and over.
00:21:33 <pharaun> edwardk: i find having a project to work on and something tangable/code-like tends to help me big time with smashing my head into
00:21:39 <nand`> I don't see the importance of formal education either; I mainly see it to teach me those things that I'm not interested enough in to explore myself
00:21:44 <nand`> sorry, that came out wrong
00:21:50 <nand`> I don't mean to say formal education is useless
00:22:02 <LordBrain> i think category theory is going to explode when the functional paradigm becomes dominant in software engineering
00:22:02 <pharaun> I just feel like i am lacking/bit of a fraud from the lack of formal education, i only have a BS :p
00:22:17 <nand`> LordBrain: honestly, I'm not too sure about that
00:22:19 <zhulikas> should one pursue formal education when has a chance or when has a motivation for it? IF right now I think work experience is more valuable for me but in a couple of years I'd realise that  formal education is what I really need, is it ok to study later or should I try to focus right now when I have a proper chance for it?
00:22:34 <LordBrain> by explode, i mean no university is going to pretend it's not there
00:22:34 <nand`> I feel like category theory is more interesting for the language implementors/designers rather than the users
00:22:38 <nand`> oh
00:22:40 <edwardk> pharaun: yeah. i used to. nowadays i basically use a project as a jumping off point. i need this, but i need this to build that, and there is this other subproject i could use…. ok fine, let me build the 'right' version of this tiny subproblem 3levels removed from my goal, and work my way back up
00:22:47 <LordBrain> not necessarily that everyone will know it or something
00:22:55 <edwardk> maybe in the end i don't bother finishing the top level project, but i have more libraries for the next one
00:23:05 <startling> nand`: language implementation/design is much more interesting for the language implementors/designers rather than the users
00:23:10 <pharaun> edwardk: sweet :)
00:23:33 <pharaun> edwardk: glad to hear that there's some viability in that approach, its what seems to work for me
00:23:42 <startling> edwardk: so yak shaving works?
00:23:50 <startling> work by mathematical induction?
00:24:08 <edwardk> https://github.com/ekmett/ pretty much documents my wanderings over the last ~ 2 years. that was when i moved to github, at the time i had ~13 repos
00:24:10 <Enigmagic> 20 years of yak shaving can't be wrong.
00:24:14 <nand`> edwardk: just make sure you don't recurse yourself into mutually dependent sublibraries
00:24:30 <edwardk> nand`: thats when you split out the common core.
00:24:46 <nand`> ah, you have analyzers to detect these sort of situations?
00:24:48 <edwardk> fortunately its well founded. no sense committing a package with zero lines, so eventually it terminates
00:25:42 <edwardk> nah, before haskell i mostly just started random companies, and sold off my old technology before i got too bored with it
00:25:54 <edwardk> now i just post it to github
00:26:11 <nand`> you say starting companies like it's a casual thing
00:26:23 <edwardk> erm, it is
00:26:39 <nand`> (disclaimer: I've never started a company, but I thought this kind of thing would be more involved)
00:26:39 <pharaun> it can be :)
00:26:58 <Enigmagic> nand`: it only takes a little bit of cash and filling out some paperwork
00:27:26 <edwardk> i've had a video store, an isp, a phone company, licensed tech to game companies, used to sell a java cryptography engine, sold a distributed column store, and done a whole bunch of other little startups like that that i forget at the moment ;)
00:27:40 <augur> edwardk: :(
00:27:42 <monadd> how old are you and when did you start
00:27:43 <mm_freak> nand`: the art is not to start a business, but to keep it running =)
00:27:47 <Enigmagic> at least in the US. it's cheaper in Asia, not sure about Europe or South America.
00:27:50 <nand`> mm_freak: fair point :)
00:28:01 <shachaf> Java cryptography engine?
00:28:04 <edwardk> 37, and i was probably 12 when i first made money off the computer
00:28:08 <monadd> nice
00:28:17 <monadd> veteran
00:28:39 <edwardk> shachaf: i had a JCA/JCE engine in the java 1.3-1.4 era, that did horrible tricks to work around their crappy API
00:29:14 <edwardk> shachaf: it let me actually factor out the mode selection and padding selection for hashes, etc. without making one class for every !@()# combination
00:29:35 <shachaf> But that's the Java way!
00:29:44 <Enigmagic> there's a design pattern for that.
00:29:50 <edwardk> it was a total hack but i had a number of customers who used it because i could support some pretty esoteric functionality
00:29:58 <nand`> I thought the java way would be to make one big generator class to construct all of those combinations for you
00:30:06 <johnw> edwardk: I'm trying  _filename .~ "/root/foo/bar.cpp" $ "hey", but getting "/root/foo/bar.cpp"
00:30:09 <johnw> did I miss something?
00:30:32 <edwardk> in the end around 1.4 java stopped giving licenses to everyone smaller than symantec, and i moved on, gave a lot of code to GNU CRYPTO and switched to other projects
00:30:41 <nand`> _filename ?
00:30:59 <nand`> johnw: quick question, did you perhaps mean _filename .~ "hey" $ "/root/foo/bar.cpp" ?
00:31:01 <edwardk> johnw: not sure what the _filename lens does to be honest. someone else wrote the filepath module
00:31:07 <johnw> oh, haha
00:31:10 <edwardk> hahaha
00:31:11 <edwardk> yeah
00:31:12 <edwardk> that
00:31:32 <johnw> (_directory . _filename) .~ "hey" $ "/root/foo/bar.cpp" => "/root/hey/bar.cpp"
00:31:36 <johnw> excellent
00:31:44 <edwardk> =)
00:31:46 <nand`> not bad
00:31:50 <edwardk> no need for ()'s
00:31:56 <edwardk> _directory._filename .~
00:32:09 <nand`> why are there _s in this situation though
00:32:12 <nand`> it's ugly
00:32:28 <edwardk> i'd be okay with removing them if they don't collide with exported functions from System.FilePath
00:32:35 <edwardk> take a look and patch. i'll accept
00:32:57 <nand`> personally I'd rather import System.FilePath hiding (directory, filename) if those are replaced by the lenses
00:33:08 <johnw> they don't mean the same thing at all
00:33:11 <nand`> .. I always love how you can just include Haskell in english sentences and have it read out normally
00:33:13 <nand`> okay
00:33:13 <Enigmagic> I'd rather just not import System.FilePath
00:33:17 <johnw> _filename is a Lens
00:33:27 <johnw> ^. _filename is a FilePath -> FilePath
00:33:38 <nand`> and ‘filename’ ?
00:33:42 <edwardk> johnw: i don't always prefix lenses with _
00:33:45 <johnw> for any foo/bar, returns bar
00:33:48 <edwardk> mostly when they collide with another name
00:34:07 <shachaf> Whatever your normal identifier is, toggle the _ to get the lens version.
00:34:09 <edwardk> filename doesn't collide
00:34:22 <edwardk> directory doesn't either
00:34:27 <nand`> edwardk: excellent
00:34:52 <edwardk> nor extension
00:35:03 <edwardk> or basename
00:35:11 <edwardk> its a clean sweep
00:35:16 <edwardk> all the _'s in there die
00:35:32 <nand`> I use _ for the record field names personally; the only time I like _ on my lenses is for short / heavily collided / impossible names like _1 through _9 for tuples and _x/_y or _u/_v for vector components
00:35:42 <edwardk> yep
00:35:58 <edwardk> i use _e, _i, _j, _k for fields of a quaternion, etc.
00:36:37 <nand`> quick thought
00:37:03 <nand`> _ei, _jk, _eij etc. for traversals over those
00:37:15 <nand`> like in shader code :)
00:37:19 <nand`> foo._xy *= 3
00:37:20 <edwardk> i already use ijk as the lens to extract the 3 vector of components
00:37:34 <edwardk> but it gets the vector not the traversal of the elements
00:37:38 <edwardk> heh
00:37:42 <edwardk> thats cute though
00:38:23 <johnw> The operators in Control.Lens are a wee bit overwhelming
00:38:40 <edwardk> johnw: there is a method to their madness
00:39:15 <edwardk> +~  etc are functional updates, += apply to state,   <+=   returns the result as well
00:39:30 <nand`> oh hey, ‘both’ no longer exists
00:39:34 <johnw> why .~ for modifying paths?
00:39:36 <edwardk> nand`: moved
00:39:43 <nand`> edwardk: where?
00:39:47 <shachaf> .~ is "set"
00:39:58 <edwardk> .~ is used for setting to _any_ sort of setter.
00:40:00 <johnw> ah
00:40:08 <johnw> i like Lens, a lot
00:40:12 <edwardk> works on setters, lenses, traversals, isomorphisms, indexed setters, etc.
00:40:16 <johnw> now that I understand a bit more about Comonads
00:40:30 <mm_freak> edwardk: i'm examining comonadic FRP again
00:40:38 <nand`> I'm not entirely sure .~ looks the way it should the first time you see it; but it fits into a good pattern where most lens operations are divided into pure and Stateful versions
00:40:43 <mm_freak>     extend f r@(Reactive x xs) = Reactive (f r) (extend f xs)
00:40:44 <mm_freak>     fmap   f   (Reactive x xs) = Reactive (f x) (fmap f xs)
00:40:52 <nand`> and .= looks like a reasonable approximation to something like :=
00:40:54 <mm_freak> those seem incredibly similar
00:41:06 <johnw> why does .~ flip the arguments around from ^.?
00:41:11 <johnw> is there a ~.?
00:41:12 <edwardk> yeah it was originally ^=, then ^~, then the ^ got quited to .~
00:41:30 <edwardk> johnw: ^. is mnemonic, the ^ points to what is being updated.
00:41:44 <nand`> (oh hey, it's just like pointers: foo^.bar)
00:41:46 <mm_freak> johnw: btw, that's a comonad that is also an applicative functor
00:41:49 <edwardk> originally the operator for update was ^= or ^~, but that is awkward to type
00:42:03 <johnw> i think Object Pascal actually has a .^ member pointer operator...
00:42:13 <shachaf> ^. does updates?
00:42:17 <johnw> mm_freak: what is?
00:42:18 <edwardk> mm_freak: comonads always look like that ;)
00:42:31 <johnw> I think ^= is much clearer
00:42:44 <edwardk> johnw: the problem is i want = for the state actions
00:42:51 <mm_freak> johnw: data Reactive a = Reactive a (Reactive a)
00:42:53 <edwardk> so ballSpeed.x += 10
00:42:57 <edwardk> that sort of thing works
00:42:58 <mm_freak> you can rename Reactive to Stream, if you wish
00:43:06 <edwardk> ~ is used for analogy, its 'like' =
00:43:13 <johnw> mm_freak: I don't think you mean to be talking to me
00:43:19 <johnw> mm_freak: I never mentioned Reactive
00:43:25 <edwardk> ballSpeed.x +~ 10 $ now i have to pass something with ballspeed here
00:43:31 <nand`> johnw: reply to ‘what is?’
00:43:32 <mm_freak> johnw: i know, but you asked whether every comonad is an applicative functor
00:43:42 <edwardk> .= is much quieter. ideally it would be := but thats not legal
00:43:54 <nand`> := would be too convenient
00:43:58 <shachaf> What about ←
00:44:00 <johnw> oh, ok, I zoned out because you were talking to edwardk about FRP
00:44:02 <edwardk> shachaf: =P
00:44:18 <johnw> .= makes more sense too
00:44:21 <nand`> edwardk: I can't find both
00:44:22 <edwardk> shachaf: i have <~  -- its the one combinator that breaks the rule about < and ~
00:44:38 <edwardk> nand`: its in traversal i think
00:44:42 <edwardk> control.lens.traversal.both
00:44:56 <shachaf> (<~) = (.=)?
00:44:56 <edwardk> importing control.lens should just give it to you
00:45:00 <johnw> are there English-named functions for all the various operators?
00:45:01 <edwardk> nah
00:45:08 <nand`> most of them
00:45:14 <edwardk> johnw: only the core few
00:45:18 <johnw> because if my coworker saw all those operators, it would be worse than meaningless to him
00:45:31 <johnw> it would end likely the use of Lens :)
00:45:39 <edwardk> over for %~, view for (^$), etc
00:45:47 <nand`> traverseOf for %%~
00:45:53 <edwardk> nand`: hahah that too =)
00:46:01 <johnw> do you have a graphical quickref that shows all their relationships?
00:46:05 <edwardk> toListOf for ^..
00:46:13 <nand`> ^..? that one's new to me
00:46:27 <edwardk> nand`: added that and ^? in 2.5
00:46:45 <edwardk> johnw: https://github.com/ekmett/lens#field-guide
00:46:58 <edwardk> it only shows the core of the hierarchy
00:47:04 <edwardk> but its enough to get you a feel for how things work
00:47:10 <johnw> that's not really what I meant
00:47:20 <nand`> edwardk: ah, I have ‘both’ now; I was sitting on 2.4
00:47:28 <johnw> i'd prefer to see a table that shows rows and columns for "access", "modify", "state", "view", etc.
00:47:35 <edwardk> i don't have a breakdown of the syntactic relationship between them etc
00:47:47 <johnw> that would help much them clearer to a newcomer
00:47:52 <edwardk> there is an open wiki though, if you wanted to start a page, i'd contribute
00:48:02 <johnw> otherwise, I have to build those relationships myself, and man there are a LOT of them
00:48:02 <edwardk> https://github.com/ekmett/lens/wiki
00:48:17 <nand`> edwardk: btw, re: using _eij to get that triple of a quaternion; with a traversal you could do something like toListOf _eij to get [e,i,j]
00:48:39 <edwardk> nand`: the problem is i really need it as a vector more often than not
00:48:52 <nand`> maybe something like that could be retrofitted into returning fixed length vectors
00:49:09 <edwardk> rotate q v = (q * Quaternion 0 v * conjugate q)^._ijk
00:49:20 <nand`> ah
00:50:19 <edwardk> johnw: http://ekmett.github.com/lens/doc-index-All.html
00:51:00 <johnw> hrmph :)
00:51:00 <edwardk> basically its just (existingoperator) with = or ~ after it and optionally < before it for 99% of those
00:51:10 <johnw> ah
00:51:17 <nand`> half those operators seem to have been moved to the bottom; that is an unfortunate sorting
00:52:02 <nand`> I'm not entirely sure I understand the motivation behind (^..) = flip toListOf
00:52:12 <edwardk> the only rule breakers are things like ^., ^.., ^!, ^? and ^$, plus <~
00:52:30 <edwardk> nand`: when you have a fold its useful to be able to run it and then enumerate it
00:52:32 <johnw> yay, I have an edwardk comment on my blog
00:52:51 <nand`> edwardk: I mean the operator naming
00:52:56 <edwardk> foo^.._2.folded.biplate
00:53:05 <edwardk> [a..b] think
00:53:16 <nand`> ah
00:54:04 <edwardk> i can't use an actual .. but ^.. is legal, and placing it infix, it fits the pattern of . for field access, but for things that aren't monoids.
00:54:38 <edwardk> kind of like how ^! lets you run actions
00:55:03 <edwardk> and ^? lets you get the target of a traversal/fold being used like a partial getter
00:55:17 <edwardk> ^? is flipped headOf
00:55:30 <edwardk> so you get a Maybe out of it
00:55:45 <johnw> night all
00:58:54 <edwardk> on a more half baked front i've been toying with ways i can make it so you can have some traversals that can also be used for 'insert' like operations
00:59:22 <edwardk> but havemostly been beating my head on alternate designs for multiplate
00:59:29 <mm_freak> edwardk: do you have a use case for bazaars?
00:59:48 <edwardk> mm_freak: yes. =)
00:59:59 <edwardk> they charaterize a traversal
01:00:12 <edwardk> i use them all over the place in lens
01:00:24 <mm_freak> i see
01:00:58 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Plated.hs#L783
01:01:08 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Plated.hs#L677
01:01:34 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Traversal.hs#L371
01:04:35 <edwardk> mm_freak: https://github.com/ekmett/lens/blob/4b6f7325984ce279af714c45c0f05384c65cce6d/src/Data/Data/Lens.hs#L262 was how i used to implement uniplateData/biplateData as welll
01:04:58 <edwardk> kleene was the old name for bazaar
01:05:52 <edwardk> the comonad lets you 'split' a traversal in half between different functors. thats the role of duplicate
01:06:03 <edwardk> say you know how to convert half the targets of a traversal
01:06:12 <edwardk> or to convert them half way to your goal
01:06:17 <edwardk> you can split and do that part
01:07:45 <mm_freak> interesting
01:08:01 <mm_freak> btw, in your latest comonad library you have removed the Extend class, which is unfortunate
01:08:11 <mm_freak> because in fact wires are Extend, but not Comonad
01:08:17 <edwardk> mm_freak: its in semigroupoids
01:08:22 <mm_freak> ah, ok
01:08:31 <edwardk> it was confusing the heck out of people
01:08:47 <edwardk> and more over it was a barrier to getting it standardized
01:08:49 <mm_freak> huh?
01:08:59 <mm_freak> hmm
01:09:15 <edwardk> so i stripped the comonad type down to the 'stuff everyone can agree it should have'
01:09:24 <mm_freak> not sure what's confusing about Extend
01:09:28 <edwardk> well
01:09:46 <edwardk> there is also the fact that it meant that people wound up with spurious semigroup requirements for their comonads
01:09:56 <edwardk> because they had extend that needed the semigroup
01:10:03 <edwardk> but extract added the need for the unit
01:10:19 <edwardk> so now you have to pass both, say, an monoid _and_ a semigroup for a bunch of combinators
01:10:26 <edwardk> it really mucks up the exposition
01:10:41 <edwardk> if semigroup was fixed and merged in as a superclass of monoid that'd be a less convincing argument
01:11:08 <edwardk> but as it stands its ugly and inconsistent
01:11:28 <mm_freak> ok, i see
01:11:42 <edwardk> and much of the pressure i had put on me to make usable semigroupoids came from the fact that i could make product and coproduct semigroupoids, but not product and coproduct categories
01:11:45 <edwardk> now i can make those
01:11:49 <mm_freak> well, you could ignore Data.Monoid and make your own
01:12:00 <edwardk> i could, but that isn't going to happen
01:12:15 <edwardk> i have a whole sewer of those things in algebra
01:12:19 <edwardk> even i don't use them
01:18:21 <statusfailed> Could anyone suggest a way to tidy up the "variance" function here? http://hpaste.org/73806
01:18:37 <statusfailed> I feel like i'm missing some of the Lens operators that might help
01:19:01 <edwardk> statusfailed: did you see my updates to it?
01:19:05 <statusfailed> oh, I didn't!
01:19:11 <statusfailed> and they're right ther e:|
01:19:13 <statusfailed> thanks :P
01:19:17 <edwardk> =)
01:19:25 <edwardk> the last one is actually kinda nice i think
01:20:03 <statusfailed> hah, I hadn't even thought of using both <- and <+=. neat :)
01:20:05 <edwardk> it probably needs to be uses mean (x -)
01:20:26 <edwardk> the < is to point out that the answer is going that way ;)
01:20:42 <statusfailed> well if you put it like that :P
01:21:04 <statusfailed> that's awesome, thanks a bunch! I'm gonna go through this line by line
01:21:30 <edwardk> lemme know if you come up with something that you think would be an api improvement
01:22:01 <statusfailed> will do!
01:41:17 <statusfailed> edwardk: I think there's a bug in the docs for <%~: "When you do not need the result of the addition, (+~) is more flexible"
01:41:36 <shachaf> edwardk: Have you considered higher-order documentation?
01:41:51 <shachaf> Usually all this copying-and-pasting would be considered bad style.
01:41:57 <statusfailed> hahaha
01:42:55 <hardc0de> how can I flush IO buffer in haskell? no problem when running by runhaskell, but compiled program have problem.
01:42:57 <edwardk> shachaf: =)
01:43:01 <edwardk> i blame haddock
01:43:08 <edwardk> statusfailed: i'll fix
01:43:35 <mekeor> hardc0de: hFlush, i think
01:43:40 <statusfailed> no rush, but thanks :)
01:43:52 <mekeor> @hoogle hFlush
01:43:52 <lambdabot> System.IO hFlush :: Handle -> IO ()
01:43:52 <lambdabot> GHC.IO.Handle hFlush :: Handle -> IO ()
01:43:52 <lambdabot> GHC.IO.Handle hFlushAll :: Handle -> IO ()
01:43:57 <edwardk> docs patched in HEAD
01:44:14 <mekeor> hardc0de: hFlush stdout, e.g.
01:44:30 <hardc0de> mekeor, lambdabod: thanks! I'll try that
01:44:50 <edwardk> shachaf: my previous attempts at higher order documentation have largely failed. i document just the concepts and i get no users ;)
01:44:55 <mekeor> hardc0de: lambdabot is a bot, a robot.
01:45:20 <hardc0de> ? don't know until now
01:46:08 * mekeor missed #haskell since he is on holidays =(
01:46:33 <mekeor> i missed edwardk and shachaf and newsham :)
01:47:28 <edwardk> i do something like lens where i we missed you too, er wait, you were gone? ;)
01:47:45 <mekeor> :D
01:47:53 <statusfailed> where were holidays?
01:48:11 <mekeor> i am still... in turkey
01:48:19 <statusfailed> ooh nice
01:48:36 <mekeor> i'm in an internet-cafe at the moment.... but that's too off-topic :)
01:48:40 <edwardk> you missed like a dozen versions of lens
01:48:44 <statusfailed> but this does indicate a severe haskell addiction :P
01:48:48 <mekeor> oh
01:49:04 <nand`> #haskell addiction rather
01:50:27 <hardc0de> mekeor: hFlush works, "hFlush stdout", that's all I need. thanks
01:50:54 <mekeor> nice :)  no problem :)
01:51:41 <merijn> hardc0de: There's also a "hSetBuffering" (or something similar, anyway) to permanently enable/disable line buffering for a handle
01:52:00 <merijn> @hoogle hSetBuffering
01:52:00 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
01:52:01 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
01:53:50 <hardc0de> http://www.haskell.org/pipermail/haskell/2006-September/018430.html similar question
01:54:18 <asda8> this may be not that much haskell related, but what is the best way to make sure that my application isn't running twice? I'm on windows btw.
01:54:34 <shachaf> Unplug the computer.
01:54:49 <shachaf> (Task manager?)
01:55:00 <merijn> asda8: Usually you'd create a lockfile in some known directory and if the file creation fails (i.e. it already exists) then you terminate with an "already running" error
01:55:07 <asda8> I was thinking of creating a file while my application is running and deleting it when it stops, then checking for it on startup
01:55:09 <shachaf> Oh, you meant from the application itself.
01:55:30 <asda8> merijn: yeah, but what happens when my app crashes and leaves that file around
01:55:34 <nand`> unplugging the computer would still work
01:55:43 <merijn> asda8: You're screwed and have to manually remove it
01:55:43 <shachaf> I think Windows has a mechanism for that.
01:55:58 <merijn> Or have an "force remove" startup option in your program
01:56:00 <asda8> merijn: or maybe I could expire it after some time?
01:56:02 <shachaf> Google suggests http://blogs.msdn.com/b/onoj/archive/2004/06/04/148532.aspx
01:56:06 <nand`> maybe it would be possible to consult the process table itself to count the number of running copies
01:56:15 <merijn> asda8: Do you plan to run the program as a background service type deal?
01:56:19 <shachaf> Those links should be relevant.
01:56:28 <asda8> merijn: i want to run it as a scheduled task in windows, so yes
01:56:52 <asda8> merijn: I stumbled upon this: http://stackoverflow.com/questions/10037654/how-can-a-windows-service-application-be-written-in-haskell
01:57:10 <asda8> merijn: so I figured I do the easier windows scheduled task type of thing
01:57:41 <asda8> merijn: I still want to make sure no other instance of my app is started while the first one is still working...
01:59:40 <merijn> asda8: The question you need to answer is what's the best failure mode: application accidentally running twice or application accidentally not running?
02:01:09 <asda8> merijn: running twice would be really bad, but I also want to avoid it not running
02:02:51 <merijn> As long as your program doesn't crash the lockfile idea will be fine for preventing it from running twice, but if for some reason the program *does* crash and leave a lockfile any subsequent runs won't start
02:03:31 <asda8> merijn: maybe I could put an "expiration" on the logfile, so my program can recover after some time
02:03:49 <merijn> One thing you can do is check whether the haskell library provides a way to create temporary files (i.e. that'll be deleted on reboot) or use the FFI to call a window function that does that, in that case a reboot will automatically fix things
02:03:52 <mauke> this could be done with a socket or fifo
02:04:12 <asda8> merijn: what about checking the list of running processes?
02:04:26 <merijn> asda8: Yes, but take into account that if your expiration is shorter than the maximum runtime you might still run twice
02:04:43 <asda8> merijn: sure, I just have to live with that I guess
02:04:48 <merijn> asda8: That might work, seems like it could be a bit hacky/insecure then
02:04:58 <merijn> mauke: Really? How?
02:05:10 <asda8> mauke: I'm curious as well :)
02:05:24 <merijn> oh, I guess the socket will be free to bind whenever the original binder dies
02:05:53 <merijn> (Assuming you remember to turn off the delay preventing binding after the original owner dies!)
02:05:53 <mauke> IIRC the bind will fail anyway, but with a different error
02:05:59 <mauke> what delay?
02:06:03 <asda8> merijn: yeah, never thought of using ports for locking
02:06:14 <mauke> oh, not ports. I was thinking of a file
02:06:26 <merijn> mauke: By default trying to bind a port that was bound by a recently died process fails
02:06:55 <mauke> yes, I wasn't talking about ports
02:07:06 <asda8> did I mention this is a database application, so maybe I can use some mechanism inside the db as well
02:07:28 <mauke> wait
02:07:42 <mauke> this can be solved by a simple lockfile, can't it?
02:08:18 <asda8> mauke: yes, but what if the power goes out and the file sticks there forever
02:08:26 <mauke> doesn't matter, it won't be locked
02:08:38 <merijn_> hmm, stupidly timed D/C
02:08:51 <merijn_> mauke: So how can you get the OS to release a file on process crash?
02:08:59 <mauke> define "release a file"
02:09:36 <merijn_> Well, something detectable that lets you see while the previous process is still running
02:09:44 <merijn_> be it deleting the file or whatever
02:09:50 <mauke> a lock
02:09:58 <mauke> on a file
02:10:11 <asda8> mauke: you mean just opening a handle to the file while the process is running?
02:10:21 <mauke> no, I mean locking the file
02:10:42 <asda8> mauke: shouldn't that lock the file?
02:11:00 <asda8> mauke: I mean if I open it in write-mode
02:11:01 <merijn_> asda8: Nope
02:11:09 <mauke> asda8: depends on what you mean by "open"
02:11:15 <merijn_> asda8: You have no protection from others messing with a file you have open
02:11:37 <merijn_> mauke: Are fcntl locks portable to windows, though?
02:11:38 <mauke> the ghc runtime will actually lock files behind your back
02:11:45 <mauke> merijn_: no idea
02:11:57 <asda8> merijn_: I've seen this with my log files (hslogger), you can even read them until the app finishes
02:12:13 <asda8> can't
02:13:22 <merijn_> asda8: I don't know how windows behaves, but on unix there's not protection aside from fcntl locks on files (which are optional in the sense that if you have a lock and someone edits a file without checking for the lock it will just work)
02:13:41 <mauke> you're not limited to fcntl locks on unix
02:14:24 <mauke> there's at least flock and lockf
02:14:34 <asda8> merijn_: I don't have a problem if the lock isn't enforced, I'll check it myself
02:14:59 <merijn_> mauke: I was checking flock but the man page doesn't say the lock is freed when the process dies?
02:15:48 <mauke> it says closing a fd releases its locks
02:16:51 <asda8> hm, I'll test this
02:16:52 <Shapeshifter> How can I parse the +-*/ operators from string to their respective functions, e.g. "+" -> (+)? read can't do it, so I tried a lookup table like so: http://hpaste.org/73823 but this gives me an error "Could not deduce (Fractional a) arising from a use of `/'" since / uses Fractionals and not Nums, or something...
02:17:18 <merijn_> mauke: Not on my system so I guess the manpages are incomplete?
02:17:25 <mauke> merijn_: what OS?
02:17:28 <merijn_> OSX
02:17:54 <LaughingMan> what is the runtime overhead of 'existenial quantified' ?
02:18:08 <shachaf> Shapeshifter: (/)'s type isn't Num a => a -> a -> a
02:18:20 <merijn_> mauke: Although a quick look suggests the man page are identical to the FreeBSD ones
02:18:37 <Shapeshifter> shachaf: I know, but how do I get around that without it getting too complicated?
02:18:51 <mauke> merijn_: man 2 open
02:18:52 <shachaf> Shapeshifter: Pick a common type for all those functions.
02:18:52 <mauke> er
02:18:55 <mauke> merijn_: man 2 close
02:19:14 <mauke> Shapeshifter: that depends on what you want the code to do
02:19:21 <merijn_> mauke: Ah, lockf also mentions closing the fd closing the locks
02:19:28 <merijn_> It's just fcntl and flock that don't
02:20:31 <mauke> "on the last close of a file holding an
02:20:31 <mauke>      advisory lock the lock is released (see further flock(2))."
02:21:38 <hpaste> igstan pasted “Integral and Fractional” at http://hpaste.org/73824
02:21:48 <igstan> Shapeshifter: haskell is complaining because there's also a div function on the Integral type class. / is defined on Fractional
02:22:06 <igstan> Shapeshifter: choose one of them depending on what you want to achieve
02:22:22 <merijn> mauke: Yeah, as I said it's just flock and fcntl that are missing the info, which happen to be the two I checked >.>
02:22:51 <shachaf> Shapeshifter: You have to decide what type you want to use.
02:23:00 <shachaf> If you want to be nice and concrete you can pick something like Integer or Rational.
02:23:17 <Shapeshifter> Yes, I understand the problem but I can't think of a solution. Pick a common type? I think that's only Eq or Show, but that doesn't seem right.
02:23:20 <Shapeshifter> mhh
02:23:53 <shachaf> Shapeshifter: You can pick something type-class-polymorphic but that's probably too complicated for what you need.
02:24:46 <mauke> Shapeshifter: how are you going to use this table?
02:26:23 <nand`> Shapeshifter: if you absolutely need (/) the easiest way would be to strengthen Num to Fractional
02:28:00 <Shapeshifter> Well. I'm reading 'Learn you a haskell' and I've reached the RPN calculator. But I'd like to solve it before reading how he did it. I'm trying to parse the input, which will be a string. So I'll need to parse +, - , * and / to their respective functions.
02:28:15 <mauke> Shapeshifter: and how are you going to use those functions?
02:28:46 <nand`> if you want your RPN calculator to evaluate 3 2 / to 1.5 then you want a fractional type. If you want it to evaluate 3 2 / to 1 then you want `div`
02:29:02 <shachaf> That's backwards.
02:29:16 <shachaf> First figure out your types and then figure out the operations you can do on them. :-)
02:29:36 <shachaf> (You don't "want" 3 2 / to evaluate to 1. You settle for it because you "want" things to be integers.)
02:29:38 <nand`> I disagree (in this scenario), first he wants to figure out what his RPN calculator should be doing and then figure out a type to model that behavior
02:31:20 <nand`> the question is should his RPN calculator be (to the user) handling rationals or integers, without regarding the underlying haskell type (yet)
02:31:26 <Shapeshifter> let me think about it a bit more...
02:31:52 <nand`> (of course, they'd translate down to Rational and Integer :P)
02:39:04 <hardc0de> I just wrote a simple program, downloading web albums from website. It's my first time writing a working haskell program. But after I finished that, I found myself still using the idea of imperative programming. I guess I have not got any clue of functional programming.
02:41:53 <tdammers> haskell is a fine imperative language ;)
02:43:24 <Hadaka> I've got a Warp server which receives files, and a HTTP Conduit client which sends files - and I'm finding that reusing a "manager" actually slows down connections
02:43:54 <Hadaka> or, concretely - if I call "closeManager" (which closes all http connections kept alive) after *each* request, I more than double my throughput
02:44:42 <Hadaka> the sending happens in a strictly sequential manner, there is no interleaving of the requests
02:45:17 <Hadaka> also, the best performance comes if I send a single file as just one very large PUT - which is obvious - so the issue is not that TCP itself would slow it down
02:56:46 <timthelion> Hadaka: there is a simple explanation(maybe correct, maybe incorrect) and that is that some networked servers have throughput quotas with a higher "burst" rate then "sustained" rate...  And by getting a new route you can take advantage of the burst rate quotas...
02:57:16 <Hadaka> timthelion: both servers are transferring over lo-interface
02:57:26 <Hadaka> erm, and server/client
02:58:39 <timthelion> Hadaka: Are you sending over LAN or internet?
02:59:24 <timthelion> oh, lo=loopback?
02:59:33 <timthelion> on local machine?
02:59:33 <tdammers> yeah.
02:59:34 <Hadaka> timthelion: if you can sell me a loopback interface that sends over LAN or internet, do let me know :)
03:00:04 <timthelion> Hadaka: then I guess I'm full of shit(or at least my explanation does not apply to your case :)
03:00:05 <tdammers> lo is the device name of the loopback interface of pretty much every Linux system ever
03:00:08 <AfC> People with the surname "Cloud" living in "Haskell, Arkansas, USA" are messing up my google searches.
03:03:28 <timthelion> WTF, right clicking on dzen2 causes it to close, thus causing xmonad to exit...
03:06:25 * timthelion was just sitting there, listening to Justin Beiber, chatting on IRC about LO devices.  Wanted to figure out if he had one of those lo0's hanging arround, so you know, he was clicking on things. when all of a suden, music stops, cat jumping off balcony GIF loop dissapears... All of a sudden, just grey text and a black screen.  He'll have trauma for months.
03:10:53 <nand`> My google searches for currying in haskell are always messed up :(
03:11:11 <srhb> nand`: Why? :P
03:11:20 <nand`> because of that joker named Haskell Curry
03:11:28 <srhb> Oh, how dare he.
03:11:50 <srhb> But I doubt that works when actually using the form "currying" :P
03:12:08 <t7> how much do you need to know about currying...
03:12:13 <nand`> a lot, I guess
03:12:14 <srhb> Yeah, that too :P
03:13:26 <srhb> Plus, it's not really Haskell specific.
03:14:14 <tdammers> ((a, b) -> c) -> (a -> b -> c) -- that's all there is to currying, really
03:14:21 <Jafet> I wonder if Chef supports currying.
03:14:41 <tdammers> yes, but it means something completely different
03:14:55 <srhb> tdammers: That doesn't really encompass the whole concept, does it
03:15:17 <srhb> Isn't it clearer to say that a function (a -> b -> c) is really a function (a -> (b -> c)) ?
03:15:18 <tdammers> which part is missing? oh, the "why".
03:15:38 <tdammers> same thing, only more explicit
03:15:44 <srhb> Hmm.
03:16:04 <t7> i watched a talk on lambda calc and turing yesterday
03:16:05 <srhb> It seems to me like you are explaining curry while I am explaining currying.
03:16:06 <srhb> :P
03:16:06 <t7> was awesome
03:16:09 <quicksilver> I don't think that ((a, b) -> c) -> (a -> b -> c) is a good candidate for "all there is to currying"
03:16:33 <quicksilver> currying is when you replace a function which takes two arguments with a function which takes one argument and returns a function.
03:16:39 <tdammers> I wasn't being *entirely* serious
03:16:42 <quicksilver> ((a, b) -> c) isn't a function which takes two arguments
03:16:47 <quicksilver> it's a function which takes one argument - a tuple
03:16:56 <quicksilver> it's just the closest we can get inside haskell
03:17:13 <quicksilver> :)
03:17:23 <srhb> This reminds me of the time where I accidentally said, in #haskell "and the shortest possible way to do that would be (foo)."
03:17:55 <quicksilver> So currying, from a PL point of view, is something like the observation "When designing a PL you don't need to account specially for multiple argument functions - you can make all your functions single argument and permit some of them to return functions"
03:18:05 <quicksilver> in some ways this observation simplifies stuff.
03:18:31 <quicksilver> srhb: currying brings out my pedantic side because people so often use the word when they mean partial application.
03:18:45 <quicksilver> and because I have seen newbies genuinely confused by inaccurate usage
03:18:56 <tdammers> quicksilver: (a -> b -> c) doesn't take two arguments, really
03:19:11 <tdammers> it takes one, returns another function, and *that* function takes another argument
03:19:33 <quicksilver> sure
03:19:36 <t7> #haskell-philosophy
03:19:36 <quicksilver> did I say otherwise?
03:19:41 <tdammers> not really
03:20:20 <nand`> quicksilver: or you could add tuples, really
03:20:27 <nand`> without needing first class functions
03:20:31 <tdammers> also, that observation is only *one* of the reasons why you'd want to curry
03:20:37 <tdammers> partial application is another
03:20:38 <srhb> And we're back to my succinct version: (a -> b -> c) is really (a -> (b -> c)) -- \o/
03:20:49 <srhb> Which really encompasses both.
03:20:51 <nand`> srhb: I don't feel that says anything
03:20:55 <tdammers> srhb: yes, but the precedence rules for -> already imply that
03:20:58 <nand`> notation is just notation, -> could be left associative
03:21:00 <srhb> Yeah :P
03:21:08 <quicksilver> it's certainly an important observation thouguh
03:21:10 <tdammers> s/precedence/associativity/
03:21:14 <tdammers> certainly.
03:21:16 <quicksilver> (important to observers who didn't already know it)
03:21:25 <t7> i dont like infix arrow (->) a ((->) b c)
03:21:41 <t7> now there is no confusion
03:21:52 <nand`> I think currying is rather the reason why we use a -> b -> c -> d in the first place - that seemed a tad strange to me when I was first introduced to Haskell
03:22:05 <nand`> not specifically how that associatives
03:22:08 <nand`> associateS*
03:22:36 <tdammers> yeah, well, almost all the haskell functions one comes across are already fully curried
03:22:59 <srhb> What does that even mean?
03:23:23 <tdammers> it means that a -> b -> c is a typical type signature, but (a, b) -> c is not.
03:23:24 <srhb> I mean, Haskell is a language that employs currying to simulate multiargument functions. Therefore all functions are "fully curried" -- or am I mistaken?
03:23:32 <tdammers> sort of
03:23:44 <tdammers> unless you count functions that take tuples as "multi-argument"
03:23:49 <quicksilver> I don't.
03:23:56 <quicksilver> tuples are tuples
03:23:58 <quicksilver> they're a data structure
03:24:02 <quicksilver> in haskell, at least.
03:24:02 <tdammers> Yes.
03:24:10 <Jafet> I'm even more hungry now
03:24:19 <quicksilver> so I'm with srhb - all fucntions in haskell are fully curried, that's the only option available.
03:24:20 <srhb> There's no way of currying (a,b) -> c that does not change semantics.
03:24:20 <tdammers> But with pattern matching and all that, the difference is pretty damn small, practically speaking
03:24:31 <srhb> I guess.
03:24:47 <tdammers> of course not. Currying itself always changes semantics
03:25:36 <srhb> Right, I should say changes semantics of a and b
03:25:52 <nand`> unrelated thought, would it break or change anything significant to make tuple pattern matches irrefutable by default?
03:26:10 <nand`> matching the constructor, that is
03:26:11 <srhb> (a,b) is drastically different from a and b.
03:26:27 <lpvb> I'm planning to make a 3d game in haskell, anyone know what the performance hit will be vs using C++?
03:26:31 <srhb> THough I suppose that's subjective :-)
03:26:38 <tdammers> but which one of these differences are outside the intended effects of uncurrying?
03:26:43 <t7> (a, b) is equiv to logical a & b
03:26:56 <srhb> lpvb: ASsuming OpenGL, OpenGL will probably be the deciding factor, not Haskell vs. C++
03:26:59 <tdammers> lpvb: zero, if you do it right
03:27:02 <srhb> lpvb: But the question is insane.
03:27:06 <tdammers> (or maybe even negative)
03:27:07 <lpvb> I'm using OpenGL
03:27:28 <lpvb> how would I 'do it right'?
03:27:40 <tdammers> play haskell's strength, avoid haskell's performance pitfalls
03:27:46 <tdammers> just like with any other language
03:27:47 <quicksilver> there is no simple answer as to the performance hit
03:27:55 <lpvb> ok that's good to hear
03:27:57 <quicksilver> it depends how complex your game's data structures are and how you model them
03:27:58 <t7> tdammers: 0 if you do it wrong, your code will look like C so it might aswel be in C
03:28:09 <nand`> t7: disagree
03:28:20 <tdammers> t7: if you do it wrong, haskell's going to be slower than the C++ equivalent
03:28:33 <srhb> @faq Can Haskell write games that go way faster than C++?
03:28:34 <lambdabot> The answer is: Yes! Haskell can do that.
03:28:36 <srhb> Hurray!
03:28:36 <tdammers> but then, properly written haskell is faster than poor C++, so that doesn't say much
03:28:41 <t7> if you do it right its gonna be slower. but safer and nicer etc
03:28:58 <srhb> tdammers: How do you know the the C++ is not horrible?
03:29:16 <tdammers> I don't. I'm sketching two scenarios
03:29:29 <tdammers> It boils down to 'good code is faster than bad code'
03:29:33 <srhb> YEs!
03:29:40 <lpvb> If I write it in idiomatic haskell, what's the worst speed hit I can expect?
03:29:43 <lpvb> 30%?
03:29:46 <srhb> Which is exactly why amusing people when they bring this question is horrible
03:29:49 <t7> 200%
03:29:52 <srhb> lpvb: 100000%
03:29:56 <srhb> lpvb: Or 10.
03:30:08 <tdammers> lvpb: last [1..]
03:30:20 <lpvb> obviously not that
03:30:26 <tdammers> very well that
03:30:31 <srhb> lpvb: Your question doesn't make sense.
03:30:42 <t7> why not?
03:30:44 <tdammers> if you end up writing nonterminating constructs, then your program never does anything
03:30:53 <tdammers> that's an infinite performance hit
03:30:55 <nand`> his question makes sense, but I don't think it can be answered
03:30:59 <nand`> it's like philosophy
03:31:04 <srhb> Fair enough.
03:31:07 <Jafet> tdammers: fast Haskell code defaults Num to Word8
03:31:09 <srhb> Same difference though.
03:31:11 <t7> tdammers: thats irrelevant
03:31:21 <tdammers> yes, it is.
03:31:32 <srhb> Jafet++
03:31:41 <srhb> :-)
03:32:04 <nand`> I default Num to ()
03:32:34 <t7> I default it to false
03:32:40 <nand`> that's not a type :(
03:33:01 <t7> :)
03:34:10 <srhb> lpvb: The point is that it's impossible to answer your question. Once you have "something" in C++ you can say "OK, so what would I need to bring Haskell to do the same thing at the same speed" - and it's either possible or it's not, and either ugly or it's not
03:34:24 <nand`> guys guys
03:34:28 <nand`> languages don't have speeds
03:34:32 <srhb> lpvb: And it may be way faster and way prettier or the other way around, mostly depending on the programmer, but also (blah blah blah)
03:34:39 <nand`> implementations factor in
03:34:40 <srhb> nand`: Pedant!
03:34:47 <srhb> :P
03:34:47 <Jafet> Well, it's definitely going to be faster than python
03:34:56 <Jafet> GHC 7.6 will have
03:34:58 <Jafet> ALLOYED RIMS
03:35:01 <nand`> and ruby
03:35:07 <companion_cube> languages don't have speed, but a good C++ compiler with good C++ code will probably be faster than ghc with good haskell code
03:35:21 <srhb> companion_cube: fsvo "good"
03:35:26 <timthelion> srhb: you are brilliant.  That was very well said.
03:35:28 <nand`> architectures and computers factor in too :(
03:35:37 <companion_cube> yep, let's say g++ -O2 versus ghc -O2
03:35:59 <srhb> companion_cube: I didn;t know -O was a goodness switch.
03:36:25 <tdammers> point being, both compile to machine code, so given equally good compilers, both have the potential for the maximum possible performance on a given platform
03:36:43 <srhb> But that's irrelevant since compilers are shit and you should write your application in machine code directly anyway.
03:36:50 <t7> what if i run it in the cloud?
03:36:53 <srhb> I mean, if you want speed.
03:36:59 <t7> clouds*
03:37:02 <tdammers> so the question is not "is Haskell faster than C++", but "does ghc produce faster code than g++"
03:37:12 <tdammers> (or whatever you use to compile c++)
03:37:17 <srhb> tdammers: To which the answer is "gooberlooberwaba"
03:37:21 <tdammers> ywah.
03:37:35 <tdammers> you can't compare the both of them, really
03:37:39 <nand`> srhb: if you can, sure; but I don't think anybody has the capacity to write maximally efficient machine code
03:37:41 <timthelion> companion_cube: In terms of theoretical maximum.  If the programmer does not know how many cores the target architecture has, he/she has a better hope of writting efficient paralel computation in Haskell than in C.
03:37:47 <srhb> nand`: How dare you! :P
03:38:03 <tdammers> because the languages differ so much that it is virtually impossible to come up with code samples in each that are 100% equivalent
03:38:10 <srhb> M-x optimize-assembler
03:38:25 <tdammers> timthelion: ah, but now we're arguing *developer* performance
03:38:31 <tdammers> that's an entirely different story
03:38:33 <nand`> honestly, people often say ‘write assembly for fast codez’ and while in small examples human microoptimization might produce marginally faster assembly it doesn't scale very well
03:38:54 <Shapeshifter> So now instead of parsing +-*/ I just wrote the RPN calculator like this. Seems to work ok. http://hpaste.org/73827
03:38:57 <srhb> The point is that this is a ridiculous discussion.
03:38:59 <srhb> :P
03:39:27 <nand`> Shapeshifter: personally I would factor out "+" "-" etc. into a data type
03:39:28 <tdammers> srhb: it's not entirely ridiculous
03:39:37 <timthelion> tdammers: no no no, that's not what I meant at all.  If I do not know the target architecture, it's better in terms of actuall RUNTIME preformance, to use a high level language.
03:39:42 <nand`> then separate parsing and evaluation
03:40:01 <srhb> The original question is unanswerable, and I think the only takeaway that anyone can get from following it to the end is "stuff's complex!"
03:40:14 <tdammers> timethelion: you can write the same runtime optimizations in C++, it just takes more work.
03:40:43 <nand`> timthelion: if you don't know the target architecture I don't think there's an awful lot of low level stuff you can do :P
03:41:42 <timthelion> tdammers: Not true.  If I want to write a program that will run optimally for 1core, 2cores, 3cores ... 16 cores 1000 cores.  I'd have to write an infinite amount of code in C(which is impossible).  but haskell(ghc is to stupid to do this, but theoretically can) if compiled(but not written) for all those different possibilities, outpreform C.
03:42:07 <nand`> timthelion: nonsense, all you need is an appropriately good C compiler
03:42:09 <srhb> I don't understand how that is possible.
03:42:11 <srhb> Yeah
03:42:12 <quicksilver> timthelion: "theoertically can"
03:42:19 <quicksilver> timthelion: that's just as true for C as haskell
03:42:27 <quicksilver> auto-parallelisation is very ahrd, and nobody does it well
03:42:35 <quicksilver> however if they did it wll, they could work out how to do it for C.
03:42:45 <quicksilver> certainly haskell has some inherent advantages there
03:42:46 <nand`> it certainly is easier when you don't have to worry about side effects, mind
03:43:00 <timthelion> take the "map" command, it is algebraically paralizable.  The while loop is not possible to automatically paralelize at all
03:43:06 <quicksilver> btu a sufficiently smart compiler can do it for any language.
03:43:10 <tdammers> timthelion: either your code adjusts for the architecture at runtime, or it doesn't. Whether you do it manually (e.g. in C) or automatically (through a compiler for a high-level language) doesn't change anything about it, except that doing it manually takes more effort.
03:43:29 <tdammers> you can write an auto-parallelizing 'map' in C just fine.
03:43:36 <tdammers> it just takes more time than in haskell.
03:43:44 <nand`> timthelion: but you can auto-parallelize a while loop given a sufficiently smart compiler to recognize it as an independent mapping
03:43:54 <timthelion> tdammers: but that would be done at run time, and not compile time...
03:44:16 <tdammers> you could write a compiler (or preprocessor or something) that does it compile time
03:44:27 <tdammers> but I thought we were talking about runtime tweaks
03:44:28 * frerich thinks discussions which involve things being "sufficient" in some respect are always a little... unsatisfying
03:45:04 <tdammers> hell, #define NUM_CORES = 32 would probably do.
03:45:08 <timthelion> nand`: that's a bit like saying that a computer is theoretically better at playing Go than a human(even though a calculation that would do all the calculations for that to be true would take longer than the life of the solar system/even universe)
03:45:30 <srhb> lpvb: What's the game about? :-)
03:46:35 <nand`> timthelion: but that's exactly the reason you have to be careful with these sorts of discussions; you can't make blanket statements on an entire language - if you mean to talk about current implementations I think it's important to choose your words more carefully
03:47:44 <lpvb> srhb: I want to make a voxel based game similar to voxatron. http://youtu.be/_q-xqI8Cm5A?t=00m23s
03:47:50 <lpvb> but with my own twists
03:48:07 <neothemachine> hi all, little question to tuples vs lists: is there a noticeable performance difference between using say a 4-tuple and a list with 4 elements that is also used via pattern matching in the form [x1,x2,x3,x4]? So, how much can GHC optimize in this case with such a fixed pattern?
03:48:15 <timthelion> nand`: I think that it IS true, though, that haskell allows for autoparalelization which would be computatoinally impracticable in C.  Even if GHC doesn't know how to do such a paralization, I think it's at least forseeable that a haskell compiler would do it.  C compilers will never do such a thing.
03:48:47 <neothemachine> *also/always
03:48:50 <srhb> lpvb: Looks cool!
03:49:07 <tdammers> neothemachine: I'd worry about the semantic implications more than the performance
03:49:09 <srhb> What the heck is a voxel though
03:49:19 <tdammers> if it always has to have 4 elements, invariably, then pick a tuple
03:49:23 <nand`> srhb: think like a pixel but in 3 dimensions
03:49:26 <nand`> iirc
03:49:27 <tdammers> if the size is dynamic, use a list.
03:49:37 <lpvb> 3d analogue to a pixel
03:49:39 <srhb> nand`: Aha.
03:49:41 <tdammers> yeah.
03:49:49 <tdammers> think minecraft, minus textures
03:49:58 <srhb> lpvb: I think you'd have more fun doing this in Haskell.
03:49:59 <srhb> :-)
03:50:04 <nand`> it's not uncommon to see round voxels used though
03:50:27 <lpvb> yea I was thinking about animation, and when I thought about it, each voxel that moves to a new position on the grid is an entirely new voxel
03:50:27 <tdammers> conceptually, they are cubes, but things look nicer if you round the surfaces
03:50:34 <lpvb> which sounded like Haskell
03:52:44 <neothemachine> tdammers: It should be dynamic, but with more effort I could also provide code upto 10-tuples (for most use cases that's enough) which is in the end more effort/code but quite trivial, but if the performance is similar I would also consider using lists
03:53:42 <nand`> a number of arbitrary-size but fixed-length vector libraries have had to deal with this question, I presume
03:54:28 <nand`> (not exactly this question, but a related one)
03:55:14 <tdammers> neothemachine: with 10 elements, the performance doesn't matter much either way, would be my guess
03:55:20 <tdammers> but if in doubt, profile.
03:55:44 <nand`> tdammers: it does if you repeat the calculation arbitrarily often
03:55:56 <neothemachine> tdammers: the relevant algorithm repeats this millions of times
03:56:34 <tdammers> then profile.
03:56:51 <tdammers> really, it depends what you do with the data
03:57:21 <neothemachine> hmm ok
03:59:38 <neothemachine> another question, when I'm in a list comprehension and match on something like "A b c <- l", then this filters l for A, but can I also prevent filtering and force it to crash if it finds something different then A?
04:00:13 <mauke> > [ x | Just x <- [Nothing] ]
04:00:14 <lambdabot>   []
04:00:19 <mauke> > [ x | ~(Just x) <- [Nothing] ]
04:00:20 <lambdabot>   [*Exception: <interactive>:3:0-29: Irrefutable pattern failed for pattern (...
04:00:42 <mikeplus64> huh?
04:00:44 <nand`> mauke: nice, didn't think of that
04:00:52 <neothemachine> ah eh, is that exactly what I want?
04:01:01 <nand`> neothemachine: sounds like it
04:01:10 <Jafet> join deepSeq $
04:01:36 <nand`> neothemachine: by making the match irrefutable you are preventing the usual pattern matching ‘fail’ which for lists is just []
04:01:51 <nand`> though note that
04:02:02 <nand`> > [ 3 | ~(Just x) <- [Nothing] ]
04:02:03 <lambdabot>   [3]
04:02:06 <nand`> will still not crash
04:02:32 <neothemachine> hm alright, but that's useless anyway
04:03:18 <byorgey> neothemachine: why on earth would you want to force something to crash?
04:03:34 <neothemachine> to enforce constraints
04:03:41 <neothemachine> it's an assertion
04:03:57 <neothemachine> it should never crash, otherwise it's a programming error
04:04:08 <srhb> *boggle*
04:04:31 <srhb> neothemachine: I think you're doing it wrong.
04:04:36 <byorgey> neothemachine: why not *test* to see whether all the elements of the list are A, and then do something useful if it's False?
04:04:54 <Jafet> Yeah, like crash.
04:05:04 <neothemachine> srhb: How to do it right?
04:05:22 <nand`> usually it's a better idea to statically enforce assertions rather than dynamically testing them, but I don't think this always works out very well
04:05:38 <nand`> eg. if you can change your type to use [x] instead of [Maybe x] that asserts statically you will never encounter Nothing
04:05:38 <mikeplus64> > [ case x of _ -> 3 | ~(Just x) <- [Nothing] ]
04:05:40 <lambdabot>   [3]
04:05:40 <srhb> neothemachine: What nand` said.
04:05:46 <mikeplus64> > [ case x of !_ -> 3 | ~(Just x) <- [Nothing] ]
04:05:47 <lambdabot>   [*Exception: <interactive>:3:0-45: Irrefutable pattern failed for pattern (...
04:05:53 <mikeplus64> neothemachine:
04:06:06 <nand`> > [ 3 | ~(Just !x) <- [Nothing] ]
04:06:07 <lambdabot>   [3]
04:06:14 <nand`> ah
04:06:36 <mauke> > [ 3 | ~(Just x) <- [Nothing], x `seq` True ]
04:06:37 <lambdabot>   *Exception: <interactive>:3:0-43: Irrefutable pattern failed for pattern (D...
04:06:57 <t7> > 0b1010101
04:06:58 <lambdabot>   Not in scope: `b1010101'
04:07:06 <Jafet> nand: except this code statically converts Nothing to undefined.
04:07:15 <t7> > 010
04:07:16 <lambdabot>   10
04:07:17 <byorgey> neothemachine: isA (A{}) = True; isA _ = False;  if (all isA list) then ... else ...
04:07:29 <nand`> Jafet: huh?
04:07:36 <neothemachine> let's just say: I could do it with the type system but I don't know how (as this is quite complex, maybe I'll ask about that later), so this is my compromise
04:08:21 <byorgey> neothemachine: I'm just saying that even if you want the program to immediately exit, there are much nicer ways than forcing a pattern-matching error.
04:08:22 <LordBrain> there is an assert
04:08:32 <LordBrain> debug.assert ...
04:09:01 <neothemachine> byorgey: yeah, the other way would be to put it in an assert, but I thought that this fits quite nicely
04:09:56 <byorgey> neothemachine: it's like there's a ride only for little kids, and instead of just politely telling adults they should not be in this line you put a spinning saw blade four feet off the ground
04:09:58 <LordBrain> your way seems a little devilish, but i suppose it's ok, especially if you catch the exception
04:10:29 <neothemachine> byorgey: sounds great :D
04:10:30 <frerich> byorgey: :-)
04:11:00 <LordBrain> disturbing
04:11:12 <frerich> byorgey: I'd like to steal that, I think I could put it to use in some internal discussions here...
04:12:16 <frerich> It reminds me of another comparison I like to use - "unsafeCoerce is like cutting your toe nails with a chainsaw. It works, but you darn better know what you're doing."
04:12:59 <LordBrain> we all think we know what we are doing tho.
04:13:02 <LordBrain> :)
04:14:46 * byorgey licenses all his utterances in #haskell under a CC-NonCommercial-Attribution license
04:15:19 <byorgey> actually, I don't even care about attribution
04:15:28 <byorgey> but if you make money off of something I said I want a cut ;)
04:15:48 <LordBrain> maybe you could use nonempty
04:16:22 <tdammers> CC-YourFirstbornBelongsToMe-Attribution-Sharealike
04:17:36 <LordBrain> is the list comprehension notation overloadable?
04:17:56 <atriq> LordBrain, I think there's MonadComprehensions?
04:17:59 <merijn> LordBrain: I think it just uses toEnum and fromEnum
04:18:07 <merijn> LordBrain: So it'll work for any instance of Enum
04:18:12 <behelit> hi guys. looking to parse a string in the format "01:12:30 <<>> 02:13:32", i want to retrieve the hours, minutes and seconds. any scanf like modules out there or some other useful technique?
04:18:16 <atriq> merijn, no, that's something else
04:18:29 <nand`> merijn: that's enumeration, not comprehension
04:18:35 <LordBrain> great, then maybe neothemachine could use Data.List.NonEmpty ?
04:18:39 <merijn> hmm
04:18:52 <nand`> and yes, list comprehensions can be overloaded to all monads; but it needs MonadPlus for guards
04:18:55 <hpc> behelit: there's some regex libraries, but i don't really like any of them
04:19:03 <nand`> and something else like MonadZip for parallel comprehensions
04:19:05 <hpc> there's parsec, which might be a bit overkill for this
04:19:33 <merijn> behelit: Usually people straight up pattern match the string (might be a bit slow, then again, might not be a problem), otherwise they tend to grab parsec/attoparsec
04:19:52 <nand`> sometimes ‘read’/‘words’ is all you need
04:19:59 <nand`> but that's more ‘quick and dirty’
04:20:06 <hpc> i think i would use takeWhile also
04:20:53 <behelit> merijn: how would you pattern match that in haskell? seems like it would be a long pattern (h11:h12:m11:m12:s11:s12:' ':'<':'<' ... )
04:21:20 <behelit> and then code to combine h11+h12 and parse the integer value
04:21:39 <nand`> yes that would be an ugly pattern match
04:22:01 <behelit> can you do something like binary pattern matching in erlang?
04:22:09 <nand`> case words x of [x, "<<>>", y] -> ... could be used
04:22:25 <behelit> <<X:bytes, ":" ...>>
04:22:28 <nand`> maybe mix in view patterns to do the parsing right off the bat
04:22:35 <hpc> ooh, that's a good one
04:22:58 <hpc> case words x of [before, "<<>>", after] -> (parseTime "whatever" before, parseTime "whatever" after)
04:23:23 <hpc> http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Format.html#v:parseTime
04:23:51 <behelit> yeah, that would work.
04:23:52 <hpc> that gives you real time values
04:24:00 <behelit> much obliged
04:24:03 <hpc> np
04:34:11 <tmhz> If anyone knows about Yesod. I am trying so get all rows from a database using "getCoors = runDB $ selectList [] [Desc DistCoorTime]" but I can not seem to get it to compile. I am getting errors like "No instance for (PersistQuery (YesodPersistBackend master0) (GHandler sub0 master0)) arising from a use of `selectList' Possible fix: add an instance declaration for (PersistQuery (YesodPersistBackend master0) (GHandler sub0 master0))
04:34:11 <tmhz> the second argument of `($)', namely `selectList [] [Desc DistCoorTime]' In the expression: runDB $ selectList [] [Desc DistCoorTime] In an equation for `getCoors': getCoors = runDB $ selectList [] [Desc DistCoorTime]"
04:34:27 <tmhz> Sorry I should have split that up
04:34:39 <tmhz> getCoors = runDB $ selectList [] [Desc DistCoorTime]
04:34:43 <merijn> tmhz: Maybe pastebin the responsible code + error at hpaste.org?
04:35:06 <tmhz> merijn: ok thanks
04:36:13 <hpaste> tmhz pasted “Yesod database select” at http://hpaste.org/73828
04:43:34 <boom_cakes> hello
04:43:50 <boom_cakes> anyone know how to show a variable type in a let do expression?
04:43:51 <neothemachine> is there a tree data structure, where I can define a different type for each level? obviously it's a fixed-level tree then
04:45:14 <merijn> boom_cakes: What do you mean by "show a variable type"?
04:45:37 <boom_cakes> print out the data type to stdout
04:45:48 <merijn> neothemachine: I don't think that exists, but you should be able to write one
04:45:59 <neothemachine> boom_cakes: don't know if you're a hard-core emacs guy, but if not, then have a look at EclipseFP, I found it quite nice for a beginner to hover over stuff and see the types
04:45:59 <t7> boom_cakes: error $ show foo
04:46:09 <boom_cakes> something like: showType(a) => "[Char]""
04:46:10 <mikeplus64> neothemachine: just a bunch of tuples?
04:46:18 <t7> no wait
04:46:24 <t7> ignore me
04:46:24 <byorgey> merijn: that doesn't work for locally bound identifiers though, does it?
04:46:48 <fmap> > typeOf 3
04:46:49 <lambdabot>   Integer
04:46:51 <byorgey> boom_cakes: for local things, the only way I know is with the ghci debugger.  step until the thing is in scope, then you can ask for its type
04:47:20 <merijn> boom_cakes: You can probably write something like that using "Data.Typeable"?
04:47:48 <boom_cakes> merijn: coolio, Ill give it a look
04:48:26 <merijn> boom_cakes: fmap already partially spoiled the solution using typeOf
04:48:38 <merijn> > typeOf $ Just ()
04:48:39 <lambdabot>   Maybe ()
04:48:47 <mauke> > show (typeOf "hi")
04:48:48 <lambdabot>   "[Char]"
04:48:56 <boom_cakes> awesome!
04:49:01 <boom_cakes> many thanks, everyone!
04:49:12 <boom_cakes> typeOf is what I was looking for!
04:49:14 <neothemachine> mikeplus64: hmmmm sounds logical, I'll think about it
05:10:10 <ozgura> is there a quickcheck test suite to check the laws for common type class instances; such as functor, applicative, monad and such?
05:13:54 <Jafet> Arbitrary (a -> b) sounds tricky
05:15:12 <danr> ozgura: did you have a look at http://hackage.haskell.org/package/ClassLaws? related publication: http://www.cs.uu.nl/research/techreps/repo/CS-2012/2012-008.pdf
05:15:43 <ozgura> danr: no I haven't. I am checking it out now, thanks!
05:16:03 <oneb> I've defined (x = unsafePerformIO $ readFile "bla.txt") in a file, btu when I change the contents of "bla.txt" and :r, x still contains the old contents. Any way to make it reread the file?
05:16:25 <Botje> nope
05:16:46 <Botje> that's what you get with unsafePerformIO.
05:17:45 <merijn> Botje: Actually, that's what you get with ghci
05:25:39 <oneb> hah, problem solved, make it a function "x ()" instead of just "x" and the file will be reloaded
05:26:58 <fmap> you mean `() -> x' ?
05:27:36 <oneb> yeah I guess, defined "x () = ..." instead of "x = ..." and refer to "x ()" instead of "x"
05:29:05 <srhb> oneb: *shudder* :-)
05:29:13 <oneb> :)
05:38:34 <int-e> oneb: this works until the optimizer gets to work on your function and floats out the /constant/ "..." part.
05:41:43 <mauke> ... I think I know how to write scanf in Haskell
05:43:18 <statusfailed> mauke: as in the opposite of printf?
05:43:25 <mauke> well, sort of
05:43:26 <statusfailed> coprintf?
05:43:30 <ksf> mauke, look into the "fun with type functions" paper?
05:43:34 <mauke> scanf isn't really the opposite of printf
05:44:35 <ksf> but really, parser combinators are preferrable to scanf in every way.
05:44:55 <ksf> and if it's just a clearer way to attach semantics to the grammar.
05:45:09 <mauke> ksf: strongly disagree
05:51:34 <merijn> How do I tell GHC to compile a named module to an executable?
05:52:29 <fmap> -main-is?
05:52:31 <quicksilver> ghc Path/To/Module/Source.hs
05:52:34 <mikeplus64> merijn: --make ?
05:52:38 <mauke> grr. get back here, ksf!
05:52:39 <mikeplus64> heh
05:52:41 <quicksilver> ghc --make Path/To/Module/Source.hs
05:52:47 <mauke> --make is on by default
05:52:55 <quicksilver> unless he has an old ghc
05:53:15 <quicksilver> -main-is only necessary for fancier tricks like using a different main name or not passing the name of the main module, AFAIK
05:53:34 <quicksilver> if you supply a module source file then that is the 'main' module even if it's name isn't Main
05:53:37 <quicksilver> IIRC
05:58:36 <merijn> quicksilver: Well, I don't end up with an executable when I run "ghc Foo.hs" or "ghc -main-is main Foo.hs"
05:59:24 <statusfailed> merijn: I do? Given that Foo.hs has a "main" function...
05:59:47 <merijn> statusfailed: Does your Foo.hs have a "module Foo where" line?
05:59:57 <statusfailed> I will test
06:00:02 <statusfailed> I thought I could do that though
06:00:18 <statusfailed> nope :)
06:00:35 <statusfailed> my bad
06:00:45 <merijn> When I remove the module line it compiles an executable, but that won't let me use the same source file for building a library
06:01:14 <quicksilver> merijn: you need --make if it's not a recent ghc
06:01:17 <quicksilver> otherwise, I'm confused.
06:01:22 <merijn> It's 7.04 or something?
06:01:32 <merijn> yup, 7.0.4
06:01:34 <statusfailed> I'm on 7.4 and it does exactly the same thing
06:01:41 <tdammers> merijn: move the stuff from Foo.hs to somewhere else and add a super-simple Main.hs that imports it?
06:01:56 <merijn> It works if there's no module line, but refuses to compile an executable with it
06:01:56 <tdammers> nm
06:01:57 <statusfailed> ahh
06:02:04 <statusfailed> merijn: ghc -main-is Foo.main FOo.hs
06:02:09 <statusfailed> gotta say which module main is in
06:02:23 <merijn> tdammers: Sure, but take offense to having to add a "main.hs" with just one line of "main = Foo.main"
06:02:41 <merijn> \o/
06:02:46 <merijn> statusfailed++
06:02:50 <statusfailed> fuck yeah :D
06:03:04 <statusfailed> gotta remember this
06:03:28 <Shapeshifter> How can I break a case expression on a long line without having to indent all cases far to the right? e.g. "let (wordLength, width, height) = case map read args of [w, h, n] -> (n, w, h)" means putting the next pattern very far to the right just after the "of". How can I put everything more to the left?
06:04:13 <quicksilver> I was sure GHC used to run 'main' from any module, not necessarily called Main
06:04:22 <quicksilver> (as a small extension which was documented somewhere)
06:04:30 <statusfailed> Are you allowed multiple modules per file?
06:04:30 <Botje> Shapeshifter: put a newline after the of.
06:04:36 <quicksilver> maybe they took it out for consistency
06:04:46 <Botje> Shapeshifter: the cases should be indented more than the 'case' keyword
06:05:45 <quicksilver> Botje: more than the ( of (wordLength is enough, in fact
06:05:51 <statusfailed> Shapeshifter: I think you can put "case" on a newline  too
06:05:53 <beyeran_> did anyone try to install darcs on archlinux?
06:07:08 <Shapeshifter> Botje, statusfailed: nope, neither works: http://hpaste.org/73832
06:07:31 <statusfailed> beyeran_: I have it installed, but I don't remember installing it :P
06:07:35 <Shapeshifter> It only works if the case is on the same line as the = and the additional patterns are indented further than the "of"
06:07:44 <statusfailed> beyeran_: I may have used cabal, don't remember
06:07:53 <Botje> Shapeshifter: make sure you're not mixing tabs and spaces.
06:08:04 <merijn> Shapeshifter: That's because in your second example you have the first pattern on the same line as case of
06:08:06 <beyeran_> statusfailed: yes, I'm struggling for hours now, something always fails
06:08:14 <Shapeshifter> Botje: I only using spaces, as in the pastebin
06:08:18 <merijn> Shapeshifter: All patterns should *always* be indented equally
06:08:38 <merijn> Shapeshifter: Having one pattern follow the case-of means all patterns should be indented that far
06:08:51 <merijn> Hence why you should line break after of
06:09:03 <Shapeshifter> merijn: yes, my question was, how do I get everything further to the left. Where can I break - before the case for example, so I don't have my patterns that far right.
06:09:09 <Shapeshifter> ah
06:09:13 <statusfailed> beyeran_: using cabal?
06:09:18 <quicksilver> Shapeshifter: you can break before case if you want
06:09:26 <quicksilver> Shapeshifter: you just went too far to the left
06:09:40 <quicksilver> Shapeshifter: in your third example case needs to be at least one space to the right
06:09:54 <quicksilver> otherwise it starts another 'defn =' part of that let
06:10:03 <Botje> Shapeshifter: annotated your paste
06:11:35 <Shapeshifter> Ah, I see. Thanks. But I'm not sure I understand it. I have to indent 'case' 5 to the right from 'let' so it isn't treated as part of the let expression?
06:12:45 <Shapeshifter> nevermind, I'll read some docs about indentation in haskell...
06:12:54 <beyeran_> statusfailed: using cabal, using aur, even trying cabal2arch (what is redundant, but I was desperate ^^)
06:13:07 <Botje> Shapeshifter: more indentation = open {, less indentation = close }, same indentation  = ;
06:13:21 <statusfailed> beyeran_: cabal up to date?
06:13:30 <Botje> if you don't indent the case you get let (...) = ; case ... of { ... }
06:13:36 <beyeran_> statusfailed: yes
06:13:39 <statusfailed> dammit
06:13:46 <Botje> whereas you want let (...) = { case ... of { ... } }
06:13:57 <statusfailed> Have you got arch linux haskell libs installed? i.e. haskell-platform?
06:14:17 <statusfailed> I'm just wondering if it's an issue with dependencies. Can you post the error with cabal?
06:15:03 <Shapeshifter> Botje: but the thing is, it's not enough if "case" is indented further than "let", it needs to be indented further than the first expression of the let, that's what got me.
06:15:34 <statusfailed> Shapeshifter: if it's indented at the same level as (wordLength, then it's seen as a second let expression
06:15:45 <statusfailed> like you were trying to do "let case map read args of"
06:16:25 <beyeran_> statusfailed: there are some dependency issues with aur for sure, he claims dependencies which don't exist in aur (haskell-hashed-storage e.g.) and if I build it by myself the version is wrong
06:16:34 <beyeran_> statusfailed: ok, I'm trying cabal again
06:17:05 <statusfailed> beyeran_: Try to remove any arch linux haskell packages other than GHC- they aren't supported anymore afaik
06:19:04 <ique> I'm trying to read in 25M doubles into an unboxed vector, but I get this error message at runtime: "memory allocation failed (requested 2097152 bytes)"
06:19:18 <merijn> :t \f -> (fmap f Prelude..)
06:19:19 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
06:19:20 <ique> adding +RTS -A128M (or larger) doesn't seem to make a difference
06:19:59 <merijn> @pl \f -> (fmap f Prelude..)
06:19:59 <lambdabot> flip fmap Prelude..
06:20:50 <statusfailed> ique: sample code? I don't think I'd help, but I fancy reproducing it :P
06:21:10 <merijn> :t flip fmap (Prelude..)
06:21:11 <lambdabot> forall b b1 c a. (((a -> b1) -> a -> c) -> b) -> (b1 -> c) -> b
06:21:19 <merijn> That doesn't look right?
06:21:51 <ique> statusfailed: hold on, copy pasting it together
06:24:06 <ique> statusfailed: This is the code, but the matrix file with all the data is 400MB (containing 25 million values) http://hpaste.org/73836
06:24:51 <ique> setting the allocation size to >1GB produces the same error message that it can't allocate 2MB
06:25:27 <beyeran_> beyeran_: ok
06:25:30 <beyeran_> statusfailed: ok
06:26:16 <byorgey> ique: note, I think that's just the size of the final request that failed
06:26:18 <beyeran_> statusfailed: there was a linking error with collect2: ld returned 1
06:26:43 <ique> byorgey: hmm i see
06:26:54 <byorgey> ique: so if it requests 100GB in 2MB increments you would see that same error no matter what size you made the heap under 100GB
06:27:21 <neothemachine> when I depend on a library where I need to set a flag (because the author didn't separate the extra feature into an own package), do I just put that flag next to the others of my own project when calling cabal build?
06:28:18 <neothemachine> hm wait, I have to install that package already with the flag, right?
06:29:20 <neothemachine> so, I guess I can't specifify in my build-depends that I depend on a package with a specific flag?
06:30:05 <byorgey> neothemachine: good question, I don't know.  Certainly 'cabal build' won't work because that requires all dependencies to be already installed.  But as for e.g. 'cabal install'  I don't know whether flags are transitive
06:30:20 <byorgey> and I don't know whether you can specify it in your build-depends
06:30:36 <byorgey> try something like pkg:flag and see if it works
06:30:50 <byorgey> ique: I don't really know what the consequences are of going through a list data structure on the way to a Matrix
06:31:20 <byorgey> ique: you should try compiling with profiling turned on and see what's allocating the memory
06:32:17 <ique> byorgey: me either.. it works fine with around 6M items.. reading from file is just a temporary thing to test my algorithm, where in the future it will read from a database.. but i guess if it can't handle the larger sets i'll have to try to make it run a bit better
06:32:59 <ique> what is the highest memory you can allocate with -A?
06:33:46 <byorgey> i.e. compile with -prof -auto-all -rtsopts  and then run with  +RTS -hc  or  +RTS -hc  or  +RTS -p
06:33:55 <byorgey> I don't know, check the manual
06:35:37 <ivanm> neothemachine: the way Cabal is defined, you can't depend upon other packages being built with certain flags
06:35:57 <ivanm> flag usage isn't meant to affect the API
06:36:06 <dcoutts_> packages are not supposed to change their interface based on flags
06:36:17 <dcoutts_> if they do, complain to the package author
06:36:40 <neothemachine> yeah I know, but if install the package with the flags manually, would it at least work then?
06:36:41 <ivanm> dcoutts_: how can I work out why cabal-install keeps complaining that one package (regex-base) is using an old version of mtl when everything that transitively uses it is built with a newer version?
06:36:47 <ivanm> neothemachine: yes
06:36:54 <ivanm> should do
06:37:12 <dcoutts_> ivanm: does it depend on the old mtl?
06:37:47 <ivanm> dcoutts_: I have one installed in the global db that deps on the old mtl, and one installed in my user db that deps on the new one
06:38:07 <ivanm> (can't be bothered bumping exherbo's packages atm to have system packages use new mtl)
06:38:20 <neothemachine> dcoutts_: it's http://hackage.haskell.org/package/monadiccp and unfortunately they don't work on it anymore and there's no public repo, it's all a bit difficult to contribute..
06:38:35 <dcoutts_> ivanm: older cabal get confused by the same version being in both global and user dbs, because it only looked at the version, not the full package id (ie including that hash)
06:38:43 <ivanm> dcoutts_: I'm using 0.14
06:40:29 <ivanm> neothemachine: they don't check the bug tracker?
06:40:46 <dcoutts_> ivanm: looks like it's doing the correct check, using full package id
06:41:38 <dcoutts_> ivanm: ok, so you're saying that you do have a situation where it's depending on two different instances of the same package?
06:41:41 <neothemachine> ivanm: probably not http://trac.haskell.org/monadiccp/ it's not working ATM, but last time it was full of spam
06:41:58 <ivanm> dcoutts_: well, that's what it claims
06:42:00 <dcoutts_> ivanm: because you said it's depending on one from the global and one from the user, right?
06:42:07 <ivanm> AFAICT, yes
06:42:16 <ivanm> even though I'm not using regex-* in my package
06:42:18 <dcoutts_> ivanm: ok, so it's doing the correct thing then right
06:42:27 <ivanm> the only place I can figure it coming from is pandoc
06:42:28 <dcoutts_> ivanm: that doesn't matter
06:42:46 <ivanm> and I've rebuilt pandoc, so it should be using the local version of regex-base, shouldn't it?
06:43:34 <dcoutts_> ivanm: I don't think there's any guarantee of that
06:43:58 <dcoutts_> if both are available and non-broken, I think the solver will consider both
06:44:00 <ivanm> dcoutts_: wait, it seems that both the global and local installs of regex-base (using different versions of mtl) have the same id :/
06:44:19 <ivanm> shouldn't they have different hashes because of different deps?
06:44:24 <ivanm> or doesn't the hashing work that way?
06:44:24 <statusfailed> ique: doing some clustering?
06:44:27 <dcoutts_> ivanm: mm, that'd be particularly bad
06:44:41 <dcoutts_> ivanm: do they have different deps?
06:44:41 <ique> statusfailed: indeed I am, how did you figure? :P
06:44:51 <statusfailed> I did a PAM implementation recently :P
06:45:04 <ivanm> dcoutts_: yup, mtl is different
06:45:05 <statusfailed> saw "dissimilarity matrix" and just assumed :)
06:45:11 <ivanm> 2.0.1.0 vs 2.1.2
06:45:18 <dcoutts_> ivanm: we'd need full details on it, bug report etc
06:45:36 <ivanm> dcoutts_: https://gist.github.com/3498123
06:46:00 <ique> statusfailed: aahh, ofc :D
06:46:37 <carpi> is it true that haskell uses computation contexts to perform or rather do things it "cannot" or is "not meant" to do?
06:47:08 <ivanm> carpi: come again?
06:47:15 <mauke> carpi: what's a computation contexts?
06:47:17 <rosie> How can I include blaze in my project? After installing blaze and adding it as a dependency in my project.cabal file, I see "Loading package blaze-html-0.5.0.0 ... linking ... done." when I run cabal-dev ghci, but then when I load the module, I get the error: Could not find module `Text.Blaze.Html5.Attributes'.    It is a member of the hidden package `blaze-html-0.5.0.0'..    Perhaps you need to add `blaze-html' to the build-depends in yo
06:47:18 <rosie> .cabal file.
06:47:48 <ivanm> rosie: so add blaze-html to the .cabal file
06:48:01 <ivanm> oh, is that what you meant by just "blaze" ?
06:48:02 <byorgey> ivanm: rosie just said it is already added.
06:48:08 <carpi> ivan: mauke : there's a word for it in haskell.. other languages like F# like to call it a computation context..
06:48:09 * ivanm has never used cabal-dev
06:48:11 * dcoutts_ is coming to the conclusion that cabal-dev ghci is just too hacky
06:48:19 <mauke> carpi: what is the word?
06:48:21 <byorgey> it is rather hacky.
06:48:29 <ique> statusfailed: did you do it in haskell? i've gotten my version roughly comparable to C in speed now, but that's still extremely slow for large datasets
06:48:31 <ivanm> byorgey: he said he added _blaze_ as a dependency, not blaze-html... didn't twig at first that they're one and the same
06:48:37 <byorgey> dcoutts_: isn't there a 'cabal ghci' coming down the pipeline?
06:48:44 <statusfailed> ique: nope, native R actually...
06:48:44 <dcoutts_> byorgey: yes! :-)
06:48:45 <carpi> mauke: mondas
06:48:48 <byorgey> ivanm: oh, fair
06:48:48 <carpi> *monads
06:49:01 <statusfailed> ique: It is horribly slow for large datasets though
06:49:01 <mauke> carpi: then no
06:49:02 <rosie> ivanm and byorgey: sorry, I added "blaze-html"
06:49:06 <byorgey> carpi: no, it is not true that Haskell uses monads to do things it cannot do
06:49:11 <statusfailed> ique: I think it's O(n^3) isn't it?
06:49:14 <ique> statusfailed: agh i see.. yeah..
06:49:31 <ivanm> carpi: I fail to see how something can have a way of doing things it can't do
06:49:38 <ivanm> if it can't do it, how can it have a way of doing it? ;)
06:49:45 <byorgey> @faq can Haskell not use monads to do things it cannot do?
06:49:45 <lambdabot> The answer is: Yes! Haskell can do that.
06:50:09 <byorgey> dcoutts_: \o/
06:50:24 <ique> statusfailed: I believe it's O(n^2) but with k involved in the coefficient
06:50:50 <statusfailed> ique: I think you're going to be near the limits of memory doing a 5000x5000 matrix though
06:51:06 <statusfailed> ique: wait. that might be stupid...
06:51:08 <carpi> byorgey: but IO is performed in a monadic context ..
06:51:08 <statusfailed> :P
06:51:10 <ivanm> dcoutts_: is that output from ghc-pkg enough of a bug report, or do you need more?
06:51:17 <tdammers> @faq can Haskell not use non-monads to not do non-things it cannot not undo?
06:51:17 <lambdabot> The answer is: Yes! Haskell can do that.
06:51:22 <tdammers> wow.
06:51:29 <dcoutts_> ivanm: that's good, can you file the ticket
06:51:34 <byorgey> carpi: and Haskell can do IO.
06:51:36 <statusfailed> ique: how many vectors do you have? 5K, right?
06:51:50 <ivanm> dcoutts_: for Cabal of GHC?
06:51:58 <ique> statusfailed: no, i do indeed think that 5k matrix is near what my computer can do :P i have 8gb memory but only 3 free right now so i guess i am running out of heap
06:52:06 <ique> statusfailed: yeah 5k boxed and 5k unboxed
06:52:09 <mauke> carpi: not necessarily
06:52:22 <mauke> carpi: main = putStr "Hello, world\n"  -- no monads here
06:52:22 <dcoutts_> ivanm: for Cabal
06:52:24 <ique> statusfailed: but it's obviously stupid of me to not use a triangular matrix at least
06:52:32 <statusfailed> ique: You could always compare to the R implementation. I seem to remember running into problems around the 5K mark and that's on a 16GB machine
06:52:41 <byorgey> carpi: monads are not magical.  They are a convenient way to structure certain patterns of computation.  But they are not a magical "escape hatch".
06:52:42 <ivanm> dcoutts_: OK, I'll do it when I get up
06:52:44 * ivanm needs sleep
06:53:08 <byorgey> carpi: IO is the only somewhat magical monad; but Haskell could still have IO without monads
06:53:13 <dcoutts_> ivanm: ta
06:53:15 <byorgey> carpi: in fact, it used to!
06:53:25 <ique> statusfailed: oh wow.. i was thinking a double is 64bit, 25M*64bit = 200MB
06:53:41 <statusfailed> ique: yeah that's why i'm confused...
06:53:45 <carpi> byorgey: "convenient way to categorise certain kinds of computations" .. am i close ?
06:53:48 <byorgey> dcoutts_: oh, btw, I notice (to my surprise) that I have push access to the cabal repo on github.  does that mean I can/should merge (minor) pull requests and such?  what's the policy on that?
06:53:53 <ique> statusfailed: but of course that would just be pure memory storage and not any haskell-related thunks or list stuff
06:53:55 <byorgey> dcoutts_: or am I not supposed to have push access?
06:54:08 <ivanm> and I also have to work out why my attempt at having graphviz be clever about dot, neato, etc. not being installed isn't working :s
06:54:12 <statusfailed> ique: but from 200M to 8GB seems ridiculous :\
06:54:22 <statusfailed> I know I figured out what was going on before... :P
06:54:22 <byorgey> carpi: close to what?
06:54:39 <dcoutts_> byorgey: you can push directly if you think it needs no further review, or you can ask for review from someone else
06:54:44 <ique> statusfailed: yeah, that's why I was thinking it was a compiler-problem at first, not allowing it to allocate enough or something
06:55:05 <carpi> byorgey: close to your defintion or maybe a more accurate description of a monad?
06:55:17 <byorgey> dcoutts_: ok
06:55:38 <rosie> ivanm: I can't seem to find and documentation on _blaze_ rather than "blaze-html". I'm using the install instructions on http://jaspervdj.be/blaze/tutorial.html, but I get the error I posted. Where should I look to find better documentation?
06:55:40 <statusfailed> ique: I have to go for now, but if I remember why i will get back to you :P
06:55:58 <ivanm> rosie: no, that's right
06:56:01 <ique> statusfailed: thanks :)
06:56:05 <ivanm> rosie: the error is with cabal-dev methinks
06:56:06 <statusfailed> np, good luck :)
06:56:14 <ivanm> but as I said, I've never used it, so can't help you
06:56:29 <byorgey> carpi: I don't know what you mean by "categorise"
06:56:31 <rosie> ivanm: Thanks. Any ideas where I should sep help?
06:56:34 <rosie> *seek
06:56:37 <ivanm> rosie: here? :)
06:56:43 <rosie> ivanm: haha
06:56:45 <byorgey> carpi: do you know the definition of the Monad type class?
06:57:04 <ivanm> carpi: the definition of Monad in the Haskell Report is the definition of Monad... (modulo fail)
06:57:36 <byorgey> carpi: if not, I suggest you start there instead of trying to figure out what monads "are" or what they are "for"
06:58:27 <ivanm> RWH's approach to Monads was good: "hey look, we've just done a whole bunch of really similar looking stuff; why not package it up as a type class and get some nice syntactic sugar to go with it!"
06:58:32 <ivanm> *good IMHO
06:58:43 * ivanm -> land of nod
06:59:26 <carpi> byorgey: yes.. i think i am jumping ahead of myself.. this is my second stint with haskell. The first being a few months ago when i decided to give up. somehow i find myself sucked into it. How did you learn it? Maybe i can help myself by learning it the way you did..
06:59:59 <byorgey> carpi: I learned it by reading as much as I could from as many sources as possible and playing around with it a lot
07:00:20 <hiptobecubic> carpi, force it.
07:00:20 <byorgey> in fact, I am still learning it.
07:00:47 <hiptobecubic> carpi, when you have some little problem and you think "i could solve this in two minutes using language X, use haskell anyway and blow 2 hours on it"
07:01:15 <carpi> and was it worth it? did it make your life easier? what made you want to learn it in the first place if i may ask?
07:01:30 <hpaste> Rose pasted “blaze” at http://hpaste.org/73837
07:02:01 <rosie> When I create a blaze test file not in my project, I can load it into ghci fine. How do I run it?
07:02:09 <byorgey> carpi: it was worth it twenty times over
07:02:34 <byorgey> carpi: I don't know if it made my life *easier* but it certainly made my life far more *interesting* =)
07:02:39 <byorgey> (in a good way)
07:03:09 <byorgey> carpi: I wanted to learn it in the first place because it looked different and beautiful and fascinating.  I just got sucked in.
07:03:42 <byorgey> one day I read some mention of it on a blog, and six months later I was reading reaseach papers =)
07:04:13 <carpi> research papers? the documents on the website weren't enough?
07:05:01 <byorgey> no, the high starts wearing off more and more quickly, and you start getting into the harder stuff, you know?
07:05:16 <byorgey> ;)
07:06:09 <merijn> carpi: It took my 5 attempts before haskell "stuck" :p
07:06:35 <Shapeshifter> carpi: I'm on my third try and this time I think it's gonna stick
07:06:36 <tdammers> I'm a victim of the number 1 gateway drug
07:06:42 <tdammers> xmonad.
07:06:58 <merijn> My gateway drug was python list comprehensions and generators :p
07:07:01 <carpi> I don't mind getting stuck to haskel )
07:07:15 <carpi> by 5 attempts you mean.. on and off with significant intervals in between each attempt?
07:07:36 <merijn> carpi: I mean I started learning 5 times spread out over a year or 2
07:07:48 <merijn> The 5th time things finally went *click*
07:07:57 <neothemachine> right... note: haskell platform on windows is 32 bit... that's why it couldn't load the additional 64 bit library..
07:09:42 <merijn> carpi: I find concurrent programming is a good way to ease into haskell, since it's just so much easier in haskell then any other language
07:09:57 <carpi> merijn: including golang?
07:10:01 <merijn> Yes
07:10:24 <rosie> has anyone used blaze-html?
07:10:30 <merijn> Go is neat, but not nearly as convenient as haskell
07:10:40 <thirsteh> merijn, capi: I find STM/TVars nicer (although maybe not as fast) than CSP-style channels
07:10:49 <thirsteh> (which is what Go has)
07:10:54 <merijn> carpi: forkIO is essentially goroutines, but in haskell you also get STM
07:11:15 <thirsteh> but I also love Go for I/O-heavy stuff, or for big projects (when I have to read/work with other people's code)
07:11:19 <merijn> (And of course Chan/BoundedChan mimics go's channels)
07:11:35 <MoALTz> just been playing with peano numbers and co. was fun defining a scheme that supports negative numbers.
07:12:36 <thirsteh> I imagine there are a million ways to write a bad Haskell program. Not so much in Go, since its syntax/facilities are extremely restrictive
07:12:45 <merijn> carpi: Have you looked at STM yet? If not it's interesting place to start looking after mastering basic haskell
07:12:54 <thirsteh> (and that's good for big projects, IMO)
07:12:55 <donri> edwardk: hey does machines solve the same problems as pipes or is the similarity more limited?
07:13:08 <thirsteh> STM is really elegant
07:13:41 <thirsteh> or rather, database transactions are elegant :)
07:14:22 <edwardk> machines do both more and less than pipes. it is easier to make multiple input machines or to block on multiple inputs, and it has better asymptotic characteristics, but pipes can compose and then >>= the result
07:14:33 <carpi> merijn: haven't look at STM yet. I don't think i've mastered 15% of haskell. So I don't think I can go there yet.
07:15:44 <merijn> carpi: By mastering basic haskell I mean: 1) (most/basic) type signatures no longer scare you 2) you kinda get Monad/Functor/Applicative 3) played around with maybe, either and state monads
07:15:45 <thirsteh> carpi: it's extremely approchable IMO. TVars are shared "references" that can be updated even when you have multiple threads, without having to worry much/at all about locks
07:16:14 <thirsteh> I'm a complete Haskell noob, and I'm using TVars. I don't even really know what an MVar is yet
07:16:29 <edwardk> thirsteh: wake me when both the little exception mechanism they use internally and templates are in, usable and first class. until then go is a huge step backwards. as it stands it strikes me as frankly a rather amateurish effort given the people involved.
07:16:43 <carpi> thirsteh: are you following any document?
07:17:06 <thirsteh> carpi: the Real World Haskell chapter on STM, I think it's the last one, was great
07:17:19 <donri> edwardk: plan for happstack 8 is to rewrite the server with pipes. i'm curious if machines would be similarly/better sutied still?
07:17:23 <donri> suited
07:17:47 <edwardk> for right now? pipes has a better story about dealing with leftovers in the pipe and for dealing with resource deallocation.
07:17:58 <donri> aye
07:18:00 <edwardk> i still think those are critical for decent web development.
07:18:11 <thirsteh> edwardk: but they take pride in being "amateurish", they just call it "simplistic". I can see why most Haskell users will have a problem with the language. Rob Pike wrote a good post about it. Haskell is pretty akin to C++: http://commandcenter.blogspot.se/2012/06/less-is-exponentially-more.html
07:18:13 <carpi> thirsteh: but that book was written in 20008. still relevant?
07:18:14 <edwardk> in machines i'm looking at rather different ways to support them
07:18:29 <donri> i think pipes doesn't do leftovers yet, although tekmo has the design ready and just polishing the code
07:18:54 <thirsteh> carpi: yes. The only thing I didn't understand right away was when you have to use retry; answer is you don't have to--everything is automatically retried if the state changes during a transaction
07:19:36 <thirsteh> edwardk: by that I mean you can switch out "C++" with the word "Haskell" in his post. Don't hit me please... :)
07:20:00 <edwardk> thirsteh: my problem with go is similar to my problem with plan 9, the things they understand they just say they were doing in the 70s, the things they don't understand they dismiss as unnecessary. as almost everything i do falls in the area dismissed as unnecessary, i find little reason to write go. ;)
07:20:09 <thirsteh> edwardk: the authors never opposed generics; it's just not there because it's "notoriously hard to get right"
07:20:41 <thirsteh> edwardk: makes sense. Haskell and Go are two at opposite ends of the spectrum IMO
07:20:42 <edwardk> thirsteh: yes. but i find it frankly rather embarassing to shi a language and tout its use without them. you write a ridiculous amount of boilerplate in go as a resut
07:20:50 <edwardk> er ship
07:21:14 <thirsteh> edwardk: you very rarely need polymorphic functions, though. Most of the generic stuff can be solved with (Java-style) interfaces
07:21:29 <thirsteh> edwardk: it's like a good Java, or a good C, not an innovation in PL theory
07:21:37 <thirsteh> by design
07:21:45 <edwardk> it encourages a very 70s cut-and-paste development style for dealing with channels, etc. you can't even write something like erlang's OTP for go even if you want to
07:22:24 <merijn> edwardk: Sure, I agree it's a step back from Haskell and Erlang, but I still think it's a step up from Java/C/C#
07:22:48 <merijn> So I'd rather do money-oriented programming in Go than in Java/C/C#
07:23:10 <edwardk> thirsteh: i leave you to your world in which you can work without polymorphic functions. in my experience, working without them is a recipe for disaster. polymorphism saves you from yourself. If you have a function a -> b -> a, you can immediately know what it is and that your code is correc.t given a function Int -> Int -> Int you have no such guarantees, moreover, if you need to flip the function, you need to do something one-off
07:23:31 <thirsteh> I'd rather do money-oriented programming in Haskell, but it becomes a problem when you have to work with people that aren't as good, or even as interested, in programming as you are
07:23:37 <thirsteh> most industry programmers just write really shitty Java
07:23:37 <edwardk> i'd rather write c#. i at least have generics there and i have an ecosystem of libraries
07:24:00 <thirsteh> Go is perfect for working with any programmer, rather than just good programmers/comp.sci ph.ds
07:24:11 <edwardk> you hardly get anywhere by comparing what you are doing to the behavior of the mean population ;)
07:25:02 <hiptobecubic> ooo, a language debate :)
07:25:15 <hiptobecubic> and it's not even about haskell
07:25:17 <edwardk> i see little point in writing asymptotically more code simply so i can work with more people on that code
07:25:32 * hiptobecubic stuffs a handful of popcorn in his mouth
07:25:55 <thirsteh> edwardk: you DON'T write that much more code, though. The lack of generics, while they would be nice, isn't a problem in practice.
07:26:22 <thirsteh> but only so long as you use Go to write "normal" code, e.g. a web application, bloom filter, load balancer
07:26:28 <merijn> thirsteh: Not for you, but I imagine for edwardk it is
07:26:35 <thirsteh> for anything math-heavy I would always use haskell, even though I suck at it
07:26:47 <thirsteh> yes, I don't dispute that
07:26:51 <edwardk> thirsteh: literally none of the code i've written in the last 3 weeks can be expressed at all in go.
07:26:54 <thirsteh> different tools for different jobs
07:26:56 <edwardk> nothing
07:27:04 <edwardk> the very thoughts can't be had
07:27:10 <thirsteh> I understand
07:27:12 <edwardk> there is a very strong sapir-whorf issue there
07:27:25 <edwardk> i don't want to be the guy who can only think the thoughts he can think in go
07:27:43 <hiptobecubic> edwardk, but you are doing dark magic. Bob the programmer doesn't do that, doesn't want to, and probably couldn't.
07:28:03 <edwardk> hiptobecubic: but the fact is by choosing go, he can never evolve beyond that level
07:28:10 <thirsteh> My point is that most programmers can't do this, and if they try it becomes an unwieldy mess
07:28:13 <donri> bob isn't a real scotsman ^W programmer
07:28:26 <thirsteh> Go almost forces you to write programs that can be parsed and added to by anyone
07:28:40 <thirsteh> they're not as elegant, expressive or exotic as Haskell; never will be
07:29:09 <edwardk> and my point is that i can get a lot more done with a team of 7 really smart people than i can with 70 java drones and can compensate them accordingly. which team would you rather work on?
07:29:21 <thirsteh> by most programmers I mean most industry programmers. Most of the people I've interviewed can't write FizzBuzz efficiently, for crying out loud
07:29:28 <thirsteh> edwardk: the former
07:29:50 <hiptobecubic> edwardk, that is true, but if you can't ride a bicycle, you should walk. Getting on a bicycle is just going to kill everyone and then get your corpse fired.
07:29:51 <edwardk> the issue is with that team of 7 people i can write tools that can be used by the larger community even if they can't build the tools themselves. they can then work a little bit faster.
07:30:17 <edwardk> hiptobecubic: you don't need to know how to write the lens library in order to use it for instance.
07:30:49 <thirsteh> edwardk: you're assuming people can use Haskell at all, or even remotely understand its syntax
07:30:50 <edwardk> you don't need to know that behind _1 is a bunch of multiparameter type classes, functional dependencies, rank 2 types and an applicative functor
07:31:05 <edwardk> you just need to know ("foo","bar")^._1 works like an imperative programmer expects
07:31:14 <Shapeshifter> I have a list of words. I can take a random sample of these words by doing "take 10 $ map (words !!) $ (randomRs (0, length words-1) gen)". But how can I easily get a sample of *distinct* words? Before, I shuffled the list using a complicated function I copy pasted from the web and then just took 10 from the shuffled list. That works, but requires a big function for shuffling the list.
07:31:16 <thirsteh> it took me a year of glancing at Haskell through rose-colored glasses before even learning what =<< was
07:31:44 <edwardk> thirsteh: in my experience i can hand a domain specific language written in haskell to someone who works with customers and doesn't know how to program they can learn by example and write productive code in it.
07:31:44 <hiptobecubic> edwardk, absolutely agree. We count on you to make those things for sure. But you are making generic tools, not a database updater for Sears' durable commodity products
07:31:49 <alpounet> edwardk, hey, is 'linear' the math part of your physics code we've talked abotu a month or so ago?
07:31:50 <edwardk> this isn't fantasy land, i've done this
07:31:57 <edwardk> alpounet: yep
07:32:08 <alpounet> alright, cool
07:32:13 <hiptobecubic> So when Sears tells Bob to make that, he had better walk, not ride the bicycle.
07:32:14 <thirsteh> I don't dispute that some programmers can't learn haskell quickly, and can't write beautiful haskell. It's just not most people. Most people can learn Go quickly and write Go code, which is almost forcedly idiomatic
07:32:15 <edwardk> hiptobecubic: yes but the problem is in the go community i can't even offer those tools
07:32:28 <edwardk> so the community is forever forced to go without. it can't evolve or improve in that direction at all
07:33:01 <byorgey> Shapeshifter: that's the best way I know.
07:33:03 <edwardk> thirsteh: the thing is i can give those programmers a domain specific language in haskell that fits their problem domain. i can't do that in go.
07:33:10 <thirsteh> edwardk: you're right, Go doesn't have DSLs. If you can't present the same functionality in a normal API then you can't write it
07:33:17 <hiptobecubic> edwardk, also true. But the trade off is that the code is easy to understand and work with for any old moron that will work for 13 dollars an hour.
07:33:23 <byorgey> Shapeshifter: but rather than copy-pasting some big function from the web, you could use the random-shuffle package
07:33:23 <edwardk> thirsteh: back to the sapir-whorf issues ;)
07:33:26 <byorgey> Shapeshifter: http://hackage.haskell.org/package/random-shuffle
07:34:00 <Shapeshifter> byorgey: thanks
07:34:05 <thirsteh> edwardk: I'm not disputing you, and I'm not trying to argue that Go is as beautiful as Haskell. It isn't. It's just easier to hit the ground running with it, and that means a lot for most teams
07:34:09 <edwardk> hiptobecubic: dsl based code can be too. look at yesod. many of its users are ruby converts who don't really understand the haskell bits
07:34:11 <hiptobecubic> Network effects play an enormous role here.
07:34:49 <alpounet> thirsteh, haskell obviously doesn't target "most teams"
07:34:55 <thirsteh> my point exactly
07:35:03 <alpounet> that's what edward was saying too
07:35:09 <alpounet> with his 7 smart people team thing
07:35:09 <thirsteh> if I had a team of 5 geniuses I would use Haskell
07:35:14 <edwardk> in my experience, that 'hit the ground running' speed can be had off in something like scala, and you still get better interop and generics and i can provide the community with tools.
07:35:25 <hiptobecubic> edwardk, sure. But look at the user base of yesod compared to any framework that isn't based on haskell? Where are the "experienced yesod developer" job postings? We are drowning in RoR and Django.
07:35:26 <thirsteh> with a team of 30 people who just learned Java in college, I would rather have everyone use Go
07:35:38 <mauke> .oO( no need, our community is already full of tools )
07:36:02 <hiptobecubic> I think scala is going to 'make it', as it were.
07:36:19 <edwardk> thirsteh: the idea of even hiring a team of 30 people who just learned java in college terrifies me
07:36:29 <hiptobecubic> If you really suck, you can just write java in scala and you'll be happy to have type inference.
07:36:33 <edwardk> hiptobecubic: in many ways it already has, in spite of itself
07:36:35 <thirsteh> hiptobecubic: they just got like $15M in funding if I'm not mistaken
07:36:50 <edwardk> mauke: =)
07:37:00 <thirsteh> edwardk: unfortunately that's most enterprises..
07:37:06 <merijn> hiptobecubic: The trick is not to look for Yesod job postings...
07:37:11 <hiptobecubic> edwardk, a team of 30 people who just learned java in college is better than what I see here at the bank today.
07:37:16 <Shapeshifter> what do you think of scala, then?
07:37:24 <merijn> You just start your own company and undercut RoR/Django shops by being faster to write stuff
07:37:44 <edwardk> thirsteh: we have a small army of them ourself. but there is a huge productivity difference across teams
07:38:03 <merijn> If it takes you half the time in Yesod and you charge 75% of a Django shop you just increased your income by 50% :p
07:38:07 <merijn> (per hour, that is)
07:38:09 <loreints> I'm finding it really hard to solve a problem in Haskell. Right now I have a function that I'm using to inspect every byte, and originally it was written to check for a single byte value. However, now I want it to check for a sequence of bytes, and I have no clue how to do this. The only way I can think to do it is to pass two [char]'s, one for the full val and the other for the current match, so that it would remove an element fro
07:38:09 <loreints> second [char] every time it matched.
07:38:17 <thirsteh> edwardk: undoubtedly
07:38:21 <MagneticDuck> grr.. I have a cabal problem
07:38:27 <MagneticDuck> https://github.com/MagneticDuck/IndentParse
07:38:33 <MagneticDuck> when I try to install the module
07:38:37 <MagneticDuck> it builds and registers fine
07:38:37 <loreints> Is that the right way to solve the problem, or should I be doing further research into monads to figure out how to encapsulate the state I want this function to check against?
07:38:45 <MagneticDuck> but then I can't import its exposed module
07:38:45 <thirsteh> merijn: ever read http://www.paulgraham.com/avg.html ? (LISP as a secret weapon)
07:38:47 <hiptobecubic> I see a loosely organized group of 25 people who just learned excel, "learned" java from a book on their own, and spend the day arguing about which singleton widgetfactoryfactory pattern is the best
07:38:48 <Botje> loreints: are you doing subsequence matching?
07:38:50 <edwardk> Shapeshifter: i think scala is an okay language that throws a lot of stuff in the blender. it gives you a lot of tools, subtyping, implicits, etc. that just frankly don't work well when mixed. but the baseline situation is better than the situation with go.
07:38:52 <merijn> thirsteh: Yes
07:38:52 <MagneticDuck> "IndentParse"
07:38:57 <MagneticDuck> ghc can't find it
07:39:01 <MagneticDuck> why?
07:39:05 <MagneticDuck> can anybody replicate this problem?
07:39:16 <thirsteh> merijn: quite a similar theme
07:39:40 <merijn> If you don't see the job you want, just go and make it instead..
07:39:54 <carpi> thirsteh: merijn do you guys have a mathematical background? reason i ask is.. mabye thats why it eventually stuck ? )
07:40:02 <loreints> Botje: I don't know what that's what I'm trying to do. I'm just trying to turn a function that usually checks for one value into one that checks for a sequence, and I feel like in Haskell that's like trying to turn a bicycle into a car.
07:40:15 <thirsteh> carpi: almost none
07:40:51 <thirsteh> carpi: but I spend more time than can be expected of employees learning stuff in my spare time
07:41:02 <MagneticDuck> well guys?
07:41:05 <edwardk> ultimately it comes down to being the change you want to see in the industry. i'd rather work with people who understand higher order functions. heck i enjoy working with people who i can talk about right kan extensions with, or say, oh, well if i abuse coyoneda over here i can make it so i dont need to pass in the monad parameter and help inference over there.
07:41:10 <MagneticDuck> btw, my question was almost ignored yesterday
07:41:12 <MagneticDuck> x)
07:41:16 <mauke> MagneticDuck: what problem?
07:41:18 <MagneticDuck> https://github.com/MagneticDuck/IndentParse
07:41:24 <edwardk> i find it is remarkably energizing and makes me want to go to work every day ;)
07:41:24 <MagneticDuck> when I try to cabal install that package
07:41:30 <MagneticDuck> I can't get the exposed modules
07:41:36 <MagneticDuck> ghc doesn't recognise then
07:41:40 <MagneticDuck> them
07:41:45 <mauke> MagneticDuck: that's your misinterpretation of reality. what actually happens?
07:41:47 <MagneticDuck> I can't import them in ghci, for one
07:41:52 <MagneticDuck> okay
07:41:57 <MagneticDuck> I have that directory on my machine
07:42:01 <MagneticDuck> I "cabal install"
07:42:05 <MagneticDuck> I "cd .."
07:42:06 <edwardk> i've written literally decades of code the other way
07:42:08 <MagneticDuck> I open ghci
07:42:14 <MagneticDuck> I say "import IndentParse"
07:42:14 <Botje> loreints: sounds like you need to reduce your problem to the essence and then lift it using higher-order functions
07:42:22 <MagneticDuck> (which is one of the exposed-modules)
07:42:23 <thirsteh> edwardk: no doubt working with Haskell in a smart team is much more intellectually stimulating
07:42:24 <MagneticDuck> and nothing happens
07:42:28 <MagneticDuck> it's not added to the scope
07:42:30 <edwardk> in the end, screw the average programmer ;)
07:42:36 <loreints> Botje: oh god.
07:42:40 <MagneticDuck> granted, I don't know a whole lot about cabal
07:42:46 <hiptobecubic> edwardk, well after arguing with someone yesterday about why writing a regex "parser" to read a csv file was both stupidly error prone *and* slower, i can appreciate what you mean.
07:42:51 <MagneticDuck> but I've installed other packages in the past
07:42:55 <rosie> In cabal-dev, how do you debug a "Could not find module" error?
07:42:56 <MagneticDuck> btw, it's not on hackage yet
07:43:11 <thirsteh> hiptobecubic: lol
07:43:17 <EvanR> lol regex csv
07:43:22 <loreints> okay, is my approach to Haskell wrong? I keep trying to work on a binary parser, but I feel like at the end of the day I need to know way more. Usually I learn by just fooling around and trying to tackle something, but with Haskell I feel like I need a serious foundation.
07:43:22 <EvanR> regex solves everything
07:43:29 <MagneticDuck> hehe
07:43:29 <hiptobecubic> edwardk, but from a manager's point of view... what's that saying? "No one ever got fired for choosing java"
07:43:40 <loreints> How do most people learn haskell? Just read for a month and play a little, then try and tackle something?
07:43:43 <byorgey> MagneticDuck: does the same thing happen with :m +IndentParse ?
07:43:43 <Botje> loreints: can you maybe just put what you have now on hpaste?
07:43:57 <thirsteh> loreints: Learn You a Haskell, then play a bit, then Real World Haskell, then try to write something real
07:43:58 <EvanR> loreints: write code
07:44:00 <Botje> loreints: I learned it by trying to do project euler stuff
07:44:03 <hiptobecubic> loreints, i think most people get halfway through learn-you-a-haskell and then quit entirely.
07:44:18 <thirsteh> Botje, loreints: Project Euler is _great_ if you don't have anything specific you want to write
07:44:26 <byorgey> loreints: sure, except keep reading longer and play a lot, and don't stop reading or playing when you try to tackle something
07:44:28 <loreints> http://hpaste.org/73841
07:44:34 <MagneticDuck> loreints: write a project
07:44:35 <thirsteh> hiptobecubic: I quit for a year halfway through LYAH pretty much :)
07:44:37 <MagneticDuck> learn by doing
07:44:43 <mauke> MagneticDuck: how do you know it's not added to the scope?
07:44:49 <edwardk> hiptobecubic: who cares? i can hire as many haskell or scala developers as i'd ever need to staff the team. they are typically living with their parents and desperate for work, you can pay them 20% more than a java developer and you have loyalty and greatly increased productivity. i can see the numbers to management and have
07:44:58 <MagneticDuck> it doesn't appear in the prefix of the line
07:45:03 <MagneticDuck> "Prelude>"
07:45:03 <mauke> MagneticDuck: so what?
07:45:11 <thirsteh> edwardk: you know The Secret
07:45:13 <MagneticDuck> I can't access the function either
07:45:16 <MagneticDuck> I WANT THAT MODULE
07:45:17 <mauke> MagneticDuck: I can
07:45:17 <int-e> MagneticDuck: what kind of output do  ghc-pkg list indent-parse  and  ghc-pkg find-module IndentParse  produce?
07:45:20 <MagneticDuck> really?
07:45:21 <hiptobecubic> edwardk, thirsteh, bingo
07:45:30 <mauke> *> :t stringToParsedStructure
07:45:30 <mauke> stringToParsedStructure :: String -> ParsedStructure
07:45:33 <hiptobecubic> More importantly, it *is*, in fact, a secret.
07:45:35 <MagneticDuck> int-e: it seems it installs fine, I get a listing on my machine
07:45:37 <edwardk> you hire a java developer out of college and in 2 years you're stuck training the next one, its a consistent pull back to mediocrity
07:45:44 <MagneticDuck> so I don't get this
07:45:50 <alpounet> and there are more haskell jobs that one thinks
07:45:52 <MagneticDuck> it installs
07:45:54 <MagneticDuck> and I can access the functions
07:45:57 <edwardk> so screw the average developer, i don't want to build a business around them
07:46:00 <MagneticDuck> but it doesn't get added to the scope?
07:46:01 <alpounet> (that surprised me actually)
07:46:03 <MagneticDuck> dafuq
07:46:10 <thirsteh> I've seen a lot of Haskell/OCaml postings in finance, aerospace, crypto
07:46:17 <merijn> loreints, thirsteh: I think Project Euler is *terrible* programming practice in any language
07:46:37 <thirsteh> not so many in buzzy-buzz social local photo sharing startups
07:46:39 <merijn> They're math tricks, not programming problems, and as such completely unrepresentative for "normal" haskell code
07:46:40 <MagneticDuck> Project Euler isn't really a course in programming
07:46:41 <EvanR> ocalm? >_<
07:46:43 <MagneticDuck> it's a course in math
07:46:44 <hiptobecubic> alpounet, are there? When I see them, I see a few postings here and there and 150 comments of poor souls like edwardk wants to hire who are drooling over them
07:46:48 <alpounet> i've received 6 offers in the last 6 months...
07:46:53 <edwardk> er s/see the numbers/sell the numbers
07:46:56 <MagneticDuck> H99 is a good thing to do if you want to learn haskell
07:47:18 <alpounet> and i'm not really the typical emblematic haskell dev
07:47:20 <thirsteh> MagneticDuck, merijn: and Haskell excels at math
07:47:21 <rtj_> edwark: is there a particular site/source you'd recommend finding haskell programmers?
07:47:35 <thirsteh> rtj_: r/haskell maybe
07:47:39 * frerich wonders where edwardk finds all those Haskell programmers, too
07:47:40 <merijn> thirsteh: I disagree
07:47:43 <neothemachine> help... http://hpaste.org/73838 there are probably not many Windows guys out here, but who knows
07:47:55 <merijn> If I want to do math I'll write fortran or use NumPy >.>
07:47:59 <edwardk> hiptobecubic: i receive job offers at a rate of 2-3 a week for haskell or scala work
07:48:11 <MagneticDuck> YAY
07:48:14 <merijn> edwardk: To be fair, you're hardly the average haskell programmer
07:48:15 <MagneticDuck> I DID IT
07:48:17 <MagneticDuck> I found the problem
07:48:23 <MagneticDuck> there were two versions installed
07:48:25 <Botje> neothemachine: does that bin directory contain libgeocode*.dll?
07:48:25 <MagneticDuck> with a different name
07:48:29 <MagneticDuck> exporting the same module
07:48:31 <MagneticDuck> thanks
07:48:35 <MagneticDuck> :m + IndentParse
07:48:38 <MagneticDuck> gave an error
07:48:38 <edwardk> frerich: honestly? here
07:48:42 <MagneticDuck> okay
07:48:44 <hiptobecubic> edwardk, yes but are a haskell celebrity i'd say.
07:48:44 <MagneticDuck> good
07:48:46 <hiptobecubic> but you*
07:48:52 <neothemachine> Botje: it contains GecodeSupport-3-1-0-r-x86.dll etc
07:48:57 <neothemachine> should I rename it?
07:49:19 <thirsteh> haskell celebrity is an oxymoron
07:49:32 <alpounet> hiptobecubic, nah, he just floods hackage every few weeks
07:49:32 <thirsteh> :)
07:49:34 <rtj_> edwark/thirsteh: I wasn't being difficult, actually big fan of haskell and have real projects, just new to sourcing haskell programmers.
07:49:37 <edwardk> if you know a good hakell developer who wants work, and isnt picky about the language, i can get them a job. it may not be in haskell, it may be writing c# in a defense contractor somewhere, but i can easily get them hired.
07:49:56 <thirsteh> rtj_: I wasn't trying to be snide. I really do think reddit.com/r/haskell would be a good place to post
07:50:08 <jamiltron> Aww the "may not be haskell" part is a bit disappointing :P
07:50:09 <thirsteh> you'll get lazy people who know Haskell
07:50:21 <thirsteh> as long as they're the good kind of lazy, that's perfect.. :)
07:50:41 <edwardk> jamiltron: ddarius is there =P
07:51:09 <rtj_> thirsteh: thanks!
07:51:18 <merijn> rtj_: Have you tried http://www.haskellers.com/ ?
07:51:39 <thirsteh> merijn, rtj_: ah, nice page
07:52:47 <rtj_> merijn: nope. cool - thanks
07:55:45 <Botje> neothemachine: from what i (vaguely) remember, you also need .lib and/or .def files to link with libraries, no?
07:56:23 <neothemachine> Botje: there's also a lib folder full of .lib's, I'll try
07:56:27 <statusfailed> rtj_: you're looking for Haskell programmers?
07:57:13 <rtj_> statusfailed: yup
07:57:15 <statusfailed> The wiki points to "functional jobs" and "cufp", they seem to have jobs pages. I don't know if anyone's pointed them out
07:57:41 <statusfailed> What are you hiring for?
07:59:01 <thirsteh> rtj_: maybe the very act of asking the question answered it :)
07:59:30 <rtj_> thirsteh: yup, sure did.
08:00:07 <mmaruseacph2> rtj_: what kind of projects?
08:00:11 <mmaruseacph2> what country?
08:00:37 <rtj_> guess got my answer, will come back here when ready to post :)
08:00:49 <neothemachine> Botje: no difference, I even added the two folder to PATH
08:01:59 <statusfailed> rtj_: is it the singapore investment bank quant job on cufp? :P
08:03:47 <rtj_> Singapore is one of the locations. Nope - but given information it's a good guess. :)
08:04:21 <statusfailed> haha damn :D
08:16:10 <merijn> rtj_: Which other locations?
08:17:02 <thirsteh> merijn: maybe finding out is your first test
08:17:13 <rtj_> merijn: Switzerland/Zurich, CA/Bay Area
08:17:19 <thirsteh> aww
08:17:29 * hiptobecubic wouldn't mind living in the bay area
08:18:04 <merijn> Screw the bay area and its groupthink, I wouldn't mind living in Zurich :p
08:18:14 <hiptobecubic> Weather is important :)
08:18:31 <jfischoff> sf weather is not that great
08:18:32 <hiptobecubic> I don't need an army of hipster friends. I just want to wear some goddamn shorts sometimes.
08:18:34 <jamiltron> hiptobecubic: I'm moving there next month :)
08:18:58 <merijn> hiptobecubic: Zurich can be nice and sunny in summer + skiing close by in winter :p
08:19:24 <thirsteh> rtj_: Google?
08:19:55 <thirsteh> If I recall, they have engineering offices in all those cities
08:20:09 <t7> somone is spamming hpaste
08:20:15 <t7> is haskell mainstream now?
08:20:22 <t7> or a clever bot?
08:20:23 <merijn> thirsteh: Zurich is pretty big in CS
08:20:37 <hiptobecubic> ETH is a beast
08:20:39 <merijn> thirsteh: ETH is there
08:20:41 <thirsteh> yeah, fair enough. Just a guess
08:20:54 <thirsteh> true
08:21:19 * eikke in doubt between moving to Lausanne (related to EPFL), or NYC
08:21:52 <thirsteh> if you want to live in the U.S., NYC is a great city
08:22:07 <thirsteh> kind of its own little bubble
08:22:37 <eikke> yup. if given the choice between NYC or west-coast, NYC it is
08:23:25 <thirsteh> and you'll earn an obscene amount of money if you get an FP job in finance in NYC...
08:23:37 <thirsteh> $200k entry-level positions downtown
08:23:53 <eikke> I'm not american, so that might be hard :)
08:24:16 <thirsteh> a lot of the people in those jobs are Russian
08:24:30 <alpounet> thirsteh, an pay an obscene amount of money for a flat there? :p
08:24:32 <thirsteh> to sterotype wildly, Americans suck at math
08:24:32 <alpounet> and*
08:24:49 <thirsteh> alpounet: sure, it's expensive. Just don't live in Manhattan
08:25:09 <thirsteh> s/to sterotype wildly/statistically/
08:25:34 <yitz> thirsteh: some people say: if you want to live in the US, live somewhere else (even though NYC *is* a great city)
08:25:47 <merijn> thirsteh: Sounds like I should get a remote job there :p
08:25:59 <thirsteh> that's what I have
08:26:00 <thirsteh> :)
08:26:25 <thirsteh> office in Manhattan, live in Europe
08:26:33 <thirsteh> working on moving to NYC though
08:26:38 <merijn> Right now I get 25k a year and an entry position will probably get me 35-45k *max*
08:27:00 <eikke> is that before or after taxes?
08:27:02 <merijn> Well, maybe as I'd get more as an industry programmer
08:27:04 <merijn> Before
08:27:16 <thirsteh> merijn: that's very low for industry
08:27:31 <thirsteh> depending on city, of course
08:27:56 <merijn> Entry industry position will be more 40-50k, I guess
08:28:05 <mmaruseacph2> well, there are others, unluckier :)
08:28:11 <mmaruseacph2> with 15 - 20k a year
08:28:28 <thirsteh> hey: you're flipping monads, not burgers
08:28:40 <merijn> I think NYC and the bay are about an order of magnitude more expensive than Amsterdam, though :p
08:28:45 <merijn> Maybe even two orders
08:29:55 <eikke> merijn: sure, although amsterdam is more expensive than here (.be), and 25k before taxes would be considered pretty low (in industrial programming jobs)
08:30:32 <merijn> eikke: Like I said, industry is probably more 40-50k
08:30:56 <thirsteh> merijn: it's not too bad: http://en.wikipedia.org/wiki/List_of_most_expensive_cities
08:31:07 <merijn> I already knew academic wages sucked :p
08:31:17 <hiptobecubic> merijn, you're in amsterdam too?
08:31:24 <thirsteh> merijn: oh, you're not in the U.S.
08:32:07 <merijn> hiptobecubic: Yeah (for given values of *in*)
08:32:11 <thirsteh> NYC isn't really that much expensive than e.g. Copenhagen, you just have more expenses and pay less taxes
08:32:17 <Jeanne-Kamikaze> http://www.pasteall.org/34755 <- what does that mean ?
08:32:19 <thirsteh> much more*
08:32:34 <thirsteh> but no doubt they're among the most expensive cities
08:32:40 <neothemachine> this is stupid! http://hpaste.org/73838 haskell platform on windows has problems with whitespaces in paths but has whitespace in it as default?!
08:32:43 <thirsteh> Amsterdam being a little lower
08:34:07 <eikke> thirsteh: makes sense.  I wonder how Copenhagen will be in 2 weeks, never been up north
08:34:20 <thirsteh> oh right there's the FP summit
08:34:24 <Clint> i paid 9€ for a tiny little glass of beer in copenhagen
08:34:32 <adnam> :[
08:34:48 <thirsteh> Clint: You haven't seen anything. Try old/mid-town Stockholm.
08:35:03 <eikke> company put us in a rather cheap hotel, so I won't mind paying 9E for a beer and putting it in expenses :P
08:36:14 <thirsteh> it depends where you go. If you buy beer in a hotel bar you're asking for people to take your money
08:36:45 <thirsteh> go to a restaurant/pub-looking place a few blocks away and you'll pay £1.5/beer
08:40:05 <eikke> it'll be >15min walking away ;)
08:40:11 <thirsteh> contemplating going, but "On the Complexity of Equivalence of Specifications of Infinite Objects" sounds a little spicy to me
08:40:33 <thirsteh> where's the conf? Uni Copenhagen?
08:40:39 <thirsteh> we're talking about ICFP right?
08:40:49 <eikke> yes
08:42:01 <thirsteh> not too bad
08:44:51 <srhb> Hm, I actually have no idea where the conference is held.
08:45:07 <sykora> How many of you guys are going to ICFP?
08:45:15 <srhb> Oh, DGI-byen. Right by central station.
08:45:28 <thirsteh> you can go to Hard Rock Cafe :)
08:45:45 * byorgey is going to ICFP
08:45:51 <thirsteh> or walk a little farther and get the most expensive Kentucky Fried Chicken in the world
08:45:58 <hiptobecubic> :D
08:46:02 <thirsteh> what happens when there's only one KFC in the whole country
08:46:10 <srhb> thirsteh: Oh yeah, they just opened one nearby, didn't they
08:46:16 <srhb> That's not true, there's one in Ballerup or somesuch as well
08:46:21 <thirsteh> oh, ok
08:46:39 <srhb> But ICFP is too expensive. :(
08:46:59 <thirsteh> well I always need to get KFC when I see it, but damn, 200 DKK for some wings
08:47:00 <monochrom> where is ICFP held this year?
08:47:04 <thirsteh> Copenhagen
08:47:04 <srhb> Denmark.
08:47:06 <srhb> Copenhagen.
08:47:09 <thirsteh> Denmark
08:47:18 * eikke will be there (& talk)
08:47:29 <srhb> thirsteh: Are you a student? Or just random Dane? :-)
08:47:43 <thirsteh> just a random Dane. I don't actually live in Denmark though
08:47:48 <srhb> thirsteh: Ah
08:48:10 <srhb> eikke: About what?
08:48:45 <eikke> srhb: we have one at OUD (OCaml) about a project of ours, and one at CUFP about experiences with using FP in general
08:52:04 <srhb> Am I reading the prices wrong, or is the Haskell intro a mere 1100 USD for students? Are they insane? :P
08:52:58 <hiptobecubic> srhb, what? Just write a cheque
08:53:12 <thirsteh> students don't have expense accounts?
08:53:20 <srhb> xD
08:53:40 <srhb> It must be a typo.
08:53:44 <osfameron> CUFP is an academic conference, rather than a grassroots one, isn't it?
08:53:48 <osfameron> they seem quite expensive
08:53:59 <thirsteh> ACM in general
08:54:10 <srhb> Scal and F# intros are 150 usd each
08:54:11 <byorgey> osfameron: as far as I can tell it's somewhere in the middle
08:54:13 <sykora> I'm pretty sure the prices were lower than that before August 1, the early bird deadline.
08:54:23 <srhb> Seems like they put an extra zero on the prices of the Haskell ones
08:54:31 <byorgey> it's an academic-ish conference attended by practitioners
08:54:32 <srhb> sykora: WEll they have both early and late prices listed here.
08:55:08 <matthiasgorgens1> osfameron: cufp is corporate. :o)
08:55:37 <sykora> student prices for the intro haskell was 900 for early reg
08:55:44 <matthiasgorgens1> 900 euros?
08:55:48 <byorgey> srhb: something is strange though, the late prices for intro to Scala and F# are less than the early prices!
08:55:48 <srhb> USD
08:55:51 <srhb> What the shit :P
08:55:53 <sykora> all USD
08:55:56 <matthiasgorgens1> wow, that's quite a bit.
08:56:09 <matthiasgorgens1> it was around 500 euro for the whole conference (plus cufp etc) in 2009.
08:56:12 <srhb> byorgey: Obviously they couldn't sell them and had to lower the prices, they're just being honest :-)
08:56:13 <matthiasgorgens1> when I attended as a student.
08:56:22 <byorgey> srhb: hahaha
08:56:29 <matthiasgorgens1> byorgey: yield management.
08:56:34 <matthiasgorgens1> ryanair works on the same principles.
08:57:00 <byorgey> srhb: note the Haskell one is two days long.  I don't think it is a typo.
08:57:11 <srhb> for 1100 for two days of "tutorial" I'd certainly expect to come out a goddamn goddess of Haskell
08:57:15 <thirsteh> hey, at least ACM isn't trying to make you stand up against a pole on the airplane
08:57:17 <matthiasgorgens1> I have to check, if I actually still have to get a ticket,
08:57:19 <byorgey> they do not expect random students to just come.  They expect companies or universities to send students.
08:57:21 <srhb> Blowing monads from all orifices whenever I move.
08:57:24 <matthiasgorgens1> or whether presenters are already registered.
08:57:33 <byorgey> srhb: well, you might. did you see who is teaching it?
08:57:36 <matthiasgorgens1> byorgey: I came as a random student in 2009.
08:57:38 <srhb> Nope.
08:57:49 <srhb> How to get details on that event is a mystery to me.
08:57:49 <Eduard_Munteanu> They also expect companies to be stupid I guess.
08:58:05 <thirsteh> srhb: there is a "List of papers" on the prices page
08:58:07 <matthiasgorgens1> Eduard_Munteanu: some companies only take conference above a certain price serious.
08:58:18 <matthiasgorgens1> +ly.
08:58:34 <eikke> icfp is cheap compared to javaone back in the days
08:58:46 <osfameron> perl confs typically cost £100 but have a corporate ticket costing far more, if you need the price to impress your boss ;-)
08:58:49 <Eduard_Munteanu> The ultimate learn-Haskell-in-2-days-while-skateboarding-and-caring-for-your-family course, only $1100, limited-time offer!!111
08:58:52 <byorgey> srhb: I can't find it either right now, but if I remember correctly it is Jeremy Gibbons, Simon Marlow, and someone else
08:59:09 <srhb> Ah, so it's a celebrity safari.
08:59:10 <Eduard_Munteanu> In just 2 days you can be an experienced programmer!11
08:59:30 <eikke> Eduard_Munteanu: skateboard? fixed-gear hipster biking!
09:00:11 <srhb> I suppose it's clever from the perspective og getting companies to feel like they are invested in it, and they would lose something if they backed down
09:00:16 <Eduard_Munteanu> eikke: yeah, I mean I doubt you can learn $1100-worth of Haskell in 48 hrs even if you maintain perfect focus on that task and ignore everything else ;)
09:00:19 <srhb> From all other perspectives it seems counterproductive.
09:00:29 <srhb> $1100!!!!
09:00:32 <Eduard_Munteanu> 11
09:00:33 <srhb> >_<
09:00:41 <hiptobecubic> eikke, "fixie". Get your lingo sorted out
09:00:49 <Eduard_Munteanu> I think they meant $!!00 !
09:01:02 <eikke> hiptobecubic: non-native speaker, had to google it anyway :P
09:01:05 <Eduard_Munteanu> But couldn't keep shift pressed down!!111
09:01:29 <srhb> Eduard_Munteanu: Makes sense1
09:01:31 <thirsteh> these aren't really exorbitant prices for conferences/trainings. Black Hat is $1.6k for briefings, $2k for training or something like that
09:01:32 <hiptobecubic> eikke, lucky you. That's a guaranteed popularity card in hipster world
09:01:38 <strg> $11.00
09:01:43 <hiptobecubic> strg, maybe that's it
09:01:49 <sykora> ah, the haskell symposium and the CCiH workshops are included in the thursday/friday/saturday passes
09:01:53 <hiptobecubic> Maybe it's supposed to be Zimbabwe dollars?
09:01:55 <eikke> hiptobecubic: like speaking French?
09:02:24 <matthiasgorgens1> hiptobecubic: don't they use american dollars in zimbabwe now?
09:02:40 <hiptobecubic> eikke, I'm not sure french is still cool. German for sure. Or anything from scandinavia.
09:02:53 <hiptobecubic> matthiasgorgens1, for their sake, i hope so
09:03:03 <thirsteh> matthiasgorgens1: everything is priced in fractions...
09:03:22 <Shapeshifter> Is there a convenience function for splitting a list at n different points? E.g. thatFun [1..10] [3,8] should return [[1,2],[3,4,5,6,7],[8,9,10]].
09:03:25 <eikke> hiptobecubic: basic German should work
09:03:27 <matthiasgorgens1> hiptobecubic: I speak German.  Didn't strike me as hip so far.
09:03:44 <matthiasgorgens1> Shapeshifter: have you looked into the split module?
09:03:58 <Shapeshifter> matthiasgorgens1: will do, thanks.
09:03:59 <matthiasgorgens1> Shapeshifter: see http://hackage.haskell.org/package/split
09:04:04 <Eduard_Munteanu> Didn't I see that question the other day as well?
09:04:14 <hiptobecubic> matthiasgorgens1, you have to go to a microbrewery and talk about it like wine with a german accent now.
09:04:27 * Eduard_Munteanu wonders if it's homework for some Haskell course
09:04:32 <matthiasgorgens1> hiptobecubic: I've only really started drinking beer here in the UK.
09:04:54 <matthiasgorgens1> Eduard_Munteanu: who cares. :o)  learning how to search for standard library stuff
09:05:03 <matthiasgorgens1> is more important than coding yourself. :o)
09:05:07 <Eduard_Munteanu> Just wondering :)
09:05:11 <hiptobecubic> matthiasgorgens1, oh. If you aren't in the US then all bets are off. Being european gets you no points in europe.
09:05:58 <matthiasgorgens1> there were lots of hipsters in London, last time I checked.
09:06:12 <matthiasgorgens1> but yeah, doesn't score any points here.
09:06:18 <matthiasgorgens1> the baseline is higher here.
09:06:24 <hiptobecubic> probably, but i don't know the etiquette there
09:07:22 <matthiasgorgens1> haskell would be very hipster-istic, if programming was cool enough.
09:07:26 <matthiasgorgens1> in the first place.
09:07:52 <srhb> Nah, not mainstream enough to be hipster.
09:08:11 <srhb> I think Ruby is the first language I think of as a hipster language.
09:08:11 <matthiasgorgens1> srhb: I liked Haskell before it was cool.
09:08:18 <eikke> it'll get there
09:08:50 <hiptobecubic> ruby is definitely hipster
09:09:31 <matthiasgorgens1> hiptobecubic: is that a comparative?
09:10:04 <hiptobecubic> hipster is an adjective
09:10:12 <Eduard_Munteanu> hipsterer? :)
09:12:38 <thirsteh> <hiptobecubic> ruby is definitely hipster
09:12:55 <thirsteh> node.js is hipster as hell
09:13:04 <hiptobecubic> also true
09:15:00 <matthiasgorgens1> but, is it web-scale?
09:15:16 <thirsteh> matthiasgorgens1: http://www.youtube.com/watch?v=bzkRVzciAZg
09:18:05 <srhb> thirsteh: hahaha!
09:19:09 <matthiasgorgens1> thirsteh: sounds like a computer reading.
09:19:15 <thirsteh> it is
09:19:28 <matthiasgorgens1> thirsteh: do you have the text?
09:19:45 <thirsteh> I forgot the name of it. Some software where you can get random characters to tell your story
09:19:49 <matthiasgorgens1> "stab myself repeatetely in the ears with a fork"?
09:19:54 <thirsteh> matthiasgorgens1: nope, sorry, I think this is the "original"
09:20:01 <matthiasgorgens1> thirsteh: ok.
09:21:02 <thirsteh> srhb, matthiasgorgens1: another good one: http://www.youtube.com/watch?v=b2F-DItXtZs
09:21:40 <matthiasgorgens1> thirsteh: it's just too bad that a real node.js troll would not let the other guy finish his sentences.
09:21:43 <srhb> thirsteh: Oh that one I know :P
09:21:56 <thirsteh> matthiasgorgens1: yup
09:22:05 <thirsteh> reminds me of something I read the other day (no kidding): "A thin node.js idiom based module for CouchDB's REST API that tries to stay close to the metal."
09:22:24 <srhb> what.
09:22:33 <thirsteh> I just started crying
09:23:14 <hiptobecubic> There was a great quote on @shithnsays, which has apparently been suspended. Something like "I can always use node.js if I need to work down close to the metal."
09:23:18 <matthiasgorgens1> thirsteh: somehow those voices remind me of Shodan.
09:23:42 <thirsteh> hiptobecubic: that's how I found the other one. I couldn't believe anyone would say that, then I found something much worse.
09:24:22 <eikke> https://twitter.com/shit_hn_says/status/234856345579446272
09:24:23 <thirsteh> matthiasgorgens1: haha, yeah
09:24:49 <hiptobecubic> eikke, ah yes :D   it's a beautiful quote
09:25:06 <matthiasgorgens1> thirsteh: https://www.youtube.com/watch?v=5iZMD_eCpEo
09:25:17 <eikke> sure is
09:25:58 <hiptobecubic> heh. this is much better than most of these videos
09:26:04 <matthiasgorgens1> "if /dev/null is fast and web-scale, I will use it."
09:26:13 <thirsteh> yeah that account is great
09:26:15 <hiptobecubic> "You are the reason science was set back 1000 years."
09:26:57 <thirsteh> "It's because of you, mother#####, that we're not all using LISP." "Sorry, what was that?" "Nothing." "I could have sworn you just said LISP"
09:27:10 <matthiasgorgens1> thirsteh: http://www.rockpapershotgun.com/2009/08/12/the-girl-who-wanted-to-be-god/
09:27:48 <thirsteh> matthiasgorgens1: that was a great game
09:35:16 <rosie> What's a good way to convert a tuple (String, String) to a String?
09:35:52 <mauke> const ""
09:36:10 <hiptobecubic> mauke, you beat me :(
09:36:11 <latro`a> uncurry (++) might be what you mean
09:36:17 <mauke> show
09:36:27 <latro`a> show also might be what yo umean
09:36:28 <mauke> fst
09:36:29 <latro`a> *you mean
09:36:31 <mauke> snd
09:36:47 <latro`a> probably anything else throws out information
09:37:01 <mauke> uncurry (flip (++))
09:37:15 <latro`a> that would work, yeah
09:37:34 <latro`a> here's a question: why do you have pairs of strings
09:37:35 <rosie> Thanks all!
09:37:46 <rosie> parameters from an http request
09:37:53 <latro`a> gotcha
09:38:14 <mauke> \(x, y) -> [c | a <- x, b <- y, c <- [a, b]]
09:38:53 <latro`a> hm
09:39:09 <matthiasgorgens1> you guys are evil.
09:39:13 <latro`a> > (\(x,y) -> [c | a <- x, b <- y, c <- [a,b]]) ("foo","bar")
09:39:15 <lambdabot>   "fbfafroboaoroboaor"
09:39:18 <latro`a> oh god
09:39:28 <hiptobecubic> latro`a, that is beautiful
09:39:34 <hiptobecubic> i can even hear it
09:39:36 <thirsteh> haha
09:40:19 <otters> whaaarrglalrb
09:40:20 <thirsteh> "screamify"
09:40:24 <thirsteh> "murlocify"
09:40:35 <matthiasgorgens1> what is the neatest way to describe that without monad comprehensions?
09:40:44 <latro`a> with concatMap?
09:40:49 <thirsteh> what's the idiomatic suffix for a function that only serves as the pure part of an impure function? ', even though it's not strict? e.g. formatFoo -> ... -> IO String and formatFoo' -> a -> b -> c -> String
09:40:51 <matthiasgorgens1> yeah, probably.
09:40:52 <mauke> > (\(x, y) -> [c | a <- x, b <- y, c <- [a, b]]) ("hello", "world")
09:40:53 <lambdabot>   "hwhohrhlhdeweoereledlwlolrllldlwlolrllldowooorolod"
09:41:05 <hiptobecubic> this is really great
09:41:12 <latro`a> lol, the two o's
09:41:14 <latro`a> result in hilarity
09:41:22 <matthiasgorgens1> thirsteh: I often add call it blubPure (i.e. append Pure).
09:41:28 <matthiasgorgens1> but I don't know whether that's idiomatique.
09:41:46 <mauke> @undo \(x, y) -> [c | a <- x, b <- y, c <- [a, b]]
09:41:46 <lambdabot> \ (x, y) -> concatMap (\ a -> concatMap (\ b -> concatMap (\ c -> [c]) [a, b]) y) x
09:41:52 <mauke> @. pl undo \(x, y) -> [c | a <- x, b <- y, c <- [a, b]]
09:41:52 <lambdabot> uncurry ((. flip ((=<<) . (. return) . (:))) . (>>=))
09:42:03 <latro`a> that @pl could be worse
09:42:12 <mauke> @. unpl . pl undo \(x, y) -> [c | a <- x, b <- y, c <- [a, b]]
09:42:13 <lambdabot> uncurry (\ h t -> h >>= \ c -> t >>= \ w -> ((:)) c (return w))
09:42:20 <thirsteh> matthiasgorgens1: I could have swon I saw ' used this way in LYAH, but it seems a little wrong since that means strict everywhere else
09:42:30 <thirsteh> matthiasgorgens1: +pure or pure+ works
09:42:39 <thirsteh> s/swon/sworn
09:42:50 <matthiasgorgens1> thirsteh: I'd do +Pure.
09:42:50 <latro`a> ' just gets used for "another version of" imo
09:42:53 <matthiasgorgens1> (camel case and all.)
09:43:00 <Shapeshifter> matthiasgorgens1: will do, thanks.
09:43:04 <mauke> :t join .: liftM2 (\x y -> [x,y])
09:43:05 <lambdabot> forall a2. [a2] -> [a2] -> [a2]
09:43:08 <matthiasgorgens1> latro`a: yeah.  and strictness is the most common case of "other version"
09:43:08 <Shapeshifter> matthiasgorgens1: whoops
09:43:26 <mauke> > (join .: liftM2 (\x y -> [x,y])) "hi" "there"
09:43:28 <lambdabot>   "hthhhehrheitihieirie"
09:43:29 <matthiasgorgens1> mauke: that misses an uncurry.
09:43:32 <thirsteh> matthiasgorgens1, latro`a: ok. I guess ' makes sense since I won't be exporting these functions
09:43:46 <matthiasgorgens1> thirsteh: oh, if you are not exporting, feel free to mess around.
09:43:53 <latro`a> if the distinction is basically that Pure does the same thing without using IO
09:44:00 <latro`a> then Pure sounds like a good name
09:44:03 <Rahul> hello fello haskell programmers
09:44:10 <latro`a> I'm not sure about it as one that results in IO String vs. resulting in String
09:44:12 <atriq> Hello, Guest79874
09:44:19 <thirsteh> latro`a: in this particular case, the formatFoo only serves to extract info from TVars
09:44:20 <Guest79874> i have a question for you guys
09:44:31 <matthiasgorgens1> Guest79874: shoot.
09:44:31 <atriq> Fire away
09:44:39 <Guest79874> lately i have been searching a net for this , but not a single source could satiate me
09:44:52 <Guest79874> is there any thing which haskell is specifically meant for ?
09:44:59 <matthiasgorgens1> nope.
09:45:06 <thirsteh> haskell is general-purpose
09:45:07 <hiptobecubic> Guest79874, programming
09:45:09 <latro`a> it's a general purpose language
09:45:09 <Guest79874> like C-> speed  python -> expressiveness
09:45:11 <latro`a> so, not really
09:45:16 <hiptobecubic> C was not meant for speed
09:45:16 <mauke> :t concat . sequence . words
09:45:17 <lambdabot> String -> [Char]
09:45:20 <atriq> Haskell -> being awesome
09:45:22 <hiptobecubic> C was also meant for programming.
09:45:27 <mauke> python was not meant for expressiveness
09:45:36 <matthiasgorgens1> hiptobecubic: original, C was meant as a high level language to do operating systems in.
09:45:43 <mauke> > concat . sequence . words $ "hello world"
09:45:45 <lambdabot>   "hwhohrhlhdeweoereledlwlolrllldlwlolrllldowooorolod"
09:45:48 <Guest79874> but python code are a lot more easier to read
09:45:52 <mauke> I'll take it
09:45:57 <matthiasgorgens1> than C code?  yeah.
09:46:00 <hiptobecubic> matthiasgorgens1, right. Which, is indeed the opposite of speed, usually.
09:46:03 <thirsteh> mauke: that's expressiveness if I've ever seen it
09:46:05 <thirsteh> :D
09:46:12 <matthiasgorgens1> hiptobecubic: though that was back in the day.
09:46:12 <Guest79874> i was trying haskell online
09:46:23 <mauke> @let scream = concat . sequence . words
09:46:25 <lambdabot>  Defined.
09:46:26 <matthiasgorgens1> hiptobecubic: Java was created to run on washing machines.  but that's not what it's meant for today. :o)
09:46:35 <thirsteh> > scream "argh"
09:46:37 <lambdabot>   "argh"
09:46:38 <matthiasgorgens1> mauke: you forget the map uppercase!
09:46:47 <thirsteh> > scream "argh why are you doing this"
09:46:49 <lambdabot>   "awaydtawaydhawaydiawaydsawayotawayohawayoiawayosawayitawayihawayiiawayisaw...
09:46:53 <latro`a> lolol
09:46:58 <osfameron> I would buy a washing machine that ran haskell
09:47:07 <Guest79874> for example : in Haskell let abc@(a,b,c) = (10,20,30) in (abc,a,b,c)
09:47:22 <roconnor> > let abc@(a,b,c) = (10,20,30) in (abc,a,b,c)
09:47:23 <lambdabot>   ((10,20,30),10,20,30)
09:47:23 <lambdabot> roconnor: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:47:26 <matthiasgorgens1> Guest79874: if you have pin haskell to any specific purpose, I guess you could do worse than "Correctness".
09:47:44 <mauke> haskell was meant for laziness
09:47:48 <Guest79874> well i m trying to learn haskell
09:48:00 <Guest79874> but basically coming from python world ,
09:48:01 <hiptobecubic> Guest79874, so do some programming in Haskell.
09:48:04 <mauke> and practical theory
09:48:06 <matthiasgorgens1> Guest79874: I did so too.
09:48:10 <Guest79874> its kinda very difficult to learn it
09:48:12 <roconnor> mauke: you are correct.
09:48:12 <hiptobecubic> Guest79874, me too.
09:48:15 <matthiasgorgens1> Guest79874: I made a detour via Clean.  but that's not necessary. :o)
09:48:20 <mauke> > scream "haskell rocks"
09:48:22 <lambdabot>   "hrhohchkhsaraoacakassrsoscsksskrkokckkksereoecekeslrlolclklslrlolclkls"
09:48:25 <matthiasgorgens1> Guest79874: yeah, but it's fun. :o)
09:48:30 <matthiasgorgens1> Guest79874: why are you learning haskell?
09:48:34 <latro`a> I think it is helpful to just dive in and write some code
09:48:38 <Guest79874> i m more of a pragmatic programmer
09:48:38 <latro`a> at first
09:48:38 <Automorphism> @src scream
09:48:38 <lambdabot> Source not found. :(
09:48:48 <matthiasgorgens1> Guest79874: that's a good attitude.
09:48:55 <latro`a> before learning about all the clever trickery that people use
09:48:55 <roconnor> mauke: perhaps we can say Haskell meant to be a free version of Miranda
09:49:10 <roconnor> mauke: then I guess we ask what was the purpose of Miranda
09:49:15 <matthiasgorgens1> roconnor: haskell was meant to be a standardized lazy functional language.
09:49:17 <matthiasgorgens1> wasn't it?
09:49:21 <roconnor> matthiasgorgens1: yep
09:49:40 <mauke> > scream "2 + 3"
09:49:42 <matthiasgorgens1> gotta pump some iron.  see ya.
09:49:42 <lambdabot>   "2+3"
09:49:43 <roconnor> matthiasgorgens1: but I'd suggest that Miranda was the de facto standard previously
09:50:02 <latro`a> what the
09:50:04 <matthiasgorgens1> roconnor: I don't know enough history for that.
09:50:07 <latro`a> > words "2 + 3"
09:50:08 <matthiasgorgens1> anyway, I'm off.
09:50:08 <lambdabot>   ["2","+","3"]
09:50:10 <latro`a> um
09:50:11 <latro`a> what
09:50:21 <latro`a> > sequence $ words "2 + 3"
09:50:23 <lambdabot>   ["2+3"]
09:50:25 <latro`a> ...
09:50:30 <latro`a> ???
09:50:38 <latro`a> oh, they're single character
09:50:39 <latro`a> duh
09:50:46 <mauke> > scream . show . typeOf $ ord
09:50:48 <lambdabot>   "C-IC-nC-tC>IC>nC>th-Ih-nh-th>Ih>nh>ta-Ia-na-ta>Ia>na>tr-Ir-nr-tr>Ir>nr>t"
09:50:53 <latro`a> .....
09:50:59 <Guest79874> ok let me put it this way
09:51:01 <latro`a> > typeOf ord
09:51:02 <lambdabot>   Char -> Int
09:51:05 <Automorphism> mauke: What does scream do?
09:51:11 <Guest79874> whats the best way to learn haskell without banging ur head on the wall
09:51:13 <latro`a> scream = concat . sequence . words
09:51:21 <latro`a> he defined it just a bit ago
09:51:33 <hiptobecubic> Guest79874, wear a helmet
09:51:43 <Automorphism> Guest79874: Accepting the fact that the type system (and the type checker) are there to help you!
09:51:45 <latro`a> it turns strings with several words in them into a horrible growl, more or less
09:52:01 <hiptobecubic> http://i.imgur.com/qXupD.jpg
09:52:19 <hiptobecubic> i believe that's the original implementation
09:52:20 <Automorphism> Guest79874: You are Harry. The type checker is Snape.
09:52:31 <Guest79874> hiptobecubic , still there is a chance my helmet will break
09:52:42 <mauke> > scream "warab hrgrl"
09:52:42 <hiptobecubic> Automorphism, harry never got it right without cheating
09:52:44 <lambdabot>   "whwrwgwrwlaharagaralrhrrrgrrrlaharagaralbhbrbgbrbl"
09:53:08 <hiptobecubic> @src scream
09:53:09 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:53:19 <hiptobecubic> seems like an easy thing to implement
09:53:20 <Automorphism> hiptobecubic: I already tried it a few minutes ago.
09:53:22 <Guest79874> scream "haskell"
09:53:31 <Automorphism> Guest79874: Use > first.
09:53:46 <Guest79874> >scream "haskell"
09:53:56 <Guest79874> damn , how do u guys do it ?
09:54:00 <Automorphism> > scream "Hello, world"
09:54:02 <lambdabot>   "HwHoHrHlHdeweoereledlwlolrllldlwlolrllldowooorolod,w,o,r,l,d"
09:54:03 <hiptobecubic> Guest79874, also, needs at least two words to be any fun.
09:54:14 <Automorphism> Guest79874: "> " first, sorry.
09:54:18 <hiptobecubic> > scream "sigh"
09:54:20 <lambdabot>   "sigh"
09:54:23 <mauke> > "simon peyton jones"
09:54:24 <lambdabot>   "simon peyton jones"
09:54:35 <Guest79874>  >  scream "has , kell "
09:54:42 <Automorphism> > scream "ohai peepls"
09:54:44 <lambdabot>   "opoeoeopoloshphehehphlhsapaeaeapalasipieieipilis"
09:54:58 <thirsteh> > scream "B O N U S"
09:54:58 <Guest79874>  >  scream "has  kell "
09:55:00 <lambdabot>   "BONUS"
09:55:03 <Clint> haha
09:55:12 <hiptobecubic> > scream "Guest79874 no extra space at the beginning."
09:55:14 <lambdabot>   "GnesatbGnesateGnesatgGnesatiGnesatnGnesatnGnesatiGnesatnGnesatgGnesat.Gnes...
09:55:19 <Guest79874> >  scream "has  kell "
09:55:21 <lambdabot>   "hkhehlhlakaealalskseslsl"
09:55:31 <Guest79874> wohooo . . .
09:55:41 <Guest79874> this is fun ...
09:56:04 <Guest79874> > scream "node js"
09:56:06 <lambdabot>   "njnsojosdjdsejes"
09:56:11 <mauke> :t join . sequence . group
09:56:12 <lambdabot> forall a. (Eq a) => [a] -> [a]
09:56:20 <mauke> > join . sequence . group $ "haskell"
09:56:22 <lambdabot>   "haskelhaskel"
09:57:10 <mauke> > join . sequence . group $ "roconnor"
09:57:12 <lambdabot>   "roconorroconor"
09:57:46 <Guest79874> ok guys coming back to point
09:57:53 <Guest79874> whats the best way to learn haskel
09:57:54 <Guest79874> ?
09:57:58 <mauke> I understand!
09:58:00 <hiptobecubic> Guest79874, LearnYouAHaskell
09:58:09 <hiptobecubic> Then quit for a few weeks out of frustration.
09:58:16 <hiptobecubic> Then feel like a loser and start over.
09:58:22 <hiptobecubic> Repeat until you know haskell
09:58:25 <Automorphism> hiptobecubic: So true!
09:58:26 <Guest79874> lol .. :D
09:58:47 <strg> Guest79874: learn you a haskell for great good, and real world haskell. both available for free online.
09:58:52 <Guest79874> Can we interface other languages with haskell
09:58:58 <Clint> obviously
09:59:03 <strg> then a lot of googling about monads
09:59:03 <ranger66> hello can i hide the Functor instance decalaration of [] from GHC.Base?
09:59:05 <hiptobecubic> @faq Can haskell?
09:59:05 <lambdabot> The answer is: Yes! Haskell can do that.
09:59:06 <mauke> yes, for languages that are C
09:59:12 <latro`a> lol
09:59:21 <srhb> All languages are C!
09:59:26 <mauke> fortunately a lot of languages are in fact C
09:59:32 <mauke> ranger66: no
09:59:32 <donri> ranger66: {-# LANGUAGE NoImplicitPrelude #-}
09:59:45 <GlitchMr> I'm new to Haskell (I was playing with ghci) and I wonder what "\&" does?
09:59:51 <GlitchMr> Nothing, I guess?
09:59:51 <mauke> GlitchMr: nothing
09:59:52 <donri> hides everything, so have fun with that :)
10:00:08 <Guest79874> Guys what are your thoughts on this article
10:00:09 <Guest79874> http://mypy.pythonblogs.com/12_mypy/archive/423_python_vs_haskell_vs_php-real_world_performance.html
10:00:52 <Botje> that uses the String version of readFile
10:01:15 <hiptobecubic> Guest79874, strings are linked lists in haskell. Not arrays.
10:01:17 <ranger66> donri: thanks, works fine in this case
10:01:18 <ranger66> :)
10:01:33 <hiptobecubic> > id ['a', 'b', 'c']
10:01:34 <lambdabot>   "abc"
10:01:50 <hiptobecubic> i guess id probably wasn't necessary :)
10:01:56 <Botje> Guest79874: and it uses "[" ++ (big thing here) ++ "]"
10:01:58 <GlitchMr> id is identify function, I guess?
10:02:01 <Botje> which is also pretty horrible :(
10:02:04 <danr> hiptobecubic: one or two ids never hurt anyone
10:02:08 <latro`a> hrm
10:02:15 <latro`a> there's a bytestring benchmark there
10:02:20 <latro`a> which is still 8 ms vs python's 4
10:02:23 <hiptobecubic> danr, i start every function with   = id $
10:02:35 <danr> hiptobecubic: yeah, that's good coding practice ;)
10:02:44 <hiptobecubic> to keep it general
10:02:50 <osfameron> can you actually distinguish anything with a benchmark in the region of *milliseconds* ?
10:02:59 <latro`a> yeah, I was gonna say
10:03:00 <Botje> ah, dons already added a followup :]
10:03:03 <osfameron> shouldn't you do the benchmark with n = 30000 or similar?
10:03:05 <latro`a> there's issues with just startup time and so on
10:03:11 <latro`a> when the timings are milliseconds
10:03:17 <osfameron> yeah
10:03:19 <merijn> latro`a: To be fair, python's IO is ridiculously fast since it's all just straight up C calls
10:03:39 <latro`a> true
10:04:10 <hiptobecubic> he still converts the bytestings to strings, then traverses the whole thing to add ']' at the end
10:04:47 <luite> that's probably required by the FastCGI lib he uses?
10:05:03 <latro`a> the prepend would be slow in the python, though, no?
10:05:17 <latro`a> eh, hard to tell I guess
10:05:24 <luite> could be fast in python if they use ropes internally
10:05:38 <luite> v8 uses ropes for example
10:05:39 <latro`a> you're right, though, he randomly brings strings back
10:05:44 <merijn> python strings are pretty damn fast too
10:05:48 <Guest79874> luite: what are ropes ?
10:05:56 <Clint> he should use outputFPS instead of output
10:06:07 <luite> Guest79874: trees of shorter strings
10:06:32 <oneb> is there a way to do profiling from ghci, or do you have to make a new haskell file with the expression you wan to profile in main and use ghc from command line?
10:06:32 <pnielsen> appending to a list and doing "".join(out) is much faster in Python
10:06:53 <Yiq> Pure code is the shiznit. Problem it is often ridicously inefficient in non-haskell langs. upside is that inefficieny doesnt matter most of the time
10:18:03 <oneb> "Could not find module `System.IO.UTF8': Perhaps you haven't installed the profiling libraries for package `utf8-string-0.3.6'?" <- so how do I get profiling libraries?
10:18:37 <hiptobecubic> oneb, go back in time to when you installed that library and use the -p flag with cabal install
10:19:40 <Clint> or apt-get install libghc-utf8-string-prof
10:19:54 <oneb> windows here
10:20:07 <Clint> ouch
10:20:07 <oneb> guess i'll reinstall it
10:20:14 <hiptobecubic> doesn't haskell platform come with that?
10:20:50 <Clint> hiptobecubic: no?
10:20:52 <oneb> shouldn't -p be enabled by default though
10:21:29 <hiptobecubic> oneb, you can enable it by default if you edit your cabal config
10:25:10 <oneb> now this I like, partial profiling graphs for programs that take too much memory to be able to finish
10:25:53 <bootcode> hello
10:26:19 <bootcode> is there a monad for concurrent computations?
10:26:51 <osa1> I seperated lexing and parsing stages using parsec but now error messages are less helpful. when it encounters an unexpected token, it gives an error message but error message doesn't contain what tokens were expected. do you know why?
10:26:59 <maurer> bootcode: What you're asking for could mean a lot of different things. What are you thinking of?
10:28:09 <bootcode> maurer: like scala's `Future / Promise a`, a computation eventually yielding `a`
10:28:31 <hiptobecubic> sounds like laziness :)
10:28:34 <bootcode> usually running on a dispatcher pool
10:28:39 <hiptobecubic> sparks maybe?
10:29:41 <hiptobecubic> bootcode, http://stackoverflow.com/questions/958449/what-is-a-spark-in-haskell
10:29:48 <maurer> bootcode: I think the normal way of doing that is either to use sparks or forkIO + an MVar
10:29:59 <GlitchMr> reverse (5 : reverse [1, 2, 3, 4])
10:30:05 <GlitchMr> I've feeling I shouldn't write code like this
10:30:07 <maurer> There may be a monad encoding this operation, but I'm not immediately aware of it
10:30:50 <hiptobecubic> GlitchMr, you are correct
10:30:56 <hiptobecubic> GlitchMr, why did you do that?
10:31:31 <merijn> I think he wanted to implement an append function or something?
10:31:46 <hiptobecubic> it appears so
10:32:22 <GlitchMr> I guess the answer is simply that instead of pushing I should shift?
10:32:52 <merijn> GlitchMr: Depends, what are you trying to do?
10:33:03 <parcs`> bootcode: do you mean concurrent IO computations or pure parallel computations?
10:33:14 <byorgey> GlitchMr: if you need to append to the end of a list you can do  [1,2,3,4] ++ [5].  But that still takes linear time.
10:33:32 <hiptobecubic> GlitchMr, a common pattern in haskell is to build up your list with conses (:) and then reverse it at the end
10:33:39 <byorgey> GlitchMr: better is to come up with a way so that you don't need to append to the end of a list, or use a different data structure.
10:34:14 <byorgey> (or build up your list as a difference list using composition and then run it at the end =)
10:34:40 <bootcode> parcs`: exactly that is where i want to get to, so interested in both
10:35:55 <bootcode> how do you do concurrent IO?
10:36:48 <hiptobecubic> take a shot of tequila and sequence a list of forkIO calls maybe?
10:37:06 <parcs`> bootcode: there's the 'async' package for concurrent IO computations and 'monad-par' for pure parallel computations
10:37:52 <hiptobecubic> If you have an embarrassingly parallel problem, you can also just do a parallel map over the list of problems
10:42:04 <clintm> (lparallel:pmacpc!
10:42:11 <clintm> ack! damnit... wrong channel. :/
10:42:29 <clintm> correctish answer, wrong channel. hah. what a weird feeling.
10:42:58 <Clint> conspiracy
10:47:04 <oneb> can anyone spot the memory leak in this? http://hpaste.org/73847
10:47:58 <srhb> woah
10:48:44 <clintm> cut, paste, reformat... heh.  Good thing I was bored. :)
10:51:41 <hiptobecubic> oneb, did you run this through a js compressor or what?
10:52:41 <srhb> I don't even understand how that can compile. Does it?
10:52:42 <oneb> hiptobecubic: heh
10:52:58 <oneb> hm
10:53:08 <oneb> sorry, sec
10:53:39 <srhb> oneb: Also, foo $ bar $ baz is generally frowned upon, hlint should tell you the same.
10:54:02 <oneb> http://hpaste.org/73848
10:54:16 <oneb> made a little indentation error when tranferring it from text editor
10:55:53 <oneb> srhb: what am I supposed to use instead? let barbaz = bar $ baz in foo $ barbaz?
10:56:11 <oneb> don't see a warning about it in hpaste
10:56:26 <statusfailed> oneb: I usually bracketise big expressions
10:56:31 <statusfailed> I find it easier to read
10:56:36 <statusfailed> foo (bar) (baz)
10:56:51 <geekosaur> I think the recommended way is:  foo . bar $ baz
10:57:00 <oneb> ah
10:57:11 <Clint> @pl \tags -> foldl' f Map.empty $ tail $ partitions  (withAttr "span" ("class", "my_wholepost")) tags
10:57:11 <lambdabot> foldl' f Map.empty . tail . partitions (withAttr "span" ("class", "my_wholepost"))
10:58:42 <Botje> hmm.. I have a FilePath -> IO (Just a) operation that I mapM over 10k files, what's the right incantation to prevent the "too many open files" exception?
10:59:02 <srhb> Botje: Maybe a, you mean
10:59:10 <Botje> uh, yeah
10:59:14 <Cale> Botje: I take it you're using lazy readFile from the Prelude?
10:59:29 <GlitchMr> I find yourself typing != when I mean /=. I should be happy that != isn't fork bomb operator.
10:59:39 <srhb> GlitchMr: Yes :P
10:59:41 <Cale> Botje: Or perhaps opening the files and using hGetContents?
10:59:46 <Botje> Cale: i'm using decodeFile from Data.Binary, which uses BS.Lazy internally.
10:59:52 <Cale> I see
11:00:05 <aristid> Botje: just use conduits :P
11:00:11 <oneb> (well, this is the code in the form in which I actually edit and test it, if I wanted to upload it to github or something I'd change it to follow style conventions, but trying to follow style conventions while editing makes editing harder imo)
11:00:17 <Cale> Well, apart from using something like cereal instead
11:00:24 <Cale> (which is strict)
11:00:30 <GlitchMr> I probably could make function != which would work like /=, but this probably would make programs more confusing
11:00:41 <Cale> You can force the evaluation of each result before opening the next file
11:00:51 <Cale> which should ensure that the file handle can be closed
11:01:17 <srhb> GlitchMr: Sure, you can just do (!=) = (/=)
11:01:20 <Cale> It's really unfortunate that operating systems just suck at having lots of open files.
11:02:00 <Botje> i'm trying to use evaluate to force certain things, but it's not really working as expected
11:02:03 <srhb> Cale: Can't we just make it even lazier? :-)
11:02:12 <Cale> (I should be able to have as many open filehandles as I have memory for, damnit)
11:02:23 <aristid> GlitchMr: you could just call sed -i -e 's/!=/\/=/g' or so on your code
11:02:33 <hpaste> GlitchMr pasted “!=” at http://hpaste.org/73849
11:02:39 <Clint> i'm sure that's possible on the hurd
11:02:42 <Cale> Botje: yeah, you may also need to use deepseq/rnf
11:03:13 <GlitchMr> Hmmm... (!=) = (/=) didn't worked
11:03:18 <Cale> Botje: It may be simpler to swap out Data.Binary for Data.Serialize from the cereal package
11:03:22 <GlitchMr> Operator exists, but it doesn't work
11:03:32 <Cale> If you don't really need the lazy reading
11:03:49 <Cale> (usually if you have a lot of input files, you don't want them to be handled lazily)
11:04:01 <Clint> there's cereal-conduit too
11:04:06 <Botje> Cale: okay, i'll try that :]
11:04:41 <merijn> GlitchMr: How did you define (!=)? Just as "(!=) = (/=)"?
11:05:08 <GlitchMr> let (!=) = (/=)
11:05:15 <GlitchMr> Without "let" it didn't worked
11:05:20 <merijn> Ah, in ghc?
11:05:23 <GlitchMr> But I guess I'm doing it wrongly
11:05:24 <GlitchMr> ghci
11:05:25 <merijn> eh, ghci
11:05:45 * merijn suspects GHCI's defaulting acting up
11:05:59 <srhb> GlitchMr: All function declarations in ghci must be preceded with let - but not in haskell source as such.
11:06:15 <Cale> I would go to a fair amount of trouble to avoid all that Conduit/Iteratee/etc. stuff, and I don't think it's really needed for typical applications. But I might just be biased.
11:06:26 <srhb> THough in fairness the monomorphism restriction would still hit you
11:06:40 <srhb> so you need let x != y = x /= y
11:07:01 <Cale> I haven't seen anything from that whole design space which I actually thought seemed elegant to me.
11:07:30 <merijn> GlitchMr: Basically, ghci is defaulting to a much restricted version of the function. If you defined it in a haskell source file it wouldn't, but you'd still get hit by the Dread MonoMorphism Restriction
11:08:06 <Clint> Cale: i like conduits.. but then i don't know what i'm doing
11:08:38 <srhb> GlitchMr: Just defined it as let x != y = x /= y
11:08:43 <srhb> define*
11:08:47 <merijn> GlitchMr: Personally I usually create haskell source file in which I write stuff with an editor and then I load that file into ghci to play around with what I write
11:19:28 <fourier> Hi all
11:19:46 <timthelion> fourier: hi
11:19:59 <fourier> I have a small question regarding to infinite lists and fold[r,l]
11:20:31 <fourier> Suppose that I want to write a function which takes first n unique elements from the list
11:20:53 <fourier> My implementation is takeUniq lst n = take n $ foldl (\x y -> if notElem y x then x ++ [y] else x) [] lst
11:21:39 <fourier> But then I fall into infinite loop if use infinite lists..
11:21:52 <tromp_> yes, foldl will do that
11:22:01 <napping> use foldr, or just Data.List.nub
11:22:28 <fourier> foldr doesn't help either by some reason.. takeUniq lst n = take n $ foldr (\x y -> if notElem x y then y++[x] else y) [] lst
11:22:34 <JDreamKiller> hello?
11:22:46 <napping> well, y depends on the result
11:22:48 <srhb> JDreamKiller: Hello
11:22:51 <FireFly> How would you know if an element is unique if the list is infinite?
11:22:59 <JDreamKiller> IDK
11:23:06 <JDreamKiller> I just started learning
11:23:11 <napping> what you can do instead is use foldr to build a function that takes a list of the things you have seen so far
11:23:34 <fourier> It shall not exist in accumulator
11:24:13 <napping> yeah, like foldr (\x rest seen -> if x `elem` seen ...) ...
11:24:19 <srhb> No, that does not help
11:24:40 <fourier> that was exactly what I tried to do
11:24:48 <merijn> fourier: It is (theoretically and practically) impossible to determine whether an element is unique in an infinite list
11:24:51 <napping> there are three arguments on the lambda
11:24:55 <napping> not two
11:24:56 <srhb> Nothing is stopping the foldr from running all the way through unless you do clever things.
11:25:02 <Cale> take n . nub
11:25:06 <fourier> ah
11:25:16 <srhb> the point, I think, is to take the FIRST unique things
11:25:37 <fourier> Yes, FIRST n unique elements
11:25:37 <merijn> :t nub
11:25:38 <lambdabot> forall a. (Eq a) => [a] -> [a]
11:25:43 <srhb> So nub will not help either.
11:25:58 <napping> > take 10 $ Data.List.nub [1..]
11:25:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:26:02 <srhb> It's much easier to make a recursive definition here
11:26:03 <merijn> > nub [1,2,3,4,5,4,3,2,1]
11:26:04 <lambdabot>   [1,2,3,4,5]
11:26:13 <srhb> Ugh, enough with the nonsense :P
11:26:15 <merijn> > nub [1,3,2,3,4,5,4,3,2,1]
11:26:16 <lambdabot>   [1,3,2,4,5]
11:26:22 <napping> please try things before claiming they don't work out
11:26:53 <tromp_> > nubBy(((>1).).gcd)[2..]
11:26:56 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
11:26:57 <merijn> > nub $ [1,3,2,3,4,5,4,3,2,1] ++ [1..]
11:27:00 <lambdabot>   [1,3,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:27:10 <fourier> hm
11:27:12 <srhb> Sorry, I missed the 'n'
11:27:26 <jfischoff> > take 1 . nub $ repeat 1
11:27:27 <lambdabot>   <no location info>: lexical error at character '\FS'
11:27:28 <napping> fourier: completing the foldr I suggested will work
11:27:28 <srhb> I thought the idea was to take items until there was a non-unique one already, not n
11:27:47 <napping> or a direct recursive definition might be simpler
11:27:48 <fourier> I had recursive definition before :) just wanted to rewrite it with fold
11:28:25 <atriq> j #transmission
11:28:29 <atriq> Woops
11:28:30 <srhb> fourier: Could you clarify what you mean by n again, do you want to take a fixed number of the first unique elements, or do you want to grab elements while they have not been seen before?
11:29:40 <fourier> I want to iterate through the list and accumulate first N unique elements
11:29:50 <srhb> fourier: Where N is a given argument?
11:29:52 <napping> yes, that's a good point - everything suggested has been taking the first occurences, checking if the element only occurs once in an infinite list is impossible
11:29:58 <srhb> Yeah, which is why I protested
11:30:09 <fourier> like takeUniq 3 [1,2,3,2,1,3,2,1] shall return [1,2,]3
11:30:18 <srhb> fourier: Fine, then the nub solution is correct
11:31:11 <fourier> Ahha ok thanks ! will try it with the nub solution. Thanks guys! :)
11:37:16 <hpaste> mmos1127 pasted “instances” at http://hpaste.org/73852
11:38:59 <mmos> see http://hpaste.org/73852 for my question
11:39:36 <merijn> mmos: I'm guessing it doesn't compile because you don't have a MonadError constraint on your function
11:39:46 <merijn> i.e.
11:40:04 <merijn> getInt :: MonadError String m => a -> m Int
11:40:30 <merijn> Not 100% sure though, maybe pastebin the compile error too?
11:40:32 <mmos> merijn: can I drop the MonadError constrain from the Foo class?
11:42:20 <merijn> mmos: I think you can simplify your entire class to "class Foo a where getInt :: MonadError String m => a -> m Int"
11:42:21 <hpaste> mmos1127 annotated “instances” with “instances (annotation)” at http://hpaste.org/73852#a73853
11:42:37 <mmos> I just pasted a version that comipiles!!!
11:42:54 <merijn> mmos: Just because something is used in the type of a class doesn't mean it needs to be a parameter of that class
11:43:32 <merijn> mmos: You also shouldn't need those language extensions anymore
11:43:39 <mmos> merijn: I think I understand. vaguely. I never really went over an explanation of this stuff in detail.
11:43:58 <mmos> I wonder if my compiler version is old. how do I check?
11:43:59 <mroman> For the first time I'm actually surprised the code my brain spit out works o_O
11:44:11 <mmos> Ah I have version 6
11:44:24 <mmos> 6.12.3
11:44:44 <Clint> that's pretty old
11:44:47 <merijn> mmos: Basically the typeclass parameters let you define different instance for varying combinations of types. But that's not really what you wanted here
11:45:27 <merijn> mmos: In this case you only wanted to give a new instance for different values of a, not really caring about m (other than m being an instance of MonadError, because getInt uses functions of MonadError)
11:45:48 <merijn> mmos: So that means you'd usually want the MonadError constraint to be part of getInt, rather than of the entire typeclass
11:46:05 <mmos> merijn: thanks for the detailed explanation
11:46:08 <merijn> The restriction on the typeclass would limit which instances you can define without error
11:46:19 <merijn> Not so much what the functions in it can or cannot do
11:47:32 <mmos> Is it true that I'm not allowed to put a type signature on the functions I define in the instance?
11:48:07 <merijn> mmos: You can, it just can't be different from the one in the class :p
11:48:08 <mroman> How does ghc infer the type of an argument that is not used?
11:48:18 <merijn> mroman: It can't
11:48:25 <mroman> like foo a _ = 8; foo 0 _ = 1;
11:48:42 <mroman> But still, somehow it infers a type.
11:48:56 <merijn> mroman: It looks at where you use foo. If you call "foo 0 'c'" it'll infer the type is Char for the second argument
11:48:58 <mroman> or not.
11:49:09 <mroman> maybe I have a usage somewhere where I don't see it.
11:49:12 <mmos> I've noticed that ghc sometimes complains if I don't ever put something that makes it clear what types I mean with the instance
11:49:13 <merijn> mroman: If you write "foo 0 'c'" *and* "foo 0 1" you will get an error
11:49:30 <merijn> mmos: Such as?
11:49:35 <srhb> merijn: Why?
11:50:15 <mroman> Huh.
11:50:27 <srhb> foo _ _ = 10; bar = foo 1 1; baz = foo 'c' 2 -- what is wrong with this?
11:50:42 <mroman> I accidentally passed something to the unused argument.
11:50:43 <mmos> I don't remember the details, but I had a data type than include functions as data, and the functions operated on types that were part of my typeclass, and ghc wasn't able to infer the type because I only called the function through fetching it from the data.
11:50:44 <mroman> My fault.
11:51:13 <mmos> I think that was it. something like that. Anyway when I put a type signature on one function, it compiled, didn't have to change any code
11:51:37 <srhb> mroman: foo _ _ = 2 will have type a -> b -> Integer
11:51:52 <mroman> Yeah, I know.
11:52:05 <srhb> mroman: Mkay. I guess I did not understand the question then :-)
11:52:07 <mroman> That's why I was so surprised ghci actually assigned it a concrete type.
11:52:10 <srhb> Aaah
11:52:11 <mmos> Obviously I'm "coding by the seat of my pants". It's a little awkward. I would have to get the code and paste it for you to see, but I have time pressure and it's not the priority right now
11:52:12 <srhb> COncrete. :P
11:52:13 <merijn> srhb: hmm, maybe you're right
11:52:27 <mroman> But I used the unused type somewhere in my code where I didn't see it.
11:52:30 <mroman> *argument
11:52:43 <merijn> mmos: Did the error include the words "monomorphism restriction"?
11:53:06 <mroman> @type let foo _ _ = foo 1 1
11:53:07 <lambdabot> <no location info>: not an expression: `let foo _ _ = foo 1 1'
11:53:09 <mroman> like that.
11:53:23 <mroman> then it is assigned a type.
11:54:32 <mmos> merijn: I believe it did
11:55:21 <merijn> mmos: Ok, that's a special case. If you have something that *looks* like a value, but isn't (i.e. "foo = [1..10]") the monomorphism restriction kicks in
11:55:37 <neothemachine> after I reinstalled the haskell platform in a folder without whitespaces (sigh..), I'm now closer to my goal of installing monadiccp but it still fails, see far bottom http://hpaste.org/73854 ld just cannot find the libs
11:56:00 <merijn> mmos: The problem with "foo = [1..10]" is that it has type "Num t => [t]" i.e. it can be a different t each time, which mean the list has to be recomputed (with the correct type) every time you use it
11:56:17 <neothemachine> should I be worrying that cabal uses a pkg-config.exe from graphviz?
11:56:44 <merijn> mmos: To prevent this counterintuitive recalculation ghc restricts cases like that to be of a specific type (for example [Int]) if you use it as [Int] somewhere in your code
11:57:23 <dcoutts> neothemachine: it's not distributed with cabal, and on windows many C libs come with their own copy of pkg-config
11:57:47 <merijn> mmos: The two possible solutions are: explicit type signature to tell GHC that you *want* it to recompute everytime based on type OR disable the monomorphism restriction (add "{-# LANGUAGE NoMonoMorphismRestriction #-}" at the top of the file)
11:58:02 <neothemachine> dcoutts: does cabal depend on this information that pkg-config returns?
11:58:05 <dcoutts> neothemachine: it's probably ok, but could cause an issue if you use a very old pkg-config from one C lib to work with .pc files from another C lib
11:58:25 <merijn> mmos: It's perfectly fine/safe to turn of MMR, just be aware that some top level expressions might get recomputed multiple times (as a newbie you probably want to turn if off anyway)
11:58:27 <dcoutts> neothemachine: some cabal packages depend on C libs and get info via pkg-config
11:58:40 <srhb> The linker is failing in this case though
11:59:02 <timthelion> is it possible that neothemachine needs to install gecode(a c++ program) seperately?
11:59:16 <srhb> Sounds reasonable
11:59:16 <neothemachine> I installed gecode already
11:59:42 <timthelion> neothemachine: but is it in g++'s path in that particular mgwin folder?
11:59:44 <bootcode> @type async
11:59:45 <lambdabot> Not in scope: `async'
12:00:02 * timthelion notes that he does not use windows and is likely spouting shit.
12:00:07 <mmos> merijn: despite that I don't completely understand them, I can see how Haskell typeclasses and types express the heart of needed abstraction. I used C++ previously, and it has multiple inheritance and templates -- so ugly compared to haskell.
12:00:09 <srhb> Are the header files in Programme/Gecode/include?
12:00:16 <neothemachine> yes
12:00:19 * srhb is also most likely saying nonsense
12:00:21 <neothemachine> I run it with: cabal install monadiccp --flags="RuntimeGecode Debug" --extra-lib-dirs="D:\Programme\Gecode\lib;d:\programme\Gecode\bin" --extra-include-dirs=D:\Programme\Gecode\include\ -v3 > log.txt 2<&1
12:00:27 <bootcode> @type Control.Concurrent.Async.async
12:00:29 <lambdabot> Couldn't find qualified module.
12:00:57 <bootcode> well, it is async :: IO a -> IO (Async a) - i like it
12:01:07 <srhb> No idea.
12:01:17 <mmos> C++ confuses classes vs. types -- or that is how it seems to me now
12:01:35 <mmos> because every class is a type also, but that's not what you want, really, when you look at the heart of the problem
12:01:45 <neothemachine> in the cabal file it says: "Frameworks: gecode" what does that really mean?
12:01:49 <johnw> in C++, type classes != classes
12:01:55 <johnw> there are no type classes
12:02:03 <dcoutts> neothemachine: that only applies on OSX
12:02:26 <johnw> value constructors = classes, type constructors = templates, type classses = <what would have been/will someday be concepts>
12:03:09 <hiptobecubic> they are  a bit like java's 'interfaces' no?
12:03:22 <johnw> kind of, but not really
12:03:31 <johnw> you can think of them as interfaces
12:03:32 <neothemachine> so, must the libs be registered in pkg-config to be found?
12:03:41 <hiptobecubic> johnw, how do they differ?
12:04:36 <dcoutts> neothemachine: is cabal is complaining that a pkg-config package cannot be found?
12:04:58 <johnw> type classes apply prior to "instantiation" of the function in C++
12:05:11 <johnw> interfaces apply during instantiation
12:05:16 <johnw> whether this is the same in Java, I don't know
12:05:17 <neothemachine> nope, but I'm just wondering because when I run pkg-config --list-all, then there is only graphviz stuff
12:05:24 <johnw> type classes therefore lead to far better errors
12:05:33 <johnw> the error is "x is not a Num", rather than "can't call foo on x"
12:07:05 <johnw> (especially when that call is deep inside other functions being called from yours)
12:08:38 <shachaf> Num tends to lead to much more annoying error messages than non-type-cass functions.
12:09:07 <shachaf> That's part of why they took type classes out of Helium. :-)
12:09:18 <magnus__> Can anyone help me in how I can apply (:) to a tuple :: (a,[a]) in point free notation?
12:09:29 <shachaf> @ty uncurry (:)
12:09:30 <lambdabot> forall a. (a, [a]) -> [a]
12:09:34 <monochrom> this is why length does not have type Num n => [a] -> n
12:09:45 <shachaf> @ty genericLength
12:09:46 <lambdabot> forall b i. (Num i) => [b] -> i
12:09:52 <magnus__> awesome, thanks
12:09:52 <rosie> What's the correct indentation for nested case statements? e.g. Let's say I have a case x of, and I want two cases. One will return a value, and the other will continue to pattern match, and after the pattern matching, it will return a value.
12:10:01 <monochrom> and I am joking :)
12:10:16 <shachaf> Sadly, (genericLength x) is often worse than (fromIntegral $ length x) even for lists shorter than maxBound :: Int. :-(
12:10:20 <monochrom> there are many correct indentations
12:11:01 <lightquake> shachaf: really?
12:11:07 <Cale> rosie: The nested case expression should start in a deeper column than the first non-whitespace character after the 'of' in the outer one.
12:11:13 <monochrom> but try one with the first line "case x of P -> v", second line "Q -> w", align Q under P
12:11:27 <shachaf> If something is nested inside something else, it should be more indented.
12:11:35 <shachaf> @src genericLength
12:11:35 <lambdabot> genericLength []    = 0
12:11:36 <lambdabot> genericLength (_:l) = 1 + genericLength l
12:11:37 <shachaf> @src length
12:11:37 <lambdabot> Source not found. :(
12:11:50 <shachaf> Anyway, genericLength is meant to be lazy with types like Nat.
12:11:59 <shachaf> So it's not tail-recursive or anything.
12:12:27 <Cale> rosie: Also note that you can construct nested patterns which match on multiple parts of the input at once, so might be able to avoid nesting the case expressions that way. Pattern guards are also quite handy.
12:13:04 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards
12:13:14 <shachaf> Sometimes you can explicitly construct such a pattern: case (a,b) of ([],Nothing) -> ...; (...,...) -> ...
12:13:21 <hpaste> Rose pasted “nested cases” at http://hpaste.org/73855
12:14:06 <shachaf> Eek, that's a large and very indented piece of code.
12:14:36 <rosie> I think I'm misinterpreting how I should indent. I want the nested case statement so I can group together some cases that provide a parameter for a single function
12:14:50 <shachaf> (Is that syntax even valid? _ -> resp <- ... ?)
12:15:09 <Cale> I would probably start the ("insert":_) -> ... line around the same column as pathInfo req on the previous line.
12:15:26 <Cale> You could go even shallower
12:15:36 <jfischoff> shachaf: what's wrong with '_'?
12:15:43 <Cale> no it's not valid.
12:15:48 <shachaf> jfischoff: Nothing.
12:15:55 <jfischoff> ah
12:16:02 <Cale> There ought to be a 'do' in there somewhere
12:16:05 <shachaf> jfischoff: <- doesn't usually stand on its own like that.
12:16:23 <jfischoff> yeah, I misunderstood you
12:16:26 <Cale> but also, these cases match on the same expression
12:16:36 <Cale> the nested one is matching on pathInfo req
12:16:46 <shachaf> Oh, yes, they do.
12:16:47 <Cale> which is the exact same expression that the outer one is matching on
12:16:58 <Cale> So you don't need to nest at all
12:17:14 <shachaf> Also, please don't use ByteString.Char8. :-(
12:17:25 <shachaf> Not that that's relevant. But still.
12:17:55 <ericmj> shachaf: Why is that?
12:18:12 <rosie> Thanks. shachaf: Why? Cale: How can I return from the first case, and return a single function that takes a parameter generated from all the rest of the cases?
12:18:38 <shachaf> ericmj, rosie: Because a ByteString is a string of bytes, not a string of characters. Most characters don't fit in a byte.
12:18:43 <Cale> also, there's this weird return at the end there which doesn't seem to belong to anything
12:19:12 <shachaf> What you want, if you're really sure you want a ByteString, is to encode your String (probably as UTF-8).
12:19:14 <ericmj> shachaf: but as long you use ascii it should be fine. right?
12:19:54 <shachaf> ericmj: I see people's names being "packed" there.
12:19:56 <Cale> so, all the branches of this case are needlessly monadic
12:20:06 <hpaste> wm pasted “parList” at http://hpaste.org/73856
12:20:08 <Cale> because they all just consist of  return and let
12:20:20 <shachaf> ericmj: People's names are not "ascii".
12:20:45 <rosie> Cale: would you mind explaining in more detail why they are needlessly monadic?
12:21:00 <ericmj> oh, i havent followed the discussion sorry. i just meant in the general case, when you are sure you are using only ascii
12:21:19 <shachaf> ericmj: That's not the general case.
12:21:23 <Cale> rosie: If none of them actually *do* anything, but are just return (...), then you can pull the return out of the case
12:21:27 <shachaf> ericmj: That's a very specific case. :-(
12:21:55 <Cale> rosie: this case is essentially just defining a String, but happens to apply return to that String in all cases
12:22:05 <shachaf> ericmj: Most of the time what happens is that people say "oh, it'll only ever be ASCII!" and it looks like their program works until someone who speaks something other than English tries to use it. :-)
12:22:27 <ahkurtz> use ascii for network protocols. use utf8 for actual text content for humans
12:22:39 <rosie> shachaf: So what specific code do you recommend instead?
12:23:11 <shachaf> A function called something along the lines of "encodeUTF8" would probably be good.
12:24:28 <monochrom> use binary for student ID. yes you are just a number.
12:24:35 <hpaste> Cale annotated “nested cases” with “nested cases (annotation)” at http://hpaste.org/73855#a73857
12:24:41 <Cale> rosie: ^^
12:24:41 <monochrom> generalize from student to all humanity
12:24:53 <shachaf> Anyway that's irrelevant to what you're asking, but it's important to mention sometime.
12:25:13 <shachaf> Cale: You're missing the (commented out, admittedly) mapM_ there.
12:25:40 <Cale> shachaf: that's a reasonably point
12:25:44 <Cale> reasonable*
12:25:49 <shachaf> Of course there are other ways to do that.
12:26:38 <shachaf> There are also other ways to write a lot of that code. :-)
12:26:48 <shachaf> If you're doing isJust followed by fromJust, that means you're doing something wrong.
12:27:02 <Cale> Yeah, I didn't even look at that part :)
12:27:35 <shachaf> You might do something like [(S8.unpack key, S8.unpack val) | (key, Just val) <- queryString req], for instance.
12:27:41 <Cale> Probably a list comprehension with a pattern ... yes
12:28:25 <Cale> user = snd (twoPartParams!!0) <-- this also is scary
12:28:27 <shachaf> You might also abstract a lot of this code into a "where" clause or something.
12:28:30 <shachaf> Yep.
12:28:48 <Cale> You really want to handle the case where that list is empty and where it's not empty
12:29:02 * shachaf wonders what happened to hlint.
12:29:07 <Cale> and pattern matching will bind a variable for the first element of that list in the nonempty case anyway
12:29:29 <rosie> Cale: Thanks, but I want the first login "Response" to be returned on its own, and not converted to a string in the final return. Does that make sense?
12:29:56 <Cale> oh, there are still type errors in this
12:30:50 <Cale> Right, you'll want to pull the construction of the response in the other cases into the case.
12:31:00 <Cale> Like with the login
12:31:21 <Cale> You may want to construct a function for creating the ok response
12:31:35 <rosie> Cale: that sounds good
12:32:29 <magnus__> Is this an overcomplicated way for a function to put together a value with the rest of the calculated ones? => uncurry (:) . (id &&& iterate decision)
12:32:39 <magnus__> decision just maps :: a -> a
12:33:03 <shachaf> @ty uncurry (:) . (id &&& iterate (+1))
12:33:03 <lambdabot> forall a. (Num a) => a -> [a]
12:33:10 <shachaf> > uncurry (:) . (id &&& iterate (+1)) $ 5
12:33:12 <lambdabot>   [5,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
12:33:28 <shachaf> @pl \x -> x : iterate f x
12:33:28 <lambdabot> ap (:) (iterate f)
12:33:44 <shachaf> Yes, that's somewhat overcomplicated. :-)
12:33:52 <magnus__> :)
12:34:13 <monochrom> @unpl uncurry (:) . (id &&& iterate decision)
12:34:14 <lambdabot> (\ d -> uncurry (:) (((\ a -> a) &&& (iterate decision)) d))
12:34:25 <shachaf> I would probably just write it out pointfully.
12:34:48 <shachaf> (:) <*> iterate decision is also not that bad.
12:34:59 <shachaf> But only if you know what (<*>) means.
12:35:02 <hiptobecubic> decision?
12:35:06 <shachaf> Pointful code doesn't hurt. :-)
12:35:21 <magnus__> I like the point free style though
12:35:30 <shachaf> hiptobecubic: "decision" is the new name for "f". Haskell people are rebelling against one-character identifiers.
12:35:44 * timthelion prefers pointful code except in places where it "looks right" like in maps.
12:35:57 <hiptobecubic> why not "unnamedFunction"
12:36:00 <carpi> http://imgur.com/Yqb8L     <- Did I understand correctly? Simply follow the arrows
12:36:08 * eikke always runs "pointfree" so his colleagues need "pointful"
12:36:09 <shachaf> magnus__: (x : iterate f x) is immediately obvious.
12:36:12 <magnus__> I like (:) <*> iterate f
12:36:31 <shachaf> magnus__: The other things -- especially your original one -- need some thinking to figure out.
12:36:47 <hiptobecubic> (x : iterate f x) is definitely the least obfuscated
12:37:26 <timthelion> eikke: ???
12:37:49 <timthelion> eikke: did I read that correctly, that you obfuscate your code just so you'll never lose your job???
12:37:58 <eikke> timthelion: it was a joke
12:38:14 <shachaf> Please calm down with the ?s. :-(
12:38:31 <eikke> my colleagues only get in touch with my ocaml code, we don't do haskell yet (officially)
12:38:47 <magnus__> Just somewhat new to haskell
12:39:15 <shachaf> The *real* type of (:) should be Maybe (a,[a]) -> [a]
12:39:17 <magnus__> Just noticed that iterate actually does what I want
12:39:23 <shachaf> And uncons should be [a] -> aybe (a,[a])
12:39:27 <magnus__> take 10 $ iterate (+1) 1
12:39:39 <magnus__> includes the first value, not just the iterated ones
12:39:49 <shachaf> Also foldr should be (Maybe (a,b) -> b) -> [a] -> b
12:39:56 <monochrom> too bad we don't usually use ? in haskell operators
12:40:06 <timthelion> shachaf: why? what's wrong whith (:) :: a -> [a] -> [a]?
12:40:08 <shachaf> magnus__: OK, great.
12:40:37 <shachaf> magnus__: Remember you don't need to @pl everything. :-)
12:40:45 <shachaf> timthelion: Nothin'.
12:41:06 <magnus__> shachaf: pl?
12:41:19 <timthelion> shachaf: then why did you say the "*real*" type should be ...
12:41:20 <magnus__> Thanks for your help btw
12:42:04 <hpaste> Cale annotated “nested cases” with “nested cases (annotation) (annotation)” at http://hpaste.org/73855#a73859
12:42:06 <shachaf> timthelion: Because of uncons.
12:42:24 <Cale> rosie: ^^ perhaps something like that would work too
12:42:36 <monochrom> the real type of (&&) should be Maybe (Maybe Bool, Maybe Bool) -> Maybe Bool
12:42:39 <timthelion> shachaf: really, what DOES @pl mean?
12:42:56 <Cale> timthelion: pl stands for pointless
12:43:04 <rosie> Cale: cool, thanks!
12:43:08 <timthelion> Cale: ah
12:43:09 <magnus__> aha
12:43:31 * timthelion remembers that >>= is another case where pointlessness is not completeley pointless.
12:43:37 <shachaf> rosie: Did you write that entire chunk of code without compiling it? :-)
12:43:38 <Cale> and is a little pun on "points-free style"
12:43:58 <magnus__> shachaf: I know, but it looks soo good :)
12:44:11 <shachaf> Usually for a piece of code like that I would start out with something that works and slowly add pieces to it and type-check it.
12:44:24 <rosie> shachaf: nope (; just added the login bit. That added that new level complexity.
12:44:42 <Cale> timthelion: something to remember though is that whenever you have function composition to the right of >>=, you should probably flip it over and use =<<
12:44:46 <tromp_> i start out with something that works and then slowly remove pieces
12:45:13 <shachaf> When I'm working on a big codebase that takes a while to compile, I develop a form of "branch prediction" where I make a change, start off the compilation, and then keep working as if my change compiled successfully.
12:45:13 <timthelion> Cale: example?
12:45:28 <shachaf> If the compilation fails it counts as a "misprediction" and I lose a bit of work.
12:45:42 <monochrom> how long does compiling take?
12:46:00 <timthelion> shachaf: you realize you can compile individual files seperately.  So you can recompile just the file you are working on to type check it..
12:46:12 <shachaf> monochrom: Depends.
12:46:27 <shachaf> If it takes an hour I wouldn't do this, of course. But for something more than a few seconds and less than a few minutes.
12:46:31 <Cale> timthelion: print . lines =<< readFile "foo"  vs.  readFile "foo" >>= print . lines
12:46:33 <shachaf> timthelion: I'm not even talking about Haskell here.
12:46:42 <hiptobecubic>  Cale why?
12:46:58 <timthelion> Cale: what is the advantage to the former?
12:47:00 <Cale> hiptobecubic: Keep data moving in the same direction through the expression so it reads a bit better
12:47:26 <monochrom> yeah, consistent data direction
12:47:35 <Cale> It's maybe not so clear in my tiny example
12:47:38 <timthelion> Cale: I'm so used to unix | (pipes) that I really find the later easier to read.
12:47:41 <hiptobecubic> I always just read chains of >>= in the direction that they point :)
12:47:56 <monochrom> define "f ? g = g . f". imagine "a . b ? c . d ? e . f ? g ? h"
12:47:57 <shachaf> If you use a flipped (.) I'm sure Cale would have no objection to (>>=)
12:48:00 <Cale> timthelion: but unix pipes have a consistent direction too
12:48:21 <Cale> timthelion: The output of readFile "foo" is going into *lines* next
12:48:26 <Cale> not into print and then lines
12:48:37 <Cale> So to read it, you have to skip around a bit
12:48:38 <timthelion> Cale: ah, I see.
12:48:41 <hiptobecubic> oh
12:48:43 * timthelion doesn't use (.) much.
12:48:46 <monochrom> customers who bought unix pipes also like: readFile "foo" >>= lines ? print
12:49:03 <timthelion> monochrom: thanks amazon :)
12:49:10 <shachaf> @let (·) = flip (.)
12:49:12 <lambdabot>  Defined.
12:49:22 <hiptobecubic> I guess... I don't see how you can use haskell and not be used to semantically clumping composed functions together as one mental unit
12:49:24 <timthelion> shachaf: is that the braile comma?
12:49:29 <monochrom> too bad you can't use (|) in haskell, and (||) is taken
12:49:29 <shachaf> No.
12:49:46 <monochrom> there is still >>> if you don't mind
12:49:59 <timthelion> shachaf: what character is it then?
12:50:03 <Cale> you could also write   print . lines <=< readFile $ "foo"
12:50:10 <shachaf> timthelion: I don't know.
12:50:13 <hiptobecubic> timthelion, some horrible unicode that should be banned from source files :)
12:50:14 <timthelion> shachaf: it shows up for me as braille dot 2...
12:50:17 <Cale> and maybe abstract away the application :)
12:50:33 <shachaf> timthelion: That's weird. It's not.
12:50:57 <hiptobecubic> @type <=<
12:50:58 <lambdabot> parse error on input `<=<'
12:51:01 <hiptobecubic> @type )<=<)
12:51:02 <lambdabot> parse error on input `)'
12:51:02 <monochrom> U+00B7 "middle dot"
12:51:04 <hiptobecubic> @type (<=<)
12:51:05 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
12:51:22 <Cale> (<=<) is like (.), but monadic
12:51:27 <hiptobecubic> @type (=<<)
12:51:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:51:40 <Cale> (=<<) is like ($), but monadic
12:51:51 <monochrom> utf8 byte sequence 0xc2 0xb7
12:52:24 <shachaf> Â·
12:52:56 <hiptobecubic> oh weird, (<=<) works on values which are not in the monad
12:53:04 <shachaf> @let (¦) = flip (.)
12:53:06 <lambdabot>  Defined.
12:53:31 <timthelion> monochrom: reminds me of the guy who wrote implicitcad and typed all his vectors ℝ3
12:53:48 <Cale> > generalCategory '䷉
12:53:49 <lambdabot>   <no location info>:
12:53:49 <lambdabot>      lexical error in string/character literal at end o...
12:53:51 <Cale> > generalCategory '䷉'
12:53:52 <lambdabot>   OtherSymbol
12:53:53 <timthelion> monochrom: made it really hard for me to use his code, since I can't just type that...
12:54:00 <shachaf> @ty (+1) ¦ (*2) ¦ show ¦ (++"hi")
12:54:01 <lambdabot> forall a. (Num a) => a -> a
12:54:08 <monochrom> interesting, the range U+00Bn has utf8 code 0xc2 0xbn. this is ripe for a recursion joke. bn = c2 bn = c2 c2 bn = ...
12:54:09 <shachaf> Hmm?
12:54:15 <Cale> > let x ䷉ y = x + y in 7 ䷉ 9
12:54:16 <lambdabot>   16
12:54:26 <shachaf> What's going on with that type?
12:54:29 <shachaf> > ((+1) ¦ (*2) ¦ show ¦ (++"hi")) 5
12:54:30 <hiptobecubic> timthelion, that is my biggest problem with unicode source
12:54:31 <lambdabot>   "12hi"
12:54:33 <shachaf> @ty (+1) ¦ (*2) ¦ show ¦ (++"hi")
12:54:34 <lambdabot> forall a. (Num a) => a -> a
12:54:39 <monochrom> I prefer ℝ to R
12:54:43 <Cale> lol, you can use Yijing hexagrams for infix operators
12:54:48 <shachaf> Is @ty breaking off after the first non-ASCII character? :-(
12:54:52 <hiptobecubic> you could just define all your operators as kanji or something
12:54:59 <hiptobecubic> Cale, :)
12:55:05 <Cale> hiptobecubic: no, those would have to be prefix
12:55:16 <monochrom> yeah lambdabot is partly broken (but not fully) wrt utf-8
12:55:20 <Cale> > generalCategory '字'
12:55:20 * shachaf can "just type" ¦
12:55:21 <lambdabot>   OtherLetter
12:55:26 <Cale> They count as letters
12:55:30 <hiptobecubic> ah
12:55:36 <hiptobecubic> seems pretty arbitrary
12:55:37 <monochrom> it seems different lambabot plugins do it differently
12:55:41 <hiptobecubic> considering they aren't letters.
12:55:41 <watermind> isn't the dot operator in Strategies just an instance of <=<  ?
12:55:52 <Cale> Take it up with the Unicode consortium.
12:55:59 <monochrom> you now see why I hate the existence of iso-latin-1
12:56:01 <watermind> dot seems like a good name for the more general case... or maybe mdot
12:56:01 <hiptobecubic> I'm surprised japan hasn't
12:56:27 <timthelion> Cale: I can just imagine breaking into the Unicode headquarters with a sameri sward and a half kilo of plastic explosives...
12:56:30 <shachaf> monochrom: How do you feel about people who use ByteString.Char8?
12:56:55 <monochrom> I don't hate them. but they are victims of the existence of iso-latin-1
12:56:57 * timthelion realized, that he spelt two words wrong in that sentence...
12:57:31 <shachaf> That must be a new record.
12:57:38 <Cale> hiptobecubic: I think that in translation to Japanese, the distinction between letters and other characters is blurred.
12:58:35 <hiptobecubic> Isn't kanji symbol based, borrowed from chinese?
12:58:47 <hiptobecubic> Not like the korean alphabet, which is an actual alphabet of letters
12:59:25 <shachaf> Japanese also has an actual phonetic alphabet (in fact, it has more than one).
12:59:46 <Cale> hiptobecubic: But they would call our letters 字 as well.
13:00:28 <timthelion> Wow, the implicitcad guy has done some amazing stuff here http://implicitcad.org/ look at his web interface(to haskell backend)
13:01:32 <hiptobecubic> shachaf, they do, yes. But that's not kanji is it? Maybe i'm getting my names mixed up
13:01:43 <Cale> hiptobecubic: right
13:02:01 <Clint> it's not kanji; it's kana
13:02:27 <shachaf> hiptobecubic: I believe Korean also has borrowed Chinese characters, "hanja".
13:02:30 <Cale> hiptobecubic: 漢字 'kan' 'ji' means Chinese character
13:02:35 <shachaf> I don't know if they're used as much, though.
13:02:35 <FireFly> @let (˙) = flip (.)
13:02:37 <lambdabot>  Defined.
13:02:44 <shachaf> flip FireFly
13:02:44 <Martty> stop saying korea damn it
13:02:47 <hiptobecubic> shachaf, also true, but it's nowhere near as prevalent as the japanese case
13:02:57 <ion> > cycle "korea "
13:02:58 <lambdabot>   "korea korea korea korea korea korea korea korea korea korea korea korea ko...
13:03:06 <hiptobecubic> > scream "korea korea"
13:03:09 <lambdabot>   "kkkokrkekaokoooroeoarkrorrreraekeoereeeaakaoaraeaa"
13:03:14 * shachaf sighs.
13:03:25 <monochrom> eh? hehe
13:03:32 <ion> hiptobecubic: That was pretty. What’s the implementation of scream?
13:03:34 <FireFly> (╯°□°）╯︵ ɟɐɥɔɐɥs
13:03:50 <Clint> concat . sequence . words
13:04:08 <hiptobecubic> FireFly, :D
13:04:14 <ion> ah
13:04:20 <Cale> hiptobecubic: But my point is that the Japanese word for 'English letter' is 英字
13:04:32 <Cale> hiptobecubic: eiji
13:05:19 <Cale> hiptobecubic: So the distinction is not as large from their point of view (at least from an etymology perspective) between English letters and Chinese "letters", yeah?
13:05:50 <shachaf> I think #-blah
13:06:07 <Cale> I think too late for #-blah
13:07:20 <Cale> Anyway, in a practical sense, if you were to be using Japanese or Chinese letters to name things in Haskell, you'd definitely be unhappy if they were treated as symbol characters and you had to make everything infix.
13:07:39 <shachaf> Not that you should be doing that.
13:07:40 <inigo_> Hi, I'm learning Haskell
13:07:40 <inigo_> I can't understand how =<< works here:
13:07:40 <inigo_> listDir path = do mapM_ putStrLn =<< sort <$> getDirectoryContents path
13:07:41 <inigo_> could anyone explain please?
13:07:55 <shachaf> inigo_: Do you know what (>>=) does in general?
13:07:58 <timthelion> Cale: You could always put ()'s arround everything :)
13:08:19 <Cale> First of all, let's parenthesise that:  listDir path = do mapM_ putStrLn =<< (sort <$> getDirectoryContents path)
13:08:41 <Cale> So that it's clear what the parameters to =<< really are
13:08:54 <byorgey> also, the 'do' is unnecessary
13:08:56 <inigo_> shachaf: I'm read the description several times, but I can't say I understand it
13:09:10 <Cale> inigo_: are you aware of fmap?
13:09:14 <shachaf> inigo_: You should probably start with smaller uses of it, then.
13:09:24 <Cale> inigo_: Or, already know what the <$> is about?
13:09:28 <shachaf> And not try to figure out (<$>) at the same time. :-)
13:09:29 <inigo_> Cale: fmap yes, same than <$> ;-)
13:09:34 <shachaf> Ah.
13:09:35 <Cale> inigo_: right
13:09:47 <timthelion> inigo_: And then lets unfmap it... "listDir path = do mapM_ putStrLn =<< (do {contents <- getDirectoryContents path ; return $ sort contents)
13:10:00 <Cale> So sort <$> getDirectoryContents path is an action which gets the contents of the directory (a list of strings) and sorts them
13:10:10 <byorgey> timthelion: wat, why would you do that
13:10:18 <timthelion> byorgey: to understand it easier :)
13:10:23 <shachaf> ==byorgey
13:10:32 <Cale> and then mapM_ putStrLn is a function which takes a list of strings, and produces an action which prints them out one-per-line
13:10:41 <inigo_> Cale: I understand the right part of the expression, just missing light on the left
13:10:42 <byorgey> timthelion: understand fmap easier by explaining it in terms of do-notation which is syntax sugar for monad operations? o.O
13:10:47 <Cale> and =<< sticks those two things together in the obvious way
13:10:54 <Cale> Are you familiar with mapM_ ?
13:11:23 <timthelion> byorgey: of course. I'm stupid.
13:11:30 <inigo_> Cale: mapM_: yes
13:11:50 <timthelion> byorgey: stupid people require special syntax.  Didn't you learn that in school when they taught you about why some kids have to go to special ed?
13:11:58 <Cale> inigo_: Okay, so you know what  mapM_ putStrLn  means, yeah?
13:12:20 <Cale> inigo_: and what it would do if you wrote  mapM_ putStrLn ["hello", "there", "world"]
13:12:38 <shachaf> timthelion: I don't think that's helping. :-(
13:12:40 <inigo_> can't understand how =<< can transform IO [FilePath] in [FilePath] looking at the description
13:12:40 <byorgey> timthelion: I see
13:13:04 <shachaf> inigo_: mapM_ putStrLn :: [FilePath] -> IO ()
13:13:19 <shachaf> (=<<) :: ([FilePath] -> IO ()) -> IO [FilePath] -> IO ()
13:13:41 <Cale> inigo_: or somewhat more generally, (=<<) :: (a -> IO b) -> IO a -> IO b
13:13:57 <Cale> It's just a flipped over version of (>>=)
13:13:59 <shachaf> Right. When you're used to unification. :-)
13:14:03 <inigo_> ok, shachaf: that's what I was looking for
13:14:24 <matthiasgorgens1> Cale: it actually works for any monad. :o)
13:14:30 <sheldonh> is there a more efficient way to surround a string in quotes than ('\n':s) ++ "\n"?
13:14:34 <Cale> matthiasgorgens1: lol, of course *I* know that :)
13:14:49 <inigo_> thanks to all of you
13:14:50 <matthiasgorgens1> sheldonh: you mean, in terms of typing?
13:15:00 <matthiasgorgens1> Cale: or runtime or memory?
13:15:00 <shachaf> sheldonh: Not if you want a function :: String -> String
13:15:23 <matthiasgorgens1> oops, not cale, was meant for sheldonh.
13:15:43 <timthelion> sheldonh: and you mena "newlines" or "quotes"?
13:15:50 <timthelion> s/mena/mean/
13:15:55 <Cale> inigo_: (>>=) is implemented specially for the IO monad as a primitive way to glue IO actions together
13:16:10 <sheldonh> oops. i actually mena quotes. i have this: quote s = '"' : s ++ "\""
13:16:29 <hpaste> halp pasted “halp” at http://hpaste.org/73861
13:16:33 <timthelion> Cale: (>>=) can be used for other monad opperations too!
13:16:44 <thirsteh> is there an easy way to insert [[1,1,1], [2,2,2]] between [[4,5,6],[7,8,9],[10,11,12]] to get [[4,5,6],[1,1,1],[7,8,9],[2,2,2]],[10,11,12]]?
13:16:47 <matthiasgorgens1> cale, in a way, >> also glows monads together (and IO).
13:16:52 <Cale> inigo_: (The "real" implementation in GHC is pretty unenlightening though, because GHC cheats in implementing the IO monad)
13:17:02 <Cale> matthiasgorgens1: It doesn't glue monads together, it glues actions together
13:17:07 <armlesshobo> timthelion: i thought >>= only binds the result of a monadic operation to the next context
13:17:08 <matthiasgorgens1> but >>= allows you to also let those actions have an impact on each other.
13:17:26 <matthiasgorgens1> Cale, yeah, you are right about not glueing monads.  that was sloppy.
13:17:28 <shachaf> thirsteh: There are ways but you would have to explain why you want that operation.
13:17:35 <timthelion> armlesshobo: doesn't make it useless for things like Maybe monad or STM
13:18:20 <sheldonh> matthiasgorgens1: good question. i suppose memory :)
13:18:32 <thirsteh> shachaf: just playing around
13:18:44 <frp4vb6> Is it not easier to explain >>= in terms of join?
13:19:06 <shachaf> There should be a ban on talking about monads in this channel.
13:19:09 <shachaf> It would make it much better.
13:19:28 <timthelion> shachaf: agree'd.  If we just refered to them a burritos...
13:19:52 <shachaf> timthelion: And a double ban on people who talk about burritos.
13:20:02 <thirsteh> puppies
13:20:18 <timthelion> shachaf: :(
13:20:40 <timthelion> shachaf: perhaps potstickers is better?
13:20:49 <shachaf> Not funny.
13:21:48 <sheldonh> the way you guys talk about 'em, they should have been called Gonads.
13:23:02 <timthelion> shachaf: I can just imagine how that would change the channel.  "the M word."  "IO is an instance of the typeclass that shall not be named"...
13:23:20 <timthelion> s/is/has/?
13:24:28 <hpaste> inigo pasted “listDir” at http://hpaste.org/73862
13:25:11 <sheldonh> can i use a class as a constructor argument in a data type? haskell doesn't like this: data JsonValue = JsonNumber Num?
13:25:12 <inigo_> That was my 3rd try on the task, a 1-liner: http://hpaste.org/73862
13:25:40 <shachaf> listDir''' = mapM_ putStrLn . sort <=< getDirectoryContents
13:25:47 <Botje> yay! fish operator!
13:26:00 <shachaf> hi Botje
13:26:06 <Botje> hallo.
13:26:26 <timthelion> shachaf: try data JSonValue (Num a) = JsonNumber a
13:26:38 <timthelion> sheldonh: I mean
13:26:42 <timthelion> sorry shachaf
13:27:04 <shachaf> Syntax error.
13:27:21 <timthelion> what did I f_ck up this time?
13:27:46 <shachaf> sheldonh: You can do that, but are you sure you want to?
13:28:19 <shachaf> sheldonh: In particular you can do data JsonValue = JsonNumber (forall a. Num a => a)
13:28:31 <shachaf> But it may not be what you want.
13:29:14 <inigo_> shachaf: I think I would need a couple of additional weeks to understand that ;-)
13:29:16 * frerich is convinced that shachaf is actually a group of multiple Haskell programmers using the same nickname.
13:29:59 <shachaf> inigo_: That's because it's too complicated.
13:30:20 <shachaf> sheldonh: You probably want either: data JsonValue a = JsonNumber a, and then have constraints on the functions that use JsonValue
13:30:20 <aristid> frerich: that would explain everything.
13:30:34 <shachaf> Or: Pick a concrete type (or several) to be used for JSON values.
13:31:04 <inigo_> well, I started reading lyah book last saturday..
13:31:15 <sheldonh> shachaf: thanks. maybe i'm yak shaving and should just stick with JsonInt for now :)
13:31:27 <inigo_> I'm in my first Haskell week
13:31:47 <shachaf> sheldonh: Or JsonDouble!
13:31:56 <shachaf> Assuming JSON uses JavaScript-style types.
13:32:35 <aristid> shachaf: i think JSON numbers can be arbitrary precision
13:33:18 <shachaf> Hmm, did you know "05" isn't a valid JSON number?
13:33:54 <shachaf> Yes, I guess JSON numbers are arbitrary precision.
13:33:58 <shachaf> You probably want Rational, then?
13:34:21 <shachaf> Also, JSON doesn't support non-BMP codepoints? :-(
13:35:38 <shachaf> Ugh.
13:35:41 <shachaf> They use surrogate pairs?
13:36:05 <monochrom> that sounds utf-16
13:36:37 <shachaf> monochrom: JSON uses UTF-16-style surrogate pairs (\u....\u....) to encode non-BMP characters, it seems.
13:36:41 <watermind> why does  deriving functor requires an extension?
13:37:05 <shachaf> watermind: Because it's not part of Haskell 2010.
13:37:06 <watermind> seems like it would be pretty straightforward if the type constructor is unary
13:37:18 <watermind> shachaf: right
13:37:31 <geekosaur> it's not that it's difficult, just that it's not standard
13:37:45 <monochrom> there is no conflict between "is an extension" and "is straightforward"
13:38:22 <watermind> yes it's just something I'd expect to see even in Haskell 98
13:38:31 <monochrom> fwiw no-monomorphism-restriction is straightforward (in fact less implementation work than the opposite) and is an extension
13:38:53 <shachaf> watermind: If you make it work you need to make it work everywhere. :-)
13:39:02 <watermind> well but that changes the semantics of some programs
13:39:17 <shachaf> watermind: Undocumented extensions are considered bad form.
13:39:29 <shachaf> You might try to compile a program with a different Haskell compiler (ha ha).
13:39:29 <watermind> shachaf: yes I understand
13:40:49 <watermind> shachaf: yes I understand that not being part of the standard requires an extension, I guess my surprise is just that it isn't part of the standard, so I thought I could be overlooking some complications
13:41:04 <zxcv> hey
13:41:43 <shachaf> watermind: It's maybe not quite as trivial as you think (newtype Cont r a = Cont ((a -> r) -> r) or something?), and anyway 1998 was a different time.
13:41:56 <gadtfly> haskell.org/hoogle has been performing unreliably today.  Is there an easy-ish way I can make a local copy of the whole hoogle experience (ie, search with links to documentation pages and source)?  Is there an existing mirror somewhere?
13:42:00 <shachaf> People change the language proper conservatively but add compiler extensions liberally.
13:42:05 <watermind> schlaftier: right
13:42:14 <watermind> ops
13:42:21 <watermind> shachaf: right
13:42:40 <Rc43> Hi, guys.
13:42:47 <zxcv> is there a name for a function that takes a tree and applies some kind of transformation top-down?
13:43:23 <watermind> zxcv: transformation?
13:44:03 <zxcv> some function on a node/its children/an external value
13:44:11 <frp4php> zxcv: Like applying the same function to every node in the tree, and then returning the resulting tree? Perhaps fmap?
13:45:17 <monochrom> I would call it "topdown"
13:45:21 <zxcv> frp4php, yes, but it's not fmap, because the result depends on a node and its children and traverses from top to bottom
13:45:28 <Rc43> What semantics `where` has? In such code `g = <any_value> ; x a _ = f a where f = <any_func> g` function `f` will be calulcated only once (it doesn't dependes on a (`x`'s arguments)) __or__ every time `x` is evaluated?
13:45:49 <Rc43> Is it at compiler's discretion?
13:45:58 <shachaf> Everything is at the compiler's discretion.
13:46:19 <Rc43> scachaf, but there is standard and it cat descrive this and can not
13:46:28 <Rc43> *can describe
13:46:36 <zxcv> monochrom, I guess that works. I was just wondering if there is a common name for it. it seems like a common enough operation
13:46:37 <Lycurgus> at alternatively, being a machine it doesn't have the current possibility of have "discretion"
13:46:37 <lambdabot> Lycurgus: You have 1 new message. '/msg lambdabot @messages' to read it.
13:46:53 <Lycurgus> *having
13:47:28 <monochrom> f is likely not computed for different x's
13:47:51 <monochrom> use "ghc -ddump-simpl -dsuppress-uniques" to find out
13:48:44 <Rc43> monochrom, so `f = <something> ; x a _ = f a` and `x a _ = f a where f = <something>` are equal? (except visibility scope, offcourse)
13:48:49 <zxcv> here's the type if it looks like anything: (a -> b -> [a] -> [(a, b)]) -> b -> Tree a -> Tree (a, b)
13:49:11 <zxcv> nothing shows up on hoogle though
13:49:46 <gadtfly> zxcv: is it a fold?
13:49:59 <zxcv> no
13:50:27 <zxcv> fold folds
13:51:30 <gadtfly> Folds can also rebuild
13:52:20 <Rc43> hmm, ghc -03 -ddump-simpl shows nothing?
13:52:21 <zxcv> true, but not in the general case
13:52:58 <gadtfly> What does your first parameter do, I'm not sure I see what (a -> b -> [a] -> [(a,b)]) is
13:53:35 <zxcv> that's the transformation to apply
13:53:58 <gadtfly> Cause foldrM looks pretty similar
13:54:35 <gadtfly> :t foldrM
13:54:36 <lambdabot> Not in scope: `foldrM'
13:54:36 <zxcv> b is an outside parameter that gets stuck to the node labels depending on the node labels of parent nodes
13:56:15 <zxcv> it's (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
13:56:37 <zxcv> but the result is still folded, it's just in a monad...
13:57:56 <gadtfly> Dunno then, sorry
14:03:02 <zxcv> is there a tree library that everyone uses? the obvious stuff on hackage looks a little sparse
14:03:35 <startling> quick question regarding state and reader: if I do a >> b and a "changes" the state, with reader b sees no changes but with state it does, correct?
14:03:44 <startling> zxcv: good pun
14:03:49 <zxcv> :)
14:03:56 <startling> zxcv: I've noticed an annoying lack of this kind of thing, too, though
14:04:07 <startling> everyone seems to implement their own things
14:04:20 <startling> I'd love a "every tree ever" library
14:04:56 <zxcv> well, as long as I'm not missing something really obvious that everyone else knows about... I can live with that
14:05:22 <tdammers> trees are ridiculously easy to implement in haskell
14:05:30 <Saizan> "every tree ever" would have to cover almost all haskell datatypes..
14:05:31 <tdammers> a library would be about 5 sloc
14:05:41 <Saizan> a bit too large in scope, i'd say
14:05:42 <zxcv> Data.EveryTreeEver is on the to-do list
14:06:12 <zxcv> tdammers, it's about the tons of traversal/map/fold/whatever functions, not the structures themselves
14:06:21 <tdammers> ah, yeah.
14:06:41 <zxcv> re-implementing them can be tedious, and many are not that simple
14:06:46 <tdammers> problem is, there are lots of different trees
14:07:05 <tdammers> still, yeah, library, why not.
14:07:07 <nand`> the thing is, instead of using a ‘most general tree-like structure ever!1’ you often want to limit yourself to trees with certain shapes/properties, eg. binary trees, labelled trees, trees with elements on the leaves, trees that carry around meta data for balancing, etc.
14:07:51 <Saizan> there are a few "generic programming" libraries to give you the traversals for free
14:08:12 <Saizan> e.g. uniplate, syb, now lens
14:08:27 <zxcv> I noticed uniplate seemed to have some stuff
14:08:52 <edwardk> zxcv: lens includes a (faster) version of uniplate, that is more general
14:08:58 <zxcv> but not the specific traversal I wanted here
14:09:11 <edwardk> zxcv: what are you wanting to traverse?
14:10:21 <zxcv> a rose tree from top to bottom. I have some value that I want to pair with each node, but the specific value that's passed down the tree changes depending on the node label and its children
14:11:01 <edwardk> oh, thats a Tree anamorphism with a funny seed
14:11:28 <edwardk> you're using the existing tree as part of your seed
14:11:29 <zxcv> battery's dying :(
14:11:47 <zxcv> I'll look that up later though. thanks!
14:11:56 <edwardk> @type unfoldr
14:11:57 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:12:02 <edwardk> is an anamorphism for lists
14:12:18 <zxcv> excellent
14:12:28 <edwardk> replace b with (b, [a])
14:12:36 <edwardk> and you get what you wanted (just for lists)
14:13:04 <zxcv> great. thanks
14:16:46 <startling> zxcv: for thre record, I've found Mu and Free useful
14:21:08 <mietek> haskell.org is down?
14:21:55 <nand`> seems to be from here
14:22:07 <shachaf> Looks like it.
14:22:12 <shachaf> This is getting kind of ridiculous.
14:22:28 <sheldonh> it's all us noobs
14:22:52 <sheldonh> discover the source of the increasing popularity and squelch it! :)
14:26:21 <luite> looks like it's just the server, the isp status page doesn't mention any problems
14:26:51 <luite> oh it's just really slow
14:32:37 <startling> sheldonh: obviously we should just introduce more category-theoretic terminology
14:35:04 <diabolical> I want to group all spaces in a string together, and groupBy ((==) `on` ((==) ' ')) seems to work
14:35:23 <diabolical> But still, this looks pretty weird, how would you guys do it?
14:35:44 <startling> > groupBy ((==) `on` ((==) ' ')) "hello, world !"
14:35:45 <lambdabot>   ["hello,"," ","world"," ","!"]
14:35:59 <startling> diabolical: that's what you want?
14:36:54 <diabolical> startling, yes
14:37:55 <lightquake> you could rewrite it using pointed style as \x y -> (x == ' ') == (y == ' ')
14:38:15 <startling> what's the opposite of intersperse?
14:38:22 <lightquake> @type intersperse
14:38:23 <lambdabot> forall a. a -> [a] -> [a]
14:38:35 <startling> @hoogle [a] -> a -> [a]
14:38:35 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:38:35 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:38:36 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:38:45 <lightquake> what does it do?
14:39:08 <startling> > intersperse '!' ["hello", "world"]
14:39:09 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:39:09 <lambdabot>         against inferred type...
14:39:18 <startling> errr
14:39:28 <startling> > intersperse '!' "hello, world"
14:39:29 <lambdabot>   "h!e!l!l!o!,! !w!o!r!l!d"
14:39:48 <lightquake> i mean, what does the 'opposite' of intersperse do?
14:40:01 <sipa> :t intersperse
14:40:02 <lambdabot> forall a. a -> [a] -> [a]
14:40:14 <startling> oh, guess I was thinking intercalate
14:40:18 <diabolical> lightquake, I did exactly that, but then I realized that this is exactly what on does
14:40:41 <startling> I was asking for a thing that does "abc!d" -> ["abc", "d"] for any '!'
14:40:47 <lightquake> > groupBy (const $ const False) "h!e!l!l!o!,! !w!o!r!l!d"
14:40:47 <startling> or "!"
14:40:48 <lambdabot>   ["h","!","e","!","l","!","l","!","o","!",",","!"," ","!","w","!","o","!","r...
14:41:02 <Clint> a more general version of words
14:41:07 <confab> startling: so you want a split?
14:41:13 <confab> startling: on strings
14:41:13 <lightquake> there's http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
14:41:26 <bobajett> splitOn("!")
14:41:32 <lightquake> oh, not the patest version
14:41:35 <lightquake> http://hackage.haskell.org/package/split-0.2.0.0
14:41:37 <lightquake> *latest
14:42:11 <startling> confab: on Eq a => [a], I guess. this `split` looks promising, thanks
14:42:18 <bobajett> > splitOn "!" "abc!d"
14:42:19 <lambdabot>   Not in scope: `splitOn'
14:42:34 <scshunt> hrm
14:42:47 <Hadaka> Attoparsec question - I want to write an efficient parser which matches identifiers of lower and upper case letters and digits, but must not start with a digit - I can use takeWhile (or takeWhile1) to get the entire identifier directly as ByteString, but how do I ensure that the parsing will fail if it starts with a number?
14:42:48 <confab> startling: sorry, i don't know if it's an actual function, just generalizing it to terms someone else might understand
14:42:50 <scshunt> what structure should I use for something that is like Set, but where the ordering is not total?
14:42:53 <akosch> anyone into percolation theory here? I want to read about different algorithms for calculating the percolation threshold (and implement them in Haskell naturally) ;)
14:43:50 <startling> scshunt: you mean you don't have Ord ?
14:43:58 <Clint> Hadaka: match only an alpha before the takeWhile
14:44:22 <startling> scshunt: if you can make your thing Hashable, I think there's a set-like thing for that. sec
14:44:42 <bobajett> folks how do I convert a list of strings into Ints? I know: read "42" :: Int will convert "42" into 42, but not sure how to use it to convert a list.
14:44:58 <bobajett> Can I do something like map (read ? :: Int) ["42","33","21"]
14:44:59 <Hadaka> Clint: but then I have to append to that alpha the rest of the bytestring for return value :(
14:45:06 <akosch> I've read about using the monte carlo method for this, but I wonder if there are any solutions without randomness
14:45:19 <startling> bobajett: map read ["42","33","21"] :: [Int]
14:45:29 <bobajett> awesome!
14:45:31 <bobajett> thanks!
14:45:55 <startling> bobajett: you could do it your way, too: map (read :: String -> Int) ["42","33","21"]
14:45:59 <Clint> Hadaka: well, prepend it
14:46:04 <startling> bobajett: or you could do this in a type signature
14:46:18 <startling> bobajett: x :: [Int]; x = map read ["42","33","21"]
14:46:57 <Clint> Hadaka: oh, i misread
14:47:09 <startling> scshunt: http://hackage.haskell.org/packages/archive/hashmap/1.0.0.2/doc/html/Data-HashSet.html
14:47:25 <bobajett> wow, thanks startling I didn't even know about this last type, Im only upto chapter 6 on LearnYouAHaskell
14:47:55 * hackagebot fb 0.11.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.11.1 (FelipeLessa)
14:48:05 <startling> bobajett: you'll get there. the important thing is just to give the compiler enough to get by on
14:48:25 <startling> scshunt: hmm, that seems to require Ord sometimes, too
14:48:49 <startling> odd. you'd think it could just use Ord on the resulting hash
14:50:20 <startling> scshunt: I suppose you could just use a Map Int [MyThing] (a list for hash collisions) and hash your things before you stick 'em in
14:50:40 <startling> you'd need Eq, though
14:53:08 <nand`> bobajett: for what it's worth; you can also do this: map (read :: String -> Int) ["42", "33", "21"]
14:53:54 <scshunt> edwardk: I have new operator ideas for Lens :P
14:54:10 <edwardk> scshunt: ?
14:54:32 <scshunt> oh wait, nevermind, it doesn't generalize :(
14:55:42 <ParahSailin> @pl on' f1 f2 l = f1 (map f2 l)
14:55:42 <lambdabot> on' = (. map) . (.)
14:57:06 <armlesshobo> so, fmap and map are not equal in any sense.
14:57:19 <armlesshobo> fmap maps from one type to the next
14:57:25 <armlesshobo> map just applies a function to a list
14:57:32 <armlesshobo> right?
14:57:34 <startling> armlesshobo: nope
14:57:39 <armlesshobo> gdi
14:57:45 <startling> armlesshobo: map is fmap for lists
14:57:51 <nand`> map is fmap with a less general type signature
14:57:55 * hackagebot lio 0.9.1.0 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.9.1.0 (DeianStefan)
14:57:56 <startling> fmap is a generalization of map
14:58:06 <armlesshobo> ahhhhhh
14:58:31 <armlesshobo> because a list is a Functor
14:58:34 <startling> yeah
14:58:41 <startling> and it's defintition for fmap is map
14:58:45 <armlesshobo> riiiiight.
15:00:04 <scshunt> edwardk: how come you don't have a lens instance for Map?
15:00:17 <rosie> e
15:00:30 <jfischoff> Now that my template haskell code is working, and I am generating maybe 5000 lines of code, my link time is taking forever. Is that to be expected?
15:00:37 <edwardk> scshunt: like 'at', 'traverseAt' or 'itraverse'?
15:00:51 <startling> :t (flip (>>=)) . (return .)
15:00:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
15:00:53 <edwardk> scshunt: all of those work, so does 'traverse' ;)
15:01:01 <edwardk> er itraversed
15:01:08 <rosie> Using blaze-html, how can I convert a [Html] to a single Html, such that all the array values are concatenated into one Html value?
15:01:17 <startling> @pl (flip (>>=)) . (return .)
15:01:18 <lambdabot> fmap
15:01:19 <edwardk> m^.at "hello"
15:01:20 <startling> hehe
15:01:40 <edwardk> at "hello .~ Just 12 $ m
15:02:23 <edwardk> you can traverse the map with access to the key: itoListOf itraversed m is a painfully explicit way to Data.Map.toList
15:02:31 <startling> rosie: if Html is a Monoid (I think it is?), mconcat
15:03:24 <rosie> startling: it is, thanks!
15:04:20 <edwardk> jfischoff: template haskell is slow =(
15:04:36 <jfischoff> yeah
15:04:40 <edwardk> jfischoff: i'm thinking about adding combinators for Control.Lens.TH for printing the code for lenses as well
15:04:45 <edwardk> so you can cut and paste it
15:04:54 <startling> heh
15:05:27 <jfischoff> why not dump splice or that package that bakes down the TH?
15:05:52 <rosie> startling: any idea why I'm getting a "Not in scope: 'mconcat'" error?
15:06:02 <startling> rosie: have imported Data.Monoid ?
15:06:06 <startling> *have you
15:06:08 <scshunt> edwardk: whoa, ok
15:06:09 <scshunt> thanks
15:06:34 <edwardk> scshunt: at is overloaded in 2.5, so you can use it on intmaps, maps or hashmaps
15:06:45 <edwardk> scshunt: contains works similarly for intsets, sets and hashsets
15:06:53 <rosie> startling: ah thanks. That worked.
15:07:18 <edwardk> _2.flags.contains Verbose
15:07:27 <edwardk> those kind of things are really convenient =)
15:07:33 <startling> rosie: sorry, should've mentiond that. always annoys me when people mention some obscure function that does what I want but not where it is
15:07:36 <scshunt> edwardk: where's the instance for At on Map
15:07:37 <scshunt> ?
15:07:58 <startling> what is At?
15:08:24 <sclv> no, where it is at. what it is.
15:08:28 <edwardk> http://hackage.haskell.org/packages/archive/lens/2.5/doc/html/Control-Lens-IndexedLens.html#t:At
15:08:33 <sclv> :-P
15:08:47 <scshunt> thanks
15:08:49 <edwardk> click source ;)
15:08:51 <rosie> startling: no prob! I shoulda known… monoid is not obscure
15:09:12 <startling> edwardk: oh nice. I've been thinking about a typeclass like that
15:09:36 <edwardk> startling: i had left it off deliberately until i wound up needing hashmap/hashset, then i decided to put it back in
15:09:44 <edwardk> (it was in in the < 1.0 versions)
15:10:08 <edwardk> by wound up needing i mean Data.Data.Lens is WAY more efficient with HashFoos than Foos
15:10:38 <bobajett> > map ((-2) [2,4,6]
15:10:39 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:10:49 <bobajett> > map ((-)2) [2,4,6]
15:10:50 <lambdabot>   [0,-2,-4]
15:11:04 <scshunt> edwardk: is there an infix operator such that if m is a lens to a map, I could do m `p` k?
15:11:05 <sclv> i see why the arguments are the way they are for the lens style
15:11:07 <scshunt> *op
15:11:11 <sclv> but i always do at with the arguments flipped.
15:11:15 <sclv> fun `at` pt
15:11:35 <bobajett> how do I subtract the opposite way? I want to get the answer [0,2,4]
15:11:37 <edwardk> scs just use . to compose the at lens
15:11:42 <scshunt> DERP
15:11:43 <scshunt> thanks
15:11:47 <edwardk> _2.at "hello"
15:12:12 <startling> > map (- 2) [2, 4, 6]
15:12:14 <lambdabot>   [-2,-2,-2]
15:12:14 <sclv> yeah i see.
15:12:26 <startling> bobajett: you forgot a parens your first try
15:12:34 <sclv> still not idiomatic for my use case :-P
15:12:38 <edwardk> cfg^.flags.contains "hello"
15:12:44 <edwardk> sure
15:12:49 <startling> errrr wait
15:12:51 <edwardk> can't please everyone ;)
15:12:57 <startling> > map (- 2) [2, 4, 6]
15:12:58 <lambdabot>   [-2,-2,-2]
15:13:05 <edwardk> and i have no idea how the alternative ordering would work =P
15:13:05 <startling> what's happening there? is that a result of caleskell?
15:13:19 <edwardk> startling: (-2) is a number, not a section
15:13:24 <edwardk> map (subtract 2) [2,4,6]
15:13:25 <sclv> yeah, your at is way more generalized than mine.
15:13:26 <edwardk> > map (subtract 2) [2,4,6]
15:13:27 <lambdabot>   [0,2,4]
15:13:46 <startling> edwardk: I get a type error locally, though
15:14:07 <edwardk> startling: oh, the instance for functions isn't in the the standard lib yet
15:14:31 <startling> Num d => (a -> d) functions? ah
15:14:43 <edwardk> instance Num a => Num (e -> a)
15:14:44 <edwardk> yeah
15:15:03 <edwardk> where (+) = liftA2 (+); abs = fmap abs, etc.
15:15:19 <bobajett> edwardk: thanks!
15:15:46 <startling> mhm
15:16:10 <sclv> ahha that's a great example of why the num instance for functions is a dubious idea.
15:18:10 <aristid> sclv: dubious in which way? that it violates the non-existent laws of Num?
15:18:25 <edwardk> aristid: dubious because every once in a blue moon it trips up a newbie
15:18:30 <scshunt> edwardk: last stupid question of the day: how do you sanely compose with Maybe lenses?
15:18:44 <edwardk> scshunt: do you want to read or write?
15:18:50 <scshunt> in this case, write
15:19:30 <edwardk> scshunt: for reading compose them as traversals and use ^?.   for writing, there is no sane composition if you think about it that can comply with the lens laws
15:19:53 <edwardk> by the former i mean
15:20:08 <edwardk> foo^?traverseAt "key1".traverseAt "key2".traverseAt "key3"
15:20:09 <aristid> edwardk: oh, the dubiousness lies mostly in the fact that lambdabot has it enabled?
15:20:28 <edwardk> aristid: somewhat. a lot of us would like to see it added to the standard
15:20:29 <c_wraith> aristid: I think it's more of a dubious idea in that it lets code compile with types radically different than what you expect.
15:20:37 <aristid> i guess it's also an orphan instance.
15:20:41 <atriq> edwardk, am I being stupid, or is the id function a lens?
15:20:52 <edwardk> yes, hence why it needs to be supplied by the standard or its dangerous
15:20:58 <edwardk> atriq: it is =)
15:21:09 <c_wraith> it's the identity lens, in fact
15:21:11 <atriq> Okay, I'm finally starting to get this
15:21:16 <edwardk> atriq: and const pure is a traversal
15:21:30 <hpc> :t const pure
15:21:32 <lambdabot> forall a (f :: * -> *) b. (Applicative f) => b -> a -> f a
15:21:48 <scshunt> edwardk: why not? If you make viewing a Nothing an error, I think it would work fine
15:23:02 <danharaj> ew
15:23:10 <danharaj> what's the point of Maybe if you make Nothing an error?
15:23:16 <edwardk> danharaj++
15:23:29 <edwardk> the problem is you _DO_ view nothing.
15:23:34 <edwardk> the moment you compose  2 of them!
15:23:45 <scshunt> huh? why?
15:23:49 <edwardk> composition of two lenses requires reading from the first one before it can know how to set it back ;)
15:24:18 <scshunt> edwardk: /me is stupid today and doesn't follow
15:24:53 <edwardk> scshunt: http://hackage.haskell.org/packages/archive/data-lens/2.10.2/doc/html/src/Data-Lens-Common.html#Lens the category instance.
15:25:03 <edwardk> (using data-lens because its easier to see in some ways
15:25:36 <edwardk> to 'set' to a composition of two lenses, you use modify on the outer lens, getting the thing that you can use the inner lens on
15:25:46 <edwardk> thats getting ;)
15:25:56 <edwardk> so how can that work when getting blows sky high on nothing? =)
15:26:14 <rosie> how can I break up long lines (like \ in python) ?
15:26:30 <hpc> rosie: what kind of lines?
15:26:36 <danharaj> indent
15:26:40 <hpc> you can do the same backslash trick on long strings
15:27:08 <edwardk> also, composition of map lenses isn't special, so how would it know what do to about the other half of a pair when i had traverseAt "key"._2.traverseAt "bar"  and wanted to write back and the "key" was missing?
15:27:33 <edwardk> the only thing you can do that makes those compose legally is give up at that point
15:27:52 <scshunt> edwardk: perhaps this is related to my limited understanding of Traversal
15:27:52 <edwardk> now, i've been thinking about ways that i can make lenses that support a more insert-like operation.
15:28:03 <edwardk> e.g. something that can be used as a traversal, but also support insertion.
15:28:30 <danharaj> Can you put constraints on associated types in class definitions?
15:28:31 <edwardk> but its not a traversal and its not a lens, its something more powerful. its a hack like Iso or Indexed where i shoehorn in the ability to cast to something else
15:28:42 <edwardk> danharaj: yes
15:28:45 <scshunt> edwardk: hmm... I suppose that makes some sense
15:30:00 <danharaj> edwardk: where do you put the constraints?
15:30:22 <rosie> hcp: e.g. a function call that has many paramteters
15:30:23 <danharaj> oh you put them on the left side of the => in the class definition.
15:30:43 <danharaj> Apparently I answered this question for myself a month ago.
15:31:02 <bobajett> I read a list of Ints like so: let revenue = map (read :: String -> Int) ["42","33","21"]
15:31:02 <edwardk> danharaj: instance (Category (Dom f), Category (Cod f)) => CFunctor f where data Cod f; data Dom f; mapf :: Dom f a b -> ...
15:31:03 <bobajett> and then I wanted to subtract a constant amount I had predeclared like so:
15:31:03 <bobajett> expense = 10
15:31:05 <bobajett> profits = map (subtract expense) revenue
15:31:06 <bobajett>  
15:31:20 <hpc> rosie: yeah, what danharaj said; indent after the newline so it understands that it's a continuation of the current expression
15:31:28 <hpc> f a b c
15:31:31 <hpc>   d e f
15:31:31 <bobajett> but I get a type error
15:31:33 <hpc>   ...
15:32:16 <bobajett> is the proper way for me to declare my expense with a type? expense :: Int? (the type error is between Integer for expense and Int for wht I had parsed)
15:32:53 <rosie> hpc: Thanks!
15:32:57 <edwardk> scshunt: you could have something like class WithInsert k where withInsert :: Functor f => (a -> d -> b) -> ((c -> f d) -> a -> f b) -> k (c -> f d) (a -> f b)
15:33:22 <edwardk> well, its a bit trickier because all the ones you want it on are things like traverseAt
15:34:23 <edwardk> class WithInsert k where withInsert :: Applicative f => (a -> d -> b) -> ((c -> f d) -> a -> f b) -> k (c -> f d) (a -> f b)
15:35:31 <edwardk> class Indexed i k => WithInsert i k where withInsert :: Applicative f => (i -> d -> a -> b) -> ((i -> c -> f d) -> a -> f b) -> k (c -> f d) (a -> f b)
15:35:34 <edwardk> thats what it needs
15:35:54 <scshunt> edwardk: hmm
15:36:14 <Eduard_Munteanu> bobajett: yes, you don't end up with a polymorphic 'expense' due to the monomorphism restriction
15:36:34 <Eduard_Munteanu> And instead it defaults to Integer.
15:36:50 <edwardk> then traverseAt becomes withInsert Map.insert (followed by more or less the default)
15:37:04 <edwardk> and you get a Category for them...
15:37:10 <edwardk> oh wait, they don't form a Category =(
15:37:10 <bobajett> Eduard_Munteanu: gotcha. thanks!
15:37:21 <edwardk> i'd have to generalize (<.>) etc.
15:37:41 <scshunt> edwardk: and then for Maybe, you would create a withDefault :: a -> Simple Lens (Maybe a) a or something like that?
15:38:05 <edwardk> scshunt: thats not a lens
15:38:10 <scshunt> edwardk: is it not?
15:38:13 <edwardk> scshunt: nope
15:38:19 <edwardk> put back what you get
15:38:31 <scshunt> ah, hmm
15:38:34 <scshunt> how do you solve Nothing then?
15:39:07 <edwardk> for the above you'd compose them using <.> and it'd remain a WithInsert and then you could use an ad-hoc insert combinator that took one and did the composite insert
15:39:13 <scshunt> ah
15:39:21 <scshunt> I guess that works
15:39:33 <edwardk> but it wouldn't work into things that weren't maps
15:39:43 <edwardk> e.g. you couldn't go into a map, through a structure, and into another map
15:39:49 <edwardk> because it wouldn't kow how to build the structure =P
15:40:16 <edwardk> also there is the problem of what it means to delete from composed maps
15:40:19 <edwardk> there are two meanings
15:40:32 <edwardk> you might want it to delete the key in the second map, but leave empty maps
15:40:37 <scshunt> right
15:40:40 <edwardk> or you might want to delete the entry for the map
15:40:55 <edwardk> these are the questions that lead to why there can't be such a canonical lens
15:41:00 <edwardk> writing to nested maps still sucks =P
15:41:05 <edwardk> updating them is easy
15:41:24 <edwardk> but creating and deleting nested map entries is awkward
15:41:58 <edwardk> the more i think about it the more i realize i can't make that WithIndex thing in a palatable way
15:42:12 <scshunt> unrelated question: is there any way to import multiple modules into scope with GHC when they aren't in packages? :l seems to only import modules from the first available module and :m doesn't work on unpackaged modules
15:47:57 * hackagebot persistent-vector 0.1.0.0 - A persistent sequence based on array mapped tries  http://hackage.haskell.org/package/persistent-vector-0.1.0.0 (TristanRavitch)
16:01:06 <janua> Hello! I am having trouble understanding the functor laws. I understand functors generally but i don't know how to interpret fmap (f . g)  ==  fmap f . fmap g
16:02:16 <edwardk> > map (+1) $ map (+1) [1,2,3]
16:02:17 <lambdabot>   [3,4,5]
16:02:26 <edwardk> > map ((+1) . (+1)) [1,2,3]
16:02:28 <lambdabot>   [3,4,5]
16:02:35 <shachaf> Does it make more sense as fmap (\x -> f (g x)) == \x -> fmap f (fmap g x) ?
16:02:45 <shachaf> In Haskell you don't *actually* need this law, though. :-)
16:03:04 <janua> shachaf: Why do you say you don't need it? Let me think about what you said :)
16:03:09 <edwardk> it says that it shouldn't matter if you break a map up into multiple parts of fuses it together
16:03:25 <edwardk> janua: its a fairly deep result that you can prove fmap f . fmap g = fmap (f . g) if you can prove fmap id = id
16:03:42 <edwardk> janua: it relies on the free theorems of fmap
16:03:53 <mk> janua: what does . do?
16:04:24 <janua> mk: Takes the results of something and gives it to the next (?)
16:04:50 <mk> janua: sort of. It produces something that does that
16:05:35 <mk> have you looked through http://learnyouahaskell.com/functors-applicative-functors-and-monoids ?
16:05:56 <janua> mk: To be honest im not sure how i would explain point free style to someone vs say $.
16:06:27 <janua> mk: I have read this about 3 times, but i don't understand the laws. I just want to make a simple type that is an instance of Functor but i'm not sure how to implement it or even udnerstand it
16:06:59 <mk> well, . pronounced "dot" is very much like addition and multiplication. It takes two things, and produces one of the same sort of thing. Add two numbers, you get another number
16:07:07 <edwardk> janua: if it typechecks and you don't do something obviously stupid like changing a number in an unrelated field, and you map 'like to like' its correct
16:07:30 <Eduard_Munteanu> janua: it's not like the compiler actually checks those laws anyway
16:07:48 <janua> Could i get away without understanding them?
16:07:49 <edwardk> data Pair a = Pair a a; instance Functor Pair where fmap f (Pair a b) = Pair (f a) (f b) -- any other definition will fail to typecheck or involve something that is obviously looping forever, etc.
16:07:49 <mk> janua: . in this context is doing the same thing, but for functions. It's composing them into a single one. In other languages, this looks like f(g())
16:07:50 <Eduard_Munteanu> In case you're wondering, that is.
16:08:23 <mk> janua: I would guess no, because understanding the laws is a test of whether you understand the concept
16:08:36 <Eduard_Munteanu> janua: oh, it's definitely a good idea to understand them
16:08:42 <janua> I understand say...
16:08:46 <edwardk> data Stream a = Stream a (Stream a); instance Functor Stream where fmap f (Stream a as) = Stream a (fmap f as)
16:09:16 <edwardk> but data Evil a = Evil Int a; instance Functor f (Evil _ a) = Evil 42 a -- would be illegal.
16:09:24 <janua> fmap (odd . length) (Just [1,2,3]) == (fmap odd . fmap length) (Just [1,2,3])... (If i got that correct)
16:09:35 <edwardk> fmap id (Evil 0 ()) = Evl 42 ()  -- thats not Evil 0 ()
16:09:55 <edwardk> janua: thats all there is to it
16:10:10 <Jafet> instance Eq (Evil Int a) where (==) = const (const True)
16:10:11 <Eduard_Munteanu> They might also make more sense if you already understand functors in the category theory sense.
16:10:17 <janua> But i can't fit together that and the law. Whats what in the law with that?
16:10:18 <edwardk> janua: fmap f . fmap g = fmap (f . g) says that if you can do it in two passes using just map, you can do it in one, (or you can break up something into two passes
16:10:23 <edwardk> and you won't get different answers
16:10:35 <Jafet> Is (Evil _ a) instance valid in ghc?
16:10:40 <edwardk> Jafet: =P
16:11:11 <janua> In the law, what is f and g?
16:11:11 <edwardk> Jafet: no i meant to write instance Functor Evil where fmap f (Evil _ a) = Evil 42 a
16:11:14 <mk> janua: when you fmap a function that takes ints and returns ints, this makes a function that takes a list (or container) of ints and returns one
16:11:18 <edwardk> but apparently i accidentally a few words
16:11:20 <Jafet> I mean the _
16:11:23 <mk> janua: what language are you coming from?
16:11:27 <edwardk> janua: any function you want them to be
16:11:40 <janua> so f and g are functions?
16:11:44 <edwardk> Jafet: no, that was a value level pattern match that got moved around
16:11:45 <edwardk> yes
16:11:47 <shachaf> "you", the user of fmap, not "you", the person proving the law. :-)
16:11:55 <janua> I have come from initially c#, then python, and now believe it or not im working in Scala :)
16:12:00 <edwardk> they could be odd or length, etc.
16:12:08 <edwardk> like you used in your example
16:12:19 <edwardk> the law simply states that it must work for any choice of f and g you can think of
16:12:21 <mk> janua: yep. So, functions can be chained, or piped, or composed into a single one
16:12:23 <janua> So is this correct?
16:12:36 <Jafet> Maybe instances should be written with hoas, then we can say _
16:12:46 <janua> fmap (a . b . c) == fmap a . fmap b . fmap c
16:12:54 <edwardk> > fmap (odd . length) (Just [1,2,3]) == (fmap odd . fmap length) (Just [1,2,3]).
16:12:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:13:00 <edwardk> > fmap (odd . length) (Just [1,2,3]) == (fmap odd . fmap length) (Just [1,2,3])
16:13:02 <lambdabot>   True
16:13:05 <janua> !!
16:13:15 <edwardk> janua: yep
16:13:17 <janua> Ok add another function
16:13:19 <janua> To that
16:13:24 <edwardk> janua: keeps working ;)
16:13:31 <edwardk> janua you're using the same law
16:13:36 <edwardk> you're just choosing f = a . b
16:13:38 <edwardk> and g = c
16:13:42 <edwardk> or vice versa
16:13:51 <shachaf> janua: You need to know that (.) is associative in order to do that.
16:13:53 <janua> Whats a and b then?
16:14:00 <shachaf> (Fortunately, (.) happens to be fmap. :-) )
16:14:01 <edwardk> janua: they are alsofunctions
16:14:05 <edwardk> thats required by (.)
16:14:07 <edwardk> :t (.)
16:14:07 <janua> OH
16:14:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:14:12 <edwardk> er
16:14:16 <edwardk> :t (Prelude..)
16:14:17 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:14:26 <janua> I think i see what you are saying now
16:14:30 <shachaf> Hmm, another way to write the law would be "fmap (fmap a b) c === fmap a (fmap b c)"
16:14:34 <shachaf> But that's probably more confusing. :-)
16:14:45 <edwardk> shachaf: a bit =P
16:14:54 <janua> So its almost like saying ((a . b) . c) ?
16:15:03 <edwardk> janua: its exactly like saying that
16:15:03 <scshunt> edwardk: hmm... regarding our conversation earlier: insertion and deletion are separate
16:15:12 <janua> Wait a minute
16:15:20 <Jafet> shachaf just wants to change what the law says by writing a different instance for (e->)
16:15:21 <janua> (((a . b) c) d) ?
16:15:44 <shachaf> Jafet: As long as you have fmap id === id, I can't! :-(
16:16:55 <ion> Redefine id. Problem solved.
16:17:04 <shachaf> id = id
16:17:14 <latro`a> more like id id = id
16:17:26 <mk> janua: it's important to understand what fmap is doing. Usually, you have very simple functions, like int->int. But let's say you want to apply this function to an array of ints. How do you do that?
16:17:42 <shachaf> Valid C code: typedef int x; x foo(x x) { return x; }
16:17:43 <Jafet> #haskell, where we reinterpret haskell
16:18:00 <janua> mk: You put the function over each of the elements
16:18:22 <mk> janua: what's the result?
16:18:23 <ion> shachaf: Well, that’s not much stranger than data Foo = Foo; foo = Foo :: Foo
16:18:44 <janua> mk: A new array of ints that have had the function applied to them
16:19:36 <shachaf> ion: Except it's not different namespaces, it's shadowing.
16:19:55 <shachaf> ion: A typedef is in the same namespace as a variable, so declaring a typedef can shadow a variable and vice versa.
16:20:05 <ion> shachaf: Oh, really? Well, that’s hilarious.
16:20:45 <mk> janua: right, exactly. Now you can see what happens in two ways. The first way, you run through each element, element by element, using the function. The second way, you just fmap the whole list using the function.
16:20:53 <ion> I take it you can’t shadow things like “int”?
16:21:01 <shachaf> mk: Where did arrays get into this?
16:21:07 <shachaf> ion: Nope. :-(
16:21:17 <hpc> shachaf: as a demonstrative example
16:21:49 <janua> mk: I think i see what you are saying. And i think i am trying to apply these laws and thinking of them as the implementation when they are not, if you know what i mean
16:22:04 <janua> When really they are a step back
16:22:12 <shachaf> janua: The implementation of fmap is different for each instance.
16:22:35 <Jafet> #define int char
16:22:38 <mk> janua: on the left side of the law, a single function called f.g is being turned into a "fmapper" - fmap returns a function that takes whole lists, and returns whole lists
16:22:40 <janua> Yes i know, but i mean i am looking at it like a signature and substituting everything for something
16:23:09 <EvanR> a blank blanker
16:23:18 <EvanR> sounds like oop
16:24:04 <janua> mk: In the law, are a and b both elements?
16:24:18 <shachaf> "elements"?
16:24:53 <ion> Blank blank is a new Blank.
16:25:00 <janua> What are a and b then?
16:25:00 <mk> janua: on the right side, you're using fmap twice. So you have two functions of, say, the form List->List. And the law says something about composing those two into a single List->List function
16:25:23 <mk> janua: which law are you looking at? Could you paste?
16:25:32 <janua> fmap (a . b) == (fmap a . fmap b)
16:26:06 <janua> Sorry i actually meant f and g, but i had this from somewhere else :)
16:26:13 <mk> right, I'm just using f and g in place of a and b. Usually, it helps to call function values f and g, and save a b c for values etc.
16:26:17 <shachaf> It doesn't matter what you call them.
16:26:30 <janua> So f and g are functions
16:26:53 <Eduard_Munteanu> :t fmap ?f . fmap ?g
16:26:54 <lambdabot> forall a b (f :: * -> *) a1. (?f::a -> b, Functor f, ?g::a1 -> a) => f a1 -> f b
16:27:17 <janua> I have now no idea what im looking at
16:27:34 <shachaf> janua: Don't worry about the ? thing. :-)
16:27:47 <shachaf> Do you understand what fmap is?
16:27:54 <janua> Yes
16:28:23 <shachaf> So do you understand what fmap (\x -> f (g x)) is?
16:28:57 <janua> shachaf: I don't know what f is, is it the container?
16:29:20 <mk> janua: it's the second function in the chain
16:29:33 <Eduard_Munteanu> janua: yes, they are functions, so using more words "for any functions f and g, fmap (f . g) == fmap f . fmap g"
16:30:04 <shachaf> janua: f is a function. For you example, f = (+1), g = (*2)
16:30:25 <Eduard_Munteanu> Well, any functions for which composition is valid.
16:30:59 <shachaf> janua: For f = (+1), g = (*2), do you understand (f . g)?
16:31:08 <janua> Yes
16:31:12 <mk> janua: if you wanted to get the result of "1, double it using a function called dub, then add 1 using a function called inc", how would you write that in your preferred language?
16:31:30 <Jafet> Another path to enlightenment, barred by variable scoping.
16:32:12 <janua> int(dub(2)) ?
16:32:17 <spark_> hello, can someone help me with a memory leak?
16:32:32 <mk> janua: yep, though inc(dub(1))
16:32:43 <janua> Oh oops yes sorry
16:32:52 <Eduard_Munteanu> spark_: maybe, post some code / describe your problem
16:33:19 <shachaf> janua: In Haskell you would write inc (dub 2)
16:33:28 <shachaf> Another way of writing that is (inc . dub) 2
16:33:29 <janua> or just int . dub
16:33:37 <janua> inc*
16:33:42 <spark_> I'm doing some work over a file (100mb) and the program goes over 2gb and crash, but there isn't nothing in the code that justify it to do that
16:33:48 <mk> ok, but we don't have a "1". We want that as an argument. Usually, we'd just write dubinc(int x) {return inc(dub(1));} -- does that look familiar?
16:34:11 <janua> Yes!
16:34:12 <hpaste> spark_ pasted “memory leak over fftAcross” at http://hpaste.org/73869
16:34:38 <hpaste> spark_ annotated “memory leak over fftAcross” with “memory leak over fftAcross (annotation)” at http://hpaste.org/73869#a73870
16:35:11 <mk> janua: well, it's a pain to define a whole function every time we want to compose. It's terrible. So we just write (inc . dub), and that means exactly what that verbose "dubinc" means
16:35:36 <Jafet> spark: you probably want to profile the heap instead
16:35:36 <Eduard_Munteanu> spark_: have you profiled it?
16:35:43 <spark_> ive anotated it
16:35:51 <spark_> http://hpaste.org/73869#a73870
16:35:58 <Eduard_Munteanu> Ah.
16:36:01 <spark_> its a 25mb
16:36:32 <janua> mk: How is fmap (inc . dub) == fmap inc . fmap dub
16:36:40 <janua> mk: I see
16:36:40 <Jafet> Is that a heap profile?
16:36:52 <janua> mk: Make something with three functions :)
16:37:14 <spark_> Jafet: that is a -p profile, the heap is an image, right?
16:37:46 <Jafet> Oh, the profile is 25mb.
16:38:01 <Jafet> Well, try to compress it into irc.
16:38:07 <mk> janua: because fmap (inc . dub) creates a function for dubinc'ing the whole list. And fmap creates a function for inc'ing a whole list...
16:38:33 <spark_> Jafet: nooo, sorry, the workfile is 25mb
16:38:48 <spark_> wait
16:38:52 <spark_> der
16:39:08 <spark_> uploaded the wrong profile
16:39:20 <janua> fmap (inc . dub . inc) == (fmap inc . fmap dub . fmap inc)
16:39:39 <mk> janua: well, the law is sortof recursive. Because "g" can stand in for a function that's just a composition of two other functions
16:39:41 <shachaf> janua: Yes. You can prove that yourself from the other law.
16:40:00 <mk> what's dub . inc ?
16:40:10 <janua> See, its the fact that the law ONLY has f and g thats confusing me
16:40:17 <spark_> Eduard_Munteanu: my 25mb test file max memory at 800mb
16:40:22 <shachaf> janua: What else should it have?
16:40:24 <janua> mk: dub . inc is f
16:40:35 <janua> shachaf: I have no idea :)
16:40:40 <spark_> Eduard_Munteanu: and my 100mb goes at 2gb and crash, you can see why this behaviour?
16:40:42 <mk> janua: it also has fmap(f . g), which is itself a function
16:41:01 <Eduard_Munteanu> spark_: is that an array amap?
16:41:16 <Eduard_Munteanu> spark_: what sort of arrays are involved there?
16:41:22 <spark_> everything are lists
16:41:28 <mk> janua: a function is like an arrow. An fmapped function is like a quiver
16:41:35 <janua> In the law, isn't the right hand side less efficient? You are going over the list a few times, but only once on the left hand side
16:42:07 <shachaf> janua: This isn't about implementation but about values.
16:42:16 <Eduard_Munteanu> Oh, you defined amap yourself.
16:42:16 <shachaf> We don't care about efficiency as long as they come out to the same thing.
16:42:23 <spark_> Eduard_Munteanu: amap takes [(,,,)], makes a ([],[],[],[]), and map a function in every one of those lists, and the remakes a [(,,,)]
16:42:32 <shachaf> janua: Just like (a ++ b) ++ c === a ++ (b ++ c), but the former is probably less efficient.
16:43:06 <mk> janua: yep, that's right
16:43:25 <janua> mk: What do you mean when you said its sort of recursive, as g and be the composition of two other functions, i was thinking that f is the composition of two functions and g is just one
16:44:05 <edwardk> janua: the law ensures that you can move from the less effiient version to the more efficient version just by spotting a pair of chained maps
16:44:12 <edwardk> janua: if you have code that looks like
16:44:18 <mk> well it's talking about two functions. But if you want to talk about 3 functions... well, there's not much of a problem there, since f might just be a composition of two other functions. And each of those two might be a composition of... and so on
16:44:37 <edwardk> foo f = f . map (foo f) . map bar . out       you can know you can rewrite it
16:44:45 <edwardk> into foo f = f . map (foo f . bar) . out
16:44:49 <edwardk> without losing anything
16:44:49 <janua> mk: So it doesn't really matter as a function can always be a composition of any number of other functions?
16:44:55 <mk> janua: what edwardk just said about rewriting is a good way of seeing it
16:45:30 <mk> janua: what doesn't matter? what it means is that the law applies to all those cases, too
16:45:34 <edwardk> janua the functor laws are a tool for the user of the functor more than a chain wrapped around the ankle of the implementor
16:46:19 <latro`a> you kinda have to try to fail to satisfy the functor laws
16:46:20 <latro`a> imo
16:46:58 <latro`a> if you apply the function somewhere you probably have a functor, even if it's sorta "the wrong functor"
16:47:36 <mk> janua: this isn't associativity, ie (a + (b + c)) = ((a + b) + c), if that's what you're thinking. It's a different pattern here
16:47:42 <latro`a> (an example of "the wrong functor" is fmap f [] = [];fmap f (x:_) = [f x]
16:47:44 <latro`a> )
16:48:20 <shachaf> maybeToList . fmap f . listToMaybe
16:48:42 <janua> latro`a: Why is that wrong? Because it just returns x?
16:49:06 <shachaf> janua: Because fmap id /= id :-)
16:49:31 <latro`a> gah, my bad
16:49:55 <Eduard_Munteanu> spark_: I'd add some type signatures to it, but other than that, it seems to attribute those allocations to 'fft'
16:49:56 <latro`a> I was gonna say "it's the wrong functor because it's isomorphic to Maybe anyways" but yeah, it fails fmap id = id
16:50:03 * Eduard_Munteanu kinda has to go shortly
16:50:32 <spark_> Eduard_Munteanu: exactly, but fft should be just an operation that return a list
16:50:41 <latro`a> ffts on lists...ugh
16:50:54 <spark_> latro`a: have a better option ? D:
16:51:10 <latro`a> (sorry, my senior thesis involved doing many millions of FFTs on length 60 vectors)
16:51:14 <latro`a> (lists...bad idea)
16:51:23 <Jafet> Allocations don't have much to do with memory usage
16:51:39 <spark_> latro`a:  I could even rewrite fft, the algorithm in numeric.fft is pretty simple
16:51:41 <Jafet> That's why allocation profile is pretty useless
16:51:45 <hpc> latro`a: but they're fixed length! surely O(1) is fast ;)
16:51:56 <hpc> (oh god, don't think i am serious)
16:52:05 <spark_> Jafet: hmm, does it have a better tool?
16:52:06 <latro`a> lol
16:52:28 <Jafet> spark: did you obtain a heap profile?
16:52:39 <spark_> the .hp?
16:52:46 <latro`a> (FWIW my senior thesis used FFTW directly)
16:53:13 <spark_> latro`a: I couldn't figure it out how to install fftw, pkg-config doesn't detect it
16:53:17 <Jafet> Ok, so you did. But you haven't provided it
16:53:22 <latro`a> that's really strange
16:53:30 <latro`a> there should be windows instructions even
16:53:32 <latro`a> on the fftw site
16:53:41 <spark_> Jafet: I have a profile for a 800kb file, im redoing for a 25mb now
16:54:16 <spark_> latro`a: their instruction is, unpack everything and you are done
16:54:37 <latro`a> precompiled or compiling?
16:55:08 <latro`a> because precompiled it looks like you can do it with VC++
16:55:09 <spark_> precompiling
16:55:18 <spark_> precompiled*
16:55:20 <latro`a> though if you don't have that then yeah :/
16:55:28 <latro`a> still, if the dll is in the directory it should link?
16:55:38 <latro`a> oh wait FFI
16:55:39 <latro`a> nvm
16:56:20 <spark_> still, 25mb having a workload of 800mb
16:56:22 <spark_> thats
16:56:23 <spark_> strange
16:56:49 <janua> shachaf: I've been looking at your fmap (\x -> f (g x)) == \x -> fmap f (fmap g x), Is there an fmap missing after the == ?
16:56:52 <spark_> and darn, isn't slow
16:57:10 <shachaf> janua: No.
16:57:43 <shachaf> janua: You can think of it as (\m -> fmap (\x -> f (g x)) m) === (\m -> fmap f (fmap g m))
16:58:38 <janua> shachaf: On the right hand side, what is feeding x? (On the simpler one) I don't understand it when its standing alone
17:00:05 <spark_> What is the better place to post about code review/performance questions, reddit or SO? I've never used SO so I don't know if its place for not that especific questions
17:00:20 <mk> janua: function foo(int \x) { return fmap(f, (  fmap(g,x)  ));}
17:00:54 <shachaf> spark_: Specific performance questions on SO are probably OK.
17:01:08 <geekosaur> there's a specific stackexchange site for code reviews
17:01:22 <shachaf> Not so much general questions or code review questions. But what geekosaur said.
17:02:02 <geekosaur> http://codereview.stackexchange.com/
17:02:30 <spark_> here , it finally ended
17:02:37 <spark_> http://imgur.com/cmV6I profile for 25mb
17:03:02 <janua> mk: I mean, is it not meant to be fmap (\x -> f (g x)) == fmap (\x -> fmap f (fmap g x)) ?
17:03:17 <shachaf> janua: It' snot.
17:03:39 <shachaf> janua: What you said is equivalent to fmap (f . g) === fmap (fmap f . fmap g)
17:03:43 <shachaf> Which doesn't even type-check. :-)
17:03:56 * janua tries to breathe slow!
17:04:13 <Jafet> spark: ok, I think the biggest problem is pretty obvious
17:04:20 <spark_> geekosaur: thanks
17:04:26 <shachaf> janua: Maybe you should get more used to (.) before worrying about these laws. :-)
17:04:44 <janua> shachaf: I think i am used to it
17:05:01 <janua> I just am not thinking about it correctly i dont think its the (.) that is confusing me
17:05:15 <shachaf> janua: Is it obvious that what you wrote is equivalent to what I wrote?
17:05:26 <Jafet> You may want to force the result of readExpr.
17:05:36 <janua> shakakai: How do you mean?
17:05:39 <janua> Oops
17:05:53 <janua> shachaf:
17:05:56 <shachaf> janua: Stop worrying about fmap for a bit and worry about the concrete function map.
17:06:11 <shachaf> map :: (a -> b) -> [a] -> [b]
17:06:18 <shachaf> map (f . g) === map f . map g
17:06:29 <mk> janua: the right side is talking about the composition of two fmaps (which "contain" functions), the left side is talking about a single fmap (which "contains" a single function, which is the composition of two functions)
17:06:35 <Jafet> spark: do you understand why parseAcc is using memory?
17:06:51 <shachaf> mk: fmaps don't contain functions.
17:08:05 <janua> map (\x -> f (g x)) == \x -> map f (map g x)
17:08:16 <janua> Ah i see
17:10:24 <janua> Think i got it now, i guess i was just thinking of it completely the wrong way altogether, thanks mk and shachaf and others!
17:11:14 <shachaf> janua: It's a law like "x + y = y + x"
17:11:29 <shachaf> It's not part of the definition of (+), but however you define (+), it should hold.
17:14:55 <joe9> I am trying to figure out how to update a record. I get the to-be-updated record as a parameter and I want to return the record-with-a-field-updated
17:15:15 <joe9> foo x@(C1 {}) = x {f1 = 1} --will this work?
17:15:20 <shachaf> oldRecord { field = newValue }
17:15:25 <joe9> from here: http://hackage.haskell.org/trac/haskell-prime/wiki/ExistingRecords
17:15:28 <shachaf> Yes.
17:15:33 <joe9> shachaf: ok, thanks a lot.
17:15:34 <shachaf> joe9: See also: Lenses.
17:15:40 <shachaf> @hackage lens
17:15:40 <lambdabot> http://hackage.haskell.org/package/lens
17:16:02 <shachaf> Lenses let you do things like (field.subfield .~ 5) oldRecord
17:17:08 <ivanm> where is the Cabal bugtracker nowadays? on github?
17:17:21 <dcoutts_> yep
17:19:05 <spark_> and there goes my question to code review
17:25:52 <ivanm> dcoutts_: the bug report you asked for: https://github.com/haskell/cabal/issues/1019
17:25:57 <dcoutts_> ta
17:29:27 <spark_> how dificult is to replace list to a faster container? and which container should i use? (vectors, arrays?)
17:29:42 <ivanm> spark_: what are you doing with the lists?
17:29:51 <spark_> fft's
17:30:14 <ivanm> isn't there a package for fft's already?
17:30:31 <ivanm> fft, pure-fft, vector-fftw
17:30:54 <ivanm> oh, ignore pure-fft
17:30:59 <spark_> im using pure-fft, but it's alocating too much
17:31:12 <ivanm> spark_: yeah, mmorrow has been MIA for quite a while now
17:31:26 <spark_> the other two uses c bindings, aaand i cant figure out how to install fftw
17:31:28 <ivanm> and his last release of pure-fft seems to predate vector, etc.
17:31:32 <ivanm> spark_: which OS?
17:31:38 <spark_> maybe i should just bail out windows and try to go ubuntu
17:31:40 <luite> he had pretty heap diagrams that showed the structure of the fft :)
17:31:57 <ivanm> spark_: might be easier :p
17:32:12 <ivanm> spark_: the statistics package seems to have fft support
17:32:16 <spark_> ivanm: darn i don't want to close my iexplorer tabs hahaha
17:32:17 <ivanm> not sure how it's implemented
17:32:22 <ivanm> as does repa-algorithms
17:32:28 <ivanm> spark_: IE doesn't have session saving?
17:32:29 <spark_> ivanm: repa requires the llvm
17:32:45 <spark_> ivanm: it does, if i force crash it hahahaha
17:32:56 <hpc> spark_: well what are you waiting for? ;)
17:33:10 <ivanm> spark_: I think you can comment out that line in the repa-algorithms cabal file
17:33:18 <ivanm> since it's only a build option
17:33:24 <ivanm> which probably shouldn't be in there IMHO
17:33:44 <ivanm> dcoutts_: should repa-algorithms really specify -fllvm in its .cabal file?
17:33:46 <spark_> ivanm: ok, but what should i expect changing list to repa arrays?
17:33:54 <spark_> just a warper function or something?
17:33:59 <spark_> or a full rewrite?
17:34:04 <ivanm> spark_: since I don't know how you're using it... ;)
17:34:07 <dcoutts_> ivanm: arguably it should yes
17:34:16 <spark_> ivanm:  can i show you the code?
17:34:37 <ivanm> dcoutts_: oh, I figured that kind of thing is a bit intrusive, since you can't tell beforehand that other packages need to be installed with -fllvm, etc.
17:34:43 <ivanm> and it isn't exposed anywhere until the build crashes
17:34:58 <ivanm> spark_: using statistics might be easier for you though
17:35:04 <ivanm> it has an fft implementation using Vectors
17:35:05 <spark_> ivanm: http://codereview.stackexchange.com/questions/15164/initating-in-haskell-am-i-following-a-good-way
17:35:12 <spark_> I'll have a look, thank you!
17:35:39 <ivanm> spark_: don't override Show
17:35:46 <ivanm> Show isn't designed for pretty-printing
17:35:47 <dcoutts_> ivanm: other packages don't, -fllvm doesn't change the ABI
17:35:54 <ivanm> you're only going to cause problems down the track
17:36:05 <ivanm> dcoutts_: oh, I thought that you needed all deps compiled with -fllvm as well
17:36:08 <dcoutts_> nope
17:36:14 <ivanm> I stand corrected then :)
17:36:29 <dcoutts_> if -fllvm is crashing something file a ghc ticket
17:36:38 <dcoutts_> it should work
17:36:45 <ivanm> *nod*
17:37:07 <ivanm> dcoutts_: there's been a few people on -cafe, etc. that I've seen having issues with repa-algorithms requiring -fllvm though, that's all
17:37:17 <ivanm> spark_: your aToG functions is fugly :s
17:37:29 <blackdog> is there a good deployment target for throwaway haskell webapps yet?
17:37:40 <dcoutts_> ivanm: "issues" of what kind?
17:37:46 <shachaf> blackdog: How throwaway?
17:37:56 <ivanm> dcoutts_: primarily "it won't build on windows" if memory serves
17:38:00 <blackdog> shachaf: equivalent of heroku
17:38:09 <blackdog> don't really care about performance or stability
17:38:14 <shachaf> Doesn't Heroku run Haskell with some twiddling?
17:38:19 <blackdog> it's more about being able to push an app easily
17:38:22 <blackdog> shachaf: no :/
17:38:27 <blackdog> you can push a binary up
17:38:38 <blackdog> i worked on getting a source push buildpack working, but failed
17:38:38 <spark_> ivanm: well, is a reimplementation of python code
17:38:38 <dcoutts_> ivanm: mm, does the ghc windows binary ship llvm I wonder
17:38:43 <blackdog> 200mb is not much space.
17:38:54 <shachaf> blackdog: Pushing a binary doesn't seem all that bad.
17:38:58 <spark_> ivanm:  how can i make it look better though?
17:39:28 <blackdog> shachaf: it's pretty bad. you have to match architectures locally, and 30mb binaries are pretty normal
17:39:33 <ivanm> spark_: clean up your where block for starters
17:39:43 <blackdog> especially on an asymmetrical connection, that really slows down iteration
17:39:44 <dcoutts_> ivanm: if llvm isn't bundled on windows then probably ghc should ignore -fllvm and warn
17:39:45 <ahkurtz> will heroku let you run ghc after push?
17:39:53 <blackdog> ahkurtz: yeah, sort of
17:40:06 * shachaf doesn't know of something.
17:40:07 <spark_> ivanm:  is there a better way to do that if?
17:40:16 <blackdog> check out https://github.com/mwotton/heroku-buildpack-haskell for my abortive attempt
17:40:20 <blackdog> the trick is getting the space usage down
17:40:32 <shachaf> I don't think Haskell web applications are common enough for people have put effort into it. :-)
17:40:38 <ahkurtz> I didn't realize it was that bad. I thought there were people deploying on heroku
17:40:48 <ivanm> spark_: hang on, talking on phone
17:40:58 <blackdog> shachaf: that's what i'm hoping to change, but i'm a bit stymied
17:40:58 <spark_> ivanm: D:
17:48:00 <spark_> sometimes I wish there was just a section about transforming to a type to another
17:56:23 <ivanm> spark_: OK, back
17:56:42 <ivanm> for starters: you're better off (IMHO) having the where block starting on the line _after_ the where, just indented
17:56:50 <ivanm> rather than starting on the same line, as that leads to longer lines
17:56:57 <spark_> ivanm:  and i just got to learn how to make []->vector cd and use statistic fft!
17:57:04 <ivanm> heh
17:57:10 <spark_> ivanm:  ok, isee
17:57:27 <ivanm> for sign I would replace it with: sign = if a > 128 then negate else id
17:57:43 <ivanm> that way you just have "sign uresult" (maybe call it something other than "sign" then)
17:57:52 <ivanm> alternatively, use guards rather than an if statement
17:58:00 * hackagebot wai-app-file-cgi 0.7.2 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.7.2 (KazuYamamoto)
17:58:05 <spark_> ivanm:  hmmm, i forgot about those
17:58:19 <ivanm> I'm not sure about what your g definition is there for
17:58:24 <ivanm> oh, wait, right
17:58:29 <ahkurtz> would it be insane to try to use haskell to use FFT for real time sound synthesis? is that an extremely ambitious project?
17:58:33 <ivanm> first of all, better off having it on two lines
17:58:37 <spark_> ivanm: it's because i zipwith *
17:58:47 <ivanm> ahkurtz: I believe there are some packages that do that already
17:59:01 <ivanm> spark_: right; use two lines though rather than one line with a semicolon
17:59:04 <ivanm> alternatively:
17:59:09 <ivanm> > fromEnum True
17:59:10 <lambdabot>   1
17:59:14 <ivanm> > fromEnum False
17:59:15 <lambdabot>   0
17:59:50 <spark_> hmmmm
18:00:12 <aristid> > toEnum 10 :: Bool
18:00:13 <lambdabot>   *Exception: Prelude.Enum.Bool.toEnum: bad argument
18:00:18 <ivanm> your indentation in twocomp looks inconsistent as well (the then and else should ideally be indented either to line up with the if or more than the if)
18:00:27 <ivanm> aristid: yes, well, I never suggested to do the inverse ;)
18:01:38 <ivanm> spark_: oh, and foldr (+) 0 == sum !
18:01:40 <ivanm> @src sum
18:01:40 <lambdabot> sum = foldl (+) 0
18:01:58 <ivanm> OK, so it's actually a foldl, but in terms of what you're doing it should be the same
18:02:05 <ivanm> unless you're using lazy Natural numbers or something
18:02:18 <aristid> ivanm: the toEnum function always makes me uncomfortable
18:03:27 <spark_> aristid: why so?
18:04:26 <ivanm> spark_: also, why not create your amap directly than defining map4 ?
18:04:47 <ivanm> oh, right
18:05:10 <aristid> spark_: because it's partial
18:05:11 <ivanm> spark_: I would actually create your own type for FourD rather than newtyping (,,,)
18:06:07 <spark_> ivanm: what do you mean by making it directly?
18:06:50 <ivanm> data FourD b a = FourD a a a b
18:07:06 <spark_> i thought fmap doesn't work on data?
18:07:21 <aristid> yes it does, you just need to define your instance.
18:07:34 <parcs`> blackdog: running upx on the binaries should decrease their size by a factor of 10
18:07:42 <aristid> which GHC can do automatically with an extension, but it's easy enough to write by hand
18:08:10 <blackdog> parcs`: hrm, that's an interesting idea. 3mb is still more than pushing source, but it would solve the immediate pain point well enough
18:08:23 <blackdog> parcs`: especially if you could provide a vagrant box with everything set up already.
18:08:41 <parcs`> also make sure the binaries are stripped
18:09:24 <ivanm> spark_: you're defining your own Functor instance anyway
18:09:32 <spark_> hmmm
18:09:43 <ivanm> I would also call it "FourD a b" rather than "FourD b a", but that could be a slight OCD tendency :p
18:09:57 <spark_> ivanm: last time I tried with data i failed, probably because my data was int^3string in place of a^3 b
18:10:26 <ivanm> well then, yes, Functor won't work :)
18:10:31 <spark_> ivanm:  ahahahaha that's from the original code I learn Functor
18:10:57 <spark_> i think somewhere there they said it doesn't work with data, and only newtype with one constructor
18:12:23 <parcs`> blackdog: you could also copy all the required libraries to the server side and send a dynamically linked binary
18:13:14 <blackdog> parcs`: you'd have to do that individually anyway in the heroku model
18:13:21 <blackdog> blah, that was incoherent. let me try again
18:14:05 <spark_> i hate having to reinstall everything for profiling t.t
18:14:06 <blackdog> you can cache stuff, i suppose. if you're not using that space for building, you could commit your local libs into the repo, then only push changes when they change locally
18:14:13 <spark_> ivanm:  thanks, i'll change the type to that
18:14:42 <spark_> ivanm: wait, hmmm, this would change the definition of amap by a lot, i supose
18:24:51 <spark_> is there a script that reinstall everything from cabal to profiling mode?
18:25:01 <ivanm> spark_: cabal install world
18:25:10 <ivanm> once you've enabled profiling in ~/.cabal/config
18:25:13 <spark_> cabal install -p world ?
18:25:42 <ivanm> no
18:25:52 <ivanm> enable profiling in ~/.cabal/config and then just cabal install world
18:27:32 <Cale> ivanm: What happens if someone uploads a package named 'world' to hackage? :)
18:27:34 <spark_> -- library-profiling: True ?
18:27:54 <Cale> spark_: and while you're at it, set  documentation: True  as well
18:27:58 <ivanm> Cale: heh
18:28:04 <ivanm> spark_: yeah, uncomment that
18:28:20 <ivanm> Cale: better hope dcoutts_ has set that as a non-available package on Hackage :p
18:28:23 * shachaf has documentation: True but has never used it.
18:28:32 <spark_> ivanm: you mean put it to true?
18:28:39 <spark_> ivanm: its here on false too
18:28:39 <ivanm> spark_: yes
18:28:52 <ivanm> you want library profiling, right? ;)
18:28:54 <spark_> Cale: thanks D:
18:28:58 <Cale> shachaf: file:///home/shachaf/.cabal/share/doc/index.html
18:28:59 <spark_> yes
18:29:03 <ivanm> don't enable executable-profiling by default though
18:29:10 <spark_> ivanm:  why not?
18:29:13 <ivanm> because that will slow down any executables you build
18:29:23 <ivanm> even if you don't run them with profiling
18:29:23 <spark_> ivanm: ahhh ok
18:29:23 <shachaf> Cale: I just read the source, though!
18:29:28 <shachaf> It's way better than the documentation.
18:29:43 <ivanm> just use --enable-executable-profiling when doing a cabal configure/install for the packages you actually want to build profiling binaries for
18:29:51 <spark_> I guess this will take hours to compile
18:29:52 <ivanm> shachaf: though quite often less pretty
18:32:54 <spark_> great, cabal install world fails because repa alghoritms requires llvm
18:32:56 <spark_> o.O
18:33:33 <roconnor> is there profit in combinatorrent?
18:33:43 <geekosaur> os x by any chance?  apple's llvm is incomplete, you need to install a full one
18:33:47 <ivanm> spark_: if you built it by hand, you'll need to build it by hand again
18:34:08 <spark_> ivanm: I didnt, it failed before
18:34:29 <ivanm> remove repa-algorithms from the ~/.cabal/world file then
18:39:25 <spark_> ivanm:  strange, it is ignoreing the world file
18:42:38 <spark_> oh it was just another library ttrying to compile the same broken library
18:43:03 <parcs`> what is the point of the 'restore' function that 'mask' applies its argument to?
18:44:15 <parcs`> the docs cite this as an example: 'mask $ \restore -> do x <- acquire; restore (do_something_with x) `onException` release; release' but isn't that identical to
18:44:29 <parcs`> 'mask $ \_ -> do x <- acquire; do_something_with x; release'
18:47:07 <parcs`> what happens when 'do_something_with x' throws an exception in the second snippet?
18:48:51 <dwi_> hi there, i'am dwi from Indonesia, I would to know about haskell programming, do Haskell can create web?
18:49:06 <shachaf> dwi_: See the FAQ:
18:49:07 <shachaf> @where faq
18:49:07 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:49:21 <ivanm> @faq do Haskell can create web?
18:49:22 <lambdabot> The answer is: Yes! Haskell can do that.
18:49:23 <ivanm> :p
18:49:26 <ion> Yes, there are Haskell libraries/frameworks for web development.
18:49:44 <dwi_> hello ?
18:50:24 <latro`a> how do I shot web with haskell
18:52:24 <ion> @faq Can Haskell have a radioactive spider bite you?
18:52:24 <lambdabot> The answer is: Yes! Haskell can do that.
18:52:37 <ivanm> sweet!
18:52:38 <ivanm> :p
18:52:52 <ivanm> unsafeRadioactiveSpider ? :p
18:53:20 <latro`a> unsafePerformRadioactiveSpiderBite
18:53:34 <latro`a> it even has the unpredictable loss of spidey powers due to the bite having never happened
18:53:48 <spark_> ion:  that doesnt sense
18:54:04 <shachaf> radioactiveBiteString
18:54:11 <latro`a> *groan*
18:54:25 <shachaf> Anyway, none of these jokes in #haskell
18:54:28 <shachaf> Take it to #not-haskell
18:54:46 <spark_> @ Can #haskell be #not-haskell
18:54:56 <spark_> @faq Can #haskell be #not-haskell?
18:54:56 <lambdabot> The answer is: Yes! Haskell can do that.
18:55:02 <ivanm> shachaf: but... that channel doesn't exist!
18:55:07 <shachaf> spark_: No, it can't.
18:55:13 <shachaf> ivanm: Nor should these jokes.
18:55:16 <spark_> shachaf: the bot is never wrong
18:55:17 <ivanm> heh
18:55:22 <spark_> lol
19:00:36 <spark_> why cabal install world will take the flag and recompile everything, and cabal install -lib- wont?
19:00:48 <spark_> the profiling flag*
19:01:38 <dcoutts_> spark_: they work the same, both take the profiling flag
19:02:08 <dcoutts_> cabal install world is the same as cabal install $(the list of all packages you installed via cabal install)
19:02:23 <spark_> dcoutts_: well, the second fails automatically when a depending library is not profile ready
19:03:02 <spark_> dcoutts_: and install world doesn't seem to be doing this
19:04:22 <dcoutts_> spark_: cabal install world is just reinstalling more things
19:04:44 <dcoutts_> neither are automatically rebuilding dependencies that don't have the prof version installed
19:05:53 <spark_> well, either it's ignoring the flag in the \cabal\config, or is recompiling all libs again
19:05:57 <spark_> and it did ignore the flag
19:06:59 <dcoutts_> spark_: you're missing the point that the world target includes basically everything, so effectively it does cover all deps (not ones that come with ghc, but those do have prof versions already)
19:07:40 <spark_> dcoutts_: is there more packages then the one listed on the world file? make sense
19:08:44 <dcoutts_> spark_: the ones installed are known by ghc-pkg, see ghc-pkg list. The ones that get reinstalled when you do cabal install world are the ones in the world file
19:08:56 <spark_> hmmmm
19:16:43 <spark_> lol, just from changing fft from list to vector my runtime went from 4.15 to 3s
19:19:14 <spark_> im still using 800mb runtime for a 25mb file
19:19:33 <spark_> is there a better tool that can trace what is in memory ?
19:37:55 <Cale> spark_: 4.15 seconds or 4 minutes 15 seconds?
19:38:18 <spark_> 4.15s
19:38:29 <Cale> That's a little underwhelming then
19:38:56 <ivanm> Cale: well, the statistics fft implementation is internal rather than using a tuned variant like fftw
19:39:25 <Cale> ivanm: I'd just expect vector to be a much better datastructure than lists to do an FFT over.
19:39:38 <spark_> Cale: well, it reduced from 80% to 50% time
19:39:39 <ivanm> well, it depends what else he's doing
19:39:50 <Cale> True :)
19:39:50 <ivanm> how he's creating the structure, etc.
19:39:58 <latro`a> part of the problem is that the FFT is a very well-built algorithm for in-place work
19:40:30 <latro`a> obviously the asymptotics don't change
19:40:35 <latro`a> but in-place ffts are *fast*
19:58:19 <spark_> whats the diference between a foldr and a foldl?
19:59:00 <n00b6502> they work opposite ways can't remember which is which
19:59:02 <startling> spark_: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
19:59:11 <startling> n00b6502: foldl is left, foldr is right. ;)
19:59:22 <n00b6502> from the left or going left
19:59:40 <spark_> well, if i have foldr i can change it to foldr teorically?
19:59:54 <n00b6502> there's a 'tree like fold' too aswell?    ((a b)(c d)) etc
19:59:55 <ion> foldr is appropriate when your function parameter is lazy on its second parameter; foldl' is appropriate when you want to update an accumulator value for each item in the input list.
19:59:58 <n00b6502> foldt ?
19:59:59 <JoeyA> foldl' (you almost always want the ') is for "sum"-like operations.
20:00:07 <startling> n00b6502: going to the right
20:00:08 <JoeyA> foldr is for "map"-like operations.
20:00:20 <n00b6502> aren't they all reductions
20:00:30 <JoeyA> Yes
20:00:34 <ion> > foldr (:) [] [42..100]
20:00:36 <lambdabot>   [42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66...
20:01:13 <JoeyA> A case (the only case I can think of) where you don't want ' on foldl is for re-implementing 'last'
20:01:13 <spark_> that exactly what im doing, but for some raeson i cant go from vu.foldr to vu.foldl
20:01:42 <JoeyA> > let last = foldl (\_ x -> x) undefined in last [1..10]
20:01:43 <lambdabot>   10
20:02:28 <DT`> protip: (\_ x -> x) = const id.
20:02:34 <spark_> for some reason my program is getting slower when going vector
20:02:35 <spark_> o.O
20:02:56 <latro`a> > let last = foldl' (const id) undefined in last [undefined,undefined,2]
20:02:57 <lambdabot>   *Exception: Prelude.undefined
20:03:01 <startling> DT`: isn't that just const?
20:03:02 <JoeyA> length "(\_ x->x)"
20:03:04 <latro`a> (just to drive the point home)
20:03:12 <JoeyA> > (length "(\_ x->x)", length "const id")
20:03:13 <lambdabot>   <no location info>:
20:03:13 <lambdabot>      lexical error in string/character literal at chara...
20:03:17 <DT`> startling, const is (\x _ -> x).
20:03:20 <JoeyA> > (length "(\\_ x->x)", length "const id")
20:03:22 <lambdabot>   (9,8)
20:03:23 <startling> DT`: oh right
20:03:49 <latro`a> you need the parens in const id here anyways
20:03:51 <latro`a> same as the lambda
20:03:56 <latro`a> so it's 9 vs 10
20:04:09 <DT`> one character less!
20:04:26 <Jafet> > (comparing length) "const id`foldl'`undefined" "foldl'(\\_ x->x)undefined"
20:04:26 <JoeyA> I often avoid const, since '\_ ->' is the same length.  But that breaks when you need to parenthesize and such.
20:04:27 <lambdabot>   GT
20:04:48 <ion> The length difference is irrelevant.
20:05:00 <Jafet> JoeyA: \_->
20:05:31 <DT`> I use const when possible because I wanto to avoid \_->.
20:05:35 <JoeyA> That's even shorter than "const" :-)
20:05:48 <DT`> it doesn't look nice to me.
20:06:11 <latro`a> there is a lot to be said for being able to say your code
20:06:18 <latro`a> at least mostly
20:06:22 <otters> namely, "const"
20:06:51 <Jafet> @quote succ
20:06:51 <lambdabot> chrisdone says: Production of two-handed use langes Schwerts with long flambard blades and heavily category-theoretically decorated guards, katzbalgers, axes, mail and Macedonian quality defence
20:06:51 <lambdabot> pikes. Lambda Knights need to be prepared for the inevitable battle against success.
20:08:23 <spark_> @quote memory
20:08:23 <lambdabot> qwe1234 says: i know and program in more languages than can fit in your short-term memory, ok?
20:08:35 <spark_> wooosh
20:08:48 <spark_> @quote memory
20:08:48 <lambdabot> Anonymous says: A sufficiently advanced in-process cache is indistinguishable from a memory leak.
20:08:59 <JoeyA> :D
20:09:02 <spark_> @quote memory
20:09:02 <lambdabot> command says: lambdabot will say 'it is forever etched into my memory' and then forget the quote by tomorrow.
20:09:13 <latro`a> lol
20:09:18 <spark_> @quote memory
20:09:18 <lambdabot> Anonymous says: A sufficiently advanced in-process cache is indistinguishable from a memory leak.
20:09:23 <spark_> aw
20:09:34 <spark_> @quote leak
20:09:34 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
20:09:41 <latro`a> ...........
20:09:47 <spark_> @quote leak
20:09:47 <lambdabot> KetilMalde says: No, those are quite outdated by now.  The new horsemen of the programming apocalypse are, of course, IO, MutableState, LazyMemoryLeak, and Bottom.
20:10:10 <spark_> @quote leak
20:10:11 <lambdabot> KetilMalde says: No, those are quite outdated by now.  The new horsemen of the programming apocalypse are, of course, IO, MutableState, LazyMemoryLeak, and Bottom.
20:10:25 <JoeyA> @quote drug
20:10:25 <lambdabot> dylan says: pugs, darcs, and lambdabot: gateway drugs to haskell.
20:10:43 <frp4php> lol
20:11:09 <JoeyA> @quote satisfying
20:11:09 <lambdabot> <JoeyA> says: One thing I like about Haskell versus C++ is that abusing language features tends to give more satisfying results.  <monochrom> that seems to be a criterion for drugs rather than
20:11:09 <lambdabot> languages :)
20:11:24 <ion> FRP in PHP sounds painful.
20:11:32 <frp4php> ion: It is a joke.
20:12:03 <spark_> @quote haskell
20:12:03 <lambdabot> haskell says: "a programming language"
20:12:07 <frp4php> ion: I also have frp4vb6, a language that does not even have first-class procedures. :-)
20:12:19 <spark_> @quote haskell
20:12:19 <lambdabot> haskell says: Haskell - it's like a Lamborghini in the village. A little jerk - and went to work on the tractor.
20:23:03 * hackagebot hsshellscript 3.2.0 - Haskell for Unix shell scripting tasks  http://hackage.haskell.org/package/hsshellscript-3.2.0 (VolkerWysk)
20:23:37 <startling> shell scripting would be a thousand times nicer if it had . and Maybe
20:23:49 <startling> >>= even
20:23:51 <spark_> it has . ?
20:23:57 <spark_> | ?
20:24:26 <DT`> isn't | more like >>=?
20:24:43 <startling> spark_: kind of I guess
20:24:51 <spark_> I never used them, but i thought there was something called unix pipes
20:24:56 <startling> spark_: indeed
20:25:04 <spark_> oh D;
20:25:08 <Jafet> Shell scripting would be a thousand times nicer if people stopped doing it
20:25:10 <startling> spark_: I would consider that more like >>=, though
20:25:22 <startling> Jafet: no, it'd be bitter and lonely
20:25:28 <spark_> yeah, thats true
20:26:12 <startling> scratch that, it'd be a thousand times better if it had types at all
20:28:15 <AfC> Interesting; we had shelly not to long ago, but looks like hsshellscript has been around a very long time
20:28:54 <Cale> | is kinda like >=>
20:29:40 <DT`> it doesn't really compose.
20:29:45 <spark_> the fuck
20:29:52 <Ralith> I want to do shell scripting with arrows
20:29:56 <spark_> i had a map /32 that was accounted for 50% time spent
20:29:59 <Jafet> | :: ByteString -> (ByteString -> ByteString) -> ByteString?
20:30:18 <Ralith> no.
20:30:28 <Ralith> | manipulates streams
20:30:30 <DT`> echo "something" | dosomething is like return "something" >>= dosomething.
20:31:57 <spark_> arg i forgot to compile with optimizations, maybe it wasnt that bad before
20:36:20 <Cale> | :: (ByteString -> IO ByteString) -> (ByteString -> IO ByteString) -> (ByteString -> IO ByteString)
20:36:28 <Cale> kind of
20:36:33 <Ralith> still not streams.
20:36:44 <Ralith> the streams are kind of the whole point.
20:36:51 <Cale> If the ByteStrings are lazy, then it is almost like that :)
20:36:53 <Jafet> ByteString is a stream
20:37:41 <otters> yeah, so | is >=>
20:37:43 <otters> :P
20:37:46 <otters> :t (>=>)
20:37:47 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
20:37:48 <Ralith> Jafet: no, it's not :P
20:37:59 <Jafet> But in (foo | bar), foo :: IO ByteString and bar :: ByteString -> IO ByteString
20:38:08 <ion> Don’t cross the streams.
20:38:11 <Jafet> Or maybe not
20:38:16 <otters> Yeah, because foo has already been applied to something
20:38:18 <otters> echo "foo" | bar
20:38:26 <otters> ...waaaaaait
20:38:27 <otters> you're right
20:38:30 <otters> ma
20:38:51 <otters> But in that case echo "foo" | bar would just be of type IO ByteString
20:38:58 <otters> so...it is >>= after all
20:39:45 <ion> echo "foo" :: IO ByteString
20:39:53 <ion> cat :: ByteStrig -> IO ByteString
20:40:04 <ion> cat | bar
20:40:41 <Jafet> (foo) and (bar|foo) are valid pipes
20:40:50 <Jafet> What's the type of foo?
20:41:29 <ion> Perhaps echo foo :: ByteString -> IO ByteString where it doesn’t evaluate its parameter. :-P
20:42:49 <Jafet> runSH :: (ByteString -> SH ByteString) -> SH ByteString; runSH p = p ""
20:43:37 <Jafet> So every chain is implicitly started with an empty input
20:48:57 <startling> so where should I put tests in my project's directory? how can I run them? (does Cabal run tests?)
20:49:23 <otters> typesafe shell scripting
20:49:25 <otters> That will be the day
20:49:31 <Jafet> cabal test
20:49:52 <startling> otters: indeed
20:50:08 <Jafet> powershell has some notion of types
20:50:32 <Ralith> I don't want anywhere near any shell system that doesn't handle streams properly
20:50:33 <Jafet> Also nobody uses it
20:51:43 <startling> Jafet: interesting
20:51:46 <Jafet> So reactionary
20:51:54 <Jafet> What's a stream, anyway?
20:51:59 <startling> what should I use to run quickcheck tests?
20:52:17 <Jafet> I have no idea, startling
20:56:41 <spark_> why haskell so leaky T.T
20:57:39 <ion> Because the Haskell Report dictates so, right on page 59.
20:58:13 <spark_> ion: Since there is really a haskell report, I wonder what's on page 59
20:58:41 <dolio> Depends on the version.
20:58:41 <startling> haskell is leaky?
20:59:07 <spark_> startling: well, it's leaking everywhere on my program
20:59:11 <spark_> ops
20:59:36 <spark_> startling: and I have no idea where all this water coming from
20:59:59 <startling> heh
21:00:41 <startling> spark_: when you say "leaking", do you mean "uses lots of memory" or "doesn't clean up allocated memory"?
21:01:25 <spark_> startling: that I have a program that should be close to O(C) and is O(e^e^x)
21:01:38 <temphobo> > 3 / 4
21:01:39 <spark_> in memory
21:01:39 <lambdabot>   0.75
21:02:19 <spark_> in fact, the program runs at O(c)
21:02:35 <spark_> but c~e17 bigger than the input
21:03:08 <startling> spark_: doesn't sound like a leak to me !
21:03:17 <startling> spark_: anyway, you might want to use ST or something
21:03:45 <mauke> spark_: what does your program do?
21:03:47 <spark_> well, how should I call it?
21:04:32 <spark_> mauke: I read data from a file (acceleration values), I separate it in multiple blocks of 32 and apply fft to every block
21:05:02 <mauke> have you tried profiling it?
21:05:15 <n00b6502> is a haskell program predictable in its memory use or does lazy-eval mean the implementation can choose to run it a different way .. eg based on howw much inlining is done
21:05:15 <spark_> apply a little function that return a single value to every 'fft-ed' array, and then print to a file
21:05:24 <startling> n00b6502: yes
21:05:37 <n00b6502> yes to which clause
21:05:45 <spark_> mauke:  I am profiling tons, but still doesn't say/I can't interpret it maybe?
21:05:51 <startling> n00b6502: thought it was a boolean or
21:06:01 <n00b6502> its an either or :)
21:06:07 <startling> n00b6502: I think it's the latter
21:06:11 <n00b6502> i heard of something called "deforestatiion" - removing pointers
21:06:24 <mauke> deforestation doesn't remove pointers
21:06:31 <spark_> mauke:  http://imgur.com/cmV6I this is an example, but still, which function is to blame there?
21:06:49 <n00b6502> ok i thought it was  something like serializing a graph in memory to make it pointerless, something else then
21:07:07 <mauke> spark_: no idea
21:07:10 <n00b6502> i suppose you might have a runtime "size vs speed" tradeoff option
21:07:53 <johnw> spark_: when you read, what data type are you reading the data into?
21:08:38 <spark_> johnw: a list of (FourD B.ByteString Int)
21:08:51 <spark_> (which is a tuple with type (a,a,a,b)
21:08:53 <johnw> and how are you parsing out the blocks
21:09:02 <mauke> actually, why not post the whole program?
21:09:12 <mauke> that way we can actually reproduce the problem
21:09:42 <startling> ^ good call
21:09:51 <hpaste> spark_ pasted “memory leak not over fftAcross” at http://hpaste.org/73871
21:10:12 <spark_> I started changing some lists to vectors
21:10:17 <monochrom> it is the last thing a programmer thinks of. actual code and actual reproduction
21:10:29 <johnw> any reason you're using ByteString.Lazy.Char8 with ByteString.Internal?
21:10:34 <spark_> for example, splitN was [[]], now it is [vector], but still pretty big
21:10:39 <johnw> why not ByteString.Lazy.Char8 with ByteString.Lazy?
21:10:47 <mauke> johnw: why "with"?
21:10:48 <johnw> all that unpacking and re-packing is costing you
21:11:03 <spark_> johnw: i think I got rid of most of it
21:11:07 <johnw> ok
21:11:12 <johnw> using just BS.Lazy would be the best approach
21:11:21 <johnw> the code you pasted is reading in the file strictly it looks like
21:11:36 <johnw> and of course, the pack/unpack is a waste
21:11:47 <spark_> johnw: yes, I was (and still is) learning how to use bytestring correctly, so i had some things mixed
21:11:55 <johnw> is this old code then?
21:11:58 <johnw> show me the fixed version
21:12:02 <spark_> johnw: no, it's working
21:12:03 <temphobo> can I not create pattern matching after where?
21:12:11 <startling> temphobo: how do you mean?
21:12:17 <spark_> johnw: and the reading should be lazy too
21:12:24 <temphobo> like where f [] = 0; f (a:as) = ...
21:12:29 <spark_> johnw: ah, no the reading isnt
21:12:31 <startling> temphobo: you can
21:12:31 <temphobo> startling: ^
21:12:40 <temphobo> ghci complains when i do it
21:12:47 <temphobo> it says there is a parse error on '='
21:12:48 <startling> temphobo: paste code
21:13:00 <monochrom> the error is elsewhere
21:13:14 <johnw> spark_: do you have a more recent version of the code to show me?
21:13:21 <monochrom> it is the last thing a programmer thinks of. actual code and actual reproduction
21:13:23 <spark_> johnw: no, this is what im running atm
21:13:37 <johnw> ok, so I think your B.unlines, since it's using strict ByteStrings, is costing you a lot
21:13:50 <spark_> johnw: some imports are just not used in the code, but yeah the reading is strict, the writing isnt
21:13:56 <johnw> just switch to ByteString, drop the .Internal import, drop the Char8 import and the extra pack/unpack step
21:14:07 <johnw> sorry, I meant ByteString.Lazy
21:14:14 <hpaste> temphobo pasted “wat” at http://hpaste.org/73872
21:14:28 <johnw> and the fact that your doing a concat after a map suggests you may prefer to do a fold
21:14:37 <spark_> johnw: wait, I **shouldn't** use bytestring.char8.lazy?
21:14:42 <johnw> otherwise, you're building up a large data structure just to tear it right back down
21:14:50 <johnw> spark_: use just Data.ByteString.Lazy
21:14:51 <spark_> hmmmm
21:14:53 <spark_> ok
21:14:54 <johnw> you shouldn't need Char8
21:16:05 <johnw> what is "map head" intended to do?  Do you have a list of sublists and you don't care about the tails?
21:16:20 <Jafet> hobo: ghci is a do block, so you introduce definitions with let
21:16:21 <temphobo> startling: ^ btw lol
21:16:38 <spark_> johnw: yes
21:16:42 <mauke> temphobo: it's a type error but works otherwise
21:16:49 <monochrom> I only get a type error, not a parse error
21:16:51 <johnw> lastly, there's a better way than 'B.pack ""'
21:16:55 <temphobo> mauke: what's the type error?
21:17:11 <johnw> well, maybe not
21:17:13 <Jafet> Well, you're not pasting the whole thing into ghci
21:17:14 <monochrom> couldn't match a with [a]
21:17:14 <spark_> johnw: i didn't knew how to build lazy list
21:17:17 <johnw> never mind that one
21:17:20 <mauke> temphobo: http://hpaste.org/73873
21:17:24 <johnw> spark_: just building a list makes it a lazy list ;)
21:17:36 <johnw> in general you shouldn't have to think about laziness too hard
21:17:38 <spark_> er
21:17:40 <spark_> wrong word
21:17:47 <spark_> johnw: a lazy bytestring*
21:17:47 <johnw> it's when you *don't* want laziness that you have to do work
21:17:52 <johnw> oh, yeah
21:18:03 <monochrom> when I look at "flp (a:[]) = ..." and "flp (a:as) = ...", the type error makes sense
21:18:42 <johnw> spark_: in your Parsec parser, use char ',' not string ","
21:19:10 <temphobo> mauke: i don't understand why that produces a type error
21:19:46 <mauke> temphobo: what is the type of flp?
21:19:50 <temphobo> mauke: oh geez. nvm
21:19:55 <monochrom> actually, "plndrmz as = as : ..." is inconsistent with [a]->[a]. pretty clearly.
21:20:22 <temphobo> mauke: it's the type of (:) it's concerned about...
21:20:29 <temphobo> monochrom: yeah, i picked up on it lol
21:20:36 <temphobo> monochrom: thank you ;)
21:20:40 <johnw> when I see: uncurry4 zip4 . map4 f g . unzip4 . map getFourD
21:20:46 <johnw> i think there's got to be a more direct way to do that
21:21:09 <mauke> temphobo: what does that have to do with my question?
21:21:31 <johnw> I'm thinking just do one map with a better mapping function
21:21:39 <temphobo> mauke: flp :: [a] -> [a]
21:22:02 <mauke> temphobo: what's the type of (:)?
21:22:05 <monochrom> "flp (a:as) = (flp as) : ..." is inconsistent with [a]->[a]
21:22:12 <temphobo> right
21:22:17 <temphobo> i should use ++
21:22:26 <temphobo> (:) :: a -> [a] -> [a]
21:25:57 <spark_> johnw:  Sorry my internet failed, did i lost something?
21:29:39 <johnw> spark_: when I see: uncurry4 zip4 . map4 f g . unzip4 . map getFourD
21:29:42 <adnauseam> can return be thought of as a functor ?
21:29:43 <johnw> I'm thinking just do one map with a better mapping function
21:30:08 <monochrom> no
21:30:32 <Cale> adnauseam: The monad M is the functor, return a -> M a is a natural transformation from the identity functor to M
21:30:42 <Cale> return :: a -> M a
21:31:18 <Cale> (you can think of it as providing the component of such a natural transformation at each type a)
21:31:43 <adnauseam> oh i see
21:31:53 <Cale> fmap :: (a -> b) -> (M a -> M b) provides the mapping on arrows for the functor
21:31:58 <spark_> johnw: hmmm, how can i define it?
21:32:20 <spark_> johnw: because well, hmm, this was the 'better map' I was thinking about
21:32:25 <johnw> map f', where f' does all the work
21:32:40 <johnw> rather than creating a ton of lists and tuples you're just going to throw away
21:34:17 <temphobo> hmm
21:34:20 <temphobo> the problem is my editor
21:34:32 <temphobo> it is shifting over too far, but it looks  just fine
21:34:33 <temphobo> :|
21:34:39 <dibblego> johnw: map and unzip operations compose together — you may want to look at the TypeCompose library
21:35:28 <monochrom> do not trust your editor. it translates behind your back.
21:35:39 <mk> in the continuation monad, what particular part is "the continuation"?
21:35:43 <temphobo> monochrom: ha
21:36:12 <spark_> johnw: the fact that i have[(a,c)] and my function is [a]->b, doesn't that force me to make the structure with [a]?
21:36:16 <temphobo> monochrom, mauke, startling: thanks for the help :)
21:37:09 <johnw> spark_: which function is [a]->b?
21:38:06 * hackagebot persistent-vector 0.1.0.1 - A persistent sequence based on array mapped tries  http://hackage.haskell.org/package/persistent-vector-0.1.0.1 (TristanRavitch)
21:38:12 <spark_> quare . (drop 1 ) . fft
21:38:30 <spark_> in the code is (map (floor . quare .(Vu.drop 1) ). fftAcross)
21:38:48 <monochrom> @unmtl Cont r a
21:38:48 <lambdabot> (a -> r) -> r
21:39:22 <johnw> something smells fishy here
21:39:31 <johnw> your file is basically a [(a,b,c,d)], right?
21:39:36 <spark_> yes
21:39:46 <johnw> what is quare . drop 1 . fft doing?
21:40:31 <johnw> are you wanting, at each step, to sum all the entries you've seen so far?
21:41:55 <spark_> then i make ([],[],[],[]). then i do ([(vector)],[(vector)],[(vector)],[[]]), apply fft to the list of vector, transformate those vectors to a value ([],[],[],[]), then remake the list [(,,,)]
21:41:58 <johnw> you've got a *lot* of maps within maps going on here
21:42:30 <johnw> here's what I'd do at this point
21:42:36 <spark_> hmmm
21:42:38 <johnw> write down your core algorithm in the simplest form possible
21:42:49 <johnw> describe the input, the output, and the transformation to go from a to b
21:43:02 <johnw> then we can find the most optimal transformation in Haskell
21:43:27 <spark_> hmmm
21:43:36 <spark_> do you want me to explain it to you?
21:43:46 <johnw> write a comment for your cod
21:43:48 <johnw> then pastie me
21:43:51 <spark_> ok
21:44:09 <spark_> ill just finish passing ap to lazy
21:44:44 <johnw> because I count 11 maps in your code
21:44:55 <johnw> and that just doesn't seem write for how simple this should be
21:45:03 <spark_> Data.Attoparsec.Lazy doesnt have char/decimal
21:45:04 <spark_> @.@
21:45:05 <lambdabot> Maybe you meant: . @
21:45:54 <johnw> i don't think parsing is your bottleneck
21:46:08 <johnw> how big is the file?
21:47:49 <spark_> 100mb
21:47:59 <johnw> how much time is this taking?
21:48:03 <spark_> its not working
21:48:04 <spark_> D:
21:48:07 <johnw> oh, heh
21:48:09 <spark_> at 25mb it uses 800mb
21:48:12 <spark_> and 70s
21:48:18 <johnw> ok, that's totally wrong
21:48:21 <spark_> at 100mb, it goes over 2gb
21:48:21 <johnw> and not the fault of the parser
21:48:29 <spark_> the parser is ok
21:48:31 <spark_> is the mapings
21:48:39 <spark_> somewhere there there is a leak
21:49:01 <spark_> or a code bloater
21:51:06 <LordBrain> hello
21:52:01 <johnw> that actually makes total sense, from what I'm seeing
21:52:22 <johnw> it's not a leak, just a combinatorial explosion of intermediate values
21:52:33 <johnw> (or is that what Haskellers call a leak?)
21:52:39 <LordBrain> yeah
21:52:43 <LordBrain> space leak
21:52:57 <spark_> more a tsunami
21:53:12 <spark_> 40* the filesize is toomuch
21:53:20 <thirsteh> any way to have linebuffering in / explicit/block buffering out on an IO.Handle?
21:55:02 <mikeplus64> thirsteh: you mean hSetBuffering <handle> LineBuffering ?
21:55:17 <gentleben> laziness pretty much sucks
21:55:24 <thirsteh> I want that for input, yes, but I don't want it to flush the output buffer once per line
21:55:28 <Cale> gentleben: Just trolling?
21:55:48 <gentleben> nah. I just wish haskell was strict
21:55:48 <johnw> a non-lazy troll would try harder
21:55:56 <LordBrain> lol
21:56:05 <startling> I wish there was a haskell-like strict language, too
21:56:07 <LordBrain> i am very glad haskell is lazy personally
21:56:17 <startling> though laziness is very cool
21:56:19 <johnw> yes, it's laziness is a huge benefit
21:56:20 <thirsteh> mikeplus64: seems like hSetBuffering sets both in/out -- maybe I'm missing something
21:56:25 <LordBrain> but you can make it strict, all you need to do is use seq, and ! patterns etc
21:56:31 <johnw> so much garbage I don't have to think about
21:56:31 <Cale> Laziness is the better default imo.
21:56:35 <startling> {-# Language Strict #-}
21:56:44 <gentleben> writing apps the process huge amounts of data is much more difficult
21:56:45 <LordBrain> i agree with Cale
21:56:46 <startling> oh wait, this isn't perl
21:56:53 <mikeplus64> thirsteh: yeah, i'm not sure about only input or only output
21:56:57 <LordBrain> i suppose most of us would agree, being that we're mostly haskell fans
21:57:11 <johnw> gentleben: use the profiler, apply 'seq' where necesarry
21:57:16 <gentleben> haha
21:57:25 <johnw> about the same difficulty as making C++ code lazy when it needs to be
21:57:33 <johnw> which can completely suck
21:57:41 <Cale> The cases where you want nonstrict semantics greatly outnumber the cases where you really want strictness.
21:57:42 <gentleben> the profiler breaks down when it can take hours or days for a bug to repro
21:57:47 <johnw> so I'm not saying that finding the right place to put seq is trivial
21:57:57 <gentleben> actually the tools break down
21:58:03 <gentleben> it can still emit the data
21:58:04 <johnw> oh, the profiler crashes on you?
21:58:11 <gentleben> it just can't be observed
21:58:17 <johnw> that's no fun
21:58:19 <LordBrain> c++ has a lot of overhead... i am not going to rag on it, it was the bomb in the 90s heh
21:58:26 <gentleben> no, it produces too much data
21:58:47 <gentleben> but no matter
21:59:06 <gentleben> i wrapped my last bug in a timeout and i am back in a good state
21:59:18 <gentleben> the bug is not fixed, but no longer an issue
21:59:26 <spark_> johnw: I has a map (f) . map (g ), just made it map (f.g) and it got twice as fast
21:59:50 <LordBrain> spark_ if you are using ghc, use -O2
21:59:58 <spark_> johnw: I though haskell did it already for me
22:00:06 <spark_> LordBrain: Im compiling with O2
22:00:12 <Cale> I will say this -- writing efficient functional programs with nonstrict semantics is a different skill from writing efficient strict functional programs.
22:00:14 <thirsteh> mikeplus64: score! Should've read the docstrings for all funcs: mkDuplexHandle: like mkFileHandle, except that a Handle is created with two independent buffers, one for reading and one for writing. Used for full-duplex streams, such as network sockets.
22:00:15 <spark_> doesnt make a ton of diference
22:00:30 <mikeplus64> thirsteh: nice
22:00:32 <LordBrain> ah, in a lot of cases the stream fusion optimizing will do that for you, map f . map g = map (f.g)
22:00:43 <Cale> and it does take a significant amount of rebuilding of intuition about where things will go wrong
22:00:54 <gentleben> Cale: the bad part is that the tools are inadequate to help find problems
22:00:57 <Cale> But I don't think it's fundamentally harder or easier
22:00:57 <LordBrain> at least i am pretty sure it will
22:01:03 <thirsteh> mikeplus64: not sure if I actually get two handles though. Seems to only return one, still
22:01:35 <spark_> johnw: eeeeeeh, the memory usage got cut by two
22:01:43 <Cale> gentleben: Report bugs against GHC if the profiler isn't working well for you.
22:01:46 <spark_> I didnt expect that
22:02:31 <gentleben> I have a few active GHC trac tickets
22:02:37 <johnw> spark_: reducing maps is reducing loops, and reducing the intermediaries created by those loops
22:02:58 <johnw> if you can get down to a single map over your data, you'd find the consumption to be flat
22:02:59 <Jafet> There should be a rewrite rule for map somewhere
22:03:07 <Jafet> Wonder why it's not fired
22:03:11 <johnw> what I don't know is whether your algorithm can be done with a linear analysis
22:03:15 <spark_> johnw: I somewhat expected that the intermediates would have the same size
22:03:26 <spark_> or the code compile the map . map
22:03:26 <LordBrain> yeah, i am with Jafet
22:03:28 <johnw> for map (f . g) vs map . map g?
22:03:44 <johnw> map f . map g creates a whole slew of intermediaries that get thrown away
22:03:49 <LordBrain> the rewrite rule should have fired for that i am pretty sure
22:03:55 <LordBrain> unless it is an old ghc
22:03:55 <johnw> for map f . g, the intermediaries are the result
22:04:11 <johnw> but yes, an optimizer should have figured this out
22:04:14 <johnw> as everyone is asying
22:04:15 <spark_> LordBrain: well it didnt
22:04:20 <johnw> what version of GHC, and what flag?
22:04:23 <Cale> If you're compiling with -O then map f . map g will be compiled to the same thing as map (f . g)
22:04:24 <johnw> compilation flags?
22:04:38 <Cale> A rewrite rule will apply
22:04:44 <spark_> O3 atm haha
22:04:48 <spark_> has the same speed as O2
22:04:50 <mauke> there is no -O3
22:04:58 <spark_> well, that sucks
22:05:00 <Cale> -O3 used to have no effect :)
22:05:07 <startling> make sure you use -O98
22:05:12 <spark_> hahaha
22:05:17 <Cale> -O9999
22:05:24 <spark_> aaanyway
22:05:34 <spark_> since i took out that map, im from 70s to 30
22:05:50 <spark_> and 790mb to 480
22:06:13 <spark_> that's great , but I was expecting something like 25
22:07:12 <gentleben> spark_: how big is our executable?
22:07:17 <gentleben> *you
22:07:23 <johnw> take out more maps
22:07:27 <johnw> you had 11 of them
22:07:28 <spark_> 3.8mb
22:07:29 <johnw> get closer to 1
22:08:08 <LordBrain> maybe the rewrite rule it a limit in the depth or something
22:08:24 <spark_> LordBrain: or because im hiding them with naming?
22:08:36 <Cale> Is it the real map function from Data.List?
22:08:40 <Cale> That makes a difference
22:08:49 <spark_> ooh, i think its prelude map
22:08:55 <Cale> Or Prelude
22:09:08 <LordBrain> i think prelude just imports it from data.list
22:09:17 <spark_> anyway, my code is at least having a bottleneck on the fft function in place of other things
22:09:45 <spark_> im reuploading
22:10:10 <spark_> http://pastebin.com/9Vtd5eMy
22:10:12 <mauke> The paste 9Vtd5eMy has been copied to http://hpaste.org/73874
22:10:30 <spark_> http://pastebin.com/3mSUZ8xX
22:10:33 <mauke> The paste 3mSUZ8xX has been copied to http://hpaste.org/73875
22:11:06 <johnw> have you described the algorithm yet?
22:11:31 <spark_> arg, i was going to before uploading
22:11:43 <johnw> I bet you that whole splitAndApply thing has got to go
22:11:44 <spark_> anyway, fftacross is really close to
22:11:54 <spark_> in fact, it should be it
22:12:03 <johnw> there are 4 maps right there
22:12:12 <johnw> and then you map on the result
22:12:25 <spark_> the map on the result is the filtering
22:12:30 <johnw> ok, i'm taking away your map priveleges
22:12:31 <gentleben> spark_: a conduit will be much better
22:12:43 <spark_> what's a conduit
22:12:45 <spark_> @.@
22:12:45 <lambdabot> Maybe you meant: . @
22:12:47 <johnw> http://hackage.haskell.org/package/conduit
22:13:24 <gentleben> when you can stream your data, haskell is much happier
22:13:26 <spark_> (is there a better way to use hp2ps? my output always seem kinda bad)
22:13:50 <gentleben> whats bad?
22:14:07 <spark_> the picture
22:14:15 <spark_> for example is black and white, hahaha
22:14:26 <gentleben> oh
22:14:42 <gentleben> the other one does color
22:14:46 <johnw> how is conduit better than just ordinary function composition?
22:15:02 <gentleben> johnw: less thinks
22:15:10 <gentleben> *thunks
22:15:13 <spark_> gentleben: that's -c right? anything else i should know?
22:15:47 <gentleben> spark_: if its giving you the data you want I have never cared about the colors
22:16:48 <gentleben> whats using the space?
22:17:13 <gentleben> feel free to PM me
22:18:11 <thirsteh> mikeplus64: finally found it: hDuplicate :: Handle -> IO HandleSource - Returns a duplicate of the original handle, with its own buffer. The two Handles will share a file pointer, however. The original handle's buffer is flushed, including discarding any input data, before the handle is duplicated.
22:18:45 <Cale> In my eyes, conduit/iteratee/enumeratee are heavy-duty solutions to very particular performance issues which aren't something that you just throw in on a whim. Other people would disagree with me though.
22:19:00 <spark_> gentleben:  http://imgur.com/AQkHT
22:19:03 <spark_> thanks guys
22:19:08 <spark_> you've been helpfull
22:20:55 <gentleben> Cale: As we have moved more and more things into conduits we have had much fewer issues related to space
22:21:30 <spark_> he , I tried to run on my 100mb file
22:21:44 <Cale> I have no doubt that they're very appropriate for specific types of program
22:22:02 <spark_> since my 25mb file uses 400mb, I expected my 100mb to use 1600, it didnt (over 2gb, crashed OOM)
22:22:47 <ivanm> Cale: yeah, I haven't really found a need for them, since I tend to write stuff that just lazily outputs data to a file and that's it
22:22:53 <johnw> the space leak is combinatorial
22:23:22 <spark_> probilem is, whyyyy
22:23:27 <johnw> i've told you
22:23:28 <johnw> all the maps
22:23:33 <johnw> describe the algorithm to me
22:23:37 <johnw> so I can write it in fewer maps
22:23:40 <spark_> ok,
22:23:44 <ivanm> anyone know what kind of Exception I need to catch for "fd:5: hClose: resource vanished (Broken pipe)" ?
22:25:27 <shachaf> Some kind of errno exception?
22:26:28 <gentleben> is it an IOException?
22:27:32 <Cale> yes, it is
22:28:24 <ivanm> well, I'm already catching IO exceptions...
22:28:26 <Cale> hClose_rethrow :: SomeException -> Handle -> IO ()
22:28:26 <Cale> hClose_rethrow e h =
22:28:26 <Cale>   case fromException e of
22:28:26 <Cale>     Just ioe -> ioError (augmentIOError ioe "hClose" h)
22:28:26 <Cale>     Nothing  -> throwIO e
22:28:30 <ivanm> so I wonder why it isn't getting it :s
22:29:04 <ivanm> (more specifically: one function is meant to be converting an IOException to a GraphvizException, and another is getting the GraphvizException and doing something with that)
22:29:12 <ivanm> I wonder whether laziness is biting me somehow...
22:29:40 <shachaf> I don't like the Haskell exception mechanism. :-(
22:29:50 <Cale> I like the new Haskell exception mechanism
22:29:52 <gentleben> ivanm: This a common problem since its easy for the exectution to escape the handler
22:29:59 <ivanm> gentleben: *nod*
22:29:59 <shachaf> (BECAUSE YOU CAN MAKE CUSTOM TYPEABLE INSTANCES AND CRASH EVERYTHING!!!)
22:30:01 <johnw> what is the new exception mechanism?
22:30:08 <LordBrain> what's the new exception mechanism?
22:30:10 <ivanm> johnw: extensible-exceptions
22:30:16 <LordBrain> oh you beat me to it john
22:30:19 <Cale> It's the one in Control.Exception right now
22:30:42 <LordBrain> how's it differ than what was there?
22:30:42 <gentleben> ivanm: have you considered making the result of the function strict via nfdata?
22:30:50 <spark_> brb
22:30:54 <Cale> http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Exception.html
22:31:02 <ivanm> gentleben: I thought it already was strict ;)
22:31:08 <Cale> LordBrain: It differs greatly from the IO exceptions in Haskell 98
22:31:13 <Cale> LordBrain: by being extensible
22:31:20 <LordBrain> oh i get ya
22:31:32 <gentleben> ivanm: yeah. that happens. I need to finish my blog post on this exact problem
22:31:46 <gentleben> I will do it when I get to the office in the morning
22:31:54 * shachaf is looking forward to base-4.6.
22:32:12 <johnw> shachaf: what in particular?
22:32:17 <ivanm> specifically, what seems to be happening is that whilst my "get the output from running this external program" function is strict, it doesn't matter if it crashes because the program doesn't actually exist
22:32:26 <ivanm> and I suspect that the error is coming from earlier than I thought...
22:32:30 <Cale> I disagree that Ivan's problem likely has anything to do with strictness
22:32:43 <shachaf> Why would exceptions have to do with strictness?
22:32:52 <gentleben> seriously guys?
22:32:55 <Cale> shachaf: Well, exceptions thrown from pure code
22:32:57 <ivanm> shachaf: because the result isn't evaluated where I thought, it isn't being caught until later
22:33:09 <ivanm> @type bracket
22:33:10 <lambdabot> Not in scope: `bracket'
22:33:13 <ivanm> bah
22:33:16 <ivanm> @hoogle bracket
22:33:16 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:33:16 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:33:16 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:33:22 <Cale> However, it seems weird for *hClose* to be throwing an exception from pure code
22:33:28 <shachaf> Cale: Oh. I thought it was an IO error.
22:33:48 <shachaf> I should hope exceptions with an errno never get thrown from pure code. :-)
22:33:54 <johnw> gentleben: do conduits play well with, say, Parsec?
22:34:09 <gentleben> there is an attoparsec conduit
22:34:19 <gentleben> i have used it for a couple of things
22:34:28 <Cale> attoparsec is very different from Parsec though
22:34:30 <gentleben> our real parsers are all ragel
22:34:32 <ivanm> so now I need to work out whether it's opening the handle or closing it that's getting the error
22:34:58 <Cale> ivanm: Do you have an explicit hClose?
22:35:04 <ivanm> Cale: yup
22:35:13 <Cale> ivanm: Then the exception must be happening there
22:35:27 <ivanm> *nod*
22:35:34 <shachaf> base-4.6 has readEither and readMaybe!
22:35:39 <Cale> ivanm: It's just a matter of making sure it gets caught. Try catching all exceptions at first perhaps?
22:35:40 <ivanm> :o
22:35:41 <shachaf> All our problems will be solved.
22:35:51 <ivanm> yeah
22:35:54 <Cale> Haskell 98 has reads
22:35:59 <shachaf> reads is terrible.
22:36:01 <gentleben> ivanm: what happens if you wrap the close in a handler
22:36:12 <ivanm> wait, that's right, my entire function is wrapped in a mapExcetion (foo :: IOException -> GraphvizException)
22:36:26 <ivanm> yet the error is still coming out as an IOException...
22:36:34 <ivanm> gentleben: the entire thing is wrapped in bracket
22:36:37 <Cale> ivanm: heh, what?
22:37:00 <ivanm> the function in question is: http://hackage.haskell.org/packages/archive/graphviz/2999.14.0.0/doc/html/src/Data-GraphViz-Commands-IO.html#runCommand
22:37:16 <gentleben> and you are positive that evaluation is completed inside the handler
22:37:29 <ivanm> I wrap calling this with handle to deal with the GraphvizException
22:38:14 <Cale> It has nothing to do with evaluation
22:38:59 <gentleben> ivanm: did you try catching just SomeException?
22:39:10 <ivanm> gentleben: nope
22:39:35 <gentleben> see if that catches it
22:39:41 <ivanm> the (Handle -> IO a) function I'm passing in to that is: SB.hGetContents h >>= SB.writeFile fp >> return fp
22:40:57 * ivanm tries
22:41:37 <LordBrain> Is it better to catch exceptions close to where they are thrown, or is it best to just have one consolidated place in the code where all exceptions are caught?
22:41:48 <Cale> LordBrain: depends
22:41:57 <LordBrain> yeah, thats what i thought
22:41:59 <spark_> johnw: Ahm, i wrote something but im not sure it's clear
22:42:00 <LordBrain> lol
22:42:18 <johnw> let me give it a gander
22:42:19 <ivanm> gentleben: just meant the program ran further :/
22:42:30 <gentleben> same error?
22:42:37 <LordBrain> What's the more usual case tho, coming from those who have a lot of experience with exceptions in haskell
22:42:41 <johnw> writing a clear description is key to finding the best algorithm
22:42:46 <johnw> so let's refine it
22:42:49 <ivanm> same errors on stderr but now I do indeed seem to be _getting_ some of the errors caught
22:43:12 <ivanm> it seems that my attempts at getting the actual error messages have failed
22:43:12 <LordBrain> exceptions are like a semantic clutter in this way
22:43:14 <hpaste> spark_ pasted “optimizing representation” at http://hpaste.org/73876
22:43:16 <johnw> oh, hey, I have a typing question for you guys
22:43:22 <ivanm> and the messages are printed to stderr rather than in the generated file :s
22:43:29 <ion> shachaf: nice
22:43:37 <ivanm> no, wait, I'm getting some hClose errors
22:43:39 <Cale> LordBrain: Usually pretty close.
22:43:44 <gentleben> ivanm: but your process is still getting torn down?
22:43:47 <ivanm> it seems to be random whether the message is caught or not :/
22:43:53 <ivanm> gentleben: what do you mean by "torn down"
22:43:57 <ivanm> I'm still getting errors
22:44:08 <LordBrain> i guess i dont bother with them usually, except on file io
22:44:13 <johnw> I want to have a family of GitObjects, like GitBlob, GitTree and GitCommit.  I want to be able to put them into a list, like [GitObject].  However, I also want to typecheck that a function that need a GitTree is receiving a GitTree.  Do I have to compromise heterogeneity to get typechecking?
22:44:14 <gentleben> the runtime had an unhandled exception on the main thread
22:44:19 <startling> @pl \f x -> f y x
22:44:19 <lambdabot> ($ y)
22:44:23 <startling> oh right
22:44:23 <LordBrain> i dont really have much choice there
22:44:30 <ivanm> gentleben: I'm still getting errors on stderr
22:44:42 <LordBrain> and sockets
22:44:48 <gentleben> ivanm: that causes the runtime to tear down teh app
22:44:58 <gentleben> crash it if you will
22:45:00 <Cale> johnw: well...
22:45:09 <ivanm> Cale: I think it might be bytestrings hClose that's throwing the error...
22:45:13 <ivanm> gentleben: the app actually _finishes_ now
22:45:18 <ivanm> and produces output
22:45:25 <LordBrain> my feeling is if i can safely not use exceptions, don't...
22:45:35 <ivanm> but I'm still getting messages on stderr rather than printed in the output file like I'm trying to get
22:45:58 <Cale> johnw: There is a way to use GADTs and existentials to do that.
22:46:01 <gentleben> ivanm: who is printing them? you?
22:46:03 <yitz> johnw: it's not compromising heterogeneity. at each point in your program, you have to decide how to describe what you have.
22:46:17 <ivanm> gentleben: I'm not printing them to stderr; I'm trying to get them printed in the generated output
22:46:20 <johnw> I thought of using existentials with a GitObject type class
22:46:29 <johnw> but then I can't know anything except what's common to all GitObjects
22:46:30 * ivanm might just fix it with an explicit check to see if dot, neato, etc. are installed at the beginning rather than trying to deal with it later
22:46:36 <Cale> johnw: There's also the possibility of factoring out the choice between different GitObject types into just a pure sum type
22:46:41 <johnw> I can't pull something out of a GitObject list, and do things with it based on whether it's a tree or not, can I?
22:46:48 <LordBrain> files and sockets force them on me, but would i make my own exceptions and handler as a general mode of programming... it feels like a mess waiting to happen, but maybe i just haven't mastered that particular art.
22:46:49 <Cale> and having separate types for GitBlob/GitTree/etc.
22:46:51 <johnw> a pure sum type?
22:46:57 <yitz> johnw: there are various techniques to be able to move between different kinds of views of your data.
22:47:25 <johnw> yitz: like what?
22:47:27 <gentleben> LordBrain: its a complication of dealing with the outside world
22:47:30 <Cale> I mean   data GitObject = Blob GitBlob | Tree GitTree | Commit GitCommit | ...
22:47:38 <johnw> ohh
22:47:42 <johnw> thats' clever
22:47:44 <Cale> (or whatever you'd like to name the constructors)
22:47:47 <johnw> didn't even think of that
22:47:54 <gentleben> ivanm: so there is still an exception escaping your handler
22:47:58 <johnw> that solves all my problems, actually
22:48:00 <ivanm> seems that way
22:48:04 <johnw> thanks!
22:48:08 <Cale> no problem
22:48:13 <ivanm> wait, I think they might be getting called elsewhere...
22:48:15 * ivanm checks
22:48:37 <LordBrain> in pure code, if i wanted to catch an exception, i would think i better put that handler way out in main or something
22:48:44 <ivanm> nope, that should be getting caught still
22:48:56 <ivanm> LordBrain: or the first IO function that would need to deal with it
22:49:04 <yitz> Cale: in the situation that johnw is describing, it often turns out to be useful to express the sum type as a GADT instead
22:49:20 <gentleben> ivanm: do you have an unhandled exception handler?
22:49:42 <ivanm> gentleben: hmmmm?
22:49:49 <Cale> yitz: I almost described that way :)
22:50:15 <Cale> yitz: But decided to give the H98 solution, because it's often just fine.
22:50:44 <LordBrain> ivanm, well you might be right, but that sounds messy, especially if there are multiple such exceptions... easier to keep track of where all that is done if its all done in one place...
22:50:59 <ivanm> OK, it seems to be 50/50 between "catch the error message and print it in the file but without the header that's meant to be added" vs "catch the error message, print the header to file but print the error message to stderr"
22:51:13 <ivanm> LordBrain: it depends on the architecture of your program
22:51:17 <LordBrain> yeah
22:51:29 <LordBrain> true
22:51:37 <gentleben> ivanm: setUncaughtExceptionHandler
22:51:49 <gentleben> its in GHC.Conc.Sync
22:52:01 <ivanm> nope, never heard of that before
22:52:17 <ivanm> huh, it's in OldException but not new...
22:52:24 <gentleben> I believe it only calls it if there is an exception that is going to tear down your app
22:52:27 <ivanm> it's also in GHC.Conc
22:52:56 <ivanm> and there's a complete lack of documentation about it...
22:53:46 <gentleben> ivanm: yeah. there is. we use it in all our apps. although we have it hooked to a centralized reporting mechanism so we can track app crashes
22:53:48 <spark_> johnw: did that explain something?
22:53:58 <ivanm> gentleben: *nod*
22:54:18 <ivanm> I might just go back to looking at detecting whether dot/neato are installed at the beginning of the app
22:54:47 <ivanm> makes more sense than trying to be clever about detecting it each time I try to call it, with 50 million such error messages :p
22:54:49 <gentleben> ivanm: having not seen your code there is probably an exception escaping your handler
22:55:31 <ivanm> if you want to see my code, it's a combination of graphviz & Data.Graph.Analysis.Reporting in Graphalyze on hackage
22:55:32 <gentleben> there is a thunk created and the catch frame is being unwound before it is evalutated
22:55:41 <ivanm> (being called from SourceGraph)
22:55:46 <ivanm> gentleben: yeah, that's my guess
22:56:34 <gentleben> i have not used those
22:56:47 <gentleben> however there are a could of ways around this
22:57:10 <gentleben> 1 know where the evaluation will happen and catch there
22:57:34 <gentleben> 2 know that something will be a thunk and get the catch inside of it
22:57:54 <gentleben> 3 use nfdata and rnf to force evaluation inside the catch
22:58:38 <spark_> inside a Parser  i have a x <- Ap.Decimal, and i want  to aply a function in x
22:59:19 <spark_> how to lift the function?
22:59:43 <LordBrain> if you are inside the do block with x, you could just say f x
22:59:55 <LordBrain> but you coud do x <- fmap f Ap.Decimal
23:00:31 <LordBrain> or liftM
23:00:50 <LordBrain> sorry if i am telling you stuff you know already, maybe i missunderstand the question
23:01:15 <Enigmagic> gentleben: setUncaughtExceptionHandler catches any uncaught exception... only uncaught exceptions on the main thread tear down the app, uncaught exceptions on a non-main thread are silently discarded by default.
23:01:24 <spark_> maybe thats exactly what i need
23:01:56 <spark_> LordBrain:  aahh didnt work
23:02:00 <spark_> neither did liftm
23:02:06 <gentleben> Enigmagic: that is correct. we use our own version of forkIO to ensure that the exception is not swallowed
23:02:56 <LordBrain> well that's how you lift a function, maybe the types are not right tho, what is the type of x? been a while since i parseced
23:03:14 <spark_> x is an int
23:03:38 <LordBrain> what is f?
23:03:45 <gentleben> ivanm: is your app multithreaded?
23:04:03 <LordBrain> what's your error, better yet
23:04:04 <spark_> LordBrain:  int-> int
23:04:19 <spark_> x <- Ap.decimal
23:04:22 <spark_> on the parser block
23:04:39 <LordBrain> you get a type error right?
23:04:46 <spark_> that works
23:04:55 <LordBrain> what works?
23:04:56 <spark_> but i want to aply a int to int function on x
23:04:59 <spark_> x <- Ap.decimal
23:05:04 <spark_> but i want (f x )
23:05:26 <LordBrain> you should be able to do x <- fmap f Ap.decimal
23:05:32 <LordBrain> or
23:05:37 <LordBrain> on the next line
23:05:40 <LordBrain> let y = f x
23:05:48 <spark_> ill try the let
23:05:48 <spark_> fmap didnt work
23:06:02 <LordBrain> well what is the compiler error?
23:06:29 <spark_>     Ambiguous type variable `a0' in the constraints:
23:06:43 <LordBrain> go on
23:06:44 <spark_>     Ambiguous type variable `a0' in the constraints:
23:07:24 <hpaste> spark_ pasted “compile error” at http://hpaste.org/73877
23:07:27 <LordBrain> if the fmap didnt work, the let wont likely work either.  Let's see more of the error message
23:07:29 <spark_> LordBrain: posted
23:09:10 <LordBrain> do you have a type signature on the decimal function?
23:09:21 <spark_> no
23:09:33 <Enigmagic> spark_: add a type signature to aToG, something like aToG :: Int -> Int
23:09:38 <LordBrain> actually, try (x::int)
23:09:52 <spark_> where?
23:09:52 <LordBrain> or yes what Enigmagic said
23:09:55 <spark_> (x::int) <-
23:09:55 <spark_> ?
23:10:11 <LordBrain> Enigmagic's solution is better
23:10:21 <LordBrain> put Int -> Int on aToG
23:11:01 <LordBrain> unless you want to keep it polymorphic
23:11:10 <LordBrain> you should be able to
23:11:32 <spark_> aaaaaaaaaand compiled
23:11:37 <spark_> thanks
23:11:47 <spark_> fuck, I expected ghc to determine all type signatures
23:11:51 <LordBrain> try x <- fmap (aToG::Int->Int) Ap.decimal
23:12:14 <spark_> I think it would complain about scoped type declarations
23:12:21 <Enigmagic> spark_: if you enable -XNoMonomorphismRestriction it would have compiled...
23:12:48 <Enigmagic> well, maybe not
23:12:52 <LordBrain> which function got restricted?
23:13:03 <Enigmagic> it's just ambiguous
23:13:14 <Enigmagic> too much coding today
23:13:15 <Enigmagic> :(
23:15:33 <LordBrain> he should be albe to keep aToG main polymorphic
23:15:51 <Enigmagic> yeah
23:16:13 <spark_> LordBrain: aToG
23:16:27 <spark_> LordBrain: didnt try to make it quoted inside
23:16:42 <LordBrain> spark_, i was asking Enigmagic what got restricted, aToG actually wouldn't have been affected by MonomorphismRestriction
23:16:55 <spark_> LordBrain: ahhh
23:17:00 <LordBrain> it has a parameter
23:17:20 <spark_> LordBrain: welll, now my program uses more memory than before o.O
23:17:23 <LordBrain> if you write your function declarations with parameters they never get the monomorphism restriction
23:18:04 <LordBrain> although, local let binds are now all defaulting to monomorphic i guess
23:18:18 <Enigmagic> since 7.0
23:24:12 <LordBrain> from what i understand, top level  binds aren't affected, but what the heck is a top level let bind?
23:24:47 <LordBrain> if local let binds are affected, how is that different from all let binds?
23:25:28 <LordBrain> and if it is the same, why does he say local
23:26:29 <LordBrain> there must be such a thing as a global let bind
23:26:54 <yitz> LordBrain: module Foo where ....[top level binds]...
23:27:11 <LordBrain> but those never have "let"
23:27:16 <RahulRam> Hello Fello Haskell programmers
23:27:17 <yitz> right
23:27:25 <LordBrain> are they translated to let inside the intermediate language?
23:27:48 <yitz> let and where binds are identical. they just scope differently.
23:27:58 <LordBrain> splj made it sound like there was some kind of global let
23:28:16 <LordBrain> maybe i missunderstood him tho
23:28:26 <yitz> splj?
23:28:32 <LordBrain> i mean simon peyton jones
23:28:42 <yitz> hi RahulRam
23:28:44 <LordBrain> not sure why there is an l
23:29:06 <LordBrain> i just know i see that l when he shortens to initials
23:29:18 <johnw> how does one read "the next integer" as an Int efficiently with Attoparsec?
23:29:25 <johnw> I can't imagine it involves read . unpack
23:29:29 <yitz> LordBrain: he's know as spj around here
23:29:32 <yitz> *known
23:29:45 <RahulRam> hey yitz , is there docmentation on linking C++ programs with Haskell ?
23:29:45 <johnw> @lastseen spj
23:29:45 <lambdabot> Unknown command, try @list
23:29:47 <yitz> johnw: decimal
23:29:52 <LordBrain> it might habe been slpj
23:30:20 <LordBrain> RahulRam, you want the ffi
23:30:30 <LordBrain> foreign function interface
23:30:36 <johnw> where is decimal from?
23:30:53 <yitz> RahulRam: i think there is a wiki article about it on haskell.org
23:31:30 <johnw> ah, Char8
23:31:38 <shachaf> Don't use Char8. :-(
23:31:43 <yitz> RahulRam: usually your best bet is to use a C wrapper and then just use regualar ffi.
23:31:56 <shachaf> Well, maybe it's justifiable for that...
23:32:02 <LordBrain> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
23:32:12 <johnw> it's in ByteString.Char8, or Text
23:32:14 <LordBrain> there also some wikis and things
23:32:16 <johnw> but it's not in plain ByteString
23:32:19 <yitz> johnw: also Text. which is what you really should be using, probably.
23:32:28 <johnw> i'm parsing data that could be raw
23:32:35 <johnw> so I'm just using ByteString
23:32:42 <yitz> johnw: oh you want to parse a binary int?
23:32:50 <johnw> I want to parse, say "18\n"
23:32:57 <LordBrain> there are some c++ specific tools too i think
23:33:08 <yitz> ah so text. you have that interspersed with binary gook?
23:33:08 <shachaf> You mean [49,56,10]?
23:33:19 <johnw> shachaf: exactly
23:33:24 <shachaf> "18\n" is a sequence of characters.
23:34:02 <yitz> johnw: if so, then i guess you're stuck with Char8.
23:34:22 <johnw> I can just using Char8.Decimal in the midst of parsing my ByteString, right?
23:34:29 <yitz> yes
23:35:18 <yitz> johnw: people refer to him as "spj". but i don't think i've ever seen him on irc, under any nick.
23:35:28 <shachaf> preflex: seen simonpj
23:35:28 <preflex>  simonpj was last seen on #ghc 3 years, 353 days, 15 hours, 27 minutes and 48 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
23:35:41 <shachaf> Been a while.
23:35:47 <LordBrain> i think in comments he signs it splj
23:36:39 <LordBrain> lol
23:36:46 <LordBrain> just went out for a moment
23:37:38 <LordBrain> aha it is slpj
23:38:12 <LordBrain> on some publications too he says "SL Peyton Jones"
23:39:01 <startling> "Sorry went away for a moment."
23:39:12 <startling> see you again in four years!
23:39:19 <spark_> back, closed my browser without wanting
23:40:34 <LordBrain> hmm it seems like he had an L in there in the 90s and it seemed to fall off in the 00s
23:40:41 <Jafet> The phd ratio in this channel is high enough already
23:41:47 <shachaf> Is the phd ratio in a database company a measure of its acidity?
23:42:44 <thirsteh> shachaf: yes
23:42:54 <thirsteh> at least the opposite is true
23:43:36 <thirsteh> how many Ph.Ds does Michael Stonebraker have?
23:44:29 <LordBrain> oh i see, the MonoLocalBinds only gets turned on with TypeFamilies or GADTs
23:45:31 <LordBrain> in 7.2 on
23:45:45 <LordBrain> 7.0 maybe was more severe
23:52:05 <johnw> hmm.. importing ByteString.Char8 is changing the behavior of Data.Attoparsec.  Now AP.take returns BC.ByteString, instead of ByteString
23:52:12 <johnw> even though I'm doing the import qualified
23:52:14 <shachaf> It's the same type.
23:52:24 <johnw> that's not what the type checker is saying
23:52:25 <shachaf> GHC is just picking a different name for it.
23:52:34 <shachaf> Pass it a "regular" ByteString and it'll be the same thing.
23:52:37 <johnw> Couldn't match expected type `BC.ByteString' with actual type `ByteString'
23:52:43 <visof> Hello
23:52:48 <johnw> oh, this is a laziness thing
23:53:10 <johnw> i always get bit by this...
23:54:03 <spark_> I have a parser that works on one line, how do i make it work on multiples?
23:54:13 <johnw> many1?
23:54:16 <Cale> johnw: Is it? Data.ByteString.Char8 re-exports the same ByteString that Data.ByteString does, and Data.ByteString.Lazy.Char8 re-exports the same one as Data.ByteString.Lazy
23:54:58 <spark_> johnw:  right now i have contents <- liftM ((map ( readExpr )) . B.lines) $ B.readFile filename
23:55:05 <spark_> johnw:  but im trying to take out the map D:
23:55:17 <johnw> just take out the B.lines too
23:55:24 <johnw> have Attoparsec read across lines
23:55:28 <spark_> how?
23:55:49 <visof> Can Haskell replace any programming language? Also what do you think about go language compared to haskell?
23:55:50 <johnw> parse <* parse <* parse <* satisfy (== 10)
23:56:05 <johnw> many1 (parse <* parse <* parse <* satisfy (== 10))
23:56:11 <johnw> will read all the lines in your file
23:56:19 <spark_> wait, why 3 parse?
23:56:24 <johnw> that was just an example
23:56:30 <spark_> ahh ok
23:56:30 <johnw> put your own parsers in there
23:56:40 <spark_> will it return a list?
23:56:53 <johnw> yep
23:58:00 <startling> visof: turing equivalence yo
23:58:27 <donri> ask edwardk about haskell vs go ;)
23:58:33 <startling> visof: I like haskell much more than Go but I never got into Go very much
23:59:00 <Cale> visof: Go is more or less a language from the 1960's. At least, there's nothing in it as far as I've seen which would be out of place in a language from that era.
23:59:16 <Cale> visof: Haskell is significantly more modern than that.
23:59:22 <Enigmagic> tell us how you really feel
23:59:47 <shachaf> Modern, mo' problems.
