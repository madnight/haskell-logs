00:00:09 <apeschel> postscript is for printers, not computers
00:00:35 <shachaf> TWIST: printers are computers
00:00:36 <ion> Postscript is for programmers who like RPN
00:00:52 <yitz> ion: no. first you have to turn everything into simple loops. then you can read about DPH and find out why you were wrong.
00:01:22 <n00b6502> yes, simple loops with no memory operations inside them
00:02:22 <mm_freak> anyway, you can't do any further optimizations once you have reached the assembler level
00:02:23 <n00b6502> if it can generate GPU code .. it can geneate that too
00:02:36 <mm_freak> and STG is also not the compilation strategy to use for GPUs
00:03:01 <mm_freak> that's why GPU stuff is usually a DSL in haskell
00:03:06 <mm_freak> instead of a haskell compiler
00:03:08 <n00b6502> we have 256 bit simd now dont we
00:04:51 <apeschel> mm_freak: I've heard rumors that Intel has some unpublished instructions that they use in their compiler for a slight speed boost
00:05:02 <apeschel> You would have to go to bytecode for that
00:05:29 <mm_freak> apeschel: sure, but those would be micro-optimizations, not structural ones
00:06:50 <ion> http://hackage.haskell.org/trac/ghc/wiki/SIMD
00:08:11 <n00b6502> this would be really interesting
00:08:25 <n00b6502> modern x86 also has 8element simd
00:08:59 <dmwit> Have you actually written any Haskell code yet?
00:09:17 <n00b6502> only trivial, i've made it draw something
00:09:38 <apeschel> That is a funny use for Haskell
00:09:43 <dmwit> Write more code.
00:10:32 <n00b6502> is haskell suitable for writing somethign like a physics engine...
00:12:12 <n00b6502> to use SIMD you have to refactor algorithms to run on arrays
00:12:17 <Enigmagic> @faq is haskell suitable for writing  a physics engine
00:12:18 <lambdabot> The answer is: Yes! Haskell can do that.
00:12:39 <n00b6502> because SIMD can't use anything else
00:12:51 <Enigmagic> n00b6502: go look at repa/accelerate and the vector work people are doing for ghc
00:13:04 <n00b6502> sounds interesting
00:13:27 <Enigmagic> llvm++
00:13:35 <apeschel> False: Fortran is the only suitable language for writing a physics engine.
00:13:50 <Enigmagic> i'm writing one in javascript
00:14:35 <dmwit> Start writing a physics engine. Find a concrete problem that's too slow.
00:14:41 <dmwit> Then start fixing it.
00:14:59 <dmwit> Don't fix a hypothetical problem that you think might happen maybe some time in the future possibly if you ever got around to actually writing any damn code.
00:15:06 <ion> No, start writing an implementation of a Haskell compiler that generates short loops first.
00:15:20 <apeschel> Use FORTRAN
00:15:27 <n00b6502> you need such loops if you want to use SIMD instructions
00:15:35 <ion> Write a Haskell compiler that outputs FORTRAN.
00:15:52 <Enigmagic> how about a Haskell DSL for FORTRAN? :o
00:16:21 <ion> How about a DSL that embeds FORTRAN in Haskell?
00:16:41 <apeschel> ion: Via punchcard notation
00:17:34 <Enigmagic> ion: MonadFORTRAN? :(
00:17:38 <Ralith> I ported a 2D physics engine to common lisp a while ago
00:17:42 <Ralith> it worked well enough
00:18:03 <shachaf> ion: Short loops? I thought simple loops were the key.
00:18:03 <tdammers> what was it originally written in? scheme?
00:18:21 <apeschel> tdammers: It's 'Racket' now
00:18:37 <n00b6502> simple loops without much pointer chasing and branching, yes
00:18:48 <tdammers> there's more to scheme than racket
00:18:56 <frerich> Hm, if only I had known about Graphics.Gloss earlier. So many text-mode games could've benefitted from some.... chromatic exuberance.
00:19:00 <n00b6502> the sort that can be unrolled because each iteration is independent
00:20:29 <tdammers> I thought the key to such loops was that you could unroll them by iterating at compile time
00:20:47 * tdammers hasn't been listening enough to make any qualified statements
00:20:50 <n00b6502> correct
00:21:20 <tdammers> so, excuse the C, for (i = 0; i < 10; ++i) would be OK, but for (i = 0; i < j; ++i) would not
00:21:40 <n00b6502> blocks of code within which the compiler can allocate registers effectively
00:21:52 <shachaf> Why is this in #haskell again?
00:21:53 <n00b6502> yes
00:22:18 <tdammers> shachaf: because haskell is the tool you'd use to implement a compiler? :P
00:22:41 <n00b6502> we're talking about if haskell can do the same job as C
00:22:45 <dolio> Vector processors execute maps over vectors.
00:22:50 <n00b6502> correct
00:22:54 <dolio> Maps.
00:23:05 <shachaf> Scalar processors execute maps over scalars.
00:23:12 <dolio> That's why you need to put qualifiers on your 'loops' thing.
00:23:24 <n00b6502> scalar processors are so pipelined that vector techniques work on them
00:23:28 <Axman6> n00b6502: sure it can. it already can take advantage of vector operations using LLVM and things like Repa can get those advantages I beleive
00:23:30 <mm_freak> @tell edwardk are you going to add FreeT to your 'free' library?  the one from transformers-free is awful, and FreeT would finally help me get rid of monad-coroutine dependency =)
00:23:31 <lambdabot> Consider it noted.
00:23:57 <ion> tdammers: Well, https://en.wikipedia.org/wiki/Duff%27s_device
00:24:28 <dolio> People actually write code with map in Haskell frequently.
00:24:29 <Axman6> plus we've got an LLVM monad which gives you access to runtime code generation, which allows you to implement these things yourself if wanted, and produce functions that are native Haskell functions
00:24:43 <dolio> And people don't write map in C, because it's a pain in the ass.
00:24:52 <dolio> So they need the compiler to compile their loops to maps.
00:25:02 <n00b6502> you need to 'think' in termps of maps to write fast C
00:25:14 <dolio> And now you want Haskell compilers to compile maps to C loops so they can be compiled back to maps.
00:25:34 <n00b6502> to qualify further, what I mean is loops where each iteration of the loop body is not dependant on the previous
00:25:53 <SebastienGllmt> Is there something wrong with doing func :: ([x], Int) -> x
00:25:59 <SebastienGllmt> it feels too non-Haskell to be correct
00:26:01 <danharaj> mm_freak: what's wrong with the one in transformers-free?
00:26:03 <SebastienGllmt> I mean it gives me the right output
00:26:13 <Axman6> SebastienGllmt: it's not a total functrion
00:26:16 <tdammers> ion: holy crap, that is *nasty*
00:26:17 <Axman6> function*
00:26:21 <n00b6502> dolio: i want to see what operations are being strung together
00:26:34 <ion> tdammers: Not really when you let your compiler do that for you.
00:26:35 <n00b6502> it will look like the body of a loop
00:26:57 <SebastienGllmt> What do you mean not a total function?
00:27:17 <Axman6> if you give it ([],1) it can't possibly return an x
00:27:18 <ion> sebastiengllmt: Not implicitly, but you lose the ability to use partial application directly.
00:27:29 <tdammers> Axman6: why not?
00:27:33 <shachaf> Axman6: What?
00:27:39 <shachaf> Oh.
00:27:41 <latro`a> it *can*, but not in a natural way, meaning that it won't work polymorphically
00:27:44 <Axman6> ...
00:27:44 <tdammers> func ([], _) = 23
00:27:52 * shachaf reads further up.
00:27:54 <latro`a> tdammers--can't work polymorphically
00:27:55 <Axman6> tdammers: no...
00:27:56 <ion> sebastiengllmt: (I was only referring to the currying, Axman6’s comment stands.)
00:28:10 <tdammers> latro`a: true.
00:28:16 <Axman6> tdammers: that obviously doesn't work if x is String for example
00:36:50 <n00b6502> The most important four registers are the BaseReg, the stack pointer (Sp), the heap pointer (Hp), and the general purpose register R1 which is used for intermediate values, as well as for returning evaluated values when unwinding the stack. These are the four registers which are assigned actual processor registers when implementing the STG machine on x86.
00:36:56 <n00b6502> from some doc..
00:37:06 <n00b6502> does it use 16regs in x86-64
00:37:12 <n00b6502> 64bit mode
00:37:45 <Enigmagic> i bet google knows
00:38:03 <n00b6502> ah it does
00:47:03 <SebastienGllmt> http://ideone.com/c4tWc
00:47:12 <SebastienGllmt> Is there a way to do the x==reverse x
00:47:26 <SebastienGllmt> or do I have to assign it to another variable then compare
00:47:28 <mm_freak> @tell danharaj all the nice instances from 'free' are missing…  edwardk is like me in this regard…  a library is never ready for release when basic instances are missing, like Monad, but no Functor and no Applicative
00:47:28 <lambdabot> Consider it noted.
00:47:30 <SebastienGllmt> or something like that
00:47:40 <ion> Yes, x==reverse x
00:47:45 <latro`a> why the do
00:47:48 <latro`a> there's no monad
00:47:53 <SebastienGllmt> I was trying stuff
00:48:06 <SebastienGllmt> x==reverse x returns an error though
00:48:13 <latro`a> shouldn't
00:48:22 <dmwit> SebastienGllmt: Your type signature is too restrictive.
00:48:30 <latro`a> ah
00:48:31 <latro`a> so it is
00:48:40 <dmwit> SebastienGllmt: You must add an Eq x constraint, so that you can compare list elements for equality.
00:48:41 <adnam> it should, there's no way for it to know that it can compare elements in x
00:48:45 <ion> Or too liberal from another point of view :-P
00:48:54 <dmwit> SebastienGllmt: func :: Eq x => [x] -> Bool; func x = x == reverse x
00:49:19 <dmwit> Yes, too restrictive on the implementation, too liberal on the inputs it accepts.
00:49:25 <tdammers> ?type \x -> x == reverse x
00:49:27 <lambdabot> forall a. (Eq a) => [a] -> Bool
00:49:29 <dmwit> s/accepts/claims to accept/
00:50:16 <SebastienGllmt> What does Eq x => [x] do exactly..?
00:50:33 <tdammers> demand that the type x be a member of typeclass Eq
00:51:05 <tdammers> you can only compare lists for equality if their element type is also equality-comparable
00:51:05 <adnam> ... which means you can call ==
00:51:30 <dmwit> SebastienGllmt: Exactly: it passes the function "(==) :: x -> x -> Bool" as an implicit parameter to the function.
00:51:55 <dmwit> In this case, that then constructs another function "(==) :: [x] -> [x] -> Bool" to use when writing "x == reverse x".
00:52:15 <dmwit> ?src Eq
00:52:16 <lambdabot> class  Eq a  where
00:52:16 <lambdabot>     (==), (/=)   :: a -> a -> Bool
01:02:51 <quicksilver> dmwit: that's an implementation choice, I don't necessarily think it's the most helpful way to understand the constraint. It certainly isn't "exactly" true because no implementation is forced to do that.
01:15:21 <dmwit> > 163.6/3
01:15:23 <lambdabot>   54.53333333333333
01:25:01 <hpaste> hov pasted “happstack overloaded strings” at http://hpaste.org/73150
01:30:17 <hpaste> hov annotated “happstack overloaded strings” with “happstack overloaded strings (annotation)” at http://hpaste.org/73150#a73151
01:33:31 <mm_freak> ok, i just implemented StateT in terms of Free (i.e. not FreeT)
01:33:37 <mm_freak> but it's really inconvenient
01:40:07 <ion> I’d like to see the sauce out of curiosity.
01:44:59 <srhb> I caught half a conversation in the hallway at uni recently -- what is meant when people say "writing Haskell in Agda"? Haskell compiler, or the actual language?
01:45:24 <c_wraith> neither
01:45:29 <srhb> Baw.
01:45:33 <c_wraith> It means "using agda as if it was haskell"
01:45:40 <shachaf> Probably something like "writing C in Haskell".
01:45:53 <srhb> Is that possible? I suppose without actually having the features of Haskell (and indeed, Hackage)
01:45:54 <danr> c_wraith: srhb: yeah, typically by turning off the termination checker
01:46:21 <danr> (and allowing type in type, and disabling the positivity checker)
01:46:27 <dmwit> Personally, my favorite programming mode is to write perl in brainfuck.
01:46:41 <merijn> ASM in python \o/
01:46:43 <srhb> dmwit: While on acid?
01:46:48 <srhb> >_<
01:46:52 <dmwit> ^_^
01:46:58 <sp3ctum> :3
01:47:40 <srhb> So my vague intuition of this meaning "Agda as a Haskell-generator" or "Haskell, but dependently typed" was entirely wrong.
01:48:16 <frerich> srhb: In my experience it's usually used in a derogative sense. Similiar to, say, 'Speaking english with german grammar'. Having the wrong mindset (the mindset of another language) when using some particular language, so the expressions are awkward at best.
01:48:20 <hpaste> sp3ctum pasted “nyan cat lyrics” at http://hpaste.org/73152
01:48:27 <srhb> Right, okay.
01:48:33 <shachaf> srhb: Were they speaking in Danish?
01:48:53 <srhb> shachaf: Yes, so I'm afraid anything is possible. After all, we rarely even understand each other in casual conversation.
01:49:08 <srhb> :-)
01:49:21 <shachaf> "writing Haskell in Agda" is an English idiom -- maybe they meant generating Haskell code from Agda.
01:49:39 <shachaf> Which is also a thing people do, I think.
01:50:16 <dmwit> sp3ctum: You got it wrong, by the way. The lyrics say "meow"...
01:50:28 <latro`a> um
01:50:28 <latro`a> no?
01:50:32 <latro`a> very much no, lol
01:50:50 <sp3ctum> dmwit, it's only a draft :)
01:51:53 <dmwit> "very much no"? Take a listen, and keep in mind the human mind's bias towards unifying what it hears and reads, as evidenced by the very popular "translation" videos of foreign songs.
01:53:18 <merijn> It is nyan, but OTOH nyan is the Japanese transliteration of a cat meowing :)
01:53:30 <latro`a> ^
01:53:38 <latro`a> it's definitely a nasal sound
01:53:40 <dmwit> That is a backsplanation.
01:53:40 <shachaf> ==merijn
01:53:41 <latro`a> but that's japanese
01:53:49 <merijn> dmwit: Eh, why?
01:54:03 <dmwit> It is meow, sped-up.
01:54:09 <srhb> http://www.youtube.com/watch?v=vIglHv0Vg1g
01:54:20 <srhb> slowed down.
01:54:32 <sp3ctum> challenge unlocked: distract #haskell discussion with nyan cat
01:54:32 <dmwit> You can hear the o-w glide in the slow version.
01:54:37 <shachaf> Hmm.
01:54:39 <dmwit> Something that you very don't get when saying nyan.
01:54:55 <latro`a> still not hearing an n
01:55:01 <latro`a> erm
01:55:01 <latro`a> m
01:55:04 <srhb> I agree, it is meow.
01:55:04 <dmwit> That is because there is no n. =)
01:55:08 <latro`a> definitely hearing an n, is what I meant
01:55:11 <srhb> latro`a: Even your subconscious agrees.
01:55:13 <merijn> dmwit: Why would a Japanese video use "meow"?
01:55:13 <latro`a> (sorry, nearly 5 am -_-)
01:55:20 <merijn> <-- hearing an n too, btw
01:55:21 <dmwit> It is not a Japanese video.
01:55:59 <merijn> Ok that I don't honestly know, but the voice software it uses is
01:56:33 <merijn> dmwit: Wikipedia disagrees with you
01:56:36 <merijn> The original version of the song "Nyanyanyanyanyanyanya!" was uploaded by user "daniwell"[4] to the Japanese video site Nico Nico Douga on July 25
01:56:47 <merijn> The song features the Vocaloid Hatsune Miku (初音ミク?). The Japanese word for the sound cats make, "nyā" (にゃ?), is the equivalent of the English language word "meow".[1]
01:57:13 <merijn> A user named "Momo Momo" ("もももも") uploaded a remixed version of the song "Nyanyanyanyanyanyanya!", adding the repeating vocal sound "nyan" throughout the song, to Nico Nico Douga on January 31, 2011.
01:57:16 <n00b6502> ok where's the paper on the stg machine again.. the one i'm currently looking at talks about x86 with few registers and says x64/16reg implementation is very different... thats the one i need to read about
01:57:29 <dmwit> You're right.
01:57:29 <shachaf> @where stg
01:57:30 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
01:57:44 * shachaf doesn't know what to believe anymore!
01:57:50 <shachaf> Except that we're in the wrong channel, that is.
01:58:03 <merijn> shachaf: But how can it be wrong if it feels so right? :D
01:58:17 <typoclass> what's wrong? what's not to be believed?
01:58:20 <typoclass> (just came in)
01:58:23 <srhb> We need a japanese speaker to say nyan, obviously.
01:58:25 <shachaf> typoclass: The cats.
01:58:34 <hpaste> trem pasted “GTK / Gstreamer” at http://hpaste.org/73153
01:58:39 <trem_> is here someone knowledable about the GTK / Gstreamer bindings? I'm having "schedule: re-entered unsafely" problems, but don't know what I'm doing wrong.
01:58:41 <shachaf> #haskell is a no-cat zone.
01:58:45 <srhb> :(
01:59:12 <merijn> typoclass: We had a discussion whether the text in nyan-cat was "nyan" or "meow", but I think the argument just got definitively settled in favour of "nyan", courtesy of wikipedia
01:59:12 <typoclass> shachaf: that's a minority opinion
01:59:19 <ion> shachaf: “My cat used to shit on the floor. I would push his nose into it and then throw him out through the window. After a week, he was trained. He would shit on the floor, stick his nose into it and then jump out through the window.”
01:59:25 <merijn> #haskell is totally a cat zone
01:59:29 <merijn> @where lambdacats
01:59:29 <lambdabot> http://lambdacats.org
01:59:40 <shachaf> ion: :-(
01:59:53 <srhb> http://codereview.stackexchange.com/questions/14616/rewrite-of-sokoban-using-state -- I feel that I lose all of the advantages of State and lenses with boilerplate. If anyone fancies to take a look, perhaps there's an obvious way to generalize some code here.
02:00:22 <typoclass> merijn: i see. i distinctly remember that we had exactly that discussion a few weeks ago
02:01:21 <trem_> the problem seems to be related to the GTK.on signal handler starting on line 72, if i take it out GHC runtime does not complain. but I get no video playing either.
02:02:27 <shachaf> srhb: Looks like you can abstract all those things pretty easily?
02:03:31 <srhb> shachaf: I'm probably just not seeing it. It may just be horrible design :P
02:03:35 <dmwit> trem_: Hm. Does the demux signal get sent more than once? Do you really want to link those things more than once?
02:03:46 <dmwit> <- definitively not a gstreamer expert
02:03:51 <srhb> i want caseM :: m Bool -> ...
02:03:52 <srhb> :P
02:04:53 <shachaf> srhb: If you hpaste something that compiles people will probably annotate it for you.
02:05:11 <srhb> It does compile. It should compile.
02:05:14 <srhb> :P
02:05:17 * srhb is now uncertain
02:05:30 <trem_> dmwit, the "no more pads" signal should be sent only once, the is also a "pad added" signal which can be emitted more than once. is it a problem if a signal handler runs more than once?
02:05:32 <shachaf> Oh, wait, you did.
02:05:35 <shachaf> I just saw the snippets.
02:05:49 <srhb> Ah, ok :-) I got a little scared there.
02:06:02 <trem_> dmwit, the "elementLink" should be a no-op for already linked elements anyway. if I understood it correctly.
02:06:13 <shachaf> Hmm, it doesn't compile here.
02:06:24 <quicksilver> srhb: I think part of your problem is that your data model is wrong.
02:06:24 <srhb> What.
02:06:34 <srhb> quicksilver: Yes, I suspected as much. keep everything in one map perhaps?
02:06:54 <srhb> But then i would need a data type that encodes WorkerOnStorage or CrateOnStorage
02:07:06 <srhb> Which would complicate the logic a bit.
02:07:12 <shachaf>     No instances for (Fractional Coord, Integral (Int, Int))
02:07:13 <quicksilver> srhb: you end checking squares via several booleans "isWall" "isCrate" etc etc where these booleans are not independent.
02:07:17 <srhb> shachaf: What.
02:07:57 <quicksilver> I would think that data Square = Empty | Crate | Worker  type affair would be better.
02:07:59 <dmwit> trem_: Okay, then I'm clueless. I can help you write a naive translation to C if you want to ask some actual gstreamer experts.
02:08:03 <dmwit> e.g. on StackOverflow
02:08:36 <srhb> shachaf: It compiles here, I don't see how that Fractional Coord comes into play
02:08:58 <srhb> quicksilver: But I thought that bit actually encoded the logic of the game nicely
02:09:10 <srhb> quicksilver: Especially the bit where a box is in front of something.
02:09:16 <srhb> Perhaps, too imperative. :/
02:10:07 <srhb> quicksilver: Square would not suffice, I would need CrateOnStorage and WorkerOnStorage as well.
02:10:10 <trem_> dmwit, so you suspect that the problem is somewhere in gstreamer? it makes heavy use of threads, afail. maybe the signal is emitted on a "wrong" thread or something?
02:10:22 <dmwit> No, I suspect the problem is in the way you are using gstreamer.
02:10:27 <quicksilver> srhb: sure it was only the beginning of an answer
02:10:38 <quicksilver> srhb: you could either add Storage as an independent Bool
02:10:49 <quicksilver> or you could add the 'OnStorage' options as you suggest.
02:10:52 <srhb> quicksilver: Right, ok, but that seems to me like it complicates manners because I would have to "restore" the floor after a movement over it
02:10:55 <srhb> Hmm.
02:11:02 <srhb> matters, not manners.
02:11:07 <srhb> (manners are complicated too)
02:11:29 <dmwit> But gstreamer experts (who are likely to be able to spot the way you're using it wrong) won't want to have to learn Haskell.
02:11:49 <trem_> dmwit, i used java bindings for gstreamer and now i'm trying with haskell. maybe i should prototype with python or something which is well-supported in gstreamer land then.
02:11:51 <srhb> I suppose I could keep my data model but add the Square thingy on top and check squareKind instead of isWall and friends.
02:11:59 <trem_> dmwit, thanks for having a look!
02:12:00 <srhb> That might actually be the way to go...
02:12:13 <quicksilver> yes
02:12:16 <quicksilver> I should be clearer
02:12:28 <quicksilver> the actual data model doesn't matter (only for performance perhaps)
02:12:33 <srhb> Right.
02:12:43 <quicksilver> but your API is clumsy as checking repeated Bools which aren't really independent feels messy
02:12:53 <srhb> Yes, agreed.
02:13:08 <quicksilver> to be honest I also don't think your code is as bad as you seem to think it is :)
02:13:16 <srhb> That's a relief :-)
02:13:26 <srhb> But thanks a lot for the feedback, I'll try to do as you suggested.
02:13:32 <quicksilver> I don't see anything at all wrong with setMaxCoords for example
02:13:44 <srhb> Oh, it's just so verbose.
02:13:51 <srhb> And a lot of repeated code.
02:14:01 <shachaf> quicksilver: Really? It looks very redundant to me.
02:14:15 <quicksilver> well there are certainly other ways you can write it
02:14:22 <quicksilver> depending which repetition offends you
02:14:28 <quicksilver> you don't have to use the 'uses' idiom if it annoys you :)
02:14:31 <srhb> the <-s bit especially
02:15:09 <quicksilver> you could just fetch walls, crates and storage once
02:15:25 <quicksilver> and then inline the maximum/minimum finding into the result lists
02:15:45 <srhb> I feel like I should be able to map those folds over all the relevant lenses
02:16:15 <typoclass> @hoogle uses
02:16:16 <lambdabot> No results found
02:16:20 <typoclass> what witchcraft is this?
02:16:25 <srhb> Control.Lens
02:17:19 <typoclass> thanks
02:18:34 <shachaf> srhb: What version of lens are you using?
02:18:58 <srhb> shachaf: ekmetts lens. Um, how do I get the version? I just installed it like yesterday from cabal.
02:19:03 <shachaf> ghc-pkg list
02:19:19 <dmwit> ghc-pkg list lens is more specific
02:19:22 <srhb>     lens-1.4.1
02:19:33 <shachaf> dmwit: I was partially applying ghc-pkg!
02:19:40 <srhb> :-)
02:19:50 <srhb> So I suppose that is quite old. Weird.
02:19:56 <dmwit> DID YOU KNOW that ghc-pkg list accepts package-globs?
02:20:07 <srhb> dmwit: Did not, thanks!
02:20:37 <shachaf> srhb: Oh, you're using an old version of lens.
02:20:44 <dmwit> srhb: 1.4.1 is not that old. About a week and a half old.
02:20:45 <shachaf> In the new lens, ^= means exponentiation, I guess.
02:20:57 <shachaf> Hence the fractional error.
02:21:00 <srhb> dmwit: Dear lord, how fast is he cranking out those versions?
02:21:02 <dmwit> So you can be excused. Just run cabal update and try again.
02:21:05 <srhb> shachaf: Aahh
02:21:07 <dmwit> srhb: inorite
02:21:11 <typoclass> srhb: edward has been releasing new versions about every five minutes. try "cabal update"
02:21:14 <srhb> rofl
02:24:07 <shachaf> srhb: Yes, I would say not to use Bools so much.
02:24:55 <hpaste> srhb pasted “Sokoban - now with ekmett fast forward compatibility” at http://hpaste.org/73154
02:25:22 <srhb> I like the new set operator better, too
02:25:40 <srhb> shachaf: Yeah, I should be casing off something that returns some m SquareType instead like quicksilver suggested?
02:28:39 <srhb> I lose being able to use unless though, which seems so nice..
02:30:26 <shachaf> unless?
02:30:34 <shachaf> I wouldn't use unless there anyway.
02:30:38 <srhb> Oh.
02:30:44 <shachaf> | crate && not wall' && not crate'
02:30:46 <shachaf> Or something like that.
02:31:21 <srhb> Alright. I'll have a go at a rewrite.
02:34:08 <Egbert9e9> does it make sense to map (\(idx, x) -> if idx == wantedIdx then (f x) else x) if i want to change one element in a vector?
02:34:31 <shachaf> Egbert9e9!
02:34:34 <Egbert9e9> "change" is not a good word in #haskell, I am aware
02:34:35 <Egbert9e9> hi
02:34:38 <Egbert9e9> :)
02:35:05 <Egbert9e9> you remember me O_O
02:35:22 <hpaste> typoclass annotated “Sokoban - now with ekmett fast forward compatibility” with “Sokoban - now with ekmett fast forward compatibility (annotation)” at http://hpaste.org/73154#a73155
02:35:33 <typoclass> srhb: ^^ yo
02:36:51 <srhb> typoclass: Thanks!
02:36:58 <Egbert9e9> will replicateM guarentee the order of execution?
02:37:00 <dmwit> Egbert9e9: Looks fine. You understand the performance implications? If so, get your code on, mate!
02:37:02 <Egbert9e9> for IO
02:37:03 <shachaf> I think there's probably a bigger abstraction you could have there?
02:37:35 <Egbert9e9> dmwit: actually.. performance is everything.. so nope
02:37:49 <Egbert9e9> hoped there'll be a better solution
02:38:02 <shachaf> What order is there to guarantee when all the actions are the same?
02:38:10 <typoclass> Egbert9e9: seems pretty okay to me. it's a common pattern that a function to 'change' a data structure will give you back a new data structure with the one change made
02:38:43 <Egbert9e9> shachaf: what if they get the time?
02:38:45 <dmwit> Egbert9e9: Okay, O(n) update is not okay, then lists are not for you.
02:38:49 <dmwit> Pick a better data structure.
02:38:59 <shachaf> Egbert9e9: Oh, you mean the order of the actions in the list?
02:39:04 <shachaf> s/action/result/
02:39:10 <shachaf> Yes, it'll be the same as the order they were run in.
02:39:15 <Egbert9e9> dmwit: what if i do it over a vector?
02:39:18 <dmwit> I suggest finger-trees; for example, the Seq data type.
02:39:31 <dmwit> If O(n) update of a single element is not okay, then vectors are not for you, either.
02:39:33 <Egbert9e9> dmwit: everything with the functions under Data.Vector
02:39:41 <Egbert9e9> shachaf: cool!
02:40:24 <shachaf> Egbert9e9: Is this a mutable or immutable vector?
02:40:34 <shachaf> To update an immutable vector at all you have to copy the whole thing.
02:40:53 <Egbert9e9> i guess i'll have to decide to use a mutable, then
02:40:59 <dmwit> Mutable vectors may be an alternative, yes, though I would suggest trying very hard to make sure that you really, absolutely need them before you turn to them.
02:41:10 <dmwit> Chances are good you're just missing out on the Haskell way.
02:41:13 <Egbert9e9> oh
02:41:18 <Egbert9e9> probably
02:41:57 <shachaf> ==dmwit
02:42:20 <Egbert9e9> it's similar to forest fire, except that i have to change each element according to the board resulting from the previous change
02:42:37 <Egbert9e9> different in other aspects as well
02:42:40 <dmwit> If you have to change each element, why are you changing elements one index at a time?
02:42:58 <Egbert9e9> because they're dependant on previously changed elements
02:43:06 <Egbert9e9> the decision itself
02:43:07 <dmwit> So?
02:43:14 <Egbert9e9> i'm missing on the haskell way
02:43:17 <dmwit> lern2laziness, friend!
02:44:55 <dmwit> If you can construct a piece of Haskell code that: 1. is short 2. is representative (tackles the things you think will be tricky about the real code) 3. isn't necessarily fast, just readable; THEN you will probably get some very targeted, high-quality advice from this channel.
02:45:01 <Egbert9e9> http://syntacticsalt.com/2010/08/30/forest-fire-cellular-automaton-haskell-and-matlab/
02:45:23 <dmwit> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
03:00:59 <XexonixXexillion> Does anyone know a rapid approximation (i.e constant time) method (which gives an upper bound) for factorials
03:03:01 <schlicht> So i wrote a gui with gtk2hs, and i'm using a turnstile (⊢) at somepoint in my labels. My boss uses mac, and on his mac the turnstile is kind of broken, it is there but with an rectangle afterwards. anyone an idea why? i tried \x22A2
03:05:28 <Egbert9e9> dmwit: what if I want a fast haskellian stochastic cellular automaton? (I keep using these words, but I don't think they mean what I think they mean)
03:05:52 <lizzzin> is Maybe how haskell handles 'null'?
03:06:25 <srhb> lizzzin: That's one nice way of doing it. We have no null. :-)
03:06:30 <shachaf> lizzzin: A lot of uses for null, yes.
03:06:47 <shachaf> It's not a direct correspondence but it's probably the closest thing. It's much nicer.
03:06:52 <typoclass> lizzzin: yeah, pretty much. the advantage is that in other languages it's common to accidentally forget to handle the null case, leading to all kinds of bugs, where haskell the compiler ensures you don't forget it
03:07:28 <typoclass> s/where haskell/where in haskell/
03:07:29 <shachaf> It's not just about forgetting it, it's about not having it in most places.
03:07:45 <lizzzin> woah, love haskell. ask a question and you don't get berated
03:08:30 <ion> And since we have a first-class thing for the nullness, we have standard powerful functions and operators to assist with the case where you do use it.
03:09:09 <lizzzin> so a function would return a Maybe and then you pattern match it?
03:09:18 <tdammers> that is one option, yes
03:09:35 <tdammers> but there's also a bunch of useful helper functions in Data.Maybe
03:09:38 <lizzzin> is that how most do it?
03:09:52 <lizzzin> oh ok. ill check that out
03:09:58 <tdammers> e.g., maybe, fromJust, catMaybes, etc.
03:10:09 <ion> THERE’S NO FROMJUST. THERE’S NO FROMJUST.
03:10:18 <tdammers> sorry
03:10:22 <tdammers> scrap fromJust
03:10:29 <clsmith> maybe is prelude
03:10:33 <tdammers> fromMaybe
03:10:34 <typoclass> shachaf: right. in haskell, it's clearly separated -- "this can be null, this cannot". other languages encourage you to conflate the two, and you end up skipping the null check far too often
03:10:41 <ion> (>>=) can also be useful with Maybe values.
03:10:52 <tdammers> typoclass: C# has nullable value types, and enforces them
03:11:27 <typoclass> typoclass: good to hear. they write it with a "?", don't they? it was added only a few years ago, right?
03:11:30 <clsmith> one of the nicer-than-java features
03:11:33 <tdammers> e.g. int? a = 23; int b = a;
03:11:43 <tdammers> ^ yields a type conversion error
03:11:50 <Jurily> in C#, everything and their dog can be null
03:11:58 <ion> ion: Yeah, it seems they do write it with a “?”.
03:11:58 <tdammers> you have to do b = a ?? 0; or something
03:12:11 <XexonixXexillion> null is evil
03:12:11 <tdammers> Jurily: only reference types (i.e., class instances)
03:12:28 <tdammers> (which accounts for 99% of everything you ever write)
03:12:32 <Jurily> yeah, it's not like anyone uses *those*
03:13:06 <tdammers> just saying the idea isn't unique to haskell
03:13:31 <tdammers> and it's better than, uh, PHP, or even Python
03:13:40 <lizzzin> http://stackoverflow.com/a/9894441
03:13:48 <lizzzin> that has me confused
03:14:17 <lizzzin> in scala, you would do 'something extends Show'
03:14:46 <lizzzin> this says that something is a subtype of Show. where show is some type
03:15:12 <lizzzin> so if haskell doesn't do subtyping, then what does deriving (Show) do?
03:15:29 <lizzzin> how is that read? how should i think of whats going on?
03:16:11 <Automorphism> lizzzin, Haskell type classes are nothing like classes from the object-oriented paradigm.
03:16:16 <sipa> lizzzin: types and classes are entirely separate
03:16:30 <sipa> classes are just collections of types that share some property
03:16:47 <sipa> now, some classes are very simple become a part of
03:17:06 <sipa> and deriving will make the compiler write the code to do so automatically
03:19:17 <typoclass> lizzzin: your link refers to a question about Nothing and Just. about that, you have to remember that it's defined like "data Maybe a = Nothing | Just a". this means Maybe is a name at the type level (it can show up to the right of "::"), while Nothing and Just are at the value level and cannot be on the right side of "::". hence the output "Nothing :: Maybe a" that you saw
03:19:25 <Jurily> lizzzin: think interfaces from other languages
03:19:29 <Jurily> like Go or Java
03:19:40 <quicksilver> although, don't think interfaces for more than a minute or two
03:19:44 <Automorphism> Jurily: That is an awful analogy.
03:19:45 <quicksilver> it's not the best analogy
03:19:55 <quicksilver> it's better than subtyping
03:20:25 <lizzzin> Jurily: i dont know java or go. but ive read that they are like scalas traits, which seems to not be similar to haskell way
03:20:34 <Automorphism> A type class is a contract, an API, that can be implemented for multiple types in various ways, while respecting the general type signatures established by the contract.
03:20:47 <xkb> Is it possible to install multiple versions of a lib using cabal?
03:20:54 <Athas> xkb: yes.
03:21:11 <xkb> do I need a specific flag for that?
03:21:21 <Automorphism> lizzzin: The best way to understand type classes is in terms of themselves.
03:21:25 <Athas> No, just do cabal install foopkg-x.y
03:21:35 <xkb> I tried using cabal install warp-1.2.2 (where I have a newer one present)
03:21:43 <Automorphism> lizzzin: Haskell is too different from most other languages for analogies to be useful.
03:21:52 <xkb> and it says this might break some existing project
03:22:14 <typoclass> Automorphism: if you do s/type class/java interface/, your explanation works very well
03:22:19 <lizzzin> Automorphism: ill have to keep that in mind
03:22:28 <ion> lizzzin: Dunno if this is more confusing than helpful, but in GHC’s implementation type classes (“class Show a where show :: a -> String”) compile to struct-like types (“data Show a = Show { show :: a -> String }”). Instances (implementations of those classes; “instance Show Integer where show = integerToString”) compile to dictionaries with an according type (“showInteger :: Show Integer;
03:22:30 <Automorphism> lizzzin: Do you know how dynamic dispatch is implemented in object-oriented languages? (vtables)
03:22:30 <ion> showInteger = Show { show = integerToString }”). Values that have a type constraint (“showReverse :: Show a => a -> String; showReverse x = reverse (show x)”) compile to versions that take an explicit dictionary for each constraint (“showReverse :: Show a -> a -> String; showReverse showImpl x = reverse (show showImpl x)”). References to those values will pass those dictionaries as appropriate.
03:22:54 <Athas> xkb: huh, that's strange.  What exactly does it say?
03:23:08 <xkb> Athas: cabal: The following packages are likely to be broken by the reinstalls:
03:23:09 <xkb> scotty-0.4.4
03:23:11 <Automorphism> typoclass: Java interfaces cannot vary over multiple types.
03:23:16 <lizzzin> Automorphism: i understand how it works in liftweb . not sure if they are at all related though
03:23:20 <xkb> and scotty depends on warp > 1.0.0
03:23:26 <xkb> >=*
03:23:37 <merijn> lizzzin: "Foo deriving Show" means "use built-in magic to create an instance of Show for type Foo. Where an instance is essentially a dictionary of functions matching names and types with those specified in the typeclass. Then, whenever you try to use one of the typeclass's functions the compiler figures out which instance it needs and implicitly passes it as an extra argument
03:24:06 <Athas> xkb: which versions of warp do you already have installed?
03:24:17 <Automorphism> "deriving" is perhaps not the most fortunate of keywords.
03:24:26 <xkb> Athas: 1.2.2, 1.3.0.1
03:24:35 <Automorphism> It is by no means inheritance.
03:24:37 <xkb> where I just installed 1.3.x
03:24:38 <ion> “instantiatingByMagic”
03:24:41 <Athas> So you already have 1.2.2?
03:24:46 <Automorphism> ion: Yes.
03:24:56 <dmwit> xkb: The correct solution is to tell cabal all the top-level goals you have.
03:25:16 <dmwit> xkb: So if you want warp-1.2.2 and some other packages, too, you say "cabal install warp-1.2.2 and some other packages too".
03:25:36 <hpaste> lucca pasted “tears” at http://hpaste.org/73157
03:25:39 <xkb> dmwit: In the end I just want to install yesod-1.x.x
03:25:52 <xkb> dmwit: ah.. the combination
03:25:59 <dmwit> e.g. "cabal install warp-1.2.2 xmonad-0.10.1 yesod --constraint 'yesod > 1 && < 2'"
03:26:07 <dmwit> or whatever
03:26:11 <xkb> dmwit: I see
03:26:15 <merijn> lizzzin: For example, there is the Bounded typeclass, for datatypes which have maximum and minimum bounds. The contents of the Bounded typeclass are the values (note: values, not functions!) minBound and maxBound, writing "instance Bounded Foo where minBound = whatever; maxBound = somethingElse" creates a new instance which basically tells the compiler what values to use for maxBound/minBound when used in a context where it infers the typ
03:26:15 <xkb> let me try that
03:27:04 <merijn> lizzzin: A useful difference from inheritance is that you can define types to be instances of a typeclass without needing to modify the original declaration of the type
03:27:37 <merijn> lizzzin: If you define type Foo in your module, but don't provide a Show instance for it, I can define a Show instance in my code without ever needing to modify your library
03:27:37 <lizzzin> merijn: i can follow that
03:27:52 <tdammers> A typeclass is a bit like an interface in OOP. Not entirely though, because it's still resolved at compile time.
03:28:57 <mm_freak> lizzzin: http://stackoverflow.com/questions/8122109/difference-between-oop-interfaces-and-fp-type-classes/8123973#8123973
03:29:04 <mm_freak> that's the best summary i've seen so far
03:29:05 <tdammers> so you can't, for example, have [Show] and fill it with a mixture of Ints and Strings
03:29:13 <merijn> There's an SPJ talk where he explains how typeclasses are implemented, it's fairly enlightening, but I don't remember the name :\
03:29:30 <Automorphism> tdammers: Another important diffeence is that interfaces are valid types in OOP. In Haskell, you can refer to a generic type that is guaranteed to be an instance of a type class, but the type class itself is not a type.
03:30:26 <tdammers> Automorphism: yes. This kind of follows from the fact that they are resolved at compile time.
03:30:29 <ion> merijn: It seems your client throws the rest of lines exceeding IRC’s length limit into /dev/null.
03:30:39 <Jeanne-Kamikaze> afaik you can have a [Show] with existentials thought, but then you lose the underlying types
03:30:41 <Automorphism> A type class is simply a vtable signature. And type class instances are actual vtables satisfying this signature.
03:30:46 <Jeanne-Kamikaze> *though
03:30:46 <lizzzin> Automorphism: tdammers  oh wow, thats kind of important to know
03:30:53 <lizzzin> mm_freak: thanks for the link
03:31:37 <mm_freak> one of the biggest differences between type classes and interfaces is that type classes are very flexible at polymorphism
03:31:51 <mm_freak> for example i don't know any OOP language where you can encode the Functor typeclass
03:32:00 <dmwit> tdammers: You can have that, you just can't downcast. =)
03:32:30 <Automorphism> mm_freak: It is probably feasible using C++ templates, but it is going to be horrible, and of course it is not going to be guaranteed to be pure.
03:32:30 <Athas> mm_freak: C++?
03:32:51 <tdammers> dmwit: let a = [23, "foobar"] doesn't compile, is what I'm talking about.
03:32:54 <ion> And type class instances (vtables) existing independently of values is a great advantage over many languages.
03:33:11 <dmwit> Nevertheless, it can be done. =)
03:33:17 <mm_freak> i don't know whether C++1x can express it, but there is no context equivalent in the older C++ standard
03:33:22 <dmwit> Just because *that way* doesn't work doesn't mean no way works.
03:33:40 <mm_freak> also C++ templates are basically just a macro language
03:33:41 <Athas> ion: they exist independently of values in many languages.  Usually there's one vtable per class.
03:33:53 <mm_freak> type classes are backed by an actual type system
03:34:14 <tdammers> dmwit: of course it can be done, but you have to jump through a few hoops and sacrifice a few things
03:34:38 <merijn> Hah, that list mm_freak linked is pretty neat, I knew most of them. I just never spent much time to look at the limitations of interfaces to notice some of them :)
03:34:38 <Automorphism> mm_freak: Templates are more sophisticated than macros, but they are duck-typed, which makes them a pain to use.
03:34:41 <ion> > {- You can set the type of something like -} exp (sqrt (-1) * pi) + 1 :: Complex CReal {- from the “outside in”: instead of a vtable being attached to the -1, you pass the vtable of Complex CReal to the expression from the outside. -}
03:34:42 <lambdabot>   0.0 :+ 0.0
03:35:19 <mm_freak> Automorphism: "more sophisticated than macros"?  that makes as little sense as "cars are more sophisticated than vehicles"
03:35:24 <merijn> I think something like "(Show a, Num a) => a -> String" makes a nice short example of some of the extra flexibility you get
03:35:24 <ion> …pass the *vtables* of…
03:36:16 <Athas> ion: that makes little sense to me.  Nothing in that expression is polymorphic.
03:36:33 <merijn> Athas: Except for all the constants, you mean?
03:36:41 <mm_freak> my own answer in that SO page also raises an interesting point, which is not related to interfaces directly, but to the power of the underlying type system
03:36:48 <mm_freak> a type variable can be of kind * -> *
03:36:48 <Athas> merijn: they're resolved statically in that example.
03:37:00 <ion> @type exp (sqrt (-1) * pi) + 1
03:37:01 <lambdabot> forall a. (Floating a) => a
03:38:01 <merijn> Athas: They're always resolved statically...
03:38:05 <merijn> Unless you use existentials
03:38:19 <mm_freak> they are statically resolved in all cases
03:38:22 <mm_freak> including existentials
03:38:48 <merijn> eh, yeah, I fail
03:39:44 <ion> @type (exp, sqrt, -1, (*), pi, (+), 1)  -- all polymorphic
03:39:46 <lambdabot> forall a a1 t a2 a3 a4 t1. (Floating a, Floating a1, Num t, Num a2, Floating a3, Num a4, Num t1) => (a -> a, a1 -> a1, t, a2 -> a2 -> a2, a3, a4 -> a4 -> a4, t1)
03:40:18 <mm_freak> this is one of the biggest misconceptions of ex-OOPers trying to abuse existentials for heterogenous collections…  types are resolved at compile time in all cases
03:40:39 <mm_freak> you have to write custom dynamic typing abstractions to have types at run-time
03:40:42 <mm_freak> like Typeable
03:40:49 <Athas> It's not polymorphic when you run it, due to the type defaulting rules.  You'd need to put it in a function to preserve the polymorphism.
03:41:03 <Athas> That said, you can actually do the same thing using type casting operators in C++, so this is not particular to Haskell.
03:41:30 <ion> There’s no casting involved.
03:42:17 <Athas> How is 'fromIntegral 1' different than 'static_cast<T>(1)' in C++?  You're just arguing semantics.
03:43:08 <Athas> The real magic is the implicit fromIntegral (or is it fromInteger?) on numeric constants.
03:43:08 <shachaf> Athas: Fortunately, semantics is exactly the issue here.
03:43:26 <XexonixXexillion> > 1 :: (Int, Int)
03:43:27 <lambdabot>   (1,1)
03:43:38 <Athas> Semantics as in "the meaning of words", which is much less interesting than "the meaning of Haskell".
03:43:40 <ion> Again, the point was that i was able to choose the type of the entire expression from the “outside” and that propagated to everything within the expression.
03:44:02 <XexonixXexillion> Athas: can a static cast in C++ diverge?
03:44:03 <ion> Not the other way around.
03:44:28 <Athas> XexonixXexillion: actually, it's been too long to remember specifics about static casts, but general C++ implicit casts can, yes.
03:44:32 <Athas> They run arbitrary code.
03:45:16 <XexonixXexillion> Athas: in that case I'll agree it's a matter semantics
03:46:31 <mm_freak> Athas: the difference is that it's a class in C++ while it's a type class in haskell
03:46:43 <Athas> mm_freak: I'm not arguing that.
03:47:00 <ion> In C++, vtables are attached to values. In Haskell, vtables travel as separate entities.
03:47:39 <mm_freak> Athas: fromIntegral is not a good example anyway…  mempty is a better one
03:47:45 <Athas> I still think that's a really strange way of putting it.
03:47:57 <Automorphism> ion: Yes! Isn't that awesome?
03:48:29 <ion> automorphism: Not according to Athas. :-)
03:48:53 <Automorphism> Aw. :(
03:50:20 <hpaste> Athas pasted “Does the desugaring of this not necessarily attach typeclass dictionaries to values?” at http://hpaste.org/73159
03:50:45 <Athas> 'map showShowable funky' works as expected.
03:50:50 <mm_freak> hpaste: dictionaries are attached to stuff that has a type signature with a context
03:50:59 <mm_freak> that can be a function, a value or anything else typed
03:51:02 <mm_freak> hpaste?
03:51:04 <mm_freak> Athas: …
03:51:36 <dmwit> Athas: In GHC, values of type Showable do indeed carry a typeclass dictionary inside.
03:51:53 <Athas> Good, that's what the Core looks like as well.
03:52:07 <mm_freak> semantically a context adds an implicit argument that the compiler figures out by itself by selecting the appropriate instance
03:52:09 <dmwit> If you looked at Core, then why did you ask here?
03:52:12 <dmwit> Core is the definitive answer.
03:52:47 <Athas> dmwit: my keyword was "necessarily".  It might be a suboptimal choice on the part of GHC, or something else.
03:53:21 <mm_freak> Athas: specialization gets rid of the extra argument
03:56:49 <ion> > (pure "foo", pure "foo") :: ([String], Maybe String)  -- "foo" doesn’t carry a “pure”, i pass it to both expressions from the outside.
03:56:51 <lambdabot>   (["foo"],Just "foo")
03:58:09 <Athas> I think my problem is that I've been reading too many papers and too much code on program transformation lately, so I can't help but see the final result of that expression (with everything inlined and no vtables anywhere).
03:58:51 <shachaf> Athas: It doesn't have to do with vtables.
03:59:08 <shachaf> foo :: Num a => a -> a; foo = (+1)
03:59:32 <Athas> Right, that's a function, so I can clearly see what code needs to be generated.
04:00:01 <shachaf> OK, and foo :: Num a => a; foo = 1?
04:00:33 <shachaf> In its own module, that is.
04:00:46 <shachaf> No inlining anywhere.
04:01:23 <ion> bar :: Monoid a => a; bar = mempty
04:01:56 <Athas> foo would be transformed to a function 'NumDict t -> t' when used for some concrete type 't', wouldn't it?
04:02:17 <shachaf> Athas: That's probably what it would get compiled into, yes.
04:02:30 <shachaf> I thought you were talking about semantics, though.
04:06:32 <ion> I can have a “computation :: MonadPlus m => m Something” and switch from (m ~ []) to (m ~ Logic) from the outside to get a more advanced model for my logic without having to change a line within the implementation of “computation”.
04:10:17 <ion> These are defined appropriately for all float values. https://gist.github.com/1188115#L14
04:11:06 <SebastienGllmt> How do I declare a list with a list inside it? I'm trying to do [1, [1,2]] but it doesn't seem to work
04:11:25 <sp3ctum> SebastienGllmt, the syntax is okay
04:11:29 <quicksilver> [[1,2],[3,4]] is fine, though, SebastienGllmt
04:11:36 <quicksilver> the thing is lists have to have elements of the same type
04:11:38 <koala_man> SebastienGllmt: the elements have to be of the same time
04:11:39 <koala_man> type
04:11:52 <sp3ctum> ah, sorry. my mistake
04:11:54 <ion> You might want a tree. http://hackage.haskell.org/packages/archive/containers/0.5.0.0/doc/html/Data-Tree.html
04:12:02 <tdammers> very ad-hoc solution:
04:12:12 <tdammers> [ Left 1, Right [ 1, 2 ]]
04:12:17 <SebastienGllmt> so would I want to use a tuple instead?
04:12:26 <tdammers> depends
04:12:28 <quicksilver> maybe, SebastienGllmt . It depends what you're trying to do :)
04:12:48 <tdammers> a tuple works if the first element is always a number, and the second one is always a list, and there's always exactly two elements
04:12:51 <SebastienGllmt> create a list then flatten it
04:12:53 <timthelion> SebastienGllmt: Tuples generally cannot be longer than say 32/64 elements
04:13:15 <tdammers> you probably want a tree instead
04:13:28 <SebastienGllmt> Alright, I'll look into it
04:13:50 <shachaf> timthelion: That has nothing to do with the reason you don't want to use tuples.
04:13:57 <tdammers> data Node = Leaf a | Branch [Node]
04:13:59 <shachaf> They're a bad idea way before 64 elements.
04:14:03 <timthelion> shachaf: any other reason not to use tuples?
04:14:10 <shachaf> Cofree []
04:14:40 <quicksilver> SebastienGllmt: if your intention in the first place is to flatten it
04:14:44 <shachaf> I guess tdammers's list is closer to what you want.
04:14:50 <quicksilver> SebastienGllmt: then you can normally build it as a uniform depth
04:14:58 <quicksilver> SebastienGllmt: e.g. [[1],[1,2]]
04:15:11 <quicksilver> make sure single elements are wrapped in [], and then just use concat
04:15:16 <quicksilver> > concat [1,1,2]
04:15:17 <lambdabot>   No instance for (GHC.Num.Num [a])
04:15:17 <lambdabot>    arising from a use of `e_1112' at <int...
04:15:23 <quicksilver> !
04:15:29 <shachaf> > concat [[1],[1,2]]
04:15:29 <quicksilver> > concat [[1],[1,2]]
04:15:31 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
04:15:31 <lambdabot>   [1,1,2]
04:15:33 <quicksilver> (sorry :)
04:15:37 <SebastienGllmt> Well the thing is I'm learning Haskell so I'm trying to do assorted stuff in case I ever need to use it
04:15:44 <ion> I love that race condition.
04:15:48 <quicksilver> the advice to use trees is probably misguided
04:15:55 <sp3ctum> wow cool
04:16:01 <quicksilver> unless you have a really good reason to encode your algorithm as a tree :)
04:16:07 <quicksilver> it will just add work.
04:16:35 * timthelion has literally never used the tree data type in his life.
04:16:43 <shachaf> Having small functions that do things is good, but not having to do those things is even better.
04:17:30 <tdammers> you only need a tree structure if your data is actually tree-shaped
04:17:35 <tdammers> with arbitrary nesting
04:17:48 <timthelion> ion: what race condition?
04:17:59 <tdammers> if you only ever nest one level deep, shachaf's uniform-depth list is much better
04:18:13 <SebastienGllmt> but if I do it that way then I can't have stuff like [[1],[1,2,[3,4]]]
04:18:18 <tdammers> no.
04:18:20 <SebastienGllmt> unless I start spamming [] everywhere
04:18:34 <ion> timthelion: <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
04:18:35 <timthelion> tdammers: Every time I've gotten to the point of building tree's I've had such unique and interesting data, that I ended up making my own data type, with you know, names and stuff...
04:18:58 <tdammers> timthelion: sure, but it's still a tree structure
04:19:03 <shachaf> SebastienGllmt: These questions are too low-level.
04:19:10 <timthelion> ion: what, that it's trying to remove a file that doesn't exist?
04:19:39 <SebastienGllmt> shachaf I believe in Haskell
04:19:41 <shachaf> timthelion: Yes.
04:20:03 <ion> timthelion: The general race condition with L.hs. A number of muevals may try to do a bunch of operations to it simultaneously.
04:20:08 <timthelion> SebastienGllmt: hehe, I believe in maltheism.
04:20:32 * shachaf doesn't believe in timthelion.
04:20:43 <timthelion> shachaf: :/
04:20:52 * timthelion no longer exists
04:21:24 <timthelion> ion: I was sure that side effect free computation prevented race conditions...
04:21:29 * timthelion will have to rethink things.
04:21:30 <SebastienGllmt> Once Haskell brings upon the giant flood I will be the only one to living standing tall in the tree that I built -- the tree all of you were too lazy to create
04:21:47 <timthelion> SebastienGllmt: don't knock lazyness!
04:21:57 <timthelion> with a y OR an i!
04:25:22 * mekeor dislikes RWH's table of contents.
04:25:23 <timthelion> Is there any quantitative difference between "f :: [Int];f=1:f" and "g = (1,g)" << what is the type of g in that case anyways???
04:26:09 <mekeor> g doesn't work in ghci
04:26:11 <mekeor> or ghc
04:26:17 <mekeor> because it's type is infinte
04:26:17 <shachaf> timthelion: Yes.
04:26:28 <shachaf> "what is the type of g in that case anyways???" is what GHC says.
04:26:38 <shachaf> You can implement equirecursive types but you don't want to.
04:26:43 <mekeor> :t let g = (1,g) in g
04:26:44 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t1, t)
04:26:44 <lambdabot>       Expected type: t
04:26:44 <lambdabot>       Inferred type: (t1, t)
04:26:47 <mekeor> see
04:27:00 * timthelion sad puppy face
04:27:23 <fmap> i guess one can implement `g' with Free?
04:27:58 <quicksilver> haskell forces all value recursion to go via recursive data types
04:28:02 <timthelion> GHC isn't smart enough to do like "newtype G = (Int,G);g::G;g=(1,g)"
04:28:08 <timthelion> would THAT work?
04:28:12 <schlicht> So i wrote a gui with gtk2hs, and i'm using a turnstile (⊢) at somepoint in my labels. My boss uses mac, and on his mac the turnstile is kind of broken, it is there but with an rectangle afterwards. anyone an idea why? i tried \x22A6
04:28:22 <quicksilver> this means that the the constructor acts as a 'signpost' which makes type inference feasible.
04:28:30 <quicksilver> yes, somehting like that will work, timthelion
04:28:36 <quicksilver> but you need a constructor name
04:29:02 <quicksilver> newtype G = mkG (Int,G); g = mkG (1,g)
04:29:26 <hiptobecubic> why is that different
04:29:34 <timthelion> schlicht: there are still some bugs with UTF8 in gtk2hs sadly.  Found one the other day, that the open file dialog box doesn't support it at all.  Haven't gotten around to reporting it yet...
04:30:04 * timthelion has never heard of constructor names before.
04:30:45 <quicksilver> timthelion: yes you have.
04:30:57 <quicksilver> data Maybe a = Nothing | Just a
04:31:02 <mekeor> s/mkG/MkG/ # right?
04:31:03 <quicksilver> the constructors are named 'Nothing' and 'Just'
04:31:09 <timthelion> quicksilver: then whyt isn't mkG capitalised?
04:31:09 <quicksilver> yes, mekeor :)
04:31:10 <schlicht> timthelion, hmpf, and what can i do now?
04:31:16 <quicksilver> timthelion: typo.
04:32:08 <SebastienGllmt> hmm if I do data Tree tree = Empty I get a parse error on put 'data'
04:32:15 <timthelion> schlicht: I don't know.  When I came across the error, I said "screw it, I'm too buisy to make a test case and file a bug report"  You could try asking on the gtk2hs list, it's not very active, but you'll get a responce(I always have)
04:32:16 * mekeor doesn't like that RWH almost only gives example but doesn't actually *explain* stuff... :(
04:32:18 <SebastienGllmt> *input data
04:32:24 <mekeor> *examples
04:32:31 <Automorphism> mekeor: Yeah, I have found that frustrating as well.
04:32:43 <schlicht> timthelion, how do i find out, if gtk2hs is the problem?
04:32:56 <Automorphism> mekeor: For all the childish language, at least LYaH attempts to bring explanations to the table.
04:33:04 <mekeor> SebastienGllmt: are there whitespaces before "data"?
04:33:26 <SebastienGllmt> no, only a tab because it's inside the main = do
04:33:37 <timthelion> schlicht: it's almost definitely the problem.  If you are setting some lable text that takes a "String" and that attribute fails to process the String, then it's pretty much gauranteed to be a gtk2hs problem!
04:33:44 <mekeor> Automorphism: yeah, but LYAH is too childish and RWH only consists of examples... taht's annoying :/
04:34:01 <mekeor> Automorphism: i read most of LYAH though...
04:34:03 <timthelion> mekeor: too childish?
04:34:13 <tdammers> RWH worked well for me
04:34:16 <mekeor> timthelion: the steps are too small.
04:34:20 <mekeor> it explains too much
04:34:26 <tdammers> bigger problem than the all-examples approach is that it's somewhat outdated
04:34:45 <timthelion> mekeor: just compile the examples to core, and figure out what they mean by reading the c-- code.
04:34:55 <timthelion> ;)
04:34:58 <mekeor> :D
04:35:13 <schlicht> timthelion, the string just has a extra rectangle after a unicode symbol, anything else is correct, thats weird...
04:35:32 <SebastienGllmt> http://ideone.com/hNRo8
04:35:35 <SebastienGllmt> Mystery errors
04:36:14 <tdammers> schlicht: I had similar problems with libcairo
04:36:22 <mekeor> SebastienGllmt: data types are defined at top-level. not in do-blocks.
04:36:40 <Automorphism> SebastienGllmt: Why is the line "data Tree tree = Empty" inside the do block?
04:36:40 <schlicht> tdammers, and what did you do?
04:36:51 <tdammers> the first version I used had a bug that caused it to treat Strings as byte strings
04:36:56 <Automorphism> SebastienGllmt: What are you trying to do there?
04:37:00 <SebastienGllmt> mekeor you just shattered my entire world that revolved around stuffing stuff inside do blocks
04:37:06 <tdammers> so I had added a workaround, basically, utf-8 encoding Strings
04:37:24 <tdammers> but then, at some point, things just broke almost exactly like you described
04:37:30 <tdammers> removing the workaround fixed it
04:37:35 <mekeor> SebastienGllmt: http://ideone.com/G4LKl
04:37:41 <SebastienGllmt> Automorphism I'm not exactly sure yet
04:37:50 <tdammers> so apparently, someone had fixed the bug in cairo (or the haskell cairo bindings)
04:37:50 <frerich> SebastienGllmt : FWIW, even if you ptu the 'data' line to the topelvel scope, there still seems to be a disagreement of what a 'Tree' is. the 'treeFromList' function seems to assume something which has two constructors ("Empty" and "Node").
04:37:53 <tdammers> so
04:38:10 <tdammers> my guess would be that you have too much UTF-8 encoding somewhere
04:38:13 <mekeor> SebastienGllmt: you ought continue reading your haskell book... :)
04:38:23 <SebastienGllmt> frerich yeah this is all copy pasted from stuff I'll fix that when I get to it
04:38:38 <mekeor> s/continue/to continue/
04:38:51 <SebastienGllmt> mekeor I'm taking a bit from every book and reading libraries as I go through doing random assorted tasks
04:38:55 <tdammers> also taught me the lesson that I should use cabal-dev and properly guard dependency versions ;)
04:39:15 <schlicht> tdammers, i tried \8870 , \x22A2 and the unicode directly in the source file  ⊢
04:39:42 <tdammers> so your String value is probably correct
04:39:49 <schlicht> its just a plain haskell string
04:39:55 <tdammers> and those are Unicode
04:39:56 <schlicht> on linux it works fine
04:40:11 <SebastienGllmt> schlicht maybe tell your boss to get an operating system that doesn't suck
04:40:14 <tdammers> make sure you have the same versions of the libraries *and* their haskell bindings on both platforms
04:40:15 <mekeor> SebastienGllmt: yeah, that's a quite nice method (actually, no, it isn't). but it's really really slow, so if you don't wanna waste much time, i'd recommend warmly recommend reading a book, like LYAH :)
04:40:26 <schlicht> SebastienGllmt, yeah right...
04:40:46 <tdammers> I'm guessing something somewhere doesn't marshal Strings quite correctly
04:40:56 <SebastienGllmt> mekeor I have a physcial copy of LYAH so I'm going to be forced to go through it but I'm enjoying myself as it is
04:41:09 <tdammers> away zzzzzzzzzzzzzzz
04:41:30 <schlicht> mhm, he told me it was a pain just to get gtk to work on mac os,...
04:43:01 <timthelion> schlicht: if you can make a 3 line program, that's like "import Graphics.UI.Gtk\nmain ::IO()\nmain = do\n guiInit\n win<-createWindow\n box<-myTopVBox\n containerAdd win box\n label<-labelNew (Just "⊢")\n containerAdd box label\n widgetShowAll win\n mainGUI
04:43:08 <timthelion> and test it, that would help
04:44:08 <schlicht> tdammers, timthelion i will do that. waiting on the mac book to test it. other symbols work just fine, but some in that area have the same problem
04:45:05 <timthelion> if you replace \n with newlines, that program should *just work* tm
04:49:53 * shapr yawns
04:50:07 <schlicht> timthelion, yeah...2012 and encoding still sucks
04:51:05 <typoclass> schlicht: haven't followed the discussion, but have you checked if that symbols is included in the font that the mac gtk stuff uses?
04:51:59 <schlicht> typoclass, the symbol is display, it is there and it is the right one, just with a rectangle with 4 circles in afterwards
04:52:34 <typoclass> schlicht: how strange ...
04:52:35 <timthelion> schlicht: well, it's mostly OK, once you coerce EVERYTHING to use utf-8.. The only problem, is the fact that many things are still not even utf-8 by default(puzzling isn't it?)
04:53:14 <schlicht> wiki said mac os uses utf16
04:54:18 <timthelion> that's not so great. and could be your problem.  You'd have to look it up, but it's possible those symbols are getting expanded to like 3 bytes when in utf8, they are expanded to only 2 or something.  I'd presume that the gtk stuff on mac uses utf8.
04:54:38 * timthelion doesn't have the differences between utf-8 and utf 16 memorised
04:54:57 <schlicht> timthelion, yeah i was trying to find something in that direction
04:55:10 <timthelion> schlicht: you understand how that happens? Haskell thinks it's supposed to be "thinking in" utf-16 and gtk is expecting utf8
04:56:34 <schlicht> timthelion, maybe, but how i can fix that?
04:56:44 <mekeor> x >> y = x >>= \_ -> y, right? so, (>>) doesn't actually have to be in the Monad type class, right?
04:56:53 <quicksilver> mekeor: right.
04:57:06 <mekeor> okay :)
04:58:04 <timthelion> schlicht: you'd have to ask on the list :/
04:59:31 <timthelion> mekeor: Many people think that a fuction of type "f:: IO a -> a" is impossible.  This is true.  But what about a function of type "f :: IO a -> b"?  Try giving "f x = 42" that type sometime...
05:00:47 <mekeor> timthelion: oh, cool, it works! oO
05:01:18 <schlicht> timthelion, soo just got the mac book air to test that stuff
05:01:37 <quicksilver> timthelion: f x = 42 does not have type "f :: IO a -> b"
05:01:49 <timthelion> quicksilver: it does if you tell GHC it does.
05:01:58 <quicksilver> no, it does not.
05:02:07 <mekeor> quicksilver: right
05:02:11 <quicksilver> you could give it the type Num b => IO a -> b
05:02:16 <quicksilver> but that's entirely different.
05:02:22 <bitonic> timthelion: `42' can't be any b
05:02:29 <mekeor> yeah
05:02:32 <quicksilver> if you think "that is good enough" then why not give it the type Num a => IO a -> a
05:02:35 <timthelion> bitonic: but any b can be a Num, that is the difference
05:02:44 <quicksilver> which is like your first 'impossible' one.
05:02:48 <mekeor> quicksilver: yeah
05:02:53 <bitonic> timthelion: what?  no
05:02:54 <timthelion> quicksilver: but you're wrong
05:03:03 <quicksilver> which part was wrong?
05:03:24 <timthelion> quicksilver: your insistance I cannot claim that f has type :: IO a -> b is bullshit.
05:03:37 <dmwit> You can claim anything you want.
05:03:38 <timthelion> b could be anything.  No need to restrict it to the num class
05:03:41 <dmwit> But if you make that claim, you'll be wrong.
05:03:50 <mekeor> it is impossible to define a function ":: IO a -> b" where a and b are type variables. (not using undefined and error.)
05:03:52 <dmwit> (Try it!)
05:04:05 * hackagebot hpygments 0.1.0 - Highlight source code using Pygments (DavidLazar)
05:04:17 <quicksilver> timthelion: with the body "f x = 42" as in your original message, IO a -> b is not a valid type.
05:04:43 <bitonic> mekeor: `x = x' has that type, no undefined or error!  you probably meant "no bottoms" :P
05:05:14 <mekeor> bitonic: oO what's the type of x in x = x?
05:05:27 <bitonic> mekeor: `forall a. a'.  pick your `a'.
05:06:00 <mekeor> oh, you mean like "impossible _ = x where x = x". i see.
05:06:10 <mekeor> yup
05:06:15 <bitonic> mekeor: no, I mean x = x.
05:06:20 <bitonic> @type let x = x in x
05:06:21 <lambdabot> forall t. t
05:06:28 <timthelion> quicksilver: mmm, I guess you are right.
05:06:35 <bitonic> @type let x = x in x :: IO a -> b
05:06:37 <lambdabot> forall a b. IO a -> b
05:06:46 <mekeor> oh
05:06:52 <mekeor> okay, yeah
05:07:02 <dmwit> :t let x :: IO a -> b; x = x in 3
05:07:03 <mekeor> hm, cool
05:07:04 <lambdabot> forall t. (Num t) => t
05:07:10 <quicksilver> timthelion: thank you. I'd be grateful if you held back on phrases like 'bullshit' in future. We value the quality of language used in here :)
05:08:41 <mekeor> bitonic: so, what's "bottom" exactly? i thought bottom is "data Bottom"...
05:09:33 <bitonic> mekeor: bottom is something with no defined value, e.g. infinite loop or `length [1..]'.
05:09:38 <dmwit> It's a term for loops, exceptions, and other oddities that are too weird to admit are a part of Haskell.
05:09:45 <mm_freak> mekeor: that's Absurd
05:10:05 <dmwit> Actually, there's lots of different bottoms.
05:10:18 <mekeor> bitonic: ah, something that doesn't terminate e.g.. so, in agda, there is no bottom?
05:10:22 <dmwit> "data Bottom" is a fine type-level bottom.
05:10:55 <dmwit> Generally: "bottom" is the minimal value in some ordering.
05:11:20 <dmwit> In Haskell, the ordering we're *usually* talking about when we say "bottom" is the defined-ness ordering.
05:11:23 <mekeor> but in haskell, there are values which have bottom as their type, e.g. "length [1..]" while in agda that can't be... or is this a misuse of the terms?
05:11:28 <bitonic> mekeor: in agda there is no bottom
05:11:43 <mekeor> bitonic: yeah, cool
05:11:49 <mm_freak> dmwit: that Bottom is not a type-level bottom…  that one would more like this:  type instance F x = F x
05:12:15 <shachaf> mm_freak:
05:12:17 <shachaf> Er.
05:12:19 <timthelion> > :t lenght [1..]
05:12:20 <mm_freak> shachaf:
05:12:20 <lambdabot>   <no location info>: parse error on input `:'
05:12:21 <dmwit> mm_freak: Depends what ordering you use. If you use the implication ordering (e.g. x < y when you can implement a function of type x -> y), then "data Bottom" is a fine bottom.
05:12:23 <timthelion> > :t length [1..]
05:12:25 <lambdabot>   <no location info>: parse error on input `:'
05:12:31 <timthelion> @type length [1..]
05:12:33 <lambdabot> Int
05:12:47 <timthelion> mekeor: length [1..] has a type Int
05:12:47 <mm_freak> dmwit: i'm using definedness
05:12:48 <shachaf> mm_freak: "_|_" to mean an empty type is reasonably standard.
05:13:07 <shachaf> It's not really related to value-level _|_ in Haskell, though (except that the latter is the only inhabitant of the former).
05:13:10 <timthelion> shachaf: empty type?
05:13:10 <shapr> Gooood Morning #haskell!
05:13:13 * shapr boings cheerfully
05:13:18 <mekeor> :D
05:13:21 <dmwit> mm_freak: That's unusual. Is there even a definedness ordering in Haskell's type system? =)
05:13:22 <mm_freak> shachaf: i never liked that name
05:13:25 <quicksilver> shachaf: (which is quite a relavant 'relation' isn't it?)
05:13:26 <shachaf> timthelion: "empty type" means "type with one inhabitant"
05:13:28 <mm_freak> dmwit: sure
05:13:41 <timthelion> shapr: good morning sleepy head.  On this side of the world, it's already 2 o clock!
05:13:45 <shachaf> quicksilver: Sort of, except that value-level _|_ is also an inhabitant of every other type.
05:13:49 <shapr> Aw, it's only 7am here!
05:13:53 * quicksilver nods
05:14:16 <shachaf> quicksilver: Given that type-level _|_ isn't usually used in Haskell anyway, I think it's just confusing to bring it up.
05:14:20 <mekeor> so, _|_ is bottom, right?
05:14:23 <mm_freak> dmwit: all haskell types are fully defined, until you enable UndecidableInstances and perhaps TypeFamilies
05:14:24 <timthelion> shapr: well, rise and shine!
05:14:28 <quicksilver> shachaf: it probably was confusing in this context, yes.
05:14:38 <quicksilver> shachaf: it's quite relevant in a kind of curry-howard type context I think.
05:14:52 <shapr> timthelion: I feel more like bread some mornings. I rise and get beaten up by the world!
05:14:56 <shachaf> quicksilver: Sure, but people just use Void for that.
05:15:07 <shachaf> In Haskell. Since that can be an actual type and all.
05:15:14 <timthelion> shapr: I don't bother getting up that early, so I wouldn't know.
05:15:29 <shapr> haha!
05:15:39 <shapr> So, how's the code flowing this morning?
05:15:44 <timthelion> shachaf: so you're saying you'd like to call "type G = (1,G)" _|_?
05:15:59 <shachaf> timthelion: No.
05:16:21 <timthelion> shapr: I'm studying for a linguistics test. Can't you tell?
05:16:27 <mekeor> so, the "top type" is like a type variable (which isn't restricted by a constraint), right?
05:16:34 <shapr> timthelion: In which language?
05:16:45 <shapr> timthelion: Are you writing linguistics concepts in Haskell?
05:16:46 <shachaf> There's no "top type" in Haskell, I think.
05:16:55 <shachaf> Well, there's "exists a. a", I guess.
05:17:00 <shachaf> But Haskell doesn't have that. :-)
05:17:06 <typoclass> shapr: so, what timezone are you in? timthelion must have been referring to central european, plus summer time
05:17:10 <timthelion> shapr: English.  Right now I'm perfecting my knowlege of the semantic feild of procrastination.
05:17:22 <mekeor> shachaf: what's the type of "undefined" called?
05:17:22 <dmwit> data Top = forall a. Top a -- ?
05:17:46 <shapr> timthelion: oh wow!
05:17:48 <dmwit> sort of
05:17:51 <shachaf> dmwit: Well, that's not first-class.
05:17:58 * dmwit nods appreciatively
05:17:58 <danr> why would you talk about a top type if you don't have subtyping?
05:18:00 <shachaf> (forall a. a) is first-class type-level _|_
05:18:23 <danr> or do you mean top as in () ?
05:18:29 <mekeor> that's unit
05:18:55 <shachaf> Hmm, () is actually what they mean in Agda when they say Top.
05:18:58 <danr> yes... in agda it's usually written as ⊤ though
05:19:03 <dmwit> () is a fine top type, but not in the ordering we were talking about just now.
05:19:04 <Saizan> the implication lattice has a top and a bottom, () and Void, in a total language
05:19:08 <shachaf> Given that they only care about whether it's inhabited.
05:19:54 <mekeor> oh, there's even a name for Maybe in type theory: http://en.wikipedia.org/wiki/Option_type
05:19:57 <schlicht> i can start a unicode pointer with \x ... how do i end it, with out a space?
05:20:12 <hpc> shachaf: \&
05:20:18 <hpc> > length "\&"
05:20:19 <lambdabot>   0
05:20:24 <hpc> > '\&'
05:20:26 <lambdabot>   <no location info>:
05:20:26 <lambdabot>      lexical error in string/character literal at chara...
05:20:35 <dmwit> Hm, I wonder...
05:20:39 <dmwit> > '\96\&'
05:20:41 <lambdabot>   <no location info>:
05:20:41 <lambdabot>      lexical error in string/character literal at chara...
05:20:41 <hpc> er, schlicht ^
05:20:44 <dmwit> yeah
05:20:51 <dmwit> Anyway, yes, use \& or string gaps.
05:21:01 <hpc> string gap?
05:21:02 <dmwit> > "\96\ \7"
05:21:04 <lambdabot>   "`7"
05:21:04 <schlicht> hpc, thanks, but doesnt do the trick :(
05:21:14 <dmwit> schlicht: You're doing it wrong, then.
05:21:22 <dmwit> Show us what you tried.
05:21:33 <hpc> > "\e"
05:21:35 <lambdabot>   <no location info>:
05:21:35 <lambdabot>      lexical error in string/character literal at chara...
05:21:50 <hpc> > length "\n"
05:21:52 <lambdabot>   1
05:21:53 <typoclass> i think you could always do "\xabc" ++ "rest". i find it more clear than \&, let alone \ \
05:21:56 <hpc> > length "\nul"
05:21:58 <lambdabot>   3
05:22:04 <hpc> > length "\n\&ul"
05:22:06 <lambdabot>   3
05:22:13 <hpc> hmm
05:22:17 <shachaf> \NUL
05:22:22 <hpc> > length
05:22:24 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> GHC.Types.Int)
05:22:24 <lambdabot>    arising f...
05:22:27 <hpc> > length "\NUL"
05:22:28 <shachaf> /query
05:22:29 <lambdabot>   1
05:22:33 <hpc> pah
05:22:47 <typoclass> urgh, it's case-sensitive. how weird.
05:23:06 <hpc> typoclass: the problem with (++) is that now you have to do constant folding
05:23:07 <schlicht> dmwit, Just "\x22A2\& test"
05:23:13 <hpc> which means -O
05:23:18 <RawProduce> > length "test"
05:23:19 <dmwit> > "\x22A2\& test"
05:23:19 <lambdabot>   4
05:23:20 <lambdabot>   "\8866 test"
05:23:25 <RawProduce> is this executing code?!
05:23:26 <dmwit> schlicht: Looks like it works here.
05:23:27 <shachaf> hpc: No, you only have to do constant-folding if you care.
05:23:29 * mekeor notices a similarity between the types of fmap, (<*>) and (=<<)
05:23:30 <dmwit> RawProduce: yes
05:23:30 <RawProduce> coolest thing ever
05:23:33 <shachaf> ++ doesn't work with some OverloadedStrings, though.
05:24:03 <hpc> mekeor: you should compare their implementations for ((->) e)
05:24:21 <mekeor> okay, i'll write them myself =)
05:24:34 <dmwit> schlicht: Possibly useful next question: what string were you expecting?
05:24:39 <schlicht> dmwit, im using a gtk label on mac, "\x22A2" is displayed just fine, "\x22A " with a space is the symbol and a rectangle thats wrong there
05:24:43 * mekeor is writing his own prelude for learning purposes...
05:24:53 <schlicht> dmwit, * "\22A2 "
05:24:58 <schlicht> dmwit, * "\x22A2 "
05:25:34 <shachaf> schlicht: You could just put the codepoint straight into your source code...
05:25:56 <schlicht> shachaf, what do you mean?
05:26:08 <hpc> schlicht: haskell source can contain unicode
05:26:13 <dmwit> schlicht: It's not clear to me why that suggests to you that "\x22A2 " is not the right thing to write in Haskell source.
05:26:18 <hpc> so just put the actual character into the string
05:26:23 <hpc> instead of the escape code
05:26:27 <schlicht> hpc, same error
05:26:36 <schlicht> tried that at the beginning
05:26:38 <typoclass> schlicht: that's strange. is there some setting in gtk (or gtk2hs) about trying to auto-detect or auto-guess the encoding?
05:26:40 <timthelion> schlicht: Are you using my reduced test case?
05:26:49 <dmwit> typoclass: No, everything is UTF-8.
05:26:55 <schlicht> timthelion, yeah, kind of
05:27:03 <shachaf> schlicht: Step 1: Instead of using GtkLabel, use putStrLn.
05:27:05 <dmwit> typoclass: And functions that accept values of type String are encoded/decoded at the Haskell/C boundary.
05:27:10 <dmwit> If not, it's a bug, so complain.
05:27:13 <shachaf> After you make it work with putStrLn, you'll know whether to blame Gtk.
05:27:40 <dmwit> ==shachaf, except use print instead of putStrLn so you know whether to blame your terminal
05:27:50 <typoclass> dmwit: right, but a bug in gtk2hs would be possible. he reported it works fine on linux and fails on a mac
05:28:13 <timthelion> dmwit: gtk2hs is already known to be buggy in this area
05:28:17 <dmwit> typoclass: I don't understand your question, then.
05:28:31 <dmwit> timthelion: Can you be more specific?
05:29:00 <timthelion> dmwit: I ran across a similar bug in the open file dialog.  Also doesn't seem to handle utf-8 strings properly
05:29:11 <dmwit> That's a completely different issue.
05:29:22 <shachaf> typoclass: Questions about Gtk2hs are different from questions about Haskell.
05:29:22 <dmwit> Filenames are not String, unfortunately.
05:29:41 <timthelion> dmwit: It returns a FilePath, which IS String, no?
05:29:46 <schlicht> shachaf, works fine with putStrLn
05:29:50 <hpc> timthelion: think he means C-side
05:29:53 <shachaf> schlicht: OK, then it's Gtk2HS.
05:30:06 <theorbtwo> Well, the OS-side.
05:30:11 <dmwit> timthelion: Although Haskell has the unfortunate wart of "type FilePath = String", nevertheless, String is the wrong type.
05:30:31 <timthelion> dmwit: ?
05:30:42 <theorbtwo> In unix, filenames are bunches of no-explicit-encoding bytes.
05:30:55 <MrElendig> on windows they are unicode
05:30:56 <dmwit> Filenames are sequences of bytes in *nix, and something else in Windows (don't remember what off the top of my head).
05:31:01 <MrElendig> while on windows*
05:31:40 * timthelion is pretty sure it's filesystem dependent and not kernel dependent?
05:31:49 <koala_man> in Windows they're utf-16 characters
05:31:49 <tdammers> timthelion: both
05:31:53 <dmwit> Very likely true, yes.
05:32:03 <timthelion> this is awful
05:32:05 <timthelion> !
05:32:07 <dmwit> yes!
05:32:23 <dmwit> And very much not what schlicht is running into, I think.
05:32:29 <timthelion> why did I ever move to a country with little hats above the letters!!!???
05:32:31 <shachaf> I thought on Windows they were 8 bytes + 3 bytes extension.
05:32:41 <schlicht> '\x22A2' : "foo" works, 'x22A2' : " foo" not
05:33:03 <theorbtwo> IMHO, the only resonable route there is to write your filenames in ascii.
05:33:04 <mekeor> timthelion: calm down and join #-blah ...
05:33:06 <typoclass> schlicht: you're missing the "\"
05:33:11 <MrElendig> schlicht: ntfs and the modern windows api uses unicode for everything
05:33:18 <MrElendig> ser.. shachaf ^
05:33:19 <theorbtwo> ...not that even I do that.
05:33:33 <schlicht> typoclass, yeah sry, still :)
05:34:01 <koala_man> theorbtwo: how would you feel if you couldn't include the characters 'm' or 'p', because you already have n and b which sounds the same
05:34:40 <typoclass> schlicht: to summarize, you did «print ('\x22A2' : " foo")» and that gives a wrong result?
05:34:47 <shachaf> MrElendig: Is it Unicode or "BMP Unicode"?
05:34:53 <typoclass> er, putStrLn
05:35:05 * shachaf is seeing seemingly-inconsistent on MSDN.
05:35:09 <schlicht> so, suggestion for a workaround? my boss wants to present it on monday on is mac...
05:35:10 <theorbtwo> koala_man: Not great, but fortunately, in many languages, that's not really analogous.
05:35:14 <schlicht> typoclass, putStr works
05:35:19 <schlicht> label doesnt
05:35:59 <timthelion> schlicht: crazy idea of the day...  Save it to SVG and use cairo to draw it.
05:36:04 <theorbtwo> German, for example, defines u-umlout and ue as equivelent (in most circumstances, at least).
05:36:15 <theorbtwo> Anyway, getting really off-topic now.
05:36:18 <tdammers> not exactly equivalent
05:36:23 <mekeor> ü
05:36:35 <tdammers> 'ue' is an acceptable replacement on environments where umlauts are not available
05:36:43 <tdammers> which, today, means practically never
05:36:44 * mekeor is from germany... öäüÖÄÜßẞ
05:36:50 <schlicht> timthelion, yeah but that is realy ugly and not realy font size independent
05:37:06 <timthelion> schlicht: just don't do that in production software, as blind people won't be able to read it then(if you want to do that in production software, then you have to set the accessability feild as well)
05:37:10 <koala_man> tdammers: is it awkward to read?
05:37:21 <dmwit> schlicht: Well, as a workaround, you could have two labels, one for \x22A2 and one for the remainder of the text.
05:37:22 <timthelion> schlicht: Did I say it wasn't?
05:37:25 <dmwit> not really pretty
05:37:36 <timthelion> dmwit: now you're thinking...
05:37:40 <theorbtwo> timthelion: Not that I'd expect screen-reader software to support \x22A2 very well.
05:37:53 <koala_man> I know if someone wrote Norwegian blaabaersyltetoey instead of blåbærsyltetøy, I'd find it really awkward
05:37:55 <theorbtwo> U+22A2 RIGHT TACK = ⊢
05:38:01 <schlicht> timthelion, its a development tool
05:38:03 <timthelion> theorbtwo: braille can support ANY character.
05:38:17 <timthelion> schlicht: doesn't mean blind people will never use it.
05:38:40 <tdammers> koala_man: yes.
05:38:44 <schlicht> very unlikely
05:38:48 <timthelion> theorbtwo: and a smart screen reader, will read that aloud as "Right Tack"
05:38:57 <schlicht> its unlinkely anyone will use it
05:39:06 <timthelion> schlicht: sorry, my feild is accessability :)  Don't mind me.
05:39:43 <timthelion> schlicht: work on something for a couple of years, and all of a sudden it starts seeming like the most important think in the world.
05:39:51 <theorbtwo> timthelion: Interesting.  Other then as a transcriber's note defining a temporary charcter as "right tack"?
05:40:23 * theorbtwo isn't an accessability expert, and can't read braille, but has read the universal english braille spec.
05:40:40 <schlicht> dmwit, yeah thats possible, but i much work, because the labels are arranged on a layout
05:40:43 <schlicht> timthelion, hehe
05:41:27 <dmwit> I mean, the right thing to do is to hack about a bit and see if you can find a way to output the bytes in the label.
05:41:35 <timthelion> theorbtwo: there are like 5 specs, none of them apply to 8 dot computer braille(at least not in any language other than German and Chinese) and most people redefine the symbols anyways.  But good job, I haven't.
05:41:51 <dmwit> If the string is encoded correctly, you complain to the gtk folks; if it isn't, you complain to the gtk2hs folks.
05:42:16 <schlicht> aha!
05:42:22 <timthelion> schlicht: yes?
05:42:54 <theorbtwo> Hm.  Randomly, you might also try writing to, and reading back, the label.  What you get back might shed some light on the issue.
05:42:54 <merijn> koala_man: I think it'd be quite awkward, seeing "wrong" digraphs is normally quite jarring
05:42:57 <dmwit> Here's another possible workaround: you could use another kind of whitespace.
05:43:17 <schlicht> it works if i use a NO-BREAK SPACE like this: '\x22A2' : '\x00A0' : "foo"
05:43:26 <dmwit> ah, you used this trick =)
05:43:41 <merijn> Take for example all the native English speakers (that's a slightly less confrontational way of saying "americans" :p) butchering the ij digraph in my name...it's quite jarring to read
05:43:43 * timthelion didn't know there was more than one kind of space...
05:43:48 <dmwit> You can just write that "\x22a2\xa0\&foo", by the way
05:43:56 <theorbtwo> Have you tried switching fonts, or copy-and-pasing out the value in the label?
05:44:22 <tdammers> using 'ij' instead of the proper ligature is more acceptable than using the -e umlaut replacement
05:44:33 * tdammers speaks German *and* Dutch
05:44:45 <merijn> tdammers: I didn't mean the ij ligature, they keep addressing me a merjin >.>
05:44:52 <tdammers> ouch.
05:44:58 <merijn> Because an ij digraph can't possibly be right, right?
05:45:00 <schlicht> dmwit, yes :)
05:45:04 <frerich> tdammers: Sincere condolences.
05:45:07 <schlicht> thanks everybody!
05:45:20 <shachaf> merĳn
05:45:22 <luite> hehe merjin
05:45:22 <tdammers> I used to live on IJssellaan, and most spell checkers would change it to Ijssellaan
05:45:30 <timthelion> dmwit: why are there more than one kind of space?
05:45:41 <timthelion> s/are/is/?
05:46:02 <merijn> shachaf: Fancy
05:46:03 <dmwit> timthelion: There are some things that it would be confusing to separate across a newline when word wrapping.
05:46:24 <theorbtwo> merijn: Is it pronouned the same as i-j, or as a long i?
05:46:25 <merijn> Let's see if freenode supports unicode properly
05:46:29 <theorbtwo> (In your name.)
05:46:34 <dmwit> timthelion: For example, in "Theorem 42", it's quite convenient to put a non-breaking space to prevent this from becoming "Theorem\n42".
05:46:38 <schlicht> still would be intressting what is happening in the background
05:46:39 <merijn> oh :(
05:46:40 <shachaf> merijn: You can't change your nick to that.
05:46:42 <timthelion> dmwit: OH, I see :)  So like collocations and yet to be joined compound words...
05:46:50 <shachaf> merijn: IRC is just bytes, though.
05:46:58 <typoclass> schlicht: have you tried labelSetUseMarkup? it might be relevant, not sure. see http://hackage.haskell.org/packages/archive/gtk/0.12.3.1/doc/html/Graphics-UI-Gtk-Display-Label.html
05:47:03 <theorbtwo> Sadly, per the sepc, IRC is *not* just bytes.
05:47:08 <merijn> theorbtwo: Your question does not compute
05:47:09 <shachaf> Your nick is restricted to a small set of bytes, all below 128.
05:47:28 <theorbtwo> merijn: How is the "ij" in your name properly pronunced?
05:47:40 <schlicht> typoclass, i will have a look at it
05:48:02 <merijn> Closest thing in English would be something like eye or I
05:48:20 <theorbtwo> merijn: Right.  That's a long i.
05:48:21 <tdammers> close, but not the same
05:48:23 <timthelion> so like mereen
05:48:33 <tdammers> more like merine
05:48:37 <frerich> merijn: wouldn't it be more like the "ey" in "Feynman"?
05:48:42 <timthelion> like Česky merín?
05:48:51 <merijn> theorbtwo: Which is completely unlike how the letter i is pronounced, which is more like 'e' in the long form :p
05:49:01 <merijn> frerich: Kinda, sorta
05:49:18 <dmwit> http://en.wikipedia.org/wiki/IJ_(digraph) <- pretty much clears everything up, no?
05:49:21 <tdammers> let's not get started on 'ui', shall we?
05:49:26 <merijn> Actually, the simplest explanation would be to say it's pronounced like the ij in Dijkstra :p
05:49:32 <timthelion>  /meri:n/ or /meri:ne/?
05:50:01 * timthelion has never heard Dijkstra.
05:50:13 <tdammers> timethelion: get out.
05:50:17 <knz> timthelion: /mere:in/
05:50:17 <dmwit> timthelion: ij is pronounced [ɛi]
05:50:18 <luite> frerich: :(
05:50:33 <dmwit> tdammers: I think he just means he's never heard the name said aloud.
05:50:34 <knz> actually no
05:50:35 <theorbtwo> dmwit: That suggests that there are two ways to pronounce ij, depending on context, which is why I asked.
05:50:45 <tdammers> dmwit: that would be excusable
05:50:49 <knz> timthelion: /m<schwa>re:in/
05:50:52 <dmwit> What, really?
05:51:06 <knz> what's ASCI IPA for schwa?
05:51:15 <tdammers> upside-down e
05:51:21 <tdammers> or upside down c
05:51:21 <dmwit> huh
05:51:23 <tdammers> can't remember
05:51:28 <shachaf> By "ASCII" you mean UTF-8, right?
05:51:31 <timthelion> dmwit: actually, I'd never heard of him
05:51:33 <shapr> I wonder if Aarne Ranta's Grammatical Framework handles pronunciation at all?
05:51:34 <shachaf> If so it's ə
05:51:36 <dmwit> Maybe I should actually learn the IPA conventions before I say much more. =P
05:51:44 <theorbtwo> schlicht: ASCI, not ASCII.
05:51:45 <tdammers> theorbtwo: yes
05:51:57 <tdammers> there is an exception for word endings like -lijk
05:52:04 <shachaf> If my heuristics for Dutch pronunciation are correct, the IPA transcriptions in here are inaccurate.
05:52:12 * shapr goes to swim in the lijk
05:52:13 * mekeor says merid͡ʒin
05:52:20 <knz> http://nfcs.wikispaces.com/ASCII+IPA <- this says @
05:52:35 <tdammers> shapr: that would make you a necrophiliac of some sort
05:52:47 <shapr> er, I was saying "lake" in my head.
05:52:50 <mekeor> "meree djin"
05:52:51 * shapr blinks
05:52:54 <mekeor> :D
05:53:09 * shachaf says m̸͔̟͖̟̩͎̜̈́ͦ̽̕ͅe̪̟͉̰̼̮̞̳ͨͩ̿ͤr̵̷̼̼̙͎̗̯ͮ́͘ȉ̵̢̟̰̝̻́͊̔̄ͦ̚͠j̖̱͆̓͌̽̃͊̚͜n̟̗ͨ͗̀͝
05:53:14 <shachaf> Oops.
05:53:19 <mekeor> wtf :D
05:53:28 <merijn> Impressive, that actually takes up multiple vertical lines...
05:53:32 <knz> shachaf: feel welcome to propose your own
05:53:37 <shapr> shachaf: Wow, emacs is now really slow :-)
05:53:49 <shapr> But only in this buffer
05:54:29 <shapr> whew
05:54:38 <shachaf> shapr: Sorry!
05:55:01 <tdammers> shachaf: IPA is inadequate for Dutch pronunciation
05:55:50 <hiptobecubic> tdammers, not nearly enough choking and gurgling
05:56:26 <dmwit> timthelion: So, according to what I've just read, /these slashes/ are for phonemic (i.e. non-specific understandings of a set of sounds) and [brackets] are for phonetic (i.e. specific sounds).
05:56:37 <bitonic> shapr: uhm, my emacs is still fast.
05:56:46 <shachaf> bitonic: Let me help!
05:56:54 <dmwit> ...also, I've been talking to the wrong person this whole time.
05:56:59 <bitonic> shachaf: dump what you want on -blah :P
05:56:59 <dmwit> theorbtwo: That was aimed at you.
05:57:06 <mekeor> bitonic: mine, too
05:57:12 <schlicht> emacs! i'm thinking on trying it out. is it worth it? im using vim most of the time
05:57:25 <tdammers> hiptobecubic: look up the correct pronunciation of 'Scheveningen' for laughs
05:57:32 <mekeor> emacs sucks and is great at the same time
05:57:47 <bitonic> emacs is great and great at the same time
05:57:59 <timthelion> tdammers: IPA is an alphabet of phonemes(units of sound contrast) and then there are allophones(units of sound).  To describe pronunciation, you need a phonetic transcription.
05:59:13 <timthelion> schlicht: try it while you're young.  I had a crush on emacs, back in the days I should have been chasing girls.  Still have dreams of curvy parethesis gently caresing....  But she's a bit of a crazy freek once you get too maried to her.
05:59:27 <hiptobecubic> tdammers, Scheveningen deserves the name it got.
05:59:40 <mekeor> bitonic: is it possible to make a programming language which is lazy and has dependent types at the same time?
05:59:50 <bitonic> mekeor: of course
05:59:50 <mekeor> bitonic: or is that contradictional?..
05:59:55 <mekeor> oh, okay..
06:00:24 <schlicht> timthelion, i want other young programmers to look at me and ask : "how did she do that?!"
06:00:48 <timthelion> schlicht: she can kill you with your own mind.
06:00:54 <dmwit> Expertise in any of the major text editors can cause that reaction.
06:01:16 <bitonic> dmwit: what are the other major text editors?
06:01:25 * shachaf uses notepad.exe, one of the majorest text editors there are.
06:01:31 <timthelion> shachaf: reallyM
06:01:32 <timthelion> ?
06:01:32 <shachaf> I get that reaction all the time.
06:01:36 <dmwit> vim, eclipse, notepad++, sublime, etc.
06:01:38 <shachaf> Well... *Some* kind of reaction, at least.
06:01:41 <shachaf> @karma notepad
06:01:41 <lambdabot> notepad has a karma of 18
06:01:42 <shachaf> See?
06:01:44 <shachaf> Hmm.
06:01:47 <shachaf> @karma vim
06:01:47 <lambdabot> vim has a karma of -1
06:01:50 <shachaf> @karma emacs
06:01:50 <lambdabot> emacs has a karma of 0
06:01:52 <shachaf> @karma ed
06:01:52 <lambdabot> ed has a karma of 0
06:01:52 <bitonic> dmwit: notepad++ is major?  and sublime? mhm.
06:01:53 <shachaf> ed++
06:01:58 <shachaf> preflex: karma notepad
06:01:58 <preflex>  notepad: 4030
06:02:00 * dmwit shrugs
06:02:08 <bitonic> cat++
06:02:24 <tdammers> hiptobecubic: it's useful to have a name like that
06:02:31 <mekeor> there's a nice xkcd about that :
06:02:32 <tdammers> helps distinguish German tourists from locals
06:02:32 <mekeor> :D
06:02:34 * timthelion used scribes for a while.  Great, but not vim.  And a bit funky on the whole automatic saving after every character press thing...
06:02:49 <dmwit> timthelion: Was saving all the time a problem?
06:02:50 <mekeor> http://xkcd.com/378/ that one
06:02:54 <shachaf> Let's have no more editor discussion in here.
06:02:56 <dmwit> I've often wondered why editors don't just do that.
06:03:18 <bitonic> emacs saves all the time
06:03:18 <dmwit> Let's discuss editors until there's a Haskell question why not.
06:03:21 <tdammers> dmwit: because not everyone uses source control for everything
06:03:23 <bitonic> well save backups all the time
06:03:31 <schlicht> shachaf, i like it :)
06:03:39 <Egbert9e9> Where do I check to see which class a type is an instance of?
06:03:41 <dmwit> tdammers: Yes, I would want the editor to have robust undo if it implemented that feature.
06:03:49 <dmwit> tdammers: Like, robust even across restarts.
06:04:02 <bitonic> Egbert9e9: haddock docs, :info
06:04:03 <dmwit> tdammers: But then, I've often wondered why editors don't just do that, too. =)
06:04:03 <ion> I use source control for everything, but i also have hourly btrfs snapshots.
06:04:06 <timthelion> dmwit: it was.  But mostly just because it was buggy.  I'd forget something was open, edit it somewhere else, and it would save the OLD version over the new...
06:04:13 <Egbert9e9> bitonic: Thanks!
06:04:16 <shachaf> Egbert9e9: A type can be an instance of lots of classes.
06:04:19 <shachaf> Egbert9e9: :i in ghci, yes.
06:04:22 <dmwit> timthelion: oh, yuck
06:04:33 <dmwit> timthelion: Yes, you need to use inotify or similar for this to work, I guess.
06:05:02 <tdammers> dmwit: what if you're editing /etc/hosts?
06:05:04 * shachaf >>= sleep
06:05:10 <timthelion> dmwit: speaking of inotify, I saw that someone had that set up(in a haskell live coding vid) for ghci, that it reloads every time you save...
06:05:11 <mekeor> gnight
06:05:12 <bitonic> the best thing is to save often to a backup file.  which is what emacs does!
06:05:13 <timthelion> is that easy?
06:05:14 <Egbert9e9> shachaf: I wonder what is the class which enables unpacking, like fromJust :: Just a -> a
06:05:15 <ion> Drawing *what* out of shachaf, sleep it?
06:05:16 <dmwit> tdammers: what about it?
06:05:26 <shachaf> Egbert9e9: Please don't use fromJust. :-(
06:05:27 <tdammers> stuff may break.
06:05:33 <bitonic> Egbert9e9: comonad
06:05:34 <tdammers> processes relying on it and such
06:05:52 <dmwit> tdammers: I don't get it.
06:05:53 <zhulikas> fromJust is dangerious!
06:05:54 <bitonic> well comonad is too much actually, cofunctor or whatever
06:05:54 <Egbert9e9> shachaf: what is the reason?
06:05:56 <shachaf> Egbert9e9: And there's no such class, in general. Comonad (like bitonic mentioned) and some others will do it, but you don't want that.
06:05:59 <edwardk> you can't make a comonad for Maybe that is sound though
06:06:02 <bitonic> @hoogle extend
06:06:02 <Egbert9e9> bitonic: thanks again!
06:06:03 <lambdabot> System.Posix.Terminal ExtendedFunctions :: TerminalMode
06:06:03 <lambdabot> Text.Regex.Posix.Wrap compExtended :: CompOption
06:06:03 <lambdabot> Text.Regex.Posix.String compExtended :: CompOption
06:06:03 <edwardk> cofunctor = functor
06:06:05 <zhulikas> Egbert9e9, because it can throw an error
06:06:09 <zhulikas> use fromMaybe instead
06:06:11 <tdammers> what's wrong with fromMaybe?
06:06:13 <tdammers> heh
06:06:13 <shachaf> Egbert9e9: fromJust will crash your program if you give it a Maybe. With a useless error message, no less.
06:06:16 <dmwit> tdammers: Oh, now I get it.
06:06:18 <bitonic> edwardk: damn, right
06:06:26 <Egbert9e9> shachaf: ah, thanks
06:06:27 <marcot> My global index (Contents) of haddock documentation is, suddenly, missing a lot of modules.  I can still access the documentation on each package's index, but not on file:///home/marcot/.cabal/share/doc/index.html .
06:06:27 <ion> s/Maybe/Nothing/
06:06:35 <Egbert9e9> never use fromJust
06:06:39 <shachaf> Egbert9e9: If you're absolutely sure it won't be a Nothing, use "let Just x = ..."
06:06:49 <shachaf> That way you get line number information when your program crashes. :-)
06:06:58 <bitonic> shachaf: why is that better than `fromJust'?
06:07:02 <marcot> Do you know how could this have happened and how can I restore it?  For instance, Prelude is missing, but Prelude.Unicode from base-unicode-symbols is present.
06:07:14 <dmwit> tdammers: That's an interesting point that I hadn't considered! You might reasonably want to save certain files only when they're in a parsable state.
06:07:27 <Egbert9e9> actually, my type has no alternative to the packed type
06:07:40 <Egbert9e9> do I call that kind of general types "m a"?
06:07:48 <marcot> Can this be related to unsafe reinstalls?
06:07:52 <quicksilver> dmwit: more generally, you might have in mind a particular invariant which relates one or more files and you might intend only to save when that invariant holds.
06:07:56 <dmwit> tdammers: Still, I'd want "always save" to be the default and "save only when the user says so" to be the optional version.
06:08:06 <dmwit> quicksilver: Right.
06:08:09 <tdammers> dmwit: 'parsable state' is not enough
06:08:09 <quicksilver> dmwit: (parsability is a single-file exacmple of that)
06:08:17 <quicksilver> however, apple agrees with dmwit apparently :)
06:08:18 <bitonic> Egbert9e9: you call them "type constructors of kind `* -> *'" :)
06:08:30 <quicksilver> I think the compromise of saving regularly to a *different* file name is a reasonable one
06:08:49 <quicksilver> as used by many editors
06:08:58 <Egbert9e9> type constructors of kind `* -> *`, okay
06:09:03 <tdammers> agree.
06:09:38 <timthelion> quicksilver: I think the best compromise is never crashing.
06:09:53 <tdammers> timthelion: you can't control that
06:09:54 <Egbert9e9> BTW, the Trac system wants me to read cursive English as its captcha. I can hardly read cursive English.
06:09:57 <dmwit> pfft, crash-only software is much better
06:10:08 <Egbert9e9> I fail this mini-turing test.
06:10:21 <tdammers> if I zap X11, and take the xterm down that contains the shell that spawned the editor, there is nothing the editor can do about it
06:10:29 <timthelion> tdammers: no really, my computer almost never crashes unrecoverably...  Like once a month or less.
06:10:34 <Egbert9e9> GHC's Trac system, that is.
06:10:44 <timthelion> tdammers: screen
06:10:55 <timthelion> tdammers: keep vim in screen
06:11:12 <tdammers> screen introduces more annoyances than I am willing to accept for most usages
06:11:16 <bitonic> emacs backups + desktop saves + saveplace = win
06:11:18 <tdammers> (irssi in screen is nice though)
06:11:37 <Egbert9e9> for some reason, GHCi panics when I declare "data Woo = Woo Int deriving (show)" instead of "Show"
06:11:39 <dmwit> I'm with tdammers on this one. You can't count on never crashing.
06:11:43 <timthelion> tdammers: there is a smaller program with no hotkeys that has the same recovery feature, don't recall it's name
06:11:58 <quicksilver> dtach
06:12:04 <quicksilver> and see also tmux
06:12:10 <dmwit> Egbert9e9: Yes, it's a known bug (and fixed in the most recent GHCs).
06:12:12 <quicksilver> but, I think we've drifted off topic :)
06:12:24 <tdammers> the topic was 'ij', right?
06:12:36 <shachaf> The topic was * -> *
06:12:46 <timthelion> @type topic
06:12:47 <lambdabot> Not in scope: `topic'
06:12:54 <Egbert9e9> dmwit: aww, damn. No bug report for me :(
06:13:02 <dmwit> Egbert9e9: http://hackage.haskell.org/trac/ghc/ticket/5961
06:13:56 <timthelion> dmwit: There must have been more than one ticket for that,  because when I googled it I got one with (show) as the example
06:14:31 <dmwit> wouldn't surprise me
06:15:23 <dmwit> http://hackage.haskell.org/trac/ghc/ticket/6141 perhaps? this was marked as a duplicate of 5961
06:15:56 <timthelion> perhaps.
06:16:27 * timthelion found a bug in GHC caused by the fact that "head" errors out instead of Maybeing out.  Had to laugh a that...
06:20:34 <mekeor> "Maybe a" is isomorpic to "Either () a" :)
06:21:27 <dmwit> I've recently been enjoying the "how long can you go before converting that list to a Maybe?" challenge.
06:21:41 <dmwit> The answer has been "forever" more often than I expected.
06:22:01 <timthelion> dmwit: it's actually bad when you have to... It makes it a strict rather than a lazy list...
06:22:21 <bitonic> timthelion: uhu?  what do you mean?
06:22:24 <dmwit> ...what?
06:23:07 <timthelion> If I have to evaluate the entire list, in order to determin if the result is valid or not.  Then I have to evaluate the whole list to return even one element.
06:23:55 <timthelion> kind of tautological eh?
06:23:59 <bitonic> I don't follow.
06:26:19 <timthelion> bitonic: for example, If I have a lexer of type lex :: String -> [Token] and it is a single pass parser.  Then [Token] is a lazy list.  If I then decide I need pretty error messages.  Then my parse will return Either [Token] ErrorMessage.  [Token] can no longer be a truely lazy list, because I have to lex the whole file in order to figure out if it will be an Error message or a proper lexing.
06:26:22 <shapr> Agda is totalogical.
06:26:27 <dmwit> But why would you have to evaluate the entire list to return just one element from it?
06:26:42 <timthelion> dmwit: read what I just wrote
06:26:56 <dmwit> I'm talking about not doing "head" anywhere, even if it's "safeHead :: [a] -> Maybe a".
06:27:01 <dmwit> I don't know what you're talking about.
06:27:13 <timthelion> dmwit: ?
06:27:34 <timthelion> not doing head anywhere. now I don't know what you are talking about
06:29:49 <tdammers> timthelion: pattern-match on x:xs instead
06:29:53 <dmwit> Never mind, it was just an stupid side comment.
06:30:12 <neothemachine> Hi, as I'm diving more and more into Haskell I'm wondering about the guards used when defining a function. They seem useful but when you have common parts then you are forced to code duplication. Why can't this syntax be mixed with let etc.?
06:30:40 <dmwit> It can be mixed with where.
06:30:43 <bitonic> neothemachine: have you looked at PatternGuards?
06:31:00 <neothemachine> dmwit: oh, at the far end?
06:31:11 <dmwit> > let foo | y && z = 3 | y && not z = 4 | otherwise = 5 where y = True; z = False in foo
06:31:12 <neothemachine> bitonic: no, what's that?
06:31:13 <lambdabot>   4
06:31:31 <bitonic> neothemachine: it's not what you're asking for, but it probably solves some of your poblems.
06:31:36 <bitonic> @google haskell patternguards
06:31:39 <lambdabot> http://www.haskell.org/haskellwiki/Pattern_guard
06:31:40 <lambdabot> Title: Pattern guard - HaskellWiki
06:32:02 <neothemachine> interesting, ok I'll read up, thanks for now
06:32:05 <merijn> Where is prettier than let anyway :p
06:35:00 <neothemachine> ok one more question, what about assert statements? these can't be put into a where
06:37:26 <dmwit> Sure they can, as much as they can be put anywhere.
06:38:04 <dmwit> Maybe I should ask, "what is an assert statement?".
06:38:16 <om> can you guys help me with my emacs autocompletion for haskell, or should i take it to an emacs chatroom?
06:39:52 <shapr> om: maybe? What are you trying to do?
06:40:10 <neothemachine> dmwit: well I mean the assert function from Control.Exception, I could do something like... where x = assert (arg1 == 1) valueofx, but is this the right way? I mean, it doesn't have anything to do with x but the function arguments itself
06:40:16 <shapr> om: Also, are you using haskell-mode from more than six months ago, or are you using the more recent haskell-mode from github?
06:41:03 <nh2> I use hPutStr to write to a socket. Is that really what it is supposed to do, sending *1 byte* per TCP packet?
06:41:39 <dmwit> neothemachine: That seems fine to me. What does "it doesn't have anything to do with x but the function arguments itself" mean?
06:41:48 <om> shapr: i followed the information from this page: http://sritchie.github.com/2011/09/25/haskell-in-emacs.html
06:41:58 <nh2> I mean I am aware that [Char] is lazy, but I thought the String would be buffered somewhere before it is sent to the network
06:42:06 <iamtakin1iteasy> hi, how do i properly test if list has element that satisfies some predicate? i see two ways: use filter + length and use map + any. which one is better? or maybe there are even better ways?
06:42:07 <quicksilver> nh2: depends on all kinds of things including your OS, the speed of your net connection, the configuration of your network drivers, etc.
06:42:16 <yitz> nh2: use bytestrings
06:42:21 <neothemachine> dmwit: ok, what if I don't actually need the where part, but still want to have the assert for the function arguments and also use guards
06:42:26 <nh2> quicksilver: I use localhost
06:42:40 <quicksilver> you're most likely to see one-char packets with localhost, yes
06:42:57 <quicksilver> TCP windowing algorithms will tend to combine later packets
06:43:03 <quicksilver> on normal-latency links
06:43:16 <Clint> iamtakin1iteasy: why would you need map with any?
06:43:20 <quicksilver> admittedly yitz has given you the practical answer :)
06:43:29 <mekeor> is "data Empty" valid haskell2010?
06:43:35 <shapr> om: ok, so you're probably using the >6 months old version. What's the problem?
06:43:38 <tdammers> iamtakin1iteasy: I'd use not . null . filter or something
06:44:05 <om> shapr: the autocompletion is working for everything except haskell
06:44:08 <tdammers> length requires fully evaluating the list, null doesn't
06:44:12 <iamtakin1iteasy> Clint: how else do i apply predicate to each element of list and see if any of them came up with True value?
06:44:15 <dmwit> neothemachine: I'm still not sure I see the problem. You can write an assert in a where clause and use the variable you've just bound to the assert anywhere you could have put the assert without binding it to a name.
06:44:21 <iamtakin1iteasy> tdammers: thank you!
06:44:23 <nh2> yitz, quicksilver: yes, that would change the behaviour, I don't really consider what I just found a problem, but I'd like to understand how this happens
06:44:25 <shapr> om: What sort of autocompletion?
06:44:29 <nh2> although I think I just found it
06:45:06 <shapr> om: dabbrev?
06:45:09 <om> shapr: http://cx4a.org/software/auto-complete/index.html this
06:45:25 <Clint> iamtakin1iteasy: any :: (a -> Bool) -> [a] -> Bool
06:45:38 <iamtakin1iteasy> ohh
06:45:56 <nh2> I use NoBuffering, and with that the implementation is indeed: hPutChars handle (c:cs) = hPutChar handle c >> hPutChars handle cs
06:45:59 <iamtakin1iteasy> i confused 'any' and 'or'
06:46:02 <iamtakin1iteasy> sorry
06:46:09 <nh2> good to know
06:46:11 <iamtakin1iteasy> and yeah, any is best shot
06:46:13 <iamtakin1iteasy> %)
06:46:22 <iamtakin1iteasy> Clint: thank you!
06:46:54 <shapr> om: Wow, I've never seen that before. Looks awesome, and I'd guess you need some way to feed it tokens...
06:46:56 <tdammers> heh, yeah
06:47:00 <tdammers> what Clint said
06:47:59 <hpaste> neothemachine pasted “guards with assert” at http://hpaste.org/73167
06:48:00 <yitz> om: what's going wrong with haskell?
06:48:14 <om> yitz: it's not autocompleting
06:48:21 <yitz> om: and yes, if it works for everything except haskell, sounds like this is going to be the right channel :)
06:48:27 <neothemachine> dmwit: I made a sample, have a look
06:48:54 <om> here's my .emacs: http://pastebin.com/CLjaCZwE
06:48:56 <mauke> The paste CLjaCZwE has been copied to http://hpaste.org/73169
06:49:07 <zhulikas> CLjaCZwE
06:49:10 <zhulikas> that sounds like a polish word :D
06:49:19 <yitz> om: why not? it's not getting any tokens? have you tried debugging?
06:49:43 <hpaste> dmwit annotated “guards with assert” with “guards with assert (annotation)” at http://hpaste.org/73167#a73170
06:49:47 <om> i don't know how to debug emacs lisp
06:49:53 <yitz> zhulikas: oh oh. i hope it's not something inappropriate for this channel.
06:49:56 <shapr> om: do you know if that autocomplete can read TAGS files?
06:50:00 <byorgey> neothemachine: yes, that is indeed awkward.  But the reason it is awkward is because of assert, which is used only for its side effects.
06:50:35 <byorgey> neothemachine: it should not be surprising that apparently pure functions which actually have operational side effects are awkward to use in Haskell.
06:50:44 <om> shapr: i don't think so, it just has some *-dict files in a folder
06:50:46 <byorgey> neothemachine: the better question is -- why are you using assert?
06:50:55 <neothemachine> why not?
06:51:40 <neothemachine> what's the alternative? I thought it might be good to have some checks in place which can then eliminated by the compiler easily
06:51:49 <byorgey> because it is extremely un-Haskelly.  it goes against the whole style and philosophy of the language.
06:51:52 <byorgey> neothemachine:
06:52:07 <byorgey> neothemachine: if you want some checks, use QuickCheck to test your functions externally.
06:52:24 <tdammers> the haskelly way would be to use the type system to enforce invariants
06:52:52 <byorgey> indeed, though enforcing things like  a > 1 && b > 2  with the type system is awkward to say the least
06:53:17 <neothemachine> yeah.. I don't really want to do peano numbers and so on
06:53:17 <tdammers> but then again, why would you need to enforce such constraints?
06:53:34 <shapr> om: so the docs imply you just need to make your own dictionary: http://cx4a.org/software/auto-complete/manual.html#Major_Mode_Dictionary_and_Extension_Dictionary
06:53:55 <neothemachine> to document the invariants and check for programming errors
06:53:59 <tdammers> I'd say even pattern-matching into an exception would be a nicer solution than to emply side effects
06:54:08 <neothemachine> I thought that was the reason for having assert, also in other languages
06:54:15 <byorgey> (though actually, soon GHC is going to get efficient type-level natural numbers with equality and inequality and basic arithmetic.  but that's not really relevant here. =)
06:54:19 <shapr> om: Although if you want excitement, the most recent version of haskell-mode automatically builds a TAGS file and you could dynamically build intellisense completion with that.
06:54:20 <yitz> om: ahh. i thought you were the author of autocomplete :) ok. well, i see from the source code that it has a a dictionary file with keywords for each language it supports
06:54:48 <tdammers> s/emply/employ/
06:54:50 <yitz> om: but haskell isn't there. (look in the dict directory)
06:54:55 <byorgey> neothemachine: documenting invariants and checking for programming errors is wonderful, of course.
06:55:07 <yitz> shapr: that list of keywords is what you call a TAGS file?
06:55:15 <byorgey> neothemachine: I'm simply suggesting that 'assert' is not the best mechanism for that in Haskell.
06:55:23 <shapr> yitz: Are you familiar with etags/ctags?
06:55:23 <byorgey> neothemachine: instead, use QuickCheck.
06:55:46 <yitz> shapr: no.
06:55:49 * shapr cheers for QuickCheck
06:56:02 <byorgey> hip hip!
06:56:07 <shapr> yitz: a TAGS file is the top level definitions in a file
06:56:14 <mekeor> hooray!
06:56:19 <yitz> QuickCheck++
06:56:23 <shapr> yitz: http://en.wikipedia.org/wiki/Ctags
06:56:28 <yitz> @karma QuickCheck
06:56:29 <lambdabot> QuickCheck has a karma of 1
06:56:59 <om> yitz: i know there isn't a haskell dictionary in there, but this site http://sritchie.github.com/2011/09/25/haskell-in-emacs.html says where you can get an .el file that acts like a dictionary
06:57:30 <om> yitz: more specifically, this file: https://gist.github.com/1241063
06:57:39 <donri> @karma C
06:57:40 <lambdabot> C has a karma of 1
06:58:27 <shapr> om: oh that's neat
06:58:30 <om> yitz: i placed it in my .emacs.d directory and required it just like it says on the site
06:58:50 * mekeor laughs at Data.Monoid.Dual
06:59:11 <byorgey> mekeor: why?
06:59:35 <neothemachine> the problem with test frameworks is that sometimes you need to make internals public if you want to test them, right?
06:59:55 <yitz> om: it doesn't look like that file is in the right format. but you could probably use that to create an appropriate dict file for haskell.
07:00:05 <shapr> neothemachine: You can put QuickCheck tests inside the source module in that case.
07:00:06 <mekeor> byorgey: why not just use (flip mappend) instead of defining a whole new type?
07:00:47 <byorgey> neothemachine: yes, but when that is an issue what I do is have one module which exports everything, and then another module which only re-exports the public API
07:00:51 <om> yitz: ok i'll try
07:01:02 <quicksilver> mekeor: to use other polymorphic monoid combinators or libraries.
07:01:10 <yitz> donri: interesting, someone must have zeroed out that karma, or perhaps lambdabot automatically does it every once in a while now.
07:01:21 <mekeor> quicksilver: aaah...! okay
07:01:25 <quicksilver> mekeor: "fold" from Data.Foldable springs to mind for the former, and Data.Fingertree for the latter.
07:01:46 <byorgey> neothemachine: this approach has other benefits too (it makes more complete documentation of the internals available, and allows power users to get access to the internals if they want)
07:01:47 <yitz> om: if you do, please let us know here, and also submit it to the auto-complete author
07:01:48 <quicksilver> arranging your fingertree with the Dual measure would give something quite different.
07:02:00 <om> ok
07:02:11 <mekeor> quicksilver: okay, so it's to make other functions, which use mappend, flip the arguments, right? okay, got it.
07:02:29 <quicksilver> yes.
07:02:35 <aristid> seriously, these days there isn't a whole lot of difference between conduits and pipes. they even share some weaknesses :D
07:02:44 <byorgey> mekeor: right, it's for anything where you want mappend to be chosen in a type-directed way.
07:02:56 <neothemachine> byorgey: i see, seems like a good compromise
07:03:01 <donri> preflex: karma C
07:03:02 <preflex>  C: 193403
07:03:12 <yitz> donri: ahh, there we go
07:03:14 <byorgey> mekeor: actually I think that *most* of the time when I use mappend, I am not calling it directly, but calling something else which eventually calls mappend
07:03:16 <donri> ^_^
07:03:28 <byorgey> mekeor: so I do not have a choice of whether to use mappend or flip mappend.
07:03:29 <yitz> preflex: karma QuickCheck
07:03:29 <preflex>  QuickCheck: 11
07:03:30 <mekeor> byorgey: yu
07:03:37 <mekeor> byorgey: yup
07:05:35 <ocharles> if anyone is on OS X 10.6, could you do me an off-topic favour, and check if `head` accepts the -c parameter?
07:06:25 <merijn> ocharles: Mine says yes
07:06:27 <yitz> ocharles: yes it does
07:06:43 <quicksilver> byorgey: in fact, if htat's not the case, the type class isn't very useful.
07:06:43 <merijn> ocharles: Actually, I'm on 10.7 I just realised. But I don't suspect it changed
07:06:53 <sinelaw> I'm having trouble figuring how to traverse a tuple-based heterogenous list
07:07:00 <byorgey> quicksilver: indeed, good point.
07:07:08 <sinelaw> i.e. (a, (b, (c, ... , z, ((), ())))..))
07:07:15 <quicksilver> byorgey: (for example, this is why Arrow isn't a very useful typeclass - there aren't that many general purpose combinators which work on generic arrows)
07:07:26 <merijn> sinelaw: Pattern matching seems the only real option?
07:07:33 <quicksilver> before the arrow-fans attack me, I'm not saying "none" :-)
07:07:37 <quicksilver> just not very many.
07:08:01 <merijn> I dunno, *** and &&& are pretty nifty
07:08:17 <byorgey> quicksilver: true, though I would say there is still some value in not having to come up with a new set of names for the arrow operations on every different type.
07:08:54 <sinelaw> merijn: actually traversing is not the problem, need to rephrase
07:08:55 <quicksilver> merijn: they are methods not geenral purpose combinators.
07:09:04 <quicksilver> merijn: you have to *write* those to make the instance :)
07:09:23 <merijn> quicksilver: Ah, right
07:09:25 <quicksilver> when was the last time you, merijn, personally used *** or &&& on an arrow other than (->).
07:09:28 <quicksilver> ?
07:09:45 <merijn> I don't think I ever used non (->) arrows, period :p
07:09:48 <quicksilver> right.
07:09:55 <quicksilver> that's part of my point.
07:10:01 <quicksilver> byorgey: yeah, definitely some value.
07:10:08 <quicksilver> byorgey: but the real win is the polymorphic algorithms.
07:10:13 <quicksilver> byorgey: 'mapM' being a great example.
07:10:17 <merijn> Although I've started to develop some ideas for abusing arrows in the future :p
07:10:26 <byorgey> quicksilver: sure, I agree with you there.
07:10:30 <quicksilver> and traverse being a more 'modern' good example.
07:12:23 <hpaste> dmwit annotated “guards with assert” with “guards with assert (another shot)” at http://hpaste.org/73167#a73171
07:13:03 <dmwit> neothemachine: I've made another suggestion, if you're still here and still care.
07:13:33 <zhulikas> :t assert
07:13:34 <lambdabot> Not in scope: `assert'
07:13:42 <zhulikas> @hoogle assert
07:13:43 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
07:13:43 <lambdabot> Control.Exception assert :: Bool -> a -> a
07:13:43 <lambdabot> Control.OldException assert :: Bool -> a -> a
07:14:03 <dmwit> I like byorgey's suggestion of quickcheck, but the question is more general than just "how do I use assert" anyway.
07:14:19 <dmwit> You can use this any time you want to do some post-processing, whether that's an assertion or something else.
07:14:32 <byorgey> oh, nice dmwit
07:16:48 <sinelaw> can I use existential types without constraining them to any typeclass?
07:17:05 <dmwit> That depends on what "use" means.
07:17:07 <byorgey> sinelaw: yes, but then they are useless.
07:17:15 <dmwit> Practically speaking, the answer is "no".
07:17:28 <sinelaw> because i know nothing abuot the type, right?
07:17:31 <byorgey> if you don't know anything about the type of some value, then you can't do anything with that value.
07:17:33 <dmwit> right
07:17:34 <sinelaw> *about
07:19:03 <neothemachine> dmwit: sorry was away, I like that!
07:19:32 <sinelaw> I'm trying to do some funky strongly typed stuff in c# and thinking how I would do it in Haskell makes it much easier
07:20:41 <sinelaw> can I use existentials in typeclass methods?
07:21:37 <frerich> dmwit: Hm, out of curiosity: if one wanted to move the burden of making sure that those constraints in the assert() are met to the caller, one could use dedicated types which only allow values 'Greater than 1' or so. Do you think that template haskell could be used to quickly whip up something like a 'newtype' for Int or so (with a smart constructor enforcing the constraint)?
07:21:41 <byorgey> sinelaw: what do you mean?
07:22:03 <sinelaw> class Test a where Bla :: Test b => a - > b
07:22:51 <dmwit> frerich: Probably, though I don't suppose it would be all that much more convenient than just writing the code yourself (since there's so little).
07:23:04 <frerich> dmwit: Something like 'Clamped<Int, (>1)>' resulting in 'newtype Something = Something Int' and 'makeSomething :: Int -> Something' with 'makeSomething i = assert ((>1) i) i' or so.
07:23:10 <dmwit> "Can I use Template Haskell for X?" "...well, yeah, probably, if you mash it hard enough."
07:23:32 <frerich> dmwit: Hm, I see.
07:23:36 <ocharles> makeSomething :: Int -> Maybe Int
07:26:29 <merijn> "newtype SafeInt = SafeInt Int" "makeSafeInt :: Int -> Maybe SafeInt" makes more sense
07:26:59 <byorgey> sinelaw: that is not an existential.
07:27:27 <Athas> Is there a reason why the syntax for infixing via backquoting only permits backquoting a plain variable?
07:27:33 <neothemachine> dmwit: I guess that's the best we can get with current haskell, but in the end guards are just sugar for ifthenelse, right? That's why I'm wondering that there use is so constrained, why not something like: test a b c = assert (a>1) $ | a == 1 = 2 | b == 2 = 2
07:27:47 <byorgey> sinelaw: that is  bla :: forall b. Test b => a -> b,  i.e. the caller of bla gets to choose the type it returns.
07:27:49 <Athas> There have been times where I would like to write x `f z` y.
07:27:54 <merijn> Athas: You mean "why doesn't it allow partially applied expressions"?
07:27:55 <sinelaw> byorgey: hmm, right
07:28:00 <merijn> Athas: Parsing simplicity, I bet
07:28:09 <scshunt> ^
07:28:24 <merijn> Athas: Fully general parsing of partial expressions in backquotes seems a bitch to implement
07:28:25 <byorgey> sinelaw: if you want bla  to be able to choose the return type, you can create an existential wrapper type (just like you would anywhere, this has nothing really to do with type classes specifically)
07:28:25 <Athas> merijn: yes, clearly you don't want the nonsense of nested backquoting, but it seems like it would be simple enough to expand it slightly.
07:28:29 <dmwit> neothemachine: See the MultiWayIf language extension available in GHC 7.6.
07:28:37 <merijn> Especially considering since you can just where/let the partial expressions
07:29:06 <byorgey> sinelaw:   data Testable = forall b. Test b => Testable b;   class Test a where  bla :: a -> Testable
07:29:09 <neothemachine> dmwit: haha, if it doesn'
07:29:09 <merijn> Athas: I think it is one of those things where no one will stop you if you implement it, but no one is motivated to invest the effort
07:29:19 <neothemachine> t work, there's an extension..
07:29:49 <sinelaw> byorgey: i see
07:29:51 <dmwit> neothemachine: Anyway, guards are not just sugar for if/then/else.
07:30:37 <dmwit> neothemachine: You can think of equals signs as being a "commit point" -- once you cross the sign, you never go back and choose a different equality to use.
07:30:49 <quicksilver> Athas: `(f x)` has been suggested more than once
07:30:50 <dmwit> neothemachine: Guards come before the equals sign, and can control which sign you cross.
07:31:03 <dmwit> neothemachine: if/then/else comes after the equals sign, and therefore after the "commit point".
07:31:17 <quicksilver> (that is, use parens as well as the backquotes to make parsing unambiguous
07:31:19 <dmwit> If the if doesn't match -- tough, you're never going to get to use a different defining clause.
07:31:24 <merijn> dmwit: I think he means that they (semantically) just map to nested if/else statements
07:31:39 <merijn> Which is true
07:32:14 <quicksilver> they're a conceit - like list comprehensions - designed to make haskell definitions look like math definitons
07:32:18 <quicksilver> for some simple cases.
07:32:22 <EvanR_> hello citizens of haskelldom
07:33:19 <Athas> Hello.
07:33:20 <quicksilver> not entirely unrelated syntactically to list comps, too. "concat $ [ foo | bar ] ++ [ baz | bam ] ++ [ otherwise | error "no guard matched" ]
07:36:00 <neothemachine> well, I guess I'll leave it at it for the moment, and use the where construct if I really need it and otherwise quickcheck
07:49:11 * hackagebot minimorph 0.1.1.0 - English spelling functions with an emphasis on simplicity. (EricKow)
07:51:42 <dmwit> hackagebot was a great idea. I learn about all kinds of packages I would have otherwise never even have thought to ask for.
07:54:11 <timthelion> Is it possible to find out if anyone has installed a given package from hackage?
07:54:37 <dmwit> There are download stats somewhere, but I think you have to have certain powers to view them.
07:54:39 <danr> timthelion: how do yau mean? so I could check what packages you personally have installed?
07:54:43 <danr> you*
07:55:05 <dmwit> dons used to post such stats once in a while.
07:55:40 <timthelion> danr: no, like to see how many people have downloaded a given package
07:56:15 <paolino> hello, I'm trying to make  function [STM (IO ())] -> IO (). I arrived to join . liftM sequence_ . atomically . sequence . It should collect all SMT results, and execute them in IO. Is that correct ?
07:56:48 <dmwit> Looks fine. Do you definitely want all the actions to run in the same transaction?
07:56:56 <LadyAurora> @pl (\a b c -> if c then a else b)
07:56:57 <lambdabot> flip . flip if'
07:57:02 <timthelion> dmwit: ok, so I take it that it's no longer availiable.  Dons being eaten by a bank was a huge loss to the comunity.
07:57:18 <quicksilver> :t join . liftM sequence_
07:57:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [m a] -> m ()
07:58:10 <paolino> dmwit, yes, good question, I'm thinking about it
07:58:19 <LadyAurora> @pl (\x -> (flip . flip if') (return 5) (return 7) . (>= 0.5) =<< return 0.6)
07:58:20 <lambdabot> const (flip (flip if' (return 5)) (return 7) . (>= 0 . 5) =<< return 0 . 6)
07:58:35 <LadyAurora> lol bug
07:59:09 <LadyAurora> Look at the numbers. Or what's left of them.
07:59:14 <dmwit> timthelion: Yes, it was. Here's the most recent post I could find with this stuff, if you want it: http://haskellwebnews.wordpress.com/2011/03/16/hackage-stats-the-past-year/
07:59:41 <paolino> dmwit, if one of them retries I have no IO at all, everything pause
07:59:45 <dmwit> LadyAurora: That's a funny one. Here's another:
07:59:49 <dmwit> ?pl [x | x <- [1..5]]
07:59:50 <lambdabot> [x | x <- [1..5]]
07:59:59 <dmwit> ?pl \s -> [x | x <- s]
08:00:00 <lambdabot> return . ((x | x) <-)
08:00:12 <LadyAurora> lol
08:00:42 <bitonic> rewriting pl might be a nice weekend project
08:00:43 <dmwit> paolino: Yes, if one of them retries, the entire transaction will wait until another transaction changes one of the variables it has touched.
08:01:56 <ion> @type (sequence_ =<<) . sequence . liftM atomically
08:01:58 <lambdabot> Not in scope: `atomically'
08:02:18 <dmwit> paolino: I suspect you more likely want to map something like (forkIO . atomically) across the list first, then massage the results.
08:02:29 <quicksilver> yes, rewrite pl to use its current rewrite rules but with the parser replaced by haskell-src-exts
08:04:00 <paolino> dmwit, no, all collective changes and single decisions must happen before any IO
08:04:24 <timthelion> why not simply have pl rewrite pl?
08:04:40 <LadyAurora> lol
08:06:42 <paolino> dmwit, the point should be banning the retring ones, maybe
08:06:55 <dmwit> uh
08:07:00 <paolino> *retrying
08:07:43 <dmwit> Okay, there's a few things to touch on here.
08:08:04 <dmwit> First: mapping (forkIO . atomically) doesn't run *any* of the IO actions returned (yet).
08:08:24 <dmwit> So you can still wait until all the transactions finish before running the actions they return.
08:08:42 <paolino> but I loose precedences
08:08:49 <dmwit> precedences?
08:08:58 <paolino> it's a list
08:09:21 <quicksilver> 7
08:09:22 <dmwit> I still don't understand. Can you explain a tad more, please?
08:09:26 <quicksilver> ooops :)
08:09:45 <paolino> it's a list of STM actions and the order matters
08:11:02 <dmwit> To be clear: you want the first action to complete before the second begins (ignoring for a moment whether the first and second action are in the same transaction or not)?
08:11:18 <dmwit> Or: you want the IO action returned by the first action to run before the IO action returned by the second action?
08:12:41 <paolino> dmwit, I have to make also my mind clear, sorry.  All STM action must execute in that order, then all IO actions in the same order
08:13:22 <dmwit> Okay. Then I agree that forkIO is a bad idea. =)
08:14:17 <timthelion> It's tricky sometimes to come up with names for things.
08:14:33 <dmwit> So, I think the questions so far have narrowed the choices down to the one you proposed and the one-transaction-per-action version.
08:15:01 <timthelion> Now I have a list of functions, and so of course I have their assiciated Types.  And now I have different kinds of functions.  But the word "Kind" is taken already.
08:15:15 <dmwit> timthelion: You know the famous quote. "There's only two difficult things in computer science: cache coherence and naming."
08:15:41 <timthelion> What other synonyms for Type are there?  Is it OK if I use Czech words in English language source code if I've run out of english words?
08:15:53 <timthelion> dmwit: cache coherence?
08:16:02 <prophile> dmwit: and off by one errors
08:16:07 <dmwit> "sort" is commonly the next level up from kind
08:16:09 <quicksilver> I'm sure that's up to you, timthelion
08:16:11 <timthelion> prophile: haskell fixed that.
08:16:17 <quicksilver> kind/sort/variety/category
08:16:25 <timthelion> quicksilver: thanks
08:16:46 <frerich> Flavour!
08:16:56 <timthelion> frerich: good one
08:17:13 <dmwit> http://en.wikipedia.org/wiki/Cache_coherence
08:17:23 <shapr> Wasn't there a recent research paper on scaling Haskell up to 18 cores or so?
08:17:31 <timthelion> frerich: So I have emediately evaluated IO flavoured functions, and possibly evaluated IO flavored functionss...
08:18:02 <ion> 18? Why that number?
08:18:38 <timthelion> shapr: is scalling haskell really so hard?  At first, I thought GHC magically knew how to parralelize maps and such over multiple cores, then I heard about the monad-par package and I was confused....
08:19:17 <frerich> timthelion: I would call the "immediately evaluateD" ones "vanilla flavoured functions", for the fun of it. For symmetry, the "possibly evaluated ones" could be chocolate.
08:19:25 <shapr> timthelion: scaling anything is hard with many cores.
08:20:00 <timthelion> frerich: you must write comments from hell
08:20:00 <paolino> dmwit, I'm going nuts, but all the STM actions will run in the same thread, right ? So the only way to fail is that they explicitly retry ?
08:20:24 <paolino> s/fail/don't commit
08:20:59 <timthelion> shapr: but at least with a map, we know that doing each evaluation seperately (in arbitrary order) is the SAME as doing them in imperitive order.  So GHC should just be able to "figure it out"...
08:21:05 <frerich> timthelion: The right metaphor can make understanding code much easier than any comment could! Granted, vanilla vs. chocolate isn't the best idea...
08:21:11 <shapr> timthelion: monoids?
08:21:51 <timthelion> dmwit: Cache coherence seems like a great place in implement lazyness.  Instead of trying to synchronise the data in real time, why not just have a "changed" bit.  And if that bit was set, then th CPU would go searching for up to date information lazilly"
08:22:15 <shapr> timthelion: That's roughly transactional memory done in hardware.
08:23:42 <timthelion> in other news.  Why is THIS a million dollar question:  I have two MVars, and I would like to wait for ONE of them to be filled.  And I'd like to start processing after that one has been filled, causing no effect to the seccond.
08:24:19 <timthelion> I tried doing this by forking two threads, and having the one that get's it's MVar filled first kill the seccond before it could "take" it's MVar.
08:24:24 <timthelion> But that's a race condition.
08:24:51 <paolino> that's n orElse in STM
08:25:18 <timthelion> paolino: I thought that.  But orElse has such an awful name, I didn't want to touch it.
08:25:34 <shapr> Is there something about scaling STM or other single Haskell binary that's more recent than 2009?
08:25:57 <timthelion> paolino: plus, have you looked at
08:26:01 <timthelion> @type orElse
08:26:03 <lambdabot> forall a. Maybe a -> Maybe a -> Maybe a
08:26:12 <timthelion> lambdabot: WRONG!
08:26:41 <dmwit> paolino: Maybe post some code?
08:26:53 <timthelion> http://hackage.haskell.org/packages/archive/stm/latest/doc/html/Control-Monad-STM.html#v:orElse
08:27:10 <dmwit> timthelion: Your scheme has been done, 30 years ago, and improved upon steadily since then.
08:27:17 <timthelion> It's type is fine I guess. But it's description confused the heck out of me.
08:27:26 <timthelion> dmwit: the race condtion one?
08:27:44 <dmwit> timthelion: No, your cache coherence one. The race condition one is easy.
08:28:00 <dmwit> Here's the solution: create a third MVar, and have your two forked threads both write into it.
08:28:14 <timthelion> dmwit: if the two MVar problem is so easy, then why can't I figure it out? :(
08:28:40 <dmwit> I don't know. Don't you like my proposal?
08:29:21 * timthelion goes searching the history for dmwit's proposal
08:29:22 <quicksilver> well timthelion's problem lacked context
08:29:41 <dmwit> My proposal is at 11:27, approximately 30s after "the race condition one is easy".
08:29:54 <LadyAurora> Why does this code fail to compile? http://hpaste.org/73178
08:30:04 <quicksilver> is this the only use of these MVars? or do we need to leave them in a certain state afterwards?
08:30:07 <parcs`> timthelion: use stm
08:30:13 <dmwit> (In fact, instead of three mvars, you probably just want one, and change whatever is writing into two different mvars to write into the one instead.)
08:30:16 <timthelion> dmwit: that proposal won't work.
08:30:43 <Cale> timthelion: orElse has pretty much exactly the name it ought to have, I would think :)
08:30:45 <quicksilver> LadyAurora: you need to fix the type somewhere.
08:30:53 <dmwit> timthelion: Are you going to explain why?
08:30:56 <timthelion> dmwit: the problem with that, is that we may have more than one fork.  We don't want to end up in the situation, where we have one system wide mvar with 1000 purposes.
08:30:59 <dmwit> ah
08:31:03 <dmwit> I just wasn't patient enough.
08:31:04 <LadyAurora> quicksilver: yeah, but where?
08:31:21 <dmwit> Yes, that's a good reason not to have them all write to one MVar.
08:31:37 <timthelion> Cale: but OrElse isn't what I want.  If it's waiting for A to retry before even looking at B it has nothing to do with this problem.
08:31:39 <dmwit> But the original proposal should work just fine, no?
08:31:58 <quicksilver> LadyAurora: (0.0 :: Double ) on the first first 0.0, I would suggest
08:32:15 <timthelion> dmwit: the orElse one sounds fine in SPJ's speach about STM, but I cannot figure out how it's actually supposed to work.
08:32:28 <LadyAurora> quicksilver: lol yeah, thanks, it works.
08:32:28 <dmwit> Specifically, the original proposal is: "create a third MVar, and have your two forked threads both write into it".
08:32:31 <Cale> timthelion: Okay, I don't actually know about your problem, because I haven't read all the context.
08:32:43 <timthelion> dmwit: that's what I'm doing.  It's a race condition
08:32:48 <dmwit> what
08:32:58 <quicksilver> LadyAurora: the problem is that in that invocation of uniform, which yields preswapTest, the only thing you do with preswapTest is compare it to the literal 0.5
08:33:00 <dmwit> Now I'm confused.
08:33:11 <quicksilver> LadyAurora: so nothing forces it to be any particular instance of Fractional.
08:33:45 <dmwit> timthelion: I'm going to post some code. You tell me what the race condition is.
08:33:46 <roconnor_> > show 0.0
08:33:48 <lambdabot>   "0.0"
08:33:56 <timthelion> If thread1 is waiting for firstMVar , and afterwards writes to mvarShared...  And thread2 is wainting for seccondMVar and afterwards writes to mvarShared. What happens to thread2 when firstMVar get's filled?
08:34:03 <timthelion> dmwit: cool :)
08:34:09 <roconnor_> quicksilver: where did LadyAurora's defaulting go?
08:34:14 <quicksilver> roconnor_: defaulting only works when all the typeclasses involved are in the magic anointed set.
08:34:25 <quicksilver> roconnor_: LadyAurora's type had a 'Uniform' constraint too
08:34:32 <roconnor_> ah
08:34:38 <quicksilver> sorry, a Distribution Uniform constraint
08:34:41 <LadyAurora> quicksilver: ah, makes sense.
08:34:44 <parcs`> timthelion: orElse doesn't wait for A, it waits for A or B
08:34:50 <quicksilver> the error message is dire though,
08:35:17 <dmwit> Oh, I get it.
08:35:17 <timthelion> parcs`: then the haddock description is severely wrong
08:35:39 <SebastienGllmt> That's it guys
08:35:42 <SebastienGllmt> I give up on trees
08:35:44 <timthelion> parcs`: http://hackage.haskell.org/packages/archive/stm/latest/doc/html/Control-Monad-STM.html#v:orElse
08:35:45 <dmwit> So, yeah, you probably want something a tad more compositional than MVars (like TVars).
08:35:45 <SebastienGllmt> I'm ragequitting to bed
08:35:58 <SebastienGllmt> 'night
08:36:50 <parcs`> timthelion: what's wrong with the descrition?
08:36:55 <dmwit> timthelion: Your assertion, "If it's waiting for A to retry before even looking at B it has nothing to do with this problem." is incorrect, I think.
08:37:07 <timthelion> Compose two alternative STM actions (GHC only). If the first action completes without retrying then it forms the result of the orElse. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the orElse as a whole retries.
08:37:21 <dmwit> timthelion: When taking from a TMVar, an empty TMVar immediately retries.
08:37:30 <timthelion> parcs`: it says that the seccond action isn't even looked at untill the first "retry"s
08:37:30 <LadyAurora> quicksilver: just like usual, GHC error messages are bad.
08:37:40 <timthelion> dmwit: ah.
08:37:49 <quicksilver> LadyAurora: some are better than others :) that one is bad.
08:38:16 <timthelion> dmwit: doesn't this lead to a bit of a loop?  you know, CPU inefficeint?
08:38:27 <dmwit> timthelion: "retry" does not mean "busywait".
08:38:37 <timthelion> dmwit: How does it work then?
08:38:39 <Cale> timthelion: Retries happen when one of the things which was read on the way to the retry is written to.
08:38:44 <dmwit> timthelion: It means "abort, and tell the runtime to wake me up when one of the variables I've touched so far in my transaction changes".
08:38:53 <neothemachine> oh man...
08:39:05 <Cale> neothemachine: what's up?
08:39:13 <timthelion> very interesting deffinition of "retry"
08:39:23 <neothemachine> Cale: I hate exceptions :D
08:39:29 <dmwit> It means "retry, but not until it's worth trying again".
08:39:36 <parcs`> timthelion: anyway 'atomically (readTMVar a <|> readTMVar b)' will do exactly what you want
08:39:52 <dmwit> right
08:40:00 <timthelion> @type atomically
08:40:01 <lambdabot> Not in scope: `atomically'
08:40:21 <parcs`> er, takeTMVar is probably more efficient
08:40:28 <dmwit> (This kind of compositionality is pretty much the raison d'etre of STM.)
08:40:29 <neothemachine> Cale: "*** Exception: Map.find: element not in the map" and even with :set -fbreak-on-exception and :trace I just get "Empty history. Perhaps you forgot to use :trace?"
08:40:57 <neothemachine> I just don't know where I should look at, how do people do that in big code bases?
08:40:59 <dmwit> neothemachine: I have a StackOverflow answer lying around here talking about this problem, one moment...
08:41:21 <Cale> neothemachine: How many times in your program are you calling Map.find? Replace them with Map.findWithDefault with a more specific error message.
08:41:26 <timthelion> parcs`: that's for when the two TVars are of the same type.  Anyways I can get an Either a b out of that given TVar a and TVar b?
08:41:52 <dmwit> neothemachine: http://stackoverflow.com/questions/10838785/find-the-source-of-an-haskell-exception/10839334#10839334
08:41:54 <Athas> Is there a merge function of type '[a] -> [a] -> [a]' that merges two sorted lists into one?
08:41:54 <Cale> Or wait, what Map is this?
08:42:01 <parcs`> timthelion: sure, Left <$> takeTMVar a <|> Right <$> takeTMVar b
08:42:11 <neothemachine> Cale: actually never, although "!" is probably the same as find, and this method doesn't even get called
08:42:16 <dmwit> eh, I meant to link to the question, not the answer
08:42:18 <dmwit> but whatever
08:42:30 <neothemachine> dmwit: I'll see
08:42:31 <timthelion> parcs`: cool, thanks :)  So does this mean, I should just start using TVars now, and depricate my use of MVars entirely?
08:42:51 <timthelion> or is there a hidden TVar tax?
08:42:54 <quicksilver> for this kind of compositionality they are great
08:43:09 <quicksilver> however you do need to understand under what circumstances they can block
08:43:11 <parcs`> yeah you'll want to use stm for the use case you've described
08:43:26 <quicksilver> similar to - but more complicated than - the circumstances that MVars/Chans can block.
08:43:40 <quicksilver> MVars only block if you take an empty one or put a full one.
08:43:44 <Cale> neothemachine: Yeah, you can compile with profiling on and run the program with +RTS -xc, which sometimes helps
08:44:07 <quicksilver> STM transactions block if you never produce a "satisfactory" or "consistent" state for them
08:44:18 <quicksilver> which may require some thinking through.
08:44:37 <timthelion> parcs`: ironically, it's the most pathetically simple situation one could imagine.  GUI application, has a bunch of threads that handle events that are associated with "objects" needs a way of not simply blocking till an event(of "their type") comes, but at the same time listening for an "exit" signal, so they can save their "object" to disk.
08:44:45 <Cale> neothemachine: It does appear that message is produced when using ! to look up an element not in the Map
08:44:53 <neothemachine> dmwit: well.. to be honest, that sucks :D
08:44:58 <EvanR_> timthelion: that sure sounds pathetically simple
08:45:03 <timthelion> quicksilver: and that's different than MVars?
08:45:09 <EvanR_> i like how it starts with 'gui application' lol
08:45:14 <quicksilver> it's not qualititaively different.
08:45:27 <quicksilver> it's just a more complex notion of 'consistent state'
08:45:29 <timthelion> EvanR_: what?  This IS simple!
08:45:32 <quicksilver> (and a user-extensible one)
08:45:35 <Cale> neothemachine: It's really best to avoid functions which can fail like that unless you're *really* sure. I kinda wish that ! didn't have such a short name.
08:45:37 <EvanR_> timthelion: heh.
08:45:52 <neothemachine> Cale: can I use -xc in ghci as well?
08:46:05 <Cale> neothemachine: Ummm... you can try it :)
08:46:14 <Cale> I'm not sure
08:46:57 <neothemachine> Cale: so I should use findWithDefault and the default is then an error or something just so I know where to look at
08:46:58 <Cale> You'd want to pass it as an RTS option to ghci, I think, but I'm not sure if it'll apply to the program that GHCi runs, or just GHCi itself.
08:47:02 <Cale> yes
08:47:04 <Cale> at least
08:47:28 <Cale> But better still to actually handle the failure case properly in each instance.
08:47:33 <Cale> (If possible)
08:47:42 <neothemachine> well, it's a programming error
08:47:43 <quicksilver> Cale: the RTS that ghci runs in doesn't distinguish between ghci itself and the programs it runs.
08:47:58 <fryguybob> timthelion: You were concerned with a single MVar being a bottleneck, but do you actually have enough bandwidth in your events that it is a bottleneck?
08:47:59 <quicksilver> Cale: (this is a strength and a weakness)
08:48:08 <quicksilver> mostly a weakness IMO but perhaps convenient here.
08:48:14 <neothemachine> the element should also exist, I'm just complaining because I'm lost in those moments :)
08:48:38 <Cale> neothemachine: Another thing to be aware of is Debug.Trace.trace
08:48:49 <neothemachine> yeah I already use it here and there
08:49:01 <Cale> neothemachine: You can observe the things being looked up, and what's being put into the Map
08:49:24 <Cale> Of course, you could also paste your code on hpaste or something and we can have a look :)
08:49:43 <timthelion> fryguybob: Well, perhaps not in terms of actual computing speed, though I think that it's a "bad idea(tm)" to simply waste resources due to failiure to design properly.  But it's more of a bottleneck in that it complicates the code.  Every time we have a "multichannel MVar" we have the risk of pattern matching problems, lost events, ect.
08:50:02 <neothemachine> what would be really cool is to be able to set a flag which traces every function call, for debugging
08:50:25 <Cale> neothemachine: -prof -auto-all more or less does that
08:50:48 <Cale> well, secretly :)
08:51:03 <Cale> It doesn't cause them all you print out into a terminal :)
08:51:06 <Cale> to*
08:51:40 <neothemachine> and how would I use it with ghci?
08:51:43 <Cale> But when an exception occurs, you can get a pretty good trace of where it occurred now
08:51:57 <Cale> uh, you usually wouldn't
08:52:14 <neothemachine> hm ok
08:52:16 <Cale> You can write a main for your program which just prints out whatever expression you'd have put into ghci
08:52:27 <Cale> and then compile with -prof -auto-all
08:52:40 <Cale> and run the program with +RTS -xc
08:53:50 <Cale> I'll be back shortly
08:57:13 <KirinDave> Another morning, another haskell hater article on the frontpage of hackernews.
08:58:00 <RawProduce> yeah, but hacker news is full of reddit nerds
08:58:04 <RawProduce> who cares what they think?
08:58:24 <KirinDave> Oh it's just funny
08:58:43 <KirinDave> Seems like there is an increasingly escalating campaign against haskell there
08:58:59 <RawProduce> it's generally been going downhill
08:59:17 <KirinDave> https://existentialtype.wordpress.com/2012/08/14/haskell-is-exceptionally-unsafe/ is the article so you don't have to step in the mud to see it
08:59:26 <LadyAurora> @pl \x y -> f x `compare` f y
08:59:27 <lambdabot> (. f) . compare . f
08:59:28 <KirinDave> The argument is, "unsafePerformIO and friends are unsafe and I really dislike this."
09:00:05 <shapr> KirinDave: And as the comments say "User defined Typeable instances can do bad things".
09:00:28 <KirinDave> shapr: And then the dramatic chipmunk clip gets played
09:00:38 <shapr> Of course, with the FFI you can define any amount of C code to be pure, so I dunno why he's messing about with small ways to blow up the type system.
09:00:48 <shapr> KirinDave: ooh, tell me that's on youtube..?
09:01:00 <KirinDave> Yes.
09:01:08 <LadyAurora> "Haskell is unsafe because I donuse unsafe functions", nice.
09:01:18 <LadyAurora> don't know how to use*
09:01:29 <KirinDave> Well I mean, it is unsafe. Very well, carry on.
09:01:46 <LadyAurora> Assembly is the safest of all languages.
09:01:49 <KirinDave> Haskell enjoys more popularity than many other languages in the space because of this tacit nod towards pragmatism.
09:02:06 <wuttf> LadyAurora: lol
09:02:18 <neothemachine> Cale: when I use -prof: "Warning: 'ghc-options: -prof' is not necessary and will lead to problems when
09:02:19 <neothemachine> used on a library. Use the configure flag --enable-library-profiling and/or
09:02:19 <neothemachine> --enable-executable-profiling.
09:02:21 <danr> KirinDave: I think Lennart's commentary sums it up pretty well
09:02:22 <neothemachine> oops, sorry
09:02:30 <RawProduce> real men flip the bits by hand, with a tiny magnet on a pair of tweezers
09:02:38 <shapr> KirinDave: I agree. "We treasure safety, except when it just can't be had. Here's unsafePerformIO. With great power, comes great responsibility."
09:03:05 <LadyAurora> wuttf: it's true, there's no "undefined behavior" in assembly.
09:03:58 <wuttf> LadyAurora: I still wouldn't write pacemaker controller software with it
09:04:03 <jfischoff> shapr: http://axisofeval.blogspot.com/2012/07/when-i-read-blog-post-by-robert-harper.html
09:04:27 <byorgey> KirinDave: uh, that is not the argument at all.  It is a specific argument about unsoundness of Haskell's exception mechanism.
09:04:33 <shapr> jfischoff: haha
09:04:40 <mekeor> why is () an instance of Enum if the methods (apart from fromEnum) just fail? :(
09:05:13 * shapr rereads the post
09:05:13 <dmwit> (mostly just about the unsoundness of Typeable)
09:05:39 <LadyAurora> wuttf: who cares about that? The slightest possibility of abusing the language is more important when judging the safety. See the article linked above.
09:05:42 <dmwit> mekeor: Well, how else am I supposed to write [()..]??
09:05:53 <mekeor> dmwit: kidding, hm?
09:05:55 <shapr> > [() ..]
09:05:57 <lambdabot>   [()]
09:06:09 <dmwit> > [minBound .. maxBound] :: ()
09:06:11 <lambdabot>   Couldn't match expected type `()' against inferred type `[a]'
09:06:14 <dmwit> > [minBound .. maxBound] :: [()]
09:06:16 <lambdabot>   [()]
09:06:18 <shapr> neat
09:06:25 <mekeor> -.-
09:06:27 <parcs`> mekeor: succ and pred are useless but the rest aren't
09:06:28 <shapr> > map (1) [1..5]
09:06:29 <lambdabot>   [1,1,1,1,1]
09:06:43 <LadyAurora> Caleskell!
09:06:44 <wuttf> LadyAurora: my sarcasm detector is glitchy in english. is that sarcasm?
09:06:45 <DMcGill> wait what?
09:06:46 <tgeeky_> > [((),()),..]
09:06:47 <lambdabot>   <no location info>: parse error on input `..'
09:06:53 <LadyAurora> wuttf: yes.
09:06:55 <tgeeky_> > [((),())..]
09:06:56 <mekeor> > fromEnum 1 :: ()
09:06:57 <lambdabot>   can't find file: L.hs
09:06:57 <lambdabot>   No instance for (GHC.Enum.Enum ((), ()))
09:06:57 <lambdabot>    arising from the arithmetic seq...
09:07:02 <wuttf> LadyAurora: ;)
09:07:09 <DMcGill> shapr: how does that work?
09:07:15 <dmwit> mekeor: I think the real question is "why shouldn't () be an instance of Enum, thereby making any Enum-polymorphic values and functions usable with ()?".
09:07:36 <Eduard_Munteanu> DMcGill: num instances for functions
09:07:40 <LadyAurora> DMcGill: it's Caleskell, not Haskell.
09:07:50 <shapr> DMcGill: I have no idea. But I it happened in my GSoC project yestedray when I tried to GET expr=map (+1) [1..5] since + is a space in an url.
09:07:52 <Eduard_Munteanu> > 1 3
09:07:53 <lambdabot>   1
09:08:12 <dmwit> instance Num b => Num a -> b -- this is how it happens
09:08:15 <LadyAurora> @src Num
09:08:16 <lambdabot> class  (Eq a, Show a) => Num a  where
09:08:16 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:08:16 <lambdabot>     negate, abs, signum     :: a -> a
09:08:16 <lambdabot>     fromInteger             :: Integer -> a
09:08:21 <quicksilver> dmwit: the answer to that might be "because the Enum typeclass is such a mess we don't want to make any changes which might appear to encourage use of it" ?
09:08:23 <DMcGill> why on earth do functions have a Num instance?
09:08:31 <mekeor> shouldn't Enum be two classes, like one that provides succ and the other provides pred?
09:08:37 <dmwit> quicksilver: That might be one answer, yeah. =)
09:08:44 <shapr> KirinDave: I thought Dramatic Chipmunk was a joke, I didn't know it actually existed :-)
09:08:53 <mekeor> DMcGill: that's only for lambdabot
09:08:56 <edwardk> DMcGill: why wouldn't they?
09:08:56 <parcs`> DMcGill: why not
09:08:58 <quicksilver> mekeor: Enum should certainly be more than one typeclass, yes.
09:08:59 <DMcGill> so they could have Show and Eq?
09:09:07 <dmwit> DMcGill: Because it's cute.
09:09:10 <edwardk> DMcGill: Num doesn't require Show and Eq any more
09:09:10 <dmwit> For example:
09:09:14 <LadyAurora> > const 2 == const 3
09:09:16 <lambdabot>   *Exception: (==): No overloading for function
09:09:16 <dmwit> > (sin^2 + cos^2) 32
09:09:17 <lambdabot>   1.0
09:09:21 <quicksilver> mekeor: Enum's "special" behaviour is the way it provides meaning to ".."
09:09:25 <LadyAurora> > show $ const 2
09:09:26 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
09:09:26 <lambdabot>    arising from a use of `...
09:09:33 <quicksilver> mekeor: I wouldn't call that 'Enum' (I'd call it 'Range')
09:09:43 <LadyAurora> Still, lambdabot has Eq for functions.
09:09:55 <edwardk> > let f x = x + 2 in (2 * f) 4
09:09:57 <lambdabot>   12
09:10:29 <nand`> I would call it Enum because it means the type is enumerable (elements are listable)
09:10:30 <mekeor> quicksilver: so, would you make it as i suggested? two classes, one called Succ the other Pred?
09:10:32 <DMcGill> bah, Num should just be the instance of IntegralDomain for the different number types
09:10:42 <edwardk> LadyAurora: thats because lambdabot's instances were defined back when Num _did_ require Eq and Show
09:10:47 * mekeor is writing yet another prelude =)
09:10:47 <timthelion> having read the article, I would have to agree, that the current exception system in haskell sucks.  But I hate the proposed ML solution
09:11:06 <edwardk> DMcGill: turns out to define a decent numerical tower you need MPTCs/FDs or MPTCs and TFs
09:11:18 <LadyAurora> Is there an 'iterateM' function?
09:11:22 <mekeor> what if all functions were ... -> Maybe a? that'd solve the problem...
09:11:48 <mekeor> @hoogle iterateM
09:11:49 <lambdabot> No results found
09:11:50 <edwardk> timthelion: bob harper's trolling tends to be technically true, totally mischaracterize the problem, and largely irrelevant
09:11:51 <timthelion> edwardk: do you think lambdabot will be updated, or simply be replaced by something based on hint?
09:11:55 <mekeor> @hayoo iterateM
09:11:56 <lambdabot> Unknown command, try @list
09:11:57 <DMcGill> edwardk: I don't know any of those acronyms I'm afraid
09:12:07 <Clint> LadyAurora: it's in monad-loops
09:12:07 <mekeor> LadyAurora: http://holumbus.org/hayoo/hayoo.html?query=iterateM
09:12:17 <edwardk> DMcGill: multiparameter type classes, functional dependencies, type families
09:14:03 <shapr> byorgey: so Harper's whole complaint is that exceptions should be uni-typed in Haskell in order to stay pure, right?
09:14:23 <timthelion> It seems to me that the first step in fixing haskell's exceptions, would be to stop saying "well *anything*" could happen and start using "internal, and external" exceptions.  Such that head [] would be an internal exception, and SIGTERM #threadID would be an "external" exception.
09:14:25 <edwardk> shapr: no. his complaint is that Typeable allows unsafe coercions
09:14:53 <edwardk> i don't think they need to be fixed. this _was_ the fix and its a pretty good fix. SafeHaskell disallows manual Typeable instances
09:15:01 <shapr> Ok, sounds good to me.
09:15:13 <edwardk> when 7.8.1 comes around and Typeable can work for arbitrary kinds, then SafeHaskell kills harper's pet argument dead
09:15:33 <edwardk> but we decided to go a little slower and not include the generalized Typeable in this release
09:15:34 <shapr> Has anyone figured out how I can put type family stickers on the back window of my car?
09:15:51 <edwardk> shapr: =P
09:16:07 <arbn> shapr: That's a good idea.
09:16:10 <quicksilver> timthelion: we already do distinguish those and you can catch them separately and the latter is much easier to catch than the former.
09:16:11 <shapr> edwardk: I do not understand, but I believe you do :-)
09:16:14 <dmwit> Monokinded Typeable is a bit annoying, yeah.
09:16:30 <dmwit> shapr: Do you know about Typeable1, Typeable2, etc.?
09:16:30 <timthelion> shapr: what type familly is your familly?
09:16:32 <quicksilver> timthelion: in what further way would you like to distinguish?
09:16:35 <shapr> dmwit: I do not.
09:16:41 <dmwit> Okay. Do you want to?
09:16:42 <shapr> dmwit: Something I can read?
09:16:48 <shapr> Um... not today :-)
09:16:50 <edwardk> shapr: look at the code for Data.Typeable
09:16:52 <dmwit> okay =)
09:16:58 <shapr> dmwit: But I will return and ask you at some later point.
09:17:07 <dmwit> sure
09:17:17 * shapr goes back to writing GSoC code
09:17:18 <dmwit> The documentation for Typeable talks about it a bit, too, I think.
09:17:21 <edwardk> shapr: it has classes for various kinds, *, * -> *, * -> * -> *, etc Typeable, Typeable1, Typeable2
09:17:33 <edwardk> shapr: racing that hard pencils down date?
09:17:43 <quicksilver> edwardk: don't forget (* -> *) -> *
09:17:50 <edwardk> quicksilver: those are missing
09:17:55 <shapr> edwardk: yes, exactly. I have a working-but-ugly version and I'd like to have a working-and-pretty version :-)
09:17:55 <dmwit> Actually, do forget it, since they don't exist. =/
09:18:00 <quicksilver> edwardk: I know. It was humour :)
09:18:00 <edwardk> quicksilver: thats why you still need to write manual instances
09:18:05 <quicksilver> not a particularly clever sort.
09:18:05 <timthelion> quicksilver: I'd like functions which can emmit "internal" exceptions to be marked in some way(doesn't have to actually effect the code, I'd just like to type a cappital E every time I define a function that explicitly calls "error" just so that I remember/know that an error *could* occur
09:18:19 <edwardk> ah
09:18:48 <edwardk> anyways, the lack of ability to provide typeable for anything that takes non * kinded arguments is why we need polykinded Typeable once and for all.
09:19:00 <quicksilver> timthelion: all code can.
09:19:17 <timthelion> quicksilver: rightnow, I have to rely on the documentation to tell me that an "error" condition is handled with an exception.  And if you look at thinks like "take" and "head" and "tail" from prelude, you'll notice none of their haddock entries tell you anything of what to expect.
09:19:27 <DMcGill> divide :: ThrowsDivByZero a, Num a => a -> a -> a
09:19:31 <quicksilver> timthelion: HeapExhaustion and StackOverflow can occur anywhere.
09:19:35 <quicksilver> timthelion: right.
09:19:37 <timthelion> quicksilver: actually, not all code can produce an "internal" exception.
09:19:55 <timthelion> quicksilver: I would call HeapExhaustion" an "external" exception
09:20:00 <quicksilver> ok.
09:20:03 <edwardk> timthelion: x = x; that can also throw an exception =P
09:20:06 <quicksilver> what would you call an infinite loop?
09:20:10 <edwardk> it isn't always clear
09:20:12 <timthelion> external as well
09:20:22 <timthelion> I would call anything, that is unexpected, external.
09:20:25 <quicksilver> the error from 'head' and 'tail' is not something you're supposed to handle.
09:20:32 <timthelion> and anything that is explicitly declared with an "error" internal
09:20:53 <timthelion> quicksilver: but you should know that it will happen if you give it a bad value
09:21:17 <timthelion> quicksilver: it's not even explicitly documented, that / and div act differently
09:21:18 <quicksilver> yes, it is good to understand which functions are partial.
09:21:21 <timthelion> > 1 / 0
09:21:23 <lambdabot>   Infinity
09:21:26 <timthelion> > 1 `div` 0
09:21:28 <lambdabot>   *Exception: divide by zero
09:21:39 <edwardk> head [] would be perfectly within its rights to spin forever, throw an exception, divide by zero, part the red sea, or do anything it wanted ;)
09:21:45 <timthelion> quicksilver: it's good to understand, and right now, impossible to see.
09:22:23 <edwardk> timthelion: ultimately i view the fix of exposing all possible exceptions thrown by a type as worse than the disease of partial functions
09:22:30 <timthelion> I firmly believe, that the problem, is not at runtime, or even compile time, but at haddock generation time.
09:22:57 <quicksilver> that soundsl ike something I can agree with, timthelion
09:23:07 <quicksilver> partial functions need to document their partiality clearly.
09:23:08 <Cale> neothemachine: Did you have any luck?
09:23:15 <edwardk> it works fine for toy examples like head, but when you start talking about, say, MVars or sockets, there are a million funny little cases that can pop up with deadlock or the IO subsystem
09:23:20 <Cale> neothemachine: I'd be happy to take a look at the code if you're still stuck
09:23:28 <neothemachine> this site (http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program) says that I have to compile every library I use manually, which seems right looking at the error "ld.exe: cannot find -lHStest-framework-0.6_p"
09:23:54 <quicksilver> edwardk: that's true but I don't think timthelion is actually touching on the wider issue of the spiralling hierarchy of IO/RTS exceptions.
09:23:55 <neothemachine> is there no other way? I mean, can't cabal do that too?
09:24:04 <quicksilver> edwardk: I think he's just concerned about partiality.
09:24:06 <dmwit> cabal install foo bar baz --enable-profiling
09:24:19 <dmwit> You can also enable profiling by default by changing ~/.cabal/config.
09:24:24 <Cale> neothemachine: oh, there's an option which you should have in your... yes
09:24:32 <neothemachine> ah.... great :)
09:24:40 <edwardk> i prefer to program with total functions where possible, but i accept the fact that i can't always get away with it
09:24:44 <Cale> I have no idea why it's not default, actually
09:24:45 <monochrom> enable library docs while you're at it
09:25:10 <monochrom> the default assumes you don't care about haskell if not for xmonad
09:25:10 <Cale> yeah,  library-profiling: True   and  documentation: True
09:25:13 <dmwit> Cale: Because hard drive space is expensive, maaaan.
09:25:20 <edwardk> for instance i have some lenses that are actually partial functions in lens, just because they are too damn useful
09:25:21 <timthelion> edwardk: but don't you see, that partial functions should somehow be marked, so the programmer can see?
09:25:33 <mekeor> monochrom: is that the "documentation: False" option?
09:25:37 <monochrom> yes
09:25:52 <edwardk> i see the argument, but ive also lived with ecosystems where you have checked exceptions before and absolutely hated them
09:25:55 <timthelion> edwardk: even if that marking ONLY showed up in haddock?
09:25:55 <_flow_> how can i get the current unix utc time seconds?
09:26:25 <monochrom> getUTCTime
09:26:34 <monochrom> @hoogle getUTCTime
09:26:35 <lambdabot> No results found
09:26:39 <shapr> @index getUTCTime
09:26:39 <lambdabot> bzzt
09:26:41 <shapr> :-(
09:26:43 <dmwit> getPOSIXTime if you literally want the number of seconds since 1970, getUTCTime if you want an actually good data type.
09:26:46 <monochrom> err, perhaps wrong name
09:27:00 <dmwit> getCurrentTime
09:27:21 <edwardk> timthelion: i'd be okay with adding some kind of throws or partiality formatting to haddock, but that is more or less the job of the haddock author right now
09:27:23 <_flow_> getPOSIXTime seems to be what i need
09:27:37 <monochrom> yeah. Data.Time.Clock.getCurrentTime. it's UTC
09:27:44 <dmwit> getPOSIXTime is almost always not what you need.
09:27:49 <timthelion> edwardk: is it "possible" for haddock to tell?
09:27:49 <dmwit> almost
09:27:52 <edwardk> ultimately inferring it for haddock is nigh impossible, and requiring a manual annotation provides no additional power
09:27:59 <edwardk> no
09:28:26 <neothemachine> Cale: I guess I should also set executable-profiling: True in my config, right?
09:28:28 <edwardk> i have plenty of code that includes errors that can literally never happen, because they exist because the GADT type checker isn't smart enough to spot that something can't happen
09:28:33 <timthelion> edwardk: even if it parsed both the output of "-WAll" and searched for the Token "error"? ;)
09:28:42 <Cale> neothemachine: no, not in the cabal config
09:28:44 <_flow_> dmwit: I want the current second count of the unix time which is "seconds since 1.1.1970 UTC"
09:28:45 <edwardk> timthelion: still useless for the reason i just specified
09:28:51 <timthelion> edwardk: that is one problem... I would admit.
09:28:57 <Cale> neothemachine: Usually if you install an executable with cabal, you want to install the non-profiling version of it
09:29:04 <dmwit> _flow_: Why do you want that?
09:29:18 <neothemachine> Cale: ok
09:29:26 <edwardk> and you can have plenty of invariants that are always satisfied when using smart constructors when the constructors aren't exposed to the user
09:29:36 <monochrom> I wouldn't ask why you want whatever. but I would ask why you change the question.
09:29:37 <timthelion> edwardk: but Haddock could easilly show us some context, so we could judge for ourselves... Like the line where "error" is written, if the text is "really, sir, this will never happen" you guess it won't happen.
09:29:39 <edwardk> i have plenty of code that uses the implementation hiding approach as well
09:29:42 <quicksilver> timthelion, edwardk : to be fair, neil mitchell did quite a lot of work on a restricted case in which you can tell.
09:29:47 <quicksilver> "Catch"
09:29:47 <_flow_> because the spec of memcached measures time relative to the unix time
09:29:57 <timthelion> edwardk: if the text is "oh my, bad parameters, can't take a 0" then you figure it's your responcibility
09:30:07 <edwardk> haddock isn't magic, right now all it does is look at the output of ghc and some text that gets dropped into the AST
09:30:07 <Cale> neothemachine: The library profiling flag will install both versions of every library you install from then on.
09:30:09 <dmwit> Right. That's the kind of thing that makes the "almost" in "almost never what you need" necessary. =P
09:30:10 <edwardk> quicksilver: sure
09:30:12 <applicative> somehow i feel like responding to harper that i would use haskell over sml even if it melted my machine on every 5th run.
09:30:15 <dmwit> Other programs that got it wrong.
09:30:17 <quicksilver> so whilst edwardk is quite right that you can't get it right all the time (or even in some mathematical sense 'most' of the time) you can technically tell in an interesting set of cases.
09:30:38 <edwardk> applicative++
09:31:47 <edwardk> anyways, if you want to chase after such functionality, it'll be a lot of work, because its pretty far outside of what haddock does right now
09:31:59 <edwardk> and as long as its a flag i can shut off i won't care
09:32:16 <edwardk> just pointing out that it isn't a panacea
09:32:24 <edwardk> and that it is quite a lot of work ;)
09:32:36 <neothemachine> Cale: yeah, I just tried to reinstall existing ones, but it seems I have to list all at once, otherwise he doesn't find the other profile-compiled dependencies, right?
09:32:37 <timthelion> edwardk: I'm well aware of that.  I converted to "maltheism" today.
09:33:07 <Cale> neothemachine: hm, it should find them...
09:33:15 <Cale> neothemachine: be careful about version numbers of things
09:33:37 <Cale> neothemachine: What libraries are you using in this code?
09:33:46 <prophile> I like jam
09:33:49 <neothemachine>     Could not find module `Test.Framework.Providers.API'
09:33:50 <neothemachine>     Perhaps you haven't installed the profiling libraries for package `test-framework-0.6'?
09:34:09 <Eduard_Munteanu> What's a good library for networking stuff? I'm mainly interested in UDP stuff. network?
09:34:21 <Cale> cabal install --reinstall test-framework-0.6
09:34:33 <dmwit> neothemachine: Yes, after you've turned the flag on, you still need to reinstall all the packages you've already got (except the ones that came with GHC).
09:34:34 <neothemachine> yeah, well, but WITH profiling!
09:34:41 <Eduard_Munteanu> -p
09:34:53 <Cale> neothemachine: you should see it compile the library twice when you reinstall it
09:35:04 <monochrom> it is easiest and most robust to just list "ghc-pkg list --user", remember the list, then get rid of them all, then explicitly list them all at the "cabal install" line
09:35:07 <Cale> neothemachine: if you set that option for library profiling to true in your cabal configuration
09:35:22 <Cale> neothemachine: (once without profiling, and then with)
09:35:32 <drewr> anybody know of a good example of using cmdArgs with modes?  the docs may be sufficient and I'm just not reading them carefully enough
09:37:02 <neothemachine> success! now let's see if the profiling actually works...
09:37:24 <KirinDave> drewr: I've used it.
09:37:31 <KirinDave> drewr: Want me to gist a bit of code?
09:38:28 <drewr> KirinDave: I can use it fine for the simple case, but the docs allude to it having better support for Modes (which I currently do by frobbing leftover args)
09:38:40 <drewr> and doesn't really go into any more detail
09:38:58 <applicative> 'modes' are like git clone and cabal install and so on?
09:39:54 <mekeor> is there a way haskell could (be extented such that it can) allow types to have multiple instances for one type class? (without using newtype, i mean.)
09:40:36 <mauke> but then you'd have to select instances manually
09:40:44 <S11001001> mekeor: if they're in separate modules and you don't cross the streams, but that's flaky
09:41:23 <mekeor> mauke: yup
09:41:26 <mekeor> S11001001: yup
09:41:27 <Cale> mekeor: If you're going to do that, you might as well not use a typeclass
09:41:36 <mekeor> Cale: why?
09:41:38 <mauke> mekeor: that would destroy monads
09:41:43 <mekeor> oO
09:41:44 <Cale> mekeor: because you have to say which instance you want, which means that you might as well just pass it as a parameter
09:41:53 <mauke> the entire point of typeclasses is that the typechecker takes care of them
09:42:01 <mekeor> Cale: ah, hm
09:42:04 <neothemachine> Cale: hmm nothing different happens on execution with +RTS -xc, I compiled with -Wall -rtsopts -prof -auto-all
09:42:08 <Cale> You can already make a datastructure with all the methods in it
09:42:09 <mekeor> mauke: hmm
09:42:13 <mekeor> i see
09:42:24 <Cale> The only thing which distinguishes typeclasses is that passing them around is automatic
09:42:34 <mekeor> yeah
09:42:41 <Cale> neothemachine: you get an exception, but no list of contexts?
09:42:46 <Cale> neothemachine: hmm
09:42:57 <Cale> neothemachine: try running the program with +RTS -p
09:43:07 <mekeor> thanks, Cale, mauke
09:43:08 <neothemachine> Cale: I haven't tested it on my problematic code yet, I thought I get different output with working code as well
09:43:17 <Cale> neothemachine: oh, no
09:43:24 <neothemachine> Cale: well, even better
09:43:27 <Cale> neothemachine: It only prints a trace when the program dies from an exception
09:43:36 <neothemachine> Cale: very nice, I'll try that now
09:43:40 <slack1256> is there a way to install documentation of a program with link to source code as in haddock?
09:44:38 <yitz> slack1256: cabal haddock
09:45:40 <yitz> slack1256: the haskell platform for mac os x does that automatically whenever you install a package, and combines all the haddocks into one separate local haddock site.
09:45:52 <neothemachine> Cale: aaaaaaaaaaah, a stacktrace! :) Ok, I hereby vote with a million votes that this should be made DEFAULT!!!
09:45:59 <yitz> s/separate/combined/
09:46:41 <Cale> neothemachine: Your code runs *a lot* slower that way though
09:47:12 <Cale> neothemachine: The machinery required to artificially produce that "stack trace" is expensive since the "stack" that it's tracing doesn't actually exist.
09:47:40 <neothemachine> Cale: well, ok, then at least the compile things with the packages
09:48:02 <Cale> But yeah, the profiling libraries really ought to be installed by default, I have no idea why they're not.
09:48:08 <c_wraith> install time
09:48:18 <c_wraith> it doubles the install time for packages
09:48:31 <neothemachine> who cares..
09:48:48 <c_wraith> there are *some* packages where that means "adds an extra 5 minutes"
09:48:53 <c_wraith> that gets annoying
09:48:57 <Cale> c_wraith: I'd rather pay the install time on a package-by-package basis than find out I need it later and spend half an hour working out which packages need to be rebuilt and doing them all.
09:49:05 <yitz> Cale: it's the default on mac os x (haskell platform)
09:49:48 <applicative> mekeor the mistake was ever to let us apply typeclasses to 'real' datatypes; it ought to have been restricted to newtypes.  :)
09:50:01 <Cale> disagree
09:50:04 <mekeor> applicative: heh yeah
09:50:04 <c_wraith> also, there are ambiguities in call stacks that I'm not sure how this will address.
09:50:15 <yitz> Cale?
09:50:26 <Cale> sorry, I disagree with applicative
09:50:32 <yitz> oh ok
09:50:40 <Cale> Integer isn't a newtype
09:50:58 * applicative agrees with Cale of course
09:51:30 <KirinDave> So I was just talking with someone
09:51:32 <KirinDave> cmdargs is no fun to use
09:51:37 <KirinDave> And it's not even really safe.
09:51:52 <KirinDave> Can someone who is a genius with template haskell whip up something that emulates this?
09:51:53 <KirinDave> https://github.com/clojure/tools.cli/
09:52:02 <KirinDave> Because that library is superb at cli parsing.
09:52:07 <ocharles> the applicative command line parser looks good
09:52:09 <applicative> I'm Integer poses any difficulty.  It is a consequence of my imaginary system that e.g. numeric literals could only be used for newtypes
09:52:18 <KirinDave> ocharles: link please?
09:52:18 <yitz> KirinDave: there are a number of alternatives to cmdargs nowadays.
09:52:39 <ocharles> KirinDave: http://hackage.haskell.org/package/optparse-applicative
09:52:45 <ocharles> i think is what I was thinking of
09:53:02 <paolino> shoudn't it be more natural for forkIO :: (ThreadId -> IO ()) -> IO ThreadId ?
09:53:03 <Cale> applicative: right, so you'd basically end up wrapping every normal datatype in a newtype just so that instances could be written for it
09:53:14 <c_wraith> like...  « let f = g x ; g 0 = (`div` 5) ; g _ = (+ 1) in map f [-10..10] ».  Ok, when x is zero, that blows up.  Does the stack trace mention g at all?
09:53:25 <KirinDave> Ugh
09:53:26 <KirinDave> but
09:53:36 <KirinDave> then you need to write your state and your parser by hand
09:53:39 <Cale> applicative: and it would just make things awkward all the time, instead of like it is now, where you only incur a small amount of awkwardness when using a newtype wrapper
09:53:48 <yitz> ocharles: i'm pretty sure there's also something based on TH, very similar to what KirinDave is asking for. (but yeat, the applicative one looks interesting.)
09:54:04 <applicative> Cale, yes, but this might inspire one to introduce sensible extensions like the 'pattern synonyms' in the she preprocessor
09:54:13 <KirinDave> The real secret of tools.cli for clojure is that the result structure and parsing function are both derived from the same unified syntax.
09:54:18 <ocharles> KirinDave: eh? it's a combinator library. yes you need to declare what command line arguments you accept and how to parse them, but that doesn't look too different to the clojure thing you linked to
09:54:26 <KirinDave> ocharles: See my comment.
09:54:33 <KirinDave> ocharles: The difference is you have two things to keep in sync.
09:54:36 <yitz> KirinDave: no i don't think so, the parser is built in.
09:54:36 <ocharles> i don't agree that that is a good thing
09:54:43 <ocharles> yes, and the compiler will force you to
09:55:04 <KirinDave> ocharles: I just don't see why you'd WANT to write both if it wouldn't be challenging to have the compiler generate both.
09:55:15 <KirinDave> What's valuable about writing that code by hand?
09:55:17 <ocharles> because they are different things. maybe I want to be able to manually pass in options in scripts
09:55:21 <KirinDave> Okay
09:55:23 <roconnor_> dmwit: getPOSIXTime is the nominal number of seconds since 1970 not the literal number of seconds :/
09:55:25 <ocharles> i don't want to have to literally pass in string syntax to my functions
09:55:28 <KirinDave> What does that mean?
09:55:33 <fmap> edwardk: Is there any reason why free doesn't have FreeT?
09:55:46 <ocharles> KirinDave: do you plan to actually let me back my points up, or just jump in immediately because you don't agree?
09:56:22 <KirinDave> ocharles: No, actually I am going to go now because of that comment. We can discuss later? Seems overly defensive for a discussion.
09:56:31 * ocharles shrugs
09:56:36 <KirinDave> ocharles: And because my wife has to go to the doctor now.
09:56:42 <KirinDave> And that sort of slipped my mind. ;)
09:56:50 <ocharles> ok, that probably takes priority over haskell :)
09:56:58 <yitz> KirinDave: here's one that uses some kind of generics: http://hackage.haskell.org/package/ReadArgs
09:57:16 * paolino btw doesn't like myThreadId, it's not functional
09:57:59 <EvanR_> paolino: well, its IO anyway, and forcing people into a reader if they ever want to use the thread id is pretty bad
09:58:07 <mekeor> edwardk: would a type class for quasigroups need to provide *two* binary operators, i.e. left and right division?
09:58:17 <applicative> ReadArgs is brilliant, but I think it won't make very complicated options possible
09:58:33 <EvanR_> paolino: youd make the case that all read only values should be passed to the thread like that
09:59:01 <yitz> ocharles: here's one based on Google gflags, using TH: http://hackage.haskell.org/package/hflags
09:59:44 <paolino> EvanR_ I suppose so, maybe with a datatype of IO actions hiding the ThreadId completely
10:00:32 <ocharles> yitz: thanks, but I think it was KirinDave who was interested in that. I like optparse-applicative :)
10:02:53 <yitz> ocharles: yeah just continuing to record the ones i find in the irc channel log :0
10:02:55 <paolino> EvanR_, probably threads are the only objects we have, we can encapsulate state and have some class methods then :-P
10:03:30 <yitz> ocharles: here's one with parser combinators and a simple default parser, based on python's optik: http://hackage.haskell.org/package/multiarg
10:03:38 <EvanR_> paolino: eh?
10:03:43 <yitz> wow i didn't realize just how many there are
10:03:55 <EvanR_> paolino: IO isnt very functional in the first place btw ;)
10:04:10 <yitz> ocharles: and yeah, i would probably try the applicative one next, too. still stuck with cmdargs for now though.
10:04:39 <ocharles> it's a shame multiarg doesn't seem to have any examples
10:05:04 <ocharles> oh 'SampleParser'
10:05:14 <paolino> EvanR_, I start liking IO when it comes to STM, but yeah it's not so important then
10:06:13 <LadyAurora> :t stToIO
10:06:17 <lambdabot> Not in scope: `stToIO'
10:07:07 <paolino> @hoogle ST a -> IO a
10:07:08 <lambdabot> Did you mean: ST a a -> IO a
10:07:09 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
10:07:09 <lambdabot> Control.Exception evaluate :: a -> IO a
10:07:30 <paolino> eh, I meant that
10:07:57 <paolino> @hoogle ST l a -> IO a
10:07:58 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
10:07:58 <lambdabot> Control.Monad.ST runST :: (forall s. ST s a) -> a
10:07:58 <lambdabot> Control.Monad.ST.Lazy runST :: (forall s. ST s a) -> a
10:08:47 <yitz> this one is a higher-level front end to GetOpt: http://hackage.haskell.org/package/cmdlib
10:08:57 <LadyAurora> I want to create an STRef when in IO, 'stToIO . newSTRef' is the way to go, isn't it?
10:09:48 <c_wraith> LadyAurora: That won't really work.  (You won't be able to use that STRef in an ST computation.)
10:10:14 <LadyAurora> Oh.
10:11:14 <c_wraith> LadyAurora: in fact, it's very important to the design of ST that STRefs cannot exist in a usable state outside of an ST action
10:12:17 <applicative> drewr: i notice optparse applicative does support 'modes' under the title 'commands' here's an example https://github.com/pcapriotti/optparse-applicative/blob/master/tests/Examples/Commands.hs
10:12:28 <c_wraith> LadyAurora: would an IORef work for your purposes?
10:12:55 <drewr> applicative: thanks! looks very close to what I want
10:12:58 <LadyAurora> c_wraith: I suppose it would.
10:13:20 <tarps> c and haskell are on opposite ends of hte spectrum?
10:13:26 <yitz> this one allows a tree of modes, and options that are interchangeable with settings in a config file, all with an optional TH syntax wrapper: http://hackage.haskell.org/package/console-program
10:14:16 <EvanR_> haskell and c++ maybe
10:14:40 <c_wraith> tarps: not ends...  even if you assume a linear spectrum, you can go further..  assembly and Agda, for instance.  But really, the decisions are far more complicated than just a single scalar
10:14:41 <tarps> c++ seems like a true nightmare
10:15:58 <roconnor> the implicit stuff in c++ drives me insane
10:16:27 <c_wraith> implicit use of single-arg constructors to do type conversion is scary.
10:16:28 <sclv> and by implicit stuff, you mean... the entire ++ :-)
10:16:51 <roconnor> implicit copy constructors and whatnot
10:17:42 <tarps> is this for like type coercion stuff?
10:17:55 <iamtakingiteasy> hi, is there any tools for profiling haskell?
10:18:12 <neothemachine> Cale: I found the error :) I used [x..] where x is >1 and somehow I assumed that I would get a backwards counting list and that [3..1] actually would work, hehe
10:18:19 <c_wraith> iamtakingiteasy: ghc has a profiler built in
10:19:15 <neothemachine> Cale: and this caused some real error later on when accessing the map
10:19:46 <c_wraith> > [74,73..1]
10:19:48 <lambdabot>   [74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50...
10:19:58 <c_wraith> just need to help it out a bit, that's all :)
10:20:05 <iamtakingiteasy> c_wraith: thanks!
10:20:15 <neothemachine> hm, so why doesn't [2..1] work?
10:20:29 <yitz> this one provides fairly simple yet pure arg parsing by allowing only a small fixed set of types for option values: http://hackage.haskell.org/package/parseargs
10:20:50 <c_wraith> because if you don't specify an increment (via a second value), it assumes you mean the « succ » operator from the Enum class
10:21:17 <Cale> neothemachine: Yeah, that works, but you get an empty list :)
10:21:20 <neothemachine> ah ok, and succ always counts up
10:21:30 <Cale> neothemachine: which is actually convenient a lot of the time, but not in this case :)
10:21:55 <Cale> it actually uses enumFromTo which may or may not use succ
10:22:05 <Cale> (depending on the instance)
10:22:48 <c_wraith> Hmm, true.  Enum doesn't actually have laws about what those functions do
10:22:51 <neothemachine> > [10,6..1]
10:22:52 <lambdabot>   [10,6,2]
10:22:56 <neothemachine> funny
10:23:51 <yitz> ocharles: and, of course, System.Console.GetOpt from base. well, that's all i found. whew! when KirinDave gets back - if none of those are suitable, well then, go ahead and write yet another one.
10:24:25 <iamtakingiteasy> how do i say ghc that it should link program against mtl package when compiling in -prof mode?
10:24:28 <drewr> yitz: I was the OP actually; currently perusing all your findings :-)
10:24:29 <iamtakingiteasy> --make mode works just fine
10:25:06 <LadyAurora> @hoogle exitWith
10:25:07 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
10:25:21 <yitz> drewr: ah ok. :) that was an interesting exercise. i'm looking for a cmdargs alternative too.
10:25:41 <om> yitz: i made a dictionary and got it working
10:25:48 <drewr> kind of a bummer; Neil seems to be really passionate about it
10:26:04 <neothemachine> so... how can I get a list [4,3,2,..] where just 4 is known by a value x?
10:26:06 <yitz> om: yay! good work!
10:26:18 <Cale> [x,x-1..]
10:26:35 <Cale> > let x = 5 in [x,x-1..]
10:26:36 <lambdabot>   [5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18...
10:26:46 <Cale> > let x = 5 in iterate pred x
10:26:48 <lambdabot>   [5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18...
10:27:02 <neothemachine> eh ok :D
10:27:18 <yitz> om: can you post it somewhere so people can use it until the author adds it? e.g., perhaps you'll send a pull request and send us the link?
10:27:39 <Cale> yitz: I'd probably just use GetOpt
10:28:00 <Cale> I've used it before, and it's pretty decent.
10:28:12 <yitz> drewr: ndm's work was very important. it lit a fire under people's imaginations.
10:28:30 <neothemachine> Cale++
10:28:46 <neothemachine> my life saver...
10:28:48 <drewr> yitz: I see
10:28:57 <om> i don't have a github account, but i'll make one now
10:29:31 <yitz> Cale: i used it in the past. it works, but it's pretty byzantine. an awkward word-for-word translation of gnu getopts to haskell 98, not very idiomatic.
10:30:38 <yitz> om: ok great. other than here, good places to let people know about it are the haskell-cafe mailing list and the haskell reddit channel.
10:30:44 <yitz> om: thanks for doing that.
10:31:09 <Cale> Does gnu getopts have higher order syntax for arguments?
10:31:34 <madjestic> hey guys. I am doing a tutorial from learnyouahaskell and, after typing a command, unexpectedly I got this::
10:31:36 <madjestic> *Main> show Monday
10:31:37 <madjestic> Loading package array-0.4.0.0 ... linking ... done.
10:31:50 <madjestic> and a couple more lines
10:32:17 <Cale> madjestic: ghci will tell you when it's loading packages
10:32:20 <madjestic> what is happening here?  I am inside ghci, so I am not compiling anything explicitly
10:32:41 <madjestic> does it mean that it loads packages in a lazy way too?
10:32:50 <EvanR_> is reversing a Data.Sequence efficient?
10:32:51 <byorgey> yes
10:32:51 <madjestic> i.e load when necessary?
10:32:56 <Cale> madjestic: Well, ghci only loads packages when it needs to, yeah.
10:33:03 <byorgey> the yes was for madjestic.
10:33:09 <EvanR_> if not whats better
10:33:14 <Cale> madjestic: When you compile your program, usually they'll be statically linked.
10:33:19 <byorgey> Sequence
10:33:26 <byorgey> oops, sorry
10:33:33 <timthelion> Is there a good short essay on the uses of toplevel modules?
10:33:38 <madjestic> thanks, that's so cool
10:33:50 <Cale> EvanR_: it's not super-efficient.
10:33:53 * timthelion perhaps I should have asked in blah
10:33:59 <Cale> EvanR_: It should be O(n)
10:34:09 <EvanR_> so like a list
10:34:12 <Cale> yes
10:34:24 <byorgey> EvanR_: did you look at the documentation?  It clearly states it is O(n).
10:34:28 <EvanR_> is there a structure with faster reverse
10:34:44 <EvanR_> byorgey: no i didnt, in fact i didnt know it even had a reverse operation
10:34:53 * timthelion goes to ask this question in blah
10:35:03 <byorgey> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html
10:35:04 <yitz> Cale: no. and no data types, no Maybes, etc. no type safety. it's just a simple function. the option spec is a string. http://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html#Example-of-Getopt
10:35:04 <EvanR_> this is me randomly typing questions while doing his real job which is totally unrelated
10:35:11 <byorgey> hehe
10:35:30 <EvanR_> a doubly linked list in C is pretty fast at reverse ;)
10:35:43 <Cale> EvanR_: still O(n)
10:35:55 <EvanR_> nah just switch the beginning and ending
10:36:10 <Cale> EvanR_: but then the links are all in the wrong direction?
10:36:22 <EvanR_> they go both ways anyway
10:36:35 <Cale> EvanR_: yes, but x.next and x.prev are different.
10:36:41 <EvanR_> hmm
10:36:46 <EvanR_> right
10:37:02 <byorgey> so you switch the beginning and ending and flip a bit telling you to interpret next as prev and vice versa
10:37:03 <EvanR_> so it needs a traverse direction flag
10:37:17 <EvanR_> anyway, how to make it functional
10:37:20 <Cale> Yeah, if you want with Data.Sequence, you could do the same :)
10:37:22 <mauke> an array with a 'reversed' flag is pretty efficient
10:37:29 <yitz> a type class, like for Monoid
10:37:30 <mauke> O(1) reverse, O(1) acccess
10:37:32 <Cale> Because accessing Data.Sequence from either end is equally efficient.
10:37:51 <EvanR_> ah
10:38:15 <EvanR_> bbee's captain kirk quote just changed my life
10:38:36 <yitz> EvanR_: haha. if so you had better get back to work.
10:38:50 <EvanR_> pah
10:39:08 * yitz has to go too. bye.
10:39:45 <mekeor> bye, yitz
10:55:53 <solrize> http://erlangonxen.org/  neat, erlang has its own halvm
10:59:14 <edwardk> fmap: lack of time spent writing it
10:59:23 <edwardk> mekeor: yes
10:59:37 <edwardk> fmap: i need to spend some time overhauling free
11:00:39 <edwardk> fmap: also when i release it it'll screw up users of the transformer-free package because i'm taking its module name ;)
11:00:39 <mekeor> edwardk: cool, thansk
11:04:00 <hpaste> Kuraitou pasted “libtcod build errors” at http://hpaste.org/73190
11:04:01 <Kuraitou> Does anyone know what would cause errors like these? I'm trying to build haskell-libtcod on Windows.
11:05:19 <DMcGill> is (.:) going to be in base in the new release?
11:05:30 <DMcGill> At least 4 packages have it defined in their utils
11:05:59 <mekeor> @ty (.:)
11:06:00 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
11:06:09 <hpaste> none pasted “cairo” at http://hpaste.org/73191
11:06:12 <efe> I followed this tutorial ( http://projects.haskell.org/diagrams/tutorial/DiagramsTutorial.html ), but when I say "cabal install gtk2hs-buildtools cairo"
11:06:19 <efe> I get http://hpaste.org/73191
11:06:30 <parcs`> a whole 4 packages?! :P
11:06:35 <efe> this error, can someone help me?
11:07:30 <DMcGill> it seems like a generally useful function that is in use
11:07:39 <mekeor> efe: hm, it doesn't really say why it fails...
11:07:39 <DMcGill> even if it's the more specialised function instance
11:08:08 <efe> mekeor: yes..
11:08:28 <mekeor> efe: you might want to ask in #diagrams, too
11:08:41 <efe> mekeor: ok, thanks :)
11:09:28 <Cale> efe: Were there any other messages while building the cairo package?
11:09:30 <fmap> edwardk: oh, okay, I'm patiently waiting for the release then
11:10:05 <Jurily> efe: try doing it by hand with cabal unpack/configure/build/install
11:10:14 <edwardk> fmap: the code is on github, patches are a great way to get me started ;)
11:10:31 <Cale> (but before that, just try  cabal install cairo-0.12.3.1
11:10:32 <Cale> )
11:10:49 <Cale> and see if there's anything obvious, like perhaps you're missing the C library which it's a binding to
11:11:40 <thorkilnaur> efe, I am not sure, but cabal ought to allow, say, a -v option to increase verbosity and get more detailed error reports
11:14:04 <otters> > succ .: Just (Right 3)
11:14:05 <efe> Thank you for your responses, I will go through it
11:14:06 <lambdabot>   Just (Right 4)
11:14:09 <otters> neat
11:15:01 <DMcGill> > (succ .: (+)) 3 4
11:15:04 <lambdabot>   8
11:15:41 <mekeor> @pl \x y -> succ (x + y)
11:15:41 <lambdabot> (succ .) . (+)
11:15:52 <mekeor> so, that's .:... i see
11:15:58 <shurikas> how can I pass a type parameter to function so I could use it like (v :: a) where a is my parameter?
11:16:09 <shurikas> and v :: a is in function body
11:16:14 <mekeor> shurikas: you can't
11:16:27 <mekeor> :/
11:16:29 <shurikas> hm
11:17:21 <Saizan> shurikas: look at ScopedTypeVariables
11:17:46 <nurpax> hi..  I'm feeling like a n00b..  But isn't there a better way to convert a T.Text to UTCTime (or any Read'able) than doing "read . T.unpack $ t" (in which t :: T.Text)
11:18:18 <nurpax> T.Text derives Read but somehow I can't get that to type check.  GHC is expecting 't' still to be a String
11:18:32 <DMcGill> read :: Read a => a -> String
11:18:44 <DMcGill> for Text, read :: Text -> String
11:18:57 <mekeor> nurpax: yeah, just do "read t"
11:18:58 <merijn> DMcGill: You're thinking of show
11:19:07 <DMcGill> ah, other way around
11:19:30 <mekeor> am i thinking wrong, too? oO
11:19:32 <DMcGill> still for Text, read :: String -> Text
11:19:51 <DMcGill> there isn't a readText :: Read a => Text -> a
11:19:59 <DMcGill> other than "T.pack . read"
11:20:11 <mekeor> okay, so forget what i said..
11:21:39 <merijn> Saizan: ScopedTypeVariables doesn't do what he wants, he wants types as values, not provide a type signature based on the type variables in the outer function
11:21:50 <DMcGill> oops, I mean "read . T.unpack", which is what you said. In short nurpax: no, not that I know of
11:22:35 <Saizan> merijn: is there some context i'm missing?
11:23:06 <nurpax> mekeor, DMcGill: I must be missing an import, it's not type checking
11:23:53 <mekeor> read the error message.. :)
11:24:00 <nurpax> DMcGill: I'm looking for read :: Text -> UTCTime or similar
11:24:01 <mekeor>  import qualified Data.Text as T ?
11:24:06 <nurpax> that's what I have
11:24:22 <DMcGill> readText :: Read a => Text -> a; readText = read . T.unpack
11:24:43 <nurpax> DMcGill: gotcha, so it looks like I need to go via an unpack
11:25:00 <DMcGill> 'fraid so, Read and Show are strictly for Strings only
11:25:11 <DMcGill> @hoogle genericRead
11:25:12 <lambdabot> No results found
11:27:19 <merijn> Saizan: He asked to use "v :: a" in the function body where a is a parameter to the function
11:27:55 <merijn> Saizan: Not "a is the *type of* a parameter of the function"
11:27:56 <DMcGill> what about asTypeOf?
11:28:00 <DMcGill> :t asTypeOf
11:28:02 <lambdabot> forall a. a -> a -> a
11:28:17 <DMcGill> @src asTypeOf
11:28:17 <lambdabot> asTypeOf = const
11:32:45 <nobdraisentone> How can I generate all possible lists like [[(1,1),(2,1),(3,1)],[(1,2),(2,1),(3,1)],...[(1,3),(2,3),(3,3)]]? It's for n == 3,
11:33:18 <scshunt> that seems like an easy comprehension
11:33:29 <johnw> [ (x, y, z) | x <- [1..], y <- [1..], z <- [1..] ]
11:33:47 <scshunt> johnw: that... doesn't work the way you want it to
11:33:55 <mekeor> that's wrong
11:33:56 <johnw> (,,) <$> pure [1..] <*> pure [1..] <*> pure [1..]
11:34:14 <johnw> oh, drop the pures
11:34:15 <mekeor> that's wrong
11:34:20 <johnw> well, I tried :)
11:34:33 <scshunt> > take 10 [(x, y, z) | x <- [1..], y <- [1..], z <- [1..] ]
11:34:35 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1...
11:34:36 <mekeor> he wants (x,y), not (x,y,z)
11:34:38 <scshunt> notice a problem here?
11:34:57 <nobdraisentone> Applicative variant looks like not abstract from n
11:35:07 <johnw> (,,) <$> [1..3] <*> [1..3] <*> [1..3]
11:35:10 <nobdraisentone> As comprehension, btw
11:35:14 <johnw> that works in my ghci window
11:35:36 <DMcGill> I'm not sure what the problem is - how do you define each of the sublists? Just all possible combinations?
11:35:38 <scri> > take 10 [[(x,y) | x <- [1..]] | y <- [1..]]
11:35:40 <lambdabot>   [[(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1),(11,1),(12,1...
11:35:52 <johnw> > (,,) <$> [1..3] <*> [1..3] <*> [1..3]
11:35:52 <scri> > take 10 [[(x,y) | x <- [1..3]] | y <- [1..]]
11:35:54 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2...
11:35:54 <lambdabot>   can't find file: L.hs
11:36:02 <scshunt> johnw: that works for finite lists
11:36:09 <johnw> i think he just wanted up to 3
11:36:10 <mekeor> don't spam -.-
11:36:11 <nobdraisentone> johnw: what if n = 20 now?
11:36:17 <johnw> I'm spamming now?
11:36:19 <johnw> wtf?
11:36:23 <scri> > take 10 [[(x,y) | x <- [1..3]] | y <- [1..]]
11:36:25 <lambdabot>   [[(1,1),(2,1),(3,1)],[(1,2),(2,2),(3,2)],[(1,3),(2,3),(3,3)],[(1,4),(2,4),(...
11:36:47 <scri> one nested comprehension
11:36:51 <byorgey> efe: cairo is failing to install for some reason, but the actual reason is buried somewhere above in the ... part
11:37:17 <byorgey> efe: try doing 'cabal install cairo' and paste the entire output, and I'll take a look
11:37:37 <Y0Gi> I compiled a rather tiny Haskell program with GHC into a binary file. but it's still around 1 megabyte in size. are there stable ways to optimize that (i.e. reduce the file size)?
11:38:07 <scri> Y0Gi: does size really matter?
11:38:11 <merijn> Y0Gi: I think that by default the entire runtime is included and that it is a bit tricky to strip that
11:38:13 <JoeyA> Y0Gi: You could run the strip command on it to shrink it a little.
11:38:23 <JoeyA> (namely, by removing debugging symbols)
11:38:28 <Y0Gi> scri: depends on whom one asks.
11:38:35 <byorgey> efe: oh, I see others also already responded
11:38:36 <DMcGill> how would I pretty print with base?
11:38:44 <JoeyA> I think cabal install strips the binary automatically.
11:39:01 <DMcGill> doesn't have to be complicated, even just having a showWithIndex or something would be good
11:39:03 <mekeor> byorgey: no, his problem remains
11:39:06 <DMcGill> indent*
11:39:17 * hackagebot carray 0.1.5.2 - A C-compatible array library. (HenningThielemann)
11:39:40 <DanBurton> quick poll: I want to make a reverse state monad transformer package, 1) does such a package already exist, and 2) if not, should I call it "reverse state" or "backwards state"?
11:39:47 <scri> Y0Gi: i think if you want a standalone executable it's going to inevitably have some overhead
11:39:51 <Y0Gi> hmm. then again, 1 meg is still nothing compared to having some kind of VM around that needs to be started first (be it Python, Java, Lua or whatever).
11:40:08 <shurikas> how can I define a function which returns a different type than specified using fun v :: MyType ?
11:40:42 <shurikas> MyType is needed as a type variable for an intermediate step inside a function
11:40:50 <shurikas> but the returned value is of different type
11:41:00 <merijn> Y0Gi: As your programs become bigger than RTS overhead will be marginal to say the least
11:41:09 <Y0Gi> I was wondering if small tools called with keyboard shortcuts aren't better off written in Haskell to be self-contained and fast to launch compared to some to-be-interpreted scripts.
11:41:15 <Clint> how would one express the list comprehension [x | y x] monadically?
11:41:37 <merijn> Y0Gi: The way OSes and executable work the executable size doesn't matter
11:41:37 <tgeeky_> Clint: ?
11:41:41 <efe> byorgey: I just saw that it says "Cannot find gtk2hsC2hs Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin)" in the "...". But ~/.cabal/bin is in my $PATH and "cabal install gtk2hs-buildtools"worked fine
11:41:59 <DMcGill> Cline: do {guard y x; return x}
11:42:00 <Clint> tgeeky_: or "not as a list comprehension and not as an if/then/else"
11:42:01 <scri> Y0Gi: the difference is hard to notice on a small tool
11:42:03 <byorgey> efe: also, feel free to rejoin #diagrams, if you post questions there you will definitely get a response, just not necessarily right away
11:42:07 <JoeyA> DanBurton: I don't know, but this might be helpful (as far as naming goes): http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Applicative-Backwards.html
11:42:09 <merijn> Y0Gi: For example, linux and BSD will map the entire executable into memory, but not actually load it. When it tries to access a memory page the page will fault and the OS will load it from disk
11:42:10 <DMcGill> "Clint" I meant
11:42:15 <Clint> DMcGill: thanks
11:42:31 <merijn> Y0Gi: As a result unaccessed parts of the executable shouldn't be loaded and thus not impact performance
11:42:50 <JoeyA> DanBurton: Otherwise, I'm thinking "reverse state" is better than "backwards state"
11:42:53 <tgeeky_> Clint: I didn't think that y was a boolean function
11:42:57 <tgeeky_> Clint: so I was confused
11:42:57 <JoeyA> "reverse state" can be abbreviated RState
11:43:00 <merijn> Aside from using a few memory pages, but that should hardly affect your machine
11:43:16 <JoeyA> While backwards state would be BState, which isn't as obvious.
11:43:19 <Y0Gi> I guess I'm good then.
11:43:20 <byorgey> efe: what is the output if you type 'which gtk2hsC2hs' at a prompt?
11:43:49 <efe> byorgey: it gives me no output at all
11:44:14 <JoeyA> DanBurton: Or even RevState.  Either way, "reverse" is much easier to abbreviate than "backward(s)"
11:44:17 <merijn> Y0Gi: Consider that the bash executable (on my system at least) is already 1.3MB
11:44:19 * hackagebot fft 0.1.7.2 - Bindings to the FFTW library. (HenningThielemann)
11:44:21 <byorgey> efe: and is there actually a file called gtk2hsC2hs in ~/.cabal/bin ?
11:44:21 <luite> efe: is ~/.cabal/bin in your $PATH ?
11:44:28 <DanBurton> JoeyA: quite right, I think I'll go with "reverse" so as to not clash with "control.applicative.backwards"
11:44:42 <Y0Gi> merijn: good point.
11:44:43 <byorgey> luite: efe claims it is, but I'm not sure I believe it =)
11:45:00 <luite> byorgey: never believe strangers on the internets!
11:45:02 <DanBurton> RevState seems like a reasonable abbreviation
11:45:13 <DanBurton> I'll write it up and see how I feel about it
11:45:30 <tgeeky_> DanBurton: Etats
11:45:56 <byorgey> ...which, strangely, means "states" in French
11:46:20 <johnw> did someone privmsg from this channel?  my client exited before I could respond
11:46:48 <tgeeky_> byorgey: of course! coup d'etat!
11:47:05 <efe> luite, byorgey: no problem =) here is what there is on the shell: http://hpaste.org/73195
11:47:30 <luite> efe: yeah the ~/.cabal/bin is wrong
11:47:36 <DanBurton> tgeeky_: etats?
11:47:39 <byorgey> efe: /~/.cabal/bin  doesn't look right
11:47:43 <byorgey> lose the initial /
11:47:43 <tgeeky_> DanBurton: I just reversed "State"
11:47:44 <roconnor> DanBurton: planning to clash with http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Reverse.html instead?
11:47:48 <DanBurton> oh lol
11:47:58 <tgeeky_> DanBurton: but it happens to mean "States" in French
11:48:06 <DanBurton> roconnor: ugh :(
11:48:22 <tgeeky_> DanBurton: don't mind that (data-functor-reverse and applicative-backwards)
11:48:22 <DanBurton> etats is sounding less horrendous..
11:48:29 <tgeeky_> it was just added and nobody uses it
11:48:34 <tgeeky_> (yet)
11:48:36 <byorgey> DanBurton: maybe call it SpookyTimeTravelingState
11:49:00 <DanBurton> byorgey: xD well I already named my other library Tardis
11:49:05 <byorgey> hehe
11:49:08 <DanBurton> I figured I'd give this one a sensible name
11:49:36 <byorgey> nah, call this one Delorean
11:52:29 <timthelion> I've asked this before, I'll ask this again.
11:52:42 <timthelion> Is there really no way of pattern matching against multiple patterns?
11:53:13 <timthelion> Like data F = A | B | C ; f A | B = 1 ; f C = 2?
11:53:30 <DMcGill> timthelion: f A = f'; f B = f'; f C = g is your best bet
11:53:44 <jfischoff> DanBurton: Do you think it could used for something like look ahead when parsing?
11:53:53 <jfischoff> DanBurton: Tardis that is
11:54:26 * timthelion cries
11:54:35 <timthelion> DMcGill: I already know about that :( it's so ugly
11:55:13 <roconnor> timthelion: have you considered pattern views?
11:55:15 <scri> timthelion: or case-of
11:55:24 <DMcGill> how about f x | isA x || isB x = f'; f C = g
11:55:26 <timthelion> roconnor: what are they?
11:55:40 <roconnor> they are functions you run in place of patterns
11:55:47 <timthelion> DMcGill: lots of work, but less ugly...
11:55:49 <efe> byjorgey, luite thanks for your suggestion, I'll try to figure out how to delte some variables from $PATH and report when I made it :)
11:56:10 <JoeyA> timthelion: How often do you plan on doing the same thing for multiple constructors?  Maybe you should consider factoring the data type.
11:56:36 <roconnor> f (Just 1 <- getAorB) = ... where getAorB (A x) = Just x; getAorB (B x) = Just x; getAorB _ = Nothing.
11:56:48 <timthelion> JoeyA: I would, but I have entirely different groupings based on the different use cases.
11:57:04 <scri> timthelion: can you do like f x = case x of A | B -> 1; C -> 2 ?
11:57:21 <timthelion> scri: is that even possible?
11:57:24 <DMcGill> scri: that doesn't work, "|" enters guards
11:57:30 <roconnor> oh I miss parsed that
11:57:59 <timthelion> roconnor: yeah, I'd want Bools, but I see where you're going with that.
11:58:07 <JoeyA> I'd prefer the f' idea.  Then you can implement the cases as where clause definitions.
11:58:14 <scri> that sucks. timthelion, OCaml lets you do that
11:58:39 <timthelion> And do those "lense" things, or that "TemplateHaskell" thing allow me to generate functions like isA A = True;isA _ = False automagically?
11:58:43 <scri> you could just do let f = function A | B -> 1 | C -> 2
11:59:11 <DMcGill> TH could do it, it'd probably be just as much effort as doing it yourself though
11:59:18 * hackagebot Elm 0.3.6 - The Elm language module. (EvanCzaplicki)
11:59:24 * timthelion has been putting off learning TH
11:59:33 <DMcGill> if you had dozens of constructors, you could try abusing enum?
11:59:35 <byorgey> efe: well, how are you setting the $PATH?
11:59:44 <timthelion> DMcGill: enum?
11:59:50 <edwardk> clearly you shoud use Data.Data and use the constructor analysis ;)
11:59:51 <DMcGill> f x | fromEnum x >= 3 && fromEnum x < 6
12:00:16 <edwardk> > Data.Data.toConstr (Just 12)
12:00:17 <lambdabot>   Not in scope: `Data.Data.toConstr'
12:00:19 <edwardk> aw
12:00:29 <JoeyA> e.g.: sendToSpace entity = case entity of Human x -> spaceElevator x; Robot x -> spaceElevator x; Rocket x -> launch x where spaceElevator x = ...; launch x = ...
12:00:40 <byorgey> efe: it's not really an issue of deleting things, just edit the place where you add ~/.cabal/bin  and then re-open a terminal, log out and log back in, or whatever
12:00:56 <timthelion> > Nothing == Nothing
12:00:58 <lambdabot>   True
12:01:18 <timthelion> In *this* case, I can use guards
12:01:35 <efe> byorgey: I followed this site http://ubuntuforums.org/showpost.php?p=6649277&postcount=4 I added the correct one, but the false on with the "/" is still there
12:02:01 <timthelion> right?  f x | x == A || x == B = 1 ;f x | x == C = 2?
12:02:14 <byorgey> efe: that's ok for now, the false one is not hurting anything
12:02:40 <byorgey> efe: wait, you mean the false one and the correct one are there? or just the false one?
12:02:51 <DMcGill> timthelion: only if your data type doesn't actually have any values, only constructors
12:03:10 <DMcGill> so it would work for Nothing, not if you wanted a Just value though
12:03:19 <DMcGill> you can't do "x == Just _" or something
12:03:21 <timthelion> DMcGill: in this case I'm safe on that(but only because I already did a refactor)
12:03:24 <byorgey> efe: you should have something like  PATH=$PATH:~/.cabal/bin
12:03:50 <byorgey> efe: not  PATH=$PATH:/~/.cabal/bin
12:04:00 <timthelion> DMcGill: In this case, I was smart enough to do data Value = Value {....... , ValueVariety}, data ValueVarieth = A|B|C|D
12:04:04 <DMcGill> tbh I'd still have f x | matches x == 1 where matches A = True; matches B = True; matches _ = False
12:04:31 <byorgey> efe: that post on ubuntu forums is not very clear, it makes it look like you must prepend / before the path you want, but that is not true
12:04:45 <merijn> DMcGill: Pattern guards would work for that too
12:04:53 <edwardk> fmap: check github.com/ekmett/free -- I added FreeT. i'll add CofreeT before i release though
12:04:54 <DMcGill> in Text.PrettyPrint, what does "ribbonsPerLine" mean?
12:04:58 <efe> byorgey: yes, I have ":/home/tobias/.cabal/" there too, the "~/" probably got replaced
12:05:06 <efe> byorgey: yeah, thanks =)
12:05:13 <DMcGill> the description is "Ratio of ribbon length to line length", I don't know what that means eithe
12:05:31 <merijn> For example "f x | Just _ <- x" would work just fine
12:06:21 <timthelion> DMcGill: this is in a description of a Text data type?
12:06:30 <DMcGill> rhttp://hackage.haskell.org/packages/archive/pretty/latest/doc/html/Text-PrettyPrint.html
12:06:33 <DMcGill> http://hackage.haskell.org/packages/archive/pretty/latest/doc/html/Text-PrettyPrint.html
12:06:54 <DMcGill> in the Style data type
12:09:12 <byorgey> DMcGill: if a page is 100 characters wide, it does not look good to always put as close to 100 characters on each line as possible
12:09:35 <timthelion> DMcGill: well it's an unusal usage, but I think they mean "word groupings"  So they sometimes have more space inbetween word groupings...
12:09:58 <timthelion> My guess based on reading the source code
12:10:09 <byorgey> DMcGill: a ribbonsPerLine of 1.5 means that the ratio of actual page width to maxuimum number of charaters per line should be 1.5
12:10:37 <byorgey> DMcGill: with indentation etc. the code will look like a "ribbon" of text going back and forth across the page
12:10:55 <DMcGill> I think I'll have a play around with it
12:11:15 <byorgey> DMcGill: this is explained in section 7.4 of Hughes' paper "The design of a pretty-printing library"
12:11:32 <moleculo> Hi guys. Quick question: is there a haskell tutorial available that's very hands-on, possibly inspecting an existing codebase, or creating something from start to finish while introducing Haskell features?
12:11:49 <DMcGill> real world haskell does that right?
12:11:53 <argiopeweb> Yep
12:11:57 <DMcGill> @where RWH
12:11:58 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:12:09 <moleculo> awesome thanks, will have a look
12:12:22 <argiopeweb> LYAH is very hands on, but RWH is very focused on building real world things.
12:12:37 <DMcGill> I prefer LYAH myself, but it's more learning/exercise based then one continuous program
12:12:58 <argiopeweb> I read RWH till my mind broke, then did LYAH and went back to finish RWH.
12:13:36 <moleculo> i find lyah more like a list of features that aren't really connected in any way, like in a project or some kind of goal. at least from the first 2 or 3 chapters.
12:14:07 <DMcGill> It is like that, but I don't see the problem with it
12:14:21 <DMcGill> oh well, hopefully RWH is more what you're looking for!
12:14:29 <moleculo> well, it's not a problem, just a different learning style i guess.
12:14:52 <argiopeweb> I'd argue it's beneficial since the Haskell method of programming is so much different from most other languages that you don't want to jump directly into a big project.
12:16:24 <argiopeweb> But I would at least keep LYAH in your back pocket so you can come back to it if/when Real World Haskell makes your mind boggle.
12:16:57 <merijn> moleculo: Personally I got confused several chapters into RWH because it glosses over some important details
12:17:23 <EvanR_> whatever happened to manatee integrated gui thingie?
12:17:31 <EvanR_> and the dude who wrote it
12:18:15 <merijn> moleculo: LYAH makes a completer introduction of the fundamentals. Personally I think the best approach is to read LYAH first, RWH second. But if you wanna try out RWH until you get confused that should also work
12:18:43 <merijn> Although that approach may make reading the first few chapters of LYAH a bit more of a chore, since you know most stuff but need to search for the missing bits
12:18:52 <timthelion> EvanR_: bank ate him
12:19:01 <EvanR_> >_>
12:19:12 <timthelion> EvanR_: we need to destroy the banks.  They kill all the best haskell programmers.
12:19:31 <argiopeweb> He's theoretically still alive... Kind of a Jonah & the whale type of thing.
12:19:35 <moleculo> yeah, maybe i should just be more patient and go through LYAH first. just feels frustrating because I'm sitting with code based on WAI/Warp and don't have the faintest clue how it works. Haha... haven't had that experience since learning to code at school
12:19:41 <timthelion> kill=land them with (presumably high paying) jobs with non disclusure agreements
12:19:52 <EvanR_> o
12:20:07 <argiopeweb> moleculo:  You may not know why WAI/Warp code works in 6 months either. :P
12:20:14 <EvanR_> i did write most of my real hobby code while unemployed
12:20:24 <EvanR_> now i find it hard to concentrate
12:21:02 <fmap> edwardk: oh, i will, thanks
12:21:04 <timthelion> EvanR_: I think I'm going to be a house painter when I graduate from college.  Just so I can focus my mental energies on open source
12:21:24 <edwardk> fmap: i kept the shape of it compatible with transformers-free, but added all the missing instances
12:21:26 <moleculo> lol as long as i can build something on it i'll be happy! thanks for the advice.
12:21:26 <EvanR_> hmm.
12:21:28 <merijn> moleculo: Haskell has a very long runway, in the sense that not only do you need to know the language, but also understand the "extended prelude" (i.e. the common libraries everyone uses) to be able to understand real production code
12:21:52 <edwardk> (Eq, Show, etc)
12:22:00 <EvanR_> Maybe
12:22:02 <EvanR_> Monad
12:22:07 <EvanR_> etc
12:22:13 <DMcGill> both RWH and LWAH touch on some of them a bit iirc
12:22:38 <merijn> moleculo: Much more so than in any other language I've used. Although now tht I *know* all this stuff I have a feeling most applications require relatively little actual coding :p
12:22:48 <timthelion> merijn: and even then someone *ehem edwardk* will go inventing crazy useless libraries with a buch if dots and dollar signes, and the code you read will end up looking like perl.
12:22:58 <edwardk> ?
12:23:05 <roconnor> timthelion: %%=!
12:23:06 <timthelion> edwardk: lenses, wasn't that you?
12:23:16 <edwardk> you don't have to use it
12:23:17 <merijn> DMcGill: Yeah, they cover Control.Applicative and Control.Monad I guess, but not (yet?) stuff like lenses and arrows
12:23:18 <mauke> timthelion: Perl is readable
12:23:25 <timthelion> edwardk: you still have to read it :D
12:23:25 <roconnor> what part of %%=! don't you understand? :P
12:23:32 <LadyAurora> edwardk: ($).($)
12:23:36 <merijn> roconnor: Isn't it !%%=?
12:23:42 * roconnor has no idea
12:23:45 <LadyAurora> mauke: lol
12:23:51 <edwardk> roconnor: i don't have !%%=
12:23:52 <mauke> LadyAurora: that's not a joke
12:23:55 <DMcGill> merijn: A page on the wiki called "So you know Prelude" would be great
12:23:57 <merijn> Note, question mark wasn't part of the operator :p
12:24:03 <LadyAurora> :t ($).($)
12:24:04 <lambdabot> forall a b. (a -> b) -> a -> b
12:24:18 <DMcGill> I mean I still haven't used lenses, fundeps and so on
12:24:25 <DMcGill> and only recently used arrows
12:24:29 <EvanR_> i have 13 operators in my lib. !%%= %!%= %!=% !%=% ...
12:24:31 <roconnor> DMcGill: you will use lenses/traversable.
12:24:32 <merijn> DMcGill: Lenses are pretty freaking cool
12:24:34 <DMcGill> even if it consisted of just links to tutorial for those things
12:24:38 <merijn> fundeps, not quite
12:24:45 <merijn> Well, probably still cool
12:24:58 <merijn> But not nearly as generally useful as lenses I mean :p
12:24:59 <roconnor> er lenses/traversals
12:25:13 <roconnor> edwardk: multilenses are called traversals right?
12:25:21 * edwardk notes that roconnor has finally come around to the new name ;)
12:25:22 <JoeyA> Trivia: Prelude has the longest documentation page of all modules in the base package.
12:25:23 <edwardk> yes
12:25:26 <DMcGill> I mean tutorials for these things are pretty easy to find on the wiki once you know what to look for
12:25:36 <roconnor> edwardk: ya I'm coming around to traversals
12:25:44 <timthelion> JoeyA: really???
12:25:44 <DMcGill> but I don't know of a page saying which things you should learn after Haskell base
12:25:50 <roconnor> edwardk: holding out on %%= a bit.
12:25:59 <edwardk> not liking the operator?
12:25:59 <JoeyA> timthelion: According to byte size, and not including index pages or source pages, yes.
12:26:12 <EvanR_> DMcGill: learn exactly what you see in other code and what you need when you write your own code
12:26:13 <DMcGill> [sarcasm sign]
12:26:18 <roconnor> edwardk: I'm not finding it so intuative.
12:26:23 <timthelion> DMcGill: definitely learn bannana FRP.   Useless, but once you grok it, you'll be a god.
12:26:27 <edwardk> i had someone open an issue to change all the %'s to $'s
12:26:31 <JoeyA> I'm curious what the longest Haddock page is on Hackage.
12:26:41 <DMcGill> When I get back to making my game, I'll use bananaFRP and lenses shou
12:26:42 <JoeyA> The longest I've found is http://hackage.haskell.org/packages/archive/OpenGLRaw/latest/doc/html/Graphics-Rendering-OpenGL-Raw-Core31.html
12:26:55 <timthelion> JoeyA: oh, I see, in base.. Well duh.
12:27:15 <roconnor> edwardk: $$= almost make sense.  Why not have as a rule that every operator with more $'s than other characters is id.
12:27:18 <edwardk> JoeyA: i have Data.Colorimetry.Observer.TenDegree.StockmanJäglePirzerSharpe_2008  in an unreleased package
12:27:18 * timthelion wishes he groked FRP
12:27:27 <roconnor> :P
12:27:48 <timthelion> edwardk: since when were underscores allowed in module names?
12:27:59 <edwardk> since when weren't they?
12:28:03 <JoeyA> We should make a "records" page, like Wikipedia's:  http://en.wikipedia.org/wiki/Wikipedia:Wikipedia_records
12:28:11 <moleculo> one last question: does haskell have any builtin documentation features like python, or any "standard" way of finding and viewing module/member info?
12:28:22 <timthelion> moleculo: yes!!!!
12:28:25 <EvanR_> haddock
12:28:26 <mauke> moleculo: haddock
12:28:31 <jamwt> in case anyone finds it useful, we're using this at bu.mp: https://gist.github.com/3351984
12:28:33 <timthelion> moleculo: it is actually the best feature of haskell, period
12:28:36 <roconnor> you can ghci haddock?
12:28:44 <moleculo> haha sweet
12:29:12 <timthelion> roconnor: sadly, no
12:29:17 <DMcGill> molecule: that is actually one thing you can get a grip on by looking at the docs of Prelude and then the source
12:29:25 <roconnor> timthelion: not exactly like python
12:29:33 <merijn> moleculo: Even better, we have a search engine that lets you search the documentation by type signature \o/
12:29:39 <timthelion> roconnor: but infinitely better. due to the type system.
12:29:57 <timthelion> moleculo: hoogle, and hayoo, they are linked too on the haskell.org page
12:30:05 <merijn> @where hoogle
12:30:06 <lambdabot> http://haskell.org/hoogle
12:30:15 <edwardk> roconnor: anyways the reason i haven't swapped to $'s from %'s is that the intuition is slightly off.
12:30:18 <timthelion> moleculo: you will end up using hayoo more than google, and hoogle more than yahoo, if you start programming in haskell.
12:30:47 <edwardk> all the other combinators l <>~ a = over l (<> a), etc.
12:30:56 <edwardk> they use the value on the right hand side
12:30:57 <EvanR_> <> ?
12:31:02 <edwardk> the $ would put it on the left
12:31:05 <edwardk> <> = mappend
12:31:07 <EvanR_> ok
12:31:14 <Eduard_Munteanu> timthelion: that thing you just said looks a lot like an adjunction :)
12:31:18 <edwardk> it was an alias added in 7.4.1
12:31:34 <mekeor> in Data.Monoid, right?
12:31:36 <timthelion> Eduard_Munteanu: I'll have to google adjunction
12:31:36 <edwardk> yeah
12:31:37 <merijn> In tradition of fish for <=< I hereby dub <>~ the sperm
12:31:49 <Eduard_Munteanu> Ah, nevermind then.
12:31:51 <mekeor> there's also a <> in semigroups, a package by you, edwardk :)
12:32:01 <JoeyA> Also, the longest documentation page I've found that actually has text: http://hackage.haskell.org/packages/archive/gtk/latest/doc/html/Graphics-UI-Gtk-Abstract-Widget.html
12:32:02 <roconnor> merijn finally said what I have been thinking for weeks.
12:32:04 <mekeor> <>~ looks like a sperm :D
12:32:05 <edwardk> merijn: <<>~ winds up looking like a rat or something insectoidal that i'd flip out if it was crawling on my arm
12:32:07 <Jurily> (+‿+)
12:32:19 <JoeyA> (there might be longer; I just searched based on packages I have installed locally)
12:32:30 <EvanR_> mappend for a semigroup should be the same as an associated monoid right ;)
12:32:32 <merijn> Just you wait, this name is going to stick and I'm going to be internet famous
12:32:35 <edwardk> roconnor: you _asked_ for the sperm operator
12:32:39 <roconnor> I know
12:32:43 <roconnor> I use it quite a bit
12:32:45 <mekeor> EvanR_: right :)
12:32:51 <edwardk> i exiled it to Data.Monoid.Lens in the last release
12:33:15 <edwardk> when i add au, and auf, etc.
12:33:25 <edwardk> au _sum foldMap [1,2,3,4]
12:33:26 <timthelion> merijn: actually <> in slavic language speaking countries is the píča, or "vagaina"
12:33:38 <Jurily> Haskell operators are really getting out of hand
12:33:43 <EvanR_> haha
12:34:00 <EvanR_> A &@#$%@#$^@#$%@#$ B
12:34:04 <merijn> timthelion: Even better \o/
12:34:14 <mekeor> (?) is quite unused...
12:34:16 <roconnor> edwardk: Thats okay, I put it right into Lens.Family: http://hackage.haskell.org/packages/archive/lens-family-core/0.1.0/doc/html/Lens-Family.html#g:1
12:34:16 <Jurily> sadly, 8===D is not valid yet
12:34:25 <mekeor> Jurily: :D
12:34:37 <DMcGill> I still think we should have the family of (.), (.:). (.::), ...
12:34:48 <DMcGill> in the same way that we have (,), (,,), (,,,), ...
12:34:57 <mekeor> and [,] [,,] ...
12:35:00 <roconnor> DMcGill: I'm pretty used to (((f.).).) now
12:35:06 <roconnor> I don't feel the need for those operators
12:35:07 <JoeyA> > [,,] 1 2 3
12:35:07 <mekeor> ([,] x y = [x,y])
12:35:09 <lambdabot>   <no location info>: parse error on input `,'
12:35:14 <DMcGill> roconnor: :(
12:35:35 <JoeyA> Does [,,] exist yet?
12:35:42 <mekeor> nope
12:35:44 <EvanR_> thats silly
12:35:48 <mekeor> but i want it
12:36:08 <EvanR_> :t (,,)
12:36:10 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
12:36:16 <mekeor> :k (,,)
12:36:18 <lambdabot> * -> * -> * -> *
12:36:27 <DMcGill> it'd be much easier if, rather than [,,], [,,,] there was just one function that could take multiple things
12:36:29 <DMcGill> say in a list
12:36:33 <DMcGill> I dub this, "id"
12:36:50 <EvanR_> > id 9 3 4 1 2
12:36:52 <lambdabot>   9
12:37:01 <frerich_> DMcGill: I think you're on to something there.
12:37:05 <DMcGill> id [4,2,54,6,4]
12:37:07 <DMcGill> > id [4,2,54,6,4]
12:37:09 <lambdabot>   [4,2,54,6,4]
12:37:11 <DMcGill> perfect
12:37:34 <EvanR_> > id (5,'a',False)
12:37:36 <lambdabot>   (5,'a',False)
12:37:36 <timthelion> DMcGill: how would that be easier? In any way?
12:37:39 <EvanR_> awesome
12:37:53 <timthelion> > id id
12:37:55 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:37:55 <lambdabot>    arising from a use of `...
12:37:59 <mekeor> > id id id 5
12:38:01 <lambdabot>   5
12:38:08 <mekeor> > fix id
12:38:12 <lambdabot>   mueval-core: Time limit exceeded
12:38:22 <timthelion> > break id
12:38:24 <lambdabot>   Overlapping instances for GHC.Show.Show
12:38:24 <lambdabot>                              ([GHC....
12:38:29 <mekeor> ?
12:38:37 <DMcGill> timthelion: https://lh5.googleusercontent.com/-mJnSn-Z5z2c/Tiks7iMJRYI/AAAAAAAAEMo/EV2J8oSWFrM/sarcasm%2Bsign.jpg
12:38:52 <EvanR_> @src id
12:38:53 <lambdabot> id x = x
12:38:53 <mekeor> DMcGill: that's you?
12:38:53 <LadyAurora> :t break
12:38:55 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:38:59 <DMcGill> thankfully not
12:39:03 <mekeor> :D
12:39:16 <timthelion> DMcGill: Oh, I thought you where just being an idiot... You know, "think thus of others, as others would think thus of you."
12:39:28 <DMcGill> well I was just being an idiot
12:39:38 <DMcGill> but intentionally in the persuit of humour
12:39:38 <timthelion> :P
12:39:39 <mekeor> you *are*, too
12:39:47 <mekeor> https://lh5.googleusercontent.com/-mJnSn-Z5z2c/Tiks7iMJRYI/AAAAAAAAEMo/EV2J8oSWFrM/sarcasm%2Bsign.jpg
12:39:49 <timthelion> mekeor: hey, that's not nice
12:40:00 <mekeor> see pic
12:40:12 <amliby> Is there a way to take a .cabal file and automagically apt-get any libghc- packages corresponding to the build-depends?
12:40:53 <mekeor> amliby: never heard something like that. but nice idea, nice project :
12:40:54 <mekeor> :)
12:41:03 <timthelion> amliby: yeah, look at the error message, google the words in the error message, along with apt get, apt get the package, and recurse
12:41:04 <Eduard_Munteanu> Gentoo has something like that IIRC.
12:41:18 <timthelion> amliby: don't forget, you are a robot, anything YOU do, is automagic too!
12:41:18 <Eduard_Munteanu> I mean, something that generates ebuilds for Haskell packages.
12:41:21 <n00b6502> can compiled  haskell IO () functions be called from C
12:41:33 <Eduard_Munteanu> n00b6502: yeah
12:41:35 <timthelion> Arch does too, but it sucks.
12:41:49 <Eduard_Munteanu> @google haskell from c
12:41:51 <lambdabot> http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
12:41:51 <lambdabot> Title: Calling Haskell from C - HaskellWiki
12:41:53 <JoeyA> On Hackage, some packages list Distributions.  Where does that info come from?
12:41:57 <Eduard_Munteanu> n00b6502: ^^
12:42:07 <JoeyA> e.g. http://hackage.haskell.org/package/mtl
12:42:14 <JoeyA> it says Distributions	Fedora: 2.0.1.0, NixOS: 2.1.2, Debian: 2.1.1, FreeBSD: 2.1.1
12:42:31 <mekeor> JoeyA: well, those package are in the official packet repositories of those distros
12:42:51 <Eduard_Munteanu> Oh, you said IO () stuff.
12:43:13 <timthelion> Why is there still no haddock for my package http://hackage.haskell.org/package/her-lexer-0.1 it's been like a week!
12:43:16 <n00b6502> i made the assumption that would be easier than lazy-eval-land
12:43:18 <mekeor> JoeyA: the list prolly generated by hackage itself somehow (since it's not in the cabal file)
12:43:39 <n00b6502> e.g. the imperative subset of haskell to compile c callables
12:43:49 <n00b6502> perhaps i was wrong
12:44:11 <Eduard_Munteanu> n00b6502: easier for what purpose?
12:44:14 <mekeor> timthelion: maybe it doesn't work, i mean, maybe "cabal haddock" doesn't succeed?
12:44:26 <timthelion> mekeor: why would it fail?
12:44:31 <mekeor> timthelion: btw, did you "cabal check"?
12:44:49 <n00b6502> for haskell.. i thought functions didnt ewally exist in the c sense due to lazy eval
12:44:56 <n00b6502> reaaly
12:44:57 <timthelion> I cabal sdistd, and then I uploaded it to the checker, but I never cabal checked from the CLI no.
12:44:58 <frerich_> What is 'fix' (from Data.Function) useful for? The only application I found was to generate an infinite list, but 'repeat' seems nicer to me for that.
12:45:19 <DMcGill> frerich_: it's equivalent to recursion
12:45:34 <JoeyA> > fix error
12:45:36 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
12:45:37 <roconnor> dist/build/tmp-9056/src/Language/Haskell/Her/FromClutterToLines.hs:5:3:
12:45:39 <roconnor>     parse error on input `-- | When we get the tokss from her-parser's ready, they're a bit cluttered.  I'm not sure what Dr. McBride had in mind when he made that mess.  But this doesn't mater, from this clutter we can create a list of lines which is aware of haskell's brackets.  If a multi-line clause is inside brackets, then we keep the whole section in the same "line".'
12:45:40 <JoeyA> That's it's primary use
12:45:40 <DMcGill> you can transform a recursive function into one using fix and vice versa
12:45:57 <mekeor> timthelion: "cabal check" is quite use for checking whether the cabal-file is fine...
12:46:22 <roconnor> timthelion: mekeor: cabal check succeeds; cabal haddock fails
12:46:23 <mekeor> donri recommended me that command recently :)
12:46:39 <amliby> Does anybody know if cabal-debian might have anything to resolve libghc packages?
12:46:45 <mekeor> roconnor: did you test?
12:46:50 <roconnor> yes
12:46:53 <mekeor> :)
12:46:59 <JoeyA> In seriousness, you can define loops without having to say "let".  E.g. fix $ \loop -> do delay 60; bumpTimer; dead <- isConnectionDead; when (not dead) $ loop
12:47:17 <roconnor> @src fix
12:47:18 <lambdabot> fix f = let x = f x in x
12:47:18 <timthelion> roconnor: That's a literate haskell file...  So it's unlitting by converting to comments...  And then those comments are no longer valid somehow.
12:47:25 <timthelion> roconnor: so what did I do wrong?
12:47:32 * roconnor doesn't know
12:47:40 <DanBurton> instance MonadFix m => MonadRevState s (RevStateT s m) -- how does this not satisfy the "coverage condition"?
12:47:51 <DanBurton> or rather, what *is* the "coverage condition"?
12:48:20 <timthelion> roconnor: well, thanks for looking into it.  Is haddock supposed to fail on "bad syntax" or is it supposed to warn?
12:48:25 <frerich_> JoeyA: Hmmm...
12:48:28 <mekeor> DanBurton: what is the coverage condition? ... was just about to ask that...
12:48:30 <roconnor> timthelion: I don't know
12:48:33 <DMcGill> timthelion: have you looked in the haddock docs about LHS?
12:48:41 <DMcGill> I'm sure there'd be a section specifying how it works
12:48:53 <monochrom> timthelion: haddock and literate haskell?
12:49:01 <timthelion> https://github.com/timthelion/her-lexer/blob/master/src/Language/Haskell/Her/FromClutterToLines.lhs
12:49:18 <timthelion> DMcGill: what haddock docs about LHS????? !!!! THey exist, I'd be thrilled(not being sarcastic here)
12:49:38 <monochrom> ok, write like this: "> -- | haddock sees this"
12:49:47 <roconnor> ya
12:49:55 <DMcGill> what monochrom said
12:50:02 <mekeor> what monochrom said
12:50:02 <roconnor> I've always put my haddock in comments in bird ticks
12:50:03 <timthelion> monochrom: so freekin ugly :(
12:50:03 <DMcGill> http://www.haskell.org/haddock/doc/html/invoking.html#cpp
12:50:19 <DMcGill> (although that seems really unhelpful)
12:50:25 <DMcGill> timthelion: tough
12:50:31 <DMcGill> ;)
12:50:33 <monochrom> yeah cpp is a bit of a different story
12:50:36 <timthelion> well it ruins the entire purpose of LHS
12:50:42 <DanBurton> mekeor: sounds like stackoverflow fodder; I guess I'll ask there.
12:50:52 <DMcGill> write a patch or request a change to haddock!
12:50:59 <mekeor> DanBurton: ok :)
12:51:02 <timthelion> but this is different.  Cabal actually implements it differently, and DOES support LHS
12:51:20 <timthelion> just, it's entirely undocumented.
12:51:33 <timthelion> and doesn't work, apparently
12:51:35 <geekagent> I think I understand why people have a hard time understanding arrows.
12:51:43 <monochrom> not convinced that it ruins the entire purpose of literate haskell. the entire point of literate haskell, Knuth's literate programming, is *internal* documentation. haddock is not internal documentation.
12:52:20 <geekagent> The haskell arrow typeclass mashes together three things a, b, c where a is independent and b->c
12:52:35 <geekagent> haskell arrows define a category where objects are haskell types.
12:53:06 <geekagent> and then asks if there's a functor from Hask to that category, arr
12:53:19 <DMcGill> I found arrows much easier when I started thinking "a b c" as "b -> c"
12:53:24 <geekagent> *** says that (,) is a monoid in the new category
12:53:24 <DMcGill> I mean I know it's not really correct
12:53:32 <DMcGill> but it gives you an intuition
12:53:34 <geekagent> DMcGill, actually it's perfect.
12:53:42 <JoeyA> What really helped me "get" arrows was learning about Mealy machines: data Auto a b = a -> (b, Auto a b)
12:53:52 <geekagent> Arrows should be thought of as a ~> b
12:54:04 <monochrom> b->c is a good starting example, don't worry
12:54:06 <JoeyA> A function is an Arrow, but Auto is an Arrow with an interesting side effect.
12:54:07 <DMcGill> could type sigs be amended?
12:54:25 <DMcGill> list :: Arrow (~>) => (a -> b) -> (a ~> b)
12:54:25 <monochrom> piaget's theory. concrete before abstract. always start with examples.
12:54:37 <DMcGill> lift*
12:54:44 <DMcGill> or even arr
12:54:48 <mekeor> that's called arr, yeah
12:54:48 <geekagent> DMcGill, yes, you can split up the typeclasses.
12:55:01 <mekeor> arrr, like a pirate :)
12:55:20 <DMcGill> I mean "a ~> b" seems way more intuitive for people than "a b c"
12:55:23 <geekagent> &&& says more than *** it says that (,) is not only a monoid, but the product in the new category.
12:55:29 <Eduard_Munteanu> @yarr
12:55:29 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
12:55:34 <Eduard_Munteanu> Hah.
12:55:35 <mekeor> DMcGill: you need -XTypeOperators for that
12:55:41 <Eduard_Munteanu> I actuall got an arr one.
12:55:44 <geekagent> I find it easier to call the category c and write c a b
12:55:56 <DanBurton> this is baffling. I am doing almost the exact same thing in RevState that I did in Tardis, yet for some reason the Tardis code is OK while the RevState code doesn't satisfy the coverage condition =/
12:56:25 <geekagent> similarly, there's no reason why ArrowChoice should depend on Arrow at all.
12:56:29 <DanBurton> asked, btw, on SO: http://stackoverflow.com/questions/11959764/what-is-the-coverage-condition
12:56:40 <geekagent> +++ says that Either is a monoid in the new category
12:56:56 <geekagent> and ||| says that it's the categorical sum (stronger than just the monoid condition)
12:57:54 <geekagent> ArrowApply says that the category has exponentials, witnessed by the eval map.
12:58:12 <Eduard_Munteanu> :t Category..
12:58:13 <otters> So for regular functions, arr is id
12:58:14 <lambdabot> parse error on input `Category..'
12:58:19 <geekagent> I wrote it up here: http://goo.gl/nSvY8
12:58:21 <Eduard_Munteanu> :t (Category..)
12:58:22 <lambdabot> Couldn't find qualified module.
12:58:24 <geekagent> otters, exactly.
12:58:26 <Eduard_Munteanu> Bah.
12:58:37 <otters> geekagent: how do you make a Kleisli arrow? I couldn't figure it out
12:58:46 <ocharles> :t (Control.Category..)
12:58:48 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
12:58:49 <geekagent> :t (Control.Category..)
12:58:51 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
12:58:52 <Eduard_Munteanu> Erm, yeah.
12:58:53 <ocharles> I WIN.
12:59:04 <mekeor> otters: kleisli isn't an arrow. Monad m => Kleisli m is an arrow :)
12:59:13 * Eduard_Munteanu is stuck in Agdaland where there's Category. stuff :)
12:59:20 <otters> mekeor: I thought "kleisli arrow" meant that
12:59:32 <otters> then again, I have no idea what kleisli is
12:59:34 <frerich_> DanBurton: http://research.microsoft.com/en-us/um/people/simonpj/papers/fd-chr/jfp06.pdf defines "Coverage Condition" (definition 7)
13:00:03 <geekagent> otters: you're defining a different kind of arrows.
13:00:08 <mekeor> otters: newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
13:00:18 <Eduard_Munteanu> otters: there's a Category for every Kleisli m, where id = return and (.) = (<=<)
13:00:25 <otters> oh
13:00:59 <otters> so it's a newtype wrapper around an arrow with monad-wrapped output?
13:01:06 <DanBurton> frerich_: thanks
13:01:07 <roconnor> indeed m satifies the monad laws iff Kleisli m satifies the category laws
13:01:22 <geekagent> otters: In haskell that's what it is. It was cribbed from category theory.
13:01:26 <frerich_> DanBurton: I just realized I could do this on SO and get a few points :-)
13:01:28 <Eduard_Munteanu> otters: monads are Kleisli arrows
13:01:29 <otters> I see
13:01:34 <roconnor> geekagent: it only looks that way
13:01:38 <otters> okay...
13:01:44 <DanBurton> frerich_: yeah go ahead and do that anyways :)
13:01:44 <otters> cranial integrity compromised
13:01:54 <JoeyA> DanBurton: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules
13:02:02 <roconnor> otters: this often happens on #haskell
13:02:03 <om> published the dictionary for auto-complete in emacs: https://github.com/mr-om/haskell-dict if anyone wants it
13:02:06 <DanBurton> I just realized, I made an incredibly stupid mistake. My class defined the fundep as s -> m rather than m -> s
13:02:10 <JoeyA> (that talks about context reduction, and gives some examples)
13:02:16 <otters> roconnor: you'd think I'd get used to it after this long
13:02:30 <mekeor> om: what's that? looks interesting
13:02:42 <geekagent> There are several posts about how things like Op or Bijections are almost arrow instances.
13:03:01 <geekagent> but they meet some of the criteria I separated out.
13:03:14 <mekeor> om: so, it's auto-complete for haskell functions?
13:03:22 <om> yes
13:03:45 <mekeor> om: does it include all base-functions, or..?
13:04:27 <om> it does
13:04:59 <mekeor> nice
13:05:10 <rosie> good way to execute an array of IO?
13:05:25 <ocharles> :t sequence
13:05:26 <Eduard_Munteanu> rosie: sequence from Data.Traversable
13:05:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:05:32 <rosie> thanks!
13:05:35 <Eduard_Munteanu> @hoogle sequence
13:05:36 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:05:36 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
13:05:36 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
13:05:42 <Eduard_Munteanu> @hoogle+
13:05:42 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
13:05:43 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
13:05:43 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
13:05:58 <ocharles> you probably want the Control.Monad.sequence
13:06:17 <DMcGill> no, the Data.Traversable.sequence
13:06:17 <ocharles> though I guess traversable would work too
13:06:20 <DMcGill> given that he's using arrays
13:06:21 <ocharles> cause [] is still traversable
13:06:25 <ocharles> oh, array
13:06:57 <JoeyA> Idea for alternative Prelude writers: include sequence in the Monad class, which strict monads can define to avoid the stack overflow issue.
13:07:21 <JoeyA> @src sequence
13:07:22 <lambdabot> sequence []     = return []
13:07:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:07:23 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
13:07:50 <JoeyA> sequence isn't tail recursive, so this'll produce a stack overflow if you try to sequence a list of IO actions that's too long.
13:08:25 <EvanR_> JoeyA: well, is that the actual sequence of just the one in lambdabot
13:08:25 <JoeyA> Meh, just define sequence' which builds the list in reverse, then reverses it.
13:08:45 <JoeyA> EvanR_: The actual sequence has the stack overflow problem.  (sequence_ does not)
13:11:13 <rudyl313> I'm having trouble encoding unicode characters with the urlEncode function from Network.HTTP.Base...the results returned from urlEncode "משה" are not the same as other url encoders... does anybody some wisdom in this regard?
13:12:23 <mauke> rudyl313: yeah, be less vague
13:12:41 <rudyl313> mauke: oh I didn't realize I was being unclear
13:12:43 <DanBurton> Well I've thrown together the initial code for RevState: https://github.com/DanBurton/rev-state
13:13:31 <monochrom> show actual code
13:13:45 <ocharles> DanBurton: why not tardis?
13:14:08 <mauke> rudyl313: 1) what other url encoders?  2) what are the results?  3) how are they different?
13:14:35 <ocharles> DanBurton: I mean, you wrote the thing after all :)
13:14:51 <DanBurton> ocharles: tardis is still there, too. I'm thinking about refactoring tardis to depend on rev-state
13:14:55 <ocharles> ah
13:15:26 <DanBurton> newtype TardisT bw fw m a = RevStateT bw (StateT fw m) a
13:15:34 <ocharles> makes sense
13:15:51 <DanBurton> whoops forgot = TardisT ( blah )
13:16:10 <rudyl313> mauke: 1) this online encoder, http://meyerweb.com/eric/tools/dencoder/ , 2) the online encoder returns "%D7%9E%D7%A9%D7%94" , while urlEncode returns "%05%DE%05%E9%05%D4" 3) they care just completely different
13:17:30 <rudyl313> mauke: the strange thing is if I try encoding a string like "{\"hi\":3}" it encodes identically in both cases
13:17:52 <mauke> rudyl313: urlEncode is horribly broken
13:18:11 <rudyl313> mauke: what can I use instead?
13:18:19 <mauke> no idea
13:18:45 <rudyl313> does anybody know of a reliable url encoding function for haskell?
13:19:02 <DanBurton> "url encoding"?
13:19:07 <rudyl313> yes
13:19:12 <DanBurton> what kind of input/output are you talking about
13:19:25 <mauke> DanBurton: what
13:19:41 <ocharles> WAT.
13:19:42 <rudyl313> any arbitrary unicode string should be input and a url encoded string should be returned
13:19:46 <rudyl313> that is valid
13:20:02 <timthelion> is there a countMatches :: (a -> Bool) -> [a] -> Int  or do I need to length $ filter ....
13:20:34 <DanBurton> mauke: ignore me, somehow I missed rudy's statements that came minutes before
13:20:53 <DanBurton> I really need to configure this client to hide those join/leave messages >,<
13:21:05 <JoeyA> timthelion: What's wrong with length $ filter ?
13:21:18 <mauke> rudyl313: can you file a bug against Network.HTTP.Base?
13:21:27 <atriq> If Haskell was being first designed now, I wonder how different it would be
13:21:29 <DMcGill> you could even do countMatches = length .: filter
13:21:29 <DMcGill> !
13:21:30 <atriq> Probably vastly
13:22:19 <DanBurton> atriq: at the library level, Snoyman and I are working on more "modern" Preludes
13:22:30 <timthelion> JoeyA: it is slightly less efficient then doing foldr ....
13:22:46 <atriq> DanBurton, I mean, the functional classes were "Wow these are a new and weird"
13:22:54 <timthelion> atriq: it would be f# :P
13:22:58 <JoeyA> timthelion: Fusion optimization should take care of that.
13:22:59 <atriq> Would they have happened without Haskell?
13:23:13 <atriq> Would Monads be an obscure category theory term?
13:23:17 <geekagent> timthelion: if you're going to specialize it, use foldl'
13:23:21 <timthelion> JoeyA: I think that's false advertizing.. But I hope it's not.
13:23:21 <JoeyA> But if you're really concerned, you could use foldl' (\a x -> if f x then a+1 else a)
13:23:30 <atriq> Would anyone care about arrow
13:23:31 <atriq> s
13:23:49 <geekagent> atriq: Yes, Monad came from category theory.
13:23:51 <timthelion> geekagent: what is better about foldl'?
13:24:13 <atriq> geekagent, I'm saying, without Haskell would it still be only known to category theorists?
13:24:13 <geekagent> timthelion, for folds with an accumulator, you want foldl'
13:24:15 <c_wraith> I think any "new prelude" effort that ignores what edwardk is currently doing is...  premature
13:24:31 <timthelion> At first, I thought that Monads where reffering to Leibnitzian Monads.  Then, I realized I was terribly mistaken.
13:24:34 <Eduard_Munteanu> And the application of monads in CS / languages predates Haskell.
13:24:44 <atriq> Where does it come from?
13:24:52 <geekagent> atriq: I think moggi's paper wasn't specific to haskell, so it would have likely been pulled in to some other language.
13:24:57 <atriq> Hmm
13:25:00 <Eduard_Munteanu> What geekagent says.
13:25:02 <timthelion> geekagent: oh, I've been acumulating using the normal foldl for a while now.
13:25:09 <mauke> rudyl313: this is pretty amazing
13:25:19 <geekagent> foldl' is strict in the accumulator so you don't get stack overflows.
13:25:22 <DanBurton> geekagent: folds always have an accumulator, they wouldn't be folds otherwise
13:25:22 <mauke> rudyl313: Network.URI is also broken, albeit in a completely different way
13:25:24 * timthelion would like to try haskell from back before the IO monad.
13:25:27 <edwardk> DanBurton: yeah i was going to send you a message to the effect that tardis is just a state and backwards state composed ;)
13:25:37 <edwardk> but i see you already realized it
13:25:49 <edwardk> timthelion: its not fun times
13:26:03 <geekagent> atriq: people don't apply enough category theory. Arrows are a mess because they're a mash of 3 different things that often go together.
13:26:07 <DanBurton> edwardk: indeed; in fact the first time I implemented Tardis I consulted the Monad instances of state and backwards state
13:26:13 <timthelion> edwardk: where you here then, exactly how long ago was it?
13:26:19 <atriq> geekagent, isn't that like the english language?
13:26:20 <edwardk> timthelion: doesn't prevent me from using 'monadologist' as a handle when i play video games ;)
13:26:26 <atriq> How useful is the Tardis monad?
13:26:43 <DanBurton> it's... not for general purpose use ;)
13:26:45 <jfischoff> geekagent: what are the three things?
13:27:10 <DanBurton> I'll be blogging more about the particular uses that it is suited for
13:27:15 <timthelion> When I first, understood leibnitzian monads, I fell into a fit of depression that took me 4 years to recover from. Glad Category theory monads are more optimistic.
13:27:16 <geekagent> jfishchoff: are you familiar with Control.Category?
13:27:16 <edwardk> timthelion: i'm newer than that though i've spent a lot of time going through old haskell language specs and mined through a decade or so of mailing list entries from before i arrived on the scene ;)
13:27:19 <DanBurton> but honestly it's more of a toy than a serious tool
13:27:26 <jfischoff> geekagent: yes
13:27:30 <rosie> what's the link to the site where I can temporarily post code?
13:27:36 <c_wraith> @hpaste
13:27:37 <lambdabot> Haskell pastebin: http://hpaste.org/
13:27:38 <timthelion> edwardk: just looking for the dirt on the long timers eh :)
13:27:44 <Philippa> DanBurton: I haven't RTFM much on it, does it have nice 'high-level' names for various operations as relevant in a tardis-like context?
13:27:47 <rosie> c_wraith: thanks!
13:27:55 <acowley> alternate name for tardis: beg-the-question
13:28:01 <edwardk> timthelion: yeah, the fight on the mailing list over 'fail' in monad was quite enlightening ;)
13:28:10 <edwardk> i was rather shocked at who took each side of the debate
13:28:16 <timthelion> edwardk: I'll have to read it.
13:28:25 <DanBurton> Philippa: indeed. The two primitives from state (get and put) are simply extended to the two state streams, so we have getPast, getFuture, sendPast, and sendFuture
13:28:36 * timthelion googles "fail monad haskell"
13:28:50 <Philippa> suffice to say that while it's cute for do notation, fail is appropriately named?
13:28:55 <hpaste> Rose pasted “print loop” at http://hpaste.org/73197
13:28:59 <timthelion> edwardk: that was on haskellcafe?
13:29:10 <Philippa> edwardk: 'mafraid I am still creeping waaaay behind the SugarHaskell program, btw
13:29:15 <acowley> haskell started the fail meme
13:29:30 <DanBurton> suffice it to say, fail should not be explicitly used. Just leave it to be automatically used by pattern matching magic
13:29:36 <EvanR_> i am very strongly against fail in the monad class, so strong in fact that i make fail throw an error for any instances i define!
13:29:38 <rosie> what's a good way to use sequence to print the array of IO actions?
13:29:42 <rosie> see pasted code
13:29:48 <edwardk> timthelion: i think the mailman server on haskell.org has the original haskell mailing list archives that far back still, let me dig
13:30:03 <DanBurton> EvanR_: lol :)
13:30:19 <avpx> EvanR_: Instead of sequence . map, use mapM
13:30:20 <Philippa> rosie: are you doing homework that insists on using sequence?
13:30:25 <Philippa> (or something homework-like)
13:30:26 <rosie> No
13:30:27 <avpx> Oh wait
13:30:30 <Philippa> mapM is your friend
13:30:33 <rosie> nope, just learning haskell
13:30:36 <Philippa> or mapM_ as appropriate
13:30:37 <monochrom> mapM_ printInsertStmt [1..50]
13:30:39 <rosie> thanks, i'll look it up
13:30:40 <avpx> Sorry for directing that at you, EvanR_
13:30:43 <timthelion> edwardk: I always wonder, about all the idiotic things I say here on IRC.  And when I'm famous and respected, people will go back and they will be "inspired that they can be too"
13:31:10 <Philippa> I guess I always tried to be at least interestingly stupid?
13:31:15 <Philippa> and/or interestingly clueless
13:31:19 <monochrom> and this is not "print the array of IO actions". far from it
13:31:20 <avpx> timthelion: I feel much the same way. IRC logs are like repositories of my mistakes, where I can go back and see how dumb I was at any point in time.
13:31:20 <edwardk> i've left more than enough stupid things out there for any historian who wants dirt on me ;)
13:31:21 <Eduard_Munteanu> Mind the original code was "sequence map ..." which is wrong.
13:31:21 <DanBurton> rosie: mapM is simply defined as mapM f xs = sequence (map f xs), so you had the right idea
13:31:37 <edwardk> timthelion: not sure where the original haskell mailing list archives went
13:31:43 <Philippa> edwardk: eh, I'm sure it's all harmless
13:32:24 <timthelion> edwardk: respectability died with the internet. The fact that some politicians DON'T have dirt on them, just confirms the theory, that they are space aliens.)
13:32:33 <edwardk> Philippa: =)
13:32:49 <timthelion> Or lying about their names.
13:32:59 <Philippa> mmm. The rule these days is: own your shit before it owns you
13:33:16 <geekagent> jfischoff: The arrow typeclass says with arr that there's a functor from Hask to the new category
13:33:23 <edwardk> Philippa: heh at least all the articles i wrote when i was young were written under pseudonyms, muahahaha
13:33:27 <geekagent> with *** that (,) is a monoid in the new category
13:33:29 <Philippa> hell, give it 20-30 years and it might be acceptable for a politician to've ever changed their position on something
13:33:41 <geekagent> and with &&& that (,) is the product in the new category.
13:33:51 <geekagent> &&& implies *** but not the other way round.
13:34:33 <JoeyA> Is there a utility Exception instance where show = id ?
13:34:39 <DanBurton> edwardk: do you know of any reverse state monad transformer implementations already on hackage?
13:34:48 <edwardk> Philippa: based on how well romney is still doing its okay to change it every couple of weeks ;)
13:34:59 <edwardk> DanBurton: i've seen one, but i can't remember where =/
13:35:11 <Philippa> edwardk: "he may be a bastard, but he's our bastard"
13:35:17 <DanBurton> I have seen it in a couple blog posts, but couldn't track down anything on hackage
13:35:25 <DanBurton> oh well I'll just release mine
13:35:30 <Eduard_Munteanu> Reverse state monad transformer?
13:35:52 <avpx> Eduard_Munteanu: It's a common programming idiom
13:35:55 <DanBurton> Eduard_Munteanu: indeed. It's like the state monad transformer, but the state travels the opposite way
13:36:05 <edwardk> heh, attempting to search for backwards and state on hackage just finds a ton of references to Control.Lens.Traversal. sorry ;)
13:36:10 <DanBurton> avpx: for some value of "common"...
13:36:23 <Eduard_Munteanu> Mm, how come? What's the functor?
13:36:24 <atriq> So, we now have a monad that can violate causality. Are we trying to scare away newbies?
13:36:36 <EvanR_> lol
13:36:38 <avpx> Can the monad go back and kill its own grandparents?
13:36:40 <Philippa> atriq: more like, we have a monad that admits it can
13:36:40 <c_wraith> Eh.  any actual paradoxes result in infinite loops
13:36:42 <edwardk> Eduard_Munteanu: when you write the definition for State/StateT you can choose to thread the state 's' backwards
13:36:43 <monochrom> it pretends to violate casuality
13:36:52 <Jurily> we also have a monad for quantum computations. I'm not surprised at anything anymore
13:36:53 <Eduard_Munteanu> Oh.
13:36:57 <EvanR_> 'actual paradox' is a contradiction
13:36:59 <edwardk> Eduard_Munteanu: it gives you a way to send messages back to yourself 'from the future'
13:37:01 <avpx> Jurily: That's neat.
13:37:12 <DanBurton> you can see the Monad and Functor instances here: https://github.com/DanBurton/rev-state/blob/master/Control/Monad/Trans/RevState.hs
13:37:15 <edwardk> or to accidentally bottom out
13:37:26 <EvanR_> class MonadComeFrom
13:37:26 <edwardk> paradoxes resolve to _|_
13:37:45 <Eduard_Munteanu> I see.
13:37:49 <DanBurton> that is what I find fascinating
13:37:56 <avpx> edwardk: Could that mean that paradoxes cause nontermination?
13:37:59 <timthelion> Jurily: the funny thing, is Tardus is actually useful, for reversing tree making code(though I still don't grok it)
13:38:02 <edwardk> avpx: yep
13:38:04 <avpx> Oh, oaky.
13:38:31 <Jurily> I bet there's a monad to describe something that was about to happen to you in the past before you avoided it by time-jumping forward two days in order to avoid it.
13:39:11 <Enigmagic> Jurily: it's the BackToTheFutureMonad
13:39:29 <DanBurton> alas, the Tardis package isn't quite that good. It's really quite amusing to think about time paradoxes and such in terms of Haskell, though.
13:40:06 <JoeyA> @hackage acme-realworld
13:40:07 <avpx> Just wait. In a couple of years someone in here will discover actual time travel, and when prompted to explain how it works, will simply say "The machine is just a monad instance. It was really quite easy."
13:40:07 <lambdabot> http://hackage.haskell.org/package/acme-realworld
13:40:09 <avocado> is there a way i can make Network.Curl.curlGetString to only return me the first 2KB of a file? i can't find an option in Network.Curl.Opts that seems to say that. CurlMaxFileSize just gives CurlFilesizeExceeded.
13:40:11 <DanBurton> Tardis only works in the presence of sufficient laziness, which is comparable to the various lores regarding what you should and should not do during time travel
13:40:16 <timthelion> It's sad to me, that we spend so much time, doing trivial monad games, playing with purity. And then we live in the dung heep that is every GUI library ever written for haskell.
13:40:30 <timthelion> IORefs, weird type class casts..
13:40:35 <avpx> timthelion: Many attempts have been made to fix this.
13:40:51 <avpx> See: functional reactive stuff
13:41:12 <timthelion> avpx: I didn't understand the FRP stuff :(
13:41:22 <avpx> And you have reached the heart of the issue
13:41:34 <DanBurton> timthelion: I don't see that as "sad" at all. Everyone is going to spend time doing whatever they wish; it's a fallacy to think that if we didn't spend time doing thing X, then all of that time would instead be spent doing thing Y
13:41:54 <Jurily> is there an editor that parses Haskell and doesn't call out to ghci on every freaking keystroke?
13:42:15 <avpx> DanBurton: I think he's just saying that we have a lot of great theory going into Haskell, but there are still some (important) parts that just seem glued on.
13:42:15 <timthelion> DanBurton: True.  I just see this, in the context of my OWN life.  Being perfect in a few details, and having a really really messy house in the grand scheme of things.
13:42:19 <parcs`> avpx: by the way, i was wrong when i said that there's no way to turn an untyped syntax tree into a typed one. see http://augustss.blogspot.com/2009/06/more-llvm-recently-someone-asked-me-on.html
13:42:21 <rosie> I'm surprised that putStr "dog " ++ (show 7) doesn't work. What does?
13:42:22 <DanBurton> Jurily: "parses Haskell" meaning... syntax highlighting? error highlighting?
13:42:28 <rosie> and why doesn't it
13:42:29 <rosie> ?
13:42:43 <Eduard_Munteanu> rosie: you're missing some parens
13:42:52 <edwardk> DanBurton: time travel only working in the presence of sufficient laziness makes me think of Dirk Gently for some reason.
13:42:53 <rosie> ah thanks
13:42:56 <timthelion> rosie: add a $ after putStr
13:42:59 <avpx> parcs`: Oh, neat. Thanks for following up on that.
13:43:00 <Eduard_Munteanu> > putStr ("dog " ++ (show 7))
13:43:03 <lambdabot>   <IO ()>
13:43:12 <Jurily> DanBurton: on-hover type information maybe?
13:43:57 <Jurily> I'm spoiled by KDevelop's responsiveness
13:44:03 <avpx> Speaking of Douglas Adams, is there an Infinite Improbability Monad?
13:44:13 * timthelion thinks that they should have made $ as | and made it "face" the other way, so that we could just use it like pipes in unix...
13:44:33 <Jurily> timthelion: lens does something similar
13:44:56 <timthelion> Jurily: KDE is the most amazing environment ever...  If I wasn't a total whore for the keyboard(xmonad) I'd love it.
13:45:05 <S11001001> avpx: no, infinite improbability violates associativity laws
13:45:17 <EvanR_> the fanboi is strong with you padawan
13:45:46 <Jurily> timthelion: give the win key to xmonad
13:45:51 <avpx> S11001001: Really? The composition of infinitely improbable actions seems associative to me.
13:46:26 <timthelion> Jurily: I've tried that in the past. Found that I randomly had panels jumping out at me(probably an xmonad bug)
13:46:33 <Philippa> DanBurton, rosie: or equivalent, parens around everything after it
13:46:42 <Philippa> ...
13:46:46 <rosie> yep, thanks
13:46:46 <S11001001> avpx: would that the events were occurring in sequence
13:46:48 <Philippa> not DanBurton, sorry, timthelion
13:48:02 <rudyl313> mauke: Looks like using Codec.Binary.UTF8.String.encode with Codec.Binary.Url.encode is my best bet
13:50:14 <Soultaker> is there a standard function like 'comparing' but for equality functions, like those passed to nubBy?
13:50:28 <hpc> :t nubBy
13:50:30 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
13:50:32 <hpc> :t comparing
13:50:35 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:50:52 <hpc> perhaps you want...
13:51:00 <hpc> :t \f -> (==) `on` f
13:51:02 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
13:51:28 <Soultaker> how do I tell the bot to give me the source code for 'on'?
13:51:32 <hpc> @src on
13:51:33 <lambdabot> (*) `on` f = \x y -> f x * f y
13:52:04 <Soultaker> :t on
13:52:06 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:52:15 <Soultaker> I don't think that's it.
13:52:27 <Soultaker> what I mean is, if I want to sort a list by a custom criterion, I can do:
13:52:30 <Eduard_Munteanu> Soultaker: what type did you expect?
13:52:32 <Soultaker> sortBy (comparing snd) [(1,3),(2,1),(3,4)]
13:52:35 <jfischoff> @src comparing
13:52:35 <lambdabot> Source not found. I am sorry.
13:52:41 <Soultaker> I want to do something like:
13:52:52 <slack1256> @src Comparing
13:52:53 <lambdabot> Source not found.
13:52:55 <Soultaker> nubBy (xyzzy snd) [(1,3),(2,1),(3,4),(5,4)]
13:53:00 <Soultaker> (which would then throw out the last item)
13:53:10 <DanBurton> slack1256: comparing = on compare
13:53:18 <Eduard_Munteanu> :t (==) `on` snd
13:53:20 <lambdabot> forall a b. (Eq b) => (a, b) -> (a, b) -> Bool
13:54:21 <DanBurton> > let equating = on (==) in nubBy (equating snd) [(1,3),(2,1),(3,4),(5,4)]
13:54:23 <lambdabot>   [(1,3),(2,1),(3,4)]
13:54:27 <mekeor> is there a Parsec parser for haskell code? (i'd like to take a look at its source code.)
13:54:33 <hpc> > ((==) `on` snd) (5, 'a') (10000000, 'a')
13:54:34 <lambdabot>   True
13:54:35 <Soultaker> oh hmm.aha, looks like that works
13:54:47 <Soultaker> where is `on' defined?
13:54:52 <mekeor> Data.Functionm
13:54:53 <DanBurton> shamless plug, the next version of basic-prelude includes equating :)
13:55:08 * mekeor likes on.
13:55:12 <slack1256> DanBurton: I thought lambdabot would show the class declaration of Ord. I don't why I thought that.
13:55:24 <hpc> mekeor: the GHC library would have an implementation :P
13:55:31 <mekeor> hpc: :D
13:55:45 <mekeor> hpc: does it use parsec??? O_O
13:56:16 <hpc> no
13:56:23 <Eduard_Munteanu> Indeed, a nub that used Ord would be nice.
13:56:24 <mekeor> okay :)
13:56:45 <mekeor> Eduard_Munteanu: hm? there's nubBy... or what doo you mean?
13:56:54 <Eduard_Munteanu> :t nubBy
13:56:56 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
13:57:08 <mekeor> ah, instead of Bool?
13:57:17 <Eduard_Munteanu> mekeor: one that wasn't O(n^2)
13:57:23 <hpc> Eduard_Munteanu: wait for edwardk to be in-channel and he'll come up with something for sure ;)
13:57:26 <slack1256> why some declarations use 'forall a. a -> a' instead of 'a -> a'
13:57:44 <edwardk> ?
13:57:45 <DanBurton> lambdabot likes to say "forall"
13:57:55 <DanBurton> even though in "regular haskell" you usually don't typeit out
13:58:15 <Eduard_Munteanu> :t nub
13:58:16 <slack1256> mmm in existential declaration seems mandatory.
13:58:17 <lambdabot> forall a. (Eq a) => [a] -> [a]
13:58:26 <Eduard_Munteanu> mekeor: replace Eq by Ord there
13:58:33 <mekeor> ah
13:58:37 <edwardk> Eduard_Munteanu: nub by adding it into a Set as you go and its easy enough
13:58:37 <Eduard_Munteanu> There's a more efficient way to do it then.
13:58:45 <mekeor> ah ok cool :)
13:58:50 <Eduard_Munteanu> edwardk: yeah sure, I mean it should be in the stdlib
13:58:59 <edwardk> the stdlib doesn't have sets ;)
13:59:12 <DanBurton> oh is this about the speed of ord?
13:59:16 <DanBurton> *nub
13:59:21 <Eduard_Munteanu> Yeah.
13:59:25 <hpc> slack1256: it's a ghc flag
13:59:42 <DanBurton> if you want a collection of unique elements, why not just use Set.toList?
13:59:48 <DanBurton> *fromList
13:59:49 <ocharles> .fromList*
13:59:50 <ocharles> :)
13:59:58 <DanBurton> man I'm missing the mark today
14:00:19 <Eduard_Munteanu> @hoogle fromList
14:00:20 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
14:00:20 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
14:00:20 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
14:00:22 <Soultaker> in my case I want control over which elements are kept
14:00:29 <Eduard_Munteanu> @hoogle+
14:00:30 <lambdabot> Data.Sequence fromList :: [a] -> Seq a
14:00:30 <lambdabot> Data.Set fromList :: Ord a => [a] -> Set a
14:00:30 <lambdabot> Data.Map fromList :: Ord k => [(k, a)] -> Map k a
14:00:45 <Eduard_Munteanu> Right, Ord is there.
14:00:51 <hpc> slack1256: can't seem to find it atm though
14:00:51 <Soultaker> or actually, I want to keep pairs with unique 'first' field and minimum 'second' field
14:01:00 <Soultaker> so I thought I'd sortBy and then nub
14:01:04 <DanBurton> oh on the topic of fromList, does it bother anyone else that Map.fromList doesn't keep the same lookup behavior?
14:01:05 <ion> Hoogle+, the competitor to Hacebook nobody uses.
14:01:13 <Soultaker> or is there a smarter way to do this?
14:01:33 <hpc> oh
14:01:35 <hpc> -fprint-explicit-foralls
14:01:58 <DanBurton> > let xs = [(1,"foo"), (1,"bar")] in (lookup 1 xs, Map.lookup 1 (Map.fromList xs))
14:01:59 <lambdabot>   Not in scope: `Map.lookup'Not in scope: `Map.fromList'
14:02:08 <DanBurton> :( what does lambdabot call Map
14:02:09 <Philippa> ion: be fair. We'd call it Facehook
14:02:16 <ion> M, i think.
14:02:24 <DanBurton> > let xs = [(1,"foo"), (1,"bar")] in (lookup 1 xs, M.lookup 1 (M.fromList xs))
14:02:25 <lambdabot>   (Just "foo",Just "bar")
14:02:55 <DanBurton> it seems counterintuitive to say that you can turn an assoc list into a map, when the map won't behave the same
14:03:16 <slack1256> hpc: yes explicit-foralls.
14:03:22 <quicksilver> it's an interesting point DanBurton
14:03:34 <ocharles> DanBurton: maps don't have any ordering, so I'd say that lookup should be undefined
14:03:44 <hpc> annoyingly, that flag isn't on the manpage, so it didn't show up in my tab completion
14:03:46 <ocharles> i don't think you should expect a specific element back
14:03:49 <quicksilver> ocharles: no, both are perfectly defined.
14:03:54 <quicksilver> fromList folds an insert
14:04:03 <quicksilver> so later entries replace earlier ones with the same key.
14:04:07 <ocharles> hm
14:04:12 <ocharles> i suppose when you define it like that
14:04:17 <quicksilver> while the List 'lookup' returns the first hit it finds
14:04:33 <ocharles> but I think of fromList as 'given this thing, make a map' and I don't care about how it does it
14:04:34 <quicksilver> anything else would just be a 'waste of time' and inparticular would stop it working with infinite lists.
14:04:34 <monochrom> fix your intuition
14:04:46 <ocharles> in fact, it should do it in whatever is the most efficient way for it
14:04:48 <quicksilver> but I do see that the inconsistency is mildly jarring
14:04:50 <DanBurton> monochrom: I'd rather fix the rest of the universe >.>
14:05:20 <monochrom> well, me too. that is why you fix your intuition. you're in my universe.
14:05:21 <hpc> hmm
14:05:30 <hpc> does haskell have a mutable map implementation?
14:05:35 <DanBurton> monochrom: or are you in mine? o_O!
14:05:43 <hpc> (preferably more sophisticated than IORef (Map k v)
14:05:45 <hpc> )
14:05:49 <Philippa> there's the old hashtable module?
14:06:14 <DanBurton> a mutable map, what for? when immutable ones can be shared so nicely
14:06:27 <n00b6502> is it erlang where there's an immutable datastructure that can represent a 'undo-able' mutable structure ..i'd imagine haskell can do that too?
14:06:53 <quicksilver> is there a mutable hashmap in unordered-containers?
14:06:56 <DanBurton> @faq can Haskell do that, lambdabot?
14:06:56 <lambdabot> The answer is: Yes! Haskell can do that.
14:07:09 <hpc> n00b6502: haskell has that kind of thing for ordinary arrays, but it's rather odd
14:07:19 <Jurily> state monad :)
14:07:32 <hpc> it's mutable under the hood, but keeps a history kind of thing, so old references get old data
14:07:40 <hpc> forget what it's called
14:07:42 <n00b6502> i heard of that specifically from a 3d modeller that uses it for 'undo' :)
14:07:56 <mekeor> well, isn't Writer like that, too?
14:08:07 <mauke> yeah, that sort of thing is called persistent data structures
14:08:09 <avpx> mekeor: Yeah, I was just going to say
14:08:11 <mekeor> i mean, you can save the old values in the writer monad... no?
14:08:40 <mekeor> Writer a [a] or something...
14:09:12 <quicksilver> hpc: DiffArray
14:09:15 <quicksilver> it doesn't work very well.
14:09:20 <n00b6502> can haskell have separete IO style monads e.g. fileIO , networkIO, graphicsIO that sort of thing ... or is the asumption all underlying OS will be 'IO'
14:09:20 <quicksilver> in performance terms, I mean.
14:09:38 <hpc> n00b6502: you can write those wrappers over IO
14:09:41 <quicksilver> n00b6502: you can definitely imagine that - it's a very sensible idea - but it's not how the standard library is implemented.
14:09:47 <hpc> and many libraries do that
14:09:51 <quicksilver> you could isolate it all yourself and export a restricted api like that.
14:09:54 <n00b6502> sounds very neat
14:09:57 <Eduard_Munteanu> quicksilver: arguably it could be better, no?
14:10:04 <quicksilver> Eduard_Munteanu: it would be better in some ways, yes.
14:10:15 <hpc> one notable example is cairo's Render monad
14:10:20 <quicksilver> it's not obvious the best way to make it compositional.
14:10:25 <hpc> (except i think that one is MonadIO, so doesn't count)
14:10:33 <Eduard_Munteanu> It's just the synchronization primitives used are slow as hell.
14:10:53 <n00b6502> guiIO and fileIO/netIO perhaps for most apps
14:11:00 <quicksilver> one approach to making it compositional is to use classes as capabilities, like  "GraphicsIO m, FileIO m => m ()"
14:11:08 <quicksilver> but there are annoyances with that too.
14:11:17 <hpc> ambiguous types, etc
14:11:34 <n00b6502> there might be cases where a GUI toolkit can use file resources
14:11:38 <avpx> Overlapping instances
14:11:44 <n00b6502> so guiIO just ends up being everything anyway
14:12:18 <avpx> I saw a blog post recently where someone created a monad just to do putStr / getContents or something
14:12:26 <avpx> I can't remember what it was though.
14:13:11 <jfischoff> avpx: probably Haskell for All's Free Monad post
14:13:28 <avpx> jfischoff: I think that was it. Thanks.
14:15:05 <n00b6502> do 'monad transformers' relate to that
14:15:34 <ion> Haskell for All, huh? Why did i not see this site before?
14:15:47 <ion> I want my money back.
14:15:54 <avpx> ion: You get a Haskell! And you get a Haskell!
14:16:33 <avpx> n00b6502: Monad transformers are a way we can compose monadic features
14:16:33 <yitz> n00b6502: yes, monad transformers can be used as a way to stack up various capabilities from multiple monads into a single monad
14:17:54 <mekeor> should i use Text.ParserCombinators.Parsec or Text.Parsec?
14:18:00 <hpc> latter
14:18:03 <luite> Text.Parsec is the new one
14:18:04 <mekeor> ok
14:18:08 <mekeor> ok
14:18:09 <mekeor> thanks
14:18:11 <luite> parsec3
14:19:49 <n00b6502> in C the idea would be to pass around an IO object and that might have conversion operators to return fileIO, pd3dDevice or whatever ... but not everyone likes that..
14:19:51 <n00b6502> c++
14:20:58 * mekeor gets some orange juice
14:25:52 <otters> Why would you ever need implicit parameters?
14:26:26 <Jurily> to anger the gods?
14:27:03 <otters> okay, that's one explanation
14:29:51 <mekeor> i only can think of cases where they are practical with dependent types, especially when the implicit parameter of a function is a parameter of the type of another argument or so... then, you don't always want to name that parameter.
14:30:10 <xnyhps> Situations where you'd like to use a class, but might need different instances for the same type
14:31:01 <otters> Does ghci allow "default"?
14:31:04 <otters> it doesn't appear to
14:31:11 <mekeor> (my description was unprecise)
14:31:37 <mekeor> otters: i think the new ghcis can do that... dunno exactly
14:31:44 <mekeor> otters: which ghc version?
14:33:47 <otters> 7.4.1
14:34:18 <zhulikas> :t (show . read)
14:34:20 <lambdabot> String -> String
14:34:26 <zhulikas> anyone knows how to solve this?
14:34:37 <zhulikas> > (show . read) "12"
14:34:39 <lambdabot>   "*Exception: Prelude.read: no parse
14:34:45 <Clint> specify a type
14:34:57 <zhulikas> I don't want to.
14:34:59 <johnw> where is the current parsec 3 manual?
14:35:04 <ion> > (show . read) "()"
14:35:06 <johnw> the link from the HaskellWiki is to the parsec 2 manual
14:35:06 <lambdabot>   "()"
14:35:19 <ion> zhulikas: Enjoy the error then.
14:35:24 <zhulikas> so that's a default type
14:35:48 <Clint> there's like some chaotic mailing list post which half-explains parsec3 somewhere
14:35:51 <zhulikas> so how should I make such a pipe which would support any type? or at least some type class?
14:35:51 <mekeor> johnw: i don't know of an other manual than that on their homepage
14:36:05 <mauke> zhulikas: how would that even work?
14:36:06 <mekeor> johnw: http://legacy.cs.uu.nl/daan/parsec.html
14:36:15 <mauke> zhulikas: magic?
14:36:18 <mekeor> johnw: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
14:36:27 <zhulikas> mauke, isn't it the main point behind Haskell? magic
14:36:27 <johnw> yeah, that's the page I'm looking at
14:36:32 <mauke> zhulikas: no, that's math
14:36:36 <zhulikas> oh.
14:36:40 <mekeor> johnw: yeah, it's pretty out-dated
14:36:43 * zhulikas mixed the M words
14:36:44 <ion> Mathemagic
14:36:52 <zhulikas> mathemagics
14:36:57 <mekeor> johnw: "4 Oct 2001" :D
14:36:58 <mekeor> omg
14:37:23 <otters> maybe existential types?
14:37:27 <mekeor> johnw: but please let me know if you find a newer documentation
14:37:35 <otters> wait, no
14:38:11 <mekeor> rules for existential types: (1) if you think you need them, you don't need them.
14:38:26 <otters> you're absolutely right, I'm talking nonsense
14:38:35 * armlesshobo waves
14:38:39 <avpx> 2) Forall existential types. you do NOT talk about existential types.
14:38:45 <zhulikas> armlesshobo, with what?
14:38:47 <johnw> mekeor: this is useful: https://gist.github.com/89786
14:38:47 <mekeor> :D
14:38:59 <ion> I had a problem, so i thought “i’ll solve this with existential types!” Now i have two problems.
14:39:20 <otters> now I have one problem, but I can't deconstruct it into a useful value.
14:39:30 <avpx> Exactly.
14:39:31 <mekeor> johnw: well, the out-dated but official manual is better than that
14:40:28 * mekeor hugs armlesshobo but armlesshobo can't hug him as he doesn't have arms :/
14:41:25 * armlesshobo cries
14:41:42 * armlesshobo sulks away
14:42:01 <statusfailed> haha, whoops :P
14:42:04 <statusfailed> Hello, armlesshobo
14:44:03 <mixer> "!lista"
14:44:27 <armlesshobo> so, foldr is the same as foldl, except that it starts from the right, right?
14:44:34 <mauke> armlesshobo: not really
14:44:35 <avpx> armlesshobo: Well, not quite
14:44:43 <avpx> armlesshobo: It's better to think of it in terms of associativity.
14:45:07 <pqmodn> fold right: a + (a + (a + (a + ...))). fold left: (((a + a) + a) + a) + a
14:45:36 <mekeor> > foldr (\x y -> concat ["(",x,"+",y,")"]) "0" (map show [1..13])
14:45:37 <lambdabot>   "(1+(2+(3+(4+(5+(6+(7+(8+(9+(10+(11+(12+(13+0)))))))))))))"
14:45:44 <mekeor> > foldl (\x y -> concat ["(",x,"+",y,")"]) "0" (map show [1..13])
14:45:46 <lambdabot>   "(((((((((((((0+1)+2)+3)+4)+5)+6)+7)+8)+9)+10)+11)+12)+13)"
14:45:49 <timthelion> > let (processedToks,cond) = g n ; g x = (x:[],True) ; n = if cond then 'a' else 'b' in list -- THIS is what makes time traveling lazyness great!!!
14:45:51 <lambdabot>   Not in scope: `list'
14:46:07 <mauke> > foldr f z [a, b, c, d]
14:46:08 <lambdabot>   f a (f b (f c (f d z)))
14:46:11 <mauke> > foldl f z [a, b, c, d]
14:46:11 <timthelion> > let (processedToks,cond) = g n ; g x = (x:[],True) ; n = if cond then 'a' else 'b' in processedToks -- THIS is what makes time traveling lazyness great!!!
14:46:13 <lambdabot>   f (f (f (f z a) b) c) d
14:46:13 <lambdabot>   can't find file: L.hs
14:46:14 <mekeor> oh, cool :D
14:46:23 <monochrom> it is not clear what is "start"
14:47:08 <avpx> mekeor: That was a cool fold to explain folding and I am impressed.
14:47:30 <mekeor> avpx: it's from wikipedia ;) :P :) :D
14:47:32 * roconnor thinks of foldr as a catamorphism and foldl as an accumulating consumer.
14:47:38 <mekeor> avpx: http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
14:47:50 <timthelion> So I have a parser, that needs to change it's output based on something that happens later in the file.  Normally, you would HAVE to do double pass parsing.  But since haskell is lazy.  I can simply be too lazy to "fully parse" the bits that are waiting on info that comes later on :)
14:47:58 <Soultaker> raichoo: that will surely make sense to fp newbies that don't know the difference between foldl and foldr
14:48:00 <avpx> mekeor: Nevermind. I am no longer impressed :p
14:48:02 <EvanR_> haskell makes everything easy except adding numbers which it makes incomprehensible ;)
14:48:06 <Soultaker> *roconnor, I meant.
14:48:17 <timthelion> EvanR_: adding numbers?
14:48:27 <timthelion> EvanR_: like you mean all the funky casting?
14:48:29 <mekeor> avpx: well, you're impressed but not by me. :)
14:48:29 <avpx> Oh, you mean Monoids?
14:48:29 <EvanR_> foldl' and such
14:48:35 <EvanR_> timthelion: ... casting?
14:48:58 <timthelion> EvanR_: Tried doing arithmatic on 3 Reals, a couple of Floats and a Double in haskell?
14:49:03 <EvanR_> sucks that cast has come to mean convert and not 'delete type checking'
14:49:22 <johnw> wow, reading the Wikipedia page on catamorphism does almost nothing to explain to me what catamorphism means
14:49:43 <Soultaker> EvanR_: why? Seems like the former is more consistent with the non-programming meaning.
14:49:45 <mekeor> :D
14:49:50 <timthelion> johnw: wikipedia is a big weak in some areas. Ehem, lingustics and mathematics.
14:50:02 <EvanR_> Soultaker: the non programming meaning of cast? you mean throwing something?
14:50:06 <Reaga> hey
14:50:06 <johnw> i mean, if you already know I'm sure the page makes sense
14:50:16 <timthelion> EvanR_: no, pouring it into a mold
14:50:21 <roconnor> Soultaker: maybe ... but I think that thinking of foldr and foldl as holding a symetric relation to one an other held me back for years.
14:50:21 <Reaga> Guys
14:50:22 <Soultaker> EvanR_: no, I mean forcing a material into a new shape
14:50:27 <Soultaker> as in cast-iron and such.
14:50:42 <EvanR_> well, i feel that the original meaning in C was about throwing away the type safety
14:50:54 <EvanR_> casting wasnt about conversions back then
14:50:59 <hpc> johnw: very casually, catamorphisms are "from big to small" transformations
14:50:59 <ion> There’s type safety in C? ;-)
14:51:03 <roconnor> Soultaker: perhaps using the term catamorphism is a bit too scary.
14:51:04 <MostAwesomeDude> Casting is about reinterpretation of memory.
14:51:05 <EvanR_> some
14:51:09 <johnw> hpc: see, now that helps
14:51:18 <hpc> johnw: the bananas/lenses/envelopes paper covers it well
14:51:20 <Soultaker> ah, I never interpreted 'cast' in the sense of 'throwing'
14:51:27 <EvanR_> MostAwesomeDude: except in c++, php, java
14:51:27 <Reaga> what are haskells biggest flaws
14:51:28 <johnw> so cata means "reducing" and morphism means "the shape of the thing"?
14:51:33 <EvanR_> well sometimes in c++
14:51:34 <hpc> Reaga: too much perfection
14:51:38 <roconnor> Reaga: lack of dependent types
14:51:42 <MostAwesomeDude> EvanR_: C++ and PHP aren't real languages. :3
14:51:43 <hpc> ;)
14:51:47 <avpx> Reaga: Use of static typing
14:51:59 <EvanR_> static typing is good
14:52:00 <roconnor> avpx: *LOL*
14:52:01 * avpx kids
14:52:03 <johnw> MostAwesomeDude: what do you mean by "real language"?
14:52:04 <kanedank`> this is an example of currying/pointer-free functions, right?: https://gist.github.com/3353352 (from ch. 5 in rwh)
14:52:09 <timthelion> Reaga: unsafeLaunchMissiles
14:52:09 <MostAwesomeDude> Reaga: Oh, are we doing this again?
14:52:19 <avpx> MostAwesomeDude: I know, right?
14:52:27 <EvanR_> johnw: language of the form x + jy where y is zero
14:52:31 <avpx> Reaga: Why do you always ask such weird questions of us?
14:52:37 <Reaga> MostAwesomeDude: im interviewing haskell
14:52:39 <MostAwesomeDude> johnw: I like to discourage PHP whenever possible since it causes brain damage.
14:52:52 <avpx> Why don't you just write some programs in Haskell and see if you like it?
14:52:53 <timthelion> Reaga: we don't want a job.
14:52:55 <Reaga> i have conciously avoided learning PHP because im scared it will make me stupider
14:52:56 <timthelion> Reaga: we're hippies.
14:52:59 <MostAwesomeDude> Reaga: Okay. I would say that Haskell drinks too much at home.
14:53:37 <hpc> haskell hates his first name
14:53:48 <Enigmagic> MostAwesomeDude: daddy drinks because you cry.
14:53:57 <Botje> kanedank`: that's a partially applied function, yes.
14:53:58 <Reaga> hum...
14:54:13 <Reaga> the only thing i need to know is if haskell is turing complete and it is
14:54:14 <avpx> Haskell lures you in under the pretense that it is a cult based around Simon Peyton Jones, when it is in fact a cult based around Saunders Mac Lane.
14:54:22 <hpc> hah
14:54:35 <Reaga> im just still trying to figure out why haskell isnt more popular
14:54:37 <Botje> kanedank`: and you can implement it that way because haskell curries functions by default, so foldr ... returns a function by default
14:54:39 <Reaga> it seems to be flawless
14:55:00 <Philippa> hah. There're plenty of flaws, as anyone who's spent enough time with it knows
14:55:02 <hpc> Reaga: have you written any haskell code?
14:55:02 <Jurily> because cabal
14:55:08 <Reaga> hpc: no
14:55:16 <EvanR_> Reaga: thats why, popular stuff is logically equivalent to sucking ;)
14:55:16 <hpc> well you are why it isn't more popular, then
14:55:17 <avpx> Reaga: Yeah, it has its warts like any other language.
14:55:19 <Enigmagic> Jurily: not using cabal has made my life 300% better
14:55:20 <hpc> write some code!
14:55:31 <Reaga> im still learning java at the moment but im getting sick of it
14:55:37 <Philippa> EvanR_: popularity is a result of believing Worse Is Better?
14:55:39 <Reaga> its so impure
14:55:46 <avpx> Reaga: It doesn't strive for "purity"
14:55:53 <Reaga> its so hacky
14:55:58 <avpx> Java isn't really hacky
14:56:03 <EvanR_> Philippa: no its  aresult of worse being better
14:56:06 <Reaga> you just bash things together and it kinda works but barely
14:56:06 * Philippa remembers when purity was an advertised property of Java. Pure OO, that is
14:56:40 <avpx> Reaga: I don't get it. Why don't you just write some code in Haskell?
14:56:46 <Reaga> I will
14:56:49 <avpx> Then do.
14:56:54 <Reaga> I will do.
14:57:10 <MostAwesomeDude> Reaga: Popularity is caused by inertia. Have you *seen* how much Fortran and COBOL are still around?
14:57:22 <kanedank`> is there an alternative to cabal or a really good tutorial on it?
14:57:31 <otters> no; not really
14:57:42 <otters> you mean installing stuff with cabal, or making packages?
14:57:50 <kanedank`> making packages
14:57:59 <kanedank`> or both
14:58:00 <Dodek> MostAwesomeDude: i have seen how much fortran is around. fortran 95 and newer are quite good, though.
14:58:01 <Philippa> big flaws in Haskell: lack of dependent types, the consequences of being the first FPL language to really take constraints/qualified types seriously, no proper MLish module system that doesn't require more syntactic cruft than I'm willing to put up with...
14:58:30 <otters> my philosophy is, if I don't understand something, I can't possibly have a use for it
14:58:42 <parcs`> how is "lack of dependent types" a flaw?
14:58:43 <johnw> otters: lol
14:58:43 <Reaga> otters that philoosphy is greatly limiting you
14:58:45 <hpc> having used agda's module system, i don't think haskell's is that bad
14:58:52 <otters> Reaga: just a little humor
14:58:55 <johnw> otters: imagine if humanity as a whole had that philosophy
14:58:57 <Reaga> :)
14:59:03 <otters> johnw: not serious
14:59:11 <johnw> otters: yeah, I figured no thinking person could be
14:59:16 <hpaste> gertc pasted “db tutorial” at http://hpaste.org/73198
14:59:20 <hpc> it just needs some work on re-exporting
14:59:25 <Nafai> Philippa: anything you could point me to that describes the advantages of MLs module system?
14:59:28 <otters> although, corollary 1: learned what existential types are, how they work, no use for them
14:59:30 <Jurily> qualified exports!
14:59:32 <Reaga> what is the module system
14:59:36 <Reaga> what is a module system
14:59:38 <otters> I've done some non trivial stuff in haskell
15:00:08 <otters> I don't see what's wrong with Haskell's module system
15:00:20 <statusfailed> Yeah, it seems quite nice to me...
15:00:30 <gertc> i am looking for a tutorial how to make this into a index of userids
15:00:39 <Philippa> Nafai: eh, there's a chapter in ATTaPL that describes how they work pretty well? If you grok the system you'll see the advantages pretty quickly
15:00:41 <otters> Like, you can name modules and treat them as
15:00:46 <otters> I guess "objects" would be the right word
15:00:49 <kanedank`> what is it called when a function is in parentheses like "a = fold (b)"
15:00:57 <otters> and the module name reflects the filepath, which I really like
15:00:57 <roconnor> otters: its hard to make functors and mixin functors over extentions.
15:01:05 <roconnor> otters: Module functors I mean
15:01:14 <otters> module functors?
15:01:15 <EvanR_> kanedank`: nothing
15:01:18 <ion> kanedank: It’s called being in parentheses, i believe.
15:01:23 <EvanR_> kanedank`: fold (b) is the same as fold b
15:01:32 <otters> you mean define functors in a module, or are "module functors" something I haven't heard of?
15:01:38 <monochrom> what is the actual thing you wrote "b" for?
15:01:43 <avpx> I'm thinking he means a module viewed as a functor
15:01:50 <kanedank`> EvanR_: what? but why do I keep seeing (++) in rwh?
15:01:57 <otters> how could you view a module as a functor
15:01:57 <roconnor> otters: a module functor is assignment of expressions in one module signature in the context of another module signature.
15:01:58 <statusfailed> kanedank`: because it's an operator
15:02:00 <otters> what would mapping over it do?
15:02:13 <avpx> otters: A functor in Haskell is not really identical to a functor in category theory
15:02:14 <gertc> like in [("1","hello"),("2","hello2")]
15:02:31 <otters> well, I only know the Haskell functor, not the category theory functor
15:02:39 <statusfailed> kanedank`: () around an operator makes it callable like a normal function rather than between the arguments
15:02:45 <Azel> Parenthesis are the mean to use an operator as a normal (binary) function
15:02:46 <avpx> otters: Do you know what a homomorphism is, in algebra?
15:02:50 <statusfailed> > (++) "Hello, " "World"
15:02:50 <otters> avpx: no
15:02:52 <lambdabot>   "Hello, World"
15:02:58 <roconnor> I'm not entirely sure that a module functor is at all related to functors in category theory.
15:03:12 <avpx> roconnor: I just don't understand the term :-\
15:03:18 <roconnor> the term "functor" is often used to mean something that is like a function in some sense.
15:03:29 <avpx> Right
15:03:32 <kanedank`> huh? but isn't that just like the backtick prefix notation?
15:03:34 <Azel> Conversely, back-quotes are the mean to use a normal function as an operator
15:03:52 <Azel> > 'e' `elem` "Hello"
15:03:54 <lambdabot>   True
15:04:00 <monochrom> there is backtick infix notation, but no backtick prefix notation
15:04:00 <statusfailed> kanedank`: yeah, backticks are like the reverse  :)
15:04:14 <statusfailed> > (`add`) 1 2
15:04:14 <Iceland_jack> > elem 'e' "Hello"
15:04:15 <lambdabot>   <no location info>: parse error on input `)'
15:04:15 <lambdabot>   can't find file: L.hs
15:04:21 <statusfailed> eek
15:05:05 <Soultaker> statusfailed: nice try.
15:05:07 <statusfailed> hehehe
15:05:42 <shachaf> (`foo`) *should* be allowed.
15:05:56 <Reaga> non trivial? ey.
15:06:07 <statusfailed> shachaf: it should?
15:06:08 <Reaga> I need to read stuff now
15:06:09 <Soultaker> it's like doing:
15:06:12 <Soultaker>   (&*&***&**&***&**&*&**puts)("Hello world!");
15:06:14 <shachaf> statusfailed: I mean, morally speaking.
15:06:14 <Soultaker> in C.
15:06:19 <johnw> why does lambadot complain about L.hs so much lately?
15:06:20 <shachaf> statusfailed: Not by the spec.
15:06:21 <Soultaker> (not many people know this is valid C)
15:06:23 <statusfailed> oh ok, haha
15:06:25 <shachaf> johnw: Race condition.
15:06:31 <statusfailed> Yeah, it does seem like it should work
15:06:32 <statusfailed> :)
15:06:38 <Azel> shachaf: You're up to submit that for inclusuion in Haskell's next version ?
15:06:50 <shachaf> Azel: There are more important things to add.
15:06:54 <shachaf> Like nullary classes!
15:06:58 <shachaf> preflex: xseen ddarius
15:06:59 <preflex>  ddarius was last seen on freenode/#haskell 5 days, 2 hours, 9 minutes and 17 seconds ago, saying: So I'm in the Bay area for today and most of tomorrow.
15:07:03 <statusfailed> Azel: WONTFIX: Really? I mean, really?
15:07:06 <statusfailed> :D
15:07:11 <shachaf> Huh, I didn't hear about that!
15:09:06 <nh2> I have a quickcheck question: my function to test works on all strings that don't contain \n. Shall I specify that with ==> or write a Gen that generates all chars but \n?
15:09:07 <kanedank`> also, I'm having a bit of trouble understanding type definitions
15:09:18 <kanedank`> specifically: what do the parens mean here?: fold :: (Doc -> Doc -> Doc) -> [Doc] -> Doc
15:09:38 <avpx> kanedank`: A function argument
15:09:56 <monochrom> parens mean grouping there
15:09:56 <kanedank`> my working model right now is that 'a -> b' is a function and 'b -> c' is a function
15:10:18 <kanedank`> so the first function expects two arguments?
15:10:32 <avpx> kanedank`: Yup
15:10:32 <statusfailed> kanedank`: yep
15:10:33 <monochrom> (Int -> Int) -> Bool  is a function. it takes a parameter. that parameter is also a function
15:10:58 <nh2> kanedank: without parens, fold :: Doc -> Doc -> Doc -> [Doc] -> Doc would be understood as fold :: Doc -> (Doc -> Doc -> [Doc] -> Doc)
15:11:09 <monochrom> in a few minutes you will see why you cannot continue working on the simplistic level of "it is a function, it is not a function"
15:16:05 <nh2> quickcheck question: my function to test works on all strings that don't contain \n. Shall I specify that with ==> or write a Gen that generates all chars but \n?
15:16:31 <valentin> in the "eval (Div t u) = case eval t of" how can I have "Term = Div Term Term"? Do they mean that arity of t can be larger than 1?
15:16:51 <mauke> what
15:17:08 <Botje> valentin: Div is a value constructor.
15:17:17 <Botje> t is a variable you match that value into
15:17:40 <valentin> Botje: thanks
15:18:12 <zhulikas> heh, awesome. Trying to define a Read instance for existential type
15:18:32 <shachaf> zhulikas: It should be very easy!
15:18:37 <zhulikas> :D
15:18:44 <zhulikas> if only I could get the type for it
15:18:52 <shachaf> You can use any type you like.
15:18:54 <zhulikas> without having a value :D
15:19:20 <hpaste> zhulikas pasted “That's what I have” at http://hpaste.org/73199
15:19:50 <shachaf> zhulikas: Ah, I see your confusion.
15:20:05 <shachaf> Read is covariant while Show is contravariant (or is it the other way around?).
15:20:15 * timthelion is in love... With laziness.
15:20:15 <zhulikas> no idea what those two words mean
15:20:17 <shachaf> Which means that a type for Read should be universal rather than existential.
15:20:57 <shachaf> zhulikas: It means that...
15:21:07 <shachaf> First of all, you shouldn't have an existential type for Show in the first place.
15:21:09 <monochrom> I don't think "instance forall a. Read R" is valid to begin with
15:21:36 <shachaf> It's a waste. Just use a String.
15:21:52 <shachaf> zhulikas: Think about what the existential Show type corresponds to.
15:21:53 <monochrom> as for "instance Read R", I don't know what you want done to begin with
15:22:12 <Reaga> hum
15:22:37 <shachaf> It's something like (exists a. (a, a -> String)), where the "a -> String" is the type class dictionary.
15:22:42 <monochrom> though I don't know what you want done, it is safe to bet (99% probability of correctness) that you misunderstood existential type and it is not for your task
15:22:54 <monochrom> regardless of your intuition. (fix your intuition)
15:22:56 <shachaf> Note that that's exactly equivalent to a String.
15:23:05 <Reaga> is objective C a good language?
15:23:12 <shachaf> For Read, on the other hand, it's backwards (you have a function :: String -> a)
15:23:18 <zhulikas> I'm doing shotgun debugging :D
15:23:44 <zhulikas> ok
15:23:45 <shachaf> So it's something like (forall a. (String -> a) -> a) -- i.e., it *gets* the Read dictionary as a parameter.
15:24:16 <shachaf> An existential type for Read doesn't make much sense because the read function can decide on the type. For example it can decide to use ().
15:24:39 <monochrom> > read " ( ) "
15:24:40 <lambdabot>   ()
15:24:46 <monochrom> it does :)
15:24:51 <zhulikas> so I believe this problem cannot be solved
15:25:05 <shachaf> zhulikas: You've yet to state your problem.
15:25:21 <avpx> Reaga: You're not even a good troll
15:25:27 <zhulikas> > (show . read) "make it work!"
15:25:30 <lambdabot>   "*Exception: Prelude.read: no parse
15:25:45 <shachaf> zhulikas: ?
15:25:56 <Reaga> avpx: ?
15:26:01 <zhulikas> ehh forget it
15:26:06 <monochrom> I think the problem is protected by a NDA
15:26:10 <keep_learning> > ( show.read ) "12345"
15:26:12 <lambdabot>   "*Exception: Prelude.read: no parse
15:26:18 <zhulikas> it must be
15:26:36 <keep_learning> > ( show.read ) "12345" :: Int
15:26:38 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:26:38 <lambdabot>         against inferred type ...
15:26:56 <zhulikas> the idea is not to use types here
15:27:13 <mauke> zhulikas: what do you want to use instead?
15:27:23 <Reaga> heh
15:27:26 <zhulikas> I think I just got hooked up to stupid worthless problem
15:27:31 <zhulikas> which should be left alone
15:27:37 <mauke> there is no problem
15:28:17 <monochrom> good! we can now go back to whether aspect pascal is a good language
15:28:27 <zhulikas> :D
15:28:28 <ion> Pascell
15:28:31 <mauke> hectopascal
15:28:56 <Soultaker> why don't case expressions use the same syntax as function guards?
15:29:00 <Soultaker> so confusing...
15:29:13 <monochrom> you mean = vs -> ?
15:29:21 <Soultaker> yeah, and the |'s
15:29:25 <ion> Pascal sounds like paskal’ which is Finnish spoken language for taking a shit. Which results in some snickering in elementary school math classes.
15:29:28 * hackagebot wai-hastache 0.1 - Nice wrapper around hastache for use with WAI (StephenWeber)
15:29:32 <monochrom> they both use | the same way
15:29:57 <Soultaker> case-of doesn't use | right?
15:30:04 <monochrom> does
15:30:12 <Soultaker> really?
15:30:22 <monochrom> > case 5 of x | x>0 -> "hey"
15:30:24 <lambdabot>   "hey"
15:30:27 <monochrom> works
15:30:29 <Soultaker> huh.
15:30:49 <monochrom> only the = and the -> are different
15:30:58 <zhulikas> I'd rather use ->
15:31:01 <zhulikas> arrows are cool.
15:31:06 <Soultaker> but not at the beginning of a new line? or am I doing something wrong?
15:31:33 <monochrom> I am writing on a single line for lambdabot. you can certainly add some line breaks in your file
15:32:08 <shapr> monochrom: See, that's why I want to get ghclive working!
15:32:33 <monochrom> what will ghclive do?
15:33:00 <avpx> https://github.com/shapr/ghclive
15:33:11 <avpx> Looks like an interesting idea.
15:33:32 <shapr> monochrom: You put your Haskell source into the textbox, and other people can connect to the same sessions, then you load that module into the ghci-like critter, and you can the put in statements to evaluate.
15:33:38 <monochrom> ah but chrisdone is done with that
15:33:39 <shapr> monochrom: everyone who connects sees the same thing.
15:33:40 <Soultaker> monochrom: ahh, now I get it.  You introduce a variable x.
15:33:53 <shapr> monochrom: Not quite the same, everybody gets their own with tryhaskell
15:34:01 <shapr> monochrom: Teaching newbies on #haskell means people should have one to share.
15:34:10 <monochrom> I will show you. not tryhaskell
15:34:19 <shapr> ok, show me.
15:35:45 <monochrom> http://www.vex.net/~trebla/haskell/testbed.cgi
15:36:44 <shapr> monochrom: Doesn't seem to allow shared concurrent editing.
15:36:57 <monochrom> right, but that is just me not implementing sharing
15:37:27 <monochrom> or rather, I decide what to share with you, and you obey me!
15:37:31 <shapr> monochrom: what about http://c-71-207-252-122.hsd1.al.comcast.net:3000/edit ?
15:37:33 <Soultaker> what's an easy way to invert an ordering?
15:38:16 <Soultaker> I could do something like: invert cmp x = case (cmp x) of LT -> GT, etc... but that seems complicated.
15:38:48 <mauke> @src Ordering
15:38:49 <lambdabot> data Ordering = LT | EQ | GT
15:39:07 <fmap> flip compare?
15:39:08 <mauke> > map (compare EQ) [LT, EQ, GT]
15:39:10 <lambdabot>   [GT,EQ,LT]
15:39:15 <shapr> monochrom: Whaddya think?
15:39:16 <mauke> invert = compare EQ
15:39:43 <monochrom> good
15:40:32 <Soultaker> let me try to wrap my head around that....
15:40:44 <hpc> > EQ > GT
15:40:46 <lambdabot>   False
15:41:06 <Soultaker> seems like you're comparing the result of the comparison function with EQ
15:41:14 <shapr> monochrom: of course it takes this opportunity to break
15:41:18 <shapr> presentation effect
15:41:48 <shapr> monochrom: But you see how this is a great improvement over teaching people via lambdabot's one line eval and hpaste rewrites?
15:42:03 <hpc> Soultaker: yep
15:42:16 <monochrom> yes
15:42:28 <Soultaker> ingenious.
15:42:44 <hpc> Soultaker: here's another bendy one:
15:42:53 <hpc> EQ ++ x = x
15:42:55 <Soultaker> I think fmap's solution should also work?
15:42:57 <hpc> x ++ _ = x
15:43:10 <shapr> monochrom: I saw lots of people teaching and being taught with a combination of mu-eval, hpaste and irc chat, so I figure it needed to be improved.
15:43:14 <hpc> > (compare 5 3) ++ (compare 3 3)
15:43:17 <lambdabot>   GT
15:43:30 <hpc> > (compare 5 3) ++ (compare 2 3)
15:43:33 <lambdabot>   GT
15:43:36 <hpc> > (compare 3 3) ++ (compare 2 3)
15:43:38 <lambdabot>   LT
15:43:58 <hpc> you can use that to chain comparisons, for say... sortBy
15:44:34 <johnw> wouldn't `mappend` be more appropriate?
15:44:46 <hpc> lambdabot also lets you use (++)
15:44:51 <johnw> ah
15:44:56 <hpc> but yeah, in real code it would be mappend
15:45:03 <hpc> or probably <>
15:45:23 <hpc> @hoogle (<=>)
15:45:24 <lambdabot> No results found
15:45:30 <hpc> aw, spaceship isn't a thing
15:45:44 <DMcGill> yet
15:46:10 <hpc> @hoogle (|=|)
15:46:11 <lambdabot> No results found
15:50:03 <acowley> Anyone have any experience using Representable?
15:50:58 <shapr> Is there a separate irc channel for Text.Blaze?
15:52:31 <DT``> is YAHT still recommended or RWH/LYAH deprecated it?
15:52:43 <monochrom> (|=|) might not work out. (|=|) is taken as the prefix notation for |=|
15:52:57 <hpc> LYAH is by far the best intro nowadays
15:53:03 <hpc> monochrom: i know
15:53:10 <hpc> the operator is |=|
15:53:20 <monochrom> I recommend LYAH. I have never recommended YAHT. so I wouldn't say "deprecate".
15:53:23 <hpc> the TIE fighter to (<=>)'s vader-fighter
15:53:45 <DT``> so, if you had to pick two, you'd pick LYAH and RWH?
15:53:53 <hpc> yeah
15:53:59 <MostAwesomeDude> YAHT?
15:54:05 <hpc> LYAH as the intro, RWH as a reference-y kind of thing
15:54:15 <DT``> MostAwesomeDude, yet another haskell tutorial.
15:54:16 <hpc> but more guided than a typical reference book
15:55:34 <DT``> hpc, good, thank you.
15:55:35 <MostAwesomeDude> Aha.
15:55:39 <DT``> monochrom, thank you too.
15:58:53 <pepijndevos> I'm using shuffle from random-fu, and sometimes is just takes forever, while other times it finishes instantly. Why could that be?
15:59:11 <pepijndevos> shufling 2 60 element arrays
15:59:15 <callen> god fucking dammit I'm writing the maybe monad in Python
15:59:20 <callen> what have you people dooooone to meeeeeeeeeeee
15:59:25 <statusfailed> hahaha
15:59:27 <statusfailed> I know that feeling :D
15:59:55 <zhulikas> :DDD
16:00:15 <zhulikas> I already wrote Maybe-like thingie in C#
16:00:16 <slack1256> callen: as spj said. haskell runs on your brain.
16:00:25 <slack1256> callen: that damn wizard man.
16:00:59 <statusfailed> pepijndevos: woah, that library is awesome
16:01:04 <statusfailed> except maybe for shuffle, heh
16:01:24 <statusfailed> Do you have examples of the two cases?
16:01:38 <statusfailed> i.e., one which always takes a long time and one which doesn't?
16:04:29 * hackagebot http-types 0.7.2 - Generic HTTP types for Haskell (for both client and server code). (AristidBreitkreuz)
16:06:38 <johnw> callen: is Maybe already part of Python?  any value can be None
16:06:48 <johnw> same with type? in C#
16:07:16 <Mortchek> johnw, not in the monadic sense.
16:07:32 <johnw> so do you have "do" notation or something similar?
16:07:42 <mauke> johnw: how do I do Maybe (Maybe Int) in python?
16:07:46 <pepijndevos> statusfailed, same case
16:07:52 <mauke> Just Nothing
16:07:56 <zhulikas> I wrote a function which takes a calculation which can throw an exception. In case of exception null is returned. Otherwise value is returned
16:08:30 <zhulikas> also discovered pipeline design pattern in C#
16:08:43 <zhulikas> which is the same as >>
16:09:12 <johnw> don't pipelines communicate values between segments?  wouldn't that be >>=?
16:09:24 <mauke> >>>
16:09:35 <Jafet> For some instance of >>
16:09:48 <johnw> so, the composition design pattern then
16:11:01 <mauke> > flip id 60 ((*2) >>> sqrt >>> floor)
16:11:03 <lambdabot>   10
16:11:19 <johnw> > flip id 60 ((*2) . sqrt . floor)
16:11:21 <lambdabot>   Ambiguous type variable `b' in the constraints:
16:11:21 <lambdabot>    `GHC.Real.Integral b'
16:11:21 <lambdabot>   ...
16:11:38 <johnw> huh, why does >>> work but not .?
16:11:44 <mauke> wat
16:11:47 <DT``> (>>>) = flip (.) for functions.
16:11:52 <johnw> ahh
16:11:52 <DT``> IIRC.
16:12:02 <mauke> :t (>>>)
16:12:04 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:12:06 <mauke> :t flipd (.)
16:12:07 <johnw> :t (<<<)
16:12:07 <lambdabot> Not in scope: `flipd'
16:12:09 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
16:12:10 <mauke> :t flip (.)
16:12:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
16:12:29 <DT``> > flip id 60 (floor . sqrt . (*2))
16:12:32 <lambdabot>   10
16:12:34 <johnw> ok
16:12:37 <johnw> so . is <<<
16:12:51 <johnw> which makes more sense
16:12:53 <zhulikas> uhm, ok. not a pipeline I guess
16:12:56 <johnw> as the traffic flows from right to left
16:13:12 <zhulikas> idea is that if at some point it fails and passes null value along, next calculations will continue to pass along null
16:13:20 <johnw> ah
16:13:23 <johnw> the Maybe Monad
16:13:23 <zhulikas> so it's like >> for Maybe
16:13:25 <zhulikas> yes
16:13:35 <johnw> i implemented the same thing in C++
16:13:41 <zhulikas> :D
16:13:42 <johnw> but the syntax of using it remained ugly
16:13:46 <zhulikas> Haskell is contagious!
16:13:59 <zhulikas> it infests other languages
16:14:05 <n00b6502> yes
16:14:14 <n00b6502> i'm doing the same, trying to make C++ look like haskell.
16:14:34 <avpx> I think it would be hard to do much of that without garbage collection.
16:14:42 <n00b6502> #define DEF_PARTIAL(funcname, types)   /* now i get partial appliation without having to write bind(...) */
16:14:43 <johnw> haskell is formalized condescension
16:15:10 <johnw> heh, I like the comment update n00b6502 :)
16:15:37 <n00b6502> i've got some templates that let me do this sort of thing    reuslt = myvector.filter(mypred).map(myfunc).eval()
16:15:50 <johnw> very rubyish
16:15:54 <n00b6502> with phoney lazy eval
16:16:24 <n00b6502> i'll just fill out the cases i need
16:16:37 <efe> byorgey: after I changed my $PATH, this is the error log I get : http://hpaste.org/73200 If you would like to take a look ... it is probably "Configuring cairo-0.12.3.1... setup: The pkg-config package cairo-pdf is required but it could not be found." which has to be fixed?
16:18:58 <n00b6502> i still want a haskel to C converter.. i.e. use haskell syntax to as a sort of template language for C ..
16:19:04 <n00b6502> (subset of)
16:19:43 <statusfailed> didn't GHC originally use C as a backend?
16:19:51 <avpx> Yes, until recently.
16:20:04 <n00b6502> i'm still unclear if i can still get at that or not
16:20:14 <statusfailed> apparently so, but deprecated as of 7.0
16:20:17 <statusfailed> -fvia-c
16:20:19 <statusfailed> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/code-generators.html
16:20:38 <avpx> You wouldn't want to use it with your C code anyway. You should interface using the FFI
16:20:40 <applicative> jhc writes C
16:21:34 <n00b6502> really what i've got in my head here is... i like a subset of the functional mentality for C++ imperative programs; it would be even nicer to do it with haskell's clearer syntax
16:21:52 <statusfailed> like fay for C?
16:22:19 <n00b6502> immagine having a bit of both, i.e. haskells great syntax with tuples & partial.. but still writing a program where you reason about memory
16:22:24 <n00b6502> i'll google fay ...
16:22:44 <statusfailed> n00b6502: https://github.com/faylang/fay
16:23:00 <statusfailed> I don't think it's quite what you want actually
16:23:23 <n00b6502> ah thats haskell to Javascript
16:23:27 <statusfailed> yeah
16:23:37 <statusfailed> now you just need javascript to C and you're set!!!
16:23:39 <avpx> n00b6502: Haskell isn't the only functional programming language with type inference and other advanced features.
16:23:42 <n00b6502> hahah lmao so if i write javascript to C with type tracking ...
16:24:15 <n00b6502> avpx , i've looked a tiny amount at scala
16:24:20 <n00b6502> i get mixed opinions
16:24:24 <avpx> n00b6502: You could look into ML.
16:25:09 <zhulikas> there is always frege
16:25:10 <EvanR_> hehe type tracking
16:25:10 <n00b6502> hah i need a language search.. tick the boxes
16:25:24 <EvanR_> haskell and clean are the only lazy ones
16:25:33 <EvanR_> miranda is dead right
16:26:02 <johnw> there's also shen
16:26:10 <n00b6502> in the map().filter() example... the appeal is one can put optimizations in for branchless code on some cpus
16:26:42 <avpx> I hear Unlambda and Lazy K are also good
16:27:09 <n00b6502> you could implement that as a loop with if (predicate) (output result of fuction) ... or you could run the predicates into an array of indices, allocate output space, then run the 'function'
16:27:12 <avpx> I'd stick to the iota combinator version of Lazy K because I don't really like sugar
16:27:28 <n00b6502> is ML the first recomendation?
16:27:47 <n00b6502> scala looked interestnig to me because it has FP *and* straightforward class access
16:28:03 <avpx> n00b6502: ML is nice because it has a Hindley-Milner type system.
16:28:52 <n00b6502> haskell is the only one that has monads for restricting io though isn't it... thats a really good idea IMO
16:30:23 <n00b6502> agh ML gets me to F-sharp but i want something non microsoft
16:30:39 <avpx> That doesn't make any sense to me
16:30:50 <EvanR_> haskell has type classes and monad syntax sugar
16:30:52 <avpx> Microsoft's F# is descended from ML
16:31:21 <Apocalisp> edwardk, are you here?
16:31:23 <avpx> If you're worried about memory usage, you *can* use strict semantics in Haskell.
16:31:25 <edwardk> yep
16:31:36 <acowley> Is there a canonical location for bool :: a -> a -> Bool -> a yet?
16:31:38 <EvanR_> besides that you can 'use monads' in any language
16:31:43 <edwardk> acowley: no
16:31:49 <Apocalisp> edwardk: having trouble understanding SF Fork
16:31:55 <edwardk> Apocalisp: ?
16:32:18 <acowley> edwardk: boooo. I know it's a small definition, but I wish someone would just slip it into Prelude somewhere
16:32:26 <Apocalisp> edwardk: type SF2 a b = SF Fork (a, b)
16:32:30 <edwardk> yep
16:32:58 <johnw> acowley: what does your function meant to do?
16:33:08 <edwardk> that means you can Receive (L f) or Receive (R f)
16:33:29 <Apocalisp> but Receive (k a (SF k a b))
16:33:31 <hpc> acowley: (??) i think is the most popular
16:33:31 <edwardk> data Fork … where L :: (a -> c) -> Fork (a,b) c
16:33:42 <edwardk> k = Fork, a = (a,b) c = SF k a b
16:33:52 <acowley> johnw: it lets you write a more functional if-then-else as in, bool "yes" "no" . even
16:34:05 <acowley> hpc: where is that defined?
16:34:09 <edwardk> so L :: (a -> SF k a b) -> Fork (a,b) (SF k a b)
16:34:14 <hpc> acowley: nowhere, sadly
16:34:16 <johnw> I was arguing for something like this here in the channel about 5 days ago
16:34:17 <edwardk> er
16:34:22 <johnw> i called it eitherOr
16:34:29 <Apocalisp> So you can Receive (L \(a, b) -> c)
16:34:29 * hackagebot direct-sqlite 2.0 - Low-level binding to SQLite3. Includes UTF8 and BLOB support. (IreneKnapp)
16:34:32 <hpc> bool it somewhere on hackage iirc
16:34:36 <acowley> johnw: it's just like maybe and either
16:34:40 <hpc> *is
16:34:47 <edwardk> L :: (a -> SF Fork (a,b) c) - Fork (a,b) (SF Fork (a,b) c)
16:34:55 <edwardk> -> even
16:35:01 <Apocalisp> edwardk: I don't understand why the L case doesn't take (a, b) and the R case doesn't take SF a b c
16:35:06 <aristid> @hoogle (a -> b -> m c) -> m a -> m b -> m c
16:35:07 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
16:35:07 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
16:35:07 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:35:14 <edwardk> Apocalisp: type args vs terms
16:35:33 <johnw> i want maybe/either for lists
16:35:42 <johnw> i.e., if list a is [], use list b, otherwise use list a
16:35:44 <edwardk> the L _data_ constructor takes one function
16:36:01 <edwardk> the L type constructor takes a pair of types and a result type and only uses one of the type pair
16:36:08 <mebaran151> new to haskell: I want to play with the language by writing a simple program to do some salesforce queries and output some CSV; is there a good library for REST/JSON web services to get me started?
16:36:08 <Apocalisp> yeah, but in the SF2 case, that function takes a pair of arguments
16:36:29 <edwardk> no, in SF2 it only takes one argument, for L and the other argument for R
16:36:30 <Apocalisp> edwardk: Oh wait… what?
16:36:51 <Apocalisp> I don't see an L type
16:36:56 <hpc> mebaran151: there's definitely a few JSON libs
16:37:06 <EvanR_> i like attojson
16:37:12 <EvanR_> if think thats what its called
16:37:16 <Nereid> johnw: the equivalent for lists is foldr
16:37:16 <Nereid> ;)
16:37:20 <edwardk> data Fork :: * -> * -> * where L :: (a -> c) -> Fork (a,b) c; R :: (b -> c) -> Fork (a,b) c
16:37:27 <hpc> http://www.haskell.org/hoogle/?hoogle=http -- you should also probably look through here, for making the requests themselves
16:37:50 <Nereid> @type maybe Nothing Just
16:37:52 <lambdabot> forall a. Maybe a -> Maybe a
16:37:53 <Nereid> @type either Left Right
16:37:54 <johnw> Nereid: I don't see how
16:37:55 <lambdabot> forall a b. Either a b -> Either a b
16:38:00 <Nereid> @type foldr (:) []
16:38:01 <lambdabot> forall a. [a] -> [a]
16:38:09 <johnw> i want to select one of two lists
16:38:11 <edwardk> L takes a function from a -> c   . the Fork type constructor (sorry, not the L type constructor) takes (a,b) c as its parameters
16:38:23 <edwardk> when you wrap it in SF you get
16:38:27 <johnw> like: eitherOr [1] [2] => [1]; eitherOr [] [2] => [2]
16:38:30 <Nereid> johnw: I'm just saying that foldr is to lists as maybe/either is to Maybe/Either
16:38:31 <ion> I have had to use “either Right Left” because the iconv package uses insane types.
16:39:11 <mebaran151> hpc: which http library do you think is most friendly?  I'm not sure I can handle fancy features quite yet...
16:39:24 <Nereid> I hear http-conduit is popular.
16:39:30 <aristid> mebaran151: http-conduit has a very friendly simpleHttp function
16:39:46 <aristid> it also has very advanced features, but don't let that scare you.
16:40:34 <edwardk> SF Fork (a,b) c such that Emit :: c -> SF Fork (a,b) c -> SF Fork (a,b) c; Receive . L :: (a -> SF Fork (a,b) c) -> SF Fork (a,b) c;  Receive . R :: (b -> SF Fork (a,b) c) -> SF Fork (a,b) c
16:40:37 <Soultaker> does haskell have a short way to check if a value is between to other values, like Python's lo <= x <= hi?
16:40:43 <mebaran151> also, I might be getting ahead of myself, but once I finish my short program, what's the easiest way to build a fat static binary for deployment?
16:41:04 <Soultaker> *two other values
16:41:04 <johnw> Soultaker: lo <= x && x <= hi?
16:41:05 <EvanR_> not attojson... its called aeson
16:41:26 <avpx> mebaran151: You should just be able to use ghc -static
16:41:28 <Soultaker> johnw: I was hoping for something that would eliminate the duplication of x
16:41:31 <edwardk> Apocalisp: that make sense?
16:41:34 <aristid> does ghc still build static binaries by default?
16:41:37 <Soultaker> but I guess I can just bind it to a variable and do that.
16:41:39 <johnw> Soultaker: I hear you
16:41:39 <Apocalisp> edwardk: No
16:41:45 <Soultaker> (I mean, x is a complex expression, in this case)
16:42:17 <Nereid> Soultaker: you can always define a function like
16:42:25 <Nereid> between lo x hi = lo <= x && x <= hi
16:42:27 <edwardk> Apocalisp: data SF k a b = Emit a (SF k a b) | Receive (k a (SF k a b))
16:42:36 <Nereid> (or, between lo hi x)
16:42:37 <edwardk> er Emit b (SF k a b)
16:42:51 <avpx> Soultaker: x `between` (min, max) = (min <= x) && (x <= max)
16:42:57 <Soultaker> Nereid: true; I just wondered if there was something standard.
16:43:13 <Soultaker> in that case, I'd be a sucker to introduce my own function that does that.
16:43:13 <edwardk> You Receive (L (\a -> your stream))  -- you don't get \(a,b) -> your stream
16:43:13 <johnw> x `in` (min, max) :)
16:43:17 <EvanR_> ;;ticker
16:43:37 <johnw> seems like there should be a lib function for x `in` [min..max]
16:43:39 <johnw> oh
16:43:43 <johnw> x `elem` [min..max]
16:43:47 <edwardk> remember L :: (a -> c) -> Fork (a,b) c  -- the (a,b) are tupled as a type argument to the GADT, not at the term level
16:43:49 <Nereid> that is (a) slow, (b) wrong
16:43:51 <avpx> johnw: That is a really bad way to do it
16:44:02 <Nereid> > 2.5 `elem` [1..5]
16:44:02 <johnw> but it can be done, is all I was sayin' :)
16:44:04 <lambdabot>   False
16:44:21 <zzing_> How can I tell cabal to install things globally instead of user?
16:44:22 <Nereid> another option.
16:44:34 <DMcGill> zzing_: cabal install <package> --global
16:44:37 <edwardk> So Receive . L :: (a -> SF Fork (a,b) c) -> SF Fork (a,b) c
16:44:39 <Nereid> increasing :: Ord a => [a] -> Bool
16:44:47 <Nereid> and then increasing [lo, x, hi] = lo <= x && x <= hi
16:44:51 <applicative> > liftM2 (&&) (>5) (<10) 7
16:44:52 <lambdabot>   True
16:44:56 <edwardk> i think you're getting tripped on the two 'a's involved
16:45:03 <Apocalisp> edwardk: OK, what indicates that (a,b) is a tuple of types?
16:45:14 <Nereid> it is a type of tuples.
16:45:21 <Soultaker> johnw: actually in my case I could probably use that
16:45:23 <edwardk> the a in k a (SF k a b) is the (a,b) in the definition of Fork
16:45:27 <Soultaker> but it's far from a general solution
16:45:28 <applicative> > (&&) <$> (>5) <*> (<10) $ 7
16:45:29 <Nereid> Soultaker: it's a bad idea, don't.
16:45:30 <lambdabot>   True
16:45:31 <edwardk> Apocalisp: that its in the result type of the GADT
16:45:31 <johnw> Soultaker: it will be slow
16:45:44 <avpx> Your soul will be taken, and everyone will laugh.
16:45:49 <Nereid> lol
16:45:51 <Soultaker> my algorithm is already quadratic-time; this seems to add just linear overhead at the end
16:45:53 <edwardk> L :: (a -> c) -> Fork (a,b) c  -- L takes one argument, the GADT argument is only loosely related
16:45:57 <johnw> > (3<=) <*> (<=10) $ 5
16:45:59 <lambdabot>   Couldn't match expected type `a -> b'
16:46:00 <lambdabot>         against inferred type `GHC.Bo...
16:46:03 <edwardk> recall it was originally written with a data kind
16:46:08 <Soultaker> actually, not quite, but the point is it would have little noticable overhead in my case.
16:46:11 <edwardk> L :: (a -> c) -> Fork '(a,b) c
16:46:21 <Nereid> Soultaker: applicative has a nice one.
16:46:36 <Soultaker> anyway, the bottom line is that Python's syntax is really nice in this case, and I wish more languages emulated it
16:46:38 <edwardk> and those don't even _have_ a value level ;)
16:46:50 <Nereid> > let f x = liftA2 (&&) (>= 3) (<= 8) x in map f [2, 4, 8, 10]
16:46:51 <lambdabot>   [False,True,True,False]
16:47:04 <Nereid> (obviously I could have omitted the point x)
16:47:06 <Apocalisp> edwardk: The receive case of SF2 is basically  Receive (Fork (a, b) (SF Fork (a, b) c))
16:47:08 <Apocalisp> right?
16:47:19 <edwardk> yep
16:47:21 <Nereid> @type liftA2 (&&)
16:47:22 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
16:47:36 <avpx> Soultaker: The issue is that it's special syntax and it's not very general.
16:48:00 <Apocalisp> ok, so if Fork's first type argument is (a,b)… then (a,b) is also the argument type for the first argument to its L constructor
16:48:09 <Soultaker> I think it is pretty general, but I'm not sure if it creates ambiguities in Haskell
16:48:11 <edwardk> no, because L :: (a -> c) -> Fork (a,b) c
16:48:21 <edwardk> so the (a,b) is what you see on the right there
16:48:23 <Apocalisp> yeah, but I just instantiated `a` at (a, b)
16:48:31 <Nereid> > 2000000 `elem` [1..5000000]
16:48:32 <lambdabot>   True
16:48:37 <Nereid> heh.
16:48:37 <avpx> Soultaker: Sometimes we add special syntax for things like monads when there will be a big benefit, but (1 < x < 2) just doesn't make sense as a series of function applications
16:48:42 <edwardk> L ignores the 'b' in its type
16:48:44 <avpx> And it's not really worth adding syntax for
16:48:52 <Nereid> @type \a b c -> a < b < c
16:48:54 <lambdabot>     Precedence parsing error
16:48:54 <lambdabot>         cannot mix `<' [infix 4] and `<' [infix 4] in the same infix expression
16:48:57 <Nereid> heh.
16:48:58 <Soultaker> avpx: Ok. Too bad!
16:48:59 <edwardk> Thats like saying Either a b has two arguments, so Left takes two arguments ;)
16:49:17 <typoclass> johnw: if you write it like "f <*> g", then f needs to be a function that takes two arguments
16:49:26 <johnw> i see
16:49:30 <nand`> avpx: I see it desugaring to (x₁ < x₂ < ...) -> (x₁ < x₂ && x₂ < ...)
16:49:30 * hackagebot dom-selector 0.1.0.0 - DOM traversal by CSS selectors for xml-conduit package (nebuta)
16:49:30 <DMcGill> Couldn't agda do something like
16:49:31 <typoclass> > ((==) <*> reverse) "radar" -- palindrome checker
16:49:32 <lambdabot>   True
16:49:45 <DMcGill> _<_<_ : Ord a => a -> a -> a -> Bool
16:49:49 <nand`> the only thing I *don't* like about that syntax is that it makes < and && special
16:49:54 <avpx> nand`: The point isn't that you couldn't, though. But why would you add that sugar?
16:50:00 <DMcGill> l < x < r = ...
16:50:03 <nand`> as if tuples and lists weren't special enough
16:50:05 <Soultaker> the rationale in Python is that parsing x < y < z as (x < y) < z or x < (y < z) (like most other languages do) typically doesn't do what you want.
16:50:06 <Apocalisp> edwardk: No, it's not like that at all. data Either a b  where L :: a -> Either a b; R :: b -> Either a b
16:50:22 <edwardk> Apocalisp: now lets make a GADT for either
16:50:23 <Soultaker> nand`: there is a class of comparison operators, I believe, which are special in that sense.
16:50:30 <edwardk> Apocalisp where we tuple up the arguments
16:50:33 <Apocalisp> ok
16:50:40 <johnw> > (==) <$> (3<=) <*> (<=10) $ 5
16:50:41 <Soultaker> but operators are already special in Haskell in that you classify that with infixl or infixr and a specific priority
16:50:42 <lambdabot>   True
16:50:47 <edwardk> data E x where L :: a -> E (a,b); R : b -> E (a,b)
16:50:49 <nand`> hmm, the Haskell standard forces the names < and &&, doesn't it?
16:50:53 <Nereid> would be cool if we could do applicative brackets like
16:50:54 <johnw> same as the liftA2 example above
16:50:55 <ion> > (False < True) < True
16:50:56 <lambdabot>   False
16:50:56 <edwardk> same difference
16:51:04 <Soultaker> it's not as if Haskell is like APL or Smalltalk in that all operators are equal.
16:51:05 <ddarius> Nereid: Only insofar as Ord is in the Prelude.
16:51:07 <Nereid> [| (>= 2) && (<= 8) |] 5
16:51:10 <edwardk> L still takes one argument, i just tupled them in the type
16:51:27 <Soultaker> (or to be correct: APL and Smalltalk distinguish between unary and binary application of operators only)
16:51:29 <edwardk> see the difference?
16:51:45 <DMcGill> edwardk: what happens to the 'x' type param?
16:51:47 <Apocalisp> I do see the difference. I think I need to see the binders.
16:52:00 <edwardk> DMcGill: nothing, its just a placeholder
16:52:04 <nand`> given L :: (a -> c) -> Foo (a,b) c;  if you matched (L f) then f would have type (a -> c), right?
16:52:07 <edwardk> it could be data E :: * -> *
16:52:12 <shachaf> Oh, ddarius is back.
16:52:13 <edwardk> or if i wanted to write it more safely
16:52:14 * ddarius wishes GADT syntax required the kind signature declaration.
16:52:21 <applicative> (| (5<) && (<10) |) would work with the she-preprocessor, Nereid, or I guess you were saying that
16:52:24 <shachaf> ddarius: How was the west coast?
16:52:27 <Nereid> applicative: yes, I was.
16:52:36 <edwardk> data E :: (*,*) -> * where L :: a -> E '(a,b); R :: b -> E '(a,b)
16:52:41 <applicative> pretty handsome in this case
16:52:47 <Nereid> :)
16:53:04 <ddarius> @tell ezyang For Robert, GHC's exception mechanism is only for GHC not Haskell, and even it has changed drastically multiple times so there's hardly "no chance to fix it."
16:53:06 <lambdabot> Consider it noted.
16:53:10 <applicative> oh i didn't see the scott bracketted line
16:53:16 <ddarius> shachaf: I really like Highway 1.
16:53:17 <edwardk> nand`: yep
16:53:43 <edwardk> ddarius: moreover, most of us don't think its !@#*) broken
16:54:20 <ddarius> edwardk: Well obviously.  Typeable is cruddy, but no one denies that or fails to recognize that it's a really hacky solution.
16:54:28 <ddarius> (for limited values of "no one".)
16:54:29 <johnw> it would be funny if Monad's fail function were named !@#$
16:54:53 <ddarius> johnw: That would require the prefix operators extension to use.
16:54:57 <edwardk> it'd be funnier if it didn't exist ;)
16:55:05 <nand`> that wouldn't be very funny
16:55:08 <nand`> that would be fun
16:55:13 <ReinH> Any examples of Test.Framework in use in a real-world program?
16:55:25 <edwardk> ReinH: i used it for a while for speculation
16:55:32 <edwardk> i wonder if i still have the code
16:55:42 <zxspectrum> is it possible to write a general lifting function like f :: MonadIO m => ContT r IO a -> ContT r m a?
16:55:42 <ReinH> edwardk: how did you find it?
16:55:46 <Apocalisp> edwardk: data E x where L :: forall b. a -> E (a,b); R :: forall a. b -> E (a,b)
16:55:48 <Apocalisp> right?
16:56:06 <Nereid> @type lift . liftIO
16:56:07 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, MonadIO m) => IO a -> t m a
16:56:11 <Nereid> oops.
16:56:18 <Nereid> @type fmap liftIO
16:56:20 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (MonadIO m, Functor f) => f (IO a) -> f (m a)
16:56:22 <edwardk> if you put the explicit forall in there you need to explicitly forall both i think, but yes
16:56:24 <Nereid> doh.
16:56:39 <edwardk> Apocalisp: Fork is just an either of functions to c.
16:56:39 <ddarius> edwardk, Apocalisp: I would expand out the equality constraint.
16:57:06 <edwardk> L :: (x ~ (a,b)) => a -> E x
16:57:23 <edwardk> R :: (x ~ (a,b)) => b -> E x
16:57:37 <Apocalisp> data Fork a b where L :: (a -> c) -> Fork (a, b) c; R :: (b -> c) -> Fork (a, b) c
16:57:55 <hpaste> nanotech pasted “Test.Framework.QuickCheck2 ByteStrings” at http://hpaste.org/73202
16:58:02 <zxspectrum> I am looking at an approach with delimited continuations (shift and reset), but I can't get anything to typecheck, and I'm not sure if it's even possible
16:58:10 <nanotech> I've been trying to use Test.Framework.QuickCheck2 with bytestrings, but it's not working with my Arbitrary instance
16:58:13 <ddarius> For kmc, "fail is usually not a function"
16:58:22 <nand`> edwardk: what's the difference between that and L :: a -> E (a, b) ?
16:58:28 <ddarius> Well, I guess it would be "fail x ..."
16:58:34 <hpaste> nanotech pasted “Test.Framework.QuickCheck2 ByteStrings Error” at http://hpaste.org/73203
16:58:35 <edwardk> so for data Fork x y where L :: (a -> c) -> Fork (a, b) c      -- we get  L :: (x ~ (a,b), y ~ c) => (a -> c) -> Fork x y
16:58:51 <edwardk> nand`: wrong way
16:58:59 <Nereid> can you write a GADT with like
16:59:04 <Nereid> L :: a -> forall b. E (a,b)
16:59:04 <edwardk> E (a -> c, b -> c)
16:59:04 <Nereid> ?
16:59:13 <Nereid> wait, I guess there's no point.
16:59:16 <edwardk> no point
16:59:18 <ddarius> Nereid: Correct.
16:59:18 <Apocalisp> edwardk: Oh, so in the GADT type signature, the _result type of the data constructor_ binds the types.
16:59:21 <edwardk> the forall slides out over the ->'s
16:59:25 <Nereid> indeed.
16:59:29 <edwardk> yes
16:59:41 <nanotech> getting an no-instance error despite my instance definition
17:00:03 <edwardk> data Exp :: * -> * where Ap :: Exp (a -> b) -> Exp a -> Exp b
17:00:03 <Nereid> nanotech: time to paste the code and error message?
17:00:28 <Apocalisp> edwardk: This is what I was missing. L and R are data constructors of Fork (a, b) c.
17:00:29 <nanotech> Nereid: I did; scroll up a bit
17:00:31 <edwardk> or Both :: Exp a -> Exp b -> Exp (a, b)
17:00:33 <edwardk> yep
17:00:33 <Nereid> oh.
17:00:38 <Apocalisp> Fucking Haskell.
17:00:42 <Nereid> I'm blind.
17:00:43 <edwardk> hah
17:00:43 <Apocalisp> How does it work?
17:00:47 <edwardk> magic
17:00:50 <avpx> Apocalisp: Magnets.
17:00:50 <Apocalisp> hehe
17:01:53 <edwardk> there is a reason why the simons live in the cambridge area, they can run around the english countryside hunting for fairies and leprechauns to turn into grist for the ghc mill
17:02:18 * ddarius wonders if we would have gotten GADTs had Simon come to equality constraints earlier.
17:02:21 <aristid> edwardk: i heard there is at least one simon outside cambridge
17:02:34 <ddarius> "GHC, powered by ground up fairies"
17:02:40 <Apocalisp> edwardk: Thanks, this is a major piece I was missing from being able to read Haskell GADTs
17:02:42 <edwardk> foraging for more plunder i would suppose
17:02:51 <edwardk> no problem.
17:03:05 <Apocalisp> Sitting in a talk on Scala futures
17:03:06 <hpc> ddarius: nah, not anymore
17:03:15 <Apocalisp> this is much more educational
17:03:18 <edwardk> i can see how this would drive you to distraction
17:03:20 <hpc> liquid fairies provide more consistent output of magic
17:03:47 <ReinH> edwardk: http://stackoverflow.com/questions/3120796/haskell-testing-workflow :)
17:03:50 <DMcGill> @faq can Haskell run on powdered fairies?
17:03:51 <lambdabot> The answer is: Yes! Haskell can do that.
17:04:15 <hpaste> nand` pasted “L :: x ~ (a,b) => a -> E x” at http://hpaste.org/73204
17:04:25 <ion> Homeopathic fairy liquid which has been diluted to have ca. zero molecules of fairies is the best.
17:04:34 <ddarius> Apocalisp: Probably a slightly more interesting talk than one on Scala options.
17:04:38 <edwardk> i think we used up all the fairies that were left in our local little american cambridge to write https://github.com/ekmett/reflection/blob/master/fast/Data/Reflection.hs#L60
17:04:55 <hpc> i hear 7.4.6 is going to run on unicorns
17:05:06 <aristid> hpc: you  mean 7.6?
17:05:10 <monochrom> wow, you support hugs too? :)
17:05:10 <hpc> yes, that
17:05:31 <aristid> edwardk: do you actually test with hugs? oO
17:05:35 <edwardk> ReinH: i need to update that thing to reflect the fact that speculation no longer uses it, and that the test harness best practices have changed
17:05:40 <edwardk> aristid: every once in a while
17:05:45 <aristid> heh
17:05:49 <edwardk> aristid: semigroups and reflection are both tested with hugs
17:06:07 <aristid> time to test lens with hugs :P
17:06:07 <mebaran151> so I'm looking at HTTP conduit, and I'm not sure how to issue my first post request; ideally I would issue a login, and run all my requests with a custom http action that could store that token; what's the best approach in Haskell for this?
17:06:15 <edwardk> lens and hugs won't get along ;)
17:06:42 <edwardk> mebaran151: you might have better luck on the #yesod channel
17:06:50 <aristid> mebaran151: maybe the Browser module is what you want
17:10:53 <zxspectrum> the main problem with this continuation lifting thing, I think, is the inability to break out of an IO action with delimited continuations :(
17:11:14 * ddarius just realized what reify does.
17:11:21 <zxspectrum> I guess it's not possible then
17:11:58 <hpc> :t reify
17:11:59 <lambdabot> Not in scope: `reify'
17:12:03 <zxspectrum> even though it seems like something that should work intuitively
17:12:31 <hpc> ddarius: is that the one that makes the pretty graphs?
17:12:56 <mebaran151> aristid: Browser?
17:13:20 <aristid> mebaran151: http://hackage.haskell.org/packages/archive/http-conduit/1.5.0.3/doc/html/Network-HTTP-Conduit-Browser.html
17:13:28 <aristid> mebaran151: if you want to store cookies and such
17:13:49 <ddarius> hpc: No.
17:13:51 <nanotech> ah. test-framework-quickcheck2 depends on quickcheck 2.4 while I was using 2.5 everywhere else
17:14:07 <hpc> oh, the TH one
17:14:32 <hpc> yeah, that is a cool function
17:14:47 <ddarius> hpc: No, not the TH one.
17:14:58 * hpc foncuses
17:15:11 <mebaran151> aristid: thanks I'll check it out, but it's not so much cookies as a request header I would be passing with every request
17:15:12 <aristid> why didn't i read the monad reader 19 coroutine text before? oO
17:15:29 <ion> edwardk: Was there a description of how Reflection.hs precisely works somewhere?
17:15:32 <aristid> mebaran151: oh, is this some webservice you're trying to use?
17:15:35 <shachaf>     No instance for (Num a)
17:15:35 <shachaf>       arising from the literal `5'
17:15:38 * shachaf likes that error.
17:15:43 <mebaran151> aristid: yep, Salesforce REST API
17:15:48 <edwardk> ion: nope. just black magic
17:16:27 <aristid> mebaran151: ok, cool
17:16:42 <ion> edwardk: This is a politically correct channel. I think you mean African-American magic.
17:16:43 <edwardk> ion: basically it uses the fact that a dictionary of one thing is represented by that thing, and so it casts a function that takes a dictionary and an argument into a function that takes two arguments.
17:16:54 <aristid> @nixon
17:16:55 <lambdabot> Scrubbing floors and emptying bedpans has as much dignity as the Presidency.
17:17:01 <mebaran151> aristid: yeah, I actually might use the XML incantaion, did a mini starter scraping project with HandsomeSoup and found it terser and less error prone than doing it in Ruby
17:17:05 <aristid> ion: political correctness eliminated.
17:17:12 <ReinH> edwardk: how have the test harness best practices changed?
17:17:12 * ddarius reserves "African-American" for Americans who are actually only recently from Africa.
17:17:19 <mebaran151> Haskell almost makes XML palatable
17:17:26 <edwardk> ReinH: basically you can use cabal test to drive it now
17:17:30 <edwardk> ReinH: take a look at lens
17:17:32 <aristid> mebaran151: that's cool
17:17:34 <ReinH> edwardk: ok!
17:17:34 <edwardk> that has 3 test suites in it
17:17:38 <aristid> mebaran151: which xml package do you use?
17:17:44 <edwardk> before cabal test had to be hooked manually
17:17:46 <mebaran151> I was using HXT with HandsomeSoup
17:17:55 <edwardk> now you can do it without a custom Setup.lhs
17:18:01 <aristid> mebaran151: oh yeah, i think HXT and xml-conduit are the sanest options.
17:18:03 <ion> edwardk: Ah… When using unsafeCoerce, foo :: Bar a => baz and foo :: Bar' a -> baz end up having the same representation upon compilation?
17:18:05 <edwardk> just by adding test sections to the cabal file
17:18:09 * nand` uses “African-American” for people have nationalities of at least some American and some African country
17:18:12 <mebaran151> the arrow notation was a little bit daunting at first, but it basically followed how I think about css transformations
17:18:32 <edwardk> ion: only if its a dictionary that contains a single member
17:18:40 <edwardk> ion: sometimes this is good, sometimes its bad
17:19:02 <ion> edwardk: Alright
17:19:03 <edwardk> if Bar had two methods in it for instance, then all bets would be off
17:19:14 <aristid> mebaran151: i couldn't really myself get to like HXT, but i think that's a matter of taste
17:19:21 <aristid> *get myself
17:19:53 * ddarius makes sure all his Reify instances have SPECIALIZE pragmas.
17:20:13 <mebaran151> aristid: mostly using it for HandsomeSoup, which worked very much like Nokogiri
17:20:27 <aristid> mebaran151: i know neither of those :)
17:21:01 <edwardk> ion: the nice thing is there can be no faster implementation ;)
17:21:02 <aristid> mebaran151: oh that css selector function is cool
17:21:08 <ion> edwardk: aye
17:21:41 <aristid> mebaran151: and the way haskell works, it can even be fast (i don't know how fast it is in practice, but the type allows it)
17:21:56 <mebaran151> sanest css combining too; via listA it was trivial to traverse tree, inspired me to try to bring haskell into a slightly larger projects
17:22:12 <mebaran151> aristid: I'm figuring it just fuses the functions together
17:23:05 <aristid> mebaran151: well what it does it first compiles the string to something (i haven't yet looked closely)
17:23:34 <mebaran151> so I figured; for my purposes it was plenty fast (far more bound by IO than anything else)
17:23:41 <ReinH> edwardk: so paulcc is commenting on my haskell live code and while I generally agree with him I have a few doubts
17:23:43 <aristid> mebaran151: in ruby you'd compile the string every time it's called, in haskell it depends on how the expression is built
17:23:55 <mebaran151> better I didn't have to worry about figuring out what to map where and whether something was a collection
17:24:13 <edwardk> ReinH: how so?
17:24:14 <ReinH> edwardk: specifically https://github.com/haskelllive/haskelllive/pull/16#issuecomment-7689512
17:24:17 <byorgey> @tell efe You need to install gtk and cairo via your OS's package manager. e.g. in Debian it's probably something like  libcairo-dev  and so on. The Haskell gtk2hs and cairo packages are just bindings to the C libraries.
17:24:18 <lambdabot> Consider it noted.
17:24:32 <ReinH> edwardk: wondering if I'm making sense there
17:25:44 <edwardk> personally i liked the code before you refactored it to add the letter list ;)
17:25:49 <edwardk> it was faster ;)
17:25:58 <ReinH> edwardk: if I use a map it would be faster again though right?
17:26:07 <ReinH> as pattern matching is O(n)?
17:26:13 <ReinH> a Map, sorry
17:26:24 <edwardk> in practice the overhead of choosing branches is probably has high as the original match
17:26:31 <edwardk> its a small lookup
17:26:35 <mebaran151> googling about, it looks like I probably wanna connect http-conduit to xml-conduit and create some sort of higher level pattern for Salesforce actions
17:26:39 <ReinH> edwardk: right
17:26:54 <edwardk> before ghc ould turn it into a bunch of operations on unboxed chars
17:27:02 <ReinH> edwardk: also his comments here https://github.com/haskelllive/haskelllive/issues/15
17:27:04 <edwardk> now its got to armwrestle with tuples and chars, etc.
17:27:08 <ReinH> edwardk: right
17:27:26 <ddarius> We need strict (not necessarily unboxed) pairs in the Prelude.
17:28:19 <edwardk> ReinH: overall his comments are mostly bikeshedding between two mostly equivalent choices *shrug*
17:28:39 <ReinH> edwardk: that was sort of my sense
17:28:47 <ReinH> I'm glad it's confirmed by an expert :)
17:28:49 <mebaran151> not completely sure how I would structure this in Haskell
17:29:09 <johnw>  mebaran151: that's pretty one's experience in general when starting with Haskell
17:29:29 <ReinH> johnw: s/haskell/programming
17:29:57 <mebaran151> johnw: none of the concepts seem completely foreigh (I've worked with lisps before, and even the infamous monadic stuff actually seems pretty intriguing
17:30:16 <johnw> lithpth
17:30:29 <ReinH> correct
17:30:32 <hpaste> Jurily pasted “I hate Gtk” at http://hpaste.org/73205
17:30:39 <nand`> does anybody else constantly get errors for accidentally using { ...; ... } in record definitions instead of { ...,  ... } ?
17:31:25 <nand`> I think it might be more fortunate if the , syntax was done away with entirely and ; ; used for inline records and indentation otherwise
17:31:25 <Jurily> after 3 days of intense reading, I almost have the same functionality as a 10 minute Qt project in C++!
17:31:56 <ion> nand: That would be nice.
17:32:38 <edwardk> @tell fmap pushed free 3.1 to hackage with FreeT and CofreeT
17:32:39 <lambdabot> Consider it noted.
17:32:42 <johnw> Jurily: welcome to the madness
17:32:50 <edwardk> (and documentation!)
17:33:06 <ddarius> edwardk: What's there to document?
17:33:14 <edwardk> ddarius: the definition of free for a free monad
17:33:28 <edwardk> ddarius: and some common uses, etc.
17:33:34 <aristid> edwardk: which is better, your or tekmo's free?
17:33:37 <johnw> Haskell is like using a finely crafted blade to whittle yourself a canoe, as your friends pass by on their cruise liner and wonder what you're up to
17:33:49 <a215> > take 60 $ zip (0..) (60..)
17:33:51 <lambdabot>   <no location info>: parse error on input `..'
17:33:57 <a215> how do i do an infinite range
17:34:05 <nand`> johnw: except the canoe is statically guaranteed never to sink?
17:34:05 <johnw> [0..]
17:34:07 <djahandarie> [] not ()
17:34:12 <johnw> nand`: exactly
17:34:14 <a215> > take 60 $ zip [0..] [60..]
17:34:16 <lambdabot>   [(0,60),(1,61),(2,62),(3,63),(4,64),(5,65),(6,66),(7,67),(8,68),(9,69),(10,...
17:34:21 <aristid> edwardk: i see, yours didn't have any transformer version before 3.1
17:34:22 <johnw> nand`: it will be the best damn water conveyance ever seen
17:34:31 * hackagebot free 3.1 - Monads for free (EdwardKmett)
17:34:31 <edwardk> aristid: tekmo uses my free, he just had a freet in a separate package because i hadn't gotten around to adding it in 'free' directly. mine includes everything his does along with Eq, Ord, Show, Read, Foldable, Traversable, etc.
17:34:32 <johnw> nand`: even icebergs will not slow it down
17:34:32 <typoclass> @remember johnw Haskell is like using a finely crafted blade to whittle yourself a canoe, as your friends pass by on their cruise liner and wonder what you're up to
17:34:33 <lambdabot> Done.
17:34:48 <nand`> johnw: it's typed in a way that prevents you from steering it into icebergs
17:34:57 <edwardk> aristid: so i can say unconditionally that mine is better, as code that used his should typecheck with mine and i have more instances ;)
17:34:58 <Jurily> once I'm done, it'll be the best canoe ever!
17:35:00 <aristid> edwardk: so i guess he will switch to your transformer some time?
17:35:04 <Jafet> It comes with lifeboats
17:35:05 * ddarius makes the indexed free transformer construction package, ifreet.
17:35:12 <djahandarie> Hah
17:35:15 <ion> johnw: Does it say “Titanic” on the side of the cruise liner by any chance?
17:35:16 <edwardk> considering he asked me to include it, yes ;)
17:35:23 <Guest6947> @src fix
17:35:23 <lambdabot> fix f = let x = f x in x
17:35:27 <mmcdermo> exit
17:35:31 <djahandarie> ala and ifreet
17:35:34 <edwardk> ddarius: =)
17:35:45 <Clint> djahandarie: btw, i think i meant to tell you http://people.debian.org/~nomeata/platform.html
17:35:51 <johnw> what my friends will never realize is that the ocean is just a Monad, providing the context for what I call "rowing"
17:36:03 <ReinH> johnw: lulz
17:36:19 <djahandarie> Clint, did you? :P
17:36:25 <Clint> perhaps
17:36:44 <djahandarie> I'm clearly missing some context if I'm suppose to understand why I should have been told that link :P
17:36:47 <monochrom> I am not convinced of the canoe and cruise liner analogy
17:36:54 * djahandarie agrees with monochrom
17:36:58 <johnw> that's because I haven't written the proof yet
17:37:00 <johnw> it's forthcoming
17:37:06 <aristid> johnw: a boat is just a free monad that can be used in both an ocean or lake interpreter
17:37:15 <johnw> one thing at a time, people!  this wood is tough to carve
17:37:16 <monochrom> putting the feel of haskell and other languages aside, the economics doesn't work out
17:37:24 <johnw> aristid: lol
17:37:29 <djahandarie> I swear the jokes in this channel go more and more off the deep end.
17:37:32 <Clint> djahandarie: i thought you asked about the platform state in debian
17:37:39 <djahandarie> Clint, oh, it's you!
17:37:43 <johnw> djahandarie: bah dum dum
17:37:55 <djahandarie> Clint, nice, thanks.
17:37:56 <johnw> djahandarie: (the sound of drums when a bad pun is made)
17:38:03 <monochrom> you *pay* to ride on a cruise liner. you *get paid* to write in java etc. are they really analogous?
17:38:32 <johnw> they are riding the cruise liner because they've gotten paid for their work
17:38:53 <Clint> np
17:39:43 <johnw> there definitely is a "pride in craftsmanship" that comes with writing in Haskell, whose personal value I do not take lightly
17:40:03 <johnw> something about writing in PHP always leaves a little piece of my soul behind
17:40:34 <otters> I like PHP
17:40:40 <otters> it makes simple web applications so easy
17:41:06 <Jafet> mod_canoe
17:41:16 <otters> mod_yesod
17:41:44 <Jafet> The apaches don't use yesods, whatever those are
17:42:04 <Jurily> they're hunting buffalo in canoes
17:42:06 <mebaran1`> I don't know, from my experience with other web apps, it's nice to compile a web application with a built web server
17:42:22 <otters> well, I already have an apache config, so it's easy
17:42:27 <mebaran1`> you just throw the binary on the server and let it run (embedded Jetty previous for fun and profit)
17:42:28 <ReinH> given a reversable arrow of time, they are isomorphic
17:42:45 <otters> throw a binary at the server and hope it doesn't bounce off and shatter
17:42:48 <otters> fucking hate when that happens
17:42:49 <johnw> a lot of what defines "easy" is computing is the library of personal stuff you build up for solving solutions you frequently come across
17:42:57 <JoeyA> By the way, can a Yesod application be hosted through Apache?
17:42:58 <johnw> s/is/in
17:43:06 <mebaran1`> yeah on server meaning behind nginx reverse proxy :)
17:43:06 <johnw> s/solutions/problems
17:43:07 <johnw> bleh
17:43:09 <JoeyA> (for a server hosting other sites, too)
17:43:14 <aristid> mebaran1`: that's possible with haskell, i think. you might need to take a little bit of care that things are compiled statically
17:43:15 <otters> just use nginx
17:43:16 <edwardk> johnw: quite a few people get paid rather well for working in haskell ;)
17:43:31 <johnw> edwardk: I want to become one of those people
17:43:41 <aristid> edwardk: you don't, right? you're paid for scala :P
17:43:43 <djahandarie> Some other people get paid well for writing haskell in other languages
17:43:47 <otters> Scala is badass
17:43:48 <johnw> right now I am paid well to write C and C++
17:43:53 <djahandarie> Hey, don't ruin my joke aristid
17:43:57 <otters> right now I'm paid shit to write Ruby
17:44:00 <edwardk> aristid: =P
17:44:02 <johnw> but I'm a contractor; so I just need to find Haskell contracts
17:44:05 <otters> but I haven't gone to college yet so it's okay
17:44:17 <ReinH> technically I get paid to write whatever gets the job done
17:44:25 <ReinH> these days that's mostly Ruby, which I'm ok with
17:44:30 <otters> Ruby is fun
17:44:33 <typoclass> johnw: yup. also if you can get the hang of other people's libraries of that sort, or if it's all an undocumented impenetrable mess
17:44:38 <johnw> yes, Ruby can be quite fun
17:45:02 <otters> I've been in #ruby for about two years but this guy is like "I thought you were new"
17:45:10 <ReinH> heh
17:45:12 <otters> and I'm like "no, I've been using ruby for ages, and I've been here for about two years"
17:45:21 <otters> and I say "ask me an advanced ruby question"
17:45:27 <otters> so he asks me this ridiculous crap about eigenclasses
17:45:27 <mebaran151> the ruby community is a strange strange place
17:45:29 <edwardk> in practice i get paid to be the guy who either already knows the answer to the problem or knows how to figure it out. language is a very small factor in that.
17:45:40 <otters> and I'm like "wtf dude, I know everything else, but not that"
17:45:42 <monochrom> how do you do dependent types in ruby? :)
17:45:43 <ReinH> mebaran151: most communities are
17:45:51 <otters> monochrom: it's fairly easy
17:45:57 <djahandarie> I go to college and I'm still stuck coding shit languages
17:46:05 <ReinH> otters: eigenclass: the singleton class of an object
17:46:06 <otters> how do you instance eval in haskell? :)
17:46:10 <otters> ReinH: yes, I know that *now*
17:46:12 <otters> :|
17:46:14 <ReinH> otters: ok :)
17:46:20 <Jafet> Just implement Haskell in ruby, then port Agda to it
17:46:29 <otters> funny thing was, I knew the answer, but I couldn't explain the answer
17:46:35 <otters> so reputation = destroyed
17:46:43 <ReinH> otters: what's the difference between lambda, proc, and Proc.new? Bonus points for 1.8 vs 1.9 differences. ;)
17:46:48 <ddarius> djahandarie: Don't worry, you get to pay for the privilege.
17:47:06 <aristid> Jafet: wow, that'll make for the slowest programming language ever. including all esoteric pls designed for slowness.
17:47:10 <ReinH> otters: answer: the difference is that I always use lambda because I know how it behaves. ;)
17:47:20 <ddarius> otters: And that's why you're here now?
17:47:22 <brisbin> ReinH: isn't there less of a difference in 1.9?
17:47:27 <ReinH> brisbin: sort of, yes
17:47:35 <brisbin> and i do as you do :)
17:47:35 <ReinH> brisbin: it's complicated ;)
17:47:39 <otters> ddarius: is what why?
17:47:44 <edwardk> monochrom: lemmachine
17:47:51 <otters> ReinH: blah blah blah return blah scope blah
17:47:52 <johnw> i decided to wait until 1.9 was stable before learning Ruby, so I don't know what life in 1.8 was like
17:47:52 <mebaran151> ReinH: those scoping rules made so little sense
17:47:55 <Jafet> aristid: thankfully agda users don't actually write programs
17:47:59 <ReinH> brisbin: argument handling, behavior of return, blah blah
17:48:05 <Jurily> given a FilePath, how do I get its absolute representation?
17:48:08 <aristid> Jafet: that definitely helps.
17:48:13 <ReinH> Ruby is mostly consistent most of the time
17:48:19 <otters> I do not understand what dependent types are.
17:48:20 <ReinH> but where it isn't it's pretty obvious
17:48:24 <ddarius> monochrom: edwardk simply uses copumpkin.
17:48:26 <mebaran151> I think they were all supposed to be Kernel.lambda but were hurt in the making...
17:48:28 <brisbin> ReinH: i hate when return exits the calling method, not the block :(
17:48:31 <johnw> Jurily: canonicalizePath
17:48:34 <otters> nor does the wiki really help because it links me to 1. Wikipedia and 2. a 404 page written in French.
17:48:40 <ReinH> brisbin: don't use return in blocks :p
17:48:43 <edwardk> yes, copumpkin is how i generate agda
17:48:45 <otters> the 404 page is actually more helpful. You know how wikipedia is
17:48:56 <Jurily> johnw: thank you.
17:48:59 <monochrom> one agda user writes programs, in fact web apps. and he came from ruby, and still tells ruby people about agda for web apps
17:49:01 <ReinH> brisbin: you can, oddly enough, use next to always get what you mean by return
17:49:01 <brisbin> ReinH: next :retval ;)
17:49:07 <brisbin> highfive
17:49:08 <otters> yeah
17:49:24 <otters> the thing about blocks is that a lot of it is magic to make you feel like you're still operating in the calling function
17:49:25 <ion> Wasn’t eigenclass just the same thing as metaclass?
17:49:26 <ReinH> I just try to avoid writing blocks that way
17:49:42 <ReinH> otters: blocks are closures. ish.
17:49:50 <ReinH> ion: not if you're being technical
17:49:51 <otters> some_method { return if foo }
17:49:52 <brisbin> ion: i think so? also called the ghost class
17:49:57 <otters> and you just pop out of the calling method
17:49:58 <ReinH> ion: a metaclass is a class that creates classes, i.e. Class
17:50:08 <ion> reinh: In Ruby
17:50:08 <monochrom> I see the pattern now
17:50:18 <otters> an eigenclass is a hidden class that can hold methods and stuff
17:50:32 <ReinH> it's often called the metaclass, but it is not
17:50:38 <ReinH> a metaclass is a class-creating class, i.e. Class
17:50:49 <ReinH> as Class.new is a class
17:51:14 <brisbin> anonymous classes that are fun, i use them in tests and rake tasks
17:51:20 <ReinH> heh
17:51:25 <ReinH> anonymous modules are often funner
17:51:26 <brisbin> like that*
17:51:27 <monochrom> /topic Welcome to #haskell. For haskell performance, please press "dons". For agda writing, please press "copumpkin". To talk to an assistant, please press "*"
17:51:43 <ReinH> lulz
17:51:48 <otters> anonymous modules
17:51:51 <otters> jeez
17:52:01 <brisbin> Module.new i suppose?
17:52:03 <ReinH> Welcome to #haskell, where we discuss Ruby.
17:52:08 <aristid> ReinH: agda has anonymous modules too!
17:52:09 <djahandarie> monochrom, hey now, dons isn't even around anymore.
17:52:11 <ReinH> brisbin: yes
17:52:19 <aristid> preflex: seen dons
17:52:19 <preflex>  dons was last seen on #ghc 41 days, 7 hours and 34 minutes ago, saying: i don't recall a time that the hetzner's been down before
17:52:24 <ReinH> they can be class_eval'd
17:52:31 <ion> preflex: seen bonus
17:52:31 <preflex>  bonus was last seen on #haskell 1 year, 107 days, 5 hours, 24 minutes and 33 seconds ago, saying: yeah i think that's better as well
17:52:35 <aristid> preflex: seen bos
17:52:35 <preflex>  bos was last seen on #haskell 26 days, 1 hour, 38 minutes and 6 seconds ago, saying: Anpheus_: use the Builder type, that's what it's for
17:52:39 <ReinH> that can be useful in creating proxy contexts for metaprogramming, etc
17:52:43 <djahandarie> preflex: seen mmorrow
17:52:43 <preflex>  mmorrow was last seen on #ghc 2 years, 209 days, 21 hours, 55 minutes and 1 second ago, saying: * mmorrow is rtfm'ing
17:52:48 <DT``> isn't calling class-returning classes metaclasses like calling function-returning functions metafunctions?
17:52:49 <typoclass> monochrom: what do i press when i want to talk bollocks? that's what i'm most interested in
17:53:03 <ReinH> djahandarie: must be a pretty thick manual then
17:53:10 <Jurily> preflex: that's one big manual..
17:53:22 <ReinH> Jurily: #winning
17:53:23 <monochrom> we said that 100 days ago. thick manual
17:53:24 <aristid> djahandarie: people talked about mmorrow not having been here in ages already when i first came to #haskell :D
17:53:35 <ReinH> monochrom: to be fair, I wasn't around then. So still #winning.
17:54:00 <bos> aristid: ?
17:54:00 <lambdabot> bos: You have 3 new messages. '/msg lambdabot @messages' to read them.
17:54:07 <Jurily> looks like gtk2hs is taking its toll on my sanity
17:54:09 <aristid> bos: sorry, just a preflex seen
17:54:16 <aristid> bos: didn't want to bother you :/
17:54:40 <ion> You woke it from its slumber!
17:54:40 * djahandarie sacrifices aristid for angering the gods
17:55:02 <ReinH> it must be done
17:55:17 * aristid waves arms and legs hastily to free himself from djahandarie's embrace
17:57:19 <edwardk> i think its a hazard of writing a haskell book. bos is fighting it, but he can only hold on so long.
17:57:47 <ReinH> heh
17:58:08 <ion> Are people who write a Haskell book destined to disappear from IRC for good?
17:58:26 <edwardk> this explains why you never see SPJ or wadler on here, they wrote the book forever ago
17:59:34 <brisbin> snoyman left #yesod as soon as his book came out ;)
18:00:01 <aristid> did chris done write a book too?
18:00:12 <typoclass> edwardk: for all we know, they might quite often be in here, named "pinkmouse82" or some such and asking why return doesn't exit the do block ...
18:00:24 <brisbin> hah
18:00:36 <edwardk> hahaha
18:00:40 <ion> :-D
18:01:11 <edwardk> glad i never got too far in mine ;)
18:02:09 <mapreduce> You just gave me a new way to deal with trolls.  "There seems to be a gap in the market for a book on [..]"
18:03:54 <aristid> mapreduce: sadly the rule only works on people who actually finish books, i think
18:04:11 <aristid> on the bright side, what would we do without edwardk?
18:04:34 <edwardk> you'd probably get a lot more done without my yammering
18:05:16 <aristid> on the whole irc is probably not very good for my productivity, yeah :P
18:05:44 <djahandarie> If it wasn't for IRC, I probably wouldn't even know what Haskell is.
18:05:49 <djahandarie> Possibly not even programming at all.
18:06:36 <aristid> djahandarie: you found to programming via IRC?
18:07:22 <talios> script kiddy origins?
18:07:36 * talios deidles and speaks finally
18:07:59 <djahandarie> aristid, I knew a little about it before, but I really "learned" it thanks to IRC, probably.
18:08:35 <aristid> djahandarie: well i guess that's true for me too. had a few people on irc who taught me a lot
18:08:52 <djahandarie> And no, not really script kiddy, though 'hacking' was fun back when I was in middle school, in the sense of trying to break some sort of complicated system with rules. Never did anything evil, though :).
18:09:52 <edwardk> irc is pretty much the only reason i learned haskell
18:10:25 <mapreduce> edwardk: But you came from mathematics rather than programming, right?
18:10:33 <edwardk> not really
18:10:37 <mapreduce> I mean, you don't sound like a recovering PHP programmer.
18:10:46 <edwardk> i was a computer geek for a looong time.
18:10:52 <djahandarie> I think it was programming -> business -> math -> programming for edwardk
18:11:11 <djahandarie> Or maybe the last item would better be titled 'programming/math'
18:11:16 <edwardk> i binged through academia in 2004-2006 ;)
18:11:27 <ion> progmathing
18:12:36 <edwardk> but yes: programming, demo scene, graphics, phone company, holography, math/cs/bioinformatics/linguistics, defense contracting, finance
18:12:43 <edwardk> you know, the typical
18:13:14 <djahandarie> Haha
18:13:28 <nand`> master of all trades, jack of none?
18:14:03 <edwardk> pretty much
18:14:04 <ion> Have you contributed to demos? Is something available on the Internet?
18:15:06 <edwardk> i used to provide a lot of algorithms for the #coders channel on efnet (later split to ircnet). if you mine through old pre 98 demos for shouts out to harmless thats me
18:15:25 <edwardk> individual demos would be a bit harder to mine after this much time
18:16:40 <mekkz> newbie question: are there any examples of functors that aren't also applicatives? i haven't seen any so far
18:16:46 <mekkz> google doesn't come up with anything on it
18:17:23 <hpc> uh
18:17:30 <hpc> huh
18:17:31 <ion> edwardk: ok
18:17:45 <hpc> mekkz: good question
18:18:12 <nand`> there are functors that can only be made applicatives under certain constraints
18:18:30 <edwardk> guess its a bit off topic, so moving this stuff to #haskell-blah  ;)
18:18:42 <nand`> the first example that comes to mind is Const a
18:18:55 <ion> Const isn’t Applicative?
18:19:20 <edwardk> Const is Applicative given the monoid on the first argument
18:19:22 <hpc> ion: it breaks some rules wrt pure, i think
18:19:22 <ion> Ah, i missed your previous line.
18:19:23 <edwardk> but its a functor regardless
18:19:27 <dstcruz> anyone know what postgresql's numeric or money types map to when using postgresql-simple?
18:19:37 <edwardk> hpc: it isn't a monad, its a fine applicative
18:19:57 <mekkz> Const? what's that? excuse any dumb questions i make.... i justed started haskell a couple months ago
18:20:04 <hpc> data Const a b = Const a
18:20:08 <edwardk> mekkz: newtype Const a b = Const a
18:20:22 <edwardk> instance Functor (Const a) where fmap _ (Const a) = Const a
18:21:19 <parcs`> mekkz: in GPipe, shaders are just Functors and Monoids
18:23:12 <mekkz> Okay. i'll look that up.
18:23:43 <dstcruz> I've trying to map them to Float or Double with no luck
18:23:56 <mekkz> Maybe to phrase my question a better way... would there have been any problems if the haskell designers had just lumped Applicatives and Functors into one big typeclass?
18:24:26 <nand`> mekkz: Const still provides a counter-example
18:24:31 <aristid> mekkz: yes.
18:24:34 <nand`> since the instances are different
18:24:39 <nand`> it would end up breaking eg. package lens
18:25:01 <aristid> mekkz: there are lots of types that are functors, only a subset of them are applicatives
18:25:27 <aristid> i mean ghc can even derive Functor instances automatically, that doesn't work for Applicative
18:25:44 <mekkz> Okay, thanks.
18:26:04 <djahandarie> Is there a quick and fast way to pretty-print records in ghci?
18:27:35 <edwardk> mekkz: Many Functors are not Applicatives that I use every day. Yes. Tons would break
18:28:14 <amliby> dstcruz: What exactly are you trying to do? Take a numeric and get it's value?
18:28:57 <dstcruz> (x :: [(Text, Float)]) <- query_ con "select name, value from sometable"
18:29:01 <nand`> edwardk: I'm having trouble thinking of examples other than various permutations of Const
18:29:03 <mekkz> Could you give an example edwardk?
18:29:26 <dstcruz> where value is defined as "numeric (10,2)" in the postgresql side
18:29:48 <typoclass> djahandarie: call show on the record, then «split ","», then unlines?
18:30:00 <typoclass> (you asked for quick and dirty ... :) )
18:30:50 <mekkz> nand`: when you say Const isn't applicative, do you mean it'd be impossible for it to be made one, or it just isn't defined as one in the haskell libraries?
18:31:03 <nand`> mekkz: I mean making it one requires additional constraints
18:31:05 <nand`> whereas Functor does not
18:31:18 <edwardk> mekkz: ((,) e)  is a comonad, but not an applicative, almost anything in my comonad-transformers package
18:31:39 <djahandarie> typoclass, unfortunately that doesn't help very much, need indentation
18:31:52 <nand`> edwardk: surely that can be made an applicative with Monoid e => ?
18:32:03 <edwardk> nand`: not every 'e' is a Monoid
18:32:21 <edwardk> newtype Ran f g a = Ran { forall r. (a -> f r) -> g r } -- is a Functor
18:32:25 <edwardk> but not an applicative
18:32:26 <nand`> just mentioning that it's awfully similar to Const
18:32:42 <nand`> (rather the other way around)
18:33:09 <ion> > ("foo",succ) <*> ("bar",42)
18:33:10 <lambdabot>   ("foobar",43)
18:33:17 <nand`> I think you can group all of those into the same heap of “types carrying some parameter e that can't be instantiated / combined without Monoid”
18:33:20 <mekkz> this is getting over my head haha. i should've known when i was getting into when i asked.
18:33:38 <edwardk> take the Ran example then
18:33:45 <nand`> yeah, I saw that
18:34:19 <edwardk> newtype K x y z = K ((z -> x) -> y)
18:34:29 <nand`> I think it might be possible to provide a simpler example
18:34:31 <edwardk> is a simpler Ran that fails
18:34:45 <nand`> newtype Foo a = F (forall b. b -> a)
18:35:17 <edwardk> thats easy, since i can pass anything to extract the a
18:35:25 <nand`> oh, hrm
18:35:42 <edwardk> anyways, mekkz, Applicatives are rarer than Functors
18:35:54 <edwardk> and not every Functor can be transformed into an Applicative
18:36:23 <mekkz> Okay. Thanks guys.
18:36:30 <mekkz> I appreciate the help
18:37:17 <nand`> the least contrived example of “what would break if functor/applicative merged” would probably be lens
18:37:25 <nand`> and by contrived I mean mind-bending
18:40:25 <edwardk> yeah
18:40:50 <nand`> (it would mean you're only able to write lenses to fields that are monoids)
18:41:15 <edwardk> yep
18:41:23 <mebaran151> does anyway here know how to disable SSL cert checking in http-conduit; apparently it's broken under Windows :(
18:42:13 <aristid> mebaran151: check out the Manager type. and file an issue: https://github.com/snoyberg/http-conduit/issues?state=open
18:42:31 <mebaran151> aristid: it actually knows it's an issue: it told me that it wasn't supported...
18:42:54 <shachaf> Why would you merge Functor and Applicative?
18:43:41 <aristid> mebaran151: oh, then find that issue and say that you want it. :D
18:43:56 <aristid> mebaran151: but you can disable certificate checking in the Manager, i think
18:45:00 <aristid> mebaran151: or rather, in the ManagerSettings
18:52:47 <mebaran151> aristid: how would I create a function that takes three values and returns in the IO monad?
18:54:11 <aristid> mebaran151: sorry, i'm not sure what you mean
18:54:32 <jyc> just wondering, how forwards compatible is haskell?
18:54:40 <Ralith> mebaran151: f :: Int -> Int -> Int -> IO Int; f x y z = return (x+y+z)
18:54:44 <Ralith> should work
18:54:49 <Ralith> why would you want to do that?
18:54:57 <mebaran151> I want to define a function that always returns CertificateUsageAccept, but the signature says it has to be IO CertificateUsageAccept
18:55:09 <aristid> mebaran151: use return.
18:55:19 <aristid> \_ _ _ -> return CertificateUsageAccept
18:55:30 <Ralith> ^
18:55:43 <aristid> :t return
18:55:45 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:55:55 <aristid> or more specifically, return :: a -> IO a
19:00:20 <mebaran151> aristid: how does it know which monad to package it in?
19:00:57 <typoclass> jyc: you mean "if i write code now, will it still compile with the ghc released in 2013/14/...?"
19:01:13 <aristid> mebaran151: the type is fixed to IO CertificateUsageAccepted, so it knows it has to be IO
19:01:14 <jyc> typoclass: yep
19:03:18 <typoclass> jyc: i don't have much experience with that, but from what i've heard it's not haskell's strongest area
19:03:32 <jyc> typoclass: hm, I see. thanks for the answer!
19:03:41 <Jafet> Code written in 1998 still compiles now
19:05:38 <JoeyA> Jafet: Not if it assumes (Eq a, Show a) => Num a
19:06:09 <typoclass> Jafet: *shrug* as i said, i have not much experience, but here is a lot of mails for example ... http://www.mail-archive.com/haskell-cafe@haskell.org/msg74683.html
19:06:12 <aristid> JoeyA: i think if you compile it in haskell98 mode that should work.
19:06:58 <donri> doesn't that depend on the base package
19:09:54 <Jafet> There are the haskell98 and haskell2010 standards, ghc is unlikely to stop implementing them
19:14:33 * hackagebot implicit 0.0.2 - Math-inspired programmatic 2&3D CAD: CSG, bevels, and shells; gcode export.. (ChristopherOlah)
19:19:33 * hackagebot attoparsec-enumerator 0.3.1 - Pass input from an enumerator to an Attoparsec parser. (JohnMillikin)
19:19:35 * hackagebot daemons 0.1.0 - Daemons in Haskell made fun and easy (AlexandruScvortov)
19:23:48 <hpaste> EvanR pasted “huh” at http://hpaste.org/73207
19:23:57 <Guest6947> ^
19:23:59 <Guest6947> :(
19:24:10 <Guest6947> instance Foo String where
19:24:12 <Guest6947> will not work
19:24:49 <mekkz> Do you mean as of right now it won't work, or it won't in the future?
19:24:55 <typoclass> Guest6947: have you tried [Char] instead of String?
19:25:00 <Guest6947> typoclass: same error
19:25:07 <Guest6947> i have no tried [] Char
19:25:55 <Ralith> looks like an extension is expanding String to something variablish
19:26:40 <mekkz> I know this problem i think, i just had it
19:26:45 <Guest6947> ill take away the type synonym instance and try [Char]
19:26:53 <mekkz> Does it say "illegal instance declaration" or something like that?
19:27:00 <Guest6947> mekkz: ... its in the paste
19:27:13 <mekkz> oh sorry i missed that
19:28:03 <mekkz> Guest6947: Here ya go, the second answer is the best: http://stackoverflow.com/questions/8633470/illegal-instance-declaration-when-declaring-instance-of-isstring
19:28:32 <mekkz> funny, i had that same problem today
19:28:41 <Guest6947> i tried Output ([] Char) same error
19:28:46 <mekkz> read the entire thing
19:29:02 <mekkz> or at least just skip to the solutions section
19:29:56 <Guest6947> reading
19:29:59 <Guest6947> pretty crazy
19:30:13 <Guest6947> basically its impossible
19:30:14 <stepkut> hmm. I am trying to make a Free-monad based parser. I can make this work, data ParserFunctor a = PChar Char a | OneOf [a] | PZero
19:30:18 <Guest6947> and i have to put flexible instances
19:30:27 <Guest6947> moving on
19:31:01 <stepkut> and I can build a 'many' function on top of that.. but I would like to add an explicit, Many, constructor. However.. I can't make the types work ... not sure how to tell if it is possible or not..
19:33:04 <mm_freak> stepkut: a Free-based parser is really just a Free-based State+Either
19:34:03 <stepkut> mm_freak: and ?
19:34:22 <mm_freak> simple non-CPS version:  newtype ParserF s e a = ParserF (s -> (Either e a, s))
19:34:34 * hackagebot daemonize-doublefork 0.1.1 - Start background daemons by double-forking (AlexandruScvortov)
19:34:38 <mm_freak> type Parser s e = Free (ParserF s e)
19:35:05 <mm_freak> stepkut: i'm just saying you don't need the various parsers explicitly
19:36:35 <mm_freak> but to answer your question:  Many would look like:  Many a a
19:37:20 <mm_freak> also your OneOf seems incorrect
19:37:40 <mm_freak> Oneof String a
19:38:14 <mm_freak> (assuming you're parsing Char streams…  also Set Char would be more efficient than String)
19:38:36 <stepkut> OneOf works
19:39:05 <mm_freak> your OneOf is actually 'choice'
19:39:07 <stepkut> OneOf gets a list of parsers and tries them in sequence until one succeeds
19:39:15 <stepkut> yes
19:39:22 <stepkut> I called it that originally, not sure why I changed
19:39:29 <stepkut> clearly it is choice
19:39:33 <mm_freak> it's confusing =)
19:40:55 <stepkut> so, something like this, data ParserFunctor a = PChar Char a | Choice [a] | Many a a | PZero
19:41:06 <mm_freak> yeah, looks sensible
19:41:22 <stepkut> and, then I should be able to implement: type Parser = Free ParserFunctor ; many :: Parser a -> Parser [a] using Many ?
19:42:03 <mm_freak> i'm not entirely sure about Many
19:42:17 <mm_freak> that's many_, not many actually
19:42:27 <stepkut> hmm
19:43:30 <stepkut> I am not certain Many can be implemented.. but not certain it can't either
19:43:51 <mm_freak> it certainly can, but i suspect it's going to be existential
19:43:51 <eyu100> > fix error
19:43:53 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:44:12 <stepkut> mm_freak: yes.. that made it hard (impossible?) to implement runParser then
19:44:29 <mm_freak> no, runParser wouldn't have a problem, but i'm not sure how to express Many
19:44:37 <stepkut> I had a gadt like, data ParserFunctor a where Many :: a -> ParserFunctor [a]
19:44:56 <mm_freak> an obvious solution would be:  forall b. Many (Parser b) ([b] -> a)
19:44:58 <stepkut> and I could implement, 'many' but not 'runParser'
19:45:06 <mm_freak> but that feels wrong, even though it would work
19:45:08 <stepkut> right, I tried that as well
19:47:13 <mm_freak> let's try something simpler…  a language with 'sequence'
19:48:06 <mm_freak> data SeqF a = forall b. Sequence [Seq b] ([b] -> a)
19:48:12 <mm_freak> type Seq = Free SeqF
19:49:03 <mm_freak> runSeq (Free (Sequence cs k)) = runSeq (k (map runSeq cs))  -- i think
19:49:35 * hackagebot sqlite-simple 0.1.0.0 - Mid-Level SQLite client library (JanneHellsten)
19:51:33 <stepkut> many :: Parser a -> Parser [a] ; many p = liftF (Many p id)
19:51:45 <stepkut> seems a bit weird using 'id' there
19:52:01 <stepkut> like.. if we are gonig to use 'id' why even have that field in the first place
19:52:18 <mm_freak> because it's fmapped by (>>=)
19:53:49 <stepkut> you mean it starts as 'id' but as things happen, it will be replaced by a function that does something else?
19:54:44 <mm_freak> yeah…  also liftF already transforms it
19:54:50 <mm_freak> it changes id to Pure
19:55:09 <mm_freak> many p = Free (Many p Pure)
19:55:57 <stepkut> makes sense
19:56:24 <stepkut> so.. I wrote this, but didn't finish because it seemed like cheating to use Parser in the Functor
19:56:41 <mm_freak> i'm not sure whether this is cheating, but i can't imagine any other way
19:56:55 <mm_freak> the functor has no information about the surrounding monad otherwise
19:57:00 <stepkut> i think if it was really cheating it wouldn't type check
19:57:32 <stepkut> my intuition for free monads is still pretty weak
19:57:54 <mm_freak> think of 'a' as "the rest"
19:58:01 <mm_freak> a continuation in a sense
19:58:01 <stepkut> right
19:58:07 <mm_freak> and the constructor is a suspension
19:58:12 <mm_freak> in fact Free is really just Coroutine
19:58:33 <mm_freak> Coroutine from monad-coroutine is a transformer version of Free
19:58:42 <stepkut> i am not clear about what the Free monad is buying me over just putting the recursion explicitly in the type
19:58:55 <shachaf> stepkut: A free monad instance!
19:59:04 <mm_freak> stepkut: lots of instances
19:59:13 <mm_freak> at least if you're using the 'free' library by edwardk
19:59:36 <shachaf> Instances with the laws verified, in particular.
20:03:35 <stepkut> lots of instances being between 10-20.. but only if your functor already has instances for those classes already?
20:03:45 <stepkut> like, instance (Functor m, MonadReader e m) => MonadReader e (Free m) where, ?
20:03:48 <edwardk> stepkut: you don't always win much
20:03:55 <edwardk> what you do get though
20:04:10 <edwardk> is that you can use Free from Control.Monad.Free to prototype and to write interpreters for your type
20:04:21 <edwardk> and you can use the faster free monad types from kan-extensions to run with better asymptotics
20:04:31 <edwardk> when building up free monad terms
20:05:03 <edwardk> there are non-obvious improvements you can make to code using free monads, notably, left associated uses of (>>=) on a 'directly coded free monad' are often really really inefficient
20:05:47 <stepkut> edwardk: because they can't be made more efficient? Or because people just usually screw it up?
20:06:08 <johnw> too bad kan-extensions has zero documentation
20:06:33 <edwardk> usually because they screw it up
20:06:56 <dolio> Because (m >>= f) >>= g walks all the way to the leaves of m, replaces them with f, then walks the whole path again, in addition to what f filled in.
20:06:59 <edwardk> johnw: i take patches
20:07:06 <stepkut> is there some good way to decide when to use directly coded vs the Free monad?
20:07:50 <johnw> edwardk: I'd have to understand it -- i.e., read its documentation -- before I could document, now wouldn't I?
20:08:31 <edwardk> stepkut: yes, if you are going to build a DSL over it, i recommend either directly interpreting the dsl -- the so called 'final' approach. or if you need to do multiple passes over it, encode it using its base functor so you can use one of the more efficient forms when substituting, and use the naive form when interpreting the result
20:08:55 <edwardk> johnw: well, i have only written about 8 blog posts describing them
20:09:09 <johnw> so, summarize them into docs
20:09:11 <johnw> don't make me find them
20:09:16 <edwardk> i'll get right on that
20:09:18 <johnw> otherwise, you're not looking for users
20:09:48 <scooty-puff> edwardk: with the release of ghc 7.6, will tagged's Proxy module be compiled with PolyKinds?
20:09:54 <edwardk> scooty-puff: yes
20:10:15 <scooty-puff> k
20:10:23 <edwardk> as will tagged
20:10:43 <edwardk> johnw: i've been writing documentation pretty much nonstop for the last 3 weeks. i haven't gotten to that package yet.
20:10:51 <johnw> fair enough
20:10:58 <johnw> i'll be happy to proofread for you
20:11:11 <johnw> where do you post your articles?
20:11:23 <edwardk> comonad.com
20:11:30 <edwardk> start with kan-extensions i, ii, and iii
20:11:46 <edwardk> there are later posts on Yielding IO, and Codensity that are also related
20:11:51 <stepkut> edwardk: thanks... I'll finish up this blog post soon and then you can make comments on something more concrete :)
20:11:52 <edwardk> and several more after that
20:12:52 <typoclass> edwardk: thanks for writing documentation. that has been one of haskell's weaker areas, so it's great to hear people are working on it
20:13:23 <edwardk> working on the docs for 'parsers' at the moment
20:15:02 <n00b6502> i was interested in the idea of functions and inverses,(i.e. keeping an encoder & decoder function in sync) is lenses to do with that
20:16:31 <n00b6502> imagine if you have an encoder function thats has to be garaunteed to be lossless
20:16:38 <edwardk> n00b6502: lens lets you define an isomorphism, which helps somewhat with that, though in practice most function embedding/projection pairs aren't true inverses but merely form something idempotent when composed
20:16:59 <geekagent> There's a paper claiming that applicative functors are more general than arrows, but I think I found a counter example to that.
20:17:05 <geekagent> Anyone care to take a look?
20:17:09 <n00b6502> let me catch up on jargon here.. isomorphism =?
20:17:41 <edwardk> an isomorphism between two types is a 'one-to-one' and 'onto' function between them, basically you can map both ways without losing information
20:17:42 <n00b6502> perhaps this is over thinking things but imagine for example compression and decompression
20:17:54 <hpaste> “Kyle Butt” pasted “Applicative to Arrow” at http://hpaste.org/73208
20:17:59 <edwardk> geekagent: there are more applicatives than arrows
20:18:47 <geekagent> edwardk: please give an example of an applicative that is not an arrow.
20:19:34 <geekagent> edwardk: and also please see my paste building an arrow from an applicative.
20:19:35 * hackagebot parsers 0.3 - Parsing combinators (EdwardKmett)
20:20:05 <edwardk> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf provides the relationship between applicatives, arrows and monads
20:20:23 <geekagent> edwardk: I was reading that recently. I think they missed something.
20:20:55 <edwardk> i see your code, but i'm too lazy to beat on it with the 9 arrow laws to see which one fails ;)
20:22:21 <n00b6502> can haskell introspect functions... e.g.  can a function receiving a function inspect its arguments and components if its composed
20:22:37 <edwardk> n00b6502: no
20:22:48 <edwardk> n00b6502: we have parametricity protecting us from that
20:22:51 <geekagent> edwardk: categorically, an arrow is a functor that preserves products, correct?
20:23:25 <n00b6502> can you elaborte on that statement
20:24:03 <edwardk> categorically arrows are a mess. they are some kind of indexed or enriched freyd category
20:24:09 <edwardk> https://personal.cis.strath.ac.uk/robert.atkey/arrows.pdf
20:24:15 <n00b6502> a function can only see whats in the type signature of a function argument?
20:24:25 <n00b6502> beyond that its opaque?
20:24:56 <edwardk> :t flip
20:24:57 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
20:25:03 <edwardk> :t Prelude.flip
20:25:04 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
20:25:07 <edwardk> there
20:25:22 <edwardk> flip takes any function (a -> b -> c) and gives you a function b -> a -> c
20:25:50 <shachaf> You get to decide what a and b and c are.
20:25:55 <edwardk> it knows nothing about the arguments to the function. it doesn't know if one is an Int or a Bool, or a Double, or an Array or a spaceship
20:25:57 <shachaf> They're like "hidden" compile-time arguments.
20:26:05 <edwardk> the caller of flip gets to to pick them
20:26:24 <edwardk> flip can't do anything at all with those arguments other than shuffle them around and pass them to the function where they fit
20:26:37 <edwardk> parametricity protects you from it doing anything stupid
20:26:55 <edwardk> it can't inspect one of them and do something different if its an Int, etc. and you can know this from the type signature.
20:27:04 <edwardk> in fact, the type signature of flip completely determines its behavior
20:27:10 <edwardk> @djinn  (a -> b -> c) -> b -> a -> c
20:27:10 <geekosaur> I would have said referential transparency prevents it because it means you can never see the difference between the varuous ways a given value might be represented; in particular is it a thunk or not
20:27:10 <lambdabot> f a b c = a c b
20:27:58 <n00b6502> is there a way to enforce that something is an inverse of something else at compile time. (mr imperative would just have a test..)
20:28:03 <edwardk> now, if you take a function from (Int -> Int) as an argument, you can of course do different things with it parametricity is much weaker
20:28:17 <edwardk> n00b6502: sadly that is something beyond the power of haskell's type system
20:28:32 <edwardk> there are other languages where you can typecheck the property that something is an inverse of another function
20:28:37 <edwardk> agda and coq spring to mind
20:28:37 <n00b6502> here's me thinking its omnipotent from everything i've seen so far
20:28:47 <edwardk> but they give up turing completeness to get there
20:29:32 <Jafet> I still want a Function typeclass
20:29:43 <edwardk> Jafet: for overloading?
20:29:44 <johnw> yeah, me too
20:29:51 <edwardk> Jafet: use the lens trick ;)
20:29:53 <johnw> so that (.) can be defined in Category
20:30:27 <Jafet> Well, I want the syntactic magic for Function
20:31:53 <edwardk> jafet: like the ability to apply it as a function with ' ' ?
20:32:00 <dolio> Overloading juxtaposition is overrated.
20:32:03 <edwardk> jafet: you can do that today =)
20:32:06 <n00b6502> can the 'encoder/decoder' example be done with some high order trickery...   (encoder,decoder)=compose(invertiblef1,invertiblef2,...)
20:32:11 <edwardk> you just can't put the result in a container
20:32:15 <geekagent> edwardk: I don't understand why when people discuss arrows, they treat first as the defining element. &&& makes it much clearer.
20:32:29 <n00b6502> sorry
20:32:40 <johnw> geekagent: I just don't understand people discussing arrows :)
20:32:41 <n00b6502> can the 'encoder/decoder' example be done with some high order trickery...   (encoder,decoder)=magic_compose(invertiblef1,invertiblef2,...)
20:32:45 <Jafet> How do I do that today, edwardk?
20:32:46 <edwardk> n00b6502: using lens you can compose isomorphism pairs using .    and turn it around with from.
20:33:14 <edwardk> Jafet: http://hackage.haskell.org/packages/archive/lens/2.2/doc/html/Control-Lens-Iso.html
20:33:24 <edwardk> Jafet: See the definition for Isomorphic k
20:33:33 <edwardk> there is an instance for (->) and one for Isomorphism
20:33:57 <Jafet> Hmm
20:33:59 <edwardk> so if you define type a <-> b = forall k. Isomorphic k => k a b
20:34:08 <edwardk> then you can use a <-> b   as a -> b
20:34:13 <edwardk> or as an Isomorphism
20:34:44 <edwardk> http://hackage.haskell.org/packages/archive/lens/2.2/doc/html/Control-Lens-Indexed.html provides the same trick for indexed functions
20:35:03 <edwardk> data Index i a b = Index { withIndex :: (i -> a) -> b }
20:35:07 <n00b6502> is there a tutorial or walkthrough... perhaps i'm trying to half re-invent somethiing in a clumsy way in my head
20:35:38 <edwardk> then I can make class Indexed i k where index ((i -> a) -> b) -> k a b
20:35:38 <edwardk> and instance Indexed i (->) where index f = f . const
20:36:13 <edwardk> so you can now us a forall k. Indexed i k => k a b    as either a function from a -> b or you can call withIndex on it and get (i -> a) -> b
20:36:28 <Jafet> And I can be evil and use something that isn't an isomorphism
20:36:46 <edwardk> jafet: beyond my scope ;)
20:37:06 <edwardk> n00b6502: i don't have a tutorial covering the isomorphisms in lens yet
20:41:31 <n00b6502> i dont know if i'm over thinnking things... imagine for example a datastructure and changing how its clustered & compressed, but keeping lots of code that uses it in sync automatically
20:41:57 <dolio> I don't think that isomorphism example is what people typically want out of a Function type class.
20:42:19 <Jafet> Not me, I'm all for dangerous hacks
20:42:41 <n00b6502> but its more likely one is changing a datastructure to allow different types of query
20:43:02 <Jafet> noob: make a bunch of functions that implement the datastructure
20:43:11 <Jafet> When you change the representation, supply different functions
20:43:31 <Jafet> Then you get lazy and don't want to pass the functions around everywhere, so you put them in a typeclass
20:44:37 <edwardk> Jafet: the Isomorphic class was of course just an example of an overloaded function
20:45:22 <Jafet> Fun with (->) instances
20:45:39 <edwardk> another example would be something like class FunArray a where fun :: Array i e -> a i e; instance FunArray Array where fun = id; instance FunArray (->) where fun = (!)
20:46:07 <lpsmith> dstcruz,  you around?
20:49:35 <n00b6502> hmm..the purpose of the encoding is to modify how various queries can be implemented, i probably am overthinking it, its unlikely anything nontrivial could be automated
20:49:36 * hackagebot Pup-Events-Demo 1.3 - A networked event handling framework for hooking  into other programs. (DanielWilson)
20:49:38 * hackagebot Pup-Events-Server 1.2 - A networked event handling framework for hooking  into other programs. (DanielWilson)
20:50:17 <n00b6502> it would be more like you document what you want to acheive by writing the simpler side (whether its encoder or decoder) and the mental work is in writing the nontrivial side
20:51:19 <edwardk> n00b6502: my usual recommendation is to write the dumbest thing that can possibly work in haskell, then see if you need to improve on it
20:52:59 <n00b6502> i mean just going through the manual process of writing an encoder and decoder in a test like you would in c++ .. but doing it in a more powerful language would save you time
20:54:08 <edwardk> n00b6502: what kind of data structure, like a BVH or BSP or something?
20:54:13 <n00b6502> yes
20:54:37 <n00b6502> but even simpler things like how data is shared and indexed between nodes
20:55:20 <edwardk> note: since data in haskell is usually best implemented as something immutable, sharing of data actually happens pretty easily behind your back
20:55:39 <n00b6502> array of meshes of (raw triangles)  ====>   array of shared attribute tables; array of meshes with references to shared attribute tables and indices into them
20:56:54 <n00b6502> the reasoning is definitely in what you want to actually encode something as... but mentally the work you are doing is often specific to knowledge of how it can be used (eg mapping onto specific instructions to decode it .. how its permuted ..)
20:58:19 <edwardk> n00b6502: you may want to look at the (slighty bitrotted) code for frag. http://code.haskell.org/frag/ http://www.haskell.org/haskellwiki/Frag  -- it was a 3d game written using FRP and quake 3 levels
20:58:39 <edwardk> n00b6502: it might give you an idea how to encode game logic in haskell and how to deal with meshes, bsps, etc.
20:58:49 <n00b6502> i think i've seen that on youtube ;
20:59:07 <edwardk> if nothing else it'll give you a starting point
20:59:20 <n00b6502> right now i'm quite curious to write something like a bsp generator in haskell
20:59:59 <augur> edwardk: can i get your thoughts on something?
21:00:44 <edwardk> augur: that is a distinct maybe
21:00:44 <edwardk> ;)
21:01:03 <augur> :)
21:01:43 <augur> edwardk: so im trying to develop a theoretical framework for talking about formal theories as objects of study
21:02:29 <edwardk> the maybe is getting less distinct as the topic gets more abstract ;)
21:03:19 <n00b6502> if nothing else writing encoders in haskell for data for a c++ engine could be a time saver
21:03:19 <augur> edwardk: eg if the theory is CG, then the object is a specific thing -- some sort of algebraic object consisting of a set of types, some inference rules, etc
21:04:28 <augur> edwardk: or if the theory is a particular CFG, then obviously the object is one of those CFG tuples (N,T,S,R)
21:05:13 <edwardk> or something isomorphic to it
21:05:21 <augur> edwardk: but the idea is to have a theory of such theories. ie a definition of what it means to be a theory, so that CFGs, CGs, etc. are instantiations
21:06:00 <edwardk> sounds like a remarkably high height from which to try to do any real work ;)
21:06:09 <augur> well
21:06:13 <augur> i think i have that part down actually
21:06:20 <augur> because its not _that_ high a height
21:06:30 <augur> well, part of it anyway
21:07:18 <augur> what i did was basically just described a collection of types, a together with something like a description of record constructors for types, etc.
21:07:35 <augur> but what im puzzling over now is
21:08:22 <augur> i want a data type for analyses-in-a-theory
21:09:04 <augur> eg if you have the sentence "John saw Aeryn", you could have a particular analysis of this structure in some theory
21:09:37 * hackagebot opentheory-primitive 1.0 - Haskell primitives used by OpenTheory packages (JoeHurd)
21:09:39 <edwardk> specify the laws of the theory, and then the anlysis is just a series of applications of the laws.
21:09:48 <augur> edwardk: right, thats the goal
21:09:55 <augur> but heres the thing where im stuck
21:10:14 <augur> my initial instinct is to let the analysis consist of a (typed) set of abstract objects forming a graph
21:10:54 <augur> if its a CFG analysis the abstract objects are nodes in a tree, together with an ordering relation on nodes (or perhaps just on terminal nodes)
21:11:24 <augur> if its a CG analysis, it would have nodes be inferences, types, etc.
21:12:11 <augur> essentially just a graph representation for the data terms that code up the structures, right
21:12:36 <augur> but if i use a graph representation, the graphs could be cyclic
21:12:45 <augur> not necessarily bad -- some theories might want cyclic representations!
21:13:12 <augur> but certainly bad if you want to be able to define a catamorphism over the structure as part of the analysis
21:13:45 <augur> cyclic graphs cant have catamorphisms over them because they're essentially coalgebraic objects
21:13:47 <edwardk> don't use a catamorphism, break up your graph into nodes where each node holds some kind of base functor with references to other nodes in the graph
21:13:56 <edwardk> smash those fragments into a map somewhere
21:14:00 <edwardk> and then name one the root
21:14:08 <augur> but there might be one root
21:14:11 <augur> there might be 10
21:14:15 <augur> depending on the theory
21:14:16 <edwardk> great then name 10 roots
21:14:21 <edwardk> catamorphisms aren't magic ;)
21:14:25 <augur> i know P
21:14:26 <augur> :P
21:14:38 <edwardk> there is no reason to believe you should be able to use catamorphisms on most of these theories
21:14:44 <augur> edwardk: right
21:14:50 <augur> but what about theories where you CAN use catamorphisms
21:15:00 <edwardk> then you can use the direct representation of the graph
21:15:06 <augur> what
21:15:22 <edwardk> i mean you can encode the graph as a tree and fold your way up it
21:15:32 <augur> oh, yes, but thats the issue, right
21:15:33 <edwardk> these theories don't have to all use the same representation
21:15:40 <augur> if i want to give a single uniform description of an "Analysis"
21:15:54 <augur> it has to be capable of describing both structures that _could_ have catamorphisms defined for them
21:15:57 <augur> and also structures that _couldnt_
21:16:18 <augur> and there might be mixtures, right
21:16:31 <edwardk> you have references to things and relationships between things and maybe some kind of dictionary of things. in the theories where you can use a catamorphism maybe you have one thing and that thing is a tree
21:16:35 <edwardk> with relationships to its children
21:16:46 <augur> so for instance, you might have an analysis where some objects have catamorphisms, but others have the dual (i forget the name)
21:16:57 <edwardk> in other theories maybe you have a whole map full of named nodes with relationships to other named nodes, but no obvious tree structure
21:17:09 <edwardk> i think you're trying too hard to make things look the same
21:17:19 <augur> perhaps
21:17:23 <edwardk> anamorphism
21:17:26 <augur> thats it
21:18:02 <augur> but the reason i want them to look the same is that i want to then go on to characterize the process of _changing_ an analysis
21:18:25 <augur> and you might change an analysis from one that enables catamorphisms to one that enables anamorphisms
21:18:49 <edwardk> changing the analysis is just working on the set of rules you are applying to the various objects, it can be largely independent of the set of objects available to the analysis
21:18:53 <augur> and i would prefer it if the change didnt require a huge reformulation
21:19:27 <edwardk> and cata -> ana is a big deal. especially if you are off in theorem-prover territory where this usually would take you from data to codata
21:19:36 <augur> in the graph setting, enabling catamorphisms is a sort of meta-property -- the data descriptions dont permit cyclicity, etc.
21:19:49 <augur> edwardk: i know
21:20:10 <augur> but in a graph setting, its not a big deal as much. cyclic graphs arent magical new kinds of graphs
21:20:15 <augur> theyre just graphs that happen to have cycles
21:21:44 <augur> its just "accidental" that you could only give an anamorphism for a cyclic graph and not a catamorphism
21:22:33 <edwardk> well its accidental that a catamorphism or anamorphism would apply in the first place ;)
21:22:39 <augur> yes :)
21:22:47 <augur> i think it might be useful if i understood how catamorphic definitions are possible at all in haskell
21:23:09 <kanedank> what does "=>" mean?
21:23:10 <edwardk> cata :: Functor f => (f a -> a) -> Mu f -> a  -- done
21:23:12 <augur> since they can be given, but only work if the data is finite
21:23:32 <edwardk> kanedank: its an implication arrow. the stuff on the left are constraints on the type on the right
21:23:35 <augur> edwardk: well yes, but cata isnt _really_ a catamorphism, since haskell only has codata
21:23:49 <edwardk> augur: no, you can build catamorphisms of infinite data
21:23:54 <augur> oh?
21:24:03 <edwardk> no, its a real catamorphism, its just that Mu and Nu coincide in haskell
21:24:10 <augur> oh, right
21:24:17 <edwardk> the least fixed point of haskell _is_ the greatest fixed point
21:24:35 <augur> then i guess im fine
21:24:55 <edwardk> augur: an interesting exercise:
21:25:09 <augur> since cyclic graphs correspond to some sort of category with coinciding LFP and GFPs
21:25:24 <augur> or graphs in general, rather
21:26:10 <edwardk> newtype Mu f = Mu (forall a. (f a -> a) -> a); data Nu f = forall a. Nu a (a -> f a)  -- build mappings from Mu f -> Nu f and vice versa given Functor f
21:26:18 <augur> :P
21:26:27 <augur> ill pass!
21:26:29 <edwardk> and then finally from each to newtype Fix f = Fix (f (Fix f))
21:26:36 <edwardk> its actually quite a seriously useful exercise
21:26:37 <shachaf> Hmm, what's Nu?
21:26:39 <edwardk> and its not hard
21:26:57 <augur> edwardk: i suppose i could try to do it in agda without termination checking
21:27:00 <edwardk> Nu is the greatest fixed point, defined in terms of an unrolling. think 'unfoldr' to build a list
21:27:10 <augur> i try not to program interesting things in haskell
21:27:12 <edwardk> augur: you can do the Mu -> Nu mapping in agda without flags
21:27:22 <shachaf> edwardk: Hey, this is also related to that Yoneda/Coyoneda thing, isn't it.
21:27:24 <augur> edwardk: really?
21:27:28 <augur> hm.
21:27:29 <augur> ill try!
21:27:52 <edwardk> shachaf: good eye =)
21:28:03 <augur> yoneda is just about fancy continuations!
21:28:26 <edwardk> at least half of it is, when applied in a limited setting to haskell types ;)
21:28:33 <augur> :p
21:28:49 <augur> piponi's tutorial on yoneda made it make sense to me
21:28:58 <augur> prior to reading it, i had no clue what yoneda was all about
21:29:02 <augur> now its easy as pie
21:29:24 <edwardk> again its a pretty limited usage of a much more general tool
21:29:30 <augur> yeah
21:29:43 <augur> it was hard for me to understand tho
21:29:56 <augur> it just seemed like wankery about function application and i didnt get it
21:30:37 <augur> edwardk: should i use genuine functors in agda or will that not matter
21:31:24 <edwardk> ask someone who writes agda ;)
21:31:31 <augur> edwardk: well i mean
21:31:37 <augur> does the functoriality of f matter
21:31:46 <edwardk> you'll probably want it
21:32:27 <augur> also, should it be F : Set -> Set or ..
21:32:32 <augur> i feel it shouldnt work, because Mu and Nu dont coincide for |Set
21:33:04 <edwardk> augur: With Nu you're going to be working with codata, with Mu, data.
21:33:10 <edwardk> so keep that in mind
21:33:31 <edwardk> on that note, i'm going to go get some sleep
21:33:41 <augur> night
21:36:44 <shachaf> edwardk: Ah, the goal is to write f :: Functor f => Mu f -> Nu f and vice versa?
21:37:15 <augur> i wish there were an agda-like editor for haskell :(
21:37:46 <Ralith> why not just use agda?
21:37:58 <shachaf> Ralith: "use" and "agda" in the same sentence?
21:38:30 <augur> Ralith: because itd be a lot harder to code up
21:38:41 <augur> i think edwardk is wrong about how easy it would be
21:39:32 <edwardk> shachaf: in haskell, yes. in agda, just Mu -> Nu
21:39:33 <mm_freak> there is nothing wrong with "using" agda, but not for what i'd like to use it
21:39:50 <Ralith> ?
21:40:03 <mm_freak> proving yes, programming no
21:40:33 <hpaste> “Kyle Butt” pasted “Applicative to Arrow w/ implementation of freshName” at http://hpaste.org/73210
21:41:13 <shachaf> edwardk: Oh, in Agda you can only go in one direction?
21:41:29 <Ralith> mm_freak: why not?
21:41:43 <mm_freak> Ralith: because it's impractical right now
21:41:44 <Ralith> shachaf: I think he means you don't need the functor bit to be explicit.
21:41:47 <Ralith> mm_freak: why is that?
21:42:06 <mm_freak> Ralith: missing libraries mainly
21:42:18 <augur> ah, if its just one direction it might be easier
21:42:24 <mm_freak> interfacing to haskell is possible, but inconvenient
21:42:27 <aristid> :t In
21:42:29 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
21:42:45 <aristid> so lambdabot's Mu isn't even Mu? oO
21:42:54 <augur> edwardk: one direction or both in agda?
21:42:56 <edwardk> shachaf: its more obvious if you encode Mu as the fixed point using data and Nu as the fixed point with codata
21:43:05 <edwardk> augur: only Mu -> Nu
21:43:14 <augur> edwardk: oh ok.
21:44:36 <killerswan> hey, have any of you used iterIO for SSL requests lately?
21:45:30 <killerswan> I'm seeing a segfault when I call OpenSSL.Session.contextSetCADirectory
21:45:54 <killerswan> (and if I skip that, I see an error on simpleGetHttps)
21:47:59 <illusionoflife> @type map
21:48:01 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:49:10 <illusionoflife> @version
21:49:10 <lambdabot> lambdabot 4.2.2.1
21:49:10 <lambdabot> darcs get http://code.haskell.org/lambdabot
21:49:43 <illusionoflife> > map (+1) [1..10]
21:49:45 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
21:50:20 <illusionoflife> > unsafePerformIO $ putStrLn "Hello world!"
21:50:21 <lambdabot>   Not in scope: `unsafePerformIO'
21:50:36 <illusionoflife> putStrLn "Hello"
21:50:47 <illusionoflife> >  putStrLn "Hello"
21:50:47 <illusionoflife> >
21:50:49 <lambdabot>   <IO ()>
21:51:07 <Nereid> gotta get more creative than that ;)
21:51:47 <illusionoflife> > Just 1
21:51:49 <lambdabot>   Just 1
21:52:13 <Nereid> > fix Just
21:52:14 <lambdabot>   Occurs check: cannot construct the infinite type:
21:52:14 <lambdabot>    a = Data.Maybe.Maybe a
21:52:17 <Nereid> of course.
21:52:42 <tgeeky> anyone know how to turn *off* executable stripping? Evidently it's failing, and it's causing cabal build to fail.
21:53:18 <illusionoflife> @type fix
21:53:20 <lambdabot> forall a. (a -> a) -> a
21:54:03 <illusionoflife> @run fix 1
21:54:04 <lambdabot>   1
21:54:11 <solrize> @where genericLength
21:54:11 <lambdabot> I know nothing about genericlength.
21:54:38 * hackagebot ListLike 3.1.6 - Generic support for list-like structures (JohnLato)
21:54:42 <aristid> @hoogle genericLength
21:54:42 <lambdabot> Data.List genericLength :: Num i => [b] -> i
21:54:51 <aristid> ^ solrize
21:55:04 <nand`> > fix (In . Just)
21:55:09 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
21:55:20 <illusionoflife> > fix sin
21:55:24 <lambdabot>   mueval-core: Time limit exceeded
21:55:42 <illusionoflife> @type fix
21:55:43 <lambdabot> forall a. (a -> a) -> a
21:55:54 <illusionoflife> @run fix 3
21:55:55 <lambdabot>   3
21:56:07 <shachaf> It turns out these things are so easy edwardk can do them in his sleep.
21:56:13 <shachaf> Oh, wait, I was just scrolled up.
21:56:13 <illusionoflife> why `fix 3` exsist?
21:56:23 <nand`> 3 can be a function
21:56:28 <augur> illusionoflife: blame cale :)
21:56:29 <nand`> > fix (const 3)
21:56:30 <lambdabot>   3
21:56:36 <Rotaerk> I herd you like a, so I put an a in your a so you can a while you a
21:56:37 <augur> he messed around with lambdabot to make it fancier
21:56:47 <edwardk> shachaf: =P
21:56:51 <illusionoflife> @type 3
21:56:51 <augur> also, illusionoflife:
21:56:53 <lambdabot> forall t. (Num t) => t
21:57:02 <augur> > iterate sin 1
21:57:03 <lambdabot>   [1.0,0.8414709848078965,0.7456241416655579,0.6784304773607402,0.62757183204...
21:57:48 <illusionoflife> > (!!) (iterate sin 1 ) 1000000
21:57:49 <lambdabot>   *Exception: stack overflow
21:58:44 <illusionoflife> mfix Just
21:58:53 <illusionoflife> @run mfix Just
21:58:57 <lambdabot>   mueval-core: Time limit exceeded
22:02:42 <chris2_> ping
22:03:30 <shachaf> chris2_: There is only silence and some second-hand clothes.
22:04:24 <Nereid> > foldl' (flip id) 1 (replicate 1000000 sin)
22:04:27 <lambdabot>   1.7320415240522167e-3
22:04:51 <Nereid> > foldl (flip id) 1 (replicate 1000000 sin)
22:04:55 <lambdabot>   *Exception: stack overflow
22:07:58 <shachaf> Ugh, polymorphic recursion. :-(
22:09:29 <ParahSailin__> :t replicate
22:09:31 <lambdabot> forall a. Int -> a -> [a]
22:10:09 <shachaf> Hmm, so I have foo = bar . baz failing but foo x = bar (baz x) succeeding.
22:10:15 <shachaf> Ah, I guess this rank-2 type is to blame. :-)
22:13:43 <nand`> hrm, great; more aliases in lens now?
22:13:48 <nand`> ‘over = mapOf’
22:13:53 <edwardk> adjust became over
22:13:56 <edwardk> i removed adjust
22:14:15 <shachaf> It turns out that when you get rid of all the aliases and the type synonyms, lens only exports a single actual function.
22:14:19 <shachaf> And that function is id.
22:14:25 <edwardk> by switching to over, i could make the corresponding operation on iso into 'under' ;)
22:14:30 <edwardk> shachaf: =)
22:15:08 <edwardk> my wife took to calling me the wizard of id the other day
22:15:27 <edwardk> after she saw the id jokes on channel
22:18:06 <shachaf> edwardk: You're more like the const conjurer, in my opinion.
22:18:39 <yitz> > let wizard = "edwardk" in case wizard of id -> True
22:18:40 <lambdabot>   True
22:20:33 <MostAwesomeDude> edwardk: Hey, what happened to "focus"? Is it still around?
22:20:39 <edwardk> yep
22:21:05 <mysticc> Any body using haskell-mode with ghc-mod in emacs ?
22:21:15 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Type.hs#L279
22:21:23 <MostAwesomeDude> edwardk: Aha, didn't see it there.
22:21:37 <edwardk> the Focus(..) class makes it a little harder to find
22:22:01 <edwardk> it works on both StateT and ReaderT now
22:22:50 <edwardk> i may make a version with an MPTC that can be used to focus on more deeply nested state using ugly tricks like the ones that let _1, etc. work for monomorphic tuples
22:23:07 <edwardk> might give it a different name though
22:24:28 <MostAwesomeDude> I see, so it replaces the "local" function too.
22:24:43 <edwardk> only for an outer-most ReaderT
22:25:21 <edwardk> focusing can be done with Traversals, whatever this other operation that is focus-like but can change deeply nested state will probably only work with a lens
22:26:24 <edwardk> but the third focus-like operation that can do type-changing local for nested types could work for any getter.
22:26:31 <MostAwesomeDude> Hmm. 'k.
22:26:35 <shachaf> JunkBee: I use :set smarttab expandtab autoindent sw=4
22:26:41 <Nereid> I go away for like 3 days and the lens package moves by 5 minor version numbers.
22:26:49 <Nereid> sloooooooooow down
22:26:52 <edwardk> Nereid: i've been off my game
22:26:58 <edwardk> Nereid: no =P
22:26:58 <Nereid> lol
22:27:04 <MostAwesomeDude> I'm tinkering around with SDL, and finding that it's difficult to get all my types lined up.
22:27:17 <MostAwesomeDude> But maybe this is a consequence of being all C-like and only using types as data containers.
22:27:23 <tgeeky_> Nereid: just think about all of the things he's *not* publishing.
22:27:45 <edwardk> if you want stability just go use all the packages i'm not working on right now ;)
22:28:03 <edwardk> at any given time 95% of my deployed packages are perfectly rock solid stable
22:28:56 <shachaf> Hmm, my implementation of this function got a kind error.
22:28:58 <edwardk> thinking about calling the nested state type-changing operation 'zoom' and the one for dealing with nested readers, 'magnify' ;)
22:29:00 <shachaf> I didn't know you could do that.
22:29:35 <shachaf> (I.e. f = undefined compiles, f = ... fails with a kind error.)
22:29:58 <danil> shachaf: no type annotations in the body?
22:30:06 <shachaf> danil: Nope.
22:30:09 <tgeeky_> edwardk: heh. I am not at my desktop now, but somehow, in the Lift class in haskell-src-meta, GHC was complaining that "instance Ord Type" was the same thing as "instance Ord Kind"
22:30:11 <shachaf> Although there are a couple of ImplicitParams.
22:31:03 <edwardk> tgeeky_: did they make one an alias for the other in the presence of data kinds?
22:32:28 <tgeeky_> edwardk: I don't think so.
22:32:33 <danil> edwardk: I think they've been aliases in GHC for a while
22:32:37 <tgeeky_> I haven't fixed it yet
22:32:58 <edwardk> danil: yeah
22:33:06 <edwardk> danil: just wondering about Language.Haskell.TH
22:33:46 <tgeeky_> i'll tell you tomorrow. :o
22:34:18 <tgeeky_> it was complaining of duplicate instances, so I assume danil is right. But then again, I don't see why it would have compiled
22:34:27 <tgeeky_> (before, in 7.4.1)
22:34:41 <edwardk> tgeeky_: in 7.4.1 the supplied TH version has them separate
22:34:55 <edwardk> betting in 7.6.1 they made TH merge the two types
22:35:06 <edwardk> there was a bunch of mailing list chatter about TH improvements
22:35:37 <tgeeky_> I just deleted the Kind one, and it disappeared. I had to add three or four Ords to get it to stop complaining, and then I was left without "instance Lift Word8"
22:36:31 <edwardk> just look at your TH docs to see what changed
22:38:22 <edwardk> class Zoom f m n s t | m -> s f, n -> t f, m t -> n, n s -> m where zoom :: SimpleLensLike (f c) t s -> m c -> n c -- or something like that
22:38:37 <JunkBee> shachaf: thank you. I am not sure which command fixed my indentation but one of them did. My config file is all in two letter commands...
22:38:41 <shachaf> edwardk: You know that thing people sometimes say about Haskell and single-letter variable names?
22:38:49 <edwardk> shachaf: =P
22:38:55 <edwardk> that they are awesome?
22:39:09 <shachaf> That there is a time and place for everything.
22:39:15 <edwardk> instance Monad m => Zoom (Focusing m) (Strict.StateT s m) (Strict.StateT t m) s t where
22:39:15 <shachaf> Or something.
22:39:16 <danil> shachaf: now I want to see that term :P.  All the conventional (i.e. non kind polymorphic) typechecking papers I've read seem to either not mention kinding or claim it's sufficient to kind check type declarations / classes / signatures before typechecking terms.
22:39:47 <tgeeky_> shachaf: just make an editor which will do in-place expansions of single letters into words :O
22:40:17 <shachaf> edwardk: At least you provide a nice Overton window for people who complain that *I* use too many single-letter names!
22:40:24 <edwardk> ;)
22:40:25 <tgeeky_> hehe
22:40:53 <edwardk> I was working on a resource management monad earlier where the types wound up looking like R e d s o x -> ...
22:41:09 <edwardk> the mnemonic wound up quite helpful
22:41:10 <tgeeky_> I prefer not things like "Lens a b c d", unless that is a "Lens alpaca buffalo cat dog"
22:41:26 <tgeeky_> edwardk: I've been doing things like that locally for a while. That's part of what I was advocating months ago
22:41:56 <shachaf> (Functor fox) => (cat -> fox dog) -> alpaca -> fox buffalo
22:42:02 <shachaf> I could get used to that naming scheme.
22:42:07 <tgeeky_> hehe
22:42:23 <tgeeky_> actually, "f" is for Functor
22:42:28 <tgeeky_> so that would stay f
22:43:14 <edwardk> tgeeky_: i literally had to write out  6800 lines of haskell where about 1/2 of the lines had those signatures in it. typing them with single character names and a consistent name usage pattern saved my sanity ;)
22:43:26 <tgeeky_> edwardk: yea! that's what I'm saying
22:43:46 <tgeeky_> I mean, I don't burp out thousand line code bubbles, but still.
22:44:13 <edwardk> depending on who you ask they may say i pull the code out of the other end
22:44:19 <tgeeky_> hehe :)
22:44:46 <tgeeky_> that's a bubble if you're on the ISS, in the same way that s/area/volume/ on the ISS
22:45:48 <tgeeky_> also, "a" is for algebra (not applicative!), "i" is for idiom ("id" is for the Id idiomo)
22:46:57 <nand`> Functor functor => (cat -> functor dog) ...
22:47:16 <tgeeky_> my prelude renames Functor to just F
22:47:21 <shachaf> danil: I think something like "blah (Mu x) = x unFix"
22:47:26 <tgeeky_> F f => (cat -> f dog)
22:47:44 <shachaf> Not that that makes any sense.
22:48:14 <nand`> M m => a -> m a
22:48:44 <danil> shachaf: hmm, yeah, that does it
22:49:07 <mysticc> Anybody can point me to integration of hlint in haskell-mode in emacs ..
22:49:58 <edwardk> tgeeky_: heh well, my scala code just passes around functors as objects and uses their apply method. F(f) to transform functions ;)
22:50:21 <edwardk> tgeeky_: this is mostly a sop to how bad the inference is on implicits, but still ;)
22:50:52 <dmwit> ?wn sop
22:50:53 <lambdabot> *** "sop" wn "WordNet (r) 3.0 (2006)"
22:50:53 <lambdabot> sop
22:50:53 <lambdabot>     n 1: piece of solid food for dipping in a liquid [syn: {sop},
22:50:53 <lambdabot>          {sops}]
22:50:53 <lambdabot>     2: a concession given to mollify or placate; "the offer was a
22:50:55 <lambdabot> [13 @more lines]
22:52:35 <bill_> > pl lookup
22:52:36 <lambdabot>   Not in scope: `pl'
22:53:17 <tgeeky_> dmwit: urbandictionary: SOP - standard operating procedure
22:53:42 <dmwit> Definition two from ?wn seems more likely.
22:53:58 <dmwit> s/more likely/pretty appropriate, too/
22:54:21 <dmwit> ...sorry, the keys are like, right next to each other
22:55:11 <tgeeky_> dmwit: oh, I guess my brain didn't appreciate the def since it was partially cutoff, or something.
22:55:13 <callen> about to test hpaste.el, apologies ahead of time.
22:55:44 <callen> hrm.
22:55:46 <callen> or not.
22:58:31 <tgeeky_> I'm really surprised I've never seen this before: http://en.wikipedia.org/wiki/Tupper%27s_self-referential_formula
23:04:13 <zzing_> tgeeky_, awesome formula!
23:04:15 <callen> does anybody here use hpaste.el with Emacs?
23:05:08 <illusionoflife> @run 2+2
23:05:09 <lambdabot>   4
23:05:14 <illusionoflife> @run 2+
23:05:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:05:22 <illusionoflife> @run (+2)
23:05:23 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:05:23 <lambdabot>    arising from a use of `...
23:05:38 <illusionoflife> @run IO "Hello"
23:05:39 <lambdabot>   Not in scope: data constructor `IO'
23:06:00 <illusionoflife> @run return . return
23:06:02 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> m (m1 a))
23:06:02 <lambdabot>    arising from a u...
23:06:13 <illusionoflife> @type (fix Just)
23:06:14 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
23:06:15 <lambdabot>       Expected type: a
23:06:15 <lambdabot>       Inferred type: Maybe a
23:06:28 <illusionoflife> @type putStrLn
23:06:30 <lambdabot> String -> IO ()
23:06:42 <illusionoflife> @type  eval
23:06:43 <lambdabot> Not in scope: `eval'
23:06:47 <illusionoflife> @help
23:06:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:06:52 <illusionoflife> @list
23:06:52 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:07:48 <tgeeky_> illusionoflife: you can play with her in private chat
23:10:32 <illusionoflife> tgeeky_ how?
23:10:46 <shachaf> illusionoflife: /query lambdabot
23:11:39 <zzing_> two bugs in clckwrks ;-(. Love the thing though.
23:18:41 <Okasu_> Cale: why did you commented out Url module?
23:18:56 <Okasu_> Cale: in lambdabot
23:22:43 <Okasu_> Cale: is there some security reason or just some personal preferncies?
23:25:36 <zzing_> Now a good debugging question - I have this multimodule cms written basically by another. It seems to have an issue displaying some large files — how might I track down the problem?
23:33:06 <Twey> zzing_: What sort of an issue?
23:34:04 <zzing_> Twey, as near as I figure it, with clckwkrs (happstack based cms) if the page content (not the theme stuff) is roughly over 9170 bytes in length, it will start a connection but nothing will ever happen. Under that, the page returns just fine and dandy.
23:34:51 <zzing_> I don't see any logging implemented either
23:35:02 <zzing_> This thing is also running with runhaskell
23:37:28 <Twey> Hrm
