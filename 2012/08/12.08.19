00:00:29 <Jafet> Heh, who came up with( (!!1)<$>).transpose
00:01:02 <EvanR> mm_freak: just tab completing every letter in ghci, i arrived at the conclusion IOError
00:01:05 <EvanR> er
00:01:06 <EvanR> IOException
00:02:09 <Hail_Spacecake> why does the case X of syntax use "->"?
00:02:19 <Hail_Spacecake> that doesn't seem to have any relation to the <- you use when doing IO
00:02:26 <Jafet> It doesn't
00:02:49 <Hail_Spacecake> also is -> a language primitive, or is it actually a function or something?
00:02:58 <Ralith> that depends on the context
00:03:00 <Jafet> It is part of case and lambda syntax
00:03:10 <Jafet> It is also the type operator for functions
00:03:29 <Hail_Spacecake> are those functions related, or do they just coincide because "->" looks like an arrow
00:03:30 <Hail_Spacecake> ?
00:03:32 <EvanR> -> isnt a function
00:03:44 <Jafet> They're probably coincidental
00:03:58 <EvanR> > let (-->) = (+) in 2 (-->) 2
00:04:00 <lambdabot>   2
00:04:08 <EvanR> > let (->) = (+) in 2 (->) 2
00:04:10 <lambdabot>   <no location info>: parse error on input `->'
00:04:18 <EvanR> > let (-->) = (+) in 2 --> 2
00:04:19 <lambdabot>   4
00:04:49 <Jafet> (->) is the magical function type
00:05:11 <Hail_Spacecake> magical?
00:06:01 <Jafet> You can't define a type (or anything else) named (->)
00:06:52 <Hail_Spacecake> well you can't define a type Int, can you?
00:06:54 <nus> "Functions are an abstract type: no constructors directly create functional values."
00:07:13 <Hail_Spacecake> oh huh I guess you can overwrite Int
00:07:36 <Jafet> Sure you can
00:07:42 <Jafet> data Int =
00:08:31 <ddarius> Incidentally, in Hagino's CPL, you can define functions.
00:09:26 <Ralith> Hail_Spacecake: shadow.
00:17:52 <nand`> Hail_Spacecake: you could define Int if you really, really wanted to (theoretically, at any rate - the syntax wouldn't let you)
00:18:13 <Jafet> Why not
00:18:19 <nand`> data Int = -9223372036854775808, -9223372036854775807, -9223372036854775806 ... 9223372036854775806, 9223372036854775807
00:18:35 <Jafet> data Int = Int Integer
00:18:52 <Jafet> Integer, however, is magical
00:19:14 <Hail_Spacecake> is there a way to write a custom version of to/fromEnum that's specific to my custom Enum type?
00:19:14 <Hail_Spacecake> so I don't have to type toEnum :: myType every time?
00:19:15 <nand`> (One of Integer's constructors in turn contains an Int, mind)
00:19:26 <nand`> Hail_Spacecake: yes
00:19:27 <donri> data Integer = Zero | Pred Integer | Succ Integer
00:19:30 <donri> magic!
00:19:40 <nand`> fromMyType :: MyType -> Int; fromMyType = fromEnum
00:25:55 <Jafet> @where+ pi_10 (!!1)<$>transpose[show$sum[10^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[1..]]
00:25:57 <lambdabot> I will never forget.
00:27:01 <donri> everything looks like perl without whitespace
00:30:09 <Ralith> single-letter variables help
00:30:28 <Ralith> as does naming things with symbols
00:30:41 <shachaf> > (!!1)<$>transpose[show$sum[10^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[1..]]
00:30:44 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
00:30:46 <shachaf> Jafet++
00:30:56 <shachaf> @tell edwardk 00:25 <Jafet> @where+ pi_10 (!!1)<$>transpose[show$sum[10^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[1..]]
00:30:56 <lambdabot> Consider it noted.
00:31:37 * shachaf wonders why that code doesn't evaluate in ghci.
00:31:38 <Jafet> Well, that was a trivial change
00:32:11 <shachaf> Oh, because I have TH turned on.
00:33:51 * shachaf wonders why that was 100 in the first place.
00:34:04 <shachaf> I vaguely recall there being a 10^ in there...
00:34:16 <shachaf> Who knows.
00:35:08 <hpaste> Ben pasted “parsing Number” at http://hpaste.org/73384
00:36:47 <boothead> can anyone take a quick look at an attoparsec parser - i seem to have a huge chunk of memory attributed to the Char8.Number type: http://hpaste.org/73384
00:36:59 <boothead> am i doing something heinous here?
00:37:27 <Jafet> > (!!2)<$>transpose[show$sum$(10^2^n`div`)<$>1:scanl1(*)[1..2^n]|n<-[0..]]
00:37:29 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
00:37:49 <shachaf> @where e_10
00:37:49 <lambdabot> let(p,q)%d=p*d`div`q;w(p,q)i=(p*i+1,q*i);(x:y:s)^d|y%d>x%d=s^d|0<1=mod(x%d)10:s^(10*d)in 2:scanl w(1,1)[1..]^10>>=show
00:37:57 <shachaf> > let(p,q)%d=p*d`div`q;w(p,q)i=(p*i+1,q*i);(x:y:s)^d|y%d>x%d=s^d|0<1=mod(x%d)10:s^(10*d)in 2:scanl w(1,1)[1..]^10>>=show
00:37:59 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
00:38:09 <shachaf> Hah, Jafet++
00:38:17 <Jafet> Same transformation really
00:38:22 <shachaf> Right.
00:38:27 <Jafet> Power series are awesome
00:38:29 <shachaf> @tell edwardk 00:37 <Jafet> > (!!2)<$>transpose[show$sum$(10^2^n`div`)<$>1:scanl1(*)[1..2^n]|n<-[0..]]
00:38:29 <lambdabot> Consider it noted.
00:38:50 <bartavelle> there is something I fail to understand entirely. The implementation of the Maybe monad seems clear to me, but I don't know why runState is ran twice in the binding operation of the State monad
00:39:16 <shachaf> bartavelle: "runState" doesn't do anything. It's just a getter.
00:39:35 <shachaf> bartavelle: My advice is to disregard the implementation -- you shouldn't even have looked at it -- and write the instance yourself, from scratch.
00:39:41 <shachaf> The first step is to figure out what it does.
00:40:11 <bartavelle> I looked at the implementation because I just figured I had no clue how I would do this
00:40:18 <donri> boothead: hm is that code actually working
00:40:27 <shachaf> @where+ e_10 (!!2)<$>transpose[show$sum$(10^2^n`div`)<$>1:scanl1(*)[1..2^n]|n<-[0..]]
00:40:27 <lambdabot> It is stored.
00:40:45 <shachaf> bartavelle: Well, think about the types. :-)
00:40:58 <boothead> ha - it's that bad huh?! yes it's working as far as I can see
00:40:59 <shachaf> bartavelle: If you have no clue how you would write it, you have no hope of understanding someone else's implementation.
00:41:04 <bartavelle> Also I do not understand where runState is defined in the source file :)
00:41:04 <shachaf> You have to know what it does first.
00:41:13 <boothead> what's wrong with it donri?
00:41:17 <shachaf> bartavelle: OK, then I suggest you back up a bunch.
00:41:33 <shachaf> data State s a = State (s -> (s,a))
00:41:46 <shachaf> runState :: State s a -> s -> (s,a); runState (State f) = f
00:41:54 <shachaf> Proceed from there. :-)
00:42:02 <bartavelle> let's try
00:42:12 <Jafet> @where+ e_10 (!!2)<$>transpose[show$sum$scanl div(10^2^n)[1..2^n]|n<-[0..]]
00:42:20 <lambdabot> Good to know.
00:43:13 <shachaf> @tell edwardk And more -- see @where
00:43:14 <lambdabot> Consider it noted.
00:43:30 <donri> boothead: i don't think you'd normally use number and take together like that
00:43:51 <Jafet> I like this one, it looks really simple.
00:44:00 <donri> boothead: rather let number consume the input itself
00:44:56 <donri> boothead: if the number has a fixed width maybe not use the number parser (in that case the number is more like a string than a number)
00:46:18 <boothead> how would you express take the next n digits and give me a number? i.e. I have 054323411111 and I want a Double and and Integer?
00:46:44 <boothead> i did have read . C.unpack <$> P8.take n before
00:47:03 <boothead> which actually seems to be more performant
00:47:13 <donri> also Char8 is kinda evil and String kinda inefficient
00:47:59 <boothead> you're the second person that has said that Char8 is evil... Why is that?
00:48:27 <shachaf> Jafet: By the way, we have a shorter version of pi_10 which is slow enough that lambdabot can't actually evaluate it.
00:48:30 <shachaf> @where pi_11
00:48:31 <lambdabot> [show(sum[(8-i.&.3*4)*div(10^2^n)(a^i*i)|i<-[1,3..3^n],a<-[2,3]])!!n|n<-[0..]]
00:49:36 <shachaf> Probably the same trick could be used for e but it hardly matters when it's that slow.
00:49:37 <donri> boothead: maybe you want, replicateM n digit
00:50:26 <donri> boothead: that should be a String of n chars and fail if the input isn't digits
00:50:40 <boothead> hmmm... yes that sounds usefull!
00:50:41 <Jafet> Char8 is like a secretary that, when she finds a document that she doesn't know how to read, she throws it into the fireplace.
00:51:11 <boothead> what should I be using Jafet?
00:51:23 <Jafet> shachaf: who came up with map(!!n).transpose?
00:51:45 <Jafet> boothead: Data.Text.Encoding
00:52:11 <donri> boothead: Text if the data is textual, bytestring if it's binary
00:52:11 <boothead> it's not actually Text that I'm reading it's a binary file
00:52:26 <shachaf> Jafet: dmwit, I think.
00:52:41 <Jafet> @karma+ dmwit
00:52:42 <lambdabot> dmwit's karma raised to 36.
00:52:43 <shachaf> It's rather clever -- a good deal shorter than what he had there before.
00:54:26 <pharaun> is there any nicer way of doing this -> http://hpaste.org/73385
00:54:28 <boothead> I had naively assumed that Data.Attoparsec.Char8 was dealing with Bytestrings (due to Data.ByteString.Char8). Is that not the case?
00:54:44 <pharaun> i'm trying to make my options type safe before i marshals it into a string to send it over the network
00:54:55 <donri> boothead: it does, but pretends that binary data is textual, and that unicode is ascii
00:55:26 <boothead> gulp
00:56:02 <pharaun> a very bad thing :)
00:57:10 <donri> although would be nice to have an ascii literal or QQ that errors at compile-time...
00:57:40 <donri> it's not for nothing that people use/invent Char8 apis
01:00:57 <pharaun> i'm honestly wondering if there is a good way other than giant table of pattern matching for transforming typesafe expr into string for... sending/storing on disk
01:01:28 <donri> pharaun: easy way: Show/Read, good way: binary/cereal
01:02:10 <pharaun> donri: i have a couple of odd ones like Bool -> 0/1 :\
01:02:19 <pharaun> donri: i'll take a look at binary/cereal
01:02:36 <donri> > fromEnum True
01:02:38 <lambdabot>   1
01:03:06 <donri> pharaun: cloud haskell does closure serialization, duno how reusable
01:03:11 <pharaun> ah
01:03:12 <donri> @hackage distributed-process
01:03:12 <lambdabot> http://hackage.haskell.org/package/distributed-process
01:03:26 <pharaun> i sadly don't control the remote end
01:03:45 <pharaun> so i have to match the output/string format exactly, and some of the string is icky like "enc" - Encode
01:03:58 <donri> pharaun: attoparsec?
01:04:10 <nobdraisentone> How can I run Haskell programm in a background?
01:04:14 <nobdraisentone> Without a &
01:04:24 <donri> @hoogle daemonize
01:04:24 <lambdabot> package direct-daemonize
01:04:25 <lambdabot> package hdaemonize
01:04:25 <pharaun> donri: i already have parsec for the inbound data :)
01:04:34 <pharaun> donri: alright i'll poke around thanks
01:04:59 <donri> nobdraisentone: how about http://hackage.haskell.org/packages/archive/hdaemonize/0.4.4.1/doc/html/System-Posix-Daemonize.html
01:06:11 <paolino> Hello. Is it possible to force garbage collection from code ?
01:06:27 <nobdraisentone> donri: nice, thanks
01:07:05 <shachaf> paolino: GHC has performGC
01:07:09 <paolino> or at least hint it
01:07:22 <shachaf> Are you sure you want it?
01:09:02 <paolino> shachaf, I'm not sure it's gc fault but my sequencer is not enough regular
01:09:35 <paolino> I cannot find docs for performGC
01:09:40 <paolino> which module ?
01:09:46 <shachaf> @google performGC docs haskell
01:09:47 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem.html
01:09:47 <lambdabot> Title: System.Mem
01:10:48 <paolino> oh it's in base
01:10:59 <paolino> not specific to ghc
01:15:35 <EvanR> how do i get the compiler to tell me about incomplete case patterns
01:15:39 <da-x> Can someone point to an example where quasiquotation is used as a map/filter over a haskell code, rather than parsing  some completely other syntax? In my case I'd like to do replacement on the token level.
01:18:57 <donri> EvanR: -Wall does it, and it's probably -fwarn-incomplete-patterns
01:19:05 <donri> it's not an error without -We
01:19:25 <donri> -Werror
01:22:27 <bindy> Hi guys, please I need a little help. How can I feed (n (m a)) as an argument to (a -> n (m a)) where (Functor m, Applicative m, Monad m, Monad n, MonadIO n, Functor n, Applicative n)?
01:23:32 <nobdraisentone> const (n (m a))?
01:23:44 <shachaf> nobdraisentone: What?
01:23:55 <bindy> no, function that returns n (m a)
01:23:57 <shachaf> If you're giving people useless advice, at least make it sort-check.
01:24:31 <shachaf> @ty (>>=)
01:24:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:25:06 <shachaf> I guess you'll need to do it yourself.
01:25:14 <shachaf> I'm not sure what you're doing. Are you sure you're supposed to be doing that?
01:25:46 <LambdaDusk> wow if someone had asked me that more often...
01:26:29 <bindy> shachaf: i have no idea :) I'm trying to use Hedis transactions and apparently the individual commands return RedisTx (Queued a)
01:27:10 <bindy> shachaf: and I haven't found any example how to use result of one command in another in the transaction
01:27:13 <donri> y u no use acid-state
01:27:24 <shachaf> donri: Oh, come on, are you serious?
01:27:44 <bindy> donri: cause I need to connect to redis?
01:27:53 <donri> ook
01:28:41 <shachaf> @ty multiExec
01:28:43 <lambdabot> Not in scope: `multiExec'
01:28:52 <shachaf> Anyway look at all the functions you have available.
01:29:06 <bindy> multiExec :: RedisTx (Queued a) -> Redis (TxResult a)
01:30:02 <bindy> shachaf: I did but I haven't figured it out. The author points out that the Queued being instance of Monad, Applicative and Function solves everyting...
01:30:20 <bindy> *Functor
01:30:25 <shachaf> There's an example of using multiExec in the documentation.
01:31:05 <bindy> shachaf: yes, but they have two independent results. I need to use result of the first command as an argument to the other
01:31:29 <shachaf> Huh?
01:31:33 <shachaf> Look at the example.
01:31:41 <shachaf> --          hello <- get \"hello\"
01:32:18 <bindy> yeah, imagine you need to do: set \"world\" hello
01:34:16 <shachaf> You need to use "watch" for that, apparently.
01:35:30 <shachaf> Look at the Redis documentation: http://redis.io/topics/transactions
01:35:36 <bindy> whah, you mean I am trying to do something that might not even be possible in redis?
01:35:44 <shachaf> This doesn't seem to have to do with Haskell.
01:35:45 <bindy> that might explain my troubles :)
01:35:51 <shachaf> No, it's possible.
01:35:56 <shachaf> Did you read the documentation on transactions?
01:36:37 <bindy> briefly, thank you for pointing me in a new direction, I am going to read it carefully!
01:37:35 <shachaf> I admit the documentation is a bit unclear.
01:38:32 <bindy> No, it's my fault, I thought I understood Redis too well and was blaming Hedis instead. Thanks again, mate, you really helped to unstuck me :)
01:39:36 <yitz> shachaf++
01:55:09 <paolino> anyone succeded in using ghc rts for soft real time ?
02:13:22 <Pav> I am a beast
02:40:52 <k0ral> hello
02:42:34 <k0ral> is there a way to write a generic f :: <n parameters> -> (<n parameters> -> a) -> a, forall n ?
02:45:23 <MostAwesomeDude> I would not think so.
02:45:31 <MostAwesomeDude> But then again, what do I know?
02:46:57 <shachaf> k0ral: You shouldn't want to.
02:47:12 <shachaf> Maybe you can use some dirty tricks to do it. But please don't.
02:47:21 <k0ral> shachaf: I guessed that, but let me explain you why I've come to need it
02:47:33 <shachaf> You don't need it.
02:47:49 <k0ral> sigh, let me explain why I *thought* I needed it
02:48:10 <k0ral> I'm using monad-control to lift IO () -> IO () to m () -> m ()
02:48:45 <k0ral> now I would like to lift callback -> IO () to <callback lifted to m) -> m ()
02:48:57 <k0ral> callback is <n parameters> -> IO ()
02:49:36 <k0ral> currently, I'm creating f1, f2, ..., fn for each n
02:49:59 <k0ral> f1 :: (a -> m ()) -> (a -> m ())
02:50:25 <k0ral> sorry, f1 :: (a -> m ()) -> m ()
02:50:46 <k0ral> fn :: (a1 -> ... -> an -> m ()) -> m ()
02:51:05 <k0ral> just wanted to know whether there was a nicer way to do this
02:54:30 <dmwit> Well, that's a different question, isn't it?
02:55:22 <dmwit> Also, I don't believe you yet.
02:55:27 <dmwit> Those types look very suspicious.
03:02:48 <shachaf> dmwit: Compliments from Jafet on the map(!!n).transpose thing.
03:03:14 <k0ral> dmwit: talking to me ?
03:03:42 <Hail_Spacecake> I'd like to create a date ADT that limits the range of numbers from 1-31
03:03:42 <Hail_Spacecake> is there a way to do this with a data constructor?
03:04:17 <MostAwesomeDude> Hail_Spacecake: If you're willing to type a fair amount, there *is* the Bounded typeclass.
03:04:31 <shachaf> Not unless you want to data Foo = One | Two | Three | Four | ...
03:04:45 <shachaf> A smart constructor would probably be simpler.
03:04:52 <Hail_Spacecake> shachaf, what's a smart constructor?
03:05:15 <shachaf> I.e. data Day = Day Int; mkDay d | d < 0 || d > 31 = Nothing | otherwise = Just (Day d)
03:05:20 <shachaf> And then don't export Day itself.
03:05:31 <shachaf> Hail_Spacecake: Keep in mind that your Date type has further invariants to keep track of, though.
03:05:51 <shachaf> (Date 2012 Feb 31) should be invalid even though 31 is valid.
03:05:55 <shachaf> s/0/1/
03:06:28 <Hail_Spacecake> shachaf, yeah, but I guess if I don't export the data constructor I can have my own Date-returning functions that apply whatever restrictions I wan
03:06:39 <Hail_Spacecake> t
03:10:35 * hackagebot sqlite-simple 0.1.0.1 - Mid-Level SQLite client library (JanneHellsten)
03:11:49 <Hail_Spacecake> so, I just read that in haskell the module namespace is flat
03:11:58 <Hail_Spacecake> so does that mean when I have a module like System.IO
03:12:08 <Hail_Spacecake> that's just a single module that happens to have a period in the name?
03:12:34 <donri> Hail_Spacecake: yep
03:12:54 <donri> although the source files are usually ordered in directory trees
03:13:16 <Hail_Spacecake> that would be sensible
03:13:18 <donri> but System doesn't get you System.IO unless there's an actual System module that re-exports System.IO
03:13:33 <Hail_Spacecake> although that does raise the question of how you distinguish between module names with .
03:13:39 <Hail_Spacecake> and qualified names
03:13:51 <Hail_Spacecake> since . is apparently part of the lexical syntax for qualified names
03:13:56 <donri> and any package can expose modules with any name, under any parents
03:14:16 <Hail_Spacecake> I could have some package System that exports a qualified name IO
03:14:18 <donri> not sure what you're asking now
03:14:21 <Hail_Spacecake> and another package named System.IO
03:14:25 <donri> ah
03:14:26 <Hail_Spacecake> and they need not have anything to do with each other
03:14:31 <Hail_Spacecake> if I'm understanding this right
03:14:49 <donri> don't really know what ghc/haskell does there, but there's always a risk of name conflicts
03:15:13 <daniel_-> when doing ``exitSuccess`` in a thread it prints to stdout appname: ExitSuccess, is there any way to supress?
03:15:21 <donri> you can rename imported modules though
03:15:25 <donri> import qualified System as Sys
03:15:37 <donri> import qualified System.IO
03:15:43 <donri> now you have Sys.IO and System.IO
03:18:17 <shachaf> donri: Not really.
03:18:33 <donri> not what
03:18:40 <shachaf> Hail_Spacecake: There's no ambiguity. "Foo.Bar.Baz" is a module whose name is "Foo.Bar" and a constructor/type "Baz".
03:19:14 <shachaf> Everything to the left of the rightmost . is just part of the module name.
03:19:37 <shachaf> There are no "hierarchical modules" except that when GHC looks for a module, it looks in a file with the same name but with .s converted to /s.
03:19:40 <Hail_Spacecake> but can't haskell names contain . ?
03:19:53 <shachaf> Only operators.
03:20:06 <donri> > Just.Just.Right $ a
03:20:08 <lambdabot>   Not in scope: data constructor `Just.Just.Right'
03:20:14 <shachaf> And those can't have text before the .
03:20:26 <shachaf> Data.Bits..&. -- module is "Data.Bits", operator is ".&."
03:20:26 <Hail_Spacecake> ah
03:21:02 <donri> > Just . Just . Right $ a
03:21:04 <lambdabot>   Just (Just (Right a))
03:23:19 <Jafet> > zipWith(!!)[show$sum[div(4*100^n)(a^i*i)*(2-i.&.3)|i<-[1,3..4*n],a<-[2,3]]|n<-[3..]][0..]
03:23:23 <lambdabot>   mueval-core: Time limit exceeded
03:23:42 <Jafet> > take 80 $ zipWith(!!)[show$sum[div(4*100^n)(a^i*i)*(2-i.&.3)|i<-[1,3..4*n],a<-[2,3]]|n<-[3..]][0..]
03:23:44 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
03:27:20 <hiptobecubic> yuck
03:31:37 <efie> loading a file into ghci works, but when I execute a function I get "Killed" - what does this say about the error which occured?
03:32:36 <Jafet> Is it an executioner?
03:33:55 <efie> Jafet: Not that I know of
03:34:10 <efie> :)
03:34:21 <Jafet> ghci is not known to kill things
03:39:06 <dmwit> k0ral: I was talking to you, yeah.
03:42:57 <k0ral> dmwit: sorry then: which types do you find suspicious ?
03:43:11 <k0ral> I'm using gtk2hs and I want to bind callbacks to signals
03:43:22 <k0ral> signals are defined as Signal object callback
03:43:34 <k0ral> callback can be anything
03:43:46 <k0ral> I want to lift the 'on' function from glib
03:44:02 <k0ral> on :: object -> Signal object callback -> callback -> IO (ConnectId object)
03:45:22 <dmwit> Alright, I'm with you so far.
03:45:57 <k0ral> I wrote:  onM object signal f = control $ \runInIO -> on object signal (runInIO f)
03:46:10 <k0ral> then: onM1 object signal f = control $ \runInIO -> on object signal (\a -> runInIO $ f a)
03:46:12 <k0ral> etc
03:46:24 <k0ral> for each number of arguments callback may take
03:47:02 <k0ral> my question was: is there a nicer way to do this, with a single function for example ?
03:48:35 <dmwit> Yes, I expect so.
03:49:27 <dmwit> It should be as easy as making a class with instances for IO and (->) e.
03:49:53 <k0ral> I'm not familiar with using (->) e things
03:50:05 <k0ral> do you have a resource explaining them ?
03:50:42 <dmwit> What do you want explained?
03:51:00 * hackagebot PortFusion 1.2.1 - high-performance distributed reverse / forward proxy & tunneling for TCP (CetinSert)
03:51:04 <dmwit> (->) is just the function type constructor...
03:51:25 <galbi> ciao
03:51:27 <galbi> !list
03:51:35 <dmwit> Howdy galbi.
03:51:45 <dmwit> Perhaps you're looking for
03:51:46 <dmwit> ?help
03:51:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:53:32 <k0ral> alright, (->) e is a function type constructor that take an object of type e as first argument
03:54:32 <dmwit> right
03:55:21 <k0ral> then I could write onM object signal ((->) e f), and onM object signal ((->) e ((->) f))
03:56:08 <k0ral> dmwit: I need a little practice to get confortable with it, but I think I got your point
03:56:19 <k0ral> dmwit: thank you
04:37:52 <yogsototh> Dear Haskeller, how could I create NominalDiffTime? More precisely, how could I create a NominalDiffTime of 1 minute?
04:38:18 <mikeplus64> is there a comand line typechecker floating around? (something like :t in ghci, but standalone)
04:38:48 <yogsototh> I don't see this in this doc: http://www.haskell.org/ghc/docs/7.0.2/html/libraries/time-1.2.0.3/Data-Time-Clock.html
04:40:51 <yogsototh> mikeplus64: you might want to look at ghc-mod works for vim and emacs, you certainly can find a way to make a command line typechecker
04:41:03 <yogsototh> mikeplus64: https://github.com/eagletmt/ghcmod-vim
04:41:13 <mikeplus64> yeah, i'm just wondering if someone has done something like mueval
04:41:16 <mikeplus64> for types only
04:41:43 <mikeplus64> with time limits and all that jazz (i managed to get hint to loop indefinitely before :()
04:50:44 <paolino> yogsototh, diffUTCTime (fromIntegral 0) (fromIntegral 60)
04:50:56 <paolino> maybe
04:52:40 <paolino> oh no, it's nominal that is a Num
04:53:05 <paolino> @type fromIntegral 60 :: NominalDiffTime
04:53:07 <lambdabot>     Not in scope: type constructor or class `NominalDiffTime'
04:56:18 <beaky> how do I compile haskell programs with debugging symbols suitable for gdb?
04:58:43 <paolino> is there a combination of fmap return and lift to go   t m a -> t r (m a) ?
05:01:48 <latro`a> at value level that's m (t a) -> r (t (m a)) right?
05:02:31 <paolino> mh, dosn't seem like
05:02:49 <latro`a> if it is then I don't think that's gonna work; where do you get an m a in the first place
05:03:14 <latro`a> I guess using m's return you can get an m a
05:03:30 <paolino> it's ReaderT r IO () -> ReaderT r STM (IO ())
05:03:58 <latro`a> well then the fact that it's m a seems less important
05:04:50 <yogsototh> paolino: thanks!
05:05:29 <paolino> yogsototh, always look at the instances when you don't see obviuos things
05:06:52 <paolino> which is a good reason to abandon a library sometimes for sub-culture, but that is haskell :-)
05:06:55 <yogsototh> paolino, I saw it was a Num I don't really know I didn't thought immediately about fromIntegral. Thanks again!
05:09:39 <paolino> latro`a, I can put a return just inside the function and it compiles, so it's more a curiosity than a need
05:17:13 <paolino> ask >>= lift . print :: ReaderT Int IO ()
05:17:33 <paolino> ask >>= lift . return . print :: ReaderT Int STM (IO ())
05:25:01 <mm_freak> you know what i really dislike in haskell-mode?  that it highlights the module name in qualified names differently, and does so inconsistently (`V.!`)
05:25:14 <mm_freak> i'd prefer it to highlight the whole qualified name using a single style
05:26:11 <mikeplus64> @pl \x y -> [x, y]
05:26:12 <lambdabot> (. return) . (:)
05:26:20 <hpc> yeah, not seeing it in my vim highlighting
05:26:41 <Yiq> when i do <tab> my code is indented 4 steps isntead of 2, why? what mode should i use?
05:26:42 <hpc> it highlights the module name the same as the operator in the module
05:26:57 <mm_freak> Yiq: which editor?
05:27:04 <mm_freak> hpc: yeah, that's sensible
05:27:19 <mm_freak> the distinction there makes code actually less readable
05:27:27 <mm_freak> at least if you're using a lot of qualified names
05:27:29 <hpc> there's really only one odd thing about it, and that's that after the first '.', subsequent ones look like (.)
05:27:36 <hpc> to the vim highlighter
05:27:57 <hpc> but that's fairly minor
05:28:06 <mm_freak> that's probably because your highlighter assumes a flat module name space
05:28:17 <hpc> possible, it's the debian default
05:28:51 <paolino> about fmap, fmap (subtract 1) ((+2).(*3)) == (+2) . (subtract 1) . (*3) ?
05:29:10 <hpc> Yiq: mostly tangental to your question, but you should also make sure your tab key inserts spaces, and not tab characters
05:29:20 <hpc> GHC sets tab stops to 8
05:41:19 <paolino> well I thought (fmap (fmap (subtract 1)) ((+2).(*3)) == (+2) . (*3). (subtract 1)  , but it's not typechecking. How to achieve this ?
05:49:40 <latro`a> uh
05:49:46 <efie> could someone help me with this problem? http://hpaste.org/73390
05:50:06 <latro`a> (.) ((.) (subtract 1)) ((+2).(*3))
05:50:10 <latro`a> so
05:50:27 <latro`a> ((.) (subtract 1)) . ((+2).(*3))
05:50:40 <latro`a> so now when you pass in an argument
05:50:42 <latro`a> you get a number
05:50:50 <latro`a> and then you're trying to make that number the second arg to (.)
05:50:52 <latro`a> which breaks
05:51:08 <identity> Does parsec not have some .. easy type(on the eyes) to use when explicitly specifying type signatures so I can get my code to typecheck?
05:51:17 <identity> Like the old parsec -- it was just Parser
05:51:38 <identity> p :: Parser Char; p = oneOf "abc"
05:51:38 <identity> etc
05:51:50 <latro`a> efie--you can't map overa  tuple
05:51:57 <latro`a> *over a
05:52:03 <latro`a> oh wait nvm
05:52:04 <latro`a> misread
05:52:36 <latro`a> the map you're consing is a list
05:52:39 <latro`a> did you mean ++?
05:52:43 <efie> oh
05:52:48 <efie> yes.. thanks
05:53:24 <latro`a> that's also pretty much what the error message says :p
05:53:41 <latro`a> : wants its left side to be (String,String,Int), map gives a list
05:55:22 <identity> Anyone? @ parsec question
05:55:24 <efie> latro`a: yes, you are right, that's a bit embarrassing
05:55:25 <paolino> latro`a, thanks I spent too much time in trying to insert that "return" after the lift in ask >>= lift . return . print
05:55:38 <identity> What should a parser's type signature look like if it returns a Char?
05:55:50 <identity> (when you explicitly specify the type)
05:56:25 <latro`a> also, efie, what you're doing is actually a map itself
05:57:04 <latro`a> ah wait, no it isn't
05:57:09 <latro`a> you're using the head to work with the rest
05:58:22 <latro`a> hmm...f (x:xs) = map (\y -> g x xs) : f xs
05:58:24 <Twey> efie: You should start by reshaping your data into something more suitable for your problem
05:58:32 <latro`a> I'm surprised that's not already some recursion pattern
05:58:37 <latro`a> but yes, I'd refactor the data structure a bit
05:58:55 <Twey> @let calcDist :: [(String, Int)] -> [(String, Int)] -> Int; calcDist x y = undefined
05:58:55 <latro`a> @pl f (x:xs) = map (\y -> g x xs) : f xs
05:58:57 <lambdabot>  Defined.
05:58:57 <lambdabot> f = fix ((`ap` tail) . (. head) . flip (ap . (((:) . map . const) .) . g))
05:59:01 <latro`a> bah
05:59:25 <Twey> :t \inp -> map (\((name_a, info_a), (name_b, info_b)) -> (name_a, name_b, calcDist info_a info_b)) [(a, b) | a <- inp, b <- inp]
05:59:26 <lambdabot> forall t. [(t, [(String, Int)])] -> [(t, t, Int)]
05:59:32 <Twey> efie: ^ that's your function
05:59:49 <Twey> efie: The types would be a lot more readable if you used some type synonyms
05:59:54 <paolino> identity, Parsec = ParsecT Char () Identity ?
06:00:39 <Twey> efie: But basically, what you've got is a map over the Cartesian product of your items.  As soon as you hear ‘I want to ___ every element with every other element’, you should be thinking Cartesian products.  From there it's just a map to get the individual items into the form you want.
06:01:05 <Twey> (you can filter out the (x, x) pairs later, if you want)
06:01:53 <identity> paolino: I hoogle'd my way to it -- it seems there are 'aliases' for it in Text.Parsec.String/ByteString etc
06:02:04 <Twey> efie: [ (x, y) | x <- xs, y <- ys ] is the Cartesian product of xs and ys, of course
06:02:08 <identity> otherwise it seems that: Parsec String () resultType will work
06:02:11 <identity> but thanks :)
06:04:17 <latro`a> I'd probably write what twey wrote as just a comprehension
06:04:36 <Twey> Oh, yeah, that's probably a better idea.  Ha.
06:05:06 <latro`a> :t \inp -> [(name_a,name_b,calcDist info_a,info_b) | (name_a,info_a) <- inp, (name_b,info_b) <- inp]
06:05:07 <lambdabot> forall t. [(t, [(String, Int)])] -> [(t, t, [(String, Int)] -> Int, [(String, Int)])]
06:05:22 <latro`a> feh
06:05:29 <latro`a> doesn't know what type inp is
06:05:31 <Twey> allDistsMember inp = [ (name_a, name_b, calcDist info_a info_b) | (name_a, info_a) <- inp, (name_b, info_b) <- inp ]
06:05:31 <latro`a> silly lambdabot
06:05:41 <Twey> latro`a: That's fine
06:05:43 <latro`a> oh nvm
06:05:49 <latro`a> I have an extraneous comma
06:05:50 <Twey> (and better to specifying a concrete type)
06:05:55 <latro`a> :t \inp -> [(name_a,name_b,calcDist info_a info_b) | (name_a,info_a) <- inp, (name_b,info_b) <- inp]
06:05:57 <lambdabot> forall t. [(t, [(String, Int)])] -> [(t, t, Int)]
06:05:58 <Twey> s/to/than/
06:05:59 <latro`a> there we go
06:06:13 <Twey> latro`a: Yes, but I did it a while back ;)
06:06:25 <latro`a> true
06:06:34 <Twey> Also, ick at the lack of spacing all over the place here.
06:06:44 <latro`a> indeed
06:06:47 <latro`a> but then
06:06:50 <latro`a> ick at tuples in general
06:06:58 <Twey> Mm, especially triples
06:12:25 <Yiq> http://testpersta.appspot.com/Outdoortemperature #Final version of my first webapp ever. Does it look to you(yes it it amateurish but its my first one), no errors in?
06:13:39 <identity> Yiq: pretty cool
06:15:18 <Twey> Yiq: Ithinkit's Kindoffunny Howyourun Allthewordstogether
06:15:31 <Twey> Yiq: Where's the Haskell?
06:18:09 <Yiq> twey, in swedish wed do that but yeah in english you dont
06:18:32 <Yiq> i should change that
06:20:54 <kuribas> @pl \x -> runSP x $ runSecond f
06:20:54 <lambdabot> ($ runSecond f) . runSP
06:35:32 <davidsarah> hello everyone
06:35:38 <Botje> halo
06:35:47 <davidsarah> I'm reading the paper "Lazy Functional State Threads" (research.microsoft.com/en.../lazy-functional-state-threads.ps.Z)
06:35:57 <davidsarah> wrong url, just a sec
06:36:47 <davidsarah> http://research.microsoft.com/en-us/um/people/simonpj/papers/lazy-functional-state-threads.ps.Z
06:37:16 <davidsarah> it says "Complete referential transparency is maintained"...
06:38:10 <davidsarah> but in section 7.1, there is an eqMutVar operation to compare STRefs
06:38:44 <davidsarah> and its type is outside the ST monad (although it can only compare refs from the same state thread)
06:39:13 <davidsarah> (the type is eqMutVar :: MutVar s a -> MutVar s a -> Bool)
06:39:45 <davidsarah> how is this referentially transparent, given that identical calls to newVar will give different references?
06:40:30 <davidsarah> (that are observably different outside the ST monad)
06:43:07 <geekosaur> davidsarah, the references themselves are not observably different outside of ST because they cannot be typed outside of ST and so don't exist outside of ST
06:43:56 <davidsarah> ah, that makes sense
06:44:46 <davidsarah> because newVar :: a -> ST s (MutVar s a)
06:44:49 <davidsarah> ok, got it
06:45:09 <geekosaur> the values within them could get out; at some point you need to provide your own proof you aren't using ST internals to do somehtingnon-referentialy transparent
06:45:39 <davidsarah> I thought the type system prevented that?
06:46:10 <davidsarah> can you give an example of a program that uses ST internals non-referentially-transparently
06:46:12 <davidsarah> ?
06:50:41 <Saizan> davidsarah: referential trasparency is about equals, newVar () is not the same as the reference you get out of it, they don't even have the same type
06:51:04 <hpaste> kuribas pasted “comonadic state” at http://hpaste.org/73391
06:52:31 <Saizan> davidsarah: and, btw, you can get references out of ST and compare them, and this is still fine, you can even compare IORef's in pure code
06:53:14 <davidsarah> now I'm confused again
06:54:02 <kuribas> I managed to make a comonadic datatype for my program, and supporting comonadic state.
06:54:29 * davidsarah experiments with ghci
06:54:43 <kuribas> It would be nice if runSP was a variadic function, using typeclass magic, but I am not sure I can implement it...
06:54:50 <Saizan> to get references out you need an existential wrapper btw
06:55:45 <edwardk> runSP?
06:55:45 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
06:56:07 <kuribas> edwardk: SP = StreamPointer
06:56:15 <kuribas> edwardk: It's a sort of zipper structure.
06:56:58 <kuribas> Naming functions is not my strongest skill.
06:57:55 <edwardk> > (!!1)<$>transpose[show$sum[10^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[1..]]
06:57:58 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
06:58:05 <edwardk> oh nice, the [1..] helped
06:58:17 <edwardk> Jafet++
06:58:55 <ion> edwardk: What’s the name of that method?
06:59:05 <edwardk> pi_10
06:59:14 <ion> I mean, something i can google. :-)
06:59:15 <edwardk> @where pi_10
06:59:16 <lambdabot> (!!1)<$>transpose[show$sum[10^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[1..]]
06:59:20 <edwardk> nothing
06:59:27 <edwardk> its something i golfed back and forth with shachaf here
06:59:41 <davidsarah> (14:54:29) Saizan: to get references out you need an existential wrapper btw
06:59:43 <ion> Did you begin with some method with a known name?
06:59:48 <edwardk> i have an long procession of it losing digits
06:59:56 <davidsarah> Saizen: can you explain a bit more?
07:00:12 <edwardk> i can dig up a less mangled form perhaps
07:00:16 <edwardk> @where pi_11
07:00:16 <ion> Also, what does the “10” stand for?
07:00:17 <lambdabot> [show(sum[div(4*100^n)(a^i*i)*(2-i.&.3)|i<-take(2*n+1)[1,3..],a<-[2,3]])!!n|n<-[0..]]
07:00:20 <edwardk> base 10
07:00:33 <edwardk> pi_11 is shorter by almost maximally slow ;)
07:01:17 <edwardk> er shorter but almost
07:02:00 <edwardk> pi_10 is currently 'the shortest encoding of the digits of pi that doesn't need any funny libraries or imports that runs within lambdabot's timeout window
07:02:14 <edwardk> (and which can generate an arbitrary number of digits
07:02:17 <ion> heh
07:02:28 <Saizan> davidsarah: e.g. data Refs a = forall s. Refs [STRef s a]; runST (do xs <- replicateM 2 (newSTRef ()); return (Refs xs)) :: Refs ()
07:02:52 <edwardk> the transpose in there was an ingenious addition of dmwit iirc
07:03:03 <edwardk> saved us half a dozen characters
07:03:24 <edwardk> jafet's change saved us a character. it used to be > (!!1)<$>transpose[show$sum[100^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
07:03:35 <Saizan> davidsarah: you need {-# LANGUAGE ExistentialQuantification #-} to define that type
07:04:18 <hpc> edwardk: you can replace transpose with sequence, i think
07:04:28 <hpc> > (length "transpose", length "sequence")
07:04:30 <lambdabot>   (9,8)
07:04:47 <edwardk> > (!!1)<$>sequence[show$sum[100^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
07:04:51 <lambdabot>   mueval-core: Time limit exceeded
07:04:57 <hpc> maybe not...
07:05:13 <edwardk> > (!!1)<$>sequence[show$sum[10^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[1..]]
07:05:17 <lambdabot>   mueval-core: Time limit exceeded
07:05:20 <hpc> perhaps the way sequence is using monadic commands instead of being defined directly does it
07:05:29 <hpc> because i am fairly sure that for finite lists, sequence = transpose
07:05:40 <hpc> > sequence [[1, 2], [3, 4]]
07:05:41 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
07:05:49 <hpc> oh, damn
07:05:57 * hpc falls on his sword
07:06:19 <edwardk> sok
07:06:23 <hpc> :P
07:06:33 <Saizan> sequence on ziplists maybe
07:06:36 <edwardk> yeah
07:06:41 <edwardk> that works
07:06:48 <edwardk> thats how i define it in lens
07:07:21 <hpc> Saizan: ziplists aren't a monad though
07:07:34 <edwardk> transposeOf l = getZipList . l ZipList
07:07:45 <Saizan> ?type sequenceA
07:07:46 <lambdabot> Not in scope: `sequenceA'
07:07:48 <edwardk> hpc: sequenceA
07:07:51 <hpc> oh right
07:08:12 <hpc> that's the same length as transpose though, plus you have to wrap things up
07:08:17 <edwardk> of course the A costs a character ;)
07:08:20 <edwardk> yeah
07:08:28 <hpc> still neat
07:08:45 <hpc> i should see what kind of hijinks i can get up to with ziplists
07:09:16 <edwardk> now that 7.6 has decent polykinds i can finally release a library of indexed monad transformers!
07:09:24 <hpc> yaaaaaaaay!
07:09:40 * hpc is mostly happy because he actually knows what that means
07:09:55 <edwardk> i couldn't compose indexed transformers before
07:10:07 <edwardk> because you couldn't define return
07:10:08 <davidsarah> Saizan: thanks
07:10:20 <edwardk> i could make indexed binds that i could compose, but not the indexed returns
07:10:51 <hpc> what ended up preventing GHC from making it work?
07:13:15 <ion> Is that an (indexed monad) transformer or an indexed (monad transformer)? In either case, what does that mean? :-)
07:14:04 <hpc> ion: an indexed monad transformer is a regular transformer, i think
07:14:09 <hpc> er
07:14:13 <hpc> (indexed monad) transformer
07:15:33 <latro`a> hpc: zip non-empty lists make a monad
07:15:36 <latro`a> albeit a boring one
07:15:41 <edwardk> an indexed monad transformer in the sense that it takes an indexed monad to an indexed monad in an indexed way. so both the base and the transformer have separate indexes combined via a data kind
07:15:54 <latro`a> using join = map head
07:16:12 <latro`a> (I was surprised that this works, but I checked it the other day)
07:16:23 <hpc> huh
07:16:49 <hpc> actually, that might not be so boring, if you look at what bind does
07:16:51 <edwardk> well, the problem before was the same thing that kept you from building product categories before 7.4
07:17:16 <edwardk> latro`a: join = map head should violate the monad laws, check again
07:17:24 <edwardk> you have to take the diagonal
07:17:36 <edwardk> or the associativity of bind breaks
07:17:39 <latro`a> uh
07:17:45 <latro`a> diagonal, huh
07:17:54 <sentientwaffle> i ran 'cabal install hlint' but the binary doesn't seem to be in my $PATH.. do i need to add it somewhere manually
07:17:54 <latro`a> I checked some cases with the associativity of bind
07:17:57 <edwardk> that does't work when the shape can change though
07:18:01 <latro`a> but now you're enforcing streams, no?
07:18:06 <latro`a> eh
07:18:11 <latro`a> streams or square arrays
07:18:16 <edwardk> you can only use the diagonalization monad when the lists have a fixed length
07:18:22 <latro`a> or arrays with more columns than rows
07:18:28 <shapr> edwardk: Got a moment to "git clone https://github.com/shapr/ghclive.git && cd ghclive && cabal install" and give any feedback?
07:18:31 <hpc> edwardk: is this in the agda stdlib somewhere?
07:18:44 <hpc> because that would be an awesome record to have around for Vec
07:18:45 <edwardk> shapr: sure
07:18:47 <latro`a> that's weird though, because I checked a fair number of cases
07:18:55 <edwardk> hpc: should be
07:19:08 <edwardk> shapr: let me get set up here for a sec
07:19:09 <latro`a> not a proof, didn't feel like muddling through a proof
07:19:20 <shapr> edwardk: Will probably take some minutes to build
07:20:02 <latro`a> though join as fmap is probably a problem, now that I think about it
07:20:13 <latro`a> erm, join as definable using fmap
07:23:22 <edwardk> latro`a thats because its broken ;)
07:25:55 <edwardk> latro`a:
07:25:55 <edwardk> @check let j = map head in \as -> j (map j as) == j (j as)
07:25:57 <lambdabot>   "*Exception: Prelude.head: empty list
07:26:04 <edwardk> thats the first problem ;)
07:27:00 <hpaste> kuribas annotated “comonadic state” with “comonadic state (new version)” at http://hpaste.org/73391#a73392
07:27:33 <latro`a> edwardk: I was enforcing nonempty to begin with
07:27:44 <kuribas> Hm, the comonadic state doesn't quite work... "runStateSP [1, 2, 3, 4] $ \s x -> (1, 0)" loops
07:27:46 <latro`a> (at data level)
07:30:08 <edwardk> latro`a: its still broken. i've tried this one before
07:30:30 <latro`a> mmk
07:31:53 <latro`a> incidentally, is there a general way to check whether an Ix is within a bounds?
07:32:17 <latro`a> I don't really need one, but I have this for a 2D case
07:32:25 <latro`a> withinBounds arr (i,j) = i >= mini && j >= minj && i <= maxi && j <= maxj
07:32:25 <latro`a> where ((mini,minj),(maxi,maxj)) = bounds arr
07:32:54 <latro`a> seems like this should be doable with just Ix
07:33:10 <edwardk> use >>= return
07:33:12 <latro`a> it is *not* doable with Ord, however, because the lexicographic order lets you go off to the right
07:33:15 <edwardk> what happens?
07:33:31 <geekosaur> davidsarah, sorry, was busy (family stuff).  http://www.haskell.org/haskellwiki/Monad/ST has a good overview of ST's use as a non-refrentially-transparent mechanism fo rproducing referentially transparent results
07:33:33 <edwardk> its something like that
07:33:42 <edwardk> its probably not the associativity law that breaks
07:34:01 <geekosaur> which is what I was trying to get at; mutable variables are one way in which you can do this
07:34:02 <latro`a> I tested the return laws iirc
07:34:39 <latro`a> >>= return appears to still be id
07:34:57 <otters> of course it is
07:35:02 <latro`a> eh
07:35:08 <latro`a> for this probably-not-a-monad
07:35:13 <dmwit> :t inRange
07:35:13 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
07:35:15 <dmwit> latro`a:
07:35:17 <latro`a> oh
07:35:19 <latro`a> huh
07:35:25 <latro`a> @src inRange
07:35:26 <lambdabot> Source not found. That's something I cannot allow to happen.
07:35:28 <latro`a> :|
07:35:49 <latro`a> thanks though
07:36:05 <dmwit> It's a member of the Ix typeclass.
07:36:14 <otters> @hoogle inRange
07:36:15 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
07:37:11 <latro`a> it only goes up to 5D :(
07:37:20 <latro`a> oh wait nvm
07:37:25 <latro`a> it'll derive correctly for nD apparently
07:40:56 <edwardk> latro`a: http://zenzike.com/posts/2010-10-21-streams-and-monad-laws
07:42:55 <latro`a> gah, it's not transitivity :|
07:44:52 <edwardk> latro`a: return 1 >>= (\x -> [x,x+1])  -- is the problem
07:45:04 <latro`a> ah
07:45:19 <edwardk> return a >>= f != f a
07:46:01 <edwardk> figures its the last law i checked ;)
07:46:23 <dmwit> It's not usually the one that fails.
07:46:59 <latro`a> important one, though
07:47:05 <latro`a> more important than >>= return = id imo
07:47:30 <latro`a> at least for how we use monads normally
07:48:24 <edwardk> i think they both matter quite a bit =)
07:48:48 <latro`a> sure
07:49:03 <edwardk> >>= return is critical to make sure fmap matches liftM
07:49:07 <latro`a> that's true
07:49:26 <latro`a> but it matters less in larger blocks
07:50:14 <latro`a> return x >>= f = f x makes it so that when you pass a monad chain that ends in return to a new chain, you basically just link the chains together
07:50:25 <latro`a> (handwaving like mad here, but you get the point I hope)
07:52:06 <edwardk> shapr: it installed, now what?
07:54:57 <shapr> edwardk: Now you need to run ghclive from the source directory (haven't got it locating its cache dir by itself yet) and point your browser to localhost:3000
07:57:03 <edwardk> no instance of Display for Integer ;)
07:57:35 <shapr> yah, it doesn't do type default yet, I'm working on that. :-/
07:58:17 <luite> shapr: nah that isn't the problem
07:58:23 <shapr> oh?
07:58:26 <luite> there just isn't an instance for Integer :)
07:58:32 <edwardk> got it to load a short script and print something
07:58:33 <edwardk> yeah
07:58:36 <luite> will be fixed once you add the Show a => Display a instance
07:58:48 <edwardk> luite: that instance makes me twitch
07:58:56 * dmwit too
07:58:58 <luite> hehe it should :)
07:59:22 <edwardk> because it means that nobody else can ever reliably define an instance of Display other than what you put in that module
08:00:25 <edwardk> another option would be to add a default signature for the display method in Display
08:00:40 <osa1> is there a way to make this code work: `testFun a = (a 10, a "ok")`  ?
08:00:52 <edwardk> so what can i display that isn't boring test?
08:00:53 <edwardk> er text?
08:01:30 <luite> oh that's worse than i thought, i thought OverlappingInstances would be enough here and ghc could always resolve the most specific instance
08:01:35 <shapr> edwardk: renderDia SVG (SVGOptions "output.file" (Dims 200 200)) (circle 1 # fc red # lw 0 ||| circle 1 # fc green # lw 0 :: Diagram Diagrams.Backend.SVG.SVG R2)
08:01:40 <hpc> osa1: Rank2Types
08:01:52 <edwardk> luite: nope
08:02:12 <hpc> testFun :: (forall a. whatever -> whatever) -> (something, something)
08:02:14 <edwardk> luite: basically if you define a bit overarching overlapping instance you're screwed for adding any other instances in other modules (reliably)
08:02:29 <edwardk> if on the other hand you defined
08:03:15 <hpc> > let test :: (forall a. Show a => a -> String) -> (String, String); test a = (a 10, a "ok") in test (\x -> show x ++ "!!")
08:03:18 <lambdabot>   ("10!!","\"ok\"!!")
08:03:38 <hpc> > let test :: (forall a. Show a => a -> String) -> (String, String); test a = (a 10, a True) in test (\x -> show x ++ "!!") -- probably a bit more clear
08:03:40 <edwardk> class Display a where display :: * -> String; default display :: Show a => a -> String; display = show
08:03:40 <lambdabot>   ("10!!","True!!")
08:03:44 <edwardk> or something like that
08:03:54 <edwardk> then you can just have to put instances in
08:03:58 <edwardk> instance Display Integer
08:03:58 <hpc> osa1: ^
08:04:05 <edwardk> with no body and you get what you want for most cases
08:04:17 <shapr> hm, looks nice
08:04:57 <osa1> wow, thanks
08:05:53 <hpc> make sure you add {-# LANGUAGE Rank2Types #-} to the top of your file
08:06:09 <shapr> hpc: he's gone
08:06:19 <latro`a> wait, what is this default shenanigans
08:07:03 <hpc> i think the new hackage IP has had long enough to spread through DNS
08:07:07 <hpc> and can be dropped from the topic
08:07:09 <edwardk> latro`a: DefaultSignatures
08:07:30 <latro`a> does that do any ugly things like FlexibleInstances and friends?
08:08:02 <edwardk> no
08:08:08 <edwardk> this is just like its writing code for you
08:08:08 <latro`a> cool
08:08:17 <shapr> edwardk: That * doesn't parse, do I need to add a pragma?
08:08:26 <latro`a> does the implementation go through TH?
08:08:27 <edwardk> er sorry a -> String
08:08:38 <edwardk> miranda flashback i guess ;)
08:08:42 <edwardk> latro`a: no
08:08:50 <shapr> Now it doesn't like that default ...
08:08:53 <latro`a> huh, k
08:09:12 * shapr reads about typeclasses and default methods
08:09:13 <edwardk> where is the Display class defined?
08:09:23 <edwardk> you need to enable DefaultSignatures
08:09:33 <shapr> It's in Display.hs
08:09:35 --- mode: ChanServ set +o monochrom
08:09:42 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
08:09:47 --- mode: monochrom set -o monochrom
08:10:02 <edwardk> k, one sec. i'll patch
08:10:04 <shapr> edwardk: src/Network/Web/GHCLive/Display.hs
08:12:09 <EvanR> need help with acid state. how can i combine writer with update events
08:12:26 <EvanR> seems like template haskell will confuse things
08:13:08 <EvanR> using writer to substitute for doing IO output during the update (which i think i cant do?)
08:15:31 <gautamc> hi, new to haskell here. I am looking for ghci's equivalent of erlang's code:get_path(). (The ghci manual talks of a search_path, but I still search for its name)
08:18:21 <edwardk> shapr: pull request sent
08:18:38 <edwardk> i'm kinda tempted to rip apart the instances you have for Display entirely to go to something more Show like
08:18:54 <shapr> feel free
08:18:58 <edwardk> with a separate displayList method, so you can remove the need for flexible string instances
08:20:06 <luite> dispayList could also nicely display a list of diagrams like mgsloan had in his diagrams ghci thing :)
08:20:11 <edwardk> yep
08:20:41 <edwardk> so what is the instance instance Display [(Html,Html)] where display d = display $ mconcat $ Prelude.map toHtml d  -- used for?
08:20:51 <luite> i think they're not used anymore
08:21:07 <edwardk> good, that was a big blocker to fixing the display instances
08:21:26 <edwardk> i need to drop my sister-in-law off at the airport or with a friend or something, bbiab
08:21:37 <shapr> k
08:28:20 <EvanR> well i combined writer with update just fine... now to make acidic...
08:30:35 <EvanR> it worked o_O
08:38:34 <Yiq> How much traffic is streaming a webcam?
08:38:42 <merijn> gautamc: What does code:get_path() do?
08:47:10 <gautamc> code:get_path() returns an strings. Each string is a file system path that erlang search for to locate module to load
08:52:15 <edwardk> shapr: hrmm, its fairly awkward to fix up the displays for lists because of the rather incestuous relationship between Display and ToMarkup
08:52:24 <shapr> blow it away?
08:54:36 <luite> edwardk: the ToMarkup instances can go imho
08:54:55 <edwardk> luite: hop over to #ghclive
09:05:13 * hackagebot rdf4h 0.9.1 - A library for RDF processing in Haskell (RobStewart)
09:05:22 <ben> Can I implement seq in haskell?
09:05:27 <davidsarah> geekosaur: yes, my question was answered and I also understand why your existential quantification example works. thanks again
09:06:27 <Yiq> How would you people graph rain/no rain over a day?
09:08:03 <latro`a> ben--I'm fairly sure seq is actually primitive
09:08:11 <ben> Looks like it
09:08:23 <ben> I can never quite remember whether bangpatterns are part of the language or not
09:09:02 <latro`a> I think they desugar to seq anyway
09:09:12 <ben> yeah
09:09:15 <ben> looks like it
09:10:06 <typoclass> Yiq: display numbers from 0 to 24 written in blue or black?
09:10:47 <Yiq> typoclass, just like : 0 1 2 3 ... 24; and then either blur or black?
09:10:54 <Yiq> im using a graph now and it looks a bit silly
09:11:04 <Yiq> http://perstaweatherstation.appspot.com/Rain
09:12:45 <typoclass> yiq: you're right, a line graph is probably not the clearest for "on/off" data
09:13:06 <mapreduce> Wow.  What does -1 mean, the seas boiling?
09:14:02 <latro`a> you can basically do a local average
09:14:05 <byorgey> Yiq: maybe a blue square when there's rain, and nothing for no rain
09:14:07 <latro`a> instead of on/off
09:14:13 <byorgey> Yiq: silly to have a vertical axis of course =)
09:14:28 <mapreduce> Yiq: I'd go for a coloured bar with a different colour (or nothing) for periods of no rain.
09:14:51 <sellout42> Yiq: Tufte’s sparklines has a good visualization for binary data.
09:14:56 <latro`a> like, time of the last x minutes in which there was rain
09:14:57 <latro`a> or such
09:15:02 <sellout42> Especially if you have like 2-3 binary dimensions.
09:15:14 <mapreduce> Although as a Brit I'd need too many categories for rain, on-off doesn't begin to cover it.
09:15:21 * hackagebot snaplet-sqlite-simple 0.1.0 - sqlite-simple snaplet for the Snap Framework (JanneHellsten)
09:15:24 <mapreduce> (luckily living abroad so that's from memory)
09:27:58 <ch33sus_> is there a basic abs math function?
09:28:13 <ch33sus_> within the standard library
09:28:39 <typoclass> > abs (-7) -- ch33sus_
09:28:40 <lambdabot>   7
09:29:06 <ch33sus_> huh i forgot the brackets
09:29:22 <ch33sus_> and more advanced vector stuff?
09:29:31 <ch33sus_> like angle between vectors?
09:29:49 <chrisdone> shutting down hpaste for a few minutes…
09:30:24 <chrisdone> upgrading ma specs
09:30:28 <mapreduce> > tan 3
09:30:29 <lambdabot>   -0.1425465430742778
09:30:34 * hackagebot tagsoup 0.12.7 - Parsing and extracting information from (possibly malformed) HTML/XML documents (NeilMitchell)
09:30:38 <ch33sus_> naaah
09:30:40 <latro`a> I think he means inner products and so no
09:30:42 <latro`a> *on
09:30:48 <latro`a> but that depends on the vector data structure
09:30:54 <ch33sus_> yea
09:31:04 <hpc> ch33sus_: check out vector-space
09:31:13 <hpc> on hackage
09:31:51 <Yiq> How much traffic is streaming a webcam? Would it be to hard for haskell to use it to implement a webcam chat?
09:32:41 <chrisdone> nah, i've implemented video support with a kinect, it's fast enough to deal with webcams
09:32:44 <cods> I feel dumb. How can I write the following more concisely?  doesFileExist filename >>= \r -> unless r (error "File is missing")
09:33:49 <otters> flip unless (error "File is missing")
09:33:53 <otters> then you could eliminate r and \r ->
09:35:20 <cods> otters: perfect! thanks
09:41:46 <mk> is it possible to build on the trivial monad in any significant way whatsoever, without as a first step turning it into the identity monad?
09:44:25 <ch33sus_> is there a option to use degrees with trigonometry functions or do i have to do conversion on my own?
09:44:39 <byorgey> ch33sus_: you have to do conversion.
09:44:55 <ch33sus_> hrmpf
09:45:00 <latro`a> it'd be a little awkward to do the conversion anyway
09:45:03 <byorgey> mk: I don't understand your question.
09:45:15 <byorgey> mk: what is the trivial monad, and how is it different from the identity monad?
09:45:17 <latro`a> as you'd be either setting some global parameter or else adding an argument to the trig functions
09:45:24 <byorgey> mk: and what do you mean by "build on"?
09:45:31 <ch33sus_> like deg_cos
09:45:32 <mk> does any monad exist, except for trivial, where there is only a single monadic value?
09:45:35 <ch33sus_> i thought
09:45:45 <ch33sus_> alternative function names
09:45:47 <latro`a> or another function, yeah
09:45:49 <latro`a> that would work too
09:46:00 <ch33sus_> lazy library architects :D
09:46:00 <latro`a> gets a bit crufty, though
09:46:23 <mk> byorgey: the trivial monad manages to satisfy the laws but has only a single value (per type). Identity has a monadic value per "non-monadic" value.
09:46:47 <byorgey> mk: the trivial monad being  data Trivial a = Trivial  ?
09:47:50 <mk> byorgey: yes. One might imagine that it returns nil. When you "mash together" identity and trivial, you get maybe
09:48:52 <byorgey> mk: ok. well, to answer one of your questions, if a monad has only a single value per type, then it is isomorphic to Trivial.  So no, there are no others.
09:49:18 <ch33sus_> anyone knows what ctrl + s does in vim?
09:49:27 <otters> heh
09:49:31 <otters> tried to save?
09:49:43 <ch33sus_> :D
09:49:45 <ch33sus_> reflex
09:49:48 <Saizan> would the grammer be ambiguous if we allowed variables named "let"?
09:49:51 <ch33sus_> it freezed
09:49:59 <mk> ch33sus_: try #vim
09:50:00 <otters> yes
09:50:01 <byorgey> ch33sus_: it probably paused the terminal, try hitting Ctrl + q
09:50:16 <ch33sus_> wow thx
09:50:19 <ch33sus_> yeah using putty
09:50:38 <byorgey> (that's not specific to vim by the way)
09:52:13 <mk> byorgey: the questions are the same. Some articles suggest that monads are "built" upon trivial by adding features to trivial. So I'm wondering if a feature might be added without first adding "maps to not-a-single-value"
09:53:22 <ch33sus_> not in scope arccos
09:53:23 <ch33sus_> wtf
09:53:23 <hughfdjackson> nand`: you mentioned the other day that haskell reifies IO specifications via the IO monad
09:53:29 <ch33sus_> >arc_cos
09:53:40 <ch33sus_> > :t arc_cos
09:53:42 <lambdabot>   <no location info>: parse error on input `:'
09:53:52 <ReinH> current status: rereading ALL of the typeopedia
09:54:00 <hughfdjackson> just to make sure i have my understanding of reification on point; would you say that lisp macros work on the basis of receiving reified lisp code?
09:54:06 <ch33sus_> so whats the arcuscosinus function?
09:54:06 <hughfdjackson> :3 i think i'm on point, just want to be 100%
09:54:13 <ReinH> *typeclassopedia
09:54:28 <mk> byorgey: to what extent isomorphic? I understand that they would both have just one monadic value, but are there any implications for order of execution, etc.?
09:54:45 <byorgey> mk: order of execution doesn't matter if there is only one value.
09:54:48 <ch33sus_> > acos (pi)
09:54:50 <lambdabot>   NaN
09:54:55 <ch33sus_> ha
09:55:14 <byorgey> mk: also, I have never seen an article suggesting that monads are built up by adding features to the trivial monad.  Can you give an example?
09:55:23 <byorgey> mk: certainly you can build up by adding monad transformers to Identity
09:56:00 <otters> > acos pi
09:56:01 * hackagebot dbus-qq 0.1.0 - Quasi-quoter for DBus functions (PaoloCapriotti)
09:56:01 <lambdabot>   NaN
09:56:06 <mk> byorgey: it might matter for side-effects, no? Suppose I implement a trivial such that its bind always skips the given function, and another that always calls the function
09:56:29 <byorgey> mk: calls it with what input?
09:56:30 <ReinH> mk: wouldn't that violate the monad laws?
09:57:26 <byorgey> I think if you want to satisfy the monad laws even with respect to _|_, then there is only one valid way to implement it.
09:57:36 <mk> ReinH: which part? It probably wouldn't, since due to the single-valueness, bind can infer that any given function must return nil (the single monadic value), and thereby satisfy law 1
09:58:33 <mk> so it has the option of not calling the function at all, and just returning nil. But it also has the option of calling the function, having it return nil as predicted, and then returning the nil
09:58:40 <ch33sus_> lol
09:58:42 <ReinH> mk: what does "skips the given function" mean?
09:58:45 <ch33sus_> > :q
09:58:47 <lambdabot>   <no location info>: parse error on input `:'
09:58:48 <ReinH> treats it as id?
09:59:00 <ch33sus_> > :t  (*)
09:59:02 <lambdabot>   <no location info>: parse error on input `:'
09:59:07 <ch33sus_> wtf
09:59:08 <ddarius> mk: All the passed in function can do (ignoring bottom) is return the single value anyway, so those are the same.
09:59:16 <ReinH> ch33sus_: no type for you
09:59:24 <ch33sus_> nope
09:59:29 <ch33sus_> types are all gone
09:59:41 <ch33sus_> sold out
09:59:43 <ddarius> Ignoring bottom, the only possibility for m >>= f is the single value.  How it goes about getting that value makes no difference.
09:59:48 <mk> ReinH: bind takes a monadic function, and a pure value. In any monad except trivial, bind *must* call the function with the original value corresponding to pv
10:00:05 <ddarius> At any rate, it couldn't call f because it won't actually have an a to pass to it.
10:00:28 <latro`a> hm, I wonder, is there a monad with nontrivial join but trivial fmap?
10:00:47 <latro`a> ah nvm, that couldn't be
10:01:06 <latro`a> trivial fmap forces the type itself to be trivial, since you need x to be both m a and m b at once
10:01:13 <ReinH> mk: right, left identity, how does "trivial" get around that restriction?
10:01:58 <latro`a> rather, you need *every* x to be that
10:02:01 <latro`a> obviously, say, Nothing is that
10:02:11 <ddarius> If there is only one value of type M a for all a, then all the laws immediately hold.
10:02:33 <ddarius> Of course, since all the monad operations return an M a, they all are constant functions.
10:02:53 <latro`a> hrm, are we talking about
10:02:57 <latro`a> data Trivial a = Trivial
10:02:59 <latro`a> or
10:03:06 <latro`a> ah wait, no has to be that, derp
10:03:10 <latro`a> need a parameter to have a monad
10:03:13 <mk> ddarius: right, since the only monadic value that it can receive is nil. If we can assume that bind can't choose an arbitrary v for the given type, it looks like trivial *must* skip calling f...
10:03:13 * latro`a shuts up
10:04:25 <k0ral> hello
10:04:39 <mk> I suspect that trivial is (secretly) not a monad
10:04:49 <latro`a> how not
10:04:56 <ddarius> Ignoring bottom, it can't not be a monad.
10:05:12 <latro`a> and if you use seq adequately
10:05:13 <ddarius> Including bottom, you have to be careful, but you can simply make data Trivial a; and that will be a monad.
10:05:20 <latro`a> it still is a monad
10:05:21 <latro`a> I think
10:05:43 <mk> latro`a: because the laws imply very consistent things with respect to all the other monads; not so when it comes to trivial, which gets a free pass on many restrictions
10:05:47 <ddarius> latro`a: You have more options then, and not all of them are right.
10:06:23 <ddarius> mk: All it has to do is satisfy the laws.  If it satisfies the laws its a monad.
10:06:27 <mk> latro`a: according to all definitions, it is a monad. What I think I'm saying is that we should add a 4th law, stating "Trivial is not a monad"
10:06:32 <latro`a> lol
10:06:35 <latro`a> cute
10:06:48 <latro`a> also inconsistent
10:06:53 <ddarius> mk: Well, in Moggi's original Notions of Computation, he required return to be a monomorphism which it is not for Trivial.
10:06:53 <byorgey> why on earth would you want to do that?
10:06:53 <ReinH> mk: so your trivial monad is just Nothing?
10:06:56 <k0ral> when instanciating this: MonadState [m ()] m, I get an infinite type
10:07:09 <ReinH> (not Just Nothing, ofc)
10:07:11 * BMeph scoffs grumpily
10:07:18 <ddarius> So, Trivial is not a "notion of computation" a la Moggi, though I believe he later dropped that restriction.
10:07:21 <latro`a> (this is analogous to making a collection of sets and then saying that some of them aren't sets)
10:07:26 <k0ral> how would you fix this ?
10:07:27 <latro`a> (which is why naive set theory can't be patched up)
10:07:38 <byorgey> k0ral: can you paste the entire error message please?
10:07:50 <mk> ddarius: sure, but the laws have a purpose, they impose certain restrictions, and they ensure that monads have certain properties. But trivial gets a free pass on just about all the useful properties
10:08:21 <ReinH> mk: many laws give rise to trivial or degenerate cases
10:08:34 <k0ral> byorgey: alright, I was simplifying so the error message will be somewhat different from what I've exposed
10:08:43 <ReinH> I'm not sure what value there is in adding new law that effectively says "useless monads are not monads"
10:08:53 <ReinH> isn't it enough for them to be categorized as "useless monads"? :p
10:08:59 <byorgey> k0ral: that is exactly why I want to see the actual error message =P
10:09:18 <latro`a> I'd say it's not so much that it bypasses the useful properties as that it has too many properties
10:09:23 <latro`a> including all the useful properties
10:09:33 <ddarius> ReinH: The addition restriction I mentioned would already rule out Trivial (and I think just Trivial in Haskell.)
10:09:37 <k0ral> https://gist.github.com/3396319
10:09:42 <k0ral> byorgey: ^
10:09:48 <n00b6502> do lenses help batching up mutations of a record into a single operation
10:09:50 <byorgey> k0ral: looking
10:09:59 <mk> ReinH: I think that Trivial is the *only* degenerate case. For example, all other monads *must* map original values to *distinct* monadic values. They all must, when bind is given a pure monadic value,  call the given f.
10:10:02 <k0ral> byorgey: expecting you to ask for the actual code :)
10:10:08 <ReinH> ddarius: the monomorphism of return?
10:10:16 <ddarius> ReinH: Yes.
10:10:25 <ReinH> I mean, it seems like a reasonable law
10:10:30 <ReinH> it's intuitively correct
10:10:31 <ddarius> mk: Attempting to get rid of degenerate cases is usually a bad idea unless they clearly have -bad- properties.  This is a mistake programmers have been making for decades.
10:10:59 <ReinH> I'm just wondering why we care about the trivial monad
10:11:10 <ReinH> it's not ugly or dangerous, it's just a degenerate case
10:11:27 <ReinH> like a list that can only be empty
10:11:33 <mk> I'm not proposing that the definition be changed, I'm just claiming that it can be changed without any harm, so that I can be corrected if I'm off on this
10:11:39 <ddarius> ReinH: Such as [Void]
10:11:46 <ReinH> exactly
10:11:59 <ReinH> we don't have a special [Void] is invalid law
10:12:05 <ReinH> because it's just a degenerate case that no one cares about
10:12:10 <byorgey> k0ral: is HState a data family?
10:12:16 <ddarius> It's also useful.
10:12:28 <k0ral> byorgey: yes
10:12:28 <mk> ddarius: Trivial is useful?
10:12:43 <k0ral> byorgey: it's made of callback functions of type m ()
10:12:44 <ddarius> No, [Void].  Though Trivial probably could be useful in some cases.
10:12:53 <ReinH> mk: for representing computations that always fail ;)
10:12:54 <byorgey> k0ral: well, it shouldn't be.
10:12:56 <k0ral> that's why I needed to parametrize m over HState
10:13:04 <byorgey> k0ral: seems like it ought to be a type family instead.
10:13:07 <ReinH> ddarius: what is [Void] useful for?
10:13:54 <n00b6502> is Data.Tree a binary tree or a branch with a list of trees
10:14:00 <n00b6502> n-ary tree
10:14:03 <mk> ReinH: that's one way of looking at it - like the nil side of a maybe
10:14:12 <byorgey> k0ral: because of the  MonadState s (StateT s m)  instance, those two occurrences of 's' must match
10:14:13 <ddarius> n00b6502: The latter, a rose tree.
10:14:19 <n00b6502> ok nice
10:14:33 <byorgey> k0ral: in this case it concludes  (HState (StateT (HState m1) (ReaderT Context (ErrorT HError IO))))  =  (HState m1)
10:14:36 <ddarius> data Foo a = Foo { stuff :: Crap, options :: [a] };  Foo Void has no options and this is statically apparent.
10:14:41 <n00b6502> are there custom HOFs for trees
10:14:42 <ddarius> n00b6502: Not really.
10:15:10 <byorgey> k0ral: and since HState is a data family, it is injective, and hence the outer HStates can be stripped off, leaving  (StateT (HState m1) (ReaderT Context (ErrorT HError IO))) = m1
10:15:11 <mk> ReinH: it's a bit off though, because the computations wouldn't fail by virtue of the given monadic functions. It's more like Trivial is for representing computations that we refuse to carry out...
10:15:21 <ReinH> touche
10:15:32 <byorgey> k0ral: but that's not what you want; presumably you want  (HState (StateT (HState m1) (ReaderT Context (ErrorT HError IO))))  to evaluate to  HState m1
10:15:40 <ddarius> For Trivial, one could consider what happens when you apply various monad transformers to it.  At any rate "degenerate" cases are usually valuable for combinators, e.g. id is useless except to pass it to other functions.
10:15:41 <ReinH> mk: we can call this monad Hal
10:15:46 <byorgey> i.e. probably   HState (StateT s m) = s
10:15:51 <ReinH> as in "I'm sorry Dave, I can't do that"
10:15:57 <mk> ReinH: haha
10:16:10 <k0ral> byorgey: kinda see what you mean, but how can I turn data family into a type family
10:16:20 <byorgey> k0ral: but with HState as a data family, it doesn't 'evaluate' to anything, it just creates a completely new type
10:16:35 <mk> ddarius: do any examples come to mind?
10:16:39 <byorgey> k0ral: well, for starters, change the keyword 'data' to 'type'
10:16:49 <byorgey> k0ral: and if there was only one data constructor, remove it
10:17:11 <byorgey> k0ral: if there were multiple data constructors, a more substantial redesign may be required
10:17:29 <k0ral> byorgey: there is only one, but what about "attributes" ?
10:17:36 <byorgey> k0ral: attributes?
10:17:54 <k0ral> byorgey: data X = X { attribute1 :: A, attribute2 :: B }
10:18:12 <k0ral> how is that reproduced in a type family ?
10:18:16 <k0ral> type class ?
10:18:21 <byorgey> oh, well, I suppose you could use a tuple
10:18:26 <byorgey> type X = (A, B)
10:18:29 <ddarius> Trivial seems to behave almost like a right zero to applying monad transformers.
10:18:39 <byorgey> but it depends what you are trying to accomplish.
10:18:56 <byorgey> I suspect you need to more carefully rethink things.
10:19:04 <k0ral> byorgey: it's supposed to be a state, so a "collection" of objects/callbacks I will read/write
10:19:35 <k0ral> byorgey: I would be glad to find a cleaner way to implement this, but ater thinking about it for a while, I didn't
10:19:47 <byorgey> k0ral: Another approach would be to do   data C = C { attribute 1 :: A, attribute2 :: B },  then   type X = C
10:20:03 <k0ral> byorgey: how would you design a "collection" of callbacks, if not through the State monad ?
10:20:31 <ReinH> mk: Trivial is a monad that performs your computation and then throws the results away. (Except that it probably doesn't even do that because of laziness)
10:20:37 <k0ral> byorgey: how dirty is that ? it seems like cheating :)
10:20:42 <byorgey> k0ral: what? why?
10:20:51 <byorgey> k0ral: it seems cleaner to me, actually.
10:21:02 <latro`a> s/probably/definitely
10:21:09 <latro`a> undefined >>= f = undefined, no evaluation :p
10:21:13 <k0ral> byorgey: so type X m = C m ?
10:21:23 <k0ral> byorgey: given that I need to parametrize m, right ?
10:21:25 <byorgey> k0ral: because the point is that not every instance will need/want a completely new type for its state (e.g. the StateT instance)
10:21:27 <latro`a> Trivial >>= f = Trivial, no need to do anything
10:21:34 <byorgey> k0ral: right, probably
10:21:37 <mk> ReinH: nah, because Hal. If bind receives only nil, it can't know what value to call monadic f with, so it must skip f. In other words, it cannot perform the computation, it can only refuse
10:21:43 <ddarius> k0ral: Always eta reduce type synonyms if possible.
10:21:50 <ReinH> mk: true
10:22:14 <latro`a> depends what "the computation" is I guess
10:22:18 <byorgey> ddarius: ah, right, good point
10:22:34 <k0ral> byorgey: let me try this and come back
10:22:36 <mk> latro`a: any computation whatsoever
10:22:59 <byorgey> k0ral: ok, I'm heading off soon, but will be back tomorrow
10:23:10 <k0ral> byorgey: however, still interested in your insights about how to store a collection of callbacks in an "enriched" way (ie not a bare IO)
10:23:56 <latro`a> if a monadic value *is* a computation, then the computation does happen, it's just trivial
10:25:08 <k0ral> byorgey: hmm, how do I instanciate the type you wrote ?
10:25:09 <mk> latro`a: the computation is the monadic function passed to bind
10:25:17 <k0ral> byorgey: since I don't have constructors anymore
10:25:25 <latro`a> that's a way of looking at it I suppose
10:25:37 <latro`a> I think of, say, an IO a as a computation that may depend on IO
10:25:45 <latro`a> or a Maybe a as a computation that may have already failed
10:26:24 <latro`a> I see your perspective, however
10:29:05 <mk> latro`a: right, there are monadic functions (taking a normal value, returning its pure counterpart) that are specific to various monads. But bind must execute those functions to perform the computation, the output of which is a "monadic" value. Trivial can't do the computation in the first place
10:29:59 <latro`a> "execute those functions" is a weird concept to me
10:30:14 <ReinH> mk: so while it respects the typing and the laws, it disregards the semantics
10:30:33 <latro`a> I look at it the other way, the object that performs execution is the new monadic value, which has "encapsulated" the execution specified by the function
10:30:40 <mk> note that in all monads except trivial, bind is *forced* to direct pure values (that is, their non-monadic counterparts) into the monadic function
10:30:50 <ReinH> mk: >> could be defined as _ >> n = n, but it's defined in terms of >>= to ensure that the semantics of computation are honored
10:30:52 <latro`a> for example, the IO b you get from bind does all the IO that the first arg does, then does the IO that the result does
10:31:28 <latro`a> the a->IO b itself is just a relationship, encoding what results in the first arg result in what additional IO behavior
10:31:29 <ReinH> so if we have a monad that by definition does not perform computation...
10:32:03 <ReinH> it may walk and talk like a duck without, in fact, being a duck
10:32:04 <latro`a> again, it's a difference of perspective, but here I think thinking of a function as a computation is deceptive
10:32:30 <mk> latro`a: ok, in that case, "no computation" is called return. But in the trivial monad, even "no computation" (ie return) is not executed
10:32:32 <latro`a> similarly thinking of a monad as a computation may be deceptive in degenerate contexts
10:32:53 <latro`a> this is probably true, yes
10:32:59 <ReinH> s/computation/effects
10:33:04 <ReinH> monadic effects are part of the semantics
10:33:12 <latro`a> but "a non-computation is executed" is sorta contradictory
10:33:26 <latro`a> it's like "who did you pass on the road?" "Nobody" from alice in wonderland
10:34:11 <mk> latro`a: well, return is a "degenerate" case (trivial is beyond degenerate...)
10:35:05 <kuribas> Ok, I finally got the comonadic state right: http://paste.lisp.org/display/131116
10:35:10 <ReinH> mk: unsavory
10:35:23 <mk> it's no more strange than saying that you added something to 1 when you added 0. "But 0 is nothing" - well, perhaps, but I still in fact added 0 to 1
10:35:28 <kuribas> "runStateSP [1, 2, 3, 4] $ \s x -> let s2 = (0 ~< s) + extract x in (s2, s2)" => [1,3,6,10]
10:35:31 <ReinH> or perhaps ignoble
10:36:21 <ReinH> mk: so noop is the monoidal identity of monadic effects?
10:36:58 <ReinH> do thing + do nothing = do this
10:37:02 <ReinH> s/this/thing
10:37:12 <mk> ReinH: it's downright depraved, is what it is
10:37:17 <ReinH> lulz
10:38:04 <ReinH> so that's actuallt interesting.
10:39:03 <ReinH> does imperative programming in some sense form a monoid where zero = noop and dot = interpret?
10:39:11 <merijn> How do I tell cabal to shutup and ignore version constraints?
10:39:22 <c_wraith> merijn: no such flag exists, sadly
10:39:37 <ReinH> mk: puts 'foo' . noop = noop . puts 'foo' and so on
10:39:37 <mk> ReinH: yeah I'm not sure how to think of it. But the point is that Trivial doesn't (can't) even try to do a computation (whatever the status of the computation)
10:39:41 <merijn> cabal-dev demand tar 0.3.* and yesod demands 0.4.* :\
10:39:51 <srhb> merijn: Beat the .cabal files with heavy objects - at least that's what I do.
10:39:58 <ReinH> mk: I know, I'm just thinking about other random stuff now
10:40:11 <mk> ReinH: right
10:40:14 <ReinH> I guess that's how IO works: it assumes that imperative IO is a monoid
10:40:15 <c_wraith> This is why I suspect we're moving towards the ability to update constraints of a package without replacing the package...
10:40:38 <ReinH> and from there constructs a monoid by adding laws
10:40:43 <ReinH> *monad
10:40:44 <c_wraith> ReinH: more of a Kleisli category than a monoid - types matter
10:41:09 <ReinH> c_wraith: right
10:41:34 * hackagebot yesod-markdown 0.4.1 - Tools for using markdown in a yesod application (PatrickBrisbin)
10:41:36 * hackagebot yesod-paginator 0.3.2 - A pagination approach for yesod (PatrickBrisbin)
10:41:44 <monochrom> tar 0.3 looks old and brings in more old libs
10:42:01 <kuribas> Let's say you want to add the numbers to the left and right of a list: "runSP [1, 2, 3, 4] $ \x -> (0 ~< x) + (x ~> 0)" => [2,4,6,3]
10:42:09 <ReinH> c_wraith: which is the monadic version of the monoid laws with return and >=> over some category, right?
10:42:27 <c_wraith> ReinH: yep. (I see you read Tekmo's article. :)
10:42:33 <mk> a Kleisli category is like an asteroid belt, right?
10:42:33 <ReinH> c_wraith: I did?
10:42:40 <c_wraith> merijn: in this case, you could just cheat... cabal-dev is just a binary. build it, then remove its dependencies
10:42:41 <ReinH> actually I didn't
10:42:46 <c_wraith> oh.  then you should
10:42:48 <ReinH> c_wraith: but monoids already enforce closure...
10:42:52 <ReinH> c_wraith: link please?
10:43:04 <c_wraith> http://www.haskellforall.com/2012/08/the-category-design-pattern.html
10:43:09 <ReinH> thanks
10:43:21 * monochrom has a cunning plan, but it breaks. use cabal-dev to sandbox the building of... cabal-dev!
10:43:45 <kuribas> monochrom: It may work with lazyness?
10:43:48 <hpc> monochrom: i actually had a situation where i needed that
10:44:01 <hpc> cabal-dev had dependencies that required recompilation
10:44:01 <monochrom> but actually you can do sandboxing by hand if you know about those -package-db flags
10:44:36 <monochrom> someone should update cabal-dev to depend on newer things (or at least not rejecting newer things)
10:44:52 <ReinH> c_wraith: I guess I was looking at specifically the O of IO as a monoid of the set of operations that produce output
10:45:00 <ddarius> In a simplistic semantics, imperative statements are endofunction State -> State and thus are monoids with nop indeed being the unit and ; (sequential composition) being the multiplication.
10:45:00 <monochrom> which brings us back to the recent version number thread in haskell-cafe
10:45:15 <ReinH> ddarius: yes that's what I was going for :)
10:45:24 <c_wraith> ah.  when there's no input, I suppose that holds
10:45:27 <ReinH> but, you know, with less big math words
10:45:55 <c_wraith> but when the output has dependencies on the input, and you want to track that in the types, it becomes a category
10:46:04 <ReinH> c_wraith: confirm
10:46:08 <ReinH> yay math
10:46:14 <ReinH> and now I get why IO is a monad
10:46:21 <ReinH> (because it's really a category)
10:47:05 <ReinH> and monads give us kleisli composition "for free"
10:47:17 <ReinH> sweet
10:48:26 <ReinH> I'm sort of unsure though why Haskell chose to define monads in terms of bind, etc rather than in terms of kleisli composition
10:48:42 <ReinH> it seems more intuitive that way
10:48:49 <k0ral> byorgey: using type X m = C m, and writing let state = C { callback1 = ..., callback2 = ... }, I'm still getting the infinite type error
10:49:04 <k0ral> but I'm not that surprised since I used the C constructor
10:52:16 <kuribas> What is the performance penalty for using a compositional style?  For example using a state monad instead of list functions (for example scanl).
10:53:05 <n00b6502>  should haskell always work best with the purest representation (gives compiler most information)
10:53:39 <Philippa> n00b6502: there are multiple meanings of 'pure' involved here
10:53:53 <srhb> n00b6502: In any given problem? Depends what you mean by "purest possible" - a lot of matrix representations would certainly not be fun or fast in very pure code.
10:53:59 <ddarius> (id . undefined) `seq` ()
10:54:03 <ddarius> > (id . undefined) `seq` ()
10:54:05 <lambdabot>   Ambiguous type variable `f' in the constraint:
10:54:05 <lambdabot>    `GHC.Base.Functor f'
10:54:05 <lambdabot>     ...
10:54:14 <ddarius> > (id Prelude.. undefined) `seq` ()
10:54:16 <lambdabot>   Not in scope: `Prelude..'
10:54:31 <Philippa> kuribas: that's a big 'it depends', though the state monad hasn't had work done on fusion the same way list functions have (and is hard to do that for in general)
10:54:33 <ksf> couldn't we just use attribute grammars as record system?
10:54:55 <ksf> ...tying up attributes with transformations into a different record type?
10:55:57 <kuribas> Philippa: wouldn't inlining and partial evalutation help?
10:56:01 <Philippa> n00b6502: in principle, if the monad is implemented in pure functions then the compiler only 'loses' info insofar as you told it extras about the alternatives anyway. Except the compiler might have to inline the monad an awful lot to figure the same things out. But it's a matter of obscuring
10:56:02 <ReinH> the compiler can probably better optimize functions over lists than arbitrary state transformations (fusion, as mentioned)
10:56:21 <c_wraith> ReinH: I'm pretty sure bind was chosen as the primitive *solely* because it maps so directly to do notation
10:56:22 <Philippa> ReinH: all the fusion rules in the list lib help!
10:56:49 <Philippa> c_wraith: give or take, yes :-) I need to re-read the relative monads paper, come to think
10:56:52 <ReinH> Philippa: yep, although I suspect that some amount of unpacking, unboxing, and strict types would help
10:56:58 <ReinH> but you'd have to do that yourself
10:57:00 <kuribas> ksf: I am trying to use something like that for my program.
10:57:09 <n00b6502> my impression is an imperative language helps you manually reason about performance wheras a functional langauge helps tools reason about performance
10:57:28 <kuribas> ksf: http://paste.lisp.org/display/131116
10:57:59 <Philippa> n00b6502: nowhere near that simple. Take a look at some of the intermediate languages that functional compilers use (CPS, ANF), you'll see what I mean
10:58:08 <ReinH> nomadmonad: The lower level ones, at least, but that makes sense: the thing ultimately performing the operations is imperative in nature.
10:58:10 <Philippa> also, lazy and functional are importantly distinct concepts
10:58:41 <kuribas> ksf: The idea is that I have a list of events (notes and rests), and I generate another list with attributes.
10:58:42 <merijn> Laziness really fucks with your (human and tool) ability to create composable cost models
10:59:06 <ReinH> sorry wring tab-complete
10:59:25 <ReinH> n00b6502: but higher leven imperative langauges depend just as much on compiler optimization as functional langauges
10:59:28 <ReinH> *level
10:59:36 <ksf> kuribas, http://hackage.haskell.org/package/uuagc-0.9.40.3
10:59:37 <qnikst> hello, is there a way to make my functoin depends on an outter type
10:59:38 <qnikst> ?
10:59:46 <n00b6502> true,
11:00:00 <ReinH> n00b6502: imagine the JVM without JIT
11:00:17 <Philippa> qnikst: in a "typecase"-like manner? Not without Data.Dynamic. Typeclasses might be sufficient for you though?
11:00:17 <ReinH> or, you know, think back a few years to when it was too slow to compete with C ;)
11:00:18 <n00b6502> in c++ , IMO there is a balance to be struck between abstraction and manually stating what you're doing
11:00:20 <kuribas> ksf: I know, but my library works in pure haskell, and I need only trees.
11:00:35 <Philippa> in C++, the balance is to run screaming
11:00:45 <Philippa> but that's because its abstraction tools aren't
11:00:46 <ReinH> I guess the lesson is that sufficiently advanced compilers can make any langauge performant
11:00:53 <merijn> unix-time is failing to install on my machine and the error suggests it's somehow searching $PATH for C source?
11:00:54 <qnikst> i.e. I have foo :: Foo b => a -> b, and another function bar :: Foo a => a -> c, and make smth like foo a = let c = bar ?? in blah c a
11:01:05 <ReinH> I suspect that referential integrity makes it much easier for compilers to optimize, but I am not an expert
11:01:07 <Philippa> ReinH: don't tempt me to go build an esolang they can't...
11:01:09 <n00b6502> an example of what i'm talking about is attempts to hide what pointers are
11:01:13 <geekosaur> merijn, pastebin the actual error?
11:01:21 <n00b6502> when one is trying to reason about caching behaviour
11:01:22 <ReinH> Philippa: only if you build a sufficiently advanced compiler for it ;)
11:01:57 <Philippa> ReinH: see, that's the point - to bury all the cost behaviour behind things that require solving the halting problem or worse on a regular basis :-)
11:02:01 <n00b6502> haskell is innteresting because its as far from traditional programming as you can get
11:02:05 <merijn> geekosaur: http://hpaste.org/73397
11:02:07 <ReinH> n00b6502: if you're programming in a language that doesn't have direct memory address, your ability to reason about caching behavior is exactly the same as your ability to reason about compiler behavior
11:02:36 <merijn> That path is the last entry in my $PATH variable, doesn't appear anywhere else in my environment and it's not my working dir
11:02:58 <Philippa> n00b6502: I could find points that're further. But I possibly understand how to compile something like Haskell better than you do at this point?
11:03:30 <geekosaur> hrm, windows.  I would not be surprised if windows regularly tries stuff form $PATH to work around there being a lack of standards for this kind of thing... but I would expect it to be checking the current directory
11:03:37 <ReinH> Philippa: we all solve the halting problem on a daily bases :p
11:03:43 <merijn> geekosaur: Eh, where'd you get windows from?
11:03:43 <ReinH> *basis
11:03:49 <merijn> geekosaur: It's OSX
11:03:50 <geekosaur> sorry, misread
11:03:57 <ReinH> Philippa: for solvable subsets, ofc ;)
11:04:16 <ddarius> Haskell isn't even close to as far from traditional programming as you can get.
11:04:18 <n00b6502> i got interested in functional programming from the experience of low level optmiizing for parallelism (multicore and SIMD) where the mentality was to try and refactor things into ''maps' as much as possible
11:04:30 <merijn> ddarius: Piet? :)
11:04:36 <geekosaur> but it occurs to me also... any chance of $PATH having a space in it somewhere?  that usually causes configure scripts to start behaving very, very weirdly
11:04:49 <merijn> geekosaur: Nope, space free
11:05:05 <merijn> (Piet being a language programmed by bitmap, named after Mondriaan :)
11:05:43 <ddarius> My recollection is Piet is a fairly normal, if minimal, language with an unusual syntax.
11:05:52 <Philippa> n00b6502: yeah, anything where you can make the actions on elements independent of each other is good. Product-like behaviour ftw!
11:06:24 <nand`> @tell hughfdjackson I have no clue about lisp, sorry
11:06:24 <ReinH> merijn: rather ironically, a good example of non-traditional programming languages for today is probably stack-based langauges like Forth
11:06:25 <lambdabot> Consider it noted.
11:06:48 <merijn> Is there a verbose flag for cabal?
11:06:49 * hackagebot yesod-eventsource 1.0 - Server-sent events support for Yesod apps. (FelipeLessa)
11:06:58 <merijn> It's current error reporting is utterly unhelpful
11:06:58 <n00b6502> laziness seems like a whole new level, which seems to offer scope for the compiler to radically rework what you're doing for memory traversal
11:07:04 <monochrom> yes. "cabal install -v" etc
11:07:29 <ReinH> n00b6502: practically speaking, laziness is often the enemy of (memory) performance, however
11:07:37 <ReinH> thunks are not free, unfortunately
11:07:53 <Philippa> n00b6502: so the problem is that most of the time the compiler doesn't quite have enough info unless you spent a long time feeding it rewrite rules? And even then it's not going to engage in search behaviour to try out different local maxima
11:07:53 <n00b6502> it seems like there is massive scope for haskell implementations to evolve
11:08:12 <n00b6502> this is why i was ranting about haskell -> C translator.
11:08:24 <ReinH> n00b6502: that seems like a step in the wrong direction
11:08:33 <Philippa> heh, GHC used to compile via C
11:08:39 <n00b6502> i probably haven't fully explained myself if you think that
11:08:46 <ReinH> fusion is probably the forefront of hackell compiler optimization
11:08:48 <ReinH> *haskell
11:08:56 <ReinH> Philippa: s/seems/historically is
11:09:01 <ddarius> JHC always compiles via C unless that's changed since last I looked.
11:09:31 <ddarius> ReinH: Fusion is pretty old.
11:09:31 <kuribas> I think that partial evaluation with inlining can do the same thing as fusion does, but more general.
11:09:41 <geekosaur> ghc still compiles via C if you use an unregisterised build
11:09:42 <merijn> ok, I'm completely clueless how to tell unix-time to look in the right location for its C files
11:09:49 <ReinH> ddarius: what about for parallelization?
11:09:57 <ddarius> kuribas: That would be akin to supercompilation and it can do many of the same things.
11:10:23 <n00b6502> "thunks /laziness are the enemy of memory efficiency" .. yet a pure/lazy program could be turned into an imperative program in a large number of ways. imagine a tool which could analyze the dataflow and turn it into the most efficient memory traversal.. which can be visualzied in C
11:10:29 * geekosaur got diverted by something else, is trying to reproduce locally (if lack of a proper env ironment doesn't bite me again...)
11:10:40 <ddarius> I believe advanced forms of supercompilation can completely subsume partial evaluation.
11:11:05 <ReinH> n00b6502: analyze the dataflow == solve the halting problem, right?
11:11:13 <Philippa> n00b6502: C is a shitty way to visualise
11:11:14 <n00b6502> or show you where its like the halting problem
11:11:30 <merijn> geekosaur: I think I have the problem
11:11:38 <n00b6502> no C emerged as being a convinient way to visualize how computers really work;
11:11:39 <Philippa> as a rule? When it runs into general recursion or a fixpoint operator :p
11:11:41 <merijn> geekosaur: Just don't know ho to solve it
11:11:57 <ReinH> how is GHC on branch prediction these days?
11:12:04 <Philippa> n00b6502: how much compiler work have you done? C really does not look like a good IR to me
11:12:17 <merijn> geekosaur: I checked out the error in the configure script and it's using $ac_confdir as default search path. So I suspect the autoconf script is borked and not setting that directory correctly
11:12:22 <monochrom> I can't reproduce the problem of unix-time not finding its own cbits/conv.c. but I'm on linux, not os x
11:12:39 <n00b6502> you can work around its limitations with restrict an making temporaries
11:12:39 <Philippa> ReinH: no idea what kinds of cue it tries to use. I wouldn't be surprised if it just hands off to llvm
11:12:41 <ReinH> Philippa: or, you know, lazy lists
11:13:05 <ReinH> Philippa: seems fair; llvm is quite good
11:13:14 <n00b6502> C is a good way of visualizing low level algorithms
11:13:23 <merijn> If I edit the configure script to use the extracted dir of unix-time as default path instead of $ac_confdir it works
11:13:30 <geekosaur> interestingly, it works here
11:13:32 <ReinH> Philippa: my point was that lazy evaluation in general is equivalent to the halting problem, right?
11:13:37 <monochrom> perhaps os x doesn't have the program "dirname"?
11:13:37 <Philippa> ReinH: there's an implicit fixpoint in that data declaration, but if you can call the constructors succesfully without using one and the compiler can see that, it's fine
11:13:40 <ReinH> Philippa: you can't know a priori whether one thunk will terminate or not
11:13:42 <merijn> So I'm gonna blame crappy autoconf scripts
11:13:57 <geekosaur> haral:60125 Z$ type dirname
11:13:57 <geekosaur> dirname is /usr/bin/dirname
11:13:57 <kuribas> ddarius: Why isn't supercompilation considered for GHC?
11:14:04 <merijn> monochrom: No, dirname exists, according to which
11:14:09 <n00b6502> could an analyzer tell you where its unable to analyze
11:14:09 <geekosaur> hm, does the current directory have a space in it?
11:14:20 <hpc> ReinH: it's not a question of "will it terminate", it's a question of "will i need this value"
11:14:35 <ReinH> hpc: yes, that's true, but some subset of thunks will be evaluated
11:14:42 <Philippa> n00b6502: yep, ones for dependently typed languages do that during typechecking/elaboration all the time
11:14:46 <ReinH> and of those, some may or may not terminate
11:14:50 <hpc> sure
11:14:54 <merijn> geekosaur: Nope
11:14:56 <ReinH> and there's no way to create an oracle to know if any given thunk will terminate
11:15:06 <ddarius> Kuraitou: It is.
11:15:35 <c_wraith> Does Conor McBride's Frank language do anything clever with termination checking?
11:15:36 <Philippa> ReinH: correct. There are, however, a bunch of analyses you can apply that take a conservative stab at provable termination
11:15:50 <n00b6502> i haven't done any compiler work but i've been a compiler
11:15:54 <Philippa> c_wraith: AFAIK it's not bothering so far
11:16:07 <hpc> ReinH: for instance, "Constructor (terminating expr)" is terminating
11:16:14 <ReinH> sure
11:16:17 <n00b6502> and had to work around and reason about comiler limitations
11:16:20 <ReinH> the halting problem in general depends on special cases
11:16:25 <Philippa> n00b6502: C doesn't even let you fuck around with the stack properly, what use is that?
11:16:36 <Philippa> hell, it insists there is one
11:16:40 <n00b6502> you can build your own stacks
11:16:44 <ddarius> You can fuck around with it improperly.
11:16:53 <monochrom> haha
11:16:57 <Philippa> ddarius: right, but mostly you fuck yourself instead, same as usual
11:16:58 <ReinH> Philippa: depends, insists, whatever :p
11:17:17 <Philippa> n00b6502: right, you can start embedding the language you actually want to talk in...
11:17:33 <n00b6502> also fast code will be more register based than stack based.
11:17:34 <Philippa> you're better off learning the appropriate compiler IRs
11:17:35 <ReinH> n00b6502: you can build your own stacks on disk too, but manipulating THE stack is important
11:17:36 <merijn> This proves once again that there isn't a build process that can't be made worse by the addition of autoconf >.>
11:18:03 <ReinH> merijn: Merijn's Law
11:18:32 <merijn> ReinH: I'm okay with being remember for observing that law :>
11:18:39 <merijn> s/remember/remembered
11:18:51 <ReinH> Philippa: I mean that every program aside from the one that breaks the oracle could be decideable.
11:19:16 * geekosaur still thinks this sounds like something has a space in it somewhere; almost nobody writes shell scripts properly to handle spaces
11:19:46 <n00b6502> 'manipulating the stack is important' - on modern processors fast code will keep locals in registers and minimize stack manipulation
11:19:55 <ddarius> So what do you do if an active standard references a cancelled standard which, apparently, hasn't been superceded?
11:20:09 <Philippa> n00b6502: how do you think you get to that code?
11:20:21 <merijn> ddarius: Cry and buy a gallon of chocolate ice cream
11:20:22 <scshunt> ddarius: make your best
11:20:23 <ReinH> Philippa: and essentially the reason that we can model the halting problem is that a program that halts 1 second before the heat death of the universe is pragmatically the same as one that never halts, and you just work backwards from there
11:20:26 <Philippa> ddarius: punch someone
11:21:02 <ReinH> we just model "halts in a reasonable amount of time"
11:21:12 <scshunt> You can actually go further
11:21:15 <n00b6502> i know LLVM assumes you have infinite registers, then overspills to stack. An ASM coder on a machine with decent register file simplifies his code until subroutines fit in registers since stack manipulation is a pain.
11:21:26 <n00b6502> (decent register file in x86 is still fairly recent..)
11:21:27 <scshunt> You can design a computer proram which can solve the halting problem up to a finite complexity limit
11:21:52 <ddarius> Register allocation is more of a pain than stack manipulation.
11:22:00 <scshunt> ^
11:22:00 <Philippa> n00b6502: yeah. Now, do you understand the relevance of tail calls here?
11:22:06 <n00b6502> sure
11:22:11 <scshunt> when I wrote a compiler in a course, I just used the stack since efficiency was no object
11:22:27 <qnikst> will try to ask again. I has a class Foo a where foo :: a -> Int; is it possible to make a function bar :: Int -> Foo a ; bar x = (foo <smth> + x)
11:22:35 <ReinH> scshunt: you can also determine if programs in a particular langauge will halt, for instance my trivial language that only contains the term 'halt'
11:22:46 <scshunt> ReinH: sure
11:22:48 <nand`> qnikst: :: Int -> Foo a doesn't seem like a valid type signature
11:22:49 <qnikst> that will depend on "outter" type
11:22:50 <ReinH> but only a finitely enumerable langauge
11:22:54 <Philippa> okay. If you've got that far, perhaps marking out things that do/don't allocate more explicitly is a good thing? Next thing you know, you're looking at ANF instead
11:22:58 <ReinH> scshunt: which is probably the same thing that you said
11:22:58 <scshunt> nand`: sure it is
11:23:11 <nand`> scshunt: not if Foo is a class
11:23:13 <qnikst> nand`: (Foo a) => Int ->a, for sure
11:23:27 <scshunt> yeah
11:23:31 <scshunt> close enough
11:23:38 <ReinH> scshunt: I'm sure there's a bijection there somewhere
11:23:43 <ddarius> Stack CPUs actually have some very nice properties, though probably the most relevant is that they tend to be much lower power than register based CPUs (probably due, in part, to the fact that they use far less transistors, which isn't a limitation now but you could conceive of it being valuable for massively parallel CPUs.)
11:23:43 <Philippa> C is actually pretty obscuring about such things, it just has other tradeoffs in its design that've made it a good lingua franca at the level it sits at
11:24:01 <scshunt> ReinH: Yeah. Any sub-turing-complete language, or a non-turing-complete restriction of a TC one
11:24:09 <nand`> qnikst: anyway; if you have a Foo Int instance then that gives you foo :: Int -> Int, but you still can't make it more general
11:24:22 <n00b6502> register based cpus offered more scope for ILP
11:24:30 <ReinH> scshunt: I think even finitely enumerable is too strict
11:24:34 <nand`> I don't think it would be possible to write foo :: Foo a => Int -> a  given only those requirements
11:24:42 <ReinH> scshunt: computability depends on uncountable infinities
11:24:57 <qnikst> nand`: i was a simplification, basically I need to make a parameter based on required type
11:25:03 <scshunt> ReinH: yeah
11:25:18 <ReinH> scshunt: ofc practically speaking that's a lot for a compiler to take on ;)
11:25:21 <scshunt> nand`: sure I can
11:25:23 <scshunt> nand`: undefined
11:25:34 <nand`> scshunt: I don't think that helps here
11:25:44 <scshunt> nand`: no, but this isn't agda. We have bottom
11:25:49 <monochrom> there are too many "foo"s. in particular, there is a "foo" being a class method of Foo, and now there is another "foo" being not a class method.
11:25:50 <n00b6502> "stack based CPUs..... massively parallel CPUs" .... remember the Inmos Transputer :)
11:26:04 <scshunt> qnikst: the problem I see
11:26:12 <scshunt> is that (foo <something> + x) is an Int
11:26:13 <mmarco> hi
11:26:13 <scshunt> not a Foo a
11:26:25 <scshunt> (or a (Foo a) => a) if you're pedantic
11:26:33 <monochrom> you people with your "foo"s are no better than math newbies who keep speaking like "it equals 0 therefore it is a maximum"
11:26:39 <mmarco> i am trying to compile json, but it consumes all the system memory
11:26:44 <mmarco> is it normal?
11:26:47 <nand`> monochrom: I.. huh?
11:26:49 <ReinH> scshunt: throw a forall in there for maximal pedant points
11:26:58 <nand`> ‘it equals 0 therefore it is a maximum’ O.o
11:27:03 * scshunt gives ReinH a cookie
11:27:04 <monochrom> "I has a class Foo a where foo :: a -> Int"
11:27:07 <scshunt> nand`: there's also unsafeCoerce if you really want
11:27:16 <n00b6502> Philippa: is there anything better than C for that level ...
11:27:19 <scshunt> ;)
11:27:30 <ddarius> nand`: Ambiguous pronoun reference.
11:27:41 <Philippa> n00b6502: the point is that you want to be at a level subtly below that. And I just namedropped an IR/class of IRs, are you familiar with ANF?
11:27:44 <nand`> ddarius: oh, I see
11:28:01 <monochrom> the correct sentence is supposed to be "(derivative of f at c) = 0, therefore f(c) is a maximum". see what I mean?
11:28:03 <nand`> monochrom: the way I interpreted it, ‘foo’ was always the class method; and ‘Foo’ was always the class
11:28:08 <n00b6502> ANF not heard that acronym.
11:28:22 <monochrom> <nand`> I don't think it would be possible to write foo :: Foo a => Int -> a
11:28:23 <nand`> monochrom: yes, I see what you mean. I totally didn't infer that from the previous sentence
11:28:27 <monochrom> that's the second foo
11:28:36 <nand`> monochrom: oh, I see now
11:28:43 <n00b6502> i know compilers make an IR. but is there a low  level language that has the same "peak" of low-level + whole program clarity as C
11:28:45 <nand`> monochrom: that was my error
11:28:50 <Philippa> n00b6502: yeah. See, normally when I'm getting into an argument with someone that's about when I get curious
11:28:50 <nand`> monochrom: I meant bar :: Foo a => Int -> a
11:29:15 <Philippa> right, so ANF will mess some things up for you, because it won't make arithmetic pretty?
11:29:41 <Philippa> but it makes things like allocation and tail calls stick out like a sore thumb and you still get to keep functions as a notion
11:30:11 <Philippa> so personally, so long as I can tell which chunk is a given arithmetic expresion from the source? I'd rather poke at ANF for costs
11:31:13 <ReinH> Philippa: http://en.wikipedia.org/wiki/Administrative_normal_form ?
11:31:44 <Philippa> ReinH: yep, though that's far from my favourite description of it and doesn't usefully demonstrate how a 'real' compiler IR gets built out of it
11:32:01 <Philippa> but take a peek at some of the languages that GHC Core's been?
11:32:06 <dylukes> Whew.
11:32:08 <typoclass1> n00b6502: erm, the "whole program clarity of c" has contributed a lot to those 40 years of buffer overflows, random crashes, null-pointer dereferences, and security snafus
11:32:27 <qnikst> nand`, mabye some scary stuff like func-deps, phantom type, gadts can work there?
11:32:28 <n00b6502> many languages were available
11:32:40 <ReinH> Philippa: too many IRs, brain not sufficient to contain
11:32:44 <dylukes> type families > func deps
11:32:46 <nand`> qnikst: sorry, I don't really know what the concrete problem is
11:32:48 <n00b6502> why did people go with C?
11:32:54 <dylukes> nand`: what's the goal?
11:33:01 <dylukes> n00b6502: it's a relatively simple language? :P
11:33:09 <ddarius> Indeed, C would be better at what it's used for if it didn't try to be as "friendly" to hand-written programs.
11:33:09 <ReinH> n00b6502: it was better than the alternative
11:33:13 <n00b6502> its just the right balance between high & low level
11:33:29 <ddarius> n00b6502: UNIX is why they went with C.
11:33:31 <ReinH> n00b6502: it was the only high level game in town
11:33:38 <ReinH> the rest is just momentum
11:33:39 <nand`> dylukes: ask qnikst; all I saw was “given class Foo a where foo :: a -> Int, is it possible to write bar :: Foo a => Int -> a; bar n = (foo <something>) + n”
11:33:43 <Philippa> n00b6502: you're walking into market territory, which tends not to lead to productive discussions. C was /not/ the language of choice on the platform I grew up on aside from maaaybe a 3-year gap before everyone got the hang of a little C++
11:34:00 <n00b6502> which platform was that, i'm curious
11:34:39 <monochrom> the class method "foo :: a -> Int" alone does not tell me how to generate a value of type a.
11:34:43 <Philippa> DOS
11:34:44 <qnikst> nand`, problem is to use a const based on return type inside a function
11:34:50 <ReinH> nand`: this sounds like a question for djinn ;)
11:34:52 <dylukes> Foo is Enum.
11:34:55 <dylukes> foo is fromEnum.
11:34:57 <dylukes> bar is toEnum.
11:35:07 <n00b6502> what was the language of choice on DOS
11:35:15 <geekosaur> many years ago unix shipped with a free compiler (pcc); other compilers were massively expensive.  for a while dos went the pascal route instead because turbo pascal was cheap, but freely available unix programs pushed things toward C and several free and cheap C compilers appeared
11:35:17 <n00b6502> my path was various home computers then gamedev
11:35:20 <n00b6502> on consoles
11:35:25 <Philippa> varied a little, but Turbo Pascal was pretty common
11:35:29 <dylukes> you couldn't write bar like that, but you can use Enum/Bounded for doing what he wants.
11:35:46 * ddarius misses developing in DOS.
11:35:56 <qnikst> nand`: is it ever possible, and what are workarounds if it's not possible
11:35:58 <ddarius> Though I never really used Turbo Pascal.
11:36:04 <Philippa> granted, Borland's Pascal had a lot in common with C. The 16 -> 32 bit transition shook things up a bit, too
11:36:16 <Philippa> *nod*. Hell, I wrote too much qbasic
11:36:20 <typoclass1> n00b6502: i think it's largely psychological. most people are naturally overconfident and overoptimistic. c seems like exactly the right choice for those. "one call of free() for every malloc()? every time exactly once in all the code paths that contained the malloc()? oh sure i can handle that", etc.
11:36:22 <n00b6502> asm -> c + a little asm -> c++, inline assembly and intrinsics
11:36:35 <qnikst> dylukes: ok, Foo a where foo :: a -> MyComplesDataType;
11:36:46 <ddarius> Yeah, I started on QBASIC, then assembly then C-ish C++ that evolved into real C++, then tons of other languages.
11:36:55 <n00b6502> for gamedev reasoning about memory was important. (embedded) you have to know ahead of time the program works in constant memory :)
11:36:58 <dylukes> qnikst: I'm not sure I follow? What's your goal here?
11:37:04 <Philippa> yep. I'm not saying C is useless?
11:37:22 <Philippa> But it's not what I would choose to talk about such things in. It's just a compromise position that's widely spread
11:37:27 <Squirrel-Neko> hekko
11:37:29 * ddarius <3 Borland's Turbo Debugger.
11:37:31 <Squirrel-Neko> hello
11:37:49 <qnikst> dylukes: I have a function that calls FFI code, and there is a parameter that describes return type, I want to hide it from caller for safety
11:37:52 <typoclass1> hi Squirrel-Neko
11:38:09 <nand`> qnikst: it doesn't seem to be possible in general without resorting to stuff like undefined; since bar :: Foo => Int -> a would directly involve constructing some ‘Foo a’; for example, consider ‘instance Foo Void’; your bar would be able to construct a Void (again, without resorting to undefined)
11:38:14 <n00b6502> currently people talk about the pointer overhead in 64bit mode.. 64bit mode 'makes some programs run slower'
11:38:21 <Philippa> did a bit of amateur gamedev stuff myself, FWIW - mostly in the last few DOS years and a bit of mucking around under windows once it was gaining us graphics acceleration
11:38:33 <n00b6502> ... but low level coders can use tricks like compressed pointers, precompiled datasstructures
11:38:37 <n00b6502> its not idiomatic C/C++
11:38:38 <ddarius> C has a lot of problems for embedded development though that's usually solved by implementation specific extensions.
11:38:39 <Squirrel-Neko> typoclass1, i'm glad to talk yo you :)
11:38:49 <n00b6502> ddarius: sure
11:39:10 <n00b6502> plenty of intrinsics, platform specific extentions
11:40:00 <n00b6502> my formative years were spent on the amiga which was great fun.
11:40:23 <Philippa> so at heart, C is mostly "denormalisable ANF" plus the right-enough mechanisms for data structure layout, memory usage etc?
11:40:24 <ReinH> C is a good language for telling a processor what to do (creating an IR that generates efficient machine code). It's not a great language for asking a processor what it's doing (recreating a C program from machine code or a given IR).
11:40:30 <n00b6502> 68k asm was a lot more pleasant than contemporary x86 and you had fun hardware to interface with
11:40:34 <Philippa> well, those and pointedly first order, of course
11:40:51 <n00b6502> heh decompilers ok
11:40:54 <Philippa> yep. Hell, when my gf and I start messing around musically, we'll be using a tracker descendant to run things
11:41:10 <ReinH> C is very noisy as an IR
11:41:16 <n00b6502> reasoning about data structures explicitely is why C works IMO yes
11:41:36 <n00b6502> if you want to make compressed pointers or imply pointers by sticking objects sequentially you can
11:41:37 <Philippa> but those bits of explicitness are fairly easy to 'steal' when wanted
11:41:53 <n00b6502> restrict is a mess though
11:42:08 <n00b6502> could be nice if const implied restrict
11:42:10 <ddarius> ReinH: No, see is not even that good at being an IR.
11:42:44 <ddarius> s/see/C
11:43:02 * ddarius returns to reading standards documents that are older than he is.
11:43:18 <typoclass1> i contend the sea isn't good at being an IR either
11:43:48 <monochrom> you upset OceanSpray :)
11:43:52 <ReinH> an IR should really only have one canonical representation of a given program
11:44:38 <Philippa> ReinH: I wouldn't go quite that far, but there should be identifiable and /sensible/ directions to normalise in
11:44:43 <ReinH> Philippa: yes, that
11:44:46 <dylukes> qnikst: you could do it.
11:45:08 <n00b6502> are there any links on the internet showing a C program alongside equivalent BNF
11:45:17 <Philippa> ANF, you mean? No idea
11:45:22 <n00b6502> ANF sorry
11:45:27 <dylukes> for example lets say you have some type Foo a where 'a' is some type parameter (ideally a member of a data kind enumerating return type).
11:45:30 <dylukes> Then you can do:
11:45:35 <ddarius> There should be no ambiguity which C is horrible about.
11:45:52 <Philippa> most of what you get is lambda calculus or ML to ANF. But that's sufficient if you can see what to add to a first-order lambda calculus to get C
11:46:09 <dylukes> class C a where; f :: forall i. a i -> i
11:46:09 <Philippa> (which is, um, mostly intrinsics)
11:46:11 <ReinH> also ideally your IR should not itself require a PEG to understand
11:46:11 <dylukes> then
11:46:16 <ddarius> ANF is closely related to SSA, and I'm sure there are examples of compiling C to SSA.
11:46:30 <dylukes> instance (Foo X) where…; instance (Foo Z) where …; instance (Foo Y) where...;
11:46:53 <n00b6502> i've not dealt with SSA but i'm aware of it
11:46:59 <ddarius> @google ANF SSA
11:47:01 <lambdabot> http://lambda-the-ultimate.org/node/3467
11:47:01 <lambdabot> Title: SSA vs. CPS (and ANF?) | Lambda the Ultimate
11:47:40 <dylukes> ddarius: Of course there are. Clang/LLVM.
11:48:04 <ReinH> there's also the distinction of an IR intended for human vs. computer consumption
11:48:12 <ReinH> an IR intended for human consumption is not really an IR at all
11:48:28 <dylukes> LLVM provides an IR and a bytecode version of the IR.
11:48:51 <dylukes> It's not provided for human consumption, but it's legible by humans, and good for outputing from front ends :P.
11:49:25 <n00b6502> i imagine that helps building and debuging the toolchains themselves
11:49:40 <ddarius> dylukes: I have no idea what you are responding to.
11:49:49 <dylukes> "and I'm sure there are examples of compiling C to SSA."
11:50:03 <ddarius> dylukes: I meant textual examples of side-by-side code.
11:50:08 <dylukes> oh heh
11:50:13 <dylukes> there are some in the clang docs I believe.
11:50:13 <ddarius> Many C compilers use SSA.
11:50:14 <ReinH> dylukes: the representation that's output for humans is an artifact of the IR, not the IR itself :p
11:50:36 <dylukes> the textual IR carries more information (names).
11:51:42 <ddarius> @google functional "static single information"
11:51:45 <lambdabot> http://homepages.inf.ed.ac.uk/stg/workshops/TFP/book/Singer/singer/ssifunc.pdf
11:51:45 <lambdabot> Title: Static Single Information from a Functional Perspective
11:51:50 <n00b6502> is there any language which beats C for practically writing fast programs
11:51:55 <dylukes> LLVM IR -> LLVM BC is a forgetful transformation.
11:51:58 <scshunt> assembly
11:52:02 <n00b6502> C and C++
11:52:05 <dylukes> "practically" is subjective.
11:52:12 <n00b6502> but C can do your register allocation ,its very useful
11:52:14 <ReinH> retention of lexer metadata (f.e. names) into the IR is really a human-centric optimization, I guess
11:52:14 <ddarius> "fast" is also subjective.
11:52:23 <n00b6502> fast is unambiguous
11:52:24 <dylukes> And it really depends on the task.
11:52:35 <ReinH> fast is unambiguous? wat
11:52:41 <ddarius> n00b6502: If you specify hardware and operating environment and program.
11:52:52 <n00b6502> yes thats what i mean then
11:53:17 <n00b6502> lets ask it another way. is there another language that would have been better for working on game consoles
11:53:52 <dylukes> Okay now that's a specific question.
11:54:07 <ReinH> FSVO "better"
11:54:12 <dylukes> Given that the major audio and video libraries are written in C with C bindings...
11:54:31 <dylukes> and that these platforms really only have a supported C toolchain,
11:54:32 <n00b6502> ok you can argue they didn't use C because there was also extentions, e.g. intrinsics, and bits of ASM here and there
11:54:34 <ReinH> better *for what*? programmer productivity? performance? cost?
11:54:36 <dylukes> and anything else tends to be self supported.
11:54:42 <n00b6502> performance on game consoles is absolute
11:54:52 <n00b6502> and unambiguous
11:54:57 <n00b6502> FPS
11:55:05 <ReinH> ...
11:55:07 <ReinH> memory
11:55:09 <n00b6502> or how much you can make the update & render do at 60gps
11:55:09 <ReinH> load times
11:55:11 <n00b6502> or how much you can make the update & render do at 60gfps
11:55:14 <ReinH> render distance
11:55:20 <Philippa> n00b6502: you seem awfully caught up on conflating different uses of C here
11:55:23 <n00b6502> yes these are all absolutles.
11:55:25 <Yiq> an mp3 decoder in haskell - useless?
11:55:39 <ReinH> "performance" is never unambiguous
11:55:45 <Philippa> Yiq: mp3 decoding isn't exactly something you need to make go as fast as possible these days
11:55:50 <ReinH> you still have to define your terms and qualify your comparators
11:55:51 <n00b6502> what language could have let people work on high performance rendering engines as effectively as C
11:55:58 <ReinH> or people will keep on misunderstanding you
11:56:36 <Philippa> n00b6502: I'm not sure anyone here gives a shit on what could have been better at C for /that/ purpose in the timeframe in question. That doesn't mean it's the ultimate possibility in the design space
11:56:36 <dylukes> n00b6502: Clearly it must be Common Lisp.
11:56:46 <ReinH> These things aren't inherent to the C language per se, they're a part of the C ecosystem.
11:56:48 <Philippa> dylukes: go Forth and multiply!
11:56:59 <dmos> conduit Q - how can I create a conduit which can run a checksum over all the ByteString bytes which have been consumed by a Sink?
11:57:00 <dylukes> Philippa: Oh shush. Take your Smalltalk to #-blah
11:57:02 <Philippa> ReinH: that and to a slightly wider class of languages that C typifies
11:57:03 <typoclass1> Yiq: sounds like a fun project to make one!
11:57:04 <dylukes> n00b6502: this is also definitely the wrong channel
11:57:18 <dylukes> Philippa: Also capitalize "Go" to add to the puns :P
11:57:24 <ReinH> C had a priveleged place in systems development as the first successful general-purpose successor to CPL
11:57:46 <n00b6502> well to bring it back on topic, could haskell ever be evolved for that specific purpose. game engines on consoles.
11:57:50 <ReinH> most of its current suitability comes from this accident of history, not because of any particular advantage to the langauge per se
11:57:53 <n00b6502> and do it better than C
11:57:55 <Cale> n00b6502: sure
11:58:23 <n00b6502> bearing in mind things like processors with no OOOE sometimes
11:58:26 <ReinH> if Haskell had a long-standing game development ecosystem, I can't see why it would be inferior
11:58:28 <Yiq> Philippa: why not?
11:58:51 <Philippa> Yiq: because unless you've asked for a specifically fast one, on any modern system you've got cycles to burn on the task
11:59:01 <n00b6502> i'm not talking about using C for acess to libraries - i'm talking about developing the libraries from the ground up
11:59:10 <monochrom> mp3 decoder for just playing to humans does not need to be faster than humans
11:59:20 <n00b6502> in cases where you have libraries, they somtimes let users develop games in other languges now.
11:59:28 <Yiq> Philippa: but couldnt haskell with GC make it a bit unpredictable Can I guarantee any real time constraints with haskell?
11:59:36 <ReinH> n00b6502: why do you think the C libraries exist in the first place?
11:59:37 <Cale> n00b6502: Are you planning on writing code for a processor with no OOOE?
11:59:37 <n00b6502> (e.g. C# application code with underlying C++ engine)
11:59:41 <Philippa> n00b6502: Haskell is not what I'd choose for it directly, no. But there are a lot of ideas that are reasonably related to Haskell that could be pursued
11:59:41 <ReinH> it's mostly historical inertia
11:59:45 <ddarius> Yiq: Nope, but nowadays you can be so far ahead so easily that it doesn't matter.
11:59:46 <Cale> (what is the point of this question?)
11:59:52 <n00b6502> current game-consoles have no OOOE
11:59:54 <Ralith> @faq Can haskell be used to build efficient renderers on consoles?
11:59:55 <lambdabot> The answer is: Yes! Haskell can do that.
11:59:59 <Cale> What?
12:00:04 <Philippa> also, while *I* wouldn't choose it, I'm not working on high-performance haskell code. Talk to those who do about the efforts involved and what is/isn't visible
12:00:14 <n00b6502> xbox 360 and PS3 do not have OOOE
12:00:16 <Philippa> Ralith: that would be a bad time to @faq yourself
12:00:29 <n00b6502> they grind to a halt when values go through the stack
12:00:33 <Ralith>  @faq you, Philippa
12:00:54 <Cale> n00b6502: But regardless, that's a detail for the compiler authors to worry about.
12:01:01 <Cale> n00b6502: Which language you're using doesn't matter.
12:01:08 <ReinH> consoles are also  a special case because of lack of thread contention
12:01:09 <Philippa> Ralith: okay, let me rephrase that - please do not abuse the @faq command in situations where it's actually non-obvious even to those best-placed to answer whether Haskell can actually do that?
12:01:18 <Cale> (with regard to that implementation detail)
12:01:32 <n00b6502> Cale: when a new console comes out the compilers aren't ready so you have to work around limitations
12:01:34 <Philippa> Cale: of course, it's easy for us to say that - we know how to specify ordering in Haskell when we want to
12:01:35 <Ralith> Philippa: as Cale is observing, it's an implementation concern, not a language one.
12:02:11 <Cale> n00b6502: I suspect that no OOOE is probably a boon to compiler authors who want to be clever about maximising the use of whatever processing units are available.
12:02:20 <n00b6502> Cale: when the xbox 360 came out, it wasn't able to map C++ vector maths classes into registers.. only a C typedef that they provided.
12:02:22 <Philippa> Ralith: let me know when you know what a Sufficiently Smart Compiler looks like, then. It's not unreasonable to talk about GHC Haskell's abilities to talk about resource usage in the meantime
12:02:35 <Ralith> Philippa: but that's not what he's asking about.
12:02:41 <Cale> (well, depending on how it's handled)
12:02:55 <n00b6502> no OOOE was a throughput issue, and possibly IBM mis-seeling a chip they designed for set-top boxes as video decompression :)
12:02:56 <Philippa> Ralith: Except that the mild generalisation of that rather /is/
12:02:57 <Cale> Aren't many things using the Cell processor now?
12:03:08 <Philippa> Cale: PS3, PS3 and not a lot else
12:03:10 <n00b6502> CELL is on the way out
12:03:12 <Ralith> Philippa: if you wish to assume that's what he means to ask about, well, GHC does not presently support either platform, so the answer is clearly no :P
12:03:22 <n00b6502> the software tools didn't catch up with the CELL's promise
12:03:28 <Cale> That's sad
12:03:35 <n00b6502> it would have taken a super langauge (like haskell )
12:03:40 <Cale> Cell was a nice architecture
12:03:43 <n00b6502> but the tools just weren't ready
12:03:47 <Cale> I would have liked to write a compiler for it
12:03:54 <nurpax> good evening!  anyone have any tips for testing code against stack overflow?  I'd like to do some heap & stack stress tests, and was wondering if there are some easy ways of checking if stack usage grows as a function of input size.
12:03:58 <Cale> (not that I had any reason to)
12:04:01 <Philippa> n00b6502: okay, so - have you understood how you'd build a lower-level-but-not-much C-like language out of ANF yet?
12:04:05 <n00b6502> CELL is what got me insterested in languages other than C
12:04:14 <n00b6502> but nothing was available to solve it
12:04:27 <Philippa> if not, it's really critical to understand it or something like it here
12:04:42 <monochrom> test with large input sizes
12:05:08 <Philippa> it's the bridge between Haskell itself and the languages the compiler works with - and the latter are the ones in which it has to be able to talk about these issues
12:05:15 <n00b6502> i can see how you'd go a little lower than C, and i've certainly written code that idomatic C programmers would despise
12:05:40 <Philippa> right. Next in line: can you see how, when you remove the first-order restriction, it's almost immediately 'higher-level' as well?
12:05:50 <nurpax> monochrom: yes, that much I figured out.  I just need to use large enough input and see stack blow up?  there's no way to measure this?
12:06:10 <n00b6502> would youu write a game engine in ANF
12:06:13 <ddarius> nurpax: Use the profiler.
12:06:43 <ReinH> n00b6502: what does that mean?
12:07:03 <monochrom> there are many OS tools for watching how much memory a program uses
12:07:05 <Philippa> n00b6502: Directly? No. But it's the language I'd use to do most of my "is the compiler doing what I want to?" checking in rather than dropping to asm
12:07:30 <Philippa> and there'd be an awful lot of ANF-like snippets in my code
12:07:43 <n00b6502> ok, something between high level  and asm sure. something like LLVM
12:07:55 <Cale> n00b6502: Do you know what ANF is?
12:08:01 <n00b6502> the main thing for me is registers vs memory
12:08:04 <Cale> (I'm just checking here :)
12:08:25 <teurastaja> how does one retrieve unique elements in a multiset without iteration?
12:08:27 <n00b6502> i've still not found decent links. someone said its related to SSA. i've seen a little LLVM
12:08:32 <teurastaja> xoring the sets by folding yields elements that appear an odd number of times but this isnt enough
12:08:32 <Philippa> Cale: It's new as of the start of this conversation, certainly. I double n00b6502 has internalised what it means
12:08:33 <Cale> http://en.wikipedia.org/wiki/Administrative_normal_form
12:08:46 <Philippa> n00b6502: OK, do you know the basic lambda calculus?
12:08:52 <teurastaja> symmetric difference works only with 2 sets
12:09:01 <teurastaja> because i get the intersection of all sets in the result otherwise when i use more than 2 sets
12:09:15 <n00b6502> i'm not sure i do.
12:09:16 <ReinH> n00b6502: people don't generally write IRs themselves... that's where the "intermediate" part comes in.
12:09:45 <n00b6502> i mean if i was to 'fix' c, theres a bit of clunkiness in 'restrict'
12:09:53 <Philippa> okay. Do you think you could start asking a more interesting class of question when people start dropping keywords and trying to point you at relevant things? Because really, we're just going over the same crap here otherwise
12:11:31 <n00b6502> with C you can reason enough about registers and memory. are you saying thats clearer in ANF.
12:11:55 <ReinH> n00b6502: ANF is a representation of a program that is essentially lambda calculus done up all pretty with a grammar. It allows for constants, lambda expressions, and variables (for function application), and for results of expressions to be captured via let binding
12:12:31 <n00b6502> does ANF have a concept of memory and registers
12:12:32 <Philippa> n00b6502: I'm saying that there is nothing that C does on that front that can't be made at least as clear in a simple ANF variant
12:12:38 <n00b6502> ok
12:12:40 <Philippa> n00b6502: Do us a favour, okay?
12:12:45 <Philippa> stop asking these questions
12:12:51 <Philippa> ask for an explanation of what ANF *is*
12:13:10 <n00b6502> what is ANF
12:13:13 <Philippa> because we're going to keep talking at cross purposes until you stop trying to get an 'interface' picture and grasp the details
12:13:25 <Philippa> okay. Lambda calculus first, because you're pretty short on some of the basics here:
12:13:28 <ReinH> ahem
12:13:31 <ReinH> n00b6502: ANF is a representation of a program that is essentially lambda calculus done up all pretty with a grammar. It allows for constants, lambda expressions, and variables (for function application), and for results of expressions to be captured via let binding
12:13:41 <Philippa> ReinH: please leave this one to me?
12:13:45 <ReinH> Philippa: ok :)
12:13:57 <Cale> (I disagree with that description of ANF)
12:14:09 <teurastaja> let me simplify my question: having a list of lists, i want to perform set-theoretic operations on it to retrieve elements that appear only once in those lists
12:14:13 <Philippa> n00b6502: so you know how in Haskell, you can write anonymous functions using a lambda?
12:14:20 <n00b6502> (\x -> .....)
12:14:24 <Philippa> correct
12:14:33 <n00b6502> []() { ....} in 'sepples'
12:14:35 <n00b6502> []() { ....} in 'sepples11'
12:14:43 <Philippa> the lambda calculus is the language consisting of: variables, applications/function calls and single variable lambdas
12:14:44 <n00b6502> they rock sure
12:14:50 <ddarius> ANF is monadic style.
12:15:02 <Cale> teurastaja: only once in all the lists? Or...
12:15:18 <teurastaja> yes, once in all the lists
12:15:25 <monochrom> what is in the list of lists, and why are they not flattened out?
12:15:26 <Philippa> I can mess around giving you a more formal version of that, but hopefully you can at least picture how that language behaves? (Note that it doesn't specify evaluation order, just how to evaluate when you do)
12:15:48 <n00b6502> i've heard the name lambda calculus thrown aroound with lisp whicih is where i gather lambdas first appeared
12:15:52 <Philippa> n00b6502: can we take this to #haskell-overflow?
12:15:53 <teurastaja> i fold over the lists using set-theoretic operators
12:15:58 <Philippa> and no, lisp was not the first use of lambdas
12:16:14 <Cale> The lambda calculus is older than electronic computers
12:16:23 <ReinH> Church
12:16:26 <Philippa> it was (one of the?) first languages implemented on a hardware computer that had them, inspired by the lambda calculus
12:16:27 <n00b6502> i've joined #haskell-overflow
12:16:48 <qnikst> nand`: thanks hack with undefined works well
12:16:55 <monochrom> if you use a list to store a set or multiset, you will run into linear-time and quadratic-time algorithms
12:18:26 <ReinH> best-case performance for what teurastaja wants is O(n*m) right?
12:18:28 <Cale> teurastaja: concat . filter (null . drop 1) . group . sort . concat
12:18:48 <teurastaja> i use scheme but i cant even get answers in ##math, ##math-software, etc.... so it has to be a list
12:19:04 <Cale> teurastaja: translate that into scheme :)
12:19:20 <monochrom> you can code up binary search trees in scheme
12:19:32 <ReinH> Cale: I have a doubt.
12:19:58 <ReinH> oh, once in all the lists
12:20:09 <Cale> > concat . filter (null . drop 1) . group . sort . concat $ [[1,2,3], [1,2], [4,5], [5,6,7,8], [7,8]]
12:20:11 <lambdabot>   [3,4,6]
12:20:26 <ddarius> Pretty much every Scheme nowadays has various data structures beyond cons cells.
12:21:33 <teurastaja> i use set functions found in srfi-1 (lset-difference, lset-xor, lset-union and lset-concatenate)
12:22:27 <kuribas> They O(n * m)
12:22:29 <Cale> Set operations are insufficient, because you're distinguishing between the cases of something occurring once and something occurring more than once, and set operations ought not to.
12:23:47 <ReinH> Cale: obtain a set of unique elements via disjunction and difference with original set to obtain a set of all duplicate elements?
12:24:10 <ReinH> then difference again with original set to obtain set of only-once elements?
12:24:11 <Cale> ReinH: Maybe list difference, but not set difference?
12:24:19 <ReinH> oh, *set*
12:24:27 <ReinH> set has no concept of 'appears more than once' to begin with
12:24:36 <Cale> right, that's my point
12:25:13 <teurastaja> set functions in scheme take any number of lists and fold over their arguments
12:25:26 <ReinH> teurastaja: but do they have list semantics or set semantics?
12:25:51 <teurastaja> scheme doesnt care about types
12:25:56 <ReinH> teurastaja: i.e. what is the result of union [1], [1]
12:26:03 <Cale> teurastaja: that's not what he's asking
12:26:05 <teurastaja> (1)
12:26:09 <ReinH> ok, set semantics
12:26:26 <ReinH> teurastaja: you need list semantics (allow dups)
12:26:28 <monochrom> right, scheme doesn't care about types. precisely the root of the problems
12:27:04 <teurastaja> (lset-union = (list 1) (list 1))  => (1)
12:27:17 <ReinH> ok, so
12:27:33 <ReinH> a xor b should give me a list of elements that occur once in either a or b right?
12:27:41 <teurastaja> yes
12:27:45 <ReinH> can I fold that?
12:27:58 <monochrom> is that behaviour promised by srfi-1? or is it just known in one implementation?
12:28:05 <ReinH> would fold xor list_of_sets give you what you want?
12:28:09 <teurastaja> but on multisets it returns those that occur an odd number of times
12:28:11 <Cale> What does (xor '(1) '(1) '(1)) give?
12:28:45 <teurastaja> would give (1)
12:28:51 <Cale> unfortunate
12:28:55 <ReinH> never mind
12:29:01 <DT``> shouldn't it give '()?
12:29:32 <ReinH> DT``: xor ( xor (1) (1)) (1) => (1)
12:29:48 <ReinH> assuming xor () (1) => (1)
12:30:39 <ReinH> I suspect that trying to determine "non-uniqueness" based on a type that has no concept of "uniqueness" is not going to be your best bet
12:31:48 <ReinH> s/based on/based on traversing/
12:32:25 <teurastaja> but its easy to get numbers that have multiple occurences
12:32:40 <ReinH> teurastaja: how do you do that using set operations?
12:32:41 <DT``> ReinH, right, I had a brainfart and stared at the monitor until I realized.
12:33:10 <teurastaja> lset-difference
12:33:16 <ReinH> teurastaja: i.e. how do you used closed operations over sets to produce a set with duplictes, when sets cannot have diplicates?
12:33:21 <ReinH> hint: you can't
12:34:20 <monochrom> I am not convinced that set operations will not do unexpected things to your multisets
12:35:15 <teurastaja> i meant lset-intersection
12:35:26 <monochrom> I mean that, too
12:35:37 <monochrom> I am not convinced that lset-intersection will not do unexpected things to your multisets
12:35:54 <monochrom> and similarly for the other lset-whathaveyou's
12:36:43 <teurastaja> http://srfi.schemers.org/srfi-1/srfi-1.html#SetOperationsOnLists
12:36:45 <monochrom> a lecture on the flip-side of assume-guarantee (pre-condition, post-condition) program correctness is probably in order
12:39:30 <ReinH> monochrom: then by all means :)
12:39:46 <teurastaja> i dont believe i cant do anything with that
12:40:36 <ReinH> monochrom: I don't think we're dealing with multisets here?
12:41:48 <monochrom> I am given the task of writing a function for "take an even integer parameter, return ...". because I am allowed to assume the parameter to be even, you can almost be sure that I will optimize my algorithm for even parameters, to the point that the function gives wrong answers for odd parameters. I am allowed to do that. it's in my contract.
12:42:36 <monochrom> now suddenly someone asks "how do I use your function for odd parameters?"
12:43:52 <ReinH> I can't even remember the original question o_O. Isn't the set of all elements that appear only once in each set in the list sets just `map difference sets`?
12:44:09 <monochrom> "odd integers are integers too! and the type system you use does not distinguish even and odd"
12:44:41 <ReinH> monochrom: to play devil's advocate, you *do* have a partial function over Int...
12:44:57 <ReinH> and unless you want to get pretty crazy you can't encode that restriction into the type system, right?
12:45:15 <ReinH> (can you encode even-only with Peanos?)
12:45:16 <teurastaja> i want to avoid (let f ([ls ls] [answer (list)]) (if (null? ls) answer (let ([x (car ls)] [ls (cdr ls)]) (if (member x ls =) (f ls answer) (f ls (cons x answer))))))
12:45:30 <monochrom> the original question says something about multisets, each multiset stored in a list. now, just because a set is also stored in a list and there is a library for that, the goal is to use the same library for multisets
12:45:47 <ReinH> monochrom: I thought that we had established that the sets were sets, not multisets...
12:46:03 <ReinH> monochrom: teurastaja said that union (1) (1) => (1)
12:46:18 <merijn> ReinH: Of course you can encode even-only using peano's
12:46:42 <monochrom> ReinH, my algorithm is optimized for even parameters, to the point it gives wrong answers to odd parameters. you are still welcome to plug in odd parameters, I won't mind, but from the wrong answers how do you recover the right answers?
12:46:42 <ReinH> merijn: ofc, sorry, so... assuming we don't want to encode even-only using peano arithmetic in types
12:46:48 <teurastaja> i have a list of lists (that is, a scheme list). i apply set operations unto those lists
12:47:13 <ReinH> oh. wow, ok.
12:47:44 <ReinH> teurastaja: so your-crazy-intersection [1,1,2] [2] would be... (1)?
12:47:44 <teurastaja> i want to use set operations to yield elements that occur only once in all lists
12:48:01 <teurastaja> no: (2)
12:48:14 <monochrom> you can say I should use the type system to forbid odd parameters in the first place
12:48:31 <ReinH> teurastaja: I meant difference, sorry
12:48:36 <monochrom> you can also say scheme should use the type system to forbid "everything is a list" in the first place, too
12:48:51 <ddarius> You can simply say your function represents even numbers by their halves.
12:49:05 <monochrom> <monochrom> right, scheme doesn't care about types. precisely the root of the problems
12:49:11 <ReinH> monochrom: no, I'm not saying that at all
12:49:47 <teurastaja> (1 1) because the 1st list is not touched
12:50:02 <ReinH> teurastaja: what
12:50:13 <ReinH> so... lset-union [1], [1] is what?
12:51:11 <monochrom> yes ddarius, you can also tell me to use a no-junk representation for even integers
12:51:26 <monochrom> you can also tell the scheme people to use a no-junk representation for sets
12:51:35 <ReinH> if lset-union [1] [1] => (1) and lset-difference [1,1,2] [2] => (1,1) then I wouldn't use lset-* for anything ever.
12:52:11 <monochrom> as it stands, they do use a full-of-junk representation for sets, and thus my analogy of full-of-junk representation for even integers still holds
12:52:13 <teurastaja> (lset-difference = '(1 2 3 4 5 6 7 8 9) '(1 5) '(2 3 7) '(2 3 5 6)) is the same as: (lset-difference = '(1 2 3 4 5 6 7 8 9) '(1 5 2 3 7 6))
12:52:30 <ReinH> teurastaja: that's now what I asked
12:52:43 <ReinH> the mapping from list semantics to set semantics that lset-* embodies is what's important
12:52:55 <ReinH> and if the semantics are as above, I think it's pretty broken
12:53:28 <teurastaja> what do you mean by the mapping of list semantics to set semantics?
12:53:48 <teurastaja> change of types?
12:53:52 <ReinH> teurastaja: so since scheme is untyped, lset-* just operates over lists, right?
12:54:01 <teurastaja> right
12:54:16 <ReinH> but it operates over lists in a way that attaches set semantics
12:54:25 <teurastaja> right
12:54:29 <ReinH> but it seems to do so inconsistently, and I'm not sure there's a way to make it consistent
12:55:06 <ReinH> so I especially wouldn't use it to decide something that set semantics can't decide in the first place, like uniqueness
12:56:09 <ReinH> in haskell, if you had lsetDifference :: List -> List -> Set and you tried lsetDifference [1,1,2] [2] then the one thing you can guarantee you wouldn't get back is a set with two 1s in it
12:56:16 <kuribas> But it doesn't claim to match set semantics precisely...
12:56:35 <teurastaja> i dont care about the 1st list not trimming off doubles since every list im using has unique numbers. what is not unique is when you make a set out of all those lists
12:56:45 <ReinH> kuribas: yes, adding undefined behavior makes things better :p
12:57:22 <kuribas> ReinH: It's defined in the SRFI.
12:57:31 <ReinH> teurastaja: if your function receives [[1,1,2], [2]], what should it output?
12:57:42 <teurastaja> lset-difference that is?
12:57:54 <ReinH> teurastaja: your 'elements that appear exactly once' function
12:58:48 <ReinH> wouldn't [] be logical?
12:59:01 <ReinH> since 1 appears twice?
12:59:17 <ddarius> monochrom: Yes, cons cell representations are indeed absolutely full of junk for most things.
12:59:29 <teurastaja> i dont have anything of this case in my program, each list has unique elements, though the concatenation of those lists may not have unique elements
12:59:51 <ReinH> famous last words...
13:00:17 <nurpax> is there any way to make cabal warn if some dependencies of my package are not in fact used?
13:00:24 <teurastaja> lset-difference takes a list, leaves it as is and performs set difference on the remaining lists
13:00:30 <monochrom> then don't concatenate? use lset-union?
13:00:54 <teurastaja> i have delete-duplicates for this matter
13:01:01 <ReinH> teurastaja: if you have a list of sets and you want to find every member that appears in exactly one set, just map difference (the traditional set difference, not your weird one)
13:01:08 <teurastaja> i want to see which ones are unique
13:01:44 <monochrom> lset-union skips duplicates in the second argument
13:02:02 <monochrom> most of the time
13:03:43 <ReinH> s/map/fold
13:08:12 <ReinH> specifically you need an associative difference
13:11:05 <pharaun> i have a question, is it possible for an outsider to wake a sleeping thread?
13:11:25 <ReinH> (and of course I'm incorrect because difference does not fold)
13:11:47 <teurastaja> if i (lambda (list1 . rest) (drop-right (apply lset-union = list1 rest) (length list1))) then i have unique numbers except those in list1....
13:11:57 <carharttjimmy> Hello, are there any good vim scripts to turn VIM into an IDE ?
13:12:04 <carharttjimmy> for haskell*
13:14:00 <ReinH> teurastaja: please remind me again why you're asking Scheme questions in #haskell?
13:14:06 <ReinH> carharttjimmy: you might find my setup useful http://haskelllive.com/environment.html
13:14:07 <teurastaja> because other chans dont have answers
13:14:09 <ReinH> teurastaja: you might try #nginx then as well
13:14:10 <mapreduce> Then you might want to try non-IRC resources.
13:14:29 <mapreduce> I bet if you write a blog post titled 'Scheme can't do X' you'll get a load of answers.
13:14:39 <monochrom> is there a scheme channel?
13:14:45 <mapreduce> Yes.
13:15:11 <monochrom> and if the scheme channel doesn't answer, no other channel answers. so don't bother harping the "the scheme channel is dead" argument
13:15:20 <teurastaja> it can do it as i wrote earlier: (let f ([ls ls] [answer (list)]) (if (null? ls) answer (let ([x (car ls)] [ls (cdr ls)]) (if (member x ls (f ls answer) (f ls (cons x answer))))))
13:15:29 <monochrom> but I guess I lie. we answered, afterall
13:15:43 <carharttjimmy> ReinH: does your haskellmode require me to make changes to it since I run Linux or is it general enough?
13:16:11 <ReinH> carharttjimmy: it's not mine, and no it's for vim generally
13:16:20 <carharttjimmy> ahh thank you
13:16:22 <monochrom> but you must be very boggled by the logic or lack thereof behind "I'm asking in #ubuntu because #haskell doesn't answer"
13:16:22 <teurastaja> i just wanted a mathematical answer to my set-theoretic problem
13:16:30 <ReinH> my videos use vim per se, not any specific gui version
13:16:45 <ReinH> teurastaja: then try #math
13:16:49 <teurastaja> i tried
13:16:54 <ReinH> ...
13:16:55 <carharttjimmy> I mean I have syntax enabled in Vim for haskell.
13:17:02 <teurastaja> i tried ##math-software also
13:17:38 <teurastaja> you should be pleased that haskell has such a useful community
13:17:44 <ReinH> at what point do you decide that your question is off topic for a particular channel?
13:17:55 <mapreduce> Hmph, I didn't even know you could do pattern-matching in the arguments bit of a scheme lambda
13:18:01 <mapreduce> (lambda (foo . bar) ...)
13:18:17 <DT``> mapreduce, that's not pattern-matching, it's a rest argument.
13:18:52 <teurastaja> bar contains additional arguments or '() if there isnt any
13:20:21 <ReinH> intuitively I think it's impossible to do what you want using set operations but I can't prove it
13:20:53 <teurastaja> if you curry this: (lambda (foo) (lambda bar ...))
13:21:09 * ddarius would recommend writing the logical formulation, simplifying that, and then translating to set theoretic operations.
13:21:26 <ReinH> I think the problem is that the fold you need requires an accumulator for 'seen element' state
13:21:55 <teurastaja> i achieve it like this without sets: (let f ([ls ls] [answer (list)]) (if (null? ls) answer (let ([x (car ls)] [ls (cdr ls)]) (if (member x ls (f ls answer) (f ls (cons x answer))))))
13:21:55 <ReinH> well no, not *just* that, but also 'count of seen element'
13:22:34 <teurastaja> i cons to the answer list if the car is not in cdr
13:24:15 <teurastaja> then i just continue with the cdr. when i reach the empty list, i return the answer
13:24:40 <teurastaja> i knew that from the start, but i wanted to see how i could do it with sets
13:25:34 <teurastaja> oops: (let f ([ls (concatenate ls)] [answer (list)]) (if (null? ls) answer (let ([x (car ls)] [ls (cdr ls)]) (if (member x ls (f ls answer) (f ls (cons x answer))))))
13:25:50 <teurastaja> oops
13:26:04 <teurastaja> oops: (let f ([ls (concatenate ls)] [answer (list)]) (if (null? ls) answer (let ([x (car ls)] [ls (cdr ls)]) (if (member x ls =) (f ls answer) (f ls (cons x answer))))))
13:26:27 <teurastaja> note that =) is actually = )
13:26:44 <teurastaja> because im working with numbers
13:26:45 <otters> =(
13:27:15 <ReinH> can we at least agree to write haskell in #haskell?
13:27:28 <otters> don't you have to have two copies of the board to implement Game of Life properly?
13:28:07 <teurastaja> how would you translate this into haskell?
13:28:41 <carharttjimmy> huh I just found http://aur.archlinux.org/packages.php?ID=26343 . I might try this for haskell and vim
13:29:16 <ReinH> well
13:29:29 <ReinH> there is probably a much cleaner way, but:
13:29:33 <ReinH> > let uniquesIn arr = foldr1 (\\) [nub $ concat arr, concat arr, nub $ concat arr] in uniquesIn [[1,2], [2,3], [3,4]]
13:29:34 <lambdabot>   [1,4]
13:30:00 <BvE707> howdee
13:32:25 <teurastaja> hmm... isnt \\ set difference?
13:32:39 <kuribas> Why not use Data.IntSet?
13:33:18 <ReinH> kuribas: well yes but I'm trying to use more primitive operations like unique and difference
13:33:24 <ReinH> teurastaja: yes
13:34:19 <Cale> Not quite
13:34:24 <Cale> \\ is list difference
13:34:31 <Cale> > [1,1,1] \\ [1,1]
13:34:32 <lambdabot>   [1]
13:34:56 <apeschel> Does order matter?
13:35:06 <DT``> > [1,2,1] \\ [1,1]
13:35:08 <lambdabot>   [2]
13:35:11 <teurastaja> im having troubles understanding a couple of things. could you break it down?
13:35:16 <teurastaja> no order doesnt matter
13:35:31 <ReinH> Cale: sorry, you're ofc right
13:36:40 <Cale> > "mississippi" \\ "imps"
13:36:42 <lambdabot>   "sissipi"
13:37:13 <hiptobecubic> it does 'remove firsts' basically, no?
13:37:18 <ReinH> teurastaja: since we're right folding, it's:
13:37:19 <ReinH> > let arr = [[1,2], [2,3], [3,4]] in (nub $ concat arr) \\ ((concat arr) \\ (nub $ concat arr))
13:37:21 <lambdabot>   [1,4]
13:38:40 <ReinH> teurastaja: first we get duplicate elements by (all \\ unique)
13:39:19 <teurastaja> $ is for infix notation?
13:39:44 <ReinH> teurastaja: $ is just function application with low precedence.
13:39:47 <hpc> ($) is function application, as an operator
13:40:00 <hiptobecubic> as in:   f $ x = f x
13:40:01 <hpc> (nub $ concar arr) is the same as (nub (concat arr))
13:40:02 <ReinH> nub $ concat arr is nub (concat arr)
13:40:12 <hiptobecubic> or  (f) (x) i guess
13:40:16 <monochrom> yes $ is infix
13:41:00 <ion> > nub "mississippi"
13:41:02 <lambdabot>   "misp"
13:41:58 <parcs`> > sort (sub "mississippi")
13:41:58 <lambdabot>   Not in scope: `sub'
13:41:58 <parcs`> > sort (nub "mississippi")
13:41:58 <lambdabot>   "imps"
13:42:02 <ReinH> so we are removing the list of all duplicate from the list of all unique elements
13:42:20 <ReinH> *duplicates
13:42:25 <ReinH> which leaves the list of all unique, non-duplicate elements
13:45:49 <ReinH> i.e. the list of all only-once-occurring elements
13:45:56 <ReinH> if our fold operation was a monoidal operation there would be a much simpler way to express this using mappend but I can't think of one for this... anyone?
13:46:01 <monochrom> in haskell, you use Data.List.union for that. in scheme, lset-union. they know how to skip duplicates
13:46:01 <teurastaja> since order matters in haskell... ;)
13:46:03 <monochrom> my understanding of the misguided question is: "but but that's slow, isn't there a faster way then linear-time? I think that lset-xor can help"
13:46:04 <monochrom> or perhaps s/linear/quadratic/
13:46:05 <teurastaja> of course you can force left-to-right or right-to-left evaluation in scheme, but in scheme we avoid assuming everything is ordered since its implementation-dependent
13:46:13 <teurastaja> just an example of trade-offs
13:46:21 <ReinH> so (nub.concat) = (foldr1 union) right?
13:46:49 <ReinH> teurastaja: I would be happy to show you an order-independent implementation if you can show me an order-independent non-associative difference
13:46:59 <monochrom> yes for inputs that already have no duplicates
13:47:29 <teurastaja> none associative?
13:47:48 <ReinH> > [1,2] \\ [2,3]
13:47:49 <lambdabot>   [1]
13:47:52 <monochrom> I don't know whether lset-xor or \\ helps in terms of correctness, but I am sure it doesn't help in terms of faster
13:49:29 <teurastaja> from the srfi-1: Be aware that these procedures typically run in time O(n * m) for n- and m-element list arguments. Performance-critical applications operating upon large sets will probably wish to use other data structures and algorithms.
13:49:48 <ReinH> I'm not sure that this is doable in less than O(n*m) time
13:50:11 <ReinH> but you can probably lower the constant factor
13:50:17 <monochrom> if all you have for elements is equality test, it is quadratic time
13:50:43 <teurastaja> recures once over the list: (let f ([ls (concatenate ls)] [answer (list)]) (if (null? ls) answer (let ([x (car ls)] [ls (cdr ls)]) (if (member x ls =) (f ls answer) (f ls (cons x answer))))))
13:51:14 <monochrom> binary search trees are faster because they cost you total-order tests
13:52:25 <ReinH> if we assume sorted lists, can we use some sort of saddleback?
13:53:00 <ReinH> hmm, no
13:53:22 <monochrom> the sorted-list assumption is useless if you won't use the total-order test
13:53:29 <teurastaja> i assume no order with my algorithm. just test for membership of the car in the cdr
13:54:25 <ReinH> so if my algorithm is: obtain list of duplicate items, difference from list of unique items, we can optimize the list of duplicates but we're still stuck with at least a single difference
13:54:36 <teurastaja> member function returns the tail starting with the found element or false if none were found
13:55:20 <teurastaja> i dont think you can beat what i just wrote in algorithm efficiency
13:55:39 <teurastaja> but i cant translate it....
13:55:40 <ReinH> yeah, I just can't parse it to tell
13:56:04 <ReinH> reading lisps is hard enough with indentation
13:57:05 <mk> is it possible for a monad that does not "box up" multiple values to violate the third monad law?
13:57:29 <atriq> Which is the third one?
13:57:30 <teurastaja> (let f ([ls (concatenate ls)] [answer (list)])
13:57:32 <teurastaja>   (if (null? ls) answer
13:57:33 <teurastaja>       (let ([x (car ls)] [ls (cdr ls)])
13:57:35 <teurastaja>         (if (member x ls =) (f ls answer)
13:57:36 <teurastaja>             (f ls (cons x answer))))))
13:57:39 <teurastaja> =) is = )
13:57:52 <mk> teurastaja: use pastebin
13:58:13 <arkx> A public gist would be better.
13:58:14 <mk> http://www.haskell.org/haskellwiki/Monad_Laws third monad law
13:58:38 <monochrom> what is "box up multiple values"?
13:59:14 <mk> monochrom: the maybe monad "boxes up" or "contains" a single value, which is passed by bind into the monadic function given to bind
13:59:15 <teurastaja> http://paste.lisp.org/+2T67
13:59:24 <monochrom> I am also proud to have contributed to that page, namely the do-notation versions!
14:00:02 <monochrom> ( http://article.gmane.org/gmane.comp.lang.haskell.cafe/14967/ )
14:00:08 <mk> monochrom: a set monad "boxes up" multiple values, and bind feeds each one into the monadic function
14:00:11 <teurastaja> [] is same as () i use the square ones for visibility
14:00:32 <monochrom> I don't think I understand the set monad. but I understand the list monad.
14:00:53 <ReinH> monochrom: "using 3.14" <- you planned this, didn't you?
14:00:58 <monochrom> "data Hey = Hey" can be made a monad. boxes up nothing
14:01:18 <ReinH> oh no we're back to trivial monads
14:01:35 <mk> monochrom: monadic values in the set monad have no ordering to their contained values
14:01:44 <monochrom> haha no, 3.14 refers to the haskell report, I couldn't control their section numbers!
14:01:50 <Okasu> hello
14:01:51 <ReinH> monochrom: ah, ok
14:01:55 <monochrom> also correction: data Hey a = Hey
14:01:57 <mk> ReinH: no no, we've already decided that those are not real monads
14:02:06 <ReinH> mk: are too
14:02:57 <mk> it seems to me that a monad that "contains" only single values cannot violate the third law
14:03:43 <mk> I suspect that the third law can only be violated when a) there are multiple values, and b) those values are ordered
14:05:02 <monochrom> I don't understand the question and your latest statement
14:05:04 <monochrom> "a monad cannot violate the third law" is a true statement. therefore, "a monad that satisfies <one more property> cannot violate the third law" too. but this is clearly not your question
14:05:04 <Okasu> is it possible to write onliner to "download web page contents -> get all regex matching links -> write it in file" with haskell?
14:05:04 <shapr> A monad cannot violate the third law unless failing to do so would violate the first or second laws of robotics, er.. monads.
14:05:35 <ReinH> shapr: I for one appreciate the Zeroth Law of Monadics. I'm pretty sure it's the only thing preventing skynet.
14:05:46 <Okasu> actually i already did it with ruby, but just wondering maybe it possible to substitute ruby with haskell in daytoday routine
14:06:36 <ReinH> @faq Is it possible to scrape an html document with Haskell and then conditionally write things to a file?
14:06:37 <lambdabot> The answer is: Yes! Haskell can do that.
14:06:49 <ReinH> monochrom: am I doing it right?
14:06:56 <monochrom> and "a monad that violates the third law" is an oxymoron
14:06:57 <avocado> this might be more of a problem with dealing with ssl in general, but i don't know how to get this to work on freenode. the ssl handshake fails. has anyone dealt with this before? it might also just me being dumb about freenode http://hpaste.org/73399
14:07:14 <mk> monochrom: to violate a law, a monad would have to be altered. My question is about that alteration, and not about whether tautologies hold :)
14:07:16 <Okasu> Ralith: you forgot thing about onliner
14:07:43 <ReinH> let us replace all uses of "monad" with "class that would be a monad if it honored the third law"
14:07:59 <Okasu> it's obvious that it possible even in C, but it should be oneliner :/
14:07:59 <ddarius> Okasu: Haskell doesn't require line breaks, so every Haskell program can be written in one line.
14:08:08 <ReinH> oh oneliner.
14:08:14 <Okasu> ddarius: funny
14:08:17 <ReinH> FSVO line length, yes.
14:08:21 <mauke> C doesn't require whitespace
14:08:29 <mauke> where is your god now?
14:08:55 <Okasu> do it in less than 100 chars?
14:09:02 <Okasu> can i do*
14:09:35 <mk> anyway, the point is, monads "containing" single values that meet all other requirements seem to need nothing more in order to satisfy the third law
14:09:38 <mauke> import Magic;main=dwim
14:09:51 <ReinH> Okasu: do you think this is a valuable metric for comparing programming languages?
14:10:08 <Deston> Okasu, you realize you can only do it in ruby in one line because of all the library code that runs in that one line? if you have the equivalent libraries available, you can do it in one line in any language.
14:10:20 <ReinH> mk: monochrom is objecting to your use of "monad', since all monads obey the monad laws by definition
14:10:24 <ddarius> Deston: Not -any- language.
14:10:28 <Okasu> ReinH: whoa, do you think i'm comparing something?
14:10:39 <monochrom> well that's the next part where I don't understand the question. you can violate the third law by alteration, always. I don't understand the focus on "single value" vs "not single value"
14:11:15 <monochrom> you can take Maybe, alter, and the alteration violates the third law
14:11:16 <Okasu> geez, can you just tell me can i do it or not?
14:11:39 <mauke> Okasu: import Magic;main=dwim
14:11:56 <Okasu> mauke: what is it?
14:12:13 <ReinH> if part of that line is import PageScraperAndMatcherAndFileWriter then yes, otherwise maybe
14:12:14 <mauke> Okasu: a program
14:12:25 <ReinH> Okasu: my point is that this is not a very useful question
14:12:47 <mk> ReinH: yes, I am aware of this. It also seems that my question was clear enough
14:13:11 <Ralith> Okasu: what
14:13:16 <mk> monochrom: how can it be violated without violating any other law etc.?
14:13:30 <Okasu> ReinH: ok, got it
14:13:40 <shapr> Okasu: I think so
14:13:43 <ReinH> mk: I was just trying to prevent the degeneration into semantics
14:13:53 <Okasu> shapr: how?
14:13:54 <mk> ReinH: success!
14:14:14 <lpvb> hey I'm trying to make an IRC bot in haskell
14:14:16 <lpvb> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
14:14:20 <lpvb> following that tutorial
14:14:22 <shapr> Okasu: try installing the download-curl library
14:14:29 <Okasu> shapr: already
14:14:42 <lpvb> but I get an error from the irc server saying: 451 JOIN :You have not registered
14:14:43 <Okasu> now im at the parsing point
14:14:56 <shapr> parsec?
14:14:56 <hdev> for some reason my project doesn't compile with -threaded even though i added it in ghc-options in my cabal file, no errors no nothing, anybody an idea why this is happening?
14:15:01 <Okasu> but it seems imposible to do it in short way
14:15:07 <ddarius> shapr: tagsoup would make more sense.
14:15:11 <shapr> ddarius: oh good point
14:15:16 <shapr> Okasu: Yah, tagsoup is a better choice.
14:15:25 <shapr> ndm's nifty tool
14:15:31 <ddarius> I think tagsoup even has a HTTP client so you could eliminate the curl part as well.
14:15:33 <ReinH> anything that can do xpath over possibly invalid xml is a good choice :)
14:15:44 <monochrom> ok, I don't know how to.
14:15:49 <ReinH> s/possibly/probably
14:15:49 <shapr> Okasu: http://community.haskell.org/~ndm/tagsoup/
14:16:00 <mk> the list monad can be "altered" to violate the law, by having it reverse the list either before or after processing. I can think of no such 3rd-law-violating alteration when it comes to single-value monads
14:16:21 <ReinH> mk: can we substitute "maybe" for "single-value monads" and then generalize from there?
14:16:52 <mk> ReinH: if you prefer
14:16:55 <ReinH> since proving your hypothesis false for Maybe generalizes into proving it false for all single-value monads :p
14:17:02 <Okasu> shapr: nah, i dont care about tags, they can be different from site to site, i need just get all links matching http://.*\.zip for example
14:17:15 <ReinH> s/all/any
14:17:45 <shapr> Okasu: Sounds cute, will you put it up on hpaste when you're done?
14:17:53 <mk> ReinH: I think that "single value" includes the state monad
14:17:56 <ReinH> mk: so you just need an example of this, right?
14:17:58 <ReinH> 17:10:54 < monochrom> you can take Maybe, alter, and the alteration violates the third law
14:18:11 <ReinH> mk: I'm trying to avoid having us argue about what "single-value" means... again. ;)
14:18:14 <monochrom> yeah, I can't do that now
14:18:34 <ddarius> data M a = L a | R a; instance Monad M where return = R; R a >>= f = f a; L a >>= f = case f a of R b -> L b; L b -> R b
14:18:38 <mk> ReinH: that doesn't make sense to me - what alteration can violate 3rd, but not any other monad-requirement?
14:19:02 <ReinH> mk: nfi, I'm just mediating this discussion :p
14:19:22 <mk> obviously, I agree that making maybe's bind always return 22 would ruin things
14:19:33 <Okasu> shapr: i can put in ruby, couse it's done already, i'm just theorythize about possibility of replce ruby in my day-to-day routine, so if it impossible to do it in short oneliner
14:19:37 <Okasu> i think i wouldn't do it again
14:19:43 <monochrom> yeah, having two cases "L a", "R a" helps, I briefly thought of it too, but it doesn't fulfill my promise about Maybe. (no no, you don't have to fulfill my promise either)
14:19:59 * ddarius needs to make a command-line parser.
14:20:21 <geekosaur> what, is that the new monad tutorial?
14:21:03 <mk> I think that the error monad is single-valued, though I'm not so sure about "Either"...
14:21:13 <mk> geekosaur: where?
14:21:15 <ReinH> well, if you add some non-associative operation to the bind, wouldn't that make the bind itself non-associative?
14:21:31 <mk> ReinH: explain?
14:21:33 <geekosaur> never mind ;}
14:21:41 <ReinH> mk: let me see if it makes sense in my head first
14:22:27 <monochrom> "how to break the monad laws" would be a good monad tutorial, yes
14:22:59 <ddarius> ReinH: Yes, just use the Writer monad with a non-monoid.
14:23:09 <mk> so, if we're planning to sabotage a monad, we can do it by changing bind, in two places. The first is on input (e.g. list monad, reversing the incoming list values), and the second is the output
14:23:24 <ReinH> ddarius: I was thinking of adding subtraction to Identity Int somehow
14:23:39 <monochrom> generally, for topic T, there is not enough dose of "what is not T". this is one factor why people keep thinking up broken analogies for T
14:23:44 <ddarius> As long as the monoid satisfies the left and right unit laws, the monad will satisfy the monad left and right unit laws.
14:23:53 <mk> ReinH: you would violate 1 and 2
14:23:56 <ReinH> that's true
14:23:59 <ReinH> never mind :)
14:26:43 <ddarius> data T = Leaf | Branch T T; instance Monoid T where mempty = Leaf; Leaf `mappend` t = t; t `mappend` Leaf = t; x `mappend` y = Branch x y
14:26:59 <ddarius> Writer T now satisfies the unit monad laws but not the associative law.
14:27:39 <mk> ddarius: can we walk through that?
14:28:48 <hpc> mk: what's the root of (x `mappend` y `mappend` z)?
14:29:00 <hpc> is it (x, y), or (y, z)?
14:29:19 <mk> hpc: unfamiliar with mappend...
14:29:29 <hpc> Leaf `mappend` t = t; t `mappend` Leaf = t; x `mappend` y = Branch x y
14:29:35 <hpc> (from ddarius above)
14:30:23 <mk> doesn't Branch store two values, then?
14:31:12 <mk> that is, if I gave a Branch monadic value to bind along with some function f, wouldn't bind call f first with one value contained in Branch, and then with the other?
14:34:07 <ddarius> The monad is Writer T, not T.  T isn't even a functor.
14:36:37 <mk> I'm a bit confused then
14:38:57 <gertc> how do i pack ascii to string? dit not find it on http://www.haskell.org/hoogle/?hoogle=ascii+pack
14:39:33 <shachaf> ASCII?
14:39:34 <geekosaur> which kind of string?
14:39:37 <shachaf> Represented how?
14:40:34 <geekosaur> also, is it *really* ASCII?  (That is, characters from 0x00 to 0x7f?)
14:42:10 <gertc> http://hpaste.org/73401
14:42:31 <otters> ...
14:42:55 <gertc> i gues the uid of fb is ascii?
14:43:05 <mauke> wat
14:43:41 <gertc> the facebook package uid type
14:43:55 <mauke> the what?
14:44:21 <Botje> gertc: you will need to show full code. Haskell doesn't come with an "Ascii" type by default.
14:44:43 <gertc> ok sec
14:44:58 <otters> Looks like http://hackage.haskell.org/packages/archive/ascii/0.0.4.1/doc/html/Data-Ascii.html
14:45:08 <otters> which means you'd just have to use toString
14:46:33 <porcoDIO> ooooooooooooooooo
14:46:33 <porcoDIO> rrrrrrrrrrrrrrrrrrrr
14:46:36 <porcoDIO> cccccccccccccccc
14:46:38 <porcoDIO> oooooooooooooooooooooo
14:46:43 <porcoDIO> ddddddddddddddddd
14:46:43 --- mode: ChanServ set +o mauke
14:46:44 --- kick: porcoDIO was kicked by mauke (porcoDIO)
14:46:55 <monochrom> "type UserId = ByteString" from package fb
14:47:05 <pharaun> wat
14:47:08 <monochrom> I don't know how you know that's ascii
14:47:15 <monochrom> http://hackage.haskell.org/packages/archive/fb/0.11/doc/html/Facebook.html#t:UserId
14:48:06 <monochrom> of course, that's for fb version 0.11
14:48:25 <monochrom> but the strange thing is, I can't find version 0.10 or 0.10.0 or 0.10.*
14:48:27 <gertc> https://github.com/gertcuykens/haskell-design/blob/master/src/Picture.hs
14:48:29 <mauke> ausmertzen: hello
14:48:44 --- mode: mauke set -o mauke
14:48:48 <ausmertzen> hi
14:48:58 <mauke> ausmertzen: what brings you to #haskell?
14:49:21 <monochrom> hackage only lists "... 0.9.6, 0.9.7, 0.11"
14:49:55 <ausmertzen> i want to see the level of development of H
14:49:56 <ausmertzen> it's been a while that i didn't check with it
14:49:59 <ausmertzen> and when i saw it i damn liked it
14:49:59 <monochrom> eh? "import qualified Login as FB"? so where does Login come from?
14:50:16 <Botje> presumably the same project?
14:50:20 <monochrom> (definitely not fb)
14:50:26 <Botje> yep, there's a Login.hs
14:50:28 <ausmertzen> heh
14:50:40 <pharaun> hello, is it possible for another thread to wake up a different thread?
14:51:03 <shachaf> pharaun: Yes.
14:51:07 <shachaf> But why is the thread sleeping?
14:51:19 <gertc> i tought this would work but it does not liftIO $ mkdir ("data/" `mappend` i)
14:51:27 <ausmertzen> bye all
14:51:33 <monochrom> ok then it's still fb's Facebook.UserId which is Bytestring
14:52:12 <monochrom> and I have no reason to believe whatever anyone says about what's really in that Bytestring
14:52:12 <pharaun> shachaf: cos the network io is UDP, i need to keep track of which sent mesg -> which recieved msg, i'm looping in a loop to handle that and i want to wake up the thread that sent the message when i got a reply back for that thread
14:52:23 <monochrom> of course, you can ignore me
14:52:31 <ReinH> seems like having two different modules imported as FB in different scopes is unnecessarily confusing, especially when one of them is Facebook and the other is your own Login
14:52:33 <shachaf> pharaun: Why is the thread sleeping?
14:52:42 <gertc> monochrom, https://github.com/gertcuykens/haskell-design/tree/master/src
14:52:50 <pharaun> shachaf: cos it sent a message then i put it to sleep till a reply come back
14:53:09 <shachaf> How did you put it to sleep?
14:53:10 <pharaun> shachaf: i was told that having a blocking library is better cos haskell has good light weight threading
14:53:27 <pharaun> shachaf: that part i'm not for sure, was thinking of a mvar
14:53:38 <shachaf> OK.
14:53:42 <monochrom> you can kill a thread to wake it up. it means an exception for that thread. you can install an exception handler in that thread to say "do more work, don't die"
14:53:50 <mauke> or you can use an MVar
14:53:56 <shachaf> If you're waiting on an MVar, then write to that MVar from another thread to make it stop waiting.
14:54:00 <ReinH> seems like an awkward way to coordinate though
14:54:09 <shachaf> Don't use exceptions. That's, like, crazy.
14:54:19 <shachaf> "as they say"
14:54:27 <monochrom> but do not make the mistake of "a tail call in the exception handler". there is no such thing. your call is not a tail call, far from it
14:55:02 <ReinH> you could avoid that mistake by not making the mistake of using exceptions to coordinate threads :)
14:55:13 <monochrom> use exceptions. they're fine. just use them correctly.
14:55:57 <ReinH> why wouldn't you just use MVar () as a semaphor?
14:56:00 <monochrom> here is a correct way to catch exceptions for this purpose. it begin by: don't use "catch", use "try"
14:57:20 <monochrom> x <- try (whatever you normally do); case x of { Right a -> you're done, and the answer is a; Left e -> you get an exception, it's e, and also this is a good place to make a tail call if you want to }
14:57:34 <hpc> catch or catch not
14:57:36 <gertc> how do you go from bytestring to filepath?
14:57:37 <hpc> there is no try ;)
14:57:43 <monochrom> haha hpc
14:57:43 <ReinH> hpc: :p
14:57:55 <Ralith> What are some instances of Category with a nontrivial id implementation?
14:58:44 <monochrom> gertc: there is some new lib for using bytestring as filepath directly, saving you the highly possibly erroneous intermediate translation to String
14:58:56 <monochrom> I just forgot the name of the packages
14:59:11 <shachaf> gertc: Depends on your OS.
14:59:19 <gertc> posix
14:59:24 <shachaf> Probably "decode it as UTF-8".
14:59:30 <monochrom> and yes as soon as you step out of ascii, that intermediate String layer is highly possibly erroneous
14:59:42 <ReinH> pharaun: it seems like what you want to do could be solved efficiently using pubsub (master thread publishes responses keyed by message id, message senders subscribe and filter by message id)
14:59:49 <monochrom> so don't bother with String at all
15:00:38 <gertc> ps show i works but the i have "" wraped around it
15:00:52 <pharaun> shachaf: so i could have a mvar of a list (tag, thread mvar to wakeup), then i grab that list, find the correct thread to wake up then fill/take a value from its mvar to wake it up?
15:00:56 <monochrom> sure, "show" is not for that purpose at all
15:02:00 <pharaun> ReinH: i was thinking that, but then won't that mean each thread would wake up everytime the master publishes a result
15:02:17 <pharaun> ReinH: it just seems more efficient to have master thread wake up the correct child thread and say here you go here's your data
15:03:00 <gertc> ok so how do i go from liftIO $ mkdir ("data/" ++ show i)to liftIO $ mkdir ("data/" ++ i) without i being ""uid""
15:03:15 <ReinH> pharaun: that's true, but then it would probably make more sense conceptually as message passing (actors) rather than semaphors or mvars
15:04:03 <gertc> going to try decode, just a sec
15:04:12 <shachaf> pharaun: You didn't say anything about lists or tags or anything until now.
15:04:14 <pharaun> ReinH: yeah, i'm just trying to figure out which model/approach works the best for this api/library, the main painpoint is fact that its on top of the udp protocol :\
15:04:24 <pharaun> shachaf: i was just asking if that approach could work?
15:04:28 <ReinH> pharaun: master would receive (childId, messageId, message) tuples from children and dispatch received messages to child at childId via message passing
15:04:31 <shachaf> pharaun: If you want to "wake up" a thread which is waiting for an MVar, just put something into that MVar.
15:04:39 <shachaf> I don't know about the rest of it.
15:04:54 <ReinH> pharaun: right, it's udp so you have to bake any consistency/durability guarantees in at the app layer
15:05:24 <pharaun> ReinH: exactly hence me having to have a master loop that deals with timeout/recieving/etc and then waking up/returning things in the right order/etc
15:05:33 <ReinH> pharaun: you can implement the basic message passing system on top of mvars, but I think it would be easier to conceptualize as message passing
15:06:04 <pharaun> ReinH: message passing in this case is ? i mean like how do i pass the messages to all of the threads for them to filter?
15:06:31 <ReinH> as in wire things together with mvars but speak about 'send clientId message' instead of putMVar at the app level
15:06:44 <pharaun> ReinH: ahh i see
15:06:48 <ReinH> hide the mvar usage behind a nice interface that you can reason about more easily
15:07:53 <pharaun> gotcha, yeah something like that would work, hide away mvar/list/etc
15:07:53 <ReinH> or possibly explor actor options in Haskell, although I haven't done that myself
15:07:54 <pharaun> then have a nice api that is like, ok here's a tag, ok find me the thread, wake it up, pass it the data
15:07:55 <ReinH> pharaun: you don't even worry about waking up at that level, that's handled underneath the hood by the mvars
15:07:55 <ReinH> you just send a message to a client
15:07:55 <pharaun> true
15:07:55 <ReinH> (client process)
15:07:57 <pharaun> that would certainly be easier to reason about and hide away all of that inside that api
15:08:01 <ReinH> s/process/thread but conceptually they are processes if we're talking about message passing
15:08:29 <ReinH> send manages lookup and dispatch to the correct mvar, etc
15:08:30 <gertc> ok found it need to use bytestring unpack ... somtimes i really want to kiack the compilers ass :)
15:08:51 <ReinH> pharaun: or just, you know, use actors ;)
15:09:11 <ReinH> or just, you know, use Erlang *runs away*
15:09:27 <pharaun> ReinH: hah!
15:09:51 <pharaun> ReinH: i haven't looked into actors yet, i should eventually but i'm probably not at that level yet
15:09:59 <pharaun> anyway shachaf ReinH thanks :) i now got a better idea/model on how to approach this
15:10:04 <ReinH> pharaun: if you're at the level where you're building a message passing system using mvars, you're already past the level where you could be using actors ;)
15:10:19 <pharaun> ReinH: i guess
15:10:49 <pharaun> alright alright, i'm digging around into actors now :p
15:11:10 <ReinH> pharaun: you can use mvars as channels btw with takeMVar and putMVar as receive/send, which will probably get you quite far
15:11:30 <ReinH> you just need a clientId -> channel map
15:11:35 <pharaun> yeah
15:11:47 <Okasu> http://vpaste.net/K5wnm how can i fix it?
15:11:49 <pharaun> i already needed a map to track all of the message/session going in/out anyway
15:12:03 <pharaun> so i should be able to attach a channel map, and go from there
15:12:30 <mauke> Okasu: what's the type of openURIString?
15:12:37 <ReinH> pharaun: you need an mvar on the master so children can announce, probably, but I think you see where I'm going with this
15:12:44 <lpvb> how do you make multiline strings in haskell?
15:12:44 <pharaun> indeed
15:12:51 <Okasu> mauke: String -> IO (Either String String)
15:13:04 <mauke> Okasu: so what is doc =~ "..." supposed to do here?
15:13:18 <pharaun> and ReinH as of why haskell, i just wanted to improve my haskell skills and i enjoy the language so far thus :) tho i suppose i could probably do some things easier in erlang
15:13:27 <ReinH> pharaun: seems good :)
15:13:28 <Okasu> mauke: patternmatch
15:13:33 <mauke> Okasu: on what?
15:13:49 <Okasu> on doc
15:13:53 <mauke> Okasu: doc is not a string
15:13:57 <mauke> how is this supposed to work?
15:14:07 <Okasu> how can i converti it to string?
15:14:12 <ReinH> pharaun: the issue is that you end up building in a lot of things like health checks that erlang will give you more or less for free via OPT
15:14:17 <mauke> Okasu: what do you mean by "convert"?
15:14:33 <pharaun> ReinH: true
15:14:34 <ReinH> pharaun: but it does sound like a fun project
15:14:37 <Okasu> IO (Either String String) -> String
15:14:45 <mauke> Okasu: how about no
15:14:47 <pharaun> ReinH: still good to learn about how those things work before you take it for granted imho
15:14:52 <ReinH> pharaun: totes
15:14:58 <mauke> Okasu: you don't seem to understand what you're doing
15:15:03 <mauke> you're just arranging symbols
15:15:04 <ReinH> pharaun: if nothing else you'll appreciate erlang a lot more ;)
15:15:08 <pharaun> ha
15:15:46 <Okasu> mauke: why it so hard to get content of page and parse it?
15:15:51 <Okasu> what purpose of it?
15:16:00 <mauke> Okasu: because you don't understand what you're doing
15:16:20 <ReinH> mauke: well if I start generating theorems from syntactically correct combinations of {IO, Either, String, (, )} I'll eventually get to what he means, right?
15:16:25 <mauke> similarly, it's hard to walk around if you're just activating random muscle groups
15:16:33 <d-snp> hey, if I explain monad as a linked list of lambda's where upon evaluation the return value of the first is the parameter of the next, etc am I skipping something important?
15:17:02 <Okasu> mauke: so can you explain how can i parse ouptup of openORIString?
15:17:04 <mauke> d-snp: yes
15:17:17 <ReinH> d-snp: that explains a certain kind of monad, those based on sequential computation
15:17:17 <mauke> Okasu: what is the output of openURIString?
15:17:32 <ReinH> but not, say, [a]
15:17:33 <Okasu> mauke: page content
15:17:39 <mauke> Okasu: impossible
15:17:51 <mauke> Okasu: you said its type is IO (Either String String)
15:17:55 <mauke> that is not "page content"
15:18:09 <Okasu> mauke: http://vpaste.net/uOlCv
15:18:13 <Okasu> it is page content
15:18:20 <mauke> Okasu: no, it isn't
15:18:59 <d-snp> ReinH: but [a] is a linked list too right?
15:19:04 <monochrom> I wonder what you would get if you were given some true utf-8 stuff
15:19:08 <Okasu> mauke: it is, but it wrapped in some kindof type
15:20:07 <Okasu> mauke: nad if it possible to parse, why ReinH said that it's maybe possible?
15:20:09 <ReinH> d-snp: explain this for me in terms of sequential evaluation:
15:20:14 <ReinH> > do { x <- [1,2,3]; y <- [2,3,4]; return (x,y) }
15:20:15 <lambdabot>   [(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,2),(3,3),(3,4)]
15:20:24 <monochrom> openURIString "http://www.vex.net/~trebla/u.html"
15:20:32 <ddarius> :t (/)
15:20:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:20:49 <mauke> Okasu: I'm no longer interested in talking to you
15:20:59 <Okasu> mauke: pussy
15:21:05 <mauke> that was uncalled for
15:21:07 <d-snp> lol hush hush with the name calling
15:21:48 <monochrom> what package is Network.Curl.Download from?
15:21:55 <ReinH> #winning friends and influencing people
15:22:03 <d-snp> ReinH: I don't understand what is going on there at all :P
15:22:24 <mauke> d-snp: multiple worlds
15:22:25 <d-snp> I think the do syntax clouds it a bit.. and perhaps I don't fully understand what bind and return are for []
15:22:35 <monochrom> (>>=) for list is like concatMap
15:22:46 <ReinH> d-snp: what about here:
15:22:49 <ReinH> > [ (x,y) | x <- [1,2,3], y <- [2,3,4] ]
15:22:51 <lambdabot>   [(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,2),(3,3),(3,4)]
15:22:55 <monochrom> [1,2,3] >>= f is concatMap f [1,2,3]
15:23:29 <d-snp> well the list comprehension I understand
15:24:00 <d-snp> oh thanks monochrom now I understand why it does a carthesian product
15:24:02 <ReinH> d-snp: the list monad is a) comprehension over lists b) computation with multiple possible results c) other things that map onto the implementation
15:24:18 <monochrom> list comprehension can also be understood as concatMap
15:24:44 <monochrom> and both end up doing cartesian product
15:24:46 <ReinH> monochrom: yes
15:24:47 <Shou> Has anyone read http://www.renci.org/wp-content/pub/tutorials/BeautifulCode.pdf ? On page 10 it says "DataNode would be a user defined module." but that's about it, as far as I can tell as document search results for "DataNode" are contained to that page. Anyone have an idea of what it is?
15:26:02 <monochrom> does the article give the code for DataNode?
15:26:20 <d-snp> hey ReinH when's your second episode coming?
15:26:54 <ReinH> d-snp: second is out, third is being recorded today
15:26:59 <d-snp> ohhh nice
15:27:02 <d-snp> I'll go check it out
15:27:16 <d-snp> was there a mailinglist?
15:27:26 <ReinH> d-snp: there's github issues
15:27:31 <ReinH> and rss :)
15:29:10 <Shou> monochrom: Article? The PDF document or is there something else? DataNode isn't anywhere to be found in the PDF document, at least.
15:29:23 <monochrom> the pdf
15:29:43 <d-snp> ReinH: we use mailchimp for mailing interested people, it works very well for retaining users, just put a big e-mail box on your frontpage and mail everyone when a new episode is out
15:29:44 <monochrom> does it say "here is how you would write it if you wanted to"?
15:29:58 <d-snp> though since it's free I guess you don't make much money off more users :P
15:30:01 <ReinH> DataNode appears to be some custom (oddly named) tree implementation
15:30:12 <ReinH> d-snp: exactly zero money :)
15:30:32 <ReinH> well that's not true, someone donated $3/month, but I haven't collected yet
15:30:33 <ReinH> no wait, $3/week (I'm rich biatch)
15:31:12 <ReinH> judging from the pattern match, DataNode is DataNode num height depth lt rt
15:31:19 <d-snp> :P
15:31:51 <ReinH> er
15:31:54 <ReinH> ok, weird, nodes have type DataNode and leaves have type DataLeaf and they are pattern matched separately
15:31:55 <d-snp> oh you still didn't spot the error in your test board in episode 2 :P
15:32:04 <ReinH> d-snp: which?
15:32:40 <d-snp> oh wait you do, the bottom row wasn't capitalized, but skipping ahead I see you fix it
15:32:54 <ReinH> I assume DataNode and DataLeaf are part of some product type DataTree = DataNode ... | DataLeaf num, but then why does it import DataNode instead of DataTree... ok I give up
15:33:27 <ReinH> d-snp: don't worry, at least a dozen people mentioned to that and one of them open a pull request :)
15:34:23 <d-snp> haha
15:34:46 <d-snp> I thought so, it's why I didn't mention it before
15:35:13 <ReinH> polarGeometry just traverses the tree and builds up a Tree (the original DataTree-ish thing decorated with positioning and color info)
15:35:53 <ReinH> nfi why they didn't just define the DataNode and DataList types inline. They can't be very long.
15:35:54 <d-snp> btw, if you want to demonstrate haskell's awesome power to have real-life value, and make the chess board come to life on a webpage, scotty is awesome for it
15:36:07 <ReinH> d-snp: scotty?
15:36:16 <ReinH> s/List/Leaf
15:36:21 <d-snp> I did it to my Go implementation which looks a lot like your chess
15:36:31 <d-snp> https://github.com/d-snp/Ergo <-- it's here
15:36:40 <d-snp> scotty is a Sinatra.rb clone for haskell
15:36:40 <ReinH> oooh cool!
15:36:46 <ReinH> double cool
15:37:08 <ReinH> oh clever
15:37:10 <d-snp> you can check out my scotty.hs, it pretty much speaks for itself in simplicity
15:37:53 <d-snp> I thought you might like it being a ruby affectionado too
15:38:00 <ReinH> d-snp: tisk tisk, using get for a non-idempotent action https://github.com/d-snp/Ergo/blob/master/scotty.hs#L24
15:38:04 <ReinH> :p
15:38:14 <d-snp> I..'m sorry :P
15:38:19 <ReinH> lol
15:38:28 <ReinH> I have alerted the REST police
15:39:22 <d-snp> lol I actually did not realise it wasn't idempotent when I wrote it :P
15:39:45 <d-snp> I first wrote it to just return an empty board
15:39:57 <ReinH> the call to updateGame is a hint
15:39:59 <d-snp> obviously later on it actually stored the board in memory, making it less GET worthy
15:40:02 <d-snp> yeah
15:40:59 <d-snp> it's not very production proof code anyways, it throws random index out of bound errors but I'm too busy with my school to go find out why
15:43:37 <sm> d-snp: is that your code, or do you have that trouble with scotty ?
15:43:49 <sm> the errors I mean
15:44:31 <d-snp> my code probably, I ported the go logic from another language in an afternoon, perhaps something didn't map very well
15:45:53 <adnauseam> has anyone here worked through "the haskell road to logic, maths and programming" ?
15:47:33 <ReinH> d-snp: btw you probably want Game to be strict or else your MVar will be full of thunks
15:47:45 <ReinH> or else use MVar.Strict
15:48:03 <d-snp> oh cool thanks
15:49:12 <ReinH> d-snp: you probably want Game to be strict anyway. I'll be making that change to by own board later as well.
15:49:47 <d-snp> btw if you're interested in making efficient game boards, JaffaCake made a go board implementation that's fully optimized
15:49:57 <d-snp> it's ugly as hell sadly
15:49:59 <ReinH> link?
15:50:02 <d-snp> hmm
15:50:32 <d-snp> http://www.mail-archive.com/haskell-cafe@haskell.org/msg56217.html
15:50:35 <d-snp> here it is
15:50:41 <ReinH> d-snp: I'm considering a move to a repa matrix eventually.
15:50:42 <ReinH> At the very least I want something with O(1) lookup and insert, like Array
15:50:45 <d-snp> simon marlow is his real name
15:52:01 <ReinH> hmmm
15:52:44 <ReinH> d-snp: this or something like it? http://www.haskell.org/pipermail/haskell-cafe/2009-March/057982.html
15:53:02 <d-snp> hm? that's what I linked right?
15:53:13 <ReinH> oh you did
15:53:22 <ReinH> I missed it while I was looking :p
15:53:24 <d-snp> :P
15:55:23 <d-snp> ok I should stop procrastinating, I have to finish my related work chapter :P
15:56:13 <adnauseam> make a haskell tool that does your bibliography for you!
15:57:24 <ReinH> ~,
15:58:20 <ssbr_> What would the haskelly alternative to makefiles be?
15:58:46 <Okasu> ssbr_: cabal files
15:59:06 <ssbr_> Okasu: excellent! thank you
15:59:17 <n00b6502> could haskell do it itself being more like a dependancy graph
15:59:43 <adnauseam> am i the only one who thinks of mortal kombat everytime someone says cabal ?
16:00:05 <d-snp> I think of a magic the gathering card :S
16:02:02 <adnauseam> hah! neat
16:02:36 <d-snp> http://gatherer.wizards.com/Pages/Card/Details.aspx?multiverseid=30564
16:02:50 <d-snp> not that was the kind of literary research I should be doing..
16:03:52 <ReinH> n00b6502: cabal does do dependency resolution
16:04:03 <ssbr_> hm, cabal init wants me to say whether or not this is a library or an executable. Why can't it be a library that also has associated executables? :(
16:04:40 <n00b6502> library and test programs ?
16:05:05 <d-snp> ssbr_: it might be a code smell, perhaps your project should have 2 cabal files?
16:05:15 <ssbr_> n00b6502: that'd be one case, but I figure cabal has something for that
16:05:18 <d-snp> (one the library, one the exe)
16:05:36 <ssbr_> d-snp: sure, I don't have any objections to that
16:05:57 <d-snp> not at all sure though, I'm not an expert at cabal or hackage
16:06:41 <Okasu> d-snp: I'm no longer interested in talking to you then
16:06:48 <Okasu> mauke: high five
16:06:53 <d-snp> lol
16:07:17 <d-snp> were you waiting 2 hours for me to say something you could respond to? :P
16:07:37 <Okasu> d-snp: not really :)
16:17:07 <d-snp> compared to other CS papers I read, the Haskell papers I came across in my research are all very readable
16:17:41 <d-snp> perhaps its just because I'm just more familiar with the subject matter..
16:19:08 <ddarius> d-snp: What other subjects have you read about?
16:19:11 <Okasu> d-snp: can you recommend me a paper which explains how to parse curl-binding's output?
16:22:16 <Okasu> meh, it's CSy for random haskell i suppose :/
16:22:32 <Okasu> s/haskell/haskeller/
16:23:52 <ReinH> Okasu: do you understand the type Either?
16:24:19 <Okasu> yep, it's for error handling
16:24:29 <ReinH> do you understand how to interact with IO?
16:24:31 <Okasu> it returns Left or Right
16:24:59 <Okasu> ReinH: yep, put IO stuff in 'container' with '<-' do thing with it
16:25:08 <Okasu> and do*
16:25:11 <ReinH> Okasu: so if you have an Either in an IO container, how do you get it out?
16:25:56 <Okasu> ReinH: i don't know, some monad magick maybe?
16:25:57 <nand`> @hoogle maybeToList
16:25:58 <ReinH> or rather, how do you use do notation to get a handle on it for further processing
16:25:58 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
16:26:17 <ReinH> Okasu: for instance
16:26:18 <ReinH> :t getLine
16:26:20 <lambdabot> IO String
16:26:30 <ReinH> Okasu: how do you use getLine?
16:26:35 <Okasu> line <- getLine
16:26:38 <Jafet> IO containers!
16:26:43 <ReinH> Okasu: and what type is line then?
16:26:50 <Okasu> String?
16:26:52 <ReinH> right
16:27:02 <ReinH> now what's the return value of your curl function?
16:27:13 <ReinH> sorry
16:27:16 <ReinH> what's the type
16:27:22 <Okasu> IO (Either String String)
16:27:37 <ReinH> so if line <- getLine goes from IO String to String
16:27:45 <ReinH> how would you go from IO (Either String String) to Either String String
16:28:15 <Okasu> doc <- openURIString s
16:28:22 <ReinH> Okasu: and now doc is a what?
16:28:30 <Okasu> Either String String
16:28:43 <ReinH> so it's either Left errormsg or Right pageContents, right?
16:28:58 <Okasu> right
16:29:07 <Okasu> http://vpaste.net/Ps8sT now i'm at this point
16:29:13 <ReinH> so now you can case on doc and handle the error or further process the page contents
16:29:25 <ReinH> woah
16:30:27 <Jafet> Probably want (Right doc) <-
16:31:16 <Okasu> and error is http://vpaste.net/9v1sJ
16:32:10 <Jafet> doc is Either String String; Regex only works on String.
16:32:23 <ReinH> paste y u no announce
16:32:27 <ReinH> Okasu: http://hpaste.org/73404
16:32:52 <ReinH> also y no whitespace
16:33:38 <Jafet> :t either
16:33:39 <ReinH> ok http://hpaste.org/73404
16:33:42 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:34:02 <ReinH> Jafet: yes, but I think it would be better to walk through explicitly with the case for pedagogical value
16:34:30 <Jafet> Bah, pedagogy!
16:34:37 <ReinH> oh ffs I can't indent
16:34:59 <Jafet> There should be a version of either with (b -> c) appearing last.
16:36:04 <Jafet> Anyway, in ghc you would write: flip (either (hPutStrLn stderr)) doc $ \text -> do
16:36:57 <ReinH> or you could separate the IO from operating on strings :)
16:38:19 <mk> can a monad that "contains" a single value (such as maybe) be made to fail to satisfy the third monadic law, without failing to meet the other requirements?
16:38:55 <Jafet> Strictly speaking, monads follow all the monad laws by definition
16:39:12 <mk> Jafet: right - "be made to"
16:39:31 <ReinH> mk: here we go again?
16:39:32 <ReinH> here we go again
16:39:42 <ReinH> mk: PEDANTIC MODE ENGAGE - no, because then it is no longer a monad
16:40:07 <mk> ReinH: yes, I had to leave for a bit, and the question didn't really get answered
16:40:13 <mauke> ReinH: that wasn't part of the requirements
16:41:02 <mk> ReinH: I could have sworn I set it up better this time...
16:41:11 <ReinH> mk: I think what you mean to say is, "can a monad that 'contains' a single value (in the same way that Maybe can be said to contain a single value) be made no longer a monad specifically by making it no longer satisfy the third monadic law even though it still satisfies the other two?"
16:41:16 <ReinH> there, simple. ;)
16:41:36 <ddarius> Except "'contains' a single value" is still completely nebulous.
16:41:53 <mauke> Maybe doesn't contain a single value, it contains 0 or 1 values
16:42:02 <ReinH> ddarius: I concretized it by analogy :p
16:42:08 <mk> ddarius: "contains" means precisely that bind will extract that value and feed it into the monadic function passed to it
16:42:17 <ReinH> mauke: Maybe []... mind blown? ;)
16:42:25 <ddarius> mk: That won't happen with Maybe if the value is Nothing.
16:42:25 <dibblego> any description of "monad" with the word "contains" or "container" is less valuable than the air it occupies
16:42:31 <mauke> ReinH: no, kind error
16:43:09 <mk> ddarius: right. Monadic values in Maybe contain either 0 or 1 "original" value. Nothing contains 0 original values
16:43:16 <shachaf> dibblego: "The class Monad contains two methods: (>>=) and return"
16:43:29 <dibblego> shachaf: poo you
16:43:45 <mk> dibblego: see precise definition above, regarding extraction while binding :)
16:44:00 <shachaf> dibblego: But in general I agree.
16:44:02 <Jafet> shachaf: wrong!
16:44:03 <ReinH> Welcome to #haskell, where if there is any way in which your question or statement is even slightly incorrect, you will be made aware of it.
16:44:27 <dibblego> mk: if you redefine "contains" to mean "elephant", it might fit into a zoology book
16:44:31 <Jafet> (it contains three)
16:44:39 <dibblego> four
16:44:39 <ReinH> Jafet: it elephants three, i think you mean
16:44:56 <ddarius> @src Monad
16:44:57 <lambdabot> class  Monad m  where
16:44:57 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:44:57 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
16:44:57 <lambdabot>     return      :: a -> m a
16:44:57 <lambdabot>     fail        :: String -> m a
16:45:06 <ddarius> Less words, more code.
16:45:15 <mk> dibblego: I defined "contains" to mean "the original value will be passed by bind into the monadic function given to bind"
16:45:26 <shachaf> That's a weird definition of "contains".
16:45:29 <mauke> mk: that fits []
16:45:37 <dibblego> mk: yes and that not only incorrect, but in my experience, almost always detrimental to the student
16:45:49 <mk> mauke: what does [] contain?
16:46:02 <dibblego> it skews the student's understanding and leaves them hanging when it comes to actually understanding the concept
16:46:10 <mauke> mk: depends
16:46:15 <dibblego> the instructor must then spend considerable effort deleting that misunderstanding
16:46:15 <mauke> mk: what does Maybe contain?
16:46:15 <ion> If a monad elephants three but noöne is around to slagheap it, does it make a gaultheria?
16:46:44 <dibblego> what does RWST r w s f contain?
16:46:57 <mauke> pain and sorrow
16:47:10 <mk> dibblego: yeah, I disagree. The first monadic law actually requires that pure monadic values "contain" (keep a reference to, closure, whatever) the original value
16:47:16 <pdxleif> None | Just [] | Just a:[] ?
16:47:32 <shachaf> @google "the first monadic law is"
16:47:33 <lambdabot> http://importantshock.wordpress.com/
16:47:33 <lambdabot> Title: Important Shock
16:47:36 <ReinH> please replace the word contains in the following sentence: a monad x 'contains' a iff return a = x
16:47:38 <mk> mauke: pure values in maybe contain the original values. Nothing contains nothing.
16:47:45 <shachaf> Clearly, "The first monadic law is that a monad is a wrapper around another type"
16:47:59 <mauke> mk: what's a "pure value"?
16:47:59 <dibblego> mk: are you disagreeing that this is my experience (and that of many others I might add)? Also, what law says this?
16:48:06 <ReinH> schroedinbug: oh god, the result is "jquery is a monad"... abandon ship.
16:48:13 <ReinH> er
16:48:15 <shachaf> mk: There is no "monadic law" that says that.
16:48:16 <mk> mauke: a value yielded by return
16:48:25 <ReinH> s/schroedinbug/shachaf
16:48:26 <mk> shachaf: examine the first monadic law
16:48:32 <dibblego> mk: which law exactly?
16:48:34 <mauke> mk: ok, then that description works for lists too
16:48:37 <mauke> with s/Nothing/[]/
16:48:46 <shachaf> data Null a = Null
16:48:48 <mk> bind(return(v), f) = f(v)
16:48:59 <dibblego> so the right identity law then?
16:49:15 <mk> this law entails that pure monadic values must keep a reference to the original value
16:49:16 <shachaf> instance Monad Null where return _ = Null; Null >>= f = Null
16:49:17 <Philippa> mk: yeah, that isn't quite as strong as you think it is
16:49:21 <ddarius> Jesus Christ.  This day is on a 4 hour cycle.
16:49:34 <mauke> inb4 timecube
16:49:36 * ion had forgotten how bad that article was.
16:49:37 <Okasu> ReinH: thanks :) but still it doesn't works, look, i refoactor it as you said: http://hpaste.org/73404
16:49:54 * ddarius needs to add triggering to his time series display.
16:50:00 <ion> The third monadic law, and the only one that’s even remotely complicated, is that all monads must be able to feed the value or values that they wrap into another function, as long as that function eventually returns a monad.
16:50:03 * ion cringes
16:50:06 <mk> the trivial monad is an exception
16:50:08 <dibblego> mk: that law says nothing about what you said it does (and back to the point, believing in this "contains" metaphor is an extreme hindrance to learning — have a look at how difficult this discussion is with you for example)
16:50:36 <mauke> dibblego: you're too focused on learning
16:50:43 <dibblego> mk: if you will accept that you might have this wrong, then you might get to see why this "contains" metaphor is so objectionable — because now I have to have tis extremely lengthy discussion
16:51:04 <dibblego> mauke: with learning, I can show that the law says no such thing easily :)
16:51:06 <ddarius> Actually, triggering looks like it may be very easy to do.
16:51:19 <mauke> dibblego: I don't even know what you're talking about
16:51:27 <mauke> I'm only interested in how to break the third law
16:51:29 <mk> dibblego: I'm not trying to teach you
16:51:48 <ReinH> ion: I like the idea of "eventually returns" as somehow being distinct from "returns"
16:52:02 <Philippa> mk: good, I don't think dibblego is trying to be taught by you either
16:52:04 <dibblego> mauke: mk says "I disagree" — I am not sure with what (that the "contains" metaphor is broken in teaching, or that it is broken in practice) or now, that this law says something that is claimed when in fact, it does not
16:52:16 <mk> dibblego: excellent, let's begin. The trivial monad is exempt, but otherwise, pure monadic values must keep a reference. That's my claim. Should you start or should I?
16:52:17 <ion> “I never heared of Monad , But really your explanation is great , thank you”
16:52:17 <dibblego> mk: I am trying to meta-teach you using yourself as the example
16:52:30 <ddarius> mauke: I provided examples of non-monads that break the associativity law but satisfy the unit laws.  Arguably ones that "contain a single value" too.
16:52:38 <dibblego> since you have this wrong ("contains"), we have to go through this incredibly laborious process
16:52:46 <dibblego> I'd rather you were never confused to begin with — start with air
16:52:59 <mk> dibblego: actually, I'll just start
16:53:08 <dibblego> mk: start what exactly?
16:53:11 <mk> bind must pass v into f, when given a pure value, agreed?
16:53:26 <dibblego> telling me how the right identity law gives you permission to your earlier claim?
16:53:29 <mk> proving
16:53:38 <dibblego> no not agreed
16:53:42 <dibblego> wtf is a "pure value"?
16:53:46 <shachaf> "the trivial monad is exempt"
16:53:53 <mauke> dibblego: the result of return v for some v
16:53:53 <dibblego> yeah what is that too?
16:53:57 <pdxleif> (a ->) is a monad - maybe "can yield" is more accurate than "contains"?
16:53:59 <monochrom> a pure value is a value, and vice versa :)
16:54:03 <mk> dibblego: ... a monadic value is pure iff it is yielded by return
16:54:09 <dibblego> thank you monochrom, as I thought
16:54:18 <dibblego> wtf is a "monadic value"?
16:54:29 <augur> isnt there an instance of Monad that has no values?
16:54:31 <Jafet> The value of pure is a pure value
16:54:33 <mauke> dibblego: a value of type m a for some m, a where m is a monad
16:54:35 <ddarius> Oh, trigger is just filter.
16:54:35 <ReinH> pdxleif: are you, in fact, in pdx?
16:54:36 <monochrom> a value of type M X where M is a monad :)
16:54:38 <dibblego> pdxleif: so is RWST r w s f, just to make the point
16:54:40 <augur> like,   data Empty a = Empty
16:54:52 <mauke> augur: that's not a monad
16:54:57 <mk> ...
16:54:58 <augur> mauke: isnt it?
16:55:01 <shachaf> mauke: Why not?
16:55:10 <shachaf> I just gave an instance Monad for it above.
16:55:17 <augur> oh, shachaf, haha nice :)
16:55:19 <mauke> wait, let me ponder
16:55:19 <mk> dibblego: do you understand what a pure value is yet?
16:55:24 <pdxleif> ReinH: Jah, og du?
16:55:30 <dibblego> mk: I completely understand the monad laws; where does the right identity law give you permission to use the metaphorical "contains"?
16:55:37 <dibblego> mk: yes, the word "pure" here is redundant
16:55:43 <mauke> dibblego: why are you talking about the right identity?
16:55:44 <ReinH> pdxleif: wait, what does pdx mean here?
16:55:46 <dibblego> like monochrom said, it is a value
16:55:46 <augur> mauke: its pretty clearly got bind and return
16:55:51 * hackagebot typelevel-tensor 0.1.1 - Tensors whose ranks and dimensions type-inferred and type-checked. (TakayukiMuranushi)
16:55:54 <djahandarie> This conversation is painful to read.
16:55:55 <monochrom> Empty is my favourite monad :)
16:55:55 <dibblego> mauke: that was the law stated earlier
16:55:55 <augur> mauke: return x = Empty; m >>= f = Empty
16:55:56 <mk> dibblego: no, it isn't, because "Nothing" is not pure, but is a monadic value
16:55:59 <Jafet> We need permission to use metaphors now?
16:56:01 <mauke> dibblego: no, that was the left identity
16:56:08 <dibblego> mauke: oh yes thanks
16:56:13 <dibblego> mk: what is not "pure" about it?
16:56:21 <augur> mauke: and i think the identities will hold because everything in that monad is Empty
16:56:22 <ddarius> djahandarie: Try reading it four times in a row.
16:56:24 <mauke> dibblego: it doesn't result from return v for some v
16:56:34 <dibblego> this makes no fucking sense
16:56:35 <donri> > Nothing :: Maybe Int
16:56:37 <lambdabot>   Nothing
16:56:40 <pdxleif> ReinH: The airport code for Portland, Oregon - commonly used to to refer to the city in shorthand, as well.
16:56:41 <mk> dibblego: because another name for "return" is pure, and according to my definition, only values returned by return are to be called "pure". Savvy?
16:56:42 <dibblego> can we just say it is not a value of the type Monad m => m a?
16:56:43 <Philippa> mk: looks like a pure nullary data constructor to me, the word's horribly overloaded
16:56:46 <companion_cube> :t pure
16:56:47 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:56:56 <Philippa> mauke: rather, you can't apply = to a lack of value so the law can't hold?
16:57:01 <ReinH> pdxleif: good! Me too. I was wondering why the German :)
16:57:05 <dibblego> mk: I'm aware of the synonyms for return, pure, point, unit
16:57:08 <MostAwesomeDude> pdxleif: Good times, I'm at OSU.
16:57:10 <Eduard_Munteanu> augur: isn't that the trivial monad?
16:57:10 <Philippa> oh, sorry, mixed conversation threads
16:57:15 <augur> Eduard_Munteanu: i think so!
16:57:18 <Jafet> Empty = Empty
16:57:27 <ReinH> MostAwesomeDude: awesome! High five for oregonianness
16:57:31 <Philippa> Eduard_Munteanu: mapping to 1 and mapping to 0 aren't the same thing
16:57:32 <augur> Eduard_Munteanu: but that atleast demonstrates to mk that monads dont contain things necessarily
16:57:36 <dibblego> this is just too painful, sorry
16:57:44 <augur> and that you cant interpret the laws to be about contained values
16:57:47 <dibblego> all I can is, teachers, this is what happens when you use the "contains" metaphor
16:57:47 <mk> dibblego: great. So. According to rule 1, bind must pass v into f, when given return(v) (aka, a pure value)
16:57:51 <mauke> dibblego: you suck at definitions
16:58:00 <dibblego> mk: I am very very familiar with the monad laws
16:58:03 <dibblego> mauke: ?
16:58:05 <Philippa> mk: *no*
16:58:18 <mk> augur: read up, at the very start I said that trivial is excluded
16:58:23 <Philippa> mk: it must yield the same result as doing so
16:58:25 <pdxleif> ReinH: Jeg snakke solomente Engelsk! Ich kan spreche nicht Deustch.
16:58:26 <Saizan> dibblego: you keep not catching up with the definitions being introduced in this discussion
16:58:36 <Eduard_Munteanu> Philippa: what zero? data Void?
16:58:38 <mauke> dibblego: <dibblego> mk: what is not "pure" about it?
16:58:38 <Philippa> (notice how a slight rephrase now works for trivial?)
16:58:42 <dibblego> Saizan: I keep rejecting them
16:58:49 <rosie> Has anyone seen the s8 data type?
16:58:53 <companion_cube> Philippa: what's the difference?
16:58:56 <augur> MK_FG: if you excluded something, you cant really claim to be talking about monads, can you
16:58:57 <mauke> dibblego: that was after the definition of "pure value" was repeated like two times
16:58:58 <dibblego> yes, we have established that "pure" means any value not of the type Monad m => m a
16:59:07 <mauke> dibblego: no
16:59:08 <Saizan> dibblego: no, it doesn't mean that.
16:59:15 <pdxleif> ReinH: Do you come to pdxfunc in town?
16:59:17 <mk> mauke: nothing, I stopped using the word pure and am instead using the expression "return(v)" aka "pure(v)"
16:59:20 <augur> mk: ^
16:59:23 <ReinH> pdxleif: I haven't yet but I should
16:59:30 <Saizan> dibblego: pure (monadic) value here means a value of the form (return v) for some v
16:59:42 <Philippa> companion_cube: for trivial, you know what the result has to be :-)
16:59:52 <dibblego> then it is an expression
17:00:09 <mk> dibblego: it is the value expressed by the expression
17:00:19 <dibblego> I am not "skipping over" definitions, I am rejecting them because they are ridiculous
17:00:20 <Philippa> Saizan: so we're already... mucking about with non-initial algebras just to describe the operations, which doesn't help any
17:00:33 <dibblego> mk: then that is what I just said, which Saizan and mauke said it is not
17:00:49 <mauke> dibblego: what?
17:00:56 <mk> dibblego: is maybe's "nothing" a pure value according to you?
17:01:05 <Saizan> Philippa: we could be inlining (return v) everywhere instead, i don't find it problematic
17:01:14 <dibblego> mk: I do not use the terminology "pure value" because I have found it to make sense, so "not even no"
17:01:25 <dibblego> *not
17:01:37 <mauke> wat
17:01:48 <mk> dibblego: " yes, we have established that "pure" means any value not "
17:01:49 <Philippa> mk: you realise that it's entirely a matter of perspective, right? Was Nothing impure before someone wrote a Monad instance?
17:01:54 <Saizan> mk: just use (return v) everywhere instead of pure value, we might get somewhere
17:01:57 <dibblego> mk: apparently I was wrong
17:02:17 <mauke> Philippa: yes
17:02:18 <dibblego> thank you Philippa, a voice of reason in a sea of nonsense!
17:02:18 <donri> is the "pure" function named after its argument not its result?
17:02:23 <dibblego> honestly, my patience for this is too thin
17:02:24 <Philippa> (now, stating the perspective in question clearly? That gives you room to go ahead and say things)
17:02:35 <dibblego> please teachers, do not confuse your students, I must leave it at that
17:03:00 <mauke> dibblego: from here it looks like you're too caught up in your own misexpectations
17:03:03 <rosie> Has anyone seen the s8 data type?
17:03:04 <Saizan> i don't see why we must get attached to the conventional meaning of "pure" after a definition has been given.
17:03:13 <Philippa> donri: the result is equivalent to "purely yield the parameter" in the lang in question
17:03:19 <mk> Philippa: I don't know, did return(v) ever return Nothing before we bothered to define return?
17:03:22 <dibblego> mauke: I am not caught up in anything and yes I have expectations that were not anywhere near met
17:03:23 <donri> ah yea
17:04:10 <mauke> dibblego: then what's stupid about the definition of "pure value"?
17:04:16 <dibblego> Saizan: I did not intend to attach to any meaning, except one that could be used (this was an expectation)
17:04:17 <Philippa> mk: *shrug* - yeah, but that's still what you might call a /confusing/ use of language given that there are two language layers involved
17:04:29 <dibblego> mauke: I never used the word stupid, I am trying to make it useful
17:04:56 <mk> anyway
17:05:00 <mauke> dibblego: oops, right. you said "ridiculous"
17:05:00 <Philippa> (anyone who wants a thoroughly impure value can unsafePerformIO themselves)
17:05:15 <dibblego> Philippa: is head/fromJust impure?
17:05:31 <Saizan> dibblego: what's not usable about "t is a pure value <=> exists v. return v ~~> v" where ~~> means "reduces to"?
17:05:32 <Philippa> dibblego: not touching that one with a goddamn bargepole :-)
17:05:36 <mk> bind must pass v into f, when given the value expressed by return(v)
17:05:40 <mk> agreed?
17:05:44 <dibblego> Philippa: just trying to make sense you see :)
17:05:48 <mauke> Saizan: that you typo'd t as v
17:05:50 <dolio> dibblego: No, they aren't.
17:05:57 <Saizan> mauke: gah.
17:05:59 <Jafet> Don't google "impure head".
17:05:59 <monochrom> head [] = unsafePerformIO (throwIO (ErrorCall "onoes"))
17:06:06 <Philippa> dibblego: suffice to say that's one you can start serious flamewars with
17:06:07 <Saizan> dibblego: what's not usable about "t is a pure value <=> exists v. return v ~~> t" where ~~> means "reduces to"?
17:06:14 <dibblego> Saizan: I can go with that
17:06:48 <dibblego> Philippa: I was unaware
17:06:49 <mk> forget it, we don't need to resolve the definition of pure because I'm attempting to not use that term while talking to dibblego
17:06:57 <Jafet> @quote head.[]
17:06:58 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 7,"Unmatched [ or [^")
17:06:58 <Saizan> see, this is what happens when teachers get confused.
17:07:01 <Jafet> @quote head.\[\]
17:07:02 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
17:07:02 <mk> dibblego: bind must pass v into f, when given the value expressed by return(v), agreed?
17:07:21 <Philippa> mk: see, this is where you're having to introduce your magic exception
17:07:22 <ReinH> Jafet: I am now staring into the abyss. Thanks.
17:07:41 <mauke> mk: personally I don't think that's required
17:07:58 <dibblego> Saizan: if I am confused, then in my opinion, it is because this has failed to make sense from the start — if I am wrong, I'd appreciate knowing why and I doubt that will happen here
17:08:07 <mk> Philippa: I introduced it way at the start. If you were here a while ago, as ReinH might attest, I spent a bit of time jokingly calling "Trivial" not a real monad for precisely this reason
17:08:32 <ReinH> mk: it's groundhog hour over here in #haskell
17:08:38 <dolio> It is a real monad, though.
17:08:47 <Philippa> mk: sure, but this is *why* you have to. Given that the conversation is about the teaching, and that it is indeed a real monad...?
17:08:57 <mk> dolio: I agree, I just think it lacks many properties that all other monads have
17:08:58 <Philippa> Now, an "in practice..." statement? That's different
17:08:59 <mauke> I thought it wasn't a monad but I can't break it
17:09:16 <Philippa> mk: all other Monads (as in the class instance), not all other monads
17:09:19 <dibblego> mk: I think you are saying that \f v -> f =<< return v == f v, otherwise, I have no idea
17:09:20 <ReinH> I think the issue is that mk thinks that his exception is the same is the first monadic law (return a >>= l = k a) and that others do not?
17:09:24 <mk> Philippa: no, not in practice. The only exception to this rule is Trivial.
17:09:34 <ReinH> s/l/k
17:10:08 <dolio> There is a monad that takes the rational numbers to the real numbers in the category of metric spaces (or something like that). Are you sure that pure (5/6) "contains" (5/6) there?
17:10:23 <mk> dibblego: I'm saying: bind(return(v), f) = f(v). That means that (except in the case of trivial), bind must pass v into f
17:10:24 <Philippa> dolio: quite!
17:10:25 <ddarius> mauke: Ignoring bottom, it definitely is... trivially.
17:10:33 <mauke> yeah
17:10:39 <dibblego> mk: that's what I said, but I used haskell, right?
17:10:49 <mk> dibblego: great, so you agree
17:10:57 <ddarius> mauke: Including bottom, you can make a definition, but you could just as well define data Trivial a; which would also trivially be a monad (with undefined as the only value.)
17:10:59 <dibblego> mk: yes I have agreed that all monads must satisfy left identity
17:11:14 <mk> dibblego: do you agree that bind must pass v into f?
17:11:22 <dibblego> I might also add, right identity, associativity
17:11:25 <ReinH> except where it doesn't
17:11:27 <dibblego> mk: no, I only agree with that
17:11:44 <mk> dibblego: with what?
17:12:00 <dibblego> all monads must satisfy left identity (which you and I have spelled out), right identity and associativity laws
17:12:06 <mk> that's... interesting
17:12:11 <mk> what does it have to do with our discussion?
17:12:29 <mauke> dibblego: wait, are you agreeing with the first law but not with what it says? or what is going on here
17:12:41 <Philippa> mauke: but not with what mk says it says
17:12:41 <dibblego> wat?
17:12:43 <mk> do you not agree because you don't understand, or because you have a reason or counterexample?
17:12:50 <mauke> Philippa: ok, much better
17:12:51 <monochrom> I surely don't know what is going on here. :)
17:13:11 <dibblego> I agree that all monads must satisfy all laws; I do not agree with what you said, whether it was an attempted paraphrase or what
17:13:13 <nand`> I'm trying to piece together what the argument is about myself
17:13:15 <Philippa> monochrom: a pissing contest about just how much semantic junk you carry around if you buy a 'monads contain values' analogy
17:13:36 <mk> monochrom: I'm proving that "container" is an appropriate term for monadic values, grab popcorn
17:13:41 <nand`> I think mk is trying to show that Trivial breaks in the presence of ⊥ or something
17:13:49 <ddarius> nand`: No.
17:13:52 <mauke> nand`: where did that come from
17:14:06 <mk> nand`: I'm explicitly excluding trivial
17:14:10 <ReinH> nand`: that's wrong and you should FEEL wrong
17:14:15 <monochrom> Trivial doesn't break the monad laws. that's what upsetting some people here.
17:14:16 <nand`> mauke: well, isn't he complaining about how return v >>= f for trivial is *not* f v ? the only way I can see that happening is with ⊥
17:14:18 <ReinH> or something
17:14:21 <Philippa> see, personally I go with "monads-in-haskell describe languages whose computations 'yield haskell values' in some sense", but "container" is pushing it for me
17:14:24 <mauke> nand`: no, he isn't
17:14:31 <shachaf> mk: "container" is not an appropriate term.
17:14:33 <nand`> I guess I haven't been paying enough attention to the argument then
17:14:44 <shachaf> Does id contain an Int?
17:14:52 <shachaf> @quote /bin/ls
17:14:53 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
17:14:53 <mauke> shachaf: no
17:14:55 <dibblego> shachaf: that is this (now lengthy) contention
17:15:03 <ReinH> "context" is thrown around a lot and seems sufficiently vague as to not have much baggage
17:15:18 <monochrom> I actually don't mind the container view. because we can always bend the meaning of "container"
17:15:22 <mauke> I agree with mk, btw
17:15:27 <mauke> counterexamples welcome
17:15:29 <dolio> shachaf: Clearly only const 5 contains an Int.
17:15:43 <mk> "pure" monadic values (ie, those returned by return/pure) must contain the original value. If they do not, then bind cannot extract them, so as to feed them into f
17:15:45 <mk> bind(return(v), f) = f(v)
17:16:06 <Philippa> mauke: my problems on the informal side of the argument, certainly
17:16:16 <ReinH> schroedinbug: is 'produces' a better verb? As in IO String produces a String?
17:16:23 <mk> containment = keeping a reference, or a closure, or whatever, which is encapsulated in some way. That's a reasonable and intuitive use of "contains"
17:16:27 <ReinH> why do I keep putting that sch in there :(
17:16:37 <ReinH> shachaf: is 'produces' a better verb?
17:16:39 <monochrom> you don't know what f does to v. you don't know whether f ignores v or not. in fact, no monad operation allows you to confirm or refute it.
17:16:46 <ddarius> nand`: return v >>= f = f v for Trivial too.  They both equal the single value of Trivial.
17:17:00 <nand`> mk: that's an excellent argument to prove why monads are not containers -> some monads are monads despite never ‘passing along any values’
17:17:13 <mauke> nand`: which ones?
17:17:13 <shachaf> mauke: What do you agree with mk about?
17:17:22 <mauke> shachaf: that return v contains v
17:17:28 <mk> nand`: *pure monadic values*, not "monads", unless you want to be more specific
17:17:35 <monochrom> the law bind(return(v), f) = f(v) equally says: if f ignores v, then bind is allowed to ignore return(v), too
17:17:36 <nand`> ddarius: return () >>= undefined  doesn't throw an error, but undefined () does
17:17:36 <shachaf> mauke: Even in the case of data Null a = Null?
17:17:40 <mauke> shachaf: no
17:17:59 <shachaf> I thought you were agreeing with 17:13 <mk> monochrom: I'm proving that "container" is an appropriate term for monadic values, grab popcorn
17:17:59 <mauke> shachaf: the full statement is: return v contains v except for Null
17:18:00 <nand`> mauke: Trivial
17:18:06 <mk> monochrom: it is impossible for bind to determine whether f "ignores" (?) v
17:18:24 <mauke> nand`: Trivial was explicitly excluded
17:18:26 <mauke> nand`: any others?
17:18:28 <shachaf> mauke: Except for Null and "data Void a", I guess, if you allow _|_
17:18:34 <nand`> mauke: Const
17:18:35 <ddarius> nand`: Feel free to redefine Trivial to data Trivial a; where instance Monad Trivial where return = undefined; (>>=) = undefined
17:18:35 <mauke> shachaf: I don't allow bottom
17:18:40 <mauke> nand`: what is Const?
17:18:47 <shachaf> data Const r a = Const r
17:19:00 <ddarius> nand`: The data Trivial a = Trivial definition is assuming no bottom.
17:19:04 <nand`> instance Monoid r => Monad (Const r)
17:19:21 <dolio> Const r fails right identity for most r.
17:19:48 <nand`> ddarius: ...that's my point
17:19:49 <mk> if trivial can produce two values, it isn't really trivial ;)
17:20:01 <monochrom> do you allow StateT Int Trivial? it is not identical to Trivial...
17:20:19 <nand`> oh; wait, Const is not a monad
17:20:22 <ddarius> nand`: The qualifications I gave were given the whole time, even in the statement I said to you.
17:20:24 <nand`> dolio is right
17:20:34 <Philippa> monochrom: it is up to denotational equality
17:20:38 <shachaf> (Const r) is Applicative, though, for Monoid r.
17:21:06 <dolio> Wait, sorry, left identity.
17:21:06 <shachaf> mauke: What does "contain" mean?
17:21:08 <Philippa> you just found a couple more fancy names for Trivial
17:21:20 <ddarius> I haven't proven it, but I think data Trivial a = Trivial (or alternatively data Trivial a;) is the only monad with a non-mono return in Haskell.
17:21:34 <Philippa> ddarius: likewise
17:21:50 <Philippa> I *still* think containers are a shitty analogy, but the reasons aren't formal
17:21:54 <mauke> shachaf: I don't know how to define it formally
17:22:07 <mk> shachaf: keeps an encapsulated reference to (as with a closure, or otherwise). The point is that the original value must be kept around "in" the pure monadic value (pure being, returned by return)
17:22:33 <shachaf> mauke: Then I don't really know.
17:22:37 <nand`> ddarius: I must have missed it amidst the noise, doesn't really matter
17:22:46 <mauke> shachaf: maybe defined along the GC
17:22:57 <shachaf> mauke: Oh, it's an operational thing?
17:23:06 <mauke> shachaf: "as long as you have return v, you can't collect v" or something
17:23:08 <Philippa> mk: more formally safe, it must be possible to get the original value out. No need for an operational spec
17:23:10 <dolio> Does 'pure 5' contain 5 for Cont?
17:23:14 <dolio> Or does that depend on r?
17:23:30 <monochrom> I know how to define it formally. you have to add a getter.
17:23:39 * ddarius constantly forgets forevers with pipes code.
17:23:42 <dolio> How about Cont Bool?
17:23:58 <mauke> monochrom: how do you add a getter to IO?
17:24:14 <mk> Philippa: another way to get the value out is for bind to keep a mapping of pure values back to original values. In this case, the reference would be held by bind, not by the pure monadic value
17:24:26 <monochrom> I would avoid adding a getter to IO
17:25:21 <dolio> Cont (), of course, is trivial, so it doesn't contain 5, apparently.
17:25:25 <Philippa> we have a "with-patterned getter", it's just limited to functions that stay in the monad
17:25:27 <Saizan> "return is mono" seems a nice way
17:25:31 <monochrom> the formal getter idea clarifies the situation IMO. it reduces the original proposition to "a monad is a container iff the monad is a container"
17:25:51 <mk> Philippa: but if you have a language where you can add new values, it's impossible for bind to have such a mapping in advance. So you end up using pures (and other monadic values) as containers
17:27:46 <monochrom> "return is mono" also gives a similar reduction
17:29:57 <mk> monochrom: that's why I'm choosing a definition of the form "the structure in which the monadic value is realized keeps a reference"
17:30:52 <mk> anyway, pure monadic values contain original values. QED? ;)
17:30:54 <ddarius> monochrom: That's the way of most "monad as container" analogies.  "A monad is a container, but only if you limit yourself to monads that are containers."
17:31:14 <monochrom> yes, I want to convey that
17:31:42 <Cale> Or you generalise your notion of container sufficiently :)
17:31:43 <mauke> I want to go along another axis
17:32:02 <mauke> a monad is a container, but only if you limit yourself to values that are containers
17:32:07 <monochrom> Cont Bool is a pretty interesting consideration
17:32:19 <ddarius> Cale: Yes, that's the other approach.  "A monad is a container where 'container' means monad."
17:32:23 <monochrom> @unmtl Cont Bool a
17:32:24 <lambdabot> (a -> Bool) -> Bool
17:32:40 <Philippa> ddarius: that's unfair. Where 'container' means pointed :p
17:32:56 <Cale> pointed functors all look somewhat like containers
17:33:00 <mk> all monads (except trivial, which by fiat is not a real monad) have pure monadic values that keep references back to original values. So sayeth the first monadic law.
17:33:03 <Cale> maybe you could say any functor
17:33:51 <Saizan> mk: btw, i wouldn't keep using "pure monadic value" in the future
17:34:38 <mk> Saizan: it's been defined. Also, seems sensible that all x such that pure(v) = x are called "pure"
17:35:00 <mauke> mk: yes, but apparently people suck at definitions
17:35:13 <mauke> and it's not obvious that it's a synthetic term
17:35:27 <Saizan> it's been defined with considerable pain for the people in this discussion
17:35:29 <Philippa> so, is teaching anywhere in the scope of the discussion? Or are we just in an alpha equivalence pissing contest?
17:35:35 * nand` .oO( Pointed values )
17:35:50 <Philippa> nand`: normally just "points"?
17:35:53 <ddarius> Philippa: Some of the latter, none of the former, mostly neither.
17:35:57 <Saizan> meanwhile it goes against accepted meanings of "pure"
17:36:07 <mk> mauke: like a term of art? Well, that's why you define it. Or you can call it Pure. I hope it catches on, because it makes perfect sense given pure(v)
17:36:08 * ddarius goes and gets food.
17:36:12 <Saizan> and there are too many already.
17:36:40 <mk> Saizan: what's the accepted meaning of "pure monadic value"?
17:36:49 * Philippa hopes it dies a firey death, because "I have this one link that works!" really isn't a good reason for throwing oil on a burning pile of overloaded crap
17:36:51 <mauke> mk: that it's nonsense
17:37:09 <Philippa> "I didn't built it with unsafePerformIO", perhaps :p
17:37:21 <mauke> and that people who use it don't know what they're talking about
17:37:33 <Philippa> but "this is not a useful phrase to think with" would be one. It's too damn /big/, if nothing else
17:37:34 <Saizan> mk: i'm talking about "pure" by itself, and people expect meanings to compose
17:37:47 <Philippa> right, especially when you've got a three word term
17:38:00 <mk> mauke: I like to call things that I make using a particular function names based on that function. So like, if I use a function called "string" to create things, I like to call them strings. Roughly the same deal here :)
17:38:25 <mk> Saizan: do you have an equally-memorable alternative?
17:38:36 <Philippa> "'return'ed values"
17:38:44 <mauke> puree
17:38:57 <Philippa> "pure [in the monad]" is also good
17:39:19 <Philippa> but requires a linguistic metaphor instead of the container metaphor - more fully, it's "pure [in the language described by the monad]"
17:39:42 <nand`> when I think of ‘pure’ I think of do { x <- f; return (x,x) } = do { x <- f; y <- f; return (x,y) }
17:39:50 <Saizan> (pure v), you can drop the quantifier
17:40:35 <mk> Saizan: I tried calling them return(v), but someone complained that that was an expression and not a value ;)
17:40:42 <mauke> nand`: that doesn't mean f has no effects, it just means it's idempotent
17:41:16 <nand`> mauke: fair point; maybe f >> return () = return () -- ?
17:41:35 <nand`> but it's an ambiguous label in general
17:41:37 <nand`> eg. consider lists
17:41:48 <nand`> I'd certainly call them ‘pure’ but they don't in general respect those two equalities
17:41:55 <mauke> lists of length 1 are pure
17:43:08 <mk> does any monad exist, whose monadic values "contain" only 1 or fewer original values (e.g. Maybe, but not List), where there is some way to alter them to break the 3rd monadic law, but meet all other requirements?
17:43:49 * shachaf has no idea what mk is saying anymore.
17:43:52 <mk> where "contains" means "the values can be extracted from the monadic value passed to bind, by bind, to be given to the monadic function passed to bind"
17:44:05 * shachaf follows ddarius's example.
17:44:17 <monochrom> I think, afterall, there is a 0th law of monads. "return and bind are parameteric polymorphic"
17:44:24 <Jafet> Is there a Monad Maybe where return = Just, and return a >>= f == f a, but not a >>= f >>= g == a >>= f.g?
17:44:29 <mk> shachaf: hmm?
17:44:53 <nand`> monochrom: huh? isn't that given by the type signature already?
17:45:09 <mk> Jafet: if that's directed at me, I'm not yet good enough at reading notation
17:45:19 <monochrom> yes. call it type sig, call it law.
17:45:38 <Jafet> mk: it's the same question as yours
17:45:48 <monochrom> in fact the compiler checks exactly that law and no other
17:45:58 <Saizan> Jafet: Either e
17:46:05 <mk> what I'm getting at, is that it's possible to "break" list by making list's bind "reverse" the values in the list passed to it before processing it as usual
17:46:12 <nand`> I'm not entirely sure I'm comfortable with that; to me a ‘law’ is something that isn't statically enforced and has to be guaranteed by the instance
17:46:43 <monochrom> to me every requirement at every level is a law
17:47:21 <mauke> @src Writer
17:47:22 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:48:02 <mk> it seems to me that this is possible only by virtue of the fact that lists have many ordered values. It seems that the third law applies only in cases of monads that order their "contained" values, and in no other cases
17:48:12 <mauke> mk: what about ddarius's two examples?
17:48:20 <mk> so if you don't order your values, you get a free pass with respect to the third law
17:48:37 <mk> mauke: which ones? I might have missed or had trouble understanding them
17:48:55 <Saizan> it's pretty easy to modify Writer to do what you ask
17:48:57 <mauke> data M a = L a | R a
17:49:03 <mauke> the other was Writer T
17:49:26 <pdxleif> Forget about monads. It's a beautiful day out. Go have some ice cream.
17:49:44 <mauke> pdxleif: forget about irc. it's the middle of the night. go to bed
17:49:49 <Philippa> it's night out. Though still warm enough for ice cream...
17:50:08 <mk> mauke: data M is just the Either monad?
17:50:11 <monochrom> if you live in the first world, it is always warm enough for ice cream
17:50:18 <mauke> mk: no, wrong kind
17:51:03 <mk> what do you mean?
17:51:15 <Philippa> Either takes two parms
17:51:25 <Philippa> M takes one, and this is deliberate
17:51:33 <Saizan> any good reads on how pretty printers decide where to put spaces?
17:51:35 <nand`> M = Join Either
17:51:54 <Philippa> Saizan: the Wadler-Leijen paper?
17:52:05 <Saizan> i guess so
17:52:35 <mauke> mirror (L x) = R x; mirror (R x) = L x
17:52:42 <mk> what is M's return?
17:52:46 <mauke> return = R
17:52:47 <shapr> I met Wadler and Leijen at the same time, but only Daan went to lunch with me.
17:52:58 <mauke> R x >>= f = f x
17:53:08 <mauke> L x >>= f = mirror (f x)
17:55:50 <mk> is this equivalent to data M a = R a Boolean?
17:56:07 <mauke> yes
17:56:33 <mauke> x + x = x*2
17:56:34 <Okasu> http://hpaste.org/73404 so, whats wrong with it?
17:56:41 * mauke knows how to algebra
17:56:45 <mk> ok - still not there for seeing this as a counterexample though...
17:57:13 <mauke> mk: a value of type 'M a' contains exactly one 'a'
17:57:22 <mauke> and the first two monad laws hold
17:57:47 <mk> how does the third fail?
17:58:15 <mauke> haven't looked closely yet
17:59:27 <nand`> looks to me like it should be associative
17:59:53 <Cale> Okasu: I think you want  let matches = getAll...
17:59:56 <nand`> join behaves like a xor when it comes to R/L; and xor is associative isn't it?
18:00:34 <mk> I don't think that it does... I mean, I'm not sure exactly how bind works, but if I put a falsey value in there, I get one out just fine
18:01:34 <ddarius> I'm not sure about the L/R one, though you could likely make it fail with an appropriate definition, but at any rate, the Writer T one is much more obvious and even more "single valued".
18:01:52 <ddarius> And, as mentioned the L/R one reduces to Writer.
18:02:00 <mk> ok, so it looks like bind just discards any false "metadata" passing through it, turning it into true?
18:03:28 <mk> how does writer work?
18:03:33 <Okasu> Cale: nope, error changes slightly, now its:
18:03:33 <Okasu>     No instance for (RegexContext
18:03:34 <Okasu>                        Regex String (AllTextMatches [] Char))
18:03:50 <mk> it just appends to the non-pure "metadata", doesn't it?
18:03:50 <ddarius> mk: Read an introduction or the definition.
18:03:56 <Okasu> but still arising from a use of `=~'
18:04:48 <ddarius> (=~) and similar APIs are one of the worst things to happen to Haskell libraries.
18:04:58 <nand`> ddarius: in general; it seems to be the case that Writer X for some X which satisfies left and right identity but not associativity violates only the third law
18:05:02 <mk> ddarius: how does it break the third law?
18:05:08 <Okasu> ddarius: i've noticed that :)
18:05:27 <nand`> mk: T isn't associative since it reifies the AST it was built from
18:05:37 <ddarius> nand`: Yes.
18:05:51 <ddarius> The monad laws directly follow the monoid laws for Writer.
18:06:04 <Cale> look at http://hackage.haskell.org/packages/archive/regex-base/0.93.2/doc/html/Text-Regex-Base-Context.html for the instances
18:06:11 <mk> nand`: shorter words?
18:06:26 <nand`> mk: Branch a (Branch b c) ≠ Branch (Branch a b) c
18:06:26 <ddarius> mk: You can easily calculate what each side of the associativity equation would be and verify that they are not equal.
18:06:29 <mk> what is the T in writer T?
18:06:38 <nand`> data T = Leaf | Branch T T
18:06:48 <mk> how does writer use T?
18:07:11 <nand`> (a,b) >>= f = first (a++) (f b)
18:07:19 <nand`> something like that
18:09:46 <mk> in plain english? For example, the maybe monad's bind will if nothing, then yield nothing, otherwise extract original and pass it to f, yielding the result
18:10:13 <mk> s/will/will:
18:10:47 <mauke> plain Haskell > plain English
18:11:18 <ddarius> I said "Less words, more code" a long, long time ago.  It would dramatically shorten and improve this ridiculous dialogue.
18:11:30 <pharaun> still at it? :)
18:12:19 <nus> @src Maybe (>>=)
18:12:20 <lambdabot> (Just x) >>= k      = k x
18:12:21 <lambdabot> Nothing  >>= _      = Nothing
18:12:22 <monochrom> I went "show actual code" which somewhat means "no words"
18:12:35 <mauke> @src words
18:12:36 <lambdabot> words s = case dropWhile isSpace s of
18:12:36 <lambdabot>     "" -> []
18:12:36 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:12:38 <nand`> mk: ‘will pass the value to the function then join the two logs with mappend’
18:12:47 <monochrom> word!
18:13:18 <mk> inc nand`
18:16:10 <mk> the logs are stored in the T structure?
18:16:47 <Saizan> mk: yes
18:16:57 <ddarius> Yay words.  Their ability to multiply confusion never wanes.
18:17:20 <ddarius> The "log" in this case -is- the T structure.  Though calling it a "log" is a bit silly.
18:17:41 <monochrom> you can call it "ln" for the kicks :)
18:18:01 <ddarius> "Get your natural logs from this tree."
18:18:23 <dotnull> lol
18:18:58 <mk> the log is the... as far as I understand, the temporal order of calls. So, f is called first, and then g
18:19:12 <ddarius> *sigh*
18:19:34 <mk> isn't the result (V, Branch "f" "g") in both cases?
18:19:45 <mauke> how did you get strings into T?
18:19:49 <ddarius> Where are these strings coming from?
18:20:01 <monochrom> perl :)
18:20:14 <mk> mauke: I'm not sure. Presumably bind appends to the originally "empty" T value
18:20:18 <monochrom> actually, more like shells and tcl
18:20:19 <mauke> mk: wat
18:20:19 <nand`> I shouldn't have used words should I?
18:20:25 <ddarius> nand`: No.
18:20:33 <mk> mauke: as in, (V, Leaf)
18:20:38 <mauke> mk: I asked: how did you get strings into T?
18:20:49 <ddarius> nand`: The definition of Writer is short and clear.  Much shorter and clearer than any actually comprehensive, let alone enlightening, description.
18:20:55 <mk> mauke: didn't I answer?
18:20:59 <mauke> mk: you didn't
18:21:08 <nand`> by ‘log’ I meant ‘monoidal log’; something that seems to be used in other situations as well
18:21:12 <mauke> mk: in fact, I don't even see what your "answer" has to do with my question
18:21:54 <mk> mauke: can you be a bit more informative than "wat"?
18:22:13 <mauke> mk: can you be a bit more informative than "Presumably bind appends to the originally "empty" T value"?
18:22:21 <mauke> what does that even mean?
18:22:49 <mk> bind(return(v), f) = f(v)
18:22:51 <mk> oops
18:23:14 <ddarius> Why do you keep writing that using a C-style syntax?
18:23:59 <mk> bind(bind(mv, f), g) = bind(mv, Lx[ bind(f(x), g) ])
18:24:05 <ddarius> wtf?
18:24:16 <mk> ddarius: ...perhaps because it's easier for you to interpret than it is for me to attempt to write it in haskell?
18:24:17 <ion> ಠ
18:24:27 <n00b6502> c syntax .. habit and many must go back to c style languages
18:24:32 <mk> that's the third monad law, Lx is lambda
18:24:32 <nand`> ddarius: ‘C-style’: nonsense, ‘bind’ is just uncurried
18:24:45 <ddarius> mk: Why are you having this conversation when you clearly aren't familiar with Haskell or monads?
18:24:56 <aristid> nand`: what's Lx[ ] then? an agda-style mixfix operator?
18:25:04 <mk> ddarius: because I'm trying to understand both
18:25:08 <nand`> aristid: yeah, that part breaks it :(
18:25:22 <mauke> mk: what do these monad laws have to do with T?
18:25:31 <ddarius> mk: Try to understand Haskell first.  Then when you get comfortable with that, worry about learning monads.  Then, if your questions still haunt you, ask them again.
18:25:42 <nand`> I think the two clearest formulations of the third monad law are:  join . join = join . fmap join
18:25:51 <nand`> and f >=> (g >=> h)  =  (f >=> g) >=> h
18:26:02 <ion> and bind(bind(mv, f), g) = bind(mv, Lx[ bind(f(x), g) ])
18:26:13 * mauke punches ion
18:26:30 <n00b6502> flechette operators
18:26:51 * ddarius doesn't know why this copy of byorgey's paper doesn't have references.
18:27:11 <mauke> it was passed by value
18:27:16 <ion> ddarius: Is it in C? It only has pointers.
18:28:20 <mk> ddarius: I'm pretty sure that's irrelevant
18:28:22 <Saizan> mk: the details are here btw http://hpaste.org/73409
18:28:22 * ion managed to decipher mk’s line: (mv >>= f) >>= g  =  mv >>= (\x -> f x >>= g)
18:28:23 <aristid> ion: as pun-ishment for your bad puns, you must use perl for a week.
18:28:54 <ion> I suppose that is a valid way to put it, although the syntax makes it hard to read.
18:29:11 <aristid> oh, the Lx[] is a lambda? that explains things
18:29:48 <mk> mauke: I'm looking at that third law I posted. I'm assuming that f and g are monadic functions, and they spit out a value, and a "log value"
18:29:50 <ddarius> mk: If you can't understand what we're saying or the definitions of what you are talking about, how do you plan to "prove" anything and what do you plan to get out of the conversation?
18:30:08 <mauke> mk: still nothing to do with strings and T
18:30:12 <mk> ddarius: what? I'm not trying to prove anything
18:30:51 <mk> ddarius: I'm trying to falsify a hypothesis I have about the third law
18:31:06 <ddarius> mk: Proving something is false, is still proving something.
18:31:40 <mk> mauke: right, so the log value is just a string - f logs "f", and g logs "g", and bind appends the two
18:31:47 <mauke> mk: the log values not a string
18:31:50 <ddarius> nand`: See what you've done?
18:31:50 <mauke> mk: the log value is a T
18:31:52 <mk> ddarius: I'm aware, and I'm not trying to prove anything false
18:32:10 <ddarius> mk: So you are not trying to falsify a hypothesis?
18:32:11 <mk> mauke: right, a T containing a string, yeah?
18:32:12 <ReinH> does this look like a reasonable way to specify chess piece mobility? https://gist.github.com/1e8b5a91a21257dea290
18:32:14 <mauke> mk: no
18:32:20 <mauke> mk: T does not contain a string
18:32:46 <mk> ddarius: no, I am. I'm looking for someone else to disprove a hypothesis?
18:32:59 <ddarius> mk: Okay.  I did.  You can't understand it.  See my earlier question.
18:33:00 <nand`> ddarius: :(
18:33:04 <nand`> ddarius: I'm sorry
18:33:30 <ReinH> welcome back to our our hourly "monads: totes containers" discussion.
18:33:39 <mk> mauke: strange - what am I missing here?
18:33:48 <mauke> mk: not sure
18:33:50 <ReinH> unlines . nub . unlines
18:33:52 <mauke> the definition of T maybe?
18:33:58 <ReinH> words, w/e
18:34:01 <ddarius> mk: You are missing a working understanding of Haskell.
18:34:26 <ReinH> gloves: officially off
18:35:44 <mk> ddarius: you're missing a working understanding of explaining what you're saying. You waste time imposing arbitrary "you must know this much for me to be capable of explaining things" criteria all you want, but I'm not interested
18:35:45 <BMeph> ReinH: bitch: officially slapped
18:36:12 <mauke> BMeph: :-(
18:36:31 <mk> if you can explain, great, if you can't be assed, maybe someone else will be kind enough
18:36:41 <mauke> Saizan did
18:36:42 * nand` sobs
18:36:51 <nand`> so much contempt in my #haskell
18:37:17 <monochrom> all of you are scaring off OceanSpray
18:37:41 <ReinH> monochrom: I C what you did there
18:37:49 <BMeph> nand`: #haskell...so young, so angry. ;)
18:38:50 <ddarius> mk: I'm sure someone is willing to teach you a working knowledge of Haskell from scratch despite your apparent lack of interest in going out and achieving this yourself.  They'll only need to talk to you for a few weeks or months.
18:39:06 <aristid> BMeph: only 11 years old
18:39:18 <monochrom> I'm willing to explain for money
18:39:23 <ddarius> mk: Then they'll be able to explain the counter-example I've provided to you.
18:39:57 <ReinH> I think I'm going with this: https://gist.github.com/1e8b5a91a21257dea290
18:40:01 <nand`> I'll undercut whatever monochrom's asking; by forking off ‘cat lyah’
18:40:31 <mk> ddarius: I'm not interested in arguing about how much Haskell I know with you. I'm having trouble with this, if you aren't interested in helping, then just chill out
18:41:23 <aristid> nand`: you have lyah sitting around as a text file?
18:41:27 <mk> anyway, I'm reading what Saizan posted. I think I was under the impression that T was abstract?
18:41:38 <aristid> nand`: don't you lose all the important drawings that way? :P
18:41:45 <nand`> aristid: actually, I do; as a PDF
18:41:54 <monochrom> <nand`> data T = Leaf | Branch T T
18:42:05 <aristid> nand`: catting a PDF on a console is not a recommended exercise
18:42:05 <monochrom> that was half an hour ago
18:42:15 <ddarius> monochrom: Not to mention when I initially provided it.
18:42:17 <mauke> and more than that when ddarius said it
18:42:29 <mk> monochrom: yeah. I thought that t was something like Branch t t
18:42:30 <nand`> aristid: never said anything about a console; I could be cat'ing it into a pdf renderer for all we know :)
18:42:35 <monochrom> right, I only looked for the most recent
18:42:45 <nand`> or over a pdf renderer on the other side of the internet, linked with ‘nc’
18:42:54 <aristid> nand`: well that'd be a gratuitous use of cat, which is even worse
18:43:23 <nand`> ddarius │ data T = Leaf | Branch T T
18:43:30 <nand`> my reproduction was quite faithful
18:43:55 <aristid> mk: the type is recursive. the T is the same
18:44:30 <mk> aristid: right - I was confused because I was caught up on logs storing strings (perhaps in tree-like datastructures)
18:44:37 <ReinH> nand`: this is why god invented < ;)
18:45:28 <aristid> mk: this is just a tree, no data attached.
18:45:58 <Saizan> data attached wouldn't change things noticeably
18:46:08 <monochrom> I don't know. a typical computer has gigabytes of ram these days. if even 0.1% of that is used for irc scroll buffer, you would be able to search for these things trivially. or maybe you already have that scroll buffer, but you never intend to use it
18:46:34 * ddarius predicts this will eventually end in mk coming to some false epiphany, which will really be better of for everyone, well except mk.
18:47:24 <mk> ddarius: get off my case :)
18:47:42 <ReinH> ddarius: you mean like "monads contain things"?
18:47:47 <ReinH> because that worked out well for everyone
18:47:59 <ddarius> ReinH: A different one.  That one is used already.
18:48:15 <aristid> re-use of false epiphanies not allowed here.
18:48:18 <ddarius> ReinH: Anyway, it would have to be "final" enough for the current purpose.
18:48:19 <mk> ReinH: well, pure monadic values contain original values - that much has been proven
18:48:24 <mauke> linear epiphanies
18:48:36 <ReinH> mk: fsvo pure, contain
18:48:43 <aristid> is Const a valid monad?
18:48:47 <nand`> no
18:48:51 <aristid> too bad
18:48:51 <ddarius> aristid: Only when it's Trivial.
18:49:03 <aristid> ddarius: what's Trivial?
18:49:09 <nand`> Const ()
18:49:12 <ddarius> Const () (or Const Void)
18:49:17 <mk> ReinH: yeah yeah. pure = return(v), and contains = its underlying structure keeps a reference to, perhaps via closure
18:49:25 <nand`> ddarius: Const Void doesn't seem right
18:49:31 <nand`> how would return work?
18:49:36 <ddarius> return = undefined
18:49:38 <aristid> nand`: just put a bottom there
18:49:42 <ReinH> mk: only for monads that can be run though
18:49:47 <ddarius> Const Void is if you are caring about bottoms.
18:50:03 <nand`> ah, fair enough
18:50:12 <ddarius> Really, the trivial monad is the one with one value either bottom or a non-bottom value if we are ignoring bottom.
18:51:00 <mk> ReinH: precisely
18:51:06 <ddarius> ...
18:51:40 * ddarius applauds Saizan's use of code, fruitless though it may be.
18:51:41 <aristid> so the Trivial monad proves that "pure monadic values" need not actually contain the value anywhere
18:51:49 <mk> ddarius: we ignore bottom
18:52:27 <mk> aristid: yes, as has been mentioned at the very start of the proof
18:52:44 <aristid> which proof?
18:52:56 <shachaf> mk: As in, going and getting food.
18:53:02 <shachaf> All y'all're still on about this?
18:53:21 <mauke> shachaf: not really, it's cyclic
18:53:32 <monochrom> I guess it's boring Sunday and no one has anything better to do
18:54:05 <ddarius> shachaf: I propose you talk about spacesuits and nuclear waste until mk is enlightened.
18:54:12 <mk> aristid: the one about pure monadic values "containing" (their structure keeping reference to) the original value
18:54:16 <shachaf> @quote nuclear.waste
18:54:16 <lambdabot> dons says: Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
18:54:16 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
18:54:37 <shachaf> That's a space*suite* full of nuclear waste.
18:54:43 <shachaf> Very different from a spacesuit.
18:54:59 <mk> yes, http://koweycode.blogspot.com/2007/01/think-of-monad.html
18:55:04 <mauke> @quote Duqicnk
18:55:05 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
18:55:24 <monochrom> oh, I finally understand now. I was thinking spacesuit all along. why would anyone fill a spacesuit with waste rather than a good human?
18:55:48 <aristid> shachaf: not sure if that was trolling (in the quote) or a serious attempt to explain monads
18:56:06 <monochrom> it was a serious attempt
18:56:22 <mk> monochrom: because "waste" is supposed to represent the harm that the IO etc. monads are purportedly saving the rest of the language from
18:56:40 <ReinH> oh those monads and their purporting
18:56:43 <monochrom> later, we knew better
18:56:47 <shachaf> aristid: It was a parody.
18:57:00 <aristid> shachaf: monochrom contradicts you about that
18:57:03 <mk> it's too bad that it didn't include the monadic lover
18:57:13 <aristid> shachaf: and because monochrom is much older than you, he's right
18:57:48 <ddarius> For the spacesuit(e) one, dons was certainly doing a parody, but it was inspired by a mix of original serious ones.
18:58:15 <monochrom> well, one Zachary Landau said he found it helpful...
18:58:22 <aristid> oO
18:58:48 <monochrom> trust ddarius more than me on this
18:59:00 <aristid> ok.
18:59:43 <monochrom> a parody reflects someone else's serious attempt afterall
18:59:58 * monochrom loves parodies!
19:01:11 <aristid> do i understand this right, that this parody analogy attempts to explain the return function, and the lack of an inverse of return?
19:01:35 <monochrom> I think so
19:01:40 <mk> the metaphors aren't that bad. See http://blog.plover.com/prog/burritos.html , for example
19:01:47 <ReinH> so can I have a monad AlwaysFortyTwo a that injects values of type a into the monadic context (the integer 42) by throwing them away and keeping the integer 42?
19:02:21 <mk> ReinH: isn't that just Trivial?
19:02:22 <monochrom> the burrito one was a parody. I was there when it happened.
19:02:36 <aristid> mk: yes they are bad. because they take something relatively simple and bury it in loads of analogy sauce :P
19:02:39 <ReinH> mk: yes, but it's a very special kind of trivial where the context happens to be the answer to the ultimate question
19:03:05 <shachaf> Why are people still going on about this. :-(
19:03:21 <ReinH> shachaf: I think it's jumped back over the shark since we've started
19:03:21 <aristid> ReinH: what would be the kind of AlwaysFortyTwo?
19:03:33 <BMeph> monochrom: Was it a parody, or was it satire?
19:03:48 <monochrom> maybe satire
19:03:51 <ReinH> aristid: Int, yes?
19:03:52 <mk> shachaf: we all secretly enjoy it
19:04:02 <aristid> ReinH: Int is no kind :)
19:04:20 <aristid> ReinH: well, either way you need to have a parametric type to get a monad
19:04:35 <aristid> ReinH: so AlwaysFortyTwo is not possible because 42 isn't valid in all types
19:04:41 * monochrom loves parodies, satires, sarcasms... all those things, and makes no distinction. sorry! :)
19:05:17 <ReinH> data AlwaysFortyTwo a = Always Int
19:05:18 <monochrom> I hate analogies. I love parodies satires sarcasms jokes puns... all those things
19:05:21 <aristid> monochrom: all the different categories of "funny stuff" are just confusing anyways
19:05:38 <mk> aristid: I don't mind factory-machine analogies for functions, or physical container analogies for containers. For example, "bag".
19:05:52 <pharaun> a bit of a dumb question, but how do i pattern match to a record? - ie i don't want to have to do "foobar x _ _ _" for all entries in the record
19:05:53 <nexx> I think it is a bit sad you don't make a distinction
19:05:55 <monochrom> I enjoy the burrito thing. as a joke. publicly and secretly. not intended to be an analogy, metaphor, allegory... any of those things
19:05:55 <dolio> What was the answer for Cont Bool?
19:06:14 <aristid> hey nexx
19:06:16 <mk> and "pass it into" or "returns". That's metaphor-talk
19:06:16 <pharaun> but i want to match on the fact that i have that type of record so i can then do further work on it
19:06:25 <nexx> hey aristid :)
19:06:33 <monochrom> is it a functor or monad? it's both! http://www.vex.net/~trebla/photo/unorganized/burrito-salad.jpg
19:06:42 <ddarius> dolio: It fell on deaf ears.
19:06:55 <dolio> I see the new definition of "contains" is trivial.
19:07:01 <ddarius> dolio: Cont () is poignant though, but arguing about it would be a waste of breath.
19:07:03 <aristid> pharaun: MyRecord { foo = bar } is a valid pattern
19:07:10 <parcs`> pharaun: MyRecord{}
19:07:23 <ddarius> That binds bar.
19:07:30 <dolio> Because Cont () is trivial, but it operationally 'hangs onto a copy of something via a closure' to pass to a continuation that doesn't do anything with it.
19:07:31 <aristid> ddarius: indeed
19:07:43 <pharaun> aristid: parcs` doh, thanks
19:08:13 <ddarius> dolio: Yes, except that the compiler could quite conceivably optimize out that reference making this "operational" description fales.
19:08:28 <mk> what about cont bool?
19:08:45 <dolio> That'd be a pretty nice compiler.
19:08:47 <monochrom> you could go denotational on what "(a -> ()) -> ()" means
19:09:16 <ddarius> dolio: For (), it's not -that- hard.  A little bit of strictness analysis.
19:09:41 <ddarius> For Bool, you could conceivably retrieve full information by constant probing with different continuations.
19:10:39 <dolio> Just need to ask infinitely many questions to recover my integer. :)
19:10:51 <ddarius> dolio: Yep.  But don't worry it's only log infinity.
19:11:21 <aristid> log N is practically constant time
19:11:26 <dolio> Actually, you might be able to do it in finite time.
19:11:37 <ddarius> You could find any particular Integer in finite time.
19:11:51 <dolio> Anything produced with return.
19:12:00 <aristid> but there's no bound on how long you might need?
19:12:19 <monochrom> Oh! I see, yes! plug in "is it bigger than 1000?" "is it bigger than 10000?" etc to find an upper bound first
19:12:24 <dolio> Yes.
19:12:38 <dolio> Then you binary search the portion between the yes and the no.
19:14:03 <dolio> Timsort uses that strategy while merging sometimes.
19:14:42 <dolio> "Can I just copy [0,1]? Can I just copy [0, 2]? Can I just copy [0, 4]? ..."
19:15:41 <dolio> Then when n is 'yes' and n*2 is 'no', you search for the exact index, and copy the whole block.
19:15:49 <ReinH> So what's the state of the art with backtracking monads these days? Thinking about implementing the chess engine in terms of backtracking (alpha-beta pruning) search...
19:15:55 <dolio> And if n turns out to be big enough, you save comparisons.
19:16:04 <ReinH> MonadPlus is unfair, but that may be suitable
19:16:40 <aristid> MonadPlus is not a backtracking monad
19:18:17 <monochrom> use LogicT
19:18:23 <ddarius> I don't think anything new has happened in that area in several years.
19:18:37 <monochrom> the package name is logict
19:18:39 <ReinH> aristid: sorry, an instance of MonadPlus that naively implements backtracking
19:18:49 <ddarius> I think LogicT is (inspired by?) Oleg's which is pretty featureful and, I believe, has decent performance.
19:18:52 <ReinH> LogicT. Oh look there's a paper.
19:18:59 <aristid> @hackage logict
19:19:00 <lambdabot> http://hackage.haskell.org/package/logict
19:19:22 <ReinH> oh it does pruning
19:19:24 <ddarius> Ralf Hinze's BacktrT is a simpler, older one, that may or may not be faster.
19:19:46 <ReinH> LogicT looks fun
19:19:46 <aristid> so logict is a dolio package
19:20:07 <ReinH> I bet I can do alpha-beta pruning pretty easily with LogicT. Very cool.
19:20:20 <ddarius> Yep.  LogicT is probably what you want.
19:20:33 <ReinH> sweetsauce
19:20:34 <ddarius> There are some libraries that do constraint stuff as well.
19:20:56 <ReinH> neat but not really necessary here
19:21:09 <ReinH> are they gecode-like?
19:21:16 <aristid> hmm, interesting type (LogicT): forall r. (a -> m r -> m r) -> m r -> m r
19:22:07 <monochrom> @unmtl ContT m r a
19:22:08 <lambdabot> (a -> r m) -> r m
19:22:27 <ReinH> this is a fun read http://www.cs.rutgers.edu/~ccshan/logicprog/LogicT-icfp2005.pdf
19:23:17 <monochrom> oh I remember now. you have two continuations, not one. because one of them is for success, the other one is for failure
19:24:23 <ddarius> @google typed logic variables haskell
19:24:26 <lambdabot> http://www.cs.nott.ac.uk/~gmh/papers/20.ps
19:24:42 <dolio> Yes, it's Oleg's stuff with various things renamed to be more palatable.
19:24:48 <ReinH> oh I think I was thinking of Data.List.Tree as well
19:24:51 <ReinH> http://hackage.haskell.org/packages/archive/ListTree/0.1/doc/html/Data-List-Tree.html
19:25:18 <aristid> @hoogle Tree
19:25:19 <lambdabot> Data.Graph.Inductive.Tree module Data.Graph.Inductive.Tree
19:25:19 <lambdabot> Data.Tree module Data.Tree
19:25:19 <lambdabot> Data.Tree data Tree a
19:25:25 <dolio> Oleg has some other thing that isn't actually a monad, but has better behavior for various things.
19:25:26 <ReinH> also a backtracking search based on MonadPlus
19:25:55 <ReinH> I think Data.List.Tree's prune is exactly what I want, assuming the lib isn't terribad
19:26:41 <dolio> http://okmij.org/ftp/Computation/monads.html#fair-bt-stream
19:26:44 <dolio> That's the thing.
19:26:53 <dolio> He calls it a monad transformer, but I don't think it is.
19:27:10 <dolio> You'll probably get results in different orders depending on associativity.
19:27:20 <dolio> Not that you'd necessarily care about that.
19:27:48 <aristid> dolio: "Also, in the present monad the laws are satisfied modulo the order of the answers" <- this?
19:27:48 <ReinH> dolio: in this case I don't think I do unless I'm ordering by score, which could be useful
19:28:04 <aristid> ReinH: which you can do after everything is done
19:28:11 <ReinH> aristid: right
19:28:20 <dolio> aristid: Ah, yes.
19:29:30 <dolio> Anyhow, LogicT falls down when you do something like 'filter (const false) (repeat x) `interleave` return 5'
19:29:59 <dolio> It just spins forever. And his backtrack thing actually yields 5.
19:30:26 <aristid> oO
19:31:46 <ReinH> dolio: his who?
19:31:51 <dolio> Oleg's.
19:32:12 <ReinH> hmm
19:32:15 <ReinH> so many choices :)
19:32:37 <dolio> The difference is that LogicT is effectively a list, so when you remove all elements individually from an infinite list, you get bottom.
19:33:01 <dolio> Whereas the backtrack thing just replaces Yields with Steps, and you can still interleave the steps with another stream.
19:33:30 <ReinH> dolio: so in my case it looks like I could implement alpha-beta search with this... I think... maybe... http://hackage.haskell.org/packages/archive/ListTree/0.1/doc/html/Data-List-Tree.html#v%3AbranchAndBound
19:33:41 <ReinH> I mean it is just a branch and bound after all...
19:34:12 <dolio> I've never used that. Maybe, though.
19:34:24 <ReinH> looks... weird.
19:35:15 <ReinH> so number in Oleg's example is just [1..] implemented in a way that makes it portable to non-List instances of MonadPlus, right?
19:36:06 <ReinH> [0..]
19:36:21 <ReinH> but then he guards it just to confuse me
19:37:30 <aristid> ReinH: maybe you might even be able to just use a normal list?
19:37:30 <dolio> Yes, it's [0..].
19:37:44 <ReinH> aristid: yes probably
19:38:28 <ReinH> just wondering about ways I might optimize later
19:38:54 <aristid> ReinH: so why not give that a try and go all fancy with logict or whatever when you see how well it behaves?
19:39:00 <pharaun> i'm probably being dense but i'm trying to
19:39:03 <ReinH> aristid: yep
19:39:06 <pharaun> replace a mvar without blocking
19:39:07 <ReinH> just wondering what's out there
19:39:27 <aristid> pharaun: i don't think that would be safe
19:39:38 <rosie> haddock generated lots documentation in the cabal-dev/share folder. Is this documentation on the libraries on which this package (which contains the cabal-dev folder) depends?
19:39:46 <aristid> ReinH: tons of cool options :)
19:40:02 <pharaun> aristid: even with modifyMVar?
19:40:11 <ReinH> aristid: basically if I can implement with List then I can replace with a more performant instance of MonadPlus later.
19:40:22 <ddarius> pharaun: The best you can do is tryTakeMVar which will keep you from blocking, but won't actually take the MVar if it is already taken.
19:40:27 <ReinH> (implement with List using its MonadPlus interface)
19:40:32 <pharaun> :\
19:41:00 <aristid> pharaun: well you could use forkIO
19:41:11 <ddarius> The whole point of MVar is to be a synchronizing primitive, so it's not clear why you want to do what you are trying to do.
19:41:15 <aristid> pharaun: just spawn a thread to modify the MVar for you :D
19:41:22 <pharaun> ddarius: then how should i implement this semantics - i query the remote api, it returns a session key, which i want to give out to all threads that has access to that mvar (they will do a readMVar) to get the session id or block
19:41:36 <parcs`> pharaun: modifyMVar is safe if you don't use putMVar or takeMVar anywhere else
19:41:44 <pharaun> and then if i get a new session key i want to put it into the MVar
19:42:00 <pharaun> parcs`: yeah all i am doing is either putting/replacing the session MVar or reading from the MVar
19:42:11 <Enigmagic> pharaun: use a TVar instead?
19:42:13 <parcs`> then modifyMVar should be ok
19:42:36 <pharaun> Enigmagic: i haven't read up on STM yet :) i'm leaning toward that but i wanted to understand MVars first
19:42:44 <aristid> pharaun: i think you might be able to do with just an IORef
19:42:48 <aristid> @hoogle atomicallyModify
19:42:49 <lambdabot> No results found
19:42:50 * shachaf wonders what the Haskell community will do when they have more than 26 kinds of concurrency variables.
19:43:08 <ddarius> shachaf: We already have TMVars, so we're safe.
19:43:23 <pharaun> aristid: can i have a IORef block if there's no value in there that way i can't "send" a packet that requires a session value
19:43:24 <aristid> pharaun: atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
19:43:36 <pharaun> oh hm
19:43:39 <shachaf> ™Var
19:43:43 <aristid> pharaun: no. you don't get blocking
19:43:49 <pharaun> arugh
19:43:53 <parcs`> http://neilmitchell.blogspot.com/2012/06/flavours-of-mvar_04.html
19:43:54 <shachaf> register :: ™Var a -> ®Var a
19:44:44 <pharaun> aristid: so there's no good way to have "blocking readers" but can just put/replace the current value by a producer (one lone productor)
19:45:00 <aristid> shachaf: i guess the fact that it took me a while to get this proves that i'm tired *sigh*
19:45:00 <ddarius> pharaun: It sounds like modifyMVar or even just writeMVar is what you want unless you worried about one of the readers taking a long time to read the MVar, or malicious parties.
19:45:27 <shachaf> aristid: Maybe it proves it was a stupid pun.
19:45:45 <pharaun> ddarius: writeMVar? hmm
19:45:49 <aristid> shachaf: it's almost 5 am here, so the former seems more likely
19:46:01 <ddarius> writeMVar is just takeMVar mvar >> putMVar mvar x
19:46:02 <pharaun> ddarius: i don't see a writeMVar
19:46:09 <ddarius> It should be somewhere.
19:46:11 <ddarius> @hoogle writeMVar
19:46:12 <lambdabot> No results found
19:46:20 <ddarius> @hoogle readMVar
19:46:21 <lambdabot> Control.Concurrent.MVar readMVar :: MVar a -> IO a
19:46:26 <Enigmagic> :t putMVar
19:46:27 <lambdabot> Not in scope: `putMVar'
19:46:30 <aristid> well you just gave the definition anyways, right? :P
19:46:35 <parcs`> swapMVar, i think
19:46:36 <pharaun> ddarius: i'm mostly worried about 1) preventing a reader from going out without a valid session token, 2) being able to put/replace the session token as needed
19:46:41 <ddarius> That definition may not be the safest.
19:47:10 <ddarius> pharaun: Yes, and it sounds like if the readers just use readMVar, you'll be fine as long as you don't have a race condition.
19:47:13 <pharaun> i want blocking on reader, but no blocking on writer
19:47:22 <pharaun> ddarius: yeah i have one single writer, multiple reader
19:47:49 <ddarius> pharaun: Yes, but can a session token become invalid and before the writer writes the new one the reader reads the old one and continues?
19:48:19 <pharaun> nothing i can do about that case, the reader will send it out and get an error from the api
19:48:24 <pharaun> which i can then tell it to re-try
19:48:43 <pharaun> i'm just trying to minimalize the chance of a bad request going out
19:48:45 <ddarius> So why worry about this at all?
19:48:47 <ddarius> Okay.
19:49:55 <aristid> pharaun: and your MVar has multiple readers, or just one?
19:50:40 <pharaun> aristid: multiple readers
19:50:56 <ddarius> When would the readers block?
19:51:16 <aristid> only in the beginning when there's no session key at all?
19:51:24 <pharaun> yes
19:51:28 <aristid> how about only starting the readers once there is a session key?
19:51:38 <pharaun> not sure if there's a good way i could do that
19:51:41 <aristid> and just use an IORef afterwards
19:51:47 <ddarius> Alternatively, you could have a lock (MVar ()) and just use an IORef.
19:51:48 <pharaun> but i could maybe redesign the api to only allow that case
19:51:56 <aristid> ddarius: one lock per reader?
19:52:03 <ddarius> No, one lock period.
19:52:17 <shachaf> One lock per iod.
19:52:20 <ddarius> It starts empty, and when there is a key it's filled.
19:52:23 <ddarius> shachaf: Yes.
19:52:44 <pharaun> so if the ioref becomes empty i can re-engage the lock
19:52:46 <aristid> but once one of the reader takes it, it's taken? would the reader put it back?
19:52:53 <nand`> pharaun: you want one non-blocking writer -> multiple blocking readers
19:52:58 <pharaun> nand`: yes
19:52:59 <ddarius> IORefs can't be empty.
19:53:03 <nand`> sounds like a channel to me
19:53:08 <aristid> ddarius: i mean the MVar.
19:53:14 <pharaun> nand`: looking
19:53:41 <ddarius> aristid: The reader can put it back, or you could have one per reader if the contention was undesirable.
19:53:44 <nand`> something like http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-Chan.html#t:Chan I guess
19:54:10 <ddarius> nand`: You'd have to dup the ends.
19:54:15 <pharaun> nand`: it seems to take the value off the chan
19:54:21 <aristid> ddarius: ok, i didn't consider at first that readers can put it back.
19:54:24 <pharaun> so i would have to supply a repeating supply of the same session key
19:54:36 <nand`> or dup the channels per reader?
19:54:39 <ddarius> aristid: It would just be a readMVar.
19:54:44 * Enigmagic is amused
19:54:56 <ddarius> nand`: Or that, yes.
19:55:05 <aristid> nand`: but then you have the same effect as the lock + IORef solution, which is more lightweight
19:55:28 * ddarius agrees with aristid (unsurprisingly).
19:55:28 <byorgey> ddarius: eh? what's that about a paper of mine with no references?
19:56:09 <ddarius> byorgey: I have some copy of your monoid functional pearl, but it seems to be missing the bibliography.
19:56:26 <ddarius> It refers to things but the list of things is missing.
19:56:34 <byorgey> ddarius: bizarre.  Do you know where you got it?
19:56:49 <byorgey> ddarius: are you sure it's missing?  it would be before the appendix, not at the very end.
19:57:15 <ddarius> I considered that.  I'll see if I can find the link I used.
19:57:22 <pharaun> thanks everyone :)
19:57:29 <pharaun> given me some stuff to think over
19:57:42 <shachaf> http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf seems to be missing it.
19:58:03 <ddarius> Yep.  That's the one I used.
19:58:40 <byorgey> eek, what
19:59:29 <byorgey> sh**, I really hope the final version I submitted for publication had a bibliography =P
19:59:55 <ddarius> I would imagine someone would say something if it was missing...
20:00:35 <byorgey> I would hope so.
20:00:47 <byorgey> anyway, I'll upload a new version with the bibliography tomorrow
20:00:58 <byorgey> at the moment I'm headed to bed
20:07:35 <mk> http://hpaste.org/73409 I'm having trouble getting this running in ghci. What happens if I type m? just "W (Leaf, ())"?
20:08:47 <Cale> mk: yes
20:08:56 <Cale> mk: What trouble are you having getting it to run in ghci?
20:09:23 <mk> Illegal instance declaration for `Monad (Writer T)' [...]
20:09:32 <Cale> mk: It works for me, I just pasted the code into mk.hs and then ghci mk.hs
20:09:49 <mk> ah. I pasted directly into ghci, oops
20:10:42 <Cale> In that case, you might be able to get the instances and such to work if you substitute the first like for  :set -XFlexibleInstances
20:10:59 <Cale> It's still weird to me that ghci lets you do that at all
20:11:33 <Cale> (it's a new feature to declare datatypes/classes/instances on the ghci prompt)
20:13:18 <mk> Cale: working well now using the file, thanks
20:13:48 <hayashi> turns out I still don't grok GHC.Generics =P
20:14:22 <hayashi> it seems so easy to use it to translate an ADT into another form, but going the other way, not so much
20:14:46 <hayashi> instances overlapping with themselves for starters
20:15:52 <mk> http://hpaste.org/73409 same link as above, does m count as a monadic value, and does f count as the return function?
20:16:40 <Cale> mk: I think this fails the associativity law for monads, but otherwise, sure.
20:17:02 <Cale> er, f?
20:17:12 <Cale> return would be the return function
20:17:33 <mk> Cale: how should I bind to return? I just did m >>= f
20:17:39 <Cale> (Were it not for the fact that this T type isn't quite a monoid)
20:17:54 <mk> oh, nevermind. m >>= return works fine
20:18:06 <Cale> mk: Oh, right, this isn't even satisfying the unit law
20:18:10 <Cale> heh
20:18:20 <mk> Yeah.
20:18:51 <rosie> what's the word for the {-# LANGUAGE xyz #-} at the top of a .hs file?
20:18:59 <mk> ddarius: ^ in case you were interested
20:18:59 <Cale> LANGUAGE pragma?
20:19:17 <rosie> Cale: thanks
20:20:06 <shachaf> rosie: Good news! bahaskell was cancelled for this month.
20:20:31 <mk> is there any monad which "stores" only single values (like Maybe, but unlike List), which could be altered and made to fail the third law, without failing any of the others?
20:20:55 <rosie> shachaf: ha, good news because I won't be missing out on anything?
20:21:08 <shachaf> Exactly!
20:21:26 <shachaf> It was cancelled because you and ddarius didn't show up.
20:21:35 <shachaf> (And also because there was no venue and no talk, I guess.)
20:21:38 <rosie> haha
20:22:15 <mk> I'm having trouble understanding what the 3rd law does, and I suspect that it only applies to monads that have an ordered structure of multiple values
20:22:42 <ddarius> Saizan didn't copy my definition correctly.
20:23:46 <ddarius> It was data T = Leaf | Branch T T; instance Monoid T where mempty = Leaf; Leaf `mappend` t = t; t `mappend` Leaf; x `mappend` y = Branch x y;
20:24:15 <shachaf> ddarius: I think you're missing an "= t" there.
20:24:16 <ddarius> You can correct Saizan's definition by replacing the Branch with mappend in Branch t1 t2 in the definition of (>>=).
20:24:24 <ddarius> shachaf: Yes.
20:25:09 <mk> so W (t2,b) -> W (mappend t1 t2,b) ?
20:25:14 <ddarius> T fails the associativity law by design, but satisfies the unit laws.  The monad then fails its associativity law but satisfies its unit laws.
20:25:28 <ddarius> Yes, given the instance I provided corrected as shachaf mentioned.
20:26:13 <mk> t `mappend` Leaf = t;  ?
20:26:20 <ddarius> Yes.
20:26:28 <mk> ddarius: thanks
20:26:40 <ddarius> For consistency, you could replace the use of Leaf in return with mempty and then generalize the instance to instance Monoid m => Monad (Writer m) where ...
20:26:49 <ddarius> Which would then correspond to the definition of Writer in the libraries.
20:26:54 <mk> err, not in scope Monoid
20:27:03 <ddarius> @hoogle Monoid
20:27:03 <lambdabot> Data.Monoid module Data.Monoid
20:27:03 <lambdabot> Data.Monoid class Monoid a
20:27:04 <lambdabot> package monoid-owns
20:27:04 <shachaf> It's actually "data T = Leaf | Br= tanch T T; instance Monoid T ..."
20:28:06 <mk> shachaf: are you sure you pasted right?
20:28:22 <shachaf> I didn't paste at all.
20:29:11 * ddarius needs to make a language for describing signals.
20:29:12 <zenkicks> hello
20:29:17 <Cale> hello
20:29:37 <shachaf> hi Cale
20:29:45 <shachaf> Cale: Welcome #haskell.
20:29:45 <BMeph> ¡Hola!
20:29:59 <shachaf> Stereo etc.
20:30:07 <zenkicks> let x = 10. why does x * x work, but x / x gives me this error:  No instance for (Fractional Integer) arising from a use of `/'
20:30:10 <shachaf> (No stereo here, though.)
20:30:20 <shachaf> zenkicks: Monomorphism restriction.
20:30:29 <shachaf> Try giving x a type signature.
20:31:11 <Cale> Or, put this code into a file
20:31:37 <shachaf> Or ":set -XNoMonomorphismRestriction"
20:31:39 <zenkicks> isn't x's type implicitly set to whatever type 10 literal is?  10 / 10 works
20:31:55 <Cale> zenkicks: literal 10 has type (Num a) => a
20:32:00 <Cale> zenkicks: *however*
20:32:14 <Cale> There's an awkward (and well-hated) rule in the Haskell standard
20:32:51 <Cale> which says that whenever you have a pattern binding (i.e. one with no function parameters), and it doesn't have an explicit type signature
20:33:10 <Cale> then it's not allowed to be type class polymorphic
20:33:58 <Cale> and numeric defaulting interacts with that in order to try to decide on a concrete type for the bound variable involved
20:34:28 <zenkicks> thanks for detailed explanation
20:34:35 <fredflinstone> test
20:34:58 <ddarius> Type classes are not particularly relevant to the monomorphism restriction.
20:35:14 <Cale> oh, right, it's just polymorphic at all?
20:35:22 <ddarius> Correct.
20:35:33 <ddarius> It's vaguely similar to ML's value restriction.
20:37:00 <Cale> In fact, it's weird that it doesn't mention type classes, because the only rationale I've ever seen for its existence has involved typeclasses.
20:37:20 <ddarius> What?  The rationale in the report is avoiding duplicate evaluations.
20:37:21 <ion> zenkicks: AFAIU the reasoning for the monomorphism restriction is that Num a => a compiles to something like a function Num' a -> a and they don’t want “let x = 10” result in that unexpectedly.
20:37:31 <shachaf> ddarius: My ghci doesn't behave that way.
20:38:20 <shachaf> Prelude> let x = id Prelude> :t x\n x :: a -> a\n Prelude> let y = (id :: Num a => a -> a)\n Prelude> :t y\n y :: Integer -> Integer
20:39:37 <geekosaur> they're mentioned with it because it usually interacts with / triggers defaulting, which *does* involve (specific) typeclasses
20:39:39 <ddarius> shachaf: That's the wrong test.  The monomorphism restriction is about monomorphic type variables, not about defaulting.
20:40:04 <mk> http://hpaste.org/73417 I think mappend has been corrected, but I'm not getting expected results
20:40:11 <shachaf> Oh, defaulting, right.
20:40:51 <shachaf> But why does the monomorphism restriction keep x polymorphic?
20:42:01 <Cale> mk: let x = Branch Tip Tip, and consider (x `mappend` x) `mappend` x  vs. x `mappend` (x `mappend` x)
20:43:10 * hackagebot tskiplist 0.1.2 - A Skip List Implementation in STM (PeterRobinson)
20:43:34 <ddarius> Ah, no I'm wrong the monomorphism does (also) refer to constrained types: "In addition, the constrained type variables of a restricted declaration group may not be generalized in the generalization step for that group."
20:44:05 <Cale> aha
20:44:15 <Cale> I thought there was something about type classes in there :)
20:44:45 <dolio> Constraints are the only way you'd get 'confusing' duplicate evaluation.
20:44:45 <ddarius> However, "We say that a given declaration group is unrestricted if and only if: (a): every variable in the group is bound by a function binding or a simple pattern binding (Section 4.4.3.2), and (b):an explicit type signature is given for every variable in the group that is bound by simple pattern binding."
20:44:51 <Cale> I think it's usually that second part which ends up biting people too
20:45:50 <mk> Cale: sure, I get that, but I'm having trouble following why that would matter
20:46:06 <Cale> dolio: That's what I was thinking, but then I started thinking about cases where you're explicitly passing a dictionary of operations which happens to be polymorphic, and whether you could make a local definition get evaluated more times than one might think
20:46:12 <ddarius> Cale: The code he pasted is just completely broken.
20:46:13 <Cale> I don't know
20:46:23 <Okasu> shapr: http://hpaste.org/73418 here you go :)
20:46:55 * Okasu hardly brainlags today :/
20:47:06 <Cale> mk: Okay, usually the Writer w monad is only a monad when the w type is a monoid.
20:47:21 <dolio> Cale: Explicitly passing a dictionary isn't 'confusing,' though, because you're writing things that are explicitly functions. :)
20:47:24 <estulticia> Okasu: what does that?
20:47:37 <Cale> dolio: well, no, you'd have local pattern bindings
20:48:06 <Okasu> estulticia: just get web page contents and greps it for some regex
20:48:41 <mk> Cale: right - doesn't making it a non-monoid break one of the first two laws, in addition to the third? (I'm a bit in the dark here, since I can't get ddarius's code working beyond what I pasted above)
20:48:47 <estulticia> Okasu: cool, thanks
20:49:13 <Cale> mk: It can break all the laws, depending on how exactly it fails to be a monoid
20:49:41 <Cale> I may be missing some context for this discussion.
20:49:43 <ddarius> Each monad law for Writer goes back to exactly one of the corresponding monoid laws.
20:50:48 <mk> Cale: I'm wondering if it can break only the 3rd law. I'm trying to understand how the 3rd works, and I have the idea that it only applies to cases where there monadic values "contain" multiple values (like List), but is irrelevant for all monads whose monadic values "contain" either 1 or 0 values
20:50:51 <shachaf> Really? That's interesting.
20:51:31 <Cale> mk: I don't think that's necessarily right
20:51:41 <Cale> mk: In particular, it matters for Writer
20:51:50 <ddarius> Cale: It isn't right and the example was specifically designed as a counter-example.
20:51:53 <Cale> (I think it matters all the time)
20:51:57 <Cale> ah, okay
20:52:25 <mk> Cale: right, apparently so, but I'm having trouble understanding why, and getting a counterexample producing conflicting values for the left and right sides of the 3rd law
20:52:50 <Cale> In do-notation, the third law says that  do w <- (do v <- x; f v); g w  is the same thing as  do v <- x; w <- f v; g w
20:53:12 <nand`> whoa, I just realized hackage's Source pages had syntax highlighting
20:53:21 <ddarius> nand`: ...
20:53:25 <mk> Cale: this is one of those "doesn't make any sense whatsoever unless you already understand" things :)
20:53:48 <Cale> mk: Okay, so think about what your intuition is for a hunk of code like that
20:54:09 <ddarius> Cale: mk is not comfortable with even the syntax of Haskell.
20:54:25 <Cale> mk: to get w, we run x, producing the result v, and then run f v, and the result of that is w
20:54:36 <Cale> mk: and then in the outer do-block, we run g w
20:55:03 <Okasu> http://hpaste.org/73418 more practicl version
20:55:20 <Cale> So this intuitively should be the same thing as just, all in one do-block, running first x to produce the result v, and then running f v to get w, and then running g w
20:56:06 <mk> what I understand about the 3rd law is that if, for example, I define a List monad that reverses the values, it will break the third law. But since monads like maybe don't have more than one value to reverse, I'm wondering how they might get broken
20:56:19 <Cale> mk: This is the law that lets us chop out some bunch of lines in the middle of a do-block and turn them into a new function or straight definition of an action.
20:56:40 <Cale> and then call that function and not have the program's behaviour change
20:57:07 <Cale> In a sense, it says we're not allowed to be able to tell how deeply nested we are in the computation.
20:57:15 <mk> how can I selectively break the 3rd law?
20:57:30 <shachaf> mk: Did you see the thing ddarius said several times already?
20:58:20 <shachaf> Starting 6 hours ago.
20:58:24 <Cale> The instance of Monad for Maybe is so straightforward that it's almost hard to imagine writing one which is incorrect.
20:58:39 <ddarius> @hoogle either
20:58:39 <lambdabot> Prelude data Either a b
20:58:39 <lambdabot> Data.Either data Either a b
20:58:40 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
20:58:43 <Cale> (the typechecker will kill most attempts)
20:58:54 <shachaf> m >>= f = Nothing
20:59:07 <Cale> There's one thing you can do which will still satisfy the monad laws, but be pretty useless.
20:59:25 <Cale> (which is to send everything to Nothing)
20:59:27 <mk> shachaf: (not interested. What ddarius said was helpful.)
20:59:47 <ddarius> Okasu: http://hpaste.org/73418 (untested)
20:59:59 <shachaf> mk: Huh?
21:00:22 <mk> shachaf: I'm not interested in having that conversation with you
21:00:30 <Cale> mk: Okay, so you're looking for an attempt at a monad instance which fails the associativity law, but succeeds with the unit laws?
21:00:56 <Cale> mk: Pick your favourite non-associative operation with a unit, and use the Writer monad.
21:01:11 <shachaf> mk: What conversation?
21:01:11 <mk> Cale: right. I think I follow the other two laws. The first effectively says "bind must pass v into f, when given a v that was returned from return"
21:01:37 <shachaf> mk: Writer T "contains", to the extent that that word makes any sense, exactly one value. And it satisfies the unit laws but not the associative law.
21:01:49 <Cale> mk: I have another, prettier way to write the monad laws which might help
21:01:53 <shachaf> It's exactly what you asked for.
21:01:55 <Okasu> ddarius: whoa nice, i think it's just a bit longer than ruby version(put away imports)
21:02:18 <shapr> Okasu: thanks!
21:02:23 <Cale> mk: If we define the operation (f <=< g) x = f =<< g x
21:02:24 <mk> Cale: it also says that return must map each value to a distinct monadic value. The second law says that bind won't call f unless a the v passed to it contains a value (unlike Nothing, which does not)
21:02:49 <Cale> mk: That is slightly false
21:03:06 <Cale> mk: return can send everything to a constant if bind does so as well :)
21:03:15 <mk> shachaf: I want to understand why, not merely to see that it can be done
21:03:24 <mk> Cale: right, Trivial
21:04:05 * ddarius didn't realize jfredett was here.
21:04:07 <Cale> mk: Okay, so does this <=< make sense? It is an analogue to composition, in that its type is:
21:04:13 <shachaf> jfredett is alive?
21:04:22 <Cale> (<=<) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)
21:04:37 <Cale> where normal function composition is like this:
21:04:45 <Cale> (.) :: (b -> c) -> (a -> b) -> (a -> c)
21:04:56 <mk> is =<< >>=?
21:05:00 <Cale> yeah
21:05:08 <Cale> (=<<) = flip (>>=)
21:05:19 <Cale> f =<< x = x >>= f
21:05:44 <Cale> (might be cuter to use v instead of f to make it totally symmetrical)
21:06:24 <BMeph> (Welcome to #haskell, where we like our puns audio-visual.)
21:06:40 <Cale> So in terms of this operation, the monad laws are:  return <=< f = f,  f <=< return = f, and  (f <=< g) <=< h = f <=< (g <=< h)
21:06:50 * ddarius thinks IRC's bit rate is a bit low for reasonable quality audio.
21:07:17 <Cale> If you thought mIRC colours were annoying, just wait.
21:07:42 <shachaf> Low by just one bit?
21:07:43 <ion> f =<< x = x >>= ɟ
21:07:58 * BMeph thinks the quality is perfect for whale songs...
21:07:59 <nand`> ion: excellent
21:08:26 <Cale> mk: In other words, <=< is the composition for a category
21:08:36 <Cale> where return gives the identity maps
21:09:21 <mk> Cale: right, those are at the bottom of http://www.haskell.org/haskellwiki/Monad_Laws - I haven't looked at them much, though
21:09:33 <Cale> (This category is called the Kleisli category for the monad)
21:10:02 <mk> how might that version fail?
21:10:05 <Cale> This is nice because it actually makes the unit and associativity laws look like unit and associativity laws
21:13:10 <ddarius> Any recommendations on graph plotting libraries, preferably usable for interactive/animated plots.  plot/plot-gtk is what I'm using now, but it's API is crappy.  gnuplot I don't think will do quite what I want.
21:14:23 <mk> for example, 1 and 2 might fail if bind simply returns some arbitrary value. 1 fails if you map any two values to the same monadic value. 2 fails if bind modifies the "metadata" part, but skips the function (as it would be skipped if Nothing)
21:15:06 <mk> (as usual, Trivial is excluded)
21:17:26 <Cale> okay, here's one
21:17:37 <Cale> one sec
21:22:30 <Cale> Well, okay, let's not think too hard about it, I was going to do something involving detecting nesting level, but that fails one of the unit laws too :)
21:22:52 <Cale> a broken Writer will provide examples of everything
21:22:57 <Okasu> is it possible somehow handle "Not in scope" event?
21:22:59 <Cale> (with various non-monoids)
21:23:18 <ddarius> Okasu: That happens at compile-time.
21:23:19 <Cale> Okasu: That's a static error.
21:23:30 <Cale> It's not a runtime event
21:23:41 <Okasu> oh, got it, thanks
21:23:45 <Cale> Or do you mean handle with Template Haskell somehow?
21:23:49 <Cale> I don't think there is
21:23:57 <Cale> That would be really weird.
21:23:59 * hackagebot lz4 0.2 - LZ4 compression for ByteStrings (MarkWotton)
21:24:38 <Cale> Best just to define things when you want to use them :)
21:24:59 <Cale> If you're using them in the code, you might as well provide a definition right then
21:25:01 <mk> how can I make http://hpaste.org/73417 give conflicting values for that 3rd law test at the bottom?
21:25:41 <Cale> mk: Let  u x = W (Branch Leaf Leaf) x
21:25:46 <Cale> mk: and play around with that
21:26:40 <slack1256> When developing haddock documentation. What is best? put the Datatypes first, Classes after and then functions?
21:26:50 <Cale> oh, sorry
21:26:52 <Okasu> Cale: but what i don't know what i will use, for example writing linux shell in haskell: when not in scope occures /usr/bin lookup trys to find some exec and if it fails
21:26:56 <slack1256> A friend told is easier to understand a package once you understand the core datatype.
21:26:57 <Cale> u x = W (Branch Leaf Leaf, x)
21:26:59 <Okasu> standart Not in scope raises
21:27:33 <ddarius> slack1256: Use whatever order makes sense.
21:27:43 <Okasu> or web frameworks like RoR heavily use this tequinik
21:28:00 <Cale> Okasu: if you're writing a shell in Haskell, and your shell receives the name of a program from the user, it's up to you to search to see if that program exists, and if so, execute it
21:28:07 <Okasu> defining methods on runtime when user call them
21:28:43 <Cale> Okasu: The name of the program won't itself be the name of a variable in your program (except perhaps by coincidence)
21:29:04 <Cale> Okasu: and none of the code you write could possibly have known whether the user would have typed that
21:29:13 <Cale> Okasu: right?
21:29:59 <slack1256> ddarius: there isn't a rule of a thumb? on how to produce good documentation (good as easier to understand the intention of the module)?
21:30:34 <Okasu> Cale: heh, don't know it seems very usefull to me by now, but maybe it's just ruby/lisp background influences on me :)
21:30:57 <Cale> Okasu: what code are you trying to write
21:31:03 <mk> Cale: why u x =, and not simply x = ?
21:31:19 <mk> nevermind
21:31:21 <Cale> mk: because this is a function you're going to use in the associativity law
21:31:25 <Cale> mk: to break it
21:31:30 <mk> gotcha
21:31:30 <Cale> u () >>= u >>= u
21:31:34 <Cale> u () >>= (\v -> u v >>= u)
21:31:37 <Okasu> Cale: it's just toughts nothing real for now
21:31:38 <ddarius> slack1256: Pedagogy is hard.
21:32:24 <Cale> mk: Note, there was nothing too special about my choice of Branch Tip Tip there
21:32:39 <Cale> mk: The associativity law will break for u whenever that value is anything other than Tip
21:32:44 <ddarius> Okasu: You could mimick those techniques in Haskell (explicitly) if you wanted to.  As far as I know, no one wants to.  Also, most code written has been written in languages that don't have such facilities, and even code in languages with such facilities usually doesn't use them.
21:33:00 <ddarius> Arguably, things like that are part of why some people hate Ruby on Rails.
21:33:04 * slack1256 wonders aren't as many books on writing programming documentation as on programming languages
21:33:22 <Cale> Okasu: I ask because I don't know how it could possibly look
21:33:29 <slack1256> s/wonders/wonders\ why/
21:33:33 <lewis1711> I don't understand the function signature of "return". it takes a, and returns m a. but how does it "know" which m?
21:33:56 <parcs`> lewis1711: context
21:33:57 <Cale> Okasu: Why would you want to refer to something which you can't define?
21:33:58 <ddarius> lewis1711: The type will be clear in any concrete use.  If it isn't the code won't compile.
21:34:07 <Cale> Okasu: (why not just define it?)
21:34:32 <Cale> I find the whole concept very strange
21:34:55 <slack1256> lewis1711: return will look at the type signature of the function and return the appropriated m
21:35:01 <Cale> Okasu: If you could give me an example of the code you'd like to be able to write though, I might be able to suggest a way to do what you want
21:35:18 <Cale> Okasu: I have a sneaking suspicion that you just want strings.
21:35:20 <lewis1711> does each type class have a monad associated with it, or something?
21:35:30 <Okasu> Cale: becuase it imposossible define something you don't know about, but if know pattern and simaple use case of that function you can predict future call and define it dynamicly
21:35:56 <Cale> lewis1711: no, Monad itself is a type class, and we write an instance of that type class for each monad
21:36:25 <slack1256> lewis1711: No each 'Monad datatype' implement a instance of the 'Monad class'
21:36:39 <Cale> Okasu: give me an example?
21:37:11 <slack1256> lewis1711: example for 'Maybe' 'return a = Just a', for 'Either String' 'return a = Right a'
21:38:22 <lewis1711> ok, hmm
21:38:42 <Okasu> Cale: in RoR you when you create some controller(MVC term) i dynamicaly get heap of auziliary methods for linw 'controller_name ++ "_path"' or something like that
21:38:53 <lewis1711> so integers are already instances of the monad type class. Therefore "return 3" => 3, actually does what it says on the tin, because applying the m constructor just returns... itself?
21:39:00 <Okasu> but i agree it can be done by means of standart programming
21:39:08 <Okasu> without fancy matestuff
21:39:22 <Okasu> meta*
21:39:26 <ddarius> lewis1711: No.
21:39:55 <Cale> Okasu: How do you call those methods if you don't know the controller's name at compile time?
21:40:40 <slack1256> lewis1711: let's play a little bit with lambdabot
21:40:45 <Okasu> Cale: just intersept method missing event, match regexp and create apropriate method using simple pattern
21:40:47 <slack1256> > return 3 :: Int
21:40:48 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:40:48 <lambdabot>         against inferred type ...
21:40:50 <Cale> (if it's by introspection of some sort, you can just store them in some other datastructure where you wouldn't need introspection to find them)
21:40:59 <slack1256> > return 3 :: Maybe Int
21:41:01 <lambdabot>   Just 3
21:41:03 <Cale> Okasu: nonono
21:41:19 <ddarius> Cale: Don't ask questions you don't want answers to.
21:41:20 <lewis1711> oh I am confusing how return 3 looks with show
21:41:34 <Okasu> :)
21:41:48 <slack1256> > return 3 :: Writer String Int
21:41:49 <shachaf> You gotta have more symmetry, man.
21:41:50 <lambdabot>   No instance for (GHC.Show.Show
21:41:50 <lambdabot>                     (Control.Monad.Trans.Wri...
21:41:50 <shachaf> > return 3 return :: Int
21:41:52 <lambdabot>   Ambiguous type variable `m' in the constraint:
21:41:52 <lambdabot>    `GHC.Base.Monad m'
21:41:52 <lambdabot>      a...
21:41:55 <Cale> Okasu: I mean how can you, as a programmer, sit there and write code with implied names of controllers in it, without just being able to define those things at compile time too
21:41:56 <shachaf> Bah.
21:42:03 <Cale> Why does it need to be caught at runtime
21:42:16 <Cale> If you've written code which already assumes that you'll need things with certain names
21:42:16 <shachaf> > return 3 4 :: Int
21:42:18 <lambdabot>   3
21:42:29 <Cale> why can't you just define those things ahead of time, so that you'll know that you have time
21:42:34 <Cale> have them*
21:43:07 <Cale> at compile time, rather than at runtime
21:43:23 <Cale> You can still do compile-time metaprogramming
21:43:34 <slack1256> shachaf: what?
21:43:40 <shachaf> slack1256: Sorry. Ignore that.
21:43:41 <Cale> (We have a system for that in Haskell called Template Haskell)
21:43:47 <slack1256> > return 3 4 :: Int
21:43:49 <lambdabot>   3
21:43:53 <shachaf> slack1256: "integers are already instances of the monad type class" is not even wrong.
21:44:09 <Okasu> Cale: http://th01.deviantart.net/fs19/PRE/f/2007/273/f/e/Oblivion__Character_Creation_by_TheMinttu.jpg
21:44:14 <Okasu> just joking :)
21:44:21 <slack1256> shachaf: OMG, how is that, i don't even
21:44:50 <Okasu> Cale: how if you don't know no names of future contorollers nor other internal stuff?
21:44:53 <Cale> Okasu: yeah, I don't think there's a good reason to even want to defer that to runtime and handle it by catching exceptions
21:44:54 <ion> instance Num a => Num (a -> a)
21:45:21 <shachaf> Cale: You clearly don't get the Rails Philosophy.
21:45:22 <ion> where fromInteger = const
21:45:23 <Okasu> Cale: but yeah "because i can" plays vital part of that
21:45:28 <Cale> Okasu: If you don't know their names, then you can't write any code which could use those names in a way that the "not in scope" catcher could deal with it.
21:45:29 <shachaf> ion: That has nothing to do with return 3 4
21:45:39 <shachaf> > return 3 4 5 :: Int -- This, on the other hand...
21:45:40 <lambdabot>   3
21:45:41 <Cale> Okasu: right?
21:45:57 <ion> Duh, i skimmed through the discussion too hastily.
21:45:59 <shachaf> > return return 1 2 3 4 5 :: Int
21:46:00 <lambdabot>   2
21:46:10 <Cale> Okasu: because you need to know the name of the thing to be able to write the code which will cause the error in the first place
21:46:41 <Cale> So you *have* to know it at compile time
21:46:43 <ddarius> Cale: Unless you write the code that calls the thing at run-time.
21:46:44 <ion> instance Monad (a -> a) where return = const
21:47:08 <ion> err. a -> b
21:47:12 <shachaf> ion: Just (a ->)
21:47:39 <ion> Perhaps i shouldn’t think about code when i’ve been awake too long.
21:47:48 <ddarius> Cale: But yes, a lot of this could be done by compile-time metaprogramming, but since Ruby doesn't really have a compile-time meta-programming framework, run-time it is.
21:48:02 <ddarius> ion: I recommend not thinking about code at all.
21:48:06 <ion> Sounds good
21:48:12 <slack1256> shachaf: i need to find that instance.
21:48:14 <Okasu> Cale: no, code which could use those names being created dynamically with those func_names
21:48:36 <Cale> Okasu: use String
21:48:47 <shachaf> slack1256: It's in the last place you'd ever think to look for Control.Monad Instances.
21:48:49 <Okasu> Cale: it's ugly
21:48:56 <Cale> No it isn't.
21:49:07 <ddarius> "I'd rather destroy the semantics of my entire language, thank you very much."
21:49:10 <Cale> Functions intrinsically having names attached to them is ugly.
21:49:47 <Okasu> Cale: yep, and so i'm here :)
21:49:48 <shachaf> Can we just go straight to "NO UR FACE IS UGLY" and then leave it be?
21:50:13 <Peaker> when writing cabal test suites -- can modules inside executables be imported for test purposes?
21:50:24 <Cale> If you're referring to something by the use of a String, call a string a string. :)
21:50:59 <slack1256> Peaker: you could use a haskell script which import that module and run it with runghc on each test
21:51:04 <shachaf> Peaker: "text" does it by having tests/tests.cabal which imports files from ..
21:51:17 <ddarius> Am I the only one that finds UU papers difficult to be motivated to read?
21:51:22 <shachaf> Well, I guess that's not "inside executables".
21:51:26 <shachaf> But it's an unexported module.
21:51:31 <shachaf> UU as in uu.nl?
21:51:39 <ddarius> shachaf: Yes.
21:52:11 * shachaf tries to recall a UU paper.
21:52:41 <Cale> ddarius: *all* of the research coming from that university is difficult to motivate? :)
21:53:25 <ddarius> Cale: Some of the stuff is reasonably cool, but it doesn't really show in the papers.  You get half way through them, but then don't really feel like reading on.
21:53:35 <ddarius> Hmm, I guess for my current purposes I just need a 0.5usec and 1.0usec pulse and ways to shift and sum them.
21:54:54 <rosie> what does it mean when the argument of a lambda is of this form? (_ :: Cat)
21:55:03 <Cale> ddarius: That's the most sequitur remark I've seen in a while.
21:55:19 <ddarius> Cale: I didn't say the work was unmotivated, it's my drive to read the work that loses motivation.
21:55:36 <Cale> (SUDDENLY SIGNALS)
21:55:44 <ion> The type of the parameter is Cat and any value will match without gettin bound to a name.
21:56:02 <rosie> ion: thanks!
21:56:03 <Cale> rosie: It means we want the argument to be a Cat, but that we're going to ignore that argument
21:56:04 <geekosaur> rosie, that's a pattern signature.  (requires an extension)  it just assigns a type on the fly to the (wildcard) pattern, since lambdas can't be given an explicit signature
21:56:10 <Cale> oh
21:56:29 <ion> Lambdas can’t be given an explicit signature?
21:56:37 <Cale> they can
21:56:45 <ddarius> Parameters can't.
21:56:47 <shachaf> That's not in Haskell 2010, yes.
21:56:50 <ddarius> Or rather pattern bound variables.
21:56:51 <shachaf> You need ScopedTypeVariables.
21:56:56 <shachaf> (In GHC.)
21:56:59 <geekosaur> yeh
21:57:01 <shachaf> ScopedTypeVariables is overkill, of course.
21:57:12 <ddarius> Haskell should have always had scoped type variables.
21:57:22 <ddarius> (It should also have always had explicit foralls.)
21:57:35 <geekosaur> foralls were difficult back then, no?
21:57:40 <Cale> I really wish I could find the original Haskell committee mailing list archive
21:57:41 <geekosaur> or at least thought to be
21:57:55 <ddarius> geekosaur: I didn't say higher-rank types, just the requirement to explicitly bind type variables.
21:58:02 <geekosaur> ah
21:58:12 <Cale> (i.e. pre H98)
21:58:15 <shachaf> ddarius: You think the uppercase-lowercase thing isn't a good idea in general?
21:58:23 <ddarius> shachaf: That's fine.
21:58:37 <ddarius> I think implicitly bound variables isn't a good idea.
21:58:42 <Peaker> scoped type vars could be enabled by default, even for variables that don't have explicit foralls -- would be more newbie friendly
21:58:54 <shachaf> Peaker: Not without breaking compatibility, presumably.
21:59:11 <ddarius> shachaf: It would break compatibility but probably on an extremely small set of programs.
21:59:12 <Peaker> shachaf, yeah, unfortunately..
21:59:17 <ddarius> (Actual programs that is.)
21:59:35 <Cale> I wonder if anyone saved it
21:59:55 <Cale> There were arguments in there about scoped type variables
22:00:27 <Cale> (I can't remember if it was for Haskell 98 or a previous version, but people were talking about it)
22:01:01 <ddarius> I'd imagine it would've come up pretty early on.
22:01:34 <Cale> It was really interesting to read how a lot of the decisions about the language got made (if in a haphazard and error prone way)
22:01:50 <Cale> but I don't recall exactly where I read it
22:02:08 <ddarius> The History of Haskell paper covers some of it.
22:02:15 <Cale> dons apparently has an archive, but the links to it are broken
22:02:26 <Cale> http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/threads.html
22:02:41 <Cale> (I'm not 100% sure that's the right list
22:02:42 <Cale> )
22:03:54 <geekosaur> the wayback machine has that, fwiw
22:04:03 <Cale> oh, cool
22:06:55 <ddarius> Hmm
22:07:18 <Peaker> Is there a package that makes a type family so that Map Int is not "slower" than IntMap?
22:07:36 <Cale> It's too bad that universities aren't generally better at keeping their grad students' stuff from dying after they leave. There's a lot of useful material online which dies like that.
22:07:58 <geekosaur> bah.  so, that particular page is indexed, I found a likely threrad, wayback mchine tells me page not saved :(
22:08:06 <Cale> yeah
22:08:10 <Cale> I saw that too
22:08:26 <Cale> There's an obvious discussion about the scope of type variables there
22:08:57 <Cale> dons y u no irc anymore?
22:09:16 <geekosaur> yeh :(
22:09:59 <geekosaur> preflex: seen dons
22:10:00 <preflex>  dons was last seen on #ghc 46 days, 11 hours, 51 minutes and 41 seconds ago, saying: i don't recall a time that the hetzner's been down before
22:10:19 <geekosaur> hm, he's been in #xmonad slightly more recently than that, I think
22:10:35 <geekosaur> but not really recently
22:15:36 <geekosaur> and google finds only one relevant hit which points back to dons' archive.  apparently nobody else has the fplangc list archived
22:20:32 <geekosaur> hm, can;t find that thread, but mail-archive.com has http://www.mail-archive.com/haskell@haskell.org/msg02535.html et seq.
22:24:09 <nand`> Wow
22:24:20 <nand`> it took me like 4 hours to debug this encoding issue, and at the end it turns out package HTTP uses .Char8.pack
22:24:33 <nand`> can I have somebody's shoulder to sob onto?
22:24:49 <ddarius> There's a lot to love about the HTTP package.
22:27:07 <pharaun> :\
22:27:24 * pharaun is going to have to clean up the testing char8 stuff out and replace it with proper utf8 encode
22:28:21 <nand`> What's the preferred way of getting :: String -> ByteString using UTF-8?
22:28:41 <nand`> I could go via Data.Text's pack/encodeUtf8 or I could go via utf8-string's fromString
22:29:17 <JoeyA> nand`: Whichever doesn't introduce another dependency.
22:29:32 <nand`> (it would be nice if performance isn't disregarded entirely)
22:29:52 <JoeyA> I wonder if fusion takes care of that or not.
22:29:53 <nand`> oh, there's already a dependency on utf8-string; excellent
22:29:55 <geekosaur> utf8-string was originally intended for this kind of thing, no?  Data.Text would be better if you were using Text instead of ByteString?  that said, another option is to use the encoding stuff inside of GHC
22:30:08 <JoeyA> But there's a slight semantic difference.  Text uses UTF-16 internally.
22:30:11 <pharaun> oh there's encoding stuff inside ghc?
22:30:35 <JoeyA> UTF-16 cannot represent code points from U+D800..U+DFFF.  These are reserved for surrogate pairs, and are invalid Unicode code points.
22:30:55 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/GHC-IO-Encoding.html
22:31:15 <geekosaur> utf8-string predates ghc's encoding support
22:31:29 <JoeyA> Ah, good to know.
22:31:30 <geekosaur> and I think is easier to use
22:31:51 <JoeyA> Is that new in base 4.5 ?
22:31:56 <nand`> hmm; this package doesn't seem to have a Setup.hs; is there some system default one I can backup to?
22:32:29 <geekosaur> the encoding stuff?  goes back to ghc 6.12 or thenabouts, IIRC
22:33:37 <geekosaur> definitely was present in 6.12.1
22:34:11 <geekosaur> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/GHC-IO-Encoding.html
22:34:30 <mk> does the third monad law simply state that the structure used to store monadic values must be a monoid?
22:35:54 <mk> s/store monadic values/store the values which make up monadic values
22:36:04 <JoeyA> I think so.
22:36:41 <JoeyA> Someone presented a nice-looking formulation of the monad laws using >=> .  I forget where I saw it.
22:37:16 <mk> JoeyA: Cale in this channel earlier, and http://www.haskell.org/haskellwiki/Monad_Laws
22:37:22 <n00b6502> has anyone done direct-X bindings for haskell
22:38:30 <rosie> what does the forall do in this function declaration? withPolicyModule :: forall a pm. PolicyModule pm => (pm -> DBAction a) -> DC a
22:38:59 <mk> the name sort of tips you off, but the point is that the third law is simply saying something about the structure used to store values, whether those values are actually "originals" (like, the stuff that return takes), or various forms of metadata (such as Nothing, or writer logs, or whatever)
22:39:32 <rosie> here's an example:  withPolicyModule $ \(_ :: SomePolicyModule) -> do
22:39:33 <rosie>   -- Perform database operations: insert, save, find, delete, etc.
22:39:57 <mk> that structure itself has to be a monoid, in order for bind to use its "combining" operation to correctly mash things together
22:40:14 <JoeyA> rosie: It means the function works for all types a and pm.
22:40:28 <JoeyA> forall a pm. PolicyModule pm =>
22:40:49 <JoeyA> That means: for all types a and pm, where there's an instance PolicyModule pm, we have a function of type ...
22:41:41 <JoeyA> When you have a signature like id :: a -> a, there's an implicit forall in there.
22:42:04 <rosie> you mean when it's parameterized?
22:42:35 <rosie> how can a take on different values DBAction and DC on the same line?
22:43:12 <rosie> If it helps, here's an example of its use:
22:43:13 <rosie>  withPolicyModule $ \(_ :: SomePolicyModule) -> do
22:43:14 <rosie>   -- Perform database operations: insert, save, find, delete, etc.
22:45:48 * shachaf sighs.
22:45:56 <shachaf> Someone took inspiration from Exception?
22:46:16 <rosie> eh?
22:47:49 <shachaf> Exception has APIs that are used like catch foo $ \(x :: SomeException) -> ...
22:47:50 <nand`> he means the existentials
22:48:16 <shachaf> It's not just the existentials that I have a problem with, but yet.
22:48:56 <shachaf> Robert Harper recently wrote this post criticizing it, which is reasonable, but for silly reasons.
22:49:36 <shachaf> But I wish people would think twice about isomorphic representations before doing that sort of thing.
22:49:59 <JoeyA> What do you mean by isomorphic representations?
22:50:20 <shachaf> I don't know.
22:57:12 <kish> .
23:07:17 <qnikst> hello, I have MonadResource m monad and can throw exceptions from it, but is it possible to catch them inside MonadResource&
23:08:04 <shachaf> When you ask questions like that it helps to tell people what MonadResource is.
23:08:29 <Okasu> https://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/#comment-799 why did hw said that?
23:08:40 <Okasu> why it's broken?
23:08:54 <shachaf> http://hackage.haskell.org/packages/archive/resource-simple/0.2/doc/html/Control-Monad-Resource.html has a MonadControl instance, which I think is about catching exceptions.
23:09:34 <shachaf> Robert Harper said that.
23:09:41 <shachaf> Oh, "why", not "who".
23:09:51 <qnikst> sorry, http://hackage.haskell.org/packages/archive/resourcet/0.3.3.1/doc/html/Control-Monad-Trans-Resource.html
23:09:58 <shachaf> He probably said it because he's a h8r.
23:10:11 <shachaf> That's why they all say it. :-(
23:11:23 <Okasu> shachaf: but is there any starting point of that *cough* point of view?
23:11:34 <Okasu> why they think it's broken?
23:11:39 <shachaf> Please don't cough in here. It's rude.
23:11:52 <shachaf> Why don't you ask Robert Harper?
23:11:55 <ddarius> "Please cease all bodily functions."
23:12:34 <Okasu> shachaf: so you think type system in haskell is ideal?
23:12:37 <shachaf> I have no problem with Okasu's coughing in general, but bringing it into IRC is a different matter.
23:12:39 <zzing> If I wanted to model a cpu, what would be the best sort of structure to model ram consisting of x kb to mb?
23:12:52 <shachaf> Okasu: No.
23:13:14 <Okasu> shachaf: what's wrong with it then?
23:13:18 <ddarius> zzing: A mutable, unboxed array, unless you are particularly looking for a pure solution and don't care about performance at all.
23:13:43 <shachaf> Okasu: I'm not in the mood to tell you why Haskell is a bad language, nor why it's a good language.
23:13:49 <zzing> ddarius: I do care for performance, but a pure solution is desired if it ins't too costly
23:13:50 <shachaf> If you have some specific question you should ask it.
23:14:05 <zzing> I would love one not needing the IO monad
23:14:17 <ddarius> zzing: You'd only need the ST monad.
23:14:57 <zzing> ddarius: I haven't really used them, but would lens be of any use?
23:15:28 <ddarius> zzing: Not really for what you've asked.  They also don't really solve that problem, though they likely solve other problems you will have.
23:16:15 <ddarius> You -could- use something like an IntMap, but I suspect having a "pure" structure won't actually change the structure of your code much and will, in this case, incur a massive performance penalty.
23:16:24 <zzing> ddarius: what would you suggest I use to have as much speed as reasonable in a random access read/write operation for the ST monad?
23:16:47 <zzing> I am having trouble thinking up something specifically
23:17:07 <zzing> I will be implementing the CPU as a state machine (I found a paper that has a state machine already described for me)
23:18:06 <nand`> Hmm, my application is crashing out with an error like “Enum.toEnum{Word8}: tag (8469) is outside of bounds (0,255)”
23:18:21 <nand`> how do I figure out which of the 50000 components is to blame?
23:18:55 <shachaf> Look for places where you're calling toEnum.
23:19:07 <ddarius> nand`: Or compile with profiling and pass the runtime flag -xc.
23:19:15 <shachaf> That sometimes works.
23:19:50 <zzing> ddarius: Is there a structure that is easy to update sections that I can just pass on to the next iteration, and thus keep it pure?
23:19:55 * shachaf makes a note to recommend toEnum instead of fromIntegral when people insist they're absolutely sure their Ints won't have out-of-values.
23:20:00 <shachaf> @where rts-xc
23:20:01 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
23:20:06 <nand`> shachaf: that's what I did first; I checked the four or so libraries I modified and investigated each toEnum; none of them seemed to have anything to do with Word8 (they all seemed safe)
23:20:31 <nand`> I.. oh
23:20:33 <nand`> I think I found it
23:20:44 <zzing> Perhaps data.sequence?
23:21:07 <nand`> toBLBS :: String -> LBS.ByteString; toBLBS = LBS.pack . map (toEnum . fromEnum)
23:21:15 * nand` sobs
23:21:47 <shachaf> Sounds like someone was being racist.
23:23:22 <nand`> nope; apparently it's not even that function
23:23:35 <dolio> Why are the only options, "Bob Harper is right about everything Haskell," and "Haskell is ideal"?
23:24:35 <ddarius> zzing: You could use a DiffArray which is supposed to have optimal asymptotic performance for linear usage.
23:24:51 <ddarius> Though it has been claimed to have pretty horrible absolute performance.
23:25:26 <ddarius> dolio: Man, you'll never pass Trolling 101.
23:25:34 <dolio> Damn!
23:28:02 <zzing> "Diff  arrays have an immutable interface, but rely on internal updates in place to provide fast functional update operator //. "   that is so evil is it not?
23:28:46 <shachaf> It doesn't seem evil in principle.
23:29:08 <zzing> shachaf: it violates referential transparency does it not?
23:29:13 <shachaf> No.
23:29:13 <dolio> No.
23:29:18 <shachaf> That's the point.
23:29:32 <dolio> The problem is that it doesn't work very well, apparently.
23:29:47 <lpsmith> hey,   with snaplets and configurator,  does anybody know where you are supposed to put the configuration file?
23:30:13 <shachaf> lpsmith: strace to the rescue!
23:30:26 <shachaf> strace -fo OUT ./program; grep open OUT
23:31:30 <lpsmith> thanks shachaf
23:32:04 <nand`> hmm, the output of -xc doesn't seem to be very useful
23:32:19 <shachaf> lpsmith: Did that actually help?
23:32:39 <nand`> it goes trhough a list of Snap stuff and then stops somewhere at Snap.Internal.Types.liftIO
23:33:57 --- mode: wolfe.freenode.net set +o ChanServ
23:34:57 <lpsmith> shachaf, yes,  thanks a bunch  =)
23:35:08 <shachaf> Hooray!
23:35:09 <shachaf> strace++
23:36:36 <ddarius> Someone should make a buddha plugin.
23:38:24 <lpsmith> buddha?
23:38:54 <lpsmith> @karma strace
23:38:55 <lambdabot> strace has a karma of 4
23:39:06 <shachaf> preflex: karma strace
23:39:06 <preflex>  strace: 22
23:40:56 <zzing> Is Data.StateVar the state monad?
23:41:25 <ssbr_> zzing: Control.Monad.State
23:41:47 <zzing> I have a control.monad.st not state
23:42:04 <ssbr_> this one is from mtl
23:42:11 <ssbr_> I don't know anything about the ST monad
23:42:22 <zzing> Is there anything real special about mtl?
23:42:37 <shachaf> Control.Monad.ST and Control.Monad.State are very different.
23:43:00 <ssbr_> zzing: it provides the state monad...
23:43:03 <ssbr_> that's special
23:44:10 <zzing> Do we have a data structure using the state monad that allows constant time read and write?
23:44:43 <ssbr_> that isn't what the state monad does.
23:45:03 <ssbr_> The state monad is sort of like getting access to one rebindable variable, whereas usually you can't "rebind" anything in haskell
23:45:19 <ssbr_> at least IIRC. I don't actually know haskell.
23:45:23 <zzing> ssbr_: I should add, something like an array :-)
23:45:34 <ssbr_> zzing: then maybe you want the ST monad, not the state monad.
23:46:45 <zzing> I could use the memory stuff to get the array, dirty, but it would be fast
23:48:32 <ssbr_> speaking of me not knowing haskell: how does one write unit tests that integrate with cabal? I've found stuff on 2008 that's out of date now, because cabal has support for unit tests... and I've found that support for unit tests. But I haven't found how to actually use cabal with a unit test framework like HUnit
23:49:09 <ssbr_> like, the docs for cabal + unit tests are aimed at the authors of HUnit. They explain how to make the unit test framework interoperate with cabal. But not how, as a user, to write a unit test suite that works with cabal
23:50:10 <dcoutts_> ssbr-: you make an executable that runs the unit tests and returns an exit code of 0 or non-0
23:50:15 * hackagebot io-choice 0.0.2 - Choice for IO and lifted IO (KazuYamamoto)
23:50:59 <ssbr_> dcoutts_: that's not what the cabal docs say!
23:51:14 <dcoutts_> ssbr-: and rather than listing that exe as a normal exe in the .cabal file, you list it as a test-suite
23:51:16 <ssbr_> dcoutts_: I mean, they mention that, but they say that's not the recommended way to write new unit tests
23:51:25 <ssbr_> uhhh, I've lost the relevant cabal doc page
23:51:32 <ssbr_> but there's another way that involves actual integration with cabal
23:51:37 <ssbr_> I was hoping HUnit supported that
23:51:45 <zzing> ssbr_: find an example :-) I don't know one mind you.
23:52:00 <ssbr_> zzing: an example re my question or yours?
23:52:22 <dcoutts_> ssbr-: right, those docs refer to the detailed test interface, unfortunately those docs were written somewhat in advance of the feature being finalised.
23:52:22 <ssbr_> dcoutts_: see http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
23:52:34 <ssbr_> dcoutts_: Oh, so there's no such thing as detailed tests?
23:52:47 <dcoutts_> ssbr-: it's not available in a release
23:52:52 <ssbr_> I have an idea
23:52:59 <ssbr_> let's not publish docs about things that don't exist yet
23:53:21 <ssbr_> serious time waster dude
23:53:42 <dcoutts_> the docs were written at the same time as the code, but then the feature was disabled for the release as it wasn't ready yet
23:53:47 <dcoutts_> docs got missed
23:54:00 <shachaf> There's no need to be rude, ssbr_.
23:54:17 <dcoutts_> ssbr-: the bit in the docs about the basic test interface are fine
23:54:27 <ssbr_> shachaf: Yeah, I guess.
23:54:41 <ssbr_> It's just that I have spent a lot of tiem researching this because I didn't want to waste #haskell's time with a stupid question
23:54:51 <ssbr_> and it feels really crap to find out, ha ha, I was lied to this isn't a thing
23:54:58 <ssbr_> shoe's on the other foot now!
23:55:29 <ssbr_> dcoutts_: OK, thanks
23:56:08 <zzing> ssbr_: don't worry, I waste #haskell's time with stupid questions all the time. Because it is usually the best way to get answers without spending hours without knowing.
23:56:30 <ssbr_> zzing: I can see some flaws with this system.
23:56:49 <zzing> ssbr_: well there is no such thing as a stupid question
23:57:05 <Ralith> I disagree.
23:57:30 <ssbr_> zzing: "Has anyone really been far even as decided to use even go want to do look more like?"
23:57:38 <shachaf> zzing: You shouldn't waste #haskell's time.
23:58:05 <zzing> shachaf: that statement was rather meant as a joke
23:58:30 <zzing> ssbr_: parse error
23:58:55 <ssbr_> zzing: it's an internet meme, don't mind it.
23:59:23 <zzing> ssbr_: I am glad to ignore memes as much as I can. My eyes were already stained by the giver and reciever.
