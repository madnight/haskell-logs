00:00:24 <Ralith> I didn't get a lot of errors, but when one occurred, spontaneous crashing was not a fun way to learn about it.
00:01:51 <ddarius> Where's the excitement in life if you can't look forward to a minor typo in your code leading to millions of dollars lost or loss of life?
00:02:13 <Enigmagic> Ralith: it's not really that big of a deal. the compiler works even though it's slow to build... if and when ghc gets native type-nats support i'll patch the llvm bindings to support it.
00:03:01 <ddarius> Enigmagic: What representation of numbers is it using?  Unary?
00:03:07 <Ralith> it's a big deal if it's stalled your work!
00:03:24 <LordBrain> speaking of q monad, i have a question, and i think someone solved it for me ages ago, but i didn't store it anywhere.  How would I implement scheme's "cut/e" macros.  They are like doing partial applications except you indicate slots for the missing parameters.  I want to use () a the slot.
00:04:00 <LordBrain> here's a fuller description of the macro: http://srfi.schemers.org/srfi-26/srfi-26.html
00:04:15 <ddarius> I, personally, wouldn't.
00:04:48 <ddarius> But you'd just parse applications and decide on what you want to use to indicate the holes.
00:04:49 <Enigmagic> ddarius: base 10... so 'type D999 = D9 :* D9 :* D9'
00:04:56 <LordBrain> i imagine something like map (cut 'f x () y)
00:05:03 <LordBrain> quoting f
00:05:52 <Enigmagic> Ralith: agreed... i managed to kick the can far enough down the road that all the major functionality works with some arbitrary limitations. like a windowing function can't use lags larger than 64.
00:06:00 <Enigmagic> not great but it works for what i need right now
00:06:10 <Ralith> what does it use type nats for, anyway? Integer width?
00:06:16 <ddarius> So you want to be able to write cut 'f x y HOLE z and have it generate \hole -> f x y hole z ?
00:06:20 <LordBrain> cut there would have to be an n-ary function
00:06:23 <johnw> what does it mean for a Map to be lazy?
00:06:27 <LordBrain> yes
00:06:36 <Enigmagic> Ralith: array sizing
00:06:41 <johnw> does it mean entries aren't inserted into the tree if they aren't ever referenced?
00:06:42 <LordBrain> or it could be using a splice
00:06:52 <LordBrain> i dont mind having to write $(cut ... )
00:06:53 <ddarius> LordBrain: Yes, you can use the pattern used by printf though you may need something to terminate it and/or overlapping instances.
00:07:22 <Ralith> Enigmagic: oh, right, LLVM's C API has variable-length arrays basically everywhere.
00:07:35 <LordBrain> no terminating
00:07:37 <Ralith> (or things that look much like them)
00:07:54 <ddarius> Admittedly, I think you might actually be able to do this as a normal method.
00:08:04 <ddarius> I.e. not by meta-programming.
00:08:30 <LordBrain> yeah i think so, except i dont want to have to write a terminator
00:09:11 <Enigmagic> Ralith: yeah.. it also uses it to represent bit-widths for integers and pointers
00:09:17 <LordBrain> you mean without even quoting the function/
00:09:22 <ddarius> LordBrain: Yes.
00:09:27 <Enigmagic> Ralith: in llvm the C++ api doesn't differentiate between 32 and 64 bit signed/unsigned types
00:09:36 <Enigmagic> or any arbitrary bit-width
00:10:02 <LordBrain> well if we can omit the quote that is nice, but i dont mind it
00:10:08 <Ralith> yeah
00:10:11 <johnw> maybe it's that if you map a function over the map, the values in the resulting mind aren't computed unless used?
00:10:20 <Ralith> wasn't expecting the Haskell binding to statically check that
00:10:21 <Ralith> that'll be nice
00:11:13 <Enigmagic> Ralith: yep, things like that. struct layouts are also statically checked.
00:11:26 <Ralith> whee
00:11:29 <LordBrain> cut was inspired by haskell, so it would be nice for it to come full circle
00:11:35 <LordBrain> :)
00:12:33 <ddarius> Inspired by but completely missing the point.
00:12:57 <Ralith> annoying when that happens
00:13:00 <LordBrain> if it missed your point, it didn't miss someone elses
00:13:09 <Enigmagic> Ralith: which is awesome btw, getelementptr is fully checked at compile time.
00:13:16 <Ralith> yeah
00:13:26 <Ralith> that will save a ton of pain
00:13:34 * Ralith is looking forward to this project even more!
00:14:47 <LordBrain> i think the scheme cut and cut/e expressions are more readable than the lambdas they replace
00:14:58 <vodik> is there an easy way to append two conduit sources to one another?
00:15:05 <vodik> or make another source?
00:15:07 <vodik> *to make
00:15:12 <Enigmagic> vodik: source1 >> source2
00:15:24 <vodik> ty
00:15:35 <ddarius> LordBrain: Until you start doing complicated things or having nested ones.  Also, a large part of that is Scheme's somewhat heavy lambda notation in the first place.
00:16:02 <LordBrain> yeah the notation in scheme is icky, we have it nice
00:16:46 <LordBrain> as for complicated, well... yeah, you know every tool has its uses and abuses
00:17:13 <Enigmagic> vodik: mappend/mconcat also works
00:17:20 <vodik> okay
00:17:29 <vodik> just going to ask, since im doing foldl1 (>>)
00:17:36 <vodik> ty
00:17:57 <Enigmagic> mconcat [source1, source2, ...]
00:18:10 <Enigmagic> would also work but fold1l (>>) should be equivalent
00:18:29 <vodik> yeah
00:18:35 <frelux> if i have a datatype like data Node = Node NodeName [Node], how do I walk it getting back a list of all possible paths to the root (as lists of node names)? (assuming it forms a DAG)
00:18:41 <vodik> mconcat is a little nicer though
00:18:42 <vodik> ty
00:18:47 <Enigmagic> np
00:19:55 <danr> frelux: Data.Tree
00:20:28 <frelux> thanks!
00:20:31 <danr> np :)
00:22:08 <felipe_rosa> hi guys, anyone has a sugestion to a good functional reative programming tutorial? I'm a beginner in that topic.
00:23:56 <johnw> danr: I'm looking at Data.Tree, but I don't see how that answers his question?
00:24:01 <belgin> I've looked at the source a bit closer and i've found that the (Map k) functor is defined something like "fmap func m = map func m". if m is of type Map k v, then how does map know how to work with it?
00:26:04 <LordBrain> one little thing that bugs me about Control.Arrow is the convention of using a for *->*->*  types
00:26:19 <LordBrain> i think if i recall right he really wanted to use alpha or something
00:27:17 <danr> johnw: Well, the functionality is almost there, I think what is needed is really sequence . levels
00:27:25 <LordBrain> a is so commonly used as a polymorphic *
00:27:49 <johnw> for example, the hackage documentation only gives methods for building and printing.  How do I traverse, or return the path to an element?
00:28:00 <johnw> how do I find something?
00:28:10 <johnw> do I have to roll those?
00:28:34 <danr> johnw: the Traversable and Foldable instances
00:28:39 <danr> @find
00:28:40 <lambdabot> parse error (possibly incorrect indentation)
00:28:44 <danr> @hoogle find
00:28:44 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
00:28:44 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
00:28:44 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
00:29:01 <johnw> is there a Data.Tree.find?
00:29:13 <johnw> or am I missing some basic abstraction?
00:29:18 <LordBrain> @type arr
00:29:19 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
00:29:30 <srhb> johnw: There's Data.Foldable.find, and Data.Tree has an instance for Foldable.
00:29:36 <johnw> ah, ok
00:29:37 <johnw> thanks
00:29:50 <LordBrain> hat least here we have kind annotation, that is nice
00:29:56 <johnw> that's the piece of the puzzle I was missing
00:30:42 <srhb> johnw: Yeah, realizing the way things are abstracted out really needs some intuition about it. :)
00:31:21 <johnw> the code I'm writing at the moment to create Git commits from Svn revisions is using nested maps, but now I realize a rose tree is just the right "shape"
00:31:36 <LordBrain> Oleg, are you the Oleg Kiselyov of HList?
00:31:37 <srhb> johnw: Excellent!
00:32:58 <LordBrain> if so, check this out, if i uncomment the line with the let binding and comment the line above it (which i would think is equivalent), ghc complains. http://hpaste.org/73718
00:34:10 <johnw> well, no, I need name indexing
00:34:21 <johnw> because the same value can appear at different places under different names
00:35:11 <LordBrain> happens without monomorphism restriction too
00:35:36 <LordBrain> let bug = hReverse (HCons x l) in bug  --- fails to compile
00:35:54 <LordBrain> but simply hReverse (HCons x l) --- compiles fine
00:36:10 <LordBrain> even with -XNoMonomorphismRestriction
00:37:15 <LordBrain> is it a ghc bug, or is there some strange type foo or let binding foo that i just dont understand.
00:38:03 <danr> let is not generalised
00:38:17 <danr> is that what happens here? me wonders
00:38:52 <danr> here's the article about it: http://research.microsoft.com/pubs/102483/tldi10-vytiniotis.pdf
00:39:36 <LordBrain> thanks
00:40:06 <notdan> http://research.microsoft.com/apps/pubs/default.aspx?id=151805
00:40:42 <belgin> in the Map k functor defined as fmap func m = map func m, what type is m? is it Map k v?
00:42:54 <johnw> what's the type signature?
00:43:10 <belgin> of the functor?
00:43:21 <johnw> of fmap
00:43:28 <srhb> :t fmap
00:43:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:43:34 <johnw> that should answer your question
00:43:38 <johnw> f = Map k
00:43:40 <johnw> in this case
00:43:59 <danr> yeah, but m in the definition is a Map k v
00:44:21 <srhb> It's also kind enough (hurhur) to give us the kindedness of the f: (f :: * -> *)
00:44:30 <johnw> fmap :: (a -> b) -> Map k a -> Map k b
00:44:42 <srhb> so the instance must be instance Functor (Map k) where fmap ...
00:44:45 <danr> srhb: ^^
00:44:54 <johnw> thus, the second argument, the m, is Map k a
00:45:35 <belgin> that's what i thought, then how can map work with Map k a?
00:45:46 <johnw> how do you mean?
00:46:03 <srhb> belgin: Look at the f in fmaps definition
00:46:07 <belgin> in the definition, fmap func m = map func m
00:46:08 <srhb> belgin: It is given a type as argument
00:46:39 <srhb> belgin: Its arguments when called are thus of kind *, not * -> *
00:46:53 <johnw> are you asking how are maps mappable?
00:47:06 <srhb> f a in the case of map is (Map k) a, meaning Map k a
00:47:11 <srhb> er, fmap.
00:47:43 <danr> belgin: oh, the map in the definition is Data.Map.map, not Data.List.map
00:47:49 <danr> @hoogle Data.Map.map
00:47:50 <lambdabot> Data.Map module Data.Map
00:47:50 <lambdabot> Data.Map data Map k a
00:47:50 <lambdabot> Data.Map map :: (a -> b) -> Map k a -> Map k b
00:48:04 <belgin> well that makes sense now
00:48:10 <johnw> ah
00:48:21 <johnw> yes, reading that as List.map would be rather confusing
00:58:36 <ddarius> So I have a cut method that works for monomorphic types.
01:00:31 <ddarius> I wonder what happens if I use equality constraints...
01:01:22 <LordBrain> oh yeah?
01:03:53 <ddarius> Wait it isn't working.
01:05:03 <ddarius> I realize what I need to do now, but it's way to late/early for this.
01:06:05 <LordBrain> np
01:06:27 <LordBrain> if you want you can email it to me later >:D
01:26:51 * hackagebot htime 0.3 - Timing utility for the command line  http://hackage.haskell.org/package/htime-0.3 (JosePedroMagalhaes)
01:35:11 <belgin> what's the difference between "data Person = String String Int" and "data Person = Person String String Int"?
01:36:57 <srhb> belgin: One has String as a value constructor, another has Person as one.
01:38:00 <srhb> belgin: In the first, you get a Person by String "foo" 2, in the second, Person "First" "Last" 30
01:39:07 <belgin> i see now, thanks a lot srhb
01:47:07 <Phil> When trying to install glib using cabal I get the error "setup.exe: The program pkg-config version >=0.9.0 is required but it could not be found". Is this a paths issue?
01:49:05 <belgin> it could mean that you either don't have pkg-config in your path, or you don't have pkg-config at all, or your version of pkg-config is too old
01:52:17 <Hadaka> I need to create a simple ByteString as sprintf style "%d-%d/%d" - what's the best way to do this?
01:53:43 <Hadaka> show and concatenations, printf, or something? I've found some code which looks really ugly, filled with fromShow, c2w, etc.
01:56:11 <Lemmih> Hadaka: I'd use printf.
01:56:46 <Lemmih> pack $ printf "%d-%d/%d" a b c
01:57:58 <Hadaka> Lemmih: looks good
01:58:29 <mikeplus64> Hadaka: or maybe use http://hackage.haskell.org/package/bytestring-show-0.3.5.2
01:59:47 <mikeplus64> and then something like B.concat [B.show a, "-", B.show b, "/", B.show c]
02:00:41 <tdammers> I'd really like to see some kind of string formatting lib
02:00:56 <tdammers> the concatenation approach works, kind of, but it looks ugly
02:00:56 <shachaf> pack :: [Word8] -> ByteString. :-(
02:01:04 <shachaf> What you want is encodeUTF8, or something.
02:01:06 <mikeplus64> tdammers: i have my QuasiText package
02:01:19 <tdammers> lemme check that out
02:01:29 <mikeplus64> that lets you have Text literals like [embed|$x $y hi $z|]
02:02:03 <Hadaka> someone reimplement python's .format() in haskell: http://docs.python.org/library/string.html#format-string-syntax
02:02:06 <tdammers> hey, wait, my own hako quasiquoter does pretty much the same :P
02:02:13 <mikeplus64> haha
02:02:26 <tdammers> only I use {} instead of $()
02:02:33 <mikeplus64> a ByteString version of them would be useful
02:02:45 <tdammers> should be doable
02:02:53 <mikeplus64> definitely
02:03:07 <shachaf> ByteStrings are for bytes, not characters. :-(
02:03:35 <tdammers> sure
02:03:48 <tdammers> but sometimes, treating bytes as characters is acceptable
02:03:56 <mikeplus64> shachaf: we're just dangerous (i don my sunglasses)
02:04:13 <shachaf> If only dons was here.
02:04:22 <mikeplus64> haha
02:04:25 <shachaf> I heard dons dons suits these days.
02:09:58 <AfC> shachaf: *after* months of newbiness trying to use ByteStrings as better Strings, I found the line in LYAH a that said they were byte sequences. Felt like quite the dummy at that point.
02:10:08 <shachaf> Months?
02:10:17 <AfC> {shrug}
02:10:29 <shachaf> Should've looked at http://hackage.haskell.org/package/bytestring :-)
02:10:44 <shachaf> The equivalent of ByteString for Char is Data.Text
02:10:44 <AfC> If Data.ByteString.Char8 didn't exist, I probably would have figured it out sooner
02:10:48 <srhb> Honestly, I felt the same. ByteStrings were super confusing to me. I still sometimes have trouble with them, partly because lazy and strict bytestrings are just ByteStrings. :P
02:10:56 <shachaf> Data.ByteString.Char8 is the devil.
02:11:11 <tdammers> UNIX is the devil.
02:11:25 <tdammers> char* and all that
02:11:30 <shachaf> srhb: Well, now you know! (Or do you?)
02:11:49 <shachaf> srhb: You should read some of the ByteString implementation code! Then it'll all make sense.
02:11:57 <AfC> srhb: totally. I *wish* someone would deprecate both of them and just whack them behind the same interface. Talk about an implementation detail that I don't need to know; worse, the only way to find out is to hover over a signature in Haddock in a browser, and squint at the tooltip saying what the link is and whether or not it has ".Lazy." in it. Worst. API. Ever.
02:12:17 <srhb> AfC: I agree. It's really bad.
02:12:26 <srhb> It's not transparent at all.
02:12:41 <srhb> shachaf: I'd rather people stopped using it :P
02:12:48 <shachaf> And used what instead?
02:12:59 <srhb> Something smarter, obviously!
02:13:05 <srhb> Which may or may not exist yet :P
02:13:08 <bitonic> AfC: reading the docs at the top of Data.BS.Char8 would have been enough :)
02:13:15 <AfC> bitonic: :) true
02:13:23 <shachaf> srhb: Feel free to propose it!
02:13:31 <bitonic> also, the `unpack :: ByteString -> [Word8]' is a good clue
02:13:32 <AfC> bitonic: but as is often the case in Haskell land, unless you already know what they're talking about, you probably won't get it.
02:13:33 <srhb> shachaf: I know, I know...
02:13:47 <shachaf> srhb: I agree the situation could be better. But still.
02:14:05 <bitonic> AfC: wait what do you propose to deprecate?
02:14:42 <bitonic> String, Text and ByteString all have a reason to exist... and Char8 is useful
02:14:46 <AfC> shachaf: I've been wondering: given the push to constant space/time programming via Enumerator | Conduit | Pipe paradigms, does that more or less circumvent needing to worry about the inefficiency of list construction (which is the problem behind [Char] strings)
02:14:53 <srhb> shachaf: Oh, really, it doesn't annoy me that much, and I wish I could convey the confusion better, because I think a lot of people run into it.
02:15:16 <AfC> shachaf: I mean, at this point, you wouldn't do anything with a large data set _without_ streaming it through one of those models
02:15:20 <shachaf> srhb: Good documentation is surely appreciated too!
02:15:26 <srhb> shachaf: Of course. :)
02:15:28 <shachaf> AfC: Sure you might.
02:16:05 <AfC> bitonic: both ByteString and ByteString.Lazy; replace them with something opaque like, dunno, "Bytes"
02:16:34 <shachaf> Which would be what?
02:16:41 <AfC> bitonic: would clean up a lot of pain for newcomers. {shrug}
02:16:43 <shachaf> ByteString and ByteString.Lazy have rather different semantics.
02:16:44 <AfC> [on this topic]
02:16:58 <shachaf> Well, reasonably different.
02:17:01 <AfC> shachaf: to be sure. But they consistently show up in API documentation as "ByteString"
02:17:03 <srhb> I actually don't quite agree with that, I wish strict bytestrings and lazy bytestrings should have radically different names to start with.
02:17:05 <srhb> That would help.
02:17:05 <AfC> this is awful
02:17:32 <shachaf> OK, so fix Haddock.
02:18:03 <shachaf> srhb: There is one approach to writing modules where each module exports one type, "T".
02:18:22 <shachaf> So you have Data.ByteString.T for strict ByteStrings, Data.ByteString.Lazy.T for lazy, Data.Text.T, etc.
02:18:22 <bitonic> AfC: what's wrong with reading the docs?  the ByteString docs are very clear on what a ByteString is
02:18:42 <shachaf> bitonic: AfC's objection is that lazy and strict ByteStrings are both shown as "ByteString"
02:19:04 <bitonic> shachaf: ah.  well, maybe a LazyByteString would be clearer?  I don't know
02:19:24 <srhb> The error messages are also super confusing because of the names being the same.
02:19:29 <bitonic> deprecating them is not a good idea, lazy BS is silly
02:19:39 <shachaf> http://spl.smugmug.com/Humor/Lambdacats/bitestring/960526295_8MbYf-O-2.jpg
02:19:52 <AfC> bitonic: so, for the purposes of this conversation, I'm reporting what I experienced as a newcomer to Haskell. You can't tell me I'm "wrong"; more to the point, given that we get this in #haskell about once a day, it's fairly obvious that it's a common problem. The documentation may say it, but a newcomer doesn't have the sophistication to understand what it means.
02:19:52 <bitonic> srhb: if you have both in the same module, they'll be qualified in some way
02:20:07 <AfC> All we get told is "use ByteString instead of String"
02:20:25 <shachaf> If anyone tells you to "use ByteString instead of String", they're probably wrong.
02:20:33 <shachaf> Sadly there's a lot of bad advice given in #haskell.
02:20:34 <srhb> bitonic: Yes, which really just makes the error messages more verbose in order to disambiguate the, and it doesn't help.
02:20:37 <AfC> if the meme was "use ByteString instead of [Word8]" I never would have worried about it because ones intro to haskell never encounters Word8 or bytes
02:20:41 <bitonic> AfC: I think the problem is that people don't really read the documentation.  it takes 10 minutes to find out what ByteString and lazy ByteString are.
02:20:46 <tdammers> shachaf: unless what you're manipulating are in fact bags-of-bytes rather than proper strings
02:20:59 <srhb> bitonic: I think imagining that the documentation really fixes this issue is naive.
02:20:59 <shachaf> tdammers: Hence "probably" instead of "definitely".
02:21:04 <tdammers> yeah.
02:21:28 <tdammers> sometimes, however, people just can't tell the difference, or they tell it wrong
02:21:37 <bitonic> srhb: what's the issue here?  people being confused by the `bytestring' package?
02:21:39 <tdammers> HTTP, for example, handles byte streams, not strings.
02:22:06 <srhb> bitonic: Not sure exactly. You'd probably need to round up a lot of noobs and see what happens when you throw them into ByteString land.
02:22:18 <AfC> tdammers: [and they you have the joyful experience of trying to tie, oh, say, a read from a database and flow it into a crypto function. Lazy and Strict Bytestrings in the same module. Pain and suffering]
02:22:22 <shachaf> tdammers: A lot of libraries tell it wrong.
02:22:31 <tdammers> yep.
02:22:41 <tdammers> as I said, UNIX is the devil
02:22:52 <shachaf> tdammers: In UNIX a FilePath is a sequence of any-byte-except-0-or-47.
02:22:58 <tdammers> "A byte is a char" was a bad bad decision.
02:23:02 <bitonic> srhb: I think the confusion is largely deriving from the fact that people can't be bothered to spend half an hour reading the docs
02:23:14 <AfC> Wow. This is quotable.
02:23:29 <shachaf> tdammers: In Windows a FilePath is a Unicode (UTF-16-encoded in the API) string with some characters ruled out.
02:23:37 <shachaf> What do you do for a common FilePath API?
02:23:52 <srhb> bitonic: I think that's a horrible attitude. And I don't think you can really justify saying "ByteString is as understandable as it could possibly be!" :P
02:24:03 * shachaf thinks bitonic's position is somewhat unreasonable.
02:24:23 <tdammers> shachaf: use an opaque type for file paths and hide the platform-specific implementation details away from the public API?
02:24:43 <shachaf> tdammers: OK, but how?
02:24:51 <bitonic> srhb: I did not say that.  we could probably use better docs
02:25:00 <tdammers> language-agnostically, I mean.
02:25:22 <shachaf> In UNIX let's say you're using UTF-8 and you find a file name which contains an invalid UTF-8 sequence.
02:25:22 <tdammers> you'd have to move every language function that uses filenames in any way to the opaque type
02:25:36 <shachaf> OK, it's an opaque type, but what's its interface?
02:25:58 <tdammers> fromString, toString, joinPath, replaceExtension, etc. etc.
02:26:40 <tdammers> if you have a filename with invalid UTF-8, then toString barfs, but you can still pass it around and perform valid operations on it
02:27:18 <tdammers> conceptually, a filename (or FilePath) is not the same thing as an arbitrary String or ByteString, so it shouldn't be represented as the same typer
02:27:23 <tdammers> s/r$//
02:27:43 <tdammers> haven't seen any language yet that does it that way though
02:30:22 <ddarius> Oy, sign errors.
02:30:59 <eikke> what's the syntax to use the same 'handler' for 2 distinct matching patterns?
02:31:25 <shachaf> No particular syntax for it.
02:31:48 <eikke> so I should put my handler in a where clause or something, then match on both aptterns?
02:31:52 <shachaf> You could do something like foo x = case x of { A -> h; b -> h } where { h = ... }
02:31:57 <shachaf> Yep.
02:31:58 <eikke> right
02:32:15 <shachaf> Or restructure your code another way.
02:32:46 <eevar> is it obvious to anyone why this piece of attoparsec would error out, saying "note enough input"? -- http://pastebin.com/zXicn8kb
02:32:48 <tdammers> "case fall-through", hehe
02:32:48 <mauke> The paste zXicn8kb has been copied to http://hpaste.org/73771
02:35:45 <fmap> isn't `try' == `id' for attoparsec?
02:35:50 <nus> tdammers, CL has concepts of namestrings and pathnames
02:36:29 <tdammers> nus: haven't really done any CL yet
02:36:33 <tdammers> good to know though
02:39:18 <Ornedan> What is a GHC "worker task"? The things created in rts/Task.c startWorkerTask? What do they do? What determines how many of them may exist at one time?
02:39:52 <eevar> fmap: try might be a no-op, yes
02:41:10 <fmap> eevar: you should probably provide some sample input that you want to parse
02:44:13 <eevar> fmap: just digging through a file of garbage looking for all occurances of "prefix" s1 "sep" s2 "term", collecting s1 and s2
02:45:03 <eevar> could the problem be that i'm not handling whatever follows the final match?
02:47:56 <frelux> can someone try "cabal install rangemin"? I'm getting "Not in scope: `GM.unsafeNewWith'" here
02:49:30 <strg> here too
02:50:52 <frelux> thanks! : ) i'll email the maintainer
02:51:50 <strg> okey
02:53:22 <fmap> eevar: your code works for me, that's why i've asked for samples
02:55:51 <fmap> works as in "a prefix b separator c term d" parses to `[Company " b " " c "]'
02:58:13 <eevar> fmap: works for me too with the sample i just came up with, sorry.
02:58:21 <belgin> say we have the typeclass "class Tofu t where tofu :: j a -> t a j" and the type constructor "data Frank a b = Frank {field :: b a}" now, when i make Frank an instance of Tofu, "instance Tofu Frank where tofu x = Frank x", x here matches "j a"?
02:58:22 <eevar> now to figure out what is wrong with my real data...
03:07:50 <belgin> also, why does it follow from the fact that the function tofu can only take concrete types as its arguments, the fact that j has to have a kind of * -> * and a a kind of * ?
03:08:41 <shachaf> I'm not sure that that quite follows.
03:09:04 <belgin> that's what it says in the book
03:09:06 <shachaf> But you know j is of kind "something" -> *, because j a is of kind *.
03:09:21 <shachaf> If a is of kind *, then j is of kind * -> *
03:09:38 <belgin> "Because j a is used as the type of a value that the tofu function takes as its parameter, j a has to have a kind of *. We assume * for a and so we can infer that j has to have a kind of * -> *."
03:09:48 <shachaf> See? It doesn't say that in the book.
03:09:56 <shachaf> If you assume that a :: *, then j :: * -> *
03:10:05 <shachaf> If you assume that a :: Hello, then j :: Hello -> *
03:11:08 <belgin> ok so j a must be of kind *, a is of kind *, therefore j is of kind * -> *
03:11:13 <belgin> i don't see how this follows
03:11:30 <shachaf> "a is of kind *" is an assumption.
03:11:45 <shachaf> We know that "j a" :: *
03:11:53 <shachaf> Therefore we know that j :: somethingorother -> *
03:12:02 <shachaf> And that a :: somethingorother
03:12:40 <belgin> so a is applied to j ?
03:13:27 <shachaf> No, j is applied to a.
03:13:33 <shachaf> Try thinking about types instead of kinds.
03:13:42 <shachaf> f a :: Int
03:13:51 <shachaf> So f must be :: something -> Int
03:13:54 <shachaf> And a must be :: something
03:14:05 <belgin> when they say tofu :: j a -> t a j, j and a aren't 2 different arguments to the function tofu, "j a" is a single argument?
03:14:44 <shachaf> Yes. Just like Maybe Int
03:14:55 <shachaf> tofu :: Maybe Int -> Blah Int Maybe
03:20:29 <Shapeshifter> I'm reading about the RTS at http://www.aosabook.org/en/ghc.html . Is it completely wrong to call the RTS a kind of virtual machine? At least, it seems like it does memory management, thread management and it has a bytecode interpreter...
03:23:16 <shachaf> The bytecode mode is mostly used in ghci.
03:23:28 <shachaf> Generally GHC generates native machine code.
03:24:15 <Shapeshifter> Mh, I see.
03:36:17 <nand`> the definition of ‘virtual machine’ changes from project to project also it seems
03:36:52 <belgin> i don't understand what happens when we call tofu Nothing
03:37:10 <billdozr> Any particular reason that one would get a `too few bytes. Failed reading at byte position n' when reading the stream contents via BSL.hGetContents *only* if I omit the S.IO.hClose for that handle?
03:37:31 <shachaf> billdozr: You're not supposed to use hClose with hGetContents.
03:37:54 <belgin> what are a and b in the definition of the Frank type constructor?
03:38:24 <belgin> are they types, variables?
03:38:34 <tdammers> shachaf: yeah, bit me once or twice
03:38:36 <shachaf> Yes.
03:38:56 <shachaf> belgin: Do you know how unification works?
03:38:59 <billdozr> shachaf:right that was my thinking, however if I omit it, I get the error bove hence I wish to know the behavior a bit more intimately.
03:39:15 <belgin> shachaf: i don't know what that is
03:39:16 <shachaf> Oh, if you *omit* hClose.
03:39:37 <billdozr> Right :)
03:39:42 <shachaf> belgin: Unification is probably the answer to all your questions. :-)
03:40:15 <shachaf> billdozr: Are you sure hGetContents is the thing that's failing?
03:40:53 <shachaf> I suspect the error is coming from somewhere else.
03:41:26 <shachaf> At least, the words "byte position" don't seem to appear anywhere in the package "bytestring". :-)
03:41:38 <shachaf> Ah, it's from Data.Binary.
03:41:39 <billdozr> shachaf: Actually not at all; error only occurs when I try to *realize* the data that the hGetContents returns.
03:42:05 <shachaf> billdozr: Are you sure Data.Binary.Get isn't just failing on the binary data?
03:42:59 <billdozr> Well I thought that however adding the questionable hClose in this context solves the problem entirely hence I was a bit puzzled.
03:43:15 <shachaf> The hClose probably closes the handle early.
03:43:22 <shachaf> So only part of the ByteString gets read.
03:43:36 <tdammers> using hClose on a hGetContent-ed file handle doesn't produce any errors
03:43:41 <billdozr> Well it does a pretty dam good job as it returns the entire payload :-)
03:43:43 <tdammers> just prevents reading any more buffers
03:43:48 <shachaf> billdozr: Are you sure about that?
03:43:54 <billdozr> 100%
03:43:55 <billdozr> :)
03:43:55 <tdammers> well yeah, I've seen the same thing
03:44:04 <tdammers> until my payload became larger than an IO buffer
03:44:10 <tdammers> (4 kiB in my case)
03:44:20 <shachaf> billdozr: What if you print (LB.length buf) before doing the hClose?
03:44:31 <billdozr> Will check
03:51:54 * hackagebot HGamer3D-Data 0.1.8 - Library to enable 3D game development for Haskell - Data  http://hackage.haskell.org/package/HGamer3D-Data-0.1.8 (PeterAlthainz)
03:51:56 * hackagebot HGamer3D-Ogre-Binding 0.1.8 - Library to enable 3D game development for Haskell - Ogre Bindings  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.1.8 (PeterAlthainz)
03:53:12 <strg> nice
03:56:58 * hackagebot HGamer3D-SFML-Binding 0.1.8 - Library to enable 3D game development for Haskell - SFML Bindings  http://hackage.haskell.org/package/HGamer3D-SFML-Binding-0.1.8 (PeterAlthainz)
03:57:00 * hackagebot HGamer3D 0.1.8 - Library to enable 3D game development for Haskell  http://hackage.haskell.org/package/HGamer3D-0.1.8 (PeterAlthainz)
04:14:51 <spark_> hello, someone can help me with my fundling with functors? D;
04:15:06 <shachaf> Only if you ask a question.
04:15:45 <spark_> "why it doesn't work " does the job?
04:16:52 <belgin> shachaf: i think i've partially figured it out. a and b in the Frank type constructor definition are data constructors, so when we do tofu Nothing, its type is tofu Maybe a which fits with tofu's type signature, now Frank Nothing works because its type is actually Frank Maybe a, what i don't get is how can x hold for a j _and_ for j a ?
04:17:41 <shachaf> belgin: I have no idea what you said. :-)
04:17:47 <shachaf> a and b are variables.
04:18:33 <nand`> I think this is in reference to that one set of exercises where you need to provide Functor/Monad implementations for a series of common types; but it renames them all so they don't sound scary
04:18:41 <shachaf> No.
04:18:51 <hpaste> spark_ pasted “pattern matching fail” at http://hpaste.org/73773
04:18:53 <shachaf> Not if you're talking about dibblego's fluffy unicorn thing, at least.
04:19:11 <nand`> perhaps there are multiple; but ‘Frank’ and ‘tofu’ sound familiar/related
04:19:30 <belgin> here's the definition of tofu: tofu :: j a -> t a j, and the implementation: tofu x = Frank x, how can x hold for j a and a j?
04:19:33 <nand`> though the second half of the question doesn't make sense then
04:20:01 <shachaf> spark_: Isn't amap f = map (fmap f) ?
04:21:07 <spark_> no because my type is already [FourD b a]
04:21:14 <nand`> (Oh, I also thought belgin's question was asked by spark_)
04:21:19 <spark_> wait, wrong answer
04:21:47 <spark_> no, because f is from [a]->[b]
04:21:52 <byorgey> belgin: t a j =  ((t a) j)
04:22:03 <byorgey> belgin: so  a j  doesn't come into it at all
04:22:24 <billdozr> shachaf: sorry I had top step out for a sec. Regarding checking: LBS.length bs-payload .... It prints out the correct byte size. I tried sending pretty large payload too and it fully arrives on the other end; when I use hClose that is. :)
04:22:47 <belgin> byorgey: are you saying it's been reduced?
04:23:12 <byorgey> belgin: also, given  Frank x :: t a j,  and  x :: j a,  all we know is that   Frank :: j a -> t a j
04:23:32 <byorgey> belgin: you seem to be getting data constructors and type constructors mixed up.  Frank x :: t a j  does not mean  Frank = t
04:23:33 <shachaf> billdozr: So you're doing foo <- LBS.hGetContents h; print (LBS.length foo); hClose h; ...; something foo; and it succeeds, but without the hClose it fails?
04:23:36 <danr> Shapeshifter: thanks for the link to aosabook, really interesting reads :)
04:23:48 <byorgey> belgin: in fact, that doesn't even make sense.  t is a type, and Frank is a data constructor.
04:25:06 <billdozr> shachaf: I'm doing => foo <- LBS.hGetContents h; print (LBS.length foo); B.decode foo; hClose h; ...;
04:25:14 <billdozr> note the decode bit
04:25:24 <spark_> shachaf: whoops, im glad I asked around, made me notice a bug on my type, map4 is f x, f y... in place of map f x
04:25:31 <billdozr> B for Data.Binary
04:26:07 <spark_> Still, the pattern matching doesnt seem to cope
04:31:55 <timthelion> > split (whenElt (\n->n==1)) [1,2,3,1] -- Do we have a split that would return [[1,2,3],[1]] for this list?
04:31:56 <lambdabot>   Not in scope: `whenElt'
04:35:48 <rfw> @pf f x = T (\w -> (w, x))
04:35:48 <lambdabot> Maybe you meant: bf pl
04:35:51 <rfw> @pl f x = T (\w -> (w, x))
04:35:51 <lambdabot> f = T . flip (,)
04:36:10 <rfw> @pl f x = T (\w -> (# w, x #))
04:36:10 <lambdabot> (line 1, column 5):
04:36:10 <lambdabot> unexpected "="
04:36:10 <lambdabot> expecting variable, "(", operator or end of input
04:36:12 <rfw> :(
04:36:55 * hackagebot reactive-banana 0.7.0.1 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.7.0.1 (HeinrichApfelmus)
04:37:41 <shachaf> > groupBy (\x y -> y /= 1) [1,2,3,1]
04:37:42 <lambdabot>   [[1,2,3],[1]]
04:37:46 * shachaf >=> sleep
04:39:16 <timthelion> shachaf: thanks :)
04:43:34 <billdozr> shachaf: a `hFlush h' on the initiator side, after sending the payload, resolves the problem requiring no need to close the handle.
05:12:50 <osa1> I can't divide an integer because it's not a RealFrac, how can I fix this code?
05:13:39 <osa1> http://hpaste.org/73775
05:14:46 <rtharper> fromIntegral
05:14:53 <rtharper> :t fromIntegral
05:14:54 <lambdabot> forall a b. (Integral a, Num b) => a -> b
05:15:44 <rtharper> so a idx = test !! floor ((fromIntegral idx) / 3)
05:15:52 <rtharper> but
05:15:54 <rtharper> it looks like what you want
05:15:57 <rtharper> is integer division
05:15:59 <rtharper> compare
05:16:18 <rtharper> :t (/)
05:16:19 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:16:25 <rtharper> :t div
05:16:26 <lambdabot> forall a. (Integral a) => a -> a -> a
05:16:33 <rtharper> > 5 / 3
05:16:34 <lambdabot>   1.6666666666666667
05:16:39 <rtharper> > div 5 3
05:16:40 <lambdabot>   1
05:16:55 <rtharper> osa1 ^^
05:22:23 <warpy> how do i index into a Data.Sequence with an Integer index?
05:22:46 <warpy> the signature of Seq.index only allows Int
05:22:55 <rtharper> warpy: fromIntegral
05:23:24 <warpy> but my indexes are larger than Int
05:23:28 <warpy> it overflows
05:23:36 <rtharper> O.o
05:23:43 <DexterLB> is there a way to load an external module by filename?
05:24:03 <rtharper> my, what a lot of elements you have there
05:24:05 <typoclass> DexterLB: ":l" in ghci?
05:24:14 <sheldonh> as an exercise, i'm hand-rolling the functions in Data.List. some are imported by the Prelude. how can i prevent them from being imported, so that when i play with my functions in ghci, i don't get "Ambiguous occurrence `head'"?
05:24:17 <DexterLB> typoclass: something like that, but for ghc
05:24:27 <warpy> rtharper: yes i do. now i am stuck
05:24:49 <rtharper> warpy: you coudl slipt the sequence up?
05:24:58 <rtharper> or use drop?
05:25:20 <rtharper> but those are sequential, I think
05:25:32 <rtharper> oh no
05:25:35 <rtharper> drop is logarithmic
05:25:48 <rtharper> you could drop until the sequence gets small enough
05:25:48 <warpy> rtharper: nevermind. i figured it out
05:25:53 <rtharper> how did you do it, then?
05:26:04 <warpy> but why doesnt Seq allow more than max Int indexes?
05:26:17 <typoclass> DexterLB: the module names translate pretty directly to filenames, e.g. Control.Monad.Instances ./Control/Monad/Instances.hs
05:26:20 <rtharper> you'd want a separate function
05:26:23 <rtharper> you could ask for it =)
05:26:45 <warpy> Data.List has genericIndex. Data.Seq should have one too
05:26:49 <DexterLB> typoclass: the problem is I want to import a .hs with a lowercase name :D
05:27:00 <warpy> there doesnt seem to a reason to limit index to Int
05:27:20 <warpy> looks like some legacy carryover
05:29:17 <sheldonh> i see i can do import Prelude hiding (head). can i do something like import Prelude only (error)?
05:30:00 <opqdonut> import Prelude (error)
05:30:02 <danr> yes, import Prelude (error)
05:30:11 <typoclass> sheldonh: yes (uh, sorry, i forgot to address your earlier question). the syntax is "import Prelude (error, head, stuff)"
05:30:18 <opqdonut> works for other modules too, of course
05:30:23 <sheldonh> ah, lovely!
05:30:43 <sheldonh> thanks. finally finished up to chapter 4 of realworldhaskell, so now it's time to get some practice in :)
05:31:40 <danr> sheldonh: fun :)
05:32:13 <whaletechno> how come [1..] has type (Enum t, Num t) => [t] and not [Integer] instead?
05:32:29 <sheldonh> danr: exactly. i ate my dinner, now i want cake :)
05:33:24 <typoclass> whaletechno: it's polymorphic. your t could be an Integer, or an Int, or yet other things
05:34:29 <typoclass> > take (head [1]) "abc" -- whaletechno
05:34:30 <lambdabot>   "a"
05:34:32 <typoclass> @type take
05:34:33 <lambdabot> forall a. Int -> [a] -> [a]
05:35:33 <typoclass> the 'take' function can take only an Int, so this code would not work if [1] had type [Integer] as you suggested
05:36:25 <whaletechno> typoclass: oh, I see
05:37:29 <whaletechno> that's very convenient. thanks for clearing that up
05:37:55 <typoclass> whaletechno: you're welcome
05:55:49 <sheldonh> weeeee! optimization for my hand-rolled length function: length (_:_:_:_:_:_:_:_:_:_:xs) = 10 + length xs   :)
05:56:10 <opqdonut> did you measure that?
05:56:28 <opqdonut> by "that" I mean the performance improvement
05:56:37 <sheldonh> opqdonut: only with me eyes. let's take a look :)
05:56:51 <dmwit> Yeah, I find it very unlikely that this will actually help much.
05:56:54 <sheldonh> opqdonut: is there a convenient way to bench expressions in ghci?
05:57:04 <dmwit> The majority of the time is likely dereferencing cons cells, which you still have to do here.
05:57:08 <dmwit> :set +s
05:57:11 <opqdonut> right
05:57:46 <schovi> sheldonh: compile it and then run like ./time my_program
05:57:55 <sheldonh> ghci is awesome
05:58:02 <sheldonh> schovi: yeah, that's what i'm hoping to avoid :)
05:58:06 <dmwit> Also, yes, benchmarking in ghci is ill-advised.
05:58:31 <opqdonut> you definitely want to profile the compiled version
05:58:34 <dmwit> Timings for interpreted code are so very unrelated to timings for compiled code that it's sort of pointless.
05:58:34 <sheldonh> oh?
05:58:46 <sheldonh> okay thanks for the heads up
05:59:02 <timthelion> dmwit: GHCI doesn't interpret the code, it compiles it without optimization.  But yes, you are correct.
05:59:12 <dmwit> uh, no?
05:59:42 <dmwit> e.g. the famous segfaults with GeneralizedNewtypeDeriving are segfaults on -O0 but not in ghci.
06:00:00 <merijn> If you really want to seriously benchmark you want to look at http://bos.github.com/criterion/ :p
06:00:02 <dmwit> So it's possible to empirically show that "compiled without optimization" and "interpreted" are actually different. ^_^
06:00:26 <Mon_Ouie> Depends on what people mean by "interpreting" (just walking the AST vs running bytecode vs running native code)
06:00:30 <timthelion> dmwit: but GHCI still isn't an intepreter.
06:00:40 <dmwit> Why do you say ghci is not an interpreter?
06:00:49 <dmwit> Hell, it's even in the name -- the GHC (i)nterpreter.
06:00:59 <timthelion> dmwit: i stands for "interactive"
06:01:05 <sheldonh> hmmm. i come up short on IO. what's the simplest thing i can do to turn main = length [1..1000000] into something that will compile? :)
06:01:26 <dmwit> print (length [1..10000000])
06:01:56 * hackagebot BlogLiterately-diagrams 0.1.0.0 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.0.0 (BrentYorgey)
06:02:08 <dmwit> timthelion: Okay. So, what makes you say ghci is not an interpreter?
06:02:39 <timthelion> dmwit: well, it actually creates binarry to be run, rather than interfacting itself between the code and the CPU.
06:02:59 <merijn> timthelion: What's your point?
06:03:08 <merijn> How do you define interpretation?
06:03:18 <dmwit> Also, where are you getting that from?
06:03:28 <timthelion> dmwit: looking at the source...
06:03:45 <dmwit> "By default, GHCi compiles Haskell source code into byte-code that is interpreted by the runtime system."
06:03:52 <sheldonh> yay! my first stack space overflow :)
06:04:05 <dmwit> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/ghci-obj.html
06:05:20 <belgin> byorgey: thanks for your explanation, i think i finally got it: in the Frank instance of Tofu, tofu has the same type as the data constructor of Frank, so it makes sense to write "instance Tofu Frank where tofu = Frank"
06:06:42 <t7> timthelion: is a subtle troll
06:06:44 <timthelion> dmwit: I guess I understood it incorrectly then.  Sorry.
06:06:48 <t7> my favourite kind of troll
06:06:57 * hackagebot BlogLiterately-diagrams 0.1.0.1 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.0.1 (BrentYorgey)
06:07:04 <dmwit> cheers
06:07:32 <merijn> t7: My favourite kind of troll is the kind that has a weakness to fire :>
06:07:39 <timthelion> I did actually read the source code to GHCI, and I said "hey look it's compiling" and never got so far as "compiling to bytecode which is then interpreted"
06:08:28 <typoclass> t7: i wish people would stop making "troll" accusations just because someone misunderstood something
06:09:02 <merijn> typoclass: By now hitting someone in the face is considered "trolling" if you believe reddit, the word is losing all meaning...
06:09:29 <sheldonh> how can i increase the stack size of my exploding test program? i tried ghc +RTS -K16M -RTS bench-pessimal.hs, but get the same overflow at 8388608 bytes
06:09:42 <t7> typoclass: nah i can back this one up the megabytes of irc logs
06:09:59 <dmwit> It's curious that people are okay with language being fluid enough to admit a modern meaning for troll (namely, someone intending to inflame a community) but not okay with language being fluid enough to expand the meaning of troll.
06:10:34 <dmwit> sheldonh: You need to run *the program* with a bigger stack, not run *the compiler* with a bigger stack.
06:10:40 <dmwit> ./bench-pessimal +RTS -K16M
06:10:45 <timthelion> t7: You really think I've typed megabytes of missunderstanding on here?
06:10:48 <dmwit> sheldonh: Don't forget to compile with -rtsopts
06:11:29 <spark_> hmmm, if Im having IO happening at bursts, it means that I have a IO bottleneck?
06:11:41 <sheldonh> dmwit: thanks :)
06:11:52 <dmwit> That's not usually what people mean when they say they have an IO bottleneck, no.
06:12:03 <dmwit> ...or maybe it is
06:12:15 <dmwit> Naming it properly doesn't seem that important, though.
06:12:19 <sheldonh> sjoe. for a start, my length function is 8 times faster when compiled :)
06:12:36 <merijn> dmwit: Actually, it doesn't mean to inflame a community, the meaning comes from fly fishing where you drag bait across the water in the hopes of attracting bites, seems a rather obvious usage of the word, as opposed to hitting someone in the face >.>
06:13:11 <dmwit> merijn: Yes; the modern usage is dragging inflammatory comments across a forum in the hopes of attracting replies. I don't think I mischaracterized it badly by ommitting the etymology.
06:13:26 <donri> hitting someone in the face is the equivalent of throwing a grenade in the sea to catch fish
06:13:38 <dmwit> dang
06:13:41 <dmwit> omitting, I mean
06:13:54 <sheldonh> who doubted my awesome optimisation to length? :)
06:14:01 <sheldonh> it makes it 10 times faster! :)
06:14:02 <merijn> dmwit: I don't think said fluidity is in the same order of magnitude
06:14:20 <timthelion> sheldonh: that's pretty sad I must say...
06:14:20 <merijn> sheldonh: Even for small use cases?
06:14:38 <sheldonh> merijn: no :)
06:14:55 <dmwit> sheldonh: 10 times faster than Prelude.length?
06:15:02 <sheldonh> dmwit: nooooooooooooo
06:15:35 <sheldonh> dmwit: my length with this extra equation is 10 times faster than without: length (_:_:_:_:_:_:_:_:_:_:xs) = 10 + length xs
06:15:42 <typoclass> merijn: i'm not worried about the word losing its meaning. i meant that people throw around the "troll" accusation quite a lot nowadays. it's an ad-hominem attack that drags discussion to a personal level, and off of the level of discussing statements. it feels to me that people might accuse you for harmless misunderstandings, having some difficulty with english, phrasing things unclearly, misspeaking, or really just making a typo
06:16:19 <nobdraisentone> sheldonh: so length [1,2] is what?
06:16:36 <typoclass> t7: do you really believe tim out of malicious intent says something about ghci, then is corrected by others, then says "I guess I understood it incorrectly then.  Sorry." ?
06:17:02 <sheldonh> nobdraisentone: i have standard equations also, for [] and (_:xs)
06:17:40 <sheldonh> nobdraisentone: but for fun, i thought i'd throw in the 10 placeholder equation, and someone here said they wouldn't expect it to make a difference, and so of course it suddenly became extremely important to me :)
06:18:00 <sheldonh> nobdraisentone: i think what they meant was "you won't optimize Prelude's length like that"
06:18:19 <dmwit> That is what I meant, yes.
06:18:32 <dmwit> Though I'm equally surprised that it optimizes the naive implementation of length.
06:18:44 <dmwit> (This is reproducibly true on my machine.)
06:20:14 <sheldonh> dmwit: what i'm surprised about is that it reduces the stack usage. with the "optimization", i don't need +RTS -K32M
06:20:31 <dmwit> That part doesn't surprise me.
06:20:45 <dmwit> The stack comes from deeply-nested thunks like (1+(1+(1+(1+(...))))))
06:20:53 <timthelion> t7: My statement was both correct and incorrect. A) it does compile. B) It has an option to not interpret at all. C) When you run ghci Foo.hs it always compiles and never interprets Foo.hs(according to the output messages at least)...
06:21:08 <sheldonh> dmwit: hmmm... is there a way to hint to haskell that i don't want an expression thunked?
06:21:11 <dmwit> So the thunks will be much more shallowly nested if they're (10+(10+(10+(...))))
06:21:21 <dmwit> Yes, make things a bit more strict.
06:21:27 <dmwit> e.g.
06:21:29 <dmwit> :t ($!)
06:21:30 <lambdabot> forall a b. (a -> b) -> a -> b
06:22:39 <sheldonh> dmwit: aha! great. i was really worried that there seemed to be no way to implement length efficiently :)
06:23:07 <sheldonh> nyomnyomnyom http://www.haskell.org/haskellwiki/Performance/Strictness
06:23:13 <mm_freak> sheldonh: your version is probably faster because it does 10 + 1 + 0 instead of 1 + 1 + 1 + … + 1 + 0
06:23:38 <dmwit> Yes, but ten additions should be so negligible compared to ten dereferences... no?
06:23:43 <dmwit> That's why I'm surprised it matters.
06:23:45 <mm_freak> doubt it
06:23:50 <sheldonh> mm_freak: yes. that was the plan. and then i saw the memory impact and realized i still don't have a clue what's going on :)
06:24:06 <timthelion> dmwit: Is there an optimization level at which GHC automatically makes it strict?  It *should* be smart enough to do so.
06:24:07 <mm_freak> i wouldn't expect a 10x speedup, but only a small factor like 2 or 3
06:24:40 <mm_freak> sheldonh: i'd expect both the heap and stack usage to be very large with your version
06:24:42 <sheldonh> could the speedup be coming from reduced pressure on the operating system's memory allocator?
06:24:45 <mm_freak> let me check something
06:24:49 <typoclass> dmwit: when you say the optimized length makes things a bit more strict, does that matter? i thought the regular length forces all of the list anyway (could be wrong, i don't really have a clue)
06:25:31 <opqdonut> but unoptimized it leaves the additions unevaluated
06:25:41 <opqdonut> building a large thunk
06:25:53 <spark_> how do i go from lazy bytestring to strict? I was expecting to just delete the lazy keyword from the import, but then parsec complains
06:26:10 <dmwit> typoclass: Who care's about the list? It's the answer that's blowing the stack. =)
06:26:20 <dmwit> The list is on the heap.
06:26:26 <sheldonh> ahhhhhhhhhh
06:26:28 <sheldonh> that makes sense
06:26:33 <typoclass> oh i see
06:28:00 <Hadaka> newbie question - inside a do block I have: if ((fromIntegral offset) /= curSize) then EX.throw foo else return ()
06:28:16 <sheldonh> so i want (1 `seq`) + length xs or something
06:28:17 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#length for what it's worth
06:28:36 <Hadaka> I hate if, but this doesn't work: when ((fromIntegral offset) /= curSize) (EX.throw foo)
06:28:39 <opqdonut> sheldonh: that doesn't type
06:28:43 <dmwit> sheldonh: I'm not 100% sure what you want, but at a guess, it's "length xs" you'd want to be "seq"ing.
06:28:58 <Hadaka> (the monad is ResourceT IO)
06:29:02 <merijn> Hadaka: How does it not work?
06:29:15 <merijn> :t when
06:29:15 <Hadaka> Couldn't match expected type `ResourceT IO a0'
06:29:16 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:29:25 <dmwit> Hadaka: If the first works, the second should, too.
06:29:27 <Hadaka> with actual type `()'
06:29:42 <merijn> Oh, the type of EX.throw might not be restricted enough?
06:29:42 <dmwit> If the second doesn't work, then I am suspicious of your claim that the first does.
06:29:51 <merijn> oh, no
06:29:54 <merijn> That can't be it
06:30:23 <Hadaka> sorry! path parenthesis, added some and the problem went away
06:30:28 <Hadaka> s/path/bad/
06:30:44 <mm_freak> sheldonh: a generic 8-foldl is slower than a 1-foldl
06:30:51 <merijn> Hadaka: btw, the parenthesis around "fromIntegral offset" are redundant
06:31:14 <Hadaka> yeah, I was trying to add stuff justin case
06:31:15 <merijn> Hadaka: The simple rule is that function application *always* binds tighter than infix operators
06:31:50 <typoclass> ("space binds tighter than almost everything")
06:32:03 <sheldonh> dmwit: ah, i didn't think of that. passing an accumulator through as an additional argument :)
06:33:27 <dmwit> sheldonh: I think the real magic there is in not wrapping/unwrapping the Int constructor all the time, but yeah.
06:33:40 <dmwit> GHC has crazy levels of optimization in the base libraries.
06:33:45 <sheldonh> dmwit: what does the hash symbol mean, following an argument?
06:33:53 <dmwit> You should read it as part of the name.
06:33:54 <typoclass> sheldonh: i think it's "unboxed"
06:34:02 <dmwit> Int has a constructor whose name is "I#".
06:34:23 <mm_freak> in fact i can't reproduce the 10-fold length to be faster on my system
06:34:27 <dmwit> And len's second argument is a value named "a#" of type "Int#".
06:34:32 <dmwit> mm_freak: Funny, I can on mine.
06:34:32 <mm_freak> i have GHC 7.4.2 on a 64 bits i5
06:34:44 <dmwit> Although I recently downgraded to GHC 7.0, so maybe that's why.
06:34:57 <sheldonh> ah, so like native primitives
06:35:02 <dmwit> sheldonh: Yes, exactly.
06:35:34 <sheldonh> dmwit: and i'm guessing i should try to avoid these in my own code unless i start doing rocket science
06:35:45 <dmwit> # is both a letter and a symbol for these purposes. =P
06:35:51 <dmwit> sheldonh: I dunno. Use them if you need them.
06:35:55 <sheldonh> :)
06:36:55 <hpaste> “Ertugrul Söylemez” pasted “8-fold length faster?” at http://hpaste.org/73778
06:37:04 <mm_freak> sheldonh, dmwit: that's the code i used
06:37:16 <mm_freak> and i'm compiling with -O2
06:37:37 <mun> hi
06:37:42 <mun> i have a somewhat logically related question
06:37:43 <mun> if i combine a theory T with another theory T', will the number of theorems in the resulting merge be greater than the sum of those in T and T'?
06:37:45 <dmwit> mm_freak: length8'' calls length8'...
06:38:14 <mun> well, equal or greater than, that is.
06:38:50 <mm_freak> uh
06:39:20 <dmwit> mm_freak: Also, note that sheldonh is claiming a speedup compared to naive length, not Prelude.length.
06:39:22 <mm_freak> dmwit: no, it doesn't…  it's actually just a typo in the paste =)
06:39:29 <mm_freak> oh
06:39:38 <mm_freak> well, that's totally reasonable
06:39:43 <dmwit> (This was my first objection, too.)
06:40:13 <mm_freak> 1 + 1 + 1 + 1 + 1 + 0 needs more allocations, GC and arithmetic than 5 + 0
06:41:39 <sheldonh> mm_freak: sorry for the confusion. i communicated on the assumption that everyone in this channel is following every step of my personal journey to the exclusion of other concerns :)
06:42:20 <mm_freak> no worries, i'm just analyzing =)
06:42:55 <mm_freak> the speedup doesn't really come from pattern matching or arithmetic…  it mainly comes from heap operations
06:43:47 <dmwit> Yeah, the lesson here for me is that the 8-fold version actually *is* eight dereferences fewer per 8 cons cells, because it's not creating and destroying an I# for each.
06:43:56 <dmwit> (or sever fewer or something)
06:43:57 <typoclass> fwiw, on my system the length8 from hpaste takes about 5 sec on a test case, while Prelude.length takes 4 sec. -O2 makes them slightly slower (0.4s and 0.2s)
06:44:14 <sheldonh> mm_freak: i don't know enough to understand the difference. in my head, if pattern matching saves you a bunch of recursions, you've saved stack or heap or frikken' *something* :)
06:45:29 <typoclass> sheldonh: you did report that a naive length caused a stack overflow and needed a runtime switch to increase stack space, while your 10-cell length didn't. that's a lesson as well
06:45:30 <typoclass> :)
06:46:14 <sheldonh> typoclass: naive is just a place to start? :)
06:46:26 <dmwit> I tried strictifying the naive length, and it still stack overflow'd on me.
06:46:29 <dmwit> So that surprised me.
06:46:49 <dmwit> strictLength (_:xs) = (1+) $! strictLength xs; strictLength [] = 0 -- is what I tried
06:47:12 <sheldonh> dmwit: i went the other way, still using boxed Int, but with an accumulator. i still get a stacko, but if i increase stack space, it's almost 8 times faster than naive
06:48:44 <timthelion> if I just want to block untill something.  Is there something "more efficient" then having a data Null = Null, a touchTMVar :: TMVar Null, and a _<-takeTMVar touchTMVar ?
06:48:50 * typoclass will begin using Ints to hardcode the lengths of lists everywhere, because this whole discussion gives him the willies
06:49:14 <dmwit> timthelion: That's the normal way with MVars.
06:49:24 <Cale> Remember, it's not a call stack, it's a stack of pattern matches waiting for their scrutinee to be sufficiently evaluated to match. $!/seq/etc. are like forced pattern matches in this regard.
06:49:26 <dmwit> There may be something better with STM depending on a lot more context.
06:49:34 <dmwit> timthelion: (By the way, you can use () instead of Null.)
06:49:43 <timthelion> dmwit: I realized that after pressing enter...
06:50:18 <sheldonh> typoclass: length as first element? ;)
06:50:24 <dmwit> Cale: Can you explain why strictLength (and even the version of strictLength that uses deepseq instead of seq) stack overflows on long lists?
06:50:43 <Cale> @src ($!)
06:50:44 <lambdabot> f $! x = x `seq` f x
06:50:55 <dmwit> doh
06:50:58 <mm_freak> sheldonh: you shouldn't think of recursion as an /operation/ in haskell, because it's really not
06:50:59 <timthelion> dmwit: I'm waiting on a buch of TChans symultaneously in order to do a draw(GUI stuff).  And I just want to be able to have a "force-redraw" function.  I don't see this as actually being a preformance problem, it just seems ugly to be passing a value I don't care about.
06:51:04 <dmwit> Cale: Good explanation. =)
06:51:16 <mm_freak> sheldonh: as pointed out, haskell programs don't have a call stack =)
06:51:36 <dmwit> Cale: Hm, just changed the (_:xs) clause to let r = strictLength xs in r `seq` r+1 and still stack overflow.
06:51:45 <mm_freak> a recursion in haskell can correspond to the closing curly brace in a while-loop in C
06:51:48 <sheldonh> basically, it's not going to make sense until i read that STG paper :)
06:51:57 <mm_freak> or it can correspond to something that you won't find in C at all =)
06:52:34 <Cale> dmwit: You want the additions to happen as soon as possible, so you must left-associate the expression so that forcing the additions to occur can have any effect at all on the number of things waiting to be evaluated.
06:52:52 <mm_freak> and that's not even an optimization…  it's the way haskell programs are compiled (STG)
06:53:54 <typoclass> Cale: you mean he should write 1+r instead of r+1 ?
06:54:11 <dmwit> Surely not...
06:54:13 <Cale> that would be too easy :)
06:54:15 <hiptobecubic> hopefully not
06:54:30 <Cale> dmwit: So you can imagine in this case that seq is putting r+1 on the stack, while r is evaluated here
06:54:37 <dmwit> Yeah, I see it.
06:54:41 <dmwit> It took a bit of mind-bending.
06:54:48 <dmwit> Still working out what the fix is, though. =P
06:54:56 <Cale> Tail recursion will work
06:55:00 <Cale> (with seq)
06:55:13 <Cale> Or foldl' will work :)
06:55:15 <dmwit> Okay, foldl' worked.
06:55:49 <dmwit> I suppose the "tail recursion" solution means adding an accumulator?
06:55:52 <Cale> yeah
06:55:55 <dmwit> right
06:56:23 <dmwit> thanks =)
06:56:25 <Reko> I'm looking at image loading libraries. One gives me Vector Word8, another [[Pixel]], another StorableArray (Int,Int) Word8, another Ptr. I was wondering as to their relative merits.
06:57:03 <dmwit> What will you do with the image after you loaded it?
06:57:08 <Reko> Send it to OpenGL.
06:57:23 <thirsteh> trying to avoid having my mind exploded by the M. C. Escher theme, I ask: Given data Foo = { foos = [Foo] } can I put foo 1 in foo 2's foos, AND foo 2 in foo 1's foos, without making foos e.g. a TVar?
06:57:24 <dmwit> What format does OpenGL expect?
06:57:38 <typoclass> ... so that's the reason why GHC.List.length has an accumulator
06:58:01 <dmwit> thirsteh: foo1 = Foo [foo2]; foo2 = Foo [foo1]
06:58:02 <Reko> ...Hm. Ptr, looks like. Heh.
06:59:02 <thirsteh> dmwit: sorry, what I meant was Foo = Foo { foos :: [Foo] }
06:59:18 <dmwit> thirsteh: I know what you meant. My answer is the same. =)
06:59:27 <thirsteh> dmwit: what kind of sorcery is that
06:59:39 <dmwit> Laziness, baby!
06:59:47 <zhulikas> how can you use something before it was defined
06:59:47 <dmwit> and, like, recursion and stuff
06:59:49 <zhulikas> O.o
07:00:03 <dmwit> zhulikas: Definitions are not ordered. Either a thing is defined or it isn't.
07:00:11 <zhulikas> nice!
07:00:36 <thirsteh> amazing stuff
07:00:45 * zhulikas from now on will be a bit more powerful Haskell wizard
07:00:50 <nand`> > let cat = "meow " ++ dog; dog = "woof " ++ cat in dog
07:00:53 <lambdabot>   "woof meow woof meow woof meow woof meow woof meow woof meow woof meow woof...
07:01:08 <zhulikas> O.O
07:01:18 * thirsteh 's head explodes
07:01:30 <zhulikas> infinite recursion
07:01:39 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in (take 10 evens, take 10 odds)
07:01:40 <lambdabot>   ([0,2,4,6,8,10,12,14,16,18],[1,3,5,7,9,11,13,15,17,19])
07:01:47 <nand`> Cale: love it
07:02:10 <zhulikas> how the hell this one works O.O
07:02:17 <zhulikas> that's definitely black magic
07:02:22 <Cale> haha :)
07:02:27 <thirsteh> the gods don't approve of this
07:02:49 <Clint> they must be crazy
07:02:59 <Cale> Wait for it...
07:03:21 <dmwit> evens = 0 : map (+1) odds = 0 : map (+1) (map (+1) evens) = 0 : map (+1) (map (+1) (0 : map (+1) odds)) = 0 : map (+1) (1 : map (+1) (map (+1) odds)) = 0 : 2 : map (+1) (map (+1) (map (+1) odds)) = ...
07:03:29 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
07:03:30 <hiptobecubic> The evens odds trick was my first exposure to tying the knot :)
07:03:30 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:03:50 <thirsteh> Cale: very cool
07:04:09 <nand`> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
07:04:10 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:04:27 <nand`> or more succintly
07:04:35 <nand`> > let fibs = scanl (+) 0 fibs in fibs
07:04:36 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
07:04:37 <zhulikas> I hate you all!
07:04:38 <nand`> oh
07:04:43 <nand`> > let fibs = scanl (+) 0 (1:fibs) in fibs
07:04:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:04:58 <parcs`> > fix (ap tail) [1, 2, (!!0) + (!!1), length, head]
07:04:59 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
07:05:05 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
07:05:06 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:05:25 <parcs`> > fix (ap tail) [1, 2, (+) <$> (!!0) <*> (!!1), length, head]
07:05:26 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
07:05:27 <dmwit> zhulikas: Don't worry, the next time this topic comes up, you'll have these standard examples to throw at them, too, and then *you* will look like a wizard. =)
07:07:38 <parcs`> oh right..
07:07:45 <parcs`> > fix (ap flip) [1, 2, (!!0) + (!!1), length, head]
07:07:47 <lambdabot>   [1,2,3,5,1]
07:08:22 <Cale> dat Loeb
07:08:47 <nand`> parcs`: cute
07:08:55 <parcs`> dat Num (a -> b) instance
07:11:16 <parcs`> :t fmap fix return
07:11:18 <lambdabot> forall a. a -> a
07:12:45 <latro`a> fix . const
07:13:01 <latro`a> so that's...id?
07:13:04 <latro`a> cute
07:14:34 <kmels> can you combine bird style ('>' in the beginning of a line) with \begin{code} .. \end{code} in literate haskell?
07:15:05 <merijn> kmels: I don't think so
07:15:15 <kmels> ok :(
07:22:11 <belgin> is ghc supposed to link automatically? i'm doing ghc --make program.hs and it's not outputting any executables, only a .hi file and a .o file
07:22:32 <spark_> just do ghc program.hs
07:22:32 <sheldonh> damn. not everything is a nail. doesn't look like you can implement init with an accumulator (unless you think append is a hot idea)   :)
07:22:55 <spark_> it works like this for me
07:23:34 <belgin> spark_: no luck
07:23:49 <Cale> Oh, btw, on the length thing earlier, if you're willing to be required to compile with optimisations, you can also do this:
07:23:54 <byorgey> belgin: does program.hs  have  'module Foo where...' where Foo is something other than Main?
07:23:56 <Cale> length xs = length' xs 0
07:23:57 <spark_> belgin: really? does it says compiling at least?
07:23:59 <Cale> length' [] = id
07:24:07 <Cale> length' (x:xs) = length' xs . (+1)
07:24:18 <belgin> it does have something other than Main
07:24:26 <Cale> dmwit: ^^ :)
07:24:31 <byorgey> belgin: if so, you must specify -main-is Foo  if you want it to create an executable
07:24:55 <byorgey> by default only modules named Main are turned into executables
07:25:01 <belgin> thanks again byorgey
07:25:06 <Cale> That will eat space like a pig if compiled without optimisations though :P
07:25:19 <sheldonh> Cale: naive length is already eating space like a pig :")
07:25:27 <sheldonh> well, like a spacepig
07:25:49 <dmwit> Cale: in the strictness analyzer we trust
07:26:00 <Cale> Right :)
07:27:07 <spark_> so if naive lenght sucks, what should we use?
07:27:14 <dmwit> Prelude.length
07:27:16 <Cale> spark_: the one in the Prelude
07:27:27 <Cale> spark_: or if you're going to write it yourself, use foldl'
07:27:41 <latro`a> in other words foldr-length
07:27:43 <latro`a> is naive length
07:27:44 <latro`a> yes?
07:27:54 <Cale> yeah, or just the bare recursive definition
07:27:57 <Cale> length [] = 0
07:28:02 <Cale> length (x:xs) = 1 + length xs
07:28:10 <dmwit> That is the naive length.
07:28:12 <latro`a> they're the same :p
07:28:18 <spark_> well, if im using length then im probably using prelude, so im fine?
07:28:28 <dmwit> It has performance problems because of constantly boxing and unboxing and also stack overflows.
07:28:30 <Cale> spark_: right
07:28:37 <merijn> byorgey: Don't you mean "modules with main", I have plenty of stuff that isn't called Main but still builds an executable
07:28:55 <Cale> spark_: However, you *should* try to avoid using length in general
07:29:35 <spark_> Cale: I can totally see that, just changed a stupid function that called lenght n-1 times
07:29:36 <byorgey> merijn: I don't believe you
07:30:39 <sheldonh> please don't tell me how, but... can (++) be implemented in haskell?
07:30:54 <companion_cube> concatenation of lists? yep
07:31:11 <sheldonh> damn. it's gonna be a had-scratchy night :)
07:31:11 <byorgey> merijn: the key is the name of the module, not the name of the file
07:31:18 <edwardk> companion_cube: =P
07:31:26 <typoclass> merijn: if it doesn't have a "module X where" line at all, it builds executables just find
07:31:36 <flux> sheldonh, you know how to append a single element to a list?
07:31:42 <dmwit> sheldonh: Yes. Hint: data [a] = [] | a : [a] -- roughly
07:31:43 <byorgey> typoclass: right, because in that case the name of the module defaults to Main
07:31:43 <merijn> byorgey: Ah, I think I may be lacking "module X where" in those files
07:31:43 <flux> (hmm, well prepend actually)
07:31:58 <byorgey> merijn: right.
07:33:22 <sheldonh> it's amazing how imperative thinking just totally brick walls functional thinking
07:33:31 <tdammers> oh yeah.
07:33:45 <merijn> sheldonh: One example implementation: "(x:[]) ++ ys = x:ys" and "(x:xs) ++ ys = x : (xs ++ ys)"
07:33:49 <osa1> is there a way to use nested guard patterns? I'm getting some errors on this code: http://hpaste.org/73781
07:34:46 <dmwit> merijn: "please don't tell me how, but..."
07:34:47 <dmwit> =P
07:34:58 <merijn> sheldonh: hmm, only just saw you didn't want to see how, I guess that one needs a spoiler alert xD
07:35:02 <spark_> spoilers all around
07:35:25 <dmwit> osa1: uh
07:35:34 <spark_> damn, my code looks awfully bad
07:35:38 <dmwit> osa1: You're putting a guard but not on the definition of r...
07:35:58 <dmwit> osa1: Guards go on definitions (only).
07:36:10 <dmwit> Maybe I should ask: what did you want that code to do?
07:37:43 <merijn> Is having a shared file for common imports in a package heresy?
07:38:01 <hpaste> dmwit annotated “sytax error” with “perhaps this?” at http://hpaste.org/73781#a73782
07:38:35 <osa1> dmwit: thanks
07:38:47 <danr> merijn: in one project, I have an utilities file that also exports some of the common parts of Control.Applicative and Control.Arrow. I find it nicer to just do import Utils, than to import those two libraries everywhere
07:39:28 <dmwit> merijn: not at all
07:39:30 <danr> I guess you'll have to ask yourself who is going to read the code and how you need to inform them where all these extra stuff is imported from
07:42:43 <merijn> It'll mostly be the "extended prelude" (i.e. Control.Applicative, Control.Arrow, Control.Monad, etc.)
07:43:04 <jtza8> If I'd like to record a time difference in milliseconds, is there something simpler than using System.time.getClockTime ?
07:43:28 <Clint> what do you mean by "simpler"?
07:43:46 <typoclass> jtza8: perhaps System.Time.Clock.POSIX
07:44:32 <jtza8> perhaps, thanks typoclass.
07:44:35 <dmwit> Clippy mode activated!
07:44:43 <dmwit> It sounds like you're trying to benchmark. Would you like help with that?
07:44:45 <dmwit> ?hackage criterion
07:44:46 <lambdabot> http://hackage.haskell.org/package/criterion
07:45:26 <jtza8> dmwit: Actually, I'm trying to record the framerate in an OpenGL app.
07:45:51 <dmwit> okey-dokey!
07:45:56 <frerich> jtza8: As you can tell, dmwit's Clippy mode is very realistic (read: seemingly plausible but rarely useful) ;-)
07:46:19 <hiptobecubic> that wasn't accurate at all
07:46:29 <hiptobecubic> You should have offered help with cflags
07:46:45 <hiptobecubic> and banged on the inside of the screen
07:46:58 <typoclass> i thought criterion was a reasonable thing to point out ...
07:47:07 <jtza8> :)
07:47:55 <danr> @hoogle getCPUtime
07:47:55 <lambdabot> System.CPUTime getCPUTime :: IO Integer
07:47:59 <danr> ^ jtza8
07:48:20 <Clint> that's not what he wants
07:48:23 <danr> no?
07:48:28 <Clint> not if he's measuring framerate
07:49:50 <spark_> oo well, if i have 2 unused fields on a tuple, haskell stills loses time calculating them
07:49:53 <spark_> sad
07:50:19 <tdammers> spark_: why?
07:51:01 <sheldonh> merijn: haha. fortunately, i was called away from my desk, so no harm done :)
07:51:10 <tdammers> > fst (3, last [1..])
07:51:11 <lambdabot>   3
07:51:23 <spark_> tdammers: well
07:51:39 <spark_> tdammers: then I have a damn of a time leak here
07:51:59 * hackagebot logic-TPTP 0.3.0.2 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.3.0.2 (DanielSchuessler)
07:52:11 <spark_> is show instance that slow?
07:52:20 <Spockz_> Suppose I want to add unique identifiers to each Pandoc Block, how could I do this best? I'd rather not fork pandoc for this
07:52:32 * jtza8 decides System.Time will work just fine.
07:52:57 <Lemmih> spark_: Using 'show' is usually very slow.
07:53:23 <Lemmih> jtza8: How about Data.Time?
07:53:34 <spark_> Lemmih:  so this      show (FourD (a,b,c,d)) = "( "++show a++" , "++show b++" , "++show c++" , "++show d++" )" is 4 times slower?
07:53:35 <tdammers> Spockz_: I actually thought about forking pandoc for this exact reason (or rather, for adding class names to arbitrary elements, but that's basically almost the same problem)
07:53:48 <Lemmih> spark_: Four times slower than what?
07:53:56 <tdammers> problem is, pandoc's data model can't currently do this
07:54:01 <spark_> than just a show a
07:54:19 <spark_> well, darn
07:54:20 <spark_> ofc
07:54:27 <lightquake> you're trying to show four things, so...
07:54:42 <spark_> I shouldnt stay awake all night doing haskell
07:54:45 <spark_> haha
07:55:02 <Spockz_> tdammers: if he would include a type parameter of kind * to * each could make their own modifications
07:55:47 <Spockz_> each -> anyone
07:56:11 <spark_> here i go search a pure library that does fft on the gpu
07:59:35 <Spockz_> fft?
07:59:54 <Palmik> Hmm, cabal sdits reports "suplicate modules in library", but they are not dusplicate, since the setup looks like this: "if flag(something) exposed-modules: ... else exposed-modules: ... other modules: ...", any way around it?
08:02:12 <dmwit> Your interface shouldn't change depending on a compilation flag...
08:03:24 <Palmik> It's better (in my opinion) that to expose ALL of my functions (inluding those from internal modules and those that are only relevant inside the given module) just for testing.
08:03:38 <spark_> Spockz_:  fast fourier transform
08:04:07 <Palmik> Without better support for testing, this seems like the lesser evil of the two options.
08:04:29 <Palmik> Maybe there is a third option I do not know about though you would like to share? :)
08:04:49 <jtza8> Lemmih: That would work even better, thanks. :)
08:06:04 <Palmik> Or I can change the cabal file every time before I upload it to hackage... sweet.
08:06:59 * hackagebot abstract-deque 0.1.6 - Abstract, parameterized interface to mutable Deques.  http://hackage.haskell.org/package/abstract-deque-0.1.6 (RyanNewton)
08:07:47 <dmwit> Palmik: I think it's pretty normal to have some modules named "Internal" that it's understood shouldn't be used except in dire circumstances (like testing).
08:08:23 <dmwit> I'm surprised there's a warning, though.
08:08:36 <dmwit> That seems like the kind of thing cabal should be able to notice won't have an overlap.
08:08:37 <Palmik> I do not think that is ideal solution either.
08:10:02 <sheldonh> some jerk wandered into my office and helped me with my (++)   :)
08:10:37 <sheldonh> can it be done without reverse? afaik, there isn't actually a way to append a single item to a list, so i did this: http://fpaste.org/ty7g/
08:11:17 <byorgey> sheldonh: you do not need reverse to implement (++)
08:11:18 <merijn> sheldonh: Mine works without reverse
08:11:20 <dmwit> It can be done without reverse.
08:11:25 <rtharper> ...so yes
08:11:46 <merijn> sheldonh: To repeat my previous solution: "(x:[]) ++ ys = x:ys" and "(x:xs) ++ ys = x : (xs ++ ys)"
08:11:52 <dmwit> Your base case is lousy.
08:11:56 <byorgey> sheldonh: hint: recurse on (++)'s first parameter instead of the second.
08:11:59 * hackagebot template-hsml 0.2.0.1 - Haskell's Simple Markup Language  http://hackage.haskell.org/package/template-hsml-0.2.0.1 (PetrPilar)
08:12:24 <dmwit> [] ++ ys = ys -- much cleaner, and let's (++) be total besides
08:12:45 <rtharper> sheldonh: there's no way getting around traversing the entire list, but you can do so that you only traverse the list once
08:13:04 <rtharper> whichi si what (x:xs) ++ ys = x : (xs ++ ys) does
08:13:09 <merijn> dmwit: Yeah, bit sloppy, I changed how I wanted to write it midway
08:13:42 <rtharper> have attempted to help 3 people out on #haskell today, must be procrastinating
08:24:03 <spark__> when my import doesnt let me compile with -prof, what should i do?
08:24:24 <tibbe> spark_: you will have to install a profiling version of the libraries you depend on
08:25:06 <tibbe> spark_: something like: cabal install -p <pkg1> <pkg2>
08:25:14 <tibbe> spark__: it's a bit annoying
08:26:03 <spark__> tibbe:  i'll try that, thanks!
08:26:11 <tibbe> spark__: you're welcome
08:26:58 <tibbe> spark__: the annoying issue is that cabal doesn't track which packages have a profiling version installed so you might have to install more packages
08:27:07 <kaos> Hi, does anyone here use SourceGraph? I've installed it but trying to make it analyse my projects fails to parse (SourceGraph: fd:5: hClose: resource vanished (Broken pipe))
08:27:14 <tibbe> spark__: but at least it will tell you that it failed to install a package due to missing profiling versions of its deps
08:33:45 <geekosaur> kaos, at a guess... is graphviz installed?  "Broken pipe" makes me think it's trying to run an external program that isn't actually there.
08:34:12 <geekosaur> I see a dependency on graphviz-the-library, but even if the program is installed along with it you might need to make sure it's on your $PATH
08:37:17 <Hadaka> hmmh - I was using Warp and HTTP.Conduit happily, getting around 100 MB/s transfer speed - then I enabled TLS in both and the transfer speed dropped to 2-3MB/s
08:37:20 <Hadaka> is this normal?
08:37:32 <NougatRillettes> @pl let f >< g = \ x y -> (f x) + (g y)
08:37:33 <lambdabot> (line 1, column 7):
08:37:33 <lambdabot> unexpected ">"
08:37:33 <lambdabot> expecting pattern or "="
08:37:46 <NougatRillettes> @pl let f || g = \ x y -> (f x) + (g y)
08:37:46 <lambdabot> (line 1, column 7):
08:37:46 <lambdabot> unexpected "|"
08:37:47 <lambdabot> expecting pattern or "="
08:37:50 <Clint> Hadaka: how slow is your cpu?
08:37:51 <NougatRillettes> hm
08:38:01 <Hadaka> Intel(R) Core(TM) i7 CPU       M 620  @ 2.67GHz
08:38:07 <Clint> how slow is your peer's cpu?
08:38:11 <Hadaka> same machine
08:38:19 <Clint> ah
08:38:24 <Clint> maybe you have an entropy shortage
08:38:41 <NougatRillettes> @pl \f g = \x y -> (f x) + (g y)
08:38:41 <lambdabot> (line 1, column 6):
08:38:41 <lambdabot> unexpected "="
08:38:41 <lambdabot> expecting pattern or "->"
08:38:50 <NougatRillettes> @pl \f g -> (\x y -> (f x) + (g y) )
08:38:50 <lambdabot> flip . (((.) . (+)) .)
08:38:56 <NougatRillettes> finally
08:40:07 <merijn> Hadaka: Does it improve of you move your mouse/smash keys on your keyboard? (Only semi-joking...)
08:40:47 <Clint> you're not going to generate enough entropy for 100MB/s by mouse movement
08:40:59 <merijn> :p
08:41:10 <Hadaka> merijn: no entropy shortage
08:41:49 <navaati> hiya
08:41:58 <atriq> Hello
08:42:06 <Hadaka> besides, entropy is only required in connection setup, not while a connection is transferring a large file
08:43:52 <Clint> really?
08:46:53 <geekosaur> Clint, typically you use the entropy to seed a conventional PRNG; there rarely is enough to be used directly as a random source
08:47:28 <Clint> ah, makes sense
08:48:54 <hpaste> timthelion pasted “Tiny library” at http://hpaste.org/73783
08:49:16 <timthelion> Is there a better way to publish this function, than to make a package on hackage?
08:49:27 <Hadaka> symmetric encryption in SSL does not need entropy, regardless of any PRNG stuff
08:49:40 <t7> weird indentation style
08:49:42 <timthelion> Is there hope I could get that funcion integrated directly into the STM library?
08:49:50 <timthelion> t7: sorry?
08:50:06 <t7> each function arg on a new line
08:50:15 <timthelion> it is a really usefull funcion :)
08:50:29 <timthelion> t7: I like to keep things short.
08:50:49 <t7> equals on its own line :|
08:50:52 <t7> lol
08:51:31 <timthelion> t7: it's vertical formatting rather than horizontal, you gotta problem with that?
08:51:35 <NougatRillettes> excuse me, what is the correct version of this : type Foo a b = (Num b) => a -> b ?
08:51:51 <NougatRillettes> (aka putting a constraint on a synonym type definition)
08:52:03 <timthelion> I just wonder if it would be worth my time trying to get that into the actual library rathern than making a 20 line package.
08:52:08 <t7> timthelion: never seen it before
08:52:25 <rosie> What's the function for "map" with the arguments flipped? We have mapM and forM, but no for?
08:52:49 <merijn> rosie: flip map :p
08:52:50 <timthelion> t7: the context is withTChan a f >>= withTChan b >>= withTChan c >>= forkIO
08:52:51 <Hadaka> but, has anyone used SSL/TLS support in haskell? is it supposed to be that slow? the CPU can churn out AES around 50 megabytes per second, and several hundred if using AES-NI
08:53:04 <rosie> merijn: Thanks!
08:53:10 <merijn> :t flip map
08:53:11 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
08:53:23 <fmap> NougatRillettes: did you try `type Foo a b = (Num b) => a -> b'?
08:53:36 <byorgey> NougatRillettes: do you get an error message?
08:54:12 <NougatRillettes> yes :  Illegal polymorphic or qualified type: Num b => a -> b
08:54:16 <NougatRillettes>  Perhaps you intended to use -XRankNTypes or -XRank2Types
08:54:19 <NougatRillettes>     In the type synonym declaration for `Blbl'
08:54:27 <timthelion> t7: don't you see it's everydayness now?
08:54:47 <byorgey> NougatRillettes: ah, right.  Well, you just have to turn on the Rank2Types extension
08:55:08 <byorgey> NougatRillettes: put {-# LANGUAGE Rank2Types #-} at the top of your file
08:55:19 <Cale> hmm...
08:55:30 <NougatRillettes> Hm, kay, but i don't reallu get the error message actually
08:55:32 <Cale> I wonder if this really means what NougatRillettes wants it to mean now
08:55:35 <spark__>  bhmap (xs,ys,zs,ts) ((FourD (x,y,z,t)):fds) = bhmap (xs++(x:[]),ys++(y:[]),zs++(z:[]),ts++(t:[])) fds
08:55:43 <spark__> Never do that
08:55:48 <spark__> 98% of time spent here
08:55:49 <Cale> oh, I guess it has to
08:56:08 <Cale> NougatRillettes: It's not allowed in Haskell 98/2010 to put a class context there
08:56:37 <NougatRillettes> oh, why ?
08:57:16 <Cale> Well, it obscures the fact that type variables are constrained, I guess.
08:57:23 <Cale> If you define  bar :: Foo a b
08:58:02 <Cale> it's unclear to the user of bar that b is a constrained type variable, without looking at the definition of Foo now
08:58:13 <Cale> (But maybe that's okay)
08:58:16 <NougatRillettes> Hm, in fact I just want to instance (Num b) => a -> b as member of a typeclass
08:58:38 <NougatRillettes> but Cale is there any way to put it in a way that it can be seen in the type of foo ?
08:58:55 <Cale> type synonyms won't help, because you're not allowed to write instances of typeclasses for them normally anyway
08:59:44 <NougatRillettes> oh, right, i had forgot about it
09:05:42 <Spockz_web> is anyone of you familiar with an online collaboration tool for working on papers and/or books? I know that Real World Haskell has a web page where you can comment on sections on the book.
09:13:18 <geekosaur> mmm, people use wordpress and wikis for that, also sometimes things like collabedit.com although that's more for code
09:14:21 <Hadaka> hmmh, atleast the cryptocipher package has AES.X86NI
09:14:39 <Hadaka> so, if that's used it should be up to that atleast
09:15:03 <thirsteh> Spockz_web: maybe pbwiki/pbworks
09:15:21 <thirsteh> Spockz_web: their tagline is "online collaboration" -- we use it, it's pretty good
09:18:41 <Spockz_web> geekosaur: well, but with WP/Wiki you don't see your paper/book on the side and you can't edit it. And the online edition of RWH enables you to add comments to each paragraph
09:18:50 <Spockz_web> thirsteh: I just created an account there, let's take a look
09:19:34 <thirsteh> I don't know of anything that gives you RWH paragraph-style comments though
09:19:59 <thirsteh> sounds very easy to make though
09:20:10 <Spockz_web> What I practically want is something you feed with your git/darcs/hg repository and it compiles your paper/thing for you
09:20:38 <navaati> iirc RWH uses an homemade app, happstack based, right ?
09:21:03 <Spockz_web> so you have your average latex / MD document and you parse it, and you get an online editor and a HTML view and a PDF view for free
09:21:03 <yitz> navaati: python. it was originally used by bos for his book about mercurial.
09:21:15 <Spockz_web> yitz: can I take a look at it?
09:21:33 <Spockz_web> yitz: I'm curious as to how you add the comments, or rather how you identify each paragraph
09:21:47 <yitz> Spockz_web: i believe the source is available, yes. not sure where, but if so, shouldn't be too hard to find.
09:23:57 <Spockz_web> yitz: does it have a name?
09:24:46 <Spockz_web> ah The Django Book?
09:25:11 <Spockz_web> http://www.realworldhaskell.org/blog/2007/07/10/want-to-help-out-got-html-css-javascript-fu/
09:30:05 <strg> Spockz_web: Maybe something like piratepad.net ?
09:31:56 <Spockz_web> strg: that works for colloboration when you want to work on one bit of text together, but you can't build your latex/markdown thing on there
09:32:19 <yitz> Spockz_web: https://github.com/bos/rwh
09:33:09 <yitz> full web site, including book, code examples, scaffolding, and python
09:33:13 <Hadaka> okay, found out a part of the problem - the debian cryptocipher package does not have the X86 parts...
09:36:14 <Spockz_web> yitz: I'll take a look at that :)
09:36:51 <Spockz_web> allright, I'm off, thanks everyone! :)
09:37:01 * hackagebot SVGFonts 1.1.2 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.1.2 (BrentYorgey)
09:41:39 <yitz> Spockz_: the book it was originally used for is here: http://hgbook.red-bean.com/
09:45:47 <hpaste> timthelion pasted “Lenses?” at http://hpaste.org/73784
09:45:59 <timthelion> So I've found a place where I think I might need lenses.
09:46:16 <edwardk> not sure how they'd help there
09:46:37 <timthelion> edwardk: do you get what that code does already without me explaining it?
09:46:50 <edwardk> i get the gist of it
09:47:05 <timthelion> I want to update only one foo at a time, leaving the others with their old values.  What if I had 20 foos though.
09:47:09 <timthelion> that would be really ugly :/
09:47:16 <edwardk> yeah
09:47:30 <edwardk> well, you can set up the lenses into whatever is holding all the foos
09:47:49 <edwardk> and have a list of channel, lens pairs
09:48:10 <edwardk> (though thats a little tricky because storing lenses in lists requires reifying them ,etc.
09:48:24 <timthelion> any other ideas?
09:48:32 <edwardk> not sure yet
09:48:48 <edwardk> well, what i described will work, its just not the prettiest code =)
09:49:31 <timthelion> edwardk: prettier than what I have now?
09:49:47 <edwardk> when you get up towards 5-10 of them, definitely
09:57:10 <spark__> how do i increase the memory of my executable? Iits running out opening a 100mb file
09:58:13 <spark__> damn, im going over 2gb o.O
09:58:24 <srhb> spark__: Sounds like you need a different strategy.
09:58:47 <spark__> srhb:  I agree
09:59:51 <spark__> still, I don't get it. It's a 100mb file and im just doing ffts across it
10:04:07 <spark__> aaaaaaaaaaaah fuck
10:04:17 <spark__> reversing a list forces it to be strict, i supose
10:04:47 <c_wraith> well.  How do you know what the first element of the reversed list is?
10:05:02 <spark__> what do you mean bythat?
10:05:29 <hpaste> spark_ pasted “mem leak” at http://hpaste.org/73785
10:05:37 <c_wraith> I mean, what work has to be performed to find out what the first element of "reverse xs" is?
10:05:56 <timtheli1n> c_wraith: technically one could still find the "last,now first" element without loading the entire list into memory :)
10:06:04 <navaati> spark__, to access the last element of the list, you must go trough all the previous elements
10:06:13 <c_wraith> timtheli1n: not with haskell linked lists
10:06:30 <timtheli1n> c_wraith: well if you where discarding the elements as you whent...
10:06:36 <spark__> So I guess I should change list to vectors?
10:06:47 <c_wraith> you wouldn't be reversing the list, then.  you'd just be calculating the last element
10:06:52 <c_wraith> vectors also are all in memory
10:07:04 <c_wraith> it'd be better to not build the list backwards, if you want to traverse it lazily
10:07:10 <spark__> still
10:07:11 <spark__> well, they shouldn't use the same quantity
10:07:40 <timtheli1n> c_wraith: aw shucks, you're rigth...  it would be a rather waste to "calculate the last elemet dicarding intermetdiates" "calculate the next to last discarding intermedieates" ect :D
10:07:49 <spark__> its a 100mb file, where i collect it by 32, so it should be 32*100mb
10:09:03 <spark__> but it should be much less...
10:09:21 <spark__> I'll get rid of the reversing using !!
10:09:31 <c_wraith> that's probably also wrong.
10:09:37 <c_wraith> !! is pretty bad for performance
10:10:07 <Clint> is there a doubly-linked list type?
10:10:33 <c_wraith> not in the standard libraries.  (a doubly linked immutable list is... hard to work with)
10:10:56 <c_wraith> It'd be pretty much inferior to Array in every way.
10:10:57 <ReinH> dmap, bmap, bhmap, oh my!
10:11:15 <navaati> spark__, your list contains data from a file, right ?
10:11:28 <spark__> y
10:11:45 <navaati> do you need random access in this list ?
10:11:51 <spark__> not really
10:12:01 <spark__> i need to acess in bulks of 32
10:12:22 <navaati> it seems like you need something like ByteString
10:12:50 <spark__> im working with numbers atm
10:13:10 <spark__> my type is Comple^3 String, and I dont work with that string
10:13:10 <ReinH> using read as your parser isn't helping your performance any
10:13:48 <spark__> readInt?
10:14:15 <spark__> anyway, the problem isn't speed atm, the memory leak is much worse since I can't run it at all
10:14:55 <ReinH> (amap (map (floor .quare .(drop 1) . map (/32) . fft ). splitN 32) ((map  head) . splitN 32))
10:15:00 <ReinH> do you know what complexity this has?
10:15:45 <ReinH> I sort of suspect it's blowing up your heap with thunks
10:15:51 <spark__> the fft is n log n, split n increases by n, quare is n
10:16:14 <spark__> so I should be at n ^2 log n
10:16:20 <ReinH> have you profiled the heap?
10:16:40 <spark__> running with -prof?
10:16:43 <spark__> +RTS?
10:17:14 <ReinH> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/prof-heap.html
10:17:29 <spark__> ty
10:17:37 <spark__> ill give it a look and ill report back soon D:
10:17:55 <ReinH> you might have to recompile GHC if it wasn't compiled for profiling
10:17:55 <ReinH> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/prof-compiler-options.html
10:18:16 <ReinH> sorry, wrong link
10:18:35 <navaati> why do you need to access the end of the file first ?
10:25:51 <spark__> navaati:  I don't, it's a trick to make [(a^3,b)]into ([a]^3,b)
10:26:24 <spark__> ReinH:  on my 2mb file it says the parser is taking most of the memory o.O
10:26:53 <spark__> ReinH:  ill make 10mb file
10:28:05 <spark__> wait, does +hc work even if the program runs out of memory?
10:28:19 <hughfdjackson> I want to check I haven't got my terminology off entirely here
10:28:19 <lambdabot> hughfdjackson: You have 1 new message. '/msg lambdabot @messages' to read it.
10:28:42 <hughfdjackson> if you have a typeclass, are all instances isomorphic with respect to that typeclass?
10:29:11 <hughfdjackson> :| it's entirely possible I've misunderstood isomorphism
10:29:17 <spark__> aand a 25mb file goes up to 1gb , clearly im doing somethign wrong
10:29:54 <ReinH> spark__: what shape is the memory growth?
10:30:01 <ReinH> polynomial? exponential?
10:30:12 <spark__> im still runing the 25mb file
10:30:34 <ReinH> run a 2mb, 10mb and 25mb and tell us the results
10:30:40 <spark__> ok
10:30:55 <ReinH> and is that memory going into thunk storage or?
10:31:04 <spark__> still, 1gb for 25mb is insane
10:31:08 <ReinH> it is
10:31:11 <monochrom> no, instances are not isomorphic to each other
10:31:13 <spark__> 2mb has like 80mb
10:31:16 <ReinH> but I'd like to know exactly how insane
10:31:31 <spark__> will do D:
10:31:32 <monochrom> even with respect to the type class
10:31:36 <Ornedan> What is a GHC "worker task"? The things created in rts/Task.c startWorkerTask? What do they do? What determines how many of them may exist at one time?
10:31:58 <ReinH> that actually looks like linear grown though
10:32:01 <ReinH> *growth
10:32:07 <ReinH> so you just have some really terrible constant factor
10:32:33 <hughfdjackson> monochrom: i had started to suspect i was dead wrong on this :D further reading required
10:32:34 <ReinH> I still don't think you want to be using read for parsing
10:32:35 <spark__> well, it kinda looks linear on the graph
10:32:40 <spark__> one sec
10:32:45 <spark__> does imgur accept ps?
10:33:06 <dmwit> Ornedan: You might like the sections "Why Threading is Hard" through "Foreign Imports" (and maybe "The Non-Threaded Runtime") of http://dmwit.com/gtk2hs/
10:33:07 <Heffalump> is CABAL_OS_WINDOWS a flag that's set by recent versions of Cabal/cabal-install but not by earlier ones?
10:33:07 <ReinH> you also want to make sure you're using strictness appropriately to avoid creating unnecessary thunks
10:33:29 <dcoutts_> Heffalump: not aware of it
10:33:43 <ReinH> spark__: are you processing the file lazily or do you process the entire file?
10:34:29 <thirsteh> Do I really need to enable GHC extensions to make an Exception? (--XDeriveDataTypeable)
10:34:40 <Heffalump> ok, looks like it's just a convention then
10:34:44 <ReinH> btw you probably want to use bytestring
10:34:45 <thirsteh> data MyErrors = SomeError deriving (Show, Typeable)
10:34:52 <bitonic> thirsteh: you do
10:35:11 <hughfdjackson> monochrom: out of interest, is there a term that *does* denote that types share an interpretation of an operation that i might come across?
10:36:00 <thirsteh> ok
10:36:05 <dmwit> hughfdjackson: What does "share an interpretation" mean?
10:36:41 <hughfdjackson> dmwit: :| that was quite the wrong thing to say
10:36:55 <hughfdjackson> i mean "share in common that there exists an interpretation of an operation over them"
10:37:04 <hughfdjackson> i suppose that's quite loose and ad-hoc :/
10:37:11 <nus> Ornedan, see the GHC wiki for the gory details
10:37:22 <dmwit> What is an interpretation of an operation?
10:37:35 <spark__> ReinH: http://imgur.com/a/IyvsO
10:37:37 <monochrom> there are infinite many terms for this, one for each type class or mathematical definition or ...
10:37:45 <dmwit> (I'm not trying to be an asshole... I swear I'm trying to be helpful.)
10:37:56 <spark__> ReinH:  i was strict, but changed to lazy, didnt matter
10:38:05 <monochrom> for example, in group theory, they say "integers and real numbers are both groups"
10:38:29 <hughfdjackson> dmwit: :p questioning my badly constructed questions twice doesn't make you look like an asshole
10:38:33 <monochrom> in field theory, they say "rational numbers and real numbers are both fields"
10:38:56 <monochrom> in haskell, they say "Int and Double are both instances of Num", "Int and Double are both instances of Show", etc
10:39:10 <monochrom> one term for every type class
10:39:19 <hughfdjackson> monochrom: makes sense :) cheers
10:40:43 <joe9>  /ws 26
10:40:44 <hughfdjackson> dmwit: i think, in a round-about way, i'm talking about 'the name for the group of types that are logical candidates for being instances of typeclass X'
10:40:45 <ReinH> spark__: http://book.realworldhaskell.org/read/profiling-and-optimization.html
10:40:59 <hughfdjackson> which is .. subjective, so :| yea
10:41:03 <hughfdjackson> not a good Q
10:41:08 <hughfdjackson> :) i'll pop off and give it more thought
10:41:11 <hughfdjackson> cheers for the replies all
10:41:22 <ReinH> spark__: time to start optimizing parseAcc
10:42:14 <dmwit> hughfdjackson: Well, there's a good type for types that *are* instances. (That term is instances. ;-) And a separate question you can ask is whether the types implied by an instance header are inhabited.
10:42:29 <dmwit> (ignoring nontermination and exceptions and such)
10:42:55 <spark__> ReinH: yeah, i can see that @.@, but hmmmm, what can i change there?
10:43:04 <spark__> the read for the ints to what?
10:44:34 <hughfdjackson> dmwit: i think i'm coming unstuck on 'inhabited'
10:44:53 <hughfdjackson> oh, wait, found references to it :)
10:44:54 * hughfdjackson reads
10:45:15 <dmwit> A type is "inhabited" just when you can create a value of that type.
10:45:32 <dmwit> For example, "a -> a" is inhabited, but "() -> a" is not inhabited.
10:46:13 <dmwit> (Actually, in Haskell, all types are inhabited, for example, by "undefined". But we can wave our hands a little.)
10:46:29 <hughfdjackson> hehe, okay
10:48:21 <dmwit> Here's a small example of a familiar typeclass and type for which things are not inhabited:
10:48:42 <dmwit> data Backwards b a = Backwards (a -> b)
10:49:01 <dmwit> Now, we can ask: if we were to write instance Functor (Backwards b), would fmap be inhabited?
10:49:02 <latro`a> (again via handwaving we have to ignore undefined and also unsafeCoerce)
10:49:26 <dmwit> We'd have to write a function fmap :: (i -> o) -> Backwards (b -> i) -> Backwards (b -> o)
10:49:37 <dmwit> ignoring the wrapping and unwrapping, this means we have to write a function of type
10:49:46 <dmwit> whoops, I mean
10:49:53 <dmwit> fmap :: (i -> o) -> Backwards b i -> Backwards b o
10:50:08 <latro`a> so (i->o)->(i->b)->(o->b)
10:50:10 <dmwit> So, ignoring wrapping, we're looking for foo :: (i -> o) -> (i -> b) -> (o -> b)
10:50:21 <latro`a> (sorry, too many cooks, I'll be quiet)
10:50:30 <dmwit> I hope you agree that this is hard to write; a bit of thought might convince you that, more than just being hard, it's actually impossible.
10:50:33 <hughfdjackson> latro`a: :p don't want to burn the brain
10:51:14 <latro`a> it would be possible on a subcategory where all arrows are invertible
10:51:26 <latro`a> (then it wouldn't be a functor, but still)
10:51:28 <dmwit> So there's some kind of hierarchy, like "is a valid type-level expression" -> "has the right kind to be an instance of this class" -> "the methods of this class are inhabited" -> "some inhabitants of the methods satisfy some laws" -> "is actually an instance of this class"
10:52:02 <byorgey> latro`a is not very good at being quiet ;)
10:52:02 * hackagebot yesod-core 1.1.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.1.1 (FelipeLessa)
10:52:14 <latro`a> that wasn't explaining anything byorgey :p
10:52:20 <latro`a> that was just making a silly semi-related comment
10:52:27 <thirsteh> is there a find for assocation list (predicate against key)?
10:52:32 <thirsteh> association lists*
10:52:38 <latro`a> lookup
10:52:46 <latro`a> not sure if there is a lookupBy
10:52:51 <latro`a> :t lookupBy
10:52:52 <lambdabot> Not in scope: `lookupBy'
10:53:06 <byorgey> thirsteh: yes, and it is called... find
10:53:12 <byorgey> @type find
10:53:13 <thirsteh> I want to do something like find (s `isPrefixOf`) associationlist
10:53:13 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:53:22 <latro`a> he's basically talking about a composition
10:53:24 <latro`a> I think
10:53:32 <dmwit> find ((s `isPrefixOf`) . fst)
10:53:35 <thirsteh> find . fst?
10:53:36 <latro`a> \f -> find (f . fst)
10:53:37 <thirsteh> ah, great
10:53:41 <thirsteh> thanks
10:53:51 <hughfdjackson> dmwit: am processing ;)
10:53:52 <dmwit> find's type =(
10:54:00 <dmwit> filter's type =)
10:54:22 <latro`a> reminds me about that deleteBy bug-ish-thing
10:54:37 <latro`a> (deleteBy's signature is not maximal)
10:54:44 <dmwit> hughfdjackson: Yep, I figured. Ask any questions that come to mind as you process.
10:54:47 <byorgey> heh, I guess find p = listToMaybe . filter p, eh
11:02:27 <aj__> why is "Try Haskell in browser" hardcoded
11:03:09 <thirsteh> case find ((s `isPrefixOf`) . fst) commands of Nothing -> Nothing; Just pair -> Just $ snd pair    ?
11:03:39 <dmwit> snd <$> find (...) commands
11:03:56 <dmwit> snd `fmap` find (...) commands -- if you prefer
11:04:06 <thirsteh> nice.
11:04:26 <dmwit> [val | (key, val) <- commands, s `isPrefixOf` key] -- would be my preferred spelling
11:04:46 <thirsteh> ah, list comprehension does it nicely, yeah
11:09:12 <thirsteh> I suppose the list comprehension evaluates the whole list though?
11:09:30 <dmwit> Not unless you ask it to.
11:09:34 <thirsteh> otherwise listToMaybe $ [val | (key, val) <- commands, s `isPrefixOf` key] is perfect
11:09:48 <dmwit> I still view listToMaybe as a code smell.
11:09:53 <thirsteh> won't that comprehension look for all values where s is a prefix of key?
11:09:58 <dmwit> Others disagree with me, though, so take that with a grain of salt.
11:10:04 <dmwit> thirsteh: Only if you ask it to. =)
11:10:08 <dmwit> Remember: laziness.
11:10:11 <thirsteh> I don't understand what that means
11:10:17 <thirsteh> oh
11:10:59 <thirsteh> you just gave me a small epiphany. Thanks
11:13:27 <scshunt> :t listToMaybe
11:13:28 <lambdabot> forall a. [a] -> Maybe a
11:13:31 <scshunt> eww
11:13:46 <thirsteh> [] -> Nothing; [a] -> Just a
11:13:56 <thirsteh> or something like that
11:14:02 <dmwit> (a:_) -> Just a
11:14:05 <thirsteh> yeah
11:14:05 <SLi> dmwit: Funny, I've had the same thought (but I'm fairly newbie in Haskell). It feels like a kludgey way to get rid of too much safety.
11:14:30 <SLi> Except it doesn't lose safety unless you use it wrong (which is tempting).
11:14:33 <thirsteh> I prefer empty lists whenever there actually might be more than one value
11:14:56 <thirsteh> IMO Maybe a makes it clear that there'll only be one
11:22:03 * hackagebot template-hsml 0.2.0.2 - Haskell's Simple Markup Language  http://hackage.haskell.org/package/template-hsml-0.2.0.2 (PetrPilar)
11:23:44 <teneen> In the module Data.Vector the documentation of the function modify states that the (immutable) vector will be modifed in place if it is  safe to do so. When is it safe to do so?
11:23:52 <teneen> http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector.html#v:modify
11:26:14 <mm_freak> teneen: probably never
11:26:53 <mm_freak> well, i could imagine that it might be fused into a composition
11:27:03 <mm_freak> but in general it's never safe
11:28:10 <teneen> mm_freak: what do you mean by fused into a composition?
11:28:58 <mm_freak> teneen: the 'vector' library performs stream fusion
11:29:14 <mm_freak> such that intermediary (or even all) vectors are eliminated
11:29:21 <teneen> mm_freak: so if the vector does not have any variable referencing it, or is defined on the fly (replicate, iterate etc.) it will be performed in-place?
11:29:42 <mm_freak> if 'modify' is part of such a composition, it can be safe and the library may recognize that through RULEs
11:30:05 <mm_freak> i'm not saying it will, i'm saying that's something i could imagine
11:30:16 <eevar> anyone here using redis? wonder which library I should be looking at. There's hedis (which looks most current), redis and redis-hsm, and perhaps more..
11:30:29 <mm_freak> teneen: cata . modify f . ana
11:30:39 <joe9> any help on what I am missing here: code : http://codepad.org/MD2VK2aR error http://codepad.org/Q825sVqr
11:30:39 <mm_freak> 'modify' can probably do its work in-place there
11:31:28 <teneen> mm_freak: I see. This makes sense
11:31:50 <mm_freak> joe9: backUp :: Gcode a => a
11:32:20 <joe9> mm_freak, what is wrong with it?
11:32:27 <mm_freak> joe9: the type promises that it can be any type you choose for it, as long as it's an instance of Gcode, while you fixate the type to Move
11:33:03 <mm_freak> joe9: keep in mind that the user chooses the type, not the value itself
11:33:22 <hpaste> spark_ pasted “attoparsec, which function to parse int” at http://hpaste.org/73788
11:33:52 <joe9> mm_freak, I plan to extend to add more instances to Gcode. but, for now, I only have one type as an instance to Gcode.
11:34:09 <joe9> mm_freak, I want to add onto this function as I keep working on it.
11:34:24 <joe9> mm_freak: Move is an instance of Gcode typeclass.
11:34:42 <spark__> If someone could indicate me which function to use to parse an int in autoparsec, thanks!
11:34:57 <mm_freak> joe9: it's just a simple type mismatch…  your backUp value is obviously of type Move
11:35:14 <Botje> joe9: you could add a default :: a method to GCode.
11:36:01 <joe9> mm_freak: but, type Move is an instance of Gcode typeclass.
11:36:17 <mm_freak> joe9: to understand the error, consider zero = []
11:36:22 <mm_freak> joe9: what's the type of zero?
11:37:03 * hackagebot xmonad-screenshot 0.1.0.0 - Workspaces screenshooting utility for XMonad.  http://hackage.haskell.org/package/xmonad-screenshot-0.1.0.0 (DmitryMalikov)
11:37:09 <joe9> list, correct? mm_freak.
11:37:18 <mm_freak> joe9: be more precise
11:37:22 <mm_freak> give me a haskell type
11:37:50 <joe9> mm_freak: http://codepad.org/wufYcmaN
11:37:59 <eevar> spark__: number ?
11:38:11 <hughfdjackson> dmwit: this is embarressing :p
11:38:20 <dmwit> hughfdjackson: ?
11:38:26 <hughfdjackson> data Backward a b = Backward (b -> a)
11:38:34 <mm_freak> joe9: if you really had to ask GHCi to determine the type, you should probably read some more LYAH, before you go on =)
11:38:37 <hughfdjackson> i'm scratching my head over what the latter part of that means?
11:39:01 <hughfdjackson> a constructor that takes arguments of two types and..? or does it take a function with arguments of two types
11:39:31 <spark__> eevar: that gives me a type Integer?
11:39:41 * hughfdjackson has perused lyah to little effect
11:39:52 <joe9> Botje: do you have any examples on how to add the default function?
11:39:53 <byorgey> spark__: by the way, this is unrelated to your question, but the use of reverse in implementing amap is unnecessary
11:40:01 <hughfdjackson> :D if you're got a search term handy, that'd be great
11:40:17 <dmwit> hughfdjackson: It defines a new data type.
11:40:24 <byorgey> spark__: I would implement amap as  amap f g = map FourD . uncurry4 zip4 . map4 f g . unzip4 . map getFourD
11:40:25 <dmwit> hughfdjackson: Values of this data type are functions.
11:40:32 <byorgey> where uncurry4 f (a,b,c,d) = f a b c d
11:40:42 <dmwit> hughfdjackson: In particular, if you have foo :: b -> a, then Backward foo :: Backward a b
11:40:50 <byorgey> but unzip4 and zip4 are functions from Data.List
11:40:55 <spark__> byorgey: woa that's nice! thanks
11:41:03 <joe9> mm_freak: I just want to add the default Move type there and when I keep working on the program, I expect to have more instances of Gcode here.
11:41:09 <dmwit> hughfdjackson: (Likewise, if you have a value of type Backward a b, then you can extract a function of type b -> a from it via pattern matching.)
11:41:24 <dmwit> hughfdjackson: Gotta run now, but ask questions in here and others will surely help you.
11:41:34 <spark__> byorgey: I was thinking the other day if there was some magic to implement it, couldn't figure it out
11:41:41 <hughfdjackson> :) cheers for all the help so far
11:41:49 <mm_freak> joe9: not sure i get that…  try to explain what you want without haskell terms
11:42:53 <joe9> i want to return a type which will belong to the typeclass Gcode. But, for now, I only have one such type ie. Move.
11:42:59 <joe9> mm_freak: ^^
11:43:13 <statusfailed> Why can't I declare a function of type "foo :: MonadState Bar m => m ()" ?
11:43:17 <joe9> as I keep adding more code, I plan to add more types to that typeclass.
11:43:19 <mm_freak> joe9: without haskell terms, please…  explain your application
11:44:04 <byorgey> statusfailed: It's impossible to tell.
11:44:19 <byorgey> statusfailed: perhaps you could provide more information, i.e. an error message or a link to some code
11:44:22 <statusfailed> byorgey: because I haven't given you the implementation?
11:44:22 <statusfailed> ok
11:44:27 <statusfailed> sure I will do a paste
11:45:16 <Cale> statusfailed: The snarky answer would be that that's not a function type ;)
11:45:21 <hpaste> wm pasted “sleep sort” at http://hpaste.org/73789
11:45:44 <byorgey> Cale: hehe
11:47:31 <watermind> I was playing around with Concurrency in ghc, and am getting a  "thread blocked indefinitely in an MVar operation"
11:47:38 <hpaste> statusfailed pasted “online variance calculation” at http://hpaste.org/73790
11:47:55 <statusfailed> byorgey: there it is
11:48:03 <statusfailed> Cale: quite right :P
11:48:17 <watermind> the code is rather simple, I'm just trying to implement a sleep sort and communicating via a MVar
11:48:21 <Cale> watermind: yes, that happens when you block on an MVar operation (taking an empty MVar or writing a full one) and you no longer have a reference to that MVar from any other thread.
11:48:35 <statusfailed> haha, sleepsort :D
11:49:16 <Cale> (also with Chan because it is apparently implemented in terms of MVar)
11:49:23 <watermind> Cale: I understand... but I don't see why it's happening
11:49:23 <byorgey> statusfailed: the error message tells you how to fix it: "Use -XFlexibleContexts to permit this"
11:49:26 <spark__> byorgey: it did reduce the memory spend on amap! thanks, but still 90% is on the parser
11:49:29 <Cale> watermind: hpaste?
11:49:32 <statusfailed> byorgey: but I don't understand what that means or why I'm seeing it
11:49:39 <watermind> http://hpaste.org/73789
11:50:00 <statusfailed> I generally feel it's bad to try and fix errors by just adding language extensions :P
11:50:01 <Cale> statusfailed: The error message tells you which extension you need
11:50:22 <byorgey> statusfailed: the Haskell standard is quite conservative in what sorts of instances and constraints are accepted.
11:50:22 <Cale> statusfailed: you can either use that flag or put {-# LANGUAGE FlexibleContexts #-} at the top of your file
11:51:13 <watermind> so all of the threads put a value in that one MVar
11:51:38 <watermind> and the main thread tries to read n values from it
11:51:46 <byorgey> statusfailed: in this particular case, it doesn't like constraints where not all of the arguments are type variables
11:51:51 <byorgey> i.e. Knuth
11:51:54 <Cale> watermind: you didn't forkIO the threads
11:52:09 <spark__> anyone has a very good tutorial for attoparsec? google isn'tgetting me far
11:52:15 <Cale> watermind: So there's only one thread, and the code is trying to run sequentially
11:52:17 <watermind> Cale: oh my
11:52:30 <byorgey> statusfailed: you're right that it's bad to try and fix errors by just adding language extensions.  But FlexibleContexts in particular is quite straightforward and uncontroversial.
11:52:42 <statusfailed> byorgey: so the problem is literally that in a type constraint block you can't have anything concrete?
11:52:46 <watermind> Cale: I was pretty sure I had that line over there :S
11:52:55 <watermind> argh
11:53:01 <byorgey> statusfailed: right, not according to the bare standard.
11:53:07 <statusfailed> okey dokes! question answered :)
11:53:13 <statusfailed> thanks very much guys :D
11:53:52 <byorgey> statusfailed: and for future reference, if you wanted to know about what that error meant and why you were seeing it, you should have asked that in the first place
11:53:58 <byorgey> statusfailed: "why can't I do X" is rather vague
11:54:17 <statusfailed> fair point...
11:54:37 <statusfailed> Seems a stupid way to ask the question when you put it like that :)
11:55:05 <byorgey> statusfailed: no worries, asking good questions is a nontrivial skill
11:55:38 <statusfailed> sadly true, haha
11:56:10 <johnw> I wonder if Philosophy could be boiled down to the art of perfecting the question
11:56:15 <watermind> thanks Cale, that was rather silly :S
12:03:13 <Cale> Philosophy is the art of getting different definitions confused with one another and then arguing about it.
12:06:33 <johnw> if I want to point remote-repo at a local directory, do I just give the directory name, or do I have to use a file:// URI?
12:09:44 <merijn> Cale++
12:17:12 <spark__> someone can help me with attoparsec? @.@
12:17:26 <statusfailed> spark__: maybe... what's the problem? :)
12:17:42 <spark__> welll, i finally manage to get it compiling
12:17:52 <statusfailed> spark__: you mean attoparsec? via cabal?
12:18:35 <spark__> buut it fails
12:18:36 <spark__> (no match)
12:18:36 <spark__> using it
12:18:37 <spark__> not installing it
12:18:44 <spark__> I could get parsec just fine with RWH, but attoparsec is being hellish
12:18:47 <statusfailed> Could you paste your code somewhere?
12:18:50 <statusfailed> hpaste is the norm
12:19:13 <hpaste> spark_ pasted “help with attoparsec!” at http://hpaste.org/73791
12:19:19 <ericmj> i've seen natural numbers implemented both ways in Haskell. What is the difference? https://gist.github.com/3491459
12:20:11 <statusfailed> oh cool, hpaste runs hlint :O
12:20:15 <spark__> statusfailed:  done!
12:20:15 <spark__> statusfailed: hope you can give me a light D:
12:21:45 <statusfailed> spark__: I don't suppose you could upload "lol.txt"?
12:22:00 <statusfailed> or give a simple example of what you're parsing
12:22:05 * hackagebot logic-TPTP 0.4.0.0 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.4.0.0 (DanielSchuessler)
12:22:19 <Sgeo> @hoogle [[a]] -> [a]
12:22:20 <lambdabot> Prelude concat :: [[a]] -> [a]
12:22:20 <lambdabot> Data.List concat :: [[a]] -> [a]
12:22:20 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
12:24:49 <spark__> right now its empty, the functions goes throug undefined
12:24:53 <spark__> statusfailed:
12:25:08 <spark__> the parsing is
12:25:27 <statusfailed> We're just concerned here with "readExpr" and "parseAcc", is that correct?
12:26:14 <spark__> yes
12:26:30 <spark__> parsing is like this
12:26:51 <statusfailed> also, I think you can remove all your "fromString" calls if you use {-# LANGUAGE OverloadedStrings #-}
12:26:55 <spark__> (131,24,12,2012-08-27 time)
12:27:03 <statusfailed> oh ok
12:27:16 <spark__> the date can be text, i dont care
12:27:20 <statusfailed> ok
12:27:34 <statusfailed> so it's "read a bracket, read three numbers separated by commas, read a string, read a bracket"?
12:27:57 <spark__> yes
12:28:51 <Okasu> hello
12:29:08 <Okasu> do you know what can cause this "Main: caught (and ignoring) too few bytes. Failed reading at byte position 8" ?
12:29:47 <spark__> statusfailed: i just got that the value for () i put there are in hex, not decimal, fixing that
12:30:19 <spark__> Okasu: can you paste the code? D:
12:30:28 <Okasu> spark__: it's lambdabot
12:30:45 <spark__> hmmmm
12:31:49 <statusfailed> spark__: oh, you are missing commas in between your three decimals
12:32:23 <statusfailed> spark__: so you have do { x <- decimal; y <- decimal; ... } when you should have { x <- decimal; char ','; y <- decmial ... }
12:32:37 <spark__> statusfailed:  darn, of course
12:32:46 <spark__> statusfailed:  i had a takeuntil before
12:32:54 <spark__> thanks for catching that
12:32:57 <statusfailed> It's been a while since I did attoparsec, took a while :P
12:33:08 <statusfailed> is the "satisfy (==28) catching the first bracket?
12:33:20 <spark__> I have no idea
12:33:25 <spark__> (btw is 40)
12:33:35 <Okasu> spark__: strange thing is when i disable Seen pluging error is gone :/
12:34:00 <statusfailed> spark__: perhaps use "char '('" instead?
12:34:32 <statusfailed> spark__: I have to run, hope that helped!
12:35:10 <Okasu> also i've fixed log plugin, now lambdabot can log propperly :)
12:35:55 <sheldonh> i'm implementing functions in Data.List as a learning exercise. i did intersperse like this: http://fpaste.org/U1UJ/  the haskell implementation is different, to avoid space leaks. should it have been obvious to me that my version would feature space leaks? (haskell version here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#intersperse )
12:36:28 <spark__> statusfailed: it did, thanks!
12:36:39 <statusfailed> sheldonh: I've read in many places that a downside to Haskell is that it is sometimes difficult to reason about space usage
12:36:42 <statusfailed> so I guess not :)
12:36:51 <statusfailed> (but I didn't read the code...)
12:36:54 <statusfailed> spark__: np!
12:37:14 <spark__> statusfailed:  too bad that now i destroyed something else in my program hahah
12:37:18 <sheldonh> statusfailed: ok. so it may be a case of "take it easy, young one. it will come with time"?
12:37:46 <statusfailed> sheldonh: perhaps, i'd let others weight in here though, i'm basically a beginner :D
12:37:49 <statusfailed> *gone*
12:38:02 <merijn> sheldonh: Take into account that the comment mentions "it was determined through testing"
12:38:23 <sheldonh> merijn: so maybe the lesson is "test your code" :)
12:38:24 <merijn> sheldonh: In other words, the person who wrote that code wasn't even able to reason which was more efficient
12:38:42 <merijn> sheldonh: The lesson is, don't optimise 'till you need to :p
12:38:50 <sheldonh> haha. great, then i'm done! :)
12:39:09 <sheldonh> merijn: i suppose i could feed it an infinite list and see what happens ;)
12:39:24 <merijn> sheldonh: I wouldn't really worry about the difference while you're still learning anyway
12:39:33 <merijn> sheldonh: Most programs don't involve you writing intersperse :p
12:39:40 <sheldonh> merijn: cool, i was hoping this was the answer :)
12:43:34 --- mode: ChanServ set +o Cale
12:43:41 --- mode: Cale set -q $a:mk
12:43:46 --- mode: Cale set -o Cale
12:54:05 <sheldonh> haskell programmers never die. they simply cease to function
12:54:09 <applicative> sheldonh: did you detect a space leak yourself?
12:55:03 <sheldonh> applicative: nope. i took the advice and moved on to the next function :)
12:55:26 <sheldonh> applicative: that said, i fed it an infinite list, and my computer didn't like that at all :)
12:55:33 <applicative> I see the remark in the Data.List comments.
12:56:47 <sheldonh> applicative: yeah, that's what made me ask. i write a function, then look at the haskell source to see how much better i could have done it
12:56:50 <applicative> oh, I just fed it a halfgigabyte file of chars interspersing 'a'.
12:57:53 <applicative> did you compile with -O1 or -O2 or whatever
12:58:34 <applicative> main = interact $ intersperse 'a'
12:58:41 <sheldonh> applicative: nah, just in ghci. i would have taken it more seriously, but as merijn pointed out, this is probably a rabbit hole that isn't worth greasing up for, this early in my learning :)
12:58:59 <sheldonh> applicative: what's that dollar about?
12:59:28 <applicative> sheldonh: it just puts parens around the following
12:59:29 <sheldonh> ah, hoogle knows
12:59:43 <maloi> hoogle knows best
12:59:43 <applicative> main = interact (intersperse 'a')
13:00:22 <Yuu-chan> @hoogle Monad m => m (m a) -> m a
13:00:22 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
13:00:22 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
13:00:22 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
13:00:40 <applicative> it does this by the low precedence the $ operator has, but itself it just means 'applied to'
13:01:06 <sheldonh> applicative: thanks
13:01:12 * Yuu-chan remembers a holywar about using $ and parens
13:01:21 <asdasd__> hi, is there a way for a thread to kill itself?
13:01:32 <johnw> why $ do $ you $ say $ that $ Yuu-chan?
13:02:11 <asdasd__> I was looking for some info on Control.Concurrent or Control.Exception, but I could not find it
13:02:34 <Yuu-chan> (prefer (some people) (nested expressions (against (flat ones))))
13:02:37 <johnw> what if you call killThread myThreadId?
13:02:40 <asdasd__> in particular, I would like to a thread commit suicide in a non-IO part
13:03:01 <johnw> killThread is in IO
13:03:10 <johnw> don't see how you're going to get killing to happen without a side-effct
13:03:10 <asdasd__> I would like to do that outside of the IO
13:03:17 <Cale> error?
13:03:26 <johnw> killing isn't a "value", it's an IO action
13:03:52 <johnw> Yuu-chan: maybe from Lisp they are
13:03:54 <asdasd__> I was thinking something along the lines of unsafePerformIOAction
13:04:06 <johnw> ah, well then
13:04:13 <johnw> unsafePerformIO $ killThread myThreadId
13:04:21 <dmwit> asdasd__: My advice would be to have your pure computation return, say, an Either e a; if it returns (Left err), then just stop doing things, and if it return (Right val), keep doing things.
13:04:48 <asdasd__> thanks dmwit
13:04:49 <johnw> yes, it's bad form to hide effects inside code that gives the appearance of being pure
13:04:54 <dmwit> unsafePerformIO is very likely to cause headaches if you use it for this.
13:04:57 <Yuu-chan> > unsafePerformIO $ return 2
13:04:58 <lambdabot>   Not in scope: `unsafePerformIO'
13:04:59 <johnw> that misguides your reader
13:05:15 <dmwit> unsafePerformIO comes along with a proof burden (namely, that the unsafePerform'd thing is really pure) which you can't satisfy here.
13:05:31 <Jeanne-Kamikaze> it's in System.IO.Unsafe
13:05:45 <johnw> it's should be in System.IO.Tempered.Insanity
13:05:51 <Jeanne-Kamikaze> also, why will the unsafe kill be evaluated ?
13:06:13 <Yuu-chan> Is it possible for the lambdabot to import modules?
13:06:15 <dmwit> Ensuring that things are evaluated at the appropriate time is one of the "headaches" I was referring to above. =)
13:06:26 <dmwit> Yuu-chan: Nope.
13:06:26 <asdasd__> wow
13:06:46 <Yuu-chan> @source unsafePerformIO
13:06:53 <johnw> unsafePerformIO :: IO a -> a
13:06:59 <lambdabot> unsafePerformIO not available
13:07:11 <dmwit> Yuu-chan: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-IO.html#unsafePerformIO
13:07:22 <Yuu-chan> dmwit: thanks :)
13:07:31 <johnw> if I have an IO (Maybe a), would a join call unsafePerformIO?
13:07:54 <johnw> oh, never mind
13:07:56 <asdasd__> I see your point, I'll do as dmwit suggested
13:07:57 <johnw> it unwraps m (m a)
13:08:01 <johnw> not m (n a)
13:08:01 <geekosaur> join works only when it's the same monad, IO is not Maybe
13:08:01 <joe9> i cannot have a function that returns a typeclass, correct? a function has to return a particular type, doesn't it?
13:08:18 <dmwit> joe9: Your function can be typeclass polymorphic.
13:08:20 <dmwit> For example:
13:08:22 <dmwit> :t const 9
13:08:23 <lambdabot> forall t b. (Num t) => b -> t
13:08:37 <johnw> but yes, the return type has to be concrete
13:08:37 <applicative> :t 3
13:08:38 <lambdabot> forall t. (Num t) => t
13:09:02 <Jeanne-Kamikaze> dmwit: did you reach any conclusion ?
13:09:04 <johnw> if the return type is not concrete, you're dealing with a type constructor
13:09:11 <dmwit> Jeanne-Kamikaze: About what?
13:09:24 <Jeanne-Kamikaze> about ensuring that stuff is evaluated at the appropiate time
13:09:39 <applicative> :t fromIntegral . ord
13:09:40 <lambdabot> forall b. (Num b) => Char -> b
13:09:46 <joe9> dmwit, johnw, i have 2 types belonging to a certain typeclass. I cannot return a list of values that could be either type, correct? It has to be a list of either the first type or the second type, correct/
13:09:47 <dmwit> Jeanne-Kamikaze: Can you state the concrete question?
13:10:06 <johnw> joe9: you mean, a heterogenious list?
13:10:13 <dmwit> joe9: Yes, that's correct.
13:10:15 <johnw> you could use dynamic typing, if you really had to
13:10:36 <applicative> joe9: no you cant you can either Either Type1 Type2 and make a list.
13:10:45 <LordBrain> Does the annotate button on hpaste behave as an edit or does it add another post to appear underneath the previous one?
13:10:46 <johnw> see Data.Dynamic, but question your need for it first
13:10:53 <applicative> you can use Either I mean, thats the simple answer
13:10:54 <joe9> johnw: ok, thanks. I want to stick with typeclasses, types. my option is to just define them as the same "data" type  instead of having a typeclass.
13:10:56 <Jeanne-Kamikaze> dmwit: it seems that if I roll some STM and I have thread1 producing X and thread2 consuming X, then thread1 won't do any work, and instead it'll be thread2 evaluating X
13:10:57 <dmwit> LordBrain: It adds another post.
13:11:13 <johnw> joe9: I ended up having to do something very similar last night
13:11:19 <joe9> johnw: ok, thanks.
13:11:36 <dmwit> Jeanne-Kamikaze: That depends very much on the exact code used in thread 1. But yes, a common mistake is to forget that the various pointer types are lazy.
13:11:36 <johnw> I need a GitTree to have a list of either GitBlobs or other GitTrees.  So I made a GitObject type, of which GitBlob and GitTree are value constructors
13:11:56 <Jeanne-Kamikaze> and how do you force evaluation in thread 1 ?
13:12:13 <dmwit> Pattern match, or, if you're really stuck, use seq.
13:12:31 <Jeanne-Kamikaze> say thread 1 is only running pure code, and leaving the results in a tvar
13:12:39 <Jeanne-Kamikaze> but seq only imposes an order, it doesn't force anything
13:12:57 <dmwit> In short: you introduce an extraneous data dependency of the STM action on the data contained in the TVar.
13:13:01 <Jeanne-Kamikaze> if the topmost thing isn't evaluated, nothing is evaluated
13:13:09 <Jeanne-Kamikaze> oh ?
13:13:26 <dmwit> compare:
13:13:31 <dmwit> > return undefined :: [Int]
13:13:33 <lambdabot>   [*Exception: Prelude.undefined
13:13:39 <dmwit> > return $! undefined :: [Int]
13:13:40 <lambdabot>   *Exception: Prelude.undefined
13:13:54 <hpaste> LordBrain annotated “GHC Bug?” with “GHC Bug? (annotation)” at http://hpaste.org/73718#a73792
13:13:59 <Jeanne-Kamikaze> an extra [ ?
13:14:00 <dmwit> You can have the same thing for STM actions: an action which first evaluates some data, then tells what STM transaction to run.
13:14:12 <applicative> joe9 there are other fancy options, e.g. a type that refers to the class data X = X (C a => a ) and suchlike things
13:14:18 <dmwit> Jeanne-Kamikaze: Yes, that extra [ is a clue about evaluation order. =)
13:14:38 <dmwit> Jeanne-Kamikaze: The first is a list-action containing an undefined value; the latter is, too, but it evaluates the undefined value before evaluating to that.
13:14:39 <Jeanne-Kamikaze> so the first one evaluated the list constructor ?
13:14:48 <Jeanne-Kamikaze> I see
13:15:12 <Jeanne-Kamikaze> but you're cheating, because you're printing the result so you're triggering an initial evaluation
13:15:34 <dmwit> Your STM action is going to get passed to atomically and incorporated in main (presumably).
13:16:27 <applicative> oh no haskell crushed again by prof. harper.
13:18:15 <thirsteh> he sure seems quite pissed that nobody's using ML
13:19:08 <thirsteh> his "Haskell is Exceptionally Unsafe" was pretty funny/good linkbait
13:19:13 <dylukes> Ugh. I have this ingrained distaste for like… everyone in my major with a few exceptions.
13:19:45 <latro`a> what's your major
13:19:49 <dylukes> It's really really vane but I feel like they all have personally decided not to grow up, not to care about their appearances at all, and not to just… self-analyze.
13:19:52 <dylukes> Computer Science.
13:20:09 <Jeanne-Kamikaze> dylukes: shit does happen
13:20:13 <thirsteh> welcome to college, heh
13:20:16 <latro`a> it gets better, I think
13:20:16 <dylukes> I feel like they're annoying and lack introspection. Like some programming languages.
13:20:17 <Jeanne-Kamikaze> indeed
13:20:29 <latro`a> but it's very much "welcome to college" yeah
13:20:30 <Philonous> thirsteh:  My guess is, he is quite pleased with the state of affairs and tries to keep the riff-raff in the haskell world by alienating possible converts
13:20:40 <dylukes> I can forgive them being who they are, withoiut any issue.
13:20:43 <Jeanne-Kamikaze> you mean reflection ?
13:20:47 <thirsteh> Philonous: oh really :)
13:21:03 <Jeanne-Kamikaze> dmwit: I'm not sure I follow
13:21:04 <dylukes> What drives me up the wall is the complete lack of any attempt to assess and evaluate themselves, and improve.
13:21:16 <thirsteh> To understand recursion you first have to understand ecursion
13:21:20 <merijn> dylukes: Depending on the university CS can be crawling with antisocial nerd stereotypes which ruin everything >.>
13:21:23 <dmwit> Jeanne-Kamikaze: You complained that I'm triggering some evaluation. I retorted that you are too, just you forgot about it.
13:21:38 <dylukes> merijn: ding ding ding.
13:21:41 <dmwit> Jeanne-Kamikaze: In particular, by including things in "main", the only thing that the runtime bothers to evaluate without you asking it to.
13:21:48 <Jeanne-Kamikaze> dmwit: the problem is who's doing the evaluation
13:22:09 <dmwit> Let's make it very concrete.
13:22:26 <Jeanne-Kamikaze> if I make a thread that creates a list and another thread that prints it, the second thread will evaluate the list
13:22:31 <dylukes> Well, this is where they realize a healthy mind inhabits a healthy body, get a social wake up call, and probably also realize they've already doomed to mediocrity just a little too late to make up for it.
13:22:32 <dmwit> writeTVar expensiveCalculation -- the person who reads this TVar and evaluates the constant is going to do the work
13:22:37 * dylukes is spiteful today.
13:22:41 <Jeanne-Kamikaze> exactly
13:22:51 <Jeanne-Kamikaze> and I want the dude doing the writing to evaluate it
13:23:02 <dmwit> let x = expensiveCalculation in x `seq` writeTVar x -- the person who evaluates *this STM action* is the one who is going to do the work
13:23:09 <Jeanne-Kamikaze> writeTvar var "an already evaluating thing"
13:23:17 <Jeanne-Kamikaze> oh shit
13:23:17 <dmwit> *not* the reader of the TVar (unless the reader is also the person executing this write)
13:24:12 <Jeanne-Kamikaze> dmwit: what if expensive calculation depends on other expensive calculations and you only write once in a while ?
13:24:34 <Jeanne-Kamikaze> then it will only evaluate the mega expensive calculation when it writes
13:24:43 <Jeanne-Kamikaze> what if you want to lay your expensive calculations smoothly in time ?
13:25:04 <keyu> Are functions functors ?!?!
13:25:05 <dmwit> "smoothly in time"?
13:25:15 <Jeanne-Kamikaze> yeah
13:25:20 <Jeanne-Kamikaze> evened out
13:25:28 <ion> kyu: ((->) a), or (a ->), is an instance of Functor.
13:25:37 <Jeanne-Kamikaze> i.e. force the evaluations of the intermediate expensive calculations
13:25:38 <ion> keyu even
13:25:39 <johnw> dylukes: it's been my observation that hating on anonymous people is almost always disguised self-hate
13:25:48 <Jeanne-Kamikaze> instead of making a mega expensive calculation right before I write to the TVar
13:25:55 <applicative> the code in Harper doesn't seem to bother to compile the ML he includes in his paper
13:26:09 <dylukes> johnw: It's not disguised.
13:26:12 <applicative> rather ,  Harper doesn't seem to bother to compile the ML he includes in his paper
13:26:13 <johnw> lol
13:26:22 <Jeanne-Kamikaze> keyu: yes, functor of a function is just function composition iirc
13:26:26 <dylukes> I'm hating on aspects of myself I've done the best to wipe out or polish and improve.
13:26:33 <Jeanne-Kamikaze> i.e. fmap = .
13:26:34 <dmwit> Jeanne-Kamikaze: Force the calculations whenever you want them forced.
13:26:36 <johnw> what I mean is, if the self-hate were truly recognized, the hate-of-others would fade away
13:26:38 <dmwit> What's the problem?
13:26:44 <Jeanne-Kamikaze> how do I do that ?
13:26:55 <johnw> we displace what we cannot accept
13:27:01 <dmwit> As before: pattern match on them, or use seq if you don't have the constructors in scope.
13:27:09 <dylukes> johnw: No, that's just sophist bullshit :P.
13:27:31 <dylukes> We just hate what we enjoy hating, or we find convenient to hate. We're assholes. Get used to it.
13:27:34 <jfischoff> dylukes, johnw: blah?
13:27:34 <thirsteh> johnw: I can't stand most people, and I rather like myself. How do you like them apples.
13:27:42 <dylukes> Oh, wait, this isn't blah.
13:28:03 <dylukes> johnw: go to blah if you want to further discuss.
13:28:22 <Jeanne-Kamikaze> dmwit: but won't that force their evaluation only when the top-level thing is demanded ? For example, say thread 1 creates a list of very expensive lists; then the very expensive lists will only be evaluated when the top-level list is evaluated, which is when the TVar is written to
13:29:09 <Jeanne-Kamikaze> but I want the expensive lists to be evaluated as they are prepended to the top-level list, say
13:29:25 <dmwit> All of this smacks of a confusion about what you're doing.
13:29:37 <dmwit> You'd better write some code and come up with a real performance problem first, and only fix it second.
13:29:41 <dylukes> yep yep.
13:29:48 <dylukes> You can always change the evaluation time later.
13:31:01 <applicative> harper and blelloch want us to focus on the difference between these definitions of map
13:31:07 <applicative> fun map f [] = [] | map f h::R = f(h)::map R  vs fun map f [] = [] | map f h::R = let val R' = map R in f(h)::R'
13:31:24 <applicative> somehow I think they didn't test any of their results
13:31:33 <lightquake> johnw: wait
13:31:40 <lightquake> er, -johnw:. sorry for the accidental ping
13:31:42 <johnw> thirsteh: I didn't say the self-hate was conscious; if it were, it wouldn't be displaced.  Such a person likes themselves *precisely* at the cost of disliking anonymous others (people whom they don't know).  The integrated person likes themselves and mostly doesn't think about people they don't know.  </soapbox>
13:31:44 <lightquake> applicative: wait. what's the difference? O_o
13:32:06 <bos> johnw: offtopic
13:32:07 <johnw> lightquake: np
13:32:09 <lightquake> i think the equivalent haskell is operationally and semantically equivalent
13:32:11 <thirsteh> is [n,n,n] < [n,n,n] == x1 < y1 && x2 < y2 && x3 < y3?
13:32:13 <johnw> bos: yeah, stopping now
13:32:16 <bos> thanks
13:32:35 <applicative> the let in the second.  I was just pointing to the obvious lack of 'f' in the two expressions "map R"
13:32:40 <lightquake> thirsteh: comparing lists is lexicographic, yeah
13:32:45 <lightquake> applicative: ... oh, ha.
13:32:45 <thirsteh> i.e. does list Eq work like I think it does?
13:32:46 <thirsteh> great, thanks
13:33:19 <Philonous> applicative: Does ml allow matching :: without parens?
13:33:50 <applicative> II  was surprised by that Philonous
13:33:51 <Philonous> applicative:  That was the first thing I noticed, but I don't remember
13:34:17 <applicative> me neither.  He's going to have to work a lot harder to convince me to use sml
13:35:37 <applicative> I could do with more little essays like the one on Boolean Blindness
13:38:59 <Jeanne-Kamikaze> ok I was being stupid you were right
13:42:53 <johnw> applicative: nice article, thanks for the pointer
13:43:26 <applicative> on Booleans ?
13:43:54 <johnw> yeah
13:44:23 <timtheli1n> Why don't I have newBroadCastTChan?  I have the latest GHC... http://hackage.haskell.org/packages/archive/stm/latest/doc/html/Control-Concurrent-STM-TChan.html#v:newTChan
13:44:57 <spark__> I have a hugeeeeeeee memory leak, I traced it back to the implementation of pure-fft, any other fft libraries that doesnt use the C bindings avaliable? maybe something with the gpgpu?
13:45:25 <dmwit> timtheli1n: Could it be capitalization? the 'c' in Broadcast
13:45:43 <bos> spark__: try the fft package
13:45:45 <timtheli1n> dmwit: no, because I don't get it with tab completion in ghci either.
13:45:59 <dmwit> ghc-pkg list stm
13:46:16 <timtheli1n> /usr/lib/ghc-7.4.2/package.conf.d stm-2.3
13:46:19 <latro`a> isn't the fft package a binding to FFTW?
13:46:38 <spark__> the fftw? it uses c bindings and i cant manage to install the bindings on windows
13:46:47 <timtheli1n> oh, OK, so I need stm2.4?
13:46:52 <dmwit> Seems so. =)
13:46:52 <timtheli1n> maybe?
13:47:00 <latro`a> spark__, have you tried mingw/cygwin?
13:47:01 <timtheli1n> and when was that released?
13:47:06 <latro`a> (not that they're great, but saves some pain in theory)
13:47:07 * hackagebot configurator 0.2.0.1 - Configuration management  http://hackage.haskell.org/package/configurator-0.2.0.1 (BryanOSullivan)
13:47:27 <spark__> latro`a: theorically it comes with the ghc, still, it doesnt make sense for me
13:47:39 <dmwit> Hackage says July 4
13:47:47 <jfischoff> spark__: there is a 2d fft example in the repa-example that is pure haskell
13:47:48 <latro`a> FFTW in particular should be very easy to install
13:47:55 <spark__> hmmm
13:47:56 <latro`a> as C programs go
13:48:13 <pyrtsa> thirsteh: Btw, comparing lists is lexicographic, but x1 < y1 && x2 < y2 && ... is *not* a lexicographic comparison.
13:48:14 <timtheli1n> dmwit: if I cabal install stm will it get me the new one?
13:48:25 <spark__> well, when i tried hmatrix i lost so much time circling around
13:48:31 <timtheli1n> dmwit: given that I have GHC installed as binarry?
13:48:37 <dmwit> That I don't know. Installing libraries that come with GHC makes me nervous, though.
13:48:38 <latro`a> LAPACK is markedly more difficult to install than FFTW imo
13:48:56 <spark__> latro`a: well ill try it D: thanks
13:49:16 <timtheli1n> dmwit: well OK, there's a rather large memory leak associated with not having that function...  But I guess I'll live for now.
13:49:23 <thirsteh> pyrtsa: sorry, lexicographical order was what I meant
13:50:23 <jfischoff> sparks__: http://hackage.haskell.org/packages/archive/repa-algorithms/3.2.1.1/doc/html/Data-Array-Repa-Algorithms-FFT.html
13:51:02 <jfischoff> 50x slower then FFTW woah
13:51:35 <dmwit> timtheli1n: Seems like you ought to be able to fix that leak by just forking a thread that does nothing but read from the original TChan.
13:51:39 <dmwit> No idea if that's actually true.
13:52:06 <timtheli1n> dmwit: I guess I could.  Or simply handing the initial TChan to the first reader without duplication
13:52:45 <pyrtsa> thirsteh: Lexicographic order is defined by (x1 < y1 || (x1 == y1 && x2 < y2)) etc.
13:53:09 <thirsteh> pyrtsa: yeah, that's what I meant
13:53:23 <dmwit> > x < y
13:53:24 <lambdabot>   True
13:53:26 <dmwit> hm
13:53:31 <pyrtsa> Ok. :)
13:53:43 <dmwit> not exactly what I was hoping for, but now I realize everything has the wrong type for what I'm hoping for
13:54:12 <thirsteh> what happens if you write > [1..] ?
13:54:50 <dmwit> Try it. =)
13:54:52 <thirsteh> now somebody has to do it...
13:54:58 <thirsteh> > [1..]
13:54:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:55:10 <thirsteh> nice
13:55:32 <dmwit> lambdabot has been hardened by years of attack attempts. If you manage to get it to do something unsavory I'll be impressed. =)
13:55:46 <johnw> i have a Cabal project which use an "include-dirs: dir" line for building the library.  configure/build/haddock/test/sdist all work fine, but upload is complaining with: 'include-dirs: dir' directory does not exist.
13:56:04 <dmwit> Well... does "dir" exist?
13:56:07 <johnw> yes
13:56:09 <shachaf> dmwit: lambdabot has very little security.
13:56:11 <thirsteh> yeah, I guess I should have expected somebody to have come up with that idea before
13:56:13 <thoughtpolice> johnw: you probably have to put the contents of dir in the extra-source-files field
13:56:17 <thoughtpolice> IIRC
13:56:21 <johnw> ok, let me try that
13:56:35 <shachaf> For example, it's easy for anyone to become a lambdabot admin.
13:56:47 <dcoutts> johnw: are any of the modules in the lib actually in said dir?
13:57:07 <johnw> no, the dir contains C headers used for creating the library's FFI files
13:57:11 <dmwit> Hm, lambdabot doesn't even check if admins are identified to services? Or what?
13:57:16 <johnw> I would think they are unnecessary once the FFI files have been built
13:57:23 <shachaf> For instance.
13:57:25 <thoughtpolice> dmwit: there's some catch with lambdabot where one of the admins is an unregistered user or something i think?
13:57:40 <dcoutts> johnw: ahh ok, then yes you need to list it in extra-source-files, cabal cannot auto-discover .h files
13:57:47 <shachaf> But in general there's been little attention paid to security.
13:57:55 <thoughtpolice> Phlippa or something i think. i thought someone (mauke maybe?) had re-registered that
13:57:56 <johnw> extra-source-files is unrecognized
13:58:13 <shachaf> thoughtpolice: That's unrelated to lambdabot.
13:58:15 <dcoutts> johnw: it= the .h files. It lives in the global section, not lib/exe section
13:58:17 <dmwit> Anyway, I didn't say what I meant, and you're right for pointing that out. I meant that I'd be impressed if he could get ?eval to do something unsavory.
13:58:18 <shachaf> thoughtpolice: That was #-blah.
13:58:25 <johnw> ah, ok
13:58:30 <thoughtpolice> shachaf: oh
13:58:31 <shachaf> @help eval
13:58:31 <lambdabot> eval. Do nothing (perversely)
13:58:36 <shachaf> @eval blah
13:58:54 <dmwit> or whatever the plugin that provides "> " is called
13:59:08 <geekosaur> @list run
13:59:08 <lambdabot> eval provides: run let undefine
13:59:22 <dmwit> ?run 3 + 5
13:59:23 <lambdabot>   8
13:59:50 <johnw> cool, that worked, thanks guys
14:00:08 <johnw> <-- new maintainer of hlibgit2
14:00:24 <shachaf> eval is piped to mueval (mooeval?), which has paid a little more attention to security.
14:00:31 <geekosaur> "> " is an input parser hook provided by the run module, which translates to @run
14:00:46 <thoughtpolice> dcoutts: btw, while i have a minute i might as well ask - cabal doesn't allow really greedy globbing in extra-source-files, because it's possible to include things like editor remnants or whatever that may interfere with the build process. but would there be room for a ticket in Cabal to actually allow it somewhow? right now I have 2 or 3 packages that carries a ton of C source files, and my solution is to just pipe `find -type f -iname '*.h'
14:00:53 <geekosaur> unless someone rewiredthat part of LB since the last time I worked on it
14:01:20 <dcoutts> thoughtpolice: it allows limited globbing, like blah/*.h
14:01:48 <thoughtpolice> dcoutts: yes, but there are tons of subdirectories that have multiple files that need including with multiple suffixes, and several of them don't even have suffixes
14:02:05 <johnw> does */* work?
14:02:06 <dcoutts> thoughtpolice: one extension that seems reasonable is "blah/" to mean whole directory, recursively
14:02:07 * hackagebot hlibgit2 0.2 - Low-level bindings to libgit2.  http://hackage.haskell.org/package/hlibgit2-0.2 (JohnWiegley)
14:02:09 <johnw> or can it only glob leaves?
14:02:09 <thoughtpolice> i just have a generic script i move around that does all the piping through find/sort to get me a reasonable list
14:02:14 <dcoutts> johnw: no, deliberately
14:02:14 <thoughtpolice> dcoutts: yes, i would love that
14:02:29 <thoughtpolice> i understand the rationale behind not allowing full globs, but it would really be nice :)
14:02:40 <dcoutts> aye
14:02:40 <shachaf> Why not "blah/**"?
14:02:49 <shachaf> That's the "standard" syntax for recursive globs.
14:02:58 <thoughtpolice> dcoutts: here's an example of what i mean, in the extreme case - https://github.com/thoughtpolice/salt/blob/master/salt.cabal#L46
14:03:07 * geekosaur would be tempted to start from a *.cabal.sh which had the real *.cabal as a here document with $() expansions inside
14:03:12 <johnw> haha, I like the comment thoughtpolice
14:03:24 <Hadaka> if using a totally unsupported distribution - but where the "generic" haskell binaries work - is it worth it to recompile GHC on that platform or should one just use the pre-built binaries?
14:03:44 <jfischoff> **/*.png -> glob all pngs recursively
14:03:44 <thoughtpolice> johnw: pretty much
14:03:47 <geekosaur> rebuilding ghc is a fairly big project; use the prebuilt when possible
14:03:51 <LordBrain> what univerity do you attend dylukes ?
14:03:55 <dcoutts> thoughtpolice: mm, it's a fair point
14:03:57 <johnw> version 0.0?
14:04:03 <thoughtpolice> dcoutts: in any case, i'll file a ticket and it can be hashed out there :)
14:04:06 <johnw> are you on a platform where that /= 0?
14:04:07 <thoughtpolice> johnw: it's not released yet
14:04:08 * geekosaur just did the ghc rebuild thing, via freebsd ports...
14:04:10 <thoughtpolice> although it should be
14:04:16 <dcoutts> thoughtpolice: search first, I think there's a couple
14:04:19 <dylukes> LordBrain: University of Pittsburgh
14:04:24 <thoughtpolice> johnw: i always keep the version at 0.0 and bump to 0.1 on an initial release
14:04:25 <thoughtpolice> dcoutts: ok
14:04:30 <dmwit> johnw: For versions, x.0 /= x for all x
14:04:42 <dmwit> including x that look like y.z
14:04:47 <johnw> dmwit: i know, it was just floating-point humor
14:04:57 <Hadaka> geekosaur: okay, thanks
14:05:01 <dmwit> My sarcasm detector is broken. =(
14:05:03 <johnw> having worked on floating-point libraries, I needed to ease the pain
14:05:22 * dmwit chuckles at johnw's joke in retrospect
14:05:27 <johnw> :)
14:06:11 <dmwit> thoughtpolice: Hm, at that point I'd start looking into just including a tar of all the files.
14:06:17 <dmwit> Let Setup.hs untar it before the real work starts.
14:06:21 <johnw> thoughtpolice: I want to use your library now :)
14:06:26 <johnw> release it!
14:06:28 <thoughtpolice> dmwit: i thought about it. i don't use Setup.hs, i have a hand-written configure script
14:06:49 <thoughtpolice> it actually does out of line compilation of the underlying library, because it is impossible for several reasons to either A) have pre-built copies or B) make cabal build it
14:06:52 <johnw> the last time I needed an MD5, I wrote my own FFI code to use openssl.  blech
14:07:19 <dcoutts> johnw: there's some fairly fast pure Haskell md5 libs
14:07:33 <johnw> this was a really long-time ago, and I think my ability to find existing libraries sucked then
14:07:36 <thoughtpolice> dmwit: if you want the details as to why, you can read the 'Installation' part here: http://thoughtpolice.github.com/salt/ - i've found the 30 line sh script to work OK so far
14:08:25 <Hadaka> there's no "generic linux" version of haskell platform, is there? that should be compiled manually then?
14:08:26 <thoughtpolice> johnw: i'm planning on it soon, i have another wave of packages i need to release anyway
14:08:36 <johnw> ooh, waves of packages
14:08:40 <thoughtpolice> and one i need to update before GHC 7.6 :)
14:08:49 <johnw> when is 7.6?
14:08:52 <dmwit> thoughtpolice: I definitely don't want to know the details.
14:08:58 <thoughtpolice> johnw: soon-ish
14:09:00 <dmwit> Details are never fun things to know in this field.
14:09:11 <thoughtpolice> dmwit: hahahaha, fair enough. i readily admit it's terrible
14:09:17 <johnw> forall soon. soon -> later
14:09:24 <thoughtpolice> i believe i mentioned how it worked to copumpkin and he vomited
14:09:51 <thoughtpolice> but i can't think of a better possible solution as it stands if i want people to just be able to install-n-go
14:11:54 <shergill> johnw: you're a haskeller. did not know
14:12:47 <latro`a> johnw: forall soon. soon -> Later
14:12:51 <latro`a> :p
14:13:19 <johnw> does haskell have an fmap on morphisms?
14:13:22 <latro`a> alternately
14:13:30 <latro`a> forall soon. Ish soon => soon -> Later
14:13:39 <johnw> shergill: it's a recent thing
14:13:45 <mm_freak> johnw: fmap is a map on morphisms, isn't it?
14:14:02 <mm_freak> fmap :: (a -> b) -> (F a -> F b)
14:14:19 <johnw> I know fmap maps objects of C onto objects of D
14:14:25 <johnw> but can it map arrows of C onto arrows of D?
14:14:33 <latro`a> uh
14:14:35 <mm_freak> johnw: in haskell every Functor is actually an endofunctor
14:14:42 <mm_freak> F : Hask -> Hask
14:14:48 <latro`a> functors map objects to objects, arrows to arrows
14:14:54 <mm_freak> johnw: and just read the type of fmap
14:15:00 <latro`a> unless you're talking about a functor category
14:15:03 <latro`a> which is a different object
14:15:14 <mm_freak> it's a map from morphism f :: a -> b to morphism fmap f :: F a -> F b
14:15:20 <johnw> ok
14:15:25 <johnw> that makes sense
14:15:27 <dmwit> fmap does not map objects of C onto objects of D
14:15:28 <johnw> thanks
14:15:41 <johnw> dmwit: I'm reading http://comonad.com/haskell/Comonads_1.pdf now
14:15:45 <johnw> but I may be reading some things incorrectly
14:15:46 <latro`a> and yeah, there is not necessarily a function a -> f b
14:15:48 <dmwit> in instance Functor Foo, it is Foo that maps objects of Hask onto objects of Hask
14:15:48 <latro`a> anywhere
14:15:51 <johnw> maybe I mean "functor" when I say "fmap"
14:16:02 <dmwit> You mean functor, yes.
14:16:29 <latro`a> actually
14:16:34 <latro`a> what would a functor be like with no a -> f b
14:17:00 <mm_freak> johnw: fmap is the function that maps morphisms for the given functor…  the object map is defined outside of the Functor instance
14:17:10 <dmwit> latro`a: You want to know how to write a Functor class in Haskell that doesn't refer only to Hask?
14:17:13 <mm_freak> read a type in GADT notation, that should make it clearer
14:17:18 <mm_freak> Just :: a -> Maybe a
14:17:35 <dmwit> latro`a: (I don't really understand your question.)
14:17:47 <latro`a> it doesn't really make sense with endofunctors
14:18:00 <latro`a> because with endofunctors you can have a = f b
14:18:03 <latro`a> and then id
14:18:40 <latro`a> but basically I'm thinking of a functor with no constructor
14:18:47 <latro`a> which I guess is automatically isomorphic to Void or Trivial?
14:19:04 <latro`a> but what if there are values of the type that you just can't build
14:19:22 * dmwit wrinkles his brow in confusion
14:19:34 <mm_freak> latro`a: i'm confused
14:19:35 <latro`a> I'm thinking of values like "getLine", that (for discussion purposes) you can't construct from other values
14:19:47 <latro`a> and a type all of whose values are such values
14:20:00 <johnw> i want to cabal install edwardk
14:20:00 <paolino> hello, is it of to unsafeCoerce from CFloat to Float ?
14:20:16 <latro`a> iirc no
14:20:16 <dmwit> No, you shouldn't do that.
14:20:17 <mm_freak> latro`a: the object map is the type itself:  IO :: * -> *
14:20:19 <dmwit> Use realToFrac
14:20:21 <jfischoff> @tell edwardk what's the plan for universeBi functionality?
14:20:21 <lambdabot> Consider it noted.
14:20:26 <latro`a> mm_freak, that's a type function
14:20:30 <latro`a> I'm talking about a value function
14:20:47 <mm_freak> latro`a: a value function is only captured in terms of morphisms
14:20:47 <dmwit> :t realToFrac
14:20:48 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
14:20:50 <mm_freak> for which you have fmap
14:21:08 <latro`a> mm_freak, I mean a value function that "adds a type constructor"
14:21:13 <latro`a> which fmap does *NOT* do to values
14:21:17 <paolino> dmwit, it's a StorableArray, if it's ok I'd avoid copying it
14:21:21 <mm_freak> latro`a: it doesn't have to
14:21:31 <mm_freak> latro`a: a functor maps objects (types) and morphisms (functions)
14:21:37 <latro`a> I know what a functor is
14:21:48 <latro`a> I'm trying to imagine a functor where the only values of the functor type are primitive
14:22:28 <latro`a> but I don't think you can do that without reducing to Trivial
14:22:33 <mm_freak> latro`a: there doesn't have to be a concrete representation in memory…  it's an abstract concept…  IO is perfectly fine as a functor
14:22:35 <latro`a> because that means you can't apply to the a, since there isn't one
14:22:36 <dmwit> paolino: Seems okay in GHC, according to the docs:
14:22:42 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t:CFloat
14:22:42 <paolino> dmwit, docs says CFloat is newtype Float,
14:22:49 <dmwit> That's not going to be portable, though.
14:22:51 <latro`a> mm_freak, IO has return
14:23:25 <latro`a> anyway, the thing I'm describing is definitely Trivial or something close enough to it
14:23:35 <mm_freak> latro`a: which is a natural transformation…  it maps from the identity functor to the IO functor
14:24:14 <latro`a> I know; I'm saying that if you don't have any way whatsoever to build "custom" values of the functor type, then you can't have a nontrivial endofunctor
14:24:24 <mm_freak> latro`a: why?
14:24:32 <latro`a> because there's nowhere for the "a" to be
14:24:36 <paolino> dmwit , is it right that they have same internal representations as they are one newtype of the other ?
14:24:38 <latro`a> it's analogous to a Maybe without a Just branch
14:25:03 <dmwit> In GHC, newtypes have the same representation as the thing they're newtypes of, yes.
14:25:07 <mm_freak> latro`a: why not?  if you imagine Hask as a graph, you would draw infinitely many objects prefixed "IO"
14:25:26 <mm_freak> latro`a: CT does not care at all about representation…  it's not at the value level
14:25:29 <latro`a> I know
14:25:30 <dmwit> Now ask yourself what newtype Newtype = Newtype Newtype does
14:25:48 <latro`a> but you can still think at value level
14:25:51 <latro`a> it just doesn't make CT happy
14:26:04 <mm_freak> it makes CT perfectly happy, because it doesn't care =)
14:26:08 <paolino> <loop> ?
14:26:11 <latro`a> eh, that's one way of looking at it
14:26:12 <latro`a> anyway
14:26:14 <latro`a> this is silly
14:26:18 <latro`a> so I'll stop
14:26:28 <nus> @src ()
14:26:28 <lambdabot> data () = ()
14:26:30 <mm_freak> if i would understand your problem…
14:26:45 <latro`a> you don't understand it because it isn't one
14:26:50 <shachaf> data Data = Data Data
14:27:04 <dmwit> At least I can build an operational model for Data.
14:27:12 <dmwit> The Newtype one... bleh
14:27:19 <paolino> dmwit , I can't imagine
14:27:25 <dmwit> I mean, I can "just calculate", but WTF is GHC really doing down there on my bits?
14:27:43 <mm_freak> latro`a: perhaps it would help you to separate the functor from the type…  there are objects Int and IO Int and a functor F : Int -> IO Int
14:27:46 <dmwit> zero-bit registers, I guess
14:28:11 <mm_freak> uhm
14:28:15 <mm_freak> F : Hask -> Hask
14:28:15 <latro`a> mm_freak, seriously, it's not a problem :p
14:28:18 <mm_freak> ok =)
14:28:28 <mm_freak> it sounded like one
14:30:43 <latro`a> it was
14:30:46 <latro`a> but it was silly
14:30:48 <latro`a> so now it isn't
14:31:31 <mm_freak> a silly problem is something like arguing whether 0 should be a natural number (or a number at all)
14:38:48 <johnw> i'm trying to read about the State Comonad, sometimes referred to as Store.  I'm wondering why it's isn't the Writer Comonad; or is it CoState because you can change the store being read from?
14:40:28 <johnw> and why can't I emulate Store in the State monad by just xs <- get ; put (tail xs) ; return (head xs)?
14:41:32 * johnw is trying to wrap his head around a practical use of Comands that does not involve stream or dataflow programming
14:41:57 <Hadaka> can cabal be forced somehow to never download anything from the network? can it be used to install from local packages?
14:42:26 <hpc> Hadaka: cd into a directory with a cabal file and run "cabal install" without the package name
14:42:31 <dcoutts> Hadaka: you can remove the remote-repo section from the ~/.cabal file
14:42:36 <hpc> or that
14:42:49 <hpc> if you're feeling silly, change the remote-repo to localhost
14:42:50 <Hadaka> oh, right! and then local-repo?
14:43:02 <dcoutts> Hadaka: also, for temporary use cases, you can do: cabal fetch blah, and then cabal install blah  when you're offline
14:43:13 <ivan> on this subject, does anyone have some kind of subset of hackage that is known-good?
14:43:24 <dcoutts> Hadaka: yes, you can have local archives/repos
14:43:57 <hpc> ivan: you can look for maintainers with names you recognize
14:44:34 <hpc> it's usually easy to tell the good ones from quality of the docs
14:44:42 <ivan> but there's no signing or encryption anywhere and who knows what's on that server ;)
14:44:59 <Hadaka> does cabal have any sort of package integrity checking? are there any signatures on packages? are there some requirements on getting to hackage?
14:45:15 <Hadaka> heh, quite the timing on my question
14:45:16 <mm_freak> johnw: notice that comonads are inherently resembling /values/, not computations
14:45:20 <ivan> there are requirements but uploads and passwords seem to be sent plaintext
14:45:23 <dcoutts> Hadaka: no, there's no integrity checking at the moment
14:45:29 <mm_freak> johnw: Store is really just a data structure
14:45:37 <dcoutts> ivan: the new server uses http digest auth btw
14:45:46 <dibblego> @hoogle CoproductT
14:45:46 <lambdabot> No results found
14:45:59 <Hadaka> dcoutts: please no? digest auth is a terrible protocol
14:45:59 <johnw> mm_freak: hmmm
14:46:11 <dcoutts> Hadaka: it's better than http basic
14:46:16 <johnw> mm_freak: so monads contexts into a grander context; while comands decompose contexts down to a base value?
14:46:23 <johnw> s/monads/monads compose
14:46:40 <dibblego> newtype CoproductT f x y a = CoproductT (EitherT f (x a) (y a)) -- is this out there somewhere?
14:46:41 <dcoutts> Hadaka: fact is, there's no sensible http auth method short of ssl and that brings a host of problems
14:46:42 <Hadaka> dcoutts: yes, marginally - https is out of the question?
14:47:08 <Clint> we'll fix it all with rfc6091 someday
14:47:18 <dcoutts> Hadaka: yes, for the moment. We use the pure Haskell http lib and it has no tls support.
14:47:48 <spark__> can ghc-pkg be used to register packages for pkg-manager?
14:47:50 <dibblego> johnw: re comonads: have you ever mapped across a list, but wanted to know your "current context" e.g. "what is to my left and right?"
14:47:52 <mm_freak> johnw: i don't think that's a useful way to think about those
14:48:05 <latro`a> dibblego, I think he explicitly excluded stream programming
14:48:08 <latro`a> earlier
14:48:08 <mm_freak> johnw: first consider pointed (return) vs. copointed (extract)
14:48:10 <Hadaka> authentication without data integrity protection is anyway doomed to fail in the end, so there's not much point in trying to make a really good http auth protocol as SSL has to be used anyway
14:48:12 <dibblego> oh ok sorry
14:48:21 <mm_freak> johnw: those represent 'safe' operations
14:48:29 <dcoutts> Hadaka: digest auth can do integrity protection
14:48:30 <johnw> like, if I had a database query which results in a list of strings, and I wanted to hand it to a function to execute based on an query term, could I use a comonad for this, since it's providing context that gets evaluated to yield a value??
14:48:32 <spark__> i want to install fftw, but it refuses because idk how to say to pkg-manager it was installed
14:48:36 <mm_freak> for a monad it's always 'safe' to map into the monad
14:48:41 <dibblego> latro`a: I was just talking about a list zipper, but there are many more comonads (I use Store comonad almost daily)
14:48:44 <mm_freak> for a comonad it's always 'safe' to map out of the monad
14:49:09 <Hadaka> dcoutts: eh? digest auth protecting the sent / received data?
14:49:16 <dcoutts> Hadaka: yes
14:49:36 <jfischoff> how does one fix the Bad interface file: .. errors cabal-dev seems to get on a regular basis?
14:49:53 <dcoutts> Hadaka: as far as I can see, if they switched the digest algorithm from being md5 to something sensible, and if browsers supported http auth methods properly in their UI it could be a pretty good system
14:50:04 <MagneticDuck> grr.. cabal is annoying me
14:50:09 <mm_freak> s/monad/comonad/
14:50:11 <MagneticDuck> it seems that I messed some packages up
14:50:11 <ivan> digest auth is trivially MITMed
14:50:18 <dcoutts> Hadaka: many use cases don't need privacy, just authentication and integrity checking
14:50:25 <MagneticDuck> I reinstalled a package..
14:50:25 <mm_freak> s/cocomonad/comonad/
14:50:28 <MagneticDuck> no error
14:50:36 <MagneticDuck> and then, I can't import the package in my code!
14:50:40 <MagneticDuck> or in ghci
14:50:44 <thirsteh> dcoutts: call me when browsers support key derivation with e.g. scrypt for digest auth
14:50:45 <MagneticDuck> what could be going wrong?
14:50:46 <johnw> mm_freak: what about the database question?
14:50:46 <Hadaka> dcoutts: I haven't ever heard of digest auth being used for intergrity protection? and I'm having a hard time seeing how it could even
14:50:52 <dibblego> @tell edwardk newtype CoproductT f x y a = CoproductT (EitherT f (x a) (y a)) -- is this out there somewhere (any language)?
14:50:52 <lambdabot> Consider it noted.
14:50:54 <mm_freak> (s/monad/comonad/, s/cocomonad/comonad/…  that almost sounds like a monad in its own right, lol)
14:51:20 <mm_freak> johnw: i missed that one
14:51:29 <MagneticDuck> also, how do I completely remove a cabal package from my machine?
14:51:33 <Hadaka> dcoutts: and in any case, replacing md5 doesn't help unless the hash in digest auth is made a slow one - otherwise it's too trivial to brute force
14:51:34 <johnw> mm_freak: if I had a database query which results in a list of strings, and I wanted to hand it to a function to execute based on an query term, could I use a comonad for this, since it's providing context that gets evaluated to yield a value?
14:51:46 <sheldonh> i'm still not getting the hang of "Couldn't match type `a' with `[a]'" for functions that take function arguments. could anyone help me understand this error message? http://fpaste.org/Bdbg/
14:52:01 <johnw> or can I not map the query term into the query object because that would be unsafe?
14:52:10 <thirsteh> Hadaka: the client can use a KDF
14:52:11 <dcoutts> Hadaka: see "auth-int". Yes, agree about the digest algorithm, but that should be easy to fix.
14:52:15 <Hadaka> if digest auth would cover the sent body of the request, that would mean that a 1 gigabyte PUT request would have to be buffered in memory so that its hash could be calculated before sending
14:52:26 <MagneticDuck> btw, my package doesn't export any programs
14:52:29 <thirsteh> dcoutts, Hadaka: yet no browsers support any such facility
14:52:43 <latro`a> sheldonh, the problem is that ++ takes two lists
14:52:49 <latro`a> your x is the wrong type to be ++'d
14:52:58 <mm_freak> johnw: a comonad is about manipulating "by looking at the big picture", which is encoded in the type of (=>>)
14:53:02 <thirsteh> Hadaka: that's not how HMAC's work
14:53:02 <latro`a> but you should almost never append
14:53:08 <latro`a> as n appends is O(n^2)
14:53:10 <mm_freak> (=>>) :: (Comonad w) => w a -> (w a -> b) -> w b
14:53:17 <dcoutts> Hadaka: yes, you don't necessarily want to use it all the time. For example for hackage, you'd only need it for uploads. All the GETs are public anyway.
14:53:19 <latro`a> always prepend
14:53:26 <latro`a> reverse at the end if really needed
14:53:27 <dibblego> or if you prefer: w a -> w (w a) (and fmap)
14:53:31 <sheldonh> latro`a: hmmm. okay, back to the drawing board. thanks :)
14:53:45 <MagneticDuck> ah, I used ghc-pkg unregister
14:53:46 <Hadaka> thirsteh: no, but that's how HTTP works - you can't send headers after the body
14:53:50 <johnw> mm_freak: how does that apply to the database query example?
14:54:01 <thirsteh> Hadaka: yes you can. It's called trailers. But no browsers support them.
14:54:08 <mm_freak> johnw: the point is to find out /whether/ it applies =)
14:54:11 <latro`a> sheldonh, if you replace x with [x], that will compile and should do the right thing
14:54:14 <latro`a> but *slow*
14:54:16 <latro`a> very slow
14:54:17 <johnw> mm_freak: ok, you're not helping
14:54:30 <MagneticDuck> gaah
14:54:36 <MagneticDuck> I uninstalled the package
14:54:39 <dibblego> johnw: yes he is, by guiding you to ask the right question
14:54:39 <mm_freak> johnw: i'm trying to…  the problem is that i don't have insight into your query type
14:54:40 <sheldonh> latro`a: yeah, when i did it, i knew it sucked. probably a reverse at the end is the way to go. thanks again
14:54:41 <Hadaka> tridactyla: heh, did not know that
14:54:43 <MagneticDuck> with ghc-pkg unregister
14:54:46 <MagneticDuck> and reinstalled it
14:54:54 <MagneticDuck> but I still can't access its exposed modules
14:54:59 <johnw> dibblego: I'm not getting what he's guiding me toward; I'm not able to think about this in the abstract yet
14:55:02 <dibblego> johnw: incidentally, the question you asked fits a problem I am solving at this moment, where I use both monad and comonad (and more)
14:55:24 <mm_freak> johnw: ok, let me ask:  if you have a 'Query a', is it always safe to turn it into an 'a'?
14:55:30 <dcoutts> Hadaka, thirsteh: right, my gripe is really that http auth is unloved by the browsers and frameworks but could be improved to be good if only they cared
14:55:33 <latro`a> sheldonh, have you looked at how (++) is defined, and hence why it's O(n) where n is the length of the left argument?
14:55:35 <MagneticDuck> the module builds fine, without any errors btw
14:55:45 <Hadaka> but then the situation is reversed - the server needs to store the 1 gigabyte PUT in a temporary location before it can authenticate it and start processing it...
14:55:49 <mm_freak> johnw: purely that is, i.e. using a function of type Query a -> a
14:55:49 <dibblego> johnw: I prefer using a problem that you (any student) is almost certainly familiar with, then showing how comonad fits that problem
14:55:58 <MagneticDuck> any help guys?
14:56:10 <dibblego> I really hate point/copoint in these explanations :(
14:56:19 <dcoutts> Hadaka: on uploads that's not really a problem. Stream it into a file, when it's done then process it.
14:56:47 <thirsteh> dcoutts: totally agree. It's a shame they don't. Client-side KDFs and/or SRP/other proof would have prevented most of the recent digest leakage catastrophes
14:56:59 <Hadaka> if there could be authenticators on each chunk of a chunked transfer, that would actually be useful
14:57:35 <sheldonh> latro`a: yeah. i've done my own implementation of (++) too. it sucks :)
14:57:43 <thirsteh> Hadaka: that's the same regardless of the transport protocol, though
14:57:44 <johnw> dibblego: yes, a concrete example that is not about streams or dataflow is what I need
14:58:01 <johnw> dibblego: I get the difference between safe and unsafe, but I don't see how it relates to a real problem yet
14:58:02 <dcoutts> anyway, it's a lot easier to implement digest auth than ssl in both cabal-install and the hackage-server, and a step up from http basic auth
14:58:04 <dibblego> johnw: I'm not sure what "streams" or "dataflow" mean to you
14:58:07 <thirsteh> Hadaka: you could conceivable encode HMACs in a chunked HTTP body
14:58:11 <thirsteh> conceivably
14:58:12 <johnw> dibblego: that's just it, they mean very little :)
14:58:24 <Hadaka> thirsteh: but isn't that down to just using bad hash algorithms? SRP is still vulnerable to "digest" leakage and digest leakage is how all of the exploits have been
14:58:25 <johnw> dibblego: but all the literature I can find gives stream computations as the only example
14:58:30 <mm_freak> johnw: again, can you write a total function of type Query a -> a?
14:58:33 <dibblego> newtype Store a b = Store (a -> b) a -- here is a comonad (Store a)
14:58:40 <johnw> mm_freak: what is a "total function"?
14:58:50 <mm_freak> johnw: a function that does not go bottom
14:58:50 <dibblego> johnw: one that computes a result, always
14:59:09 <thirsteh> Hadaka: SRP protects against eavesdropping attacks. KDFs protect against dictionary attacks against the digest. People say SRP is vulnerable, but SRP was never meant to have hardened verifiers
14:59:20 <johnw> If it's Query [String], yes
14:59:28 <mm_freak> johnw: without the "if"
14:59:31 <johnw> is that a query that yields a list of strings as a result?
14:59:32 <thirsteh> Hadaka: so what you want is client-side key derivation and some kind of public-key authentication/ZKPP
14:59:38 <dibblego> johnw: haskell uses lower-case type variables to mean "forall"
14:59:53 <thirsteh> Hadaka: the reason TLS-SRP is good is that it provides mutual authentication
14:59:54 <johnw> oh, I see what you mean
14:59:58 <mm_freak> johnw: can you write a total function of type:  forall a. Query a -> a
15:00:10 <johnw> can I define a Query a type that is total forall a
15:00:15 <mm_freak> yes
15:00:28 <mm_freak> if not, then it's certainly not a comonad
15:00:35 <johnw> no, as some queries are empty, which may not be representable in a
15:00:42 <thirsteh> Hadaka: but, you guessed it, no browsers support it :)
15:00:47 <Hadaka> thirsteh: by client side key derivation do you mean key derivation which isn't entirely password based?
15:00:50 <latro`a> then you don't have a coreturn
15:00:50 <mm_freak> johnw: [4~then scratch comonads =)
15:00:54 <johnw> how about MaybeQuery
15:00:55 <latro`a> which means you don't have a comonad
15:01:03 <johnw> oh, still has to yield an a
15:01:04 <mm_freak> johnw: same question
15:01:08 <johnw> not a Maybe a
15:01:15 <mm_freak> johnw: the type is Query a -> a, not Query a -> Maybe a
15:01:17 <johnw> ok, that actually really helps mm_freak
15:01:18 <sheldonh> latro`a: you reckon two reverses at the end is worth the loss of readability of filtering twice?
15:01:27 <johnw> thank you
15:01:31 <johnw> for sticking with me
15:01:32 <latro`a> two reverses at the end is probably about the same pace as two filters
15:01:35 <latro`a> but
15:01:44 <mm_freak> you're welcome =)
15:01:45 <dibblego> there are many useful data types and operations which have extend but not copoint
15:01:46 <latro`a> the version in Data.List doesn't reverse
15:02:06 <latro`a> (it's actually a really neat idea, as it happens)
15:02:10 <latro`a> (the way Data.List does it)
15:02:12 <johnw> what happens with finite streams, though?  What if the stream is empty, then what is a?
15:02:21 <dibblego> johnw: [] is not a comonad
15:02:21 <sheldonh> latro`a: yeah, buti can't read it yet, 'cause i haven't gotten to tilde :)
15:02:24 <thirsteh> Hadaka: no, I mean a key/password that is stretched on the client terminal before being sent over the wire. You can use that with SRP to prove that you know the derived key without sending it (or you can just use TLS)
15:02:27 <mm_freak> johnw: the stream comonad is never empty
15:02:36 <dibblego> johnw: newtype NonEmptyList a = N a [a] -- this is though
15:02:37 <latro`a> sheldonh, ~ just means it lazily binds the pattern
15:02:51 <latro`a> (more or less)
15:03:00 <MagneticDuck> anyway.. my question is back
15:03:05 <MagneticDuck> I made a package
15:03:07 <johnw> and how about Store?
15:03:09 <MagneticDuck> that exports a single module
15:03:10 <dibblego> newtype ListZipper a = Z [a] a [a] -- and this
15:03:13 <johnw> is the Store never exhausted?
15:03:16 <MagneticDuck> it's only on my machine
15:03:18 <dibblego> yes (Store a) is a comonad
15:03:18 <mm_freak> johnw: extract (Store f x) = f x
15:03:26 <MagneticDuck> when I run "cabal install", it installs fine
15:03:27 <dibblego> johnw: try writing fmap+extract+copoint for it
15:03:28 <mm_freak> that's total, as long as 'f' is total
15:03:29 <johnw> how is that different from Reader?
15:03:37 <MagneticDuck> but then, I can't load it in ghci or my code
15:03:42 <MagneticDuck> what could be going wrong?
15:03:49 <Hadaka> thirsteh: okay, my point is that if the server database is leaked - and the client doesn't get any more input than just the password - then that will always allow for bruteforce offline attacks against the client password
15:03:50 <dibblego> Reader a b = a -> b, Store a b = (a -> b, a)
15:04:03 <mm_freak> johnw: think of arrays…  store comonads are a generalization of indexed arrays
15:04:08 <johnw> hmmm
15:04:18 <johnw> i think a neuron just broke
15:04:20 <Hadaka> thirsteh: so the only protection against this is to use slow hash functions, regardless of SRP, ZKPP, etc.
15:04:29 <thirsteh> Hadaka: I think you're missing my point
15:04:32 <thirsteh> Hadaka: I'm saying use both
15:04:41 <mm_freak> johnw: you can always represent an array as a function
15:04:56 <MagneticDuck> x| everyone's ignoring me
15:05:05 <MagneticDuck> I should probably do some research
15:05:07 <mm_freak> johnw: the array [2, 5, 1] can be represented as:  f 0 = 2; f 1 = 5; f 2 = 1
15:05:29 <johnw> mm_freak: so whereas an array in the Reader monad would apply that whole array to all functions bound over it, the Store monad can yield a value at a given index, with that index being adjustable?
15:05:50 <mm_freak> johnw: yes, but the adjusting is outside the scope of Comonad
15:06:01 <mm_freak> johnw: but now consider cobind alias (=>>)
15:06:15 <johnw> so are there uses of Store and Reader that would appear identical?
15:06:28 <dibblego> sure, they both have fmap
15:06:30 <mm_freak> (=>>) :: Store e a -> (Store e a -> b) -> Store e b
15:06:39 <dibblego> fmap (+1) -- this will work on both Reader and Store
15:06:41 <mm_freak> look at the type of the second function
15:06:46 <sheldonh> latro`a: aha. foldr. i keep forgetting that there *is* a way to work back from the end of a list :)
15:06:48 <mm_freak> the second argument i mean
15:06:57 <mm_freak> it is applied all over generating the resulting store
15:06:58 <sheldonh> latro`a: maybe i should implement foldr next ;)
15:07:04 <thirsteh> Hadaka: A simple example: client generates a salt and digest; server never sees the password, but stores the salt and digest, sends the salt to the client before it stretches the key (so you can switch clients without problems), and checks that it matches the digest it has stored. All this is done over TLS so the client knows it's talking to the server. Alternatively, you could do it over TLS-SRP, in which case both parties prove their
15:07:05 <thirsteh>  identity to each other
15:07:07 <Hadaka> thirsteh: sure, it's good to have both - I'm just saying that using good KDFs would've "protected" against the digest leakage catastrophes specifically, and that SRP is only relevant if you are concerned about the other attack modes
15:07:11 <johnw> ah, hmm
15:07:11 <dmwit> MagneticDuck: What does ghc-pkg list <yourpackagename> say?
15:07:16 <mm_freak> that gives the function the ability to "look at the big picture" while constructing the output
15:07:23 <mm_freak> think of applying a blurring filter to an image
15:07:23 <johnw> (one sec, on the phone, brb)
15:07:24 <latro`a> I don't really think of foldr as working from the back
15:07:26 <dibblego> sheldonh: this might help https://github.com/tonymorris/course it has all the exercises you have mentioned so far
15:07:48 <thirsteh> Hadaka: I never said otherwise :)
15:07:49 <latro`a> in a way foldr is more front-y than foldl, in that it may only inspect the head
15:08:09 <dmwit> MagneticDuck: (Perhaps you installed to another user's local repository -- say, root's.)
15:08:20 <MagneticDuck> perhaps
15:08:23 <MagneticDuck> I have "user-install: False"
15:08:29 <dibblego> foldr f z x replaces every (:) in x with f and [] with z, I recommend against thinking about fronts, backs, lefts, rights
15:08:30 <MagneticDuck> and I don't run it with su
15:08:36 <MagneticDuck> I'm using linux
15:08:44 <mm_freak> foldr is /the/ fold for lists
15:08:44 <dmwit> MagneticDuck: Well, my question stands, then: what's ghc-pkg list <yourpackagenmae> say?
15:08:52 <Hadaka> thirsteh: but you were pushing for usage of SRP using digest leakages as a reason, even though SRP does not protect against those
15:08:57 <mm_freak> foldl isn't really a fold, because it doesn't have an identity
15:09:06 <mm_freak> foldr (:) [] = id
15:09:07 <MagneticDuck> dmwit: sorry, I didn't see your question
15:09:16 <MagneticDuck> say my name :P
15:09:24 <MagneticDuck> I was working on something else
15:09:24 <dmwit> MagneticDuck: (I did.)
15:09:26 <MagneticDuck> let me see...
15:09:28 <MagneticDuck> oh
15:09:30 <thirsteh> Hadaka: no, I said KDFs and SRP
15:09:36 <shachaf> I,I foldr :: (Maybe (a,b) -> b) -> [a] -> b
15:10:01 <MagneticDuck> that's weird
15:10:08 <MagneticDuck> even after unregistering it
15:10:14 <MagneticDuck> it's still installed
15:10:17 <MagneticDuck> ~_~
15:10:21 <johnw> back
15:10:23 <ahkurtz> is there any way to make something like `last $ reverse [1..]` finite?
15:10:32 <MagneticDuck> unregistered
15:10:33 <dmwit> ahkurtz: Sure!
15:10:35 <MagneticDuck> gah
15:10:41 <dmwit> > last $ reverse [1..] :: Word8
15:10:42 <lambdabot>   1
15:10:48 <ahkurtz> haha
15:10:57 <gwern> are we discussing hackage security? I have a suggestion: whatever debian does, let's do it
15:11:03 <mm_freak> ahkurtz: not if you want the number type to stay polymorphic
15:11:14 <Hadaka> thirsteh: heh, had to go check :) you said and/or :)
15:11:14 <ahkurtz> this is over my head.
15:11:24 <mm_freak> ahkurtz: you're saying [1..] there
15:11:24 <thirsteh> gwern: debian signs packages. You can't do that if random people can check in packages
15:11:34 <ahkurtz> what is different about it if it knows the type more specifically?
15:11:45 <gwern> thirsteh: that is an issue...
15:11:47 <ahkurtz> is it just polymorphism or is it actually the word8 that makes the diff?
15:11:47 <mm_freak> ahkurtz: the '1' is of type (Num a) => a, which may be Integer
15:11:47 <johnw> so, in the Reader monad each bound function receives the context-value from the Monad, but must return a new monad; but in the Store monad each bound function receives the Comonad and returns a value.  Interesting.
15:11:50 <MagneticDuck> well, what should I do, dmwit?
15:11:52 <dmwit> ahkurtz: Oh, I just picked a type that I happened to know was finite (and had a small upper bound).
15:12:09 <dmwit> MagneticDuck: I don't know. What's the current top-level problem?
15:12:10 <johnw> I wonder how Store relates to Comonad.Reader
15:12:10 <mm_freak> ahkurtz: for Integer there is no way for last . reverse to result
15:12:21 <dmwit> > last [1..] :: Word8
15:12:22 <lambdabot>   255
15:12:23 <thirsteh> Hadaka: look, I'm not saying SRP protects against offline attacks. The first thing I said about SRP is that it was designed to protect against eavesdropping/online attacks. KDFs protect against offline attacks. Therefore you should use both.
15:12:26 <ahkurtz> I think I see it
15:12:38 <thirsteh> Hadaka: I'm tired of people dissing SRP as being "inferior" to KDFs when it solves an entirely different problem
15:12:41 <Mon_Ouie> Is there any standard function to insert the elements of a list at an arbitrary position within another list? (like this: http://hpaste.org/73800)
15:12:56 <dibblego> johnw: Lens a b = a -> Store b a -- Store provides the set/get pair
15:12:58 <shachaf> Mon_Ouie: No.
15:13:04 <Clint> thirsteh: why is that less possible than password management?
15:13:07 <shachaf> Mon_Ouie: The reason is partly that it's often the wrong thing to want.
15:13:09 <dibblego> Mon_Ouie: no, there is a data structure called a list zipper though
15:13:11 <MagneticDuck> Mon_Ouie: use the "split" function
15:13:13 <MagneticDuck> @type split
15:13:14 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
15:13:18 <Hadaka> thirsteh: I'm not dissing SRP as being inferior - I'm just saying that it wasn't *relevant* - good KDFs have to be used, SRP or not
15:13:19 <MagneticDuck> aa
15:13:20 <dmwit> :t splitAt
15:13:20 <mm_freak> johnw: btw, there is no store monad
15:13:21 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:13:21 <MagneticDuck> no
15:13:23 <MagneticDuck> I can't remember what it's called
15:13:26 <MagneticDuck> yes
15:13:31 <johnw> well, I'm going to have to keep working at this
15:14:00 <thirsteh> Hadaka: for the third time, I don't disagree with you :) You should use both.
15:14:05 <Hadaka> SRP is a great protocol when you can't verify the server fingerprint
15:14:07 <johnw> i think I need some working code that actually makes compelling use of Store (other than Lens, which is later on my list for grokkage)
15:14:25 <Mon_Ouie> I guess I shoudl read about zipper. What I was trying to do was, insertingg ansi escape codes around certains characters in a string.
15:14:31 <Hadaka> thirsteh: I think, unfortunately, we'll just have to agree to agree
15:14:37 <mm_freak> johnw: use picture processing as an example
15:14:38 <dibblego> johnw: you probably reinvent it all the time — at least, I watch a lot of my colleagues do this then I just say "Store"
15:15:00 <johnw> dibblego: ooh, can you give me an example?  Of the code before, and the code after using Store?
15:15:03 <mm_freak> johnw: the store comonad is amazing for pixmap filters
15:15:06 <thirsteh> Hadaka: So you don't like TLS either?
15:15:37 <johnw> I suppose a file's contents are just a Store?
15:15:41 <Hadaka> thirsteh: now you I think you are assuming I said or meant something I didn't
15:15:43 <mm_freak> johnw: whenever you iterate over an array to create a new array you're using a convoluted store comonad =)
15:15:58 <dibblego> johnw: not really off-hand, but suppose you have a data structure that is the same as Store (but maybe not polymorphic), then you write a helpful method which is the equivalent of (<<=) then you start writing the comonad library on top and then … I come along and say "Store"
15:16:12 <johnw> mm_freak: to date I have only used Lists and Maps in Haskell, not Arrays
15:16:38 <thirsteh> Hadaka: Maybe I'm not making myself clear. You don't have to use _SRP_, you should client-side key stretching AND something which provides a proof like SRP, e.g. public key exchange
15:16:54 <thirsteh> Hadaka: that might be SRP; it might be TLS.
15:17:06 <mm_freak> johnw: data Store s a = Store (Map s a) s
15:17:08 <latro`a> minus errors, constraints, and the actual underlying data structure, Map and Array aren't that different
15:17:12 <thirsteh> SRP provides mutual authentication, TLS doesn't (unless you issue client certificates)
15:17:33 <johnw> mm_freak: ok, what would a use of that map mean?
15:17:53 <johnw> am I setting the "key" for the value to be inspected on =>>?
15:17:54 <mm_freak> johnw: well, there is the easy one:  extract :: Store s a -> a
15:17:59 <thirsteh> Clint: It's not. I just mean that just because Debian's packages are safe because they're signed doesn't mean Hackage's would be
15:18:13 <thirsteh> Clint: Debian has a few gatekeepers that can be trusted, so it works for them
15:18:14 <Hadaka> thirsteh: I am not disagreeing either, if you read my message correctly
15:18:16 <johnw> ok, let me try implementing Map as a comonad
15:18:30 <thirsteh> Hadaka: you JUST said "I guess we'll have to agree to disagree"
15:18:43 <armlesshobo> lol
15:18:47 <mm_freak> johnw: the interesting one is (=>>), where you construct a new store from the old…  given s =>> f the function 'f' is used at every index of the result
15:18:50 <thirsteh> Hadaka: oh, agree to agree. Haha
15:18:55 <ezyang> What is the moral difference between "desugaring" and "denotational semantics"?
15:18:57 <thirsteh> Hadaka: well, I'm confused enough for both of us now
15:19:01 <Hadaka> "Hadaka:#haskell => thirsteh: I think, unfortunately, we'll just have to agree to agree"
15:19:15 <thirsteh> Hadaka: alright then.
15:19:15 <Hadaka> I was just trying to be funny :)
15:19:27 <mm_freak> johnw: the key is to make the index of the function's argument point to the result index
15:19:32 <johnw> mm_freak: every index of the *result*?
15:19:37 <mm_freak> yes
15:19:38 <thirsteh> Hadaka: I parsed that sentence too quickly :)
15:19:51 <johnw> wait, let me implement this comonad; what you said makes no sense to me yet
15:19:59 <dmwit> ezyang: I would say you normally don't include computational rules in a desugaring.
15:20:04 <mm_freak> johnw: Store is easier to define using a function:  data Store s a = Store (s -> a) s
15:20:11 <Hadaka> thirsteh: yeah, sorry for not putting a smiley on that line :)
15:20:15 <mm_freak> johnw: try that one first, before you try Map
15:20:29 <johnw> Store still makes no sense to me
15:20:35 <johnw> Map is something I have knowledge of
15:20:35 <mm_freak> johnw: think of (s -> a) as Map s a
15:20:44 <Hadaka> anyhow, on the topic of "hackage security suggestions from a random bloke"
15:20:51 <Clint> thirsteh: i thought you were talking about using a gpg sig to authenticate to hackage instead of a password
15:20:53 <mm_freak> johnw: they are the same thing, except that you get a result for every key, not just the ones in the map =)
15:21:19 <Clint> or rather i thought that's what gwern was talking about
15:21:28 <Hadaka> I think you should start from the other end - take hashes of all the packages, include those in package listings and have hackage sign all downloaded package lists - that's a start
15:21:40 <ezyang> dmwit: I would say that the denotation of an expression should not involve computation!
15:21:56 <Hadaka> then allow developers to upload a voluntary gpg key for uploads that prevents any further uploads from getting in unless signed by the key
15:22:29 <Hadaka> and then finally start worrying about getting all the devs to have good gpg keys with a web of trust and somebody confirming that they indeed are a real person
15:23:02 <dmwit> ezyang: Would you say that the transformation from an expression to its denotation should not involve computation?
15:23:15 <thirsteh> Hadaka, Clint: ah ok. I think GitHub's approach works fairly well for a "broad" audience. You add your public key in your account settings (which could be protected by two-factor auth), and use your private key to auth when pushing to your repositories
15:23:15 <Hadaka> none of this requires TLS ;-)
15:23:46 <thirsteh> Hadaka: There isn't really a good reason why people need to sign packages. Just have the server generate a SHA-256 digest when it's uploaded
15:24:16 <ezyang> dmwit: It could be expressed using something resembling computation, but it's not good form in mathematics to assume that just because you have a function, you also have a computation.
15:24:19 <Yiq> So I thought nosql and sql databases were basically for different use but a  lot of people are saying nosql(couch, mongo) is the way to go for webapps, dynamic applications. Why is it better(or is it? obv there must be stuff where each is better)?
15:24:27 <Hadaka> thirsteh: signing is there if the package delivery method is untrusted - perhaps via some intermediate staging servers, not always integrity protected, etc.
15:24:40 <Hadaka> thirsteh: if uploading directly to the repository over TLS, no signing is needed
15:24:48 <parcs`> Yiq: what does that have to do with haskell
15:24:54 <thirsteh> Hadaka: does Hackage have that? (I'm new to Haskell/Hackage)
15:25:04 <thirsteh> Hadaka: I just mean it's not necessary for Hackage, if I understand Hackage correctly
15:25:05 <Clint> hackage has next to zero security
15:25:21 <Hadaka> thirsteh: I have no idea, I know less of hackage than you do, probably
15:25:25 <Clint> it's like a wiki
15:25:33 <thirsteh> but it's centralized, right?
15:25:46 <Clint> yup
15:25:51 <dmwit> ezyang: So, is my claimed moral distinction clear or not?
15:26:02 <thirsteh> unless you want to validate the integrity of the package yourself, and you have the author's pubsig (from somewhere other than Hackage) there's no reason to sign it
15:26:36 <thirsteh> but indeed, for something like Debian which has a bunch of mirrors, it makes sense
15:27:15 <ezyang> dmwit: My understanding of the matter is you said that desugaring doesn't involve computation, and I claimed that denotational semantics don't involve computation either.
15:27:33 <dmwit> Okay, so it is not clear and I will try to be more precise.
15:28:23 <Dashkal> Hit a snag in a tutorial I'm following.  What do I need to lookup to understand what this does?: newtype Forall f = Forall { unforall :: forall a. f a }
15:28:45 <shachaf> Dashkal: Do you know what "forall" does?
15:29:00 <Dashkal> Vaguely only
15:29:07 <shachaf> You should understand that, then.
15:29:25 <Dashkal> googling "forall" isn't going to get me very far.  Can you suggest better terms to search for?
15:29:29 <Hadaka> thirsteh: signatures also provide some level of irrefutability and after-the-fact verification of packages - if, for example, hackage is compromised and compromise has been detected
15:29:50 <shachaf> @google mainisusuallyafunction forall
15:29:51 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/09/higher-rank-type-constraints.html
15:29:51 <hpc> Dashkal: https://en.wikipedia.org/wiki/Universal_quantification -- here's the wikipedia page
15:29:53 <shachaf> I think that post was good.
15:30:02 <thirsteh> Hadaka: sure
15:30:03 <Dashkal> danke
15:30:16 <Dashkal> yep, this looks promising
15:30:25 <hpc> probably won't teach you anything, but will give a frame of reference when reading other things
15:30:37 <Dashkal> hpc: wikipedia is what I'm trying to avoid.  I find wp pages tend to be written by math major for math majors.
15:30:54 <Dashkal> I lack the backround to understand the language they explain things in
15:31:06 <mm_freak> Dashkal: apropos promises…  i found 'forall' easy to understand by interpreting types as promises
15:31:08 <edwardk> preflex: xseen jfischoff
15:31:08 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:31:08 <preflex>  jfischoff was last seen on freenode/#haskell 41 minutes and 32 seconds ago, saying: how does one fix the Bad interface file: .. errors cabal-dev seems to get on a regular basis?
15:31:19 <mm_freak> Dashkal: f :: forall a. a -> a
15:31:22 <edwardk> jfischoff: universeOn Data.Data.Lens.biplate
15:31:23 <shachaf> forall is easy to understand if you think of types as arguments. :-)
15:31:31 <jfischoff> ah
15:31:33 <jfischoff> cool
15:31:37 <Hadaka> in debian, every debian devel key has been verified by other debian developers in a face to face meeting against some valid identification document, so the signatures actually carry some weight
15:31:38 <mm_freak> f "promises" that it can handle any type 'a', so the caller can choose the type
15:31:38 <Dashkal> Heh, I suppose if I get stuck now I can poke the author of said tutorial.  Hey, edwardk :)
15:31:51 <edwardk> i'll probably export the various fooBi combinators from Data.Data.Lens
15:32:11 <edwardk> johnw: costate isn't dual to state, hence costate is a terrible name ;)
15:32:12 <dmwit> One of the things I expect from a denotational semantics is some kind of proof of equality of terms that "look like computation": for example, a proof that the denotation of (\x. e) y is equal to the denotation of e [y/x]. I don't expect such proofs out of a desugaring, because I don't expect there to be meaningful rewrites of this kind.
15:32:13 <jfischoff> I'll have to check those out
15:32:15 <mm_freak> f :: (forall a. a -> a) -> Int
15:32:24 <mm_freak> the argument to 'f' has to "promise" that it can handle every 'a'
15:32:31 <Dashkal> *nods* I follow
15:32:31 <mm_freak> so the argument must be polymorphic in 'a'
15:32:33 <dmwit> I expect the desugaring to be obviously structurally recursive or similar, so that computation "can't happen".
15:32:36 <dibblego> edwardk: do you have CoproductT?
15:32:38 <edwardk> jfischoff: but basically anywhere you could use fooBi, just use fooOn biplate
15:32:55 <edwardk> dibblego: for comonad coproducts?
15:33:21 <edwardk> dibblego: Data.Functor.Coproduct is in comonad-transformers
15:33:24 <dibblego> CoproductT f x y a = EitherT f (x a) (y a)
15:33:38 * jfischoff is testing out the lens plate functionality
15:33:39 <edwardk> no
15:33:43 <ezyang> dmwit: OK, that makes sense. Follow up: what do you call desugaring that does have computational content?
15:33:47 <dibblego> edwardk: ok thanks
15:33:57 <ezyang> Alternatively, denotational semantics where the end denotation isn't a mathematical object.
15:34:03 <dmwit> I dunno. =P
15:34:04 <edwardk> dibblego: that is more of a random composition of simpler functors =)
15:34:20 <thirsteh> Hadaka: agreed, that's when it shines. threshold signature schemes are really sexy
15:34:24 <edwardk> jfischoff: great. i spent the day chasing after how to do polymorphic recursion for multiplates
15:34:43 <jfischoff> any progress?
15:34:45 <edwardk> basically i want to be able to do something multiplate like that can work in the presence of polymorphic recursion (e.g. bound)
15:34:49 <edwardk> some
15:34:55 <edwardk> two steps forward one step back all day
15:34:56 <thirsteh> Hadaka: (just as an aside; not implying that's what they use)
15:34:56 <dmwit> ezyang: Maybe just a rewrite system.
15:35:07 <Dashkal> mm_freak: Where I get lost is what it means when I lift that into a type.  Forall f.  Am I saying I have a functor that works for any type?
15:35:11 <dibblego> edwardk: I may drop the T
15:35:34 <Dashkal> Well, not even that was specified.  A type constructor that accepts any time.  Not seeing what changed
15:35:38 <Dashkal> type*
15:36:01 <mm_freak> Dashkal: if you write this in GADT notation it may be easier to understand
15:36:21 <mm_freak> Dashkal: Forall :: (forall a. f a) -> Forall f
15:36:36 <mm_freak> the argument to the Forall constructor must be polymorphic in 'a'
15:36:36 <ezyang> dmwit: OK, and then another follow up: are rewrite systems morally inferior to denotational semantics?
15:36:40 <jfischoff> edwardk: exciting either way :)
15:36:44 <dmwit> haha what
15:36:45 <ezyang> What if the thing you're rewriting to does have a denotational sematnics?
15:37:12 <Dashkal> I'm not entirely certain how I could provide it anything that wasn't.
15:37:22 <edwardk> i found i rather strongly disagree with ezyang on whether one of nested data types and gadt's wins though ;)
15:37:31 <mm_freak> Dashkal: Forall (Just 0) would not compile
15:37:35 <ezyang> edwardk: Ha!
15:37:37 <mm_freak> because 0 is not fully polymorphic
15:37:41 <edwardk> mostly after i spent hours beating on an initial algebra semantics are enough style traversal
15:38:10 <Dashkal> ok, now I have a feeling for what I'm missing.  So it would accept Forall Nothing?
15:38:16 <mm_freak> Dashkal: there is only one (total) way to construct a Forall Maybe
15:38:17 <mm_freak> yes
15:38:29 <LordBrain> is there a generally understood terminology closed kinds v open kinds?
15:38:31 <edwardk> jfischoff: i'm pretty flexible on changing around the plate stuff, since its still new, so if you see something that could stand to be improved, tell me
15:38:32 <mm_freak> Forall Nothing is the only thing it accepts, if you disallow bottom
15:39:08 <edwardk> expect to use the Of and On variables a lot though
15:39:14 <edwardk> er variants
15:39:30 <mm_freak> LordBrain: in lambda calculus a closed expression is an expression without free variables…  in that sense '*' is open and 'a' is closed
15:40:36 <byorgey> mm_freak: surely you meant the other way around.  * is closed and 'a' is open.
15:40:38 <Dashkal> ok danke.  Lesse if I can understand what was ment then.
15:40:48 <mm_freak> byorgey: "a" is forall a. a
15:41:00 <mm_freak> that one is certainly closed
15:41:15 <mm_freak> Dashkal: gerne =)
15:41:20 * dmwit feels a bit lost between type and kind levels
15:41:20 <byorgey> mm_freak: OK, fine, but * is closed too
15:41:32 <jfischoff> edwardk: Cool I'll let you know. How about if I add examples to the doc? I have a feeling I come up with any improvements for the api though.
15:41:38 <edwardk> please do
15:41:40 <dmwit> byorgey: Depends on whether you treat * as a variable name or part of the syntax, I guess.
15:41:57 <edwardk> also feel free to just add examples in the examples folder as well
15:42:04 <jfischoff> cool
15:42:05 <mm_freak> byorgey: i think * is open on the kind level the same way () is open on the type level and Nothing is open on the value level
15:42:07 <LordBrain> well i'm no clearer
15:42:07 <edwardk> all i have in there right now is a basic syntax tree
15:42:08 <byorgey> dmwit: I suppose it does depend on that.  But I am failing to come up with any reasonable scenario where you would interpret * as a variable name.
15:42:34 <LordBrain> i am reading http://hackage.haskell.org/trac/ghc/wiki/NewAxioms
15:42:37 <byorgey> mm_freak: wat
15:42:51 <byorgey> closed = no free variables, right?
15:42:54 <dmwit> Wouldn't it be fine to treat * and (->) as variables referring to GHC's (global) initial environment?
15:42:55 <mm_freak> yeah
15:42:56 <LordBrain> "For closed kinds (and maybe for open ones, but I can't unravel it), it seems possible to write a set of equations that will catch all possible cases but doesn't match the general case."
15:42:59 <byorgey> so where are the free variables in () and Nothing?
15:43:01 <LordBrain> that's the context
15:43:19 <mm_freak> byorgey: () and Nothing are free variables…  they refer to stuff defined elsewhere
15:43:24 <dmwit> () is a variable name, defined by the environment data () = ()
15:43:26 <edwardk> jfischoff: class Template a b where data Plate a b :: (* -> *) -> *; template  :: (forall c d. Part a b c d -> c -> f d) -> Plate a b f; monoplate :: (a ~ b) => (forall c. Simple Part a c -> c -> f c) -> Plate a b f; replate :: (Applicative f, a ~ b) => Plate a b f -> Plate a b f; unplate :: Applicative f => Plate a b f -> a -> f b -- was one design i kicked around for multiplate
15:43:43 <byorgey> ohhhh
15:43:56 <mm_freak> byorgey: in a strict lambda calculus sense you would have a context and () and Nothing would be part of it
15:44:07 <byorgey> this is confused by the fact that there are two different kind of variables here.
15:44:12 <mm_freak> byorgey: whether * is also a free variable is controversial, because * is always in the context
15:44:18 <byorgey> a type variable like 'a' is not the same as a "variable" like () or Nothing
15:44:30 <byorgey> ok, I see now.
15:44:32 <dmwit> Oh, yes. Very true.
15:44:40 <mm_freak> byorgey: it's only one kind of variable, but * is never out of context
15:44:48 <hpc> mm_freak: i would say * is a global kind-level constant
15:44:56 <edwardk> jfischoff: instance Template (Either a b) (Either c d) where data Plate (Either a b) (Either c d) f = EitherPlate { _left :: a -> f c, _right :: b -> f d }; template f  = EitherPlate (f _left) (f _right); monoplate f = EitherPlate (f _left) (f _right); unplate (EitherPlate l _) (Left a) = Left <$> l a; ...  would be a trivial example
15:45:04 <mm_freak> hpc: what's that?
15:45:17 <edwardk> bit dense for a single irc line i admit ;)
15:45:24 <byorgey> mm_freak: a variable that is always in scope =)
15:45:37 <latro`a> instance with a data declaration
15:45:39 <latro`a> I don't even
15:45:41 <johnw> mm_freak: I have been working at this, and still have no idea how to connect a Store and a Map
15:45:41 <mm_freak> byorgey: then it's yet another variable =)
15:45:45 <johnw> type MapStore k v = Store (Map k) v?
15:45:51 <dmwit> latro`a: associated types (and datas)
15:45:52 <jfischoff> edwardk: I copied it :)
15:45:56 <edwardk> @hpaste
15:45:56 <lambdabot> Haskell pastebin: http://hpaste.org/
15:45:58 <johnw> how do I create one of those?  how do I use it?
15:46:04 <mm_freak> lambda calculus doesn't have a notion of "constants"…  you could arbitrarily define them as being always-in-context variables
15:46:05 <dmwit> latro`a: ...are the Google terms, if you want to know more
15:46:15 <mm_freak> or
15:46:19 <hpaste> edwardk pasted “templates” at http://hpaste.org/73804
15:46:19 <mm_freak> always-in-starting-context
15:46:28 <latro`a> ah right
15:46:29 <latro`a> that
15:46:30 <latro`a> k
15:46:46 <jfischoff> oh cool
15:47:03 <edwardk> johnw: how well do you understand store?
15:47:08 <johnw> not at all
15:47:11 <johnw> zero
15:47:16 <edwardk> ok, lets start at the top =)
15:47:22 <edwardk> lets do something simpler first
15:47:26 <johnw> how do I use a store?
15:47:34 <johnw> ok
15:47:43 <johnw> (cabal install edwardk must have finished)
15:47:44 <edwardk> have you used any comonads yet?
15:47:46 <johnw> no
15:47:55 <dolio> What formulation of the lambda calculus are you talking about?
15:47:55 <johnw> that's the goal of this exercise
15:48:03 <byorgey> mm_freak, LordBrain: anyway, this is all irrelevant, because after looking at the page LordBrain referenced I realized that the "open/closed" there means something completely different
15:48:04 <edwardk> ok, lets do a couple of other comonads first. i'll let you define them as we go
15:48:10 <johnw> ok
15:48:18 <edwardk> then i'll have you think through a comonad for image manipulation that will motivate store
15:48:26 <edwardk> but first
15:48:32 <dolio> Pure type systems definitely have constants, and * isn't just a thing sitting in some context.
15:48:33 <edwardk> lets define a comonad for (,) e
15:48:35 <byorgey> LordBrain: in particular a kind is closed if it has a fixed set of types inhabiting it
15:48:43 <edwardk> for that we need two operations, extract and extend, right?
15:48:48 <Dashkal> ok, I'm doing something horribly wrong.  I'm trying to derive [] from Free and (,) but I'm getting an error I cannot follow: http://hpaste.org/73805
15:48:48 <byorgey> LordBrain: and open if new inhabitants can always be added
15:48:52 <edwardk> extract :: (e,a) -> a
15:48:53 <johnw> ok, defining
15:48:56 <edwardk> i leave that one to you
15:49:02 <byorgey> LordBrain: so * is open because you can always create new types of kind *
15:49:12 <johnw> extract = snd
15:49:23 <byorgey> but a promoted type is closed because it is inhabited only by its promoted data constructors
15:49:23 <edwardk> extend :: ((e,a) -> b) -> (e,a) -> (e,b)
15:49:40 <byorgey> ok, have to go put my son to bed, back in a bit
15:50:02 <dolio> And the traditional formulation of System F doesn't have * at all.
15:50:16 <dolio> But I expect F_omega would have it as a constant.
15:50:26 <mm_freak> johnw: which version of the comonad library are you using?
15:50:26 <LordBrain> um
15:50:32 <dolio> Same with the function connective.
15:50:41 <dolio> Not just a free variable.
15:50:42 <LordBrain> ok byorgey... but then aren't all kind's open?
15:50:50 <sheldonh> it's a little creepy how many Data.List functions can be defined without using the others, and how few can be defined without recursion :)
15:51:00 <edwardk> johnw: let me know when you have extend worked out
15:51:14 <johnw> almost there
15:51:22 <edwardk> no rush
15:51:39 <latro`a> sheldonh, probably almost all of them *could* be defined using foldr
15:51:43 <latro`a> but the result would be kinda obfuscated
15:52:57 <sheldonh> latro`a: in the haskell source for these things, a lot of them are implemented as folds :)
15:52:58 <johnw> extend f (e,a) = (e, f (e,a))?
15:53:03 <dmwit> Dashkal: Tricky question: what are the types of "a" and "as" on line 31?
15:53:04 <edwardk> johnw: yep
15:53:09 <dmwit> Dashkal: Hint: "as" is a bad name for this. =)
15:53:11 <edwardk> lets clean that up by naming the pair
15:53:15 <navaati> extent f t@(e,_) = (e,f t)
15:53:20 <___d> Anybody familiar with a package that provides HTTP form parsers? (Similar to yesod-form, but not dependent on yesod-core.)
15:53:23 <edwardk> yep
15:53:26 <dmwit> uh
15:53:29 <navaati> doh, too slow :)
15:53:31 <dmwit> Dashkal: Second hint: ignore me
15:53:48 <Dashkal> dmwit: I was expecting a to be (), and as to be FL a (the names were from a previous iteration where I was going for NEL)
15:53:49 <mm_freak> ___d: there are many
15:53:51 <edwardk> great. you've just defined your first comonad. lets give it a couple of operations
15:54:03 <edwardk> ask :: (e, a) -> e
15:54:06 <johnw> (be back in one sec)
15:54:11 <mm_freak> ___d: the classic one is digestive-functors, but there is also the newer and more powerful 'reform' package
15:54:20 <navaati> the Reader comonad ?
15:54:24 <Dashkal> erm, no, that's wrong.  a should be a, and as should be FL a
15:54:25 <edwardk> and local :: (e -> e) -> (e,a) -> (e,a)
15:54:40 <___d> mm_freak: thanks!
15:54:54 <Dashkal> meh, as you can tell, I'm getting a little lost in the types
15:54:54 <edwardk> navaati: yes, though as it isn't dual to reader so its not coreader, and it plays a rather different role, in comonad-transformers its the Env comonad.
15:55:02 <Dashkal> hence the admission I'm doing something terribly wrong :PO
15:55:07 <edwardk> basically its the comonadyou get for adding an 'e' to the environment.
15:55:08 <mm_freak> ___d: if you're using happstack, go with 'reform'…  for snap you probably want to use digestive-functors for now
15:55:46 <edwardk> a reader plumbs through the demand for an e through a monadic computation. the environment comonad is just a value with something else you can easily forget.
15:56:03 <dmwit> Dashkal: Okay, here's my second attempt at a hint: when writing map for lists, we expect map to call itself.
15:56:07 <___d> mm_freak: actually working on hails, but thanks for the heads up
15:56:20 <navaati> oh, i see : in the reader monad, the env is to be supplied later, right ?
15:56:26 <dmwit> Dashkal: Does the fmap you wrote call itself? (Is the fmap it calls using the fmap from FL or from Free?)
15:56:32 <Dashkal> yes.  that was the intent with the fmap.... am I forgetting some type bookeeping here?
15:56:35 <edwardk> navaati: yeah, while in the comonad its there all along
15:57:09 <navaati> (since haskell is lazy it looks like there is not much difference, but well…)
15:57:40 <edwardk> so we can make lots of comonads of this sort, and they are quite useful. for instance Snaplet is basically just an environment comonad that carries the snaplet configuration
15:57:59 <mm_freak> i think the reader comonad is easiest to understand, but also the least useful
15:58:00 <edwardk> i can have a data Named a = Named String a  -- which is just a comonad for named values where i can easily extract to forget the name
15:58:17 <dmwit> Dashkal: I believe you are forgetting some type bookkeeping here, yes.
15:58:21 <edwardk> mm_freak: sure. just starting with it because its the simplest and deriving it is trivial ;)
15:58:33 <edwardk> and i'm waiting for johnw to get back before i introduce the next one
15:58:39 <mm_freak> edwardk: i know your notion of "trivial" =P
15:58:51 <Dashkal> ok, time to explore closer
15:59:21 <mm_freak> edwardk: btw, i investigated comonadic FRP, but didn't find it useful
15:59:32 <mm_freak> applicative FRP seems much nicer
15:59:42 <edwardk> it is interesting that you can exploit a monad transformer i have to convert the environment comonad to a reader monad. ;)
15:59:55 <hpc> mm_freak: could you do IO with comonadic FRP?
16:00:01 <edwardk> mm_freak: as it should. you generally can't just flip the arrows around and get something all that useful ;)
16:00:03 <mm_freak> hpc: no
16:00:19 <hpc> hmm
16:00:20 <dmwit> Dashkal: I *think* the fix should be as easy as adding an Fnel constructor around as before calling fmap. =)
16:00:24 <Dashkal> Ok, I am indeed calling free's fmap
16:00:32 <dmwit> Dashkal: So that you're using FL's fmap instead of Free's fmap.
16:00:34 <hpc> is there a way to compose monads and comonads?
16:00:38 <hpc> kinda like transformers
16:00:41 <mm_freak> edwardk: yeah, but the idea intrigued me…  it's just that i didn't find much use and (=>>) was either inefficient or introduced time leaks all around
16:00:41 <edwardk> mm_freak: in machines, the moore machine type forms a comonad, the mealy machine forms an arrow
16:00:53 <dibblego> hpc: adjunction perhaps?
16:00:54 <Dashkal> Should have renamed all of FNel FL before I pasted.  FNel would be if the first side of the tuple was "a".
16:01:18 <edwardk> (a monad even, but its a silly monad)
16:01:27 <hpc> it could be interesting to have a comonad for the reactive parts, and a monad for the plumbing parts
16:01:34 <mm_freak> edwardk: the monad isn't silly, just very inefficient
16:01:34 <Dashkal> hrm, that's not quite right.  The right side of the tuple is supposed to be Free, not FL.  So I need to do the bookkeeping twice here.
16:01:38 <edwardk> yes
16:01:56 <dmwit> oh, yes
16:01:58 <edwardk> i should just give in and add it to machines
16:02:09 * hackagebot postgresql-copy-escape 0.1 - Format data to feed to a PostgreSQL COPY FROM statement  http://hackage.haskell.org/package/postgresql-copy-escape-0.1 (JoeyAdams)
16:02:11 <dmwit> That's pretty normal with newtypes, though.
16:02:29 <mm_freak> edwardk: (>>=) for monadic mealy-like FRP is inefficient in the same way (=>>) is for comonadic FRP based on streams
16:02:39 <edwardk> sure
16:03:16 <mm_freak> but comonadic FRP would work for actual time functions
16:03:20 <mm_freak> which is just Store =)
16:03:24 <navaati> mealy machines are Mealy a b = a -> (b, Mealy a b), right ?
16:03:27 <edwardk> yep
16:03:34 <mm_freak> type Behavior = Store Time
16:03:35 <mrotondo> ghci question: how come :t [max, min] is [max, min] :: Ord a => [a -> a -> a], but saying let fs = [max, min] and then :t fs is fs :: [() -> () -> ()]
16:03:50 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Mealy.hs
16:03:55 <hpc> mrotondo: you're hitting the monomorphism restriction
16:03:59 <edwardk> its nice having a canonical url i can give for that now ;)
16:04:12 <hpc> very roughly speaking, things that "look like values" get their types defaulted
16:04:34 <hpc> since it's picking (), i can guess that you are using ghci?
16:04:39 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Moore.hs#L46 are their evil twin
16:04:56 <mrotondo> hpc: eep. is there a particular bit of reading i could do to clear that up for myself, or should I just look up "monomorphism restriction"? Yeah I'm using ghci
16:05:05 <latro`a> why case m a of instead of let m a = ... in
16:05:06 <hpc> "looks like a value" for GHC basically means "foo ="
16:05:13 <hpc> as opposed to "foo arg arg ... ="
16:05:18 <dmwit> mrotondo: Yes, "monomorphism restriction" and "extended defaulting" are the search terms.
16:05:19 <mrotondo> ah.
16:05:30 <edwardk> extended defaulting makes me sad
16:05:35 <edwardk> it could be so much better
16:05:41 <jfischoff> hey mrotondo
16:05:48 <hpc> mrotondo: the fix is to put a type signature on fs
16:05:55 <hpc> which isn't particularly nice in ghci
16:06:00 <mrotondo> jfischoff: hi! :D how's it going?
16:06:05 <johnw> edwardk: back.  ask = fst, local = id
16:06:08 <hpc> or you can disable the monomorphism restriction
16:06:15 <latro`a> gah then you nest cases instead of one let
16:06:15 <mm_freak> GHCi should support continuation lines
16:06:16 <hpc> which isn't particularly nice for real code
16:06:24 <latro`a> I don't understand, why do you do that edwardk
16:06:25 <edwardk> johnw: local needs work
16:06:27 <jfischoff> mrotondo: great man how about you?
16:06:28 <johnw> oh, right
16:06:44 <mrotondo> hpc: Awesome, thanks.
16:06:45 <johnw> local = const
16:06:47 <edwardk> latro`a: less risk of shadowing errors
16:06:56 <latro`a> ...what?
16:07:06 <mrotondo> jfischoff: I'm real great, I've been home in RI for a week and I've gotta run to dinner! See you when I'm back in SF
16:07:14 <edwardk> latro`a: if i alpha rename and screw up swapping an s for a t with the let then i get code that compiles and just spins forever at runtime.
16:07:23 <edwardk> with the nested cases when i write it if i screw up i get a type error
16:07:29 <johnw> local = const id ?
16:07:39 <edwardk> local f (e,a) = (f e, a)
16:07:40 <jfischoff> mrotondo: yeah definitely do, I'm moved to the city so lets hack soon!
16:07:42 <latro`a> in the nested case I guess that works
16:07:43 <edwardk> we want to use the function
16:07:46 <latro`a> but not so much in the first one
16:08:02 <edwardk> i also write the cases because i really hate the layout of let ;)
16:08:04 <latro`a> or the third, etc.
16:08:07 <johnw> oh
16:08:12 <johnw> e -> e is not identity
16:08:17 <johnw> it's just a mapping of the sam etype
16:08:23 <johnw> ok
16:08:38 <johnw> it's like fmap of the first argument
16:08:40 <mm_freak> well
16:08:42 <mm_freak> local id = id
16:08:49 <Dashkal> horray! found my false assumption.  ScopedTypedVariables to the rescue
16:08:55 <edwardk> johnw: yeah this is one reason why i tend to prefer writing comonadic and monadic code with indexed monads, because then the types keep me honest
16:09:01 <jfischoff> edwardk: should have read the documentation first ;p all is well now
16:09:11 <johnw> I defined fmap f (e,a) = (e,f a)
16:09:13 <edwardk> jfischoff: ?
16:09:27 <jfischoff> edwardk: when I asked about biplate
16:09:29 <edwardk> johnw: ok. you now have a comonad, note some of the uses of it i mentioned above
16:09:51 <johnw> did I miss those uses?
16:10:08 <johnw> i have my scrollback history; what word should I search for?
16:10:09 <mm_freak> edwardk: i write the "in" on the last definition line and don't indent the part after it
16:10:13 <edwardk> basically just things like data Named a = Named String a, etc.
16:10:45 <Dashkal> Now if I could just understand why my assumption is wrong.
16:11:06 <johnw> how does that data declaration relate to our (,) e comonad?
16:11:06 <edwardk> mm_freak: its just uglier to me, has the 'whoops, infinite loop' problem, and then when i switch to unboxed tuples or cps i have to rewrite it all to basically this style anyways.
16:11:07 <mm_freak> johnw: if you can't figure out the definition of Store, i have just written them…  but try it out yourself first
16:11:30 <edwardk> mm_freak: i find that by just writing my code this way to begin with i screw up less
16:11:34 <johnw> I have Store implemented.  The two I couldn't figure out for myself were: fmap f (Store g s) = Store (f . g) s, and extend f (Store g s) = Store (\s' -> f (Store g s')) s
16:11:44 <Dashkal> Horray!
16:11:54 <mm_freak> edwardk: i see your point
16:11:55 <edwardk> johnw: the latter is nicer if you write it using duplicate
16:12:03 <edwardk> duplicate (Store f s) = Store (Store f) s
16:12:13 <johnw> wait, back to (,) e
16:12:17 <johnw> what's a use of it look like?
16:12:26 <Dashkal> dmwit: The magic line was this: fmap f (FL (Free (a, as))) = FL . Free $ (f a, unfl . fmap f $ (FL as))
16:12:37 <edwardk> so, i have a library named bound that provides a really handy way to deal with capturing variables
16:12:43 <Dashkal> I had to promote as back into an FL, then break it out after mapping it
16:12:54 <edwardk> one issue is that bound 'erases' the names of anything it captures locally
16:13:15 <edwardk> its rather nice to just write a comonad for something like data Named a = Named { name :: String, _extractName :: a }
16:13:29 <mm_freak> johnw: as with monads the real magic comes from the laws and polymorphism
16:13:38 <edwardk> and then you can extract the value of it, or you can get at the name if you want it
16:13:46 <johnw> mm_freak: that statement, while likely true, contains no information for me yet
16:13:47 <mm_freak> think of all the generic monadic functions we love:  mapM, foldM, filterM, …
16:14:00 <mm_freak> if you implement a monad, you get those for free
16:14:07 <edwardk> similarly i have a bunch of code in a parser written in scala, where i need to work under binders, where i've got a bunch of names in scope and can easily forget to dispose of them
16:14:36 <johnw> edwardk: can you show me a snippet of code that uses the (,) e comonad?
16:14:50 <mm_freak> johnw: i mentioned one example above:  imagine a blurring filter for pictures…  you can implement that as an application of 'extend' and perhaps a type class for moving the pointer
16:14:54 <wywy> any suggestions for a good irc client?
16:14:56 <johnw> i'm starting to feel disconnected from the code again
16:15:08 <frio> wywy: irssi!
16:15:08 <mm_freak> now you have a blurring filter for many kinds of comonads
16:15:19 <edwardk> its nice for me to just work with things like: data Patterned a = Patterned { cleanup :: Parser (), extract :: a }  context
16:15:19 <johnw> mm_freak: I have no idea what you're saying!
16:15:28 <mm_freak> array-based store, function-based store, repa-based store (parallel!), etc.
16:15:29 <edwardk> johnw: lets get there
16:15:40 <edwardk> mm_freak: let me walk him there slower =)
16:16:04 <edwardk> johnw: i'm going to skip over to another comonad rather than try to dredge up code
16:16:14 <johnw> i really need to see (,) e in action
16:16:21 <johnw> otherwise, the exercise we just did has no value
16:16:24 <mm_freak> i'm not walking him there at all…  i'm just saying that the comonad itself, just like a monad, is just a bunch of definitions…  the magic comes from the stuff you get for free
16:16:43 <johnw> it has never helped me to simply define fundamental functions
16:16:45 <edwardk> johnw: the problem is any example i can come up with involves paging in tons of extra stuff ;)
16:16:49 <johnw> my brain doesn't extrapolate from there to implications
16:17:02 <johnw> edwardk: let me see if I can manufacture something simple
16:17:30 <mm_freak> it's hard to find uses for the (,) e comonad
16:17:31 <Dashkal> Now to understand why I had to do all that in the first place.  ((,) a) is a Functor.  And Free f is a functor as long as f is...
16:17:56 <navaati> have some people started to use type-level literals (esp. strings) ? i'd like to see examples
16:17:58 <johnw> is there a codo notation yet?
16:18:10 <mm_freak> johnw: nope
16:18:22 <mm_freak> johnw: i also don't know what it would look like
16:18:23 <wywy> frio: ah... doens't seem to be very windows friendly ;)
16:18:27 <edwardk> http://hackage.haskell.org/packages/archive/rope/0.6.2/doc/html/Data-Rope-Annotated.html used the environment comonad a lot
16:18:27 <hpc> you should add it to trac
16:18:39 <edwardk> i basically defined annotated ropes in there
16:18:47 <frio> ah wywy... not really, no :(
16:18:48 <edwardk> where a rope is just a fingertree of bytestrings
16:18:59 <edwardk> but we often have some metadata we might want to attach
16:19:03 <frio> wywy: in windows i use mirc, but that's only because i've never bothered looking for anything else
16:19:06 <mm_freak> the problem with (,) e is that you really only know it's useful for an application, when you're actually already using it
16:19:20 <wywy> I used to use xchat. but my school's network seems to have blocked it.
16:19:20 <edwardk> johnw: dominic orchard defined one, i'd like to see it standardized
16:19:24 <mm_freak> it's hard to come up with uses, but it's easy to recognize uses
16:19:53 <edwardk> now, the usual way to augment something like a fingertree with an extra annotation would be to bolt the data directly into the fingertree
16:19:58 <frio> wywy: grab an amazon AWS box, or some sort of VPS. run ssh on port 443, and run irssi in a screen session on that ;)
16:20:23 <wywy> frio: that would not be as good as the webchat I'm running now :)
16:20:28 <edwardk> that package instead of making a tree (a,b)  makes (tree a, tree b)   -- and then welds them together with type magic ;)
16:20:52 <Nafai> wywy: I would assume that if xchat is blocked, any client is blocked
16:20:54 <edwardk> i've done similar things with building a graph api that had annotations on a graph paired with the actual graph shape
16:21:09 <edwardk> that way the graph itself didn't mutate when you annotated its nodes and edges with data
16:21:11 <frio> what Nafai said :) (hence the route-around-it)
16:21:24 * ddarius thinks he started but did not finish reading the codo notation paper.
16:21:46 <edwardk> the separation of shape from metadata means that it doesn't have the god-awful garbage collection properties that, say, fgl has
16:22:13 <mapreduce> wywy: Generally screen is better because you can keep the connection going between sessions assuming you're not in front of the same PC all day and night.
16:22:35 <edwardk> basically the big 3.0 jump for comonad was to make it more suitable for standardization and for dominic orchard's sugar
16:24:07 <navaati> if comonads are to be standardized and included in base, wouldn't it be cool to use restricted comonads from the beginning ?
16:24:15 <edwardk> navaati: no
16:24:28 <edwardk> restricted monads and comonads should remain separate from the unrestricted forms
16:24:45 <navaati> uh ? why ?
16:25:01 <johnw> how do I "unimport" a module that's being imported by the Prelude?
16:25:06 <mm_freak> are those actual monads/comonads categorically?
16:25:11 <edwardk> you have lots of places where type inference goes to crap with the restricted versions, and where you just can't say that something is polymorphically recursive
16:25:20 <mm_freak> johnw: import Prelude hiding stuff
16:25:21 <edwardk> mm_freak: just define them over a subcategory of hask
16:25:28 <byorgey> LordBrain: No, types which get promoted to kinds (using the DataKinds extension) are closed
16:25:51 <byorgey> LordBrain: but all Haskell 2010 kinds are open.
16:25:57 <navaati> argh, such a shame...
16:26:10 <johnw> import Prelude hiding Control.Monad.Instances?
16:26:21 <hpc> can't hide instances
16:26:30 <wywy> Nafai: probably ...
16:26:37 <edwardk> navaati: basically restricted monads are okay for more or less "first order" code and thats about it
16:26:55 <hpc> and i don't think you can hide re-exports
16:26:59 <edwardk> johnw: you can't hide instances.
16:27:03 <edwardk> just make your own pair type
16:27:03 <hpc> you should try it with something less magic than Prelude
16:27:08 <edwardk> data Pair a b = Pair a b
16:27:11 <hpc> see if it works
16:27:13 <edwardk> and work with that for your comonad, etc.
16:27:19 <frio> hpc: could you import qualified Prelude as P? (thus keeping stuff out of your global namespace)
16:27:20 <johnw> edwardk: https://gist.github.com/3493332
16:27:28 <johnw> now I can: foo ("foo", 100)
16:27:41 <johnw> but I'm not sure on what this buys me over the Reader monad
16:27:57 <edwardk> johnw: you don't use comonads where you'd use monads
16:28:01 <johnw> except that I guess the Reader monad applies its argument to ever single function in the do block?
16:28:10 <edwardk> johnw: consider having a list of (String,Type) pairs.
16:28:15 <edwardk> you can now extract the type from the pair
16:28:25 <edwardk> but you also have the names if you want them
16:28:43 <johnw> edwardk: you mean, extract the type from every pair?
16:28:45 <edwardk> you often work with _lots_ of comonads, and only one big monad
16:28:56 <johnw> extract [(a,b)...] = [(b)...]?
16:28:58 <edwardk> at least thats my experience
16:29:09 <edwardk> fmap extract
16:29:14 <johnw> ah
16:29:16 <frio> Reader monad eh... /ears perk up
16:29:23 <edwardk> its pretty nice to have a common name for it
16:29:34 <edwardk> because you can now make things like
16:30:33 <edwardk> data Global a = Global { hashCode :: MD5Hash, packageName ::  String, moduleName :: String, localName:: String, globalValue :: a }
16:31:25 <edwardk> i use those for instance in a bunch of type checkers for things like global names. then i can have Global Type for global variables term variables that carry a type, and Global Kind for global type variables carrying their kind.
16:31:44 <edwardk> and i can extract the type, compare them for equality, etc.
16:32:36 <edwardk> i often have lots of variables in my program, i also often have lots of different comonads lying around, its nice to not pollute my namespace, i can just use extract on almost anything and it works
16:33:44 <edwardk> now lets build something like store but more concrete
16:34:06 <edwardk> data Pointer i e = Pointer (Array i e) i
16:34:21 <edwardk> a Pointer is an array and an index into the array
16:35:06 <edwardk> so how would you define: extract :: Ix i => Pointer i e -> e  ?
16:35:40 <Dashkal> edwardk: In your blog post "Monads for free" you make this comment just before definint Forall: "The problem is you want to be able to perform different folds that return different types, so lets quantify over the variable in the monad."  What did you mean by that?  (I'm trying to understand Forall and how it allowed ghc to properly derive Functor/Monad for Free ((,) a))
16:35:56 <Dashkal> )
16:37:42 <edwardk> Dashkal: if i have a free monad but quantify over the choice of a, then at any branch in the free monad, which looks like a + f (a + f (a + … i'm forced to choose the 'f' side
16:38:02 <edwardk> so its effectively dumbing free down to f (f (f (f …   which is Mu f
16:38:34 <Dashkal> That sounds familiar... coMu is now freeMu
16:38:45 <edwardk> Dashkal: =)
16:38:49 <Dashkal> Danke :)
16:39:06 <Dashkal> Yep, now it clicks.  No longer confused.
16:39:32 <Dashkal> And Forall f is just fine when the other branch could only hold a () (to be the list terminus)
16:44:28 <Solarnrg> I've got a reverse engineering coding question
16:44:51 <Solarnrg> Involves Kerbal, Damned Robotics, optimization, making this thing run a lot less chuggy, any ideas?
16:45:13 <Solarnrg> I built this mining rig but as soon as I add on more than a certain number of joints/rotors i chugs like fuck
16:45:17 <Solarnrg> Here's what I built so far http://www.youtube.com/watch?v=TG17V3AEDxw
16:49:21 <byorgey> Solarnrg: is this written in Haskell?
16:50:27 <Solarnrg> I have no idea where to even begin with this, all I know is the damned robotics pack is not made by the same company who made Kerbal and I do know you guys are some of the best coders on the web
16:54:20 <Solarnrg> Also I know haskell is a very algorithmic language and I figured the way teh robotics pack is writtin is a very poor algorithm currently, I'd like some pointers how I could mess aroudn with it
16:54:27 <Solarnrg> Would a link to the source code be of any use?
16:54:50 <edwardk> probably not unless its written in haskell ;)
16:55:16 <Solarnrg> How can I tell what language its written in?
16:55:24 <latro`a> ...
16:55:30 * latro`a head explodes somewhat
16:56:59 <ion> ಠ
16:57:12 <edwardk> is that half a look of disapproval?
16:58:32 <ion> solarng: What channel do you think you joined?
16:58:39 <ivan> Solarnrg: feel free to pastebin some code and link it to me, I am curious
16:59:11 <Solarnrg> ok brb
17:00:31 <johnw> edwardk: sorry, I keep getting pulled away
17:00:56 <edwardk> johnw: np. working on other stuff ;)
17:01:08 <johnw> edwardk: so, I have my (,) e comonad.  The million dollar question is: what do I gain by making it a comonad?  Why not just tell my code that it's (e,a), rather than some Comonad a?
17:01:31 <johnw> is it for the genericity?
17:01:49 <edwardk> johnw: did you see the Global example above?
17:01:56 <navaati> bye
17:01:57 <edwardk> i have lots of types like that
17:02:14 <edwardk> its nice to be able to share the name extract for them at the very minimum
17:02:14 <slack1256> navaati: bye.
17:02:24 <johnw> ohh
17:02:28 <edwardk> even if you take nothing else away from the (,) e example
17:02:38 <johnw> you use Comonads to wrap a value
17:02:45 <johnw> so that the same code can applies to kinds or to types?
17:03:13 <edwardk> yes, that way i can have code that works on names or named things, and it just does the right thing with either kind of name
17:03:21 <johnw> aha!  and now I see why a Lens is a comonad
17:03:26 <johnw> because that's just what a Lens is doing
17:03:37 <Solarnrg> Found it
17:03:38 <Solarnrg> http://svn.mumech.com/KSP/trunk/MuMechLib/
17:03:51 <Solarnrg> No idea what .cs files do
17:03:53 <johnw> a lens is a comonadic "view" on top of a value
17:04:03 <edwardk> a -> (b -> a, b) -- if we ball up the right hand side of that the (b -> a, b) forms a comonad Store b a
17:04:11 <edwardk> not entirely
17:04:16 <edwardk> lenses themselves aren't actually comonads
17:04:20 <hpc> Solarnrg: C Sharp
17:04:22 <hpc> C S
17:04:30 <johnw> what aspect of lenses are?
17:04:30 <edwardk> however, a lens can be viewed as a 'store comonad coalgebra'
17:04:39 <johnw> oops, lost me there :)
17:04:40 <edwardk> that captures the lens laws perfectly
17:04:40 <hpc> just from eyeballing the code, so might be something else
17:04:42 <hpc> but unlikely
17:05:02 <ion> WWW www = new WWW("file://" + KSPUtil.ApplicationRootPath.Replace("\\", "/") + "Parts/mumech_MechJebPod/snd1.wav");
17:05:08 <edwardk> have you ever written a fold or unfold using the (f a -> a) -> Mu f -> a  style?
17:05:11 <ion> “WWW”?
17:05:33 <johnw> edwardk: no
17:05:51 <edwardk> johnw: used foldr or unfoldr? =)
17:06:01 <johnw> i've used foldr.  never heard of unfoldr
17:06:07 <edwardk> @type unfoldr
17:06:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:06:35 <Solarnrg> Is there a way of debugging the game to find out why it gets so chuggy beyond a certain number of servos or rotortrons in-game?
17:06:39 <edwardk> basically the Maybe (a,b) describes one 'step' of the [a] data type
17:06:42 <statusfailed> I'm trying to use Control.Lens and MonadState to write an implementation of an online algorithm to calculate variance, but I think it's quite messy, could anyone have a look?
17:06:44 <dibblego> foldr :: (Maybe (a, b) -> b) -> [a] -> b
17:06:46 <hpaste> statusfailed pasted “Lenses and Variance” at http://hpaste.org/73806
17:07:09 <johnw> edwardk: cool.  how does that relate to lenses and Comonads?
17:07:19 <slack1256> Solarnrg: It should be. But i think is better to ask the dev directly.
17:07:31 <ion> solarng: What do you suppose this channel’s topic of discussion is?
17:07:48 <johnw> I'm not clear on how Store relates to your Global example either
17:07:50 <edwardk> johnw: well, foldr is an algebra, unfoldr as a coalgebra.  you foldr tearing down a [a] one cons cell or nil at a time
17:07:54 <ion> nrg even
17:07:57 <edwardk> you unfoldr building it up from a seed one level at a time
17:08:01 <johnw> a -> (a -> b, b) is still a mystery
17:08:14 <edwardk> now, those are 'f-algebras' or 'f-coalgebras' which just means f is a functor.
17:08:24 <slack1256> SolarnRg: the kerbal space program hask a channel en irc.netsplit.de
17:08:34 <slack1256> s/hask/has/
17:08:41 <johnw> doesn't folding use a Monoid?
17:08:48 <johnw> and not a functor?
17:08:54 <edwardk> in the lens case we want the to be a stronger kind of algebra
17:09:03 <edwardk> lets say we defined list differently
17:09:26 <Solarnrg> So I go to irc.netsplit.de they'll answer all my questions
17:09:46 <hpc> johnw: you have an 'a' and you want to get a 'b' out of it
17:09:49 <hpc> with a getter function
17:09:52 <hpc> what's the type of the getter?
17:09:53 <edwardk> hrmm, first a simpler example
17:10:02 <slack1256> i guess. Probably more than here. we know only about haskell not of KSP. sorry though
17:10:03 <edwardk> data Nat = S Nat | Z
17:10:30 <edwardk> we can break this up into a basic functor. data NatF a = S a | Z  -- that isn't recursive
17:10:38 <edwardk> and something else that does the recursion for me
17:10:51 <edwardk> newtype Mu f = Mu   (f (Mu f))
17:11:34 <edwardk> instead of values like Z, S Z, S (S Z)     you'd have Mu Z, Mu (S (Mu Z)), Mu (S (Mu (S (Mu Z)))), etc
17:12:40 <edwardk> given that you can define something like foldNat :: (NatF a -> a) -> Mu NatF -> a
17:12:48 <edwardk> but my wife needs me, going away now
17:12:54 <johnw> hpc: but I don't get a b out of it, I get a (a -> b, b)
17:13:02 <hpc> johnw: ignore that part
17:13:11 <johnw> that's the part I need to understand
17:13:12 <hpc> so a getter would be something like
17:13:20 <hpc> get :: Person -> Address
17:13:25 <hpc> a setter looks like
17:13:39 <hpc> set :: Person -> Address -> Person
17:13:56 <hpc> now we take a side-trip
17:14:16 <hpc> if you have two functions, like (* 2) and (+ 7), both of type Integer -> Integer
17:14:25 <hpc> you also have a function Integer -> (Integer, Integer)
17:14:34 <hpc> \x -> (x * 2, x + 7)
17:14:50 <hpc> that's factoring out the common first argument
17:14:56 <johnw> oh
17:14:58 <johnw> ok
17:15:03 <hpc> look back at get, set
17:15:06 <hpc> and factor it out
17:15:15 <hpc> we get Person -> (Address, Address -> Person)
17:15:28 <hpc> then replace those with type variables 'a', 'b'
17:19:13 <johnw> so it's a combined get/set?
17:19:37 <hpc> yep
17:19:54 <hpc> a value of that lens type will be something like
17:20:01 <johnw> in (a -> b, b), the first the is the result of set, and the second is the result of get?
17:20:06 <hpc> \obj -> (get obj, set obj)
17:20:07 <hpc> yeah
17:20:24 <hpc> one of the two orderings, doesn't really matter
17:22:59 <hpaste> edwardk annotated “Lenses and Variance” with “Lenses and Variance (annotation)” at http://hpaste.org/73806#a73807
17:23:10 <edwardk> that any better?
17:23:43 <dolio> Not the variance I was expecting.
17:23:44 <johnw> are you talking to me?
17:24:03 <edwardk> that was for whoever sent me the lens code before i went away for a bit
17:24:15 <edwardk> dolio: hah
17:25:33 <hpaste> edwardk annotated “Lenses and Variance” with “Lenses and Variance (annotation) (annotation)” at http://hpaste.org/73806#a73808
17:26:05 <johnw> can anyone tell me why this doesn't type check: https://gist.github.com/3493777
17:26:19 <johnw> it says that a doesn't match b in the fooName = e expression
17:26:54 <johnw> and yet I can do fmap f (e,t) = (e, f t) just fine, and I would have thought it was equivalent in form
17:27:08 <hpaste> edwardk annotated “Lenses and Variance” with “Lenses and Variance (annotation) (annotation) (annotation)” at http://hpaste.org/73806#a73809
17:27:23 <byorgey> johnw: no, because the declaration of Foo specifies that the two fields must have the same type
17:27:45 <byorgey> johnw: for it to be equivalent you would have to have  data Foo a b = Foo { fooName :: a, fooValue :: b }
17:27:54 <edwardk> data Foo a b = Foo { fooName :: a, fooValue :: b } would permit that functor
17:28:06 <hpc> johnw: (f :: a -> b)
17:28:07 <byorgey> then the code you have would work, if you change it to  Functor (Foo a)
17:28:16 <hpc> you are trying to unify (f x) with x
17:28:16 <edwardk> that too
17:28:21 <hpc> and the types aren't working out
17:28:29 <hpc> so it says 'b' isn't 'a'
17:28:30 <johnw> edwardk: what I don't get with your Global example is why your code doesn't then just call globalValue.  What does the Comonad get you?
17:28:31 <hpc> in fancy words
17:28:34 <edwardk> well b with a anyways
17:28:41 <johnw> edwardk: oh, I see
17:28:43 <scshunt> edwardk: follow-up to yesterday's discussion: I have a series of operations (a -> Writer a). Is there an easy way to run them all (besides manually writing a fold) or should possibly be looking for something other than monadic structure?
17:28:50 <johnw> wow, wouldn't have figured that out by myself
17:29:09 <edwardk> johnw: say i have 6 of those different types in my code. now i have 6 extra combinator names cluttering up my namespace that i have to remember
17:29:15 <johnw> ah, hmm
17:29:18 <byorgey> scshunt: foldr (>=>) return
17:29:18 <johnw> let me code that example
17:30:36 <edwardk> johnw: with a lens, we can define a lens directly as data Lens a b = Lens { get :: a -> b, set :: a -> b -> a } -- but then we have to come up with laws we want it to satisfy
17:30:57 <edwardk> johnw: those laws are pretty much common sense
17:31:10 <scshunt> byorgey: derp, thanks
17:31:15 <scshunt> :t foldr (>=>)
17:31:16 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m c) -> [a -> m a] -> a -> m c
17:31:21 <edwardk> that you get back what you put, putting bck what you got doesn't change it, setting twice is the same as just setting the last way once, etc.
17:31:36 <edwardk> johnw: but they are totally ad hoc
17:31:49 <byorgey> scshunt: (>=>) is composition for "monadic functions"
17:31:51 <byorgey> @type (>=>)
17:31:52 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:32:02 <edwardk> it turns out that you can both improve the performance and get some more fundamental laws by changing the representation slightly
17:32:15 <scshunt> byorgey: yeah, I remember now :)
17:32:18 <byorgey> so  foldr (>=>) return [a,b,c] = a >=> b >=> c >=> return
17:32:22 <byorgey> ok =)
17:32:26 <edwardk> one such choice of implementation involves a comonad
17:32:34 <edwardk> a -> Store b a
17:33:39 <edwardk> because (a -> b, a -> b -> a) can be factored into (a -> (b, b -> a)), and if we flip that to get a -> (b -> a, b)       and define data Store b a = Store (b -> a) b             then you get a -> Store b a
17:34:03 <edwardk> and then the get/put laws turn out to be precisely the laws you want a comonad coalgebra to satisfy
17:34:06 <johnw> would it be correct to say that Monads are abstraction for embedding values in context, and operating on those values within that context; and Comonads are an abstraction for extracting values from context, and contextualizing operations on those values?
17:34:19 <edwardk> you also get to use extract on store, and do other store operations on the result
17:34:29 <johnw> gotta run dinner time
17:34:33 <hpaste> test pasted “test” at http://hpaste.org/73810
17:34:33 <hpc> edwardk: wow, i was about to ask how you define extract *facepalm*
17:34:35 <johnw> I think I'm getting closer
17:34:45 <edwardk> johnw: comonads are like burritos ;)
17:34:52 <edwardk> hpc: =)
17:34:56 <edwardk> Store is nice like that
17:36:04 <byorgey> edwardk: wait, so burritos are self-dual?
17:36:26 <edwardk> byorgey: apparently burritos aren't just a lifestyle, they are an Identity.
17:36:33 <byorgey> hahaha
17:37:12 * hackagebot hogg 0.4.1.2 - Library and tools to manipulate the Ogg container format  http://hackage.haskell.org/package/hogg-0.4.1.2 (ConradParker)
17:37:29 <hpc> nice package name
17:37:55 <hpc> @hoogle vorbis
17:37:55 <lambdabot> package vorbiscomment
17:39:53 <johnw> edwardk: monads are burrito packers, and comonads are burrito vendors
17:40:17 <maloi> is it ok to say: types that have values have kind * (i.e. Int has the value 3 so it has Kind * and Int -> Int has the value (+1) so it has also kind *)
17:40:39 <hpc> maloi: the empty type has no values
17:40:55 <hpc> {-# LANGUAGE EmptyDataDecls #-} data Void
17:41:43 <shachaf> hpc: In Haskell all types are lifted. :-)
17:41:58 <shachaf> In GHCskell there's also the kind "#".
17:42:00 <maloi> ok so it's better to say that all nullary type constructors have kind *?
17:42:18 <hpc> shachaf: okay fine, newtype Void = Void Void
17:42:18 <Nereid> that's just as bad as talking about nullary functions
17:42:30 <shachaf> hpc: What does that have to do with it?
17:42:33 <shachaf> hpc: undefined :: Void
17:42:41 <shachaf> maloi: Sometimes people just say "types" when they mean "things of kind *".
17:42:45 <hpc> shachaf: not a value :P
17:42:59 <shachaf> maloi: But in general, yes.
17:43:04 <byorgey> sometimes people say "value" when they mean "stuff including undefined".
17:43:08 <maloi> Nereid: can u explain your answer?
17:43:31 <shachaf> @kind GHC.Prim.Int#
17:43:32 <lambdabot> #
17:43:33 <byorgey> Nereid: no it isn't.
17:43:35 <hpc> i mean, if you count undefined as a value, it's basically tautological to equate {X | undefined : X} with *
17:44:15 <Nereid> byorgey: why not?
17:44:27 <Nereid> unless you mean to say it's worse
17:44:44 <byorgey> because "constructor" is a much less well-defined term.  At times people have used the phrase "type constructor" specifically to mean types of higher kind, but fundamentally it just means "something that constructs a type".
17:45:00 <byorgey> whereas "function" can't mean anything other than "something which takes an input and produces an output".
17:45:08 <byorgey> so "nullary function" really makes no sense.
17:45:24 <byorgey> but "nullary type constructor" seems perfectly cromulent to me.
17:45:53 <shachaf> "nullary type function" doesn't make sense, though. :-)
17:45:55 <hpc> "Nothing is a nullary constructor/value"
17:45:58 <Nereid> I don't agree with what you say about "type constructor" but whatever.
17:45:59 <byorgey> shachaf: agreed.
17:46:00 <hpc> yeah, i can see that
17:46:29 <shachaf> Unless a "nullary type function" is a function that takes and returns a nullary type!
17:46:35 <Nereid> ok never mind.
17:46:36 <Nereid> I agree now.
17:46:37 <shachaf> (That doesn't make much sense either.)
17:46:48 <byorgey> Nothing is a data constructor.  () is a type constructor.  Nice and consistent.
17:46:58 <Nereid> yes, that's why I agree now.
17:47:00 <hpc> () is also a data constructor
17:47:07 * hpc unhelps
17:47:11 <byorgey> hehe
17:47:14 <Nereid> lol
17:47:40 <shachaf> How can () be a data constructor if nothing is a data constructor?
17:47:53 <hpc> <3 this channel
17:48:21 <scshunt> hmm
17:48:24 <scshunt> :t (>>=)
17:48:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:48:33 <byorgey> shachaf: everything is inhabited in Haskell, even ill-advised terminology.
17:49:22 <shachaf> byorgey: Is "Maybe" inhabited?
17:49:33 <shachaf> @quote unsafeCoerce#
17:49:33 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
17:49:36 <shachaf> @quote unsafeCoerce#.*kind
17:49:36 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
17:49:42 <Nereid> shachaf: I argue that it is nonsensical to ask that question.
17:49:47 <byorgey> shachaf: maybe
17:49:58 <shachaf> Nereid: Don't argue.
17:50:06 <Nereid> I demand, then.
17:52:56 <maloi> so Int->Int is a nullary type constructor too, right?
17:54:09 <byorgey> maloi: no, it's not a constructor
17:54:16 <byorgey> it's just a type of kind *
17:54:29 <byorgey> constructors are things with CapitalizedNames
17:54:44 <scshunt> anyone have a code formatter handy?
17:54:44 <byorgey> and also some special ones like [] and (->)
17:54:53 <scshunt> byorgey: plus anything starting with a :
17:55:27 <byorgey> scshunt: yes, that counts as a capital letter ;)
17:55:38 <byorgey> @package stylish-haskell
17:55:38 <lambdabot> http://hackage.haskell.org/package/stylish-haskell
17:55:41 <byorgey> ^^^ scshunt
18:00:28 <maloi> (->) is a function type constructor and has kinf * -> * -> * so i thought (->) Int Int is therefore nullary
18:00:47 <byorgey> maloi: yes, but it is not a "constructor"
18:01:05 <maloi> byorgey: actually i'm  reading http://www.cis.upenn.edu/~cis194/lectures/2012-03-15.html which u might be familiar with ;)
18:01:05 <hpc> not any more than (Just 17) is a constructor, at any rate
18:01:18 <byorgey> maloi: Just is a data constructor but  (Just 3) is not a data constructor.
18:01:35 <byorgey> maloi: oh, hm, yes, that seems vaguely familiar
18:01:38 <byorgey> ;)
18:02:22 <byorgey> oh, argh, I used "type constructor" in the way that I don't like in those lecture notes
18:02:33 <byorgey> though it is common
18:02:37 <byorgey> which is perhaps why I used it
18:03:04 <byorgey> maloi: anyway, all this splitting hairs over terminology (what counts as a "constructor", etc. etc.) is really unimportant
18:03:11 <c_wraith> which is the way you don't like?
18:03:16 <byorgey> maloi: the important thing is to understand kinds
18:03:31 <byorgey> c_wraith: "type constructor" = "anything with a kind other than *"
18:03:34 <frio> ooh byorgey
18:03:38 <shachaf> Understanding kinds is kind of important.
18:03:39 <frio> thanks for the stylish link :)
18:03:52 <byorgey> frio: you're welcome =)
18:09:11 <scshunt> maloi: A constructor is an irreducible part of a value
18:09:52 <scshunt> it's not a type
18:10:34 <c_wraith> Hmm.  By analogy to values, a type constructor really should be any non-polymorphic term at the type level.
18:11:06 <shachaf> I think "type" and "type constructor" are among those words that aren't worth arguing about.
18:11:07 <scshunt> I would define a constructor as "a function whose values at a given set of arguments are identified uniquely among all values as being the evaluation of that function at those arguments"
18:11:12 <shachaf> If we want to be precise, we can specify the kind.
18:12:16 <scshunt> this decision doesn't quite work, but it's the idea
18:12:34 <scshunt> actually I take that back, it's horrible and doesn't capture the idea at all :P
18:13:25 <maloi> thanks!
18:13:53 <scshunt> maloi: but the basic idea is that you can't reduce, say, "Just 4" any further than that
18:14:01 <scshunt> whereas (4 + 2) reduces to 6
18:14:36 <scshunt> and compositions of constructors are not constructors
18:15:01 <scshunt> so (Int -> Int) is not itself a type constructor, although Int and (->) are
18:15:20 <scshunt> please tell me I haven't just confused you more :P
18:15:35 <maloi> let me read that a third time :)
18:18:18 <scshunt> read the second bit
18:18:21 <scshunt> the first bit is very wrong :)
18:21:13 <maloi> you said "A constructor is an irreducible part of a value" and Just 4 cannot be reduced any further
18:21:27 <maloi> so it'S a constructor?
18:21:54 <shachaf> Different people will probably call different things constructors.
18:21:59 <shachaf> It's not worth worrying too much about.
18:23:18 <maloi> ok :)
18:28:52 <aoeu> When people call Google/Apple copycats, do they really believe it? Or do they just whine for no reason?
18:29:15 <shachaf> I think that's off-topic for this channel.
18:29:43 <dibblego> ho aoeu, do you want to discuss this in #haskell-blah please
18:30:09 <dibblego> *hi
18:31:51 <aoeu> sure
18:32:54 <dibblego> thanks!
18:37:23 * hackagebot HsOpenSSL 0.10.3.3 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.3.3 (MasatakeDaimon)
18:46:25 <narens> hello
18:48:27 <johnw> do I want data-lens, or lenses?
18:48:37 <shachaf> johnw: You want "lens".
18:48:43 <shachaf> Which exports Control.Lens
18:48:56 <johnw> hmm.. I can't find the lens package via Hoogle
18:49:57 <shachaf> http://hackage.haskell.org/package/lens
18:51:46 <narens> I am going to post 2 code snippets on hpaste one containing java code and the other Haskell and it does very simple number crunching. The running time for argument 1 million is 0.688 seconds vs 2.326 seconds. If anyone can tell me why the Haskell one is slow and how to speed it up I will greatly appreciate it. I am guessing its because of performing computation on boxed ints, but I am not sure.
18:52:00 <hpaste> narens pasted “Java_and_haskell_1” at http://hpaste.org/73815
18:52:25 <hpaste> narens pasted “Java_and_haskell_2” at http://hpaste.org/73816
18:55:36 <narens> anyone?
18:55:59 <shachaf> I don't think your two programs are doing the same thing.
18:56:26 <narens> shachaf: why's that?
18:57:02 <edwardk> @hackage lens
18:57:02 <lambdabot> http://hackage.haskell.org/package/lens
18:58:34 <shachaf> narens: There are a bunch of small changes optimizations that can probably speed up your program by a lot, like using `rem` instead of `mod`.
18:59:21 <edwardk> also you can swap  or . map  for any
18:59:36 <shachaf> Yes, hpaste mentioned that. :-)
18:59:42 <narens> let me try those two
18:59:49 <shachaf> edwardk's change is just stylistic.
18:59:58 <shachaf> checkPrimes = sum . filter isPrime $ [0..n-1] should work just as well as what you wrote, I think.
19:00:02 <edwardk> @src any
19:00:02 <lambdabot> any p =  or . map p
19:00:08 <edwardk> guess so =)
19:00:35 <narens> okay down to 1.983
19:02:32 <narens> shachaf: why is rem better than mod?
19:03:04 <shachaf> It's not better.
19:03:06 <shachaf> But it's faster.
19:03:20 <shachaf> Probably because it corresponds to your CPU's "remainder" instruction or something. :-)
19:03:34 <Automorp`> shachaf: Is it always faster?
19:03:55 <Nisstyre_> Automorp`: it would be if you had a "remainder" instruction
19:04:08 <Nisstyre_> (as shachaf said)
19:04:19 <narens> shachaf: what else can I do to speed it up?
19:04:22 <Nisstyre_> that would depend on your CPU architecture
19:04:48 <shachaf> Let me see.
19:06:21 <rosie> How can I pattern match on something like _:'=':user = "hey=you" ?
19:07:34 <shachaf> rosie: You can't, really.
19:07:36 <roconnor> rosie: you cannot without something like view patterns
19:07:39 <shachaf> You can use a view pattern, though.
19:08:05 <rosie> I was thinking I may have to do myfunc(_:'=':user)
19:08:06 <shachaf> But you might be best off just being more explicit about it.
19:08:07 <rosie> ...
19:08:22 <shachaf> rosie: _:'=':user means that _ must be one character.
19:08:37 <rosie> shachaf: You mean '='?
19:08:41 <rosie> It'll split it, right?
19:08:42 <Nisstyre_> you could match against a list of lists....
19:08:44 <shachaf> No, _
19:08:56 <shachaf> You could do what Nisstyre_ said, which might combine nicely with view patterns.
19:09:15 <shachaf> rosie: This might be clearer if you un-infix (:)
19:09:29 <shachaf> myfunc ((:) _ ((:) '=' user))
19:09:44 <shachaf> As you know, (:) :: Char -> [Char] -> [Char]
19:09:48 <shachaf> So that _ must be a Char.
19:10:02 <Nisstyre_> (:) = cons if you've ever used Scheme
19:10:12 <Mortchek> Would something using dropWhile (/= '=') work?
19:10:48 <shachaf> Lots of things would work.
19:10:54 <rosie> shachaf: Why can I pattern match on ("fetch":_) -> do … ? "fetch/298" matches well
19:10:57 <shachaf> You probably don't want dropWhile.
19:11:09 <Mortchek> rosie, "fetch":_ is a list of lists of characters.
19:11:13 <shachaf> rosie: You can say ('f':'e':'t':'c':'h':_)
19:11:15 <geekosaur> because "fetch" translates to 'f':'e':'t':'c':'h'
19:11:21 <shachaf> rosie: That's kind of long, though. :-)
19:11:51 <ion> geekosaur: :[]
19:11:53 <geekosaur> which happens to be the same thing "fetch" means anywhere else, except it has a :[] appended
19:11:55 <shachaf> I think you maybe want a view apttern like stripPrefix.
19:12:16 <rosie> shachaf: I see. Thanks! I'll look into it
19:12:22 <geekosaur> in a pattern that last may be suppressed if there's a : afterward, so you can use it as a prefix conveniently
19:12:27 <ion> Oh, you weren’t referring to "fetch" in general.
19:12:41 <shachaf> > let foo (stripPrefix "fetch" -> Just r) = Right r; foo x = Left x in (foo "fetchblah", foo "hello")
19:12:42 <ion> Oh, you were.
19:12:42 <lambdabot>   (Right "blah",Left "hello")
19:12:44 <shachaf> rosie: Like that.
19:13:21 <geekosaur> I was talking about the pattern, but comparing it with the general form
19:13:38 <geekosaur> to show how they are related and thereby why it works in a pattern
19:14:05 <shachaf> rosie: You should understand why ("fetch":_) and so on don't work, though. :-)
19:16:01 <rosie> shachaf: Thanks! I think "fetch" works as a series of characters, but I couldn't have a variable to capture the result of the pattern match… does that make sense?
19:17:06 <shachaf> narens: You can speed the program up by a lot by checking "odd n" first.
19:17:55 <shachaf> narens: On my machine your Haskell and Java programs are the same speed with my changes.
19:18:25 <narens> shachaf: I want the programs to be the same though. You can ignore the algorithm.
19:18:57 <narens> shachaf: really, the same? can you post the final haskell program?
19:20:04 <shachaf> Oh, I guess the Java code doesn't return early for even numbers?
19:20:09 <shachaf> Maybe my change is invalid then.
19:20:21 <shachaf> real	0m0.380s
19:20:21 <narens> shachaf: yea
19:20:23 <shachaf> real	0m0.380s
19:20:34 <shachaf> But it ends up being exactly the same runtime. :-)
19:21:14 <narens> is this without checking even numbers early?
19:21:53 <shachaf> No, that's with.
19:21:57 <narens> k
19:22:04 <shachaf> Maybe the Java code is optimizing that somehow?
19:22:20 <narens> I'm sure this can be speeded up more without resorting to GHC.prim
19:23:40 <narens> java performs almost the same as C with O2
19:30:05 <narens> shachaf: I'm signing off... i'll mess around with it later
19:30:09 <narens> k
19:48:51 <wywy> Are random numbers cumbersome to use in Haskell?
19:49:00 <latro`a> I don't think so
19:49:16 <thirsteh> not really, you just pass a PRG (with its state) around
19:49:30 <latro`a> or you can use IO repeatedly
19:49:42 <latro`a> as it happens via the MonadRandom interface, you can write the same code to do either process :D
19:50:38 <wywy> thirsteh: but then the RNG will contaminate all the code which depends on it...
19:50:48 <shachaf> Oh no!
19:51:15 <latro`a> wywy, a little, but it's all hidden anyways
19:51:17 <cmears> If you're trying to add strictness annotations to some code, and you have some big data structure that you want to be fully evaluated, is there some way to test whether that's the case?
19:51:23 <shachaf> You'll generally have to express the fact that your function uses random numbers in its type *some* way or another.
19:51:28 <cmears> Some "hasStillGotThunks" function?
19:51:37 <latro`a> even if it's just taking a generator argument
19:51:37 <shachaf> cmears: There's no "safe" opertaion to do that.
19:51:48 <shachaf> cmears: You can force a whole data structure, though (but often you don't want that).
19:52:55 <cmears> shachaf: do you mean unsafe in the unsafe-perform-io sense, or that in the checking you might end up forcing it anyway?
19:53:15 <parcs`> hasStillGotThunks x = x `deepSeq` False
19:53:35 <shachaf> Well, probably just unsafe in the "you're not supposed to do it" sense.
19:53:42 <shachaf> Breaks equational reasoning and all that.
19:53:44 <wywy> shachaf: just feel too much work to pass the RNG around
19:54:03 <wywy> shachaf: I don't seem to have this problem with impure languages...
19:54:13 <shachaf> Feel free to use impure languages, then. :-)
19:54:15 <latro`a> wywy, it's hidden
19:54:17 <cmears> parcs`: thanks, I might end up doing it that way (:
19:54:29 <latro`a> the IO way looks basically like imperative langs
19:54:44 <latro`a> while the PRG way hides the plumbing in a State-like monad
19:54:55 <wywy> latro`a: how is it hidden?
19:55:04 <latro`a> the generator?
19:55:09 <latro`a> do you know how State works?
19:55:31 <LordBrain> the documentation for the j language seems to use the word monad to mean unary prefix operator
19:55:53 <wywy> shachaf: well, I'm asking the question because I still have some hope for pure languages for doing this conveniently ;-)
19:56:00 <LordBrain> that sounds like a headache waiting to happen
19:56:10 <latro`a> wywy: Rand is quite convenient imo
19:56:13 <parcs`> wywy: there's a monad for that
19:56:27 <shachaf> wywy: You have to be explicit about it but it doesn't mean you have to pass it as a functiona argument everywhere.
19:56:31 <latro`a> when you want a random number, you just use one of the several functions for the task, and the generator updates accordingly
19:56:39 <thirsteh> "There's a monad for that" == "There's an app for that"
19:56:51 <latro`a> getRandom and getRandomR are the ones used to get single numbers
19:56:54 <wywy> shachaf: can you show me a good example?
19:57:33 <LordBrain> !hoogle getRandomR
19:57:34 <thirsteh> wywy: the definition of a pure function is that it always yields the same result for the same input. If your RNG changed state in the background that would no longer be true
19:57:52 <shachaf> makeRandInt :: Rand Int; makeRandInt = do { ... }; make2RandInts :: Rand (Int,Int); make2RandInts = do { x <- makeRandInt; y <- makeRandInt; return (x,y) }
19:57:52 <LordBrain> I think I forgot how to use the bots
19:58:00 <shachaf> LordBrain: It's OK.
19:58:11 <monochrom> yes, "monadic" can mean "1-ary", e.g., "monadic second order logic" the monadic refers to 1-ary predicates
19:58:55 <monochrom> "monadic second order logic" means you can say "for all 1-ary predicates P, ..."
19:59:09 <hpaste> latro`a pasted “random example” at http://hpaste.org/73817
19:59:14 <latro`a> ^@ wywy
19:59:35 <latro`a> (@ everyone else, yes I know that's liftM2 (,) getRandom getRandom)
19:59:42 <latro`a> (humor me)
19:59:57 <wywy> thirsteh: I know that ... but I don't want to write too much code in monadic style... but it seems random numbers will force me to do so?
20:00:13 <LordBrain> well, i dont object to overloading words generally, but now that monads are so popular in computing languages, the uses seem destined to clash
20:00:18 <latro`a> if it didn't, you'd be breaking referential transparency
20:00:20 <parcs`> latro`a: more like id =<< (,) $ getRandom !
20:00:21 <latro`a> so
20:00:27 <thirsteh> wywy: by definition, you have to; or you pass the generator around so that the inputs _aren't_ the same
20:00:30 <latro`a> lol parcs`
20:01:14 <monochrom> on the bright side, if everyone uses "monad" for something, people can no longer complain that it is a "scary" "mathy" "theoretical" word
20:01:30 <LordBrain> i mean 1-ary operator, and monad are both going to be used in the same context inevitably
20:01:30 <monochrom> just like no one complains about "class", "variable", "function"
20:01:45 <thirsteh> monad just sounds really complexy and mathemical-like
20:01:50 <latro`a> wywy, I think my example is pretty intelligible
20:02:00 <thirsteh> mathematical*
20:02:08 <latro`a> and is actually rather versatile (in that it is agnostic about how you get the random numbers)
20:02:35 <latro`a> (it is somewhat less versatile in that the numbers have to be the same type, but you can work around that too, with some type-foo)
20:02:54 <thirsteh> wywy: you can write a function that takes an integer as its input, and supply it with your randomly generated integer
20:03:04 <thirsteh> there's no reason that can't be pure
20:03:07 <latro`a> which is all that Rand does anyway
20:03:11 <thirsteh> yeah
20:03:14 <shachaf> Except not quite.
20:03:18 <shachaf> But the whole thing is irrelephant.
20:03:21 <latro`a> close enough
20:03:24 <latro`a> also
20:03:25 <latro`a> +1
20:03:29 <latro`a> someone else using irrelephant
20:03:51 <thirsteh> well, that's anything not pertaining to elephants
20:04:14 <LordBrain> I see that the monad class instance in haskell forced a sort of *->* kinded type, but that seems to me simply a sort of implementation choice about how to represent monad in the computer language than a property of monad as in category theory
20:04:16 <thirsteh> so most things really
20:04:34 <shachaf> LordBrain: Not really?
20:04:56 <LordBrain> is what i am saying true? or is it that *->* is actually much more natural than i perceive.
20:05:34 <wywy> latro`a: Do I need to import some module?
20:05:41 <shachaf> LordBrain: Would you say the same thing about Functor?
20:05:47 <latro`a> Control.Monad.Random
20:05:49 <LordBrain> yes
20:05:54 <latro`a> not sure if you also need to import System.Random
20:05:54 <LordBrain> same with functor
20:06:03 <latro`a> (neither of those are in base, so you'll need to install them)
20:06:21 <latro`a> (I have no idea why System.Random isn't in base btw)
20:06:33 <shachaf> LordBrain: When you say "F is a functor", it means that F turns an object x into an object F(x).
20:06:38 <wywy> Could not find module `Control.Monad.Random'
20:06:45 <latro`a> cabal install monadrandom
20:06:47 <latro`a> should work
20:06:48 <latro`a> iirc
20:07:28 <shachaf> LordBrain: Objects (i.e., "x"s) in Hask have kind *, so functors have kind * -> *
20:07:34 <shachaf> (Well, F(x)s also have kind *)
20:07:58 <parcs`> LordBrain: do you mean that the 'varying' parameter has to be lexicographically last in the parameter list?
20:08:03 <latro`a> incidentally
20:08:06 <latro`a> why does this need undecidableinstances
20:08:10 <latro`a> http://hackage.haskell.org/packages/archive/MonadRandom/0.1.8/doc/html/src/Control-Monad-Random-Class.html#MonadRandom
20:08:59 <pqmodn> > /query lambdabot
20:09:00 <lambdabot>   <no location info>: parse error on input `/'
20:09:02 <parcs`> latro`a: that module in particular doesn't, but the instances do
20:09:07 <latro`a> ah
20:09:24 <latro`a> but
20:09:27 <latro`a> they're not there
20:09:34 <latro`a> so undecidableinstances doesn't need to be on for that file
20:09:34 <wywy> latro`a: it works now
20:09:36 <LordBrain> well it seems to me we could have made the class *->*->* , so we can say it is a functor from blah to blah
20:09:57 <latro`a> wywy: you can change return to print and then foo is appropriate for main
20:09:58 <edwardk> LordBrain: you can generalize functors to other categories, monads to other categories, they work there. Functor in haskell is an endofunctor over the category of haskell types
20:10:34 <edwardk> its not the general purpose construction. if you want that, import it from my categories package ;)
20:12:25 * hackagebot machines 0.1 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.1 (EdwardKmett)
20:13:22 <wywy> latro`a: If I don't change return to print, how can I use it in main?
20:13:33 <latro`a> you'd have to add an IO () to the last line
20:13:40 <latro`a> but then you wouldn't see the numbers
20:18:54 <wywy> latro`a: I guess I need the exact code ...
20:19:03 <LordBrain> parcs`,  about the lexicographically last in the parameter list thing, if i understand you, yeah that seems to be a limitation of our implementation.. showing how we cant help but diverge a little, not all endofunctors on over haskell types are going to be enocdable as instances of functor, unless i am missing something.. I just want the clarity in my mind here.
20:19:10 <latro`a> just change the return to print and run the program a couple times
20:19:43 <latro`a> you can also do pair <- foo; print pair
20:19:44 <latro`a> in main
20:19:46 <wywy> latro`a: It won't compile: Couldn't match expected type `(a, a)' with actual type `()'
20:19:53 <latro`a> with return of course it won't
20:19:59 <latro`a> with print it willl
20:20:02 <latro`a> *will
20:20:52 <wywy> latro`a: It compiled with return, but can't compile with print
20:21:03 <latro`a> ...
20:21:05 <latro`a> oh
20:21:08 <latro`a> you have to fix the signature
20:21:12 <latro`a> remove the signature
20:21:37 <latro`a> the code with s/return/print is fine, it just has a different type (since main is always IO ())
20:22:52 <LordBrain> lets see.. if I have r::*->*->* i wanted a fmap:: (a->b) -> r a c -> r b c ....
20:23:02 <latro`a> can't have a functor with that kind
20:23:32 <latro`a> you can have a type constructor r :: * -> * -> * and then have r a be a functor, however
20:23:38 <LordBrain> right, but mathematically... there is a functor, is there not?
20:23:51 <latro`a> there is one, but writing it down would require something analogous to a type level lambda
20:23:51 <wywy> latro`a: it needs a type signature somewhere...
20:23:53 <latro`a> which we don't have
20:23:57 <latro`a> wywy: it doesn't
20:24:22 <latro`a> main = do {m <- getRandom; n <- getRandom; print (m,n)} will compile and run
20:24:29 <latro`a> without a signature
20:24:40 <latro`a> if you want a signature it's IO () like main always is
20:24:49 <parcs`> LordBrain: there's 'newtype Flip f a b = Flip (f b a)' with which you can have fmap :: (a -> b) -> Flip r c a -> Flip r c b
20:25:05 <LordBrain> yeah
20:25:37 <LordBrain> newtype... hmmm that means putting funky constructor tags
20:26:43 <shachaf> LordBrain isn't talking about Haskell endofunctors.
20:26:58 <latro`a> he called it fmap, so...
20:27:26 <shachaf> Yes, but he explicitly said it wasn't earlier. :-)
20:27:35 <latro`a> true
20:29:12 <LordBrain> what makes it not a haskell endofunctor?  both r a c and r b c are in the hask category... am i missing something?
20:29:44 <LordBrain> i mean it's still mapping haskell types
20:29:58 <LordBrain> i must be confused by the terminology here
20:30:16 <latro`a> there's not a type function r a c -> r b c
20:30:29 <latro`a> or rather there isn't one that's reified, more or less
20:30:44 <latro`a> if you make the parameter last
20:30:47 <latro`a> r c a -> r c b
20:30:53 <latro`a> then "r c" can be a Functor in haskell's sense
20:31:09 <LordBrain> right
20:31:10 <latro`a> but to put it in the first position you have to first move it with Flip or something similar
20:32:10 <latro`a> note that this means that, for example, you can't make a Functor out of Either which acts on Lefts
20:33:08 <Saizan> in classical linear logic, can you think of the dual of A as the type of continuations accepting A?
20:34:06 <edwardk> LordBrain: by 'haskell functor' folks are talking about instances of the Functor class. You can make a more general functor type in haskell. However, to do so you have to go beyond haskell 98. This is why Functor is the way it is. its as correct as it can be given the constraints it is placed under by the language it was implemented in
20:34:23 <LordBrain> oh i know edwardk
20:34:42 <LordBrain> yeah ok, that is basically what i wanted to clarify in my mind
20:35:01 <shachaf> I hear edwardk is a professional clarifier.
20:35:01 <LordBrain> same with monad
20:35:21 <edwardk> shachaf: *groan*
20:35:29 <LordBrain> teacher?
20:35:36 <edwardk> shachaf: we're officially just s&p capital iq now ;)
20:35:50 <shachaf> edwardk: Is that a recent thing?
20:36:16 <edwardk> LordBrain: i did the adjunct lecturer thing for a while, but i'm i write tools for quants. shachaf's joke was because the company's name used to be clarifi.
20:36:30 <Ralith> hah
20:36:31 <LordBrain> oh
20:36:56 <shachaf> An adjunct lecturer is someone who lectures on adjunctions, right?
20:37:05 <edwardk> shachaf: it was 'capital iq' officially even before i started, but they shuffled and rebranded to put the s&p name on it, when they took it out from under s&p or some such
20:37:15 <edwardk> shachaf: clearly
20:37:24 <edwardk> or maybe thats an adjoint lecturer
20:37:28 <edwardk> i always get them confused
20:38:54 <shachaf> edwardk always gets a bit forgetful when he gets on that topic.
20:39:47 <edwardk> are you sure? most of my lectures are free
20:40:32 <johnw> edwardk: a question on lenses, such as "foo/bar" ^. _filename.  Why is that better than just filename "foo/bar"?
20:40:56 <edwardk> johnw: now write back to it
20:41:09 <edwardk> or edit it
20:41:13 <T_S_> Hi all. Instead of StateT s m  a , I want something like StateT s1 s2 m a, where the type of the underlying state can change. This is for something like a parser where my token type, s,  evolves . Is there a preferred package for this on hackage already?
20:41:29 <johnw> what does that look like?
20:42:18 <edwardk> _filename <>~ "baz"     $ "foo/bar"   ==> "foo/barbaz"
20:42:33 <edwardk> over filename (do something with it here) "foo/bar"
20:42:50 <johnw> ("foo/bar" ^. _filename) .~ "baz" == "foo/baz"?
20:42:55 <edwardk> _filename .~ "baz" $ "foo/bar"    => "foo/baz"
20:43:11 <edwardk> no
20:43:35 <edwardk> you say the lens you are editing on the left of the .~
20:44:02 <johnw> so, "foo/bar" ^. _filename to get the filename
20:44:09 <latro`a> T_S_, can't you put an Either in the s?
20:44:14 <johnw> but _filename .~ "baz" $ "foo/bar" to edit it?
20:44:15 <latro`a> StateT (Either s1 s2) m a
20:44:17 <edwardk> set _filename "baz" "foo/bar"   gives you "foo/baz"
20:44:20 <edwardk> yes
20:44:37 <edwardk> now, on its own, boring, right?
20:44:39 <johnw> set a b c == a .~ b $ c?
20:44:51 <johnw> well, that's not very boring at all
20:45:37 <johnw> I can write: modifyExt = (_extension .~)
20:45:41 <edwardk> rewrite (_2.at "hello"._filename) (`lookup` someMap)
20:45:47 <johnw> or: modifyExt = flip (_extension .~)
20:45:51 <lightquake> edwardk: what's the difference between adjust and over?
20:45:53 <johnw> and have: modifyExt "foo.cpp" ".h"
20:46:26 <edwardk> that would go into a tuple, grab the second field, go into a map at that position, edit the entry for 'hello' in the map, which points to a file path, and then change the filename in that path, by looking it up in a map.
20:46:45 <edwardk> lightquake: is adjust still in there? i renamed it to over at some point
20:46:55 <johnw> actually, that flip call must be wrong
20:47:06 <lightquake> i'm probably using an old version, then
20:47:13 <edwardk> lightquake: it became over so i could use 'under' for the equivalent under isomorphism
20:47:17 <johnw> modifyExt x = (_extension .~ x)
20:47:18 <lightquake> haha
20:47:27 <lightquake> ah, yeah, i'm using 2.0
20:47:37 <edwardk> and to match the over/under combinators from control.newtype
20:47:45 <johnw> modifyExt x y = (_extension .~ y) x
20:47:51 <johnw> there, that's what I mean
20:47:52 <edwardk> try pulling. 2.5 is quite a ways forward from that =)
20:48:15 <johnw> so, can you tell me once again how a Lens like this relates to a Comonad?
20:48:51 <edwardk> so the lens laws exist: http://hackage.haskell.org/packages/archive/lens/2.5/doc/html/Control-Lens-Type.html#g:1
20:49:09 <edwardk> but how do you know you have the right laws?
20:49:14 <edwardk> you might have missed some!
20:49:19 <edwardk> or have specified something to strict
20:49:23 <edwardk> er too
20:49:46 <edwardk> turns out we can derive the lens laws ~ 3 different ways and you get equivalent definitions each time
20:49:50 <shachaf> "Why is it a Lens Family?" isn't supposed to be a link, is it?
20:49:57 <shachaf> Or maybe it's supposed to be a non-broken link.
20:50:08 <edwardk> shachaf: woops
20:50:52 <edwardk> fixed in head
20:51:06 <edwardk> you can't put hyperlinks with arbitrary text in haddock =(
20:51:10 <shachaf> That means you convinced yourself that it's fixed now, right?
20:51:13 <T_S_> Then I am stuck using s1 and s2. I want to compose and use s1 s2 then s2 s3 etc.
20:51:14 <johnw> your definition of type Lens looks like the definition of >>=
20:51:22 <johnw> (in the mirrored lens article)
20:51:34 <edwardk> johnw: familiar with traverse?
20:51:39 <johnw> a little
20:51:45 <edwardk> @type Data.Traversable.traverse
20:51:46 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:51:51 <edwardk> compare that with
20:52:05 <edwardk> type Traversal a b c d = forall f. Applicative f => (c -> f d) -> a -> f b
20:52:26 * hackagebot parsergen 0.2.0.0 - TH parser generator for splitting bytestring into fixed-width fields  http://hackage.haskell.org/package/parsergen-0.2.0.0 (JasperVanDerJeugt)
20:52:29 <latro`a> T_S_, that's gonna be necessary anyways
20:52:32 <edwardk> traverse :: Traversable t => Traversal (t a) (t b) a b
20:52:37 <latro`a> State doesn't let you change the state type
20:52:49 <latro`a> and really can't, otherwise you don't have a monad
20:52:56 <edwardk> a Lens is a Traversal that doesn't need the full power of the Applicative, it merely needs the Functor.
20:53:10 <edwardk> that turns out to be enough to show it can only target one thing
20:53:23 <edwardk> and moreover, that it _has_ to target one thing
20:53:41 <johnw> and the connection to Comonad?
20:53:44 <edwardk> the other conditions are more that you don't do anything else stupid to the values ;)
20:53:46 <johnw> i see the use of Store in your article
20:54:28 <edwardk> if we use an indexed store we can get something just as powerful as the lens families i use in lens, but without the overloading
20:54:36 <edwardk> a -> Store c d b
20:54:51 <edwardk> where data Store c d b = Store (d -> b) c
20:55:11 <edwardk> is like the Store you know except s is split into two types
20:55:15 <edwardk> (its only a comonad when c = d)
20:55:32 <edwardk> it is however, applicative regardless
20:56:01 <edwardk> now, if we run a lens using that choice of functor
20:56:03 <edwardk> we get
20:56:20 <edwardk> ((c -> Store c d b) -> a -> Store c d b)
20:56:26 <edwardk> we can pass 'Store id' for the first argument
20:56:30 <edwardk> er
20:56:40 <edwardk> ((c -> Store c d d) -> a -> Store c d b)
20:56:48 <edwardk> passing it Store id, yields a -> Store c d b
20:57:20 <T_S_> I was looking at  http://blog.sigfpe.com/2009/02/beyond-monads.html and and wondering if something similar is on hackage with various class instances defined
20:57:48 <edwardk> the properties that that version need to satisfy (if you just used it as a traditional lens) type Lens a b = a -> Store b a    would be the properties of a comonad coalgebra.  that is to say its a coalgebra that also respects the comonad operations
20:58:12 <edwardk> T_S_: "sort of"
20:58:41 <edwardk> T_S_: sigfpe used the 2 parameter indexed monads. tekmo has packaged up the 1 parameter indexed monads that subsume them
20:58:50 <T_S_> your monad-param package?
20:59:03 <edwardk> i've been meaning to put up a new indexed monad package myself, but i want 7.6 to be here first
20:59:20 <edwardk> because i can't make indexed monad transformers without 7.6's features
20:59:31 <T_S_>  what's tekmo's called?
20:59:32 <edwardk> my monad-param package is ancient and crappy ;)
20:59:52 <edwardk> http://hackage.haskell.org/package/index-core
21:00:28 <edwardk> when we get the new platform i'll push out a package of proper indexed monads, indexed comonads, indexed comonad transformers, etc.
21:00:47 <T_S_> thanks. never would have found that one.
21:08:04 <Saizan> so the indexed state monad would be State a i = s i -> exists j. (s j, a j)
21:09:48 <edwardk> why exists?
21:11:10 <Saizan> what else?
21:11:36 <edwardk> now i need to go work back through the single argument indexed monad
21:11:37 <edwardk> =)
21:12:03 <Saizan> this is the single argument one, i thought?
21:12:23 <edwardk> might be, i haven't worked it out in a while
21:12:49 <edwardk> just surprised me
21:13:09 <edwardk> i know you _can_ implement them with the single argument, and the reasons why its good
21:13:12 <Saizan> (!>=) for this monad would specialize to the two-argument bind
21:13:40 <edwardk> just haven't used it
21:13:40 <edwardk> at least not for the traditional monads
21:14:19 <Saizan> yeah, this is the first time i've thought about ones that were't Free something
21:14:52 <edwardk> i have an example i use of one with support for those generalized debruijn indices i like
21:14:57 <edwardk> but thats a different beast
21:16:04 <edwardk> hrmm the exists there makes me want to cps that thing ;)
21:17:28 <shachaf> Edward "continuation passin'" Kmett
21:17:54 <edwardk> i rather preferred "trembling categories"  from the other day ;)
21:18:17 * shachaf wonders whether "trembling category" is a thing.
21:18:55 <Saizan> we already have a tuple, another field is not that bad :)
21:19:47 <edwardk> true
21:20:21 <edwardk> just annoying to have to explicitly construct a different data type
21:22:41 <edwardk> damnit, now i want to go work up the whole transformer library of these
21:26:54 <Saizan> heh :)
21:27:23 <Saizan> i wonder if there's anything you can make a 2-style instance but won't fit the 1-style typeclass
21:27:44 <edwardk> the := hack lets you model the 2-style with the 1-style
21:28:00 <edwardk> i'd be shocked if there was anything that didn't fit
21:28:05 <edwardk> the encoding is pretty simple
21:28:08 <shachaf> edwardk: Your De Bruijn thing was for highest-bit-set, right?
21:28:20 <edwardk> lowest
21:28:38 <edwardk> but thats predetermined by the preprocess
21:28:47 <Clint> is there a flag to have ghc scream at me if i try to use 0x100000000 as a Word32 constant?
21:28:51 <edwardk> you are just looking up the only set bit ;)
21:30:02 <roconnor> what does darcs rebase even mean?
21:33:31 <Cale> roconnor: no such command 'rebase'
21:34:06 <dolio> They're talking about adding it.
21:35:36 <roconnor> Cale: http://www.reddit.com/r/darcs/comments/yxv2o/rebase_merged_into_head/
21:38:38 <mk> Cale: so put and get allow you to (with the help of do notation) use bind without having to laboriously define special a->m a functions - is that about right?
21:38:58 <Cale> um...
21:38:59 <shachaf> put and get have nothing to do with (>>=)
21:39:03 <johnw> how do I create a Store?
21:39:13 <Cale> You mean define functions s -> (s,a)?
21:39:15 <johnw> what's the value constructor?
21:39:15 <shachaf> do notation is a more convenient syntax for (>>=), but it has nothing to do with put and get
21:39:30 <johnw> I want to make a value of type Store (Map k v) v
21:39:40 <johnw> Store (fromList [("foo", "fooval"), ("bar", "barval")]) is not it
21:39:54 <shachaf> Wait, what's Store here?
21:40:05 <johnw> Control.Comonad.Store.LAzy
21:40:09 <johnw> .Store
21:40:13 <Saizan> Store s a = Store (s -> a) s
21:40:20 <Cale> mk: By binding together a bunch of gets and puts (along with perhaps some additional logic), you can write the equivalent of any State s a computation you want without using the S constructor we defined
21:40:23 <roconnor> johnw: http://hackage.haskell.org/packages/archive/data-lens/2.10.2/doc/html/src/Data-Lens-Common.html#mapLens
21:40:25 <shachaf> Oh. Then it's what Saizan said.
21:40:30 <shachaf> The constructor is Store.
21:40:39 <Cale> mk: and it comes out looking a bit like imperative code
21:40:41 <shachaf> It takes a function and a value.
21:40:42 <mk> Cale: yes, roughly - and I suppose embedding them into a->m a functions, though in this case it's a->State a, aka a-> ( s->s,a), if I've got things right?
21:40:50 <johnw> oh, then it doesn't take a map, it takes a function
21:40:55 <edwardk> johnw: lets look at store.  data Store s a = Store (s -> a) s
21:41:04 <roconnor> that code create a Store (Map k v) (Maybe v)
21:41:04 <shachaf> But "Store" isn't exported from Control.Comonad
21:41:08 <shachaf> It exports StoreT
21:41:16 <johnw> look above
21:41:17 <shachaf> You can use "store" instead.
21:41:19 <johnw> i gave a much longer import name
21:41:32 <shachaf> Control.Comonad.Store. Whatever it is that exports it.
21:41:35 <edwardk> you can think of 's' as a position. and th function (s -> a) as something that gives a value for all possible positions on demand
21:42:12 <roconnor> johnw: the constructor "Store" isn't exported use "store" instead.
21:42:23 <johnw> ah, ok
21:42:58 <edwardk> johnw: i recommend just writing the comonad out locally by hand at first, getting used to it, then switching tothe comonad-transformers version
21:43:11 <johnw> i did write it out
21:43:21 <johnw> now I need to actually use of these things, I need to get out of Abstract Land
21:43:30 <edwardk> heh
21:43:31 <roconnor> johnw: state works the same way in transformers.
21:43:53 <roconnor> johnw: State isn't exported because now State is just an alias for StateT Identity
21:44:07 <roconnor> johnw: similarly Store is an alias for StoreT Identity
21:44:58 <mk> Cale: right, yes. I was thinking of it as just an extra way to initiate and terminate a monadic value (as one usually would with runState), but then I came back to it and saw that things were happening, but without having to define numerous functions
21:45:23 * shachaf thinks mk is a bit confused.
21:45:48 <mk> shachaf: it's possible, but it's usually helpful if you point out why you think so ;)
21:46:09 <johnw> so how do I write this value construction
21:46:22 <johnw> store M.lookup (fromList [("foo", "fooval"), ("bar", "barval")]) is not right
21:46:33 <roconnor> johnw: but you really probably want  Store (Map k v) (Maybe v)
21:47:12 <roconnor> since with Store (Map k v) v, you have the problem that peek empty foo will have nothing to return.
21:47:13 <edwardk> johnw: store $ \v -> M.lookup v (fromList [("foo", "fooval"), ("bar", "barval")])
21:47:35 <johnw> (\v -> M.lookup v) != M.lookup?
21:47:46 <johnw> oh, i see
21:47:58 <johnw> the stored value is in the lambda
21:48:06 <edwardk> anyways thats still wrong
21:48:34 <edwardk> what are you trying to build type wise?
21:48:41 <roconnor> johnw: take a peek at http://hackage.haskell.org/packages/archive/data-lens/2.10.2/doc/html/src/Data-Lens-Common.html#mapLens
21:48:47 <roconnor> for inspiration
21:48:50 <MostAwesomeDude> Q: Does somebody already have a convolution on Arrays somewhere common? If not, I can hammer my own out, but I figured I'd ask first. (I can't use Repa because my types are too fancy.)
21:49:16 <johnw> here's what I have right now:
21:49:18 <johnw> https://gist.github.com/3495044
21:49:25 <johnw> and I get a pretty hideous type error from hthat
21:49:46 <johnw> ah, calling the wrong foo
21:49:50 <johnw> that's one hideous error down :)
21:50:38 <edwardk> extract <<= seek "foo" st can be simplified to peek "foo" st
21:50:58 <johnw> the call to peek gives me: Couldn't match type `Map k' with `[]'
21:51:12 <johnw> wrong argument order?
21:51:42 <johnw> :t peek
21:51:43 <lambdabot> Not in scope: `peek'
21:51:49 <johnw> peek :: ComonadStore s w => s -> w a -> a
21:52:01 <edwardk> yes, so peek expects you to pass it a whole map
21:52:04 <johnw> I don't know how to get my "foo" into w a
21:52:08 <shachaf> edwardk: seek turns into peek?
21:52:13 <edwardk> i have no idea what you are trying to do here =)
21:52:23 * shachaf would think that (extract <<=) would be an identity.
21:52:25 <edwardk> shachaf: seeking is extended peeking
21:52:26 <johnw> I want to seek the store to the entry with key value "foo"
21:52:34 <johnw> then I want to extract the value relating to that key
21:53:04 <roconnor> johnw: you will want a (Store k v)
21:53:14 <johnw> I'm reading this from an article I found: "A value of type Store βα represents a collection of values of type α, where each element of the collection is indexed by a value of β. There is one element for every β. The collection is represented by the peek component of type β → α. Within the collection there is one special “selected” location."
21:53:15 <edwardk> johnw: type MapStore k v = Store k (Maybe v)
21:53:21 <edwardk> is what you probably want
21:53:25 <roconnor> right
21:54:16 <johnw> but still, I can't just pass "foo" to peek
21:54:17 <Cale> mk: It's also best not to confuse the state monad with other monads. The whole idea of a "monadic value" bereft of context is a bit of a funny thing, because there are not so many interesting values which belong to all monads. (Perhaps you could consider all the stuff which is in the image of return, but in some sense, all those are trivial)
21:54:23 <johnw> it has to be a "w a", not an "a", right?
21:54:23 <roconnor> and then mkMapStore :: Map k v -> k -> Store (Maybe v) ; mkMapStore mp k = Store (Map.lookup mp) k
21:54:41 <roconnor> @type peek
21:54:42 <lambdabot> Not in scope: `peek'
21:54:48 <johnw> peek :: ComonadStore s w => s -> w a -> a
21:55:01 <edwardk> w a is the store
21:55:17 <mk> Cale: right, I meant a state monadic value
21:55:23 <roconnor> peek :: s -> Store s a -> a
21:55:28 <Cale> right, or just "state computation"
21:55:41 <roconnor> johnw: the first argument to peek is the "s" type
21:55:52 <roconnor> the second argument is the store
21:56:24 <edwardk> johnw: https://gist.github.com/3495044#comments
21:56:37 <roconnor> johnw: I'm the author of said article :D
21:56:43 <mk> though I have trouble thinking of all monadic values as computations, since much of the time they seem to be the results of computations
21:57:02 <MostAwesomeDude> mk: Consider the types of Reader or
21:57:06 <MostAwesomeDude> Er, or State.
21:57:18 <mk> there's also trivial, which never represents a computation, but rather a refusal to compute
21:57:37 <Cale> Well, it's a computation for a very boring computer
21:57:50 <johnw> roconnor: thank you, I've really enjoyed it so far
21:57:56 <roconnor> :)
21:57:57 <mk> MostAwesomeDude: yeah, I have much less trouble seeing those as computations, since you pull functions out of them
21:58:10 <edwardk> johnw: that comment on your gist help?
21:58:28 <Cale> Different monads are like different choices of a model of computation or more concretely, different choices of computer.
21:58:33 <mk> Cale: by boring computer, do you mean "inert slab of stone"?
21:58:36 <Cale> yes
21:58:40 <Cale> exactly :)
21:58:47 <johnw> still trying
22:00:35 <Hadaka> whee, my first ghc compilation seemed to go fine - the only different files were the package hashes and the missing documentation as I didn't have the documentation tools installed
22:01:04 <mk> I'm roughly on board with the "model of computation" part, though I'm thinking of it more like "figure out what your computation/function needs in order to execute, and figure out what it produces; that will tell you what 'type' of computation you're dealing with"
22:01:23 <Cale> mk: But in more down-to-earth terms, the Monad class is just a description of a shape that shows up in many library APIs -- a pattern that we've decided to give a name to.
22:01:35 <johnw> is, extract <<= seek "foo" st, incorrect?
22:01:37 <johnw> it doesn't type check
22:01:46 <johnw> while print $ extract st does, and print $ peek "foo" st does
22:02:02 <johnw> I wish ghci supported everything lambdabot does..
22:02:02 <edwardk> you need to extract (seek "foo" st")
22:02:11 <johnw> isn't there a cobind?
22:02:15 <edwardk> sure
22:02:20 <edwardk> but binding to extract is id ;)
22:02:27 <edwardk> so you still wind up with a comonadic value
22:02:29 <edwardk> which can't print
22:02:29 <shachaf> Just like >>= return
22:02:32 <edwardk> because it has a function in it
22:02:34 <Cale> mk: and there's a bunch of stuff which can be written to work in an arbitrary monad, stuff like sequence :: (Monad m) => [m a] -> m [a]
22:02:38 <johnw> ohh
22:02:49 <Cale> mk: and we save ourselves the trouble of writing that stuff out multiple times
22:02:59 <edwardk> you can extend extract all you want it doesn't get you anywhere ;)
22:03:07 <johnw> what does cobinding look like in practice?
22:03:34 <Cale> That's really what monads are about -- not having to write sequence and mapM and so on over and over
22:03:39 <mk> Cale: what just happened there, with sequence?
22:03:48 <Cale> sequence [] = return []
22:04:01 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:04:14 <hpaste> edwardk pasted “for johnw” at http://hpaste.org/73818
22:04:19 <mk> Cale: what's it for?
22:04:20 <edwardk> johnwL like that ;)
22:04:39 <johnw> where is the cobinding taking place?
22:04:43 <Cale> sequence takes a list of actions, and gives an action which will run each one in turn, and give a list of the results
22:04:47 <mk> oh, nevermind
22:04:49 <mk> right
22:04:53 <edwardk> everywhere you see extend
22:04:56 <edwardk> extend is 'cobind'
22:05:01 <Cale> and so it acts like a sort of primordial simple loop
22:05:08 <edwardk> just not written infix
22:05:15 <Cale> If we can decide ahead of time what our loop iterations will be
22:05:19 <Cale> then sequence will glue them together
22:05:26 <Cale> So we can write:
22:05:43 <Cale> mapM f xs = sequence (map f xs)
22:05:49 <johnw> can you show me a one-liner that uses <<=?
22:05:49 <Cale> or perhaps more suggestively
22:06:01 <Cale> forM xs f = mapM f xs
22:06:07 <Cale> This acts like a for-each loop
22:06:11 <Cale> in an arbitrary monad
22:06:17 <edwardk> extend blur myimage ;)
22:06:33 <Cale> forM [1..5] $ \n -> print n
22:06:46 <johnw> i can't figure out what the arguments to <<= would be, even looking at the type
22:06:47 <edwardk> seek = extend . peek
22:06:55 <johnw> is "w a" my store?
22:07:01 <edwardk> yes
22:07:27 <edwardk> johnw: say you wanted to peek at several values in the store before returning your answer
22:07:48 <Cale> mk: If you try that in ghci, you'll see that it prints the numbers 1 through 5 and then returns a list of the results of each print, which are all ()
22:07:56 <edwardk> lets get away from a map because it make a cruddy store and try something with an array where you expect to hit more often
22:08:25 <edwardk> lets make up a type, data Pointer i e = Pointer (Array i e) i
22:08:34 <edwardk> we can define extract for it, just like with store
22:08:34 <Cale> mk: since this sort of case comes up often enough where we don't care about the results, there are also sequence_, mapM_ and forM_ which discard the results
22:08:35 <johnw> this works: extract (peek "bar" <<= st)
22:08:43 <johnw> no, let's not leave the map yet
22:08:52 <johnw> moving on to other examples just confuses the living hell out of me
22:09:02 <edwardk> well, i just want something where it makes more sense to move 'relative' to the current location
22:09:03 <Cale> But you can also try something like  forM [1..3] $ \n -> do print n; getLine
22:09:10 <johnw> and this works: extract (peek "foo" <<= peek "bar" <<= st)
22:09:27 <edwardk> given that you are at "foo" you don't tend to 'jump' to bar by making simple ends to foo
22:09:32 <Cale> mk: (oh, btw, you'll need to import Control.Monad)
22:09:32 <roconnor> edwardk: you can append to strings
22:09:35 <johnw> but that gets me "bar", not "foo"
22:09:37 <edwardk> roconnor: true
22:09:38 <mk> "not in scope: `forM' ?
22:09:45 <mk> ah
22:09:46 <Cale> right
22:09:48 <roconnor> edwardk: even put a '/' in between
22:09:51 <edwardk> johnw: as it should
22:10:01 <edwardk> the first one overwrote every entry of the map with bar
22:10:03 <johnw> print $ extract (peek "foo" <<= peek "bar" <<= st) => "barval"
22:10:23 <johnw> how did it overwrite them?
22:10:25 <edwardk> rather ir even overwrote entries that aren't there ;)
22:10:43 <edwardk> it just said, no matter what state you give me i'm going to ignore you and just give you the answer for "bar"
22:11:02 <johnw> so peek "bar" returns a Store that only has bar's answer?
22:11:42 <edwardk> peek "bar" mystore returns a single answer, it ignores the stored choice of key in mystore and just looks at "bar"
22:12:08 <johnw> but shouldn't the peek "foo" it's extended to do a seek "foo" in that store?
22:12:17 <edwardk> when you extend (peek "bar") you get something that no matter what s you give it, will just throw it out, and call your function with "bar"
22:12:26 <johnw> ah, interesting
22:12:31 <edwardk> it did, but its boring to do anything after you peek/seek ;)
22:12:44 <edwardk> peeks and seeks on the other hand do 'relative movement'
22:12:44 <johnw> so what does extending mean here?
22:12:52 <johnw> "locking down" to the map to a single entry?
22:12:58 <edwardk> peeks (+1) shifts everything in the store by 1
22:13:00 <johnw> oh
22:13:09 <edwardk> or rather looks at the entry one above you in the store
22:13:15 <Cale> mk: So what sequence does in the IO monad is fairly intuitive. Let's look at what happens in the list monad
22:13:15 <edwardk> while seeks shifts the entire store
22:13:26 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
22:13:27 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
22:13:29 <edwardk> the _relative_ motions are interesting
22:13:34 <bulsa11> Is there any status about nubOrd in ghc? I just found two closed tickets in the bugtracker that look abandoned...
22:13:41 <edwardk> those you can extend all day ;)
22:13:43 <Cale> mk: In the list monad, "running" a list means to pick an element from it in all possible ways
22:13:58 <edwardk> lets say you had Store (Int,Int) Color
22:14:08 <Cale> mk: So sequence "runs" each of the lists, picking one element from each of them in all possible ways
22:14:22 <edwardk> the 's' would be a position, the answer would be the output color
22:14:28 <Cale> mk: which computes a Cartesian product :)
22:14:48 <edwardk> then you could do things like peek at the current color for the pixel above you, the one below you, etc. and average them, yielding a single color
22:15:13 <Cale> mk: In a parsing monad, sequence would compute the concatenation of a bunch of parsers
22:15:18 <edwardk> when you extend this action that knows how to look around relative to the current position you get a whole new image, stitched together by running the preceding computation everywhere
22:15:22 <johnw> I tried to "peek (++"z")", to look at "barz", but it fails to type check
22:15:33 <edwardk> peeks (++"z")
22:15:39 <Cale> mk: Still here?
22:15:42 <edwardk> peeks is the relative function
22:16:09 <johnw> extract (peeks (++"barz") <<= peek "bar" <<= st) => "barval"
22:16:10 <edwardk> analgous to how asks is the 'relative' version of ask that takes a function and gets takes a function
22:16:13 <johnw> shouldn't it be barzval?
22:16:16 <johnw> oops
22:16:29 <johnw> extract (peeks (++"z") <<= peek "bar" <<= st)
22:16:31 <johnw> still prints barval
22:16:33 <johnw> not barzval
22:16:38 <edwardk> no, once you peek, any further extending is going to have boring interactions with the store ;)
22:16:47 <johnw> why is that?
22:17:14 <mk> Cale: yep, sorry, reading up
22:17:14 <edwardk> because thats what the types force it to do? =)
22:17:18 <roconnor> peek cares not for the selected location
22:17:20 <johnw> I tried this:
22:17:21 <johnw>   print $ peek "bar" st
22:17:21 <johnw>   print $ peeks (++"z") st
22:17:21 <johnw>  
22:17:29 <johnw> and the last peeks got "Nothing"
22:17:36 <johnw> so I'm still thoroughly confused
22:17:36 <edwardk> sure, you don't have a barz
22:17:40 <johnw> i do now
22:17:40 <roconnor> and the selected location is what makes this comonad a comonad
22:17:47 <johnw> https://gist.github.com/3495176
22:17:51 <edwardk> the second one is peeking ar fooz
22:17:52 <edwardk> er at fooz
22:17:56 <mk> Cale: going from lists to parsers is a bit of a jump
22:18:01 <edwardk> er bazz
22:18:15 <Cale> mk: It's actually not that crazy a jump, and I'll show you why if you have some time :)
22:18:23 <edwardk> st is a store with selected position "baz"
22:18:23 <johnw> now I have a foozval too, and that's not being printed either
22:18:30 <Cale> We should do that in #haskell-overflow though
22:18:40 <edwardk> peeks will look relative to the current key.
22:18:47 <mk> sure
22:19:07 <edwardk> 'st' doesn't magically change values between different attempts to use it, each time you start a new sequence of actions from st, you start over with "baz" being the selected key
22:19:29 <johnw> i see
22:19:37 <johnw> so why doesn't line 2 in foo' work?
22:19:43 <edwardk> peek "foo" st, is aking the function you have from a key to a value, and just passing it "foo" ignoring the curent value
22:20:09 <edwardk> lets step through what it means
22:20:38 <edwardk> lets start with peek "bar" <<= st    or peek "bar" st
22:20:38 <johnw> Gist won't let me delete the first file, so just ignore it
22:20:45 <johnw> ok
22:22:09 <edwardk> so peek "bar" <<= st    is seek "bar" st, it generates a new store that ignores whatever st you feed it, and replaces it with "bar".
22:24:31 <edwardk> so when you peeks (++"z") -- thats all well and good, but the peeking you do just passes a different s to the function, whereupon it is promptly dropped on the floor, stepped on, and replaced with "bar"
22:24:36 <johnw> it replaces it with bar, or with the value related to bar?
22:24:37 <edwardk> peek s (Store f _) = f s
22:24:45 <edwardk> thats all it is
22:25:06 <johnw> oh
22:25:26 <johnw> peeks "bar" st = store (\_ -> "barval") "bar"?
22:26:03 <johnw> well, Just "barval"
22:27:32 <edwardk> peek "bar" (Store f "baz") =           f "bar"    then when you extend that you get  Store (\_ -> f "bar") "baz"
22:27:55 <johnw> gotcha
22:27:58 <edwardk> then you go and ask it what the value of that function is at "bazz"
22:28:05 <edwardk> and of course it tells you f "bar" =)
22:28:06 <johnw> and f "bar" = "barval", so it's equivalent
22:28:20 <johnw> to const "barval"
22:28:30 <startling> does anyone know of a Tree somewhere like data Tree k a = Tree (Map k (Tree k a)) (Maybe a) ?
22:28:58 <startling> well, it could be just Tree (Map k (Tree k a)) a, too. the Maybe can be part of a
22:29:00 <johnw> peek x st = store (const (f x)) x
22:29:05 <edwardk> now, lets say you had something more combinational, where say, the values aren't strings but instead numbers
22:29:15 <edwardk> not quite
22:29:26 <edwardk> peek x (Store f _) = f x
22:29:35 <edwardk> it doesn't build a store it builds a value
22:30:01 <johnw> oh, it's the extension that makes it a new store
22:30:02 <johnw> of course
22:30:09 <edwardk> extend (peek x) (Store f y) = Store (\_ -> f x) y
22:30:18 <edwardk> its when you extend relative motion that its interesting
22:30:25 <johnw> how so?
22:30:34 <johnw> extend (peeks x) (Store f y) = ...?
22:30:42 <johnw> extend (peeks g) (Store f y) = ...?
22:30:52 <edwardk> peeks f (Store g y) = g (f y)
22:30:57 <edwardk> so when you extend it
22:31:14 <edwardk> extend (peeks f) (Store g y) = Store (g . f) y
22:31:20 <johnw> aha
22:31:31 <edwardk> but you don't have to just use relative motion once
22:31:40 <edwardk> you can do it multiple times, and get an answer by combining those
22:32:08 <johnw> i see now
22:32:14 <edwardk> foo st = peeks (+1) st + peeks (subtract 1) st
22:32:17 <edwardk> then you can extend foo
22:32:19 <johnw> you can compose relative peeks
22:32:24 <johnw> but once you use an absolute peek it's fixed
22:32:28 <edwardk> and it'll give you the sum of the entry one above and one below you
22:32:34 <edwardk> if you did
22:32:50 <johnw> extract (peeks (++"z") <<= peeks (++"z") <<= st) = "barzzval"
22:32:55 <johnw> for a map starting at "bar"
22:32:56 <edwardk> foo st = (peeks (+1) st + peeks (subtract 1) st) / 2
22:33:17 <edwardk> and extended that, the entries would be a 'blur' of the original entries
22:33:19 <edwardk> yep
22:33:41 <edwardk> seeks (++"y") $ seeks (++"z") st
22:33:49 <gadtfly> My local copy of pointfree is not terminating given 'pointfree "splitBy2 s  = take 2 s : splitBy2 (drop 2 s)"'.  I'm wondering a) if this is an expected behaviour of pointfree, because it's always been snappy for me before, and b) what would it's answer be or is there a better way to express this.
22:33:58 <edwardk> seeks is making relative movements
22:34:19 <shachaf> @pl splitBy2 s  = take 2 s : splitBy2 (drop 2 s)
22:34:19 <lambdabot> splitBy2 = fix (ap ((:) . take 2) . (. drop 2))
22:34:22 <mm_freak> finally arrived at blurring filters =)
22:34:35 <edwardk> mm_freak: we took a few detours =)
22:34:57 <mm_freak> dunno, i didn't follow the whole workshop =)
22:35:15 <LordBrain> After seeing the topic so much discussed, i decided to educate myself on lenses.  And then i found a paper on edit-lenses: http://dmwit.com/papers/201107EL.pdf   I wonder if someone could help me tho with a notation question.  Page 4 of that pdf has equations with long vinculums over the top... what do the vinculum signify?
22:35:17 <gadtfly> Okay, given that I think I'll stick with my version.  Strange my pointfree was choking on it.
22:35:18 <johnw> how do I seek in all this?
22:35:24 <johnw> do I have to: let st' = seek "foo" st?
22:35:39 <edwardk> LordBrain: edit lenses and the lenses we're talking about are at best tangentially related
22:35:46 <edwardk> johnw: yes
22:35:59 <LordBrain> edit lenses are not a generalization?
22:36:07 <edwardk> LordBrain: neither one subsumes the other
22:36:12 <pqmodn> gadtfly: i can't speak from experience, but i've heard several members of this channel complain than the version of pointfree from cabal often hangs
22:36:14 <edwardk> they are just different
22:36:24 <pqmodn> gadtfly: from hackage rather
22:36:27 <Hadaka> hmmh, I compile haskell, it has paths of the form lib/ghc-7.4.1/packagename
22:36:30 <johnw> so really this is like a data set with a cursor
22:36:41 <Hadaka> I compile haskell platform, it has paths of the form lib/packagename/ghc-7.4.1
22:37:09 <edwardk> the original notion of a functional reference-style lens was briefly mentioned as a 'very well behaved lens' by pierce. but the edit lens stuff is all about restoring you to the nullspace of an invariant
22:37:11 <mm_freak> Hadaka: that's probably a distribution effect
22:37:17 <gadtfly> pqmodn: cool.  What about a better way to express it?  Can it be a fold/unfold or some other more general recursion scheme?
22:37:46 <mm_freak> what's more general than a fold/unfold?
22:38:02 <Hadaka> mm_freak: both downloaded from source, no distribution packages (if you meant different linux distributions)
22:38:16 <edwardk> LordBrain: dmwit works on edit lenses. we've agreed to largely ignore the fact that we both tromple on the same word with very different usecases and laws in mind
22:38:16 <mm_freak> Hadaka: i did, and in that case i have no idea
22:38:33 <mm_freak> what are edit lenses?
22:38:40 <LordBrain> oh
22:38:41 <edwardk> johnw: exactly =)
22:39:03 <edwardk> johnw: hence why the current location is named 'pos', and you can do 'seeks' to mov the cursor relatively =)
22:39:06 <mm_freak> johnw: put differently, it's an array with a stored index =)
22:39:22 <johnw> https://gist.github.com/3495241
22:39:27 <johnw> in that code, why is the third print Nothing?
22:39:28 <edwardk> johnw: notice the data set doesn't have to be finite
22:39:33 <johnw> shouldn't it be 800?
22:40:03 <LordBrain> well i was trying to educate myself on the lenses you were discussing, got detoured by the technical language namespace collision
22:40:08 <lightquake> > ((-) 1) 3
22:40:09 <lambdabot>   -2
22:40:18 <johnw> oh
22:40:20 <johnw> it's not a sectin
22:40:23 <lightquake> you probably want (`subtract` 1)
22:40:30 <edwardk> LordBrain: https://github.com/ekmett/lens/wiki/Derivation
22:40:31 <johnw> that's what I was looking for
22:40:33 <LordBrain> nevertheless since i am on page 4, i'd still love to know what those vinculums are
22:40:34 <johnw> (-1) didn't do it
22:40:35 <lightquake> it is a section, it's just putting the 1 on the wrong side
22:40:53 <johnw> with `subtract`, it's still Nothing
22:41:00 <johnw> (`subtract` 1)
22:41:09 <mm_freak> > (1 -) 3
22:41:10 <lambdabot>   -2
22:41:12 <edwardk> > (`subtract` 1) 2
22:41:13 <lambdabot>   -1
22:41:21 <lightquake> oh, that's... weird
22:41:24 <johnw> (`subtract` 1) 4
22:41:28 <johnw> > (`subtract` 1) 4
22:41:29 <edwardk> > subtract 1 2
22:41:29 <lambdabot>   -3
22:41:30 <lambdabot>   1
22:41:33 <LordBrain> is dmwit present?
22:41:36 <lightquake> so you want (1 `subtract`)
22:41:42 <edwardk> LordBrain: more often than not
22:41:44 <mm_freak> or subtract 1
22:41:45 <edwardk> lightquake: yes
22:41:50 <lightquake> or that, yeah
22:41:51 <johnw> weird
22:41:58 <johnw> so it's flip (-)?
22:42:05 <edwardk> johnw: yes
22:42:05 <mm_freak> yeah
22:42:20 <edwardk> the sectioning rules are special cases so people can write (-2) to get the number -2
22:42:25 <johnw> i'll just use pred
22:42:46 <johnw> yes, now it all works, and actually makes sense
22:42:52 <edwardk> but that leaves a hole in functionality. how  do right section a -?   the replacement for it is subtract
22:42:57 <johnw> thanks to edwardk and mm_freak for not giving up on me
22:43:03 <edwardk> np
22:43:18 <edwardk> once you have the store down, you can move on to the bazaar ;)
22:43:46 <edwardk> that one gives _me_ headaches still
22:43:51 <LordBrain> the edit lens paper referred to state-based lenses, which turned out to be homomorphic to a subset of the so called edit lenses, and which i thought was probably what ordinary lenses were.
22:43:52 <mm_freak> johnw: to find use cases it's really useful to think of stores as images with a pointer, regardless of the actual representation
22:44:18 <mm_freak> edwardk: what's a bazaar?
22:45:13 <edwardk> mm_freak: newtype Bazaar c d a = Bazaar { _runBazaar :: forall f. Applicative f => (c -> f d) -> f a } is a comonad
22:45:37 <edwardk> You can write it in a more direct style
22:45:40 <edwardk> data Bazaar c d a  = Buy a  | Trade (Bazaar c d (d -> a)) c
22:45:51 <LordBrain> but i hate to let go of the question, who knows when i will need to know.  if i put a long horizontal bar over a=b, what does that signify?
22:46:08 <mm_freak> interesting…  looks like a generalization of Store
22:46:22 <edwardk> mm_freak: good eye
22:46:39 <mm_freak> seems like a Store with shape…  something that can change behavior
22:46:58 <edwardk> newtype Store c d a = Store { runStore :: forall f. Functor f => (c -> f d) -> f a } is also a comonad
22:47:04 <edwardk> er
22:47:06 <edwardk> when c = d
22:47:12 <edwardk> its an indexed comonad as is
22:47:21 <LordBrain> i thought for a sec it might be that my pdf viewer was messing the image up, but i tried a different one and it is still there
22:47:31 <edwardk> a bazaar is like a 'lot of stores'
22:47:38 <edwardk> where you can easily add more
22:47:51 <mm_freak> i see
22:48:07 <mm_freak> that one might be useful to me…  let me try to implement it
22:48:10 <edwardk> LordBrain: are you talking abut the sequent calculus rules?
22:49:43 <edwardk> LordBrain: the asymmetric lenses dmwit and benjamin pierce talk about in http://www.cis.upenn.edu/~bcpierce/papers/symmetric.pdf  are almost the lenses we use
22:49:57 <edwardk> LordBrain: they lack the put  put law
22:50:22 <edwardk> the fact that they lack that law is why neither is a generalization of the other
22:50:59 <LordBrain> edwardk, "Given monoids M and N and a complement set C, /a stateful monoid homomorphism/ from M to N over C is a function h \elem M X C -> N X C satisfying two laws:"
22:51:00 <edwardk> you need that law for the lens formulations to make sense in terms of traversable container laws, functor laws, store comonad coalgebras, etc.
22:51:51 <edwardk> LordBrain: yes. those are sequent calculus rules http://en.wikipedia.org/wiki/Sequent_calculus
22:52:25 <LordBrain> the first law, i understand, except for the bar on top:  h(1_M, C) = (1_N, C)    1_ is the unit of the monoids
22:52:34 <edwardk> baically they are saying given what is above the line you can get what is below it
22:52:46 <edwardk> if the stuff above the line is empty, it says you can get there from no preconditons
22:52:51 <edwardk> its an axiom
22:52:56 <LordBrain> aha
22:52:58 <LordBrain> thankyou
22:53:36 <edwardk> e.g.   ------- \n a |- a     is the axiom that given a context in which you have a, a holds ;)
22:53:37 <LordBrain> i have a ten year old math degree, dont recall ever seeing that notation
22:53:49 <edwardk> its used more in formal logic
22:53:58 <LordBrain> ok
22:55:00 <edwardk> basically when you start playing with the rules of logic, by say removing the axiom that a entails a & a, then you need to care a lot more about the derivations. also when you write compilers and type checkers, stating your rules this way is a good precursor to writing a compiler that enforces them
22:55:13 <startling> @hoogle Monoid c => [a -> c] -> a -> c
22:55:14 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:55:14 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
22:55:14 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
22:55:30 <edwardk> you can learn how to make good 'syntax directed' rules so its obvious how to translate them into code, etc
22:55:58 <mauke> :t mconcat .: sequence
22:55:58 <startling> ^^ anyone know of one of them? I want to run a list of functions on a single given thing and mconcat the results
22:55:59 <lambdabot> forall a (g :: * -> *). (Monoid a, Monad g, Functor g) => [g a] -> g a
22:55:59 <edwardk> its more useful to logicians and computer scientists than to mainstream mathematicians. for a mathematician the target of the proof is another mathematician
22:56:15 <mauke> startling: ^
22:56:15 <startling> :t (.:)
22:56:16 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
22:56:20 <edwardk> foldMap ($a) ?
22:56:30 <startling> edwardk: ooh
22:56:54 <startling> mauke: interesting, hadn't thought of the monad instance of functions
22:57:11 <edwardk> its a different game when you need to convince a computer
22:57:24 <mauke> > sequence [(+1), (*2), (^3)] 3
22:57:25 <lambdabot>   [4,6,27]
22:57:43 <startling> mauke: right, very cool
22:59:18 <LordBrain> hmm do the logicians write all the axioms of their formal logic on top of every statement... that sounds like a heavy burden
23:00:09 --- mode: ChanServ set +o mauke
23:00:09 --- mode: mauke set -q $a:mk
23:02:10 --- mode: mauke set -o mauke
23:06:02 <startling> @pl \fns t -> foldMap ($ t) fns
23:06:02 <lambdabot> flip (foldMap . flip id)
23:06:21 <startling> :t (flip id)
23:06:22 <lambdabot> forall a b. a -> (a -> b) -> b
23:06:46 <startling> how does that work?
23:06:50 <mauke> ($) = id :: (a -> b) -> (a -> b)
23:06:59 <startling> ahhhh
23:08:22 <LordBrain> caleskell i take it
23:08:54 <startling> Nah, it's standard
23:08:57 <startling> (apparently)
23:08:58 <LordBrain> :t id
23:08:59 <lambdabot> forall a. a -> a
23:09:24 <startling> LordBrain: (a -> b) -> a -> b is a special case of a -> a
23:09:39 <startling> LordBrain: because (a -> b) -> a -> b is the same as ((a -> b) -> (a -> b)
23:09:59 <LordBrain> i see
23:20:08 <johnw> edwardk: can you review something for me?
23:20:18 <edwardk> shoot
23:20:28 <johnw> edwardk: I need to know if I've actually understood what you're saying, in this e-mail to a colleague: https://gist.github.com/3495435
23:20:42 <johnw> he and I are trying to understand this stuff together, so we talk on Skype and trade e-mails about Haskelly stuff
23:22:02 <edwardk> not sure i follow the svn store stuff at the end
23:22:18 <johnw> he and I are writing utilities in Haskell to work with very large Subversion repositories
23:22:27 <edwardk> ah
23:22:29 <johnw> in some ways our work is very different (he deals with the active repo, I work with dump files)
23:22:34 <johnw> but the abstraction should work out to be about the same
23:23:06 <johnw> I think Comonads are just the trick for representing efficient repository traversal in a generic way
23:23:12 <edwardk> lets try another way to view comonads for a sec based on the intuition you've gained from store
23:23:17 <johnw> ok
23:23:30 * Enigmagic still has nightmares of large Subversion repos
23:23:44 <johnw> Enigmagic: we are only doing this work to migrate Boost to Git :)
23:24:22 <Enigmagic> johnw: honorable goal, I fully back any and all migrations away from Subversion.
23:24:51 <edwardk> if you have something like Store Integer a   then you have an infinite sequence of as that trail off in either direction forever, right?
23:25:15 <edwardk> then you can do relative movements in the sequence using peeks/seeks
23:25:18 <johnw> yes, because any extend f must be a total function
23:25:21 <edwardk> or copy one entry over everything using peek
23:25:30 <edwardk> now
23:25:48 <edwardk> one thing we like do to with structures like that is, say, run cellular automata.
23:26:04 <edwardk> you can define a step function for how you look at your neighbors and compute whether the current cell is live or dead for instance
23:26:17 <edwardk> and then when you extend it, you get the next time step all at once
23:26:47 <edwardk> the comonad took care of gluing together all the different viewpoints and gave you a new number line
23:27:07 <edwardk> where the answers at each point could depend on any of the previous entries on the line
23:27:14 <johnw> unfortunately, I don't know cellular automata at all
23:27:23 <johnw> I was a philosophy major, and did not complete my degree
23:27:29 * hackagebot asn1-data 0.7.1 - ASN1 data reader and writer in RAW, BER and DER forms  http://hackage.haskell.org/package/asn1-data-0.7.1 (VincentHanquez)
23:27:31 <johnw> so my theoretical knowledge is pretty much nil
23:27:31 <edwardk> ever seen conway's game of life?
23:27:40 <johnw> I think I've run it on my computer before
23:27:44 <johnw> one where sharks eat fishes
23:27:51 <edwardk> http://en.wikipedia.org/wiki/Conway's_Game_of_Life
23:28:13 <edwardk> cells live or die based on how many cells around them are alive or dead
23:28:31 <johnw> ah, ok
23:28:35 <edwardk> you locally make the decision for each cell by looking at your neighbors
23:29:16 <mm_freak> blur :: (Fractional a, Surround e) => Int -> Store e a -> a
23:29:20 <mm_freak> extend blur image
23:29:37 <edwardk> now, not everything is a fixed image or shape like that
23:29:42 <edwardk> we can also have things like trees
23:30:11 <edwardk> data Tree a = Bin (Tree a) a (Tree a) | Tip a
23:30:18 <edwardk> we can make a comonad for that Tree
23:30:32 <edwardk> where the extend operation lets you see everythind below you in the tree
23:30:52 <edwardk> extract (Bin l a r) = a; extract (Tip a) = a
23:31:38 <edwardk> extend f w@(Tip _) = Tip (f w); extend f w@(Bin l _ r) = Bin (extend f l) (f w) (extend f r)
23:31:54 <edwardk> notice how the function gets passed the whole node and all its children
23:32:29 * hackagebot certificate 1.2.6 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.2.6 (VincentHanquez)
23:32:34 <edwardk> you can 'see' more with a comonad when you go to generate the answer, but you only get to update one entry for all you can see. extend glues together all those perspectives and uses all their answers to give you a new structure
23:32:35 <johnw> how does "the extend operation lets you see everythind below you in the tree"?
23:33:15 <edwardk> let me write up an example real fast
23:33:22 <johnw> that would be great
23:34:00 <mm_freak> johnw: compare the types of (=>>) and (>>=)…  the latter allows its function argument to examine a certain point and return a tree
23:34:19 <johnw> ok...
23:34:20 <mm_freak> the former allows its function argument to examine the whole subtree and return a single value
23:34:25 <johnw> ah
23:34:41 <johnw> hmmm
23:34:42 <startling> what does >> do for lists? nothing computationally relevant?
23:35:00 <johnw> >> won't continue if the left list is empty
23:35:03 <edwardk> compare   fmap f (Bin l a r) = Bin (fmap f l) (f a) (fmap f r)   with extend f w@(Bin l _ r) = Bin (extend f l) (f w) (extend f r)
23:35:16 <edwardk> the former the 'f' is only fed the single entry
23:35:22 <edwardk> it can only use one entry to generate one entry
23:35:27 <mm_freak> startling: (>>) is just a complicated 'replicate'
23:35:29 <johnw> > [] >> return [1]
23:35:31 <lambdabot>   []
23:35:32 <startling> johnw: oh, right
23:35:38 <mm_freak> > [1..3] >> "hello"
23:35:39 <lambdabot>   "hellohellohello"
23:35:42 <edwardk> in the latter, the 'f' is fed the current node _and its children_ and can use that information to generate the new answer
23:35:42 <startling> mm_freak: oh
23:35:45 <startling> ohhhh
23:35:46 <startling> yeah
23:35:56 <startling> it adds uncertainty the computation
23:36:08 <mm_freak> i wouldn't call that uncertainty
23:36:19 <johnw> mm_freak: >>= for list uses mconcat?  I guess I remember reading that
23:36:26 <mm_freak> johnw: concatMap
23:36:32 <mm_freak> it /is/ concatMap
23:36:37 <johnw> edwardk: I get it now
23:36:38 <mm_freak> flip concatMap that is
23:36:40 <startling> mm_freak: what would you call it?
23:36:46 <edwardk> on the other extreme you have a monad, where you can have things like Bin l r >>= f = Bin (l >>= f) (l >>= r); Tip a >>= f = f a where f gets fed a single input (like with fmap) but it can generate an entire tree from it
23:36:47 <mm_freak> startling: it replicates =)
23:36:51 <johnw> fmap is value to value, >>= is value to tree, =>> is tree to value
23:36:51 <startling> mm_freak: alright
23:36:59 <edwardk> yep
23:37:01 <johnw> Comonad forms the complete picture
23:37:20 <edwardk> extend builds the complete picture from the mosaic tiles
23:37:23 <johnw> how does =>> get applied to the whole tree?
23:37:31 <mm_freak> johnw: both form the complete picture…  the question is from what =)
23:37:35 <edwardk> notice the definition used itself recursively
23:37:44 <johnw> ah
23:37:45 <johnw> gotcha
23:37:48 <mm_freak> you can either calculate a point from a picture or a picture from a point
23:37:59 <mm_freak> the former is comonad, the latter is monad
23:39:08 <mm_freak> this is also resembled by the categorical notion of monads and comonads
23:39:17 <LordBrain> edwardk, i have of course seen the more common |- notation, and i will admit I perhaps miss something of it's point, except to emphasize a status like this implication is to be considered as a lemma or theorem or some such as opposed to the typical => implication symbol.
23:39:35 <johnw> what's the opposite of catamorphism?
23:39:44 <johnw> please don't say cocatamorphism
23:39:47 <mapreduce> anamorphism
23:39:57 <mm_freak> johnw: depends on your notion of "opposite"
23:40:14 <edwardk> LordBrain: the LK/LJ equent calculus stuff is often used to reason about the - |- -   notation ;)
23:40:16 <LordBrain> my reading of wikipedia seems to indicate i have conflated things that are in fact distinct
23:40:22 <edwardk> those are often the things that live above and below the line
23:40:23 <mm_freak> but in the sense that there are folds and unfolds, an anamorphism is an unfold
23:40:51 <LordBrain> otherwise why would anyone need the deduction theorem
23:40:52 <mm_freak> but that's not really opposite, because catamorphisms can be anamorphisms at the same time
23:40:52 <edwardk> its the difference between the language and the meta language.
23:41:51 <LordBrain> is |- considered a meta language symbol, while => or ->  or whatever you are using for implies as part of the language proper
23:42:06 <edwardk> then view this as the meta meta language for |- =)
23:42:32 <shachaf> I never metalanguage I didn't like.
23:42:42 <LordBrain> har har
23:42:45 <johnw> so is =>> homomorphic?
23:43:03 <edwardk> a,b |- c   is that c holds in a context with a and b in it.   but how do you get those contexts? that is what the sequents are for
23:43:32 <mauke> yay, I can now type ⊢ ⊣ ∴
23:43:35 <edwardk> introducing more stuff in the context, moving stuff across the turnstile, etc.
23:43:43 <edwardk> each of those can be talked about informally
23:44:00 <edwardk> but you can also make it something you can compute with by talking in sequent form
23:44:03 <LordBrain> well... you know all of it sort of gets translated in my little head to the same english... given a and b we deduce c
23:44:10 <shachaf> Has ezyang's thing been mentioned yet?
23:44:12 <shachaf> Logitext.
23:44:16 <edwardk> notably you can have more than one thing above the --------- so your proofs form a tree
23:44:17 <LordBrain> or if we have a and we have b then we have c
23:44:23 <edwardk> LordBrain: sure.
23:45:07 <mm_freak> edwardk: btw, i noticed that most of the time i use 'flip extend'
23:45:12 <edwardk> but there is the level at which we manipulate the contexts, there is the way the contexts imply meaning, and then we often have whatever it is that we're executing
23:45:15 <mm_freak> there should probably be a convenience function for that
23:45:35 <shachaf> mm_freak: (=>>)?
23:45:37 <johnw> edwardk: is =>> homomorphic?
23:45:41 <edwardk> mm_freak: odd i almost never use it
23:45:46 <edwardk> johnw: in what sense?
23:45:54 <johnw> is the resulting Tree always of the same shape?
23:45:59 <edwardk> yes =)
23:45:59 <mm_freak> shachaf: flip extend c $ \d -> …
23:46:09 <mm_freak> that doesn't work with (=>>)
23:46:11 <edwardk> =>> will _never_ change the number of 'a's in the container =)
23:46:15 <johnw> and Monad and Comand are both Applicative Functors?
23:46:18 <shachaf> mm_freak: c =>> \d -> ...?
23:46:21 <edwardk> no
23:46:21 <johnw> Comonad
23:46:30 <edwardk> monads should alwyas be able to be applicative
23:46:34 <johnw> are they both Arrows?
23:46:46 <edwardk> many comonads do not offer you applicative operations
23:46:55 <mm_freak> oh, (=>>) is infixl 1
23:46:59 <mm_freak> that's convenient
23:47:05 <edwardk> that said, there are many comonads you can 'apply' in a way that is compatible with extract
23:47:24 <mm_freak> btw, i never understood why (>>=) is infixl…  infixr makes more sense to me
23:47:37 <edwardk> mm_freak: =>> is the convenience function ;)
23:48:26 <mm_freak> seems like with an infixl (>>=) the RTS has more work to do before it can finally start executing actions
23:48:37 <johnw> so Comonads are sometimes Applicatives, but not always?
23:48:47 <edwardk> johnw: one example of how you might be able to combine comonads. lets take your ((,) e) comonad
23:48:52 <johnw> but they are both always Arrows?
23:48:57 <edwardk> johnw if you have a monoid on e that can be made Applicative
23:49:16 <mm_freak> johnw: neither are always arrows
23:49:17 <LordBrain> the deduction theorem is that A |- B implies A -> B
23:49:19 <edwardk> johnw: there is an arrow for cokleisli (comonad) composition. and kleisli (monad) composition
23:49:35 <edwardk> the comonad/monad themselves may not be usable direclty as an instance of arrow though
23:49:38 <johnw> I think Arrows were more general than Monads
23:49:48 <johnw> and thus "every monad is an arrow, but not every arrow is a monad"
23:49:51 <johnw> think I read that somewhere
23:49:54 <edwardk> arrows are weaker than monads and thus more prevalent
23:49:56 <LordBrain> wikipedia says mathematicians took this as obvious for centuries
23:49:57 <mm_freak> johnw: every monad gives rise to an arrow, but it is not an arrow in its own right
23:50:04 <edwardk> every monad gives rise to an arrow
23:50:09 <johnw> yeah, like every physicist is a human, but not all humans are physicists
23:50:12 <edwardk> but its not the same to say that it _is_ an arrow
23:50:26 <startling> what happens if I use Data.ByteString.Lazy.readFile and someone edits that file while I'm reading it?
23:50:28 <edwardk> we can make an arrow (a -> m b)  for a monad m
23:50:33 <edwardk> but that isn't m
23:50:46 <edwardk> we can make an arrow (w a -> b)  for a comonad w, but that isn't w
23:50:55 <mauke> startling: you'll get whatever is currently in that file
23:51:22 <startling> mauke: at the time it finally gets reduced?
23:51:23 <johnw> ok
23:51:25 <shachaf> To the granularity of your chunk size, that is.
23:51:31 <johnw> Kleisli m a b is the arrow
23:51:38 <edwardk> LordBrain: the extra formality becomes really really useful when you start ripping out rules of logic
23:51:39 <johnw> not necessarily Monad a?
23:51:40 <mm_freak> johnw: Kleisli m
23:52:06 <edwardk> LordBrain: for instance it is useful to talk about linear logics in programming and in theorem proving for world states, etc
23:52:10 <johnw> don't you need the b for it to be an arrow?
23:52:25 <LordBrain> in english, lets see... the deduction theorem states, that we can use thereoms to derive new theorems... rather than having to go back every time to the set of axioms
23:52:25 <mm_freak> johnw: an arrow is a type of kind * -> * -> *, not of kind *
23:52:33 <johnw> oh
23:52:36 <edwardk> Kleisli m is the arrow, that has two parameters a and b.
23:52:36 <johnw> I see
23:52:50 <johnw> Kleisli m is the arrow of the Monad 'm'
23:52:52 <edwardk> instance Monad m => Arrow (Kleisli m)
23:52:56 <mm_freak> in the same way Maybe is the monad, not Maybe Int
23:52:58 <johnw> Cokleisli w is the arrow of the Comonad 'w'
23:53:06 <mm_freak> and in the same way State s is the monad and not State
23:53:11 <edwardk> its an arrow based on it
23:53:17 <edwardk> there may be multiple arrows based on that monad
23:53:19 <edwardk> we can define
23:53:34 <edwardk> newtype Static f a b = Static (f (a -> b))
23:53:42 <johnw> ok, back to Comonads and applicative
23:53:44 <edwardk> and Static m would also be an arrow based on the monad m
23:53:51 <johnw> ((,) e)
23:53:55 <edwardk> (or applicative m)
23:53:55 <johnw> where e is a Monoid you said
23:54:01 <edwardk> yes
23:54:15 <edwardk> now you have enough that you can write pure and (<*>)
23:54:38 <edwardk> but without the monoid on e you can't define pure.
23:54:52 <johnw> oh, sure
23:54:57 <johnw> because =>> returns a value without context
23:55:02 <edwardk> and (<*>) would have had to throw away one or the other without the monoid, because it doesn't know how to combine them
23:55:31 <edwardk> =>> puts the (,) e right back on remember. its extract that returns the value sans context.
23:55:32 <johnw> the context provided by >>= is what allows Applicative to apply in every case, right?
23:55:51 <johnw> oh, extract vs. return
23:55:55 <johnw> not >>= vs. =>>
23:56:22 <edwardk> so notice the difference here, i can work with the same w a over and over in different ways, but i can't normally put them together
23:57:05 <edwardk> but its easy for me to glom applicatives and monads together
23:57:25 <edwardk> ComonadApply gives you some of that power back, you can at least <@> which is like <*>
23:57:32 <startling> what's the way to export the contents of some module from another module?
23:57:43 <edwardk> but the laws for ComonadApply relate it to extract, not return.
23:57:58 <edwardk> startling: in the (… ) export list   add module Foo
23:58:25 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens.hs#L47
23:59:24 <startling> edwardk: thanks
