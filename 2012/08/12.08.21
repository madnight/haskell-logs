00:09:43 * ksf wonders if he's missing something that makes attribute grammars capable of properly working on trees that are actually graphs.
00:10:03 <ksf> say, do a dead node elimination without auxiliary data structure.
00:19:12 <signalsea> shachaf: I'm reading... but i have a question. if instead of Val e i had Add e = Add e e, Would it be possible to construct an (Expr Add) ? Could you give an example? Again, Expr f = In (f (Expr f))
00:19:32 * hackagebot stylish-haskell 0.4.0.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.4.0.0 (JasperVanDerJeugt)
00:19:39 <shachaf> Let's call it Fix.
00:19:43 <signalsea> ok
00:19:46 <shachaf> Fix f = In (f (Fix f))
00:20:07 <shachaf> Fix Add = In (Add (Fix Add))
00:20:07 <signalsea> I'm just curious what an example of Expr Add would be.. it would be illustrative for me
00:20:12 <signalsea> yes
00:20:16 <signalsea> got that far
00:20:21 * ksf would recommend to forget about encoding the thing in plain haskell and go with attribute grammars.
00:20:23 <shachaf> Well, it would be an infinite binary tree with no values.
00:20:50 <signalsea> ok, so there are no such values, right?
00:21:01 <signalsea> because it depends on its parameters
00:21:03 <shachaf> Sure there are.
00:21:04 <ksf> there's exactly one.
00:21:07 <signalsea> oh
00:21:10 <shachaf> data Add = Add Add Add
00:21:12 <shachaf> x = Add x x
00:21:16 <shachaf> That's equivalent.
00:22:01 <ksf> well, either infinitely many or one, depending on your idea of equality.
00:22:15 <ksf> all are darn similar, though.
00:22:16 <signalsea> but is it feasible to actually construct something like In (Add (In Add)... or something
00:22:26 <shachaf> Yes, recursively.
00:22:32 <shachaf> (Or corecursively, if you prefer.)
00:22:32 <ksf> it's feasible, but also utterly pointless.
00:23:09 <signalsea> can you give me an example?
00:23:26 <shachaf> I just gave you an example, minus the Ins.
00:23:29 <signalsea> oh ok
00:23:35 <signalsea> In Add Add Add?
00:23:54 <shachaf> What?
00:23:56 <ksf> x = In (Add x x)
00:24:01 <shachaf> I think you're confusing values and types.
00:24:08 <signalsea> just your example
00:24:27 <nand`> signalsea: type error
00:24:30 <signalsea> how would I actually declare such a recursive value
00:24:31 <signalsea> yeah
00:25:54 <signalsea> like, what Expr Add  definition could I paste into ghci, or compile, that would actually typecheck?
00:26:05 <signalsea> or call it Fix if you wish
00:26:40 <signalsea> s/definition/value/
00:27:35 <frerich> shachaf: You're pretty active in #haskell
00:28:00 <shachaf> frerich: Is that so? :-(
00:29:05 <frerich> shachaf: Looks like it. You're pretty much always active whenever I look (despite the fact that you are nine timezones away, I think).
00:29:44 <shachaf> @localtime frerich
00:29:45 <lambdabot> Local time for frerich is Wed Aug 21 09:29:11 2012
00:29:57 <Enigmagic> haskellers in sf don't sleep
00:30:14 <shachaf> My sleep schedule is a fair number of time zones from here.
00:30:51 <norm2782> about GHC compiler plugins: is there a way to ensure that a plugin is run after all other core passes are done? would that be as simple as |return (todo ++ [CoreDoPluginPass "foo" pass])| in the plugin's install function?
00:34:35 * hackagebot tdoc 0.4.1 - TDoc is a typed document builder with support for (X)HTML  http://hackage.haskell.org/package/tdoc-0.4.1 (NicolasPouillard)
00:34:37 * hackagebot lzma-conduit 0.5.2 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-0.5.2 (NathanHowell)
00:35:06 <signalsea> ok shachaf and ksf, thank you for putting up with me. I see what you meant about constructing an Expr Add.
00:37:22 <murple_smile> Hello
00:37:41 <srhb> murple_smile: hi
00:38:02 <murple_smile> Im trying to run some system profiling code on the latest GHC for OSX (7.0.4)
00:38:18 <murple_smile> passing these options: +RTS -sstderr -rtsopts
00:38:23 <srhb> That's not the latest GHC for OS X
00:38:34 <murple_smile> and I get this response: Most RTS options are disabled. Link with -rtsopts to enable them.
00:38:51 <nand`> have you tried linking with -rtsopts?
00:38:53 <shachaf> murple_smile: You should link with -rtsopts
00:38:58 <srhb> :-)
00:39:11 <murple_smile> yeah, how do I link with -rtsopts?
00:39:17 <nand`> ghc -rtsopts ?
00:39:55 <shachaf> Yep.
00:41:02 <loreints> hey, in this example, how do I tell where the let stops evaluating?: http://hpaste.org/73458
00:41:08 <murple_smile> ghc -rtsopts some_file_name ?
00:41:20 <murple_smile> sorry if this is a naive question
00:41:21 <shachaf> murple_smile: Try it!
00:41:33 <srhb> loreints: What do you mean? There are two declarations in that let
00:42:07 <srhb> loreints: The indentation determines how far the "let block" goes.
00:42:11 <loreints> I'm sorry, I miswrote that. I meant to say where does the binding stop?
00:42:20 <srhb> loreints: Right, the indentation.
00:42:33 <loreints> srhb: but the last line is not indented as far as the let variable bindings?
00:42:45 <srhb> loreints: Exactly.
00:42:49 <shachaf> loreints: Right, which stops the "let" bindings and goes back to the "do".
00:43:04 <srhb> loreints: http://en.wikibooks.org/wiki/Haskell/Indentation
00:43:16 <huangyi> I have to implement a `MonadBaseControl IO` instance for `newtype Yun a = Yun { unYun :: ReaderT YunEnv (ResourceT IO) a }`, i guess there is a very simple way to do that, but i can't figure it out, instance deriving don't work here.
00:43:42 <murple_smile> awesome guys! it worked
00:43:55 <loreints> so after a let statement, the bindings will stay in the current do/monad binding lexical area?
00:44:12 <murple_smile> many thanks
00:44:19 <srhb> loreints: Yes.
00:44:36 <shachaf> do { let { ...α }; ...β } becomes let { ...α } in do { ...β }
00:44:42 <srhb> loreints: It gets rewritten to do let decls gets rewritten let decls in do ...
00:44:53 <srhb> ergh, failsentence.
00:45:06 <srhb> what schachaf said -- i get cofee nao :-)
00:45:13 <loreints> so there is no way of exiting that lexical binding within the current do that called the let statement?
00:45:36 <shachaf> I have no idea what "exiting' or "called" means.
00:45:50 <srhb> loreints: "no"
00:46:39 <loreints> It seems that the last part: "in do { ...β }" cannot be told where to end? such as the let binding stops here?
00:46:41 <loreints>  
00:46:50 <loreints> sorry if I'm not being clear
00:47:02 <srhb> loreints: You are not being clear, but no, it reaches to the end of the do-block
00:47:29 <srhb> I have no idea why you would ever need it to stop early somehow.
00:48:14 <loreints> to not overpopulate the local namespace?
00:48:24 <srhb> What? The local namespace in your do-block?
00:48:35 <srhb> This seems to be a very hypothetical issue :P
00:48:39 <loreints> I think I'm used to 'bad' code with very long definitions
00:48:44 <srhb> Yes :P
00:48:52 <loreints> ah, okay then :P
00:48:59 <srhb> This is a ridiculous thing to worry about, stop it at once. ;)
00:49:00 <loreints> thank you for your help srhb!
00:49:13 <shachaf> loreints: Why do you care about the local namespace?
00:49:24 <shachaf> You can shadow variables if you want to reuse names (but you probably shouldn't).
00:51:21 <loreints> shachaf: I don't know, I guess I don't have a very good reason. Just curious I guess.
00:51:41 <shachaf> loreints: Is this a performance concern or something?
00:52:22 <loreints> shachaf: no, just trying to understand the language.
00:53:11 <loreints> I'm glad I'm up at this ungodly hour, I think I finally understand monads (at least in a simple manner) due to lyah
00:53:35 <srhb> loreints: Which monads? :-)
00:53:45 <srhb> Or just the general concept?
00:54:33 <loreints> srhb: the general concept (I think).
00:54:34 <shachaf> I need help understanding what it means to "understand monads".
00:54:40 <shachaf> Is there a tutorial on that?
00:55:09 <loreints> I guess staring at this example for a while finally made sense: Just 9 >>= \x -> return (x*10)
00:55:14 <Enigmagic> there is a tutorial on understanding gonads (the successor to goroutines)
00:55:24 <srhb> Enigmagic: lol
00:55:39 <srhb> loreints: Yeah, that helps a lot. You should be aware that the pattern foo >>= return . ... is wrong though :)
00:55:45 <srhb> Or, not wrong, but fmap is a lot nicer.
00:55:45 <Enigmagic> :)
00:56:06 <srhb> > fmap (*9) (Just 9)
00:56:07 <loreints> srhb: what do you think a short concise example of proper monad interaction is?
00:56:08 <lambdabot>   Just 81
00:56:41 <srhb> loreints: Well, yours was proper as such, just not necessary since functors will get you as far as that in a cleaner manner
00:57:45 <loreints> the one thing about monads, that I do not like, is the implicit way in which the function on the right hand side is wrapped up in the monad from the left.
00:58:07 <srhb> It's not implicit.
00:58:12 <srhb> :t (>>=)
00:58:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:58:15 <shachaf> I have a feeling you've got more understanding to do.
00:58:19 <srhb> It's quite explicit.
00:58:30 <srhb> (If I understand what you mean by "wrapped" right :-))
00:59:28 <loreints> well I guess I kept thinking a monad would look like this (hypothetically) (Just x) >>= f WrapUp Maybe
00:59:30 <srhb> loreints: I mean, in your example you even put in "return"
00:59:37 <srhb> :t return
00:59:38 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
01:00:07 <loreints> which now seems like a waste, because why would you want to use a monad different from the one on the left?
01:00:08 <srhb> loreints: We should call (>>=) bind and its usage "use of bind" rather than monad. :-)
01:00:27 <srhb> What do you mean different from the left? Do you mean a stack of monads?
01:01:06 <loreints> Well I keep thinking of monads as just a different api around the same data
01:01:10 <loreints> is that a good metaphor?
01:01:20 <srhb> OK, I think you should stop thinking about metaphors and read the definition of bind and return instead.
01:01:36 <loreints> srhb: haha, yes, I think that is a good idea.
01:01:37 <mikeplus64> @src return
01:01:38 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
01:01:47 <mikeplus64> @src return :: a -> Maybe a
01:01:48 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:01:57 <mikeplus64> lambdabot is a cruel beast
01:02:00 <srhb> loreints: Read the Monad instances for Maybe and [] for instance.
01:02:06 <srhb> mikeplus64: yes :(
01:02:30 <mikeplus64> loreints: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#Monad
01:02:33 <loreints> where could I find more instance Monad examples?
01:02:59 <srhb> loreints: In the source, both monads are defined in Prelude. :)
01:03:10 <mikeplus64> (there is only the [] instance on that page though)
01:03:18 <srhb> Oh, really.
01:03:21 <mikeplus64> loreints: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Maybe.html#Maybe
01:03:35 <mikeplus64> just below the definition are the Monad and Functor instances
01:04:08 <srhb> search for "instance  Monad []" -- note the two spaces
01:04:32 <loreints> do you know of any slightly more complex ones?
01:04:45 <mikeplus64> loreints: IO
01:04:49 <srhb> loreints: Really, you just grasped the list monad, just like that? ;)
01:05:08 <mikeplus64> loreints: also http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad-Instances.html
01:05:11 <shachaf> instance Monad (r ->)
01:05:22 <shachaf> That's a good one as a counterexample to some things.
01:06:31 <loreints> hmm, no I just undrestood the Maybe one and thought I got the list one. That list one is pretty difficult.
01:06:37 <srhb> > ((+2) >>= (*)) 1
01:06:38 <lambdabot>   3
01:06:40 <srhb> Fun
01:06:50 <srhb> That's actually really useful.
01:06:59 <mikeplus64> loreints: the list one's definition is complicated i think mainly for the sake of optimization
01:07:05 <mikeplus64> loreints: (>>=) for lists = concatMap
01:07:14 <shachaf> Optimization?
01:07:33 <mikeplus64> shachaf: is it not easier for ghc to rewrite expressions using >>= if the code is inlined like that?
01:07:43 <shachaf> Inlined?
01:08:19 <shachaf> Oh, I doubt it.
01:08:23 <mikeplus64> i mean just written in the body of (>>=)
01:08:33 <shachaf> It's probably because concatMap is defined in Data.List or something.
01:08:42 <mikeplus64> yeah
01:09:34 <loreints> srhb: haha what the heck is this: ((+2) >>= (*)) :: (Num b, Monad ((->) b)) => b -> b
01:09:34 <loreints>  
01:09:55 <srhb> loreints: It's the function Monad.
01:10:06 <srhb> Or, it's bind in the function Monad
01:10:33 <srhb> > ((+2) >>= (*)) 2
01:10:34 <lambdabot>   8
01:10:39 <mikeplus64> > (do { x <- (+1); return (typeOf x) }) 0
01:10:41 <lambdabot>   Integer
01:10:47 * shachaf has never used (>>=) in (r ->)
01:11:10 <srhb> It's not THAT useful, but I can see myself wanting to pass the same argument to two functions.
01:11:17 * Twey has, frequently
01:11:19 <srhb> And.. uh.. composing the result
01:11:21 * srhb boggles
01:11:34 <mikeplus64> i've never used the (a ->) monad outside of playing with lambdabot or ghci, ever
01:11:55 <shachaf> liftM, liftM2, and join are all quite useful.
01:11:57 <srhb> Twey: Any useful examples you could share with us? Perhaps we just haven't seen the light. :-)
01:12:11 <nand`> @pl \r -> (r+2) * r
01:12:11 <lambdabot> (*) =<< (2 +)
01:12:13 <shachaf> And ap
01:12:26 <nand`> join is probably the one I use the most
01:12:34 <shachaf> @ty join join
01:12:35 <lambdabot>     Occurs check: cannot construct the infinite type:
01:12:35 <lambdabot>       m = (->) (m (m a))
01:12:35 <lambdabot>     Probable cause: `join' is applied to too few arguments
01:12:58 <Twey> srhb: It comes up when point-free'ing things
01:13:07 <Twey> Quite often
01:13:08 <loreints> why can't I run this in ghci?: ((+2) >>= (*))
01:13:08 <loreints>  
01:13:20 <mikeplus64> loreints: you need to import Control.Monad.Instances
01:13:22 <srhb> loreints: import Control.Monad.Instances
01:13:28 <srhb> the function Monad instance is in there
01:13:40 <Twey> loreints: And the result of that has no Show instance, too
01:13:49 <Twey> You'd need to apply it to something
01:14:06 <mikeplus64> > (do x <- succ; y <- pred; z <- (*10)) 0
01:14:08 <lambdabot>   <no location info>:
01:14:08 <lambdabot>      The last statement in a 'do' construct must be an ...
01:14:13 <mikeplus64> > (do x <- succ; y <- pred; z <- (*10); return (x, y, z) 0
01:14:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:14:18 <mikeplus64> > (do x <- succ; y <- pred; z <- (*10); return (x, y, z)) 0
01:14:19 <lambdabot>   (1,-1,0)
01:14:21 <mikeplus64> third time lucky
01:14:30 <loreints> the result of that monad is a curried function applied to a passed arg, right?
01:14:40 <nand`> wut
01:14:44 <shachaf> OK, I've used (r ->)'s (>>=) under the guise of do notation.
01:14:44 <srhb> f >>= k = \ r -> k (f r) r
01:14:57 <Twey> I like the (>>=)
01:15:09 <mikeplus64> loreints: the result of something in the ((->) a) monad is a function
01:15:13 <Twey> It gives you a ‘pipeline’ where the argument is passed in at every step
01:15:30 <shachaf> @ty (>=>)
01:15:32 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:15:46 <mikeplus64> > ((+1) >=> (+2)) 0
01:15:48 <lambdabot>   No instances for (GHC.Num.Num (m (m c)), GHC.Num.Num (m c))
01:15:48 <lambdabot>    arising from...
01:16:24 <shachaf> > ((+) >=> (*)) 5 3
01:16:26 <lambdabot>   24
01:16:28 <Twey> > (1, ) >>= (,) >>= (,) $ 2
01:16:29 <lambdabot>   Illegal tuple section: use -XTupleSections
01:16:32 <Twey> Tsk
01:16:37 <Twey> > (,) 1 >>= (,) >>= (,) $ 2
01:16:39 <lambdabot>   (((1,2),2),2)
01:17:09 <nand`> > ((,) >=> (,) >=> (,) >=> (,)) () 2
01:17:09 <Twey> It's just a composition pipeline with the passed value as as a second argument to each function
01:17:10 <lambdabot>   (((((),2),2),2),2)
01:17:10 <lumi_> Isn't this the Reader monad?
01:17:17 <Twey> s/as as/as/
01:17:19 <Twey> lumi_: Yes
01:17:19 <shachaf> lumi_: It is.
01:17:25 <loreints> so could I say the result of that monad is  \x -> (2 * (x + 2))?
01:17:33 <nand`> “result of that monad” O.o
01:17:44 <shachaf> :-(
01:17:58 <loreints> what it evaluates into?
01:18:22 <shachaf> loreints: You're putting words together in an order that doesn't make any sense.
01:18:34 <shachaf> So it's difficult to answer your questions. :-)
01:18:51 <nand`> the order makes sense, some of the words just don't
01:18:53 <Twey> loreints: (+ 2) >>= (*) = \x -> (x + 2) * x
01:19:22 <srhb> loreints: You could say "the result of that expression" and you could even say "the result of that expression in the function Monad" (but that would be redundant)
01:19:36 * hackagebot Top 1.7 - Constraint solving framework employed by the Helium Compiler.  http://hackage.haskell.org/package/Top-1.7 (JurriaanHage)
01:19:39 <Twey> > (+ 2) >>= (*) $ a
01:19:41 <lambdabot>   (a + 2) * a
01:19:45 <Twey> > (+ 2) >>= (*) $ x
01:19:47 <lambdabot>   (x + 2) * x
01:19:54 <Twey> loreints: SimpleReflect is cool ☺
01:20:18 <loreints> Twey: SimpleReflect?
01:20:31 <Twey> loreints: SimpleReflect is the package that defines the single-letter variables in lambdabot.
01:20:35 <Twey> > x + 2
01:20:36 <loreints> this is what I think I mean: (+ 2) >>= (*) = \x -> (x + 2) * x
01:20:37 <lambdabot>   x + 2
01:20:38 <nand`> > foldr f z [a,b,c]
01:20:39 <lambdabot>   f a (f b (f c z))
01:20:40 <nand`> this stuff
01:20:47 <Twey> loreints: You are correct.
01:21:01 <Twey> Your terminology was just a little off when explaining it
01:21:15 <Twey> Also note that the x is the *second* argument to (*), not the first
01:21:34 <srhb> it would be clearer if you wrote it in  the same way
01:22:13 <nand`> not that it matters much, honestly
01:22:15 <Twey> (+ 2) >>= (*) = \x -> (*) ((+) x 2) x -- ?
01:22:19 <nand`> > (+ 2) >>= flip (*) $ r
01:22:21 <lambdabot>   r * (r + 2)
01:22:37 <srhb> Twey: Right
01:22:46 <Twey> I guess
01:22:55 <srhb> Well, I'd keep the section from the lhs
01:22:56 <srhb> but nevermind!
01:22:58 <srhb> :-)
01:23:40 <Twey> f x >>= g = \y -> g (f x y) y
01:23:43 <Twey> There :þ
01:25:38 <loreints> it is hard for me to undrestand the flip type definition. does (a -> b -> c) in a type definition imply a tuple of args?
01:25:48 <srhb> No
01:25:51 <shachaf> No, it's a function.
01:26:05 <nand`> a function that returns a function
01:26:05 <shachaf> Same thing it means anywhere else. :-)
01:26:05 <loreints> I thought functions were of f x => b
01:26:12 <nand`> a -> (b -> c)
01:26:13 <srhb> > const 1 2
01:26:15 <lambdabot>   1
01:26:16 <srhb> > flip const 1 2
01:26:19 <lambdabot>   2
01:26:41 <srhb> loreints: foo => is a constraint
01:26:47 <loreints> sorry, I just got a bit confused, I think I'm going to have to double check my notes a bit more.
01:26:54 <srhb> :t (+)
01:26:55 <lambdabot> forall a. (Num a) => a -> a -> a
01:27:06 <srhb> Here the constraint is that a must be a Num
01:27:26 <srhb> but the function takes two arguments and produces another a (a -> a -> a)
01:27:38 <shachaf> loreints: I recommend ignoring anything that mentions the word "Monad" for a bit.
01:27:41 <loreints> Does it matter where type constraints are, or as long as they are before the first usage of the variable?
01:27:42 <srhb> (+2) 1 2
01:27:42 <shachaf> See the FAQ on that:
01:27:44 <shachaf> @where faq
01:27:44 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
01:27:53 <shachaf> loreints: In general no.
01:28:03 <shachaf> There are some specific cases where it might matter but those are rare.
01:28:18 <srhb> :t length
01:28:20 <lambdabot> forall a. [a] -> Int
01:28:28 <srhb> loreints: Notice how there are no constraints in that signature
01:28:47 <srhb> loreints: It is a function that takes [a] and produces Int
01:29:12 <nand`> with rank-2 or higher types the location of the constraint can differ but apart from that they'd pretty much always be at the beginning
01:29:28 <loreints> nand`: what does 'rank' mean?
01:29:35 <nand`> while I think you can write a -> Num b => b -> b; it's equal to Num b => a -> b -> b
01:29:40 <shachaf> nand`: YOu don't need rank-2 types.
01:29:47 <nand`> shachaf: example?
01:29:50 * srhb feels the need to hold up a giant STOP! sign and make loreints stay on basics :D)
01:29:56 <shachaf> foo :: a -> (Constraint a => a -> ...) -> ... can exist, for example.
01:29:57 <pdxleif> loreints: I think it meanys "stinky".
01:30:04 <loreints> haha, will do :P.
01:30:09 <shachaf> And it can mean something different from having the constraint on the outside.
01:30:11 <shachaf> ==srhb
01:30:29 <nand`> shachaf: I get “Illegal polymorphic or qualified type; perhaps you intended -XRankNTypes or -XRank2Types”
01:30:33 <nand`> when I try something like that
01:30:36 <nand`> even without quantifying myself
01:31:13 <loreints> also, I have to ask, did Intel really nickname their next processor in reference to Haskell?
01:31:44 <shachaf> No.
01:32:32 <loreints> I saw hardware STM support and "Haswell" and was just thinking about it
01:32:35 <Twey> What's the nickname of their next processor?
01:32:39 <loreints> Haswell
01:32:46 <Twey> Then no :þ
01:33:40 <nand`> loreints: ‘rank’ is something involving the position of quantifiers (eg. forall) in types; not sure on the exact formulations involved
01:33:52 <shachaf> "hardware STM", eh?
01:33:58 <XexonixXexillion> Twey: Off topic, but I have to ask, are you actually icelandic, or do you just like using þ ?
01:34:10 <mikeplus64> heh, hardware software transactional memory
01:34:40 <loreints> http://en.wikipedia.org/wiki/Transactional_Synchronization_Extensions
01:34:42 <flux> well, I doubt it's transactional memory per se, rather it has some support for software doing it..
01:34:57 <Twey> XexonixXexillion: Er, no, not Icelandic.
01:35:46 <Twey> nand`: Rank N means you can have a quantifier nested N deep, I think
01:35:57 <shachaf> Twey: Apparently a constraint is enough, according to GHC>
01:36:10 <Twey> Doesn't a nested constraint imply a quantifier?
01:36:39 <shachaf> No.
01:36:40 <nand`> wikipedia says “For some fixed value k, rank-k polymorphism is a system in which a quantifier may not appear to the left of k or more arrows (when the type is drawn as a tree).” but that concept of arrow is I'm pretty sure unrelated to -> since you can have eg. a -> forall b. b -> b with rank-1
01:36:53 <Twey> Oh, okay
01:37:07 <shachaf> Twey: There's at least one exampl with GADTs where the behavior is different.
01:37:15 <nand`> oh, it's ‘to the left of’, even; but all rank-1 foralls are at the left :)
01:37:15 <Twey> nand`: No you can't
01:37:18 <Twey> Er
01:37:19 <Twey> Wait
01:37:27 <Twey> Yeah.
01:37:31 <Twey> ‘To the right of’ works.
01:38:13 <nand`> (forall a. a -> a) -> b -> b  <- the quantifier is the the ‘left’ of all ->s but the type is rank-2; again showing that the ‘arrows’ in the description have nothing to do with ->
01:38:17 <nand`> but I think it's just nesting depth
01:38:56 <shachaf> nand`: That's not what "left" means.
01:39:03 <shachaf> It's "left" in the tree.
01:39:19 <Twey> Hmn, yes, I guess
01:39:25 <nand`> oh
01:39:36 * hackagebot metadata 0.1.1.0 - metadata library for semantic web.  http://hackage.haskell.org/package/metadata-0.1.1.0 (KatsutoshiItoh)
01:39:51 <nand`> yes that makes sense then
01:41:21 <Guest82477> at what point
01:41:28 <Guest82477> in a large stack of monad transformers
01:41:35 <Guest82477> do you say "this is too much"
01:42:11 <srhb> That's hard to say. They are so useful, and often you don't need to write your own Monad. I think it's a matter of taste
01:42:13 <nand`> when it starts involving forward and backward state monads
01:42:16 <mikeplus64> Guest53303: when you notice the overhead
01:42:26 <kniu> specifically, I'm thinking of splitting off a monad into two, with each taking up its own module
01:42:51 <srhb> mikeplus64: Is the overhead really that bad?
01:42:59 <mikeplus64> srhb: no!
01:43:10 <mikeplus64> but if you're at the point where it is, then i think you have to reevaluate
01:43:47 <srhb> Haha. That is a good point. :-)
01:55:29 <merijn> The question to ask is whether the separate ones make sense, I guess?
01:58:30 <shachaf> The question to ask is probably what monad you want.
01:58:42 <shachaf> If transformers happen to be the best way to write it, then use transformers.
02:25:38 <loreints> what does it mean when I see a type declaration that ends with -> IO () or a paren in general
02:26:03 <shachaf> () is a type.
02:26:04 <ksf> () is the unit type.
02:26:11 <ksf> it has exactly one member: ()
02:26:12 <loreints> so it's not an empty tuple?
02:26:20 <ksf> well, you could see is as such.
02:26:21 <shachaf> It's the type of empty tuples.
02:26:36 <shachaf> It has a value, the empty tuple, which is also written ().
02:26:54 <loreints> what's the point of matching against an empty tuple? Why not use Nothing?
02:27:08 <ksf> Nothing is a value, not a type.
02:27:28 <ksf> and Maybe has two or more inhabitants
02:27:33 <srhb> loreints: We could have a type called "NothingAtAll" and it would be fine, as long as it had only one value. The point of (), or the empty tuple, as you call it, is that it cannot contain any relevant information, because a type with only one member really cannot do that.
02:27:54 <ksf> Maybe True has three, Maybe () two.
02:27:57 <ksf> ugh.
02:28:00 <ksf> Maybe Bool.
02:28:07 <ksf> everyone forget that I wrote that.
02:28:14 <srhb> ksf: *screenshot*
02:28:18 <srhb> :-)
02:28:41 <srhb> loreints: So it is just a way to convey that the return type here conveys no information at all. :)
02:28:48 <srhb> convey convey convey.
02:29:04 <loreints> but why isn't it "IO -> ()" instead of "-> IO ()"?
02:29:19 <ksf> because IO has kind * -> *
02:29:40 <ksf> ...that is, it's a type that takes another type as an argument.
02:29:58 <ksf> (just like functions, but for types)
02:30:00 <srhb> You can have IO Int, IO String, IO (), but not IO - it is not a concrete type.
02:30:12 <srhb> Is concrete the right word? I think it is.
02:30:17 <ksf> ground
02:30:20 <srhb> oh.
02:30:27 <ksf> but concrete works just fine.
02:30:56 <ksf> unless you want to write something about a "concrete ground type"
02:31:01 <loreints> what is that placement of IO called in "IO foo"?
02:31:12 <srhb> loreints: Not sure what you mean by placement.
02:31:21 <srhb> A type constructor perhaps?
02:31:43 <loreints> ah, type constructor.
02:32:01 <shachaf> I've never heard "ground".
02:32:08 <srhb> loreints: Consider data Maybe a = Just a | Nothing -- Maybe is the type constructor.. Or is it Maybe a
02:32:12 <srhb> Anyway, the left hand side.
02:32:12 * ksf got it out of oleg papers
02:32:15 <shachaf> People sometimes just say "type", or "of kind *".
02:32:18 <srhb> ksf: Then it must be true.
02:32:38 <ksf> he also means non-polymorphic with that, though.
02:32:50 <mm_freak_> loreints: if it were IO -> () it would be a function from some type IO to type (), which wouldn't make any sense
02:33:02 <srhb> loreints: In that example, you give Maybe a type, and you've constructed a concrete type.
02:33:02 <ksf> (it does, in disciple)
02:33:08 <t7> i want type level functions
02:33:17 <shachaf> t7: You've got them.
02:33:21 <t7> {-# Language DependentTypes #-}
02:33:30 <shachaf> {-# LANGUAGE TypeFamilies #-}
02:33:42 <loreints> ah, okay, I think I have a bit of a clearer grasp on that. Thanks mm_freak and srhb!
02:33:50 <mikeplus64> {-# LANGUAGE RuntimeTyping #-} -- oh wait
02:34:00 <mikeplus64> (seems to me that would defeat the purpose)
02:34:08 <t7> mikeplus64: jokes on you, thats in the new ghc
02:34:16 <srhb> loreints: You should notice that all this happens on the type level, not the value level. (Which is why you see it in type _signatures_)
02:34:22 <t7> deferred type errors or something
02:34:57 <shachaf> t7: Joke's on new, that's not what deferred type errors are at all.
02:35:04 <shachaf> ...On you.
02:35:05 <shachaf> :-(
02:35:12 * shachaf sobs quietly.
02:35:13 <t7> yey jokes on you
02:36:33 <mikeplus64> i wonder if you could sanely have a Num instance for type-level peano numbers
02:39:53 <mm_freak_> mikeplus64: sure
02:40:00 <mm_freak_> wait, type level?
02:40:04 <mm_freak_> no
02:41:21 <mikeplus64> perhaps instance Num a where (+) x y = undefined etc
02:41:39 <eikke> mm_freak_: I wrote a simple wrapper which makes a Conduit out of the functionality provided by the rate-limit package
02:42:24 <int-e> data NatVal where Nat n => n -> NatVal; instance Num NatVal where ...
02:42:27 <eikke> yet that doesn't support changing rates at runtime for now, might hack that in
02:43:35 <int-e> mikeplus64: would something like that be sane enough?
02:43:49 <mbuf> is there any function in System.Process or others which will dump the output as it happens, and also return the final exit code?
02:44:13 <shachaf> "dump"?
02:44:16 <mikeplus64> int-e: to be honest i'm not sure if the question was sane at all ;)
02:44:27 <srhb> mbuf: I think the descriptions in System.Process are quite clear. :)
02:44:28 <mbuf> shachaf: *print the output
02:44:32 <shachaf> "print"?
02:45:00 <shachaf> As in, just run the process and pass it stdout as its stdout?
02:45:14 <mbuf> shachaf: readProcessWithExitCode waits for the process to finish before I can print the output
02:45:21 <shachaf> The thing that's called "system" in other languages?
02:45:50 * shachaf isn't sure what the question is.
02:46:16 <shachaf> The thing that's called "system" in C is also called "system" in Haskell.
02:47:33 <srhb> > system "ls; sleep 10" >>= print -- ls sends stuff to stdout, then after 10 seconds I get ExitSuccess mbuf
02:47:34 <lambdabot>   Not in scope: `system'
02:47:40 <srhb> oops, sorry
02:50:30 <srhb> mbuf: If you need more control, use runInteractiveProcess or something similar.
02:50:49 <mbuf> srhb: will try that; thanks!
03:05:07 <wunki> what's a good way to test/use your library while creating it? I don't mean unit tests or quickcheck, but overall usage. Do you have a 'demo' directory in your library?
03:06:12 <mikeplus64> wunki: it's certainly not uncommon to have a demos or examples directory
03:06:46 <hirsch_> Xn*P37Z12
03:09:26 <wunki> mikeplus64: any idea how to make it work with cabal (cabal-dev)? Otherwise I have to install it with cabal, everytime I try to run something in the demo directory right?
03:15:23 <mikeplus64> wunki: you could make a .cabal file for it in the directory, then do cabal build or install
03:15:29 <mikeplus64> i would just use ghc though
03:17:07 <wunki> mikeplus64: alright, thanks. I'm going to try to get some "workflow" that way
03:36:28 <osa1> I can't use getContents to make my app run until EOF is read, I think it's because I never use return value of getContents, so it's never evaluated. how can I fix that?
03:37:14 <shachaf> x <- getContents; evaluate (length x)
03:37:20 <bitonic> shachaf: :(
03:37:24 <shachaf> Kind of a hack but it works.
03:37:33 <bitonic> "kind of" is an understatement :P
03:37:36 <shachaf> bitonic: SORRY, MAN!
03:37:53 <shachaf> import qualified Data.ByteString as B; B.getContents
03:37:54 <bitonic> osa1: don't use lazy IO
03:38:02 <osa1> bitonic: how can I do that?
03:38:08 <shachaf> getContents is an evil function, yes.
03:38:16 <shachaf> (But not strict ByteString's getContents.)
03:38:19 <bitonic> osa1: shachaf suggested a way
03:38:38 <bitonic> isn't there a strict `getContents' in base?
03:39:12 <osa1> that worked. thanks. but now my app is dependent to ByteString but I actually never use it
03:39:35 <shachaf> Also it allocates a big buffer that you don't use.
03:39:46 <osa1> ...
03:41:01 <osa1> so do we have any strict input functions in base? I can make them read until EOF
03:42:04 <bitonic> are the Handle functions strict?
03:42:06 * bitonic doesn't remember.
03:42:20 <Twey> osa1: getChar?
03:42:31 <osa1> oh, there are some in System.IO.Strinct http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html
03:42:37 <tdammers> is getChar really strict?
03:43:02 <bitonic> osa1: well, that's not base
03:43:06 <Twey> main = do x <- getChar; when (x /= '\EOT') main
03:43:10 <shachaf> osa1: Better to depend on "bystring" than "strict"!
03:43:23 <tdammers> seriously though, what exactly is wrong with lazyIO as long as you respect the implications?
03:43:29 <osa1> ok
03:43:32 <shachaf> Twey: ...I don't think '\EOT' means what you think it means.
03:43:54 <Twey> shachaf: Don't you?
03:44:20 <osa1> yeah, readChar is strict
03:44:31 <osa1> s/readChar/getChar
03:44:44 <Twey> It's strict for some relevant value of ‘strict’
03:44:59 <bitonic> tdammers: it's really hard to understand what's going on (with lazy IO)
03:45:06 <Twey> tdammers: Namely that the implications you have to respect is that it introduces impurity into the whole of the rest of your program
03:45:07 <osa1> yeah, at least it works for me
03:45:09 <bitonic> and you have little control on the resources
03:45:33 <tdammers> depends on the scope of your purity
03:45:36 <Twey> tdammers: Lazy IO is basically a restricted version of unsafePerformIO
03:45:43 <tdammers> heh, well, yeah
03:45:48 <Twey> You get back a pure value whose evaluation results in IO
03:45:56 <tdammers> I know
03:46:00 <shachaf> Twey: '\EOT' is a character.
03:46:02 <Twey> This is Bad™
03:46:04 <Twey> shachaf: Yes
03:46:05 <shachaf> Twey: You can find it in a file.
03:46:13 <tdammers> the reason I'm asking is that I did use it in a toy web server, and it worked like a charm
03:46:14 <Twey> True
03:46:24 <Twey> It's also what getChar returns when it encounters EOF, as far as I can tell
03:46:29 <shachaf> Oh.
03:46:33 <shachaf> Well, that's bad.
03:46:35 <Twey> Yes
03:46:52 <tdammers> I had one module that lazy-read a static file, and then another module would decorate the whole thing with appropriate headers, then a third module did the actual service
03:46:53 <shachaf> "i h8 u getChar", as they say.
03:46:57 <tdammers> s/service/serving/
03:47:01 * Twey nods sagely.
03:47:02 <bitonic> tdammers: of course you can use lazy IO reasonably, but the cons outweigh the pros, imo.
03:47:22 <bitonic> happstack is still based on lazy IO and does quite well.
03:47:23 <Twey> tdammers: Nobody's saying it's not going to work
03:47:31 <Twey> Lots of stuff is bad, but works.
03:47:33 <Twey> Like C.
03:47:45 <bitonic> here we go.
03:47:50 <tdammers> well, in this particular case, lazy IO made for a huge performance gain
03:47:55 <Twey> o.@
03:48:05 <Twey> tdammers: You were doing something horribly wrong with strict IO, then :þ
03:48:33 <Twey> Besides, there are lots of alternatives around these days that are as nice as or nicer than lazy IO, like conduits
03:48:43 <t7> use node.js for huge performance gain™
03:48:47 <Twey> Haha
03:48:54 <Twey> t7: It's web-scale!
03:49:02 <tdammers> well, if I had used the same semantic solution with strict IO, I would have loaded the entire static file into RAM first, then copy it around a bit to add the headers, and then served the result from RAM
03:49:18 <merijn> Twey,t7: Node.js has done a lot of good for this world...
03:49:40 <merijn> Mainly in giving me an easy of determining whose opinions are worthless and who can be ignored safely...
03:49:51 <t7> pray tell
03:50:02 <t7> ah
03:50:11 <timthelion> merijn: Like VB application developers?
03:50:17 * tdammers has to look into conduits
03:50:32 <merijn> btw, I had this idea of writing Node.hs mimicking the entire ridiculous node.js approach in haskell as a joke, but then I was lazy
03:50:43 <merijn> If someone wants to steal the idea and run with it, go ahead :p
03:50:50 <Twey> merijn: Hehe
03:51:15 <timthelion> merijn: if people where born with a certain programing language, as their "native programming language" we'd all be horrible racists.
03:51:17 <merijn> You'll see it'll become popular too
03:51:21 <dmwit> http://stackoverflow.com/a/6669453/791604 <- on when lazy IO is good and bad
03:53:17 <mikeplus64> merijn: what would it be? snap with some incorrect instances for common things or something?
03:53:26 <timthelion> Is McBride's new type system actually going to be adopted? Or will she always be a seperate entity?
03:53:38 <mikeplus64> timthelion: ???
03:54:14 <timthelion> mikeplus64: he made this new parametric type system, that makes it easier to write type safe code.
03:54:15 <tdammers> mikeplus64: probably something that forces everything to run in a single thread, even when a multi-threaded approach would be easier to implement *and* more efficient
03:54:32 <dmwit> I suspect she will always be a separate entity, though I wouldn't be at all surprised if features slowly leaked from she directly into GHC.
03:54:39 <merijn> mikeplus64: Also, lots of manual call back management
03:55:04 <timthelion> dmwit: It's just, I've run into a place where I really want it :D
03:55:15 <dmwit> So use it. =D
03:55:38 <timthelion> dmwit: that would require work, to learn it, install it, make sure it's working properly, ect :P
03:56:23 <timthelion> dmwit: but mainly, I just don't want to add a non standard language feature to my code set... As that makes the code much more likely to become dead code...
03:56:34 * timthelion has a phobia of dead code.
04:00:24 <timthelion> http://hpaste.org/73460 <<< You see, that is the problem...
04:00:45 <timthelion> See the comment on line 9...
04:01:07 <dmwit> Oh, lern2GADT
04:01:21 <timthelion> dmwit: ?
04:01:36 <dmwit> ?wiki GADT
04:01:36 <lambdabot> http://www.haskell.org/haskellwiki/GADT
04:01:49 <timthelion> dmwit: is there a good way to solve this?
04:01:59 <shachaf> timthelion: GADTs might be a good way to solve it.
04:02:03 <dmwit> Maybe even a plain old phantom type would be enough for this particular case.
04:02:11 <dmwit> ?wiki phantom type
04:02:12 <lambdabot> http://www.haskell.org/haskellwiki/phantom_type
04:03:31 <timthelion> dmwit: but phantom types don't actually improve type safety, do they? Isn't there always a place where you have to repackage the Value into the Phantom type that violates that?
04:03:52 <dmwit> "always" is a strong word
04:04:07 <shachaf> The goal of phantom types is to improve type safety.
04:04:49 <dmwit> The short answers to your exact questions are "Yes, phantom types improve safety." and "No, there isn't always a place where you must repackage values.".
04:05:19 <shachaf> dmwit: Did you see the progress made on pi_10 and e_10?
04:05:21 <shachaf> @where pi_10
04:05:21 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
04:05:23 <shachaf> @where e_10
04:05:23 <lambdabot> (!!2)<$>transpose[show$sum$scanl div(10^2^n)[1..2^n]|n<-[0..]]
04:05:58 <dmwit> neat
04:06:02 <mikeplus64> timthelion: i would probably use data Value a = Value { ... valueVariety :: a }
04:06:17 <shachaf> Valuriety
04:06:53 <dmwit> mikeplus64: I would probably use data Value a = Value { ... }, with no valueVariety at all.
04:06:58 <dmwit> (i.e. phantom types ;-)
04:07:37 * timthelion is having trouble conceptualizing what changes to his code that would require, and how that would fit together...
04:07:55 <dmwit> timthelion: It's just a trick.
04:08:04 <mikeplus64> dmwit: i like values too much
04:08:04 <dmwit> You could make two data types, called something like ValueStatic and ValueDynamic.
04:08:26 <timthelion> dmwit: I had that before, but that leads to a huge amount of pointless code duplication...
04:08:43 <dmwit> And then you could write functions that only take ValueStatic values and functions that only take ValueDynamic values, and maybe even some functions that know what to do with both, e.g. that operate on Either ValueStatic ValueDynamic things.
04:08:54 <timthelion> dmwit: which could be fixed with a null type class, but somehow those bug me.
04:08:54 <dmwit> But then, as you say, you get a lot of pointless code duplication.
04:09:18 <dmwit> So, the fix is to give Value a type parameter, and let that parameter range over a type-level value whose inhabitants are the types Static and Dynamic.
04:09:24 <dmwit> Value Static and Value Dynamic.
04:09:34 <dmwit> Functions that know how to handle both simply operate on forall a. Value a
04:09:35 <dmwit> done
04:09:55 <quicksilver> dmwit: except you can't statically prove that Value Static and Value Dynamic are the only possibilities without a GADT
04:10:10 <dmwit> With the new kinding features you can. =)
04:10:17 <quicksilver> forall a . Value a isn't enough if you have to choose two different cases
04:10:25 <quicksilver> really? You can case over finite kinds?
04:10:29 <quicksilver> how does that look syntactically?
04:10:41 <dmwit> data NewKind = NewType1 | NewType2
04:10:55 <quicksilver> I know that bit
04:10:56 <dmwit> data Value (a :: 'NewKind) -- or something like that
04:11:01 <quicksilver> but how do you case over it?
04:11:07 <dmwit> Who's casing over anything?
04:11:16 <quicksilver> I want to write code which says:
04:11:32 <shachaf> quicksilver: I think dmwit is responding to "you can't statically prove that Value Static and Value Dynamic are the only possibilities without a GADT"
04:11:39 <dmwit> yes
04:11:44 <quicksilver> ok
04:11:53 <quicksilver> but "Statically proving it" in that sense
04:12:00 <quicksilver> isn't useful if you can't write code which takes advantage of it
04:12:14 <quicksilver> given f :: Value Static -> r and g :: Value Dynamic -> r
04:12:22 <mikeplus64> data StaticOrDynamic a => Value a = ... (ok i'll show myself out)
04:12:24 <quicksilver> how do I build f_or_g :: Value a -> r
04:12:33 <shachaf> That's not as much as you get with a GADT, yes.
04:12:41 <quicksilver> which uses one or the other as appropriate
04:12:41 <shachaf> mikeplus64: Type classes are open so that doesn't help you.
04:12:58 <dmwit> As I mentioned above: GADTs are great, and in this particular case probably phantom types are enough.
04:13:10 <dmwit> I fully recognize that phantom types don't give you everything GADTs do, and never claimed that.
04:13:14 <quicksilver> and in the absence of syntactic support for type-case I don't see how to write f_or_g
04:13:26 <quicksilver> dmwit: and I never claimed you claimed that :)
04:13:32 <timthelion> what quicksilver asked...
04:13:36 <quicksilver> I'm just interested if the new kinding facilities also allow this kind of thing.
04:13:47 <dmwit> I don't know, but I sort of doubt it.
04:13:54 <timthelion> how DO we write f_of_g???
04:14:06 <mikeplus64> shachaf: data Dont.Even.Think.About.Importing.This.Typeclass.Its.Really.Just.Too.Long.Too.Type.StaticOrDynamic a => Value a = ...
04:14:20 <dmwit> timthelion: You don't.
04:14:24 <mikeplus64> too long to type *
04:14:43 <dmwit> If you need to write a function like that, you need to switch to GADTs.
04:15:19 <Twey> mikeplus64: Proof by keyboard exhaustion.
04:15:36 <dmwit> timthelion: Alternately, you write a function of type Either (Value Static) (Value Dynamic) -> a instead.
04:15:50 <mikeplus64> Twey: brb thesis
04:15:54 <mikeplus64> lol
04:16:00 <timthelion> dmwit: OK, so I'd need GADTs, because I have lots of code like that.  For example, the grouping function that would be like group :: forall a. [Value a] -> [EvaluationGroup]
04:16:33 <timthelion> Sorry I butchered the syntax there
04:16:43 * timthelion hasn't used forall yet and so doesn't have the syntax ingranded.
04:16:48 <shachaf> Or you switch to Agda.
04:16:49 <timthelion> ingraned
04:17:17 <timthelion> shachaf: that will really help, after having spend so much time learning haskell :P
04:17:34 <shachaf> Agda is like Haskell except better (worse).
04:19:05 <HugoDaniel> :D
04:19:10 <srhb> shachaf: Let us switch at once (never)!
04:19:26 <quicksilver> presumably GHC will get some kind of type-case
04:19:26 <HugoDaniel> im not a fan of agda or coq :/
04:19:36 <quicksilver> finite kinds do strongly invite it
04:19:39 <Twey> Why not?  :-O
04:19:59 <quicksilver> although...
04:20:11 <shachaf> srhb: Agda is the future!
04:20:14 <shachaf> You should learn it.
04:20:18 <quicksilver> I actually don't think that can work without changing the heap object format
04:20:33 <shachaf> srhb: Agda is, like, way cooler than Haskell. All the kewl dawgs use Agda.
04:20:34 * timthelion likes Haskell's bulemic nature, of going all pure 98% of the time, and then binging on unsafePreformIO due to starvation.
04:20:39 <Twey> Well, a very primitive form of the future :þ
04:20:46 * timthelion doesn't need a fully anorexic language like coq.
04:20:49 <quicksilver> just because a kind happens to be finite doesn't mean an object of type Value k; k :: FiniteKind has a tag to indicate the type k
04:20:55 <agundry> quicksilver: what GHC actually needs is Pi-types
04:20:58 <srhb> shachaf: Agda seems so cool, and unfortunately way harder to use for practical things :P
04:21:12 <agundry> (of course, you can fake them using singleton GADTs, but it's not as fun)
04:21:24 <Twey> srhb: Don't worry, making it nicer to use for practical things is a large area of research.
04:21:35 <shachaf> srhb: Pft, as if you care about practical things.
04:21:40 <srhb> Twey: I don't have time to wait for the singularity :-)
04:21:49 <Twey> srhb: So make it happen :þ
04:21:52 <HugoDaniel> the future is javascript, and crockford the new world order pope
04:21:58 <Twey> HugoDaniel: Arrrgh
04:22:03 <Twey> I had a nightmare like that once
04:22:31 <HugoDaniel> all hail hitler^H^H^H^H^H^H JS
04:23:19 * timthelion thinks javascript is a beautiful language.  So many nasty hackish things you can do.  Exiting loops by overwriting the web page comes to mind.
04:23:29 <DT``> ... what.
04:24:09 <timthelion> DT``: If your java script is embeded in HTML you can overwrite yourself.
04:24:33 * timthelion googles java script core wars
04:24:43 <HugoDaniel> eval is amazing, haskell should do that
04:24:49 * hackagebot NumberSieves 0.1.2 - Number Theoretic Sieves: primes, factorization, and Euler's Totient  http://hackage.haskell.org/package/NumberSieves-0.1.2 (LeonSmith)
04:24:50 <HugoDaniel> unsafePerformEval
04:25:12 <timthelion> HugoDaniel: we have Eval.. it's called hint
04:25:59 <HugoDaniel> oh nice
04:26:00 <ziman> eval + fix would be a cool combo ;)
04:26:01 <HugoDaniel> :)
04:26:28 <DT``> ziman, eval+fix+unrestricted call/cc.
04:26:51 <DT``> gotta leak memory with those loops.
04:27:58 <Jafet> > (length&&&length) [0..]
04:28:02 <lambdabot>   mueval-core: Time limit exceeded
04:28:42 <vaflis> :t (&&&)
04:28:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:29:08 <vaflis> > (length&&&length) [1,2,3]
04:29:10 <lambdabot>   (3,3)
04:29:27 <vaflis> uh-huh...
04:29:34 <vaflis> > (length&&&sum&&&product) [1,2,3]
04:29:36 <lambdabot>   (3,(6,6))
04:29:45 <vaflis> ok
04:30:54 <mikeplus64> is it possible to search for instances on hoogle?
04:31:15 <srhb> Am I understanding correctly that using the properties of Applicative is preferred over liftMN? Why?
04:31:41 <Jafet> Well you know, generality
04:31:47 <Twey> srhb: More general
04:31:49 <Jafet> It's fashionable, like skinny girls
04:31:50 <srhb> Ah, it's the N that is bothering?
04:32:05 <Jafet> Applicative is more general than Monad
04:32:09 <Jafet> There's also liftAn
04:32:13 <shachaf> srhb: liftAn is nicer than liftMn.
04:32:18 <ziman> liftM requires a Monad; <$> + <*> does not
04:32:19 <srhb> Oh. Why?
04:32:24 <srhb> Right, okay.
04:32:32 <srhb> All Monads are Applicative Functors?
04:32:33 <shachaf> srhb: For one, it can sometimes be implemented more efficiently.
04:32:36 <vaflis> @src fmap Maybe
04:32:36 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:32:42 <shachaf> srhb: Yep. See if you can prove it!
04:32:48 <mikeplus64> > loop id ()
04:32:49 <vaflis> @src fmap (Maybe a)
04:32:49 <lambdabot> Source not found. stty: unknown mode: doofus
04:32:49 <lambdabot>   ()
04:32:50 <srhb> I wouldn't know where to start.. Hmm
04:32:53 <vaflis> :(
04:32:56 <Jafet> pure = return
04:32:59 <Jafet> There I did the easy bit
04:33:04 <shachaf> srhb: Well, you know the monad laws, and the applicative functor laws, right?
04:33:11 <srhb> Right
04:33:20 <t7> @google applicative functor laws
04:33:22 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
04:33:22 <lambdabot> Title: Haskell/Applicative Functors - Wikibooks, open books for an open world
04:33:27 <ziman> you can also look at the types
04:33:31 <shachaf> An Applicative has three operations: fmap, pure, and (<*>)
04:33:44 <shachaf> Write those interms of (>>=) and return, and then prove that they obey the same laws.
04:33:51 <srhb> Oh, cool, I'll have a go at that.
04:34:08 <shachaf> srhb: Also, there's a way nicer definition of Applicative than (<*>) and pure.
04:34:24 <srhb> Oh?
04:34:25 <Twey> There is?
04:34:27 <shachaf> It goes unit :: f (); (*) :: f a -> f b -> f (a,b)
04:34:34 <shachaf> The laws work out much more nicely that way.
04:35:12 <Twey> … oh yeah
04:35:16 <Twey> That is nice.
04:35:49 <dmwit> Yes, I've proposed the "Applicative are for things with arbitrary zips" summary before, but many people don't like it.
04:35:56 <Jafet> <*> probably more suited for golf
04:36:08 <dmwit> (Especially since several implementations are sort of... not zips without a bit of rework of the meaning of "zip". =P)
04:36:20 <d-snp> http://hpaste.org/73462
04:36:21 <Twey> Heh
04:36:33 <d-snp> anyone could help me with this? I think it involves template haskell or typeable
04:38:18 <Twey> d-snp: You just need the ability to replace handlers
04:38:46 <Twey> I.E. handlers of the form Event → (m) Handler
04:39:24 <d-snp> but what do I replace a handler with?
04:39:44 <Twey> d-snp: Another handler :þ
04:39:46 <Jafet> @google you could have invented coroutines!
04:39:47 <d-snp> the events are not necessarily received in the order of the tuple
04:39:48 <lambdabot> http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
04:39:48 <lambdabot> Title: Coroutines in C
04:39:53 <Jafet> Blergh
04:40:04 <d-snp> so how would I generate that thandler? :P
04:40:51 <Twey> d-snp: If you currently have a handler that requires a GotInteger followed by a GotBytes, you write a handler that requires a GotInteger and returns a handler that requires a GotBytes, which handler then does whatever it's supposed to do and returns the original handler again
04:43:35 <d-snp> Twey: but I don't require them in order
04:43:55 <d-snp> I want it to require a GotInteger and a GotString at the same time
04:44:24 <d-snp> so the handler must be able to handle any of them, and return a handler that handles the other one and then executes the real handler
04:45:12 <Jafet> Whenever you find yourself writing a state machine
04:45:50 <Jafet> ...okay, what's a witty ending for that
04:46:00 <Twey> … write a state machine?
04:46:27 <d-snp> :P
04:46:39 <Jafet> I would use MVars here
04:46:52 <Twey> d-snp: Okay; that's fine.  You'd just keep a Data.Map or something internal to the handler.  The handler takes a value and attempts to put it in the map, ignoring it if that slot in the map is full.  If the map contains everything you need it to contain, execute whatever the handler's payload is.  If it isn't, return the same handler but with the new map.
04:46:52 <Jafet> The handlers just block on input
04:47:08 <d-snp> yeah, I'm not allowed to use the IO monad :)
04:47:10 <Jafet> Or IVars if possible
04:47:19 <d-snp> sorry for giving lame restrictions
04:47:20 <Twey> ‘Not allowed’?
04:47:29 <Jafet> He's programming at gunpoint
04:47:36 <Twey> Ah
04:47:37 <d-snp> :D
04:47:39 <Twey> I hate it when that happens.
04:47:50 <d-snp> Halle Berry is under my desk :(
04:48:16 <mikeplus64> "this is a 44 magnum the most powerful gun in the world ... are you going to write that monad instance? are you feeling lucky, punk?"
04:48:21 <Jafet> That doesn't sound very productive
04:48:33 <d-snp> but eh yeah I'm writing an alternative I/O system for Haskell
04:48:40 <Twey> Aha
04:48:45 <d-snp> so the idea is that I don't use IO for anything
04:49:30 <d-snp> it's a pretty bad idea ofcourse, trying to make stream-based I/O work again :P
04:50:14 <Twey> d-snp: No no, it's a fine idea.  Have you looked at the recent research on programs as games?
04:50:22 <Jafet> So why are you writing an event handler?
04:52:57 <d-snp> Twey: no, what's that about? or do you mean the Tangible Values one?
04:53:55 <d-snp> Jafet: well the lazy pattern matching technique is a bit flawed, so instead of input streams it takes input events, but still returns responses
04:54:21 <d-snp> so instead of [Request] -> [Response] it's Request -> (State, [Response])
04:54:37 <d-snp> ehh (State, Request) -> (State, [Response])
04:55:50 <d-snp> perhaps if I had more time I would make it [Request]
04:55:56 <Jafet> Why is it flawed? Because it's linear?
04:56:34 <d-snp> because it assumes an ordering of events
04:57:09 <d-snp> anyway my approach has a bunch of flaws too
04:57:19 <Jafet> Why not order them anyway?
04:57:21 <d-snp> one of which is this problem which seems to require metaprogramming
04:57:53 <d-snp> well if you let go of the ordering idea you can execute actions concurrently
04:58:05 <d-snp> which is what I do
04:58:27 <Jafet> Okay
04:58:32 <Jafet> So why not implement MVar
04:58:36 <Jafet> And then use MVars
05:00:31 <d-snp> yeah perhaps I need to implement this accumulator function as part of the IO system and have it use MVar
05:01:38 <Jafet> GHC IO is built on top of its scheduler
05:02:26 <srhb> Am I doing it wrong? http://hpaste.org/73463
05:02:52 <srhb> (I'm not sure if the v' makes sense xD)
05:03:32 <shachaf> What's v'?
05:03:44 <Jafet> The pure value, of course.
05:03:52 <srhb> Yeah, exactly.. ._. It's v without its context. Or how to say it.
05:03:57 <Jafet> Or was it impure.
05:04:02 <shachaf> You can do without that, I think.
05:04:08 <Egbert9e9> Repa is always about whole sale array operations, never about a one element change operation. [y/n]?
05:04:16 <Jafet> q
05:04:24 <shachaf> (\a -> return . id $ a) == (\a -> return a) == return
05:04:28 <Botje> abort!
05:04:29 <shachaf> v >>= return == v
05:04:39 <Egbert9e9> s/one element change/many one element changes/
05:04:50 <srhb> shachaf: True. That would get me around that issue. Thanks!
05:05:03 <Jafet> repa arrays are immutable
05:05:19 <int-e> srhb: <*> is not defined that way, is it?
05:05:19 <shachaf> srhb: Also, ending every line with "= v" looks strange.
05:05:26 <shachaf> Since that's what you're trying to prove in the first place. :-)
05:05:29 <srhb> shachaf: OK, yes, thanks.
05:05:37 <srhb> I was just going for the whole "this should hold"
05:05:39 <Egbert9e9> Jafet: what if I traverse with an if x == i && y == j ... rule?
05:05:42 <srhb> int-e: No.
05:05:54 <Jafet> Then you're probably doing something pretty dumb
05:05:57 <Egbert9e9> yes
05:06:03 <Egbert9e9> thought so
05:06:24 <shachaf> srhb: Right, but it looks like you're manipulating an equation.
05:06:33 <srhb> shachaf: Yeah..
05:06:45 <srhb> <=> ?
05:06:52 <srhb> Meh :P
05:07:14 <shachaf> srhb: Just: pure id <*> v   =    return id <*> v   =   ...   =   v
05:07:50 <srhb> Ok :)
05:09:09 <srhb> Wow, that is so cool... I've never done proofs in relation to programming before
05:09:15 * srhb has another mind-blown moment
05:09:40 <int-e> srhb: it should really be  return id <*> v = return id >>= \f -> v >>= \v' -> return (f v') ... you'll end up with v >>= return anyway.
05:10:37 <srhb> int-e: I guess it would have looked like that if I'd made my definition more point-free. They're the other way around in mine.
05:10:44 <srhb> mf <*> ma = ma >>= \a -> (mf >>= \f -> return . f $ a)
05:11:08 <srhb> Unless I made a real mistake in my "proof", they must be equivalent.
05:11:46 <shachaf> srhb: Oh, right, your <*> is backwards.
05:12:06 <int-e> srhb: hmm. you get an applicative all right, but the order of effects is different from the standard definition.
05:12:24 <dmwit> Surely there's a Dual around somewhere that inverts the order of effects on (<*>).
05:12:25 <shachaf> @ty flip (<**>)
05:12:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:12:46 <shachaf> ezyang was just talking about commutative applicatives and all that.
05:12:59 <srhb> Well, damn me. So I'm all wrong? Why does the proof come out right then D:
05:13:02 <shachaf> srhb: Anyway, since "return v" has no effects, it happened to work out in your case.
05:13:08 <shachaf> But in general that's not valid.
05:13:19 <shachaf> Sorry, man. :-(
05:13:20 <dmwit> srhb: Because that's a fine way to make an Applicative.
05:13:23 <srhb> Oh. There's more to it. :<
05:13:25 <dmwit> shachaf: what
05:13:37 <dmwit> The Applicative laws surely aren't strong enough to enforce effect order.
05:13:49 <shachaf> dmwit: return id <*> v = v
05:13:49 <shachaf> v >>= \a -> (return id >>= \f -> return . f $ a) = v
05:14:02 <shachaf> I assume this was starting out with the definition (<*>) = ap
05:14:18 <shachaf> Maybe not, though.
05:14:26 <dmwit> That looks like a fine equation to me.
05:14:38 <shachaf> It probably still works out with the order reversed.
05:14:43 <shachaf> It's just not ap. Fair enough.
05:14:54 <mikeplus64> hm, would it be possible to write a variadic function such that magicApplicate f x y z == f <$> x <*> y <*> z ?
05:15:07 <Egbert9e9> I have no clue how to adapt this into haskell.
05:15:10 <mikeplus64> presumably it'd involve a fair bit of type hackery
05:15:16 <mikeplus64> typeclass
05:15:19 <mikeplus64> rather
05:15:54 <shachaf> srhb: If you used Agda you wouldn't have to worry about all this!
05:15:57 * srhb didn't understand much, but is still rather proud
05:16:00 <srhb> shachaf: Oh dear!
05:16:01 <shachaf> Because everything would be checked.
05:16:11 <shachaf> ...There'd be a bunch of other things to worry about, though.
05:16:39 <dmwit> srhb: As my favorite math prof used to say: "there's nothing to understand. It's just a definition."
05:16:48 <dmwit> You got a proof of the thing you wanted to prove, what more could you want? =D
05:16:55 <srhb> True enough :P
05:17:08 <timthelion> dmwit: nice quote :D :D :D
05:17:29 <int-e> but so wrong ;)
05:17:36 <timthelion> dmwit: actually, that's a brilliant quote :D
05:17:40 <timthelion> int-e: so right!
05:17:41 <shachaf> "A formalist is one who cannot understand a theory unless it is meaningless"
05:18:37 <dmwit> He really was a great guy. I remember on the last day of class he held an "ask a mathematician" session. Sort of reddit's AMA, but IRL.
05:18:53 <int-e> timthelion: I don't think mathematicians would get far in their proofs without some understanding, by which I mean intuition, for the definitions that they work with. What's true is that this intuition may be non-transferrable, a result of experience.
05:19:01 <dmwit> "So what do you do when you're not teaching us calculus?" "Ohhh, I drink bee-uh of course!"
05:21:09 <timthelion> my favorite math teacher had black hands from both erasing the board and smoking about 30 cigarets a day.
05:21:33 <osa1> can anyone help me? I have this code: http://hpaste.org/73464 but the code after "setCurrentDirectory" is not executed. line 2 is executed, but line 5 is not. why?
05:22:47 <timthelion> osa1: have you tried pruning it?
05:22:49 <dibblego> osa1: do you catch an exception by any chance in the outer code?
05:23:00 <osa1> dibblego: no
05:23:02 <dibblego> this is the problem with IO code — you can't juts isolate it like you are doing
05:23:03 <osa1> timthelion: pruning?
05:23:18 <dibblego> it would really help to post a full example, especially one that someone else could run
05:23:36 <timthelion> osa1: down to one file, either getCurrentDirectory is not finishing(hanging) throwing an exception, or some other thread is causing problems.
05:24:56 <NoICE> hi guys :) anyone using sublime text 2 with ghc-mod (SublimeHaskell package)?
05:24:59 <osa1> timthelion: how can I know if it's throwing an exception? I don't catch any exceptions, and it doesn't crash
05:25:54 <timthelion> osa1: does it hang?
05:26:21 <mikeplus64> NoICE: that exists? (link?)
05:26:22 <osa1> timthelion: no
05:26:40 <timthelion> osa1: so the function returns without those lines being executed?
05:26:47 <NoICE> mikeplus64: just use package manager and do Package Install: SublimeHaskell :)
05:26:53 <NoICE> but I have troubles with it
05:27:03 <mikeplus64> ah
05:27:27 <NoICE> you need to do cabal install ghc-mod .. and "Show type" and Insert type works.. autocompletion of imports works somehow too...
05:27:33 <osa1> timthelion: hmm. I just added a new print in tail position. seems like function doesn't return
05:28:04 <mikeplus64> NoICE: i'll check it out (i use vim, but kind of like st 2)
05:28:11 <NoICE> but it also should check the code for errors on save, but it does not and the sublime console shows some python error ("must call on main thread"), so I just wanted to ask if someone have experience with it
05:28:44 <NoICE> mikeplus64: I like both and use both everyday, but sublime has better file navigation (imho) :)
05:29:21 <Shapeshifter> If I write a function like < findKey key = foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing
05:29:37 <Shapeshifter> will the list be traversed to the end? I mean, this seems somewhat inefficient.
05:29:39 <NoICE> mikeplus64: here is the package which is used by package control: https://bitbucket.org/nh2/sublime-text-haskell
05:29:40 <osa1> timthelion: ok, I found the problem and fixed it. I'm working on this for about 15 minutes and I had to ruin the code with adding lots of putStrLn's for debugging purposes. why I'm now getting any exceptions or crashes when this call is throws an exception, or crashes?
05:30:07 <timthelion> osa1: it's hanging then.  OR, another possibility, is that somehow it's not recompiling correctly, do to vim not saving, a permision problem or something...
05:30:41 <timthelion> osa1: does it throw an exception, or simply hang?
05:31:19 <osa1> timthelion: there are no exceptions. how can it hang? I'm calling this function in a mapM_, does that mean it is run in parallel?
05:31:28 <fmap> Shapeshifter: why not just try it?
05:31:37 <fmap> > (\key -> foldr (\(k,v) acc -> if k == key then Just v else acc) Nothing) 3 [1,2,3,undefined]
05:31:39 <lambdabot>   Just 3
05:31:46 <timthelion> osa1: it's not run in parallel no.
05:32:01 <osa1> timthelion: but then if it hangs, mapM_ should also hang
05:32:18 <Shapeshifter> fmap: well, yes it works, but my question is what haskell is doing in this case. Because with a fold, I thought it would fold until the entire list is consumed.
05:32:18 <timthelion> osa1: well if it's not returning, then mapM_ IS hanging.
05:32:51 <edwardk> Shapeshifter: the function doesn't demand anything of 'acc' in the Just case
05:33:02 <edwardk> so laziness saves you
05:33:25 <edwardk> > take 2 $ foldr (:) [] [1,2,3,undefined]
05:33:26 <lambdabot>   [1,2]
05:33:36 <Shapeshifter> Ah, I see.
05:33:38 <Shapeshifter> Thanks
05:33:39 <osa1> timthelion: right. I still have no idea how can "setCurrentDirectory" hang. or how can I know which functions can hang, which ones can throw exceptions etc.
05:33:41 <timthelion> osa1: and why don't you have any putStr's between lines 3 and 4?
05:34:01 <edwardk> the same thing happens there with a slightly more refined bent, there i'm building up a structure and to see each result of the new list i need to look at the corresponding element of the source list
05:34:06 <timthelion> osa1: it's usually a bad thing when a function hangs.  It's probably not documented, because it's probably a bug :)
05:34:14 <edwardk> but until i look at them, they don't get forced
05:35:14 <osa1> timthelion: I just tried the code with same error on ghci, and it throwed an exception
05:35:23 <Twey> d-snp: No, recently there's been a trend in research for relating types to games and values or programs to strategies, and using game theory to analyse them
05:35:24 <fmap> Shapeshifter: note that this won't work with `foldl'
05:35:28 <fmap> > take 2 $ foldl (flip (:)) [] [1,2,3,undefined]
05:35:31 <lambdabot>   [*Exception: Prelude.undefined
05:35:46 <timthelion> osa1: good :)  what exception
05:36:03 <timthelion> osa1: and "threw" not "throwed" :D
05:36:09 <osa1> timthelion: "inappropriate type (Not a directory)".
05:36:12 <osa1> oh, thanks :D
05:36:17 <mikeplus64> osa1: if setCurrentDirectory hangs, could your hdd be really slow or something? is s </> relPath evaluating? is merge cs matches being evaluated?
05:36:38 <osa1> mikeplus64: nope, we find the problem. I was passing it a file path instead of a folder
05:36:56 <mikeplus64> oops, timthelion saved the day while i wasc scrolled up
05:37:11 <timthelion> mikeplus64: I didn't do nothin.
05:38:25 <timthelion> osa1: it shouldn't have hung like that.  Probably somewhere a resourcewas getting locked that was hanging GHC.  You could report that as a bug if you whished to build a small test case.
05:41:45 <osa1> timthelion: ok, I'm writing a test case. could it be related with threads? I'm using inotify and it spawns some threads, and this exception is thrown in one of this threads and not in main thread
05:44:55 <timthelion> osa1: yes, it can!  A thread can die with an exception.(as far as I know, that's by design)
05:50:48 * logicalguy is ParahSailin sarah palin?
05:56:00 <timthelion> logicalguy: Yes. Sarah Palin, is not only one of the most prominent women in politics, but also one of the few women who program in a purely functional programming language(sadly, I think there are more prominent women in politics in the world, then women who program in purely functional programming languages...)
05:56:10 <tromp_> hmm, imagine sarah palin going parasailing...
05:56:50 <osa1> timthelion: I found a line in hinotify library (the library I'm using and that creates threads): "catch (handler e) (\_ -> return ()) -- supress errors"
05:57:39 <timthelion> osa1: :D there you go...
05:57:43 <logicalguy> good for her
05:58:29 <osa1> this really needs to change. I'm mailing to the author :D
06:00:19 <Botje> osa1: yes! this typo just cannot stand!
06:00:54 <timthelion> Botje: ?  Typo?
06:01:20 <Botje> 'supress'
06:01:39 <timthelion> heh
06:02:10 <osa1> Botje: there shouldn't be any suppressing after fix, so this will be fixed too :)
06:10:10 <srhb> I keep failing at the "get a clever idea"-part of making proofs. :/
06:13:17 <logicalguy> what do you mean, srcerer
06:13:21 <logicalguy> whoops
06:13:25 <logicalguy> what do you mean, srhb
06:17:41 <srhb> logicalguy: I always seem to get stuck on the part where you have to get a great idea to proceed. but I was mostly venting :P
06:22:23 <shachaf> srhb: I don't think the Applicative thing requires a clever idea.
06:22:49 <shachaf> Of course, I haven't actually done it. So I shouldn't say that.
06:23:07 <srhb> shachaf: Nah, I'm just a baddie and not grasping how to do the composition law proof. I'll get it eventually, I hope :-)
06:23:09 <timthelion> srhb: I have no trouble figuring out cleaver ideas, but it's always difficult for me to figure out which axioms/laws actually apply to a given proof, so my proofs always end up being invalid :P
06:23:20 <srhb> timthelion: Nifty :P
06:25:26 <iamtakingiteasy> hi, how do o convert Float to Integer as it implictly done in C or Java (droping the part after point) ?
06:25:45 <shachaf> truncate?
06:25:51 <iamtakingiteasy> thanks!
06:25:52 <shachaf> It depends on the exact behavior you want.
06:26:01 <shachaf> It might be that what you actually want is floor.
06:26:31 <iamtakingiteasy> what the difference between flooring Float and discarding fractional part ?
06:26:45 <logicalguy> srhb, vent away :)
06:26:48 <atriq> > floor (-1.3)
06:26:50 <lambdabot>   -2
06:26:51 <iamtakingiteasy> ah, isee
06:27:05 <atriq> Floor goes to negative infinity, truncate goes to 0
06:27:21 <iamtakingiteasy> yeah, truncate is what i need
06:27:31 <maybefbi> how is (=<<) . flip liftM same as ap
06:27:49 <maybefbi> :t (=<<) . flip liftM
06:27:51 <lambdabot> forall (m :: * -> *) b a1. (Monad m) => m a1 -> m (a1 -> b) -> m b
06:27:54 <maybefbi> :t ap
06:27:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:28:29 <maybefbi> how should i think of composition of higher order functions
06:28:33 <maybefbi> with more than one argument
06:29:34 <fmap> more that one argument?
06:29:39 <fmap> than*
06:29:41 <maybefbi> yes
06:29:59 <fmap> ?
06:30:08 <maybefbi> (=<<) . flip liftM
06:30:13 <maybefbi> how does it work?
06:30:47 <maybefbi> flip liftM :: m a -> (a -> b) -> m b
06:30:55 <maybefbi> how do i compose that with:
06:31:06 <quicksilver> by viewing it as a single-argument function
06:31:08 <Eduard_Munteanu> flip liftM :: m a -> ((a -> b) -> m b)
06:31:14 <quicksilver> like Eduard_Munteanu just wrote.
06:31:43 <maybefbi> hmm gimme a sec let me digest that curried form
06:32:13 <Eduard_Munteanu> maybefbi: a -> b -> c is a -> (b -> c) by definition
06:32:34 <maybefbi> yes
06:33:08 <maybefbi> but the brackets hadnt existed in my mind for "flip liftM" until just now
06:33:12 <maybefbi> im putting it there.
06:35:10 <Yiq> Anyone deployed happstack to heroku or should i gor for yesod?
06:35:23 <Twey> maybefbi: All functions are single-argument
06:35:37 <Twey> Yiq: Yesod's nicer pe'i
06:35:44 <maybefbi> Twey, copy that
06:36:10 <Yiq> pe'i?
06:37:00 <Yiq> API?
06:39:33 <Yiq> If I calc average and then I get a new value and do: (oldaverage*nbr_measurements+newValue)/(nbr_measurements+1) then that will ALWAYS be the same as calculating the average of all values? So if it isnt it is because how computers handle numbers?
06:43:26 <ziman> the precision of numbers in computers is limited
06:43:31 <Eduard_Munteanu> Yiq: why not remember the sum of measurements as you go?
06:43:40 <Eduard_Munteanu> > 1/3 * 3
06:43:41 <lambdabot>   1.0
06:43:45 <ziman> so if you have a lot of small measurements, it might get quite imprecise
06:44:16 <atriq> > (718/973 * 973)/718
06:44:17 <lambdabot>   1.0
06:44:19 <ziman> > 1/10 * 10
06:44:20 <lambdabot>   1.0
06:47:10 <maybefbi> hey guys i got it! flip liftM :: m a -> ((a -> b) -> m b) and (=<<) :: (a -> m b) -> (m a -> m b),  in (=<<) substituting 'a' with '(a -> b)' and 'b' with 'b', we get (=<<) :: ((a -> b) -> m b) -> (m a -> m b). So composing that (=<<) with flip liftM means the output function ((a -> b) -> m b) of flip liftM will be fed to the input of the new (=<<) when flip liftM is provided with its m a. then the (=<<) will give a function which when provided with m a
06:47:11 <maybefbi>  again will give us m b just like ap does.
06:47:15 <Yiq> Eduard_Munteanu: yes better remember the sum and length than the average
06:48:08 <Shapeshifter> huh. "ghc: panic! (the 'impossible' happened)". It tells me to report this as a bug. Really?
06:48:13 <bartavelle> also there can be problems with remembering the sum when it gets much larger than individial values
06:48:18 <maybefbi> tony morris is a genius!
06:48:35 <Yiq> bartavelle: how?
06:49:04 <bartavelle> floating value are more or less stored as v*2^x
06:49:23 <bartavelle> when x is large, new values won't contribute to the sum at all
06:49:30 <bartavelle> or be horribly rounded
06:50:31 <bartavelle> I suppose some smart people have solutions for that (such as storing various sums in bins of various max values, and promoting them to the next bin when they overflow?)
06:50:44 <bartavelle> I don't know much on this subject but it should already be in a lib
06:51:01 <quicksilver> the simplest solution is to store your sum in an Integer
06:51:15 <quicksilver> (multiplied up by some fixed scaling factor if that is necessary)
06:51:19 <quicksilver> and do the division at the end
06:51:27 <bartavelle> that's true, but you have the scaling factor right
06:51:32 <bartavelle> you must have
06:51:34 <quicksilver> ...and if you wish to round to a fixed-length format do it at the last step there.
06:52:00 <Shapeshifter> Mh, there, I found out what triggers the Panic. Entering 'data Test = Taken | Free deriving (show, Eq)' in ghci 7.4.2 panics it.
06:52:08 <quicksilver> you're quite right that there are clever ways to manipulate multiple floating point registers to gain extra precision.
06:52:09 <Shapeshifter> should be "Show", uppercase.
06:52:48 <quicksilver> however, they are quite fiddly and I would suggest only bothering with them once you have an algorithm with Integer which you have proved (1) to be correct and (2) to be too slow for your needs.
06:53:35 <bartavelle> the simplest solution might be to just use something like the statistics package
06:54:30 <jasonkuhrt> Is there anyone in the haskell community working on supporting NaCl in order to use haskell to drive clients-side web apps? https://developers.google.com/native-client/overview
06:54:53 * hackagebot Elm 0.3.6.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.3.6.1 (EvanCzaplicki)
06:58:40 <Shapeshifter> what the hell... I want to register on the haskell trac and this is the first time I cannot read the captcha.
06:58:58 <Botje> A BOT! KICK IT!
06:59:21 <Shapeshifter> http://hackage.haskell.org/trac/ghc/captcha.png gibberish >.>
07:00:45 <Shapeshifter> meh. got the fourth one right.
07:01:11 <osa1> how can I catch "index too large" exception?
07:02:13 <Cale> osa1: tbh, it's easier not to throw one in the first place
07:02:29 <Botje> osa1: don't generate such errors in the first place :)
07:02:31 <Cale> osa1: You *can* catch it in IO using catch from Control.Exception
07:02:43 <Cale> along with Control.Exception.evaluate
07:02:57 <osa1> uh, ok.
07:02:59 <Cale> to evaluate the expression whose evaluation will cause the exception
07:03:08 <Cale> But it's awkward, and easy to get wrong
07:03:15 <Yiq> osa1: whats your code? lets rewrite it
07:03:25 <quicksilver> and forces a chunk of code into IO which might reasonably be pure
07:03:30 <parcs`> osa1: looks like Data.Array uses the generic ErrorCall exception
07:03:34 <parcs`> which is unfortunate
07:03:49 <osa1> parcs`: I'm working on lists
07:03:55 <parcs`> oh
07:04:09 <Cale> Oh, you don't really want to be using !! anyway
07:04:40 <Twey> jasonkuhrt: Sounds like a recipe for pain
07:05:12 <osa1> Cale: why?
07:05:41 <Cale> osa1: Well, from the performance side of things, xs !! n takes O(n) steps to evaluate, so it's slow
07:06:07 <Cale> osa1: and of course, it's error prone as you've discovered
07:06:14 <osa1> Cale: it's good enough for me since it's length will not be more than 10
07:06:46 <Yiq> osa1: hpaste your code so we can help you rewrite it
07:06:49 <jasonkuhrt> Twey: I haven't looked at it deeply, and doing it would be way beyond me atm, but the general possibility sounds awesome, how much harder can this be than trying to get haskell to compile down to js? and NaCl sounds like you get more direct access to the DOM etc APIs
07:06:53 <Yiq> @paste
07:06:53 <lambdabot> Haskell pastebin: http://hpaste.org/
07:07:06 <Cale> and usually either one of two things will be true: 1) your lists are meant to be accessed in the order of their elements, or 2) there is a better datastructure to store your data in
07:07:36 <osa1> Yiq: I can manage that, but if you really want to see: https://github.com/osa1/thrall/blob/master/src/Thrall.hs
07:08:48 <Cale> osa1: Hey, doesn't the regex library give you the option of getting the matches as an array anyway?
07:09:02 <osa1> Cale: no
07:09:11 <osa1> oh
07:09:14 <osa1> I don't know
07:09:38 <quicksilver> yes, it does.
07:09:54 * hackagebot Elm 0.3.6.2 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.3.6.2 (EvanCzaplicki)
07:09:54 <osa1> quicksilver: how? are you talking about this: http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/Text-Regex.html ?
07:10:58 <Cale> RegexLike a b => RegexContext a b (AllMatches (Array Int) (MatchOffset, MatchLength))
07:12:32 <Yiq> osa1: i thought you were a beginner
07:12:41 <Yiq> what does the program do?
07:14:18 <osa1> Yiq: not much yet. it will watch some folders for changes(ie file additions/modifications) and run some system commands including path of the modified/cread file
07:14:20 <Yiq> god, yesod is huge
07:14:37 <Cale> osa1: If you get the matches as an array, then you'll have the array bounds and will be able to check if the read number is in bounds. Of course, you should also pattern match x to make sure it's nonempty too.
07:15:16 <Cale> (and maybe also use reads and ensure that it parses)
07:15:28 <Cale> Well, depending on which operations are allowed to die
07:16:13 <Twey> jasonkuhrt: I meant NaCl in general.  Blacklisting certain APIs is not a good security measure.  If NaCl ever becomes popular there are going to be security leaks beyond belief.
07:16:56 <Cale> Twey: otoh, it's really nice that I can play Bastion in Linux through it :)
07:17:48 <atriq> You...
07:17:56 <atriq> You can play Bastion natively on Linux anyway?
07:17:59 <Cale> yes
07:18:01 <Yiq> Twey: whats a pe'i? API?
07:18:03 <Cale> er
07:18:12 <Cale> Can you now?
07:18:21 <jasonkuhrt> Twey: and what about something like this? https://github.com/kripken/emscripten
07:18:23 <atriq> I'm pretty sure I do
07:18:27 <merijn> Cale: It was in the Humble Indie Bundle, so yes
07:18:28 <Botje> it was HTML5ed.
07:18:32 <Botje> and that.
07:18:50 <jasonkuhrt> Twey: would it be realistic to go from ghc > llvm > javascript?
07:19:00 <Cale> at the time I got it, there was no native linux client that didn't just go via NaCl
07:19:19 <Cale> But that's interesting :)
07:19:29 <luite> jasonkuhrt: at least it doesn't work out of the box
07:20:13 <jasonkuhrt> luite: what do you mean? i.e. not programming directly on the browser but through indirect build steps?
07:20:42 <luite> jasonkuhrt: i mean that no one has succeeded yet in getting the rts running with emscripten
07:20:52 <luite> i don't know how hard people tried
07:23:12 <Yiq> im on cryptocipher in yesod install, much left?
07:25:05 <luite> jasonkuhrt: i personally expect that compiling haskell directly (without llvm) to javascript would lead to better results
07:25:10 <Yiq> I assume yesod and happstack have templating systems?
07:25:43 <Clint> yesod's are shakespearean templates
07:25:52 <jasonkuhrt> luite: there's a few haskell projects like that out there, with varying degrees of development
07:26:19 <luite> i know
07:29:54 * hackagebot csv-conduit 0.3 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.3 (OzgunAtaman)
07:30:30 <bitonic> GHC programs over emscripten?  that must be fun
07:31:08 <Yiq> [ 5 of 21] Compiling Network.TLS.Struct ( Network\TLS\Struct.hs, dist\build\Netw
07:31:12 <Yiq> how much left(yesod)?
07:31:16 <luite> jasonkuhrt: writing a compiler (backend) and rts is a lot of work. emscripten might be a shortcut for some types of applications, but it's difficult to support something similar to ghci in the browser (where users can load new modules)
07:31:18 <Yiq> seriously, its huge
07:31:37 <luite> Yiq: if you get a recent cabal-install from github, it can install multiple packages in parallel
07:32:24 <jasonkuhrt> luite: not sure if it would help but ES6 will have modules maybe making it easier to support ghci like ones
07:33:55 <luite> i doubt that will help, this is all generated code, so it's easy to fake modules by generating special names and code to register them somewhere
07:34:20 <Yiq> luite: how would multiple in parallell help? running it on both cores?
07:34:56 * hackagebot acid-state 0.7.0 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.0 (DavidHimmelstrup)
07:35:58 <quicksilver> Yiq: it also lets you do something during IOwait even on a single core
07:35:58 <nh2> what is the component that indexes modules on hackage (the reason why some modules are hyperlinks and others not)?
07:36:11 <quicksilver> Yiq: compiling often won't take 100% of CPU due to the IO parts.
07:36:22 <nh2> or: why is the haddock of modules sometimes broken?
07:36:41 <nh2> like in http://hackage.haskell.org/package/csv-conduit - you cannot click the modules
07:36:52 <quicksilver> I have wondered that too, nh2 :(
07:37:23 <Twey> Cale: Really?  o.@
07:37:33 <fmap> nh2: you need to wait for hackage to build documentation
07:37:57 <Twey> Cale: Yeah, I thought Bastion was native.  Doesn't it have to be?  Reading the description, it looks like NaCl just runs a native app with some blackboxing & providing an API.
07:38:01 <nh2> fmap: when will it do that? in intervals / is there a queue?
07:38:10 <fmap> no idea
07:38:27 <luite> jasonkuhrt: i don't know every detail, but i think ES6 will bring very little to improve haskell support
07:38:44 <luite> ES6 WeakMap is unusable for implementing haskell weak refs
07:39:07 <jasonkuhrt> =\
07:39:58 <Yiq> which is the simpler framework of happstack and yesod?
07:40:29 <Cale> Twey: I'm not sure, maybe that's all it is. It seems like there's decent support for all NaCl apps in Linux though, so maybe it's just they make it easy for the apps to be cross platform or something.
07:40:43 <luite> Yiq: it's a bit difficult to compare
07:40:52 <luite> yesod is certainly the one that takes longer to install
07:41:02 <dibblego> maybefbi ?
07:42:17 <timthelion> Are there any zero conf web servers in haskell? Or are they all frameworks?
07:42:37 <luite> timthelion: you mean just serve a directory files?
07:42:57 <timthelion> luite: yes, like in apache how you can just put an index.html in the correct dir and be set...
07:43:15 <luite> timthelion: you can install warp-static, then just run warp in the dir that you want to serve
07:43:25 <luite> or warp -p someport for a port other than 3000
07:43:36 <luite> it serves the current dir and has dir indices
07:43:51 <Yiq> So if Im on 32bit linux i cant deploy on heroku?
07:43:55 <timthelion> and does it also allow for dynamic pages and session management? or is it an all or nothing kind of deal?
07:44:15 <luite> it's just a static file server, if you want dynamic, use the rest of the framework :)
07:45:20 <timthelion> The last time I did any real web dev was on something called "java enterprise" with netbeans 6 years ago!
07:46:11 <luite> Yiq: yeah need 64 bit binaries
07:46:39 <timthelion> That was about the time I gave up on Java, when I discovered that the use has to have the same VM version as you compiled for, making the cross platform theory kind of fail...
07:47:22 <Yiq> timthelion: hows that if youre just serving webpages?
07:48:26 <timthelion> Yiq: the java enterprise stuff was all framework based.  You took the URL as an argument, and then had this magic parser, which turned the URL into a set of variables.  And your function then returned a string of HTML
07:48:36 <timthelion> Yiq: so no files at all.
07:48:56 <timthelion> at least you didn't have to have actual files represent the path locations.
07:49:03 <luite> Yiq: in theory a heroku buildpack could work, that would build the executable with cabal install, but unfortunately heroku doesn't allow enough time for compiling
07:49:26 <dibblego> timthelion: doesn't have to be the same, just up to date
07:49:28 <Yiq> and the user gets served that html-string, why would they need java at all?
07:49:34 <lpsmith> hmm, did ScopedTypeVariables get turned on by default sometime recently-ish in GHC?
07:49:48 <dibblego> timthelion: e.g. code compiled with a target of 1.4 bytecode will run on 1.5
07:49:54 <timthelion> Yiq: they didn't.  But if you wanted to send them an app, then they did...
07:49:57 <dibblego> timthelion: the cross-platform hypothesis is still a joke
07:52:22 <typoclass> lpsmith: not for me ... (7.4.2)
07:54:08 <luite> timthelion: haskell web frameworks also work more or less that way
07:54:12 <timthelion> Yiq: the magic parser theory has security problems though.  It is sometimes hard to make sure that the user couldn't hack into your system by manipulating variables which where directly set in the URL
07:54:41 <luite> oh that soudns more like php
07:54:52 <timthelion> luite: it does seem rather, functional.
07:54:53 <Yiq> lol, yesod is still compiling
07:55:12 <luite> Yiq: you seem to have a pretty slow machine? or perhaps not enough ram?
07:56:11 <timthelion> luite: well, there's not so much risk with java that arbitrary code execution will happen.  But what if the URL contains session&=AIU24AZZX...  and the person can just change that number to find themselves logged in as someone else :P
07:56:31 <Yiq> luite: well connection is slow but machine is average
07:56:38 <timthelion> luite: that actually happend to a major bank in the US, I think it was citybank, but I don't recal.
07:56:42 <Yiq> but compiling takes time not downloading
07:57:22 <neothemachine> hey guys, does anyone have any experience with the monadiccp package?
07:57:42 <luite> timthelion: oh i don't think the haskell stuff suffers from that
07:58:00 <luite> but session hijacking is still possible if you can intercept cookies somehow
07:58:18 <neothemachine> (or constraint programming in haskell in general)
08:04:47 <tdammers> yesod took rather long to compile on my machine too
08:05:18 <srhb> > readOct "0o1" :: [(Int,String)]
08:05:20 <lambdabot>   [(0,"o1")]
08:05:25 <srhb> What am I not understanding here?
08:06:05 <merijn> > readOct "01" :: [(Int,String)]
08:06:07 <lambdabot>   [(1,"")]
08:06:09 <srhb> Oh!
08:06:12 <merijn> > readOct "010" :: [(Int,String)]
08:06:13 <lambdabot>   [(8,"")]
08:06:14 <srhb> So not like Haskell literal octal
08:07:53 <quicksilver> > 0o1
08:07:53 <om> how do I find out where the haddoc docdir is?
08:07:54 <lambdabot>   1
08:08:01 <quicksilver> I don't think I knew that :)
08:08:04 <quicksilver> how quaint.
08:08:09 <geekosaur> > reads "0o10" :: [(Int,String)] -- this perhaps?
08:08:10 <quicksilver> > read "0o1" :: Int
08:08:11 <lambdabot>   [(8,"")]
08:08:11 <lambdabot>   can't find file: L.hs
08:08:16 <quicksilver> yes, apparently.
08:08:32 <hpc> srhb: it's more like, assume that the "0o" is already consumed
08:08:50 <srhb> hpc: Yep, got it, thanks :)
08:08:54 <hpc> reads ('0':'o':digits) = readOct digits
08:09:07 <hpc> :D
08:09:43 <typoclass> > 0o99
08:09:44 <lambdabot>   Not in scope: `o99'
08:10:02 <om> i need to know where the haddock docdir is for some vim plugins
08:10:05 <typoclass> > reads "0o99" [(Int, String)]
08:10:06 <lambdabot>   Not in scope: data constructor `Int'Not in scope: data constructor `String'
08:10:33 <quicksilver> > 0o59
08:10:34 <srhb> typoclass: The error messages are a bit quaint when you use a digit that is not included. :P
08:10:35 <lambdabot>   5
08:10:40 <quicksilver> OK that's really cool
08:10:44 <fmap> om: ~/.cabal/share/doc probably
08:10:51 <quicksilver> with a clever Num instance for functions
08:11:05 <quicksilver> you could do some really nasty obfuscation with lexically invalid octal numbrs
08:12:26 <typoclass> > 678a
08:12:27 <lambdabot>   678
08:12:40 <om> fmap: thanks, but it's not there. It needs to contain some html files from what i've read on the internet
08:13:19 <typoclass> srhb: probably also because i forgot the "::" ... :)
08:14:11 <quicksilver> om: it won't contain anything if you didn't configure cabal to install documentation
08:14:59 <pqmodn> > 0o123888
08:15:00 <lambdabot>   83
08:15:35 <pqmodn> hmm, ghci says something else. it tries to apply the number 0o123 as a function to 888
08:15:42 <hpc> > 0xford
08:15:44 <lambdabot>   15
08:15:48 <quicksilver> pqmodn: ues that's exactly what it does.
08:16:00 <quicksilver> pqmodn: hence my remark "with a clever Num instance for functions"
08:16:05 <pqmodn> ah, neat
08:16:20 <quicksilver> lambdabot has a Num instance for functins, just not an interesting one
08:16:29 <quicksilver> a logical one but one lacking in clever obfuscation possibilities :)
08:16:47 <typoclass> > flip ($) 11pred
08:16:49 <lambdabot>   10
08:17:09 <typoclass> i wonder if that's a feature ...
08:22:43 <Yiq> To store userdata like loginname and password, would you use an sql db?
08:23:32 <quicksilver> Yes. Or No.
08:23:38 <quicksilver> it all depends.
08:23:50 <quicksilver> take a look at acid-state for a non-sql pure persistence solution.
08:24:14 <quicksilver> or safecopy for simpler non-transactional persistence
08:24:39 <quicksilver> but if your data model as a whole is suited to a relational model then you might as well put username/password in the same place.
08:25:19 <Cale> Please don't store user passwords though.
08:25:25 <om> quicksilver: what exactly in the cabal configuration do i need to enable in order for it to fetch documentation for everything installed so far?
08:25:48 <Cale> (use a password hash, of course)
08:25:50 <matthiasgorgens> Yiq: to make cale's statement more obvious: read up on password hashing and salting.  and don't implement your own.
08:26:53 <quicksilver> om: it doesn't fetch it. It builds it when it builds the packages.
08:27:50 <om> so i have to rebuild everything?
08:28:44 <quicksilver> yes.
08:29:17 <quicksilver> strangely I can't see on http://www.haskell.org/cabal/ or http://www.haskell.org/cabal/users-guide/ a clear description of what you have to do
08:29:35 <quicksilver> you put a parameter in ~/.cabal/config
08:29:42 <quicksilver> btu I can't see where that fact is documented
08:30:08 <quicksilver> see, e.g. http://blog.patch-tag.com/2009/10/23/cabal-install-a-package-with-documentation/
08:31:06 <om> ok thanks very much quicksilver
08:32:34 <quicksilver> dcoutts: ^^
08:33:08 <timthelion> Does ghci recognise → as ->?
08:33:16 <dcoutts> quicksilver: yes, the config file is almost totally undocumented. But it does correspond almost 1:1 with the cabal command line flags
08:33:42 <timthelion> I mean, can, not does?
08:34:47 <otters> timthelion: :set -XUnicodeSyntax
08:35:12 <daniel_-> is it recommended to use the haskell module structure for your own internal modules? e.g. "Data.ProcessFinder"?
08:35:42 <timthelion> otters: Nice :D
08:35:52 <otters> word
08:36:08 <timthelion> otters: word?
08:36:16 <quicksilver> daniel_-: I would generally put them under a top-level all of your own
08:36:21 <otters> timthelion: agreeing
08:36:30 <quicksilver> daniel_-: DanielUnderscoreMinus.ProcessFinder, say
08:36:46 <daniel_-> yeah, right now im putting everything under Internal.*
08:37:23 <daniel_-> but im just about to go into phase 2 of my app, where i need to share some libraries and datastructures
08:37:30 <daniel_-> can i have 2 cabal projects in the same folder?
08:37:32 <om> oh man, i'm doing "cabal install --reinstall world" the program outputs: "All requested packages are already installed: use --reinstall if you want to reinstall anyway"
08:37:53 <dcoutts> om: hmm, interesting
08:38:08 <dcoutts> om: can you file a ticket please
08:38:20 <om> i don't even know what that is
08:38:31 <timthelion> om: report a bug
08:38:32 <dcoutts> om: a bug report I mean
08:41:20 <srhb> parseNumber = parseHex <|> parseOct where parseOct = do string "#o" ...; parseHex = do string "#h" ...
08:41:38 <srhb> So why does it never reach parseOct when parseHex works fine? It works if I add a try on each case
08:41:59 <srhb> As I understand it, if the string "#o" fails, nothing should be consumed and it should move on?
08:42:38 <timthelion> hmm, my module is now 1200+ lines long.
08:44:10 <om> dcoutts: i'm using version 0.14.0 is this the latest one?
08:44:18 <dcoutts> om: yes
08:44:26 <Veinor> srhb: i don't know parsec, but maybe it's consuming the #
08:44:29 <om> ok i'm going to file a bug
08:44:29 <Veinor> and then failing on the o
08:44:45 <srhb> Veinor: Yes, that is what is happening.
08:45:26 <Saizan> srhb: <|> in parsec is not symmetric, in p <|> q, if p fails after consuming some input then q is not tried
08:45:46 <srhb> Oh, right
08:46:04 <srhb> so try is the right way to go
08:46:25 <Saizan> or you could factor the # out, if that's not too messy
08:46:45 <srhb> Hmm.
08:47:12 <quicksilver> in particular, you are using parsec as a Char parser
08:47:20 <quicksilver> and so it's committing to the # and it can't backtrack.
08:47:35 <quicksilver> if you used parsec as a token parser for some custom token type
08:47:42 <quicksilver> and #o and #h were both single tokens
08:47:46 <quicksilver> then you wouldn't have this issue.
08:48:03 <srhb> Alright, I'm following the scheme tutorial first, so I think I'll go with "try" and then try making a token parser later on. Thanks both :)
08:55:08 * timthelion gets paranoid, any time, after a major re-write, his code actually compiles.
08:56:41 <hpc> i pretend i am the greatest programmer ever, smoothly covering up my surprise :P
08:57:42 * typoclass files a ghc bug every time he gets a compiler error. gotta be their fault.
08:58:57 <timthelion> I should actually file a ghc bug for a compiler error I got today.  Clear reproducable case of "parse error on =" when the actual error was a lack of a closed parenthesis.  They CAN give a more informative error message than that.
08:59:30 <daniel_-> okay i have basicly three projects i want to share some internal libs. one webserver, one dispatcher and one worker. Where the webserver talks with the dispatcher (on the same physical machine) and dispatcher routes and load balances over the workers (distributed over a network). they share some Data Types API's for communication. how the hell do i structure this with cabal? do i keep the internal libs as a seperate package?
09:00:17 <timthelion> daniel_-: no need to.  You can easilly expose some modules and also have an executable
09:00:23 <dcoutts_> daniel_-: two options: one package containing several exes, or separate packages
09:00:36 <hpc> i vote for single package
09:00:56 <hpc> unless there's a reason why a network would have asymmetrical installs
09:00:58 <daniel_-> i'd also like a single package with multiple exes
09:01:06 <hpc> (say, one server and a bunch of clients)
09:01:13 <dcoutts_> daniel_-: if you go for one package containing several exes, you can also have them share a library, but you can't currently make that library private
09:01:17 <daniel_-> where the folder structure where Project/Worker Project/Dispatcher Project/Webserver Project/Internal
09:01:25 <daniel_-> for maintaining the sourcefiles
09:02:43 <daniel_-> dcoutts_ what means with making the library private?
09:03:19 <dcoutts_> daniel_-: that's not possible. The library would be exposed and other packages could depend on it.
09:03:44 <dcoutts_> daniel_-: if it were possible, other packages would see yours as if it just contained a few exes and no library
09:03:55 <hpc> i don't think keeping the internals private is that important
09:04:10 <hpc> look at how many other packages have "public" module Foo.Internals stuff
09:04:54 <daniel_-> i mostly want it so i dont have to keep one file for each project and sync the Data Types between them
09:13:49 <om> dcoutts_: https://github.com/haskell/cabal/issues/1010 here it is
09:24:54 <rosie> Why does StdGen (random number generator) appear as two integers? random generator :: (Int, StdGen)    -- shows me --   (2092838931,1601120196 1655838864)
09:26:05 <hpc> rosie: look through the source for StdGen - there might be some comments or a link to a paper or something that explains it
09:26:06 <otters> because the next item is the next generator
09:26:16 <hpc> oh, or that
09:26:45 <rosie> otters: do you means the next item is the next seed?
09:27:06 <otters> StdGen is a generator
09:27:34 <rosie> otters: why does it look like two numbers?
09:27:54 <rosie> e.g.  it appears like "1601120196 1655838864"
09:27:57 <parcs`> rosie: internally StdGen is composed of two Int32s
09:27:59 <otters> random someGen --> (randomValue, nextSeed)
09:28:02 <otters> oh, wow
09:28:05 <monochrom> StdGen appearing as two integers is an implementation that must be somewhat leaked because someone wants to use Show and Read for storing and retrieval
09:28:06 <otters> sorry, I was misunderstanding the question
09:28:15 <monochrom> an implementation detail
09:28:36 <monochrom> you may also ask why Data.Set appears as a list
09:29:10 <monochrom> why everything is serialized to a string
09:29:51 <monochrom> a string that looks like numbers or lists or xml or cryptograph
09:29:52 <quicksilver> > read "1 2" :: StdGen
09:29:54 <lambdabot>   1 2
09:30:12 <quicksilver> it's a non-standard read/show instance, that one.
09:30:24 <quicksilver> that is, it doesn't conform to the defacto standard we now have
09:30:31 <monochrom> hell, StdGen is kicked out of the standard altogether
09:30:32 <otters> Hey, and you can make random into a State computation with state
09:30:33 <otters> :t state
09:30:35 <lambdabot> forall s a. (s -> (a, s)) -> State s a
09:30:39 <otters> :t random
09:30:40 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
09:31:09 <rosie> quicksilver: just curious, why two numbers for the seed and not one?
09:36:14 <quicksilver> rosie: because 32 bit state wasn't considered enough
09:36:23 <quicksilver> would be my only guess.
09:38:33 <timthelion> What is haskell's equivalent of Set theory's U?   I'd like to have U :: [a] -> [a] -> [a]
09:38:46 <Cale> :t union
09:38:47 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
09:38:54 <timthelion> hehe, of course :D
09:39:06 <Cale> timthelion: not quite the same type
09:39:10 <Cale> maybe you meant (++)?
09:39:20 <tromp_> > union [0] [0]
09:39:22 <lambdabot>   [0]
09:40:00 <tromp_> union is quadratic time?
09:40:08 <timthelion> Cale: of course Eq...
09:40:17 <Veinor> tromp_: yes, because it can't use Set
09:40:43 <Veinor> Set.union is O(n+m), which is obviously asymptotically optimal
09:40:57 <timthelion> > [1,2,3] \\ [2]
09:40:59 <lambdabot>   [1,3]
09:41:18 <tromp_> > [0,0]\\[0]
09:41:20 <lambdabot>   [0]
09:41:53 <tromp_> > [0,0,0]\\[0,0]
09:41:55 <lambdabot>   [0]
09:41:59 <srhb> timthelion: Why not use Set if you need sets? ^^
09:42:35 <timthelion> srhb: Because one doesn't chose the data types for their entire application over a single operation.
09:42:52 <srhb> timthelion: Ah, it was just that you were using several set-like operations now. :)
09:44:13 <timthelion> srhb: I'm doing dependency resolution.  I need to come up with error messages.  Ironically, finding the error messages is very very hard with haskell.  Normally, you would just set some "error" flag.  But now it's a mess of maybe's and eithers. and then I end up having to do everything twice just to generate a reasonable error message :D
09:44:30 <srhb> timthelion: Sounds messy!
09:44:45 <timthelion> srhb: writting this application with no error messages is like 40% shorter...
09:44:52 <srhb> Yikes.
09:44:59 <timthelion> And it requires about 100x the memory :D
09:45:44 <timthelion> srhb: well, you want your compiler to give you error messages, no?
09:45:53 <srhb> timthelion: Yes please! :P
09:46:07 <srhb> I have no idea the complexity of the problem. I'm just baffled that the difference would be so large.
09:46:43 <monochrom> It is not so bad with Either. use the Left case to remember the kind of error
09:46:50 <om> anyone here using vim with haskellmode for development?
09:46:51 <timthelion> The funny thing for me though, is the difference in memory usage.  Because a list of [a] can be lazy.  Where as an Either [a] Error, must evaluate completely inside memory just to decide if there is an error or not.
09:47:15 <srhb> Either [a] Error sounds weird!
09:47:20 <srhb> Why isn't it Either Error [a] ?
09:47:28 <byorgey> timthelion: you could also try using [Either Error a]
09:47:35 <timthelion> srhb: I'm an idiot, thats why :)
09:47:50 <timthelion> I'm still not clear on how that helps me though.
09:47:52 <srhb> timthelion: You're using Haskell, can't be that bad. ;)
09:48:11 <mcstar> timthelion: only an idiot wont understand how beaing an idiot wont help you...
09:48:17 <mcstar> being
09:48:26 <mcstar> j/k btw
09:48:37 <srhb> You get a lot of free tools for short-circuiting and things in the Either monad, I believe. Not that I know it would help you
09:48:43 <timthelion> Well, it doesn't help me at all with the cases that I'm running into.
09:49:22 <srhb> > foldr (liftM (+)) (Right 0) [Right 1, Right 2, Left "AARHGH"]
09:49:23 <lambdabot>   Couldn't match expected type `a1 -> a1'
09:49:23 <lambdabot>         against inferred type `Data...
09:49:25 <srhb> eep
09:49:46 <srhb> > foldr (liftM2 (+)) (Right 0) [Right 1, Right 2, Left "AARHGH"]
09:49:47 <lambdabot>   Left "AARHGH"
09:49:49 <Veinor> timthelion: checking whether an Either Error [a] is a Left or Right doesn't force the [a] or the Error...
09:50:10 <timthelion> Like I have a takeWhile, and takeWhile returns type [a].  But what I need is takeWhileWithFlag :: (a->Bool) -> [a] -> (Bool,[a])... So that I can know if it took the whole list or just part of it(if I want to show an error instead of simply sometimes producing the wrong result.
09:50:17 <timthelion> That forces me to write a new takeWhile...
09:50:22 <Veinor> > let isLeft (Left _) = True; isLeft (Right _) = False in isLeft (Left undefined)
09:50:24 <lambdabot>   True
09:50:28 <Veinor> > let isLeft (Left _) = True; isLeft (Right _) = False in isLeft (Right undefined)
09:50:30 <lambdabot>   False
09:51:27 <timthelion> srhb: that is nice I guess.
09:51:39 <timthelion> srhb: when I started, I didn't think of such an approach :)
09:51:46 <mk> in haskell, is a monoid a set, a type, or?
09:51:49 <srhb> timthelion: I don't know whether you'd be able to use it, but that's the deal with the Error Monad basically.
09:51:57 <Veinor> mk: what do you mean
09:51:58 <srhb> timthelion: But I don't know if short-circuiting is any help at all for you
09:52:14 <mk> Veinor: "what's a monoid"?
09:52:26 <mk> or define monoid
09:52:26 <Veinor> instances of the Monoid typeclass, such as Any, [Int], and (), are types
09:52:31 <timthelion> srhb: that would have been a cleaner way to write my code.  But I'm really nearly done.
09:52:33 <hpc> @src Monoid
09:52:34 <lambdabot> class Monoid a where
09:52:34 <lambdabot>     mempty  :: a
09:52:34 <lambdabot>     mappend :: a -> a -> a
09:52:34 <lambdabot>     mconcat :: [a] -> a
09:52:38 <srhb> timthelion: Ok :)
09:52:52 <hpc> a monoid is a type that implements those operations
09:52:59 <mk> ok, typeclass
09:53:02 <hpc> plus some laws
09:53:08 <timthelion> srhb: I don't really want to rewrite all 1300 loc I have here.
09:53:11 <mk> numbers are a monoid?
09:53:32 <hpc> they are two monoids, in fact
09:53:36 <Veinor> yeah
09:53:40 <hpc> mempty = 1, mappend = (*)
09:53:41 <mk> right, + and *
09:53:46 <hpc> mempty = 0, mappend = (+)
09:53:59 <mk> what's the right way of talking about that?
09:54:00 <srhb> timthelion: Well, at least now you know for some other time! :D
09:54:11 <typoclass> mk: there's a module named Data.Monoid, and it offers the typeclass Monoid that hpc just quoted. it's basically a thing that you can append to. lists, for example.
09:54:11 <Veinor> in 7.4, mappend is also known as (<>)
09:54:41 <srhb> @index (<>)
09:54:42 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
09:54:47 <srhb> Hm.
09:54:56 <srhb> @hoogle (<>)
09:54:57 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
09:54:57 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
09:54:57 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
09:54:58 <timthelion> srhb: sure!  The trouble with haskell, is that it's too easy.  You start out writting, and you get a good way done before you realized that you fucked up the types.  If it was just a little harder to write, then I wouldn't feel that I had so much to throw away by fixing things.
09:55:01 <srhb> It does not exist!
09:55:02 <Veinor> i thought it was in 7.4, anyway!
09:55:05 <aristid> srhb: it's in Data.Monoid now.
09:55:06 <typoclass> srhb: no, it's in base. it's a synonym for mappend now
09:55:09 <aristid> Veinor: you are right.
09:55:24 <typoclass> @instances Monoid
09:55:25 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:55:35 <srhb> aha
09:55:46 <typoclass> mk: ^^ here's the two monoid instances they described. Sum and Product
09:57:19 <mk> typoclass: ok - that makes sense. So we don't really call the type a monoid - the monoid is the typeclass of the type
10:02:27 <eacameron> So I'm once again stumped by Typeclassopedia's Functor exercises. I'm trying to write a Functor instance for ITree but one of ITree's constructor's is `Node [ITree a]` which is really throwing me. How do I fmap over the list?    http://www.haskell.org/haskellwiki/Typeclassopedia#Instances
10:04:14 <MostAwesomeDude> eacameron: Aren't lists Functors too?
10:04:14 <srhb> eacameron: You already have fmap defined for lists, yes?
10:04:51 <eacameron> MostAwesomeDude: srhb: yeah...that's what I thought. So I wrote (partially): `fmap f (Node xs) = Node (fmap f xs)` but no go!
10:05:30 <MostAwesomeDude> eacameron: Hm, that's what I'd do.
10:05:51 <srhb> eacameron: Did you get Leaf right?
10:06:31 <eacameron> srhb: fmap f ( Leaf g )  = Leaf (f . g)
10:06:56 <srhb> So you're missing an fmap?
10:07:04 <eacameron> srhb: I never thought to look at that since the compiler was complaining about my the other line
10:07:31 <srhb> It looks right to me
10:08:06 <eacameron> srhb: missing an fmap you say? let me ponder that one
10:08:22 <Cale> eacameron: you need to apply fmap f to each of the trees in the list
10:08:29 <Cale> right?
10:08:32 <eacameron> Interestingly, this guy has almost the same answer: http://hpaste.org/55449
10:08:51 <eacameron> Cale: ahh yeah!
10:08:54 <eacameron> that makes sense
10:08:58 <srhb> That's what I meant by missing an fmap :-)
10:09:41 <eacameron> srhb: ahh now I see it in the hpaste too
10:09:47 <eacameron> srhb: Cale: thank you
10:10:26 <srhb> eacameron: Just a nit, I'd use your function functor in the Leaf case too
10:11:03 <eacameron> srhb: ahh cool...good idea
10:13:16 <srhb> I wish we could encode laws in types. :/
10:13:21 <srhb> Like, functor laws etc.
10:14:01 <byorgey> srhb: use Agda!
10:14:09 <hpc> srhb: we are gradually getting closer to being able to do that
10:14:11 <srhb> But I also want to make real programs doing real things! :P
10:14:15 <srhb> hpc: Yes, so I hear.. :)
10:15:50 <mcstar> someone argues with me that it is soo natural that append destructively modifies
10:15:59 <mcstar> c++
10:16:14 <srhb> mcstar: Stop. Breathe. :-)
10:16:16 <mcstar> im soo disagreeing
10:16:19 <mcstar> :(
10:16:25 <Veinor> someone has a different opinion on the internet!
10:16:26 <mcstar> ok, ill do that
10:16:35 <hpc> mcstar: it's completely natural... in c++
10:17:05 <DT``> srhb, until we find a way to do hypercomputation, I guess you'll have to be content with rational programs doing rational things... I'll get my coat.
10:17:19 <xmattdh> This is probably a completely nooby question and answered alsewhere, but where would I go around starting learning Haskell?
10:17:30 <srhb> xmattdh: learn you a haskell
10:17:32 <srhb> @where lyah
10:17:32 <mcstar> let me do it
10:17:33 <lambdabot> http://www.learnyouahaskell.com/
10:17:37 <mcstar> @where lyah
10:17:37 <lambdabot> http://www.learnyouahaskell.com/
10:17:56 <srhb> xmattdh: There's also tryhaskell.org for a very quick tutorial
10:18:02 <srhb> xmattdh: It's very very basic though.
10:18:26 <srhb> But you might want just that. :)
10:18:44 <xmattdh> Okay, I think learn you a haskell looks good - I already have a general programming knowledge and tryhaskell looks too much like tryruby for my liking
10:19:13 <Shapeshifter> I'm looking for the 'source-language escape conventions' that are mentioned hundreds of times in the API but never actually linked.
10:19:25 <srhb> xmattdh: I think that was basically the point of it, yes. :-) But yeah, get The Haskell Platform and read LYAH and you're on the way to coolness.
10:19:39 <Shapeshifter> It's funny because Google finds the beforementioned API docs but not the conventions themselves.
10:19:58 <srhb> xmattdh: If you're not used to the functional paradigm, your general knowledge is probably mostly useful for "knowing where to go when things get stuck"
10:20:01 <typoclass> xmattdh: skip a few chapters if lyah is going at it too slowly. another good book that's available free of charge is rwh --
10:20:03 <typoclass> @where rwh
10:20:04 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:20:17 <byorgey> Shapeshifter: eh? what API are you talking about?
10:20:31 <Shapeshifter> byorgey: www.haskell.org/ghc/docs/
10:20:40 <Shapeshifter> https://www.google.com/search?hl=en&q=" source-language escape conventions"
10:20:55 <xmattdh> •typoclass• I like to learn slowly, I like to learn about why, what, when, where and how before I dive into learning the actual language
10:21:27 <xmattdh> Because some tutorials just go: So, here, learn this because you 'might' use it for this and this and this
10:21:30 <byorgey> Shapeshifter: oh. see the Haskell report: http://www.haskell.org/onlinereport/haskell2010/
10:21:39 <xmattdh> While I like to learn more before I dive in
10:21:47 <srhb> xmattdh: I think that's a difficult way to go with Haskell, but maybe RWH is better then. I'm not really sure.
10:21:50 <hpc> xmattdh: lyah does a great job of building up the "why" before going through code
10:21:52 <mebaran151> hey #haskell, I'm trying to design a quick library that interfaces with the Salesforce REST API
10:22:00 <Shapeshifter> byorgey: ahh, thanks
10:22:00 <srhb> I don't know..
10:22:03 <mcstar> srhb: wanna recommend typeclassopedia to him? :)
10:22:08 <srhb> mcstar: Hah!
10:22:17 <mebaran151> so far I've gotten logging in working, but I'm not quite sure what the idiomatic pattern would be for designing actions against the API
10:22:22 <srhb> I think that's going into space rather than diving into the deep end.
10:22:42 <byorgey> Shapeshifter: specifically http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
10:22:49 <xmattdh> Oh well, maybe I'll waste my time reading all of them.
10:22:52 <mebaran151> would it be idiomatic to a create a SalesforceService type, and if so, how would it work?
10:22:54 <xmattdh> And I might learn something ;)
10:23:04 <srhb> xmattdh: Have a go at LYAH first, it's really good, if you don't like it come back. Or just stick around ;)
10:23:15 <xmattdh> Link?
10:23:18 <xmattdh> Oh
10:23:18 <srhb> @where lyah
10:23:19 <lambdabot> http://www.learnyouahaskell.com/
10:23:20 <hpc> mebaran151: we can give better help if you write some code yourself which we can review and give tips
10:23:20 <xmattdh> Nevermind
10:23:21 <srhb> That one!
10:23:22 <xmattdh> Sorry
10:23:37 <mebaran151> hpc, I have some quick code: should I throw it on a pastebin?
10:23:38 <hpc> there isn't generally an "idiomatic" way of doing things in haskell
10:23:44 <hpc> sure
10:23:51 <srhb> @where hpaste
10:23:52 <lambdabot> http://hpaste.org/
10:23:52 <byorgey> xmattdh: in that case you'll want to read several tutorials and ask lots of questions in here! =)
10:24:05 <xmattdh> :D
10:24:20 <lispy> http://corp.galois.com/blog/2012/8/21/galois-internship-available.html <-- Send in your resume today!
10:24:27 <xmattdh> I like the mood of this channel, will be back after working through some LYAH
10:24:30 <typoclass> xmattdh: right, good plan :) if you need reading material on any topic, ask in here. folks will recommend the best texts
10:24:50 <byorgey> lispy: already forwarded to some undergrads!
10:25:05 <zomg> "The ability to be geographically located in Portland during the internship."
10:25:11 <zomg> Another company which doesn't want to hire the best people...
10:25:12 <zomg> lol
10:25:16 <mebaran151> here's the paste: http://hpaste.org/73472
10:25:18 <hpc> heh
10:25:36 <hpc> zomg: https://www.youtube.com/watch?v=AVmq9dq6Nsg
10:25:38 <byorgey> notice it doesn't say you need to be in portland, just that you must have the ABILITY to be located there.
10:25:40 <Veinor> it's a shame that a lot of the haskell internships i see are in industries that i'm not interested in
10:25:51 <hpc> byorgey: more importantly, doesn't specify which portland
10:25:53 <zomg> hpc: denied in finland
10:25:56 <hpc> maine, here i come!
10:25:58 <lispy> byorgey: awesome, thanks!
10:26:07 <byorgey> hpc: also a good point!
10:28:39 <luite> hmm
10:29:34 <Automorphism> I am compiling GHC from source, where does "make install" install it by default? (That is, if I passed no arguments to "./configure".)
10:29:39 <luite> oh it was also posted on -cafe
10:30:05 <byorgey> hpc: in fact, according to The Internet, there are also Portlands in TX, TN, IN, CT, NY, MI, WI, PA, ND, and AR!
10:30:30 <byorgey> Automorphism: probably /usr/local/...
10:30:40 <srhb> Automorphism: make show VALUE=prefix
10:30:45 <typoclass> lispy: thanks for the link!
10:30:51 <byorgey> well, that's for Linux at least, it depends on the OS
10:31:16 <hpc> byorgey: that's a lot
10:31:33 <Automorphism> srhb: Oh, nice, I did not know that trick. ty, byorgey and srhb.
10:31:38 <srhb> Welcome.
10:31:48 <hpc> funny story: the other day i drove through arlington to get to one airport, then flew to another state and drove through arlington to get to my final destination
10:32:09 <srhb> hpc: I hope it was the same Arlington.
10:32:12 <hpc> nope
10:32:14 <srhb> :(
10:32:22 <hpc> it could have been though
10:32:32 <byorgey> hpc: hehe, which Arlingtons?  I know of three
10:32:34 <hpc> there's a couple of airports nearby
10:32:39 <hpc> byorgey: dc, boston
10:32:45 <lispy> hpc: have you seen this version? https://www.youtube.com/watch?v=mPKe9OfWs-M
10:33:00 <hpc> omg
10:33:06 <hpc> that's awesome
10:33:11 <byorgey> hpc: right.  I used to live in the DC Arlington when I was little.
10:33:22 <mcstar> must haves: Good knowledge of C/C++.
10:33:28 <mcstar> didnt anybody catch that ^^ ?
10:33:33 <mcstar> in bold..
10:33:49 <mcstar> ah no, it isnt in bold
10:34:36 <lispy> mcstar: C/C++ is hard to avoid for autonomous vehicles. But don't worry, we like DSLs.
10:35:30 <mcstar> do a 'very good haskell knowledge' is implicitely assumed?
10:35:35 <mcstar> so
10:35:41 <n-dolio> Is that like PL/I?
10:35:42 <shapr> ghclive is causing lots of cabal dependency excitement... maybe the package author could include an optional list of exact deps that DOES work somehom?
10:36:36 <lispy> mcstar: Send your questions to this guy: http://corp.galois.com/lee-pike/
10:37:13 <mcstar> ah, sry, im waay out location wise
10:37:16 <n-dolio> @karma C/C
10:37:17 <lambdabot> C/C has a karma of 227
10:38:24 <shapr> tromp_: You got credits on my ghclive project for writing the Hilbert curve for diagrams :-)
10:38:42 <srhb> Can anyone recommend an Agda tutorial for an intermediate novice Haskeller? :P
10:39:00 <lispy> srhb: ask in #agda
10:39:07 <lispy> srhb: quite a few haskellers hang out there
10:39:15 <srhb> lispy: Thanks :)
10:39:39 <lispy> shapr: this ghclive thing is your gsoc?
10:39:48 <shapr> yes!
10:39:51 <lispy> shapr: rock on
10:40:00 <typoclass> @remember srhb I think that's going into space rather than diving into the deep end.
10:40:00 <lambdabot> Done.
10:40:07 <srhb> shapr: Real nice job on that :-)
10:40:13 <shapr> lispy:  and I consider it to be thoroughly sexy. Did you see edwardk's screenshot?
10:40:16 <shapr> srhb: thanks!
10:40:35 <paolino> hello, I see packages have gpl or bsd licenses, I understand bsd is permissive , so gpl libraries are happy to depend on them, is it ok the other way around , or bsd projects cannot depend on gpl ones ?
10:40:41 <shapr> srhb: props to luite for being an awesome helpful mentor for months, and edwardk and darius for code help the past few days.
10:40:41 <lispy> shapr: Dunno if it was ed's screenshot, but someone at work put a link to a screenshot in chat
10:40:59 <shapr> lispy: This is ed's screenshot: http://i.imgur.com/w5e5D.png
10:41:17 <lispy> paolino: gpl is more restrictive. If something in your project uses that then in principle your license is constrained to gpl.
10:41:29 <lispy> paolino: but they can be used together
10:41:35 <c_wraith> shapr: are you prepared for us to insist you fix it with every ghc update? :)
10:41:42 <lispy> shapr: ah yeah, that's the one
10:41:43 <shapr> c_wraith: yup!
10:41:44 <t7> > let rec r = if r == 0 then "Hello!" else rec (pred r) in rec 10
10:41:46 <lambdabot>   <no location info>: parse error on input `rec'
10:41:53 <typoclass> shapr: oh nice :)
10:42:01 <shapr> c_wraith: It still has some problems that need fixing, but I hope it will get sexier!
10:42:04 <t7> > let reca r = if r == 0 then "Hello!" else reca (pred r) in reca 10
10:42:05 <lambdabot>   "Hello!"
10:42:15 <t7> :type rec
10:42:23 <t7> @hoogle rec
10:42:24 <lambdabot> Prelude recip :: Fractional a => a -> a
10:42:24 <lambdabot> Control.OldException RecConError :: String -> Exception
10:42:24 <lambdabot> Control.Exception.Base RecConError :: String -> RecConError
10:42:35 <shapr> c_wraith: For example, sound and animation and/or G+ hangout integration.
10:42:43 <conal> i'm looking for help with crazy-long compile times when using GHC with profiling. a source file has a single 10k line top-level definition, which is a CAF. with -prof auto-all or an explicit SCC, compilation runs for 8 hours on a fast machine with the heap growing to 13GB before being killed. without profiling, it compiles in minutes. any ideas?
10:42:58 <KBme> man
10:43:04 <hpc> dude what
10:43:06 <lispy> paolino: due to the restrictiveness of gpl (and GHC's cross module inlining) you will find that most people in the Haskell world avoid GPL and LGPL and prefer BSD/Apache/MIT licenses that are more permissive.
10:43:06 <KBme> is there an alternative to cabal?
10:43:15 <paolino> lispy hosc is gpl, if I put up a project depending on it , should it be gpl ?
10:43:40 <hpc> conal: what if you compile with profiling, but don't set any breakpoints or anything?
10:43:54 <hpc> cost centers, whatever they are called
10:44:23 <lispy> paolino: I'm not a lawyer, but my understanding is that the answer is basically yes. The problem is that code that directly interfaces with the library needs to also be gpl and then it's sort of transitive from there. I could be way off.
10:44:42 <KBme> cabal is horrible to use. I don't think I have ever managed to actually install anything with only cabal
10:44:50 <c_wraith> paolino: no, your code can be under a less restrictive license, if you desire.  That will mean that if the libraries you depend on ever change their license to be something like BSD, you don't need to change anything
10:44:57 <copumpkin> lispy: when can we donate to haskell.org?!?!
10:45:05 <copumpkin> :) :) :)
10:45:09 <copumpkin> (: (: (:
10:45:13 <copumpkin> >_>
10:45:14 <hpc> KBme: cabal is kind of like linux; it knows when you don't understand it and actively undermines you
10:45:14 <copumpkin> <_<
10:45:24 <KBme> heh
10:45:28 <conal> hpc: in that case, compilation finished fine.
10:45:28 <hpc> once you understand it, you can go through exactly the same steps you took before, but somehow this time it will work
10:45:43 <KBme> but why is it that I *always* bump into dependency problems with cabal?
10:46:18 <KBme> either that or I simply can't use it because hackage is down.
10:46:19 <monochrom> cabal-install works for me
10:46:35 <hpc> conal: try refactoring?
10:46:50 <paolino> c_wraith, it's just tha someone else using my code cannot use the permissiveness?  I'm very confuse
10:46:55 <hpc> not sure what you are doing, but a single module with a 10k-line top-level CAF sounds really wonky
10:47:09 <conal> hpc: yeah. sadly it's auto-generated code. and not of my making.
10:47:14 <hpc> aw
10:47:25 <hpc> try a bug report, maybe?
10:47:32 <hpc> with ghc or the tool that generated it
10:47:46 <conal> yeah. thanks.
10:47:48 <KBme> what is cabal-install?
10:48:10 <hpc> KBme: cabal-install is the package for "cabal"
10:48:12 <typoclass> KBme: cabal can be a bit brittle, yes. sorry for that, folks are working on it. have you tried running with -v3 and if you get stuck pasting cabal's output in here? many things are reasonably easy to fix
10:48:15 <typoclass> @where hpaste
10:48:16 <lambdabot> http://hpaste.org/
10:48:21 <hpc> on hackage, the "Cabal" package is a library for common utilities
10:48:30 <hpc> cabal-install is the "cabal" command-line tool
10:48:40 <hpc> cabal-dev and various other things also use Cabal the lib
10:48:42 <KBme> ah ok, that's what I'm using
10:48:52 <KBme> and I can't get anything to install, really
10:49:01 <KBme> there are constant dependency problems
10:49:10 <hpc> @where hpaste
10:49:11 <lambdabot> http://hpaste.org/
10:49:15 <KBme> packages that won't build, others that depend on borken packages etc…
10:49:22 <hpc> KBme: ^ can you paste a broken build?
10:49:34 <hpc> maybe someone here can diagnose it
10:50:00 <monochrom> as a corollary to what hpc said, reading my http://www.vex.net/~trebla/haskell/sicp.xhtml may suddenly get cabal-install to work
10:50:02 * hackagebot monoid-extras 0.1.0.0 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.1.0.0 (BrentYorgey)
10:50:16 <hpc> monochrom: lol
10:50:24 <hpc> yeah, that's a really good article
10:50:29 <KBme> hmmm, hpaste doesn't post in here weird
10:50:34 <KBme> http://hpaste.org/73474
10:50:41 <KBme> hpc, here you go ^
10:50:52 <hpc> KBme: the hpaste bot is down, apparently
10:50:53 <conal> it would also help to be able to turn off auto-all for that one module. i don't know how to, as we're using 'ghc --make -prof -auto-all', so the auto-all propagates to all of the modules. i tried overriding with a OPTIONS_GHC pragma, but ghc objected to a -prof there.
10:50:59 <KBme> ok
10:51:03 <KBme> well there it is
10:51:30 <hpc> @tell chrisdone the hpaste bot is down, in case you didn't know
10:51:31 <lambdabot> Consider it noted.
10:51:35 <donri> KBme: common cabal issues: missing C dependencies (run install twice to get less noise, it will tell you about missing header files and such); ~/.cabal/bin not in $PATH (add it in ~/.bashrc); refusal to break previously installed packages (use cabal-dev or ghc-pkg unregister)
10:52:15 <KBme> it is in my path and the path is in .bashrc
10:52:26 <typoclass> KBme: oh wow o_O
10:52:29 <KBme> refusal to break previously installed packages (use cabal-dev or ghc-pkg unregister) -- i don't get this
10:52:42 <KBme> missing C dependencies (run install twice to get less noise, it will tell you about missing header files and such) -- i don't understand this either
10:52:50 <KBme> typoclass, what?
10:52:58 <paolino> KBme, version of ghc ?
10:53:16 <hpc> (ghc -V or --version)
10:53:17 <typoclass> KBme: i'm just surprised by what you pasted
10:53:21 <hpc> (-v is verbose)
10:53:23 <KBme> The Glorious Glasgow Haskell Compilation System, version 6.12.1
10:53:29 <monochrom> I cannot reproduce that compiler error
10:53:36 <donri> ah, that's ancient by haskell standards
10:53:38 <hpc> KBme: you will want to update to 7.4
10:53:44 <paolino> yep
10:53:48 <donri> you need ghc 7.0+ now for happstack I think
10:53:52 <KBme> ok, but this is the default debian version
10:53:57 <KBme> can I use cabal to do that?
10:54:11 <KBme> also, compiling ghc will eat my laptop and burn it in flames
10:54:12 <hpc> KBme: which debian? stable or testing?
10:54:13 <donri> nope. you could use apt pinning to get it from sid, maybe
10:54:15 <KBme> stable
10:54:25 <hpc> yeah, stable is sloooooooooow to update packages
10:54:41 <hpc> @where ghc
10:54:42 <lambdabot> http://haskell.org/ghc
10:54:55 <dcoutts_> KBme: or install an older happstack version, e.g. you can try --constraint="network ==2.2.*" to get it to stick to the version of network that you've got installed already
10:54:57 <hpc> you probably want to blow away your existing ghc and packages
10:55:00 <donri> KBme: your problem here is that you're mixing stable OS packages from debian with the bleeding edge from hackage
10:55:03 <hpc> then install a modern ghc yourself
10:55:05 <typoclass> still, kbme has a point. ideally a package (especially such a basic one as network) should have better version bounds, instead of trying to compile and failing obscurely ...
10:55:17 <paolino> KBme, http://www.haskell.org/ghc/download_ghc_7_4_2
10:55:27 <donri> KBme: for example you could probably install an older happstack just fine. but i really recommend upgrading ghc instead.
10:55:31 <dcoutts_> typoclass: yes, it's wrong deps on network here, if cabal knew it didn't work, it wouldn't try to install it
10:55:45 <typoclass> dcoutts_: right, that's what i mean
10:56:09 <monochrom> I think it's old parsec rather than old ghc
10:56:16 <paolino> right
10:56:27 <dcoutts_> KBme: if you want to try getting an older happstack to work I also recommend upgrading to cabal-install-0.14 which has a better solver and that'll help you with trying to install older versions
10:56:36 <KBme> i'm not a newbie with regards to programming and systems administration, i have used quite a few package managers, but with this I'm not really able to figure out anything
10:56:45 <KBme> i have upgraded cabal, though
10:56:59 <KBme> which cabal\n/root/.cabal/bin/cabal
10:57:01 <timthelion> > foldr (liftM2 (++)) (Right []) [Right [1],Right [2]]
10:57:04 <lambdabot>   Right [1,2]
10:57:11 <monochrom> cabal-install is not package management. this is why your expertise doesn't help
10:57:13 <hpc> KBme: yeah, you aren't alone with that; what helped me was realizing cabal wasn't a package manager
10:57:16 <hpc> but a build tool
10:57:24 <timthelion> What doesn't that work in ghci? What do I need to import?
10:57:28 <paolino> KBme, it's not cabal fault, it's network package bounds broken
10:57:29 <KBme> but it's supposed to handle dependencies and the sorts
10:57:32 <dcoutts_> KBme: ok so basics are to use --dry-run to have it show what it'd do, and to know that you can guide the solver to do what you want using things like --constraint="pkg < x.y"
10:57:35 <KBme> that's a package managers job
10:58:00 <monochrom> also if you read my http://www.vex.net/~trebla/haskell/sicp.xhtml you will realize that all your intuition about c lib compatibility doesn't help either
10:58:09 <donri> KBme: what cabal needs to do is much more complicated than what something like apt/dpkg needs to do, though
10:58:10 <KBme> ah well, i'll stop bi**ing
10:58:11 <KBme> sorry
10:58:16 <KBme> it's just that i'm pretty lost
10:58:25 <typoclass> monochrom: there's quite some overlap between what cabal does and package management. if a "removing" feature and a few other things were added, it'd be a package manager
10:58:32 <KBme> donri, I use gentoo ;)
10:58:40 <donri> you said you're on debian stable
10:58:53 <donri> but gentoo too does something much more simple
10:58:55 <KBme> well, right now I'm trying to do it on debian
10:58:57 <dcoutts_> KBme: and the other thing is to think top down, not bottom up, ask cabal install --dry-run to install the main goal, rather than doing it by installing a dependency here or there
10:59:05 <KBme> uh
10:59:28 <KBme> is there a way to use cabal inside my home, with a prefix?
10:59:38 <monochrom> also, the world's best dependency resolver doesn't help if the human-written dependency list is wrong
10:59:45 <srhb> That's how it usually works, KBme
10:59:46 <KBme> monique_, sure
10:59:48 <dcoutts_> KBme: yes, it does that by default, and it can be overridden with --prefix
10:59:53 <KBme> monochrom, sure, true dat
10:59:55 <monochrom> in this case, network-2.3.1.0 has a wrong human-written dependency
11:00:13 <donri> or is it happstack-server which is wrong?
11:00:15 <KBme> dcoutts, ok, so how would I use, for example, $HOME/cabalroot as a prefix?
11:00:28 <KBme> dcoutts_, ^
11:00:36 <dcoutts_> KBme: the default prefix is $HOME/.cabal
11:00:59 <mcstar> mkdir cabalroot; ln -s ~/.cabal ~/.cabalroot
11:01:05 <timthelion> can someone please tell me why I get No instance for (Monad (Either a0)) in ghci? What do I need to import.  Lambdabod does not complain.
11:01:06 <dcoutts_> KBme: you can change it for a single install using cabal install --prefix=$HOME/cabalroot, or persistently by editing the ~/.cabal/config file
11:01:07 <hpc> donri: i have happstack-server, and it's not wrong
11:01:07 <monochrom> I don't know whether happstack-server does wrong things. but I know network-2.3.1.0 does
11:01:14 <KBme> and is there a script, like for example with pip, that I can source so that all the cabal-installed packages become available?
11:01:18 <donri> hpc: you don't have ghc 6.12
11:01:22 <hpc> that too
11:01:30 <paolino> timthelion, Control.Monad.Instances
11:01:33 <dcoutts_> KBme: put .cabal/bin on your $PATH
11:01:35 <donri> i think it is in deed network which is wrong though, in its dependency on parsec
11:01:36 <timthelion> paolino: thankyou !
11:01:38 <monochrom> it says "parsec >= 2.0" but it's a compiler error with parsec-2.1.0.1. no error with parsec-3.*
11:01:48 <KBme> dcoutts, is that it? and for libraries?
11:01:59 <dcoutts_> KBme: all the library packages are available by default once you install them
11:02:21 <KBme> if I have a lib installed on my system aswell as in the cabal .cabal dir, I'm guessing it'll use the system ones?
11:02:27 <dcoutts_> KBme: you have to do different if you wanted to register them into a different package db (the --package-db flag)
11:02:36 <KBme> really, ghc looks in $HOME/.cabal by default?
11:02:51 <hpc> KBme: it looks on its build path
11:02:51 <donri> KBme: if you want something like virtualenv, there's cabal-dev. but cabal-install defaults to user installs.
11:02:57 <SLi> Hi. A newbie question :) If I have a type like Color {red, green, blue :: Double}, and would like to have a function like "mapColor f c = Color (f $ red c) (f $ green c) (f $ blue c)", am I right that Color cannot be made an instance of Functor, because the wrapped type (Double) is not generic?
11:02:57 <hpc> depends on how the path is ordered
11:03:06 <dcoutts_> KBme: no, the per-user ghc package db is in ~/.ghc and cabal registers into that by default
11:03:07 <KBme> donri, yeah, virtualenv is what I want
11:03:13 <monochrom> you see why I said all your intuition about c libs doesn't carry over. ghc does not "scan directories for libs"
11:03:18 <KBme> dcoutts, ah ok, so that's fine
11:03:19 <dcoutts_> KBme: the global and per-user packages are both available, yes
11:03:24 <KBme> ok great
11:03:29 <KBme> and default will be per-user?
11:03:33 <dcoutts_> yes
11:03:35 <hpc> SLi: it can't be Functor because Color is the wrong kind
11:03:36 <KBme> great
11:03:37 <hpc> (probably)
11:03:50 <monochrom> just bloody read my http://www.vex.net/~trebla/haskell/sicp.xhtml
11:03:56 <hpc> SLi: let's get the full definition written out: data Color = Color {red, blue, ...}
11:04:02 <donri> KBme: well cabal-install does the equivalent of pip install --user, and that should "just work" with ghc etc. what cabal-dev gives you is local sandboxes.
11:04:06 <paolino> SLi, a functor is kind * -> *
11:04:08 <hpc> SLi: that has (Color :: * -> *) as a kind
11:04:10 <hpc> er
11:04:12 <KBme> ok
11:04:13 <hpc> SLi: that has (Color :: *) as a kind
11:04:20 <hpc> instead of (Color :: * -> *)
11:04:21 <KBme> great, thanks for the help and patience guys
11:04:34 <hpc> SLi: now let's do something really silly, and give Color a "phantom type" parameter
11:04:37 <conal> SLi: right. on the other hand, you could define a type of uniform triples, give it a Functor instance, and then define Color as a type-specialization.
11:04:44 <hpc> data Color a = Color {red, blue, green :: Double}
11:04:55 <hpc> now we can make it a Functor, and it even obeys the laws!
11:04:57 <timthelion> How do I get Right [1,2,3] from [Right 1, Right 2, Right 3] ?
11:04:59 <SLi> conal, hmm, interesting :)
11:05:03 * hackagebot RepLib 0.5.3.1 - Generic programming library with representation types  http://hackage.haskell.org/package/RepLib-0.5.3.1 (BrentYorgey)
11:05:05 * hackagebot unbound 0.4.1.1 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.4.1.1 (BrentYorgey)
11:05:08 <hpc> instance Functor Color where fmap f color = color
11:05:11 <donri> timthelion: sequence?
11:05:12 <conal> oops -- didn't mean to interrupt hpc's idea.
11:05:18 <hpc> it's not a useful instance though ;)
11:05:34 <hpc> you can also do what conal said
11:05:37 <timthelion> donri: ohh, easy :D
11:05:48 <hpc> data Color a = Color {red, blue, green :: a}
11:05:48 <donri> timthelion: may need the either package though
11:05:52 <paolino> @hoogle [Either a b] -> [a]
11:05:54 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
11:05:54 <lambdabot> Data.Either rights :: [Either a b] -> [b]
11:05:54 <lambdabot> Data.Graph.Inductive.Query.DFS topsort' :: Graph gr => gr a b -> [a]
11:06:01 <timthelion> donri: doesn't look like it.
11:06:03 <hpc> and get instance Functor Color where fmap = mapColor
11:06:17 <donri> timthelion: oh yea, you need Control.Monad.Instances
11:06:18 <hpc> that also lets you write more complex color types
11:06:22 <hpc> say you want HDR colors
11:06:31 <hpc> use (Color Word16)
11:06:34 <applicative> that might not be so bad if, e.g. different kinds of numbers can be used for Colors
11:06:36 <conal> with the polymorphic generalization of Color, you can derive Functor
11:06:45 <applicative> as hpc says...
11:06:46 <hpc> or sRGB: (Color Double)
11:07:03 <applicative> Color GLFloat
11:07:23 <SegFaultAX|work2> Why might I want to use the M_ variants in Control.Monad (foldM_, for example)?
11:07:43 <hpc> SegFaultAX|work2: if you don't care about the return values, just the "side effects"
11:07:43 <srhb> SegFaultAX|work2: When you don't care about the results.
11:07:52 <timthelion> SegFaultAX|work2: to produce side effects without return values...
11:08:00 <hpc> for IO, a good example would be, suppose you wanted to get 3 lines, and drop the results
11:08:00 <SegFaultAX|work2> Ah, I see.
11:08:00 <mcstar> M_ vs _
11:08:10 <hpc> sequence_ [getLine, getLine, getLine]
11:08:15 <hpc> :t sequence_ [getLine, getLine, getLine]
11:08:17 <lambdabot> IO ()
11:08:21 <hpc> :t sequence [getLine, getLine, getLine]
11:08:23 <lambdabot> IO [String]
11:08:48 <SegFaultAX|work2> Cool! It didn't click that it's only for side-effecting code.
11:08:49 <monochrom> fork 3 threads but lose their thread IDs
11:09:06 <SegFaultAX|work2> monochrom: Why would you want to do that?
11:09:16 <applicative> a better case is
11:09:19 <SLi> hpc, conal, ok. Thank you. I think I can get further with this advice :) I actually did think of something like data Color a = Color {red, green, blue :: a} but it did not occur to me that I could define the specific non-parameterizable type (if I want to use such) as a type synonym for Color Double.
11:09:23 <hpc> SegFaultAX|work2: if you have other ways of controlling their execution, say
11:09:37 <applicative> :t sequence_ [putChar 'a', putChar 'b']
11:09:39 <monochrom> because I care about running the threads but not their IDs
11:09:39 <lambdabot> IO ()
11:09:39 <SegFaultAX|work2> hpc: Ah, I see.
11:09:47 <conal> SLi: :)
11:09:47 <applicative> :t sequence [putChar 'a', putChar 'b']
11:09:49 <lambdabot> IO [()]
11:10:12 <mcstar> i think the question was wrongly phrased
11:10:20 <applicative> a list of () s is actual information
11:10:22 <mcstar> map vs. mapM_
11:10:29 <mcstar> foldl vs. foldM_
11:10:37 <hpc> a list of () is isomorphic to Nat, if you ignore bottoms
11:10:48 <applicative> right
11:10:52 <hpc> it's not real information though, in the case of sequence
11:10:53 <SegFaultAX|work2> Nat?
11:11:01 <srhb> Natural numbers
11:11:05 <hpc> because you can always do something like
11:11:12 <applicative> positive numbers?
11:11:32 <hpc> do {let result = length actions; sequence_ actions; ...}
11:11:32 <timthelion> HaskarrowPrecompile.lhs:1279:8: Parse error in pattern: value {valueDepends = resolvedDepends}
11:11:34 <geekosaur> hm?  [] is ispmorphic with Z, no?
11:11:36 <timthelion> ???
11:11:39 <geekosaur> isomorphic
11:11:47 <timthelion> Isn't that how one assigns a record?
11:11:54 <srhb> applicative: I can't tell if you're trying to start a war over whether to include zero or not <<
11:11:58 <ReinH> applicative: [0..] or [1..] depending on who you ask
11:12:05 <hpc> timthelion: you can also use {;} for layout control
11:12:15 <geekosaur> timthelion, in a pattern I think you need a constructor where you have 'value'
11:12:17 <applicative> () is zero
11:12:22 <ReinH> or 1
11:12:31 <timthelion> geekosaur: so what do I need to change to fix it?
11:12:40 <johnw> afternoon all
11:12:41 <donri> timthelion: "value" must be a constructor in a pattern
11:12:58 <applicative> srhb zero vs one only makes sense if there is are operations in view
11:13:11 <geekosaur> I am not familiar with the code you;re compiling so can't say off the top of my head.  more context?
11:13:31 <timthelion> aha, I see.  My error was actually elsewhere in the code :/
11:13:53 <mcstar> value needs to be a record constructor as donri said
11:13:59 <mcstar> but thats not a parse error
11:14:11 <donri> mcstar: it is a parse error in pattern context
11:14:36 <mcstar> oh, right, capital letter
11:14:58 <SegFaultAX|work2> How is a list of () isomorphic to natural numbers?
11:15:07 <scshunt> [] is 0
11:15:10 <scshunt> [()] is 1
11:15:14 <scshunt> and go from there
11:15:30 <scshunt> (():) is the successor function
11:15:31 <paolino> you can only count them
11:15:54 <scshunt> it satisfies the peano axioms
11:16:03 <donri> > length <$> sequence_ [Right 1,Right 2]
11:16:05 <lambdabot>   Couldn't match expected type `[a]' against inferred type `()'
11:16:26 <paolino> :t sequence_
11:16:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
11:16:33 <paolino> :t sequence
11:16:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:16:38 <donri> > length <$> sequence [Right 1,Right 2]
11:16:39 <lambdabot>   Right 2
11:16:43 <donri> > length <$> sequence [Right 1,Right 2,Left 3]
11:16:45 <lambdabot>   Left 3
11:17:22 <hpc> > length <$> sequence [Right 1,Right 2,Left 5007]
11:17:23 <lambdabot>   Left 5007
11:17:27 <applicative> scshunt: yes of course, it was nonsense what I said above though my point about operations seemed sound
11:17:42 <donri> > length <$> sequence [Right 1,Left "ohnoes",Right 2]
11:17:43 <lambdabot>   Left "ohnoes"
11:18:04 <hpc> > sequence_ [Right 1,Right 2,Left 5007]
11:18:05 <lambdabot>   Left 5007
11:19:04 <paolino> > length <$> sequence (Left "ohnoes": repeat (Right undefined))
11:19:05 <lambdabot>   Left "ohnoes"
11:20:03 * hackagebot split 0.2.0.0 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.2.0.0 (BrentYorgey)
11:20:53 <armlesshobo> I'm having a bit of trouble trying to implement the instance of Functor (Either e)
11:21:06 <armlesshobo> I'm assuming that it has a fixed type e for both Left and Right
11:21:21 <paolino> is there a time statistic on new package uploads?
11:22:00 <srhb> armlesshobo: So, where do you get stuck
11:22:08 <monochrom> your assumption is correct
11:22:09 <timthelion> armlesshobo: Why the assumption?
11:22:23 <armlesshobo> timthelion: it's part of the exercise
11:22:34 <monochrom> "Left ()" and "Right True" both have the same type: Either () Bool
11:22:40 <srhb> Not only that, you need the right kindedness.
11:23:16 <timthelion> srhb: monochrom I know, but that's different than what he said.  He said, "for both Left and Right"
11:23:27 <srhb> That's not different, really.
11:23:32 <srhb> It's redundant, though.
11:24:00 <monochrom> I allowed a miswording
11:24:25 <armlesshobo> well, wouldn't this be right? fmap f (Left a) = Left (f a)
11:24:38 <monochrom> no. don't do that
11:25:02 <armlesshobo> how come?
11:25:11 <monochrom> for the love of type-matching
11:25:33 <srhb> armlesshobo: Remember you're using one type parameter for the Functor, and it's not the left one (you already said it was instance Functor (Either e) ...
11:25:44 <srhb> Left*
11:26:13 <monochrom> if you want the same "e", you keep "Left a" and don't change it. the "a" determines the "e"
11:26:21 <armlesshobo> ahhhh
11:26:22 <armlesshobo> my bad
11:26:29 <armlesshobo> i mistyped, it should have been e
11:27:33 <applicative> armlesshobo: first define it as if you were defining instance Functor (Either Int) where ...   then replace Int with 'a'
11:27:55 <armlesshobo> applicative: hmm. i'll try this approach
11:28:11 <timthelion> srhb: monochrom: also, consider data NotEither e = NotLeft e | NotRight e ...  Here, armlesshobo's statment seems quite different.
11:28:40 <armlesshobo> applicative: ahh, this actually might be where I'm getting confused.
11:29:27 <meursault> does anyone know what the current best solution is for dynamic compilation and loading of functions? It would be really nice if something like the haskell-plugins package existed. Is pretty much the best option to slog through using the GHC api?
11:29:34 <Yiq> would it be easy to write a haskell program to make all html-tags lowercase?
11:29:35 <applicative> armlesshobo: so the types to consider would be Either Int Char , Either Int Int , Either Int () etc.   Functions can be anything () -> Char , Int -> Char
11:29:38 <timthelion> meursault: hint
11:29:46 <armlesshobo> applicative: first, if they say that I have to write and instance of Functor for Either e for a fixed type e, then I would need to write "instance Functor (Either e) where...", right?
11:29:49 <srhb> timthelion: That's true, but that wasn't it. I still agree it's more correct to talk about the Type when talking about type parameters in general.
11:29:57 <srhb> timthelion: But it wasn't WRONG wrong in this case :P
11:30:04 <srhb> anyway details.
11:30:19 <Cale> meursault: I agree with timthelion, hint is pretty easy.
11:30:20 <meursault> timthelion: is hint good for compilation also or only as an interpreter? I don't really understand the performance implications of hint (I want to run a function as a filter on a large piece of data)
11:30:33 <applicative> armlesshobo: yes. you will write that anyway, the functor instance is for Either e or Either a or whatever
11:30:35 <Cale> meursault: If there are .o files, it will load those
11:30:47 <Cale> meursault: (same as ghci)
11:31:07 <applicative> armlesshobo: the Functor instance is always for the many-parameter type, minus the last parameter, to put it crudely
11:31:12 <meursault> Cale: ah so if I do the compilation the same as ghci I can get similar performance
11:31:13 <timthelion> meursault: don't worry about the speed of interactive code as mapped over large lists...  Even ghci compiles(though without optimizaitons)
11:31:18 <Cale> meursault: yeah
11:31:38 <Cale> Compiling without optimisations makes a *huge* difference
11:31:44 <timthelion> meursault: it's not actually interpreted.  Just interactive :D
11:32:07 <meursault> oh interesting, can you compile with optimizations and then load it with hint?
11:32:16 <applicative> armlesshobo: but if you focus on the case Either Int, you notice that Left 3 is in all the the types Either Int Char , Either Int Int , Either Int ()
11:32:22 <Cale> meursault: yes, that's what I mentioned about the .o files
11:32:38 <applicative> armlesshobo: and that it's  your only hope
11:32:54 <meursault> Cale: ah now I understand so hint basically becomes a passthrough
11:33:17 <meursault> that's much much easier than trying to get the GHC api to do what I want
11:33:50 <armlesshobo> applicative: why is the last parameter limited to Char, Int, or ()?
11:34:09 <applicative> it isn't it's anything, I was just making a list to suggest all types
11:35:05 * hackagebot ottparse-pretty 0.1.2.2 - Pretty-printer for Ott parse trees  http://hackage.haskell.org/package/ottparse-pretty-0.1.2.2 (BrentYorgey)
11:36:17 <applicative> if you were making an imaginary instance Functor (Either Int) where fmap f (Left n)  = ? ; fmap f (Right x)   = ? then x could have any type and f can map x's to any type y
11:38:00 <S11001001> applicative: sure, though you'd have to take care that treatment of lefts don't violate laws
11:38:43 <S11001001> applicative: e.g. you couldn't use that int as a count of how many fmaps the left has gone through
11:39:22 <applicative> S11001001: yes that would be easy with such an instance. I was just suggesting that in thinking about the Either a instance one think of a as held fixed.
11:40:22 <applicative> in a Functor instance, the two places in Either a b figure in different ways, which I remember being a bit confusing at first
11:41:19 <armlesshobo> applicative: right. that's what I thought I was doing
11:41:49 <applicative> have you defined fmap yet?
11:42:05 <armlesshobo> so, if I did "instance Functor (Either e) where fmap f (Left e) = Left (f e); fmap f (Right e) = Right (f e)
11:42:09 <armlesshobo> "
11:42:13 <armlesshobo> so, I did*
11:42:20 <Cale> armlesshobo: incorrect
11:42:27 <applicative> right but  why should f apply to an e
11:42:30 <Cale> armlesshobo: (think about the type of fmap a little more)
11:42:47 <Cale> fmap :: (a -> b) -> (f a -> f b), so if f = Either e, we have
11:42:49 <applicative> suppose e were Int,  still f might be Char -> [()]
11:43:01 <Cale> fmap :: (a -> b) -> (Either e a -> Either e b)
11:43:04 <micahjohnston> is there a built-in function for wrapping a string to a width?
11:43:21 <micahjohnston> in Data.List or somewhere like that?
11:43:41 <Cale> micahjohnston: What does "wrapping a string to a width" mean?
11:43:48 <donri> micahjohnston: there's such functions for Text
11:44:10 <donri> micahjohnston: also look at packages: pretty, wl-pprint, wl-pprint-text
11:44:26 <donri> Cale: probably padding with spaces
11:44:29 <micahjohnston> Cale: as in, if you want to wrap "asdfasdf" to a four-character-wide line, you'd get "asdf\nasdf"
11:44:37 <donri> oh
11:44:57 <micahjohnston> but like only if it has spaces there
11:45:08 <micahjohnston> well, I guess it could get complicated for different rules of tokenizing
11:45:17 <donri> you can do that with wl-pprint[-text]
11:46:17 <Cale> Or if you don't care about word breaking,  unlines . map (take n) . takeWhile (not . null) . iterate (drop n)
11:46:17 <micahjohnston> donri: Text.PrettyPrint?
11:47:17 <micahjohnston> Cale: ooh, I like that
11:47:19 <donri> micahjohnston: yea
11:47:26 <Automorphism> I have just installed GHC from source. Now I have one question. According to "ghc-pkg list", the package "Cabal-1.14.0" is installed, however, there is no cabal in my $PATH. Is this cabal package the actual cabal I can use to download Haskell packages?
11:47:34 <armlesshobo> Cale: so, I'd have to return (Right (f e))?
11:47:40 <armlesshobo> for Left
11:47:41 <armlesshobo> ?
11:47:49 <donri> micahjohnston: fillSep $ map text $ words theString
11:47:50 <Cale> armlesshobo: no
11:48:11 <Cale> armlesshobo: You have a value Left x where x :: e and you have a function (a -> b)
11:48:11 <donri> micahjohnston: also see text-icu if you want something smarter than "words" for word-splitting
11:48:12 <Okasu> hello
11:48:13 <armlesshobo> because I'm looking at the definition data Either a b = Left a | Right b
11:48:17 <luite> Automorphism: that package is the Cabal library, cabal-install is the name of the package with the installer
11:48:24 <Cale> armlesshobo: you can't apply the function because you don't have a value of type a
11:48:33 <micahjohnston> donri: yeah, I'm compiling a language to another one, so I probably do
11:48:38 <armlesshobo> Cale: uuughhhhh
11:48:45 <armlesshobo> Cale: i see
11:48:46 <Automorphism> luite: Oh. So I have to download cabal-install anyway... Thank you!\
11:48:55 <donri> micahjohnston: spoken or programming language?
11:48:56 <Cale> armlesshobo: but it's all good, you need to produce a value of type Either e b
11:49:14 <micahjohnston> donri: programming language
11:49:16 <Cale> armlesshobo: and so you can just produce Left x
11:49:45 <Okasu> i hame "data Unpacker = forall a. Eq a => AnyUnpacker (LispVal -> ThrowsError a)" type and "unpackEquals :: LispVal -> LispVal -> Unpacker -> ThrowsError Bool" function type
11:49:45 <donri> micahjohnston: then you should probably tokenize or parse the language (packages: alex, happy, parsec, attoparsec)
11:49:52 <micahjohnston> donri: yeah, I use Parsec
11:49:54 <donri> micahjohnston: text-icu is for spoken languages
11:49:57 <Okasu> because of that i've got "Could not deduce (a ~ m0 Bool)" error
11:50:02 <applicative> Automorphism, you probably have cabal (small c) but need to add ~/.cabal/bin
11:50:06 <Okasu> can you tell me how to fix it?
11:50:23 <donri> micahjohnston: what languages are you translating between btw
11:50:23 <armlesshobo> Cale: I don't follow how that is so :(
11:50:30 <armlesshobo> Cale: it doesn't seem to be clicking lol
11:50:34 <micahjohnston> donri: so, for instance, the target language I'm working on right now is JS, and I have a list of variables to declare, so I say intercalate ", " variables
11:50:40 <Cale> armlesshobo: did you see what I said earlier about the type of fmap?
11:50:41 <micahjohnston> donri: my own reactive language to JS
11:50:52 <micahjohnston> planning to compile to C and some other targets eventually
11:50:59 <donri> micahjohnston: you can use packages like jmacro or language-javascript to generate JS
11:51:00 <Cale> armlesshobo: In general fmap :: (Functor f) => (a -> b) -> f a -> f b
11:51:05 <micahjohnston> donri: oh neat
11:51:06 <applicative> Automorphism: if you have the Haskell Platform, you have the cabal executable, its part of the definition
11:51:06 <Cale> armlesshobo: and here, f = Either e
11:51:17 <donri> micahjohnston: language-c for C
11:51:19 <micahjohnston> donri: thanks, that will probably be a huge help
11:51:26 <Cale> armlesshobo: so we're trying to write  fmap :: (a -> b) -> Either e a -> Either e b
11:51:51 <Cale> armlesshobo: right?
11:52:52 <paolino> it's Either a a -> Either b b if the types are the same
11:53:01 <Cale> ?
11:53:14 <Cale> No, that can't be done with Functor
11:53:27 <micahjohnston> cabal list language- gives me a billion things
11:53:32 <micahjohnston> how did I not know about this? :D
11:53:32 <donri> micahjohnston: many such language-* packages listed here http://hackage.haskell.org/packages/archive/pkg-list.html#cat:language
11:53:39 <donri> yea
11:53:39 <donri> :)
11:53:48 <Cale> Functor only lets you express type constructors which are functors in their last type parameter alone
11:53:49 <paolino> Cale that is another point, but I understood that was the question
11:53:58 <Nereid> paolino: the functor here is Either e, for a fixed type e.
11:54:24 <donri> micahjohnston: for haskell itself you want haskell-src-exts, btw
11:54:43 <micahjohnston> all right, thanks
11:54:45 <paolino> well, I let armlesshobo rephrase his question, maybe I got it wrong
11:54:59 <applicative> armlesshobo: If you defined Or a = L a | R a , then youd write instance Functor Or where fmap f (L a) = L (f a), etc
11:55:54 <Nereid> and Or a ~ (Bool,a)
11:56:03 <applicative> fmap f  (R a) = R (f a)  -- the result in either case is an Or b if f :: a -> b
11:56:09 <Nereid> for some definition of ~
11:57:36 <Automorphism> applicative: I am trying to install the Haskell Platform, but it says I need GHC 7.4.1 specifically, and I have GHC 7.4.2 :S
11:58:29 <applicative> yes, releases of the platform are tied to the ghc.  i was hoping you had done it all through your package manager.  There was another release of that platform.
11:58:34 <Cale> Automorphism: yeah, if you already have GHC working, my recommendation is just to get cabal-install installed and then install other packages as user as you need them
11:58:44 <Cale> In fact, I do that anyway
12:00:06 * hackagebot TypeCompose 0.9.3 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.9.3 (ConalElliott)
12:00:19 <applicative> Automorphism: if you download the tarball it has a regular make file in it, if I remember.
12:01:09 <dgpratt> when cabal says "The following packages are likely to be broken by the reinstalls..." what is the advice for proceeding? don't?
12:02:15 <Automorphism> Wow, thanks, Cale, applicative.
12:02:34 <jfischoff> dgpratt: what's the context (most likely the answer is just do the reinstall)
12:02:50 <armlesshobo> Cale: right
12:02:59 <Automorphism> Apparently, the only problem was that the initialization script that comes with cabal-install's source had to be "chmod +x"ed.
12:03:09 <dgpratt> jfischoff: the context is "cabal install yesod-platform"
12:03:14 <johnw> is the author of Control.Monad.Free here?
12:03:19 <armlesshobo> Cale: but I thought it would be like Either e a = Left e | Right a
12:03:34 <armlesshobo> That's how I view Either e a or Either e b
12:05:49 <dgpratt> is there a way to back up the current state of GHC packages before doing a "cabal install" and then restore it if things go wrong?
12:06:56 <Cale> armlesshobo: that is right...
12:07:09 <JoeyA> dgpratt: You might be able to back up your ~/.ghc/x86_64-linux-7.4.2  (or whatever it's called on your system)
12:07:28 <JoeyA> But I've never tried that.
12:07:38 <Cale> armlesshobo: So in the case where it's a Left x :: Either e a, so that x :: e, we want to produce Left x :: Either e b as the result
12:08:24 <JoeyA> dgpratt: Of course, you can cabal install --dry-run, but that won't let you play around with the installed packages.
12:11:22 <armlesshobo> Cale: but where would the function be applied?
12:11:41 <armlesshobo> Cale: would you only apply it to the Right?
12:11:55 <armlesshobo> Cale: and Left would be the identity?
12:12:04 <Cale> armlesshobo: that's correct
12:12:16 <Cale> armlesshobo: You don't use the function in the Left case, because you literally can't.
12:12:25 <armlesshobo> Cale: omfg.....
12:12:29 <Cale> You don't have a value of type a to apply the function (a -> b) to
12:12:31 <armlesshobo> Cale: thank you
12:12:35 <Cale> so you can't apply it
12:12:37 <armlesshobo> Cale: thank you thank you thank you thank you
12:12:39 <armlesshobo> lol
12:12:59 <applicative> Cale proves to  be the master tutor once again
12:13:01 <armlesshobo> ugh...i get it now
12:13:01 <armlesshobo> lol
12:14:35 <zhulikas> :)
12:14:43 * zhulikas gives a high five to armlesshobo 
12:14:46 <zhulikas> oh, wait.
12:15:12 <byorgey> awkward
12:15:54 <applicative> awkward?
12:16:10 <Cale> applicative: "armless hobo"
12:16:32 <applicative> hah, took a sec, I was so accustomed to the nick
12:17:49 <thetallguy> change your name to applicativehobo, then we can give you a chest bump
12:17:51 * applicative searches for another means of celebrating a-h's step
12:20:06 <applicative> armlesshobo: now you can let it become second nature, declare it to be obvious on reflection and start giving smug supercilious advice on #haskell ...
12:20:17 <applicative> or not
12:22:40 <applicative> is it possible to change the defaulting in ghci it seems not to  matter if the imported module has default (Int,Float) or whatever,
12:25:06 * hackagebot postgresql-libpq 0.8.2.1 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.8.2.1 (LeonSmith)
12:25:54 <Shapeshifter> I'm confused. I have a file F3cliWordlist.hs which contains only module F3cli.Wordlist ( wordlist ) where wordlist = [ "eat", ...] with a bunch of words in it. It compiles fine using ghc F3cliWordlist.hs. I have another file where I want to import F3cli.Wordlist but if I compile that one, I get "Could not find module `F3cli.Wordlist'", Locations searched: F3cli/Wordlist.hs F3cli/Wordlist.lhs"...
12:26:26 <geekosaur> Shapeshifter, yes, that's how the module name to filenam emapping works
12:26:43 <geekosaur> it's not magic, module Foo.Bar is Foo/Bar.hs
12:26:45 <Shapeshifter> geekosaur: so I need to put my module in a subdirectory called "F3cli"?
12:26:49 <geekosaur> yes
12:26:53 <Shapeshifter> okay, thanks
12:28:51 <applicative> what, Accelerate can now be used with agda ?!
12:30:00 <mcstar> fecli?
12:42:29 <Nereid> > 0.032 * 25.4
12:42:31 <lambdabot>   0.8128
12:54:27 <danbst> Hello cafe. Is there C/C++ compiler written in Haskell? Wonder if gcc can be replaced to build Linux
12:54:58 <geekosaur> nope.  have at it!  but, it's harder than you might think
12:56:06 <danbst> geekosaur, I'm just wondering to what degree Haskell can integrate into Linux environment
12:56:13 * Clint squints.
12:56:28 <proq> danbst: it can.  llvm makes a good replacement.  not written in haskell though
12:57:16 <danbst> proq, oh, good
12:59:30 <geekosaur> does either clang or llvm-gcc work with the kernel yet?  used to be it was really dependent on gcc internals, and even llvm-gcc seems to have some slight differences
13:00:14 <proq> danbst: if I understand your question though, maybe what you are looking for is http://hackage.haskell.org/package/greencard
13:00:45 <proq> or possibly http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
13:08:25 <aib> @pl (\x -> 2 * x == x)
13:08:26 <lambdabot> (==) =<< (2 *)
13:08:35 <aib> ouch
13:09:07 <johnw> that's identical in form to something we were playing with yesterday
13:09:17 <johnw> (+1) >>= (+)
13:09:36 <c_wraith> Strangely, I find it much easier to read in that formulation
13:09:50 <c_wraith> I can see the extra argument flowing in more clearly that way
13:11:06 <aib> isFixPoint f p = f p == p
13:12:41 <johnw> > (+a) >>= (+) $ b
13:12:41 <lambdabot>   b + a + b
13:12:49 <johnw> > (+) <*> (+a) $ b
13:12:50 <lambdabot>   b + (b + a)
13:13:40 <johnw> > (==) =<< (a *) $ b
13:13:41 <lambdabot>   False
13:13:47 <johnw> > (==) <*> (a *) $ b
13:13:49 <lambdabot>   False
13:14:03 <johnw> huh, didn't realize =<< could be equivalent to <*> in the functor case
13:14:05 <zhulikas> that is messed up
13:14:10 <zhulikas> can't you just write normal expressions
13:14:52 <johnw> well, sometimes point-free gets a little obfuscated
13:15:07 <johnw> I was more trying to see the relationship between Applicative and Monad
13:17:21 <johnw> has anyone succeeded a building ThreadScope on Mac?
13:17:27 <johnw> I'm getting a missing symbol: gdk_x11_drawable_get_xid
13:17:54 <johnw> ah, found my answer
13:18:00 <johnw> I need -have-quartz-gtk
13:28:44 <donri> do people use those newtypes for e.g. monoid (Dual, Endo, All, Any, Sum...) or are they mostly for show?
13:29:01 <edwardk> donri: check lens. i use them a _lot_
13:29:05 <johnw> All and Any are pretty excellent
13:29:09 <donri> aha
13:29:11 <johnw> as are Last and First
13:29:30 <edwardk> donri: in particular Control.Lens.Fold references all of them at least once
13:29:37 <johnw> they sort of give you different "flavors" of the base Monoid
13:30:20 <donri> but when are they useful and you can't use the all/any functions?
13:30:46 <johnw> any and all work on lists
13:31:05 <johnw> Any and All work on any mappable monoid
13:31:26 <johnw> you could use Any to ask if your binary tree has any nodes greater than X in value
13:31:39 <johnw> to use "any" for that, you'd have to foldMap and convert it to a list first, which would be rather sub-optimal
13:31:57 <donri> aha
13:32:28 <johnw> an exercise here would be to implement any in terms of Any :)
13:32:59 <johnw> and the revers
13:35:39 <donri> johnw: isn't it basically, any f = getAny . mconcat . map (Any . f)
13:36:16 <johnw> @src any
13:36:16 <lambdabot> any p =  or . map p
13:36:20 <johnw> @src or
13:36:21 <lambdabot> or    =  foldr (||) False
13:37:07 <shurikas> shouldn't it search until finds first occurence?
13:37:33 <shurikas> > any (==1) [2,1,undefined]
13:37:35 <lambdabot>   True
13:37:38 <shurikas> ok, it does
13:37:47 <shurikas> smart Haskell
13:37:49 * shurikas pets Haskell
13:37:52 <johnw> > getAny $ foldr (mappend . Any) (Any False) [False, True, False]
13:37:54 <lambdabot>   True
13:37:57 <donri> @src (||)
13:37:57 <lambdabot> True  || _ =  True
13:37:57 <lambdabot> False || x =  x
13:38:10 <donri> notice the _
13:38:22 <donri> although without a bang pattern i don't think it would matter?
13:38:35 <johnw> > getAny . mconcat . map Any $ [False, True, False]
13:38:37 <lambdabot>   True
13:38:49 <zhulikas> :t Any
13:38:50 <lambdabot> Bool -> Any
13:38:51 <johnw> donri: I think your solution is right, it's just restricted to lists
13:38:56 <zhulikas> :t getAny
13:38:58 <lambdabot> Any -> Bool
13:38:59 <johnw> donri: doing it as a fold removes that restriction
13:39:02 <donri> johnw: you said any in terms of Any
13:39:31 <johnw> yes
13:39:38 <johnw> I don't see anything wrong with our solution
13:39:58 <johnw> any required a list before, so it's ok if it still does
13:41:40 <donri> exactly :)
13:41:47 <johnw> s/our/your
13:42:32 <donri> i keep forgetting about "or"/"and" and do things like "any id" :p
13:43:05 <edwardk> > getAny . foldMap Any $ [False, True, False]
13:43:05 <johnw> yeah, well, I did "any (==True)" the other ady
13:43:06 <lambdabot>   Not in scope: `foldMap'
13:43:09 <johnw> which is even worse
13:43:13 <edwardk> > getAny . Data.Foldable.foldMap Any $ [False, True, False]
13:43:15 <lambdabot>   True
13:43:21 <edwardk> > getAny . Data.Foldable.foldMap Any $ (Just True)
13:43:24 <lambdabot>   True
13:43:45 <edwardk> using Control.Newtype: ala Any foldMap [False, True, False]
13:45:19 <johnw> if I import Control.Arrow, and then turn any "f" into "arr f", how do I execute it?
13:45:40 <johnw> the type is just "Arrow"
13:45:41 <Clint> >>>?
13:45:49 <johnw> that just composes, doesn't it?
13:45:56 <Shapeshifter> How can I intercalate a string with two alternating strings? Basically, I would want "abcdefghijkl" to become "abc def\nghi jkl\n" and so on.
13:46:01 <johnw> I'm expecting some kind of runArrow function
13:47:11 <edwardk> johnw: the way you run an arrow is particular to each tye of arrow
13:47:14 <edwardk> er type of arrow
13:47:20 <edwardk> its like how there isn't one 'runMonad' function
13:47:21 <johnw> so there's now way to run the generic Arrow?
13:47:31 <edwardk> no, just like there isn't a way to run an generic Monad ;)
13:47:37 <edwardk> you can pick k = (->)
13:47:39 <johnw> ok, makes sense
13:47:44 <edwardk> and then just treat it like a function
13:47:46 <johnw> I'll make a DumbArrow
13:47:52 <edwardk> just like how you can pick m = Identity
13:47:54 <edwardk> just use (->)
13:47:59 <edwardk> (->) is a nice dumbarrow ;)
13:48:38 <johnw> you mean, newtype DumbArrow = (->)?
13:48:40 <edwardk> if you know nothing about it other than its a valid arrow for any choice of k, you can always choose k = (->) and just apply it to something
13:48:44 <edwardk> no newtype needed
13:48:47 <dgpratt> cabal is testing my patience!
13:48:48 <edwardk> just use it as a function ;)
13:48:56 <johnw> oh!
13:48:58 <johnw> cool!
13:49:01 <edwardk> > Control.Arrow.arr (+1) 2
13:49:02 <lambdabot>   3
13:49:02 <johnw> that's just what I was looking for
13:49:04 <dgpratt> feel like I'm going around in circles
13:49:06 <johnw> the builtin dumb arrow :)
13:49:14 <edwardk> yep
13:49:25 <johnw> dgpratt: in this channel, I bet you're going around in venn diagrams
13:49:40 <dgpratt> johnw: :)
13:50:07 <rosie> why is the Ix module called Ix?
13:50:19 <Saizan> Index
13:50:27 <Cale> johnw: http://arxiv.org/pdf/1207.6452v1.pdf
13:50:29 <rosie> thanks!
13:50:38 <DT``> why isn't it just called Index?
13:50:44 <DT``> hysterical raisins?
13:50:46 <shachaf> Ix is shorter.
13:50:50 <shachaf> Just be thankful it's not called I.
13:50:53 <rosie> haha
13:51:04 <dgpratt> hmm...where's my hpaste?
13:51:09 <dgpratt> http://hpaste.org/73486
13:51:12 <aib> (\x -> x - 1)
13:51:18 <aib> @pl (\x -> x - 1)
13:51:18 <lambdabot> subtract 1
13:51:26 <dgpratt> that's one half of the circle I've been tracing
13:51:26 <c_wraith> heh.  that's an amusing special case
13:51:42 <NoICE> hi guys :) simple question (with possibly many answers): I'm currently creating haskell types for XSD document, which has multiple "records" which inherits some attributes (via attributeGroup), I don't know what's cleanest: 1) include all these inherited attributes in every haskell record which should have them, 2) nest them under something 3) is there other way?
13:52:27 <dgpratt> wasn't yesod-platform supposed to solve these cabal headaches?
13:52:34 <NoICE> ( 2) involves another record for every derived record )
13:52:50 <zhulikas> @src substract
13:52:51 <lambdabot> Source not found. You untyped fool!
13:53:31 <edwardk> @tell acowley adding a simple tape based reverse mode to 'ad'
13:53:32 <lambdabot> Consider it noted.
13:53:33 <dcoutts_> dgpratt: having broken packages isn't in itself a problem, only if you need them
13:53:40 <Cale> NoICE: I say factor your types as best as possible. So if there is a meaningful collection of fields, define a new datatype for that bunch, and make it a field of things that need it.
13:53:43 <DT``> @src subtract
13:53:44 <lambdabot> subtract x y = y - x
13:54:13 <zhulikas> > let substract = flip (-) in substract 1 3
13:54:15 <lambdabot>   2
13:54:27 <dcoutts_> dgpratt: the trick is to ask cabal to install all the things you need simultaneously, don't install things sequentially
13:54:28 <dgpratt> dcoutts_: well, the default Yesod template does use the broken package AFAICT
13:54:36 * zhulikas googled how to spell illiterate
13:54:49 <dgpratt> dcoutts_: that thought had just occured to me, actually
13:55:03 <dgpratt> dcoutts_: trying it as we speak
13:55:18 <DT``> zhulikas, I write substract everytime too.
13:55:29 <dcoutts_> dgpratt: it's really the only way to manage things in really large package collections, since almost anything else will end up with breaking deps of other things
13:55:56 <zhulikas> at least I'm not the only one
13:56:01 <dgpratt> dcoutts_: yesod-platform seems to include everything including the kitchen sink, not sure why some stuff didn't get installed/reinstalled
13:56:22 <dcoutts_> dgpratt: yes, if yesod-platform depends on these packages then it's odd
13:57:05 <dgpratt> dcoutts_: maybe I had prior versions of some packages and that threw it off?
13:57:08 <NoICE> Cale: well, some of these attributeGroups contain one value, other contains like 12 of them.. I would like to keep one style across all of them, e.g. nest them (to keep these DRY) but it seems overkill for the simple ones.. maybe I could use something like Phone = (Extended Phone SomethingInerited) and "extend" all of those this way?
13:57:30 <dgpratt> dcoutts_: obviously what cabal does is magic to me
13:57:51 <dcoutts_> dgpratt: hard to guess, but if you do: "cabal install a; cabal install b"  rather than "cabal install a  b" then you'll almost certainly break things
13:58:05 <dcoutts_> dgpratt: cabal-install-0.14 will warn you about that
13:59:05 <dgpratt> dcoutts_: what happens when 'a' is installed at an earlier point (because something else needed it)?
13:59:57 <dcoutts_> dgpratt: and then you do what?
14:00:01 <zzing_> So I am making a forth, and thought of using Data.Sequence for a stack and there was a data structure listed here for random access that would be able to simulate a sort of ram but I cannot remember what it is. Can anyone suggest a near constant time random access data structure that supports updates? I am trying to keep things as pure as I can, and with the speed of machines I am not too worried about performance as long as it isn't too bad
14:00:40 <dgpratt> dcoutts_: well, followed at a later point by "cabal install b", I guess
14:01:21 <dcoutts_> dgpratt: then it's quite possible you can break things, and this is what cabal-install-0.14 will tell you about (and if you ask it to it can try hard to avoid)
14:01:35 <dcoutts_> dgpratt: unless b depends on a obviously
14:02:38 <NoICE> Cale: https://gist.github.com/3419381 first file is the XSD, second is my type declarations for it so far, take a look at data CommAddress (line 146)
14:02:56 <dgpratt> dcoutts_: well, still a touch confused on your point, but I think I have something working anyway, thanks for your assistance
14:03:10 <NoICE> Cale: (if you want of course :) )
14:07:04 <dcoutts_> dgpratt: the reason is, suppose 'a' and 'b' depend on some common package 'c'. If 'b' needs 'c' to be built against a different version of some other package then 'c' will need to be rebuilt. That will break 'a', unless 'a' is itself also rebuilt.
14:08:12 <ParahSailin> ghc doesnt automatically make multiple os threads, right?
14:08:51 <parcs`> ghc automatically makes and manages multiple os threads if you use the threaded runtime
14:08:54 <donri> ParahSailin: you need -threaded
14:10:13 <wi`> hello, i have written a parser for propositional logic formulae, but it's going into an infinite loop, so i was wondering if someone here would be willing to look at the code (ill post it on hpaste.org)
14:10:30 <wi`> (i used parsec)
14:11:47 <adnam> wi`: better chance to get someone to look if you just post it i think :]
14:12:09 <johnw> mm_freak_: ping
14:13:37 <wi`> its on hpaste.org now
14:14:42 <rosie> what's a good way to print an array without commas?
14:14:56 <sclv> wi
14:15:00 <donri> mapM_ print
14:15:00 <sclv> wi`: paste the link
14:15:21 <NoICE> I will simplify my question a bit: is there a nice way to declare records which have a lot of common attributes? or some other way around?
14:15:28 <wi`> http://hpaste.org/73487
14:15:46 <johnw> NoICE: do you want something similar to derivation in OO languages?
14:16:30 <wi`> btw, i used the conjunction parser in the parsel function, but it still goes into an infinite loop when you replace it with the 'proposition' parser
14:16:41 <sclv> wi`: instead of that between stuff, which i'm pretty sure is wrong, i'm pretty sure you can just use a parens parser.
14:17:02 <sclv> oh wait, parens might only come from a Language def
14:17:08 <sclv> in any case, the between stuff is wrong.
14:17:34 <NoICE> johnw: I'm handling with XSD which does something like oop inheritance (in a ugly way) and I need to represent those data back and forth, the xsd and my prototype code is here https://gist.github.com/3419381
14:17:49 <NoICE> I'm dealing*
14:17:51 <sclv> wait, maybe not, sorry, i'm being slow
14:18:44 <eacameron> What does this do? `data Weird a = Weird (Weird a)`? Is it infinitely recursive?
14:18:49 <mm_freak_> johnw: pong
14:18:53 <johnw> NoICE: I'm not clear on what things you're wanting to reduce
14:19:02 <johnw> mm_freak_: hey, I referenced you here: https://github.com/yesodweb/Shelly.hs/issues/21#issuecomment-7904514
14:19:22 <johnw> mm_freak_: was wondering if you'd be willing to chime in on the payoffs for making people learn arrows :)
14:19:51 <NoICE> johnw: take a look at CommAddress and its Phone, Email, Uri.. they all share "GeneralChar" attributeGroup, which I nested under some field for now (and they have prefixes because of name collision)
14:20:06 <NoICE> (CommAddresses *)
14:20:06 <sclv> wi`: another thought. you probably want many1 alphanum rather than many alphanum
14:20:16 <sclv> otherwise you'll just parse empty identifiers over and over
14:20:20 <sclv> hence infinite loop
14:20:28 <johnw> NoICE: Ah, I see
14:20:48 <wi`> no, i dont think thats true
14:20:53 <johnw> NoICE: there are some GHC extensions which might eliminate your name collision problem
14:21:04 <NoICE> johnw: and if you take a look at ReplyPhoneChar, it's also shared between many records :( not in the code for now, but in XSD)
14:21:08 <johnw> NoICE: you could also use Template Haskell to eliminate boilerplate
14:21:25 <johnw> NoICE: but otherwise, I'm not aware (yet) of an excellent solution to this sort of problem
14:21:28 <wi`> sclv: i think the variables have to be at least 1 char long, because of the lower parser
14:21:35 <NoICE> johnw: I'm kinda newbie in haskell, so I didn't touch TH yet :)
14:21:44 <johnw> think of TH like macros on steriods
14:21:58 <sclv> wi`
14:22:05 <NoICE> yup, I've heard something sort of that :)
14:22:06 <sclv> wi`: ah, gotcha, missed that.
14:22:06 <johnw> you can "inject" arbitrary code based on a pattern coded in Haskell
14:22:19 <wi`> and could be longer due to the many parser, possibly returning an empty list
14:22:30 <n00b6502>  maybe i should give TH a go
14:22:33 <n00b6502> i love macros
14:22:43 <johnw> so things like "Make me a disambiguated type that has these sub-types in it" would be a trivial job for TH
14:22:52 <NoICE> johnw: I'm also using Aeson in this project and it uses TH, it's nice that I can just say $(deriveJSON ''Something) :)
14:23:01 <johnw> yes, exactly
14:23:42 <Veinor> i feel dirty when I use an IORef
14:23:51 <johnw> Veinor: that's a good thing :)
14:23:52 <n00b6502> what can   TH do versus  c #defines,C++ templates, lisp-macros
14:24:15 <johnw> n00b6502: C++ templates are more equivalent to type constructors
14:24:25 <johnw> n00b6502: TH is a little more like lisp-macros
14:24:26 <Veinor> i'd like to not use one, but i'm like 99% sure that iorefs are the only way to deal with state when using OpeNGL
14:24:34 <NoICE> johnw: I thought about completely different solution, like using some other type to "extend" the base record (to nest them from the beginning), like data Extended = WithGenericChar Phone GenericChar)  and then "data Phone = Phone WithExtended a" or something like that?
14:24:39 <Veinor> because all the callbacks happen in IO()
14:24:40 <n00b6502> i saw haskells type inference kindd of making the whole language like c++ templates improved
14:25:16 <johnw> NoICE: ah, kind of like using value wrappers
14:25:26 <johnw> NoICE: that will work too, your pattern matching will just get a little deep in places
14:25:28 <n00b6502> so TH could implement data schemas perhaps (and generate load/save & a haskell view)
14:25:36 <johnw> NoICE: but it could be a better way to go
14:26:11 <johnw> n00b6502: I'm not sure if TH has access to I/O at compile time.  does anyone else know?
14:26:47 <jfischoff> johnw: yes
14:26:47 <sclv> wl`: actually, i give up. this is a terrible parser. you have lots of nested tries so everything goes to heck.
14:26:54 <thoughtpolice> johnw: it does
14:26:58 <sclv> my recommendation is to use BuildExpressionParser and get parsec to do it for you.
14:27:22 <johnw> n00b6502: well, Haskell adds type classes to the mix, which C++ calls "concepts", that make generic programming much more useful, as well as give you proper compile-time type checking when you misuse a type
14:27:29 <NoICE> johnw: hmm… yup, it will be deep sometimes, and some of the values are like Maybe and some elements with those types have "0..infinity" list-like-behavior.. but at least the type system will cover my back :D
14:27:39 <wi`> ok, i will try that, thanks sclv ;)
14:28:08 <johnw> in C++ if you instantiate a template with the wrong type, God help you
14:28:14 <sclv> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Expr.html#v:buildExpressionParser
14:28:16 <n00b6502> what i had in mind would need compile time I/O .. i more mean the kind of system i'd do with xmacros in C .. e.g declaring data fields with anotation. here's a record-member... heres how it shows up in the UI; here's the default value;heres how it looks in the file
14:28:29 <NoICE> johnw: the sad thing is that I just need to do this: convert incoming JSON to XML, send this XML over http and return back JSON with values from the response
14:28:30 <n00b6502> here's how it looks in C -struct
14:28:51 <johnw> NoICE: aren't there already JSON and XML libraries that will do that for you?
14:29:04 <n00b6502> typeclasses look good , more useful than inheritance
14:29:22 <johnw> type classes are a very different thing from inheritance
14:29:42 <Dodek> n00b6502: typeclasses are more like interfaces than inheritance.
14:29:43 <timthelion> Is there a good reason why ghc doesn't let you place import lines anywhere in the code?
14:30:03 <timthelion> that is, you cannot do module Main where \n foo = "hi" \n import Bar
14:30:14 <johnw> inheritance establishes an "isa" relationship between two concrete types; interfaces describe the capabilities of a family of concrete types that are possibly unrelated in any other way
14:30:24 <NoICE> johnw: I'm handling json via aeson, that works well.. but to convert it from json to xml and back (and maybe clean the response and standardise the api somewha) I need to do the conversion manually.. I took a look at HaXml, but it is kinda overkill too (and it can't parse this ugly xsd as it doesn't support xsd:all and xsd:attributeGroup)
14:30:27 <n00b6502> keeps the whole module namespace consisten
14:30:46 <n00b6502> ability to 'import' anywhere makes a mess in c++
14:30:48 <johnw> timthelion: I ran into that yesterday too
14:30:55 <n00b6502> hell for IDE
14:31:04 <johnw> timthelion: I think it has to do with name lookup, and the fact that functions can appear out-of-order in a haskell module
14:31:07 <timthelion> n00b6502: but they could(and should) make the placement of the import irelivant)
14:31:35 <johnw> otherwise, the compiler would have to hunt for all imports before starting to parse the functions in the file
14:31:45 <timthelion> johnw: the compiler is multipass anyways.
14:31:52 <jtza8> timthelion: It's just plain messy to do that.
14:32:26 <johnw> it's multipass, but I bet you it decides what is a function and what isn't just based on the names in the first pass
14:32:50 <johnw> otherwise, it would have to tokenize, and only get around to parsing in the second pass, since module imports can really change the meanings of things
14:32:57 <timthelion> well I want to do "import qualified Foo\n foo = Foo.foo \n import qualified Bar\n bar = Bar.bar ect
14:32:58 <johnw> is Foo a type, or a type class, for instance
14:33:23 <aib> > filter (id)
14:33:25 <lambdabot>   Overlapping instances for GHC.Show.Show
14:33:25 <lambdabot>                              ([GHC....
14:33:32 <aib> @pl filter (id)
14:33:32 <lambdabot> filter id
14:33:37 <aib> hmm
14:34:24 <timthelion> and is there an import Something.*?
14:34:29 <paolino> timthelion, you want a where clause for import
14:34:45 <timthelion> paolino: I can import after a where?
14:34:57 <johnw> NoICE: I'm rather partial to HXT myself
14:35:08 <timthelion> paolino: like foo = Foo.foo where import Foo?
14:35:11 <MostAwesomeDude> aib: Maybe the type will help?
14:35:12 <johnw> NoICE: if only because it's use of arrows is what led me to grok their usefulness
14:35:15 <MostAwesomeDude> :t filter id
14:35:16 <lambdabot> [Bool] -> [Bool]
14:35:31 <paolino> I mean you'd want to specify things inherent to a specific  import
14:35:52 <timthelion> paolino: I don't follow.
14:36:08 <johnw> n00b6502: C++ can allow #include anywhere because order matters in the lookup of names
14:36:16 <aib> MostAwesomeDude: I was wondering if there was another name for (filter id), something specific for [Bool]s. I don't know why I thought such a thing might've existed
14:36:32 <paolino> it's not really placing an import anywhere import qualified Bar\n bar = Bar.bar
14:36:40 <johnw> aib: do you mean, and?
14:36:42 <MostAwesomeDude> aib: Well, I mean, it'll just take a list of Trues and Falses and give you a list of Trues.
14:37:03 <johnw> and will take a list of Bools and return a True if all are True
14:37:11 <MostAwesomeDude> :t and
14:37:12 <lambdabot> [Bool] -> Bool
14:37:17 <aib> something more along the lines of (length . filter id), so "countTrues" maybe.. though what I typed looked just as fine in the end :)
14:37:24 <paolino> timthelion, just rename things
14:37:38 <timthelion> paolino: ???????
14:37:44 <timthelion> paolino: just rename what?
14:37:57 <paolino> bar = Bar.bar
14:38:19 <paolino> anyway you cannot
14:38:21 <NoICE> johnw: I didn't use arrows yet
14:38:29 <timthelion> paolino: what I'm trying to do, is one function per module...
14:39:16 <johnw> @pl foldl (\acc x -> if x then acc + 1 else acc) 0 [True, True]
14:39:17 <lambdabot> foldl (flip =<< flip if' . (1 +)) 0 [True, True]
14:39:18 <NoICE> johnw: it's hard to write clean code (and types) in haskell when I have to use this ugly XSD, produced by some weird standard.. it just looks like Java class hierarchy dump to xsd :D
14:39:20 <johnw> what is if'?
14:39:40 <paolino> functional if
14:39:47 <johnw> where is it defined?
14:39:53 <timthelion> johnw: if' :: Bool -> a -> a-> a
14:40:00 <johnw> :i if'
14:40:13 <jtza8> timthelion: how about "import Foo (foo)"?
14:40:19 <paolino> @hoogle Bool -> a -> a -> a
14:40:21 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
14:40:21 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
14:40:21 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
14:40:31 <MostAwesomeDude> @hoogle if'
14:40:31 <lambdabot> No results found
14:40:33 <aib> johnw: MostAwesomeDude: I just check here (and hoogle if I have no more than a couple of type signatures) to see if something I've come up with can be simplified.. I'm known to do things like fold (*) 1 or (last . take n)
14:40:37 <timthelion> jtza8: that's nice. but I was using a very simplified example.  I want to do more than just rename...
14:40:54 <MostAwesomeDude> aib: I don't see anything wrong with (length . filter id) for this.
14:41:15 <aib> good to know :)
14:41:46 <johnw> @pl sum $ map (\x -> if x then 1 else 0) [True, False, True]
14:41:46 <lambdabot> if' True 1 0 + if' False 1 0 + if' True 1 0
14:41:49 <johnw> bah
14:41:55 <jtza8> timthelion: Ah, I thought so... Do you want to use a function from a module based on some condition?
14:42:16 <Yiq> > last []
14:42:18 <lambdabot>   *Exception: Prelude.last: empty list
14:42:22 <Yiq> why not Maybe?
14:42:38 <timthelion> johnw: I was asking about if' the other day.  It was described in an essay about how if sucks.  And it's definition was if' :: Bool -> a -> a-> a \n if' True a _ = a \n if' False _ b = b
14:42:54 <timthelion> jtza8: yes.
14:42:56 <johnw> @hoogle if'
14:42:56 <lambdabot> No results found
14:43:12 <johnw> @hoogle ifte
14:43:12 <lambdabot> No results found
14:43:17 <timthelion> johnw: but apparently it's not actually in any of the base libraries for some reason.
14:43:19 <MostAwesomeDude> @src if'
14:43:19 <lambdabot> Source not found. Do you think like you type?
14:43:20 <Yiq> > let lst [] = Nothing; lst [x] = Just x; (_:xs) = lst xs in (lst [], lst [1], lst [1..10])
14:43:21 <lambdabot>   Couldn't match expected type `[t]'
14:43:21 <lambdabot>         against inferred type `Data.Mayb...
14:43:31 <jtza8> timthelion: i.e. foo | condition = foo \n foo = bar
14:43:36 <johnw> LLVM calls the same thing "select"
14:43:53 <johnw> aka, the good ol' ternary operator of yesteryear
14:43:58 <timthelion> jtza8: yeah, something like that...
14:44:04 <Yiq> > let lst [] = Nothing; lst [x] = Just x; lst (_:xs) = lst xs in (lst [], lst [1], lst [1..10])
14:44:05 <lambdabot>   (Nothing,Just 1,Just 10)
14:44:06 <johnw> @hoogle (?:)
14:44:06 <lambdabot> No results found
14:44:18 <mm_freak_> johnw: i love arrows, but to be honest, i'm not overly fond of arrow style
14:44:27 <mm_freak_> johnw: i mostly use arrows in an applicative/category fashion
14:44:30 <johnw> what is arrow "style"?
14:44:37 <NoICE> johnw: I just thought maybe I could work directly with the XML tree (I use xml package (Text.XML.Light)), since the inquiry/response is so different for each type of inquiry (e.g. "subscriberList" uses just 4 attributes of Selection type :/ )
14:44:40 <johnw> you mean proc-notation?
14:44:40 <mm_freak_> johnw: using arrow combinators and/or arrow syntax
14:44:54 <johnw> i find that &&& and ||| bind my brain like a pretzel
14:45:00 <Yiq> why isnt last complete/safe? because you probably dont want to use it anyway?
14:45:08 <jtza8> timthelion: I don't really know of another way, although I'm new to Haskell.
14:45:15 <johnw> Yiq: beacuse the type of last returns a thing
14:45:20 <Yiq> :t (|||)
14:45:22 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
14:45:27 <johnw> Yiq: not a thing-or-maybe-nothing
14:45:42 <Yiq> so you get an exception instead
14:45:42 <mm_freak_> johnw: you'll find that most of the time applicative+category style is more sensible and beautiful
14:45:55 <johnw> mm_freak_: can you show me some examples?
14:46:09 <johnw> mm_freak_: or better yet, write another great article on using arrows in teh applicative+category style :)
14:46:38 <mm_freak_> johnw: there is a better way to appreciate this
14:46:45 <jtza8> timthelion: Perhaps it might be a good idea to consider doing things another way?
14:46:50 <mm_freak_> johnw: write your Arrow instance in terms of Category and Applicative
14:47:08 <mm_freak_> i.e. write instances for Category and Applicative, then write Arrow in terms of those
14:47:11 <timthelion> jtza8: nah, I think it's time to write another preprocessor for haskell code :D
14:48:02 <mm_freak_> btw, i'm slowly starting to see functors and categories everywhere
14:48:24 <johnw> mm_freak_: I would need example to grok what you're saying
14:48:36 <mm_freak_> johnw: you have written an arrow already
14:48:42 <johnw> isn't Category just "composition"?
14:48:49 <johnw> and "identity"?
14:48:51 <paolino> >>>
14:48:58 <mm_freak_> more or less with some laws
14:49:28 <mm_freak_> associative composition and an identity with respect to it
14:49:48 <jtza8> timthelion: Well, good luck with your code either way. :)
14:49:48 <shachaf> And with types, unlike Monoid.
14:50:47 <timthelion> mm_freak_: You see functors and categories everywhere, because it's pretty much impossible for a group of well, anything, to not follow the functor and category laws.  What would be interesting, is if you found some objects that where outside of a set with functor or category properties.
14:51:30 <timthelion> mm_freak_: that is, we'd be interested, if you found some set of objects to which functor and category do NOT apply :D
14:51:57 <mm_freak_> timthelion: i just started to categorize my shell commands…  it's just interesting to see that "echo" corresponds to 'pure' =)
14:52:09 <johnw> mm_freak_: so I'm not sure what you mean by "seeing categories everywhere", unless by category you didn't mean Category
14:52:26 <johnw> in terms of Category, I've been perforce seeing it everywhere since day one
14:52:38 <mm_freak_> johnw: i mean outside of haskell
14:52:42 <johnw> ah
14:52:55 <mm_freak_> shell pipelining forms a category and an applicative functor
14:53:26 <johnw>  That example I posted in that GitHub issue of a composed arrow; how would you write that code in the applicative?
14:53:26 <loreints> okay I'm feeling really stupid. I've been reading the monad chapters in LYAH and I'm still not any closer to figuring out how the hell I'm supposed to write a custom definition for >>=. Can someone help?: http://hpaste.org/73489
14:53:30 <paolino> :t pure
14:53:32 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
14:53:51 <mm_freak_> johnw: just write an Applicative instance instead of an Arrow instance
14:54:01 <Dustin_> Everyone, this is a sort of general question, but I want to ask it anyway. Are there any decent books on Haskell, and which one(s) would you recommend?
14:54:03 <johnw> loreints: that's not going to be a trivial definition.  Maybe you want to try a simpler monad?
14:54:06 <mm_freak_> johnw: instance Category MyArrow; instance Applicative (MyArrow a)
14:54:15 <DT``> mm_freak_, that's interesting. what's (<*>)?
14:54:20 <johnw> mm_freak_: I don't understand how that changes my example
14:54:30 <johnw> mm_freak_: I'm not getting what your getting at :)
14:54:32 <mm_freak_> johnw: just do it
14:54:36 <loreints> johnw: why won't it be trivial? what would you recommend instead?
14:54:40 <johnw> mm_freak_: I don't know what "doing it" implies
14:54:46 <johnw> mm_freak_: i.e., you've completely lost me
14:54:59 <johnw> mm_freak_: it's like saying, "You have to add an operation.  So just do it!"
14:55:11 <byorgey> loreints: I have to run, but my advice boils down to: Follow the Types!
14:55:13 <johnw> loreints: the maybe monad is a much better place to start
14:55:22 <johnw> loreints: then move to the Either monad, then the List monad
14:55:42 <byorgey> loreints: make sure you understand very well what the type of each identifier and subexpression is
14:55:44 <johnw> loreints: the State monad (and its relatives) is a beast.  Even beastlier is Cont
14:55:48 <mm_freak_> DT``: consider that a shell command is a morphism…  the functor is formed by mapping shell commands
14:56:02 <parcs`> loreints: hint: Parse m >>= f = Parse $ \state -> ...
14:56:07 <mm_freak_> it's an endofunctor
14:56:48 <parcs`> loreints: alternatively you can define join :: Parse (Parse a) -> Parse a and (>>=) will bo
14:56:50 <mm_freak_> johnw: ok, let's back up a bit:  data StateA s a b = StateA Bool ((a, s) -> (b, s))
14:57:02 <parcs`> lokydor: m >>= f will be join (fmap f m)
14:57:04 <mm_freak_> johnw: write a Category instance for 'StateA s'
14:57:04 <parcs`> loreints: ^
14:57:20 <mm_freak_> johnw: then write an Applicative instance for 'StateA s a'
14:58:44 <mm_freak_> DT``: notice that the "shell category" has only a single object
14:58:50 <mm_freak_> you might call it Text
14:59:04 <johnw> mm_freak_: I'm afraid I can't do that off the cuff yet.  Write me a new article and I will devour it at night when I have more time to process stuff
14:59:14 <DT``> mm_freak_, yeah. echo seems to be the identity morphism in that category, though.
14:59:19 <DT``> am I missing something?
14:59:25 <mm_freak_> johnw: the Applicative instance is actually in the arrow tutorial you have read =)
14:59:28 <DT``> ls | echo = ls.
14:59:40 <mm_freak_> DT``: no, 'echo' is 'pure'
14:59:45 <kallisti> DT``: don't you mean cat?
14:59:48 <mm_freak_> DT``: the identity morphism is the 'cat' command
14:59:51 <wi`> echo | ls /= ls
14:59:54 <DT``> oh, right, silly me.
15:00:00 <johnw> mm_freak_: so what does the applicative version of "match test_d >>> match test_r >>> match test_x" look like?
15:00:16 <mm_freak_> johnw: just like that
15:00:16 <parcs`> johnw: i haven't been following your discussion but if you want to know how arrow relates to applicative check out http://cdsmith.wordpress.com/2011/07/30/arrow-category-applicative-part-i/
15:00:36 <loreints> so I should 1). write a category instance for StateA s 2). write an applicative instance 3). define >>= in terms of join. Is that correct?
15:00:39 <mm_freak_> johnw: applicative style becomes significant when you actually make use of the arrow combinators =)
15:00:52 <johnw> parcs`: nice, thanks!  sending to tothe Kindle now :)
15:00:59 <johnw> I was reading Haskell articles for 5 hours straight last night
15:01:02 <mm_freak_> loreints: huh?  apparently you're mixing up discussion threads =)
15:01:08 <mm_freak_> loreints: the stuff about StateA was for johnw
15:01:18 <shachaf> johnw: Were you the person who talked about "unboxing" functors. :-(
15:01:39 <johnw> loreints: implement the Maybe monad, if you haven't already
15:01:47 <johnw> loreints: It's really a gem of a monad
15:01:49 <paolino> loreints, if m applied to s is Left you keep it, otherwise apply f to first
15:01:57 <johnw> loreints: in fact, implement it in another language too
15:02:05 <johnw> shachaf: yes
15:02:17 <johnw> shachaf: uh oh, I got a sad face from shachaf
15:02:22 <johnw> what did I do?
15:02:40 <johnw> it's fmap that unboxes, not the functor, right?
15:02:40 <mm_freak_> unboxing functors?  what does that mean?
15:02:42 <wi`> loreints: implement (>>=) for State and Either, then combine
15:02:46 <parcs`> loreints: use this template 'Parse m >>= f = Parse $ \state -> ...'
15:03:08 <johnw> loreints: I would avoid the State monad for a good while
15:03:17 <parcs`> (this would be a good use case for holes)
15:03:17 <johnw> loreints: it took me about 2 years to finally comprehend it
15:03:24 <johnw> (I would love holes)
15:03:29 <MarcWeber> Is there any http library which returns body as binary data and which can connect to https servers?
15:03:46 <c_wraith> @hackage http-conduit
15:03:47 <mm_freak_> MarcWeber: http-conduit can do both
15:03:47 <lambdabot> http://hackage.haskell.org/package/http-conduit
15:03:54 <johnw> hey MarcWeber!
15:03:56 <parcs`> MarcWeber: http-conduit?
15:04:19 <dmwit> That's three votes for http-conduit.
15:04:26 <dmwit> Any other voters?
15:04:41 <paolino> loreints, the point there is to let flow lefts and compose rights
15:06:05 <loreints> what
15:06:20 <mm_freak_> it's a major problem of #haskell
15:06:21 <paolino> look at parcs` hint
15:06:51 <mm_freak_> whenever someone tries to understand monads, around five people are trying to help simultaneously, each in totally different ways
15:07:18 <paolino> ok I'm the 5th I pop out
15:07:25 <johnw> mm_freak_: yes
15:07:30 <parcs`> loreints: if you still feel stuck, try writing the definition minus the newtypes, ie define (ParseState -> Either String (a, ParseState)) -> (a -> ParseState -> Either String (b, ParseState)) -> ParseState -> Either String (b, ParseState)
15:07:30 <meursault_> thanks for pointing me at hint earlier Cale and timthelion. My experiments with it so far have been quite successful. If I want to grab a function out of it from a piece of compiled code can I do something like kernelFunc <- interpret "funcName" (as :: Float -> Float)
15:07:36 <loreints> sorry, I'm just still confused. So, to solve my problem, do I have to write anything outside of the instance Monad Parse?
15:07:36 <MarcWeber> johnw: Do you have any experience with mingw? I've been trying to use curl for hours.
15:07:44 <meursault_> or does that have performance implications that I don't understand
15:07:45 <johnw> no, sorry I don't
15:07:49 <DanBurton> we need to teach Haskellers to be less helpful ;)
15:08:01 <parcs`> loreints: nope
15:08:04 <johnw> and to avoid inflicting the State monad on someone just learning monads
15:08:09 <johnw> it's not a luminous example
15:08:14 <DT``> DanBurton, I can help with th-oh.
15:08:24 <johnw> shachaf: did you have something more to say?
15:08:45 * johnw just discovered threadscope
15:08:48 <shachaf> johnw: It's all been said before.
15:08:50 <loreints> okay, well I guess I'll try to get this working for a bit. Thank you everybody!
15:08:57 <DanBurton> johnw: any ol' monad is fine for teaching monads. I see nothing awful about the State monad.
15:09:01 <shachaf> "unbox" or "box" are very unhelpful analogies.
15:09:02 <mm_freak_> loreints: my recommendation is to step back for a minute
15:09:09 <shachaf> DanBurton: Codensity!
15:09:14 <shachaf> That's the best monad, I hear.
15:09:18 <johnw> shachaf: well, they helped me, so they aren't completely unhelpful
15:09:33 <mm_freak_> loreints: try to solve a related problem
15:09:40 <DanBurton> shachaf: all monads are created equal. There was not a monad made that did not have return and bind
15:09:43 <shachaf> johnw: They helped you become the sort of person who writes about boxing and unboxing. :-(
15:09:55 <johnw> ?
15:10:09 <johnw> DanBurton: seriously?
15:10:11 * hackagebot obdd 0.2.5 - Ordered Reduced Binary Decision Diagrams  http://hackage.haskell.org/package/obdd-0.2.5 (JohannesWaldmann)
15:10:17 * shachaf doesn't have much to say.
15:10:38 <mm_freak_> loreints: you have a function of type 'X -> Parse Y"…  that's a parametric parser, i.e. it needs further information…  are you with me so far?
15:10:39 <DanBurton> shachaf agressively dislikes monad analogies that have potential for misinterpretation
15:10:40 <parcs`> the state monad is really confusing to beginners
15:10:48 <dmwit> johnw: shachaf is being grumpy because unboxing isn't really what's happening and (probably incorrectly) feels that such intuitions lead directly to the horrible "how do I unbox an 'a' from an 'IO a'" question.
15:11:04 <DanBurton> parcs`: it doesn't have to be, imho
15:11:15 <shachaf> dmwit: I don't care about "IO a" in particular.
15:11:17 <johnw> I did clearly state in my article that any metaphor -- and especially the metaphors I was using -- were intrinsically misdirecting, albeit necessary to at least have something concrete to say
15:11:18 <dmwit> For the record, I'm grumpy about it, too.
15:11:39 <shachaf> I mind people trying to extract and Int from a function "Int -> Int" just as much.
15:11:39 <johnw> dmwit: easy, unsafePerformIO :)
15:11:49 <johnw> shachaf: haha, point taken
15:12:02 <DanBurton> johnw: GASP! You mean, the-function-which-shall-not-be-named
15:12:22 <johnw> I was using boxing from my Java days: you box a value to give it the trappings necessary to use it in a certain context, and you unbox the value to observe the result
15:12:25 <paolino> rebox it
15:12:34 <dmwit> johnw: The point is that you can meaningfully use the boxing metaphor without ever talking about unboxing.
15:12:54 <johnw> but honestly, when I wrote it all I could think about was getting ready for my move to Illinois last year
15:13:08 <dmwit> How? Instead of saying that fmap unboxes a value, passes it to the function you provided, and boxes it back up, you can recast it by saying that fmap takes a function that operates on unboxed values and teaches it how to act on boxed values.
15:13:15 <DanBurton> shachaf: I can do that for you! extractFunc f :: (a -> r) -> r; extractFunc f = f undefined
15:13:41 <mm_freak_> the box metaphor is really really awful for functors
15:13:44 <shachaf> -fun-defined-loops
15:14:00 * DanBurton thinks the creepy thing is that the "burrito" analogy almost works better than "box/unbox"
15:14:02 <loreints> mm_freak_: not sure... I don't see how that applies to my implementation of bind.
15:14:03 <DT``> that signature looks a lot like call/cc and fix.
15:14:05 <shachaf> I would rather never use the word "box".
15:14:18 <mm_freak_> loreints: just listen…  are you following so far?
15:14:19 <simon> mm_freak_, arent most metaphors bad for describing complex things. <(
15:14:24 <loreints> yep
15:14:26 <wi`> "computational context"
15:14:37 * timthelion finds monads easy, but still doesn't undestand IO.
15:14:48 <shachaf> No one understands IO.
15:14:56 <simon> timthelion, as in "the IO monad" or as in IO in general_
15:14:56 <mm_freak_> loreints: now imagine that the X argument is not just some constant you pass to the function…  it's actually the result of another parser of type "Parse X"
15:14:58 <shachaf> I'm not sure what it means to "find monads easy", though.
15:14:59 <parcs`> it's like State RealWorld, but with concurrency
15:15:01 <armlesshobo> if one were to create the type class Aryan, would that make all its instances perfect types? :P
15:15:09 <timthelion> simon: as in IO in haskell.
15:15:16 <mm_freak_> loreints: still following?
15:15:26 <simon> shachaf, I suppose it could mean: to understand the type signature that underlies the lias Monad.
15:15:27 <DanBurton> timthelion: what about it don't you understand? How it is implemented?
15:16:12 <timthelion> DanBurton: yes, how it's implemented.  It's not a monad, that's clear.  Monads are pure, just like everything else.  But the IO bind, it's NOT a monadic bind, in that it breaks other fundumental laws :/
15:16:16 <loreints> mm_freak_: why would it be of type X and not Parse X in the initial function type definition?
15:16:52 <dmwit> timthelion: The Monad laws are generally taken to be the monad laws, but ignoring bottom. The IO bind is not a monadic bind, but it is a Monadic bind in this sense.
15:17:09 <mm_freak_> loreints: because "Parse X" is the type for /parsers/ that produce an X
15:17:25 <johnw> did you know that Aryan and Iran are from the same root word?
15:17:31 * DanBurton isn't sure whether he likes or dislikes Haskell's handwaviness when it comes to exceptions and nontermination
15:17:50 <mm_freak_> loreints: let's take IO as an example…  you have a function "putStrLn :: String -> IO ()"…  it's an action that depends on a string
15:17:57 <DanBurton> Koka looks interesting in that it is clearer about these things
15:18:13 <loreints> yup, I think I get that
15:18:15 <mm_freak_> loreints: now imagine that that string is not some constant string you pass to the function, but it's actually the result of another IO action
15:18:21 <mm_freak_> perhaps getLine :: IO String
15:18:34 <DT``> DanBurton, see also: http://disciple.ouroborus.net/
15:18:50 <DanBurton> disciple, also cool
15:18:56 <mm_freak_> loreints: in the end you want an IO () that performs the getLine and passes the result to putStrLn, i.e. a compound action
15:18:57 <scooty-puff> given f x = xs where xs = [0 ..] and f = const xs where xs = [0 ..]:
15:19:13 <scooty-puff> would the latter create a giant space leak if its defined at the top level?
15:19:23 <mm_freak_> loreints: so what you need is a combinator that combines the "IO String" and the "String -> IO ()" into an "IO ()"…  that's the second action applied to the result of the first
15:19:31 <mm_freak_> loreints: and that's exactly what (>>=) is
15:19:45 <parcs`> scooty-puff: probably
15:19:47 <DanBurton> well that's what (>>=) is when specialized to IO
15:19:58 <mm_freak_> that's (>>=) in general
15:20:02 <DanBurton> and specialized to String and ()
15:20:09 <DanBurton> well yes
15:20:17 <scooty-puff> parcs`: that sucks.. have a nice point-free function that i now have to stick a parameter onto and $ param just to make sure it isn't..
15:20:19 <mm_freak_> i just used IO, String and () as examples, but that's the basic idea of (>>=)
15:20:35 <mm_freak_> (>>=) :: IO String -> (String -> IO ()) -> IO ()
15:21:12 <DanBurton> my point was, that the list version of >>= will not help you if you want to glue IO actions together. Behind this abstract interface, there is a specific and concrete implementation for each type that implements it
15:21:14 <mm_freak_> produce a compound action where the second parametric (!) action gets the result of the first action as its parameter
15:21:28 <parcs`> scooty-puff: by all means test it out and see if that's the case
15:21:52 <scooty-puff> k
15:23:04 <loreints> mm_freak... you are kind of losing me because it's hard to generalize from your example.
15:23:18 <mm_freak_> loreints: don't generalize
15:23:32 <mm_freak_> loreints: imagine you have a Parse String and a String -> Parse Int
15:23:42 <mm_freak_> write a combinator to combine them, call it (>>==)
15:23:52 <mm_freak_> (>>==) :: Parse String -> (String -> Parse Int) -> Parse Int
15:24:19 <mm_freak_> then realize that you can easily replace String and Int by type variables
15:24:30 <mm_freak_> without changing the code =)
15:26:19 <parcs`> scooty-puff: looks like neither version exhibits a space leak
15:27:35 <parcs`> scooty-puff: wait never mind
15:30:55 <loreints> mm_freak: uh... is this close?: Parse s >>== f = Parse (f s)
15:31:36 <mm_freak_> loreints: that's a type error
15:31:57 <mm_freak_> loreints: if it doesn't compile, it's obviously not correct =)
15:32:10 <loreints> mm_freak: Parse s >>== f = f s?
15:32:26 <mm_freak_> loreints: don't guess, think!
15:33:04 <scooty-puff> parcs`: ?
15:33:16 <mm_freak_> loreints: Parse s >>== f = Parse (\str0 -> let (x, str1) = s str0 in …)
15:33:35 <parcs`> scooty-puff: they both exhibit the same behavior, but i'm not sure whether to classify it as a leak or not
15:33:43 <scooty-puff> where xs is shared?
15:34:47 <scooty-puff> i can experiment with it
15:35:08 <loreints> I guess I don't get why the Parse type constructor is being applied to a lambda function. What new argument is it expecting? I'd assume that that Parse s and f are the only arguments that matter.
15:35:27 <scooty-puff> the specific case i am dealing with is create the initial state for a state monad, where the state is made up of infinite streams
15:35:43 <mm_freak_> loreints: i'm assuming this implementation:  newtype Parse a = Parse (String -> (a, String))
15:35:45 <johnw> loreints: and that is exactly why I suggested come back to the State monad after doing some of the others
15:36:08 <loreints> newtype Parse a = Parse { runParse :: ParseState -> Either String (a, ParseState); }
15:36:31 <scooty-puff> parcs`: bah, i'll leave it for now until the whole thing is working and wait to test til then
15:36:33 <mm_freak_> loreints: try to implement State first
15:36:46 <mm_freak_> loreints: the Either will make things unnecessarily complicated for now
15:36:54 <mm_freak_> newtype State s a = State (s -> (a, s))
15:36:59 <loreints> mm_freak_: what do you mean implement State first?
15:37:11 <mm_freak_> see above
15:40:13 * hackagebot una 2.0.1 - Universal un-archiver utility  http://hackage.haskell.org/package/una-2.0.1 (JohnWiegley)
15:43:51 <rosie> I see the use of using "newtype Celcius Float" and "newtype Fahrenheit Float". Why use "newtype State s a = State (s -> (a, s))" rather than having state be a type constructer?
15:46:03 <shachaf> What do you mean?
15:46:06 <shachaf> It is a type constructor.
15:46:32 <geekosaur> "data" adds a level of indirection that "newtype" does not
15:46:53 <rosie> geekosaur: Can you explain that level of indirection?
15:47:01 <shachaf> Oh, you're asking about newtype vs. data?
15:47:15 <rosie> shachaf: yep
15:47:17 <shachaf> There's a wiki article on it.
15:47:20 <shachaf> @google newtype vs data
15:47:22 <lambdabot> http://stackoverflow.com/questions/2649305/why-is-there-data-and-newtype-in-haskell
15:47:22 <lambdabot> Title: types - Why is there "data" and "newtype" in Haskell? - Stack Overflow
15:47:31 <rosie> got it, thanks!
15:47:38 <shachaf> Well, that page works too. :-)
15:47:58 <shachaf> It mostly has to do with _|_. Do you know what that is yet?
15:58:39 * edwardk waves hello.
15:58:48 <edwardk> preflex: xseen acowley
15:58:49 <preflex>  acowley was last seen on freenode/#haskell 22 hours, 32 minutes and 35 seconds ago, saying: edwardk: Okay, will do
15:59:38 <HugoDaniel> hi
16:04:05 <acowley> edwardk: hello!
16:04:05 <lambdabot> acowley: You have 1 new message. '/msg lambdabot @messages' to read it.
16:04:24 <edwardk> acowley: added the quaternions the other day
16:04:34 <edwardk> also bolted a new mode into ad that may work better for you
16:05:00 <edwardk> waiting for benchmark results from lennart to see if its an improvement for him
16:05:08 <acowley> I need to work faster
16:05:17 <edwardk> but i'd be curious to see how Numeric.AD.Mode.Chain stacks up to Numeric.AD.Mode.Reverse for you
16:05:25 <edwardk> in case you still have any code lying around that uses it
16:05:41 <edwardk> if its faster for you as well i may swap it in and make it the default Reverse mode
16:06:00 <edwardk> since you two are pretty much my heaviest users
16:06:14 <edwardk> also lennart improved the performance of topSortAcyclic
16:06:26 <acowley> Two comments about quaternion: Quaternion's rotate function wasn't working as I expected, so I replaced it with the more compact "rotate q v = q * Quaternion 0 v * conjugate q"
16:06:27 <edwardk> so it should run a fair bit faster and with less memory usage now
16:06:41 <edwardk> acowley: i may have flubbed it
16:07:00 <acowley> which also points to another minor tweak, I'd probably slightly prefer if Quaternion was a scalar and a V3
16:07:10 <acowley> because then we can write quaternion multiplication as cross and dot products
16:07:25 <acowley> It's just less error prone
16:07:48 <edwardk> not sure there. i can see embedding the V3 strictly perhaps and unpacking it
16:08:02 <edwardk> but i worry that it'll pessimize the performance of the operations if it doesn't inline perfectly
16:08:09 <acowley> Then there is a question that is purely stylistic: the accessors x,y,z,etc. use up some rather valuable realestate in the identifier neighborhood
16:08:13 <acowley> edwardk: I agree
16:08:23 <acowley> edwardk: I'd want to see if we can ensure it unpacks
16:08:34 <edwardk> acowley: i'm thinking about renaming them to _x, _y, _z and _e, _i, _j and _k
16:08:38 <acowley> edwardk: I'm also adding Storable instances because I use these types with OpenGL
16:08:43 <acowley> edwardk: that is exactly what I was going to suggest
16:08:45 <edwardk> that is what i do for lens, and it works pretty well
16:08:48 <acowley> edwardk: I do that in my code, and it looks fine
16:08:51 <edwardk> yeah
16:09:22 <edwardk> sold
16:09:25 <acowley> okay, so no controversy
16:09:26 <edwardk> i'll go bang that out now
16:09:49 <acowley> The unpacking part is tough because we can't unpack polymorphic fields
16:09:53 <edwardk> and push up a patch for the rotation or at least an issue
16:10:03 <edwardk> we can unpack the V3 itself though
16:10:13 <edwardk> if you really want it to directly be a member
16:10:22 <edwardk> though that isn't appreciably better than just accessing it with xyz
16:10:26 <edwardk> or _xyz i guess now ;)
16:10:32 <acowley> That's a good point
16:11:08 <acowley> And, yes, I am dismayed that my topological sort has been dethroned :P
16:12:22 <edwardk> =)
16:12:44 <edwardk> i would really like to know how well chain stacks up though
16:13:48 <acowley> edwardk: I'll try to revive some of the image processing I was doing before. Last time I tried to scrape off the rust I couldn't put it back together.
16:13:53 <edwardk> k
16:14:04 <edwardk> i'll just go off of lennart's benchmarks then
16:15:31 <acowley> edwardk: is the implementation code worth looking at yet? It's a pretty rad (ahem) code base already, but the tape-based optimization sounded fairly gnarly when we talked about it before.
16:15:47 <edwardk> yeah it works pretty well
16:15:59 <edwardk> just poke at Numeric.AD.Internal.Chain
16:16:09 <edwardk> and compare to Reverse
16:16:20 <edwardk> i factored out some common support code
16:18:41 <acowley> Your allergy to comments makes me itchy
16:19:08 <edwardk> i got over them in lens. i just haven't added any to these ;)
16:19:12 <edwardk> please patch! =)
16:20:07 <acowley> I know I should, but the ad code base is not something I'm comfortable with yet. I'm sure my comments would be misleading at best.
16:20:30 <edwardk> fair enough
16:20:35 <edwardk> i should do a documentation pass over 'ad'
16:20:42 <edwardk> it has a good number of users now
16:20:47 <edwardk> and it needs some love
16:21:27 <edwardk> i underscored the names in linear
16:21:30 <edwardk> and pushed
16:23:08 <edwardk> basically with Chain i have a single tape i smash into a dictionary using reflection. and then i poke at it with some carefully sequenced io actions
16:23:41 <edwardk> the tape itself consists of the unary and binary update nodes, the chain of vars at the end of the tape is implicit upon hidding Nil
16:23:43 <edwardk> er hitting
16:25:21 <acowley> Is any of your monte carlo sampling with hamiltonian dynamics code on github?
16:28:31 <edwardk> i have a very tiny example of how to do hamiltonian mcmc in a gist somewhere
16:28:45 <edwardk> there were licensing reasons why i didn't put up the main codebase
16:28:51 <edwardk> one sec while i find the gist
16:29:21 <edwardk> https://gist.github.com/5739676c452ada86af2a
16:29:42 <acowley> It came up because my wife's group is doing these simulations of particles suspended in fluid moving between various sources of circular currents
16:29:44 <edwardk> that has the basic hmc step function
16:29:44 <edwardk> and includes a leapfrog integrator
16:30:41 <acowley> Well that looks rather tidy
16:30:51 <acowley> edwardk: thanks!
16:31:45 <int80_h> what exercises can I do to test my understanding of rankNtypes?
16:32:00 <edwardk> feel free to use a better implementation of rnorm, etc. ;)
16:32:04 <edwardk> i just wanted it to fit on a slide ;)
16:32:18 <edwardk> int80_h: implement the monads for Yoneda and Codensity
16:32:48 <edwardk> newtype Codensity f a = Codensity { runCodensity :: forall r. (a -> f r) -> f r) }
16:33:20 <shachaf> edwardk: That's your default answer to any question in #haskell!
16:33:28 <acowley> They're just getting started on it, and they do everything in matlab. I thought I should implement some of their stuff in Haskell and make it available to them as a library.
16:33:31 <edwardk> its correct in this case ;)
16:33:40 <edwardk> acowley: sounds fun
16:33:45 <acowley> Though I always run into trouble with needing GHC for linking
16:33:50 <acowley> so it's fairly antisocial
16:34:41 <int80_h> edwardk: can you point me to a resource about those two monads?
16:35:02 <edwardk> int80_h: myblog comonad.com, Kan Extensions I, II, and III
16:35:37 <int80_h> edwardk: thanks :)
16:36:23 <NoICE> good night
16:36:28 <edwardk> int80_h: another good one is the proper rank 3 type for callCC
16:36:48 <edwardk> int80_h: and the pile of rank 2 types used inside lens
16:37:21 <int80_h> edwardk: I will study lens, but I can't know I understand until I try to use them.
16:38:16 <edwardk> int80_h: the wiki https://github.com/ekmett/lens/wiki has a writeup on the derivation of the types for lenses and traversals
16:38:31 <edwardk> that uses some rank 2 types to reason about getters as well
16:39:26 <edwardk> another fun one: data a := b = Refl { subst :: forall c. c a -> c b }
16:39:32 <edwardk> that is fun to make the Category instance for
16:39:48 <int80_h> edwardk: much thanks :)
16:42:04 <parcs`> int80_h: also understand the type signature of runST and why it prevents references from leaking out
16:42:30 <edwardk> that trick is gold
16:43:22 <edwardk> an expert level version of the yoneda/codensity hack: https://github.com/ekmett/machines/blob/master/src/Data/Machine/Plan.hs#L49 ;)
16:44:33 <c_wraith> edwardk: http://comonad.com/reader/2012/wadlers-law-revisited/ is kind of amusing, given your recent work on lens :)
16:44:42 <edwardk> notice the rank 3 type
16:44:42 <edwardk> c_wraith: =)
16:45:14 <edwardk> i spent a lot of time thinking about lexical syntax for that package. its true ;)
16:46:22 <acowley> edwardk: thanks for all the fish, I'm signing off for the evening.
16:46:28 <edwardk> acowley: night man
16:51:04 <dropdrive> Question about http://stackoverflow.com/a/393953 -- could one not just write x = 0 : 1 : x ?
16:51:11 <BMeph> Is there a name for a function whose codomain is the entire type, in analogy to a total function?
16:52:33 <copumpkin> BMeph: surjective?
16:52:39 <edwardk> dropdrive: in haskell, yes
16:53:10 <int80_h>  parcs : ah good.I came across ST in my initial investigations.
17:02:04 <BMeph> copumpkin: Okay, now that I went back and looked up all the definitions, it works out. So, do you know of an analogous name for a relation that may not also be surjective, or even a function?
17:02:32 <copumpkin> right-total, I think
17:04:17 <BMeph> copumpkin: Ah, excellent! If I ever do anything with allegories, I'll remember - thanks!
17:14:51 <loreints> why am I getting
17:15:06 <loreints> "parse error on input 'data'" for data Car = Car { company :: String, model :: String, year :: Int} deriving (Show)
17:15:25 * hackagebot wl-pprint-text 1.1.0.0 - A Wadler/Leijen Pretty Printer for Text values  http://hackage.haskell.org/package/wl-pprint-text-1.1.0.0 (IvanMiljenovic)
17:15:28 <loreints> (in ghci)
17:15:41 <c_wraith> oh.  only very new versions of ghci support data declarations
17:15:43 <mauke> because you're in ghci
17:17:12 <loreints> huh, why is that?
17:19:25 <c_wraith> because ghci already isn't haskell (it executes top-level IO actions!)..  It was originally intended for interacting with files containing things like data declarations already
17:26:10 <loreints> what? I don't get why executing IO actions means I can't declare data types.
17:26:35 <shachaf> ghci isn't a Haskell file.
17:26:38 <shachaf> That's all.
17:30:26 * hackagebot hyphenation 0.2.1.3 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.2.1.3 (EdwardKmett)
17:30:34 <n00b6502> ghci repl is single line  ::IO ?
17:31:11 <n00b6502> or detects if its input is  ::IO
17:33:10 <Mortchek> n00b6502, it does a few different things. It evaluates and prints out the value of most expressions you give it, but will run IO actions resulting from those. It also lets you use let to bind values to variables.
17:33:38 <Mortchek> It basically feeds your input into a do block.
17:33:44 <shachaf> And declare data declarations.
17:34:02 <Mortchek> shachaf, how?
17:34:14 <shachaf> data Foo = Foo
17:34:24 <Mortchek> That's odd, I can't do that.
17:34:32 <shachaf> Upgrade.
17:34:37 <n00b6502> ghci is a subset or full haskell... can you run a real program then susppend and poke around in it (does that even make sense in haskell)
17:35:09 <n00b6502> mr C++ does miss the repl from childhood basic
17:36:59 <Jafet> ghci is a do block on drugs
17:44:09 <rosie> Why is return :: a -> State s a         return x = State ( \st -> (x, st) )   rather than return x = State x st ?
17:45:26 <shachaf> rosie: What's the type of State?
17:45:44 <shachaf> Keep in mind that "State" the value and "State" the type are two different entities.
17:47:05 <rosie> shachaf: aha! thanks
17:47:25 <shapr> Yow!
17:50:37 <shachaf> shapr!
17:54:31 <nand`> rosie: that would be an error, ‘st’ is not in scope
17:55:02 <rosie> hand`: ha, you're right
17:55:16 <shachaf> HAND, hand`
17:55:28 <nand`> half-and
17:58:14 <dgpratt> I ran into a cabal tangle earlier that I eventually sorted out (thanks dcoutts_), but I wish to understand better the root cause of the issue...
17:59:06 <dgpratt> so suppose I have some package 'Foo' v1.0 installed locally...
17:59:21 <dcoutts_> dgpratt: there's two parts to it: one is that we make conservative assumptions about what versions of packages are needed, specifically...
17:59:49 <shapr> shachaf: howdy!
18:00:47 <dcoutts_> dgpratt: each package can only depend directly or indirectly on one version of any other package
18:01:48 <dcoutts_> dgpratt: consider what that means, suppose I have a package 'a' that depends on 'b' and 'c', now 'b' and 'c' depend on 'd'. This means 'b' and 'c' must depends on the same version of 'd', otherwise 'b' and 'c' cannot be used together by 'a'.
18:02:21 <dcoutts_> the reason for this is that package 'a', might take a value produced by code in package 'b' and pass it to 'c'
18:02:43 <dcoutts_> and if the type of that value came from 'd', then it'd be a type error unless it's the exact same version of 'd' in both cases
18:03:14 <dcoutts_> this isn't just a theoretical problem, it really can happen very easily
18:03:34 <dcoutts_> it was the root problem of the first great cabal crisis
18:04:18 <dcoutts_> which I solved by writing a new dependency solver that conservatively assumes that we are only allowed a single version of each package, and thereby have none of these type error problems
18:04:41 <dgpratt> dcoutts_: makes sense, thanks for explaining this
18:04:49 <dcoutts_> dgpratt: but it is an over-conservative assumption. Sometimes it would be fine because no information is passed between the packages
18:05:00 <dcoutts_> so it does make things more fragile
18:05:33 <Veinor> yeah
18:05:42 <dcoutts_> to achieve this state of all packages in a solution depending on the same version of any given dependency, we may have to rebuild a package against a different version of some of its dependencies
18:05:45 <Veinor> on the other hand, having a package manager in a state where some programs work but others don't would be... weird
18:05:59 <dcoutts_> and rebuilding packages breaks all packages that depend on the rebuilt package
18:06:05 <dcoutts_> that's the second problem
18:06:34 <dgpratt> dcoutts_: could the dependent packages be rebuilt automatically?
18:07:23 <dcoutts_> dgpratt: maybe, but there's no guarantee. You can try it of course: when cabal says something would be broken if you proceed, you can try adding it to the target list so it'll be rebuilt
18:07:40 <dcoutts_> dgpratt: but rebuilding it is not guaranteed to actually work of course
18:07:55 <dcoutts_> there's two solutions here: one is to allow multiple instances of the same version of a package to be installed at once. That prevents breaking already installed packages
18:08:28 <dcoutts_> The other partial solution is to give the dep solver more information so that it doesn't need to be so conservative about making sure we only have one version of anything
18:08:38 <dcoutts_> that's what "private dependencies" are all about
18:09:18 <dcoutts_> if you know no types from a dependency escape in your public API, then it's fine for the version to not match some other user of the same package name
18:09:33 <dgpratt> dcoutts_: yep, makes sense
18:10:13 <dcoutts_> so those two things, plus making it easier to fix dependencies after packages are released, that I think would go a long way to solving the current cabal crisis
18:10:50 <dcoutts_> fortunately there's been progress on each of these
18:11:38 <dgpratt> considering that Haskell packages are distributed as source and considering that Haskell programs which compile *usually* work, it seems like there might be some future where we could do something more sophisticated than binary versioning, does it not?
18:12:16 <dgpratt> dgpratt: or am I being too hopeful?
18:13:50 <dgpratt> why do I do that...address myself? honestly, I don't do this in person :)
18:16:17 <dcoutts_> dgpratt: yes indeed, this has indeed been considered before and it is generally agreed to be a good idea
18:16:28 <dcoutts_> but it's a non-trivial amount of work to implement
18:16:36 <dgpratt> dcoutts_: I can only imagine
18:17:00 <ReinH> Ugh no haskell live episode today. Hopefully tomorrow :(
18:17:05 <ReinH> I feel bad.
18:20:29 <mariojv> ReinH: I had not discovered haskell live, that looks interesting. Thanks.
18:20:46 <dgpratt> ReinH: are you being compensated for these episodes?
18:29:09 <ReinH> dgpratt: nope
18:29:41 <ReinH> dgpratt: ok, in the interest of full disclosure, I should mention that someone is tipping me $3 on gittip. Which I have no idea how to collect.
18:30:02 <edwardk> ReinH: needs moar lenses ;)
18:30:16 <edwardk> ReinH: in all seriousness i think its good that you are doing the videos
18:30:17 <ReinH> edwardk: needs maor episodes
18:30:26 <dgpratt> ReinH: then what's to feel bad about? although if it motivates you to get it out there, then feel bad, man!
18:30:32 <ReinH> I am going to introduce lenses when I start doing hardcore board manipulation
18:30:47 <ReinH> dgpratt: people are expecting them and I've been busy :(
18:30:57 <ReinH> so yes, it's motivating, so I'll keep the feel I guess :)
18:31:15 <edwardk> ReinH: lesson number one about doing a regular column or series is to make sure you have a few in the can before you start showing them ;)
18:31:16 <rking> ReinH: Apparently there's a #gittip
18:31:23 <ReinH> edwardk: yep
18:31:29 <edwardk> that way when you inevitaby have to take a break, you just eat into your reserve
18:31:36 <ReinH> rking: I mean, I could find out, I just haven't botehred
18:31:39 <ReinH> edwardk: totes
18:31:56 <ReinH> edwardk: the only probablem is that I like to respond to feedback and incorporate in the next episode
18:31:59 <rking> And also this is pretty interesting: http://blog.gittip.com/post/26350459746/the-first-open-company
18:32:01 <edwardk> yeah
18:32:02 <ReinH> so it's live in more than one way
18:32:09 <edwardk> i can see how in this format that is difficult
18:32:34 <ReinH> edwardk: what's the performance story for lenses?
18:32:40 <ReinH> I assume it depends heavily on the thing being lensed
18:32:49 <edwardk> they are pretty good actually
18:32:53 <ReinH> but what kind of overhead are we talking about?
18:32:54 <edwardk> they pretty much inline away
18:33:02 <edwardk> even composed
18:33:10 <ReinH> edwardk: so a repa int board might be pretty fast
18:33:15 <edwardk> they are al set up so that they inline and their compositions inline, etc.
18:33:23 <ReinH> smart
18:33:25 <ReinH> wicked smart
18:33:46 <edwardk> even the ones that get generated are generated with inline pragmas by TH ;)
18:34:01 <ReinH> edwardk: my goal is to base all board traversal on lenses and traversals so that I can change the board impl and just change some types and some lens implementations
18:34:18 <edwardk> that could actually be pretty cool
18:34:34 <ReinH> so I can switch from the current slow-ass list representation to a repa 2x matrix of Ints
18:34:34 <edwardk> you may not get all the way there, with bitboards its often faster to do entire ranks or files at a time
18:34:40 <ReinH> the thing is
18:34:47 <ReinH> I'm using board-based
18:34:50 <ReinH> bitboards are piece-based
18:34:52 <edwardk> fair nuff
18:34:53 <ReinH> so that would be difficult
18:34:57 <ReinH> but
18:35:08 <ReinH> a repa matrix of unpacked ints would probably be pretty damn fast
18:35:33 <edwardk> well, its still a 'big' board rep
18:35:55 <ddarius> All things end in Monte Carlo integration.
18:35:58 <edwardk> so you're going to have some performance headaches. the fast c hacks for doing the moves and then undoing them to restore the board don't work well
18:36:04 <ReinH> I'm not going to compete with Rybka but if I can make a playable engine I'll be super happy :)
18:36:20 <edwardk> ReinH: fair nuff
18:36:22 <ReinH> if I can get it running at playable speed at (say) 6 ply I'll be super happy
18:36:40 <ReinH> yeah, it won't be well memory bounded at all I suspect
18:36:47 <edwardk> ddarius: or tanh-sinh quadrature
18:36:48 <ReinH> since I'm not mutating a board representation (move/unmove)
18:37:51 <ReinH> but on modern machines I hope I can get a playable engine even without low-level performance optimization
18:38:07 <edwardk> its not bad to get something the average joe can't beat at least
18:38:13 <ReinH> yep
18:38:23 <ReinH> and it's more about the pedagogical value than the chess engine per se anyway
18:38:49 <ReinH> but having a viable chess engine will certainly make the series seem a bit more real-world
18:39:25 <ReinH> and I think with the right evaluation strategy, a decently performant board representation, and a good alpha-beta, I can get pretty damn close
18:39:43 <ReinH> my intuition is that haskell should be pretty amazing at the alpha-beta search
18:40:08 <edwardk> yeah alpha beta fits on 2 lines
18:40:13 <ReinH> edwardk: SHOW ME!
18:40:20 <ReinH> heh
18:40:30 <ReinH> I'm not yet sure if I'll want to make it iteratively deepening
18:40:46 <ReinH> but I know I'll at least be using alpha-beta after I implement the basic negamax
18:40:47 <edwardk> heh, if you dig through tunes.nef for the old haskell logs you can probably find me rambling about it ;)
18:40:58 <ReinH> ugh fine :p
18:41:11 <ReinH> I don't even know what that is but ok
18:41:49 <ReinH> the key to a good alpha beta is ofc the tree ordering
18:42:08 <ddarius> @where whyfp
18:42:08 <lambdabot> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
18:42:39 <ReinH> edwardk: oh look what I just found http://www.haskell.org/pipermail/beginners/2010-February/003625.html
18:42:54 <ReinH> seems good
18:43:05 <edwardk> looks verbose ;)
18:43:14 <ReinH> edwardk: yeah but verbose can be useful
18:43:17 <ReinH> for teaching
18:43:35 <ReinH> also negascout is slightly more complex b/c of zero windowing
18:44:06 <ddarius> Using translations of imperative programs is usually a bad idea for Haskell pedagogy.
18:44:12 <ReinH> ddarius: good point
18:44:37 <ReinH> ddarius: I didn't really look through but I'm hoping they didn't literally transliterate them
18:44:54 <edwardk> hah, my opinion on the classy prelude has shifted over the years: http://tuukka.iki.fi/tmp/haskell-2007-03-24#01:40:39.2
18:45:07 <ddarius> edwardk: ?
18:45:31 <ReinH> edwardk: seems like you should be able to specify negamax with a traversal?
18:45:33 <nand`> edwardk: you hadn't gotten enough ambiguous type errors it seems
18:45:36 <ddarius> edwardk: 2007 was when you were young and new.
18:45:48 <edwardk> ddarius: was searching for my old alphabeta/negascout code. found a discussion with dpiponi about one
18:45:53 <ReinH> heh
18:46:31 <shachaf> dpiponi used to go here?
18:46:35 <shachaf> Those must've been the days.
18:46:35 <edwardk> yeah, that was a long time ago: http://tuukka.iki.fi/tmp/haskell-2007-03-24#03:01:47
18:46:38 <edwardk> shachaf: yeah
18:46:49 <edwardk> he still wanders in every 6 months or so
18:46:50 <ReinH> edwardk: dinner time but if you find anything I'll be lurking or you can message me :)
18:46:50 <rosie> Is there an intuitive mnemonic for evalState vs execState?
18:47:00 <edwardk> preflex: xseen dpiponi
18:47:01 <preflex>  dpiponi was last seen on freenode/#haskell 302 days, 1 hour, 45 minutes and 44 seconds ago, saying: BMeph: I might blog about one aspect of GLUT programming though it's a bit of a dirty hack really.
18:47:07 <shachaf> rosie: I just look at the type.
18:47:38 <shachaf> Hmm, apparently I first joined #haskell in 2007-02-01?
18:47:42 <shachaf> That's too long ago. :-(
18:47:53 <ddarius> shachaf: Yes.  That's one of those questions you don't ask.
18:48:32 <shachaf> ddarius: Which question?
18:48:57 <ddarius> shachaf: "How long have I been on this channel?"
18:49:27 <edwardk> shachaf: hah newcomer! ;)
18:49:57 <ddarius> edwardk: I'm sure there was over 100 people on when you joined.
18:50:12 <edwardk> yeah, probably 250 or so
18:50:22 <edwardk> i was pretty late to the game
18:52:30 <shapr> preflex: xseen sigfpe
18:52:30 <preflex>  Sorry, I haven't seen sigfpe
18:52:32 <shapr> aw
18:52:56 <shachaf> preflex: xseen dpiponi
18:52:56 <preflex>  dpiponi was last seen on freenode/#haskell 302 days, 1 hour, 51 minutes and 39 seconds ago, saying: BMeph: I might blog about one aspect of GLUT programming though it's a bit of a dirty hack really.
18:53:00 <edwardk> he's usually dpiponi on here
18:53:11 <shachaf> SIGFPE is taken by a different Freenode user.
18:53:19 <shachaf> As I found out when I /msged them once.
18:53:33 <otters> preflex: xseen otters
18:53:34 <preflex>  otters was last seen on freenode/#haskell 9 hours, 22 minutes and 55 seconds ago, saying: :t random
18:53:50 <ddarius> preflex: xseen Darius
18:53:51 <preflex>  Darius was last seen on magnet/#london.pm 356 days, 12 hours, 9 minutes and 9 seconds ago, saying: jjl: impressive!
18:54:00 <ddarius> What the shit?
18:54:16 <ddarius> Oh yeah, preflex.
18:54:21 <mauke> ddarius: hmm?
18:54:35 <shachaf> preflex: seen Darius
18:54:36 <preflex>  Darius was last seen on #haskell 1 year, 14 days, 22 hours, 8 minutes and 20 seconds ago, saying: pretty unusual, obviously
18:55:03 <otters> all these people have really unremarkable last words :(
18:55:19 <ddarius> preflex: seen mmorrow
18:55:19 <preflex>  mmorrow was last seen on #ghc 2 years, 216 days, 22 hours, 57 minutes and 38 seconds ago, saying: * mmorrow is rtfm'ing
18:55:46 <donri> still reading the manual?
18:56:37 <NegativeK> Perhaps mmorrow is reading all of the manuals.
19:02:01 <donri> did we just witness a live sex change operation
19:02:42 <Clint> it wouldn't be the first
19:08:43 <YayMe_> Yay, my lead architect resigned!!
19:09:25 <YayMe_> Who is keeping me in the dark ages of C# because "not all developers can understand lambda's or delegates"
19:09:34 <YayMe_> no higher order functions after learning haskell is boo
19:10:05 <YayMe_> Hopefully the next guy will say we can write good code rather than more code
19:10:29 <YayMe_> Has anybody touched Fantom?
19:12:36 <YayMe_> Why is it every freeging time I try to find convincing articles about why to use functional programming it just says "Because it makes you smarter and it solves math problems and is pretty bla bla bla" instead of what I see to be the actual reason every shop everywhere should be writing functional code:
19:12:45 <YayMe_> There is simply no better way to work with a data set.
19:12:59 <YayMe_> And every piece of software has data sets, especially these days they're large
19:13:54 <YayMe_> for crud or UI sure, ignore it, but when you actually have to do something with the data set that comes from the UI or the database, it's time to start using higher order functions on the lists to execute whatever manipulations need be done
19:14:50 <ddarius> Higher order functions are not functional programming.
19:15:18 <shachaf> What is functional programming? Functions, as opposed to procedures?
19:15:27 <YayMe_> pattern matching, destructuring, mapping, folding, and list comprehensions are the absolute best way to manipulate a data set
19:15:29 <YayMe_> that I have found
19:15:44 <YayMe_> I'm not that bright though so I'm the last person who should be speaking in absolutes
19:16:21 <Jafet> ddarius, don't you know that most grad students are now busy implementing mapreduce in cloud haskell?
19:16:27 <Jafet> With monads
19:16:41 * ddarius finds Conal's "value-oriented programming" to have more appropriate connotations.
19:17:03 <edwardk> ddarius: he was on ##ghclive yesterday with shapr
19:17:08 <edwardk> (re darius)
19:17:16 <ddarius> edwardk: Yeah, I saw shapr's mention of hi.m
19:17:17 <edwardk> er #ghclive
19:18:28 <YayMe_> Am I wrong in thinking that for just any average manipulation of a data set you should favor functional techniques over OO/imperative ?
19:18:57 <ddarius> YayMe_: Most data sets are better modelled as values rather processes.
19:19:09 <YayMe_> I didn't say modeled, I said processes
19:19:26 <YayMe_> CRUD is where modelling matters and for that I agree, use OO methods
19:19:32 <YayMe_> or UI again, modelling
19:19:50 <ddarius> YayMe_: I had a typo, but even factoring that in, I'm really not sure what you read my sentence as saying.
19:20:15 <shachaf> Rich Hickey had a talk about that recently, I think.
19:20:19 <YayMe_> but when your UI gets a data set and that data set needs to be modified before inserting, the modifications should be executed using functional techniques me thinks
19:21:34 <YayMe_> Maybe I'm just tired of managing the iterators in loops, but I hope I haven't found a new hammer and begun to see nails everywhere
19:22:55 <ddarius> YayMe_: Read Seif Haridi's and Peter van Roy's "Concept, Techniques, and Models of Computer Programming".  I feel that positions functional programming and object-oriented programming (more) appropriately.
19:23:10 <YayMe_> It feels like using those things I listed instead of iterating a data set in loops which often have nests of loops is just cleaner and more correct, even though large linq concoctions make my fellow C# folks shriek and hiss
19:23:33 <YayMe_> Is that a book or a white paper?
19:24:11 <YayMe_> http://www.epsa.org/forms/uploadFiles/3B6300000000.filename.booksingle.pdf
19:24:16 <ddarius> In this case it's a book.  I don't actually know what "white paper" means, but from my experiences, I rarely refer to white papers.
19:24:36 <n00b6502> i think functional style is more pleasant than iterators and loops
19:24:58 <YayMe_> Holy balls that's a big book
19:25:22 <ddarius> http://en.wikipedia.org/wiki/White_paper
19:26:13 <sellout42> YayMe_: It’s a really good book, though.
19:27:12 <YayMe_> based on the table of contents it sounds extremely comprehensive across a swath of computing not a lot of books are, so I would guess it is pretty good
19:27:33 <ddarius> It's probably the closest thing to an SICP of the 21st century.
19:27:34 <YayMe_> the guy must know his shit to write that much across such an enormous portion of software
19:27:40 <YayMe_> SICP?
19:27:56 <ddarius> YayMe_: Actually, not knowing what you're talking about is usually more conducive to copious writing.
19:28:25 <YayMe_> ddarius: True, but if you didn't know what you were talking about your table of contents wouldn't have the topics he lists broken up as he did
19:28:53 <sellout42> YayMe_: I have this hanging by my desk: http://www.info.ucl.ac.be/~pvr/paradigms.html . It's a good companion to the book.
19:31:19 <sentientwaffle> when using record update syntax (ie X {foo = bar}) does haskell internally copy all other properties?
19:31:31 <YayMe_> I once had to manually serialize a structure (which I did not design because I never would have modelled something like this) that was if I recall correctly: SortedList<int,Dictionary<SomeEnum,List<int>>> and doing it using functional techniques was denigrated by my colleagues in code review because it was only like 5 lines, but I left it in because it would have been 50 lines to do it with loops which gives 10 times the chances to scr
19:31:35 <shachaf> sentientwaffle: Haskell doesn't do anything.
19:31:41 <shachaf> sentientwaffle: GHC will compile code that copies pointers.
19:32:07 <sentientwaffle> shachaf: so its optimized at compile time to just copy a pointer?
19:32:20 <shachaf> sentientwaffle: What do you mean?
19:32:24 <djahandarie> Can anyone think of a nice way to do an hGetLine with a 'timeout'? I.e., it can block for up-to 30 seconds, then it gives up.
19:32:28 <shachaf> It's not really "optimized". What else would it do?
19:32:32 <sentientwaffle> shachaf: none of the data is copied
19:32:41 <mauke> sentientwaffle: pointers are data
19:33:01 <shachaf> djahandarie: Use "timeout"?
19:33:03 <sentientwaffle> mauke: right, but say I have a list of ints or something. would that get copied?
19:33:04 <Mortchek> djahandarie, timeout in Data.Timeout
19:33:05 <sm> djahandarie: I suspect one of the console libs on hackage has that
19:33:11 <mauke> sentientwaffle: what does "copied" even mean?
19:33:20 <Mortchek> System.Timeout, sorry
19:33:26 <sentientwaffle> mauke: moved to a new location in memory
19:33:33 <shapr> ddarius: Yah, we're chatting on #scannedinavian at the moment, discussing arduino and raspberry pi
19:33:36 <YayMe_> Those are the types of scenarios where I think functional techniques are far better than imperative, and it's not math based or concurrency based when everywhere you read people say "math and concurrency are the purpose of functional techniques"
19:33:39 <mauke> sentientwaffle: what's a memory?
19:34:04 <ddarius> shapr: I consider getting a Raspberry Pi, but I don't have any monitor or keyboard or mouse ...
19:34:06 <djahandarie> shachaf, ah right, that should work because it's not actually blocking, it's asyncronous behind the scnes.
19:34:33 <shapr> ddarius: You don't need 'em, the occidentalis distro has ssh enabled on first boot.
19:35:00 <ddarius> shapr: Yeah, I know.  That's why I haven't completely ruled it out.  But it's not clear what I would do with it.
19:35:23 <ddarius> shapr: For now I have an FPGA with a radio attached to it.
19:35:28 <shapr> darius and I just figured out how to turn a luminglass into an indicator light.
19:35:39 <shapr> ddarius: ok, that's awesome :-)
19:35:42 <otters> http://hpaste.org/73501
19:36:08 <shachaf> djahandarie: Hmm, I wonder whether reading from stdin is actually non-blocking?
19:37:12 <otters> I think the time complexity is something horrible because it has to check the whole list for each new iteration
19:37:16 <shachaf> Ah, yes. Hmm. I wonder how it gets marked nonblocking.
19:37:36 <donri> is there a fractional type that doesn't permit negative values?
19:39:18 <n00b6502> never heard of such a type, ratios i guess
19:40:05 <n00b6502> uint/uint
19:40:10 <donri> > fromRational $ -1%2
19:40:11 <lambdabot>   -0.5
19:40:19 <parcs`> Ratio Word
19:40:57 <n00b6502> in c++ a fixed point unsigned class
19:41:06 <donri> parcs`: ah
19:41:07 <donri> thanks
19:41:17 <YayMe_> Because of haskell's lazy nature a continuation is more or less pointless, no?
19:41:24 <n00b6502> hah "i've never heaerd of one" but i made one for colour values lol, a fixed-point unsigned class
19:41:36 <donri> YayMe_: continuations are used a lot
19:41:40 <ddarius> @hoogle Fixed
19:41:40 <lambdabot> Data.Fixed module Data.Fixed
19:41:40 <lambdabot> Data.Fixed data Fixed a
19:41:40 <lambdabot> Data.Text.Lazy.Builder.RealFloat Fixed :: FPFormat
19:41:57 <YayMe_> donri: They are managed beneath by the lazy evaluation though?
19:42:02 <otters> anyone? D:
19:42:37 <YayMe_> donri: Except when dealing with multiple threads or other finer grained concurrent techniques, no?
19:42:39 <donri> YayMe_: not sure what you're asking. the Cont monad is implemented in a few lines of code though.
19:42:44 <YayMe_> Oh
19:42:47 <YayMe_> there are continuations
19:42:53 <YayMe_> That's what I was asking
19:43:00 <YayMe_> Sorry :)
19:43:00 <shachaf> Haskell doesn't have first-class continuations.
19:43:02 <shachaf> (On purpose.)
19:43:20 <YayMe_> shachaf: alright, you and donri fight and tell me whose right. I'm confused.
19:43:24 <n00b6502> i was thinking that too, lazy eval reduces a lot of the complexity found elsewhere
19:43:33 <donri> yea, i don't think you can usually implement continuations in a few lines of code in languages that have them first-class
19:43:37 <shachaf> YayMe_: Haskell has a monad for continuations. They're not first-class.
19:43:57 <shachaf> donri: You can implement continuations in a few lines in terms of another primitive.
19:44:00 <YayMe_> shachaf: How do you mean not first-class? Is it particularly useful?
19:44:05 <shachaf> I think that's what they do in Smalltalk.
19:44:37 <shachaf> Who said anything about useful?
19:44:52 <rosie> easy question: why does the state monad "get" function not take any parameters? How does it know which state processor to return? get :: State s s     get s = (s,s)
19:44:58 <YayMe_> I may not understand continuations. I think of continuations as a method of creating coroutines which basically gives the ability to have multiple entry points in a function, which haskells lazy evaluation already has
19:45:06 <shachaf> rosie: I'm not sure what a "state processor" is.
19:45:12 <otters> @src get
19:45:12 <lambdabot> Source not found. stty: unknown mode: doofus
19:45:16 <otters> bah
19:45:17 <rosie> sorry, State s s
19:45:18 <shachaf> rosie: But x :: State s a is just a function :: s -> (s,a)
19:45:38 <YayMe_> Actually I guess lazy evaluation doesn't quite give you multiple entry points to the same function
19:45:38 <shachaf> rosie: I.e., it gets a state as an argument, and returns some value along with a new state.
19:45:53 <shachaf> In this case the "some value" and "new state" are both its argument.
19:45:56 <mauke> YayMe_: neither do continuations
19:46:27 <rosie> Why do I see no argument in: rollDie = do generator <- get ?
19:46:30 <YayMe_> mauke: Then I don't know what continuations are, I equate them with the yield keyword in C#, or the new await keyword in .net 4.5
19:46:39 <YayMe_> mauke: What are they? Please share.
19:46:40 <shachaf> rosie: The argument is passed implicitly.
19:46:48 <shachaf> rosie: By (>>=) or runState or whatever it is.
19:46:56 <mauke> YayMe_: do you happen to know unix?
19:46:57 <shachaf> rosie: The whole point of State is that the state is passed around implicitly.
19:47:24 <YayMe_> mauke: Eh.. I know how to *use* it, I've never done any system level development
19:47:40 <rosie> shachaf: whoa, thanks. Do you know a good article that talks about the mechanism of implicit argument-passing?
19:47:50 <mauke> too bad
19:47:59 <latro`a> it's not really implicit under the hood
19:48:04 <mauke> rosie: it's >>=
19:48:06 <shachaf> rosie: It's not exactly "implicit argument passing".
19:48:07 <latro`a> if you look at the definition of >>= for State you can see why
19:48:16 <YayMe_> mauke: I'm a corporate schmuck
19:48:17 <shachaf> rosie: I think you're approach State backwards.
19:48:53 <shachaf> rosie: I would suggest that you *first* figure out how functions :: s -> (s,a) work and why you want them. Then, as an exercise, take the newtype State s a and write some helper functions for it.
19:49:09 <shachaf> For example, stateMap :: (a -> b) -> State s a -> State s b
19:49:24 <shachaf> And then you can figure out why "get" and "put" have those types. :-)
19:49:40 * shachaf phrased this kind of badly, though.
19:49:42 <mauke> YayMe_: do you know assembler programming?
19:49:53 <YayMe_> mauke: Nope.
19:50:11 <mauke> aww
19:50:55 <mauke> YayMe_: imagine an expression with one of the values taken out and replaced by a hole
19:51:10 <YayMe_> and when it's executed?
19:51:14 <n00b6502> were you about to explain something hakelly in asembler terms?
19:51:17 <mauke> YayMe_: you can take that holey expression and plug a value in and evaluate it and get a result
19:51:17 <n00b6502> were you about to explain something haskelly in asembler terms?
19:51:28 <ddarius> n00b6502: Contiunations aren't "Haskelly".
19:51:29 <mauke> n00b6502: no, just continuations
19:51:55 <ddarius> Also, various patterns in assembly are naturally modelled with CPS.
19:52:06 <n00b6502> CPS=?
19:52:19 <mauke> YayMe_: the holey expression sort of describes the "future" of the value that will be plugged in
19:52:30 <YayMe_> mauke: it's a promise?
19:52:33 <mauke> no
19:52:38 <mauke> it's an expression with a hole in it
19:52:43 <donri> i thought continuations were very "haskelly": used for writing parsers, used by containers IIRC?, used for conduit/pipes...
19:53:02 <parcs`> >>= is sort of like a continuation
19:53:35 <ddarius> Continuation Passing Style
19:53:38 <n00b6502> i usually ask if its like composing and returning a function but i'm usually told it isn't
19:53:47 <djahandarie> Man, why does Network.accept not have an option to just turn off reverse DNS lookups.
19:53:54 <YayMe_> http://msdn.microsoft.com/en-us/library/ee372288.aspx
19:54:34 <mauke> YayMe_: e.g. in '(1 + {}) * 2' the value you plug into {} will have 1 added to it, then it'll be multiplied by 2
19:55:27 <mauke> you can think of function calls like this
19:55:29 <YayMe_> And this is different than a function because when it's a continuation it will be executed later?
19:55:39 <mauke> e.g. (1 + f()) * 2
19:56:14 <rosie> shachaf: Thanks. I'll do that, just one question first: I see how the state gets passed between to functions throughout the bind. I want to know how the state gets passed between state monads when the monads aren't directly chained together with >>=
19:56:18 <mauke> here we call f, but leave the "execution context" (1 + {}) * 2 around
19:56:29 <mauke> whatever value is returned by f will be "plugged in"
19:56:53 <YayMe_> So it's like having an entry point in the function that's right in the middle?
19:56:54 <shachaf> rosie: The word "monad" doesn't mean what you think it means, I think.
19:56:58 <mauke> YayMe_: ... no?
19:57:06 <rosie> shachaf: please explain
19:57:07 <mauke> YayMe_: I don't see where you're getting entry points from
19:57:12 <shachaf> rosie: "State s" is a monad, for some value s. A value of type "State s a" isn't a monad.
19:57:44 <shachaf> rosie: Anyway, I'm not sure I understand your question.
19:58:11 <YayMe_> mauke: your definition of continuation sounds identical to my definition of function.. but I've had it drilled into my head in the past that continuations are for asynchronous programming via what is it.. cooporative multitasking?
19:58:21 <n00b6502> i've never used a language with continuations. in c/c++ its alawys batching up some parameters into a struct/class ..and something else uses it.
19:58:54 <shachaf> @google continuations in c++ with fork
19:58:55 <n00b6502> indeed used for asynchronicity etc..
19:58:55 <mauke> YayMe_: continuations are not for asynchronous programming
19:58:56 <lambdabot> http://mainisusuallyafunction.blogspot.com/2012/02/continuations-in-c-with-fork.html
19:58:58 <YayMe_> n00b6502: C#'s about to get them and the beta of them is out, I've played with them a little and thought I understood them..
19:59:36 <roconnor> YayMe_: delimited or non-delimited?
19:59:37 <rosie> shachaf: alright, so State s gives us a monad that has the power to return a single result (hence the name of monad), and we have the s as a parameter to the value constructor because we set the type of the state. My question is that the definition of (>>=) begins with (>>=) :: State s a -> (a -> State s b) -> State s b   <newline>    processor >>= processorGenerator = State $ \st -> … so we need to get that \st argument from somewhere. Where does i
19:59:37 <rosie> come from?
19:59:38 <n00b6502> similarly use of real threads has had to be limited in my cases. thread pools for dataparallel
19:59:45 <mauke> YayMe_: but did you notice that my example was about returning from a function, not calling into a function?
20:00:05 <mauke> rosie: I'm pretty sure that's not where the name "monad" comes from
20:00:09 <parcs`> @src Cont
20:00:10 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
20:00:15 <n00b6502> continuiations are like being able to return the current locals as a struct?
20:00:21 <shachaf> rosie: That depends. If you "runState x", where x is of type "State Int Char", it'll give you a function :: Int -> (Char,Int)
20:00:29 <shachaf> rosie: You can then give it an Int to start things off.
20:00:32 <frio> quick question because im lazy: is the State monad for implementing State machines?
20:00:36 <YayMe_> mauke: Yes, but after the function returns, it's going to re-enter the function that did the returning right at that return point later on and then return again after that, no?
20:00:41 <roconnor> frio: not really
20:00:51 <frio> cool roconnor, thanks :)
20:00:59 <mauke> YayMe_: no
20:01:02 <YayMe_> mauke: http://blogs.msdn.com/b/abhinaba/archive/2005/08/11/450785.aspx is this not a continuation? (I know you may not know C#, but it should be pretty clear..)
20:01:12 <roconnor> frio: it probably is possible to implement state machines with the state monad, but that isn't really their raison d'etre
20:01:15 <rosie> mauke: you're right, my apologies
20:01:35 <parcs`> instead of returning an 'a', a continuation returns an '(a -> r) -> r'. that is, a continuation returns a function that, given a function that does something with an 'a' and returns an 'r', returns an 'r'
20:01:57 <parcs`> so, like, control is inverted, and stuff
20:02:14 <frio> cool roconnor :)
20:02:35 <mauke> YayMe_: "However in continuation this is not what happens. Here the state of the function is preserved and when you call back on the function it starts off from where it left off." <- that sounds more like generators
20:02:48 <mauke> using "yield", etc
20:02:57 <YayMe_> parcs`: I understand what you're saying, however it turns out then that what I have been taught by C# are continuations, are in fact not
20:03:05 <n00b6502> yield is nice in game scripting..
20:03:20 <YayMe_> mauke: Precisely.  yes, I understand generators to be a purpose of continuations.. but I guess they are not
20:03:21 <ddarius> Generators are somewhat related to continuations, but they certainly aren't continuations themselves.
20:03:22 <roconnor> mauke: sounds like coroutines
20:03:29 <parcs`> the power of the continuation comes from the callee having control of the 'future' of a computation, instead of the caller
20:03:31 <mauke> roconnor: yeah
20:03:52 <roconnor> mauke: in fact, I might describe coroutines with exactly that language.
20:04:10 <YayMe_> Is this a true continuation then? http://msdn.microsoft.com/en-us/library/ee372288.aspx
20:04:19 <n00b6502> these are useful in stateful web programming ?
20:04:55 <n00b6502> which possibly gets longwinded in c++, building lots of temporary structs
20:04:57 <YayMe_> I think so.. the task is the expression with your hole, and then you can see the hole is later filled I think?
20:05:00 <shachaf> Generators are closer to coroutines than to continuations, I think.
20:05:53 <YayMe_> shachaf: and yeah, I understand coroutines too but again associated generators very closely with continuations and thought continuations were the technique by which you create a coroutine (or a generator which creates a coroutine)
20:06:17 <YayMe_> I guess continuations are greater in functionality than I was giving them credit for
20:06:28 <mauke> YayMe_: this looks like manual CPS (done with lambdas) and some async/threads integration
20:06:28 <shachaf> YayMe_: If anything the other way around is probably a bit more reasonable, I think.
20:06:29 <ddarius> Powerful enough forms of yield are equivalent in power to delimited continuations.
20:06:44 <shachaf> ddarius: Powerful enough how?
20:07:00 <ddarius> @google "Yield: Mainstream Delimited Continuations"
20:07:03 <lambdabot> http://parametricity.net/dropbox/yield.subc.pdf
20:07:03 <lambdabot> Title: Yield: Mainstream Delimited Continuations
20:07:46 <ddarius> A lot of people confuse programming in CPS and first-class continuations for reasons I don't fully comprehend.
20:07:58 <rosie> shachaf: thanks! I see that we do start off the state monad with a starting value. In "return" functions, how do we know in which constructor we should wrap the value?
20:08:08 <shachaf> rosie: ?
20:08:23 <shachaf> "wrap"?
20:08:29 <ddarius> Admittedly, "continuation" is massively overused and abused, so it's not surprising.
20:08:31 <YayMe_> ddarius: I found this library before which uses yield to create coop multitasking, is this what you mean: http://easyasync.codeplex.com/
20:08:32 <parcs`> ddarius: what do you mean?
20:08:45 <parcs`> (confusing cps and first-class continuations)
20:09:08 <ddarius> parcs`: If I wrote some state passing code, would you describe that code as using mutable state?
20:09:28 <parcs`> probably not
20:09:39 <rosie> shachaf: for example, how does the "return value" in this code: http://hpaste.org/73502 know it should wrap value in a GeneratorState? ah, is it the return type of the function?
20:10:02 <shachaf> rosie: I don't know what GeneratorState is.
20:10:08 <shachaf> rosie: But yes, that's just type inference.
20:10:29 <mauke> rosie: you could remove line 1 and it'd infer from randomR
20:10:36 <mauke> and get/put, obviously
20:10:37 <shachaf> rosie: What introduction are you reading here?
20:10:51 <shachaf> mauke: Infer what from randomR?
20:10:52 <shachaf> @ty randomR
20:10:54 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
20:10:55 <ddarius> The other thing I see a lot of is calling everything that even remotely looks like (a -> r) -> r "CPS".
20:11:07 <mauke> shachaf: constraints on generator/newGenerator
20:11:29 <YayMe_> ddarius: CPS is "not first-class continuations" as opposed to "first-class continuations" ?
20:11:53 <mast`> I posted this on reddit's university of reddit 'request board' about finding someone to teach a math-related haskell class, thought maybe someone here would be interested http://redd.it/yj6lm
20:12:22 <YayMe_> What languages have "first-class continuations" or has them easily/often used so I can maybe understand them in their native landscape (like understanding currying is far easier in haskell than through some mangled curry function in javascript)
20:12:34 <rosie> shachaf: http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State   Why do you say you think it would infer randomR?
20:12:43 <mauke> YayMe_: scheme
20:12:52 <ddarius> CPS is a way of modelling ("implementing") first-class continuations, much like state passing is a way to model mutable state.  Unfortunately, both are global transformations and thus you lose a lot of the power of actually having the feature.
20:12:57 <YayMe_> mauke: Time for the little schemer I guess
20:13:02 <shachaf> If anything "continuations" might be easier to understand when they're not first-class.
20:13:09 <mauke> YayMe_: and unix, in a weird sense
20:13:10 <ddarius> YayMe_: Scheme is the archetypical example.
20:13:13 <YayMe_> mauke: What's the easiest best way to quickly get scheme up and going on a windows box?
20:13:17 <mauke> YayMe_: no idea
20:13:18 <shachaf> YayMe_: Lots of other languages have them.
20:13:30 <parcs`> mauke: how does unix have first class continuations?
20:13:42 <YayMe_> Anyone know the easiest best way to get scheme up and going on a windows box? Or know of an online scheme repl?
20:13:45 <mauke> parcs`: not quite first class
20:13:55 <ddarius> YayMe_: There are tons of online scheme repls.
20:13:58 <mauke> parcs`: but the way the kernel treats processes is very continuationy
20:14:03 <YayMe_> I've read of the little schemer so much I figure it's time I try my hand
20:14:19 <ddarius> YayMe_: PLT Scheme, now known as Racket, is probably the most featureful implementation of Scheme around and I believe it has installers for Windows.
20:14:20 <YayMe_> (it is free online, no?)
20:14:25 <mauke> parcs`: processes waiting to be scheduled are continuations
20:14:29 <shachaf> mauke: With the exception of fork(), it's mostly coroutiney.
20:14:31 <ddarius> @where sicp
20:14:32 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | "Structure and Interpretation of Computer Programs"
20:14:34 <mauke> parcs`: system calls pretend to be functions, but aren't
20:14:54 <ddarius> @google "Threads Yield Continuations"
20:14:57 <lambdabot> http://www.cs.indiana.edu/~dyb/pubs/LaSC-10-3-pp223-236.pdf
20:14:57 <mauke> parcs`: fork() invokes its continuation twice; _exit() doesn't invoke it at all
20:14:57 <lambdabot> Title: Threads yield continuations∗
20:18:27 <parcs`> mauke: what are system calls if not functions?
20:18:36 <mauke> parcs`: magic
20:19:04 <YayMe_> mauke: Whoa.
20:19:17 <parcs`> at least you didn't say 'continuations'
20:19:20 <mauke> do you really think you can enter the kernel with a simple 'call' instruction from userspace?
20:19:41 <parcs`> i don't know, maybe
20:19:45 <shachaf> call, syscall, what's the difference?
20:20:07 <ddarius> mauke: You could if you went through a call gate.
20:20:16 <mauke> ddarius: ah, but I don't know what that is
20:20:20 <ddarius> But arguably that, itself, would be a "simple call".
20:20:25 <ddarius> s/would/wouldn't/
20:20:51 <ddarius> http://en.wikipedia.org/wiki/Call_gate
20:21:08 <mauke> .oO( colgate )
20:21:10 <BMeph> YayMe: Try racket-lang.org for Racket stuff
20:21:11 <BMeph> .
20:22:31 <shachaf> Early versions of Windows did system calls by executing an illegal instructions.
20:23:30 <mauke> "With the introduction of SYSENTER/SYSEXIT and SYSCALL/SYSRET, a new faster mechanism was introduced for control transfers for x86 programs."  "Upon comparing call gates to interrupts, call gates are significantly faster."
20:23:36 <mauke> cool story, wikipedia
20:24:31 <shachaf> mauke: SYSCALL and SYSENTER aren't interrupts.
20:24:53 <mauke> shachaf: and I know this how?
20:25:15 <mauke> (the last sentence appears completely unmotivated after two paragraphs about SYSENTER)
20:25:44 * hackagebot simple-actors 0.4.0 - A library for more structured concurrent programming, based  on the Actor Model  http://hackage.haskell.org/package/simple-actors-0.4.0 (BrandonSimmons)
20:25:55 <ddarius> mauke: Because the parts were very likely written by different people.
20:26:44 <shachaf> mauke: As far as I can tell, that paragraph is saying that: SYSCALL and SYSENTER only work for ring3<->ring0. Interrupts (presumably) work for more than that, as do call gates. Therefore, if you want something other than ring3<->ring0, call gates are still preferrable to interrupts.
20:27:47 <mauke> then why does linux use interrupts?
20:27:54 <shachaf> It doesn't.
20:28:08 <shachaf> Well, on the AMD64 ABI Linux uses "syscall".
20:28:13 <mauke> sure it does
20:28:20 <mauke> int $128
20:28:30 <shachaf> Interrupts are still supported.
20:28:35 <mauke> yes
20:28:45 <mauke> and they were the only method before linux-gate.so
20:28:49 <shachaf> But if you call a glibc function that does a syscall, it'll use "syscall".
20:29:03 <shachaf> mauke: No, on AMD64 you don't use linux-gate.so for system calls at all.
20:29:29 <mauke> I'm referring to x86 only
20:29:30 <tmiw> so i have a cabal package that yesod autogenerated. how do i programmatically grab the version number of the package from the haskell code?
20:29:33 <shachaf> The SYSCALL instructions are hard-wired into code that does syscalls (I'm pretty sure, at least).
20:29:42 <tmiw> (I mainly want to print xxxxxxx v1.0.0.0 on the bottom of webpages)
20:29:50 <shachaf> mauke: Oh. Whose x86?
20:30:03 <mauke> shachaf: huh?
20:30:09 <shachaf> AMD or Intel?
20:30:19 <mauke> does it make a difference?
20:30:21 <shachaf> Yes.
20:30:25 <mauke> where?
20:30:29 <shachaf> AMD introduced SYSCALL, Intel introduced SYSENTER.
20:30:38 <shachaf> x86 CPUs generally support one or the other.
20:30:51 <mauke> ok, and?
20:30:54 <shachaf> linux-gate.so is used to do fast system calls.
20:31:03 <mauke> what is your point?
20:31:17 * shachaf is confused.
20:31:39 <shachaf> You asked why Linux uses interrupts.
20:31:48 <mauke> yes
20:32:08 <shachaf> If you compile a C program that links against glibc, and do a read() call in it, it won't use an interrupt.
20:32:20 <mauke> irrelevant
20:32:31 <mauke> if I use int $128 in a linux program, it'll work
20:32:41 <shachaf> Oh. Backwards compatibility?
20:32:49 <mauke> missing the point
20:33:02 <shachaf> I must be.
20:33:08 <mauke> interrupts were the only mechanism at some point
20:33:17 <mauke> that's why they're still there
20:33:27 <mauke> but why interrupts in the first place?
20:33:28 <shachaf> Right.
20:33:44 <shachaf> Oh, well, you have to have *some* special mechanism for switching to kernel mode.
20:33:53 * shachaf didn't dispute that.
20:33:54 <mauke> how about call gates?
20:34:04 <mauke> I heard they're still preferrable to interrupts
20:34:24 <maurer> mauke: Used to be. iirc x86_64 doesn't support callgates?
20:34:34 <shachaf> Ah. Then your question is "Why did Linux choose interrupts back in the day?"?
20:34:55 <mauke> hmm. yes.
20:35:14 <shachaf> I don't know why they chose it.
20:35:35 <ddarius> Probably a combination of portability, not really caring at the time, backwards compatibility, and the fact that interrupts are more convenient (and definitely smaller code space-wise) than far calls.
20:36:42 <ddarius> I forget if there are any real differences between cross privilege level interrupts and call gates, but under same-privilege level situations, interrupts push more information on the stack allowing you to do more with an interrupt return.
20:37:08 <ddarius> Which brings another reason to use an interrupt, you can reuse the interrupt returning code that you'll have to write for actual hardware interrupts anyways.
20:41:58 <ddarius> Checking the manuals, it does look like even interprivilege calls through a call gate don't push EFLAGS as an interrupt would.
20:43:13 <ddarius> The main benefit of a call gate is you can directly pass parameters.  The best way to use call gates would be to give various system calls their own call gates rather than having a giant dispatch through a single hook, but I imagine that that's more hassle (and less portable) then most feel like dealing with.
20:49:12 <ybit> what does the <> symbol do?
20:49:22 <mauke> nothing much
20:49:22 <ddarius> Whatever it's defined to do.
20:49:30 <Ralith> name a value
20:49:43 <ybit> is there a way to find out through ghci?
20:49:47 <shachaf> :i
20:49:55 <ybit> it's been awhile since i've touched haskell :|
20:50:18 <ybit> curious what ~ does
20:50:27 <ybit> the differences between => and ->
20:50:41 <ybit> what the @ symbol does
20:51:03 <shachaf> ybit: You should read an introduction instead of IRC.
20:51:14 <shachaf> @where lyah
20:51:14 <lambdabot> http://www.learnyouahaskell.com/
20:52:05 <mauke> just hanging out, having a beer
20:53:06 <ybit> shachaf: not wanting to do that again
20:53:14 <ybit> more so curious how to find this through ghci
20:53:28 <nand`> GHCi won't explain what ~, =>, -> and @ do
20:53:30 <shachaf> ybit: ghci will tell you about operators, but it won't tell you about syntax.
20:53:54 <ybit> shachaf: how can you get it to tell you about operators?
20:54:10 <nand`> like he said, :i works
20:54:13 <ybit> done
20:54:14 <ybit> thanks
20:54:45 <Mortchek> :t (->)
20:54:46 <lambdabot> parse error on input `->'
20:55:02 <ybit> parse error on :i -> and => as well
20:55:05 <ybit> and ~
20:55:07 <nand`> those aren't operators
20:55:11 <ybit> but it works on say.. >>
20:55:11 <Mortchek> :i (->)
20:55:15 <ybit> ah
20:55:16 <nand`> >> is an opreator
20:55:18 <nand`> operator*
20:55:21 <mauke> <shachaf> ybit: ghci will tell you about operators, but it won't tell you about syntax.
20:55:47 <ybit> mauke: i take it that's you telling me ~ is syntax
20:55:51 <ybit> and not an operator
20:55:52 <ybit> :)
20:55:54 <nand`> yes
20:56:07 <mauke> I take it that's you telling me you have no idea what's an operator and what's syntax
20:56:20 <mauke> and you don't like to read
20:57:21 <ybit> been awhile since i've used it
20:58:12 <OceanSpray> is there something like a foldZipWithM function
20:58:38 <OceanSpray> or, more specifically,
20:58:46 <OceanSpray> a fold1zipWithM function
20:59:27 <nand`> foldZip?
20:59:29 <Ralith> ybit: read the intro.
20:59:46 <OceanSpray> @hoogle (a -> b -> c -> a) -> a -> [b] -> [c] -> a
20:59:47 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
20:59:47 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
20:59:47 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
21:00:15 <OceanSpray> it seems not
21:02:11 <mauke> :t \f z xs ys -> foldl f z (zip xs ys)
21:02:12 <lambdabot> forall a a1 b. (a -> (a1, b) -> a) -> a -> [a1] -> [b] -> a
21:02:40 <mauke> :t \f z xs ys -> foldl (uncurry . f) z (zip xs ys)
21:02:41 <lambdabot> forall a b c. (c -> a -> b -> c) -> c -> [a] -> [b] -> c
21:03:06 <mauke> @pl \f z xs ys -> foldl (uncurry . f) z (zip xs ys)
21:03:07 <lambdabot> flip flip zip . (((.) . (.)) .) . foldl . (uncurry .)
21:05:20 <nand`> :t flip (.:) zip .: (foldl . (uncurry.))
21:05:21 <lambdabot> forall a b c. (c -> a -> b -> c) -> c -> [a] -> [b] -> c
21:05:51 <Nereid> @type flip flip
21:05:53 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
21:05:57 <dmead> hello channel
21:05:59 <Nereid> @type Prelude.flip Prelude.flip
21:06:01 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
21:07:11 <dmead> @seen cale
21:07:12 <lambdabot> Unknown command, try @list
21:07:16 <parcs`> @type let x = flip flip flip flip flip in x `asTypeOf` x flip `asTypeOf` x flip flip `asTypeOf` x flip flip flip
21:07:18 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b b1. (Functor f1, Functor f) => f ((f1 (a -> b) -> a -> f1 b) -> b1) -> f b1
21:09:51 <nand`> it just occurred to me that (Data.Bits..|.) can look fairly inappropriate when not qualified
21:11:45 <Jafet> @quote 0xb
21:11:46 <lambdabot> Jafet says: > (.)(.) id const succ 5$ 0xb00b135
21:13:55 <Veinor> > (.)(.) id const succ 5$ 0xb00b135
21:13:58 <lambdabot>   6
21:34:33 <kanzure> join #slic3r
21:34:37 <kanzure> oops. please ignore me.
21:40:49 <Dustin_> Is lambdabot an actual bot?
21:42:39 <permagreen> No, it's just someone who can evaluate haskell code really fast in their head
21:42:49 <Mortchek> > const True "Are you a bot?"
21:42:50 <lambdabot>   True
21:43:53 <Dustin_> yeah it's obvious he/she's not a bot given his comment at 00:11
21:44:28 <Jafet> I believe Cale hasn't yet performed the Voight-Kampff test.
21:44:43 <Mortchek> Dustin_, you mean when someone invoked the @google function?
21:45:01 <Mortchek> (I don't know what timezone you're in.)
21:45:39 <Dustin_> EST
21:46:06 <Mortchek> So, when lambdabot evaluated that Haskell expression given to it?
21:46:41 <Mortchek> I don't seee how that proves it's not a bot.
21:46:52 <mast`> It is a bot
21:47:10 <Mortchek> Right, I'm just responding to < Dustin_> yeah it's obvious he/she's not a bot given his comment at 00:11
21:47:51 <Dustin_> If lambdabot is a bot, he's the best bot I've ever seen
21:47:54 <Jafet> A copy of GHC HEAD doesn't actually work until you add your own faerie to it
21:48:03 <Jafet> And other little-known facts
21:48:06 <Mortchek> Dustin_, how do you figure?
21:48:24 <Dustin_> But then he said at 00:11 something a bot would never say
21:48:33 <Mortchek> Dustin_, what was that?
21:48:50 <Dustin_> He said "Jafet says: > (.)(.) id const succ 5$ 0xb00b135"
21:49:07 <mast`> @quote 0xb
21:49:07 <ddarius> Jafet: Make sure to grind your faerie into faerie dust first.
21:49:08 <lambdabot> Jafet says: > (.)(.) id const succ 5$ 0xb00b135
21:49:10 <Mortchek> Dustin_, that was in response to Jafet invoking the @quote function.
21:49:15 <Jafet> She's a perverted little thing, eh.
21:49:36 <mk> that quote should be deleted
21:50:05 <Dustin_> Oh
21:50:27 <ddarius> @wn impute
21:50:28 <lambdabot> *** "impute" wn "WordNet (r) 3.0 (2006)"
21:50:29 <lambdabot> impute
21:50:29 <lambdabot>     v 1: attribute or credit to; "We attributed this quotation to
21:50:29 <lambdabot>          Shakespeare"; "People impute great cleverness to cats"
21:50:29 <lambdabot>          [syn: {impute}, {ascribe}, {assign}, {attribute}]
21:50:30 <lambdabot> [3 @more lines]
21:50:58 <Mortchek> That's handy.
21:52:31 <Dustin_> I remember when I had just barely started Haskell and was using it for an academic paper on functional programming and lambdabot helped me, he knew the answer before anybody else, and I was like "wow, that was eerie, is this a bot???" And I had asked the question in plain english and lambdabot knew the answer like 2 seconds later. But I had my paper to write so I couldn't focus on the question of lambdabot.
21:52:54 <jmcarthur> what did you ask?
21:52:57 <Dustin_> *question on how to program in a specific thing
21:53:20 <Dustin_> I don't remember off the top of my head
21:53:28 <mast`> maybe someone extracted the info from your question and had the bot give it a go
21:54:01 <Dustin_> Maybe...
21:54:17 <Mortchek> Nonetheless, that fateful day had changed Dustin_'s life for all eternity.
21:55:09 <mk> yes, the paper got written much faster than it otherwise would have
21:55:18 <Mortchek> Yeah, 'swhat I meant. :)
21:56:36 <Dustin_> Oh, how I wish I had screenshotted it. My research field is AI and I've been more skeptical in recent years that we'll ever reach "smart AI", but lambdabot  I think is the closest bot to actual intelligence, and I'm not just saying that
21:57:07 <mk> Dustin_: grep your logs
21:57:30 * zachk mutters about cleverbot being as smart as a smalls subset of 14 year old females whilst using txting....
21:57:43 <zachk> small even :-D
21:57:49 <mk> Dustin_: I'm not sure why you say that. Doesn't it just parse expressions, and perform various trivial lookups?
21:58:22 <Mortchek> Cleverbot has no sense of self. Its sense of identity comes from those it converses with.
21:58:51 <Mortchek> I mean, it basically just parrots back things it's heard before verbatim.
21:58:51 <mk> zachk: as opposed to the substantially more intelligent 14-year-old males?
21:58:52 <Dustin_> I think it's because of the way we humans think. Maybe the way we think is really similar to how functional programming works.
21:58:54 <zachk> do I need to rehash the subset of the population I just referenced... o_o oh wait maybe that was maybe already recursively implied by mortcheck
21:58:55 <nand`> Mortchek: but maybe it's just that which gives it an identity? :)
21:59:17 <Mortchek> I like to think even 14-year-olds are wiser than that. :P
21:59:19 <mk> Dustin_: it isn't
21:59:32 <zachk> hey when I was that age I used to argue predestination with men who turned out latter to be aduleteres....
21:59:50 <zachk> aduleters evenfss i can no longer spell I Quit
22:00:11 <Dustin_> I'm going to look at my paper again and try that question with it again, that will shed light on the matter.
22:00:19 <zachk> which question?
22:00:50 <zachk> if you can get a bot to discuss the five points of calvinism with someone, you might be able to drag us forward into the future....
22:01:08 <mk> Dustin_: just check the logs
22:01:33 <nand`> the logs of this channel are public
22:01:49 <zachk> it involves tulip(s) or something, which of course applies to the tulip bubble in holland.....uhhh wait didnt calvin argue for usury not being a sin....did this theology possibly lead to the infamous tulip bubble....
22:01:55 * zachk shudders
22:01:59 <zachk> are blahs?
22:02:18 <nand`> if you can discern the date then we can figure out whether it was a dream or if lambdabot accidentally turned into skynet
22:02:27 <Dustin_> sorry, I don't know how
22:02:48 <zachk> that is eschatology or possibly dispensationalism, not even close to predestination nand.... :D
22:03:37 <EvanR2> why is my program which is doing nothing but blocking on a few mvars forever using 0.6% cpu
22:03:44 <mk> the date of the comment that Dustin_ made
22:03:53 <zachk> predestination is more like the homotopy of souls, being partitioned into only two sets at a positive infinite point on the time axes
22:03:55 <Dustin__> grep logs
22:04:15 <Dustin__> (sorry, the window froze)
22:04:20 <zachk> EvanR2: because blocking can be really expensive because your program might be polling and do alot of syscall nonsense....
22:04:26 <mk> Dustin_: find your log file, open it in your favorite text editor, search for your own name
22:04:36 <EvanR2> zachk: eh? its not doing anything
22:04:38 <zachk> s/do/doing...
22:04:42 <permagreen> If lambdabot was realy so great, it ought to be able to check to logs for you
22:04:49 <zachk> or so you thik from your ivory tower
22:04:59 <EvanR2> since when is blocking polling
22:05:03 <zachk> no idea
22:05:05 <zachk> look close
22:05:06 <mk> lambdabot: what has Dustin_ asked you?
22:05:08 <EvanR2> :|
22:05:12 <zachk> really close if you can
22:05:32 <zachk> there has be crazy syscalls nonsense, or something else , possibly in the RTS
22:05:45 <EvanR2> gc might explain it
22:05:46 * zachk is completely making this up.... 
22:05:56 <EvanR2> but why gc when nothing is happening
22:06:01 <mk> that ibm jeopardy computer would have given us an answer
22:06:02 <zachk> because something is happening
22:06:12 <zachk> what was that things name/title anyways
22:06:14 <EvanR2> im not using any ffi libs
22:06:23 <zachk> are you in IO ?
22:06:31 <EvanR2> blocking on MVars, yes
22:06:39 <EvanR2> hmm, im using acid state
22:06:44 <zachk> try twiddling the RTS
22:06:56 <EvanR2> maybe its spawning some polling shit
22:07:04 <zachk> could be, no idea, is that any good? ive looked at it, that is from the happstack isnt it?
22:07:21 <EvanR2> happstack state used to be
22:07:25 <EvanR2> now its acid state
22:07:25 <zachk> 0.6 might be a decent tradeoff for a somewhat optimal system under a decent load
22:07:36 <EvanR2> theres no load >_<
22:07:41 <zachk> yea it is what is now used in happstack
22:07:44 <zachk> no I am saying
22:08:03 <zachk> having the weird cpu usage, could be an optimal solution for something that goes under heavy load
22:08:17 <EvanR2> thats silly
22:08:33 <zachk> might increases responsiveness
22:08:37 <zachk> increase
22:09:16 <EvanR2> polling generally reduces responsiveness
22:09:20 <zachk> would you take a 2.5% hit to your IQ to double your response speed under stress to intelligent questions?
22:09:26 <zachk> blocking is better?
22:09:38 <zachk> if you mess up blocking it can completely stall
22:10:18 <EvanR2> ill ask the acidstate dude next time i see him i suspect its him
22:10:21 <zachk> also if you attempting to have a "smooth" system (say a twitchy shooter) an even sense of lag might be prefered to most users
22:10:28 <zachk> how big is it?
22:11:01 <EvanR2> were not doing fps or frp its just a server responding to sockets
22:11:05 <Dustin__> Ok, I looked at the logs, it was rtharper who actually answered my question, not lambdabot. I must have just misremembered (I was really stressed about getting my paper in on time. All lambdabot really did was evaluate the expression that rtharper gave).
22:11:38 <EvanR2> the rts internally uses select or epoll to block on handles
22:11:42 <zachk> wait, is rtharper secretly a tachyon transmitted version of future lamdbabots?
22:12:11 <zachk> was not polling, long ago, better for responsiveness?
22:12:16 <zachk> 80's maybe./....
22:12:34 <Dustin__> how do you change your name on this?
22:12:41 <zachk>    /nick usually
22:12:41 <nand`> /nick
22:13:58 <zachk> would going to a zen buddhis monastery so some in/nonoperable hernias have time to heal good be a wise idea?
22:14:42 <zachk> no heavy work, practice posture and breathing.... mmmmm
22:16:24 <EvanR2> zachk: ghc concurrent runtime is different from interprocess communication and old style graphics stuff
22:16:38 <EvanR2> i dont know the details though
22:24:50 <tmiw> so it looks like the Paths_* module that cabal makes is what i want. unfortunately when i import it i get stuff like
22:24:53 <tmiw> dist/build/autogen/Paths_4peas.hs:10:12:
22:24:53 <tmiw> :(
22:24:56 <tmiw>     Not in scope: type constructor or class `IO'
22:25:13 <tmiw> isn't IO in Prelude?!
22:25:48 <nand`> maybe you were using -XNoImplicitPrelude or importing Prelude () ?
22:25:49 <scshunt> yes, but Prelude doesn't have to be imported
22:26:14 <mauke> post dist/build/autogen/Paths_4peas.hs
22:26:15 * hackagebot http-types 0.7.3 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.7.3 (AristidBreitkreuz)
22:27:52 <tmiw> mauke: http://hpaste.org/73508
22:28:12 <tmiw> the rest of the code is at https://github.com/tmiw/4peas
22:28:45 <mauke> NoImplicitPrelude
22:28:51 <mauke> there you go
22:29:42 <tmiw> ah, there it is in the .cabal file
22:29:57 <tmiw> i'm getting another error, but that's all on me now
22:29:57 <tmiw> thanks
22:30:05 <tmiw> :)
23:26:42 <mm_freak_> somehow it's more convenient to define monad transformers in terms of Free instead of FreeT
23:27:05 <mm_freak_> with FreeT there is lots of wrapping going on for essentially the same effect
23:28:03 <johnw> mm_freak_: interesting; I hadn't looked at FreeT yet
23:28:42 <johnw> mm_freak_: remember that GitHub issue where I suggested arrows?  I updated with a new suggestion to use Free
23:29:36 <mm_freak_> johnw: so back to monads?
23:30:26 <johnw> i'm just proposing alternatives
23:30:56 <johnw> and since Monads are arrows, I really don't lose anything
23:31:34 <shachaf> What's does that mean?
23:31:50 <mm_freak_> johnw: you do
23:31:56 <shachaf> "Monads are functors" too.
23:32:07 <mm_freak_> johnw: every monad gives rise to an arrow, but the converse is not true
23:32:13 <mm_freak_> in particular your arrow is not a monad
23:32:16 <johnw> it means if I want to make my own little predicate library on top of a Free solution using arrow notations and such, I'm free to do so
23:32:22 <shachaf> The whole *point* of using Arrow instead of Monad is that you lose some things.
23:32:28 <johnw> mm_freak_: my arrow wasn't a monad, true; but the Free monad I proposed can become an arrow, can't it?
23:32:38 <mm_freak_> no
23:32:41 <mm_freak_> well, yes
23:32:49 <mm_freak_> of course it can become a Kleisli arrow
23:32:53 <johnw> exactly
23:33:02 <mm_freak_> but you can't have the static information there
23:33:06 <johnw> no
23:33:17 <johnw> the optimization will have to move into the Free interpreter
23:33:34 <mm_freak_> the interpreter can't perform the optimization
23:33:46 <mm_freak_> you need to actually run the action to find out whether you need to stat
23:33:50 <johnw> shachaf: it's more that Greg didn't like arrow syntax
23:34:01 <mm_freak_> also you don't need arrow syntax
23:34:10 <mm_freak_> i mostly use Category+Applicative
23:34:20 <Guest72069> :t fmap
23:34:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:34:23 <mm_freak_> liftA2 f (a2 . a1) (b2 . b1)
23:34:24 <mm_freak_> etc.
23:34:33 <johnw> mm_freak_: I can make a pre-pass interpreter :)
23:34:49 <johnw> although, I don't think it's necessar
23:34:51 <johnw> y now
23:35:00 <mm_freak_> johnw: that's certainly possible, as long as your action doesn't depend on side effects
23:35:29 <johnw> I would prefer to avoid side effect dependency if at all possible
23:35:38 <johnw> I like that the Free predicates are independent of the Sh monad
23:35:54 <johnw> the arrow solution still has "Sh Bool" as the output type
23:36:05 <mm_freak_> that's your own choice
23:36:12 <johnw> shachaf: just to be clear, what exactly do I lose?
23:36:17 <OceanSpray> @hoogle (Functor f, Functor g) => (a -> f b) -> g a -> f (g b)
23:36:18 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:36:18 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
23:36:19 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
23:36:25 <mm_freak_> johnw: you lose the static information
23:36:39 <johnw> shachaf said the reason to use Arrows is that I lose something
23:36:43 <johnw> I don't think it was that
23:36:48 <mm_freak_> yes, it's that
23:36:52 <mm_freak_> for the arrow the static information is a composition effect
23:37:11 <johnw> aren't you reversing the meaning?
23:37:15 <johnw> arrows _give_ me the static information
23:37:20 <johnw> I don't lose it
23:37:27 <johnw> he said the point of arrows is that you lose something
23:37:42 <mm_freak_> if you move from the arrow to a monad you're definitely /losing/ the static information
23:37:54 <johnw> yeah, and moving from the monad to arrows I lose...
23:38:19 <mm_freak_> well, in that direction you lose the power of (>>=)
23:38:44 <mm_freak_> you have to decide between the expressiveness of (>>=) and the static information
23:39:01 <johnw> shachaf made it seem like there was a beneficial loss
23:39:09 <mm_freak_> that's subjective
23:39:14 <johnw> I know that I lose the infectiousness of monads
23:39:27 <mm_freak_> "infectiousness"?
23:39:46 <johnw> I have to lift everything into the monad to call it
23:39:52 <johnw> or use the monad return type everywhere
23:39:57 <mm_freak_> that's the same for the arrow
23:40:01 <johnw> oh, hmm
23:40:09 <mm_freak_> for every functor in fact
23:40:53 <mm_freak_> let me tell you:  it's not very smart to move from Monad to Arrow…  if you have a Monad anyway you should make use of the monadic interface
23:43:42 <paolino> where can I get these galsses to see categories ?
23:43:52 <paolino> *glasses
23:44:00 <mm_freak_> paolino: just know what a category is
23:44:06 <johnw> look for them in the category of things that help one see ;)
23:45:53 <johnw> shachaf: still there?
23:46:38 <paolino> johnw, that category has been recently emptied, I suspect mm_freak_
23:46:44 <mm_freak_> paolino: look at your friends in a simplified model…  when friend A is at least as smart/old/whatever as friend B, then there is an arrow from friend B to friend A
23:46:57 <mm_freak_> paolino: every friend is at least as smart/old/… as himself
23:47:07 <mm_freak_> so there is always an arrow from A to himself
23:47:36 <mm_freak_> continue this to verify that this is indeed a category, where the objects are your friends and the morphisms are smartness/age relations
23:48:19 <mm_freak_> it gets interesting when you find an endofunctor from age to smartness =)
23:48:25 <paolino> ok, a coffee before I start looking them so strangely
23:49:05 <mm_freak_> CT is really interesting…  i'm a beginner myself, but i'm starting to value its usefulness as an abstract language
23:49:55 <nand`> looks like a poset category
23:49:57 <mm_freak_> paolino: this one is a fun read:  http://www.haskellforall.com/2012/08/the-category-design-pattern.html
23:50:00 <mm_freak_> nand`: it is
23:50:46 <johnw> thanks for the article link
23:50:52 <shachaf> johnw: ?
23:50:54 <johnw> my kindle is filling up fast
23:51:32 <johnw> shachaf: you said "The whole *point* of using Arrow instead of Monad is that you lose some things."  Can you clarify please?
23:55:47 <ddarius> johnw: You lose context-sensitivity.  You gain context-insensitivity.
23:56:29 <johnw> i think that relates to what I meant about infectiousness (although a bad choice of term)
23:57:35 <mm_freak_> johnw: i'm pointing out again that what you want is a category and an applicative functor
23:57:50 <johnw> mm_freak_: and some day, I might understand what you mean by saying that
23:58:07 <mm_freak_> simply that you can write Category and Applicative for it
23:58:20 <mm_freak_> and i suggest again that you try to do it
23:58:43 <johnw> i need an example of how what you're saying changing the way I do things in some way
23:59:05 <mm_freak_> what do you want to do?
23:59:11 <johnw> like the find predicate example
23:59:32 <mm_freak_> it's just a function that knows which files to access, correct?
