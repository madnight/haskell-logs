00:00:11 <edwardk> this gives us a rose tree
00:00:11 <edwardk> a :< [] or a :< [b :< [], c :< [], … ] or
00:00:27 <edwardk> so we can now have an arbitrary number of children for each element
00:00:38 <edwardk> :< is the 'Node' constructor from Data.Tree then
00:00:59 <edwardk> basically every node has a value and a list of children
00:01:15 <edwardk> it doesn't even need to be a data structure per se
00:01:27 <edwardk> consider when f = (->) b!
00:01:52 <edwardk> a :< (b -> (a :< (b -> (a :< ...
00:02:20 <edwardk> you have some value for the current state 'a', then you feed it a 'b' and you get a new value for the current state 'a', and you feed it a b, etc.
00:02:30 <edwardk> this is Moore machine.
00:02:59 <amiller> i follow that example
00:03:27 <edwardk> all we needed to make the comonad was the knowledge that f was a functor
00:03:48 <edwardk> so lets look at your data Trunk e x = Leaf e | Bin x x
00:03:50 <johnw> edwardk: is all of this goodness documented somewhere?
00:04:09 <edwardk> johnw: i've done this shpiel on here a few times over the years ;)
00:04:12 <randomclown> is there a way to rewrite \(x:y:[]) -> f x y
00:04:17 <edwardk> thats about it
00:04:29 <johnw> I'd like to understand this better
00:04:35 <edwardk> (Trunk e) is a Functor
00:04:36 <johnw> it applies directly to something I was about to write
00:04:37 <edwardk> we can define
00:04:38 <amiller> since you mentieond a moore machine, can you also get from there to a mealy machine?
00:05:02 <edwardk> instance Functor (Trunk e) where fmap f (Leaf e) = Leaf e; fmap f (Bin x x) = Bin (f x) (f x)
00:05:39 <edwardk> then you have a :< Leaf e  or a :< Bin (a :< …) (a :< …)
00:06:08 <edwardk> so the end result is an annotated tree with annotations of type 'a' at every level
00:06:16 <edwardk> now, i did write up a blog post on how to use these
00:06:36 <edwardk> http://comonad.com/reader/2009/incremental-folds/
00:07:03 <edwardk> there, to maximize confusion i used:
00:07:09 <edwardk> data f :> m = f (f :> m) :> m
00:07:20 <edwardk> putting the 'a' on the other side
00:07:50 <edwardk> and using an infix type constructor that has the same name as the data constructor
00:08:00 <Jafet> It looks happy
00:08:08 <edwardk> :>
00:09:33 <edwardk> amiller: we can define a mealy machine, but its not a comonad
00:09:55 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Moore.hs
00:10:03 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Mealy.hs
00:10:14 <randomclown> @pl \x:y:[] -> f x y
00:10:14 <lambdabot> (line 1, column 6):
00:10:14 <lambdabot> unexpected "["
00:10:14 <lambdabot> expecting "()", natural, identifier, "_" or "("
00:10:21 <randomclown> @pl \(x:y:[]) -> f x y
00:10:21 <lambdabot> (line 1, column 7):
00:10:22 <lambdabot> unexpected "["
00:10:22 <lambdabot> expecting "()", natural, identifier, "_" or "("
00:10:35 <Jafet> @pl \[x,y] -> f x y
00:10:35 <lambdabot> (line 1, column 2):
00:10:35 <lambdabot> unexpected "["
00:10:35 <lambdabot> expecting pattern
00:10:46 <Jafet> @pl f [x,y] = g x y
00:10:46 <lambdabot> (line 1, column 9):
00:10:46 <randomclown> @pl \(x:y:[]) -> (f x y)
00:10:46 <lambdabot> unexpected "="
00:10:46 <lambdabot> expecting variable, "(", operator or end of input
00:10:46 <lambdabot> (line 1, column 7):
00:10:46 <lambdabot> unexpected "["
00:10:48 <lambdabot> expecting "()", natural, identifier, "_" or "("
00:10:54 <Jafet> Wait what
00:11:06 <edwardk> note that Mealy forms an Arrow while Moore forms a Comonad.
00:11:24 <edwardk> @pl doesn't do pattern matching
00:11:24 <lambdabot> doesn't do pattern matching
00:11:34 <luite> hehe
00:11:39 <edwardk> =)
00:11:42 <randomclown> @pl \xs -> foldl1 f xs
00:11:42 <lambdabot> foldl1 f
00:11:54 <randomclown> right right
00:11:57 <edwardk> it only deals with variables in the lhs
00:12:33 <Jafet> foldl1 f doesn't have the same type
00:12:59 <Jafet> Well, it may not have
00:13:29 <edwardk> > foldl1 f [x,y]
00:13:30 <lambdabot>   f x y
00:14:07 <edwardk> > foldl1 f [x,y,z]
00:14:08 <lambdabot>   f (f x y) z
00:14:42 <edwardk> i presume you want the result type to be able to vary or something?
00:16:02 <randomclown> (replicateM 2 (genTree h' v)) >>= return . (foldl1 f)
00:18:19 <Jafet> liftM2 f `join` genTree h' v
00:26:27 <pharaun> man i'm having trouble finding good quickcheck examples
00:26:44 <pharaun> i'm trying to generate a bytestring up to 9mb in quickcheck and i'm having trouble figuring this out
00:26:49 <johnw> > 1 :< [2, 3]
00:26:50 <lambdabot>   Not in scope: data constructor `:<'
00:28:45 <vrm_> @help
00:28:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:28:47 <amiller> that's excellent
00:28:50 <amiller> your blog post contains sum and size
00:28:58 <vrm_> @pl f x = x * x
00:28:58 <lambdabot> f = join (*)
00:29:54 <edwardk> amiller: that enough to get you going?
00:29:55 <amiller> those are exactly the motivating examples i had in mind for describing these "accumulators" (and i implemented all this in python where it's possible not to know what it actually is)
00:30:02 <amiller> they are algebras
00:30:07 <edwardk> amiller: yep
00:30:24 <edwardk> though sum and size an be implemented with just a monoid
00:31:29 <edwardk> sean leather wrote up a paper after this that elaborated a bit on the same ideas
00:32:22 <edwardk> http://splonderzoek.blogspot.com/2010/03/final-push-ups-push-downs-and-passing.html is pretty much what that turned into
00:37:28 <pharaun> anyone got any good example of quickcheck/quickcheck with X length bytestring?
00:41:56 <startling> pharaun: pack <$> vectorOf 20 (arbitrary :: Gen Word8) maybe?
00:42:10 <startling> dunno if Word8 is an Arbitrary out of the box
00:42:44 <startling> also, replace 20 with whatever you want
00:42:49 <pharaun> startling: sweet
00:43:21 <startling> you could probably do it more efficiently (without first constructing a list of Word8) but meh
01:15:48 <u_> http://arimaa.janzert.com/aei/aei-protocol.html http://pastebin.com/GgwRNPjv , trying to figure out how to tame this mess, especially mainLoop...
01:25:15 <cods> Is there a more concise way to write the following?
01:25:17 <cods> map (combine base) <$> ((filter $ flip notElem [".", ".."]) <$> getDirectoryContents base)
01:26:30 <Botje> looks pretty concise already
01:27:14 <Twisol> would utilize a section instead of flip, though: (`notElem` [".", ".."])
01:27:34 <Botje> map (combine base) . filter (`notElem` [".",".."]) <$> getDirectoryContents base
01:27:47 <Botje> but that might give issues with the precedence of . :[
01:29:04 <u_> ...suddenly my code doesn't seem so bad
01:29:46 <cods> Botje: looks better :) (and it works)
01:30:49 <Twisol> Incidentally, what's the precedence of a function used infix like `fmap`?
01:31:06 <u_> 4?
01:31:25 <Twisol> I mean using backticks in general
01:31:32 <mauke> customizable
01:31:41 <u_> really?
01:31:45 <Twisol> O_o
01:32:15 <u_> "any operator lacking a fixity declaration is assumed to be infixl 9"
01:32:21 <mauke> http://www.haskell.org/onlinereport/decls.html#fixity
01:32:35 <Twisol> u_: thanks
01:33:34 <u_> http://pastebin.com/GgwRNPjv halp someone
01:33:35 <Twisol> Interesting! So you can apply a fixity declaration to things that aren't automatically infix
01:33:42 <u_> crap i already posted that sorry
01:34:29 <u_> i tried to use statet on mainLoop but couldn't figure out how it worked :(
01:36:58 <u_> i'd like to apply words to each line before binding it to "l" but there's that one option setposition that needs whitespace preserved when it's between brackets
01:39:42 <Botje> you already have parsec imported, why not use that?
01:40:08 <u_> oh yeah
01:40:57 <Botje> and you still have access to l in the setposition case
01:41:03 <Botje> so just run l through a small parsec thing.
01:41:23 <u_> yeah, but i'd prefer to do words. getline >>= \l -> so i don't have to write :_ or :ls after everything else
01:41:53 <u_> my original idea was to use parsec for the entire mainLoop thingy but the fact it's IO got in the way
01:42:04 <Botje> doesn't matter.
01:42:12 <u_> really?
01:42:28 <Botje> getLine >>= \l -> case runParser commandParser "-" l of ...
01:42:33 <Botje> or something like that.
01:42:51 <u_> oh crap i'm stupid
01:43:08 <Botje> together with a small datatype
01:43:15 <u_> i was thinking of making the handle-each-line part part of the parser
01:43:42 <u_> like, a commandSequence parser that splits its input up into lines on its own
01:43:50 <Botje> data Command = Simple String | SetPosition String | SetOption String String | MakeMove String -- just guessing, of course.
01:43:53 <u_> >_<
01:44:00 <u_> alright
01:44:08 <Botje> that's also possible, but indeed needs a lot more work.
01:44:13 <u_> really?
01:44:23 <Botje> (your idiea, that is)
01:44:30 <u_> it seemed like parsers can only take Text and [Char] and stuff
01:44:30 <Botje> you can layer a ParsecT over IO
01:44:35 <u_> oh
01:45:10 <Botje> type Parser = Parsec String () 	-- Defined in Text.Parsec.String
01:45:16 <plat0> Where can I find which characters are allowed in infix operators?
01:45:18 <Botje> type Parsec s u = ParsecT s u Control.Monad.Identity.Identity -- Defined in Text.Parsec.Prim
01:45:33 <Botje> so even the regular "boring" parsec is already a monad transformer ;)
01:45:41 <u_> ah yeah speaking of T's... is StateT what i need to remove the gs ("gamestate") argument from mainLoop and  maybe clean up the record updating stuff?
01:45:46 <Botje> plat0: the haskell report, maybe?
01:46:20 <alex_> he
01:46:29 <Botje> u_: is there any code beyond the mainloop that needs to use the IO monad?
01:46:41 <u_> "think" needs to keep track of the time
01:46:47 <u_> besides that no
01:46:59 <Botje> think isn't in your code :[
01:47:08 <u_> oh right i took it out because it was just id at the moment
01:47:10 <Botje> also, make it a habit to put types on top-level declarations
01:47:13 <u_> it's the actual gametree search
01:47:27 <u_> k
01:47:53 <u_> think would be under the "go" branch
01:48:56 <Botje> you could probably get away with a forkIO + chan
01:49:01 <plat0> Botje: yes it's here: http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2
01:49:04 <u_> hm, "stop" has to interrupt "think"... i don't have a clue how to do that
01:49:08 <plat0> Thanks
01:49:13 <Botje> plat0: yay!
01:49:51 <Botje> u_: when you receive go, spawn a new thread that writes moves into a Chan
01:50:07 <u_> ah
01:50:26 <Botje> and then you can have a pure think function that returns a list of moves with monotonically increasing quality
01:50:48 <Botje> in the main thread you just grab every move from the chan
01:50:55 <Botje> when "stop" arrives, kill the thread and return the last move you read
01:51:09 <Botje> or maybe close the writing end of the Chan or something.
01:51:52 <Botje> net result is that you "think" can still be pure then.
01:52:16 <u_> how? what if "think" decides to delete system32?
01:52:55 <Botje> well, think would have type [Move]
01:53:20 <Botje> and you would forkIO a thread that invokes think, consumes each move and writes it into the Chan
01:53:34 <u_> oh i see
01:53:41 <u_> so keeping track of the time is outside of think now
01:53:47 <Botje> yes
01:54:37 <Botje> and I think that makes it relatively easy to generate moves in parallel --- just have more threads writing to the Chan.
01:56:24 <u_> eh the strategy i'm thinking of probably won't even return more than one decent move...
01:56:31 <vrm> @pl f x = x * x
01:56:31 <lambdabot> f = join (*)
01:56:42 <vrm> @pl foo rows = unzip . zipWith (\xs is -> let es = map (xs!!) is in (es, xs \\ es)) rows
01:56:42 <lambdabot> (line 1, column 10):
01:56:42 <lambdabot> unexpected "="
01:56:42 <lambdabot> expecting variable, "(", operator or end of input
01:56:46 <Botje> u_: oh.
01:56:55 <Botje> don't you want to look several moves ahead?
01:57:17 <Botje> with typical min-maxing or something
01:57:28 <ksf> odd. I just noticed that no hlist-like library knows of record constructors in the usual sense.
01:57:32 <u_> arimaa has a branching factor of 1,600 so the idea is to do as little of that as possible
01:57:45 <u_> (possible moves per turn)
01:57:56 <vrm> @pl unzip . zipWith (\xs is -> let es = map (xs!!) is in (es, xs \\ es)) rows
01:57:56 <lambdabot> (line 1, column 57):
01:57:56 <lambdabot> unexpected ","
01:57:57 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
01:59:18 <vrm> @pl unzip . zipWith (\xs is -> let es = map (xs!!) is in es) rows
01:59:18 <lambdabot> unzip . zipWith (map . (!!)) rows
01:59:41 <vrm> @pl unzip . zipWith (\xs is -> let es = map (xs!!) is in xs \\ es) rows
01:59:41 <lambdabot> (line 1, column 57):
01:59:41 <lambdabot> unexpected "\\"
01:59:41 <lambdabot> expecting variable, "(", operator or ")"
01:59:52 <vrm> @pl unzip . zipWith (\xs is -> let es = map (xs!!) is in xs (Data.List.\\) es) rows
01:59:52 <lambdabot> (line 1, column 68):
01:59:53 <lambdabot> unexpected "\\"
01:59:53 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
02:00:35 <vrm> @pl unzip . zipWith (\xs is -> let es = map (xs!!) is in (Data.List.\\) xs es) rows
02:00:36 <lambdabot> (line 1, column 65):
02:00:36 <lambdabot> unexpected "\\"
02:00:36 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
02:13:21 <ksf> has there been any work on record systems since -XDataKinds ?
02:13:32 <ksf> I don't mean lenses, but proper records with sums and products.
02:14:02 <u_> sums?
02:14:13 <ksf> as in sum type
02:14:20 <ksf> as in data Foo = Bar | Baz
02:14:53 <neutrino3000> you mean disjoint sum
02:14:55 <u_> but that's not a record
02:15:01 <ksf> ...called sum because the number of inhabitants of Foo = the number of inhabitants of Bar + Baz
02:15:19 <neutrino3000> no, it's sum because of topological origin
02:15:19 <shachaf> neutrino3000: As opposed to what kind of "sum"?
02:15:32 <ksf> neutrino3000, but then I wouldn't be able to remember it.
02:15:34 <neutrino3000> as opposed to set-theoretical sum
02:15:37 <ksf> also, my interpretation is true.
02:15:51 <ksf> ...it also applies to products.
02:16:40 <shachaf> Haskell types are a semiring with sums as + and products as *
02:17:04 <shachaf> I don't know what the original motivation for the names is, but that's certainly a reasonable one.
02:17:13 <shachaf> Also, types aren't sets.
02:17:16 <ksf> shachaf, where's the bleeding unit?
02:17:27 <neutrino3000> that's why you don't use sums for them, you use disjoint sums.
02:17:33 <shachaf> ksf: And () and Void.
02:17:52 <ksf> but I can't just tack on something.
02:18:03 <shachaf> Those are called sum types.
02:18:06 <shachaf> ksf: ?
02:18:06 <ksf> ...you have to say "up to data keywords"
02:18:24 <shachaf> Up to isomorphism.
02:18:31 <shachaf> That's implied. :-)
02:20:30 <cods> what is the obvious thing that I missing there: http://paste.lisp.org/display/131198 ? I need to concat the result of FilePath -> IO [FilePath] into a IO [FilePath] I think.
02:25:50 <randomclown> @pl \x,y -> (f x 1) && (f y 2)
02:25:50 <lambdabot> uncurry ((. flip f 2) . (&&) . flip f 1)
02:26:24 <randomclown> @pl \x,y -> (f x) ++ (f y)
02:26:25 <lambdabot> uncurry ((. f) . (++) . f)
02:26:52 <luite> cods: mapM or forM
02:27:17 <luite> forM level1 $ \l1 -> getDirectoryList l1 >>= ....
02:28:02 <luite> and you can simplify that again with >=>
02:28:34 <eldar> Hi! I'm trying to build Haskell platform on the server and it requires OpenGL by default. I don't really want to install mesa and potentially X on it, so I'd like to configure it without Opengl. IS that possible at all because --disable-opengl or --enable-opengl=no flags don't appear to work
02:30:29 <Jafet1> eldar: then you can't install the platform.
02:30:49 <eldar> well, it should be optional shouldn't it??
02:31:02 <eldar> I still need cabal to install some web related packages
02:31:03 <Jafet> But you can look up what packages are in the platform, install all of them except OpenGL, and you get the same thing
02:31:22 <Jafet> The platform is just a bundle of GHC, cabal-install and some packages
02:31:35 <luite> and alex, happy
02:31:42 <eldar> hm ok, so I can install cabal separately
02:31:44 <luite> which you sometimes need for web related packages
02:32:35 <cods> luite: hmm, I'm not sure to understand. Does not you suggestion produce [[FilePath]]? Actually I want something like: [FilePath] -> (FilePath -> IO [FilePath]) -> IO [FilePath] (I'm new to Haskell)
02:32:51 <Jafet> @type \f -> (++) `on` f
02:32:52 <lambdabot> forall b a. (Monoid b) => (a -> b) -> a -> a -> b
02:32:58 <Jafet> @type \f -> (Prelude.++) `on` f
02:32:59 <lambdabot> forall a a1. (a1 -> [a]) -> a1 -> a1 -> [a]
02:33:04 <luite> cods: you can concat them :)
02:36:42 <cods> then I'm stuck at [IO [FilePath]] -> IO [FilePath]. I need to think more about that.
02:38:55 <fmap> @type \xs -> concat <$> sequence xs
02:38:56 <lambdabot> forall a (f :: * -> *). (Monad f, Functor f) => [f [a]] -> f [a]
02:39:04 <fmap> cods: ^
02:39:35 <cods> ah, great
02:45:26 <structuralist> Does anyone here know the answer to this question? http://stackoverflow.com/questions/12103309/when-is-a-composition-of-catamorphisms-a-catamorphism
02:49:47 <DexterLB> how do I open a FIFO for writing? using openFile with WriteMode doesn't seem to work
02:50:49 <Botje> DexterLB: have you tried appendmode?
02:51:23 <DexterLB> doesn't work either. the error is this: Exception: /tmp/test_pipe: openFile: does not exist (No such device or address)
02:51:39 <DexterLB> which indicates that haskell is probably trying to open it in blocking mode instead of nonblocking
02:53:48 <cods> Does my updated version of my function looks good to you? http://paste.lisp.org/display/131198#1 (I spent one entire hour for these 4 lines of code :/ )
02:55:19 <typoclass> DexterLB: check out this. http://hackage.haskell.org/trac/ghc/ticket/4248 apparently someone needs to be reading from the pipe before you can open it for writing
02:55:26 <typoclass> (fifos are weird ...)
02:56:06 <mauke> wtf, someone actually reported that as a bug?
02:57:52 <DexterLB> typoclass: hmm
02:58:00 <mauke> DexterLB: what are you trying to do?
02:58:24 <DexterLB> write stuff to a fifo pipe instead of stdout :D
02:58:52 <mauke> yourprogram > thefifo
03:01:54 <pharaun> @pl newLength a = len xs + B.length a
03:01:54 <lambdabot> newLength = (len xs +) . B.length
03:41:33 <Sgeo> Don't you hate it when a language community steals a feature from Haskell but they want a facility that Haskell can't easily do so they write a macro but the language happens to support a feature that would allow doing it without a macro and Haskell doesn't have this feature but they don't realize it?
03:42:19 <fmap> what
03:42:22 <Jeanne-Kamikaze> huh
03:42:24 <drmegahertz> wat
03:42:27 <ninegrid> totally lost
03:42:32 <paolino> longer
03:42:49 <Sgeo> In Clojure, someone made a library for monads
03:43:32 <Sgeo> They implemented a liftM<any> thing via a macro, but since Clojure supports varargs easily, as far as I can tell it can be done via a function (unlike in Haskell)
03:44:28 <mm_freak_> we can have a variadic liftM, too
03:44:38 <mm_freak_> the clojure variant is untyped…  that's the difference
03:45:01 <mm_freak_> certain things are always easier to express, when no type system keeps you from being stupid…  that's the whole point of using haskell in the first place
03:46:01 <Jeanne-Kamikaze> I don't even understand how people can write anything without a type system
03:46:12 <Sgeo> My point is that whoever wrote this code didn't realize what was available to em
03:46:32 <mm_freak_> is in:  haskell?
03:46:58 <Sgeo> I'm looking at Clojure code
03:47:50 <mm_freak_> people trying to implement monads in other languages usually are just trying desparately to get some of haskell's beauty to their own language…  and more often than not they fail
03:47:58 <mm_freak_> if you want monads, use haskell
03:48:11 <Jeanne-Kamikaze> who writes clojure anyways
03:48:23 <Jeanne-Kamikaze> hey I'm a functional language, but my runtime can't do tco
03:48:36 <Jeanne-Kamikaze> so you should use recur everywhere
03:48:38 <mm_freak_> seriously?
03:48:41 <Jeanne-Kamikaze> yes
03:48:59 <mm_freak_> ok, clojure is off the list =)
03:49:18 <mm_freak_> what about scala?  same thing?
03:49:22 <Jeanne-Kamikaze> yes
03:49:38 <Jeanne-Kamikaze> if you read "Programming in Scala"
03:49:57 <mm_freak_> why is that?  isn't there a jump instruction in the JVM?
03:50:04 <Jeanne-Kamikaze> in the chapters on Actors they tell you to use react instead of receive, because react throws an exception in the end and runs in constant space
03:50:12 <raek> you can only jump within methods on the JVM
03:50:31 <Jeanne-Kamikaze> and in clojure you're told not to write recursive functions and to use recur instead
03:51:02 <mm_freak_> that wouldn't be a problem, if you were compiling properly
03:51:06 <raek> well, lazy sequences are commonly using ordinary recursion in clojure
03:51:16 <mm_freak_> in other words:  you shouldn't compile to java, but to the JVM
03:51:20 <Sgeo> mm_freak_, it's done to make Java interop easy
03:51:42 <Sgeo> I think it compiles to the JVM, but wants to make working with Java libraries nice.
03:51:59 <raek> mm_freak_: Clojure compiles into JVM bytecode directly
03:52:19 <raek> but JVM instructions must live in methods, which must live in classes
03:52:31 <mm_freak_> yeah, that sounds reasonable, but then any language on the JVM is going to be ugly…  i would sacrifice one direction of interop to get good code and some opportunities
03:52:44 <mm_freak_> because now clojure and scala really just sound like better javas
03:53:11 * Sgeo is trying to think of Clojure as a better Lisp
03:53:13 <raek> that was one of the reasons for making clojure, wasn't it?
03:53:24 <Jeanne-Kamikaze> I think one of the points of lisp is that it is fast
03:53:24 <mm_freak_> Sgeo: i'm very sure it's not a better lisp
03:53:50 <Jeanne-Kamikaze> from what I've read, the jvm is static and clojure must rely on reflection to get anything done, since clojure is "dynamic"
03:54:03 <mm_freak_> where by lisp i'm referring to scheme/racket and common lisp
03:54:21 <raek> is there any statically typed language with lisp-style macros?
03:54:52 <mm_freak_> raek: doubt it, but lisp is about the only language where you would want those macros
03:55:03 <mm_freak_> there is statically typed racket, FWIW
03:55:17 <mm_freak_> and there is haskell with TH, but that's not comparable
03:55:38 <Jeanne-Kamikaze> statically typed racket seems meh, although I didn't go very far with it
03:55:47 <Jeanne-Kamikaze> the type inference sucks and it forces you type virtually everything
03:57:28 <Jeanne-Kamikaze> seriously though, haskell is just plain awesome
04:00:31 <mm_freak_> haskell gives you the same power as clisp with macros, but without metaprogramming, source rewriting and statically typed
04:00:51 <mauke> wat
04:01:23 <mm_freak_> i'm referring to the power of higher order functions combined with laziness
04:01:31 <mauke> weaksauce
04:02:06 <Sgeo> mm_freak_, what of Template Haskell? It exists for a reason.
04:02:15 <qwr> raek: Qi maybe
04:03:04 <mm_freak_> Sgeo: TH isn't really necessary, it just saves you from having to repeat yourself or write boring boilerplate code
04:03:29 <mm_freak_> interestingly whenever something using TH comes up, some time later someone comes up with something similar that gets along without TH =)
04:03:46 <mauke> functions aren't really necessary, they just save you from having to repeat yourself or write boring boilerplate code
04:04:06 <mauke> interestingly etc.
04:04:47 <Sgeo> I am done with boilerplate code. I never wish to write boilerplate again.
04:06:37 <mm_freak_> mauke: i'll just disregard that as an attempt to troll…  no offense
04:07:38 <mauke> mm_freak_: you started it
04:08:55 <Sgeo> mm_freak_, what, in fact is "really necessary"? Most nonpathological languages are Turing-complete.
04:09:01 <mm_freak_> this is still a chat room, so some intuitive communication is allowed…  let's use the power of our brain to apply context and knowledge, which machines lack (currently)
04:09:13 <mm_freak_> Sgeo: that's my point
04:10:29 <mm_freak_> such a comparison is always subjective and hard to formalize for turing-complete languages
04:10:52 <mauke> mm_freak_: the thing is, I think you're wrong
04:11:11 <mm_freak_> but when i'm saying that haskell gives you the same power as clisp macros, then i mean that you won't miss the macros in haskell
04:11:39 <mauke> but I do
04:11:45 <mauke> and I don't even use lisp
04:11:53 <mm_freak_> mauke: there is a huge difference between being wrong and making empty statements…  now it gets more interesting, what am i wrong about?
04:12:15 <mauke> <mm_freak_> haskell gives you the same power as clisp with macros, but without metaprogramming, source rewriting and statically typed
04:13:00 <mauke> ok, you could define "same power" such as to make it an empty statement
04:14:23 <mm_freak_> intuitively my understanding is that you're saying:  clisp macros can do the same with less code or less programmer work
04:14:49 <mauke> same as what?
04:15:02 <mm_freak_> as higher order functions and laziness in haskell
04:15:09 <mauke> no, that's ridiculous
04:15:25 <mm_freak_> then i need some explanation
04:15:52 <Sgeo> I feel weird with the abbreviation "clisp", since that's also the name of one particular Common Lisp implementation.
04:16:41 <mm_freak_> let's say CL then
04:17:31 <mauke> mm_freak_: are you assuming a total ordering over programming languages?
04:18:03 <mauke> such that not (A <= B) implies A > B?
04:19:38 <mm_freak_> mauke: my order is partial, but i'm not using turing's measure
04:19:49 <mm_freak_> i'm using productivity as a measure
04:20:12 <mm_freak_> in that sense haskell is more powerful than assembly most of the time
04:20:19 <mauke> PHP wins hands down
04:20:30 <mauke> have you seen how much PHP code is produced every day?
04:21:03 <mm_freak_> did you divide that number by the number of PHP programmers and the relative richness of the code?
04:21:19 <mauke> no
04:21:27 <mauke> what's a relative richness?
04:21:54 <qwr> why the amount of code produced is relevant ;)
04:22:08 <mm_freak_> compare "forkIO $ …" to the equivalent in PHP
04:22:21 <mauke> mm_freak_: what equivalent?
04:22:36 <qwr> if they wrote it in assembler, i'm sure, they had to write even more ;)
04:22:41 <mm_freak_> PHP does support threads (but nobody uses them)
04:23:18 <merijn> mm_freak_: Hah, I bet somewhere out there is a Node.php using threading to implement an asynchronous event server
04:23:40 <mm_freak_> alternatively you can compare virtually any application of foldM, mapM or even filter
04:24:03 <mm_freak_> haskell code is, let's say, "semantically dense"
04:24:23 <mauke> mm_freak_: how does that help you with writing, say, a CMS or a wiki?
04:24:39 <mm_freak_> well, you use one of haskell's web frameworks
04:24:47 <mauke> or I could just use PHP
04:24:56 <mm_freak_> not PHP alone
04:25:10 <mm_freak_> you could use PHP with the zend framework, etc.
04:25:17 <Randy1703> http://www.youtube.com/watch?v=VeG6EVGGZtA&feature=plcp
04:25:34 <mm_freak_> then you still write more code with PHP than with haskell
04:25:55 <mauke> yes, because PHP makes me more productive
04:26:19 <mm_freak_> i'm measuring productivity in application richness, not in code size
04:26:53 <Sgeo> Oh crud. I absentmindedly clicked the video because I tend to click links. It's blatently spam, but the video has an ad on it so this jackass made money off me :(
04:27:43 <mauke> PHP has far more interesting semantics, leading to richer application behavior
04:27:52 <mm_freak_> that's true
04:28:08 <typoclass> mauke: what exactly are you arguing for?
04:28:20 <Jeanne-Kamikaze> ^ was about to ask that too
04:28:22 <dmwit> for the joy of trollin'
04:28:23 <mauke> that this discussion is stupid
04:28:39 <mm_freak_> typoclass: don't worry, he prefers haskell =)
04:28:50 <dmwit> shows what you know, he prefers perl
04:29:29 <mauke> I think "interesting semantics leading to rich application behavior" is a good euphemism, though
04:29:55 * Sgeo wants to strike some balance between functionalness, libraries, and macros
04:30:08 <Sgeo> Which is why I'm looking at Clojure >.>
04:30:15 <mikeplus64> why do ghc developers tend to use do notation, but with curly braces and semi-colons?
04:30:34 <mauke> mm_freak_: I see no thread functions in PHP
04:30:40 <mauke> what were you referring to?
04:30:48 <flux> sgeo, I was going to plug you with a script to warn about that, but it's for irssi :)
04:31:01 <mm_freak_> mauke: you have to compile PHP with threading support enabled…  in most cases it's disabled, because it makes stuff fail
04:31:03 <dmwit> Who can tell me about using pty's in Haskell?
04:31:18 <mauke> mm_freak_: ok, but how do I use it?
04:31:37 <Sgeo> flux, warn against ... clicking links by someone who rapidly enters links and leaves?
04:32:24 <flux> seantallen, "142517 NOTE! Randy1703 has been silent before this URL!"
04:32:26 <flux> oops, sgeo
04:32:30 <Sgeo> Ah
04:33:18 <Sgeo> Well, if it weren't a YouTube URL I would have been more cautious... which in my mind consists of opening links in incognito so no funny business with cookies happens
04:33:28 <Sgeo> Which is probably asking for trouble, really :/
04:33:48 <mm_freak_> mauke: apparently you have to fork manually and use IPC
04:34:05 <mm_freak_> mauke: as far as i understand multi-threading in PHP is done from outside of PHP
04:34:18 <mm_freak_> like from mod_php
04:34:43 <mauke> I'm reluctant to call that threading
04:34:56 <mauke> it's not part of the language proper
04:37:44 <mm_freak_> reasonablre
04:37:46 <mm_freak_> reasonable
04:55:20 <statusfailed> I have an Arrow which has some internal state, what's the best way to expose it? the State arrow transformer?
05:00:42 <mm_freak_> statusfailed: what kind of arrow?  and why an arrow?
05:01:00 <statusfailed> mm_freak_: I'm doing mealy machines :P
05:01:10 <statusfailed> mostly as a learning exercise
05:01:14 <mm_freak_> they are inherently stateful
05:01:52 <statusfailed> ok, so I can obviously make some functions like "get" and "set", e.g. get :: Mealy t state
05:02:19 <statusfailed> but I know there are things like ArrowState which already have definitions
05:02:28 <statusfailed> I'm not really sure how to fit it in with existing "interfaces"
05:02:44 <mm_freak_> MealyT (Kleisli (State s)) a b
05:03:20 <statusfailed> sorry, totally lost here :)
05:03:30 <statusfailed> I should probably figure out monad/arrow transformers
05:04:09 <mm_freak_> let me get this straight…  you want global state?
05:04:30 <mm_freak_> because individual mealy machines have local state
05:04:33 <statusfailed> local state
05:04:47 <statusfailed> I want to compose mealy machines of the same state
05:05:03 <statusfailed> so I don't want that generalized Automaton thing where you have automata returning new automata
05:05:15 <mm_freak_> you can compose mealy machines which then communicate
05:05:28 <mm_freak_> m2 . m1
05:05:34 <mm_freak_> m2 can now act on the state of m1
05:05:38 <statusfailed> right
05:05:45 <mm_freak_> do you want feedback?
05:05:54 <statusfailed> Nope
05:06:08 <statusfailed> keeping it simple
05:06:34 <statusfailed> Basically my only requirement is that I can run the composed machine step-by-step, and look at intermediate states
05:06:54 <mm_freak_> what do you mean by "look"?
05:07:00 <statusfailed> access, use
05:07:07 <mm_freak_> you want explicit state?
05:07:10 <statusfailed> yes
05:07:19 <mm_freak_> there is an equivalent representation for mealy machines
05:07:31 <mm_freak_> data Mealy a b = forall s. Mealy s ((a, s) -> (b, s))
05:07:40 <mm_freak_> now you can add instances to the 's' type
05:07:42 <mm_freak_> like Show
05:07:43 <statusfailed> That's basically what I have, except the "forall s."
05:07:59 <mm_freak_> what do you have instead?
05:08:21 <statusfailed> newtype Mealy s a b = Mealy { runMealy :: (a, s) -> (b, s) }
05:08:41 <mm_freak_> that's not a mealy machine at all
05:08:45 <mm_freak_> it's just StateArrow
05:09:00 <statusfailed> It seems to fit by the wikipedia definition?
05:09:12 <mm_freak_> what your definition lacks is local state =)
05:09:28 <mm_freak_> the usual definition looks like this:  data Mealy a b = Mealy (a -> (b, Mealy a b))
05:09:37 <mm_freak_> the existential one is equivalent to this one
05:09:42 <statusfailed> But that can have arbitrary internal state, returning new (and different) mealy machines
05:09:49 <mm_freak_> yes, that's the point
05:09:54 <statusfailed> but that's not what a mealy machine is
05:10:18 <statusfailed> A Mealy machine has a finite set of states
05:10:26 <mm_freak_> countFrom x0 = Mealy x0 (\(dx, x) -> (x, x + dx))
05:10:57 <mm_freak_> well, that's the automaton arrow…  i thought you were referring to Mealy as edwardk defined it
05:10:57 <dmwit> I feel like mm_freak_ is addressing different questions than the ones statusfailed is asking.
05:11:15 <mm_freak_> now, i'm now just starting to get what statusfailed actually has and wants =)
05:11:19 <statusfailed> haha, sorry :P
05:11:29 <statusfailed> I know the definition I have is what I want
05:11:41 <statusfailed> What I want to do is provide useful methods like "get, set, modify", to make it easier to use
05:11:54 <statusfailed> and I don't know how to make it a "StateArrow"
05:12:04 <statusfailed> which I guess seems to be the right thing
05:12:28 <mm_freak_> get = Mealy (\(s, _) -> (s, s))
05:12:38 <mm_freak_> get :: SFMealy s s s
05:12:42 <mm_freak_> uhm
05:12:45 <mm_freak_> that was put
05:12:47 <mm_freak_> not get
05:12:48 <statusfailed> haha
05:13:07 <mm_freak_> get = Mealy (\(_, s) -> (s, s))
05:13:11 <mm_freak_> that's get
05:13:18 <statusfailed> do I need an instance declaration with that? is it just "instance StateArrow s (SFMealy s) b c"
05:13:26 <mm_freak_> modify = Mealy (\(f, s) -> (s, f s))
05:13:41 <mm_freak_> no, those were just functions
05:14:00 <mm_freak_> you can of course use the 'arrows' library and write an ArrowState instance
05:14:16 <mm_freak_> they weren't even functions =)
05:14:31 <mm_freak_> my modify has this type:  SFMealy s (s -> s) s
05:14:52 <mm_freak_> you could pass it a static function like this:  modify . pure f
05:15:12 <mm_freak_> but again, it's really just StateArrow, and StateArrow is just an uglier State
05:15:23 <mm_freak_> so you could just as well use state monads and get a nicer interface
05:15:47 <statusfailed> as in use the type a -> State s b  ?
05:15:48 <dmwit> (a,s) -> (b,s) ~= Kleisli (State s) a b
05:16:06 <mm_freak_> yes
05:16:44 <statusfailed> that seemed to be harder to use, and the arrow notation seems like it would be helpful to write them out
05:17:05 <dmwit> a -> State s b ~= Kleisli (State s) a b, too
05:17:18 <mm_freak_> do-notation is more powerful than arrow notation
05:17:46 <mm_freak_> more precisely:  monadic do-notation is more powerful than arrowic do-notation
05:18:39 <mm_freak_> you can get along without all those -< symbols and can make the computational structure depend on the state results
05:19:04 <mm_freak_> and you have to use less tuples =)
05:19:29 <statusfailed> Hmmm.
05:19:39 <statusfailed> i'm trying to think of an example where I'd need -<
05:20:19 <mm_freak_> get -< newState
05:20:23 <mm_freak_> uhm
05:20:30 <mm_freak_> why am i confusing get and put all the time?
05:20:41 <mm_freak_> put -< newState
05:20:46 <mm_freak_> state <- get -< ()
05:20:59 <mm_freak_> state <- modify -< succ
05:21:04 <mm_freak_> etc.
05:21:04 <kane77> what editor do you use for haskell?
05:21:13 <mm_freak_> i use emacs…  most use emacs or vim
05:22:32 <statusfailed> I'm confused as to why I can't make "the computational structure depend on the state results" without using monadic do notation
05:22:53 <mm_freak_> s <- get -< ()
05:22:56 <mm_freak_> f s -< ()
05:22:59 <mm_freak_> s is not in scope
05:23:05 <mm_freak_> s <- get
05:23:06 <mm_freak_> f s
05:23:09 <mm_freak_> s is in scope
05:23:36 <statusfailed> Why is s not in scope? I can't desugar that in my head ...
05:23:37 <statusfailed> :D
05:23:43 <byorgey> kane77: you could also use gedit, or kate, or notepad++, and there are also some IDEs, like a plugin for Eclipse and something called Leksah
05:23:46 <mm_freak_> what does it desugar to?
05:24:37 <mm_freak_> statusfailed: if you can desugar that in your head, you have just destroyed the entire universe…  it's like giving an answer to the question whether the barber of seville shaves himself =)
05:25:08 <kane77> byorgey, yes, I know I can use any text editor, but I would like some comfort, I'm vim guy, but the haskellmode seems to be ages old and I can't get it to compile
05:25:13 <statusfailed> ok, I mean I don't know how I desugar things normally, so I don't understand why that isn't in scope :P
05:25:39 <byorgey> kane77: ah.  well, there are plenty of Haskellers that use vim (though I am not one of them).
05:25:42 <tdammers> kane77: I use just plain vim, works fine
05:25:49 * hackagebot monarch 0.1.0.0 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.1.0.0 (NoriyukiOhkawa)
05:25:51 <statusfailed> I use vim without haskellmode
05:25:54 <tdammers> ctags file from ghci, and I'm all set
05:25:56 <merijn> kane77: Personally I just use vim without haskellmode, the autoindenting could be a little smarter, but it's good enough for me
05:25:58 <byorgey> kane77: I know dmwit is a big vim guy, you can ask him what he does when he's around
05:26:14 <statusfailed> byorgey: he was around just moments ago!
05:26:23 <byorgey> oh! so he was!
05:26:23 <dmwit> I'm half around.
05:26:24 <kane77> tdammers, how do you do that?
05:26:25 <dmwit> What's up?
05:26:35 <statusfailed> dmwit: what do you do for haskell-mode?
05:26:52 <dmwit> I use Claus Reinke's mode.
05:26:59 <dmwit> I've got a link hanging around here somewhere...
05:27:06 <tdammers> :ctags, you mean?
05:27:30 <dmwit> http://projects.haskell.org/haskellmode-vim/ <- this one, I think
05:27:39 <tdammers>    :ctags[!] [<file>]          create tags file for Vi (default: "tags")
05:27:48 <tdammers> ^ that's what ghci itself has to say about it
05:28:25 <tdammers> (the exclamation mark makes regex-based rules, those work better when you edit and line numbers change)
05:30:11 <mm_freak_> statusfailed: you may be interested in my unfinished arrow tutorial
05:30:14 <kane77> hmm.. let me try that..
05:30:39 <mm_freak_> statusfailed: it shows you both why s is not in scope and why you just have a convoluted state monad =)
05:30:53 <mm_freak_> statusfailed: http://ertes.de/new/tutorials/arrows.html
05:35:01 <statusfailed> mm_freak_: Okay, reading up :)
05:35:26 * byorgey is interested in reading mm_freak_'s finished arrow tutorial ;)
05:35:26 <mm_freak_> it also makes you understand why Auto is so great =)
05:35:59 <mm_freak_> byorgey: if you're patient…  might take a few weeks/months, because i'm not really getting around to finishing it
05:36:37 <byorgey> mm_freak_: yeah, it was a joke, just trying to encourage you to finish it =)
05:36:47 <mm_freak_> ok =)
05:36:51 <byorgey> though it is true I am interested in taking a look at it at some point (finished or unfinished)
05:37:16 <mm_freak_> it's not terribly long right now, so looking now might give you a first clue easily
05:37:29 <mm_freak_> and i'd be happy to receive your feedback =)
05:46:29 <kane77> tdammers, do you create tags of library functions?
05:46:48 <statusfailed> mm_freak_: so far it seems like your tutorial is arguing that I _do_ want arrows...
05:46:51 <statusfailed> :P
05:47:17 <hpaste> abcdefgh pasted “Data constructor in other module” at http://hpaste.org/73686
05:47:42 <thirsteh> thanks hpaste. Can somebody help me explain why that doesn't work?
05:48:07 <statusfailed> thirsteh: you need to export the constructors, too
05:48:12 <statusfailed> herp
05:48:13 <statusfailed> you did
05:48:38 <thirsteh> I'm pretty lost..
05:49:33 <statusfailed> thirsteh: http://www.haskell.org/tutorial/modules.html
05:49:47 <Cerise> thinking about it
05:49:50 <thirsteh> thanks, but that's what I followed
05:49:55 <thirsteh> clearly there's something I misunderstood
05:49:57 <statusfailed> I'm just showing you what i'm reading :D
05:49:59 <Cerise> wouldn't mapM be the same as (sequence . map)?
05:50:00 <thirsteh> ah
05:50:58 <thirsteh> import Bar(MyData(..)) doesn't work either
05:51:23 <statusfailed> thirsteh: Bar(MyData(MyData, dataName, dataNum)) ?
05:52:00 <thirsteh> ah, there you go!
05:52:02 <thirsteh> of course
05:52:04 <thirsteh> thanks much statusfailed
05:52:18 <statusfailed> yw :D
05:52:21 <statusfailed> after all that derping around
05:52:23 <statusfailed> heh
05:52:40 <thirsteh> that's nothing. I spent like 4 hours just trying to compile and letting it break my brain yesterday
05:52:42 <thirsteh> should've asked here earlier
05:52:53 <statusfailed> aww
05:53:01 <statusfailed> I hate it when I do that
05:53:05 <thirsteh> only makes this more satisfying :)
05:57:28 <saep> Why do all IO actions have type (IO Foo) and not (MonadIO m => m Foo)?
05:58:55 <opqdonut> to keep things more concrete
05:58:58 <opqdonut> you can always liftIO them
05:59:01 <opqdonut> :t liftIO
05:59:02 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
05:59:23 <opqdonut> also, MonadIO isn't part of Prelude
05:59:33 <opqdonut> or even base
06:01:17 <hpaste> abcdefgh annotated “Data constructor in other module” with “Data constructor in other module (annotation)” at http://hpaste.org/73686#a73687
06:09:32 <fuchsto> I have a record i use to read / write settings into a file. Now, one entry of this record is again a heterogenous list of records, like   things :: [ AnyRecordDerivingShowAndRead ]
06:10:13 <fuchsto> I understand that i can use existential types to define something like "Showable". How could i define an existental type "ShowableAndReadable" ?
06:12:02 <paolino> fuchsto, add Read a to the Show a in the context of the existential
06:12:28 <fuchsto> paolino: Thank you, just facepalmed and tried it myself >_<
06:12:45 <dmwit> um
06:13:00 <dmwit> An existential with a Read inside doesn't really seem readable.
06:13:16 <dmwit> How should it know which Read instance to use...?
06:13:54 <paolino> you need some witness I suppose
06:14:04 <dmwit> All you get is a String.
06:14:15 <loreints> is there an example somewhere of using parsec with an ascii non line-terminated file?
06:14:29 <dmwit> Perhaps Typeable can help.
06:14:50 <paolino> in the end
06:14:56 <dmwit> loreints: Sounds like you're reading a binary format. Don't use parsec for that.
06:15:37 <dmwit> Typeable doesn't really help.
06:15:42 <aristid> dmwit: why not, specifically?
06:15:44 <dmwit> You can't go backwards from a TypeRep to a Proxy a.
06:15:48 <loreints> dmwit: why not? attoparsec looks like it works pretty well for it
06:15:58 <dmwit> loreints: Yes, attoparsec is great for it.
06:16:03 <dmwit> attoparsec is not parsec.
06:16:17 <loreints> but it has the same api while I'm debugging, right?
06:16:36 <dmwit> aristid: It's not bad. It's just that there's other packages that have smoother integration with binary-format idioms.
06:16:38 <loreints> I don't really know haskell, so I want to start somewhere where I can look at tutorials/google stuff then switch
06:16:48 <loreints> or should I start off using attoparsec?
06:17:15 <aristid> dmwit: i see.
06:18:08 <dmwit> loreints: If you think you're going to end with attoparsec, you should start with attoparsec, too.
06:18:24 <fuchsto> dmwit: So, how would i solve this?
06:18:33 <dmwit> fuchsto: Don't Do That
06:18:47 <fuchsto> dmwit: I was afraid you'd say that.
06:19:18 <dmwit> fuchsto: Is there a reason to use (exists a. Show a => a) over, say, String?
06:19:29 <fuchsto> dmwit: Essentially, i want a settings file, and i have modules A, B and C, each having their own settings record.
06:20:21 * dmwit nods along merrily
06:20:21 <fuchsto> dmwit: Using a heterogenous list of these module-settings records seemed logical. So, what's the right way to solve that?
06:20:40 <dmwit> Wait, why do you want a heterogeneous list of these things?
06:20:57 <dmwit> Why not something like
06:21:16 <dmwit> data Settings = A A.Settings | B B.Settings | C C.Settings -- ?
06:21:17 <fuchsto> dmwit: Well, assuming i have a setting like   moduleSettings = [ settingA, settingB ]  the list would be heterogenous, wouldn't it?
06:21:39 * fuchsto scratches head
06:21:53 <fuchsto> there has to be a reason why i didn't do it this way ...
06:22:51 <fuchsto> Meh, i don't care about my thoughts of yesterday, i'll just do it. Thanks :)
06:22:57 <dmwit> g'luck =)
06:23:36 <fuchsto> dmwit: Thanks :)   Oh, and by the way: Gtk2Hs works just fine out of the box with the recent packages for Ubuntu 12.04
06:23:44 <dmwit> hooray
06:24:12 <fuchsto> dmwit: So these segfaults i got seem to only appear for a certain combination of ghc and glib2, i presume
06:24:26 <fuchsto> dmwit: The ghc version being the crucial part
06:24:41 <statusfailed> mm_freak_: ok I think i'm with you on why I just made a gimped State Monad
06:24:57 <dmwit> fuchsto: Yeah, I could never reproduce them. =/
06:25:00 <fuchsto> dmwit: Still crashes on 7.2, works fine on 7.4. But it doesn't look like it's a Gtk2Hs issue.
06:26:04 <loreints> dmwit: thanks for the suggestion!
06:40:04 <mm_freak_> statusfailed: =)
06:40:53 <merijn> Is there some way to make cabal store/cache dependency info? I'm working on a project using Yesod and when I run "cabal clean && cabal install" the resolving dependencies process takes ages...
06:42:15 <adnam> merijn: why do you have to clean? updated deps?
06:42:27 <mm_freak_> merijn: just don't clean
06:42:56 <mm_freak_> merijn: also you don't have to install to run a program
06:43:07 <mm_freak_> see dist/build
06:44:01 <merijn> adnam: Mostly to get rid of any stale files that are no longer needed (I started with a scaffolded Yesod site, but that has many things which are overkill for my purposes)
06:44:11 <adnam> i'm not sure, but can cabal-dev prevent you from having to clean if you have updated a package with the same version number but different hash?
06:45:07 <adnam> aha, well then i'd suggest as mm_freak_ and don't clean, if it causes trouble then you can clean
06:45:41 <mm_freak_> merijn: cabal-install is smart enough only to install what is actually necessary
06:45:45 <mm_freak_> stale files don't get installed
06:45:52 * hackagebot wtk 0.2 - Wojcik Tool Kit  http://hackage.haskell.org/package/wtk-0.2 (BartoszWojcik)
06:46:06 <mm_freak_> i sometimes write on a project for weeks without cleaning once
06:49:25 <Sgeo> People in languages other than Haskell seem to be so enamored with monads that they don't bother to make applicatives and functors separately definable things
06:49:44 <Sgeo> It's like they're bringing over just the "works with monads only" versions of functions.
06:49:57 <Sgeo> And not generalizing to non-monad applicatives and functors.
06:52:00 <byorgey> Sgeo: they'll get there.  And F# is one notable counterexample.
06:52:25 <Automorphism> Sgeo: Weird, because functors are easier to grasp than monads. :-P
06:54:43 <k0ral> is there a gtk2hs maintainer here ?
06:54:58 <byorgey> k0ral: dmwit
06:55:12 <dmwit> k0ral: hi
06:56:08 <hpc> Automorphism: incidentally, more languages have functors
06:56:17 <hpc> as a side-effect of having iterators
06:56:22 <loreints> why can't I used [[String]] b -> ... in a case statement?
06:56:40 <dmwit> loreints: What did you want that to do?
06:57:11 <dmwit> To answer the direct question: because String is not a constructor, and even if it were the b would be an extraneous little thing.
06:58:32 <mm_freak_> byorgey: in what way is F# a counterexample?  can you actually define Functor and Applicative there?
06:58:41 <loreints> I just want to match on a type... I have a function that does this: parseCSV :: String -> Either ParseError [[String]]
06:58:59 <dmwit> Perhaps you want to match on the Left and Right constructors.
06:59:19 <dmwit> case parseCSV "blah blah blah" of Left err -> ...; Right parsed -> ...
06:59:21 <Eduard_Munteanu> @src Either
06:59:21 <lambdabot> Source not found. stty: unknown mode: doofus
06:59:28 <byorgey> mm_freak_: http://tomasp.net/blog/fsharp-variations-joinads.aspx
06:59:30 <dmwit> data Either a b = Left a | Right b
07:00:09 <k0ral> dmwit: hi
07:00:28 <k0ral> dmwit: why isn't gtk2hs-buildtools a dependency of gtk ?
07:00:34 <dmwit> It wouldn't help.
07:00:45 <Eduard_Munteanu> loreints: also, you can't match on types, or anything like that
07:00:54 <loreints> dmwit: ah, thank you
07:00:55 <dmwit> You need gtk2hs-buildtools to compile Setup.hs, which has to happen before dependency analysis.
07:01:06 <dmwit> s/has to happen/happens/
07:01:38 <k0ral> alright, now I guess the same holds for alex and happy as dependencies for gtk2hs-buildtools ?
07:01:51 <dmwit> Hm, that one I'm not 100% sure of.
07:02:03 <dmwit> Ah, no, that's a different thing.
07:02:14 <dmwit> There's just no way to depend on executables in cabal, and alex and happy don't install libraries.
07:02:15 <Eduard_Munteanu> k0ral: generally, binary deps aren't handled by cabal
07:02:15 <k0ral> I was wondering why installing gtk wasn't as seamless as installing any other package
07:02:35 <dmwit> Yes, it's very unfortunate.
07:02:40 <dcoutts_> dmwit: not quite true, you can specify build-tools dependencies
07:02:43 <k0ral> Eduard_Munteanu: is it a bad thing to handle that, or is it just a missing feature ?
07:02:56 <dcoutts_> but it is true that those are not yet taken into account by the dependency solver
07:02:59 <dmwit> dcoutts_: Can you specify a package that provides those dependencies?
07:03:03 <Eduard_Munteanu> I'd guess it's a bit of both.
07:03:18 <dcoutts_> dmwit: no, you specify the executable itself
07:03:22 <dmwit> dcoutts_: We already specify alex and happy as build-tools, but that doesn't get the second part (which is installing alex and happy if they're not there yet).
07:03:43 <dcoutts_> dmwit: right, it checks they're there but the dep solver doesn't match them to packages yet
07:03:50 <dmwit> Right.
07:03:58 <k0ral> it won't stop me from installing gtk-dependent programs because I'll make the effort, but it will for many beginners
07:04:17 <dcoutts_> which isn't anything special about build tools, the dep solver doesn't track any deps at all except lib deps (not C libs, etc etc)
07:04:48 <dmwit> k0ral: Yes, gtk2hs is historically one of the most complained-about build processes. =P
07:04:57 <hamishmack> dmwit: I am working on a big patch for the gtk2hs webkit package to add DOM interfaces.  It is not finished, but quite a lot of stuff works now.
07:05:11 <dmwit> Wow, great!
07:05:34 <dmwit> I have a bit of a backlog of things to do on gtk2hs, actually.
07:06:07 <hamishmack> I'd quite like to put it somewhere for people to try it out.
07:06:42 <hamishmack> What is the best way to do that?
07:07:06 <dmwit> Are you asking about hosting or advertising?
07:07:16 <hamishmack> Hosting
07:07:17 <dmwit> hosting: perhaps patch-tag or similar?
07:07:25 <dmwit> advertising: gtk2hs-users mailing list, I guess
07:07:28 <mikeplus64> dmwit: any plans for a gtk3hs? (i might start working on it, but i have zero experience in this sort of dealio)
07:07:35 <Eduard_Munteanu> dmwit: btw, is GTK3 support planned at all?
07:07:37 <Eduard_Munteanu> Heh.
07:07:40 <mikeplus64> Eduard_Munteanu: haha
07:07:46 <dmwit> mikeplus64: Somebody has submitted some patches, but they break a few old interfaces.
07:08:01 <dmwit> The top thing on my backlog is seeing how hard it is to fix up the patches so that we don't lose backwards compatibility.
07:08:33 <hamishmack> I'll stick the webkit dom stuff up on patch-tag this weekend
07:09:04 <mikeplus64> gtk3 broke compatibility with gtk2 though (didn't it?), so i wouldn't really worry about losing backwards compatibility
07:09:21 <mikeplus64> gtk3's glade is really nice
07:09:35 <dmwit> It depends what you mean by backwards compatibility, I think.
07:10:02 <mikeplus64> expecting some code written for gtk2hs to work for the hypothetical gtk3hs i guess
07:10:10 <dmwit> Right, that is not what I mean.
07:10:23 <mikeplus64> oh
07:10:23 <hpc> oh wow, that's what the 2 was
07:10:29 <hpc> i thought it was like c2hs
07:10:32 <dmwit> What I mean is the code he submitted to make gtk3hs bindings eliminated some gtk2hs bindings when built without the gtk3 flag.
07:11:12 <dmwit> anyway, AFK for a few hours now
07:11:19 <dcoutts_> dmwit: oh, you're planning on making it bind both 2.x and 3.x?
07:11:21 <mikeplus64> alrighty
07:11:29 <dmwit> dcoutts_: I guess?
07:11:35 <dmwit> Possibly split into a separate package, though.
07:11:44 <Nafai> I don't know if any other language bindings support both
07:12:05 <dmwit> It would really make it possible to lose a lot of cruft if we split into a GHC7/gtk3-only package. =P
07:12:13 <dcoutts_> dmwit: great. I'd not looked at how much different they are. Of course gtk2hs has supported loads of versions of 2.x for ages, using cpp, but I wasn't sure how much of a jump 3.x is
07:12:42 <dcoutts_> dmwit: but it's quite plausible, I've heard 3.x mainly deletes deprecated stuff and adds new stuff, but doesn't fundamentally change much
07:12:51 <dmwit> Anyway, yeah, the current patches just use cpp.
07:13:01 <dcoutts_> sounds ok
07:13:20 <hpc> dcoutts_: ive heard that a few fundamental features are missing, like the ability to specify a default directory for the file chooser
07:13:31 <dmwit> Okay, really AFK now.
07:13:43 <dcoutts_> hpc: that wound't be a problem for the binding
07:13:57 <hpc> ah, true
07:16:53 <sheldonh> is the maybe function the only way to get the number 2 out of (Just 2)?
07:17:04 <mikeplus64> sheldonh: no!
07:17:15 <mikeplus64> > case Just 2 of Just x -> x
07:17:16 <lambdabot>   2
07:17:27 <sheldonh> ooooh
07:17:27 <mm_freak_> byorgey: i still don't believe monads are very useful in a language that doesn't allow polymorphism of type variables other than of kind *
07:17:43 <mm_freak_> i believe this is called "higher-kinded polymorphism", even though i find that term very unfortunate
07:17:52 <sheldonh> mikeplus64: great. 'cause the maybe function had me looking for a function to give it, that just returns its input. which felt... arse about face :)
07:17:53 <mm_freak_> higher-kinded feels like (* -> *) -> *
07:18:07 <loreints> should I be using parsec if I'm parsing a fixed byte format? like, I know this field is 2 bytes, and this one 5, and so on. I think not, going by the tutorials/examples so far, but I'm not sure.
07:18:22 <mm_freak_> (and yes, haskell supports that, too, of course, and other languages are far from supporting that)
07:18:50 <mikeplus64> sheldonh: remember to also add a clause for when the thing is Nothing (ie case justSomething of Just x -> x; Nothing -> "oh no")
07:19:11 <Eduard_Munteanu> :t fromMaybe
07:19:12 <lambdabot> forall a. a -> Maybe a -> a
07:19:28 <byorgey> sheldonh: you may be interested also in the 'fromMaybe' function
07:19:35 <byorgey> ah, Eduard_Munteanu beat me to it
07:20:40 <sheldonh> ha! that's exactly what i'm looking for, thanks. plus i got a sneak peek at case statements for free!
07:21:00 <mm_freak_> i never understood why other languages impose arbitrary restrictions on polymorphism…  supporting arbitrary kinded polymorphism seems like an easy thing to do
07:22:05 <mm_freak_> in both java and .NET languages only type variables of kind * can be polymorphic, which makes polymorphism far less useful
07:22:59 <Eduard_Munteanu> mm_freak_: what do you mean, kind polymorphism / quantifying over kind variables?
07:23:39 <hpc> Eduard_Munteanu: meaning you can't do something like class Foo<T> { T<Integer> object; }
07:23:45 <hpc> i think
07:24:37 <Eduard_Munteanu> That quickly gets dangerously close to dependent types.
07:24:57 <mm_freak_> Eduard_Munteanu: huh? no
07:25:09 <mm_freak_> you have the Functor class in haskell, where the type variable is of kind * -> *
07:25:29 <mm_freak_> you can't have such a type variable in java/.NET
07:25:34 <Eduard_Munteanu> Ah.
07:26:25 <timthelion> mm_freak_: did you see my link?  They claim that your (`div`) example isn't actually a bug...
07:26:29 <hpc> wait, not even F# lets you have higher-kinded type variables?
07:26:29 <mm_freak_> so in fact in C# you can't implement mapM
07:26:39 <mm_freak_> timthelion: yeah
07:26:47 <mm_freak_> hpc: nope
07:26:57 <mm_freak_> at least not when i used it, but i doubt that that changed
07:27:15 <hpc> strange
07:27:30 <timthelion> mm_freak_: kind of shocking that he was able to respond that quickly quoting chapter and verse.
07:30:53 * hackagebot git-annex 3.20120825 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120825 (JoeyHess)
07:33:40 <Ornedan> I've got a program (irc bot / game server tracker) that seems to leak OS based on occasionally crashing with error message "failed to create OS thread: Cannot allocate memory". How does one go about debugging such problems in Haskell?
07:35:30 <hpc> Ornedan: what language is the bot written in?
07:36:02 <monochrom> perhaps it creates too many OS threads?
07:36:04 <Ornedan> Haskell
07:36:24 <hpc> oh right, forgot forkOS was a thing
07:38:35 <Eduard_Munteanu> Ornedan: try profiling, and look for allocations
07:45:53 * hackagebot highlight-versions 0.1.0.0 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.0.0 (BrentYorgey)
07:59:17 <timthelion> >:t reverse . reverse
07:59:22 <timthelion> > :t reverse . reverse
07:59:23 <lambdabot>   <no location info>: parse error on input `:'
07:59:27 <timthelion> :t reverse . reverse
07:59:28 <lambdabot> forall a. [a] -> [a]
07:59:57 <timthelion> > {- so why doesn't this work? -} reverse . reverse "hi"
07:59:58 <lambdabot>   Couldn't match expected type `[a]'
07:59:58 <lambdabot>         against inferred type `GHC.Types...
08:00:21 <timthelion> I'm passing it "hi" which is of type [Char] which should fit into [a]
08:01:51 <fmap> `reverse "hi"' isn't a function
08:02:16 <timthelion> fmap: so I need (reverse . reverse) "hi"?
08:02:22 <fmap> timthelion: yep
08:03:20 <timthelion> I've been confused by that all along...  I always thought it would be the same as in math class, like f.g(x) just without the parens...
08:03:40 <timthelion> and I could never get why that wasn't working...
08:04:00 <nobdraisentone> fmap: `reverse "hi"` is a function
08:04:15 <Clint> :t reverse "hi"
08:04:16 <lambdabot> [Char]
08:04:53 <timthelion> nobdraisentone: it's a value.  Functions can only have a subset of the type :: a -> b
08:06:05 <nobdraisentone> timthelion: where that definition of function is from?
08:07:20 * timthelion 's ass.
08:07:36 <nobdraisentone> wat
08:07:51 <timthelion> I made it up :D
08:08:13 <ion> @hoogle unsafeCoerce
08:08:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:08:17 <monochrom> it's haskell's definition
08:09:45 <timthelion> nobdraisentone: Actually, it's from Category theory.  Category theory says that "arrows" are direct one to one mappings of values to values.  And that functions are arrows.  And so therefor functions have to be direct one to one mappings from values to values.
08:10:00 <timthelion> Please correct me if I'm wrong on that.
08:10:36 <b0fh_ua> Hi haskellers! please advice - is there a library, which can parse HTTPD logs (common format)?
08:11:36 <fmap> nobdraisentone: no, `reverse "hi"' is a string
08:12:16 <timthelion> No one has yet told me I am wrong about category theory.  My explanation must have been TL;DR
08:13:12 <hpc> timthelion: oh, yeah i think you are wrong about the one-to-one bit of it
08:13:25 <nobdraisentone> fmap: but why value couldn't be a 0-arity function
08:13:26 <nobdraisentone> ?
08:13:30 <monochrom> I am too polite to say that category theory is unnecessary for this
08:13:38 <timthelion> hpc: ! really !  ?
08:13:43 <hpc> timthelion: consider constant functions
08:13:56 <timthelion> hpc: oh, many to one also, soory
08:13:56 <hpc> 1 => foo
08:13:59 <hpc> 2 => foo
08:14:02 * timthelion is an idiot.
08:14:07 <hpc> ;)
08:14:47 <monochrom> value can be a 0-ary function in another channel. just not here.
08:15:05 <nobdraisentone> monochrom: but why?
08:15:18 <monochrom> it is more convenient here
08:15:28 <nobdraisentone> It's a pity
08:15:29 <timthelion> nobdraisentone: because we have declared that we will use terminology consistent with Category theory :)
08:15:40 <mm_freak_> i think the definition of Arrow is quite arbitrary…  you can translate it to category theory, but it's not like there is a distinguished concept in CT
08:16:27 <monochrom> your time is better spent on whether 0 is a natural number or not
08:16:30 <timthelion> mm_freak_: I was just going by the term my CT textbook used to explane it.  I'm not sure if Arrows even exist as a destinct entity.  I mean, are there any Arrows that are not functions?
08:16:48 <mm_freak_> timthelion: of course
08:17:02 <timthelion> mm_freak_: example?
08:17:08 <monochrom> in this channel, 0 is a natural number. in some other channel, 0 is not a natural number. it's a pity.
08:17:14 <mm_freak_> timthelion: newtype Auto a b = Auto (a -> (b, Auto a b))
08:17:58 <nobdraisentone> http://www.reddit.com/r/haskell/comments/cs3gw/so_im_eating_breakfast_this_morning_posting_about/c0uu70s
08:18:01 <mm_freak_> timthelion: whole libraries (mostly FRP libraries) are based on that category, which is also an arrow
08:18:16 <timthelion> mm_freak_: in which the Arrow is Many to Many?
08:18:24 <mm_freak_> timthelion: what do you mean?
08:18:39 <timthelion> mm_freak_: Sorry, I'm confused already :)
08:19:09 <timthelion> mm_freak_: What are you claiming about Auto?  That it is an Arrow?
08:19:12 <nobdraisentone> monochrom: so, finally, all valid expressions in haskell are functions or values?
08:19:19 <mm_freak_> timthelion: 'Auto a b' represents a function that takes an input of type 'a' and results in a 'b' along with a new version of itself
08:19:23 <timthelion> nobdraisentone: values.
08:19:34 <mm_freak_> timthelion: yes, Auto is an arrow
08:19:45 <sheldonh> is there a premade data type that i can use in a function signature to say the function takes a list of Int or Double?
08:19:50 <nobdraisentone> timthelion: seems like not values only, lol
08:19:55 <timthelion> mm_freak_: and in what way is that not a function?
08:19:59 <mm_freak_> sheldonh: [Int]?
08:20:01 <sheldonh> i tried Num, but that's a class and raises an error
08:20:19 <latro`a> nobdraisentone, functions are definitely values in haskell
08:20:19 <mm_freak_> nobdraisentone: everything that has a type is a value
08:20:30 <monochrom> Num a => [a] -> ?
08:20:32 <mm_freak_> nobdraisentone: including functions…  every function is a value, but not every value is a function
08:20:40 <timthelion> sheldonh: not [Num] but Num a => [a] like monochrom  says.
08:21:03 <monochrom> you don't say what the function returns, so I don't know how to fill in the rest
08:21:16 <mm_freak_> timthelion: it's defined in terms of a function of course…  there are no arrows that are not defined based on a function, except one trivial one
08:21:24 <mm_freak_> timthelion: data VoidArrow a b
08:21:53 <sheldonh> monochrom: like so: http://pastebin.com/K6V9GRvX
08:21:56 <mauke> The paste K6V9GRvX has been copied to http://hpaste.org/73691
08:22:03 <timthelion> mm_freak_: but I was asking in terms of Category theory.  whether the set of all functions is equal to the set of all arrows or if there actually exist arrows that are not functions in the mathematical sense.
08:22:15 <sheldonh> monochrom: meh, i haven't shown enough in that paste, sorry
08:22:30 <k0ral> hello
08:22:46 <mm_freak_> sheldonh: that's just a regular type error
08:22:51 <k0ral> runX f doesn't compile for f :: (MonadX m) -> m ()
08:23:27 <monochrom> -> ? => ?
08:23:30 <mm_freak_> timthelion: the question doesn't seem to make sense…  every arrow is a category, but you could say that only categories where the morphisms represent functions can be arrows
08:23:34 <monochrom> and what is MonadX
08:23:53 <monochrom> or should I care?
08:24:08 <k0ral> monochrom: runReaderT MyContext f with f :: (MonadReader MyContext m) => m ()
08:24:46 <monochrom> runReaderT is not general. does not work for all MonadReader instances. like, runReaderT's type sig already says so
08:24:49 <timthelion> mm_freak_: I guess I'll have to read up more on my own.  IRC isn't the best medium.
08:24:51 <k0ral> monochrom: could not deduce m ~ ReaderT MyContext IO from the context (MonadReader MyContext m)
08:24:55 <mm_freak_> timthelion: more precisely you have an arrow C, if you can map functions to the morphisms of C…  i think an equivalent way to say that is that there must be a functor F : Set -> C
08:25:23 <mm_freak_> i think that's precise, because the arrow laws resemble that
08:25:28 <k0ral> monochrom: I must have misunderstood how to use MonadReader then
08:25:49 <k0ral> I thought is was a monad-agnostic way to say "I can read a context"
08:25:59 <mm_freak_> for example:  arr id = id; arr (f . g) = arr f . arr g
08:26:01 <k0ral> and that runReaderT was "use the Reader implementation"
08:26:06 <mm_freak_> sounds a lot like a functor =)
08:26:24 <k0ral> monochrom: where am I wrong then ?
08:26:29 <fmap> @type runReaderT
08:26:29 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
08:27:24 <k0ral> fmap: isn't there the same with a MonadReader-instance monad instead of ReaderT ?
08:27:43 <monochrom> there can be none
08:27:52 <fmap> i'm not sure this makes sense
08:27:53 <sheldonh> mm_freak_, monochrom: thanks, got it.
08:28:08 <monochrom> your actual code is where you are wrong
08:28:45 <Saizan> k0ral: have you shown us the code? the general principle is sound but that error means you're doing something else
08:29:37 <b0fh_ua> http://hpaste.org/73692 - could somebody please advice, what may be wrong here? I checked signatures of digit and many1 - it should bind together?
08:29:50 <k0ral> so, let me paste it
08:30:46 <Saizan> b0fh_ua: the problem is the MonomorphismRestriction there
08:31:16 <Saizan> b0fh_ua: either give a type signature for numPart or add {-# LANGUAGE NoMonomorphismRestriction #-} at the top of the file
08:33:03 <b0fh_ua> Saizan: cool, thanks!
08:35:39 <k0ral> monochrom, fmap, Saizan: https://gist.github.com/3467158
08:37:36 <monochrom> the type of onKeyPress means that the caller of onKeyPress chooses what m is
08:40:55 <k0ral> for the callee the choose, how should I do ?
08:41:01 <k0ral> s/the/to
08:42:21 <Saizan> k0ral: omit the signature and check which one ghci infers
08:43:23 <Saizan> but something like ErrorT HError (ReaderT Context IO) () instead of m ()
08:46:06 <k0ral> Saizan: isn't there a word missing in your last sentence ?
08:46:52 <k0ral> Saizan: now GHC doesn't complain anymore (when omitting the signature) but it doesn't show what it deducted
08:46:54 <Saizan> k0ral: "use", maybe?
08:47:14 <Saizan> k0ral: if you load the code in ghci you can :t onKeyPress
08:49:05 <k0ral> Saizan: I have to fix other issues first
08:49:26 <rosie> Where can I find some good documentation on the Hoogle command-line interface?
08:49:47 <k0ral> Saizan: and replacing m with an explicit monad means losing the monad-agnostic feature, right ?
08:50:29 <Saizan> k0ral: your code is not agnostic, so it'd better show in your type
08:51:29 <Saizan> k0ral: if you don't want to show which concrete monads you're using you could go higher-rank, but that's likely overkill
08:56:10 <merijn> Wait...there's a Hoogle command-line interface?
08:56:11 <k0ral> Saizan: I thought it was good practice to write the whole program with monad-agnostic functions, and to call runMonadT at the beginning of the main function
08:56:56 <shirt> class Foo a where foo :: Int -> a ; baz x = foo x ; qux = foo
08:56:57 <shirt> why is the definition for 'baz' good, but 'qux' gives an error?
08:57:04 <k0ral> Saizan: plus I don't want to care about in which order my monads are stacked
08:57:17 <hpc> shirt: you're hitting the dreaded monomorphism restriction
08:57:29 <merijn> shirt: My blind guess is dreadd monomorphism restriction
08:57:33 <hpc> shirt: basically, top-level definitions that "look like values" get their types restricted
08:57:41 <hpc> for a number of reasons, but mostly optimization
08:57:52 <hpc> "baz x =" looks like a function
08:57:58 <hpc> "qux =" looks like a value
08:58:02 <hpc> hence what you are seeing
08:58:13 <monochrom> k0ral, the type sig says that the caller chooses m. the internal code says that the callee chooses m. you can't let both caller and callee choose. they will choose conflicting things
08:58:14 <merijn> shirt: You have two options: 1) disable monomorphism restriction or 2) explicit type signature
08:58:16 <hpc> put a type signature on qux and the problem goes away
08:58:26 <merijn> (2 is the better option, IMO)
08:58:34 <rosie> Where can I find some good documentation on the data type "Name"?
08:58:59 <hpc> http://www.haskell.org/hoogle/?hoogle=Name -- rosie
08:59:42 <shirt> awesome, thanks guys! another question...
09:00:08 <k0ral> monochrom: I figured that from your previous remark, I'm still wondering how to make it so that only the callee chooses
09:00:26 <monochrom> use 2nd-rank type
09:00:38 <hpc> k0ral: a higher-ranked type
09:00:43 <rosie> hpc: I don't see an introduction on what they actually are. For example, the first line of documentation says, "For global names (NameG) we need a totally unique name, so we must include the name-space of the thing." Does that imply Name used to set global variables?
09:01:09 <hpc> the caller sees "this type is exactly this polymorphic"
09:01:15 <monochrom> f :: (forall m. MonadReader Int m => m ()) -> etc  now callee chooses, caller cannot choose
09:01:30 <hpc> and the callee has freedom to use any 'm' that fits, like in monochrom's example
09:01:51 <hpc> the callee can even use different 'm's in different places, so long as it typechecks
09:02:15 <shirt> class Foo a b where foo :: Int -> a ; bar :: Foo a b => Int -> a ; bar x = foo x
09:02:15 <shirt> this gives an error: "Could not deduce (Foo a b0) arising from a use of `foo' from the context (Foo x y) ..."
09:02:16 <k0ral> hpc: sounds great
09:03:36 <Ornedan> Eduard_Munteanu: Which runtime options for that? -p or something else?
09:04:50 <merijn> shirt: How does the compiler know which value b has in the function bar?
09:05:24 <shirt> merijn: bar should work for any value of b
09:05:31 <merijn> shirt: It can infer a from the expect result of calling foo, but there is not context to infer b from
09:06:00 <hpc> shirt: suppose you did something like
09:06:07 <hpc> > show (5 + 2)
09:06:08 <lambdabot>   "7"
09:06:13 * hackagebot CouchDB 1.2 - CouchDB interface  http://hackage.haskell.org/package/CouchDB-1.2 (ArjunGuha)
09:06:21 <merijn> shirt: Typeclasses rely on their being one specific value when a function is actually used. If there is no argument to infer b from you need to explicitly tell the compiler which b to use
09:06:24 <hpc> with the monomorphism restriction, it figures out that (5 + 2) :: Integer
09:06:38 <hpc> but if you don't have the monomorphism restriction (which we don't in your example)
09:06:42 <monochrom> plus defaulting
09:06:45 <hpc> then it doesn't know what kind of number it is adding
09:06:54 <hpc> > show (5.0 + 2)
09:06:55 <lambdabot>   "7.0"
09:07:00 <hpc> > show ((5 % 1) + 2)
09:07:02 <lambdabot>   "7 % 1"
09:07:19 <hpc> > show ((5 :: Int -> Int) + 2)
09:07:20 <lambdabot>   "*Exception: show: No overloading for function
09:08:07 <hpc> if it can't figure out what kind of a Foo it is dealing with, it can't figure out what behavior it should display
09:08:12 <rosie> hpc: My question is super basic: What's a Name used for? The documentation doesn't appear to provide the answer, it's more of a reference. It looks like I can declare names in certain namespaces. Can you point me to any alternate documentation?
09:08:38 <merijn> This should work, no? "bar x = (foo :: Foo a Char => Int -> a) x"
09:08:44 <ion> newtype Name = Name String
09:08:47 <ion> name = Name "rosie"
09:08:55 <ion> Now it’s being used to store your nick.
09:09:10 <shirt> hpc, merijn: i'm still a bit confused. how do i change the type signature of 'bar' so that it will compile?
09:09:16 <rosie> ion: Why use Name rather than String?
09:09:25 <monochrom> where did you find "Name"? there are many. they are all unrelated.
09:09:36 <monochrom> or should I care?
09:09:40 <neutrino2000> shirt: declare the right type for "bar" and then fix type incompatibilities
09:09:52 <rosie> monochrom: Language.Haskell.TH.Syntax
09:09:53 <neutrino2000> they will be limited to how "bar" is defined
09:10:04 <monochrom> ok that's a start
09:10:56 <shirt> neutrino2000: i want 'bar' to have the type bar :: Foo a b => Int -> a
09:11:04 <ksf> anyone ever tried constructing extensible records via a parametrised monad?
09:11:14 <merijn> shirt: Think of the compiler having a dictionary of type tuples to datatypes containing functions, whenever you use a function from the Foo typeclass it will do a lookup for the type tuple (a,b) and use functions from the returned datatype (i.e. the instance)
09:11:53 <merijn> shirt: If you don't tell the compiler which value b has it cannot do that lookup, unless you annotate all uses of bar with an explicit type signature telling which b you expect
09:12:44 <merijn> shirt: Alternatively, you could do "class FooHelper a where bar = ..." combined with "class FooHelper a => Foo a b where {- remaining functions -}"
09:12:50 <monochrom> it stores identifiers and it remembers whether the identifier is a global name, or a local name or whatever. identifiers are more complex than you think. Name is being safe and comprehensive
09:13:09 <paolino> shirt, if the choice of b is implied by the choice of a then you have other choices
09:13:25 <shirt> paolino: that is indeed the case
09:13:38 <rosie> Why use Name rather than String?
09:13:42 <merijn> shirt: That way bar is defined separate from b, unless different b's should result in different implementations of bar
09:13:52 <merijn> In which case my suggestion is worthless :p
09:14:13 <merijn> shirt: Can you maybe explain a bit more concretely what you want to do?
09:14:41 <paolino> shirt then you can choose functional dependencies or type families, or give more details on the code
09:15:06 <shirt> merijn, paolino: thanks, i'll paste some code in a pastebin...
09:18:41 <hpaste> shirt pasted “ambiguous type variables” at http://hpaste.org/73694
09:20:09 <rosie> It must be obvious what a Name is in Haskell, because I can't find anyone else asking this question online: "Why use Name rather than String"? It's probably just hard to search for. Can I have any advice on finding documentation outside Hoogle?
09:20:59 <paolino> shirt what are the possible case for mt ? STM and IO ?
09:21:24 <sheldonh> i'm doing the exercises in real world haskell. i made a list mean calculator that works for ints. is there an easy way to make it work for fractional values too? http://pastie.org/4586748
09:21:25 <ksf> rosie, name cassies more information than a string
09:21:34 <shirt> paolino: no, a custom implementation of mine
09:23:17 <ksf> rosie, for example, Name knows whether a name is qualified and a number of internal things I don't grok from the source atm.
09:23:25 <Eduard_Munteanu> Ornedan: yeah, though there are other useful modes I don't remember right now
09:23:30 <paolino> shirt: for sleep5 to compile mt and v must be implied by ma
09:24:03 <shirt> paolino: i am ok with that requirement. what do i need to do?
09:24:39 <rosie> ksf: alright, I can declare a Name as a NameFlavour. What other information can a Name carry, and why would I want to use it?
09:24:47 <paolino> shirt: add a fundep in the class or write a type family to relate those
09:25:20 <ksf> rosie, and even if it didn't carry additional information having two separate types might still be sensible. to keep you from confusing strings that are names from strings that are filenames, file contents, or whatever.
09:25:28 <paolino> @where ghc type families
09:25:28 <lambdabot> http://haskell.org/ghc
09:25:33 <Eduard_Munteanu> shirt: you could make it work for any Fractional if you want to
09:25:59 <Eduard_Munteanu> Erm.
09:26:02 <Eduard_Munteanu> sheldonh: ^^
09:26:12 <merijn> sheldonh: As far as I can tell all you need to do to make it work for fractional values is change the type signature
09:26:14 <rosie> ksf: oh! That makes sense. Is there any other documentation I can look at?
09:26:16 <shirt> paolino: thanks, i'm not familiar with either of those and will read about them. which of the two do you think is most appropriate?
09:26:26 <ksf> rosie, it could know which namespace it is in, for example.
09:26:39 <ksf> as in Type vs. Constructor namespace.
09:27:03 <merijn> sheldonh: Your listSum uses "[Int] -> Int", you probably want to change that to something like "Num a => [a] -> a"
09:27:04 <sheldonh> merijn: yeah, i've been looking for a type that represents fractional or non-fractional numbers
09:27:21 <ksf> rosie, I fear TH is underdocumented.
09:27:28 <sheldonh> merijn: ah. i haven't learned about => yet :)
09:27:51 <Eduard_Munteanu> It's going to be a typeclass rather than a type.
09:28:04 <merijn> sheldonh: "Num a => [a] -> a" means "for all types a that are an instance of the typeclass Num" this is a function of type "[a] -> a"
09:28:17 <sheldonh> oooooo
09:28:30 <paolino> shirt fundeps are more intuitive. but for your case an associated type families (which is equivalent) is the new way
09:28:42 <merijn> sheldonh: Where Num is the typeclass for numerics, including Int, Double and all sorts of fractional values
09:28:55 <merijn> :t 1
09:28:56 <lambdabot> forall t. (Num t) => t
09:29:02 <merijn> :t (+)
09:29:03 <lambdabot> forall a. (Num a) => a -> a -> a
09:29:12 <shirt> paolino: thanks!
09:29:21 <Eduard_Munteanu> :t (/)
09:29:22 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:29:24 <sheldonh> merijn: okay tanks. i might actually park this until i get to typeclasses then. good to know there was a way out, though :)
09:29:36 <paolino> shirt: you are welcome
09:30:23 <rosie> ksf: Alright, thanks for your help!
09:30:26 <merijn> sheldonh: As you can see, things like (+) are already defined using the Num typeclass, it's just that your type signatures are telling GHC to be more struct then necessary
09:30:36 <merijn> sheldonh: Just deleting the type signatures will probably also work
09:30:51 <merijn> sheldonh: Because then GHC will automatically try to be as generic as possible
09:32:48 <merijn> sheldonh: btw, you can leave out the middlecase in listMean, as it should be identical to the last one
09:33:18 <sheldonh> merijn: premature optimisation :)
09:34:08 <merijn> And unlike many other languages, adding "0.0" isn't necessary to make it a double. Just writing 0 is sufficient, the compiler will infer that you meant Double from the function's type signature
09:34:57 <merijn> > (show 0, show (0 :: Double))
09:34:58 <lambdabot>   ("0","0.0")
09:35:16 <sheldonh> merijn: cool. taking out the signatures and the fromIntegral works. now i'll try add the signatures back as an exercise. thanks!
09:35:36 <merijn> np
09:48:18 <mreh> cabal: Couldn't read cabal file "ixset/1.0.3/ixset.cabal"
09:48:29 <mreh> I read all the chat logs on this and still have no idea what to do
09:48:51 <dcoutts_> mreh: one (not lovely) solution is to upgrade your cabal
09:49:42 <mreh> would this somehow affect cabal-dev?
09:50:03 <byorgey> mreh: cabal-dev is just a wrapper around cabal
09:50:15 <byorgey> so yes
09:50:17 <mreh> cabal-dev says it was built with 1.14.0
09:50:37 <rosie> If arbitrary conversions between types aren't allowed in Haskell, why do the type representations in Data.Typeable "define a type safe cast operation?
09:50:43 <mreh> but my cabal version is 1.8.0.2
09:50:51 <mreh> just what my shell finds
09:50:57 <mreh> i've got both installed
09:51:19 <dcoutts_> mreh: cabal-dev uses the Cabal lib but it also shells out to the cabal prog
09:51:19 <hpc> rosie: the cast is basically "if source and destionation types are the same then (Just value) else Nothing"
09:51:36 <hpc> and it's an evil trick
09:52:17 <mreh> so upgrade to 0.14.0?
09:52:23 <mreh> (cabal-install)
09:52:56 <rosie> hpc: Thanks. Do you mean String compared with String will return Just String? So there's no actual type conversion?
09:53:04 <hpc> rosie: yeah
09:54:12 <byorgey> rosie: Typeable isn't for converting between types, it's for recovering the type of something whose type you have forgotten
09:55:56 <rosie> hpc and byorgey: Thanks. Why not use :=: to check type equality? Do you mean that we just want to be able to print the representation of the type?
09:56:10 <byorgey> rosie: what is :=: ?
09:56:32 <rosie> Defined in Data.Type.Equality: "Type equality. A value of a :=: b is a proof that types a and b are equal. By pattern matching on Refl this fact is introduced to the type checker."
09:57:46 <mreh> Warning: Falling back to topdown solver for GHC < 7.
09:58:17 <rosie> Why not use typeOf?
09:58:28 <byorgey> rosie: oh.  :=: is not for checking type equality, it's for passing around proofs of type equality.
09:58:57 <ksf> ...on the type level.
09:58:57 <byorgey> rosie: typeOf is from Typeable, that'
09:59:05 <byorgey> rosie: typeOf is from Typeable, that's in fact what type safe cast uses
09:59:14 <ksf> ...returns its result on the value level.
09:59:34 <byorgey> good point, ksf
09:59:37 <ksf> type-level type-equality requires -XOleg
09:59:39 <rosie> byorgey: gotcha. What does it mean to "pass around a proof"?
09:59:51 <bobTbuilder> is there a sort function in hci?
09:59:52 <hpc> ksf: that needs to be a thing
10:00:00 <bobTbuilder> like in try haskell.org ?
10:00:22 <byorgey> bobTbuilder: import Data.List
10:00:40 <byorgey> rosie: some values can be considered "proofs" in some sense.
10:00:44 <rosie> ksf: So :=: checks types on type level and typeOf tells you the type on the data level?
10:00:47 <bobTbuilder> thank you
10:00:59 <byorgey> rosie: since Refl has type  a :=: a,  if you have   Refl :: X :=: Y  then it is a proof that X and Y are the same type
10:00:59 <rosie> byorgey: A proof as in, a Bool?
10:01:10 <byorgey> rosie: Bools are not proofs.
10:01:15 <ksf> :=: doesn't check, it merely allows you to pass on the fact that you know that it's equal.
10:01:31 <ksf> rosie, a proof as in "not a type error"
10:01:42 <byorgey> rosie: Bools are the result of running some sort of check.  But once you have run it you don't know where the Bool came from anymore.
10:01:56 <ksf> (programs are theorems, types are proofs)
10:02:09 <byorgey> rosie: you may be interested in reading http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
10:02:17 <hpc> ksf: you mean, types are propositions, programs are proofs
10:02:26 <hpc> ?
10:02:29 <ksf> yes.
10:02:42 <ksf> amonts to the same, tohugh.
10:02:50 <ksf> er no.
10:02:53 <byorgey> ksf: no, you had it backwards
10:02:54 <monochrom> no, you have them swapped
10:03:04 <bobTbuilder> in  lyh it has an example: 4 'elem' [3,4,5,6]. But in ghci, it doesn't work.
10:03:06 <monochrom> but theorem = proposition
10:03:07 * ksf was just looking at theorem <-> proposition
10:03:08 <rosie> byorgey: thanks! I'm off reading it...
10:03:17 <byorgey> bobTbuilder: use backquotes, `elem`, not single quotes like 'elem'
10:04:10 <monochrom> 4 `elem` [3,4,5,6]
10:04:19 <hpc> > 4 `elem` [3,4,5,6]
10:04:20 <lambdabot>   True
10:04:42 <bobTbuilder> how to write backquotes?
10:04:52 <ksf> the same key as ~
10:04:53 <hpc> it's to the left of the '1' key
10:04:55 <monochrom> programmers understand that you have to use exactly the right symbol rather than a look-alike symbol
10:05:00 <nand`> depends on your keyboard layout
10:05:09 <monochrom> you can copy-paste mine
10:05:32 <maloi> yeah always have ` in the clipboard
10:05:37 <nand`> monochrom: (unfortunately people still mix up tabs and spaces?)
10:05:43 <bobTbuilder> oh ok
10:05:45 <bobTbuilder> got it
10:06:05 <monochrom> I'm being sarcastic in "programmers understand that you have to use exactly the right symbol rather than a look-alike symbol"
10:06:14 <spaceships> do you need a prescription for the learn-haskell-type-system pills, or can you get them over the counter?
10:06:17 <bobTbuilder> "you can copy-paste mine"
10:06:23 <bobTbuilder> I would rather prefer not
10:06:33 <bobTbuilder> my clipboard doesn't have enough space as is
10:06:36 <bobTbuilder> but I found it
10:06:37 <bobTbuilder> thanks\
10:06:41 <monochrom> from watching #haskell you know that programmers are the worst in understanding it
10:06:47 <hpc> heh
10:07:09 <hpc> it gets worse in #agda
10:07:23 <hpc> in some places you need to use ':' and in some, '\:'
10:07:58 <hpc> the difference in a default emacs installation is two or three pixels
10:11:14 * hackagebot zip-conduit 0.2 - Working with zip archives via conduits.  http://hackage.haskell.org/package/zip-conduit-0.2 (TimCherganov)
10:15:32 <edenc> monochrom: I don't understand what you said, if you write haskell, you're a programmer by definition
10:15:58 * nand` .oO( What is the definition of ‘programmer’? )
10:16:14 * hackagebot test-framework 0.6.1 - Framework for running and organising tests, with HUnit and QuickCheck support  http://hackage.haskell.org/package/test-framework-0.6.1 (MaxBolingbroke)
10:16:36 <mgsloan> bobTbuilder:  speaking of look-alike symbols, my nickname used to be "botbuilder".  Chose it back in my blitzbasic and mindrover (competitive robot programming sim) days), when I was I think maybe 10 years old ?
10:17:30 <mgsloan> edenc: so now configurers-of-window-management-system are programmers? ;)
10:17:35 <edenc> nand`: "a person who writes computer programs" according to webster's
10:18:09 <nand`> edenc: that much I can agree with, but the definition of ‘computer program’ may be interesting :)
10:18:35 <edenc> yeah, we can drill down into meta-language all day long
10:19:34 <edenc> mgsloan: if said window-management-system is xmonad, then yes, you must be a programmer to "configure" it
10:20:19 <mgsloan> :D I dunno, I think plenty of non-programmers, yet reasonably technical people, use and configure xmonad
10:20:36 <mgsloan> mostly by example / copy-pasting together other people's profiles
10:20:45 <mgsloan> s/profiles/configs/
10:20:49 <edenc> mgsloan: isn't that what the php folks do? they're still programmers
10:21:04 <nand`> how complex does something have to be to qualify as a ‘computer program’? what separates programs from, say, configuration files (of various sorts)? Does a trivial program in some programming language count? (eg. does running ‘touch’ make me a programmer?) etc.
10:21:07 <rosie> byorgey: What do these function declarations mean? "Thus, = : (int->int) x (int->int) -> prop expresses equality, but = : (int->int)->(int->int)->bool cannot satisfy the specification just given. " Is the takeaway of the article that you should wait until the last possible moment to evaluate a predicate, so that you know where the true/false bit came from?
10:21:12 <hpc> mgsloan: that's how i configure vim and screen
10:21:29 <mgsloan> hmm, I suppose.  Are HTML designers that use the markup directly "programmers"?
10:21:30 <hpc> well, how i used to configure vim, at least
10:21:45 <edenc> mgsloan: yes
10:21:46 <hpc> once i figured out that vim just executes the config, things got easier
10:21:48 <mgsloan> hpc: me too!  And most of my xmonad.hs too
10:21:58 <nand`> rosie: the point of the article is that you shouldn't use Bool+conditionals at all; in favor of approaches like pattern matching
10:22:14 <byorgey> rosie: no, I think the takeaway of the article is that in many cases you should avoid using predicates entirely.  For example, instead of calling 'isJust' to see whether a Maybe value is Nothing or Just, simply pattern-match on it
10:23:55 <nand`> one good example of why this can make a difference is that in the case of isJust+fromJust it's to make a programmer error (mixing up then/else) resulting in a crash; but if you use pattern matching instead there's a static guarantee you did not accidentally fromJust a Nothing value
10:24:13 <nand`> it's possible to make*
10:25:00 <edenc> nand`: running touch isn't writing a program
10:25:40 <nand`> since you are extracting information at the same time you branch on it (with pattern matching), there's no separation of steps like there is with using some Bool-returning function + further reprocessing
10:26:22 <nand`> edenc: but writing a configuration file is?
10:26:53 <edenc> nand`: yes
10:30:04 * timthelion finds managing his config files to be much harder than programming.
10:30:05 <jmcarthur> edenc: my wife uses xmonad, configures it mostly by herself, is not a programmer
10:30:29 <timthelion> jmcarthur: you are a very lucky man to have a wife who is not afraid of such things.
10:30:36 <edenc> jmcarthur: she is, by definition, you can choose to view it some other way if you please
10:30:38 <nand`> edenc: so if I write an empty configuration file, I'm both a programmer and not a programmer?
10:30:54 <jmcarthur> edenc: what is she programming, exactly?
10:30:58 <monochrom> why are you arguing over vain definitions?!
10:30:58 <t7> you are in a superposition
10:31:10 <edenc> jmcarthur: a computer
10:31:14 <hpc> there's nothing in the config to observe, so your wavefunction can't collapse
10:31:41 <timthelion> preflex: give hpc +1 karma
10:31:46 <zhulikas> are there any projects I could contribute to with Haskell? :)
10:31:54 <ion> Yes.
10:31:55 <hpc> unfortunately, quantum computing hasn't developed to the point of having quantum programmers
10:32:04 <hpc> so we can't manipulate the probabilities in any way, either
10:32:19 <typoclass> hpc: i hear quantum config file writers would be okay too
10:32:41 <timthelion> hpc: what about that guy who wrote the quantum factorization program, is he not as much a programmer as Ada Lovelace? Is he not a quantum programmer?
10:32:41 <hpc> nand`: im sorry to have to tell you this... but you have to become a physicist
10:33:13 <nand`> no way :(
10:34:12 <monochrom> Physical Harmonics Programming = PHP
10:34:30 * timthelion finds the types of photons to be a bit doggey...The whole dynamically typed particles/waves.  Could never become a physicist.
10:34:47 <hpc> COmmon BOson Language
10:34:48 <hpc> COBOL
10:35:22 <edwardk> is there a tutorial on how to use criterion as it exists today out there somewhere?
10:35:29 <edenc> though COBOLA would be funny
10:35:57 <atriq> COBOL is the language of my ancestors
10:36:05 <rosie> hand` and byorgey: Thank you! hand', thanks especially for the clear example
10:36:08 <edenc> Enhanced BOson LAnguage would be awesome
10:36:15 * hackagebot highlight-versions 0.1.1.0 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.1.0 (BrentYorgey)
10:36:31 <timthelion> That is a good question.  Is a good analogy for the wave particle duality, that they are Dynamically/Contextually typed???
10:37:06 <nand`> ‘dynamically typed’ ugh
10:37:19 <timthelion> nand`: no seriously, the universe is dynamically typed!
10:37:26 <timthelion> think about it!
10:37:35 <monochrom> it is a good analogy for bikeshed colours
10:37:51 <timthelion> monochrom: ?
10:38:32 <monochrom> unnecessary dichotomy
10:39:00 * timthelion is again confused by the things strangers say on IRC.
10:39:50 <Mortchek> timthelion, all you can see is the result of the universe running; you have no idea what language it was written in. ;)
10:40:06 <timthelion> Mortchek: unless it throws an exception at me.
10:40:39 <Mortchek> I'm pretty sure the universe handles most if not all of its exceptions. Then again, perhaps that is how it will end - an unhandled exception.
10:40:40 <timthelion> Wait, if the universe becomes _
10:40:45 <timthelion> _|_ then I do too.
10:40:52 <monochrom> ok, an analogy is "a phone satisfies the sender-receiver duality. sometimes it acts like a sender, sometimes it acts like a receiver. it's dynamically typed!"
10:40:56 <edenc> Mortchek: it's written in perl, according to xkcd
10:41:11 <Mortchek> edenc, yeah well, he can't know either :P
10:41:17 * hackagebot acid-state 0.7.2 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.7.2 (DavidHimmelstrup)
10:41:41 <nand`> explains all the natural disasters and black holes and stuff
10:42:19 <monochrom> but you wouldn't even entertain the idea of "sender-receiver duality". the "duality" is just a wrong dichotomy "sender vs receiver" leading to all kinds of hilarious conclusions
10:42:23 * geekosaur would have guessed php, actually...
10:42:31 <timthelion> nand`: you think G_D WANTED to write the prefect universe, but just didn't test it well enough first?(thus natural disasters..)
10:42:52 <monochrom> at least, it's a wrong dichotomy to apply to phones
10:43:01 <edenc> monochrom: a phone is actually two static-typed devices packaged under a façade layer
10:43:24 <edenc> but yeah, as long as you don't open it, it doesn't matter
10:43:41 <hpc> a boolean is actually two static unit types packaged under a façade layer
10:43:46 <hpc> the only static type is ()!
10:44:00 <nand`> ()+(), clearly
10:44:14 <edenc> boobs
10:44:23 <timthelion> hpc: what is the kind of ()?
10:44:34 <hpc> timthelion: ()
10:44:36 <hpc> obviously
10:44:46 <nand`> ()₂
10:44:48 <nand`> clearly
10:44:49 <hpc> () :: () :: () :: () :: ...
10:45:11 <timthelion> is it true that ghci does not have a :k to go along with :t?
10:45:19 <hpc> ghci has :k
10:45:19 <monochrom> it is not true
10:45:24 <hpc> :k Maybe
10:45:25 <lambdabot> * -> *
10:45:34 <timthelion> :k ()
10:45:35 <lambdabot> *
10:46:03 <timthelion> Cool
10:46:44 <timthelion> I'm 22 years old already, I'm too old to be learning this stuff
10:47:34 <edenc> timthelion: I can tell you one thing, if G_D wrote it in 7 days, he clearly didn't use java
10:47:56 <edenc> nor C++
10:49:13 <timthelion> edenc: that's not true, especially considering he trashed it once Noah came arround.  He was like "ya know what Noah, I'm serializing you because the rest of the human race is a bunch of spaghetti code!"
10:49:28 <n00b6502> you thing nature uses garbage collection? i dont thinkso
10:49:47 <edenc> yeah it does, bacteria
10:50:03 <Dashkal> Is it straightforward to get a cross compiling ghci chain running?  Context: I want to compile for my raspberry pi on an amd64 system.
10:50:07 <timthelion> n00b6502: Probably not.  Given conservation of energy, most likely the univese is written in Core Wars code.
10:50:29 <bobTbuilder> how old are you guys?
10:50:31 <timthelion> Dashkal: ghci or ghc?
10:50:42 <Dashkal> sorry, ghc itself.  repl not necessary
10:50:44 * timthelion already revealed that sensitive bit of information.
10:50:52 <n00b6502> bacteria might use 'garbage colection' to degrade its unused proteins but the underlying systems that build the garbage collectors themselves dont
10:50:52 <ion> “G_D”?
10:51:02 <monochrom> I am 160 years old. I supervised Church's thesis.
10:51:13 <Ralith> timthelion: nonsense, you are never too old to learn haskell
10:51:21 <edenc> bobTbuilder: what type do you want that information in?
10:51:39 <ion> If i had a dog, i’d name her D-g.
10:51:39 <bobTbuilder> int
10:51:43 <n00b6502> i liked the wolfram idea that speculated the base level of the universe was actually a simple computing system implementing the laws of physics in software
10:51:48 <timthelion> ion: Since this is #haskell and not -blah I figured I'd assume some level of Christianity, and some people are offended by the word GOD spelt with vowels.
10:51:55 <bobTbuilder> monochrom: aren't you a bit to old
10:51:56 <bobTbuilder> ?
10:52:14 <n00b6502> god is spelt n a t u r e
10:52:16 <Dashkal> "too old to learn" <-- what a strange concept
10:52:22 <nand`> I thought G_D were some sort of initials
10:52:31 <Ralith> timthelion: but they wouldn't be offended by the obvious self-censor?
10:52:44 <bobTbuilder> monochrom: you would be like 70 years old when he wrote his thesis
10:52:54 <nand`> Ralith: people that get offended over this sort of thing don't think very logically
10:53:02 <Ralith> fair point
10:53:04 <timthelion> Ralith: How am I supposed to know, I've never been to a church service in my life save for one funeral.
10:53:08 <Ralith> still, let them be offended :P
10:53:44 <Dashkal> mmm, the wiki suggests skipping the CC chain and just going with qemu, but I can't help but suspect that emulating arm on x86 might not be the fastest way to do a build system.
10:54:12 <bobTbuilder> why are youasking this on Haskell?
10:54:30 <timthelion> Dashkal: do as the wiki says.  You will waste more time doing things wrong, then compiling.  As far as I know it hasn't been done yet.
10:54:35 <bobTbuilder> CC? C? C /= Haskell
10:54:40 <Dashkal> bobTbuilder: cross-compilier
10:54:47 <Dashkal> I want ghc on x86 to produce ARM code.
10:54:53 <bobTbuilder> oh
10:54:53 <bobTbuilder> ok
10:55:11 <bobTbuilder> do they have ghc compiled for arm?
10:55:24 <n00b6502> isn't there LLLVM backend
10:55:26 <Dashkal> Yes.  I can actually install the thing to my raspberry pi, but the ram limitations make this problamatic
10:55:30 <n00b6502> that soounds like the best bet
10:55:48 <Saizan> the problem is that ghc doesn't officially support cross-compilation, there might be some patches for ARM around though
10:56:00 <Dashkal> Yeah, that's what I feared the case would be.  qemu it is
10:56:03 <Ralith> nand`: llvm is not a portability layer.
10:56:11 <Ralith> er
10:56:12 <Ralith> nand`:
10:56:13 <Ralith> gaah
10:56:16 <Ralith> n00b6502:
10:56:20 <Dashkal> tab completion is fun!
10:56:24 <Ralith> :P
10:56:25 <timthelion> Dashkal: I saw a bug report about it on track: http://hackage.haskell.org/trac/ghc/ticket/6154 , http://hackage.haskell.org/trac/ghc/ticket/6169
10:56:39 <Dashkal> But meh, I refuse to write in python, and that's what the rpi really wants me to use.
10:56:56 <n00b6502> instead of supporting a gazillion CPUs isn't it better for haskell to target say x86 and llvm
10:57:11 <timthelion> n00b6502: why not do both ?????
10:57:28 <Dashkal> I dunno, haskell on arm is pretty valuable.  Certainty in your code does not suck in embedded systems.
10:57:39 <Saizan> n00b6502: targetting llvm isn't a solution, because you still produce architecture specific code because of word sizes and other details
10:58:14 <n00b6502> llvm transformations can handle a lot
10:58:35 <bobTbuilder> So far I used ghci only as interpreter, so I know nothing about it. Does it compile to C or Assembly?
10:58:38 <n00b6502> llvm is pretty dammn good
10:58:53 <Dashkal> bobTbuilder: all of the above, but the primary target is native code.
10:58:54 <Ralith> n00b6502: they cannot handle portability, because LLVM IR is lossy with regard to Haskell.
10:58:54 <n00b6502> i'd have thought the REPL would be interpretted
10:59:16 <timthelion> n00b6502: nope, the REPL compiles without optimization.
10:59:18 <Dashkal> nah, it just compiles on the spot.
10:59:38 <Dashkal> well, how about I find out if this ram limitation actually matters...
10:59:45 <Dashkal> time to try science!
10:59:46 <n00b6502> so haskell's lowest level is this STG malarchy
10:59:58 <timthelion> Dashkal: you saw the links I sent you?
11:00:19 <Saizan> ghci inteprets bytecode, which can also call compiled code
11:00:30 <Dashkal> timthelion: No, missed that.  clicking now
11:00:39 <timthelion> Dashkal: RAM won't be a problem if you use a 16gb SDHC card and give 6 gigs to the SWAP :)
11:00:58 <n00b6502> i remeain worried by the amount of intermediate going through memory a lazy graph-machine must do compared to traditional languages
11:01:05 <bobTbuilder> Holy crap, ghc user guide is 300 pages long
11:01:21 <mreh> it's unecessary to read them all
11:01:24 <Dashkal> 6 gigs of swap on an sd card *shudder* I could probably troubleshoot qemu faster than a decent sized compile :P
11:01:41 <Dashkal> Buuuut, an external drive might work
11:01:58 <n00b6502> So if LLVM isn't sufficient for haskell backend, does that mean haskell needs its own extensive per-cpu reworking
11:02:15 <n00b6502> nicluding fretting about pipeline details
11:02:21 <obk> Does anyone know how to install cabal-install (presumably 0.16.0) with ghc-7.6 (development head)?
11:02:35 * obk is hunting down a GHC GC bug that crashes the generated binaries
11:02:43 <mreh> oh
11:03:02 <timthelion> Dashkal: in what way would an external drive be faster than SD?
11:03:51 <Dashkal> Unless sd tech took a dramatic performance leap when I wasn't looking, my spinning platter drive is going to be faster for many small reads/writes
11:03:54 <obk> timthelion: The physical interface to an SD card is very slow compared to the SATA interface (or whatever) to a hard disk.
11:04:32 <Dashkal> also the media dedregation issue with sd cards.
11:04:40 <hpc> don't mistake SD with solid-state :P
11:04:43 <Dashkal> however you spell that
11:04:46 * hpc does that a lot
11:05:02 <timthelion> hpc: SD *is* a form of solid-state memory...
11:05:22 <mreh> those useless laymen can't tell the difference!
11:05:25 <hpc> well, don't confuse it for an SSD ;)
11:05:33 <timthelion> hpc: there you go :)
11:05:58 <obk> timthelion: yes, SD is solid state, but not all solid state is equal. Even SSDs have very different speeds depending on their controllers.
11:06:32 <hpc> obk: at this point most SSDs have similar hardware performance, and the most significant differences are in firmware
11:06:57 <ocharles> anyone want to indulge me in some type trickery? (: I'm trying to implement type indexed products using the new DataKinds extension, with the hope that I can avoid type classes, mostly as an experiment. So far I have: https://gist.github.com/0570d799026d69c0382f
11:07:10 <ocharles> We're all good, up to line 39, where it doesn't type check
11:07:21 <obk> Yes, they are converging. Still, there are older ones still on the market. Performance can be 2x/0.5x (depends on which side you are :-)
11:07:51 <ocharles> I need way to change =? to say 'the head of the record is x, or x is in xs', and i'm not quite sure how to do that
11:07:52 <hpc> ocharles: one stylistic note, you can compress all the extensions into {-# LANGUAGE Foo, Bar, Baz #-}
11:08:07 <ocharles> hpc: yea I know, haskell-mode added them for me so I haven't cleaned them up
11:08:15 <ocharles> I doubt I even need them all either atm
11:08:24 <ocharles> certainly don't need overlapping instances :)
11:08:25 <hpc> ah, cool
11:09:01 <ocharles> but it seems that the moment you define Record as a single data type, rather than separate RNil and RCons data types, you can't create special type classes instances that make HList do its magic
11:12:01 <ocharles> I wonder if there's some trickery with ConstraintKinds that can be done to add some magical context to =?
11:15:18 <shirt> @seen paolino
11:15:18 <lambdabot> Unknown command, try @list
11:15:50 <geekosaur> use preflex
11:16:15 <timthelion> preflex: seen paolino
11:16:16 <preflex>  paolino was last seen on #haskell 1 hour, 46 minutes and 40 seconds ago, saying: shirt: you are welcome
11:16:18 <monochrom> I think people dilberately have multiple {-# LANGUAGE one_thing_here_only #-} to fit a fairly arbitrary idea of what "diff" means
11:17:43 <hpc> monochrom: it can make it easier to eyeball, i suppose
11:17:53 <ocharles> Oh, I know why I had OverlappingInstances. The following is possible and type checks: https://gist.github.com/94f16505b091eec2cc5e
11:18:16 <ocharles> I dunno how evil that extension is, but I suppose it's not in line with my "do it without type classes!" goal either :)
11:19:34 <shirt> i'm using type families: class Foo a where { data Bar a; ... }
11:19:34 <shirt> how can i make it so that "Bar m" is a Monad instance?
11:20:01 <edwardk> ok, benchmarking shows the style of recursion used by lens is about 5-10% slower than that provided by uniplate, which is consistent with what i expected
11:20:22 <edwardk> but i think i have some room for improvement for the Data traversals because they are about 80% slower
11:22:18 <monochrom> "Bar m" does not refer to one single type. so, cannot be done
11:22:39 <timthelion> edwardk: Are you sure that constant procentages are valid?  Mostly, when there is an 80% slowdown form slow lists, there will be a 99% slowdown for long lists and vice versa, aka O(n^something)  an 80% difference on a constant O(n) seems unbelievable to me.
11:22:59 <shirt> monochrom: i want to make it so that all instance of "Bar" are required to be also Monad instances
11:23:20 <edwardk> timthelion: well, its mostly a big constant factor caused by the different way i do traversals, i pass in a function, they build and tear down the structure
11:23:26 <edwardk> it seems to hold over a wide array of inputs
11:23:46 <timthelion> that must be a very big constant factor :/
11:23:54 <monochrom> then I don't know
11:24:21 <edwardk> the 5-10% difference is because i pass in a function, the 80% one may be because i screwed up the hitmap
11:24:36 <edwardk> this is why we benchmark ;)
11:25:59 <jmcarthur> shirt: class Monad (Bar a) => Foo a where { data Bar a; ... }
11:26:23 <jmcarthur> shirt: will require FlexibleContexts or somesuch i think
11:26:33 <edwardk> some tweaks got it down to only 50% slower
11:26:42 <jmcarthur> oh wait
11:26:52 <jmcarthur> shirt: what kind does Bar have?
11:27:03 <edwardk> keep in mind the data traversals are 5x slower than the handwritten ones and using lens its a _lot_ easier to compose the handwritten traversals
11:27:03 <jmcarthur> Bar :: * -> * ? or Bar :: * -> * -> * ?
11:27:36 <shirt> jmcarthur: "data Bar a :: * -> * -> *"
11:27:45 <jmcarthur> oh, okay
11:28:13 <jmcarthur> not 100% certain how to write that constraint
11:28:30 <jmcarthur> if it was  data Bar a :: * -> *  my suggestion would work
11:28:36 <edwardk> @tell roconnor for reference cloning a traversal seems to make it about 60% slower, not as bad as i'd feared
11:28:36 <lambdabot> Consider it noted.
11:28:50 <jmcarthur> maybe  Monad (Bar a b)  would work, but i am thinking it won't
11:29:03 <shirt> jmcarthur: thanks! it seems to work!
11:29:11 <jmcarthur> ah, great
11:29:22 <Dashkal> *sigh* so much for science.  routine update to the rpi and it refuses to boot.  ghc will have to wait I suppose
11:30:35 <neothemachine> Hi, I'm still a Haskell novice and just read www.vex.net/~trebla/haskell/sicp.xhtml and now I'm asking myself: why?? Isn't it possible to build something like Java's Maven which just works, and works independently for each project and can't mess up at all?
11:31:06 <ocharles> that post has a terrible acronym :)
11:31:11 <Dashkal> wtb bootloader as deterministic as a well-written haskell program.
11:32:20 <maloi> neothemachine: maybe virthualenv is somthing for you?
11:32:31 <geekosaur> or cabal-dev ehich I'm pretty sure that page references
11:33:18 <edwardk> "shirt: monochrom: i want to make it so that all instance of "Bar" are required to be also Monad instances"
11:33:26 <neothemachine> I'll have a look at those, thanks
11:33:30 <edwardk> shirt: Bar has * -> * -> * ?
11:34:31 <shirt> edwardk: "data Bar a :: * -> * -> *"
11:34:51 <edwardk> oh Bar is a data type
11:35:32 <edwardk> class Monad (Bar a) => Foo a where { data Bar a; ... }
11:35:41 <edwardk> is that what you are looking for?
11:36:23 <edwardk> i just realized i replayed the conversation above ;)
11:36:49 <edwardk> then to supply an instance of Foo, you'd have to make an instance of Monad for your associated type (Bar a)
11:38:00 <edwardk> instance Foo Int where newtype Bar Int a = Bar (Int -> (a, Int); instance Monad (Bar Int) where return a = Bar (i -> (a, i); ...
11:38:56 <edwardk> also, are you sure it should be class associated data and not a class associated type?
11:41:16 <spaceships> ?spaceships
11:41:16 <lambdabot> Unknown command, try @list
11:41:36 <Clint> uh-huh
11:41:41 <t7> @vixen
11:41:42 <lambdabot> The Chinese use two brush strokes to write the word 'crisis.' One brush stroke stands for danger; the other for opportunity. In a crisis, be aware of the danger - but recognize the opportunity.
11:42:54 <Clint> "brush stroke"
11:45:23 <timthelion> TIL everything Chinese is deep and symbolic because it's from Asia.
11:46:38 <t7> sora aoi is my favourite Asian person
11:47:10 <t7> and then chang from community
11:49:05 <Cale> neothemachine: I think that a lot of the problem would be solved by allowing multiple installations of the same package-version with different ABI hashes.
11:49:54 <timthelion> t7: porn actress?
11:50:36 <t7> adult entertainer
11:51:08 <timthelion> right, ok
11:51:28 <t7> did you have to google or did you know?
11:51:49 <neothemachine> Cale: even then, ideally I just want to check out a project from version control, hit compile and run it, and I guess it would help if there would be a single cabal-dev command which reads the .cabal file and creates/updates the cabal-dev environment with the needed packages
11:52:42 <Cale> neothemachine: You can usually just enter the project's directory and do "cabal install" or "cabal build"
11:53:05 <t7> i dont see why cabal cant index packages built with different dep versions
11:53:09 <neothemachine> Cale: oh I don't know that, convenient
11:53:12 <t7> im gonna make cabal 2 one day
11:53:13 <timthelion> t7: I had to google google: wikipedia:she studied with the intent of becoming a pre-school teacher
11:54:17 <BMeph> Does anyone have a recommendation for a small install-sized language, that's as "interesting" to program in as Haskell?
11:54:39 <t7> BMeph: SML, agda, coq
11:54:42 <timthelion> BMeph: install size of compiled binarry?
11:55:06 <monochrom> hugs
11:55:17 <Cale> GHC is less than 1GB isn't it? That's small, right? :)
11:55:34 <monochrom> hugs is smaller than sml and coq
11:55:53 <luite> yeah you can even compile reasonably small programs with ghc with only 4GB RAM
11:56:04 <monochrom> agda may require you to add ghc first. coq may require you to add ocaml first. not my idea of small
11:56:22 <hpc> i code in agda on my 1gig laptop every so often
11:56:26 <BMeph> How about "smartphone"-small?
11:56:28 <hpc> it doesn't have any trouble
11:56:31 * timthelion looks in horror that his own binaries are actually very big: 7mb for simple command line image processor.  3.8mb for a parser+compiler of an essoteric language(that's not bad!)
11:56:33 <monochrom> hugs
11:57:08 <monochrom> depending on your notion of fun, javascript may fit
11:57:18 <k00mi> BMeph: scheme, if that's interesting enough
11:57:20 <BMeph> monochrom: Thanks.
11:57:29 <typoclass> BMeph: you want to run ghc on the phone?
11:57:51 <monochrom> I do not know how to port hugs to a smartphone. but it is small
11:57:55 <timthelion> BMeph: is 3.8mb too big for per program install size?
11:58:04 <BMeph> typoclass: Doesn't everyone? ;)
11:58:16 <luite> ghci should work on arm now
11:58:25 <luite> and i guess most recent smartphones have enough ram to run it
12:01:04 <parcs`> why not ssh into a machine with ghc on it?
12:01:24 <Ornedan> Is it possible to get a list of existing threads? And what they're doing?
12:01:51 <timthelion> Ornedan: no, but http://hackage.haskell.org/package/threadmanager
12:02:10 <BMeph> Parcs`: If I had such a machine available, I'd be using it instead.
12:08:04 <timthelion> BMeph: do you just want to be able to REPL code on the go?
12:08:32 * BMeph is amused how his phone capitalizes names, but not sentences...
12:08:40 <Eduard_Munteanu> BMeph: you could connect to tryhaskell though
12:08:55 <timthelion> BMeph: you can always get yourself a VPS. They cost like 15$ a month and would give you such SSH access.
12:09:35 * timthelion is trying to figure out what universe BMeph lives in where he doesn't have access to computers.
12:10:45 <timthelion> BMeph: just /msg lambdabot whenever you need to compute something.
12:14:24 <BMeph> It isn't so much that I don't have computer access, as much as I'd like something to distract me from thinking about taking home a work computer when mine conks out.
12:15:12 * timthelion shrugs
12:17:59 * BMeph nods
12:19:34 <ksf> http://okmij.org/ftp/Haskell/keyword-arguments.lhs apparently doesn't work, any more.
12:21:01 <mapreduce> Eduard_Munteanu: tryhaskell doesn't give a way of defining things, just running expressions.
12:41:49 <wires> Are there any "toy" or template GHC backend examples around?
12:42:34 <luite> ghcjs is more or less toy in its current stage :)
12:42:48 <wires> ah, that sounds great :)
12:43:04 <luite> it's not particularly clean code though
12:43:28 <luite> wires: what kind of code do you want to generate, and from which stage?
12:43:47 <wires> clojure
12:43:55 <timthelion> why clojure?
12:44:17 <timthelion> noting that someone already did a haskell to java byte code something...
12:44:27 <timthelion> @jhc
12:44:27 <lambdabot> ghc says: try_stub.o: unknown symbol `Safe_zdffibonaccizuhszuaM1_closure'
12:44:37 <timthelion> @google jhc
12:44:38 <lambdabot> http://repetae.net/computer/jhc/
12:44:38 <lambdabot> Title: jhc
12:44:42 <teneen> is it a good idea to always use the "-O2" option with "cabal install"?
12:44:46 <wires> Does that work well? Last time I tried it totally didn't work
12:45:03 <timthelion> I have never tried it.
12:46:27 <wires> luite, I'm not sure what the proper level is, the more it looks like lambda calculus, the better I guess, Core?
12:46:48 <wires> timthelion, I was hoping to reuse some of the clojure datastructures, and clojure also compiles to js..
12:47:25 <wires> timthelion, luite, it's really just a thought, I wonder how hard it would be to write a GHC backend like that
12:47:27 <luite> wires: yeah for clojure output i guess core or stg
12:48:55 <luite> wires:  i think it will depend a lot on how well you want it to work
12:49:22 <timthelion> wires: what do you want to convert from?  CMM?  Or Core?  You don't have to write your code so that it directly interfaces with GHC.  Just tell ghc to output core or cmm, and then write your program to operate on those.  You can "integrate" it later.
12:49:37 <luite> single threaded slow, limited support for primops (like no weak refs, unboxed arrays) should be quite doable
12:49:45 <wires> I think actually STG is the best one.. but I'm not sure...
12:49:48 <luite> proper multithreding and optmiization means a lot of work
12:49:51 <timthelion> wires: cmm = C minus minus, which is like C but wierd.
12:50:08 <luite> it's not really like C, more assembly with a C-like syntax
12:50:13 <wires> timthelion, exactly.. so that isn't a good fit
12:50:29 <luite> Cmm already has the heap, stack and calling convention baked in
12:51:23 <luite> wires: stg would work i think
12:51:28 <luite> ghcjs also uses that
12:51:51 <wires> hmm I think STG is quite good fit actually
12:52:00 <wires> no types, etc...
12:52:31 <luite> but ghcjs implements the STG machine in a limited way, it doesn't use static information about arity, so it has no fast apply paths
12:52:44 <luite> (haste-compiler does the same)
12:53:29 <wires> I don't know too much about the STG machine, but I wonder how much it would work like Clojure reduction
12:53:35 <luite> also no pointer tagging, but that's not terribly easy to do in javascript :)
12:53:57 <wires> haha
12:54:15 <wires> "When I want to go close to the metal, I grab my node.js"
12:55:08 <luite> v8 does do tagging itself though :)
12:55:21 <wires> oh lol, really... :)
12:55:26 <n00b6502> a haskell implemented on top of JS ?
12:56:04 <n00b6502> is it my lack of knowledge off JS that makes me think that sounds awful ?
12:56:12 <wires> n00b6502, yes
12:56:14 <wires> haha
12:56:25 <n00b6502> what synergy is there
12:56:26 <neothemachine> if I want to remove all of my installed user packages, which folder do I have to remove?
12:56:33 <luite> wires: yean but for javascript types of course. it generates code specialized to the types you use when you first call a function. tagging is used for escape paths if the funciton is entered with the wrong types the next time
12:56:34 <wires> actually if you think JS is awful you should like this project
12:56:53 <n00b6502> i dont think JS is awful. but as a backend for another language,,,?!
12:56:55 <wires> because if it works well you won't have to write JS anymore, but can just write beautiful haskell code :)
12:57:15 <n00b6502> i'd get further writing JS than haskell at this point
12:57:32 <wires> basically JS is the VM of the web nowadays..
12:57:45 <pharaun> for better or worse
12:57:52 <wires> luite, that is pretty neat though
12:57:54 <n00b6502> good god
12:58:22 <n00b6502> i can't think of anything futher from a VM than a scripting language
12:58:40 <pharaun> n00b6502: lots of other projects are working on compiling down their language to JS :)
12:58:49 <wires> luite, could you maybe point me to a file in ghcjs that get's the STG AST and starts the conversion to js?
12:58:52 <pharaun> n00b6502: also have you seen some of the minified example of js
12:58:59 <n00b6502> no
12:59:22 <n00b6502> but you'll be relying on JS engine to do some serious optimization surely
12:59:30 <n00b6502> does JS have types
12:59:30 <pharaun> v8 and others already have :)
12:59:42 <wires> n00b6502, v8 certainly does optimize a lot :)
12:59:57 <n00b6502> doesn't a JS engnie have to do 'type tracking' to figure out what the types are
12:59:57 <pharaun> i mean if you wanted a vm on the web there's better ... way to do it like having bytecode, etc... but
13:00:07 <luite> wires: https://github.com/ghcjs/ghcjs/blob/master/src/Generator/Core.hs
13:00:09 <pharaun> *shrugs* everything kind of just settled on js
13:00:21 <n00b6502> thats bonkers
13:00:25 <pharaun> hence my comment better or worse :)
13:00:25 <wires> pharaun, true and meh...
13:00:33 <wires> luite, thanks!
13:00:33 <pharaun> wires: indeed
13:00:34 <timthelion> pharaun: that's already been proven not to work, see java, flash, and silverlight, all failiures in one way or another.
13:00:56 <pharaun> timthelion: yeah, but what makes js different if people are going to start grafting on VM-like features?
13:01:09 <n00b6502> i like the idea of Google NaCl but i doubt other browsers will adopt it, since getting native code over the internet will be increasingly done through appstores
13:01:15 <luite> wires: i don't really like the Javascript class though
13:01:25 <timthelion> pharaun: that it displays it's content as HTML, and not in some dorky window with a non accesable interface ...
13:02:00 <pharaun> timthelion: this is true :) i was just saying that there could have been a better way to do the whole VM but, for better and worse we ended up on JS :)
13:02:06 <luite> wires: what will probably help is reading the original stg machine paper and the more recent eval/apply one, and experimenting with -ddump-stg
13:02:17 <wires> luite, hmm what would you want to change on that class?
13:03:01 <luite> wires: oh i just don't really like that the javascript generator is a type class in this way
13:03:22 <wires> luite, thanks I was already skimming the original STG paper. What eval/apply paper do you mean?
13:03:54 <luite> http://research.microsoft.com/apps/pubs/default.aspx?id=67488
13:04:09 <totte> What kind of file is xmonad-x86_64-linux? Is it the binary? I understand that the xmonad.o is an "object file" and that .hi is an "interface file".
13:04:26 <pharaun> totte: yeah its a compiled binary
13:04:28 <timthelion> pharaun: I think that it's for better, in that javascript has single handedly proven that open source can work on a large scale(albiet illegally)
13:04:33 <hpc> totte: run "file xmonad-whatever"
13:04:40 <totte> All I find on Google is issues with the files missing, not what they are for. :/
13:04:41 <luite> wires: perhaps this one is better http://community.haskell.org/~simonmar/papers/evalapplyjfp06.pdf
13:04:41 <wires> luite, thanks!
13:04:43 <hpc> and it should probably say executable
13:04:53 <totte> pharaun: Cool, thanks.
13:05:28 <totte> hpc: Neat! Didn't know about that one. :)
13:05:34 <pharaun> timthelion: indeed, i don't disagree with that statement, but at the same time what i ment is there has been lots of VM effort in say jvm, etc and with a bit better bytecode/arch than shipping around "raw" js script, the whole thing could have been a bit more efficient
13:05:56 <pharaun> timthelion: but at the same time it would have never had the success that js has had so :)
13:06:37 <luite> wires: i found it useful to be able to dump the actual STG AST as haskell types, not just the prettyprinted source from -ddump-stg
13:07:04 <luite> wires: unfortunately, they have no Data instance, i hacked some Show instances together here: http://hpaste.org/73700
13:07:08 <pharaun> timthelion: i just find it amusing that people are compiling their program down to js which is another text format, which is then shipped on over to the browser, which then again parse it, then JIT/whatever it down :)
13:07:59 <wires> luite, ahh great that is nice
13:08:04 <luite> wires: it's really hacky, but showIndent x, where x is some Stg node (from the StgSyn) module prints out the haskell data relatively nicely with indenting
13:08:09 <timthelion> pharaun: you are correct.
13:08:52 <timthelion> pharaun: still, compaired to economics, war, and religion, the internet is still an extremely rational human invention.
13:09:08 <pharaun> timthelion: haha indeed in the grand scale :)
13:09:28 <wires> luite, do you recommend any docs to get started on this. For instance I have no idea how to get GHC produce me such a term
13:09:46 <wires> luite, also I don't mind digging around your code...
13:09:58 <ownclo> Good day! Function stack is heavily used in a lazy functional language, right? So haskell-made programs (processes?) should have an enlarged function stack. Have they?
13:10:23 <wires> ownclo, no not really. using all kinds of smart tricks, this is avoided
13:10:46 <hpc> ownclo: in GHC at least, the model of execution is completely different than what you would expect from any other language
13:10:50 <hpc> you should read the STG paper
13:10:54 <latro`a> tricks that tend not to make sense in a setting where the compiler doesn't know much
13:11:04 <wires> ownclo, what hpc says :)
13:11:21 <wires> also papers on the CAML machine are very interesting
13:11:25 <hpc> it will at least give you some bearings to help understand any answer you would get here
13:12:30 <luite> wires: right it's a bit messy, https://github.com/ghcjs/ghcjs/blob/master/src-bin/Compiler/Main.hs , see main -> compileModSummary
13:12:32 <ownclo> wires, hpc, so these details are handled by ghc itself? Well, ghc docs should contain some information about it?
13:13:33 <hpc> ownclo: probably, but not at a level of detail that will help you get the ideas behind the whole thing
13:13:53 <luite> wires: also so this, the second example: http://www.haskell.org/haskellwiki/GHC/As_a_library
13:14:26 <wires> ownclo, functional languages use special virtual machines that work quite different from the stack based hard
13:14:28 <luite> wires: it only goes to core, but it's only a few more lines to get STG
13:14:43 <wires> luite, thanks a lot!
13:15:11 <wires> luite, cool this should get me somewhere...
13:15:39 <luite> wires: ghcjs is messy becaus it does a lot of ghc command line emulation to get cabal support
13:16:05 <luite> but to get started, you probably just want to compile single files
13:16:29 <wires> yes, well, ideally it would support cabal out of the box :^)
13:16:33 <luite> also ghcjs-boot shows how you can hook into the ghc build system to get your own compiler to build the base library
13:16:53 <luite> but it's messy, send me patches if you find better ways ;)
13:16:53 <wires> hehe, but once I'm compiling single files, I'll come back and ask for more help
13:17:38 <ownclo> wires, hpc, thanks for hint! I've got the direction of future research
13:17:56 <luite> wires: ideally we should be able to factor out these common "ghc-like compiler" support things, command line handling, cabal, boot libraries, should all be more or less the same
13:18:37 <wires> ownclo, check Xavier Leroy's papers http://gallium.inria.fr/~xleroy/talks.html
13:18:39 <n00b6502> stack vs graph machines - is a stack machine simply a graph with one 'dominant path' chosen
13:19:18 <wires> luite, exactly
13:20:00 <n00b6502> one question, is there something like JVM or LLVM for functional languages. is the STG used to implement others
13:20:24 <wires> n00b6502, there is for instance EPIC
13:21:03 <wires> n00b6502, http://www.cs.st-andrews.ac.uk/~eb/epic.php
13:21:05 <n00b6502> epic, in what context. i've only heard of Eplicit Parallel Instruction ...
13:21:07 <ownclo> wires, thank you a lot
13:21:15 <pharaun> is there any recommendation for a on disk haskell cache in which i can have timestamp and expire the cache entry?
13:21:34 <wires> luite, you meant Boot.hs ?
13:21:37 <burbul> Is there a nice way to write this?
13:21:37 <burbul> (string "-" *> pure Nothing) <|> (Just <$> term_tuple)
13:21:42 <luite> wires: yeah
13:22:00 <n00b6502> Ah thats more like what i thought would be possible. pure functional langauge as an abstract reprepesentation that is still suitable for generating efficient imperative programs
13:22:09 <luite> wires: but forget about that now, just try to compile things first that don't use the base lib
13:22:21 <luite> (and cheat a bit with numbers perhaps)
13:23:18 <wires> luite, haha I always like it when such things (boot.hs) are writing in haskell, i would personally grab python for that but okay :0
13:23:38 <wires> luite, i guess I don't know haskell libraries well enought to quickly whip something like that together
13:23:54 <luite> wires: yeah i don't really want to require python for this, doesn't work as well with cabal :)
13:24:08 <luite> wires: i used shelly there
13:24:16 <luite> which is a bit hacky, but seems to get the job done
13:24:52 <wires> ah great, never heard of that
13:25:55 <wires> anyway, details.. but this is great, thanks for the hints luite
13:26:00 <luite> wires: and would your python script do streaming unpacking of the ghc source archive while downloading! ;p
13:26:12 <luite> oh with pipes perhaps
13:26:17 <luite> unix pipes
13:26:22 <wires> curl -L bla | tar xzv ?
13:26:28 <wires> :)
13:26:36 <luite> yeah but then you ahve even more dependencies
13:26:46 <wires> who cares about windows
13:26:47 <luite> anyway boot.hs does this with http-conduit
13:26:47 <wires> haha
13:27:25 <wires> Anyway, i'm just joking. I think it is very cool to write such things in haskell, and in fact it should be as easy as in python or unix pipes
13:28:19 <wires> but btw, this boot thing, isn't that something you would just want to do on a build server? and maybe for a developer (because then it really doesn't matter if they need python right)
13:28:39 <luite> i have to admit that i really haven't tried to make it nice (boot.hs), i just wanted it to work, and dealing with the ghc build system, for things that it wasn't meant to do, caused enough frustation already
13:28:59 <wires> yes :) we shouldn't even be talking about it
13:29:09 <wires> bikeshed discussion :P
13:29:33 <luite> i think users should be able to boot their own compiler
13:30:02 <wires> but the end result is just a blob of minified js right?
13:30:22 <luite> but yeah, a fast boot should be added later, where it just registers the packages with downloaded javascript source
13:30:32 <luite> if there is a prebuilt version availble for their compiler
13:31:27 <luite> currently ghcjs builds  both native and javascript code
13:31:37 <luite> so you can run template haskell like the usual ghc
13:32:03 <luite> but it has its own package db
13:32:38 <wires> hmm. it sounds like you are really out to solve the "Haskell in the browser" problem for good...
13:33:05 <luite> well i didn't write much of the current code generator, but i'm working on some new stuff that's faster, hopefully :)
13:33:20 <luite> but it's also more or less a rewrite from scratch
13:33:50 <johnw> one thing that always bites me with Data.Text is when I get type errors about "Text != Data.Text.Internal.Text"
13:33:53 <johnw> I'm never sure how to solve it
13:34:22 <luite> johnw: Lazy vs Strict perhaps?
13:34:25 <johnw> :t either (const 0) fst (decimal x)
13:34:26 <lambdabot> Not in scope: `decimal'
13:34:33 <johnw> that's the function I'm calling
13:34:39 <johnw> but I get expected vs. actual type mismatch
13:34:42 <johnw> my function is:
13:34:45 <johnw> textToInt :: Text -> Int
13:34:49 <johnw> seems innocuous enough
13:35:10 <johnw> I don't care about text after the int, and I want errors to just yield 0
13:35:13 <jmcarthur> i also suspect that has to do with strict vs lazy
13:35:27 <johnw> so I need (decimal . toStrict $ x)?
13:35:38 <johnw> ah, yes
13:35:39 <jmcarthur> which version of Text do you have imported and which type does decimal expect?
13:35:41 <johnw> I think you are right!
13:35:45 <jmcarthur> ah nevermind
13:35:46 <johnw> my "Text" is "Data.Lazy.Text.Text"
13:35:56 <johnw> solved!
13:35:58 <johnw> you guys are awesome
13:36:06 <johnw> I should have noticed the lack of Lazy in the complaint
13:36:15 <luite> now that's not fair, i was the only one who gave the right answer ;)
13:36:22 <luite> oh wait jmcarthur too
13:36:31 <wires> hehe :) johnw the brain doesn't work that way
13:36:33 <jmcarthur> my answer was only agreement with you, to be fair
13:36:34 <luite> sorry, i'm willing to share the awesomeness with you
13:37:43 <luite> jmcarthur: that's right, but it's hard to pick the right people to agree with
13:38:20 * Saizan thinks the two types should have different names
13:39:17 <luite> Saizan: the error message would be more clear if it was imported as LT.Text
13:39:33 <johnw> yay, I'm warning free.  I'm writing a Subversion dump file parser using ByteString.Lazy and Text.Lazy
13:40:19 <johnw> I'd already written this parser in C++.  It's been quite illuminating to see how differently I approach the problem in order to find a functional solution
13:40:25 <johnw> (plus how laziness changes things)
13:40:44 <pharaun> whoa 3.5gb for ghcjs for js linker
13:41:12 <luite> pharaun: yeah i guess that means there's some optimization to do huh ;p
13:42:11 <pharaun> luite: hehe, :D i was mainly poking around the github repo for it :)
13:43:06 <luite> pharaun: it probably can be improved easily, just make the linker process each file separately, and have some better optimized data structure of the functions that it needs
13:43:35 <timthelion> johnw: my favorite bit about lazt parsers(if you are writting a linear parser, which I don't suggest) is that you can go back in time.  Say (IsTypeOrDeclairation,theRestOfTheParsedItems) = parseTheRestOfTheItems (if isTypeOrDeclaration then ... else ...)
13:43:36 <luite> the linker reads the js file produces a new one with only the functions it needs to build the program
13:44:00 <luite> so usually it can leave otu large parts of the base librar
13:44:01 <luite> y
13:44:34 <pharaun> ahh i see
13:45:07 <pharaun> luite: still a sweet project! :)
13:45:33 <luite> pharaun: i can't claim credits for the linker, i think hamishmack wrote it
13:50:56 <wires> so that happened to this work that chris done was doing on writing a better haskell-emacs ?
13:51:21 <wires> wait, let me rephrase that. How do i get emacs to behave properly with cabal-dev
13:51:57 <wires> (because I thought his newer emacs haskell-mode dealt with this kind of nonsense..)
13:53:16 <luite> yeah i believe he uses cabal-dev a lot
13:54:27 <zungaloca> could comeone explain Muabe?
13:54:34 <zungaloca> *Maybe?
13:54:52 <Cale> zungaloca: sure
13:54:54 <wires> it is just a type to optionally contain another value
13:55:20 <Cale> zungaloca: A value of type Maybe t is either the value Nothing, or it is a value of the form Just x where x :: t
13:55:24 <mauke> zungaloca: how much haskell do you know?
13:55:43 <Cale> This is useful for representing the results of operations which may or may not produce a value
13:56:32 <pharaun> a good one to know also is the Either
13:56:36 <Cale> For example, the lookup function searches a list of pairs for a pair whose first part matches a given value, and produces Just (the second value) if it finds one, and Nothing otherwise
13:56:40 <pharaun> then you can return an error
13:56:48 <Cale> :t lookup
13:56:50 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:57:16 <Cale> > zip [0..] (words "here is a bunch of words")
13:57:17 <lambdabot>   [(0,"here"),(1,"is"),(2,"a"),(3,"bunch"),(4,"of"),(5,"words")]
13:57:24 <Cale> > lookup 3 (zip [0..] (words "here is a bunch of words"))
13:57:25 <lambdabot>   Just "bunch"
13:57:30 <Cale> > lookup 7 (zip [0..] (words "here is a bunch of words"))
13:57:31 <lambdabot>   Nothing
13:58:13 <Cale> zungaloca: make sense?
13:59:28 <zungaloca> Wildcard of something?
13:59:48 <Cale> zungaloca: hmm..
14:00:17 <Cale> zungaloca: It's a way of representing failure as a value
14:00:46 <typoclass> zungaloca: another way to think about Maybe is that it's like a list that can be either empty, or contain exactly one value. as cale pointed out, it's used similarly to how you'd use "null" in java (to indicate that something is absent). sometimes it's also used like -1 is used in c (e.g. for a search function that didn't find anything and returns -1)
14:01:01 <wires> zungaloca, think of 'Maybe A' as just saying, well is either a value of type A, or some special placeholder called 'Nothing', like java's... 'null'
14:01:12 <wires> ah :)
14:01:31 <Cale> But don't forget, you need the Just constructor in the case that you actually have a value as well.
14:01:32 <wires> zungaloca, maybe you can try to say what is confusing to you
14:02:03 <ion> zungaloca: What other languages are you familiar with?
14:02:13 <mauke> zungaloca: how much haskell do you know?
14:02:31 <zungaloca> O.o!
14:02:46 <zungaloca> So
14:02:53 <wires> ah
14:03:14 <wires> :) read the 'learn you a haskell'
14:03:39 <zungaloca> data Maybe book = Just book {bla :: bla}              | Nothing
14:03:42 <wires> zungaloca, http://learnyouahaskell.com/
14:03:59 <Cale> @let scrabbleTiles = zip ['A'..'Z'] [1,3,3,2,1,4,2,4,1,8,5,1,3,1,1,3,10,1,1,1,1,4,4,8,4,10]
14:04:00 <lambdabot>  Defined.
14:04:15 <Cale> > lookup 'H' scrabbleTiles
14:04:17 <lambdabot>   Just 4
14:04:26 <Cale> > lookup '6' scrabbleTiles
14:04:28 <lambdabot>   Nothing
14:04:29 <wires> zungaloca, do you understand data Boo = A | B ?
14:04:57 <zungaloca> yes
14:05:00 <Cale> zungaloca:  data Maybe a = Nothing | Just a
14:05:16 <Cale> zungaloca: That's the one and only data declaration for Maybe
14:05:39 <wires> it is important to note two things now: "A" and "B" are just names
14:05:49 <wires> but little "a" is a parameter, which can stand for any type
14:05:56 <Cale> It says, like I wrote in English before, that every value of type Maybe a is either the value Nothing, or it is a value Just x where x has type a.
14:06:17 <Cale> Yeah, a here is a variable which stands for an arbitrary type
14:06:24 <Cale> Just 6 :: Maybe Integer
14:06:28 <Cale> Nothing :: Maybe Integer
14:06:35 <Cale> Just "Hello" :: Maybe String
14:06:38 <wires> Just A :: Maybe Boo
14:06:40 <Cale> Nothing :: Maybe String
14:06:58 <zungaloca> is this possible?
14:07:08 <wires> yep
14:07:09 <Cale> zungaloca: Is what possible?
14:07:20 <zungaloca>  data Maybe a = Nothing | Just a | qwertyu|34567
14:07:27 <mauke> zungaloca: no
14:07:33 <Cale> zungaloca: That's syntactically invalid
14:07:35 <zungaloca>  data Maybe a = Nothing | Just a | qwertyu|asdfg
14:07:36 <mauke> zungaloca: that's two syntax errors, and a name clash
14:07:50 <mauke> Maybe already exists, as do Nothing and Just
14:07:59 <wires> no, but data Maybe a = Nothing | Just a | Foo | Baa | Meh a a a is
14:08:05 <zungaloca>  data Maybe a = Nothing | Just a | Qwertyu|Asdfg
14:08:05 <Cale> qwertyu starts with a lowercase letter, so it is not allowed as a data constructor
14:08:26 <Cale> zungaloca: You *could* write that, but it would conflict with the already-existing definition of Maybe
14:08:37 <wires> zungaloca, yes and what mauke said: Maybe already exists ... etc
14:08:42 <Cale> zungaloca: If you hid that declaration from the Prelude, then you could do it
14:09:01 <Cale> (however, you'd also lose the ability to use all the already-defined functions on Maybe)
14:10:11 <zungaloca> type CardHolder = String type CardNumber = String type Address = [String] type CustomerID = Int data Maybe BillingInfo = Just CreditCard CardNumber CardHolder Address                  | CashOnDelivery                  | Invoice CustomerID                  | Nothing                    deriving (Show)
14:10:11 <shapr> Good afternoon #haskell!
14:10:58 <Cale> zungaloca: You're not allowed to redefine Maybe on specific datatypes
14:11:08 <wires> zungaloca, what is the question exactly?
14:11:17 <Cale> zungaloca: The one definition in the Prelude already covers Maybe t for *every* type t
14:12:06 <Cale> zungaloca: However, you can define your own new datatype if you want to have more cases.
14:12:27 <Cale> zungaloca: Maybe is just for those cases where you either have something or nothing
14:14:16 <zungaloca> give an exmaple of a data with accessors, datatype on Maybe
14:15:06 <pharaun> is acid-state a good library for my usecase (i want to cache network information locally, and cache expensive disk operations)
14:15:42 <Cale> zungaloca: One which uses Maybe?
14:15:53 <wires> like data Person = Person { name :: String , age :: Maybe Integer } ?
14:15:56 <zungaloca> data Maybe a = Just a {bla :: String} deriving (Show)
14:16:15 <Cale> zungaloca: You're redefining Maybe again, you're not meant to do that :)
14:16:19 <zungaloca> correct.. ?
14:16:20 <wires> lol
14:16:23 <wires> no :)
14:16:38 <Cale> zungaloca: Maybe is already defined, you don't have to define it again.
14:16:46 <wires> when you write 'data' you are defining a NEW datatype
14:16:46 <Cale> This declaration:
14:16:52 <Cale> data Maybe a = Nothing | Just a
14:16:58 <Cale> is already in the Prelude module
14:17:05 <Cale> and you don't need to replace it with anything
14:17:19 <Cale> You just use the type constructor Maybe and the data constructors Nothing and Just which it defines
14:18:02 <zungaloca> i thought maybe was also use to error handling on datas ups
14:18:16 <mauke> it is
14:18:55 <wires> function :: A -> B which can fail, then use function :: A -> Maybe B
14:19:38 <wires> Persons age not always known? data Person = Person { age :: Maybe Integer }
14:20:17 <wires> thisDude = Person (Just 42) -- some guy of age 42
14:20:33 <sheldonh> yay! my isSPalindrome works! :)
14:21:04 <mauke> :t ap (==) reverse
14:21:05 <lambdabot> forall a. (Eq a) => [a] -> Bool
14:21:17 <zungaloca> and in data? error handling with maybe how?
14:21:29 <wires> zungaloca, what I did with age
14:21:34 <wires> normally age :: Integer
14:21:38 <mauke> zungaloca: how much haskell do you know?
14:21:48 <wires> you don't know it? (ie. got error), then age :: Maybe Integer
14:22:54 <wires> but you are probably better of reading a bit of http://learnyouahaskell.com/
14:23:01 <zungaloca> kkk get it now ;D thanks
14:23:33 <wires> :)
14:28:21 <Dashkal> Huh, that's a surprise.  raspbian includes haskell-platform, but I didn't get ghci with it.
14:28:33 <geekosaur> does ghci work on arm yet?
14:28:40 <Dashkal> I'm gonna guess not
14:28:43 <Dashkal> time to do hello.hs
14:29:01 <heatsink> "Alas, GHC 7.0 still cannot handle equality superclasses"
14:29:05 <heatsink> Time to upgrade...
14:29:23 <shapr> Dashkal: it does, but you need 7.4.2 or later
14:29:36 <geekosaur> I know people are working on ghci/TH on arm, no idea if it's out there in the wild yet
14:29:41 <shapr> It is!
14:29:46 <shapr> Er wait, not sure about TH
14:29:49 <Dashkal> Raspbian has 7.4.1, and there are bug reports complaining that 7.4.2 won't compile for raspbian yet
14:29:54 <shapr> :-(
14:30:11 <Dashkal> Eh, that's fine, I can ghci on a different machine so long as I can actually compile on the pi
14:30:38 <ion> How about cross-compilation? I have ordered a Beagle Bone, i’ll probably try to cross-compile Haskell code for it.
14:30:41 <Dashkal> If that fails, qemu time.  No idea if I can get qemu to load a raspbian image.  "bootloader" means something very different on the pi
14:30:49 <ion> (If that’s easy enough to do.)
14:31:01 <Dashkal> I asked about that an hour or so ago.  The consensus was it's pain, pain, and more pain to do cross-compiliation.
14:31:01 <wires> Dashkal, but ghc works?
14:31:08 <Dashkal> wires: Installing vim, then I'll know
14:31:14 <ion> dashkal: Oh, ok. Too bad.
14:31:17 <geekosaur> yeh, looks like you need ghc 7.4.2, not working yet :(
14:31:29 <wires> echo main = putStrLn "hoo" > hello.hs ?
14:31:29 <shapr> Dashkal: Yah, one of the guys on the forums has used a raspbian image to build ghc 7.4.2
14:31:49 <shachaf> wires: That won't work.
14:31:49 <Dashkal> Ok, I could have used... yes, echo :P
14:32:01 <shachaf> echo 'main = putStrLn "hoo"', maybe.
14:32:06 <Dashkal> shachaf: Why not?  Though I have vim now.
14:32:10 <Dashkal> oh, escaping
14:32:19 <Dashkal> We have success!
14:32:23 <shapr> Dashkal: I use sshfs to mount my the raspberry pi's home dir so I can use all my familiar editing tools.
14:32:29 <Dashkal> ghc --make hello.hs works
14:32:39 <wires> I thought so. It is a similar problem on PPC
14:32:44 <wires> no GHCi
14:32:44 <Dashkal> vim is a must-have for me, just in general for sys amin.
14:33:02 <zhulikas> is it possible to build on PC for arm?
14:33:05 <Dashkal> I'll do my normal dev on my amd64 "closet server" anyway
14:33:14 <zhulikas> if I don't want to install haskell platform on rpi
14:33:15 <shapr> zhulikas: yes
14:33:17 <zhulikas> cool
14:33:25 <Dashkal> zhulikas: It's in theory possible, let me know if you have success.
14:33:29 <zhulikas> ah, ok
14:33:30 <zhulikas> :)
14:33:33 <shapr> zhulikas: But there are debs for ghc 7.4.1 already.
14:33:34 <zhulikas> I probably won't
14:33:35 <geekosaur> possible yes, easy not so much, as I understand it?
14:33:44 <Dashkal> The haskell wiki page suggests using qemu to run arm emulated, then just copying
14:33:46 * zhulikas forever a noob
14:34:11 <Dashkal> the rpi has /very/ limited ram, so that's a good option over installing directly like I just did
14:34:29 <Dashkal> But I was curious.  I'm happy now.  No need to use python to play with the thing.
14:36:18 <Dashkal> I wonder if I can manage a build that actually reserves all ram for the system (no video support whatsoever).  Things to ask in rpi forums.
14:38:38 <sheldonh> Dashkal: my experience is all from virtual machines and PC... the bloody BIOS always lops off huge swathes of RAM :(
14:38:56 <sheldonh> Dashkal: even with no vga driver built into the kernel
14:39:00 <Dashkal> In the case of the rpi, there's a ram split between core and video.  The default is 192/64
14:39:06 <sheldonh> meh
14:39:08 <Dashkal> I can drop it to 32 for the video, but not 0
14:39:15 <Dashkal> (which would disable hdmi, so use at risk)
14:40:03 <Dashkal> I'm not planning on doing large scale haskell compilation on the pi anyway.  If I try to get xmonad working, for example, I want either cross-compiling or an emulated environment with much more ram.
14:40:19 <Dashkal> But this is sufficient for getting started with the gpio pins
14:40:43 <Dashkal> Or would be if I still had my electronics toys.  Time to go shopping.
14:41:20 <povman> I have a question about proofs
14:41:29 <povman> structural induction
14:43:27 <ocharles> fire away
14:43:58 <hpaste> povman pasted “sum” at http://hpaste.org/73701
14:44:31 <ion> dashkal: RPi has much less GPIO pins than a Beagle Bone. That’s why i chose to buy the latter.
14:44:40 <povman> how would i prove that sum' acc xs = acc + sum' 0 xs
14:45:33 <povman> i was reading some lecture slides which prove (sum' acc xs = acc + sum xs), which is easier because of the definition of sum
14:45:43 <Dashkal> ion: Well, I got the rpi since it's so very in the middle.  I have an sd card loaded with xmbc.  I have one loaded with arch.  Now I'm playing with haskell
14:45:46 <povman> er, i mean regular sum not the one in the paste
14:46:16 <Dashkal> The number of directions I can take this one unit is what sells me.
14:46:33 <Dashkal> For any serious real-world interaction, I'm likely to go Arduino.
14:46:34 <wires> $85 vs $29
14:46:49 <zhulikas> I should get my rpi in a couple of weeks
14:46:57 <zhulikas> can't wait to get my hands on it :)
14:47:11 <Dashkal> And all I have to do is swap out the SD card to change its purpose.  Very much a fan
14:47:19 <Dashkal> I just refuse to use python if I can avoid it :P
14:47:29 <zhulikas> I plan to do pure Haskell
14:47:35 <zhulikas> no other languages
14:47:39 <Dashkal> So many thanks to to arm paintainers of GHC
14:47:56 <Dashkal> Well, you may have a small C shim for interacting with the hardware, but aside from that, haskell will do it
14:48:08 <Dashkal> I'm looking into gpio access now
14:48:27 <Dashkal> I've not yet used the FFI, so this is new territory
14:48:28 <zhulikas> I don't think you need C for gpio access
14:48:41 <Dashkal> I'm not sure if it's exposed via dev or not.  Research time
14:48:55 <zhulikas> try /sys/class/gpio
14:49:10 <zhulikas> it should be there
14:50:37 <zhulikas> I already wrote some code to generate PWM in Haskell
14:50:51 <zhulikas> it seems to work, but now I kind of need to try it on rpi
14:51:00 <zhulikas> in the end I might have a Haskell-based gpio driver :)
14:51:10 <zhulikas> extending it to control servos
14:54:24 <Dashkal> zhulikas: sweet! did not know of that
14:54:33 <Dashkal> Of course doing it is meaningless until I get my hands on a multimeter
14:54:40 <zhulikas> :}
14:55:05 <Dashkal> I don't think I even have a non-burnt out led.  When I played with electroncis as a kid I had a bad habit of over-powering the poor things.
14:55:12 <zhulikas> :DD
14:55:15 <zhulikas> me too!
14:55:24 <zhulikas> and I wasn't a kid anymore when I did that
14:55:26 <zhulikas> :(
14:56:23 <zhulikas> I had some pretty nice LEDs... the wire contacts detached faster than LEDs burnt
14:56:47 <spaceships> can someone explain the difference between $ and . to me, please?
14:56:53 <mapreduce> Me too on the burning out of LEDs.
14:56:58 <zhulikas> hehe
14:57:22 <mapreduce> :t ($)
14:57:23 <lambdabot> forall a b. (a -> b) -> a -> b
14:57:27 <Veinor> spaceships: $ is function application, . is composition
14:57:30 <mapreduce> :t (.)
14:57:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:57:31 <zhulikas> spaceships, value on the right side of $ is applied to function on the left side of it
14:57:35 <monochrom> "difference between $ and ." is a wrong way about it. a right way: first eliminate $
14:58:01 <zhulikas> on the right side it may be a chain of functions but result of that chain is applied to function on the left side
14:58:10 <monochrom> e.g., "f $ g $ h $ x" is really "f (g (h x))". put back the parentheses
14:58:19 <mapreduce> > ($) sin 3
14:58:20 <lambdabot>   0.1411200080598672
14:58:28 <mapreduce> > sin $ 3
14:58:29 <lambdabot>   0.1411200080598672
14:58:36 <mapreduce> > sin 3
14:58:37 <lambdabot>   0.1411200080598672
14:58:39 <zhulikas> monochrom, so you say it's possible to write code without $ and parentheses?
14:58:47 <zhulikas> maybe I'm just lazy
14:58:49 <zhulikas> and use $
14:58:50 <monochrom> then, use the definition of "." to see why "f (g (h x))" is the same as "(f . g . h) x"
14:59:39 <monochrom> maybe "f (g (h x))" is too big. you can first play with "f (g x)" and "(f . g) x"
14:59:59 <Tekmo> (f . g . h) x = f (g (h x)) = f $ g $ h x
15:00:19 <spaceships> monochrom: as far as ive gotten is noticing that (.) seems to only work with curried functions
15:00:35 <ocharles> I like to mix and match them. For example, not . null $ foo, makes more sense to me than not $ null $ foo
15:01:02 <ocharles> if functions combine into some sort of useful function, then I use composition. if I want the 'pipeline' model, then I use application
15:01:12 <monochrom> I don't know what you mean. "(sin . sin) 0" does not look like "only work with curried functions"
15:01:16 <sentientwaffle> how can I repeatedly map over a list, with some "done" condition -- without any sort of flag (b/c I cant use mutation)?
15:01:26 <monochrom> I wouldn't call sin a curried function
15:01:35 <ocharles> sentientwaffle: what is the 'done' condition doing?
15:01:41 <ocharles> sentientwaffle: terminating further maps?
15:01:46 <zungaloca> so how much time to learn haskell
15:01:46 <zungaloca> ?
15:01:58 <hpc> zungaloca: 10 years ;)
15:01:58 <sentientwaffle> ocharles: allow the current map to finish, but dont do another
15:01:59 <Dashkal> The very basics?  About 2 hours.
15:02:05 <Dashkal> Everything?  Your life
15:02:22 <spaceships> monochrom: thanks. will ponder
15:02:23 <ocharles> sentientwaffle: so if I map (2+) [1, 2, 3, 4], it might just return [3, 4] ?
15:02:36 <ocharles> (ie, it was 'done' after the second element)
15:02:39 <Tekmo> map (2+) . take 2
15:02:43 <Dashkal> When you see the match behind your code with your own eyes....
15:02:46 <Dashkal> math*
15:02:56 <ocharles> Tekmo: yes, i'm trying to understand what sentientwaffle wants first :)
15:02:58 <k00mi> sentientwaffle: i think the until function is what you are looking for, it's in Prelude
15:03:06 <Tekmo> I think take is what he wants
15:03:07 <sentientwaffle> ocharles: no, I mean it would add 2 to all the numbers a certain number of times, then stop -- but you dont know that number ahead of time
15:03:14 <Tekmo> It throttles the list at the given number of elements
15:03:18 <Tekmo> takeWhile is the more general case
15:03:18 <ocharles> Tekmo: not if he's doing monadic stuff to determine how much he wants
15:03:21 <sentientwaffle> Tekmo: no, I dont know what the Int would be ahead of time
15:03:23 <k00mi> sentientwaffle: yes that's what until does
15:03:26 <Tekmo> Then use takeWhile
15:03:37 <Tekmo> map (2+) . takeWhile condition
15:03:52 <k00mi> i think he wants to repeatedly map until the values satisfy some condition
15:03:57 <k00mi> then stop
15:03:59 <ocharles> that still doesn't help if the condition is monadic
15:03:59 <Tekmo> That's what takeWhile is for
15:04:01 <sentientwaffle> k00mi: yes
15:04:10 <ocharles> sentientwaffle: how are you determining the condition?
15:04:13 <sentientwaffle> Tekmo: no, takeWhile requires the condition to be external
15:04:14 <Tekmo> The monadic version is
15:04:30 <Tekmo> Oh wait, there is no takeWhileM
15:04:34 <Tekmo> :)
15:04:34 <sentientwaffle> ocharles: the condition is determined by passing each value as you map
15:04:38 <ocharles> why don't we actually get the question out before suggesting solutions, eh? :)
15:04:53 <Tekmo> No, we must bombard him with solutions :)
15:05:08 <monochrom> I have been saying that for my whole life
15:05:25 <ocharles> sentientwaffle: Is the condition dependent on a value, or the value and all prior values?
15:05:49 <ocharles> if the latter, then you may need some sort of accumulator
15:05:51 <monochrom> I think answerers simply prefer the uncertainty and guessing and the thrill of the 10% probability of "oh I guess you right!"
15:05:51 <ocharles> :t takeWhile
15:05:52 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:05:54 <zungaloca> hpc: really
15:06:04 <ocharles> takeWhile will only let you determine the 'condition' on a single element
15:06:22 <ocharles> sentientwaffle: so maybe state your question with a concrete example
15:06:50 <sheldonh> if i pattern matched (a:b:xs) in a recursive function, and now need to pattern match the 2 element list case for the non-recursive step, how do i format that pattern?
15:07:03 <sentientwaffle> ocharles: basically, repeatedly map over list X until there are no more 0s in it. the map function will replace _some_ zeros each time
15:07:40 <sentientwaffle> I dont want to have to check at the end of each map for zeros by iterating over the whole thing
15:07:57 <k00mi> sentientwaffle: until (null . filter (==0)) (map (+1)) xs
15:08:03 <Tekmo> Ok, so any time you have a function you want to apply repeatedly
15:08:05 <Tekmo> A good starting point is the iterate function
15:08:19 <ocharles> :t iterate
15:08:20 <lambdabot> forall a. (a -> a) -> a -> [a]
15:08:21 <Tekmo> iterate f x = [x, f x, f (f x), f (f (f x)), ...]
15:08:26 <sentientwaffle> k00mi: but then you iterate twice per processing step
15:08:32 <danr> > iterate f x
15:08:32 <Tekmo> Then you go through the list of those repeated applications
15:08:33 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
15:08:44 <Tekmo> And just break on the one that has no more zeros
15:08:46 <danr> > iterate (f . f) x
15:08:47 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:08:48 <lambdabot>    `SimpleReflect.FromExpr ...
15:08:50 <k00mi> that's true, it's not exactly efficient
15:09:03 <Tekmo> Are you sure?
15:09:05 <ocharles> sentientwaffle: have you profiled it to know that is a problem? :)
15:09:50 <sentientwaffle> ocharles: no.. but it seems like the haskell solution shouldn't have higher complexity than a normal one :P
15:10:29 <ocharles> it might not
15:10:29 <monochrom> "haskell solution" should not be taken as a special case of "dumb algorithm"
15:10:32 <Tekmo> head . dropWhile (elem 0) . iterate f
15:11:24 <k00mi> yep, Tekmo is right
15:11:55 <sentientwaffle> Tekmo, k00mi: the type looks right, its gonna take me a few minutes to wrap my head around, tho :)
15:12:05 <k00mi> i don't think there is a way to do it with less iterations with pre-defined functions
15:12:29 <Tekmo> It will probably be within a factor of 2 of a hand-written version
15:12:37 <monochrom> head (dropWhile (elem 0) (iterate f xs))
15:13:56 <sentientwaffle> Tekmo: if im understanding it right (quite possibly im not) each iteration does a seek (the `elem` call)
15:14:17 <Tekmo> Each iteration checks the resulting list to see if it has a 0 in it
15:14:22 <Tekmo> That's what 'elem 0' does
15:14:54 <n00b6502> are thre any examples of a pure FP program implemented in some sort of suitable VM low-level code (is there an assembler for STG machine)
15:15:21 <sentientwaffle> Tekmo: thats going to require 2 iterations for every 1 that you'd need in an imperative language, right?
15:15:27 <Tekmo> No
15:15:37 <Tekmo> Oh
15:15:40 <Tekmo> I see what you are asking
15:15:46 <sentientwaffle> hurray!
15:15:51 <Tekmo> You want it to check while it is mapping over the list
15:15:55 <sentientwaffle> yes!
15:15:57 <Tekmo> So that it doesn't have to traverse the list twice
15:16:01 <sentientwaffle> bingo
15:16:40 <Tekmo> So, that can be written by hand, but I'm just taking a moment to think if there is an elegant way
15:16:45 <monochrom> I don't think it traverses twice?
15:16:59 <Tekmo> It might
15:17:06 <Tekmo> depending on how foldr/build fusion works out
15:17:54 <Tekmo> So to explain for sentientwaffle
15:17:59 <Tekmo> The base libraries like Data.List
15:18:05 <Tekmo> have lots of rewrite rule tricks
15:18:11 <Tekmo> to fuse multiple passes of a list into a single pass
15:18:13 <monochrom> if you bring up that, then you mean the possibility of creating intermediate cons cells just to throw away
15:18:33 <Tekmo> So there is actually a decent chance that the code I gave you actually traverses the list just once
15:18:44 <mapreduce> mapWhile _ _ [] = []
15:18:54 <mapreduce> mapWhile p f (x:xs) | p x = f x : mapWhile p f xs
15:19:02 <mapreduce>     | otherwise = []
15:19:03 <sentientwaffle> Tekmo: is there any way to know for sure?
15:19:05 <mapreduce> howzat?
15:19:06 <Tekmo> Yes
15:19:12 <Tekmo> You can use the ghc-core tool
15:19:15 <Tekmo> cabal install ghc-core
15:19:22 <monochrom> but you're doing "head . dropWhile blah". the dropWhile part is not going to create intermediate cons cells for a long time. and the 1st time it does, head cuts it short. overall, only 1 intermediate cons cell to be thrown away. ever.
15:19:22 <Tekmo> and then run it on the resulting program
15:19:26 <Tekmo> and see if the fusion rules triggered
15:19:27 <hpaste> ari pasted “Why do I need to declare the types of x and y in the definition of random?” at http://hpaste.org/73702
15:19:34 <Tekmo> and look at the generated code
15:19:35 <Tekmo> In fact, I'll do it myself right now
15:19:38 <Tekmo> to see if I can tell
15:19:49 <povman> proof question: in http://hpaste.org/73701 how would i prove that sum' acc xs = acc + sum' 0 xs (in general, not asking for a specific proof)
15:19:50 <ari> ^ I get ambiguous type variable errors if I leave the type declarations out
15:20:31 <monochrom> "in general", use induction on the []/(x:xs) parameter
15:20:35 <ari> The randomR definition doesn't need the declarations which... doesn't confuse me any further, I guess, since I'm already pretty confused
15:21:10 <hpc> povman: if i was doing this in a language like agda, i think i would do it with a right fold instead of a left one, and then the proof is all but written right into the definition
15:21:33 <hpc> then if the operational details matter, do a proof that both left and right folds are equal to mconcat
15:22:14 <wires> How can one run 'main' from ghci and pass CLI arguments?
15:22:48 <povman> hpc: ah.
15:22:59 <hpc> wires: you want to make it so that when you call main, it does the same thing as "runghc Foo.hs --arg arg arg arg --arg ..."?
15:23:20 <hpc> you would pass the arguments after the file
15:23:26 <hpc> so "ghci Foo.hs --arg ....."
15:23:29 <hpc> then call main
15:23:47 <hpc> that's something i had to do for my IRC bot, way back when
15:24:00 <twanvl> or just use ":main arg arg arg"
15:24:11 <hpc> oh, that works too?
15:24:17 <hpc> damn, wish i knew about that before
15:25:50 <povman> hpc: I was specifically thinking about the left fold version. Are you saying you'd write a right fold version and prove they're the same?
15:26:03 <hpc> povman: it's just what i would do, but yeah
15:26:26 <hpc> the monoidal nature of (0, (+)) makes both folds the same
15:26:42 <hpc> i don't know how you would do it if that tactic wasn't available
15:26:48 <hpc> never had to think about it
15:26:54 <povman> hpc: Thanks for your help.
15:27:36 <povman> I was reading some lecture slides which proved that a right fold sum was the same as a left, wondered if you could just prove that property of the left.
15:27:56 <monochrom> ari: I can't reproduce your problem. I don't need types. "let (x,g') = random g ... in (Coord x y, g'')" works, I don't need "(x::Int, g')"
15:28:08 <monochrom> both ghc 6.12.3 and ghc 7.4.1
15:28:35 <monochrom> (so no excuse about "ghc 7.4 changes let-polymorphism")
15:28:36 <hpc> povman: have you tried #agda or similar channel with your question?
15:28:59 <monochrom> oh, ScopedTypeVariables? let me test again
15:29:25 <Tekmo> So I checked and the answer is a definitely "no"
15:29:29 <sentientwaffle> Tekmo: ah
15:29:30 <monochrom> still no type error
15:29:33 <Tekmo> It is definitely not fusing into a single pass
15:29:46 <sentientwaffle> Tekmo: thanks, that did seem a little too magical :P
15:30:11 <Tekmo> It is possible, though
15:30:27 <Tekmo> But in this case you are better off using the mapWhile version somebody else wrote above
15:30:46 <jmcarthur> i think iterate is not foldr/build fusion friendly
15:30:55 <k00mi> i don't think that version did what sentientwaffle wants
15:30:59 <jmcarthur> works with stream fusion though
15:30:59 <Tekmo> It's not even lazy
15:31:06 <jmcarthur> it's not?
15:31:14 <Tekmo> Oh wait
15:31:17 <Tekmo> I tested the wrong thing
15:31:20 <jmcarthur> > iterate (+1) 1
15:31:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:31:25 <jmcarthur> looks lazy to me :)
15:31:25 <Tekmo> No not like that
15:31:28 <Tekmo> Give me a second
15:31:32 <ari> monochrom: Huh... the only thing my .ghci sets is NoMonomorphismRestriction and that seems to be the cause
15:31:33 <Tekmo> to give the precise example I have in mind
15:31:44 <wires> twanvl, hpc, thanks!
15:32:11 <Tekmo> Oh, never mind
15:32:12 <Tekmo> it still is
15:32:16 <Tekmo> I had the wrong example
15:32:19 <jmcarthur> @src iterate
15:32:19 <lambdabot> iterate f x =  x : iterate f (f x)
15:32:37 * ari reads the page on the monomorphism restriction again, then!
15:32:55 <monochrom> ari: ok, then I can reproduce the type error.
15:33:47 <monochrom> then the randomR version "doesn't need" types because, it still needs types, but "randomR (x1, x2)" already gives the needed type
15:35:05 <k00mi> sentientwaffle: so to be clear, what you want is to repeatedly map over a list while checking for each *element* if a predicate holds, if it doesn't continue the current map but stop afterwards, else continue mapping.
15:35:34 <Tekmo> Well, in his case he has a predicate that he can evaluate on an element-by-element basis
15:35:42 <k00mi> yes
15:36:00 <Tekmo> Here's what he wants
15:36:06 <Tekmo> He wants a function that maps over a list
15:36:11 <Tekmo> and while it is mapping over the list
15:36:13 <Tekmo> it maintains an accumulator
15:36:18 <Tekmo> keeping track of whether it found a 0
15:36:27 <Tekmo> and returns whether or not it found a zero alongside the final list
15:37:16 <Tekmo> So it would be something like
15:37:25 <k00mi> that's how i would implement what i described
15:37:27 <Tekmo> map' acc [] = (acc, [])
15:37:34 <Tekmo> oops
15:37:44 <Tekmo> map' acc _ [] = (acc, [])
15:37:55 <monochrom> ari: ghc 6.12.3 does not have a type error, even with NoMonomorphismRestriction. so it is going to be ghc-version-specific rather than a general misunderstanding of types
15:38:18 <Tekmo> Never mind, I will just write it as a fold
15:38:20 <monochrom> and this time we can use the excuse "ghc 7.4 changes let-polymorphism"
15:39:10 <Tekmo> map' (hasZero, diffList) _ [] = (hasZero, diffList [])
15:39:54 <Tekmo> map' (hasZero, diffList) f (x:xs) = map' (hasZero || x == 0, diffList . (x:)) f xs
15:40:07 <ari> monochrom: Neat, I'll have to take that into account
15:40:10 <ari> monochrom: Thank you for looking into it!
15:40:32 <jmcarthur> :t mapAccumL
15:40:33 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
15:41:00 <Tekmo> Or you can cheat and use the state monad
15:41:01 <Tekmo> !
15:41:09 <jmcarthur> same thing
15:41:12 <Tekmo> :)
15:41:15 <Tekmo> I know
15:41:19 <Tekmo> If you are going to use the state monad
15:41:23 <Tekmo> at least do it right: mapM
15:41:55 <jmcarthur> i'm much more likely to have Data.List imported than Control.Monad.State
15:41:56 <shachaf> Usually folds or mapAccumL are nicer than tiny applications of State s.
15:42:29 <sentientwaffle> Tekmo: so the state monad is the solution?
15:42:55 <Tekmo> (`runStateT` False) $ mapM (\x -> put True >> return x) xs
15:43:02 <thirsteh> Can I do something like: if name /= Nothing then (Just name) else "" ?
15:43:19 <shachaf> thirsteh: Don't use == for checking Nothing. :-(
15:43:24 <Tekmo> Oh wait
15:43:27 <Tekmo> Haha
15:43:28 <Tekmo> :)
15:43:30 <Tekmo> Also
15:43:30 <shachaf> That's a type error anyway.
15:43:31 <Tekmo> runState
15:43:34 <Tekmo> instead of runStateT
15:43:48 <thirsteh> shachaf: how can I check Nothing without a case/guard? I'd like to keep the if/else/then
15:43:57 <shachaf> thirsteh: You should use case instead.
15:44:03 <shachaf> thirsteh: if/then/else is the devil.
15:44:08 <jmcarthur> Tekmo: mapAccumL looks much nicer to me ;)
15:44:13 <twanvl> or use a writer monad even
15:44:20 <Tekmo> (`runStateT` False) $ mapM (\x -> when (x == 0) (put True) >> return x) xs
15:44:26 <thirsteh> shachaf: yes, but in this case I'm concatening a string where each element is a Maybe String
15:44:26 <k00mi> shachaf, thirsteh: he should use the maybe function
15:44:33 <shachaf> thirsteh: OK, maybe not the devil. But, really, it's much nicer.
15:44:39 <Tekmo> Oh yeah
15:44:40 <shachaf> "maybe" or "fromMaybe" is good too.
15:44:41 <Tekmo> writer is better
15:44:43 <Tekmo> Any monoid
15:44:48 <shachaf> But start out by writing case-of.
15:44:55 <thirsteh> shachaf, k00mi: oh, thanks
15:45:13 <Tekmo> runWriter $ mapM (\x -> tell (Any (x == 0)) >> return x) xs
15:45:17 <jmcarthur> writer is also better in that, in theory, there could be such a monad instance for plain tuples
15:45:19 <shachaf> thirsteh: Note that what you wrote is a type error, so I have no idea what you were actually trying to do.
15:45:20 <c_wraith> I've recently learned to start structuring code involving Maybe so that I can use (<=<).  It makes writing small pieces that make sense independently easy.
15:45:27 <jmcarthur> so in theory you could get out of the newtype wrapping
15:45:34 <thirsteh> shachaf: that's why I wrote "can I do something like" :)
15:45:50 <Tekmo> Let me make sure that works
15:45:55 <shachaf> thirsteh: What's your high-level goal?
15:46:01 <thirsteh> shachaf: I thought it was obvious I'm checking if a Maybe String is nothing, using it if it isn't, or using "" if it is
15:46:18 <thirsteh> shachaf: but the maybe func was what I was looking for
15:46:19 <shachaf> Oh.
15:46:28 <Tekmo> Oh, I forgot one last thing
15:46:28 <shachaf> No, fromMaybe is.
15:46:31 <shachaf> @ty fromMaybe ""
15:46:32 <lambdabot> Maybe [Char] -> [Char]
15:46:33 <Tekmo> I forgot to actually map the function
15:46:40 <shachaf> thirsteh: But do you know how to write it with a case?
15:46:56 <shachaf> thirsteh: (case name of Just s -> s; Nothing -> "")
15:47:02 <Tekmo> mapWhile f xs = runWriter $ mapM (\x -> tell (Any (x == 0)) >> return (f x)) xs
15:47:13 <Tekmo> mapWhile (+1) [-1..10]
15:47:19 <Tekmo> ([0,1,2,3,4,5,6,7,8,9,10,11],Any {getAny = True})
15:47:21 <thirsteh> shachaf: ah, that works. I wanted to keep it concise, didn't know you could use semicolon
15:47:41 <otters> mapWhile?
15:47:46 <Tekmo> for lack of a better name
15:47:49 <Tekmo> He asked for a function
15:47:52 <otters> I don't understand what it does
15:47:55 <Tekmo> Haha
15:47:58 <Tekmo> Yeah, bad name
15:48:02 <Tekmo> more like mapCond
15:48:08 <Tekmo> He wanted a function that would traverse a list once
15:48:12 <shachaf> Even if you couldn't do semicolon, you should start with the case and change it from there.
15:48:12 <Tekmo> and while traversing check a condition
15:48:20 <Tekmo> in this case, whether there was a 0 in the list
15:48:29 <Tekmo> He wanted to do it in a single pass
15:48:38 <Tekmo> Instead of dropWhile (elem 0) . map f
15:48:44 <jmcarthur> :t \f -> traverse (\x -> (Any (x==0), f x))
15:48:45 <lambdabot> Not in scope: `traverse'
15:48:47 <sentientwaffle> Tekmo: thanks!
15:48:51 <jmcarthur> :t \f -> Data.Traversable.traverse (\x -> (Any (x==0), f x))
15:48:52 <lambdabot> forall a b (t :: * -> *). (Num a, Data.Traversable.Traversable t) => (a -> b) -> t a -> (Any, t b)
15:49:04 <Tekmo> Oh
15:49:07 <Tekmo> I like that last one
15:49:10 <Tekmo> that jmcarthur wrote
15:49:17 <Tekmo> Much better
15:49:31 <jmcarthur> :t \f -> first getAny . Data.Traversable.traverse (\x -> (Any (x==0), f x))
15:49:32 <lambdabot> forall a b (t :: * -> *). (Num a, Data.Traversable.Traversable t) => (a -> b) -> t a -> (Bool, t b)
15:50:40 <jmcarthur> :t \f -> first getAny . Data.Traversable.traverse (Any . (==0) &&& f)
15:50:41 <lambdabot> forall a b (t :: * -> *). (Num a, Data.Traversable.Traversable t) => (a -> b) -> t a -> (Bool, t b)
15:51:52 <Tekmo> sentientwaffle
15:51:57 <Tekmo> I'll explain jmcarthur's solution
15:52:12 <sentientwaffle> Tekmo: so its a pseudo-state monad using pairs?
15:52:18 <Tekmo> It's the writer monad
15:52:35 <Tekmo> Writer w r = (Monoid w) => (w, r)
15:52:36 <sentientwaffle> hm, not familar w/ that one
15:52:45 <Tekmo> Basically
15:52:52 <Tekmo> return r = (mempty, r)
15:52:57 <sentientwaffle> ah
15:53:16 <sentientwaffle> whats Any?
15:53:39 <Tekmo> (w, a) >>= f = let (w', b) = f a in (w <> w', b)
15:53:45 <Tekmo> The Any monoid
15:53:52 <Tekmo> where mempty = False
15:53:55 <Tekmo> and mappend = (||)
15:54:06 <Tekmo> It returns true if any of the mappended values is True
15:54:15 <Tekmo> and False if all of them are False
15:54:27 <Tekmo> Monoids are used quite often for folds
15:54:40 <hpc> monoids are awesome
15:54:44 <Tekmo> for example, consider Haskell's "or" function
15:54:48 <Tekmo> :t or
15:54:49 <lambdabot> [Bool] -> Bool
15:54:59 <Tekmo> It returns True if any value in the list is True
15:55:01 <Tekmo> False otherwise
15:55:13 <Tekmo> > or [True, False, False]
15:55:14 <lambdabot>   True
15:55:18 <Tekmo> or [False, False]
15:55:21 <Tekmo> > or [False, False]
15:55:23 <lambdabot>   False
15:55:35 <Tekmo> Monoids ahve a useful function called mconcat
15:55:39 <theorbtwo> > or [False, True, _|_]
15:55:40 <lambdabot>   <no location info>: parse error on input `|'
15:55:40 <Tekmo> Which folds a list using mempty and mappend
15:55:50 <Tekmo> mconcat = foldr mappend mempty
15:55:50 <mikeplus64>  or [False, True, undefined]
15:55:52 <mikeplus64> > or [False, True, undefined]
15:55:53 <lambdabot>   True
15:55:57 <Tekmo> So we can write the or function as
15:56:12 <Tekmo> or = getAny . mconcat . map Any
15:56:24 <Tekmo> It wraps every value in the Any constructor to choose the appropriate monoid instance
15:56:32 <Tekmo> Folds them using the monoid instance for Any
15:56:35 <Tekmo> which behaves like "or"
15:56:40 <Tekmo> And then just unwraps the result
15:56:50 <Tekmo> The other monoid for bools is the "All" monoid
15:56:53 <Tekmo> where
15:56:58 <Tekmo> mempty = True
15:57:03 <Tekmo> mappend = (&&)
15:57:13 <Tekmo> and = getAll . mconcat . map All
15:57:24 <Tekmo> > and [True, True, True]
15:57:25 <lambdabot>   True
15:57:30 <Tekmo> > and [True, False, True]
15:57:31 <nejucomo> I see no documentation for http in my cabal doc index.  I just did "cabal install --reinstall HTTP" but there's still no documentation.
15:57:31 <lambdabot>   False
15:57:41 <Tekmo> So what jmcarthur did
15:57:45 <nejucomo> Is there a way to get a package's manifest (-list of installed file paths)?
15:57:49 <Tekmo> was take every element in the list
15:57:57 <mikeplus64> nejucomo: sure you've got documentation: True in ~/.cabal/config ?
15:58:00 <Tekmo> associate it with a Bool marking whethero r not it was 0
15:58:17 <Tekmo> and then folded the monoid to get whether there was a 0 anywhere in the list
15:58:28 <sentientwaffle> ah, and Any was indicating which kind of fold it was
15:58:32 <Tekmo> Right
15:58:39 <Tekmo> So if you wanted to check if they were ALL 0
15:58:44 <Tekmo> you would use the All monoid instead
15:59:26 <Tekmo> So if you take the type of traverse and specialize it to the writer monoid
15:59:29 <Tekmo> it looks like this
15:59:37 <nejucomo> mikeplus64: Yes.
15:59:40 <Tekmo> traverse :: [Writer w r] -> Writer w [r]
16:00:03 <Tekmo> It factors out all the monoids in the list into a single value
16:00:06 <Tekmo> while preserving the list
16:00:24 <mikeplus64> nejucomo: that's odd
16:00:40 <jmcarthur> eh... half truths...
16:00:50 <nejucomo> pebkac - I just needed to reload the html index.  :-/
16:00:55 <hpc> @unmtl [Writer w r] -> Writer w [r]
16:00:55 <lambdabot> [Writer w r] -> Writer w [r]
16:00:58 <hpc> aw
16:01:04 <Tekmo> Oops
16:01:08 <Tekmo> I'm confusing it with sequence
16:01:13 <Tekmo> But basically the same idea
16:01:16 <Tekmo> :t sequence
16:01:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:01:22 <Tekmo> :t Data.Traversable.traverse
16:01:23 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:01:41 <Tekmo> If t is a monad
16:01:48 <Tekmo> you can replace traverse with mapM
16:01:52 <Tekmo> :t mapM
16:01:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:01:58 <jmcarthur> you mean if f is a monad
16:02:02 <Tekmo> Oh yeah
16:02:05 <Tekmo> If f is a monad
16:02:07 <Tekmo> and t is a list
16:02:22 <jmcarthur> in fact, there is this:
16:02:26 <Tekmo> So you could specialize the solution he gave to mapM
16:02:27 <jmcarthur> :t Data.Traversable.mapM
16:02:28 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
16:02:37 <Tekmo> Yeah, but I always have Control.Monad in my import list
16:02:40 <jmcarthur> the problem is there is no instance of Monad for pairs like that
16:02:41 <Tekmo> and Data.Traversable less so
16:02:50 <Tekmo> There is the Writer monad
16:02:53 <jmcarthur> in the current world
16:02:57 <Tekmo> m = Writer w
16:03:03 <jmcarthur> sure, but that requires having it in scope and doing more newtype wrapping
16:03:04 <Tekmo> Writer Any
16:03:36 <Tekmo> I'd prefer Control.Monad.Writer over Data.Traversable
16:03:43 <Tekmo> especially since the meat of it is the Writer monad
16:04:18 <jmcarthur> to each his own
16:05:02 <Tekmo> So if you use mapM and the Write rmonad, you'd get: mapM (\x -> Writer (Any  (x ==0), f x)) xs
16:05:31 <EvilMachine> hmm… is it possible to have a zipper with multiple “handles” pointing to different positions in the zipper chain?
16:05:44 <EvilMachine> (with a variable number of "handles"
16:05:46 <EvilMachine> )
16:06:05 <Tekmo> You mean while still preserving the Comonad instance?
16:06:24 <Tekmo> I mean, you can, simply declaring the data type
16:06:30 <Tekmo> but it depends on what you want to use it for
16:07:47 <Tekmo> Do the handles have to always be "spaced" apart the same distance?
16:07:59 <Tekmo> Let's use the example of a list with two adjacent foci
16:08:17 <Tekmo> data TwoFoci a = (Stream a, a, a, Stream a)
16:08:26 <Tekmo> You could then shift that left and right the same way you do an ordinary zipper
16:08:35 <Tekmo> But let's say you want to be able to move the two foci independently
16:08:38 <Tekmo> Then you could do
16:08:47 <Tekmo> data TwoFoci a = (Stream a, a, [a], a, Stream a)
16:08:59 <Tekmo> Where the 2nd and 4th elements of the tuple are the two foci
16:10:00 <Tekmo> However, that data type wont' handle the two foci moving through each other
16:10:05 <Tekmo> I'm trying to think of a mroe general solution
16:10:55 <Tekmo> One possible solution
16:10:59 <Tekmo> is to just keep a master list
16:11:05 <Tekmo> and the foci are represented as indices instead of values
16:11:16 <twanvl> what should even happen when the two foci overlap?
16:11:21 <Tekmo> No clue
16:11:40 <Tekmo> But
16:11:45 <Tekmo> let's say you had an indexed stream
16:11:49 <Tekmo> Then you could do
16:11:58 <twanvl> maybe you should always focus on one of the foci
16:12:21 <Tekmo> How about this
16:12:28 <Tekmo> You first define a bidirectional indexable stream
16:12:42 <Tekmo> data BStream a = (Stream a, Stream a)
16:12:51 <Tekmo> Where the left hand stream are the negative values
16:12:52 <nejucomo> I'm making my first foray into threads...  I get this: thread blocked indefinitely in an MVar operation
16:12:58 <Tekmo> and the right hand stream are the non-negative values
16:13:00 <Tekmo> I mean
16:13:03 <Tekmo> non-negative indices
16:13:11 <Tekmo> So then you can index into the stream using some operation
16:13:20 <Tekmo> (!) :: BStream a -> Int -> a
16:13:27 <Tekmo> Then you can define a zipper with two foci using
16:13:41 <Tekmo> type TwoFoci a = (BStream a, Int, Int)
16:13:42 <Cale> nejucomo: This happens when you try to read an empty MVar or write to a full one, but no other thread has a pointer to that MVar anymore, so the system detects that your thread will never become unblocked.
16:13:59 <nejucomo> There are two threads which are blocked on readChan, but I expect each to receive a message eventually.
16:14:17 <nejucomo> Does this message mean ghc runtime detects that one of the channels will never be written to?
16:14:18 <Cale> Basically, the RTS has proved that you'll never wake up.
16:14:22 <Cale> yes
16:14:43 <nejucomo> huh.
16:14:53 <nejucomo> I wonder how I could tell which of the two threads it is.
16:15:09 <Cale> I guess you could catch the exception.
16:16:43 <nejucomo> Thanks for the help.
16:22:39 <hpaste> meretrix pasted “cabal-dev install failure” at http://hpaste.org/73704
16:23:57 <meretrix> Hi. I am trying to install cabal-dev, but I'm getting a "connection time out" error: http://hpaste.org/73704
16:24:14 <meretrix> Is there any way to debug it to get more information about what is failing?
16:24:29 <Cale> meretrix: Looks like you're having network problems?
16:24:55 <Cale> (or maybe hackage is)
16:25:28 <meretrix> I don't think I am. I've retried it multiple times and it always fails on zlib.
16:25:57 <luite> hackage seems to be down
16:26:33 <meretrix> Oh. Did that just happen? It downloaded many other dependencies without problems.
16:27:00 <sheldonh> i thought it was just me
16:27:58 <Tekmo> http://www.downforeveryoneorjustme.com/http://hackage.haskell.org/
16:28:00 <Tekmo> It's down
16:28:14 <sheldonh> awesome website :)
16:28:18 <Tekmo> :)
16:29:00 <sheldonh> puts a bit of a downer on the learning experience :)
16:29:49 <Tekmo> Then we'll compile your code for you!
16:29:57 <sheldonh> heyyyyyy, that site thinks everything's down :)
16:30:24 <Tekmo> Oh, you're right
16:30:29 <Tekmo> That's lame
16:30:44 <Tekmo> I've been living a lie
16:30:53 <sheldonh> welcome to the human race :)
16:35:22 <aristid> and the new hackage seems to be down too!
16:35:31 <Tekmo> Yeah
16:44:00 <hpaste> Yiq pasted “mongodb - not starting” at http://hpaste.org/73705
16:47:53 <nejucomo> Can anyone recommend an http client library that supports https with some control over certificate authentication?
16:48:16 <nejucomo> (If there's no control but it verifies against the platforms CA roots that's ok I guess.')
16:51:46 <DT`> is hackage down again?
16:52:12 <mauke> looks like it
16:52:28 <monochrom> onoes, let me test
16:53:53 --- mode: ChanServ set +o monochrom
16:54:19 --- topic: set to '["hackage is down","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
16:54:26 --- mode: monochrom set -o monochrom
16:55:10 <monochrom> seems like a weekly function now!
16:56:43 <DT`> someone should write an ishackagedown bot and put it on hackage, IMO.
16:57:11 <aristid> monochrom: i hope it can be fixed over the weekend
16:57:14 <monochrom> it's called "cabal update" :)
16:58:54 <nejucomo> Hrm. I haven't found a solution to my https need yet after some searching...
17:24:51 <sheldonh> is arccos from the law of cosines acosh in haskell?
17:25:16 <mauke> no, acos = arccos
17:26:03 <sheldonh> definitely bed time, then :)
17:30:42 <nexion> how does the haskell runtime know how many OS threads to use? and does it spawn more as needed?
17:30:58 <mauke> you tell it
17:31:04 <mauke> there's a command line option for it
17:31:36 <nexion> is there a way to let it increase that if the traffic picks up?
17:31:40 <nexion> without restarting
17:31:53 <mauke> what's the point of that?
17:32:02 <jmcarthur> also, if you just pass +RTS -N without a number, it chooses based on the number of cores you have
17:32:10 <m3ga> nejucomo: http-conduit allows control over certificate authentication/ i point you to it but hackage is down
17:32:14 <Eduard_Munteanu> CPU hotplugging?
17:32:34 <jmcarthur> it will spawn more if needed for system calls, if that's what you mean
17:32:35 <napping> or running programs other than yours
17:33:06 <napping> nexion: nothing built in intentionally adjusts the number of threads
17:33:37 <jmcarthur> it will not automatically add additional threads to share load, that is
17:34:17 <napping> do calls back from C just leave the thread bound, or actually make the thread available for running Haskell?
17:35:05 <jmcarthur> the number of capabilities doesn't change, but afaik this isn't necessarily the same as the number of os threads
17:35:29 <jmcarthur> my knowledge is too fuzzy to be more precise
17:35:32 <nexion> I'm realizing that this way is probably best
17:35:41 <nexion> adding threads beyond the number of cores won't help
17:36:32 <nus> nejucomo, curl or http-conduit
17:36:51 <hpc> nexion: what kind of threads? lightweight threads can easily number into the hundreds of thousands, and don't have much bearing on performance
17:36:58 <nexion> hpc: OS threads
17:37:02 <edenc> hey guys, what's the best way to get cabal going on osx?
17:37:08 <hpc> gotcha
17:37:32 <nexion> hpc: I was asking about the default number and if the runtime somehow released/spawned some as needed
17:37:47 <Eduard_Munteanu> Probably not, assuming lightweight threads can increase beyond the number of cores.
17:38:11 <hpc> iirc, +RTS -N determines the number of capabilities
17:38:35 <hpc> (at start of execution; a little-used feature of GHC lets you add more, but not release them)
17:39:08 <byorgey> you CAN increase the number of capabilities in sufficiently recent versions of GHC.
17:39:17 <hpc> i think capabilities can be shuffled between OS threads
17:39:30 <byorgey> I do not remember what counts as sufficiently recent
17:40:02 <byorgey> edenc: install the Haskell Platform
17:40:12 <edenc> byorgey: the one from macports?
17:40:22 <byorgey> edenc: hmm, I don't know
17:41:14 <edenc> haskell.org is pointing me to hackage which is down :(
17:41:46 <JoeyA> Hmmpfh, both Hackages are down (package list, that is)
17:42:07 <JoeyA> [Package] is not an efficient representation, I'm telling you!
17:54:38 <mikeplus64> JoeyA: is that what they use?
17:55:52 <JoeyA> mikeplus64: I'm just poking fun at the website title, which reads "Hackage :: [Package]"
17:55:55 <mikeplus64> actually, where can one find the source for hackage 1 or 2?
17:56:13 <JoeyA> Oh, that's on Hackage... oh wait
17:56:43 <JoeyA> I think it's here: http://hub.darcs.net/simon/hackage-server/changes
17:58:25 <mikeplus64> alright
17:58:29 <mikeplus64> (also darcsden is neat)
18:04:22 <Bart_Massey> Anyone know when Hackage might be back up?
18:04:41 <Bart_Massey> Or why it's down, or anything?
18:05:30 <tgeeky> I know a few things, but nothing relevant.
18:05:35 <mauke> I only know mirrors
18:06:00 <Bart_Massey> mauke: a mirror would be great...
18:06:13 <Bart_Massey> would like to get some stuff done right now :-)
18:06:15 <mauke> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
18:08:05 <Bart_Massey> Thanks! I'll try to figure out how to get it going.
18:09:12 <mauke> you can put that in your ~/.cabal/config
18:09:31 <Bart_Massey> Yeah, getting there
18:30:01 <nejucomo> m3ga, nus: Thanks for the curl & http-conduit tips.
18:30:22 <jfischoff> Has anyone used HsShellScript?
18:32:06 <jfischoff> is hackage2 up?
18:32:58 <shachaf> jfischoff: Neither Hackage 1 nor Hackage 2, I think.
18:33:07 <jfischoff> oh well
18:38:31 <m3ga> nejucomo: my experience with the curl bindings were not good. the api is too close to the C api and its really inconsistent. htt-conduit on the other hand is excellent.
18:38:59 <luite> and you make windows users happier
18:54:26 <edwardk> @tell roconnor decided to go with Bazaar as a slightly less white-trashy version name than Mall ;)
18:54:26 <lambdabot> Consider it noted.
18:55:01 <ivanm> edwardk: you wouldn't be developing another DVCS now, would you? :p
18:55:18 <edwardk> ivanm: hah, no, just a funny comonad that comes up when you try to characterize traversals
18:56:47 <aristid> edwardk: i think Mall is a better name because it doesn't sound like a DVCS
18:56:52 <edwardk> aristid: hah
18:58:23 <edwardk> the main thing is that you do a lot of trading there, so a mall is a bad model
18:58:32 <edwardk> at a bazaar you can envision a lot of trading happening
19:00:19 <shachaf> "Number of comonads released by edwardk will exceed the number of words in the English language by 2015, experts report."
19:00:27 <edwardk> heh
19:01:11 <shachaf> Maybe you'll have abandoned English for naming them by then.
19:02:50 <ivanm> I think I've worked out my State monad problem: DLists aren't "lazy" in the sense of being able to repeatedly snoc something onto the end, convert the result to a list and then take something
19:03:05 <ivanm> @remember shachaf "Number of comonads released by edwardk will exceed the number of words in the English language by 2015, experts report."
19:03:05 <lambdabot> It is stored.
19:03:08 <Ralith> shachaf: how long until he exhausts unicode?
19:03:38 <aristid> i recommend starting to name comonads numerically
19:03:38 <edwardk> ivanm: yeah you can and should only use Dlists effectively when you need to consume it once
19:03:38 <Saizan> ivanm: heh, no, you get no sharing there
19:03:43 <shachaf> ivanm: Yes, DLists are "write-only" until you apply them to []
19:03:49 <ivanm> Ralith: unicode keeps getting more characters...
19:04:09 <Ralith> ivanm: well, plot that one too, and see whether it converges!
19:04:17 <ivanm> edwardk: I only use it once; the problem is that I typically produce a DList, convert it to a list and then only need a prefix of it, but the entire list is produced first :s
19:04:29 <edwardk> that too =)
19:05:00 <ivanm> so is there a better data structure I can use to keep appending values, and then at the end convert it to a list and only lazily consume it?
19:05:07 <ivanm> Sequences are spine-strict, aren't they?
19:06:21 <Saizan> YES
19:06:36 <ivanm> Saizan: which question is that an answer to? :p
19:06:52 <shachaf> ivanm: Looks like Saizan's pretty serious about sequences being spine-strict. You'd better believe him.
19:06:56 <Saizan> sequences are spine-strict (with a caps on for no reason)
19:06:59 <ivanm> heh
19:07:39 <shachaf> What are you doing?
19:07:49 <ivanm> shachaf: traversing a graph
19:08:07 <ivanm> took me a while to work out why traversing more than one component was so much slower :s
19:08:21 <ivanm> that's what I've spent most of last week trying to figure out
19:08:55 <ivanm> I kept thinking it was something to do with the State monad, as it only seemed to occur if I tried to get a value from it after the first component
19:10:37 <ivanm> i.e. in "liftM2 DL.append getOneComponentAsDList f", if `f' is just "return DL.empty" it was fine; but if I changed that to something like "f = do numNs <- gets $ M.size traversedNodes ; numNs `seq` return DL..empty" it would massively slow down
19:16:10 <mgsloan> I'm sure that y'all have heard enough by now of the hackage woes, but this was really the wrong day - just got a new laptop!
19:16:51 <edwardk> mgsloan: you can point cabal to luite's mirror and get by in the meantime you know
19:17:28 <edwardk> mgsloan: see https://github.com/ekmett/lens/blob/master/config#L10 on how to edit your ~/.cabal/config
19:18:01 <ivanm> edwardk: something like that should probably get put in the /topic ...
19:18:35 <edwardk> probably
19:18:41 <mgsloan> yeah, true!  Is that truly seamless? I think I had some minor problems with it before.  Maybe I did something wrong
19:18:51 <ivanm> though it'd be nice when we can officially have a concept of a hackage mirror
19:19:00 <edwardk> it works for reading, not for publishing
19:19:07 <ivanm> mgsloan: I think you'd have to comment/uncomment the stuff in your ~/.config to switch back and forth
19:19:08 <mgsloan> we need a "ishackagedown.com" with those instructions
19:19:13 <ivanm> heh
19:20:18 <mgsloan> is it an increase in load that's caused the more recent frequency of outages?  If so, that's a pretty good sign!
19:20:31 <ivanm> is Galois still hosting hackage?
19:20:32 <edwardk> mgsloan: nah, its galois being offline
19:21:07 <shachaf> Oh, galois.com is down too.
19:21:10 <shachaf> Must be serious.
19:21:12 <mgsloan> edwardk: ahh.  Don't they have a DSL for that ;)
19:21:58 <edwardk> we're doing a committee meeting in a couple of weeks. i want to try to use it to get a plan for getting hackage 2 set up somewhere with a more reliable connection, figure out some kind of content delivery network we get set up in front of it to serve up content even if the server itself goes down, and figure out how we can make this crap stop happening
19:22:10 <mgsloan> runServer hackage $ ServerConfig { uptimeRequest = 99.9999 }
19:22:26 <edwardk> shachaf: likely something to do with their new connection
19:22:32 <mgsloan> edwardk: awesome!
19:23:05 <ivanm> edwardk: get a cloud instance or something and let someone else deal with the server management, etc.?
19:23:16 <edwardk> mgsloan: haven't made it happen yet. in any event it is likely to need more help from the community for maintenance, etc.
19:23:36 <edwardk> ivanm: thats pretty much the idea. sclv started shopping around already
19:23:42 <ivanm> *nod*
19:24:06 <edwardk> don't want to burn any bridges though, so things go slow
19:24:15 <ivanm> going back to my question from earlier: is there a better data structure I can use to keep appending values, and then at the end convert it to a list and only lazily consume it?
19:24:40 <edwardk> ivanm: you're going to pay some kind of logarithmic cost in there if you want incremental reads
19:24:51 <ivanm> I only want to read at the end
19:24:55 <ivanm> not during the process
19:24:55 * mgsloan modifies cabal/bootstrap.sh to point to luite's
19:25:20 <edwardk> well, have you tried one of the queue types that okasaki describes?
19:25:29 <napping> what do you mean "at the end ... lazily consume it"?
19:25:32 <ivanm> hmmm, no...
19:26:03 <ivanm> napping: well, I convert the list-like structure into an actual list, and then I usually only need a prefix of it
19:26:15 <edwardk> if you occasionally build chunks then a bootstrapped queue probably works best
19:26:37 <napping> if control flow forces you to go through all the construction before you get the final value, it probably doesn't help to conusme it lazily
19:27:12 <ivanm> edwardk: in the zipper kind of sense?
19:27:46 <tuttlem> Hi all, I'm trying to lookup actions that I can perform on an IO list but haven't been able to find much. I'm just struggling to get an indexed item out a list. Can someone help me please?
19:27:55 <ivanm> napping: it doesn't; the problem is that I snoc values onto the end just before turning it into a list, and with DList that means that the snoc'd value gets evaluated first
19:28:10 <ivanm> (and the way I'm constructing it means it needs to evaluate everything before it as well)
19:28:14 <napping> > let dcons c s = (c:) . s; drepeat c = dcons c (drepeat c) in take 10 (drepeat 'x' "")
19:28:16 <lambdabot>   "xxxxxxxxxx"
19:28:41 <ivanm> tuttlem: do xs <- myIOList; <do stuff with xs>
19:29:01 <ivanm> napping: I'm _snoccing_ a value onto the end
19:29:07 <ivanm> that's the bit that makes it expensive
19:29:20 <ivanm> I take that back: I'm appending another DList onto the end
19:29:44 <edwardk> something like
19:29:46 <ivanm> but this is within a State monad, and to create that appended DList it needs to run through the State to construct the initial DList
19:30:14 <napping> that doens't change my example, unless getting your hands on the final data structure forces the computation
19:30:16 <ivanm> ` take 3 DL.toList $ foldl' DL.snoc DL.empty [1..] ' doesn't end...
19:30:21 <edwardk> data Q a = Empty | Q [a] (Q [a]) !Int [a] !Int
19:30:34 <ivanm> edwardk: what are the Ints for?
19:30:34 <tuttlem> ivanm: thanks for throwin' me a bone! I'll try to get that running in my code!
19:30:56 <edwardk> the first is the size of the front plus the middle, the latter is the size of the tail
19:31:28 <ivanm> edwardk: don't know the sizes...
19:31:42 <edwardk> you build them up as you build the queue
19:31:50 <napping> > let drepeat c = ((c:) . drepeat c) in take 10 ((drepeat 'x' . drepeat 'x') "")
19:31:52 <lambdabot>   "xxxxxxxxxx"
19:32:10 <edwardk> you probably can't get all the properties you want
19:32:13 <napping> what's the computation doing, that you can lazily evaluate?
19:32:59 <ivanm> napping: the actual list I'm constructing is a traversal through a graph, and I use that to find which edge produces a canonical example by finding the minimum of all possible traversals
19:33:02 <ivanm> (this is simplified)
19:33:12 <ivanm> the problem comes about when I try to let my traversal also deal with multiple components
19:34:43 <napping> if the rest of the computation is forced by deciding whether or not to snoc on a value, you won't get a lazy traversal out of a data structure exposing a snoc operation
19:35:26 <napping> can you instead have the earlier stages cons values onto the result of the rest of the traversal?
19:35:56 <ivanm> the definition of append is (from memory): append (DList xs) (DList ys) = DList $ xs . ys
19:36:24 <napping> yeah, that should be lazy (at least if DList is a newtype)
19:36:39 <ivanm> but when you convert that to a list, it first evaluates ys, does it not?
19:36:56 <napping> no, it goes (xs . ys) rest => xs ++ (ys rest)
19:37:33 <napping> (.) is not strict in the second argument
19:37:52 <ivanm> well, the value of ys is dependent on the state created when making xs
19:37:59 <mauke> more like (xs . ys) rest = xs (ys rest) by the definition of .
19:38:33 <napping> so ys should be a thunk over some arguments you came up with when computing xs
19:39:10 <ivanm> in "liftM2 DL.append getOneComponentAsDList f", if `f' is just "return DL.empty" it was fine; but if I changed that to something like "f = do numNs <- gets $ M.size traversedNodes ; numNs `seq` return DL..empty" it would massively slow down
19:39:17 <napping> if DList is actually a constructor, the definition you write is too strict
19:39:23 <ivanm> napping: it's a newtype
19:41:15 <ivanm> to me, that only makes sense if it's trying to evaluate the DList produced by f before it actually appends the DList from the first component
19:41:42 <napping> or if your monad is too strict
19:41:59 <ivanm> I'm using Control.Monad.Trans.State
19:42:23 <ivanm> I don't think it's strict...
19:42:58 <napping> try using explicitly Control.Monad.Trans.State.Lazy
19:43:31 <napping> should be the same
19:43:43 <ivanm> well, seeing as how C.M.T.S just re-exports the .Lazy one...
19:44:56 <Saizan> if you use the lazy state you should try consing from the parent calls rather than snocing in the children
19:49:58 <mgsloan> hmm, has anyone compiled cabal with ghc 7.6?  I'm getting Module `Prelude' does not export `catch'
19:50:46 <mgsloan> ahh, nvm
19:50:58 <monochrom> oh, ghc 7.6's Prelude doesn't export "catch" which is quite old
19:51:09 <monochrom> although, that "catch" is still in Haskell 2010
19:51:14 <mgsloan> (using bootstrap.sh with an older(?) hackage mirror)
19:51:46 <mgsloan> (just gotta do the packages manually, maybe I'll use trunk versions of everything)
19:52:18 <monochrom> I use stable released versions of everything :)
19:52:35 <mgsloan> :)  I guess I live dangerously!
20:03:11 <luite> mgsloan: if you use my mirror, that's at most 10 minutes older than hackage
20:03:37 <mgsloan> luite: really? cool!  I shoulda known
20:03:52 <edwardk> luite++ the mirror is a godsend
20:04:04 <mgsloan> I just thought it wasn't because I thought there were versions of cabal beyond 0.14, but probably only trunk
20:04:16 <mgsloan> yeah, and HDiff is pretty cool in itself :D
20:04:22 <shachaf> edwardk: I'd've thought that the mirror, being download-only, wouldn't help with your Hackage withdrawal at all.
20:04:31 <edwardk> shachaf: =P
20:05:02 <edwardk> it lets me keep testing lens. i've got a couple of lines i patch into my .travis.yml file when hackage goes down that sends everything to luite
20:05:13 <edwardk> then i don't get spammed with failed build messages all day
20:10:31 <ivanm> Saizan: I'm appending something to the end (I got confused, it's definitely an append and not a snoc)
20:11:25 <ivanm> the exception being when I'm recording the list of traversed nodes and edges; then I snoc each new one to the end of the already existing list
20:12:20 <ivanm> but I'm not trying to use that for this; it's just created
20:12:39 <ivanm> and then discarded (in this case I'm not using that value)
20:28:08 <edwardk> score. the data traversals for lens are now ~25% faster than the equivalents from uniplate rather than 80% slower
20:28:25 <shachaf> Does lens replace uniplate or something now?
20:28:28 <mgsloan> !!
20:28:32 * shachaf hasn't been keeping track.
20:28:33 <jfischoff> I was just about to ask
20:28:35 <edwardk> yes
20:28:52 <edwardk> Control.Lens.Plated is basically a drop in replacement for uniplate that uses traversals
20:29:04 <edwardk> and Data.Data.Lens exports usable 'uniplate' and 'biplate' traversals
20:29:26 * jfischoff heads to github
20:29:39 <edwardk> jfischoff: let me push, one sec
20:30:08 <edwardk> pushed
20:30:55 <edwardk> i'll upload haddocks in a sec
20:33:00 <edwardk> http://ekmett.github.com/lens/Control-Lens-Plated.html
20:33:09 <shachaf> The "plate" in "uniplate" comes from "scrap your boilerplate"?
20:33:13 <shachaf> I feel like I should've realized that.
20:33:51 <edwardk> shachaf: yeah. thats part of why i felt the need to spell it out
20:38:22 <edwardk> jfischoff: oh yeah, thats right you were interested in uniplate/multiplate, so i guess this is right up your alley =)
20:38:37 <jfischoff> yeah very much so
20:38:53 <jfischoff> reading through the code
20:39:18 <edwardk> thoughts?
20:39:41 <edwardk> the ratio of comments to code in there is somewhat overwhelming =)
20:39:52 <ivanm> edwardk: wait, you commented your code? :o
20:39:54 * ivanm faints
20:40:28 <jfischoff> right, I'm still don't have all types in my head, but I like that you are copying the uniplate api which I like
20:40:31 <shachaf> ivanm: It's the innovation week that never ended!
20:40:31 <edwardk> ivanm: lens as 100% haddock coverage on everything the user can see, it has doctests, quickcheck properties, and benchmarks ;)
20:40:41 <edwardk> er has
20:40:58 <ivanm> who are you and what have you done with edwardk?!?!?
20:41:08 <edwardk> innovation week was machines i think. or maybe i'm confused
20:41:35 <shachaf> Coming up next: Language.Haskell.Lens.x86code replaces GHC, and generates 15% faster code.
20:42:09 <edwardk> ivanm: crap you're on to me. i'll let him out of the cage. i just thought i could do some good while I was here. Now back to your regularly scheduled edwardk
20:42:33 <shachaf> ivanm: Now look what you've done. :-(
20:42:56 <edwardk> basically the data traversals i was doing were already faster than the ones used by uniplate i'd just screwed up and was calculating the hit mask every time
20:44:22 <Dodek> every time i look at #haskell, there are lenses everywhere
20:44:38 <Dodek> guess i'll need to catch up a bit :)
20:44:42 <edwardk> thats because lenses are awesome
20:44:50 <edwardk> or its because i like to talk
20:44:55 <edwardk> its one of the two, or maybe both
20:45:14 <mgsloan> definitely both :D
20:45:20 <Dodek> or you're creating history!
20:45:22 <m3ga> oh damn! hackage down this week end as well!
20:45:45 <mgsloan> all three! bidirectional programming is going mainstream!!
20:45:46 <mgsloan> ... within Haskell ;)
20:46:24 <jfischoff> edwardk: Well this very cool. I have some Uniplate code I was going to write next (whenever that is). I'll use this as a replacement and try it out.
20:46:36 <edwardk> m3ga: https://github.com/ekmett/lens/blob/master/config#L10 copy that line into your ~/.cabal/config file and comment out your remote-repo line, that will let you get by
20:47:01 <edwardk> jfischoff: great. =) i'm going to add smarter traversals to GHC.Generics.Lens now that i know how to make them fast
20:47:11 <edwardk> that way i can benchmark Generic vs. Data
20:47:57 <nejucomo> I want to get a time string formatted as iso8601.  Why does Data.Time.Format (formatTime) need a locale when it also takes a format specification string?
20:48:02 <shachaf> What's Generic?
20:48:08 <nejucomo> -for the UTC time zone.
20:48:12 <edwardk> Generic will probably lose. Data.tinplate seems to be about 30% faster
20:48:18 <shachaf> Oh, is it that thing that turns types into :+ and :* and all that?
20:48:23 <edwardk> GHC.Generics
20:48:24 <edwardk> yeah
20:49:42 <m3ga> edwardk: i know about that. i'm interested in the bug tracker.
20:49:47 <m3ga> :-)
20:50:07 <edwardk> m3ga: ah, well, you can at least know that no new bugs have been filed in the last few hours ;)
20:50:27 <nejucomo> cabal says of System.Locale: It is a member of the hidden package `old-locale-1.0.0.4'.
20:51:00 <m3ga> edwardk: i have no problem with people filing bugs. filing good bug reports is good. it result in patches and tests.
20:51:12 <nejucomo> I feel like I must be using a deprecated api.
20:51:36 <edwardk> nejucomo: there is 'old-locale' but at last check no 'locale' to replace it ;)
20:52:32 <jfischoff> edwardk: how hard do you think it will be to make plate "families" so we can change the types? Is that still something your mulling over?
20:52:48 <edwardk> keep chewing on it, but its hard
20:52:53 <nejucomo> edwardk: I don't understand why formatTime takes both a locale and a format string.
20:52:58 <jfischoff> I bet
20:53:36 <edwardk> notice the uniplate combinators i export are actually more permissive in the types than the traditional uniplate combinators, but i still can't change types out
20:53:52 <jfischoff> no I haven't noticed that, how so?
20:54:24 <edwardk> holesOf :: LensLike (Bazaar c c) a b c c -> a -> [Context c c b]
20:54:31 <jfischoff> wait Traversal has a functor in it right
20:54:44 <edwardk> Traversal uses Applicative, Lens uses Functor
20:54:50 <jfischoff> ah right
20:55:04 <jfischoff> what's Bazaar?
20:55:35 <edwardk> http://ekmett.github.com/lens/Control-Lens-Internal.html#t:Bazaar
20:55:54 <edwardk> its a particularly interesting indexed comonad
20:56:06 <jfischoff> interesting
20:56:10 <edwardk> its a 'lot of stores'
20:56:38 <djahandarie> lol at that naming
20:56:42 <edwardk> =)
20:57:26 <edwardk> its also funny in that the type arguments are often 'a a r' or something of that form
20:58:20 <shachaf> foo bar baz aar
20:58:22 <edwardk> heya andyjgill
20:58:33 <andyjgill> hi edwardk
20:58:45 <edwardk> had forgotten you irc'd =)
20:58:56 <edwardk> did lennart ping you with a bunch of stuff about data-reify?
20:59:03 <shachaf> I never knew andyjgill IRCed.
20:59:07 <andyjgill> Sometimes when I remember.
20:59:20 <andyjgill> Yes; I need to push the changes.
21:00:02 <edwardk> k. right now the automatic differentiation mode that i have that uses data-reify is a lot slower than the stupid version i have that just uses reflection to build a linear tape
21:00:17 <edwardk> i'll be curious to see if this makes it more competitive
21:00:43 <edwardk> (been on a benchmarking spree for the last few days)
21:01:27 <edwardk> i'll also be curious to see if your changes and mine together fix lennart's space problems
21:01:29 <andyjgill> I think the changes that were proposed was fixing a minor space leak, unfortunately.
21:01:37 <andyjgill> Sure.
21:02:14 <edwardk> ah, just that one?
21:02:18 <jfischoff> edwardk: can't wait try the new stuff, have a good night!
21:02:27 <edwardk> oh, the other issue he sent me doesn't appear to actually exist in practice, nevermind =)
21:02:28 <zeiris> Is there a way to point cabal-install at a mirror of some sort?
21:02:38 <edwardk> zeiris: yes
21:03:02 <edwardk> zeiris: see https://github.com/ekmett/lens/blob/master/config#L10
21:03:23 <edwardk> copy that line into your ~/.cabal/config and comment out your existing remote-repo
21:03:37 <edwardk> you'll have to cabal update after that
21:03:52 <andyjgill> I'll see if I can push the changes this week. Is there something specific I can help with, regarding your automatic differentiation and data-reifiy?
21:05:04 <edwardk> not sure really. the main concern is just not running out of memory to store the tape, and i wind up with a huge pile of stable names when i feed it a large problem. i don't think there really is a much better solution though
21:05:55 <edwardk> the naive version has the benefit that it doesn't have to sort the tape, so in theory if i use mostly one thread when computing values and need almost everything computed, it'll be faster
21:07:15 <edwardk> when you push the new version i'll benchmark and see which one deserves the moniker of reverse mode, and rename the other to something more exotic sounding
21:07:16 <andyjgill> Yes, stable names usage might be O(n^2). I'm not sure. We make extensive use of them for reify
21:08:27 <edwardk> yeah, i had code for doing basically the same thing when you shipped data-reify, but i switched to yours because it was way prettier =)
21:09:11 <andyjgill> Type functions make it all possible.
21:10:37 <edwardk> well, i suppose it could be done with an MPTC, but blech
21:11:37 <edwardk> i've also implemented a higher rank version of Data.Reify a few times, i should probably just refine it, package it up and send it to you for inclusion
21:12:07 <edwardk> its particularly handy when you need to reify typed DSLs, etc.
21:13:13 <andyjgill> I'd be interested in the higher-ranked version. Will you be at ICFP?
21:13:36 <edwardk> sadly not this year
21:15:47 <andyjgill> Oh well. Maybe you can visit Kansas at some point. We've got 9! people on the HERMIT project now.
21:15:58 <shachaf> > product [1..9]
21:15:59 <lambdabot>   362880
21:16:00 <shachaf> Wow.
21:17:04 <edwardk> shachaf: =)
21:17:38 <edwardk> andyjgill: nice. not feeling quite so lonely any more, eh?
21:18:14 * shachaf thought andyjgill was in PDX.
21:18:17 <andyjgill> Nope.  Kansas has always been good to me.
21:18:18 <edwardk> alternately, you should come up to boston some time
21:18:47 <edwardk> shachaf: he wandered off to play academic a few years back
21:18:49 <shachaf> Or to CA in October! I hear it's going to be a great place to go to in October.
21:20:11 <edwardk> andyjgill: i may need to wind up inlining the reify code into ad though, as i believe i currently make a number of assumptions about the order in which the identifiers are assigned
21:20:59 <andyjgill> no problem. This is why I use BSD. Gives other options.
21:21:21 <edwardk> likewise
21:22:18 <andyjgill> anyway, I'm off to get some Lava hacking done.
21:22:29 <edwardk> sounds like fun
21:22:36 <edwardk> if you get a chance, check out https://github.com/ekmett/lens
21:22:43 <edwardk> you may find it interesting
21:22:58 <andyjgill> Sure. Will do.
21:26:01 <___d> Is hackage down again? Anybody have a mirror? (Need ghc-paths.) TIA
21:26:12 <shachaf> luite has a mirror.
21:26:23 <shachaf> 18:05 <mauke> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
21:26:28 <___d> thanks!
21:48:44 <otters> is hackage seriously down again
21:49:04 <pharaun> yup
22:47:51 <ksf> anyone feel like challenging oleg?
22:48:28 <ksf> I have a type like 'type Foo = (Bar ::: Bool) :*: (Baz ::: (Int :+: Float :+: Integer))' and would *love* to turn that into keyword argument functions.
22:49:32 <ksf> that is, accept foo :: Bar -> Bool -> Baz -> Int, Baz -> Integer -> Bar -> Bool , Baz -> Float  -> Bar -> Bool etc.
22:51:56 <ksf> also, hackage is down.
22:52:55 <typoclass> ksf: oh wow, you're right :( i guess there's something to the theory that they turn it off on weekends
22:56:51 <johnw> strangely, hoogle times out if I try to access any Parsec-related page other than Prim
22:57:56 <johnw> which is killing my ability to learn how to use it!
23:04:55 <roconnor> preflex: seen edwardk
23:04:56 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
23:04:56 <preflex>  edwardk was last seen on #haskell-blah 10 minutes and 1 second ago, saying: i stole it from dons, and audreyt ;)
23:05:37 <edwardk> here
23:05:41 <roconnor> edwardk: I have a more elegent definition of duplicate
23:05:46 <edwardk> oh?
23:05:50 <roconnor> duplicate (Bazaar t) = getCompose (t (\i -> Compose (fmap impure) (impure i)))
23:05:52 <roconnor>   where
23:05:53 <roconnor>     impure :: i -> Bazzar i j j
23:05:55 <roconnor>     impure i = Bazaar (\f -> f i)
23:06:01 <roconnor> I haven't typechecked it yet
23:06:17 <edwardk> oh i already have the name for impure in there, its 'sell' i think
23:06:21 <roconnor> duplicate (Bazaar t) = getCompose (t (\i -> Compose (fmap impure (impure i))))
23:06:35 <roconnor> it might be more efficent
23:06:42 <ksf> do we have a type-level list library?
23:06:53 <ksf> (not that it would help in any way as hackage is down...)
23:06:54 <roconnor> I suspect things can be pushed the other way too.
23:07:30 <roconnor> duplicate (Bazaar t) = getCompose (t (Compose . (fmap impure) . impure))
23:08:05 <roconnor> duplicate (Bazaar t) = getCompose (t (Compose . (fmap sell) . sell))
23:09:40 <varadharajan> Hey guys, I've jsut started learning Haskell. I'm currently hit with a problem. I trying to write my own head function with simple pattern matching (list). I currently have 2 lines of code "myhead [] = "empty list" \n  myHead (x:_) = x" in my file. When i pass myHead an empty list ([]). It shows me patterns are non exhaustive. Is there something i'm missing out here?
23:10:39 <roconnor> varadharajan: you spelled myHead two different ways
23:10:45 <roconnor> making two different functions
23:11:18 <edwardk> roconnor: since it didn't turn out as fast as the other bazaar/kleene i just switched back
23:11:29 <edwardk> but it was really nice to have an obviously correct definition
23:11:40 <roconnor> edwardk: I suspect there is a third definition
23:12:21 <varadharajan> roconnor: My Bad. I was wondering what could be wrong for 30+ mins :( Thanks
23:12:29 <roconnor> The first one I gave had one occurance of impure
23:12:42 <roconnor> the second one I gave had two occurances
23:12:54 <roconnor> I suspect you can go the other way and have no occurances of impure
23:13:09 <roconnor> I'll sleep on it some more
23:13:28 <edwardk> that'd be ideal
23:14:17 <startling> @hoogle [(a, m b)] -> [m (a, b)]
23:14:17 <lambdabot> No results found
23:14:28 <startling> ^ anyone got a nice solution?
23:15:07 <paolino> :t fmap . (,)
23:15:08 <edwardk> roconnor: oh, btw- i got lens to be faster than uniplate
23:15:08 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
23:15:33 <pharaun> is there any other good large haskell system other than xmonad, yesod, few others that i can study for good type/module design?
23:15:41 <paolino> :t uncurry $  fmap . (,)
23:15:42 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => (a, f a1) -> f (a, a1)
23:15:55 <startling> paolino: wow nice
23:16:14 <paolino> if m is a Functor
23:17:07 <startling> it is
23:19:14 <startling> my other question: is there a nice way to list the files and the directories of a directory separately?
23:20:34 <startling> @hoogle FilePath -> IO ([FilePath], [FilePath])
23:20:35 <lambdabot> No results found
23:20:44 <startling> @hoogle FilePath -> IO [FilePath]
23:20:44 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
23:20:44 <lambdabot> Graphics.UI.GLUT.Initialization initialize :: String -> [String] -> IO [String]
23:20:44 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
23:21:57 <startling> man, no hackage sucks
23:22:19 <johnw> if I'm using Text.Parsec.ByteString.Lazy, shouldn't many1 return a ByteString, rather than a [Char]?
23:22:22 <paolino> startling, hackage is inaccessible here, the package directory should resolve with maybe a package on file stat
23:23:13 <johnw> is there an fmap that calls f on both sides of a tuple?
23:23:49 <edwardk> johnw: no. it parsed it all a character at a time
23:24:06 <edwardk> johnw: if you want slicing with reference to the source bytestring, you can use trifecta ;)
23:24:30 <edwardk> johnw: there is a traversal for it that can be used to fmap that way ;)
23:24:34 <ksf> meh type-eq doesn't compile with 7.6.1-rc1
23:24:35 <edwardk> johnw: that is in lens
23:25:05 <edwardk> over both (+1) (2,3)   ==> (3,4)
23:25:13 <edwardk> both is in Data.Pair.Lens
23:25:26 <johnw> cool
23:25:36 <johnw> too bad hackage appears to be down
23:25:47 <startling> johnw: bimap in bifunctors, too
23:25:54 <johnw> easy enough to define for my current needs: tuplate f (x,y) = (f x, f y)
23:26:03 <startling> (also by the illustrious edwardk)
23:26:19 <johnw> i'm intrigued by comonads
23:26:36 <typoclass> startling: haddock for the base stuff is here http://www.haskell.org/ghc/docs/latest/html/libraries/base/index.html
23:26:38 <edwardk> johnw: you can use luite's mirror
23:26:59 <typoclass> @hoogle doesDirectoryExist
23:26:59 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
23:27:08 <johnw> can I mirror all of hackage myself?
23:27:10 <edwardk> johnw: https://github.com/ekmett/lens/blob/master/config#L10 copy that line into your ~/.cabal/config
23:27:21 <edwardk> and comment out your existing remote-repo line
23:27:32 <edwardk> cabal update and then cabal install lens ;)
23:27:42 <startling> typoclass: thanks!
23:27:43 <typoclass> startling: you'd probably use Data.List.partition or something like it, that function ^, and getDirectoryContents
23:28:05 <typoclass> > partition odd [1..8]
23:28:06 <lambdabot>   ([1,3,5,7],[2,4,6,8])
23:28:08 <startling> typoclass: how do I use partition with a x -> IO Bool ?
23:28:35 <startling> I can't think of a clean way
23:28:42 <paolino> write your partitionM
23:29:17 <startling> paolino: good call
23:29:26 <typoclass> yeah, probably it's gonna be what paolino said. that's why i added "or something like it" :-)
23:29:32 <ksf> oh. there's other packages
23:30:04 <paolino> or mapM and zip and partition and unzip
23:30:48 <johnw> can I turn a String into a ByteString, for testing in ghci?
23:30:59 <edwardk> johnw: pack
23:30:59 <johnw> B.pack wants a Word8
23:31:10 <edwardk> er johnw : Data.ByteString.Char8.pack
23:31:15 <johnw> ahh, thank you
23:31:28 <edwardk> lens also gives you Data.ByteString.Lens.packedChars
23:31:36 <johnw> yay, it works!
23:31:41 <johnw> my first ever Parsec parser
23:31:46 <edwardk> gratz =)
23:31:49 <johnw> https://gist.github.com/3475035
23:31:57 <johnw> just parses "Foo: Value\n" fields
23:32:19 <edwardk> no need for the ()'s in the keyValue case
23:32:27 <edwardk> well one of them
23:32:38 <johnw> i need to lead you into my Emacs, edwardk
23:32:43 <johnw> M-x edwardk-optimize
23:32:48 <edwardk> no all of them can go
23:33:05 <johnw> even around (,)?
23:33:09 <edwardk> =P
23:33:14 <pharaun> johnw: familiar with hlint ?
23:33:16 <typoclass> i think the parens do make it clearer
23:33:24 <johnw> yes, hlint is always running in the background
23:33:26 <pharaun> i am prone to overusing parens
23:33:27 <johnw> (,) is required
23:33:39 <edwardk> i ruthlessly excise unnecessary ()'s from my code.
23:33:53 <pharaun> i'm trying that approach :)
23:34:02 <pharaun> some time it does make things nicer/cleaner, other time i'm not sure
23:34:07 <edwardk> i find it leads to me having a much stronger developed sense of relative precedence levels than i'd have otherwise
23:34:09 <johnw> ruthless excisions FTW
23:35:32 <typoclass> edwardk: yeah, but i'm not sure if i want to develop that sense. not sure what it's good for
23:35:47 <Clint> not getting confused
23:35:59 <edwardk> clint++ ;)
23:36:24 <edwardk> here the lack of > is indicating precisely what you want to know
23:36:44 <typoclass> Clint: you seem to be arguing for parens, not against them :)
23:36:50 <edwardk> (,) <$> fieldKey <* char ':' <* space  <*> fieldValue <* newline
23:36:59 <edwardk> the things that have a > before them are being returned
23:37:05 <edwardk> i can read that
23:37:17 <edwardk> with the ()'s i had to be constantly on guard that something hinky was happening
23:38:24 <edwardk> you can read any intermixture of <$ <$> <* and <*> that way.
23:38:35 <edwardk> if you start putting ()'s in there, all bets are off
23:38:48 <edwardk> note this doesn't work when you start throwing around *>'s
23:42:23 <typoclass> honestly, i think "(,) <$> (fieldKey   <* char ':' <* space) <*> (fieldValue <* newline)" makes it much more clear what the two arguments to the lifted (,) are. i mean, your approach "the things that have > in front are returned" is clever, but i bet that's documented nowhere
23:43:00 <edwardk> thats why those combinators were created with the fixities they have
23:43:02 <typoclass> and you have to learn stuff for every new operator that someone might come up with, along with exceptions ("doesn't work anymore when *> is involved" etc.)
23:43:25 <edwardk> *> is a hack that works for the common bra *> foo <* ket case
23:43:34 <edwardk> it doesn't fit the common pattern
23:43:57 <edwardk> *shrug* you're free to do what you like
23:46:26 <typoclass> sure, i was just opining. also in order to get an opinion formed in my head =)
23:48:46 <crats> [1,2,3\
23:49:49 <johnw> say I'm parsing a ByteString, and suddenly I know that the next 1000 bytes forms an opaque binary blob.  How do I just snarf this blob (lazily) and continue parsing after it?
23:50:13 <startling> johnw: whatcha parsin with?
23:50:15 <johnw> that is, I may not want to read it, but I want Parsec to fseek past it and resume parsing
23:50:22 <johnw> I'm using Parsec 3 and ByteString.Lazy
23:50:25 <startling> ah, Parsec
23:50:34 <startling> dunno.
23:51:38 <shachaf> johnw: Isn't Parsec is for text, not bytes?
23:51:53 <johnw> well, most of what I want to parse is text
23:51:59 <johnw> it just has blobs interspersed in it
23:52:42 <sheldonh> this realworldhaskell book has a nasty habit of presenting exercises long before equipping you to solve them :(
23:52:43 <johnw> it's like I want to say "x,y = next 1000 bytes of the current ByteString, remainder of ByteString; parse y"
23:53:02 <ivanm> johnw: so you know the length of the blob?
23:53:07 <johnw> yes, always
23:53:12 <johnw> so I can use take for that
23:53:18 <johnw> does the Parsec monad let me advance the input stream?
23:53:24 <ivanm> johnw: do you want the blob or just to skip it?
23:53:31 <johnw> i may want the blob
23:53:45 <johnw> i want to return it lazily, so it gets read from the file if the user needs it
23:54:03 <johnw> these files I'm parsing are upwards of 10G, and a lot of times a great deal of that file is unneeded
23:54:10 <johnw> but sometimes, it's all needed
23:54:19 <johnw> I thought Haskell would be perfect for this!
23:54:32 <ivanm> have you considered using attoparsec rather than parsec?
23:54:57 <johnw> I read some stuff indicating that attoparsec was older and not up to par with the new Parsec?
23:55:12 <johnw> aha, Parsec has getInput and setInput
23:55:15 <johnw> that might do me nicely
23:55:47 <ivanm> the closest I can find is in Text.Parsec.COmbinator.count, but it returns a list of values rather than the actual bytestring
23:56:17 <startling> johnw: cereal might do you well
23:56:59 <ivanm> startling: depends on the type of data if memory serves
23:57:01 <johnw> grr
23:57:12 <johnw> ByteString.Lazy.take takes a GHC.Int.Int64, instead of an Int or Integer
23:57:14 <johnw> I ask myself, why?
23:57:20 <ivanm> johnw: because it's lazy
23:57:30 <ivanm> see the length of a lazy bytestring
23:57:35 <ivanm> on 64bit systems, Int = Int64
23:57:41 <johnw> ah
23:57:48 <johnw> I build this GHC in 64-bit
23:57:50 <johnw> built
23:57:58 <paolino> what is so hard to keep up with hackage service? Deliberate attacks from imperative hackers ?
23:57:59 <johnw> how do I convert Int -> Int64?
23:58:09 <ivanm> fromIntegral
23:58:19 <ivanm> paolino: galois's server is down IIRC
23:58:22 <johnw> ok, thanks!
23:58:23 <ivanm> and they currently host hackage
23:58:47 <paolino> mh, it seems to happen often
23:59:16 <startling> paolino: turns out haskell doesn't work for real-world applications
23:59:17 <startling> whoops
