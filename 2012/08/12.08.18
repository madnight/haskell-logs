00:16:04 <charliesome> i wrote a gui for the unix 'file' utility - can someone give it a quick review for me? https://gist.github.com/3385011
00:16:15 <charliesome> let me know if i've done anything the wrong way
00:21:54 * hackagebot case-insensitive 0.4.0.3 - Case insensitive string comparison (BasVanDijk)
01:11:52 <isson> hello, i am not good to speak english, but i have a question about haskell.
01:11:57 <isson> sequence (map print [1,2,3,4,5])
01:12:42 <isson> i wonder that map print [1,2,3,4,5] evaluate to [print 1 , print 2 , print 3, print 4, print 5]
01:13:05 <shachaf> Yes.
01:13:25 <isson> no..restart, question. if map print [1,2,3,4,5] evaluate to [print 1 , print 2 , print 3, print 4, print 5] ,..
01:13:30 <shachaf> ghci> sequence [print 1, print 2, print 3, print 4, print 5] -- :-)
01:13:38 <shachaf> @src mapM
01:13:38 <lambdabot> mapM f as = sequence (map f as)
01:16:31 <isson> "sequence (map print [1,2])" always execute "print 1" once , "print 2" once..?
01:17:25 <isson> is there a specification about map function do not evalute (execute) "print 1" for internal implementation ?
01:18:50 <shachaf> No function can execute print.
01:18:55 <shachaf> Evaluate is not the same as execute.
01:19:04 <shachaf> What language are you more fluent in?
01:19:11 <isson> c++
01:19:47 <LambdaDusk> is there any possible way to put a debug output into a pure/non-monadic function?
01:21:04 <isson> i think taht "print 1" evaluate to generate code that execute "print" function.
01:21:53 <companion_cube> not exactly, it returns a value (like every function), but this value describes how to perform an action
01:21:59 <companion_cube> an namely, here, this action is to print 1
01:23:04 <isson> hmm.. thanks ~ a lot.
01:23:35 <isson> i need to learning english than haskell :-)
01:24:54 <shachaf> isson: I meant spoken language, not programming language.
01:25:16 <isson> korean :-)
01:31:56 * hackagebot cmdargs-browser 0.1.2 - Helper to enter cmdargs command lines using a web browser (NeilMitchell)
01:34:58 <JoeyA> What's a good name for a newtype wrapper that clarifies the role of an existing type?
01:35:01 <JoeyA> Example: http://hackage.haskell.org/packages/archive/postgresql-libpq/latest/doc/html/Database-PostgreSQL-LibPQ.html#t:Row
01:37:35 <Ippo> hello everyone
01:37:49 <JoeyA> hi
01:38:21 <Ippo> am I interrupting someone? or can I ask a very noobish question?
01:38:36 <c_wraith> you can always ask beginner questions
01:38:43 <c_wraith> usually, someone will even answer
01:38:51 <Ippo> thanks :)
01:38:56 <Ippo> so
01:39:09 <Ippo> I wrote a function that accesses a list of lists
01:39:13 <Ippo> to retrieve an element
01:39:18 <Ippo> which is just
01:39:27 <Ippo> (list !! row) !! column
01:39:48 <Ippo> however, in ghci calling this directly
01:39:49 <Ippo> I mean
01:39:52 <Ippo> with the double !!
01:39:55 <Ippo> works like a charm
01:40:08 <Ippo> my function, instead, which is just a wrapper, doesn't
01:40:19 <Ippo> because ghci complaints he cannot infer Int from the literal
01:40:41 <hiptobecubic> Ippo, example code on hpaste please.
01:40:47 <Ippo> ehm, sure
01:40:55 <Ippo> one second to ffigure out how it works
01:41:13 <hiptobecubic> Ippo, but if i had to guess, it sounds like you need to throw some `fromIntegral` in there somewhere
01:41:52 <Ippo> adding fromIntegral
01:41:58 * hackagebot hoogle 4.2.13 - Haskell API Search (NeilMitchell)
01:41:58 <Ippo> gives an exception
01:41:58 * hackagebot HTF 0.8.2.1 - The Haskell Test Framework (StefanWehr)
01:42:06 <hiptobecubic> paste it
01:42:09 <Ippo> No instance for (Num (b0 -> Int))
01:42:10 <Ippo> here
01:42:30 <dmwit> Man, StackOverflow is like the quality version of outsourcing to India.
01:42:38 <xraycat> lol
01:42:55 <hiptobecubic> dmwit, :D   quora is also very nice
01:43:31 <hpaste> Ippo pasted “Matrix @@” at http://hpaste.org/73346
01:43:49 <dmwit> Ippo: (mat @@ row) col = ...
01:43:50 <Ippo> ok I posted to hpaste
01:44:11 <dmwit> Ippo: likewise you'll need to use (list @@ 1) 1 when you call it
01:44:20 <dmwit> You could optionally write mat @@ (row, col) instead.
01:44:30 <Ippo> oh... it works
01:44:41 <Ippo> thank you...
01:44:43 <Ippo> but why?
01:45:01 <dmwit> Because function application binds tighter than any infix operator.
01:45:11 <dmwit> So it parses as mat @@ (row col) and list @@ (1 1), respectively.
01:45:37 <Ippo> ... you know that moment when people tell you the very obvious solution to a problem that bugged you for days?
01:45:46 <Ippo> well, I'm having it right now
01:45:47 <Ippo> :D
01:45:50 <dmwit> =D
01:45:57 <Ippo> dude I'm an idiot XD
01:46:08 <Ippo> thank you very much, really
01:46:37 <dmwit> hiptobecubic: Thank goodness quora has a bugmenot account!
01:47:33 <Ippo> :)
01:48:50 <dmwit> Quora seems to have significantly less traffic.
01:49:09 <hiptobecubic> dmwit, it's a different kind of service
01:49:24 <hiptobecubic> SO shuts down a lot of questions as 'out of scope'
01:49:43 <hiptobecubic> even if everyone is interested in them and industry leaders are writing long and detailed responses
01:58:34 <Ippo> since no one is talking, do you mind me asking again?
01:58:56 <dmwit> Don't ask to ask, just ask.
01:59:04 <Ippo> this time it's more a theoretical question, I don't have this problem (yet)
01:59:08 <dmwit> If the question isn't appropriate, we'll tell you (and maybe even point you at a better forum).
01:59:17 <Ippo> how can I access a specific device in haskell?
01:59:31 <Ippo> let's say I need to write data from a gps, for example
02:00:32 <Ippo> *read data
02:00:34 <Ippo> not write
02:01:57 * hackagebot hlint 1.8.31 - Source code suggestions (NeilMitchell)
02:02:11 <dmwit> It depends on what interface the device offers. Many devices offer a network interface; then you use a networking library. Some offer themselves up as external media; then you use the usual file opening/closing library. Some have C code for interfacing; then you use the FFI.
02:02:58 <Ippo> ok, so it really depends on the interface the device has
02:03:32 <Ippo> it should be easier on linux because they are mounted to a file anyway
02:03:41 <Ippo> right?
02:03:51 <dmwit> If it's a file, then it should be pretty easy, yeah.
02:04:21 <Ippo> ok
02:04:41 <Ippo> to be honest I'm learning haskell for a specific goal
02:04:50 <Ippo> have you heard about fishPi?
02:04:59 <Ippo> I want to be their competition :D
02:05:14 <Ippo> but there's no challenge in doing everything in matlab
02:05:58 <dmwit> > Just {}
02:05:59 <lambdabot>   Just *Exception: <interactive>:3:0-6: Missing field in record construction
02:06:03 <dmwit> neat
02:06:33 <Ippo> thank you for your help
02:06:34 <Ippo> bye
02:07:24 <JoeyA> Is there a shorter way to make an error value in Haskell?  (I may have asked this before)
02:07:28 <JoeyA> > (,){}
02:07:30 <lambdabot>   (*Exception: <interactive>:3:0-4: Missing field in record construction
02:07:33 <JoeyA> :-)
02:08:19 <dmwit> Hm, there's no standard data-type with a one-letter constructor name, is there? =P
02:08:24 <dmwit> data T=T
02:08:25 <dmwit> T{}
02:08:35 <JoeyA> > [1]{}
02:08:37 <lambdabot>   <no location info>: Empty record update
02:08:38 <dmwit> Oh, that's not an error.
02:08:41 <JoeyA> What would the record be named?
02:08:43 <dmwit> > []{}
02:08:44 <lambdabot>   []
02:08:51 <dmwit> data T=T Int
02:08:52 <dmwit> T{}
02:09:06 <dmwit> JoeyA: You don't need a name, as I demonstrated with Just{} above. =)
02:09:28 <JoeyA> But what if you wanted to overwrite the x in (x:xs), and you had to use record syntax?
02:10:24 <dmwit> You can't.
02:16:41 <cesip> nice, just got my letter of acceptance into cs/musicology
02:22:19 <maybefbi> :t ((<<=) id)
02:22:20 <lambdabot> Not in scope: `<<='
02:22:54 <maybefbi> :t ((=<<) id)
02:22:56 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
02:23:26 <typoclass> :t join
02:23:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:23:37 <maybefbi> anyone know why ((=<<) id) :: join
02:24:12 <maybefbi> (=<<) :: (m a -> m (m b)) -> m (m a) -> m (m b)
02:24:15 <maybefbi> and
02:24:24 <maybefbi> id :: a -> a
02:24:55 <maybefbi> so how come the return type of ((=<<) id)  is m b
02:25:19 <typoclass> :t (=<<)
02:25:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
02:25:52 <maybefbi> typoclass, but in this is case a is m a
02:26:18 <maybefbi> m (m a) is the second argument
02:26:37 <maybefbi> i.e. the place of a is taken by m a
02:27:20 <maybefbi> so (=<<) id would strip down one level and add another level of m
02:27:23 <maybefbi> and return it
02:27:42 <maybefbi> so shouldn (=<<) id return m (m a)
02:31:32 <LambdaDusk> what to write into .cabal file to have a profile build of my executables?
02:31:45 <maybefbi>  profile build ?
02:32:18 <maybefbi> you mean profile built?
02:32:38 <typoclass> LambdaDusk: have you tried "cabal install -p"?
02:34:52 <LambdaDusk> typoclass: "Most RTS options are disabled. Link with -rtsopts to enable them."
02:37:40 <typoclass> LambdaDusk: have you checked this guide? http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program#Case_study:_Processing_XML_using_HaXML
02:38:14 * typoclass gtg
02:38:30 <dcoutts_> LambdaDusk: cabal configure --enable-executable-profiling --ghc-options=-rtsopts
02:39:25 <LambdaDusk> dcoutts_: Thanks, that worked
02:39:51 * dcoutts_ notes that with later ghc version the -rtsopts is often not needed
02:39:58 * dcoutts_ fixed it
03:08:39 <randomclown> is there a better way to write "sortBy (\(x,y),(a,b) -> if (compare x y) == EQ then (compare a b) else (compare x y)
03:09:09 <randomclown> so compare two tuples by compare the first element, then the second element
03:09:16 <Botje> compare x y `mappend` compare a b
03:09:18 <Botje> for starters
03:09:39 <Automorphism> randomclown: Tuples of two Ord types are Ord as well, IIRC.
03:09:41 <Botje> @src mappend Ordering
03:09:41 <lambdabot> Source not found. You untyped fool!
03:10:10 <randomclown> oh lol
03:10:42 <Automorphism> instance (Ord a, Ord b) => Ord (a, b) -- Defined in 'GHC.Classes'
03:10:48 <Botje> Automorphism: well, randomclown was comparing the members of each tuple against each other
03:10:59 <Automorphism> Oh.
03:11:02 <Automorphism> My bad.
03:11:04 <Botje> if it was x `compare` a that'd be something else
03:11:14 <Botje> Automorphism: might be a typo on randomclown's part :)
03:11:45 <randomclown> yeah I typed it wrong
03:12:08 <randomclown> I didn't realise tuples were comparable as well
03:12:16 <Botje> well, now you know both approaches :]
03:12:28 <randomclown> Indeed
03:16:50 <randomclown> @pl map (
03:16:51 <lambdabot> (line 1, column 6):
03:16:51 <lambdabot> unexpected end of input
03:16:51 <lambdabot> expecting lambda abstraction, expression or ")"
03:19:02 <randomclown> @pl map (\x -> elemIndex x key) "asdfasdf"
03:19:02 <lambdabot> map (flip elemIndex key) "asdfasdf"
03:21:48 <Automorphism> @pl f g x y = g y x
03:21:48 <lambdabot> f = flip
03:31:03 <merijn> Try this? map (`elemIndex` key) "asdfasdf"
03:31:23 <merijn> > map (`elemIndex` 'd') "asdfasdf"
03:31:24 <lambdabot>   Couldn't match expected type `[a]'
03:31:24 <lambdabot>         against inferred type `GHC.Types...
03:31:42 <merijn> oh, type error, by the looks of it
03:31:59 <merijn> > map (`elemIndex` 'd') ["asdfasdf"]
03:32:00 <lambdabot>   Couldn't match expected type `[a]'
03:32:01 <lambdabot>         against inferred type `GHC.Types...
03:36:50 <maybefbi> @hoogle (Monad m) => m a -> a
03:36:51 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
03:36:51 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
03:36:51 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
03:38:35 <merijn> maybefbi: There's no such function, it's not possible to write
03:38:42 <maybefbi> yeah
03:38:55 <merijn> maybefbi: For some specific monad there *might* be, but that depends on said specific monad
03:39:40 <maybefbi> that sucks im trying to write ap in terms of other stuff like liftM
03:39:56 <merijn> :t ap
03:39:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:40:07 <maybefbi> :t liftM
03:40:08 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
03:40:31 <Botje> return f `ap` ... = f `liftM` ...
03:41:33 <merijn> :t liftM . (>>=)
03:41:35 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a b. (Monad m, Monad m1) => m1 a -> m (a -> m1 b) -> m (m1 b)
03:41:44 <merijn> hmm, not quite
03:41:52 <maybefbi> yeah
03:42:12 <DT``> :t \mf mx -> do f <- mf; x <- mx; return (f x)
03:42:13 <lambdabot> forall (m :: * -> *) b t. (Monad m) => m (t -> b) -> m t -> m b
03:42:37 <DT``> desugaring is left as an exercise for the reader.
03:42:48 <maybefbi> hehe wow
03:42:54 <merijn> @undo \mf mx -> do f <- mf; x <- mx; return (f x)
03:42:54 <lambdabot> \ mf mx -> mf >>= \ f -> mx >>= \ x -> return (f x)
03:43:01 <maybefbi> haha
03:43:14 <maybefbi> dint know that was possible
03:43:18 <maybefbi> with the bot
03:43:20 <DT``> @pl \ mf mx -> mf >>= \ f -> mx >>= \ x -> return (f x)
03:43:20 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
03:43:25 <DT``> me neither.
03:43:35 <merijn> lambdabot has many awesome tricks :p
03:43:40 <DT``> lambdabot, why are you so awesome?
03:43:43 <maybefbi> wtf with @pl ?
03:43:58 <merijn> maybefbi: pointless, i.e. it tries to eliminate variable names
03:44:12 <maybefbi> wow
03:44:24 <merijn> There's also
03:44:24 <maybefbi> will i ever learn enough about haskell?
03:44:39 <DT``> maybefbi, sure, why not?
03:44:42 <merijn> @djinn m (a -> b) -> m a -> m b
03:44:43 <lambdabot> -- f cannot be realized.
03:44:46 <merijn> aww
03:45:04 <Botje> maybefbi: you've learned enough haskell when you struggle with for loops in other languages ;)
03:45:05 <DT``> @djib Monad m => m (a -> b) -> (m a -> m b)
03:45:06 <lambdabot> -- f cannot be realized.
03:45:13 <LambdaDusk> "(cols, _) = (tsWidth `div` tw, tsHeight `div` th)" why did I write this rubbish?
03:45:13 <DT``> @djinn Monad m => m (a -> b) -> (m a -> m b)
03:45:14 <lambdabot> -- f cannot be realized.
03:45:26 <maybefbi> Botje, i like while loop using State monad
03:45:44 <merijn> maybefbi: Anyhoo, @djinn tries to generate code for a given type signature, but it's not very smart
03:46:01 <maybefbi> merijn, if bots could think
03:46:07 <maybefbi> we wouldnt be here would we?
03:46:12 <merijn> @quote skynet
03:46:13 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
03:46:15 <DT``> @djinn (a -> b -> c) -> (b -> c) -> a -> c
03:46:15 <lambdabot> -- f cannot be realized.
03:46:23 <DT``> oops.
03:46:29 <DT``> @djinn (a -> b -> c) -> (b -> a) -> b -> c
03:46:29 <lambdabot> f a b c = a (b c) c
03:47:17 <maybefbi> remember that quote from star wars? "if droids could think..."
03:47:26 <maybefbi> obi said it i think
03:49:29 <obiwahn> http://www.darpa.mil/Our_Work/TTO/Programs/DARPA_Robotics_Challenge.aspx
03:50:01 <Saizan> djinn is sound and complete for first order propositional intuitionistic logic
03:57:01 <daniel_-> anyone using sublime text2 with the SublimeHaskell plugin for cabal integration here?
04:09:06 <plat0> @djinn a
04:09:07 <lambdabot> -- f cannot be realized.
04:09:26 <DT``> @djinn (a -> a) -> a
04:09:26 <lambdabot> -- f cannot be realized.
04:17:50 <zhulikas> @djinn a -> a
04:17:50 <lambdabot> f a = a
04:18:06 <zhulikas> @pl f a = aa
04:18:07 <lambdabot> f = const aa
04:18:12 <zhulikas> woops
04:18:27 <donri> @djinn a -> b
04:18:27 <lambdabot> -- f cannot be realized.
04:24:28 <mm_freak> is there something like IsSet that doesn't rely so much on Typeable?
04:26:31 <mm_freak> i remember there was at least one alternative to IxSet
04:27:06 <mm_freak> but i forgot its name
04:28:44 <mm_freak> something like Data.Map with HOF operations instead of using an Ord constraint would also suffice
04:29:41 <mm_freak> lookup :: (k -> k -> Ordering) -> k -> Map k a -> Maybe a
04:31:01 <mm_freak> i think i can emulate that…  data Key = Key Int Double | IntQuery Int | DoubleQuery Double
04:31:10 <mm_freak> but it feels ugly
04:31:25 <donri> mm_freak: HiggsSet
04:31:31 <donri> and the unreleased kdmap
04:31:53 <mm_freak> thanks
04:32:57 <statusfailed> Weird, djinn fails to build with "gcc: error: unrecognized command line option ‘-Wl’" after linking
04:33:03 <statusfailed> Any ideas how to fix it?
04:33:32 <statusfailed> I'm guessing I have a too old or too new gcc?
04:35:52 <mm_freak> indeed, HiggsSet seems to work
04:35:55 <romildo> I am looking for a substring replacement based on Perl like regular expressions that would let me use part of the original string in the resulting string. Something like
04:35:55 <romildo>     reReplace "name is (.*)\\." "hy \1" "my name is john."
04:35:55 <romildo> which would result in "hy john." Any help?
04:36:56 <Botje> romildo: there are regexp packages for haskell
04:37:01 <Botje> Text.Regex, for example
04:39:37 <mm_freak> HiggsSet fails to install =/
04:40:14 <Jafet> There is perl for haskell too
05:35:00 <t7> @hoogle [a] -> [a] -> [a]
05:35:00 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
05:35:01 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
05:35:01 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
05:35:14 <t7> is there a list starts with
05:35:19 <t7> @hoogle [a] -> [a] -> Bool
05:35:20 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
05:35:21 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
05:35:21 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
05:35:23 <t7> aha
05:36:09 <t7> > isPrefixOf "abc" "abcdefg"
05:36:11 <lambdabot>   True
05:41:55 <t7> can a cabal project have multiple executables?
05:42:16 <ion> I assume so.
05:42:24 <ion> That would be a strange limitation.
05:51:50 <t7> ok my vimscript backend is ready :D
05:51:55 <t7> now i just need to learn vimscript
05:52:13 <ion> *shiver*
05:52:41 <t7> im writing a latex names -> utf8 character script
05:52:49 <byorgey> @tell dolio I have a blog post on the type algebra stuff from Hac Phi half written up.  I plan to finish it up soon (perhaps this afternoon).
05:52:50 <lambdabot> Consider it noted.
05:53:32 <mikeplus64> @hoogle Generic
05:53:33 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
05:53:33 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
05:53:33 <lambdabot> Data.List genericLength :: Num i => [b] -> i
05:55:03 <mikeplus64> (what i'm trying to find is where the Generic typeclass found in GHC.Generics is actually defined and what functions it has -- http://hackage.haskell.org/packages/archive/ghc-prim/0.2.0.0/doc/html/src/GHC-Generics.html doesn't reveal anything)
05:57:12 <mikeplus64> > (to . from) ()
05:57:14 <lambdabot>   Not in scope: `to'Not in scope: `from'
05:59:14 <McManiaC> hey, I'm having troubles with the custom buildtype of cabal, I get weird "defined in multiple files" errors from autogenerated files: http://npaste.de/ibuY/
05:59:24 <McManiaC> the Setup.hs: http://npaste.de/Hv/
06:00:35 <McManiaC> any idea what the reason might be?
06:01:17 <McManiaC> the cabal files: http://npaste.de/cDCA/
06:01:49 <zhulikas> @hoogle to
06:01:50 <lambdabot> Prelude toEnum :: Enum a => Int -> a
06:01:50 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
06:01:50 <lambdabot> Prelude toRational :: Real a => a -> Rational
06:01:55 <McManiaC> cable install -v3 delivers http://npaste.de/Q5QV/
06:05:10 <McManiaC> oh wait, I got it
06:09:09 <otters> :t fromEnum
06:09:10 <lambdabot> forall a. (Enum a) => a -> Int
06:16:14 <otters> :t (===)
06:16:16 <lambdabot> Not in scope: `==='
06:16:34 <otters> > let (======) = (==) in 3 ====== 3
06:16:35 <lambdabot>   True
06:16:41 <otters> it's just like PHP
06:24:24 <Guest73324> otters: not quite
06:24:58 <tdammers> first, you'd have to hide (==)
06:25:02 <tdammers> and then redefine it
06:25:16 <tdammers> and then implement (===) that would do what (==) normally does
06:25:25 <Expez> I have a small program which explodes. It terminates with Prelude.read: no parse. Is there a way to compile with a debug flag or something so I can get a line number indicating where the error occured?
06:25:40 <otters> yeah
06:25:47 <otters> and then (==) would be something like
06:26:00 <latro`a> expez: I think so, but for this single case you'd be better off using reads
06:26:53 <Expez> latro`a: What do you mean? What is 'reads'?
06:27:02 <latro`a> reads is another function provided by Read
06:27:14 <latro`a> which doesn't crash the program when it fails to parse
06:27:19 <Expez> ah right, thanks
06:27:42 <Expez> I just envision this happening again and it would be so helpful to have line numbers :)
06:27:43 <tdammers> Show a,b => (==) a b = Prelude.(==) (show a) (show b)
06:27:47 <latro`a> eh, should say "doesn't throw an exception when it fails to parse" but close enough
06:27:50 <tdammers> ugh
06:28:12 <tdammers> also, not even close to what PHP does
06:28:12 <latro`a> without a fair bit of effort, pure code exception and crash are basically the same thing
06:29:00 <Jafet> > 1 === (0 === 0.0)
06:29:02 <lambdabot>   True
06:29:18 <otters> :t (===)
06:29:19 <lambdabot> forall a a1. (Show a1, Show a) => a -> a1 -> Bool
06:29:40 <tdammers> > show True
06:29:42 <lambdabot>   "True"
06:29:46 <tdammers> wow.
06:30:02 <tdammers> > (0 === 0.0)
06:30:04 <lambdabot>   True
06:30:36 <tdammers> but for PHP compliance, you'd also need 0 === "foobar"
06:30:41 <tdammers> > 0 === "foobar"
06:30:44 <lambdabot>   False
06:30:48 <tdammers> *beep* fail
06:32:08 <Jafet> @hackage acme-php
06:32:08 <lambdabot> http://hackage.haskell.org/package/acme-php
06:32:42 <tdammers> yeah, I've seen that one
06:33:12 <latro`a> wtf, sort :: [()] -> [()]
06:33:14 <latro`a> I don't
06:33:14 <latro`a> what
06:33:37 <otters> must be a monomorphism restriction thing
06:33:47 <otters> probably uses show and read
06:33:49 <otters> lol
06:34:16 <otters> x + y = show (read x + read y)
06:34:24 <Jafet> Well, php is a jewish abomination anyways.
06:34:51 <tdammers> eh.
06:34:59 <tdammers> I give you abomination
06:35:22 <tdammers> but I guess the fact that jewish people contributed is not the reason
06:35:29 <latro`a> what the
06:35:37 <latro`a> notElem negates the...what
06:35:42 <latro`a> in this module
06:35:47 <ion> pi = "3.14"
06:35:49 <ion> haha
06:35:49 * latro`a gives up
06:36:06 <tdammers> ion: wasn't PI defined as exactly 3 somewhere in the Bible?
06:36:07 <otters> highly accurate
06:36:45 <tdammers> anyway, accurately modelling the behavior of PHP's lax comparisons is pretty damn hard
06:36:50 <t7> tdammers: yes
06:36:51 <tdammers> because it's so fucked up
06:37:04 <Jafet> Only in american bibles
06:38:15 <tdammers> $f = 0; switch ($f) { case false: echo "No, no, no."; break; case 0: echo "Zero zilch nada"; break; default: echo "Dunno lol"; }
06:38:26 <tdammers> blhe.
06:38:33 <tdammers> s/he/eh/
06:39:56 <ion> tdammers: ITYM “approximately 3”
06:44:50 <parcs`> tdammers: what does that print? "dunno lol"?
06:46:37 <tdammers> parcs`: no. Guess again.
06:46:54 <tdammers> hint: switch() does lax comparisons.
06:48:09 <ion> tdammers: Googling reveals it says some round object (how well it’s manufactured to be circular isn’t specified) has a diameter of 10 cubits (the measurement error and rounding isn’t specified) and a circumference of 30 cubits (ditto for measurement error and rounding).
06:49:05 <ion> Cubit seems to be defined as “usually from 17 to 21 inches”.
06:51:20 <mathriek> tdammers: http://i.imgur.com/kuWuk.png
06:51:27 <mathriek> so I heard you like well orderings
06:51:40 <ion> :-D
06:52:03 <mathriek> and yes, there are at least three cycles in there
06:52:19 <sentientwaffle> with QuickCheck, in and Arbitrary generator, how can I change an IO X into a Gen (IO x)?
06:52:32 <sentientwaffle> *in an
06:56:23 <sykora> sentientwaffle: you want to generate random IO actions that return X?
07:01:23 <fmap> random IO actions generator would be funny
07:02:08 <sentientwaffle> sykora: ya
07:02:13 <ion> fmap: An idea for an acme module.
07:02:29 <mathriek> not that hard if you limit yourself
07:02:30 <sentientwaffle> i mean, "arbitrary" is random anyway, but with the Gen monad
07:03:15 <mathriek> e.g. foo x = acquire_randomness >>= \n -> return (print n >> x)
07:03:45 <sentientwaffle> ah, 1 sec
07:04:29 <Yiq> So how is haskell platform just 99MB, oisnt ghc huge?
07:06:21 <sentientwaffle> couldn't match expected type Gen a0 with actual type IO X
07:07:04 * hackagebot lens 2.4 - Lenses, Folds and Traversals (EdwardKmett)
07:08:08 <latro`a> yiq--that's just an installer
07:08:19 <latro`a> not sure why the installer is as big as it is, actually
07:10:47 <fmap> edwardk: thanks :)
07:11:14 <edwardk> was one of that mountain of patches for you? =)
07:11:15 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:11:33 <edwardk> oh filepath
07:11:33 <Yiq> latroa: so its gonna pull a lot from the webs?
07:11:52 <Yiq> i cant download 700MB with my connction. 99MB takes to long as it tis
07:12:08 <edwardk> partially because they are a little fast and lose with the lens laws
07:12:16 <edwardk> but i liked your </>~ combinators ,etc
07:13:16 <singpoly1a> Can anyone tell me why GHC gives me an ambiguous type error on this: http://pastie.org/4544248 ?
07:14:24 <mathriek> presumably because it doesn't know which Show instance you want
07:14:39 <edwardk> the main issue is that round tripping through taking and putting the directory back in can slighly change the file named
07:15:23 <edwardk> the main thing i need to work on in lens is getting magnify to work with monad monad transformers
07:15:30 <edwardk> er with more
07:16:29 <singpoly1a> mathriek: oh, because `undefined` is a concrete value, so it needs a concrete type?  I guess that makes sense
07:17:26 <mathriek> well, you have a (Show a) constraint on action, so it needs to make sure that whatever type you intended for 'undefined' is actually an instance of Show
07:18:12 <singpoly1a> right
07:30:53 <statusfailed> aw man. you can use a comma separated list in LANGUAGE declarations :|
07:31:05 <mathriek> why so serious?
07:31:37 <statusfailed> I've been writing out {-# LANGUAGE ... #-} for each one
07:31:38 <statusfailed> sour
07:32:29 <mathriek> I actually like the one-pragma-per-line variant
07:34:30 <statusfailed> I guess it's easier to edit
07:34:37 <hpaste> fantasticsid pasted “SumFileByte” at http://hpaste.org/73351
07:34:39 <hpaste> fantasticsid pasted “SumFileByte” at http://hpaste.org/73352
07:35:06 <mathriek> hlint++
07:35:50 <kuribas> I am looking at https://github.com/ekmett/comonad/blob/master/Control/Comonad.hs, I don't see how cfix would work, without looping...
07:36:38 <k0ral> hello
07:36:59 <k0ral> I'm reading here and there that mtl might be deprecated in favor of transformers
07:37:08 <k0ral> is it true ?
07:38:38 <Saizan> recent mtl versions are built on top of transformers
07:39:48 <fantasticsid> Hi, I wrote this ByteString version of SimpleSum from <<RWH>> chapter 8. (Sum all integers in a plain text file) When I compile it as a binary, it uses up stack space when fed 1 million integers. Any hints what's causing so much stack usage?  http://hpaste.org/73352 http://hpaste.org/73352
07:39:48 <k0ral> so I can keep writing programs using mtl without worrying, right ?
07:40:07 <Saizan> yeah
07:41:13 <k0ral> what about monadlib ? is anyone using it ?
07:41:28 <mathriek> fantasticsid: at a guess, the nested thunks in Just
07:42:05 <Saizan> yeah, it's the Just
07:44:17 <fantasticsid> mathriek: do you mean the list of Maybe Sum Integer I get from map?
07:44:40 <mathriek> no, those are all shallow
07:44:46 <mathriek> I mean the result of foldl'
07:44:48 <singpoly1a> I have a set of functions in one file.  I'm using a code generator to produce a second set of functions to be used in the first set.  The second set need the first set in scope.  GHC for some reason can't handle import loops, it seems.  Is there a good solution?
07:45:07 <mathriek> singpoly1a: boot files
07:45:08 <Yiq> How much is the haskll platform installer get from the nets? ghc at 700MB? or just the src and compile it locally
07:45:40 <hpaste> Saizan annotated “SumFileByte” with “SumFileByte (annotation)” at http://hpaste.org/73352#a73353
07:45:41 <mathriek> singpoly1a: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
07:45:56 <Saizan> fantasticsid: try my annotation ^^^
07:47:00 <k0ral> no one uses monadlib here ?!
07:48:33 <fantasticsid> Saizan: cool! It works!
07:50:03 <singpoly1a> mathriek: wow, so, basically a pragma + C-style header file.
07:50:20 <mathriek> a bit more controlled, but yes
07:50:57 <Saizan> foldl' only forces the outermost constructor at each step, it's your duty to propagate that deeper if needed
07:51:18 <singpoly1a> that's really gross :(
07:51:19 <k0ral> quicksilver: isn't monad-control supposed to solve the problem I had ?
07:55:47 <k0ral> how would you stack several times the same Monad using mtl ?
07:56:16 <k0ral> say it's Reader, how can I do something like (MonadReader X m, MonadReader Y m) => m ()
07:56:39 <k0ral> there will be conflicts for "ask"
07:57:43 <mathriek> AFAICT there will be conflicts in the type signature
07:57:52 <mathriek> m uniquely determines r
07:59:42 <k0ral> mathriek: indeed, does it mean I must gather all my read data into a single datatype ?
07:59:56 <k0ral> I would find such constraint annoying
08:00:19 <mm_freak> k0ral: why would you want to stack multiple readers anyway?
08:00:38 <fantasticsid> Saizan: So if I don't use forceMaybe, the result of foldl' would be a large thunk containg 1 million Maybe (Sum Num) connected by mappend, is that correct?
08:01:15 <k0ral> mm_freak: because I want to separate the "readable data" into several data types for better coherency
08:01:48 <Saizan> fantasticsid: no, it'll be a Just wrapped around 1 million Sum Int connected by mappend
08:02:32 <mm_freak> k0ral: that's not going to be pretty…  i still recommend a record
08:03:35 <k0ral> mm_freak: f needs to read X, g needs to read Y, h needs to read both X and Y, why would I grant f (respectively g) the right to read Y (resp. X) ?
08:04:09 <mm_freak> k0ral: f :: X -> Z; g :: Y -> Z; h :: X -> Y -> Z
08:04:12 <mm_freak> what's wrong with that?
08:04:27 <k0ral> mm_freak: you mean not using Reader at all ?
08:04:30 <mm_freak> yeah
08:04:43 <mm_freak> that is still Reader, just a different representation =)
08:05:07 <mm_freak> newtype Reader e a = Reader (e -> a)
08:05:29 <mm_freak> type Reader e = (->) e
08:06:00 <k0ral> O_o
08:06:07 <mm_freak> and that one is also a monad, where you use 'id' as 'get' ;)
08:06:18 <mm_freak> > (do x <- id; return (x + y)) 5
08:06:19 <lambdabot>   5 + y
08:06:23 <mm_freak> > (do x <- id; return (x + x)) 5
08:06:24 <lambdabot>   10
08:06:38 <mm_freak> and you use 'f' instead of 'asks f'
08:07:25 <k0ral> isn't that how Reader is implemented ?
08:08:05 <mm_freak> in fact i don't see a valid use case for Reader given that…  only ReaderT seems sensible
08:10:21 <k0ral> mm_freak: anyway, replace Reader with State or Writer
08:10:51 <k0ral> mm_freak: does mtl enforce using each of them only once in the stack ?
08:12:10 <mm_freak> no, but you can't use MonadState or MonadReader then
08:12:34 <mm_freak> well, you can, but it will require explicit lifting
08:13:31 <mm_freak> given ReaderT e1 (ReaderT e2 m) you will need 'get' for e1 and 'lift get' for e2
08:13:56 <k0ral> I'm not using explicit ReaderT, just MonadReader
08:14:09 <mm_freak> i still recommend explicit arguments
08:14:17 <k0ral> as I understand, there is no such thing as upper or lower monad
08:14:24 <k0ral> when using MonadXXX
08:15:10 <k0ral> mm_freak: but it's really annoying using explicit XxxxT monad transformers since you have to lift in and out *every where*
08:15:15 <k0ral> makes the code boilerplate
08:15:32 <mm_freak> the problem is the dfundep
08:15:41 <k0ral> what ?
08:15:45 <mm_freak> you can't have multiple MonadReader instances for the same monad
08:16:51 <k0ral> that's the point of my original question
08:16:51 <mm_freak> and really, insisting on using a monad in place of arguments will make your code longer and uglier
08:17:15 <k0ral> are you saying the whole Reader monad is useless ?!
08:17:25 <mm_freak> not always
08:17:44 <k0ral> and, again, forget about Reader, since it bothers you, and consider other monads like State, Error...
08:18:02 <mm_freak> the only use case i see is ReaderT, where you have some application state and only functions deep in your calling hierarchy use the state
08:18:59 <mm_freak> i'm not overly fond of State either…  Error makes more sense
08:19:05 <k0ral> mm_freak: Reader makes it possible not to bother writing the additional argument for each function
08:19:44 <mm_freak> the additional argument is easier to write and makes your code more understandable in most cases
08:20:02 <k0ral> mm_freak: soooo, here we go, consider MonadError, you obviously can't have m instance of several MonadError classes
08:20:11 <mm_freak> correct
08:20:35 <k0ral> mm_freak: that's quite subjective... I'm not going to argue, that's not what my question is about
08:21:05 <mm_freak> in mtl MonadError is quite unfortunate anyway
08:21:09 <mm_freak> normally error monads are well composable
08:21:10 <k0ral> so, we agree you currently *have* to gather all your error types into a single data type
08:21:41 <k0ral> which is sometimes unfortunate
08:22:03 <k0ral> since you want to be able to tell "f can throw error X while g can throw only Y and h both"
08:22:40 <mm_freak> well, you can solve that easily by using a combinator
08:23:09 <mm_freak> Either e a -> Either (Either e e') a
08:23:14 <k0ral> let me browse on that keyword "combinator", see what I can find on my own
08:23:30 <fantasticsid> Saizan: So when foldl' reduces two Maybe (Sum Num) with the seq function, ie. "mappend (Just (Sum 1)) (Just (Sum 2))" , the result would be "Just (mappend (Sum 1) (Sum2))", rather than a total complete evaluation like "Just (Sum 3)" ?
08:23:38 <mm_freak> :t either (Left . Left) Right
08:23:39 <lambdabot> forall b a b1. Either a b -> Either (Either a b1) b
08:24:09 <k0ral> mm_freak: so what with that double Either ?
08:27:30 <ezyang> Hm. Suppose I have f :: IO () -> IO (), and I would like to prevent users from doing f (f ...) (that is, no wrapping twice!) Is there a way of implementing this dynamic check?
08:27:53 <mm_freak> k0ral: interpret the outer Either as Error
08:27:56 <zhulikas> O.o
08:28:14 <zhulikas> why don't you do a -> IO a ?
08:28:15 <mm_freak> ezyang: dynamic?
08:28:24 <mm_freak> at runtime?
08:28:35 <ezyang> Yep.
08:28:50 <mm_freak> doesn't look possible
08:28:53 <zhulikas> yea
08:29:03 <ezyang> I know how I'd do it with types but it's a little too heavyweight for this particular problem.
08:29:06 <mm_freak> except with a very ugly solution:  a global mutable
08:29:19 <ezyang> but that doesn't work; I want to allow forkIO (f ...) >> f ...
08:29:25 <mm_freak> it seems quite easy with types
08:29:25 * zhulikas pukes a little in his mouth after freak's suggestion
08:29:38 <ezyang> Phantom, right?
08:30:07 <mm_freak> f :: (forall w. WrapIO w a) -> WrapIO X a
08:30:11 <mm_freak> something like that
08:30:28 <mm_freak> now f (f c) is a type error
08:30:48 <ezyang> Right. Point is, that's too heavyweight.
08:31:00 <mm_freak> what's heavyweight about that?
08:31:02 <ezyang> This is just a lil' script :-)
08:31:14 <ezyang> The newtype overhead of WrapIO.
08:31:18 <mm_freak> i promise that a run-time solution will be more heavyweight =)
08:31:32 <mm_freak> newtype has no overhead except in the case of RULES
08:31:48 <parcs`> there's syntactic overhead
08:31:51 <ezyang> Well, certainly GHC does this for, say, atomically
08:31:53 <parcs`> you need to use liftIO everywhere
08:31:54 <Saizan> fantasticsid: yeah
08:32:21 <ezyang> So, implemented properly, it's not all that expensive.
08:32:26 <ezyang> Another example: exception masking.
08:32:38 <mm_freak> ezyang: it's not a run-time check for STM
08:32:50 <mm_freak> it's simply the fact that there is no IO a -> STM a
08:33:12 <ezyang> mm_freak: Well, there is an unsafe one :-)
08:33:21 <ezyang> and it *does* do the "am I already in atomically" check
08:34:01 <mm_freak> ok, well, just don't have such a function =)
08:37:06 * hackagebot route-generator 0.3 - Utility to generate routes for use with yesod-routes (StephenWeber)
08:46:39 <cods> I wrote something horrible.. Any suggestion to improve that? -> http://hpaste.org/73356
08:46:53 <cods> I'm learning Haskell.. and that's what I got after many difficulties
08:47:31 <mm_freak> cods: data Color = Color { red :: Word8, green :: Word8, blue :: Word8 }
08:47:32 <mm_freak> try this
08:47:54 <mm_freak> then the red, green and blue functions will be defined for you
08:49:13 <monochrom> hrm, hPutChar. this may do something you didn't think of
08:50:00 <cods> ok, changed to use Color.
08:50:12 <kuribas> cods: You may as well write "(_, (width, height)) <- getBounds arr"
08:50:21 <kuribas> It's less verbose.
08:50:55 <cods> ah yes, I knew I was missing a shortcut here
08:51:15 <monochrom> such as putChar '\xE1' giving you 0xC3 0xA1 because of UTF-8
08:51:17 <cods> monochrom: you mean it can interpret it as unicode or something like that? Looking again at the doc.
08:51:51 <eyebloom> If you get a message such as this http://hpaste.org/73357, essentially couldn't match a type in a return type. Which of the two types is the expected type?
08:53:00 <monochrom> use openBinaryFile for now
08:53:55 <cods> much better, indeed
08:55:00 <cods> can the double-nested forM_ be simplified somehow?
08:55:13 <zhulikas> what happens when an IO action fails?
08:56:08 <monochrom> exception
08:57:29 <zhulikas> so in theory I should always expect an exception with an IO action
09:00:10 <zhulikas> @type System.IO.Unsafe.unsafePerformIO $ return (5::Int)
09:00:11 <lambdabot> Int
09:00:13 <zhulikas> can this ever fail?
09:00:36 <monochrom> return doesn't fail
09:02:14 <hpaste> lamefun pasted “How to express this better?” at http://hpaste.org/73359
09:02:21 <lamefun> ^
09:05:04 <donri> lamefun: do you actually want something like this http://hackage.haskell.org/packages/archive/happstack-server/7.0.4/doc/html/src/Happstack-Server-FileServe-BuildingBlocks.html#combineSafe
09:06:25 <lamefun> no
09:06:38 <lamefun> are there better ways to express what is written in my paste?
09:07:33 <donri> maybe. but what are you actually trying to do? exactly what you are doing? or something more abstract (like "check if filepath is safe")?
09:08:59 <lamefun> no
09:09:05 <lamefun> trying to do exactly what's in comment
09:09:19 <daniel_-> why cant i catch the god damn exception for "*** Exception: Corrupted binary data for `DataType`"
09:11:02 <kuribas> lamefun: I'd use functions from Data.Char
09:11:09 <Clint> lamefun: you can use elem instead of containedIn. checking for whether you're at the start or the end of the string for each character seems silly
09:11:31 <parcs`> cd
09:11:54 <hpaste> daniel_- pasted “going mad” at http://hpaste.org/73360
09:12:33 <kuribas> lamefun: And I'd use `any`.
09:12:42 <daniel_-> why does that still throw exceptions?
09:12:43 <parcs`> daniel_-: use evaluate instead of return there
09:12:51 <parcs`> anyway i suggest you use cereal instead of binary
09:13:32 <daniel_-> THANK YOU!
09:13:37 <lamefun> is there a function for slicing start and end, like (x:xs:y)?
09:13:40 <daniel_-> parcs`,
09:13:44 <lamefun> *pattern
09:14:28 <shachaf> No, because lists don't work that way.
09:17:39 <non_> [x*2 | x <- [1..10], x*2 >= 12]  dont get it
09:19:01 <roconnor> lamefun: You might want to use Data.Seq which allows for this sort of thing.
09:24:00 <Yiq> testpersta.appspot.com , anyone with a 1080 monitor that coulc check that site in fullscreen and see how it looks?
09:27:07 * hackagebot route-generator 0.3.1 - Utility to generate routes for use with yesod-routes (StephenWeber)
09:32:20 <Yiq> How much is the haskll platform installer get from the nets? ghc at 700MB? or just the src and compile it locally
09:32:54 <otters> I believe the installer has a binary and it just moves everything to the right place
09:34:06 <Yiq> but isnt ghc megahuge?
09:35:12 <geekosaur> 2.8M	/Library/Haskell/ghc-7.4.1/bin
09:35:40 <geekosaur> granted that's os  instead of linux... on theother hand that very probably means it's larger than it would be on linux
09:35:47 <Yiq> win7?
09:35:58 <otters> well
09:36:04 <otters> mine is 141MB
09:36:11 <Yiq> > 99
09:36:13 <lambdabot>   99
09:36:23 <Yiq> "> 99"
09:36:37 <Yiq> the whole win7 haskell platform installer is 99
09:38:59 <LambdaDusk> anyone here with some yampa knowledge? I don't get how "integral" exactly works...
09:45:22 <Philippa_> LambdaDusk: what don't you get about it, OOI?
09:45:36 <hpaste> saep annotated “How to express this better?” with “How to express this better? (annotation)” at http://hpaste.org/73359#a73363
09:46:15 <Philippa_> (not saying I know yampa well, mind)
09:46:25 <LambdaDusk> Philippa_: For example it seems to start at (0,0) but I wanna have a starting pos
09:52:06 <LambdaDusk> ok
09:52:29 <ezyang> hPutStr is thread safe, right?
09:53:45 <shachaf> ezyang: What do you mean by thread safe?
09:55:34 <taylorgb> Usually it means that if you call the function on seperate OS threads then the output will not be interleaved, but serialised. I doubt this is the case though
09:55:48 <ezyang> what taylorgb said
09:56:03 <ezyang> I vaguely recall that Haskell handles use MVars under the hood
09:56:04 <shachaf> No, you don't have that guarantee.
09:56:33 <JoshTriplett> I'm using Data.ByteString as part of an FFI, and I'd like to make as few copies as possible.  unsafeUseAsCString avoids copying the internal buffer, but it also doesn't guarantee '\0'-termination.  useAsCString always copies the internal buffer.  Does a (semi-safe) function exist that guarantees '\0'-termination but doesn't copy the buffer if already terminated?
09:56:44 <hpaste> saep annotated “How to express this better?” with “How to express this better? (I forgot the consecutive dots.)” at http://hpaste.org/73359#a73364
09:56:50 <JoshTriplett> And if not, how crazy would it be to write one?
09:57:02 <shachaf> Try it: λ> mapM_ (spawn.hPutStrLn stdout.show) [1..20]
09:57:06 <shachaf> I get lots of interleaving.
09:57:35 <shachaf> JoshTriplett: A ByteString isn't in general going to have a \0
09:57:48 <ezyang> ok
09:57:57 <JoshTriplett> shachaf: Meaning, most of the time I'll end up making a copy just to snoc a '\0'?
09:58:41 <JoshTriplett> That seems unfortunate.
09:58:46 <shachaf> JoshTriplett: If you're starting with just a plain ByteString you got from somewhere, probably, yes.
09:58:59 <shachaf> JoshTriplett: Keep in mind that a ByteString can be a "slice" of another ByteString.
09:59:27 <JoshTriplett> shachaf: That much I knew; I figured that if I ended up having to make a copy when I encountered a slice, that would be OK, if I could avoid a copy when dealing with an unsliced string.
09:59:28 <shachaf> JoshTriplett: Also keep in mind that ByteStrings represent bytes, not text. Bytes are in general not \0-terminated.
09:59:45 <ezyang> Ah, I bet I'm thinking of stdout. Maybe.
09:59:55 <shachaf> 0-terminated strings are kind of evil.
09:59:56 <shachaf> stdout?
10:00:11 <JoshTriplett> shachaf: So, there's no efficient way to deal with APIs that don't take a pointer-and-length representation of strings?
10:00:58 <ezyang> wait, never mind, your test was on stdout
10:01:05 * ezyang is a little confused, then. 
10:01:33 <shachaf> JoshTriplett: Not with ByteString, at least, I don't think.
10:02:55 <JoshTriplett> shachaf: Sigh.  And here I'd hoped that I could avoid most of the copying.
10:03:39 <shachaf> JoshTriplett: Maybe there's something you can do, but ByteString is not the datatype for you. :-)
10:03:57 <JoshTriplett> shachaf: Well, copying or no copying, ByteString still seems like a better choice than String. :)
10:04:31 <JoshTriplett> shachaf: Does a ByteString commonly have extra space available after the last byte, or does it usually have precisely the required number of bytes allocated?
10:04:40 <JoshTriplett> shachaf: (As in, could I potentially add a '\0' without copying?)
10:05:04 <shachaf> You're talking about evil unsafe operations now.
10:05:28 <shachaf> I think ByteStrings are usually shrunk to exactly the size of allocation necessary to contain them.
10:05:38 <JoshTriplett> shachaf: I was always talking about evil unsafe operations. :)
10:05:52 <shachaf> Anyway what you're talking about is completely unsafe if you have a slice, and how do you know if you have a slice or not?
10:06:33 <JoshTriplett> shachaf: I hadn't looked closely at the internal representation yet.  I'd assumed that a ByteString knew it was a slice of some other ByteString; otherwise it couldn't maintain a proper reference count.
10:07:17 <parcs`> bytestrings are foreignptrs under the hood
10:07:26 <JoshTriplett> But now that I look at the representation, a slice at the beginning of a ByteString will look indistinguishable to a standalone ByteString.
10:07:39 <shachaf> JoshTriplett: A ByteString is represented as (ForeignPtr Word8,Int,Int)
10:07:43 <parcs`> so the bytestring would have to store an offset in its reperesentation too
10:07:45 <shachaf> For offset/length.
10:07:46 <JoshTriplett> Yeah, looking at .Internal now.
10:08:05 <shachaf> It's allocated with ~malloc.
10:08:33 <ddarius> Just bind to the DMA chip.
10:08:37 <JoshTriplett> shachaf: It hadn't occurred to me that ByteString would just share the ForeignPtr between all slices, rather than changing the pointer and dropping the offset.
10:08:52 <shachaf> JoshTriplett: Well, you have to be able to free it. :-)
10:09:28 <parcs`> you can't really change the pointer instide a foreignptr
10:09:50 <shachaf> JoshTriplett: Anyway, even if the length is "too big", you won't know whether that's because the remainder of the ByteString is unused (in which case *maybe* you can be evil and write a 0 byte?), or you have a slice.
10:10:04 <JoshTriplett> shachaf: Yeah, I realize that now.
10:10:38 <JoshTriplett> shachaf: Other representations exist that might have allowed that (such as the classic "allocate more than you need when growing" representation with separate "length" and "size").
10:11:22 <shachaf> When "growing", you copy the whole thing anyway, since it's immutable. :-)
10:11:37 <shachaf> (Well, except when you're initially generating it. Maybe that's what you mean.)
10:12:11 <parcs`> i don't think we have a library that provides growing vectors like that
10:12:12 <JoshTriplett> shachaf: Right.  And in this case, if slack space existed, it would make sense to poke a '\0' at the start of the slack space and then use the buffer directly. :)
10:12:32 <JoshTriplett> So, this brings me back to the original question: given an FFI interface that passes around a pile of strings and buffers, should I just declare everything as ByteString and live with making copies for all the functions that want '\0'-terminated strings, or does some better alternative exist?
10:12:47 <JoshTriplett> At least the functions that take a pointer and length won't have to copy...
10:12:48 <Yiq> ok now cloud haskell is installing, why is it called distrbiuted process, cloud haskell is much cooler :)
10:12:56 <shachaf> JoshTriplett: Ff I remember correctly ByteString has code to allocate a smaller buffer and copy when it overallocates.
10:13:10 <ddarius> Yiq: distributed-process is an implementation of Cloud Haskell.
10:13:23 <shachaf> But I might be wrong.
10:13:30 <parcs`> joachifm: i would use String
10:13:30 <JoshTriplett> shachaf: IIRC, ByteString actually has bits to call realloc.
10:13:53 <JoshTriplett> parcs`: Was that meant for me?
10:13:56 <JoshTriplett> parcs`: And if so, why?
10:14:01 <shachaf> JoshTriplett: Oh, yes.
10:14:10 <shachaf> parcs`: Huh? By String do you at least mean [Word8]?
10:14:20 <parcs`> JoshTriplett: because it's convenient
10:14:52 <parcs`> oh wait, is it binary data you're passing aruond?
10:15:02 <JoshTriplett> parcs`: Sometimes, sometimes not.
10:15:07 <JoshTriplett> parcs`: This is a binding to libgit2.
10:15:40 <JoshTriplett> parcs`: Some of these strings definitively represent arbitrary content.  Some of them represent filenames or ref names or similar.
10:15:58 <JoshTriplett> But I don't really want to have an API where some things use ByteString and some use String.
10:16:07 <parcs`> ah, then i'm indecisive
10:16:13 <ddarius> You wouldn't use String anyway, you'd use Text.
10:16:40 <parcs`> bytestring should really add an implicit \0 to the foreignptr
10:16:48 <ddarius> No it should't.
10:16:53 <shachaf> ==ddarius
10:16:56 <parcs`> why not?
10:17:09 * hackagebot splice 0.6.1 - Cross-platform Socket to Socket Data Splicing (CetinSert)
10:17:13 <ddarius> ByteString, despite it's name, is meant for binary data and buffers.
10:17:15 <parcs`> it'll only be visible when you're using the ForeignPtr directly
10:17:20 <JoshTriplett> ddarius: Massive "ugh" on Text; it uses UTF-16.
10:17:27 <shachaf> Text would definitely not allow you to pass data to C APIs without copying. :-)
10:17:28 <ddarius> JoshTriplett: What do you care what it uses?
10:17:29 <JoshTriplett> ddarius: And since I don't run Windows, that's a useless representation.
10:17:44 <shachaf> JoshTriplett: They tried UTF-8 and it ended up being slower.
10:17:46 <nand`> Text is more memory efficient than String, right?
10:17:48 <JoshTriplett> ddarius: Because I'd like to avoid copies.
10:17:58 <shachaf> JoshTriplett: Or if you're using text-icu.
10:18:10 <shachaf> But at any rate Text isn't going to be \0-terminated either.
10:18:11 <JoshTriplett> shachaf: Depends on the benchmark and how much Unicode it passes around.
10:18:13 <shachaf> (Or \0\0-terminated.)
10:18:19 <JoshTriplett> *nod*
10:18:37 <shachaf> When you support slices \0-termination doesn't make much sense.
10:18:39 <JoshTriplett> nand`: Almost anything is more memory-efficient than String. ;)
10:18:58 <ddarius> JoshTriplett: If you aren't manipulating the data in any way, then you should definitely just use ByteString or perhaps even better an opaque pointer.
10:19:05 <parcs`> i don't understand why an implicit \0-termination is a bad idea, if the \0 is only visible when using the ForeignPtr directly
10:19:54 <JoshTriplett> ddarius: Much of the time that'll be true.  In some cases, callers will need to pass around filenames and manipulate them.
10:20:00 <ddarius> parcs`: Because it would force copying.  I can make a ByteString directly from a pointer.  Also, \0 termination is completely pointless and useless most of the time.
10:20:12 <JoshTriplett> ddarius: And a few other bits of stringy data.  But most of the time the data will be opaque.
10:20:45 <shachaf> ByteStrings can have 0 bytes in them anyway.
10:20:48 <ddarius> Okay, then have it be opaque and have conversion functions to ByteString/Text that potentially copy.
10:21:07 <JoshTriplett> ddarius: What do you mean by "opaque" here?
10:21:10 <shachaf> And slices aren't going to be 0-terminated. A lot of the point of ByteStrings is that slices are just as good as their hosts.
10:21:38 <ddarius> JoshTriplett: An abstract (new)type around a Ptr or ForeignPtr.
10:22:27 <JoshTriplett> ddarius: That seems rather painful.  While I don't expect most callers to manipulate the data directly, I *do* expect most of the data to come from APIs other than this one. :)
10:22:44 <JoshTriplett> ddarius: (For instance, reading data off of a socket and feeding it into this library, or vice versa.)
10:23:04 <shachaf> If you use a ForeignPtr and immutable data, you can write a function that converts your data type to ByteString without copying. :-)
10:23:15 <JoshTriplett> shachaf: Heh.
10:23:37 <JoshTriplett> shachaf: Amusing idea.  Kinda makes me want a separate library for "managed C strings".
10:24:53 <shachaf> JoshTriplett: Also, if you create a ByteString and explicitly add a 0 byte at the end, it'll have the 0 byte, of course.
10:25:00 <shachaf> It's just not something the library does for you.
10:25:01 <ddarius> JoshTriplett: In the worst case, all that would require is an extra call to a conversion function which will not copy unless it needs to.
10:25:26 <JoshTriplett> ddarius: Still doesn't make for a very pleasant API to use when just about every call involves a conversion function.
10:25:45 <ddarius> JoshTriplett: You can easily fold the conversion functions in and use a naming convention.
10:26:21 <JoshTriplett> ddarius: Quite a few of these calls have multiple stringy arguments, and you might want different conversions for each.
10:26:30 <JoshTriplett> ddarius: (For instance, a filename and a buffer.)
10:26:35 <ddarius> JoshTriplett: I would use different types for each.
10:26:52 <ddarius> And you could use a type class to have the same name for the conversion.
10:27:39 <JoshTriplett> I actually started out with this API having a "Stringable" typeclass, but it just seemed awkward, and required a lot of explicit ::String or ::ByteString annotations in the callers to disambiguate (such as when taking the result of one call and passing to another).
10:27:59 <ddarius> As a totally different option, you could make a type of \0-terminated strings that's just a newtype wrapper around ByteString with a function isNulTerminated :: ByteString -> Maybe CByteString
10:28:23 <ddarius> JoshTriplett: That's doing the wrong thing.
10:28:53 <ddarius> ByteStrings are not "strings".
10:29:46 <EarlGray^> hello
10:30:08 <ddarius> Also, there's no reason you can't leave unadulterated buffers as they are since you should be able to use a copyless implementation for them always (as long as the buffer doesn't get mutated later.)
10:30:33 <ddarius> It's only the \0-terminated string arguments that are problematic.
10:30:40 <EarlGray^> I thought I knew how pattern matching works, but this example puzzled me:
10:30:44 <JoshTriplett> ddarius: Yeah, ByteString works perfectly for "buffer" arguments.
10:30:49 <JoshTriplett> ddarius: Anything that takes a length.
10:31:19 * shapr boings cheerfully
10:31:25 <shapr> Goood morning #haskell !
10:31:29 <EarlGray^> case reads str :: [(Integer, String)] of { [] -> Nothing; [(i, ""), _] -> Just i; _ -> Just (-1);
10:31:31 <shachaf> unsafeCreate l f = unsafeDupablePerformIO (create l f)
10:31:33 <shachaf> Isn't that exactly the thing you're supposed not to use unsafeDupablePerformIO for?
10:31:37 <ddarius> shapr: Doing classes or did you take the summer off?
10:31:42 <EarlGray^> it gives -1 almost always
10:31:57 <JoshTriplett> ddarius: unsafeUseAsCStringLen works nicely, as does packMallocCString; I just realized that the vast majority of the time I can't use unsafeUseAsCString.
10:31:59 <shapr> ddarius: I did classes and I have a Google Summer of Code project!
10:32:07 <shachaf> > case reads "blah" :: [(Integer, String)] of { [] -> Nothing; [(i, ""), _] -> Just i; _ -> Just (-1)
10:32:08 <shapr> ddarius: Perhaps I should have chose one or the other.
10:32:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:32:14 <shachaf> > case reads "blah" :: [(Integer, String)] of { [] -> Nothing; [(i, ""), _] -> Just i; _ -> Just (-1) }
10:32:15 <lambdabot>   Nothing
10:32:18 <shachaf> > case reads "28" :: [(Integer, String)] of { [] -> Nothing; [(i, ""), _] -> Just i; _ -> Just (-1) }
10:32:19 <lambdabot>   Just (-1)
10:32:36 <shachaf> > reads "28" :: [(Integer,String)]
10:32:37 <n00b6502> can't seem to get the 'State' monad acceisible... tried import State , import Monad.State, import Monad.Control.State, import Control.Monad.State etc;
10:32:38 <lambdabot>   [(28,"")]
10:32:38 <EarlGray^> why is it -1 ?
10:32:42 <shachaf> EarlGray^: There you go.
10:32:51 <n00b6502> i'd grabbed haskelll by sudo apt-get install haskell in linux
10:32:53 <n00b6502> ubuntu
10:32:58 <shachaf> EarlGray^: [(i,""),_] doesn't match [(28,"")]
10:33:08 <EarlGray^> oach
10:33:17 <shachaf> (Why are you using Just (-1)? :-( That's a terrible return value.)
10:33:25 <EarlGray^> it's just an example
10:33:34 <ddarius> More precisely, (i,""):_:[] doesn't match (28,""):[]
10:33:44 <EarlGray^> thanks, I get it
10:33:54 * ddarius highly suspects EarlGray^ wants (i,""):_
10:34:37 <shachaf> ddarius: So are you moving to the west coast?
10:34:47 <n00b6502> how do i get State into the namespace :(
10:34:51 <shapr> ddarius: If you want to make some suggestions/critiques, the GSoC code is at: https://github.com/shapr/ghclive
10:35:24 <shapr> ddarius: Did you write any fun code this summer?
10:35:29 <BMeph> EarlGray^: Most matches only find one match. Your "[(i,""),_]" construct only succeeds when there is more than one match.
10:35:49 <JoshTriplett> n00b6502: libghc-mtl-dev
10:35:57 <JoshTriplett> n00b6502: (or install it via cabal, your choice)
10:36:02 <geekosaur> isn't State per se obsolete and gone?
10:36:14 <JoshTriplett> geekosaur: Huh?
10:36:33 <ddarius> BMeph: Specifically if there is exactly 2 results.
10:36:34 <geekosaur> State was removed in favor of StateT Identity
10:36:34 <shachaf> geekosaur means type State s = StateT s Identity, presumably.
10:36:38 <geekosaur> that
10:36:42 <shapr> @index (<$>)
10:36:43 <lambdabot> bzzt
10:36:45 <shachaf> But the type still exists.
10:36:46 <ddarius> Except I think reads only ever returns [] or a singleton.
10:36:49 <shachaf> (Though the constructor doesn't.)
10:36:52 <n00b6502> thanks
10:37:06 <geekosaur> yeh, I was assuming it's the constructor
10:38:25 <ddarius> shapr: I haven't written much code yet, but I've been reading a ton about GPS signals, so I'll probably produce a decent amount of code for that soon.  Also probably some code for some (rather practical but still cool) physics simulations.  Also I did some Android development a while back in Java and Scala.
10:39:08 <shapr> ddarius: sounds nifty!
10:39:09 <shapr> ddarius: Do you have an NMEA parser in Haskell?
10:41:43 <Expez> When you've done 'cabal install foo' should foo show up on 'ghc-pkg list' or do I have to do something else as well?
10:43:04 <ddarius> shapr: No.  I don't see myself implementing that, though I'll probably implement decoders for various other signals.
10:43:10 <shachaf> Expez: If foo is a library, and the installation succeeded, then yes.
10:43:32 <n00b6502> import Control.Monad.State   ... i've tried to use 'State ...' but the compiler says i wanted 'StateT'
10:43:37 <n00b6502> http://www.haskell.org/haskellwiki/State_Monad#Complete_and_Concrete_Example_2
10:43:50 <Expez> shachaf: ty
10:43:55 <n00b6502> trying to do this example. Is it 'State' or 'StateT' i'm after
10:44:04 <ddarius> GPS is one of the more complex signals available.  I might do GLONASS first since it is much simpler to acquire in many ways.
10:44:23 <ddarius> (It's much less protected against narrow-band interference though.)
10:45:51 <LambdaDusk> can anyone please please please tell me why this is an eternal loop and how to resolve it: https://gist.github.com/3388692
10:47:20 * geekosaur thinks "pos <- arr clampPos -< (p', pos)" in a recursive do-binding is highly suspicious
10:47:24 <ddarius> LambdaDusk: You feed pos into clampPos and it immediately returns it.  There is no delay.
10:47:50 <LambdaDusk> ddarius: How to add that delay...?
10:48:16 <Yiq> Whats the name of a value like Temp,Light,Rain. Ie no the unit but what are those?
10:48:23 <ddarius> LambdaDusk: What's the initial value for pos?
10:48:43 <LambdaDusk> ddarius: p0, the parameter of playerPos
10:49:18 <Yiq> like type but not really
10:49:30 <Yiq> a physical "?"
10:49:43 <LambdaDusk> ddarius: I just need some way to make sure pos always stays within the bounds
10:52:25 <ddarius> LambdaDusk: This is Yampa or something else?
10:52:39 <LambdaDusk> ddarius: Nope, Yampa 0.9.3
10:53:31 <n00b6502> should "import Control.Monad.State "  give me "State" ?
10:54:16 <ddarius> I think the function you want is initially.
10:55:26 <ddarius> I think pos <- arr clampPos . initially (p0, p0) -< (p', pos) may do what you want.
10:56:32 <ddarius> Though I don't think this is the best way to resolve the problem.
10:56:40 <fmap> n00b6502: it should give type synonym `State'
10:57:52 <n00b6502> ok
10:58:08 <n00b6502> dont know what it was doing before, must have used it in bad syntax, it seems to work now
10:58:23 <ddarius> LambdaDusk: I think really what you want is essentially to have pos be an looped back in earlier since integral should already have a delay.
11:00:28 <LambdaDusk> ddarius: Initially deleted the loop at the first instance, but it is still there in the second movement... I would like to ask generally how I can clamp this position safely.
11:00:30 <ddarius> So pos <- arr clampPos . ((^+^ p0) ^<< integral) &&& id -< pos may also do what you want.
11:01:02 <nand`> in STM, is ‘retry’ independent from re-execution after a failed transaction? Suppose I have a `orElse` b and a fails due to a failed transaction; not retry - will this restart a or will it move on to b?
11:01:32 <ddarius> nand`: You could test this and find out.
11:01:46 <nand`> ddarius: I'm not sure how I'd reliably generate a failed transaction
11:01:56 <nand`> except unsafeIOtoSTM or something to sleep one thread
11:02:17 <LambdaDusk> ddarius: Nope, doesnt =/
11:02:17 <mathriek> AFAIK retry *is* a failed transaction
11:02:43 <Okasu> how can i enable superoptimization with ghc?
11:02:43 <shachaf> Do the semantics of STM even mention anything about transactions?
11:02:44 <Okasu> is it even possible?
11:02:50 <nand`> shachaf: oh, you're completely right. yes, that answers it
11:02:54 <ddarius> Okasu: Define "superoptimization".
11:03:01 <mathriek> .oO( supercompilation? )
11:03:48 <Okasu> ugh, i mean supercompilation
11:04:59 <ddarius> LambdaDusk: Try changing id to initially p0 as well.
11:05:43 <LambdaDusk> ddarius: Then it works for one loop. I think the idea is fundamentally flawed here.
11:07:51 <ddarius> LambdaDusk: Well does it work without the clamp stuff?
11:08:36 <Okasu> meh, it seem ghc can't so that, but lucky me have found Neil Mitchell's supercompiler
11:09:16 <Hakkla> Hello. Has someone managed to install the latest wxHaskell on Windows?
11:10:25 <ddarius> LambdaDusk: Maybe it's iPre you want not initially.
11:12:08 <LambdaDusk> ddarius: iPre seems to do it, damned if I knew why
11:12:35 <n00b6502> State is really a StateProcessor ?
11:12:39 <ddarius> iPre seems to be what delay was and I forget what intially quite is.
11:12:48 <ddarius> I haven't really looked at Yampa in like six years.
11:13:35 <LambdaDusk> ddarius: Now it is still stuck in the corner... I think I need a break and re-think tomorrow
11:13:39 <Philippa_> n00b6502: when they're not named after the datatype underlying them, we tend to name monads after the language feature they provide
11:13:51 <Philippa_> so it's a "State language", if you like
11:14:23 <n00b6502> ok
11:52:56 <McManiaC> is there a way to tell why a handle got closed?
11:53:49 <McManiaC> withBinaryFile myFile ReadMode $ \h -> Data.ByteString.Lazy.hGetContents h
11:53:57 <McManiaC> results in "hGetBufSome: illegal operation (handle is closed)"
11:53:58 <c_wraith> withBinaryFile closes the handle
11:54:00 <c_wraith> done!
11:54:15 <c_wraith> You're combining withFile and lazy IO
11:54:19 <McManiaC> oooh
11:54:19 <c_wraith> that combination always fails
11:54:21 <McManiaC> i see
11:54:56 <mathriek> should've used readFile
11:57:20 <McManiaC> c_wraith: does a strict bytestring have the same issues?
11:57:45 <c_wraith> McManiaC: no, its equivalent function is non-lazy
12:02:03 <McManiaC> is there a way to stay lazy but make sure that the handle gets closed as soon all content is read?
12:02:18 <mathriek> yes
12:02:21 <McManiaC> kind of add a finalizer or something to the bytestring
12:03:32 <McManiaC> mathriek: how? :)
12:03:43 <mathriek> <mauke> should've used readFile
12:03:57 <mathriek> o helo
12:04:51 <c_wraith> I'm pretty sure hGetContents closes the file when its done..  readFile just lets you avoid naming the handle
12:05:14 <McManiaC> oh hGetContents closes itself
12:05:15 <McManiaC> yeah
12:12:12 <Yiq> anyone made a browser in haskell?
12:12:22 <Clint> Yiq: hbro
12:12:27 <Phlogistique> Yiq: you mean the engine?
12:13:27 <shurikas> anyone knows projects similar to gsoc?
12:14:19 <Philippa_> similar in what regard?
12:14:36 <Philippa_> Dreamwidth does a lot of mentoring for new coders, for example
12:14:50 <Philippa_> but you won't get paid :p
12:14:52 <kuribas> Do I have to declare instances in a module declaration?
12:14:57 <mauke> no
12:15:05 <mauke> instances leak everywhere
12:15:14 <kuribas> Is that good or bad?
12:15:19 <mauke> yes
12:15:26 * Clint nods.
12:16:07 <shurikas> Philippa_, yeah, I was hoping for a payment :D
12:16:30 <shurikas> writing code with mentoring + some money
12:24:00 <ddarius> shurikas: You could get a job.
12:24:08 <shurikas> nah
12:24:11 <shurikas> that's not a solution
12:26:54 <ddarius> > (1 :: Int) :+ 0
12:26:55 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
12:26:56 <lambdabot>    arising from a use o...
12:27:21 <ddarius> Okay, lambdabot just hasn't upgraded.
12:27:44 <mauke> I believe lambdabot is still on 6.something
12:29:06 <parcs`> > ?X
12:29:08 <lambdabot>   <no location info>: parse error on input `?'
12:29:14 <parcs`> > ?x
12:29:16 <lambdabot>   mueval-core: internal error: PAP object entered!
12:29:16 <lambdabot>      (GHC version 6.12.3 f...
12:30:02 <mauke> nice work
12:49:52 <roconnor> $ cabal install cabal-dev
12:49:59 <roconnor> unrecognized option `--disable-benchmarks'
12:50:00 <roconnor> cabal: Error: some packages failed to install:
12:50:06 <neothemachine> @pl \r z s -> h (r z s)
12:50:06 <lambdabot> ((h .) .)
12:50:09 <roconnor> why the error?
12:50:22 <ddarius> Your cabal is old?
12:50:38 <roconnor> cabal 0.1.4
12:50:40 <roconnor> er
12:50:41 <roconnor> cabal 0.14
12:50:57 <roconnor> rather
12:51:03 <roconnor> $ cabal --version
12:51:05 <roconnor> cabal-install version 0.14.0
12:51:06 <roconnor> using version 1.14.0 of the Cabal library
12:51:11 <roconnor> AFAIK it is the lastest
12:51:57 <neothemachine> is the @pl also somewhere else available as a tool? or a website? I don't want to spam this channel
12:52:00 <ddarius> I don't know then.
12:52:06 <otters> neothemachine: you could install lambdabot locally
12:52:08 <otters> and use that
12:52:15 <donri> @hackage pointfree
12:52:16 <lambdabot> http://hackage.haskell.org/package/pointfree
12:52:18 <otters> or that.
12:52:20 <ddarius> neothemachine: You can message the bot, but there is a package for a commandline version.
12:52:22 <neothemachine> ok thanks
12:53:24 <otters> I can't tell if pointfree just infinite loops or if this problem is really hard
12:54:29 <ddarius> @pl ap id id (ap id id)
12:54:33 <lambdabot> ap id id (ap id id)
12:54:33 <lambdabot> optimization suspended, use @pl-resume to continue.
12:55:29 <donri> i've had pointfree hang when @pl works
12:55:44 <Eduard_Munteanu> @pl-resume
12:55:51 <lambdabot> ap id id (ap id id)
12:55:51 <lambdabot> optimization suspended, use @pl-resume to continue.
12:56:00 <donri> pointfree also handles composition vs qualified less well
12:56:23 <parcs`> :t ap id id (ap id id)
12:56:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
12:56:25 <lambdabot>     Probable cause: `id' is applied to too few arguments
12:56:25 <lambdabot>     In the second argument of `ap', namely `id'
12:56:31 <ddarius> Sounds like someone should update pointfree.
12:56:33 <otters> donri: yeah, same
12:56:41 <otters> actually, about 80% of everything I plug into pointfree hangs indefinitely
12:56:47 <parcs`> :t id <*> id
12:56:49 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
12:56:49 <lambdabot>     Probable cause: `id' is applied to too few arguments
12:56:49 <lambdabot>     In the second argument of `(<*>)', namely `id'
12:57:15 <ddarius> parcs`: Haskell's type system is designed (among other things) to explicitly disallow such things.
12:57:41 <ion> unless you use {-# LANGUAGE PHPTypeSystem #-}
12:58:05 <neothemachine> lol
12:59:22 <DT``> :t pure id <*> pure id
12:59:24 <lambdabot> forall (f :: * -> *) a. (Applicative f) => f (a -> a)
12:59:53 <neothemachine> is point-free style used a lot in library code? I find it a bit harder to read as a beginner, but I guess it's worth it once you understand the concept
12:59:54 <ddarius> Hmm is there a vector builder?
13:00:49 <ddarius> (Actually, do I care?)
13:01:13 <ddarius> neothemachine: It's used but not to the extremity of @pl.
13:01:33 <otters> pure id <*> pure id is just pure id ಠ_ಠ
13:02:04 <otters> shouldn't pure f <*> g be the same as f <$> g
13:02:20 <ddarius> fmap id = id
13:04:28 <parcs`> @pl ap id id
13:04:29 <lambdabot> join id
13:04:45 <ddarius> @pl \x -> x x
13:04:46 <lambdabot> join id
13:05:12 <otters> :t \x -> x x
13:05:13 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
13:05:13 <lambdabot>     Probable cause: `x' is applied to too many arguments
13:05:13 <lambdabot>     In the expression: x x
13:05:15 <otters> lol
13:12:36 <ion> otters: It isn’t?
13:12:46 <ion> @type id <$> pure id
13:12:47 <lambdabot> forall a (f :: * -> *). (Applicative f) => f (a -> a)
13:25:09 <parcs`> :t fix (ap flip)
13:25:11 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
13:25:14 <ch33sus_> how do i write x^n
13:25:21 <ch33sus_> "in" haskell
13:25:26 <parcs`> @src (^)
13:25:27 <lambdabot> x ^ 0            =  1
13:25:27 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
13:25:27 <lambdabot>   where f _ 0 y = y
13:25:27 <lambdabot>         f x n y = g x n
13:25:27 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
13:25:29 <lambdabot>                       | otherwise = f x (n-1) (x*y)
13:25:31 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
13:26:00 <ch33sus_> thx :D
13:26:27 <ddarius> s/1/mempty/ s/\*/mappend/g
13:26:41 <hiptobecubic> is lambdabot immune to autokicks?
13:27:08 <ddarius> hiptobecubic: Why would lambdabot be immune to autokicks?
13:27:35 <hiptobecubic> To allow it to make large responses like the one we just witnessed?
13:27:47 <geekosaur> hm.  normally it self-throttles after 3 lines
13:27:51 <ddarius> lambdabot throttles its output
13:28:08 <geekosaur> and does the 'use @more' thing for even longer output
13:28:14 <hiptobecubic> @src (^)
13:28:14 <lambdabot> x ^ 0            =  1
13:28:15 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
13:28:15 <lambdabot>   where f _ 0 y = y
13:28:15 <lambdabot>         f x n y = g x n
13:28:15 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
13:28:16 <lambdabot>                       | otherwise = f x (n-1) (x*y)
13:28:18 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
13:28:31 <ddarius> geekosaur: I don't think more is general.  Generally, it just produces lines more slowly.
13:28:35 <hiptobecubic> I see..  I guess that was slow enough to avoid a kick
13:30:07 <ddarius> :t let x ^ 0 = mempty; x ^ n | n > 0 = f x (n-1) x where f _ 0 y = y; f x n y = g x n where g x n | even n = g (x`mappend`x) (n `quot` 2) | othrewise = f x (n-1) (x`mappend`y) in (^)
13:30:09 <lambdabot> Not in scope: `othrewise'
13:30:15 <ddarius> :t let x ^ 0 = mempty; x ^ n | n > 0 = f x (n-1) x where f _ 0 y = y; f x n y = g x n where g x n | even n = g (x`mappend`x) (n `quot` 2) | otherwise = f x (n-1) (x`mappend`y) in (^)
13:30:16 <lambdabot> forall a t. (Monoid a, Integral t) => a -> t -> a
13:33:44 <roconnor> dcoutts: What do I do about "unrecognized option `--disable-benchmarks'" when cabal install lifted-base-0.1.1.1 using cabal-install version 0.14 under GHC 7.0.4?
13:46:36 <luksow> I'm designing data model for use with acid-state for a web app, here I encountered rather philosophical question... when do you think it is worth to wrap field built from primitives like xxx :: Int or yyy :: [(Int, Float)] into some new types, like xxx :: InterestingTypeForXX or yyy :: YyyList? In OOP I use only common sense but maybe there are things that I should take into consideration with Haskell?
13:47:37 <ddarius> luksow: Generally if it would help avoid mistakes, or if you need/want to specify unique instances for those types.
13:47:54 <ddarius> Also, data abstraction, maybe in the future you want yyy :: IntMap Float
13:49:04 <luksow> ye, data abstraction.. [[(Int, Float)]] looks good for now (it represents possible ways of doing something) but in the future, who knows.. ;)
13:50:19 <luksow> but still there are many cases when I'm not sure, for example I have a description of some entity in my db, description :: Text looks fine and clear, but maybe I missed something?
13:50:27 <Philippa_> luksow: type synonyms are an "always" food
13:50:52 <luksow> wrapping everything in new type seems crazy ;)
13:50:54 <Philippa_> if nothing else, they make it a lot easier to start disentangling if you ever need to refactor to another (implementation) type
13:51:07 <luksow> Philippa_, yes but still a lot of headers to change
13:51:20 <Philippa_> sure. But you get the list the first time you try to recompile
13:51:53 <Philippa_> it's a useful bit of defensive programming that I usually end up kicking myself for forgetting sooner or later
13:52:24 * ddarius wonders how upset people would be if I use Word instead of Int for a count.
13:52:30 <roconnor> ugh, the order of parmeters to cabal install matters!
13:52:31 <roconnor> yeck
13:53:41 <Philippa_> ddarius: butbutbut how do you encode escaped values without negatives?!
13:54:46 <ddarius> This is just a parameter like if I wrote take :: Word -> [a] -> [a]
13:54:57 <Philippa_> *nod*
13:55:04 <luksow> Philippa_, for ex. type Id = Int seems to be awful becase of Int being constructorless...
13:55:24 <ddarius> luksow: ?
13:55:27 <Philippa_> luksow: why should it have a constructor as opposed to fromInteger?
13:55:34 <monochrom> type Int = Word
13:56:01 <hpaste> MagneticDuck pasted “weird error” at http://hpaste.org/73371
13:56:11 <MagneticDuck> I have a really weird error
13:56:19 <MagneticDuck> I never got something like this before
13:56:29 <MagneticDuck> it's not descriptive at all
13:56:41 <MagneticDuck> just.. "parse error: parsedToUserActionID"
13:56:47 <luksow> Philippa_, ok so maybe synonyms are good to go ;)
13:56:50 <MagneticDuck> that there is a function
13:56:53 <Philippa_> luksow: so long as you can keep track of where Id values are introduced in your code, why should it be fixed to be an algebraic type? Plenty of other implementation strategies :-)
13:56:55 <MagneticDuck> that compiles without errors
13:57:00 <MagneticDuck> any help?
13:57:40 <MagneticDuck> understanding the code probably isn't necessary
13:57:46 <MagneticDuck> there's some syntax problem
13:57:54 <Philippa_> MagneticDuck: it won't give you a source location?
13:58:15 <MagneticDuck> Philippa: yes, line 35
13:58:17 <Philippa_> oh, you've got a signature that doesn't have the body immediately underneath
13:58:24 <MagneticDuck> where?
13:58:25 <monochrom> do not deduce that the rest parses fine
13:58:38 <MagneticDuck> true
13:58:53 <MagneticDuck> this error is on the parsing level
13:58:55 <roconnor> maybe I'll try happstack instead of yesod; it seems to have fewer dependencies
13:58:55 <MagneticDuck> there could be type errors
13:59:00 <MagneticDuck> Philippa_: what signature?
13:59:13 <Philippa_> actually no. It's puking on the braces, because it's expecting record syntax
13:59:20 <MagneticDuck> oh
13:59:23 <MagneticDuck> yeah
13:59:27 <MagneticDuck> it IS record syntax
13:59:29 <MagneticDuck> forgot the names
13:59:31 <MagneticDuck> x)
13:59:33 <MagneticDuck> I was stumped
13:59:55 <MagneticDuck> I'm not good with record syntax
13:59:55 <Philippa_> you might want to file a bug report for the unhelpful error message though?
14:00:01 <MagneticDuck> it doesn't look right to me
14:00:06 <MagneticDuck> perhaps
14:00:10 <MagneticDuck> that's probably a common error
14:00:16 <MagneticDuck> among the ranks of newbies
14:00:45 <roconnor> how come http://www.haskell.org/haskellwiki/Web/Servers doesn't list Yesod
14:01:00 <roconnor> oh wait
14:01:09 <roconnor> there is a difference between a webserver and a web framework
14:01:12 <roconnor> ... apparently
14:02:20 <MagneticDuck> btw, what do you guys think of my silly little "IndentParse" system?
14:02:31 <MagneticDuck> https://github.com/MagneticDuck/IndentParse
14:02:40 <MagneticDuck> I'm using it to parse a personality file for my awesome irc bot
14:02:56 <MagneticDuck> it parses a file into a generic recursive data structure
14:03:08 <MagneticDuck> and you can take that data and use it to parse your own data
14:03:17 <MagneticDuck> :P
14:03:26 <MagneticDuck> it's the most horribly simple thing in the world
14:03:30 <MagneticDuck> but it works great
14:04:36 <MagneticDuck> https://github.com/MagneticDuck/DuckBot/blob/master/src/DuckBot/Sentence.hs has some examples of its use
14:04:55 <MagneticDuck> I wonder if I should put it on hackage
14:05:11 <MagneticDuck> parsecs can do everything it can
14:05:25 <MagneticDuck> but it's useful as a little tool
14:05:43 <adnam> did you try writing it in parsec? :)
14:05:47 <MagneticDuck> x)
14:05:55 <MagneticDuck> the thing's like 45 lines
14:06:39 <MagneticDuck> oh, and I was going to ask if anyone wanted to see how many things I have done horribly wrong in my "DuckBot.Sentence" sentence parser thingie
14:06:43 <MagneticDuck> https://github.com/MagneticDuck/DuckBot/blob/master/src/DuckBot/Sentence.hs
14:06:45 <MagneticDuck> I'm a newbie
14:06:48 <MagneticDuck> if you have the time, it would be awesome
14:06:53 <MagneticDuck> it's not too big
14:07:04 <MagneticDuck> (that repo has some examples of its use)
14:07:41 <ddarius> Use where and function pattern matching as opposed let and case.
14:08:21 <ddarius> Also, look at the Prelude.  You could definitely simplify/shorten a lot of the code with some Prelude functions.
14:08:24 <MagneticDuck> you're talking about Sentence.hs?
14:08:31 <MagneticDuck> name an example?
14:08:46 <hiptobecubic> this is a pretty rad formatting style
14:08:54 <MagneticDuck> hehe
14:08:59 <MagneticDuck> I developed it on my own
14:09:03 <MagneticDuck> rad as in, weird?
14:09:16 <MagneticDuck> and not mainstream?
14:09:21 <ddarius> E.g. phraseSequence = drop 1 $ parseSentenceWithID sentenceID str
14:09:30 <MagneticDuck> what would you do?
14:09:41 <MagneticDuck> phraseSequence = drop 1 . parseSentenceWithID sentenceID?
14:09:45 <MagneticDuck> erm
14:09:48 <MagneticDuck> with the str at the end
14:09:49 <hiptobecubic> tail?
14:09:55 <MagneticDuck> ..
14:10:00 <MagneticDuck> yeah.
14:10:02 <MagneticDuck> x)
14:10:14 <ddarius> tagVarTuple is just silly but it is tagVarTuple tag var = (fromMaybe "" tag, var), or even tagVarTuple = (,) . fromMaybe "" though that's a bit extreme.
14:10:16 <hiptobecubic> are you coming from ML? or do you just really like  let .. in ?
14:10:43 <MagneticDuck> I just like lets
14:10:46 <MagneticDuck> =)
14:10:59 <MagneticDuck> let statements seem better to me
14:11:09 <MagneticDuck> they are parsed more flexibly
14:11:13 <MagneticDuck> imo
14:11:37 <MagneticDuck> but "mo" from "imo" isn't very experienced
14:11:39 <ddarius> I have no idea why you have parentheses in the very last case.
14:11:41 <MagneticDuck> :P
14:11:49 <SwineFlu> Is haskell used outside academa
14:11:50 <SwineFlu> for anything
14:11:58 <MagneticDuck> the last function?
14:12:01 <MagneticDuck> haha
14:12:04 <MagneticDuck> I was desperate
14:12:05 <hiptobecubic> MagneticDuck, parsing by humans is more important :)
14:12:08 <hiptobecubic> SwineFlu, yes.
14:12:10 <MagneticDuck> and I haven't fixed it yet
14:12:12 <nand`> SwineFlu: I'm not in academia, and I use Haskell for things that exist
14:12:22 <adnam> SwineFlu: http://www.haskell.org/haskellwiki/Haskell_in_industry
14:12:32 <MagneticDuck> SwineFlu: look at what we're reviewing right now
14:12:35 <MagneticDuck> :P
14:12:37 <MagneticDuck> https://github.com/MagneticDuck/DuckBot/blob/master/src/DuckBot/Sentence.hs
14:12:39 <MagneticDuck> well
14:12:48 <MagneticDuck> that's not a good example
14:12:57 <MagneticDuck> good link adnam
14:13:12 <nand`> SwineFlu: I use Haskell programs in my daily life too; xmonad, darcs, yeganesh, ghci, etc.
14:13:25 <ddarius> (not . null $ str) is a silly way of writing not (null str)
14:13:33 <hiptobecubic> <3 xmonad
14:13:43 <MagneticDuck> mm
14:13:54 <Hakkla> why is that ddarius?
14:13:56 <MagneticDuck> I prefer a . b $ c over a (b c)
14:13:57 <hiptobecubic> ddarius, i don't think so
14:14:10 <ddarius> Read what I wrote more carefully.
14:14:34 <MagneticDuck> ddarius: I guess that reduces key strokes
14:14:37 <MagneticDuck> :P
14:14:45 <ddarius> MagneticDuck: Application always binds tighter than infix operators.
14:14:57 <ddarius> It's not just less keystrokes it's easier to read and less noisy in this case.
14:15:03 <Hakkla> it doesn't... it uses more characters.
14:15:10 <SwineFlu> adnam, awesome link
14:15:11 <Hakkla> from this point of view at least.
14:15:17 <hiptobecubic> I dispute the 'easier to read' argument
14:15:36 <MagneticDuck> hm
14:16:02 <MagneticDuck> btw, https://github.com/MagneticDuck/DuckBot/blob/master/src/DuckBot/FunctionString.hs is more recent, and has smarter code because when I wrote it I had some more experience
14:16:10 <ddarius> hiptobecubic: You'd rather see (all (not . isAlphaNum) str) && (not . null $ str) rather than: all (not . isAlphaNum) str && not (null str) ?
14:16:22 <ddarius> @hoogle notNull
14:16:36 <MagneticDuck> ty for opinions btw
14:16:38 <ch33sus_> hi so i have my small script that runs with winghci but when i try to compile with ghc it says it needs a main function
14:16:51 <Hakkla> then do a main function?
14:16:54 <MagneticDuck> you're trying to make an applicatoin
14:17:00 <MagneticDuck> when you are really trying to compile a library
14:17:18 <MagneticDuck> what command are you executing?
14:17:25 <MagneticDuck> ghc --make Src.hs?
14:17:42 <ch33sus_> trying to get c code, ghc -c src.hs
14:17:43 <MagneticDuck> s/applicatoin/application
14:17:55 <ddarius> As a probably pointless optimization, though it doesn't cost anything, you can commute the filter isAlphaNum . map toLower.
14:17:57 <MagneticDuck> What's the module called?
14:18:17 <MagneticDuck> ddarius: commute?
14:18:24 <ch33sus_> test :D
14:18:30 <hiptobecubic> ddarius, the only difference there is the not (null str) part and some redundant parens that aren't at all what we're talking about?
14:18:34 <ddarius> filter isAlphaNum . map toLower = map toLower . filter isAlphaNum
14:18:39 <MagneticDuck> okey, I have no idea why it's doing that then ch33us_
14:19:05 <hiptobecubic> because yes, the first to me looks better. the  (not . null) is a single logical idea to me, independent of the str
14:19:16 <lambdabot> No results found
14:19:25 <ddarius> Way to be slow lambdabot.
14:19:32 <ch33sus_> hm, ok so what are the package names for haskell under linux i tried ghci and haskell but it didtn find any
14:20:28 <MagneticDuck> ch33us_: you're on linux?
14:20:32 <MagneticDuck> what distro?
14:20:32 <ch33sus_> ya
14:20:35 <ch33sus_> uhm
14:20:39 <MagneticDuck> ubuntu?
14:20:42 <MagneticDuck> debian?
14:20:45 <ch33sus_> ami, its amazon deriviative
14:20:47 <ch33sus_> it has yum
14:21:01 <MagneticDuck> install "haskell-platform"
14:21:06 <MagneticDuck> and you should get a ghci executable
14:21:17 <MagneticDuck> among everything else you need to do haskell stuff
14:21:38 <monochrom> "ghc -c src.hs" does not give you C code
14:21:44 <ch33sus_> wat
14:21:50 <MagneticDuck> yeah
14:21:53 <MagneticDuck> that too
14:21:55 <MagneticDuck> :P
14:21:57 <MagneticDuck> it compiles to..
14:21:57 * ddarius executes ghc -java src.hs
14:22:01 <MagneticDuck> (looks in documentation)
14:22:11 <ch33sus_> really i saw somehting lile that in the --help
14:22:14 <ch33sus_> i guess
14:22:17 <ch33sus_> not too sure
14:22:19 <ddarius> MagneticDuck: It compiles to assembly.
14:22:26 <ddarius> Well, machine code.
14:22:41 <ch33sus_> so it also cant finde haskell-platform
14:22:44 <MagneticDuck> yes
14:22:48 <MagneticDuck> weird
14:22:53 <MagneticDuck> no idea
14:23:00 <MagneticDuck> anyone here use yum?
14:23:07 <monochrom> I think no one understands the real question
14:23:17 <MagneticDuck> he's trying to install haskell-platform right now
14:23:32 <ch33sus_> just something to run my script :D
14:23:56 <MagneticDuck> lol
14:24:00 <MagneticDuck> you have ghci?
14:24:07 <ch33sus_> on windows
14:24:15 <MagneticDuck> type ghci into the console on linux, does anything come up?
14:24:26 <MagneticDuck> or does it give you an error?
14:25:11 <ch33sus_> yo, i have ghci on my windows box and the linux is fresh installed and i cant find the name for the package
14:25:31 <MagneticDuck> okay
14:25:36 <MagneticDuck> http://hackage.haskell.org/platform//linux.html
14:25:40 <MagneticDuck> follow instructions from there
14:25:44 * ddarius agrees with monochrom.
14:25:54 <MagneticDuck> you will have haskell-platform on your machine
14:25:58 <MagneticDuck> your linux machine
14:26:17 <MagneticDuck> and you get ghc(i), cabal, bleh bleh bleh
14:27:18 <MagneticDuck> ddarius, monochrom: leave it to me 8|
14:27:25 <MagneticDuck> 8| <- sun glasses
14:28:53 <ch33sus_> hm but say i have my haskell converted to c, i could copy the code to the linux machine and compile there with gcc
14:28:59 <MagneticDuck> nonono
14:29:03 <MagneticDuck> -c doesn't do anything with c
14:29:06 <ch33sus_> sure
14:29:16 <ch33sus_> ghc --help
14:29:17 <MagneticDuck> if you have c code, you can compile it on linux
14:29:19 <monochrom> that route is way too hard
14:29:24 <ch33sus_> i know :D
14:29:25 <MagneticDuck> yeah
14:29:30 <MagneticDuck> and lots of weird things along the way
14:29:39 <MagneticDuck> okay, but you have ghc now?
14:29:45 <ch33sus_> on windows
14:29:49 <MagneticDuck> grr
14:30:03 <MagneticDuck> did you install the haskell platform on your linux partition?
14:30:05 <ch33sus_> but if i comile and install the haskell platform i could as well
14:30:12 <Yiq> anyone here did something with rabbitmq
14:30:14 <ch33sus_> no its in the "cloud"
14:30:15 <ch33sus_> haha
14:30:20 <ch33sus_> the linux
14:30:24 <MagneticDuck> mmhmm
14:30:26 <MagneticDuck> yes
14:30:30 <ch33sus_> putty
14:30:43 <MagneticDuck> okey
14:30:48 <MagneticDuck> everything set?
14:30:49 <ddarius> You can install GHC on your cloud server and build there, though it would make more sense to have a local linux so all you need to transfer is the binary.
14:31:07 <MagneticDuck> yeah
14:31:10 <ch33sus_> and whats the ghc package name?
14:31:14 <ch33sus_> its not ghc
14:31:18 <MagneticDuck> no
14:31:24 <ch33sus_> atleast in the amazon repository
14:31:24 <MagneticDuck> why not install haskell-platform?
14:31:36 <ch33sus_> i would have to build from source
14:31:43 <ch33sus_> never liked that
14:31:53 <ch33sus_> if i do that i can as well compile my c code
14:32:00 <MagneticDuck> if you don't have the universe repository, you'll have to
14:32:06 <ch33sus_> ya
14:32:07 <MagneticDuck> whether it's ghc or whatever
14:32:38 <ch33sus_> ha they have like nothing i tried to get a fortran compiler for numpy but i didnt find one as well
14:32:40 <ch33sus_> damn fortran
14:32:42 <ch33sus_> dude
14:32:56 <MagneticDuck> btw, you don't have to do much to install the platform
14:33:00 <MagneticDuck> cabal install
14:33:03 <MagneticDuck> erm
14:33:07 <MagneticDuck> no
14:33:43 <MagneticDuck> any help guys?
14:33:48 <MagneticDuck> I'm all alone
14:33:50 <MagneticDuck> x)
14:33:58 <MagneticDuck> and I have work to do actually
14:34:20 <ch33sus_> ha irc sometimes is like reddit :D
14:34:26 <ch33sus_> consumes too much time
14:34:54 <MagneticDuck> hehe
14:34:57 <MagneticDuck> true
14:35:10 <MagneticDuck> so does being a geek
14:35:39 <MagneticDuck> or having an account on github
14:35:44 <MagneticDuck> MUST..GET..COMMIT..OUT..
14:35:54 <MagneticDuck> at least that's how it is with me
14:36:26 <MagneticDuck> I'm weirdly motivated to make the graphs keep going up
14:36:48 <MagneticDuck> https://github.com/MagneticDuck/DuckBot/graphs/code-frequency
14:36:52 <MagneticDuck> tee hee hee
14:37:45 <MagneticDuck> and also to keep the first derivitaves of all the lines keep going up
14:37:51 <MagneticDuck> derivatives
14:38:03 <MagneticDuck> and keep the second derivatives more or less stable
14:38:05 <ddarius> MagneticDuck: Good luck.  I recommend writing a program to do that for you.
14:38:16 <MagneticDuck> ddarius: hehe
14:38:46 <MagneticDuck> after a while I won't even be able to sleep at this rate
14:38:57 <MagneticDuck> and then I'll have to more to mars
14:39:03 <MagneticDuck> so the days are longer
14:39:11 <MagneticDuck> this is going in a weird direction
14:39:19 <MagneticDuck> *move
14:39:33 <ch33sus_> meh why mars
14:40:08 <ch33sus_> why mars when you can have Neptune
14:40:39 <ch33sus_> uuh A simple and customizable irc bot
14:40:59 <MagneticDuck> x)
14:41:04 <MagneticDuck> "simple" I said
14:41:09 <MagneticDuck> well, it will be simple to use
14:41:16 <MagneticDuck> no really
14:41:30 <ch33sus_> how do i have to indent where clauses
14:41:41 <MagneticDuck> how so?
14:42:24 <MagneticDuck> blehblehbleh\n    hi = bleh\n    hi2 = blehblah
14:42:39 <ch33sus_> http://pastebin.com/zR6na3cw
14:42:41 <mauke> The paste zR6na3cw has been copied to http://hpaste.org/73372
14:42:44 <ch33sus_> gets me indent errors
14:42:56 <ch33sus_> possible
14:43:06 <MagneticDuck> erm
14:43:09 <MagneticDuck> no
14:43:13 <hpaste> nand` annotated “pastebin.com/zR6na3cw” with “pastebin.com/zR6na3cw (annotation)” at http://hpaste.org/73372#a73373
14:43:18 <nand`> this is how you'd usually do it
14:43:22 <mauke> ch33sus_: missing )
14:43:31 <ch33sus_> wher
14:43:40 <mauke> I don't know
14:43:44 <mauke> but you have 3 ( and 2 )
14:43:46 <MagneticDuck> oh, and that isn't good at all
14:43:54 <nand`> that ++ section also doesn't look like it should type check
14:43:59 <mauke> also, wtf is a kraftsumme?
14:44:04 <nand`> it's a powerful sum
14:44:04 <MagneticDuck> what's with the ++s on the beginning and the end?
14:44:09 <MagneticDuck> KRAFTSUMME
14:44:11 <nand`> or power sum*
14:44:17 <MagneticDuck> pronounced with a German accent
14:44:24 <ch33sus_> xD
14:44:28 <MagneticDuck> KREAFTESUMMEH
14:44:35 <MagneticDuck> BE AFRAID
14:44:35 <ch33sus_> no its a function for a force (kraft)
14:44:39 <MagneticDuck> ah
14:44:56 <ch33sus_> i didnt know how to ouput a float :D
14:45:06 <mauke> except it's not called a "kraftsumme" in german
14:45:06 <MagneticDuck> aah
14:45:07 <ch33sus_> thought that ++ ... ++  would format
14:45:10 <MagneticDuck> print
14:45:19 <ch33sus_> mauke what
14:45:25 <MagneticDuck> "print" prints out just about anything
14:45:28 <mauke> that was in reply to nand`
14:45:34 <MagneticDuck> (actually, everything that has a Show definition)
14:45:45 <nand`> mauke: “kräftesumme”?
14:45:51 <ch33sus_> so print betrag(...)?
14:45:57 <mauke> nand`: Potenzsumme
14:46:07 <ch33sus_> quatsch
14:46:14 <nand`> I've never seen Potenz used for forces, just exponentials
14:46:16 <ch33sus_> power == potenz und kraft
14:46:30 <hpaste> MagneticDuck annotated “pastebin.com/zR6na3cw” with “pastebin.com/zR6na3cw (annotation) (annotation)” at http://hpaste.org/73372#a73374
14:46:33 <MagneticDuck> there we go
14:46:37 <MagneticDuck> all awesome
14:46:38 <mauke> reference: http://de.wikipedia.org/wiki/Newton-Identit%C3%A4ten
14:46:50 <ch33sus_> ha u dont like brackets dont you
14:47:11 <ch33sus_> $$$$$$ all over the place
14:47:20 <MagneticDuck> no I don't (actually I do (really (haha (this is so punny (get it (I bet you do))))))
14:47:41 <MagneticDuck> I am a punny duck
14:47:42 <ch33sus_> missing ) , expected ";"
14:47:44 <ch33sus_> :D
14:47:51 <MagneticDuck> mm?
14:48:11 <MagneticDuck> hehe
14:48:27 <MagneticDuck> no
14:48:33 <MagneticDuck> parse error : )
14:48:36 <MagneticDuck> :)
14:48:36 <ch33sus_> damn
14:48:50 <ddarius> MagneticDuck: I thought you were supposed to be checking code into github?
14:48:53 <MagneticDuck> I BEAT YOU IN DEH WARS OF DEH PARENS
14:49:00 <MagneticDuck> ddarius: omg!! AAAAAAA
14:49:01 <nand`> no
14:49:09 <MagneticDuck> yes
14:49:12 <MagneticDuck> I must get back
14:49:13 <nand`> we hate brackets :(
14:49:14 <nand`> at least I do
14:49:23 <MagneticDuck> I'm sure all these intelligent people won't miss me
14:49:24 <dolio> I hate them, too.
14:49:25 <monochrom> try rewriting "I don't (actually I do (really (haha (this is so punny (get it (I bet you do))))))" using $'s. I bet you can't
14:49:25 <MagneticDuck> :P
14:49:26 <ch33sus_> lol i got a 2193 line C file from like 10 lines haskell
14:49:27 <ion> monochrom: That almost looked like a Russian person IRCing)))))))))))))))
14:49:28 <nand`> mauke: I see. It seems that article is using it to reference, well, actual sums of exponentials. (I know nothing about the domain it's applied to)
14:49:30 <ch33sus_> gotta be kidding me
14:49:46 <ion> How so?
14:49:48 <nand`> shows how expressive Haskell is
14:49:50 <nand`> ;)
14:49:56 <ch33sus_> oh yeah
14:50:02 <mauke> nand`: the english version calls it a "power sum"
14:50:12 <ch33sus_> noway
14:50:21 <nand`> mauke: yeah, that seems like a completely reasonable translation
14:50:37 <MagneticDuck> monochrom: here we go...
14:51:02 <MagneticDuck> actuallyIDo . really . haha . thisissopunny . getit $ I bet you do
14:51:06 <MagneticDuck> ta da
14:51:10 <MagneticDuck> *ahem*
14:51:15 <MagneticDuck> taa daa
14:51:58 <ch33sus_> https://plus.google.com/u/0/106537406819187054768/posts
14:51:59 <monochrom> that works. how about "beautiful (yes that's right) and powerful"
14:52:45 <ch33sus_> for all the kraft friends here
14:52:49 <ch33sus_> just found that line
14:52:50 <ch33sus_> ((W_)&Main_kraft_srt+12), 0x1U, 0x10011U };
14:53:33 <MagneticDuck> dableep is that
14:54:01 <mauke> partial not-quite-C
14:54:15 <MagneticDuck> C!
14:54:18 <MagneticDuck> aa
14:54:28 <MagneticDuck> C is the opposite of haskell
14:54:31 <MagneticDuck> well
14:54:34 <MagneticDuck> one of the opposites
14:56:10 <ion> Not really. PHP is much further on the “opposite of Haskell” scale for instance.
14:56:26 <Philippa_> hell, C and Haskell share an interesting common ancestor
14:56:48 <shachaf> "urry"?
14:56:58 <ch33sus_> assembler hur hur
14:57:09 <shachaf> ch33sus_: That's not an ancestor of Haskell.
14:57:16 <MagneticDuck> btw.. what's your favorite haskell code everyone?
14:57:22 <ch33sus_> gotta be?
14:57:26 <MagneticDuck> a single function
14:57:30 <MagneticDuck> here's mine:
14:57:31 <ch33sus_> everyones evolving from assembler
14:57:32 <hpaste> MagneticDuck pasted “my favorite haskell function” at http://hpaste.org/73375
14:57:33 <ion> magneticduck: undefined
14:57:39 <MagneticDuck> or one of my favorites
14:57:43 <MagneticDuck> ion: haha
14:57:49 <MagneticDuck> that really got me when I first discovered it
14:57:53 <mauke> ch33sus_: not lambda calculus
14:57:58 <MagneticDuck> it's one of the most useful things I know
14:58:00 <MagneticDuck> :P
14:58:31 <ch33sus_> yeah
14:58:36 <ch33sus_> ur right
14:58:41 <monochrom> lambda calculus evolved from turing machine. to tease all of you. ha ha
14:58:47 <fmap> MagneticDuck: not enough one letter variables
14:58:59 <ion> magneticduck: That’s not very pretty. :-P
14:59:06 <nand`> my favorite line of haskell code:
14:59:08 <nand`> (%%~) = id
14:59:12 <MagneticDuck> O.o
14:59:19 <shachaf> monochrom: More like from intuitionistic logic.
14:59:23 <ch33sus_> i confused implementation with heritance
14:59:24 <MagneticDuck> interesting
14:59:31 <MagneticDuck> ion: how so?
15:00:24 <monochrom> I think the names are too long, too. could be half as short
15:00:30 <MagneticDuck> I write big names
15:00:35 <MagneticDuck> that's my thing
15:00:37 <MagneticDuck> that's how you know it's me
15:00:39 <MagneticDuck> :P
15:00:45 <ion> magneticduck: The least significant parts are first; nested let…ins; excess ($)s; a non-total function; no code comments
15:00:59 <MagneticDuck> breakIntoPhrasesTakingAListOfPredicatesAndReturningAFunctionBreakingASTring
15:01:14 <MagneticDuck> ion: non-total function?
15:01:18 <ion> > init []
15:01:20 <lambdabot>   *Exception: Prelude.init: empty list
15:01:37 <MagneticDuck> my code there should never give an error
15:01:42 <MagneticDuck> that's how it is
15:02:24 <MagneticDuck> well, forget about the refactoring that could be done
15:02:29 <MagneticDuck> the logic is the pretty part
15:02:35 <MagneticDuck> if you rename all the vars etc
15:03:16 <ion> I don’t see a problem with the names.
15:03:36 <ion> But some spacing and comments would be warranted.
15:04:00 <nand`> names can be much longer than that
15:04:05 <nand`> https://github.com/timthelion/haskarrow/blob/master/HaskarrowPrecompile.lhs#L100
15:04:39 <Philippa_> the common ancestor I had in mind was CPL, FWIW
15:24:22 <SwineFlu> I once watched a video on youtube
15:24:26 <SwineFlu> and it was a google tech talk
15:24:27 <SwineFlu> about haskell
15:24:33 <SwineFlu> and the guy taken it was very good
15:24:39 <SwineFlu> Can anyone find it?
15:24:49 <mauke> http://youtu.be/b9FagOVqxmI
15:26:29 <SwineFlu> How did you find that >.>
15:26:41 <mauke> I went to youtube and searched for "google haskell"
15:26:43 <hiptobecubic> altavista
15:26:52 <SwineFlu> I tried that >.>
15:26:56 <SwineFlu> Oh wait...
15:26:57 <mauke> first result
15:26:58 <mast`> it's the first result for "google haskell" on youtube
15:27:00 <SwineFlu> Its the only video i didnt click
15:27:07 <hiptobecubic> :D
15:27:09 <SwineFlu> I feel stupid now :D
15:27:31 <mauke> my work here is done
15:27:54 <SwineFlu> How much acid do i have to take to understand haskell
15:28:00 <mauke> none
15:28:09 <JoeyA> @quote drugs
15:28:10 <lambdabot> DukeDave says: what, if your kids start doing drugs? or worse, business school
15:28:11 <JoeyA> bah
15:28:12 <mauke> you may have to unlearn programming, though
15:28:24 <MostAwesomeDude> @quote drug
15:28:25 <lambdabot> SAHChandler says: young and hip children would use these "emoticons" to signal when they were in possession of drugs, and how they were going to overthrow the proletariate
15:28:30 <MostAwesomeDude> Pfft.
15:28:34 <JoeyA> @quote satisfying
15:28:35 <lambdabot> <JoeyA> says: One thing I like about Haskell versus C++ is that abusing language features tends to give more satisfying results.  <monochrom> that seems to be a criterion for drugs rather than
15:28:35 <lambdabot> languages :)
15:28:57 <SwineFlu> I've been programing in Java c# and (mostly) PHP for the last 3 - 4 years
15:29:01 <SwineFlu> This may be a learning curve haha
15:29:04 <mauke> not a good start :-)
15:29:18 <mauke> http://tryhaskell.org/
15:31:06 <mast`> I'm moving from C to Haskell myself (well not moving but 'adding' to my repertoire)
15:31:23 <mast`> and it's like both fun and scary
15:31:39 <SwineFlu> I've wrote some C
15:31:50 <SwineFlu> C is scary with all its pointers and stuff ;x
15:33:39 <Automorphism> SwineFlu: What you need to understand Haskell is to take a deep breath and accept the fact that the type system is there to help you. It is not something you have to fight against (unlike in C++ or Java).
15:34:05 <nand`> hey, C++'s type system is pretty flexible
15:34:08 <mauke> pfft, I've fought the haskell type system before
15:34:14 <mauke> nand`: exactly
15:34:29 <Botje> the AoE attacks are killer, though.
15:34:40 <sipa> age of empire?
15:34:49 <Cale> Area of Effect
15:34:50 <nand`> and by ‘pretty flexible’ I mean ‘you could implement a sophisticated type-checker within C++ types then use that to type check instead’
15:34:58 <Automorphism> nand`: C++'s type system is broken in a number of ways.
15:35:03 <mauke> "hey, this banister is pretty flexible"
15:35:07 <nand`> Automorphism: but turing complete
15:35:09 <sipa> C++'s type system is turing complete, no?
15:35:22 <mauke> sipa: kind of ... maybe
15:35:26 <Automorphism> nand`: A few days ago, I wanted to implement my own version of std::unique_ptr whose internal pointer is guaranteed to not be aliased.
15:35:52 <Automorphism> nand`: After consulting with ##c++ folks, it turned out it is impossible.
15:35:54 <geekosaur> lots of things are turing complete.  doesn;t mean you want to write programs in, say, vi macros (not vimscript but vi commands in a register)
15:36:00 <mauke> sipa: it's not really the type system
15:36:20 <nand`> we need a Haskell to C++ templates compiled
15:36:20 <shachaf> Being Turing-complete isn't the goal of a type system.
15:36:22 <nand`> compiler*
15:36:28 <mauke> templates are just a fancier preprocessor and the expansion depth is limited
15:36:29 <nand`> Automorphism: I didn't even seem to have understood the question (and don't want to either; I don't want to be affiliated with C++ other than it being the butt monkey of my jokes)
15:36:45 <nand`> mauke: I see
15:37:10 <Automorphism> nand`: Haskell is too beautiful to ruin it by compiling it down to C++.
15:37:25 <mauke> there's no fixed limit in the standard but pretty much every implementation has one
15:37:50 <nand`> Automorphism: doesn't stop hordes of people from compiling it down to JavaScript
15:37:51 <shachaf> I wish the Haskell fan club would leave this channel and go somewhere else.
15:37:58 <shachaf> We should have a different channel for talking about how great Haskell is.
15:38:16 <mauke> #haskell-fans?
15:38:27 <shachaf> Sure.
15:38:42 <mauke> hmm, or maybe #haskell-rocks
15:38:42 * Automorphism adds to #haskell-fans to his auto-join list.
15:38:47 <mauke> then we can have #haskell-sucks
15:38:48 <Philippa_> next up: #haskell-fanwank
15:42:24 <Cale> #haskell-circlejerk?
15:42:29 <shachaf> Does anyone have any good isomorphisms?
15:42:41 <mauke> echocham.br
15:43:12 <shachaf> mm_freak's data Foo t = forall a. a (a -> a) (a -> t) as well as the things edwardk mentioned got me looking for others now.
15:43:44 <Automorphism> shachaf: Perhaps one between [()] and Integer?
15:44:03 <shachaf> Automorphism: You mean Natural?
15:44:18 <mauke> complex numbers are real pairs
15:44:22 <Automorphism> shachaf: I meant to order the integers as follows: 0, 1, -1, 2, -2, etc.
15:44:24 <ion> shachaf: What’s Foo t an isomorphism of?
15:44:44 <shachaf> ion: Nat -> t
15:44:52 <Automorphism> shachaf: Is that not valid?
15:45:01 <shachaf> Automorphism: Well, sure, you can do that.
15:45:28 <shachaf> You can do it with any countable type, though.
15:45:29 <ddarius> Actually, one of the first programs I wrote in Haskell compiled a simple Haskell-like language into C++ templates.  It was very, very easy to do.
15:45:41 <shachaf> I'd prefer something with parameterized types or something.
15:46:16 <shachaf> There's also (exists a. Show a *> a) ~ String ~ (forall a. Read a => a)
15:47:58 <shachaf> These are all pretty easy. But surely there are interesting ones.
15:48:23 <ion> shachaf: What’s an example of an appropriate “a” for Foo t?
15:48:48 <shachaf> ion: t would be one example. :-)
15:48:55 <shachaf> I mean, you can pick any a you want.
15:49:02 <shachaf> As long as it's inhabited, I guess.
15:49:19 <parcs`> data SF a b = forall s. SF s (a -> s -> (b,s)) ~ newtype SF a b = SF (a -> (b, SF a b))
15:49:40 <NihilistDandy> This is the weirdest Haskell I've ever seen~: http://hpaste.org/73365
15:50:36 <shachaf> parcs`: Didn't that one come up in the conversation with mm_freak? :-)
15:51:17 <parcs`> yeah
15:53:45 <parcs`> how is String ~ (forall a. Read a => a)
15:54:11 <mauke> is it?
15:54:23 <parcs`> that's what shachaf said
15:54:25 <shachaf> Assuming class Read a where read :: String -> a
15:54:27 <dolio> No, it isn't.
15:54:38 <shachaf> dolio: It's not?
15:54:55 <dolio> I can do things with a string besides read it.
15:55:16 <shachaf> data Foo = Foo String
15:55:17 <parcs`> it would be isomorphic if read x = x
15:55:29 <sipa> mauke: agree, the template engine is not really part of the type systen
15:55:30 <mauke> shachaf: how do I turn "" into Read a => a?
15:55:47 <shachaf> instance Read Foo where read = Foo
15:56:28 <shachaf> mauke: "read"?
15:56:28 <shachaf> read :: String -> Read a => a
15:56:29 <shachaf> (forall a. Read a => a) gets turned into (forall a. (String -> a) -> a)
15:56:30 <shachaf> Passing it id is one direction of the isomorphism.
15:57:28 <DT``> > read "" :: String
15:57:45 <parcs`> thanks a lot for breaking lambdabot
15:57:59 * shachaf isn't sure what dolio/mauke mean.
15:57:59 <lambdabot>   "*Exception: Prelude.read: no parse
15:57:59 <ion> dt: read "" :: Foo
15:58:00 <shachaf> I'm assuming a read that can't fail, of course. Exceptions are outside the scope of all this.
15:59:08 <mauke> f = read; g = unFoo
16:02:05 <dolio> I guess in that case it works.
16:02:26 <dolio> Although that now violates the intent of Read.
16:02:38 <dolio> But then, lots of stuff does.
16:03:04 <shachaf> dolio: Sure, but type classes are open.
16:03:27 <shachaf> Anyway I'm not talking about "real Read", I'm talking about a hypothetical one for the purpose of this exercise.
16:04:12 <shachaf> It violates the intent of Read in the same way that "data Bar = forall a. Show a => Bar a; instance Show Bar where show (Bar x) = show x" violates the intent of Show.
16:04:36 <dolio> Yes.
16:05:53 <shachaf> Anyway it's kind of nice how an existential wrapper for Show or a universal wrapper for Read are both ~ String.
16:06:49 <dolio> Not surprising. One is the encoding of the intial algebra for Const String, and the other is the encoding of the final coalgebra.
16:07:23 <dolio> If you look at it that way.
16:07:35 <monochrom> "a -> String" is a very simplistic type afterall
16:07:38 <Saizan> you can also see them as applications of the yoneda lemma
16:07:41 <shachaf> (a -> Const String a), (Const String a -> a)?
16:08:02 <shachaf> Well, that would be any algebra or coalgebra, I guess.
16:08:24 <dolio> Those are the types of (co)algebra actions on a, yes.
16:09:43 <monochrom> you may like to play with "a -> (Int, a)" next
16:10:10 <shachaf> I guess inital and terminal algebras for Const x aren't very interesting.
16:10:13 <shachaf> monochrom: What about it?
16:10:50 <parcs`> Saizan: do elaborate
16:13:26 <dolio> The Yoneda lemma applied to Haskell says that F T ~ forall a. (T -> a) -> F a, for functors F and types T.
16:13:31 <Saizan> parcs`: there's an isomorphism f a ~ forall b. (a -> b) -> f b, for any Functor f, take f = Id and a = String
16:14:40 <thirsteh> I understand some of these words
16:14:57 <Saizan> but also exists b. (f b , b -> a) ~ f a, so you get the Show isomorphism too
16:15:26 <ddarius> shachaf: Given the adjunctions (->A)
16:16:35 <parcs`> nice
16:17:56 <aristid> thirsteh: "Haskell" and "types"? :)
16:18:16 <thirsteh> and "elaborate"
16:18:27 <aristid> thirsteh: that's a nice word, too.
16:19:30 <parcs`> :t \f -> (f, \g -> fmap g f)
16:19:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (f a, (a -> b) -> f b)
16:22:59 <parcs`> is the yoneda lemma what's used to convert exists a. a into (forall a. a -> r) -> r ?
16:23:16 <parcs`> or rather can it be used
16:24:05 <dolio> Not exactly. It could be part.
16:24:37 <dolio> It gives you that exists a. a ~ forall r. ((exists a. a) -> r) -> r
16:24:52 <dolio> Then you use that (exists a. a) -> T ~ forall a. (a -> T)
16:25:07 <dolio> Which is actually currying, more or less.
16:43:13 <ddarius> shachaf: Given the adjunction (A,) -| (A
16:43:16 <ddarius> Christ.
16:44:02 <mauke> christianity in a nutshell
16:51:11 <pharaun> got a little bit of library design, is it preferred to use blocking calls or non-blocking + callbacks ?
16:51:23 <kallisti> blocking and concurrency, typically.
16:51:26 <ddarius> pharaun: The former.
16:51:41 <pharaun> blocking? k alright thanks
16:53:43 <Yiq> http://testpersta.appspot.com/ /* Does that look ok to you guys now? Anyone on 1080 monitor? */
17:04:29 <roconnor> it strikes me the removing upper bounds on pacakges would only work if cabal somehow automatically tried older versions of dependnecies when compilation fails ... which seems unreasonable for many reasons.
17:04:57 <roconnor> perhaps people have forgotten the nightmare that was hackage without upperbounds
17:05:08 <roconnor> as opposed to the bad dream that hackage currently is
17:06:03 <NihilistDandy> I like the idea of wiki'd bounds. Putting the onus for dependency version bumping on package maintainers isn't altogether reasonable
17:06:28 <roconnor> NihilistDandy: I do that already :D
17:06:40 <roconnor> anyone with a hackage account can upload any package
17:06:50 <ddarius> shachaf: Given the adjunction (A,) -| (A->) and the adjunction (->A)^op -| (->A) and the continuity properties of left and right adjoints, we have Colim_i(F^i(0)) -> B ~ Lim_i(F^i(0) -> B)) ~ (/\X.Lim_i(F^i(0) -> X)(B) ~ Lim_i(F^i(0) -> -)(B).  If we can make a G such that the functor (F(A)->) ~ G(A->), then we have Colim_i(F^i(0)) -> B ~ Lim_i(G^i(1)(B), i.e. (mu F) -> B ~ (nu G)(B).  E.g. 1+A -> B ~ (B, A -> B), so F
17:06:50 <ddarius> = (1+), mu F = Nat, G = (=,-), nu G = Stream, so Nat -> B ~ Stream B
17:14:49 <Yiq> what kind of messaging is done rabbitMQ?
17:15:27 <parcs`> i have 260 packages locally installed, 0 broken packages and absolutely no issues
17:15:39 <monochrom> nice
17:15:42 <parcs`> what's this dependency problem that people are facing?
17:16:06 <parcs`> after cabal 1.14 was released everything has been smooth sailing for me
17:16:20 <geekosaur> a good example is one some people are seeing on a fresh haskell-platform install, cabal install cabal-dev wants to break a bunch of stuff
17:18:03 <NihilistDandy> I managed to install gitit, darcs, yesod, and Agda without anything breaking. I was amazed.
17:18:52 <geekosaur> darcs worked fine for me, as did a bunch of other things.  cabal-dev was a nasty surprise
17:20:03 <hpaste> ND pasted “Ouch” at http://hpaste.org/73377
17:20:05 <NihilistDandy> You know, I hadn't even looked at cabal-dev on this install, yet. Now I see what you mean.
17:21:09 <NihilistDandy> I guess there's always hsenv
17:25:30 <ddarius> :t forever
17:25:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:25:48 <SwineFlu> Why, when using the print function do we use "(" and ")", For example print (1 + 5)
17:26:00 <SwineFlu> Why are the "(" needed in this case and not other cases with functions
17:26:21 <parcs`> SwineFlu: why is () needed in (1 + 2) * 3?
17:26:31 <ion> Function application always binds tighter than operators.
17:26:33 <NihilistDandy> SwineFlu: Function application has higher precedence
17:26:39 <n00b6502> are my haskell programs going to be unbareably lame if i dont master monads and just use IO imperative blocks + pure non-monadic blocks
17:27:01 <SwineFlu> parcs`, Order of operations?
17:27:18 <adnauseam> when doing induction on lists, my basis step is over the empty list, that much i know. but then is the assumption that from our basis we derive that it is true for an element, and then move on to prove it for the list, or that it's true for the list, and we move on to prove it for its elements ?
17:27:27 <thirsteh> SwineFlu: it becomes (print 1) + 5. You can do print $ 1 + 5
17:27:28 <ion> n00b6502: There’s no need to understand monads before you understand monads.
17:27:46 <thirsteh> to understand recursion, you must first understand ecursion
17:28:29 <geekosaur> SwineFlu, it's not that print needs parentheses arund its arguments.  consider that if print took *two* parameters, you might say something like:  print 2 (1 + 5)
17:29:09 <SwineFlu> Ah, so its just a grouping of arguments
17:29:37 <ddarius> @hoogle threadDelay
17:29:37 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
17:29:37 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
17:29:38 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
17:36:41 <nand`> Is it possible when using cabal to build against a locally built version of a library instead of the system-wide one?
17:37:18 <nand`> I want to submit a patch for a certain library, but before I do so I want to make sure the included example projects still build after my changes
17:38:00 <nand`> how would I best do this without nuking my globally installed version of that library and installing this one in its place, then testing and reverting the previous procedure?
17:38:20 <geekosaur> hm?  install it as a user package... but this is what cabal-dev is for
17:38:45 <monad1> !seen
17:38:49 <monad1> .seen
17:39:02 <nand`> oh, right; I could install it as a user package in ~/.cabal then nuke that afterwards
17:40:39 <nand`> (how do I omit documentation? It still wants to copy documentation to /usr/local/share/doc )
17:40:58 <ragusa> adnauseam: Good read on induction (and coinduction) http://www.cs.ru.nl/~bart/PAPERS/JR.pdf
17:41:23 <NihilistDandy> nand`: There's either a cabal flag, or you can shut it off in .cabal/config
17:41:48 <geekosaur> --disable-documentation
17:42:36 <nand`> geekosaur: Seems to be an unrecognized option
17:43:04 <geekosaur> odd.  listed here...
17:43:13 <nand`> Cabal version 0.14.0
17:43:25 <nand`> err, 1.14.0
17:43:55 <NihilistDandy> cabal install --help | grep documentation
17:44:20 <NihilistDandy> Should show --disable-documentation
17:45:30 <nand`> oh, I need cabal-install for this don't I?
17:45:39 <NihilistDandy> What are you using?
17:45:41 <NihilistDandy> ./Setup ?
17:45:44 <nand`> yeah
17:45:49 <NihilistDandy> Just don't ./Setup haddock
17:45:53 <nand`> runhaskell Setup.hs
17:46:06 <nand`> I'm not running that
17:46:14 <NihilistDandy> runhaskell Setup.hs configure
17:46:16 <nand`> “./Setup configure && ./Setup install --user”
17:46:17 <NihilistDandy> runhaskell Setup.hs build
17:46:22 <NihilistDandy> runhaskell Setup.hs install
17:46:24 <nand`> err, build too
17:46:31 <NihilistDandy> Hmm
17:46:42 <monochrom> eh? strange, you don't want docs?
17:46:45 <NihilistDandy> ./Setup configure --disable-documentation?
17:46:57 <nand`> that gives me the permission error about /usr/local/share/doc
17:46:58 <monochrom> but docs are skipped by default, you don't need to do anything
17:47:05 <NihilistDandy> ^
17:47:07 <nand`> NihilistDandy: unrecognized flag
17:47:42 <NihilistDandy> Have you built the documentation before? Maybe you need to clean the directory?
17:47:43 <monochrom> Setup does not know --disable-documentation or --enable-documentation. for Setup, doc is controlled by whether you "Setup haddock" or not
17:47:57 <NihilistDandy> That's what I thought.
17:48:08 <nand`> sanity check: “runhaskell Setup.hs clean && runhaskell Setup.hs configure && runhaskell Setup.hs build && runhaskell Setup.hs install”
17:48:19 <nand`> when it gets to installing I get “Setup.hs: /usr/local/share/doc: permission denied”
17:48:28 <nand`> note: I can workaround this by using --docdir=/tmp when configuring
17:49:01 <nand`> now I get “Setup.hs /usr/local/lib/gloss-1.7.5.1: permission denied”. I thought this would install into ~/.cabal? Or is that a cabal-install-only thing?
17:49:08 <monochrom> oh, it still writes to /usr/local/share/doc for license readme etc
17:49:14 <NihilistDandy> You forgot --user in your configure
17:49:18 <mast`> you probably need to sudo it?
17:49:30 <monochrom> and yeah Setup defaults to --global
17:49:42 <monochrom> this is so XY Problem
17:50:00 <nand`> NihilistDandy: oh; yes. I tried ‘runhaskell Setup.hs install --user’
17:50:06 <nand`> it seems I indeed had to pass the flag when configuring
17:50:15 <nand`> that seems to have done the trick, now to hope it works
17:50:16 <monochrom> yes --user is for configure
17:50:37 <monochrom> in general, Setup /= cabal
17:51:03 <ryant5000> has anyone in here used the new ghcjs?
17:51:04 <monochrom> different defaults and completely unrelated workflow
17:51:13 <ryant5000> (the one at github.com/ghcjs/ghc)
17:51:26 <monochrom> "Setup install" is nothing remotely close to "cabal install"
17:51:28 <ryant5000> i'm trying to figure out how to load these .jsexe directories properly
17:51:35 <shachaf> luite has, I assume.
17:51:56 <shachaf> If that's the ghcjs I'm thinking of, anyway.
17:52:10 <monochrom> perhaps I should write a tutorial on that, too. people just assume Setup == cabal
17:52:11 <nand`> hmm, it seems my efforts were in vain; gloss-examples requires base 4.6.* to build in the first place; I only have 4.5.1.0
17:52:19 <ryant5000> shachaf: yeah, i asked in #ghcjs, but i think nobody there (including him) is around right now
17:52:27 <nand`> monochrom: I thought the latter was cabal-install and not cabal any way
17:52:55 <monochrom> well Setup /= cabal-install too
17:53:06 <monochrom> <monochrom> "Setup install" is nothing remotely close to "cabal install"
17:53:11 <nand`> yes
17:53:32 <NihilistDandy> monochrom: My general rule is that any flag I pass to cabal-install is for `Setup configure`
17:53:34 <nand`> but to me ‘cabal’ refers to the ‘cabal’ package, and not the ‘cabal-install’ package
17:53:50 <monochrom> I would write "Cabal" for the lib
17:53:54 <nand`> ah
17:54:05 <nand`> they're both lower-case in my package manager, I just checked with hackage and it's uppercase there
17:54:07 <monochrom> "cabal" can only be the cabal-install exe
17:54:09 <nand`> I'll use ‘Cabal’ from now on
17:56:42 <NihilistDandy> Anyone played around with fay? I've been looking for a usable alternative to js, and coffeescript just doesn't cut it.
17:56:55 <monochrom> anyway getting 260 packages installed consistently is a formidable accomplishment :)
17:57:25 <nand`> eix -I dev-haskell/*  ==> Found 228 matches. :)
17:57:32 <nand`> and that's just libraries
17:57:35 <monochrom> but yes Setup defaults to --global so it didn't even see your user libs
17:58:04 <nand`> I don't have any user libs; except for the one I just installed. I deleted that now. So now I have none.
17:58:22 <NihilistDandy> Yeesh, hope nothing ever breaks
17:58:55 <NihilistDandy> Nuking .cabal hurts enough as it is.
17:59:25 <nand`> nothing has ever broken for me, despite wanton upgrading whenever a newer version of a package comes out. I feel left out :(
18:00:03 <NihilistDandy> I was just thrilled when yesod didn't burn down my package list like it used to. :D
18:00:03 <monochrom> you are not left out. I think 99% of user problems are due to wanton upgrades
18:00:49 * ddarius only does wonton upgrades.
18:01:06 <NihilistDandy> Pork to beef?
18:02:50 <pharaun> NihilistDandy: yesod loves to burn down my packages
18:03:36 <NihilistDandy> wontonUpgrade :: (Pork a, Beef b) => Wonton a -> Wonton b
18:04:36 <NihilistDandy> pharaun: Yeah, it used to kill me without cabal-dev even with a clean install. Either my basic package needs have stabilized along with Yesod, or enough dependencies are sensible now that it doesn't hurt too much
18:05:31 <pharaun> NihilistDandy: yeah i've done a few upgrades since and its getting better :)
18:05:53 <pharaun> but it still takes some work to get it all happy from time to time but eh
18:07:06 <JoeyA> It'd be cool if GHCi supported interactive case matching.
18:07:07 <nand`> speaking of which, time to wanton upgrade
18:08:02 <bio44> *jumps in* .... As a new haskeller, I'm trying to figure out practicalities like dependency management... if I download some old code but it only compiles with an old version of something, do I use cabal-devel to set up its own enviroment?
18:08:12 <JoeyA> So you say case, and it prints the case that matched and variables that were bound.
18:08:50 <NihilistDandy> bio44: That's a pretty safe option. It depends if it's likely to break anything, in your estimation
18:08:55 <NihilistDandy> cabal install --dry-run is a great tool
18:08:58 <JoeyA> I would just try to fix the package.
18:09:10 <JoeyA> (unless it proves to be nontrivial)
18:09:34 <bio44> gotta. i'll play around with those options
18:09:37 <bio44> gotcha, i mean
18:10:18 <NihilistDandy> Unless the code (or dependency list) is huge, you're probably safe without cabal-dev. Definitely install with --user, though. Much easier to clean out.
18:11:09 <bio44> Hrm. I'm thinking I need a good cabal tutorial/guide. I'll start googling.
18:12:10 <JoeyA> Here's an idea for a GHCi feature:
18:12:14 <JoeyA> > ? Left 3
18:12:15 <lambdabot>   <no location info>: parse error on input `?'
18:12:38 <Veinor> what would it do?
18:12:44 <JoeyA> Then it prompts you to give the variable name for the matched case.
18:12:59 <JoeyA> Just a minor convenience.
18:12:59 <Veinor> ... ?
18:13:04 <nand`> I don't understand
18:13:12 <JoeyA> I'm not sure what it would look like.
18:13:31 <JoeyA> Here's my scenario.  I have prepare :: Database -> Query -> IO (Either Error Statement)
18:14:07 <JoeyA> If I just say: prepare conn "SELECT * FROM foo" and it returns a Right, I have no way of using the result in subsequent code, without having to re-run the command.
18:14:25 <nand`> let Right x = it
18:14:31 <JoeyA> If I know in advance it should succeed, I could just use a monad guard: Right stmt <- prepare conn "SELECT * FROM foo"
18:14:39 <JoeyA> But if it fails, I get a useless pattern match failure.
18:14:45 <JoeyA> Ah, it.
18:14:53 <JoeyA> nand`: Thanks!
18:14:57 <nand`> :)
18:15:10 <nand`> ‘it’ is useful when playing around with dangerous side effects
18:15:18 <Veinor> yes, it is
18:15:20 <Veinor> :D
18:15:36 <latro`a> isn't "it" only a thing in ghci?
18:15:41 <Veinor> well yeah
18:15:48 <nand`> latro`a: that's the point
18:15:54 <nand`> latro`a: this was about playing around in GHCi
18:15:54 <NihilistDandy> > 1; (<3) it
18:15:56 <lambdabot>   <no location info>: parse error on input `;'
18:15:58 <latro`a> ah
18:16:03 <NihilistDandy> > 1
18:16:04 <lambdabot>   1
18:16:08 <NihilistDandy> > (<3) it
18:16:09 <lambdabot>   Not in scope: `it'
18:16:12 <JoeyA> There should be an interleaved IO contest.  Whoever has the most effectful interleaved computation wins.
18:16:14 <NihilistDandy> Aww, mueval
18:16:14 <nand`> NihilistDandy: ‘> ’ doesn't use GHCi
18:16:25 <JoeyA> e.g. a `seq` () initiates a fireworks display.
18:16:27 <NihilistDandy> nand`: Yeah, I know. I just didn't know if mueval had `it`
18:16:44 <nand`> JoeyA: unsafePerformIO launchMissiles
18:17:05 <JoeyA> I wonder if the USB missile launcher has an API: http://www.thinkgeek.com/product/8a0f/
18:17:12 <nand`> NihilistDandy: mueval works on a strictly expression-by-expression basis afaik
18:17:25 <JoeyA> Then I could update Acme.Missiles to be an FFI binding to that.
18:17:30 <nand`> JoeyA: yes, my thoughts exactly
18:17:43 <nand`> and demonstrate the dangers of implicit side effects
18:17:46 <nand`> hands-on
18:17:51 <nand`> great for class presentations
18:17:55 <JoeyA> :D
18:18:09 <NihilistDandy> Great for getting tenure, too
18:19:02 <nand`> http://bpaste.net/show/40973/ hooray for wanton updates
18:19:11 <Veinor> JoeyA: haha
18:19:38 <NihilistDandy> getTenure >> launchMissiles
18:20:00 <nand`> that's completely safe; getTenure is nonterminating
18:20:18 <NihilistDandy> haha
18:20:34 <gautamc> hi, I've recently started to learn haskell. I see that, " let myCons thing list = thing:list " works fine when I type it directly into ghci. However, if I save it into a file and load it via: :load myCons.hs ghci says: parse error (possibly incorrect indentation) ... is there something i am doing wrong?
18:20:55 <nand`> gautamc: that's not valid Haskell
18:21:04 <JoeyA> Bah, C# has missile-launching capabilities: http://christianspecht.de/missilesharp/
18:21:08 <JoeyA> Haskell needs to get with the times.
18:21:09 <nand`> well, it's not a valid expression or top-level statement
18:21:34 <gautamc> ok
18:21:48 <nand`> gautamc: GHCi does some special tricks to allow for assignment (sort of like being in a do-block at the top level, but not really (you still can't define instances or data types in a do block, for example))
18:21:58 <nand`> gautamc: the easiest way to fix that is probably to just get rid of the ‘let’
18:22:00 <NihilistDandy> gautamc: Did you remove the let?
18:22:04 <Veinor> ... wait, what the hell does Acme.RealWorld do?
18:22:10 <joshcheek> How do I say that my function takes a parameter which is both an instance of Num and an instance of Show?
18:22:20 <nand`> Veinor: let's you pass around the RealWorld. What did you think it does?
18:22:32 <nand`> joshcheek: :: (Num a, Show a) => a -> ...
18:22:53 <n00b6502> is RealWorld an alternative way of doing io
18:23:01 <Veinor> RealWorld is deep magic
18:23:09 <shachaf> n00b6502: No.
18:23:12 <nand`> n00b6502: I'm not sure how much the Acme package relates to it, but RealWorld is how GHC chooses to implement IO
18:23:23 <NihilistDandy> Haskell is the most powerful language precisely because it explicitly destroys the old world and creates a new one with the desired IO action already performed.
18:23:57 <nand`> NihilistDandy: except it doesn't, that's the thing about RealWorld
18:24:04 <joshcheek> nand`: When I do that, I get overlapping instances with another class that implements show (so I assume this is the disjunction of the types instead of the conjunction of them)
18:24:10 <NihilistDandy> I meant philosophically~
18:24:33 <latro`a> what the hell is acme in general
18:24:48 <nand`> joshcheek: I can't infer how you got that error from the context you gave me, but (Show a, Num a) is definitely a conjunction of constraints
18:24:56 <nand`> :t \x -> (show x, x + 1)
18:24:58 <lambdabot> forall a. (Num a) => a -> (String, a)
18:25:00 <nand`> oh
18:25:08 <JoeyA> latro`a: Joke modules.  I think Perl kinda kicked off the tradition:  http://search.cpan.org/~asavige/Acme-EyeDrops-1.60/lib/Acme/EyeDrops.pm
18:25:11 <nand`> Show a is a superclass of Num a
18:25:37 <NihilistDandy> print "Hello, world!" creates a universe where "Hello, world!" has been printed to the screen, and throws the old universe away. After all, what use does it have now? :D
18:25:41 <nand`> wait, lambdabot is just outdated
18:25:45 <nand`> joshcheek: what version of GHC are you on?
18:25:59 <joshcheek> nand`: 7.4.2
18:26:24 <JoeyA> Of course, the name "Acme" comes from the Road Runner cartoons: http://en.wikipedia.org/wiki/Acme_Corporation#Fictional_depiction
18:26:25 <hpaste> nand` pasted “(Show a, Num a)” at http://hpaste.org/73378
18:26:27 <JoeyA> ^ fun ead
18:26:30 <JoeyA> read*
18:26:31 <nand`> that's odd, I'm on 7.4.2 as well, see my paste ^
18:26:38 <nand`> (that's from GHCi)
18:27:26 <avpx> Can anyone recommend a good resource or some good resources on the typed lambda calculus (not sure if that's a reasonable phrase) and the connection to first-order logic?
18:27:52 <nand`> https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
18:28:06 <nand`> that might be what you're looking for
18:28:12 <ddarius> @wn acme
18:28:13 <JoeyA> avpx: Have you seen Wadler's talk Faith, Evolution, and Programming Languages?
18:28:13 <lambdabot> *** "acme" wn "WordNet (r) 3.0 (2006)"
18:28:14 <lambdabot> acme
18:28:14 <lambdabot>     n 1: the highest level or degree attainable; the highest stage
18:28:14 <lambdabot>          of development; "his landscapes were deemed the acme of
18:28:14 <lambdabot>          beauty"; "the artist's gifts are at their acme"; "at the
18:28:15 <nand`> I don't know if it's ‘good’, but it should be enough to find other references
18:28:15 <lambdabot> [9 @more lines]
18:28:18 <ssbr_> Is there a reason for the separate "elems" and "toList" functions for Data.Set ? both are O(n) and :: Set a -> [a]
18:28:36 <avpx> nand`: I don't learn very well from these sorts of Wikipedia articles :-\
18:29:02 <ddarius> avpx: To connect directly to first order logic, you'd need a dependently typed lambda calculus.
18:29:09 <JoeyA> (Wadler gave that talk at least twice, once in 2007, and again a few weeks ago: http://www.infoq.com/presentations/Faith-Evolution-Programming-Languages )
18:29:48 <avpx> JoeyA: I haven't seen that, but I will definitely watch
18:31:47 <NihilistDandy> ssbr_: elems = toList
18:32:07 <NihilistDandy> and toList = toAscList
18:32:10 <ssbr_> NihilistDandy: Right, but what's the reason for the two names? They even have separate documentation
18:32:24 <ssbr_> as in, the documentation isn't a carbon copy
18:32:38 <JoeyA> The talk doesn't go deep into details, but it skims the surface.  It talks more about the history of the connection between functional programming and logic.
18:32:47 <joshcheek> nand`: Here is an example: https://gist.github.com/3390813
18:33:04 <ddarius> > 5000000 / 1023
18:33:04 <JoeyA> (and how it took people decades to notice such a simple notion)
18:33:06 <lambdabot>   4887.585532746823
18:33:26 <NihilistDandy> ssbr_: That's a good question. Convenience?
18:33:41 <pharaun> any way i can set the "from" port on an udp socket?
18:33:56 <NihilistDandy> ssbr_: The intent of the functions is different, even if their output is identical
18:34:18 <ddarius> pharaun: You make a packet that has the from port set.
18:34:39 <gautamc> @nand -- thnx. I understand what you mean (i think). - ghci does some "magic" which is why it worked. But in the real world, without the magic that expression i tried would be invalid (kind of like how perl sometimes automagically wraps things in a while (<>){} ...)
18:36:02 <lambdabot> parse error (possibly incorrect indentation)
18:36:05 <pharaun> ddarius: i'm trying to figure that out with - Network.Socket
18:36:06 <nand`> joshcheek: re: exporting; depends on what you want. If you want the user to be able to construct Addition, but *not* pattern match on it, you can go with your method - but if the user should be able to pattern match too you'd just export the constructor itself. Note that you probably want to export the Addition type as well
18:36:12 <nand`> gautamc: well, it's not really that much magic - it's just that GHCi is supposed to be a REPL so you should be able to assign and reassign stuff eg. as you fix bugs, something that Haskell doesn't allow - but it's conceptually not too dissimilar from a regular old do block in Haskell
18:36:33 <nand`> gautamc: it's important to see that distinction - Haskell (source) is for developing programs/libraries that exist in one coherent state; GHCi is for REPL debugging/developing
18:37:07 <joshcheek> nand`: Sorry, that was just a comment for me to come back to later when I learn more. I'm mostly interested in why the compiler fails on line 24 (I had previously implemented it with the commented functions on 14-22, but figured if I could specify `(Show a, Num a)` then I wouldn't have to do that, but when I do this, I get the error shown in the readme)
18:37:28 <nand`> joshcheek: I'm still looking at that
18:37:33 <Tekmo> joshcheek
18:37:39 <NihilistDandy> I'm just kind of amazed that the REPL works as well as it does in ST2
18:37:41 <Tekmo> The reason it fails is because of how instance resolution works
18:37:48 <nand`> oh, right
18:37:50 <Brad_> Brad
18:37:55 <Tekmo> Instance resolution doesn't use the constraints to determine resolution
18:38:00 <Tekmo> So when you write something like
18:38:09 <nand`> yeah what Tekmo said is right
18:38:11 <Tekmo> instance (Constraint1 a, Constraint2 a) => SomeClass a
18:38:16 <Tekmo> It matches everything
18:38:21 <nand`> joshcheek: the reason it fails is because ‘a’ and ‘Addition a b’ overlap in what they match
18:38:23 <Tekmo> regardless of whether that satisfies the constraints
18:38:51 <nand`> joshcheek: there are two ways to resolve this: 1. create a newtype, and define the ‘a’ instance for that newtype only; 2. use -XOverlappingInstances if that's really what you want
18:38:55 <Tekmo> I know it's pretty lame
18:39:01 <Tekmo> There's some reason for it, but I forgot what it is
18:39:21 <Tekmo> Perhaps somebody more experienced can explain the rationale better than I can
18:40:27 <nand`> joshcheek: eg something like newtype Literal a = Literal a; instance (Num a, Show a) => MathML (Literal a) where ...
18:41:57 <latro`a> is there a theoretical reason why instance matching has to work the way it does?
18:42:09 <latro`a> like, if you don't apply that restriction the type system is automatically turing complete or something
18:42:36 <Tekmo> Well, I think the problem is that the resolution is not well defined
18:42:40 <Tekmo> Consider this
18:42:42 <gautamc> @nand.. hmm. makes perfect sense .. i think i finally "see the light"
18:42:43 <Tekmo> imagine you had
18:42:43 <lambdabot> Unknown command, try @list
18:42:52 <Tekmo> instance (Show a) => SomeClass a where
18:42:55 <Tekmo> and then some other instance
18:43:02 <Tekmo> instance (Num a) => SomeClass a where
18:43:27 <Tekmo> How would the compiler know if those overlap?
18:43:50 <Tekmo> By matching purely on the type and not the constraints, the instance resolution is straightforward
18:44:34 <latro`a> ah, that one is clearer
18:45:15 <Tekmo> I usually use one of two solutions when I encounter this problem
18:45:49 <Tekmo> Either use the newtype solution that others have proposed
18:45:58 <Tekmo> Or instead switch to a dictionary
18:46:04 <Tekmo> instead of a type-class
18:46:15 <Tekmo> However, turning on OverlappingInstances will not solve his problem
18:46:40 <Tekmo> In this case his instances do overlap and the compiler will not be able to resolve them even with the extension
18:47:00 <Tekmo> It's more for cases where instances MIGHT overlap like the example I gave, but the programmer is certain they won't
18:47:19 <Tekmo> So, using my example, if you knew for sure that there was no type that implemented both Num and Show
18:47:45 <Tekmo> Then you could tell the compiler "look, it's ok, these are fine, just proceed"
18:49:01 <ddarius> pharaun: It looks like you'd bind the socket to the local port, which should specify the from port, and then, the natural thing would be to use sendTo with the remote port.
18:49:06 <nand`> Tekmo: no, -XOverlappingInstances would resolve his case
18:49:21 <nand`> Tekmo: OverlappingInstances isn't just a ‘compiler blind eye’ flag, it actually merges the instances together
18:49:40 <nand`> specifically by using the one it considers ‘less general’ whenever it can, and the more general one otherwise
18:49:51 <Tekmo> Interesting
18:49:59 <Tekmo> Perhaps I misconstrued it, then
18:52:05 <nand`> Tekmo: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/type-class-extensions.html#instance-overlap
18:52:06 <nand`> for more info
18:52:45 * ddarius needs to make pipes that support a constant rate of data.
18:53:10 <n00b6502> can haskell use C for pure code e.g. where the C conforms to reading one datastructure and filling another
18:53:20 <Tekmo> Yes
18:53:30 <Tekmo> When you do an FFI declaration to import C code
18:53:39 <Tekmo> There is a way to import the C function as a pure function
18:53:40 <n00b6502> so thats like C plugin nodes to haskells dependancy-graph execution system.
18:53:46 <pharaun> ddarius: ahh i see! doh me, thanks :)
18:53:59 <luite> that's not allowed by safehaskell though
18:54:15 <nand`> n00b6502: unsafePerformIO exists for exactly these kinds of situations; where you're sure the external code will run in deterministic fashion and free of side effects
18:54:16 <n00b6502> i suspect there are serious limitations r.e. what type of structures you can use.. r.e. garbagecollector
18:54:28 <joshcheek> Tekmo: Can you give me a link to an example of using a dictionary to solve a problem like this?
18:54:47 <n00b6502> i mean a well structured C program will have a well defined concept of dataflow.
18:55:35 <n00b6502> i find myself wanting the opposite of 'const' in c now, a write-only pointer (as opposed to read-write default)
18:56:03 <MostAwesomeDude> Hey, is there an easy way to tell Haskell to default a numeric literal according to its constraints?
18:56:12 <nand`> n00b6502: wouldn't you usually use return values for ‘write-once-only’ stuff?
18:56:29 <n00b6502> fill out datastructures is very commmon
18:56:30 <MostAwesomeDude> I'm using literals in some GL code and want Haskell to just default them to bytes or floats or whatever's smallest.
18:56:57 <hpc> > 0 :: Word8
18:56:58 <lambdabot>   0
18:57:03 <hpc> > 256 :: Word8
18:57:04 <lambdabot>   0
18:57:07 <hpc> like that?
18:57:16 <MostAwesomeDude> Yeah, but more automatically.
18:57:19 <n00b6502> although C++0x is much better at using return values with rvalue-references
18:57:23 <ddarius> MostAwesomeDude: Not really.  The defaulting mechanism only works with standard classes.  You can specify a different order and presumably it will only choose the Fractional types when appropriate, but otherwise you have little control.
18:57:26 <n00b6502> c++11 sorry
18:57:40 <nand`> I'm not sure but there might be some PRAGMA for this. Right now, it only works for Integer and Double and for certain classes only
18:57:45 <MostAwesomeDude> Aw. Okay.
18:57:50 <nand`> I didn't need to capitalize pragma there
18:57:54 <ddarius> MostAwesomeDude: Oh, you want 1000 to be Word16 and 10 to be Word8?
18:58:18 <ddarius> nand`: It's not a pragma; it's part of the language.
18:58:20 <nand`> I thought this would be about defaulting to GLint or whatever
18:59:12 <MostAwesomeDude> ddarius: I wanted it to figure out that (Vertex2 0.25 0.25) should use Floats.
18:59:31 <MostAwesomeDude> But it's no biggie. I just defined type Vertex2f = Vertex2 GLfloat
18:59:40 <ddarius> Okay, then add default (GLint, GLfloat) or whatever, though I'd highly recommend against that.
18:59:56 <ddarius> Yes, that solution is much better.
19:00:24 <ddarius> Also, as I said earlier, the defaulting mechanism won't kick in if there are any non-standard classes.
19:01:39 <MostAwesomeDude> It's just like I'm writing GL in C!
19:01:39 <nand`> low level bindings tend to have that effect
19:01:40 <nand`> especially to highly imperative stuff like OpenGL
19:01:57 <MostAwesomeDude> Actually, I really dig the GL combinators. They're pretty snazzy.
19:02:08 <MostAwesomeDude> And they don't have their own GL monad, so I can just do things in IO.
19:02:21 <n00b6502> i was about to say gl monad..
19:02:35 <n00b6502> but graphics in pure functional is an interesting idea
19:02:45 <n00b6502> pixel and vertex shaders are very functional
19:03:07 <ddarius> GPU processing in general tends to be highly functional
19:03:17 <n00b6502> hardware 'map' :)
19:03:22 <hpc> see also, GPipe
19:03:29 * geekosaur will try to decipher frp someday...
19:03:31 <nand`> n00b6502: you might be int-- yeah, GPipe
19:03:35 <nand`> n00b6502: you also might be interested in gloss
19:03:51 <nand`> geekosaur: I've recently given up and started looking at arrows instead
19:03:57 <n00b6502> i would like to see graphics as functional as possible
19:04:07 <geekosaur> arrows still hurt my head
19:04:24 <nand`> n00b6502: Gloss is for when you want to get some 2d vector graphics running as quickly as possible without concerning yourself with the implementation
19:04:26 <nand`> n00b6502: it's very nice
19:04:32 <Tekmo> Gloss is great
19:05:03 <latro`a> I have trouble with the analogies
19:05:09 <nand`> n00b6502: basically, the main function for drawing an animated vector is something like :: a -> (a -> Picture) -> (Float -> a -> a) -> IO ()
19:05:10 <latro`a> in some of the explanations of FRP
19:05:35 <nand`> n00b6502: corresponding to ‘initial state’, ‘drawing function’ and ‘update function’ (where the Float represents passed time in seconds since the last update)
19:06:00 <latro`a> I have trouble with them in mathematics too
19:06:00 <n00b6502> ah i see
19:06:09 <n00b6502> render and update pattern
19:06:29 <n00b6502> well known to imperative gfx coders but i bet it can parallelize behind the scenes.
19:07:21 <Tekmo> The best explanation of FRP I ever read was this one: http://stackoverflow.com/a/1028642/1026598
19:07:23 <ddarius> @hackage reactive-fieldtrip
19:07:23 <lambdabot> http://hackage.haskell.org/package/reactive-fieldtrip
19:07:28 <n00b6502> a lot of graphics tools are very functional conceptually e.g. animation constraints
19:07:39 <n00b6502> all those node chart editors
19:08:04 <nand`> n00b6502: basically, gloss has a few main functions that scale depending on what you want to write; the simplest is something like :: Picture -> IO () which just displays a static picture
19:08:06 <pharaun> ddarius: perfect, that did the trick, thanks
19:08:17 <n00b6502> nice
19:08:29 <nand`> and the most complicated one is something like :: a -> (a -> Picture) -> (Float -> a -> a) -> (Event -> a -> a) -> IO ()
19:08:30 <Tekmo> noob6502, do you know about Brent Yorgey's Diagrams library and paper?
19:08:35 <nand`> so you get an Event handler too (mouse, keyboard input) :)
19:08:41 <n00b6502> no i do not
19:08:49 <Tekmo> Well, it's not really real-time graphics
19:09:03 <Tekmo> But it's still great if you are thinking of functional metaphors for graphical concepts
19:09:07 <Tekmo> Let me find the paper
19:09:53 <nand`> n00b6502: (if you're interested, here's an example of a rather simple game written with gloss: https://github.com/ekmett/lens/blob/master/examples/Pong.hs )
19:09:54 <n00b6502> render:update on multicore suits double-buffered state sometimes
19:10:18 <n00b6502> ok edwardk himself point me at that r.e. lenses
19:11:01 <Tekmo> http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
19:12:05 <n00b6502> i like the idea of pure functional world update  eg new frame= update(oldframe, inputs) as opposed to emulating stateful modification
19:12:39 <ddarius> @google site:hackage.haskell.org circular buffer
19:12:43 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler
19:12:43 <lambdabot> Title: Commentary/Rts/Scheduler – GHC
19:12:44 <nand`> I think this approach carries a certain elegance as opposed to eg. a monad-based solution to input
19:13:14 <ddarius> @google site:hackage.haskell.org inurl:package circular buffer
19:13:16 <lambdabot> No Result Found.
19:13:18 <FreeFull> So I'm trying to write a prime sieve
19:14:31 <FreeFull> primesieve (y:ys) = y : primesieve (filter (\z -> (z `mod` y) /= 0) ys)
19:14:55 <ddarius> Hmm, maybe I just use an array of (T)MVars and an integer mod the size...
19:15:14 <nand`> (isn't rem faster than mod for positive integers)
19:15:24 <ddarius> nand`: Yes it is.
19:15:26 <Tekmo> I believe so
19:15:43 <Tekmo> You know what this channel could use
19:15:47 <Tekmo> A criterion bot
19:16:20 * nand` .oO( @check \x y -> speed (x `mod` y) > speed (x `rem` y) )
19:16:48 <Hail_Spacecake> how do you specify multiple bound variables in a let expression?
19:17:01 <nand`> > let a = 5; b = 3 in a+b
19:17:02 <lambdabot>   8
19:17:03 <FreeFull> I'm getting     No instance for (Integral a)
19:17:04 <Hail_Spacecake> or rather, where is the syntax  documentation for that?
19:17:18 <Hail_Spacecake> becuase I'm also confused on exactly how identing in let expressions works
19:17:24 <NihilistDandy> > let x = 5 in let y = 4 in let x + y
19:17:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:17:30 <FreeFull> And then two similar errors, except (Eq a) and (Num a)
19:17:30 <nand`> Hail_Spacecake: http://www.haskell.org/onlinereport/exps.html#sect3.12
19:17:30 <Hail_Spacecake> is let a = 5; b=3; in ... legal?
19:17:39 <nand`> there's the syntax documentation for let expressions
19:17:45 <nand`> Hail_Spacecake: I don't think so
19:17:49 <tgeeky> > let a = 5; b = 3 in a + b
19:17:50 <lambdabot>   8
19:17:53 <nand`> > let a = 5; b = 3; in a + b
19:17:54 <lambdabot>   8
19:17:57 <nand`> it is
19:18:05 * tgeeky arrests nand for typing that
19:18:09 <tgeeky> ILLEGAL!
19:18:18 <nand`> tgeeky: I was just testing what Hail_Spacecake asked
19:18:18 <ddarius> Tekmo: Feel free to create a lambdabot plugin.
19:18:41 <NihilistDandy> derp, added one too many lets
19:18:42 <tgeeky> nand`: yes, and that Russian band was just pointing out the corruption and hypocracy of the Russian Orthodox Church.
19:18:43 <NihilistDandy> >let x = 5 in let y = 4 in x + y
19:18:45 <ddarius> Though all we'd really need to do is import the appropriate functions in eval.
19:18:45 <tgeeky> Still in jail.
19:18:49 <Tekmo> Yeah, I might try that sometime
19:18:54 <shachaf> Since when is Tekmo in #haskell?
19:18:58 <Tekmo> lol
19:19:11 <Tekmo> I come here when I have free time
19:19:23 <shachaf> That's how it starts.
19:19:30 <Tekmo> :)
19:19:42 <Tekmo> #haskell, not even once!
19:19:49 <nand`> s/#//
19:19:57 <Tekmo> lol
19:20:08 <Hail_Spacecake> so, if you use the indenting syntax
19:20:16 <Hail_Spacecake> it seems like you don't have to use semicolons
19:20:21 <nand`> Hail_Spacecake: correct
19:20:28 <Hail_Spacecake> but, I don't know if you can, or if it's a syntax error
19:20:35 <nand`> Hail_Spacecake: the preprocessor inserts { ; } as needed based on indenting before parsing it proper
19:20:39 <nand`> you still can
19:21:38 <nand`> (well, I'm not sure if the terms ‘preprocessor’ ‘parsing’ are accurate here. But the Haskell report describes the semantics of inserting { ; } automatically)
19:21:39 <Hail_Spacecake> so indentation is irrelevant for "pure" haskell I suppose? i'ts just something hte preprocessor converts for you?
19:21:52 <nand`> syntax is irrelevant for “pure” haskell
19:22:04 <ddarius> Hail_Spacecake: Indentation is part of the syntax of Haskell.
19:22:14 <nand`> at the “core” of Haskell are the expression trees and the type system
19:22:27 <nand`> but as ddarius said, for actual Haskell (as in the language definition), syntax and indenting play a role
19:25:09 <Tekmo> FreeFull, are you still there?
19:25:24 <FreeFull> Yes
19:25:38 <Tekmo> Have you tried annotating your primesieve with a type signature?
19:25:46 <FreeFull> I have
19:25:56 <FreeFull> Let me pastebin the full error, and the code
19:26:02 <Tekmo> Use hpaste
19:26:07 <Tekmo> it has an option
19:26:11 <Tekmo> to autocopy the link to this channel
19:26:22 <Tekmo> http://hpaste.org/
19:27:22 <hpaste> FreeFull pasted “Prime sieve” at http://hpaste.org/73380
19:27:40 <latro`a> type signature is too general
19:27:51 <Tekmo> Oh
19:27:54 <Tekmo> There is your problem
19:27:57 <Tekmo> Your type signature was wrong
19:27:58 <latro`a> you need to require a to be Integral, Eq, and Num
19:28:02 <latro`a> which is exactly what the errors say
19:28:04 <Tekmo> You can either omit the signature
19:28:11 <latro`a> if you omit the signature the correct type will be inferred
19:28:19 <latro`a> but if you want the signature, it needs to be
19:28:33 <latro`a> (Integral a,Eq a,Num a) => [a] -> [a]
19:28:38 <Tekmo> Or you can specialize the signature to [Integer] -> [Integer] for convenience
19:28:40 <latro`a> or else something more specific, like [Int]->[Int]
19:28:47 <NihilistDandy> Don't you only need Integral a?
19:28:50 <latro`a> no
19:28:58 <latro`a> though I think you can omit Num
19:29:00 <FreeFull> Thanks
19:29:02 <latro`a> as I think Integral forces Num
19:29:10 <latro`a> it doesn't force Eq, though
19:29:20 <Tekmo> How would you query lambdabot for that?
19:29:26 <latro`a> try writing
19:29:32 <NihilistDandy> ghci spits primesieve :: Integral a => [a] -> [a]
19:29:32 <FreeFull> I'll try [Integer]->[Integer]
19:29:34 <latro`a> foo :: Integral a => a -> a -> a
19:29:37 <latro`a> foo x y = x+y
19:29:41 <latro`a> and see if it compiles
19:29:49 <latro`a> if it does then you don't need to specify Num
19:29:50 <NihilistDandy> @let primesieve (y:ys) = y : primesieve (filter (\z -> (z `mod` y) /= 0) ys)
19:29:52 <lambdabot>  Defined.
19:29:53 <NihilistDandy> :t primesieve
19:29:55 <lambdabot> forall a. (Integral a) => [a] -> [a]
19:29:59 <Tekmo> Nice
19:30:00 <latro`a> that is because lambdabot is old
19:30:06 <latro`a> you'll need Eq now
19:30:09 <latro`a> (this is a fairly recent change)
19:30:10 <FreeFull> I'll just omit the type definition and then check what :t says
19:30:12 <NihilistDandy> Is my 7.4.1 ghci old, too?
19:30:13 <NihilistDandy> Damn
19:30:18 <latro`a> it is not, no
19:30:35 <NihilistDandy> I get the same result from ghci, hence my confusion
19:30:43 <FreeFull> Yeah, :t says primesieve :: Integral a => [a] -> [a]
19:31:23 <Tekmo> According to 7.4.1
19:31:27 <Tekmo> Ord still brings in Eq
19:31:46 <FreeFull> I have 7.4.2
19:31:55 <NihilistDandy> class (Real a, Enum a) => Integral a where, and class (Num a, Ord a) => Real a where
19:33:49 <NihilistDandy> FreeFull: That said, you still need a base case
19:36:13 <shachaf> So given "class Read a where read :: String -> a" and "class Show a where show :: a -> String", you can make "data ShowVal = forall a. Show a => ShowVal a" and "data ReadVal = ReadVal (forall a. Read a => a)", respectively.
19:36:22 <shachaf> One is existential and the other is universal.
19:36:24 <FreeFull> My prime sieve appears to work
19:36:33 <FreeFull> Prints out an infinite list of primes when I run it
19:36:47 <shachaf> If you had class ReadShow a with both methods, would it make any sense to talk about about a "ReadShowVal"?
19:37:31 <nand`> FreeFull: what he means is that primeSieve [] will result in a runtime error
19:38:14 <nand`> (you could hide it in a local definition though; eg. primes :: Integral a => [a]; primes = primeSieve [2..] where primeSieve ...
19:38:26 <nand`> that way nobody would be able to run primeSieve []
19:38:26 <Tekmo> Or you can use Stream
19:38:27 <NihilistDandy> ^ That'd be my approach
19:38:42 <nand`> yeah Stream would be ideal
19:38:55 <FreeFull> Let me look at Stream
19:38:59 <NihilistDandy> @hoogle Stream
19:38:59 <lambdabot> Network.HTTP.Stream module Network.HTTP.Stream
19:39:00 <lambdabot> Network.Stream module Network.Stream
19:39:00 <lambdabot> Network.StreamDebugger module Network.StreamDebugger
19:39:00 <Tekmo> http://hackage.haskell.org/package/Stream
19:39:21 <NihilistDandy> Oh, neat
19:39:23 <NihilistDandy> Didn't know about that one
19:43:58 <NihilistDandy> Is there much gain to using Stream over List? I'm not seeing a huge difference, though I don't know what that ~ notation is
19:44:15 <nand`> the basic difference is that Streams are infinite
19:44:28 <NihilistDandy> Oh, right
19:44:28 <nand`> which for your primeSieve to not error out they have to be
19:44:42 <NihilistDandy> No empty constructor
19:44:44 <Tekmo> The more you program in Haskell, the more you appreciate total functions
19:44:52 <n00b6502> whats a total function
19:44:53 <JoeyA> What happens when a Haskell function wrapped in a FunPtr throws an exception?
19:44:58 <shachaf> The more you program in Agda, the more you appreciate partial functions.
19:45:06 <nand`> shachaf: haha
19:45:07 <Tekmo> A total function is one that handles all cases
19:45:16 <Tekmo> So for example
19:45:18 <nand`> n00b6502: a total function is one that produces a result for every input
19:45:21 <Tekmo> head for lists is not total
19:45:26 <NihilistDandy> n00b6502: Converges on all inputs
19:45:27 <Tekmo> because it errors out on an empty list
19:45:30 <NihilistDandy> What they said
19:45:35 <shachaf> An infinite loop is also not total.
19:45:50 <n00b6502> ok so Maybe helps
19:46:07 <nand`> shachaf: is there a word for ‘total or ⊥’ ?
19:46:08 <Tekmo> Right
19:46:18 <shachaf> nand`: Thing?
19:46:30 <nand`> ‘error-free’ in Haskell I guess
19:46:36 <nand`> well, no
19:46:50 <aristid> shachaf: an infinite loop can be... productive is the word i think
19:47:05 <shachaf> aristid: By "infinite loop" I meant _|_
19:47:05 <Hail_Spacecake> so I have a pattern matching question
19:47:08 <shachaf> How could it be productive?
19:47:13 <Hail_Spacecake> I've defined a date type
19:47:18 <Hail_Spacecake> data Date = Date Month Day Year
19:47:23 <shachaf> I've got a question-asking question. But I think I'll save it for later.
19:47:25 <Hail_Spacecake> (where all of those are type'd integers)
19:47:30 <Tekmo> I think he means a coinductive type
19:47:31 <NihilistDandy> nand`: ⊤?
19:47:33 <aristid> shachaf: bottom is not productive, but not all infinite loops are _|_
19:47:44 <Hail_Spacecake> and I have a function where I'm already pattern-matching on internal components of the date
19:47:52 <shachaf> aristid: I think we're using a different meaning of "infinite loop", then.
19:47:53 <Hail_Spacecake> so functionDef (Date m d y) otherArgs = ...
19:48:00 <aristid> Tekmo: yes, i think that's what i mean
19:48:06 <shachaf> Hail_Spacecake: Don't do m d y! :-(
19:48:08 <Hail_Spacecake> and I want to call another function that takes a Date type within that function
19:48:10 <Hail_Spacecake> shachaf, why not?
19:48:11 <nand`> for all intents and purposes, ⊥ means ‘undefined’ - so shachaf's statement is like saying undefined things are not total
19:48:17 <ion> % unicode middle finger
19:48:19 <ion> %
19:48:23 <ion> Aww, that would have been a cooler ⊥.
19:48:26 <Tekmo> date@(Date m d y)
19:48:30 <Tekmo> That lets you reuse the whole variable
19:48:31 <shachaf> Because that order is evil. Do y m d. This has nothing to do with your question, but still.
19:48:33 <aristid> nand`: indeed, undefined things are not total
19:48:41 <Hail_Spacecake> shachaf, eh, I'm an american
19:48:47 <shachaf> Hail_Spacecake: So am I.
19:48:50 <Hail_Spacecake> I say august 18th 2012
19:48:56 <NihilistDandy> UTC is UTC for a reason
19:49:02 <aristid> Hail_Spacecake: your haskell doesn't need to talk like you
19:49:02 <shachaf> You can define a Show instance that works that way.
19:49:07 <ion> I’m sure Africans can think logically about date formats.
19:49:36 <shachaf> Also, you might want to define actual Month etc. instead of Int. :-) But that's also off-topic.
19:50:02 <Hail_Spacecake> Tekmo, ah, okay
19:50:04 <otters> @pl \x -> (x `div` 2) == 0
19:50:05 <lambdabot> (0 ==) . (`div` 2)
19:50:24 <Hail_Spacecake> is it syntactically ill-formed to reuse (Date m d y) in the function I'm calling within the first function?
19:50:33 <Hail_Spacecake> I realize the @-syntax is better
19:50:37 <Tekmo> No
19:50:38 <Hail_Spacecake> I'm just curious
19:50:39 <shachaf> Hail_Spacecake: GHC can tell you about what's syntactically ill-formed.
19:50:39 <Tekmo> That's legitimate
19:50:49 <Tekmo> There is a possibility that it might be inefficient
19:50:49 <shachaf> Hail_Spacecake: That's one of the best way to figure something out.
19:51:01 <Tekmo> Using the @ syntax makes it likely the variable is reused rather than rebuilding it
19:51:08 <Hail_Spacecake> shachaf, yeah but I don't have a compilable program right now
19:51:10 <ion> We write all groups of numbers and also the digits within a number with the most-significant part first. Except that dates get a weird middle-endian format.
19:51:12 * shachaf would hope that GHC would do CSE to produce @-patterns.
19:51:20 <Hail_Spacecake> and ghci works subtly different sometimes
19:51:20 <shachaf> Hail_Spacecake: OK, but you can still type it into ghci. :-)
19:51:23 <Hail_Spacecake> in ways that I don't understand yet
19:51:33 <Tekmo> This is where a criterion bot would help!
19:51:37 <Hail_Spacecake> criterion?
19:51:46 <Tekmo> so we can benchmark things on the spot
19:51:46 <Tekmo> Here
19:51:47 <shachaf> Tekmo: A criterion bot on lispy's poor VPS?
19:51:51 <Tekmo> I'm going to benchmark it myself
19:51:53 <Tekmo> Give me a second
19:52:04 <shachaf> This is the sort of thing that's tricky to microbenchmark.
19:53:05 <ion> Perhaps we can create an experiment that uses the tiny effect to e.g. kill a cat in real life, so we have something we can measure easily.
19:53:25 <shachaf> @slap ion
19:53:26 * lambdabot jabs ion with a C pointer
19:53:51 <nand`> unsafeCriterion
19:57:01 <mysticc> Does cabal build also installs the dependencies ?
19:57:39 <parcs`> benchmarking bytecode
19:58:03 <Hail_Spacecake> okay, so, I'm creating an algebraic data type for days of the week
19:58:13 <Hail_Spacecake> data DayOfWeek = Monday | Tuesday | Wednesday etc.
19:58:29 <Hail_Spacecake> and I wnat to easily be able to convert an integer from 0 to 6 to a DayOfWeek
19:58:37 <Tekmo> deriving (Enum)
19:58:39 <Hail_Spacecake> and I could write that function myself, but I wonder if there's an easier way to get that behavior
19:59:07 <NihilistDandy> What Tekmo said
19:59:39 <Hail_Spacecake> so once DayOfWeek is an Enum type, what do I do to a literal integer to make it a DayOfWeek in the type system?
19:59:55 <ben> @type (fromEnum, toEnum)
19:59:56 <shachaf> Tekmo: GHC doesn't CSE it. :-(
19:59:57 <lambdabot> forall a a1. (Enum a, Enum a1) => (a -> Int, Int -> a1)
20:00:04 <Tekmo> Damn!
20:00:09 <Tekmo> I was just installing criterion
20:00:26 <shachaf> I didn't use criterion.
20:00:31 <Tekmo> How do you check?
20:00:40 <shachaf> Old-school, with "time ./program"
20:00:42 <Tekmo> lol
20:00:57 <shachaf> But the difference is obvious.
20:01:01 <Hail_Spacecake> ben, I don't understand the @type syntax
20:01:18 <Tekmo> What was the rough slowdown?
20:01:29 <Tekmo> @type fromEnum
20:01:30 <lambdabot> forall a. (Enum a) => a -> Int
20:01:34 <ben> Hail_Spacecake: That was obtuse of me, sorry, just try the fromEnum/toEnum functions
20:01:36 <Tekmo> @type toEnum
20:01:37 <lambdabot> forall a. (Enum a) => Int -> a
20:01:40 <Tekmo> There
20:01:43 <Tekmo> You want toEnum
20:01:46 <adnauseam> ragusa: excellent! i will give this a good read
20:01:49 <Hail_Spacecake> what does @type mean?
20:01:56 <Tekmo> It is like :t in ghci
20:01:56 <ben> It's for the bot
20:02:01 <ben> It's not a haskell thing
20:02:04 <ddarius> Either I'm missing something, or this "FFT" code is really just an N^2 DFT.
20:02:05 <Tekmo> The lambdabot interprets it
20:02:09 <ddarius> Written in a silly way.
20:02:40 <shachaf> Tekmo: Try it out: http://slbkbs.org/v.hs.txt
20:03:11 <otters> is it possible to recursively define a list of prime numbers?
20:03:22 <otters> "this is a list of numbers wherein none of the numbers has any factors in the list"
20:03:45 <nand`> I think the answer is yes
20:04:00 <nand`> due to the rate of primes growing faster than the rate of factors you need to check against, something like that
20:04:01 <otters> I just tried it and my brain exploded
20:04:06 <otters> hmmm
20:04:06 <nand`> but I could be entirely wrong
20:04:09 <otters> maybe I can check < sqrt x
20:04:12 <otters> that's probably what I need to do
20:04:20 <Hail_Spacecake> how do I specify what concrete type toEnum expects in ghci?
20:04:25 <Hail_Spacecake> just to try it
20:04:31 <shachaf> ::
20:04:32 <nand`> > toEnum 1 :: Bool
20:04:34 <lambdabot>   True
20:04:38 <NihilistDandy> Now can you do it at the type level?
20:04:46 <Tekmo> toEnum 0 :: Date
20:04:48 <Hail_Spacecake> oh I didn't know you could use :: outside of defining a function
20:04:53 <Tekmo> Oh yeah
20:04:57 <NihilistDandy> All I want is data Prime = ...
20:04:59 <nand`> you can use it anywhere in an expression
20:05:02 <Tekmo> This helps sometimes when the instance is ambiguous
20:05:06 <nand`> > (0 :: Int) + (0 :: Float)
20:05:07 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:05:08 <lambdabot>         against inferred type ...
20:05:23 <shachaf> Tekmo: go2 is ~twice as fast as go1 here.
20:05:30 <Tekmo> Yeah
20:05:31 <Tekmo> I checked it
20:05:36 <Tekmo> I got almost a factor of 2 on my machine
20:05:39 <shachaf> It's not really strictly CSE, I suppose.
20:05:44 <Tekmo> Of course, this is while criterion is compiling in the background
20:05:46 <shachaf> But I thought GHC would do it. :-(
20:05:56 <shachaf> Hah, good luck with that.
20:06:02 <shachaf> That's a big package.
20:06:10 <shachaf> (Actually maybe its dependency is big? I don't remember.)
20:06:10 <Tekmo> Yeah
20:06:12 <nand`> on a multi-core system it might not matter
20:06:14 <Tekmo> Yes,
20:06:19 <Tekmo> huge dependency list
20:06:22 <otters> how do I convert a Num to a Floating?
20:06:24 <otters> hoogle tells me nothing
20:06:37 <nand`> (doesn't cabal only ever compile on one CPU core?)
20:06:44 <ddarius> GHC tends to avoid CSE.
20:06:58 <Tekmo> Oh
20:07:04 <Tekmo> A Floating is already an instance of Num
20:07:07 <NihilistDandy> ^
20:07:11 <NihilistDandy> Beat me to it again, Tekmo
20:07:14 <Tekmo> lol
20:07:23 <shachaf> Tekmo: otters asked in the other direction, though.
20:07:24 <nand`> otters: in general, that's not possible
20:07:31 <Tekmo> Oh
20:07:33 <shachaf> Oh, wait.
20:07:36 <shachaf> Yes.
20:07:39 <Tekmo> maybe you can
20:07:39 <Tekmo> hold on
20:07:57 <shachaf> ddarius: Is that on purpose?
20:08:04 <nand`> I think you can get as far as Fractional
20:08:13 * ddarius would like to acos implemented on matrices.
20:08:22 <nand`> sorry, no
20:08:23 <Tekmo> Well
20:08:28 <shachaf> I mean, is CSE often not a good optimization on Haskell code?
20:08:45 <ddarius> shachaf: Yes.  It will CSE some small things, but CSE can lead to significant changes in memory behavior.
20:09:02 <ddarius> The typical example is the two definitions of powerList.
20:09:21 <otters> I need a typeclass that intersects Eq, Floating, Integral, Num, and Ord
20:09:22 <shachaf> ddarius: This optimization is pretty much always a reasonable thing to do, though, isn't it?
20:09:26 <otters> and Enum
20:09:32 <shachaf> (Not that this is exactly CSE.)
20:09:33 <nand`> Floating and Integral at the same time?
20:09:37 <NihilistDandy> otters: let f n = n :: Float?
20:09:38 <nand`> I'm not sure how that's supposed to match up
20:09:44 <ddarius> shachaf: I don't know what you guys were originally talking about.
20:09:53 <NihilistDandy> I don't know that I understand what you're after
20:09:53 <nand`> Float isn't Integral
20:09:54 <otters> yeah, I don't know why it wants Integral
20:10:02 <nand`> how would toInteger :: Floating a => a -> Integer work
20:10:05 <shachaf> ddarius: foo a@(Foo x) = ...a... vs. foo a@(Foo x) = ...Foo x...
20:10:08 <otters> oh it's because I'm using div
20:10:12 <Tekmo> I think it doesn't work
20:10:12 <nand`> (remember toInteger is in Integral)
20:10:21 <NihilistDandy> Oh, wait, I see
20:10:22 <NihilistDandy> derp
20:10:22 <ddarius> shachaf: Those could be not even the same type.
20:10:30 <Tekmo> I can't find any function that works on Fractional or Floating
20:10:40 <nand`> for division?
20:10:48 <shachaf> ddarius: That's true.
20:10:56 <shachaf> But in this case they are. :-)
20:11:28 <shachaf> (When they're not the same type could they have a different value too?)
20:12:06 <ddarius> shachaf: They could have a different representation and they will certainly give rise to different instance resolutions.
20:13:41 <Tekmo> Well, you could in theory fix the type signature
20:13:54 <otters> okay, I'm just trying to figure out if this decimal number has a fractional part or if it's a whole number
20:14:00 <shachaf> That's true, but I'd think that that would affect things at a different stage.
20:14:20 <Tekmo> How do you know it's decimal if it's a Num?
20:14:23 <shachaf> But I don't know.
20:15:00 <Tekmo> Example
20:15:06 <Tekmo> I could just define a new Num instance
20:15:14 <Tekmo> for Vectors of Ints
20:15:54 <ssbr_> Anyone know where I should look for a disjoint set datastructure implementation?
20:16:45 <ddarius> @google site:hackage.haskell.org "disjoint set"
20:16:49 <Tekmo> You mean like Data.Set?
20:16:49 <lambdabot> http://hackage.haskell.org/package/persistent-equivalence
20:16:49 <lambdabot> Title: HackageDB: persistent-equivalence-0.3
20:17:15 <ssbr_> Tekmo: no, it's a datastructure used to keep track of equivalences
20:17:55 <Tekmo> Oh neat
20:18:01 <Tekmo> I could have used something like that at one point
20:18:11 <c_wraith> like, the union-find tree?
20:18:12 <ssbr_> ddarius: perfect!
20:18:18 <ssbr_> c_wraith: merge-find
20:18:34 <ssbr_> errrr, I guess there are more names for it
20:18:38 <ssbr_> people should stop using synonyms
20:19:03 <c_wraith> Oh, neat.  I didn't realize there was an optimal persistent version
20:19:08 <NihilistDandy> They'd better stop using words that mean the same thing, too
20:44:01 <isson> i am reading realworld haskell , Chapter 7. I/O
20:44:13 <ddarius> Wow.  Using signed rather than unsigned numbers goes a long way towards eliminating a DC bias.
20:44:23 <pharaun> DC ?
20:44:41 <isson> in the section "What Is An I/O Action? "
20:44:44 <Cale> direct current
20:44:52 <isson> Produce an effect when performed, but not when evaluated. That is, they only produce an effect when called by something else in an I/O context.
20:45:46 <Cale> isson: Yeah, we distinguish between evaluation: reducing expressions to values, and execution: carrying out the effects described by IO actions.
20:45:52 <isson> they (evaluate , execution)  is different in the haskell ?l
20:45:56 <Cale> isson: yes
20:46:25 <isson> thanks a lot Cale.
20:46:38 <shachaf> Little-known fact: Cale sees #haskell 15 seconds into the future.
20:46:40 <Cale> :)
20:46:40 <isson> is there a good reference about it ?
20:46:58 <Cale> I wrote a short tutorial here: http://www.haskell.org/haskellwiki/Introduction_to_IO
20:47:15 <pharaun> goddamn
20:47:42 <pharaun> that's rather amusing :) Cale you should go play some of those gambling games
20:47:51 <isson> thanks. Cale. very very very very much ! :)
20:48:07 <Cale> You're quite welcome
20:48:16 <Cale> Feel free to ask more questions
20:57:49 <stj> I need an advice on how to practice monads and functors... do you have exercises or ideas for simple projects to work on?
20:58:10 <stj> the largest thing I've written in haskell is 230-line ray tracer, but there is nothing advanced in it
20:58:17 <shachaf> What does "practice monads and functors" mean?
20:58:38 <stj> well, writing a monadic parser is one good idea, for example
20:58:53 <Tekmo> Here, let's start with a functor
20:59:01 <stj> I'm curious if you know any good examples to try coding
20:59:04 <Tekmo> List is a functor
20:59:21 <Tekmo> > fmap (+1) [1,2,3]
20:59:23 <lambdabot>   [2,3,4]
20:59:29 <Tekmo> fmap = map
20:59:45 <Tekmo> IO statements are functors, too
21:00:04 <shachaf> No, IO is a functor. :-(
21:00:09 <Tekmo> Correct
21:00:26 <boothead> hi folks, I'm having a bit of trouble getting my head around return type polymorphism... I need to extract the value from an attoparsec Number type which has I Integer and D Double constructors
21:00:38 <stj> sure, I'm familiar with that... but I'd rather implement something else, to see what else can be modeled as a functor
21:00:47 <shachaf> boothead: I don't think that's what people usually mean by "return type polymorphism".
21:00:54 <Tekmo> So you mean come up with a new functor?
21:01:02 <stj> yeah
21:01:11 <Tekmo> Ok, here's a simple example I use all the time in my work
21:01:14 <boothead> I'm trying (Num a) => Number -> a which I kind of knew wouldn't work
21:01:19 <Tekmo> Let's say I have a record of some sort
21:01:33 <shachaf> boothead: Oh, I see.
21:01:36 <Tekmo> like data Atom = Atom { coord :: Point, elem :: Element }
21:01:45 <Tekmo> and I want to add some sort of a "scratch space" to it
21:01:46 <boothead> shachaf: I think that's half the problem - I don't even know which works mean what! :-)
21:01:56 <Tekmo> Then I add a polymorphic field to that Atom
21:02:00 <Tekmo> and make the Atom type a functor
21:02:03 <shachaf> boothead: Well, you need to decide what you want to do if it's I and what you want to do if it's D.
21:02:12 <Tekmo> data Atom a = Atom { coord :: Point, elem :: Element, extract :: a }
21:02:24 <shachaf> The answer might be "(possibly lossily) convert the Integer to a Double, and then always return a Double".
21:02:40 <shachaf> Or it might be something different for each one. Or who knows.
21:02:48 <shachaf> Anyway whatever type you return has to account for both possibilities.
21:02:54 <Tekmo> instance Functor Atom where fmap f a = a { extract = f (extract a) }
21:03:00 <boothead> so the function must return the same type, an instance of the same typeclass isn't enough?
21:03:07 <Tekmo> No
21:03:09 <Tekmo> Not enough
21:03:16 <shachaf> Yes, enough.
21:03:34 <Tekmo> Well, it depends on what you want to do with it, then
21:03:34 <shachaf> But "instance of Num" might not mean what you think it means.
21:03:41 <Tekmo> For example
21:03:44 <Tekmo> You could unify both code paths
21:03:49 <boothead> It's actually for a benchmark - so if I somehow make Number and instance of Benchmarkable, would that work?
21:03:49 <Tekmo> by converting both of them to string
21:03:57 <shachaf> In particular, when your function is of type :: Num a => Foo -> a, that means the *caller* gets to choose what Num instance to use.
21:04:03 <shachaf> boothead: No, don't do that!
21:04:35 <shachaf> Just decide what you want to return for each one.
21:04:35 <mapreduce> boothead: An instance is something you have available, but, say, a Double is never a Num.
21:04:46 <mapreduce> There exists an instance for Num Double.
21:04:49 <shachaf> Then figure out what type captures both possibilities.
21:04:58 <Tekmo> That's easy
21:05:02 <Tekmo> Number does
21:05:06 <Tekmo> :)
21:05:21 <shachaf> Tekmo: No, it doesn't unify "what boothead wants to return for each one".
21:05:32 <Tekmo> Well
21:05:34 <boothead> Tekmo: yes, but bench doesn't seem to like Number
21:05:36 <shachaf> I probably shouldn't use the word "unify" here.
21:05:41 <Tekmo> Answering that requiers specifying what final type you want
21:05:47 <shachaf> Tekmo: Exactly!
21:05:53 <shachaf> boothead hasn't actually said what they want.
21:07:02 <Tekmo> But I mean, if he's just benchmarking it
21:07:08 <Tekmo> Why not just make it an instance of NFData
21:07:16 <boothead> Tekmo: I don't really care I'm running a parser an I just want to benckmark a few different ways of parsing a fixed number of digits. I already have a function that uses read which seems to be terribly slow from my profiling
21:07:17 <shachaf> We have no idea what's being benchmarked.
21:07:39 <Tekmo> instance NFData Number where ...
21:07:55 <Tekmo> Then you can benchmark it using Criterion
21:07:58 <boothead> Tekmo: thanks I'll look at NFData
21:08:15 <shachaf> I don't think NFData is necessary here. :-(
21:08:29 <Tekmo> Well, I think he just wants to benchmark a pure function
21:09:27 <Tekmo> But I still understand what you are trying to say
21:09:40 <shachaf> I think type classes are making this too complicated.
21:09:46 <Tekmo> that he should perhaps consider that he's benchmarking the wrong thing if he doesn't know what return value he's getting
21:09:55 <shachaf> That's not what I'm trying to say. :-)
21:09:59 <Tekmo> Oh
21:10:00 <Tekmo> :)
21:10:22 <boothead> I could just convert to a string - but I was worried that that might obscure what I'm trying to test
21:11:28 * ddarius wishes people wouldn't use the term "return type polymorphism".
21:11:51 <shachaf> How about "covariant polymorphism"? :-)
21:12:13 <ddarius> shachaf: Nothing special is going on.  It's just parametric polymorphism.
21:12:21 <Jafet> But, but, return is type polymorphic
21:12:29 <Tekmo> Well, Criterion requires that any pure action you want to benchmark can be reduced to normal form
21:12:31 <shachaf> ddarius: I think people specifically mean type classes when they say that.
21:12:32 <boothead> ddarius: what does return type polymorphism mean to you and why do you wish people wouldn't use that term?
21:12:51 <Tekmo> Well, there are two types of polymorphism
21:12:55 <Tekmo> parametric polymorphism
21:12:56 <shachaf> I'm not sure why I'm arguing about that term, given that I don't use it.
21:12:59 <Tekmo> and ad-hoc polymorphism
21:13:11 <Tekmo> ad-hoc polymorphism is type classes
21:13:14 <ddarius> shachaf: And you can desugar type classes into dictionaries and normal parametric polymorphism, i.e. plain code.  All that's happening is unification of type variables.
21:13:23 <Tekmo> parametric polymorphism is stuff like :: a -> a
21:13:35 <Tekmo> where you know absolutely nothing about the type variable
21:13:38 <Tekmo> not even a type-class constraint
21:13:41 <ddarius> shachaf: If one wants to talk about "return type polymorphism", one should just as well talk about "second argument in a list polymorphism".
21:14:49 <monochrom> well, I think the term comes up because mainstream languages offer parameteric polymorphism at every point of the type sig except the return type
21:15:05 <ddarius> monochrom: No, they certainly offer it in the return type too.
21:15:22 <ddarius> Dynamic dispatch doesn't happen in the "return type" but that doesn't even make sense.
21:15:31 <boothead> so in a nutshell what is wrong with stating that I'm going return something that's a Num and then doing something that tries to return either an Integer or a Double?
21:16:19 <Tekmo> I don't mind the choice of terms
21:16:27 <Jafet> (forall a b. (Num b) => a -> b) must return a value of type (forall b. (Num b) => b)
21:16:28 <shachaf> boothead: When you return a value :: Num a => a, it means the person who *called* you gets to decide what a is.
21:16:58 <shachaf> (Except I shouldn't use the word "call" either.)
21:17:03 <shachaf> (But anyway.)
21:17:08 <Tekmo> However, I think boothead wasn't referring to polymorphism at all
21:17:14 <Tekmo> He's just referring to the fact that the result is a sum type
21:17:16 <Tekmo> i.e. Number
21:17:22 <shachaf> 5.3 doesn't have the type Num a => a, because you can't pick for it to be an Integer.
21:17:27 <shachaf> Tekmo: That's what I thought at first too.
21:17:30 <n00b6502> i like the way types are infered in haskell
21:17:58 <shachaf> Tekmo: But then he started talking about Num a => Number -> a and all that.
21:18:06 <Tekmo> Oh, then maybe you're right
21:18:07 <XexonixXexillion> boothead: So why not return an "Either Integer Double" :p
21:18:14 <shachaf> XexonixXexillion: That's what Number is.
21:18:41 <Tekmo> To be precise, Number is isomorphic to Either Integer Double
21:18:48 <Tekmo> You'd just be changing the name of the representation
21:19:00 <XexonixXexillion> and changing the strictness
21:19:16 <shachaf> Not really.
21:19:37 <boothead> I was assuming that I could just return a Num and it would be Benchmarkable.
21:19:47 <boothead> Duck typing has ruined me :-)
21:19:51 <Tekmo> Number can be made benchmarkable
21:20:09 <shachaf> I don't think Benchmarkable is what you think it is.
21:20:21 <Tekmo> Here
21:20:31 <Tekmo> I'll give you a quick tour of Criterion
21:20:41 <Tekmo> A simple default program in criterion is:
21:21:06 <Tekmo> main = defaultMain [bench "MyFunction" $ nf pureFunction pureArgument]
21:21:27 <Tekmo> the meat of the benchmark is the right part
21:21:34 <Tekmo> the "nf pureFunction pureArgument"
21:21:38 <boothead> shachaf: I think it's safe to assume that most things aren't what I think they are :-)
21:21:40 <Tekmo> That's what criterion benchmarks for pure functions
21:21:49 <Tekmo> If you benchmark an IO action
21:21:52 <ddarius> boothead: That is likely true.
21:22:00 <boothead> nf is normal form right?
21:22:00 <Tekmo> you would use "nfIO myIOaction"
21:22:02 <XexonixXexillion> shachaf: Perhaps not i nthis case, but I can throw undefineds around for Either Integer Double without problems, not for attoparsec's Number
21:22:03 <Tekmo> Yes
21:22:09 <Tekmo> So normal form only works
21:22:13 <Tekmo> if a type is an instance of NFData
21:22:17 <Tekmo> from Control.DeepSeq
21:22:31 <Tekmo> So if you have some pure function that returns a Number
21:22:38 <Tekmo> You just have to make Number and instance of NFData
21:22:42 <Tekmo> and you can benchmark it
21:22:44 <shachaf> XexonixXexillion: Oh.
21:22:56 <shachaf> XexonixXexillion: boothead said data Number = I Integer | D Double
21:23:02 <shachaf> So that was just a lie. :-)
21:24:45 <boothead> shachaf: it's I !Integer | D !Double in Attoparsec.ByteString.Char8
21:24:58 <shachaf> "ByteString.Char8" :-(
21:25:17 <boothead> Tekmo: thanks I will try your suggestiong
21:25:41 <boothead> shachaf: oh no - not another one... what this time?!
21:26:07 <shachaf> Using ByteString.Char8 makes you racist. Or maybe being racist makes you use ByteString.Char8. I'm not sure which direction it is.
21:26:16 <shachaf> But let's save that for another time. :-)
21:27:22 <NihilistDandy> Really curious, now
21:28:18 <boothead> racist... are we still talking about polymorphism? :-)
21:29:24 <pharaun> char8 ? is there a good way to avoid using char8.pack for converting string -> bytestring for feeding into a socket?
21:29:34 <pharaun> i was going to start digging around into the utf8 encoder stuff
21:29:42 <shachaf> Yes, encode it as UTF8.
21:30:11 <pharaun> thought so, will do
21:31:32 <ddarius> @hoogle MonadIO
21:31:33 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
21:31:33 <lambdabot> package monadIO
21:31:48 <Jafet> We should buy hardcover copies of Unicode and hurl them at people.
21:32:16 <shachaf> ddarius: Did you mug anyone in California?
21:32:27 <shachaf> Or the west coast in general, I guess.
21:32:50 <ddarius> shachaf: I never left California while I was on the west coast.
21:32:55 <ddarius> I do not recall mugging anyone.
21:32:56 <shachaf> Oh.
21:33:02 <Jafet> I tried Darrell Huff's statistics book, but it isn't heavy enough.
21:33:12 <shachaf> ddarius: Better luck next time, I guess.
21:33:15 <shachaf> (For California, that is.)
21:33:33 <NihilistDandy> Jafet: Throw two
21:58:03 <boothead> oh dear - I seem to have broken my cabal-dev environment by using cabal-dev configure... is there anyway to fix it again without starting over? I'm getting ghc: --interactive can't be used with -prof or -unreg.
22:12:38 <aravartanian> Okay I am having a brain fart.
22:20:03 <aravartanian> So let's say I have a plain old recursive data type like maybe a data Expr = Plus Expr Expr | Minus Expr Expr.
22:20:19 <aravartanian> Then I want to write a whole bunch of functions that operate on the tree of objects I can make from this kind of type.
22:21:16 <aravartanian> There's a common pattern to all, which is to say if what you're not looking for in the type in questions, just push down to the children, i.e. f (Plus x y) = (f x) ++ (f y)
22:21:26 <shachaf> data Op = Plus | Minus; data Expr = Lit Integer | Bin Op Expr Expr
22:21:33 <aravartanian> How do you generalize that sort of thing without repeating yourself ad nauseum?
22:22:06 <shachaf> f (Bin op x y) = op2fn op x y
22:22:44 <Jafet> :t foldMap
22:22:46 <lambdabot> Not in scope: `foldMap'
22:22:50 <Jafet> @hoogle foldMap
22:22:51 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
22:22:51 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
22:23:01 <n00b6502> haskell and parallelism:- do haskell implementations autoparallelize even if you dont use parMap
22:23:23 <n00b6502> (i'm completely sold on the idea that functional thinking lends itself to parallelism)
22:23:30 <Jafet> No haskell implementation has automatic parallelism
22:23:34 <shachaf> Yes. GHC also does it if you use "par".
22:23:34 <n00b6502> ok
22:23:40 <shachaf> But not automatically. It's hard.
22:23:55 <Jafet> parMap means you say where the parallelism is, and ghc makes it run in parallel
22:23:56 <aravartanian> shachaf What's throwing me is that my data type itself can't be made into an instance of Functor/Foldable etc.
22:23:58 <n00b6502> fine-grain parallelism needs reasoning about caches
22:24:10 <shachaf> aravartanian: I never said to make it an instance of Functor/Foldable/etc.
22:24:24 <shachaf> aravartanian: Though you might be able to make it a Function if you parameterize it.
22:24:24 <n00b6502> writing imperative parallel code is like trying to turn it into a functional program
22:24:28 <n00b6502> maps are perfect
22:24:45 <shachaf> I thought simple loops were where it was at.
22:24:56 <n00b6502> yes that's what i mean by simple loops
22:25:04 <n00b6502> loops with minimal complexity
22:25:09 <n00b6502> minimal dependancies
22:25:16 <n00b6502> simple operations inside the loop
22:25:20 <n00b6502> like a map
22:25:54 <shachaf> What does a general do with his dependarmies when no one is looking?
22:26:15 <aravartanian> shachaf I was thinking of wrapping it with something like data Tree = Leaf a | Node (Tree a) (Tree a) and then folding over that, but then I thought... this feels wasteful.
22:26:26 <shachaf> aravartanian: Did you see what I said above?
22:26:34 <aravartanian> About making it a function?
22:26:38 <shachaf> aravartanian: Anyway, I'm not sure what you mean by "wasteful". What are you wasting?
22:26:47 <shachaf> Oops, I meant Functor. Silly fingers.
22:26:50 <shachaf> But no, before that.
22:26:55 <shachaf> In fact, I said it before you asked your question.
22:27:04 <Jafet> Thought: Tree is 75% Free
22:27:10 <aravartanian> About not making it an instance of Functor/Foldable/etc
22:27:32 <shachaf> 22:21 <shachaf> data Op = Plus | Minus; data Expr = Lit Integer | Bin Op Expr Expr
22:27:35 <shachaf> 22:21 <shachaf> f (Bin op x y) = op2fn op x y
22:28:05 <aravartanian> shachaf. Oh. Wait let me take a second look at what you wrote.
22:28:23 * hackagebot hoauth2 0.2.3 - hoauth2 (HaishengWu)
22:28:46 <Jafet> arav, you need to try really hard to make a type that can't even be a Functor
22:28:52 <Jafet> Like really really hard
22:28:55 <aravartanian> I see. You are parameterizing the operation.
22:28:58 <shachaf> Jafet: Nope, it's easy.
22:29:09 <shachaf> data Expr = Lit Int | Plus Expr Expr | Minus Expr Expr
22:29:17 <shachaf> It's not even the right kind to be a Functor.
22:29:31 <aravartanian> shachaf. Right. Not right for functors at all.
22:29:34 <shachaf> aravartanian: The operation is the only thing that's different between Plus and Minus. So abstract it out.
22:29:49 <Jafet> Well, I wouldn't find it easy to write that
22:29:49 <shachaf> aravartanian: Mind you, it's very possible that your Expr type *should* be a Functor.
22:29:59 <aravartanian> Yup. schachaf. Thanks. That's a clever idea.
22:30:10 <aravartanian> shachaf But a functor over what value?
22:30:11 <shachaf> For example, data Expr a = Lit a | BinOp Op (Expr a) (Expr a)
22:30:35 <Jafet> You can even remove the indirection
22:30:51 <Jafet> | BinOp (a -> a -> a) (Expr a) (Expr a)
22:30:55 <shachaf> Sure.
22:31:01 <shachaf> You might want to print Exprs, though.
22:31:18 <Jafet> Then just let a = Expr
22:31:23 <Jafet> (the other Expr!)
22:31:40 <shachaf> You might want to optimize an Expr.
22:33:12 <Jafet> Well, once you make that substitution you have a complete interpretation anyways
22:33:21 <shachaf> Sure.
22:33:42 <shachaf> But removing the indirection only to add it again seems awkward.
22:33:49 <aravartanian> shachaf That's what I was thinking of when I said "wasteful" about the tree. Not literally wasteful, but if I wanted to print the thing, printing Tree (Node a) a (Node a) would, well, print out a lot of duplication.
22:33:51 <hpaste> Ri pasted “Problema 3” at http://hpaste.org/73382
22:34:03 <shachaf> aravartanian: Oh, just write a smart printing function.
22:34:10 <shachaf> You'll probably have to do that anyway. No waste involved.
22:34:40 <aravartanian> An I see. An instance of Show over that Tree type I mentioned?
22:34:42 <Jafet> showsPrec is easy, readsPrec is annoying
22:35:06 <aravartanian> Or over the Expr type itself?
22:35:07 <shachaf> aravartanian: Or a function print over that type.
22:35:14 <shachaf> aravartanian: Whichever one.
22:35:17 <shachaf> You'll probably do it anyway.
22:35:22 <aravartanian> Interesting.
22:35:25 <shachaf> Jafet: But you'll probably be writing your own parser anyway. :-)
22:35:30 <aravartanian> I already did that :)
22:35:41 <Jafet> Hence annoying
22:35:44 <aravartanian> Actually wrote a quasi quoter.
22:39:52 <aravartanian> shachaf Jafet thanks for your help. Very nice little mind-broadening discussion to have at 2 am.
22:40:53 <shachaf> OceanSpray
22:55:39 <ddarius> @hoogle getCurrent
22:55:40 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
22:55:40 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
22:55:40 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
23:14:53 <OceanSpray> shachaf, what
23:40:56 <EvanR> how do i figure out which exception to catch when writing to a handle which may be closed
23:41:23 <EvanR> try?
23:42:07 <EvanR> hmm
23:42:09 <EvanR> nope
23:42:57 <Jafet> IOException
23:43:34 <mm_freak> EvanR: unless it's in the documentation i see only one way:  use the fact hat exception types are Typeable
23:44:03 <mm_freak> of course you can always just catch SomeException, which matches every exception
23:44:21 <mm_freak> c `catch` \(SomeException ex) -> …
23:44:30 <shachaf> ALSO IF YOU instance Typeable Foo where typeRep = typeRep somethingElse YOU CAN BREAK EXCEPTIONS
23:44:33 <shachaf> It's true.
23:44:51 <shachaf> s/=/_=/
23:45:15 <mm_freak> s/_=/_ =/
23:45:15 <ddarius> > let (_=) = undefined in (_=)
23:45:17 <lambdabot>   <no location info>: parse error on input `='
23:45:35 <EvanR> mm_freak: something tells me i dont want to catch every exception
23:45:53 <EvanR> ill try typeable
23:46:25 <shachaf> mm_freak: Let me golf my regexps, man!
23:47:06 <shachaf> This channel looks like it's in the mood for some exciting Haskell golf.
23:47:08 <shachaf> @where pi_10
23:47:09 <lambdabot> (!!1)<$>transpose[show$sum[100^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
23:47:25 <shachaf> > (!!1)<$>transpose[show$sum[100^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
23:47:27 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
23:47:34 <nand`> looks like something taken out of APL; except with less strange symbols
23:48:38 <mm_freak> EvanR: use Typeable only to /display/ the type
23:48:45 <mm_freak> not for actual matching…  let 'catch' do that for you
23:49:04 <mm_freak> my favorite subsets function…  it sucks, but works
23:49:30 <mm_freak> > filterM(\_->[False ..]) "abc"
23:49:31 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
23:49:48 <mm_freak> > filterM(\_->[0>1..]) "abc"
23:49:50 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
23:50:45 <EvanR> mm_freak: yeah. tried that
23:50:54 <EvanR> i got SomeException from typeOf ;)
23:51:35 <EvanR> looking in the documentation
23:52:38 <shachaf> mm_freak: I meant golfing pi_10 down.
23:53:08 <mm_freak> > pi
23:53:09 <lambdabot>   3.141592653589793
23:54:23 <Jafet> > showCReal pi
23:54:24 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
23:54:24 <lambdabot>    arising from a use of...
23:54:36 <Jafet> > showCReal 100 pi
23:54:38 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
