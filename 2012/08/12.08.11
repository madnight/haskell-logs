00:00:14 <YayMe> mm_freak_: no, they would have suggested I return a fake value and check for that instead, I choose null because distinguishing something like Mortgagee which is fake from a Mortgagee that is real is annoyingly more error prone
00:00:30 <Mortchek> YayMe, my condolences.
00:00:32 <rosie> Here's my module question, reposted: When would you want to :add a module, but not :module (or :load) it?
00:00:56 <mm_freak_> YayMe: i disregarded such an order once when my team leader requested that i return null instead of throwing an exception (in PHP)…  i disobeyed and told him:  "sorry, but i won't let my reputation suffer like that…  if you're not happy with my code, you'll have to find someone else" (not in those exact words, but with that sense)
00:01:13 <mm_freak_> but my (haskell-inspired) code was very solid, so they didn't want to lose me =)
00:01:23 <YayMe> mm_freak_: enterprisey shops don't like throw anything unless you're in a scenario where you're dealing with resources known to have shoddy reliability (disk/network/etc)
00:01:23 <mm_freak_> so they just lived with the exceptions =)
00:02:01 <mm_freak_> also "mortgage" sounds like it had to do with money, which is even more reason to use proper error handling
00:02:19 <YayMe> mm_freak_: I behaved more or less similarly at my last job; but I've been at this place ~1 month now so, I have to use the kid gloves until they value
00:02:50 <YayMe> mm_freak_: hah, if you had any idea how bad the software these banks are using you'd shit your pants and faint
00:04:05 <YayMe> Mortchek: what do you work in?
00:06:07 <YayMe> language that is
00:06:21 <YayMe> Damn it's late.. what am I doing up at 1..
00:06:28 <Mortchek> YayMe, while I do have a job, I don't work full-time. I'm pursuing a CS degree. Most of my hobby work is JavaScript though.
00:07:13 <Mortchek> I hope to make the switch over to Haskell once I can adequately formulate things in it.
00:07:14 <YayMe> ah
00:07:27 <YayMe> stick with javascript
00:07:29 <YayMe> hah
00:07:40 <ninegrid> i tried to cabal install xmonad-utils and i got the error Hhp.hs not in scope `ExitException', any ideas how to proceed?
00:07:41 <YayMe> sorry, I shouldn't say that but..
00:07:51 <Mortchek> Oh I certainly won't drop it entirely or forget it. But Haskell is so much more fun.
00:07:57 <YayMe> javascript has a *very* strong career future
00:08:22 <mm_freak_> btw javascript, i should really check out fay
00:08:33 <YayMe> yeah, haskell really does bring back the fun I remember when I was first learning
00:08:46 <YayMe> people say ruby does that, I haven't bothered to try yet, but haskell definitely does
00:09:00 <latro`a> with ruby I think that might depend on where you start
00:09:09 <YayMe> How do you figure?
00:09:16 <YayMe> (I don't know any ruby)
00:09:20 <latro`a> as far as I can tell ruby basically just dives into the way that python looks when it's advanced
00:09:26 <latro`a> and does it cleaner
00:09:42 <Ralith> isn't ruby just a poor man's lisp?
00:09:43 <latro`a> that is obviously a very vague sketch, and will enrage fans of both languages
00:09:48 <latro`a> eh no, ralith
00:09:51 <YayMe> see I been meaning to learn python
00:09:51 <latro`a> it's very OOPy
00:10:09 <latro`a> but also somehow very metaprogramming-y
00:10:17 <Ralith> you haven't used CL, hav eyou
00:10:20 <latro`a> (I have almost no knowledge of its metaprogramming facilities)
00:10:25 <Mortchek> I wish Python had been my first language. I tried starting with C++ and it wasn't so much fun.
00:10:28 <latro`a> I am familiar with CL, haven't used it nontrivially
00:10:33 <Ralith> common lisp's OOP is among the best.
00:10:34 <YayMe> yeah, I've heard a lot of people compare it to functional languages but while I understand it's multiparadigm, I don't think anyone can call it functional based on the ruby developers I knew
00:10:36 <latro`a> I know that you can get OOP into CL
00:10:39 <latro`a> but the standard idiom isn't that
00:10:46 <Ralith> there is no "standard idiom"
00:10:49 <latro`a> eh
00:10:51 <latro`a> true
00:10:53 <Ralith> nor is it a case of "you can get" it
00:10:56 <latro`a> but the standard idiom is to not have a standard idiom
00:11:00 <latro`a> in lisp
00:11:02 <Ralith> CLOS is one of the best OOP systems out there.
00:11:05 <latro`a> the standard idiom in ruby is not that
00:11:07 <mm_freak_> i never understood the hype around OOP…  it's not a great concept after all
00:11:07 <latro`a> sure
00:11:12 <latro`a> but that's not what I mean by OOPy
00:11:23 * Ralith shrug
00:11:29 <Ralith> mm_freak_: it's better when it's not java-style OO.
00:11:36 <latro`a> core, common things like iterators are methods and such
00:11:38 <Ralith> but then it starts to look like ADTs and typeclasses pretty quick.
00:11:40 <YayMe> mm_freak_: after 10 years writing it, I understand that now.. unfortunately, it'll be 10 years before the industry as a whole does as well
00:11:49 <Ralith> YayMe: that's very optimistic.
00:11:50 <mm_freak_> OOP is noisy, error-prone and you always have to bend the interfaces, whenever you want to do something the library author did not anticipate
00:12:15 <latro`a> that depends on how robust the lib is, but yes, it can very easily become that
00:12:27 <mm_freak_> latro`a: it always becomes like that
00:12:41 <mm_freak_> for OOP more flexible means more methods
00:12:43 <ninegrid> i tried to cabal install xmonad-utils and i got the error Hhp.hs not in scope `ExitException', any ideas how to proceed?
00:12:57 <mm_freak_> and then you have hundreds of classes with hundreds of methods and need a week to learn the library
00:12:57 <latro`a> I know, I meant with a robust lib that does everything it should but not more stuf
00:13:08 <mm_freak_> there is no library that does everything
00:13:11 <latro`a> I know
00:13:12 <latro`a> *stuff
00:13:17 <latro`a> I said everything it should
00:13:36 <latro`a> if it does everything it should, then all you need is the miracle of compositionality
00:13:40 <latro`a> and it works well
00:13:58 <mm_freak_> and that's the problem
00:14:04 <latro`a> it's the effort to get compositional results that doesn't get put in much of the time
00:14:07 <YayMe> Sadly, I am very good at OOP design by my measure following the SOLID principles and all of those gags, but even with decent OOP design skills, I have to agree. OOP just ends up with a ton of code to maintain, and lots of funky hacks to avoid code duplication if avoidance of it is even tried
00:14:09 <latro`a> but *much*, not *all*
00:14:57 <mm_freak_> OOP isn't very composable, and as soon as you have a need, which is not covered by the API, you have to bend things and code becomes ugly, redundant and error-prone
00:15:19 <mm_freak_> that's the fallacy of OOP:  that an object may ever provide all you need
00:15:33 <Mortchek> or s/object/framework/
00:15:34 <latro`a> that's the fallacy of bad OOP, I think
00:15:42 <mm_freak_> s/framework/class/
00:15:48 <latro`a> which unfortunately has sorta become OOP, by what I've heard about the industry
00:15:50 <mm_freak_> the framework is the mess that results from that fallacy
00:15:54 <hughfdjackson> it really depends what language's OOP you're talking about
00:16:03 <latro`a> eh, it depends more on the programmers than the language I think
00:16:07 <hughfdjackson> composition/ad hoc behaviour sharing is easy enough in.. for instance, js
00:16:18 <YayMe> in functional languages, avoiding code duplication is plain as day. in oop you have to design the system to be correct, and may do well and get it modelled right to start. but maintenance is just a nightmare because (compared to functional) redefining the model to account for new requirements is a kludge. time after time kludge kludge kludge until some years go by and the whole system is a kludge.
00:16:18 <mm_freak_> hughfdjackson: java-style OOP (C#, java, PHP, etc.)
00:16:30 <hughfdjackson> where you can .call or .apply a function to an object, or mixin new behaviour to an object by shallow copying
00:16:36 <hughfdjackson> :3 ah, in those cases, i'm 100% with you
00:16:41 <mm_freak_> hughfdjackson: JS isn't really OOP…  it's just records and closures
00:16:51 <Mortchek> Yeah, JS is nice in that way in that you can do stuff you aren't "supposed" to do
00:16:51 <mm_freak_> and composing by adding stuff never works well
00:16:52 <hughfdjackson> :p well, if that's not what you meant by OOP, i shalln't argue
00:17:07 <hughfdjackson> *that's what you meant
00:17:18 <startling> how do I turn a Nothing while I'm in do notation into the monad's fail?
00:17:22 <mm_freak_> in haskell and functional languages in general you always do what you're supposed to do…  it's still concise and correct
00:17:33 <latro`a> startling: the most obvious way is to try to match it to a Just
00:17:43 <latro`a> Just x <- m; if m is Nothing fail gets called
00:17:45 <Mortchek> mm_freak_, of course, I just mean that given pointless limitations you can still break them.
00:17:49 <startling> oh, would fromJust do that?
00:17:59 <latro`a> fromJust would throw its own exception, iiuc
00:18:00 <startling> latro`a: oh hm
00:18:20 <mm_freak_> Mortchek: the limitations aren't pointless…  they are part of a concept that is pointless…  if you break the rules, you stop doing OOP
00:18:30 <mm_freak_> and the result is an even worse mess
00:18:48 <mm_freak_> adding functions to a javascript object always makes me feel bad
00:19:35 <Mortchek> mm_freak_, I'm speaking more of the design that *results* from OOP. JS lets you monkey patch other people's libraries if you want.
00:19:49 <YayMe> mm_freak_: before I embarked on my functional expedition a few months ago, I had written much javascript in C# style with pride :( I hereby apologize to the world
00:19:59 <mm_freak_> Mortchek: yes, but you shouldn't do that for the same reason you shouldn't define orphan instances in haskell
00:20:45 <startling> latro`a: do notation seems to expect things after <- to be the same kind of monad as the do notation.
00:20:56 <mm_freak_> startling: yes
00:21:15 <mm_freak_> startling: you can do this:  maybe fail return
00:21:19 <mm_freak_> :t maybe fail return
00:21:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe (m a) -> String -> m a
00:21:27 <mm_freak_> uhm
00:21:34 <mm_freak_> :t maybe (fail "blah") return
00:21:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
00:21:39 <mm_freak_> there you go
00:21:51 <mm_freak_> but please note that it's a bad idea to use 'fail' explicitly
00:22:05 <startling> mm_freak_: yes, I know, but the parsing thing I'm using seems to want that
00:22:07 <YayMe> Mortchek: OOP is good for modelling data, yes. I think it's best application may be in database structure design, but as soon as you introduce logical rules and calculations in it, you are committing those to your data model. As soon as they need to change, so does your data model, and any thing which depends on your data model (such as all of your other business rules)
00:22:20 <mm_freak_> startling: the "parsing thing" is probably an Alternative
00:22:23 <mm_freak_> :t empty
00:22:24 <lambdabot>     Ambiguous occurrence `empty'
00:22:25 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
00:22:25 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
00:22:26 <YayMe> that's why OOP becomes a mess
00:22:30 <mm_freak_> :t Control.Applicative.empty
00:22:32 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
00:22:37 <startling> mm_freak_: nope
00:22:42 <startling> mm_freak_: (it's Data.Binary.Get)
00:22:54 <AfC> YayMe: I like what you said a moment ago
00:23:14 <mm_freak_> startling: ah, now i remember why i hate 'binary'…  try cereal =)
00:23:19 <startling> mm_freak_: man
00:23:40 <mm_freak_> YayMe: OOP is the worse design pattern for modelling data
00:23:47 <mm_freak_> you can't model data more noisy and more error-prone
00:23:50 <startling> i'm seriously 80% of the way there with 'binary'
00:23:57 <startling> :(
00:23:58 <mm_freak_> YayMe: for a proof just try to model Maybe using OOP
00:24:05 <AfC> YayMe: though I think that alternatives (which I think are begging for a wider audience) have regrettably little to say about alternatives; sure, decouple business rules and data structures in your code, except that you can't really do that; the coupling remains.
00:24:13 <scri> @hoogle Char -> String
00:24:13 <mm_freak_> startling: i suggested cereal from the very beginning
00:24:13 <lambdabot> Network.URI escapeURIChar :: (Char -> Bool) -> Char -> String
00:24:13 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
00:24:13 <lambdabot> Text.Html prettyHtml :: HTML html => html -> String
00:24:36 <startling> mm_freak_: not blaming you, just complaining
00:24:37 <Mortchek> mm_freak_, there's a blog post where someone does that. Lemme dig it up
00:24:46 <mm_freak_> Mortchek: i know how to do it
00:24:51 <Mortchek> http://www.stephanboyer.com/2011/10/monads.html
00:25:36 <startling> mm_freak_, the api seems pretty similar, though?
00:25:44 <Mortchek> mm_freak_, wasn't saying you didn't, it just reminded me, and the blog post is potentially relevant to the discussion
00:25:51 <rajeshsr> hi all
00:25:52 <YayMe> AfC: In the functional paradigm you can severely limit your logics exposure to your data models
00:25:56 <mm_freak_> startling: yes, but Get is an Alternative
00:26:07 <startling> mm_freak_: interesting. what would I do in that case?
00:26:12 <mm_freak_> Mortchek: this is about modelling Maybe using OOP
00:26:27 <mm_freak_> if you want to do it cleanly you need three classes and lots of noise
00:26:38 <rajeshsr> was trying to get cabal in mac. It seems to be failing with the "overlaping instance" error between "mtl" and "transformers"..
00:26:44 <rajeshsr> can anybody help?
00:26:47 <Mortchek> mm_freak_, I guess it isn't exactly "using OOP".
00:26:48 <AfC> YayMe: yeah, I'm starting to learn that, but it's not automatic; my sense is it is still something you have to work at, just as good code structure [to preempt these sort of problems] is just as necessary in OOP land. Dunno. Code is hard.
00:26:51 <mm_freak_> abstract class Maybe; class Just extends Maybe; class Nothing extends Maybe
00:26:57 <Mortchek> More like using a dynamically typed language.
00:27:00 <startling> mything.is_just, mything.data
00:27:05 <mm_freak_> and that's just the class headers, which is already much more code than in haskell
00:27:25 <Mortchek> You're talking about Java-style OO, then?
00:27:26 <mm_freak_> and doesn't even count in the fact that haskell's Maybe is polymorphic
00:27:30 <mm_freak_> yes
00:27:53 <YayMe> AfC: True that. I'm only like 3 months into haskell myself and yes, I willfully apply to the credo that we all write bad code heh
00:28:36 <rosie> What's a good way to see what functions are loaded in ghci?
00:28:45 <mm_freak_> rosie: :bro
00:28:54 <mm_freak_> it's per-module though
00:29:23 <startling> mm_freak_, so would I just end with "empty" since Get is an Alternative in cereal?
00:29:33 <mm_freak_> startling: yeah
00:29:40 <mm_freak_> :t maybe empty return
00:29:42 <lambdabot>     Ambiguous occurrence `empty'
00:29:42 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
00:29:42 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
00:29:46 <YayMe> mm_freak_: I think OOP can't model maybe because none of the OOP languages have a type system where that is possible. When I was referring to data modelling however, I mean modelling records... though maybe you have a point and the concept of a flat encapsulated data record rather than a data tree as I kind of view haskell has, is stupid..
00:29:48 <mm_freak_> :t maybe Control.Applicative.empty return
00:29:50 <lambdabot> forall (f :: * -> *) a. (Alternative f, Monad f) => Maybe a -> f a
00:30:17 <rosie> :mm_freak_: thanks!
00:30:25 <mm_freak_> YayMe: haskell records with lenses are already tons more expressive and powerful than OOP-style records
00:31:32 <mm_freak_> YayMe: OOP can model Maybe, but the result will be very noisy
00:31:41 <YayMe> mm_freak_: I don't know what lenses are, but you have made me curious now- are there any persistent data stores (sql or nosql) which can have such dynamic record types as haskells?
00:31:51 <mm_freak_> while you can implement a sensible Maybe in about 15 lines in haskell, you need 100 lines in an OOP language
00:32:07 <mm_freak_> YayMe: acid-state =)
00:32:21 <mm_freak_> turns any haskell data type into a persistent storage
00:33:02 <YayMe> Will have to look into that out of curiosity..
00:33:05 <Mortchek> I would like to play around with parser combinators. Should I use Parsec, or is there something else someone would recommend?
00:33:10 <YayMe> How does it perform? Is it specifically for haskell?
00:33:17 <mm_freak_> YayMe: yes
00:33:34 <mm_freak_> and it performs like the data structure except that you may have to wait for the hard-disk
00:33:44 <mm_freak_> acid-state gives you, well, ACID guarantees, just like a database
00:33:57 <mm_freak_> Mortchek: parsec is fine
00:33:59 <YayMe> and queries?
00:34:14 <Mortchek> Thanks.
00:34:17 <mm_freak_> YayMe: queries are in-memory
00:34:36 <YayMe> does it load the whole database to memory?
00:34:43 <mm_freak_> YayMe: yes, acid-state data lives in RAM
00:34:51 <YayMe> cool
00:35:24 <YayMe> guarantees performance, and has the simplest cheapest bottleneck solution: add more ram.
00:36:00 <mm_freak_> well, it's not a DBMS, it's really just for persisting with ACID
00:36:16 <startling> Mortchek: parsec is good
00:36:16 <mm_freak_> but for applications, where the whole database fits into RAM anyway it's great
00:36:21 <YayMe> but it allows arbitrary queries?
00:36:34 <mm_freak_> YayMe: you write the allowed queries
00:36:54 <startling> Mortchek: edwardk wrote trifecta, but it's not as well documented and it's modelled mostly on Parsec anyway. So I would use parsec
00:36:58 <startling> *learn
00:37:03 <mm_freak_> myQuery k = gets (M.lookup k . myDB)
00:37:05 <Mortchek> Sounds good.
00:37:33 <mm_freak_> only the interface of trifecta is based on parsec…  the internals are very different
00:37:49 <mm_freak_> i recommend parsec for beginners
00:38:29 <YayMe> mm_freak_: my last 2 companies had the multi-terabyte database on ~$300k machine where they tried forcing as much of the DB into ram as possible. In all honesty I've come to the conclusion the only value for disk to an RDBMS is durability in case of crash
00:38:29 <startling> yeah, I meant the API, not the actual thing
00:39:13 <YayMe> mm_freak_: So I like hearing a database lives in memory. If it grows too large for memory, break the system up and let it live across multiple machines.
00:39:37 <mm_freak_> YayMe: yeah, although acid-state does not support distributed stores
00:40:16 <YayMe> mm_freak_: I didn't figure, I meant splitting the data up and hand coding communication between nodes
00:40:46 <mm_freak_> that's inconvenient and error-prone, unless you can do this logically
00:41:12 <YayMe> the data split would have to be logical and well thought out
00:42:07 <YayMe> one may be forced to implement the distributed transactional behavior yourself with collision detection, but whatever, that's really not that bloody hard as everyone makes it out to be
00:42:08 <beekor> ....3333333
00:42:39 <mm_freak_> well, STM is great, but it doesn't support distributed transactions right now
00:42:45 <mm_freak_> the cloud haskell stuff might change that some day
00:43:47 <YayMe> mm_freak_: like I said, you may have to implement them yourself. It's never particularly pretty but honestly not the worst thing in the world to tag a lock into a data structure then send similarly tagged locks with timestamps to other nodes
00:44:33 <YayMe> each node does a timestamp check to see who gets the lock, tells the other locker sorry tough luck and then they both do their update and unlock.. again.. it's not complex, it's not pretty, but it works.
00:44:35 <mm_freak_> YayMe: my point is that you may not even have to do it yourself
00:44:44 <YayMe> oh, I thought you said you would
00:44:55 <mm_freak_> right now
00:45:26 <YayMe> cloud haskell.. I like the sound of that..
00:45:48 <mm_freak_> distributed haskell threads, basically
00:46:09 <beekor> 666666
00:46:11 <mm_freak_> and yeah, as most design patterns it's just a library…  no language/compiler support needed =)
00:46:15 <YayMe> would that be something like haskell's answer to javas mapreduce?
00:46:25 <YayMe> beekor: You're not keanu reeves, quite sleeping on your keyboard
00:46:32 <YayMe> s/quite/quit/g
00:46:37 <mm_freak_> YayMe: don't feed the troll, just ignore him
00:46:49 <mm_freak_> YayMe: mapreduce is already something above that
00:47:02 <mm_freak_> cloud haskell is for sending messages between remote threads
00:47:14 <mm_freak_> transparently that is, like they were regular local haskell threads
00:47:46 <YayMe> ah makes sense
00:48:05 <YayMe> I still don't even know how haskell does threads to begin with
00:48:39 <mm_freak_> well, then start!
00:48:43 <latro`a> for simple stuff, Control.Parallel is great
00:48:48 <mm_freak_> concurrency is one of the main strengths of haskell
00:48:54 <YayMe> I just assume if you minimize your state monads your code will be easy to prefix with parellel haskell and just go to town
00:48:59 <latro`a> really elementary SMP sort of stuff can be done with just a few little annotations
00:49:00 <mm_freak_> latro`a: that's not about parallelism, but about concurrency
00:49:34 <latro`a> I was basically thinking of parmap and whatnot
00:49:44 <latro`a> where I don't quite see the distinction
00:49:44 <mm_freak_> YayMe: try to write a simple echo server in haskell…  it must be scalable, allow multiple clients simultaneously and should not have more than about 10 short lines
00:49:52 <mm_freak_> and yes, it's not just possible, but easy =)
00:50:00 <YayMe> mm_freak_: I know, concurrency is why I started learning haskell, I was doing a bunch of service development and realized the value of no side effects programming naturally
00:50:33 <YayMe> mm_freak_: that is, I realized the value of no side effects is, massive scalability
00:51:54 <YayMe> mm_freak_: I started designing the processing services to be no side effects so we could spin up as many of them as we wanted, none of the architects or other devs I was working with understood why I wanted this..
00:52:34 <YayMe> they just kept telling me I should bundle the data access services together with the processing services since they were processing the data that was being accessed
00:53:12 <beekor> 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999+++++++++++++++++++++++++++++++-------------------------------
00:53:12 <beekor> ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------++
00:53:13 <beekor> +++++++++++++++++-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
00:53:17 <mm_freak_> @where ops
00:53:18 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
00:53:21 <beekor> ....................................7777777777777+++++++++++++++++++++++++++++++
00:53:25 <beekor> ++++++++++++++968++++++
00:55:23 <mm_freak_> YayMe: you will find that most programmers don't value haskell design patterns…  that's because their brain is already messed up from what they learned
00:57:42 <YayMe> Yeah.. that one comes through loud and clear
00:58:10 <YayMe> I wonder if I would prefer working at a ruby shop just because the people are more interested in software
00:58:25 <YayMe> enterprisey developers are just punching the keys and collecting a check
01:03:18 <beekor> 411111155555555555555555555555555555555555555554444444222555555555555555555555555
01:05:31 <pharaun> YayMe: i am working at a startup (python)
01:05:48 <pharaun> and they are indeed more interested in software but at the same time there's no interest in deploying haskell :)
01:06:10 <pharaun> tho we did the arch in a manner in that i could *theorically* write up a haskell service and deploy it :)
01:06:53 <dfeuer> ping Cale
01:09:08 <dfeuer> @karma- beekor
01:09:08 <lambdabot> beekor's karma lowered to -1.
01:11:07 <YayMe> pharaun: People with their ears open not hearing "bla bla bla" would be a step up for me.. python is another one I've been meaning to learn
01:11:18 <pharaun> true :)
01:11:27 <srhb> YayMe: Python isn't all that impressive, you'll get frustrated quickly. :P
01:11:37 <srhb> The libraries are nice though.
01:11:45 <pharaun> the libraries is why i like python
01:11:53 <pharaun> i've done lots of work with numpy/scipy
01:12:03 <pharaun> and do bunch of ffi work with cython/c/openmp
01:12:14 <dfeuer> People who like libraries too much tend to program in C++ or Emacs LISP.
01:12:15 <srhb> Yes, that package specifically - but I've been on a project trying to extract that .mat-reading capabilities of scipy, and I lost my love for it then.
01:12:23 <srhb> It's not pretty code. At all.
01:12:26 <pharaun> hehe
01:12:54 <pharaun> well needless i'm learning haskell now :p
01:13:01 <srhb> Good. ;)
01:13:21 <pharaun> enjoying it... *lots*
01:13:31 <srhb> yeah, it really does put the fun back in programming.
01:13:31 <pharaun> anyway off to bed, its past my bedtime
01:13:35 <srhb> Goodnight. :)
01:14:29 <YayMe> coming from a very solid understanding of good OOP and C#, I imagine I could pick up python and rails pretty quickly, pain points being the frameworks. possibly worth learning just to get my head into a job where the people aren't just drooling into their IDE all day
01:15:01 <srhb> YayMe: That's a fair point I guess. I think you'll find a great distaste for Python if you're used to C# though.
01:15:23 <YayMe> srhb: Oh? Why so?
01:16:06 <srhb> Python has some strange inconsistensies here and there, I think C# is more polished. Oh, and if you're in .Net, there's always F# which is actually pretty nice.
01:16:42 <AfC> libraries. Hm. Haskell does *not* make it easy; there are often 3-4 ways [libraries, apis] to solve a problem, several of which may be cutting-edge theoretical, and it can be hard to Get Shit Done™ while you wade through the morass of papers and shoddy documentation and stackoverflow posts looking for some evidence as to which you would be wise to use.
01:17:01 <srhb> AfC: But that is rapidly improving.
01:17:16 <latro`a> and is significantly helped by just asking whatever question on here, tbhp
01:17:17 <latro`a> *tbph
01:17:22 <latro`a> even now
01:17:24 <srhb> Yeah.
01:17:38 <AfC> latro`a: that's so
01:17:52 <latro`a> that isn't a defense, it's hackish as hell, obviously
01:17:54 <latro`a> but it works
01:18:14 <AfC> srhb: though I can't say that I've seen much improvement over the last year, which is my [admittedly quite short] time horizon with Haskell.
01:18:20 <srhb> It's very true, we need more work there, I'm just very calm about it because the development seems to be going quite rapidly.
01:18:30 <srhb> AfC: Oh, really? perhaps we're using different library ecosystems :0
01:18:30 <AfC> srhb: that's my take on it too
01:18:33 <latro`a> I still wish I knew how hmatrix worked
01:18:36 <YayMe> srhb: Very true, but I don't suspect I have the chops to pick up a functional programming job, I would need to really pick up algorithms and data structures comprehension asap, even then I suspect most places trying to hire someone to write in a functional language would be far more staunch on their degree requirements of which I have none
01:18:37 <latro`a> so I could try to extend it
01:18:54 <latro`a> but as soon as I see an app2 or app3, which are in ALL the FFI calls in there, I have no idea what it does
01:19:09 <srhb> YayMe: I don't think there's that much of a degree requirement, but yeah, why use F# when you can learn FP via Haskell, which is much nicer. :-)
01:19:44 <latro`a> oh hey, ther's a pdf intro
01:19:48 <latro`a> *there's
01:20:29 <srhb> To hmatrix?
01:20:30 <YayMe> well it's time I lay my head on something, night all
01:20:34 <srhb> YayMe: Gnight.
01:20:42 <latro`a> yeah
01:20:48 <latro`a> http://dis.um.es/profesores/alberto/material/hmatrix.pdf
01:21:31 <srhb> Neat.
01:21:51 <latro`a> infinitely better than the documentation
01:21:52 <latro`a> seriously
01:21:59 <srhb> No doubt about that. :-)
01:22:07 <srhb> But isn't hmatrix also quite broken?
01:22:11 <latro`a> is it?
01:22:27 <latro`a> I didn't know, I just knew that if I wanted my linalg stuff to be fast for any kind of numerical work I'd need a binding
01:22:27 <srhb> I don't think I've been able to build it, but that might just be OS X being a steaming pile of crap.
01:22:33 <srhb> Yes.
01:22:34 <latro`a> uh
01:22:35 <latro`a> huh
01:22:54 <latro`a> I have a fresh platform install on the OS I'm on now
01:23:00 <latro`a> so...I guess I'll give it a shot
01:23:06 <srhb> Nice. :)
01:23:09 <latro`a> will probably be missing libs, though
01:23:13 <latro`a> (windows >.>)
01:23:21 <latro`a> if it breaks I'll reboot and try it there
01:23:30 <srhb> Seems like a safer bet :P
01:24:45 <srhb> latro`a: https://github.com/AlbertoRuiz/hmatrix/blob/master/INSTALL.md
01:25:23 <latro`a> bah, not worth trying to get windows to find LAPACK
01:25:27 <latro`a> will just reboot
01:25:28 <latro`a> heh
01:25:29 <srhb> Hehe :P
01:25:43 <startling> @pl l m v i w = fmap Left $ f m v i w
01:25:44 <lambdabot> l = (((fmap Left .) .) .) . f
01:25:49 <startling> o.o
01:25:56 <srhb> startling: Ugh..
01:26:22 <startling> well, it's kind of pretty
01:26:30 <srhb> No, no it's not :P
01:26:54 <startling> look at those beautifully balanced parens!
01:27:00 <startling> feel the lispy nostalgia!
01:27:04 <srhb> :P
01:28:06 <shachaf> fmap (fmap (fmap (fmap (fmap Left)))) f
01:28:10 <shachaf> Better?
01:28:17 <fmap> yes
01:28:22 <shachaf> Hah.
01:29:23 <shachaf> fmap (fmap (fmap fmap fmap fmap (fmap fmap) fmap Left)) f
01:29:33 <latro`a> oh dear
01:29:35 <latro`a> the hell is that
01:29:45 <startling> :t fmap (fmap (fmap fmap fmap fmap (fmap fmap) fmap Left)) f
01:29:47 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a (f2 :: * -> *) b (f3 :: * -> *) (f4 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, SimpleReflect.FromExpr (f4 (f3 (f (f1 (f2 a))))), Functor f4) =>
01:29:47 <lambdabot> f4 (f3 (f (f1 (f2 (Either a b)))))
01:29:56 <startling> wow, two lines
01:30:01 <latro`a> all the functors
01:30:03 <latro`a> all of them
01:30:41 <shachaf> fmap (fmap fmap fmap fmap (fmap fmap fmap fmap (fmap fmap)) fmap Left) ?f
01:30:46 <startling> :t fix fmap
01:30:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
01:30:48 <lambdabot>       Expected type: a
01:30:48 <lambdabot>       Inferred type: f a
01:30:53 <startling> :(
01:30:59 <shachaf> I think that's just more fmaps without any simplification.
01:31:05 <startling> it is
01:31:19 <latro`a> :t fix (>>)
01:31:20 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
01:31:21 <lambdabot>     Probable cause: `>>' is applied to too few arguments
01:31:21 <lambdabot>     In the first argument of `fix', namely `(>>)'
01:31:22 <latro`a> aww
01:31:26 <startling> > let ffffmap = fmap ffffmap
01:31:28 <lambdabot>   not an expression: `let ffffmap = fmap ffffmap'
01:31:34 <latro`a> :t fix (>> putStrLn "lolwut")
01:31:35 <lambdabot> IO ()
01:31:37 <startling> > let ffffmap = fmap ffffmap in ffffmap
01:31:38 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
01:31:39 <latro`a> yay
01:31:57 <latro`a> wait
01:32:03 <latro`a> doesn't that never put anything at the front of the first >>?
01:32:43 <shachaf> I think you want to fix (... >>)
01:32:45 <startling> latro`a: it puts everything in front of the first >>
01:32:53 <startling> (I think?)
01:33:04 <startling> @src fix
01:33:05 <lambdabot> fix f = let x = f x in x
01:33:12 <latro`a> let's do one iterate...then it puts (>> putStrLn "lolwut") >> putStrLn "lolwut"
01:33:20 <latro`a> and continues recursing on the left
01:33:22 <latro`a> so you're right
01:33:26 <latro`a> this way it never does anything
01:33:54 <shachaf> It gets very hot.
01:34:08 <latro`a> holy
01:34:14 <latro`a> it *hemorrhages* memory
01:34:27 <latro`a> goes through a gigabyte in 10 seconds
01:34:33 <latro`a> not even
01:36:22 <startling> latro`a: fix (>> putStrLn "lolwut") ?
01:36:27 <latro`a> yes
01:36:42 <startling> it's a strictly-evaluated infinite thunk, isn't it?
01:36:43 <latro`a> easily allocates a gigabyte in <10 seconds
01:36:52 <latro`a> how would it be strict
01:36:53 <pdxleif> I'm trying to modernize xmonad-utils.  The .cabal list 5 different executables.  Can I specify the build-depends once for all of those?
01:37:00 <startling> latro`a: because you're trying to run it
01:37:05 <latro`a> true
01:37:17 <latro`a> but that doesn't really strictly evaluate the *entire* thunk
01:37:20 <latro`a> though it tries rather hard
01:37:26 <startling> yeah
01:37:37 <startling> latro`a: keep it running
01:37:40 <latro`a> um
01:37:41 <latro`a> no?
01:37:44 <startling> I always wondered whether "fix" ever ends
01:37:47 <latro`a> ...
01:37:54 <latro`a> it definitely ends when you run out of memory >.>
01:38:26 <startling> heh
01:39:07 <amatsu> latro`a: it'd stop evaluating... but would that mean that it's ended?
01:39:30 <callen> so, uh, why can't I import Network.HTTP.Types.Method (methodPost)?
01:39:37 <latro`a> that's a philosophical question
01:39:40 <callen> Network.HTTP.Conduit is installed
01:40:04 <callen> I tried using a cabal file (I don't like being forced to)
01:40:10 <callen>   Build-Depends:     base >= 4 && < 5, HTTP, transformers, bytestring
01:40:38 <callen> Could not find module `Network.HTTP.Types.Method'
01:40:53 <callen> cabal build and ghc file.hs both return that error.
01:41:43 <startling> latro`a, way to go, your ctrl-c just disproved years of work on theorems in the lambda calculus
01:41:54 <callen> startling: what.
01:42:01 <startling> callen: `fix` ends
01:42:06 <startling> callen: latro`a stopped it
01:42:09 <latro`a> lol
01:42:38 <latro`a> also
01:42:48 <latro`a> I wouldn't normally rant about things like this, but
01:43:05 <latro`a> it is really awesome that there is a builtin function in hmatrix to print matrices in TeX format
01:43:27 <latro`a> it is a horrible pain to do that by hand
01:44:02 <startling> cereal is kind of low on the debugging information, huh
01:45:03 <peteriserins> What do people think about Yegge's assertion that Haskell is "conservative"?
01:45:08 <startling> peteriserins: I was puzzled
01:45:10 <osfameron> linky?
01:45:41 <startling> I think python is *much* more conservative
01:45:45 <startling> in culture at least
01:45:54 <peteriserins> Sorry I'm on tablet now, its on g+
01:46:04 <srhb> I think Yegge is trolling the shit out of the Haskell community, like he usually does.
01:46:20 <shachaf> srhb: I think most of the Haskell community doesn't care.
01:46:24 <osfameron> I don't think Yegge trolls, precisely
01:46:25 <srhb> I was sad to see someone try to make a response to it and post it on Reddit... Fuelling the flames.
01:46:26 <callen> it's pretty clear the dude is trolling
01:46:29 <callen> don't feed him
01:46:36 <osfameron> he just writes what's interesting to him
01:46:40 <shachaf> Yep. Let's talk about something exciting instead, like monoids.
01:46:48 <srhb> shachaf: Good idea!
01:46:50 <callen> shachaf: or helping me get my imports working
01:46:59 <peteriserins> It seems like he actually believed it though
01:47:01 <shachaf> Did all y'all read byorgey's paper about monoids?
01:47:09 * osfameron finds http://blog.ezyang.com/2012/08/is-haskell-liberal-or-conservative/ which links to it
01:47:19 <srhb> I still don't really understand what a monoid is <<
01:47:37 <shachaf> srhb: Do you understand what a semigroup is?
01:47:50 <pdxleif> Or a group?
01:47:50 <srhb> Yes
01:47:52 <srhb> And yes
01:48:05 <shachaf> srhb: A monoid is like a semigroup with an identity, or alternatively a group without an inverse.
01:48:14 <latro`a> not necessarily without an inverse :p
01:48:19 <latro`a> (dem forgetful functors)
01:48:26 <peteriserins> I think he doesn't get that in Haskell's case, types actually allow you to write less code.
01:48:27 <latro`a> (sorry, carry on)
01:48:28 <srhb> Um, but semigroups talk about binary operations, yes?
01:48:33 <latro`a> so do monoids
01:48:39 <shachaf> So class Semigroup m => Monoid m where { mempty :: m } -- mempty ++ x = x; x ++ mempty = x
01:48:39 <pdxleif> http://en.wikipedia.org/wiki/File:Magma_to_group2.svg
01:48:40 <latro`a> haskell calls the binary operation mappend
01:48:49 <shachaf> Anyway, read http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
01:48:53 <srhb> Ah.
01:48:54 <latro`a> (or in some of the weird preludes, ++)
01:49:08 <startling> also lambdabot
01:49:13 <shachaf> http://slbkbs.org/out.pdf (warning: has one inaccuracy)
01:49:18 <latro`a> lambdabot is just a weird prelude
01:49:19 <latro`a> :p
01:49:32 <shachaf> (At least one inaccuracy, that is.)
01:49:53 * cesc wishes there was an introductory "haskell for physicists" book around 
01:49:56 <srhb> shachaf: Link doesn't work, does it?
01:50:00 <srhb> cesc: yes!
01:50:30 <startling> I like "magma" much more than "groupoid"
01:50:35 <startling> much more evocative
01:50:41 <Jurily> is it possible to write Gtk applications without it looking like garbage-collected C?
01:50:50 <cesc> coming from fortran (language learned in a couple hours and you're good to go), haskeel seems like an overkill :(
01:50:56 <pdxleif> A set + binary operation on that set = magma.  From there you can add associativity, identity, invertibility, hell, even commutivity...
01:51:02 <cesc> *haskell
01:51:06 <latro`a> jurily: there are various wrappers
01:51:12 <srhb> cesc: Haha, overkill? I don't know, I think it feels like such a relief. :P
01:51:16 <shachaf> srhb: Hmm, weird.
01:51:20 <srhb> shachaf: Yes.
01:51:34 <latro`a> reactive-banana comes to mind, though that may be overkill for small applications
01:51:35 <shachaf> Why is my serve returning HTTP 206?
01:51:40 <pdxleif> I like "groupoid".  You have spheroid, monoid, what have you...
01:51:46 <cesc> srhb: I have never had to go up a learning curve with such a steep derivative to move such little xD
01:51:58 <shachaf> srhb: (Are you the translate.google.dk person?)
01:52:01 <cesc> the quicksort example is nice and so on, but ff =)
01:52:01 <osfameron> hmmm, yegge's article isn't trolling haskell *at all*.  It's taking an idea (liberal/conservative as related to programming) and taking it to *a* logical conclusion.
01:52:08 <srhb> cesc: Yeah.
01:52:20 <srhb> shachaf: I tried that after I tried just going there normally
01:52:36 <startling> how do I skip a bunch of NULLs in cereal?
01:52:53 <peteriserins> cesc: look up some of the quantum stuff done on Haskell, you will see the point
01:53:11 <startling> semiquantoid
01:53:46 * startling wonders whether qubits form a monad
01:53:47 <srhb> shachaf: Must be my browser being broken. The whole domain is acting weirdly :P
01:53:56 * cesc is still to illiterate in haskell to fully appreciate it  (although a number of weeks have gone by)
01:54:01 <shachaf> srhb: No, it's my server being broken.
01:54:06 <srhb> wget works. Hurrah!
01:54:30 <latro`a> ...guess I'll take a shot in the dark before heading to bed
01:54:39 <latro`a> anyone here heard of (or hell, used) numerical continuation?
01:54:47 <latro`a> (has nothing to do with callCC >.>)
01:54:59 <Jurily> 88500 hits for "qubit monad"
01:55:13 <shachaf> srhb: Try now.
01:55:15 <srhb> cesc: I've had those three big brainmelts that make you love Haskell so far
01:55:18 <shachaf> srhb: I just messed with the configuration.
01:55:22 <srhb> shachaf: Nope.
01:55:25 <peteriserins> Is there something simpler than continuations that allows you to return a value from the middle of a monad?
01:55:25 <shachaf> You might need to clear your cache.
01:55:27 <srhb> shachaf: But wget managed to get it.
01:55:29 <shachaf> I did, in Chrome.
01:55:35 <shachaf> Anyway, it's not worth the silly graph. :-)
01:55:42 <srhb> No :P
01:55:44 <cesc> srhb: which three? :)
01:55:48 <startling> peteriserins: what do you mean "Return from the middle"?
01:56:08 <srhb> cesc: I think for me, Functors, Monads and Monad transformers
01:56:11 <shachaf> peteriserins: "the middle of a monad" is phrasing that suggests a lot of confusion about things.
01:56:20 <shachaf> peteriserins: But in this case "Either" might be what you're looking for.
01:56:24 <peteriserins> Sorry middle of do
01:56:39 <shachaf> > either id id $ do { Left "hello"; return
01:56:40 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:56:42 <shachaf> > either id id $ do { Left "hello"; return "hi" }
01:56:43 <lambdabot>   "hello"
01:57:08 <peteriserins> Awesome, thanks
01:57:29 <startling> my brainmelts: "values are nullary functions", ">>= et al are just creating computations to be run later", and "monads and functors let you operate on values that don't exist yet"
01:57:43 <shachaf> startling: Values aren't nullary functions.
01:57:54 <shachaf> I don't know what the other things you said mean.
01:58:02 <startling> shachaf: sure they are
01:58:09 <shachaf> No, they aren't.
01:58:18 <shachaf> @google conal nullary functions
01:58:19 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
01:58:19 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
02:00:20 <startling> shachaf, well okay
02:12:07 <pdxleif> In lambda calculus, everything is a function.  I thought Haskell was like lambda calculus?
02:12:16 <shachaf> pdxleif: Nope.
02:12:22 <shachaf> data Bool = False | True
02:12:37 <shachaf> False and True (and Bool...) are not functions.
02:13:20 <srhb> A function is something that has (->) in its type.. Is that exact enough?
02:14:16 <shachaf> srhb: More specifically, a function is something of type (a -> b) for some a and b.
02:14:41 <shachaf> x :: Maybe (a -> b) isn't a function.
02:15:14 <c_wraith> leif, are you trolling?  I know you know better than that.
02:15:42 <shachaf> Bah. Assume good intentions *one time*...
02:15:56 <srhb> shachaf: Good point.
02:17:14 <shachaf> c_wraith: I guess you're pdxcarl?
02:17:34 <c_wraith> yeah, I'm in PDX
02:17:46 <shachaf> I heard larrytheliquid moved to PDX.
02:17:54 <c_wraith> he's one of my co-workers.  Though the project he's on is much more ruby and scala than haskell.
02:20:41 <pdxleif> They won't let me near the haskell, I don't even know what a function is. :(
02:25:34 <rajan> Hi every1
02:26:00 <srhb> rajan: Hey.
02:26:19 <rajan> hi srhb
02:26:27 <rajan> just starting out on haskell
02:26:49 <rajan> trying to get a feel, of what functional programming is
02:26:51 <rajan> :)
02:27:00 <srhb> rajan: Cool, it's lots of fun getting started. :)
02:27:05 <srhb> And it keeps being fun. ;)
02:27:29 <shachaf> srhb: Actually, 3 years and 8 months into it, it stops being fun.
02:27:33 <shachaf> But by then it's too late to stop.
02:27:37 <shachaf> Turn back while you still can!
02:27:41 <srhb> shachaf: I'm sorry to hear that. :P
02:27:42 <c_wraith> hmm.  I'm nearly there.
02:28:30 * timthelion has been reading Conal Elliot's argument against everything being a function and dissagrees.
02:29:03 <rajan> shachaf : looks like you are getting over it now
02:29:44 * timthelion thinks that every expression evaluates to something...  And the term "function" makes more sense for that "something" than the term value, and that we need a universal term for the something that every valid expression evaluates to.
02:30:01 <srhb> Value?
02:30:06 <srhb> <<
02:30:23 * timthelion thinks that "1ary function" should be our way of expressing the kind *->* and function be our way of expressing all kinds.
02:30:43 <shachaf> timthelion: Unfortunately you're wrong.
02:30:45 <timthelion> srhb: "Value" really makes no sense for "a->b" typed values
02:30:49 <shachaf> Sorry. :-(
02:30:52 <srhb> timthelion: Why?
02:31:11 <shachaf> "* -> *" doesn't mean what you think.
02:31:26 <typoclass> shachaf: takes a type, gives a type?
02:31:32 <timthelion> shachaf: I see no reason, why haskell programmers should use a term which diverges from Both mathematics AND imperitive computer science.
02:31:47 <shachaf> Arguments about words are bad style, though.
02:31:49 <shachaf> So let's not have one.
02:31:59 <shachaf> Instead, go read conal's post. :-)
02:31:59 <timthelion> shachaf: yes, you are right *->* does not mean what I think, sorry about that
02:32:16 <timthelion> shachaf: I read it in it's entirety
02:32:18 <pdxleif> I'm sticking with Church numerals - the heck with you all.
02:32:40 <shachaf> "f (f (f (f (f u))))" -- pdxleif
02:32:46 <timthelion> shachaf: I just think he's full of shit to say that a->b is now going be be named "function" and nothing else
02:32:47 <srhb> I built an abomination. StateT Int (Either Int) Int . And now I don't understand the results of runStateT on it
02:33:08 <shachaf> @unmtl StateT s (Either e) a
02:33:08 <lambdabot> s -> Either e (a, s)
02:33:09 <srhb> On one hand, if I lift $ Left value out of it, I get simply Left value
02:33:15 <shachaf> srhb: It means that. :-)
02:33:27 <srhb> If I lift $ Right value out of it, I get Right (value, state)
02:33:30 <shachaf> "Left" is used for early return -- it jumps out to the place where you runEither.
02:33:36 <srhb> Oh
02:33:40 <srhb> But.. How.
02:33:46 <shachaf> "Right" is just "return" -- it doesn't have any effects.
02:33:52 <srhb> Aha
02:33:54 <shachaf> srhb: Do you understand instance Monad (Either e) on its own?
02:34:02 <srhb> I thought I did, but apparently no.
02:34:15 <typoclass> srhb: it's like the Maybe monad aborting once it hits Nothing
02:34:22 <srhb> Oh, yeah.
02:34:24 <shachaf> Yes, what typoclass said.
02:34:30 <shachaf> Except instead of just aborting, it yields a value.
02:34:35 <srhb> I simplified it in my mind to "they are both Justs"
02:34:38 <srhb> Which is wrong.
02:34:39 <shachaf> And that value goes all the way "up the stack", like exceptions.
02:35:10 <srhb> Oh yes. Thanks. This make much more sense.
02:35:42 <srhb> So if I evalState instead, I will get like results
02:35:47 <srhb> ie Right value, Left value
02:35:57 <shachaf> Note that if you abort, you won't have any state.
02:36:06 <srhb> Yeah.
02:36:07 <shachaf> Maybe EitherT e (State s) a is different in that regard?
02:36:13 <startling> how can I turn a ByteString into a string of hex digits?
02:36:13 <typoclass> i think of Either as an extended Maybe. Nothing won't tell you much about what exactly fails, so you can use Left x in order to attach something to the Nothing, an error message or errno or whatever
02:36:27 <typoclass> @hoogle showHex
02:36:28 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
02:36:35 <shachaf> startling: map toHexDigit . B.unpack
02:36:43 <startling> shachaf: oh nice
02:36:44 <shachaf> Well, concatMap toHexDigits . B.unpack
02:36:49 <shachaf> Since you get two per byte.
02:36:53 <startling> yeah
02:37:11 <srhb> Aaaah, I get it now. Beautiful. Transformers are awesome.
02:37:16 <srhb> Can any Monad have an associated transformer?
02:37:20 <startling> where's toHexDigits?
02:37:41 <shachaf> startling: Doesn't exist.
02:37:52 <shachaf> concatMap (printf "%02x") . B.unpack
02:38:12 <shachaf> srhb: No.
02:38:21 <srhb> shachaf: What's the prerequisite?
02:38:28 <shachaf> I think it's not that simple.
02:39:16 <shachaf> edwardk was saying something about that -- about how every particular monad can be turned into a transformer for a different reason, or something like that.
02:39:32 <shachaf> srhb: Look at the instance for ContT. It's funny.
02:39:37 <srhb> When edwardk says something, most of it goes way over my head. :-)
02:39:51 <srhb> Ok :0
02:40:08 <shachaf> srhb: When he's talking to you in person, it makes a lot more sense!
02:40:32 <srhb> Ah, I'll remember that. I can make a vacation out of learning comonads or something. :-)
02:40:55 <shachaf> Pft. On vacations, you should come to CA rather than MA!
02:40:58 <shachaf> It's the place to be, I hear.
02:41:09 <srhb> Oh, I would for sure. ;)
02:41:13 <typoclass> shachaf: i thought WA is where the kitties are
02:41:46 <shachaf> typoclass: There are kitties here too.
03:04:07 <startling> is there an opposite to floor somewhere?
03:04:13 <shachaf> ceiling?
03:04:14 <c_wraith> ceiling?
03:04:17 <c_wraith> damn it
03:04:18 <c_wraith> too slow
03:04:24 <startling> that's the one. thanks!
03:04:35 <shachaf> @google is there an opposite to floor somewhere?
03:04:36 <lambdabot> http://www.pagetutor.com/jokebreak/052.html
03:04:37 <lambdabot> Title: Survival Guide for Taking a Dump at Work
03:04:40 <c_wraith> what?
03:04:42 <shachaf> Hmm, maybe Google isn't optimal here.
03:05:01 <c_wraith> If that is optimal..  I'm scared.
03:05:13 <DT``> oh wow.
03:07:26 <mreh> should writeFile write relative to the directory the program is invoked from when given a relative file path?
03:07:32 <mreh> shouldn't*
03:07:37 <mreh> I'm on *nix
03:07:42 <startling> mreh: yep
03:08:04 <mreh> must be something i'm doing wrong then
03:10:02 <mreh> yeah, i'm naming the output file after the input file by default, but I'm forgetting to strip of all the other path info from the input file argument
03:12:49 <mreh> i suppose chucking out everything out before and including the last dir slash would be reliable
03:13:17 <mreh> unless it's escaped...
03:13:28 <mreh> why is life so hard
03:13:54 <startling> haskell should use non-empty lists for paths
03:14:41 <shachaf> Haskell should use ByteStrings for paths.
03:14:43 <Eduard_Munteanu> mreh: http://hackage.haskell.org/packages/archive/filepath/1.2.0.0/doc/html/System-FilePath-Posix.html
03:14:54 <startling> shachaf: ew
03:15:09 <Eduard_Munteanu> See takeBaseName for example.
03:15:59 <mreh> I was hoping someone would know what I wanted :)
03:22:02 <hiptobecubic> What kind of problems make you think "haskell will make solving this a pain in the ass." ?
03:48:50 <SebastienGllmt> data structures?
03:49:54 <startling> hiptobecubic: file i/o
03:49:56 <shachaf> SebastienGllmt: Yes.
03:50:06 <shachaf> Oh, that was in response to something.
03:50:13 <shachaf> Can something be done about pommes_?
03:50:23 <SebastienGllmt> yeah I was late to the ball on that one
03:51:01 <shachaf> That seems like an odd response.
03:51:12 <hiptobecubic> startling, file io? Why?
03:51:48 <shachaf> There ought to be a rule about asking that kind of question. It always leads to tears.
03:51:53 <mekeor> did you see/read oleg's new article "Representing existential data types with isomorphic simple types" <http://okmij.org/ftp/Computation/Existentials.html> ?
03:52:53 <mekeor> well, i think it's not quite new… "Last updated October 5, 2008" hehe
03:53:18 <mekeor> but he posted it on the mailing-list today…
03:53:49 <SebastienGllmt> Well my answer's not worth much since I literally just started learning Haskell today
03:53:51 <shachaf> In response to a question, it looks like.
03:54:12 <shachaf> pommes_: Can you do something about all these joins and quits?
03:54:14 <shachaf> Bah.
03:56:20 * mekeor can hide joins and quits now, thanks to bitonic =)
03:56:22 <shachaf> There's a nice duality between existential over Show and universals over Read.
03:56:46 <shachaf> For Show you have exists a. (a, a -> String), which is isomorphic to String.
03:57:00 <shachaf> For Read you have forall a. (String -> a) -> a, which is also isomorphic to String. :-)
03:58:10 <mekeor> is it? how?
03:58:39 <shachaf> @ty flip id
03:58:40 <lambdabot> forall a b. a -> (a -> b) -> b
04:01:34 <mekeor> ah, nice, you can directly type ":main arg1 arg2 …" in ghci without having to ":set args arg1 arg2 …".
04:08:57 <startling> if I turn line 210 into do notation and then add "let y = fromIntegral $ size s :: Integer", I get a type error that the type of size s cannot be Word64.
04:09:02 <startling> does that make sense to anyone?
04:09:29 <shachaf> (foo $ bar :: Baz) === ((foo $ bar) :: Baz)
04:09:51 <startling> shachaf: sure
04:09:58 <timthelion> > {-too bad-}let f = 3 4 in (+) f
04:10:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
04:10:00 <lambdabot>    arising from a use of `...
04:10:08 <shachaf> Oh, maybe I misread.
04:10:14 <shachaf> I have no idea what line 210 is.
04:10:27 <timthelion> > {-I'd like that to be the same as-} 3+4
04:10:28 <lambdabot>   7
04:10:29 <startling> oh right, forgot the url https://github.com/startling/maquina/blob/macho/Data/Macho/Concrete.hs
04:10:34 <shachaf> And "the type of size s cannot be Word64" doesn't sound like a type error GHC would produce. :-)
04:10:51 <shachaf> timthelion: Well, you shouldn't want that!
04:11:12 <startling> "Couldn't match expected type `Word64' with actual type `Word32'", for the function on line 245, all the way on the bottom
04:11:13 <shachaf> > let plus (x,y) = x + y; f = (3,4) in plus f
04:11:14 <lambdabot>   7
04:11:20 <startling> which calls the one on 210
04:11:46 <timthelion> shachaf: it would make sense, that a value of type a applied to a value of type b would come up with some value of type "a <- b" that when applied to an "a -> b -> c" would then resolve to a value of type c
04:12:08 <shachaf> startling: Can you hpaste the full *actual* code you're using, as well as the full error from GHC?
04:12:15 <shachaf> Line 210 is blank in the URL you gave.
04:12:18 <timthelion> shachaf: I know you can do it with tuples, but I'm talking about the type system here :)
04:12:37 <shachaf> timthelion: "3 4" isn't a value.
04:12:50 <Maxdamantus> So "a -> b -> c" is the same as "(a <- b) -> c"?
04:12:51 <timthelion> >t: 3 4 -- shachaf:
04:13:00 <shachaf> let f = 3 4 in (+) f means the same as (+) (3 4)
04:13:00 <SebastienGllmt> Could somebody explain to me why ' ' and " " seem to be so different in Haskell and what exactly the difference is?
04:13:01 <timthelion> :t 3 4 -- shachaf:
04:13:03 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
04:13:06 <startling> shachaf: yeah, sec
04:13:19 <XexonixXexillion> SebastienGllmt: ' ' is for characters, " " is for strings
04:13:21 <amatsu> SebastienGllmt: ' ' refers to the space Char, " " is a list containing that character.
04:13:26 <shachaf> timthelion: You want a crazy overloaded Num instance to make that work?
04:13:35 <shachaf> You can't do it even with a crazy overloaded Num instance.
04:13:36 <Maxdamantus> let f = succ [1..] in map f
04:13:55 <timthelion> shachaf: no, I just want there to be a type "extra values on the stack that will be applied to the next function that wants them"
04:14:22 <timthelion> I don't care about Num instances...
04:14:45 <hpaste> startling pasted “full *actual* code I'm using” at http://hpaste.org/72958
04:14:47 <shachaf> timthelion: That's not how Haskell syntax works.
04:14:52 <startling> ^^ error is at the bottom
04:14:58 <timthelion> shachaf: too bad
04:15:32 <SebastienGllmt> so if I type ['a','b'] it puts the chars together as an array to form "ab" but if I type ["a","b"] it doesn't merge strings because it treats them as separate things, right?
04:15:37 <shachaf> startling: Can you add some type signatures for r and f and all those?
04:15:52 <shachaf> SebastienGllmt: "ab" is just a special way of printing ['a','b']
04:16:01 <shachaf> A string is just a list of characters.
04:16:20 <shachaf> There's no special way of printing a list of strings, so you can only get ["a","b"].
04:18:07 <gertc> Data.Binary I do not understand why put needs a t parameter and get does not?
04:18:22 <SebastienGllmt> so why isn't "ab" : [] == "ab" valid?
04:18:25 <hpaste> startling annotated “full *actual* code I'm using” with “full *actual* code I'm using (annotation)” at http://hpaste.org/72958#a72959
04:18:30 <startling> shachaf: ^
04:19:01 <timthelion> SebastienGllmt: because the type of "ab" : [] is [[Char]]
04:19:03 <shachaf> SebastienGllmt: Because ("ab : []) is ["ab"] -- a (one-element) list of strings.
04:19:03 <XexonixXexillion> SebastienGllmt: (:) add an item to a list, not a list to a list. use (++) for putting a list to a list
04:19:42 <Maxdamantus> gertc: what's the "t" parameter?
04:19:58 <startling> shachaf: the idea is that the Mach-O format can be read either as little-endian or big-endian, so you pass in a Get Word32 for all the specified Word32s and a Get w where w is either Word32 or Word64 for all the platform size-dependent fields
04:20:08 <SebastienGllmt> XexonixXexillion mind explaining that into more detail?
04:20:16 <gertc> Maxdamantus, put :: t -> Put
04:20:26 <startling> SebastienGllmt: a:[] = [a]
04:20:30 <Maxdamantus> gertc: yes. But what's the t parameter for?
04:20:33 <typoclass> > 'a' : "bc"
04:20:34 <lambdabot>   "abc"
04:20:35 <SebastienGllmt> but I mean the ++ thing
04:20:42 <typoclass> > "a" : "bc" -- that's an error
04:20:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:20:43 <lambdabot>         against inferred ty...
04:20:55 <startling> SebastienGllmt: [a] ++ [b, c] = [a, b, c]
04:21:10 <startling> SebastienGllmt: a : [b, c] = [a, b, c]
04:21:11 <SebastienGllmt> thank you :)
04:21:12 <typoclass> > "ab" ++ "cd"
04:21:14 <lambdabot>   "abcd"
04:21:17 <shachaf> startling: Right, that idea seems sound.
04:21:28 <shachaf> s/sound/reasonable/
04:21:31 <mekeor> :D
04:21:50 <gertc> Maxdamantus, defining what type to put in? But why does get figures that out by it self?
04:22:21 <timthelion> >concatMap id ("a":["bc"])
04:22:34 <startling> shachaf: and I'm trying to consume up to the boundary in parseSection, but any time I try to do any arithmetic on the size or alignment boundary of that Section, I get that type error
04:22:35 <timthelion> > concatMap id ("a":["bc"])
04:22:36 <lambdabot>   "abc"
04:22:38 <Maxdamantus> gertc: succ :: Int -> Int
04:22:39 <timthelion> :)
04:22:48 <shachaf> startling: Sounds like you need more fromIntegral.
04:23:03 <shachaf> startling: You should add a type signature to parseSection. :-)
04:23:04 <startling> shachaf: but if I even stick that one line in, i get that error
04:23:06 <shachaf> (And to everthing else.)
04:23:14 <Maxdamantus> gertc: it's not just a type parameter.
04:23:38 <startling> shachaf: I had a bunch, but I kept getting "couldn't infer whatever against bound type variable ...", so I thought I might have more luck without them
04:23:50 <shachaf> Bound type variable?
04:24:06 <shachaf> You should know what type your function has.
04:24:39 <Maxdamantus> :t id
04:24:40 <lambdabot> forall a. a -> a
04:24:45 <Maxdamantus> :t id 4
04:24:47 <lambdabot> forall t. (Num t) => t
04:24:57 <Maxdamantus> :t put 5
04:24:59 <startling> shachaf: "rigid type variable bound by the type signature" etc etc etc, I mean
04:24:59 <lambdabot> forall t (m :: * -> *). (Num t, MonadState t m) => m ()
04:25:22 <Maxdamantus> :t put (5 :: Int)
04:25:24 <lambdabot> forall (m :: * -> *). (MonadState Int m) => m ()
04:25:35 <shachaf> startling: Sounds like a good error message to get.
04:25:49 <shachaf> If your function is working without a type signature and not with, it means you don't know what its type is.
04:26:05 <gertc> Maxdamantus, data constructer?
04:26:47 <Maxdamantus> gertc: no. `put` is a function, so it takes a value and gives one back.
04:26:51 <Maxdamantus> gertc: just like `succ`
04:27:07 <startling> shachaf: sure. putting it in (parseSection :: Integral w => Get Word32 -> Get w -> Get (Section w)) gets me the error at the bottom of the paste still, though
04:27:27 <Maxdamantus> gertc: but instead of taking something like `Int` and giving back an `Int`, it takes something like `Int` and gives back a `Put`
04:28:11 <typoclass> startling: you could load your file in ghci (without the problematic signature) and check what ghc infers for the type (:t foo), then compare that to your signature
04:28:45 <shachaf> startling: Your code is confusing me. :-(
04:28:46 <startling> typoclass: yep, that's what I'm doing. the signatures aren't problematic, I don't think.
04:28:52 <startling> shachaf: sorry. there's quite a bit
04:28:55 <shachaf> All these one-letter variable names and things.
04:29:03 <shachaf> l m v w f r
04:29:22 <shachaf> And x, what's x?
04:29:23 <timthelion> shachaf: NOW you're on my side :)
04:29:27 <shachaf> Is it universally quantified?
04:29:43 <shachaf> timthelion: I have nothing against one-letter variable names.
04:29:44 <startling> shachaf: l just sticks a Left onto the result of f
04:29:59 <gertc> Maxdamantus, ok but get is also a function? and it just returns T out of thin air?
04:30:06 <shachaf> Oh, x is just unused, right.
04:30:18 <startling> shachaf: x is just taken out of the Just
04:30:21 <timthelion> shachaf: so why are you complaining about one letter variable names again?
04:31:11 <Maxdamantus> gertc: no.
04:31:32 <typoclass> startling: anyway, i bet it's the DMR
04:31:45 <SebastienGllmt> is there a way to use map with negative numbers like map (-1) [3..5]
04:31:58 <shachaf> startling: Maybe you should get rid of l and r -- the names aren't helping with clarity, I think. Just 0xfeedface -> Left <$> f m getWord32le getWord32le, etc.
04:32:02 <typoclass> > map (subtract 1) [3..5]
04:32:03 <lambdabot>   [2,3,4]
04:32:13 <gertc> Maxdamantus, get :: Get t
04:32:14 <startling> typoclass: nope, tried that already
04:32:17 <startling> shachaf: can do
04:32:33 <Jafet> > map (-1) [3..5]
04:32:33 <Maxdamantus> gertc: yes. It's a value of type `Get t`
04:32:34 <lambdabot>   [-1,-1,-1]
04:32:44 <shachaf> @src replicateM
04:32:44 <lambdabot> replicateM n x = sequence (replicate n x)
04:32:46 <startling> shachaf: I actually had a lot more code there when I made l and r, so they're a bit extraneous now
04:33:01 <gertc> Maxdamantus, i expected get :: t -> Get t
04:33:04 <typoclass> SebastienGllmt: ^^ here you go. "-1" collides with the negative number "-1", so we have subtract instead
04:33:04 <shachaf> Anyway, I forgot what you were asking.
04:33:12 <Maxdamantus> gertc: what would you give get?
04:33:20 <XexonixXexillion> gertc: what would the t be?
04:33:29 <mekeor> > map (+(-1)) [3..5]
04:33:30 <lambdabot>   [2,3,4]
04:33:40 <shachaf> mekeor: Let's not start with that again.
04:33:46 <mekeor> okay
04:33:47 <shachaf> Not when someone is asking an actual question.
04:33:57 <Jafet> > map (- 1) [3..5]
04:33:59 <lambdabot>   [-1,-1,-1]
04:33:59 <gertc> Maxdamantus, the same as de t from put? put :: t -> Put t
04:34:06 <startling> shachaf: me? heh. I'm getting that error at the bottom once I put in line 213
04:34:16 <Jafet> Wat
04:34:18 <SebastienGllmt> typoclass what do you mean "collides"
04:34:24 <mekeor> Jafet: that's lambdabot…
04:34:28 <mekeor> > 1 2 -- Jafet
04:34:30 <lambdabot>   1
04:34:33 <Maxdamantus> gertc: the `t` in `t -> Put t` is representing the argument you're meant to give to the function.
04:34:36 <Jafet> Why does - 1 lex to negate 1
04:35:06 <mekeor> Jafet: - is the only exeption in haskell because we need - to write negative numbers…
04:35:07 <shachaf> startling: What's the type of w?
04:35:08 <startling> Jafet: Num n => a -> n is an instance of Num in lambdabot
04:35:11 <mekeor> :t (-1)
04:35:13 <lambdabot> forall a. (Num a) => a
04:35:19 <shachaf> startling: *Please* add a type signature. It'll help you think about this.
04:35:23 <startling> shachaf: either Word32 or Word64
04:35:28 <shachaf> In this case, maybe you want a rank-2 type.
04:35:28 <gertc> Maxdamantus, aaaa is see somthing now its not put :: t -> Put t its put :: t -> Put :)
04:35:30 <Maxdamantus> gertc: it's similar to something like `getLine`
04:35:32 <Jafet> Integers shouldn't have spaces in them
04:35:33 <shachaf> ...Or something.
04:35:46 <mekeor> Jafet: hm… yea
04:36:10 <shachaf> startling: Wait, if it's a Word32, why are you using it with <*>?
04:36:27 <startling> shachaf: oh, it's a Get Word32 or Word64
04:36:30 <startling> my bad
04:36:44 <typoclass> SebastienGllmt: (-1) could plausibly be the negative number -1, or it could be a "section". in haskell, it's always taken to be a negative number. if you want the other thing, use subtract
04:36:58 <Jafet> > -             3.14
04:36:59 <lambdabot>   -3.14
04:37:02 <typoclass> > let f = (/ 3) in f 21 -- and this is a section
04:37:03 <lambdabot>   7.0
04:37:15 <shachaf> startling: I have no idea what's going on in your question anymore.
04:37:50 <gertc> Maxdamantus, ok it slowly starts to make sense thx :)
04:38:14 <startling> shachaf, you mean you have no idea what's causing the error or you have no idea what's happening at all?
04:38:46 <mikeplus64> > 1 == -1
04:38:47 <lambdabot>   False
04:38:52 <typoclass> SebastienGllmt: section means you take an operator (/  +  *  ...) and fix one of its arguments, but not the other. it's written in parens like (/ 6) or (3 /) or (1 +)
04:38:54 <mikeplus64> > 1 == (-)1
04:38:55 <lambdabot>   *Exception: (==): No overloading for function
04:39:03 <mikeplus64> huh?
04:39:19 <shachaf> startling: Can you put up some code that can fail in my ghci?
04:39:22 <startling> shachaf: I think I got it, regardless, but I'm not sure how
04:39:23 <shachaf> Your @paste loads fine for me.
04:39:31 <SebastienGllmt> thanks :)
04:39:43 <startling> shachaf: weird. let me git diff and investigae
04:39:45 <mikeplus64> why doesn't it say an error like "No instances for Num (a -> b) ?
04:39:46 <mikeplus64> oops
04:39:56 <mikeplus64> "
04:40:03 <shachaf> mikeplus64: lambdabot has weird instances.
04:40:03 <typoclass> mikeplus64: that parses as "1", then "==", then the 2-arg function (-), then another "1"
04:40:19 <typoclass> SebastienGllmt: you're welcome
04:40:34 <mikeplus64> shachaf: ah
04:40:36 <startling> shachaf: thanks for your time, btw
04:40:58 <shachaf> startling: It's probably a good habit to get into to put type signatures on all your top-level functions.
04:41:09 <gertc> Maxdamantus, ok comparing it with getLine and putStrLn does make it clear now :)
04:41:12 <shachaf> Especially when you're getting weird type errors and asking questions about them. :-)
04:41:17 <shachaf> It makes reading the code much easier.
04:42:01 <startling> shachaf: will do. usually I add them in when I'm finishing up the code, but they can probably be useful for debugging
04:42:49 <XexonixXexillion> startling: you add them after the code? I find adding them before the code is easier :p
04:43:43 <startling> XexonixXexillion: depends. sometimes I change it too quickly for it to be convenient
04:44:07 <SebastienGllmt> how would I do something like filter (not ==3) [3,5,7]
04:44:13 <SebastienGllmt> I feel kind of bad for asking all these questions
04:44:29 <startling> filter (/= 3) [3, 5, 7]
04:44:40 <startling> > filter (/= 3) [3, 5, 7]
04:44:42 <lambdabot>   [5,7]
04:44:44 <Jurily> write the function first, then copy the signature from ghci when you're done
04:44:47 <Jafet> If something is too ephemeral for its type to be written down first, it may not belong at the top level
04:45:02 <Jafet> > filter (\x -> not (x == 3)) [3,5,7]
04:45:03 <lambdabot>   [5,7]
04:46:37 <SebastienGllmt> Would there be a way to do something like filter(/>=3) [3,5,7] without using <
04:46:43 <SebastienGllmt> Or, well, I guess Jafet's thing would work
04:46:50 <typoclass> > filter (not . (== 3)) [3,5,7] -- SebastienGllmt. this works too. the dot basically means: put the argument into the right function (== 3), take its output (a Bool) and put it into the function "not"
04:46:52 <lambdabot>   [5,7]
04:46:55 <XexonixXexillion> > filter (not . (>=3)) [3,5,7]
04:46:57 <lambdabot>   []
04:47:15 <XexonixXexillion> > filter (not . (>=3)) [3,5,7,2]
04:47:17 <lambdabot>   [2]
04:47:54 <Jurily> filter (not . (3 >=)) [3,5,7,2]
04:49:16 <Maxdamantus> > map (\x ->- x) [3..5]
04:49:18 <lambdabot>   <no location info>: parse error on input `->-'
04:52:14 <hiptobecubic> Is there a way to get lambdabot to show the source for an instance of a typeclass?
04:52:24 <hiptobecubic> specifically monoid for Orderings?
04:52:43 <shachaf> hiptobecubic: No, but you can look it up.
04:53:11 <shachaf> @google "instance Monoid Ordering"
04:53:13 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Monoid.html
04:53:13 <lambdabot> Title: Data/Monoid.hs
04:53:20 <mekeor> shachaf: but lambdabot *had* such a feature, right?
04:53:41 <bdirks> Have any serious chess engines been written in Haskell?
04:53:56 <startling> bdirks: only funny ones
04:54:05 <zhulikas> 4
04:54:20 <bdirks> Ok, elo > 2300, if that's a better definition
04:54:23 <startling> :instance Monoid Ordering
04:54:31 <startling> @instance Monoid Ordering
04:54:32 <lambdabot> Maybe you meant: instances instances-importing
04:54:43 <startling> @instances Monoid
04:54:44 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
04:55:04 <zhulikas> > filter (\a -> not $ a >= 3) [3,5,7]
04:55:05 <lambdabot>   []
04:55:06 <zhulikas> > filter (not . (>= 3)) [3,5,7]
04:55:08 <lambdabot>   []
04:55:17 <zhulikas> any reasons not to use lambdas here?
04:55:20 <zhulikas> and anywhere in general
04:55:29 <SebastienGllmt> what just happened?
04:55:39 <shachaf> mekeor: No, lambdabot never had a feature that would show you the source of "instance Monoid Ordering".
04:55:40 <timthelion> SebastienGllmt: nothing?
04:55:54 <SebastienGllmt> My comment was directed at zhulikas
04:56:18 <mekeor> shachaf: ok
04:56:34 <zhulikas> are lambda expressions evaluated every time or are somehow cached?
04:56:44 <shachaf> What does that mean?
04:56:47 <zhulikas> damn
04:56:58 <zhulikas> ok
04:57:00 <Jurily> why does instance Monoid Ordering exist? Seems pointless to me.
04:57:12 <shachaf> Because Ordering is a monoid.
04:57:17 <shachaf> Next question? :-)
04:57:59 <shachaf> > sortBy (comparing length ++ compare) ["q","blah","hello","abcd","hmph"] -- This uses (Monoid Ordering) *and* (Monoid (a -> b))!
04:58:01 <lambdabot>   ["q","abcd","blah","hmph","hello"]
04:58:08 <mekeor> zhulikas: there's actually no real difference between that lambda expression and that function composition but sometimes one of those methods looks better or is easier to extend.
04:58:17 <timthelion> zhulikas: they are evaluated every time.  We have a think called scope. if something is given a name in a scope, say let f = foo in then that thing(f) will be evaluated once per argument, for the duration of that scope.  But lambdas, not having a name will not be(as far as I know)
04:58:26 <mekeor> zhulikas: see http://www.haskell.org/haskellwiki/Pointfree
04:59:04 <zhulikas> timthelion, that's what I was wondering about! and sorry for a badly formed question
04:59:08 <shachaf> timthelion: I don't think zhulikas's question had enough meaning to be able to answer it. :-)
04:59:18 <shachaf> I also don't think your answer is accurate.
05:00:00 <zhulikas> shachaf, I think it's quite accurate because I have similar thought about lambdas from somewhere (maybe I read it somewhere, maybe it's just my imagination) so I needed someone to confirm it
05:00:44 <timthelion> shachaf: you may be right.  If we have function f = g (\x->x), and g lx = lx then for the duration of g(while lx is a named value, and not a lambda, it will be cached)
05:01:12 <shachaf> zhulikas: Well, maybe I just have no idea what question you're asking.
05:01:37 <zhulikas> that's why it's good to have 800 people around so atleast someone would get what I mean
05:01:37 <shachaf> zhulikas: Can you give an example of some code that would be different if they were cached from if they weren't?
05:01:37 <zhulikas> :D
05:01:42 <shachaf> Operationally, that is.
05:01:43 <timthelion> but for most uses of the lambda, there's really no point in caching, a lambda passed to map, for example, will have to be re-evaluated for every item of the list
05:02:07 <shachaf> zhulikas: I'm not sure that you get what you mean. :-)
05:02:25 <Jurily> or it can be optimized out entirely
05:02:25 <zhulikas> shachaf, it makes sense only in head!
05:03:05 <shachaf> zhulikas: So you can't give an example?
05:04:11 <mekeor> shachaf: effectively, he's just asking whether lambdas or function compositions are efficienter, i think.
05:04:55 <shachaf> Huh?
05:04:58 <XexonixXexillion> mekeor: s/efficienter/more efficient
05:06:35 <mekeor> XexonixXexillion: oh, right =) sorry :)
05:06:50 <timthelion> zhulikas: if you are thinking of f = ((\x->x) 1) + ((\x->x) 1)) verse f = let g x = x in (g 1) + (g 1), they are actually identical, because g will be inlined. But if ghc wasn't smart enough, then g 1 would be cached, and then it would be less efficient, since inlining is better in that case
05:07:15 <timthelion> amiright about that???
05:07:34 * timthelion isn't 100% sure
05:07:51 <Jurily> http://www.haskell.org/haskellwiki/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
05:10:07 <timthelion> Jurily: so basically, one has to do "let g x = x ; g1 = g 1 in g1 + g1 to get any caching?
05:12:10 <Jurily> pretty much, yes
05:12:13 <nus> @wiki memoization
05:12:13 <lambdabot> http://www.haskell.org/haskellwiki/memoization
05:12:47 <mekeor> nus: cool, thanks
05:12:59 <timthelion> zhulikas: so I was a tiny bit more optimistic than I should have been in GHC's case...
05:13:18 <zhulikas> I failed to give an example
05:13:27 <zhulikas> as I wrote a recursive expensive function and executed it a couple of times
05:13:35 <zhulikas> and expected it to execute immediately for the second time
05:13:38 <zhulikas> as I thought it would cache
05:14:43 <timthelion> zhulikas: well read Jurily's link and that will explain what needs to be done...
05:14:46 <zhulikas> ok then, forget the whole thing
05:15:11 <zhulikas> it was a mistake to try bringing a question without proper explanations
05:16:07 <zhulikas> but if this was accurate (it isn't, according to shachaf) and true, it would be the answer I needed
05:16:08 <zhulikas> <timthelion> zhulikas: they are evaluated every time.  We have a think called scope. if something is given a name in a scope, say let f = foo in then that thing(f) will be evaluated once per argument, for the duration of that scope.  But lambdas, not having a name will not be(as far as I know)
05:16:41 <zhulikas> and so I thought GHC handles point-free functions differently than lambdas
05:19:23 <nus> http://stackoverflow.com/questions/9439470/evaluation-strategy
05:20:48 <shachaf> zhulikas: You mean, if you call it with the same argument, it'll avoid doing the computation the second time?
05:21:01 <zhulikas> indeed
05:21:27 <zhulikas> and yes, I know that's what memoization is for
05:21:27 <shachaf> That's called "memoization", and no, it won't happen automatically in just about any Haskell implementation.
05:21:31 <Jurily> I'm under the impression that pointfree expressions can be optimized better via rewrite rules
05:21:42 <shachaf> It's very different from "caching a lambda". :-)
05:22:28 <shachaf> Anyway, /me >>= sleep
05:22:34 <zhulikas> by Haskell implementation you mean compiler/etc ? or programmer's code
05:22:46 <mekeor> shachaf: g'night!
05:22:51 <zhulikas> nite
05:23:08 <sipa> zhulikas: he means the compiler
05:23:22 <mekeor> @time shachaf
05:23:24 <lambdabot> Local time for shachaf is Sat Aug 11 05:23:01 2012
05:23:28 <sipa> and runtime
05:23:32 <zhulikas> ok
05:23:43 <zhulikas> I assume most of us here use GHC
05:23:50 <sipa> yes
05:25:14 <Jurily> on a related note, are there even any other implementations that do Haskell2010?
05:56:17 <Athas> Jurily: isn't Haskell2010 just a canonisation of previously rather widespread extensions?
05:56:32 <Taneb> And a removal of n+k patterns
05:57:49 <sipa> Athas: define "widespread"? already-implemented-for-some-time-in-GHC, or practically-every-implementation-ever-supported-it
05:59:23 <gertc> why does savecopy uses Data.Serialize only? i was working on a answer and realized i could not use Data.Binary.Put see answer http://stackoverflow.com/questions/11889387/haskell-safecopy-example
05:59:54 <Athas> sipa: I'm not too sure about pattern guards (although they're so simple), but I've seen the other parts in non-GHC implementations.
06:00:49 <sipa> Athas: right, just checked the list; i thought there were more changes
06:01:54 <Athas> Unfortunately not.
06:06:49 <gertc> should i ask the question in a different stackoverflow question or at it as a comment?
06:07:01 <gertc> to the answer
06:36:48 <mysticc> What do you generally use in place of http://hpaste.org/72960 .. I have too many nested cases which look really bad ..
06:38:08 <DT``> mysticc, maybe performA1 performA2 a
06:38:12 <byorgey> mysticc: maybe performA1 performA2
06:38:35 <byorgey> mysticc: if you have lots of nested cases on Maybe, you should also consider using the Maybe monad
06:38:42 <byorgey> i.e. use  >>=  or  do-notation
06:43:16 <mysticc> byorgey: When I use Maybe monad .. suppose the inner Monad is m .. I get something of type Maybe (m a) .. Now I am again in the same place ..
06:45:03 <byorgey> mysticc: you can use  MaybeT m
06:45:56 <byorgey> oh, wait, sorry, MaybeT m a = m (Maybe a),  not Maybe (m a)
06:46:29 <byorgey> but perhaps you can use MaybeT anyway
06:46:39 <byorgey> if what you want to do is combine some monad m with possible failure
06:48:16 <zhulikas> @hoogle String -> (a -> b)
06:48:16 <lambdabot> Debug.Trace trace :: String -> a -> a
06:48:17 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
06:48:17 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
06:48:29 <zhulikas> is there a way to parse Strings into Haskell functions?
06:50:23 <mikeplus64> zhulikas: http://hackage.haskell.org/package/hint
06:50:41 <zhulikas> thanks
06:56:45 <mvj4> (Data.Accelerate) how would you write a map over folds? the map-function operates over functions that generates Exp a, but the fold will result in an Acc-array.
06:57:47 <mvj4> one way would be to evaluate each map-element with Backend.run() and extract the Exp-result, but that doesn't look too great.
06:59:09 <mvj4> (Data.Array.Accelerate) *
07:00:52 <den_> which is the best book to learn haskell?
07:01:30 <mvj4> learn you a haskell is great and really fun to read.
07:01:51 <mvj4> I guess this is a quite common question, search for some basic reviews.
07:02:16 <mvj4> (for me a mix of RWH and LYAH did it :)
07:02:26 <Athas> I dislike Learn You A Haskell, but I like Programming in Haskell and Real World Haskell (in that order).
07:02:31 <den_> "Learn you a haskell"> IS that the name you said
07:03:09 <den_> Ok..something thatr is easy on thre first go
07:04:15 <den_> http://www.amazon.com/Programming-Haskell-Professor-Graham-Hutton/dp/0521692695
07:04:22 <zhulikas> real world haskell is too hard for a beginner I think
07:04:26 <zhulikas> at least it was too hard for me
07:04:41 <zhulikas> but LYAH was perfect
07:04:42 <den_> Is this book good? From amazon
07:05:49 <den_> Is haskell good in performance than php?
07:06:16 <zhulikas> :D
07:06:26 <zhulikas> den_, I think compared to php, haskell does pretty well :D
07:06:35 <Athas> The GHC generates faster code than any PHP implementation, yes.
07:07:24 <den_> not sure what GHC means, sounds like compiler to me.
07:07:44 <zhulikas> it is a compiler
07:08:11 <den_> is it loosely types language?
07:08:19 <den_> *typed
07:08:23 <zhulikas> strictly typed
07:08:28 <sipa> and strongly
07:08:39 <zhulikas> and heavily :D
07:08:51 <den_> aah...thats nice
07:08:51 <sipa> and extensively
07:09:05 <zhulikas> den_, to learn Haskell after php is almost like picking up programming for the first time in your life :D
07:09:10 <isomorphic> Is there a way to find out which packages depend on a given package on hackage (or elsewhere)?
07:09:24 <den_> I know php is very easy to implement..
07:09:40 <iamtakingiteasy> implement php?
07:09:45 <den_> But I know a bit of C++
07:09:45 <iamtakingiteasy> you mean implement php interpereter?
07:09:52 <sipa> php is impossible to implement
07:10:05 <den_> no i mean writing php code
07:10:05 <sipa> you'd have to do it bug-for-bug exactly
07:10:14 <iamtakingiteasy> as wine guys did
07:10:43 <sipa> den_: writing code in php, at least for small programs, will typically be faster
07:10:53 <sipa> den_: but the chances that it works the first time are small
07:11:01 <sipa> in haskell it's often the opposite
07:11:08 <den_> I use php with APC for best performace..
07:11:11 <zhulikas> I've never written a big program in Haskell
07:11:41 <zhulikas> can it be because codebase doesn't grow fastly?
07:12:05 <sipa> oh yes, you can often do a lot more in much fewer lines of code
07:12:11 <den_> I a mcurrently in dilemma between haskell and Lua
07:12:12 <sipa> though that takes some experience
07:12:30 <mysticc> Is writeTVar in STM strict ?
07:12:45 <ParahSailin> since you sound like a beginner, learning haskell would be good for you
07:13:31 <sipa> den_: it's mostly a very different way of thinking, and if you start writing haskell you'll probably be tempted to write a php-style (imperative) program translated to haskell, instead of using the haskell (functional) way of dealing with problems
07:13:37 <Athas> zhulikas: even GHC is not that many lines of code, and that's the biggest Haskell program I know of.
07:13:56 <zhulikas> how many lines of code?
07:13:57 <sipa> den_: and i found that different way of thinking very educational, even when i'm using other languages now
07:14:47 <Athas> zhulikas: depends on how you count, but the 'compiler' directory contains 141k SLOC.
07:14:48 <den_> @sipa..I lost context
07:14:48 <lambdabot> Unknown command, try @list
07:15:21 <Athas> The RTS is about 50k SLOC of C, and then there's of course standard libraries...
07:15:32 <singpoly1a> What would people reccomend as a crash course in Arrows?
07:16:02 <sipa> den_: never mind then :)
07:16:05 <zhulikas> I C :)
07:17:02 <Athas> singpoly1a: Programming in Arrows: http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf
07:17:08 <Athas> It also has fun exercises.
07:17:35 <Athas> It's not completely up-to-date, but the differences are minor.
07:18:05 <singpoly1a> Athas: that link gives me a Forbidden message
07:18:06 <Athas> The only difference I remember offhand is that Arrows are now also Categories, where that paper includes the operations from Categories in the Arrow typeclass itself.
07:18:22 <Athas> Strange, it used to work.  Anyway, that paper should be available elsewhere.
07:19:33 <joeyh_> mysticc: I assume atomically is necessarily strict
07:32:01 <mvj4> "the :: Elt e => Acc (Scalar e) -> Exp e"
07:32:35 <mvj4> why is it possible to escape the Acc-context? doesn't it require an explicit evaluation from a backend?
07:34:02 <mvj4> ah, maybe Scalars are limited.
07:40:07 <singpoly1a> Am I right in thinking that (>=>) is the same as (>>>) for Kleisli ?
07:40:47 <roconnor_> singpoly1a: yes
07:40:59 <singpoly1a> cool
07:41:19 <Dread> cabal install gtk is giving me wsaetimedout error when it attempts to download  the packages gio and pango
07:41:23 <roconnor> @src Kleisli (>>>)
07:41:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:41:32 <roconnor> @src (>>>) Kleisli
07:41:32 <lambdabot> Source not found. My pet ferret can type better than you!
07:41:56 <typoclass> mvj4: not sure what you're referring to, but in that signature, the part to the left of "=>" is called the context ("Elt e"). it is saying that for the type e, an instance of typeclass Elt has to be present. "Acc (Scalar e)" is like "Maybe (Maybe e)". you can get stuff out of it by simple pattern matching. there's no "escaping" necessary
07:45:11 <singpoly1a> Dread: hackage is down for me
07:45:49 <Dread> singpoly1a: thanks
07:46:30 <parcs`> > 0x000000ff
07:46:31 <lambdabot>   255
07:49:17 <parcs`> > 0xff000000
07:49:18 <lambdabot>   4278190080
07:50:36 <singpoly1a> it seems like there's nothing Arrow-specific about (>>>) and (<<<)  since they are just  flip (Control.Category..) and Control.Category..  -- why specialise their types to Arrows?
07:50:41 <singpoly1a> I guess historical reasons
07:51:49 <singpoly1a> or... oh
07:51:53 <singpoly1a> I'm reading docs wrong again
07:51:57 <singpoly1a> they are just in Category :)
07:52:32 <otters> :t (>>>)
07:52:34 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
07:52:53 <otters> > (succ >>> pred) 3
07:52:54 <lambdabot>   3
07:55:23 <hpaste> teneen pasted “imperative_quicksort” at http://hpaste.org/72964
07:55:27 <teneen> Can someone please tell me what's wrong with this code which implements an imperative quicksort?
07:55:37 <teneen> The error message is in the paste
07:56:38 <fmap> :t when
07:56:39 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:57:33 <DMcGill> add "return ()" inbetween lines 14 and 15
07:57:45 <DMcGill> i.e. in when's do block
07:57:51 <teneen> fmap: The last statement in qsort' is "return arr" this it is not m ()
07:57:57 <parcs`> better yet remove line 15
07:58:17 <parcs`> and put the return somewhere near line 8
07:58:32 <parcs`> or don't return the array at all
07:58:49 <parcs`> since the caller already knows what the array is
07:59:26 <teneen> parcs`: Ok I added "void $" at the beginning of line 14
07:59:37 <teneen> it works now, thanks!
08:00:04 <DMcGill> parcs` is very right, there's no need to keep returning a pointer to the mutable array
08:00:22 <DMcGill> you're discarding it every time
08:01:03 <DMcGill> qsort's type should be "STUArray s Int Int -> ST s ()" imo
08:03:35 <teneen> Ok, I got it. Thanks DMcGill and parcs`
08:04:42 <XexonixXexillion> does anyone now how the garbage collector interacts without foreign function calls and/or knows how to find out? Specifically will gc interrupt a foreign call, and if so, is there a way to stop it
08:05:55 <singpoly1a> XexonixXexillion: it will not interrupt.  if not -threaded, the FFI call block the RTS, if -threaded the GC runs in a thread.  IIRC
08:10:16 <XexonixXexillion> singpoly1a: that's what I was afraid of. Why can't my OS have a decent scheduler...
08:11:59 <XexonixXexillion> out of curiosity, when people here are not coding in Haskell, what are they coding in?
08:12:50 <DMcGill> My second most used language is Java, then MATLAB
08:12:53 <mvj4> I'm an embedded developer during the day, mostly writing C. It's quite nice to relax with some haskell after work.
08:13:14 <DMcGill> but then as I'm an undergrad, easily 90% of my coding is done in Haskell
08:13:18 <DMcGill> more than that
08:13:23 <singpoly1a> ruby
08:14:16 <jrajav> Javascript here
08:16:11 <XexonixXexillion> Does anyone else here write much ada?
08:31:26 <mysticc> I was working on a problem .. It involves networking .. I was kind of stuck in the clean up procedure .. i had a thread serving requests of the clients .. but I wanted this thread to exit when client socket handle is closed.. so what I did was to fork another thread which repeatedly checks if client handle is closed if yes then it performs the cleanup .. The problem is should I include some delay in this cleanup thread ?
08:32:55 <DMcGill> it doesn't quite answer your question, but have you looked at using bracket to cleanup?
08:33:02 <DMcGill> :t bracket
08:33:03 <lambdabot> Not in scope: `bracket'
08:33:07 <DMcGill> @hoogle bracket
08:33:08 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:33:08 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:33:09 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:33:51 <DMcGill> the idea is you give it a function that "cleans up" the resource after the action is finished
08:35:26 <mysticc> DMcGill: That does not necessarily work .. problem is I have threads A ,B which is repeating forever to serve request on handle h .. Now if handle is closed how to kill thread A and B ..
08:39:52 <geekosaur> sure, so forkIO returns a thread ID, use killThread in the cleanup function?
08:47:41 <parcs`> is hackage down? :(
08:48:05 <geekosaur> yes, yet again :(
08:48:40 <mysticc> I am not able to debug this error .. here is my client http://hpaste.org/72967 .. Then problem is when I press ctrl + d .. hClose id called on the handle but server side still sees handle as not closed ?
08:56:16 <q0tw4> hackage is not available for me now
08:56:55 <monochrom> oh yikes, indeed
08:57:25 --- mode: ChanServ set +o monochrom
08:57:43 --- topic: set to '["hackage down","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
08:57:49 --- mode: monochrom set -o monochrom
08:59:28 <jmcarthur> dangit hackage :(
09:00:00 <jmcarthur> anybody have a package bundle? i'll help seed if it's a torrent
09:00:07 <jmcarthur> we used to do this, i recall
09:00:15 <jmcarthur> when hackage was down
09:01:27 <q0tw4> cabal-install with torrent support? Nice idea
09:01:41 <luite> jmcarthur: my mirror still works: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
09:02:04 <jmcarthur> thanks!
09:02:18 <mysticc> Anybody can help ? With Network module .. I have used connectTo to connect to a server .. it returns handle .. but when I call hClose on this handle .. server side handle still remains open ?
09:03:02 <mauke> mysticc: so close it in the server
09:03:17 <mysticc> mauke: How do I know when the client has disconnected ?
09:03:54 <mauke> when read returns 0 or write returns EPIPE
09:03:59 <DMcGill> you could have the client send a disconnect message and/or have the server implement a timeout feature
09:05:13 <mysticc> mauke: What read ?
09:05:34 <mauke> mysticc: what does your server do with the socket?
09:06:12 <mysticc> mauke: it is a handle .. from accept in Network module .. I just use it to interact with client .. simple interactive application ..
09:06:27 <mauke> "interact" how?
09:06:45 <mysticc> mauke: hGetLine and hPutStrLn on handle ..
09:06:55 <mauke> ok, they'll throw exceptions then
09:07:53 <mysticc> mauke: Huh finally .. hIsEOF works .. :)
09:07:55 <mauke> isEOFError from getLine
09:08:26 <mysticc> mauke: Yeah  .. I spawned another thread which checks hIsEOF and performs cleanup if it returns true
09:08:34 <mauke> that's generally a bad idea
09:08:56 <mauke> it's like doing 'if not (null xs) then head xs ...'
09:09:07 <mauke> don't separate check/use
09:10:33 <mysticc> mauke: What do you suggest .. ?
09:10:54 <mauke> use hGetLine and catch the exception
09:11:09 <JunkBee> I am looking on google for the `..` range operator like perl or C, and it is showing me examples of it, but they don't work. Do I just need to use the Data.Ix range function?
09:11:41 <mauke> JunkBee: C has no range operator
09:11:49 <DMcGill> JunkBee: can you give a quick example?
09:11:52 <mauke> Haskell has no range operator either, but it has range syntax: [X .. Y]
09:12:06 <mauke> which is syntactic sugar for enumFromTo
09:12:09 <JunkBee> foldl (*) 1 (1..10)
09:12:13 <JunkBee> oh []?
09:12:21 <DMcGill> > foldl (*) 1 [1..10]
09:12:23 <lambdabot>   3628800
09:12:32 <JunkBee> dang wrong parenth
09:13:21 <hayashi> haskell, some would say sadly, is not lisp.
09:16:07 <JunkBee> If I was writing C I think this function would be 100 to 300 lines
09:16:23 <JunkBee> this is cool
09:17:22 <eldar> I'm trying to install some component from snap and it fails to resolve some dependencies http://pastebin.com/ND0HgqXw
09:17:24 <mauke> The paste ND0HgqXw has been copied to http://hpaste.org/72968
09:17:35 <GlennBecksMother> if i have values at 16:01, 16:03 and 17:00. how do you say the values the whole hour? like 17:00, 16:00 etc?
09:18:22 <typoclass> eldar: hackage is currently down, sorry. cabal install won't work
09:18:32 <JunkBee> GlennBecksMother: if minutes `mod` 60 == 0
09:19:21 <mauke> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
09:19:35 <eldar> typoclass, thanks! I have to get some beers then
09:19:44 <mauke> or you can put that line in your ~/.cabal/config
09:19:48 <GlennBecksMother> JunkBee: i mean in english, not programmatically
09:19:48 <eldar> and leave coding for a tonight
09:20:16 <JunkBee> GlennBecksMother: Oh, if it is 17:00, I don't know how to say in military time, I would say it is 5 pm, or 5 o'clock
09:20:18 <eldar> mauke, thanks. How long is it going to be down for?
09:20:36 <GlennBecksMother> but can say , filter out whole hours in a comment?
09:20:40 <JunkBee> GlennBecksMother: I think military would say it is seventeen-hundred
09:20:42 <mauke> eldar: er, no idea
09:21:01 <GlennBecksMother> -- filter for measurements at the whole hour
09:22:04 <JunkBee> GlennBecksMother: I think that would depend on the text you are parsing because English can refer to something many different ways, like it is at 5!, the game starts at O seventeen hundred!
09:22:43 <jfischoff> Cale: have you ever used Multiplate? Would you consider it an appropriate alternative to explicit recursion?
09:25:06 <mvj4> how would you define recursion (or iteration) without instances of (==) and compare?
09:27:57 <DMcGill> pattern match?
09:28:08 <jmcarthur> mvj4: pattern matching requires neither of those
09:28:08 <jfischoff> mvj4: ^
09:28:18 <mauke> mvj4: what do you need == for?
09:28:30 <mauke> @src iterate
09:28:31 <lambdabot> iterate f x =  x : iterate f (f x)
09:28:45 <mvj4> but pattern matching gets translated to (==) ..
09:28:52 <mauke> no, it doesn't
09:29:00 <mysticc> What do you use commandline to paste to hpaste ?
09:29:04 <mauke> mvj4: what do you need == for?
09:29:12 <jmcarthur> @src [] (==)
09:29:12 <lambdabot> []     == []     = True
09:29:12 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
09:29:12 <lambdabot> _      == _        = False
09:29:23 <jmcarthur> see? (==) is defined in terms of pattern matching, not the other way around
09:29:36 <mauke> mysticc: http://mauke.hopto.org/stuff/perl/pastebin
09:29:51 <jmcarthur> @src () (==)
09:29:52 <lambdabot> () == () = True
09:30:00 <jmcarthur> > [(), (), ()] == [(), ()]
09:30:01 <lambdabot>   False
09:31:23 <mysticc> mauke: huh .. perl
09:31:47 <mauke> what else?
09:33:04 <mysticc> https://github.com/satvikc/hpaste-sh .. shell ..
09:33:34 <mauke> more like curl
09:33:44 <mauke> and it doesn't say which shell
09:33:48 <jmcarthur> why not haskell? :P
09:33:57 <mauke> I kind of doubt it's valid bourne shell code
09:34:47 <mysticc> Dont know .. but works for me .. and is very fast ..
09:35:16 <mauke> it would scare me if this thing was cpu-bound somehow
09:35:54 <mysticc> jmcarthur: hpaste not limited to haskell only .. so somepeople might not want to add ghc dependency
09:36:07 <jmcarthur> well, it's cpu bound in that the network stuff only happens in sequence with bits of computation
09:36:16 <jmcarthur> mysticc: it was a half joke
09:36:26 <mauke> jmcarthur: huh?
09:36:57 <jmcarthur> mauke: i just mean that both the cpu and network are bottlenecks in this code, unless you have interleaving or concurrency that i don't see
09:37:10 <jmcarthur> mauke: it's just that i doubt the cpu is anywhere near enough of the execution time to care
09:37:42 <jmcarthur> doesn't mean it's not cpu bound, is all i mean. i'm being pedantic
09:37:50 <mysticc> I dont know .. but it takes less than a second for me to hpaste ..
09:37:50 <naula> hello!
09:37:52 <mauke> ok, separate phases
09:38:05 <mauke> mysticc: that's your network
09:38:19 <mauke> and maybe your disk
09:38:27 <naula> it seems hackage is down and it is mentioned even in topic of this channel. but why it is down? and when it will be fixed?
09:39:42 <c_wraith> naula: it's down because it's run by volunteers at a small company who don't have much time to spend on its maintenance
09:40:01 <naula> c_wraith: argh!
09:40:22 <mysticc> mirrors .. hackage mirrors .. We need you ..
09:40:34 <mauke> I'm mirroring luite's mirror as we speak
09:40:59 <luite> using Wget/1.12-hax
09:41:08 <mysticc> mauke: Would have been nice if we had a mirror file .. like we have for distro package managers ..
09:41:10 <mauke> yep
09:41:16 <luite> what does the hax doe?
09:41:20 <luite> do
09:41:39 <nus> what's stranger www.galois.com is also down
09:41:40 <naula> I use Debian GNU/Linux and I am trying to install this: http://rampa.sk/static/wikipedia4epub.html
09:42:21 <mysticc> whats the status of hackage2
09:42:23 <rajeshsr> hi
09:42:24 <naula> well, how can I install that wikipedia4epub without cabal?
09:42:55 <mysticc> naula: good if you use cabal ..
09:43:16 <mysticc> naula: How are you going to take care of dependencies ..
09:43:16 <luite> naula: add this line to your cabal config file: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
09:43:20 <rajeshsr> i was trying to install cabal in mac (All to get that xmonad! ) It fails with overlapping instance compile error..
09:43:27 <rajeshsr> can anybody help me?
09:43:56 <b__> rajehshr can you hpaste your error?
09:44:00 <b__> http://hpaste.org
09:44:01 <mauke> luite: it adds a command line option that lets you customize the Referer header
09:44:08 <rajeshsr> b__: sure!
09:44:12 <mysticc> luite: Whats the total size of the mirror ?
09:44:17 <mauke> luite: and it changes the semantics of accepted domains during recursive retrieval
09:44:38 <luite> mysticc: all packages are ~1.5GB
09:44:43 <naula> luite: okay. should I comment away this: remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
09:44:44 <mauke> luite: that is, it always downloads page requisites
09:44:53 <luite> naula: yeah
09:45:11 <luite> ah
09:45:21 <naula> luite: okay. let's see what will happen
09:46:00 <luite> mauke: if you fixed it so it wouldn't retrieve all different directory listings form apache if would be even faster :p
09:46:11 <DMcGill> so I have a WriterT, is there a function :: ((a,[w]) -> (b,[w']) -> WriterT w m a -> WriterT w' m b?
09:46:11 <mauke> indeed
09:46:18 <DMcGill> there's some map functions
09:46:19 <mauke> I tried -R html,htm but that doesn't work
09:46:29 <naula> dows anyone of you use cabal-debian ?
09:46:31 <DMcGill> but I can't see one that applies the function to the entire output
09:46:46 <mauke> the next iteration will use stricter patterns
09:46:56 <naula> does, even
09:47:13 <PaulVisschers> hackage is down again :(
09:47:21 <b__> rajeshsr: is haste working out for you?
09:47:59 <rajeshsr> b__: http://hpaste.org/72976
09:48:09 <rajeshsr> Was re-compiling to get the error...
09:57:28 <zzing_> When code is wrapped up in a free monad, does it take a performance hit?
10:03:20 <jfischoff> zzing_: sure, but only your hotspots matter so it could be negligible.
10:03:34 <zzing_> That is true
10:03:37 <Saizan> depends
10:03:40 <jfischoff> zzing_: plus I think rewrite rules might help
10:04:00 <Saizan> zzing_: it's very simple to optimize the overhead away by church-encoding the free monad part
10:04:46 <Saizan> http://comonad.com/reader/2011/free-monads-for-less/ <- e.g.
10:05:06 <zzing_> I have code right now that is going the way of the first one: http://hpaste.org/72953   and mm_freak_ assisted with the annotation, and then suggested a free monad. On my post: http://www.reddit.com/r/haskell/comments/y1gg0/error_handling_how_would_you_solve_this/   it was suggested (by the author) to use his 'errors' library.
10:08:56 <Yuu-chan> Hello guys! Cabal can't update and install packages for an unknown reason and writes a very useful "cabal: failed" error message. Could anybody help?
10:09:10 <mvj4> Yuu-chan: hackage is down.
10:09:20 <Yuu-chan> mvj4: oh.
10:16:32 <mysticc> Yuu-chan: you can use luite's mirro .. add this line to your cabal config file: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
10:16:40 <Yuu-chan> Which one is better: haskell-indentation or haskell-indent?
10:17:07 <mysticc> Yuu-chan: where ?
10:17:07 <Yuu-chan> mysticc: thank you
10:17:18 <Yuu-chan> In Emacs haskell-mode
10:18:15 <mysticc> Yuu-chan: http://stackoverflow.com/questions/11365815/what-are-the-similarities-and-differences-among-haskell-indentation-modes-for-em
10:18:26 <mysticc> I use haskell-indent ..
10:18:59 <sentientwaffle> How could i refactor `pure getKey <*> (pure (:) <*> getChar <*> getRemainingInput)` to use only one "pure"?
10:19:50 <typoclass> sentientwaffle: if i'm reading that correctly, you can say "getKey <$>" for "pure getKey <*>". same for "pure (:)"
10:21:57 <sentientwaffle> typoclass: awesome, thanks! I'm having a hard time wrapping my head around applicatives.. ><
10:22:12 <mysticc> sentientwaffle: I think `getKey . (:) <$> getChar .....` will work ..
10:23:02 <mysticc> oops
10:23:10 <Yrogirg> a bit offtopic, when will stackexchange be back?
10:23:43 <sentientwaffle> mysticc: doesnt seem to
10:23:53 <roconnor> sentientwaffle: pure (\a b -> getKey (a : b)) <*> getChar <*> getRemainingInput
10:23:58 <roconnor> aka
10:24:05 <roconnor> (\a b -> getKey (a : b)) <$> getChar <*> getRemainingInput
10:24:23 <roconnor> not that such refactoring is needed
10:25:10 <sentientwaffle> roconnor: yeah, i think its more readable w/o the lambda
10:25:22 <roconnor> @pl (\a b -> getKey (a : b))
10:25:23 <lambdabot> (getKey .) . (:)
10:25:35 <roconnor> (getKey .) . (:) <$> getChar <*> getRemainingInput
10:25:42 <roconnor> still the orginal is best
10:26:03 <sentientwaffle> how do the 2 dots work?
10:26:13 <roconnor> however, it is nice to understand the theoretical property that every applicative expression can be rewriten in the form f <$> a <*> ... <*> z
10:26:54 <roconnor> sentientwaffle: (f .) . g  is a popular way of composing a function f with a binary function g
10:27:01 <roconnor> @type \f g -> (f .) . g
10:27:03 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
10:27:09 <roconnor> CALE!!!
10:27:16 <roconnor> @type \f g -> (f Prelude..) Preulde.. g
10:27:18 <jfischoff> haha
10:27:18 <lambdabot> Couldn't find qualified module.
10:27:25 <roconnor> @type \f g -> (f Prelude..) Prelude.. g
10:27:27 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
10:27:44 <roconnor> sentientwaffle: add more dots to let g be a trinary function
10:27:52 <roconnor> @type \f g -> ((f Prelude..) Prelude..) Prelude.. g
10:27:54 <lambdabot> forall b c a a1 a2. (b -> c) -> (a2 -> a1 -> a -> b) -> a2 -> a1 -> a -> c
10:27:58 * geekosaur imagining that a la KHAAAAAAAAAAN!
10:28:26 <ParahSailin> :t <$>
10:28:27 <lambdabot> parse error on input `<$>'
10:28:34 <ParahSailin> :t (<$>)
10:28:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:29:45 <ParahSailin> :t (<*>)
10:29:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:30:37 <bitonic> @tell mekeor oh, I didn't realise it was you on the ERC mailing list :)
10:30:37 <lambdabot> Consider it noted.
10:31:43 <jfischoff> geekosaur: likewise
10:32:16 <sentientwaffle> roconnor: wo, neat! so you can compose functions with multiple arguments
10:32:52 <roconnor> sentientwaffle: Its such a common idiom that I no longer consider it obscure code.
10:32:57 * nand` waves
10:33:08 * roconnor particles
10:33:21 <sentientwaffle> roconnor: awesome, i'll try it out :)
10:33:31 <hiptobecubic> is hackage down?
10:33:33 * nand` fields
10:33:37 <roconnor> hiptobecubic: yes
10:33:46 * roconnor quantizes
10:33:49 <hiptobecubic> roconnor, dang. ok thanks.
10:36:32 <parcs`> lambdabot should have a command that pings hackage
10:37:02 <roconnor> parcs`: http://en.wikipedia.org/wiki/Ping_of_death  ?
10:37:18 <nand`> parcs`: http://www.isup.me/hackage.haskell.org
10:37:59 <int-e> oh, there's more of these services. http://www.downforeveryoneorjustme.com/hackage.haskell.org
10:38:25 <parcs`> yeah but using a 3rd-party website is inconvenient
10:38:31 <nand`> int-e: that's the same website
10:39:07 <edwardk> hackage dead again?
10:39:07 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
10:39:26 <nand`> edwardk: the syntax highlighter on your blog is broken, it bolds ‘as’ when used as a variable
10:39:44 <edwardk> nand`: yeah its crap
10:39:49 <roconnor> edwardk: I believe parcs` gave hackage a ping of death using lambdabot ... if I follow #haskell correctly, which I don't.
10:40:20 <edwardk> just noticed because i panicked when lens reported a build failure ;)
10:40:28 <edwardk> then i saw it wasn't my fault ;)
10:41:43 <parcs`> i just sent the command, lambdabot is the one who sent the ping. blame lambdabot
10:42:12 <int-e> @botsnack
10:42:12 <lambdabot> :)
10:44:45 <wires> damn hackage...
10:44:59 <wires> haha ;) why did I just delete my cabal-dev dir...
10:45:40 <roconnor> wires: don't worry you can just undelete it right?
10:45:56 <roconnor> cause linux is awesome?
10:46:00 <roconnor> anyone?
10:46:01 <wires> roconnor, hahaha :)
10:46:02 <roconnor> ?
10:46:23 <wires> I guess this little haskell project is now on hold
10:47:43 <int-e> wires: hmm, does cabal-dev not use ~/.cabal/packages to cache package sources?
10:48:21 <wires> BTW is was getting this weird error, I run "cabal-dev ghci" and then it complains: "cabal-dev: user error (cabal: Cannot find the program 'ghc' at 'fake-ghc-cabal-dev' or on the path)"
10:48:57 <wires> int-e, seems not:
10:48:58 <wires> Downloading highlighting-kate-0.5.2...
10:48:58 <wires> Sending:
10:48:58 <wires> GET /packages/archive/highlighting-kate/0.5.2/highlighting-kate-0.5.2.tar.gz
10:48:59 <wires> HTTP/1.1
10:49:01 <wires> Host: hackage.haskell.org
10:49:11 <int-e> pity
10:49:17 <wires> very...
10:55:47 <DMcGill> please tell me there's some way to get the compiler to implicitly put "Text.pack" in front of every single function that expects a Text and recieves a String
10:55:56 <DMcGill> I know it subverts the entire point of the type system
10:55:59 <DMcGill> but it's so annoying
10:56:05 <int-e> Ah I knew there were hackage mirrors out there. http://hackage.scs.stanford.edu/recent.html is one
10:56:58 <Expez> I have a type constructor which takes 5 args and I have a list containing the args. Can I use currying to consume the list and construct the type, somehow? Right now I'm using 'read' and (!!) and I feel like I've typed too much.
10:57:36 <DMcGill> Expez: not that I know of, you could pattern match with single letter names
10:58:05 <DMcGill> something like let [a1, a2, a3, a4, a5] = list in Foo a1 a2 a3 a4 a5
10:58:34 <Expez> DMcGill: Yeah, that would be an improvement.
10:58:42 <DMcGill> unless you want to go all out and use Template Haskell of course
10:58:47 <DMcGill> (you don't want to do that)
10:59:09 <DMcGill> note that if there aren't 5 things in that like you'll get a runtime error
10:59:20 <Expez> yeah
10:59:22 <DMcGill> so either have multiple cases or do
10:59:35 <DMcGill> let (a1 : a2 : a3 : a4 : a5 : _) = list in...
10:59:42 <DMcGill> to throw away the rest
11:00:03 <DMcGill> is this for command line arguments? A 5-tuple would be a better structure than a list
11:00:18 <DMcGill> or I guess that's what the data structure is fore
11:00:51 <Expez> Yeah, I'm constructing this data type when parsing a string of user input
11:01:00 <naula> int-e: what kind of line I should add to config of cabal, if I want to use that mirror?
11:01:22 <DMcGill> naula: in your config file, look for the remote repo line
11:01:33 <DMcGill> change that to the mirror
11:01:47 <DMcGill> possibly located at ~/.cabal/config
11:02:10 <DMcGill> or appdata\roaming\cabal\config
11:03:08 <int-e> naula: remote-repo: hackage.haskell.org:http://hackage.scs.stanford.edu/packages/archive  in ~/.cabal/config works for me (you may want to change the name 'hackage.haskell.org' to something different -- but this way it uses the same cache directory.
11:03:09 <Expez> I'm using hGetContents to read the contents of a data file and then check if it contains an entry. If not I want to add the entry to the end. hGetContents closes the handle so I have to open another one. Is there perhaps a more idiomatic way of doing this?
11:03:11 <DMcGill> you might be able to get away with putting another remote repo line below the hackage one and have it read both databases
11:03:45 <naula> int-e: topic says it is down
11:04:17 <int-e> naula: read the line, it lists two different hosts - the first is just a name used locally, the second is the mirror
11:04:18 <naula> is it possbile to have two or more remote-repo: -lines?
11:04:41 <naula> is this correct: remote-repo: hackage.scs.stanford.edu:http://hackage.scs.stanford.edu/packages/archive
11:04:56 <int-e> naula: yes, and you can have two such lines.
11:05:14 <naula> int-e: I also have this: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
11:05:59 <int-e> well, s/two/as many as you like/ :-)
11:06:55 <naula> well, I removed comments from that hackage.haskell.org -line. maybe it will come back some day
11:07:32 <Ste1891> Hi.  Can anyone point me to a function which does the conversion :: Ptr () -> Word32?
11:08:39 <naula> this is weird: now cabal try to get updates only from hackage.haskell.org and after timeout it exits and do not try any other servers I have in that config
11:08:59 <geekosaur> Ste1891, while it can be done, it probably shouldn't be.  what are you really trying to do?
11:10:30 <int-e> fromIntegral . Foreign.Ptr.ptrToWordPtr. But you should not do that, but rather stick to the WordPtr type, which will be of the right size on 64 bit architectures. And I second geekosaur's question - why do you want to do that?
11:15:27 <LucasCampos> Hello there. Am I the only one having problems accessing http://hackage.haskell.org/platform/ ?
11:15:35 <Taneb> No
11:16:23 <mekeor> i remember that there was a hackage mirror. where is it?
11:16:23 <lambdabot> mekeor: You have 1 new message. '/msg lambdabot @messages' to read it.
11:17:21 <int-e> naula: I see, hdiff.luite.com  is another mirror. I think you need to comment out the original hackage.haskell.org  line temporarily to make things work smoothly. (and you can probably do without the hackage.scs.stanford.edu  mirror)
11:17:30 <hpaste> Ste1891 pasted “win32: appendMenu” at http://hpaste.org/72977
11:17:38 <Ste1891> I'm trying to use appendMenu from the win32 module.  Having looked at examples of how this is done in C, it appears I need to do something like this... [code pasted]
11:17:59 <Ralith> DMcGill: did anyone point you to polymorphic strings or w/e the extension is called?
11:18:09 <DMcGill> There's OverloadedStrings
11:18:13 <Ralith> right
11:18:16 <DMcGill> but that only affects literals
11:18:23 <DMcGill> I want a dynamic type system
11:18:24 <Ralith> exactly
11:18:27 <Ralith> ...why
11:18:30 <DMcGill> or duck typing
11:18:42 <DMcGill> I have lots of functions that return String
11:18:53 <DMcGill> and lots of functions that accept Text
11:19:06 <Ralith> maybe you should make your functions more polymorphic.
11:19:08 <DMcGill> and lots and lots of "Text.pack" everywhere
11:19:15 <wires> type classes?
11:19:22 <DMcGill> I suppose so, I wasn't being too serious
11:19:30 <Ralith> kay
11:19:30 <wires> :)
11:19:48 <Ralith> becuase if you were, I'd say you were trying to fix a design error you made by breaking the type system
11:19:51 <Ralith> >_>
11:20:10 <DMcGill> speaking of, is there some kind of "ContainsLanguage" type class?
11:20:19 <DMcGill> I'm trying to think what it'd consist of
11:20:31 <DMcGill> something that String and Text and ByteString would all fit into
11:20:49 <sipa> Integer?
11:20:52 <DMcGill> classyprelude did something similar
11:21:08 <sipa> i'm sure you can construct a language that defines semantics to integers
11:21:11 <DMcGill> defined lots of isLengthable typeclasses and so on
11:21:37 <DMcGill> while you can defined length from Traversable, it's really inefficient
11:21:43 <DMcGill> s/defined/define
11:26:21 <naula> int-e: I keep those both mirrors
11:27:06 <naula> int-e: in my config
11:27:26 <naula> int-e: does it have any drawbacks, if I have two mirrors?
11:29:08 <mekeor> i need a function ":: (a -> Bool) -> Data.Map a b -> b" or ":: (a -> Bool) -> Data.Map a b -> Maybe b" but i can't find it since hackage is down. what is it called?
11:29:28 <DMcGill> hoogle is still up
11:29:36 <mekeor> ah! lookup
11:29:47 <mekeor> DMcGill: yup but couldn't find it anyway…
11:29:54 <DMcGill> sorry
11:29:57 <mekeor> :)
11:34:23 <pepijndevos> How can I filter a list by type? data Blah = Foo x | Bar y; filter (/x -> Foo x) [Foo 1, Bar 2]
11:35:13 <latro`a> you mean by data constructor?
11:35:15 <DMcGill> onlyFoo xs = [Foo x | Foo x <- xs]
11:35:18 <DMcGill> I think
11:35:21 <MostAwesomeDude> ^^
11:35:45 <latro`a> pattern matching will work, but a more robust way that doesn't rely on monadic fail is to make a predicate matching on the constructor
11:35:54 <latro`a> like
11:35:57 <DMcGill> > [Just x | Just x <- [Just 1, Just 2, Nothing, Just 3]]
11:35:58 <MostAwesomeDude> Or if the constructor's more complex, you should be able to do something like [x | x@(Foo _) <- xs]
11:35:59 <lambdabot>   [Just 1,Just 2,Just 3]
11:36:08 <latro`a> isFoo (Foo _) = True
11:36:10 <latro`a> isFoo _ = False
11:36:14 <DMcGill> latro`a is right though
11:36:19 <MostAwesomeDude> latro`a: Well, for LCs, that's pretty explicit.
11:36:29 <latro`a> what's an LC
11:36:33 <MostAwesomeDude> List comprehension.
11:36:37 <latro`a> oh
11:36:43 <DMcGill> when we get an anonymous case it'll be easier
11:36:52 <latro`a> yeah, I know, I'm just saying, that strategy doesn't work in a setting without monadic fail
11:37:06 <MostAwesomeDude> This is true.
11:37:45 <a215> does anyone know who Mattias is?
11:37:56 <a215> trying to track down whoever posted this http://hpaste.org/71551
11:38:30 <a215> re: passenger-install-apache2-module
11:38:35 <DMcGill> there's a matthiasgorgens in here
11:38:46 <a215> matthiasgorgens: is this yours?
11:39:16 <latro`a> incidentally, is there a straightforward way using TH to make those predicates?
11:41:46 <int-e> naula: I expect the only drawback is a longer waiting time on 'cabal update'
11:46:26 <naula> int-e: okay
11:49:05 <DMcGill> > mzero >> return 1
11:49:06 <lambdabot>   No instance for (GHC.Show.Show (m t))
11:49:07 <lambdabot>    arising from a use of `M9189042659...
11:49:24 <DMcGill> > (mzero >> return 1) :: [Int]
11:49:25 <lambdabot>   []
11:49:37 <DMcGill> > (mempty >> return 1) :: [Int]
11:49:39 <lambdabot>   []
11:50:16 <DMcGill> > Nothing >> return 1
11:50:18 <lambdabot>   Nothing
11:50:26 <DMcGill> > Nothing ++ return 1
11:50:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:50:28 <lambdabot>    `Data.Monoid.Monoid a'
11:50:29 <lambdabot>  ...
11:50:42 <latro`a> > Nothing ++ return 1 :: Maybe Int
11:50:44 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
11:50:44 <lambdabot>    arising from a use of...
11:50:47 <latro`a> huh
11:50:51 <latro`a> oh wait right, duh
11:51:01 <latro`a> Nothing ++ return [1] :: Maybe [Int]
11:51:08 <latro`a> > Nothing ++ return [1] :: Maybe [Int]
11:51:10 <lambdabot>   Just [1]
11:51:15 <latro`a> ^helps?
11:51:24 <DMcGill> thanks
11:51:42 <nand`> > First Nothing ++ First (return 1)
11:51:43 <DMcGill> well not really, I'd better ask
11:51:43 <DMcGill> does
11:51:44 <lambdabot>   First {getFirst = Just 1}
11:51:49 <DMcGill> when bool mzero
11:51:52 <DMcGill> do what I want it to?
11:52:01 <latro`a> you should use guard
11:52:04 <latro`a> I think
11:52:08 <DMcGill> I want to do more things too though
11:52:32 <DMcGill> > (when True mzero) >> Just 1
11:52:34 <lambdabot>   Nothing
11:52:49 <DMcGill> good, I think that's what I need
11:53:08 <DMcGill> although obviously it only has use in a monad with actual side effects
11:53:21 <latro`a> eh not necessarily
11:53:32 <DMcGill> I mean over guard
11:53:33 <latro`a> in Maybe you can have some expectation
11:53:35 <latro`a> oh
11:53:37 <latro`a> yeah
11:53:39 <DMcGill> when bool (action >> mzero)
11:53:59 <DMcGill> means that I don't have to indent everything below it!
11:58:18 <wires> yo .. why is hackage still not up? whatsup with it...
11:58:43 <roconnor> > ("test",3) >>= (\n -> (replicate n 'a',()))
11:58:44 <lambdabot>   No instance for (GHC.Base.Monad ((,) [GHC.Types.Char]))
11:58:44 <lambdabot>    arising from a u...
11:59:02 <roconnor> why no instance?
11:59:23 <danharaj> Who accidentally the hackage?
12:00:06 <mkCurry> danharaj: Colorless green dreams sleep furiously?
12:00:17 <srhb> mkCurry: Yes
12:00:21 <hughfdjackson> danharaj: you're missing a verb ^_^
12:00:29 <latro`a> that was the joke -_-
12:00:30 <srhb> That's the point ._.
12:00:34 <hughfdjackson> curses
12:00:36 <Taneb> hughfdjackson, it's a common internet joke
12:00:39 * srhb path hughfdjackson 
12:00:42 <roconnor> I demand instance Monoid o => Monad (,) o !
12:00:44 <srhb> pats, damnit :P
12:00:52 <hughfdjackson> srhb: thanks <3
12:00:59 <roconnor> (->) gets all the love
12:01:06 <hughfdjackson> i'll overcome my interweb shame someday
12:01:22 * hughfdjackson disappears into the temporary exile/to go to the shop
12:01:27 <Taneb> roconnor, more of a Writer than a Reader?
12:01:34 <srhb> hughfdjackson: One day you'll accidentally a verb, and all is good.
12:01:38 <danharaj> Isn't that exactly Writer?
12:01:39 <roconnor> > ("hello",succ) <*> ("world",3)
12:01:41 <lambdabot>   ("helloworld",4)
12:01:43 <roconnor> oh
12:01:46 <roconnor> there is applicative
12:02:01 <roconnor> close enough for me!
12:03:19 <mkCurry> Seriously, what's up with hackage?
12:03:29 <ion> instance Monoid a => Monoid [a] where mempty = repeat mempty; mappend = zipWith mappend
12:03:46 <roconnor> ion: :^)
12:05:05 <Yuu-chan> mkCurry: that must be underhand practices of imperative programmers
12:05:22 <ion> There’s nothing wrong with imperative programming.
12:05:43 <ion> And Haskell’s IO happens to be one of the best imperative programming languages.
12:05:46 <srhb> ion: Yes, except >> fast forward 10 minutes of flame wars
12:05:49 <mkCurry> Yuu-chan: I enjoy a good consipiracy theory like any other guy, but never ascribe to malice what can be equally ascribed to incompetence.
12:05:55 <geekosaur> mkCurry, mailing list indicates galois is doing internal network upgrades
12:06:24 <mkCurry> geekosaur: Ahhh, Galois hosts it?
12:06:29 <geekosaur> yes
12:07:10 * Yuu-chan draws out her [SARCASM] sign plate
12:07:37 <mietek> Is there any documentation/papers on how GHCi dynamically loads Haskell code?
12:07:43 <mietek> http://webcache.googleusercontent.com/search?q=cache:yVLnv9OY6RkJ:hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Interpreter+hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Interpreter&hl=en&client=safari&prmd=imvns&strip=1 appears to be a stub
12:08:05 <mkCurry> Yuu-chan: You must go deeper.
12:08:17 <Yuu-chan> mkCurry: how much deeper?
12:08:33 <srhb> Yuu-chan: lift . lift . lift . lift . lift . ...
12:08:36 <mkCurry> Yuu-chan: Haskell is lazy right?
12:09:05 <mkCurry> What srhb said.
12:09:28 <ion> mkcurry: Haskell implementations tend to be.
12:11:33 <Yuu-chan> ion: and what about Haskell programmers?
12:15:50 <c_wraith> also tend to be lazy.  features are implemented after demand. :)
12:16:05 <latro`a> lol
12:16:09 <avpx> I'm still new at this whole existential quantification thing. I'm parsing a language into a type SSyn, which has constructors for the different kinds of data, and then I want to convert it to SData a, which is a very similar structure except that I am using a phantom type/GADTs in this one.
12:16:10 <mkCurry> c_wraith: It takes a looooot of effort to be lazy.
12:16:18 <latro`a> "oh, you really NEEDED a user interface? hang on lemme hack one together..."
12:16:35 <avpx> I wanted a function SSyn -> SData a, but that won't work. I have convinced myself I need something like SSyn -> (exists a. SData a)
12:17:05 <jmcarthur> avpx: sounds about right. alternatively, you could maybe do SSyn -> Maybe (SData a)
12:17:14 <avpx> jmcarthur: The issue is that it just won't type check
12:17:36 <jmcarthur> avpx: maybe hpaste would help explain the problem better for us
12:17:40 <avpx> jmcarthur: Yeah, I think so
12:18:19 <avpx> I thought I could explain it in just words, but I guess that wasn't going to cut it :p
12:21:28 <mm_freak>     Warning: `mkGen' is exported by `mkGen' and `module Control.Wire.Classes'
12:21:40 <mm_freak> how can i make GHC shut up without disabling the warning?
12:21:44 <mm_freak> any idea?
12:22:05 <mm_freak> i want to export this from both modules
12:24:13 <hpaste> avpx pasted “Quantification problems” at http://hpaste.org/72980
12:25:42 <mm_freak> ok, haddock can't handle the way i solved it
12:25:56 <parcs`> avpx: you can't do that
12:26:00 <avpx> parcs`: Clearly :p
12:26:26 <mm_freak> module Control.Wire.Types (module Wc, mkGen) where import qualified Control.Wire.Classes as Wc hiding (mkGen); import Control.Wire.Classes
12:26:44 <mm_freak> haddock can't handle that…  it just doesn't show the reexport =/
12:26:58 <avpx> Can someone suggest a different approach?
12:27:28 <nand`> is there some form of ‘pulling’ function :: Int -> [a] -> (a, [a]) which returns the element at that index + a modified list with that element pulled to the beginning?
12:27:35 <avpx> On an unrelated note, is there a way to, by default, hide a package from GHC? Because I'm pretty sick of ghc -hide-package monads-tf ...
12:27:51 <parcs`> avpx: turn the gadt into a regular data type
12:27:54 <mm_freak> avpx:
12:27:54 <mm_freak> -- Parser combinators like <|> don't handle polymorphism in SData well, so
12:27:55 <mm_freak> -- we'll parse into SSyn
12:27:57 <mm_freak> that makes no sense
12:28:28 <parcs`> avpx: ghc-pkg hide monads-tf
12:28:36 <parcs`> no self-respecting package would use monads-tf
12:29:01 <mm_freak> nand`: http://stackoverflow.com/questions/11766449/list-all-possible-4-chooses-from-9-in-haskell
12:29:07 <mm_freak> see the 'select' function in my answer
12:29:21 <avpx> parcs`: That's what I had initially, but I wanted to be able to write functions like add :: SData SInt -> SData SInt -> SData SInt. Instead I have to write SData -> SData -> SData, which just seems less awesome.
12:29:26 <avpx> parcs`: Also, thanks for that
12:29:45 <shirt> anyone know of a list of changes in GHC API in ghc 7.6?
12:29:49 <DMcGill> :i Maybe
12:29:55 <shirt> ... or an upgrade guide?
12:29:55 <DMcGill> what's the class that overloads (++)
12:30:02 <DMcGill> ?
12:30:05 <avpx> DMcGill: Are you talking about Monoid?
12:30:19 <avpx> mconcat/mappend?
12:30:32 <DMcGill> I am
12:30:45 <DMcGill> and it's one of the later GHC versions that make (++) = mconcat iirc
12:31:52 <avpx> mm_freak: You're right about it not making any sense, on further thought
12:32:14 <parcs`> avpx: as you said you can use an existential but that won't buy you anything. what you're trying to do requires full-blown dependent types
12:32:37 <Quantumplation> http://hpaste.org/72981 Anyone have reccomendations for this code? I can't seem to run it without running out of memory.
12:33:06 <Quantumplation> It's attempting to find the longest sequence of Collatz numbers below 1 million using memoization.
12:33:31 <avpx> parcs`: That sounds difficult. Shucks.
12:34:00 <Yuu-chan> parcs`: what do you mean about monads-tf?
12:34:25 <avpx> Use mtl?
12:36:10 <parcs`> everybody should use mtl because it is the official monad transformer library
12:36:21 <roconnor> official?
12:36:41 <parcs`> for some meaning of official :P
12:36:51 <roconnor> try defacto
12:38:02 <avpx> But that sounds silly and circular
12:38:08 <avpx> "Everyone should use X because everyone uses X"
12:38:18 <avpx> Although there is a lot of truth in a statement like that...
12:38:40 <c_wraith> everyone uses X, so using X maximizes your compatibility
12:38:52 <c_wraith> that's a less-circular way of expressing the same thought
12:38:53 <nand`> mm_freak: that could work; right now I have it written using primitive recursion / accumulation: http://bpaste.net/show/39715/
12:39:29 <avpx> "Nobody goes there anymore. It's too crowded." -- Yogi Berra
12:39:34 <Yuu-chan> Using Java maximizes your compatibility :)
12:39:36 <Aune> It's nice how my tinkering grinded to a halt when I noticed Hackage is down. Does anyone have an estimate for when it will be up again?
12:40:04 <avpx> Aune: As an exercise, try writing a program using only Haskell98 and the base libraries.
12:40:10 <DMcGill> Aune: you can use :t and :browse in ghci to get some sembalance of its functionality
12:40:23 <DMcGill> hoogle is still up, as is hayoo
12:40:24 <Enigmagic> Aune: they're apparently switching networking stuff over and said it will be "down for most of the day".
12:40:43 <c_wraith> I've actually setting up a new ghc install.  thanks to luite's mirror.
12:40:53 <c_wraith> (which has packages, but not docs)
12:41:20 <avpx> I have most of the docs in /usr/share/doc/
12:41:43 <parcs`> Aune: "it will be down for most of today"
12:41:58 <Aune> Ok, thanks.
12:42:00 <parcs`> http://www.haskell.org/pipermail/haskell-cafe/2012-August/102807.html
12:44:24 <nand`> I'm bridging the gap by reading Haskell-related blog posts
12:44:29 <nand`> then again, I'd be doing that in the first place
12:45:12 <Quantumplation> http://hpaste.org/72981 I can't seem to get this code to not run out of memory.
12:45:29 <Aune> DMcGill, that actually solved my problem, thanks. What I was looking for was hiding in a three levels deep data type.
12:47:24 <Quantumplation> I need to execute "answer 1 1000000 0" without it running out of memory.
12:48:30 <Yuu-chan> Quantumplation: does it work well on lower values?
12:48:55 <Quantumplation> Yep, works wonderfully up until about 120000
12:52:11 <DMcGill> lines 50 and 51 compute fastest_f n and fastest_f p twice
12:52:31 <Yuu-chan> I may only assume there is some kind of thunk problem, as is in folfl
12:52:42 <Yuu-chan> *foldl
12:52:47 <DMcGill> if you make things stricter, then less will be stored in memory at once
12:54:02 <c_wraith> except for those times when making things stricter makes more things stored in memory at once.
12:54:07 <DMcGill> what's with the Tree?
12:54:12 <c_wraith> basically, you want generation to be lazy, and consumption to be strict
12:54:17 <naula> I have problem, when compiling haskell-software in my Debian GNU/Linux. when I give this command: % nice -n 19 dpkg-buildpackage -rfakeroot -b
12:54:19 <DMcGill> and yes, optimising Haskell is hard
12:54:23 <c_wraith> well, not basically.  how about "broadly"
12:55:02 <naula> It gives these errors and stops: src/wiki4e-mkepub-subtree.hs:1:1:
12:55:05 <naula>     Ambiguous module name `Prelude':
12:55:08 <naula>       it was found in multiple packages: base haskell98-2.0.0.1
12:55:09 <Quantumplation> DMcGill: it's so the lookup for the memoization is in O(log(n)) time instead of linear as it is with the list.
12:55:28 <DMcGill> perhaps use IntMap?
12:55:32 <naula> I really don’t know, which Debian-packages I shold remove
12:56:37 <c_wraith> naula: removing either one won't help. The problem is that you are trying to build an old package with a new version of ghc.  it used to be possible to use those packages together.  That's no longer the case
12:56:41 <Yuu-chan> The "memoize" package is fine is fine
12:57:12 <naula> c_wraith: what should I do?
12:57:46 <c_wraith> naula: Either use an older version of ghc, or go through whatever packages depend on haskell98, and update them to use base instead.
12:57:47 <naula> I am trying to compile this to Debian-package: http://rampa.sk/static/wikipedia4epub.html
12:58:16 <naula> c_wraith: but Debian really don’t have package called haskell98
12:58:32 <c_wraith> naula: it's a haskell package, not a debian package
12:58:47 <c_wraith> naula: debian's package manager is a very poor fit with haskell's package system
12:59:07 <c_wraith> well, with ghc's package system.
12:59:13 <naula> c_wraith: I also compiled all needed haskell-packages to Debian-package
12:59:32 <naula> c_wraith: oh, wait.
13:00:00 <naula> c_wraith: only dependency, I needed to compile to Debian-package, was EPUB
13:00:25 <startling> c_wraith, what makes apt bad for haskell packages?
13:00:26 <naula> c_wraith: everything else was found as Debian-packages from Debian-distribution
13:00:44 <startling> c_wraith: (not trying to argue, just curious)
13:03:07 <naula> c_wraith: hmmm… It seems GHC 6.12 is enough for compiling that software. latest version Debian provides, is 7.4.1-4
13:03:38 <xvilka> morning/day/evening/night!
13:04:31 <xvilka> are diffs between hugs implementation and ghc very big?
13:05:08 <c_wraith> startling: apt isn't great because packages tend to be highly unstable. things change very rapidly, and apt just isn't good for that.
13:05:21 <MostAwesomeDude> xvilka: I would imagine so.
13:05:24 <c_wraith> xvilka: they are entirely different in almost every way.
13:05:31 <xvilka> asking, mostly because have system with ported hugs on it, not yet ported ghc (some custom proprietry stuff), wonder how-much changes need to port, e.g. parsec
13:05:56 <c_wraith> xvilka: oh, you mean differences between packages for hugs vs packages for ghc
13:06:03 <xvilka> yes
13:06:11 <startling> c_wraith: ah, of course
13:06:27 <startling> xvilka: ghc has a number of extensions that hugs doesn't have
13:06:29 <c_wraith> xvilka: the base package works with both - but it uses a lot of conditional compilation
13:07:04 <xvilka> ah, so for parsec it will works, but not for all packages
13:07:13 <xvilka> s/works/work/
13:09:11 <mm_freak> nand`: why don't you just use select xs ! i?
13:09:27 <mm_freak> select "abc" ! 1 = ('b', "ac")
13:09:51 <nand`> mm_freak: I'd need (\(x,xs) -> (x, x:xs)) . select
13:10:06 <mm_freak> nand`: that's a type error
13:10:23 <nand`> .:
13:10:30 <nand`> oh
13:10:32 <nand`> no
13:10:55 <nand`> \xs i -> ... $ select xs ! i
13:11:16 <mm_freak> i mean you can write 'pick' in terms of 'select'
13:11:45 <nand`> yes; like I said, that could work
13:11:59 <nand`> is select in any standard library?
13:13:14 <latro`a> select is in Data.List afaik?
13:13:22 <latro`a> or am I thinking of a different select
13:13:27 <latro`a> there's a utility function that partition uses
13:13:29 <nand`> doesn't seem to be
13:13:36 <latro`a> it may not export it
13:13:56 <latro`a> select :: (a -> Bool) -> a -> ([a], [a]) -> ([a], [a])
13:13:56 <latro`a> select p x ~(ts,fs) | p x       = (x:ts,fs)
13:13:56 <latro`a>                     | otherwise = (ts, x:fs)
13:14:08 <latro`a> that may not be what you meant, though
13:16:14 <Quantumplation> how would I find the maximum *value* of a Data.Map? findMax returns the maximum *key*
13:16:15 <mm_freak> nand`: doubt it…  just use the code from the post, because it's quite efficient
13:16:38 <mm_freak> Quantumplation: you'll have to traverse
13:16:42 <latro`a> quantumplation: fold
13:16:43 <avpx> Quantumplation: It may not be provided, that'll be O(n)
13:16:49 <avpx> Err
13:16:51 <mm_freak> Quantumplation: maximum . M.toList
13:16:57 <latro`a> um
13:17:00 <latro`a> you can do it with a fold
13:17:05 <latro`a> without converting to list
13:17:15 <mm_freak> that is a fold, and the list is deforested away =)
13:17:22 <latro`a> touche
13:17:25 <edwardk> Quantumplation: viewMaxWithKey
13:17:26 <latro`a> damn compiler
13:17:28 <edwardk> Quantumplation: or viewMax
13:17:29 <latro`a> clever little bastard
13:17:36 <edwardk> Quantumplation: both are O(log n)
13:17:50 <edwardk> avpx: its provided
13:17:58 <mm_freak> edwardk: maximum value, not key
13:17:58 <latro`a> wait, how can you do that in logn time
13:18:02 <latro`a> yeah
13:18:08 <avpx> ^
13:18:24 <latro`a> it's madness to say you can do that in logn time, the tree structure has nothing to do with the values
13:18:38 <edwardk> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/Data-Map.html#v%3AmaxViewWithKey
13:18:46 <edwardk> mm_freak: i have a lens to it, so it better be there ;)
13:19:18 <edwardk> maxView :: Map k a -> Maybe (a, Map k a)
13:19:18 <latro`a> maximal (key,value) pair
13:19:21 <edwardk> maxViewWithKey :: Map k a -> Maybe ((k, a), Map k a)
13:19:23 <latro`a> there's no Ord a constraint
13:19:24 <avpx> edwardk: That's maximal *by key*
13:19:28 <edwardk> oh
13:19:32 <latro`a> yeah
13:19:35 <edwardk> i thought he wanted the maximum value by key
13:19:37 <edwardk> got it
13:20:01 <edwardk> yeah you're screwed ;)
13:20:05 <latro`a> lol
13:20:11 <monochrom> a better question: why do you use Map if you intend to find the maximum value eventually
13:20:12 <avpx> Heh. Thus the fold suggestion
13:20:18 <edwardk> yep
13:20:19 <Quantumplation> that's ok, I only need to do it once
13:20:41 <avpx> Probably lots of O(log(n)) operations and the occasional O(n) operation
13:20:45 <DMcGill> can Sets and Maps be infinite?
13:20:55 <edwardk> DMcGill: no
13:21:04 <edwardk> DMcGill: the chosen representation is spine strict
13:21:30 <gertc> why is Data.SafeCopy based on Data.Serialize and not serial independed?
13:21:34 <edwardk> you can make a lazier map structure but its basically impossible to balance an infinite map
13:21:52 <avpx> That makes sense
13:21:54 <mm_freak> edwardk: "maximum value by key"? ;)
13:22:23 <edwardk> mm_freak: argmax lookup by key ;)
13:24:00 <MostAwesomeDude> So, while hackage is down, is there any other place to get docs?
13:24:17 <mekeor> MostAwesomeDude: local ;)
13:24:25 <edwardk> MostAwesomeDude: what are you looking for docs on?
13:24:32 <gertc> for example you can not use Data.Binary.Get you have to use Data.Serialize.Get why did they do that?
13:24:41 <monochrom> you could build docs yourself. surprisingly, this doesn't require hackage. tarballs are cached somewhere under .cabal
13:25:08 <mekeor> MostAwesomeDude: you can browse the source code of packages on http://hdiff.luite.com/cgit/
13:25:08 <edwardk> i at least have the lens docs online: =)
13:25:09 <MostAwesomeDude> edwardk: Well, I was looking for Data.Map, and grabbed that from GHC.
13:25:27 <startling> gertc, I like Data.Serialize better than Data.Binary
13:25:30 <mekeor> MostAwesomeDude: me, too! i was looking for Data.Map, too!!
13:25:30 <monochrom> yeah GHC comes with docs. great invention.
13:25:33 <edwardk> http://ekmett.github.com/lens/ for all your haddocky needs. who needs the actual packages?
13:25:35 <startling> presumably so did the authors
13:25:51 <mekeor> monochrom: but where's the docs located, actually?
13:25:59 <gertc> startling, agree but is it technicaly not possible to make both work?
13:26:04 <monochrom> people spend whole lives browsing the web and not 2 seconds browsing their own hard disks
13:26:06 <MostAwesomeDude> Somebody should document the process for deploying a hackage.
13:26:16 <MostAwesomeDude> I know people that could run a mirror.
13:26:22 <monochrom> /usr/local/share/doc/ghc/...
13:26:30 <edwardk> MostAwesomeDude: cmccann had a copy of hackage 2 up on amazon somewhere
13:26:41 <edwardk> not sure where it went/if its still up
13:26:42 <startling> gertc, it would just be another dependency I guess
13:26:44 <monochrom> YMMV
13:27:04 <startling> gertc, you can probably switch the code over without too much difficulty.
13:27:37 <startling> or write a "instance Serial s => Binary s"
13:27:55 <latro`a> uh
13:28:10 <latro`a> that instance is a problem >..
13:28:11 <latro`a> *>.>
13:28:33 <startling> latro`a, why? You'd need FlexibleInstances?
13:28:47 <gertc> startling, can you show me how? or is it more work then just a few lines? example https://gist.github.com/3319363
13:29:05 <latro`a> UndecidableInstances
13:29:12 <avpx> Yeah
13:29:18 <Taneb> What's the data X = X :: Int -> X extension called?
13:29:19 <latro`a> much more violent
13:29:26 <avpx> http://lukepalmer.wordpress.com/2008/04/08/stop-using-undecidable-instances/
13:29:50 <startling> gertc: def. more than a few lines. Also, I'm sort of new to the API myself
13:30:13 <mauke> Taneb: GADTs?
13:30:25 <startling> oh weird, what makes it undecidable? the fact that there's a single type variable?
13:30:26 <monochrom> GADTs would not use "="
13:30:26 <Taneb> What does it allow that plain-old-haskell can;t do?
13:30:49 <Taneb> And that means...
13:30:56 <startling> heh, "There was one today asking why the typechecker was getting into an infinite loop…"
13:31:22 <mauke> startling: that the type doesn't get smaller
13:31:27 <avpx> startling: AFAIK it's because the instance is matched by the head, so basically it sees "forall s. Binary s"
13:31:30 <monochrom> "data X a where Ctor :: X Double" is something plain old haskell can't do
13:31:41 <startling> mauke: right
13:31:54 <geekosaur> http://www.haskell.org/haskellwiki/GADT might be instructive
13:31:56 <Taneb> monochrom, hmm
13:32:05 <gertc> startling, ok so its not adding a instance right? you need to add some code to api itself?
13:32:07 <LambdaPhi> I have a question about flow controls, the example I have is a project euler problem so if someone would like to help me in PM that would be nice.
13:32:38 <LambdaPhi> So I'm not posting the answer to one, (it's in one line by the way)
13:32:43 <avpx> Taneb: It's useful because you can have constructors which produce more specific types than they might otherwise.
13:32:53 <mauke> LambdaPhi: which problem?
13:32:53 <Taneb> That seems useful
13:33:05 <LambdaPhi> Number 9, I solved it in one line
13:33:12 <mauke> so did I
13:33:22 <mauke> > head [a * b * c | a <- [1 .. 995], b <- [a + 1 .. 999 - a], c <- [1000 - a - b], b < c, a ^ 2 + b ^ 2 == c ^ 2]
13:33:24 <lambdabot>   31875000
13:33:27 <callen> what's the simplest Haskell HTML templating library? I'm looking for something like Jinja2.
13:33:30 <avpx> Taneb: Basically you just type the constructor as an ordinary function, with some restrictions.
13:33:33 <LambdaPhi> ah
13:33:34 <LambdaPhi> head
13:33:35 <callen> I don't like Blaze and Heist.
13:33:40 <startling> hmm, newtype ToBinary x = ToBinary x and "instance Serial s => Binary (ToBinary s)" ? does that fix the problem?
13:33:48 <LambdaPhi> I had almost the exact same answer
13:33:48 <startling> callen: blaze-html is weird but very nice
13:34:03 <startling> callen: weird because you're using combinators to create html
13:34:33 <startling> oh oops
13:34:37 <callen> startling: that's great, but I don't care. I really just want simple text injection.
13:34:39 <startling> wow how did I miss that
13:34:44 <callen> startling: I need plain HTML templates a front-end guy can use
13:34:49 <callen> startling: and the backend just injects the data.
13:34:49 <LambdaPhi> But it would after finding the answer it would go through all the other possible conbinations
13:34:58 <startling> callen: hstringtemplating is a thing I think
13:34:59 <avpx> startling: Yeah, that will fix the problem.
13:35:02 <LambdaPhi> [(x,y,z) | x <-[1..max], y <- [1..max], z<-[1..max], (x^2)+(y+2)==(z^2) , x + y + z == 1000]
13:35:06 <startling> @hackage hstringtemplating
13:35:06 <lambdabot> http://hackage.haskell.org/package/hstringtemplating
13:35:13 <callen> startling: thanks.
13:35:27 <latro`a> LambdaPhi, no, it only computes the head
13:35:34 <avpx> startling: That is generally how this problem is solved.
13:35:38 <LambdaPhi> Yeah, that's what I was missing
13:35:41 <latro`a> this means it does go through many combinations before it finds it, but it doesn't go any further
13:35:44 <startling> avpx: good to know. thanks
13:35:45 <LambdaPhi> So thanks mauke
13:35:48 <avpx> It's too bad, because Num g => Group g really *feels* like a good instance.
13:35:49 <gertc> callen: use js and websockets example https://github.com/gertcuykens/haskell-design
13:36:00 <startling> avpx: indeed
13:36:04 <latro`a> avpx--no? there are different groups
13:36:08 <latro`a> he made that point in the article
13:36:11 <startling> avpx: but there are a handful of possible groups, yeah?
13:36:12 <startling> yeah
13:36:14 <parcs`> callen: check out heist and hsp
13:36:24 <avpx> latro`a: Right, I get that.
13:36:24 <latro`a> this is why Num doesn't have a Monoid, too
13:36:35 <callen> parcs`: I already said no to Heist
13:36:45 <callen> parcs`: but thank you. I'll look at hsp.
13:36:47 <avpx> latro`a: I'm just saying that it's very reasonable to make a statement like, "Every type satisfying Num should satisfy Group"
13:36:57 <callen> parcs`: ooh, no @ hsp
13:37:03 <avpx> But you have to add a layer of indirection to make this into Haskell.
13:37:05 <callen> parcs`: I don't want server pages, I want separate logic and templating
13:37:17 <callen> parcs`: I just want plain old fashioned templates, no magical bullshit.
13:37:22 <callen> parcs`: I think hstring will work.
13:37:22 <latro`a> avpx--if you are writing your own stuff, you can do that, but you have to go the other way
13:37:46 <startling> I sort of wish there was a nice way to make have a handful of different instances for a single class without newtype
13:37:51 <latro`a> which is just necessary to ensure type inference is, well, decidable
13:37:58 <avpx> I think I'm being misunderstood as if I'm saying I like undecidable instances.
13:38:07 <parcs`> callen: there's going to be magic somewhere unless you're working with static html
13:38:08 <latro`a> I understand what you're saying
13:38:17 <latro`a> it looks like it makes sense, definitely
13:38:33 <latro`a> but it's not really "satisfy" so much as "provide"
13:38:36 <callen> parcs`: I've been doing web dev for a long time, I know what I need and want.
13:38:45 <callen> parcs`: having the templates be part of the code isn't one of them.
13:38:56 <avpx> latro`a: Fair enough.
13:39:00 <callen> parcs`: if the templates are in the haskell code, my frontend guy will shit a goat and bleed to death.
13:39:02 <LadyAurora> Hi.
13:39:04 <latro`a> I think your point's stronger when there's only one valid definition to provide, like in Functor-Applicative-Monad
13:39:14 <parcs`> okay, hope you find what you're looking for
13:39:16 <callen> parcs`: so unless you're volunteering to write the JavaScript and frontend for us, I need plain. motherfucking. html. files.
13:39:39 <avpx> Yeah, but then it can be done using dependencies between classes. class Functor m => Monad m where ...
13:39:59 <LadyAurora> What's the reason of Hackage downtime?
13:40:07 <avpx> Or better, class Functor m => Applicative m where... class Applicative m => Monad m where ... I guess
13:40:15 <MostAwesomeDude> LadyAurora: Apparently they're doing network updates?
13:40:17 <parcs`> LadyAurora: network maintenance
13:40:42 <LadyAurora> Makes sense.
13:40:47 <LadyAurora> And thanks.
13:41:28 <startling> LadyAurora: the monomorphism restriction
13:41:38 <startling> or maybe undecidable instances
13:41:38 <avpx> It strikes again!
13:42:07 <edwardk> wow, we have a lot more users than last time i looked. when did we cross 900?
13:42:37 <aristid> how big's the biggest freenode channel? :D
13:42:42 <parcs`> #haskell's been  hovering around 900 for a month or two i think
13:42:49 <startling> yeah
13:42:50 <jmcarthur> huh, i didn't notice that either
13:42:55 <startling> aristid: I think it's #python
13:43:00 <parcs`> highest i've seen was 930
13:43:03 <edwardk> i usually sign in with textual which doesn't show me
13:43:10 <startling> aristid: python is 986
13:43:12 <callen> startling: no, it's Ubuntu
13:43:13 <LadyAurora> edwardk: only 900? Why #haskell's not over 9000 yet?
13:43:17 <callen> startling: over 2,000 people last I saw.
13:43:19 <edwardk> i remember when we crossed 400 and thought we were bursting at the seams
13:43:20 <parcs`> startling: debian is bigger
13:43:22 <aristid> startling: it's close!
13:43:23 <parcs`> #debian*
13:43:33 <callen> I guarantee ubuntu is the biggest on here.
13:43:36 <startling> oh, maybe I'm thinking "biggest programming language channel"
13:43:40 <avpx> Can't we write scripts to figure this out for us?
13:43:50 <parcs`> let's all temporarily join #ubuntu!
13:43:51 <MostAwesomeDude> You could just ask #freenode.
13:43:53 <aristid> still, #haskell is one of the larger channels
13:43:54 <callen> parcs`: fuck that
13:44:00 <startling> indeed
13:44:05 <nand`> avpx: that might be difficult since you'd need to exhaustively join every single channel, some of which are secret
13:44:05 <parcs`> bah, only 1600
13:44:17 <Taneb> I wonder why Haskell is so popular?
13:44:19 <nand`> as in, ‘not listed in channel listing requests’
13:44:26 <startling> nand`: I think we can conclude that the secret ones aren't the most popular
13:44:31 <sipa> Taneb: is it?
13:44:35 <startling> Taneb: I think this is just a nice channel
13:44:37 <aristid> Taneb: because steve yegge hates it
13:44:38 <edwardk> nand: it is a pretty safe bet that if its private, its not THAT big ;)
13:44:38 <Taneb> sipa, it's IRC channel is
13:44:41 <avpx> nand`: Yeah, I didn't know if the channel listing included that
13:44:41 <Taneb> Hmm
13:44:49 <avpx> The number of users, I mean
13:44:53 <Taneb> Without the Murderous Maths books, I would have never found Haskell
13:44:55 <naula> Is it possible to use GNU stow when compiling and installing Haskell-packages?
13:45:13 <Taneb> Same with a whole bunch of things
13:47:00 <avpx> According to irc.netsplit.de, ubuntu is the biggest with 1583 users
13:47:14 <edwardk> we can take em
13:47:20 <avpx> Haskell is reasonably high up there.
13:47:27 <parcs`> what's its rank?
13:47:34 <sipa> with 70k users connected to the network, that is a nice %
13:47:41 <avpx> #7 according to this site, which I think is right
13:48:00 <hanshoglund> no
13:48:06 <startling> I wonder where python-unregistered is.
13:48:16 <startling> 664 right now
13:48:17 <parcs`> there's a channel called #MEGA_FANTASY
13:48:17 <startling> heh
13:48:20 <parcs`> with 2000 people
13:48:28 <avpx> parcs`: That's on all of the networks it indexes
13:48:29 <naula> BTW did you see some article that said amount of users has been slowly decreasing in most IRC-networks except this?
13:48:36 <jmcarthur> 1 out of 77 freenode users are in #haskell
13:48:57 <avpx> jmcarthur: How do you figure?
13:49:13 <avpx> Remember that users can be in multiple channels
13:49:14 <jmcarthur> avpx: based on sipa's claim of 70k users on the network
13:49:15 <startling> naula: yeah, freenode's been growing for quite some time
13:49:22 <jmcarthur> i didn't say exclusively in #haskell
13:49:50 <avpx> jmcarthur: Yeah, nevermind. I derped.
13:50:34 <avpx> We're about a hundred users above the C++ channel.
13:50:35 <hpaste> gertc pasted “safecopy binary” at http://hpaste.org/72985
13:50:56 <gertc> startling, you mean something like this rigth ?
13:50:57 <avpx> I also like how the channel topics portray the kind of user wandering into the channel
13:51:18 <avpx> Python: "NO LOL | NO PROJECT EULER..."
13:51:49 <parcs`> ##c++: we don't do homework
13:51:51 <LadyAurora> TIL System.Random is dog slow.
13:51:55 <avpx> C++: " ... we don't do hom--damn it parcs`
13:52:06 <shirt> i liked it back when the topic here included "we put the funk in funktion"
13:52:30 <startling> #0x10c-dev: NO DRAMA
13:52:30 <avpx> We put the morphism back in isomorphism!
13:52:42 <jmcarthur> It's morphism time!
13:52:52 <parcs`> #agda: please comment your agda
13:52:58 <jmcarthur> lol
13:53:04 <parcs`> Agda safety: we last proved false on April 18th 2012
13:53:27 <callen> Couldn't match expected type `Data.Text.Lazy.Internal.Text' with actual type `String'
13:53:33 <callen> how do I convert from String to Text?
13:53:36 <avpx> parcs`: I bet there's one of those workplace calendars
13:53:42 <callen> it's a rather generic google query and doesn't bring up anything meaningful.
13:53:51 <aristid> callen: Data.Text.pack
13:53:53 <avpx> "False last proved 0 days ago"
13:53:56 <MostAwesomeDude> @hoogle String -> Text
13:53:57 <lambdabot> Data.Text.Lazy pack :: String -> Text
13:53:57 <lambdabot> Data.Text pack :: String -> Text
13:53:57 <lambdabot> Prelude read :: Read a => String -> a
13:54:01 <parcs`> hehe
13:54:06 <callen> aristid: thank you!
13:54:16 <aristid> callen: also, see @hoogle
13:54:28 <aristid> callen: there's an online version of hoogle, too
13:54:39 <parcs`> haskell's topic is relatively boring :(
13:54:44 <callen> aristid: Couldn't match expected type `Data.Text.Lazy.Internal.Text' with actual type `Text'
13:54:45 <avpx> callen: It's in IsString
13:54:50 <avpx> I think
13:55:01 <MostAwesomeDude> callen: You'll need to use pack from Data.Text.Lazy then.
13:55:08 <aristid> callen: oh, you need to say it's a lazy Text :P
13:55:26 <diaphoros> e
13:55:32 <LadyAurora> f
13:55:38 <callen> aristid: I changed it to Data.Text.Lazy
13:55:41 <callen> but now it's utterly batshit.
13:56:14 <aristid> g
13:56:24 <hpaste> callen pasted “batshit” at http://hpaste.org/72986
13:56:30 <callen> aristid: ^^
13:56:57 <callen> MostAwesomeDude: you seem to have been right but now the Scotty action is breaking I think.
13:57:14 <aristid> callen: that problem is not related to the packing of text.
13:57:21 <callen> I know, it's a new problem.
13:57:27 <callen> the Data.Text.Lazy pack worked, I think.
13:57:53 <ion> "" last proved False days ago. (Weakly typed languages.)
13:58:08 <avpx> You probably need to lift a type from IO to ActionM or something
13:58:14 <aristid> callen: you might need to put the readFile in liftIO
13:58:23 <avpx> I'm not familiar with ActionM though so I can't say for sur
13:58:25 <avpx> e*
13:58:29 <Taneb> ion, what's meant to be where the "" is?
13:58:30 <aristid> @hoogle liftIO
13:58:31 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
13:58:31 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
13:58:31 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
13:58:43 <DMcGill> @src max
13:58:43 <lambdabot> max x y = if x <= y then y else x
13:58:52 <DMcGill> @src maximum
13:58:53 <lambdabot> maximum [] = undefined
13:58:53 <lambdabot> maximum xs = foldl1 max xs
13:59:06 <callen> aristid: hrm. I will investigate, thank you.
13:59:14 <callen> @hoogle ActionM
13:59:14 <lambdabot> No results found
13:59:28 <DMcGill> I saw a blog post about optimising maximum to use constant space
13:59:32 <ion> taneb: "" is coerced into 0/False in some weakly typed languages.
13:59:38 <MostAwesomeDude> @src maximum'
13:59:38 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:59:41 <MostAwesomeDude> @src maximumBy'
13:59:41 <lambdabot> Source not found.
13:59:43 <DMcGill> does anybody remember where it is? It mostly involved making things strict iirc
13:59:46 <avpx> DMcGill: It wouldn't be hard
13:59:49 <avpx> You just have to use a strict fold
13:59:52 <MostAwesomeDude> Huh, could have sworn there was one somewhere standard.
13:59:54 <nand`> a bit late but
13:59:56 <nand`> [("#ubuntu",1584),("#debian",1224),("##linux",1092),("#python",987),("#gentoo",965),("#freenode",917)]
13:59:59 <Taneb> ion, okay
14:00:01 <nand`> all the channels larger than #haskell
14:00:07 <nand`> according to a publist /LIST
14:00:09 <avpx> nand`: Well done. How did you do that?
14:00:10 <nand`> public *
14:00:16 <avpx> Ah, okay, so it *was* in the listing :p
14:00:23 <Taneb> If we team up with gentoo, we'll be the best
14:00:28 <aristid> nand`: the plan for freenode domination is on target.
14:00:33 <LadyAurora> lol #ubuntu
14:00:35 <ion> ghc -O999 -funroll-loops
14:00:38 <parcs`> i thought gentoo was dying
14:00:46 <nand`> parcs`: I thought the opposite
14:00:58 <Taneb> I'm not entirely sure what gentoo is
14:01:01 <Taneb> A linux distro?
14:01:04 <parcs`> you thought it was flourishing?
14:01:12 <aristid> parcs`: i bet there's a bit of exodus from ubuntu to gentoo.
14:01:31 <MostAwesomeDude> Taneb: Yes.
14:01:37 <Taneb> What's it like?
14:01:46 <nand`> avpx: using nc irc.freenode.net 6667 > list to dump a /LIST; then filtered that with a bit of regex magic down to ‘#chan 123’ pairs; then used a small haskell program to parse that and sortBy (comparing snd)
14:01:48 <typoclass1> Taneb: yeah, gentoo is a linux distro. afaik it's source-only (you have to compile absolutely everything)
14:01:49 <parcs`> ubuntu -> gentoo is quite the leap for most ubuntu users
14:02:00 <avpx> nand`: Well done. *applause*
14:02:02 <Taneb> typoclass1, so, GHC is quite hard to get on it?
14:02:11 <avpx> Taneb: Its package manager is inspired by FreeBSD
14:02:11 <LambdaPhi> @src foldr
14:02:12 <lambdabot> foldr f z []     = z
14:02:12 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:02:13 <nand`> Taneb: It's the best linux distro I've used in my life, and I've used a few. It's the only one I like
14:02:20 <nand`> but that's subjective :)
14:02:23 <LambdaPhi> @src foldl
14:02:24 <lambdabot> foldl f z []     = z
14:02:24 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:02:32 <LadyAurora> Taneb: http://funroll-loops.info/
14:02:32 <nand`> (and probably off-topic here)
14:02:34 <Taneb> nand`, I'm used to Ubuntu now
14:02:56 <Jurily> Exherbo > Gentoo
14:02:59 <nand`> I can tell you why I like gentoo in #haskell-blah if you like
14:03:08 <Taneb> Nah, I'm ok
14:03:21 <Taneb> Instead you can tell me where I can learn how to use type families in here
14:03:30 <LadyAurora> Oh, I forgot to mention I'm using *Arch Linux*.
14:03:31 <nand`> http://www.haskell.org/haskellwiki/GHC/Type_families
14:03:33 <shapr> LadyAurora: Are you Valerie?
14:03:40 <LambdaPhi> Hello LadyAurora
14:03:43 <LambdaPhi> do I know you?
14:04:00 <DT``> NixOS > GoboLinux > Gentoo, IMHO.
14:04:02 * shapr boings frustratedly at his code
14:04:08 <LadyAurora> shapr: no.
14:04:20 <shapr> LadyAurora: Oh ok, thought I might know who you are :-)
14:04:27 <LambdaPhi> same
14:04:30 <shapr> LadyAurora: In that case, welcome to #haskell with all its brain building-ness!
14:05:05 <LadyAurora> shapr: sometimes I hate my given name.
14:05:19 <shapr> LadyAurora: I had that problem, so I changed mine.
14:05:30 <nand`> Taneb: (to answer your question; no, gentoo maintains its haskell packages very well. there's a #Gentoo-Haskell chan/team dedicated to this stuff. it's as simple as ‘emerge ghc’ to have it bootstrap ghc for you; and versions 6.x, 7.0.x, 7.4.x, 7.5.x, 7.7.x and live are supported)
14:06:31 <nand`> depending on how broken you want your GHC to be
14:06:31 <shapr> It's the Haskell approach, I am represented by my function, not by my identity directly... or maybe I've just had too much caffeine.
14:06:31 * shapr writes more code
14:06:31 <mekeor> is "Monad m => a -> m b" called a "Kleisli monad" or a "Kleisli category" or what?
14:06:31 <LadyAurora> shapr: but I hate mine only sometimes, most of the time I like it.
14:06:38 <shapr> LadyAurora: oh, that's good!
14:06:49 <Taneb> mekeor, Kleisli arrow, I think
14:06:52 <aristid> mekeor: maybe just say "a kleisli"? ;)
14:06:59 <nand`> kleisli arrow yea
14:07:01 <mekeor> Taneb: ah, yeah, sounds good
14:07:07 <mekeor> nand`: thanks
14:07:07 <mekeor> aristid: :P
14:07:13 <nand`> the kleisli category is the category in which arrows are of the form a -> m b
14:07:23 <mekeor> oh, okay
14:07:42 <callen> wait so, what does liftIO do exactly?
14:07:49 <shapr> LadyAurora: How does Haskell stack up? Mostly like it?
14:07:52 <mekeor> @type liftIO
14:07:54 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
14:07:57 <nand`> callen: lifts from IO a to MonadIO m => m a
14:07:58 <callen> the stuff I find on Google seems to be about monad transformers.
14:08:05 <nand`> callen: they're related
14:08:32 <LadyAurora> shapr: Haskell sucks, because all programming languages do.
14:08:34 <LadyAurora> But it sucks less than all the others.
14:08:42 <aristid> mekeor: or maybe "kleisli muesli"
14:08:45 <callen> LadyAurora: okay Winston Churchill.
14:09:06 <shapr> LadyAurora: I strongly agree with you :-)
14:09:21 <Jurily> cabal :(
14:09:59 <DT``> LadyAurora, Haskell seems one of the few programming languages that actually tries to not suck.
14:10:03 <avpx> DMcGill: I know this is a bit late but here is an example of a fold that is strict in its accumulator/internal state/whatever you kids call it
14:10:15 <avpx> foldr' f st (x:xs) = let next = next `seq` f x st in foldr' f next xs
14:10:18 <LadyAurora> callen: I said that Haskell is the *best*, Churchill said democracy is the *worst*.
14:10:18 <nand`> aristid: I would eat kleisli müsli
14:10:23 <wires> mekeor, I don't think that the term Kleisly monad is really used
14:10:34 <mekeor> Kleisli
14:10:37 <avpx> You obviously have to add an end conditon so that's: foldr' _ st [] = st
14:10:48 <aristid> nand`: me too
14:10:51 <hpaste> DMcGill pasted “Euler 14” at http://hpaste.org/72989
14:10:54 <wires> mekeor, :)
14:10:59 <wires> see, it's not used
14:11:24 <nand`> I don't think Haskell is the best language; it's just fairly good, better than basically all other languages I know
14:11:24 <DMcGill> I might as well try and avoid the XY problem
14:11:24 <callen> nand`: I ended up figurin it out
14:11:24 <DMcGill> I have no idea if my max' is better than max
14:11:24 <callen> nand`: I was messing up my precedence
14:11:24 <callen> nand`: thank you.
14:11:24 <DMcGill> as in, the default max
14:11:25 <mekeor> wires: it has even a definition in haskell… so i don't agree with you
14:11:38 <nand`> avpx: http://bpaste.net/show/39737/
14:11:39 <avpx> DMcGill: Hey, I happen to have something similar. https://github.com/nvanderw/NumberTheory/blob/master/NumberTheory/Collatz.hs
14:11:46 <avpx> DMcGill: It runs in parallel
14:11:47 <LadyAurora> nand`: exactly.
14:11:48 <mekeor> wires: newtype Monad m => Kleisli m a b = a -> m b
14:11:50 <mekeor> i think
14:12:02 <mekeor> in Control.Arrow
14:12:09 <nand`> Kleisli (a -> m b) but yeah
14:12:13 <wires> ah.. ok
14:12:15 <mekeor> oh, right
14:12:31 <nand`> Monad m => Kleisli m forms a Category with id = return and (.) = (<=<)
14:12:37 <avpx> nand`: I'm still amazed how high in the rankings we are.
14:12:38 <wires> No but, that is just an arrow in the Kleisli category
14:12:42 <nand`> and an Arrow with arr = (return .)
14:12:49 <rosie> s
14:12:49 <wires> exactly
14:13:07 <mekeor> avpx: which rankings?
14:13:10 <nand`> and probably some other ArrowXs
14:13:10 <wires> that is the whole point of this Kleisly thing. you normally compose arrows a -> b, b -> c into a -> c
14:13:12 <latro`a> return . being fmap
14:13:13 <DMcGill> avpx: how does yours run?
14:13:16 <callen> @hoogle simpleHttp
14:13:17 <lambdabot> Network.HTTP.Stream simpleHTTP :: Request_String -> IO (Result Response_String)
14:13:18 <lambdabot> Network.HTTP simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
14:13:18 <lambdabot> Network.HTTP.HandleStream simpleHTTP :: HStream ty => Request ty -> IO (Result (Response ty))
14:13:18 <rosie> Does anyone know what this line of code does? I'm following Real World Haskell, and I'm at the glob to regular expression example: globToRegex cs = '^' : globToRegex' cs ++ "$"
14:13:18 <nand`> which one is needed to get a monad out of them again?
14:13:22 <DMcGill> there doesn't seem to be any memoisation
14:13:23 <nand`> (of arrows, that is)
14:13:24 <latro`a> ArrowChoice
14:13:25 <latro`a> erm
14:13:27 <latro`a> sorry
14:13:28 <latro`a> Apply
14:13:30 <nand`> oh
14:13:30 <avpx> DMcGill: Err, well? I'm not sure how to answer that
14:13:34 <wires> but then you use a monad to change it from a -> m b, b -> m c and compose into a -> m c
14:13:46 <mekeor> callen: use hoogle don't spam #haskell please :/
14:13:46 <latro`a> yeah, ArrowApply
14:13:46 <callen> mekeor: sorry :(
14:13:53 <wires> this is the composition law in the Kleisli category
14:13:56 <nand`> ArrowApply was it; kleisli should have these (with applicative or something)
14:14:03 <mekeor> ArrowChoice exists, too…
14:14:07 <latro`a> yes
14:14:10 <latro`a> I just made a mistake
14:14:15 <typoclass> callen: don't worry :) also, lambdabot is available in private chats ( /query lambdabot )
14:14:20 <DMcGill> for example, mine takes roughly 8 seconds to find the answer for 10000
14:14:21 <wires> I think that is a much easier way to look at Monads...
14:14:22 <latro`a> any Arrow with an ArrowApply that obeys the laws has an associated Monad
14:14:31 <DMcGill> that's the maximum of the first 10000 collatz numbers
14:14:34 * nand` enjoys a steamy private session with lambdabot every now and then
14:14:40 <latro`a> wires--I agree conceptually, but it is rather awkward to actually write
14:14:50 <wires> latro`a, what is?
14:14:53 * mekeor always uses @pl with lambdabot privately.
14:15:01 <avpx> DMcGill: I will try to run mine?
14:15:09 <latro`a> it is awkward to write code, for the most part, using >=>
14:15:16 <nand`> public @pl is like a challenge to ‘reduce this code using your knowledge of comonads and kan extensions’
14:15:18 <LadyAurora> @pl all the things!
14:15:19 <lambdabot> (line 1, column 16):
14:15:19 <lambdabot> unexpected end of input
14:15:19 <lambdabot> expecting white space or simple term
14:15:20 <wires> latro`a, ah, yes, indeed
14:15:29 <callen> typoclass: thank you.
14:15:41 <wires> exactly, so that is why it's rewritten into return + bind...
14:15:44 <edwardk> nand`: =P
14:15:45 <callen> is HTTP.Conduit the way most people do HTTP calls to API endpoints in Haskell?
14:15:47 <avpx> latro`a: I prefer <=< because it goes in the same direction as (.)
14:15:55 <latro`a> indeed
14:15:59 <nand`> edwardk: do you have like a highlight keyword on ‘comonad’ or something?
14:16:00 <latro`a> =<< is nice for the same reason
14:16:08 <edwardk> nand`: kan extension
14:16:14 <nand`> heh
14:16:17 <latro`a> it's kinda annoying when information flows in two directions on a line
14:16:17 <wires> hahaha
14:16:21 <latro`a> also lol
14:16:26 <Mariiii> http://i265.photobucket.com/albums/ii240/Mari-SL/captcha.jpg
14:16:38 <nand`> latro`a: Control.Kleislify can help
14:16:42 <latro`a> by which I mean: m >>= f . g, the information from the m goes all the way to the right and then left
14:16:53 <aristid> edwardk: for "lens" too?
14:17:03 <edwardk> not yet, but good call
14:17:17 <LadyAurora> What are kan extensions?
14:17:24 <nand`> ah
14:17:27 <wires> LadyAurora :)
14:17:29 <nand`> excellent timing, edwardk is here to explain
14:17:34 <avpx> DMcGill: With 8 threads, mine searches for the maximum up to the number 1000000 in 6.5 seconds
14:17:34 <latro`a> also, is there an easy interpretation of: fmap f $ m >>= g = m >>= fmap f . g
14:17:39 <edwardk> LadyAurora: generalized continuation passing style
14:17:44 <nand`> LadyAurora: http://comonad.com/reader/2008/kan-extensions/
14:17:53 <nand`> better question
14:17:54 <avpx> DMcGill: Then again, my CPU is pretty good for this task
14:17:55 <wires> LadyAurora, www.cs.ox.ac.uk/ralf.hinze/Kan.pdf
14:17:55 <nand`> what isn't a kan extension?
14:18:03 <wires> haha
14:18:03 <DMcGill> cool
14:18:04 <edwardk> LadyAurora: there are two followups to that post that nand linked
14:18:19 <edwardk> hinze's article isn't very good for non-category theorists
14:18:19 <latro`a> also, nand`, hackage appears to be derping; what's control.kleislify?
14:18:27 <avpx> DMcGill: I think the issue is that ghc is probably doing memoization behind the scenes
14:18:40 <nand`> latro`a: various functions for composing kleisli arrows together, especially pure/post composition with pure functions
14:18:48 <nand`> pre/post*
14:18:53 <latro`a> ic
14:19:00 <edwardk> nand`: thats why you just use actions
14:19:04 <dfeuer> My k-way merge got much faster when I eliminated the priority queue, switching to divide-and-conquer, but memory use went way up. Any way to reduce this? Conceptually, there's a binary tree whose leaves are lists and whose nodes contain list elements. The remove-min operation should remove the root, then recursively choose the child with a smaller root, move its root up, and recur down. The tree should have k nodes and k leaves
14:19:04 <dfeuer> , and there should be no need to do any allocation at all, but that's not what's actually happening.
14:19:09 <nand`> edwardk: :)
14:19:19 <edwardk> foo^!act bar.to baz.act quux -- look kleisli composition!
14:19:23 <wires> edwardk: yes, but it had to be named, no? but your blog post is good
14:19:27 <wires> as usual
14:20:07 <edwardk> wires: thanks. i talk about kan extensions in a lot of other places on my blog as well
14:20:15 <edwardk> also, there is the monad-ran package on hackage from forever ago
14:20:27 <wires> edwardk, yeah your blog is awesome..
14:20:34 <edwardk> where i demonstrated you can turn all monads and monad-transformers we use into right kan extension transformers
14:21:03 <edwardk> basically cpsing the code exactly once
14:21:23 <wires> I was reading frigging MacLane trying to understand those f*king Kan extensions.. it wasn't until someone told met about CPS that it all clicked
14:21:28 <avpx> DMcGill: http://hpaste.org/72990 <-- That's the chain, if you're curious
14:21:36 <edwardk> i should try to write more stuff
14:21:44 <avpx> The first item in the pair is the number of elements in the chain
14:21:47 <edwardk> i started blogging mostly because shapr kept pestering me to do so
14:22:01 <nand`> reading Mac Lane and understanding these things in Haskell terms often seems to be orthogonal for some reason
14:22:01 <shapr> yay!
14:22:19 <shapr> edwardk: Your posts are wildly popular so I believe I did the right thing :-)
14:22:26 <edwardk> wires: yeah, i don't remember when i first noticed the cps connection
14:22:26 <wires> nand`: it works for me. it's the hard way but then I'm sure I understand it
14:22:29 <avpx> nand`: That book finally arrived at my library!
14:22:32 <avpx> nand`: I am very excited.
14:22:47 <edwardk> i think neil ghani spotted it first
14:22:54 <wires> I think it was him, yes
14:23:01 <edwardk> i met him back at icfp 06 but i had no idea who he was at the time
14:23:17 <edwardk> i was just talking about comonads and cps with someone else
14:23:20 <wires> Ghani is hardcore.. very nice guy
14:23:20 <nand`> wires: sure; I can understand the simple stuff in CT terms and trace that back to Hask myself as well
14:23:26 <edwardk> and he heard the word comonadand perked up and came over
14:23:34 <wires> haha typical
14:23:36 <nand`> wires: I'm just not advanced enough to read about Kan Extensions and stuff in CT terms though
14:23:54 * mekeor needs to read edwardk's whole blog someday.
14:24:00 <Taneb> mekeor, ditto
14:24:00 <edwardk> kan extensions in CT terms are pretty hard, but in haskell they are obvious
14:24:07 <wires> exactly
14:24:10 <wires> that is the funny thing
14:24:25 <LadyAurora> mekeor: try reading whole /r/haskell.
14:24:34 <wires> I didn't understand what was going on in MacLane, but then when you understand the haskell you can go back and see, AAAaah so that's up
14:24:45 <nand`> your post about Codensity / Free monads for FFI was pretty interesting, by the way; is this the Haskell-like JVM language you mentioned to me aeons ago?
14:24:46 <mekeor> LadyAurora: edwardk's blog is better :P
14:24:49 <avpx> wires: Yeah, my hope is that Haskell will give me some context for it
14:24:58 <nand`> the one that unfortunately doesn't seem to be public
14:25:23 <wires> haskell like JVM language?
14:25:31 <nand`> avpx: I'm going to have to order Mac Lane's book some time as well
14:25:36 * wires is excited
14:25:49 <nand`> only book on CT I have as physical copy is Pierce's CT for computer scientists
14:25:59 <wires> Try barr/well or goldblatt's topoi
14:26:05 <edwardk> wires: yeah it can muddle the presentation somewhat because as a category hask is so strong, but then again you can see so much category theory in it directly as a result
14:26:23 <nand`> (I just ordered Bird's Pearls for some fun reading for next year's commuting though)
14:26:24 <edwardk> nand`: pierce himself only vaguely recalls writing that book or anything in it ;)
14:26:30 <Jurily> are there any plans to revive qtHaskell?
14:26:31 <wires> CT hate those books for some strange religious reason, but they are much nicer for computer scientists
14:26:50 <edwardk> barr/wells is awesome
14:26:56 <wires> totally
14:27:01 <wires> but topoi as well
14:27:09 <nand`> which books are these? nmes?
14:27:13 <roconnor> barr/wells is the only CT book I've ever understood
14:27:16 <nand`> ‘Categories for Computing Science’?
14:27:29 <roconnor> possibly because I'm a Computing Scientist
14:27:33 <edwardk> nand`: start with http://www.ling.ohio-state.edu/~plummer/courses/winter09/ling681/barrwells.pdf
14:27:40 <wires> Also, my great hero, Joseph Guogen, wrote: "categorical manifesto", awesome paper
14:27:42 <Taneb> edwardk, can I make videos using your blog as its source?
14:27:45 <startling> roconnor: are you computing? right now?
14:27:50 <edwardk> Taneb: go for it
14:27:54 <roconnor> startling: yes!
14:27:55 <wires> roconnor: Computing :) lol...
14:27:55 <Taneb> Not right no
14:27:57 <Taneb> w
14:28:00 <Taneb> It's late and stuff
14:28:06 <Taneb> And my shirt's dirty
14:29:04 <wires> http://golem.ph.utexas.edu/category/2006/11/a_categorical_manifesto.html
14:29:56 <wires> I would say that ^ should be entry point into CT for every Computation Scientist
14:30:21 <wires> in any case, which haskell JVM language?
14:30:44 <edwardk> wires: we have one thats not quite haskell that runs on the jvm
14:30:46 <wires> I've been thinking about Clojure GHC backend.. no idea how hard that would be
14:31:05 <wires> edwardk, links?
14:31:07 <edwardk> alas it isn't (yet?) open sourced
14:31:11 <wires> ah
14:31:16 <wires> so no links :)
14:31:30 <edwardk> sadly no
14:32:40 <LadyAurora> I have an idea. Instead of targetting the JVM, target the native binary. This way, you can use Haskell.
14:33:24 <wires> LadyAurora, haha.. dork
14:33:39 <wires> the JVM is awesome... sometimes
14:36:20 * Yuu-chan enjoys Emacs with haskell-mode
14:36:42 <shapr> me too!
14:36:44 <MostAwesomeDude> wires: Sadly, the paper referenced is not freely available.
14:37:07 <shapr> Yuu-chan: Are you using the latest code from https://github.com/haskell/haskell-mode ?
14:37:36 <shapr> LadyAurora: You mean, talk to Haskell via JNI or whatever it's called these days?
14:37:59 <Yuu-chan> Early I used only different notepads to write my little pieces of code, and tried Leksah, but have finally overcome my fear of Emacs
14:38:14 <shapr> Yuu-chan: Got any questions about emacs+haskell?
14:38:18 <LadyAurora> shapr: I mean "why bother with JVM". But yeah, that's a possibility.
14:38:33 <Yuu-chan> shapr: yes, I've downloaded it right now.
14:38:43 <shapr> Huh, I've been using emacs for thirteen years now, just a bit longer than I've been writing Haskell.
14:39:13 <LadyAurora> > emacs
14:39:15 <lambdabot>   Not in scope: `emacs'
14:39:31 * nand` jumped straight into vim some day and is still using it since for Haskell code
14:39:34 <nand`> very pleasant
14:39:38 <Yuu-chan> shapr: probably only newbish questions :)
14:40:13 <shapr> Yuu-chan: Hey, this channel is for all Haskell questions, newbish or not.
14:40:17 <zhulikas> I've always wanted to start using vim...
14:40:19 <zhulikas> but I just can't... :|
14:40:21 <shapr> I certainly have newbish questions on a regular basis.
14:40:35 <shapr> I'd like to learn more vim power myself.
14:40:37 <hiptobecubic> vim is my favorite and least favorite program.
14:40:46 <shapr> I don't know much more than :syntax on :-(
14:40:49 <nand`> my favorite program is probably pentadactyl
14:41:13 <zhulikas> heh, 13 years
14:41:15 <shapr> My favorite program is the one I'm working on right now!
14:41:17 <LadyAurora> shapr: and :q!, don't forget :q!
14:41:24 <zhulikas> I've been programming only for two years
14:41:27 <Yuu-chan> shapr: wow, that's astonishing!
14:41:28 <zhulikas> that's probably the problem
14:41:35 <shapr> LadyAurora: oh is THAT how I exit vim? I should totally stop using kill -9 ;-)
14:41:41 <Yuu-chan> shapr: I mean your experience
14:41:42 <zhulikas> I'm part of GUI generation which will never accept CLI!
14:41:55 <nand`> if you ^C it tells you to use :q and if you :q it tells you to use :q! (assuming you've accidentally changed something in the file)
14:41:58 <shapr> Yuu-chan: Eh, time spent is not always spent well :-)
14:42:02 <hiptobecubic> nand`, I used firefox from version <1, but I switched to luakit a few months ago and can't see myself going back.
14:42:12 <zhulikas> why not just :wq
14:42:18 <nand`> zhulikas: I grew up on windows post-GUI and I embrace the CLI these days :)
14:42:23 <shapr> I think it's good to try new things on a regular basis.
14:42:28 <zhulikas> right
14:42:32 <shapr> I keep trying to learn and like Ruby, but it doesn't work for me :-(
14:42:37 <zhulikas> I love my linux experience though
14:42:38 <Jurily> I use firefox exclusively for Haskell docs
14:42:39 <LadyAurora> zhulikas: because you don't always want to write.
14:42:40 <nand`> hiptobecubic: I used firefox from version <1 as well; in fact my current profile traces all the way back to firefox 2.0 I think, maybe even 1.x
14:42:42 <shapr> And Agda blows my mind...
14:42:43 <zhulikas> even though I grew up with windows
14:42:45 <Jurily> with Tree Style Tab
14:42:47 <nand`> hiptobecubic: but I just can't see myself switching anytime soon
14:43:09 <shapr> zhulikas: me too! I grew up with CPM!
14:43:43 <LadyAurora> shapr: what's the emacsish for "save to file"?
14:43:46 <hiptobecubic> nand`, i liked pentadactyl, but learning haskell meant closing firefox because i only had 2GB of ram.
14:43:55 <geekosaur> C-xC-s
14:44:10 <callen> okay, I have some simple, VERY simple XML to read, what's the simplest XML library for Haskell to do this?
14:44:15 <shapr> LadyAurora: Yah, what geekosaur said
14:44:15 <hiptobecubic> Meta-xC-xC-butterfly....
14:44:19 <shapr> ha
14:44:23 <geekosaur> well, that's save to original file.  C-x w writes to an arbitrary file
14:44:33 <nand`> hiptobecubic: firefox is only using 500 MB here, I would be able to survive on 2 GB
14:44:40 <geekosaur> Escape Meta Alt Control Shift :p
14:44:43 <LadyAurora> callen: simple XML doesn't exist.
14:44:47 <hiptobecubic> callen, regular expressions :)
14:44:49 * hiptobecubic hides
14:44:52 <callen> come on.
14:45:02 <callen> LadyAurora: yes it does, I have an API to futz around with.
14:45:05 <wires> MostAwesomeDude, which paper?
14:45:11 <Jurily> call out to Perl!
14:45:13 <shapr> callen: I've used both HXML Toolbox and HaXML
14:45:19 <MostAwesomeDude> wires: The category manifesto.
14:45:31 <nand`> shame, I can't seem to buy Barr/Wells' CT book here
14:45:35 <callen> shapr: I'll look into HXML, HaXML looked way overdone for my purposes.
14:45:37 <callen> shapr: thank you.
14:45:40 <shapr> callen: But I haven't used either recently, so something like tagsoup may do what you want : http://community.haskell.org/~ndm/tagsoup/
14:45:57 <wires> LadyAurora, there are tons of cool libraries for the JVM
14:46:36 <LadyAurora> wires: now that's a reason.
14:46:41 <shapr> callen: Yah, you may want to read this first: http://community.haskell.org/~ndm/darcs/tagsoup/tagsoup.htm
14:47:01 <shapr> I've heard tagsoup is simpler/easier than HXT and HaXML.
14:47:24 <shapr> callen: I made 500 euro once for a weekend of hacking up HXT code :-)
14:47:39 <wires> MostAwesomeDude, http://cseweb.ucsd.edu/~goguen/projs/sem.html <-- go down a bit
14:47:39 <Yuu-chan> shapr: well, if you ask... Is it possible to jump to the position of an error in the code?
14:47:53 <shapr> Yuu-chan: YES! C-x ` is the emacs-standard way to do that.
14:48:01 <MostAwesomeDude> wires: Sweeet.
14:48:08 <shapr> Yuu-chan: haskell-mode was recently changed to not do that correctly :-/
14:48:16 <wires> btw checkout Goguen, the guy is bad ass
14:48:22 <wires> true hero
14:48:44 <shapr> Yuu-chan: In the meantime, if you hit C-c C-l to load the code into your interpreter, you can hit C-` to jump to the repl, and press enter on the most recent error message.
14:48:53 <shapr> Yuu-chan: Was that clearer than mud? :-)
14:49:20 <callen> shapr: thanks for the pointer on tag soup.
14:50:08 <wires> LadyAurora, another reason to use the JVM (IMHO) is the monitor. JMX rulz. You just create a class with some special naming providing you with some guage and immediatly you can monitor it using tools like visualvm (http://www.semanticmetadata.net/wp-content/uploads/2008/07/visualvm.png)
14:50:10 <Yuu-chan> C-` doesn't work :-\ Probably because of the Japanese layout
14:50:21 <hpaste> nand` pasted “Typeclasses” at http://hpaste.org/72991
14:50:27 <nand`> This is how typeclasses are implemented under the hood, right?
14:50:27 <shapr> callen: Tell me how it turns out!
14:50:52 <shapr> Yuu-chan: Are you using the most recent haskell-mode from github?
14:51:13 <hiptobecubic> poor hackage. still exploding?
14:51:18 <shapr> Yuu-chan: If you're using a version that's more than six months old, C-c C-l will load your source and jump to the results.
14:51:19 <Yuu-chan> shapr: yes, have just downloaded and installed it
14:51:27 <nand`> hackage is in a state of perpetually falling around its own axis
14:51:29 <wires> exactly. Jezus christ, doesn't Galois know that people use that site?
14:51:39 * shapr misses hackage
14:51:53 <aristid> shapr: i think even haskell-mode 2.8 had C-c C-l?
14:51:55 <shapr> wires: Sounds like we need a mirror.
14:51:55 <wires> Other sites are down to, like http://halvm.org/
14:51:56 <luite> my mirror still works
14:52:12 <luite> only packages though, no haddock yet
14:52:12 <wires> luite, where?
14:52:15 <shapr> aristid: Yah, but jumping to error has changed in the past six months.
14:52:25 <aristid> shapr: oh
14:52:48 <luite> wires: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
14:52:55 <Yuu-chan> shapr: C-c C-l loads source into the ghci, but doesn't jump into the new buffer
14:53:15 <wires> luite, just drop that line in .cabal?
14:53:27 <phaer> Has hackage been down for longer time? I just noticed it and like to know if i can except it to be up again in the next hour.
14:53:31 <luite> wires: in ~/.cabal/config , comment out the hackage.haskell.org one
14:53:40 <wires> luite, thanks, sweet!!
14:53:45 <luite> phaer: probably not, they're having network maintenance
14:53:51 <shapr> Yuu-chan: Ok, you're using a recent version, and I would expect C-` to be bound to haskell-interactive-bring
14:54:00 <Yuu-chan> shapr: pressing C-` results to "C-enlw is undefined"
14:54:05 * shapr blinks
14:54:16 <shapr> enlw? is that a character?
14:54:46 <geekosaur> *blink*
14:54:57 <shapr> Yuu-chan: emacs has some nifty help that can tell you what key to press to call a particular function, or it can say what function is called for a particular key.
14:55:01 <wires> it's been down since 19.00 CET approx
14:55:19 <shapr> Yuu-chan: So, when you're in a haskell-mode buffer, try C-h w haskell-interactive-bring
14:55:22 <wires> so thats ~ 5 hrs
14:55:31 <geekosaur> VK_OEM_ENLW apparently meaning a dedicated enlarge-window key???
14:55:40 <shapr> That is, Help, tell me Where function haskell-interactive-bring is bound.
14:55:45 <phaer> luite: okay, thanks.
14:55:46 <geekosaur> weird keyboard binding
14:55:54 <Yuu-chan> Seems ` is rebound to kana switch key in the Japanese layout
14:55:55 <shapr> geekosaur: Cool, never heard of that.
14:55:58 <mauke> ENL4RGE YOUR WIND0WS N0W
14:56:08 * shapr laughs
14:56:19 <wires> awesome key
14:56:34 * wires wantz ENL4RGE KEY
14:57:09 <wires> "hey, just press that VK_OEM_ENLW key, babe"
14:57:43 <Yuu-chan> haskell-interactive-bring is not on any key
14:57:56 <shapr> huh
14:58:13 <startling> I need a <$> key
14:58:29 <LadyAurora> I need a $ key.
14:58:41 <callen> I need $
14:58:56 * Yuu-chan joins to laughing
14:58:58 <LadyAurora> I need $1M.
14:59:02 <shapr> Yuu-chan: Ok, what do you get from C-h k C-c C-l ? That is, Help Key C-c C-l binds to what function?
14:59:03 <mauke> ENL4RGE ＄＄＄ FAST
15:00:00 <Yuu-chan> C-c C-l runs the command inferior-haskell-load-file
15:00:20 <shapr> Yuu-chan: Ok, you *are* using an older version of haskell-mode
15:00:53 <Yuu-chan> But!..
15:01:13 <shapr> C-c C-l is bound to haskell-process-load-file for me.
15:01:28 <shapr> Yuu-chan: it's possible you have both new and old haskell-mode files installed
15:03:33 --- mode: ChanServ set +o mauke
15:03:33 --- mode: mauke set +b $a:mrBG
15:03:49 <LadyAurora> wat
15:03:51 <shapr> Yuu-chan: What distro & packages do you have installed?
15:03:52 <nand`> that's an odd ban mask, I've never seen that style before
15:04:17 <Yuu-chan> shapr: I installed both Emacs and h-m only yesterday. I downloaded the zipball from https://github.com/haskell/haskell-mode/zipball/master. Was that wrong?
15:04:40 --- mode: mauke set -b $a:mrBG
15:04:58 <LadyAurora> nand`: that's "registered user" IIRC.
15:05:14 <end3rW> hello
15:05:15 <shapr> Yuu-chan: I've never done that, I don't know. I used git to check out the read-only repo and added that dir to my load-path
15:05:32 <danharaj> I am lost without hackage :|
15:05:38 <nand`> aren't we all?
15:05:41 <Yuu-chan> Uh-oh.
15:06:09 <shapr> I'm lost too :-(
15:06:14 * Yuu-chan has gone to fight git
15:06:19 <luite> danharaj: need docs or packages?
15:06:23 <danharaj> both!
15:06:24 <nand`> heh, in gentoo it would just be `emerge haskell-mode`
15:06:28 <danharaj> but mosty docs
15:06:39 <luite> hmm i don't have those yet
15:06:40 <nand`> luite: docs
15:06:41 --- mode: mauke set -o mauke
15:06:54 <shapr> danharaj: same here, seems we need a good offline setup
15:06:56 <luite> i always build my own local hoogle index and docs
15:07:05 <LadyAurora> Is there a key (with no modifiers) that's used seldom enough in Haskell so I could inoremap it to $?
15:07:06 <luite> so with my package mirror i'm fine :)
15:07:09 <shapr> luite: Explain?
15:07:51 <startling> luite: `
15:07:52 <luite> shapr: you can run hoogle on your own system, command line or as a web server
15:08:05 <startling> errr
15:08:05 <nand`> LadyAurora: swap it with (
15:08:13 <startling> LadyAurora: `
15:08:18 <luite> and with some installation flags, you can generate the data files hoogle needs
15:08:19 <startling> nand`: heh
15:08:21 <nand`> startling: infix application
15:08:26 <startling> oh right
15:08:33 <startling> \?
15:08:34 <nand`> # should be pretty rarely used, but I'm not sure if that's a key in your layout
15:08:39 <nand`> startling: lambdas
15:08:42 <startling> oh heh
15:08:56 <startling> % ?
15:09:11 <startling> delete
15:09:55 <ion> Why not just type “$?”? :-P
15:10:18 <ion> Oh, i guess you meant just “$”. Ditto for that.
15:10:28 <LadyAurora> ion: because shift.
15:10:34 <end3rW> Sorry to bother. I used to have a running EclipseFP setup, but now for every project it throws this error: "Not in scope: data constructor `IO'". It was always auto-imported via Prelude I thought? Anything I'm doing wrong?
15:11:05 <nand`> IO' ?
15:11:20 <end3rW> IO. That's just Eclipse's formatting
15:11:22 <zhulikas> ohh, it's somehow related to scion-browser I think
15:11:28 <zhulikas> or buildwrapper
15:11:30 <zhulikas> I mean
15:11:35 <zhulikas> I had similar problems with Prelude import
15:11:40 <end3rW> How's that?
15:11:52 <zhulikas> it gave me an error that Prelude is not found
15:11:53 <mauke> end3rW: IO is a type constructor, not a data constructor
15:11:58 <zhulikas> but if I build - everything is fine.
15:12:00 <mauke> end3rW: what's your code?
15:12:13 <zhulikas> end3rW, does it build fine?
15:12:17 <LadyAurora> ; for $ is a decent idea, isn't it?
15:12:41 <zhulikas> is it a building problem, or errors on eclipsefp UI
15:13:01 <nand`> LadyAurora: that could work, screws up infix { ; ; } eg. for IRC or GHCi but that's about it
15:13:02 <ion> I’d rather have ; than $
15:13:16 <nand`> I avoid using many $s either way. If I use one, it's usually just once
15:13:17 <LadyAurora> Honestly, who uses semicolons in Haskell, anyway?
15:13:19 <nand`> (on a line)
15:13:19 <end3rW> Uhm yes, it does build, in fact. Thanks, I'll just ignore that
15:13:49 <teneen> Do all monad transformers support the function "t m a -> m a"?
15:13:52 <end3rW> Thanks guys
15:13:53 <zhulikas> end3rW, reinstall buildwrapper and restart Eclipse
15:13:56 <ion> main = IO "echo 'hai' >&2"
15:14:00 <zhulikas> it's still annoying
15:14:01 <LadyAurora> nand`: I don't use vim for IRC nor GHCi, so that's a non-issue.
15:14:10 <Yuu-chan> I fetched haskell-mode files with git and they appeared to be different than in the zipball. Still I have the same message. Don't get it...
15:14:15 <end3rW> zhulikas, will try that
15:14:30 <zhulikas> :)
15:14:46 <ion> ladyaurora: Do you really use $ so much having to press shift is an issue?
15:15:19 <ion> In <$> you have to press shift for all the characters in the us layout at least.
15:15:29 <ion> Ditto for $!
15:15:55 <LadyAurora> I can remap these, too ;)
15:15:58 <Yuu-chan> We need haskell keyboards :)
15:16:03 <ion> $ isn’t used *that* much.
15:16:13 <ion> as in, ($)
15:16:31 <nand`> LadyAurora: I think changing a keyboard mapping should be a global thing
15:16:40 <nand`> otherwise you'll start using ; where you wanted $ and vice versa
15:16:45 <nand`> since you're in the ‘wrong’ application
15:16:50 * Yuu-chan wants a lambda key
15:16:55 <nand`> λ
15:16:58 * nand` has one
15:17:10 <wires> didn't the original LISP machine keyboard have one?
15:17:13 <startling> mine is cmd-space l cmd-space
15:17:19 <nand`> mine is Alt Gr + l
15:17:21 <LadyAurora> I want a "fix type errors" key.
15:17:22 <GlennBecksMother> how do i privmsg someone in #perl?
15:17:25 <Jurily> KDE can do per-application layouts
15:17:29 <nand`> LadyAurora: Delete
15:17:50 <ion> The channel isn’t relevant for personal PRIVMSGs.
15:18:08 <teneen> Do all monad transformers support the function "t m a -> m a"?
15:18:13 <zhulikas> hackage is still down...
15:18:25 <wires> well it has FUNCTION and SUPER and even HYPER keys, lol http://upload.wikimedia.org/wikipedia/commons/9/9a/Symbolics-keyboard.jpg
15:19:13 <nand`> teneen: no, consider eg. StateT; it would be s -> StateT s m a -> m a
15:19:18 <ion> I want a RUB OUT key.
15:19:18 <LadyAurora> Does it have a DO WHAT I WANT key?
15:19:23 <Yuu-chan> I remembered a topic on some form: "[CS] [\]  An interesting development of calculus" and the first comment was "I thought it was about Counter-Strike and Half-Life..."
15:19:41 <Yuu-chan> *forum, and I can't insert Unicode ._.
15:20:12 <nand`> I actually often accidentally type ω instead of w these days
15:20:22 <Yuu-chan> shapr: I should go. Thanks a lot for your friendly support :)
15:20:26 <nand`> eg. if I'm writing “who” I end up writing “ωho”
15:20:37 <shapr> Yuu-chan: Feel free to ask more questions later!
15:20:54 <Yuu-chan> nand: put an umlaut over the omega!
15:20:57 <ion> “oho”
15:21:00 <teneen> nand`: But instead of having runStateT, runReaderT, runListT etc. It's better to capture this pattern in a typeclass and it can be easily handled using associated types or functional dependencies
15:21:04 <LadyAurora> Omegas are great.
15:21:35 <LadyAurora> Now we have to wait for somebody to invent omega calculus.
15:21:36 <ion> nand: That’s okay, Valve accidentally types the name of their game as Hλlf-Life.
15:21:37 <zhulikas> does anyone get paid for support or are people just genuinely awesome around here?
15:21:41 <callen> TagSoup isn't making any sense.
15:21:46 <callen> zhulikas: they're just awesome
15:21:53 <enigmuriatic> how do i refer to the item before the current item in foldl?
15:21:54 <ion> zhulikas: I for one suck.
15:22:27 <zhulikas> ion, I doubt that. As I remember you answering some of the stupid questions I had in the past
15:22:43 <zhulikas> but that's a healthy attitude I guess
15:22:44 <zhulikas> :D
15:22:59 <ion> @src foldl
15:22:59 <lambdabot> foldl f z []     = z
15:22:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:23:00 <nand`> teneen: what would the typeclass look like?
15:23:11 <Yuu-chan> enigmuriatic: I'm afraid you can only store it in the accumulator (the first argument in (a -> b -> a))
15:23:23 <Yuu-chan> :t foldl
15:23:24 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:23:30 <nand`> LadyAurora: there are omega algebras already :(
15:24:00 <ion> > let f xs = zipWith xs (Nothing : map Just xs) in f [0..5]
15:24:01 <lambdabot>   Couldn't match expected type `[a]'
15:24:01 <lambdabot>         against inferred type `Data.Mayb...
15:24:03 <ion> > let f xs = zip xs (Nothing : map Just xs) in f [0..5]
15:24:04 <lambdabot>   [(0,Nothing),(1,Just 0),(2,Just 1),(3,Just 2),(4,Just 3),(5,Just 4)]
15:24:52 <ion> enigmuriatic: ↑
15:26:06 <GlennBecksMother> > zip [1,2,3] [4,5,6,7]
15:26:07 <lambdabot>   [(1,4),(2,5),(3,6)]
15:27:52 <GlennBecksMother> :t unzip
15:27:53 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
15:28:28 <GlennBecksMother> > unzip [("hello",3),("no",7)]
15:28:30 <lambdabot>   (["hello","no"],[3,7])
15:28:53 <LadyAurora> > zipWith (,) [1, 2, 3] [4, 5]
15:28:55 <lambdabot>   [(1,4),(2,5)]
15:28:57 <GlennBecksMother> > (sum .snd ) $ unzip [("hello",3),("no",7)]
15:29:00 <lambdabot>   10
15:29:11 <GlennBecksMother> > sum $ snd $ unzip [("hello",3),("no",7)]
15:29:12 <lambdabot>   10
15:29:32 <GlennBecksMother> > zipWith (+) [1,2,3] [4,5,6]
15:29:34 <ion> It works in private, too.
15:29:34 <lambdabot>   [5,7,9]
15:29:40 <zhulikas> > sum . snd . unzip [("hello",3),("no",7)]
15:29:42 <lambdabot>   Couldn't match expected type `(a1, [a])'
15:29:42 <lambdabot>         against inferred type `[t]'
15:29:44 <zhulikas> :|
15:30:00 <GlennBecksMother> > (sum . snd . unzip) [("hello",3),("no",7)]
15:30:01 <ion> > (sum . snd . unzip) [("hello",3),("no",7)]
15:30:02 <lambdabot>   can't find file: L.hs
15:30:03 <lambdabot>   10
15:30:04 <zhulikas> ion, no, it doesn't! it has to be done publicly!
15:30:28 <LadyAurora> zhulikas: +1
15:30:52 <LadyAurora> Wait, what?
15:31:08 <GlennBecksMother> is there a cons tthat throws away first arg instead?
15:31:11 <LadyAurora> <lambdabot>  can't find file: L.hs
15:31:14 <zhulikas> :D
15:31:19 <zhulikas> yeah, I found that odd too
15:31:19 <LadyAurora> How?
15:31:53 <zhulikas> @hoogle (a -> b -> b)
15:31:54 <lambdabot> Prelude seq :: a -> b -> b
15:31:54 <lambdabot> GHC.Conc.Sync par :: a -> b -> b
15:31:54 <lambdabot> GHC.Conc par :: a -> b -> b
15:32:06 <zhulikas> seq it is
15:32:13 <LadyAurora> > const 5 undefined
15:32:15 <lambdabot>   5
15:32:18 <zhulikas> > seq undefined 5
15:32:20 <lambdabot>   *Exception: Prelude.undefined
15:32:23 <GlennBecksMother> > foldl (\s (_,v) -> s+v) 0 [("hello",3),("no",7)]
15:32:23 * wires wants to give a shout-out to call coders in the world. Didn't we come very far from MS-DOS to linux, github, mylyn, haskell, agda, and all that insanly cool tools that we have nowadays???..
15:32:23 <zhulikas> woops
15:32:24 <Botje> flip const
15:32:24 <lambdabot>   10
15:32:27 <ion> ladyaurora: Just your run-of-the-mill race condition.
15:32:27 <DT``> flip const?
15:32:33 <LadyAurora> > (flip const) undefined 5
15:32:34 <wires> s/call/all/
15:32:34 <DT``> damn, too slow.
15:32:35 <lambdabot>   5
15:32:37 <GlennBecksMother> > foldl (flip const (+)) 0 [("hello",3),("no",7)]
15:32:39 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
15:32:48 <GlennBecksMother> > foldl ((+) . flip const) 0 [("hello",3),("no",7)]
15:32:50 <lambdabot>   Couldn't match expected type `b -> b'
15:32:50 <lambdabot>         against inferred type `([GHC....
15:32:55 <zhulikas> @src seq
15:32:56 <lambdabot> Source not found. You type like i drive.
15:33:02 <zhulikas> @src const
15:33:02 <lambdabot> const x _ = x
15:33:05 <wires> (anyway.. i'm just amazed sometimes what happened in 20yr of computing)
15:33:08 <zhulikas> so, what's up with seq?
15:33:23 <zhulikas> isn't it flip const?
15:33:25 <DT``> > foldl ((+) . uncurry flip const) 0 [("hello",3),("no",7)]
15:33:26 <lambdabot>   Couldn't match expected type `(f (b -> b1), b)'
15:33:26 <lambdabot>         against inferred ty...
15:33:31 <GlennBecksMother> > foldl ((+) . flip snd const) 0 [("hello",3),("no",7)]
15:33:33 <lambdabot>   Occurs check: cannot construct the infinite type: b = a1 -> (a, b)
15:33:40 <ion> zhulikas: Look at seq’s documentation.
15:33:49 <Botje> zhulikas: seq evaluates its first argument
15:33:54 <siracusa> > undefined `seq` 1
15:33:54 <DT``> zhulikas, it's strict in his first argument.
15:33:54 <LadyAurora> zhulikas: no, seq is compiler magic.
15:33:55 <zhulikas> I see it does
15:33:55 <lambdabot>   *Exception: Prelude.undefined
15:34:10 <zhulikas> oh, right.
15:34:16 <zhulikas> so it's not flip const. It's for evaluating
15:34:20 <DT``> yep.
15:35:09 <GlennBecksMother> > foldl ((+) . snd) 0 [("hello",3),("no",7)]
15:35:11 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b)
15:35:14 <GlennBecksMother> how do i do?
15:35:21 <ion> It works in private, too.
15:35:22 <GlennBecksMother> > foldl (\s (_,v) -> s+v) 0 [("hello",3),("no",7)] --fugly
15:35:24 <lambdabot>   10
15:36:13 <mauke> > sum . map snd $ [("hello",3),("no",7)]
15:36:15 <lambdabot>   10
15:36:23 <GlennBecksMother> wrong, thats 2 iterations
15:36:37 <c_wraith> nope
15:36:40 <c_wraith> it's not
15:36:46 <GlennBecksMother> how is it not?
15:36:49 <GlennBecksMother> ghc opt?
15:36:52 <c_wraith> stop thinking haskell is the same as other languages
15:36:57 <mauke> list fusion
15:37:00 <zhulikas> huh?
15:37:00 <c_wraith> actually, that one's a library optimization
15:37:45 <LadyAurora> Library optimization using GHC rewrite pragmas.
15:37:48 <callen> Getting this error: No instance for (Text.XML.Light.Lexer.XmlSource (IO String)) when I try to parse Prelude Text.XML.Light Network.HTTP System.IO> :t xml
15:37:51 <GlennBecksMother> what exactly does this lib opt handle? how do i know if it is 1 or 2 iters?
15:37:54 <callen> xml :: IO String
15:37:58 <callen> parseXMLDoc xml returns the instance error
15:38:04 <mauke> callen: :t parseXMLDoc
15:38:06 <callen> I'm following an example I found, but am otherwise clueless. Using XML.Light
15:38:21 <callen> :: Text.XML.Light.Lexer.XmlSource s => s -> Maybe Element
15:38:23 <callen> mauke: ^^
15:38:24 <mm_freak> i wonder if it would be possible to generalize function application, such that you could write applicative code more cleanly without idiom brackets
15:38:31 <c_wraith> GlennBecksMother: you simply don't care until the profiler tells you to
15:38:37 <mauke> callen: s <- xml
15:38:41 <mm_freak> that would be very useful for FRP
15:38:55 <zhulikas> what profiler you constantly refer to?
15:39:05 <callen> mauke: okay, thank you, but why/how did that work?
15:39:05 <zhulikas> not you personally. People here refer to it
15:39:07 <c_wraith> zhulikas: that one built in to ghc
15:39:25 <mauke> callen: xml is an action that creates strings when executed
15:39:27 <zhulikas> does it work on build or I need to use some special commands to invoke it?
15:39:30 <GlennBecksMother> > foldl ((+) . snd) 0 [(3,4),(5,6)] --why doesnt this work?
15:39:31 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b)
15:39:32 <mauke> callen: parseXMLDoc expects a string
15:39:56 <callen> mauke: sure, but why does s <- xml turn an IO String into a String?
15:39:56 <mauke> GlennBecksMother: because 0 has no snd
15:39:57 <DT``> @pl \s x -> s+(snd x)
15:39:58 <lambdabot> (. snd) . (+)
15:40:00 <c_wraith> GlennBecksMother: you're applying snd to the first argument, not the second one
15:40:01 <DT``> GlennBecksMother, that.
15:40:05 <mauke> callen: because that's what <- does
15:40:13 <mauke> callen: in ghci, it executes actions
15:40:15 <GlennBecksMother> c_wraith: this profiler u speak of...?
15:40:31 <zhulikas> -prof it is.
15:41:09 <GlennBecksMother> > foldl ((. snd) . (+)) 0 [(3,4),(5,6)] --why doesnt this work?
15:41:10 <callen> mauke: so I shouldn't do that in my code?
15:41:11 <lambdabot>   10
15:41:25 <mauke> callen: you should, but it means something subtly different there :-)
15:41:33 <zhulikas> so again, this is 1 iteration?
15:41:35 <zhulikas> > map (\x -> x + 5) $ map (\x -> x + 5) [1..5]
15:41:36 <lambdabot>   [11,12,13,14,15]
15:41:41 <mauke> callen: in your code you can't just write "<-" wherever
15:41:49 <mauke> callen: you have to do it as part of a 'do' block
15:42:17 <callen> mauke: the separate code happens to be a do block
15:42:38 <callen> mauke: but I'm trying to figure out what exactly it does and what about it is specific to ghci and whether I need to do that in my do-block as well before trying to utilize the xml.
15:42:57 <mauke> 'do { v <- x; ... }' is syntactic sugar for 'x >>= \v -> do { ... }'
15:43:19 <startling> @src (>>)
15:43:19 <lambdabot> m >> k      = m >>= \_ -> k
15:43:35 <startling> why isn't that m >>= const k ?
15:43:36 <mauke> the part that's ghci specific is that there's no surrounding "do" and you don't have the ... part
15:43:47 <mauke> or rather, the rest of your input becomes the ..., effectively
15:43:52 <startling> @pl m >>= \_ -> k
15:43:53 <lambdabot> m >> k
15:43:55 <startling> heh
15:44:10 <DT``> @pl m >>= . const k
15:44:10 <lambdabot> (line 1, column 7):
15:44:10 <lambdabot> unexpected "."
15:44:10 <lambdabot> expecting space or simple term
15:44:17 <DT``> oops.
15:44:21 <DT``> @pl (m >>=) . const k
15:44:21 <lambdabot> (m >>=) . const k
15:44:23 <callen> mauke: that was...yeah...
15:44:27 <callen> mauke: thanks for trying, haha.
15:44:46 <mauke> callen: you can treat <- as magic that goes from IO X to X
15:45:04 <mauke> but at the cost of forcing everything around it into IO
15:45:12 <LadyAurora> DT``: that's already pointless.
15:45:40 <Aune> callen: (<-) doesnt really remove the IO from IO a. The reason for the IO label is to tell any caller of the function thet IO was involved. once you have gotten your a you dont have tell any function you pas it to that it comes from IO.
15:45:42 <DT``> @pl (m >>=) . const
15:45:43 <lambdabot> (m >>=) . const
15:45:48 <zhulikas> shapr, is ghclive available as a demo anywhere on internet?
15:45:48 <DT``> this is partially pointless.
15:46:10 <mauke> Aune: IO is not a label
15:46:11 <Mortchek> @pl \m -> (m >>=) . const
15:46:11 <lambdabot> (. const) . (>>=)
15:46:18 <mauke> Aune: IO was not involved
15:46:27 <LadyAurora> :t Just 2 >>= const $ Just 3
15:46:28 <lambdabot>     Couldn't match expected type `a -> a1'
15:46:28 <lambdabot>            against inferred type `Maybe t'
15:46:29 <lambdabot>     In the first argument of `(>>=)', namely `Just 2'
15:47:12 <latro`a> :t Just 2 >>= (const (Just 3))
15:47:13 <lambdabot> forall t. (Num t) => Maybe t
15:47:13 <zhulikas> most of the time IO looks harmless... it's just a matter of getting the value from the monad. Actually I've never had any problems with it even though straight from the beginning it was said that IO is evil bla bla
15:47:48 <Veinor> @pl \((a, b), (c, d)) -> (a, c)
15:47:49 <lambdabot> uncurry ((`ap` snd) . (. fst) . (const .) . (,) . fst)
15:47:51 <LadyAurora> IO is evil.
15:47:53 <Veinor> :|
15:47:56 <LadyAurora> That's a fact.
15:48:10 <sipa> LadyAurora: sure, go write your main in a pure way
15:48:15 <Veinor> @hoogle (a -> b) -> (a, a) -> (b, b)
15:48:16 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:48:16 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
15:48:16 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
15:48:23 <Veinor> i thought there was an arrow for that
15:48:28 <startling> :t first fst
15:48:29 <lambdabot> forall c b d. ((c, b), d) -> (c, d)
15:48:34 <startling> (,) . (first fst
15:48:39 <startling> :t (,) . first fst
15:48:41 <lambdabot> forall b c b1 d. ((c, b1), d) -> b -> ((c, d), b)
15:48:41 <mauke> sipa: main :: [Response] -> [Request]
15:48:42 <c_wraith> :t join (***)
15:48:43 <zhulikas> so, is @pl giving out optimisations, or just a way to rewrite the code to make it prettier?
15:48:43 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:48:45 <Aune> mauke, then I misread the question: " why does s <- xml turn an IO String into a String?"
15:48:48 <GlennBecksMother> :t (,)
15:48:50 <lambdabot> forall a b. a -> b -> (a, b)
15:48:59 <GlennBecksMother> so it is an operator or function not syntax?
15:49:07 <GlennBecksMother> > "hello",4
15:49:08 <LadyAurora> sipa: it's evil, but it's quite necessary.
15:49:09 <lambdabot>   <no location info>: parse error on input `,'
15:49:10 <c_wraith> zhulikas: it's not always prettier.  and it's never an optimization
15:49:11 <mauke> Aune: I don't see how that can be true
15:49:13 <Veinor> > ("hello", 4)
15:49:15 <lambdabot>   ("hello",4)
15:49:18 <Veinor> > (,) "hello" 4
15:49:20 <lambdabot>   ("hello",4)
15:49:34 <Veinor> @type fst *** fst
15:49:36 <lambdabot> forall c b a b1. ((c, b), (a, b1)) -> (c, a)
15:49:40 <Veinor> there we go
15:49:54 <startling> ooh
15:50:07 <GlennBecksMother> > (,) 1 2 3
15:50:08 <lambdabot>   Couldn't match expected type `t1 -> t'
15:50:08 <lambdabot>         against inferred type `(t2, ...
15:50:10 <zhulikas> I think when you use <- in IO monad you kind of "assume" that is the value you need, all the functions are chained in the do block and only when everything is finally executed you can know if it succeeded
15:50:10 <GlennBecksMother> > (,) 1 2
15:50:12 <lambdabot>   (1,2)
15:50:17 <LadyAurora> Veinor: congrats, you won one pointless dollar.
15:50:24 <Veinor> @type join (***) fst
15:50:26 <lambdabot> forall c b. ((c, b), (c, b)) -> (c, c)
15:50:48 <zhulikas> so that could be an explanation for <-
15:50:51 <Veinor> ah, the join means that the two fsts have to be the same
15:51:03 <DT``> > (,,) 1 2 3
15:51:04 <lambdabot>   (1,2,3)
15:51:17 <Veinor> there's a (,)-like for every tuple up to... i think 20?
15:51:17 <hayashi> @type (,,,,,)
15:51:19 <lambdabot> forall a b c d e f. a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f)
15:51:20 <hayashi> wow.
15:51:23 <Veinor> but really why are you using 20-tuples in the first place
15:51:25 <hayashi> did not know that existed.
15:51:29 <Veinor> @type (,,,,,,,,,,,,,,,)
15:51:31 <lambdabot> forall a b c d e f g h i j k l m n o p. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
15:51:36 <DT``> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:51:37 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w ->
15:51:38 <lambdabot> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33)
15:51:48 <DT``> ... wow.
15:51:50 <LadyAurora> lol
15:52:16 <latro`a> the t28 always baffles me
15:52:19 <Jurily> if you need 20 things in a tuple, you probably missed some
15:52:19 <zhulikas> :D
15:52:20 <latro`a> you have 26 types and then t28
15:52:29 <startling> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:52:30 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t ->
15:52:30 <lambdabot>  u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31,
15:52:31 <lambdabot>  t32, t33, t34, t35, t36, t37)
15:52:36 <startling> does it go on forever?
15:52:43 <DT``> probably.
15:52:45 <zhulikas> startling, keep trying
15:52:48 <zhulikas> and we all will see.
15:52:59 <shachaf> No, it only goes until the people in IRC stop.
15:53:01 <LadyAurora> latro`a: good catch.
15:53:02 <startling> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:53:03 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s ->
15:53:03 <lambdabot> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28,
15:53:03 <lambdabot> t29, t30, t31, t32, t33, t34, t35, t36, t37, t38)
15:53:04 <startling> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:53:05 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r ->
15:53:05 <lambdabot> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y,
15:53:05 <lambdabot>  z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39)
15:53:07 <zhulikas> :DDD
15:53:08 <DT``> maybe it stops at 2^64?
15:53:12 <shachaf> startling: Please don't keep trying. :-(
15:53:20 <startling> shachaf: yeah, I won't
15:53:32 <LadyAurora> Why t28?
15:53:47 <latro`a> I got many hundreds
15:53:50 <GlennBecksMother> isnt parallell spelled with 2 Ls in english?
15:53:57 <mauke> GlennBecksMother: no, 3
15:53:59 <barometz> not at the end
15:54:15 <shachaf> The actual maximum size in GHC is 62.
15:54:16 <callen> sigh, why is it so hard to just parse an XML file in Haskell
15:54:32 <startling> shachaf: good to know
15:54:35 <callen> this is ridiculous. I just want a list of all elements named something
15:54:36 <startling> shachaf: you know, just in case
15:54:37 <GlennBecksMother> how do i use the profiler?
15:54:41 <DT``> it stops at t1023 for me.
15:54:48 <callen> instead I'm fencing with the compiler over the type signature of "show"
15:54:55 <DT``> (GHCi)
15:55:02 <latro`a> callen: try not using ghci
15:55:11 <callen> latro`a: yeah uh, I was working purely off source file before
15:55:15 <Jurily> t4766)
15:55:21 <mm_freak> hackage down again?
15:55:22 <callen> latro`a: I switched to ghci just to try to get a better insight into what was going on.
15:55:25 <typoclass> callen: if you post some code to hpaste, people can give you more concrete advice
15:55:26 <callen> I can't fucking win.
15:55:31 <latro`a> yeah, that's not as easy as it sounds
15:55:32 <callen> can do.
15:55:32 <startling> callen: :set -XNoMonomorphismRestriction maybe
15:55:39 <latro`a> but yes, definitely throw out some code on hpaste
15:55:52 <startling> latro`a: p.s. it was the dmr last night
15:55:55 <hpaste> callen pasted “code graveyard” at http://hpaste.org/72992
15:55:57 <latro`a> dmr?
15:56:03 <callen> latro`a: there, code graveyard.
15:56:11 <mauke> callen: precedence error
15:56:17 <GlennBecksMother> latro`a: why not use ghci?
15:56:22 <startling> latro`a: oh, maybe it wasn't you who suggested it. "Dreaded monomorphism restriction"
15:56:23 <callen> let items = findElements (QName "Forecast" Nothing Nothing) doc returns []
15:56:27 <latro`a> oh oh
15:56:38 <callen> mauke: what?
15:56:44 <mauke> callen: $ has very low precedence
15:56:54 <mm_freak> http://www.downforeveryoneorjustme.com/hackage.haskell.org ⇐ we have to do something about the hackage downtimes
15:57:03 <latro`a> indeed, that $ is the problem
15:57:10 <Clint> hackage mirrors everywhere
15:57:12 <latro`a> rather the second one
15:57:15 <callen> mauke: okay, fixed that.
15:57:16 <callen> new problem
15:57:20 <mm_freak> Clint: with online docs?
15:57:24 <mauke> callen: error message?
15:57:26 <callen> the parser shows [] for items
15:57:35 <callen> no error message anymore
15:57:41 <callen> just can't find stuff with the parser.
15:57:43 <mauke> ok, semantic error
15:57:48 <Clint> mm_freak: i was suggesting
15:57:51 <zhulikas> decentralize hackage!
15:57:59 <callen> yeah, I tried the other verbiage related to QName but nothing works
15:58:03 <callen> it only takes QName there.
15:58:03 <zhulikas> put it in the sky, on the clouds
15:58:21 <startling> zhulikas: but is hackage web-scale?
15:58:28 <zhulikas> no idea
15:58:39 <zhulikas> but I think replication is always an option
15:58:42 <mauke> if this was xpath, I'd be blaming namespaces
15:58:43 <Jurily> paludis uses git repos
15:59:09 <mm_freak> Clint: ah, i see
15:59:09 <jfischoff> cabal install (github|darcs den|etc) packageName
15:59:18 <jfischoff> would be nice
15:59:20 <mm_freak> i'd be willing to provide a server for a hackage mirror
15:59:33 <zhulikas> how much resources does it require?
15:59:39 <zhulikas> and what about synchronisation with hackage?
15:59:40 <callen> it's Text.XML.Light and the documentation is potentially the worst I have ever seen
15:59:43 <callen> even for an XML parser
15:59:56 <zhulikas> I might get my own mirror too
16:00:01 <mm_freak> well, my server has more than a TiB of free space…  should be enough i guess
16:00:20 <zhulikas> that's true :D
16:00:21 <mm_freak> i could even dedicate a hard disk to it
16:06:37 <typoclass> callen: sorry for the documentation :-/ i've used haskell for years, and the haddocks are a constant source of pain
16:08:31 <startling> it's pretty odd that people think a list of types of the api is sufficient documentation
16:09:11 <Taneb> If the functions are well-named, it would be
16:09:57 <startling> Taneb, I don't think that's true
16:10:13 <Taneb> In some cases, it would be
16:10:18 <Taneb> But I see what you mean
16:10:53 <typoclass> startling: sometimes it is, but i think a type can explain only one function. you often have trouble telling how the functions are supposed to fit together, which are the important ones and which are auxiliary, etc.
16:11:10 <hgolden> hi. is h.h.o down?
16:11:17 <typoclass> s/it is/a type is enough documentation/ :-)
16:11:30 <Taneb> hgolden, look at the topic
16:11:44 <typoclass> hgolden: yes, unfortunately
16:11:48 <hgolden> i did, but too late. sorry!
16:11:49 <Taneb> i.e., yes
16:11:51 <Taneb> :)
16:11:56 <startling> Taneb, typoclass: yeah
16:12:11 <zhulikas> does anybody read that topic into a [String]?
16:12:24 <Taneb> I'm not very good at writing docs...
16:12:36 <Taneb> zhulikas, I think it's just like that to be cool.
16:12:41 <Taneb> Compare #dwarffortress
16:13:10 <startling> it really should be [(String, String)]
16:13:16 <zhulikas> it should be
16:13:17 <zhulikas> :D
16:13:19 <latro`a> wait, what
16:13:26 <zhulikas> because it has :
16:13:34 <startling> well, everything except "hackage down" anyway
16:13:40 <latro`a> then it should be [(String,Maybe String)]
16:13:44 <latro`a> since not every part has a :
16:13:52 <Taneb> [("Hackage","Down")
16:13:54 <Taneb> ...]
16:13:56 <DT``> Hackage: down.
16:13:58 <zhulikas> latro`a, let's make it strict then!
16:13:59 <startling> [[String]]
16:14:02 <reaga> I think haskell's community could be improved.
16:14:03 <zhulikas> and add : to every part
16:14:09 <callen> does anyone here understand Text.XML.Light?
16:14:13 <GlennBecksMother> so can all things like (sum . map (+1)) be fused into one iteraTION? How gweneral is this? if i write a function product = foldl1 (*) ; would it woek then too or do i have to define a rewrite rule for it?
16:14:15 <callen> I'm having issues getting it to return anything.
16:14:26 <startling> callen: "return anything"?
16:14:40 <latro`a> GlennBecksMother, foldl and map can be merged; it is a good exercise to write how
16:14:50 <DT``> GlennBecksMother, look up list fusion/stream fusion.
16:14:51 <startling> callen: typically with parsing stuff you have a runParser (Parser x) String -> x
16:14:57 <latro`a> (using explicit recursion)
16:15:01 <callen> startling: findElement/findElements/findChildren etc all don't return any tags even though I'm passing it a valid tag name.
16:15:30 <Veinor> ... why does Set have no Functor instance?
16:15:36 <latro`a> Ord constraint
16:15:37 <GlennBecksMother> latro`a: how do you mean should i define  a rewrite rule?
16:15:40 <Veinor> ah, right
16:16:50 <latro`a> not as a rewrite rule, I mean a function of type (a->b->a) -> (c->b) -> a -> [c] -> a
16:16:52 <LadyAurora> Good night.
16:16:55 <hiptobecubic> latro`a, why is that a problem?
16:16:58 <latro`a> which implements both fold and map
16:17:17 <startling> Veinor: also, what happens if two of the functions return the same thing?
16:17:22 <fmap> callen: can you paste some minimal reproducible example (i do this, i get this, i expect to get that)?
16:17:28 <latro`a> because a Functor has to be a uunctor on all of Hask, basically
16:17:29 <latro`a> *functor
16:17:37 <latro`a> Set is only a functor on a subcategory of Hask
16:17:40 <Veinor> startling: then they get 'merged'?
16:18:19 <GlennBecksMother> latro but then id have to pass the fold and map function to a new function and just write (sum $ map (+1)) and let ghc do it
16:18:46 <startling> Veinor: well, I don't think Functor is supposed to change the structure
16:18:46 <latro`a> I know, I'm not saying to do it for real work
16:19:04 <hiptobecubic> latro`a, ohhhh. set requires Ord. I see
16:19:09 <latro`a> startling: Set is definitely a functor in the real world
16:19:25 <scri> is anyone else having trouble getting on hackage?
16:19:37 <latro`a> GlennBecksMother, I'm not saying to do it for actual use, I'm saying to use write it to give yourself an idea how list fusion works
16:19:40 <hiptobecubic> scri, it's down
16:19:58 <hiptobecubic> we're setting up a refuge tent
16:20:32 <latro`a> startling: the structure changes that need to be preserved are only fmap id = id and fmap (f . g) = fmap f . g.
16:20:53 <latro`a> startling, it's not that hard to show that the obvious Set functor (ignoring the Ord problem) would do this
16:21:03 <latro`a> the point is that the structure changes happen the same way regardless of order
16:21:13 <scri> hiptobecubic: right, just saw the topic
16:21:43 <latro`a> erm
16:21:48 <latro`a> fmap (f . g) = fmap f . fmap g
16:23:16 <GlennBecksMother> > let foldMap ff fm start = foldl ((. fm) . ff) start in foldMap (+) (+1) 0 [1,2,3]
16:23:18 <lambdabot>   9
16:24:24 <GlennBecksMother> latro`a: thats not what u emant i show do right?
16:25:44 <jfischoff> roconnor: would it be possible to make a function like foldMFor :: Multiplate p, Monad m => Projector p a -> p (m (Constant o)) -> a -> m o or something similar?
16:25:55 <latro`a> does that help you see how list fusion can be done at all?
16:26:11 <latro`a> (iirc the compiler does do some list fusion, though I'm not sure if it will detect that a fold+map can be merged)
16:27:50 <GlennBecksMother> isnt -prof available by default?
16:28:24 <GlennBecksMother> latro`a: well not for understanding how ghx does it. like you say how doe it recognize it
16:29:13 <latro`a> that's past my realm of expertise, and in a way past haskell itself, since GHC's optimizations happen in Core anyway
16:29:18 <latro`a> (mostly)
16:32:57 <geekosaur> -prof only works when everything is compiled with profiling (because laziness means your profiled stuff may be invoked in the middle of something else); while the official haskell platform includes profiling libraries, many distributions' versions split those into optional or "recommended" packages.  also cabal by default does not install profiling libraries; ~/.cabal/config can be edited to enable that
16:36:07 <edwardk> jfischoff: playing with multiplate?
16:36:25 <jfischoff> edwardk: i think I was doing it wrong
16:36:28 <callen> does anyone here know Text.XML?
16:36:34 <edwardk> fair nuff
16:36:35 <jfischoff> edwardk: but uyes
16:36:49 <hpaste> callen pasted “Text.XML API troubles” at http://hpaste.org/72993
16:37:02 <edwardk> been doing a few multiplate-like examples using lens
16:37:03 <jfischoff> edwardk: made a plate for all the TH types
16:37:05 <callen> I can't get the damned parser to return anything other than [] or Nothing
16:37:10 <edwardk> jfischoff: ah
16:37:14 <jfischoff> edwardk: I was wondering about that
16:37:15 <callen> doc is :t Element
16:37:25 <callen> anybody?
16:37:25 <jfischoff> edwardk: if there was a connection
16:37:57 <hiptobecubic> can i stop removeFile from raising an error if the file doesn't exist?
16:38:16 <callen> does anyone know Text.XML at all?
16:38:32 <edwardk> jfischoff: there is
16:38:38 <callen> I tried hoogling all over, I've spammed the hell out of the poor API endpoint backing my XML parsing attempts, I can't get anything to work.
16:38:41 <edwardk> also you can use arrow sugar to compose plates and traversals
16:38:51 <jfischoff> edwardk: interesting
16:38:59 <edwardk> they compose backwards though
16:39:04 <edwardk> as with (.)
16:39:18 <jfischoff> edwardk: huh, exciting. Multiplate is really cleaning up my code
16:39:19 <hiptobecubic> callen, make yourself a little example file locally?
16:39:21 <edwardk> so the arguments are the coalgebras for the smallest parts
16:39:27 <callen> hiptobecubic: I did, I pasted it.
16:39:31 <callen> hiptobecubic: the hpaste above.
16:39:35 <edwardk> jfischoff: did you see the traversals i use in lens for TH?
16:39:39 <callen> you can run it with runhaskell and see that nothing returns.
16:39:43 <jfischoff> edwardk: yes
16:39:43 <callen> I pasted the type of doc too
16:39:47 <jfischoff> very cool
16:40:12 <jfischoff> edwardk: I think there is a lot of work that could be done to make TH easier to use
16:40:21 <edwardk> been working on a form of traversal that permits me to retain sharing on unedited branches of code
16:40:21 <edwardk> yeah
16:40:30 <edwardk> i've been thinking about releasing a TH wrapper that uses bound
16:40:44 <edwardk> that way you get better name management, etc.
16:41:10 <edwardk> it'd more or less be a port of the guts of my thc type checker
16:41:19 <jfischoff> edwardk: there are many things about TH that I can't tell if I just don't get or are design mistakes
16:41:21 <edwardk> and a shim to dump it down to TH
16:41:30 <edwardk> like?
16:41:38 <hiptobecubic> callen, i can't help much because i can't install Text.XML because hackage is down
16:41:41 <callen> hiptobecubic: have you used Text.XML or Text.XML.Light before?
16:41:51 <jfischoff> edwardk: why store the tyvars at all
16:41:54 <callen> hiptobecubic: oddly, cabal has been working for me.
16:41:56 <callen> hiptobecubic: :(
16:42:00 <edwardk> ?
16:42:00 <takemitsu> callen: I've been playing with your code.
16:42:00 <jfischoff> edwardk: aren't they derived
16:42:10 <jfischoff> from the dec
16:42:19 <jfischoff> or whatever type
16:42:20 <takemitsu> callen: I tried it with another URL where I got some results.
16:42:36 <GlennBecksMother> i cant use -prof
16:42:40 <GlennBecksMother> Prelude is missing
16:43:01 <edwardk> you mean for the DataD, etc?
16:43:17 <callen> takemitsu: hrm.
16:43:19 <edwardk> they can have signatures on them for kind annotations, etc.
16:43:24 <callen> takemitsu: that URL is working, I can see the structure of doc if I show it.
16:43:28 <jfischoff> edwardk: yeah could there not be function that finds the free type vairables?
16:43:32 <callen> takemitsu: what were you able to figure out?
16:43:52 <edwardk> jfischoff: its not used by code generation typically, but you can use the traversal i have for it
16:44:15 <callen> [Element {elName = QName {qName = "Success", qURI = Just "http://ws.cdyne.com/WeatherWS/", qPrefix = Nothing}, <--- the beginning of 'show doc' looks like that.
16:44:16 <jfischoff> edwardk: why have the ListT :: Type and not ListT :: Type -> Type?
16:44:29 <scri> where does cabal install documentation files?
16:44:37 <edwardk> http://ekmett.github.com/lens/Language-Haskell-TH-Lens.html#v:typeVars
16:44:48 <jfischoff> edwardk: if the tyVars don't match you get an error
16:45:10 <edwardk> jfischoff: because how would you use that ListT to make an instance for ListT?
16:45:30 <callen> okay, I have to finish this project
16:45:35 <jfischoff> jfischoff: ListT (ConT "Blah")
16:45:43 <edwardk> thats not the instance you need
16:45:44 <jfischoff> he
16:45:45 <edwardk> instance Monad []
16:45:48 <edwardk> how do you write it
16:45:50 <callen> if I can't return a list of elements from an XML body in the next hour, I'm going to have to scrap Haskell for Python
16:45:57 <callen> this is fucking absurd, the documentation is utterly non-existent
16:45:58 <edwardk> there isn't anything _in_ that list
16:46:00 <edwardk> so you can't app it
16:46:03 <jfischoff> ah
16:46:13 <jfischoff> makes sense
16:46:18 <callen> a few function type signatures is not documentation
16:46:18 <callen> at all.
16:46:37 <scri> Is there a way to browse Haddock documentation offline? especially since hackage is down? I've downloaded the doc with my packages but don't know where to find it
16:46:42 * shachaf wonders how to debug "out of memory (requested 40283144192 bytes)"
16:46:59 <ion> Get more RAM.
16:47:11 <aristid> callen: if you need to finish a project in a limited amount of time, perhaps it is wisest not to pick a language you don't know
16:47:32 <callen> aristid: it's an insanely simple project
16:47:36 <fmap> scri: cabal installs documentation at ~/.cabal/share/doc/index.html
16:47:38 <callen> aristid: that I'm doing with a friend
16:47:45 <callen> aristid: I already figured out and got working a ton of stuff
16:47:54 <callen> aristid: I just need to figure out why the goddamn XML parser won't play ball
16:48:08 <aristid> which XML parser do you use?
16:48:10 <callen> I went from zero to getting a web framework, a templating system, and the HTTP client library working since a few hours ago.
16:48:19 <callen> I'm currently using Text.XML.Light which is equiv to Text.XML
16:48:27 <aristid> hah
16:48:31 <scri> fmap: thanks, is that specified in .cabal/config?
16:48:32 <callen> none of the QName / findElement stuff is working
16:48:48 <scri> fmap: oh, is $datadir .cabal/share?
16:49:04 <scri> fmap: oh i get it now, thanks!
16:49:08 <Piethon> if i define a .cabal will it use -O by default?
16:49:20 <aristid> callen: the package is xml? sadly hackage is down right now
16:49:25 <edwardk> jfischoff: Language.Haskell.TH is an okay design for as far as it goes. the name binding i fiddly, and it doesn't expose much that is GHC specific, but overall its tolerable and doesn't have any obvious design mistakes if you accept its core approach
16:49:55 <callen> aristid: http://webcache.googleusercontent.com/search?q=cache:qllIl0G0iWEJ:hackage.haskell.org/packages/archive/xml/1.3.3/doc/html/Text-XML-Light-Proc.html+&cd=1&hl=en&ct=clnk&gl=us cached "documentation" there.
16:49:56 <jfischoff> edwardk; Yeah I agree.
16:50:05 <gwern> the implementation is terrible, though, especially the module limitations
16:50:07 <callen> documentation in this case needs to be taken with a dumptruck of salt.
16:50:15 <edwardk> now, the things i don't like about it are that you can't make your own instances of Q so its _useless_ to me if i wanted to use it to mock up my own haskell implementation
16:50:36 <aristid> callen: use ghci.
16:50:38 <edwardk> and the name management is pretty awkward
16:50:55 <aristid> callen: play with XML documents to get a feel what the functions actually do
16:51:32 <aristid> callen: perhaps this is not the the best XML library though
16:51:33 <callen> aristid: I'm trying to do just that!
16:51:35 <nand`> is there any particular reason Data.Bits has an operator for .&. and .|. but not for xor?
16:51:35 <jfischoff> gwern: which module limitations?
16:51:37 <gwern> for example, I wanted to improve xmonad so it could detect at compile time if you were binding the same key multiple times because that's just a mistake, right? too bad! you can define the appropriate $() stuff, yeah, but you can't use it for a value which you then pass to a library function or something insane like that, unless you put your keybindings in an entirely separate module! at least, I think that's what thhe problem was. I was so disgusted ...
16:51:40 <callen> aristid: except every single fucking function returns nothing
16:51:43 <gwern> ... once I had something working to find it was so crippled...
16:51:54 <callen> aristid: I am testing it with an insanely simple XML document and it's just spitting [] and Nothing at me over and over
16:52:15 <aristid> callen: hpaste?
16:52:15 <callen> aristid: I've tried virtually every QName accepting function with every combination of plausible QNames in that fucking web page
16:52:28 <aristid> also please calm down a tiny bit
16:52:36 <hpaste> callen pasted “I am not enjoying this” at http://hpaste.org/72994
16:52:39 <Piethon> if i define a .cabal will it use -O by default?
16:52:39 <callen> aristid: ^^
16:52:56 <gwern> jfischoff: http://www.haskell.org/pipermail/xmonad/2010-March/009906.html aavogt did suggest something which sort of worked years later
16:53:01 <jfischoff> gwern: the staging restrictions could be better, there (is|was) a feature request to let you specify regions in the same file
16:53:20 <S11001001> What is Free without the pure constructor called, that is, data X f a = X (f (X f a))?
16:53:39 <dcoutts_> Piethon: yes
16:53:44 <jfischoff> edwardk: how would the bound th combo work?
16:54:54 <S11001001> I guess it is Cofree ? (), but that seems silly
16:55:01 <aristid> callen: calling a Nothing xmlns seems wrong, if the actual xmlns is "http://ws.cdyne.com/WeatherWS/"
16:56:01 <jfischoff> gwern: woah
16:56:06 <callen> aristid: which arg to QName is xmlns?
16:56:19 <aristid> callen: um, i don't know, look at the QName definition?
16:56:24 <naula> okay. I found my ways to install Haskell-programs and -packages in a somewhat sensible way. thanks for help!
16:56:27 <aristid> the name should be namespace or something
16:56:37 <callen> ...
16:57:19 <edwardk> jfischoff: good question. more or less like i use the bound approach now for typechecking stuff, locally debruijn name binding with original source names attached
16:57:28 <callen> aristid: trying to pass a string where the Nothings are trips a type error.
16:57:40 <callen> aristid: so uh, no dice.
16:57:41 <aristid> callen: you need a (Just "foobar")
16:58:11 <aristid> callen: also, your aggression is really making it less fun to help you
16:58:34 <callen> I'm sorry, but this is the most frustrating experience I've ever had learning a language
16:58:40 <callen> it literally has everything possible working against it here
16:59:04 <takemitsu> callen: You need to pass (Just "http://ws.cdyne.com/WeatherWS/") as the second arguemnt to QName.
16:59:12 <callen> the worst documentation, Hackage is down, the language semantics are finicky, the XML parsers don't make sense
16:59:25 <callen> takemitsu: I've gotten that far, trying to figure out how to get an inner element of that now.
16:59:25 <aristid> there are better xml parsers.
16:59:32 <typoclass> aristid: he's very frustrated. he's been in here for hours trying to get his thing to work
16:59:32 <aristid> i personally like to use xml-conduit
16:59:36 <callen> aristid: fantastic. They look even more complicated.
16:59:50 <gwern> yeah, this was a bad day to start haskell. hackage isn't usually down for a move...
17:00:06 <takemitsu> callen: What inner element are you trying to get?
17:00:17 <callen> takemitsu: I want a list of all the <Forecast> elements and their constituent data.
17:00:20 <aristid> callen: but in this case your problem is simply that you forgot to actually give it the right xml namespace
17:00:23 <gwern> (knowing this, why are you still trying past the point where you've gotten visibly frustrated and may be wasting your time or say things you'll regret...)
17:00:39 <callen> takemitsu: each Forecast has a Date, Description, etc.
17:00:39 <aristid> callen: perhaps sloppy parsers that you're used to ignore xml namespaces, but that's bad practice.
17:01:10 <callen> aristid: I'm very pleased the Haskell community has decided to bless me with a finicky parser, but I'd really just like to get the data now.
17:01:20 <callen> aristid: I will submit the appropriate sacrifices of goat after the code works.
17:01:29 <aristid> what gwern just said.
17:01:43 <callen> I just want the code to work.
17:01:56 <callen> this isn't even the last of it, after I get the XML, I still need to turn it into JSON.
17:02:01 <callen> I'm dreading that bit too.
17:02:13 <gwern> well, fortunately no one will die if it's not completed tonight
17:02:29 <gwern> few programmers ever have to worry about that, thank goodness
17:02:32 <Dread> A goat will die if it's completed
17:02:48 <gwern> Dread: all the more reason to take a break! why won't anyone think of the kid?
17:03:01 <mkCurry> Any word when hackage will be back up?
17:03:16 <callen> hardee-har. Well, I've had a steady stream of people telling me I should check Haskell out
17:03:21 <callen> for years now
17:03:24 <callen> well, I'm here.
17:03:26 <callen> Trying to use it.
17:03:36 <parcs`> callen: have you read LYAH?
17:03:46 <callen> parcs`: yeah uh, that has zero impact on what I'm doing right now.
17:04:00 <callen> parcs`: LYAH says approximately nil about your arcane XML parsers.
17:04:23 <parcs`> hahaha okay
17:04:28 <callen> we just established that the issue is the semantics of the XML parser and its pickiness
17:04:29 <gwern> callen: just because you've been meaning to check haskell out for years doesn't mean that you must do it right now under transient poor conditions. in fact, I'd say the years thing indicates that you are in absolutely no hurry
17:04:32 <callen> the code itself is "functioning"
17:04:44 <callen> gwern: I did some research prior to today, I learned the basic concepts and syntax.
17:04:50 <callen> the code, structurally, is sound'ish
17:04:53 <callen> it "works"
17:04:58 <callen> I just need to rip the data apart
17:05:01 <callen> so lets stop wasting time with meta
17:05:08 <callen> and get the XML parser to do something useful.
17:05:17 <jfischoff> if I have a Monad m and a type m [a] is there t I can wrap them in such that t (m [a]) is a monoid?
17:05:17 <gwern> but you know what, I've given you the advice to take a break and come back tomorrow, and if you're going to ignore that obvious warning signs, then yes, as you say, meta has proven useless
17:05:34 <gwern> * the
17:06:01 <zmoazeni_> I didn't realize how much I depended on hackage when I work with haskell
17:06:14 <callen> gwern: it has to be finished today
17:06:15 <gwern> jfischoff: well, a list is already a monoid isn't it? so what's wrong with [m [a]]?
17:06:22 <callen> gwern: this can take more of my time today, or less of my time today
17:06:27 <callen> those are the only cases.
17:07:15 <callen> new problem
17:07:49 <gwern> jfischoff: or if you don't like lists, plenty of other monoids like sets or sequences
17:07:50 <hpaste> callen pasted “what, can I not parse the thing recursively?” at http://hpaste.org/72996
17:08:07 <aristid> zmoazeni_: would be nice if cabal installed documentation by default instead of only with a flag, right? :)
17:08:20 <jfischoff> gwern: I want a mapped (T x) (T y) = T $ liftM2 x y I think, would I get that with []?
17:08:26 <jfischoff> err
17:08:32 <takemitsu> callen: You need to use (Just "http://ws.cdyne.com/WeatherWS/") again.
17:08:33 <jfischoff> liftM2 (++)
17:08:41 <callen> takemitsu: did you read it?
17:08:43 <callen> takemitsu: wait wait wait
17:08:50 <callen> takemitsu: I have to redeclare the namespace every single time?
17:08:54 <jfischoff> if that is even possible or type checks
17:09:05 <aristid> callen: no, just make a variable with the namespace in it.
17:09:13 <gwern> jfischoff: why not try it?
17:09:19 <aristid> let myNs = "foobar"
17:09:20 <callen> takemitsu: yes. that did it.
17:09:22 <callen> takemitsu: thank you.
17:09:29 <jfischoff> gwern: :)
17:09:30 <takemitsu> callen: You are welcome.
17:10:07 <jfischoff> gwern: thought there might be a name for it if it is possible, but yeah I will whip it up
17:10:10 <gwern> jfischoff: although I think you may need to define monoid for your T, comee to think of it
17:10:20 <jfischoff> yeah
17:10:25 <typoclass> callen: you could make a new function: «let qn x = QName x (Just "http://ws.cdyne...") Nothing)». you can then do just «qn "item"», «qn "ForecastResult"», etc.
17:10:36 <aristid> callen: or a small convenience would be to define let weatherName x = QName x "foons" Nothing
17:10:50 <aristid> +(Just )
17:10:51 <gwern> jfischoff: since regular [] just defines mappend as '++', not 'liftM2 ++'
17:11:05 * jfischoff nods
17:11:32 <callen> typoclass aristid: that occurred to me, but I'm just trying to hammer this out for now. I'll restructure later.
17:11:33 <gwern> jfischoff: but hey, easy enough to define an instance right?
17:11:34 <ion> instance Monoid a => Monoid [a] where mempty = repeat mempty; mappend = zipWith mappend
17:11:47 <jfischoff> gwern: almost done ;)
17:11:53 <pqmodn> deja vu
17:11:57 <roconnor> jfischoff: p (m (Constant o)) does not kind-check;  do you mean p (Compose m (Costant o)) ?
17:12:20 * gwern checks Data.Monoid with :info, doesn't see any mention of Monad, so yeah, no magical autolifting stuff?
17:12:28 <roconnor> hi gwern
17:12:38 <jfischoff> roconnor: yeah I was speaking loosely and incorrectly :) I have a slightly different plan now
17:12:47 <gwern> roconnor: hi
17:13:03 <reaga> im confused about haskell
17:13:05 <jfischoff> roconnor: I think foldFor could work...
17:13:09 <callen> takemitsu: now that I have the "forecasts", how would I iterate over that and get the constituent data?
17:13:13 <reaga> its not procedural, so anything can happen in any order?
17:13:16 <callen> reaga: welcome to the club
17:13:24 <callen> okay, I'm not that bad off, but I'm confused too.
17:13:34 <mekeor> reaga: it's functional
17:13:36 <reaga> haskell doesnt go 1, 2, 3...
17:13:39 <hpaste> callen pasted “have forecasts, now what?” at http://hpaste.org/72997
17:13:42 <reaga> then what does it do?
17:14:11 <takemitsu> callen: Can you fold over it?
17:14:16 <startling> reaga: it does what it needs to do when it needs to do it
17:14:26 <mekeor> reaga: it does, in some way. the main function is called. the main function calls another function which calls another function and so on.
17:14:28 <reaga> i dont understand that though
17:14:31 <gwern> reaga: it shucks off the wrapper, one layer at a time, from the giant huge nested lambda function that is an entire program
17:14:36 <mekeor> reaga: that makes the order of evaluation.
17:14:50 <gwern> reaga: like an onion! an onion has *layers*, and if you try to peel it by hand, you'll wind up crying
17:15:01 <reaga> :s
17:15:10 <roconnor> jfischoff: \proj plate -> foldFor proj (applyNaturalTransform eta plate)  where eta (Compose x) = Constant (getConstant `liftM` x)
17:15:16 <roconnor> jfischoff: I think that has the type you requested
17:15:49 <roconnor> jfischoff: applyNaturalTransform is the (longwinded) equivalent of fmap for plates
17:16:06 <jfischoff> :o
17:16:13 <Dread> reaga: You can force Haskell to evaluate things in a specific order, but you should really only need to do that with parallel execution. Something you probably shouldn't be worrying about right now.
17:16:18 <callen> takemitsu: okay, I don't really know.
17:16:58 <takemitsu> callen: What exactly do you want to do with the data?
17:17:00 <aristid> Dread: forcing evaluation can also be useful for non-parallel performance
17:17:38 <Dread> aristid: Yes, but forcing evaluation is a little different from ordering evaluation.
17:17:56 <aristid> Dread: why, it enforces a certain order
17:18:19 <callen> takemitsu: I'd like to collect it into something resembling JSON.
17:18:20 <aristid> due to non-strict evaluation, it won't be evaluated again :)
17:18:30 <dfeuer> Hmm... Weird... http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id690070  says that zip and zipWith are "good consumers" to which list fusion applies, "but on one argument only; if both are good producers, zip will fuse with one but not the other".
17:18:38 <dfeuer> Why not fuse with both?
17:19:02 <mm_freak> liftA2 (printf "%8.2f %8.2f") time (avgFps 10000) . after 2 . for 10
17:19:05 <mm_freak> that's what i call FRP =)
17:19:25 <mm_freak> netwire 4 is about to be released =)
17:19:41 <aristid> mm_freak: it prints time and fps?
17:19:48 <Dread> aristid: Yeah I guess you're right, although with `par` can't the compiler rearrange the order they are evaluated?
17:20:00 <mm_freak> aristid: for 8 seconds after 2 seconds
17:20:08 <aristid> mm_freak: that's a wire eith a String output i guess?
17:20:13 <mm_freak> yeah
17:20:14 <aristid> Dread: i'm not really familiar with par
17:20:30 <mm_freak> test :: Wire () (->) a String
17:20:30 <mm_freak> test = liftA2 (printf "%8.2f %8.2f") time (avgFps 10000) . after 2 . for 10
17:20:51 <callen> foldr show forecasts [] doesn't work
17:20:56 <callen> Couldn't match expected type `IO b0 -> IO b0' with actual type `String'
17:20:59 <aristid> mm_freak: the fps concept actually makes sense for pure wires?
17:21:05 <callen> Expected type: a0 -> IO b0 -> IO b0 Actual type: a0 -> String
17:21:17 <mm_freak> aristid: sure
17:21:45 <aristid> mm_freak: so you basically have some kind of machinery that generates "frames" on demand, and it's in effect for both pure and effectful wires?
17:21:48 <mm_freak> it runs with around 80k FPS with a clock and about 200m FPS without one
17:21:55 <mm_freak> yeah
17:22:04 <mm_freak> main = do s0 <- clockSession; testWire 1000 (return ()) s0 test
17:22:32 <mm_freak> clockSession is for real time clocks based on Data.Time.Clock
17:22:42 <aristid> mm_freak: do you have a name for inputs that generate only one frame, which never changes?
17:22:51 <mm_freak> aristid: 'pure' =)
17:22:53 <typoclass> callen: i see in your hpaste you're already doing "show forecasts". that shows the entire list of forecasts, so there's no need to call show individually on each one. you've already done that
17:22:58 <aristid> mm_freak: that's confusing!
17:23:08 <aristid> mm_freak: i propose calling them immutable
17:23:19 <aristid> mm_freak: or constant
17:23:24 <mm_freak> aristid: those are a special case of 'stateless' wires
17:23:39 <aristid> there are other stateless wires?
17:23:42 <mm_freak> a stateful wire produces different outputs for the same input in different instants
17:23:46 <mm_freak> yes, sure
17:23:56 <mm_freak> arr f is a stateless wire as well
17:24:01 <aristid> i see :)
17:24:05 <mm_freak> another one is 'empty'
17:24:10 <aristid> and arr (const x) is that special case
17:24:19 <aristid> or pure x using the Applicative
17:24:19 <mm_freak> yeah, but you would use 'pure' from Applicative
17:24:39 <mm_freak> in general you should use the applicative/category interface as much as possible
17:24:43 <aristid> i was just trying to stay close to your arr f example:)
17:25:01 <aristid> mm_freak: for a reason other than arrows being out of fashion?
17:25:01 <mm_freak> hehe, arr f is still just a special case
17:25:21 <mm_freak> main reason being that applicative wires are much easier to read and much faster
17:25:34 <aristid> mm_freak: do you have a general constructor for stateless wires?
17:25:34 <mm_freak> the factor can be anywhere between 10 and 100 times faster
17:25:47 <mm_freak> yeah, mkFix
17:25:53 <aristid> oh, so really avoid them
17:25:58 <aristid> what's the type of mkFix?
17:26:11 <mm_freak> mkFix :: (Reactive (>~)) => (Time -> a -> Either e b) -> Wire e (>~) a b
17:26:34 <aristid> wiat, but if they can use the time they can generate frames, no?
17:26:51 <takemitsu> callen: You want to show that Date, WeatherId, Description, etc. stuff, right?
17:27:03 <aristid> by themselves
17:27:49 <aristid> mm_freak: also sorry for not being able to type, my internet is very laggy right now so i'm typing a lot of this blindly
17:27:56 <callen> takemitsu: yes
17:28:09 <callen> takemitsu: honestly man, I've already given up
17:28:15 <mm_freak> aristid: no worries…  stateless wires produce the same output for the same input and same time delta
17:28:19 <callen> takemitsu: it shouldn't take this much effort to fetch and extract some XML
17:28:23 <callen> takemitsu: I'm just going back to Python
17:28:33 <mm_freak> mkPure :: (Reactive (>~)) => (Time -> a -> (Either e b, Wire e (>~) a b)) -> Wire e (>~) a b
17:28:37 <callen> I can't waste my time on this kind of raw absurdity
17:28:39 <mm_freak> that's the general wire
17:29:52 <aristid> mm_freak: time delta? i think there's a concept that needs explaining
17:30:14 <mm_freak> aristid: the Time value is the time delta to the last instant
17:30:36 <mm_freak> timeFrom t' = mkPure $ \dt _ -> let t = t' + dt in t `seq` (Right t, timeFrom t)
17:30:47 <mm_freak> timeFrom 0 is the current local time in seconds
17:30:52 <mm_freak> btw, Time is just Double
17:31:06 <aristid> mm_freak: oh, so you can get away with not generating frames for mkFix wires unless some other part of the automaton demands a frame?
17:31:08 <typoclass> callen: sorry to hear that :-/ the haddocks in my opinion are probably haskell's weakest point. good luck to you and if you ever feel like giving haskell a second chance, we're here :) it's rocky at first, but ultimately worth it
17:31:19 <aristid> mm_freak: also, "frame" is the right word?
17:31:26 <mm_freak> aristid: i don't understand
17:31:39 <mm_freak> and "frame" is too much bound to graphical stuff…  in netwire i call those "instants"
17:31:49 <mm_freak> this instant, next instant, etc.
17:31:59 <aristid> mm_freak: i'm fixated with not generating instants unless absolutely necessary
17:32:05 <mm_freak> so avgFps despite its name produces the average number of "instants" per second
17:32:14 <mm_freak> aristid: "generating instants"?
17:32:24 <mm_freak> an instant is an invocation of the wire
17:32:42 <aristid> mm_freak: and for an instant you need to recalculate the whole wire, no?
17:32:43 <callen> typoclass: I'm having a hard time believing it's ultimately worth it if doing something as simple as parsing XML is like smashing my head against a brick wall until I am smearing my brains all over
17:32:50 <mm_freak> note that not all wires are reached…  in particular non-happened events don't cause computation other than finding out that the event didn't happen
17:32:56 <startling> callen: welcome to haskell!
17:33:04 <callen> typoclass: what am I supposed to believe is going to happen once I'm working on a legitimately complicated problem? that all my troubles will evaporate and it'll suddenly get easy?
17:33:08 <callen> typoclass: thank you for your kind words though.
17:33:12 <typoclass> startling: is that supposed to be humor?
17:33:14 <aristid> mm_freak: well but the mkFix wires by themselves will always be reached, no?
17:33:22 <startling> typoclass: I wish. :(
17:33:32 <mm_freak> aristid: consider w . e, where 'e' is an event
17:33:38 <startling> typoclass: (yeah)
17:33:44 <mm_freak> if the event doesn't occur, w never gets control
17:34:07 <mm_freak> that also has an interesting side effect:  avgFps 1000 . wackelkontakt 0.5
17:34:11 <callen> by the way
17:34:15 <mm_freak> the reported number of frames will be only half
17:34:26 <callen> it took me the last two minutes to get the XML parsed and returning forecast elements in python
17:34:26 <mm_freak> 'wackelkontakt' is a random wire that produces an event 50% of the time
17:34:36 <callen> observe as it takes me another 5 to extract the data and turn it into JSON
17:34:41 <aristid> mm_freak: ok, so if stuff is bound to events there's no invocation
17:34:59 <mm_freak> there is invocation, if the event happens =)
17:35:03 <aristid> mm_freak: but if you have an FPS display at the top of the foodchain, your CPU utilization goes to 100%?
17:35:19 <mm_freak> aristid: type Event e (>~) = forall a. Wire e (>~) a a
17:35:39 <mm_freak> aristid: not necessarily…  only if your application causes instants continuously
17:36:02 <aristid> mm_freak: but you said it's not inhibited unless there's an event in front
17:36:41 <aristid> mm_freak: i'm sure i'm not using your jargon correctly, that's why you need to read my mind a little, sorry
17:36:59 <callen> ipdb> dateblah.firstChild.nodeValue
17:37:00 <callen> u'2011-11-08T00:00:00
17:37:03 <callen> ding. data extracted.
17:37:08 <callen> time to aggregate the results.
17:37:46 <aristid> mm_freak: basically the core of my thinking is that it bothers me that videogames always run at 60 fps and use 100% CPU and make my laptop run hot, so i'm hoping that netwire has ways to prevent that, and i'm forming hypotheses as to how that might be done
17:37:50 <mm_freak> aristid: ok, let me explain what happens for w2 . w1
17:38:01 <mm_freak> w1 is a wire that may inhibit…  if it does inhibit, then the composition inhibits
17:38:10 <mm_freak> events are identity-like wires that may inhibit
17:38:42 <mm_freak> aristid: that's not the job of the wire, but the enclosing application, but it's possible easily
17:38:44 <typoclass> callen: i haven't worked with xml so far, but in other areas, a haskell library will often be an entirely new thing with new concepts, new idioms, new ways of doing things, etc. i've often noticed friction, especially because of the usually poor docs. the friction tended to go away only after i got the hang of a new library quite some time later (my 2 cents)
17:39:18 <mm_freak> aristid: most applications/games do that by waiting for the vertical retrace
17:39:27 <jfischoff> roconnor: this is what I was really trying to do … I think. Haven't run the code yet :p
17:39:30 <jfischoff> https://github.com/jfischoff/th-plate/blob/master/src/Language/Haskell/TH/Plate/Folds.hs
17:40:04 <aristid> mm_freak: some games seem to not wait at all and instead run the simulation of the game world at the fastest speed the computer supports
17:41:01 <callen> typoclass: I don't want some asshole grad student's pet project
17:41:03 <callen> typoclass: I want to get things done
17:41:05 <mm_freak> aristid: that's sensible, because in increases the granularity of things like AI
17:41:06 <jfischoff> edwardk: the monster TH plate code, totally untested https://github.com/jfischoff/th-plate/blob/master/src/Language/Haskell/TH/Plate/Types.hs
17:41:11 <callen> typoclass: you haskellers need to stop pretending your language is "practical"
17:41:23 <callen> typoclass: it's just an agglomeration of experiments
17:41:24 <aristid> callen: no need to get abusive.
17:41:31 <callen> aristid: abuse is that fucking library
17:41:33 <jfischoff> callen: dude I use everyday at work
17:41:48 <jfischoff> callen: it is unbelievably practical
17:41:53 <startling> callen: heh
17:41:57 <callen> typoclass: sigh, I'm sorry. you're one of the nice people.
17:42:01 <mm_freak> callen: calm down and please summarize your problem
17:42:11 <mm_freak> callen: i'm sure there is a solution =)
17:42:12 <callen> jfischoff: I don't possess your degree of psychosis, so I can't empathize.
17:42:20 <callen> mm_freak: yeah uh, the channel tried
17:42:23 <jfischoff> callen: haha
17:42:32 <mm_freak> callen: people tried…  the channel is a set of people =)
17:42:39 <jfischoff> well I guess if you gonna troll at least be funny
17:43:12 <mm_freak> jfischoff: please stop it…  we're known to be one of the nicest programmier communities around for some reason =)
17:43:19 <mm_freak> -i
17:43:41 <mm_freak> callen: again, please summarize your problem, because i didn't follow the discussion
17:44:08 <aristid> mm_freak: he stated before that he has given up because he considers it too hard
17:44:09 <jfischoff> mm_freak: I will definitely stop it, but what was it I did?
17:44:33 <mm_freak> jfischoff: nothing particular, except that you two are heating the discussion mutually =)
17:44:51 <mm_freak> aristid: "it"?  haskell?
17:44:55 * jfischoff nods
17:45:14 * jfischoff takes it as his cue to make dinner
17:45:14 <aristid> mm_freak: no, solving his problem.
17:45:29 <mm_freak> i see
17:45:31 <aristid> i did take offense at this statement: "callen | typoclass: I don't want some asshole grad student's pet project"
17:45:47 <parcs`> callen has been mostly offensive since he got here
17:46:08 <callen> aristid: are you a grad student inflicting others with your pet projects?
17:46:34 <KJChernov_> Hello. I'm reading the chapter about main thread (http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html), but I can't figure out, why can I write "newManager = Mgr `fmap` newMVar M.empty", but can't use "newManager = fmap Mgr newMVar M.empty". Can anybody tell me the answer, please?:)
17:46:55 <mm_freak> aristid: i understand that offense…  for a beginner it can be hard to tell whether a library is mature, but being a "grad student pet project" is not the attribute to check
17:47:10 <mm_freak> i think that's callen's problem
17:47:27 <aristid> KJChernov_: you need to put newMVar M.empty in parens
17:47:32 <typoclass> parcs`, aristid: that may have been a bit much, but again, he's very frustrated, he's tried for hours to get a simple thing to work, and it _is_ true that haskell libraries are often not really polished (e.g. in terms of documentation)
17:48:10 <aristid> typoclass: you actually consider a webserver that reads XML from a public webservice, parses it, and re-emits it as JSON as a "simple thing"?
17:48:11 <KJChernov_> aristid, wow, thank you very much, it worked!:)
17:48:31 <mm_freak> aristid: yes, that should be simple to do
17:48:35 <mm_freak> and it is with the proper libraries
17:48:43 <aristid> mm_freak: if you have used the language before, sure
17:48:59 <aristid> mm_freak: but if it's your first actual usage of a language, i wouldn't consider it simple
17:49:05 <mm_freak> that's true
17:49:28 <mm_freak> haskell is unique in that regard:  harder than everything else at first, easier than everything else when you're experienced
17:49:43 <mm_freak> at least if you have programmed before
17:49:49 <callen> mm_freak: would you like to take the challenge and help me parse XML into JSON?
17:49:55 <typoclass> aristid: it seemed to me that what he mostly was wrestling with was poor documentation, difficult api, no example code, hackage being down
17:50:25 <mm_freak> callen: i can recommend a set of libraries and point you to the documentation you need to read, but basic haskell knowledge will be required
17:50:40 <mm_freak> at what stage is your haskell experience?
17:50:47 <aristid> typoclass: i didn't see the whole thing, but actually passing the correct namespace to the QName constructor doesn't seem like something haskell-specific to me
17:51:06 <callen> mm_freak: oh ho. oh. okay. well. let me share the graveyard.
17:51:21 <Dread> I will say Haskell has terrible documentation. Especially for beginners. There is a reason for that old joke about explaining monads.
17:51:22 <naula> okay: here is my kludge for installing Haskell-packages from hackage to Debian GNU/Linux: http://iki.fi/hacks/sh/cabal/
17:51:30 <hpaste> callen pasted “code graveyard, again.” at http://hpaste.org/72998
17:51:35 <callen> mm_freak: ^^
17:51:39 <otters> Dread: what's that joke?
17:51:41 <mm_freak> callen: of course when you have specific problems along the way, i'm happy to help as far as i can =)
17:51:51 <callen> mm_freak: I don't have any math education, is this the problem?
17:51:54 <aristid> Dread: well, if hackage is down, the documentation is certainly terrible.
17:52:09 <callen> the extent of my knowledge of math is limited to some linear algebra, set theory, and the usual raw computer stuff.
17:52:12 <Dread> Monads are just monoids in the category of endofunctors
17:52:14 <startling> otters: monads are just morphisms in the category of endofunctors, what's the problem?
17:52:19 <otters> oh
17:52:22 <startling> callen: that's not a problem
17:52:26 <naula> argh! I meant: http://iki.fi/juhtolv/hacks/sh/cabal/
17:52:29 <callen> startling: then what is?
17:52:34 <startling> callen: bad docs
17:52:38 <aristid> startling: i thought they are strong lax endofunctors in the category of monoids? :D
17:52:39 <startling> callen: and hackage being down
17:52:42 <mm_freak> callen: now there is one very important question you have to answer first:  do you want to learn the language or just get stuff done?
17:52:43 <callen> startling: because I just got done writing, literally the entirety of what I wanted, in 15 minutes in Python.
17:52:43 <startling> aristid: no idea!
17:52:52 <aristid> or strong lax monoids in the category of endofunctors?
17:52:57 <callen> startling: it fetches the XML, parses it into JSON, passes it on via a web app.
17:53:05 <callen> mm_freak: I want to get stuff done as I learn
17:53:05 <startling> callen: sure. haskell definitely takes some getting used to
17:53:10 <mauke> callen: no wonder you're having problems. you already know python.
17:53:19 <startling> callen: python is a nice language; if that works for you, what's your problem?
17:53:29 <mm_freak> callen: in haskell these two tasks have to be done separately, that's why it's an exclusive or there
17:53:30 <callen> startling: I want something stronger typed.
17:53:31 <Jurily> mauke: ouch
17:53:33 <startling> callen: ah
17:53:52 <parcs`> this is how far callen's experience with haskell extends: "I did some research prior to today, I learned the basic concepts and syntax."
17:53:52 <mauke> Jurily: imperative mindset
17:53:56 <mm_freak> callen: the point is:  if you're not patient enough to first learn haskell (at least the basics of the type system), you should probably just go with python
17:54:03 <callen> mauke: I'm an ex-lisper, prick.
17:54:12 <mauke> callen: even worse
17:54:14 <parcs`> in this case poor documentation is not the problem
17:54:16 <callen> mauke: I understand functional from that realm just fine.
17:54:16 <typoclass> aristid: i see your point, but the missing namespace parameter wasn't his only problem, and the question in my mind is why the api accepts a Maybe String if (apparently) it's not going to do anything on Nothing
17:54:29 <mauke> callen: which lisp?
17:54:53 <callen> mauke: mostly cmucl, some mzscheme.
17:55:00 <mauke> ah
17:55:01 <aristid> typoclass: well, i think the reason for that is that no namespace is not the same as a namespace for which the URI happens to be empty :)
17:55:11 <mm_freak> haskell does have a learning curve before you can get really productive
17:55:11 <mauke> I can't talk about scheme but common lisp isn't very functional
17:55:13 <startling> callen: honestly, I'd try this again when hackage is back up
17:55:23 <mm_freak> also common lisp is mainly imperative
17:55:37 <callen> so, are we done No True Scotsman'ing the FP nature of Lisp
17:56:04 <mm_freak> even if it were functional (like, say, scheme) it wouldn't help you much with haskell…  it's just too different in about every regard
17:56:06 <mauke> that's not what's happening
17:56:19 <broombs> hackage down again?
17:56:23 <mm_freak> broombs: yeah
17:56:27 <aristid> broombs: sadly, still
17:56:34 <callen> mm_freak: oh believe me, I've gathered as much.
17:56:47 <broombs> how long has it been down?
17:56:57 <typoclass> broombs: couple hours
17:57:09 <broombs> thx
17:57:16 <mm_freak> callen: btw, the fastest way to get answers to your question is to post on SO
17:57:22 <mauke> callen: I'm speaking from my own experience. I didn't have a lot of problems with the basic concepts when I was learning CL
17:57:29 <mm_freak> even though i don't like SO, it is quite an efficient help platform
17:57:45 <aristid> mm_freak: doesn't SO have a no homework rule?
17:57:55 <Jurily> callen: don't blame the langugage for a bad API
17:57:56 <callen> I'm not doing homework.
17:58:12 <aristid> callen: ok, i was just assuming as much since you said it has to be done today.
17:58:15 <callen> Jurily: I'm happy to blame the people crazy enough to use the language for not possessing the taste to produce a good API
17:58:23 <callen> aristid: never heard of a hackathon I take it?
17:58:27 <callen> aristid: you should try leaving your ivory tower.
17:58:30 <callen> aristid: you might enjoy it.
17:58:35 <mm_freak> aristid: good question, but haskell questions could almost always be considered "homework"…  yet the haskell community is very helpful even with the most basic questions
17:58:38 <geekosaur> actually SO is happy to help with homework, in the same way we are.  tag it as such and don;t ask for people tp solve it for you
17:58:45 <mm_freak> just think of all the "how do i remove points"-questions =)
17:59:00 <mm_freak> or "how do i convert IO X into X?"
17:59:02 <callen> I wasn't asking for the solution, I was trying to understand the code
17:59:09 <aristid> callen: i'm sorry for wrongly thinking this is homework. but please don't get abusive.
17:59:18 <callen> for example, mauke unhelpfully tossed an expression at me absent explanation earlier and was reticent when I tried to get him to explain it.
17:59:29 <callen> but clearly the fact that he won't explain the eldritch code he spews is my fault.
17:59:35 <mauke> callen: wait, what
18:00:11 <mauke> callen: what expression do you mean?
18:01:01 <mm_freak> callen: haskell APIs are about the nicest APIs you get, but you won't be able to acknowledge that before getting used to the /very/ different DSL-based paradigm
18:01:15 <parcs`> let's keep feeding the troll and writing off his offensive attitude as a result of his "frustration" with the language
18:01:17 <mauke> mm_freak: [citation needed]
18:01:32 <typoclass> mm_freak: i disagree, they are often pretty hard to figure out
18:01:33 <mauke> parcs`: of course
18:01:47 <aristid> mauke: of course perl APIs are the best. but haskell APIs are second-best ;) :P
18:01:49 <callen> parcs`: right, I wasted all that time trying to get the code to work just so I could troll.
18:01:49 <mm_freak> typoclass: that's an improper attribute to judge by
18:01:55 <mauke> aristid: [citation needed]
18:01:58 <Jurily> perl has APIs?
18:02:06 <callen> parcs`: if I were trying to troll I wouldn't have wasted the time trying to make the code work.
18:02:06 <mauke> Jurily: of course
18:02:08 <aristid> mauke: wasn't serious :)
18:02:09 <roconnor> jfischoff: what is the type of infoPL  and typPL?
18:02:10 <callen> could've spared myself the effort.
18:02:12 <typoclass> parcs`: he's not a troll. he had an actual problem which he tried to solve for hours
18:02:16 <Jurily> I thought that was just line noise
18:02:22 <mm_freak> callen: again, i recommend just going with python for now
18:02:24 <mauke> Jurily: you're thinking of Haskell
18:02:27 <mm_freak> return to haskell when you have some spare time
18:02:39 <callen> mm_freak: the project is done, aka stick a fork in it, already in Python.
18:02:59 <aristid> typoclass: but he _is_ abusive. he called mauke a prick, said i need to leave my ivory tower...
18:03:01 <mauke> callen: seriously, what expression were you talking about?
18:03:02 <callen> mm_freak: at this point I'm just trying to do a post-mortem and figure out why I hit such a hard brick-wall in Haskell.
18:03:13 <callen> aristid: he denigrated my intellect
18:03:20 <parcs`> typoclass: i'm giving him the benefit of the doubt by claiming that he's trolling
18:03:22 <callen> aristid: and you hopped on that bandwagon.
18:03:26 <mauke> callen: I didn't
18:03:37 <mm_freak> callen: yes, but i recommend trying again later…  the discussion today is very unproductive
18:03:38 <aristid> callen: no he said you learned python before, that does not denigrate your intellect at all.
18:03:49 <callen> mauke: you want to have disjoint realities, that's your problem, but it won't stop people taking offense when you use things like knowing Python against them.
18:03:56 <mikeplus64> callen: what's the original problem?
18:04:01 <callen> mikeplus64: XML -> JSON
18:04:05 <callen> mikeplus64: fetch XML over HTTP
18:04:08 <mauke> callen: I wasn't using it against you
18:04:10 <parcs`> typoclass: but others don't seem to have an issue with him so i won't say anything about this anymore
18:04:13 <callen> mikeplus64: destructure XML into constituent globs of data
18:04:19 <callen> mikeplus64: return JSON via HTTP Web Server
18:04:28 <callen> mikeplus64: I got the top level destructuring, web server, and HTTP client working
18:04:28 <jathd> callen: I barely followed, but if I'm not mistaken you replaced a Nothing by a string, and then didn't seem to understand what the compiler was complaining about, correct?
18:04:33 <callen> mikeplus64: it took hours though.
18:04:41 <callen> jathd: the book is much longer than that.
18:04:47 <jathd> ^^
18:04:51 <wires> it's like a python oneliner...
18:04:52 <callen> mikeplus64: hit a wall at the point where I needed to aggregate the results.
18:04:57 <jathd> Well, is that part correct anyway?
18:04:59 <callen> wires: right. that's kinda the point.
18:05:07 <wires> exactly
18:05:09 <callen> I gave up and wrote it in Python in 15 minutes.
18:05:15 <wires> haskell is not fit for everything
18:05:26 <mm_freak> wires: it's also a one-liner in haskell…  probably even a shorter line…  but this is not really helpful
18:05:30 <wires> sadely enought.. unless you are extremely well versed in it
18:05:38 <aristid> wires: you can solve this exact problem in haskell very succinctly, but you need to have learned haskell first.
18:05:54 <wires> well not just haskell, also know the right libraries to use
18:06:03 <aristid> yes.
18:06:03 <wires> please tell me which XML lib and which JSON lib to pick
18:06:07 <wires> i wouldn't know
18:06:15 <startling> wires: aeson is well-recommended for json
18:06:22 <mauke> callen: the point of my python remark earlier was that if you know basically any language at all, you're going to have problems with haskell
18:06:25 <zmoazeni> Hey folks, I'm slowly picking up attoparsec to parse shorthand CSS rules (e.g. background: 1px solid black), if you check http://www.w3.org/TR/CSS/ (or have worked with CSS) you'll see that values are optional, how would I structure the parser to look-ahead, or try a parse? (not homework)
18:06:25 <callen> wires: well I can tell you that Text.XML and Text.XML.Light are both a kick in the face.
18:06:26 <wires> there are a gazzilion of them, with incompatible types..
18:06:29 <aristid> wires: xml-conduit, not 100% sure about the JSON library. i guess aeson would be fine if a bit low-level
18:06:36 <callen> wires: aeson seems to be the way to go for JSON
18:06:37 <startling> zmoazeni: try
18:06:58 <wires> and for HTTP ?
18:07:00 <jathd> Because that probably means you need to work on understanding the type system better, if you don't understand when the compiler says "You gave me a String but I wanted a Maybe String."
18:07:03 <mm_freak> aristid: aeson lowlevel?  it generates JSON from haskell types transparently
18:07:11 <mm_freak> both in and out
18:07:14 <mikeplus64> bah, hackage is down
18:07:15 <zmoazeni> startling: I'm going through the github source, do you mean https://github.com/bos/attoparsec/blob/master/Data/Attoparsec/ByteString/Char8.hs#L39 ?
18:07:21 <aristid> mm_freak: too bad hackage is down, or i would look
18:07:34 <wires> mm_freak, that's nice.. it uses templating I supopse? which library?
18:07:43 <aristid> mm_freak: somehow my memory tells me that people are building higher-level libraries on top of aeson
18:07:54 <mm_freak> wires: it uses template haskell…  i'm talking about aeson
18:08:04 <wires> ok
18:08:04 <mm_freak> aristid: of course, like web frameworks =)
18:08:09 <zmoazeni> https://github.com/bos/attoparsec/blob/master/Data/Attoparsec/ByteString/Internal.hs#L145
18:08:16 <wires> so which client for http ?
18:08:18 <zmoazeni> Nice, thanks
18:08:21 <wires> s/client/library
18:08:22 <aristid> wires: http-conduit
18:08:25 <wires> ok
18:08:33 <wires> Now if only hackage was up ;)
18:08:33 <zmoazeni> startling: thanks
18:08:35 <mm_freak> wires: depends…  just grab a resource or have an HTTP session?
18:08:36 <wires> haha
18:08:44 <aristid> wires: for client that is. for server there are a few options.
18:08:48 <Jurily> the bar for "low level" seems a bit higher in Haskell
18:08:52 <wires> no basically to build the http -> json -> xml -> file pipe
18:08:58 <mm_freak> for HTTP servers either WAI or snap
18:09:00 <wires> yes, client
18:09:10 <mm_freak> wires: http-conduit is fine for that
18:09:12 <aristid> mm_freak: um my answer for both client questions would be http-conduit :)
18:09:17 <mm_freak> fetching a resource is a one-liner with http-conduit
18:09:18 <wires> cool, thanks
18:09:35 <mm_freak> including all the stuff like HTTPS, etc.
18:09:36 <wires> mm_freak: show it?
18:09:53 <aristid> simpleHttp "http://www.foobar.com"
18:09:57 <wires> just curious
18:09:59 <mm_freak> aristid: indeed, http-conduit now has a Browser module =)
18:10:09 <aristid> mm_freak: yeah :)
18:10:09 <mm_freak> wires: what aristid said
18:10:10 <wires> nice
18:10:18 <wires> Browser?
18:10:26 <wires> someone should bind phantomjs btw
18:10:27 <jfischoff> roconnor: https://github.com/jfischoff/th-plate/blob/master/src/Language/Haskell/TH/Plate/Types.hs
18:10:28 <aristid> for web browser-like sessions
18:10:30 <typoclass> mm_freak: yes, but you have to decode it then, and i'm not sure if package xml has a conduit sink thingy
18:10:33 <mm_freak> wires: HTTP sessions
18:10:36 <wires> nice
18:10:50 <wires> deals with cookies and such?
18:10:52 <aristid> typoclass: as the name xml-conduit indicates, it _has_ a sink :)
18:10:58 <mm_freak> typoclass: yeah, you get the string, and then there is xml-conduit
18:10:58 <aristid> typoclass: xml doesn't, xml is primitive
18:11:06 <jfischoff> roconnor: I'm at the very beginning stages of writing some TH for deriving Multiplate instances
18:11:07 <typoclass> but yeah, the basic case is pretty simple. and it features example code iirc. so large kudos to snoyman or whoever
18:11:12 <aristid> xml doesn't even have error handling
18:11:20 <aristid> i mean other than returning Nothing
18:11:25 <wires> ah so why not xml-conduit, http-conduit, json-conduit? does that exist?
18:11:29 <jfischoff> roconnor: starting with a plate for the TH types
18:11:35 <mm_freak> yeah, http-conduit is the work of michael snoyman
18:11:39 <mm_freak> just like conduits themselves
18:11:42 <aristid> wires: if hackage was up i'd look if json-conduit exists :)
18:11:50 <mikeplus64> aristid: hoogle is up
18:11:59 <wires> i've never had time to check those out, seemed cool
18:11:59 <mm_freak> although he took inspiration from gabriel gonzales
18:12:06 <aristid> mikeplus64: hoogle doesn't index 100% of hackage iirc
18:12:19 <mikeplus64> it does index all the package names
18:12:34 <mikeplus64> but i don't think all the documentation
18:13:00 <johnny934759> when will hackage be back up? tonight?
18:13:00 <mm_freak> wires: JSON (aeson) would be outside the pipeline
18:13:04 <Jurily> http://www.reddit.com/r/haskell/comments/y1tgc/any_hackage_mirrors_how_do_you_deal_with_hackage/
18:13:06 <aristid> wires: i'm not sure if in this case using conduits all the way would be productive though
18:13:11 <aristid> the XML responses are quite short
18:13:16 <mikeplus64> johnny934759: "It will be down most of today - we are switching over to a new network
18:13:19 <mikeplus64> connection."
18:13:28 <johnny934759> okkie
18:13:29 <mm_freak> aristid: it would be, because the code would be shorter
18:13:39 <aristid> mm_freak: i'm not sure about that
18:13:59 <aristid> mm_freak: you can use xml-conduit's cursors if you parse the whole document in memory
18:13:59 <jfischoff> roconnor: the current plan is given a Type find all of types its decedents refer to and (minus some primitives) build a plate from universe of types returned.
18:14:06 <mm_freak> aristid: runResourceT (fetch >+> parse >+> …)
18:14:25 <wires> you would be hoping to go somthing like get "url" >>> parseJson >>> encodeXML >>> writeFile "f" ? (for some >>>)
18:14:43 <aristid> wires: that should work roughly like this, yes
18:14:54 <mm_freak> wires: (>+>) in the case of conduit (or pipes)
18:14:55 <aristid> wires: except it's parseXML and encodeJSON :)
18:15:05 <wires> ah :)
18:15:07 <mm_freak> it's a convenience wrapper around (.) for Pipe
18:15:10 <roconnor> jfischoff: what's the type of reify?
18:15:13 <wires> ofcourse, evil in beauty out
18:15:19 <nand`> does pipe not form a Category?
18:15:25 <nand`> I think I remember something about leftovers breaking it
18:15:27 <aristid> nand`: it forms more than one
18:15:33 <jfischoff> roconnor: Name -> Q Info
18:15:54 <wires> what is the signature of Pipe ?
18:16:00 <mm_freak> nand`: it seems to be in conduit, but it's not in pipes
18:16:01 <jfischoff> roconnor: it is how you look up a type by name in TH
18:16:08 <mm_freak> you'll need a wrapper type, unless you use (<+<)
18:16:12 <aristid> nand`: oh, i read something about making it a Category in something with type pairs
18:16:36 <Jurily> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
18:16:37 <aristid> wires: for that please look at conduit's reference documentation. it involves 5 parameters i think
18:16:38 <Jurily> works
18:16:41 <mm_freak> wires: the Pipe type is scary in conduit…  better never look at it
18:16:50 <wires> hahahaha :)
18:16:55 <aristid> there are nice type aliases though
18:16:59 <aristid> Sink, Source, Conduit
18:17:03 <wires> that sounds promising :)
18:17:07 <jfischoff> roconnor: A data declaration has many Types and named types use the ConT "TypeName" constructor
18:17:09 <mm_freak> anyway, i want to get netwire done this weekend, so i'm back to my code =)
18:17:14 <Jurily> I'm kinda tempted to try porting conduit to C#
18:17:20 <latro`a> I thought netwire was already done
18:17:22 <aristid> mm_freak: do eet
18:17:23 <nand`> mm_freak: working on a new version or something?
18:17:28 <aristid> nand`: 4.0
18:17:28 <mm_freak> latro`a: netwire 4 isn't
18:17:34 <nand`> ah, nice
18:17:36 <latro`a> what's changing?
18:17:41 <mm_freak> latro`a: lots =)
18:17:42 <nand`> is hackage back up?
18:17:44 <latro`a> ah
18:17:45 <latro`a> also
18:17:48 <latro`a> on a scale of 1 to 10
18:17:56 <Jurily> nand`: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
18:17:59 <latro`a> how much do you think I'd learn trying to understand the netwire source
18:18:04 <latro`a> and how much work do you think it'd be
18:18:08 <jfischoff> roconnor: I don't know if that code works at all, I do have a pre Multiplate version that works but isn't as pretty ;)
18:18:12 <latro`a> eh, replace I with anyone, really
18:18:13 <nand`> Jurily: I need documentation :)
18:18:15 <roconnor> jfischoff: recursivly calling childTypes in go seems unusual
18:18:29 <mm_freak> latro`a: both 10
18:18:30 <wires> mm_freak, looks cool, netwire
18:18:35 <nand`> come to think of it, I actually downloaded hackage the other day
18:18:36 <nand`> I could use that
18:18:37 <latro`a> thanks
18:18:41 <aristid> nand`: cabal install --enable-documentation?
18:18:51 <Jurily> nand`: you don't have it locally? :P
18:19:03 <jfischoff> roconnor: I'm not sure how else to use reify ;(
18:19:03 <mm_freak> nand`: set "Documentation: True" in your ~/.cabal/config
18:19:07 <nand`> Jurily: nope, I have a heapton of tabs pointed at hackage.haskell.org
18:19:10 <mm_freak> then every package is installed with documentation
18:19:25 <roconnor> jfischoff: perhaps it is okay
18:19:28 <nand`> I don't have ~/.cabal :P
18:19:36 <mm_freak> you'll have it below ~/.cabal/share/doc/ and it will reflect your actual system instead of hackage
18:19:41 <nand`> but I could use USE="doc" for all haskell packages for the same effect
18:19:41 <mm_freak> whatever you have =)
18:20:02 <nand`> still, hoogle links to haddock :)
18:20:12 <mm_freak> you can set up hoogle to work locally
18:20:12 <aristid> nand`: install a local hoogle.
18:20:15 <nand`> oh right
18:20:19 <nand`> I do have that actually
18:20:19 <Jurily> try the eclipse browser
18:20:23 <jfischoff> roconnor: we'll find out I guess… what do you think of my plan to make the Multiplate instances?
18:20:27 <Jurily> freakin' awesome
18:20:29 <aristid> nand`: \o/ you're completely covered
18:21:01 * nand` wonders where he misplaced his copy of hackage
18:21:10 <SebastienGllmt> Is there a way to do map filter (==5) [[1,5],[5],[1,1]]
18:21:11 <mm_freak> nand`: /tmp in your last session
18:21:14 <mm_freak> now it's lost =P
18:21:19 <roconnor> jfischoff: seems appropriate for multiplate
18:21:31 <mm_freak> SebastienGllmt: map (filter (== 5))
18:21:32 <jfischoff> roconnor: alright!
18:21:47 <aristid> mm_freak: somehow i'd use <$> for that
18:21:52 <Jurily> http://i.imgur.com/IZWZW.png
18:21:53 <roconnor> @instances Monoid
18:21:54 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:21:56 <mm_freak> aristid: i wouldn't
18:22:09 <aristid> mm_freak: `map`, maybe? :)
18:22:14 <mm_freak> aristid: also no =)
18:22:23 <mm_freak> i don't quite see the advantage
18:22:33 <aristid> mm_freak: it looks less cluttered to my eye:)
18:22:43 <mm_freak> to my eye it's more cluttered
18:22:53 <rosie> When I :load a module in ghci and it adds a * in front of the module name in the prompt, I take that to mean all functions at the top level will be visible to the interpreter. Why does ghci add this functionality?
18:22:54 <mm_freak> i'm not an advocator of getting rid of parentheses at all costs
18:23:02 <mm_freak> i also write print (sum xs)
18:23:17 <mm_freak> or even (print . sum) xs
18:23:24 <nand`> at all costs? no; but I try never to go beyond two nestings; and usually the second one is to section or prefix some operator
18:23:41 <nand`> that I would write as print (sum xs)
18:23:46 <aristid> mm_freak: my adversion to parentheses is already less than it used to be :)
18:24:11 <nand`> (print . sum) xs I think is needlessly complex, unless you're going for multiple levels
18:24:18 <Jurily> print $ sum xs
18:24:22 <mm_freak> i find that one quite nice actually
18:24:26 <aristid> nand`: but it looks kinda cool
18:24:38 <sral> is free monad useful when not working with script or del?
18:24:40 <sral> *dsl
18:24:54 <mm_freak> anyway, i hate dollar signs, and i dislike using combinators infix, unless they actually do some form of "bringing together"
18:25:06 <mm_freak> "map" doesn't feel like "bringing together" the function with the list
18:25:14 <aristid> mm_freak: but it is:)
18:25:16 <mm_freak> `mappend` is fine, for example
18:25:23 <kaniu> @pl \i e -> flip (extend i e) . Val <$> fresh
18:25:23 <lambdabot> flip flip fresh . ((<$>) .) . flip flip Val . (((.) . flip) .) . extend
18:25:30 <kaniu> lol nope
18:25:32 <aristid> mm_freak: mmh you're conservative:)
18:25:35 <Jesin> mm_freak: umm...  what about (<*>) then
18:25:39 <jfischoff> mm_freak: I hate dollar signs too, no idea why...
18:25:43 <nand`> Jesin: brings them together, by applying
18:25:44 <mm_freak> aristid: it always is, it's a matter of interpretation and my desire to look at one place to understand what's going on
18:25:54 <mm_freak> aristid: i have to search for the "map" in your example
18:26:12 <Jurily> let (£) = ($)
18:26:17 <pqmodn> :)
18:26:18 <Jesin> nand`: (<$>) brings them together by applying too
18:26:19 <Jesin> ....
18:26:19 <mm_freak> people find my code particularly easy to read, and that's the reason =)
18:26:20 <aristid> Jurily: much better ;)
18:26:21 <Jesin> lol Jurily
18:26:34 <mm_freak> Jesin: i think i seldomly use (<*>) without (<$>)
18:26:40 <mm_freak> mostly i use liftAn
18:26:52 <mm_freak> in particular i /really/ seldomly use (<*>) on its own
18:27:01 <Jafet> rosie: when writing the module, some people want to test things that they aren't exporting
18:27:12 <nand`> personally I only use <$> for mapping over singleton-y functors; eg. IO or Identity or other functors which seem to “carry one value”; I avoid it strongly for [], Tree, Map k, etc.
18:27:17 <aristid> mm_freak: would you even do ($) <$> a <*> b or liftA2 ($) a b instead of a <*> b?
18:27:34 <mm_freak> nand`: yeah, i prefer fmap there
18:27:37 <nand`> because in those situations, I read it like function application: “foo <$> getContents” is just foo applied to the result of getContents
18:27:40 <Jurily> I like $ because of the resemblance to shell pipes
18:27:49 <rosie> Jafet: Thanks. Does ghci always add a * to a module it :load's and not to one it :import's ?
18:27:54 <mm_freak> aristid: no, i'd do the latter…  it just comes up seldomly enough =)
18:28:02 <nand`> eg. “unlines <$> getContents” looks fine, but “fmap unlines getContents” is a bit more stimulating
18:28:04 <aristid> mm_freak: i see:)
18:28:09 <mm_freak> Jurily: shell pipes are resembled by (.), not ($)
18:28:12 <Jesin> [21:26:50]	nand`	personally I only use <$> for mapping over singleton-y functors; eg. IO or Identity or other functors which seem to “carry one value”; I avoid it strongly for [], Tree, Map k, etc.
18:28:18 <Jafet> ghci imports all toplevel names from interpreted modules
18:28:25 <Jafet> If you compile the module, it can't
18:28:25 <Jesin> the [] monad can be seen as a single nondeterministic computation.
18:28:37 <otters> what does deterministic mean
18:28:48 <nand`> Jesin: if I'm using it as such I may consider <$> as well
18:28:55 <mm_freak> nand`: i think i always use fmap, unless i want to combine with (<*>)
18:29:27 <Jesin> also I have no idea what I think about Cont.
18:29:32 <mm_freak> <$> is nice for lining up vertically
18:29:33 <nand`> mm_freak: note how they read differently based on their position but both still make sense; “map foo over xs” vs “foo mapped over xs”
18:29:40 <Jesin> I've never been able to understand that monad  :P
18:29:44 <nand`> perhaps the latter is more declarational :)
18:29:46 <aristid> Jesin: i think nobody ever actually uses Cont
18:30:01 <nand`> I prefer Codensity
18:30:04 <nand`> over Cont :P
18:30:10 <aristid> i guess the reason is that Cont is too powerful
18:30:21 <Jafet> I meditate on Cont under the tumtum tree
18:30:28 <aristid> you can almost always do with a more restricted type
18:30:46 <mm_freak> nand`: that's why i prefer to call functions as nouns instead of verbs, but "map" is nicely concise
18:31:05 <aristid> Jesin: read this, about Cont: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
18:31:28 <mm_freak> i think Free is the mother of all monads today =)
18:31:31 <nand`> mm_freak: like “negation x” vs “negate x”?
18:31:37 <mm_freak> but Free resembles Cont to some degree
18:31:44 <nand`> Codensity ∘ Free
18:31:50 <mm_freak> nand`: negated
18:31:51 <nand`> mother of all computations
18:31:53 <nand`> ah
18:32:07 <mm_freak> such that "negated x" reads as a noun with an attribute
18:32:11 <nand`> “(x `negated`)”
18:32:57 <aristid> i guess i live in a 2008 world
18:33:48 <mauke> (atlas `shrugged`)
18:33:51 <nand`> aristid: buy Apple
18:34:08 <nand`> or AAPL or w/e the stock is called
18:34:13 <mm_freak> ok, back to netwire
18:34:21 <aristid> nand`: as it happens i made some nice profit on shares i bought in 2011 :P
18:34:45 <nand`> you bought shares from the future?
18:34:55 <avpx> Better yet, see if you can find someone who lives in a 2006 world
18:34:59 <Jesin> aristid: that article is just as mindblowing as it was several months ago.
18:35:00 <roconnor> jfischoff: I'm worried your childTypes will, in general, run forever recursivly reifying the same names over again.
18:35:01 <Jesin> lol
18:35:01 <aristid> nand`: my 2008 world sadly only applies to haskell :)
18:35:04 <avpx> Then just keep hopping back in time until you can make some serious profits
18:35:11 <nand`> oh
18:35:40 <aristid> nand`: i guess the joke also breaks down when i talk about conduits. oh well :D
18:35:41 <roconnor> jfischoff: other than that, what you have written looks reasonable.
18:35:47 <jfischoff> roconnor: yeah if there were cycles
18:35:55 <Jesin> ooh, however
18:36:22 <aristid> Jesin: it's a good post, just reread every month it until you understand it :)
18:36:38 <Jesin> aristid: I am understanding it better this time
18:36:45 <Jesin> ^_^
18:36:49 <aristid> yay
18:37:28 <jfischoff> roconnor: yeah I can handle (mutual) recursion with a list and skip those I have already read. Basically Reader and local or something equivalent.
18:38:06 <jfischoff> read as in reify
18:38:19 <mm_freak> fmap (printf "%8.2f") (time + noise (mkStdGen 0)) . for 10 . after 2 <|> "please wait"
18:38:22 <mm_freak> netwire 4 =)
18:39:31 <mm_freak> prints a noisy time for eight seconds after two seconds or "please wait" =)
18:40:00 <edwardk> hackage still dead?
18:40:05 <mm_freak> edwardk: yeah
18:40:07 <edwardk> blech
18:40:21 <aristid> mm_freak: the please wait appears deterministically?
18:40:26 <mm_freak> aristid: yeah
18:40:39 <aristid> before the 2 and after the 12 seconds?
18:40:49 <mm_freak> after the 10 seconds
18:41:00 <aristid> why not before the 2?
18:41:02 <mm_freak> it's printed in the interval [2,10)
18:41:08 <mm_freak> not in the interval [2, 12)
18:41:25 <aristid> the name "for" is confusing then
18:41:36 <mm_freak> no, the (.) might be confusing =)
18:41:50 <mm_freak> the time delta a wire receives is the delta to its own last instant, not to the last global instant
18:42:00 <aristid> mm_freak: oh the . doesn't allow the after 2 to change the frame of reference?
18:42:08 <mm_freak> correct =)
18:42:25 <aristid> mm_freak: how to change the frame of reference? :>
18:42:32 <SebastienGllmt> Is it possible to do something like fst "de"
18:42:50 <mm_freak> aristid: there will be a set of wire transformers for locality
18:43:22 <aristid> mm_freak: i guess the best way to build a FRP-Braid with netwire would be to introduce a secondary notion of time for different parts of the simulation? :)
18:44:03 <mm_freak> aristid: i figured that in yampa the notion of locality mostly just stood in your way, so the implicit switching combinators are global in netwire
18:44:06 <aristid> mm_freak: hmm, an actual time transformer might be evil
18:44:15 <mm_freak> aristid: for yampa-style locality you can use the switching combinators
18:44:19 <aristid> mm_freak: like letting time run backwards locally
18:44:27 <mm_freak> or use the locality combinators i'll write
18:44:41 <mm_freak> not at all evil
18:44:49 <aristid> not? :)
18:44:57 <mm_freak> you should be able to run certain simulations backwards by flipping the sign of the time deltas
18:45:10 <mm_freak> those which follow newtonian laws at least =)
18:45:29 <aristid> mm_freak: so that would make building FRP-Braid almost trivial with netwire? :)
18:45:48 <aristid> (i assume you do know Braid)
18:46:09 <mm_freak> i don't…  i just assumed it's some sort of reversible simulation =)
18:46:28 <Jafet> braid isn't reversible
18:46:42 <aristid> mm_freak: it's a puzzle platformer with funny time manipulation. in some puzzles time runs backwards for some entities and forwards for others, and so on
18:47:03 <mm_freak> aristid: you can have negative time deltas for parts of the system
18:47:33 <mm_freak> but that's not reversing…  that's just inverting the sense of time an object receives
18:47:43 <mm_freak> 'integral' would run backwards for instance
18:47:56 <mm_freak> or actually 'integral_' in netwire 4 =)
18:48:05 <aristid> mm_freak: i'm sometimes mixing up the word reverse and inverse.
18:48:16 <mm_freak> 'integral' is an actual integral in netwire 4…  you can pass both dx and dt, not just dx =)
18:48:27 <mm_freak> or rather dy, not dt =)
18:48:35 <mm_freak> integral_ = integral . (id &&& dtime)
18:48:47 <aristid> what's the type of integral_?
18:48:57 <aristid> (i'm scared of the type for integral for now)
18:48:58 <xpika> does anyone know the mirror for hackage?
18:49:21 <mm_freak> integral_ :: (Reactive (>~), VectorSpace b, Scalar b ~ Time) => b -> Wire e (>~) b b
18:49:38 <Jurily> xpika: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
18:49:43 <geekosaur> [11 21:17] <Jurily> nand`: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
18:49:47 <geekosaur> heh
18:49:49 <xpika> ty
18:49:58 <mm_freak> aristid: integral :: (Reactive (>~), VectorSpace b) => b -> Wire e (>~) (b, Scalar b) b
18:50:19 <aristid> mm_freak: so the integral actually has the shorter type oO
18:50:20 <mm_freak> if the right signal is 'dtime', the it acts like the classic integral wire
18:50:26 <mm_freak> yeah =)
18:50:53 <nand`> geekosaur: you should have highlighted xpika as well for maximum points
18:51:02 <mm_freak> integral_'s type isn't much longer…  i'm just using '~' for convenience there
18:51:12 <aristid> mm_freak: do you have a short usage example?
18:51:43 <mm_freak> integral_ 0 . integral_ 0 . pure 5
18:51:46 <mm_freak> where 5 is acceleration
18:51:59 <mm_freak> or actually:  integral_ 0 . integral_ 0 . 5
18:52:01 <mm_freak> =)
18:52:12 <aristid> cool
18:52:33 <aristid> i figure that might be highly useful
18:52:43 <mm_freak> for multi-dimensional coordinates just use tuples:  integral_ (0, 0) . integral_ (-4, -1) . pure (1, 2)
18:52:53 <aristid> mm_freak: can you put an artificial top speed in there?
18:53:08 <mm_freak> not in 'integral_', but in 'integralLim_'
18:53:29 <mm_freak> integralLim_ :: (Reactive (>~), VectorSpace b, Scalar b ~ Time) => (w -> b -> b) -> b -> Wire e (>~) (b, w) b
18:53:40 <mm_freak> 'w' is some kind of "world state"
18:54:09 <mm_freak> the function argument can then perform arbitrary transformations on the integral including limiting
18:54:28 <aristid> mm_freak: so how'd that work? i'm confused
18:55:04 <mm_freak> integralLim_ (const $ min 10) 4 . pure 1
18:55:14 <aristid> integralLim_ (\_ -> max 100) 5?
18:55:16 <aristid> oh ok yeah
18:55:17 <mm_freak> starts at 4, goes up 1/s and stays at 10
18:55:58 <mm_freak> some people complained that 'integral' is not powerful enough in netwire 3, because it couldn't be used to control, say, a robot arm
18:56:20 <mm_freak> thus now you have integralLim and integralLim_ =)
18:56:21 <aristid> people actually are using it for such things? cool
18:56:25 * nand` remembers something or other about something involving type operators being changed.. would that break (>~) being used like that? Or has the change already been implemented?
18:56:44 <mm_freak> nand`: it doesn't change anything…  notice that (>~) is a type variable
18:57:05 <aristid> mm_freak: actually my example was something like the portal where you can get infinite acceleration by placing portals on ceiling and floor, but you have a top speed :D
18:57:11 <nand`> doesn't it break “Arrow (~>) => a ~> a” though?
18:57:12 <aristid> -the
18:57:22 <nand`> where ~> is also being used as a type variable
18:57:31 <aristid> mm_freak: but i guess i play more videogames than you :D
18:57:34 <edwardk> i wonder if the tanh-sinh integration tricks could be used to make a more stable integrator for frp
18:57:41 <mm_freak> nand`: you never have that in netwire
18:57:57 <nand`> I didn't mean netwire, mind
18:58:06 <mm_freak> edwardk: how?
18:58:15 <mm_freak> integral = accum (\x (dx, dt) -> x ^+^ dt *^ dx)
18:58:21 <mm_freak> that's how 'integral' is implemented
18:58:22 <edwardk> haven't fully fleshed it out yet
18:58:34 <mm_freak> where 'accum' is basically a left scan
18:58:36 <edwardk> you familiar with double exponential quadrature?
18:58:43 <mm_freak> nope, sorry
18:59:00 <edwardk> i'd usually point you at hackage and say 'download integration' ;)
18:59:00 <mm_freak> anyway, it would impose a Floating constraint on the signals
18:59:08 <mm_freak> i'd like to stay with VectorSpace =)
18:59:23 <SebastienGllmt> so would anybody know how to do something like fst ("ab")
18:59:24 <edwardk> but the gist is integration by stepping uniformly is really bad
18:59:34 <mm_freak> SebastienGllmt: 'head'
18:59:49 <aristid> mm_freak: would be possible to put that stuff in a second package
19:00:05 <SebastienGllmt> but why doesn't fst work if "ab" is an array of 'a','b'
19:00:12 <mm_freak> edwardk: i think the solution i have is numerically stable…  note that it's not a parametric integral, i.e. you can't actually /choose/ x
19:00:12 <aristid> mm_freak: hmm, the quality of your integration degrades if the speed of the simulation is slowed down, right?
19:00:14 <edwardk> we can do something much smarter that happens to be robust over the hardy space H^p by changing variables first
19:00:24 <edwardk> sure
19:00:33 <smokey991> SebastienGllmt, "ab" is a list
19:00:48 <edwardk> but i mean the timestep forward could be handled in an interesting way by doing quadrature over the intervening timeline with nonuniform steps
19:00:49 <mm_freak> aristid: depends…  you can get floating point underflows, when dt is large and dx is small
19:00:59 <mm_freak> aristid: but there is no way to solve that
19:01:13 <mm_freak> aristid: also the integration stuff is pretty much bound to netwire
19:01:19 <mm_freak> i don't know how to decouple that
19:01:20 <edwardk> i'm familiar with the usual frp integral trick, just fishing for a better one ;)
19:01:47 <mm_freak> edwardk: i'd rather be interested in such a trick for differentiation instead of integration
19:01:58 <mm_freak> because differentiation can be unstable, if the framerate is high
19:02:15 <edwardk> well, so is integration
19:02:25 <edwardk> differentiation can be done with AD at least
19:02:26 <aristid> mm_freak: i can't out of hand think of a practical use for differentation in FRP. not saying there is none, more that i want you to tell me one :)
19:02:34 <mm_freak> yes, but integration uses multiplication, while differentiation uses division by dt
19:02:47 <edwardk> well, sure if you avoid using AD ;)
19:02:53 <mm_freak> AD?
19:02:56 <mm_freak> active directory? =)
19:02:58 <edwardk> automatic differentiation
19:03:03 <edwardk> e.g. my 'ad' package
19:03:09 <aristid> edwardk's most elaborate SO answer ever.
19:03:16 <edwardk> aristid: hahaha
19:03:33 <mm_freak> aristid: easy:  you have a changing signal and want to get the change rate…  for example you can show a meter that shows the current FPS trend =)
19:03:39 <mm_freak> aristid: differentiation is about trends
19:04:09 <aristid> mm_freak: but wouldn't i usually want that not entirely instantaneously but over say the last 1 second or so?
19:04:18 <mm_freak> aristid: use 'avg' =)
19:04:21 <edwardk> what you have so far is finite differencing, which is related but not quite differentiation
19:04:34 <Jesin> [22:02:48]	aristid	edwardk's most elaborate SO answer ever.
19:04:40 <Jesin> yes that was amazing
19:04:42 <Jesin> :D
19:04:46 <edwardk> =)
19:05:16 <mm_freak> aristid: although 'avg' can only be done for a number of samples, not an amount of time…  yet
19:05:28 <Jesin> http://stackoverflow.com/questions/2744973/is-there-any-working-implementation-of-reverse-mode-automatic-differentiation-fo
19:05:31 <mm_freak> in fact:  avgFps n = recip (avg n) . dtime
19:05:36 <mm_freak> that's how avgFps is implemented
19:05:54 <Jesin> "Is there any implementation of this?"  "NOW THERE IS"
19:05:58 <mm_freak> and yes, 'recip' is the one from Fractional =)
19:06:16 <aristid> mm_freak: could you build a general wire for doing things over a fixed time window?
19:06:20 <edwardk> hrmm, the idea of using tanh/sinh style time sampling for integration in frp has me curious, i wonder if i can come up with a model that gives me a decent convergence estimate
19:06:28 <mm_freak> aristid: like what?
19:06:51 <aristid> mm_freak: it would return a list of values, i think
19:06:56 <mm_freak> edwardk: if you could turn this into an efficent automaton, i'd be very interested
19:07:08 * jfischoff upvotes edwardk answer on stack overflow 
19:07:08 <mm_freak> where automaton is:  data Auto a b = Auto (a -> (b, Auto a b))
19:07:17 <mm_freak> aristid: "return"?
19:07:25 <edwardk> oh you have discrete fixed time time steps?
19:07:29 <edwardk> then you're screwed ;)
19:07:35 <mm_freak> edwardk: oh, no i don't =)
19:07:39 <aristid> mm_freak: i'm sorry if this doesn't make a lot of sense
19:07:40 <mm_freak> where automaton is:  data Auto a b = Auto (Time -> a -> (b, Auto a b))
19:07:44 <mm_freak> and where Time = Double =)
19:08:01 <mm_freak> Time is a time delta, not relative time
19:08:05 <aristid> mm_freak: you said you want avg for a time window instead of a number of instants
19:08:20 <mm_freak> aristid: you can do that with 'unfold'
19:08:28 <mm_freak> or rather 'unfoldT'
19:08:37 <jmcarthur> mm_freak: i assume Time must be non-negative?
19:08:40 <mm_freak> unfoldT :: (Reactive (>~)) => (Time -> s -> a -> (b, s)) -> s -> Wire e (>~) a b
19:08:42 <edwardk> then in that case i can probably do tanh-sinh quadrature but i need to re-evaluate possible futures over the course of a 'frame' worth of time
19:08:54 <mm_freak> jmcarthur: no, it can be any number that is a number =)
19:08:59 <mm_freak> i.e. it can't be NaN
19:09:04 <nand`> ‘reverse mode’?
19:09:05 <edwardk> because i'll be taking smaller and smaller timesteps until the answer converges and those affect subsequent steps
19:09:24 <edwardk> nand`: http://en.wikipedia.org/wiki/Automatic_differentiation#Reverse_accumulation
19:09:45 <edwardk> nand`: forward mode AD like all the other haskell packages do is inefficient for n inputs you have to do n* as much work
19:09:51 <edwardk> reverse mode AD only pays per output
19:10:14 <edwardk> typically you have fewer outputs than inputs. (take a neural network for instance where the 'inputs' are all the weight on all the nodes
19:10:24 <edwardk> and the output may be a single signal
19:10:34 <mm_freak> i'm pleased to add:  'avg' uses O(1) time independent of the number of samples =)
19:10:46 <mm_freak> but of course O(n) space
19:10:46 <edwardk> you can do backpropagation in a neural network with 1 output in time proportional to the original algorithm.
19:10:50 <aristid> mm_freak: how is avg implemented?
19:10:57 <edwardk> in AD it takes O(n)* the original time for n weights
19:11:06 <edwardk> er in forward AD
19:11:13 <edwardk> (in backwards it takes proportional time)
19:11:29 <hpaste> “Ertugrul Söylemez” pasted “FRP: Average wire” at http://hpaste.org/73000
19:11:33 <edwardk> (usually we estimate reverse mode AD as costing about 3x as much)
19:11:33 <mm_freak> aristid: paste
19:12:34 <mm_freak> the context is a bit weird, but it's there to avoid having to use FlexibleContexts
19:13:06 <mm_freak> and Vu = Data.Vector.Unboxed
19:13:13 <mm_freak> and Vum = Data.Vector.Unboxed.Mutable
19:13:57 <aristid> mm_freak: but given that instants need not be equally spaced, the instant-counting parameter in avg is a bit weird?
19:14:04 <edwardk> hmm i wonder how well the lazy splines approach can be adapted as well
19:14:12 <edwardk> i'll need to check with sclv
19:14:19 <mm_freak> aristid: that's not instant counting
19:14:35 <mm_freak> it's just an index into the vector
19:14:46 <mm_freak> the vector is used as a ring buffer
19:15:05 <aristid> mm_freak: but every instant the vector is updated?
19:15:07 <jmcarthur> oh, this is a sliding window average? now it makes more sense!
19:16:22 <jmcarthur> unsafeThaw ... unsafeFreeze ... :o
19:16:43 <mm_freak> aristid: yes
19:17:00 <mm_freak> jmcarthur: it's safe because of the 'seq' in line 19
19:17:29 <mm_freak> oh, venus just appeared in the sky =)
19:17:55 <jmcarthur> mm_freak: but isn't this array shared for the duration of the automaton?
19:18:00 <jmcarthur> or am i misreading
19:18:07 <mm_freak> jmcarthur: nope
19:18:11 <mm_freak> samples' vs. samples
19:18:36 <mm_freak> the runST builds a new vector with a single changed data point
19:18:47 <jmcarthur> but you're using unsafeFreeze and unsafeThaw...
19:18:50 <mm_freak> it shares the underlying memory, but forgets about the old vector
19:19:10 <jmcarthur> what happens if i step backward and forward in succession?
19:19:26 <mm_freak> oh, now i understand
19:19:34 <mm_freak> you mean if the wire is shared?
19:19:42 <jmcarthur> yeah
19:19:49 <mm_freak> you're right actually =/
19:19:50 <jmcarthur> or, rather, its state
19:20:03 <mm_freak> i should probably go for Data.Sequence
19:22:10 <aristid> mm_freak: i bet the code would be shorter too
19:22:18 <jmcarthur> and slower :(
19:22:18 <mm_freak> it would be way shorter
19:22:23 <mm_freak> and slower, yeah
19:22:25 <Jafet> DiffArray!!
19:22:30 <jmcarthur> still slower
19:22:40 <mm_freak> also for some reason i dislike DiffArray
19:22:40 <aristid> better slow than incorrect :D
19:22:40 <jmcarthur> DiffArray is fast in theory
19:23:05 <mm_freak> i'll use Data.Sequence
19:23:28 <jmcarthur> but actually all DiffArray would do here is turn the situation that would demonstrate the bug into one that would demonstrate a space leak
19:23:35 <aristid> mm_freak: beware the drop from 200K to 50K FPS
19:24:10 <mm_freak> at least Data.Sequence has O(1) view and append
19:24:22 <aristid> jmcarthur: and Data.Sequence would behave well and uniformly slow?
19:24:24 <mm_freak> aristid: avgFps is not the main bottleneck
19:24:40 <mm_freak> aristid: the main bottleneck is realToFrac (diffUTCTime t t')
19:24:46 <aristid> lol
19:24:52 <mm_freak> i'm serious
19:24:53 <jmcarthur> mm_freak: data Queue a = Queue [a] [a]  is probably going to be faster on average, actually, although i haven't benched it
19:24:58 <aristid> because the time library is not very well optimized?
19:25:11 <mm_freak> that calculation alone drops the performance from 100m FPS to below 100k FPS
19:25:28 <aristid> i read about formatTime being extremely slow, to the point where the http server boys created a http-date library
19:25:34 <aristid> or rather, kazu
19:25:42 <jmcarthur> mm_freak: do the causal commutative arrow optimizations apply to netwire?
19:25:54 <aristid> mm_freak: 100mm FPS?
19:25:56 <mm_freak> jmcarthur: if you use arrow style, yes
19:26:03 <mm_freak> aristid: 100 million FPS
19:26:04 <aristid> mm_freak: you're kidding, right? 100mm? oO
19:26:21 <aristid> mm_freak: that'd be like 30 cycles per frame?
19:26:22 <jmcarthur> aristid: i assume that's without actually rendering anything
19:26:24 <mm_freak> aristid: you get that performance with netwire 3 already
19:26:36 <mm_freak> aristid: composition is very cheap
19:26:37 <aristid> jmcarthur: of course
19:26:45 <jmcarthur> aristid: given that i find it quite unsurprising
19:26:47 <JoshTriplett> If I turn a Haskell function into a FunPtr using a foreign import ccall "wrapper", and that Haskell function throws an exception, what happens?
19:27:11 <mm_freak> JoshTriplett: safest to try it out…  anything might happen
19:27:13 <jmcarthur> JoshTriplett: good question
19:27:14 <aristid> jmcarthur: well i guess the whole thing fits into cache
19:27:33 <edwardk> JoshTriplett: aliens land and the invasion begins
19:27:33 <JoshTriplett> mm_freak: That's not a comforting answer. :)
19:28:01 <mm_freak> JoshTriplett: yeah…  if you want to be sure, catch exceptions in the outermost layer =)
19:28:05 <mm_freak> of the handler that is
19:28:21 <JoshTriplett> mm_freak: Sounds like I need to, yeah.  Just wondered what would happen. :)
19:28:28 <aristid> mm_freak: did you measure if the bottleneck is realToFrac, or diffUTCTime?
19:29:09 <mm_freak> aristid: not really, but i'll write a quick benchmark…  i think the realToFrac is the main problem
19:30:14 <jmcarthur> realToFrac is always a problem :\
19:30:22 <aristid> :t realToFrac
19:30:25 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
19:30:35 <jmcarthur> @src realToFrac
19:30:36 <lambdabot> realToFrac = fromRational . toRational
19:30:40 <danil> JoshTriplett: according to the Report it's undefined and you're supposed to catch it inside the exported function
19:30:41 <jmcarthur> ^^ that's the problem
19:30:49 <JoshTriplett> danil: Good to know.
19:30:57 <JoshTriplett> Meanwhile, I managed to find a bug in ghci. :)
19:31:17 <aristid> jmcarthur: that involves an usually unnecessary GCD, right?
19:31:18 <JoshTriplett> Typing in a foreign import ccall "wrapper" declaration at the prompt causes a linker error.
19:31:33 <mm_freak> aristid: main bottleneck is 'diffUTCTime'
19:31:37 <JoshTriplett> ...oh, right, ghc trac is on hackage, which is down. :(
19:31:43 <jmcarthur> mm_freak: wha-? :)
19:31:45 <mm_freak> aristid: realToFrac is secondary, but still a noticable bottleneck
19:31:50 <aristid> hah
19:32:01 <aristid> time library might use some optimization love
19:32:05 <hpaste> “Ertugrul Söylemez” pasted “diffUTCTime benchmark” at http://hpaste.org/73001
19:32:09 <mm_freak> see paste
19:32:09 <danil> JoshTriplett: however, it appears that GHC provides a TopHandler module to register handlers for such things--hard to see what it does with hackage down though.
19:32:11 <Jafet> Maybe it has to handle leap seconds
19:32:40 <mm_freak> if i don't force 'dt' there the benchmark completes in 10 ms
19:32:46 <mm_freak> with dt it completes in 750 ms
19:32:55 <mm_freak> with dt, without realToFrac it needs 650 ms
19:33:36 <mm_freak> additional note:  deepseq on 't' results in 350 ms
19:34:00 <mm_freak> but i guess that's really just the expense of forcing, not the actually time query
19:34:13 <avpx> Are there pure ways of doing error handling that work well with laziness? Either-based approaches have the problem that to get any values you have to know if the computation succeeded or not.
19:34:32 <mm_freak> avpx: what would that look like?
19:34:40 <mm_freak> perhaps an example application
19:35:23 <Jafet> timeout can't possibly be pure
19:35:33 <jmcarthur> avpx: the only way i know of is to have a way to include error information *within* your output data structure so that you can start reading it before you are done with the possibly-failing computation
19:36:34 <mm_freak> avpx: perhaps you want coroutines
19:36:40 <mm_freak> avpx: see the monad-coroutine package
19:36:53 <avpx> I would.
19:36:57 <jmcarthur> avpx: for example, instead of Either e [a], you could have ListT (Either e) a
19:37:02 <aristid> mm_freak: hmm the bottleneck must be utcTimeToPOSIXSeconds
19:37:06 <aristid> http://hdiff.luite.com/cgit/time/tree/Data/Time/Clock/POSIX.hs
19:37:32 <_e`> hello all , i was reading the conversation you all seem to know how to turn the computer on so i have a question
19:37:37 <jmcarthur> where ListT is the "done right" version, i think
19:38:03 <avpx> jmcarthur: That seems reasonable
19:38:06 <_e`> im trying to ping my notepad command ping notepad.exe -n 1 -l 1
19:38:10 <mm_freak> avpx: coroutines allow you to have a failable computation that can report values early
19:38:11 <_e`> i cant get no result
19:38:17 <_e`> i dont know how far i am
19:38:20 <_e`> for my notepad
19:38:26 <_e`> please help me
19:38:28 <jmcarthur> _e`: this is certainly the wrong channel for this
19:38:32 <mm_freak> _e`: sorry, we're not knowledgable in that regard…  try #notepad
19:38:38 <Jafet> You need to add notepad.exe to your hosts file.
19:38:51 <avpx> mm_freak: That sounds like what I'm talking about
19:38:54 <_e`> :(
19:38:57 <mm_freak> Jafet: that's as mathematical as an answer could get =)
19:39:03 <roconnor> #notepad is a real channel
19:39:24 <Jesin> what
19:39:27 <_e`> i will try to ping Jaak
19:39:36 <aristid> roconnor: do you imply mm_freak would direct people to non-existent channels?
19:39:37 <_e`> ping Jaak -l 1 -s 1 -d 1
19:39:41 <_e`> :(
19:39:42 <jmcarthur> _e`: stop
19:39:45 <_e`> dont work for me
19:39:48 <_e`> never nothing
19:39:50 <roconnor> aristid: :/
19:39:56 <aristid> lol
19:40:16 <mm_freak> _e`: would you mind trying to compose trolling components into a single line?
19:40:29 <_e`> :\
19:40:32 <_e`> 8)
19:40:34 --- mode: ChanServ set +o jmcarthur
19:40:52 <avpx> I was thinking you could have data Result err val = Result {getErr :: Maybe err, getVal :: val}
19:40:56 <_e`> >)
19:40:58 --- kick: _e` was kicked by jmcarthur (_e`)
19:41:11 <mm_freak> avpx: you can't really report values early with that
19:41:17 <mm_freak> still only at the end
19:41:26 <nand`> mm_freak: “>) ∘ 8) ∘ :\ ∘ never nothing ∘ dont work for me” ?
19:41:31 <mm_freak> laziness might help there, but then you're building thunks unnecessarily
19:41:38 <mm_freak> nand`: wrong category =)
19:41:54 <mm_freak> i wonder what 'id' would be for 'Troll'
19:42:01 <avpx> mm_freak: I guess not, because to compose two of these computations, you would need to know the error value?
19:42:08 <nand`> the category where morphisms point from one state of trolledness to another
19:42:14 <avpx> I suppose it runs into the same problem as Either
19:42:18 <mm_freak> avpx: that's really just Writer, btw
19:42:25 <aristid> nand`: what is the dual category?
19:42:45 <avpx> mm_freak: Hmm, well, I guess it is
19:42:45 <mm_freak> avpx: i'd use monad-coroutine
19:42:46 <startling> mm_freak: a silent one
19:42:56 <avpx> mm_freak: I'll look into it when Hackage is up again
19:43:48 <nand`> mm_freak: id would be not trolling :)
19:43:59 <mm_freak> nand`: not trolling further =)
19:44:01 <JoshTriplett> ...that's fascinating.
19:44:10 <JoshTriplett> So, as it turns out, Haskell somehow propagates the exception.
19:44:12 <nand`> same thing. trolling once followed by not trolling is the same as trolling once
19:44:20 <JoshTriplett> Who knows what state it leaves C in, though.
19:44:40 <mm_freak> JoshTriplett: if it propagates, that means the RTS handle's the case
19:44:43 <mm_freak> JoshTriplett: so it's probably safe
19:44:48 <mm_freak> but i wouldn't count on that
19:44:52 <aristid> nand`: sounds almost like a Kleisli arrow?
19:45:03 <mm_freak> nand`: now you're in another category
19:45:03 <JoshTriplett> mm_freak: Yeah, but it also suggests that the C function that called the callback went through the equivalent of longjmp.
19:45:06 --- mode: jmcarthur set -o jmcarthur
19:45:19 <JoshTriplett> mm_freak: Which would potentially leave it in a state where it didn't get to perform any cleanup.
19:45:23 <danil> JoshTriplett: what order does the handler and the rest of the C code execute in?
19:45:38 <mm_freak> JoshTriplett: i highly doubt that exceptions are implemented in terms of setjmp/longjmp
19:45:40 <danil> it could be that the exception just sets a flag for the RTS to look at later when it passes the Haskell boundary
19:45:41 <JoshTriplett> Good question; finding out.
19:45:46 <JoshTriplett> mm_freak: Hence "the equivalent of".
19:45:58 <mm_freak> probably the sound equivalent of =)
19:45:58 <JoshTriplett> mm_freak: I mean that the C code likely got aborted in the middle.
19:46:07 <nand`> aristid: kleisli endomorphisms in the “Troll” monad; on the unit type perhaps
19:46:18 <mm_freak> JoshTriplett: i guess the best answer is to look at the source of the RTS
19:47:04 <JoshTriplett> danil: The remaining C code does not run.
19:47:12 <JoshTriplett> danil: So no, it doesn't set a flag.
19:47:21 <mm_freak> i'm fascinated that Troll is an actual category
19:47:23 <aristid> nand`: maybe it's really just a Monoid?
19:47:24 <nand`> mm_freak: I'm not sure how this is distinct from the first category I gave; the action of trolling is the morphism that points from one state of being trolled to another here
19:47:37 <mm_freak> where objects are states of trolling and arrows are transitions
19:47:42 <mm_freak> possible transitions rather
19:47:57 <nand`> aristid: yes, troll actions are monoids with respect to composition as sequencing; they can be composed in any order
19:48:04 <aristid> mm_freak: this is a very #haskell discussion
19:48:24 <mm_freak> aristid: of course it is…  in fact i could come up with a trolling monad =)
19:48:25 <nand`> I heard it's hard to troll #haskell
19:48:26 <nand`> maybe this is why
19:48:27 <aristid> nand`: i don't think troll actions are commutative though
19:48:38 <nand`> aristid: monoids are commutative?
19:48:44 <mm_freak> nand`: #haskell can be trolled, but you have to know haskell to do it =)
19:48:53 <aristid> nand`: no.
19:48:57 <avpx> Is trolling associative?
19:49:00 <nand`> exactly; or what did you mean?
19:49:05 <mm_freak> avpx: yeah
19:49:09 <startling> avpx: composing trolls is
19:49:11 <nand`> avpx: sequencing is always associative; you're basically using the free monoid here
19:49:15 <aristid> nand`: but if trolling was commutative, we could get a stricter class
19:49:20 <danil> I'm not sure if trolling is associative; we seem to care where the linebreaks are
19:49:21 <JoshTriplett> danil, mm_freak: I just tested it, and you can't actually catch the exception.  Looks like it just aborts the program with that exception.
19:49:25 <nand`> the free monoid under the set of trolls
19:49:32 <mm_freak> come on guys, i'm almost falling off my chair =)
19:49:33 <startling> does haskell do tail-call optimization ???
19:49:42 <mm_freak> startling: no
19:49:50 <aristid> mm_freak: don't wake up the poor neighbors! it's almost 5 am after all
19:49:51 <nand`> [troll a], [troll b]; identity is [] and trolling in sequence is [troll a, troll b]
19:49:54 <avpx> startling: How do I shot in webs monad?
19:49:55 <mm_freak> startling: it doesn't need to =)
19:50:12 <mm_freak> but i guess you're just demonstrating how to troll #haskell =)
19:50:33 <startling> mm_freak: what do you mean it doesn't need to? How are all these functions supposed to be efficient?
19:50:41 <startling> ;)
19:50:41 <mm_freak> JoshTriplett: yeah, that's quite plausible actually
19:50:44 <parcs`> @protontorpedo
19:50:44 <lambdabot> so haskell is free?
19:50:55 <nand`> ”trolling #haskell” tends to be synonymous with “abusing #haskell's goodwill” when it comes to providing explanations
19:51:04 <mm_freak> hehe
19:51:10 <nand`> you can waste a fair chunk of somebody's time by bringing up eg. kan extensions and asking the same questions over and over
19:51:14 <avpx> Can I use categories to speed up my C++ code???
19:51:24 <aristid> JoshTriplett: i think c++ code, when there is a boundary where it can't propagate exceptions anymore, invokes abort() or equivalent
19:51:27 <edwardk> nand`: =P
19:51:36 <mm_freak> it's still funny how the troll's intent backfired and caused an educational discussion =)
19:51:45 <nand`> FSVO ‘educational’
19:51:53 <startling> mm_freak: maybe it succeeded ?
19:51:57 <mm_freak> "FSVO"?
19:51:58 <aristid> nand`: damn you for thinking the exact same words i thought
19:52:01 <avpx> Maybe that troll was in fact, one of us... Trying to promote ourselves via this discussion
19:52:02 <aristid> for some value of
19:52:18 <nand`> it's my favorite acronym
19:52:26 <mm_freak> nand`: it demonstrated a new type of category at least for me =)
19:52:27 <avpx> I like WOLOG
19:52:37 <nand`> mm_freak: true, for me too
19:52:41 <aristid> nand`: my thoughts were _literally  "for some value of educational discussion" and bam you had already written it
19:52:46 <mm_freak> but actually it might be just a poset category
19:52:52 <mm_freak> yeah, it's a poset category
19:53:11 <mm_freak> where the relation is "can go from to"
19:53:17 <nand`> ‘poset category’ meaning? morphisms can only go in ‘one direction’?
19:53:29 <mm_freak> hmm
19:53:34 <mm_freak> actually you're right
19:53:37 <mm_freak> it's not a poset category
19:54:11 <avpx> nand`: What about the identity morphism?
19:54:12 <aristid> mm_freak: isn't the troll monoid pretty close in nature to just the list of troll actions?
19:54:25 <mm_freak> aristid: dunno, i didn't propose it
19:54:31 <nand`> oh, there's another restriction on poset categories: there can only be one morphism between each pair of objects (which implies the former)
19:54:41 <mm_freak> aristid: but yeah, perhaps a weighted set instead of a list
19:54:43 <nand`> avpx: yeah good point, see my revised definition
19:54:54 <avpx> Hooray, I said something meaningful about category theory!
19:54:57 <avpx> \o/
19:55:18 <mm_freak> nand`: i think loops are also disallowed except for identity morphisms
19:55:24 <nand`> hmm, though I'm suddenly not sure if my definition is conclusive either
19:55:25 <nand`> yeah
19:55:32 <aristid> mm_freak: so if you somehow interpret that as a category with your magic wand of category theory, wouldn't it necessarily be a well-known type of category?
19:55:39 <teneen> Is there a standard way to read a file of numbers separated by spaces into an IOUArray or STUArray?
19:55:58 <mm_freak> aristid: dunno, if every possibility has been exhausted
19:56:10 <mm_freak> teneen: no, but in a list
19:56:17 <mm_freak> teneen: why into a mutable array?
19:56:33 <Jafet> You need to know how many numbers there are
19:56:58 <teneen> mm_freak: because I'm using a function which uses a mutable array
19:57:22 <teneen> Jafet: assume I know it
19:57:23 <mm_freak> teneen: your own?
19:57:36 <teneen> mm_freak: yes
19:57:42 <mm_freak> teneen: then my question still stands
19:57:50 <mm_freak> why a mutable array?
19:58:02 <teneen> mm_freak: for learning purposes
19:58:11 <mm_freak> not to learn haskell i hope =)
19:58:17 <mm_freak> anyway, you have to go through a list
19:58:23 <mm_freak> then use newListArray
19:58:39 <mm_freak> or use the 'vector' library, which allows you to do without an intermediary list
19:58:45 <nand`> mm_freak: no, I think loops are impossible with just the restriction I gave, because a loop would (since composition is total), eventually give rise to a isomorphism somewhere
19:58:59 <teneen> mm_freak: I assume lists are not efficient here, are they? Is a ByteString better in this situation?
19:59:02 <nand`> thus breaking the restriction that each pair of objects have at most one morphism
19:59:30 <mm_freak> nand`: true
19:59:32 <Jafet> ByteString is a list of Word8
19:59:50 <dmwit> So partition (`elem` set) map is O(n log n). Can I make a function with the same behavior that takes O(n) time without hacking the original implementations of Data.Map and Data.Set?
19:59:51 <mm_freak> teneen: most likely the list is never constructed at all
19:59:52 <aristid> nand`: so it's kind of like an increment-only number, where the increments are the morphisms?
19:59:57 <mm_freak> teneen: lists are a control structure in haskell
20:00:06 <leoncamel> anybody can give me a mirror of hackage ? I need several packages now.
20:00:11 <nand`> aristid: more or less. the canonical example is ≤
20:00:34 <jmcarthur> :t partition (`elem` set) map
20:00:35 <lambdabot> Not in scope: `set'
20:00:46 <edwardk> dmwit: you're doomed
20:00:49 <dmwit> :t \set map -> M.partition (`S.elem` set) map
20:00:50 <lambdabot> Couldn't find qualified module.
20:01:01 <nand`> aristid: basically, it guarantees antisymmetry (a < b and b < a can never hold)
20:01:02 <aristid> nand`: turns out a non-negative increment and a <= relation are closely related things for numbers :)
20:01:04 <dmwit> edwardk: Okay, I'll use the slow version, then.
20:01:09 <nand`> which, in this case, the arrow of time is
20:01:14 <nand`> it can never point backwards
20:01:16 <Jafet> dmwit: toList gives you a sorted list
20:01:30 <dmwit> Jafet: ...ah, perfect
20:01:35 <Jafet> (obviously)
20:01:35 <dmwit> I'm not doomed!
20:01:45 <teneen> mm_freak: I think it will have to be constructed anyways and this is costly. I think you mean it will be garbage collected and not stay in memory.
20:02:14 <aristid> dmwit: but edwardk said you're doomed, you can't escape that so easily
20:02:41 <dmwit> =D
20:02:43 <edwardk> =)
20:02:44 <Jafet> He means this problem is so easy that you'll have time for Doom
20:03:09 <edwardk> well its O(n) to walk the toList and logarithmic in the side of the set, no?
20:03:09 <mm_freak> teneen: likely it won't, and even if it will, only a single element of the list will likely be in memory
20:03:20 <dmwit> edwardk: use toList on both the set and the map
20:03:26 <mm_freak> teneen: so the list imposes an O(1) factor slowdown that you'll hardly notice
20:03:28 <dmwit> edwardk: then use an O(n) walk
20:03:29 <edwardk> fair nuff
20:04:10 <aristid> dmwit: a zip-like walk which pairs up equal elements?
20:04:16 <edwardk> do you need the result as a list or as two maps?
20:04:27 <dmwit> I guess reconstructing the map on the other end is still O(n log n), though. So actually now I believe not only am I doomed by the API, I'm doomed by "it's not possible even hacking the internals".
20:04:32 <Jafet> fromAscList is linear time
20:04:41 <edwardk> no, fromDistinctAscList is O(n)
20:04:47 <teneen> mm_freak: Is hGetArray by any means useful in my situation?
20:04:51 <dmwit> Oh, great.
20:05:10 <dmwit> That's actually a bit surprising to me.
20:05:13 <edwardk> i don't recall how it gets away with that, but it claims to
20:05:18 <Jafet> It doesn't
20:05:24 <Jafet> You have to give it an asclist
20:05:33 <aristid> why doesn't Data.Map have a zip-like function?
20:05:42 <dmwit> I guess one pass computes the length, and then you know right away how to balance it correctly.
20:05:46 <edwardk> jafet: re the balacing more than the sorting
20:06:00 <edwardk> yeah it does 2 passes
20:06:01 <edwardk> thats how
20:06:04 <dmwit> makes sense
20:06:09 <Jafet> Okay, that's pretty crap
20:06:20 <edwardk> you can do it in one pass though, just get a skewed looking tree ;)
20:06:35 <edwardk> its a common microsoft interview question
20:06:38 <Jafet> But Map is strict anyways, so the extra space is a Constant Factor
20:07:16 <edwardk> http://hbfs.wordpress.com/2012/01/03/building-a-balanced-tree-from-a-list-in-linear-time/
20:07:50 <mm_freak> teneen: i'd recommend not using arrays at all as far as possible
20:08:12 <shachaf> aristid: interectionWith (,)?
20:08:26 <teneen> mm_freak: Ok thanks
20:08:34 <dmwit> edwardk: essentially foldb?
20:08:41 <dmwit> Why doesn't Data.Map use that? =P
20:08:55 <Jafet> You can't foldb a list in one pass
20:09:02 <dmwit> You don't need to.
20:09:15 <jmcarthur> i like arrays, just not mutable arrays
20:09:17 <dmwit> You just need to make sure each pass only touches half as many elements. =)
20:09:35 <aristid> shachaf: that answers my question but not what i was looking for:)
20:09:46 <dmwit> I guess it still qualifies as two total passes then, though, since 1 + 0.5 + 0.25 + ... = 2
20:09:53 <aristid> shachaf: i also want elements that are not in both maps
20:10:06 <dmwit> Anyway. This seems pretty good. Thanks for the help.
20:10:29 <edwardk> luite++
20:15:30 <shachaf> aristid: OK, but that won't have the type you want, I think.
20:16:38 <aristid> shachaf: i want something like (k -> Maybe a -> Maybe b -> c) -> Map k a -> Map k b -> Map k c
20:17:06 <shachaf> aristid: Maybe you just want [Map k a] -> Map k [a]?
20:17:25 <aristid> shachaf: no
20:17:37 <aristid> shachaf: i want the types to be different
20:18:13 <shachaf> OK, Map k a -> Map k b -> Map k (These a b)?
20:18:43 <aristid> where These has three constructors: Left A | Right B | Both A B?
20:18:46 <shachaf> Good ol' These.
20:18:55 <shachaf> data These a b = This a | That b | These a b
20:19:01 <aristid> nice type
20:19:05 <shachaf> preflex: xseen cmccann
20:19:05 <preflex>  cmccann was last seen on freenode/#haskell 146 days, 1 hour, 16 minutes and 24 seconds ago, saying: was kinda sad how easily the same joker could troll /r/lisp though, they just kept encouraging him
20:19:06 <aristid> yeah exactly that :)
20:19:22 <mm_freak> ok, the Data.Sequence-based average works well
20:19:27 <startling> how do I run haddock on some code of mine, to make sure that my doc comments parse?
20:19:31 <shachaf> What's going on with cmccann?
20:19:32 <aristid> mm_freak: hoiw much slowdown?
20:20:43 <edwardk> mm_freak: can you think of any use of verlet style or leapfrog style integration for frp?
20:20:44 <aristid> shachaf: damn you this is giving me an idea. too bad i can't implement it now that it's 5 am :D
20:20:57 <hpaste> “Ertugrul Söylemez” annotated “FRP: Average wire” with “Using Data.Sequence instead of vectors” at http://hpaste.org/73000#a73002
20:21:08 <shachaf> aristid: Oh, ideas are good!
20:21:12 <mm_freak> aristid: not measureable
20:21:19 <aristid> mm_freak: awesome
20:21:26 <mm_freak> edwardk: not familiar with those
20:21:27 <edwardk> basically time shifting the update of the derivatives by half a timestep
20:21:49 <edwardk> it makes them vastly more stable but requires no more function evaluations
20:21:58 <edwardk> mm_freak: http://en.wikipedia.org/wiki/Leapfrog_integration
20:22:14 <mm_freak> aristid: the only thing i'm concerned about with Data.Sequence is the increased memory usage
20:23:20 <mm_freak> edwardk: again i'm not sure how to incorporate this into the instant-based FRP
20:23:47 <startling> okay, I've got a haskell file with haddock annotations. running haddock mything.hs tells me about haddock coverage; how do I generate an html file from it?
20:24:13 <edwardk> mm_freak: page 9 of http://www.cs.toronto.edu/~radford/ftp/ham-mcmc.pdf shows a better motivation for why you want to use it over updating both on the same timestep boundaries
20:24:42 <aristid> shachaf: the idea you inspired: https://github.com/aristidb/kv-agda/commit/c440069a7d5ae5ed118a3a398bc7d2e8475acb6c :D
20:24:44 <dmwit> startling: You want an HTML file with the coverage information in it?
20:24:48 <edwardk> basically the idea is you simulate t for half a timestep and then simulate the delta from there to avoid instabilities
20:24:55 <aristid> shachaf: OneOrBoth is exactly the These type
20:24:55 <startling> dmwit: I want an html file of the docs
20:25:12 <dmwit> startling: You should have that already, unless haddock printed some errors out.
20:25:22 <Jurily> cabal install --enable-documentation
20:25:30 <edwardk> mm_freak: i'm going to have to write code to demonstrate this aren't i? =)
20:25:39 <dmwit> Yes, the easiest way is to cabalize it. But it doesn't hurt to learn how to use the tool on its own. =)
20:25:54 <startling> I got a "Warning: could not find link destinations for: ..."; no actual errors
20:26:02 <startling> (and no html file)
20:26:16 <dmwit> Did you not get a new directory?
20:26:21 <jmcarthur> the best way to explain an idea is by uploading a package to hackage ;)
20:26:28 <startling> dmwit: correct
20:26:52 <Jurily> jmcarthur: that explains so much about the current state of hackage...
20:26:56 <edwardk> basically the issue is before you update both on the same timer, the error blows up, if you stagger them, you can change the asymptotics of the error produced
20:27:09 <roconnor> how do I configure something like snap to only bind to localhost (so that it isn't accessable over the network)?
20:27:27 <aristid> jmcarthur: when it isn't down
20:27:27 <edwardk> roconnor: look at the admin pages for the server, iirc they do that
20:27:49 <roconnor> admin pages?
20:27:50 <avpx> modifySTRef Jurily succ
20:27:50 <edwardk> i think they bind to everything but they then drop it if it comes in remotely
20:28:05 <edwardk> mightybyte sent me a link at somepoint for it, because i needed it for the arcade
20:28:16 <startling> dmwit: oh, giving it --html gets them
20:28:17 <startling> heh
20:28:33 <roconnor> arcade?
20:28:47 <edwardk> a toy project of mine that happens to embed snap
20:29:04 <dmwit> startling: heh
20:29:09 <edwardk> it was why i wrote lens ;)
20:29:18 <roconnor> lens?
20:29:20 <roconnor> :P
20:29:36 <edwardk> i built a tiny lens library inside it, then decided to expand on it
20:29:43 <startling> what's the format of mark-up in hackage comments?
20:29:50 <edwardk> startling: haddock
20:29:50 <mm_freak> edwardk: likely =)
20:29:54 <aristid> and now it's the most massive lens library on hackage
20:29:54 <startling> edwardk: heh
20:30:02 <startling> how do I make a bulleted list?
20:30:08 <edwardk> aristid: i have a bad tendency to do that
20:30:16 <dmwit> startling: Start two new lines, then use * foo
20:30:17 <aristid> edwardk: i don't complain
20:30:20 <dmwit> Just like markdown.
20:30:35 <edwardk> startling: http://www.haskell.org/haddock/doc/html/ch03s08.html
20:30:49 <mm_freak> edwardk: my main priority is to get netwire released…  the numerical stability of the calculus wires is sufficient for non-simulations
20:31:13 <edwardk> mm_freak: fair enough. i may spend some time seeing if i can build a small frp implementation that uses leapfrog or velocity verlet
20:31:20 <mm_freak> edwardk: for simulations i would probably write a separate module anyway with slower, but more numerically stable wires
20:31:39 <edwardk> it makes a HUGE difference
20:31:43 <mm_freak> edwardk: i don't think you have to reinvent the wheel…  you could just build it on top of netwire
20:31:56 <edwardk> i could, but when did i ever do that? =)
20:32:13 <edwardk> honestly just want to build a playground for the idea
20:32:18 <edwardk> probably won't release anything
20:32:21 <edwardk> (famous last words)
20:32:23 <mm_freak> edwardk: well, you would be reinventing netwire without inhibition =)
20:32:47 <mm_freak> i.e. you would be reinventing poor old yampa =)
20:32:51 <edwardk> =P
20:33:17 <mm_freak> also i think that netwire 4 will match your soundness standards…  it's based on many of your libraries anyway ;)
20:33:22 <edwardk> heh
20:33:33 <hpaste> “Joey Adams” pasted “"multiplex" a Mealy machine” at http://hpaste.org/73004
20:33:35 <edwardk> i'm not against building on netwire
20:33:46 <edwardk> i just don't know what the solution space looks like yet
20:34:04 <JoeyA> ^ Is there a general variant of or utility library providing the code I posted above?
20:34:09 <mm_freak> yeah, true…  there should be something like free arrows
20:34:22 <edwardk> i know the general shape of the problem, and what is needed to apply a second order method like leapfrog, just haven't bolted it into the frp vocabulary yet
20:34:53 <edwardk> muahahaha my mealy machines will take over the world
20:35:16 <mm_freak> Wire is more powerful than Mealy =P
20:35:23 <JoeyA> But Mealy machines are self-aware.
20:35:28 <edwardk> JoeyA: we have basically that same thing coded up around here somewhere
20:35:38 <aristid> wires are self-inhibiting
20:35:43 <edwardk> JoeyA: i didn't say they'd give me control of the world once they took it, just that they'd take it over
20:35:48 <edwardk> thats why wires will never take over the world
20:35:53 <JoeyA> :-)
20:35:55 <mm_freak> JoeyA: "self-aware"?
20:35:56 <edwardk> they will be at the mercy of my machines
20:36:03 <mm_freak> JoeyA: Wire is generalized Mealy
20:36:34 <edwardk> mm_freak: generalized for multiple consumption and production?
20:36:53 <edwardk> and the addition of some time thingy?
20:36:57 <mm_freak> edwardk: the model is:  newtype Wire e (>~) a b = Wire (a >~ (Either e b, Wire e (>~) a b))
20:37:16 <mm_freak> it was exactly that in netwire 2
20:37:44 <mm_freak> in netwire 3 it's a data family…  in netwire 4 it's an associated type with time added as an additional argument
20:37:45 <edwardk> fair nuff
20:38:07 <edwardk> the netwire 2 rep is pretty close to something we've used here in the past
20:38:30 <mm_freak> yeah…  the only problem is that netwire 2 was highly inefficient
20:38:57 <edwardk> yep
20:39:01 <mm_freak> because of the representation that is
20:39:02 <edwardk> same problem here ;)
20:39:13 <edwardk> ergo past
20:39:18 <mm_freak> hence the data family in netwire 3 and the AT in netwire 4 =)
20:39:45 <danharaj_> I miss hackage :[
20:40:02 <edwardk> one generalization is that you can parameterize it, and then make a and b GADTs to get typed messages
20:40:29 <mm_freak> well, the main point was to be able to provide Alternative
20:40:41 <mm_freak> type Event e (>~) = forall a. Wire e (>~) a a
20:41:20 <mm_freak> that's what makes netwire so powerful actually
20:41:48 <mm_freak> i think netwire is my baby in the same way lens is yours =)
20:42:12 <edwardk> the difference is that i'll probably give my baby up for adoption in a couple of months ;)
20:42:37 <mm_freak> and make a new one? ;)
20:42:46 <edwardk> i hear roconnor is a good foster parent
20:43:49 <mm_freak> well, i have planned to base a number of projects on netwire, so it will be my baby for the foreseeable future
20:43:59 <edwardk> fair nuff
20:44:12 <edwardk> i just want to pop the stack and get back to working on the physics lib that motivated lens
20:44:14 <mm_freak> in particular i will pick up webwire again and turn it into a serious project (probably based on snap or WAI)
20:44:25 <roconnor> oh man
20:44:46 <roconnor> edwardk: you will need to explain your action nonsense first :D
20:44:50 <aristid> roconnor: you didn't know yet you'll be foster parent?
20:44:53 <edwardk> roconnor: hahhaha
20:44:58 <edwardk> what about them?
20:45:07 <roconnor> aristid: there are only about 4 choices, maybe less
20:45:14 <roconnor> edwardk: what are the laws?
20:45:17 <edwardk> roconnor: honestly i wasn't planning on dumping it on your lap
20:45:27 <edwardk> they are kleisli arrows, same laws as kleisli composition
20:45:28 <aristid> roconnor: choices for what?
20:45:41 <edwardk> a monadic fold is a kleisli arrow in ContT
20:45:42 <roconnor> edwardk: so they are just getters that are kleisli?
20:45:45 <edwardk> yes
20:45:48 <roconnor> hmm
20:45:52 <edwardk> and they compose with regular getters
20:45:57 <roconnor> well, I guess getters appears to be lawless
20:46:09 <edwardk> getters have laws, they are the same laws as for functions ;)
20:46:13 <roconnor> aristid: for maintaining lenses
20:46:24 <edwardk> which is pretty much 'it works' ;)
20:46:26 <startling> how do I point haddock at a directory tree of modules?
20:46:27 <shachaf> What are the function laws?
20:46:41 <roconnor> edwardk: kleisli arrows have even fewer laws than functions.
20:46:51 <edwardk> sure
20:46:52 <roconnor> shachaf: same input -> same output ?
20:47:34 <edwardk> x ~ y => f x ~ f y
20:47:54 <roconnor> edwardk: woah now
20:47:58 <edwardk> and that composition is associative
20:48:10 <edwardk> i deliberately didn't write == in there
20:48:23 <turiya> hi all
20:49:09 <edwardk> roconnor: anyways actions are just kleisli arrows you can mix with other getters
20:49:17 <roconnor> right
20:49:34 <edwardk> and if you mix them with folds you get a 'monadic fold' which basically is looping in contT and gluing together with the monoid
20:49:47 <roconnor> edwardk: and the composition is in the same orders as actions occur?
20:49:54 <edwardk> yep
20:50:00 <edwardk> left to right like with getters
20:50:11 <roconnor> I think I'm going to stop using functions and just use getters
20:50:15 <edwardk> =)
20:50:36 <turiya> when i do "randomVector 10 Gaussian 10", I get an error "fromList Bus error". I am using the hmatrix library. A quick search in google gives pages with similar question but no solutions. Does anybody know what is going on?
20:50:46 <edwardk> they give you the ; you always wanted
20:50:47 <shachaf> type a ~> c = Getter a c
20:51:00 <edwardk> shachaf: illegal syntax =(
20:51:12 <shachaf> Oh, right.
20:51:12 <edwardk> needs moar :
20:51:23 <danil> turiya: in ghci or compiled?
20:51:30 <aristid> ::::~> - enough :?
20:51:34 <danharaj> too bad 'from' isn't the inverse to 'to' :P
20:51:34 <turiya> danil: ghci
20:51:50 <shachaf> type a :▷ c = Getter a c
20:51:57 <edwardk> aristid: could use a few more
20:52:07 <aristid> edwardk: supply is getting low
20:52:11 <nand`> type a → c = Getter a c -- ?
20:52:13 <edwardk> danharaj: i thought really really hard about that
20:52:16 <nand`> oh, still needs :
20:52:20 <aristid> shachaf: that looks like a laughing mouth
20:52:29 <edwardk> i almost stole to from getters and gave it to iso
20:52:35 <danharaj> to = id? :P
20:52:44 <shachaf> aristid: It's laughing at you for using that syntax.
20:52:50 <shachaf> Don't use that syntax.
20:52:51 <nand`> to = from
20:52:52 <edwardk> danharaj: yes, but it also injects polymorphisms
20:52:54 <roconnor> danharaj: everything in lens is just an alias for id
20:52:57 <aristid> shachaf: which syntax? oO
20:53:16 <roconnor> %%~ = id
20:53:18 <danharaj> roconnor: an obvious sign that lens is theoretically sound
20:53:22 <nand`> would let you use whichever word you want based on what makes more sense in the wording
20:53:32 <roconnor> traverse = id
20:53:38 <nand`> traverseOf*
20:53:38 <edwardk> my wife just called me 'the wizard of id'
20:53:39 <danharaj> edwardk: Can you add indexed versions of all the Fold and Traversal *Of's?
20:53:42 <roconnor> er right
20:53:44 <shachaf> roconnor: Hey, now, some things are const!
20:54:00 <turiya> danil: it works when compiled..
20:54:00 <edwardk> danharaj: i added most of them
20:54:03 <shachaf> And maybe there's an occasional const id.
20:54:08 <danharaj> ah ok, I haven't checked since hackage went down.
20:54:09 <edwardk> danharaj: but i left off the ones that don't takea  function
20:54:19 <edwardk> danharaj: http://ekmett.github.com/lens/
20:54:26 <edwardk> mirrored docs
20:54:42 <danharaj> edwardk: those should work on Indexed* anyway, right? maybe you should add them as aliases for uniformity?
20:54:43 <edwardk> ifoldrOf, imapMOf_, etc.
20:55:06 <edwardk> iallOf :: IndexedGetting i All a c -> (i -> c -> Bool) -> a -> Bool
20:55:07 <edwardk> makes sense
20:55:15 <edwardk> iandOf ? what does it do?
20:55:22 <nand`> “getters are just const” <- would be an unfortunate typo for “getters are just Const”
20:55:35 <JoshTriplett> Does a standard type exist for an error indicator without a parameter?  Something like Either () () without the silliness of the ()s.
20:55:41 <danharaj> mm good point
20:56:02 <edwardk> i basically spent about 12 hours adding the ones that are there
20:56:07 <danharaj> :O
20:56:23 <nand`> JoshTriplett: if you don't mind going blind, Bool
20:56:27 <edwardk> i even snuck in your ifiltered
20:56:33 <JoshTriplett> nand`: Exactly my problem, yes. :)
20:56:36 <danharaj> thanks :P
20:56:44 <danil> turiya: apparently it's a known bug: https://github.com/albertoruiz/hmatrix/issues/2 (ghci only, 64-bit platforms only)
20:56:55 <nand`> but I guess you could make your own; data Error = Success | Fail | FileNotFound
20:57:07 <JoshTriplett> nand`: *clap* *clap*
20:57:16 <aristid> nand`: that's Boolean, not Error
20:57:17 <turiya> danil: i see, thanks
20:57:58 <JoshTriplett> aristid: Oh, good point.  Presumably it should be data Error = Success | Fail | B Bool, as the symmetric type for data Bool = True | False | FileNotFound. :)
20:58:22 * aristid rotates head 90 degrees
20:58:57 <shachaf> edwardk: Just prefix all your types with forall (~>). ((~>) ~ Getter).
20:59:22 <shachaf> > let foo :: forall i. i ~ Int => i -> i; foo = (+1) in foo 5
20:59:23 <lambdabot>   6
20:59:27 <edwardk> shachaf: dangerous. spj has mentioned he'd like to reclaim the use of operators in types, so its not a good idea to bind them
20:59:51 <edwardk> of course then i can just make Getter = ~>
20:59:56 <danharaj> what wizardry does spj want to do with them?
21:00:09 <edwardk> allow you to use any operator as a type operator sans the : prefix
21:00:16 <edwardk> and just disallow binders for them
21:00:37 <edwardk> it'll make mm_freak sad, rewrite a lot of the arrow code out there, and it caused me to rewrite categories, but its a good idea
21:00:49 <danharaj> what do you mean disallow binders?
21:00:54 <danharaj> What's a binder?
21:01:03 <edwardk> forall (~>). a ~> b
21:01:26 <edwardk> \x ->    the lambda and forall are binders they bind (~>) and x respectively
21:01:35 <danharaj> ah, I see.
21:02:00 <edwardk> the notion is to disallow using type level binders to bind operators to eliminate the need for the concept of a 'lowercase symbol' at the type level
21:02:14 <edwardk> and then you can use type (+) = Either
21:02:15 <edwardk> etc
21:02:21 <danharaj> That would be pretty nice.
21:02:24 <edwardk> yeah
21:02:32 <aristid> yet a rather breaking change
21:02:47 <edwardk> http://comments.gmane.org/gmane.comp.lang.haskell.glasgow.user/21350
21:02:53 <danharaj> It doesn't break haskell98 code does it?
21:02:57 <dmwit> ?index catMaybes
21:02:58 <lambdabot> Data.Maybe
21:02:58 <danharaj> So it breaks no code ;)
21:03:00 <edwardk> haskell 98 doesn't have typeoperators
21:03:15 <nand`> I want my A×B = (A,B)
21:03:26 <edwardk> nand`: this gives you that
21:03:39 <nand`> proceed as planned
21:03:53 <edwardk> type (×) = (,)
21:03:58 <shachaf> Type-level $, too?
21:04:06 <danharaj> ew $
21:04:09 <shachaf> And .?
21:04:17 <nand`> edwardk: and ∘ for composing functors?
21:04:18 <edwardk> yes again to the $
21:04:40 <edwardk> who needs (.) to compose functors just compose their setters and the result is a setter ;)
21:08:15 <nand`> you do some type acrobatics with composed functors in category-extras, don't you?
21:08:27 <edwardk> lots of things
21:13:59 <broombs> any way to factor out the 'a' in 'f a <|> g a'...as in '(f <|> g) DESIREDOP a' ?
21:14:12 <shachaf> liftMa (<|>) f g?
21:14:20 <shachaf> Er.
21:14:22 <shachaf> liftA2
21:14:26 <shachaf> I'm not sure how that came out
21:14:30 <shachaf> @pl \f g a -> f a <|> g a
21:14:30 <lambdabot> liftM2 (<|>)
21:17:22 <aristid> any reason against instance Alternative a => Alternative (b -> a)?
21:17:45 <aristid> i mean in general, not for adding an orphan instance here
21:18:39 <shachaf> Alternative (b -> a)?
21:18:41 <shachaf> Does that kind-check?
21:19:04 <aristid> i mean Alternative ((->) a))
21:19:41 <shachaf> ?
21:19:56 <shachaf> What's the instance you're talking about?
21:20:11 <aristid> const empty, liftA2 (<|>)
21:22:53 <broombs> shachaf: any way to generalize liftM2 to liftMn, for arbitrary n?
21:23:09 <shachaf> broombs: f <$> a <*> b <*> c <*> d ...
21:23:10 <aristid> broombs: <$> and <*>
21:23:51 <shachaf> aristid: I'm not sure what you mean.
21:24:05 <aristid> shachaf: nevermind. i need to sleep now.
21:24:21 <broombs> shachaf, aristid: I mean a generalization to f1 a <|> f2 a <|> f3 a <|>....<|> fn a
21:24:31 <jfischoff> @hpaste
21:24:31 <lambdabot> Haskell pastebin: http://hpaste.org/
21:24:55 <aristid> :t choice
21:24:56 <lambdabot> Not in scope: `choice'
21:24:59 <shachaf> broombs: foldr (<|>) empty . map ($ a) $ [f1,f2,f3]?
21:25:19 <hpaste> “Jonathan Fischoff” pasted “Who am I” at http://hpaste.org/73005
21:25:27 <aristid> :t sequence [(+1), (+2)]
21:25:28 <lambdabot> forall a. (Num a) => a -> [a]
21:25:35 <aristid> > sequence [(+1), (+2)] 4
21:25:37 <lambdabot>   [5,6]
21:25:58 <jfischoff> goes anyone know what existing type has a monoid instance like that ^
21:26:14 <hpaste> “Jonathan Fischoff” annotated “Who am I” with “Who am I (annotation)” at http://hpaste.org/73005#a73006
21:28:07 <MostAwesomeDude> Aw, Hackage's still down? :c
21:28:27 <shachaf> jfischoff: edwardk has one in Control.Lens
21:28:36 <mm_freak> JoeyA: as a side note your 'multiplex' combinator for Mealy is predefined in netwire
21:28:44 <jfischoff> shachaf: what's it called?
21:28:47 <mm_freak> it's called 'context' there and is even more general =)
21:29:03 <JoshTriplett> @pl \e b -> handle (\(SomeException _) -> e) b
21:29:04 <lambdabot> (line 1, column 33):
21:29:04 <lambdabot> unexpected "_"
21:29:04 <lambdabot> expecting operator or ")"
21:29:16 <JoshTriplett> That's fascinating.
21:29:23 <shachaf> jfischoff: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Action.hs#LC82
21:29:32 <shachaf> Hmm, no, that has an extra parameter.
21:29:38 <shachaf> So it's not exactly what you wanted.
21:29:43 <JoshTriplett> Is lambdabot *supposed* to do that?
21:29:50 <JoshTriplett> Because that seems wrong.
21:30:06 <shachaf> But it's pretty close.
21:30:15 <JoshTriplett> In any case, the question I had hoped to get an answer to: does the following function have a name? \e b -> handle (\(SomeException _) -> e) b
21:30:16 <shachaf> JoshTriplett: @pl can't do pattern-matching
21:30:21 <JoshTriplett> shachaf: Ah.
21:30:25 <edwardk> jfischoff: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Action.hs#L87
21:30:30 <edwardk> oh shachaf beat me there
21:30:46 <jfischoff> oh killer
21:31:05 <jfischoff> I planned on depending on Control.Lens anyway
21:31:12 <edwardk> iirc both reducers and monoids also provide it somewhere
21:31:20 <jfischoff> ah
21:40:55 <JoeyA> mm_freak: Thanks.  I'm implementing my own Auto for now, to introduce myself to the idea.
21:40:56 <hpaste> cleantc pasted “explicit forall” at http://hpaste.org/73007
21:41:12 <mm_freak> ok, have fun =)
21:41:30 <JoeyA> Implementing (.) (in Category) was particularly enlightening.
21:41:45 <JoeyA> Namely, you have two automata, and you want to chain them together.
21:41:53 <JoeyA> When a value is sent through, both automata are updated.
21:42:11 <JoeyA> You want to consider this chain, as a whole, as a single automaton.
21:42:23 <tgeeky> head-to-tail or ass-to-ass?
21:43:24 <JoeyA> tgeeky: I don't quite understand what you mean, but that seems very inappropriate.
21:43:40 <tgeeky> JoeyA: it's a half-joke.
21:44:09 <tgeeky> I mean, you're talking about an pair of snakes, one of which is eating the other's tail
21:44:19 <tgeeky> or, a pair of snakes, tied at the tail, both eating
21:45:06 <tgeeky> apologies for offending, though. I'm not even sure if snakes have asses.
21:45:07 <JoeyA> No, ->  ->
21:45:15 <cleantc> why does it (http://hpaste.org/73007) pass without the explicit forall but not with one? doesn't Haskell quantify over free type variables in the signature?
21:45:31 <shachaf> "pass"? "not"?
21:45:43 <shachaf> "it fails the typechecking" isn't a GHC error message.
21:46:04 <shachaf> Anyway, the reason is that you're using ScopedTypeVariables.
21:46:19 <shachaf> So the inner a is referring to the outer a, instead of being polymorphically bound at g's ::.
21:46:29 <shachaf> Try adding a second forall for g.
21:47:53 <cleantc> shachaf: for using  ScopedTypeVariable I have to add an explicit forall in the top level signature?
21:49:58 <slack1256> somebody could name a library that utilize arrows in a elegant and simple manner?
21:50:16 <slack1256> hxt seemed to complex to me to see some real world usage.
21:50:16 <Jurily> bow?
21:50:17 <danil> cleantc: no, but if you do use an explicit forall in f's signature it will bind the 'a' in g's signature
21:53:34 <cleantc> danil: and if I don't use an explicit forall in f's signature, haskell doesn't automatically add one? It's a top-level definition
21:54:16 <tgeeky> cleantc: this is probably one of those cases where just trying each combination of using a forall in both (inner,outer) typesigs
21:54:31 <tgeeky> is a reasonable route
21:54:42 <turiya> is there a way to do contour plotting in Gnuplot in Haskell. In the original gnuplot the splot command is a tool to do contour plotting but I could not find its equivalent in haskell. does anybody know?
21:54:44 <danil> cleantc: it does generalize the type, but it doesn't bind any scoped type variables
21:55:06 <danil> cleantc: otherwise turning on the extension would break a lot of haskell98 code
21:55:11 <Cale> ScopedTypeVariables only applies when there's an explicit forall quantifying the variable
21:55:30 <cleantc> oh I see, makes sense
21:56:34 <cleantc> Thanks!
21:57:29 <saiko-chriskun> what's up with hackage
21:57:54 <MostAwesomeDude> Network maintenance.
22:01:18 <jfischoff> Cale: is using Multiplate admitting defeat, or in your opinion, is a good way to avoid to explicit recursion?
22:02:51 <Cale> Multiplate is a tool for avoiding writing some of the worst explicit recursion :)
22:03:51 <jfischoff> Cale: it definitely feels like a step forward :)
22:04:19 <MostAwesomeDude> Multiplate? Is this like Uniplate but betteR?
22:04:19 <jfischoff> are you implying in some cases its possibly to do better?
22:04:30 <tgeeky> MostAwesomeDude: it's differenter
22:04:31 <mm_freak> jfischoff: a way to go without having to define folding combinators
22:05:00 <jfischoff> MostAwesomeDude: its a generalization
22:05:27 <jfischoff> mm_freak: what would a example of the folding combinators approach be?
22:06:17 <jfischoff> MostAwesomeDude: Uniplate is pretty dope, because it is so easy to use. But Multiplate is more widely applicable
22:06:29 <MostAwesomeDude> Interesting.
22:07:06 <jfischoff> MostAwesomeDude: works mutually recursive types beyond what the little used Biplate can handle
22:07:41 <tgeeky> MostAwesomeDude: http://arxiv.org/abs/1103.2841
22:07:42 <MostAwesomeDude> jfischoff: I see. IME Biplate has been sufficient, but that's an interesting concept.
22:08:12 <tgeeky> MostAwesomeDude: Multiplate is N-Biplate
22:08:38 <tgeeky> or maybe a sum over biplates?
22:08:42 <jfischoff> MostAwesomeDude: if Uniplate works then I don't know if there is a reason to use Multiplate instead.
22:09:06 <jfischoff> tgeeky: maybe n-plate?
22:10:55 <tgeeky> jfischoff: yeah. I was thinking that each of the fields of a multiplate is paramterized over an applicative functor
22:10:59 <MostAwesomeDude> @hoogle (Integral a) => a -> a -> (a, a) -- divmod?
22:10:59 <lambdabot> Parse error:
22:11:00 <lambdabot>   (Integral a) => a -> a -> (a, a) -- divmod?
22:11:00 <lambdabot>                                    ^
22:11:01 <tgeeky> but they are all paramterized over the same applicative functor
22:11:02 <MostAwesomeDude> @hoogle (Integral a) => a -> a -> (a, a)
22:11:02 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
22:11:02 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
22:11:03 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
22:11:08 <MostAwesomeDude> There it is.
22:11:10 <startling> ugh hackage. :(
22:11:30 <startling> what can I do to help fix hackage?
22:11:34 <tgeeky> jfischoff: so, yep :o
22:11:38 <startling> toss some dollars in some direction?
22:12:02 <MostAwesomeDude> Well, if I knew how to make a Hackage mirror, I'd totally push my bosses into hosting one.
22:12:08 <MostAwesomeDude> But I don't know if it's possible.
22:12:25 <YayMe> startling: Hackage just wants to be loved..
22:12:26 <startling> lots of people are saying things like that; anyone know for sure?
22:12:28 <jfischoff> tgeeky: to be honest, I know very little of the internals of Multiplate even having read the paper (most of it). I'll come back to after using it some more, I'm getting curious about how it works
22:12:30 <mm_freak> jfischoff: foldr
22:12:33 <mm_freak> maybe
22:12:34 <mm_freak> either
22:12:35 <mm_freak> etc.
22:12:39 <mm_freak> there are many folding combinators
22:12:49 <Jurily> MostAwesomeDude: remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
22:13:09 <Jurily> it's possible :)
22:13:12 <mm_freak> all have this property:  foldr (:) [] = id, maybe Nothing Just = id, either Left Right = id
22:13:44 <tgeeky> startling: I have read similar things, and I don't think it's just an issue of money. I agree that it's probably mostly an issue of responsibility (not that the current maintainer is not responsible, but the next maintainer must be also, and we don't have that person yet)
22:13:55 <tgeeky> but it's hurting the haskell community
22:13:58 <MostAwesomeDude> Jurily: I work for the OSL; we don't mind and are pretty responsible dudes.
22:14:06 <startling> tgeeky: indeed
22:15:04 <YayMe> tgeeky: responsibility can be bought
22:15:18 <YayMe> for a sum I've been responsible for large portions of software before
22:15:18 <startling> MostAwesomeDude: ontario soccer league? open shading language? oslo airport? oncology systems limited?
22:15:22 <Jurily> I'm currently in love with the Exherbo/Paludis package management
22:15:26 <tgeeky> YayMe: sure, but not for what we pay Russ or whoever maintains it now :o
22:15:27 <MostAwesomeDude> startling: osuosl.org
22:16:04 <YayMe> tgeeky: right, but maybe startling is right; maybe just throwing money at people to be responsible for it is the solution
22:16:08 <startling> MostAwesomeDude: oh neat
22:16:14 <MostAwesomeDude> Very.
22:16:14 <YayMe> if responsibility is after all what you're looking for
22:16:41 <YayMe> granted, a lot more people would have to throw a lot more money at them
22:16:49 <jfischoff> do we really need hackage? Why cabal install from use github, darcs den, etc?
22:17:01 <YayMe> does hackage have an office donations page?
22:17:17 <YayMe> so/office/official
22:17:17 <startling> jfischoff: I think you a word
22:17:43 <jfischoff> startling: yes, I meant why not get cabal install to use github, etc.
22:17:52 <startling> jfischoff: ah
22:18:10 <startling> it could just be a dumb database with git and darcs urls
22:18:25 <Jurily> jfischoff: that's exactly what paludis is doing
22:18:33 <Jurily> it's awesome
22:18:44 <jfischoff> Jurily: how far along is he?
22:18:52 <jfischoff> is it patch?
22:19:03 <startling> would be cool if someone would write an emacs docs viewer
22:19:20 <Jurily> it's Exherbo Linux's package management
22:19:48 <YayMe> alright, it is sooo time for me to pass out..
22:19:50 <YayMe> later folks
22:20:21 <Jurily> http://paludis.exherbo.org/overview/features.html
22:20:33 <cleantc> when I load "class D a where c :: Eq a => Int" in GHCi it typechecks but when I use query for the of type of its method ":t c" it returns an error that "Ambiguous type variable `a0' in the constraints". Why does it typecheck in the first place? is it possible to resolve that ambiguity?
22:21:01 <cleantc> *the type of
22:21:26 <Jurily> did you mean "c :: Eq a => a -> Int"?
22:22:24 <cleantc> Jurily: no
22:22:36 <cleantc> "c :: Eq a=>Int"
22:23:12 <cleantc> in fact that would be " c :: (D a , Eq a) => Int"
22:23:42 <mm_freak> what's the space complexity of Data.Map?  O(n * log n)?
22:23:47 <obk> @pl (\x -> (x, []))
22:23:48 <lambdabot> flip (,) []
22:24:40 <Jurily> cleantc: what is 'a' in c's definition?
22:25:52 <cleantc> Jurily: a is the typeclass parameter. I understand there is an ambiguity, wondering why GHC accepts it
22:35:30 <pharaun> hello, i don't know if this is a dumb question, but can i use partial application/currying to loop through a list of values and apply it to a data constructor?
22:37:06 <edwardk> pharaun: e.g. you have [x,y,z] and want Vector x y z ?
22:37:59 <pharaun> ya
22:39:03 <edwardk> pharaun: then no ;)
22:39:20 <edwardk> the types change as you move through the list, so its pretty ugly
22:39:40 <pharaun> then is there a good way of dealing with this?
22:40:07 <pharaun> i have a list that is ~56 item long
22:40:15 <pharaun> i don't want to be manually shuffling that around
22:40:28 <Veinor> ... why are you trying to call a function with 56 arguments? what kind of function is that?
22:41:14 <pharaun> a large records... record, basically i got a 7 byte bit flag for all related data, and i am parsing and breaking it up into one element per flag
22:41:26 <pharaun> and 8bit * 7 bytes = 56 :[
22:42:21 <pharaun> tl;dr i'm parsing a custom protocol that will return "X data" that you request it via a 7 byte bitflag
22:42:35 <edwardk> if you have something with 56 entries, it probably shouldn't be fields in a constructor ;)
22:43:05 <pharaun> its the fastest way i can think of dumping all 56 entry into a large records
22:43:22 <pharaun> which i can then get the relevant entry or what so not
22:43:33 <edwardk> why do you need a huge record of 56 fields rather than a couple of combinators for the corresponding entries
22:43:35 <startling> so I'm pretty consistently passing around these two parameters to lots of lots of functions. Is there where I use the state or reader monad?
22:43:44 <edwardk> startling: yep
22:43:52 <pharaun> edwardk: combinators?
22:43:54 <startling> yayyyy, time to further my education
22:44:38 <pharaun> edwardk: its like a movie db, where i get a huge row of data related to a single movie
22:45:01 <edwardk> pharaun: example;  data Foo = Foo { _fooFlags :: Int64 }; makeLenses ''Foo; flag31 = fooFlags.bitAt 31
22:45:10 <edwardk> myFoo^.flag31
22:45:14 <edwardk> (using lens)
22:45:18 <edwardk> but you don't need lenses for this
22:45:56 <pharaun> that would work for getting the value of what each flag is, ie 0 vs 1
22:46:19 <edwardk> flag31 .~ True $ myFoo -- will let you update it as well
22:46:29 <pharaun> but in this case say i send "0b1010" as the flag, i will get back "data1|data3"
22:47:32 <edwardk> so what is the problem with that?
22:47:48 <pharaun> that will be useful for setting/getting the flag value :) i'll save that to my todo, but how would i like map between the flag and the data in a useful manner. i was going to just bit shift through the flag - 0b1010, and return a list like [data1, Nothing, data3, Nothing[
22:47:57 <edwardk> IntMap YourData  pass around the data in that
22:48:29 <pharaun> oh so i pass around the returned data, then the flag, and do that kind of lens/map
22:48:33 <pharaun> to map from the flag to the data
22:48:41 <edwardk> yes
22:48:48 <edwardk> no 56 argument constructor need apply
22:48:52 <pharaun> yes
22:48:55 <pharaun> that's much better idea
22:49:35 <edwardk> you can read the elements of the map using the map lookup functions or Data.IntMap.Lens
22:49:38 <edwardk> e.g.
22:49:44 <edwardk> myMap^.at 31
22:49:52 <edwardk> will give you Nothing or Just the data
22:50:23 <pharaun> sweet \o/
22:51:33 <edwardk> =)
22:51:45 <danharaj> What conditions would you need on the Applicative to make a parallel traversal?
22:51:50 <danharaj> (a sensible one)
22:52:34 <pharaun> edwardk: i felt like there had to be a better solution than the 56 argument constructor thing but couldn't think of one
22:52:38 <pharaun> edwardk: <3 thanks
22:52:41 <edwardk> np
22:53:01 <edwardk> just make the applicative do the traversal in parallel ;)
22:53:21 <danharaj> edwardk: well you'd want deterministic results if the applicative is effectful :P
22:53:25 <edwardk> also note there exists parOf, etc. in Control.Parallel.Strategies.Lens which can help
22:54:03 <edwardk> but thats more about forcing parts of your lensed structure
22:54:08 <edwardk> not the applicative accumulation of answers
22:55:14 <startling> is there a way I can simplify SomeFn <$> v <*> v <*> v <*> v <*> v <*> v <*> v <*> v ?
22:55:18 <edwardk> but ultimately applicatives are pretty good at parallel accumulation
22:55:39 <edwardk> startling: liftA7  probably doesn't exist
22:56:14 <edwardk> yours _is_ the simplification ;)
22:56:29 <startling> alright. just wondering if I could simplify repeated application to the same value
22:56:55 <startling> dunno how that would work really, but I don't know how lots of things would work. :)
23:00:03 <hpaste> startling pasted “Can I simplify this?” at http://hpaste.org/73009
23:00:08 <startling> ^ any ideas?
23:00:28 <startling> I'm new to the reader monad, so I'm not sure if this is how I'm supposed to use it
23:00:31 <mm_freak> is there an abstraction that allows mapping as well as a "length" query?  for lists it would be (length, map)
23:00:57 <startling> mm_freak: you can get length from Foldable
23:01:00 <mm_freak> length should be explicit so that i can make use of O(1) length queries for certain data structures
23:01:05 <startling> ah
23:01:06 <mm_freak> startling: not the 'length' i want =)
23:01:30 <startling> yeah. I wrote a typeclass for that once.
23:02:10 <mm_freak> ok, i'll just expect the length function as an argument then
23:02:20 <TotallyWorthIt> h
23:02:37 <Veinor> data Thing = Top | Bottom | Left | Right
23:02:37 <mm_freak> ello
23:02:41 <Veinor> what's the word i want to use for Thing?
23:02:48 <startling> waiiit, typeclasses get desugared to the reader monad?
23:02:52 <startling> essentially?
23:02:55 <mm_freak> Veinor: Edge
23:02:56 <edwardk> mm_freak: there is a CanLength in the 'classy prelude' but thats about it
23:03:13 <startling> Veinor: Quark
23:03:14 <mm_freak> edwardk: uh, i don't want to depend on an alternative prelude
23:03:22 <Veinor> startling: haha
23:03:27 <edwardk> mm_freak: i don't recommend it either
23:03:27 <mm_freak> startling: there is a left quark?
23:03:38 <edwardk> but ultimately, no, there isn't a standard sized class you can use
23:03:49 <startling> mm_freak: no, just reminded me of their names
23:04:02 <mm_freak> edwardk: doesn't have to be standard…  i'm happy to add a dependency, as long as it makes sense
23:04:19 <startling> Veinor: obvious solution is to change Left and Right to Strange and Charm
23:04:51 <edwardk> mm_freak: how many types do you need this for?
23:04:58 <edwardk> and will it be something you expose?
23:05:25 <danharaj> I have a strong feeling this snippet could be greatly simplified: http://hpaste.org/73010
23:05:27 <mm_freak> edwardk: i want to write a "count to percentage" wire:  Wire e (>~) (f a) (f Double)
23:05:51 <mm_freak> for that one i need length/size/magnitude/whatever
23:06:34 <mm_freak> of course it's hylo, but i'd like to get along with map/length so that it can be efficient =)
23:07:29 <danharaj> any ideas?
23:08:44 <edwardk> wow, i just realized my brain can't parse code with ^$'s ;)
23:08:57 <danharaj> :3
23:09:53 <edwardk> why the ('s) in (to Sum . _const) ^$
23:10:06 <edwardk> (or after)
23:10:10 <Veinor> oh man! i think this code would be a good use case for lenses
23:10:22 <edwardk> Veinor: ?
23:10:22 <Veinor> but... i can't cabal-install lens because hackage is down :(
23:10:36 <Veinor> edwardk: the BSP tree roguelike dungeon generation thing i mentioned a while ago
23:10:38 <edwardk> Veinor: you can set up hdiff as a cabal source
23:10:45 <shachaf> Veinor: git clone https://github.com/ekmett/lens.git
23:10:46 <danharaj> edwardk: I don't follow
23:10:52 <pharaun> data.lens ?
23:10:54 <danharaj> oh the parens.
23:11:03 <danharaj> No reason at all.
23:11:04 <edwardk> pharaun: 'lens' not 'data-lens'
23:11:22 <edwardk> Veinor: add remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive to your ~/.cabal/config
23:11:25 <edwardk> and cabal update
23:11:28 <edwardk> then pull lens ;)
23:11:40 <danharaj> well, if hackage were up :P
23:11:43 <edwardk> that should hold you over til hackage is back up
23:11:44 <danharaj> oh
23:11:46 <danharaj> the secret hackage
23:11:49 <edwardk> yes
23:12:04 <Veinor> \o/
23:12:04 <edwardk> as 900 people go crash luite's server
23:12:08 <danharaj> haha
23:12:19 <edwardk> sorry luite!
23:12:49 <pharaun> poor luite
23:13:14 <edwardk> danharaj: ok, let me take a whack at it
23:13:45 <mm_freak> what's a good short word for "percentage"?
23:13:52 <Veinor> but basically, a lot of this code is going to involve 'okay, take this room, and set the right edge to this'
23:13:52 <danharaj> %
23:13:52 <mm_freak> or "probability"?
23:13:58 <Veinor> mm_freak: pct? prob?
23:13:59 <danharaj> chance?
23:14:30 <mm_freak> hmm…  something that resembles an "occurence percentage" would be more suitable
23:15:02 <edwardk> the traverseGrid withIndex stuff can be replaced with imapOf
23:15:33 <edwardk> smooth k g = imapOf go g
23:15:41 <edwardk> and you can ditch the pure in go
23:15:52 <edwardk> next lets see
23:16:41 <startling> is there an infix operator for flip fmap somewhere?
23:16:56 <startling> I seem to use it pretty commonly for lambdas
23:17:04 <edwardk> startling: nope
23:17:10 <startling> darn
23:17:24 <edwardk> i've wanted it from time to time myself
23:17:27 <edwardk> likewise $>
23:17:39 <edwardk> (that latter one i at least include in comonad
23:17:45 <edwardk> because its important to wfix
23:17:52 <startling> @pl flip fmap ask $ \x -> y
23:17:53 <lambdabot> fmap (const y) ask
23:18:01 <startling> @pl flip fmap ask someFn
23:18:02 <lambdabot> fmap someFn ask
23:18:06 <Jurily> (<**>) :: Applicative f => f a -> f (a -> b) -> f b
23:18:08 <shachaf> (ask <$>) $ (\x -> y)
23:18:23 <shachaf> (<**>) is different.
23:18:38 <startling> shachaf: that's just as bad as flip fmap
23:18:49 <edwardk> hrmm your  messy inner traverseSubGraph stuff looks like it can be an ifoldMapOf using Sum
23:18:51 <shachaf> startling: No, it's much nicer.
23:19:31 <danharaj> edwardk: sweet. So I take it my structure isn't bad, it's just that there are already combinators that represent that structure?
23:19:42 <startling> :t flip fmap ask $ \x -> y
23:19:44 <lambdabot> forall a (f :: * -> *). (Functor f, MonadReader a f) => f Expr
23:19:49 <startling> :t (ask <$>) $ (\x -> y)
23:19:51 <lambdabot> forall t. (Functor ((->) t)) => t -> Expr
23:20:01 <edwardk> well, you lean pretty heavily on manually using traverseFoo `withIndex` where you probably shouldn't ;)
23:20:10 <startling> shachaf: I don't think they're the same?
23:20:11 <edwardk> and you use that hideous ^$ combinator ;)
23:20:32 <danharaj> edwardk: I am a left-endian when it comes to lenses :P
23:21:25 <danharaj> I lean on the 'withIndex' wrapping because I have some traversals that need to unwrap another traversal and give it extra information about the final argument, then wrap it up again in a traversal. Developed a habit :P
23:22:08 <edwardk> @hpaste
23:22:09 <lambdabot> Haskell pastebin: http://hpaste.org/
23:22:44 <hpaste> edwardk annotated “poor nested traversal” with “poor nested traversal (annotation)” at http://hpaste.org/73010#a73011
23:23:00 <edwardk> i probably have some parens unbalanced
23:23:02 <edwardk> but thats the gist
23:23:45 <edwardk> actually that last line can be Sum (x * k^.cell i)
23:24:04 <Veinor> edwardk: this looks really neat so far
23:24:09 <hpaste> edwardk annotated “poor nested traversal” with “poor nested traversal (annotation) (annotation)” at http://hpaste.org/73010#a73012
23:24:31 <Veinor> my one complaint is the fact that i have to use bounds ^. top instead of top bounds, but i assume that's a tradeoff for something even nicer
23:25:28 <pharaun> edwardk: why is ^$ hideous?
23:25:35 <edwardk> Veinor: yeah. in exchange you can now update with top .~ new value $ container
23:25:47 <edwardk> Veinor: and you can use them to access part of the state monad
23:25:48 <edwardk> etc
23:26:15 <edwardk> do top.x .= 10; top.y = 20
23:26:19 <edwardk> or whatever your top is
23:26:22 <edwardk> er .=
23:26:51 <edwardk> pharaun: the precedence is so low it forces ()'s everywhere
23:27:07 <hpaste> callen pasted “Nonsensical Code” at http://hpaste.org/73013
23:27:08 <pharaun> edwardk: ah i see
23:27:13 <callen> so that returns a type error
23:27:15 <edwardk> ^. has very high precedence so you can chain it almost anywhere you can chain applications
23:27:19 <callen> I really just want to see the result of show temperatures
23:27:32 <callen> how do I make it stop throwing a type error long enough to see the intermediate data?
23:27:50 <edwardk> callen: replace the bad parts with 'undefined' and just go from there
23:27:58 <callen> well.
23:28:06 <callen> Couldn't match expected type `Maybe a0' with actual type `IO ()'
23:28:13 <callen> I don't see how undefined would help here.
23:28:38 <edwardk> then you probably have a lot of bad parts ;)
23:28:49 <startling> I'm confused about the reader monad. How do I put something into a Reader so I can pass it around?
23:28:57 <callen> I don't see how undefined would help here.
23:29:01 <callen> er, woops. sorry.
23:29:05 <callen> up-arrow bit me.
23:29:07 <startling> oh, I runReader it
23:29:08 <startling> got it
23:29:33 <edwardk> startling: the simplest reader monad is just (->) e. you can make a monad for functions themselves, and define, ask, asks, etc.
23:29:34 <callen> edwardk: I'm trying to destructure the XML into constituent data
23:29:52 <edwardk> callen: i don't know the haskell xml apis, sorry
23:30:00 <startling> callen: oh hi again
23:30:01 <callen> that's not even really the issue
23:30:07 <callen> I kinda sorta resolved the XML API issue
23:30:19 <callen> I just need this function to run just long enough for me to see intermediate data
23:30:22 <callen> startling: hi
23:30:34 <edwardk> but basically it sounds like you just need to do some case analysis on the results of something returning Maybe rather than just trying to use it directly
23:31:02 <callen> I'll just return a datum with bogus data and see if that shuts the fucker up.
23:31:04 <edwardk> and hence why i'm saying you should just replace the parts that don't typecheck with undefined.  pretty much from the second call on. ;)
23:31:29 <hpaste> edwardk annotated “Nonsensical Code” with “Nonsensical Code (annotation)” at http://hpaste.org/73013#a73014
23:31:52 <startling> edwardk: very cool
23:33:05 <callen> okay okay okay
23:33:11 <callen> why is the type IO ()
23:33:17 <callen> when the final expression is the data?
23:33:29 <callen> that hardly seems fair that the first expressions (putStrLn) takes over the whole type
23:33:34 <startling> callen: IO () means it doesn't return anything meaningful
23:33:38 <startling> callen: of course not
23:33:53 <startling> callen: where do you see an IO () ?
23:33:53 <pharaun> callen: get rid of putStrLn and debug in ghci, that's how i do it :)
23:34:24 <callen> pharaun: that's a lot of foundational data that I'd rather not reiterate to an alternate universe where I'm playing a game called, "whose scope is it anyway?"
23:34:39 <callen> startling: I found another issue, I'm fixing a typeclass thing now.
23:34:43 <edwardk> i left the undefined in at the end for a reason
23:34:50 <callen> edwardk: that didn't fix it mate.
23:35:06 <callen> well, it might've
23:35:10 <callen> but I have to fix the typeclass issue first.
23:35:21 <edwardk> what typeclass issue?
23:35:23 <startling> when is \case coming?
23:35:39 <callen> edwardk: I didn't derive show for my constituent destructuring of the XML
23:35:43 <pharaun> man the type check makes refactoring a snap :D
23:36:04 <Targen_> startling: 7.6.1 has it, I understand.
23:36:53 <edwardk> pharaun: first time writing haskell?
23:37:00 <edwardk> startling: 7.6.1
23:37:07 <edwardk> its in head iirc
23:37:35 <shachaf> http://spl.smugmug.com/Humor/Lambdacats/simon/965006902_kWLvY-O.jpg
23:37:37 <jfischoff> edwardk: why do you think Multiplate isn't used more, or is it?
23:38:02 * jfischoff has become very Multiplate focused
23:38:53 <edwardk> jfischoff: its pretty awkward to use
23:38:54 <pharaun> edwardk: "somewhat" i guess, i recently got into it a few month ago, thanks to xmonad, and have been working on a yesod app on the side, this is a new project and its fun :)
23:39:01 <hpaste> callen pasted “Typeclass Show error with bogus data” at http://hpaste.org/73016
23:39:13 <callen> edwardk: let us speak in the concrete, the above gives me the error:
23:39:21 <jfischoff> edwardk: compared to ..?
23:39:23 <callen> No instance for (Show Forecast) arising from a use of `show'
23:39:53 <hpaste> edwardk annotated “Typeclass Show error with bogus data” with “Typeclass Show error with bogus data (annotation)” at http://hpaste.org/73016#a73017
23:40:00 <edwardk> add those deriving clauses and try again
23:40:14 <danharaj> edwardk: If you would do one more look, this is a place where I think I need to use 'withIndex'. Is it necessary? http://hpaste.org/73015
23:40:17 <startling> callen: that's because you're trying to see the result of that
23:40:36 <startling> callen: Show is needed for ghci to show you anything
23:40:50 <edwardk> jfischoff: i mean that the terminology is odd, it can't change types since it isn't a multiplate family, etc
23:40:53 <danharaj> (nevermind the nested where that shouldn't exist)
23:41:55 <edwardk> danharaj: let me paste it into something i can hack up
23:42:07 <callen> edwardk: the derivations are complete, I am encountering a new and interesting type error.
23:42:21 <callen> Couldn't match expected type `Forecast' with actual type `m0 b0'
23:42:21 <callen>     Expected type: m0 t0 -> (t0 -> m0 b0) -> Forecast
23:42:22 <callen>       Actual type: m0 t0 -> (t0 -> m0 b0) -> m0 b0
23:42:38 <jfischoff> edwardk: do you think one could make a MultiplateFamily package?
23:42:44 <callen> startling: the typeclasses and derivations are probably one of the few things I do understand, haha.
23:42:47 <callen> sorta :(
23:43:08 <edwardk> jfischoff: i've been fiddling with one
23:43:20 <jfischoff> edwardk: I knew it!
23:43:42 <hpaste> callen pasted “Post derivation type error, maybe I don't understand the do monad?” at http://hpaste.org/73018
23:43:43 <Jurily> callen: try parseForecast :: Element -> IO Forecast
23:43:52 <jfischoff> edwardk: well hopefully the template haskell I
23:43:53 <jfischoff> m
23:44:08 <jfischoff> writing for Multiplate will transfer
23:44:12 <callen> Jurily: very interesting!
23:44:14 <callen> Jurily: Couldn't match expected type `IO t0' with actual type `Maybe Element'
23:44:29 <Jurily> callen: parseForecast :: Element -> IO (Maybe Forecast)
23:44:56 <callen> Jurily: Wedder.hs:66:19:
23:44:56 <callen>     Couldn't match expected type `IO t0'
23:44:58 <callen>                 with actual type `Maybe Element'
23:45:34 <startling> Maybe (IO Forecast) ?
23:45:51 <startling> oh wait
23:45:53 <edwardk> jfischoff: likely will
23:45:58 <Jurily> this would be a good time to talk about why we write function signatures before the code :)
23:46:00 <callen> no dice @ startling
23:46:05 <edwardk> i'm trying to be a little more finegrained than plates tend to be
23:46:13 <callen> Jurily: wouldn't help I am faceplanting into the code.
23:46:17 <startling> callen: so what's this function do?
23:46:19 <edwardk> notably i've been playing with using arrow notation to write plates
23:46:27 <callen> startling: do you really want to know?
23:46:30 <startling> callen: yes
23:46:32 <callen> startling: it's the destructuring of the XML
23:46:38 <callen> into constituent native data types
23:46:49 <callen> that will (a week from now) turn into JSON
23:46:59 <startling> callen: k. so, first step is add declarations for all the things you use
23:47:11 <Jurily> so the issue here is that you're using two different monads: IO and Maybe
23:47:30 <startling> callen: (queryGen and bogus)
23:47:40 <danbst> [Q] Hello guys. How can I reimplement `hGetContents` with `hGetChar`? I do not need semi-closing of the handle but I do need lazyness on stream reading.
23:48:03 <callen> I'll make a paste, h/o
23:48:07 <shachaf> danbst: [A] You need to use an unsafe operation.
23:48:26 <hpaste> callen pasted “better paste” at http://hpaste.org/73019
23:48:40 <jfischoff> edwardk: I have yet to try to write a more complex plate, all though thinking about how to create a maximal bounding box from a hierarchical tree of transforms was an interesting challenge.
23:48:51 <startling> callen: k. so what does :t queryGen give you?
23:49:03 <shachaf> danbst: You pretty much can't write it yourself, really.
23:49:07 <jfischoff> edwardk: so it is hard for me to imagine the need for arrows
23:49:11 <startling> callen: (comment out parseForecast for now)
23:49:17 <startling> or use undefined
23:49:18 <danbst> shachaf: oh, it's a pity
23:49:19 <shachaf> A proper implementation has to do with implementation details of Handles.
23:49:33 <callen> startling: no
23:49:37 <edwardk> jfischoff: it comes about from wanting finer grained plates
23:49:43 <callen> I don't have ghci open, I'm using runhaskell.
23:49:44 <edwardk> jfischoff: start with something simpler
23:49:47 <edwardk> Either
23:49:47 <shachaf> danbst: If you did, you would use unsafeInterleaveIO
23:49:59 <edwardk> (a -> f b) -> (c -> f d) -> Either a c -> f (Either b d)
23:50:17 <jfischoff> ok
23:50:34 <callen> startling: I need to know what the broken out tags look like
23:50:35 <jfischoff> wait..
23:50:39 <callen> startling: I need parseForecast to run
23:50:47 <danbst> shachaf: it is magic for me... I thought there is easy way to recur hGetChar...
23:50:55 <startling> callen: yes, this will get you there
23:50:58 <startling> callen: use ghci
23:51:07 <callen> goddamn tedious.
23:51:13 <jfischoff> edwardk: I see you want per constructor, right?
23:51:19 <pharaun> callen: please use ghci
23:51:20 <shachaf> danbst: The problem is that hGetContents gives you a magic String.
23:51:29 <callen> pharaun: I fired up shime, hold on.
23:51:35 <callen> startling: looking at it in shime
23:51:36 <shachaf> danbst: The pure action of forcing the tail of that string can cause the impure action of reading data from the file.
23:51:49 <startling> callen: k. what's the type of queryGen?
23:51:52 <danharaj> I still don't like the name plate :[
23:51:55 <jfischoff> edwardk: add the types are changing...
23:51:57 <danharaj> I also really don't like zipper.
23:52:00 <danharaj> And iteratee.
23:52:05 <danbst> shachaf: ah! Now I understand
23:52:12 <JunkBee> To do IO with haskell I need to understand monads?
23:52:13 <edwardk> jfischoff: you can do this for whole types rather than for the constructor but it is clearer for Either on a per constructor basis
23:52:14 <callen> startling: h/o, loading libraries.
23:52:17 <shachaf> JunkBee: No.
23:52:18 <startling> JunkBee: not at first
23:52:21 <shachaf> JunkBee: Look at the FAQ.
23:52:23 <shachaf> @where faq
23:52:23 <callen> it's stuck on XML for some reason.
23:52:23 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
23:52:26 <Jurily> JunkBee: ask callen
23:52:30 <startling> callen: odd
23:52:30 <jfischoff> danharaj: I don't like the the name plate either
23:52:33 <shachaf> JunkBee: It has an answer to that question. :-)
23:52:48 <callen> JunkBee: dude. you don't...just no.
23:52:52 <callen> JunkBee: don't follow my path.
23:53:01 <callen> JunkBee: go read a book. Maybe find a girlfriend. Maybe read a book on Haskell.
23:53:09 <callen> JunkBee: don't just dive in, whatever you do.
23:53:09 <edwardk> danharaj: your traverseSubGrid looks decent
23:53:11 <edwardk> traverseSubGrid r' = index $ \f g@(Grid b r a) -> withIndex (traverseCoords (coordinates (intersect r r'))) f g
23:53:15 <edwardk> is about the best i could do with it
23:53:26 <edwardk> but thats just mashing it around
23:53:26 <Jurily> one does not simply learn Haskell on a deadline
23:53:29 <edwardk> nothing fundamental
23:53:29 <JunkBee> callen: I am diving while I read
23:53:43 <danharaj> edwardk: thank you for the sanity check :)
23:53:43 <callen> JunkBee: I've been doing that, it's not a good idea.
23:53:52 <callen> Jurily: urghhurk ack
23:54:00 <JunkBee> callen: Yeah. It really slows down how fast you read ://
23:54:09 <startling> :t either
23:54:10 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:54:13 <callen> importing Text.XML.Light crashes my shime
23:54:16 <callen> I hate you all.
23:54:19 <callen> opening ghci
23:55:03 <pharaun> i don't know about other folks but a tip, i have my editor, and ghci open always
23:55:04 <startling> heh
23:55:11 <startling> me too
23:55:12 <pharaun> and when i am uncertain about something i try it out in ghci
23:55:20 <pharaun> and etc its really helpful
23:57:53 <startling> @pl either x x
23:57:54 <lambdabot> either x x
23:57:59 <startling> :/
23:58:08 <startling> is there a way to run a single function on both sides of an Either?
23:59:17 <callen> Prelude Text.XML.Light> :t queryGen
23:59:18 <callen> queryGen :: String -> QName
23:59:25 <callen> startling: ^^ why'd you waste my time with that?
23:59:31 <callen> startling: that's one of the most trivial parts of my code.
23:59:36 <callen> and nothing to do with the type error in that do block.
