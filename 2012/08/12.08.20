00:00:58 <zzing> bed thyme
00:03:05 <ddarius> ssbr-: You could build the unreleased versions and beta (alpha?) test.
00:04:11 <Daerim>  Soo..... On the topic of wasting #haskell's time, are there any examples of haskell being used in natural science, excluding CS and pure math?
00:04:12 <ssbr_> ddarius: I'd prefer to stick with things I'll be able to figure out how to do
00:04:38 <ssbr_> I don't think HUnit even has any support for this, so I'd have to hook them together as a first step. Unpleasant.
00:08:25 <Cale> Daerim: There are at least a handful of bioinformatics guys
00:10:57 <Cale> Daerim: http://malde.org/cgi-bin/mailman/listinfo/biohaskell
00:11:08 <Cale> Oh, http://biohaskell.org/
00:14:17 <Cale> Daerim: I've also noticed there appear to be a few libraries on Hackage related to high energy particle physics, but I haven't heard anything about what anyone was doing with them.
00:15:04 <nand`> oh wow, I *finally* fixed my issues re: encoding. Since HTTP used .Char8 to pack/unpack Strings, it mangled UTF8; the author of CouchDB probably saw this and thought he'd fix it by, yes, converting String to [Word8] via toEnum.fromEnum and then UTF8 decoding that
00:15:09 <nand`> hilarity ensues
00:15:51 <Cale> nand`: yeah, that used to be basically what you had to do
00:16:08 <Cale> Depending on when it was written...
00:16:10 <nand`> I fixed it by rewriting CouchDB to use ByteString for HTTP.. much better
00:16:26 <Daerim> Cale, I remember seeing something about Los Alamos doing a haskell Monte Carlo particle transport code, but then everything went quiet
00:17:55 <Cale> Daerim: hmm: https://github.com/losalamos/McPhD
00:18:15 <Daerim> Cale, but thanks!
00:19:15 <Cale> Daerim: The 'philox' branch of that project has changes from a month ago
00:19:29 <Daerim> Cale, yes that was probably it. I hadn't seen it was neutrinos only, which I probably why I didn't see it again
00:23:48 <Daerim> Cale, it's an interresting project though. Random number algorithms seem to be a traditional weak point for haskell. Or rather, hte price for purity seems particularly high in that case
00:25:09 <Cale> If you do it right, Haskell's a really nice language for talking about probability distributions in a methodical way.
00:28:01 <ion> Has anyone analyzed how long delays the garbage collection in GHC-compiled code can cause? I guess it should be safe to fly an RC airplane with Haskell code.
00:29:15 <Daerim> Hmm, how so?
00:30:19 <Cale> Daerim: You can form a monad of random variables, and by swapping out the implementation, either compute complete data about the probabilities of events, or sample from the distribution.
00:31:47 <Cale> A quick way to implement something like that is e.g. WriterT (Product Rational) []
00:33:43 <Cale> (usually together with something to take the lists of pairs of probabilities and values and collect things occasionally so that you don't get combinatorial explosion)
00:35:31 <Daerim> Cale, heh that actually looks like a very neat way of doing it. Probably not going to be blazing fast, but somewhat more elegant than the usual fortran mess
00:37:17 <Cale> But also, you can use a monad which just consists of computations for sampling, Oleg has something written about this here: http://okmij.org/ftp/Computation/monads.html#random-var-monad
00:38:26 <Cale> But it's also embodied in QuickCheck, there's a Gen monad for random generation used to generate the parameters to the properties that you're testing.
00:40:17 <bitrust> Hello! newb question here: how/where do I get GHC 7.6?
00:40:36 <hpc> @where ghc
00:40:37 <lambdabot> http://haskell.org/ghc
00:40:46 <hpc> hmm, not there
00:40:53 <Cale> That hasn't been released yet
00:41:14 <Cale> SOON
00:41:26 <hpc> http://www.haskell.org/ghc/dist/stable/dist/
00:41:32 <Cale> There is a release candidate
00:41:40 <Cale> http://www.haskell.org/ghc/dist/7.6.1-rc1/
00:41:45 <bitrust> Ah, that will work for now
00:41:57 <bitrust> Yes I'm aware it's not out yet
00:43:01 <bitrust> Cale: Thanks, that list even has bins for Mac.
00:48:10 <Daerim> Cale, the Oleg article was very interresting, thanks!
01:05:13 <machty> hey, this question is utterly subjective, but what do you guys consider to be some of the most innovative/mindbending/killerapp/whatever applications of haskell that you've discovered in recent time?
01:05:42 <nand`> category-extras
01:12:49 <timthelion> Is there a standard image library with automatic codec detection(for jpg,png,bmp,and the other common formats?  Or do I have to depend on 10 different libraries just to get image support?)
01:13:19 <nand`> I remember some being able to do this but you still have the issue of conflicting pixel formats, so you had to case/of those manually
01:14:28 <timthelion> you don't know the name of the library though?
01:14:29 <typoclass> timthelion: you could try juicypixels, it was kinda nice. i didn't use it very extensively, though
01:14:35 <qnikst> timthelion: imagemagick, but it's GPL
01:14:40 <timthelion> typoclass: I'll try it.
01:14:53 <timthelion> qnikst: does imagemagick have anything to do with haskell?
01:15:43 <qnikst> there is a bindinds himage (afaik), and I'm trying to make another bindings lib (that will be more safe)
01:16:19 <timthelion> interesting.
01:16:25 * hackagebot websockets 0.6.0.4 - A sensible and clean way to write WebSocket-capable servers in Haskell. (JasperVanDerJeugt)
01:16:28 * hackagebot js-good-parts 0.0.7 - Javascript: The Good Parts -- AST & Pretty Printer (SeanSeefried)
01:18:04 <timthelion> What does the ! mean in !Int?  Is it "unboxed"?
01:18:19 <ion> It’s a strictness annotation.
01:18:19 <companion_cube> it is "strict"
01:18:32 <companion_cube> (but I suppose it makes it possible to unbox it)
01:18:48 <timthelion> So that means, it's not lazy...  hmm.
01:18:49 <timthelion> thanks
01:19:37 <ion> data Foo = Foo Integer; data Bar = Bar !Integer
01:19:43 <ion> case Foo undefined of Foo _ -> ()
01:19:46 <ion> case Bar undefined of Bar _ -> ()
01:20:18 <Cale> Basically it means that every application of the data constructor you're defining is automatically replaced with a strict application (i.e. $!) in the position of that field.
01:21:05 <ion> case Foo $! undefined of Foo _ -> ()
01:21:54 --- mode: wolfe.freenode.net set +o ChanServ
01:22:34 <Cale> http://www.haskell.org/onlinereport/decls.html#sect4.2.1 -- scroll down a little to the "Strictness Flags" section
01:23:31 <Cale> That's more a specification than how the implementation actually needs to do it of course
01:26:25 <timthelion> Is there a library that would support modular arithmatic on Word8's(I guess I can implement it on my own, since for this case I just need modular addition(mod 256)
01:27:20 <Cale> Challenge for someone bored: contrive a datatype with several fields and a program which runs significantly faster in the case that every other field is strict than in the case where they are all strict or all non-strict.
01:28:19 <MostAwesomeDude> timthelion: It isn't already?
01:28:39 <timthelion> Cale: does the program have to have the same code?
01:28:44 <Cale> timthelion: yes
01:28:46 <MostAwesomeDude> > 0xff + 0x2 :: Word8
01:28:47 <lambdabot>   1
01:28:53 <timthelion> MostAwesomeDude: I have no idea, what are the wrap arround rules for Word8?
01:29:00 <Cale> timthelion: only the field strictness changes :)
01:29:03 <timthelion> MostAwesomeDude: in C they are undefined(IIRC)
01:29:15 <shachaf> timthelion: No.
01:29:25 <MostAwesomeDude> timthelion: C doesn't have Word8, although that's a different discussion altogether.
01:29:49 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-260005.3
01:29:54 <Cale> There is, however, the additional constraint that all arithmetic on the fixed-sized types is performed modulo 2n.
01:30:43 <Cale> that's 2^n that failed to copy/paste correctly
01:32:02 <timthelion> shachaf: In C there are some weird rules for the data types that can be either signed or unsigned, that the wrap arround behavior is undefined.  I'm not sure if this applies to char or not.
01:32:30 <MostAwesomeDude> timthelion: Well, we're talking about Word8, right?
01:33:08 <nand`> > (maxBound, maxBound + 1) :: (Word8, Word8)
01:33:10 <lambdabot>   (255,0)
01:33:25 <timthelion> MostAwesomeDude: I'm not sure if C even has a type NAMED word8, so I was thinking of the closest companion
01:33:33 <Cale> Interestingly, I don't see a definition of the behaviour of arithmetic which exceeds bounds for Int
01:33:35 <nand`> > 2 * 200 :: Word8
01:33:37 <lambdabot>   144
01:33:42 <Cale> (In the Report)
01:33:44 <ion> C doesn’t have Word8? What’s the difference between Word8 and uint8_t?
01:33:47 <Cale> I guess that makes sense
01:34:23 <MostAwesomeDude> ion: Super-specifically, ISTR that unit8_t *may* be larger than 8 bits wide.
01:34:36 <MostAwesomeDude> er, *uint8_t even.
01:34:51 <ion> Seriously? ಠ
01:34:53 <MostAwesomeDude> But I don't think any of this matters for Haskell.
01:35:03 <ion> nice
01:35:08 <merijn> MostAwesomeDude: char may be larger than 8 bits, uint8_t not
01:35:23 <merijn> Well, it can be larger, but it'll behave as-if 8 bits wide
01:35:32 <MostAwesomeDude> merijn: Hm. So on a 9-bit-to-the-byte machine, would uint8_t be masked after every op?
01:35:55 <ion> Well, C is the most popular language for Haskell FFI [citation needed], C is *somewhat* ontopic. :-P
01:35:58 <merijn> MostAwesomeDude: Presumably, yes. Unless the ISA provides sub-byte behaviour
01:36:22 <merijn> Although I'd have to grab the standard to be 100% sure
01:36:35 <MostAwesomeDude> merijn: Well, that behavior doesn't sound unreasonable. I know that there's many a quirk to C which nobody ever cares about since everybody uses x86.
01:36:35 <timthelion> ion: C was only on topic, because MostAwesomeDude expressed surprise that I didn't just asume that adition with Word8 was mod 256...
01:37:16 <MostAwesomeDude> timthelion: I'm only surprised in that I'd hope you know that you can test these sorts of things out with ghci relatively quickly.
01:37:24 <MostAwesomeDude> I don't think your question was bad.
01:37:45 <merijn> MostAwesomeDude: It'd be similar to having int64_t operations implemented in software using a non-native value on 32bits machines, for example
01:38:04 <MostAwesomeDude> merijn: Sure. Makes sense.
01:41:28 <nand`> @check \x -> negate x == maxBound*2*x + (x :: Word8)
01:41:30 <lambdabot>   "OK, passed 500 tests."
01:43:03 <nand`> @check \x -> negate x == maxBound - x + (1 :: Word8)
01:43:05 <lambdabot>   "OK, passed 500 tests."
01:47:23 <Jafet> > and [ toInteger (x + y) == (toInteger x + toInteger y) `mod` 256 | x <- [minBound::Word8 .. maxBound], y <- [minBound .. maxBound] ]
01:47:25 <lambdabot>   True
01:48:53 <ion> jafet: Next up: Word64
01:52:22 <Jafet> You never know, there might be an ADD bug in the microprocessor.
01:55:10 <t7> impossibru
01:55:46 <Jafet> > (2^64)^2
01:55:47 <lambdabot>   340282366920938463463374607431768211456
01:56:12 <ion> Surely lambdabot can run that many iterations in… seven seconds, was it?
01:57:19 <shachaf> Jafet: Intel processors have had ADHD since the Pentium 4.
01:57:23 <shachaf> But I don't think it's a bug.
01:57:46 <ion> Some instruction set should have ADD and ADHD.
01:58:19 <ion> SUHB, MUHL, DIHV
02:03:51 <t7> adhd lul
02:04:29 <nitro2k01> Boh-ring! Bring back the SEX instruction instead.
02:15:13 <Shapeshifter> Hello again. I'm reading a book on haskell and I'm rewriting replicate as an exercise. The book version works, but if I change the typeclass restriction, it throws an error and I don't understand why. Paste: http://hpaste.org/73424
02:15:45 <shachaf> Shapeshifter: Int isn't a type class.
02:15:59 <shachaf> Maybe you mean replicate' :: Int -> b -> [b]?
02:16:05 <Shapeshifter> shachaf: mhh, oh right. of course. thanks.
02:16:46 <shachaf> @ty genericReplicate
02:16:47 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
02:16:57 <shachaf> If you were to use a type class, that would probably be the most sensible one.
02:17:39 <ion> replicate' :: (Int ~ a) => a -> b -> [b]
02:17:40 * ion ducks
02:19:23 <shachaf> type Int a = (Integer ~ a)
02:19:35 <shachaf> GHC doesn't allow ~ sections. :-(
02:19:46 <notdan> What does ~ means in types?
02:19:53 <notdan> hm, what is it supposed to mean then?
02:19:56 <Shapeshifter> Mh, but what exactly did ghci try to tell me saying "`Int' is applied to too many type arguments".
02:20:01 <shachaf> notdan: It's a GHC extension.
02:20:05 <shachaf> It means that two types are the same.
02:20:27 <nand`> Shapeshifter: You wrote ‘Int a’; but Int takes to type arguments
02:20:31 <nand`> takes no*
02:20:37 <shachaf> Shapeshifter: Don't worry about everything after ion started talking. It's just general #haskell tomfoolery.
02:20:45 <Shapeshifter> nand`: I see.
02:20:52 <shachaf> Int is just a plain ol' type.
02:21:09 <parcs`> notdan: there Int is not a type (it doesn't have kind *), but rather a constraint (kind * -> Constraint)
02:21:11 <shachaf> Type classes are overrated anyway -- introductions to Haskell ought to stick to types.
02:21:21 <nand`> I'm actually surprised about that error message, I'd have expected something like ‘Int isn't a typeclass’ before that; in the absence of fancy extensions
02:21:41 <shachaf> nand`: Yes, the internals of GHC were reworked to accomodate said fancy extensions.
02:21:50 <notdan> so 'Int a' is a type when 'a' is the same as 'Integer'?
02:22:00 <notdan> in type Int a = (Integer ~ a)
02:22:04 <nand`> shachaf: ah well, as long as it gives us fancy extensions
02:22:11 <shachaf> notdan: Let's call it Foo.
02:22:17 <shachaf> type Foo a = (Integer ~ a)
02:22:33 <shachaf> "Foo a" isn't a type -- it's a constraint, like (Show a) is a constraint.
02:22:43 <shachaf> Except it constrains a to be Integer.
02:22:47 <ion> "foo" :: Foo Integer => String
02:22:55 <shachaf> > let f :: (a ~ Integer) => a -> Integer; f x = x in f 5
02:22:56 <lambdabot>   5
02:23:27 <ion> 42 :: Foo a => a  -- a will be Integer
02:23:33 <parcs`> notdan: with the ConstraintKinds extension, constraints are first-class things in haskell, and you can work with them like you work types
02:24:21 <parcs`> notdan: wait do you understand what a ~ b does in a constraint context?
02:25:39 <Peaker> does HUnit support color output? and stdout printing during tests?
02:25:55 <Peaker> it seems to try to collect the output and print it at the end of its own line, which doesn't help
02:30:43 <ion> Out of curiosity, what do you want to print from a test?
02:31:41 <Peaker> mainly debug output (especially as I'm developing the test)
02:31:56 <strg> Peaker: hspec seems to support color output for hunit http://www.haskell.org/pipermail/haskell/2011-April/022765.html
02:34:21 <ion> peaker: How about Debug.Trace?
02:35:29 <Peaker> strg, the hspec approach seems very weird
02:35:34 <Peaker> ion, it's possible but I'm in IO so that's weird
02:36:03 <ion> peaker: If you’re in IO, how about hPutStrLn stderr?
02:36:45 <Peaker> ion, I'll try that.. (for now I commented out hunit wrapping)
02:38:14 <Peaker> anyone knows how Control.Lens.TH works with newtypes?
02:38:43 <nand`> Peaker: creates iso lenses afaik
02:38:55 <strg> Peaker: ok, sorry. Haskell newbie here :)
02:39:11 <shachaf> I'm not sure newtype lenses are necessarily a good idea.
02:39:18 <Peaker> strg, thanks for the pointer :) I don't want english string to describe my tests though
02:39:24 <Peaker> shachaf, why?
02:39:40 <nand`> not sure if he reverted it or not but a while ago it was something like this: newtype Foo = Foo { _foo :: Int } then you'd have foo :: Simple Iso Int Foo; reasoning being so you can use ‘5.to Foo’ and ‘(foo 5).from foo’
02:39:46 <nand`> ^. in my examples
02:39:51 <shachaf> Peaker: Because a newtype is often supposed to hide the thing inside it.
02:40:31 <shachaf> Anyway the Control.Lens.TH documentation seems to agree with nand`.
02:40:45 <nand`> shachaf: but often enough they're just for providing different instances
02:40:48 <nand`> or stuff like Identity
02:40:56 <shachaf> nand`: That's true.
02:41:03 <shachaf> It's not *necessarily* a good idea, though. :-)
02:41:09 <nand`> or just wrapping things up in pretty names in general
02:42:04 <Peaker> shachaf, the lens can be unexported
02:42:22 <shachaf> Peaker: True.
02:42:44 <timthelion> Which module has if'?
02:42:50 <shachaf> No module.
02:43:05 <shachaf> @ty if'
02:43:07 <lambdabot> Not in scope: `if''
02:43:21 <ion> if' for the lose, bool for President.
02:43:39 <timthelion> shachaf: Really? I thought I read somewhere that it's a standard function, if' :: Bool -> a -> a -> a
02:43:43 <ion> bool :: a -> a -> Bool -> a
02:43:55 <shachaf> timthelion: Nope.
02:44:07 <shachaf> ion: Bool = the devil.
02:44:30 <ion> shachaf: What should (<=) return?
02:44:39 <shachaf> A proof, I guess?
02:45:00 <shachaf> ion: That's a bit like asking "what should null return?".
02:45:11 <timthelion> ion: and which module has bool?
02:45:12 <shachaf> Yes, it should return a Bool, but you shouldn't use null in the first place.
02:45:16 <shachaf> timthelion: No module.
02:45:22 <shachaf> It's IRC folklore.
02:45:28 <timthelion> :(
02:45:40 <timthelion> But I don't like if!!!! I want a god damned function!
02:45:42 <timthelion> :D
02:45:49 <shachaf> Write it yourself.
02:45:57 <ion> There’s an implementation in Overture, but Overture is not quite finished and not even uploaded to Hackage (the last time i looked).
02:46:04 <nand`> module Church where if' = id
02:46:13 <danr> nand`: :)
02:47:01 <ion> https://github.com/isomorphism/Overture/blob/master/src/Overture/Data.hs#L167
02:47:26 <shachaf> preflex: seen cmccann
02:47:26 <preflex>  cmccann was last seen on #haskell 154 days, 7 hours, 44 minutes and 46 seconds ago, saying: was kinda sad how easily the same joker could troll /r/lisp though, they just kept encouraging him
02:47:30 <shachaf> :-(
02:47:51 <ion> Whoa, half a year already?
02:48:07 <nand`> did he write a book or something?
02:48:19 <shachaf> ion: Time. :-(
02:48:32 <ion> nand: He started a Prelude replacement. Perhaps that’s relevant.
03:00:49 <parcs`> where did cmccann go?
03:03:06 <danr> he was seen in July on SO: http://stackoverflow.com/users/157360/c-a-mccann
03:05:24 <SwineFlu> Whats the prelude in haskell speak
03:05:27 <SwineFlu> in baby terms please
03:05:54 <SwineFlu> The haskell docs look like moonspeak to me :(
03:06:45 <ion> The part of the standard library that’s imported by default.
03:07:07 <ion> @hackage base
03:07:07 <lambdabot> http://hackage.haskell.org/package/base
03:07:10 <ion> click on “Prelude”
03:09:15 <SwineFlu> but whats it for
03:10:25 <SwineFlu> I get the "prelude.undefined" error, How can this be undefined if its imported with the base package?
03:11:34 <parcs`> :t undefined
03:11:35 <lambdabot> forall a. a
03:12:19 <fmap> SwineFlu: this error doesn't mean that Prelude itself is undefined
03:12:22 <fmap> show the code
03:13:14 <SwineFlu> OHH, I've been given it from uni as a practice exercise, and it has lines like vert = undefined (after declaring it as a function) and im ment to change those lines
03:13:16 <SwineFlu> so it wont run
03:13:22 <SwineFlu> until i fix everyline
03:15:12 <typoclass> SwineFlu: when you look at haddock documentation pages, often the type signatures are more informative than the text. (i say this because at a beginner, the haddocks were often extremely frustrating)
03:16:02 <SwineFlu> Haskell is cool, but extremely furstrating for someone who learned to program with PHP years ago
03:16:32 <SwineFlu> I went PHP -> VB(hate) -> C# -> Java -> C -> haskell
03:16:48 <SwineFlu> so confuses me
03:16:57 <typoclass> @type map
03:16:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:17:02 <typoclass> ^^ example
03:17:32 <srhb> SwineFlu: Using undefined as a sort of "fill in the blanks" way of programming is very neat. You define the functions as all undefined, but you fill in their types. Then you add the function bodies in the end. :)
03:17:44 <typoclass> it takes a function (a -> b), a list of a's, and gives a list of b's. there's really only one way this can fit together
03:19:04 <SwineFlu> I hope I manage to stop thinking in impertive languages and start thinking haskell
03:19:15 <srhb> SwineFlu: eventually. :)
03:19:27 <shachaf> @let myap f [] = []; myap f (x:xs) = myap f xs ++ [x]
03:19:29 <lambdabot>  Defined.
03:19:35 <SwineFlu> I'm taking an entire haskell class next year ;3
03:19:37 <shachaf> Oops.
03:19:39 <shachaf> @undefine
03:19:42 <shachaf> @let myap f [] = []; myap f (x:xs) = myap f xs ++ [f x]
03:19:43 <lambdabot>  Defined.
03:19:46 <typoclass> SwineFlu: it's difficult to get the hang of haskell, but it's very rewarding eventually :)
03:20:09 <shachaf> OceanSpray: You sure join and quit a lot.
03:20:17 <shachaf> I remember you from a few years ago!
03:20:43 <typoclass> @type reverse
03:20:44 <lambdabot> forall a. [a] -> [a]
03:21:15 <typoclass> (types don't tell you everything in haskell)
03:21:20 <shachaf> @let mzap f [] = []; mzap f (x:xs) = f x : mzap f (x:xs)
03:21:21 <lambdabot>  Defined.
03:21:51 <adnam> lpsmith: hey, did you figure out the snap configurator?
03:22:22 <shachaf> 23:31 <shachaf> lpsmith: Did that actually help?
03:22:22 <shachaf> 23:34 <lpsmith> shachaf, yes,  thanks a bunch  =)
03:22:38 <adnam> ok :]
03:22:52 <shachaf> strace = best program
03:24:46 <typoclass> @let map' _ _ = []
03:24:47 <lambdabot>  Defined.
03:24:53 <typoclass> @type map'
03:24:55 <lambdabot> forall t t1 a. t -> t1 -> [a]
03:25:17 <shachaf> @Ty map' `asTypeOf` map
03:25:18 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
03:25:23 <shachaf> @ty map' `asTypeOf` map
03:25:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:32:25 <typoclass> i think there's demand on the market for an alternative Prelude whose functions have exactly the same names and types, but are as bass-ackwards as possible
03:32:53 <srhb> How do you mean?
03:33:38 <shachaf> Ocean: Hey, it's Ocean.
03:33:49 <shachaf> ...Or not.
03:33:59 <typoclass> srhb: oh, what shachaf and i were kidding around with :) a map function that reverses the list, etc.
03:34:04 <shachaf> srhb: I suspect geheimdienst is not being entirely serious.
03:34:17 <srhb> Ah :P
03:34:20 <Tomsik> I wonder when somebody does a prelude where (.) comes from category and mapM is the general one
03:34:21 <shachaf> (geheimdienst is my nickname for djahandarie.)
03:34:31 <shachaf> mapM?
03:34:36 <Tomsik> Right now they're doing kind of weird things
03:34:47 <Tomsik> :t mapM
03:34:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:34:58 <Tomsik> :t Control.Traversible.mapM
03:34:59 <lambdabot> Couldn't find qualified module.
03:35:05 <shachaf> Ah, Traversable.
03:35:16 <Tomsik> :t Control.Traversable.mapM
03:35:17 <lambdabot> Couldn't find qualified module.
03:35:20 <Tomsik> derp
03:35:26 <shachaf> I get it.
03:35:48 <shachaf> OceanSpray! What a pleasant surprise.
03:35:54 <Tomsik> I know, I just want to make sure
03:36:05 <OceanSpray> shachaf, hi
03:36:07 <shachaf> Tomsik: (It's Data.)
03:36:13 <Eduard_Munteanu> What's an easy way to spawn an external program and communicate with it? System.Process.createProcess?
03:36:19 <Tomsik> Ah right
03:36:22 <OceanSpray> why is it that you are wearing out my name
03:36:26 <shachaf> OceanSpray: Remember when we talked a few years ago?
03:36:31 <shachaf> About something? I don't remember.
03:37:10 <OceanSpray> I've been lurking in this channel since around 2007
03:37:18 <OceanSpray> it's hard to remember every conversation
03:38:29 <shachaf> Anyway the nick "Ocean" is taken.
03:39:05 <typoclass> Eduard_Munteanu: probably. i think there's a helper function so that you can easily construct that record that it wants
03:39:14 <OceanSpray> I also go by "kniu" or "Lemon"
03:39:29 <shachaf> Oh, you're kniu and Lemon?
03:39:33 <typoclass> (there's also rawSystem and system, but they only run something, they don't let yout talk to it)
03:40:00 <shachaf> Your nicks sure join and quit a lot.
03:40:21 <timthelion> Nice error: Couldn't match expected type `()' with actual type `[()]'
03:40:58 <Eduard_Munteanu> Right, that's good then, I just thought I'd ask if there's a more straightforward way.
03:42:35 <hiptobecubic> I guess with sparks you get a kind of worker pool for free then?
03:43:10 <OceanSpray> right now I'm stealing unsecured wifi
03:43:20 <hiptobecubic> it's not stealing. it's public.
03:43:21 <OceanSpray> hence why my connection drops in and out
03:43:34 <OceanSpray> the signal is extremely bad
03:43:43 <shachaf> OceanSpray: You should find some server to run your IRC client on, then!
03:43:56 <tdammers> if it's unsecured but not advertised as public, you're "hacking"
03:43:57 <shachaf> Or get a better Internet connection.
03:44:11 <hiptobecubic> shachaf, he can't even afford internet and you want him to have a dedicated irc server :)?
03:44:16 <tdammers> (not stealing though, stealing implies that you physically take something away)
03:44:19 <typoclass> i thought there were various free irc bouncer services
03:44:24 <OceanSpray> internet's coming in a few days
03:44:37 <OceanSpray> I just moved to a new place and didn't have the foresight to order internet beforehand
03:44:56 <hiptobecubic> tdammers, advertised as public how? Broadcasting the SSID to the world?
03:46:50 <tdammers> setting an SSID like "This is a public hotspot, please join" or sth like that
03:46:52 <MasseR> IIRC in finland it's illegal to access public wifi if it's just left unsecure by stupid users :)
03:53:17 <dmos> does anyone know how to get doctest running with multiline commands (':{'/':}' in ghci)?
03:55:28 <typoclass> dmos: i asked the other day in their irc channel, and they said there's no way currently. but you can do ">>> let x = ..." and then in later ">>>" lines refer to x
03:56:56 <dmos> typoclass: thanks. I know about the let, the problem is just the examples I'd like to show are complex enough to span multiple lines. Ah well, will have to do without doctest for that then (for now).
03:58:11 <lpsmith> adnam, at least I figured out part of it,  which is good enough for me at the moment.   it looks like this is one thing that should be better documented
03:58:48 <dmos> typoclass: btw, it's weird that it doesn't work, because they have at least some handling of it in their code base.https://github.com/sol/doctest-haskell/blob/master/src/Interpreter.hs#L97
04:00:19 <typoclass> dmos: ooh, interesting, i hadn't seen that. i looked at their sources the other day. maybe it's some very new unreleased thing ...
04:04:56 <adnam> lpsmith: see "Filesystem data and automatic installation" http://snapframework.com/docs/tutorials/snaplets-tutorial
04:06:36 <tdammers> MasseR: same here. Basically, using any network, wireless or not, without the owner's permission, is forbidden.
04:08:02 * hackagebot network-transport-tcp 0.2.0.3 - TCP instantation of Network.Transport (EdskoDeVries)
04:09:36 <f4m8> i'm at the begining in fp and haskell and have a question about "typeconversion"
04:09:39 <dmos> typoclass: Not sure, a build from github doesn't behave any differently. Well, we'll see.
04:09:59 <f4m8> see the source and error messages  here: http://paste.debian.net/184721
04:10:26 <f4m8> i'm aware of the problem, but have no idea how to resolve that
04:10:47 <f4m8> IO b0 != RealFloat a
04:11:53 <tdammers> return $ benzinkosten strecke verbrauch preis
04:12:06 <tdammers> you have to get the result value into the IO monad
04:12:20 <f4m8> tdammers: Ah, ok.
04:12:21 <tdammers> but that won't help much either
04:12:31 <tdammers> you probably want to *print* the value rather than return it
04:12:50 <f4m8> tdammers: right ;-)
04:12:52 <tdammers> putStrLn . show $ benzinkosten strecke verbrauch preis
04:13:10 <tdammers> also, next time try hpaste
04:13:23 <fmap> f4m8: `getArgs' returns `[String]' not `RealFloat a => [a]'
04:13:33 <tdammers> http://hpaste.org/new/haskell
04:13:39 <f4m8> tdammers: why is hpaste a diffrence for you?
04:13:53 <shachaf> Come on, let people use paste.debian.net
04:14:01 <tdammers> yeah, fine.
04:14:04 <fmap> f4m8: you need to read numbers from strings before "benzikosten" them
04:14:20 <tdammers> just a suggestion
04:14:50 <f4m8> fmap: that was my suspicion
04:15:02 <fmap> :t read
04:15:03 <lambdabot> forall a. (Read a) => String -> a
04:15:26 <f4m8> hwo to get RealFloat a from a valid string?
04:15:40 <Botje> read, presumably
04:17:09 <tdammers> > read "123.5"
04:17:11 <lambdabot>   *Exception: Prelude.read: no parse
04:17:25 <tdammers> > read "123.5" :: Double
04:17:27 <lambdabot>   123.5
04:18:07 <tdammers> let arg = "123.4" in read arg :: Double
04:18:12 <tdammers> sth like that
04:25:02 <dmos> > :t liftM (map read) getArgs
04:25:04 <lambdabot>   <no location info>: parse error on input `:'
04:25:18 <dmos> :t liftM (map read) getArgs
04:25:20 <lambdabot> Not in scope: `getArgs'
04:25:50 <dmos> :t liftM (map read) System.Environment.getArgs
04:25:52 <lambdabot> forall a. (Read a) => IO [a]
04:26:20 <dmos> :t liftM (map read) System.Environmen.getArgs :: IO [Double]
04:26:21 <lambdabot> Couldn't find qualified module.
04:26:28 <dmos> sigh
04:27:20 <Eduard_Munteanu> You're missing a 't' in "Environmen"
04:27:31 <dmos> :D thanks
04:27:46 <dmos> :t liftM (map read) System.Environment.getArgs :: IO [Double]
04:27:46 <HugoDaniel> hi
04:27:48 <lambdabot> IO [Double]
04:27:56 <Eduard_Munteanu> HugoDaniel: ohai
04:27:57 <dmos> ah, there we go.
04:28:53 <dmos> f4m8: ^^ should do the trick, just replace it in the first line, and add 'print $ ' or 'return $ ' at the beginning of the last line as suggested.
04:29:45 <f4m8> dmos: ok, i will try it
04:35:33 <f4m8> dmos: exchange line 18 from my pastbin with "liftM (map read) System.Environment.getArgs :: IO [Double]" doesn't work
04:36:45 <dmos> f4m8: just replace 'getArgs' with 'liftM (map read) getArgs'. You'll also need to import liftM from Control.Monad
04:37:02 <shachaf> Better yet, use fmap.
04:37:09 <shachaf> Better use, use <$> from Control.Applicative.
04:38:36 <dmos> shachaf: true. Just not sure whether it's helpful to muddy the waters just yet.
04:38:48 <dmos> but then, I'm no authority on didactics.
04:39:19 <f4m8> dmos: :-) no problem at least for me
04:40:04 <shachaf> dmos: No reason to introduce the unfamiliar name "liftM" when you could introduce the unfamiliar name "fmap".
04:40:09 <shachaf> Moreover, the latter doesn't require any imports.
04:40:37 <dmos> f4m8: then you can either replace liftM with fmap (without any import), or import <$> from Control.Applicative, and write '(map read) <$> getArgs'. All of these have the same effect.
04:40:59 <dmos> shachaf: ok, noted for next time.
04:41:02 <shachaf> Or you can fmap (fmap read) getArgs
04:41:09 <shachaf> Or fmap fmap fmap read getArgs
04:41:12 <f4m8> dmos: first of all: it compiles sucessfully
04:41:14 <shachaf> (But don't do that.)
04:41:48 <f4m8> ...adn the next step is, to understand the functionality
04:42:09 <f4m8> ..but this takes some time ;-)
04:46:13 <dmos> f4m8: it does the same thing what you initially asked (ie. type conversion).
04:46:22 <dmos> to find out what it does, start up ghci and play around with :t (:type). eg. 'import System.Environment<RET>:t getArgs' then ':t (map read) <$> getArgs' then ':t (map read) <$> getArgs :: IO [Double]'.
04:49:05 <dmos> (ah, forgot, you'll obviously need to 'import Control.Applicative' as well :| )
04:49:50 <f4m8> dmos: that was the rpblem with "return $ ..." vs. "putStrLn . show $ ..." i think
04:52:59 <dmos> f4m8: putStrLn prints to stdout, return is just control flow inside the program. It depends on what you want to achieve, but since you're here in 'main', you almost guaranteed want to use 'putStrLn...' to actually print the results.
04:53:50 <f4m8> dmos: ok. that is no differnce in other programming languages, so i got this point
04:54:48 <dmos> f4m8: actually 'return' is different from other programming languages, but it's not relevant for your current situation.
04:55:25 <f4m8> dmos: ok. i wil lkeep this in mind for later
05:11:57 <huskie> anyone awake?
05:12:16 <logicalguy> woof woof
05:13:00 <huskie> :-) just have a question...I'm a beginner and wanted to ask, why 'a' : [] does work and 'blub' : [] does not work
05:13:13 <huskie> Or is there a better reference than the "try haskell"-console?
05:13:18 <shachaf> huskie: Because '' is used for characters, not strings.
05:13:20 <shachaf> > 'a'
05:13:22 <lambdabot>   'a'
05:13:23 <shachaf> > 'abc'
05:13:24 <lambdabot>   <no location info>:
05:13:25 <lambdabot>      lexical error in string/character literal at chara...
05:13:41 <shachaf> > 'b' : 'l' : 'u' : 'b' : []
05:13:43 <lambdabot>   "blub"
05:14:03 <huskie> Ah, got it! too much python
05:14:20 <huskie> shachaf: thanks for clearing this up!
05:15:13 <logicalguy> python is gr8 too!
05:15:37 <huskie> yeah sure :-D but I need haskell for xmonad
05:16:54 <bobTheBuilder> is there an easy way to run Haskell as a server-side scripting language instead of PHP?
05:17:11 <Botje> bobTheBuilder: in theory you could use CGI + runHaskell...
05:17:21 <Botje> bobTheBuilder: but the existing web frameworks do one better I think.
05:17:39 <thirsteh> bobTheBuilder: http://snapframework.com/
05:18:09 <bobTheBuilder> what is the performance compared to PHP?
05:18:27 <osfameron> is it web scale?
05:18:53 <srhb> It is roflscale.
05:19:18 <Botje> bobTheBuilder: performance at what?
05:19:24 <logicalguy> hey how do I quit ghci
05:19:31 <srhb> logicalguy: control c?
05:19:32 <thirsteh> logicalguy: Ctrl+D
05:19:33 <bobTheBuilder> cpu consumption
05:19:42 <logicalguy> ctrl+c doesn't work
05:19:43 <srhb> Oh right, d..
05:19:46 <srhb> It's just in the fingers :P
05:19:52 <Botje> bobTheBuilder: oh, haskell is excellent at consuming CPU.
05:20:01 <osfameron> logicalguy: :q
05:20:18 <huskie> bobTheBuilder: snapframework uses epoll, so it is 100% better than php
05:20:22 <srhb> bobTheBuilder: A badly written fib or fac function will easily consume all your cpus! :-)
05:20:23 <logicalguy> osfameron, q is not in scope
05:20:29 <srhb> logicalguy: colon q
05:20:38 <srhb> logicalguy: or colon quit
05:20:49 <thirsteh> or just Ctrl+D
05:20:53 <logicalguy> oh ok.  ctrl+d works for me
05:20:57 * osfameron checks, yup, I did use the colon.  Didn't know about ctrl-d
05:20:59 <bobTheBuilder> :(
05:21:11 <osfameron> why ctrl-d instead of ctrl-c?
05:21:14 <thirsteh> bobTheBuilder: CPU won't be your bottleneck no matter what language you use
05:21:54 <osfameron> he left?
05:22:01 <thirsteh> ctrl+c breaks the line in most REPLs
05:22:05 <srhb> Yeah, maybe we overdid it!
05:22:54 <osfameron> tbh, I understand people wanting some reassurance about using an exotic technology for a real project
05:23:23 <thirsteh> "In contrast the Control-D causes the Unix terminal driver to signal the EOF condition, which is not a character, while the byte has no special meaning if actually read or written from a file or terminal. ... If Ctrl+D is typed without typing any characters first, the input stream is terminated and the program ends."
05:23:52 <samss> I have a list of type [IO(String,Float)], I would like to extract the content so that I have a list o type [(String,Float)] and so that I can work with it better how can this be done?
05:23:54 <thirsteh> osfameron: it's not going to help you if you focus on the wrong things
05:24:02 <srhb> osfameron: I agree, I didn't think he;d quit, I was about to explain why his questions were the wrong ones
05:24:03 <thirsteh> DB latency is going to be a much, much, much bigger issue than CPU load
05:24:06 <osfameron> I'm sure writing it in Haskell would be harder than writing in PHP (assuming he already knows PHP... which I guess he does, as that's what he's comparing it to)
05:24:11 <thirsteh> any framework with a reasonable templating framework is fast enough
05:24:15 <applicative> @type sequence
05:24:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:24:29 <applicative> samss: ^^^
05:24:37 <osfameron> thirsteh: yes, you're right. But I think it's worth understanding the psychology of why the question gets asked also
05:25:09 <applicative> samss it might be   xs <- sequence mylistofios
05:25:26 <thirsteh> osfameron: that may be harder than you think. You'd first have to understand the psychology of why people still use PHP
05:25:52 <osfameron> thirsteh: hah
05:25:59 <thirsteh> bazinga
05:26:09 * applicative thinks the explanation of why people use PHP is not psychological in character
05:26:28 <sipa> path of least resistance?
05:26:48 <osfameron> they know people who do it, they know sites that use it.
05:26:50 <thirsteh> you get code snippets and cheap shared hosting
05:26:55 <samss> applicative: thanks!
05:27:06 <schlicht> hey
05:27:39 <sipa> the one advantage of PHP is that it's such a non-modular monolithical interpreter, that anyone writing a PHP application, can assume that any hosting supporting it, provides everything they need
05:27:51 <huskie> from what I learned and saw is that PHP is not scaleable: for each request there must be one php-process
05:27:59 <sipa> huskie: not true
05:28:16 <sipa> well, for each simultaneous request, yes
05:28:18 <huskie> sipa: please correct me
05:28:40 <Botje> you can also run threaded PHP, if you need more tentacles.
05:28:57 <huskie> Botje: interesting... I will take a look at this
05:29:07 <thirsteh> Facebook uses PHP; sure it can scale
05:29:14 <Botje> (that's just threaded apache plus mod_php.)
05:29:15 <thirsteh> question is how much pain it is compared to using something else
05:29:20 <schlicht> sooo i use gtk2hs and glade. the path to the glade file ist hardcoded at the moment. what is the best way to handle a file like that for a release? i don't want to use a hard coded path. can it be compiled into the binary?
05:29:21 <huskie> thirsteh: Facebook uses hiphop
05:29:57 <flux> hallski, ..which is basically a PHP implementation?
05:30:09 <thirsteh> huskie: they've been using PHP since day 1. hiphop is a recent attempt to make PHP faster, but they keep repeating this over and over. A few months ago they wanted to implement PHP in PyPy
05:30:22 <Botje> which compiles PHP to C++ code and *that* is run.
05:30:30 <thirsteh> a few days ago they announced they were doing some new effort porting PHP to something, but I forgot what
05:30:35 <Botje> at that point you're no longer using interpreted php.
05:30:57 <thirsteh> Botje: what's your point? They've been using hiphop for a couple of years
05:31:12 <d-snp> that you need a process per request does not necessarily make a system unscaleable
05:31:34 <d-snp> even node.js needs a process per request at some level
05:31:55 <thirsteh> please don't use node.js as an example of scalability
05:32:01 <thirsteh> an event loop is not a panacea
05:32:07 <thirsteh> you need both processes and asynchronous IO
05:32:12 <d-snp> no
05:32:18 <huskie> thirsteh: /sign
05:33:25 <d-snp> why wouldn't I use node.js as an example of scalability? it's been used for scaling a bunch of stuff recently
05:33:44 <thirsteh> it was designed to solve the C10K problem but fails to do just that
05:33:59 <huskie> thirsteh: why?
05:34:48 <d-snp> I was responding to huskie's assertion that php is not scaleable btw, not at all making a case for actually using php :P
05:35:02 <thirsteh> it advertises itself as being a "non-blocking" "seamlessly scalable" web engine, but it is just a reactor/event loop. Any computation will block for an arbitrary amount of time; it's up to you to make sure it only blocks for a little while at a time, which means you need to do a lot of callback spaghetti for any operation that might take some time
05:35:39 <thirsteh> it completely fails at doing anything in parallel, and if you want to do something like that you need to run separate processes anyway
05:36:37 <d-snp> the failing at doing things in parallel is actually an advantage
05:36:37 <quicksilver> thirsteh: it's seemlessly scalable as long as none of your requests do any work at all :)
05:36:47 <thirsteh> quicksilver: yep
05:36:51 <quicksilver> it's excellent for serving  /dev/null very fast over multiple URL paths.
05:36:54 <d-snp> it enables you to implement concurrent I/O in a very safe manner
05:37:19 <thirsteh> what does that mean?
05:38:23 <thirsteh> node.js is a path into the backend for front-end developers who only know JavaScript, and for that it's absolutely great
05:38:31 <d-snp> it solves the problem of needing locks or other concurrency primitives for shared memory
05:38:41 <d-snp> because your pure code simply never runs concurrently
05:38:46 <d-snp> only the I/O runs concurrently
05:38:58 <d-snp> this makes some problems really easy to solve
05:39:06 <thirsteh> why would you need synchronization when serving HTTP requests? HTTP is stateless
05:39:18 <thirsteh> that is a corner case
05:39:20 <d-snp> because node.js isn't made to serve HTTP requests
05:39:45 <d-snp> who uses node.js for http anyway, don't people know ruby?
05:40:01 <huskie> they know ruby, but don't want to learn another language
05:40:09 <huskie> javascript for everything
05:41:59 <huskie> OK, that statement does look like that I love javascript... I hate it
05:42:04 <thirsteh> d-snp: so what is node.js for? Using JavaScript as a scripting language? Then my question becomes "why use JavaScript?"
05:42:21 <schlicht> is there something like __data__ for haskell?
05:42:30 <thirsteh> JavaScript is an absolutely impressive language considering it was designed in two weeks, but surely you'll agree it doesn't compare to "real" scripting languages
05:42:39 <shachaf> schlicht: Before people can answer that, you might have to specify what __data__ is.
05:43:11 <dfdsfds> anything that is not a function
05:43:17 <d-snp> thirsteh: because javascript has continuation passing style natively built in
05:43:44 <d-snp> git was designer in under 2 weeks too, doesn't make it a bad system
05:43:49 <schlicht> shachaf, ah yeah, its a token that tells the compiler stop parsing here. i know it from perl. in perl you can still access everything behind __DATA__.
05:44:14 <d-snp> anyway, I would agree that if you build ruby in this style it would be 10 times better
05:44:18 <d-snp> it's just that nobody did
05:44:20 <dfdsfds> round 1  == 1.5
05:44:22 <schlicht> i want to store xml in a haskell source file, so i can accesse it at runtime
05:44:30 <thirsteh> d-snp: you're saying JavaScript isn't bad?
05:44:36 <dfdsfds> lambda round 1  == 1.5
05:44:42 <dfdsfds> @lambda round 1  == 1.5
05:44:43 <lambdabot>  Done.
05:44:45 <thirsteh> d-snp: the outputs from [] == {} and {} == [] are different
05:44:48 <d-snp> no javascript isn't bad per se
05:44:55 <thirsteh> of course it is
05:45:01 <thirsteh> but it's the best we've got for web applications
05:45:06 <thirsteh> it isn't for the backend
05:45:37 <quicksilver> I think probably the javascript discussion has rambled off-topic a bit, perhaps -> #haskell-blah
05:45:49 <shachaf> Or ##javascript
05:45:52 <huskie> sorry, I need to throw that into the discussion: http://bodil.org/coffeescript/#in-the-beginning-slide
05:45:55 <thirsteh> sorry :)
05:46:03 <d-snp> woops, got to get back to my thesis ;)
05:47:54 <thirsteh> huskie, d-snp: apropos, Fay is great: http://fay-lang.org/
05:48:38 <drbean> The namespace qualifier doesn't have to be unique for different modules?
05:48:57 <drbean> Modules can share a namespace qualifier?
05:49:19 <quicksilver> yup
05:49:38 <quicksilver> import Foo as M; import Bar as M; mystery = M.wherediditcomefrom ?
05:50:20 <huskie> thirsteh: looks nice :-D thanks
05:50:21 <drbean> I see it as a plus.
05:53:11 <d-snp> thirsteh: I agree :)
05:53:25 <quicksilver> drbean: yes, it probably is a good thing, although the fact you can't re-export qualified makes it less powerful than you might hope.
05:56:26 <huskie> Where should I look for if I wanted to find what 'map' exactly does?
05:56:32 <fmap> i thought `module Module (module M) where...' would re-export everything qualified with M, no?
05:56:45 <frerich> thursteh: Actually, Fay looks really interesting
05:56:52 <frerich> thursteh: thanks for pointing it uot!
05:56:56 <frerich> s/uot/out/
05:57:20 <huskie> frerich: was that regex?
05:57:37 <thirsteh> I've had a chance to use it a few times. It's very nice. Snap includes a "snaplet" that recompiles your Fay code automatically, too
06:00:22 <quicksilver> fmap: no, there is no way to export qualified.
06:00:42 <quicksilver> fmap: stuff you import always comes in flat (either at the top level, or under the qualification you choose at import time)
06:01:22 <quicksilver> a more composable/programmable way to nest and re-export qualifications would make it much easier to package up 'convenience APIs' or 'recommended naming schemes'
06:03:36 <fmap> apparently i suck in parsing english
06:03:39 <fmap> sorry
06:06:08 <applicative> schlicht: does the arrangement in  something like http://hackage.haskell.org/package/tic-tac-toe seem wrong
06:12:40 <Yiq> why is rabbitMQ so cool?
06:29:14 * hackagebot obdd 0.2.3 - Ordered Reduced Binary Decision Diagrams (JohannesWaldmann)
06:31:06 <schlicht> applicative, yeah i just moved the glade file to the toplevel
06:32:23 <adnam> thirsteh: fay :]
06:32:42 <timthelion> Is there a good way to say that this mapM in the IO monad is allowed to be lazy(that order doesn't matter.)?  I have an image processing script in haskell, that loads a bunch of images, changes them, and then saves them to disk. http://hpaste.org/73427 here is my program.  Haskarrow code above, haskell code(autogenerated) bellow.
06:33:25 <timthelion> Right now, it loads every image to memory, and then saves every image, it would of course be better if the list dynamicImages was lazilly read from disk...
06:33:35 <timthelion> do I need to explicitly redesign my program?
06:34:12 <adnam> hmmm i thought that would be done lazily...
06:34:58 <timthelion> adnam: well, I think that mapM is explicitly NOT lazy.  What if you wanted to print out the contents of a list?  You wouldn't want that to be lazy...
06:35:01 <kanedank`> hey, just out of curiosity, is there a haskell skeleton I can clone from github?
06:35:08 <kanedank`> or something like that perhaps built into ghc?
06:35:21 <timthelion> kanedank`: skeleton? what kind of skeleton?
06:35:43 <kanedank`> well, I don't really understand modules for example
06:36:02 <kanedank`> I don't know, a simple 3 file library
06:36:16 <Jafet> Lazy has a very specific meaning.
06:36:19 <adnam> kanedank`: there are online books that probably explain that well
06:36:21 <timthelion> kanedank`: well, you can look at any number of simple 3 file libraries.
06:36:26 <adnam> @where lyah
06:36:27 <lambdabot> http://www.learnyouahaskell.com/
06:36:56 <timthelion> kanedank`: https://github.com/bsl/threadmanager <- as simple as it gets
06:37:20 <timthelion> kanedank`: exactly 3 files :) https://github.com/timthelion/her-lexer
06:38:00 <timthelion> Jafet: ?
06:38:04 <Botje> kanedank`: there's also cabal init, which starts you off with a skeleton.
06:39:23 * hackagebot async 2.0.1.2 - Run IO operations asynchronously and wait for their results (SimonMarlow)
06:42:11 <Jafet> Lazy means stuff isn't computed until other stuff needs it.
06:42:14 <kanedank`> is it necessary to put data type declarations or anything in separate files? or can I just use one file until it becomes unmanageable?
06:42:52 <Jafet> If your program structure is files <- getArgs; mapM_ process files;
06:43:07 <Jafet> Then process has to be however non-lazy you need
06:43:13 <Botje> kanedank`: it's not necessary, no.
06:43:24 <Jafet> (Your hpaste is very tldr so I'm ignoring it)
06:43:39 <kanedank`> Botje: awesome!
06:43:40 <Botje> kanedank`: some libraries make a split between interface and implementation, thouhg.
06:43:48 <Botje> for now go with one big file :]
06:47:11 <kanedank`> hey why am I getting Prelude.head: Empty list for this code?: https://gist.github.com/3404198
06:47:17 <kanedank`> I'm not even touching any arrays...
06:47:22 <kanedank`> lists*
06:48:05 <k00mi> kanedank`: getArgs returns a list
06:49:09 <yitz> kanedank`: you are touching a list. head takes a list as input. your code would not compile if you were not giving it a list as its input.
06:51:38 <kanedank`> thanks!
06:57:07 <fmap> timthelion: does your editor automatically add '>' and then indent appropriately after a line break?
06:59:53 * hackagebot hsparql 0.1.4 - A SPARQL query generator and DSL, and a client to query a SPARQL server. (RobStewart)
06:59:55 * hackagebot classy-prelude 0.2.0.1 - A typeclass-based Prelude. (MichaelSnoyman)
07:00:25 <eikke> when using conduits, does this make any sense or would it leak all over the place: http://hpaste.org/73430
07:10:00 * hackagebot mega-sdist 0.2.0.3 - Handles uploading to Hackage from mega repos (MichaelSnoyman)
07:11:55 <mm_freak> eikke: are you trying to do rate-limiting?
07:12:31 <eikke> mm_freak: sorta, yes (this is only an extremely basic and stupid example)
07:12:42 <eikke> couldn't find anything related using google, so started hacking
07:12:47 <mm_freak> eikke: and you want to be able to change the rate from another thread?
07:13:00 <eikke> mm_freak: yes
07:13:38 <mm_freak> eikke: are you sure this has to be done from another thread?  i mean, you don't want the source to provide the current rate?
07:14:49 <eikke> no. the source can produce data at almost any rate, as can the sink, but if the sink consumes data at a rate too high, it's very inefficient (yet the sink can't know)
07:14:59 <eikke> figuring out the 'best' rate is done through another channel
07:15:02 * hackagebot mime-mail-ses 0.2.0.4 - Send mime-mail messages via Amazon SES (MichaelSnoyman)
07:15:04 * hackagebot xml2html 0.2.0 - blaze-html instances for xml-conduit types (deprecated) (MichaelSnoyman)
07:16:06 <eikke> (basically: source is memory, sink is sending UDP packets, which should be rate-limited since the network would drop packets anyway if rate is too high)
07:19:32 <timthelion> eikke: seems simple enough.  Just have the sink takeMVar networkLoadSufficientlyLow :: ()
07:19:55 <timthelion> eikke: and put that mvar from your rate limiting thread.
07:20:01 <Na-Fiann> Hi, I've never done something like this before, and no idea if it is possible in haskell, but basically I want to create a very simple website that displays a countdown timer to the user, ticking off seconds, to learn setting up a simple website in haskell. Can this be done in haskell?
07:20:20 <eikke> timthelion: hmh... I thought doing this inside a Conduit (instead of doing it in the sink) is much cleaner
07:20:45 <sipa> Na-Fiann: that just requires some static html
07:21:07 <eikke> so I have source -> rate_limiter -> sink, and I can combine several rate-limiting strategies without changing the sink implementation
07:21:08 <sipa> Na-Fiann: a haskell program that produces such static html will suffice, but you won't learn any haskell from that
07:21:42 <timthelion> eikke: so you want to have three different threads then?
07:21:58 <timthelion> eikke: and an MVar or Channel or TVar based relay?
07:21:59 <eikke> timthelion: why would I need 3 of them?
07:22:17 <timthelion> eikke: So you just want 3 functions?
07:22:21 <mm_freak> eikke: the original solution seems sensible, but it probably doesn't limit the rate in the way you want
07:22:46 <mm_freak> eikke: notice that both the source and the sink may need some time, before accepting the next output or presenting the next input to the conduit
07:22:50 <eikke> mm_freak: basically I'll want to limit on packets per time-unit, but that's trivial
07:22:54 <mm_freak> so you have to work with time deltas
07:23:04 <mm_freak> even per unit this is not going to work
07:23:13 <mm_freak> it will work assuming that the source and sink need no time
07:23:24 <eikke> the main question is: if I'd use another source instead of a stupid list, will it only be able to generate a new item once the limiter allows one to pass through?
07:23:31 <mm_freak> but that's sort of inconsistent with relativity and the practice of networking =)
07:23:44 <mm_freak> yes
07:23:56 <eikke> mm_freak: if the actual 'packets per time unit' is somewhat-close to the desired value, that's good enough
07:24:27 * timthelion is suspicious of anything that uses IORefs :D
07:24:32 <mm_freak> if your units are large and the sink is fast, that's probably fine, but note that a time delta-based solution won't be much more complicated
07:24:38 <eikke> timthelion: I'm afraid I don't get your question. did you see the code?
07:24:52 <timthelion> eikke: I'm looking at it now
07:25:05 <mm_freak> the IORef is fine there, as long as you use atomicModifyIORef
07:25:10 <mm_freak> but an MVar would be safer, of course
07:25:39 <eikke> it's single-reader, single-writer, so mvar is overkill
07:25:48 <mm_freak> why?
07:25:56 <JoeHazzers> mm_freak: i was told i should ask you about how i should go about downloading files over HTTP in a way that i can measure the download rate during transfer :S
07:26:18 <mm_freak> JoeHazzers: http-conduit
07:28:37 <merijn> Na-Fiann: For webdevelopment in Haskell you should look at Happstack and/or Yesod
07:28:55 <merijn> (And I guess Snap? That's a seperate framework, right?)
07:29:41 <t7> yeah
07:30:01 <t7> snap is really good but a massive mindfuck at first
07:33:17 <t7> does haskell have a nice regex builder? like from english-like to regex
07:35:23 * hackagebot yesod-platform 1.1.1 - Meta package for Yesod (MichaelSnoyman)
07:35:46 <geekosaur> I think the Haskell community is sufficiently anti- (or post-) regex that nobody has had any interest in building one.  I think there's a regex EDSL out there somewhere though
07:37:44 <mm_freak> t7: if you want to build a matcher, why not just build a parser?
07:37:48 <mm_freak> that's pretty word-like
07:38:33 <t7> i thought someone might have done i allready
07:39:30 <mm_freak> many (oneOf "abcde")
07:45:45 <Jafet> Just use pugs.
07:50:00 <bitonic> <http://www.haskell.org/pipermail/haskell-cafe/2012-August/102996.html>, ideas welcome.
07:50:37 * hackagebot yesod-eventsource 1.0.0.1 - Server-sent events support for Yesod apps. (FelipeLessa)
08:00:05 <matthiasgorgens> geekosaur: regex's are fun.  but yeah, writing a parser in haskell is easy enough.
08:00:27 <matthiasgorgens> t7, how you go from English to regex?
08:00:42 <matthiasgorgens> t7: what kind of English would you come from?
08:01:01 <matthiasgorgens> t7: that would be some highly stylised version of the language, wouldn't it be?
08:01:12 <sipa> t7: yes, can you give an example of some from/to pair?
08:01:22 <ion> I had a problem. I figured i’d solve it with a regexp. Now i have two problems.
08:01:31 <matthiasgorgens> (or at least the from part.  we can probably figure out the to part.)
08:01:42 <matthiasgorgens> ion: but they might be smaller problems.
08:01:57 <sipa> I has a problem. I figured I'd solve it with a floating point number. Now I have 1.99999997 problems
08:03:05 <matthiasgorgens> sipa: at least you didn't use a pentium.
08:05:16 <kanedank`> excuse me, but where would I find a good example of attoparsec?
08:05:22 <Yiq> anyone here actually deployed on heroku? i think im gonna need some help on the way if i try
08:06:57 <matthiasgorgens> kanedank, our (unfortunately closed source) example of using attoparsec looks just like if we had used plain parsec.
08:07:07 <MostAwesomeDude> Yiq: Weren't you just doing Python?
08:07:42 <Yiq> yes thats done
08:08:08 <Yiq> jsut wanted to go through it in python first to get aquainted
08:08:45 <t7> MoreThanZero (OneOf "aeiou")
08:08:59 <t7> or something ^ matthiasgorgens sipa
08:10:05 <srhb> An attoparsec is just slightly more than an inch. Fun. ^_^
08:10:38 <srhb> Does Attoparsec supercede Parsec?
08:10:45 <srhb> It seems like it's just Parsec, but faster.
08:11:11 <Emmycakes> >.>
08:12:43 <matthiasgorgens> srhb: parsec seems to have better error reporting than attoparsec.
08:13:07 <matthiasgorgens> srhb: and parsec is now also build on Text (instead of just String), so it should have gained some speed.
08:13:17 <matthiasgorgens> (though I've heard it's not as fast as attoparsec, still.)
08:14:17 <matthiasgorgens> t7, is MoreThanZero (OneOf "aeiou") your example of something close to English that you want to translate into regular expressions?
08:14:23 <matthiasgorgens> t7, because that's almost parsec syntax.
08:15:00 <t7> yeah
08:16:47 <applicative> you mean you want to write out ordinary regexen like for perl or whatever? t7
08:18:30 <t7> yeah
08:23:39 <paolino> hello, I have a math question. I want to cut a segment of length l in n parts randomly. Is there a simple way to be sure the length of the n+1 segments are uniformly distribuited around l/n ? Sorry if I'm not precise in language
08:24:13 <paolino> *n segments
08:24:32 <Clint> randomly?
08:25:47 <paolino> yes I want to pick a set of n segments with total length l
08:26:10 <Clint> but not uniformly-long segments
08:26:58 <paolino> Clint, can you rephrase uniformly-long ?
08:27:30 <t7> paolino: choose random number call it x, choose random number - x  and call it y, etc etc
08:27:38 <t7> n times
08:27:50 <EvanR2> paolino: i think you need to more carefully describe in what random way you want to choose the segment lengths, just that they add up to L is not enough
08:28:18 <paolino> t7 first segment will have a media of l/2
08:29:03 <t7> is that not acceptable ?
08:29:19 <paolino> no, it has to be l/n
08:29:55 <t7> ah ok
08:30:01 <applicative> why not just take n random doubles in (0,1) and renormalize?
08:30:14 <psii> the primitive way would be generating n random numbers, sort them, and then do list splicing
08:30:20 <t7> choose a number between 0 - n. then divide until total = n
08:30:22 <t7> or something
08:30:39 <t7> choose numbers *
08:31:06 <t7> need to be ration numbers though i think
08:31:12 <paolino> applicative, i think it is correct
08:32:39 <EvanR2> pick n numbers between 0 and L
08:32:44 <EvanR2> divide there
08:32:51 <EvanR2> dont know if it gets the distributions you want
08:33:11 <paolino> applicative, should have thought about it, also. Thanks
08:34:04 <ion> > let go = cumul . normalize <$> replicateM 5 (state (randomR (0, 1 :: Double))); normalize xs = map (/total) xs where { total = sum xs }; cumul = scanl (+) 0 in evalState go (mkStdGen 42)
08:34:05 <paolino> EvanR2 they don't sum up to l
08:34:06 <lambdabot>   [0.0,4.297273675573799e-2,0.3720196515065809,0.4918149464255879,0.795947660...
08:34:20 <ion> > let go = cumul . normalize <$> replicateM 3 (state (randomR (0, 1 :: Double))); normalize xs = map (/total) xs where { total = sum xs }; cumul = scanl (+) 0 in evalState go (mkStdGen 42)
08:34:22 <lambdabot>   [0.0,8.737582513108882e-2,0.7564220124059768,1.0]
08:34:30 <EvanR2> paolino: yes they do
08:34:57 <paolino> oh, I see
08:35:44 <paolino> but I have no clue if they are well distributed
08:36:29 <paolino> you want me to pick n-1 points
08:38:06 <EvanR2> paolino: you didnt say what 'well distributed' means
08:38:28 <EvanR2> the division points will be equally distributed along the total length
08:38:58 <kanedank`> I'm used to seeing data declarations like this: https://gist.github.com/3405212  but I don't get this kind: https://gist.github.com/3405198
08:39:05 <kanedank`> are they the same?
08:39:45 <t7> kanedank`: yeah just named attributes
08:39:53 <EvanR2> kanedank`: the second one is record style
08:39:54 <ion> kanedank: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
08:39:55 <EvanR2> with field names
08:39:57 <t7> @google haskell record syntax
08:39:59 <lambdabot> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
08:39:59 <lambdabot> Title: Making Our Own Types and Typeclasses - Learn You a Haskell for Great Good!
08:40:06 <EvanR2> the first kind has too many arguments to easily deal with
08:41:07 <paolino> EvanR2 , their length uniformly distibuted around l/n is not enough I suppose
08:42:19 <EvanR2> paolino: 'uniformly distributed around' ?
08:42:27 <EvanR2> like between 0 and l/n?
08:42:40 <paolino> I should specify the distribution shape not only the medium which is l/n
08:42:42 <EvanR2> i dont think you can make them add up to L
08:42:57 <ZsoL> Hi everyone :) I'm trying to use a priority search queue implementation from hackage (PSQueue) but once I insert two elements into a queue, I think I get an infinite data structure
08:43:16 <ZsoL> here's my minimal code that reproduces it: https://gist.github.com/3397650
08:43:45 <ZsoL> I think I'm doing something wrong since I get the exact same behavior with another PSQueue implementation
08:43:54 <paolino> EvanR2, maybe between l/n/2 and 3*l/n/2
08:44:09 <EvanR2> paolino: uniform? its not going to add up to L
08:44:28 <EvanR2> too many requirements
08:44:36 <paolino> n * l/n == l
08:44:47 <EvanR2> yes but thats unlikely
08:45:14 <EvanR2> just because a generator has an average value it doesnt mean every generation will have the average value
08:45:32 <EvanR2> are you ok with it 'on average' adding up to L?
08:45:37 <paolino> that's why applicative suggested to normalize
08:45:54 <EvanR2> thats the same as dividing at random points between 0 and L
08:46:04 <EvanR2> the lengths will not be uniformly distributed
08:46:12 <EvanR2> just the points
08:46:25 <paolino> oh
08:47:58 <paolino> well it should be demonstrated
08:57:27 <kanedank`> how would I convert a char8 to an int?
08:57:47 <aristid> kanedank`: char8? do you mean Word8?
08:57:57 <aristid> :t fromIntegral
08:57:58 <lambdabot> forall a b. (Integral a, Num b) => a -> b
08:58:05 <Clint> :t fromEnum
08:58:06 <lambdabot> forall a. (Enum a) => a -> Int
08:59:03 <monochrom> what is char8 and where can I find it?
08:59:40 <timthelion> monochrom: char8 don't exist, but you can do import Data.Word ; type Char8 = Word8
09:00:12 <kanedank`> aristid: this http://hackage.haskell.org/packages/archive/attoparsec/0.10.2.0/doc/html/Data-Attoparsec-ByteString-Char8.html
09:00:17 <monochrom> that was a guiding question
09:00:37 <quicksilver> kanedank`: 'Char8' isn't a type - it's the name of a bytestring module which treats bytes as characters
09:00:55 <monochrom> char8 is a function name there
09:00:58 <quicksilver> kanedank`: if you actually want those bytes as numbers, not characters - then don't use that module in the first place.
09:01:25 <kanedank`> ah, okay, my bad
09:01:37 <aristid> quicksilver: actually, he can: char8 :: Char -> Parser Word8
09:01:37 <kanedank`> so how would one go from a bytestring to an int?
09:02:00 <aristid> kanedank`: are you sure that's what you want? don't you want to convert single characters?
09:02:40 <kanedank`> no, I have a binary format I'm trying to parse
09:02:47 <monochrom> (it is very hard to communicate at the level of "convert tree to color")
09:02:54 <Yiq> If I want to connect 2 users of my site via webcam, then that traffic wouldnt have to go throught the app right? Would it be hard to do this? How would you connect them?
09:03:00 <timthelion> kanedank`: In haskell, it's important that you capitalize the names of types.  I know that can be hard for some people(like dyslexic me) but it really is important so that everyone is on the same page.
09:03:28 <kanedank`> Yiq: flash rtmfp
09:04:33 <kanedank`> timthelion: thank you, I'll keep that in mind. I keep forgetting how important capitalization is in this language.
09:05:06 <paolino> EvanR2, yours is correct on the medium.  (map ((/100000) . sum) . transpose) `fmap` replicateM 100000 (scatter 10 3) ----> [3.3356546667515294,3.335185501307605,3.329159831940893]
09:07:05 <srhb> kanedank`: did you see readInt and readInteger in Data.ByteString.Char8?
09:07:32 <quicksilver> isn't attoparsec designed for parsing textual languages which happen to be in bytestrings?
09:07:42 <quicksilver> isn't it Data.Binary you want if you're parsing a binary format?
09:07:47 <srhb> I would think so, yes.
09:07:54 <paolino> EvanR2, testing momentum equality is beyond my knowledge :-(
09:08:12 <srhb> But there's also attoparsec-binary
09:08:36 <aristid> well binary should do the job, why pile on an attoparsec?
09:08:42 <srhb> I agree.
09:09:10 <quicksilver> aristid: for more sophisticated parsing combinators like 'many' I imagine
09:09:16 <quicksilver> (I'm arguing against myself now, I know)
09:09:22 <aristid> quicksilver: haha
09:09:28 <quicksilver> but binary is fine for fairly simple straight-through formats
09:09:48 <EvanR2> i dont see how the base attoparsec module is 'for textual data'
09:10:10 <quicksilver> EvanR2: well for example it doesn't provide getWord32be, does it?
09:10:19 <jfischoff> anyone used both accelerate and repa and have an opinion on which one is easier to write performant image processing with?
09:10:21 * timthelion likes lazy list computations for parsing.  Doesn't see what all these parsing libraries are all about :)
09:10:36 <quicksilver> natural primitives for binary formats
09:10:39 <EvanR2> quicksilver: no it doesnt have whitespace either for example
09:10:41 <aristid> oh, attoparsec-binary doesn't use binary
09:11:40 <kanedank`> okay, I think I'm making my life hell by using attoparsec. What would you guys recommend? it seems like I should just be using Data.Binary? I'm really not doing anything all that complicated, at lest I don't think so...
09:11:57 <srhb> kanedank`: Say what you're doing, I think ;)
09:12:06 <kanedank`> I'm trying to parse a pcap file
09:12:44 <quicksilver> did you already consider and discard Network.Pcap as a solution?
09:13:42 <NoICE> hi guys :) quick question: HaXml is the preffered way to create and parse XMLs in haskell? or there is another alternative which is better/safer/faster etc.?
09:13:43 <byorgey> ddarius, shachaf: I've updated the paper linked from my website to contain the bibliography.  No idea what happened (the version I submitted for publication did have it).
09:14:13 <t7> noIce i used the xml package and it was great
09:14:17 <srhb> kanedank`: For that purpose, I think Data.Binary is fine.
09:14:22 <kanedank`> quicksilver: nope, had no clue that even existed. I saw pcap-enumerator, but that seems to depend on pcap being installed, and I would like to create a pure haskell solution if possible
09:14:47 <NoICE> r7: this one? http://hackage.haskell.org/package/xml-1.3.7
09:15:15 <byorgey> NoICE: HaXml is good if you need to do sophisticated *transformations* of XML documents.  For simple parsing or generating of XML documents it is probably overkill
09:15:16 <NoICE> (I mean the package, not the version ofc :) )
09:15:21 <quicksilver> kanedank`: ah, network.pcap is also linked against the pcap library
09:15:35 <shapr> Goood Morning #haskell!
09:15:39 <NoICE> byorgey: thought so :) thanks
09:15:47 <NoICE> r7: also thanks :)
09:15:50 <t7> http://hackage.haskell.org/package/xml
09:16:12 <timthelion> shapr: good evening
09:16:38 <Yiq> kanedank: ty, have you used it?
09:17:43 <NoICE> byorgey: I have a task which involves creating/parsing little xmls according to 450-lines long XSD… I like haxml's utility XsdToHaskell, but it isn't perfect, i.e. it doesn't like attributeGroups and xsd:all, so I will have to create my own types anyway
09:26:46 <kanedank`> what does "Could not find module `Data.Bytestring.Lazy'" mean? I just ran cabal install bytestring...
09:27:23 <srhb> kanedankDid you restart ghci?
09:27:32 <Clint> did you spell ByteString correctly?
09:27:33 <edwardk> try an uppercase S
09:27:37 <srhb> kanedank`: Also big S, yeah :P
09:29:36 <kanedank`> yep, misspelled it :P
09:30:00 <applicative> jfischoff: I was going to say that repa at least has a fancy example, the edge detector one, but I see it hasn't been updated for the new repa
09:31:16 <jfischoff> applicative: are you referring to Efficent Parallel Stencil Convolution :http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/stencil.pdf ?
09:32:25 <Okasu> mokus: hello, i'm trying to execute haskell command from your fork of lambdabot (with (>)) but i'm getting
09:32:28 <Okasu> Could not find module `Trusted'
09:32:30 <Okasu> error
09:33:13 <applicative> jfischoff: no, I was just thinking of the demo on the bottom of the website http://repa.ouroborus.net/ with the linked darcs repo.
09:33:39 <Okasu> mokus: how can it be fixed?
09:34:00 <kanedank`> what does this error mean "Not in scope: type constructor or class `L.ByeString'" if I am seemingly importing correctly?: https://gist.github.com/3405600
09:34:19 <applicative> jfischoff: wait, youre right, it was connectedwith the paper
09:35:31 <jfischoff> applicative: I think it is the same technique. It was written in response to someone first creating canny edge detection with accelerate. Having skimmed the paper it does not appear that using that technique is trivial.
09:35:39 <c_wraith> kanedank`: it means you forgot the t in ByteString
09:36:23 <applicative> jfischoff: yes, and no doubt it would be different with the modified repa anyway, though in my limited experience it is now  easier to user
09:36:24 <applicative> use
09:36:52 <jfischoff> applicative: you find repa easier to use?
09:37:48 <c_wraith> I think applicative meant that the new versions of repa are easier to use than the old ones
09:37:50 <c_wraith> which they are
09:37:52 <applicative> i just meant the new repa is easier to use than the old repa with the special types for properly evaluated matrices etc.  accelerate Idont know
09:37:52 <jfischoff> ah
09:37:58 <applicative> like c_wraith said
09:39:25 <kanedank`> c_wraith: thank you, can't believe I missed that
09:40:10 <timthelion> kanedank`: try reading with two fingures, so you only end up looking at one letter at a time :P  It's what I do, when I have a "cannot find" error
09:40:28 <ReinH> Man, I am really excited about the next few Haskell Live episodes
09:40:46 <ReinH> I'll be getting into board evaluation, move generation and search
09:40:50 <ReinH> it'll be like a real chess engine
09:40:57 <c_wraith> ReinH: that's good news, since you're the one doing them. :)
09:41:03 <ReinH> c_wraith: exactly!
09:41:09 * applicative was at first thinking ReinH was speaking as a fan of them... 
09:41:16 <ReinH> applicative: I am also a fan of them?
09:41:21 <ReinH> can I be a fan of myself?
09:41:35 <timthelion> ReinH: Slick vim editing.  I use Vim like my grandad uses the mouse compaired to you :D
09:41:43 <ReinH> timthelion: haha :) I've been at it for a while
09:41:57 <ReinH> I still watch the videos and go "ugh you suck at vim wtf"
09:42:03 <ReinH> but ofc we're always the most critical of ourselves
09:42:24 <kanedank`> also, is there an easy way to find out what certain files look like as real world haskell progresses?
09:42:43 <timthelion> kanedank`: which files?
09:43:44 <kanedank`> the source files, like I could see the state of ch10/Pars.hs at the end of the chapter or something
09:43:52 <kanedank`> ch10/Parse.hs
09:44:36 <ReinH> he should put it on github
09:44:42 <ReinH> like some people do ;)
09:44:59 <timthelion> who maintains it? dons?
09:45:07 <applicative> kanedank`: is this something like what youre looking for https://github.com/cyga/real-world-haskell
09:45:32 <mast`> ReinH:  thanks for Haskell Live, by the way! I'm not advanced enough to actually learn from the videos quite yet but it's fun to look at and see what can be done
09:45:32 <ReinH> oh that looks good
09:45:42 <ReinH> mast`: thanks :)
09:46:05 <ReinH> mast`: I don't think the first two videos are super advanced but if I didn't explain something very well I'd be happy to try to clarify
09:46:53 <ReinH> I know I completely flubbed composition and fmap (only two of the most important concepts, ofc)
09:47:13 <mast`> ReinH: well I'm on day 3 (or so) of the learning process (coming from C) so even the chess board included a lot of elements I never could've come up with myself
09:47:30 <ReinH> mast`: :) What are you learning from?
09:47:52 <applicative> kanedank`: the answer to my previous question is no, it's more complicated....
09:48:01 <daniel_-> ReinH please cover testing with quickcheck and hUnit if you can!! i would love to watch a video on it since i feel very weak in the testing area of development
09:48:29 <mast`> "Learn you a haskell for great good" and "The haskell road to logic, maths and programming" (I'm a math major)
09:48:30 <ReinH> daniel_-: yep! I think I'm going to switch to Test.Framework and start testing things soon.
09:48:50 <kanedank`> applicative: thank you! yes, that's exactly what I was looking for
09:48:54 <ReinH> mast`: oh nice. Programming Haskell by Bird is pretty good, as is his functional algorithm design pearls or w/e it's called
09:49:05 <ReinH> Real World Haskell is free online
09:49:35 <mast`> ReinH:  I'll look it up
09:50:00 <ReinH> mast`: if you're a maths major you might enjoy the original paper on monads. It's very approachable and a far better introduction than most of the "tutorials" on teh internets.
09:50:05 <jfischoff> applicative: building with all the necessary optimizations made my images resizing executable run perfectly fast enough with repa. I guess I'll be sticking with repa for now.
09:50:29 <ReinH> jfischoff: yeah, repa looks sweet and I'm thinking about using it for my board representation eventually
09:51:37 <eikke> the Repa-related papers which will be presented during ICFP are great reads as well
09:51:42 <jfischoff> ReinH: I'm liking it so far.
09:51:42 <timthelion> ReinH: what is the "origional" paper called?
09:51:54 <mast`> ReinH:  do you happen to know the name of it? Found a lot of them http://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Monads
09:52:22 <applicative> mast`: the posts of sigfpe might be fun for a math student too, but of course they dont come in any particular order
09:52:54 <ReinH> Monads for Functional Programming by Wadler
09:52:58 <ReinH> pdf: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
09:53:03 <jfischoff> eikke: I'll check them, since I'm heading to ICFP anyway
09:53:14 <mast`> applicative, ReinH: thanks, I'll look it up
09:53:15 <ReinH> eikke: ooh exciting!
09:53:44 <eikke> jfischoff: I'll be there as well (and presenting, but not in Haskell-related things)
09:54:04 <jfischoff> eikke: what are you presenting?
09:54:05 <eikke> but will attend the haskell workshop :)
09:54:13 <jfischoff> likewise
09:54:22 <NoICE> bye guys
09:54:42 <eikke> jfischoff: 2 talks co-authored wiht a colleague (we'll both do one of them), mine at OUD, the other one at CUFP
09:55:30 <ReinH> man I'm sorry I missed the ICFP comp this year :(
09:55:34 <ReinH> I had a lot of fun in 2010
09:55:43 <jfischoff> eikke: I'm just attending, nothing that exciting :)
09:55:45 <ReinH> we haskelled our way to 16th place iirc
09:57:31 <ReinH> so the 2012 competition is some variation on a sokoban solver?
09:58:15 <ReinH> wow, crazy
10:08:27 <kanedank`> what does ==>& mean in real world haskell? I just looked it up in the symbol index and I didn't see it
10:08:40 <kanedank`> ==> is defined in chapter 10
10:09:12 <kanedank`> https://gist.github.com/3405886
10:10:45 <ion> It’s just an operator the code defines.
10:11:15 <applicative> it is going to be the definition of >>= for the monad instance
10:11:23 <n00b6502> something like 'maybe' in c++ - if you made a class Maybe<T> {} which had no accesor , just a functoin to take a function to apply to the result  if it worked and another for failiure - how much of what haskell maybe does would that cover
10:11:41 <edwardk> ion: re the derivation, take a look at e_10 and compare it to the taylor series. its basically evaluating the first so many terms of the taylor series and grabbing off a number of digits it knows are safe
10:11:56 <kanedank`> yep, you're right, it is defined. Jeez, I really have to start rereading this stuff before I post here. Sorry bout that!
10:11:59 <edwardk> it computes _way_ more digits than it uses because its shorter code that way ;)
10:12:04 <edwardk> @where e_10
10:12:04 <lambdabot> (!!2)<$>transpose[show$sum$scanl div(10^2^n)[1..2^n]|n<-[0..]]
10:12:43 <ion> edwardk: Ok
10:12:48 <applicative> kanedank`: they use camel case for local variables in a way I consider confusing, though it increasingly common
10:12:56 <n00b6502> eg Maybe<T> { bool mValid; T mVal; public: template<typenameF>  useValue(F& f) {if (mValid) {f(mValue))} ; }
10:13:44 <rking> Hehe, funny C++.
10:13:53 <rking> s/funny/poor/.
10:14:09 <n00b6502> trying to get the idea across in 1 line, FFS
10:14:21 <rking> Nah, I know. I just laugh at crippled languages as a habit.
10:14:31 <rking> The same thing could be done so much easier in a language like Ruby.
10:14:42 <rking> I don't know enough Haskell to laugh at it from Haskell's vantage point.
10:15:11 <ion> Well… Ruby doesn’t have static type checking. Not *quite* the same thing.
10:15:37 <n00b6502> the thing about c++ is you know how much and what memory is will use
10:15:58 <edwardk> ion: the one for pi is quite similar
10:16:10 <ion> The thing about some languages is you generally don’t have to care.
10:16:36 <MostAwesomeDude> Nothing = object(); Just = namedtuple("Just", "value"); # Hi guys!
10:17:18 <edwardk> it should be a truncated taylor series for 4 * atan
10:17:24 <edwardk> @where pi_10
10:17:24 <lambdabot> (!!2)<$>transpose[show$sum[div(4*10^2^n)(a^i*i)*(2-i.&.3)|i<-[1,3..2^n],a<-[2,3]]|n<-[1..]]
10:17:32 <edwardk> hence the 4 in the div
10:17:42 <n00b6502> what is <4.
10:17:44 <n00b6502> <$>
10:17:49 <ownclo> n00b6502: through memory management requires quite complex toolset for large projects
10:17:56 <ion> n00b6502: fmap
10:17:57 <edwardk>  y - y^3/3 + y^5/5 - y^7/7 + ...
10:18:00 <ion> edwardk: alright
10:18:09 <ownclo> s/through/though/
10:18:18 <edwardk> n00b6502: its just an infix form of fmap
10:18:18 <MostAwesomeDude> :t (<$>) -- n00b6502
10:18:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:18:25 <kanedank`> in this curried function, is fromIntegral being called on a Word8? If so, how is that possible if the type of fromIntegral accepts Num? https://gist.github.com/3405918
10:18:31 <edwardk> > (+1) <$> [1,2,3]
10:18:32 <lambdabot>   [2,3,4]
10:18:36 <edwardk> > (+1) <$> Just 12
10:18:37 <n00b6502> ah nice
10:18:37 <lambdabot>   Just 13
10:18:51 <sopvop1> :t fmap
10:18:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:18:54 <edwardk> its useful when combined with <*>
10:18:59 <n00b6502> that just demystified quite a bit of te more cryptic examples
10:19:05 <edwardk> (*) <$> [1,2,3] <*> [4,5,6]
10:19:11 <edwardk> > (*) <$> [1,2,3] <*> [4,5,6]
10:19:12 <lambdabot>   [4,5,6,8,10,12,12,15,18]
10:19:14 <MostAwesomeDude> :t (<*>) -- You'll see this one too
10:19:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:19:16 <mm_freak> this is so ugly
10:19:16 <ion> kanedank: Word8 is an instance of Num, therefore fromIntegral is implemented for it.
10:19:32 <merijn> mm_freak: Really? I actually find it quite pretty
10:19:34 <mm_freak> come on, guys, you have to admit that liftA* is nicer in almost all cases
10:19:38 <edwardk> > [ x * y | x <- [1,2,3], y <- [4,5,6]]
10:19:39 <lambdabot>   [4,5,6,8,10,12,12,15,18]
10:19:44 <mm_freak> > liftA2 (*) [1..3] [4..6]
10:19:45 <edwardk> mm_freak: no. i dont ;)
10:19:45 <lambdabot>   [4,5,6,8,10,12,12,15,18]
10:19:47 <sopvop1> > liftM (*) [1,2,3] `ap` [4,5,6]
10:19:49 <lambdabot>   [4,5,6,8,10,12,12,15,18]
10:20:07 <ion> > (| [1,2,3] * [4,5,6] |)
10:20:09 <lambdabot>   <no location info>: parse error on input `|'
10:20:21 <edwardk> liftAn is good when you don't want to omit some effects
10:20:24 <sopvop1> Haskell surely is not of "There is only one obvious way to do it" type
10:20:39 <edwardk> <$> <$ <*> and <* compose better for parsing
10:21:00 <c_wraith> most of the ways to do it in haskell are different combinators that the optimizer simplifies down to the same code. :)
10:21:12 <MostAwesomeDude> sopvop1: No, Haskell's more of "There is currently a family of possible ways to do it, and research is ongoing into more advanced methods of doing it in the future."
10:21:37 <sopvop1> damn, I forgot to turn off irc at work :(
10:22:07 <timthelion> I have a program that looks like "images <- mapM loadImage fileNames;images' <- return $ map changeImage images ; mapM saveImage images'...  Right now this program loads all of the images at once(thus filling up my memory and crashing after about 7gigabytes)... Is the only way to fix my program to totally restructure it?
10:22:37 <Cale> sopvop1: /msg nickserv ghost sopvop <password>
10:22:37 <ion> mapM handleImage images
10:22:46 <n00b6502> i thought lazy evaluation was supposed to give you a way to only consume on demand
10:22:48 <sopvop1> Cale: Thanks
10:22:57 <ion> handleImage name = do image <- loadImage name; …
10:23:16 <mm_freak> edwardk: the problem i have with (<*>) is that when i revisit code much later i have a harder time reading it
10:23:19 <timthelion> n00b6502: it doesn't work in this case, because what if you had "mapM print listOfThingsIWantToSay"
10:23:44 <applicative> kanedank`: oh, this looks much better https://github.com/qzchenwl/realworldhaskell
10:23:51 <edwardk> mm_freak: i tend to use <*> and <$> in a very stylized fashion. mostly for building traversals
10:24:02 <timthelion> ion: OK, :/  doesn't really go with my current design, but that's a learning experience I guess...
10:24:04 <edwardk> both f (a,b) = (,) <$> f a <*> f b
10:24:04 <edwardk> etc
10:24:20 <timthelion> n00b6502: if mapM was lazy, than nothing would be said...
10:24:50 <mm_freak> edwardk: it's probably fine the way you use it, but i always prefer liftA*, even when i use (<*) or (*>)
10:25:09 <edwardk> mm_freak: tomato tomahto ;)
10:25:09 <n00b6502> someone told me if i wrote a parser that 'read' a whole file into a string then passed the string to a function processing it.. it would actually do it on demand
10:25:32 <timthelion> n00b6502: that's with readFile and writeFile :) those are magic functions...
10:25:54 <mm_freak> edwardk: in particular i find liftA2 (,) (f a) (f b) easier to read
10:25:55 <edwardk> n00b6502: welcome to lazy io. some people like that, some people invent whole families of tools to avoid using it
10:25:55 <timthelion> n00b6502: readFile is magic.  writeFile is normal.
10:26:06 <applicative> n00b6502: that's  right, but it has advantages and disadvantages
10:26:31 <n00b6502> so you'd need loadFile ... parseImageFile:: String->Image perhaps
10:26:31 <edwardk> mm_freak: i don't mind liftAn, but it grates on me when i exceed the number of liftAns in control.applicative and then have to switch notation ;)
10:26:47 <n00b6502> heh no
10:26:52 <mm_freak> edwardk: in that case you usually also switch style =)
10:26:55 <timthelion> edwardk: other than the "side-effectfullness of necessity" when doing lazy IO is there any major dissadvantage?  Seems to be really good for the memory consumption
10:26:56 <n00b6502> a lazy binary stream ?
10:27:14 <mm_freak> edwardk: if liftA3 is not sufficient, you probably want multiple lines anyway, in which case i prefer (<$>) and (<*>), too ;)
10:27:22 <applicative> timthelion: how are the images represented?
10:27:31 <edwardk> timthelion: the problem with lazy io is that you can observe when it happens if your application does things like rename files around
10:27:50 <ReinH> applicative: who uses camelCase where?
10:27:58 <edwardk> mm_freak: well, don't look too closely at the guts of lens then, the amount of <$> and <*> in there will drive you crazy ;)
10:28:00 <timthelion> applicative: Codec.Picture.Types Image
10:28:24 <applicative> ReinH: it was in an example from RWH kanedank` was talking about.  I attributed his confusion to the dubious style
10:28:32 <edwardk> ReinH: i do, but i try to keep my usage of the convention vacuous by choosing single word names ;)
10:28:37 <ReinH> applicative: wait so camelCase is dubious style?
10:28:50 <timthelion> edwardk: I wouldn't sugest lazy IO for anything other than reading from disk/network. but for that it seems quite usefull...
10:29:12 <timthelion> applicative: they are stored internally as Vector Word8
10:29:13 <edwardk> timthelion: sure, but like i said, it works great right up until you need to start moving files around that you could be lazily reading
10:29:18 <applicative> ReinH: no, I was thinking in that sort of case its doubtful
10:29:22 <edwardk> its damn convenient
10:29:27 <edwardk> but it is a leaky abstraction
10:29:43 <applicative> ReinH: https://gist.github.com/3405886 namely
10:29:59 <timthelion> edwardk: Agreed.  But for me, the damned convenience is too apealing. :D  ^_^
10:30:04 <applicative> lazy io is miracle of human thought.
10:30:05 <edwardk> yep
10:30:09 <n00b6502> timthelion: in your example is it possible to do something like mapM  (writeImage.changeImage.loadImage) filenames
10:30:31 <edwardk> n00b6502: you have to write to new names if you use lazy io
10:30:57 <timthelion> n00b6502: It is.  However, my architecture isn't really built for that ...
10:30:58 <n00b6502> does lazy IO let it re-order execution for async IO and processing :)
10:31:05 <merijn> Aren't iteratees/conduits basically lazy IO without the downsides? :p
10:31:26 <applicative> ReinH: I consider firstParser and secondParser there to be a good case for so-called snake casing in Haskell
10:31:29 <aristid> merijn: to be politically correct you must include pipes in that x/y/z
10:31:40 <timthelion> n00b6502: lazy IO is limited to a small set of cases.  Most of which are necessarilly orderfull.
10:31:42 <mm_freak> merijn: no, they aren't lazy
10:31:45 <ReinH> applicative: snake casing as in python_case?
10:32:01 <squidz> I want to load data into my haskell program from a postgresql database for datamining. Can anybody tell me what the best way to do this is?
10:32:05 <ReinH> applicative: I'm dubious of a coding style that uses more than one case...
10:32:21 <mm_freak> merijn: those packages use coroutines so that they can perform regular strict I/O in a streaming fashion
10:32:38 <n00b6502> seems like haskell might be able to setup some sort of dependancy graph of io requests & subsequent processing
10:33:05 <timthelion> ReinH: what, you don't like nested cases????
10:33:08 <applicative> ReinH: yes, maybe but the use of camelCase is so strongly associated with defined expressions in Haskell, it seems to me nonsense
10:33:12 <n00b6502> oh maybe that is actor-model territory ..
10:33:13 <merijn> n00b6502: Keep in mind that possible and feasible are orthogonal concepts
10:33:35 <ReinH> applicative: really? huh
10:33:43 <ReinH> applicative: do you have any examples of your preferred style?
10:35:16 <applicative> hm good question mostly I just avoid long variables in definitions. camelCasing them feels to me like a syntax violation, since they express generality, not a definite term
10:35:17 <ReinH> n00b6502: if haskell had a dependency graph of IO it would then have n^^2 problems.
10:35:45 <merijn> applicative: heh, why?
10:35:49 <applicative> ReinH: this is coming up because kanedank` misread the passage in RWH not unreasonable
10:36:20 <applicative> merijn: this is just opinion about obviously optional things
10:36:22 <ReinH> applicative: sure, I'm not saying anyone is being unreasonable :)
10:37:06 <applicative> merijn: note that it is fairly recent to use long descriptive terms in definitions like op string int = length string - int
10:37:22 <applicative> merijn: I mean in older haskell you don't see it as much
10:38:21 <applicative> merijn: then I think the resistence to camelCasing in e.g op longString shortString = case shortString of ....  went more recently
10:38:46 <sm> is it not odd that the strict and lazy ByteString types share the same name ?
10:38:53 <merijn> applicative: Of course it's opinion, I was just curious based on what
10:39:16 <merijn> Since I haven't really seen this distinction of limiting camelCasing to generality
10:39:18 <applicative> merijn: but I'm not sure, something like op long short = case short of ...  is always easier to read ,
10:39:27 <sm> ByteString and LazyByteString would seem less confusing
10:40:17 <kanedank`> applicative: thank you for that other link, that has indeed been very helpful and has all the missing parts
10:42:07 <Yenpi> could myou do realtime streaming in haskell? or it has nothing to do with language?
10:42:18 <mm_freak> sm: what's wrong with Bl.ByteString?
10:42:27 <mm_freak> and B.ByteString
10:43:28 <S11001001> Yenpi: naught to do with language, everything to do with language implementation
10:43:57 <mm_freak> Yenpi: the streaming abstractions for haskell are well suitable for real-time streaming
10:45:00 <sm> mm_freak: it's a workaround, but why do they have the same name ? In practice they are different types and I am constantly guessing which one I'm reading about
10:45:06 <sm> in code
10:45:51 <mm_freak> sm: why is that a workaround?  i think it's a sensible way to differentiate the two…  if you have trouble with source code, it's probably a matter of style
10:46:54 <sm> mm_freak: if you gave different types the same name, requiring (local, adhoc) prefixing to differentiate them, anywhere else, it would be regarded as a bad code smell
10:46:58 <sm> why not here ?
10:47:23 <sm> isn't it simpler to call them what they are ?
10:49:07 <mm_freak> sm: you know, ByteString is long enough (one of the main reasons i prefer Text)…  having a consistent, readable coding style is a good way to solve the problem, because this is far from related to ByteString
10:49:18 <mm_freak> imagine you had to write UnboxedVector, StorableVector, etc.
10:49:27 <dispy> http://codepad.org/oGhTZ1l9 << why does he complain about a member I'm just creating?
10:49:40 <mm_freak> having such an argument three times in a type signature would force you to use multiple lines already
10:50:13 <sm> so I'm hearing: ByteString is used for both lazy and strict variants to save typing ?
10:50:51 <mm_freak> no, because both are, well, byte-strings
10:50:52 <aristid> sounds like a weakness in editors
10:51:10 <monochrom> I think in "class Greetings a where ..." you have to give type signatures?
10:51:13 <mm_freak> would you prefer to write LazyState and LazyWriter?
10:51:53 <sm> I'm pretty sure I would prefer to have clear types by default, with local aliases applied for brevity if that's required
10:52:22 <sm> just sayin
10:52:24 <startling> sm: so you'd prefer Data.ByteString.StrictByteString and Data.ByteString.Lazy.LazyByteString?
10:52:24 <mm_freak> i'd prefer not to have too many local aliases, unless you're using the same type for many unrelated things
10:52:34 <mm_freak> i prefer to be able to understand a function by name and type alone
10:52:59 <sm> startling: straw man, that's not necessary
10:53:05 <byorgey> dispy: you have to list a type signature for greet in the class declaration
10:53:30 <sm> mm_freak: me too! I'd like to be able to read random-code-of-the-day and if I see ByteString, not wonder what that is
10:54:06 <dispy> ah okay it works now - thank you
10:54:13 <aristid> sm: i (almost) always import ByteString qualified
10:54:17 <startling> sm, mostly I'm curious. what would you propose?
10:54:24 <mm_freak> sm: this is where you need to write consistent code
10:54:29 <aristid> sm: so it's either B.ByteString for strict, or L.ByteString for lazy :)
10:54:34 <mm_freak> ByteString always means strict, Bl.ByteString always means lazy
10:54:53 <mm_freak> again, think of the 'vector' library
10:55:10 <mast`> ReinH: if you're still around, I just rewatched your Episode 1 and it makes a lot more sense that it did 3 days ago (before I started reading the book) so you were right. Thanks again!
10:55:11 <aristid> mm_freak: but the one-and-only true prefix for lazy bytestrings is L, not Bl!
10:55:22 <mm_freak> after all you have the same problem with 'length'
10:55:27 <applicative> dispy: like so? http://codepad.org/PTsCiWmc
10:55:35 <mm_freak> so you want lazyByteStringLength in future?
10:55:49 <dispy> yeah applicative that is how I wrote it now
10:56:03 <aristid> the only problem with qualified imports is that qualified infix operators are ugly :(
10:56:11 <Yenpi> mm_freak: which streaming abstractions?
10:56:13 <applicative> dispy: ah i see yes
10:56:19 <Yenpi> And would it deploy on ehroku?
10:56:43 <applicative> qualified infix operators are a menace
10:56:52 <mm_freak> Yenpi: conduit, enumerator, iteratee, pipes, etc.
10:56:53 <dispy> I'm still at the beginning, but I already love haskell. Thank you for your help :)
10:57:06 <mm_freak> Yenpi: to some extent also monad-coroutine and FreeT
10:57:13 <mm_freak> (they are the same thing)
10:57:29 <mm_freak> Yenpi: i don't know what ehroku is
10:59:53 <applicative> its funny no one seems to use http://haskell.codepad.org/
11:01:00 <aristid> applicative: Haskell: Hugs, September 2006
11:01:04 <aristid> this is why :P
11:01:31 <applicative> aristid: yeah, but codepad.org is used, and its nice for simple haskell98 io questions
11:01:45 <aristid> mm_freak: are you intolerant of misspellings, or do you not know heroku? :P
11:01:52 <Yenpi> Heroku: cloud web host platform
11:02:01 <aristid> applicative: yeah
11:02:41 <aristid> applicative: http://ideone.com/ is slightly more "current": they use GHC 6.8 ;)
11:02:47 <mm_freak> i don't know heroku =)
11:03:06 * hackagebot glpk-hs 0.3.3 - Comprehensive GLPK linear programming bindings (LouisWasserman)
11:03:26 <aristid> apparently it's now possible to use haskell on heroku, but not officially supported
11:03:41 <applicative> aristid: yeah i know .   I  have a dim memory that one of them is written in haskell
11:05:39 <erochester> aristid, yeah, i've deployed a few small sites there.
11:05:49 <erochester> yesod sites
11:06:08 <erochester> the main catch was to get the right vm to compile on first.
11:06:43 <Yenpi> http://helpx.adobe.com/x-productkb/multi/flash-player-10-new-network.html
11:06:57 <Yenpi> wnna do that but dont really know anything about anyhing here
11:11:55 <Dread_> I'm curious how efficient concat is and whether I should use a difference list.
11:12:08 <applicative> aristid right its codepad that is partly written in Haskell  http://codepad.org/about
11:12:38 <applicative> aristid: thus I prefer it for patriotic reasons :)
11:15:25 <aristid> applicative: yeah it's also far less cluttered
11:15:33 <aristid> applicative: hpaste and codepad are my favorite paste sites
11:15:44 <aristid> gist.github.com is nice, too
11:17:31 <ibiwan> how does haskell do for stateless web services?
11:18:05 <Clint> fine
11:18:41 * ibiwan taps his fingers together
11:19:24 <ibiwan> I'm currently working a php codebase that was given to me in an 80%-complete state.  my hope had been to pythonize it, but it occurred to me haskell might be even more well-suited
11:20:21 <ibiwan> only problem is I've never actually, you know... written anything in haskell
11:20:56 <statusfailed> ibiwan: might be tricky then :P
11:21:03 <ibiwan> details!
11:21:12 <statusfailed> I mean, rewriting something in a language you don't know!
11:21:18 <statusfailed> there are no details haha
11:21:19 <ibiwan> I hadn't written anything in PHP before this, and I've gotten it up to about 95%
11:21:24 <statusfailed> Have you got any time constraints?
11:21:42 <k0ral> hello haskellers, would you please be so kind as to end my suffering by telling me *the* right way to do this:
11:21:44 <statusfailed> how fast do you learn new languages? Have you done anything like Haskell before?
11:21:55 <ibiwan> sort of.  I need to finish the feature set first so we can launch, then I should be able to convince the owner to let me rearch in whatever's most appropriate
11:22:11 <k0ral> I've spend the last day trying to setup a datatype of callbacks
11:22:14 <aristid> ibiwan: learning haskell takes longer than learning PHP.
11:22:24 <ibiwan> I've gone through the SICP lectures and many of the exercises, so I have a general handle on FP
11:22:27 <k0ral> data X = X { callback1 :: m (), callback2 :: m (), ... }
11:22:32 <ibiwan> *nods*
11:23:00 <k0ral> I want m to be polymorphic, (MonadIO m, MonadReader A m, ...)
11:23:11 <ibiwan> I'm fairly good with new languages.  I know H is a new paradigm too, but it's one that looks comfortable as I browse sample code and tutorials
11:23:27 <k0ral> I tried existential quantifier, I tried parametrized datatype, none worked
11:23:34 <mrsrikanth> i'm trying to read a file with floating point values in it. i wrote the following code (http://hpaste.org/73435) to do it. but it is taking aroung 4.5 seconds
11:23:36 <statusfailed> ibiwan: Why not try to make a simplified analogue of what you're going for, and see if you can do it quickly?
11:23:42 <mrsrikanth> am i missing any optimization flags?
11:23:44 <ibiwan> *nods*
11:24:08 <ibiwan> I only had this thought five minutes ago, so I wanted to first see what experienced practitioners thought of the tool-for-use
11:24:09 <applicative> mrsrikanth: how big is the file
11:24:30 <Yenpi> ibiwan: whos gonna maintain your haskell code?
11:24:35 <statusfailed> ^ that's a good question
11:24:40 * ibiwan raises his hand
11:24:46 <Cale> mrsrikanth: Well, if you haven't compiled with -O2, that's a good idea. But tbh, if you're having performance issues here, the problem is almost surely String.
11:24:54 <Yenpi> mm_freak: so pipes maybe?
11:24:59 <ibiwan> but you're right, if we have to make multiple people learn haskell, or I leave and the new guy has to learn it... could be problems
11:25:11 <mrsrikanth> applicative, around 2.2M
11:25:11 <Yenpi> but i dont wanna stream via my server, just user-to-user
11:25:17 <statusfailed> ibiwan: we all really want to say "yes, do it!" though :P
11:25:21 <ibiwan> oh I'm sure
11:25:24 <mrsrikanth> Cale, I have used O2
11:25:24 <Cale> (this program is too simple for the problem to be anything other than the fat representation of String)
11:25:38 <ibiwan> good job restraining yourselves =D
11:25:49 <statusfailed> hehe
11:25:50 <ibiwan> *ponders*
11:26:46 <ibiwan> it seems to me... if someone's gonna be unfamiliar with the language, whether PHP, python, haskell, server-side javascript, whatever... the most expressive one might be the easiest one to understand what's happening where
11:26:53 <ibiwan> PHP is spaghetti central, I've had to spend half my time taking notes and adding comments just to figure out where I need to make changes
11:27:18 <Clint> haskell is way more fun for web programming than php-rails
11:27:33 <statusfailed> ibiwan: Just me, but I find haskell makes me behave in general much better than other languages :)
11:27:47 <statusfailed> and it's fun ^
11:27:55 <nitro2k01> php-rails? Is there such a thing?
11:28:02 <nitro2k01> Tomorrow, cobol on rails
11:28:16 <mrsrikanth> Cale, I have pasted only the relevant part of my program after profiling. what do you mean by fat representation of String? should I be using something else?
11:28:32 <statusfailed> mrsrikanth: ByteString or Text, probably
11:28:34 <Cale> mrsrikanth: yes, Text perhaps
11:28:41 <Cale> Or yeah, ByteString
11:28:47 <applicative> nitro2k01: http://www.coboloncogs.org you mean
11:28:59 <Cale> mrsrikanth: String is a lazy linked list of 32bit Char values.
11:29:12 <dispy> ibiwan: the most expressive one is likely to be the hardest one if you're used to bloated code because you need to change your way of thinking. that's how I think of it ;)
11:29:25 <Cale> mrsrikanth: It's nice for small programs, but you really can't expect very much performance from it
11:29:44 <ibiwan> yeeeah.... but if we train the new guy to think, which language is easiest to add a new feature in?
11:29:44 <statusfailed> applicative: that's amazing :D
11:30:11 <statusfailed> ibiwan: train them to think?
11:30:20 <applicative> statusfailed: geekosaur mentioned it a while back.  the way the screen sort of blinks randomly is awesome...
11:30:22 <statusfailed> oh wait, I just read context
11:30:31 <statusfailed> applicative: yep, brilliant touch :)
11:32:48 * ibiwan wanders off to lunch.  I have more questions for you when I get back! :P
11:33:22 --- mode: wolfe.freenode.net set +o ChanServ
11:35:11 <Dread_> would concat [as,bs,cs,ds] be as efficient as a diff list?
11:35:33 <Expez> ghc -main-is TestCases --make [...] doesn't seem to do anything. It still complains about ambiguous occurrence of main. What gives?
11:36:23 <Expez> I also tried -main-is TestCases.main, but according to the ghc docs those two should be identical
11:36:52 <Yenpi> ibiwan: I think Python is clearer to anyone who hasnt done either python or haskell althopugh haskell might be more expressive
11:37:23 <shapr> Yenpi: I think it depends on the person. Haskell is clearer to some who have zero programming experience.
11:38:33 <srhb> Yenpi: If you switch Python for imperative, then maybe. I've certainly had more luck teaching Haskell to people who already know math, the idea of functions maps more clearly onto the knowledge already there.
11:38:50 <shapr> Yenpi: I've tried teaching people with zero programming experience fifteen minutes of Python and fifteen minutes of Haskell, in different orders.
11:39:10 <shapr> Yenpi: The most common response I got was "x should not be equal x + 1, that makes no sense."
11:39:18 <srhb> Yeah, exactly.
11:39:46 <shapr> Yenpi: That certainly doesn't prove my case, I know it's anecdotal, but that's what I've seen.
11:40:04 <shapr> Although a smaller number of people *did* find Python easier to handle.
11:40:16 <shapr> Yenpi: Any thoughts on why one way or the other?
11:40:27 <shapr> eftersom jag har ingen aning
11:40:33 <srhb> shapr: :-)
11:40:51 <dgpratt> I still think there is an overall advantage to knowing other mainstream programming languages when trying to learn Haskell
11:41:00 <srhb> Did you screen for bakers? Perhaps they think, ok, so x is like a bowl of something..
11:41:07 <shapr> srhb: good question
11:41:07 * srhb is kidding.
11:41:10 <srhb> :P
11:41:32 <srhb> The whole psychology in it seems too involved to attack in any way but a serious study, and who's going to bother doing that...
11:41:36 <shapr> dgpratt: Why so?
11:41:40 <Yenpi> So if I were to connect to webcams via haskell howd i go about it? anyone up for an experiment?
11:41:41 <shapr> srhb: not me
11:41:50 <shapr> Yenpi: client or server side?
11:42:03 <Yenpi> So if I were to connect to webcams via haskell howd i go about it? anyone up for an experiment? What would i need? 2 IPs, some protocol?
11:42:09 <Yenpi> shapr: client to client?
11:42:30 <shapr> Yenpi: I'm confused. Do you want to get image data from webcams with haskell, or what?
11:42:52 <dgpratt> shapr: if nothing else, there is probably a greater confidence that one *can* learn Haskell
11:43:05 <mizu_no_oto> shapr:  non-programmers probably have the advantage in learning introductory things, but once you grok monads and iteratees, experienced programmers probably have the advantage.
11:43:42 <Yenpi> shapr: stream webcams to each other. like chatroulette
11:43:48 <shapr> oh
11:44:10 <shapr> Hm, that would be interesting
11:44:17 <dgpratt> shapr: even putting that aside, though, I think there is a fundamental way of thinking...of problem solving that applies to all programming languages, including Haskell
11:44:24 <shapr> dgpratt: I agree
11:44:36 <shapr> Programming is a separate skill from the language being written.
11:45:31 <Saizan> some languages are associated with very poor problem solving teaching though
11:45:48 <sopvop> is IntMap faster or slower than HashMap?
11:45:53 <c_wraith> some languages are associated with teaching problem creation.  >_>
11:46:06 <Yenpi> shapr: maybe your right , i just find python to be so readable. but maybe to non-programmers haskell wins, i think to people who have programmed but not in haskell or python, python is familiar and very clear
11:46:12 <dgpratt> Saizan: such as? :)
11:47:00 <sopvop> I'm a python programmer, and now I hate what my python happily runs obviously wrong code. Bastard.
11:47:01 <monochrom> cobol wins non-programmers
11:47:37 <dgpratt> to somewhat contradict myself, I was initially quite frustrated at various points when trying to learn Haskell due mostly to my learned expectation that picking up a new PL should be easier than this
11:48:47 <sopvop> haskell is simple, it's just so much different
11:48:53 <Saizan> dgpratt: such as imperative ones, where people learn to simulate execution to understand what the program is doing rather than using some form of induction
11:49:43 <Saizan> dgpratt: and where problem solving becomes tinkering with your program until that execution seems to get where you want
11:51:14 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/51df24fbf33b7059
11:51:43 <Saizan> dgpratt: i guess the people producing these sort of students don't actually work like this, but don't manage to teach them better
11:53:50 <dgpratt> Saizan: you are pretty well describing both my past and present experience with programming languages
11:54:27 <Yenpi> shapr, mm_freak: using pipes, what do i need to connect 2 people via webcam? 2 IP addresses? and how would they see each other?
11:55:05 <dgpratt> Saizan: I'm reluctant to believe it was all for naught :)
11:57:34 <Saizan> dgpratt: it probably wasn't but i'd still wish a different route for a new programmer :)
11:58:08 <dgpratt> Saizan: Agreed
12:01:23 <dgpratt> I've been teaching my 11-year old daughter how to program in Haskell (haven't gotten very far)...
12:01:37 <tomte> I've been harassing google and grep for a long time now ...
12:01:54 <tomte> does anyone know where the message "failserv.hs: user error" gets written to stderr?
12:02:18 <dgpratt> ...if it happens that she takes off with it, I'm not looking forward to the day when I tell her "Oh, well that was very nice, but let me show you how people actually program..."
12:03:04 --- mode: wolfe.freenode.net set +o ChanServ
12:03:47 <rosie> In the following code, can the compiler look into the implementation of getchar, which we only know has the type signature getchar :: Int -> (Char, Int), and see that the Int parameter is unused?
12:03:48 <rosie> get2chars _ = [a,b]  where (a,i) = getchar 1
12:03:49 <rosie>                            (b,_) = getchar i
12:04:20 <mm_freak> rosie: "see" in what way?
12:04:34 <rosie> This may help: the tutorial says "We've added a fake parameter to 'get2chars' but the problem is that the Haskell compiler is too smart! It can believe that the external 'getchar' function is really dependent on its parameter but for 'get2chars' it will see that we're just cheating because we throw it away! Therefore it won't feel obliged to execute the calls in the order we want."
12:05:04 <mm_freak> it doesn't "see" that…  it's just the way haskell works
12:05:11 <mm_freak> the two will be evaluated in an arbitrary order
12:05:17 <ibiwan> Yenpi: that may well be the case.
12:05:28 <mm_freak> for example when you print a, then b, then 'a' will get evaluated first
12:05:51 <ibiwan> my thought was just that if FP is somehow "more appropriate" to a stateless API, it'd be worth looking into
12:05:58 <rosie> because the second get char depends on a result of the first, it would appear the order is enforced
12:06:09 <rosie> is the tutorial referring to the order of the get2char function?
12:07:17 <merijn> rosie: Which tutorial is that? It seems horribly confusing to me...
12:07:34 <rosie> it's not bad, actually. http://www.haskell.org/haskellwiki/IO_inside#What_is_a_monad.3F
12:07:52 <rosie> a few paragraphs into Section 2
12:08:09 <mm_freak> rosie: there is a data dependency there, but that's the only thing forcing the ordered evaluation
12:08:24 <mm_freak> rosie: this is most apparent, when you use get2chars multiple times
12:08:45 <monochrom> we are too polite to delete that page
12:09:28 <merijn> After reading I stand by previous assessment of that tutorial being confusing
12:09:49 <mm_freak> rosie: and that's really not about the compiler being smart…  it's just the way haskell programs are evaluated
12:09:57 <monochrom> that's the problem with most wikis. people are too polite to delete wrong stuff
12:10:43 <rosie> mm_freak: thanks for the heads up
12:12:54 <Cale> monochrom: I like that way of putting it
12:14:11 <Cale> monochrom: That tutorial has bothered me for a long time as well, but hey, it links to my little intro, fixing it is too much work and deleting it seems rude.
12:15:32 <ibiwan> is it wrong anywhere?  or just confusing?
12:16:05 <mm_freak> intuitions about IO are seldomly wrong, but all of them are unfortunate
12:16:08 <monochrom> IO a is not World -> (a, World). far from it
12:16:44 <mm_freak> IO is more like:  data IO :: * -> * where GetLine :: IO String; PutStrLn :: String -> IO (); …
12:16:47 <ion> It’s [World -> (a, World)], so concurrency works.
12:16:52 <ion> (Sorry)
12:16:57 <monochrom> haha
12:17:04 <mm_freak> ion: that's worse, because it doesn't capture forkIO
12:18:00 <mm_freak> btw, it's funny that GHC actually implements IO that way (World -> (a, World)), just that the tuple is strict =)
12:18:25 <monochrom> yes, but that is a code generation trick
12:18:54 <monochrom> well, and no, that is not an implementation. the implementation is in the RTS, clearly
12:19:43 <statusfailed> Wait, so GHC doesn't use Acme RealWorld?
12:19:45 <monochrom> in GHC, World->(a,World) is a lie-to-self to generate sequential code.
12:20:51 <Cale> mm_freak: Also, the World is a type with no constructors.
12:21:38 <ion> BigBang
12:26:08 <ibiwan> hm.  "list of implementations of monads in various languages"
12:26:17 <ibiwan> maybe I should just implement monads in PHP and call it a day
12:26:40 * ibiwan runs off screaming about the umbrellas' battery packs
12:27:12 <mm_freak> Cale: of course
12:27:26 <otters> it shouldn't be hard to implement in PHP
12:27:53 <ibiwan> no, the hard part is getting the rest of the language not to have side effects
12:27:59 <mm_freak> to implement monads in a sensible way in PHP you first have to implement trampolining
12:28:10 <mm_freak> and monadic code will be ugly
12:28:18 <rosie> If "action" is the second parameter of type "IO ()", what is "world"?
12:28:26 <rosie> when :: Bool -> IO () -> IO () when condition action world =    if condition      then action world      else ((), world)
12:28:58 <Cale> rosie: I think he's defining IO a as a function World -> (World, a) or something
12:28:58 <mm_freak> rosie: i strongly recommend not building on that intuition
12:29:16 <rosie> alright, I'll stop reading the article
12:29:32 <jfischoff> repa + devil + bilinear filtering = success! (maybe the edge case is off)
12:29:32 <rosie> mm_freak: what would you recommend instead?
12:29:43 <mm_freak> rosie: think of IO as an EDSL
12:29:45 <Cale> rosie: Have you seen my really small article? (The Introduction to IO linked at the beginning there)
12:29:45 <mm_freak> nothing else
12:29:53 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
12:30:10 <rosie> Cale: Thanks! I'm reading it now
12:30:19 <merijn> rosie: I'd recommend Cale's intro to IO for IO and Learn You a Haskell in general (including monads and IO)
12:31:38 <Cale> rosie: Also see http://www.haskell.org/haskellwiki/Monads_as_computation for when you're actually interested in monads, as I wrote it to capture a few points that I noticed a lot of other descriptions of monads in programming were missing.
12:31:51 <rosie> Cale: thanks agani!
12:34:40 <AeroNotix> is there a "Haskell for Erlangers" post?
12:36:32 <AeroNotix> oo  I found something
12:38:09 <Cale> AeroNotix: I remember seeing a set of slides from a talk about Haskell given to Erlangers, but I'm not sure about a tutorial.
12:38:50 <Cale> http://www.slideshare.net/bos31337/the-other-side-of-functional-programming-haskell-for-erlang-people -- here they are
12:38:50 <AeroNotix> Yes, I believe I am reading the same thing.
12:38:50 <Yenpi> wheres cale intro to IO?
12:38:53 <AeroNotix> http://www.slideshare.net/bos31337/the-other-side-of-functional-programming-haskell-for-erlang-people
12:39:03 <Cale> Yenpi: http://www.haskell.org/haskellwiki/Introduction_to_IO
12:41:25 <AeroNotix> Something that always rustles my jimmies in FP is the lovely definition of a Length function where length (x:xs) = 1 + length xs
12:42:28 <AeroNotix> So haskellhas pattern matching?
12:42:34 <Cale> AeroNotix: yes
12:42:46 <AeroNotix> Excellent
12:44:00 <ibiwan> hm.  is it bad that this is the first monad description I've found that makes sense? http://blog.plover.com/prog/burritos.html
12:44:15 <Cale> lol
12:45:06 <Cale> ibiwan: tbh it's really not a terrible description.
12:45:16 <Cale> I've seen worse
12:46:17 <Cale> (It's almost an accurate description of the list monad)
12:46:32 <shapr> w00t, time to see if I can upload ghcLiVE to hackage!
12:46:49 * shapr bounces tiredly
12:46:51 <johnw> would anyone be willing to review my short article on Monads: http://newartisans.com/2012/08/monads-in-pictures/
12:46:59 <johnw> it's not a tutorial, just an intuition builder (hopefully)
12:47:34 <Cale> johnw: In your very first picture, "f a b" should be "f :: a -> b"
12:47:42 <identity> I was just about to say that.
12:47:45 <johnw> that's a call, not a type signature
12:47:45 <c_wraith> me too
12:47:46 <c_wraith> heh
12:47:50 <johnw> an application
12:47:52 <c_wraith> in that case, the description is wrong
12:48:04 <ion> Then it should be just “f a”.
12:48:05 <c_wraith> a and b are values, not types
12:48:10 <johnw> oh, haha
12:48:54 <identity> johnw: Well, your picture suggests that the "f a b" automatically means that it is a function "f :: a -> b", but you can't derive from the lack of context.
12:49:00 <identity> Providing types would probably be better.
12:49:16 <identity> The same thing applies to the functor example, more or less.
12:49:33 <Nereid> "f a = b"
12:49:44 <Nereid> but
12:49:46 <Nereid> yeah types
12:49:49 <johnw> if I give the type of "f a", then I should give the type of "fmap", which then gets very confusing as to what I'm trying to portray
12:49:54 <johnw> I want to show *use*, not type declarations
12:50:19 <johnw> otherwise, the section on Monads is just going to be a wash
12:51:34 <Cale> The pictures need more tortillas, or at least a naan or something. ;)
12:51:40 <johnw> lol
12:52:35 <Botje> no haskell tutorial without food?
12:52:36 <AeroNotix> naan goes with the currying
12:54:28 <identity> johnw: At any rate, your example says "apply f to a and then to b", but picture says "f :: a -> b"
12:54:48 <johnw> I did?
12:54:55 <aib> I want to write a function which returns an ever-increasing value. Which of the thousands of monad tutorials out there should I look at? :)
12:54:58 <johnw>  I said "maps a value of type a to a value of type b"
12:54:59 <identity> http://newartisans.com/files/2012/08/Function.png
12:55:11 <Twey> Oh, a monad tutorial :þ
12:55:12 <johnw> I guess I should say "map some value a to produce another value b"
12:55:55 <AeroNotix> I hate to be "That guy" but as someone on the outside of the haskell community, doesn't it feel wrong that a core component of the language requires pictures in order to be understood?
12:55:58 <identity> johnw: The picture I just linked says "f a b" which is "a function f with two arguments of type a and b"(I assume you mean that), while the "arrow" in the picture suggests f takes a and returns b.
12:56:06 <johnw> i've updated the picture
12:56:07 <johnw> reload
12:56:08 <timthelion> While we're talking about functions... Is there a real difference between categorical arrows and functions?
12:56:24 <Twey> Nice pictures, though
12:56:29 <ion> aeronotix: Yes, pictures should never be used to gain intuition for anything.
12:56:46 <Twey> AeroNotix: Have you ever heard of ‘UML’?  :þ
12:56:48 <merijn> timthelion: Well, functions are categorical arrows, but not necessarily vice versa, I think?
12:56:50 <AeroNotix> ion: point taken
12:56:50 <timthelion> AeroNotix: Only simple things are usefull, that's why we never use the internets.
12:56:57 <identity> aib: iterate?
12:57:00 <identity> > iterate (+1) 1
12:57:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:57:14 <Twey> AeroNotix: Or ‘flow charts’, for that matter?  :þ
12:57:29 <timthelion> merijn: well that's the thing, is I cannot think of a law that restricts functions, that doesn't similarly restrict arrows.  I cannot think of an arrow that is not a function...
12:57:33 <merijn> Twey: state machine
12:57:34 <johnw> I used pictures -- for lack of any other device -- to more clearly show the connection between Functor and Monad.  But I agree, no metaphor is complete
12:57:49 <identity> johnw: Oh, I'm sorry. Didn't catch that.
12:57:50 <Twey> merijn: Or procedural programming in general
12:57:55 <merijn> timthelion: Simple, streams?
12:58:05 <timthelion> merijn: I'll look them up.
12:58:12 <merijn> s/Simple, //
12:58:24 <aib> identity: I want to do it using monads, to achieve a better understanding of them
12:58:47 * shapr stares at hackagebot 
12:58:49 <merijn> Rather, stream transformers
12:58:50 <timthelion> merijn: I googled streams, nothing usefull, "arrow streams" also nothing usefull, any clues as to a good keyword?
12:58:51 <shapr> hackagebot: FASTER
12:59:44 <timthelion> merijn: "netflix to stream transformers" also doesn't seem so promising in terms of enlightening my understanding of arrows :D
13:00:14 <merijn> I'm not even sure whether stream transformers have restrictions that functions do not, but I think they should
13:00:45 <Twey> > runIdentity . Identity $ iterate succ 1
13:00:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:00:48 <merijn> timthelion: Did you try Google Scholar? It turns up several papers (which may or may not be relevant, I didn't check)
13:00:53 <janua1> When looping through a list, and i need to remember, what is the best way to keep state without passing an extra parameter through the function constantly?
13:00:59 <timthelion> merijn: it's not a matter of them having a restriction that functions do not(for example, most usefull functions in calculus are not step functions, they are still functions though) it's the other way arround!
13:01:08 <janua1> remember *something*
13:01:12 <Twey> janua1: A fold?
13:01:25 <janua1> A fold!?
13:01:35 <aib> readLine :: IO String is a fixed value, always returns the same thing, but when we try to.. "unbox?" the value, the IO operation is performed, correct?
13:01:37 <Botje> janua1: how is this state passed? is it always the same?
13:01:54 <janua1> Botje: I am not passing a state
13:02:10 <identity> johnw: I have a comment on the functor example, which isn't necessarily aon your analogy. "Why do you need functors? Because sometimes you don't just want to go from a to b. Instead, you know that a wraps (or contains, or provides) another value, and what you really want is to apply your function to "the inner value.""
13:02:13 <Twey> > foldr (\a b -> (a, b + a)) 1 [1 ..]
13:02:15 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
13:02:17 <Twey> Er
13:02:18 <Botje> janua1: fine, 'keep' state then ..
13:02:25 <identity> I think this is all well and good, but as a beginner, I didn't understand the "need" for these "containers"
13:02:33 <ReinH> mast`: awesome!
13:02:35 <identity> "Why do we *have* to wrap computations sometimes?"
13:02:36 <identity> etc.
13:02:49 <janua1> Botje: 'Keep' state?
13:02:54 <Twey> > foldr (\t b -> (t, b + t)) (1, 0) [1 ..]
13:02:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
13:03:09 <johnw> identity: interesting
13:03:12 <identity> Really, the only thing that fixed that for me was just using monads, and then understanding why the IO monads was in place and so on. Then it 'made sense'
13:03:17 <janua1> Twey: What does that achieve?
13:03:20 <Twey> Gah.
13:03:21 <johnw> identity: does the mention about integers in lists clarify?
13:03:21 <Twey> Anyway
13:03:23 <merijn> Twey: t is a tuple, and you're doing b + t
13:03:26 <ReinH> identity: because if effects leak out of them, that violates referential integrity and thus purity
13:03:38 <Botje> janua1: *you* said 'keep state' !
13:03:38 <Twey> merijn: Yep, I know.  I'm just light-headed & being stupid.
13:03:40 <merijn> Twey: You probably want to pattern match the tuple in your lambda
13:03:40 <identity> It may make more sense to a mathematician with a category theory background, which I am not.
13:03:40 <ReinH> identity: oh you weren't asking
13:03:57 <identity> ReinH: Haha, nah, I wasn't. I even understand stuff like that now! :)
13:04:02 <ReinH> identity: :)
13:04:22 <Twey> janua1: A fold does exactly that: keeps a state as you go through a list performing some transformation on the state
13:04:41 <identity> johnw: Well, that example about lists works fine, but as a beginner, I remember looking at lists as "lists", perhaps somewhat analogous to arrays in other language(C/++ background), and monads as monads.
13:04:51 <identity> I had a hard time making the connection between list and monads.
13:05:01 <johnw> identity: i get you
13:05:02 <identity> (and understanding the fact that list is a monad)
13:05:25 <identity> I can't really say anything constructive regarding changes to help clarify it, as it just "clicked" at some point for me.
13:05:25 <johnw> the hardest for me was understanding that functions are monads
13:05:26 <shapr> w00t! http://ghclive.wordpress.com/2012/08/20/ghclive-project-escapes/
13:05:37 <ReinH> The "computation that may provide multiple values" analogy is what sold me
13:05:41 <johnw> (or can be)
13:06:05 <timthelion> johnw: functions are not monads.  That's for certain, a value cannot be a monad, only a type can BE a monad.
13:06:16 <johnw> sorry, sorry
13:06:19 <johnw> functions can be monadic values?
13:06:29 <johnw> or, (->) is a Monad?
13:06:42 <Botje> (r ->) is a monad.
13:06:44 <timthelion> I'm not even sure if there is a monad instance fo a -> b.  No clue what bind would be.
13:06:44 <identity> johnw: Yeah. Well, one thing that helped me attach List to monads was that knowing that "monads were computations"(One way to look at it), and that the list monad represented a nondeterministic computation
13:06:45 <monochrom> then don't connect yet. you need to see dozens of examples first
13:06:51 <identity> That could return a value, no value, or many values.
13:07:13 <donri> (->) has the wrong kind for a monad
13:07:17 <Botje> timthelion: replace m by "r ->" in the type of bind
13:07:21 <Botje> see what you end up with :)
13:07:30 <identity> I then made the connection between List and Maybe(0, 1 or many values -> Maybe = one value or no value)
13:07:44 <johnw> :t (+1) >>= 3
13:07:45 <lambdabot> forall a b. (Num a, Num b) => a -> b
13:07:48 <ReinH> identity: right, like "what do you get when you roll two 6-sided dice?"
13:07:53 <johnw> > (+1) >>= 3
13:07:53 <ReinH> > let roll2d6 = do { x <- [1..6]; y <- [1..6]; return (x,y) }
13:07:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
13:07:54 <lambdabot>    arising from a use of `...
13:07:54 <lambdabot>   can't find file: L.hs
13:08:01 <johnw> > (+1) >>= 3 $ 4
13:08:01 <ReinH> > do { x <- [1..6]; y <- [1..6]; return (x,y) }
13:08:02 <lambdabot>   3
13:08:03 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3...
13:08:05 <identity> ReinH: That was *fast* typing.
13:08:14 <identity> ReinH: But yes. Exactly. That's a good way of looking at it.
13:08:14 <ReinH> identity: I did it in ghci just to make sure :p
13:08:19 <identity> ReinH: Haha.
13:08:21 <ReinH> and then failed anyway
13:08:38 <johnw> > (+1) >>= (+2) $ 4
13:08:39 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
13:08:59 <johnw> > (+1) >>= (+) $ 4
13:09:01 <lambdabot>   9
13:09:11 <timthelion> johnw: WTF!!!
13:09:13 <timthelion> :D
13:09:20 <johnw> :)
13:09:27 <johnw> see, I thought I understood that at last :)
13:09:33 <timthelion> that resolves to something like 4 + 4 + 1?
13:09:35 <johnw> yeah
13:09:43 <johnw> +1 becomes the "context" for the upcoming + operation
13:10:08 <kostya> Prelude> (+1) >>= (+) $ 4  <interactive>:20:6:     No instance for (Monad ((->) b0))       arising from a use of `>>='     Possible fix: add an instance declaration for (Monad ((->) b0))     In the expression: (+ 1) >>= (+)     In the expression: (+ 1) >>= (+) $ 4     In an equation for `it': it = (+ 1) >>= (+) $ 4
13:10:23 <johnw> I think you need Control.Monad
13:10:24 <ion> > ((++) =<< reverse) "foobar"
13:10:27 <lambdabot>   "rabooffoobar"
13:10:31 <ParahSailin> :t (+1) >>=
13:10:32 <timthelion> The fact that monad instances are not unique makes them much less magical to me.  You end up having to memorise the various binds...
13:10:33 <kostya> oh yeah
13:10:33 <lambdabot> parse error (possibly incorrect indentation)
13:10:45 <ParahSailin> :t (+1) >>= (+)
13:10:47 <lambdabot> forall a. (Num a) => a -> a
13:11:08 <johnw> timthelion: yes, that finally demystified them for me as well: it's not the Monad that's special, it's each specific implementation of >>=
13:11:17 <donri> > (+a) >>= (+) $ b
13:11:19 <lambdabot>   b + a + b
13:11:40 <timthelion> :t (+2) >>= (+) >>= (+) >> (+)
13:11:41 <lambdabot> forall a. (Num a) => a -> a -> a
13:11:52 <ReinH> donri: you... you can do that?
13:11:52 <timthelion> :t (+2) >>= (+) >> (+)
13:11:54 <lambdabot> forall a. (Num a) => a -> a -> a
13:12:08 <donri> @hackage simple-reflect -- ReinH
13:12:09 <lambdabot> http://hackage.haskell.org/package/simple-reflect -- ReinH
13:12:24 <ReinH> giggity
13:12:32 <donri> :t a
13:12:33 <lambdabot> Expr
13:12:49 <ReinH> SEEMS GOOD
13:13:21 <identity> lambdabot does is the mana pool. The people in here are wizards. And the writers of lambdabot are gods.
13:13:24 <identity> At least where I'm standing.
13:13:27 <identity> -does
13:13:29 <ReinH> this is awesome http://twanvl.nl/blog/haskell/simple-reflection-of-expressions
13:13:56 <johnw> heh, there's already an article called "Monads through Pictures": http://www.bolour.com/papers/monads-through-pictures.html
13:13:58 <johnw> but wow
13:14:04 <johnw> gonna need a while to chew through that
13:15:06 * hackagebot ghclive 0.1.0.0 - Interactive Haskell interpreter in a browser. (ShaeErisson)
13:15:14 <ion> Those pictures make me confused.
13:15:20 <shapr> hackagebot: except that package is BROKEN
13:15:35 <timthelion> shapr: how do you know?
13:15:38 <aib> Given type LEdge b = (Int, Int, b), how do I create a value of type LEdge () ?
13:15:48 <shapr> timthelion: Because I just uploaded it and THEN discovered it's broken.
13:15:56 <rosie> In the following code, why is the result list still wrapped in a monad?
13:16:03 <McManiaC> is there a way to set the --hyperlink-source option for automatic doc creation in the cabal-config-file?
13:16:04 <rosie> sequence :: (Monad m) => [m a] -> m [a]
13:16:05 <rosie> sequence []     = return [] sequence (x:xs) = do v <- x                     vs <- sequence xs                     return (v:vs)
13:16:11 <ion> (42, 1337, ())
13:16:12 <timthelion> shapr: sorry :/  I hate when that happens!
13:16:26 <Yenpi> What are the limits of using Haskell on Heroku? That you dont have bindings to all the addons? Could you fix that yourself?
13:16:36 <Botje> rosie: because of the returns and >>= behind the scenes in the do.
13:16:51 <johnw> rosie: sequence turns a list of monadic values into a monadic value that's a list.  Are you asking why it doesn't strip away the monadic context entirely?
13:17:01 <donri> didn't hackagebot use to link the announced packages?
13:17:03 <timthelion> shapr: But I'm going to read your source code anyways.  Because I'm quite interested in the ghc api.  Do you use ghci monad directly, or with hint?
13:17:20 <shapr> ghcLiVE uses hint
13:17:32 <shapr> hint mostly made everything easier.
13:17:55 <timthelion> shapr: except that weird part about Prelude not being automatically imported, that confused me...
13:18:36 <shapr> Yah, I dunno what's up with that.
13:18:38 <sm> donri: yes it did, I quietly disabled that to reduce noise and heard no outcry
13:18:53 <donri> sm: aww well i've been missing it since :(
13:19:00 <johnw> wow, simple-reflect is amazing
13:19:02 <timthelion> shapr: It makes sense, from a security stand point.  If you wanted to use a custom Prelude and not give access to the standard one
13:19:02 <johnw> thank you so much
13:19:06 <shapr> timthelion: I've had further problems with that that I didn't expect.
13:19:21 <sm> sorry! #haskell poll, should hackagebot include package urls when announcing ?
13:19:23 <aib> what's a value of type () ?
13:19:24 <rosie> Botje: and johns: If return typically works like: return v >>= f = f v, and the function is x >>= \v -> sequence xs >>= \vs -> return (v:vs) what is the f v in this case?
13:19:32 <johnw> aim: () is the only value of type ()
13:19:33 <Twey> sm: Yes!
13:19:39 <ReinH> sm: +1
13:19:45 <shapr> sm: would be nice
13:19:51 <timthelion> shapr: I wrote a small program that I wrote.  A GUI which I load inside of ghci.  I then used a backend and std loop pipes to make it so that the program could evaluate code within it's own world...
13:19:57 <johnw> sm: yes
13:20:15 <donri> I think #haskell is a bit beyond saving from noise anyway
13:20:28 <timthelion> shapr: but then I discovered that ghci forgets everything when you do :load.  So I have to make a more robust system.  One that uses hint probably.
13:20:34 <sm> that's true, but people complain more when it comes from a bot :)
13:20:35 <timthelion> shapr: I want to make the emacs of haskell :D
13:20:41 <shapr> timthelion: That would be awesome :-)
13:20:42 <donri> sm: did someone complain?
13:20:52 <kostya> is there GUI ghci, like on Windows, for Linux?
13:20:53 <shapr> timthelion: Have you seen yi?
13:20:54 <kostya>  I installed ghci on Windows in school today, and loved the GUI. I am kinda tired of Vi.
13:20:56 <timthelion> shapr: I was SOO close, but soo far...
13:21:04 <timthelion> shapr: I've seen yi, didn't grok it though :P
13:21:08 <sm> not specifically about links, I just know there have been hackagebot resisters in the past
13:21:10 <identity> kostya: gvim, you mean?
13:21:28 <kostya> no, like the thingy for Windows
13:21:29 <identity> I'm not sure I follow. You want a GUI around a REPL?
13:21:41 <kostya> with interpreter inside it
13:21:52 <Twey> kostya: Why?  :þ
13:22:00 <kostya> Cause I am a n00b
13:22:05 * sm re-enables links on the strength of today's 5-0 vote
13:22:06 <identity> But it would still basically be a glorified shell window -- such is the nature of a REPL
13:22:10 * shapr hugs boegel 
13:22:18 <Twey> kostya: A GUI around a REPL is basically just a terminal window :þ
13:22:19 <kostya> notice the two 0's used instead of letter o.
13:22:23 <donri> sm: yay :)
13:22:24 <identity> Twey: Precisely
13:22:37 * boegel hugs shapr back
13:22:39 <Twey> kostya: You could probably just wine winghci
13:22:41 <kostya> still, I would like to use ctrl+v ctrl+c
13:22:52 <Twey> kostya: You can set your terminal up to do that
13:22:56 <kostya> good idea, I will try that
13:23:05 <shapr> timthelion: Yi was designed to be the emacs of haskell, it can do run-time reloading of its code
13:23:06 <kostya> but it would look kinda ugly
13:23:14 <donri> someone should add push announcements to hackage2
13:23:15 <identity> Oh. I didn't even know of winghci. What does it provide that makes it better than using the terminal for it?
13:23:17 <Twey> kostya: Not if you make it look pretty
13:23:23 <Twey> Terminals are generally pretty customizable
13:23:41 <Twey> sm: Cool, thanks ^_^
13:23:49 <identity> Huh. ctrl+r = reload etc. I see
13:23:54 <identity> I like this idea.
13:23:55 <timthelion> identity: 3 features that I'm implementing for my own GHCI gui:  1. Easier multiline. 2. live side by side graphical display of tree like data structures, graphic calculator, image manipulation with live preview ect. 3. Built in text editor on the side, so that you can quickly move larger functions to a scratch buffer as you write them.
13:24:05 <kostya> is it possible to make ctrl+c and ctrl+v work in terminal?
13:24:12 * Twey often learns about cool packages after seeing them on #haskell.
13:24:23 <rosie> Botje: and johns: If return typically works like: return v >>= f = f v, and the function is x >>= \v -> sequence xs >>= \vs -> return (v:vs) what is the f v in this case?
13:24:29 <donri> ^C ^V already work in terminals, they just do something more useful ^_^
13:24:30 <Twey> kostya: It's certainly possible; I don't know whether your particular terminal program allows it
13:24:32 <sm> Twey: me too
13:24:33 <Botje> rosie: there is no return v >>= f in that program.
13:24:38 <identity> kostya: I'm sure it is, yes.
13:24:39 <timthelion> shapr: there are problems with that idea.  What is reloaded, everything?  If so, that's too slow, requires too much serialization.  If only partial reloading is possible, what is mutable and what is not mutable?
13:24:45 <Twey> kostya: A lot of terminal apps use C-c and C-v for other things
13:24:57 <Twey> kostya: Middle-click paste is generally more friendly
13:25:02 <identity> Perhaps your window manager can do it -- fluxbox, which I prefer when I use linux, is pretty customizeable
13:25:17 <Twey> The WM has no control over application bindings
13:25:18 <kostya> ok, I will look into that
13:25:19 <identity> It may be able to let you make ctrl+r synonymous with ":r\n"
13:25:41 <Twey> Mm, it could intercept it, but that would be an unpleasant way to do it
13:25:50 <identity> yeah, it would be a hack.
13:26:05 <shachaf> rosie: It's not that return "typically works like" that. In fact you'll pretty much never see "return v >>= f" written.
13:26:18 <shachaf> rosie: Writing that is sort of like writing "0+x" instead of "x".
13:26:28 <identity> timthelion: That sounds pretty cool.
13:26:37 <Okasu> why eval '(List (Atom func : args))' overlaps with 'eval (List [Atom "if", pred, conseq, alt])' ?
13:26:41 <shachaf> It's just one of the laws that means return and >>= behave sanely.
13:26:43 <identity> I would give that a spin.
13:26:50 <identity> Are you working on it for real?
13:26:59 <Twey> It would be nice to have customizable keybindings in GHCi
13:27:03 <rosie> I see. I was just reading the first of three monad laws, and that one was giving the sense that "return v" does nothing and results in v
13:27:08 <johnw> > [1, 2, 3] >>= (+10)
13:27:09 <lambdabot>   No instance for (GHC.Num.Num [b])
13:27:09 <lambdabot>    arising from a use of `e_112310' at <i...
13:27:16 <identity> Twey: That would be beyond awesome indeed.
13:27:17 <johnw> can anyone explain that error for me?
13:27:18 <shachaf> Okasu: Because [Atom "if", ...] is the same as (Atom "if": ...)
13:27:19 <timthelion> identity: it's not done yet :/  It was going to be done a while ago, but I ran into one unexpected hurdle I couldn't get passed, and now I have to redo the backend.
13:27:20 <kgzm> You should be able toc ustomize your keys pretty easily in your terminal emulator.
13:27:35 <johnw> using liftM (+10) fails with a different error
13:27:39 <johnw> > [1, 2, 3] >>= liftM (+10)
13:27:40 <lambdabot>   No instance for (GHC.Num.Num [a])
13:27:40 <lambdabot>    arising from a use of `e_112310' at <i...
13:27:40 <Okasu> shachaf: thanks
13:27:44 <shachaf> rosie: No, that's not accurate. The type of return v is different from the type of v.
13:27:44 <johnw> oh, same error
13:27:46 <statusfailed> how do I find the instance of Monad for (->)?
13:27:48 <Twey> kgzm: Maybe, but I wouldn't want to have C-r always yield ":r\n"
13:27:53 <shachaf> If v :: a, return v :: m a for some Monad m.
13:27:54 <Twey> It should be an application setting
13:27:57 <identity> timthelion: Have you heard of light table?
13:28:11 <timthelion> identity: but yes, I actually was/am working on it.
13:28:19 <timthelion> identity: no?
13:28:23 <johnw> statusfailed: :i Monad
13:28:25 <johnw> statusfailed: in ghci
13:28:35 <johnw> it tells me it's in Control.Monad.Instances
13:28:37 <rosie> shachaf: It's in Section 5 of http://www.haskell.org/haskellwiki/Monads_as_computation. Have I missed something?
13:28:59 <statusfailed> johnw: thanks
13:29:04 <identity> timthelion: It's a bit different IDE that got funded via kickstarter. What you are describing is probably stuff that it would do for you
13:29:14 <shachaf> rosie: You can think of a value :: m a as something that has some effects (which are specified by the m) and, when "run", produces a value of type a.
13:29:15 <identity> provided someone would write a haskell backend for it
13:29:21 <identity> frontend?
13:29:23 <shachaf> rosie: The monad laws as specified there are correct.
13:29:25 <identity> Make it support haskell.
13:29:26 <Twey> rosie: ‘x >>= return’ doesn't mean ‘return x’
13:29:27 <identity> etc.
13:29:28 <kgzm> Middle end.
13:29:39 <shachaf> rosie: But return v is very different from v. Otherwise you could just write v. :-)
13:30:03 <shachaf> rosie: Given this effects-produce thing, "return v" is a value that has no effects, but just produces a value when you "run" it.
13:30:03 <identity> timthelion: Real-time results of code as you write it and so on -- it obviously doesn't work as well for all language, but I am sure Haskell would fit nicely in there somewhere.
13:30:08 <rosie> shachaf: what's the "a value" in "a value :: m a " ?
13:30:23 <Twey> rosie: Also ‘results in v’ doesn't mean that the expression itself returns v
13:30:26 <sclv> grrr
13:30:31 <sclv> trying to install hscurses on windows
13:30:34 <sclv> any tips?
13:30:36 <sclv> i know i did this before
13:30:41 <rosie> Twey: ah, explain?
13:30:58 <shachaf> rosie: For example, getLine :: IO String has the "effects" of asking the operating system to read from stdin and so on, and "produces" a String when you run it.
13:31:17 <Twey> rosie: ‘return v’ returns a program that, when run, returns v
13:31:19 <shachaf> It doesn't "contain" a String, but it describes a way of getting one from the OS.
13:31:32 <dgpratt> shapr: well you had to go and make your new toy depend on the unix package, eh? thanks a bunch! ;-)
13:31:36 <rosie> shachaf and Twey: got it, thanks
13:31:44 <kgzm> Is there a straight forward way to develop on Linux but compile binaries for windows? Or even, can you use GHC to generate C and compile that on windows..? I haven't tried it yet, but I am curious.
13:31:47 <shachaf> rosie: I shouldn't have used IO as an example. :-(
13:31:49 <Twey> rosie: It *doesn't* directly return v (depending on the monad in question, it may not even be possible to actually get v out again)
13:31:57 <statusfailed> johnw: doesn't appear to actually be defined in there...
13:31:58 <shapr> dgpratt: I think luite just fixed that!
13:32:05 <identity> kgzm: There are cross-compilation utilities, yes. I'm not sure if there are for haskell
13:32:26 <dgpratt> shapr: oh? I hope you're right
13:32:33 <valentin> in the function definition there is a let clause, which computes a tuple. Is it executed once function is called or lazily, when one of the tuple elements is required?
13:32:40 <shapr> dgpratt: also, the github repo works, the hackage does not yet
13:32:42 <rosie> Twey: could you give me an example when we couldn't get v out again?
13:32:56 <shachaf> rosie: [1, 2, 3] is also a value :: [] Int. In this case it actually "produces" three separate values. But you can still think of it the same way. :-)
13:33:07 <identity> valentin: When/if the tuple is used, the function that computes the tuple is 'called'.
13:33:11 <sclv> i've given --extra-lib-dirs and --extra-include-dirs  don't appear to get passed through properly?
13:33:16 <timthelion> identity: what I'm doing would be very simple http://desmond.imageshack.us/Himg803/scaled.php?server=803&filename=ghcigtk.png&res=landing
13:33:23 <identity> If it isn't used, it's just an unevaluated thunk.
13:33:29 <kgzm> identity: I guess it doesn't have to be cross compilation, but a portable source (like the C GHC generators) so I don't have to install everything and the kitchen sink on a windows machine would be nice.
13:33:48 <johnw> ah, I needed return ., not liftM
13:33:49 <johnw> > [a] >>= return . (+b)
13:33:51 <lambdabot>   [a + b]
13:33:52 <dgpratt> shapr: well, I tried it from the repo, but apparently about 5 minutes too soon :)
13:33:52 <identity> kgzm: llvm?
13:34:04 <rosie> shachaf: why is that :: [] Int rather than :: [Int} ?
13:34:08 <identity> It can generate an IL, that would work on all llvm installations, wouldn't it?
13:34:08 <kgzm> identity: I think I'll have to take a look at that.
13:34:12 <timthelion> identity: take a look at that screen shot.  You see the last command I typed?  It refers to ghciGtkBackendValues which is a giant data constructor with a bunch of reccords.  One of those reccords, could be the "display" IORef for an openGL window.
13:34:15 <valentin> identity: but tuple is never used as a whole, only elements from it!
13:34:24 <timthelion> identity: so you could type in your commands, and see them displayed in real time.
13:34:29 <ReinH> simple-reflect is blowing my mind
13:34:34 <johnw> ReinH: me too
13:34:34 <shachaf> rosie: Oh, that's just syntax. You can write "[] foo" instead of "[foo]". They're equivalent.
13:34:41 <rosie> shachaf: thanks
13:34:45 <johnw> ReinH: I've added it to my .ghci
13:34:45 <shachaf> rosie: (On the type level. Very different on the value level.)
13:34:49 <sm> shapr: re FASTER, out of concern that hackagebot might have been slacking, I checked timing; ghclive appeared in the hackage feed after 13:04:34 PDT (20:04:34 UTC)
13:34:52 <identity> valentin: i'm not entirely sure. It may depend on the way the tuple is being created. If each element depends on the other, and so on.
13:34:59 <identity> timthelion: Yeah, I see what you mean.
13:35:17 <shapr> sm: ah, I was just being impatient about uploading my very first hackage :-)
13:35:22 <shapr> sm: thanks for checking though!
13:35:29 <rosie> shachaf: could you explain?
13:35:32 <timthelion> identity: the problem, was that, the window itself, is running in GHCI.  One key feature of GHCI is the ability to reload modules...  But when I type :load ghciGtkBackendValues becomes undefined!  So I have to rewrite my backend somehow entirely :(
13:35:38 <shachaf> rosie: Explain what?
13:35:40 <sm> good good. Congrats! I shall now check it out, sounds exciting
13:35:55 <rosie> that [foo] and [] foo are the same on the type level but different on the value level
13:36:17 <shachaf> rosie: Oh, it's just a syntactic thing.
13:36:18 <identity> johnw: That is a brilliant idea. It would be so useful to have that around sometimes.
13:36:32 <rosie> shachaf: how are their values different?
13:36:36 <shachaf> rosie: Imagine you defined your own list type: data List a = Nil | Cons a (List a)
13:36:45 <timthelion> identity: did you see my screen shot?
13:36:52 <identity> timthelion: Yep, I'm looking at it.
13:37:01 <nand`> the [Foo] is syntactic sugar for [] Foo on the type-level; and Foo:[] on the value level
13:37:15 <shachaf> rosie: On the type level, you can write "[a]" to mean "List a", but you can also write "[]" to mean "List", so "[] a" also means "List a".
13:37:20 <identity> I'm not sure I understand what you mean. So your GUI runs from ghci?
13:37:21 <timthelion> identity: if you want, I can send you the source code.  But as I said, it's useless :/
13:37:25 <nand`> in addition, [a,b,c] is supported on the value level (a:b:c:[]) but *not* the type level
13:37:34 <shapr> hrm, I need to include a Setup.hs script?
13:37:51 <identity> and when you pass :load/:reload to the ghci binary, that means the GUI dies?
13:37:57 <shachaf> rosie: On the value level, you use "Cons" and "Nil" to create values, but Haskell has a special syntactic sugar for creating lists that also happens to use square brackets. But it's unrelated.
13:38:46 <timthelion> identity: yes.  I have one program that runs ghci as a process, grabing it's stdin and stdout handles
13:38:50 <rosie> shachaf: That makes sense. So how are the two equivalent forms of syntax different on a value level?
13:39:02 <sm> shapr: how has scotty been working for you ?
13:39:19 <shachaf> What do you mean?
13:39:19 <shapr> sm: I switched to Yesod, but I certainly enjoyed scotty.
13:39:25 <sm> oh, oops
13:39:31 <johnw> so [] is both a type constructor and the value for "empty list"
13:39:41 <timthelion> identity: I pipe stdout to stdin, and then send "import Mybackend.blablabla \n ghciGtkBackendValues <- initValues" to stdin.
13:39:45 <shapr> scotty webapps certainly take less time to build than Yesod webapps.
13:39:59 <nand`> johnw: it's not uncommon to see the same name used in both scenarios after all; newtype Foo = Foo ...
13:40:01 <timthelion> identity: and then my backend can talk to itself.
13:40:04 <shapr> I enjoy the convenience of all the Template Haskell in Yesod, but I enjoy the build speed of scotty.
13:40:10 <rosie> shachaf: you said " (On the type level. Very different on the value level.)"
13:40:35 <shachaf> rosie: Oh, well, it's just different syntax sugar that happens to look similar.
13:40:42 <shachaf> rosie: On the value level, "List" doesn't exist at all.
13:40:47 <identity> timthelion: Hmm. I see. But why not have a standalone program that runst he gui, grabs ghci's stdin/out, and runs independently of ghci?
13:40:56 <shachaf> But ASCII only has so many characters so they use "[]" to mean "empty list". :-)
13:41:00 <nand`> rosie: on the value level, [] is a data constructor (the empty list); [x] is sugar for x:[] and [a,B] is sugar for a:[B];  (eg. [a,b,c] -> a:b:c:[])
13:41:12 <sm> shapr: how was yesod's TH convenient ?
13:41:18 <identity> If you wanted commands for your gui, you could just intercept the input, determine if its a command, etc.
13:41:19 <timthelion> identity: Then how would you do instant display of the output?
13:41:56 <identity> timthelion: Of the output of whatever you execute in ghci?
13:41:59 <timthelion> identity: the whole idea, is that the data is in the same data-space.  So I can display something in the openGL window, simply by drawing to it from within ghci.
13:42:03 <rosie> nand: so are they equivalent on the value level?
13:42:08 <shapr> sm: I can embed javascript files in my binary with FileEmbed, for example, or just include everything in my /static/ dir with $(embed "static")
13:42:09 <identity> Aah, like that.
13:42:09 <identity> I see.
13:42:21 <timthelion> identity: take a look at the screen shot.
13:42:24 <nand`> rosie: I don't know what you mean by ‘equivalent’. Equivalent to what?
13:42:27 <shapr> sm: I want users to be able to run the ghclive binary from any directory
13:42:45 <timthelion> identity: the last command I typed is "update" blah blah blah.  I can directly change my program from within it.  Like emacs.
13:42:55 <identity> Yeah, I get you know.
13:43:23 <jfischoff> what would an efficient way to convert a conduit stream into something a repa array?
13:43:31 <shapr> sm: Although cabal allows installed apps to find their data dir, so that might work with scotty, I haven't tried it.
13:43:31 <shachaf> Are what equivalent?
13:44:11 <identity> timthelion: You couldn't intercept the input to ghci when it's :load/:reload, halt it, send some code to it that saves the state, reload the module and then make it reload the old state?
13:44:29 <mizu_no_oto> How difficult would it be to get hoogle to search instances of generic combinators?  e.g. if someone were to search for "(a -> b) -> (c -> d) -> (a,c) -> (b,d)", have that find (***).  Or "[State s a] -> State s [a] " return sequence?
13:45:08 <shachaf> @hoogle [Foo a] -> Foo [a]
13:45:08 <lambdabot> Warning: Unknown type Foo
13:45:08 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:45:08 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
13:45:09 <timthelion> identity: I could, but how am I supposed to serialize arbitrarilly typed state?  I would have to have the user explicitly create a "Serializable" instance for each value, and put that value in a special place...
13:45:27 <shachaf> mizu_no_oto: Hoogle already tries some guesses but I don't think it's type-class aware.
13:45:28 <identity> timthelion: Oh, of course. DIdn't think of that.
13:45:38 <Nereid> @hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,d)
13:45:39 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:45:40 <shachaf> Well, actually, I think it is a little bit.
13:45:45 <Nereid> heh.
13:46:30 <timthelion> identity: I'm going to do something, where I use hint, which allows you to coerse values.  That is, I can evaluate to a typable.  I'll then have the hint Server get an MVar from the interpreted GUI, with all those values, and so the values can stay server side, while the interpreter gets reloaded.
13:46:34 <eacameron> Typeclassopedia has an exercise as follows: Implement Functor instance for ((->) e). I have NO IDEA how to do that and I can't google it. Any pointers?
13:47:04 <identity> timthelion: That sounds smart.
13:47:12 <johnw> eacameron: define what it means to fmap some function a -> b over another function taking an a
13:47:13 <shachaf> eacameron: Just look at the types.
13:47:15 <timthelion> identity: wish me luck :)
13:47:22 <identity> timthelion: Haha, good luck!
13:47:27 <shachaf> eacameron: What's the type of fmap when specialized to ((->) e)?
13:47:32 <identity> Make sure to scream on cafe about it if you finish it.
13:47:36 * hackagebot ghclive 0.1.0.1 - Interactive Haskell interpreter in a browser.  http://hackage.haskell.org/package/ghclive-0.1.0.1 (ShaeErisson)
13:47:37 <identity> I'll give it a spin.
13:47:51 <shapr> w00t
13:48:03 <shapr> Man, that feels good.
13:48:05 <DrTeggy> shapr: Wowereit
13:48:12 <mizu_no_oto> Notice that in neither of those examples are you pointed to, say, Data.Traversable.sequence or Control.Arrow.***
13:48:25 <johnw> > fmap (+a) (+b) $ c
13:48:25 <shapr> grussgott DrTeggy!
13:48:26 <lambdabot>   c + b + a
13:48:36 <DrTeggy> Hi there.
13:48:45 <mwcampbell> How does GHC implement lightweight threads? Does it switch between multiple machine-level stacks, transform code into continuation-passing style, or something else? A pointer to documentation on how that works would be enough.
13:48:46 <mizu_no_oto> But instead some random partially monomorphised versions of them
13:48:47 <Nereid> > fmap f g $ c
13:48:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:48:49 <lambdabot>    `SimpleReflect.FromExpr ...
13:48:49 <sm> shapr: thanks, I see. Yes embedding resources is great. More robust than cabal file paths.
13:48:51 <Nereid> oops.
13:48:56 <eacameron> shachaf: fmap :: (a -> b) -> (e -> a) -> (e -> b) ?
13:48:57 <shachaf> eacameron: The danger of asking in here is that people will immediately give you the answer to the exercise you're trying to solve.
13:49:05 <shachaf> eacameron: Yep!
13:49:05 <johnw> eacameron: that's what I came up with too
13:49:13 <shachaf> eacameron: Now you just need to write a function with that type. :-)
13:49:30 <shapr> sm: Do you know if cabal's data-dir can do the same thing?
13:49:31 <shachaf> eacameron: If that's tricky, that means it's a good exercise.
13:49:42 <eacameron> shachaf: Sweet! man that makes sense...I'll do my best. thanks
13:49:56 <shachaf> mwcampbell: There's a wiki with RTS commentary.
13:50:22 <zungaloca> getting diabetes so much syntactic sugar
13:50:23 <shachaf> mwcampbell: GHC doesn't really use the "machine-level stack" like a lot of other languages do.
13:50:37 <shachaf> @google ghc rts commentary
13:50:40 <johnw> eacameron: hint: the solution will be vastly simpler than the problem :)
13:50:42 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler
13:50:43 <lambdabot> Title: Commentary/Rts/Scheduler – GHC
13:50:45 <luite> mcsmash: it implements it own stacks
13:52:17 <sm> shapr: the same thing, you mean can the web app serve the files out of data-dir ? yes certainly. That way means you can't offer a single-file download, but on the other hand it means someone can tweak the files more easily, so might be preferable for you
13:52:28 <mwcampbell> shachaf: Sorry, I probably used the wrong term; was just trying to unambiguously refer to the stack on which function return addresses and the like are pushed in C and similar languages.
13:52:32 <mwcampbell> shachaf: Thanks for the pointer
13:52:54 <shachaf> mwcampbell: Right, but GHC evaluates code in a rather different way. :-)
13:52:57 <Yenpi> how do i make chrome searchfield "i feel lucky"
13:53:40 <mwcampbell> shachaf: Right, I figured lazy evaluation might have far-reaching implications for the runtime implementation
13:54:30 <shachaf> Well, that was quick!
13:54:45 <sm> shapr: IIRC hledger-web embeds the files, but at startup unpacks them in the current dir for easy, discoverable and multi-instance customisability
13:55:18 <shapr> ah, neat
13:55:21 <shapr> I do like hledger-web
13:55:27 <luite> that sounds really enterprise
13:55:35 <eacameron> shachaf: johnw: If I'm not mistaken, fmap for ((->) e) is just (.)   Is that true?
13:55:42 <sm> luite: nice eh :)
13:55:47 * shapr gives luite the enterprize!
13:55:52 <shapr> one lambda!
13:56:15 <otters> eacameron: yes
13:56:18 <otters> @src fmap
13:56:18 <lambdabot> Source not found. :(
13:56:20 <otters> oh yeah
13:56:23 <otters> @src (->) fmap
13:56:23 <lambdabot> fmap = (.)
13:56:39 <S11001001> :t (.)
13:56:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:56:52 <eacameron> otters: amazing. the types really did make the answer obvious
13:57:58 <shachaf> eacameron: For more exercises of this type, implement instance Applicative (r ->) and instance Monad (r ->). :-)
13:58:14 <eacameron> shachaf: for Functor?
13:58:25 <shachaf> eacameron: No, for Applicative and Monad. :-)
13:58:34 <shachaf> eacameron: Then for twistier exercises, implement the instances for Cont r, where Cont r a = (a -> r) -> r
13:58:51 <otters> wouldn't pure be const?
13:59:02 <mm_freak> edwardk: thanks for free 3.1.1…  it replaces both monad-coroutine and transformers-free for me =)
13:59:41 <luite> shapr: does 0.1.0.1 install from hackage now?
13:59:47 <johnw> eacameron: exactly
13:59:47 <zungaloca> could someone explain me how fromIntegral works?
13:59:50 <johnw> eacameron: good job!
13:59:55 <c_wraith> @src fromIntegral
13:59:56 <lambdabot> fromIntegral = fromInteger . toInteger
14:00:01 <c_wraith> there you go.
14:00:03 <johnw> eacameron: and I take it you also understand why?
14:00:26 <shapr> luite: I think it will, though I didn't remove the unix dep
14:00:46 <sm> shapr: correction, it used to do that. Now it uses embedded files by default, or if built with -fdev it loads them from ./static/
14:00:47 <zungaloca> -_-
14:00:52 * johnw hugs shapr
14:01:00 <DrTeggy> Depending on UNIX is okay
14:01:11 <DrTeggy> *grin*
14:01:12 <donri> unix is dependable
14:01:28 <rosie> In the following quote, is the data structure or the monad computation? "Given a monad M, a value of type M t is a computation resulting in a value of type t. It's important to realise that this is typically just some data structure."
14:01:49 <c_wraith> zungaloca: all types that implement the Integral class have a function toInteger that converts them to an Integer representation.  All types that implement the Num class have a function fromInteger that converts an Integer to that type.  fromIntegral just stitches the two of them together
14:02:04 <johnw> rosie: I think you mis-asked your question
14:02:09 <johnw> rosie: What did you mean to say?
14:02:13 <ReinH> rosie: yes. And also no.
14:02:21 <rosie> ah, whoa sorry
14:02:36 <rosie> I meant to say is the t the data structure, or is the monad computation the data structure?
14:02:44 <johnw> the monad is the data structure, in some cases
14:02:50 <rosie> example?
14:02:54 <johnw> [t]
14:02:55 <DrTeggy> List
14:02:57 <johnw> Maybe t
14:03:00 <rosie> thanks!
14:03:01 <johnw> Either String t
14:03:12 <luite> shapr: it should install on windows with it removed, cna you do an 1.0.2?
14:03:20 <shachaf> rosie: That depends on what you mean by the word.
14:03:31 <shachaf> rosie: Is "Maybe" a data structure, or is "Maybe Int" a data structure?
14:03:35 <shachaf> Take your pick. :-)
14:03:36 <edwardk> mm_freak: nice =)
14:03:39 <ReinH> yes, first define all the words in your sentence and then we will either ask you to define the words in your definitions or give you an answer
14:03:43 <ReinH> and so on
14:03:54 <johnw> even (-> t) ;)
14:04:09 <zungaloca> c_wraith: so how could i write my own implementation of fromIntegral?
14:04:12 <mm_freak> edwardk: i realized that Coroutine is really just FreeT, which is great
14:04:37 <edwardk> mm_freak: yep. that comes up on my blog
14:04:37 <mm_freak> edwardk: what monad-coroutine calls suspension functions are really just the functors you pass to FreeT
14:04:51 <c_wraith> zungaloca: well, fromIntegral is not part of a class. You can't change the existing one. But you could certainly write an equivalent (or similar) function with a new name.
14:05:03 <shachaf> johnw: (-> t) isn't a monad.
14:05:08 <mm_freak> edwardk: the only thing is:  i think FreeT would be easier to understand in terms of Either, just like monad-coroutine does it
14:05:17 <johnw> it's not?
14:05:20 <edwardk> thought about it
14:05:26 <shapr> luite: sure, as soon as I finish the final survey
14:05:38 <edwardk> but the named constructor is more convenient when you are upgrading from Free
14:05:41 <shachaf> johnw: It's not even a Functor (though it's a Contravariant). (t ->) is a Monad, though. :-)
14:05:44 <otters> @src (->) (*>)
14:05:44 <lambdabot> Source not found. You type like i drive.
14:05:47 <johnw> ah, gotcha
14:05:53 <johnw> order matters
14:05:56 <otters> how is (*>) defined for (->)?
14:05:59 <johnw> what are those things called again...
14:06:05 <shachaf> otters: The same way it's defined for every other type.
14:06:08 <johnw> (1+) vs. (+1)
14:06:09 <mm_freak> edwardk: i don't think there is a straightforward way to upgrade from Free anyway
14:06:10 <johnw> sections?
14:06:13 <otters> shachaf: how?
14:06:14 <shachaf> otters: Just look at the source, man.
14:06:17 <shachaf> johnw: Commutative?
14:06:20 <otters> @src (*>)
14:06:20 <lambdabot> (*>) = liftA2 (const id)
14:06:22 <otters> oh
14:06:27 <c_wraith> zungaloca: you can also create new types that are instances of Integral or Num, allowing them to work with the existing fromIntegral
14:06:37 <shachaf> otters: In general instead of using @src, you can go to the actual source files and look there.
14:06:38 <mm_freak> edwardk: so you would probably just find yourself in name clashes when using both Free and FreeT…  i'd prefer an Either-based solution for those reasons
14:06:43 <johnw> no, I mean the way that Haskell curries the function for the missing side
14:06:48 <otters> shachaf: yeah, okay, got it
14:07:00 <shachaf> johnw: Ah. Yes, sections.
14:07:39 <johnw> so, (-> t) is very different from (t ->), although both are type constructors taking a single parameter...
14:07:51 * hackagebot cabal-uninstall 0.1.1 - Uninstall cabal packages  http://hackage.haskell.org/package/cabal-uninstall-0.1.1 (JanChristiansen)
14:08:03 <otters> So in (r ->), *> and <* don't introduce any functionality
14:08:29 <otters> aren't any different from const id and const, anyway
14:08:42 <edwardk> mm_freak: understandable, but i was stuck with the choice of breaking existing transformers-free code or making something compatible. also when switching to Either there is a tendency to want to put Right as the free variable
14:08:49 <shachaf> otters: Right, because (r ->) is a commutative Applicative.
14:08:53 <edwardk> but that gives you the wrong sorting
14:08:58 <zungaloca> c_wraith: fromIntegral :: (Integral a, Num b)=> a -> b   can explain this?
14:09:06 <edwardk> so in the end i went with the named constructors
14:09:27 <sm> ha! cabal-uninstall!
14:09:50 <ReinH> when speaking of Either, can we all agree to say "correct" instead of "right"? :p
14:10:01 <ReinH> unless, ofc, we mean Right
14:10:04 <edwardk> i tend to prefer 'OK' and Error'
14:10:09 <edwardk> er 'Error'
14:10:19 <ReinH> edwardk: I like the original terms: Rescue and Raise
14:10:20 <nand`> I guess I would prefer something like Pure and Fail
14:10:21 <ReinH> er
14:10:24 <ReinH> Return and Raise
14:10:35 <c_wraith> zungaloca: what part of it? I'm not sure what it is you're having trouble with.
14:10:44 <ReinH> original as in the terms Wadler used
14:10:44 <EvanR2> youre naming constructors but what do you call the type
14:10:46 <timthelion> nand`: Pure?
14:11:01 <nand`> timthelion: eg. Pure = pure
14:11:07 <johnw> shachaf: I see what confused me.  The monad is ((->) t), which is the same as (t ->)
14:11:09 <nand`> other way round
14:11:13 <johnw> I was dropping some necessary parens
14:11:14 <EvanR2> data OkOrError a b = Ok a | Error b
14:11:17 <Yenpi> thought it said pure = sure
14:11:30 <Yenpi> EvanR2: Left, Right?
14:11:36 <nand`> I call the type Covelocity
14:11:50 <shachaf> johnw: Yes.
14:12:11 <DT``> @pl \x y -> f x : y
14:12:12 <lambdabot> (:) . f
14:12:12 <shachaf> nand`: "is the same as" is symmetric. :-)
14:12:20 <zungaloca> c_wraith: what is the relation of fromIntegral :: (Integral a, Num b)=> a -> b to fromIntegral 3 + 9
14:12:23 <timthelion> I usually do type Error = String... foo :: Blah->Frog -> Either Result Error...  Does anyone use something more sophisticated than a String for Error? If so, why?
14:12:37 <nand`> shachaf: yeah; I was thinking in terms of the Applicative instance though
14:13:17 <EvanR2> data Result a = Ok a | Error String
14:13:21 <c_wraith> zungaloca: well, that's sort of redundant, as fromInteger is automatically applied to literals
14:13:43 <nand`> when you want to ‘catch’ errors instead of just crashing the application, strings are unfortunate
14:13:55 <nand`> eg. you don't want case foo of Left "file not found" -> ...
14:14:08 <nand`> also, isn't it usually Either Error Result ?
14:14:21 <sm> that doesn't crash the application, unless you handle it by calling error or something
14:14:49 <c_wraith> zungaloca: for a better example, let's look at something like this:  average :: Int -> Int -> Double ; average x y = fromIntegral (x + y) / 2
14:14:51 <aib> given type Memo a = (a -> r) -> a -> r, memoSecond :: Memo b -> (a -> b -> r) -> a -> b -> r would be... memoSecond :: ((b -> r) -> b -> r) -> (a -> b -> r) -> a -> b -> r?
14:14:57 <nand`> sm: what I meant is on a more broad level; if you can't reprocess the error message you're going to have to halt whatever it is you're doing
14:15:02 <timthelion> nand`: does the order matter?
14:15:06 <sclv> trying again: anyone have any luck building hscurses on cygwin?
14:15:14 <sclv> i'm going to start losing hair soon
14:15:17 <nand`> timthelion: the applicative / monad instances are defined with a certain order in mind
14:15:18 <otters> timthelion: Left is bad by convention
14:15:27 <otters> you want to be mapping over your correct result
14:15:36 <c_wraith> zungaloca: in the case of average, the expression (x + y) will have the type Int, because x and y are each Int
14:15:52 <timthelion> otters: I've been doing it wrong all along then :P
14:15:58 <sm> nand`: ok, I might misunderstand, just wanted to say Either String a is usually preferred to exceptions (simpler, purer)
14:16:38 <otters> why isn't Monad a derivable class?
14:16:41 <otters> is there an extension for that?
14:16:44 <c_wraith> zungaloca: but (/) doesn't work with Int, because it means fractional division.
14:16:49 <sclv> nope
14:16:54 <sclv> but there is an extension for deriving functor
14:17:01 <EvanR2> i would like MMORPG to be derivable
14:17:06 <MostAwesomeDude> otters: There is not guaranteed to be just a single valid Monad instance.
14:17:06 <sclv> there's not necessarily one-and-only one monad instance for a given data type
14:17:08 <timthelion> nand`: when doing GUI, I tend to stick with "If an error could occure, keep a good state at hand" "if the error occurs, show a dialog with the String and return to the good state" that's really pretty agnostic as to what the error was.
14:17:14 <wunki> I'm trying to create a cabal file for a new project, but keep getting "Failed to extract GHC build arguments"
14:17:27 <c_wraith> zungaloca: so fromIntegral converts it to a type that supports the / operation - Double in this case.
14:17:29 <wunki> anyone got a pointer what's going wrong?
14:17:41 <zungaloca> c_wraith: ok so fromIntegral 9 + 4.5 is a relation with (Integral a, Num b)
14:17:50 <c_wraith> zungaloca: so, the type of fromIntegral becomes Int -> Double in that case
14:17:57 <nand`> timthelion: yes, which is akin to ‘failing whatever it is you were doing’; but say you want to handle an error that might be as simple as restarting the procedure 5 seconds later, or possibly doing some other cleanup first
14:18:01 <zungaloca> c_wraith: yeah i know what fromIntegral does
14:18:04 * hackagebot ghclive 0.1.0.2 - Interactive Haskell interpreter in a browser.  http://hackage.haskell.org/package/ghclive-0.1.0.2 (ShaeErisson)
14:18:06 * hackagebot wraparound 0.0.1 - Convenient handling of points on a seamless 2-dimensional plane  http://hackage.haskell.org/package/wraparound-0.0.1 (ChristopherHoward)
14:18:24 <c_wraith> zungaloca: Your questions are indicating a fundamental misunderstanding somewhere. So I'm trying to start back at the beginning.
14:18:31 <sopvop> nand`: or localized errors
14:18:51 <otters> MostAwesomeDude: oh, that's why
14:19:08 <timthelion> nand`: I can see that...  Luckly, my using Either Error Result with type Error = String doesn't preclude that in any way :D
14:19:46 <nand`> yeah or what sopvop said
14:20:00 <kanedank`> okay, I'm finding it stupidly hard to make any progress in haskell today. I'm trying to use the library described in ch10 of rwh, and I still don't understand how to actually use the library. Here's my latest attempt: https://gist.github.com/3407996
14:20:12 <c_wraith> zungaloca: so, when the specific types are tied down, the implementation means something.  It uses Int's implementation of Integral to do the toInteger part.  Then it uses Double's implementation of Num to do the fromInteger part.
14:20:47 <zungaloca> c_wraith: if i define a function func5 :: (Integral a, Num b)=> a -> b how is possible that i can do this func5 9 + 4.5 + 9.8, how the definition relates to the use of the fucntion
14:20:54 <dcoutts_> wunki: what command are you running exactly?
14:21:12 <parcs`>  /join c++
14:21:15 <wunki> dcoutts_: cabal-dev ghci
14:21:15 <parcs`> bah
14:21:33 <dcoutts_> wunki: ah ok, I'd assumed you were using cabal init
14:21:46 <c_wraith> zungaloca: Is the part that you're missing return-type polymorphism?
14:21:48 <dcoutts_> wunki: must be a bug in cabal-dev, that error message doesn't appear in cabal/cabal-install
14:22:30 <wunki> dcoutts_: I seem to get this more often, I'm doing something wrong but don't know what
14:22:52 <zungaloca> c_wraith: i guess
14:23:01 <c_wraith> zungaloca: if the type checker can infer the type of an expression from context, it will do so.  That includes the return type of functions with polymorphic return types.
14:23:02 <DanBurton> Random question I thought I'd bring up here. So my advisor is teaching an undergraduate class about programming languages. One of the topics is type systems. The students will be required to write a 3-5 page essay about type systems. They're allowed to write about anything as long as it is relevant to type systems, but he also wants to provide some topic suggestions. What sorts of things would you suggest these students write about type systems?
14:23:03 <dcoutts_> wunki: my only suggestion would be to unpack cabal-dev, grep for the error message and see if you can see what might cause it
14:23:25 <shachaf> 3-5 page essay about type systems?
14:23:31 <c_wraith> zungaloca: a simpler example of that is just fromInteger in Num.
14:23:34 <shachaf> Is that what they make people do in classes these days?
14:23:50 <DanBurton> shachaf: that's what my advisor does :)
14:24:15 <DanBurton> it's not going to be graded on grammar and presentation; basically they just have to intelligently ramble for a few pages about it
14:24:17 * shachaf wonders whether a good piece of writing on any topic has ever come out of an assignment of the form "write a 3-5 page essay about X".
14:24:23 <c_wraith> zungaloca: fromInteger converts an Integer to any particular type of Num.  If possible, it chooses the type based on context.
14:24:49 <kanedank`> specifically, I don't get how to even pass a file handle...
14:25:11 <DanBurton> shachaf: the point isn't to produce "a good piece of writing" per se, it's just to prod the students to enhance their understanding of the topic by exploring whatever portion of that topic interests them
14:25:12 <dcoutts_> DanBurton: demonstrating some understanding of the concepts, things like value, type, what static and dynamic typing are. Then the obvious topics are things like comparing static and dynamic typing, or distinguishing different levels of detail in static types.
14:25:27 <wunki> dcoutts_: I found it here: https://github.com/creswick/cabal-dev/blob/master/src/Distribution/Dev/Ghci.hs#L24 but am non the wiser
14:26:28 <zungaloca> c_wraith: men this syntactic sugar hides everything
14:26:33 <otters> if you define, say, (//) = ($), what fixity does (//) have?
14:26:47 <otters> does it inherit from ($)?
14:27:24 <dcoutts_> wunki: cabal-dev ghci is a hack, it works by running cabal build --with-ghc=fake-ghc-cabal-dev, then it looks at how cabal build calls ghc, then tries to convert that so it can call ghci instead
14:27:34 <dcoutts_> it's an inherently flaky approach
14:27:50 <mizu_no_oto> DanBurton: What kind of class?  Is it based off of TaPL?  Or is it a general "languages" class where you introduce, say, Lisp, Prolog, ML, etc?
14:27:54 <c_wraith> zungaloca: the only relevant syntactic sugar here is that numeric literals are polymorphic.  Everything else is type inference, not any kind of sugar.
14:28:00 <dcoutts_> wunki: and what's happening in your case is that it's failing to extract the list of options used to call ghc
14:28:14 * hackagebot sqlite-simple 0.1.0.2 - Mid-Level SQLite client library  http://hackage.haskell.org/package/sqlite-simple-0.1.0.2 (JanneHellsten)
14:28:17 <shachaf> otters: No.
14:28:37 <DanBurton> mizu_no_oto: it's based off of SICP
14:28:48 <wunki> dcoutts_: am I missing some setting in my .cabal?
14:28:51 <kanedank`> also, what does it mean when a functio/type definition is followed by ()? does that just mean that type enclosed in a tuple e.g. [a]?
14:29:08 <dcoutts_> wunki: no idea, sorry. I'm not familiar with the details of how it does the hack.
14:29:10 <DanBurton> mizu_no_oto: the students will also write a type checker in Racket for the sample language in SICP
14:29:18 <otters> sweet
14:29:34 <wunki> dcoutts_: np, thanks for the help so far :)
14:29:35 <sm> wunki: you could try virthualenv
14:30:02 <wunki> sm: I need cabal-dev to work with my haskell-mode :)
14:30:10 <dcoutts_> wunki: you can try tracing the code, it calls getBuildArgs which calls extractGHCArgs and apparently that's returning []
14:31:49 <mizu_no_oto> DanBurton: ah.  Perhaps you could do what my Abstract Algebra professor did:  a few pages of problems from some advanced part of the book we didn't cover, or read some paper and explain it &  extend the results, or prove some things left as an "exercise to the reader"
14:31:49 <zungaloca> c_wraith: func4 :: Int -> Int -> Int -> Int func4 x y z = x+y+z , here i know it takes three Ints and returns and Int
14:32:14 <wunki> dcoutts_: my knowledge of haskell is not sufficient enough to be able to do that. Soon I hope :)
14:32:38 <meatcomputer> so I'm just going to jump right into this.  I want to *evenually* write a generalized Neural Net using tensors.  Has it been done in Haskell already...?
14:33:10 <dcoutts_> wunki: ah ok, sorry. Eventually "cabal ghci" will be implemented properly in cabal-install
14:33:26 <mizu_no_oto> Dan Burton: Say, extend the type checker to add in X; read about type system Y and do some proofs about it, or compare and contrast two different type systems
14:34:02 <wunki> dcoutts_: will just try the beginners way, changing random things :)
14:34:09 <jfischoff> shapr: congrats on getting ghclive up. Got a link to an up and running instance?
14:34:16 <dcoutts_> wunki: :-)
14:34:46 <zungaloca>  c_wraith: but here func5 :: (Integral a, Num b)=> a -> b i dont get how is the flow here it takes an integral and a Num (=> a-> b) what it does hear
14:34:58 <monochrom> what, wait, what is "cabal ghci"?! :)
14:35:06 <zungaloca> c_wraith: *hear english not my language
14:35:19 <meatcomputer> um. also are there any solid tensor libraries in the stardard toolset already...?
14:35:29 <dcoutts_> monochrom: start a ghci session for a component in a cabal package
14:35:54 <dcoutts_> monochrom: like building with --make, but a ghci session instead
14:37:56 <aib> for "func f x = if (x == 0) then 1 else x * f x" what's a good name for 'f'? "fixpoint"?
14:38:03 <mizu_no_oto> monochrom: I haven't used it, but check out http://hackage.haskell.org/package/tensor
14:38:08 <shachaf> aib: "self"?
14:38:18 <aib> shachaf: right. thanks :)
14:38:23 <monochrom> open_factorial
14:38:25 <shachaf> aib: f isn't the fixed point of func. "fix func" is the fixed point of func.
14:38:26 <mizu_no_oto> meatcomputer: I haven't used it, but check out http://hackage.haskell.org/package/tensor
14:38:35 <mizu_no_oto> sorry, messed up the names
14:38:56 <monochrom> err, nevermind
14:38:58 <otters> how does fix know when to stop ._.
14:39:05 <nand`> it never stops
14:39:18 <monochrom> fix does not know when to stop. whatever you pass to fix does
14:39:21 <otters> > fix (const "Hello!")
14:39:22 <lambdabot>   "Hello!"
14:39:28 <Cale> shachaf: but when you apply fix to this, f will be the fixed point too
14:39:31 <otters> oh
14:39:35 <otters> ...right
14:39:45 <c_wraith> zungaloca: (you wanted "here", actually, but no worries).  that function only takes one argument. the argument is of any type a - but there is a restriction on a that means it must be an instance of Integral.  The return is of any type b - but there is a restriction on b that means it must be an instance of Num
14:40:18 <monochrom> fix (const "hello") -> const "hello" (whatever) -> "hello". const knows when to stop
14:40:36 <monochrom> (it always stops :) )
14:40:39 <shachaf> Cale: That's true. I supposed it's a valid name.
14:40:59 <aib> shachaf: and what would be the noun/adjective to describe f, the function, itself? such as "a fixable function"?
14:41:04 <shachaf> s/d / /
14:41:11 <c_wraith> zungaloca: You can think of the context portion of a type signature as restricting polymorphism. Instead of specifying arguments, it specifies restrictions on the arguments after the =>
14:41:13 <shachaf> aib: f or func?
14:41:14 <wunki> dcoutts_: I managed to pull it of, problem was I didn't export any modules for my library (I think)
14:41:36 <shachaf> I don't think there's a word for in particular. Why do you need one?
14:41:44 <monochrom> another example: fix (\f -> \x -> if x==0 then 0 else f (x-1))  you have a base case "if x==0 then 0", does not call f, that's how it stops
14:42:21 <aib> shachaf: for the commit message, of course :) "made f a -> fixable <- function"
14:42:50 <monochrom> 3rd example: fix (0 :) -> 0 : (whatever)  this stops because the evaluator is happy enough with WHNF which just requires seeing the ":" exposed
14:43:26 <monochrom> (in a sense, ":" always stops, too)
14:44:24 <kanedank`> why does this have a single type?: https://gist.github.com/3408169 why isn't it: Parse Greymap -> Parse Greymap?
14:44:50 <monochrom> because I don't know what ==>& is doing
14:45:34 <monochrom> or rather, what type
14:45:35 <Cale> kanedank`: It doesn't appear to have any parameters, and apparently the result of ==> is a Parse Greymap
14:46:26 <Taslem> Is it ever acceptable to use unsafePerformIO?
14:46:36 <monochrom> sometimes
14:46:49 <monochrom> go with your heart. you know when and when not
14:47:08 <c_wraith> Of course it's acceptable.  It just means you need to prove it's correct.
14:47:14 <Taslem> I'm trying to load in a large text file that really doesn't belong in source. For debugging, mostly, I want to keep it side-effect free.
14:47:31 <Taslem> During the course of the program it won't change, so that's acceptable?
14:47:39 <Clint> is there an Either-to-Maybe utility function?
14:48:13 <c_wraith> Taslem: that case is questionable. It sort-of-works, but it can have unexpected side effects.
14:48:22 <Taslem> Like what, exactly?
14:48:34 <Taslem> I'm trying to figure out if there's a better way to do it that's as convenient at least for debugging.
14:48:47 <c_wraith> If the expression gets inlined, the file can be read multiple times, for instance
14:49:03 <c_wraith> Which means that if it changes in between those reads, you get inconsistencies
14:49:15 <Taslem> Like I said, it won't during the course of the program's life.
14:49:15 <n00b6502> are there any other lanugages that do lazy eval to the same extent as haskell
14:49:57 <c_wraith> the most common approach to doing something like that sanely is using template haskell to inline the file contents as a string literal at compile time.
14:50:07 <zungaloca> c_wraith: to make this clear not correct (Integral a)->(Numb)
14:50:39 <Taslem> Oh, right. I hadn't thought of TH.
14:51:21 <c_wraith> zungaloca: that expression would mean something else, in haskell. It would mean that Integral and Num are type constructors that expect arguments. That's not the same thing as being classes.
14:52:41 <kanedank`> here's my current code: https://gist.github.com/3408209 and the error: https://gist.github.com/3408225
14:54:13 <MostAwesomeDude> @hoogle Either a b -> Maybe b
14:54:14 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
14:54:14 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
14:54:14 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
14:54:26 <monochrom> change "IO String" to "String". change "parsedPGM <- parseRawPGM gmpFile" to "let parsedPGM = parseRawPGM gmpFile"
14:54:30 <zungaloca> c_wraith:     addThree :: Int -> Int -> Int -> Int       addThree x y z = x + y + z    The parameters are separated with -> and there's no special distinction between the parameters and the return type. The return type is the last item in the declaration and the parameters are the first three. Later on we'll see why they're all just separated with -> instead of having some more explicit distinction between the return types and t
14:55:28 <monochrom> but why does parseRawPGM not use its parameter "file"?
14:55:38 <c_wraith> zungaloca: is that from LYAH?
14:55:59 <zungaloca> c_wraith: yes
14:56:01 <monochrom> I quit. too many undefined things
14:56:11 <kanedank`> monochrom: 1). Why take out the IO? When I do :t readFile I get IO String, passing that should still have it wrapped in the IO monad, right?
14:56:12 <zungaloca> c_wraith: just learning
14:56:25 <kanedank`> monochrom: no, it compiles now! thank you, your suggestions fixed it perfectly
14:56:43 <zungaloca> c_wraith: is easy to understand 3 in 1 out
14:56:50 <kanedank`> and secondly: why the let blah = f bar
14:56:56 <aib> given "type Memo a = (a -> r) -> a -> r", "memoSecond :: Memo b -> (a -> b -> r) -> a -> b -> r" would be... "memoSecond :: ((b -> r) -> b -> r) -> (a -> b -> r) -> a -> b -> r", correct?
14:57:22 <shachaf> aib: No.
14:57:25 <shachaf> Where is "r" coming from?
14:57:30 <aib> forall r.
14:57:38 <shachaf> Where?
14:57:41 <kanedank`> I'm used to the lisp let that (to me) means creating an environment with modified lexical bindings.
14:57:43 <zungaloca> c_wraith: :: (Integral a, Num b)=> a -> b what? 1 integral in one float in ???
14:57:44 <aib> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.3/doc/html/Data-MemoCombinators.html
14:57:59 <aib> in Memo. sorry
14:58:01 <monochrom> that is exactly the same let here.
14:58:14 <c_wraith> zungaloca: No, the part before the => is called the context.  It doesn't indicate arguments or return types
14:58:15 <shachaf> aib: OK, so it's "type Memo a = forall r. ..."
14:58:35 <c_wraith> zungaloca: it just limits polymorphism.
14:58:48 <shachaf> aib: In that case, memoSecond :: Memo b -> (a -> b -> r) -> a -> b -> r would be memoSecond :: (forall r. (b -> r) -> b -> r) -> (a -> b -> r) -> a -> b -> r
14:58:51 <pqmodn> zungaloca: it says a -> b, where a is an Integral and b is a Num
14:58:52 <shachaf> Those are two different rs.
14:58:56 <donri> shapr: is ghclive meant to be secure or not?
14:58:59 <c_wraith> zungaloca: so the type signature, as far as arguments and return values are concerned, is a -> b
14:59:07 <kanedank`> but... why create a new lexical binding? in my mind I'm thinking of <- as "=" from python/java inside of it's own environment
14:59:24 <kanedank`> why create a new lexical binding if it's not saving you multiple definitions?
14:59:32 <monochrom> I think ghclive is not meant to be secure by itself. you add your own sandboxing and resource limits outside
14:59:34 <c_wraith> zungaloca: but there are extra restrictions.  a is restricted to being a type that's an instance of Integral.  b is restricted to being a type that's an instance of Num
14:59:58 <monochrom> and I actually like that. it's more customizable.
15:00:46 <pqmodn> kanedank`: sometimes breaking an expression into constituent parts and naming them is clearer than a large monolithic expression
15:00:54 <monochrom> and just out of pragmatics, for example, if you want "use at most 500K memory" it's easier to enforce outside than from inside
15:01:47 <kanedank`> as I side not I don't like this page :( http://www.haskell.org/haskellwiki/index.php?title=&search=%3C-&go=Go
15:02:43 <aib> shachaf: okay. can you tell anything else from the type signature? I can sort of see that Memo x takes a function and returns a modified version with the same type signature, but I can't tell what memoSecond does
15:02:50 <monochrom> well, google isn't doing any better in searching for punctuations either
15:03:02 <zungaloca> :c_wraith so this :: (Num b,Integral a)=> a -> b
15:03:04 <kanedank`> pqmodn: I guess I don't understand what you are saying. So multiline statements with <- to assign state count as one expression? and let allows you to break that chain?
15:03:12 <monochrom> search for "do notation" instead
15:03:18 <zungaloca> :c_wraith will work to
15:03:52 <c_wraith> zungaloca: correct. The order of the parts in the context isn't important
15:03:56 <c_wraith> oh.  too late.
15:04:04 <shachaf> aib: I assume it does the same thing, only it affects the second argument.
15:04:07 <kanedank`> I just seriously don't understand the point of a let if you never use the variable you create in it
15:04:25 <monochrom> sure. then delete that line
15:04:36 <c_wraith> kanedank`: very occasionally, it's useful for the type-checker
15:04:37 <zungaloza> c
15:04:39 <pqmodn> kanedank`: no, <- is used to bind values in do { ... } notation
15:04:43 <c_wraith> zungaloca: correct. The order of the parts in the context isn't important
15:05:21 <kanedank`> pqmodn: okay, so I am on the right page for that? but then why the let? why not just add another random variable to bind against?
15:05:49 <pqmodn> kanedank`: let doesn't "unwrap" monadic values like <- does. for instance...
15:05:53 <monochrom> what haskell tutorial are you following?
15:06:06 <kanedank`> rwh
15:06:30 <monochrom> doesn't it explain IO and "do" and "<-"?
15:06:37 <johnw> is there a way to transform a higher-order function expecting a function a -> b, into a function expecting an Arrow a b?
15:06:55 <johnw> or does the higher-order function just need to be written to use Arrows?
15:07:00 <pqmodn> kanedank`: searching for "do notation" will get you in the right place, i think
15:07:10 <kanedank`> yes, but I'm having trouble understanding it. Specifically I don't get the auto unwrapping you are talking about.
15:07:13 <monochrom> I think that is called "pure"
15:07:19 <monochrom> @type pure
15:07:21 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
15:07:27 <monochrom> sorry, wrong name
15:07:31 <pqmodn> > do { x <- [1,2,3,4]; return $ x + 1 }
15:07:31 <monochrom> @type arr
15:07:33 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
15:07:33 <lambdabot>   [2,3,4,5]
15:07:40 <pqmodn> > let x = [1,2,3,4] in x + 1
15:07:42 <lambdabot>   No instance for (GHC.Num.Num [t])
15:07:42 <lambdabot>    arising from a use of `e_112341' at <i...
15:07:47 <monochrom> yeah, "arr" does that
15:08:04 <monochrom> but I'm misreading the question
15:08:19 <aib> shachaf: yes, but it seems to take a "Memo b" along with a 2+ parameter function, before returning a modified function. all the first-parameter memoizers have type forall r. (a->r)->a->r. I'd expect memoSecond to look like forall a.forall r. (a->b->r)->a->b->r plus or minus the foralls. is this a reasonable line of thought?
15:08:27 <pqmodn> kanedank`: x <- [1,2,3] binds each element to x, for lists, where let x = [1,2,3] doesn't unwrap anything.
15:08:46 <kanedank`> is that why someone suggested String instead of IO String? The <- I used to pass the file handle unwrapped the IO monad?
15:08:54 <monochrom> write your high-order function to expect Arrow. the caller can choose to pass in "arr f" or some other Arrow
15:08:55 <pqmodn> yes, probably
15:09:58 <monochrom> I do not speak of "auto unwrapping" or any "unwrapping" when it comes to IO and <-, by the way.
15:10:09 <monochrom> I disagree with "unwrapping"
15:10:39 <zungaloca> c_wraith: it is smart enough to take x number of integers and x numbers of floats but why the float that comes out isnt defined fromInteger :: Num a => Integer -> a
15:10:57 <kanedank`> monochrom: oh god I hope you're not talking to me about arrows... I saw that on the wiki and walked away
15:11:15 <monochrom> I am not talking to you about arrows
15:12:23 <c_wraith> zungaloca: I'm not sure exactly what you're asking - but I bet the answer is that you're using the number in two different places as if it's two different types. There's no implicit conversion between types in haskell. When you want to convert between types, you have to do it explicitly.
15:13:03 <pqmodn> kanedank`: note these two are equivalent, do notation is syntax sugar: do { x <- [1,2,3]; return $ x + 1; } == [1,2,3] >>= \x -> return $ x + 1
15:13:07 <kanedank`> okay, so a do statement that said do { x <- [1,2,3]; y <- [1,2,3]; z <- [1,2,3]; putStr "x:" ++ x ++ " y:" ++ y ++ " z:" ++ z} will fully print the dimensions of a cube?
15:13:46 <monochrom> you are writing things like "p ==>& \x -> q". a similar story holds for IO. the operator is >>= instead of ==>&. "main = getLine >>= \x -> putStrLn (x ++ x)". "do" and "<-" are translated back to >>=
15:14:26 <kanedank`> should I write things with >>= and >> to strengthen my understanding?
15:14:28 <mm_freak> pqmodn: it's actually a type error
15:14:58 <mm_freak> no, it's even a scope error
15:15:00 <monochrom> I bring up >>= because you are already exposed to ==>&
15:15:12 <monochrom> exploiting what you already know
15:15:16 <mm_freak> or is it?
15:15:21 <mm_freak> the lambda may help
15:15:37 <mm_freak> > [1,2,3] >>= \x -> return $ x + 1
15:15:39 <lambdabot>   [2,3,4]
15:15:42 <pqmodn> mm_freak: huh?
15:15:42 <monochrom> for another person I would use another explanation, exploiting what he/she knows
15:15:44 <mm_freak> yeah, the lambda saves you
15:16:07 <mm_freak> anyway, i was just going to express my aversion against ($) =)
15:16:09 <zungaloca> c_wraith: (Integral a, Num b)=> a -> b take a and b an integer and a float why isnt the float that come out defined like in func4 :: Int -> Int -> Int -> Int func4 x y z = x+y+z
15:16:35 <johnw> is there a const arrow?  I.e., for any Arrow a Bool, I could have it return True?
15:16:51 <nand`> arr (const True)
15:16:54 <johnw> haha
15:16:55 <mm_freak> johnw: arr . const
15:17:01 <zungaloca> c_wraith: in the last one isnt a float but an integer but you understand is defined
15:17:01 <johnw> I was just about to come to that
15:17:05 <johnw> thanks
15:17:10 <mm_freak> johnw: or 'pure'
15:17:25 <mm_freak> technically every arrow is also an applicative functor
15:17:32 <kanedank`> mm_freak: thanks, that lambda explanation did hepl
15:17:34 <kanedank`> help*
15:17:40 <mm_freak> kanedank`: that wasn't my explanation
15:17:41 <monochrom> but it is pretty clear that readFile "filename" >>= \file -> parseGmp file ... cannot possibly be right. mixing up ParserGmp and IO
15:17:51 <mm_freak> kanedank`: thank pqmodn
15:18:09 <kanedank`> thanks pqmodn!
15:18:21 <McManiaC> how do I efficiently replace a couple of bytes in the beginning of a large file without the typical temporary file/new file cycle?
15:18:55 <mm_freak> McManiaC: open a file in AppendMode, seek to the beginning, overwrite
15:18:57 <McManiaC> (binary file, i.e. bytestring)
15:19:15 <monochrom> binary file --> openBinaryFile
15:19:20 <McManiaC> ok
15:19:23 <mm_freak> you can also open in ReadWriteMode
15:20:11 <kanedank`> here is my code atm: https://gist.github.com/3408536
15:21:46 <d-snp> hey, I'm trying to make a monad that is a sequence of operations
15:21:51 <HaskellHacker> is it possible to do something like 'a'++ to get 'b', or 'a'+'c' to get d?
15:21:58 <johnw> how do I get strings like "foo" to become of type Data.Text.Lazy.Text?
15:21:59 <HaskellHacker> because this works:['a','b'..'z']
15:22:04 <johnw> i mean, I want literal strings to have that type
15:22:07 <McManiaC> mm_freak: whats the difference between Write/Append mode?
15:22:11 <johnw> Shelly/Find.hs is doing it, but I don't know how
15:22:17 <monochrom> > succ 'a'
15:22:19 <lambdabot>   'b'
15:22:19 <McManiaC> mm_freak: and how is Append different from RW?
15:22:29 <sm> johnw: {-# LANGUAGE OverloadedStrings #-} at the top
15:22:29 <d-snp> http://hpaste.org/73448 <- am I doing it right, I'm a bit stuck on how to make the bind function
15:22:35 <johnw> ahhh!
15:22:36 <johnw> thank you
15:22:40 <monochrom> no comment on 'a'+'c' = 'd'. ill-conceived
15:22:57 <HaskellHacker> ok, at least 'a'+3 = d
15:23:04 <HaskellHacker> something like that
15:23:18 <HaskellHacker> becuase ['a','c'..'z'] works perfectly
15:23:43 <monochrom> kanedank`, why are you never calling "parse"?
15:23:51 <byorgey> > iterate succ 'a' !! 3
15:23:53 <lambdabot>   'd'
15:24:00 <byorgey> > iterate succ 'a' !! 17
15:24:01 <lambdabot>   'r'
15:24:06 <HaskellHacker> thanks
15:24:11 <McManiaC> d-snp: bind (M a) f = f a should work
15:24:34 <d-snp> oh it gets a monad as a parameter?
15:24:36 <monochrom> > fromEnum (toEnum 'a' + 17)
15:24:37 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:24:38 <lambdabot>         against inferred type ...
15:24:45 <McManiaC> d-snp: yeah usually :)
15:24:45 <byorgey> HaskellHacker: however, if you're trying to do e.g. some basic cryptography, I would suggest just writing your own function which uses ord and chr to convert back and forth to Ints and does the computation there
15:24:49 <monochrom> oops, I swapped them
15:24:53 <McManiaC> @type >>=
15:24:54 <rosie> if I have v <- getLine, v is an IO String, right? If so, then in the definition of sequence: "sequence (x:xs) = do v <- x; vs <- sequence (xs); return (v:vs)" why does v:vs have the type [a] and not [m a] ?
15:24:55 <lambdabot> parse error on input `>>='
15:25:00 <monochrom> > toEnum (fromEnum 'a' + 17) :: Char
15:25:00 <McManiaC> @type (>>=)
15:25:01 <lambdabot>   'r'
15:25:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:25:06 <byorgey> rosie: no, v :: String
15:25:11 <d-snp> ah right ok I missed that
15:25:16 <kanedank`> monochrom: hmmm... I never even thought of that. Thanks for pointing that out!
15:25:35 <HaskellHacker> no, thanks. iterate succ 'a' !! 2 works!
15:26:08 <monochrom> it's slow when you go up to 17 or something
15:26:33 <nand`> > replicateM 17 succ $ 'a'
15:26:35 <lambdabot>   "bbbbbbbbbbbbbbbbb"
15:26:38 <nand`> oops
15:27:17 <nand`> > foldr (.) id . replicate 17 succ $ 'a'
15:27:18 <lambdabot>   Couldn't match expected type `a -> [b -> b]'
15:27:19 <lambdabot>         against inferred type ...
15:27:34 <nand`> oh
15:27:35 <monochrom> great, golfing slow algorithms again
15:27:39 <nand`> yeah
15:27:50 <rosie> byorgey: ah, how should I read the type of the getLine function? I used to read it as getLine :: IO String means getLine returns an IO String. Why is the result of getLine pure?
15:27:54 <nand`> it's not pretty enough to warrant fixing the type error
15:28:00 <monochrom> someone please golf a doubly-exponential algorithm for adding 1 please?
15:28:18 <byorgey> rosie: that is indeed what the type of getLine means.
15:28:26 <byorgey> rosie: however, <- is not assignment.
15:28:39 <byorgey> rosie: <- is syntax sugar for the >>= operation
15:28:45 <byorgey> @type (>>=)
15:28:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:29:06 <monochrom> do not reason about getLine alone. reason about "getLine >>=" in "getLine >>= blah"
15:29:12 <kanedank`> also, why does ghci break on :t >>=?
15:29:18 <nand`> :t (>>=)
15:29:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:29:22 <byorgey> v <- getLine; blah  ===   getLine >>= \v -> blah
15:29:29 <pqmodn> kanedank`: put parenthesis around operator names, :t (>>=)
15:29:30 <kanedank`> oh forgot the parens to make it operator...
15:29:35 <HaskellHacker> what does 2 exclamation points mean? (iterate succ 'a' !! 3)
15:29:41 <kanedank`> array index?
15:29:45 <byorgey> HaskellHacker: list indexing
15:29:45 <nand`> > "foobar" !! 3
15:29:46 <lambdabot>   'b'
15:29:55 <monochrom> "getLine >>= blah" means: the "getLine >>=" part reads a string from the user, then calls the "blah" callback with that string. yes, don't call us, we'll call you
15:30:12 <HaskellHacker> like array[num] in other languages?
15:30:17 <nand`> sort of
15:30:22 <nand`> but on lists, not arrays
15:30:26 <HaskellHacker> ok
15:30:29 <HaskellHacker> got it, thanks
15:30:30 <kanedank`> is it ! on arrays?
15:30:55 <kanedank`> no, that's for maps...
15:31:07 <kanedank`> HaskellHacker: sorry about that wrong answer
15:31:13 <rosie> byorgey: so in getLine >>= \v -> do {<stmts>}  the v is type String and not IO String? Why is that?
15:31:14 <nand`> :t (Data.Array.!)
15:31:15 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
15:31:20 <monochrom> the type "IO String" does not mean "return a string". it means when used with >>=, your callback "blah" must have type "String -> IO your_choice_here", i.e., your callback must take a String parameter
15:31:22 <nand`> looks like it
15:31:45 <shachaf> aib: It does look like that.
15:31:56 <byorgey> rosie: right.  Listen to monochrom.
15:32:21 <mm_freak> McManiaC: Append puts the cursor at the end of the file and disallows reading
15:32:23 <aib> shachaf: except for the Memo b-> at the start which I have no idea how to supply :)
15:32:32 <shachaf> forall r. (... something that doesn't mention r ...) -> (... something that mentions r ...) is the same as (... something that doesn't mention r ...) -> (forall r. ... something that mentions r ...)
15:32:42 <rosie> monochrom: why doesn't the callback function require an IO String?
15:32:48 <shachaf> aib: Oh, well, however you normally make a Memo b.
15:32:58 <shachaf> rosie: Because what would it do with the IO String?
15:33:21 <monochrom> because if everything stayed with "IO String" and nothing ever had type "String", you couldn't write useful code
15:33:28 <shachaf> You already had an IO String at the outset.
15:33:30 <shachaf> @quote /bin/ls
15:33:31 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
15:34:00 <HaskellHacker> @quote random
15:34:00 * hackagebot vector-space-points 0.1.1.1 - A type for points, as distinct from vectors.  http://hackage.haskell.org/package/vector-space-points-0.1.1.1 (BrentYorgey)
15:34:00 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
15:34:15 <monochrom> something has to have type String eventually, so that you can actually use it. just that it is not going to come from "IO String -> String"
15:34:29 <nand`> not sure whether to put fuel on the fire or not, but ‘IO String’ can be seen seen a “computation to produce a String”; and with >>= you are effectively merging two computations together; given some String -> IO Int; you can create a new ‘computation that returns an Int’
15:34:58 <nand`> of course, the computation model is not always sound; and I restricted it to IO for a reason as well
15:35:09 <nand`> for example, a value of type IO () doesn't really seem like a ‘computation to produce a ()’
15:35:17 <monochrom> instead, invert control, have a callback be "String -> ...", now the callback can receive and use that string
15:36:23 <monochrom> I could tell the same story with do-notation instead of >>=, too, but it's a bit more clumsy
15:37:08 <rosie> shachaf: let me know where my understanding is wrong: main executes a series of IO actions, so if getLine returns an IO String, then we could print that string… or I suppose we would use putStrLn that takes a String and returns an IO action that has just a return value of (). I was under the impression that attaching IO to the value helped distinguish it as an "impure" value. How do we keep track of what values came from the 'real world'?
15:37:59 <shachaf> rosie: No, IO isn't a "tag".
15:38:11 <shachaf> A value of type IO String doesn't "contain" a String in any way.
15:38:13 <McManiaC> mm_freak: can I add bytes to the front of a file?
15:38:21 <monochrom> yeah, we're past the "tag" story by 10 years or something
15:38:33 <McManiaC> mm_freak: i.e. move the following bytes back?
15:39:03 <McManiaC> (or forward)
15:39:11 <shachaf> I have a sensible introduction to how IO works that I ought to get around to writing down someday.
15:40:06 <kallisti> rosie: essentially the only way to refer to the String value is to use >>=. you could think of it as a tag, but it's a very contagious one.
15:40:43 <mm_freak> McManiaC: no
15:40:54 <mm_freak> McManiaC: for that you have to rewrite the whole file
15:41:04 <kallisti> rosie: and you can never use an IO String as if it were a String.
15:41:23 <rosie> shachaf: This is a big question, but maybe you could point me to a good answer: How does IO help maintain the purity of haskell code?
15:41:33 <McManiaC> mm_freak: hmm, but at the end I can remove/add bytes as I wish?
15:41:37 <shachaf> rosie: That depends on what you mean by purity.
15:41:47 <mm_freak> rosie: an IO action is just a description, a recipe
15:41:59 <shachaf> conal might argue that it doesn't. :-)
15:42:01 <monochrom> good answer
15:42:23 <mm_freak> you could say that an IO Spaghetti is just a recipe for a Spaghetti
15:42:32 <rosie> haskelll is functional, so the same input will give us the same output. If there are functions that will get input from the outside world, or change some kind of state, then they are "impure". Does that clear up what I mean by "pure" ?
15:42:33 <mm_freak> that's why you can't eat IO Spaghetti
15:43:08 <kanedank`> also, because someone here ran the lambdabot and was right, :t >>= is indeed broken on fedora 17 7.0.4: https://gist.github.com/3408738
15:43:10 <wtetzner> well, the thing about IO is that it's obvious from the type of the function if it's pure or not
15:43:23 <shachaf> rosie: Sort of but not quite. :-)
15:43:25 <kallisti> rosie: IO removes side-effects from Haskell's semantics.
15:43:29 <McManiaC> rosie: is a state monad already receiving "some kind of state"?
15:43:30 <mm_freak> wtetzner: it's always pure
15:43:30 <applicative> kanedank`: you need parens
15:43:32 <kanedank`> nope, forget that, I'm an idiot
15:43:37 <applicative> @type (>>=)
15:43:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:43:39 <shachaf> rosie: Think of a simpler example.
15:43:45 <monochrom> this is where the recipe story comes in. getLine :: IO String is always the same recipe. it doesn't change.
15:44:13 <shachaf> rosie: Pretend IO didn't exist. Now, what are some ways you might embed IO into Haskell while keeping it "pure"?
15:44:19 <conal> kallisti: or perhaps concentrates it in one type, depending on whether you consider IO part of Haskell or not.
15:44:33 <shachaf> rosie: Here's a really simple one: main :: String. When you run a program, the string main is printed to the console.
15:44:38 <applicative> why call it a recipe, why not call it an action (in the sense in which an action can be done many times)
15:44:58 <monochrom> sure, action. getLine is always the same action. it doesn't change.
15:45:01 <mm_freak> applicative: because people seem to get the spaghetti thing =)
15:45:06 <kallisti> I prefer to think of IO as a program. :)
15:45:11 <monochrom> (except that it has just changed from recipe to action)
15:45:22 <mm_freak> kallisti: a composable program, yeah
15:45:24 <shachaf> rosie: Of course, that main can't do very much. :-) So here's a slightly more complex one: main :: String -> String. The user types something in, it gets processed by main, and the output is printed to the console.
15:45:28 <shachaf> rosie: Still pure?
15:45:41 <nand`> shachaf: free monads!
15:45:46 <nand`> (okay I don't think that helps)
15:45:48 <rosie> shachaf: Ask the user for some input. This process of asking requires that we interact with the real world, so we need to identify the return value as "could be anything" aka nondeterministic aka impure.
15:45:53 <rosie> shachaf: not pure, right?
15:45:55 <monochrom> a recipe can be executed many times, too
15:46:02 <shachaf> rosie: But *main* itself is a pure function, right?
15:46:14 <shachaf> rosie: The thing that runs your Haskell program isn't pure, but main is just a function that takes a String and returns a String.
15:46:20 <rosie> shachaf: Is it?
15:46:21 <HaskellHacker> is there comments in haskell (// or /* */ or something else?)
15:46:29 <rosie> ah
15:46:32 <mm_freak> HaskellHacker: --
15:46:32 <shachaf> rosie: Isn't it? main = map toUpper
15:46:34 <mm_freak> and {- -}
15:46:36 <shachaf> Looks like a pure function to me.
15:46:38 <kanedank`> HaskellHacker -- and {- -}
15:46:53 <HaskellHacker> ok
15:47:08 <DanBurton> not entirely Haskell, but not sure where else to ask. I'd like pandoc to syntax highlight code blocks in a markdown file as scheme (Racket, really). I am using ~~~~ {.scheme}\ncode\n~~~~ but it doesn't highlight it (html output). Tips?
15:47:11 <monochrom> String -> String is pure. same parameter implies same return value
15:47:11 <rosie> shachaf: got it. How do we keep track of interacting with the real world?
15:47:20 <shachaf> rosie: What do you mean?
15:47:34 <nand`> I think if ‘IO’ as a reification of real world interactions, personally
15:47:36 <mm_freak> rosie: in the String -> String case simply by laziness =)
15:47:37 <monochrom> try "how do we interact with the real world"
15:47:40 <johnw> I finally think found a legitimate use for arrows
15:47:42 <johnw> https://github.com/yesodweb/Shelly.hs/issues/21#issuecomment-7886136
15:48:04 <rosie> how do we say in our program, we have a lot of functional code, but this part of code is nondeterministic, because the inputs came from an unknown source
15:48:05 <johnw> as a way to build optimized predicates for Shelly's findWhen command
15:48:25 <shachaf> rosie: Well, if you have main :: String -> String, you don't say that.
15:48:30 <nand`> johnw: you're implying arrows have no other use? :(
15:48:31 <shachaf> rosie: Because it really is just a pure function.
15:48:34 <kallisti> rosie: well, in actuality, we use the IO type. though shachaf is discussing a different mechanism.
15:48:35 <mm_freak> johnw: yeah, that's actually a non-monad arrow =)
15:48:35 <DanBurton> rosie: parameterize the code by that input
15:48:48 <johnw> nand`: I am stating that I didn't understand them well enough to know their use until I found one :)
15:48:52 <rosie> DanBurton: could you give me an example?
15:48:55 <kallisti> rosie: the IO type specifies a computation that at some point relies on interaction with the "real world"
15:48:59 <shachaf> rosie: If you have a more complicated way of doing IO -- well, it still works out pretty similarly.
15:48:59 <nand`> johnw: ah
15:49:04 <mm_freak> johnw: did you read about StateA in my tutorial?
15:49:06 <johnw> mm_freak: so I'm breaking the arrow laws?
15:49:13 <monochrom> "main :: String -> String" precisely parameterizes the input
15:49:17 <johnw> mm_freak: did you write http://ertes.de/new/tutorials/arrows.html?
15:49:19 * shachaf wonders whether we should go to #haskell-overflow
15:49:21 <nand`> johnw: he means your arrow can't be made into a monad
15:49:22 <mm_freak> johnw: yeah
15:49:29 <johnw> mm_freak: I loved your article!
15:49:32 <DanBurton> rosie: so for example, suppose you want to write code that produces a random number that is a perfect square.
15:49:35 <johnw> mm_freak: I based this solution on what you wrote
15:49:37 <mm_freak> @ tutorial, not @ breaking =)
15:49:45 <kallisti> rosie: you can only produce other IOs from a given IO. so in this way you're always keeping track of whether or not a computation requires input/output in order to compute.
15:49:51 <DanBurton> rosie: the real code you want to write is just "squared x = x * x"
15:50:14 <DanBurton> rosie: and that way you leave the job of acquiring a random number to the caller
15:50:28 <johnw> this solves the problem rather nicely.  Without arrows, I was envisioning using the FreeMonad to build an interpreter that would first traverse to discover optimizations, then interpret
15:50:31 <mm_freak> johnw: mostly you need to make sure that 'id' is actually an identity
15:50:47 <mm_freak> i.e. when using (&&), then in 'id' you should use True
15:50:52 <mm_freak> for (||) you should use False
15:51:16 <rosie> DanBurton: right. what if in the middle of computing the square we set a global variable, or buy ice cream? I was under the impression that Haskell would require that we say in the function declaration that the function was capable of doing something of the sotr
15:51:23 <johnw> well, my data type just encapsulates a plain function, so my arrow isn't very arrowy.  It's just a souped-up version of "arr f"
15:51:29 <shachaf> rosie: One step at a time. :-)
15:51:35 <johnw> "arr f + meta-state"
15:51:36 <mm_freak> johnw: it's well arrowy
15:51:44 <johnw> haha
15:51:48 <mm_freak> why wouldn't it be arrowy?  after all (->) is also an arrow
15:51:48 <rosie> shachaf: thanks (: I want to understand this well
15:51:58 <johnw> I mean, it's not a sexy arrow
15:52:05 <shachaf> rosie: Here's a function that squares a number, sets a global variable, and buys ice cream: foo :: Integer -> (Integer,GlobalVarType,Bool)
15:52:06 * sm tried to read it and got arrows in his back
15:52:12 <monochrom> "buy icecream in the middle of squaring" is very buggy and disorganized code
15:52:16 <johnw> it's just one step above a pure function
15:52:19 <mm_freak> it's a very sexy arrow in fact…  pure, unlike (->) and still useful =)
15:52:23 <shachaf> rosie: It returns the new value for the global variable, and it tells you whether it decided to buy ice cream.
15:52:28 <DanBurton> rosie: "in the middle of computing the square" isn't exposed to the programmer if it is a pure function
15:52:36 <shachaf> rosie: But as monochrom points out, that's a terrible function.
15:53:13 <monochrom> I know C++ newbie terrible code that asks for user input in a class's constructor
15:53:29 <rosie> shachaf: why are we required to return (Integer, GlobalVarType, Bool) rather than just (Integer)? what if we never use the GlobVarType and the Bool again?
15:53:29 <johnw> monochrom: really?  shoot me now
15:53:41 <johnw> but, at least they aren't asking in a conversion operator
15:53:49 <monochrom> class ComplexNumber { public ComplexNumber() { cout << "please enter the real part" ...
15:53:55 <shachaf> rosie: Well, you asked whether the function would be required to have the type declaration say that it does those things.
15:54:00 <johnw> *face-palm*
15:54:02 <monochrom> totally not the job of a constructor
15:54:06 <shachaf> rosie: I proposed one way of doing that, while "keeping the function pure".
15:54:07 <kanedank`> why can't I just substitute >>= and >> for ==> and ==>&? https://gist.github.com/3408878
15:54:12 <johnw> totally not the job of a complex number type
15:54:29 <johnw> keep your I/O out of my math!
15:54:33 <shachaf> rosie: The actual way you'd do it might be different, but that's the basic idea: The function takes everything it needs as arguments, and returns everything it changes as results.
15:54:33 <monochrom> you can see the same newbie would demand in haskell "how do I buy icecream in a squaring function"
15:54:54 <mm_freak> kanedank`: likely because of fixity
15:54:54 <shachaf> monochrom: Totally. Asking for user input is reserved for the destructors in my code.
15:55:03 <mm_freak> kanedank`: add infixl 1 >>=
15:55:04 <sm> hey, sometimes I really want icecream
15:55:10 <rosie> shachaf: aha. Would the compiler complain if we didn't return something that we changed?
15:55:12 <shachaf> main() { int val; { int_asker foo(&val); } ... }
15:55:28 <shachaf> rosie: It's not so much that the compiler complains, it's that the function doesn't change anything in the first place!
15:55:33 <kanedank`> mm_freak: oh god what does that mean
15:55:36 <monochrom> haha, is that like ~ComplexNumber() { cout << "are you sure to discard this complex number?" ...
15:55:53 <shachaf> rosie: In my example, it's returns a new value for the global variable. Then whoever called the function can set that variable.
15:55:53 <rosie> shachaf: so if we don't return the Bool, we can't buy ice cream? How does the compiler keep us from doing that?
15:56:08 <monochrom> cout << "btw it is done, your input is irrelevant"
15:56:12 <shachaf> rosie: The function *doesn't* buy ice cream. It just tells whoever called it whether to buy ice cream or not.
15:56:16 <mm_freak> kanedank`: operator associtivity and precedence…  "infixl 1 >>=" means that the operator >>= will have priority 1 (low) and will be left-associative
15:56:26 <shachaf> rosie: But you're actually right -- Bool is a terrible type and I shouldn't have brought it into this.
15:56:36 <mm_freak> kanedank`: a >>= b >>= c = (a >>= b) >>= c  -- that's left-associative
15:56:40 <rosie> shachaf: Why can't the original function set the global variable itself?
15:57:00 <kanedank`> mm_freak: well I'd rather learn how to turn this file into 'normal' haskell
15:57:07 <shachaf> rosie: It can. But in Haskell that amounts to doing the same thing in a different way.
15:57:11 <mm_freak> (btw, i never understood why (>>=) and (>>) are left-assoicative…  right-associativity seems to make more sense)
15:57:26 <kanedank`> if I don't change the precedence rules, will I have to rewrite the whole function? or add a ton of parens?
15:57:30 <shachaf> rosie: I'm not saying how IO is actually done, I'm trying to invent ways you *might* do it from first principles. :-)
15:57:38 <mm_freak> kanedank`: parens
15:57:49 <shachaf> rosie: But the way it's actually done is pretty similar.
15:57:54 <kanedank`> is that what you recommend?
15:58:02 <rosie> shachaf: I'm still back at thinking that Haskell doesn't have the kind of purity I thought it did… any pure function seems to be able to change global state…
15:58:03 <mm_freak> kanedank`: i recommend using (>>=) and (>>)
15:58:05 * nand` .oO( main :: [Response] -> [Request] )
15:58:28 <shachaf> rosie: Nope. That's definitely not true.
15:58:48 <shachaf> rosie: square :: Integer -> Integer can *only* return an Integer, and it can only be based on the Integer you gave it.
15:58:54 <Jesin> [18:53:29]	monochrom	class ComplexNumber { public ComplexNumber() { cout << "please enter the real part" ...
15:58:55 <mm_freak> rosie: again, think in actions/recipes as a high-level way of thinking
15:58:56 <Jesin> :(
15:59:10 <JoeyA> Is there a program to unmangle names like this?  postgresqlzmlibpqzm0zi8zi2_DatabaseziPostgreSQLziLibPQ_zdwa6_info
15:59:18 <XexonixXexillion> well, one can always use unsafePeformIO.... *ducks*
15:59:20 <nand`> there's a lambdabot command
15:59:22 <nand`> I forgot what it was
15:59:24 <shachaf> preflex: zdec postgresqlzmlibpqzm0zi8zi2_DatabaseziPostgreSQLziLibPQ_zdwa6_info
15:59:24 <preflex>  postgresql-libpq-0.8.2_Database.PostgreSQL.LibPQ_$wa6_info
15:59:30 <nand`> oh, or preflex it seems
15:59:35 * Jesin drills XexonixXexillion
15:59:55 <rosie> shachaf: I thought you said "square" could set a global variable itself "But in Haskell that amounts to doing the same thing in a different way." I'm not sure what you mean. I want to understand
16:00:11 <shachaf> rosie: Well, square could have the type Integer -> IO Integer
16:00:32 <shachaf> rosie: When it has *that* type, it means that you give it an Integer, and instead of giving you back an Integer, it gives you back a program.
16:00:44 <shachaf> rosie: When you run that program, *it* gives you an Integer, but it might also go buy ice cream.
16:00:47 <mm_freak> rosie: given "main = getLine >>= putStrLn" the following happens (simplified):  the run-time system finds THUNK, which evaluates to GetLine >>= THUNK…  it performs the action GetLine, then evaluates the THUNK and finds PutStrLn…  it passes GetLine's result to PutStrLn
16:00:48 <kallisti> shachaf: I thought you're probably confusing rosie by talking about something as though it's how Haskell actually works.
16:00:54 <kallisti> s/thought/think/
16:01:00 <Jesin> um
16:01:14 <shachaf> kallisti: I think there's too much noise in the channel and people saying different things for a clear explanation. :-(
16:01:18 <mm_freak> rosie: think of GetLine and PutStrLn as regular constructors
16:01:22 <Jesin> I dunno about his previous explanations, but shachaf's  most recent explanations were accurate
16:01:33 <kallisti> I was referring to the main :: String -> String example
16:01:38 <kallisti> and the GlobalVar example.
16:01:39 <Jesin> mm_freak: um
16:01:41 <Jesin> no
16:01:43 <shachaf> I think an explanation that involves the word "thunk" is going to be too confusing.
16:01:44 <Jesin> what?
16:01:51 <Jesin> mm_freak: "constructor" D:
16:01:56 <shachaf> But I like mm_freak's free-monad style explanation in general.
16:01:57 <Jesin> they are not constructors
16:02:03 <nand`> but they could be
16:02:06 <shachaf> Jesin: Conceptually, man!
16:02:19 <kallisti> shachaf: this kind of stuff is /not/ helpful for beginners.
16:02:21 <Jesin> not with MY conceptually!
16:02:23 <nand`> data IO = PutStrLn IO | GetLine (String -> IO)
16:02:27 <nand`> | Done
16:02:29 <shachaf> kallisti: Huh?
16:02:30 <nand`> :P
16:02:39 <Jesin> umm
16:02:41 <Jesin> imo
16:02:50 <mm_freak> shachaf: and i think a historical explanation is too complicated…  rosie's response is good evidence of that
16:02:53 <mm_freak> think simple!
16:02:57 <Jesin> [18:59:50]	shachaf	rosie: Well, square could have the type Integer -> IO Integer
16:02:58 <Jesin> [19:00:11]	shachaf	rosie: When it has *that* type, it means that you give it an Integer, and instead of giving you back an Integer, it gives you back a program.
16:03:00 <Jesin> [19:00:23]	shachaf	rosie: When you run that program, *it* gives you an Integer, but it might also go buy ice cream.
16:03:02 <Jesin> sounds about right
16:03:05 <mm_freak> IO X is the type for an action that results in an X
16:03:06 <shachaf> mm_freak: My explanation isn't historical.
16:03:16 <rosie> shachaf: I think I understand it more. The only way we can set a global variable is by executing the action from main (which will call a series of other functions, which must declare themselves as IO or something that reflects they'll change the global variable if they do want to set the variable). Do I have the right understanding?
16:03:23 <mm_freak> shachaf: historical in the sense of, "how would you add impure stuff to a pure language?"
16:03:24 <shachaf> I think this channel is way too noisy for anyone to make sense of anything it says.
16:03:32 <shachaf> rosie: Yes, that's more or less correct.
16:03:38 <nand`> rosie: you're right in saying that the only way to execute IO stuff is via main (well, almost only)
16:03:51 <kallisti> rosie: in fact you can /only/ access the result of the side-effect by using >>=
16:03:54 <DanBurton> Jensin++
16:03:58 <shachaf> mm_freak: But deriving something from first principles is the best way to understand it almost always!
16:04:20 <rosie> mm_freak: got it. So that's why assignment of x <- IO String produces a String for x, because the IO String is executed and then the String result is returned?
16:04:24 <DanBurton> or rather, shachaf++
16:04:43 <mm_freak> rosie: "<-" is just a nice way to write compositions…  nothing is actually executed
16:04:57 <mm_freak> rosie: do x <- action1; action2 x x
16:05:03 <mm_freak> this is just a composition of action1 and action2
16:05:06 <mm_freak> still another action
16:05:10 <nand`> rosie: something like that; ‘do { x <- (getLine :: IO String); putStrLn x }’ is itself actually an IO action; the RTS technically only ever executes one
16:05:16 <mm_freak> you have given the result of action1 the name x
16:05:17 <kallisti> rosie: do notation is syntax sugar for >>=, if you understand how >>= works then you can figure out what <- means
16:05:21 <nand`> well, not technically; but theoretically
16:05:42 <Jesin> do x <- action1; action2 x x
16:05:43 <Jesin> means
16:05:45 <Jesin> action1 >>= \x -> action2 x x
16:06:15 <shachaf> I count about 10 pages of IRC scrollback that have been devoted to this.
16:06:22 <rosie> Jensin: x -> y is syntactic sugar for x >>= \y ->  do {stmts} right?
16:06:22 <shachaf> This discussion ought to move to #haskell-overflow.
16:06:25 <nand`> shachaf: note that I could write say ‘let foo = getline >>= putStrLn in 5’ and this would be completely pure, because the IO actions that get described never actually get executed
16:06:26 <rosie> shachaf: alright
16:06:33 <DanBurton> mm_freak: "nothing is actually executed" is a bit misleading. The reusltant action represents "executing" action1, and then for the rest of the computation, referring to the result of action1 as "x"
16:06:34 <kallisti> shachaf: isn't this kind of the purpose of #haskell?
16:06:39 <Jesin> rosie: umm, x <- y
16:06:40 <nand`> sure, you're glueing them together with >>= but at that point they still don't get executed - they just describe a new action
16:06:41 <Jesin> is
16:06:43 <nand`> err
16:06:47 <nand`> my previous comment was aimed at rosie
16:06:49 <shachaf> kallisti: No, #-overflow is for longer discussions like this.
16:06:50 <nand`> not shachaf
16:06:50 <Jesin> x -> y
16:06:52 <Jesin> is different
16:06:57 <HaskellHacker> I want to do something like: containsChars string pattern = map (map (X ==) pattern) string
16:06:58 <HaskellHacker> how to get the value (X) from the first map to use in the second one?
16:06:59 <Jesin> and has nothing to dow ith monads
16:07:06 <Jesin> *to do with
16:07:22 <rosie> Jesin: yep, sorry, typo
16:07:37 <mm_freak> HaskellHacker: see 'any'
16:07:39 <mm_freak> :t any
16:07:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:07:56 <HaskellHacker> ok
16:07:58 <nand`> rosie: note that the letters are in the other order too; x <- y  is sugar for y >>= \x ->
16:08:02 <kanedank`> on #lisp they created #lispcafe...
16:08:19 <DanBurton> HaskellHacker: what do you expect the result type of that expression to be?
16:08:48 <HaskellHacker> of any?
16:08:49 <mm_freak> HaskellHacker: also note that i recommend switching the arguments
16:08:55 <DanBurton> HaskellHacker: of your desired function
16:08:55 <mm_freak> flipping
16:08:58 <Jesin> @help undo
16:08:59 <lambdabot> undo <expr>
16:08:59 <lambdabot> Translate do notation to Monad operators.
16:09:02 <Jesin> guys
16:09:04 <HaskellHacker> what do you mean?
16:09:08 <parcs`> mm_freak: i think >>= is left associative because then you can do m >>= f >>= g, where f and g are functions in the form a -> m b
16:09:13 <Jesin> give her @undo, perhaps?
16:09:13 <shapr> donri: It's designed to be insecure
16:09:14 <DanBurton> HaskellHacker: rather, what do you want the type of "containsChars" to be?
16:09:20 <mm_freak> HaskellHacker: DanBurton means: give a type signature for your function
16:09:21 <donri> heh
16:09:22 <DanBurton> String -> String -> ???
16:09:47 <HaskellHacker> bool I guess
16:09:49 <mm_freak> parcs`: makes sense
16:09:57 <nand`> I'm quite sure >>= is left associative
16:10:02 <DanBurton> so True if "pattern" is found anywhere in "string", yeah?
16:10:03 <mm_freak> HaskellHacker: 'bool' is a type variable…  you mean Bool, i assume
16:10:06 <nand`> for exactly that reason
16:10:28 <parcs`> :t ?m >>= (?f >>= ?g) -- on the other hand m >>= f >>= g is much less useful if >>= is infixr
16:10:29 <lambdabot> forall (m :: * -> *) a a1 b. (?m::m a, ?f::a -> a1, ?g::a1 -> a -> m b, Monad m) => m b
16:10:41 <mm_freak> > \pat -> any (\x -> any (== x) pat)
16:10:42 <lambdabot>   Overlapping instances for GHC.Show.Show
16:10:42 <lambdabot>                              ([a] -...
16:10:50 <mm_freak> > (\pat -> any (\x -> any (== x) pat)) "abcde" "Test"
16:10:51 <lambdabot>   True
16:10:52 <Jesin> parcs`: what's with the questionmarks?
16:10:57 <mm_freak> > (\pat -> any (\x -> any (== x) pat)) "abcde" "Ship"
16:10:59 <lambdabot>   False
16:11:00 <parcs`> Jesin: they are implicit parameters
16:11:01 <DanBurton> HaskellHacker: if that's what you want, then map isn't really the way to do it
16:11:10 <mm_freak> :t \pat -> any (\x -> any (== x) pat))
16:11:12 <lambdabot> parse error on input `)'
16:11:15 <mm_freak> :t \pat -> any (\x -> any (== x) pat)
16:11:16 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:11:26 <parcs`> Jesin: it's like writing "\m f g -> m >>= (f >>= g)" but with less typing
16:11:31 <Jesin> k
16:11:42 <mm_freak> :t \pat -> any (`elem` pat)
16:11:44 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:12:25 <nand`> :t any . flip elem
16:12:27 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:13:18 <DanBurton> > (\x y -> not (S.null (S.intersect x y))) (S.fromList "asdf") (S.fromList "qwer")
16:13:19 <lambdabot>   Not in scope: `S.intersect'
16:13:48 <Jesin> :t Foldable.any . flip elem
16:13:49 <lambdabot> Couldn't find qualified module.
16:13:56 <Jesin> :t Data.Foldable.any . flip elem
16:13:58 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t, Eq a) => [a] -> t a -> Bool
16:14:12 <Jesin> :t Data.Foldable.any . flip Data.Foldable.elem
16:14:13 <lambdabot> forall a (t :: * -> *) (t1 :: * -> *). (Data.Foldable.Foldable t, Data.Foldable.Foldable t1, Eq a) => t1 a -> t a -> Bool
16:14:21 <Jesin> yaaaaaaay
16:14:23 <Jesin> ^_^
16:14:38 <DanBurton> > (\x y -> not (S.null (S.intersection x y))) (S.fromList "asdf") (S.fromList "qwera")
16:14:40 <lambdabot>   True
16:15:28 <Jesin> hmm
16:15:53 <kanedank`> can someone perhaps help me figure out where to put my parens so I can switch out ==> and ==>& for >>= and >> respectively?: https://gist.github.com/3409088
16:16:07 <kanedank`> I've been trying most permutations I can think of...
16:16:31 <mm_freak> kanedank`: again, if it worked with (>>=) and (>>), then just add infixl declarations
16:16:36 <mm_freak> infixl 1 ==>
16:16:38 <mm_freak> infixl 1 ==>&
16:16:44 <Jesin> guys
16:16:48 <Jesin> where did Data.Set go?
16:16:54 <mm_freak> Jesin: containers package
16:17:01 <kallisti> lol
16:17:16 <kallisti> > Set.empty
16:17:17 <lambdabot>   Not in scope: `Set.empty'
16:17:18 <Jesin> thanks mm_freak
16:17:22 <Jesin> > S.empty
16:17:24 <lambdabot>   fromList []
16:17:25 <shapr> jfischoff: I could run an instance on my laptop, but it's designed for use by everyone, so install ghclive and report bugs!
16:18:02 <Jesin> [19:14:18]	DanBurton	> (\x y -> not (S.null (S.intersection x y))) (S.fromList "asdf") (S.fromList "qwera")
16:18:10 <Jesin> why would you implement it like that, DanBurton ?
16:18:29 <kanedank`> mm_freak: is it normal to mess with the precedence of operators? I want to learn haskell, not how to hack something til it compiles
16:18:45 <kanedank`> which is what I feel like I'm doing...
16:18:47 <nand`> it's normal to mess with operator precedence, yes
16:18:52 <nand`> it's not ‘messing’ really
16:18:53 <kanedank`> really?!?!
16:19:01 * hackagebot lio 0.9.0.1 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.9.0.1 (DeianStefan)
16:19:02 <Jesin> kanedank`: if you are defining a new infix operator, it is normal to set its precedence and fixity
16:19:09 <nand`> kanedank`: operators don't really have defined precedences in Haskell; you're defining a new operator altogether
16:19:18 <nand`> and your precedence declarations don't affect any other operators
16:19:21 <Jesin> kanedank`: if it's a built-in or predefined operator, then you should usually not change that.
16:19:27 <kanedank`> is it normal to create infix operators?
16:19:32 <nand`> yes
16:19:48 <mm_freak> kanedank`: not for your case though =)
16:19:50 <Jesin> Not in all cases
16:19:57 <mm_freak> again, i recommend (>>=) and (>>)
16:20:01 <Jesin> but for some tasks, yes.
16:20:23 <nand`> maybe he can't use >>= >> because his type is not a monad?
16:20:32 <nand`> as in, violates monad laws or doesn't have return
16:20:35 <kanedank`> mm_freak: I'm sorry, but I still don't understand what you mean by (>>=) and (>>). Do you mean using the operators with parens?
16:20:58 <mm_freak> nand`: then he wouldn't define (==>) = (>>=) =)
16:20:59 <nand`> kanedank`: no he means using >>= instead of ==>
16:20:59 <Jesin> kanedank`: um, no, it's just conventional to refer to them that way in conversation
16:21:20 <nand`> mm_freak: oh, yes; I didn't see him do that in the source :P
16:21:23 <mm_freak> kanedank`: in "x >>= c" the operator is (>>=)…  it's normal haskell syntax
16:21:24 <Jesin> ...
16:21:40 <mm_freak> :t (>>=) getLine putStrLn
16:21:41 <lambdabot> IO ()
16:21:47 <Jesin> like, if you want to ask the type of the operator
16:21:49 <Jesin> :t >>=
16:21:51 <lambdabot> parse error on input `>>='
16:21:52 <Jesin> :t (>>=)
16:21:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:22:03 <Jesin> kanedank`: that's why parens.  :P
16:22:37 <mm_freak> kanedank`: in haskell you can write symbolic functions in a prefix style using the (…) syntax the same way you can use a word function using the `…` syntax
16:22:43 <kanedank`> but when I do that (https://gist.github.com/3409088) I get https://gist.github.com/3409169
16:23:35 <mm_freak> oh, it's actually not a monad?
16:24:09 <Jesin> um
16:24:10 <nand`> instance Monad Parse where (>>=) = (==>); return = ???
16:24:27 <Jesin> kanedank`: what does (==>) even do in your code?
16:24:50 <kanedank`> https://gist.github.com/3409178
16:25:20 <kanedank`> it looks like a weird predetermined wrapping around >>= which only uses the parse monad, if I'm understanding it right
16:25:54 <nand`> ugh
16:25:56 <nand`> the definition is on line 99
16:27:01 <Veinor> i need advice on how to deal with entities in a video game
16:27:02 <kanedank`> sorry about that, didn't know it was there myself
16:27:26 <Veinor> the two obvious ways i was thinking of are data Entity a = Entity {inner :: a, position :: Position, ...}
16:27:31 <Veinor> and an Entity typeclass
16:27:32 <nand`> my ugh was because the type signature for it was way up in line 31
16:28:02 <Jesin> yeah... that's confusing having them separated like that...
16:28:56 <nand`> looks like Parse = StateT ParseState (Either String)
16:29:23 <nand`> could be made a monad fairly easily with return a = Parse (\s -> Right (a, s))
16:32:05 <JoeyA> If I use finalizeForeignPtr, can I be sure the finalizer will only be called once?
16:32:05 <kanedank`> you're talking about: newtype Parse a = Parse { runParse :: ParseState -> Either String (a, ParseState); }
16:32:10 <JoeyA> Or might the GC call it again?
16:33:00 <JoeyA> Actually, in my case, the GC already finalized it, but finalizeForeignPtr is running the finalizer again.
16:33:05 <JoeyA> Looks like a bug to me.
16:35:11 <zxspectrum> Is there a common naming scheme for Maybe a instances vs a instances?
16:35:29 <shachaf> zxspectrum: What do you mean?
16:36:08 <Cale> zxspectrum: Informally I might say "Maybe values" to refer to values of type Maybe t
16:36:14 <sm> somethingM (clashes with monadic) or msomething
16:36:33 <Cale> or you mean naming the variables?
16:36:36 <zxspectrum> case foo of Just foo' -> ..., what are better names for foo and foo'?
16:36:39 <Cale> ah
16:36:55 <shachaf> It's best not to have to name one of them at all, if you can get away with it.
16:37:23 <zxspectrum> I find that I am using Maybes and the values inside often, and mfoo/foo looks messy
16:37:31 * nand` tens to use case foo of Just f -> ...
16:37:33 <nand`> tends*
16:37:57 <Eduard_Munteanu> zxspectrum: just use maybe/fromMaybe
16:38:04 <Eduard_Munteanu> :t maybe
16:38:06 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:38:11 <zxspectrum> shachaf, what if I have Maybes mixed with non-maybes?
16:38:12 <Eduard_Munteanu> :t fromMaybe
16:38:13 <lambdabot> forall a. a -> Maybe a -> a
16:38:31 <Eduard_Munteanu> And then you don't have to pattern-match explicitly.
16:38:37 <shachaf> zxspectrum: I don't know. It depends on the specific situation.
16:38:38 <zxspectrum> is it worth marking the maybes in some way, or should I just name them according to their contents?
16:38:58 <zxspectrum> Eduard, it was just an example
16:39:27 <Eduard_Munteanu> Ah.
16:40:26 <Cale> Anyone here familiar with SBCL types?
16:40:38 <shachaf> "SBCL has types?"
16:40:44 <Cale> shachaf: That's what I'm thinking :)
16:41:04 <Cale> shachaf: Well, I know it has types, but I don't remember the type system being very good
16:41:37 <Cale> http://www.reddit.com/r/haskell/comments/yizdr/boilerplate_in_haskell/c5w2nle -- I have this thread going on reddit
16:41:55 <shachaf> (optimize (speed 3) (safety 0))
16:42:06 <Cale> and I'm curious what the response to that last problem might be
16:42:34 <Cale> Can you make a typesafe polymorphic map where the type checker will catch the error if you forget the application of the function?
16:43:36 <Cale> istr the answer being "no", but my knowledge of SBCL and Common Lisp in general is about a decade out of date.
16:47:28 <kanedank`> Cale: I'm a noob to cl as well, but I believe that you cannot check that if cells in your hashmap are heterogeneous
16:53:55 <kanedank`> and I think I severely misread your question
16:54:30 <Cale> I just mean the list map function
16:54:49 <slack1256> somebody here uses haskell for statistics, if you what do you use for plotting instead of gnuplot bidings?
16:55:16 <slack1256> *s/if\ you/if\ you\ do/
16:59:09 <mm_freak> edwardk: could you please remove all the additional instances (most notably Alternative and MonadPlus) from FreeT or at least base them on f instead of m?
16:59:13 <mm_freak> they really stand in my way
16:59:25 <edwardk> ouch.
16:59:29 <edwardk> they are correct on m
16:59:35 <edwardk> the ones on f are actually a lie
16:59:50 <mm_freak> yes, but then better don't write any of them
16:59:57 <edwardk> well, i actually need them =P
17:00:06 <mm_freak> i want to write Alternative and MonadPlus in terms of my f
17:00:35 <mm_freak> otherwise i can really go without FreeT at all =)
17:00:36 <edwardk> i'm really kind of down on ripping them out
17:00:44 <mm_freak> and just go back to custom monads
17:01:05 <edwardk> because they are implied by the structure and there is only one legal construction for them
17:01:13 <kanedank`> so I have this now and it works: https://gist.github.com/3409477 but now I am getting a warning: https://gist.github.com/3409498
17:01:17 <aristid> mm_freak: don't you use a newtype anyways?
17:01:19 <kanedank`> thank you everybody for your patience!
17:01:32 <aristid> mm_freak: so you can selectively decide which instances to use?
17:01:47 <mm_freak> aristid: type
17:01:54 <aristid> mm_freak: is this netwire?
17:02:07 <mm_freak> nope
17:02:18 <edwardk> i would rather have instances you don't like than have you put orphan instances on them that i don't like ;)
17:02:21 <mm_freak> i'm not using free monads in netwire
17:02:52 <mm_freak> edwardk: couldn't you make them optional?
17:02:58 <mm_freak> like move them to a different module
17:03:11 <slack1256> kanedank: To define a 'Monad' instance you need at least to define two methods namely 'return' (already done) and '>>=' (missing)
17:03:11 <edwardk> no, i don't do orphan instances, because they are infectious.
17:03:29 <aristid> you don't do them, nor do you support anybody else using them, right
17:03:32 <edwardk> if i put them somewhere then users have to choose between working with code that uses them and working with your code
17:03:39 <edwardk> aristid: they are just a bad design idea
17:04:01 <aristid> i do think mm_freak wants a newtype.
17:04:09 <edwardk> the correct pattern when you want them is to make a newtype wrapper. that solution scales and doesn't fragment the community in terms of what code can work with what
17:05:11 <edwardk> i've gone out of my way across all of my packages _not_ to introduce orphans, i think it'd be a pretty dumb precedent to set now to go back on all of that work
17:06:18 <edwardk> i have one package full of orphans for vector and one module full of orphan monoids in another package, both were done with much hand wringing
17:06:55 <edwardk> sorry, i don't mean to be a pain about this one
17:07:06 <edwardk> but there isn't a way i can give you what you want without screwing other users
17:07:31 <MostAwesomeDude> Looking at the instances in question, I'm trying to figure out what the problem is with them.
17:07:45 <edwardk> MostAwesomeDude: he wants to use ones like i have (illegally) on Free
17:08:05 <edwardk> the ones on free are very convenient, they are also notably wrong
17:08:33 <MostAwesomeDude> Hmm, yeah. :T
17:08:34 <edwardk> i use them in a bunch of probability theory code that i have
17:08:54 <edwardk> and i included them because there isn't a 'correct' version that can apply there
17:09:19 <edwardk> and they are convenient if you are using the free monad as an optimized form of the base monad you can inspect
17:09:29 <acowley> Hey edwardk, did you ever get around to splitting the linear algebra code from the physics repo? I'll be finishing the project where I'm using those modules soon-ish and would like to merge changes back in if they're still welcome.
17:09:42 <edwardk> acowley: i did start the package but i haven't pushed it
17:09:50 <edwardk> let me throw it on github
17:10:00 <edwardk> i was trying to see if i could get my covector monad to fit in it
17:10:04 <edwardk> but that wanted too much from algebra
17:10:09 <acowley> edwardk: okay, this was just a nudge to remind you in case you'd forgotten
17:10:23 <edwardk> yeah, give me a couple of minutes, and let me add the license, etc.
17:11:30 <mm_freak> i'll just go with newtype then
17:11:50 <edwardk> mm_freak: sorry man
17:11:58 <mm_freak> i was kinda hoping that i could get along with type for simple stuff
17:12:55 <edwardk> i should also put a ChurchT in kan-extensions
17:15:23 <edwardk> acowley: getting it to compile and shoving it to github now
17:15:42 <armlesshobo> so, fmap is just a map for types that are instances of Functor?
17:15:42 <acowley> edwardk: what name have you chosen given linear is taken in your github account?
17:15:53 <edwardk> i'm just going to move the one on my github account
17:16:43 <slack1256> armlesshobo: yes. but don't expect every instance of functor behave as 'map'
17:17:12 <slack1256> armlesshobo: but you can be sure that it will change the inner value of the '''container'''
17:17:12 <armlesshobo> slack1256: right, because not all structures behave the same.
17:17:30 <slack1256> armlesshobo: yeah, yeah.
17:17:36 <acowley> "sure"
17:17:39 <applicative> DanBurton: http://hpaste.org/73449 did you tell it to choose a highlighting style
17:18:07 <armlesshobo> slack1256: ok, ty :)
17:18:14 <slack1256> armlesshobo: I'm thinking on adding an extension to hackage where also point you to where are defined the instances of a class
17:18:23 <slack1256> to make it easier for everybody
17:18:45 <slack1256> armlesshobo: ask again if you have questions! :-9
17:24:10 <edwardk> acowley: try now
17:24:51 <sipa> amiller: ah, you're here too :)
17:25:27 <acowley> edwardk: Can you add Quaternion?
17:25:29 <amiller> i like irc rooms with cool bots
17:25:34 <amiller> #haskell has one of the best
17:25:39 <edwardk> better, you can. let me make you a committer ;)
17:26:00 <edwardk> acowley: you are empowered to do so directly ;)
17:26:06 <sipa> amiller: agree!
17:26:14 <acowley> edwardk: Okay, will do
17:26:45 <edwardk> heading off to dinner with friends, so i had to delegate ;)
17:26:46 <shachaf> Awley mmits de.
17:26:52 <edwardk> i look forwar to seeing your improvements =)
17:28:20 <shachaf> I think I meant that de commits awley.
17:33:54 <zungaloca> recursivity
17:36:24 <slack1256> zungaloca: that a good name for a band :-)
17:38:09 <rosie> The left identity for a monad is a >>= f  = f a. Then why is   xs >>=f = join (fmap f xs)? It looks like that's saying f xs = join (fmap f xs). But fmap will take things from one box and put them in another box, so why would we have a nested box that we need to join?
17:38:35 <shachaf> rosie: No, it's return a >>= f
17:38:42 <shachaf> = f a
17:38:53 <shachaf> rosie: I strongly encourage you not to think of monads as "boxes".
17:39:38 * ddarius forgets if Box forms a monad.  I think it does not.
17:39:44 <shachaf> What's Box?
17:40:09 <ddarius> data Box a = Box a
17:40:15 <zungaloca> factorial n = n * factorial (n-1)
17:40:21 <sipa> return = Box
17:40:26 <shachaf> ddarius: Isn't that just Identity?
17:40:32 <shachaf> Or are you considering _|_s?
17:40:42 <ddarius> Identity is newtype Identity a = Identity a
17:41:04 <shachaf> I think people usually ignore _|_s as far as the monad laws are concerned.
17:41:22 <ddarius> I think people are usually wrong.
17:41:28 <shachaf> At least, a good deal of the standard library breaks the monad laws if you use seq right.
17:41:38 <rosie> shachaf: oh boy. I've been looking for a simple way to think about a monad. At first I thought it was simple enough to think of it as a type that implements the bind operator. Then it seemed like thinking of it as an action that could be executed was alright, but that got tricky with IO. Thinking of it as a container doesn't sound good either. What analogy do you use?
17:42:05 <shachaf> rosie: "action that could be executed" is an analogy that works pretty well.
17:42:16 <shachaf> It works with IO.
17:42:29 <rosie> shachaf: alright, I'll keep at it with that analogy
17:42:41 <shachaf> (Except the monad m isn't the action, a value of type "m a" is.)
17:43:38 <ddarius> @fresh
17:43:38 <lambdabot> Hagy
17:43:44 <latro`a> I think I'd call it "one or more actions that could be executed"
17:43:54 <latro`a> because an IO a can be a huge thing
17:44:02 <latro`a> as can any other monadic value
17:44:18 <latro`a> (this is semantics, though; arguably a mass of actions is an action)
17:44:21 <shachaf> latro`a: That's just making things confusing.
17:44:24 <latro`a> erm, s/mass/sequence
17:44:35 <kallisti> latro`a: in the sense that it's non-atomic, yes.
17:44:52 <kallisti> it makes sense to talk about it being potentially multiple actions.
17:44:59 <shachaf> foo :: A -> B. foo is an action that produces a B. Is it "composed of smaller actions"? Who knows?
17:45:11 <shachaf> And who cares?
17:45:12 <latro`a> it is or it isn't, but you can't see from the outside
17:45:53 <shachaf> Exactly.
17:45:58 * ddarius completely agrees with shachaf here.
17:46:22 <latro`a> for pedagogical purposes I totally agree
17:46:55 <latro`a> precision-wise I probably agree, because of the lack of a clear way to tell when a value is a chain of actions even if you execute it
17:47:12 <latro`a> also hard to decide what's a "single action" anyways
17:47:19 <ddarius> latro`a: Indeed.
17:47:19 <latro`a> is getLine one action?
17:47:44 <ddarius> If you do, as kallisti suggests, want to talk about atomic or non-atomic actions, simply use those terms.
17:47:49 <latro`a> true
17:48:08 <latro`a> yeah I retract my previous comment
17:48:53 * kallisti rollbacks to last savepoint.
17:49:22 <kallisti> sorry, I just got out of my databases class.
17:50:00 <ddarius> So presumably you know all about ARIES now.
17:50:30 <shachaf> rosie: Another thing to note is that the "Monad" class doesn't let you do very much on its own.
17:50:46 <ddarius> It doesn't let you do anything on its own (if you ignore fail)
17:50:55 <boothead> I'm trying to use unfoldr to generate a list of almost ordered Ints in the Gen monad. Is there a way I can reach out of the b -> Maybe (a,b) function to do choose in Gen/
17:50:56 <shachaf> rosie: In every useful case it's combined with some additional primitives for the specific instance of Monad you're using.
17:51:28 <shachaf> Like get and put for State s, or callCC for Cont r, or Nothing for Maybe, and so on.
17:51:36 <ddarius> @hoogle unfoldrM
17:51:36 <shachaf> (As well as runFoo for many monads.)
17:51:36 <lambdabot> No results found
17:51:41 <ddarius> @hoogle unfoldM
17:51:42 <lambdabot> No results found
17:51:56 <rosie> shachaf: gotcha, it just lets you chain together computations, right? the actually "running" and how the computations are changed is defined by the library.
17:52:20 <shachaf> rosie: More or less.
17:52:36 <shachaf> The library defines the meaning of the "m".
17:52:56 <rosie> shachaf: lol thanks for being patient with me (;
17:54:43 <boothead> ddarius: should I just use fold perhaps?
17:55:28 <ddarius> As a simple exercise, it very easy to prove that any expression of type m a for arbitrary m and some a made by only using (>>=) and return is return X for some X.
17:55:48 <kallisti> rosie: also the flow of execution is determined by the library (i.e. the particular monad instance). The flow of execution can be distinct from the ordering of the program
17:55:53 <ddarius> There should be a monadic unfold somewhere.
17:56:08 <shachaf> Control.Monad.Loops
17:56:18 <shachaf> @google unfoldrM Control.Monad.Loops
17:56:20 <lambdabot> http://hackage.haskell.org/packages/archive/monad-loops/0.3/doc/html/Control-Monad-Loops.html
17:56:20 <lambdabot> Title: Control.Monad.Loops
17:57:18 <kallisti> rosie: but of course this shouldn't come as any surprise; Haskell itself completely seperates the flow of execution from the program structure.
17:58:04 * ddarius thinks kallisti wants "evaluation" not "execution".
17:58:12 <boothead> perfect thanks shachaf
17:58:26 <ddarius> kallisti: Incidentally, if you enjoyed your databases class, you may find Stasis interesting.
17:58:39 <kallisti> ddarius: no I'm thinking in terms of operational semantics; this includes side-effects from IO.
17:59:09 <kallisti> evaluation is just a particular kind of execution, after all.
17:59:20 <shachaf> http://code.google.com/p/stasis/ ?
17:59:25 <shachaf> kallisti: Not really. :-(
18:00:06 <kallisti> shachaf: the exact meanings of the words might vary a bit based on what particular kool-aid you prefer.
18:00:08 <ddarius> shachaf: Yes.
18:00:32 <ddarius> shachaf: Technically, evaluation can be considered execution in the Identity monad.
18:00:48 <kallisti> or the execution of a Turing machine
18:00:56 <kallisti> or a FSA
18:01:02 <kallisti> depending on the complexity of evaluation
18:01:10 <ddarius> Apropos to not much, I think I find sqlite worse than MS Access SQL.
18:01:24 <ddarius> kallisti: All we have are FSAs.
18:02:47 <ddarius> shapr is a tease.
18:03:45 * DanBurton is pleased with the progress of basic-prelude :)
18:04:08 <kanedank`> uh... can someone help me figure out how to make a word to digit function work with a given number of 8 bit words?: https://gist.github.com/3410159
18:06:46 <kallisti> kanedank`: do you mean [Word8] -> Integer?
18:07:29 <DanBurton> @hoogle Word8 -> Char
18:07:30 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:07:30 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
18:07:30 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
18:07:33 <kanedank`> yep
18:07:40 <DanBurton> unsafeCoerce -_- srsly hoogle
18:07:48 <shachaf> thambdabot
18:07:54 <kallisti> kanedank`: so... a base 256 numeral system converted to a single integer?
18:08:08 <kallisti> the word "digit" typically refers to a character, but it looks as though you already have Word8 -> Char
18:08:37 <kanedank`> no, more like treating multiple bytes as a single integer
18:08:40 <kallisti> right
18:09:14 <kallisti> kanedank`: big endian or little endian? :>
18:09:32 <ddarius> DanBurton: As all C programmers know, unsafeCoerce is the solution to any type puzzle.
18:09:37 <DanBurton> kanedank`: what does a single Word8 represent here? A single digit 0 thru 9, or a number 0 thru 255?
18:09:55 <kanedank`> 0 through 255 I would hope, but time will tell
18:10:12 <kallisti> IIRC, he wants what is essentially a representation of a base 256 numeral system to be converted into a single integer.
18:10:17 <kallisti> er IIUC
18:10:26 <boothead> kanedank`: I've commented on the gist with my solution - however I don't think given the feedback I got in here before that you should listen to me :-)
18:10:39 <mm_freak> :t foldl' (\x d -> 256*x + fromIntegral d) 0
18:10:40 <lambdabot> forall a b. (Num a, Integral b) => [b] -> a
18:10:52 <mm_freak> > foldl' (\x d -> 256*x + fromIntegral d) 0 [1, 1]
18:10:53 <lambdabot>   257
18:11:07 <DanBurton> mm_freak++
18:11:19 <ddarius> kallisti: Don't forget about middle endian.
18:11:21 <DanBurton> I was thinking the same, but was looking for the docs for "shift"
18:11:36 <ddarius> @hoogle shift
18:11:37 <lambdabot> Data.Bits shift :: Bits a => a -> Int -> a
18:11:37 <lambdabot> Data.Bits shiftL :: Bits a => a -> Int -> a
18:11:37 <lambdabot> Data.Bits shiftR :: Bits a => a -> Int -> a
18:11:43 <mm_freak> shiftL is what you want
18:11:50 <kanedank`> boothead: why did you use the Data.ByteString.Char8 and Data.Attoparsec.Char8?
18:11:53 <mm_freak> > foldl' (\x d -> shiftL 8 x + fromIntegral d) 0 [1, 1]
18:11:55 <lambdabot>   4097
18:12:03 <mm_freak> > foldl' (\x d -> shiftL x 8 + fromIntegral d) 0 [1, 1]
18:12:04 <DanBurton> > foldl' (\x d -> (shiftL x 8) + fromIntegral d) [1,1]
18:12:05 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:12:05 <lambdabot>    `Data.Bits.Bits a'
18:12:05 <lambdabot>      a...
18:12:05 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [t])
18:12:05 <lambdabot>    arising from a use ...
18:12:31 <mm_freak> :t shiftL
18:12:33 <lambdabot> forall a. (Bits a) => a -> Int -> a
18:12:41 <DanBurton> > foldl' (\x d -> (shiftL x 8 :: Integer) + fromIntegral d) 0 [1,1]
18:12:43 <lambdabot>   257
18:12:47 <boothead> kanedank`: because I'm a neophyte
18:12:48 <mm_freak> > foldl' (\x d -> shiftL x 8 + fromIntegral d) 0 [1 :: Word8, 1]
18:12:50 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:12:50 <lambdabot>    `Data.Bits.Bits a'
18:12:50 <lambdabot>      a...
18:13:00 <kallisti> mm_freak: you'll want a fromIntegral
18:13:05 <mm_freak> yeah, apparently
18:13:14 <DanBurton> lambdabot doesn't know that the bits constraint should default to Integral in this case
18:13:20 <mm_freak> kallisti: or just a type signature =)
18:13:26 <shachaf> mm_freak: Might as well .|. while you're at it!
18:13:29 <mm_freak> yeah, there is no defaulting for Bits
18:13:34 <kallisti> mm_freak: assuming you don't mind [Integer] -> Integer
18:13:36 <mm_freak> shachaf: true
18:13:42 <kallisti> instead of [Word8] -> Integer
18:13:43 <mm_freak> kallisti: i do
18:14:01 <mm_freak> because kanedank` does =)
18:14:19 <mm_freak> > foldl' (\x d -> shiftL x 8 + fromIntegral d) 0 [1, 1] :: Integer
18:14:21 <lambdabot>   257
18:14:28 <DanBurton> > foldl' (\x d -> shiftL x 8 .|. fromIntegral d) (0 :: Integer) ([1, 1] :: [Word8])
18:14:29 <lambdabot>   257
18:14:45 <mm_freak> you can also force Num defaulting, but that's ugly
18:14:55 <mm_freak> > foldl' (\x d -> shiftL x 8 + fromIntegral d) 0 [1, 1] :: (Bits a, Num a) => a
18:14:56 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:14:56 <lambdabot>    `Data.Bits.Bits a'
18:14:56 <lambdabot>      a...
18:14:59 <mm_freak> hmm
18:15:09 <mm_freak> or i thought you could
18:15:14 <mm_freak> ah, i see why
18:15:19 <DanBurton> like I said, lambdabot is unsure about the bits constraint
18:15:23 <mm_freak> > foldl' (\x d -> 1 * shiftL x 8 + fromIntegral d) 0 [1, 1]
18:15:25 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:15:25 <lambdabot>    `Data.Bits.Bits a'
18:15:25 <lambdabot>      a...
18:15:33 <DanBurton> I wish we could specify defaults for all typeclasses
18:15:43 <mm_freak> weird…  i used Num in there
18:15:44 <ddarius> I wish the defaulting mechanism was completely removed.
18:16:16 <DanBurton> ddarius: the newbs would have a harder time getting up and running with the REPL
18:16:22 <mm_freak> defaulting is useful most of the time…  it's just weird in certain edge cases
18:16:26 <kallisti> I wish the defauling mechanism wasn't a good thing to have.
18:17:01 <DanBurton> warnings for occasions where defaulting is used are sufficient imho
18:17:11 <ddarius> DanBurton: I have no problem with GHCi doing crazy crap.  Extended defaulting was only available in GHCi originally.
18:17:28 <ddarius> DanBurton: You only get those warnings with -Wall (or the specific flag).
18:18:03 <kanedank`> mm_freak, DanBurton: thank you! that has really helped me get an idea of what to do
18:18:10 <mm_freak> unlike most other languages haskell makes heavy use of polymorphism
18:18:31 <mm_freak> if we don't have defaulting, there should be another way to specify what we want concisely
18:18:47 <ddarius> There is.  Type inference and a very occasional type signature.
18:18:47 <DanBurton> sometimes I wish [] and : were typeclassed
18:18:54 <kallisti> DanBurton: yep
18:19:04 <kallisti> it should be called OverloadedSequences
18:19:38 <mm_freak> there should be an extension for overloaded list literals
18:19:39 <kallisti> but it would require that either (:) is a special case, or : no longer represents an uppercase letter, or that we have a way to create "virtual" constructors
18:20:00 <mm_freak> but usually it would only save a very small amount of code
18:20:09 <DanBurton> I'm unhappy with the :/constructor situation as it sits
18:20:47 <DanBurton> it is unclear why the whole "constructors must be uppercase" is necessary in the first place
18:21:08 <mm_freak> DanBurton: concise code
18:21:25 <kallisti> specifically concise pattern matching.
18:22:13 <mm_freak> DanBurton: remove the requirement, then imagine "Right True"
18:22:19 <mm_freak> now is True a constructor or a variable?
18:22:34 <kallisti> I could see a "nullary constructors must be uppercase" as a rule instead
18:23:11 <ddarius> One could look at what the MLs do...
18:23:19 <mm_freak> or what agda does
18:23:27 <kallisti> I can't think of a situation where f (right True) = ...  would be unambiuous.
18:23:53 <DanBurton> I would solve that problem by making constructor names non-shadowable
18:24:04 <simon__> earlier this evening I learned of Wadler's Law. :)
18:24:15 <kallisti> DanBurton: but isn't the nullary constructor the only case that causes ambiguity?
18:24:23 <mm_freak> DanBurton: that would lead to namespace hell
18:24:37 <mm_freak> it's not unusual for me to import 15 modules
18:24:49 <DanBurton> mm_freak: isn't that the case for constructors anyways?
18:24:59 <mm_freak> now whether something is a variable or not depends on what i import
18:25:08 <mm_freak> which would be very unfortunate
18:25:10 * ddarius actually likes the fact that you can identify constructors and variables syntactically and instantaneously.  I also like the consistency it affords.
18:25:26 <mm_freak> yeah, i agree
18:25:47 <kallisti> I do think constructors should become first class though.
18:26:16 <geekosaur> I wish it didn't use case but I like not needing some kind of syntactic marker
18:26:23 <kallisti> as a pair of functions, essentially.
18:26:25 <mm_freak> kallisti: to pattern-match against variables with arguments?
18:26:34 <ddarius> @google "first class patterns" keller
18:26:36 <lambdabot> http://www.haskell.org/pipermail/haskell-prime/2006-November/001892.html
18:26:36 <lambdabot> Title: lambda-match example - from parser combinators to grammar combinators
18:26:40 <ddarius> Bloody shite.
18:26:48 <kallisti> mm_freak: it would make (:) overloadable
18:26:57 <kallisti> via a cons/uncons pair of functions.
18:27:09 <kallisti> in a typeclass.
18:27:25 <ddarius> @google "first class patterns" kesner
18:27:27 <lambdabot> Plugin `search' failed with: Prelude.(!!): index too large
18:27:30 <DanBurton> so, like Scala then?
18:27:31 <ddarius> @google "first class patterns" kesner
18:27:33 <lambdabot> Plugin `search' failed with: Prelude.(!!): index too large
18:27:37 <kallisti> DanBurton: I don't know.
18:27:40 <ddarius> Bloody shite!  I fixed that.
18:27:59 <ddarius> I think this was the exact example that made me want to fix it.
18:28:05 <ddarius> *sigh*
18:28:16 <DanBurton> Scala allows you to define an unapply method, or something, so that you can create views and use them in pattern matching as if they were constructors
18:28:28 <rosie> Is this more or less the implementation of PutStr? yo :: String -> IO String; yo str = return str
18:28:39 <mm_freak> notice that haskell has pattern guards and view patterns
18:28:42 <DanBurton> rosie: nope.
18:28:57 <rosie> DanBurton: what does it actually look like?
18:28:59 <ddarius> http://journals.cambridge.org/repo_A45US65o
18:29:03 <shachaf> rosie: What's PutStr?
18:29:05 <DanBurton> rosie: putStr causes an effect that will print the input string to the screen, but the return value is actually ()
18:29:08 <mm_freak> f (viewl mySeq -> x :< xs) = …
18:29:19 <mm_freak> so i'm not sure we really need overloadable (:)
18:29:20 <geekosaur> and the action is not hidden inside return
18:29:44 <rosie> aha. What's the IO actually doing in the program: main = yo "hey"
18:29:45 <rosie> yo :: String -> IO String
18:29:45 <rosie> yo str = return str
18:29:46 <mm_freak> rosie: PutStr has no implementation
18:29:48 * ddarius view patters > views.
18:29:51 <kanedank`> thanks again everbody!
18:30:05 <rosie> mm_freak: then how does it work?
18:30:06 <mm_freak> rosie: if you're referring to my "IO as an EDSL" explanation
18:30:11 <shachaf> rosie: Oh, you're running into a runghc "bug".
18:30:12 <mm_freak> rosie: it doesn't =)
18:30:15 <DanBurton> rosie: putStr s        =  hPutStr stdout s
18:30:24 <DanBurton> of course that's sort of a runaround answer
18:30:37 <mm_freak> rosie: think of the RTS as an interpreter for an EDSL called IO
18:30:52 <kallisti> rosie: putStr str = hPutStr stdout str
18:30:53 <mm_freak> data IO :: * -> * where PutStrLn :: String -> IO ()
18:30:58 <shachaf> rosie: If you compile that program instead of running it with runghc it'll behave differently.
18:31:13 <ddarius> Who uses runghc?
18:31:25 * shachaf
18:31:30 <shachaf> mm_freak: 16:22 <shachaf> So we can say: data Action = Exit | PutLine String Action | GetLine (String -> Action)
18:31:33 <rosie> mm_freak: thanks!
18:32:02 <shachaf> (Not that you were there. :-) )
18:32:09 <rosie> mm_freak: It's literally an EDSL, right, and not just a way to think of it?
18:32:11 <kallisti> mm_freak: I mostly think it would serve as a nice way to unify overloaded lists into the rest of the language.
18:32:25 <shachaf> rosie: The literal implementation of IO is what they call "none of your business".
18:32:27 <kallisti> but yeah view patterns are more or less the same, if a bit more verbose.
18:32:37 <rosie> shachaf: haha
18:32:43 <mm_freak> rosie: almost literally…  it translates not into a constructor to pattern-match against, but instead into a pointer to code that performs whatever the action is supposed to perform
18:32:45 <shachaf> But it's a domain-specific language embedded in Haskell, so yes.
18:32:45 <kallisti> s/none of your business/shenanigans/
18:33:17 <mm_freak> btw, i had an error in my view pattern earlier
18:33:28 <mm_freak> f (viewl -> x :< xs) = …
18:33:40 <mm_freak> that's quite concise and also captures the exact view you want
18:33:45 <mm_freak> there is also viewr for instance
18:34:19 <kallisti> yes, it would be nice if they were overloaded rather than in Sequence though
18:35:02 <mm_freak> well, we started with numbers, then we moved to strings, now you want lists…  there are infinitely many data structures
18:35:07 * BMeph thinks there should be "Cartesian" and "Polar" views for Complex numbers.
18:35:10 <mm_freak> you can't overload every type of view =)
18:35:17 <mm_freak> BMeph: there are
18:35:21 <mm_freak> BMeph: use a lens
18:35:22 <ddarius> BMeph: Simply write a function and use a view pattern.
18:35:48 <ddarius> View patterns are much more lightweight than views would be and don't require you to know ahead of time that you want something to be a view.
18:36:00 <mm_freak> (polar ^%= somethingOnPolarRepresentation) complexNumber
18:36:10 <kallisti> mm_freak: right. at this point it's a complaint about lack of standardized interface, rather than lack of a language feature. This is the majority of my Haskell complaints.
18:36:10 <shapr> ddarius: Have YOU installed ghclive and tried it out?
18:36:25 <ddarius> shapr: Isn't there supposed to be some site I can go to?
18:36:36 <mm_freak> kallisti: there is a standardized interface
18:36:37 <shachaf> ddarius: There's a site, but it lets you execute arbitrary code on shapr's machine.
18:36:43 <mm_freak> [] = List
18:36:50 <mm_freak> that's the standard
18:36:50 <ddarius> shachaf: That'd hardly be the first time.
18:37:09 <shapr> ddarius: Yes, the site is http://localhost:3000/ :-P
18:37:18 <BMeph> ddarius: If I wrote a function to do that, my thinking on it might be useful. Can't have that; it's against the Procrastinators' Code.
18:37:20 <mm_freak> the only peculiar thing about lists is that you have the [,,,] syntax
18:37:22 <ddarius> shapr: Seems down right now.
18:37:27 <ddarius> Which makes me wonder...
18:37:43 <kallisti> mm_freak: it is also not the same thing as a generalized ViewR/L
18:37:48 <shachaf> shapr: Ew. The contents of that site are disgusting, absolutely disgusting.
18:37:49 <kallisti> aka uncons
18:37:56 <shachaf> shapr: That's the last time I'm click on a link from you
18:38:17 <shachaf> When is cons going to get a type symmetric to uncons?
18:38:23 <shachaf> Maybe uncons should be called ns.
18:38:32 <mm_freak> kallisti: the point is, you can continue that forever…  there are infinitely many data structures with infinitely many types of views…  it's quite an arbitrary feature request
18:38:50 * ddarius calls uncons cdadrdoodle.
18:39:21 <kallisti> mm_freak: it's not a language feature request
18:39:29 <mm_freak> shachaf: ns is the dual of cons, not the inverse
18:39:39 <kallisti> it's a "have consistent library for basic interfaces" request.
18:39:44 <shapr> shachaf: haha
18:40:04 <mm_freak> kallisti: i agree there…  i think that viewl and viewr should use tuples instead of ViewL and ViewR
18:40:21 <mm_freak> other than that i'm happy with the interface
18:40:22 <rosie> There's (virtually) no escape from the IO monad, but is escape :: (Monad m) => m a -> a    possible for other monads?
18:40:33 <kallisti> mm_freak: I like the infix syntax, so I'd use parametric ADTs
18:40:41 <ddarius> kallisti wants Data.Set.Interface, Data.Map.Interface (or Inteface.Set ... ?)
18:40:58 <mm_freak> kallisti: tuples are infix other than that you need the parentheses
18:41:05 <kallisti> sort of. maybe not so monolithic.
18:41:11 <latro`a> rosie--if you had such a thing, you would have a copointed monad, which begins to look like it is also a monad; to my knowledge there aren't any nontrivial monads whose comonad is a comonad on Hask
18:41:16 <latro`a> erm, *also a comonad
18:41:33 <mm_freak> anyway, if Data.Sequence would use tuple views it would be consistent with all the other container modules
18:41:38 <mm_freak> minView uses a tuple
18:41:54 <ddarius> latro`a: Sure there are.
18:41:56 <latro`a> oh?
18:42:06 <latro`a> "nontrivial" here excludes both Trivial and Identity
18:42:12 <ddarius> Writer is a monad and a comonad.
18:42:13 <latro`a> which is somewhat deceptive, I realize
18:42:16 <mm_freak> kallisti: also i'm not sure how you would implement such a class in h2010
18:42:25 <latro`a> do you always have a datum to extract with Writer?
18:42:38 <shachaf> latro`a: Writer w a = (w,a)
18:42:41 <ddarius> latro`a: Of course you do.
18:42:42 <mm_freak> kallisti: it would almost certainly require an AT/fundep
18:42:43 <latro`a> ah
18:42:45 <latro`a> derp
18:42:48 <latro`a> ok, fair enough
18:43:05 <shachaf> Writer () ~ Identity, of course.
18:43:07 <mm_freak> Writer = Coreader
18:43:11 <latro`a> (I could dispute the semantics of what "trivial" means, but oh well)
18:43:28 <ddarius> Reader is also a monad and a comonad when it's parameter is a monoid.
18:43:35 <kallisti> mm_freak: I am not opposed to such radical, experimental, cutting edge, unstable language features.
18:43:42 <kallisti> /sarcasm
18:43:43 <latro`a> ddarius--that is the "isn't a comonad on Hask" thing
18:43:49 <latro`a> so no, that doesn't work
18:43:50 <shachaf> Hmm, and Writer is a monad when its parameter is a monoid.
18:44:10 <latro`a> it's a comonad, but it's a comonad on the wrong category
18:44:15 <shachaf> ddarius: Does it need to be a monoid? What's mappend used for?
18:44:16 <ddarius> latro`a: No it isn't.
18:44:18 <latro`a> which means it's not a Comonad in Haskell's sense
18:44:21 <mm_freak> Reader is a comonad when the argument is a monoid, Writer is a monad when the argument is monoid
18:44:26 <mm_freak> i see a symmetry there
18:44:29 <mm_freak> or duality
18:44:44 <latro`a> ddarius--how do you figure? you can't declare something to be a comonad on a subcategory of Hask
18:44:46 <ddarius> shachaf: How do you cojoin (r -> a) -> (r -> r -> a)?
18:45:09 <ddarius> latro`a: The environment parameter has to be a monoid, not the result.
18:45:11 <shachaf> ddarius: Ah, right. Makes sense.
18:45:17 <ddarius> latro`a: Exactly like Writer.
18:45:18 <latro`a> ah, nvm
18:45:22 <mm_freak> you also need mempty for extract
18:45:42 <mm_freak> extract :: (e -> a) -> a
18:46:06 <latro`a> also, cojoin f = \x y -> f (x `mappend` y)
18:46:07 <latro`a> ?
18:46:13 <mm_freak> mappend must be associative and mempty must be an identity wrt mappend
18:46:17 <ddarius> In fact, the Writer monad and comonad translates across the adjunction defining exponentials to produce the Reader comonad and monad.
18:46:20 <mm_freak> sounds like a monoid to me =)
18:46:34 <ddarius> And vice versa.
18:47:10 <latro`a> OK, so, categorically, when do a monad and its comonad live in the same category?
18:47:41 <ddarius> A monad doesn't "have" a comonad.
18:47:49 <latro`a> eh
18:47:51 <latro`a> you know what I meant
18:47:53 <ddarius> Unless you consider the monad viewed in the opposite category.
18:47:57 <ddarius> latro`a: No, I don't.
18:47:58 <latro`a> the adjunction that makes the monad makes a comonad too
18:48:04 <latro`a> erm, *makes a monad
18:48:11 <latro`a> but the comonad needn't be in the same category
18:48:29 <ddarius> latro`a: Okay, then those are completely unrelated, but they will certainly be in the same category only when both functors of the adjunction are endofunctors.
18:48:39 <ddarius> "completely unrelated" is a little too strong.
18:48:50 <latro`a> categorically they are intimately related
18:49:16 <latro`a> but from haskell's perspective they aren't very related, because we think in Hask, and stuff in other categories feels unrelated
18:49:48 <latro`a> anyway
18:49:49 <latro`a> gotcha
18:50:00 <latro`a> that's interesting, because it means that, for example
18:50:27 <latro`a> a monad created by the adjunction between a forgetful functor and its adjoint will never have a comonad in the same category
18:50:45 <latro`a> in particular the comonad corresponding to a free monad is never in the same category
18:58:37 <Rotaerk> latro`a, you know, from the perspective of someone who doesn't know category theory yet, that last line of yours looks like technobabble
18:58:47 <Rotaerk> well, last two
19:02:33 <rhodesd> Is there a library available that will produce a type annotated AST given a .hs file, files, or big 'ol chunk of text?  I think Language.Haskell.TypeCheck is intended for this, but I'm not certain if it is the only effort.
19:03:37 <kallisti> rhodesd: I believe haskell-src-exts does that
19:03:47 <mk> are monads useful in category theory, or are they primarily useful for compsci?
19:04:00 <rhodesd> Ok thanks kallisti, I'll check that
19:08:04 <frio> monads are just a monoid in the category of endofunctors mk
19:08:06 <frio> so
19:08:12 <frio> i have no idea
19:08:35 <Saizan> mk: they are a basic construction of CT used for e.g. talking about abstract algebra structures
19:08:43 <mk> frio: amusing, since I'm reading http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem right now
19:08:56 <frio> hahahaha mk :)
19:10:19 <mk> Saizan: maybe I'm missing some aspect of them, but it seems like they're very... I don't know if practical is the right word
19:11:41 <mk> primarily because they're suited to dealing with things that a mathematical function wouldn't be concerned with, like side-effects, but which a programmer might need to deal with
19:11:55 <ddarius> Category theory started in the mid-40s and monads were introduced in the late 50s.  I assure you, computer scientists weren't thinking about categorical semantics of anything at that time (though they did not too much later.)  Monads, as they are used in Haskell, didn't really start until the late 80s.
19:12:58 <Saizan> mk: that's very specific to how Haskell uses monads, and even talking about functions is a specialization of the concept
19:13:12 <mk> ddarius: interesting
19:13:37 <ddarius> Closure operators (which are what monads become in partial order categories) have been used for a very long time.
19:14:43 <mk> Saizan: functions being generalizations of functors, which are roughly mappings - is that about right?
19:15:14 <mk> s/gener/speci
19:15:20 <nand`> “monads seem very practical” <- hehe, so many people would say the complete opposite unfortunately
19:16:21 <mk> nand`: the chaining of 1-param functions is basically a monad
19:16:35 <aristid> nand`: fortunately those people usually don't get as far as learning what iteratees / pipes are
19:16:42 <Saizan> mk: no, that's not what i meant
19:16:58 <nand`> ‘1-param functions’ <- as opposed to?
19:17:04 <mk> Saizan: what are functions specialized from, then?
19:17:22 <nand`> arrows
19:17:36 <BMeph> relations!
19:17:43 <mk> nand`: as opposed to multi-param functions
19:17:49 <ddarius> Functions can be viewed as special cases of functors, namely functors between discrete categories.
19:17:56 <Saizan> mk: morphisms, also called arrows, one of the two parts of a category
19:18:05 <nand`> mk: oh; those. Good thing Haskell doesn't have 'em
19:18:47 <mk> nand`: any good reason? I rather like them
19:18:54 <nand`> functors are more like category homomorphisms; which are just set homomorphisms for discrete categories; and set homomorphisms are, well, functions
19:19:12 <nand`> mk: because you don't need them
19:19:28 <nand`> and they make everything more complicated
19:20:00 <ddarius> s/more like//
19:20:22 <Saizan> even between discrete categories there are some laws for a functor to be so
19:20:42 <Saizan> no, confused discrete with finite
19:20:50 <nand`> ah, was about to say
19:21:36 <mk> nand`: I see them a bit like function configurators. So (substring _ 0 3) is just (substring-first-three _), but not so ugly. You end up with a 1-param function, but you didn't have to introduce configuration into your call chain. You just plug that into the right slots
19:21:53 <nand`> huh
19:22:38 <mk> nand`: most functions that take multiple parameters use those parameters to configure the behaviour of the function
19:22:53 <zungaloca> how can i show a string ? in let x = [1,2,3,4,5]
19:23:07 <zungaloca> func6 :: (Show a) => [a] -> String func6 []       = "vacia" func6 (x:y:[]) = "dos" ++ show String func6  (x:y:_)  = "mas de dos"++
19:23:08 <ddarius> nand`: I advise you to cut your losses now.
19:23:15 <nand`> ddarius: I'm considering it
19:23:54 <Saizan> > show "foo"
19:23:55 <lambdabot>   "\"foo\""
19:24:27 <mk> ddarius: got something to say?
19:26:30 <mk> nand`: for example, multi-arg substring takes a string in the first slot, and returns a modified version of the string. The other params are just configuration, and don't need to be piped through the function like values are
19:27:29 <nand`> mk: maybe you want implicit parameters then
19:27:39 <ddarius> It takes a long time to play back a 70Ms at 30ksps.
19:27:50 <kallisti> nand`: it sounds like he's talking about partial application, strangely enough.
19:28:00 <kallisti> which is exactly what Haskell does.
19:28:11 <nand`> kallisti: yeah but then he'd still need to ‘pipe through’ the configuration
19:28:24 <nand`> eg. foo x y z = bar . bat x y z . blaz
19:28:36 <nand`> at least if I'm understanding it correctly
19:29:30 <mk> ddarius: shelve it then :)
19:30:46 <kallisti> > map (replicate 3) [1..10]
19:30:47 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3],[4,4,4],[5,5,5],[6,6,6],[7,7,7],[8,8,8],[9,9,9],[1...
19:30:53 <kallisti> 3 is my configuration for replicate
19:31:03 <mk> nand`: from what I'm looking up, implicit params seem to be default params - is that right?
19:31:11 <nand`> no
19:31:13 <kallisti> no, they're dynamically scoped variables.
19:31:27 <kallisti> as opposed to lexical.
19:32:20 <kallisti> mk: let ?x = 2 in f 4
19:32:21 <mk> so like *these-things* in clojure? (if anyone's familiar)
19:32:42 <kallisti> mk: here the variable ?x is available to literally anything that f calls.
19:32:44 <kallisti> and f itself.
19:32:47 <edwardk> preflex: xseen acowley
19:32:48 <preflex>  acowley was last seen on freenode/#haskell 2 hours, 6 minutes and 34 seconds ago, saying: edwardk: Okay, will do
19:33:25 <kallisti> mk: so your set of implicit parameters essentially constitutes an environment that functions can pull data from.
19:33:32 <mk> nand`: yeah I'm not sure what good that'd do. How do you like to express (substring _ 0 3)? (first-three)
19:33:48 <nand`> I like substring 0 3
19:34:27 <Rotaerk> prefix = substring 0
19:34:32 <frio> kallisti: you could also do that via a monad, couldn't you? hold the configuration in a monad, and then call your chain of functions (which require access to that configuration) inside the monad?
19:34:38 <frio> (forgive me if im brain-farting :))
19:34:43 <kallisti> frio: yes. that's called Reader.
19:34:47 <nand`> frio: rea--
19:34:48 <mk> nand`: how do you express (substring 3)? (the rest after three)
19:34:49 <nand`> yeah
19:34:57 <frio> you have no idea how stuff just clicked into place for me
19:34:59 <frio> awesome :D
19:35:02 <nand`> mk: drop 3
19:35:21 <frio> ty kallisti + nand` + mk for that discussion :)
19:36:00 <mk> frio: :)
19:36:28 <otters> or you could just use ((->) r) and save importing Reader
19:36:31 <otters> :P
19:36:50 <mk> nand`: I'm not a fan, since it seems like drop is just a partial substring
19:36:55 <kallisti> or you could use Reader to save importing Control.Monad.Instances, in some situations.
19:37:15 <kallisti> mk: if you assume a particular implementation of substring, then yes, it is.
19:37:21 <otters> I think ->-only signatures are prettier than those with Reader and stuff.
19:37:24 <nand`> kallisti: but it's not partial
19:37:27 <ddarius> In practice, using Reader by itself is more painful than explicitly passing the parameter.
19:37:29 <nand`> > drop 3 []
19:37:30 <lambdabot>   []
19:37:45 <kallisti> ddarius: depends.
19:37:56 <kallisti> specifically it depends on how much code there is.
19:38:03 * nand` usually mixes Reader into imperative monad stacks for configuration
19:38:06 <kallisti> Reader works well when /a lot/ of code pulls from the environment
19:38:10 <kallisti> otherwise you're wasting your time.
19:38:15 <ddarius> Not really.  More is worse.
19:38:25 <ddarius> Writing in monadic style when you don't have to is worse than passing a parameter.
19:38:52 <kallisti> also depends. I'm pretty comfortable with applicative/functor/monad/compositional style.
19:38:56 <ddarius> However, if you are already in monadic style or you suspect you may want to refactor to that in the future, then it is, of course, often worthwhile.
19:39:04 <ddarius> kallisti: But not with pure functions?
19:39:33 <kallisti> yes. Reader by itself often doesn't make sense.
19:39:47 <otters> because it's just (->)
19:39:55 <nand`> ((->) r) is more useful than Reader imo
19:39:59 <nand`> I use the former all the time
19:40:11 <nand`> no reason to wrap/unwrap everything
19:40:19 <zungaloca> how to show a string in func6 (a:b:[]) = "dos"++ show ???
19:40:21 <otters> it's just x <- foo instead of x <- asks foo
19:40:22 <latro`a> I forget, do blocks in ((->) r) model non-recursive let, yes?
19:40:24 <mk> kallisti: perhaps. My point is that (substring 0 3 ...) isn't that much different from (substring-0-3 ...) - with multiple args, you just specify the partial function right where you use it. No need to burden yourself with the idea of "returning another function"
19:40:44 <Saizan> zungaloca: what do you mean by "show a string"?
19:40:57 <kallisti> mk: there's very little effective difference, and very little burden on the programmer either way.
19:40:59 <ddarius> latro`a: do-notation in general models non-recursive let.
19:41:04 <latro`a> true
19:41:12 <frio> otters: could you please elaborate on what ((->) r) is? im still learning :)
19:41:13 <latro`a> but here it models it in the sense that they're actually isomorphic
19:41:26 <kallisti> mk: your _ / ... syntax however is ambiguous.  how do you write  (\y z x -> substring x y z) ?
19:41:28 <otters> frio: ((->) r) is the syntactically correct way to write (r ->)
19:41:29 <latro`a> frio: (->) is the prefix version of the type constructor for functions
19:41:30 <otters> it's a type constructor
19:41:37 <otters> a -> b -> c, for example
19:41:38 <kallisti> mk: using a _ does not allow you to change the argument ordering.
19:41:41 <ddarius> latro`a: No, Identity would.
19:41:49 <otters> and Reader a is functionally identical to ((->) a)
19:41:53 <latro`a> ...ah right
19:41:58 <zungaloca> saizan: func6 :: (Show a) => [a] -> String func6 []       = "empty" func6 (a:b:[]) = "two" func6  (a:b:_)  = "more"++ show ???
19:42:04 <otters> > let addOne = do { x <- (+1); return x } in addOne 5
19:42:05 <lambdabot>   6
19:42:08 <otters> frio: ^
19:42:19 <otters> which, in the Reader monad, would be do { x <- asks (+1); return x }
19:42:24 <mk> kallisti: I secretly changed the definition, to make my example of "adding dashes in the middle" more clear
19:42:34 <frio> interesting
19:42:46 <frio> im at work right now, so cant really spend the time to grok that properly (but i think i do!)
19:42:50 <ddarius> addOne = (+1) ...
19:42:52 <Saizan> zungaloca: i don't understand, the show function simply takes an argument
19:42:52 <otters> frio: basically, instead of doing x <- asks f, you just do x <- f
19:42:54 <frio> ill copy/paste this all down though :)
19:43:01 <otters> and instead of x <- ask, you do x <- id
19:43:04 <otters> :P
19:43:27 <frio> yeah; i can see the effect of it (which is cool!), but i need to spend some time playing with it to properly get it
19:43:28 <Saizan> zungaloca: the only restriction is that its type must be an instance of Show
19:43:32 <kallisti> mk: I'm not seeing what you mean by "with multiple args, you just specify the partial function right there when you use it"
19:43:35 <frio> (as with most haskell for me atm :p)
19:43:37 <kallisti> mk: how does this differ from single-argument?
19:43:45 <otters> frio: do you understand Reader?
19:43:45 <frio> ty otters :)
19:43:45 <mk> kallisti: small burdens add up. If I'm adding two numbers, why do I need to however briefly recall that first, a function will come out? And if I don't then why don't we just use multi-args. If it's just preference, that's fine - I'm just wondering if there's a knockdown reason that I might have missed
19:44:02 <nand`> > 2+3
19:44:04 <lambdabot>   5
19:44:07 <nand`> oh no, I needed to remember that a function comes out!
19:44:12 <kallisti> mk: the cognitive load is the same. either way you are returning functions.
19:44:20 <ddarius> > (2+3) 4
19:44:21 <lambdabot>   5
19:44:26 * hackagebot couchdb-conduit 0.10.3 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.10.3 (AlexanderDorofeev)
19:44:26 <nand`> ddarius: :)
19:44:28 <frio> otters: didn't even know it existed until *just* then, but ive got a little weekend project (in another language) that my brain's been screaming out for it, basically
19:44:49 <otters> frio: well, if you understand Reader, you understand ((->) a) because they're isomorphic
19:44:53 <otters> I think that's the term
19:44:56 <kallisti> mk: there is no effective difference. occam's razor wins.
19:44:57 <Saizan> mk: when we say haskell has only single-argument functions we mean that in Haskell what's transparently usable as a n-args function is also transparently seen as a 1-arg function returning a (n-1)-arg function
19:45:06 <mk> kallisti: because the way you specify is by filling in the other arguments of the function, and if you decide not to fill them in, defaults are provided: (substring 0 3) ... (substring 3) ('maxint' being the default)
19:45:10 <nand`> otters: Reader a to be pedantic but yes
19:45:17 <otters> oh yeah
19:45:17 <frio> awesome otters :)
19:45:20 <nand`> they're isomorphic; the isomorphism is given by Reader and runReader
19:45:20 <zungaloca> Saizan:func6 :: (Show a) => [a] -> String func6 []       = "empty" func6 (a:b:[]) = "two"++ show a ++ show b func6  (a:b:_)  = "more"++ show a ++show b
19:45:26 <otters> Reader is isomorphic to (->) then
19:45:28 <frio> ill have to have a play with all this tonight
19:45:34 <otters> that's easier to write
19:45:36 <ddarius> Yeah eta reduction.
19:45:41 <otters> ((->) a) just hurts my fingers with all the ().
19:45:43 <ddarius> s/Yeah/Yay/
19:45:51 <kallisti> mk: defaults built-in to functions are overrated. what happens when there are multiple sets of defaults?
19:45:51 <zungaloca> Saizan: where it say more how i add the rest of to string to "printf"
19:46:04 <mk> kallisti: yeah, I get that, but my razor cuts out "let's create a new function", which is actually an extra concept, while "add yet another param" is not
19:46:13 <kallisti> mk: the solution: use a record for your large parameter set. provide multiple pre-defined records.
19:46:23 <otters> nand`: in C you would have just said "wrong." and then called me a third grader
19:46:28 <otters> this is why I love #haskell
19:46:52 <Saizan> mk: in fact we do use examples like (substring 0 3) just fine and with that syntax, and you can either think of substring as taking 2 arguments there or taking one returning a function and taking another
19:46:53 <mk> kallisti: where are there multiple defaults? I mean, sensible defaults, like substring's 0 and last
19:46:54 <nand`> #haskell seems fairly friendly for the most part
19:46:59 <kallisti> mk: how are you not creating a new function?
19:47:03 <ddarius> nand`: Overly so...
19:47:25 <kallisti> mk: does substring 0 3 not produce a function?
19:47:34 <mk> nand`: ddarius is spoiling for a fight ;)
19:47:41 <Saizan> zungaloca: to printf? to output them on the terminal?
19:48:23 <Saizan> mk: it will really become a problem if you keep not learning haskell
19:48:28 <nand`> ^
19:48:39 <frio> mk: the very basics: let's say i define a function foo a b c = whatever a b c
19:48:55 <ddarius> jfredett: Are you alive?
19:49:02 <mk> kallisti: not if there are multiple arguments, no. You're missing the main param. You'd have to do a partial, and then yes, an actual function would be produced. But you don't need to do that, since you can just do (substring "hello" 0 3) - partials for free
19:49:19 <frio> the way that's actually executed (i believe!) is by partially applying the function
19:49:25 <frio> (foo a b) c
19:49:31 <kallisti> mk: you do not have to conceptually think about the fact that functions are curried
19:49:31 <frio> ((foo a) b) c
19:49:42 <kallisti> mk: in the same way that you don't have to conceptually think about in your example.
19:49:45 <nand`> juxtaposition is left associative
19:49:57 <frio> so -- a function with multiple args is really just syntactic sugar for a stack of simple, single-arg functions :)
19:50:00 <latro`a> you sometimes do, but a lot of times it is indeed simpler to just think of functions as being n-ary
19:50:01 <kallisti> mk: in fact I'm finding little difference in what you're saying and how Haskell works (with the exception of built-in default values)
19:50:20 <nand`> default values can be modeled with Maybe
19:50:24 <latro`a> if the return type is a type variable that becomes a function type
19:50:25 <kallisti> and records
19:50:33 <latro`a> then you have to think about currying
19:50:38 <latro`a> "const id" is the simplest example
19:50:49 <nand`> and Default; eg. in tandem with a newtype or record
19:51:04 <frio> anyway, cheers otters for all that before
19:51:12 <otters> np
19:51:13 <kallisti> mk: replace your substring function with a function of the type:  IndexParameters -> String -> String.  IndexParameters is a record with 2 Maybe Int fields, representing optional indices. Now you provide 3 functions: range :: Int -> Int -> IndexParameters; upTo :: Int -> IndexParameters; from :: Int -> IndexParameters
19:51:23 <latro`a> eh, actually, I guess "id f" for some function f is actually the simplest example
19:51:30 <kallisti> mk: now you can write substring (from 3), substring (upTo 5), and substring (range 3 5)
19:51:44 <ddarius> kallisti: Nice.
19:51:47 <zungaloca> Saizan: yes
19:52:06 <nand`> data Range = From Int | UpTo Int | Range Int Int
19:52:07 <otters> but if IndexParameters has 2 Maybe fields, doesn't that mean you can take a substring with no bounds
19:52:12 <nand`> no need to overcomplicate things with Maybes
19:52:27 <kallisti> that works as well
19:52:46 <nand`> also what otters said
19:52:46 <kallisti> except it lacks the trivial IndexParameters Nothing Nothing case
19:52:46 <latro`a> eh, I actually think the Maybe version is cleaner here
19:52:48 <kallisti> which is stupid.
19:52:57 <latro`a> not necessarily in general
19:52:58 <latro`a> but
19:53:08 <latro`a> IndexParameters {top :: Maybe Int, bottom :: Maybe Int}
19:53:11 <latro`a> is nice
19:54:02 <adnauseam> borat thumbs up.jpg
19:54:21 <Saizan> zungaloca: you can't from a function of that type, if it is for debugging you can use Debug.Trace.trace
19:54:58 <mk> kallisti: or instead of making everyone remember 3 functions, you could just define a single function that takes multiple params
19:55:20 <kallisti> mk: consider a much more complex situation. Say you want to configure options for a database, and there are 3 very common use-cases. you can provide 3 different functions and/or constants to produce large records conveniently. This is essentially the main benefit of defaulting, keyword parameters, etc, except that records are more powerful.
19:56:19 <zungaloca> Saizan: k thanks
19:56:40 <Saizan> kallisti: i don't think mk has ever advocated keyword/defaulting/implicits or whatever in this discussion, it's simply a misunderstanding of what "there are only 1-param functions" in a curried language means
19:56:48 <kallisti> mk: and now they must remember what happens when you apply 1 function argument vs. 2. also, your version of substring is going to be missing either the from or upTo case, because it can't differentiate.
19:57:16 <Saizan> icbw though
19:57:22 <nand`> I'm not even sure how currying relates; since you can just do :: (a, b) -> c  which is a 1-argument function
19:58:58 <kallisti> it certainly /seems/ like mk understands partial application, but I'm not sure where he thinks the cognitive load of partial application comes from.
19:59:16 <kallisti> here's a "2-argument" function in Haskell: f x y
19:59:24 <ddarius> kallisti: I wouldn't make that assumption.
19:59:27 <kallisti> here's a 2-argument function in a language like Haskell but with multiple parameters per function: f x y
19:59:38 <hhk> 1234567890-=qwertyuiopasdfghjklzxcvbnm
19:59:43 <latro`a> I'm not sure why partial application throws people off more than lambdas
20:00:07 <ddarius> Because people call it partial application.  There is no partial application.  There is only application.
20:00:16 <latro`a> true, ish
20:00:25 <nand`> I use partial application in languages that have multi-param functions :(
20:00:32 <otters> unless you can't
20:00:44 <latro`a> the problem is that actually thinking of like
20:00:48 <latro`a> f x1 x2 .... xn
20:00:49 <latro`a> as
20:01:07 <latro`a> (((((...(f x1) x2) x3) ... xn
20:01:15 <latro`a> is terrible
20:01:34 <kallisti> programming is like learning how to ride a really complicated bicycle.
20:01:55 <latro`a> yes, that's what it is, but thinking of it like that doesn't help unless you "partially apply"
20:01:58 <nand`> except most people never lose the training wheels?
20:02:22 <Rotaerk> I tend to think of my functions as (f x1) x2 x3 x4 ...
20:02:31 <Rotaerk> because I name f based on the type of x1
20:02:40 <latro`a> the problem is essentially that the "intermediate" functions don't necessarily mean anything
20:02:43 <Rotaerk> and if the parameters are reversed, the name changes
20:02:48 <kallisti> I usually think of my functions multiple different ways depending on how I'm using them.
20:02:51 <latro`a> they have semantics to the language, but they needn't mean anything significant
20:03:16 <nand`> I'm not sure I agree with that
20:03:50 <nand`> the ‘f x’ in ‘f x y z’ means ‘f x’.  for example ‘add 2 3’ means something but so does ‘add 2’ <- exactly what it says on the tin
20:04:07 <latro`a> that's a place where it *does* mean something significant
20:04:13 <latro`a> but especially when you have many many arguments
20:04:15 <nand`> then I think that always applies
20:04:22 <Rotaerk> subtract 5 6 should mean 6 - 5
20:04:31 <nand`> it does
20:04:38 <Rotaerk> and subtractFrom 5 6 = 5 - 6
20:05:05 <latro`a> the "meaning" of a partially applied function which has many arguments is rather tenuous
20:05:09 <latro`a> is my point
20:05:18 <Rotaerk> well, beyond the first argument, I agree
20:05:32 <Rotaerk> the order of the arguments after the first one don't really affect how i name the function
20:05:50 <kallisti> I guess you could compare Haskell to an especially complicated bicycle, with a really cool bike shed.
20:05:53 <Rotaerk> I wonder if there would be a sensical syntax where you can make your multi-argument functions into english phrases or something
20:06:07 <latro`a> I think my point here is largely supported by the fact that we often use records when arguments tend to go together
20:06:09 <latro`a> like
20:06:13 <ddarius> kallisti: It would be cool if only it were the right color...
20:06:13 <nand`> but haskell is one of the simplest languages I know
20:06:20 <latro`a> if you had a function which has 5 options and 1 actual "input"
20:06:27 <latro`a> you'd put the options in a record, probably
20:06:29 <ddarius> nand`++
20:06:33 <latro`a> even though that means you can do less stuff with closures
20:06:42 <latro`a> (eh....sorta)
20:06:43 <nand`> especially once you strip away the syntactic sugar
20:06:47 <nand`> it's a very tiny language
20:06:49 <Rotaerk> subtract x from y = y - x;  s5 = subtract 5;  s5 from 2
20:06:52 <Rotaerk> or something
20:07:13 <latro`a> there "from" is just id
20:07:22 <latro`a> erm
20:07:24 <Rotaerk> well the "from" isn't an argument
20:07:26 <latro`a> something like that
20:07:27 <latro`a> I know
20:07:32 <latro`a> you're applying from to subtract x and y
20:07:36 <latro`a> so
20:07:40 <latro`a> subtract x `from` y
20:07:40 <ddarius> data From = From
20:07:48 <nand`> from = ()
20:07:57 <Rotaerk> hmm
20:08:07 <ddarius> nand`: You don't want people saying silly things like subtract x () y
20:08:14 <latro`a> subtract x `id` y
20:08:19 <nand`> yeah well, from = From :)
20:08:20 <latro`a> does what you are thikning
20:08:27 <latro`a> *thinking
20:08:54 <nand`> > let subtract x from y = y - x; from = () in subtract 3 from 5
20:08:55 <lambdabot>   2
20:09:12 * ddarius assumes jfredett is dead.
20:09:17 <latro`a> > let from = id in subtract 3 `from` 5
20:09:19 <lambdabot>   2
20:09:20 <Saizan> actually, one tends to stop thinking of partial application, closures and similar (except for micro-optimizations maybe), and just caring about which argument goes where
20:09:39 <shachaf> preflex: seen jfredett
20:09:39 <preflex>  jfredett was last seen on #haskell-blah 3 days, 13 hours, 40 minutes and 25 seconds ago, saying: I have... forseen it.
20:09:51 <nand`> I order my parameters in terms of how they're best ‘partially applied’
20:10:05 <latro`a> when that makes sense that's usually the best idea
20:10:07 <Rotaerk> and if the existing function isn't ordered in a convenient fashion, write a new one in terms of it
20:10:11 <latro`a> because it minimizes the need for lambdas
20:10:18 <thetallguy> edwardk: I see that Pointed was deprecated.  I can't find a forward reference. Do you have a class representing a type with one distinguished value, no other properties?
20:10:24 <Rotaerk> if you can come up with a meaningful name for the reordering
20:11:19 <edwardk> thetallguy: the pointed package still provides the Pointed class. i generally frown on the class because there is very little you can correctly do with a Pointed container
20:11:28 <edwardk> but its still there
20:11:39 <edwardk> i just don't make any real packages that depend on it
20:11:52 <rosie> What is "Control" in "Control.Monad"? Is it just a prefix, or is there a module? I can't seem to find it on hoogle
20:11:57 <edwardk> take for instance the Pointed instance you might make for Set
20:12:05 <ddarius> rosie: The former.
20:12:12 <ddarius> rosie: Haskell's namespace is flat.
20:12:18 <edwardk> you might consider building a Set by abusing Pointed and mappend, but there are no laws that say that its sound to do so
20:12:29 <edwardk> merely your one-off knowledge that for set it does the right thing
20:12:50 <edwardk> Almost every other use of Pointed follows this pattern
20:13:12 <ddarius> point x = {} of course.
20:13:12 <nand`> Rotaerk: and if it is ordered in a convenient fashion, you give it half a dozen new names anyway
20:13:13 <thetallguy> edwardk: Yeah, it's always marginal in every case I've wanted it.
20:13:14 <edwardk> at least, say, for the awkward MonadZero proposals, you had some laws
20:13:27 <edwardk> ddarius: =)
20:13:45 <Rotaerk> nand`, not sure if i've done that before
20:13:45 <rosie> ddarius: It would be possible to simulate a hierarchical namespace, though, right?
20:13:46 <Rotaerk> maybe though
20:13:51 <dolio> ddarius: Obviously point should be a monomorphism, except when it isn't.
20:14:18 <edwardk> thetallguy: anyways, the only law you can state for pointed functors is already a free theorem, so Pointed now no longer incurs the Functor constraint
20:14:20 <ddarius> dolio: Those aren't "really" function.
20:14:37 <thetallguy> edwardk: I've avoided it several times by looking at neighboring types and refining them.
20:14:38 <ddarius> rosie: Yes, you could make a Control module.  It would have no relation to Control.Monad etc.
20:14:39 <nand`> if you've given every involved functions good-sounding names but your haskell still doesn't look like english, you introduce meaningless combinators to fill in the missing words; usually defined as = id
20:14:44 <ddarius> rosie: There isn't one to my knowledge.
20:14:50 <rosie> ddarius: thanks
20:14:58 <edwardk> and i just don't make any packages that depend on it
20:15:04 <edwardk> thetallguy: exactly
20:15:31 <thetallguy> edwardk: Cool, thanks.  That kept nagging at me.
20:16:05 <edwardk> thetallguy: i find it is much more useful to work with, say a semigroup or semigroupoid than to work with a pointed structure, and i found that once i switch my thinking around to allow for that i didn't feel the need to use pointed any more
20:16:25 <ddarius> rosie: As an example, Data.Graph and Data.Graph.Inductive are completely different libraries.
20:16:52 <rosie> ddarius: got it, thanks!
20:16:55 <nand`> modules just have hierarchical-looking names; but the names are completely arbitrary
20:17:11 <shachaf> ddarius: The namespace isn't hierarchical but in GHC it corresponds to a directory tree.
20:17:19 <thetallguy> edwardk: I saw that shift in the documentation trail, but I guess I didn'twiden my scope enough.
20:17:38 <nand`> Would Foo..Bar be a valid module name?
20:17:40 <dolio> Pointed set tends to be an uninteresting structure, I think.
20:17:43 <ddarius> shachaf: In GHC (and I think every other implementation).  The Report says nothing about files or directories at all (except for the file handling API).
20:17:53 <thetallguy> edwardk: I've got a pile of types stacked on top of the one I want to change.  Need to clean house before I can fix it.
20:17:54 <shachaf> ddarius: Right.
20:18:27 <dolio> Although it's the proper 0-tuply monoidal 0-category or something.
20:18:32 <ddarius> dolio: The category of pointed sets has a zero object unlike Set.
20:18:34 <dolio> Not sets.
20:18:40 <shachaf> rosie: Did you write the interpreter yet? :-)
20:18:46 <nand`> ‘pointed set’
20:18:48 <nand`> ?
20:19:45 <dolio> nand`: Set together with a distinguished element.
20:20:05 * nand` looked it up. nand` should have done that before asking
20:20:18 <thetallguy> nand`: sort of like a Monoid, but without the identity property
20:20:28 <dolio> ddarius: I find that hard to get excited about.
20:20:31 <rosie> shachaf: haha, I'm telling you I need a hint! my intuition tells me I should use main = do { --while the Action is not Exit, keep executing actions-- }… give me a hint?
20:20:38 <ddarius> Zero objects are awesome.
20:20:54 <nand`> thetallguy: without the operation in general
20:21:04 <shachaf> rosie: Don't write main. Write interpret.
20:21:18 <thetallguy> nand`:  yes, was just looking at semigroup, which does have the op.
20:21:26 <shachaf> rosie: Action is a recursive data type, so it's reasonable that an interpreter for it would be a recursive function.
20:21:26 <Nereid> the category of pointed sets is quite fine.
20:21:37 <Nereid> incidentally, it's equivalent to the category of sets with partial functions.
20:21:59 <nand`> a monoid (M,e,·) without the · is a pointed set (M,e); and monoid homomorphisms on the former are pointed set homomorphisms on the latter (f e = e')
20:22:06 <Nereid> but certain constructions are more easily described in the former, such as products
20:22:40 <ddarius> Domain(f) = coim(f)
20:22:58 <rosie> shachaf: I can't seem to find the documentation for the actual interpret function
20:23:28 <shachaf> rosie: I'm asking you to write it. :-)
20:23:39 <ddarius> shachaf: The documentation?
20:23:40 <Nereid> ddarius: neat.
20:23:51 <shachaf> ddarius: I was thinking of the function, but either works.
20:24:22 <ddarius> shachaf: Indeed.  I always require my documentation to be a complete specification.
20:24:26 <shachaf> ddarius: As a middle ground between the implementation and the documentation, the type signature.
20:24:58 <ddarius> Type signatures are for those who don't document their code properly.
20:26:03 * ddarius should make a Djinn for a stack language.
20:26:38 * ddarius doesn't know how people watch TV.  I can never find the time.
20:26:38 <dolio> Should be even easier.
20:26:49 <dolio> None of that exchange stuff to worry about.
20:27:46 <ddarius> Olli, olli, ⊗en free
20:29:05 <Saizan> i thought i could rederive djinn by transforming the naive prolog STLC checker but the usual techniques don't really get me anywhere
20:29:49 <Saizan> too bad the paper doesn't give much of a story of how they found the right rules
20:29:51 <rosie> shachaf: I'm sure this is wrong. gimme a hint? interpret :: Action -> IO ();   interpret = do {s <- GetLine; PutLine s; Exit; }
20:31:02 <shachaf> rosie: Start by having interpret take an argument. :-)
20:31:29 <shachaf> The thing you're *returning* should have type IO (); the thing you're *taking* should have type Action.
20:39:04 <ddarius> How do you initialize a (Storable) vector from a list?
20:39:09 <rosie> shachaf: Another hint? interpret :: Action -> IO ();  interpet Exit = return ()    | PutLine String Action = do { putStrLn String; interpret Action }; | GetLine (Action -> String) = s <- getLine;  PutLine s;}
20:39:36 <shachaf> rosie: Other than the syntax errors, that's almost correct.
20:39:50 <rosie> hey (: treat me to a solution?
20:39:53 <ddarius> Ah, fromList.
20:40:06 <shachaf> rosie: You can do it!
20:40:11 <shachaf> interpret Exit = return ()
20:40:20 <shachaf> interpret (PutLine string next) = ?
20:40:41 <rosie> do { putStrLn string; interpet next; }
20:41:05 <Nereid> @undo do {putStrLn strnig ; interpret next }
20:41:06 <lambdabot> putStrLn strnig >> interpret next
20:41:10 <Nereid> I can type.
20:41:10 <shachaf> interpret (GetLine x) = ?
20:42:09 <rosie> do { s <- getLine x; putStrLn s; }
20:42:42 <shachaf> rosie: Not really. Think of the types of x and getLine and interpret
20:42:43 <nand`> that doesn't seem right
20:43:16 <nand`> (you also introduced an error that was not previous in the version you gave above)
20:43:19 <nand`> not present*
20:43:46 <Nereid> you don't need a semicolon for the last thing in a do block
20:43:49 <Nereid> btw
20:44:00 <shachaf> rosie: Think about what it should do. Do you understand why you have a (String -> Action) thing in there?
20:44:33 <Nereid> where's the problem statement? :)
20:44:51 <rosie> I thought GetLine itself would have the type String -> Action
20:45:01 <shachaf> Nereid: Write an interpreter for data Action = Exit | PutLine String Action | GetLine (String -> Action)
20:45:04 <nand`> given data Action = Exit | PutLine String Action | GetLine (String -> Action) implement interpret :: Action -> IO ()
20:45:07 <shachaf> Nereid: But don't spoil it!
20:45:14 <shachaf> rosie: No, it's a constructor.
20:45:15 <Nereid> of course I won't spoil it.
20:46:56 <Nereid> so one of the patterns we have to match on is GetLine x, so
20:46:59 <rosie> alright, I have a data value that takes in a String and returns an Action, would could be Exit, get another string, or print the string to the console… I'm not sure how it relates to GetLine if it isn't GetLine itself
20:47:01 <Nereid> interpret (GetLine x) = ?
20:47:05 <Nereid> here x :: String -> Action
20:47:50 <nand`> data Maybe a = Nothing | Just a
20:47:52 <nand`> :t Just
20:47:52 <Nereid> but to use x, you have to get a String somehow.
20:47:53 <lambdabot> forall a. a -> Maybe a
20:47:56 <shachaf> Nereid: Remember, just because someone got a line it doesn't mean they're done with their program. So you'll definitely want to recurse, like you did for the PutLine case.
20:48:01 <nand`> rosie: ^ that's how data constructors relate to the type they carry
20:48:14 <Nereid> shachaf: wrong target?
20:48:23 <ddarius> @hoogle conj
20:48:23 <lambdabot> Data.Complex conjugate :: RealFloat a => Complex a -> Complex a
20:48:24 <lambdabot> Test.QuickCheck.Property conjoin :: Testable prop => [prop] -> Property
20:48:24 <lambdabot> Test.QuickCheck conjoin :: Testable prop => [prop] -> Property
20:48:26 <shachaf> rosie: What I said to Nereid above. ☝
20:49:27 <rosie> shachaf: thanks for the hints. getLine can only rerun an IO (), not an Action. How do I get that Action?
20:49:34 <rosie> ah
20:49:39 <rosie> I have the function x
20:49:42 <Nereid> getLine :: IO String, actually.
20:49:43 <rosie> I don't need to use getLine
20:49:55 <rosie> Nereid: right
20:50:10 <shachaf> rosie: GetLine is very different from getLine.
20:50:18 <shachaf> I probably shouldn't have given them the same name. :-)
20:50:21 <rosie> do { a <- x; interpret a }
20:50:29 <Nereid> type error.
20:51:09 <shachaf> Think of the types as a puzzle. There's pretty much only one way they can fit together.
20:51:20 <rosie> x returns an Action. a is then an Action. Right?
20:51:37 <Nereid> if you write a <- x and you want a to be an Action,
20:51:37 <shachaf> x takes a String and returns an Action.
20:51:40 <nand`> that's not how function application works
20:51:41 <Nereid> then x would have had to be an IO Action.
20:51:42 <nand`> rosie
20:51:48 <shachaf> Which means that (x foo) is an Action when a is a String.
20:51:56 <shachaf> But "<-" doesn't work that way.
20:52:16 * ddarius writes an FFT based correlator because it's easier.
20:52:56 <rosie> shachaf: where do I get the sring from?
20:52:59 <rosie> *String
20:53:30 <shachaf> @ty getLine
20:53:31 <lambdabot> IO String
20:54:53 <rosie>  do { a <- x $ getLine; interpret a }
20:55:07 <shachaf> x :: String -> Action
20:55:10 <shachaf> getLine :: IO String
20:55:14 <shachaf> x getLine :: type error
20:55:17 <rosie> or do {s <- getLine; a <- x s; interpet a }
20:55:25 <Nereid> closer!
20:55:31 <shachaf> Something right in between the two. :-)
20:55:33 <Nereid> let's look here:
20:55:42 <Nereid> getLine :: IO String, so when you write s <- getLine, we have s :: String.
20:55:44 <Nereid> this is cool.
20:55:57 <Nereid> so, if x :: String -> Action, then x s :: Action
20:56:18 <Nereid> but there's no IO thing on there.
20:56:23 <Nereid> remember, <- is for pulling things out of IO.
20:56:35 <shachaf> "pulling things out of" :-(
20:56:42 <Nereid> well whatever.
20:56:50 <Nereid> you need an IO value on the right side of <-
20:56:55 <rosie> aha! so do {s <- getLine; a = x s; interpet a }.  Is <- only for IO?
20:57:08 <nand`> that function looks correct
20:57:10 <shachaf> rosie: <- is only for executing actions.
20:57:14 <nand`> “Is <- only for IO” <- no
20:57:18 <shachaf> (And getting their results.)
20:57:26 <shachaf> And it's also for nand` to make his little comments.
20:57:30 <shachaf> But that's it.
20:57:33 <Nereid> in the IO monad, yes. in any other monad, it's for things in that monad. but ignore this if it didn't make sense.
20:57:46 <Nereid> anyway.
20:57:46 <YayMe> arghh I implemented a RemoveElementIf function today at work (C# shop) which takes a predicate, because I had to remove like 8 different elements in the event of particular criteria, and even that instance of a higher order function I think will fail code review for being too complex
20:57:53 <shachaf> rosie: Another way to write that is do { s <- getLine; interpret (x s) }
20:57:57 <Nereid> rosie: that's pretty much it. just remember that inside a do block you have to write
20:58:00 <Nereid> let a = x s
20:58:08 <Nereid> or do shachaf's thing
20:58:34 <Nereid> @undo do {s <- getLine ; interpret (x s) }
20:58:35 <lambdabot> getLine >>= \ s -> interpret (x s)
20:58:38 * nand` .oO( getLine >>= interpret . a )
20:58:43 <YayMe> Please god make colleges start teaching functional languages again instead of all java OO so people can understand abstraction..
20:58:44 <nand`> s/a/x/
20:58:57 <rosie> thanks all!
20:59:00 <Nereid> :)
20:59:09 * ddarius just writes CPS monads in Silverlight.
20:59:11 <shachaf> rosie: I have the feeling this didn't quite make sense yet. :-)
20:59:27 * ddarius has a feeling many prerequisites were missing.
20:59:27 * hackagebot lens 2.4.0.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-2.4.0.2 (EdwardKmett)
20:59:33 * shachaf too.
20:59:50 <Nereid> still 2.4? you're slowing down edwardk ;)
20:59:59 <edwardk> Nereid: deliberately
21:00:30 <edwardk> the last two were submitted patches. one to fix up some haddock issues, one to make it 7.6 friendly
21:01:15 <ddarius> This signal dump looks rather periodic, but it should not be periodic.
21:03:00 <rosie> I think it does… whenever we see Exit as an action, we return (), and our program finishes. Whenever we match against a PutLine string next, we want to use usual IO and use putStrLn string, and then we have another action that we want to complete right after, so we interrupt that. And then we can get input from the user by matching against a function that gets the line from the user (I have no idea what this function is) and it gets the string, and 
21:03:00 <rosie> we interpret that … I assume that String -> Action function may include more calls to GetLine, or it'll take the string and package it up so that we'll have PutLine string and our next Action… yeah?
21:04:27 <shachaf> rosie: The String -> Action function can do whatever it wants.
21:04:38 <shachaf> It can look at the String and decide what to do next.
21:04:54 <shachaf> Or it can ignore it. Or it can just return a PutLine that prints the string.
21:04:58 <rosie> getcha, e.g. the string could be "say bye now" and the function would match against that and say the next action is EXit
21:05:10 <shachaf> Yep.
21:05:47 <shachaf> If you put Action and interpret into a file, and "main :: IO (); main = interpret realMain; realMain :: Action; realMain = ...", you can write your own programs using this language!
21:06:10 <nand`> note how Action is sort of like a ‘list’ or ‘string’ of actions to perform; delimited by Exit
21:06:19 <shachaf> nand`: Except it's not.
21:06:27 <YayMe> Has there ever been anything like a lisp dialect similar to haskell's terse syntax?
21:06:46 <shachaf> If it didn't have GetLine, it would be a list.
21:07:03 <shachaf> (And then you wouldn't need Monad for it, just Monoid.)
21:07:11 <YayMe> Would it even be remotely possible to get homoiconicity out of haskell's syntax?
21:07:59 <nand`> I still think the comparison applies; GetLine is still ‘stringy’ in a sense that after you've done and perform the line-getting, you're left with a ‘next’ action to perform
21:08:21 <shachaf> nand`: Yes, but the "next" action can depend on the String.
21:08:32 <shachaf> This makes it very much not list-like.
21:28:38 <ddarius> Hmm, I think I'm also seeing ATCRBS signals.
21:28:47 <keyu> I'm having trouble downloading a package from cabal: I'm typing "cabal install zeromq-haskell" and its giving me a error that I'm sure how to fix
21:29:02 <keyu> not sure
21:31:02 <shachaf> keyu: It's the monomorphism restriction. Just add -XNoMonomorphismRestriction to the .cabal.
21:31:19 <shachaf> (Or maybe it's something else. But without seeing the error...)
21:31:52 <keyu> ah its the same error listed under the manual download heading here: http://www.zeromq.org/bindings:haskell
21:31:57 <YayMe> how well does haskell interop with java?
21:32:12 <Veinor> i don't think it does at all?
21:32:35 <YayMe> Wow that's impressive
21:32:46 <Veinor> like, i mean
21:32:54 <shachaf> keyu: I recommend that you Just follow the instructions and the installation should finish without errors.
21:33:15 <Veinor> apparently there are bindings that i wasn't aware of. but i'm not sure why you'd want haskell and java to interact
21:33:25 <Veinor> i guess: what are you trying to do
21:33:28 <keyu> haha, thats the part I don't know how to do
21:33:40 <Veinor> keyu: where'd you install 0MQ to?
21:33:42 <shachaf> Veinor: Because you have a program or library written in Java and one written in Haskell, presumably?
21:34:05 <ddarius> shachaf: Why would you have a program or library written in Java?
21:34:21 <YayMe> I can't wrap my head around why Java is still the predominant high level language from what I understand of it..
21:34:38 <mapreduce> YayMe: Because of the JVM.
21:34:51 <keyu> I opened up the shell and just typed it "cabal install" in the zeromq folder, I am supposed to put it into the haskell folder first?
21:35:02 <shachaf> ddarius: I didn't write it, man.
21:35:04 <Veinor> keyu: did you install 0mq itself?
21:35:08 <shachaf> keyu: You're supposed to install 0mq.
21:35:12 <YayMe> mapreduce: Is that really it?
21:35:29 <Veinor> the zeromq-haskell package and friends are just bindings to 0mq, i'd imagine
21:35:31 <mapreduce> YayMe: Not originally, but it pretty much is now.
21:35:41 <mapreduce> Originally it was marketed as a safe C++.
21:35:49 <keyu> ah, ok, thanks, I'm gonna try that now
21:35:57 <mapreduce> and there were a lot of C++ people to market that to.
21:36:17 <YayMe> true enough
21:36:45 <YayMe> that makes sense, back when the options were C++ or java I can see that, and until .net 3.5 circa 2008 it was still basically the truth I guess
21:37:02 <ddarius> The JVM is the only remotely good thing about the Java ecosystem.
21:37:08 <mapreduce> .NET still is not an option because of the MS dependency.
21:37:13 <YayMe> I know
21:38:19 <YayMe> for cross platform stuff, but when you're thinking server stuff which is what I always want to work with, being cross-platform because irrelevant because you can control your environment
21:38:24 <ddarius> Even with MS, the JVM is just way more broadly deployed.
21:38:59 <YayMe> s/because/becomes/g
21:39:20 <mapreduce> becomes you can contro.. :)
21:39:30 <YayMe> yeah yeah :P
21:39:51 <ddarius> s/.*//
21:39:54 <gentleben> no one really cares about cross platform anymore
21:40:25 <ddarius> gentleben: Until you want to target phones or appliances or ...
21:40:26 <YayMe> gentleben: bull. Mobile has made it extremely important
21:40:36 <mapreduce> Partly because it's now a given.
21:40:41 <Clint> except java is terrible at it
21:40:44 <gentleben> ddarius: on phones there is no sudh thing
21:41:01 <n00b6502> phones split between different languages..
21:41:03 <YayMe> the point stands though.. I guess perhaps there's a lot more client side software work than I'm used to working with, having been all server side
21:41:08 <n00b6502> java vs objective c
21:41:11 <gentleben> just find some tiread and frustrated android developers
21:41:28 <ddarius> gentleben: Now look at Symbian.
21:41:43 <gentleben> uhhhh….seriously
21:41:45 <mapreduce> Remember that Android doesn't run the JVM.  It's the same language but a completely different runtime.
21:41:49 <n00b6502> talking to iOS and android developpers they also insist there is no such thing as crossplatform, since a program must be adapted to platform specific look and feel
21:41:54 <gentleben> there are like 5 symbian phones
21:42:03 <ddarius> gentleben: Which is my point.
21:42:13 <gentleben> which is
21:42:18 <mapreduce> n00b6502: Isn't that at least in part to keep themselves employed though? :)
21:42:20 <ddarius> There are a lot more than 5 Dalvik VM or JVM based phones.
21:42:40 <gentleben> yeah, and that keeps them busy enough
21:42:42 <n00b6502> i would rather not have to re-write a program between ARM and ARM
21:43:49 <gentleben> there is no such thing really as cross platform, because you want to take advantage of your platform
21:43:50 <n00b6502> mac people are like tjhat aswell.
21:44:09 <n00b6502> "no such thing as cross platform UI, since a mac user wants his UI to look like a mac"
21:44:09 <ddarius> gentleben: Writing applications that are cross-phone on modern smartphones isn't completely trivial, but it's far easier than what you'd do without a VM.  And if you target J2ME and some crappy MIDP profile, you'd probably work on the vast majority of phones out there (which aren't the sexy ones everyone talks about now.)
21:44:22 <gentleben> i didn't even believe in code reuse before I found monad transformers
21:44:46 <gentleben> ddarius: I know. custom for each platform
21:45:24 <YayMe> n00b6502: it's one thing to be refiddling your UI layout, but layout is hardly programming, if you write it right I presume the libraries underneath between phones are going to be 98% identical for the actual logic/backend
21:45:48 <gentleben> ddarius: you know I find the J2ME thing to be interesting because of market size
21:45:54 <n00b6502> are apps often UI interfacing with internet application
21:46:08 <gentleben> I think there a lot of businesses to be built there. rest of world
21:46:32 <n00b6502> YayMe: the underlying code is the same if they both support the same language, however if one is Java and the other is ObjectiveC then no :)
21:47:09 <n00b6502> "does NDK support objectiveC" got a rather hostile response last time i asked on android-dev
21:47:10 <nand`> easy, write an ObjC -> JVM compiler
21:47:17 <gentleben> YayMe: good apps are basically built twice. Kind of like old games
21:47:28 <YayMe> n00b6502: simple fix, don't write apple software
21:47:34 <YayMe> problem solved
21:48:10 <n00b6502> only problem being there's more money in iOS than in android apps as far as i know
21:48:28 <gentleben> n00b6502: in fact much more
21:58:28 <n00b6502> does anyone know if the haskell runtime has optimizations to recycle memory e.g. can it recover the behaviour of overwriting a datastructure without GC operations if its clear a function is outputting something the same size as its input and no references are kept to the original
21:58:45 <shachaf> In general no.
21:58:51 <n00b6502> (optimizatoins to figure out simple over-write as opposed to relying on GC)
21:59:29 * hackagebot cassy 0.4 - A high level driver for the Cassandra datastore  http://hackage.haskell.org/package/cassy-0.4 (OzgunAtaman)
22:09:29 * hackagebot cassy 0.4.0.1 - A high level driver for the Cassandra datastore  http://hackage.haskell.org/package/cassy-0.4.0.1 (OzgunAtaman)
22:17:11 <shachaf> bos: The Data.Text test suite is kind of worrying.
22:17:32 <shachaf> bos: I replaced some functions with f = undefined and the tests that use them are still passing.
22:17:55 <shachaf> That seems to be because (=^=) considers a test passed if both sides crash in the same way.
22:24:53 <bos> shachaf: yes, it does
22:28:41 <shachaf> bos: No intent to change that?
22:29:45 <Guest69785> Hi All.... I want to learn how to program in haskell, can any one teach me from ground up level
22:30:44 <MostAwesomeDude> Guest69785: Have you seen LYAH?
22:30:47 <MostAwesomeDude> @where lyah
22:30:47 <lambdabot> http://www.learnyouahaskell.com/
22:31:03 <bos> shachaf: i'd need a bit more than "is kind of worrying" in IRC to make it past my caring threshold
22:31:08 <Guest69785> Hi lambdahot... let me check the website... pls hold
22:31:58 <shachaf> bos: OK. It's not *such* a big deal, I guess.
22:32:00 <osfameron> lambdabot: your call is important to us, please continue to hold
22:33:11 <bos> shachaf: if you find a *real* problem, let me know :-)
22:33:14 <Guest69785> im looking for a personal tutor who can teach me haskell programming language.... ive tried reading a lot of books...but im not able to understand anything.... pls help
22:33:39 <casion> Guest69785: do you know any other programming languages?
22:33:39 <shachaf> bos: The real problems are with my code. I was just worried they wouldn't be caught. :-)
22:33:54 <Guest69785> I know HTML & CSS
22:34:13 <Veinor> bos: arguably, there should be some tests that 'f = undefined' will cause to break
22:34:23 <casion> Guest69785: know, or have edited other people's code until it almost did what you wanted?
22:34:24 <shachaf> But I'll work on making all my functions total, I guess.
22:35:17 <Guest69785> Have edited other peoples code until it almost did what I wanted it to...:)
22:36:06 <ddarius> Guest69785: Are you offering to pay someone to tutor you?
22:36:32 <bos> Veinor: i agree, but there are only so many hours in the day
22:36:38 <Guest69785> yes i dont mind paying someone for tutoring me...
22:37:07 <Veinor> bos: clearly you need quickspec!
22:38:00 <u_> i'm writing a program to process a bunch of "setoption timelimit 30 \n setoption name joe" kind of stuff
22:38:51 <u_> and i had something like "mainloop s = huge case statement" where the branches of the case statement end in things like mainloop ( {name = "joe"} s)
22:39:02 <u_> and it's really ugly
22:39:36 <u_> i have a feeling there's a better way to do it i just cant put my finger on it
22:40:12 <shachaf> A Map?
22:40:47 <u_> map string (either int string)?
22:40:58 <ddarius> You can (also) separate the parsing into an operation and combining the results.
22:41:10 <u_> they're all ints or strings. and the strings are useless stuff like "opponent_name" that i can just ignore for now
22:41:34 <u_> ddarius: what's that?
22:42:05 <shachaf> Oh, I assumed you were already doing that, and {name="joe"} is pattern-matching on a record.
22:44:36 <u_> oh sorry its reversed
22:46:08 <u_> ddarius: i don't know what you mean. is it "an operation" and "combining the results" two things or did you mean "combine the results"
22:47:51 <u_> meant s {name= "joe"}. i guess i'll try map string int.
22:50:11 <rosie> Any idea why this super simple module takes input, but doesn't print anything? http://hpaste.org/73455
22:50:45 <shachaf> rosie: Sounds like you're running it wrong.
22:50:49 <shachaf> It prints nothing at all?
22:50:52 <rosie> I'm using cabal-dev ghci
22:51:06 <rosie> I load the file and run main
22:51:19 <shachaf> What if you just runghc the file?
22:51:36 <shachaf> (Also, you probably want putStrLn, not putStr. getLine strips the \n)
22:51:49 <lpvb> Hey, how would I do this: I have a Map of String of a keyword and String of a quote. I need a function that takes a string message, sees if any of the keywords are in the message, and if so, return the corresponding quote?
22:52:30 <rosie> shachaf: yep it works there. How can I make it work in cabal-dev ghci?
22:52:39 <shachaf> rosie: I've never used cabal-dev.
22:53:02 <shachaf> lpvb: Which part are you having a problem with?
22:53:38 <Veinor> rosie: does it prompt for input?
22:53:48 <rosie> Yes
22:54:08 <lpvb> looping through the keys one by one and checking if the key isInfixOf message
22:54:09 <shachaf> rosie: Maybe it's just buffering, and using putStrLn instead of putStr solves it?
22:54:24 <shachaf> rosie: In general I never use ghci to run whole programs.
22:54:43 <shachaf> lpvb: Which part is the problem?
22:55:09 <lpvb> could I use a fold to do that?
22:55:36 <rosie> shachaf: bingo! it works now
22:55:47 <lpvb> Prelude.foldl (`isInfixOf` msg) False $ Map.keys mymap
22:55:51 <lpvb> idk
22:56:40 <rosie> shachaf: It's working, but I don't think the buffering was the issue… must have been something random because now it also works on a different file...
22:56:43 <shachaf> filter?
22:57:07 <shachaf> rosie: Ah. Well then.
22:57:09 <lpvb> but filter would be slow wouldn't it?
22:57:21 <frio> filter's just a wrapper around foldl iirc
22:57:24 <shachaf> Everything will be slow.
22:57:27 <lpvb> since it has to check everything regardless if it already matched a keyword
22:57:31 <shachaf> filter is certainly not a wrapper around foldl.
22:57:54 <shachaf> All of these statements are false. :-(
22:58:32 <frio> so it isn't
22:58:57 <frio> (i think one of the earlier tutorials i followed showed you how to implement filter over foldl)
22:59:00 <frio> my bad :)
22:59:49 <lpvb> maybe I shouldn't use a Data.Map, when I have to iterate it anyway
23:00:03 <lpvb> yea okay I got it
23:02:12 <signalsea> Can anyone explain these constructors? I'm reading the paper "Data types a la carte" by Swierstra.  Expr f = In (f (Expr f)) ; data Val e = Val Int; type IntExpr = Expr Val
23:02:42 <shachaf> signalsea: Do you understand "fix"?
23:02:45 <shachaf> :: (a -> a) -> a
23:03:01 <signalsea> I don't understand how "In" is not infinitely recursive and why "Val 3" constitutes an Expr f in "In (Val 3)"
23:03:18 <shachaf> It is recursive.
23:03:19 <signalsea> i don't understand fix, is it requisite knowledge?
23:03:24 <shachaf> Nothing wrong with recursive types.
23:03:30 <shachaf> signalsea: Well, "Expr" is type-level fix. :-)
23:03:39 <shachaf> So it would help.
23:03:55 <shachaf> But if you understand recursive types you can probably just inline it to see if it makes more sense.
23:04:14 <shachaf> Expr Val = In (Val (Expr Val))
23:04:21 <shachaf> Val (Expr Val) = Val Int
23:04:26 <shachaf> There, no more recursion.
23:04:32 <signalsea> so how does "3" constitute an Expr Val
23:04:40 <signalsea> ok i will stare at that for a bit
23:04:41 <shachaf> It doesn't, unless you have a Num instance.
23:04:51 <shachaf> But In (Val 3) :: Expr Val, I guess.
23:05:08 <signalsea> why does "Val 3" fill in the place of "Expr f" in the type constructor
23:05:09 <signalsea> err
23:05:14 <signalsea> just "3"
23:05:28 <shachaf> ?
23:05:30 <signalsea> not the just constructor, haha
23:05:39 <shachaf> Where? What?
23:06:08 <signalsea> In (f (Expr f))...    "Val 3" :: (f (Expr f)
23:06:11 <signalsea> )
23:06:32 <signalsea> i don't understand how that makes sense
23:06:47 <signalsea> on the left it seems saturated, on the right it doesn't
23:06:50 <shachaf> data Val e = Val Int
23:06:56 <shachaf> So Val :: Int -> Expr e
23:06:57 <shachaf> For any e
23:07:19 <signalsea> i don't get that at all.. i never declared that
23:07:26 <shachaf> data Val e = Val Int
23:07:30 <shachaf> It's declared right there.
23:07:36 <shachaf> data Foo e = MkFoo Int
23:07:40 <shachaf> MkFoo :: Int -> Foo e
23:08:00 <signalsea> yes, but how does Val Int :: Expr e
23:08:12 <shachaf> It doesn't.
23:08:22 <signalsea> but Val :: Int -> Expr e?
23:08:33 <shachaf> Did I say that?
23:08:35 <shachaf> I guess I was wrong.
23:08:41 <shachaf> Val :: Int -> Val e is what I meant.
23:08:51 <signalsea> that makes sense
23:08:58 * shachaf vanishes in a puff of orange smoke for a while.
23:09:05 <u_> i guess i want something like an IO version of Parsec
23:09:14 <signalsea> i really just don't get the "In" constructor
23:10:23 <u_> i could just collect all the setoptions and run a parsing function on them.. i dunno
23:10:30 <u_> i don't either signal :(
23:12:20 <lpvb> schachaf: Here's what I got that works :)
23:12:22 <lpvb> quoteLookup msg = foldr (\(k,v) acc -> if isInfixOf k msg then Just v else acc) Nothing
23:13:08 <BMeph> Expr f = In (f (Expr f)) means, In :: f (Expr f) -> Expr f
23:14:38 <signalsea> I think i got it from shachaf's example  your example... Val (Expr Val) = Val Int  because "Expr Val" takes the place of a phantom type.. but I still find "Expr Val" confusing... i guess I'm not used to multi-kinded types taking multi-kinded types like Expr does
23:14:56 <signalsea> s/your example//
23:15:27 <signalsea> Expr :: (* -> *) -> *
23:17:40 <BMeph> lpvb: Why not 'map lookup' over the possible keys, and 'fmap lookup' over the results?
23:18:50 <lpvb> that's two map lookups?
23:21:13 <signalsea> Does "Expr f" work because the data constructors Expr and Val are lazy, much like the fix function?
23:21:25 <BMeph> lpvb: One 'map lookup' and one 'map (fmap lookup)'.
23:21:29 <signalsea> err type constructors, rather
23:22:39 <lpvb> can't just do a map lookup on the message
23:22:50 <lpvb> because the key isn't the same as the message
23:22:53 <BMeph> signalsea: In, not Expr, but yes.
23:23:20 <lpvb> the message can contain the keyword and some other words BMeph
23:25:05 <BMeph> lpvb: Any 'word' not in your keyword map will give 'Nothing' as a result in 'lookup'.
23:26:59 <lpvb> BMeph, so your strategy is to check each keyword in the message and see if it's in the map?
23:27:04 <lpvb> that would work I guess
23:27:14 <lpvb> each word*
23:30:24 * shachaf back.
23:30:41 <shachaf> signalsea: You should read about value-level fix and type-level Fix to understand Expr.
23:30:49 <shachaf> @google type-level fix
23:30:50 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
23:31:16 <signalsea> shachaf: I'm reading this which seems to be doing an ok job http://blog.plover.com/prog/springschool95-2.html i found this
23:31:42 <shachaf> signalsea: OK.
23:31:52 <shachaf> It's not complicated once you understand it. :-)
23:32:06 <signalsea> i did search for something of that vein to find it because you mentioned it, so thank you
23:32:18 <shachaf> Just abstracting the recursion and passing a parameter.
23:32:24 <shachaf> But until you understand it it's complicated. :-)
23:33:33 <signalsea> yeah, just confusing how how Val Int is an Expr Val but is somehow saturated on the type level
23:33:42 <BMeph> lpvb: Follow the types - if (`lookup` messageMap) is k -> Maybe String, then ">>= (`lookup` messageMap)" is Maybe k -> Maybe String.
23:34:00 <signalsea> kind level *
