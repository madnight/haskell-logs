00:06:01 <ddarius> happyN 0 f x = x; happyN !n f x = happyN (n-1) f (f x);  sadN 0 f x = x; sadN !n f x = sadN (n-1) (f $) (f x)
00:11:06 <ddarius> That example is interesting in that happyN is actually not happy about some things and sadN is unhappy in a way I didn't quite expect.
00:11:14 <ddarius> happyN can easily be fixed to be happier.
00:12:27 <ddarius> Add !s to each of the x's to make a happier happyN but little/no difference in sadN.
00:32:29 <b__> with quickcheck, is there a way to limit random ints to a certain range?
00:32:49 <b__> I've seen the docs, and generators like choose, but I'm not sure how to put things together
00:33:08 <b__> are there qc2 tuts that go into a bit of depth on things like this?
00:59:05 <ddarius> b__: You could just transform the integer to the range you want.
00:59:18 <ddarius> Alternatively, you could reject samples outside the range you want.
01:00:19 <b__> I could use n `elem` range ==>
01:00:34 <b__> but then it ends up rejecting a large percentage of tests
01:00:57 <b__> the range is really narrow [0..63]
01:01:20 <b__> so perhaps I might as well just test those ints
01:01:42 <b__> but I would like to do it with quickcheck instead of 'by hand'
01:02:43 <b__> I am thinking if I should not embed the range restriction in my functions instead
01:39:03 <Saizan> b__: use forAll with a custom Gen
01:40:25 <b__> I don't know what forAll is but I will go ahead and learn about it, cheers
02:18:47 <gertc> data Shape = Circle Point Float | Rectangle Point Point
02:19:39 <gertc> can you define a function like surface :: Shape -> Float
02:19:42 <t7> class Shape a where getArea :: a -> Area
02:20:25 <gertc> and surface :: Rectangle Point Point -> Float
02:21:07 <t7> if you could have sets of things of the same class you wouldnt need ADTs... maybe?
02:21:40 <t7> literal class things
02:21:41 <frerich> gertC: You just have 'surface :: Shape -> Float' and then you could use e.g. "pattern matching" to have the function do the right thing depending on how the 'Shap' was constructed. So 'shape (Circle pos r) = ...' and 'shape (Rectangle p1 p2) = ...'
02:24:52 <gertc> ok but surface :: Rectangle Point Point -> Float would do what i think it would do right? I amsking because I am confused by the follwing example
02:25:20 <gertc> data CounterState = CounterState { count :: Integer }
02:25:44 <gertc> incCountBy :: Integer -> Update CounterState Integer
02:25:45 <t7> are existential types bad?
02:25:48 <frerich> gertC: No, it wouldn't. What 'surface :: ...' does is to define the signature of "surface". This means that you use "type constructors" here (in "data X = Y", 'X' is the type constructor).
02:26:26 <frerich> gertC: 'Rectangle Point Point' is not a type constructor, but 'Shape' is.
02:27:40 <frerich> gertC: It's anything but uncommon in haskell to have data constructors which have the same name as the type constructor. So 'data Person = Person { name :: String }' defines the type constructor 'Person' (the thing left of the '=') but also the data constructor 'Person'. The former is what you would use in signatures, the latter is what you would use when creating values (or when pattern matching).
02:29:00 <timthelion> So if I have type T = String; type G = String ; foo :: (T,G)... And I have bar :: G -> T -> String ...  I'd like to be able to treat both T's and G's as Strings.  But I'd like to have functions that EXPLICITLY SPECIFY that they only take a G or a T to be type constrained in that fassion.
02:29:12 <timthelion> Is there a good way to do that?
02:31:12 <ksf> http://hpaste.org/73561
02:31:13 <ksf> @name
02:31:14 <lambdabot> Local time for ksf is Thu Aug 23 11:30:53
02:31:24 <ksf> @newname
02:31:24 <lambdabot> Unknown command, try @list
02:31:27 <gertc> ok so incCountBy :: Integer -> Update CounterState Integer should be incCountBy :: Integer -> Update CounterState in the example for sure? Or can it be part of Update?
02:31:28 <ksf> @list
02:31:28 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:31:45 <ksf> @freshname
02:31:45 <lambdabot> Hagz
02:31:47 <ksf> @freshname
02:31:47 <lambdabot> Haha
02:31:50 <ksf> @freshname
02:31:51 <lambdabot> Hahb
02:32:09 <ksf> someone replace that one with my version?
02:32:10 * timthelion thinks that what he *really* wants, is for String to be a typeclass :/
02:32:24 <ksf> timthelion, -XOverloadedStrings
02:32:53 <ksf> @yhjulwwiefzojcbxybbruweejw
02:32:54 <lambdabot> Exception: <<loop>>
02:32:56 <timthelion> ksf: I'll look at it
02:33:28 <timthelion> > undefined
02:33:30 <lambdabot>   *Exception: Prelude.undefined
02:33:57 <timthelion> > map undefined [1..]
02:33:58 <lambdabot>   [*Exception: Prelude.undefined
02:34:06 <t7> :t undefined :: StateT (Either Void Void) (Either (Either Void Void) ) Void
02:34:08 <lambdabot> Not in scope: type constructor or class `Void'
02:34:08 <lambdabot> Not in scope: type constructor or class `Void'
02:34:08 <lambdabot> Not in scope: type constructor or class `Void'
02:34:55 <t7> whats a simple expression with a huge type?
02:35:41 <ksf> any HList expression.
02:35:49 <ksf> other libraries qualify, too.
02:38:42 <gertc> it can be incCountBy :: Integer -> Update CounterState Integer in the pasted example right?
02:38:51 <gertc> can't
02:41:32 <gertc> http://hpaste.org/73562 (ps i dont see my paste anymore automaticly is it disabled?)
02:41:57 <gertc> or just hidden from my irc
02:45:22 <fmap> gertc: what's Update?
02:47:13 <gertc> no idea :) as long as it takes 2 type as parameters i am happy but i just want to make sure i can never be part of CounterState right?
02:47:34 <fmap> gertc: if it's some wrapper over State I don't see why `incCountBy' can't be `:: Integer -> Update CounterState Integer'
02:48:49 <fmap> I don't think I understand your question
02:49:15 <gertc> ok let say we would leave Update out of the sample code
02:49:46 <gertc> it must be :: Integer -> CounterState
02:50:01 <gertc> and not :: Integer -> CounterState Integer
02:50:31 <fmap> why?
02:51:02 <gertc> because of data CounterState = CounterState { count :: Integer }
02:51:23 <fmap> okay, that's right
02:51:33 <gertc> and i should use de type constructer in afucntion declaration ?
02:52:19 <gertc> ok thx :) i am not going crazy anymore :)
02:54:15 <Morgawr> hey guys :) Just started learning me some haskell.. I have a question, I'm currently reading real world haskell and I noticed that fst and snd only work on 2-tuples (pairs). How do I take, for example, the third element from a 3-tuple? and 3rd element of a 4-tuple? etc etc
02:54:33 <companion_cube> with pattern matching
02:54:38 <nand`> there's no canonical name for those functions but you can make your own eg. \(_,_,x) -> x
02:54:44 <Morgawr> ah ok
02:54:45 <companion_cube> case mytuple of  (_,_,x,_) ->
02:54:55 * nand` .oO( Or you could use edwardk's lenses )
02:55:00 <shachaf> Morgawr: Pattern matching is the standard way to take things apart. fst and snd are just for convenience -- in most cases you don't even want to use them.
02:55:02 <Morgawr> perfect, thanks for the answer :) will keep on reading then
02:55:04 <shachaf> nand`: Yes, but no.
02:55:46 <nand`> (there's also a package ‘tuple’ that provides overloaded ‘select Nth item’ for tuples up to size 16)
02:55:54 <nand`> but I've never felt the need to use those
02:55:58 <nand`> and neither should you
02:56:09 <timthelion> nand`: isn't the lambda typesafyer?
02:56:16 <fmap> Yeah, lenses are best tool for extracting elements from tuples for whose who've started learning Haskell
02:56:21 <nand`> they're both type-safe
02:56:32 <nand`> one is just more polymorphic
02:57:36 <timthelion> nand`: there is typesafe, as in when you do "a -> a" you get an a back.  And then there's insufficiently typestrict, where a function that says it takes an "a -> a" actually does the wrong thing for some a's.
02:58:12 <nand`> huh
02:58:32 <timthelion> nand`: for example, the tuple one will give you a runtime error if you hand it the wrong index, no?
02:58:41 <nand`> no?
02:59:26 <nand`> besides, that isn't type safe; something is type unsafe when it can be used to coerce types
02:59:31 <nand`> type unsafe*
03:00:16 <nand`> or rather coerce the types of values (it's perfectly fine to coerce phantom types)
03:02:23 <gertc> did it show my anotation paste in here?
03:02:33 <frerich> timthelion: You wrote "there's insufficiently typestrict, where a function that says it takes an "a -> a" actually does the wrong thing for some a's" - but how can a function do the 'wrong thing' for some 'a' given that it doesn't know anything about 'a' at all?
03:03:04 <frerich> In fact, aren't the only possibilities to either yield the given value, or 'undefined'?
03:03:28 <gertc> http://hpaste.org/73562
03:04:55 <timthelion> frerich: Well "a" is a bad example.  But take "f :: String -> String \n f s = head s"  f is insufficiently type strict, as it does not explicitly take "NonEmptyString"
03:05:17 <fmap> gertc: in `Integer -> Update CounterState Integer' `Integer' is unrelated to `CounterState', so yes
03:05:32 <timthelion> frerich: of course in haskell, we don't have a flexible enough type system *yet* to actually have a type "NonEmptyString" so we let these failings slide.
03:06:13 <frerich> fmap: Wouldn't it be possible that 'Update' takes a type constructor of kind '* -> *' as its first argument?
03:07:57 <fmap> frerich: surely that's possible
03:08:14 <fmap> say, `Update (CounterState Integer)'
03:10:32 <frerich> fmap: Ah, so you mean "Yes, it's not possible to tell whether it's one or the other", I misread (I agree)
03:10:51 * frerich always gets confused when people confirm negations
03:11:25 <gertc> would it not benificial to introduce some extra symbols that could mark the difference like a &Integer to indicate its part of teh type construker or not?
03:14:04 <timthelion> gertc: as opposed to?
03:14:31 <gertc> not knowing :)
03:15:53 <gertc> for example :: Integer -> Update CounterState &Integer
03:16:21 <gertc> :: Integer -> Update (CounterState Integer)
03:17:22 <gertc> or :: Integer -> Update &CounterState Integer
03:17:55 <timthelion> gertc: that's what parentheses are for.  And if you really want, you can even use $ with a special compiler flag.
03:19:07 <gertc> ok but the thing is if you dont use them you have no idea only the compilers knows
03:19:34 <timthelion> then use them :)
03:20:22 <timthelion> When timthelion programs in haskell, it looks like lisp :)
03:20:38 <gertc> :)
03:22:21 * hackagebot fclabels 1.1.4.1 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.4.1 (SebastiaanVisser)
03:22:59 <t7> timthelion: type level $ ?
03:23:53 <shachaf> GHC 7.6 will support type-level $!
03:24:13 <shachaf> Or whichever version is getting the new TypeOperators.
03:24:21 <t7> i still want {-# LANGUAGE DependentTypes #-}
03:24:38 <companion_cube> {-# LANGUAGE CompileWithSPJClone #-}
03:24:45 <srhb> shachaf: What will that even mean?
03:24:49 <srhb> Type level $! ?
03:24:56 <srhb> Forcing a tree to be strict, say?
03:25:10 <t7> no like Maybe $ Maybe Int
03:25:27 <srhb> Oh, the bang wasn't included :P
03:25:49 <shachaf> srhb: No, I'm just excited!
03:25:57 <srhb> ^^
03:26:31 <companion_cube> looks like english's convention for '!' is confusing :p
03:26:58 <srhb> Yes, we need to disambiguate it.
03:27:15 <shachaf> ¡GHC 7.6 will suport type-level $!
03:27:48 <gertc> can you als force programmers to use $ them so it will not be a option :)
03:27:57 <shachaf> No, $ is the devil.
03:28:07 <companion_cube> type level $¡
03:28:40 <gertc> yes tpe level $ i mean
03:34:17 <t7> when we get that im gonna moan about Kind level operators
03:35:16 <shachaf> Do we get those with DataKinds?
03:35:18 <shachaf> We ought to!
03:36:39 <srhb> I really wish the package name was clickable in the left hand upper corner of Hackage. >_<
03:37:28 <shachaf> srhb: Click "Contents" in the top-right corner.
03:37:38 <asda8> hi, how can I convert a latin1 bytestring to utf8?
03:37:52 <srhb> Yeah, I know. I just think the other thing would be more intuitive, and the fact that the package name and version is there makes my brain want to click that every time :P
03:37:52 <asda8> I'm on windows btw
03:38:17 <shachaf> srhb: Send a patch!
03:38:34 <srhb> shachaf: Hum.. I should probably get around to contributing with something soon, yeah.
03:40:43 <asda8> I can't get the encode package to build :(
03:43:56 <Lemmih> asda8: Look at Data.Text.Encoding
03:44:42 <asda8> Lemmih: does it have latin1?
03:45:12 <shachaf> "latin1" :-(
03:46:06 <asda8> maybe I can build text-icu somehow
03:55:13 <gienah> asda8: encoding-0.6.5 should build, encoding-0.6.6 is evil (contains binaries, uploaded by someone other than the maintainer)
03:55:49 <asda8> gienah: what? how can this happen?
03:56:13 <gienah> asda8: anyone with hackage account, or who can hack hackage, uploads a package
03:56:55 <gienah> asda8: and I guess the maintainer is busy, he doesn't answer my emails when I try to submit patches
03:57:10 <asda8> gienah: scary... anyway, 0.6.5 complains about illegal bang patterns
03:58:24 <gienah> asda8: one of the patches I tried to upstream: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/encoding/files/encoding-0.6.5-ghc-7.2.patch
03:58:46 <gienah> asda8: there are a few more: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/encoding/files
03:59:10 <asda8> gienah: thanks, will try it!
03:59:43 <gienah> asda8: no worries, encoding 0.6.6 in gentoo is basically the same as encoding 0.6.5
04:02:34 <asda8> gienah: many thanks, but it still doesn't build (I guess because I'm on 7.4.1)
04:03:39 <gienah> asda8: it should build with the patches, I'll try it
04:04:48 <asda8> gienah: sorry, I didn't apply all of your patches. my bad... I'll try again
04:08:26 <gienah> asda8: ok, encoding-0.6.5 built fine for me with ghc 7.4.2 with haxml-1.23.3, with the encoding-0.6.5-* patches in: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/encoding/files
04:09:38 <asda8> gienah: now I applied all your patches and the errors are gone
04:09:55 <asda8> gienah: I'm still missing some kind of system_encoding.h
04:10:54 <asda8> gienah: any ideas where I can get that for win32?
04:12:00 <asda8> hm, it's included with the source of encoding-0.6.5
04:12:04 <srhb> asda8: Don't know if it helps, but here: http://osdir.com/ml/haskell-cafe@haskell.org/2010-03/msg01464.html
04:12:07 <asda8> I'm curious why it can't find it
04:12:17 <srhb> Look at the reply to that message
04:12:20 <gienah> asda8: yeah, that's what I was just going to say
04:13:37 <shachaf> Is there a standard library function :: [Word8] -> String?
04:13:52 <shachaf> Er, that does UTF-8 decoding, I mean.
04:14:00 <srhb> Oh :P
04:14:00 * ksf needs an always-nubbed list
04:14:02 <shachaf> Or String -> [Word8] or ByteString -> String, or String -> ByteString.
04:14:12 <shachaf> ksf: Data.Set? Or do you care about order?
04:14:20 <gienah> asda8: you could try running: cabal configure --verbose=3 (or something like that to turn on the verbose error messages) then look at them closely
04:14:27 <ksf> actually... I don't.
04:14:34 <ksf> which makes the question quite stupid.
04:15:08 <ksf> just needs the right Eq instance.
04:15:29 <asda8> gienah: I'm trying with the command you pasted (--extra-include-dirs, etc.), but now the setup can't see my packages (dependencies) which I installed as a user
04:15:52 <asda8> can I give these flags to cabal install instead of runhaskell Setup.hs ?
04:17:27 <gienah> asda8: I'm not really sure, because I never actually use cabal install
04:18:26 <gienah> asda8: anyway the --verbose=3 option during the configure sometimes prints out useful stuff about what it is doing, which might give some hints about the "missing" header file
04:18:42 <asda8> gienah: ok, I'll try. thanks!
04:18:58 <srhb> asda8: Yes, you can give extra-include-dirs to cabal install
04:19:04 <srhb> asda8: see cabal install --help
04:19:41 <srhb> asda8: You might also be interested in --configure-option, if need be
04:21:50 <asda8> found the issue, it tries to join my path to the extra libs with the wrong path separator
04:22:08 <srhb> Oh, is that cabal doing that? Should warrant a bug report.
04:22:09 <asda8> ...\encoding-0.6.5/system_encoding.h
04:23:23 <ksf> actually, sets aren't optimal. I want a record of maybes.
04:23:24 <asda8> I give up, I think I'll use PHP or something to convert from latin1 to uft8
04:24:12 <ksf> asda8, iconv
04:24:27 <asda8> ksf: tried it, couldn't get it to build on win32
04:24:57 <ksf> there should be a cygwin package for it
04:25:18 <asda8> ksf: I can't deploy that on a server
05:43:48 <azi`_> could someone explain to me what does this code? http://hpaste.org/73564
05:46:24 <Botje> azi`_: it looks like a solution to the "how many ways can you make X using A,B,C" problem
05:46:57 <fmap> @oeis a000586
05:46:57 <lambdabot>  Number of partitions of n into distinct primes.
05:46:57 <lambdabot>  [1,0,1,1,0,2,0,2,1,1,2,1,2,2,2,2,3,2,4,3,4,4,4,5,5,5,6,5,6,7,6,9,7,9,9,9,11,...
05:47:16 <Botje> oh, haha :)
05:47:36 <Botje> fmap++ # for recognizing it's an OEIS number
05:50:25 <Rc43> Hi, guys.
05:50:32 <fmap> Botje: :)
05:50:53 <fmap> actually I think question was 'How does the algorithm work?'
06:05:27 <Rc43> Are there any "humanized" C-code generators from haskell or llvm-ir?
06:12:50 * hackagebot getopt-simple 0.1.0.1 - A "System.Console.GetOpt" wrapper to make simple use case easy.  http://hackage.haskell.org/package/getopt-simple-0.1.0.1 (AlexanderBondarenko)
06:23:43 <int-e> dcoutts_: I'm closer to nailing down that hpc issue. The Cabal teststuite support sets the HPCTIXFILE environment, then runs the unit-tests executable. A number of those unit tests compile a Setup.hs executable with hpc enabled -- each of these has its own Main module. When those are run, the HPCTIXFILE variable is inherited, pointing to the same .tix file every time. Hpc will then compare the module identities with those in...
06:23:50 <int-e> ...the .tix file. So unless hpc is convinced that these Main modules are all identical, it will complain and the test(s) will fail. And apparently this check involves the file modification time of the Setup.hs source file.
06:24:40 <dcoutts_> int-e: ok, so I guess we want to avoid compiling the Setup.hs with hpc in the first place, just the test progs themselves
06:27:16 <dcoutts_> int-e: right?
06:27:46 <int-e> dcoutts_: that, or make sure the same Setup executable is used each time. (The ones I'm worried about are all identical anyway.)
06:27:51 * hackagebot database-migrate 0.0.2 - Database versioning and migration  http://hackage.haskell.org/package/database-migrate-0.0.2 (MarkHibberd)
06:32:51 * hackagebot happstack-foundation 0.2.0 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.2.0 (JeremyShaw)
06:56:37 <edwardk> @tell roconnor ported the uniplate combinators to lens, thinking about adding them to the repo
06:56:37 <lambdabot> Consider it noted.
07:07:44 <azi`_> Botje: how do you mean?
07:08:21 <ocharles> edwardk: what's the status on lens and lens-familys btw? are you going to collaborate with roconnor on merging them?
07:09:02 <edwardk> lens subsumes lens-family. the lenses in lens-family remain compatible with the lenses in lens, but we have different design goals. he wants to remain haskell 98. i want to have users ;)
07:09:23 <edwardk> most of the tricks i use aren't available to lens-family
07:09:34 <edwardk> under the design constraints he seeks to impose
07:10:26 <edwardk> if you are a library supplying lenses, feel free to use either or neither (any van laarhoven lenses can be used so you don't even need the dependency on any lens lib)
07:10:50 <ocharles> ah, ok, that makes sense
07:10:51 <ocharles> thanks!
07:11:31 <edwardk> lens-family-core i think tries too hard to be haskell 98 and therefore exposes a number of type aliases that are frankly misleading
07:12:00 <edwardk> i've thought about exporting a lens-core that would be 98, but it'd be so crippled that i don't want to make the rest of the users of the package deal with the uglier names
07:12:35 <Yiq> So I got the AMQP example running. How does it now where I have rabbitmq installed or does it come with its own rabbitmq? Also could it be run on heroku (with their addons )?
07:12:59 <edwardk> at this point roconnor indicated he was planning on keeping lens-family alive as a 'slower paced exploration of lenses and traversals' or some such
07:13:29 <ocharles> Yiq: 'example'?
07:13:43 <ocharles> which example do you mean?
07:17:51 * hackagebot database-migrate 0.0.3 - Database versioning and migration  http://hackage.haskell.org/package/database-migrate-0.0.3 (MarkHibberd)
07:23:26 <Yiq> $ has lowest precedence of all functions?
07:23:52 <timthelion> Is lazyness guaranteed?   I mean, if I have let f = [] ; myhead = head f ; empty = null f in if emtpy then "foo" else myhead is it guaranteed that the head error won't be encountered?
07:25:46 <amalloy> timthelion: yeah. values that aren't needed never get evaluated
07:27:15 <timthelion> amalloy: that's good, because large parts of my data structure may be undefined at some points.
07:27:20 <Yiq> @src getArgs
07:27:21 <lambdabot> Source not found. Sorry.
07:27:33 <Yiq> @hoogle getArgs
07:27:33 <lambdabot> System.Environment getArgs :: IO [String]
07:27:34 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
07:27:41 <timthelion> lambdabot: don't appologize, just work
07:28:20 <matthiasgorgens1> @djinn a -> (a -> f b) -> f a
07:28:20 <lambdabot> -- f cannot be realized.
07:28:25 <fmap> Yiq: it has the lowest precedence possible, that's unrelated to other functions
07:28:56 <fmap> see http://www.haskell.org/onlinereport/decls.html#fixity
07:31:08 <amalloy> matthiasgorgens1: i'm just dabbling in haskell, but it seems to me like a function with that signature would be impossible to write. where can the f a come from, if you don't know what f is and can only construct instances of f b?
07:33:11 <Yiq> @hoogle getArgs
07:33:11 <lambdabot> System.Environment getArgs :: IO [String]
07:33:11 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
07:33:19 <Yiq> dead?
07:33:30 <fmap> @type \x f -> x <$ (f x)
07:33:31 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> (a -> f b) -> f a
07:34:00 <Yiq> how do you do when you have getArgs in your code and youre in ghci?
07:34:15 <geekosaur> :main your parameters here
07:35:25 <matthiasgorgens1> amalloy: oh, I wanted f to be a Functor.
07:35:29 <amalloy> fmap: what i understand from that is: it's possible when f is a functor because you have more information, but it's not possible in general for any f
07:35:39 <amalloy> okay, whew
07:35:44 <fmap> amalloy: sure
07:36:10 <matthiasgorgens1> amalloy: but I wrote it as \l -> l <$ myFunction l
07:36:12 <matthiasgorgens1> now.
07:37:34 <amalloy> @type <$
07:37:35 <lambdabot> parse error on input `<$'
07:37:39 <amalloy> @type (<$)
07:37:40 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
07:37:46 <matthiasgorgens1> it's from Control.Applicative
07:38:44 <amalloy> matthiasgorgens1: thanks. that's treading into territory i'm not familiar with yet; i'm just hoping to keep my head above water listening to the chatter in here, and practice thinking about what type signatures mean
07:39:08 <matthiasgorgens1> amalloy: if you know monads and functors, you know Applicatives.
07:39:39 <matthiasgorgens1> you should be able to write (<$) yourself, just looking at its type.
07:39:55 <matthiasgorgens1> amalloy: good luck! :o)
07:40:00 <amalloy> hah, thanks
07:41:52 <matthiasgorgens1> amalloy: that's what I was working on http://hpaste.org/73570
07:42:12 <matthiasgorgens1> (I hope I got all the relevant imports.  it's an excerpt from a longer file.)
07:42:22 <matthiasgorgens1> I didn't like the recursion in the original.
07:42:43 <matthiasgorgens1> ad-hoc recursion is seldom needed.
07:43:21 * timthelion loves recursion.  Especially when mixed with time traveling lazyness.
07:44:18 <matthiasgorgens1> oh, there's recursion.  but hidden away in combinators.
07:44:26 <matthiasgorgens1> i.e. the unfoldM does all the heavy lifting.
07:44:57 <fmap> matthiasgorgens1: why `runMaybeT' and not simply `const'?
07:45:27 <matthiasgorgens1> it would be: const . Just $ ()
07:45:28 <amalloy> yeah, understood. i spend most of my time in clojure, which has a similar approach to recursion. but we recently started doing some stuff that's very closely related to monads (but less formal), so i'm back to dabbling in haskell
07:45:37 <matthiasgorgens1> fmap: that was just because I was feeling fancy.
07:45:44 <matthiasgorgens1> return . return $ () would have also done the trick.
07:49:01 <fmap> or `return <$> return $ ()'
07:49:08 <Yiq> wouldnt it be better if last was last :: [a] -> Maybe a ?
07:49:32 <Yiq> > last []
07:49:33 <lambdabot>   *Exception: Prelude.last: empty list
07:51:00 <timthelion> Yiq: of course it would be better. But the guys who first wrote Prelude didn't think of that.
07:51:14 <geekosaur> youhave no idea what you just walked into... totality is a long time bikeshed around here :)
07:51:53 <timthelion> geekosaur: I swear, we should paint it hot pink. It'll encourage more girls to join our club.
07:56:43 <Yiq> Anyone used AMQP? Im trying to divide the example into 2 programs, Sender and Receiver but the Receiver doesnt work. Can anyone help if I paste`
07:58:10 <ocharles> I have used the amqp package on hackage with RabbitMQ
07:58:15 <ocharles> if you're going to paste, use hpaste
07:58:54 <amalloy> matthiasgorgens1: found a definition with the right type, but it feels weird since i don't know what <$ is supposed to do. x <$ y = fmap (\b ->x) y, right? seems to be saying like..."i want a functor of the same shape as y, but with all the values replaced by x"
08:00:10 <matthiasgorgens1> amalloy: exactly!
08:00:25 <amalloy> neat. thanks for telling me to go try it out
08:00:32 <matthiasgorgens1> amalloy: that's almost word for word what the documentation says http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Functor.html#v:-60--36-
08:03:39 <fmap> @type (last <$>) <$> ((<$) <*> listToMaybe)
08:03:40 <lambdabot> forall b. [b] -> Maybe b
08:04:47 <merijn> @quote springge
08:04:47 <lambdabot> No quotes match. :(
08:04:49 <merijn> aww
08:04:51 <atriq> (<*>) id unsafeCoerce ((<*>) (pure ((<*>) ((<*>) ((<*>) (pure if') (== 0)) (pure 1)))) ((<*>) (pure ((<*>) (*))) ((<*>) ((<*>) (pure (<*>)) ((<*>) (pure pure) ((<*>) unsafeCoerce id))) (pure (subtract 1)))))
08:05:00 <atriq> Some methods of recursion are ridiculous
08:05:16 <merijn> @quote sprynges
08:05:17 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
08:08:45 <matthiasgorgens1> atriq: that looks evil.
08:08:57 <atriq> matthiasgorgens1, oh, it is
08:09:41 <Yiq> ocharles: ^^ what i do in python (i think)
08:09:55 <atriq> It uses unsafeCoerce to convert a function (t -> Int -> Int) to t, then converts it back again before using it
08:12:20 <atriq> I'm pretty Hugs doesn't want you to do it, and GHC probably agrees
08:13:33 <Yiq> i can do infinite loop by calling: forever = forever?
08:13:51 <atriq> Yes, sort of?
08:14:08 <jfischoff> the compiler will catch that and give you a <<loop>> though
08:14:20 <jfischoff> err
08:14:22 <jfischoff> runtime
08:14:34 <Yiq> no stackblow?
08:14:51 <jfischoff> Yiq: no
08:15:12 <Cale> That evaluation, even if it were allowed to proceed, doesn't use any stack
08:15:13 <Cale> because there are no pattern matches
08:15:16 <qwr> it shouldn't grow stack even if the runtime wouldn't give <<loop>>
08:15:29 <Cale> The stack in GHC isn't a call stack
08:16:17 <Cale> It's a stack of case expressions (which is what all pattern matches translate into) who are waiting for their scrutinee to be sufficiently evaluated to be able to match.
08:16:45 <Yiq> aha
08:16:55 <Yiq> and the AMQP, anyone?
08:17:13 <Cale> What?
08:18:29 <geekosaur> cale: reference to question about 20 minutes ago
08:20:28 <ocharles> Yiq: I've offered to help you *twice* now
08:20:48 <ocharles> and you still haven't provided a paste or anything other than vague questions
08:21:23 <Yiq> i did paste
08:21:39 <jfischoff> here @hpaste ?
08:21:43 <jfischoff> @hpaste
08:21:44 <lambdabot> Haskell pastebin: http://hpaste.org/
08:22:13 <Yiq> http://hpaste.org/73574
08:22:42 <Yiq> it never got here?
08:23:21 <path[l]> hi, what's the most recommended book for learning haskell? is it learn you a haskell?
08:23:37 <Yiq> y
08:23:38 <adnam> i think so
08:24:07 <jfischoff> path[l]: I would take a look Real World Haskell also, you might like the style more. Its a personal choice really
08:24:16 <adnam> i have the haskell school of expression, but too much math too little haskell for my taste :]
08:24:43 <matthiasgorgens1> http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html is also good.
08:24:46 <matthiasgorgens1> but a bit heavy going.
08:24:47 <path[l]> I used real world haskell myself. I'm giving a talk to the programmers in my office about functional programming and I'm using haskell as a reference
08:24:50 <atriq> I think my evil recursion only works as long as GHC doesn't realise that it can't
08:25:03 <path[l]> so I was looking for a good reference to use to prepare the content
08:25:05 <adnam> matthiasgorgens1: i thought that was terrible :[
08:25:39 <adnam> i think RWH is better suited for people already familiar with FP
08:25:55 <jfischoff> path[i]: What language are the programmers familiar with?
08:25:56 <matthiasgorgens1> adnam, I never used it as a beginner.
08:26:01 <path[l]> java and c
08:26:14 <path[l]> some of them know javascript though
08:26:29 <path[l]> so they've been exposed to things like map
08:26:37 <path[l]> but most of them are familiar with java and c
08:26:56 <adnam> matthiasgorgens1: first haskell tutorial i read, did not go well :D
08:27:23 <matthiasgorgens1> adnam, you survived. :o)
08:27:25 <timthelion> path[l]: honestly, I programmed in many many languages for a period of 8 years and didn't know map untill I came to haskell.
08:27:39 <timthelion> that is, for 8 years before I started with haskell.
08:27:41 <qwr> matthiasgorgens1: gentle introduction to haskell? ;)
08:27:49 <path[l]> fair enough
08:28:03 <matthiasgorgens1> timthelion: it's called mapcar in common lisp. :o)
08:28:11 <timthelion> matthiasgorgens1: :)
08:28:12 <path[l]> so do you suggest I use real world haskell to prepare my talk? or lyah
08:28:19 <geekosaur> map gets used a fair amount in perl too
08:28:20 <timthelion> lyah.
08:28:32 * timthelion has never actually used perl.
08:28:41 <matthiasgorgens1> path[l]: how long's your talk?  is there time for exercises?
08:28:45 <Yiq> * yeah
08:28:52 <Yiq> how do you write in purple?
08:29:05 <path[l]> yeah, it's mostly going to be excercise based
08:29:10 <jfischoff> path[i]:  I would show examples in C (and Java) and Haskel. Show how you would do similar things. Like how you can make discriminated unions in C union and enum, and how sum types make that easier in Haskell, etc.
08:29:10 <path[l]> I want people to get their feet wet
08:29:20 <path[l]> it's about 3 hours long
08:29:31 <jfischoff> err in C with union and enums I mean
08:29:42 <matthiasgorgens1> jfischoff: if you feel you can handle the complexity in C (and Java), parser combinators a good for showing off haskell's power.
08:29:59 <matthiasgorgens1> because with more basic examples, stuff might look more complicated than in Java and C.
08:30:03 <srhb> path[l]: I guess the best point is to show the power of the type system and which errors it prevents, unless you're specifically going into the functional paradigm and not so much type inference etc. The sad thing is that it can be hard to really expose the functional paradigm in a short time span, while you can show a lot of awesome type-fu.
08:30:03 <jfischoff> mattiasgorgens1: that's a great point
08:30:25 <path[l]> actually I dont want to get into the type system
08:30:28 <matthiasgorgens1> jfischoff: i have a toy implementation of a combinatorical parser library lying around.
08:30:29 <path[l]> since the take away here
08:30:33 <pqmodn> path[l]: parser combinators are usually a compelling demonstration
08:30:38 <path[l]> is more for people to use it in their general work
08:30:47 <timthelion> path[l]: also show them http://fhtr.blogspot.cz/2008/12/drawing-tree-with-haskell-and-cairo.html
08:30:48 <path[l]> in multiparadigmn languages
08:30:56 <path[l]> so I really want to get into the functional paradigmn
08:30:56 <jfischoff> also traversals with Uniplate/Biplate are kinda of magical
08:31:02 <srhb> Hm, right.
08:31:03 <qwr> most programmers don't know why they would need parsers ;)
08:31:16 <ocharles> Yiq: ok, see your paste now. what is the problem with it?
08:31:27 <matthiasgorgens1> qwr: yeah, because parsers are too hard in most languages.
08:31:29 <Yiq> the receiver never prints anything
08:31:35 <matthiasgorgens1> qwr: so they use ad hoc techniques.
08:31:43 <srhb> path[l]: I suppose there's a lot to be learned from folding and mapping rather than imperatively looping, I just find it hard to go much further without completely drowning people. If you manage, please film the thing. :D
08:31:48 <path[l]> I agree with qwr. I was planning to get more into the whole "lets do these things" use recursion and folds and then talk about how they get to see that fp allows themselves to express themselves better
08:31:51 <ocharles> Yiq: and rabbitmq is running?
08:32:00 <path[l]> srhb: haha, really my talk is going to go in that direction
08:32:05 <srhb> :-)
08:32:14 <matthiasgorgens1> path[l]: the argument that "why functional programming matters" makes, is a good one to get across.
08:32:30 <path[l]> ah thanks, I remember reading that. I'll get hold of that
08:32:36 <ocharles> Yiq: why is line 65 commented out?
08:32:37 <Yiq> ocharles: well in python i didnt have to start anything...which was very confusing to me, i asked about that in #rabbitmq but got no answer
08:32:39 <path[l]> but I guess to giev them problems to solve
08:32:43 <path[l]> lyah is the best opton
08:32:45 <path[l]> option
08:32:50 <srhb> Yeah, I think so too.
08:33:02 <matthiasgorgens1> QuickCheck is also good.
08:33:04 <Yiq> ocharles: getLine? well i didnt need it?
08:33:06 <ocharles> Yiq: I have only used amqp with rabbitmq, and you need rabbitmq running for that
08:33:10 <typoclass> path[l]: have you seen the google talk by that mark lentczner dude? it's on youtube. check it out, there might be inspiration there
08:33:14 <timthelion> path[l]: did you look at the trees?  I really think that kind of thing turns smart people on.  Because, it's, ya know, pretty...
08:33:15 <ocharles> Yiq: without it, your reciever will just immediately terminate
08:33:21 <matthiasgorgens1> path[l]: I mean, QuickCheck style tests.
08:33:25 <srhb> typoclass: That's more about types though, isn't it
08:33:25 <path[l]> typoclass:  I havent seen this. let me google it, thanks
08:33:30 <Yiq> yeah i see that
08:33:36 <path[l]> oh is it about types?
08:33:37 <srhb> Plus I think he's a little silly and unnerving at the same time.
08:33:41 <srhb> Typical serial killer profile
08:33:46 <srhb> *dodgy eyes*
08:34:02 <typoclass> srhb: i thought it was nice how he just showed off stuff that you can do with haskell
08:34:02 <timthelion> srhb: who's a serial killer?
08:34:07 <srhb> typoclass: True.
08:34:10 <typoclass> but you're right about the serial killer look :D
08:34:31 <srhb> typoclass: Mark Lentczner
08:34:35 <matthiasgorgens1> typoclass: there's of course, also the cereal library. :o)
08:34:51 <srhb> er, sorry, timthelion : mark lentczner :P
08:34:58 <matthiasgorgens1> https://lh5.googleusercontent.com/-ImR9bdARxA4/AAAAAAAAAAI/AAAAAAAAAC4/pghDLfvpHl0/s250-c-k/photo.jpg doesn't look like a killer to me.
08:34:58 <timthelion> srhb: right, got it :)
08:35:09 <typoclass> matthiasgorgens1: what's up with it? it's elegant?
08:35:44 <matthiasgorgens1> typoclass: so you can be a cereal killer, instead of a serial one.
08:35:54 <typoclass> oh i see :) heh
08:38:34 <Yiq> ocharles: but i could run the first example when the program sent to itself via rabbitmq. and i have a node running now. so it "must" be something in my code? do you have any working code?
08:38:55 <ocharles> Yiq: only recievers, not senders
08:39:00 <timthelion> Anyone use WARNING pragma's as a todo list?
08:39:07 <ocharles> Yiq: you could install the rabbitmq web admin plugin, and see if messages are being sent
08:39:14 <ocharles> and make sure you're actually getting connected
08:42:01 <typoclass> timthelion: oh, nice idea :) i'mma start doing that
08:42:55 * hackagebot basic-prelude 0.3.0.0 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.0.0 (DanBurton)
08:48:57 <romildo> I am looking for an example of how to iterate over a Foreign.C.String in Haskell. Any help?
08:49:32 <quicksilver> iterate over it as in through its characters?
08:49:54 <romildo> quicksilver, yes
08:50:11 <quicksilver> use peekCString to get a normal String
08:50:15 <quicksilver> and then iterate over that, I suggest.
08:51:14 <romildo> quicksilver, this is not a solution to me, as the string is encoded, and I want to process it without decoding it.
08:51:30 <quicksilver> romildo: why?
08:51:41 <quicksilver> are you saying you want to iterate over bytes, not Chars?
08:53:01 <romildo> quicksilver, because regex-pcre is returning positions in the encoded C string and I want to map the positions so that they correctly refer to the decoded string.
08:53:04 <monochrom> CString = Ptr CChar. CChar is newtype CChar = CChar Int8. you certainly have bytes
08:53:13 <romildo> yes, I want to iterate over C chars.
08:54:29 <quicksilver> well you can just use peekArray to get the CChars
08:54:38 <quicksilver> or you can use peekCAString and map fromEnum
08:55:29 <romildo> I suppose I can use plusPtr to calculate the pointer to the next item. But how I access the pointed item?
08:55:35 <quicksilver> peek
08:55:39 <quicksilver> or peekArray to get them all
08:57:06 <romildo> Which modules provides peek?
08:57:21 <quicksilver> @hoogle peek
08:57:21 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
08:57:22 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
08:57:22 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
08:58:03 <romildo> ok. I think that is enough for doing what I want. Thanks.
09:03:36 <gertc> http://www.haskell.org/haskellwiki/Newtype
09:04:09 <gertc> case x of
09:04:17 <gertc> Any _ -> ()
09:04:26 <gertc> _ -> ()
09:04:45 <gertc> would that not make it more clear?
09:04:54 <gertc> or did i mis the point
09:06:52 <Eduard_Munteanu> gertc: you did, the interesting bits are what happens when you attempt to unpack a newtype
09:07:11 <srhb> gertc: Take care with this bit:  In this example, we have ⊥ :: Any distinct from Any ⊥ :: Any.
09:12:39 <timthelion> http://hpaste.org/73575  Is there a standard approach to this problem?
09:12:56 * hackagebot template-hsml 0.1.0.0 - Haskell's Simple Markup Language  http://hackage.haskell.org/package/template-hsml-0.1.0.0 (PetrPilar)
09:18:57 <RaphaelJ> Hey
09:19:26 <srhb> RaphaelJ: Hello.
09:20:10 <timthelion> No answers?
09:23:23 <RaphaelJ> What's the best way to *not* memoize an infinite list ?
09:23:23 <RaphaelJ> I've a function which generate an infinite list of data and which is iterated from different parts of my program.
09:23:23 <RaphaelJ> While its iterating the list, I don't what the runtime to keep in memory the whole list juste because the pointer to the first item is still required for another call but recompute the list each time its iterated
09:24:04 <RaphaelJ> I've something which runs by using a useless argument for the generating fuction, but that's not pretty
09:24:29 <timthelion> RaphaelJ: does it currently moimize it or are speculating that it's doing so?
09:25:00 <gertc> newtype Any = Any { getAny :: Bool }
09:25:00 <RaphaelJ> Yes, its currently making an out of memory exception
09:25:22 <amalloy> RaphaelJ: instead of passing around the list, pass around a function for generating the list, i think? that's the answer to the same question in clojure, but i'm not totally sure about the difference between values and no-argument functions in haskell
09:25:30 <gertc> Any . getAny $ ⊥  = ⊥
09:25:46 <srhb> RaphaelJ: Your method is sound enough.
09:25:46 <timthelion> amalloy: there's really no difference.
09:26:52 <gertc> correct?
09:27:57 <RaphaelJ> gertc: Any and getAny will be removed during the compilation, so yes
09:28:54 <gertc> ok thx i feel like there should be a comparison in the wiki paragraph?
09:30:05 <jfischoff> is anyone familiar with shake and ruby's rake? I'm not exactly sure how best to port a rake file to shake. Specifically how would rake style task grouping in shake?
09:32:47 <gertc> Also does it not prove that you sould always use newtype when you can?
09:34:56 <gertc> I cant think of any example where newtype is not a good idea after reading that paragraph?
09:36:45 <int-e> gertc: Well (After (A (While (The (Newtype (Constructors (Will (Make (The (Program (Very (Hard (To "Read"))))))))))))))
09:37:19 <Eduard_Munteanu> gertc: as opposed to 'data' or 'type'?
09:37:45 <int-e> I need a bracket matching client; that was one closing bracket too many.
09:37:56 <Eduard_Munteanu> When you compare to 'data' yeah, it's always a better idea if you can use a newtype.
09:38:03 <srhb> int-e: M-x rainbow-mode
09:38:22 <timthelion> int-e: I prefer hard to read, to hard to comprehend :D
09:38:26 <gertc> Eduard_Munteanu, yes opposed to data
09:38:35 <monochrom> you need to use ghclive as your irc client XD
09:38:40 <int-e> srhb: right. but I like irssi otherwise ;)
09:38:49 <gertc> when there is just one vaule
09:38:54 <srhb> int-e: Sorry. :-)
09:39:03 <int-e> srhb: nah, it's ok. I asked for that.
09:39:19 <monochrom> also lisp proves that you can just do Well (After (A While (Just close with]
09:39:38 <Eduard_Munteanu> gertc: well, that doesn't quite cover it, e.g. data A a = A
09:39:43 <timthelion> monochrom: that hurts my eyes!
09:39:49 <timthelion> )))
09:39:53 <Eduard_Munteanu> You can't use newtype there.
09:39:54 * timthelion feels better now.
09:39:58 <int-e> timthelion: [
09:39:59 <monochrom> I know, some people say that it's unsafe for real code. I agree. but this is just irc, not real code
09:40:50 <ocharles> int-e paredit-mode too!
09:41:27 <gertc> Eduard_Munteanu, hmm so data A  a = A
09:41:51 <monochrom> if you can survive my ocasional typos, you can certainly cope with 1+x*(2+x*(3+x]
09:42:58 <Eduard_Munteanu> What if you want to close just some of those parens?
09:44:04 <timthelion> monochrom: yeah, like (1*(2*(3]+4)???
09:44:04 <Eduard_Munteanu> Say (Stuff (Like (This] But) Not All Of Them.
09:44:37 <monochrom> if I just want to close some parentheses, I'm doomed, back to real )'s
09:45:31 <Eduard_Munteanu> Maybe (You (Could (Do Type-Directed] Parens Closing.
09:45:45 <Eduard_Munteanu> [On IRC)) !
09:47:36 <geekosaur> what is this, interliskell?
09:47:44 <timthelion> You could have a simple adder, that would say ] would close as much as was left over after all the real parens had been counted.  But then what if you had two ]'s?
09:48:01 <casion> just run paredit in ERC, problem solved :P
09:48:08 <ocharles> +1
09:48:10 <gertc> sorry i cant understand why you should use data instaed of newtype A  a = A is
09:48:11 * timthelion likes making haskell into lisphell.
09:48:37 * timthelion isn't sure what's usefull about newtype...
09:49:07 <Eduard_Munteanu> gertc: because the newtype won't work there? Try it.
09:49:13 <jupiter234> Hi
09:49:20 <Eduard_Munteanu> Hi there.
09:49:39 <casion> can anyone point me to a reasonably functional gui-based application written in haskell?
09:49:41 <jupiter234> Hi Eduard, I am not able to understand the sequence of execution of: filter (not . f) a
09:50:01 <srhb> jupiter234: What troubles you?
09:50:02 <casion> functional as in 'usable' not functional in a programming context
09:50:20 <c_wraith> casion: does threadscope count?
09:50:24 <gertc> Eduard_Munteanu, a ok but can i state if the compiler allows the use of newtype you should alwasy use newtype?
09:50:44 <jupiter234> what is applied first - not or f to a
09:50:45 <Eduard_Munteanu> gertc: probably
09:50:53 <monochrom> gertc, you use "data" if it solves your problem, and you use "newtype" if it solves your problems. there is no "don't use data" or "don't use newtype"
09:50:56 <c_wraith> gertc: newtype and data have different semantics.  Sometimes you want one or the other.
09:50:58 <identity> casion: leksah perhaps.
09:51:02 <identity> afaik it's written in Haskell.
09:51:12 <jupiter234> this is from Haskell's implementation of partition: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:partition
09:51:23 <srhb> jupiter234: not and f are composed to yield a new function. f is the first function in that chain, ie. your new function takes the input of f and yields the output of not.
09:51:24 <casion> identity, c_wraith: thanks
09:51:35 <timthelion> identity: he asked for usable though :D (though leksah's problems probably have little to do with the fact that it's written in haskell)
09:51:39 <srhb> (So to speak)
09:51:45 <identity> timthelion: hehe. I haven't tried it.
09:51:51 <parcs`> > Any undefined `seq` ()
09:51:52 <lambdabot>   *Exception: Prelude.undefined
09:52:02 <timthelion> identity: have you ever used a professional IDE?
09:52:07 <srhb> jupiter234: If in doubt, read the definition of (.) - it should be clearer then.
09:52:11 <casion> I just want to see (if?) how  people are dealing with GUIs with haskell
09:52:13 <Eduard_Munteanu> jupiter234: (f . g) x = f (g x) by definition
09:52:16 <srhb> @src (.)
09:52:16 <lambdabot> (f . g) x = f (g x)
09:52:16 <lambdabot> NB: In lambdabot,  (.) = fmap
09:52:22 <identity> timthelion: I have, yes. Visual studio, for one.
09:52:45 <timthelion> identity: well VS is really easy compaired to leksah :D
09:53:00 <identity> timthelion: huh. that's.. bad.
09:53:27 <timthelion> casion: it's possible, certainly.  I'm currently working on https://github.com/timthelion/gridhaskell-haskarrow which is currently unusably slow. but runs and works.
09:53:30 <Eduard_Munteanu> casion: well, usually Haskellers reach for a toolkit like Gtk2Hs.
09:53:33 <jupiter234> This  should be then equivalent to : (not (f a))
09:53:53 <Eduard_Munteanu> casion: but if you're into researchy stuff, there are things like FRP toolkits
09:53:57 <timthelion> casion: the slowness isn't the fault of haskell at all though.  it's a design flaw.  I took a risk that I shouldn't have.
09:54:01 <gertc> c_wraith, can you add a example where you would choose data instead of a newtype and both are allowd by the compiler?
09:54:05 <jupiter234> right?
09:54:09 <casion> Eduard_Munteanu: I'm looked into that, but I develop crossplatform applications, and GtK in any form is useless :(
09:54:13 <casion> I've*
09:54:21 <Yiq> some hoops?
09:54:28 <identity> casion: wxhaskell?
09:54:37 <timthelion> casion: gtk is useless cross platform?  Pray do tell why?
09:55:07 <edwardk> preflex: xseen roconnor
09:55:07 <preflex>  roconnor was last seen on freenode/#haskell-blah 17 hours, 59 minutes and 57 seconds ago, saying: ML module mixins are strange
09:55:14 <casion> timthelion: it's difficult to get working properly for a non-technical user in windows
09:55:32 <roconnor> preflex: seen edwardk
09:55:33 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
09:55:33 <preflex>  edwardk was last seen on #haskell 25 seconds ago, saying: preflex: xseen roconnor
09:55:39 <edwardk> roconnor: =P
09:55:41 <Eduard_Munteanu> casion: hm? You can ship GTK2 in your app pretty easily
09:55:43 <casion> timthelion: and there's a few common GTK applications that blow up when you start trying to install the 'incorrect' gtk version
09:55:48 <edwardk> roconnor: been adding uniplate to lens
09:55:49 <casion> yes, I'm aware
09:55:50 <c_wraith> gertc: two versions of the Identity monad..  data/newtype Identity a = Identity { runIdentity :: a } ; instance Monad Identity where return = Identity ; (Identity x) >>= f = f x
09:55:53 <timthelion> casion: you can build GTK into your binarry... See abiword for example.  Single binarry install on windows.
09:55:59 <c_wraith> gertc: both data and newtype are allowed there
09:56:20 <edwardk> at least swapping the combinators over to using lenses and traversals. indexed kleene store let me write biplate and uniplate combinators for them
09:56:21 <roconnor> edwardk: that sounds useful.
09:56:28 * timthelion doesn't actually use windows and is thus probably full of shit.
09:56:33 <c_wraith> gertc: and the Monad instance is *very* different in one important way between them
09:56:45 <timthelion> casion: you just have to make sure that gtk is STATICALLY linked and not dynamically linked :D
09:56:52 <edwardk> they also work with the more restricted types of traversals where they can
09:56:58 <roconnor> edwardk: I don't quite see why the indexed kleene store is needed
09:56:59 <c_wraith> gertc: in particular, (>>=) is strict in its first argument with data, but it's not with newtype
09:57:07 <jupiter234> @srhb But : f a has type signature : (a->Bool) -> [a] -> [a]
09:57:07 <lambdabot> Source not found. My brain just exploded
09:57:13 <edwardk> roconnor: let me show you
09:57:21 <jupiter234> how can not be applied to a list
09:57:27 <c_wraith> gertc: the difference there is very significant when you want to control evaluation order
09:57:31 <Eduard_Munteanu> c_wraith: arguably you can do ~(Identity a) >>= f = f a  there
09:57:45 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Uniplate.hs
09:57:48 <Eduard_Munteanu> :t not
09:57:49 <lambdabot> Bool -> Bool
09:57:55 <Eduard_Munteanu> :t map not
09:57:56 <lambdabot> [Bool] -> [Bool]
09:57:57 <edwardk> see the implementation of 'uniplate' and 'biplate' in there
09:58:01 <casion> timthelion: is that possible with haskell? (I'm fairly new to the language, so forgive if that's a silly question)
09:58:06 <c_wraith> Eduard_Munteanu: sure, but only one way.  You can make data non-strict.  But you can't make newtype strict
09:58:22 <casion> most applications dynamically link gtk anyway
09:58:25 <timthelion> casion: I've never built using ghc on windows, sorry.  But it *should* be...
09:58:30 <edwardk> i define everything else in terms of underneath which is just a simple traversal a a, but to make the actual uniplate and biplate combinators i need the store
09:58:42 <c_wraith> Eduard_Munteanu: because the newtype constructor doesn't actually exist
09:58:46 <gertc> c_wraith, can you add it too http://www.haskell.org/haskellwiki/Newtype
09:59:13 <Eduard_Munteanu> c_wraith: mm, yes, but I'm not sure how that gives you different semantics in a "good" way.
09:59:21 <timthelion> casion: but that's really besids the point.  Wxhaskell will work as well.  If you look at the source code I linked to, the interesting parts have nothing to do with my use of GTK. but rather my use of threadObjects.
09:59:48 <casion> timthelion: yeah, I'm looking :) I'm very familiar with Wx anyway
09:59:50 <casion> thank you
10:00:05 <Eduard_Munteanu> c_wraith: I mean, when would the strict variant make more sense?
10:00:26 <edwardk> i suppose i can cripple biplateOf a little and get something that doesn't need the error case
10:01:04 <c_wraith> Eduard_Munteanu: the strict variant is what the monad-par library is based on.  The fact that it's strict is what lets monad-par force evaluation before continuing its computation
10:01:05 <roconnor> edwardk: underneath = children?
10:01:08 <edwardk> yeah
10:01:18 <edwardk> except children was already taken by uniplate
10:01:28 <edwardk> its descendA if that had existed in uniplate
10:01:32 <edwardk> there was a descendM though
10:01:59 <Eduard_Munteanu> c_wraith: mm, but surely you can do ... = x `seq` f x if you want strictness there, regardless of the newtype, no?
10:02:07 <atriq> I was talking about some code I wrote to a none-programmer friend before.
10:02:20 <edwardk> plateOf :: LensLike (Kleene c c) a b c c -> a -> ([c], [c] -> b)  -- i think is better than the uniplateOf and biplateOf combinators i have now
10:02:20 <atriq> I said there are two kinds of people who use unsafeCoerce successfully
10:02:24 <atriq> Evil people, like me
10:02:31 <atriq> The other kind is edwardk.
10:02:35 <roconnor> edwardk: neat;  Though using indexed traversals is probably safer than the uniplate interface
10:02:40 <edwardk> yes
10:02:42 <Eduard_Munteanu> I mean, what does strictness in the wrapper buy you?
10:02:45 <edwardk> i don't use the uniplate interface anywhere
10:02:50 <edwardk> i just wanted to expose it
10:02:52 <roconnor> right
10:03:00 <edwardk> the plateOf is a safer uniplate
10:03:03 <timthelion> casion: That program is written "model view", and you can use this http://hackage.haskell.org/package/ThreadObjects package if you want to do the same.
10:03:14 <edwardk> if you under- or over- supply it it doesn't crash
10:03:15 <c_wraith> Eduard_Munteanu: not really.  That pushes the responsibility onto the user of the library, instead of keeping it inside the library
10:03:25 <casion> timthelion: great, thank you very much for the assistance
10:03:32 <casion> this is exactly what I was looking for
10:03:38 <edwardk> it just ignores the excess or keeps the existing values for the other positions
10:03:53 <jupiter234> Are these equivalent:  not (f a)   and   (not . f) a (Where a is list and f is a predicate)
10:04:05 <Eduard_Munteanu> c_wraith: I mean like (Identity x) >>= f = x `seq` f x.
10:04:21 <c_wraith> Eduard_Munteanu: that has different semantics
10:04:30 <c_wraith> Eduard_Munteanu: that forces x to WHNF
10:04:35 <edwardk> just want to get the last few combinators in, holesOf, etc.
10:04:39 <Eduard_Munteanu> Yeah, sure.
10:04:40 <roconnor> edwardk: where is plateOf?
10:04:50 <edwardk> just wrote it
10:04:58 <Eduard_Munteanu> But why would strictness matter for something like a newtype which is inexistent at runtime?
10:05:01 <edwardk> its basically uniplateOf with a more general signature
10:05:07 <roconnor> edwardk: right
10:05:08 <edwardk> i removed uniplateOf and biplateOf locally
10:05:19 <c_wraith> Eduard_Munteanu: that will blow up if you do "return undefined >> return 5".  The data version won't
10:05:32 <roconnor> edwardk: outs is distruvgingly safe
10:05:36 <roconnor> *distrubingly
10:05:40 <edwardk> yes
10:05:43 <copumpkin> edwardk: I am highlighting you to hear the ding
10:05:48 <c_wraith> Eduard_Munteanu: the difference is whether pattern-matching the Identity constructor can be used to drive evaluation or not.
10:05:48 <edwardk> copumpkin: =P
10:05:50 <copumpkin> edwardk: dammit I didn't hear it
10:05:54 <copumpkin> your window must be active
10:06:02 <edwardk> muted
10:06:04 <Eduard_Munteanu> Oh, I see.
10:06:04 * copumpkin waits
10:06:05 <copumpkin> oh
10:06:13 <djahandarie> Sounds like copumpkin is having a good time
10:07:10 <roconnor> edwardk: I was afraid your interest in lens has passed.
10:07:30 <edwardk> not entirely
10:07:31 <roconnor> edwardk: OTOH, this library seems like it will be useful for your every day Haskell programming
10:07:35 <edwardk> yeah
10:07:51 <Eduard_Munteanu> That does sound as if your types had codata semantics
10:07:57 * hackagebot haskell-src-exts-qq 0.6.1 - A quasiquoter for haskell-src-exts.  http://hackage.haskell.org/package/haskell-src-exts-qq-0.6.1 (MathieuBoespflug)
10:09:32 <gertc> Eduard_Munteanu, c_wraith, thx
10:10:24 <jtza8> I came from Common Lisp thinking that I'd miss the powerful macros. Seems functional programming takes care of that for the most part. :)
10:11:51 * jtza8 doesn't know why he just said that.
10:12:03 <c_wraith> jtza8: polymorphism and laziness take care of several common uses of macros - but certainly not all of them
10:12:49 * timthelion wants macros...
10:15:07 * roconnor hands timthelion template haskell
10:17:02 * timthelion slaps roconnor's hand back and starts screeming something about good old "ugly like me" c preprocessor macro's.
10:17:12 <Yiq> isnt polymorphism automatic in a dynamic lang?
10:18:01 <jtza8> Yiq: It's got nothing to do with the type system.
10:19:05 <sm> I seem to remember standard IO functions automatically translate / in FilePath to eg \ on windows.. am I right and if so can I mostly forget about using </> ?
10:22:13 <dispy> instance (JSON a) => JSON [a] where  << if JSON is a typeclass, this basically says that the type of parameter a is bound to be an instance of the typeclass JSON, so this is actually y constraint?
10:22:34 <sm> at least, if I'm just concatenating two known path parts
10:22:39 * sm thinks so
10:27:45 <Yiq> so polymorphism
10:28:46 <Yiq> if i define add3 for before a number and a list(yeah perhaps doesnt make sense), how do i do that? with a class?
10:30:33 <jtza8> Yiq: An example of polymorphism in Haskell is the typeclasses.
10:31:29 <jtza8> Yiq: as in "+" can be overloaded to work on Int and Double .
10:32:38 <jtza8> Yiq: In Ruby, I think you do something similar with objects.
10:36:05 <edwardk> roconnor: got a better name than Uniplate for the class?
10:41:06 <dispy> instance (JSON a) => JSON [a] where  << if JSON is a typeclass, this basically says that the type of parameter a is bound to be an instance of the typeclass JSON, so this is actually y constraint?
10:41:19 <dispy> (If the description is weird, just tell me)
10:42:30 <geekosaur> "[a] is an instance of JSON, provided that a is an instance of JSON"
10:43:21 <geekosaur> note the implication there that the unconstrained [] is checked first and the JSON-ness of a only afterward
10:45:25 <dispy> ok thanks
10:45:35 <dispy> It's just that the author used it without any explanation ;)
10:46:23 <nand`> it's fairly basic haskell, I'm not sure if it warrants an explanation, honestly
10:46:48 <Saizan> jtza8: actually, we talk about e.g. (map :: (a -> b) -> [a] -> [b]) as being parametrically polymorphic, while (map :: (Bool -> Int) :: [Bool] -> [Int]) wouldn't
11:05:48 <edwardk> i need a good name for children or descendants one step down that isn't children or 'kids'
11:06:07 <Clint> immediateprogeny
11:06:13 <sipa> offspring
11:06:19 <edwardk> Clint: =P and that is preferably short
11:06:23 * Clint grins.
11:06:37 <srhb> truBorn
11:06:41 <srhb> Throw in some gang signs
11:06:47 <edwardk> right now i'm using 'inside', i used 'underneath' for a little while
11:06:53 <edwardk> or 'beneath'
11:06:53 <johnw> deps
11:06:58 <sclv> descendants
11:07:03 <nand`> successors
11:07:04 <johnw> as in, dependents
11:07:05 <edwardk> its the traversal that yields the immediate children of a tree
11:07:06 <srhb> Well, that's not immediate is it.
11:07:20 <sclv> nextLayer
11:07:23 <edwardk> sclv: i have things that yield multigenerational descendants
11:07:26 <nand`> oneDown
11:07:30 <Clint> daughters
11:07:31 <johnw> subs
11:07:33 <edwardk> sclv: and i've avoided camelcase for the entire library ;)
11:07:39 <johnw> for subordinates
11:07:39 <sclv> nextlayer
11:07:42 <nand`> Clint: nice
11:07:44 <edwardk> successors isn't bad
11:07:45 <srhb> Clint: That's a good idea
11:07:46 <sclv> :-P
11:07:52 <luite> brood
11:07:54 <johnw> sons is shorter
11:08:30 <edwardk> sons might get me accused of reinforcing gender roles or something
11:08:53 <Mathnerd314> heir
11:08:55 <srhb> Nonsense, as long as they go to the bottom.
11:08:56 <srhb> :-)
11:09:01 <sclv> lateralroots
11:09:02 <Mathnerd314> junior
11:09:23 <sclv> shoots
11:09:38 <johnw> members?
11:09:45 <edwardk> johnw: thats not bad
11:09:55 <johnw> if you think of your thing like a set...
11:09:55 <sclv> constituents
11:10:23 <edwardk> i also need a class for things with this property. its going to play the role of uniplate
11:10:44 <johnw> Subgroup
11:11:06 <edwardk> instance Foo (Tree a) where foo f (Bin l r) = Bin <$> f l <*> f r; foo _ t = pure t
11:11:15 <edwardk> where Foo is the class in question and foo is the method
11:11:24 <johnw> Branch?
11:11:30 <sclv> instance Constituted (Tree a) where constituents f...
11:11:39 <Mathnerd314> limb
11:11:40 <edwardk> Branched and branch isn't bad
11:11:56 <edwardk> Limbed and limb could work
11:12:12 <edwardk> or limbs
11:12:14 <sclv> instance Membered (Tree a) where members =
11:12:17 <johnw> DO branches have limbs, or are they synonyms?
11:12:23 <srhb> Both.
11:12:36 <sclv> instance Membered (Tree a) where dismember =
11:12:38 <edwardk> then descend = over limbs
11:12:46 <johnw> yes
11:12:54 <edwardk> descendM = mapMOf limbs
11:12:57 <johnw> limbs is good for that
11:13:32 <edwardk> transform f = go where go = f . over limbs go
11:14:11 <sclv> edwardk: is this generic programming over yr. new lens library?
11:14:24 <edwardk> sclv: yeah. i ported uniplate to work with lenses and traversals instead
11:14:51 <sclv> cute
11:14:52 <edwardk> but i need a name for the class that isn't Uniplate, because it doesn't use uniplate per se, it uses a Simple Traversal a a   -- and there is a separate plateOf
11:14:59 <johnw> edwardk: I wanted to write a Hierarchy library, for representing arbitrary tree-like things, I like these names for that too
11:16:00 <Mathnerd314> twig might work too
11:16:01 <sclv> instance Plated (Tree a) where platelets = ...
11:16:10 <timthelion> edwardk: Call it SimpTrav'a'a :D
11:16:17 <edwardk> Plated and plate was the first name i used
11:16:36 <edwardk> but then i made 'plateOf' take a traversal and give it a uniplate like signature
11:16:54 <timthelion> edwardk: or EZSimpTrav_TM_
11:16:56 <edwardk> and that made 'plate' misnamed
11:17:36 <sclv> platelets, tho
11:17:43 <Mathnerd314> luite: does wolfgang have an ETA?
11:18:11 <edwardk> heh
11:18:40 <edwardk> Plated and platelets is pretty good =)
11:18:45 <sclv> instance Rhizomatic (Tree a) where rhizomes = ..
11:18:54 <luite> Mathnerd314: uh...
11:19:04 <sclv> or even better...
11:19:25 <sclv> instance Rhizomatic (Tree a) where plateaus = ... -- make the Deluze and Guattari fans proud
11:19:28 <Mathnerd314> luite: so, no? :-/
11:19:33 <edwardk> uniplate :: Limbed a => a -> ([a], [a] -> a); uniplate = plateOf limbs -- is a little gory sounding
11:19:39 <sclv> lol
11:20:10 <copumpkin> edwardk: instance Limbed Integer ;)
11:20:31 <copumpkin> GMP "joke", sorry
11:20:35 * copumpkin crawls back into the hole
11:20:36 <edwardk> copumpkin: *groan*
11:21:35 <jfischoff> what is the idiomatic way to fold a one dimensional repa array? do I convert it to a vector first?
11:21:59 <edwardk> could just go with 'parts'
11:22:11 <luite> Mathnerd314: i changed the plans a bit since i wasn't confident anymore that it would be secure enough
11:22:22 <jfischoff> edwardk: its existing to see you have moved on to plates :)
11:22:26 <jfischoff> exciting
11:22:30 <jfischoff> :p
11:22:30 <edwardk> =P
11:22:38 <srhb> jfischoff: Repa can only fold from 2d and up?
11:22:47 <edwardk> i'd been meaning to add support for them for a while
11:22:59 <jfischoff> srhb: at least in this section http://hackage.haskell.org/packages/archive/repa/3.2.1.1/doc/html/Data-Array-Repa-Operators-Reduction.html
11:23:15 <edwardk> i could use 'plates' as the traversal, the uniplate = plateOf plates
11:23:19 <jfischoff> srnb: maybe it can I don't know
11:23:56 <srhb> jfischoff: It says of arbitrary rank, so it must be able to, right?
11:24:01 <jfischoff> srhb: i see it now is foldAllS oops. thanks for making me look harder
11:24:10 <edwardk> I think Plated/plates wins
11:24:23 <srhb> jfischoff: :)
11:25:32 <sclv> edwardk: eh. functional, appropriate, somewhat dull.
11:25:38 <edwardk> sclv: yeah
11:25:48 <edwardk> but less likely to collide
11:25:54 <sclv> i'm still waiting for the appropriate functions to name inosculate and variegate.
11:26:02 <copumpkin> jfischoff: I could've sworn I saw that operator
11:26:03 <b__> is there a good idiom for limiting allowed values for an argument to a certain range?
11:26:07 <sclv> varigate, that is.
11:26:36 <sclv> b__ depends on how strongly you want to enforce it.
11:26:45 <copumpkin> jfischoff: foldS :: (Shape sh, Source r a, Elt a, Unbox a) => (a -> a -> a) -> a -> Array r (sh :. Int) a -> Array U sh a ?
11:26:47 <sclv> a "smart constructor" is the usual basic solution
11:27:15 <Veinor> i wish you could export constructors for pattern matching but not for constructing
11:27:17 <jfischoff> copumkin: I just didn't see foldAllS
11:27:29 <sclv> Veinor -- view patterns get you sorta there?
11:27:56 <Veinor> sclv: it means i have to come up with names, though
11:28:16 <jfischoff> compumkin: or even better for my application sumAllP
11:28:50 <copumpkin> jfischoff: you shouldn't even need the All bit
11:28:52 <copumpkin> but yeah
11:29:51 <Mathnerd314> luite: so what is the plan now?
11:30:27 <jfischoff> compumkin: I do, because that function will only work on arrays over one dimension I think (sh :. Int)
11:30:47 <jfischoff> copumpkin: ^
11:31:02 <copumpkin> jfischoff: yeah, you have an array of one dimension, and it'll give you an array of zero dimensions
11:31:05 <copumpkin> which is basically a scalar
11:31:27 <jfischoff> copumkin: and yet I get a compiler error
11:31:56 <copumpkin> hm
11:34:58 <jfischoff> copumpkin: wait I could be wrong
11:35:15 <copumpkin> either way, the *All version is even easier for your purposes
11:35:29 <copumpkin> I think my dependently typed API is a lot clearer though!
11:36:43 <jfischoff> copumpkin: hehe I bet. I didn't realize there was a monad in the P versions. Do you know if that can just be identity, or does it have to be something special to get the parellization to work?
11:37:01 <copumpkin> nah, anything works
11:37:06 <copumpkin> I think that's just a strictness hack
11:37:08 <jfischoff> copumpkin: which probably why I was getting a compiler error oh well
11:37:09 <copumpkin> can't remember though
11:37:14 <jfischoff> cool
11:37:16 <jfischoff> thanks!
11:45:54 <haqe17> Hi, can some tell me how to fix this line. im trying to define scanr recursively. its driving me nuts.
11:45:58 <haqe17> let {myScanr :: (a->b->b)->b->[a]->[b]; myScanr f acc [] = [acc]; myScanr f acc (x:xs) = f x (myScanr f acc xs):xs;}
11:48:26 <sfogarty> I am attempting to compile a haskell file to an object (for use in GHCi) without a defined main. ghc -c <file> still complains that there is no function main in module Main. How might I do this?
11:48:38 <b__> sclv thanks for your message earlier, I might go that route. Is it possible though to make am Int-like type that is limited to a certain range?
11:50:23 <fmap> sfogarty: don't name you module Main
11:50:29 <fmap> your*
11:50:45 <srhb> It's also the implicit name if you don't add one, isn;t it?
11:50:50 <fmap> yes
11:51:04 <sfogarty> I don't want to have a module main, I just want an object file
11:51:15 <sfogarty> I'm not trying to make an executable, just a .o file
11:51:53 <srhb> sfogarty: You must af module Foo where .. at the top of your file
11:52:01 <srhb> sfogarty: Where Foo is not Main, otherwise Main is assumed.
11:52:26 <sfogarty> Doh! Thank you, srhb. I was leaving it out of a module. That works, thanks so much
11:55:49 <haqe17> can anyone help me define scanr recursively?
11:56:07 <MostAwesomeDude> haqe17: Homework?
11:57:09 <MostAwesomeDude> b__: You can define a type and make it both Bounded and Enum, but it's very unfun. data Count = Zero | One | Two | ...
11:57:23 <haqe17> MostAwesomeDude: no. reading the wiki and trying to do the exercises
11:58:10 <krageon> I'm working through real world haskell, and there is a test program: main = interact wordCount where wordCount input = show (length (lines input)) ++ "\n"
11:58:30 <krageon> if I feed it any sort of text file, it tells me there is a lexical error at character '\DEL'
11:58:33 <loreints> where would I find a good example of bitwise manipulation in haskell?
11:58:41 <loreints> examples*, hopefully :P
11:58:48 <Veinor> krageon: how are you invoking it?
11:58:50 <krageon> And I eriously don't understand why
11:59:00 <krageon> I compile it using ghc <filename>
11:59:18 <krageon> I run it using runghc Counter < file.txt
11:59:24 <Veinor> oh
11:59:26 <srhb> aha
11:59:28 <Veinor> Counter is a full-blown executable
11:59:34 <krageon> yes :)
11:59:38 <Veinor> so don't use runghc
11:59:39 <srhb> ./Counter < file.txt
11:59:48 <srhb> runghc Counter tries to interprete Counter as haskell source code
11:59:51 <srhb> Which it is not
12:00:11 <Veinor> if you try to interpret a compiled binary as source, you're gonna have a bad time
12:00:39 <srhb> The error about \del is because the Haskell parser is choking on it, not that your file.txt contains it
12:01:31 <srhb> krageon: Or you could do runghc Counter.hs < file.txt
12:01:34 <sfogarty> for some reason I am not getting tail call optimization (compiled, with -O) on the function:   inc_n_x_times' n x = if x == 0 then n else inc_n_x_times (n+1) (x-1)
12:01:43 <roconnor> edwardk: I'm not very good with names.  It seems like it ought to have something to do with children.
12:01:44 <sfogarty> Is this the esoterica of the compiler, or something simple I"m missing?
12:01:48 <sfogarty> nevermind
12:01:50 <sfogarty> good heavens
12:02:00 <edwardk> went with Plated and plates
12:02:05 <edwardk> that way uniplate = plateOf plates
12:02:25 <roconnor> Since I'm so bad with name's I'd call the class Parthenogenesis.
12:02:28 <haqe17> Hi, can some tell me how to fix this line. im trying to define scanr recursively. its driving me nuts.
12:02:31 <edwardk> hahaha
12:02:35 <haqe17> let {myScanr :: (a->b->b)->b->[a]->[b]; myScanr f acc [] = [acc]; myScanr f acc (x:xs) = f x (myScanr f acc xs):xs;}
12:02:38 <edwardk> sorry for making fun your your naming skills =)
12:02:47 <roconnor> I'm okay with it :D
12:02:54 <roconnor> I know my limitations
12:02:56 <Veinor> sfogarty: what was it?
12:03:09 <edwardk> going through and haddocking the uniplate combinators now
12:03:14 <roconnor> edwardk: I sent a long time with Jacque to come up with the name Store, which IMHO is pretty good.
12:03:24 <sfogarty> Veinor: I was calling the wrong function recursively (the non-trail-recursion inc_n_x_times)
12:03:24 <edwardk> got everyting including contexts, etc.
12:03:34 <srhb> @where hpaste -- haqe17
12:03:34 <lambdabot> http://hpaste.org/
12:03:36 <edwardk> we bounced it around here as well as i recall
12:03:52 <roconnor> ya, I spent at least a week working on it.
12:03:57 <roconnor> possibly longer than on the theory
12:04:02 <krageon> srhb: I will try that now, thank you
12:04:11 <sclv> two hard things, naming and cache invalidation :-P
12:04:12 <edwardk> good names take time
12:04:57 <Veinor> sclv: and off-by-one errors!
12:05:24 <sclv> ouch
12:05:29 <edwardk> veinor: what are those? =)
12:05:31 <krageon> srhb: I have a hard time believing it, but that worked! What exactly is the difference between compiling it first and invoking the source file directly?
12:05:33 <roconnor> apparently there are only female in the New Mexico whiptail species
12:05:57 <edwardk> i seem vaguely to recall what those were like from my life before haskell
12:05:58 <srhb> krageon: What was happening before is that you were trying to make the interpreter read the BINARY as haskell source file
12:06:16 <srhb> krageon: Which it wasn;t, you compiled it, so Counter is a binary executable. runghc tries to read that as source. Doesn't go well.
12:06:33 <fmap> sfogarty: how do you know if the function is tail call optimised or not?
12:06:42 <srhb> krageon: ./Counter < file.txt or runghc Counter.hs < file.txt -- either is fine, but you can interpret a binary as Haskell.
12:06:47 <krageon> srhb: Haha xD I feel terrible now. Thank you so much :)
12:06:51 <sfogarty> fmap: call it with 100000000 and see if it pops the stack
12:06:59 <srhb> krageon: No problem. :)
12:07:00 <sfogarty> which it just did
12:07:02 <Veinor> haqe17: the problem is that myScanr f acc xs is a list
12:07:16 <Veinor> and so (myScanr f acc xs) : xs is trying to cons a list onto a list of the same type, which doesn't work
12:07:33 <Saizan> sfogarty: tail-calling is not enough to keep the stack use constant in a lazy language
12:08:08 <sfogarty> Saizan: evidently you are quite correct, because it popped the stack just the same.
12:08:13 <sfogarty> took longer though
12:08:37 <Saizan> sfogarty: yeah, because the recursion itself doesn't use stack, but reducing the accumulator later does
12:08:58 <Saizan> sfogarty: the solution is to be strict in the accumulator while recursing, so it gets reduced step-wise
12:09:53 <sfogarty> Saizan: Good to know. It's an example for a lecture, and I'd really rather not introduce strictness just yet, so I may have to figure out another way.
12:10:44 <Saizan> sfogarty: inc_n_x_times' n x = n `seq` .. would fix it, btw
12:11:13 <Mortchek> blist
12:11:23 <sfogarty> Let me write that down for when I /do/ introduce strictness :)
12:14:10 <sfogarty> so much for my lovely demonstration of why tail call is nifty :)
12:14:22 <haqe17> Veinor: ok, but can you help my define scanr recursively in the right way?
12:17:07 <Veinor> haqe17: do you know what an @-pattern is?
12:17:44 <haqe17> Veinor: no
12:18:06 <haqe17> Veinor: im going through the wiki tutorial, no such thing has been introduced yet
12:20:35 <Veinor> which tutorial? do you have a link?
12:21:34 <loreints> what does "fmap foo <$> bar" mean?
12:21:46 <loreints> I thought <$> was the infix fmap...
12:21:54 <haqe17> Veinor: http://en.wikibooks.org/wiki/Haskell/List_processing#Scans
12:22:06 <atriq> loreints, it means bar is a functor within a functor
12:22:26 <atriq> bar :: (Functor f, Functor g) => f (g a)
12:22:29 <fmap> > fmap (+1) <$> [[1,2,3],[4,5,6]]
12:22:30 <lambdabot>   [[2,3,4],[5,6,7]]
12:23:26 <Veinor> haqe17: ok, so myScanr f acc xs calculates the scanr of the list after processing the first value, right?
12:23:48 <Veinor> so what does the first element of myScanr f acc xs represent?
12:28:12 <jtza8> Saizan: True there's more than one form of polymorphism, just didn't fully understand Yiq. In the process I eschewed superfluous, esoteric vernacular. :P
12:28:39 <haqe17> Veinor: the first value would be    f x (foldr f acc xs)  i guess
12:29:17 <Veinor> right
12:33:19 <haqe17> Veinor: ah ok. so ive managed to write it myScanr using both recursion and foldr. Is it possible to do it using only one or the other, like the question asks?
12:33:35 * BMeph is tempted to say, "bar of Omens, give me functors beyond functors"...but he won't! ;)
12:33:46 <Veinor> yes; note that the first element of scanr f acc xs is equal to foldr f acc xs
12:35:10 <byorgey> edwardk: around?  I'm getting a compile failure with the latest version of 'lens' when building with GHC 7.6rc1 and TH-2.8
12:35:21 <haqe17> Veinor: you are saying use "head (myScanr f acc xs)"? but then I will get empty list issues
12:35:30 <edwardk> byorgey: hrmm, lens 2.4?
12:35:36 <BMeph> So, by Haskell's syntax rules, ((<|>) <*>) == ((<*>) (<|>)), right?
12:35:46 <otters> yes
12:35:54 <byorgey> edwardk: 2.4.0.2, yes
12:35:58 <edwardk> someone sent in patches to make it friendly to the new version of TH, but maybe they were buggy =(
12:36:05 <byorgey> edwardk: I can hpaste the error if you like
12:36:09 <edwardk> please
12:36:14 <Saizan> jtza8: you might need to tweak your "superflous esoteric" detectors when discussing a language built mostly around parametric polymorphism
12:36:33 <edwardk> this may make me shove 2.5 out the door faster than i'd planned
12:37:18 <Veinor> haqe17: no you won't, because scanr never returns an empty list :)
12:37:48 <byorgey> edwardk: hpaste.org/73582
12:37:54 <BMeph> jtza8: Welcome to #haskell, where we celebrate superfluous esoterica!
12:38:31 <haqe17> Veinor: ah yeah. ok. and for writing scanr in terms of foldr, without recursion?
12:38:44 <Saizan> BMeph: that's another point :)
12:38:55 <atriq> BMeph, is it bad that the only other channel I'm on a lot is #esoteric ?
12:39:08 <Veinor> haqe17: i'm not sure
12:39:24 <edwardk> byorgey: strange, because those were precisely what he patched in. i wonder if head changed TH 2.8 further?
12:39:25 <byorgey> edwardk: strange, the not in scope errors seem to be coming from stuff conditionally included ONLY when using TH-2.8
12:39:50 <BMeph> atriq: Bad, no, more apropos, I'd say.
12:39:51 <byorgey> edwardk: I'm using the RC, not HEAD
12:40:08 <byorgey> oh, but you think the patches are against HEAD?
12:40:11 <byorgey> could be
12:40:32 <atriq> BMeph, I actually found out about Haskell in #esoteric (which is technically a programming channel? maybe?)
12:40:32 <edwardk> byorgey: https://github.com/ekmett/lens/pull/22
12:40:38 <edwardk> was the original pull request
12:40:45 <edwardk> says something about ghc 7.6 branch snapshot
12:41:22 * BMeph imagines the glory of superfluous esoterica in contrapuntal stereo...
12:41:22 <edwardk> awkward because there isn't a good way to test for RC1 here
12:41:31 <byorgey> I see, interesting
12:41:46 <byorgey> OK, in that case I'll just wait for things to settle down a bit.
12:41:57 <atriq> BMeph, we're currently talking about some Muse/SBaHJ mishmash I made
12:42:03 <edwardk> kind of annoyed that there isn't a way for me to fix it nicely
12:42:03 <atriq> Well, I am
12:42:08 <atriq> Nobody else is
12:42:15 <Veinor> atriq: O_o
12:42:16 <BMeph> atriq: The Plan proceeds apace... ;)
12:42:16 <edwardk> i can comment the inline pragmas out until we get released i guess
12:42:45 <atriq> Veinor, BMeph, http://taneb.tumblr.com/post/30047991419
12:43:08 <byorgey> edwardk: if you like.  It really doesn't make a big difference to me personally.
12:43:23 <edwardk> well, not compiling anywhere i titularly should is a big deal to me
12:43:32 <jtza8> Saizan: True.
12:43:36 <edwardk> so i'll definitely patch it so you can compile
12:43:39 <jtza8> BMeph: Good to hear :)
12:43:46 <byorgey> edwardk: fair enough.
12:44:40 <byorgey> edwardk: well, ping me whenever you put up a new version, but no rush.
12:45:01 <edwardk> k, it'll probably be a few minutes before i figure out the right way to make it happy on all platforms
12:45:55 <byorgey> a few MINUTES??  I said "no rush", but come on, I don't have all day.
12:46:06 <byorgey> ;)
12:46:51 <armlesshobo> lol
12:48:48 <edwardk> i have it compiling locally. let me push it up. can you build off the repo for a while? i want to finish documenting the uniplate combinators before i push 2.5 out
12:50:31 <edwardk> byorgey: try pulling the master branch from github.com/ekmett/lens.git -- it should work for you
12:50:42 <edwardk> sorry it took me so long ;)
12:52:23 <byorgey> edwardk: ok =)
12:52:31 <byorgey> edwardk: no problem re: building off the repo
12:52:45 <zzing> Can I have a datatype that derives Read, and has a constructor like Setup that will convert string with (read "Setup") or (read "setup") appropriately?
12:52:53 <byorgey> I'm just testing stuff with the RC, and was looking into switching a dep from fclabels to lens
12:52:54 <edwardk> k. i'm going to see if there is a way i can detect RC1 and give you inline pragmas
12:54:13 <byorgey> zzing: if you derive Read, then (read "Setup") will work.  There's no way to get (read "setup") to work if you derive Read.
12:54:33 <byorgey> but if you want both of those then you don't really want Read anyway, you want a real parser.
12:55:13 <zzing> byorgey, is there a really simple parser available that I can learn to use in a few minutes?
12:55:32 <int80_h> huh hpaste didn't post my paste here
12:55:43 <int80_h> http://hpaste.org/73583
12:56:13 <int80_h> I found attoparsec to be accessible.
12:56:38 <zzing> THat requires bytestrings doesn't it?
12:56:57 <int80_h> I believe so
12:57:04 <zzing> Anything that works on Text?
12:57:08 <byorgey> attoparsec is for a specific purpose (parsing binary formats, network protocols, etc.)
12:57:19 <int80_h> ah
12:57:57 <byorgey> zzing: parsec is not that difficult to learn.  I doubt there is anything you could learn in just a few minutes.
12:58:17 <zzing> I suppose it is something I will have to learn eventually
12:58:31 <zzing> I am just doing a simple command line parsing
12:59:52 <zzing> Are the polyparse stuff any good? http://code.haskell.org/~malcolm/polyparse/docs/
13:01:02 <int80_h> byorgey: could I intice you to take a peek at my hpaste?
13:01:35 <byorgey> int80_h: your Ship type needs a constructor
13:01:47 <identity> http://d24w6bsrhbeh9d.cloudfront.net/photo/5137139_700b_v1.jpg <- The way I feel when optimizing some of my haskell code
13:02:45 <identity> eh, the "my" shouldn't be there.
13:02:47 <identity> fail. :(
13:02:54 <byorgey> int80_h: if you're saying you want the Ship *data type* to reflect the restrictions on certain values based on other values, forget it.
13:03:13 <byorgey> int80_h: you'd have to use something like Agda.  And I doubt it would be worth it.
13:03:21 <haqe17> Veinor: ok, well thanks anyway
13:03:44 <int80_h> byorgey: Well I want to limit what a Ship looks like, based on values if it's types.
13:03:49 <int80_h> of
13:03:54 <byorgey> int80_h: if I were you, I'd just write a function isValidShip :: Ship -> Bool, and then test to make sure that all my functions respected validity
13:04:29 <byorgey> int80_h: right. That's very difficult in Haskell.
13:04:33 <int80_h> ah! That's simple enough
13:05:01 <haqe17> Can anyone help me define scanr in terms of foldr?
13:05:10 <johnw> @src scanr
13:05:10 <lambdabot> scanr _ q0 []     =  [q0]
13:05:10 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
13:05:11 <lambdabot>     where qs@(q:_) = scanr f q0 xs
13:05:13 <johnw> @src foldr
13:05:13 <lambdabot> foldr f z []     = z
13:05:13 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:05:30 <path[l]> hi, can someone tell me why I'm facing a stack overflow when I'm using tail recursion here .http://hpaste.org/73585
13:06:07 <shachaf> The answer is strictness.
13:06:10 * shachaf looks at paste.
13:06:13 <path[l]> haha
13:06:15 <path[l]> I thought so
13:06:18 <byorgey> path[l]: http://www.haskell.org/haskellwiki/Stack_overflow
13:06:32 <shachaf> Yep.
13:06:38 <shachaf> Also your parentheses are probably wrong.
13:06:53 <path[l]> the (x-1) ?
13:07:00 <byorgey> the y*x
13:07:01 <srhb> No, the lack on the right hand side
13:07:09 <shachaf> "fac_int (x-1) y*x" = "(fac_int (x-1) y)*x"
13:07:24 <path[l]> ah the y*x
13:07:26 <path[l]> ok
13:07:31 <srhb> function application has highest precedence, so you're calling it with y as second argument
13:07:39 <path[l]> ah ok
13:08:16 <shachaf> As it happens, you'll still get the right result.
13:08:21 <shachaf> But it won't be tail-recursive.
13:08:22 <path[l]> haha yeah
13:08:24 <path[l]> that was it
13:08:25 <path[l]> thank you
13:09:23 <srhb> Why does it work now.. Because the binary ops are strict?
13:09:39 <srhb> Yes, that must be it.
13:09:48 <jfischoff> I'm trying to envision how to use to repa to multiply the alpha channel of a image with the other pixels. Here is my plan. I separate out the alpha channel as a separate array, and duplicate the alpha channel threefold. I then drop the alpha channel from the original array and combine them with traverse2. Does that seem reasonable?
13:09:51 <shachaf> srhb: What do you mean?
13:10:01 <johnw> haqe17: scanr (+) 5 [1,2,3] === foldr (\x acc -> x + head acc:acc) [5] [1,2,3]
13:10:11 <johnw> @pl (\x acc -> x + head acc:acc)
13:10:11 <lambdabot> join . ((:) .) . (. head) . (+)
13:10:17 <srhb> shachaf: I mean, the args must be forced between each call, right?
13:10:23 <srhb> Because otherwise the problem would still be there.
13:10:25 <shachaf> srhb: Why isn't.
13:10:27 <shachaf> Er.
13:10:29 <shachaf> y
13:10:31 <shachaf> :-(
13:10:44 * shachaf ought to leave this channel in shame now. Forever.
13:10:55 <srhb> ((x-1)-1)-1
13:10:58 <srhb> Is what I mean.
13:11:12 <shachaf> x is going to be forced, yes.
13:11:22 <srhb> Y not why?
13:11:25 <srhb> ;)
13:11:27 <shachaf> But the factorial-result thunk is still being built up.
13:11:41 <DT`> @pl (\x acc@(y:_) -> x+y:acc)
13:11:41 <lambdabot> (line 1, column 8):
13:11:41 <lambdabot> unexpected "@"
13:11:42 <lambdabot> expecting pattern or "->"
13:11:58 <DT`> huh.
13:12:10 <haqe17> johnw: can you explain that a bit for me? I havent got to @ notation yet
13:12:35 <johnw> ignore that part
13:12:41 <johnw> just look at the scanr/foldr equivalence
13:12:49 <johnw> I was just trying to optimize, and failed
13:12:59 <srhb> shachaf: I don't understand why there's any difference wrt. strictness of the two arguments. They both use binary arithmetic
13:13:07 <srhb> But I guess that's not the point?
13:13:24 <srhb> And both values are available in any given call.
13:13:39 <srhb> ie. not recursive.
13:14:46 <shachaf> srhb: fac_int 5 1 = fac_int 4 (1*5) = fac_int 3 ((1*5)*4) = ...
13:15:12 <shachaf> Eventually the result is a big (((((1*a)*b)*c)*d)*... thing
13:15:21 <shachaf> The stack overflow happens when evaluating that.
13:15:24 <srhb> But.. Why? Why does minus force but multiply not?
13:15:39 <shachaf> It's not the -
13:15:42 <srhb> Hm.
13:15:44 <haqe17> johnw: nah, cant get my head round that at all
13:15:45 <shachaf> It's pattern-matching to check if it's 0
13:15:56 <zzing> Is there anything good that can walk me through parsec? The documentation is out because I don't know where to start, the wiki doesn't give me anything that is generic, and the website looks like it was last updated in 2005.
13:15:58 <srhb> But they're strict
13:16:06 <srhb> I think you are lying to me.
13:16:16 <shachaf> srhb: They're strict, but so what?
13:16:17 <srhb> :-)
13:16:23 <johnw> haqe17: ok, let's look at it symbolically
13:16:25 <johnw> > scanr (+) a [b,c,d]
13:16:26 <lambdabot>   [b + (c + (d + a)),c + (d + a),d + a,a]
13:16:30 <srhb> Well.. Even pattern matching ON the x needs to force it all the way through, right?
13:16:35 <srhb> Or the y for that matter
13:16:42 <srhb> There's no outer lazy constructor, is there?
13:16:55 <johnw> so, you are folding here, but you're "saving" each step of the fold
13:16:55 <srhb> I may be using the wrong terminology here, please correct me.
13:16:56 <shachaf> Constructor?
13:17:07 <srhb> I guess I should be thinking thunks.
13:17:13 <shachaf> No need to think thunks.
13:17:19 <johnw> so all I had to do is to write a foldr call that saves the intermediate steps
13:17:19 <shachaf> Just ask monochrom.
13:17:26 <srhb> Oh :P
13:17:36 <shachaf> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
13:17:37 <johnw> but to do that, I can't start with an integer as my accumulator; I have to start with a list containing the first "step"; [5]
13:17:43 <shachaf> Cale posted that picture yesterday.
13:17:44 <johnw> > foldr (\x acc -> x + head acc:acc) [a] [b,c,d]
13:17:45 <lambdabot>   [b + (c + (d + a)),c + (d + a),d + a,a]
13:17:47 <Yiq> > scanl (+) 0 [1..5]
13:17:48 <lambdabot>   [0,1,3,6,10,15]
13:17:57 <Yiq> @src scanl
13:17:57 <lambdabot> scanl f q ls = q : case ls of
13:17:57 <lambdabot>     []   -> []
13:17:57 <lambdabot>     x:xs -> scanl f (f q x) xs
13:18:07 <shachaf> srhb: That picture happens to be a factorial function!
13:18:11 <shachaf> It's not tail-recursive, though.
13:18:43 <johnw> haqe17: at this point I will recommend reading up on scanr and foldr again, and how they work
13:18:58 <Yiq> > scanl (*) 1 [1..10]
13:18:59 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800]
13:19:51 <srhb> but there, the call in order to evaluate the right hand side of * is recursive
13:20:02 <srhb> shachaf: So therefore it builds up a huge expression, I understand that.
13:20:17 <srhb> But that's not the case here.
13:20:38 <haqe17> johnw: im reading now. but im too newb to understand this
13:20:43 <srhb> path[l]: Please don't assume your factorial is fixed just because it runs in ghci :P
13:20:44 <shachaf> srhb: The case here is that it still builds up a huge expression.
13:20:45 <Yiq> q
13:20:45 <Yiq> can u see me?
13:20:46 <johnw> haqe17: it'll come, don't worry
13:20:48 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml . no thunks. same conclusions.
13:20:53 <johnw> I'm only like one step ahead of your newbness, trust me
13:20:57 <path[l]> srhb: oh?
13:21:04 <shachaf> srhb: fac_int finishes its entire computation and returns to you a value.
13:21:07 <path[l]> srhb: whats wrong with it after I add the brackets?
13:21:14 <johnw> these guys are here are still mostly speaking in a language that only vaguely resembles english
13:21:15 <srhb> path[l]: The right hand argument is not forced, so it does blow up still
13:21:16 <shachaf> srhb: When you try to *look* at that value, your stack overflows.
13:21:58 <srhb> shachaf: I don't understand why it isn't forced, but ok, I can accept that. It would be sufficient to y `seq` ... then, right? Since x is already forced from the first pattern match of 0
13:22:36 <shachaf> srhb: Right, or match on "!y"
13:23:08 <path[l]> bangpatterns, I never really got into that, but thanks. I'll have to look into it
13:23:13 <srhb> Yes, right. The thing that was confusing, or is confusing me, is that I assumed that with no lazy constructor in whnf, there was no NOT forcing an argument
13:23:21 <shachaf> srhb: But you should understand what's happening -- it's important for your intuition of how Haskell is evaluated.
13:23:24 <Yiq> > scanr (*) 1 [1..10]
13:23:25 <lambdabot>   [3628800,3628800,1814400,604800,151200,30240,5040,720,90,10,1]
13:23:31 <srhb> path[l]: You don't need them. you can start your last line with y `seq` ... your code
13:23:38 <srhb> path[l]: But bang patterns are nicer
13:23:45 <path[l]> ah yes, thats true
13:23:47 <srhb> shachaf: Yes, I want to :P
13:23:58 <srhb> path[l]: And I hope you followed my confusion if you didn't understand what's going on :D
13:24:09 <path[l]> yeah I get it now :)
13:24:14 <path[l]> the thing is Im trying to come up with a simple example of tail recursion
13:24:27 <srhb> It's not really the right language for that, really.
13:24:32 <srhb> But sure, that's what you're showing now
13:24:33 <path[l]> to explain to people how haskell can substitute recursion for iteration
13:24:42 <shachaf> path[l]: "tail recursion" works very differently in Haskell from in other languages.
13:24:48 <srhb> Usually you just need something lazy, like building a list lazily, path[l]
13:24:53 <shachaf> path[l]: In particular, very often you *don't* want functions to be tail-recursive.
13:24:56 <srhb> tail recursion is more of a strict phenomenon
13:24:58 <path[l]> well I'm using haskell as an example of fp
13:25:02 <srhb> So you have to jump through hoops here.
13:25:07 <path[l]> ah
13:25:10 <srhb> ie. seq or bangpatterns
13:25:26 <path[l]> I was thinking of running through factorial example, with a bad implementationand then switching to that
13:25:32 <Cale> "tail call optimisation" is something which applies to strict evaluators which have a concept of a call stack
13:25:33 <srhb> otherwise the laziness gets in your way and blows up the stack. Mind, as you see, it's entirely possible to do so.
13:25:41 <Cale> The evaluator that GHC uses doesn't have a call stack
13:25:45 <path[l]> if I write a naive factorial though
13:25:47 <path[l]> it blows up
13:25:52 <Cale> So it doesn't really make sense to talk about TCO exactly
13:26:02 <Cale> The stack in GHC's evaluator is a pattern match stack
13:26:04 <path[l]> like if I do fac n = n* fac(n-1)
13:26:31 <srhb> Yes, * is strict in both argument so it needs the rightmost result before it can evaluate anything
13:26:58 <zzing> Can anyone offer some suggestions on where I might begin parsing this command line where I have something like "create main" and it would produce a Create String but I could have something like "use main" and it would produce a Use String, or something like "setup" which produces Setup. They are all parse of the same option type,but I cannot figure out how to reason this stuff and I have never used Parsec before.
13:27:15 <srhb> Making fac, strangely enough, a bad example of FP for Haskell. :P
13:27:28 <srhb> Because arithmetic stuff generally is strict, you jump through hoops.
13:27:45 <srhb> ( path[l] also you have to see this if you haven't already: http://www.willamette.edu/~fruehr/haskell/evolution.html )
13:28:04 <path[l]> fair enough, I think I'll just skip this whole topic then
13:28:08 <shachaf> srhb: Do you understand fac_int 5 1 = fac_int 4 (1*5) = fac_int 3 ((1*5)*4) = fac_int 2 (((1*5)*4)*3) = fac_int 1 ((((1*5)*4)*3)*2) = fac_int 0 (((((1*5)*4)*3)*2)*1) = (((((1*5)*4)*3)*2)*1)?
13:28:16 <path[l]> it's probably going out of the scope for the session
13:28:19 * shachaf should've picked a smaller number than 5. Ah, well.
13:28:40 <paolino> zzing, Create and use are constructors of same datatype ?
13:28:43 <srhb> shachaf: Yes, but only because you've told me so, I don't understand why y is not "examined" or how shall we call it.
13:28:49 <zzing> paolino, yes
13:28:52 <srhb> path[l]: Build trees :-)
13:29:11 <jfischoff> should I use slice to drop a column or a row in repa?
13:29:33 <path[l]> hehe
13:29:35 <srhb> shachaf: My intuition had been that say a List would not, because it only reaches the leftmost : and then says "Ah, I don't need to go further!"
13:29:44 <srhb> shachaf: But here there's nothing lazy to get "stuck" on.
13:29:44 <shachaf> srhb: Who's examining it?
13:29:57 <srhb> The pattern match.
13:30:15 <paolino> zzing, so you want to make a value of type Parser CreateUseSetup
13:30:51 <shachaf> srhb: Which pattern match?
13:30:55 <srhb> shachaf: y
13:30:59 <zzing> paolino, I would word it more generally in that I want a function String -> CreateUseSetup
13:31:06 <shachaf> > let f y = 5 in f undefined
13:31:07 <lambdabot>   5
13:31:23 <srhb> Point taken.
13:31:28 <paolino> zzing, that is when you "run" your parser
13:31:33 <srhb> And I already knew that. I don't know why I didn't transfer that knowledge
13:31:35 * srhb facepalms
13:31:44 <srhb> shachaf: Thanks for pulling me back to Earth. :P
13:31:45 <zzing> paolino, in that case, it would be yes
13:31:48 <shachaf> srhb: There's nothing particularly magical about constructors as opposed to functions.
13:31:52 <paolino> zzing, not when you build it
13:32:54 <zzing> shachaf, I consider the use of the shift key to be a sort of magical thing
13:33:54 <paolino> zzing, these are your combinators http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Combinator.html
13:34:10 <paolino> to build a Parser CreateUseSetup
13:34:58 <zzing> paolino, am I correct in my assumption that I need to do the choice between the list of different possibilities?
13:35:35 <paolino> yes, I think so
13:36:05 <paolino> to parse a word you need also http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Char.html
13:36:28 <zzing> paolino, by using ParsecT, does this prevent use of an applicative style? I have been reading some references to it, and curious but haven't found anything really about it
13:36:57 <srhb> Time to sleep, thanks for making me smarter again today #haskell, and shachaf ;)
13:37:35 <paolino> zzing, ParsecT is a monad so you go with monadic style I suppose
13:38:13 <paolino> you can use applicative combinators inside it
13:38:50 <paolino> well, functors
13:39:38 <zzing> Can I do something like do { string "setup"; return Setup; }
13:39:55 <paolino> that is one of them
13:40:37 <zzing> how do I run it
13:40:56 <zzing> assuming I have a Parser a
13:42:45 <yhager> any haskell recommended textbooks? I've been programming for two decades.. but nothing functional so far..
13:42:58 <paolino> zzing, parseTest seems easy
13:43:07 <paolino> in Prim module
13:43:11 <zzing> Is that what I would use in a real progrm?
13:43:21 <paolino> no
13:43:33 <hpc> @where lyah
13:43:33 <lambdabot> http://www.learnyouahaskell.com/
13:43:36 <hpc> yhager: ^
13:44:18 <paolino> zzing, runParser or runParserT if you have another monad inside
13:44:21 <zzing> hmm, it doesn't like this: http://hpaste.org/73588
13:44:45 <acowley> yhager: another popular text is http://www.amazon.com/Introduction-Functional-Programming-Haskell-Edition/dp/0134843460
13:45:01 <acowley> yhager: but LYAH is pretty great for just diving into things
13:45:09 <yhager> hpc: the contents look good in lyah. thanks
13:45:17 <hpc> LYAH also has a great intro
13:45:26 <hpc> and introduces things in just the right order
13:45:51 <paolino> zzing, try giving it a signature
13:46:01 <yhager> acowley: how would you describe the difference between these two books?
13:46:24 <FireFly> Speaking of LYAH, it mentions System.Random in a chapter, but it seems that module isn't provided by default by recent versions of GHC.
13:46:27 <acowley> yhager: I've not read the Bird book, but I imagine the most immediate difference is just how informal LYAH is
13:46:49 <acowley> yhager: The Bird book is something to consider if LYAH just annoys you too much :)
13:46:58 <paolino> zzing, () for s0 and Identity for m0
13:47:05 <paolino> my guess
13:47:10 <yhager> informal can be nice, but if it's over-done it can be annoying
13:48:16 <zzing> @hoogle Identity
13:48:16 <lambdabot> Control.Monad.Identity module Control.Monad.Identity
13:48:17 <lambdabot> Control.Monad.Trans.Identity module Control.Monad.Trans.Identity
13:48:17 <lambdabot> Data.Functor.Identity module Data.Functor.Identity
13:49:14 <acowley> Mind you, even informal Haskell is usually pretty jargon heavy for someone new to zygohistomorphicprepromorphisms
13:50:03 <zzing> paolino, can I get away with a type declaration for just the main function?
13:50:07 <paolino> zzing, Parsec () DataOfSetupAndNoOperation also
13:50:25 <yhager> so lyah is the first recommendation then..
13:50:48 <paolino> Parsec fix the monad to Identity
13:51:08 <zzing> Expecting one more argument to `Parsec () Operation'
13:52:03 <acowley> yhager: Yes, LYAH is the most popular recommendation these days. There is also almost always someone in #haskell willing to help as you learn.
13:52:34 <paolino> zzing, Parser Char () Operation
13:52:47 <yhager> okay, great. I will definitely come here for advice, but I'd like to have a fine textbook too (and support the author)
13:53:50 <acowley> yhager: Yeah, so try out LYAH for free on the web. If it's working, buy a copy, if it's driving you mad, try Bird's book or Huttons (http://www.cs.nott.ac.uk/~gmh/book.html)
13:54:12 <yhager> acowley: perfect. Thanks!
13:54:41 <zzing> paolino, if I try something like in my annotation: http://hpaste.org/73590  to simplify it, do you know how to fix this so there is no error?
13:57:29 <paolino> zzing , a bit late to me, I think it has to be Stream String Identity Char
13:58:07 <edwardk> i'm really tempted to replace the 'editable' contexts from uniplate with store comonads.
13:58:08 <zzing> paolino, I am not exactly sure what is supposed to be that stream
13:58:22 <edwardk> would anyone cry if lens picked up a dependency on Comonad?
13:58:25 <edwardk> er comonad?
13:58:43 <paolino> zzing, try Parsec String () Operation
13:59:05 <atriq> edwardk, on a fresh Haskell install, comonad is the first thing I cabal
13:59:18 <zzing> paolino, no progress
13:59:26 <edwardk> atriq: well, if you want to get it in the platform now is the time to do those proposals =P
13:59:28 <acowley> edwardk: No, go for it. Let the revolution sweep over the entire landscape!
13:59:35 <edwardk> sweet
13:59:38 <edwardk> comonads are going in
13:59:53 <edwardk> then i can stop using one off combinators for extract, etc for Kleene, etc.
14:00:08 <roconnor> edwardk: isn't Kleene an indexed comonad?
14:00:18 <zzing> Is there any kind of a blog post that has covered this kind of stuff, it seems like it would be common to me
14:00:22 <edwardk> yes, but i can do instance (c ~ d) => Comonad (Kleene c d)   =)
14:00:46 <edwardk> that does the right thing, forces the constraint on equality whenever you extract, etc.
14:00:46 <roconnor> >.>
14:00:53 <roconnor> ok
14:01:04 <edwardk> so it doesn't have the type inference problems you get when you use instance Comonad (Kleene c c)
14:01:10 * roconnor needs to use >.> more in Haskell
14:01:21 <nh2> is it correct that GHC automatically closes my stderr handle even before the process finishes? It introduces crazy bugs
14:01:39 <edwardk> in that case i'm going to just rename "IndexedStore" to "Store"
14:01:52 <roconnor> edwardk: isn't Store already in Comonad?
14:01:57 <edwardk> yes
14:02:09 <edwardk> but i don't export "IndexedStore" except via Control.Lens.Internal
14:02:10 <nh2> cannot we impose the restriction that the handles may only be closed once the process has shut down?
14:02:14 <edwardk> and Store is in comonad-transformers
14:02:28 <edwardk> which i wasn't adding a dep on
14:02:33 <roconnor> ah
14:03:43 <paolino> zzing, same error ?
14:04:35 <zzing> paolino, got something
14:04:39 <paolino> zzing, here parseTest (return () :: Parsec String () ()) "()" runs fine in ghci
14:04:45 <zzing> parseArgs :: Stream s m Char => Parsec String s Operation
14:04:55 <zzing> That compiles
14:05:56 <zzing> Although then using parseTest parseArgs "setup"  gives an error No instance for (Stream () m0 Char)
14:06:06 <paolino> ah, that is right
14:06:36 <paolino> you mixed the stream type with the state in the signature
14:07:17 <paolino> its Stream String Identity Char => Parsec String () Operation
14:07:55 <zzing> How does that Stream have any effect then?
14:08:29 <paolino> it's promising the instance exists to the typechecker
14:08:37 <zzing> ok
14:08:46 <zzing> I have a problem I have to fix with my installed stuff
14:09:30 <paolino> can you run parseTest (return () :: Parsec String () ()) "()" ?
14:10:09 <zzing> No instance for (Stream String Data.Functor.Identity.Identity t0)
14:10:46 <paolino> which modules you imported ?
14:11:35 <paolino> Text.Parsec should suffice
14:11:48 <zzing> in that case it works
14:12:05 <zzing> Have to reinstall cabal-install do to an error i had
14:13:12 <nh2> I have an example here, can somebody try this out? http://hpaste.org/73591
14:13:36 <nh2> this _always_ gives me ExitSuccess although the application clearly returns 2
14:17:42 <paolino> nh2, maybe it has to do with lazyness, without actually evaluating program output nothing happens and your program exit with success
14:18:27 <zzing> paolino, presently, it seems to work now that I have my cabal fixed
14:18:28 <nh2> paolino: however you run the c program, it *must* exit with with code 2 (it has no choice)
14:18:49 <zzing> Thank you very much
14:18:57 <nh2> if you run it in the terminal, it also does it reliably
14:19:23 <nh2> paolino: like: ./test; echo $?
14:19:33 <paolino> zzing, you are welcome
14:20:23 <zzing> It appears that string "setup" parses anything, unless I am doing something really wrong
14:20:48 <zzing> it doesn't when I test it otherwise
14:21:19 <zzing> Parsec seems complicated in its own right, and not a lot of documentation
14:22:09 <loreints> can someone help me add a function to print out text in the middle of this function? http://hpaste.org/73592
14:22:23 <loreints> ideally I'd like to not use do notation because I'd like to become more familiar with bind
14:23:00 <zzing> ok, more specifically, it parses it but doesn't care about afterwards
14:23:42 <paolino> loreints, look at the Debug module
14:23:57 <nexion> is haskell commonly used for writing web apps? I'm looking for libraries that would allow me to focus on writing the web app instead of dealing with the low level HTTP stuff, but at the same time give me flexibility to organize stuff my way
14:24:16 <paolino> zzing, paste the code
14:24:23 <nexion> basically node.js + the app, but being a single compiled haskell app
14:25:05 <paolino> @hoogle trace
14:25:05 <lambdabot> Debug.Trace module Debug.Trace
14:25:05 <lambdabot> Debug.Trace trace :: String -> a -> a
14:25:05 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
14:25:24 <zzing> http://hpaste.org/73594
14:25:45 <zzing> import FromHell.Debug.Trace
14:26:34 <paolino> zzing, probably spaces is many space
14:26:40 <paolino> not many1
14:27:09 <zzing> paolino, what I really want is for the thing to have as input "setup" and then whitespace or the end
14:27:31 <monochrom> "Skips zero or more white space characters". the "zero" is even in italics
14:27:54 <dmwit> nh2: weird
14:28:09 <zzing> monochrom, my bad
14:28:16 <nh2> dMazz: that really just looks wrong
14:29:10 <dmwit> nh2: I can't reproduce your claim. Mine prints Just (ExitFailure 2).
14:29:28 <monochrom> there is "eof" if you want to assure "the end"
14:29:35 <dmwit> nh2: (Though of course the Haskell program exits with ExitSuccess.)
14:29:36 <nh2> dmwit: what really? that is strange
14:30:12 <nh2> dmwit: I mean you have to comment the prints away to get the problem
14:30:19 <nh2> dmwit: http://hpaste.org/73593
14:30:30 <zzing> monochrom, I could write a version of eof that will make sure it is not followed by anything of consequence
14:30:31 <monochrom> however, I would not attempt "at least 1 space, or the end". that way of setting up your grammar makes life harder
14:30:53 <nh2> dmwit: does that also give you ExitFailure 2?
14:31:25 <dmwit> yes
14:31:56 <zzing> monochrom, I could clean the input so it didn't have trailing spaces and it would fix my problem and allow me to use eof
14:32:16 <monochrom> I do not have that in mind either
14:32:28 <nh2> dmwit: WTH. I only have the problem when compiled with clang
14:32:45 <nh2> dmwit: do you have a clang to test?
14:32:56 <zzing> monochrom, how would you accept "setup" but not "setupw"
14:32:59 <zzing> but not care about "setup "
14:33:16 <zzing> (or rather accept "setup " as you would "setup")
14:33:32 <dmwit> I don't.
14:33:52 <paolino> string "setup " <|> string "setup"
14:34:22 <monochrom> parse a whole word (many1 letter), then eat trailing spaces (unconditionally). now check that word. is it "setup"?
14:35:05 <monochrom> if you say, "but if the word is setupw, I want to backtrack", then use "try" and "<|>"
14:35:47 <zzing> How do you eat trailing spaces?
14:35:57 <monochrom> call "spaces"
14:36:43 <monochrom> get_setup = do { w <- many1 letter; spaces; if w=="setup" then ??? else ??? }
14:36:44 <nh2> dmwit: no one second, that's not correct, probably I just skipped a compile. Independent of the compiler, it always returns ExitSuccess
14:36:55 <zzing> I think the simplest, do { string "setup"; spaces; eof; return Setup; } does exactly what I need
14:37:19 <zzing> Is there an applicative version of this?
14:37:42 <hpc> :t (*>) -- zzing
14:37:44 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
14:37:46 <zzing> I have heard of about applicative parsec mentioned, but I haven't been able to find much on it
14:37:48 <hpc> :t (>>) -- zzing
14:37:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:37:58 <hpc> @undo do { string "setup"; spaces; eof; return Setup; }
14:37:58 <lambdabot> string "setup" >> spaces >> eof >> return Setup
14:38:15 <hpc> string "setup" *> spaces *> eof *> return Setup
14:38:15 <zzing> But isn't >> a monad?
14:38:52 <hpc> zzing: for all monads that follow the laws, (>>) = (*>)
14:38:58 <dmwit> nh2: Are all your buffers definitely saved? Are you definitely overwriting the executable that test.hs is actually calling when you compile? Is your C compiler definitely doing work and not just thinking everything has already been done? etc.
14:39:01 <zzing> ok, I get what iyou mean
14:39:03 <zzing> Now if I needed to parse a string and use that version later, can that be done applicatively later?
14:39:10 <hpc> yeah
14:39:28 <dmwit> nh2: Quick check is to delete "test" and see if it still says ExitSuccess... =P
14:40:42 <zzing> hpc, is that done by passing it through some how/
14:40:52 <hpc> @src (*>)
14:40:52 <lambdabot> (*>) = liftA2 (const id)
14:41:21 <zzing> :t intercalcate
14:41:22 <lambdabot> Not in scope: `intercalcate'
14:41:26 <zzing> :t intercalate
14:41:27 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:41:27 <hpc> :t intercalate
14:41:28 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:41:54 <zzing> > intercalate " " ["create", "5"]
14:41:55 <lambdabot>   "create 5"
14:42:00 <path[l]> hey guys, do you know where I can find some good classroom problems for haskell. Basically stuff that forces people to use recursive functions, folds and so on
14:42:02 <path[l]> simple stuff
14:42:12 <path[l]> for people who are just understanding the paradigmn
14:42:16 <hpc> path[l]: the wikibook has some good ones
14:42:19 <hpc> @where wikibook
14:42:19 <lambdabot> http://en.wikibooks.org/wiki/Haskell
14:42:22 <paolino> eulers
14:42:30 <shachaf> paolino: No. :-(
14:42:36 <hpc> LYAH and RWH have a few scattered throughout
14:42:36 <paolino> no
14:42:45 <NegativeK> Project Eulers is no good for Haskell?
14:42:51 <hpc> there's also 99 problems
14:42:54 <hpc> @where 99_problems
14:42:54 <path[l]> thank you
14:42:54 <lambdabot> I know nothing about 99_problems.
14:43:06 <hpc> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
14:43:11 <Apocalisp> @where your problems
14:43:11 <lambdabot> I know nothing about your.
14:43:18 <Apocalisp> bah
14:43:23 <Peaker> @hoogle Map (Maybe a) b  -> Map a b
14:43:23 <lambdabot> No results found
14:43:24 <monochrom> just ask students to sum up a list
14:43:38 <Peaker> none of the functions in Map seem nice for this
14:43:59 <path[l]> hah, 99 problems seems like a nice resource
14:44:06 <Peaker> (toList -> some filter -> fromList) seems to be the only safe way?
14:44:14 <zzing> Is there any version of parsec operating on the Text type? I am using Shelly, and it looks like it loves Text
14:44:39 <monochrom> yes, my parsec has Text modules
14:44:50 <paolino> zzing, there are instances for Stream Text m Char
14:44:53 <mm_freak_> NegativeK: PE is unfortunate…  it teaches you only a very small amount of haskell…  in particular it doesn't help you write actual programs
14:45:06 <NegativeK> Ahh, that's true.
14:45:11 <hpc> PE is the best-disguised course in number theory ever
14:45:28 <monochrom> numerology
14:45:36 <NegativeK> I've been using it as clearly defined bite-size chunks to just start _using_ Haskell.
14:45:40 * zzing reads everyone's sign
14:45:55 <mm_freak_> PE is more for math, not really for programming…  if you have done your homework you shouldn't have to write much code
14:46:46 <dmwit> nh2: Going AFK now. Let me know when you work out what it was. =)
14:46:50 <monochrom> PE is a benchmark for slow brute-force algorithms
14:47:38 <NegativeK> So.. My Collatz failure last night that ate gigs of swap can be blamed on not doing my homework? That's actually pretty fair. ;)
14:47:49 <paolino> learning should also be fun, and eulers were fun for me. But I'm not a teacher
14:48:30 <monochrom> numerology is not fun for me
14:48:57 <mm_freak_> as a beginner i always recommend adding this to your shell profile:  export GHCRTS="-M512m"
14:49:00 <mm_freak_> =)
14:50:07 <NegativeK> mm_freak_:  Noted!
14:50:25 <paolino> monochrom, it's not all learners have to reach your knowledge in one month
14:50:43 <monochrom> that leads to "Most RTS options are disabled. Link with -rtsopts to enable them." if you compile your own *.hs files to exe's and run them
14:50:57 <zzing> export GHCRTS="-M32g" :-)
14:51:31 <monochrom> paolino, I carefully added "for me" for political correctness already
14:52:31 <hpc> -M is the heap flag?
14:52:36 <hpc> i thought that expanded on its own
14:52:54 <monochrom> also, I doubt that "numerology is not fun" depends on knowledge
14:55:47 <paolino> Numerology seems enough simple to most programmers
14:56:58 <monochrom> you were talking about "fun"
14:58:00 <zzing> @hoogle unlines
14:58:00 <lambdabot> Prelude unlines :: [String] -> String
14:58:00 <lambdabot> Data.List unlines :: [String] -> String
14:58:00 <lambdabot> Data.String unlines :: [String] -> String
14:58:31 <paolino> yep, and having some results in anything is the base of fun in anything
15:00:11 <zzing> Can anyone suggest any improvements to this code? It is supposed to parse the command line arguments right now into an Operation type that will be expanded to incude other options: http://hpaste.org/73595
15:00:40 <paolino> monochrom, I hope I have some results in agda before I die, but it's not foreseeable now
15:02:17 <monochrom> you were talking about "fun". so I just said what is not fun for me. there are many things one can get results within reasonable effort, some of them are fun to one and some of them are not fun to one. I get results fine with numerology too, but it is still not fun for me. there are other easy things I find fun
15:03:04 <paolino> ok, np
15:04:34 <zzing> monochrom, are you talking about this numerology? http://en.wikipedia.org/wiki/Numerology
15:04:53 <monochrom> I think you are just enumerating adjectives that are true of numerology until you find one that can paint me as a conceited arrogant cold-blooded jerk. if "fun" doesn't work, then you try "doesn't have a lot of prerequisites". if that doesn't work, then you try "get results quickly". if that doesn't work, you will try "does not need agda"
15:05:13 <monochrom> so let me confess to you that I don't understand agda
15:06:04 <paolino> never wanted, sorry
15:08:05 * hackagebot hcron 0.0.0.3 - A simple job scheduler, which just runs some IO action at a given time.  http://hackage.haskell.org/package/hcron-0.0.0.3 (TimoHuebel)
15:11:11 <paolino> monochrom, my point is about usefulness of PE only. And my respect goes to all nice people teaching here which probably disagree with my opinion.
15:17:55 <zzing> :t (*>)
15:17:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
15:18:07 <zzing> :t (<*)
15:18:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
15:18:18 <zzing> :t (>>=)
15:18:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:18:49 <monochrom> (<*) is not flip (*>), beware
15:19:16 <Veinor> monochrom: it's not?
15:19:37 <Veinor> the shapes lied to me :(
15:20:17 <monochrom> attempt putStrLn "hi" <* putStrLn "hello"
15:20:25 <shachaf> <**> is not flip <*>
15:20:28 <shachaf> BEWARE!
15:20:44 <Luke> Veinor: (<*) is run a then b then take a's result. (*>) is run a then b then take b's result. flip (*>) would run b then a then take a's result
15:20:58 <zzing> I have a function that gives me a Text that is in the middle of a parser (specifically, string "create" *> many1 space *> many1 letter  ) and I then need to pass it on to pure $ Create result  where result is the return from many1 letter. Can I do this in applicative?
15:21:03 <Veinor> ahh
15:21:14 <Luke> there's a sequencing aspect
15:21:19 <Luke> not just the return type
15:21:36 <ion> zzing: Create <$> (string "Create" *> many1 space *> many1 letter)
15:21:51 <zzing> oh dear, I never thought of that
15:23:10 <zzing> could I also do Create <$> (string "Create" *> many1 space *> many1 letter <* eof)
15:23:33 <monochrom> yes
15:23:45 <zzing> or something where I can have   many1 letter <* (spaces <* eof)
15:23:59 <monochrom> not sure about parenthesizing, but can be done
15:24:16 <zzing> Have I finally discovered the usefulness of applicative?
15:24:23 <monochrom> I think so
15:24:55 <zzing> Now what about this one: string "setup" *> spaces *> eof *> pure Setup     Setup doesn't take anything, it just needs it to parse
15:24:59 <zzing> Can that be improved?
15:25:44 <hpc> i think (endsWith spaces) would work
15:25:52 <hpc> maybe
15:25:58 <loreints> I'm having a lot of trouble trying to use trace; I can't tell if it's because of a basic misunderstanding of haskell or something weirder; here are my 2 attempts: http://hpaste.org/73596 and http://hpaste.org/73597
15:26:04 <hpc> but it's pretty good as-is
15:26:42 <c_wraith> loreints: if you're in IO already, just use print
15:26:50 <c_wraith> loreints: trace is for when you're not in IO
15:27:19 <monochrom> what is "head x" doing there?
15:27:48 <hpc> trace is something you use when you have code written already, and want to sneak some debug prints into it
15:28:00 <monochrom> your error is that, if you did not use trace, you would have "head x" on its own line, which would be absurd to begin with
15:31:18 <ion> zzing: “something *> pure Setup” should work, but i’d use “Setup <$ something”
15:31:27 <ion> Whoops, he left.
15:31:35 <zzing> ion, not quite :p
15:32:23 <zzing> ion, that does not compile
15:32:35 <zzing> Couldn't match expected type `Operation' with actual type `()'
15:32:46 <zzing> :t (<$)
15:32:47 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
15:33:00 <ion> Duh, WeeChat’s join/part/quit filter displayed your quit line based on you having spoken recently, but didn’t show the join line of the totally different person zzing_. :-)
15:33:59 <zzing>     Expected type: ParsecT Text () Identity Operation           Actual type: ParsecT Text () Identity ()
15:34:05 <zzing> I don't understand how this figures it
15:34:30 <monochrom> should work. perhaps the context breaks it
15:35:00 <zzing> bracket issue
15:35:34 <zzing> Now one issue I am having is that many1 returns [a] but I am using this on Text
15:35:41 <zzing> Everytihng worked until that point
15:36:27 <c_wraith> so, many1 returns [Char], and you want to convert it to Text?  isn't that what pack is for?
15:37:35 <zzing> c_wraith, not quite what I mean. The stream type I have been using has been Text, and everything that I got back was text as far as I can tell
15:37:55 <c_wraith> Oh, so you're getting [Text] back, then?  mconcat
15:38:31 <loreints> I'm still having a hard time trying to figure out how to "extract" values from monad wrapped instances (hope that makes sense), is there a good tutorial filled with examples about that? LYAH and RWH aren't really helping me grasp it
15:38:52 <c_wraith> loreints: you're having a hard time because it's not an operation that's part of the Monad interface
15:39:00 <c_wraith> loreints: meaning there is no generic way to do it.
15:39:40 <typoclass> loreints: you mean "<-" ?
15:42:28 <loreints> typoclass: I guess...
15:42:36 <loreints> c_wraith: why isn't it a generic method?
15:43:09 <monochrom> hmm, let me see if there is something better than "many1 letter" for Text
15:44:08 <c_wraith> loreints: requiring the ability to remove things would prevent many things from being instances of Monad.  Things like lists and Maybe, for instance.
15:44:56 <hpc> loreints: incidentally, there's a thing called Comonad that does have an extract operation
15:45:01 <c_wraith> loreints: however, you can compose things together with monads in a way that makes it kind of seem like you're getting a value out.  That's actually the entire point of monads.
15:45:10 <monochrom> if you are looking for a specific word, string "setup" works for Text too. but if you are looking for an unknown word, I don't know
15:45:12 <typoclass> loreints: do you have any code that is giving you trouble? i think this is much easier to discuss concretely
15:45:43 <monochrom> please don't extract values from monadic actions
15:47:33 <monochrom> use control inversion. "m >>= f" means "m >>=" takes f as a callback. when the value is ready, f will be called with that value as parameter. now you are the author of f, so now you have access to the value in f. don't call us, we'll call you
15:47:55 <monochrom> you see this never needs "extract". just invert control
15:49:36 <monochrom> just like in SAX parsers you do not ask "how do I extract nodes". no no, you don't extract, they will call your callback
15:52:32 <sdb_> if I am looking to find the n_th coefficient of a generating function say (1+x+x^2+x^3+x^4+...+x^200)(1+x^5+x^10+...+x^200)(1+x^10+x^20+..x^200) .. is there a straight forward way of solving that with haskell?
15:52:46 <sdb_> or am I barking up the wrong tree here
15:53:55 <johnw> am I right in thinking that fix as a data type is the same thing as the Free Monad, only without a Pure termination value?
15:54:07 <hpc> johnw: probably
15:54:10 * hpc looks it up
15:54:29 <johnw> data Free f = Free (f (Free f)) | Pure f
15:54:31 <monochrom> I think you can use haskell. use a lazy list to stnd for a polynomial (or power series), e.g., 1 + 2x + 5x^2 is [1, 2, 5]. writing multiplication algorithms for them. then you can just use (p*q)!!4 to ask for the x^4 coefficient of p*q
15:54:35 <johnw> data Fix f = Fix (f (Fix f))
15:54:36 <hpc> johnw: yeah, you are exactly right
15:54:37 <johnw> looks like it
15:54:41 <hpc> good catch
15:54:42 <johnw> that's very interesting
15:54:48 <nh2> dmwit: no success yet
15:55:01 <sdb_> ok thanks monochrom I was just reading up on polynomials in haskell.. under "Blow your mind" lol
15:55:14 <monochrom> Doug McIlroy has written most of the code. http://www.cs.dartmouth.edu/~doug/powser.html
15:55:22 <sixthgear> lambdabot was accidentally kicked from our channel a week ago and she has yet to rejoin ;_; can anyone help me convince her?
15:55:36 <johnw> i had written some code last year using "fix", and have since forgotten what fix is and does, and now I cannot for the life of me figure out what my code is doing and how it's magically doing what it does!
15:55:38 <nh2> dmwit: tested everything, I'm executing the code I'm writing, deleted/compiled everything, it is actual voodoo: still exitsuccess
15:55:49 <hpc> sixthgear: @join is an op command
15:55:55 <hpc> Cale: ping
15:56:07 <sipa> johnw: fix f = f (f (f (f ...)))
15:56:12 <johnw> yeah
15:56:21 <johnw> i just still can't understand my code :)
15:56:30 <johnw> i'm clearly using it to express recursion
15:56:45 <johnw> oh, I get it now
15:56:56 <monochrom> johnw, see my http://www.vex.net/~trebla/haskell/fix.xhtml . you can read the article backwards, that tells you how to convert fix back to boring recursion code
15:57:09 <johnw> I'm using it to say "hey, you called me, but I'm going to now call this other function that I want to call me back with its result"
15:57:22 <monochrom> it is a mechanical transformation. mechanical means nothing to understand
15:57:56 <johnw> so fix (\f x -> case x of Foo -> someFunction f ; _ -> 10)
15:58:13 <johnw> so in that case, I return 10 unless it's a Foo, in which case I want someFunction to call me back with another x
15:58:19 <monochrom> f Foo = someFunction f; f _ = 10
15:58:29 <johnw> yeah, well, it's a stupid example
15:58:50 <johnw> my actual code is a little less stupid
15:59:40 <johnw> what surprises me is that I knew how to do this before; I don't remember learning it, or knowing it, and I'm surprised that past-me knew how to use it correctly
16:00:14 <monochrom> you will not lose my mechanical story after you see it
16:00:45 <monochrom> only "magic" and "deep insight" can be lost
16:00:48 <johnw> monochrom: will read
16:02:07 <sfogarty> My google fu is failing me: could I get a recommendation for a simple unit test framework? HUnit? QuickCheck? Something else?
16:02:53 <OceanSpray> @pl \x y -> f x <$> (g <$> z) <*> pure y
16:02:54 <lambdabot> (. (((g <$> z) <*>) . pure)) . (<$>) . f
16:02:57 <OceanSpray> oh god
16:02:58 <monochrom> use HUnit if your specification is a lot of examples. use QuickCheck if your specification is a lot of formal logic statements
16:03:02 <typoclass> sfogarty: it's not exactly unit tests, but i like doctest quite a bit. check it out
16:03:20 <frio> haskell has a doctests equivalent?
16:03:34 <frio> awesome :O
16:03:44 <OceanSpray> @pl \y -> f <$> (g <$> z) <*> pure y
16:03:44 <lambdabot> (f <$>) . ((g <$> z) <*>) . pure
16:04:03 <sfogarty> thanks, monochrom and typoclass. I'll look at doctest and HUnit if that fails.
16:04:14 <monochrom> for example, suppose the specification for f is "f 1 has to be 1, f 2 has to be 2, f 5 has to be 5", then you use HUnit
16:04:33 <monochrom> likewise, suppose the specification for f is "f x has to be x", then you use QuickCheck
16:04:59 <aristid> given f :: b -> c and g :: a -> IO b, what's the nicest way to get a -> IO c? fmap f . g doesn't feel right somehow.
16:05:20 <monochrom> g >>= fmap f
16:05:27 <sfogarty> The specification is nonexistent :) I'm trying to provide an on-git-push feedback path for my students
16:05:34 <sfogarty> examples sounds easier, so I'll do HUnit if not doctest
16:06:08 <monochrom> @type putStrLn >>= fmap (const True)
16:06:09 <lambdabot>     Couldn't match expected type `IO ()'
16:06:09 <lambdabot>            against inferred type `String -> ()'
16:06:10 <lambdabot>     In the second argument of `(>>=)', namely `fmap (const True)'
16:06:17 <monochrom> yeah, I have a type error
16:07:23 <monochrom> (\x -> fmap f (g x)) = fmap f . g
16:07:40 <monochrom> @type fmap (const True) . putStrLn
16:07:41 <lambdabot> String -> IO Bool
16:08:04 <monochrom> correct elegant programs do not have to feel right, if the feeling is wrong
16:08:37 <aristid> monochrom: might be, yes.
16:09:07 <aristid> feelings are not exactly reliable, but i thought maybe i was just not aware of a nicer solution.
16:09:54 <monochrom> g >>= (return . f) is another way
16:10:13 <meursault> anyone have any ideas why I can't pass the result of peekArray to sum
16:10:13 <ParahSailin_> @src liftM
16:10:14 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
16:10:45 <aristid> monochrom: i think i'll keep it the way it is, though.
16:10:52 <monochrom> @type peekArray
16:10:53 <lambdabot> Not in scope: `peekArray'
16:11:03 <monochrom> @hoogle peekArray
16:11:03 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
16:11:03 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
16:11:19 <monochrom> fmap sum
16:11:21 <meursault> I have do { derp <- peekArray n pt ; derp2 <- sum derp; return derp2 }
16:11:50 <monochrom> what is the type of derp?
16:12:01 <meursault> CFloat
16:12:20 <monochrom> then should work. the error is elsewhere
16:12:21 <Automorphism> I think sum can only take lists. (?)
16:12:34 <sfogarty> Pardon the idiot moment: I did a "cabal install HUnit", but cannot "import HUnit" Perhaps I am not on the haskell platform (I did not do the install). Is there way to check?
16:12:42 <monochrom> yeah but probably derp is [CFloat]
16:12:49 <meursault> yeah peekArray gives lists, is there something I don't understand about lists
16:12:54 <meursault> err [CFloat] yeah
16:13:03 <dcoutts> sfogarty: see: cabal info HUnit
16:13:12 <sfogarty> ....thanks
16:13:36 <meursault> my whole function signature is foreign export ccall arrayTest :: Ptr CFloat -> Int -> (IO CFloat)
16:13:38 <dcoutts> sfogarty: the "Modules" listed at the bottom. As you can see, the modules are not exactly the same as the package name. Usually similar but not the same.
16:13:38 <monochrom> probably you haven't imported enough? need an import to bring in the Num instance for CFloat before you can do any arithmetic
16:13:48 <meursault> ah
16:13:56 <ParahSailin_> @type do { derp <- peekArray n pt ; derp2 <- sum derp; return derp2 }
16:13:57 <lambdabot> Not in scope: `peekArray'
16:13:57 <lambdabot> Not in scope: `pt'
16:14:08 <meursault> that makes sense. So I need more imports to use CFloat
16:14:09 <monochrom> the error is always elsewhere
16:14:27 <monochrom> I think Foreign.C.Types has it
16:14:59 <sfogarty> dcoutts: right, I was following the hunit tutorial, which used a different module name, and it just didn't occur to me to check. Silly me. :)
16:16:01 <dcoutts> sfogarty: in the old days before hierarchical modules, the module was called HUnit
16:20:22 <sfogarty> Is there a simple fix to 'silly person forgot to name file and module the same'?
16:20:32 <sfogarty> (other than 'rename file or module'
16:21:07 <edwardk> preflex: xseen kosmikus
16:21:07 <preflex>  kosmikus was last seen on freenode/#haskell 6 days, 13 hours, 22 minutes and 45 seconds ago, saying: mm_freak: of course, I absolutely understand you don't want to switch; but regarding being up-to-date, you can just check the distribution data that's on Hackage, and I think that NixOS is currently likely to be distribution with the best Haskell support
16:21:35 <edwardk> @tell kosmikus you and your student are i think the last holdouts for getting all the gsoc evaluations wrapped up.
16:21:35 <lambdabot> Consider it noted.
16:26:05 <typoclass> sfogarty: you could maybe remove the "module X where" line. not sure if that's what you're looking for :)
16:27:49 <sfogarty> typoclass: a way to import module Bar from file foo
16:28:00 <sfogarty> not sure there is a way, may have to rename the file to Bar
16:28:07 <sfogarty> .hs
16:28:14 <edwardk> ok, uniplate is in. i should probably add the compos combinators as well, but over all i think it turned out well
16:28:27 <edwardk> http://ekmett.github.com/lens/Control-Lens-Plated.html
16:31:20 <MostAwesomeDude> edwardk: Wow. Nice.
16:31:47 <edwardk> that should cover most uses for recursively traversing data
16:32:02 <edwardk> adding some of the missing compos combinators now for working with monoids, etc.
16:32:27 <MostAwesomeDude> edwardk: So, uh, not to hassle you, but what's up with parsers? Is there something holding that up?
16:32:45 <edwardk> the fact that i have yet to figure out how to clone myself ;)
16:32:51 <MostAwesomeDude> Aha. :3
16:32:56 <edwardk> 'parsers' itself works pretty well now
16:32:59 <MostAwesomeDude> Well, okay. No worries then.
16:33:10 <edwardk> i just haven't bolted it into 'trifecta' in a released form
16:33:16 <roconnor> edwardk: here you go: http://ekmett.github.com/lens/Control-Lens-Type.html#v:clone
16:33:34 <edwardk> roconnor: ?
16:33:39 <meursault> if you have type signature that ends in IO () does that mean it returns an empty tuple?
16:34:08 <MostAwesomeDude> meursault: It means that it is an action in IO that doesn't result in any data.
16:34:19 <roconnor> edwardk: how to clone yourself
16:34:23 <edwardk> roconnor: hahahaha
16:34:30 <edwardk> alas, i'm not a lens =)
16:34:41 <edwardk> a little unsafeCoercing might make it work
16:34:47 <OceanSpray> @hoogle a -> Maybe a -> Maybe (a -> a)
16:34:47 <lambdabot> No results found
16:34:56 <edwardk> but i'm not sure quite how to characterize myself in combinator form
16:34:59 <meursault> asking because I figured out what was going wrong with my call to peekArray (it was my type signature) - just trying to understand why my type Signature needed to end in -> IO Double and not IO Double ()
16:35:28 <meursault> so if it returns Data and is also IO it's just -> IO Type - wow I feel like such a noob
16:36:57 <MostAwesomeDude> OceanSpray: That's kind of a weird type to want. What's up?
16:38:05 <OceanSpray> implementing an evaluator; pattern matching can fail, returning Nothing, but I want to use Control.Monad.Reader.local :: (r -> r) -> Reader r a -> Reader r a
16:38:21 <OceanSpray> hence that type
16:41:27 <typoclass> meursault: "IO Double ()" would be alright if IO had two arguments. some types have that, e.g. "Either String Int". and yes, () is used here to indicate "no value"
16:42:40 <shachaf> type Id x = x
16:42:44 <shachaf> Id IO ()
16:42:50 <shachaf> Does Id have two arguments?
16:44:32 <typoclass> it totally doesn't
16:48:22 <edwardk> typoclass: it can with polykinds ;)
16:48:54 <rosie> Why is the "return x" for the ((->) r) Monad instance defined as \_ -> x ?
16:49:05 <edwardk> rosie: what else could it be?
16:49:07 <shachaf> rosie: Think of the type.
16:49:14 <shachaf> return :: a -> m a
16:49:20 <shachaf> m a = r -> a, so return :: a -> r -> a
16:49:20 <hpc> rosie: return :: a -> (r -> a)
16:49:28 <hpc> @djinn a -> (r -> a)
16:49:29 <lambdabot> f a _ = a
16:49:38 <hpc> return a _ = a
16:49:42 <hpc> return a = \_ -> a
16:49:42 <meursault> okay I'm now extremely confused by this inside my test function for peekArray if I bind a variable to the result of sum it has a problem but I can straight up return it just fine
16:49:44 <meursault> http://hpaste.org/73601
16:50:02 <meursault> any idea? is there something I don't understand about variable binding in do blocks?
16:51:43 <hpc> ah, i see the issue
16:52:05 <hpc> meursault: "<-" in do-blocks is for monadic binding
16:52:09 <hpc> so like
16:52:23 <hpc> in "x <- m", m :: SomeMonad x
16:52:28 <meursault> oh so something else needs to be of type IO
16:52:34 <hpc> what you want is
16:52:44 <hpc> "let x = pureComputation"
16:52:54 <meursault> ah
16:53:05 <hpc> which is just short for "let x = pureComputation in do"
16:53:08 <meursault> so when I'm doing a pure computation I should use let and not <-
16:53:14 <hpc> yeah
16:53:40 <meursault> ah thanks much I was going crazy first trying to make my own example and then later trying to transform the stuff found on http://neilmitchell.blogspot.com/2011_10_01_archive.html to my own
16:55:02 <typoclass> meursault: don't worry, you'll get the hang of it :) it's not very complicated in the end
16:58:10 <meursault> thanks typoclass - I'm sure I'll figure it out here shortly - I thought after I completed several of the tutorials I would be pretty well I hadn't counted on the glue between c and haskell being a pain
16:59:59 <meursault> if I can get this to work I'll be super happy though - all the glue to pass 2 arrays from c perform a pure computation on them with a custom function compiled from a string or source file and then returned as a c array
17:05:14 <gwern> @quote
17:05:14 <lambdabot> dons says: so, anyone else plan on getting a phd in haskell studies, so they can get a job at a big investment bank? :)
17:06:52 <c_wraith> hmm.  one guess where dons works now!
17:07:02 <shachaf> When is that quote from?
17:07:17 <hpc> c_wraith: galois? :P
17:07:36 <hpc> no wait.... MSR
17:07:48 <shachaf> hpc: No, Standard Chartered Bank.
17:07:53 <hpc> oh nifty
17:07:59 <typoclass> that's like saying "so you can get a job at a gulag beating up starving people". if that's what floats your boat ...
17:08:27 <sfogarty> is there any way in HUnit to create a test you expect to fail?
17:08:27 <sipa> dons works at a bank now?
17:08:42 <shachaf> It's been a while now.
17:08:55 <typoclass> something like 1 or 2 years
17:09:54 <byorgey> sfogarty: yes
17:10:58 <byorgey> sfogarty: oh, wait, maybe not
17:11:05 <sfogarty> byorgey: do you happen to know what it is? The guide does not cover it.
17:11:05 <sfogarty> heh
17:11:07 <byorgey> I saw 'assertFailure' and misunderstood what it was
17:11:32 <byorgey> sfogarty: anyway, what do you mean by "fail"?
17:11:33 <sfogarty> I'll look into exception handling
17:11:41 <byorgey> you mean "crash"?
17:11:47 <sfogarty> in this case, raise an exception
17:12:16 <byorgey> sfogarty: yeah, your best bet is to catch the exception and turn it into a Maybe, and then check for Nothing, or something like that
17:12:33 <byorgey> sfogarty: the 'spoon' package may be useful
17:12:37 <typoclass> sfogarty: maybe check out this http://stackoverflow.com/questions/9597700/how-to-use-assertraises-from-testpack-in-haskell
17:14:18 <sfogarty> sadly, assertRaises does not seem to be defined in HUnit, nor is htere an HUnit.tools :)
17:14:39 <sfogarty> ah, wait
17:14:43 <sfogarty> I bet I have to install this
17:15:16 <typoclass> sfogarty: yeah, the dude mentioned the package that offers it
17:15:26 <sfogarty> he did indeed. thanks!
17:17:39 <mebaran151> I'd like some help structuring a quick binding to the Salesforce REST API
17:17:58 <mebaran151> I'm beginning to understand http conduit and xml conduit, but now I'm trying to get the shape of my library correct
17:19:56 <aristid> mebaran151: you could try to steal ideas from my aws package :P
17:20:03 <aristid> @hackage aws
17:20:03 <lambdabot> http://hackage.haskell.org/package/aws
17:21:13 <mebaran151> here's my code so far: http://hpaste.org/73604
17:22:09 <mebaran151> hi aristid, I'll take a look; what it seems like an idea would be to structure the rest login as a monadic type and define the interactions as monadic actions
17:22:20 <mebaran151> but I'm very Haskell fresh
17:23:35 <aristid> mebaran151: i highly recommend putting type declarations on your top-level functions.
17:23:39 <mebaran151> right now, I can't get my salesforceAction function to work with anything createSalesforceService returns, though the whole approach could be misguided
17:23:45 <aristid> mebaran151: it really helps other people read the code.
17:24:00 <mebaran151> aristid: ok, will do (though the types seem to get complex quickly)
17:24:16 <aristid> they do, but that's exactly why it's needed!
17:25:50 <sfogarty> but, apparently, PatternMatchFail doesn't implement Eq
17:25:54 <aristid> mebaran151: i also recommend using force (or just listToMaybe) instead of head.
17:26:13 <aristid> mebaran151: head will crash your program when the list is empty.
17:27:54 <sfogarty> Easily fixed
17:28:03 <aristid> but i have a question to the cabal experts, myself: i want to put an executable in a cabal file where there's already a library, and i want the executable to depend on the library instead of compiling everything twice. however, just adding the library to the build-depends does not work.
17:28:42 <aristid> google found me this message, so i suppose it is possible somehow: http://www.haskell.org/pipermail/cabal-devel/2009-May/005293.html
17:29:06 <aristid> do i need to change the cabal-version to a specific value, or set some flag somewhere?
17:29:32 <dcoutts> aristid: you also need to make sure that the library's .hs files are not found on the source search path for the exe, since otherwise modules from .hs files get used in preference to modules from packages (ie the library)
17:29:46 <aristid> dcoutts: oh.
17:29:49 <dcoutts> aristid: which in practice means the exe needs to be in another dir
17:29:53 <aristid> it is
17:30:10 <aristid> it's in Examples/. i just have Main-is: Examples/GetObject.hs
17:31:05 <dcoutts> aristid: "hs-source-dirs:" is what you're looking for
17:31:22 <dcoutts> if unspecified, it defaults to "."
17:31:28 <dcoutts> ie root of the package
17:31:46 <aristid> dcoutts: awsome, thanks!
17:32:32 <aristid> dcoutts: i've got a tiny feature suggestion: allow putting flags/boolean expressions in fields that want booleans: like Buildable: flag(Examples)
17:32:38 <mebaran151> aristid: thanks for the tip, I just finished having ghci help me fill in the type sigs
17:32:53 <aristid> mebaran151: yeah, ghci is nice for that:)
17:33:47 <dcoutts> aristid: mm, it's worse than that, the buildable feature doesn't interact at all well with the flag feature
17:33:51 <mebaran151> here's a new version: http://hpaste.org/73605
17:34:02 <f> HELLO ZAOQ1UETE3S
17:34:08 --- mode: ChanServ set +o dcoutts
17:34:24 <aristid> dcoutts: oh? i'm currently using an if around Buildable to enable or disable the examples
17:35:29 <dcoutts> aristid: that's fine, but if the exe has other extra build-depends then you'll find all the tools think it always depends on those, even when the examples are disabled
17:36:00 --- mode: ChanServ set -o dcoutts
17:36:30 <aristid> dcoutts: that's not currently the case for me, but is there a nicer way to disable whole executables?
17:36:41 <dcoutts> not really
17:36:48 <aristid> too bad there are no top-level ifs
17:36:49 <dcoutts> you can also stick the build-depends under the if
17:38:48 <aristid> dcoutts: right, don't currently need it, but that's probably better going forward.
17:41:07 <mebaran151> right now, I'm having trouble getting salesforceAction to accept a SalesforceService; far term I'd like to struture the library a little better...
17:42:37 <aristid> dcoutts: the cabal user guide fails to mention Default-language. i wonder which values can be put in there, other than Haskell98 and Haskell2010
17:43:51 <dcoutts> aristid: yes it does. Those are the only two language standards in existence so far.
17:44:12 * dcoutts has stalled part-way through a rewrite of the cabal user guide
17:45:50 <sfogarty> Hmn. is there a way to make HUnit gracefully handle tests on a function that doesn't exist? Alternately, is there a way to check if a function exists and give it a definition if it doesn't?
17:46:33 <juturna> I'm working on a little project with STM, and I frequently need to read a couple TVars atomically, and then do some IO with them.  I keep ending up with something like this: http://pastie.org/4577745 , but it feels like a code smell.. Is there a more idiomatic way to do this?
17:50:50 <aristid> dcoutts: ok, so i'll use Haskell2010. but i really can't find default-language in http://www.haskell.org/cabal/users-guide/developing-packages.html
17:51:25 <dcoutts> aristid: I meant "yes" as in yes it does fail to mention those new fields
17:52:10 <sfogarty> Hmn. Yep, this seems to be a biiiig. I can't write test cases for functions that aren't defined yet.
17:52:33 <sfogarty> (big problem with HUnit)
17:52:57 <aristid> dcoutts: oh, hah, understood it the opposite way :D
17:53:06 <dcoutts> sorry, I was unclear
17:53:40 <dcoutts> sfogarty: is that a problem? how would you run those tests?
17:53:48 <liyang> juturna: http://hpaste.org/73606
17:53:50 * donri . o ( sort of want OverloadedLists with fromList = mconcat )
17:53:51 <sfogarty> they should fail
17:53:54 <sfogarty> but it should copmile
17:53:56 <sfogarty> (er, compile)
17:54:00 <sfogarty> and run tests on functions that d oexist
17:54:06 <typoclass> juturna: maybe you could stick the tuple (a, b) in the TVar?
17:54:34 <dcoutts> sfogarty: ok, that's easy, define a local function with the name of the function you're going to test and set it = undefined
17:54:53 <sfogarty> dcoutts: wouldn that not override the imported function?
17:55:14 <dcoutts> sfogarty: but do also give the dummy impl the type signature of the real function, so that your test type checks ok
17:55:40 <juturna> liyang: thanks.  I did something similar with liftM2 (,), but I should probably be using applicative anyway.. thanks!
17:55:49 <dcoutts> sfogarty: no, when you define the function for real in another module and import it in the test module, then the compiler will complain about the duplicate and at that point you can delete the dummy impl.
17:56:21 <typoclass> sfogarty: in general, if ghc can figure out that something is wrong (e.g. you're calling a function that doesn't exist), then it will tell you. it won't pretend that things are fine and fail at runtime
17:56:35 <dcoutts> sfogarty: to be clear about my point about the type sig, instead of just: foo = undefined. also do foo :: Int -> Int, or whatever the type of foo actually ought to be
17:56:56 <Veinor> @djinn (e -> a) -> (a -> e -> b) -> (e -> b)
17:56:56 <lambdabot> f a b c = b (a c) c
17:57:18 <sfogarty> dcoutts: (figured out the type sig) that's still not a graceful solution, as it requires modifying the test file upon implementing. is there  away to check if it is defined?
17:57:25 <dcoutts> sfogarty: that way, if the test compiles, you'll know it'll still compile against the real version since it'll be guaranteed to have the same type
17:57:31 <dcoutts> sfogarty: no, that's just not how things work
17:58:06 <typoclass> sfogarty: you can put the "f = undefined" in the module under test, not in the unit tests
17:58:23 <dcoutts> true
17:58:36 <dcoutts> then it's even easier
17:59:13 <sfogarty> typoclass: that does fix a lot of things (since there will be multiple student implementation, and I'm trying to write one bank of tests), but is still not great.
17:59:36 <sfogarty> what I really want is a "check if this function exists with this type signature. if so, run these tests. If not, say 'this function does not exist/has the wrong type.'
17:59:56 <dcoutts> or instead of undefined, = error "TODO: exercise 4"
18:00:30 <sfogarty> could write a little script to check for existence, cat undefined to end of file
18:00:35 <sfogarty> but ugh
18:00:47 <dcoutts> sfogarty: do you want the students to define the type too?
18:00:53 <dcoutts> or will you provide the type sig
18:00:54 <sfogarty> I want them to be able to make type errors
18:01:20 <sfogarty> I think the proper solution may be to have a different test file for each problem, so that when it fails to load they get that error
18:01:39 <dcoutts> sfogarty: oh sure, but type errors in the impl of their function, or also errors in the interface of their function?
18:01:54 <sfogarty> In the interface :) Give them as much rope as possible
18:02:01 <sfogarty> But I like this solution
18:02:28 <dcoutts> sfogarty: when I used to run classes and had QC tests, I provided the test module but just commented out the tests, and told them to uncomment them when they were ready to test each function
18:02:28 <sfogarty> instead of haskell complaining about undefined functions/wrong types being a problem, it becomes the error message the student sees
18:02:44 <juturna> liyang: How would you write it if the second readTVar relied on the result of the first?
18:03:03 <sfogarty> kind of a pain to split it across multiple files though
18:03:07 <dcoutts> sfogarty: I'd ask them to check the function is sane in ghci first, and if they think it's ok, then go run the QC test
18:03:18 <dcoutts> sfogarty: you can bung it all in the same module if you like
18:03:20 <sfogarty> well, git is going to run the tests
18:03:26 <sfogarty> not them directly
18:04:08 <sfogarty> oooh, wait
18:04:09 <typoclass> sfogarty: i think your students are going to see various ghc error messages anyway (and they should). i think it confuses the issue if you try to replace some of the messages with your own ones
18:04:11 <sfogarty> I bet I can use cpp or something
18:04:38 <sfogarty> yeah, but atm if any funciton is undefined
18:04:40 <sfogarty> none of them get tests
18:04:51 <sfogarty> HUnit is good about returning the ghc error
18:04:54 <dcoutts> and running tests via git and automated stuff is good, but it's also useful during initial development to run them manually too
18:04:55 <sfogarty> (printing, not returning)
18:05:15 <dcoutts> e.g. with QC, it prints the counter example
18:05:27 <sfogarty> and they can, dcoutts, but git is the harder audience to program for
18:05:29 <sfogarty> (QC?)
18:05:39 <dcoutts> QuickCheck
18:05:39 <sfogarty> oh, quickcheck
18:05:43 <sfogarty> using HUnit atm
18:06:02 <dcoutts> so if you're running the tests interactively in ghci, it prints the counter example and the student can then run the counter example and see what is going on
18:06:28 <sfogarty> I've gotten HUnit to do that (through labels)
18:06:37 <sfogarty> might switch to quickcheck
18:06:50 <dcoutts> anyway point is, running them individually manually during development is useful, automate once things are basically working
18:07:06 <sfogarty> yes, but I would like to get them automated even if not everything is working
18:07:17 <sfogarty> and report failure only on the functions that are not yet defined, instead of the whole project
18:07:23 <dcoutts> sfogarty: = error "TODO" should make that possible
18:07:32 <dcoutts> the tests then will run and fail
18:07:40 <dcoutts> and you don't have to give the functions a type signature
18:07:41 <sfogarty> that's my best current solution
18:07:55 <typoclass> i liked what dcoutts suggested -- comment all the tests, tell them that when they're ready to test a function, uncomment its test
18:08:08 <dcoutts> sfogarty: but the issue there is that the students will get type error messages in the tests
18:08:21 <typoclass> the git-push thing would come at the end, when they have a solution for each function
18:08:26 <dcoutts> sfogarty: in the case that their function has a coherent type, but not the one the test case expects
18:08:28 <sfogarty> so far with undefined will PROBABLY work with that dcoutts
18:08:30 <sfogarty> oh, yes,
18:08:31 <sfogarty> that is true
18:08:35 <sfogarty> but they should get a type error there
18:08:37 <sfogarty> dcoutts:
18:08:45 <sfogarty> typoclass: I want them to be able to git push early and get early feedback
18:08:48 <dcoutts> sfogarty: ok, if that's what you want then it's ok
18:08:59 <sfogarty> putting f = undefined in the sample homework file should work for now
18:09:08 <sfogarty> (initial, not sample)
18:09:23 <dcoutts> sfogarty: I'd recommend  f = error "TODO: f not yet implemented"
18:09:30 <dcoutts> sfogarty: = undefined can confuse beginners :-)
18:09:42 <sfogarty> Fair enough
18:09:51 <sfogarty> I still want a way to see if it is defined :)
18:10:08 <dcoutts> that's easy, evaluate it :-)
18:10:13 <Jafet> _EXERCISE_ = undefined
18:10:36 <sfogarty> a way to see if it is undefined that doesn't prevent compilation :)
18:10:43 <sfogarty> that's what I have so far, Jafet
18:10:55 <dcoutts> sfogarty: but of course HUnit will report the exception, ie the error message
18:11:04 <sfogarty> no, HUnit won't get that far
18:11:10 <sfogarty> oh, with undefined
18:11:10 <sfogarty> yes
18:11:11 <dcoutts> if it's = error "blah" it will
18:11:17 <dcoutts> or = undefined, yes
18:11:18 <sfogarty> right :) Soryr, I thought you meant if I left it blank
18:11:31 <dcoutts> right, the only thing you can't do is leave it blank
18:12:05 <sfogarty> which is what I want to do :)
18:12:27 <dcoutts> so long as you can let that go you'll be fine :-)
18:13:23 <sfogarty> Yeaaah. Now I'm looking at System.eval :)
18:15:43 * sfogarty cackles, "This might do it."
18:17:06 <donri> what is System.eval?
18:19:12 <JoeyA> Can patterns in do notation have guards?
18:19:25 <JoeyA> e.g. n | n == 5 <- readLn
18:19:31 <startling> JoeyA: with a lambda
18:19:36 <startling> I don't think there's another way
18:19:44 <JoeyA> What do you mean?
18:19:53 <JoeyA> A lambda pattern is irrefutable, isn't it?
18:20:42 <startling> JoeyA: you can stick a lambda in the do notation and call it. I don't think you can do it nicely
18:21:06 <JoeyA> I think I'll just do True <- return (x == 5)
18:21:18 <JoeyA> Thanks.
18:22:42 <latro`a> ...that means you get pattern match failure instead of a value when it fails....
18:23:16 <Twisol> Hullos.
18:23:21 <JoeyA> That's intended.  I'm writing tests, and I'd rather it tell me the line on which it failed.
18:23:35 <latro`a> mmk
18:28:08 <slack1256> I have to try this.
18:28:18 <slack1256> Hey John Carmack, are you here?
18:28:40 <Boney> slack1256: Yes.
18:28:55 <Boney> (I'
18:29:33 <Boney> (I'm not really JC), but that's the kind of response you might get.  Some tool pretending to be JC)
18:29:51 <ahkurtz> that's what the real JC would say.
18:29:52 <Boney> But it's kinda blasphemous so I'll stop now.
18:30:09 <Twisol> Hmm… I'm trying to gain some intuition for functions as algebraic objects, instead of just a kind of relation or mapping.
18:30:10 <slack1256> Eh. nice try JOHN!
18:30:45 <Twisol> Is it safe to say that (a -> b) is an object of type b whose value depends on the value of the `a`?
18:31:03 <slack1256> Twisol: as in haskell or as in Real/Complex analysis?
18:31:05 <Twisol> (Writing it out makes it feel so obvious, somehow. :|)
18:31:10 <Twisol> as in Haskell
18:31:35 <slack1256> damn, well in haskell try to read the type of the function as in logic
18:31:54 <Twisol> like, treating a function as a Functor. Looking at an `fmap` over the `(->) a` functor.
18:32:38 <Twisol> I've been spending some time with `fmap` trying to understand it as a lifting operation, i.e. just passing the first parameter and intuiting what the result is
18:33:50 <slack1256> think once you pass to `fmap` a function of type (a -> b) you are, with the function. restricting the universal qualifiers of 'a -> b' to the ones of the function.
18:34:43 <Twisol> I get the general intuition of a haskell Functor. :) I'm trying to understand specific instances.
18:34:55 <Twisol> [] and Maybe were easy
18:35:18 <Twisol> but I want to make sure my understanding of (->) is correct.
18:36:00 <Ralith> Twisol: (a -> b) is a type, not an object
18:36:05 <ion> twisol: This may or may not be useful: http://heh.fi/haskell/functors/#function-instance
18:36:06 <Ralith> functions are of type (a -> b).
18:36:07 <Twisol> Objects of type (a -> b).
18:36:23 <Ralith> (a -> b) certainly isn't equal to b.
18:36:38 <Twisol> no, I've spent the last ten minutes trying to figure out how to write this
18:37:38 <ahkurtz> I don't think it's useful to think of objects
18:37:53 <Twisol> given a function that takes a 'now' value of type `a` and returns a `now` value of type `b`, fmap augments it to accept 'later' values of type `a` dependent on a type `c` and return 'later' values of type `b`
18:38:17 <Twisol> ^ yay/nay?
18:38:18 <Ralith> what are "now" and "later"
18:38:29 <shachaf> Ralith: But ((forall a. a) -> b) is!
18:38:53 <Twisol> if `b` is the type of a value we already have, `a -> b` is the type of a value dependent on another value
18:39:09 <Twisol> thus 'now' and 'later'. Like I said, I'm having a hard time figuring out how to put it.
18:39:24 <ddarius> (\_ -> undefined) /= undefined
18:39:29 <Jafet> @quote dimensional
18:39:29 <lambdabot> Ethereal says: If this conversation had been had in #python #ruby or #php it would have lots of angry people shouting about how it doesn't matter or isn't true or isn't important and what's the
18:39:29 <lambdabot> point, and no, you guys are like ahhh but no, your preconceived notions of dimensional space are so passe.
18:39:29 <Ralith> the only sense in which that is true is the one in which "dependent on" is trivially defined as "a function of"
18:40:08 <shachaf> ddarius: Ah, _|_ is one additional value for (Void -> b). True.
18:40:21 <Twisol> ddarius: (\_ -> undefined) == const undefined
18:40:29 <Twisol> and fmap = const in the Functor for (->)
18:40:38 <Twisol> which is kind of my point, really
18:40:41 <Twisol> er
18:40:42 <shachaf> Twisol: fmap /= const
18:40:46 <Twisol> sorry, pure = const in the Applicative
18:43:17 <Twisol> essentially, I'm asking if `fmap` for (->) can be seen as lifting a function operating on non-dependent values to a function operating on dependent values. Like promises.
18:43:24 <aristid> :t [fmap, const]
18:43:25 <lambdabot> forall a b. [(a -> b) -> (a -> a) -> a -> b]
18:43:43 <aristid> so there is a type for which fmap and const have the same type. lol
18:44:02 <zzing> What is a dependent value?
18:44:17 <Twisol> in my thinking, (a -> b) is a b that depends on an a
18:44:48 <roconnor> @index Identity
18:44:48 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
18:46:20 <ion> @type fmap `asTypeIn` const
18:46:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:46:58 <shachaf> @ty (`asTypeIn` const)
18:46:59 <lambdabot> forall a. a -> a
18:47:56 <DT`> :t asTypeIn
18:47:57 <lambdabot> forall a b. a -> (a -> b) -> a
18:48:12 <byorgey> Twisol: makes sense to me
18:48:42 <Twisol> Well that's good then!
18:48:46 <DT`> @src asTypeIn
18:48:46 <lambdabot> a `asTypeIn` f = a where _ = f a
18:48:47 <lambdabot> infixl 0 `asTypeIn`
18:49:18 <byorgey> Twisol: in fact, this pattern gets explicitly used quite often, but in a slightly different guise as the Reader monad
18:50:10 <Twisol> Yeah, that's on my list of things to investigate more. I figured I'd better start with Functor because it's simple and other types build on it.
18:50:19 <Twisol> I kind of prefer to look at `fmap` as taking one parameter rather than two. It seems more interesting that way.
18:50:28 <byorgey> Twisol: I agree =)
18:50:56 <byorgey> Twisol: well, you've basically already figured out Reader, except the monad instance.  Reader e a  is just a newtype wrapper around  (e -> a)
18:50:57 <ion> Yeah, that’s a natural way to think about fmap.
18:51:12 <byorgey> so something of type  Reader e a  is a "value of type a which can depend on a value of type e"
18:51:36 <byorgey> or you can think of it as a "computation" which produces an a, but is allowed read-only access to an "environment" of type e
18:51:39 <Twisol> ion: Well, in the case of (->), the two-argument view is easier to grok. It's just composition. But I really wanted to figure out if I could see it the other way too.
18:52:10 <byorgey> Twisol: well, congratulations then =)
18:52:21 <Twisol> Thanks!
18:52:36 <Twisol> My epiphany for the day was pure = const
18:52:51 <Twisol> and that kind of dovetailed with the fmap stuff. :P
18:53:04 <byorgey> nice =)
18:58:16 <zzing> :t (>>=)
18:58:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:58:45 <zzing> @hoogle (Monad m) => m a -> (a -> b) -> m b
18:58:45 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
18:58:45 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
18:58:46 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
18:59:01 <zzing> :t many1
18:59:02 <lambdabot> Not in scope: `many1'
18:59:24 * BMeph sometimes wonders what people that "get" functional programming miss that "normal" people don't
19:00:00 <zzing> BMeph, one can get Ocaml, but completely lost in Haskell's sea of vastness
19:00:04 <Twisol> Fresh air? *rimshot*
19:00:05 <shachaf> BMeph: Does "getting" one thing make you "miss" another thing?
19:00:10 <aristid> BMeph: "miss"? do you mean the other way round?
19:00:18 <parcs`> BMeph: the amount of time it takes to understand abstract concepts
19:00:32 <latro`a> twisol--sure, but the one-parameter view works too once you understand where the "value" lives in (->)
19:00:38 <latro`a> i.e. in the return value
19:00:57 <shachaf> It's always in the return value, isn't it?
19:01:04 <Twisol> latro`a: Yeah, that was today's (other) epiphany: `(->) a` as a dependent value
19:01:10 <shachaf> Is there a monad that's contravariant in its argument?
19:01:30 <latro`a> Cont?
19:01:37 <shachaf> Cont is covariant.
19:01:50 <latro`a> fair enough
19:01:55 <shachaf> Althought not "strictly covariant", or whatever the term is.
19:02:34 <Twisol> I'm starting to realize why math has so much technical jargon. It's so hard to describe certain things without it.
19:04:08 <squidz> i imported System.IO, and my list comprehension that i bind in my main do construct suddenty throws an error in the compiler
19:04:21 <squidz> expected IO but was []
19:04:36 <squidz> this happened only after i import System.IO, any ideas?
19:04:38 <latro`a> paste
19:04:48 <Twisol> Is there an existing type with a Functor instance, but that cannot be made an instance of Applicative?
19:05:37 <squidz> http://hpaste.org/73608
19:06:22 <latro`a> should break no matter what
19:06:29 <startling> Twisol, (->) a ?
19:06:46 <startling> wait, that can probably be made applicative
19:06:47 <latro`a> you're in IO, so the right side of a <- is an IO
19:06:49 <mauke> squidz: what happens without System.IO?
19:06:50 <squidz> latro`a: in line 33
19:06:58 <mauke> startling: dude, that's a monad
19:07:04 <startling> mauke: ...oh right
19:07:05 <latro`a> I know
19:07:09 <squidz> mauke: it compiles and run minus the two file IO lines
19:07:09 <Twisol> startling: according to the docs, it has an instance of applicative
19:07:09 <latro`a> that's the whole problem
19:07:17 <mauke> squidz: no, it doesn't
19:07:19 <Twisol> startling: also hi!
19:07:23 <startling> Twisol: hi!
19:07:50 <startling> yeah, not sure what a non-applicative functor would look like
19:07:56 <squidz> so i need to bring the list ot the IO monad?
19:08:09 <Twisol> I'm trying to figure out what kind of functor wouldn't support `pure`, for example.
19:08:11 <tomoj> how might FRP accomodate network latency of event propagation between two reactive programs? I feel vaguely like this would require backwards causality..
19:08:17 <latro`a> I'm not sure what you mean with the <- in the first place
19:08:21 <latro`a> do you want to concatMap or something?
19:08:40 <squidz> i just write that list to a file
19:08:43 <startling> tomoj, have you seen the reverse state monad? :)
19:08:54 <Twisol> Tardis?
19:08:58 <mauke> > fmap succ ("", 'b')
19:08:59 <lambdabot>   ("",'c')
19:09:02 <heatsink> I have some mutually recursive data types S, T :: * -> *.  The parameter is a phantom type.  Can I get functions S a -> S b and T a -> T b without writing out the structural recursion?
19:09:07 <squidz> latro`a: i want to write the lines of te list to a file
19:09:12 <mauke> > pure 'b' :: (String, Char)
19:09:13 <lambdabot>   ("",'b')
19:09:30 <byorgey> Twisol: I can't think of any off the top of my head
19:09:30 <mauke> > pure 'b' :: (Int, Char)
19:09:31 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
19:09:31 <lambdabot>    arising from a use of...
19:09:34 <latro`a> then use writeFile
19:09:50 <ddarius> startling: It's very easy to think up functors for which you can't write pure.
19:09:50 <Saizan> heatsink: unsafeCoerce?
19:09:53 <latro`a> :t writeFile
19:09:54 <lambdabot> FilePath -> String -> IO ()
19:10:03 <mauke> Twisol: (,) a where a is not a monoid
19:10:04 <startling> ddarius, like what?
19:10:19 <byorgey> Twisol: oh, well, ((,) e)  can't be made Applicative in general, you need a Monoid constraint on the e
19:10:21 <ddarius> f a = (a, x)
19:10:30 <byorgey> ah, mauke beat me =)
19:10:31 <squidz> latro`a: so i just unlines it and stick it in writeFile?
19:10:35 <latro`a> pretty much
19:10:37 <heatsink> Saizan, eew
19:10:44 * heatsink was hoping for something less unsafe
19:10:48 <tomoj> startling: now I have, though I don't understand it much. is it really applicable to FRP?
19:11:08 <aoeu> Is Snap better designed than Yesod?
19:11:12 <heatsink> Like, something that would be a compile-time error if S a was not structurally equal to S b
19:11:14 <Twisol> mauke, byorgey: Ahh, okay. And that's because we need 'mempty' to get a value from nothing?
19:11:15 <geekosaur> the othet way to think about it is that a list can be a Functor in only one wy but two ways to make it Applicative
19:11:26 <startling> tomoj: just saying that backwards causality is not necessarily impossible in haskell
19:11:31 <startling> tomoj: (in a limited fashion)
19:11:55 <byorgey> Twisol: well, and also that to implement <*> you need a way to combine two arbitrary e values
19:12:02 <tomoj> ah
19:12:10 <byorgey> Twisol: and in order for the Applicative laws to be satisfied, you need exactly the Monoid laws
19:13:29 <squidz> latro`a: thanks, and that concludes my first adventure in the world of haskell hacking. my first little program, and the first time i feel somewhat comfortable with Functors/Monads
19:13:54 <Twisol> squidz: Now tell me what (fmap fmap fmap) does. :>
19:14:00 <aoeu> Should I ditch .NET and switch to Haskell?
19:14:23 <startling> @faq Should I ditch .NET and switch to Haskell?
19:14:23 <lambdabot> The answer is: Yes! Haskell can do that.
19:14:25 <mauke> squidz: while you're at it, (flip id) and (fmap fix return)
19:14:45 <squidz> Twisol: i need time for my brain to recover from the beating it just took before i continue
19:14:45 <byorgey> stop torturing poor squidz ;)
19:14:51 <Twisol> squidz: I tease. :)
19:15:03 <startling> :t (fmap <$> fmap)
19:15:03 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:15:07 <Twisol> (fmap fmap fmap) was another recent epiphany...
19:15:09 <squidz> Twisol: i know
19:16:27 <latro`a> also, squidz, handle methods *are* indeed more versatile
19:16:33 <squidz> Twisol: I thought i had to use fmap fmap while writing, but it turned out i didnt
19:16:33 <latro`a> so do get acquainted with them
19:16:43 <latro`a> but if you're only writing one string they are unnecessary
19:16:52 <Twisol> flip id :: a -> (a -> b) ->  b
19:17:24 <Twisol> flip id == flip ($) ???
19:17:35 <Nereid> yes
19:17:52 <Nereid> ($) = id :: (a -> b) -> a -> b
19:18:06 <Twisol> Wow.
19:18:12 <Nereid> well yeah.
19:18:18 <Twisol> That puts id in a whole new light. O_o
19:18:18 <aristid> dishonestbob: and i was always thinking you were a honest man :/
19:18:22 <Nereid> not really
19:18:28 <Nereid> f $ x = ($) f x
19:18:30 <dishonestbob> aristid: guess not
19:18:35 <startling> Twisol: it's just id with a different precedence
19:18:36 <Nereid> so one would hope that ($) f = f
19:18:37 <Jafet> Cohonest?
19:19:09 <byorgey> Twisol: think of ($) as taking only one argument instead of two ;)
19:19:12 <Twisol> startling: Except id is any value, and ($) is functions. I'd have been hard pressed to figure out that relationship before.
19:19:15 <copumpkin> :)
19:19:32 <Twisol> *any type
19:19:33 <startling> Twisol: what do you mean "($) is functions"?
19:19:43 <squidz> latro`a: now i have to read each line of that file i just created and create a new file so ill have a chance to use handlers
19:19:43 <byorgey> ($) has a more restricted type than id.
19:19:45 <Twisol> ($) is specialized slightly from id.
19:19:46 <Nereid> @djinn (a -> b) -> a -> b
19:19:46 <mauke> id :: (a -> b) -> (a -> b)
19:19:46 <lambdabot> f a = a
19:19:51 <startling> Twisol: ah alright
19:21:12 <Twisol> I guess that's another case where looking at a function as 1-ary is insightful.
19:21:34 <monochrom> @quote monochrom 17-ary
19:21:34 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
19:21:43 <Twisol> *facepalm*
19:22:02 <ddarius> id <= ($)
19:32:52 <donri> monochrom: barity legal
19:37:42 <Okasu> @lisp ((lambda (x) (* x x)) 5)
19:37:42 <lambdabot> No module "((lambda (x) (* x x)) 5)" loaded
19:37:42 <lambdatest> 25
19:37:42 <lambdatest> Getting an unbound variable: No
19:37:49 <aoeu> What replaces objects in Haskell?
19:37:50 <lambdatest> Getting an unbound variable: What
19:38:08 <Ralith> Okasu: don't test your bots in a public channel.
19:38:21 <shachaf> And don't start your bots' names with "lambda".
19:38:25 <donri> aoeu: algebraic data types, type classes, monads... what are you using the object for? :)
19:38:38 <Okasu> i've implemented scheme interpreter for lambdabot but i can figre out how to enable state supportin it
19:38:54 <Okasu> any suggestions?
19:39:06 <aoeu> donri: How do you share data through an api, without objects?
19:39:34 <Okasu> steta wors fine in standalone version, but not in bot
19:39:40 <Okasu> state*
19:39:58 <Okasu> shachaf: why?
19:40:00 <donri> aoeu: algebraic data types / records, probably. still not sure what you mean exactly.
19:40:12 <Twisol> aoeu: do you have a specific example?
19:40:19 <dolio> How did people even write programs before object oriented programming existed?
19:40:30 <donri> LOL
19:40:33 <shachaf> Okasu: Because tab completion for lambdabot.
19:40:46 <shachaf> I guess we don't address lambdabot by name that much. But still, confusion.
19:40:47 <Twisol> Yeah, basically just functions accepting structures as parameters, if you look at C.
19:40:48 <donri> lambdanaut: damn you!
19:40:57 <aoeu> dolio: I have no idea.
19:41:23 <ddarius> dolio: Poorly.  Admittedly, OO didn't change that.
19:41:43 <Twisol> aoeu: object-oriented methods like obj.doStuff(a, b, c) can just be desugared into doStff(obj, a, b, c)
19:42:04 <Okasu> i wonder if there is some lambdabot gurus in existance :/
19:42:06 <aoeu> objects still exists?
19:42:14 <Twisol> aoeu: I mean conceptually
19:42:24 <aoeu> there are classes in haskell?
19:42:25 <zzing> If one has   a *> b *> c  What is the ordering of this?
19:42:26 <donri> Okasu: try mauke
19:42:32 <donri> or Cale, but not here now
19:42:42 <Twisol> aoeu: There's a way to create composite data types out of simpler ones.
19:42:59 <Twisol> aoeu: data MyType = Stuff Int Int String
19:43:17 <aoeu> Twisol: And you can serialize it in json?
19:43:17 <Okasu> donri: yeah, i've tryed mauke but he seems to ignore me or something
19:43:18 <startling> basically c structs with automatically-tagged unions
19:43:24 <startling> aoeu: sure why not
19:43:27 <aoeu> Twisol: But are these values named?
19:43:28 <Twisol> and the expression (Stuff 1 "hello" there") would be of type MyType
19:43:35 <aoeu> Twisol: OOP seems much more intuitive and powerful.
19:43:42 <Twisol> aoeu: They can be named with record syntax. They don't need to be, using pattern matching
19:43:56 <aoeu> Who can remember a pattern?
19:43:58 <Okasu> donri: and Cale have said he know nothing
19:44:00 <Twisol> aoeu: I used to think the same thing. Have you done much haskell?
19:44:01 <startling> aoeu: lol
19:44:08 <aoeu> Twisol: Not much.
19:44:13 <Twisol> aoeu: Haskell is totally different. It's really hard to judge it without spending some time with it.
19:44:14 <startling> aoeu: do you know what pattern matching means?
19:44:17 <mauke> Okasu: when was this?
19:44:17 <aoeu> Twisol: I find it beautiful, but hard to grasp.
19:44:35 <Okasu> mauke: few days ago
19:44:37 <aoeu> startling: Yes, it means like regex or method signature
19:44:40 <Twisol> aoeu: I'm not even evangelizing - Haskell is simply a profound language that cannot be grokked in a couple sessions
19:45:05 <Okasu> mauke: so, so you know something about state for lambdabot plugins?
19:45:14 <mauke> Okasu: no, I know nothing about lambdabot
19:45:19 <aoeu> Twisol: Is haskell worth it? I invested a lot in .NET technology, and I love it.
19:45:20 <dolio> You can't even understand VB in a few sessions starting fresh.
19:45:26 <aoeu> Twisol: But Haskell looks sexy.
19:45:34 <aoeu> Twisol: And I'm ready to give it a try.
19:45:39 <Nereid> it is pretty sexy.
19:45:48 <aoeu> Is it just that?
19:45:51 <aoeu> Does it have flaws?
19:45:57 <Twisol> Everything has flaws. :P
19:45:57 <Nereid> everything has flaws.
19:46:01 <aoeu> Or is it the holy grail?
19:46:02 <Okasu> mauke: meh, is it really true because i've saw your repo on github with your lambdabot fork?
19:46:05 <Saizan> dolio: tried?
19:46:07 <Twisol> The holy grail does not exist
19:46:11 <mauke> Okasu: url?
19:46:13 <aoeu> Does it make one more productive?
19:46:16 <dolio> Saizan: Yes. VB was the first language I learned.
19:46:19 <aoeu> Will I be more productive than in .NET?
19:46:21 <Twisol> Don't pick Haskell because "it is the best tool for everything".
19:46:22 <aoeu> (After a while)
19:46:22 <Twisol> No.
19:46:27 * ddarius likes this game of attributing actions, intents, and thoughts to mauke.
19:46:27 <Twisol> After a while, yes.
19:46:28 <aoeu> Twisol: No?
19:46:39 <aoeu> Twisol: What framework do you suggest?
19:46:44 <Okasu> mauke: oh, crap, it was mokus, sorry
19:46:50 <Okasu> https://github.com/mokus0/lambdabot
19:46:51 <aoeu> Twisol: Snap looks simpler and nicer at first. Yesod looks more complete.
19:46:58 <donri> isn't preflex a lambdabot
19:47:14 <mauke> donri: what do preflex and lambdabot have in common?
19:47:30 <dolio> They were written by people that hang out in #haskell.
19:47:32 <ddarius> mauke: They are both on this channel, from which I conclude donri is a lambdabot.
19:47:36 <Twisol> aoeu: Personally? I like Snap, but I haven't done much with either. I'd work through "Learn You A Haskell" though - diving into building an application is like running into a brick wall.
19:47:38 <donri> no idea, just remember hearing that
19:47:38 <Twisol> I speak from experience.
19:47:40 <Nereid> ddarius: :))))
19:47:42 <Okasu> so it was mokus who ignored me so much :)
19:47:57 <Okasu> mokus: ping
19:48:15 * tgeeky takes away a few inductive fallacies, and has ddarius repeat the last command
19:48:16 <zzing> I have a parser that is trying to use a Text type as an input, but I have trouble now that I need to get a Text out for a constructor. The compiler suggests I put in another type in the function but it doesn't make any sense. Any suggestions? http://hpaste.org/73609
19:48:18 <dolio> Actually, that's not true of lambdabot anymore.
19:48:25 <aoeu> Twisol: Why? It can't be that complicated. Everything is simpler in haskell no? My todo app will take a week to build.
19:48:33 <Twisol> aoeu: Full disclosure: I'm a Haskell novice. My primary language is Ruby, and I'm only a month or so into Haskell really.
19:48:51 <aoeu> Twisol: And will you go back?
19:49:03 <ddarius> dolio: All the people that wrote parts of lambdabot have disavowed it and fled.
19:49:17 <lpvb> ddarius: why?
19:49:22 <dolio> Cale's still around, I guess.
19:49:26 <Twisol> eh, can't tell if trolling or serious. Haskell has a steep learning curve. It boils things down to some amazingly powerful concepts and is very flexible, but that comes with a lot of learning overhead.
19:49:33 <ddarius> dolio: I'm not sure if Cale wrote anything in lambdabot.
19:49:38 <dolio> Yeah, I'm not sure.
19:49:42 <Twisol> aoeu: I don't "go back". I'm a polyglot programmer - I use whatever language I feel like.
19:49:45 <shachaf> Cale takes no responsibility for lambdabot when issues come up, certainly.
19:50:04 <aoeu> Twisol: It's better to stick with one, no?
19:50:07 <Twisol> aoeu: Right now, Haskell is my "explorative" language. I'm not using it for anything big right now, just learning and absorbing. Ruby and Javascript are my workhorses.
19:50:11 <aoeu> Twisol: It's either Haskell or Node.js.
19:50:29 <Twisol> aoeu: While learning? Yes, it's better to learn one at a time. For life? No… I would disagree.
19:51:02 <Twisol> every language provides a different view on the same fundamental thing
19:51:04 <Nereid> I'm only a theoretical haskell programmer.
19:51:14 <Nereid> I don't actually write much code.
19:51:17 <Nereid> :s
19:51:50 <Twisol> it's just too limiting to restrict yourself to one way to look at software
19:51:53 <aoeu> Open question: Which web framework is more CONSISTENT? Snap or Yesod?
19:51:53 <Nereid> (I could say the same of any language though)
19:52:29 <donri> aoeu: they're both quite consistent i'd say
19:52:43 <aoeu> donri: Consistency is the key.
19:52:50 <aoeu> donri: I don't tolerate inconsistency.
19:53:00 <Twisol> ^_^
19:53:08 <aoeu> donri: Which one is more like haskell?
19:53:17 <startling> aoeu: neither
19:53:20 <aoeu> What's the "pythonic" of haskell?
19:53:22 <parcs`> happstack is most haskelly i think
19:53:26 <aoeu> startling: Why?
19:53:29 <startling> aoeu: neither of them are compiled functional languages
19:53:31 <aoeu> Haskelly :)
19:53:35 <donri> aoeu: depends what you define as haskell. i think happstack is the most haskelly.
19:53:48 <aoeu> parcs: I don't think i like happstack. Not as sexy.
19:53:54 <Nereid> isn't snap or yesod preferred over happstack for new projects?
19:54:02 <aoeu> donri: But why don't people use it?
19:54:06 <aoeu> It's good to be haskelly no?
19:54:08 <parcs`> people use it
19:54:12 <donri> aoeu: uh, lots of people use it
19:54:13 <parcs`> who said nobody uses happstack?
19:54:20 * zzing uses it
19:54:24 <aoeu> donri: It looks big and boring and hard to use.
19:54:37 <parcs`> it's slim and fun and easy to use
19:54:37 <aoeu> It doesn't look as cool as the others.
19:54:41 <donri> duno about boring, but the rest is a bit true
19:54:47 <Clint> at least three people use it
19:54:53 <aoeu> What about Yesod?
19:54:54 <parcs`> it even comes with an awesome tutorial
19:55:02 <aoeu> hmm
19:55:06 <aoeu> I'm not convinced.
19:55:08 <aoeu> Even the name is meh
19:55:11 <parcs`> yesod will confuse the hell out of you if you don't know much haskell
19:55:21 <aoeu> parcs: Because it's haskelly?
19:55:26 <Twisol> parcs`: Doesn't yesod use template haskell too?
19:55:26 <aoeu> Snap sounds nice.
19:55:29 <aoeu> I want to like it.
19:55:30 <Clint> it's sort-of anti-haskelly
19:55:37 <parcs`> aoeu: because it uses exotic ghc extensions
19:55:38 <aoeu> Clint: Yesod?
19:55:40 <ddarius> I wonder about the people in #haskell sometimes (a lot of times).
19:55:44 <Clint> yes
19:55:46 <aoeu> parcs: Yuck
19:55:55 <Nereid> I love exotic ghc extensions.
19:56:03 <Clint> ddarius: we don't exist
19:56:03 <aoeu> Clint: Is Snap haskelly?
19:56:16 <Clint> aoeu: never tried it; xml turns me off
19:56:20 <Nereid> I should probably learn how TH works at some point, though.
19:56:23 <aoeu> Clint: XML?
19:56:26 <Twisol> I'm a fan of OverloadedStringLiterals...
19:56:27 <Clint> yes, xml
19:56:35 <aoeu> Clint: What about it?
19:56:39 <Clint> it turns me off
19:56:46 <aoeu> Clint: What does it has to do with Snap?
19:56:47 <ddarius> Nereid: What's there to learn?  You write a function at compile-time that produces an AST that the compiler compiles.
19:56:57 <Nereid> yes, I get the abstract idea.
19:57:05 <startling> Twisol: yeah, I feel like that's very haskelly
19:57:09 <Clint> aoeu: heist
19:57:20 <startling> now we just needed OverloadedCharLiterals
19:57:23 <aoeu> Are there other cool kids in the haskell web framework block?
19:57:30 <aoeu> Clint: Heist is bad?
19:57:30 <Twisol> startling: why's that?
19:57:34 <aoeu> Clint: You prefer haml?
19:57:40 <donri> aoeu: snap is less type safe than happstack or yesod, but snaplets use "haskelly" concepts like functional references (lenses) and many parts of snap are similar to (inspired by) happstack
19:57:40 <parcs`> ddarius: quasi quotes and splices are somewhat confusing
19:57:41 <aoeu> hamlet*
19:57:49 <startling> Twisol: the WordN family mostly
19:57:54 <Twisol> startling: ah, I see.
19:57:55 <Clint> aoeu: i do prefer hamlet to xml
19:58:00 <tibbe> I need a name for my new CSV package, any clever ideas (csv is taken)?
19:58:02 <aoeu> donri: Snap is Happstack done right?
19:58:10 <ddarius> tibbe: vsc
19:58:17 <Twisol> vcs
19:58:17 <Clint> tibbe: what does it do?
19:58:20 <JoeyA> vsc seems hard to type
19:58:24 <donri> aoeu: according to snap devs. I think it's happstack done part right part wrong. ;)
19:58:25 <aoeu> tibbe csv package in haskell?
19:58:27 <tibbe> Clint: it's basically aeson for CSV
19:58:31 <tibbe> aoeu: yes
19:58:32 <aoeu> donri: :(
19:58:36 <JoeyA> tibbe: What makes it different?
19:58:46 <JoeyA> Oh
19:58:47 <aoeu> donri: I don't tolerate unperfect stuff. What about other new bleeding edge frameworks?
19:58:48 <Nereid> find a word that contains the letters c, s, v in that order.
19:58:49 <tibbe> JoeyA: it uses a aeson type class based approach
19:58:49 <JoeyA> attoparsec-csv ?
19:58:57 <donri> aoeu: nothing is perfect. are you trolling?
19:58:57 <JoeyA> oh
19:59:01 <aoeu> tibbe: HCSV
19:59:03 <JoeyA> csv-simple?
19:59:11 <tibbe> JoeyA: I might use that
19:59:18 <aoeu> donri: I like well designed frameworks. ASP is well designed.
19:59:20 <tibbe> a word with the letter c s v in that order would be nice
19:59:29 <shachaf> There are many such words.
19:59:39 <JoeyA> If only there were a concise way to search for things matching patterns like that.
19:59:44 * Clint chokes.
19:59:45 <aoeu> casanova
19:59:50 <JoeyA> RECURSIVENESSES
20:00:03 <JoeyA> CURSIVE
20:00:10 <shachaf> I wish regexps had "and". :-(
20:00:12 <donri> aoeu: design is subjective. do you mean a pretty (intuitive, consistent) API? do you mean technically "correct"?
20:00:18 <geekosaur> wat
20:00:18 <JoeyA> COHESIVE
20:00:28 <aoeu> donri: Mostly pretty (intuitive, consistent)
20:00:35 <JoeyA> (I'm grepping an all-caps dictionary, and am too lazy to tr A-Z a-z)
20:00:43 <aoeu> donri: Consistency is the most important part for me.
20:01:00 <JoeyA> corrosive
20:01:04 <Nereid> :v
20:01:08 <shachaf> "Consistency is all I ask!" "Give us this day our daily mask."
20:01:09 <donri> aoeu: in that case you're more likely to like snap or yesod than happstack. i think happstack is the most "correct", but certainly not the prettiest since it's the oldest and has a lot of history behind it.
20:01:12 <JoeyA> casava
20:01:17 <lpvb> english is unconsistent and imperfect, yet you use it, aoeu
20:01:27 <donri> aoeu: although happstack 8 will be a big rewrite so will be cleaner after that
20:01:28 <tibbe> :)
20:01:41 <Nereid> conclusive?
20:01:42 <aoeu> lpvb: It's not my native language. My native language is much worse.
20:01:47 <shachaf> #haskell-web is a better channel for discussions of web applications, and of the dictionary.
20:01:52 <Nereid> time to go.
20:01:52 <shachaf> Especially the dictionary.
20:01:52 <aoeu> donri: Hard pick.
20:02:08 <JoeyA> quicksilver
20:02:09 <donri> aoeu: choices are like that.
20:02:24 <aoeu> donri: I think I'll learn haskell first.
20:02:40 <JoeyA> cat /usr/share/dict/words | grep -i '.*c.*s.*v.*'
20:02:45 <aoeu> donri: Which one is the most minimalistic?
20:02:50 <tibbe> JoeyA: that's what I'm doing now :)
20:02:52 <donri> aoeu: that's a good plan, although happstack has good docs for beginners i think.
20:02:59 <ion> joeya: Two redundant .*s in there.
20:03:00 <JoeyA> I like Jacksonville, only because that's where I live ;-)
20:03:12 <aoeu> donri: I don't know why, but I'm not attracted to happstack. I don't know why.
20:03:16 <ion> And a redundant cat. ;-)
20:03:22 <shachaf> ion: :-(
20:03:28 <JoeyA> cassava would be my pick
20:03:32 <donri> aoeu: for minimal you could maybe use wai or snap-{server,core} alone
20:03:38 <tibbe> casava
20:03:41 <aoeu> wai?
20:03:50 <Twisol> ion: pfft, composition is awesome
20:03:54 <tibbe> JoeyA: now lets check so it doesn't mean something offensive
20:03:59 <JoeyA> According to the Internet, you need two Ses to spell it right: http://en.wikipedia.org/wiki/Cassava
20:04:19 <ion> tibbe: What’s wrong with meaning something offensive?
20:04:19 <donri> aoeu: it's basically like CGI but in haskell, used in yesod
20:04:35 <shachaf> "like CGI but in haskell"?
20:04:36 <ion> More like WSGI/Rack, isn’t it?
20:04:43 <aoeu> CGI doesn't sound appealing.
20:04:46 <donri> WSGI/Rack are modeled on CGI.
20:04:54 <startling> aoeu: it's more of a replacement for CGI
20:05:05 <startling> aoeu: not literall "hey let's stick everything in environment variables"
20:05:07 <tibbe> ion: depends how offensive
20:05:20 <donri> well developing for raw WAI isn't really appealing, but you said minimalist.
20:05:21 <tibbe> JoeyA: cassava it is
20:05:34 <aoeu> Maybe I meant simple.
20:05:39 <JoeyA> Hurray, I'm useful!
20:05:41 <aoeu> I'm not sure what I'm looking for.
20:05:44 <Twisol> anything like Sinatra in Haskell?
20:05:45 <startling> aoeu: simple api or simple implementation?
20:05:45 <aoeu> I don't want huge bloated stuff.
20:05:54 <startling> Twisol: I've been wondering that too tbh
20:05:55 <Clint> Twisol: scotty
20:05:55 <Twisol> because it sounds like they want something Sinatra-y
20:05:56 <aoeu> startling: Simple API.
20:06:07 <donri> aoeu: most simple is probably happstack or snap without snaplets
20:06:16 <aoeu> What are snaplets?
20:06:21 <aoeu> Plugins?
20:06:26 <donri> basically, yea
20:06:33 <aoeu> Is it a good system?
20:06:38 <aoeu> Or just a hack?
20:06:58 <donri> quite good, haven't actually used it though :)
20:07:15 <aoeu> Alright, I have enough information now.
20:07:19 <Twisol> aoeu: it sounds like you want something like Sinatra from Ruby; Clint just suggested scotty, and it looks pretty interesting, so here's a link for you to check out: http://hackage.haskell.org/package/scotty
20:07:24 <aoeu> Snap or Happstack.
20:07:35 <aoeu> Twisol: Thanks.
20:07:38 <Twisol> welcome
20:10:21 <donri> aoeu: http://softwaresimply.blogspot.se/2012/04/hopefully-fair-and-useful-comparison-of.html for some history
20:10:29 <amiller> i'm trying to define binary trees operations in terms of a comonad, generalizing the ordinary recursive data structure
20:10:29 <amiller> https://gist.github.com/e8dc7c4c7558af0f994f
20:10:46 <amiller> i'm having trouble finding the right way of using the comonad functions to do this
20:10:48 <aoeu> donri: Thanks, but I already read that one.
20:10:51 <amiller> does anyone know of examples that are similar to this?
20:11:15 <edwardk> amiller: in general comonadic cokleisli actions won't change the shape of the container.
20:11:49 <edwardk> amiller: so i think you are trying to pound in a nail with a screwdriver ;)
20:12:16 <edwardk> insertion will by construction change the shape of the tree
20:12:20 <aoeu> What are the main advantages of Haskell over other languages?
20:12:58 <donri> aoeu: have you read this http://www.haskell.org/haskellwiki/Introduction#Why_use_Haskell.3F
20:13:24 <aoeu> Maybe 6 months ago.
20:13:34 <aoeu> I even started to learn it.
20:13:43 <amiller> the observation i want to make is that using this definition of node, Mu Node k is isomorphic to the ordinary recursive tree
20:13:43 * hackagebot http-types 0.7.3.0.1 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.7.3.0.1 (AristidBreitkreuz)
20:13:59 <aoeu> The thing is, I don't know if it just sounds good in theory, or if it's really good in practice
20:14:17 <aoeu> I really enjoy the design of the language and stuff, but I'm still wondering if it's worth it.
20:14:28 <aoeu> I'm sure you're all biased and will say yes (being here).
20:14:37 <aoeu> But why aren't more people using it?
20:14:49 <shachaf> aoeu: You should ask in #other-languages to get an unbiased answer.
20:14:52 <edwardk> amiller: data Node k d = E | T d k d is clearly not a Comonad though
20:15:00 <mauke> I'm bored by famine.
20:15:03 <edwardk> amiller: so i'm not sure where you are going with this
20:15:39 <shachaf> edwardk: Is there some equivalent of Monad for Contravariant?
20:15:39 <edwardk> Mu (Node k) is the usual tree, yes, but that just needs a Functor, not a Comonad ;)
20:15:44 <edwardk> shachaf: no
20:15:44 <aoeu> shachaf: They won't know as much as you do.
20:16:38 <edwardk> aoeu: i use haskell because i spent 15 years trying to design a neat language with all the stuff i wanted, then i found haskell and it already existed and had better solutions to the problems i was tackling than mine.
20:17:05 <donri> aoeu: this is one of the largest channels on freenode and there are thousands of packages on hackage. plenty of people using haskell.
20:17:06 <amiller> hm you're right, let me try finding an instance of comonad, i at least think i can think of one natural one
20:17:36 <aoeu> Where are the success stories?
20:18:20 <aoeu> edwardk: I love the language, I don't question it. I'm just wondering if people just like the language because it's theorically beautiful, or because it actually helps to get things done.
20:18:25 <edwardk> aoeu: well, lets see, its popular in high assurance computing at galois, in designing chips at bluespec, they have tiny customers like intel and AMD, its being used at standard chartered, credit suisse, here at s&p capital iq, etc
20:18:37 <aoeu> How good is code reuse in haskell? Is it really better since it's pure?
20:18:57 <aoeu> edwardk: Where are startups using it? Beside Silk.
20:18:59 <mauke> is aoeu protontorpedo reincarnated?
20:19:11 <aoeu> mauke: Who is he?
20:19:12 <shachaf> edwardk: But how many Haskell programs are there that let me look at cat pictures? :-(
20:19:31 <aoeu> I want to build something huge.
20:19:37 <aoeu> And I'm considering haskell.
20:19:38 <edwardk> in my experience i have a much easier time reusing code in haskell because haskell being lazy by default encourages you to write the most general solution, because laziness will let it fuse with other algorithms.
20:20:10 <jfischoff> shachaf: yeah I guess it isn't webscale
20:20:26 <aoeu> What makes it not webscale?
20:20:28 * shachaf is a big fan of cat pictures, mind you.
20:20:35 <edwardk> aoeu: i'm pretty far outside of the startup space, so i really don't know who is bothering to cook stuff up in their garage using haskell
20:20:39 <shachaf> @ask typoclass for a cat picture
20:20:40 <lambdabot> Consider it noted.
20:20:41 <donri> aoeu: someone who had used perl for 15 years noted that his haskell code was 20% reusable and his perl code something like 4% reusable. handwavey numbers from memory.
20:20:58 <aoeu> Twisol: Should I read about Sinatra to understand Scotty?
20:21:36 <aoeu> donri: Interesting.
20:21:45 <frio> aoeu:
20:21:46 <parcs`> donri: wasn't perl < 1% reusable
20:21:47 <frio> no
20:21:54 <donri> parcs`: yea don't remember exact numbers
20:21:56 <frio> scotty is tiny and very easy to grok :)
20:22:06 <aoeu> frio: Is it good?
20:22:06 <donri> aoeu: it was the git-annex author btw if you want to look that up
20:22:09 <edwardk> i wrote perl for a decade or so before i switched to haskell as well, i can't think of anything i wrote from my perl era that i'd want to reuse today ;)
20:22:27 <mauke> doesn't that just mean you suck at writing reusable code?
20:22:37 <edwardk> i'm still using the first couple of packages i wrote in haskell
20:22:42 <edwardk> mauke: perhaps =)
20:23:03 <frio> i think so aoeu :)
20:23:06 <frio> for a small site, anyway
20:23:44 <frio> the pain im having in getting it out the door is all me not grokking monads and typing properly; scotty's not been in my way at all
20:24:02 <Rotaerk> hmm a dvoraker
20:24:37 <aoeu> Dvorak!
20:25:03 <aoeu> frio: What stops scotty from being good for large sites?
20:25:21 <aoeu> Let's say I want to build the next Facebook or Google. What framework should I use (before I end up creating my own)
20:25:42 <frio> yesod's the current flavour in haskell web frameworks
20:25:43 <frio> shrug
20:25:46 <frio> it comes down to taste
20:25:58 <aoeu> frio: But they said yesod wasn't haskelly, and hard to ues.
20:26:02 <edwardk> yesod or snap and a whole lot of elbow grease
20:26:08 <aoeu> He's the last in my list.
20:26:10 <frio> if i was building something big, I'd use a framework that provided more in order to get my MVP up and running faster
20:26:22 <frio> and once i'd started growing past what the framework provides, slowly take the training wheels off
20:26:22 <donri> yesod is very haskelly, depending on what you mean by haskelly.
20:26:23 <edwardk> i'm a fan of snap personally
20:26:42 <donri> edwardk is biased because they use his lenses for snaplets ;)
20:26:42 <frio> scotty's awesome, but very very minimal, and you'll spend time developing tooling off the bat, rather than getting your site going
20:26:48 <aoeu> Is warp that good?
20:26:55 <edwardk> donri: i'm biased because of the "classy prelude" =P
20:27:02 <donri> :D
20:27:17 <frio> aoeu: yesod uses lots of DSLs and template haskell
20:27:19 <jfischoff> is classy prelude in yesod now?
20:27:21 <edwardk> donri: though the fact that i know mightybyte pretty well and they use some of my stuff is a nice push over the edge
20:27:38 <frio> it's like rails was initially regarded as "not being ruby" because it did lots of very specific things
20:27:40 <zzing> :t intercalate
20:27:41 <lambdabot> forall a. [a] -> [[a]] -> [a]
20:27:46 <parcs`> @protontorpedo
20:27:46 <lambdabot> whats a module?
20:27:48 <zzing> @hoogle intercalate
20:27:48 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
20:27:48 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
20:27:48 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
20:28:20 <aoeu> But Snap looks more future-proof with snaplets and stuff.
20:28:38 <aoeu> What are you guys MBTI types?
20:28:44 * hackagebot cassava 0.1.0.0 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.1.0.0 (JohanTibell)
20:29:01 <aoeu> That was quick.
20:29:06 <edwardk> there are about 900 of us, this may take a while ;)
20:29:34 <donri> aoeu: happstack has survived since like '01 or something ;)
20:29:46 <aoeu> donri: '05
20:29:52 <donri> aoeu: it was forked from HAppS
20:29:59 <donri> which is older still
20:30:07 <aoeu> "survived"
20:30:18 <aoeu> I want one that can live.
20:30:46 <frio> ultimately, they're all much of a muchness
20:30:50 <frio> pick snap or yesod and go
20:31:00 <donri> you know i can't tell if you're trolling most of the time. if not, you're certainly thinking too hard about things that have no relevance to you yet anyway.
20:31:08 <aoeu> frio: I'll try to pickup haskell before :P
20:31:13 <donri> frio: (or happstack)
20:31:22 <frio> indeed donri
20:31:28 <aoeu> donri: I'm not trolling, I may just think ahead too much
20:31:43 <frio> (although I personally don't like happstack that much, but that's because it left me bruised and annoyed :p)
20:31:56 <aoeu> I don't want to jump into haskell and realize there's no good web framework
20:32:02 <edwardk> aoeu: i've written code for both. yesod is pretty flexible for building one-off applications, and gives you lots of power to compile stuff straight into the executable, but it uses a lot of quasiquotation dsls that make it feel a little unnatural. snap is very 'haskelly' in that it builds up combinators for everything, and focuses on reusable snaplets, etc.
20:32:19 <frio> there are good web frameworks that will last, aoeu
20:32:28 <edwardk> aoeu: there are 2 or 3 usable web frameworks depending on who you ask, so no worries on that front
20:32:31 <frio> but if you can't write haskell yet, then you're putting the cart before the horse
20:32:33 <aoeu> edwardk: I pick Snap.
20:32:36 <aoeu> That's it.
20:32:59 <aoeu> frio: That's what I thought. Can I learn haskell by studying Snap?
20:33:02 <edwardk> aoeu: sounds good. there is a #snapframework channel full of helpful people FYI
20:33:04 <aoeu> I know some basic haskell.
20:33:07 <donri> edwardk: combinators for everything except, well, everything (routing, templating, forms)? :)
20:33:16 <aoeu> I'm in all of these channels right now :P
20:33:27 <edwardk> aoeu: i'd recommend learning haskell itself first through learn you a haskell and/or real world haskell
20:33:38 <trolling> donri: I can confirm that aoeu is not me
20:33:40 <edwardk> donri: touche
20:33:45 <aoeu> I really enjoy "learn you a haskell"
20:33:56 <aoeu> I'm not trolling.
20:34:21 <edwardk> donri: i do a lot of my routing through the combinators and haven't given in to using heist yet ;)
20:34:24 <trolling> no, I'm trolling
20:34:38 <aoeu> trolling, I know.
20:34:42 <zzing> If Haskell cannot deduce (Stream s0 m0 Char)  because I use 'string' which has a constraint of Stream s m Char  but my function has a constraint of Stream String Identity Char  - I am very confused as to what this thing is really trying to say.
20:35:05 <aoeu> Where in LYAH does it explain why I won't miss objects?
20:35:11 <donri> edwardk: well they do use happstack-like Alternative routing but not like boomerang
20:35:53 <edwardk> aoeu: somewhere around when you get through talking about applicatives, and some of the richer typeclasses
20:35:55 <edwardk> ;)
20:36:20 <aoeu> Do I need to know about monads?
20:36:30 <aoeu> And why can something be so hard to understand?
20:36:32 <edwardk> aoeu: they'll come up fairly naturally as you go along
20:36:33 <trolling> monads are useful
20:36:43 <aoeu> for I/O
20:36:46 <trolling> they're just monoids in the category of endofunctors, what's the problem?
20:37:00 <aoeu> Does anyone know a good video about haskell? I'm feeling lazy.
20:37:00 <shachaf> trolling: Are you trolling?
20:37:04 <donri> edwardk: type safe routing using monoid and category: http://www.happstack.com/docs/crashcourse/WebRoutes.html#web-routes-boomerang
20:37:04 <EN1RA> youz trolling
20:37:08 <trolling> shachaf: evidently...
20:37:23 <aoeu> You're sooo trolling.
20:37:31 <trolling> yes, I am
20:37:35 <aoeu> I have a headache.
20:37:41 <donri> doi troling do trolo xu
20:37:57 <edwardk> donri: cute. guess i need to write routing-machines next ;)
20:37:59 <donri> sisi y za'e trolo
20:38:11 <aoeu> Has anyone tried F#?
20:38:18 <trolling> learn you a haskell has a good explanation of monads
20:38:23 <aoeu> Maybe I should stay in the .NET boat and just use F#.
20:39:01 <aoeu> F# is similar to haskell.
20:39:04 <edwardk> f# is a usable crippled ML dialect
20:39:05 <aoeu> *looks*
20:39:05 <donri> edwardk: although there's this https://github.com/stepcut/snap-web-routes-demo
20:39:16 <aoeu> edwardk: Is "usable" good?
20:39:53 <edwardk> i can't say any of the things i want to say in f#. it is perfectly acceptable for writing boring first order code or programing with any particular monad, etc. you just can't write code that spans across them.
20:40:10 <carter> edwardk : would you be able to help me understand what i'm doing wrong with TypeLits in the 7.6rc?
20:40:21 <Saizan> zzing: it's trying to say that it has not information to decide what s0 and m0 should actually be
20:40:22 <edwardk> i haven't played with type lits yet
20:40:35 <edwardk> i don't have the rc installed yet
20:40:36 <carter> i'm trying to (ab)use class instances + type level nats to get absolute difference
20:40:38 <carter> ok
20:40:44 <aoeu> Thank you for everything. I'm going to learn some haskell. I'll be back soon.
20:40:46 <Saizan> zzing: can you show code? it might be caused by the MonomorphismRestriction
20:41:36 <carter> has anyone here played with the rc?
20:41:41 <edwardk> finally found the interesting parts of uniplate. these are proving harder to port ;)
20:41:54 <zzing> Saizan, the annotation is the current version: http://hpaste.org/73609
20:42:10 <edwardk> at least the manual uniplate/niplate instances are nicer with lens
20:42:20 <edwardk> er biplate
20:42:24 <zzing> Saizan, I added NoMonomorphismRestriction and it does compile
20:42:29 <Cale> niplate is the Japanese version
20:42:34 <edwardk> cale: hah
20:43:09 <donri> edwardk: can machines be used for anything you might otherwise use pipes for?
20:43:10 <Saizan> zzing: yeah, since you don't use create it can't deduce what its complete type should be, and the MR won't allow it to be polymorphic
20:43:33 <edwardk> using it in a sentence: "i could have used a niplate when i fell of my skateboard last week"
20:43:33 <lpvb> edwardk: what's so bad about F#? (never used it)
20:43:42 <zzing> Saizan, is that the same problem in the first hpaste I had there?
20:44:00 <edwardk> lpvb: its ml without a module system shoehorned into the CLR. its not bad, but it shows the limitations of where it has to run.
20:44:00 <carter> http://hpaste.org/73611 for anyone who has typelits understanding :)
20:44:24 <lpvb> edwardk: how about clojure, any opinion on that?
20:44:30 <edwardk> you can write higher-order code by abusing inlined type checking -- just so long as you don't use recursion.
20:44:37 <Saizan> zzing: seems so
20:44:51 <zzing> The Shelly stuff seems to suggest Text use
20:44:55 <edwardk> clojure is probably the most usable lisp dialect out there, but take that for what it is worth ;)
20:45:18 <lpvb> how functional compared to haskell is it?
20:45:21 <edwardk> given a choice between scala and clojure on the jvm i'd give the not to scala
20:45:27 <edwardk> er the nod
20:45:33 <lpvb> really?
20:45:35 <donri> someone should make a dependently typed lisp
20:45:36 <shachaf> Class constraints -- like Functor f => ...f... -- would seem to require rank-2 types to express without type classes. But presumably they don't allow as much as general rank-2 types do. Is there a simple way of expressing what they allow?
20:45:44 <lpvb> why scala and not clojure
20:46:04 <zzing> Is there a place I can learn how to implement my own parser combinators?
20:46:15 <EN1RA> It's more of a hybrid
20:46:18 <Saizan> donri: ACL2 is in that area
20:46:19 <lpvb> I like languages that stick to it's paradigm
20:46:32 <EN1RA> scala doesn't
20:46:34 <edwardk> basically the same reason i write haskell and not ml. implicits go a long way towards pretending they are typeclasses, and so you can program a la church rather than a la curry, with the compiler plugging in meaning from the types.
20:46:36 <lpvb> scala looks like everything was put together cheaply
20:47:20 <Saizan> shachaf: PolymorphicComponents seems to be it
20:47:31 <Cale> lpvb: I dunno, I think of it as Java with a less terrible type system.
20:47:34 <edwardk> shachaf: class constraints do pretty much require rank 2 types. this is one reason why we wound up with rank 2 types in haskell. the implementors already had to deal with them to desugar ;)
20:47:39 <carter> whoops, https://gist.github.com/3445218
20:48:02 <shachaf> edwardk: Oh, I thought rank-2 types weren't in Haskell originally because they were harder to implement than type classes.
20:48:23 <shachaf> Can you achieve something equivalent to a rank-3 type using only Haskell 98?
20:48:36 <Cale> lpvb: Whereas clojure has some interesting stuff in it, but the typesystem is nonexistent.
20:48:39 <zzing> Should (string "create" *> many1 space *> (LT.pack <$> many1 letter)  be able to match "create blah"?
20:48:43 <shachaf> With class constraints on class methods, or something?
20:48:45 <edwardk> shachaf: well, i can make a usable version of, say, callCC which is ideally a rank 3 type, by splitting things up
20:48:56 <shachaf> Oh, true.
20:49:04 <shachaf> Althought you can also achieve that with Void. :-)
20:49:18 <edwardk> yes that too
20:49:52 <edwardk> shachaf: anyways i think you only need rank 2 for typeclasses
20:50:08 <edwardk> shachaf: if you start allowing some other extensions you can need rank 3
20:50:12 <Saizan> having you newtype around higher-rank types is a huge help for inference
20:50:15 <shachaf> Hmm, I guess callCC is "forall a. ((a -> forall b. m b) -> m a) -> m a", not "forall a. ((a -> m (forall b. b)) -> m a) -> m a"
20:50:53 <lpvb> idk, Clojure looks more beautiful than scala
20:51:04 <EN1RA> certainly
20:51:06 <edwardk> yeah though the latter can be used, my just making a combinator like vacuousM that you use when you apply it
20:51:13 <shachaf> Right.
20:51:15 <edwardk> that has the benefit that you can stay entirely 98
20:51:31 <edwardk> that is equivalent to the label/goto system i use
20:51:43 <frio> I dislike clojure's lack of types
20:51:47 <lpvb> yea
20:52:04 <EN1RA> Then again, lisp is pretty beautiful by default
20:52:05 <shachaf> I guess "forall a. (a -> r) -> r" is isomorphic to "((forall a. a) -> r) -> r)"?
20:52:11 <frio> but scala has that perl/ruby feeling to me
20:52:19 <frio> one man's scala is not necessarily the next man's
20:52:40 <frio> which makes me substantially more scala-averse than clojure-averse
20:52:42 <edwardk> lpvb: scala has a lot of neat features that were thrown into a blender. you can use any one of them at a time, and everything works great, sometimes even two. but be careful about mixing, say subtyping and implicits, or higher kinded types and existentials, etc.
20:53:03 <edwardk> lpvb: but the thing is there is usually a fairly baroque workaround you can come up with to get by ;)
20:53:28 <frio> I do like clojure though, and one thing I *really* like about it is how modern the libraries and tooling feel
20:53:29 <Saizan> higher kinded and existentials don't mix in scala?
20:53:52 <frio> (client/get "url") is so clean and purdy
20:54:01 <edwardk> Saizan: correct. the bug stands as a wontfix and i've got ways to make the scala compiler flip out when trying to deal with bifunctors and product categories =(
20:54:13 <shachaf> edwardk: Given that you can choose b to be Void even with rank-1, a rank-3 callCC doesn't add that much, does it?
20:54:18 <carter> edwardk whats a good flip out exmaple?
20:54:31 * shachaf wonders whether rank-odd and rank-even types have something in common in general.
20:54:40 <edwardk> carter: github.com/ekmett/magpie try to get the bifunctor code to work
20:54:42 <EN1RA> and apparently that light table IDE is being developed for clojure first.
20:55:01 <frio> clojure/js/python EN1RA, but clojure is definitely the primary :)
20:55:08 <edwardk> carter: if you can make it work in a way that lets you define fmap in terms of bimap or vice versa, i owe you a steak dinner
20:55:17 <frio> the guy writing it has made some rather nice clojure libs too (noir, korma)
20:55:40 <edwardk> carter: as it stands one leads to the scala compiler crapping out, emitting what it thinks is a fully compiled class but which still has abstract methods in it
20:56:02 <edwardk> that was pretty much when i gave up on liking scala and started viewing it as something to be tolerated
20:56:27 <carter> edwardk: oh... is this the example you mentioned at hackphi?
20:56:35 <edwardk> yes
20:56:43 <edwardk> the code in question is in the dinatural-hom branch i thin
20:56:45 <edwardk> er think
20:57:40 <edwardk> oh, no, the dinatural-hom thing was my best attempt at fixing it
20:57:45 <edwardk> https://github.com/ekmett/magpie/blob/master/src/main/scala/magpie/bifunctor.scala is the place that is flat busted
20:58:50 <edwardk> if you uncomment the code in there, the scala compiler goes to a very special place in its head and when it comes back it says 'all done' and gives you back garbage
20:59:32 <carter> edwardk: if I find i'm in the mood to procrasticode in scala, i'll have a look see :)
20:59:49 <edwardk> Saizan: but basically with higher kinded existential type members i've lost count of the ways i can write unsafeCoerce ;)
21:02:15 <edwardk> anyways as much as i hate on it, its still the best option for working on the jvm
21:02:33 <shachaf> edwardk: Are there any interesting subclasses of Contravariant?
21:02:58 <edwardk> shachaf: http://hpaste.org/69758#line30 =)
21:03:13 <edwardk> oh, and http://hpaste.org/69758#line50
21:03:16 <shachaf> Hah.
21:03:34 <edwardk> and http://hpaste.org/69758#line159
21:03:35 <shachaf> What's neg?
21:04:00 <edwardk> used to turn the optimal solution into the pessimal and vice versa by negating it
21:04:35 <lpvb> do you mix imperative, OOP, and FP a lot in Scala?
21:04:37 <edwardk> the code in there is a modified form of Martin Escardo's infinite search in finite time that is parameterized on any contravariant functor
21:04:43 <edwardk> lpvb: yes
21:05:00 <edwardk> lpvb: for instance i recently removed (almost) all the monads from our compiler
21:05:15 <edwardk> i've since started adding them back in, but in a very different way
21:05:40 <edwardk> but the compiler itself is still very functional, it just uses some mutable state to model a state monad ;)
21:05:58 <lpvb> mmk
21:06:07 <edwardk> because to get monads to work in scala you have to choose between fast or correct for large inputs
21:07:10 <edwardk> i find it remarkably unsurprising that martin odersky hates on functional programming. if the principle window that i had to view functional programming through was scala, i'd find it baroque and abhorrent too.
21:09:10 <Saizan> maybe the hate predates scala, and that's why it's designed that way
21:18:43 <carter> the stream semantics interacation with the std lib parser combinators is also a fun gotcha
21:18:48 <carter> *interaction
21:20:26 <edwardk> still on scala? =)
21:21:13 <Sgeo> Funny that I looked at this conversation, I'm currently interested in Lisps and sort of torn between Common Lisp's CLOS and condition system and Clojure's more functionalness and libraries
21:21:36 <Cale> edwardk: So do you guys basically use it because it's the least bad type system on the JVM?
21:22:09 <edwardk> cale: yep. though that said, it did drive us to basically build our own language that has access to the JVM, so take that for what it is worth ;)
21:22:31 <Cale> edwardk: Is that staying internal forever?
21:22:53 <edwardk> Cale: not sure. we're talking about open sourcing it. its more about what corporate says
21:25:25 <Cale> Sgeo: The fact that clojure doesn't treat procedures as second class citizens gives it a big boost vs. Common Lisp in my opinion. :)
21:25:56 <Sgeo> Cale, it treats methods from Java-land as second class, though.
21:25:57 <lpvb> having second thoughts about learning Scala over Clojure
21:26:02 <lpvb> don't know what to pick
21:26:22 <startling> lpvb: clojure!
21:26:31 <startling> and then write a non-jvm implementation for it
21:26:32 <Sgeo> lpvb, which is more important to you, macros, or a strong type system? (Note that each might have other benefits)
21:26:53 * Sgeo personally wants macros more
21:27:01 <Cale> Oh really?
21:27:02 <lpvb> if I write in clojure, I won't be able to convince imperative/OOP people to work with me
21:27:13 <lpvb> I like a strong type system
21:27:21 <Cale> I would give up macros for almost any improvement to my type system
21:27:33 <lpvb> and I hate non-static typing
21:27:34 <zzing> Is there any reason why a file will load up fine in ghci, but produce an error with runhaskell?
21:27:47 <startling> zzing: are you using sdl or opengl?
21:27:59 <djahandarie> The best improvement to Java's type system is removing it
21:28:17 <zzing> startling, no, I am using parsec, shelly, applicative, system.environment, and some data.* stuff
21:28:23 <Sgeo> Not that I dislike static type systems, just that... not having to deal with boilerplate is more important to me. I think.
21:28:26 <Cale> If push comes to shove, it's always possible to write preprocessors to generate code at compile time. Bolting on a type system outside the compiler is considerably harder work.
21:28:59 <Cale> But of course, I'd prefer to just not need code generation in the first place.
21:29:21 <Cale> (I mean above and beyond what the language provides)
21:29:33 <frio> lpvb: having struggled with the same decision previously
21:29:38 <frio> and then spending half a year in scala
21:29:46 <frio> i now work in clojure and haskell in my spare time
21:29:57 <zzing> This is what the source and error is: http://hpaste.org/73612   (so it loads in ghci, but not in runhaskell)
21:30:07 <frio> take from that what you will :)
21:30:18 <startling> zzing: what if you load it in ghci and run "main"?
21:30:24 <Sgeo> I want more languages to have Common Lisp's condition system
21:30:36 <Sgeo> I think if Dylan were a viable language today, I would be using it
21:30:39 <zzing> startling, no problems reported
21:30:43 <frio> I really found scala very painful the instant someone else came to work on the code
21:30:44 <startling> zzing: odd
21:30:57 <frio> including the case where "someone else" was me, 5 months down the track
21:31:12 <frio> with java, python, haskell, and now some clojure code of a similar age
21:31:24 <frio> i can go back to it, and it'll be reasonably readable
21:31:40 <frio> with scala, there's so many ways you can write the exact same thing, you need to be very strict with yourself about what you're writing
21:33:52 <lpvb> frio: I'm thinking I want a better Java then another "personal" language like haskell or clojure
21:33:57 <lpvb> than*
21:34:36 <Sgeo> lpvb, C#?
21:34:37 <Sgeo> >.>
21:35:01 <lpvb> but I like the functional paradigm
21:35:02 <Sgeo> (You didn't specify how much or how little better)
21:35:02 <frio> yeah, that's definitely something to shoot for lpvb
21:35:07 <frio> I just don't think that scala is it
21:35:10 <trolling> how about APL?
21:35:11 <lpvb> I will keep haskell as my personal language
21:35:18 <frio> because the problem I described above compounds itself in larger teams
21:35:29 <frio> when one person writes things functionally, and another is OO/imperative
21:35:32 <Sgeo> lpvb, C# is more functional than Java.
21:35:49 <frio> the code becomes spaghetti :<
21:36:02 <lpvb> Sgeo: I'm on linux and I prefer not to use C#
21:36:06 <Sgeo> Ah
21:36:32 <zzing> startling, any ideas on how I can find out about this?
21:36:54 <frio> is the JVM a requirement lpvb?
21:36:59 <zzing> ghc --make seems to have te same problem
21:37:00 <frio> you could look at Google's Go
21:37:13 <lpvb> frio: yes
21:37:25 <lpvb> I guess I'll learn Scala
21:37:39 <lpvb> I can resort to doing OO if the team wants
21:37:54 <frio> well, it sounds like you're keen on it :)
21:39:49 <startling> zzing: none, sorry
21:42:54 <carter> ok, so looks like i found 2 bugs in type lits
21:42:57 <carter> BLEH
21:48:13 <thirsteh> is there a "de facto" source code formatting tool for Haskell?
21:48:17 <thirsteh> a la indent
21:48:29 <shachaf> Not really.
21:49:00 <thirsteh> ok, thanks anyway!
21:51:50 <nand`> there's something that does source code formatting called stylish-haskell but I don't think it does indenting at all, it mainly concerns itself with sorting and formatting imports afaik; It's also not really ‘de facto’
21:52:54 <applicative> if you want one haskell-src-exts gives you the relevant materials; good luck with comments etc.
21:55:11 <applicative> the coolest option it gives you is one that drops whitespace layout for all semicolons.  I think the module ends up being one line of text... Excellent for total opacity
21:56:22 <edwardk> preflex: xseen kosmikus
21:56:22 <preflex>  kosmikus was last seen on freenode/#haskell 6 days, 18 hours and 58 minutes ago, saying: mm_freak: of course, I absolutely understand you don't want to switch; but regarding being up-to-date, you can just check the distribution data that's on Hackage, and I think that NixOS is currently likely to be distribution with the best Haskell support
21:59:15 <shachaf> Cale: Can we have all the Djinn primitives in L.hs?
21:59:31 <shachaf> data Void; type Not a = a -> Void; void :: Void -> a; etc.
21:59:42 <mauke> if'
21:59:55 <shachaf> if', sure. Though that is decidedly not a djinn primitive.
22:00:01 <shachaf> bool, too, I guess.
22:00:31 <mauke> d'oh, that's @pl
22:02:29 <zzing> How do I "add an instance declaration for (Stream String Identity Char)"  for something like     case parseArgs s of ...
22:05:52 <nand`> instance Stream String Identity Char where ...
22:07:04 <zzing> hmm, I don't know why this doesn't exist already
22:07:30 <edwardk> are there any examples out there of geniplate in the wild? trying to understand the common usage pattern, which isn't obvious from the docs
22:07:38 <zzing> oh there we go, it works now
22:08:33 <edwardk> ah, found an example in the tarball
22:08:35 <zzing> I am trying to understand why "(string "create" *> many1 space *> many1 letter)"  doesn't seem to match "create blah"
22:09:01 <zzing> nvm, I think I found my bug
22:10:13 <frio> zzing: what library are you using for parsing? parsec?
22:10:25 <zzing> frio, yes (and it works now)
22:11:02 <frio> sweet. I need to write a very small parser myself, and that's impressively concise
22:12:28 <zzing>           create = Create <$> (string "create" *> many1 space *> many1 letter <* spaces <* eof)
22:12:42 <zzing> My exposure to applicative style has been rewarding
22:12:49 <zzing> I knew I needed it elsewhere anyways
22:14:28 <shachaf> Hmm, (a -> b) -> Either (Not a) b is equivalent to lem.
22:16:56 <zzing> I love this, works first time:           rename = Rename <$> (string "rename" *> many1 space *> many1 letter <* spaces) <*> (many1 letter <* spaces <* eof)
22:21:08 <JoeyA> What's a good way to test if two Double values are equal, going by their binary representation?
22:21:14 <JoeyA> > compare (0/0) (0/0)
22:21:16 <lambdabot>   GT
22:21:55 <shachaf> JoeyA: I'm not sure you're supposed to be able to do that.
22:21:57 <JoeyA> Meh, I guess I'll just cerealize the things I want to compare.
22:22:07 <shachaf> Why do you want to do it in the first place?
22:22:31 <JoeyA> I'm writing tests (making sure data is getting marshaled into and out of a database correctly)
22:22:37 <shachaf> If you just want to check for two NaNs, you can do that explicitly.
22:22:44 <shachaf> Hm.
22:24:18 * nand` .oO( a == b || not (a <= b || a >= b) )
22:25:23 <zzing> TIL I could do this:     s <- (intercalate " ") <$> getArgs
22:25:35 <shachaf> You don't even need the parentheses!
22:25:43 <nand`> hmm, that breaks when comparing 1/0 and 0/0
22:25:49 <shachaf> You can also (intercalate " " -> s) <- getArgs
22:25:54 <JoeyA> > encodeFloat (0/0) == encodeFloat (0/0)
22:25:55 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
22:25:55 <lambdabot>    arising f...
22:26:05 <shachaf> nand`: 1/0 and 0/0 are different.
22:26:26 <nand`> shachaf: yeah but my function says they're equal
22:26:29 <zzing> shachaf, I thought that intercalate took 2 parameters that it would try to bind tight to <$> as a parameter
22:26:35 <johnw> zzing: what is the data declaration for your Rename constructor?
22:26:43 <zzing>                | Rename String String
22:26:46 <shachaf> zzing: That's not how precedence works.
22:26:49 <johnw> cool, thanks
22:26:50 <mauke> zzing: <$> is an operator. every function takes exactly one argument.
22:26:51 <shachaf> nand`: What's your function?
22:27:02 <zzing> johnw, want to see updated source code?
22:27:09 <nand`> oh, it breaks on all nan come to think of it
22:27:10 <johnw> yes please!
22:27:11 <JoeyA> > decodeFloat (0/0) == decodeFloat (0/0)
22:27:13 <lambdabot>   True
22:27:17 <nand`> shachaf: a == b || not (a <= b || a >= b)
22:27:32 <johnw> i'm trying to test our your code snippet here
22:27:33 <shachaf> nand`: Don't do that.
22:27:42 <nand`> it works for detecting NaN
22:27:43 <johnw> i've never used Parsec before, and now you've pushed me over the edge
22:27:43 <shachaf> nand`: For that matter, don't (==) Doubles in the first place.
22:27:44 <nand`> but that's about it
22:27:45 <zzing> johnw, http://hpaste.org/73613
22:27:56 <shachaf> nand`: a == b || (isNaN a && isNaN b)
22:28:18 <shachaf> But, really, don't == Doubles. :-(
22:28:25 <zzing> nand`, couldn't that be simplified wit demorgan?
22:28:38 <nand`> I'm not the one ==ing doubles here
22:28:40 <zzing> mauke, quite right
22:28:51 <shachaf> Yes, it can.
22:28:54 <nand`> zzing: doubles break <=
22:29:36 <zzing> :t NaN
22:29:37 <lambdabot> Not in scope: data constructor `NaN'
22:29:52 <zzing> Is there a constructor for nan values?
22:29:59 <shachaf> (0/0)
22:30:05 <zzing> > (0/0)
22:30:06 <lambdabot>   NaN
22:30:09 <zzing> > (0/0) == (0/0)
22:30:10 <lambdabot>   False
22:30:13 <zzing> good
22:30:15 <johnw> zzing: that is so cool!
22:30:17 <johnw> it works
22:30:22 <shachaf> NaN stands for "Not another NaN"
22:30:34 <johnw> can you explain why you used the various LANGUAGE extensions?
22:30:37 <zzing> johnw, just learned this stuff today, mostly last few hours getting it to work
22:30:37 <shachaf> Maybe it just stands for "Not a NaN"
22:30:58 <johnw> I only needed FlexibleContexts in my mini-example
22:31:03 <zzing> johnw, some were suggested by shelly
22:31:13 <johnw> ah, I'm a shelly user too
22:31:25 <johnw> you aren't using it in your code though
22:31:41 <zzing> johnw, needed to parse the command line first
22:31:57 <zzing> Now I can write a function that will pattern match over the possible Operations
22:32:01 <johnw> this is what I have: https://gist.github.com/3445885
22:32:19 <applicative> zzing: can the class constraint Stream String Identity Char =>  actually be constraining anything
22:32:28 <johnw> it's the use of => in that code which has me scratching my head
22:32:42 <zzing> applicative, apparently it does, "you can't explain that"
22:32:46 <shachaf> What's Stream?
22:33:02 <zzing> shachaf, the type of input I believe
22:33:03 <johnw> I can drop everything between :: and => and it still works fine
22:33:07 <shachaf> Oh, a Parsec thing.
22:33:08 <zzing> A little more nuanced
22:33:13 <zzing> yes unforatuntely
22:33:15 <johnw> and then I don't need FlexibleContexts
22:33:23 <shachaf> johnw: No need for the Stream constraint if it's all hard-wired like that.
22:33:31 <shachaf> If you have the instance, that is. Which you do.
22:33:35 <johnw> ah, okk
22:33:41 <johnw> reading up on FlexibleContexts now
22:33:55 <zzing> well, I willtry it now
22:34:04 <nand`> doesn't instance selection get deferred to when you actually use the function? ie. I could write a library that assumes some absurd instance and it would compile fine until somebody loads it and tries using my function?
22:34:05 <shachaf> That's like saying add5 :: Num Int -> Int -> Int; add5 x = x + 5
22:34:09 <zzing> shachaf, well it works
22:34:20 <edwardk> mgsloan: neat. the 'every' traversal from hac phi turns out to be exactly the traversal i need to define biplate, etc generically
22:34:20 <shachaf> nand`: It doesn't matter here.
22:34:20 <zzing> Some of it was just to fix problems that were here
22:34:43 <nand`> I think FlexibleContexts is needed for all instances that aren't of the form “Class var var var var”
22:34:53 <nand`> constraints*
22:34:56 <zzing> johnw, the applicative stuff *> <* and so on, I interpret as 'pointing' to what is going to be returned
22:35:37 <johnw> yeah, that part is easy to read
22:35:38 <zzing> I would like parsec to handle white space for me though
22:35:54 <zzing> using applicative also saved me lines and lines of monoid do code
22:35:54 <johnw> a *> b <* c, means you want to parse a, then b, then c, but you only want to use the results from b
22:36:05 <zzing> si
22:36:06 <edwardk> zzing: that works pretty well until you go to mix *> and <* for more than one thing. after that, it is best just avoid using *>
22:36:25 <edwardk> er best to
22:36:39 <zzing> edwardk, I think with the stuff I have been doing it is okay, more complicated stuff would be out I am sure
22:36:49 <nand`> I tested what I asked earlier, it seems I was wrong; you actually need to specify the instance constraint to compile the module
22:38:10 <johnw> i wonder how inefficient choice is
22:38:20 <johnw> is it LL(1), or does it backtrack all the way back for each one that fails?
22:39:36 <johnw> i guess it would have to do backtracking, given how loosely it's defined in the docs
22:39:47 <edwardk> johnw: you have to explicitly try to get any backtracking
22:39:58 <johnw> so, if many terms began with "many1 space", it could get wasteful
22:40:00 <edwardk> i mean literally, by using 'try' ;)
22:40:15 <johnw> oh, it doesn't implicitly rewind?
22:40:19 <pharaun> no
22:40:23 <johnw> ok, good
22:40:24 <edwardk> not unless you ask for try
22:40:37 <edwardk> that lets it cut off those continuations
22:40:53 <johnw> is choice [a, b, c] === a <|> b <|> c?
22:40:54 <edwardk> the moment it consumes and isn't in a try block all those possibilities die
22:41:05 <edwardk> pretty much
22:41:31 <johnw> it's a nice way to write parsers
22:41:44 <edwardk> i'm rather fond of it ;)
22:42:08 <edwardk> been trying to shoehorn a GLL parser into that model for a year now in my spare time
22:42:16 <johnw> and this is from someone who has written parsers more different ways than I can remember, include building my own parser construction kits long ago
22:42:32 <edwardk> thats one reason why the 'parsers' package doesn't require MonadPlus
22:42:32 <nand`> (what about trifecta?)
22:42:41 <startling> johnw: it's a PEG parser
22:42:45 <edwardk> (it only requires Alternative)
22:42:49 <startling> johnw: unlimited backtracking
22:42:54 <johnw> in recent years I've taken to always hand-coding RD parsers, but I like Parsec a lot
22:43:15 <edwardk> nand`: well, i like trifecta a lot. i'm just still open to new points in the design space, and GLL would be dead sexy to have as a DSL in haskell
22:44:06 <nand`> I've never done parsing in Haskell but I've done a lot of monadic parsing in C#
22:44:14 <edwardk> it would give you parsers that are commutative under extensions. so if you made two language extensions, and turn them both on, you'd have no ordering issues
22:44:20 <nand`> unfortunately it was somewhat limited since defining mutually recursive parsers was hard
22:44:30 <edwardk> yeah, thats downright crippling
22:44:34 <edwardk> we had that problem in scala
22:44:47 <nand`> I managed to work around it for my domain but it was ugly
22:44:52 <edwardk> i finally gave in and just wrote a properly trampolined parser that could deal with mutual recursion gracefully
22:45:10 <edwardk> most productive 2 days i ever spent ;)
22:45:49 <zzing> edwardk, where can I learn how to write my own parsing stuff in the area of combinators? I am not very up on much beyond basic parsing
22:45:56 <edwardk> i tend towards recursive descent with some PEG processing for common branches, but i really want to get GLL working
22:46:37 <edwardk> zzing: well, there is a lot of lore out there on the parsec style of parsing, swierstra has a writeup (pretty old) about uu-parsinglib, the original arrow papers were motiated by swierstra and duponcheel's parser.
22:46:54 <edwardk> the dragon book is awful but it covers LALR vs. LL(k) etc.
22:47:11 <zzing> edwardk, I usually hear nothing but praise for the dragon book
22:47:15 <johnw> I really like Holub's front-end books
22:47:20 <johnw> out of print, but crystal clear
22:47:44 <johnw> I was able to construct top-down and bottom-up LL parsers on _paper_ based on his presentations
22:47:46 <zzing> Say I wanted to learn enough to be able to implement a parser combinator library in haskell or c++ or something like that, are there any free resources around?
22:47:49 <dolio> The dragon book is like 50%+ how to write parsers in C.
22:47:52 <dolio> If you're into that.
22:47:52 <edwardk> spiewak has some stuff online about GLL parsing. you find a lot of stuff on parsing in the natural language community. earley style parsing is easy to understand, CYK, also
22:48:27 <edwardk> the dragon book didn't age well, imho
22:48:59 <johnw> i never cared for the dragon book
22:49:00 <Nafai> This was one of my favorites about parsing, though specific to CL: http://home.pipeline.com/~hbaker1/Prag-Parse.html
22:49:03 <johnw> just its cool cover
22:49:15 <johnw> I think I traded it to my cohort on the RTL team for his Perl book :)
22:49:34 <edwardk> zzing: i have a short blurb on how to write a packrat parser in haskell using a parsec-like approach: http://comonad.com/reader/2011/a-parsec-full-of-rats/
22:49:36 <johnw> dolio: sadly, I'm *still* writing parsers in C
22:49:51 <zzing> I think the Hutton book might have done something about doing parsers
22:50:27 <zzing> hmm, trifecta
22:50:43 <edwardk> zzing: another way to do it might just be to look at http://hackage.haskell.org/packages/archive/parsers/0.3/doc/html/Text-Parser-Combinators.html and try to figure out how to build an instance of Parsing
22:51:06 <edwardk> once you've done that you've got a parser ;)
22:51:21 <zzing> hmm, might be able to figure the stuff out
22:51:25 <zzing> Well, time to sleep now
22:51:30 <zzing> Peace be with you all
22:51:37 <edwardk> also most of the combinators in there work with just alternative, etc.
22:54:49 <Cale> I commend the good taste in use of type variables in that module.
22:55:31 <nand`> ‘m bra -> m ket -> m a -> m a’
22:55:50 <Cale> also, even just  skipOptional :: Alternative m => m a -> m ()
22:56:04 <mauke> m bop
22:56:20 <Cale> A lot of libraries *cough* forkIO *cough* mess that up.
23:00:32 <mikeplus64> is there a way to do something like "cast cast y of Just (foo :: Int) -> ...; Just (y :: Double) -> ...; Just (x :: String) -> ..."
23:00:34 <mikeplus64> ?
23:00:45 <edwardk> Cale: a lot of them started as monads, and i was too lazy to change m to f ;)
23:01:05 <mauke> mikeplus64: I don't think so
23:02:27 <edwardk> hrmm i suppose i should make a Data.Typeable.Lens module with a traverseTypeable that tries cast
23:02:56 <Cale> edwardk: oh, well, I don't care about the difference between m and f
23:03:00 <Cale> edwardk: in this case
23:03:08 <edwardk> just the a?
23:03:12 <Cale> edwardk: but just that a yes
23:03:22 <Cale> some people would make that () which is tasteless imo
23:03:22 <mikeplus64> mauke: yeah, i can just call cast over and over but that is quite lame
23:03:29 <edwardk> oh blech
23:03:33 <mauke> mikeplus64: you're not supposed to use cast
23:04:05 <mikeplus64> what are you trying to say mauke, that i would use cast, that's a nasty allegation you're making there
23:04:10 <edwardk> i'm vehemently against this 'foam pad the world' movement that started making it a warning to avoid looking at a result type, etc.
23:04:11 <mikeplus64> (i kid)
23:04:53 <edwardk> just because something might be an error for someone somewhere, i don't see why i should have to waste time round tripping through a huge monad transformer stack to put a () i'm never going to look at in there
23:20:03 <sheldonh> lol. try haskell says "Here's where the magic begins!" very late
23:34:32 <johnw> I think "fix" is cool
23:35:04 <shachaf> Especially in Curry-Howard!
23:36:47 <shachaf> Why does running "cabal build; cabal build" link executables both times?
23:37:41 <johnw> hmm.. fix is hard to define in Lisp, without laziness
23:38:18 <shachaf> You can't define it on values but you can define it on functions.
23:38:30 <shachaf> fix f = f (\x -> fix f x)
23:38:33 <shachaf> In a strict language.
23:38:47 <shachaf> (In lisp you can define it without recursion at all, of course. Unlike Haskell.)
23:39:06 <johnw> here's what I came up with: https://gist.github.com/3446704
23:39:19 <johnw> I couldn't find a way to pass "fix f" as the second arg to the partially applied f
23:39:37 <shachaf> That's not fix.
23:39:49 <johnw> how so?
23:40:08 <johnw> i mean, the fix function is not fix
23:40:12 <shachaf> Right.
23:40:17 <johnw> it would have to be (apply-partially f (fix f))
23:40:23 <shachaf> You can make an actual fix function.
23:40:36 <shachaf> @google y combinator
23:40:37 <lambdabot> http://ycombinator.com/
23:40:37 <lambdabot> Title: Y Combinator
23:40:41 <johnw> you mean, one that is not higher-order?
23:40:42 <shachaf> Wrong one. :-(
23:40:49 <shachaf> @google y combinator fixed point
23:40:50 <lambdabot> http://en.wikipedia.org/wiki/Fixed-point_combinator
23:40:50 <lambdabot> Title: Fixed-point combinator - Wikipedia, the free encyclopedia
23:40:58 <shachaf> http://www.ccs.neu.edu/home/matthias/BTLS/sample.ps
23:40:59 <johnw> i was trying to get a fix that returns a function
23:41:13 <shachaf> Right.
23:41:13 <johnw> not one that simply recursively calls the passed-in function at the time fix is called
23:41:14 <mauke> (defun fix (f) (lambda (&rest args) (apply f (cons (fix f) args))))
23:41:29 <johnw> ohh
23:41:29 <mauke> untested port of my perl code
23:41:30 <shachaf> That works.
23:41:48 <johnw> that's actually just about what apply-partially expands into
23:41:55 <shachaf> You can also do it curry-style with a function that returns a function.
23:41:58 <johnw> so maybe this code is lazy enough
23:42:31 <shachaf> (defun fix (f) (f (lambda (x) ((fix f) x))))
23:42:35 <shachaf> Or something. I don't know.
23:43:15 <mauke> needs more funcall
23:44:05 <shachaf> :-(
23:44:21 <mauke> I'm pretty sure ((...) ...) is invalid in CL
23:44:26 <shachaf> [1]> ((lambda (x) (+ x 1)) 5)
23:44:27 <shachaf> 6
23:44:27 <mauke> unless the first ... starts with lambda
23:44:31 <johnw> this is it: this works:
23:44:32 <shachaf> ...Oh.
23:44:35 <johnw> this is it: https://gist.github.com/3446771
23:44:40 <mauke> lambda is syntactic magic
23:44:53 <johnw> it uses poor man's closures, since I was testing in Emacs Lisp
23:44:53 <shachaf> Why is it invalid? It's not ambiguous, is it?
23:44:59 <Ralith> CL is a lisp-2
23:45:12 <mauke> shachaf: it has no meaning
23:45:22 <mauke> ambiguous would be 2+ meanings
23:45:27 <shachaf> Right.
23:45:34 <shachaf> I meant more "why did they make it invalid?".
23:45:36 <johnw> shachaf: you must have evaluated that in Scheme
23:45:41 <mauke> shachaf: what would it mean?
23:45:43 <shachaf> johnw: I didn't evaluate it anywhere.
23:45:52 <johnw> ah, will it would have worked in Scheme
23:46:03 <shachaf> mauke: (funcall (...) ...)?
23:46:04 <johnw> but Lisp, the function argument is special in a retarded way
23:46:10 <johnw> yes, exactly
23:46:13 <shachaf> I know they have different namespaces.
23:46:20 <shachaf> But even so.
23:46:21 <mauke> shachaf: that would be a weird special case
23:47:04 <johnw> in (a b c), `a' is not evaluated in a Lisp-2, it's looked up as a symbol; in a Lisp-1, it's evaluated to return a function atom
23:47:19 <mauke> this is where Perl got the idea, btw
23:47:39 <Ralith> well, not necessarily as a symbol
23:47:45 <Ralith> see: ((lambda ...) ...)
23:47:52 <mauke> ...
23:47:55 <Ralith> but as a function designator.
23:47:57 <johnw> (a b c) == (funcall (symbol-function 'a) b c)
23:48:01 <shachaf> mauke: It would be a special case but not that weird a special case, I think.
23:48:10 <startling> johnw: where do I read about these?
23:48:20 <johnw> startling: about Lisp-1 vs. Lisp-2?
23:48:50 <johnw> http://hornbeck.wordpress.com/2009/07/05/lisp-1-vs-lisp-2/ is one place
23:49:08 <startling> johnw: thanks
23:49:13 <sheldonh> does "let" appear a lot in real programs? i'm being introduced to it at tryhaskell.org, and it... doesn't feel functional
23:49:26 <mauke> I use it all the time
23:49:28 <johnw> sure
23:49:29 <shachaf> sheldonh: Yes, it does.
23:49:30 <Nereid> all the time
23:49:44 <shachaf> sheldonh: "let" is just giving a name to a value.
23:49:46 <sheldonh> okay, will suspend disbelief. thanks
23:49:53 <johnw> think of "f = ..." at the top-level as a global let, and it will feel a lot more functional
23:49:53 <shachaf> It's not a mutable variable or anything. Names are good.
23:50:27 <mauke> if you ignore types, let v = E in B  ==>  (\v -> B) E
23:50:31 <sheldonh> it's just that, in the REPL at tryhaskell.org, immediately after doing "let square x = x * x in square 10", neither square nor x are in scope
23:50:43 <Nereid> that's correct
23:50:56 <mauke> yes, because 'in ...' is the scope of the let bindings
23:51:02 <sheldonh> ah, so it's *not* variable assignment
23:51:03 <mauke> and the 'x' isn't even in let
23:51:09 <mauke> it's just a parameter
23:51:18 <sheldonh> *ding* got it, hanks
23:51:21 <Nereid> but yes, see mauke's translation.
23:51:25 <johnw> let is just naming an expression
23:52:01 <Nereid> well.
23:52:07 <johnw> yeah, ok, scratch that
23:52:18 <sheldonh> it feels like an inline function definition to me
23:52:19 <johnw> I forgot for a second that let can also pattern match and define functions
23:52:24 <johnw> it's much richer than Lisp's let
23:52:27 <mauke> > let pi = 3 in pi
23:52:28 <lambdabot>   3
23:52:37 <Nereid> sheldonh: sure.
23:52:53 <johnw> it's like letrec+flet+destructuring-bind
23:53:01 <johnw> s/flet/labels
23:53:07 <mauke> > let _ + _ = "hi" in 'x' + True
23:53:07 <lambdabot>   "hi"
23:53:23 <mikeplus64> and then, what confuses and/or amuses many:
23:53:25 <Twisol> weeird.
23:53:30 <mikeplus64> > let 2 + 2 = 3 in 2 + 2
23:53:31 <Nereid> > let hi = "hi" ++ hi in hi
23:53:31 <lambdabot>   3
23:53:33 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
23:53:42 <johnw> yeah, that one still gets me
23:53:46 <Nereid> which?
23:53:53 <johnw> the recursive function case
23:54:02 <mauke> it's not a function
23:54:04 <johnw> i'm just not using to thinking in terms of nullary functions
23:54:08 <johnw> s/using/used
23:54:09 <Twisol> That reminds me a lot of something from my calculus class.
23:54:12 <mauke> there are no nullary functions
23:54:22 <johnw> f = 10 is like a nullary function, isn't it?
23:54:25 <mauke> no
23:54:33 <Nereid> for some definition of "no"
23:54:34 <mauke> unless you define "nullary function" as "value"
23:54:38 <Nereid> which you should
23:54:39 <johnw> and I do
23:54:50 <johnw> in Haskell, that is
23:54:53 <sheldonh> the first thing i'm doing is aliasing fst to first. honestly!
23:54:57 <mauke> johnw: no, everywhere
23:55:13 <liyang> functions are values too.
23:55:14 <mauke> sheldonh: and what do you call first instead?
23:55:15 <Nereid> > let hi x = "hi" ++ x in fix hi
23:55:17 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
23:55:27 <Twisol> > fix ("hi"++)
23:55:29 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
23:55:30 <sheldonh> mauke: there's also a first? *sigh*
23:55:36 <johnw> I Lisp, I have to call a nullary function, which makes it very different from a value
23:55:44 <johnw> first is in Arrow
23:55:45 <mauke> > first (*2) (5, 6)
23:55:46 <lambdabot>   (10,6)
23:56:08 <mauke> johnw: in Haskell, every function takes exactly one argument
23:56:30 <sheldonh> tiny language, huge standard library. i think i need to get out of tutorial land fast and get into reference material asp
23:56:44 <johnw> mauke: hmm....
23:56:59 <sheldonh> where one argument can be a tuple, though, right?
23:57:03 <mauke> sheldonh: yes
23:57:06 <johnw> so values really are different from functions in Haskell?
23:57:17 <Nereid> functions are a certain kind of value
23:57:20 <Nereid> eh, type
23:57:22 <johnw> 10 is not a function returning 10?
23:57:26 <Nereid> 10 is 10
23:57:29 <mauke> johnw: no, what would that even mean?
23:57:32 <Twisol> I see a function as a value dependent on another value.
23:57:35 <sheldonh> ah, a deer hunter moment
23:57:37 <mauke> johnw: a function returning itself?
23:57:38 <johnw> ahh
23:57:40 <johnw> this makes sense
23:57:41 <Nereid> a function is a value of a function type
23:57:43 <johnw> functions are morphisms
23:57:44 <shachaf> > 10 "hello"
23:57:45 <lambdabot>   10
23:57:46 <sheldonh> "This is this. This ain't somethin' else."
23:57:48 <johnw> values are objects
23:57:49 <shachaf> Totally a function returning 10.
23:57:54 <Nereid> shachaf: pfffft.
23:57:57 <johnw> together they form the category
23:58:03 <Nereid> johnw: types are objects
23:58:05 <shachaf> johnw: Values aren't the objects in Hask.
23:58:07 <mauke> shachaf: a white lie
23:58:07 <johnw> oops
23:58:13 <johnw> values are...?
23:58:19 <shachaf> Irrelevant.
23:58:22 <johnw> lol
23:58:24 <Nereid> pointless.
23:58:45 <johnw> so what does Int -> Int mean?
23:58:49 <johnw> is that an "endofunctor"?
23:58:54 <Nereid> it is a type
23:59:01 <johnw> or is any Haskell function an endofunctor?
23:59:05 <Nereid> no
23:59:06 <mauke> that looks like the type of functions from Int to Int
23:59:17 <Nereid> an endofunctor (on Hask) is a thing in the Functor typeclass
23:59:26 <Nereid> (that satisfies the laws, etc)
23:59:29 <johnw> ahh
23:59:33 <mauke> @src Functor
23:59:33 <lambdabot> class  Functor f  where
23:59:33 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
23:59:35 <sheldonh> ah, life gets better when google tells you about prelude :)
23:59:45 <shachaf> Nereid: Lots of endofunctors in Hask can't be instances of Functor.
23:59:54 <Nereid> example.
23:59:59 <pharaun> sheldonh: hayoo/hoogle are your friend
