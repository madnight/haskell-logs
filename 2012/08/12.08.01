00:00:02 <zzing_> ok, meric
00:05:37 <ddarius> zzing_: When you get around to writing the binding, you'll need a tool like hsc2hs or c2hs.  The FFI is pleasant enough to use directly, but it knows nothing about the field offsets in structs, only your C compiler knows that, and entering them in by hand is error-prone, fragile, and dangerous.
00:06:01 <zzing_> What is the difference between them?
00:07:26 <ddarius> c2hs has more bells and whistles, but it is a little more heavy-weight than hsc2hs.  Since I usually just use the FFI directly, I tend to lean toward hsc2hs.  Also, the way hsc2hs is implemented is cute.
00:10:22 <zzing_> oh using C to generate hs?
00:10:56 <c_wraith> using haskell to generate c to generate haskell
00:11:24 <ddarius> c_wraith: And in the via-C days, to generate C.
00:11:45 <c_wraith> I was, honestly, quite surprised to see how it worked when I was using it and wanted to debug something by looking at the intermediate source
00:12:40 <ddarius> Nowadays, I guess you could use TH to avoid separate tools entirely.
00:12:50 <ddarius> I'm not aware, off-hand, of a TH library to do that.
00:13:45 <c_wraith> are the tools available to TH?
00:13:57 <c_wraith> I guess it could call the C compiler directly
00:14:01 <ddarius> c_wraith: You can do arbitrary IO in TH.
00:16:49 <beefcube> c_wraith: i took you're advice :P https://github.com/jfeltz/testsync
00:16:51 <johnw> latro`a: ok, I need your help
00:16:57 <beefcube> your*
00:17:49 <johnw> latro`a: https://gist.github.com/3224459
00:18:02 <johnw> I cannot figure out why it wants Tree (Tree a) on line 97
00:20:10 <latro`a> you're still going to have a problem with that >>= btw
00:20:18 <latro`a> I think
00:20:19 <johnw> how so?
00:20:22 <latro`a> wait
00:20:22 <latro`a> nvm
00:20:25 <johnw> k
00:20:26 <latro`a> makeNode takes three trees
00:20:30 <johnw> yep
00:21:26 <latro`a> ...I'm not sure you can get away with this Ord
00:22:05 <johnw> that was another error I was having before
00:22:09 <johnw> but I'm completing stumped on the current one
00:22:21 <johnw> Expected Tree (Tree a0), but got Tree a0?
00:22:30 <johnw> I can see that I'm passing the constructor a Tree a0
00:22:36 <johnw> why would it want a Tree (Tree a0)?
00:23:39 <johnw> ah
00:23:43 <johnw> i see
00:23:46 <johnw> node' Empty i = Leaf i
00:23:49 <johnw> should be node' Empty i = i
00:23:57 <johnw> wow, the compiler wasn't very forthcoming with that one!
00:24:06 <johnw> now I have the Ord problem back
00:24:33 <latro`a> actually, I suspect without exposing the Monad class, which you can't do without hiding it
00:24:40 <danil> johnw: it's usually a good idea to put a type signature on the function, that way it doesn't infer something unexpected and then confuse you when other parts (which you think are correct) don't match it
00:24:43 <latro`a> you can't actually put the Ord constraint in
00:25:01 <johnw> well, that's just a little troublesome
00:25:14 <johnw> how do I provide a self-balancing Tree?
00:25:19 <latro`a> I'm not entirely sure how to do the tree surgery without Ord; can you do it based on structure alone?
00:25:41 <johnw> no, since the user can return from f whatever the heck they want
00:25:48 <johnw> well
00:25:54 <johnw> I suppose it's really up to them to caveat emptor
00:26:02 <johnw> whatever f returns, gets substituted in, period
00:27:04 <danil> if you just want to control the depth of the tree, you can keep track of the depth (or rank) of each subtree on the node and use that to do the surgery
00:29:05 <johnw> well, it actually all worked
00:29:22 <johnw> though I'm not sure about my definitions for makeNode
00:29:30 <johnw> makeNode l Empty r = makeNode Empty l r <-- feels awfully fishy
00:31:17 <johnw> but thanks for all your help latro`a
00:31:40 <latro`a> np
00:32:36 * hackagebot msgpack-rpc 0.8.0 - A MessagePack-RPC Implementation (HideyukiTanaka)
00:33:27 <akamaus> Hi all. I'm trying to debug a stack overflow in my icfpc-2012 parser code. This is the loop which triggers the problem, I believe. http://hpaste.org/72421 . Can anyone give an advice?
00:40:35 <Aoi_> =)
00:43:35 <johnw> what do you think of this latro`a: https://gist.github.com/3224680
00:43:46 <johnw> that might actually be correct...
00:44:17 <VitamnP> Hi, I'm a beginner at Haskell. Can anyone tell me why I get this error in my function? Function and error -> http://bpaste.net/show/A2pKNBgWojwoCQEIxGmD/
00:45:09 <shachaf> VitamnP: The first step is to write out the type of your function.
00:45:12 <johnw> what is the type of t?
00:45:19 <Ralith> VitamnP: write a type signature for your function; this is good practice, helps ensure you understand what you are doing, and improves errors.
00:45:36 <VitamnP> it's a boolean
00:45:42 <shachaf> Then think of the types of everything involved.
00:45:48 <VitamnP> OK, I will try that
00:45:52 <shachaf> In particular, "t", "result", and "[t] ++ result"
00:46:19 <VitamnP> thanks
00:46:29 <latro`a> ...I'm trying to see how the last statement (which is the important one) recurses
00:46:44 <latro`a> ah
00:46:45 <latro`a> nvm
00:46:54 <latro`a> try it for a small case?
00:47:11 <johnw> I'll have to cook up a bunch of cases
00:47:13 <johnw> I just tried it on Node (Node (Leaf 2) 3 (Leaf 4)) 5 (Leaf 8)
00:47:13 <latro`a> once you've done that, you've got the (admittedly arduous) task
00:47:21 <latro`a> of showing it for the associativity of >>= law
00:47:29 <johnw> heh
00:47:33 <latro`a> (it's actually the associativity of >=>)
00:47:34 <johnw> well, this is all just a toy example anyway
00:47:36 <johnw> so I may stop here
00:48:00 <johnw> but one rule I'd like to ensure
00:48:10 <latro`a> so wait, do you apply f to the value at the node?
00:48:16 <latro`a> (link that bigger one?)
00:48:18 <johnw> is that x >>= Leaf = x
00:48:31 <johnw> https://gist.github.com/3224459
00:48:43 <latro`a> well
00:48:47 <latro`a> for Empty and Leaf it's easy
00:49:22 <latro`a> (btw, the separate Empty Empty Empty case actually fallows from the second or third equation)
00:49:29 <latro`a> (so it's redundant)
00:49:54 <johnw> oh, cool
00:50:07 <latro`a> *follows
00:50:19 <VitamnP> Ahhhh I've got it, ty shachaf and Ralith. Writing the type sig helped
00:50:37 <johnw> too tired now, gotta crash; see you, and thanks again latro`a
00:50:58 <latro`a> GAH :|
00:51:03 <latro`a> I just got it
01:05:33 <gertc> http://stackoverflow.com/questions/11731941/haskell-facebook-exceptions
01:08:49 <lamefun> hi
01:08:58 <lamefun> Are programs in haskell written all-static?
01:09:22 <lamefun> Is there no downcasting?
01:09:51 <latro`a> don't know what you mean by either of those questions
01:09:53 <nand`> I have no idea what downcasting means
01:10:36 <shachaf> latro`a: Haskell doesn't have subtyping so that question doesn't really make sense. :-)
01:10:42 <lamefun> Parent parent = new Child();
01:10:43 <shachaf> lamefun: Er, ☝
01:10:47 <mgsloan> downcasting == unsafe cast to subtype
01:10:50 <lamefun> Child child = (Child)parent;
01:11:06 <mgsloan> e.g. we're in the generic type, and we declare that we believe it to be a subtype
01:11:15 <nand`> Haskell doesn't have casts, especially not unsafe ones. (Shush you unsafeCoerce people)
01:11:30 <confusing> hello lamefun. haskell in my opinion is the best of dynamic languages like python, because you don't have to write a lot of type signatures everywhere, combined with the best of static languages, i.e. guarantees that many things can't happen
01:11:46 <shachaf> mgsloan: FSVO "unsafe" -- in Java it's just an exception.
01:11:55 * mgsloan hides "unsafePerformIO launchNukes" behind back
01:12:05 <sopvop> "you don't have to write a lot of type signatures everywhere" unless you enable enough type system extensions :)
01:12:07 <confusing> lamefun: haskell's type system is different from e.g. java's. there is no inheritance, for example, and no downcasting
01:12:12 <mgsloan> right, that was a bad choice of words
01:12:29 <shachaf> (And in C++ it's also safe with dynamic_cast.)
01:13:05 <nand`> class Coerce a b where coerce :: a -> b -- write a bunch of instances and have the compiler infer casting?
01:13:11 <mgsloan> shachaf: right, but you can't downcast with dynamic_cast
01:13:17 <Ralith> of course, few C++ projects enable RTTI, so dynamic_cast is often unavailable
01:13:33 <confusing> c++, paragon of safety ...
01:13:51 <lamefun> what's wrong with RTTI?
01:13:53 <shachaf> mgsloan: Isn't that the whole point of dynamic_cast?
01:13:58 <nand`> isn't C++'s type system turing complete either way? I'm sure you could solve this statically, and safely :)
01:14:15 <shachaf> Anyway, this shouldn't turn into a discussion of C++.
01:14:26 <lamefun> can I for example
01:14:35 <shachaf> lamefun: Haskell is very different from C++, so you should ask higher-level questions than that if you want to get good answers. :-)
01:14:48 <lamefun> data Event = KeyPressed | KeyReleased | MouseMoved | Custom;
01:15:04 <lamefun> then if event is custom, the handler can cast it into other type
01:15:12 <lamefun> for example JoystickEvent
01:15:13 <shachaf> No, Custom is just a value.
01:15:31 <mgsloan> shachaf: ahh, you're right!
01:15:33 <shachaf> It's like enum Event { KeyPressed | KeyReleased | MouseMoved | Custom } except a new type.
01:15:39 <lamefun> Is there an equivalent of void* in Haskell?
01:15:42 <sopvop> Event is just an enum
01:15:56 <shachaf> lamefun: Yes, you can get casts if you really really want to.
01:16:03 <shachaf> But, uh, don't. :-(
01:16:08 <nand`> lamefun: there are ways to implement dynamic typing with safe casting but you shouldn't
01:16:13 <sopvop> No void and no null, and pointers only in ffi bindings.
01:17:54 <nand`> (except for, well, Void, Maybe and Foreign.Ptr)
01:17:55 * nand` hides
01:18:09 <nand`> oh, Foreign.Ptr is FFI bindings
01:19:16 <lamefun> so having it all-static is best?
01:19:22 <mgsloan> and Maybe is a little bit like C#'s practice of marking variables as "Nullable", except nicer and can be added as a library instead of being in the language
01:19:27 <nand`> lamefun: yes, welcome to the wonderful world of strong static typing
01:20:03 <nand`> mgsloan: Nullable can be implemented in C# too; with the benefit of it working even for reftypes
01:20:18 <nand`> but that's using the usual sumtypes hack
01:21:09 <covi> Hi guys. I want to write a script that deals with copying files. Shoud I use System.Process or something else?
01:21:12 <mgsloan> nand`: Ah.  I don't know the sumtypes hack.  Does that get around "Just x" potentially taking more space than "Nothing"?
01:22:14 <shachaf> covi: What does System.Process have to do with copying files?
01:22:15 <mgsloan> (kindof assuming we're in the land of using pointer-flags to indicate which constructor was used)
01:22:17 <shachaf> You want to call cp?
01:22:21 <covi> shachaf: cp?
01:22:29 <covi> shachaf: for executing cp, things like that?
01:22:40 <nand`> mgsloan: sumtypes hack: tagged union using an Enum for your various constructors and defaulting fields otherwise (if you don't want to waste the space for large valuetypes you can wrap them inside a lambda then null that instead)
01:22:43 <shachaf> Well, there's always copyFile...
01:22:55 <shachaf> Anyway, if you want to run programs, System.Process is probably a good choice.
01:23:22 <mgsloan> nand`: Gotcha, thanks.  I may be writing some C# in the nearish future, so good to know!
01:23:32 <nand`> eg. class Maybe<A> { bool isJust; Func<A> Just; }
01:23:44 <nand`> that could work if you want to avoid wasting space
01:23:47 <nand`> but this is off-topic here
01:23:50 <covi> looks like System.Directory is what I need shachaf
01:25:07 <mgsloan> nand`: Well, poking fun at the hacks necessary in other languages to do what Haskell does naturally is /somewhat/ ontopic ;)
01:25:38 <nand`> mgsloan: oh, I do this all the time just for fun: http://pastebin.com/KFfkMDjE
01:25:38 <mauke> The paste KFfkMDjE has been copied to http://p3rl.org/9064UZYI
01:25:51 <nand`> the amount of loops I have to go through to implement free monads in C# is mind-boggling
01:26:02 <nand`> compare with the haskell definition ~30 SLOCs
01:26:09 <nand`> (for the entire program, including main)
01:26:34 <confusing> nand`: your understanding of "for fun" is at variance with mine :-)
01:26:46 <mroman> You're doing monads in C#?
01:26:53 <nand`> confusing: fun pointing and laughing at C#'s type system afterwards
01:27:06 <fmap> mauke: p3rl.org?
01:27:26 <nand`> I can't even ignore bound vars in C#'s do-notation, I have to write “x <- subroutine; y <- bell; z <- done”
01:29:03 <mroman> C# has a do-notation?
01:29:07 <nand`> mroman: more or less. type system restrictions limit me to using duck typing hacks
01:29:12 <sopvop> so from == >>= and select = return?
01:29:20 <mroman> Besides do statement while expression
01:29:22 <nand`> mroman: yeah, dressed up under a different name and more complex for no arbitrary reason than Haskell's
01:29:40 <mroman> What's its name?
01:29:49 <nand`> mroman: Linq
01:30:02 <latro`a> erm
01:30:06 <sopvop> so c# has monads?
01:30:08 <latro`a> "no arbitrary reason"....???
01:30:09 <nand`> sopvop: not quite, the way ‘select’ works is a bit different
01:30:17 <nand`> latro`a: sorry, “no real reason”
01:30:33 <nand`> sopvop: and it has monads, yeah. But not in the type system
01:30:56 <mgsloan> nand`: In lenq's defense, GHC also defaced comprehensions with SQL-like operators
01:30:58 <nand`> technically, they aren't even monads
01:31:24 <nand`> since they aren't required to implement ‘return’ <- wouldn't even work very well in C#
01:31:37 <nand`> so a Bind would be more accurate
01:31:52 <nand`> mgsloan: yeah, I stumbled across those a while back
01:34:14 <nand`> mgsloan: to be fair, GHC's version is still much better than, yknow, actual SQL
01:34:30 <nand`> which is seemingly based on pure nonsense rather than formalized using a relational calculus or something
01:34:53 <nand`> relational algebra, rather
01:35:15 <mgsloan> nand`: True, true :)  It is more reasonable.  Still not very powerful for having added keywords
01:36:55 <sopvop> is there function Either -> Maybe in base?
01:37:08 <latro`a> Control.Error.Util
01:37:15 <latro`a> specifically Control.Error.Util.hush
01:37:28 <sopvop> ooh, hush is like reverse of note?
01:37:31 <latro`a> (the answer to your actual question is "no", however)
01:37:32 <latro`a> yes
01:37:43 <sopvop> cool, thanls
01:37:46 <sopvop> thanks
01:37:49 <latro`a> np
01:38:47 <mgsloan> wow, that's a brilliant name
01:39:05 <latro`a> it really is
01:39:05 <sopvop> program is getting bigger, and code size gets smaller. It's amazing.
01:39:15 <merijn> sopvop: :D
01:39:28 <merijn> sopvop: Everytime edwardk releases a new library my code size shrinks ;)
01:39:37 <latro`a> lol
01:39:49 <nand`> every time edwardk releases a new library my pride shrinks too
01:40:06 <sopvop> so, you have found use for latest herpiderpicomonoids? :)
01:40:19 <merijn> nand`: That too
01:40:19 <nand`> sopvop: you haven't?
01:42:00 <sopvop> Nope, and unfortunately edwardk uses lazy documentation technique
01:42:21 <latro`a> afaict, edwardk's documentation is...this channel
01:42:26 <latro`a> (about 3/4 joking)
01:42:54 <sopvop> yeah, someone need to teach lambdabot to convert it to haddock
01:42:55 <merijn> sopvop: Well, fortunately you can figure out lenses mostly from the types
01:44:05 <nand`> mostly
01:44:58 <nand`> at any rate, (%%~) is quite easy to understand
01:45:49 <latro`a> ...didn't that one turn out to be id
01:45:50 <latro`a> >.>
01:46:03 <latro`a> (or was that the joke)
01:46:25 <sopvop> http://hackage.haskell.org/package/lens these lens?
01:46:26 <mroman> @hoogle combinations
01:46:27 <lambdabot> No results found
01:46:32 <mroman> @hayoo combinations
01:46:33 <lambdabot> Unknown command, try @list
01:47:03 <mroman> Too bad.
01:47:45 <confusing> maybe haddock should for each undocumented function insert a derogatory remark, like "what is he doing?", "i have no idea about this. i doubt he himself has."
01:48:08 <sopvop> "your docs are bad, and you should feel bad"
01:48:15 <mroman> I'd need a function [a] -> Int -> [[a]] which generates all possible combinations using [a] up to a given length.
01:48:45 <latro`a> I approve of sopvop's suggestion
01:48:50 <latro`a> actually
01:48:52 <latro`a> you know
01:48:55 <mroman> Maybe mapM will do the job.
01:48:57 <latro`a> ...gimme a minute to find it
01:49:02 <confusing> mroman: permutations?
01:49:08 <confusing> @hoogle permutations
01:49:08 <lambdabot> Data.List permutations :: [a] -> [[a]]
01:49:08 <lambdabot> package action-permutations
01:49:31 <merijn> mroman: Permutations with replacement or without?
01:49:44 <latro`a> that...probably won't work, at least not without a lot of excess processing
01:49:44 <sipa> or repeating combinations?
01:49:45 <sopvop> > permutations "abc"
01:49:46 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
01:50:00 <sopvop> like that?
01:50:06 <latro`a> I mean, you can take substrings of the permutations and nub
01:50:09 <latro`a> but that is horrifyingly slow
01:50:28 <merijn> latro`a: It's going to be slow regardless
01:50:35 <latro`a> true, but that gets to like
01:50:36 <latro`a> n^3
01:50:37 <merijn> Seems like an exponential problem to me
01:50:39 <latro`a> or some such madness
01:50:42 <latro`a> erm
01:50:48 <latro`a> n^3 *after* the permutations
01:50:53 <latro`a> which are themselves *factorial*
01:51:04 <latro`a> so it's super-factorial, which is very bad
01:51:34 <sopvop> maybe list is small enough no-one will notice
01:51:42 <latro`a> the possible permutations less than or equal to n should actually be polynomial
01:51:43 <latro`a> if n is bounded
01:51:50 <latro`a> erm
01:51:51 <merijn> Product(i -> k) n^i, where n is initial list length and k is max length of the output
01:51:52 <latro`a> combinations
01:51:54 <latro`a> not permutations
01:52:16 <sipa> mroman: it seems unclear what you mean; can you give an example?
01:52:23 <latro`a> permutations make it factorial but significantly smaller than actual n!
01:52:30 <merijn> latro`a: Permutations is also correct, there's two definitions of permutation (i.e. with repetition and without)
01:52:41 <mroman> > let combinations c n = mapM (>>c) (replicate n "_") in combinations "10" 2
01:52:43 <lambdabot>   ["11","10","01","00"]
01:52:49 <latro`a> I'm a mathematician more than computer scientist, merijn :p
01:52:50 <nand`> confusing: funny
01:52:57 <nand`> confusing: taking inspiration from @src ?
01:53:02 <merijn> latro`a: In math too, I had a very long discussion about this in the channel before
01:53:10 <mroman> sipa: ^- I need that :)
01:53:26 <sipa> ok, so he means repeating permutations
01:53:36 <confusing> nand`: yeah :) lambdabot's remarks when something is not found
01:53:46 <mroman> > let combinations c n = mapM (>>c) (replicate n "_") in combinations "1234567890" 2
01:53:47 <lambdabot>   ["11","12","13","14","15","16","17","18","19","10","21","22","23","24","25"...
01:53:49 <merijn> latro`a: With a US math guy who got very upset and confrontational about that usage (which is common for mathematicians doing combinatorics here in the Netherlands), after looking it up, most math authorities (i.e. mathworld, wolfram, etc) agree both definitions are common
01:53:56 <mroman> Will generate me a list of "00" to "99"
01:53:59 <latro`a> huh
01:54:07 <latro`a> that's interesting
01:54:19 <latro`a> anyway
01:54:31 <latro`a> sorry if the maintainer of this package is actually here
01:54:32 <latro`a> but
01:54:46 <mroman> But I have to make it more general.
01:54:55 <latro`a> http://hackage.haskell.org/packages/archive/hmatrix/0.14.0.1/doc/html/src/Data-Packed-Internal-Common.html#app1 if you scroll up a little bit, you see the best/worst comment ever
01:55:10 <mroman> > let combinations c n = mapM (>>c) (replicate n "_") in combinations [1,2,3] 2
01:55:11 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
01:55:13 <merijn> mroman: More general than what?
01:55:15 <mroman> oh. That works.
01:55:27 <confusing> latro`a: i actually lol'd :) thank you
01:55:29 <mroman> I thought it would throw me a type error due to "_" being a string.
01:55:58 <nand`> > replicateM 2 [1..3]
01:55:59 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
01:56:16 <merijn> latro`a: heh
01:56:32 <latro`a> (still no idea what any of those *do*, btw)
01:56:35 <merijn> I empathise with how he must have felt writing that comment
01:56:35 <mroman> nand`: Thanks.
01:56:58 <latro`a> (afaict only app3 and smaller are used, but I have no idea what even app3 does)
01:57:27 <int-e> > let mg (x:xs) (y:ys) = map (x:) (mg xs (y:ys)) ++ map (y:) (mg (x:xs) ys); mg [] ys = [ys]; mg xs _ = [xs] in foldM mg [] . group . sort $ "0112"
01:57:29 <lambdabot>   ["0112","0121","0211","2011","1012","1021","1201","2101","1102","1120","121...
01:59:49 <nand`> > let combsUpTo = foldr (++) (const []) . map replicateM . enumFromTo 0 in combsUpTo 2 [1..3]
01:59:51 <lambdabot>   [[],[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
02:01:05 <mroman> But "replicateM n xs" works too?
02:01:13 <mroman> why all the other stuff?
02:01:44 <latro`a> gets you the smaller ones
02:01:45 <nand`> I thought in your original question you wanted “all combinations of a certain length up to n”, which would include 0-length and 1-length combinations too (for n=2)
02:01:54 <merijn> mroman: For the same reason people like doing sudoku's and obfuscated code competitions :p
02:02:09 <nand`> that extra gunk is just getting replicateM 0 xs ++ replicateM 1 xs ++ replicateM 2 xs ++ ...
02:02:20 <int-e> [0..2] >>= \n -> replicateM n [1..3]
02:02:21 <mroman> Oh. No.
02:02:33 <mroman> I meant "of length n". Sorry
02:02:41 <nand`> int-e: oh hey, that's much cleaner
02:02:47 <nand`> I should have seen it coming
02:02:59 <mroman> But I can use that too :)
02:03:03 <merijn> nand`: \x y -> mapM (flip replicateM y) [0..x] ?
02:03:22 <merijn> > (\x y -> mapM (flip replicateM y) [0..x]) 2 [1..10]
02:03:24 <lambdabot>   [[[],[1],[1,1]],[[],[1],[1,2]],[[],[1],[1,3]],[[],[1],[1,4]],[[],[1],[1,5]]...
02:03:29 <merijn> hmm
02:03:35 <merijn> Nope, that's wrong
02:03:53 * sopvop has just found out what class Enum does, and is amazed.
02:05:43 <mroman> nand`: Although yours gives me a type error for const o_O
02:05:46 <sopvop> Likee  data MyEnum = Case1 | Case2 | Case3 | Case4 deriving (Enum); allCases = [Case1..]. And more! Intead of explicit listing!
02:06:00 <nand`> > enumFromTo 1 >=> flip replicateM [1..3] $ 2
02:06:02 <lambdabot>   [[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
02:06:16 <nand`> mroman: it relies on instance Monoid m => Monoid (r -> m)
02:06:26 <nand`> use int-e's instead :D
02:06:51 <LaughingMan> is it possible to do dynamic dispatch in haskell?
02:07:53 <int-e> > let mg 0 _ _ = [[]]; mg n (x:xs) (y:ys) = map (x:) (mg (n-1) xs (y:ys)) ++ map (y:) (mg (n-1) (x:xs) ys); mg n xs ys = [take n (xs ++ ys)] in foldM (mg 2) [] . group . sort $ "01211"
02:07:55 <lambdabot>   ["01","02","20","10","12","21","11","12","21"]
02:08:04 <sopvop> LaughingMan: like with type classes?
02:08:21 <merijn> LaughingMan: How dynamic?
02:10:30 <LaughingMan> like this: http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP (should have searched first)
02:11:44 <Kakadu> hi! I'm studing parsec. I want to write parser f >>= g where f parses integer value and g returns Just _ when integer is accept some conditions and Nothing otherwise. Now I can't understand how to build Parsec.Prim.Error value
02:12:11 <covi> I want to get a file's content into a string then lines it. What should I use? liftM?
02:12:40 <Jafet> You can use liftM
02:12:43 <gspr> Possibly a stupid question, but am I correct in believing that mallocing from a Pool (in the sense of Foreign.Marshall.Pool, i.e. pooledMalloc) is significantly faster than ordinary malloc?
02:13:27 <covi> Jafet: yep
02:14:14 <covi> @src liftM
02:14:14 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:14:19 <Jafet> I doubt there is any need to build a Prim.Error value
02:14:29 <covi> @src (<$>)
02:14:29 <lambdabot> f <$> a = fmap f a
02:14:52 <sopvop> is there a function like if, i.e.  if :: Bool -> a -> a -> a? my hoogle fails
02:14:52 <merijn> gspr: Yes, normally malloc has to do quite a bit of locking/synchronisation to be threadsafe
02:15:16 <merijn> gspr: Also fitting, pool allocation usually can cut out some of that
02:15:27 <Jafet> No, but you can write if very easily
02:15:31 <merijn> gspr: And for some allocators they may just decide one pool per thread and ignore locking
02:15:34 <int-e> LaughingMan: It's usually the wrong question to ask. A lot of things can be done using higher order function (bundle a value of type  a  with a function  a -> String, for example) or  type classes (which are a way of associating functions with a type, like 'show'). At the end of the spectrum there are classes like Data.Typeable but in my experience you almost never have to use these. Before you wonder about dynamic dispatch,...
02:15:40 <int-e> ...think about the data types that you're going to use. (Inheritance can be modelled in Haskell, but isn't a natural way to accomplish things, so the question of dynamic dispatch often does not even arise.)
02:15:49 <covi> liftM vs. <$>, is there any reason to use one over another?
02:16:04 <Jafet> Aesthetic reasons
02:16:09 <merijn> covi: liftM is for monads, <$> works on any applicative (or maybe even functor)
02:16:16 <nand`> <$> works on any functor
02:16:16 <confusing> covi: i like symbols more than words, but really it's just a matter of taste
02:16:20 <merijn> covi: But mostly readability is they key decision factor
02:16:36 <merijn> I use liftM sometimes, fmap others, <$> yet other times
02:16:40 <nand`> usually I'd just use ‘liftM’ when I have code reading ‘liftM2’ right next to it
02:16:42 <confusing> gspr: when in doubt, profile? :)
02:16:55 <covi> I see
02:16:57 <int-e> nand`: which could be liftA2 ;)
02:17:14 <nand`> I use <$> instead of `fmap`, but fmap when I'm partially applying it
02:17:27 <nand`> or when I want to preserve sanity among symbol goop
02:17:28 <Jafet> But but liftA2 is just _ <$> _ <*> _
02:17:45 <merijn> nand`: Except when partially applying on the right hand side, then I prefer (<$> foo) to (flip fmap foo)
02:17:47 <nand`> int-e: sure, it's just that importing Control.Applicative everywhere can be a hassle
02:17:52 <nand`> merijn: agreed
02:18:05 <int-e> nand`: I know :)
02:18:15 <Jafet> (`fmap` foo)
02:18:45 <nand`> Jafet: sure but consider foo x y z = x <$> y <*> z   vs   foo = liftM2
02:18:57 <int-e> (I'd love Control.Monad to import and re-export Control.Applicative)
02:18:58 <nand`> well, maybe not exactly that example
02:19:04 <nand`> liftA2*
02:19:06 <Jafet> That's why you have mixfix syn... oh wait
02:19:23 <timthelion> Am I allowed to have an infinitely recursive type deffinition?  Like type Block = [Either Block Tok]?
02:19:29 <donri> you have to import liftM* too
02:19:36 <merijn> timthelion: Sure
02:19:44 <timthelion> nice :)
02:19:46 <Jafet> types are created with the keyword data.
02:19:48 <merijn> timthelion: Well, maybe not with type
02:19:48 <int-e> timthelion: no. only newtypes and data types
02:20:22 <merijn> timthelion: type is an alias, not the declaration of an actual (data) type
02:20:28 <timthelion> int-e: OK :/ I'm fine with that I guess.
02:20:45 <nand`> eg. instance Monoid m => Monoid (r -> m) where mempty = pure mempty; mappend = liftA2 mappend -- sure beats mappend a b = mappend <$> a <*> b
02:21:02 <merijn> "data Block = Block [Either Block Tok]" or a similar newtype would work
02:21:23 <Jafet> Can newtypes be recursive?
02:21:29 <nand`> yes
02:21:35 <timthelion> merijn: OK, a little unusual, but I'll take it
02:21:49 <nand`> newtype Fix f = In { out :: f (Fix f) }
02:22:23 <int-e> actually you can do this using type families: type family Block; type instance Block = [Either Block Int]. But you will drive the type checker crazy.
02:22:27 <merijn> timthelion: The compiler tries to substitute type aliases directly, which'd turn into an infinite expansion at compile time. newtypes and datas are not similarly expanded
02:22:34 <gspr> merijn: As I hoped, then. Thanks.
02:22:56 <timthelion> merijn: I know, that's what I was afraid of.  Wonder if GHC just hangs, or simply expands 1 level, or errors out :)
02:23:09 <nand`> “Cycle in type synonym declarations”
02:23:12 <LaughingMan> int-e: what i want to do: Have an object in a state monad. The concrete type of this object is unknown at runtime, but it is of a specific typeclass. Do some action on the concrete type of the object.
02:23:14 <gspr> confusing: True, but a crude approximation can often be had in much less time by asking here. Moreover, said approximation is often accompanied by wise comments such as "well, you shouldn't really..." or "why don't you just..." :)
02:24:15 <confusing> gspr: sure :) just take the crude approximations with a grain of salt. premature optimization and all that :)
02:24:27 <gspr> confusing: Absolutely, I agree
02:25:00 <gspr> confusing: But in my case I'd have to be mallocing perhaps 30 times a second. That feels wrong nomatter the actual performance :P
02:25:39 <timthelion> My skin tingles every time I hear the words "premature optimization", last time I "just wrote" a program without overthinking preformance, I had to entirely restructure it to get it to work at a usable speed :(
02:26:30 <int-e> LaughingMan: well you can use the operations of the type class then, making the function polymorphic, can't you? (say, foo :: MyClass a => [a] -> State (MyState a) a)
02:28:34 <sopvop> timthelion: premature optimization is nothing compared to premature refactoring
02:28:34 <int-e> timthelion: so you wrote a prototype ;) (algorithmic optimizations are often prudent (but the time used for designing a better algorithm has to be weighed against the running time later on); the premature optimizations are those that trade small performance gains for readability)
02:29:16 <covi> @hoogle FilePath -> [FilePath]
02:29:17 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
02:29:17 <lambdabot> System.FilePath.Posix splitDirectories :: FilePath -> [FilePath]
02:29:17 <lambdabot> System.FilePath.Windows splitPath :: FilePath -> [FilePath]
02:32:13 <timthelion> int-e: I get the point about not reusing flags to save 3 bytes in modern C programs(I'm totally guilty of this :) :) ) but the thing that bit me there, was it turned out that GTK was too slow to render all the widgets that I wanted, so I'll have to end up writing a whole bunch of drawing code(luckly I used model-view, so my backend doesn't need to change one bit)
02:33:34 <merijn> sopvop: Refactor early, refactor often!
02:33:58 <timthelion> Honestly, when I write C code like that, it's always 3 am and I always have it ALL in my head, like I see the stars from above ect...  It's the compiling that sucks :D
02:34:09 <sopvop> merijn: And never ship!
02:34:39 <merijn> sopvop: Ha, you can't ship if your codebase sucks either. At least not the next version :p
02:35:11 <timthelion> sopvop: I agree, shipping software just lets it fall into the hands of the dumb, uneducated, and undeserving masses.  We should always share our software on github without a cabal file.
02:35:12 <confusing> timthelion: that's of course unfortunate, but i wonder if premature optimization would have helped. and still, if we agree that it's helpful to do some amount of informed consideration of performance, then i'd maintain that lots of people do lots of idiotic things in the name of performance. like yelling at each other over replacing cat with "<" in some shell script that runs once per day
02:36:53 <timthelion> confusing: I agree with you on those points.  But the group of people who have pushed the "anti-premature optimization" stuff have been the worst python scripters who transfer data via xml strings through DBus known to man :(
02:37:26 <timthelion> and they have proven the points of those of us who actually do re-use byte width flags :(
02:38:09 <sopvop> make fast . make right $ make work it
02:38:46 <Peaker_> confusing, I think the pandulum swung way too far towards the "don't prematurely optimize" camp...
02:39:52 <merijn> timthelion: I'm pretty sure the python people hate DBus and XML more than premature optimisation
02:40:12 <merijn> Peaker_: Nah, some idiots just heard "don't prematurely optimize" and understood "don't design at all"
02:40:53 <timthelion> merijn: I have a hard time beleiving that, looking at the current state of the gnome project :(
02:40:58 <Peaker_> merijn, Wirth's law has taken hold because of this...
02:40:58 <confusing> timthelion: you're right :) for the record, i was referring more to knuth. and i like the wulf quote too http://en.wikipedia.org/wiki/Program_optimization#Quotes
02:41:29 <Peaker_> "Computers have gigabytes of RAM, so why not just allocate a dozen MB for every little entity in our software?"
02:41:30 <merijn> timthelion: You are confusing two similar statements
02:41:32 <timthelion> merijn: most of them don't realise that the objects they are "pickling" are getting squished into a giant xml mess :D
02:42:01 <merijn> timthelion: Python people hate DBus and XML, I didn't say people who hate DBus and XML hate python (unfortunately)
02:42:13 <merijn> As such python adoption amongst idiots has been steadily on the rise
02:42:17 <covi> @hoogle FilePath -> Bool
02:42:17 <lambdabot> System.FilePath.Windows hasDrive :: FilePath -> Bool
02:42:17 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
02:42:17 <lambdabot> System.FilePath.Windows hasExtension :: FilePath -> Bool
02:42:38 <merijn> covi: You can privmsg lambdabot with @hoogle too
02:43:03 <covi> I want to use the value of doesFileExist path after a guard, how can I extract the value
02:43:13 <covi> merijn: oops, sorry, i se
02:43:37 <merijn> covi: Why are you using doesFileExist? That is (almost) always the wrong approach
02:43:46 <Peaker_> merijn, IMO Python is one of the better dynamic languages
02:43:54 <merijn> doesFileExist is an extremely racy function
02:43:57 <covi> merijn: ...
02:44:21 <Nafai> I wish I didn't have to use Python so much
02:44:24 <merijn> Peaker_: Oh, I agree, but the community quality (while still excellent) has declined a little with increasing popularity
02:44:31 <covi> merijn: what can I use instead? want a function that judge if a path refers to a file or a di
02:44:34 <covi> *dir
02:45:14 <merijn> covi: Best solution is to just try to open it and see if that works or fails. Example, what happens in your program if doesFileExist returns true and in the meantime someone runs "rm foo; mkdir foo"?
02:46:07 <merijn> Granted, that's a small chance, but the filesystem is full of race conditions like that. You're better off just trying and dealing with errors gracefully
02:46:28 <donri> hackage2 could have used some premature optimization; it's using gigabytes of memory for what takes 20mb on disk -.-
02:47:05 <covi> merijn: right. But I haven't learned to deal with exception in haskell
02:47:18 <confusing> Peaker_: i'm not sure about the pendulum having swung towards no optimizing. it feels like in here you still regularly can read advice like "don't use 'reverse' on your 50-byte String, it's O(n)", failing to realize that it's just as likely the O(n) will be trumped by cpu cache effects, and measuring/profiling should take priority over superstitions anyway
02:47:42 <merijn> covi: It can be very easy depending on how sophisticated you want to be
02:47:56 <merijn> covi: If you're okay with just crashing with an error at runtime, its trivial :p
02:48:56 <merijn> covi: It throws an exception when that happens
02:49:36 <Peaker_> confusing, I don't think #haskell is necessarily representative, though
02:50:02 <Peaker_> confusing, I am personally very dissatisfied with the performance of the software I use
02:52:29 <Jafet> Durr, what's a cpu cache?
02:54:06 <confusing> Peaker_: i see. a lot of people, including me, sympathize with that. clearly it's a selling point when e.g. chrome is faster than firefox (thought not faster than opera 8-) )
02:55:00 <covi> merijn: I still want to know how to extract value from IO in a guard
02:56:03 <danil> covi: you can't, guards have to have type Bool
02:56:31 <Peaker_> confusing, well, browsers are pretty high-profile.. On that matter, I think Chrome has become slower, though I have not measured anything
03:01:52 <confusing> Jafet: i'm not an expert, but when the cpu accesses ram, that byte in memory *and* a number of the following bytes are fetched into a very small very fast memory on the cpu itself (l1 and l2 caches, some cpus have l3). so for the first byte you have to wait a while, while the following ones arrive quicker (orders of magnitude quicker). that's why e.g. linearly walking through an array is faster than you think, regardless of it being O(n)
03:01:55 <confusing> </handwaving>
03:05:25 <confusing> in other words, an O() analysis might assume that each access to ram takes equal time, which might be true on some theoretical turing machine but not on any computer anyone actually uses
03:05:27 <rfw> @pf \x -> x `mod` 2 /= 0 && x `mod` 3 /= 0 && x `mod` 5 /= 0
03:05:27 <lambdabot> Maybe you meant: bf pl
03:05:33 <confusing> </morehandwaving>
03:05:43 <rfw> @pl \x -> x `mod` 2 /= 0 && x `mod` 3 /= 0 && x `mod` 5 /= 0
03:05:43 <lambdabot> ap ((&&) . (0 /=) . (`mod` 2)) (ap ((&&) . (0 /=) . (`mod` 3)) ((0 /=) . (`mod` 5)))
03:05:46 <rfw> oh jesus no
03:07:01 <danil> rfw: you probably want (\x -> all (/= 0) . map (x `mod`) $ [2, 3, 5])
03:07:03 <donri> confusing: of course, a string is a list is not an array
03:07:10 <rfw> danil: ah, neat
03:08:13 <donri> confusing: which might be what people mean when they warn against reverse on a list of chars. a text in turn is packed and might actually benefit from cpu caching?
03:08:21 * donri no expert either, though
03:08:57 <shurikas> where should I start if I wanted to write a wrapper module for existing C code in Haskell?
03:09:15 <confusing> donri: have some <handwaving> tags, i just bought a large pack of them
03:09:58 <shachaf> People don't usually say "don't use reverse" for performance reasons.
03:09:59 <donri> \o/
03:10:24 <danil>  |
03:10:32 <donri> shurikas: maybe http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html
03:10:47 <shurikas> thanks
03:11:08 <donri> shachaf: ah, is it more that lists are potentially infinite?
03:13:24 <akamaus> I have a program which successfully processes large input in ghci but fails with stack overflow when compiled.
03:13:35 <akamaus> what might be the reason?
03:13:56 <shachaf> donri: That's certainly an extreme case of caring about performance. :-)
03:14:01 <donri> ^_^
03:16:28 <pshr> Hi, I am new to haskell and I have been trying to use runProcess from System.process I am getting the following error
03:16:29 <pshr>  No instance for (Data.String.IsString (Maybe FilePath))       arising from a use of `vmxpath'     Possible fix:       add an instance declaration for       (Data.String.IsString (Maybe FilePath))     In the third argument of `runProcess', namely `vmxpath'
03:16:31 <nexx> akamaus what optimization did you used?
03:16:50 <madjestic> hey guys.  I am trying to understand haskell infrastructure better.  I used cabal to install many things, not quite knowingly what I was doing.  I managed to have laksah and ghci running, code gets compiled - so basics seem to be covered.  Now I want to know where all the haskell-related things live.  I want to know where all the packages, installed by cabal live.  Should I look into cabal-install or ghc-pkg for this indormation?
03:16:52 <pshr> vmxpath is a String and i guess it is complaining that it should be Maybe Filepath
03:16:56 <akamaus> nexx, I tried -O and -O2.
03:17:14 <pshr> how do I change that string to FilePath ? Some thing like Typecasting in imperative langs
03:17:16 <shachaf> madjestic: Both.
03:17:21 <shachaf> @src FilePath
03:17:21 <lambdabot> type FilePath = String
03:17:27 <shachaf> pshr: It's a synonym. :-)
03:17:45 <Nafai> does anyone have suggestions for examples of well-written programs using gtk2hs I could look at as examples?  Or maybe someone experienced that could tell me how to improve something I've already written?
03:17:47 <akamaus> I was looking for the source of space leak, and suddenly discovered it doesn't exist in ghci
03:18:31 <pshr> shachaf: then why is it failing while building
03:18:43 <akamaus> Nafai, which aspects are you trying to improve?
03:18:49 <shachaf> pshr: If I could read minds, I would tell you. :-(
03:19:02 <shachaf> pshr: As it is, you might have to hpaste.org your code and error message.
03:19:25 <merijn> confusing: There's a really nice paper by PHK that talks about how big O analysis is a big lie in modern systems and shows how an unoptimal algorithm may beat optimal algorithms by an order of magnitude
03:19:27 <alpounet> pshr, according to your error message, vmxpath is inferred to be a 'Maybe FilePath' actually
03:19:42 <hpaste> pshr pasted “Error while building in yesod” at http://hpaste.org/72422
03:19:59 <shachaf> merijn: Huh? That doesn't say it's a lie.
03:20:13 <shachaf> That says your constants matter.
03:20:16 <merijn> shachaf: Lie in the sense of pointless
03:20:26 <shachaf> Which is always the big disclaimer when doing asymptotic analysis.
03:20:27 <merijn> shachaf: No
03:20:36 <confusing> merijn: phk -- is that the "varnish" man and longtime bsd developer?
03:20:45 <merijn> shachaf: Because the difference in constants neglible in his example
03:20:47 <hpaste> pshr pasted “Code for Maybefilepath” at http://hpaste.org/72423
03:20:49 <merijn> confusing: Yeah
03:20:51 <alpounet> pshr, look here: http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html#v%3ArunProcess
03:21:00 <alpounet> the third argument is a Maybe FilePath
03:21:24 <alpounet> so, in your call to runProcess
03:21:25 <shachaf> merijn: Cache behavior counts, of course.
03:21:26 <merijn> confusing: Fairly interesting and short article: http://cacm.acm.org/magazines/2010/7/95061-youre-doing-it-wrong/fulltext
03:21:27 <pshr> How do I create a new instance of Maybe FilePath from String ?
03:21:38 <merijn> shachaf: Yes, and big O analysis pretends caches don't exist
03:21:40 <alpounet> pshr, replace vmxpath by (Just vmxpath)
03:22:07 <shachaf> I didn't know about \SP
03:22:08 <confusing> merijn: i may have actually read that, but i can't recall what (if anything) i took away from it :)
03:22:14 <shurikas> @src FilePath
03:22:15 <lambdabot> type FilePath = String
03:22:17 <shurikas> ah, ok
03:22:23 <confusing> merijn: thanks for the link
03:22:39 <pshr> thanks alpounet seems to be running now
03:22:41 <shachaf> merijn: Only if you disregard them while doing the analysis.
03:23:23 <shachaf> I mean, when you're doing a high-level thing like that, you ignore some things and pay attention to others, on purpose.
03:23:26 <alpounet> cool
03:23:27 <Nafai> akamaus: I guess it just feels awkward because I'm used to doing gtk in C and Python, and that awkwardness leaves me feeling like maybe I'm doing something wrong
03:24:04 <Nafai> akamaus: I want to improve this program and I haven't touched it for a few years, so I thought I'd ask
03:24:07 <Nafai> akamaus: https://github.com/travisbhartwell/utilities/blob/master/src/gtkmenu/gtkmenu.hs
03:25:30 <Peaker_> confusing, reading scrollback, O() is about asymptotic performance, not realistic performance with relatively small constants, so cache behavior does not really invalidate it
03:25:54 <Peaker_> cache behavior is merely a tiny anomality in the beginning of the curve described in the O() curve :)
03:26:07 <shachaf> Peaker_: That's not necessarily true, I think.
03:26:31 <Peaker_> shachaf, cache behavior changes O(1) memory access to O(1) memory access with a better constant
03:26:40 <Peaker_> It cannot really affect the O() analysis
03:27:48 <Peaker_> it does emphasize that O() is not enough for performance analysis, though
03:28:43 <confusing> Peaker_: sure, but that "beginning of the curve" may be large, and might even cover all cases where anyone ever used your function
03:28:48 <shachaf> Well, OK, if you do asymptotic analysis disregarding caches, then it won't regard caches. :-)
03:29:07 <shachaf> confusing: No one ever claimed that O() was enough.
03:29:22 <confusing> Peaker_: right, O is not enough for performance analysis. we seem to be agreeing vigorously
03:29:31 <alpounet> confusing, yes but it still has nothing to do with asymptotic analysis. it is a complementary tool :)
03:30:08 <shachaf> For example, https://en.wikipedia.org/wiki/Coppersmith%E2%80%93Winograd_algorithm
03:30:49 <Peaker_> shachaf, if you regard caches, all that changes is the constant..
03:31:05 <Peaker_> (it changes by a lot, but O() does not care about a large constant change)
03:31:35 <Jafet> Formally, as the size of RAM approaches infinity...
03:31:42 <Jafet> (Beat that, Kingston!)
03:33:17 <confusing> shachaf: i was thinking about those haddock pages which for every relevant function say "O(logn)", prominently at the very start of the function's documentation. it seems to suggest that O() alone is a good characterization, and that it's important enough that it should be stated right at the beginning
03:33:23 <confusing> example: http://xmonad.org/xmonad-docs/xmonad/XMonad-StackSet.html#g:7
03:33:24 <merijn> Peaker_: No, cache doesn't make access O(1) with a better constant, it changes constant memory access speed into variable memory access
03:33:54 <sipa> merijn: variable but bounded-time access
03:34:25 <confusing> to me, this kind of writing doesn't create the impression "O is one metric, not enough in itself, and is to be taken with a grain of salt, and when in doubt profile"
03:34:30 <merijn> Peaker_: Although in PHK's example he actually uses paging and VM as reason why O analysis screws you over
03:34:53 <merijn> Because paging effects are of course even clearer than caching
03:34:54 <Peaker_> merijn, Memory access with or without cache, hit or miss, is bounded by a constant
03:35:54 <Peaker_> merijn, O() notations means that if you have A=O(f(N)) and B=O(g(N))      and there is some constant you can multiply A by to make it larger than B, and some constant you can multiply B by to make it larger than A, then A=B
03:36:44 <Peaker_> merijn, say caches make memory reads faster by a constant of a million
03:37:20 <sipa> *up to*
03:37:40 <Peaker_> merijn, it's still only capable of causing a difference of multiplication by a constant
03:38:46 <RichyB> sipa, ten million is roughly accurate. An L2 hit takes ~0.5ns, a page fault going to a spinning platter takes ~10ms.
03:38:59 <RichyB> er
03:39:07 <RichyB> An *L1* hit takes ~0.5ns these days.
03:39:23 <sipa> RichyB: if the working set of my program is already being swapped out to disk, something is wrong
03:39:29 <RichyB> AIUI a page fault going to an SSD these days takes about 200us?
03:40:00 <confusing> sipa: well, peaker _was_ talking about very large n's
03:40:16 <sipa> you may as well include a calculation that assumes the data must be restored from backup, which is residing on a tape with an access time of 30s
03:40:39 <RichyB> No, the restore time for a realistic tape robot is more like 4h.
03:40:48 <sipa> even better!
03:40:50 <sipa> but yes, the factor can be very large
03:40:51 <merijn> RichyB: PHK's article suggests a time of 11 millisec for paging from SSD
03:41:06 <sipa> even the difference between L1 and RAM is very significant
03:41:18 <sipa> but that said, it is not a free speedup
03:41:29 <RichyB> 11 milliseconds for paging from an SSD can't be right. 11 milliseconds is enough time for a spinning 10kRPM HDD to *seek and then read* 2MB.
03:41:49 <sipa> if your algorithm needs access to N bytes of working set, the run time cannot be less than the time to read N bytes from RAM
03:41:59 <t7> with HALO you could statically assert the complexity :O
03:42:16 <merijn> RichyB: Oh, wrong paragraph. He was talking about a specific example, not single paging events
03:42:42 <danil> t7: you'd need to axiomatize some pretty detailed *operational* semantics for that
03:42:51 <RichyB> Ah ookies.
03:43:32 <confusing> anyway, all of those remarks just underscore that memory access is not a constant-time affair
03:43:35 <t7> force fold(l/r) or map
03:43:36 <RichyB> sipa, that's no more true than the statement "if your working set is N bytes then your run time can't be lower than the time to read N bytes from disk."
03:43:36 <merijn> RichyB: He doesn't list the actual time for 1 page from SSD. But he says there's approximately 1 order of magnitude difference between SSD and HDD
03:44:02 <Peaker_> Good SSD drives can read 4K in about 20 micros, iirc
03:44:08 <sipa> RichyB: since your statement is weaker than mine, of course :)
03:44:34 <RichyB> It's perfectly reasonable to reason about the run-time of, say, a matrix transposition subroutine that operates on a matrix that is probably already in L2.
03:44:46 <sipa> RichyB: but imho running any performance-critical code where the working set hits swap, is unreasonable
03:44:49 <RichyB> merijn, that sounds accurate.
03:45:10 <donri> it's always reasonable to reason, by definition
03:45:21 <RichyB> Shush.
03:45:24 <RichyB> ;P
03:45:48 <merijn> RichyB: The article I linked is pretty interesting to read regardless of what you think the merits of big O analysis are
03:45:54 <confusing> reason might be swapped out to the tape robot, in which case it takes hours to access
03:47:13 <RichyB> merijn, which article? I don't see a URL. I assume that you're referring to one of those "latency numbers that programmers should know" articles? Or to one of PHK's technological diatribes? Or to PHK's article on how the binary-tree in Varnish is laid out in order to minimise page faults?
03:48:01 <confusing> RichyB: merijn had mentioned http://cacm.acm.org/magazines/2010/7/95061-youre-doing-it-wrong/fulltext
03:48:16 <merijn> RichyB: The one about varnish and pagefaults
03:48:53 <merijn> I found the analysis of how many high performance software packages go wrong doing their own paging to be pretty enlightening, at least
03:48:59 <RichyB> Ah, the one about using mmap() properly instead of trying to manually manage "RAM" and filesystem objects even though "RAM" hasn't actually meant *RAM* since the 1970s.
03:49:15 <RichyB> confusing, thank you.
03:49:28 <RichyB> merijn, yes, PHK's rants are worth paying attention to.
03:49:39 <t7> is martin sulzmann in here?
03:49:54 <RichyB> Varnish is, IMHO, the single nicest piece of software that I have running in production at the moment.
03:50:22 <akamaus> Nafai, I skimmed through your code, the overall structure seems ok for me. Or better to say, standard. I have a difficult feeling about gtk2hs gui code too. But looks like It's GTK after all.  No matter which language you use it in, it always stays the same.
03:51:13 <t7> wow freenode has a hidden service on tor :)
03:52:50 <hpc> well now it's not hidden, you ruined it
03:52:52 <hpc> you monster :P
03:53:13 <merijn> RichyB: I don't use it myself, but it's on my list of "high-quality software to remember when I need something similar"
03:53:39 <Peaker_> merijn, yeah, fundamental software we all use is often horribly broken :(
03:53:50 <Peaker_> My pet example these days it he Linux implementation of TCP sockets
03:54:00 <Peaker_> it he -> is the
03:54:08 <confusing> Peaker_: interesting, do you have a link?
03:54:12 <merijn> In the same category ZeroMQ and NaCl seem pretty excellent (I *don't* mean this Google Native Client nonsense, I mean the djb crypto library)
03:54:44 <Peaker_> confusing, Nope, it's just something I had stumbled upon at work when trying to squeeze good latency and throughput out of TCP connections
03:55:29 <Peaker_> confusing, Basically, the socket's flow control is reasonable -- it delays "send" calls until there is room to send them. Unfortunately, it waits for room in the socket's send buf which is statically set to some number (typically 0.5MB)
03:55:30 <merijn> FreeBSD is still king when it comes to pumping stuff over sockets. And of course SCTP will be nice once the rest of the world will start supporting it...
03:55:47 <Peaker_> confusing, Rather than waiting for room in the TCP window on the wire
03:55:59 <t7> Peaker_: thats the TCP standard
03:56:10 <Peaker_> t7, oh, so the brokenness is even more fundamental
03:56:42 <t7> http://en.wikipedia.org/wiki/Nagle%27s_algorithm
03:56:47 <Peaker_> t7, A static buffer size will be: A) too small, if you have wide/long-latency links.  B) too big, if you have narrow/low-latency links.   Why not use the TCP window discovery?
03:56:48 <t7> you can turn it off per socket
03:56:54 <merijn> t7: Naah, you can turn of Nagle
03:57:09 <Peaker_> t7, No, I'm not talking about accumulating data for less packets
03:57:12 <t7> you can on windows
03:57:18 <t7> i think...
03:57:25 <Nafai> akamaus: thanks, perhaps I need to just trudge forward with my changes
03:57:34 <merijn> t7: On BSD, linux and OSX too
03:57:35 <Peaker_> t7, I'm talking about the socket's sendbuf being filled to 0.5MB, no more and no less, regardless of the detected TCP window
03:57:41 <akamaus> guys, is it expected behavior what program runs when compiled with -O0 but fails with stack overflow when compiled with  -O or -O2?
03:57:43 <Peaker_> t7, that's orthogonal to Nagle
03:58:14 <Peaker_> akamaus, that sounds like a bug, but do you have a reproducible example?
03:58:48 <Peaker_> t7, All the data I was sending was larger than single packets anyway
03:59:22 <Peaker_> t7, I needed to detect how much to put on the wire at once (window size), and to do this, I had to duplicate the work of TCP, which already detects this, because the socket API does not expose this information
03:59:49 <akamaus> Peaker_, yeah, but it quite big example. It's a part of my icfpc-2012 solution, a tail recursive parser function.
04:00:08 <akamaus> it fails on big maps when compiled with optimization
04:00:32 <int-e> akamaus: a bit surprising but perfectly possible; optimization may be shifting some heap allocated data to the stack
04:00:36 <Peaker_> akamaus, weird - did you try increasing stack size and profiling it?
04:01:12 <int-e> akamaus: oh and which ghc version are you using?
04:01:42 <akamaus> Peaker_, I tried --prof --auto-all, it shows ~90% of individual allocations are inside one function
04:01:54 <akamaus> int-e, it's ghc-7.4.1
04:02:52 <akamaus> the code looks like this: http://hpaste.org/72421
04:04:00 <Peaker_> akamaus, is Coords strict in its fields?
04:04:30 <Peaker_> akamaus, if not, you might be building up some large chunks in it
04:04:36 <Peaker_> large thunks, that is
04:05:59 <akamaus> Peaker_, yeah, it's strict. Here're the actual data structures. http://hpaste.org/72424
04:06:55 <XexonixXexillion> Is there any way to call haskell functions from a java (well, clojure) program, or should I simply run them both and make them communicate with pipes?
04:06:58 <akamaus> Peaker_, you mean, they're accumulated in the heap with -O0 but blow stack with -O2?
04:07:28 <Peaker_> akamaus, Nope, I am not sure
04:07:28 <merijn> XexonixXexillion: You can use the Java FFI to call C which call the Haskell FFI, but communicating over pipes is probably easier
04:07:56 <akamaus> Peaker_, I found what if I add trace (M.size $ worldMap w'') to stringReader the problem goes away
04:08:16 <akamaus> so I guess it's definitely a lazyness issue
04:09:01 <Peaker_> akamaus, btw,  is performance oriented, why are you using Strings?
04:09:40 <Peaker_> hmm, maybe it is not that bad if you're really working per-char
04:11:03 <rfw> @pl (\x -> [1..x])
04:11:03 <lambdabot> enumFromTo 1
04:11:05 <rfw> neat
04:11:08 <Peaker_> akamaus, maybe your problem is in the TTMap?
04:11:31 <Peaker_> akamaus, nobody seems to be forcing those
04:11:38 <rfw> @pl (\x -> [x + y | y <- [1..x]])
04:11:38 <lambdabot> return . ap (+) (((y | y) <-) . enumFromTo 1)
04:12:33 <akamaus> Peaker_, it's just parsing, we didn't optimize it at all
04:12:39 <rfw> did i break @pl
04:12:45 <Peaker_> akamaus, ah
04:12:59 <akamaus> Peaker_, I'm testing on a map without trampolines, ttmap stays empty
04:13:00 <Peaker_> akamaus, well, you might be building up lots of thunks in the ttmap tuple
04:13:03 <Peaker_> oh
04:13:05 <rfw> @pl (\x -> [x | _ <- [1..100]])
04:13:06 <lambdabot> (line 1, column 8):
04:13:06 <lambdabot> unexpected "["
04:13:06 <lambdabot> expecting lambda abstraction or expression
04:13:08 <int-e> akamaus: odd, are you sure the stack overflow is a result of parsing?
04:13:14 <Peaker_> akamaus, and without targets?
04:13:31 <int-e> Peaker_: (also the number of trampolines was at most 10 (or 9?))
04:13:36 <Peaker_> > (\x -> replicate 100 x) 'x'
04:13:37 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
04:13:39 <int-e> Peaker_: and trampolines are paired with targets.
04:13:49 <Peaker_> int-e, ok
04:13:56 <akamaus> Peaker_, in the end ttmap is empty, I tried to output it
04:14:01 <Peaker_> it's very annoying to debug stack oveflows in ghc
04:14:14 <Peaker_> akamaus, are you sure this code is responsible for the stack overflow?
04:14:18 <akamaus> It's a random map, so everything possible :) I didn't write the generator
04:14:20 <Peaker_> akamaus, does it happen if you force the result of this code?
04:15:09 <akamaus> Peaker_, not 100%, there a couple of functions above it in the call chain. But it's the main work horse
04:15:43 <Peaker_> akamaus, try forcing its result to normal form before continuing the work and see if the overflow reproduces at that point?
04:16:15 <int-e> akamaus: Try forcing the result of just parsing, as Peaker suggested. The code doesn't look like it should produce a stack overflow to me; if it does, I would start looking at ghc's core code. But first make certain that you have the real culprit.
04:16:33 <akamaus> Peaker_, great idea, wait a bit please
04:20:31 <XexonixXexillion> rfw: liftM2 (>>=) (enumFromTo 1) (((.).(.)) return (+)) -- A nicer pl version of (\x -> [x+y | y <-[1..x]])
04:21:33 <rfw> XexonixXexillion: i'm just curious about how badly pl barfed
04:22:40 <mauke> fmap: yes
04:22:45 <mroman> > let rfw = liftM2 map (+) (enomFromTo 1) in rfw 5
04:22:46 <lambdabot>   Not in scope: `enomFromTo'
04:22:51 <mroman> > let rfw = liftM2 map (+) (enumFromTo 1) in rfw 5
04:22:52 <mauke> also, you made me look for a bug that isn't there :-)
04:22:52 <lambdabot>   [6,7,8,9,10]
04:23:02 <mauke> enomNomNom
04:23:28 <mroman> ^- what about that.
04:24:12 <mauke> what about it?
04:24:28 <mauke> oh
04:24:38 <mroman> As an alternative for liftM2 (>>=) (enumFromTo 1) (((.).(.))  return (+))
04:24:49 <fmap> mauke: ah, sorry, that looked like a bug
04:24:57 <mauke> fmap: it was actually the cache
04:25:36 <mroman> > let concatFix = concat.fix in concatFix "nomnom"
04:25:36 <akamaus> Peaker_, I inserted the trace into caller: http://hpaste.org/72425. Still get the same error.
04:25:37 <lambdabot>   Couldn't match expected type `[[a]] -> [[a]]'
04:25:37 <lambdabot>         against inferred type...
04:26:09 <mroman> Yeah, forgot the :
04:26:46 <mroman> @src cycle
04:26:46 <lambdabot> cycle [] = undefined
04:26:46 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
04:26:55 <mroman> actually concat.fix is cycle?
04:27:04 <mroman> hm no.
04:27:33 <mroman> concat.fix.(:)
04:27:51 * hackagebot scan 0.1.0.8 - lexical style suggestions for source code (ChristianMaeder)
04:27:57 <Peaker_> akamaus, what is the same error? stack overflow? before or after the trace?
04:28:35 <Peaker_> akamaus, btw, "show" might cause problems of its own. Maybe you could instantiate NFData with data-derive and force the rnf of the data instead?
04:28:44 <fmap> > let f = fix . (++) in f "abc"
04:28:46 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
04:29:04 <int-e> fmap: f = Data.List.cycle
04:29:19 <int-e> oh.
04:29:39 <akamaus> Peaker_, show appied to Int looks innocent to me, doesn't it?
04:30:25 <Peaker_> akamaus, oh, worldMap is Int?
04:30:53 <Peaker_> akamaus, aren't you showing the Map of coords?
04:31:01 <agdris> int-e: why did you say "oh."?
04:31:27 <akamaus> Peaker_, oh, forgot M.size :(
04:31:41 <lamefun> http://www.youtube.com/watch?v=rmsGEyonaQM - is something like this possible in Haskell or that would be too slow?
04:31:47 <int-e> agdris: because 'cycle' was the starting point of the discussion 2 minutes earlier.
04:31:52 <Peaker_> akamaus, even size may not force everything.. to make sure there are no loose ends, I think it may be better to use rnf
04:31:58 <agdris> int-e: oh.
04:32:05 <agdris> :D
04:32:08 <akamaus> it's a Data.Map.Strict btw
04:32:14 <Peaker_> oh
04:32:20 <agdris> :D
04:32:32 <Peaker_> So Data.Map.Strict is strict on keys and values?
04:32:33 <mauke> lamefun: that's a videogame, not a programming language
04:32:49 <akamaus> Peaker_, yes, at least manual says so
04:33:07 <lamefun> is Haskell suitable for creating them or is too slow?
04:33:10 <akamaus> I made some trials, looks like it's strict indeed.
04:33:40 <Peaker_> @faq Can Haskell make lamefun's game?
04:33:40 <lambdabot> The answer is: Yes! Haskell can do that.
04:34:07 <Peaker_> akamaus, ok, so the trace of the size of the map is not reached?
04:34:44 <XexonixXexillion> @faq Can Haskell prove that P=NP?
04:34:45 <lambdabot> The answer is: Yes! Haskell can do that.
04:34:58 <lamefun> @faq Does making simple games in Haskell require tens of years of education?
04:34:58 <lambdabot> The answer is: Yes! Haskell can do that.
04:34:59 <akamaus> yes. I tried inserting another trace "zzz" before it. zzz is printed, the number is not
04:35:58 <lamefun> @faq Does Haskell promote sloth?
04:35:58 <lambdabot> The answer is: Yes! Haskell can do that.
04:35:59 <akamaus> lamefun, it depends on the approach. If it's FRP, ten years may not be enough :)
04:36:13 <Peaker_> akamaus, I'm not sure it's the best course of action, but I'd add traces to the stringReader itself, to see if I understand the order of operations
04:36:31 <akamaus> Peaker_, to let bindings?
04:37:21 <int-e> XexonixXexillion: Haskell is not a consistent logic :-)
04:37:46 <XexonixXexillion> lamefun: if you do it in Gloss, three weeks of education would be enough :p
04:37:51 <Peaker_> akamaus, random sub-expressions in there, with emphasis on the recursive ones :)
04:37:55 <chu> XexonixXexillion: "This proof is trivial. Exercise for the reader."
04:38:18 <int-e> (for example: undefined :: PEqualsNP)
04:38:22 <akamaus> or
04:39:02 <int-e> (defining the PEqualsNP type in a meaningful way is left as an exercise.)
04:39:03 <XexonixXexillion> int-e: perhaps (undefined :: Equal P NP)
04:42:52 * hackagebot Agata 0.2.1.1 - Generator-generator for QuickCheck (JonasDuregard)
04:44:12 <akamaus> Peaker_, take a look at http://hpaste.org/72426. Looks reasonable to me.
04:44:45 <akamaus> Peaker_, zzz is first trace in caller, before Map.Size
04:45:43 <Peaker_> akamaus, can you take the tail rather than head?
04:46:17 <Peaker_> akamaus, also, you sure that there are very few trampolines/targets here?
04:46:39 <Peaker_> akamaus, also, how are you reading the string?
04:46:48 <akamaus> guess tail would take time. Waiting.
04:46:56 <akamaus> Peaker_, I'm reading it with readFile :)
04:49:52 <akamaus> Peaker_, I've just grepped the map, zero trampolines and targets
04:50:15 <akamaus> map is 2000x2000, btw
04:50:37 <Peaker_> akamaus, weird..
04:50:41 <Peaker_> it would be nice to get a stack trace :-(
04:51:22 <akamaus> Peaker_, that's the tail http://hpaste.org/72427
04:52:28 <akamaus> Peaker_, is ghc capable of dumping these? ;)
04:52:52 <Peaker_> don't think so.. that's why it's pretty annoying to debug stack traces when they aren't obvious
04:53:15 <Peaker_> akamaus, maybe you can put the entire reproducing example somewhere?
04:53:48 <Peaker_> debug stack overflows*
04:56:22 <akamaus> Peaker_, well.. I can. I'll crop the map, 2000x100 suffice. I have to go now, will return in a half of an hour or so
04:56:40 <Peaker_> akamaus, if you can give me something to play with
04:56:44 <Peaker_> akamaus, maybe I can find the culprit
04:56:57 <Peaker_> I like practicing my haskell performance debugging skills
05:01:54 <belgin> would someone please explain to me how this does NOT enter an infinite loop? pastebin.com/cK3QY83H
05:07:21 <fmap> http://pastebin.com/cK3QY83H
05:07:26 <fmap> :(
05:07:26 <mauke> The paste cK3QY83H has been copied to http://hpaste.org/72428
05:07:30 <fmap> oh, thanks
05:07:32 <int-e> belgin: the first number checked is 3; since 2^2 > 3, the lpdf function terminates after one iteration. In general, for all n >= 2, there's a prime between n and n^2.
05:09:38 <belgin> int-e: but i don't understand how it gets to ldpf without entering an infinite loop
05:09:42 <agdris> i find it funny that constructors are actually only defined by their type signature. some would say there's only a "declaration", no "definition".
05:09:51 <int-e> belgin: It's lazy evaluation at work: Since primes1 = 2 : ..., you can access the first element of the primes1 list before the ... part has ever been evaluated.
05:12:54 * hackagebot tagshare 0.0 - TagShare - explicit sharing with tags (JonasDuregard)
05:13:26 <belgin> int-e: so the interpreter somehow knows that when it evaluates primes1 the first time, it needs to evaluate the expression after 2 but when it encounters it a second time, it doesn't need to evaluate the rest of it?
05:14:16 <int-e> belgin: so the first couple of evaluation steps would be  primes1 = 2 : filter prime [3..] = 2 : filter prime (3 : [4..]) = 2 : (if prime 3 then 3 : filter prime [4..] else ...) = 2 : (if lpd 3 == 3 then filter prime [4..] else ...) = 2 : (if lpdf primes1 3 == 3 then filter prime [4..] else ...). But we know that primes1 = 2 : primes1' (this has already been evaluated), so we can now use the first equation of lpdf. so lpdf...
05:14:23 <int-e> ...primes1 3 = 3.
05:14:23 <covi> dd
05:15:06 <belgin> thanks very much for your explanation, int-e
05:16:17 <t7> the position of an infix statement doesnt matter, does it?
05:16:31 <int-e> belgin: in the implementation, 'primes1' is initially a so-called thunk, a heap object representing an unevaluated value. When it is evaluated, that thunk is replaced by a cons cell (the : constructor) pointing to the first element (2) and another thunk for the tail list. Then 'primes1' from the definition of lpd points to the same thunk initially, so after the first evaluation step it will point to the cons cell.
05:17:41 <int-e> belgin: but usually you don't have to think about it -- as long as equational reasoning, re-using partial results, does not run into loops, lazy evaluation will typically just work and produce a result.
05:24:33 <akamaus> Peaker_, do you prefer a minified example or a fully functional?
05:30:25 <Peaker_> akamaus, minified if it reproduces the problem
05:30:52 <akamaus> Peaker_, ok, working on it
05:39:45 <int-e> /debian/home/bf3/confluence/ttt2/build/csi-0.2/src/processors/src/transformation/cr/groundcr.ml
05:39:49 <int-e> argh.
05:45:05 <Milo_> How can I convert a ByteString to its Integer value? I don't me "42" -> 42 but "\42" -> 42
05:47:52 <Mortchek> Milo_, ord '\42' = 42
05:48:02 <Philonous> Milo_:  Something like (map fromEnum . Data.Bytstring.Char8.unpack) ?
05:50:51 <akamaus> Peaker_, I've remove most non-relevant parts and  wrote a testing script which triggers the error. Please, take a look. http://vyal.ru/icfpc_stack_overflow_example.tar.gz
05:52:09 <kuribas> Is an association list more efficient than a search tree for few elements (twenty or so)?
05:55:26 <Milo_> Mortchek, Philonous: yes, but I have more than one byte "\42\NUL" so I could do something like ((2^8)^1)*42+((2^8)^0)*0 ?
05:56:30 <Philonous> Milo_:  Yes, that should work (though inefficiently, I think)
05:57:04 <Milo_> there is no way to interpret a ByteString as an Integer directly. due to representational differences, I suppose?
06:00:06 <Botje> Milo_: you could use Data.Binary.
06:00:25 <Milo_> I actually receive a (Ptr Word8) on a C byte[] which I then transform to a ByteString through unsafePackCStringLen
06:08:08 <Milo_> Botje: thanks. but  now it fails with "too few bytes."
06:08:09 <merijn> kuribas: For less than 20 elements efficiency won't matter
06:08:25 <merijn> kuribas: Unless you plan to do billions of look ups
06:08:41 <merijn> And even then it probably won't do much
06:08:59 <merijn> I'd just use whichever is simpler to implement right now
06:09:16 <Philonous> Milo_:  The binary instance is a custom encoding.
06:09:58 <Philonous> Milo_:  I would just implement the nave version and see if it becomes a bottleneck. You can always get fancy with a custom binary instance with bit fiddling later
06:10:52 <alpounet> Data.Binary instances can be written for you with the "derive" package, by the way
06:11:37 <Peaker_> akamaus, was away, did you paste anything?
06:13:17 <Milo_> Philonous: Yeah, you're probably right
06:13:27 <Philonous> Milo_:  (foldl' (\acc x -> acc `Data.Bits.shiftL` 8 + fromIntegral x) . Data.ByteString.Char8.unpack) might do the trick
06:15:23 <Philonous> Milo_:  Actually, ByteString has it's own foldl', so you don't need he detour via lists
06:16:05 <kuribas> merijn: I'll try the association list then.
06:17:56 <Milo_> Philonous: sweet, thank you. I'm still a little clumsy with fold
06:19:40 <agdris> could i name a type class (>>>) or something?
06:21:40 <mikeplus64> agdris: with MultiParamTypeClasses and TypeOperators, yeah
06:22:08 <nand`> I think it'd have to be :>>> or so
06:23:07 <mikeplus64> yeah, the operator has to begin with a :
06:25:22 <SPJ> When is jfischoff here?
06:32:53 <kuribas> Can I make cabal install documentation by default?
06:33:03 <ion> Yeah, in the config.
06:33:06 <mun> if
06:34:05 <mroman> http://codepad.org/V2UUMxsB <- how would one name this function?
06:34:21 <mun> i have a slightly logic-related question. if i convert a term trm1 = F(c) to trm2 = \lambda x. F(x), would it be right to say that the term c in trm1 is abstracted in trm2?
06:35:53 <byorgey> mun: yes, I think so
06:36:20 <mun> byorgey, i see
06:36:25 <byorgey> kuribas: edit ~/.cabal/config and set  Documentation: True
06:38:07 <byorgey> mroman: I might name it "windows" or "segments"?  And incidentally, you probably don't want to use length like that -- it makes the function O(n^2) instead of O(n), and it doesn't work on infinite lists
06:38:33 <eusebio> Is it hard writing a storage engine?
06:39:12 <merijn> eusebio: Depends on how safe and fast you want it to be
06:39:21 <byorgey> mroman: instead you can do something like   map (take n) . tails, and then  takeWhile  the length of the segments is n
06:39:44 <byorgey> that way you are only checking the length of the segments instead of checking the length of the entire list repeatedly
06:39:51 <mroman> hm.
06:39:55 <mroman> good idea @length
06:40:45 <eusebio> merijn: safe as in non-hackable?
06:41:09 <eusebio> merijn: would be just for learning so decent is good neough
06:42:14 <merijn> eusebio: Safe as in resilient to memory corruption/machine crashes
06:44:33 <mroman> http://codepad.org/qPxEkExM <- works like a charm.
06:47:11 <gspr> Suppose  f :: (Storable a) => a -> IO (), and that f' :: FunPtr (a -> IO ()) is created from f in the normal wrapper way -- what do I know about the reentrancy of f' if passed to C?
06:47:56 * hackagebot testing-feat 0.3 - Functional Enumeration of Abstract Types (JonasDuregard)
07:00:49 <danil> gspr: the RTS isn't going to blow up -- it's just as safe to call it reentrantly from C as it is to run it concurrently in two Haskell threads
07:02:46 <gspr> danil: Good!
07:03:46 <eusebio> merijn: so how hard is it? hard to say ofc. How many LOC would you say for something decent and usable?
07:05:10 <t7> how long is a piece of string
07:06:24 <merijn> eusebio: Almost impossible to tell
07:09:40 <agdris> almost.
07:10:58 <t7> Quantum.List.filter is O(1)
07:12:23 <danil> that's a pretty big improvement over Grover's algorithm
07:13:04 <t7> ah what
07:13:19 <t7> every time i look at quantum stuff it gets less and less magical
07:13:49 <hpaste> nand` pasted “Free comonads?” at http://hpaste.org/72434
07:13:52 <nand`> ^ does this look correct?
07:15:04 <danil> (Grover's algorithm is a quantum algorithm for searching an unordered list in O(\sqrt n) time -- one of the earliest quantum algorithms better than classical ones)
07:18:52 <a|i> anyone knowns any 'natural language generation' library (other than geni) in haskell?
07:19:02 <danil> nand`: looks like the laws check out, and the datatype is the dual of the free monad
07:20:56 <Veinor> grover's algorithm is also known to be optimal
07:21:15 <randomclown> how would one generate all permutations of "ABCD"
07:21:17 <randomclown> including repeats
07:21:34 <mauke> > permutations "ABCD"
07:21:35 <lambdabot>   ["ABCD","BACD","CBAD","BCAD","CABD","ACBD","DCBA","CDBA","CBDA","DBCA","BDC...
07:21:41 <nand`> > replicateM 4 "ABCD"
07:21:42 <lambdabot>   ["AAAA","AAAB","AAAC","AAAD","AABA","AABB","AABC","AABD","AACA","AACB","AAC...
07:22:05 <t7> @hoogle pick
07:22:05 <lambdabot> Test.QuickCheck.Monadic pick :: (Monad m, Show a) => Gen a -> PropertyM m a
07:22:05 <lambdabot> Graphics.Rendering.OpenGL.GLU.Matrix pickMatrix :: (GLdouble, GLdouble) -> (GLdouble, GLdouble) -> (Position, Size) -> IO ()
07:22:05 <lambdabot> package hexpat-pickle
07:22:15 <randomclown> huh.
07:22:34 <mroman> Luckily we alreade had that today @permutations
07:25:09 <nand`> hmm
07:25:14 <nand`> :t join (replicateM . length)
07:25:15 <lambdabot> forall a. [a] -> [[a]]
07:26:14 <t7> > map (\x -> length $ permutations [0..x]) [0..]
07:26:17 <lambdabot>   mueval-core: Time limit exceeded
07:27:06 <nand`> why did that one time out?
07:27:20 <nand`> > map (length . permutations . enumFromTo 0) [0..]
07:27:23 <lambdabot>   mueval-core: Time limit exceeded
07:27:37 <nand`> oh, right
07:27:37 <Veinor> because length [0..10!] is kind of a slow computation
07:27:45 <Veinor> > take 4 $ map (\x -> length $ permutations [0..x]) [0..]
07:27:46 <lambdabot>   [1,2,6,24]
07:27:51 <nand`> I forgot mueval does that
07:28:09 <t7> why does it do that?
07:28:28 <Veinor> does... what?
07:28:35 <Veinor> try to evaluate the thing you told it to evaluate?
07:28:40 <nand`> t7: no idea, but it forces the first 1023 characters of whatever output it wants to show; and if it fails doing that, times out
07:29:15 <t7> Veinor: not use lazy eval
07:29:34 <Veinor> > take 8 $ map (\x -> length $ permutations [0..x]) [0..]
07:29:35 <lambdabot>   [1,2,6,24,120,720,5040,40320]
07:29:44 <Veinor> > map (const 2) [0..]
07:29:46 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
07:29:48 <Veinor> it does, though
07:30:58 <nand`> > replicate 500 2
07:30:59 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
07:31:02 <nand`> > replicate 500 2 ++ fix id
07:31:06 <lambdabot>   mueval-core: Time limit exceeded
07:31:08 <gspr> Is there an unsafe version of replicate for ByteStrings that creates a ByteString of a given length whose data is undetermined? Sort of like the ordinary replicate, except there's no memset done.
07:31:14 <Veinor> ahh
07:32:02 <Veinor> > replicate 2000 2 ++ fix id
07:32:04 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
07:32:16 <nand`> it internally forces 1023 characters of output then truncates that for here
07:32:19 <Veinor> yeah
07:33:11 <nand`> the two differences I would expect: 1. if it gets truncated here, it doesn't get evaluated; and 2. if the computation times out but produces partial results, I'd like something like "[0, 1, 2, 6, 24, 120, -- computation timed out"
07:33:23 <nand`> or maybe just ...
07:37:11 <augur> koninkje_away: <3
07:37:55 <c_wraith> gspr: what'd be the purpose of that? examining memory contents?
07:39:54 <gspr> c_wraith: Doing even more unsafe stuff afterwards :p
07:40:20 <gspr> c_wraith: But I just figured saw how to do what I want with alloca, so I'm good :)
07:40:26 <gspr> -figured
07:45:05 <c_wraith> gspr: I think you'd need allocaBytes, in order to avoid the Storable instance from writing to the allocated space.
07:45:56 <balor>  I want a datatype "data Foo = Foo { bar :: Int -> String } deriving (Show, Eq, Ord)", Is there any magic way to get it to derive Show, Eq and Ord for the datatype? Or do I have to instance the typeclasses manually?
07:46:27 <c_wraith> balor: Eq and Ord are *very slow* for that type.
07:46:34 <Axman6> balor: how do you check if two functions are equal?
07:46:41 <c_wraith> Axman6: well, the domain is finite...
07:46:41 <Axman6> how do you order functions?
07:46:50 <Axman6> but massive...
07:46:57 <c_wraith> so, yeah..  *very slow*
07:47:06 <balor> Axman6, In this case the domains are small
07:47:16 <c_wraith> well, GHC doesn't know that.
07:47:20 <balor> true
07:47:25 <c_wraith> GHC has no rules for dealing with function types
07:47:34 <c_wraith> for Eq, Ord, and Show, that is
07:47:42 <c_wraith> Because they're undecidable in general
07:47:49 <balor> that makes sense
07:47:51 <nand`> how would one even implement restricted enums like that? newtype Int and provide smart Enum/Bounded instances?
07:48:19 <Eduard_Munteanu> data MyEnum = Red | Green | ... ?
07:48:31 <nand`> assuming I did want to provide an Eq instance on functions from this domain (say from -5 to +5)
07:48:41 <balor> Effectively, I have a small set of Int and bar is a labelling function, mapping the contents of the small set to strings
07:49:04 <DrTeggy> http://pragprog.com/magazines/2012-08/thinking-functionally-with-haskell
07:49:09 <Eduard_Munteanu> balor: why not the above and a Show instance?
07:49:26 <Eduard_Munteanu> data MyEnum = Red | Green | ... deriving (Enum, Show)
07:49:31 <merijn> balor: You will have to write the instances yourself, but assuming you have a semi-reasonable definition of Eq and Ord it'll be easy. Show might be trickier
07:50:30 <balor> The set of Ints that I have to label are dependant on the instance of the type...so maybe I should just approach this another way
07:50:55 <EvanR> dependent on the instance of the type
07:51:03 <EvanR> screams function to me
07:51:19 <Eduard_Munteanu> Um, dependent on what?
07:51:32 <Eduard_Munteanu> That   data Foo   doesn't depend on anything.
07:52:31 <balor> Eduard_Munteanu, that was a minimal working example.  A more full example would be "data Things = Things {things :: Set Int, label :: Int ->String}
07:52:31 <Eduard_Munteanu> If you're looking for a typeclass, that's Enum.
07:52:49 <balor> So in one instance there may be 5 things, and in another 7 etc...
07:52:59 <Eduard_Munteanu> things :: Set MyEnum
07:53:37 <balor> Eduard_Munteanu, Doesn't that restrict the things to having a maximum number of things?
07:54:02 <Eduard_Munteanu> Ah, I see what you mean.
07:54:11 <Eduard_Munteanu> :t toEnum
07:54:12 <lambdabot> forall a. (Enum a) => Int -> a
07:54:17 <quicksilver> balor: things :: Map Int String
07:54:31 <EvanR> AllThe Things
07:54:57 <gspr> c_wraith: Correct, I'm really using allocaBytes :)
07:55:03 <Eduard_Munteanu> > toEnum 0 :: Bool
07:55:04 <lambdabot>   False
07:55:07 <Eduard_Munteanu> > toEnum 1 :: Bool
07:55:09 <lambdabot>   True
07:55:15 <balor> quicksilver, I know I'm being difficult here, but I'd prefer not to use that solution because the math definition I'm working with doesn't do it that way.
07:55:21 <hpaste> Peaker/akamaus pasted “Stack overflow with -O2, none without” at http://hpaste.org/72439
07:55:27 <balor> Eduard_Munteanu, that toEnum looks like what I'm looking for.  thanks.
07:55:38 <Peaker_> hmm -- I minified akamaus's program to an extremely small program
07:55:41 <quicksilver> balor: well a Map Int String is very like (Set Int, Int -> String)
07:55:50 <Peaker_> http://hpaste.org/72439 -- stack overflows with -O2, but runs OK without
07:56:00 <quicksilver> except that it guarantees not to label points which don't exist
07:56:59 <DrTeggy> Have a nice day everyone.
07:57:14 <hpaste> Peaker annotated “Stack overflow with -O2, none without” with “Slightly more minified” at http://hpaste.org/72439#a72440
07:57:40 <Peaker_> anyone care to help me and akamaus figure out why this program is stack overflowing?
07:58:48 <balor> quicksilver, thanks.  I might use {Set Int, Map Int String}.  It duplicates some information, but more closely matches the definitions I'm working with
07:58:54 <Peaker_> I think it has something to do with the first case consisting of a numeric pattern match that will always match followed by another match that will always fail (no '\r' in there)
08:01:08 <Eduard_Munteanu> balor: the map is pretty much like a set, why do you need a Set?
08:01:42 <EvanR> Map with the value itself as a key
08:02:27 <c_wraith> Peaker_: that ends with an exception when it runs successfully, right?
08:02:32 <Peaker_> akamaus, yeah, if I switch the param order, it no longer happens
08:02:47 <akamaus> Peaker_, I was able to remove y altogether
08:02:53 <Peaker_> c_wraith, yeah
08:03:05 <Peaker_> akamaus, yeah I pasted that too, more minified
08:03:13 <balor> Eduard_Munteanu, I'm working with some definitions and lemmas in a paper and am trying to write a conforming implementation.  The more closely I stick to the definitions in the paper, the easier it is to explain to my tame mathematicians
08:03:15 <c_wraith> there's nothing in there that suggests stack overflow to me.  So I'm baffled
08:03:27 <Peaker_> akamaus, then you remain with "x" and the String only. If you flip their order it no longer stack overflows
08:03:48 <c_wraith> Both arguments are pattern-matched, it's completely tail-recursive
08:03:57 <Peaker_> c_wraith, I'm thinking maybe it has something to do with having two pattersn on the same clause -- one of them matches and the other doesn't. Maybe that leaks some stack space
08:04:09 <Peaker_> (with optimizations on)
08:04:47 <c_wraith> that looks worthy of a ghc bug report, to me..
08:05:21 <akamaus> did someone tried it with 7.4.2?
08:06:12 <Peaker_> Core is very unreadable
08:06:46 <geekosaur> enh
08:07:09 <geekosaur> in my experience unreadable Core tends to indicate someone did something wrong; sometimes it's the compiler that did
08:07:23 <Peaker_> what's the nicest way to get core? How do I get something better than      "main:Main.zdwstringReader :: ghczmprim:GHCziPrim.Intzh -> (ghczmprim:GHCziTypes.ZMZN ghczmprim:GHCziTypes.Char) -> ... "   business
08:08:24 <geekosaur> install the ghc-core package from hackage
08:08:33 <Peaker_> oh I wasn't using -ddump-prep but -fext-core
08:08:43 <geekosaur> it will compile stuff to core and syntax color it, etc.
08:08:46 <Eduard_Munteanu> -ddump-simpl?
08:08:52 <geekosaur> oh yes, watch out for that, ext-core is not the same thing.  -ddump-simpl
08:11:31 <Peaker_> funny how the core gets infix syntax wrong
08:12:05 <Eduard_Munteanu> Peaker_: what if -O2 strictifies the last concat more than it needs to?
08:12:23 <Peaker_> Eduard_Munteanu, the smap isn't it
08:12:29 <Peaker_> Eduard_Munteanu, the problem is in stringReader
08:12:35 <Peaker_> Eduard_Munteanu, it also works when reading smap from a file
08:12:49 <Peaker_> Eduard_Munteanu, or when forcing smap fully before giving it to stringReader
08:12:53 <Eduard_Munteanu> Ah.
08:13:31 <Peaker_> if ghc-core gave a,b,c,d.. names to stuf
08:13:38 <Peaker_> instead of ds1_dmE
08:13:40 <Peaker_> it would be nicer
08:14:10 <Peaker_> What's the C# constructor? :)
08:14:25 <Peaker_> oh, Char :)
08:14:36 <Eduard_Munteanu> @src Char
08:14:36 <lambdabot> data Char = C# Char#
08:14:42 <EvanR> :t C#
08:14:43 <lambdabot> Not in scope: data constructor `C#'
08:14:59 <geekosaur> :t GHC.Prim.C#
08:15:00 <lambdabot> Not in scope: data constructor `GHC.Prim.C#'
08:15:03 <Eduard_Munteanu> Not in scope: programming language `C#'
08:15:03 <geekosaur> bah
08:15:28 <mauke> zomg C# support in ghc!
08:15:29 <EvanR> down periscope
08:15:33 <mauke> call the internets
08:15:36 <Eduard_Munteanu> @src Float
08:15:37 <lambdabot> data Float = F# Float#
08:15:41 <mauke> o shi-
08:16:11 <geekosaur> hey, peopl keep talking about getting haskell in .net...
08:16:14 <EvanR> data String = Scala String#
08:16:15 <geekosaur> }:>
08:16:25 <mroman> Why? Theres' already F#?
08:16:28 <mroman> *There's
08:16:43 <Peaker_> reading the core is pretty tedious
08:16:44 <EvanR> geekosaur: really? is that feasible
08:16:53 <mauke> @src Integer
08:16:54 <lambdabot> data Integer = S# Int#
08:16:54 <lambdabot>              | J# Int# ByteArray#
08:16:57 <mauke> and there's J#
08:17:30 <geekosaur> EvanR, it's feasible, nobody seems to be interested in doing the work.  (I still find it highly ironic that a division of MSR is backing GHC, but won't help target Microsoft's own platform)
08:17:39 <quicksilver> I seem to recall that a CILR (.NET) target was a GHC goal at some early stage
08:17:47 <quicksilver> but it got dropped
08:18:02 <quicksilver> it's mentioned in a few early documents/papers I think
08:18:03 <geekosaur> yeh.  there are some complexities involved, and early on it wasn;t really doable
08:18:14 <Eduard_Munteanu> When they decided F# was going to be showcased as the product of MSR's effort? :)
08:18:17 <geekosaur> the backend has been replaced/overhauled several times since then and it's more feasible than it was then
08:18:22 <EvanR> if it were a .net language, seems like that would make haskell more popular
08:18:29 <EvanR> thus not avoiding succeass
08:18:37 <geekosaur> the old backend was really, really not up to it at all
08:18:49 <Peaker_> akamaus, so I'm opening a bug report about this
08:18:58 <geekosaur> (I started using GHC back in the 6.6 days.  that version simply was not going to work on .net)
08:19:03 <t7> mroman: f# is impure :*(
08:19:05 <Peaker_> akamaus, I think it relates to multiple pattern matches leaking stack space, but I'm not sure
08:19:34 <EvanR> t7: everything is
08:19:42 <EvanR> except haskell, clean
08:20:03 <t7> yeah but haskell could do .net shit in a monad... ?
08:20:06 <quicksilver> I think I started with 6.6 too.
08:20:20 <EvanR> t7: another IO lib
08:20:24 <quicksilver> took an entire working day to compile on an iBook G4.
08:20:24 <EvanR> maybe some pure bindings
08:20:24 <danil> Peaker_: does it go away if you translate it to nested cases?
08:20:39 <geekosaur> t7 what?  we're talking about code generation.  6.6 was the days of generating evil C code that got passed through an even more evil perl script
08:21:22 <geekosaur> sorry, assembled (gcc -s) and *then* passed through the Evil Mangler
08:21:49 <Peaker_> danil, haven't tried that
08:21:57 <t7> when is the llvm backend gonna be default?
08:22:32 <applicative> why would it be default? just wondering
08:22:55 <akamaus> Peaker_, great :)
08:23:00 * hackagebot timerep 1.0.2 - Parse and display time according to some RFCs (RFC3339, RFC2822) (HugoGomes)
08:23:06 <t7> if everyone compiles to llvm then everything will be easier to port etc
08:23:08 <Peaker_> akamaus, http://hackage.haskell.org/trac/ghc/ticket/7110#comment:1
08:23:11 <t7> and optimize
08:23:17 <akamaus> looks like icfpc is a great stress-test for the tools :)
08:23:27 <geekosaur> because in some cases it produces a lot better code, and in most cases it's at least as good, and focusing on the llvm backend would get us to the point of being able to take advantage of more and better llvm optimizations
08:23:57 <geekosaur> (right now the llvm backenddoesn't get enough love so it can't use some of the more interesting optimization possibilities)
08:25:14 <t7> also compile to javascript in GHC plz
08:26:37 <applicative> I see, I assumed it got as much love as it might
08:32:05 <geekosaur> there's apparently a fair amount of work needed to be able to generate the right metadata to help LLVM's linker do some advanced optimizations
08:32:28 <geekosaur> IIRC
08:32:30 <t7> Simon peyton jones can do that
08:32:32 <geekosaur> there's been discussion on -cafe
08:32:52 <geekosaur> (I think it was -cafe, might have been the ghc list.)
08:39:01 <Peaker_> ghc trac emails don't have any URL link to the ticket
08:43:00 * hackagebot records-th 0.1.1.0 - Template Haskell declarations for the records package (SamAnklesaria)
08:54:59 <t7> [2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,1932053504,1278945280,Interrupted.
08:55:07 <t7> i left that permutations thing running
08:55:13 <t7> woops
08:58:45 <gertc> http://stackoverflow.com/questions/11731941/haskell-facebook-exceptions
08:59:33 <mauke> gertc: I think you've pasted that link several times. what's so funny about it?
08:59:52 <gertc> that nobody seems to know :)
08:59:59 <gertc> or does not have time
09:00:15 <gertc> so i try my luck 1 or 2 a day
09:01:28 <mauke> oh, I thought it was because the question was stupid or something
09:01:39 <gertc> could be
09:01:46 <gertc> but then explain why
09:07:50 <fmap> i guess nobody knows (or wants to know) how facebook stuff works
09:08:47 <MostAwesomeDude> fmap: What do you want to know?
09:09:43 <gertc> why i get Ambiguous type variable `e0' in the constraint:
09:10:23 <gertc> i think the question is pretty complete ?
09:11:05 <gertc> if not tell me what info you need?
09:11:29 <mauke> what does this have to do with facebook? it's a simple type error
09:12:02 <gertc> i dont know you are the expert :)
09:12:20 <gertc> i tried allot of combinations
09:12:32 <mauke> ... yeah, not really interested anymore
09:12:57 <mauke> debugging by random permutation needs to die
09:13:00 <mapreduce> Maybe if you reword it in terms of twitter.
09:13:05 <mauke> s/debugging/programming/
09:14:40 <ozataman> does Float in GHC have a lower memory footprint than Double?
09:23:26 <quicksilver> ozataman: no.
09:23:37 <quicksilver> well, not on a 64bit machine anyway
09:23:40 <madjestic> so, is my understanding roughly correct, that cabal is for installing packages and ghc-pkg is for managing installed packages?
09:23:40 <ozataman> quicksilver: that's what I thought - thanks.
09:23:51 <quicksilver> it might do on a 32bit machine, but not significantly.
09:24:24 <solrize> something like an unboxed array might do the right thing
09:24:40 <solrize> dunno about   data X = X #Float #Float
09:26:08 <geekosaur> interesting, I would have thought Float was 4 bytes on 32 bit vs. 8 bytes for Double
09:26:42 <solrize> http://johantibell.com/files/haskell-performance-patterns.html#%284%29
09:26:49 <solrize> or rather ^^
09:26:50 <geekosaur> plus overhead for the box/constructor of course
09:28:05 <gertc> ok better luck next time, bye
09:28:27 <quicksilver> geekosaur: that's what I meant by "it might do on a 32bit machine, but not significantly" :)
09:28:45 <quicksilver> the not significantly part being the box + constructor.
09:32:17 <Bobikins> What's the keyword for automatically making Show and so on work for a data declaration?
09:32:26 <danharaj> deriving
09:32:31 <Bobikins> Thanks :)
09:36:50 <Saizan> madjestic: yeah
09:37:16 <dan1981> hello i need some basic help in making a expert system framework in haskel is there a good tutorial avaliable?
09:38:40 <quicksilver> @where lyah
09:38:40 <lambdabot> http://www.learnyouahaskell.com/
09:38:47 <quicksilver> dan1981: ^^ that's a good starting point with haskell
09:39:04 <MaximVeksler> Hello everyone, are you open for a bit off-topic discussion? I'm wondering between scala, erlang, haskell and JS in terms of starting to develop my own startup with. I know great deal of JVM languages, mostly Java and we have very good experience with it, but it just doesn't feel like the best direction to take
09:39:04 <quicksilver> I can't point you to an expert systems tutorial
09:39:09 <quicksilver> that's a bit specialised
09:39:27 <klfwip_> maxim, well haskell certainly is different
09:40:12 <dan1981> @quicksilver thanks, i am reading through that now and watching the channel 9 lectures.
09:40:12 <lambdabot> Unknown command, try @list
09:40:15 <jfischoff> dan1981: this might help https://github.com/chris-taylor/aima-haskell
09:40:57 <MaximVeksler> klfwip_: really? I know mostly from hearing people on HN saying that most languages adopt features from Haskell
09:41:20 <dan1981> thanks guys, i have been looking at the learnyouahaskell and the channel 9 lectures but i wonder if there was a more specific tutorial.
09:41:30 <MaximVeksler> so it only seems natural to adapt the most advances tool, first because it's cool but also because it will attract the most smart people
09:42:53 <jfischoff> MaximVeksler: I use Haskell at a startup. I recommend it.
09:43:37 <MaximVeksler> jfischoff: Will you mind point to your website, or even better to your tech blog guys? Also - are you a founder?
09:43:56 <MaximVeksler> I'm mostly interested to learn about your experience, if that will be OK with you.
09:44:23 <jfischoff> MaximVeksler: I am not a founder. I make tools for an iOS game company called booyah, http://www.booyah.com/
09:44:34 <klfwip_> I am really new at haskell, but it really appeals to me
09:44:46 <djahandarie> Hmm, is the /topic outdated? I don't see anything that would prevent unregistered users from talking.
09:45:11 <klfwip_> I use c++ for almost everything right now, but haskell is great when you just need to solve a hard math problem
09:45:23 <jfischoff> MaximVeksler: ask me whatever you want, but I know very little about Haskell web programming.
09:47:45 <MaximVeksler> jfischoff: I'm mostly interested in production terms. Stuff like quality of standard and community libraries. How fun is it to work with the language. What corners cases (like untyped languages will catch errors in runtime and co.) - Stuff that you get by experience of working with the language. And what problems are you solving with it?
09:48:08 * hackagebot circ 0.0.4 - A Compiler IR Compiler. (TomHawkins)
09:50:21 <jfischoff> MaximVeksler: I pm you, so we won't drown the channel
09:50:26 <eusebio> Stupid example but could I use template Haskell to do be able to do: map (lambda x -> x * x) [1,2,3] => [1,4,9] . Ie define new syntax like that.
09:53:19 <mcstar> afternoon
09:53:39 <mcstar> i have another stupid question
09:53:46 <danil> eusebio: template haskell has $(macros that take normal haskell values as arguments) and [named| quasiquoters that take arbitrary strings|]
09:54:06 <mcstar> let say, i have a record, with fields of STRef
09:54:07 <alpounet> jfischoff, what kind of tools? if you can talk about it
09:54:27 <mcstar> again, like a tree or something
09:54:31 <nand`> that's odd, ‘foo x = f x’ is valid but ‘foo = f’ type errors
09:54:37 * nand` scratches head
09:54:42 <mcstar> with its nodes as mutable references
09:54:50 <mcstar> so i would build this tree in ST
09:55:03 <danil> eusebio: you can parse whatever you want in a quasiquoter and splice in generated code, but it has to be delimited by the brackets
09:55:12 <mcstar> and im wondering if it is possible to somehow change the fields of the record from STRef a to a ?
09:55:24 <danil> nand`: what extensions are you using?
09:55:32 <mcstar> is this totally  out of the question?
09:55:56 <nand`> danil: Rank2Types, NoMonomorphismRestriction, TemplateHaskell
09:56:23 <c_wraith> mcstar: you can do it if the types allow it.
09:56:36 <mcstar> c_wraith: can you explain?
09:56:39 <nand`> danil: also, it type checks if I leave out the explicit type signature
09:56:44 <nand`> I think it has to do with quantification getting mixed up somewhere
09:56:47 <danil> mcstar: not without traversing and rebuilding the structure, but if you parameterize it you can
09:57:08 <mcstar> ok, since the structure woldnt change
09:57:13 <mcstar> just the types of the fields
09:57:29 <c_wraith> mcstar: if the field is polymorphic, you can make that change.  If it's not.. the types don't allow it
09:57:49 <BMeph> mcstar: I would say no, since you'd be changing the record, and thus the record's type.
09:58:23 <mcstar> then, i must wonder a bit about the usefulness of ST
09:58:43 <danil> nand`: hmm, OutsideIn(X) (or whatever they're calling it now) isn't that robust at inferring rank 2 types, but still surprising.  Could you paste it?
09:58:54 <mcstar> id like something with 'nested mutability' if you catch my drift
09:59:09 <mauke> mcstar: why do you think the structure wouldn't change?
09:59:19 <mauke> mcstar: STRef X is not X
09:59:41 <mcstar> no, but i would 'run' it, making the result immutable
10:00:00 <BMeph> mcstar: Usefulness in one word: join.
10:00:12 <mauke> mcstar: ... and?
10:00:20 <nand`> danil: import Control.Lens: let getMany :: Functor f => Getter a b -> Getter (f a) (f b); getMany = to . fmap . view
10:00:27 <nand`> note that getMany x = to . fmap . view $ x -- works
10:00:42 <nand`> anyhow, it works if I change the type signature to the more general Getting version
10:00:55 <mcstar> yeah, be a little more unspecific guys, maybe ill understand it THEN
10:01:13 <mauke> mcstar: understand what?
10:01:16 <mauke> what is the problem?
10:01:42 <mcstar> i dont understand why wouldnt it be the same structure if i remove mutability from the fields
10:01:51 <mauke> because that's not what's going on
10:01:52 <danil> mauke: he wants to implement his own runSTTree that works like runSTArray -- takes a mutable structure and gives you a non-mutable one outside ST
10:01:54 <mcstar> thereby, i dont understand what are you getting at
10:02:06 <mauke> STRef X is not "a mutable X"
10:02:27 <BMeph> mcstar: Done! "UR DOIN IT RONG" ;-)
10:02:33 <mcstar> semantically it is, isnt it?
10:02:36 <mauke> no
10:02:50 <mauke> STRef (STRef X)
10:03:09 <danil> more like a mutable pointer to an X (i.e. a ref(erence))
10:04:02 <mcstar> well, yeah, if let a = STRef 0 then i can change what a points to
10:04:35 <mcstar> when i run a read on it, i can get back the value
10:04:46 <mcstar> so thats quite like removing the STRef
10:04:51 <ByronJohnson> edwardk: lens-1.2:Control.Lens.TH fails to derive a lens for a field that has the type "forall t. FormatTime t => Maybe (LogAccess t)": http://hpaste.org/72442
10:05:22 <edwardk> that lens would have an impredicative type, so i'm not terribly shocked
10:05:32 <edwardk> does it work in data-lens, etc?
10:05:36 <ksf> rewrite HaRe with invertible-syntax and GHC.Generics, any takers?
10:05:45 <BMeph> mcstar: Instead of "STRef X," substitute "[X]" into your statements, and see if it still makes sense.
10:05:49 <edwardk> i'm currently rewriting the lens makeLenses code
10:05:59 <edwardk> in order to autogenerate isomorphisms for newtypes, etc.
10:06:18 <ksf> edwardk, invertible-syntax has nice isomorphisms, too.
10:06:20 <edwardk> but i'm not sure i can give you a lens for that field, ImpredicativeTypes is buggy
10:06:21 <ksf> partial ones, even.
10:06:30 <mcstar> BMeph: yeah, it does
10:06:36 <mcstar> BMeph: thanks, good example
10:06:41 <edwardk> do they work like the ones in here?
10:06:52 <nand`> edwardk: is there a better way to do this? getMany :: Functor f => Getting b a a' b b' -> Getter (f a) (f b); getMany = to . fmap . view;  intended use is like this: getAges :: State [Person] [Int]; getAges = use (getMany age)
10:07:00 <ksf> they work to have functors that work both ways.
10:07:05 <nand`> where age is a Simple Lens Person Int
10:07:20 <edwardk> hrmm
10:07:24 <ksf> that is, (a -> b) -> f a -> f b  *and* (b -> a) -> f b -> f a
10:07:31 <ksf> err no that's wrong.
10:07:34 <nand`> I can't help but feel I'm missing something incredibly obvious involving traversals or similar here
10:07:35 <edwardk> hahaha
10:07:39 <ksf> the second ones is (b -> a) -> f a -> f b
10:07:47 <ksf> otherwise it'd be kinda trivial.
10:08:58 <edwardk> nand`: good question, to.fmap.view seems reasonable, there is probably a prettier way though
10:09:30 <nand`> I just wanted to see if my approach is principally flawed (ie. I'm not thinking in terms of lenses correctly) or not
10:09:53 <edwardk> working with a Getter is just like working with a function, only a little backwards because of the cpsing
10:10:58 <nand`> hmm
10:12:07 <nand`> edwardk: fmap $:: view ~> to
10:12:15 <nand`> borrowing some combinators from Data.Function.Pointless
10:12:16 <edwardk> ByronJohnson: i don't think my makeLenses rewrite will fix that one
10:13:00 <edwardk> i'm having fun going out of my way to use lenses and traversals to make the code for deriving lenses cleaner
10:13:01 <nand`> captures the essence of unboxing/reboxing the Getter a c ⇔ a -> c
10:13:26 <k0ral> hi, I can't build package network because of "Socket.hsc:951:10: error: ‘SOL_SOCKET’ undeclared", any one ever got this error ?
10:13:28 <edwardk> yeah, sadly i can't make 'to' an isomorphism because it would require impredicativity
10:14:02 <edwardk> then you could just use 'from to' ;)
10:14:15 <edwardk> (not for your usecase, but in general)
10:14:37 <timthelion> I asked earlier about the infinite type Block = [Either Block Tok] and was told to use data Block = Block [Either Block Tok].  This seems to not work with recursive functions :(  How can I do blocksFromToks tok:toks = Right tok : blocksFromToks toks --  I need to have a box in there, like blocksFromToks tok:toks = Block (Right tok) : bloksFromToks toks -- but obviously that doesn't work :(
10:14:54 <edwardk> ByronJohnson: perhaps the explicit signature i'm putting on would be enough with impredicative types though.
10:15:08 <edwardk> ByronJohnson: if you can write out what the lens should look like by hand it'd go a long way
10:15:10 <nand`> edwardk: in my concrete use case I could just use gets . fmap . view too, sparing the extra use/to
10:15:38 <edwardk> ah true
10:15:42 <jfischoff> alpounet: I made a SWF -> UIKit converter with Haskell. I'm working on type checker for an expression language now. The next big thing is to allow collaborative editing of data for the game.
10:16:10 <ksf> edwardk, http://hackage.haskell.org/package/partial-isomorphisms  and   http://hackage.haskell.org/package/invertible-syntax
10:16:14 <ksf> the paper's somewhere, too.
10:16:22 <edwardk> i'm rather familiar with the paper
10:16:31 <ksf> I was half-way expecting that
10:16:48 <edwardk> i never really liked the invertible syntax approach though
10:16:58 <ksf> and it's probably already included in lenses, already.
10:17:05 <ksf> (in some way or the other)
10:17:29 <edwardk> i don't have partial isomorphisms in there. i do have Iso, and of course you could probably make something that was partial isomorphism-like that would compose with other lenses using
10:17:34 <ksf> because it's invertible or because of its approach?
10:18:20 <c_wraith> I'm confused by the term "partial isomorphism".  much like I'm confused by the automotive term "partial zero"
10:18:22 <ksf> actually, If I really go ahead with this whim, I can't use the partial features anyway.
10:18:35 <edwardk> type PartialIso a b c d = forall f. (Isomorphic k, Pointed f, Functor f) => k (c -> f d) (a -> f b)
10:18:38 <edwardk> c_wraith: likewise
10:19:36 <edwardk> you can build those things and they'll work with other lenses, etc. but i'm not baking them in ;)
10:20:48 <timthelion> c_wraith: well technically the term is incorrect, perhaps "comorphism"?
10:21:48 <ksf> the idea is to split isomorphisms into multiple, not so much use partial features.
10:22:28 <timthelion> Can we please change the channel status from "Identify with NickServ to speak" to "Identify with NickServe to be heard"?
10:23:05 <timthelion> technically you can speak(or write) without being identified...
10:23:15 <ksf> ...and that's needed because there's sum types and alternative.
10:25:10 <nand`> edwardk: in your haddock you have fmapDefault = adjust traverse; what's fmapDefault and how does it differ from fmap?
10:25:14 <edwardk> mostly because of the invertibility, they are hard to compose
10:25:23 <edwardk> nand`: Data.Traversable.fmapDefault
10:25:29 <edwardk> its the same but it requires Traversable
10:25:33 <nand`> oh
10:25:36 <edwardk> its a valid default definition for fmap
10:25:41 <edwardk> given Traversable
10:25:47 <nand`> ah, I get it
10:25:54 <edwardk> there is also foldMapDefault
10:25:59 <edwardk> foldMapDefault = foldMapOf traverse
10:26:16 <nand`> of course now we can use lenses for these defaults :)
10:26:24 <nand`> instance Functor ... where fmap = adjust traverse
10:26:25 <edwardk> thats how Traversable justifies Functor and Foldable as superclasses
10:26:32 <edwardk> yep
10:26:47 <edwardk> or mapOf traverse to sound more idomatic
10:26:55 <edwardk> er idiomatic
10:27:05 <ksf> edwardk, oh, they're magnitudes easier to compose than, say, picklers.
10:27:20 <nand`> that's one thing that's throwing me off about Control.Lens incidentally, so many aliases; often with flipped arguments
10:27:52 <edwardk> well, the thing is they really should be viewed as more of an embedding/projection pair, there is a lot of vocabulary in there i take issue with
10:28:20 <edwardk> nand`: i'm willing to consolidate a few, a lot of them are to complete the set of analogies here and there
10:28:34 <edwardk> e.g. for a while I left off traverseOf
10:28:34 <nand`> it's just a lot to take in at once
10:28:37 <edwardk> yea
10:29:04 <edwardk> this is why i moved all those random combinators out into other modules, to try to make room for the core ideas
10:29:18 <nand`> ‘traverseOf = id’ <- oh good, we needed another one of those :)
10:29:20 <alpounet> jfischoff, looks like pretty cool stuffs :)
10:29:34 <jfischoff> :)
10:29:37 <edwardk> i've also tried shuffling the export list around a bit to move the menagerie of foldMap-like combinators to the bottom
10:29:44 <edwardk> nand`: everything is id with the right types ;)
10:31:30 <nand`> “(%%~) is traverseOf in operator form”
10:32:54 <nand`> of course, the descriptions will be mutually recursive. The fact that they're just ‘id’ will be left as an easter egg in the source code, and to those paying attention
10:35:37 <danharaj> edwardk: "Of course, reversing a Fold or Getter has no effect." Am I missing something? If the monoid you give to a Fold is non-commutative then don't you get a different result?
10:38:12 * hackagebot language-puppet 0.1.6 - Tools to parse and evaluate the Puppet DSL. (SimonMarechal)
10:38:14 <nand`> edwardk: “x^.identity” <- where this is going, pretty soon people will start thinking Haskell is object-oriented
10:39:16 * geekosaur thinks that looks more Pascal than OO...
10:39:32 <geekosaur> (Pointers?  In my Haskell?)
10:43:23 <danil> nand`: the original example fails to typecheck because it infers a type for the body and then can't unify it with the (more polymorphic) type signature.  When you eta-expand, it propagates the annotation to the argument x and checks the body under that assumption, which is fine (it can always instantiate to use x at a less polymorphic type).  It also works to compose with (\(x :: Getter a b) -> x), but again you have to annotate the
10:43:23 <danil> argument and not the function.
10:44:16 <nand`> danil: that clears it up somewhat, thanks
10:45:53 <danil> I wonder if HMF can be made to play nice with type constraints -- it's a lot less picky about these things.
10:51:52 <k0ral> so, anyone getting troubles when installing network package ?
10:55:52 <Palmik> Hmm, is there a way to implicitly import certain module to all your modules in cabal project?
10:56:54 <mm_freak> Palmik: except with ugly solutions like CPP no
10:57:22 <edwardk> danharaj: woops, should be reversing a 'Lens' or 'Getter'
10:57:39 <edwardk> danharaj: Lens Getter, Iso all return exactly one element, so the monoid never gets used
10:57:44 <danharaj> indeed.
10:58:00 <danil> Palmik: if you want to *reduce* the number of imports you can import them into one utilities module and re-export with (module Some.Module.Name) in its export list, but you can't eliminate all of them that way
10:58:04 <danharaj> edwardk: New question. I want to make lenses on STArrays, but there's no place to shove a monad in the types :3 Does this even make sense?
10:58:14 * hackagebot cmdtheline 0.2.1.1 - Declarative command-line option parsing and documentation library. (EliFrey)
10:58:26 <edwardk> unfortunately that doesn't work
10:58:38 <edwardk> working with STArrays, etc. requires you to beat yourself bloody the old way
10:59:35 <edwardk> ah i'd already fixed the reversed docs, its just not the one on hackage yet
11:00:21 <nand`> all of this crazy polymorphy has me puzzling over type signatures a bit: eg.  IsoLike (->) f (t c) (t d) c d; only to find out that it works as a normal function too: “backwards traverse print [1,2,3]” <- which works exactly like I would expect it to
11:02:04 <Palmik> dani, yes, I know about that, I wanted to replace prelude, which I can hide, but then I have to import the modified one everywhere. Time for some sed.
11:02:46 <MaximVeksler> Why: let square x = x * x in map square [1..10] does x as an argument but: let take5s = filter (==5) in take5s [1,5,2,5,3,5] does not ?
11:02:57 <danharaj> edwardk: what happens if I just shove a monad in like this: Lens a b c d = forall m f. (Monad m, Functor f) => (c -> m (f d)) -> a -> m (f b)?
11:03:43 <edwardk> then you could probably make a horrible set of combinators for working with those, but they won't compose with other lenses
11:03:53 <geekosaur> MaximVeksler, square needs to refer to the argumnt twice, the other only once so it can be eta-reduced. that said, there are evil ways to make it eta-reducible
11:04:01 <geekosaur> @pl \x -> x * x
11:04:01 <lambdabot> join (*)
11:05:02 <mietek> What's the benefit of using unboxed vectors vs unboxed arrays?
11:05:14 <geekosaur> ...you will (or should) probably get your fingers smacked for using that in real code, though
11:05:16 <MaximVeksler> geekosaur: OK so what you are saying is that the first argument is always passed to the function?
11:05:29 <MaximVeksler> This does not work: let square = x in map square [1..10]
11:05:41 <geekosaur> sort of.  do you understand the concepts of currying and partial application?
11:06:05 <jfischoff> mietek: the interface is better?
11:06:11 <mietek> jfischoff: which one? :)
11:06:14 * nand` can't decide whether stuff like "foo"^.packed is beautiful or horrendously ugly
11:06:15 <jfischoff> vector
11:06:17 <MaximVeksler> geekosaur: No.
11:06:39 <MaximVeksler> geekosaur: I'm only doing the first tutorial now.
11:07:11 <danharaj> edwardk: Too bad the Identity monad is privileged ._.
11:07:29 <nand`> geekosaur: you think so? I use join in serious code all the time
11:07:30 <edwardk> danharaj: hah
11:07:33 <nand`> on ((->) r)
11:08:32 <geekosaur> ok, so:  Haskell function application is curried.  which means, insted of a function being foo(x, y), it is foo x y.  And, if we then have a binding which has a trailing variable on both sides of an =, we can drop it from both sides (technically this is called ta reduction)
11:09:10 <geekosaur> so, "take5s xs = filter (==5) xs" can be shortened to "take5s = filter (== 5)".
11:09:45 <danil> MaximVeksler: "let square x = ..." is defining a function with argument x, while "let take5s = ..." is just a normal binding; it happens that what you define it as (namely, "filter (== 5)") is of function type, so you can apply it to things
11:09:49 <geekosaur> in the case of square, we need the "x" twice, so without some trickery we have to name it; we can't eta-reduce it away.  ("join" makes use of function application being a monad)
11:10:56 <geekosaur> so, square x = x * x (because if we drop the x from the ends of both sides, we still have an "x" left over) -- but if we use the function monad we can say "square x = join (*) x" and now we can eta-reduce the x away to "square = join (*)"
11:11:16 <nand`> consider: take5 xs = take 5 xs   is the same as   take5 = \xs -> take 5 xs;  when applying this:  (\xs -> take 5 xs) ys = take 5 ys
11:12:03 <danil> > ((map succ) [1..3], let succ'em = map succ in succ'em [1..3])
11:12:04 <lambdabot>   ([2,3,4],[2,3,4])
11:13:30 <MaximVeksler> ok I see that I'm missing theoretical knowledge here. Is the Haskell tutorial teaches about Mondas, eta-reduce, and co. ? If not, where should I read about it?\
11:17:22 <Peaker_> MaximVeksler, LYAH teaches monads. not sure about eta reduce, but that is easy :)
11:17:27 <danil> MaximVeksler: you'll get to monads eventually, and knowing that the difference between "f x = g x" and "f = g" is called eta-reduction is much less important than knowing they do the same thing
11:18:15 <danharaj> it is almost important to know that seq breaks eta reduction, at least.
11:18:27 <timthelion> GHC is telling me this doesn't parse: markBlockLevels' (nl@(NL _):spc@(Spc indent'):toks):tokss indent level =
11:18:30 <timthelion> Why?
11:18:33 <geekosaur> eta reduction is a fancy name for a simple concept, as I said
11:18:40 <timthelion> it says parse error in pattern
11:18:54 <geekosaur> same variable at the end of the things on both sides of an =, and nowhere else, you can drop it from both places
11:19:15 <c_wraith> timthelion: because you have a : outside of parens
11:19:28 <geekosaur> "foo x = bar x" can always be replaced with "foo = bar", as long as whatever "foo" and "bar" are do not otherwise mention x
11:19:33 <timthelion> c_wraith: oh, I *need* parens in that case?
11:19:44 <c_wraith> timthelion: in function definitions, yes
11:19:49 <timthelion> :/ OK
11:19:58 <timthelion> What the hell is this, lisp or something :D
11:20:01 <c_wraith> timthelion: in case statements, no, because they are always a single pattern being matched
11:20:03 <Peaker_> (\x -> (some func) x)  can drop the (\x -> .. x) wrapper, to get (some func)  <-- also eta reduce
11:20:34 <c_wraith> timthelion: but in function definitions, you can be matching multiple different values against the pattern, so it needs to be unambiguous about which patterns are which
11:20:37 <timthelion> c_wraith: thanks, that fixed it
11:20:44 <c_wraith> err, multiple values against multiple patterns
11:20:48 <levi> timthelion: It's just regular precedence rules in action.
11:22:33 * timthelion always forgets to add that one last critical pattern foo [] = []
11:24:23 <veldskoen> sup, does anyone know why this isn't working? divide_cleanly :: Int -> [Int]
11:24:24 <veldskoen> divide_cleanly x = filter p [2..(round $ sqrt x)]
11:24:24 <veldskoen>      where p y = x `mod` y == 0
11:25:55 <eusebio> what would you name a function toTwoDigits :: Int -> String ;; toTwoDigits x = if (length $ show x) == 1 then "0" ++ show x else show x
11:26:10 <byorgey> veldskoen: you cannot pass an Int to the sqrt function
11:26:22 <eusebio> > let toTwoDigits x = if (length $ show x) == 1 then "0" ++ show x else show x in toTwoDigits 5
11:26:24 <lambdabot>   "05"
11:26:27 <eusebio> > let toTwoDigits x = if (length $ show x) == 1 then "0" ++ show x else show x in toTwoDigits 12
11:26:29 <lambdabot>   "12"
11:26:32 <byorgey> veldskoen: round (sqrt (fromIntegral x))
11:26:37 <jfischoff> eusebio: pad
11:26:55 <byorgey> eusebio: I would name it  printf "%02d"
11:27:02 <fmap> (length $ show x) == 1?
11:27:16 <Peaker_> eusebio, rjust n c xs = replicate (n - length xs) c ++ xs     ;   rjust 2 '0'
11:27:27 <Peaker_> rjust 2 '0' . show
11:27:34 <veldskoen> byorgey: thanks!!!
11:27:38 <timthelion> > let toTwoDigits x = if (length $ show x)  == 1 then "0" ++ show x else show x in  toTwoDigits 500
11:27:40 <lambdabot>   "500"
11:30:38 <MaximVeksler> how is Haskell compared to erlang in terms of availability and similarity? I see that both languages are functional and both have similar features such as pattern matching. I'm wondering is someone did / knows of a comparion of major features, for example does Haskell has native implementation of the Actor model?
11:31:17 <Clint> there's http://hackage.haskell.org/package/thespian
11:31:20 <Clint> i haven't tried it
11:32:17 <jfischoff> also https://github.com/haskell-distributed/distributed-process
11:32:27 <eusebio> MaximVeksler: haskell is static, rlang is dynamic
11:32:58 <MaximVeksler> eusebio: what does it mean?
11:33:15 <mapreduce> @google static typing
11:33:17 <lambdabot> http://en.wikipedia.org/wiki/Type_system
11:33:17 <lambdabot> Title: Type system - Wikipedia, the free encyclopedia
11:33:22 <MaximVeksler> are you reffering to typic declarations?
11:33:42 <nyingen> MaximVeksler: they're really very different languages
11:33:45 <int-e> MaximVeksler: another possibility: erlang supports code updates in a running system.
11:33:51 <mapreduce> Related to type declarations, though neither Erlang nor Haskell need type declarations.
11:35:13 <mm_freak> nyingen: they are not that different, but haskell is nonstrict by default
11:35:35 <mm_freak> erlang too enforces purity by default
11:36:00 <timthelion> int-e: haskell has some support for that too.
11:36:13 <timthelion> or ghc does at least
11:36:36 <jfischoff> timthelion: its not part of cloud haskell…yet at least
11:37:00 <nyingen> mm_freak: have you done a lot of erlang programming?
11:37:04 <int-e> timthelion: well, yes, sort of.
11:37:11 <danil> mm_freak: actors are internally pure, but the program as a whole is a giant state machine -- so not quite the same sort of purity
11:37:33 <timthelion> danil: what is impure about a state machine?
11:37:42 <eusebio> jfischoff: whatis cloud haskell?
11:37:56 <mm_freak> nyingen: not a lot, just basics
11:39:44 <jfischoff> eusebio: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
11:39:46 <sm__> who says actors are internally pure ?
11:40:06 <danil> sm__: at least in Erlang they are, it's not essential to the actor model
11:40:39 <danil> timthelion: if you end up doing a lot of "ask Y what the current blah is" and "tell Y to update the current blah" you can get into a pretty imperative mindset -- though of course you don't have to do that
11:41:55 <nyingen> mm_freak: by 'erlang enforces purity' do you just mean that it doesn't allow destructive update? Because erlang functions can perform arbitrary side effects
11:42:05 <timthelion> danil: I don't know, I write applications in Haskell.  I haven't found anything wrong with that approach, however imperative it might be.  The best way to model change, is through change.
11:42:11 <nyingen> I've done a lot of erlang, but I admit I don't know all that much about its internals
11:42:26 <mm_freak> nyingen: sure, but you can't for example update variables by default
11:43:01 <timthelion> mm_freak: kind of makes them not variables then, now doesn't it ;)
11:43:33 <mm_freak> timthelion: why not?
11:43:40 <mm_freak> a variable is a placeholder for a value
11:44:04 <timthelion> mm_freak: A variable is called a variable because it varies
11:44:13 <mm_freak> timthelion: nope
11:44:29 <mm_freak> in common programming languages "variable" is a misnomer
11:45:14 <timthelion> mm_freak: etymologists dissagree
11:45:19 <timthelion> with you that is.
11:46:08 <timthelion> In algebra the word "variable" is actually a misnomer.  The correct word is "symbol"
11:46:38 <JuanDaugherty> ah
11:46:55 <mm_freak> well, of course the possibility exists that for centuries mathematicians have been wrong =)
11:47:22 <mm_freak> a "variable" is a varying quantity, not a changing quantity
11:47:27 <mm_freak> that's a big difference
11:47:27 <timthelion> mm_freak: look in any dictionary.  And yes, ENGLISH SPEAKING mathematicians have made a mistake here :)
11:47:28 <geekosaur> .oO { variables won't, constants aren't }
11:47:34 <danil> timthelion: variable in the mathematical sense means something that varies based on context, not changes through time
11:47:45 <timthelion> danil: that would be a function :)
11:48:06 <geekosaur> timthelion, technical jartgon is a necessity, much as various people would prefer to treat it as some kind of aberration or elitism enabler
11:48:36 <JuanDaugherty> elitism/parochialism
11:48:44 <JuanDaugherty> more the latter most likely
11:48:53 <timthelion> geekosaur: I'm not really trying to change anything, I was just making a snide remark.
11:49:30 <JuanDaugherty> you must be gratified by the response
11:49:33 <geekosaur> yes, it;s just the same snide remark lots of people make, generally because they don't like the idea that precision might actually be something more than just a reason to hassle outsiders
11:51:54 <timthelion> geekosaur: I wasn't trying to hastle any thing, it was simply a bit of banter, that another could look at and go "oh, yeah, that's interesting, wonder how that little etymological leap came about."
11:52:24 <scooty-puff> i've tried hayoo and hoogle with no luck: is there a type class method similar to: fix f -> f (fix f)
11:53:19 <MaximVeksler> This is a very interesting link IMO http://hammerprinciple.com/therighttool/items/erlang/haskell
11:53:52 <scooty-puff> instances would be newtype Fix f = Fix (f (Fix f)) and data LocFix = LocFix Loc (f (LocFix f))
11:58:54 <jimi_hendrix> i apologize for this silly question, but i see reference to a function lookupM, but i cant seem to find what module it is in. google hasnt provided anything useful.
11:59:20 <mapreduce> @hoogle lookupM
11:59:20 <lambdabot> No results found
11:59:25 <jimi_hendrix> hmm
11:59:33 <EvanR> hmm
11:59:41 <EvanR> wheres the reference
12:00:05 <jimi_hendrix> http://www.animal-machine.com/blog/2010/04/simple-math-and-json-in-haskell/ << see the readJSON definition
12:00:38 <jimi_hendrix> then i also found an SO post that references it: http://stackoverflow.com/questions/4973335/does-there-exist-a-monad-instance-for-data-map-data-intmap
12:03:16 <EvanR> lookupM k = MaybeT $ Map.lookup k `liftM` get
12:03:31 <EvanR> in the stack overflow
12:04:00 <EvanR> which doesnt look right
12:04:10 <EvanR> so i think it just doesnt exist
12:05:08 <Peaker_> why doesn't it look right?
12:06:17 <EvanR> :t MaybeT
12:06:18 <lambdabot> Not in scope: data constructor `MaybeT'
12:07:26 <Peaker_> MaybeT :: m (Maybe a) -> MaybeT m a
12:08:18 <Peaker_> in the SO answer, m = State (Map k v)
12:08:29 <latro`a_> looks fine to me, yeah
12:08:47 <latro`a_> oh wait
12:09:00 <latro`a_> ah yeah, right, State (Map k v) (Maybe v), at that stage, right?
12:12:03 <Peaker_> latro`a_, after the liftM, yeah
12:12:48 <eusebio> :t lookupM
12:12:49 <lambdabot> Not in scope: `lookupM'
12:13:02 <eusebio> > flip (-) 3 1
12:13:04 <lambdabot>   -2
12:13:14 <eusebio> @src flip
12:13:15 <lambdabot> flip f x y = f y x
12:13:26 <EvanR> flip flip
12:13:29 <EvanR> pilf
12:14:18 <eusebio> Someone here used google chart API?
12:14:29 <EvanR> flip3a f x y z = f x z y
12:14:37 <EvanR> flip3b f x y z = f z y x
12:14:46 <EvanR> flip3c f x y z = f y x z
12:14:55 <EvanR> flip3d f x y z = f z x y
12:14:56 <mm_freak> please don't list all six+
12:14:58 <EvanR> lol
12:15:53 <luite> eusebio: yeah i use it to draw pretty maps ;p http://hdiff.luite.com/tmp/plot4.png
12:16:23 <eusebio> chats api not google maps?
12:16:33 <eusebio> I just want to plot temps at times of day. like 00:00 to 24:00. I try to use scatter plot but cant make them align nicely
12:16:39 <luite> eusebio: that is the charting api
12:17:06 <jimi_hendrix> ok, thanks
12:18:10 <EvanR> is there a github for darcs
12:19:25 <geekosaur> EvanR, darcsden?  patch-tag?
12:27:55 <EvanR> i dont hear much about darcs in here much
12:27:58 <EvanR> much
12:28:45 <sm__> hub.darcs.net needs some gentle testers
12:31:29 <bitonic> EvanR: git has won.  darcs' advantages are not worth the fact that the world is using another scm.
12:31:58 <EvanR> what are darcs advantages?
12:32:05 <sm> nonsense! :)
12:32:08 <sm> simplicity
12:32:41 <jimi_hendrix> i always preferred hg over git, but github has a nicer interface and it is what the cool kids use these days, i guess
12:33:10 <EvanR> thats why im looking for alternatives, cool is uncool
12:34:02 <bitonic> EvanR: that's a stupid reasoning.  darcs is pretty cool, see http://www.youtube.com/watch?v=iOGmwA5yBn0 , but imo is really not worth it.
12:35:51 <augur> !seen ezyang
12:35:58 <augur> maybe its @seen :x
12:36:00 <augur> @seen ezyang
12:36:01 <lambdabot> Unknown command, try @list
12:36:08 <augur> D:
12:36:09 <augur> @list
12:36:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:36:31 <geekosaur> seen doesn;t live in lambdabot any more
12:36:37 <geekosaur> preflex: seen ezyang
12:36:38 <augur> :(
12:36:38 <preflex>  ezyang was last seen on #haskell 3 days, 16 hours, 13 minutes and 56 seconds ago, saying: "Screw that: I want to write functions that take types and values and do reasonable things!"
12:36:45 <augur> oh its preflex
12:36:45 <jimi_hendrix> i want to serialize / deserialize some of my data types to a human readable / editable format. what should i look into?
12:36:56 <augur> what is preflex, anyways
12:37:07 <geekosaur> preflex: help
12:37:07 <preflex>  try 'help help' or see 'list' for available commands
12:37:11 <geekosaur> preflex: list
12:37:11 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
12:37:12 <preflex>  ZCode: [zdec, zenc]
12:37:18 <geekosaur> hmmmm
12:37:20 <eusebio> @list
12:37:20 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:37:37 <geekosaur> preflex: version
12:37:37 <preflex>  5.897
12:37:42 <geekosaur> ...not helpful
12:37:58 <eusebio> @slap geekosaur
12:37:59 * lambdabot smacks geekosaur about with a large trout
12:38:10 <geekosaur> @version
12:38:11 <lambdabot> lambdabot 4.2.2.1
12:38:11 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:38:18 <eusebio> @vixen vixen
12:38:18 <lambdabot> They're not like us. They smell different, they look different, they act different.  The trouble is, you can't find one that's honest.
12:38:22 <geekosaur> LB tells you what it is, at least
12:38:28 <nyingen> jimi_hendrix: do you like XML?
12:38:51 <ParahSailin_> http://www.cse.unsw.edu.au/~chak/papers/sel4-model.pdf interesting paper
12:38:57 <jimi_hendrix> nyingen, acceptable
12:39:07 <alpounet> geekosaur, http://www.haskell.org/haskellwiki/IRC_channel#preflex
12:39:07 <nyingen> jimi_hendrix: hexpat-pickle is pretty easy to use
12:40:18 <nyingen> jimi_hendrix: it's been awhile since I've done anything like that, though, so someone may have invented something more automagical in the meantime. Poke around on hackage
12:41:25 <jimi_hendrix> k
12:43:49 <lpsmith> Has anybody gotten a Haskell process running as a windows service?   How hard is it?   I don't know too much about Windows programming at this point and I did find this Stack Overflow question:  http://stackoverflow.com/questions/10037654/how-can-a-windows-service-application-be-written-in-haskell
12:44:43 <Peaker_> EvanR, darcs does tracked cherry-picks -- which cover all use cases nicely.  git uses snapshots and merges, with a poor form of untracked cherry-picking.   darcs handles conflicts more gracefully and has a simpler model.  git is faster.   Most of the time, git is good enough, even if darcs is a little better, so performance won out
12:53:27 <eusebio> who coded darcs?
12:53:55 <sm> david roundy, and a bunch of helpers
12:53:57 <edwardk> eusebio: david roundy and a bunch of others on #darcs
12:54:11 <edwardk> eric kow maintains it now
12:54:22 <edwardk> (well, with a bunch of others)
12:54:59 <eusebio> Is darcs distributed like git?
12:55:46 <Clint> yes
12:55:57 <timthelion> The trouble with lazy lists, is that if you have a function that eats a list and returns a new one and it returns 1:2:3:omgsomethinghappenedWhichHasMadeTheFirstElementsInvalid you're not sure how to recover...
12:57:47 <mekeor> s/, is that/is, that/ #  i think.
12:58:24 <Eduard_Munteanu> How about no comma there?
12:59:03 <mekeor> that's best.
12:59:31 <tew88> Are there any specific resources people would recommend for A) switching from GUI editors/IDEs to Vim; B) Tweaking/customising Vim so as to be more useful than it otherwise would be in the context of Haskell development?
13:00:03 <timthelion> tew88: I haven't had to tweek vim at all.
13:00:15 <Eduard_Munteanu> Maybe save for expandtabs and such
13:00:30 <timthelion> tew88: I think that dons wrote quite a bit on the subject back in the day, if you go check out xmonad.org ^_^
13:00:44 <timthelion> what is expandTabs?
13:00:49 <tew88> timthelion: I saw a setup (assumed it was non-standard) on haskelllive.com that got me curious
13:01:07 <tew88> timthelion: Thanks, I'll take a look
13:01:26 <timthelion> tew88: did you see the evil face?  xmonad is a bit of a rabit hole :)
13:01:39 <Eduard_Munteanu> @google vim expandtabs
13:01:40 <lambdabot> http://vim.wikia.com/wiki/Converting_tabs_to_spaces
13:01:40 <lambdabot> Title: Converting tabs to spaces - Vim Tips Wiki
13:02:04 <sipa> a rabid hole, or a rabbit hole? *ducks*
13:02:06 <tew88> timthelion: Thanks retracted!
13:03:08 <timthelion> Eduard_Munteanu: I am feindishly anti tab.  However, I think that when I write my own code, I never have to use the tab key, and if I'm editing someone elses, it's not worth working with such an idiot as actually uses tabulators so I usually stop :D
13:03:34 <edwardk> eusebio: yes
13:03:44 <timthelion> tew88: ^_^ but xmonad + gnome-terminal + vim + ghci IS an IDE...
13:03:47 <edwardk> eusebio: there are also hosting providers for it like patchtag and darcsden
13:03:47 <eusebio> Would it be wrong to use a Bar diagram for plotting temp as a function of hour of the day?
13:04:02 <Cale> timthelion: I just have expandtabs on, and set my tabstops at 2 spaces, so that I can use the tab key as a spacebar that's a bit faster
13:04:45 <byorgey> eusebio: yes, bar diagrams imply that there are quantites which can be compared (proportional to the bar areas)
13:04:48 <EvanR> Peaker: yeah thats what i heard back when git became a thing, 'its fast'
13:04:48 <timthelion> Cale: that's an OK use, I guess, but you really shouldn't be ending up with large indents if you want to stay within 80 chars writting haskell...
13:04:55 <Eduard_Munteanu> Do you never just indent a "level"?
13:05:06 <Cale> I often don't stay within 80 characters :P
13:05:23 <byorgey> eusebio: use a line graph, which is more appropriate for a measurement changing over time
13:05:31 <timthelion> Eduard_Munteanu: when I do that, I go to the previous line, and press enter?
13:05:36 <tew88> timthelion: Sounds like the Holy Grail ;)
13:05:45 <Eduard_Munteanu> Mm, fair.
13:05:57 <nh2> can I put "-threaded" into a {-# OPTIONS_GHC #-} - like pragma?
13:08:00 <nh2> it works in .cabal's "ghc-options", but not in the beginning of the file.
13:08:10 <geekosaur> threaded is a static option, so no
13:08:35 <geekosaur> see http://www.haskell.org/ghc/docs/latest/html/users_guide/ch04s02.html#source-file-options
13:08:38 <nh2> geekosaur: by static option, do you mean "applicable only when static-linking"?
13:08:52 <geekosaur> no.  see the URL I just pasted for how ghc options are classified
13:09:13 <nh2> geekosaur: thanks
13:09:51 <eusebio> give me a degree sign as in degrees celsius. cant find it on me keyboard
13:10:11 <nh2> eusebio: °
13:10:21 <geekosaur> it's option-shift-8 on Macs...
13:10:23 <eusebio> ty
13:10:25 <shachaf> ℃
13:11:07 <veldskoen> hi, i'm busy building a function so pls ignore the commented out bit. Does anyone know whats wrong with:
13:11:09 <veldskoen> largest_palin :: [Int] -> String
13:11:09 <veldskoen> largest_palin (x:[]) = if a == b then show a else "Sorry there are no palindromes!"
13:11:09 <veldskoen> -- largest_palin (x:xs) = if a == b then show a else largest_palin xs
13:11:09 <veldskoen>     where   a = show x
13:11:09 <veldskoen>                         b = reverse $ show x
13:11:22 <geekosaur> indentation looks wonky
13:11:33 <shachaf> veldskoen: The indentation seems to have something to do with it.
13:11:40 <veldskoen> it printed weird but the b is underneath the a in my code
13:11:43 <shachaf> Usually you'd put your code on hpaste.org or something like that, and paste the error along with it.
13:11:53 <shachaf> veldskoen: The problem is probably that you're using a tab character.
13:11:56 <shachaf> Don't do that. :-)
13:12:47 <veldskoen> shachaf: yeah i was tabbing... cool thanks!
13:14:23 <veldskoen> shachaf: yip it was the tabs... also explains sooo many other issues I've been having
13:14:32 <veldskoen> thanks!
13:16:41 <EvanR> tabs considered harmful
13:16:51 <weasels> why does cabal-dev require mtl-2.0?
13:16:56 <weasels> mtl-2.0.1.0*
13:17:10 <EvanR> in the next version of the the keyword tab should be renamed 'autocomplete'
13:18:55 <tew88> timthelion: My googling isn't coming up trumps -- any links/search-terms you can recommend to assist me in finding my xmonad/gnome-terminal/vim/ghci zen?
13:19:00 <veldskoen> ha ha yeah
13:21:17 <fmap> tew88: ghc-mod, neco-ghc, neocomplicache
13:21:47 <tew88> fmap: tyvm
13:24:44 <timthelion> tew88: other than the ..'s for the spaces, he's not using anything unusual in vim, but he has some fileChange handler set up to automagically recompile the file on save.  That is outside of vim imo
13:26:50 <tew88> timthelion: And the separate buffers (windows?) for his ghc(i) instances are facilitated by xmonad?
13:28:06 <timthelion> tew88: Sorry, I was speaking about the video you linked to in that last statement.
13:28:34 <timthelion> tew88: but yes, that set up can be done in 3 ways, vim's internal window system, gnu screen, or xmonad/another tiling wm
13:29:11 <Hermit> wmii <3
13:29:59 <tew88> timthelion: Thanks a lot, I'll spend some time fiddling :>
13:30:32 <timthelion> advantage of vim's internal windows: customizability, better clipboard support within vim, advantage of gnu screen: it has magical recovery abilities if you happen to crash your xsession a lot, advantage of xmonad, you can switch to firefox, and intermix terminal windows with gui windows without resizing issues.
13:32:44 <Hermit> also, if you want screen-like recovery without screen, use dtach
13:33:07 <timthelion> Hermit: or simply a one window screen :)
13:34:09 <Hermit> timthelion: the problem is it will capture C-a or some other key for screen operations. I, as an emacs user, hated that when using emacs on a terminal. I don't care about it anymore since I'm using emacs-server for protecting my editing from crashes
13:34:48 <gwern> @quote terminal
13:34:48 <lambdabot> lispy|web says: This curses binding appears to be terminally broken
13:34:56 * gwern groans
13:35:09 <otters> @quote php
13:35:09 <lambdabot> stepcut says: I wrote 1 + 1 in php once, and got 11 -- wasn't quite what I was hoping for
13:35:09 <timthelion> Hermit: I was also using screen+emacs, but since so many people where doing that at the time C-a was never a big problem.  Now, with xmonad, it has been a LONG time since x crashed on me :D
13:35:42 <otters> what's this new .p_o output format that GHC produces in haskell-platform 2012.2
13:35:54 <mekeor> timthelion: :D
13:36:44 <gwern> otters: some sort of instrumented profiling version one would assume
13:36:46 <Hermit> timthelion: good to hear. I'm currently on OSX so there are no X crashes (everything is pretty damn stable). When on X though, I can't live without wmii
13:36:59 <otters> gwern: do I need it?
13:37:02 <otters> and if not, can I turn it off?
13:37:07 <otters> because it makes compiles almost exactly twice as long now
13:37:09 * gwern shrugs
13:37:20 <timthelion> Hermit: and do you use OSx's strange window manager?  I never could understand it...
13:37:22 <gwern> otters: I've given you the keyword to search for
13:37:51 * mekeor slaps gwern.
13:37:51 <otters> I see, it is profiling
13:38:22 <mekeor> was fun. :D
13:38:39 <timthelion> Hermit: I'm not trying to insult osx by that, I mean I also didn't understand vim when I started using it...
13:38:50 <timthelion> just currious.
13:39:02 <timthelion> mekeor: you sadist.
13:39:05 <Hermit> timthelion: to be honest, it sucks. I never liked the overlapping windows desktop paradigm. Moom (a window positioning app) is helping me live with it, but I'm longing to get back to wmii
13:39:33 <timthelion> Hermit: http://www.haskell.org/haskellwiki/Xmonad/Using_xmonad_on_Apple_OSX
13:39:35 <mekeor> timthelion: :P
13:39:58 <Hermit> timthelion: osx's window management improves A LOT when using the magic trackpad. This thing is inmense and multitouch.
13:40:03 <timthelion> Hermit: I guess you can do that with wmii too.
13:40:34 <Hermit> timthelion: yeah, but only on X11. I have to deal with OSX's window management for every native app
13:40:42 <timthelion> Oh, I see :(
13:41:04 <timthelion> under cygwin you can use ratpoison on windows even for native apps, so I thought that was similar for osx...
13:42:34 <Hermit> osx has this window server thing that is nowhere as flexible as X11, although way more stable (never ever crashed on me)
13:42:43 <timthelion> I don't really need a window manager to be honest, I have messed up vision, so I just full screen everything and make the font giant :D  When I was using emacs, I used to just have .xinitrc declare the proper geometry and then run without one...
13:43:23 <timthelion> Hermit: I don't think X11 itself has ever crashed on me either.  It's the drivers, and or the WM's that do the crashing.
13:43:31 <Hermit> by the sound of it, I'm assuming you ditched emacs for vim, right?
13:44:35 <timthelion> Hermit: Nah, I was an emacs fanatic.  Then I decided to find out what people and friends where all about.  When I decided I liked programming better than getting drunk, I decided to try vim...
13:44:56 <timthelion> but when I was a teen I used emacs all the time, never really had a good reason to move away...
13:45:08 <Hermit> timthelion: http://www.haskell.org/haskellwiki/Xmonad/Using_xmonad_on_Apple_OSX#Does_Not_Replace_Quartz.2C_Silly   <-- this is what I was talking about
13:45:41 <k0ral> hi
13:45:47 <mekeor> hi k0ral :)
13:45:47 <Taneb> Hey
13:45:59 <mekeor> hi Taneb =]
13:46:03 <timthelion> Hermit: pitty.
13:46:18 <k0ral> I'm again in a situation where I'm convinced there's an elegant way of dealing with it
13:46:31 <k0ral> but I can't figure it out alone so I need your help
13:47:04 <k0ral> I'm using several error-prone libraries which raise various exceptions
13:47:19 * timthelion gets into meditative position and begins to hover, before asking in a low spiritual voice what k0ral 's problem is.
13:47:48 <k0ral> each lib raises exceptions that are instance of Exception, with throw or throwIO
13:48:46 <k0ral> I wrote my own try function using as follows: try = (io . Control.Exception.try) >=> either (throwError . XXX) return
13:49:47 <k0ral> at first, there was only one kind of exception, it was IOError, so I made XXX e :: IOError -> MyCustomErrorType
13:50:06 <k0ral> now I want to handle both IOError and another exception type using the same try fonction
13:50:37 <k0ral> I could write another try' function with YYY e :: OtherException -> MyCustomErrorType
13:50:57 <k0ral> but I have the feeling there's a way of making try generic enough to support both exceptions
13:51:18 <k0ral> is it possible ?
13:51:29 <k0ral> oh, btw io = liftIO
13:53:09 <mm_freak> k0ral: you can't do that, but you can write multiple 'catch'es
13:53:27 <k0ral> mm_freak: you've broken my heart
13:53:36 <mm_freak> c `catch` (\(XXX e) -> …) `catch` (\(YYY e) -> …)
13:54:04 <k0ral> I don't want to catch the error at that level, I want it to be thrown
13:54:34 <k0ral> but within my custom error type rather than heterogeneous types
13:54:57 <mm_freak> so you want to have all exceptions as your own exception?
13:55:39 <k0ral> well, I work in a MonadError MyCustomError, so yes I would like to project every third party error onto MyCustomError
13:55:55 <danharaj> edwardk: I have a problem. http://hpaste.org/72450
13:55:58 <mm_freak> you could certainly write this:  instance (Exception e1, Exception e2) => Exception (Either e1 e2)
13:56:10 <otters> "Failed to load interface for `Prelude'"
13:56:11 <otters> oh god
13:56:28 <mm_freak> k0ral: in this case it means:  instance (Exception e) => Exception (MyException e)
13:56:45 <mm_freak> but you will need to wrap everything
13:57:06 <edwardk> danharaj: its instantiating it monomorphically, put in a signature.
13:57:21 <k0ral> mm_freak: I've already wrapped every single exception type I may run into
13:57:28 <danharaj> If I put a top-level signature it gives me a complaint about rigid type variables.
13:57:30 <edwardk> you can also use 'filtered'
13:57:37 <k0ral> mm_freak: into a single datatype
13:57:45 <danharaj> There's a filtered, huh.
13:57:48 <edwardk> =)
13:57:52 <mm_freak> k0ral: that's not what i mean
13:57:55 <k0ral> mm_freak: sorry but how is that helping to make my error type instance of Exception ?
13:58:11 <mm_freak> data MyException e = Builtin e | Mine String
13:58:44 <danharaj> It'd probably be good to know how to fix this anyway.
13:59:01 <k0ral> mm_freak: wouldn't that work for a single e at a time ?
13:59:17 <mm_freak> k0ral: it would, but what's the point?
13:59:29 <mm_freak> i'd go with multiple exception types
14:00:30 <edwardk> danharaj: not sure where the problem is off hand. when they traverse your grid can they put back in any position they want?
14:00:34 <k0ral> mm_freak: how does it play with MonadError ? can you "combine" several MonadError ? (MonadError Error1 m, MonadError Error2 m) => m () ?
14:01:27 <mm_freak> k0ral: it doesn't…  MonadError is not flexible enough for that, so you may want to check out monad-control and lifted-base
14:02:41 <hpc> see also
14:02:42 <hpc> http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/
14:02:53 * shapr boing cheerfully
14:03:59 <mcstar> No match in record selector mnodeVal
14:04:02 <mcstar> wth is this about?
14:04:15 <mcstar> mnodeVal is a record field
14:04:23 <k0ral> mm_freak, hpc: I'll take time to read it and come back later
14:04:24 <mcstar> the error is a runtime error
14:04:27 <danharaj> edwardk: not sure. It's essentially the same thing as traverseArray. Grid just keeps some metadata.
14:05:23 <danharaj> oh, I suppose the fact that I pass the index along with the value can matter.
14:05:40 <edwardk> yes
14:05:47 <edwardk> you aren't allowed to edit the position
14:05:53 <edwardk> or you break the laws =P
14:06:34 <danharaj> I should add that constraint to the type. I just want to make the position available for reading.
14:06:58 <danharaj> wait, can I even do that.
14:07:54 <edwardk> you can't safely do that
14:08:08 <edwardk> you can make a lens for each position probably
14:08:39 <edwardk> Position -> Simple Lens (Grid a) (Maybe a)  -- or a depending on if all positions are legal, etc.
14:08:55 <edwardk> what is a Grid?
14:09:42 <danharaj> Grid { _base :: Position, _region :: Rect, _arr :: Array Position a}
14:10:29 <danharaj> Because I do a lot of getting and setting subregions and translating indices.
14:10:56 <danharaj> What if I make the type of traverseGrid :: Traversal (Grid a) (Grid a) (Position, a) a?
14:11:55 <edwardk> thats illegal i can't instantiate it by passing traverse id
14:12:04 <edwardk> so you're out in uncharted dangerous territory =P
14:12:32 <danharaj> mm
14:12:46 <mcstar> No match in record selector mnodeVal
14:12:53 <mcstar> how can i debug this ^^
14:13:17 <danharaj> edwardk: is that one of the traversal laws?
14:13:40 <edwardk> yes, read the essence of the iterator pattern
14:13:47 <danharaj> yes I should go do that right nwo.
14:14:04 <edwardk> traverse Identity = Identity
14:14:25 <hpaste> eschew pasted “higher rank example” at http://hpaste.org/72451
14:14:34 <edwardk> so l Identity = Identity should hold for any Lens, Traversal, etc.
14:14:58 <eschew> hi happy haskell hackers!
14:15:50 <ksf> urgs the official grammar is ambigious.
14:16:04 <ksf> well, at least along the lexing/parsing line.
14:16:16 <mcstar> damn
14:16:20 <mcstar> i figured it out
14:16:34 <eschew> can anyone give me insight for why GHC rejects the example at http://hpaste.org/72451 ?
14:16:36 <ksf> qconid and modid look exactly the same.
14:17:00 <eschew> it's the second "well-typed" example from section 3.3 of spj's paper on higher rank type inference.
14:17:03 <ksf> they're disambiguated by context, so they should lex the same.
14:18:23 <mroman> I'd say it's because you have a function that must work foral b, but you pass Int to it
14:18:37 <mroman> and Int is not b.
14:18:59 <tylerkahn> hmm can someone explain why explicit forall is useful?
14:19:02 <danharaj> edwardk: I wonder how dangerous it is to not obey laws that don't typecheck :P
14:19:15 <edwardk> here its bad =P
14:19:24 <eschew> mroman: k2 expects to be given a function of type [Int] -> [Int], and g promises to pass it a *more* polymorphic function, so it should be ok.
14:19:27 <edwardk> you're violating the family structure
14:19:33 <eusebio> How do I kill myself if im a Haskell program?
14:19:41 <edwardk> everything is written assuming the family structure from my mirrored lenses post
14:19:52 <ksf> @hoogle exitWith
14:19:53 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
14:20:08 <tylerkahn> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html
14:20:09 <tylerkahn> yeah
14:20:17 <edwardk> man, a straight answer to that question, i expected some side-effect jokes
14:20:46 <jfischoff> edwardk: its not too late ;)
14:21:11 <danharaj> edwardk: Fair enough. Still, these traversals that see more than they can say seem useful.
14:21:13 <latro`a_> technically you don't kill yourself, you have to make something that asks the runtime system very nicely to kill you
14:21:46 <nh2> shouldn't Data.Conduit re-export liftIO?
14:22:36 <edwardk> yeah, sadly i can't comeup with a nice way to make them composablea
14:22:54 <edwardk> they break the (a -> f b) family structure
14:23:10 <edwardk> i agree that keyed structures are handy
14:23:15 <danharaj> Composable at all, or just composable as functions?
14:23:15 <edwardk> i have a whole package of them =)
14:23:24 <edwardk> as functions mostly
14:23:39 <edwardk> they break the pattern so its hard to know what to do with them
14:24:00 <danharaj> Since you're already using Category for isos, maybe wrapping lenses in a newtype to get better composition (and in the right direction! :P) isn't too big a price.
14:24:06 <eusebio>  add an instance declaration for (Num ExitCode)
14:25:01 <danharaj> on the other hand that's a big departure from what everyone expects from van Laarhoven lenses. I guess I'll just fork and see what happens.
14:25:13 <conal> is there a current/working tool for generating a haskell module dependency graph?
14:25:45 <Taneb> I tried to write one, never got far
14:25:47 <eusebio>  add an instance declaration for (Num ExitCode)
14:25:51 <c_wraith> well, ghc obviously does it.  That's not the most useful example, though
14:26:26 <danharaj> On the other hand I can just use the less broken type and promise not to break the law.
14:26:36 <ksf> conal, ghc -M ?
14:26:48 <ksf> the hardest thing is getting at that info.
14:27:02 <eusebio> @hoogle exitWith
14:27:02 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
14:27:03 * ksf recommends against using the ghc lib for that
14:27:14 <eusebio> @hoogle ExitCode
14:27:15 <lambdabot> System.Exit data ExitCode
14:27:15 <lambdabot> System.Process getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
14:27:15 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
14:27:43 <conal> pwd
14:27:45 <conal> oops
14:27:53 <mekeor> heh
14:28:40 <edwardk> danharaj: i've been willing to write a few 'use at your own risk' traversals. i have ones for Language.Haskell.TH.Lens that do things like access free variables, but you have to ensure that the target Name when you use them to write back isn't bound.
14:29:13 <ksf> conal, as for visualising, http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-Graphviz.html
14:29:24 <conal> ksf: nice. thanks!
14:29:45 <otters> hmmm
14:29:59 <otters> ghci expects whatever's inside $(...) to be Q Exp
14:30:04 <otters> but I have a Q [Dec] here
14:30:26 <ksf> ghci is a do block.
14:30:32 <ksf> those import statements are a hack.
14:31:09 <conal> oh, hm. there's also the graphmod package. i'll check it out, too.
14:31:13 <otters> oh
14:31:15 <otters> well, fuck
14:33:47 <danharaj> I wonder how good GHC is at fusing array changes.
14:33:55 <danharaj> Because otherwise I will be spewing garbage everywhere.
14:34:24 <edwardk> heh
14:34:37 <c_wraith> I don't think GHC fuses anything with arrays at all
14:34:44 <c_wraith> If you want fusion, use vector
14:35:23 <scooty-puff> are ConstraintKinds for synonyms to tuples of constraint kinds often used, or more often used for a Constraint assoc type (or other use), or not at all?  are they inconvenient as synonyms?
14:36:35 <scooty-puff> trying to gauge how good or bad of an idea require such an extension on a library is - as far as how unfamiliar it might be
14:41:23 <thoughtpolice> scooty-puff: they're so recent of an extension it's hard to say what they're 'often' used for. it's convenient for synonyms, and much clearer than doing the same with UndecideableInstances etc
14:42:54 <thoughtpolice> if you don't want to require such recent extensions, you can just hack it with UndecideableInstances by saying something like: 'class Synonym a; instance (Ord a, Num a, ...) => Synonym a where'
14:43:27 <scooty-puff> thoughtpolice: you mean with dumy class/instances - class LotsOfStuff a => Simple a; instance LotsOfStuff a => Simple a?
14:43:33 <scooty-puff> blah
14:43:37 <scooty-puff> i should type and read at the same time..
14:49:16 <EvanR> fizz buzz without modulo http://hpaste.org/72453
14:49:36 <EvanR> based on a random ruby snippet i just saw which reminded me of haskell https://gist.github.com/3230760
14:49:57 <edwardk> danharaj: t Identity = Identity; t (Compose . fmap f . g) = Compose . fmap (t f) . t g -- are the laws
14:50:51 <danharaj> I was just reading that page. Are you a wizard?
14:51:39 <thoughtpolice> edwardk actually makes real wizards question their abilities
14:52:34 <danharaj> edwardk: how is naturality constraint written?
14:52:39 <danharaj> the*
14:53:27 <mm_freak>     a="Fizz"
14:53:27 <mm_freak>     b="Buzz"
14:53:27 <mm_freak>     main=mapM_ putStrLn[[show x,a,b,a++b]!!mod(div(gcd 15 x)2)4|x<-[1..]]
14:53:57 <mm_freak> yeah, there is mod in der, but the aim wasn't to be elegant, but to be short =)
14:54:10 <mm_freak> s/der/there/
14:54:32 <mm_freak> @ EvanR that is
15:07:15 <mm_freak> is there a way to make release candidates using cabal/hackage, such that the previous version is still installed by default?
15:07:54 <c_wraith> upload with a lower version.. (this is a bad idea)
15:08:37 * hackagebot happstack-yui 7360.4.1 - Utilities for using YUI3 with Happstack. (DagOdenhall)
15:09:04 <mm_freak> hmm, ok…  i guess not
15:11:14 <jfischoff> mm_freak: for awhile parsec was not on the latest, so I think it is possible. You might have to email the guy who manages hackage to change the number though.
15:11:42 <mm_freak> that's probably not worth the trouble
15:12:02 <clsmith> i know this is somewhat OT, but does anyone know of any uh, "design patterns" for modelling typeclasses in C? specifically i want to create a function to admit any semiring, but my attempts have all been really ugly.
15:12:24 <mm_freak> clsmith: nothing nice/static
15:12:41 <c_wraith> You can kind of do it with C++ templates, but in C..  yeah, it's pain
15:12:47 <mm_freak> clsmith: you can approximate it with C++…  it will still be ugly, but at least it will become static
15:13:05 <clsmith> hrm :/
15:13:37 * hackagebot fay 0.5.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript. (ChrisDone)
15:14:46 <tylerkahn> clsmith maybe intrusive data structures?
15:16:47 <ksf> pass around a struct with function pointers?
15:17:40 <tylerkahn> hmm
15:17:58 <tylerkahn> maybe you create a typedef called Semiring_t
15:18:18 <tylerkahn> ...
15:18:39 <Ralith> clsmith: interface-passing is viable.
15:19:16 <tylerkahn> hmm
15:19:17 <tylerkahn> idk
15:19:49 <Saizan> but what would be the type of the function pointers in the struct?
15:20:44 <Ralith> the type of a pointer to a function which implements that portion of the interface, of course.
15:20:54 <Saizan> sure
15:21:22 <Saizan> but you can't parametrize a struct type definition over a type, or can you?
15:21:52 <clsmith> i'm currently erring towards just having a macro which creates a new set of functions with the specific instance's values/functions... erk :/
15:21:59 <Saizan> so in e.g. mappend :: a -> a -> a; what would you use in place of a in this encoding?
15:25:09 <dmwit> :t filterM
15:25:11 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:25:14 <Peaker_> I'd use something like:  struct mappend { void *(*mappend)(void *env, void *a, void *b); void *env; }     and then:   void *sum_mappend(void *env, void *ap, void *bp) { uintptr_t a = (uintptr_t)a; ...
15:25:45 <Peaker_> and struct mappend sum_mappend_table = { &sum_mappend };
15:26:13 <dmwit> Screw you, type system! I made my own type, and everything has that type.
15:26:24 <Peaker_> when it isn't classical single-dispatch, it's hard to get type-safety in C
15:29:16 <osa1> can anyone give me an example of mutating variables in this structure: http://hpaste.org/72454 I'm trying to understand ST monad
15:29:54 <dmwit> uh
15:29:57 <dmwit> That type is wrong.
15:30:22 <Peaker_> osa1, The "s" of ST is not a state-type. It is never supposed to be any concrete type
15:30:26 <dmwit> You almost never choose an actual type for the first parameter of ST-based type constructors like ST, STRef, STArray, etc.
15:30:59 <Clint> anyone know where http://www.haskell.org/onlinelibrary/ix.html moved to?
15:31:04 <Peaker_> osa1, it's more a "tag" used on ST computations and ST variables that links them together so state from different ST computations doesn't get mixed
15:31:13 <c_wraith> there's only one case in which choosing a specific type for that s isn't an error...  converting ST s to IO
15:31:21 <dmwit> The first parameter is somewhere between an implementation detail and a hint to the type-checker to make sure you don't return mutable things from your final immutable computation.
15:31:27 <osa1> uh. so can anyone give me a corrent example then? I have a code with IORef's and I want to change it to STRef
15:31:38 <dmwit> osa1: Just change IORef to STRef s everywhere.
15:31:40 <osa1> correct*
15:31:43 <osa1> oh
15:31:45 <Peaker_> dmwit, You can return mutable things, you just can't mix them with other ST computations later
15:32:03 <dmwit> Peaker_: You can not return mutable things from your final immutable computation.
15:32:08 <dmwit> I said a precise thing, and meant it precisely.
15:32:28 <Peaker_> @type runST (newSTRef 0)
15:32:29 <lambdabot>     Inferred type is less polymorphic than expected
15:32:29 <lambdabot>       Quantified type variable `s' escapes
15:32:29 <lambdabot>     In the first argument of `runST', namely `(newSTRef 0)'
15:32:34 <dmwit> See? =)
15:32:41 <Peaker_> oh, I may have a misunderstanding :)
15:32:59 <dmwit> (The fact that this doesn't type-check is sort of the whole point of the parameter.)
15:33:05 <EvanR> :: Int -> IORef A
15:33:22 <EvanR> ^ mutable things from immutable computation
15:33:23 <EvanR> ;)
15:33:30 <dmwit> osa1: (And of course change IO to ST s everywhere, and change IOArray to STArray s everywhere, and so on.)
15:33:53 <dmwit> EvanR: You didn't (yet) write an implementation of that type. =)
15:34:00 <EvanR> i realize i cant
15:34:04 <dmwit> okay
15:34:04 <Peaker_> dmwit, I thought the point was to prevent using the escaped mutable data, rather than prevent its escape in the first place. Apparently I was wrong.. re-reading all the types now :)
15:34:06 <EvanR> :: Foo -> IORef A ;)
15:34:13 <EvanR> for suitable Foo
15:34:45 <dmwit> EvanR: Only for Foo that contain an IORef A already... and you can't have things that contain an STRef s already.
15:35:01 <EvanR> is that so
15:35:02 <dmwit> hm, that last part was not what I meant
15:35:06 <dmwit> Let me try again.
15:35:18 <osa1> dmwit: it didn't work. I got some errors about kind mismatch when I just change every IORef to STRef
15:35:25 <Peaker_> newer GHC gives a different error for that: Couldn't match type `a' with `STRef s Char'
15:35:29 <dmwit> osa1: Read my suggested change again. =)
15:35:43 <c_wraith> osa1: IORef -> STRef s
15:36:39 <Peaker_> dmwit, hmm.. if Haskell had first-class existentials,   wouldn't   runST (newSTRef 'x')    type-check, and have the type:  exists s. STRef s Char   ?
15:36:56 <dmwit> EvanR: Here's what I meant to say: if Foo already contains an IORef (resp. STRef), then it can only be produced within IO (resp. ST) anyway, so having a pure function which extracts a bit of it doesn't result in a pure computation producing impure data either.
15:37:29 <dmwit> Peaker_: Yes, you can even write a non-first-class existential and do just that.
15:37:45 <dmwit> data Box a = forall s. Box (STRef s a)
15:37:59 <dmwit> runST (fmap Box (newSTRef 'x')) :: Box Char
15:38:14 <Peaker_> yeah, and then I can "leak out" my mutable state (which would become unusable either mutably or unmutably)
15:38:20 <dmwit> Nope.
15:38:26 <Peaker_> why not?
15:38:26 <dmwit> It's existential, there's nothing you can do with it. =)
15:38:39 <dmwit> (The 's' was an existential to begin with.)
15:39:02 <Saizan> you would get the box out and access to the STRef inside
15:39:13 <c_wraith> the s inside the box won't match the the s in ST s, though, so you can't use it.
15:39:16 <dmwit> Oh, sorry, yes, I agree that you "leak out" the mutable state, but that it's unusable either mutably or unmutably.
15:39:17 <Peaker_> Right, you can't do anything with it, but it is an STRef, and it's out,  I guess it's a matter of whether you consider (exists s. STRef s a) to be "mutable state" or "useless value"
15:39:27 <dmwit> I'm not sure in what sense you call that a "leak", though.
15:40:03 <Saizan> btw, you could use (==) on it!
15:40:14 <Saizan> but only with itself
15:40:19 <c_wraith> haha
15:40:25 <c_wraith> that'd better return True
15:40:28 <mm_freak> Peaker_: well, there are no predefined functions to do anything with it, but conceptually nothing stops you from writing some
15:40:35 <Peaker_> dmwit, I've always viewed ST as preventing mixing of mutable values from different computations, rather than as preventing escape of a mutable ref out of an ST computation. I guess the more precise description is that it prevents the escape of universally-quantified/usable mutable state
15:40:36 <t7> wow the key size needed for fully homomorphic encryption is 600kb
15:40:41 <mm_freak> that's why it's necessary that STRef is opaque
15:40:44 <dmwit> mm_freak: Yes, something does stop you from writing some: the type system.
15:40:53 <dmwit> oh, yes, assuming STRef is opaque, of course
15:40:55 <dmwit> okay
15:41:32 <dmwit> Peaker_: The precise description is that the 's' in 'ST s' is an existential type variable. =)
15:42:26 <Saizan> i don't really buy that last line
15:43:09 <c_wraith> I don't either.  it's just a type variable, until you get to runST
15:43:37 <c_wraith> It's indistinguishable from other type variables in the contexts of ST s operations
15:43:38 <Saizan> and even in the type of runST i don't see an existential quantification
15:43:55 <dmwit> runST has a rank-2 type
15:43:58 <sipa> :t runST
15:43:59 <lambdabot> forall a. (forall s. ST s a) -> a
15:44:12 <dmwit> ...which is enough to encode existentials, right? (actually not 100% sure of this)
15:44:33 <sipa> it requires its first argument to allow any type s
15:44:34 <applicative> if it were existential, the s wouldn't appear in the type ST s a
15:44:34 <t7> and you need a 226 bit integer to represent every possible combination of playing cards
15:44:38 <Saizan> some, yes, but not all rank-2 types need to be encodings of existentials
15:45:44 <dmwit> Okay, I concede.
15:45:47 <mm_freak> dmwit: you can express existentials using higher rank universal quantification and CPS
15:45:54 <Peaker_> dmwit, I conceded first :)
15:47:17 <JoeyA> Is there a more generic version of 'atomically' floating around?  Namely, something with this signature:
15:47:27 <mm_freak> universal :: (forall a. (a -> a) -> a -> b) -> b
15:47:35 <JoeyA> class MonadAtomically io stm | io -> stm where atomically :: stm a -> io a
15:47:40 <mm_freak> existential :: exists a. (a, a -> a)
15:47:49 <mm_freak> there is pratically little difference between the two
15:48:01 <MostAwesomeDude> JoeyA: Why?
15:48:23 <JoeyA> MostAwesomeDude: I want to be able to use 'atomically' without throwing out my ReaderT.
15:48:34 <mm_freak> JoeyA: you can replace the IO by MonadIO m => m
15:48:38 <mm_freak> liftIO . atomically
15:48:49 <Peaker_> @type liftIO . atomically
15:48:50 <lambdabot> Not in scope: `atomically'
15:49:04 <Peaker_> MonadIO m => STM a -> m a
15:49:10 <JoeyA> mm_freak: There's another wrinkle: in my case, I want my worker threads to always check a status variable before doing anything in the STM world.
15:49:26 <Peaker_> mm_freak, I think he wants:    ReaderT r STM a -> ReaderT r IO a
15:49:47 <JoeyA> So liftIO $ atomically $ anything isn't quite the solution I want.
15:50:42 <dmwit> :t ReaderT . fmap atomically . runReaderT
15:50:43 <lambdabot> Not in scope: `atomically'
15:50:51 <dmwit> :t ReaderT . fmap Control.Monad.STM.atomically . runReaderT
15:50:52 <lambdabot> Couldn't find qualified module.
15:50:57 <dmwit> that was a long shot =P
15:50:58 <Peaker_> mapReaderT . atomically
15:51:00 <JoeyA> Though I suppose checking the status variable could be done with a wrapper that calls the generic 'atomically', so I'm not overloading the semantics of atomically so much.
15:51:10 <dmwit> Anyway, I don't know of any existing typeclass like that.
15:51:37 <JoeyA> Also, I'm using newtypes, rather than raw ReaderT.
15:51:38 <dmwit> Peaker_: Nice, I didn't know about mapReaderT.
15:51:39 <dmwit> I like it.
15:51:46 <Peaker_>  :t mapReaderT atomically  ==>  ReaderT r STM b -> ReaderT r IO b
15:52:18 <dmwit> But yes, this is an implementation of the instance, not a pointer to where the class exists. =)
15:52:19 <MostAwesomeDude> :t mapReaderT
15:52:20 <lambdabot> forall (m :: * -> *) a (n :: * -> *) b r. (m a -> n b) -> ReaderT r m a -> ReaderT r n b
15:52:36 <mm_freak> hmm
15:52:41 <Peaker_> dmwit, I use transformers without mtl, so the lifters are often too weak.. So if I have ReaderT r (WriterT w m) ...   and I want to "listen" or such, I have to use mapReaderT to lift the "listen", since "lift" is only for the simply covariant actions
15:52:44 <mm_freak> i usually use this concept:  join . atomically
15:52:55 <mm_freak> sometimes:  join . liftIO . atomically
15:53:42 <dmwit> Neither of those seem helpful if he's going to be reading an STM variable from the environment.
15:54:18 <mm_freak> get those before you enter STM
15:54:34 <JoeyA> That pretty much defeats the purpose of ReaderT...
15:54:37 <dmwit> exactly
15:54:41 <Peaker_> mm_freak, but then he needs to manually pass around the env in the STM computation, or run another readerT around it
15:55:05 <Peaker_> JoeyA, do you need the generality or just the convenience?
15:55:23 <mm_freak> in my case the variables are usually in scope anyway
15:55:23 <Peaker_> because I think mapReaderT atomically is pretty convenient (though may restrict the type you might want)
15:55:55 <JoeyA> Peaker_: I considered that, but I'm using newtypes rather than direct ReaderT.
15:56:05 <JoeyA> (though I could use it for the implementation of my atomically, I suppose)
15:56:48 <mm_freak> i guess a wrapper around atomically is really what you want
15:56:51 <Peaker_> JoeyA, if your newtype gets the edwardk lenses or SECs, you can do something like:  (inMyNewType . mapReaderT) atomically
15:56:57 <mm_freak> btw, i always found the name "atomically" too long
15:57:05 <Peaker_> (where inMyNewType lifts a function into the newtype)
15:57:37 <Peaker_> I think maybe generalizing "mapReaderT" makes more sense than generalizing "atomically"
15:58:12 <Peaker_> generalizing "mapReaderT" is a lot like the "lift" generalization, except you have an action on the contravariant side too
15:58:38 <MostAwesomeDude> Well, IIRC, atomically :: STM a -> IO a -- is as general as you can get while still being useful, isn't it?
15:59:11 <dmwit> MostAwesomeDude: We've just seen an example of a place where the answer is no...
15:59:34 <JoeyA> Someone mentioned a higher-kinded version of Functor on Reddit a while back
15:59:42 <mm_freak> MostAwesomeDude: in a sense, yes
15:59:44 <JoeyA> For generalizing things like mapReaderT
15:59:45 <Peaker_> I wonder if this works usefully for any transformer besides ReaderT:  class BiMonadTrans t where bilift :: (m a -> n b) -> t m a -> t n b
15:59:47 <MostAwesomeDude> dmwit: Well, if you generalize it further, you still have to come back to this type in order to actually run the STM action, right?
15:59:55 <dmwit> Sure.
15:59:59 <mm_freak> MostAwesomeDude: anything else will be based on that one
16:00:07 <dmwit> But so what?
16:00:36 <MostAwesomeDude> I dunno. I'm just trying to understand the problem.
16:00:41 <JoeyA> Peaker_: If you make it (forall a. m a -> n a) -> t m a -> t n a, you (might) be able to use it with ContT.
16:00:58 <Peaker_> JoeyA, I'm wondering about StateT at the moment :)
16:01:24 <dmwit> I don't think you can do it with StateT, since StateT returns its new state in the old monad.
16:01:41 <dmwit> Likewise WriterT.
16:02:05 <JoeyA> atomically returns its new value in the old monad, no?
16:02:23 <dmwit> JoeyA: I said nothing about the value.
16:02:28 <dmwit> Only about the monadic side-effects.
16:02:28 <Peaker_> yeah, you have to take a polymorphic function
16:02:33 <dmwit> ReaderT has no monadic side-effects.
16:03:23 <dmwit> ?djinn (m a -> n b) -> (s -> m (a, s)) -> (s -> n (b, s))
16:03:24 <lambdabot> -- f cannot be realized.
16:03:28 <dmwit> done =)
16:03:39 * hackagebot AspectAG 0.3.6 - Attribute Grammars in the form of an EDSL (MarcosViera)
16:04:28 <dmwit> I guess that's not quite fair, since you might object that you can assume m and n are Monad instances.
16:04:59 <dmwit> Does djinn do classes?
16:05:00 <MostAwesomeDude> Does djinn do Monads?
16:05:01 <Peaker_> Yeah:   (forall a. m a -> n a) -> ((a -> m r) -> m r) -> (a -> n r) -> n r  <-- not possible either
16:05:04 <dmwit> ?djinn Monad m => a -> m a
16:05:05 <lambdabot> f = return
16:05:13 <Saizan> dmwit: it doesn't do Monad properly
16:05:25 <dmwit> ?djinn (Monad m, Monad n) => (m a -> n b) -> (s -> m (a, s)) -> (s -> n (b, s))
16:05:26 <lambdabot> -- f cannot be realized.
16:05:34 <dmwit> Saizan: I figured. Seems like bordering on rank-2 types.
16:06:06 <Saizan> right, the dictionary for Monad has polymorphic components
16:06:10 <Peaker_> Type-classes have polymorphic components, which I think are a special-case of rank2
16:06:27 <Saizan> but e.g. Monoid is fine
16:06:55 <dmwit> Well, I don't think (Monoid (m a), Monoid (n b)) => ... would be a convincing "cannot be realized". =P
16:07:19 <hpaste> “Joey Adams” pasted “Generalized-ish mapReaderT using rank-2 type” at http://hpaste.org/72456
16:07:21 <dmwit> Still, it "feels" like the Monad functions don't help you much with this.
16:07:59 <dmwit> Can we get a better name than Bilift, especially now that it's not even lifting along two type variables?
16:08:11 <JoeyA> Perhaps.
16:08:29 <JoeyA> In any case, this wouldn't help me anyway, since my monads aren't transformers (though I suppose they could be...)
16:08:39 * hackagebot murder 1.3 - MUtually Recursive Definitions Explicitly Represented (MarcosViera)
16:08:48 <dmwit> I don't see how that's relevant.
16:09:00 <gurrag> is "99 Haskell Problems" up to date with the current version of the language?
16:09:01 <JoeyA> Well, if I have newtype Worker a where ...
16:09:05 <dmwit> Presumably if they're not transformers, you're providing some primitives.
16:09:05 <JoeyA> and newtype WorkerSTM a where ...
16:09:14 <Saizan> HFunctor, as in higher-kinded functor has been used for that class
16:09:19 <dmwit> So provide one that's MyNewtypeConstructor . mapReaderT or whatever.
16:09:50 <Peaker_> treat mapReaderT as a SEC and compose it with a newtype-penetrating SEC
16:09:58 <dmwit> exactly
16:10:17 <sipa> sec?
16:10:32 <dmwit> Or, in slightly less FP-specific terms, use a conjugation with the isomorphism provided by the newtype constructors. =)
16:10:46 <dmwit> Const . f . unConst
16:10:48 <JoeyA> sorry, I gotta go
16:10:53 <JoeyA> Thanks for humoring me
16:10:54 <Saizan> JoeyA: btw, http://hackage.haskell.org/packages/archive/monadLib/3.6.2/doc/html/MonadLib.html#t:BaseM
16:11:05 <JoeyA> transformers-base
16:11:29 <JoeyA> But that library looks interesting nonetheless
16:13:39 <Peaker_> Why did Haskell standardize on "data" declarations, rather than structural records and anonymous sum types?
16:14:01 <Peaker_> (with only "type" synonyms and "newtype"s for unlifted wrappers/recursive-types?)
16:14:22 <Peaker_> It'd be really nice to stick {} and | just anywhere in types
16:14:38 <sully> pattern matching is much nicer with named branches
16:14:54 <Philippa> the well-understood tech was utterly inappropriate for that at the time
16:15:12 <sully> mostly I think it just makes type inference much easier
16:15:21 <sully> because you have constructors and you know the types of them
16:16:20 <Peaker_> sully, maybe | could define the data constructors, like "data" does, such that all the |'s define the same data constructor and can overlap names as long as they don't conflict (use the same or compatible fields)
16:17:18 <Peaker_> to avoid repeating fields you could always give explicit names to data constructors via a type synonym
16:18:06 <Peaker_> one option (a bit cumbersome): type CaseA = ... ; type CaseB = ... ; type SumType = CaseA CaseA | CaseB CaseB
16:18:16 <mm_freak> type (:*) = (,)
16:18:22 <jfischoff> @src concat
16:18:23 <lambdabot> concat = foldr (++) []
16:18:28 <mm_freak> type (:+) = Either
16:18:51 <mm_freak> what's the big difference between this and anonymous sums?
16:18:55 <Peaker_> mm_freak, it would be nice to have named/unordered access
16:19:19 <mm_freak> i see
16:19:35 <Peaker_> mm_freak, also:    case myType of { A x y -> ... ; B c -> .. ; other -> ... other now has less constructors in it, no A and B ... }
16:20:35 <Peaker_> I guess that works with the (:+) approach, if the ordering matches what you want
16:20:43 <Peaker_> but it's going to have very clunky syntax
16:21:18 <Saizan> foo (List (x:xs)) = .. -- that's annoyingly unpretty
16:22:30 <Peaker_> Saizan, There's probably a way to make it work out, I'm guessing
16:23:06 <Saizan> a way is to make it infer the "List" from a type signature
16:24:51 <edwardk> preflex: xseen danharaj
16:24:51 <preflex>  danharaj was last seen on freenode/#haskell 1 hour, 32 minutes and 11 seconds ago, saying: the*
16:26:50 <Peaker_> GADTs probably pull back towards hard-wired sums rather than free anonymous summing
16:29:25 <mm_freak> what implication would anonymous sums have for provability/type checking?  as far as i know ocaml has them
16:31:37 <Saizan> not really, it's just fancier types for the fields
16:34:05 <applicative> hm what do you think this means? (building ghc-head)  "ghc-stage2: internal error: Invalid Mach-O file:Address out of bounds while relocating object file" It was linking the ghc pkg I think
16:34:27 <Peaker_> Saizan, but the fields types relate to the sum's type, so it is possible if there is some special annotation relating them.. maybe:  type MyGADT a b = Cons1 (a~Int) (b~Char) .. fields .. ?
16:36:54 <Saizan> yep
16:36:55 <Peaker_> Hmm.. I have a lot of code that runs in some monad that does not support IORefs/STRefs, and now I want to add explicit caching of stuff, so I thought about wrapping the monad with a StateT of a cache. The problem is the cache type would have to be something like:  Map Guid ???   where ??? would need to be a different type for different components of the computation
16:40:53 <Peaker_> Using Dynamic/cast would suck (it would be a first time for me)
16:41:47 <Saizan> you could unsafeCoerce directly :)
16:42:57 <mm_freak> Peaker_: what about memoization?
16:45:08 <mm_freak> or should it really be an explicit cache?
17:03:41 * hackagebot zigbee-znet25 0.1.1.0 - XBee ZNet 2.5 (ZigBee) wireless modem communications (DavidJoyner)
17:03:43 * hackagebot timerep 1.0.3 - Parse and display time according to some RFCs (RFC3339, RFC2822) (HugoGomes)
17:26:32 <dmwit> preflex: seen jmcarthur
17:26:33 <preflex>  jmcarthur was last seen on #haskell 3 days, 4 hours, 2 minutes and 19 seconds ago, saying: i do think Environment makes more sense than Reader
17:28:41 <dmwit> ?ask jmcarthur re: your comment on <http://twanvl.nl/blog/haskell/categories-over-pairs-of-types>; do you think the "associated constraint" trick would solve this problem? something like "class Category cat where type family Constraint cat :: Constraint; id :: Constraint cat a => cat a a; (Constraint cat a, Constraint cat b, Constraint cat c) => (.) :: cat b c -> cat a b -> cat ac"
17:28:41 <lambdabot> Consider it noted.
17:42:55 <hpaste> xwnh pasted “io noob” at http://hpaste.org/72461
17:43:31 <XWNH> I've only just been introduced to IO, and I can't understand why there needs to be a second "do" there
17:44:06 <ddarius> What do you think do does?
17:44:07 <dmwit> It's just syntax.
17:44:31 <dmwit> There could be a rule for if/then/else in do-blocks that eliminated that need, but there isn't.
17:45:03 <dmwit> (And I'm glad there isn't: there would be a whole new brand of confusing questions if "then" and "else" sometimes introduced blocks.)
17:45:28 <mapreduce> Could one write an if/then/else equivalent typed so that the nested do wasn't needed?
17:45:37 <dmwit> No, it's a syntax thing.
17:45:41 <dmwit> Typing doesn't come into it.
17:45:46 <mm_freak> if you remove the 'do' there, i'd expect a type error
17:45:57 <mm_freak> 'putStrLn line echo' is certainly a type error
17:46:05 <dmwit> mm_freak: Presumably he also de-indented the "echo" so it was in the previous "do".
17:46:14 <mm_freak> yeah, that could be
17:47:12 <mapreduce> XWNH: Did you see hpaste's auto-generated comment about using unless?  The little pink thing under your code.
17:47:26 <mapreduce> That's a nice feature for a pastebin!
17:49:16 <latro`a> if you want that offline, cabal install hlint
17:54:21 <XWNH> ah, right, got it.
17:54:33 <XWNH> mapreduce: yeah
17:55:35 <XWNH> dmwit: yeah, "echo" wasn't indented properly before
17:55:39 <XWNH> dmwit: *she
17:55:45 <XWNH> thanks for the sexist assumption
17:56:06 <dmwit> "He" is one de-facto gender neutral pronoun in English.
17:56:39 <XWNH> using "he" as a synonym for person isn't sexist?
17:57:01 <XWNH> de-facto doesn't enter into whether or not it's a shit thing to say
17:57:56 <latro`a> um
17:58:04 <dmwit> I don't see that using a gender-neutral pronoun announces to the world that one sex is inherently superior to another, no.
17:58:05 <latro`a> de facto is *everything* in natural languages
17:58:06 <mapreduce> "Refers to a person whose gender is unknown." from wikipedia.  I hope you never learn Spanish. :)
17:58:07 <latro`a> there is nothing else
17:58:31 <mapreduce> wiktionary, sorry.
17:59:23 <Rung> got a mutable type question stemming from Haskell:The Craft of Functional Programming, Pg 85 -- The author claims that you can update a simple database (a list of tuples in this case) using this simple function: makeLoan :: Database -> Person -> Book -> Database ; makeLoan dbase pers bk = [(pers,bk)] ++ dbase. Of course this doesn't work. So how do I update a list without mutable state?
17:59:41 <dmwit> And, as a matter of fact, I did assume you were male. Nevertheless, I don't see how that makes me sexist.
17:59:46 <jmcarthur> dmwit: hmm
17:59:47 <lambdabot> jmcarthur: You have 1 new message. '/msg lambdabot @messages' to read it.
18:00:02 <nand`> I'd be willing to bet that the majority of this channel is male. Assuming male by default is simply minimizing the average error
18:00:11 <jmcarthur> i'm not sure. it seems unsatisfying...
18:00:17 <dmwit> Rung: Can you say what about it doesn't work?
18:00:53 <Rung> lol, I always use the pronoun 'she' in didactic writing, its the academic standard nowadays -- something i learned from journalism school
18:01:03 <Rung> nobody objects to the 'she' pronoun
18:01:09 <MostAwesomeDude> Rung: Mallory.
18:01:41 <Rung> ?
18:01:42 <MostAwesomeDude> People get *so* mad over that.
18:02:00 <nand`> And Eve, the eavesdropper?
18:02:01 <MostAwesomeDude> In cryptography, Mallory is the traditional name for a malicious active attacker.
18:02:08 <MostAwesomeDude> Mallory is also traditionally male.
18:02:12 <Rung> huh
18:02:23 <MostAwesomeDude> And yeah, Eve, the eavesdropper, is female.
18:02:25 <Rung> well, its good to attribute bad qualities to a male
18:02:26 <Rung> lol
18:02:34 <Rung> for writing purposes at least
18:02:38 <dmwit> Now *that* is sexism.
18:02:50 <Rung> i agree, but we don't live in a perfect world
18:03:01 <Rung> pragmatism
18:03:11 <nand`> dmwit: not necessarily; he never said that it's not good to attribute bad qualities to females
18:03:17 * ddarius goes to read the writings of a drug-addled psychotic.
18:03:19 <dmwit> ah, that's true
18:03:21 <Rung> what we need is a pronoun like "nosotros"
18:03:28 <Rung> i mean "ustedes"
18:03:30 <Rung> oops
18:03:35 <jmcarthur> can we take this conversation to #haskell-blah, please?
18:03:36 <mapreduce> hah, I was about to say
18:03:45 <dmwit> jmcarthur: Yes, thanks for the suggestion.
18:04:14 <Rung> but ya, i have a mutable state question above for anyone who cares to look at it
18:04:20 <jmcarthur> thanks
18:04:24 <dmwit> Rung: Did you see my response?
18:04:30 <mapreduce> Rung: Someone asked you what error you see etc.
18:04:50 <Cale> Rung: That's an immutable update
18:05:13 <Cale> Rung: you're not meant to continue using the database you passed as input, you're supposed to use the one which is the result for future computation.
18:05:16 <Rung> well no error per the compiler, i just know that it wont work
18:05:26 <Rung> right
18:05:34 <Cale> Won't work in what way? :)
18:05:48 <dmwit> That's what I said. =)
18:05:56 <Rung> well, the ++ operator will output an updated list without affecting the dbase
18:06:11 <dmwit> Yup.
18:06:14 <Cale> Yes, that's the point of immutability
18:06:24 <Cale> (this is a good thing)
18:06:30 <dmwit> We're with you so far, but now we want to hear about the "what won't work" part. ;-)
18:06:30 <mapreduce> The original dbase is no longer in fashion.  Use the new one from now on.
18:07:23 <Rung> yup, so i'm a newb and i just need a simple to name a new dbase with the output of the concatenation. Like let newdb = updateFunction -- will not work
18:07:36 <Rung> it will just cycle forever causing a crash
18:07:42 <Rung> add parens, same thing
18:07:42 <dmwit> Wait, what?
18:07:52 <dmwit> Maybe you'd better post some code that didn't work.
18:07:56 <Rung> ok
18:08:17 <Cale> Rung: maybe you tried x = update x ?
18:08:26 <Cale> Rung: both x's will refer to the same thing in that case
18:08:40 <dmwit> Remember the tried-and-true formula: "I tried X, expecting Y to happen, but Z happened instead.".
18:08:51 <Cale> and you'll get an infinite loop of sorts -- in this case it'd work, but produce an infinite list
18:08:51 <jmcarthur> > let x = f x in x
18:08:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:08:53 <lambdabot>    `GHC.Show.Show a'
18:08:53 <lambdabot>      a...
18:09:09 <jmcarthur> > let x = f x in x :: Expr -- not sure if this works
18:09:10 <Cale> > let x = ("hello", "there") : x in x
18:09:11 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
18:09:11 <lambdabot>   [("hello","there"),("hello","there"),("hello","there"),("hello","there"),("...
18:09:15 <jmcarthur> it works!
18:09:35 <dmwit> > let x = x + 1 in x :: Int -- but this loops, and perhaps is something like what Rung was complaining about, maybe, perhaps
18:09:39 <lambdabot>   mueval-core: Time limit exceeded
18:11:01 <Cale> Rung: btw, if you really do want to know how to manage mutable state, say in the IO monad with IORefs, then that's easy enough, but you should also learn how to program immutably
18:12:07 <Rung> ok its in hpaste
18:13:20 <Rung> Im fine with making new dbase, my syntax is probably just wrong
18:18:47 <Rung> http://hpaste.org/72462
18:19:10 <dmwit> Rung: just s/let//
18:19:42 <dmwit> wait
18:19:52 <dmwit> No, I still don't think this code is complete. =)
18:19:57 <dmwit> What's dbaseOld?
18:20:10 <hpaste> applicative annotated “new database” with “new database (annotation)” at http://hpaste.org/72462#a72463
18:20:18 <Rung> dmwit: libraryBase is dbase old
18:20:48 <applicative> Rung it was a let at the top level that confused the parser
18:21:12 <dmwit> Rung: Well, I can't reproduce your problem.
18:21:35 <dmwit> I put all your code in a file, then typed your "let newdb = ..." line in ghci, but using "libraryBase" instead of "dbaseOld", and it didn't infinitely loop.
18:21:39 <applicative> newdb dbaseOld = (makeLoan dbaseOld "me" "LYAH") is the natural definition
18:22:16 <Rung> ok, thx ill try it
18:25:49 <Rung> but the thing is that i need a way to update my db everytime a person loans-out a book
18:26:17 <Rung> the mentioned method requires I redefine newdb for every new person/book checked out
18:26:27 <dmwit> Yes, that's the general strategy.
18:26:58 <applicative> why is this bad.  You apply the function every time someone takes out a book.  But there are other ways of going about this.
18:27:17 <Rung> so to 'modularize' the update function properly, I would need another function which recreates a newdb function every time?
18:27:44 <dmwit> I'm not sure I understood that question yet.
18:28:15 <applicative> > foldr (.) id (replicate 2000 (+1)) 2
18:28:16 <lambdabot>   2002
18:28:24 <applicative> > foldr (.) id (replicate 200000 (+1)) 2
18:28:27 <lambdabot>   200002
18:28:57 <applicative> ^^^ even lambadot can apply a function 20000 times in an instant
18:29:13 <applicative> > foldr (.) id (replicate 2000000 (+1)) 2
18:29:16 <lambdabot>   *Exception: stack overflow
18:29:19 <applicative> hahaha
18:30:21 <latro`a> > foldl' (.) id (replicate 200000 (+1)) 2
18:30:25 <lambdabot>   mueval-core: Time limit exceeded
18:30:30 <dmwit> > foldr (\f g x -> f $! g x) id (replicate 200000 (+1)) 2
18:30:32 <lambdabot>   200002
18:30:38 <dmwit> > foldr (\f g x -> f $! g x) id (replicate 2000000 (+1)) 2
18:30:40 <lambdabot>   *Exception: stack overflow
18:30:47 <dmwit> huh
18:31:05 <dmwit> Oh, there's two stacks.
18:32:15 <Rung> think of it this way, a librarian scans a book for checkout, the program then takes the book and persons name as an input. This is the input of the 'update' function. Then the update function must go and automatically redefine the new database function itself for each new person and book. In other words, this application update is not complete. It requires an over-arching function which redefines newdb for each new tuple that come
18:32:15 <Rung> s along
18:32:50 <dmwit> The database is not a function.
18:32:57 <Rung> newdb is
18:33:09 <dmwit> applicative's newdb is; mine isn't.
18:33:15 <applicative> update has type Database -> Database,  that's a good function
18:33:37 <applicative> Rung: you could represent it as a state transformer
18:33:57 <applicative> Rung: but in Haskell that is just another function like newdb
18:34:19 <Rung> lol, well regular expressions, ioref, these are not in the first 85 pags of Haskel:TCoFP
18:34:33 <Rung> so, thats not gonna work for me right now
18:34:49 <dmwit> You can really do a lot without IORef. You should at least give it a chance.
18:35:13 <applicative> why does he need IORef, because hes updating the db?
18:35:20 <Rung> give learning regular expressions a chance at page 85? isnt that a major side-step?
18:35:51 <dmwit> Are you complaining that regexen come too late or too early?
18:35:55 * applicative wonders  Why would they discuss regular expressions at all
18:36:01 * dmwit too
18:36:21 <nand`> why bother with regexps when you can encode regular languages directly in Haskell?
18:36:57 <dmwit> Why bother with regexps when you have real parsing languages for the String-y parts and real data-types for the actual programming part?
18:37:17 <edwardk> dmwit++
18:37:22 <Rung> nevermind, you guys are way beyond my skill level. I'm an undergrad total newb. sometimes when you are so far along in your education, you forget what it was like learning something from scratch
18:37:26 <Rung> thx anyways
18:37:29 <nand`> ‘real parsing languages’ <- like regular languages? :)
18:38:11 <applicative> Rung, but you should continue with this approach.  A more complicated approach with a State monad would still be 'pure'  but would feel more appropriate to you
18:38:12 <dmwit> Regular expressions are one DSL for parsing, yes. But they are sort of a crappy one.
18:38:50 <dmwit> Rung: Ask an objective question, and we'll give you an objective answer. If you don't understand the answer, ask an objective question that points out which parts you don't understand.
18:39:04 <dmwit> I guarantee people will help you.
18:39:05 * applicative uses Data.List and sometimes Data.List.Split for simple regexlike operations
18:39:07 <nand`> dmwit: well, if you need to parse regular languages I don't see much point in using a tool more complex than it needs to be
18:39:38 <nand`> (I'll just go ahead and assume nobody is trying to use regexes to parse non-regular languages, like HTML)
18:39:43 <dmwit> We don't yet know what he wants to use regular expressions for; however, I've observed that most of the places I would use a regex in other languages are better served by other patterns in Haskell.
18:40:07 <tgeeky> plus, there's always applicative-regex
18:40:11 <Rung> I know you guys will help. you always do. #Haskell rox. But, the answers you present involve predicate knowledge that a person at my level would not have
18:40:23 <dmwit> Rung: So ask about the predicate.
18:40:28 <dmwit> We can't know what you know until you tell us.
18:40:58 <nand`> dmwit: in that respect I agree - regular languages are often imagined where they don't actually exist, or where they're a crude subset of the actual language one wants to parse. I was not relating my argument to Rung's questions (mainly since I wasn't tracking the conversation and thus don't know what Rung was asking)
18:42:36 <Rung> simple: am i right in assuming that in order to create a function that takes a name and an input and outputs an updated database, i would (using applicative's hpaste function- newdb) also need to create another function to redefine the newdb function itself for every new name and book
18:43:10 <dmwit> No, I don't think that's necessary.
18:43:13 <Rung> the answer needs to be composed using simple list and function making primitives
18:43:17 <gwern> anyone here conversant with shannon's theorem? I'm not sure I'm calculating it right
18:43:28 <Rung> becuz that is what a newb like me know
18:43:37 <dmwit> Rung: In particular, your function "makeLoan" *already* does what you're asking for.
18:44:10 <dmwit> It takes as input a database, a name (of a person), and a name (of a book) and returns a new database.
18:44:29 <Rung> no it doesn't, the output is not easily bindable to a new database without employing applicatives newdb function
18:44:35 <dmwit> what
18:44:44 * gwern asks anyway
18:44:50 <Rung> remember what i said earlier about the infinite loop?
18:44:52 <gwern> I have a channel which delivers 10,000 bits; each bit has an 80% chance of being correct. so after pondering the Wikipedia article https://en.wikipedia.org/wiki/Shannon%27s_theorem , I calculated the possible rate thus: let h p = p * logBase 2 p + (1 - p)*(logBase 2 (1 - p)); 10000 / (1 - h 0.2) = 5807.443429078923
18:44:59 <dmwit> Rung: Yes, but you never demonstrated an infinite loop to us.
18:45:00 <hpaste> applicative annotated “new database” with “new database (annotation) (annotation)” at http://hpaste.org/72462#a72464
18:45:25 <Rung> sure i did: let newdb = (makeLoan dbaseOld "me" "LYAH")
18:45:36 <Rung> applicative's newdb was a response to this
18:45:37 <applicative> ^^^ the 'loan' function here is a state transformer.
18:45:41 <dmwit> Rung: That does not compile here: "dbaseOld is not in scope".
18:45:57 <dmwit> Rung: If you change "dbaseOld" to "libraryBase", then that does compile and does not infinitely loop.
18:46:07 <dmwit> Rung: So tell us how to make an infinite loop.
18:46:31 <dmwit> applicative: I think that direction of instruction is going to be more frustrating than helpful at this point. I'm not 100% sure of that, though.
18:46:34 <Rung> right, which is applicative's solution
18:46:55 <Rung> however, his solution only works with one book and person
18:47:17 <dmwit> Rung: Write some code that doesn't do what you want. Show it to us and tell us what it is about the code that doesn't do what you want.
18:47:22 <Rung> to reuse this function every time a new book comes across the desk, you must redefine it to use a new name and book
18:47:30 <dmwit> We can't keep playing this guessing game where you say "this infinite loops", but "this" doesn't infinite loop.
18:47:33 <applicative> dmwit: yes, that's what I was thinking but I wanted to show we could do things differently , or seemingly differently
18:47:38 <dmwit> Or "this doesn't do X", but "this" doesn't compile.
18:47:39 <dmwit> Or whatever.
18:47:58 <nand`> I'm looking at the hpaste; applicative's ‘newdb’ is essentially just makeLoan with some of the arguments re-ordered
18:48:06 <dmwit> yes
18:48:23 <applicative> Rung, if you call it 'this function' you concede it doesnt needto be redefined. It is used with new arguments, not a new definition
18:48:33 <nand`> (and furthermore is the result of having the parameters in the wrong order in the first place)
18:49:07 <applicative> nand`: yes, we were getting it to typecheck.
18:49:24 * dmwit jokes: actually, Rung is telling us (on the meta-level) how to create an infinite loop: repeatedly claim there is an infinite loop and then don't answer questions about it
18:49:24 <applicative> nand`: makeLoan was already the answer
18:49:30 * nand` would write makeLoan as (:) personally
18:49:33 <nand`> applicative: I see
18:50:21 <Rung> makeLoan is from the book, it produces a database that needs to be bound to a new database typed object
18:50:43 <Rung> all i need to do is just bind it to a new database object
18:50:44 <nand`> ‘bound’? ‘object’?
18:50:47 <Rung> thats it
18:50:49 <applicative> nand`: my thought was that he was wanting something more like a state operation when he felt makeLoan was inadequate so I wrote mone of them too
18:51:24 <dmwit> newdb = makeLoan libraryBase "me" "LYAH" -- done, next!
18:51:56 <Rung> nevermind. thanks for the effort anyways folks. I yeild the floor.
18:51:57 <gwern> hm, maybe I'd better look for a computer science channel to ask my question
18:52:36 * gwern doesn't find very active #CS or #cs or #computerscience. drat.
18:52:41 <Clint> "\&7" == "7"?
18:52:46 <danil`> gwern: (also via wikipedia, so don't take this as independent) that seems to check out
18:52:48 <applicative> oh we've scared of Rung
18:52:52 <nand`> gwern: ##math maybe?
18:52:55 <applicative> off rather
18:52:55 <nand`> sounds mathy to me
18:53:04 <gwern> nand`: worth a try, I suppose
18:54:02 <dmwit> > "\&7"
18:54:03 <lambdabot>   "7"
18:54:18 <dmwit> Clint: \& is for separating \234 from a following actual-digit character
18:54:24 <Clint> ohh
18:54:24 <Clint> thanks
18:54:25 <dmwit> > "\1234\&5"
18:54:28 <lambdabot>   "\1234\&5"
18:54:32 <dmwit> > "\12345"
18:54:34 <lambdabot>   "\12345"
18:55:01 <dmwit> Probably superfluous, given that we have string gaps.
18:55:08 <dmwit> > "\1234\ \5"
18:55:10 <lambdabot>   "\1234\&5"
18:55:27 <Cale> heh, that is actually pretty cute
18:56:19 <Cale> btw, \& is also needed to distinguish between "\SOH" and "\SO\&H"
18:56:36 <dmwit> wow
18:56:40 <dmwit> cool =)
18:57:45 <dmwit> > map return "\1234\&5" -- maybe a better way to show off what it means, since the Show instance sticks the \& back in
18:57:46 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
18:57:47 <lambdabot>    arising from a use of...
18:57:56 <dmwit> > map (:[]) "\1234\&5" -- maybe a better way to show off what it means, since the Show instance sticks the \& back in
18:57:57 <lambdabot>   ["\1234","5"]
18:59:38 <nand`> > length "\1234\&\5"
18:59:39 <lambdabot>   2
18:59:51 <nand`> s/\\5/5/
19:04:19 * dmwit sighs
19:04:42 <dmwit> The QR folks spent all that time making QR codes robust, and then everybody abuses it to make them merely pretty instead.
19:05:36 <Boney> isn't that what happens to a lot of computing/engineering technology.
19:05:37 <danil`> some of the ways of making it pretty don't make them less robust
19:05:49 <monochrom> that happened to HTML and CSS too
19:05:58 <Boney> someone invents a photocopier to make people's lives easier, other people photocopy their bottoms.
19:06:14 <Boney> (not pretty in this case).
19:06:16 <monochrom> soon, we will also see pretty Haskell code!
19:06:29 <Boney> monochrom: haskell code is already pretty (some of it)
19:06:32 <Jafet> Heaven forbid
19:06:41 <monochrom> not in the "ascii art" sense
19:07:12 <Boney> You can render images into ascii art so that at a distance it looks like an image.
19:07:30 <Boney> I wonder if you can render it into ascii art that say,  is perl code that computes itself :-)
19:07:38 <Jafet> Does that mean haskell code will soon be robust?
19:07:54 <Jafet> http://www.ioccc.org/2000/dhyang.c
19:08:01 <monochrom> yes, imagine haskell code that is at the same time ascii art
19:10:45 <colock> nice Jafet :P
19:11:53 <dmwit> I see, some QR codes are made pretty by including unused data.
19:11:56 <dmwit> That's fine, I guess.
19:18:42 <MostAwesomeDude> Hey, if I made a game using SDL and Haskell, how easy would it be to deploy on Win32?
19:19:35 <ReinH> Would anyone like to speculate on chess board representations? I see a lot of Map-based representations, a few bitboards, and a few naive list-of-lists implementations
19:20:09 <edwardk> ReinH: depends on your goals. its hard to beat a nice bitboard for performance
19:20:13 <edwardk> its easy to work with maps, etc.
19:20:21 <ReinH> I'm guessing that 0x88 would not be as efficient without being able to mutate it
19:21:12 <MostAwesomeDude> I'm just asking for a ballpark yes/no; I understand that Win32 is always a PITA.
19:21:17 <Jafet> 0x88 is pretty old
19:21:30 <Jafet> But there's no reason you can't implement it
19:21:33 <edwardk> 0x88 would be doable using a mutable array or some such
19:22:48 <ReinH> edwardk: perhaps
19:22:59 <ReinH> Jafet: what's the current state of the art?
19:23:10 <Jafet> Dude: my answer is only _|_
19:23:23 <MostAwesomeDude> Jafet: Sounds reasonable.
19:23:49 * hackagebot integration 0.1.1 - Fast robust numeric integration via tanh-sinh quadrature (EdwardKmett)
19:24:12 <Jafet> I wouldn't know, but it's more likely to be bitboards than 0x88.
19:24:32 <edwardk> added changes of variables to permit integration from 0 to infinity and from -infinity to infinity without manual clipping
19:25:07 <edwardk> someone contacted me who was doing that and i wanted to discourage the practice ;)
19:25:14 <ReinH> Rybka uses a bitboard afaik
19:25:44 <edwardk> then prepare for dominating the chess community by duplicating the approach ;)
19:26:11 <ReinH> indeed :)
19:26:27 <Jafet> The state' of the art
19:26:37 <ReinH> this isn't really about writing a great engine, it's about writing one that's useful as a learning tool
19:27:19 <edwardk> i don't write chess engines for the same reason i don't really play chess any more. i can't get any better at it without throwing my entire life at it and i don't like it enough to do that ;)
19:27:26 <ReinH> :)
19:27:42 <Jafet> I wrote a chess player once. It beat me so I left it at that
19:27:46 <MostAwesomeDude> Is HVFS from MissingH the correct VFS to use in new code?
19:27:52 <ReinH> lots of stuff here though http://chessprogramming.wikispaces.com/Board+Representation
19:27:55 <ReinH> wewt
19:29:18 <Jafet> There should be chess competitions where each program is limited to a few million cycles
19:30:36 <ReinH> There appears to be a rabbit hole here. Descend? [Y/n]
19:31:42 <edwardk> i think i clicked the 'always' button on that suggestion once.
19:31:54 <edwardk> haven't been able to get the dialog box to pop up again
19:31:56 <ReinH> well there goes my evening
19:32:02 <gwern> > (1/145) * 100000
19:32:04 <lambdabot>   689.6551724137931
19:32:59 <ReinH> oh god, thesis on chess arch including non-bitboard representations by the guy that wrote LOOP http://www.personeel.unimaas.nl/uiterwijk/Theses/PhD/Reul_thesis.pdf
19:33:10 <ReinH> can't. resist.
19:34:02 <Jafet> Waiting for 512-bit CPUs so we can have goban bitboards
19:34:48 <edwardk> clearly you need to use lenses to edit your board state
19:35:14 <Jafet> It helps avoid the "chess blindness"
19:35:24 <edwardk> hah
19:35:26 <ReinH> edwardk: am planning on abstracting whatever representation behind lenses, yes
19:35:43 <ReinH> my first chance to use them :)
19:36:57 <ReinH> I wonder if I can get any nice properties around attack detection
19:46:19 <solrize> jafet, en.wikipedia.org/wiki/Xeon_Phi
19:47:01 <solrize> 50 cores, 32 512-bit simd registers per core
19:47:33 <solrize> ll:
19:47:33 <solrize> Cabal-1.10.2.0 failed during the configure step. The exception was:
19:47:33 <solrize> ExitFailure 9
19:47:35 <solrize> bag
19:47:37 <solrize> bah
19:51:10 --- mode: wolfe.freenode.net set +o ChanServ
19:54:40 <stephenjudkins> ReinH: last time we grabbed a beer you were helping people in #ruby
19:55:21 <stephenjudkins> seeing you in here is like seeing someone who joined a monastery or something
19:56:10 <hpaste> solrize pasted “cabal fail?” at http://hpaste.org/72466
19:56:12 <Jafet> That would be #perl
19:57:11 <geekosaur> solrize, that's cabal's way of saying "package doesn't work with your ghc"
19:57:44 <solrize> oh i see, i'm still running 6.12
19:57:45 <solrize> thanks
19:58:50 <JoeyA> I think I finally get what the "Monadic state of t" is in monad-control.  It corresponds to the function argument of map*T
19:59:14 <JoeyA> For example, you have mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
19:59:25 <JoeyA> The "monadic state" of StateT is m (a, s)
20:00:11 <JoeyA> And in monad-control, this is indeed the case: newtype StT (StateT s) a = StState {unStState ∷ (a, s)}
20:07:36 <ddarius> "Things seem so much better when they aren't a part of your close surroundings."
20:08:34 <JoeyA> Going back to the discussion about generalizing 'atomically', I think it's completely doable with monad-control (or perhaps with the associated type approach it uses).
20:08:41 <JoeyA> We'd want to generalize mapReaderT
20:08:52 <JoeyA> err, map(Transformer)T
20:08:56 <djahandarie> Haskell is part of my close surroundings and it still seems so much better than other stuff.
20:11:03 * ddarius fears that his ligament is detaching.
20:11:39 <JoeyA> mapTransT :: (m (StT t a) -> n (StT t b)) -> t m a -> t n b
20:11:42 <edwardk> well, stop it =P
20:21:29 <average_drifter> sup haskell ppl
20:21:35 <average_drifter> your code is not compiling
20:21:56 <JoeyA> Can you be more specific?
20:22:08 <average_drifter> JoeyA: :P
20:22:11 <average_drifter> JoeyA: No.
20:22:23 <ReinH> heh
20:22:49 <ReinH> wat
20:22:49 <average_drifter> ReinH: :D
20:23:02 <average_drifter> shove that "wat"
20:23:11 <ReinH> ...
20:23:41 <average_drifter> the dots too
20:23:44 <ReinH> welcome to my ignore list
20:23:55 <average_drifter> welcome to my cocksucker list hahahahahaha
20:23:56 <average_drifter> HAHAHHAHAHA
20:24:10 <mauke> average_drifter: cut it out
20:25:41 <dhow119> so what are we doing here?
20:26:04 <average_drifter> wastin your time :P
20:26:18 <dhow119> haha i guess
20:26:29 <shapr> Whoa, smartcheck is SEXY
20:26:42 --- mode: ChanServ set +o shapr
20:26:53 --- mode: ChanServ set +o mauke
20:26:53 --- mode: mauke set +b $a:spetrea-home
20:26:59 <shapr> mauke: oh, thanks :-)
20:27:09 --- kick: average_drifter was kicked by shapr (Kicked by shapr)
20:27:12 --- mode: ChanServ set +o roconnor
20:27:18 <shapr> w00t, look at the ops!
20:27:40 <shapr> dhow119: Are learning Haskell?
20:27:44 <dhow119> am
20:27:53 --- mode: roconnor set -o roconnor
20:27:59 --- mode: shapr set -o shapr
20:28:08 <dhow119> do you guys know if there's a good way to dl a like wiki book as text?
20:28:09 <shapr> dhow119: Cool, found anything interesting?
20:28:33 <ReinH> shapr: you win
20:28:53 --- mode: mauke set -o mauke
20:29:15 * shapr shrugs
20:29:16 <applicative> dl a like wiki book?
20:29:25 <shapr> I don't tolerate that sort of language here.
20:29:33 <ReinH> applicative: you know like dl like a wiki book.
20:29:45 <shapr> dhow119: Have you tried Learn Yourself a Haskell?
20:29:48 <shapr> @where lyah
20:29:48 <lambdabot> http://www.learnyouahaskell.com/
20:30:04 <applicative> ReinH: Right, of course
20:30:05 <shapr> dhow119: Real World Haskell is also available, but I'm not sure if either of them have downloadable versions.
20:30:10 <dhow119> yeah i made it up until the pattern matching section in lean you a haskell
20:30:13 <ReinH> unwords . intersperse "like" . words
20:30:33 <dhow119> i didn't understand how (x:xs) means
20:31:00 <applicative> cons x xs, x stuck in front of xs, dhow119
20:31:05 <dhow119> is it kind of like the action of going thru a list and performing whatever?
20:31:08 <applicative> > 'a' : "b"
20:31:09 <lambdabot>   "ab"
20:31:30 <applicative> > 'a' : 'b' : []
20:31:31 <lambdabot>   "ab"
20:31:31 <dhow119> yeah i sort of understand consing, in that its like a nested list
20:31:33 <shapr> dhow119: the colon : puts another item on the list.
20:31:41 <dhow119> where each item points to the next
20:31:46 <applicative> consing is what : is
20:31:53 <dhow119> so how is consing pattern matching?
20:32:12 <shapr> because you can use the : on the left hand side to take an item *off* a list
20:32:19 <shapr> and put that item into a name of your choise.
20:32:22 <shapr> choice*
20:32:24 * shapr is tired
20:32:30 <applicative> there are two cases, two patterns for a list, nil and cons, or as we say [] and x:xs
20:33:07 <dhow119> 2 : 3 : []
20:33:16 <applicative> so when you define a function on lists, you must cover these cases, and this will be by 'pattern matching'
20:33:17 <shapr> dhow119: So if you have a list [1,2] and you have function (x:y) = x + y then 1 is bound to x, 2 is bound to y, and the result is 3
20:33:34 <shapr> Also, my example function is pretty much useless :-)
20:33:41 <mauke> and wrong
20:33:42 <applicative> > let f [] = 0; f (x:xs) = x in f [2,3,4]
20:33:43 <lambdabot>   2
20:33:51 <mauke> > case [1,2] of x:y -> (x, y)
20:33:52 <lambdabot>   (1,[2])
20:33:53 <dhow119> wow i can't get over lambdabot
20:33:57 <shapr> mauke: doh
20:34:00 <mauke> x is 1, y is [2]
20:34:02 <dhow119> > 2 : 3 : []
20:34:03 <lambdabot>   [2,3]
20:34:10 <shapr> mauke: thanks :-)
20:34:11 <applicative> ^^ this exammple illustrates everything there is to know about pattern matching.
20:35:04 <dhow119> alright i've got another retarded question for you
20:35:27 <dhow119> how do i convert string inputs into integers?
20:35:34 <applicative> to answer them is ourpupose
20:35:42 <dhow119> like the user types '3' and then later on i can add it
20:35:44 <applicative> no, that question is too retarded for us
20:35:49 <latro`a> dhow: look up read
20:35:51 <applicative> length converts strings to Ints
20:35:57 <dhow119> oh
20:36:02 <applicative> ha
20:36:10 <dhow119> that was from when i was working thru the wikibook
20:36:31 <applicative> > let input = read "3" :: Int in input ^ 2
20:36:32 <lambdabot>   9
20:36:43 <dhow119> like that program where the user puts in hight and width, and the haskells make into the area of a triangle
20:36:47 <applicative> read is what you are looking for I'd think.
20:37:18 <applicative> so you must read the string, with read, and an annotation telling the compile what its supposed to read it as
20:37:33 <dhow119> so what would the type conversion look like for that?
20:37:38 <latro`a> not necessarily, applicative
20:37:42 <latro`a> depends what you use it for afterwards
20:37:43 <applicative> latro`a: yes
20:37:48 <applicative> @type read
20:37:50 <lambdabot> forall a. (Read a) => String -> a
20:37:51 <latro`a> I know
20:37:59 <dhow119> would it be [char] => num a -> num a
20:38:03 <latro`a> it can be inferred
20:38:30 <dhow119> damn son
20:38:45 <applicative> latro`a: I was thinking its a typical mistake to do nothing to specify it; it happens to me all the time
20:38:55 <latro`a> true, but you said *must*
20:38:57 <latro`a> which is just false
20:39:03 <dhow119> i'm 27, i've been a cook since i was like 19, last year i decided i wanted to learn how to computer
20:39:08 <applicative> dhow119: you have to clue the compiler in when you use read, to take latro`a 's point
20:39:33 <applicative> hm
20:39:43 <latro`a> something has to tell it what type it is, but that often needn't be you
20:40:07 <applicative> yes
20:40:32 <parcs`> it's really silly that there is no safe 'read' in base
20:40:39 <aristid> parcs`: reads?
20:40:53 <latro`a> ^
20:40:54 <parcs`> yeah but that's cumbersome and nonobvious
20:41:01 <latro`a> it is pretty cumbersome, true
20:41:02 <aristid> yeah
20:41:09 <latro`a> but you can write a wrapper
20:41:26 <parcs`> it should be predefined
20:41:48 <aristid> parcs`: well maybe you can get your patch in for ghc 7.8!
20:41:49 <applicative> reads is safe read.  I like it because it uses the type of ye olde haskell parsers.  s -> [(s,x)]
20:42:09 <applicative> aristid: are you working on ghc>>
20:42:16 <aristid> applicative: but that's just irrational nostalgia!
20:42:26 <aristid> applicative: no, but i hear parcs` want to improve base :)
20:42:33 <applicative> aristid: yes
20:42:46 <parcs`> this issue has surely been brought up before
20:42:47 <monochrom> my http://www.vex.net/~trebla/haskell/reads.xhtml is a guide to reads
20:43:04 <applicative> A Parser of things is a Function from Strings, to Lists of Pairs of Things and Strings!!!
20:43:22 <applicative> monochrom wrote the book on reads
20:44:31 <aristid> applicative: i like how you capitalise your Words, almost as if You were writing in German
20:45:50 <applicative> i think I was supposed to be imitating Dr Seuss; good German name
20:46:50 <aristid> applicative: http://en.wikipedia.org/wiki/Dr._Seuss ?
20:46:55 <applicative> this image isn't as witty as the simple quation in Hutton http://www.willamette.edu/~fruehr/haskell/seuss.html
20:46:59 <applicative> yes
20:47:57 <applicative> oh check out the capitalization there I was right about the spirit of Seuss
20:48:25 <applicative> his best book is indisputable "Green Eggs and Ham", almost as good as SICP
20:48:30 <applicative> indisputably
20:49:17 <applicative> maybe my computer is too tired or surly to compile ghc-head. it keeps just stopping
20:49:37 <monochrom> overheat?
20:50:24 <applicative> hm, no I think its just a succession of independent mistakes, e.g failure to make clean
20:51:12 <ddarius> "Applicative Functor's Succession of Independent Mistakes"
20:51:22 <poincare101> Hi everyone. I remember there being some kind of way to look at how something is implemented in GHCi - anyone have any idea how to do this?
20:51:38 <parcs`> poincare101: :i
20:51:43 <ReinH> applicative: that seuss image is amazing
20:51:45 <applicative> poincare there is :i :info
20:52:14 <applicative> ReinH: how do you mean
20:52:38 <ReinH> applicative: very well done?
20:52:41 <applicative> ag
20:52:43 <applicative> ah
20:53:30 <poincare101> applicative: AWESOME!
20:53:53 <ReinH> Willamette University? Small world! I'm in Portland.
20:54:00 <poincare101> applicative: wait a second - this doesn't show implementation of functions like map :(
20:54:22 <applicative> poincare no.  with classes it will show the methods
20:54:24 <Jafet> To see source code, read the source code
20:54:50 <applicative> poincare101: you also have the 'haddocks' if you have the usual haskell platform
20:55:25 <Jafet> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.1.0/src/GHC-Base.html#map
20:55:36 <applicative> poincare101: It would be nice to have something more like python  --  if its as I remember -- but the current arrangement has a lot of inertia,
20:56:06 <Jafet> Yay, cabal now has --haddock-hyperlink-source
20:56:08 <applicative> anyway who needs the definition when they have the typesignature
20:56:16 <Jafet> However, .cabal does not have it
20:57:58 <Jafet> Also, hscolour doesn't like latex
20:58:54 <applicative> poincare, it is good to think up a way to make the haddocks readily available when you are writing.
20:59:46 <applicative> mine are in ~/.cabal/doc in particular /.cabal/doc/index.html  it's all linked together, and you click in the appropriate place to see the source
21:01:00 <Jafet> Is there a .cabal/config option for that?
21:01:02 <hpaste> Me pasted “someType” at http://hpaste.org/72467
21:01:18 <applicative> maybe it wouldnt be too hard to hack ghci to do something crude: basically print what you see if you click 'source' on a haddock page
21:01:28 <ddarius> > maximum []
21:01:29 <lambdabot>   *Exception: Prelude.maximum: empty list
21:01:33 <applicative> Jafet for what?
21:01:43 <Jafet> For linking the source in haddocks
21:02:17 <ddarius> applicative: You can arbitrarily powerful : commands in GHCi.
21:02:52 <ddarius> One thing I did many, many years ago was make a dribble-like command for GHCi.  I never really used it, but then I never really use GHCi.
21:03:07 <Jafet> It would need to be arbitrarily powerful indeed, as you need to parse the source
21:03:24 <ddarius> Jafet: That's easy enough to do.
21:06:24 <ddarius> :t 'map
21:06:25 <lambdabot>     lexical error in string/character literal at character 'a'
21:18:52 * hackagebot happstack-authenticate 0.9.3 - Happstack Authentication Library (JeremyShaw)
21:40:43 <ParahSailin> could something like zeromq be implemented in haskell?
21:42:29 <Ralith> what's that bot command
21:44:26 <Ralith> well at any rate
21:44:27 <Ralith> ParahSailin: yes.
21:44:28 <Cale> ParahSailin: http://hackage.haskell.org/package/zeromq-haskell http://hackage.haskell.org/package/zeromq3-haskell
21:45:00 <Cale> (why would you even suspect it wouldn't be possible? :)
21:45:20 <Ralith> Cale: those are bindings, not implementations.
21:46:22 <ParahSailin> by could, i mean, would it be productive to do so
21:47:18 <ParahSailin> is that sort of intensive io something ghc and the runtime handle well
21:49:04 <xpika> given a cabal project not on hackage. can i get cabal to grab the dependencies from there anyway?
21:49:10 <stepkut> is there something like shellac that is still maintained?
21:57:26 <Enigmagic> xpika: "cabal install" will do it if you're in the directory with the .cabal file you're trying to install.
21:58:54 <Cale> Ralith: Yeah, but if you can make a binding to something in Haskell, you can certainly implement it in Haskell.
22:05:44 <latro`a> uh
22:05:47 <latro`a> I'm not sure I buy that, cale
22:06:07 <latro`a> I don't see anyone trying to implement a graphics engine like opengl in haskell
22:06:17 <latro`a> but there is a binding
22:06:54 <Rotaerk> latro`a, why not?
22:07:04 <Rotaerk> as long as you have bindings to the lower level mechanisms for implementing OpenGL
22:07:25 <latro`a> no, I mean I don't see anyone literally implementing OpenGL itself, from the drivers up
22:07:45 <Rotaerk> he didn't say *would* implement it in haskell
22:07:46 <MostAwesomeDude> latro`a: Well, where do the drivers end?
22:07:51 <latro`a> eh, not literally itself, but something analogous, a full graphics engine that only relies on drivers
22:07:58 <latro`a> um
22:08:02 <MostAwesomeDude> Are you talking about implementing something on top of Gallium?
22:08:11 <latro`a> don't know what gallium is
22:08:30 <latro`a> ah
22:08:32 <ddarius> OpenGL is just a standardized interface to graphics drivers nowadays.
22:08:46 <latro`a> true, kinda
22:10:17 <MostAwesomeDude> latro`a: Hi, I implemented graphics drivers for fun.
22:10:26 <latro`a> huh
22:10:27 <latro`a> link?
22:10:37 <latro`a> also, benchmarks?
22:10:45 <Ralith> Cale: that's nonsense
22:10:52 <MostAwesomeDude> So when you say "from the drivers up," there's not really any single unifying interface that all the drivers implement for raw GPU access.
22:11:02 <MostAwesomeDude> Hm... What to link to...
22:11:07 <latro`a> right, but you have to start *somewhere*
22:11:25 <MostAwesomeDude> Well, you start with raw register banging on a GPU.
22:11:51 <latro`a> sure, but I'm not including that level in my interpretation of cale's statement
22:12:05 <Jafet> I write games in VHDL
22:12:13 <latro`a> oh dear
22:12:45 <MostAwesomeDude> Well, as far as the "something to bind to" goes, why not Gallium? It's a low-level interface for talking to GPUs in a unified, hardware-agnostic way. It's lower-level than D3D or GL.
22:13:01 <MostAwesomeDude> In fact, D3D and GL (and VG and friends) are implemented on top of Gallium.
22:13:51 <latro`a> seems like a place to start; I was basically saying that I neither see nor anticipate any bindings like that
22:14:18 <MostAwesomeDude> (Proof I hacked on Mesa: http://www.ohloh.net/p/mesa/contributors/20766166910198 )
22:14:38 <MostAwesomeDude> Well, there wouldn't be much of a point, to be honest. You still have to do things like invent the windowing system.
22:15:13 <MostAwesomeDude> And going any lower than Gallium pretty much devolves into talking directly to the kernel.
22:15:21 <MostAwesomeDude> And going lower than *that*, well.
22:15:32 <latro`a> now you've got a hell of a task on your hands
22:15:38 <MostAwesomeDude> Yeah.
22:16:06 <MostAwesomeDude> Anyway, I did think about doing things like this in Python and then later in Haskell. Mostly I haven't done it because nobody would pay me for it and it'd be a crapload of work.
22:18:17 <ksf> MostAwesomeDude, gallium isn't guaranteed to be stable because it's not meant to be a public api.
22:28:22 <Cale> latro`a: But you can obviously do that in Haskell if you want.
22:28:41 <latro`a> you can do it in brainfuck if you want, too, technically
22:28:45 <Cale> latro`a: any low-level shenanigans you could do in C could also be written in Haskell
22:28:53 <latro`a> not trying to say you can't do stuff
22:29:21 <Cale> (and there are often good reasons to want to do that)
22:30:44 <Enigmagic> obsessive compulsive disorder?
22:30:52 <Enigmagic> methamphetamines?
22:40:17 <Cale> Enigmagic: Usually the benefits stem from the fact that you can take a model of your setting with nice properties (purity), and then implement the real thing by compiling those model descriptions in terms of the chunks of low-level code. I suppose you could still decide to write that code in C and FFI import it, but there's not really any great reason not to do it in Haskell at that point. The IO monad itself has lots
22:40:17 <Cale> of nice properties, even if we give it a lot of heck for its execution being a lot muddier semantically than evaluation is.
22:41:16 <Cale> But yeah, Haskell is a language in which you can choose to work at a lot of levels of detail if you want.
22:41:59 <ParahSailin> Cale, interesting
22:42:30 <ParahSailin> is there somewhere i could learn more about low level haskell stuff?
22:43:25 <raymank26> hi all. How can I add a search path for ghc-mod?
22:43:34 <Cale> I'd say start with the FFI spec, because that includes a lot of low-level primitives in addition to the stuff which lets you bind to C and other language libraries.
22:43:42 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
22:43:50 <ParahSailin> cool
22:44:14 <Cale> It's a good bit more friendly and readable than the rest of the Haskell report, even though it's technically part of it now.
22:44:39 <Cale> (not that the Report is all that bad, it's just not so beginner friendly)
22:45:50 <Cale> ParahSailin: One really cute thing:  malloc :: Storable a => IO (Ptr a)
22:45:53 <solrize> ParahSailin, you may also want to read the awkward squad paper if you haven't?
22:47:41 <Cale> (There's a malloc with no parameters that allocates the right amount of memory (and with the right alignment) which it knows from the instance of Storable)
22:49:20 <Enigmagic> Cale: uhm. depending on the code, the ffi transitions (even with unsafe ffi) can easily outweigh the benefits of writing little chunks in C.
22:49:47 <Enigmagic> unless you use primop import hacks it's better to either write it all in haskell or write larger chunks in C
22:50:19 <rata_> hi guys
22:50:30 <Cale> oh, indeed, there would be cases where you wouldn't want to have to pay for so much marshalling
22:51:06 <rata_> i'm wondering if there is any known performance bug in ghc 7.4.2 as i'm compiling one of my programs with -O2 and it's taking ages
22:51:25 <rata_> it's been more than two hours
22:51:44 <ParahSailin> solrize, this paper is good
22:51:56 <Enigmagic> it's not just marshalling overhead, just switching calling convention seems to be particularly expensive for small functions
22:52:32 <rata_> it's been more than 2 hours for a file that has almost 230 lines of code
22:52:42 <danil> rata_: how's its cpu/memory use?
22:53:02 <rata_> danil: 100% cpu, 13% mem
22:53:17 <Enigmagic> rata_: you might try restarting it with -v3 and seeing where it gets stuck
22:53:54 <Enigmagic> i have some code that is 30-40 lines that takes about 20 minutes on -O2 though
22:54:53 <rata_> wow, that's a lot
22:55:06 <Enigmagic> heavy use of rank-n types, GADTs and type families seems to kill my compile times...
22:55:07 <Cale> rata_: Could you put the code on hpaste.org? That definitely seems pathological...
22:55:15 <danil> you can get HM to infer types exponentially larger than your code, so it's not surprising that it's possible to write things slow to compile
22:56:14 <danil> but if it's only on -O2 it's probably the inliner's fault
22:56:31 <danil> (in any case, -v3 is better than educated guesses)
22:57:36 <Cale> istr it's possible to make the inliner go into an infinite loop in some contrived cases
22:58:46 <ParahSailin> this technical paper is better than silly tutorials
22:58:49 <rata_> maybe that is
22:59:08 <rata_> Cale: the code is in https://github.com/rhz/thermokappa
22:59:27 <rata_> after cloning, run "ghc --make -O2 MinimalGlueings"
22:59:58 <hpaste> dfeuer pasted “ABCDEF” at http://hpaste.org/72468
23:00:11 <dfeuer> Yeah, so I'm working on a silly problem: https://www.spoj.pl/problems/ABCDEF/ but my unbelievably ugly code, at http://hpaste.org/72468 is too slow to be accepted as a solution.
23:00:17 <dfeuer> I'm wondering if anyone has some tips.
23:03:59 <Cale> Oh, this is interesting, it's taking a long time doing SpecConstr
23:04:16 <dfeuer> Cale: I seem to remember you're right about the inliner. Something about preventing that being really expensive.
23:04:27 <Enigmagic> rata_: add -fno-spec-constr
23:04:30 <Enigmagic> compiles in seconds
23:05:52 <rata_> what's SpecConstr?
23:06:59 <Cale> rata_: an optimisation which produces specialised versions of functions for specific data constructors in the arguments
23:07:21 <solrize> ParahSailin, you mean awkward squad?  yeah that demystifies a lot
23:08:08 <cheater__> which technical paper?
23:08:38 <rata_> Cale: that sounds like a good optimisation
23:09:11 <Cale> Specifically, it looks for self-recursive functions where you have a recursive call with one or more of the parameters being an explicit constructor application, and the same parameter is scrutinised by a case (is pattern matched on)
23:09:59 <rata_> Cale: ok, thanks
23:10:47 <Cale> (or a slight variation on that where it can unfold one or more of the parameters into constructor applications and that and the pattern match are the only occurrences)
23:11:24 <Cale> this may be an instance of this bug: http://hackage.haskell.org/trac/ghc/ticket/5550
23:12:18 <cheater__> solrize: you guys talking about some paper?
23:14:17 <solrize>  http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
23:15:25 <cheater__> thanks, looking
23:17:41 <cheater__> solrize: oh right that
23:22:10 <dfeuer> OK, so my stupid code is slow as fuck because it does too much sorting (so says the profiler). Guess I need to switch algorithms now.
23:24:06 <solrize> so tell me, i want to run haskell programs on a 128 meg machine and i don't seem to be able to run significant cabal installs on it
23:24:14 <solrize> so i probably have to cross-compile and move binaries over
23:24:34 <solrize> are there nonobvious obstacles?
23:25:00 <solrize> for that matter i also want to run them on a 32 meg machine but if that's impossible i can deal with it.
23:25:28 <dfeuer> What sorts of machines are these with so little RAM? Embedded systems?
23:25:40 <solrize> vps
23:25:48 <dfeuer> What's that?
23:25:54 <solrize> virtual private server
23:26:16 <solrize> a simulated linux box running along side a lot of other ones inside a real box
23:26:23 <dfeuer> Yeah, got it already.
23:26:49 <solrize> also interested in embedded (raspberry pi etc.) but not using one right now
23:28:47 <dfeuer> Well,
23:29:03 <dfeuer> it is generally true that you don't want to do heavy compilation on a machine with so little RAM.
23:29:19 <solrize> the compiler seems to work but the linker runs out of memory
23:29:25 <rata_> Cale: wow, if it's an instance of that bug it won't get fixed in a long time
23:29:59 <Kuraitou> I had the same problem, so I just set up an ARM qemu instance locally and did my builds on that, then copied the binaries to a raspi.
23:30:13 <Kuraitou> Haven't really had any issues at all.
23:31:02 <ksf> invertible-syntax has such nice semantics.
23:31:03 <Cale> rata_: Well, their current target for fixing it is the next release
23:31:10 <ksf> too bad it's too slow to catch a snali.
23:31:13 <ksf> *snail
23:31:35 <Cale> rata_: maybe it'll be overlooked, but you can vote for it by adding yourself to the CC list
23:31:54 <rata_> Cale: 7.6.1 is the next release?
23:32:20 <Cale> hmm, unless they have another minor release planned in between
23:33:26 <rata_> wouldn't it be 7.6.0 in case no minor release is planned?
23:33:48 <Cale> There are never .0 minor versions
23:33:58 <rata_> oh ok
23:34:21 <Cale> The middle number is always even in a release, and the last number counts up from 1
23:58:26 <latro`a> ...is nub lazy? if so, how
23:59:17 <latro`a> I'm doing take on a very long nub, and it "pauses" periodically, which makes it look like it's trying to evaluate
23:59:41 <latro`a> but unless I'm missing something, that seems impossible
