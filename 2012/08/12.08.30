00:02:14 <lpvb> how do I show a double so that if it's very close to an integer, it will just show the integer? e.g. 5.0 + 2.0 = 7
00:02:34 <shachaf> What do you want to do if it's not very close to an integer?
00:02:48 <lpvb> show it normally as a double
00:03:19 <lpvb> without a decimal when it's close, with a decimal if it's not
00:03:27 <shachaf> if veryCloseToInteger d then show (round d) else show d?
00:03:50 <shachaf> There are various edge cases to think about, of course.
00:03:53 <lpvb> @hoogle veryCloseToInteger
00:03:53 <lambdabot> No results found
00:03:57 <startling> heh
00:04:05 <lpvb> how do I implement that?
00:04:18 <lpvb> check within epsilon?
00:04:20 <shachaf> I would say that you shouldn't want this function in the first place. :-)
00:04:29 <shachaf> But that's probably a reasonable way of doing it if you insist.
00:04:35 <startling> lpvb: `mod` might be useful
00:04:40 <lpvb> why not? I liuke aesthetics
00:04:43 <lpvb> like*
00:04:46 <shachaf> startling: Huh?
00:05:08 <startling> oh, `mod` is only on Integral
00:05:12 <startling> never mind !
00:07:35 <lpvb> unfortunately there's no instance for (minBound :: Double)
00:07:57 <lpvb> so how would I get epsilon for a Double?
00:08:43 <shachaf> What does minBound have to do with it?
00:08:55 <frerich> lpvb: The Numeric.EEEE module has an 'epsilon'.
00:09:06 <frerich> lpvb: Sorry, Numeric.IEEE
00:09:12 <rosie> shachaf: Do you have an idea on how to implement the model-view-controller paradigm using Haskell? (and blaze-html)
00:09:17 <Enigmagic> lpvb: if you're concerned about making numbers look pretty the regular "epsilon" value isn't going to help much
00:09:34 <Enigmagic> your epsilon might be 0.001 or something like that
00:09:36 <lpvb> shachaf: oops, forgot minBound is not epsilon
00:10:02 <shachaf> Oh, I see.
00:10:12 <shachaf> == Enigmagic, anyway. Pick your own epsilon.
00:11:10 <Z`> how could I run 2 functions inside my main function ? (I mean two different unrelated to each other, functions)
00:11:21 <shachaf> Z`: "main" isn't a function.
00:11:30 <Z`> oh, really ?
00:11:42 <Z`> I thought it was like -say- C's main() { ... }
00:11:43 <startling> Z`, however you like
00:11:43 <shachaf> Well, gcc would disagree with me on this point.
00:11:47 <shachaf> In Haskell it's not a function.
00:11:52 <kennyd> Z` function does not mean what you think it does
00:11:54 <shachaf> rosie: Well... First figure out what "model-view-controller" means, and why you want it. :-)
00:12:15 <startling> Z`: it's a monadic value representing an action
00:12:23 <kennyd> Z` functions don't have side effects. main does
00:13:35 <Z`> I haven't reached monads yet in my reading. Alright, let me rephrase. I have a tree and I'd like to print its leafs and also I'd like to pring the total number of nodes in it. I have 2 separate functions for that actions. How could I run both and have their result printed?
00:14:28 <shachaf> Z`: main = do { thing1; thing2 }
00:14:40 <startling> Z`: main = do { let mytree = whatever; print (nodes mytree); print (leaves mytree); }
00:14:45 <spark_> do x<- function 1 tree; y<-function 2 tree , putStrln show x ++ show y ?
00:14:46 <shachaf> (Alternatively use indentation instead of {}; .)
00:15:03 <Z`> lots of answers.thanks! I'll trem all
00:15:05 <Z`> tru*
00:15:30 <voodoo_> Hello. What haskell mode for emacs should i install to get argument hints and completion working?
00:15:46 <johnw> ghc-mod
00:15:55 <spark_> im sure theres a topic in reddit about that
00:16:03 <johnw> ghc-mod works very nicely with haskell-mode
00:16:09 <johnw> also, see http://github.com/jwiegley/haskell-config
00:17:10 <voodoo_> Thanks johnw
00:17:15 <spark_> I have  a function that works in ghci, but when i use it on my.hs the behaviour seems off. What to do? @.@
00:17:47 <shachaf> I recommend asking a vague question in #haskell and not posting any code or error messages. :-)
00:17:55 <spark_> (hahaha)
00:17:57 <spark_> sorry
00:18:15 <shachaf> (It always works for me!)
00:18:41 <rosie> shachaf: more code separation and reusability. yeah?
00:19:12 <shachaf> rosie: Hmm?
00:19:39 <hpaste> spark_ pasted ‚ÄúintervalFinder works on GHCI, seems to return nul on compiled‚Äù at http://hpaste.org/73932
00:20:18 <rosie> shachaf: I was under the impression that MVC is a well-know and widely accepted paradigm when you need to separate data from view from logic. http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller. No?
00:20:37 <johnw> it's certainly well-accepted in certain circles
00:20:42 <johnw> I knew people who swear by it
00:21:11 <shachaf> rosie: It is, but that doesn't invalidate what I said. :-)
00:22:06 <rosie> shachaf: sorry?
00:22:37 <shachaf> rosie: Haskell is probably a rather different sort of language from the languages that people came up with this concept in.
00:22:58 <rosie> shachaf: gotcha. Thanks
00:23:03 <shachaf> (Mostly object-oriented languages, for instance, where you have "model/view/controller" objects.)
00:23:04 <voodoo_> didi what exactly isnt working, (foo ...) ?
00:23:20 <shachaf> rosie: So you can expect a Haskell implementation of the concepts to look pretty different.
00:23:44 <rosie> shachaf: thanks
00:24:41 <shachaf> (What's the context of the question? You like MVC and you're wondering how it would look in Haskell? You like Haskell and you're wondering what MVC is? Something else?)
00:27:00 <spark_> MVC is directly related to objects, I would say that lously d here you would just change the function that outputs your data. but mvc also relates input, and this is probably frp
00:27:22 <ivanm> I don't suppose there's a nicer way of saying something like this: do { x <- parseVal; if badVal x then fail "not valid" else return x } ?
00:27:45 <johnw> if x were an Either there would be
00:28:02 <bas__> if there are no obvious criteria for the order of a function's arguments, how does one order them?
00:28:18 <johnw> well, maybe not so much
00:28:18 <ivanm> bas__: say you have two arguments
00:28:29 <shachaf> bas__: With the assumption that it'll be partially applied.
00:28:32 <ivanm> one way of looking at it is, which one are you most likely to want to map/fold over ?
00:28:51 <shachaf> So if (f x) is a more useful function, on its own, than (f y), x should come first.
00:29:07 <bas__> ah yeah, excellent
00:29:11 <ivanm> alternatively, would one argument create a nice morphism? (e.g. addEdge :: Edge -> Graph -> Graph is nicer than addEdge :: Graph -> Edge -> Graph)
00:29:40 <bas__> yes both of those ideas were playing around in my mind
00:29:43 <johnw> I would think the latter is better
00:29:54 <johnw> because it's more likely you'll want to partially apply on the graph than on the edge
00:30:15 <bas__> sometimes it is obvious that the one is more useful to map over than the other, but I know absolutely certain that I will not want to do that
00:30:32 <ivanm> johnw: the former gives a nicer morphism, and lets you build up the graph
00:30:45 <ivanm> addEdge e1 . addEdge e2 :: Graph -> Graph
00:31:04 <spark_> i love when ghci closes when i make a line too big
00:31:10 <ivanm> spark_: :o
00:31:21 <spark_> ivanm: that's probably a windows bug?
00:31:23 <shachaf> @ty foldr ?addEdge ?emptyGraph
00:31:24 <lambdabot> forall a b. (?emptyGraph::b, ?addEdge::a -> b -> b) => [a] -> b
00:31:33 <johnw> ivanm: ahh
00:31:38 <ivanm> spark_: this is plain ghci ?
00:31:40 <johnw> i see what you mean
00:31:43 <ivanm> not running it in anything?
00:31:44 <spark_> ivanm: yes
00:31:48 <ivanm> hmmm
00:31:50 <johnw> and flip addEdge can be used for what I Meant
00:31:53 <ivanm> no idea
00:31:55 <ivanm> johnw: yup
00:32:01 <spark_> ivanm: well i have my .hs loaded, but shouldn't make a diference
00:32:05 <shachaf> Don't use flip. :-(
00:32:08 <shachaf> flip = the devil
00:32:17 <johnw> flip shachaf
00:32:18 <ivanm> shachaf: :o
00:32:20 <ivanm> why?
00:32:31 <spark_> ivanm:                SetConsoleCursorPosition: invalid argument (The parameter is inco
00:32:35 <spark_> D:
00:33:29 <shachaf> Yep, it's a bug.
00:33:37 <shachaf> You're not the first person to run across it, either.
00:34:48 <randomclown> why does changing map (truncate :: Double -> Int) $ map (* 10.0^limit) to map (\x -> truncate (x * 10.0^limit)) yield a huge speed increase?
00:35:15 <randomclown> I meant boost, the one with the lambda expression is quite literally 100x faster
00:35:28 <johnw> map over a map is O(n^2)
00:35:39 <johnw> or O(n*2)?
00:35:43 <ivanm> shachaf: what's wrong with flip?
00:35:44 <johnw> i always get confused by that
00:35:48 <ivanm> johnw: with fusion, O(n)
00:35:56 <johnw> but anyway, you create a lot of intermediates that get thrown away
00:35:59 <dibblego> johnw: O(n*2) = O(n)
00:36:00 <ivanm> otherwise, O(2*n) == O(n)
00:36:07 <johnw> ah, thanks ivanm
00:36:10 <johnw> I've been told that before
00:36:10 <spark_> i had the same problem, fusion not kicking in
00:36:20 <johnw> constants fold away in O() notation
00:36:43 <johnw> randomclown: are you using -O?
00:36:48 <johnw> this could be a GHC bug
00:36:59 <spark_> haskell platform?
00:37:00 <shachaf> ivanm: It's very hard to read.
00:37:15 <ivanm> shachaf: not for me it isn't...
00:37:21 <shachaf> I don't mind (`f` arg), and I don't mind (\x -> f x arg), but flip f arg is just terrible.
00:37:21 <johnw> shachaf: flip why that is?
00:37:25 <ivanm> randomclown: how are you running/compiling
00:37:36 <ivanm> shachaf: huh, never thought about doing it as (`f` arg)
00:37:47 <johnw> flip f arg does take moment to figure out
00:38:01 <randomclown> ivanm: even with 02 it doesn't make a difference
00:38:12 <randomclown> I'll post up the test code real quick (about 4 lines) to demo this
00:38:16 <johnw> randomclown, spark_: Can you guys post a bug to GHC?
00:38:16 <ivanm> randomclown: are you sure you're re-compiling?
00:38:27 <johnw> implied composition should be happening
00:38:46 <johnw> @pl map f $ map g
00:38:47 <lambdabot> map f (map g)
00:39:02 <johnw> @pl map f $ map g [1,2,3]
00:39:02 <lambdabot> map f [g 1, g 2, g 3]
00:39:02 <shachaf> randomclown: Can you post a snippet that people in here can run? :-)
00:39:09 <johnw> ah, hmm
00:39:10 <shachaf> johnw: What's "implied composition"?
00:39:12 <shachaf> Fusion?
00:39:13 <ivanm> I wonder if it's from using $ ...
00:39:17 <ivanm> shachaf: I think that's what he means
00:39:18 <johnw> @unpl map (f .g) [1,2,3]
00:39:19 <lambdabot> map (\ c -> f (g c)) [1, 2, 3]
00:39:22 <spark_> my case was (map f) . (map g)
00:39:35 <hpaste> randomclown pasted ‚Äúmap not fusing‚Äù at http://hpaste.org/73933
00:39:41 <johnw> spark_: that's the same as what I wrote
00:39:53 <scshunt> ^
00:39:54 <johnw> implied composition would change your expression to map (f . g)
00:40:01 <ivanm> randomclown: how are you timing this?
00:40:04 <ivanm> which version of GHC?
00:40:16 <johnw> but it looks like your inner map is producing a list of partial applications
00:40:24 <randomclown> 7.4.2
00:40:26 <johnw> which, I think, is rather expensive for long lists
00:40:49 <shachaf> randomclown: taylor and taylor2 take the same amount of time for me.
00:40:50 <scshunt> shachaf: I dislike (`f` foo) unless f is specifically meant to be used infix
00:40:53 <ivanm> here's an idea: type defaulting issues...
00:41:06 <scshunt> e.g. (`map` [1, 2, 3]) is nonintuitive
00:41:16 <scshunt> flip map [1, 2, 3], even if uglier, is easier to understand
00:41:18 <shachaf> johnw: That's an optimization that GHC can make but it's certainly not part of the semantics of the language.
00:41:26 <ivanm> same time as well
00:41:31 <johnw> well, can make, but apparently isn't..
00:41:32 <shachaf> I prefer (`map` [1,2,3]) to (flip map [1,2,3])
00:41:36 <tbreisacher> in the particular case of map, isn't that kind of what <$> is for? :)
00:41:39 <ivanm> using ghc -O2
00:41:41 <shachaf> Even better: (<$> [1,2,3])
00:41:44 <johnw> i wonder if there's a way to write a small test case that proves this
00:41:51 <ivanm> tbreisacher: yup
00:41:56 <scshunt> shachaf: but then you have to think about the meaning of the section
00:42:00 <randomclown> shachaf: hmm weird.
00:42:00 <scshunt> yes, the latter is better
00:42:11 <scshunt> since it's natural to write f <$> [1, 2, 3]
00:42:11 <shachaf> scshunt: Yes. Which is much easier for me than thinking about the meaning of flip.
00:42:27 <scshunt> I disagree :)
00:42:55 <randomclown> Yeah I probably messed up with the recompiling. I'm a tard.
00:43:12 <ivanm> @wn tard
00:43:13 <lambdabot> No match for "tard".
00:43:33 <shachaf> It's a kind of pastry.
00:43:34 <ivanm> scshunt: how is it "natural"?
00:43:39 <ivanm> it's only natural if you're used to it
00:43:47 <ivanm> and not using a pretty-printing library that uses <$> ... :p
00:44:04 * hackagebot ghc-heap-view 0.3 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.3 (JoachimBreitner)
00:46:45 <scshunt> ivanm: natural in that <$> is usually used infix
00:46:53 <scshunt> so the meaning of the section comes to mind
00:46:53 <ivanm> ahhh, right
00:47:27 <scshunt> the most annoying idiom in all of haskell btw
00:47:31 <scshunt> is ((->) r)
00:47:48 <scshunt> for the precise reason that it is confusing with the section (-> r) which is technically not allowed
00:47:55 <shachaf> That's why I write (r ->).
00:47:59 <scshunt> yeah
00:48:00 <shachaf> Even though it's invalid syntax.
00:48:20 <ivanm> you write it but it's invalid?
00:48:25 <ivanm> so what's the point of writing it then?
00:49:14 <scshunt> ivanm: it's easier for understanding in conversation
00:49:24 <scshunt> I'm surprised it's not an extension, actually
00:52:45 <hpaste> johnw pasted ‚ÄúMap composition‚Äù at http://hpaste.org/73934
00:52:56 <johnw> is that code enough to prove whether composition is happening?
00:53:04 <johnw> the output is Inner/Outer/Inner/Outer...
00:53:10 <johnw> and not Outer/Outer/...Inner/Inner
00:53:47 <johnw> if I put the seqs around the map, I feel that I'm changing the semantics beyond what the optimizer could see
00:54:27 <randomclown> > (flip (!!)) 100000 $ map (4*) $ tail . scanl (+) 0 $ zipWith (*) (map (1/) [1,3..]) (cycle [1,-1])
00:54:29 <lambdabot>   3.1416026534897203
00:54:35 <randomclown> seems to be quite a bit faster than
00:54:50 <randomclown> > (flip (!!)) 100000 $ scanl1 (+) [ 4 * ((-1)^(fromIntegral n)) / (2 * (fromIntegral n) + 1) | n <- [0..]]
00:54:54 <lambdabot>   mueval-core: Time limit exceeded
00:54:58 <johnw> is there is a shorthand for let x = ... in seq x x ?
00:55:32 <johnw> isn't your scanl1 generating an enormous amount of data?
00:55:55 <randomclown> the other one has a scanl1 as well
00:56:01 <johnw> oh, yeah
00:56:21 <johnw> but the map is cocnsuming it
00:56:30 <johnw> before the !! gets to it
00:56:40 <shachaf> johnw: Yes: ...
00:56:46 <johnw> i.e., the scanl1 temps are getting collapsed away as they're being produced
00:56:51 <johnw> in the second case, you have a huge space leak
00:57:20 <johnw> shachaf: but that's not a strict evaluation?
00:57:32 <shachaf> johnw: It's as strict as what you wrote.
00:57:41 <johnw> then I need a refresher on seq
00:57:46 <shachaf> Yep.
00:57:51 <johnw> any good pointers?
00:58:15 <shachaf> Maybe http://www.vex.net/~trebla/haskell/lazy.xhtml
00:58:44 <johnw> what about id $! x?
00:58:56 <johnw> does that force evaluation of x?
00:58:59 <randomclown> so how would one rewrite the 2nd version?
00:59:00 <shachaf> "id" is already a strict function.
00:59:07 <johnw> oh
00:59:09 <johnw> I thought id x = x
00:59:12 <shachaf> Yes.
00:59:15 <shachaf> That's a strict function.
00:59:20 <johnw> but x isn't strict
00:59:28 <johnw> you mean, id x is the strict version of x
00:59:33 <shachaf> No.
00:59:38 <quicksilver> no. He means id is a strict function.
00:59:50 <quicksilver> Also, just a few moments ago you suggested seq x x
00:59:53 <quicksilver> that's useless
00:59:55 <johnw> so if I have x it's lazy, but if I have id x it's the same value but strict?
00:59:56 <quicksilver> seq x x is exactly x.
01:00:00 <quicksilver> no, johnw
01:00:12 <shachaf> A value isn't "lazy" or "strict".
01:00:15 <shachaf> It just is.
01:00:23 <startling> johnw: id x depends on x
01:00:32 <shachaf> (Alternatively, it's reducible or not reducible, or something like that.)
01:00:38 <startling> johnw: seq x y depends on x, but only uses the result of y
01:00:45 <quicksilver> The defintion of strict: f is strict if (f _|_) = _|_
01:00:56 <quicksilver> since id _|_ = _|_, then certainly id is strict.
01:01:00 <johnw> if I have 'y = f x', my understanding is that f x is only evaluated if I need the value of y
01:01:14 <shachaf> "need" is a vague word.
01:01:21 <shachaf> Did you see that link I linked to?
01:01:26 <johnw> so, if I say 'y = id . f $ x', is y now rendered to its value immediately?
01:01:30 <quicksilver> no.
01:01:31 <shachaf> I haven't read it but it's probably good.
01:01:40 <quicksilver> you are misunderstand what "id is strict" means.
01:01:42 <johnw> i'll have to queue it to my Kindle
01:01:46 <johnw> yes, I am very much so
01:01:46 <shachaf> johnw: "id x" is, for all purposes, exactly the same thing as "x".
01:01:59 <johnw> shachaf: you have me utterly confused now
01:02:07 <shachaf> johnw: You could read it now instead of queuing it. :-(
01:02:18 <shachaf> I mean, if you don't read it now, you'll spend now reading IRC instead.
01:02:21 <johnw> i prefer not reading material like this on a computer screen
01:02:26 <shachaf> And all we'll be saying here is what's already in the article.
01:02:28 <quicksilver> evaluation happens on demand, as you said.
01:02:36 <shachaf> It's going to be pretty much the same words. :-)
01:02:37 <johnw> that's fine, i can wait for my answer
01:02:43 <quicksilver> and evaluation only happens to the extent that is demanded.
01:02:46 <startling> johnw, (flip const) x y <- doesn't evaluate x
01:02:49 <johnw> i'll ask again tomorrow if I still have doubts
01:02:54 <shachaf> startling: flip :-(
01:02:55 <startling> johnw: seq x y <- evaluates x
01:03:01 <quicksilver> startling: no it does not.
01:03:23 <startling> fine, "introduces a data dependency for x such that x gets evaluated eventually"
01:03:25 <shachaf> It's perfectly valid for "seq x y" never to evaluate x.
01:03:26 <startling> right?
01:03:27 <quicksilver> startling: no.
01:03:32 <johnw> i want to know how to collapse a thunk before returning from a function
01:03:42 <quicksilver> startling: only if y the whole expression is evaluated at some point.
01:03:52 <startling> okay, fine
01:04:11 <shachaf> quicksilver: Even if the whole expression is evaluated, x might never be evaluated.
01:04:12 <quicksilver> (seq x y) is an expression such that if you ever do choose to evaluated it (to get the value of y) then x will be evaluated (to WHNF only) first.
01:04:15 <startling> "seq x y introduces a data dependency for x such that x gets evaluated if and when seq x y gets evaluated"
01:04:27 <startling> quicksilver: not necessarily first
01:04:28 <quicksilver> which is why (seq x x) is useless
01:04:28 <shachaf> For example, if y = _|_. Of course, this distiction is operational only. :-)
01:04:49 <quicksilver> startling: not technically required to be first, but you might as well assume it is.
01:05:08 <johnw> if you say id x is the same as x, and id is strict, what does that mean about the return value from id x?  what does strictness mean?
01:05:27 <shachaf> "f is strict" means "f _|_ = _|_"
01:05:30 <shachaf> Do you know what _|_ is?
01:05:36 <startling> shachaf: I just used flip so the arguments would be in the same order
01:05:42 <johnw> it's the bottom type, a member of every type
01:05:45 <johnw> it's bottom
01:05:47 <shachaf> No.
01:05:48 <johnw> not the bottom type
01:05:53 <johnw> it's "undefined"
01:06:04 <shachaf> undefined is _|_
01:06:09 <johnw> like Bool = True | False | undefined
01:06:10 <shachaf> So is "let x = x in x" and other things.
01:06:12 <johnw> there is an undefined for every type
01:06:20 <frerich> johnw: Rest assured, I'm a little insecure now myself. I always thought of "strict" or "not-strict" to be a property of how evaluating expressions work (I always think of how "f(a(x))" is evaluated - if it's 'a' first then 'f' it's struct, otherwize it's not strict). But now I realize that I always had 'lazy' and 'non-strict' as synonyms, hmm.
01:06:51 <johnw> yeah, right now I feel like shachaf is play word games with me
01:06:59 <quicksilver> he's not intending to
01:07:02 <shachaf> johnw: This is an important distinction.
01:07:05 <quicksilver> although I can understand why it feels that way
01:07:13 <quicksilver> it's a narrow but incredibly important distinction.
01:07:14 <johnw> I don't see what's being distinguished yet
01:07:25 <shachaf> "strict" means something slightly different from "forces its argument", which is a less important distinction.
01:07:33 <johnw> ok
01:07:39 <shachaf> (But still one you should know before you're done. :-) )
01:07:46 <quicksilver> well the feeling that "seq x x" must cause x to get forced right away is the kind of feeling  you get by misunderstanding it :)
01:07:53 <zaargy> wonder if anyone has this link handy - it's a page with haskell prog written by people of varying levels of skill
01:08:01 <quicksilver> the epiphany is when you realise that seq x x is exactly the same as x.
01:08:15 <randomclown> > (flip (!!)) 100000 $ scanl1 (+) [ 4.0 * (if even n then 1 else (-1)) / (2.0 * (fromIntegral n) + 1.0) | n <- [0..]]
01:08:17 <lambdabot>   3.1416026534897203
01:08:24 <randomclown> there we go now they are the same speed
01:08:24 <shachaf> zaargy: There was a joke page:
01:08:25 <danr> I just found out about this book "The Haskell Road to Logic, Maths and Programming" (http://homepages.cwi.nl/~jve/HR/), I wonder why it is never spoken about... Anyone here read it?
01:08:27 <shachaf> @where evolution
01:08:27 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
01:08:34 <quicksilver> You asked a page or two page "how can I guarantee that somethign is evaluated before I return from the function?"
01:08:36 <zaargy> thank you
01:08:39 <quicksilver> you can't.
01:08:41 <quicksilver> and that's important.
01:08:50 <quicksilver> also "before I return from the function" is hard to quantify
01:08:52 <zaargy> and yes i realise it was a joke page :)
01:09:07 <quicksilver> because the actual execution of the function is, in general, interleaved with the execution of the caller.
01:09:15 <randomclown> is there a better way to rewrite (if even n then 1 else (-1))?, the (-1)^n was killing the performance before
01:09:21 <shachaf> danr: I don't think it's a good introduction to Haskell. It might be a good introduction to logic.
01:09:22 <quicksilver> what you *can* do is ask that certain expressions get forced into WHNF before certain other expressions.
01:09:42 <danr> shachaf: yeah I realized I have the model theory book by the same author
01:09:56 <johnw> randomclown: ah, so it had nothing to do with scanl intermediates, interesting
01:10:21 <johnw> quicksilver: so I can sequence, but I can't demand
01:10:26 <quicksilver> johnw: yes.
01:10:27 <shachaf> randomclown: Take two lists in parallel: One is cycle [1,-1] and the other is [1,3,5,7,...]
01:10:39 <johnw> that does make some sense
01:10:40 <shachaf> randomclown: Zip them together and use their product as appropriate.
01:10:46 <quicksilver> johnw: you can say "if you ever try to force this value, I want to force this one first"
01:10:46 <shachaf> @quote monochrom pseq
01:10:46 <lambdabot> monochrom says: seq is a suggestion. pseq is an order.
01:10:54 <quicksilver> johnw: but you can't actually say "force this *right now*"
01:10:57 <quicksilver> except in the IO monad.
01:10:59 <quicksilver> (with evalute)
01:11:03 <randomclown> shachaf: I quited like the generating funtion notation though
01:11:08 <shachaf> quicksilver: Even in IO that's kind of meaningless.
01:11:15 <quicksilver> and that's at least somewhat because the IO monad actually *has* a meaning of *right now*.
01:11:18 <johnw> like if I'm mapping, I can say, "evaluate the first value before the second", instead of building a massive network of promises
01:11:18 <shachaf> quicksilver: You have to get to the point where "evaluate x" is being executed. :-)
01:11:22 <t7> will ghc realize that you dont need to remember the start of the list for that?
01:11:32 <quicksilver> shachaf: yes, and execution order gives you a notion of "now"
01:11:44 <quicksilver> shachaf: (because it relates to a sequence you can observe externally)
01:11:50 <johnw> ok, that makes a lot of sense
01:11:52 <shachaf> randomclown: Well, I think what I said is a nice way to generate your sequence.
01:11:55 <johnw> how does it connect to shachaf?
01:11:59 <shachaf> Exponentiation is going to do a repeated-square thing.
01:12:14 <randomclown> ghc should optimise (-1)^n
01:12:17 <quicksilver> johnw: you're always building a network of promises but you're allowed to tie your own shortcuts into that network :)
01:12:17 <randomclown> ahah
01:12:20 <quicksilver> (using seq)
01:12:28 <srhb> Time for stupid questions: Is first class modules what SML has and Haskell does not, and why do we want first class modules?
01:12:30 <shachaf> > [n * sign | n <- [1,3..] | sign <- cycle [1,-1]]
01:12:31 <lambdabot>   [1,-3,5,-7,9,-11,13,-15,17,-19,21,-23,25,-27,29,-31,33,-35,37,-39,41,-43,45...
01:12:39 <quicksilver> johnw: and you can rely on the RTS not to evaluate things twice (almost always) so those shortcuts will actually save work not duplicated it.
01:12:47 <quicksilver> frerich: ^^ and that's the difference between lazy and non-strict.
01:12:53 <johnw> and what was shachaf meaning about "strict"?
01:12:56 <quicksilver> frerich: (the lazy part is where it doesn't evaluate things twice)
01:13:08 <shachaf> "things" is kind of vague.
01:13:14 <quicksilver> johnw: a strict function "has a shortcut to its argument"
01:13:23 <shachaf> (5 + 5) + (5 + 5) will probably evaluate (5 + 5) twice.
01:13:24 <johnw> what does that mean?
01:13:32 <quicksilver> johnw: so it forces its argument at the same time you force the result.
01:13:45 <quicksilver> shachaf: "things" is quite precise, but I didn't explain what I meant by it :)
01:13:50 <johnw> hmm
01:14:00 <quicksilver> I hoped it would be intuitively clear from johnw's analogy of a 'network of promises'.
01:14:13 <quicksilver> the things are the bits of evaluation that those promises are promising.
01:15:05 <johnw> without any strictness -- as I understand it -- a program becomes a huge network of promises that start collapsing when main wants to discover the "return value" of the program
01:15:17 <shachaf> There's no such thing as "without any strictness"
01:15:29 <merijn> Now that we're speaking of forcing computation, etc. In a scenario where I have a bunch of worker threads communicating via channels, what's the best way to ensure all values written to the channel are completely forced?
01:15:47 <merijn> i.e. how do I avoid accidental sequentialisation by all thunks being forced in the last thread
01:15:48 <johnw> shachaf: why not?
01:16:14 <shachaf> merijn: evaluate x >> writeChan c x?
01:16:20 <shachaf> FSVO "completely"
01:16:59 <merijn> :t evaluate
01:17:00 <lambdabot> Not in scope: `evaluate'
01:17:16 <shachaf> merijn: Presumably (x `seq` writeChan c x) or something would work too.
01:17:20 <johnw> ohh
01:17:28 <johnw> "non-strictness means that an expression can have an answer even if some of its arguments have no answer"
01:17:29 <Enigmagic> merijn: you want rnf from deepseq
01:17:43 <johnw> *now* I see what you mean
01:17:53 <merijn> > True || undefined -- example
01:17:54 <lambdabot>   True
01:17:55 <shachaf> Oh, if you mean "normal-form" completely, yes.
01:18:04 <shachaf> > True || id undefined
01:18:05 <lambdabot>   True
01:18:18 <shachaf> > let x = undefined in True || (x `seq` x)
01:18:19 <lambdabot>   True
01:18:24 <shachaf> See how the "x `seq` x" doesn't matter?
01:18:37 <hirsch_> A fast question: simpleHTTP (getRequest "http://www.heise.de") >>= getResponseBody >>=  \x -> return (length . words $ x)
01:18:37 <shachaf> It's never getting to the point of evaluating the (seq x x) in the first place.
01:18:39 <johnw> in C++, you can't use a short-circuiting && where one of the values might not have an answer; you may not execute the code, but it has to have had an answer, right?
01:18:52 <shachaf> johnw: I don't think that's right.
01:19:03 <hirsch_> is there a way to write the last (return) without a lambda expression?
01:19:05 <merijn> Enigmagic, shachaf: Yeah, looks like I want deepseq, thanks!
01:19:12 <quicksilver> foo() && longjmp(blah);
01:19:14 <johnw> shachaf: I see where the seq doesn't matter
01:19:23 <quicksilver> if foo returns true, the longjmp is never executed.
01:19:24 <shachaf> if (foo && foo->bar == 5) { ... }
01:19:25 <merijn> hirsch_: You probably want fmap
01:19:28 <shachaf> Common idiom.
01:19:30 <Enigmagic> merijn: np
01:19:31 <quicksilver> but longjmps 'dont have a value'
01:19:42 <quicksilver> s/true/false/; oops.
01:19:54 <shachaf> hirsch_: That particular thing can be written as ... >>= (return . length . words)
01:20:05 <shachaf> hirsch_: But merijn is right that it's probably even better to use fmap.
01:20:13 <quicksilver> merijn: writeChan c $! x
01:20:17 <merijn> hirsch_: I'm assuming you're in IO, which happens to be a functor too, and fmap :: Functor f => (a -> b) -> f a -> f b
01:20:18 <johnw> quicksilver: I see, good example
01:20:26 <johnw> ok, so && is non-strict in C++ too then
01:20:26 <frerich> johnw: I think what's quite beautiful is that in C++, this short-circuit evaluation is built into the language for '&&' and '||'. In Haskell, you get it for free because of... uhm this is a slippery slope now... non-strictness?
01:20:36 <quicksilver> merijn: but that is only WHNF for x
01:20:49 <quicksilver> merijn: if you need more than WHNF then you might need deepseq as Enigmagic said.
01:20:59 <shachaf> && is indeed non-strict in its second argument in C++. They call it "short-circuiting".
01:21:01 <quicksilver> or if deepseq is too much you might need a custom 'Strategy'.
01:21:05 <hirsch_> mefisto`: "return . length .words " works
01:21:06 <shachaf> In Haskell everything is non-strict.
01:21:13 <shachaf> (By default, that is.)
01:21:26 <hirsch_> mefisto`: but fmap (length .words) not
01:21:36 <merijn> quicksilver: Yeah, I need deepseq (or rather, my haskell prototype needs it. Eventuall I'll be calling out to the FFI and writing the results from there to the Chan, so then strictness shouldn't work)
01:21:40 <johnw> so then, is lazy evaluation this: instead of determining the value for x when it is bound by let, the value for x is determined by the first evaluation of x, whose value is that shared by any other evaluation of x?
01:22:02 <johnw> s/is that/is then
01:22:13 <johnw> i.e., computed-on-demand-then-reused
01:22:26 <merijn> hirsch_: It would need to be something like "fmap (length . words) $ simpleHTTP (getRequest "http://www.heise.de") >>= getResponseBody"
01:22:55 <johnw> to continue with C++ analogies, a lazy x :: t would be a std::future<T> x
01:23:01 <hirsch_> merijn: I see, thanks
01:23:34 <shachaf> johnw: I don't recommend C++ analogies.
01:23:34 <merijn> Man, I need a (<$>) with fixity 0 so I can replace ($) :p
01:23:51 <johnw> shachaf: but it's where I come from, so it's how I think right now; I'm building bridges
01:23:52 <hirsch_> merijn: I was searching the first variant as it is more pileline style
01:24:05 <shachaf> johnw: You don't come from "the real world"?
01:24:06 <merijn> hirsch_: You could write a combinator like that yourself, if you want
01:24:12 <shachaf> That's a much better world to learn Haskell from than C++.
01:24:18 <johnw> I come from the inside of a C++ compiler
01:24:24 <shachaf> (Some C++ programmers forget about that world, though.)
01:24:32 <Jafet> Haskell sucks, it doesn't even have symmetric (&&)
01:24:37 <Jafet> > undefined && False
01:24:39 <lambdabot>   *Exception: Prelude.undefined
01:24:39 <shachaf> Jafet: It totally does!
01:24:44 <johnw> so, after all that, I know have no real idea of when I'd ever want to use seq
01:24:47 <Jafet> What chumps
01:24:52 <shachaf> Conal has one on Hackage, I think.
01:24:56 <shachaf> Or maybe someone else does.
01:24:59 <merijn> hirsch_: "(>>~) :: Functor f => f a -> (a -> b) -> f b; a >>~ b = fmap b a"
01:25:11 <johnw> I thought seq is for avoiding "massive networks of promises" in certain circumstances
01:25:14 <merijn> Actually
01:25:27 <merijn> "(>>~) = flip fmap"
01:26:04 <hirsch_> merijn: great, isn't that combinator somewhere defined (there are combinators for everything I suppose)
01:26:11 <johnw> this section is useful: http://users.aber.ac.uk/afc/stricthaskell.html#seq
01:26:23 <quicksilver> shachaf: although conal's symmetric && isn't haskell.
01:26:26 <merijn> hirsch_: It might be, I didn't check, you can search Google for the type signature
01:26:28 <shachaf> quicksilver: True.
01:26:35 <merijn> hirsch_: Errr...Hoogle, obviously
01:26:37 <johnw> for strict data types "if you need me, then I need all of my members"
01:26:38 <shachaf> johnw: Write a function "sum" and reason about how it gets evaluated.
01:26:46 <shachaf> sum :: [Int] -> Int
01:26:48 <johnw> not "you need only one of my members"
01:26:52 <shachaf> That'll explain why you want strictness.
01:26:53 <merijn> @hoogle Functor f => f a -> (a -> b) -> f b
01:26:54 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
01:26:54 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
01:26:54 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
01:27:06 <Jafet> quicksilver: glasgow haskell is haskell
01:27:07 <johnw> foldl' (+) 0 :)
01:27:12 <shachaf> Glaskell
01:27:19 <shachaf> johnw: OK, so you know about foldl'
01:27:22 <shachaf> Do you know what it does?
01:27:29 <johnw> not anymore!
01:27:31 <hirsch_> merijn: <**>
01:27:47 <shachaf> <**> is certainly not flip fmap
01:27:47 <srhb> Does anyone remember where the article on ContT and OpenGL callbacks lives? I can't seem to find it on Google.
01:28:01 <shachaf> @google contt opengl inversion of control
01:28:02 <lambdabot> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
01:28:11 <srhb> shachaf: Thank you!
01:28:21 <merijn> hirsch_: Not entirely, that has "f (a -> b)" as second argument, instead of "(a -> b)"
01:28:35 <hirsch_> right
01:28:45 <johnw> "both seq and ($!) evaluate their argument only enough to check that it is not bottom. If the argument is a list, this means it only has to check the first cons cell. If a complex datatype, it only has to check the topmost level, not the parts. So using seq and ($!) does not necessarily mean that anything will be fully evaluated."
01:29:07 <johnw> my house of cards has tumbled
01:29:17 <merijn> hirsch_: I'd just write your own combinator and maybe suggest on the mailing list to add a similar combinator, although I dunno whether people are interested in that
01:29:30 <johnw> what is the merit of checking that something is not bottom?
01:29:52 <merijn> It seems like an obvious combinator to have, but then again you don't want to have to ridiculously many operators
01:30:12 <shachaf> johnw: (+) :: Int -> Int -> Int
01:30:17 <shachaf> x + y = complicated
01:30:33 <shachaf> However, (+) is strict in both x and y, which means that _|_ + y = _|_, x + _|_ = _|_
01:30:38 <hirsch_> merijn: ...and find a complicated name for it and earn fame and honour, I think that would go too far.
01:30:53 <shachaf> When you check whether (x + y) is _|_, that means all of "complicated" needs to happen before you get your answer.
01:31:03 <shachaf> (Where "complicated" is a bunch of graph reduction or something.)
01:31:03 <Jafet> > reverse "<$>"
01:31:04 <lambdabot>   ">$<"
01:31:10 <Jafet> That would work
01:31:13 <johnw> (+1) $! (2 + 2) means that 2 + 2 will be computed before 1 is added, rather than returning a thunk representing ((2 + 2) + 1)?
01:31:16 <merijn> Jafet: xD
01:31:31 <merijn> Maybe >$>
01:32:09 <merijn> :t ($!)
01:32:10 <lambdabot> forall a b. (a -> b) -> a -> b
01:32:18 <johnw> shachaf: for xmas I should get you a ‚ä• key
01:32:20 <Jafet> :t let x >$< f = f <$> x in (>$<)
01:32:22 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
01:32:24 <c_wraith> johnw: be careful of "before" with $!.  it doesn't mean exactly "before", and the difference is sometimes relevant.  someone (maybe mauke?) had some examples of where it doesn't mean "before" in practice
01:32:44 <Jafet> "not after"
01:33:01 <johnw> c_wraith: I'll think I'll just admin now that I have no understanding of this whatsoever, and start over from the beginning with my friend, the Net
01:33:01 <shachaf> "before or equal to"
01:33:08 <shachaf> before
01:33:48 <shachaf> johnw: It helps to play really stupid and pretend you're a graph reduction machine.
01:33:50 <johnw> but $! does avoid a more complex thunk from being returned, yes?
01:33:56 <frerich> johnw: I think it's incredibly difficult to predict the runtime behaviour of Haskell programs if you're used to explaining things on the raw machine level (say: because you have a C++ mindset). The evaluation of the code you write works in such magical ways that it's really hard to understand the last 10% of it. You quickly have a grasp on the first 90% but the last part is where the odd ocrner cases come...
01:34:16 * frerich gave up all hope to understand it all and just hopes that he can get away with only bothering to understand 'seq' and the like if he hits problems.
01:34:18 <shachaf> What was that online evaluator that showed reduction step by step?
01:34:27 <johnw> frerich: yeah, I'm beginning to realize that my inner state machine is not valid here
01:34:39 <Jafet> stepeval isn't lazy, so its output is very confusing
01:34:49 <shachaf> frerich: All you're doing is telling people (a) how you don't understand things as well as you thought and (b) that what they're trying to learn is really hard. :-(
01:35:02 <shachaf> I don't think that helps anyone learn.
01:35:02 <Jafet> @where stepeval
01:35:02 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
01:35:09 <shachaf> Jafet: Oh.
01:35:12 <Jafet> Also it's not really maintained
01:35:13 <shachaf> It's not lazy?
01:35:33 <johnw> I'm sure that, like anything in Haskell, this will all seem very simple and clear, once I grasp the fundamental concepts thoroughly
01:35:54 <johnw> I'm lacking a properly rich understanding of strict, lazy, order, and evaluation, at this moment
01:36:08 <johnw> but I am unafraid
01:36:13 <c_wraith> johnw: well, the basic rules aren't complicated - but it's easy to slip up on an application of them.
01:36:13 <Jafet> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+f+x+%3D+x+%2B+x+in+f+%28f+%28f+0%29%29
01:36:14 <shachaf> Strict and non-strict are denotational. Lazy and "order" are operational.
01:36:30 <johnw> I'll save you some time now, shachaf, and return when I am ready to snatch some pebbles from your hand
01:36:48 <johnw> shachaf: that's helpful
01:37:03 <johnw> mu, and good night :)
01:37:16 <shachaf> johnw: If you don't -- hmm.
01:37:46 <merijn> FYI, the person who wrote the configure script that all Hackage projects with C code are copying was an idiot
01:37:53 <Jafet> If you want to be hip, you have to snatch go stones
01:38:55 <merijn> Somehow whoever wrote that decided to check $PATH for a file named "configure" and uses *that* as the location for the cabal package (and thus as the location to look for C sources)
01:39:26 <merijn> If, somehow, you happen to have a filed named configure in your path this will result in all cabal packages with C code failing to configure, build and install...
01:39:33 <Jafet> /usr/bin/configure?
01:39:36 * merijn <- rage
01:40:03 <merijn> Jafet: No, I have one from a C project that's in my path since there's some executable in the build dir that I need in my path
01:40:23 <AfC> merijn: why on earth are they running `configure` and not `./configure`? Wow
01:42:53 <merijn> AfC: They're not, but the configure script uses "ac_confdir=`$as_dirname -- "$as_myself"" to find out where it is
01:43:06 <merijn> Of course, $as_myself is just configure
01:43:32 <Jafet> I thought autoconf writes that
01:44:05 <merijn> Maybe, but autoconf scripts from other projects
01:44:09 <merijn> +work
01:44:23 <merijn> So then cabal is calling ./configure wrong, or something
01:46:52 <merijn> cabal calls "sh configure" apparently >.>
01:47:31 <startling> u.u
01:48:07 <merijn> And the autoconf script scans your path if the name of the running file doesn't include a directory separator
01:48:20 <AfC> gah
01:48:21 <merijn> And only defaults to the current dir if no configure is found in the path
01:48:33 <yitz> merijn: here's where to file your bug report: http://hackage.haskell.org/trac/hackage/
01:49:00 <yitz> merijn: i agree, that sounds like a nasty one.
01:49:14 <merijn> yitz: Isn't there a repo somewhere? Should be trivial to patch
01:49:27 <yitz> merijn: i believe so
01:49:29 <ivanm> yitz: if that's for Cabal bugs, they're on github now
01:49:40 <ivanm> (both Cabal and cabal-install)
01:53:06 <yitz> ivanm: hmm that's what the hackage page says. it does look fairly up-to-date. the darcs repo is one version ahead of what's on hackage. perhaps there's some mirroring going on one way or the other.
01:53:15 <ivanm> could be
01:53:28 <ivanm> but my understanding is that github is the "official" location nowadays
01:53:46 <ivanm> and dcoutts asked me to file a bug there rather than a trac instance
01:53:55 <yitz> ah yes: "The bug tracker has moved to Github. The trac-based bug tracker is preserved for reference, but should not be used."
01:54:09 <yitz> no link to github though :(
01:54:21 <ivanm> github.com/haskell/cabal IIRC
01:54:40 <yitz> and they really ought to say that in the main places people will look: the hackage page, and the main trac page.
01:55:19 <yitz> ok merijn please file it there then. :) sounds important.
01:55:21 <ivanm> yup
01:57:52 <yitz> merijn: this is kind of a XSS vulnerabity, of sorts.
01:58:20 <merijn> Well, it'll mostly just fail on missing C files
01:58:31 <merijn> Because it's picking the wrong working dir
01:58:46 <merijn> Patching it should be a two character change, though
01:59:27 <yitz> merijn: i would be happy to supply you with a "configure" which, when placed in your path, will do many more much more interesting things next time you try to install a haskell package that happens to use ffi.
02:00:21 <merijn> It's not actually calling the one in my path
02:00:35 <merijn> It's calling the right one, but it's finding the wrong path for itself
02:01:02 <yitz> i see. well, anyway, nice bug, well spotted.
02:01:59 <merijn> "Well spotted" more like "spent 3 days trying to figure out why Yesod refused to install due to a missing unix-time package"
02:03:45 <quicksilver> Jafet: unsafe perform IO wouldn't be haskell even if it had the support of every major conurbation in scotland.
02:04:58 <merijn> Hmm, 58 files mentioning the word "configure" in cabal/cabal-install >.>
02:11:00 <merijn> Will running "cabal install" in my fresh cabal checkout horribly break my entire Haskell setup?
02:17:26 <Z`> I wrote: quicksort (x:xs) = quicksort [y | y <- xs, y<x ] ++ [x] ++ quicksort [y | y <- xs, y>=x]
02:17:33 <Z`> I then called it on [1..1000000]
02:17:51 <Z`> a couple of minutes have passed and it hasn't completed yet
02:18:00 <Z`> why is it slow and how could I speed it up ?
02:18:18 <tbreisacher> Z` just rename it to "quick"sort :)
02:18:19 <zomg> just rename it to slowsort
02:18:22 <zomg> lol
02:18:30 <Z`> haha
02:18:38 <Z`> ok.. :) what am I doing wrong ?
02:18:44 <zomg> Yeah sorry no idea why it's slow, but perhaps someone else might have
02:18:44 <merijn> Z': Because, cool as it looks that's not actually quicksort
02:19:02 <merijn> And it's going to be horribly slow for lists of any significant length
02:19:06 <tbreisacher> well for one thing, you have two list comprehensions which means you're probably going through the whole list twice
02:19:34 <startling> *twice for each iteration
02:19:35 <merijn> tbreisacher: More than twice, since he's doing that recursively
02:19:45 <tbreisacher> right
02:20:15 <tbreisacher> @hoogle [a] -> (a -> Bool) -> ([a], [a])
02:20:15 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
02:20:15 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
02:20:15 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
02:20:17 <Z`> alright, so one problem is the list traversal due to the comprehension
02:20:27 <Z`> and then it's recursion which magnifies the latter
02:20:34 <DrTeggy> Z', if the list head is your pivot and your input list is sorted, you hit the worst case scenario for QuickSort
02:20:54 <shachaf> Z`: It's slow because it's a terrible sorting algorithm.
02:21:04 <shachaf> (By "terrible" I mean slow, naturally.)
02:21:17 <tbreisacher> but cleverly designed to look like quicksort!
02:21:30 <merijn> DrTeggy: That's not quicksort, it just looks like quicksort
02:21:32 <Z`> it looked so beautiful. too bad it's so slow
02:22:09 <Z`> AFAIK the C's quicksort doesn't recurse. It does the swap in-place
02:22:18 <merijn> Z`: Data.List source uses mergesort and has some comments discussing the mergesort implementation compared to the previous qsort implementation that used to be there
02:22:22 <merijn> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sort
02:22:34 <shachaf> Writing quicksort recursively is perfectly reasonable and has nothing to do with swapping.
02:22:41 <tbreisacher> i think quicksort has to recurse, by definition
02:22:43 <shachaf> Quicksort isn't really an "in-place" sort, though.
02:23:00 <danr> Z`: oh... it is still O(log n) space, you need either a stack or one recursive call. it has nothing to do with the in-placeness of the swapping (but regarded by most, it should be inplace to be real quicksort)
02:23:04 <lpvb> Z`: have you tried not running it in ghci?
02:23:40 <danr> shachaf: oho, what makes you say so?
02:24:06 <shachaf> danr: It uses extra (non-constant) space.
02:24:20 <Z`> lpvb: I have compiled it with ghc
02:24:25 <srhb> So.. The concept of multiplayer games in Haskell over the network. I thought I'd write Pong, but I'm not sure how to attack the problem. I've never really written anything multiplayer, but I guess the main complexity is keeping things in sync?
02:24:41 <merijn> srhb: Yes, hold on, I've got the thing for you
02:24:46 <danr> shachaf: I would say that it gets away with it by just using log n stack space... but maybe I'm wrong
02:25:20 <danr> right. the first line of wikipedia says an in-place algorithm should use small, constant ammount of extra storage
02:25:29 <merijn> srhb: http://www.fabiensanglard.net/quake3/index.php
02:25:38 <danr> shachaf: ty
02:25:43 <srhb> merijn: Thanks. :)
02:25:45 <merijn> srhb: Discussion of the Quake 3 (and everything before then linked there too) sources
02:25:56 <merijn> srhb: Including discussions on the implementation of networking, etc
02:26:09 <srhb> merijn: Sounds good, I'll head straight to the networking bit :-)
02:27:37 <merijn> Anyhoo, back to my earlier question: Will running "cabal install" in a fresh cabal checkout horribly break my current haskell install?
02:36:18 <singleton> infixl 0 |$
02:36:21 <singleton> ( |$ ) :: (a -> b) -> a -> b
02:36:29 <singleton> f |$ x = f x
02:36:31 <ivanm> merijn: depends on the deps it needs
02:36:43 <ivanm> but that should just install the new version of Cabal
02:36:46 <shachaf> singleton: People have made the argument that $ should be that.
02:37:01 <quicksilver> aren't cabal versions tightly tied to GHC versions?
02:38:17 <ivanm> quicksilver: no
02:38:25 <ivanm> Cabal is the only library that comes with GHC that you can safely upgrade
02:38:30 <ivanm> you can't _downgrade_ it
02:38:38 <ivanm> and you can't unregister the one that comes with GHC
02:38:46 <quicksilver> ah, good to know.
02:40:44 <singleton> shachaf: yes, but ($) has right associativity. this "(\x y z -> x + z + y) $ 8 $ 4 $ 1" raise err, but "(\x y z -> x + z + y) |$ 8 |$ 4 |$ 1" return 13))
02:41:03 <shachaf> singleton: Right.
02:41:18 <shachaf> singleton: That's why I said "People have made the arguemnt that $ should be that" instead of "$ is that". :-)
02:42:40 <quicksilver> I was quite convinced of that argument ($ should be left-assoc) for a while.
02:44:16 <shachaf> I'm quite convinced by arguments for both sides.
02:44:44 <atriq> I suggest another $-like combinator
02:44:53 <atriq> Perhaps Ä or £
02:47:36 <danr> maybe the currency sign? http://en.wikipedia.org/wiki/Currency_%28typography%29
02:48:03 <danr> It actually appears on swedish keyboards, but I have no idea why and it's never used
02:48:06 <adnam> don't have that on may keymap anymore :(
02:48:21 <adnam> i would approve of ¬ß :]
02:49:07 * hackagebot test-framework-quickcheck2 0.2.12.3 - QuickCheck2 support for the test-framework package.  http://hackage.haskell.org/package/test-framework-quickcheck2-0.2.12.3 (MaxBolingbroke)
02:49:13 <singleton> symbols  "¬£" & "¬ß" isn't on my keyboard, for example. Sorry for my English, I don't understand completely.
02:49:26 <singleton> aren't*
02:50:22 <atriq> I was partially joking by suggesting Ä and £. I'm pretty sure neither are on US keyboards, where I imagine a significant chunk of Haskell programmers live.
02:50:31 <srhb> Mkay, realtime multiplayer networking is beyond me. :-)
02:50:48 <srhb> Sad that the gap between turn-based and real-time is so large :-)
02:50:51 <atriq> That's a good thing to be beyond you
02:50:59 <atriq> Parsers seem beyond me
02:51:42 <srhb> atriq: What kind of parsers?
02:51:54 <atriq> In general
02:52:08 <atriq> I'm trying to use Parsec, but I'm just writing
02:52:19 <atriq> I have no idea if it will work, or do what I want, or what
02:52:39 <atriq> I think all I need is persistence and practise, though
02:54:28 <srhb> I usually make a little test function so I can parse test snippets.
02:54:37 <srhb> But I don't know if that applies in your case. :-)
02:54:58 <srhb> test = parse myParser "faketitle" -- or something like that
02:55:14 <atriq> I haven't got far enough to do that yet
02:55:47 <tdammers> atriq: you can do that for quite small parsers, really
02:56:17 <atriq> What I've got right now probably won't compile
02:56:29 <srhb> > parse (many . oneOf $ "ab") "blah" "abababbaabcccab"
02:56:31 <lambdabot>   Not in scope: `parse'Not in scope: `oneOf'
02:56:33 <srhb> Aw, no parse.
02:57:09 <srhb> atriq: I tend to code in very small bits that all compile, and stop if it does not compile. Easier to fix it then. :-)
02:57:45 <atriq> I'm more of a fan of big bits, but that's because I'm evil and hate myself
02:57:56 <srhb> Yes, it does sound masochistic. :-)
02:58:28 <tdammers> yeah, I usually compile every three minutes or some such
02:58:51 <yitz> ivanm: every time i tried upgrading Cabal it broke my entire package system and I ended up re-installing GHC.
02:59:05 <atriq> srcerer, this is the kind of program I write when I'm bored: http://hpaste.org/raw/71201
02:59:06 <ivanm> yitz: :o
02:59:09 <ivanm> never had that problem
02:59:19 <yitz> ivanm: are you saying that's all fixed now and people can just upgrade it without worries?
02:59:29 <ivanm> when was the last time you tried this?
02:59:47 <ivanm> the only time i had issues was when Gentoo's packages used to accidentally uninstall the version of Cabal that shipped with GHC
02:59:59 <yitz> ivanm: i don't understand why not. it happened to me immediately and catastrophically every time i tried it. admittedly, i haven't tried in a long time, for obvious reasons.
03:00:11 <ivanm> *nod*
03:01:09 <yitz> ivanm: truth is, for quite a while i have never issued more than two cabal commands after any ghc/HP install: cabal update and cabal install cabal-dev.
03:01:17 <yitz> ivanm: after that, only cabal-dev.
03:01:33 <yitz> ivanm: it has made life much sweeter for me.
03:02:11 <ivanm> *shrug* never even installed cabal-dev
03:03:02 <yitz> ivanm: well soon sandboxing will be in cabal itself, so you won't avoid it anymore by not installing cabal-dev. ;)
03:03:24 <ivanm> heh
03:05:12 <atriq> s/srcerer/srhb/
03:05:24 <yitz> atriq: don't think you are going to trick us into running *that*
03:05:42 <atriq> yitz, it's fine if you don't give it an number above 11
03:05:50 <atriq> Of course, 9, 10, and 11 run for age
03:05:51 <atriq> s
03:06:04 <atriq> Negative numbers cause a segfault, I think
03:06:36 <yitz> atriq: prime numbers cause a trojan to be installed, i suppose
03:06:43 <atriq> Run it with 7 and find out!
03:06:55 <atriq> (it's actually a factorial calculator)
03:07:17 * yitz holds his hand away from the keyboard with all his might
03:18:17 <atriq> yitz, I'm not sure if it's possible to make a trojan in that length where most of the program amounts to SKI calculus
03:32:47 <Deewiant> > let f (a:as) (b:bs) = a : b : f as bs; f as [] = as; f _ bs = bs in f [1..3] [4..8] -- is this function still not in any library?
03:32:48 <lambdabot>   [1,4,2,5,3,6,7,8]
03:35:15 <mm_freak> > transpose [1..3] [4..8]
03:35:16 <lambdabot>   Couldn't match expected type `[t1] -> t'
03:35:16 <lambdabot>         against inferred type `[[a...
03:35:23 <mm_freak> > transpose [[1..3], [4..8]]
03:35:24 <lambdabot>   [[1,4],[2,5],[3,6],[7],[8]]
03:35:34 <mm_freak> > (concat . transpose) [[1..3], [4..8]]
03:35:36 <lambdabot>   [1,4,2,5,3,6,7,8]
03:36:34 <mm_freak> > (concat . transpose) [[4..8], [1..3]]
03:36:36 <lambdabot>   [4,1,5,2,6,3,7,8]
03:36:42 <mm_freak> @ Deewiant
03:37:17 <Deewiant> mm_freak: Thanks
03:37:31 <mikeplus64> (but (unless concat . transpose is somehow fused together) your version might be more efficient)
03:38:05 <mm_freak> the performance difference will be negligible even if no deforestation occurs
03:38:06 <Deewiant> Yes, but I don't care about that now.
03:41:14 <merijn> Does anyone know who I can bug in here to merge my cabal bugfix?
03:51:17 <ivanm> merijn: dcoutts
03:51:39 <merijn> And byorgey/chrisdone according to github :p
03:52:39 <merijn> And now that I've subtly pinged all of them we just wait for the first to get attracted to IRC ^.^
03:52:43 <ivanm> merijn: byorgey was asking dcoutts the other day about what he's allowed to do; dcoutts said something like simple fixes, etc.
03:53:00 <ivanm> I believe that dcoutts would be the one applying any large patches
03:53:10 <merijn> ivanm: tbh I don't think there's a fix simpler than this :p
03:53:23 <merijn> I literally inserted two characters
03:53:43 <ivanm> merijn: does it work on Windows like that?
03:55:35 <merijn> Good question, probably it will since it call "sh" and configure and both'd require some form of posix emulation that should accept ./ too
03:55:55 <merijn> I don't have a windows box to test, though
03:56:12 <merijn> If someone here feels compelled to test in the name of open source feel free :p
03:56:13 <ivanm> so, it might not be that easy a patch to apply!
03:56:42 <merijn> Sure, just #ifdef the thing depending on whether it's windows or not </ghetto dev>
03:57:23 <Botje> let's add an autoconf test for it! </better ghetto-dev>
03:57:40 <merijn> Botje: The fix was for autoconf, ironically
03:57:58 <merijn> So that'd be counter productive :p
04:27:37 <srhb> Is it hacky to do gluOrtho2D 0 xsize 0 ysize? Seems easier to control.
04:29:02 <watermind> I thought "normal order evaluation" and "call-by-name" were the same (and likewise for "applicative order" and "call-by-value"), but apparently they're not
04:29:20 <Botje> srhb: not at all, if you want to do 2d :)
04:29:52 <watermind> but I was trying to find out the difference and cannot find it described anywhere
04:29:58 <watermind> do you have any references for me?
04:30:11 <srhb> Botje: Yes, exactly. OpenGL is weird. :-) Thank you
04:30:17 <watermind> or maybe an example that illustrates it?
04:31:11 <watermind> wikipedia says it is that call-by-name doesn't perform evaluations in the body of unapplied functions while normal order may
04:32:17 <watermind> but it seems strange that normal order may perform more evaluations since this eval strategy is supposed to be terminating and defined whenever possible
04:32:29 <watermind> and extra evaluations could mean more undefined cases
04:37:01 <Jafet> The usual example is double x = x + x: in applicative order double (double 1) = double 2; in normal order double (double 1) = double 1 + double 1
04:40:23 <jaxtr> ahh it's a wonderful day
04:40:34 <Jafet> Call-by-name is some weird thing from ALGOL, which is not a pure language
04:41:08 <quicksilver> I think that some writers do not use "call-by-name" in a very precise sense.
04:41:22 <quicksilver> but in principle the distinction between what haskell does, and pure call-by-name, is work duplication.
04:41:37 <quicksilver> in Jafet's expansion double (double 1) ==> double 1 + double 1
04:41:40 <Jafet> In Haskell, call-by-name would just be normal order evaluation
04:41:45 <quicksilver> it 'looks like' double 1 will get called twice
04:41:48 <Jafet> Because it doesn't have side effects
04:42:00 <quicksilver> in Haskell, double 1 will only get called once, and teh result shared between those two subexpressions.
04:42:07 <quicksilver> this strategy is sometimes called "call-by-need"
04:42:42 <quicksilver> "normal order" being a semantic notion, for a pure language, doesn't specify if results are shared.
04:42:53 <watermind> Jafet: yes but that looks like call by name and call by value
04:43:17 <watermind> Jafet: my doubt is about difference between normal order and call by name
04:43:37 <watermind> Jafet: and likewise between applicative order and call by value
04:43:48 <Eduard_Munteanu> It's not a semantic distinction though, just as non-strict semantics don't require things to be or not to be evaluated.
04:44:22 <watermind> haskell as far as I know is call-by-need, not normal order nor call-by-name
04:44:25 <Eduard_Munteanu> I mean, speculative evaluation could very well fit there for example.
04:44:27 <quicksilver> in fact the sharing I allude to above isn't technically part of the haskell spec.
04:44:40 <watermind> yeap... true
04:44:42 <quicksilver> but on the other hand, haskell is described as 'lazy' and lazy means sharing.
04:44:53 <quicksilver> and some parts of the haskell spec imply sharing.
04:44:55 <watermind> I think haskell is called non-strict actually
04:45:00 <watermind> not lazy
04:45:07 <watermind> lazy is the usual implementation
04:45:13 <watermind> but the language is simply non strict
04:45:13 <quicksilver> watermind: haskell is call-by-need but it is *also* true that it's normal order.
04:45:43 <linduxed> if i get asked the following: "how can you consider functions in haskell "pure" if you can mix in actions coming from "impure" monads like the IO monad? doesn't the involvement of function from the impure monads "contaminate" the otherwise surrounding pure functions?" how could i answer that?
04:45:59 <merijn> linduxed: IO monad is pure
04:46:09 <watermind> quicksilver: maybe you're right... since I still don't know what normal order is exactly...
04:46:12 <merijn> linduxed: The fact that the *implementation* is impure is irrelevant
04:46:36 <watermind> quicksilver: but some sources refer call-by-name is not normal order
04:46:37 <Eduard_Munteanu> linduxed: also, consider IO actions as recipes for IO.
04:46:56 <watermind> quicksilver: so if that is true I find it surprising that call-by-need would be
04:47:01 <quicksilver> watermind: laziness is mentioned several times in the haskell report.
04:47:05 <merijn> linduxed: "getLine :: IO String" is a perfectly pure value, it returns the same thing every time
04:47:10 <watermind> quicksilver: let me check
04:47:10 <quicksilver> but it's true that people aren't consistent.
04:47:13 <Jafet> watermind: call-by-name is where you have something like: double (read getLine)
04:47:19 <Jafet> Which doesn't work in haskell
04:47:30 <Eduard_Munteanu> Why would it matter whether it's call-by-name or call-by-need, really?
04:47:49 <Eduard_Munteanu> The semantics are pretty much the same.
04:47:52 <quicksilver> some of the distinctions between call-by-foo are invisible if there are no side-effects.
04:48:01 <quicksilver> however not all of the distinctions are invisible
04:48:05 <merijn> linduxed: i.e. it returns an IO action, that when evaluated will read a String. But it returns the *same* IO action every time, evaluating said action multiple times will give different results, but that's not relevant from a Haskell perspective
04:48:28 <Jafet> http://en.wikipedia.org/wiki/Jensen%27s_Device
04:48:34 <linduxed> merijn: oh i see
04:48:43 <watermind> quicksilver: http://www.haskell.org/haskellwiki/Lazy_vs._non-strict     "Haskell is often described as a lazy language. However, the language specification simply states that Haskell is non-strict, which is not quite the same thing as lazy. "
04:49:06 <linduxed> merijn: so there's a distinction between what that IO action itself returns, and what actual action is done?
04:49:15 <merijn> linduxed: Yes
04:49:18 <quicksilver> watermind: right. But as I said "laziness is mentioned several times in the haskell report"/.
04:49:30 <quicksilver> watermind: I didn't say "the haskell report states that Haskell is lazy"
04:49:34 <quicksilver> indeed it odesn't.
04:49:40 <quicksilver> but it does mention laziness several times.
04:49:47 <quicksilver> and this ambiguity of terminology of widespread.
04:49:50 <merijn> linduxed: For example "print" is pure, because "print "test"" will always return the same thing (an action that will print "test\n"), no matter how many different times you evaluate print
04:50:02 <watermind> quicksilver: right
04:50:02 <quicksilver> you will found countless sources which describe haskell as a "lazy functional programming language"
04:50:18 <merijn> linduxed: Of course, *executing* the resulting action is the only to make it actually print
04:50:25 <Jafet> That's because Haskell is Glasgow Haskell.
04:50:40 <quicksilver> :)
04:51:38 <merijn> linduxed: The biggest problem many people have (seeing the difference between returning a first class IO-action and *running* an IO-action) is what gets people confused about haskell's purity
04:52:13 <zomg> merijn: most people are confused with passing functions in languages which allow that too =)
04:52:24 <zomg> without executing it that is
04:52:34 <merijn> linduxed: You can think of main being one big IO action being fed to a giant interpreter to produce a result.
04:53:21 <watermind> I actually think the most complicated thing about haskell is lazyness (not strictness... whatever :P )
04:53:28 <watermind> s/not/non
04:53:57 <merijn> linduxed: A slightly complexer example would be "getLine >>= print", this doesn't read a line and then print it. It combines an IO action that reads a line and an IO action that prints a String into a composite IO action that reads a line and prints it.
04:54:11 <merijn> Still perfectly pure
04:54:34 <nand`> @quote /bin/ls
04:54:34 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
04:54:47 <merijn> No matter how many times you evaluate "getLine >>= print" the result is always the same action
04:54:55 <watermind> taking advantage of lazyness to construct your algorithms in a modular way requires quite a change in the way you think about programs
04:54:56 <nand`> passing around getLine is like passing around /bin/ls
04:54:59 <merijn> I <3 that quote
04:55:00 <nand`> you aren't running it
04:55:01 <nand`> just passing it around
04:55:50 <watermind> not to mention reasoning about space and time efficiency of the final result
05:01:04 <linduxed> merijn: so the purity pertains more to the types passed around, not what they return?
05:03:35 <linduxed> because... hmmm
05:04:18 <merijn> linduxed: No, purity pertains to values
05:04:28 <merijn> linduxed: It's just that haskell has no notion of executing
05:04:29 <quicksilver> linduxed: purity means, that if you have a function 'a -> '
05:04:36 <quicksilver> 'a -> b'
05:04:43 <quicksilver> then for the same 'a' it always returns the same 'b'
05:04:48 <merijn> linduxed: The *runtime* has a notion of execution, but that is seperate from the language
05:04:50 <quicksilver> this means it is a "pure function" or pure for short.
05:04:51 <linduxed> merijn: OOOOH
05:04:55 <Jeanne-Kamikaze> + it has no side effects
05:04:57 <linduxed> merijn: that's a good way of putting it
05:05:06 <linduxed> merijn: separating the execution from the caode
05:05:09 <linduxed> *code
05:05:12 <quicksilver> Jeanne-Kamikaze: yes, and it has no other observable effects at all beyond computing b.
05:05:15 <linduxed> merijn: that makes me understand better
05:05:36 <merijn> linduxed: Yes, essentially your pure program constructs an impure executable
05:05:37 <quicksilver> by extention a 'pure value' (function or otherwise) is one which when you evaluate it you get no other effects beyond evaluation
05:05:41 <quicksilver> and you'll always get the same answer.
05:06:00 <merijn> linduxed: See also quicksilver's explanation of purity
05:06:43 <Jeanne-Kamikaze> ok, but you need both conditions to be satisfied
05:08:02 <quicksilver> Jeanne-Kamikaze: yes indeed
05:08:47 <linduxed> merijn: quicksilver: also a good illustration
05:09:10 * hackagebot perdure 0.1.0 - Robust persistence for acyclic immutable data  http://hackage.haskell.org/package/perdure-0.1.0 (PatrickPremont)
05:17:43 <atriq> I've got something of type "Kleisli (StateT Int (MaybeT IO)) a a". Any idea how to loop it?
05:17:52 <atriq> Wait
05:17:56 <atriq> Recursion
05:17:59 <atriq> Of course!
05:20:09 <hpc> atriq: recursion is always the answer
05:20:22 <atriq> I can just use fix (step >>>), I think
05:27:24 <loreints`> is Maybe a monad?
05:27:31 <hpc> yes
05:27:42 <hpc> it's a pretty simple one
05:27:52 <atriq> One of the simplest non-trivial ones
05:27:55 <merijn> I would argue the simplest non-trivial
05:29:37 <atriq> Is it evil to use "foldl (\n c -> digitToInt c + 10 * n) 0" to parse an integer?
05:29:56 <atriq> When I know there's no non-numeric characters
05:30:13 <Yuu-chan> atriq: then you can use read :: String -> Integer
05:30:16 <hpc> ^
05:30:55 <atriq> I thought read was frowned upon?
05:31:01 <mm_freak> Maybe is the simplest nontrivial sum
05:31:12 <merijn> atriq: Not more so then what you just wrote :p
05:31:17 <mm_freak> Reader the simplest nontrivial product
05:31:18 <atriq> Okay, heh
05:31:32 <merijn> You could also use reads to be safe
05:31:37 <mm_freak> or Unit if you will
05:31:46 * merijn can't wait for readMaybe to make it into HP
05:32:22 <atriq> merijn, the only way that it could fail is if Parsec is deeply flawed and lying to me
05:36:40 <atriq> Is MaybeT short-circuiting?
05:36:54 <mm_freak> the Monad instance is
05:37:05 <mm_freak> and the Applicative instance
05:37:32 <Yuu-chan> @hoogle Bool -> a -> Maybe a
05:37:32 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
05:37:33 <lambdabot> Control.Exception assert :: Bool -> a -> a
05:37:33 <lambdabot> Control.OldException assert :: Bool -> a -> a
05:37:41 <atriq> Okay
05:37:45 <mm_freak> look at the type:  newtype MaybeT m a = MaybeT (m (Maybe a))
05:37:56 <mm_freak> it's a computation in 'm' that results in a 'Maybe a'
05:38:24 <mm_freak> MaybeT by itself is really just that‚Ä¶  it's Applicative/Monad that does interpret the result and performs short-circuiting
05:38:54 <Yuu-chan> :t unfold
05:38:55 <lambdabot> Not in scope: `unfold'
05:39:01 <Yuu-chan> @hoogle unfold
05:39:01 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
05:39:01 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
05:39:01 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
05:39:33 <atriq> I'm using  fix (f >>>) where f :: Kleisli (StateT Int (MaybeT IO)) a a, and I'm wondering if that will halt on mzero
05:39:55 <atriq> It is a MonadPlus, and the instance comes from the MaybeT
05:40:17 <mm_freak> yes, it will
05:40:38 <atriq> Okay, brilliant, that means I'm being stupid somewhere else
05:40:39 <atriq> Thanks!
05:40:41 <mm_freak> but it's really an ugly monad stack
05:40:50 <atriq> It's precisely what I need
05:40:57 <mm_freak> consider building your own free monad
05:41:42 <mm_freak> newtype MyFunctor a = MyFunctor (Int -> IO (Maybe (a, Int))) deriving Functor
05:41:49 <mm_freak> type MyMonad = Free MyFunctor
05:42:01 <mm_freak> also see (>=>)
05:42:03 <mm_freak> :t (>=>)
05:42:04 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:42:08 <mm_freak> :t fix (>=>)
05:42:09 <lambdabot>     Occurs check: cannot construct the infinite type:
05:42:09 <lambdabot>       m = (->) (b -> m c)
05:42:09 <lambdabot>     Probable cause: `>=>' is applied to too few arguments
05:42:17 <mm_freak> :t \f -> fix (f >=>)
05:42:18 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
05:59:11 * hackagebot perdure 0.1.1 - Robust persistence for acyclic immutable data  http://hackage.haskell.org/package/perdure-0.1.1 (PatrickPremont)
06:01:29 <Valodim> hey guys. what's an efficient way to sequentially read tons of word64 from a file?
06:03:38 <nand`> I'd guess something like the Get monad
06:03:57 <nand`> replicateM lotsandlots getWord64Le or something
06:06:46 <Valodim> ah, replicateM. yeah that might work
06:08:00 <nand`> (I have no idea about the efficiency of that, mind)
06:14:11 * hackagebot alms 0.6.5 - a practical affine language  http://hackage.haskell.org/package/alms-0.6.5 (JesseTov)
06:14:14 * hackagebot ghc-vis 0.1 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.1 (DennisFelsing)
06:16:42 <frerich> Ha! ghc-vis looks cool.
06:17:22 <loreints`> I'm having a lot trouble trying to figure out how to turn a function that checks for a Word8 being a specific char into checking for a string, and I have no clue how.
06:17:24 <loreints`> http://hpaste.org/73937
06:18:19 <loreints`> I think I want to write a function that chains a bunch of Word8 checking functions together for each char in the string, but I'm not sure
06:19:20 <mm_freak> loreints`: not sure what you want, but would the function 'all' help?
06:19:30 <mm_freak> > all even [2, 4, 6, 8]
06:19:31 <lambdabot>   True
06:19:33 <mm_freak> > all even [2, 4, 6, 9]
06:19:34 <lambdabot>   False
06:19:59 <allsystemsarego> > any odd [2,4,6,8]
06:20:00 <lambdabot>   False
06:20:09 <Automorphism> any even [1,4...]
06:20:18 <Valodim> haha
06:20:20 <Automorphism> > any even [1,4..]
06:20:22 <lambdabot>   True
06:20:38 <Automorphism> I accidentally let a third . in.
06:21:36 <DrTeggy> Dear all, is there a GHC option that forces the compiler to accept any extension for Haskell source files (not just the default '.hs' / '.lhs')?
06:22:09 <DrTeggy> Like, ghc -<some-option-here> source.foo
06:22:38 <loreints`> mm_freak: I don't think so, because each call needs to modify the parser state to look at the next byte
06:22:47 <mm_freak> DrTeggy: normally you would use cabal to build your projects
06:22:51 <loreints`> I have no clue if that's true, but that's my intuition atm
06:23:12 <mm_freak> DrTeggy: that one allows you to turn on extensions and pass command line flags for the entire compilation process and a few other nice things
06:23:39 <mm_freak> loreints`: so what you want is 'many'?
06:23:42 <DrTeggy> mm_freak, yes, but this relates to automatic compilation as initiated by an editor (Chocolat.app, in this case)
06:23:50 <DrTeggy> mm_freak, but thanks anyway!
06:23:54 <mm_freak> DrTeggy: sure
06:24:05 <mm_freak> if your editor can call makefiles, it can also call cabal =)
06:24:08 <carpi> Something to be worried about ?
06:24:11 <hpaste> carpi pasted ‚Äúpanic‚Äù at http://hpaste.org/73938
06:24:32 <DrTeggy> mm_freak, I think I was not very clear here
06:24:36 <mm_freak> carpi: yes
06:24:49 <DrTeggy> mm_freak, I am not referring to language extension but to *filename extension*
06:24:56 <loreints`> mm_freak: uh... many?
06:25:16 <loreints`> haskellwiki is empty for that: http://www.haskell.org/haskellwiki/index.php?title=&search=many&go=Go
06:25:33 <mm_freak> DrTeggy: oh, now i get it‚Ä¶  the main module can have any name you want, but i'm afraid the others will have to be named as .hs or .lhs
06:25:48 <carpi> so should i report it as bug
06:25:52 <mm_freak> loreints`: see Parsec's 'many' combinator
06:26:12 <mm_freak> carpi: first check if it still panics in GHC 7.4.2
06:27:08 <kstt> hey, I just experienced that :  cabal update - Downloading the latest package list from hackage.haskell.org - Segmentation fault
06:27:08 <kstt>  
06:27:26 <DrTeggy> mm_freak, I hoped so but it doesn't look like it.
06:27:27 <DrTeggy> > ghc source.foo
06:27:28 <DrTeggy> ld: warning: ignoring file source.foo, file was built for unsupported file format
06:27:29 <lambdabot>   Not in scope: `ghc'Not in scope: `source'Not in scope: `foo'
06:27:40 <DrTeggy> (Woops, sorry, lambdabot)
06:27:53 <mm_freak> DrTeggy: i think there is a flag that lets you choose the file type, but i'm not sure‚Ä¶  best check the GHC manual
06:27:56 <kstt> another run just completed successfully
06:28:06 <DrTeggy> mm_freak, that flag would be it!
06:28:10 * DrTeggy does looking.
06:28:15 <DrTeggy> s/does/goes/
06:28:47 <loreints`> mm_freak: right now I'm using Data.Binary for parsing the ASCII file because the variables are of fixed length; do you think I should be using Parsec?
06:29:24 <mm_freak> loreints`: probably
06:29:36 <mm_freak> but not necessarily
06:29:47 <hbIppo> isn't parsec a little overkill?
06:29:56 <mm_freak> why would it be overkill?
06:29:57 <DrTeggy> Hurray!  '-x hs' does it.
06:30:06 <DrTeggy> Thanks!
06:30:16 <atriq> There's no such thing as overkill
06:30:20 <mm_freak> hbIppo: it would rather be underkill, if he actually wants serialization
06:30:33 <hbIppo> ok...
06:30:38 <hbIppo> sorry
06:30:44 <hbIppo> i see it as a "big gun"
06:31:13 <mm_freak> the haskell gun is sufficiently big that parsec suffers in comparison =)
06:31:39 <mm_freak> by extension if parsec is overkill, then haskell is overkill =)
06:31:40 <hbIppo> yeah sorry, I'm still a noob
06:32:27 <atriq> I'd say TemplateHaskell is a big gun, and things like Happy and Alex are big guns
06:32:30 <mikeplus64> loreints`: i vote for attoparsec, which last time i heard was a fair than parsec
06:32:45 <mikeplus64> um
06:32:55 <mikeplus64> which last time i heard was a fair bit faster than parsec*
06:33:41 <mm_freak> attoparsec is faster, but you would use it for parsing of stuff that doesn't require good error reporting or has a simple structure
06:33:45 <mm_freak> like most network protocols
06:33:51 <mm_freak> i wouldn't parse files using attoparsec
06:34:54 <mm_freak> attoparsec is basically just an iteratee in disguise =)
06:39:12 * hackagebot template-hsml 0.2.0.3 - Haskell's Simple Markup Language  http://hackage.haskell.org/package/template-hsml-0.2.0.3 (PetrPilar)
06:39:44 <loreints`> which would be faster, attoparsec or data.binary?
06:44:34 <loreints`> data.bytestring, sorry
06:45:35 <parcs`> > 0x7g
06:45:36 <lambdabot>   Ambiguous occurrence `g'
06:45:36 <lambdabot>  It could refer to either `L.g', defined at <local...
06:45:38 <parcs`> > 0x7f
06:45:39 <lambdabot>   127
06:46:03 <byorgey> > 0x7h
06:46:04 <lambdabot>   Ambiguous type variable `a' in the constraint:
06:46:04 <lambdabot>    `SimpleReflect.FromExpr a...
06:46:27 <byorgey> > 0x7'f'
06:46:28 <lambdabot>   7
06:47:24 <byorgey> loreints`: your question does not make sense.  attoparsec is a parsing library.  bytestring is a data structure.
06:47:50 <byorgey> loreints`: it is like asking which is faster, a car or a pizza?
06:48:01 <hbIppo> LOL
06:48:30 <hbIppo> I'd love to see someone racing a pizza against a car :P
06:49:39 <RawProduce> the pizza is faster, it's more delicious
06:49:47 <RawProduce> and gets eaten swiftly
06:50:07 <amatsu> Is there any way to get GHC to transpile to, say, C or C++?
06:50:42 <loreints`> well right now the only libraries I'm really using are Data.Bytestring* Data.Word.*, Data.Char.*. I guess I'm kind of doing everything manually and modifying basically chapter 10 of rwh. Should I be using attoparsec instead then?
06:54:16 <ksf> @ask edwardk is there a deeper reason MonadLayout and MonadLanguage don't distribute over each other in trifecta?
06:54:16 <lambdabot> Consider it noted.
06:54:41 <ksf> amatsu, -fvia-C
06:54:56 <ksf> or -fvia-llvm and then go from there.
06:56:41 <ksf> loreints`, attoparsec has a good chance of being faster than an non-hilariously-handoptimised parser based on bytestrings.
06:56:54 <ksf> also, parsing bytestrings directly is awkward.
06:57:07 <ksf> if you want to go fast, use iteratees
06:57:44 <ksf> loreints`, but as you had to ask, any parsing library will probably be what you want, which is *not* care about performance. it's going to be fast enough.
06:58:40 <loreints`> ksf: thank you! I guess I'll have to do some serious research into using parsec.
06:59:13 * hackagebot perdure 0.1.2 - Robust persistence for acyclic immutable data  http://hackage.haskell.org/package/perdure-0.1.2 (PatrickPremont)
06:59:35 <merijn> ksf: Does -fvia-C compile to completely valid C? I thought the evil mangler needed to do some post-compilation work on that
07:01:31 <byorgey> merijn: first of all, the evil mangler worked on ASM, not C, and second of all, the evil mangler is now gone
07:01:38 <byorgey> http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
07:01:59 <amatsu> merijn: ksf: -fvia-C doesn't even do anything in the latest version of GHC
07:02:46 <ksf> they nuked it?
07:03:05 <ksf> well, I guess llvm works good enough for cross-compiling.
07:03:14 <merijn> byorgey: That's why I said post-compilation (I meant C compilation)
07:03:22 <amatsu> ksf: yup, thanks for the headsup!
07:03:31 <merijn> But I'm not really up to date enough to know about the evil mangler
07:03:59 <ksf> are you trying to port ghc? hell awaits thee.
07:04:05 <joe9> hello, I am writing a simple gcode generator and am not sure how to structure my data structures and am looking for advice. http://codepad.org/NsYLFAqZ
07:04:07 <byorgey> merijn: oh, I see.  But gcc wouldn't be able to compile the generated C code if it weren't valid, right?
07:04:13 <matthiasgorgens> where do I find the source code for the standard instance for Monad Maybe?
07:04:30 <ksf> Data.Maybe?
07:05:01 <ksf> yep.
07:05:03 <ksf> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Maybe.html#Maybe
07:05:07 <byorgey> matthiasgorgens: (1) search for Maybe on Hoogle (haskell.org/hoogle), (2) click on the "Source" link next to its declaration
07:05:17 <Jafet> @src Maybe return
07:05:17 <lambdabot> return              = Just
07:05:20 <Jafet> @src Maybe (>>=)
07:05:20 <lambdabot> (Just x) >>= k      = k x
07:05:20 <lambdabot> Nothing  >>= _      = Nothing
07:05:25 <matthiasgorgens> yeah, fonud it.  i was only looking in Control.Monad.
07:05:31 <matthiasgorgens> I'm interested in the "fail".
07:05:41 <matthiasgorgens> the >>= and return are simple. :o)
07:05:53 <byorgey> so is the fail.
07:05:53 <matthiasgorgens> oops, I'm all messed up.
07:06:00 <matthiasgorgens> I'm looking for MaybeT. :o)
07:06:08 <byorgey> also, you shouldn't use fail.
07:06:22 <Jafet> That instance is also simple
07:06:24 <Jafet> to some
07:06:28 <byorgey> use mzero if you want to indicate failure.
07:06:41 <byorgey> unless you're wondering what happens on a failed pattern-match.
07:06:46 <matthiasgorgens> yeah, that instance is also simple.
07:06:59 <matthiasgorgens> byorgey: yeah, mzero might be right.
07:08:22 <byorgey> every now and then I read a research paper where they say something like "we introduce a Monad constraint so we can have failing computations" and it makes me hopping mad
07:08:47 <sm> hmm perdure.. nice
07:09:12 <hbIppo> (I had never heard about the Evil Mangler, and googled it. It was invoked by the Glorious Driver. Haskell has all the coolest names, like Monad Transformers etc)
07:09:13 * hackagebot PrimitiveArray 0.3.0.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.3.0.0 (ChristianHoener)
07:09:41 <matthiasgorgens> byorgey: I was actually only interested in seeing whether the standard fail implementation would indeed ignore the argument.
07:09:50 <matthiasgorgens> to see whether "fail undefined" would break at runtime.
07:09:53 <matthiasgorgens> just out of interest.
07:10:01 <flux> byorgey, how about: "For side-effects we use the Monad, which was invented for having side-effectful functions in functional program." - well, I suppose that never happens..
07:10:13 <matthiasgorgens> byorgey: I had a job interview were they were asking about monad, I told them the standard thing about bind and return.
07:10:20 <matthiasgorgens> but the guy insisted that fail was integral.
07:10:23 <matthiasgorgens> to the whole thing.
07:10:31 <byorgey> matthiasgorgens: haha, what
07:10:44 <matthiasgorgens> so i mentioned bind and return.
07:10:47 <matthiasgorgens> he asked if that's all.
07:10:58 <matthiasgorgens> i told him, that in theory return and join makes for nicer reasoning.
07:11:03 <matthiasgorgens> he said, no, that's not all.
07:11:23 <matthiasgorgens> so I told him about fail, but that it is an ugly artefact of the implementation in haskell.
07:11:34 <matthiasgorgens> he didn't buy the ugly-artefact line.
07:11:51 <matthiasgorgens> but in the interview, they also asked me about obscure command line arguments to ghc.
07:12:05 <Phlogistique> what
07:12:10 <Sculptor> hello
07:12:10 <Phlogistique> what company is that?
07:12:14 <atriq> Sculptor, hey
07:12:15 <matthiasgorgens> (that I only knew by chance, because I had stumbled upon them a few days before.  but I wouldn't consider that part of knowing haskell..)
07:12:21 <eikke> sounds like a recruiter who needs to do an interview without really knowing what it's about
07:12:22 <matthiasgorgens> Phlogistique: investment bank.
07:12:36 <Cale> lol
07:12:37 <matthiasgorgens> eikke: nah, was some of their engineers.  three years ago.
07:12:41 <eikke> and did some superficial readings
07:12:42 <eikke> oh
07:12:46 <Cale> This is scary man
07:12:55 <atriq> Scary man, scary man
07:12:59 <atriq> Does whatever a scary can
07:13:06 <matthiasgorgens> anyway, on a more positive note, I have to say that Janestreet does surprisingly clued-up interviews.
07:13:15 <matthiasgorgens> (even though they are more interested in OCaml than Haskell.)
07:13:19 * frerich looks up from reading this article about the financial crisis and sees this story of an engineer (a quant?) working at an investment bank...
07:14:12 * Cale imagines a dystopian future in which people write Haskell code which is nevertheless horrible because everything is cargo culted without understanding.
07:14:44 <desc|office> like the way we solve problems in high school math exams?
07:14:53 <Phlogistique> I don't see why Haskell code would be any less horrible than any other code
07:14:58 <matthiasgorgens> Cale: at least they'll have to declare their side-effects. :o)
07:15:10 <hbIppo> lol
07:15:12 * eikke imagines a future in which people write 20 lines of Haskell code, then let their IDE generate 1500 lines of XML throughout 10 files, which then need hand-made tweakings, before being able to deploy
07:15:27 <eikke> matthiasgorgens: unsafePerformIO!
07:15:38 <Phlogistique> It would prolly be MORE horrible because to write proper Hasekll, you have to understand more abstractions than to write code in most other languages
07:15:40 <matthiasgorgens> eikke: we generate our haskell from xml.
07:15:43 <matthiasgorgens> not the other way round.
07:16:00 <Phlogistique> and code using abstractions without understanding them is terribad
07:16:02 <eikke> matthiasgorgens: not sure I like that future more ;)
07:16:16 <dgpratt> since I think it'd be fun to feed into Cale's fears, I'll point out that I gave a Haskell presentation to a group of .NET devs Tuesday night
07:16:26 <dgpratt> they loved it
07:16:27 <matthiasgorgens> eikke: or, it's just for creating rpc-stubs.
07:16:40 <matthiasgorgens> the generator also spits out C, Python, Ruby, etc.
07:16:48 <matthiasgorgens> out of the same specification.  for D-Bus.
07:17:23 <merijn> @where ffi
07:17:23 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
07:17:30 <eikke> matthiasgorgens: sounds familiar :) (protobufs/thrift comes to mind as well)
07:17:30 <Sculptor> dgpratt, did you show them the quicksort code
07:17:44 <merijn> Any short FFI tutorials or should I just read the report?
07:17:50 <dgpratt> Sculptor: alas, no
07:18:34 <Phlogistique> dgpratt: were they into F# before?
07:18:47 <Cale> merijn: The FFI report is in a more tutorial-like style than the rest of the report.
07:18:55 <merijn> Cale: ok, great :)
07:19:08 <dgpratt> Phlogistique: no, C# folks mostly, one VB.NET
07:19:46 <matthiasgorgens> dgpratt: nowadays ghc is handed to us by our MS overlords anyway.  so let's pray for MS continued financial health.
07:19:59 <matthiasgorgens> dgpratt: what lies did you tell?
07:19:59 <dgpratt> matthiasgorgens: lol
07:20:20 <dgpratt> matthiasgorgens: :-D I plead the 5th
07:20:39 <merijn> Unrelated note: I have a program that builds perfectly fine when I run "ghc main.hs" but trying to compile using cabal install fails with an obscure error "Undefined symbols for architecture x86_64: "___stginit_Inconsistentzm0zi0zi0_Settings_"" (where Inconsistent is the project name and Settings a module in there)
07:21:32 <atriq> Sounds like cabal's compiling it for the wrong architecture or something
07:21:41 <matthiasgorgens> dgpratt: we don't have any amendments here in the UK.
07:22:10 <dgpratt> matthiasgorgens: in that case, I'm happy to be on the other side of the pond
07:22:41 <atriq> I plead the 18th
07:22:57 <atriq> I hope none of you have been drinking
07:24:01 <merijn> Sometimes I had programming >.>
07:24:08 <merijn> eh, hate...
07:24:16 <merijn> So badly I can't even type anymore apparently
07:24:25 <matthiasgorgens> channel that hate. :o)
07:24:26 <atriq> Why does parseFromFile hate me?
07:24:52 <tdammers> Don't hate the channel. Channel the hate.
07:25:07 <Jeanne-Kamikaze> yeah
07:25:12 <merijn> I'm trying to install Template Haskell 2.7 but it fails with a compile error "Illegal instance declaration for `Show Doc'" since Doc is apparently a type synonym, not a datatype/newtype
07:25:23 <merijn> But after unpacking cabal I don't see Doc defined anywhere
07:31:06 <t7> @hayoo Doc
07:31:07 <lambdabot> Unknown command, try @list
07:31:12 <t7> @google hayoo Doc
07:31:14 <lambdabot> http://yui.github.com/yuidoc/
07:31:14 <lambdabot> Title: YUIDoc - Javascript Documentation Tool
07:31:23 <t7> lambdabot: you suck
07:31:33 <t7> and google does too
07:31:53 <fmap> merijn: http://hackage.haskell.org/trac/ghc/ticket/7200
07:31:55 <fmap> ?
07:31:59 <merijn> t7: Supposedly it's a built in type
07:32:39 <merijn> fmap: Yeah
07:33:16 <t7> merijn: isnt Doc a pretty print thing?
07:33:18 <merijn> Althought the underlying issues seems to be that Control.Lens is ignoring my installed TH-2.5 package
07:33:33 <edwardk> ?
07:33:33 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
07:34:26 <Sculptor> can lambdabot run haskell code
07:34:27 <edwardk> @tell ksf yes. MonadLayout edits the whitespace behavior specified by MonadLanguage
07:34:27 <lambdabot> Consider it noted.
07:34:40 <merijn> edwardk: cabal is ignoring TH-2.5 and trying to install TH-2.7 which is broken on ghc 7.0.4
07:34:50 <edwardk> merijn: what version of ghc are you on?
07:35:05 <merijn> 7.0.4
07:35:27 <edwardk> not sure it can install on 7.0.4. try editing the .cabal file and lowering the TH bound
07:35:33 <edwardk> if it works i'll lower it in the distribution
07:35:45 <merijn> I don't need to, the lower bound is 2.4
07:35:51 <edwardk> interesting
07:36:05 <edwardk> then is something else constraining it upward?
07:36:16 <edwardk> e.g another dependency i have using TH?
07:36:19 <merijn> Now cabal tells me I need to reinstall some stuff using --force-reinstalls to install
07:36:25 <Peaker> lambdabot can't really run Haskell code, but Caleskell code which is kind of close
07:36:28 <edwardk> @hpaste the list
07:36:28 <lambdabot> Haskell pastebin: http://hpaste.org/
07:36:55 <hpaste> merijn pasted ‚Äúlens dependencies‚Äù at http://hpaste.org/73939
07:37:14 <merijn> I don't really care about data-lens, and I don't think I need the other stuff anyway
07:37:19 <edwardk> those should be safe
07:37:24 <merijn> But I'm unsure how to cleanly upgrade the stuff
07:37:41 <edwardk> active an diagrams should be reinstallable after
07:38:33 <edwardk> toss the force-upgrades in there and come back and update the other packages, the main issue is the 0.3 bound on transformers
07:38:45 <edwardk> which is needed because Contro.Applicative.Backwards is in there
07:39:00 <edwardk> i'm thinking about just going back to using my own local Backwards type to let me be more compatible
07:39:09 <edwardk> i'll add an issue to do so before 2.6
07:39:26 <merijn> Although I suspect it will then still barf on TH-2.7 because someone wasn't regression testing at GHC headquarters...
07:41:10 <edwardk> it shouldn't need TH 2.7 not sure what is forcing the bound up that high
07:41:32 <merijn> How can I check? Or is there no way to check using cabal?
07:41:34 <sclv> i thought there was a verbose cabal solver mode that spit out everything
07:41:39 <sclv> let me find it.
07:41:49 <byorgey> -v3
07:41:50 <edwardk> sclv: should be, afk a sec
07:42:10 <edwardk> merijn: alternately you could just upgrade to the current platform ;)
07:42:16 <sclv> byorgey ftw
07:42:33 <merijn> edwardk: That'd involve reinstalling bazillions of things :(
07:42:44 <merijn> @where platform
07:42:45 <lambdabot> http://hackage.haskell.org/platform/
07:43:20 <sclv> btw, byorgey, nice post on datatype maths. it was a really fun whiteboard session
07:43:37 <byorgey> sclv: thanks.  It was fun indeed!
07:43:47 <atriq> By the time the next Haskell platform comes out, I'll be legally an adult, I think.
07:44:23 <t7> >mfw people are young near me
07:44:45 <merijn> When calling haskell from C I guess it has to be a fixed number of arguments function?
07:44:46 <sclv> merijn: after i install the platform, i usually just pick my biggest dep-hog (typically a web framework, or package based on one) and just cabal install that. then i pick the second biggest dep-hog (like darcs, or pandoc) and cabal install that. that usually sucks down nearly every library i want.
07:45:18 <edwardk> merijn: yes and vice versa (no varargs support)
07:45:38 <t7> could pass a list?
07:45:49 <t7> then use some magic
07:45:53 <merijn> hmm, then I need to find a good way to do this
07:46:12 <chrisbuchholz> What are some examples of programs written in haskell? That is, programs that are actually used for stuff? (asked by someone just getting started with haskell and is curious
07:46:15 <chrisbuchholz> )
07:46:20 <ksf_> edwardk, oh, that's great as I was trying to convince me not to use Language anyway.
07:46:26 <ksf_> dang.
07:46:29 <t7> chrisbuchholz: xmonad
07:46:36 <sclv> you can wrap it in a c varags function, then toss everything in an array :-)
07:47:00 <chrisbuchholz> t7: ah yes, that sucker is awesome and i have missed him as long as i have owned this mbp
07:47:09 <sclv> chrisbuchholz: darcs
07:47:33 <Jafet> A pretty big majority of haskell tools are in haskell
07:47:34 <chrisbuchholz> sclv: hmm, cool
07:47:43 <tdammers> chrisbuchholz: pandoc
07:47:44 <chrisbuchholz> Jafet: i bet they are ;)
07:47:53 <chrisbuchholz> tdammers: that one's really nice!
07:47:58 <tdammers> yep
07:48:07 <sclv> ?g "Free software programmed in Haskell"
07:48:07 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google googleit gsite gwiki . ? @ v
07:48:11 <Jafet> darcs, pandoc, yesod and a few others are sometimes used outside of haskell
07:48:14 <sclv> ?google "Free software programmed in Haskell"
07:48:15 <lambdabot> http://en.wikipedia.org/wiki/Category:Free_software_programmed_in_Haskell
07:48:34 <tdammers> how does one use yesod outside of haskell?
07:48:36 <sclv> there's lots more too
07:48:46 <atriq> tdammers, by running and administering a website
07:48:53 <chrisbuchholz> sclv: thansk for the list
07:49:03 <tdammers> atriq: but yesod is just the framework - yesod alone doesn't make a website
07:49:18 <tdammers> (unless you count the boring useless scaffolding site it generates)
07:49:27 <atriq> tdammers, if you use Yesod to make a website, the end users don't need to know a thing about Haskell
07:49:38 <dncr> in ~/.cabal/share/doc, fgl-5.4.2.4/html/index.html exists but index.html doesn't link to or mention fgl.  how can i fix it?
07:49:41 <atriq> Whereas, say, if you make some documentation using Haddock, the end users do
07:49:45 <tdammers> no, but the same goes for anything you make in haskell
07:50:01 <tdammers> haddock is *about* haskell
07:50:19 <atriq> The point is, Yesod isn't about Haskell
07:50:26 <tdammers> people can use pandoc without noticing it's in haskell
07:50:29 <dncr> "cab --reinstall fgl" even says "Updating documentation index /home/user/.cabal/share/doc/index.html"
07:50:41 <tdammers> they can use a yesod-based website without noticing haskell
07:50:54 <tdammers> but they can't use yesod itself without building a web site in haskell with it
07:51:13 <tdammers> just like you can't use the pandoc *library* without writing any haskell
07:51:59 <tdammers> or, put differently, you can't point people at yesod and expect them to be able to use it without learning haskell
07:52:31 * Jafet watches
07:55:47 * armlesshobo falls over.
07:55:53 * armlesshobo can't get himself up
07:55:59 * armlesshobo wiggles around
07:56:06 <scshunt> armlesshobo: try lifting yourself
07:56:20 <merijn> If I want to pass a value from Haskell to a C FFI function which will pass it to a Haskell function (untouched) do I need the entire problem of defining a Storable instance and marshalling for it?
07:56:54 <merijn> Could I derive the necessary boiler plate?
07:57:03 <alFReD-NSH> Hi, is it possible to link a haskell object file that was made with `ghc -c` and another object file with another linker than haskell?
07:57:11 <alFReD-NSH> another linker than ghc*
07:57:17 <Jafet> ghc isn't a linker, it just uses ld
07:57:36 <Jafet> ...with a few options
07:58:22 <tromp_> that reminds me of Murray Gordon's cars, the T.25 and T.27
07:58:24 <Jafet> merijn: consider GC
07:59:52 <merijn> Jafet: That shouldn't be an issue (and isn't, Foreign.StablePtr seems to do exactly what I want)
07:59:56 <alFReD-NSH> Jafet: I'm actually having a project of C++ and C getting build by GYP and gcc and I'm trying to bring some haskell to the party
08:00:25 <srhb> Where am I supposed to change my world in an openGL program? In the idlecallback? Seems weird!
08:00:59 <Jafet> Ok, so you considered it
08:01:13 <Jafet> srhb: in a glut program?
08:01:26 <srhb> Yes, I'm not sure I know the distinction though :-)
08:01:33 * srhb is randomly mashing buttons
08:01:33 <Ralith> srhb: you aren't supposed to do serious opengl work with glut.
08:01:40 <srhb> Oh.
08:01:45 <srhb> Well, define serious.
08:01:45 <Jafet> opengl is a series of pipes
08:01:48 <Ralith> it's made for simple demos
08:01:54 <srhb> Spastic pipes?
08:02:12 <srhb> It's rather simple, I want to move a pong paddle.
08:02:17 <Jafet> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
08:02:38 <Jafet> Using ContT. Easy to understand and maintain
08:02:47 <srhb> It says quick and dirty hack though :o
08:03:00 <Jafet> We're talking about haskell here
08:04:16 <Ralith> looks like a good solution
08:04:28 <Ralith> srhb: the 'using GLUT at all' bit generally implies hackishness.
08:04:33 <srhb> What's wrong with GLUT?
08:05:03 <Ralith> nothing's wrong with it, it's just not general-purpose.
08:05:08 <Ralith> it's great for quick demos.
08:05:17 <srhb> Aha.
08:05:40 <Jafet> alfred: if you are using the FFI, just tell ghc to link the C libraries
08:06:48 <Jafet> pong is a pretty simple demo as they go
08:08:07 <Ralith> yep!
08:08:46 <lightquake> wait, what's wrong with GLUT?
08:09:13 <Jafet> It doesn't do much, and it does what it does somewhat badly
08:09:19 <Jafet> But it does something useful
08:10:17 <lightquake> i'm mostly using it for callbacks
08:11:32 <Jafet> Well, calling back is torture in C
08:11:47 <lightquake> right, but it's simpler in haskell ;)
08:11:49 <Jafet> Here it shouldn't be a horror
08:12:02 <lightquake> i guess my question is 'why shouldn't i use GLUT for my actual project'
08:12:05 <lightquake> (in haskell)
08:12:30 <Jafet> You can, but it's not enough
08:12:36 <lightquake> oh sure
08:12:52 <lightquake> i'm not just using GLUT, i'm also using OpenGL for stuff like drawing quads
08:12:58 <Jafet> So you need to scrounge up all the other things
08:13:01 <srhb> When exactly might my application decide to redraw? <_<
08:13:07 <srhb> This is not very intuitive to work with...
08:13:11 <Jafet> Like audio, extra input devices, text rendering
08:14:01 <Ralith> nontrivial I/O, even
08:14:09 <Jafet> And stuff to manage your mipmaps and other low level things so your head stays intact
08:14:31 <Jafet> Or whatever it is that opengl doesn't manage for you
08:16:02 <Jafet> srhb: in opengl you decide when to draw; glut decides for you
08:16:07 <Jafet> Hence the Inversion of Control
08:17:36 <srhb> I see. I'm not sure which route I should take.
08:18:07 <Jafet> Well, you're not going to get anywhere with just opengl because it doesn't even let you create a window
08:18:19 <srhb> Oh, that makes it somewhat simpler :P
08:18:34 <t7> > foldl (*) 0 [1..6]
08:18:35 <lambdabot>   0
08:18:41 <t7> > foldl1 (*) [1..6]
08:18:42 <lambdabot>   720
08:25:15 <MostAwesomeDude> Stupid question time. I'm writing a handful of folds by hand, where each fold pattern matches on *multiple* things at the top of the list to operate on. Is there a combinator for this, or is doing it by hand the Right Thing?
08:26:28 <merijn> If I want to deal with opaque memory blocks I guess I should be using "Ptr CChar"?
08:27:00 <merijn> Or is there a void* type in the FFI?
08:27:28 <MostAwesomeDude> merijn: Completely opaque? Like, struct opaque; struct opaque* get_opaque(void); ?
08:28:03 <Clint> merijn: Ptr ()
08:28:05 <MostAwesomeDude> Use empty data declarations. data Opaque = Opaque -- and then use Ptr Opaque.
08:28:21 <MostAwesomeDude> Or turn on EmptyDataDecls and then: data Opaque
08:28:32 <merijn> MostAwesomeDude: Opaque from the other sides, not the haskell side
08:28:38 <MostAwesomeDude> Clint's suggestion works too. Depends on -- oh!
08:28:44 <Cale> newtype ForeignThingy = FT (Ptr ForeignThingy)
08:28:45 <merijn> i.e. I need to shove C pointers around
08:29:08 <Cale> (for less-opaque things)
08:29:22 <merijn> And maybe allocate them, so I need access to the Storable functions
08:30:35 <Cale> merijn: Well, I think which Ptr type you use depends on how you want the things to look on the Haskell side
08:30:45 <Cale> (In that case)
08:31:08 <merijn> Cale: I wanna think of them a just blocks of bytes
08:32:12 <Cale> Ptr Word8 probably
08:32:17 <merijn> Actually...maybe I want ForeignPtr
08:32:22 <merijn> Cale: Oh, duh...
08:34:37 <Cale> Which type of pointer you use is just dependent on what kind of data you want to parse out of memory at that point, more or less (I guess it would also affect alignment constraints and such)
08:35:26 <MostAwesomeDude> Can GHC derive Num for e.g. data Wrapper = Wrapper Int -- or do I need to type stuff out?
08:36:16 <srhb> MostAwesomeDude: You'll have to do it yourself I believe.
08:36:17 <parcs`> for a non-newtype? no
08:36:27 <Jafet> It should be a newtype anyway
08:36:38 <Cale> MostAwesomeDude: {-# LANGUAGE GeneralizedNewtypeDeriving #-} and make it a newtype and it can
08:36:42 <srhb> You can probably do it with GeneralizedNew... yeagh
08:36:43 <srhb> :P
08:37:20 <MostAwesomeDude> Oh yeah, it should be a newtype, huh.
08:38:56 <MostAwesomeDude> Yep, that works fine, thanks.
08:39:17 * hackagebot hstzaar 0.9.2 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.9.2 (PedroVasconcelos)
08:41:04 <sm> kstt: nevertheless, that's the one
08:41:45 <MostAwesomeDude> Oh man, I just read up on it, and generalized newtype deriving is sweet! But I guess it's got weird edges and that's why it's not in 2010? :c
08:42:27 <kstt> sm ok, thx
08:43:19 <byorgey> MostAwesomeDude: indeed
08:43:33 <MostAwesomeDude> Man, weird edges suck.
08:43:43 <sm> kstt: be prepared for a slight learning curve
08:44:10 <kstt> I'm a bit surprised by what I read in the doc already :)
08:44:28 <byorgey> MostAwesomeDude: it's fairly standard/accepted though, so I wouldn't hesitate from using it
08:44:39 <byorgey> MostAwesomeDude: you have to work fairly hard to hit the weird edges
08:45:05 * byorgey uses it extensively in his own code 
08:45:14 <MostAwesomeDude> byorgey: Yeah, looks like type families cause the common problems? But I never use type families. (I suppose this is because I don't know how to use them effectively!)
08:45:21 <kstt> also, time is packages with haskell plateform (or is it with GHC ?). Should the cabal file require specifically the version that is packaged with my plateform, or can I point to the latest ?
08:45:42 <byorgey> kstt: why not allow both?
08:46:12 <byorgey> kstt: unless there is a particular reason you know it doesn't work with one version or the other
08:46:23 <kstt> because that's too permissive, and I like to show my authority
08:46:38 <MostAwesomeDude> Anyway, thanks! This is the end of my stupid question list for the day, I think.
08:46:44 <monochrom> the cabal file should allow a wide range, not pinpoint one version
08:47:07 <byorgey> kstt: in that case, you should require some version from 2009
08:47:32 <monochrom> unless you're saying your package will not be leaked to someone else
08:47:34 <hpaste> MAD pasted ‚ÄúHand-rolled folds? :T‚Äù at http://hpaste.org/73941
08:47:40 <MostAwesomeDude> No wait, I lied. ^^
08:47:52 <MostAwesomeDude> These folds kinda suck. Is there a better way to do them or should I just suck it up?
08:48:04 <kstt> byorgey: is that the best way I have to annoy everyone ? :)
08:48:34 <monochrom> oh, to annoy everyone, there are easier ways. depend on a package not on hackage
08:48:45 <byorgey> kstt: there are many, many ways to annoy everyone
08:48:54 <monochrom> omit some files
08:48:59 <sm> kstt: include a few compilation errors in there, and a bunch of flags pulling in different deps
08:49:04 <monochrom> add a compiler error to a file
08:49:10 * sm thinks that's a great idea for a doc
08:49:30 <monochrom> tell people to "git pull" or "darcs pull". (well, that annoys me)
08:49:39 <sm> be sure to use some native c libs so it doesn't build on windows
08:50:03 <Jafet> Bonus points if it links with the C libs on Windows then crashes at runtime
08:50:05 <sm> the home page link should be broken, and the repo link should have random uptime
08:50:10 <kstt> I'm a manager, so my job is to make decision that are opposed to what most of the team I manage would make. Otherwise I'd be useless and quickly fired. :)
08:50:36 <matthiasgorgens> kstt: managers also act as shit-umbrellas.
08:51:01 <monochrom> I am not sure that it is in your best interest
08:51:06 <matthiasgorgens> so there are other things to make you useful.
08:51:19 <kstt> oh, I alway keep a stock of vacations, for when shit rains
08:52:32 <monochrom> I think your best interest is in making decisions that your superior thinks sensible, which is not necessarily the opposite of what your inferiors think
08:54:14 <kstt> well, thank you for this advice. I was jocking all the way here of course ... I'll try to put the less restrictive bounds possible on this dependency, however ... How do I know that all the range covered will properly build ? Should I traverse the package API history by hand ?
08:55:18 <merijn> ok, the FFI is pretty neat :)
08:55:30 <monochrom> you should test them all
08:56:26 <monochrom> or rather, command your inferiors to test them all
08:57:38 <kstt> great
08:58:13 <kstt> haskell is a great job provider
08:59:04 <kstt> I must go, the sh*t forecast is threatening :)
09:00:38 <hpaste> chra pasted ‚ÄúHow to get rid of OverlappingInstances?‚Äù at http://hpaste.org/73942
09:02:08 <monochrom> delete one of the two instances. they overlap because they start off with ":."
09:02:39 <chra> The point is to test if X is in the list of types.
09:04:58 <monochrom> thank you for telling me the point. but the bottomline is whether the computer, not me, understands the point
09:05:00 <merijn> hsc2hs is the best way of making new Storable instances?
09:05:16 <monochrom> this is why I don't engage in such type-level computing
09:05:34 <alFReD-NSH> ghc >= 7.2 doesn't generate *_stub.{c,o} file, but I need for linking
09:05:40 <alFReD-NSH> Anyone can help?
09:05:48 <alFReD-NSH> I'm using another linker rather than ghc
09:07:11 <fmap> chra: you probably want `instance HasX X' not `instance HasX (X .: b)'
09:07:23 <chra> ... if I remove one of the instances, it no longer tests if X is in the context, and it doesn't achieve the purpose. I was wondering if there was a way to test if X was in the list without OverlappingInstances.
09:07:56 <alFReD-NSH> I think I can just use -ddump-foreign to get the stub, and put them in a file myself
09:08:06 <alFReD-NSH> but not the best solution
09:08:19 <merijn> chra: The answer is: It's not possible
09:08:22 <chra> fmap: I see that I need that too, but if I remove 'instance HasX (X .: b)' and add that, it only works if X is the last in the list.
09:08:40 <chra> merijn: Hmm, ok. Thanks.
09:10:58 <merijn> Unless I finally decide I should start learning how to hack GHC so I can add my limited Instance Chain subset :p
09:11:05 <merijn> Which probably won't be any time soon :p
09:19:19 * hackagebot wai-middleware-static 0.3.1 - WAI middleware that intercepts requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.3.1 (AndrewFarmer)
09:23:11 <ctbo> Hi everybody! I am looking for some advice from Haskell experts ...
09:23:45 <monochrom> advice: use a clean slate
09:23:51 <ctbo> :-)
09:23:54 <srhb> ctbo: Hi :)
09:24:01 <ctbo> I already have a little more specific questions :-)
09:24:23 <ctbo> I am working on a magazine article about Haskell, but have only just learned some.
09:24:40 <srhb> That sounds like a difficult endeavour.
09:24:42 <ctbo> So I'd like experienced people to look over my code and tell me if it makes sense
09:24:52 <srhb> Linky linky.
09:25:02 <ctbo> https://github.com/ctbo/slitherlink
09:25:22 <ctbo> I have also tried to sketch how the algorithm works: https://github.com/ctbo/slitherlink/wiki/How-it-works
09:25:26 <srhb> Oh dear, too long for me to look at it now at least :)
09:25:41 <ctbo> doesn't have to be now
09:25:42 <merijn> If I want to generate a trivial wrapper (i.e. just straight int -> CInt, int* -> Ptr Int translation)around a C struct, what's the best approach? c2hs, hsc2hs, something else?
09:25:49 <ctbo> feedback via github would pe perfect
09:26:19 <ctbo> I am not sure if I am already fully into functional thinking
09:26:37 <ctbo> for instance using a 2-dimensional array as the central data structure somehow seems awkward
09:27:21 <ctbo> am I thinking too much along the lines of imperative programming or does it look ok to you functional guys? :-)
09:30:13 <timthelion> Is there a reason why the famous haskell tuple instances such as http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/src/Data-Tuple-Select.html#sel15 are not written in template haskell as sugested they should be in the TH paper?
09:31:01 <Clint> so you can use them without TH?
09:31:31 <timthelion> OK, but what's "bad" about compiling with TH, when ghc does it natively?
09:32:08 <Clint> only ghc on some platforms
09:32:09 <vodik> other compilers
09:32:38 <Clint> there's plenty of ghc out there without TH or QQ or ghci
09:32:50 <timthelion> ? really ? where and why?
09:33:41 <timthelion> Well anyways, if that's the only reason holding template haskell back, then I'll go ahead and use it :)
09:34:15 <Clint> timthelion: https://buildd.debian.org/status/package.php?p=haskell-yesod&suite=sid
09:34:25 <Clint> the ones that say BD-Uninstallable don't have working TH support
09:36:24 <timthelion> Why would PowerPC have trouble with TH?
09:36:50 <geekosaur> runtime linking
09:36:54 <Clint> it broke about a year ago and no one cared enough to fix it?
09:37:00 <geekosaur> and, that
09:38:04 <timthelion> hm, I would consider a platform without runtime linking to be "unsupported" in general :/
09:38:15 <timthelion> that's kind of a big feature to not have.
09:39:51 <geekosaur> oh, most platforms have it.  most platforms also have quirks, though, which have to be dealt with when some program decides to uts its own custom runtime linker instead of using the system facilities
09:40:15 <edwardk> timthelion: btw- those tuple accessors are easier to use with lenses ;)
09:40:17 <geekosaur> there's an open ghc bug about switching to the system facilities instead of the custom one that needs to be ported to new/changed platforms all the time
09:57:13 <hbIppo> if I have a multi-threaded program, is compiling with the -threaded flag enough?
09:57:20 <hbIppo> I mean, is there anything else I should do?
09:59:20 * hackagebot blank-canvas 0.2.2 - HTML5 Canvas Graphics Library  http://hackage.haskell.org/package/blank-canvas-0.2.2 (AndrewFarmer)
10:00:45 <timthelion> hbIppo: in order to get it on multiple cores you need to run it with +RTS -n... but that may actually run more slowly!
10:01:29 <hbIppo> it's actually a concurrent application
10:01:30 <hbIppo> so no
10:01:53 <hbIppo> to be precise, it's the very program I'm writing from... I extended the IRC bot from the documentation to post messages
10:02:03 <hbIppo> but the listening and the writing are on separate threads
10:02:15 * timthelion has no idea what program hbIppo is talking about.
10:02:46 <hbIppo> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
10:02:47 <hbIppo> this
10:03:25 <hbIppo> anyway it's just running two separate threads, one to read and one to write
10:03:43 <hbIppo> I'm just not sure how to compile it properly
10:03:55 <hbIppo> it is working, though... just asking for advice
10:09:20 * hackagebot chuchu 0.1.1 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.1.1 (FelipeLessa)
10:09:29 <hbIppo> timthelion: what was that about +RTS etc?
10:09:38 <hbIppo> is it for ghci, or ghc as well?
10:12:25 <timthelion> How does TH deal with indentation.  Can I generate a multiline function with TH?
10:13:21 <hbIppo> sorry, no clue...
10:13:56 <ixmatus> hbIppo it also depends on how you're handling your threads - are you using channels? I compile with -threads then run the program with +RTS -n (not numeric value so it just uses all of my cores)
10:14:28 <hbIppo> actually it's just a forkIO
10:14:55 <hbIppo> I'm getting into multithreading just today, I barely know what I'm doing
10:16:44 <Cale> timthelion: It doesn't, it deals with syntax trees directly.
10:19:01 <Cale> timthelion: But you can generate any function you want.
10:19:41 <timthelion> Cale: so I should think about it from the semantic standpoint alone, and not from a syntactic point...
10:20:00 <timthelion> Cool
10:20:06 <Cale> Well, you are generating syntax, it's just abstract syntax
10:20:36 <timthelion> Is an actual string generated and then passed back to GHC?
10:20:58 <timthelion> like is it precompile+compile, or compile and do weird stuff at the same time...
10:21:17 <Cale> http://hackage.haskell.org/packages/archive/template-haskell/2.7.0.0/doc/html/Language-Haskell-TH-Syntax.html -- look at the data structures here, particularly Dec and Exp
10:21:23 <Cale> No string
10:22:19 <parcs`> when you use splices you write a piece of haskell code that gets parsed into an AST
10:22:28 <parcs`> eg [| \x y -> x + y * 2 |]
10:22:42 <timthelion> I see those structures, as I'm reading the paper.  But of course, something like McBride's http://hackage.haskell.org/package/her-lexer-0.0 which is used for preprocessing also has such structures, but spits out ordinary haskell code(a String) in the end.
10:22:49 <monochrom> you should think about it as data structures
10:23:34 <timthelion> OK
10:24:24 <Cale> I don't think GHC has any really good way to generate textual source code from those structures anyway
10:24:33 <Cale> I might be wrong
10:25:55 <Cale> (Maybe the prettyprinting is good enough...)
10:28:41 <hpaste> timthelion pasted ‚ÄúTH‚Äù at http://hpaste.org/73943
10:29:25 <timthelion> Cale: I don't actually want to generate text.  I just want to change THAT into $(listen 4) foo1Object foo2Object foo3Object foo4Object draw...
10:30:46 <timthelion> Cale: indeed, I'd prefer to do so without the "4" :D
10:31:07 <c_wraith> Err, can't you just do that without template haskell at all?
10:31:16 <timthelion> c_wraith: it's impossible
10:31:18 <c_wraith> can't you just fold over a list?
10:31:51 <timthelion> c_wraith: nope, because you can't make a list of arbitrarilly typed elements.
10:32:02 <MostAwesomeDude> Well.
10:32:07 <timthelion> c_wraith: in THAT example yes, but if the foo's where to have different types then no.
10:32:39 <MostAwesomeDude> Who cares if they have the same type? Do you care what they *do*?
10:32:59 <timthelion> MostAwesomeDude: I did not understand that sentence...
10:33:07 <MostAwesomeDude> You *can* legally do things like (Show a) => [a]
10:33:16 <MostAwesomeDude> But then you can only do things that members of Show can do.
10:33:33 <timthelion> MostAwesomeDude: can I then have [1,"foo",3]?
10:33:43 <c_wraith> sort of.
10:33:46 <timthelion> > :t [1,"foo",3]
10:33:47 <lambdabot>   <no location info>: parse error on input `:'
10:33:53 <timthelion> > t: [1,"foo",3]
10:33:54 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
10:33:55 <lambdabot>         against inferred ...
10:34:10 <timthelion> c_wraith: example?
10:34:12 <MostAwesomeDude> :t [1,"foo",3] -- dunno if lambdabot can deal with this
10:34:13 <lambdabot>     No instance for (Num [Char])
10:34:13 <lambdabot>       arising from the literal `1' at <interactive>:1:1
10:34:13 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
10:34:37 <c_wraith> You need an existential for that to work, meaning you'd need a data constructor on each argument
10:34:38 <MostAwesomeDude> :t map show
10:34:39 <lambdabot> forall a. (Show a) => [a] -> [String]
10:34:40 <armlesshobo> timthelion: you'd have to construct your own type, I believe
10:35:17 <armlesshobo> I recently made a data constructor that allows for a list that can have a list as one of its elements
10:35:22 <armlesshobo> which is what "foo" os?
10:35:42 <timthelion> anyways, what I'm doing is getting the values from a LoudObject a, and passing them to a draw function. but what if I have draw :: Int -> String -> Int -> Double -> IO (). it's still impossible to use a list.
10:36:14 <c_wraith> That seems...  beyond what you can sanely abstract out with template haskell
10:36:24 <c_wraith> The whole thing sounds like a design mess
10:36:35 <timthelion> armlesshobo: of course I can make a special data constructor for each special case of listen, but that would ruin everything :) it wouldn't save me any code.
10:36:50 <timthelion> c_wraith: don't attack something untill you understand it.
10:36:56 <MostAwesomeDude> I am sensing that you want to define curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e -- and then go from there.
10:37:20 <timthelion> MostAwesomeDude: yes, for an arbitrary numbered tuple...
10:37:36 <armlesshobo> timthelion: right, but that wasn't the issue. the issue was whether or not you can have something like [1,"foo",2]
10:37:44 <MostAwesomeDude> timthelion: Sounds like your incoming data's ill-typed. You're making some kind of general event dispatcher?
10:38:23 <timthelion> MostAwesomeDude: I have invented a way with STM, to listen to a change to any of several mutable objects, and then re-run the draw function whenever any one of those values changes.
10:38:48 <c_wraith> timthelion: generally, when you have the problem you have, your design is missing something
10:39:11 <c_wraith> timthelion: and usually what's missing is that you're trying to use a type class instead of an action of some sort
10:39:16 <MostAwesomeDude> timthelion: data DrawStruct = DrawStruct Int String Int Double; draw :: DrawStruct -> IO ()
10:39:26 <timthelion> c_wraith: that's not true.  My design is perfect.  You don't know anything about my design, and yet you are attacking it already :)
10:39:42 <c_wraith> timthelion: if your design was perfect, you clearly wouldn't be asking us how to fix it. :P
10:40:02 <MostAwesomeDude> You could always pastebin more of your design. :3
10:40:04 <timthelion> c_wraith: I'm not asking how to fix it, I'm just saying that obviously I need TH for it, and I don't know TH yet.
10:40:16 <MostAwesomeDude> Mu; TH is never a requirement.
10:40:39 * timthelion goes back to reading. clearly this conversation is going no where.
10:40:42 <parcs`> is there an implementation of efficent growing vectors out there?
10:40:54 <MostAwesomeDude> TH can only ease the amount of typing you do; it cannot magically circumvent the type system.
10:41:04 <c_wraith> timthelion: would you like us to tell you how to do it without template haskell?  Because it almost certainly can be done.
10:42:13 <timthelion> c_wraith: My code currently runs perfectly.  However it's too much text.  So as MostAwesomeDude says, I want to reduce the amount of code..
10:42:58 <timthelion> unfortunately, it would take me about a day to actually explain that little equation.
10:43:10 <c_wraith> it would take a lot less time than that to just show the code
10:43:19 <timthelion> I'm not saying that you are too stupid to understand mind you ;) I'm just really bad at explaining.
10:45:26 <hpaste> timthelion annotated ‚ÄúTH‚Äù with ‚ÄúTH (annotation)‚Äù at http://hpaste.org/73943#a73944
10:45:36 <timthelion> that's the code, but I doubt it will do you much good.
10:45:51 <timthelion> especially given that the seccond file isn't exactly in standard haskell :)
10:50:20 <otters> @src ap
10:50:20 <lambdabot> ap = liftM2 id
10:50:26 <otters> @src liftM2
10:50:26 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:54:49 <hiptobecubic> vodik, you shouldn't irc as root
10:55:07 <vodik> hiptobecubic: its fake
10:55:21 <vodik> ident can be arbitarary
10:55:29 <hiptobecubic> ah ok sure
10:55:34 <vodik> :)
10:55:40 <hiptobecubic> carry on then
10:56:52 <vodik> thanks for the concern. heh, i did it to make fun of someone on #archlinux a while ago
11:01:30 <Yuu-chan> May I ask if using of TH in my task was right thing?
11:02:49 <ocharles> Do arrows have a way to achieve parallel execution? For instance, I have an arrow that at various parts splits and recombines, and both 'sides' of the arrow could be ran in parallel
11:03:13 <ocharles> https://gist.github.com/9706a08394c36b003885 is my current toy example
11:03:50 <SegFaultAX|work2> scriptor: I don't know if such a thing exists in Clojure. But the applicative style makes this sort of thing quite simple.
11:03:51 <ocharles> From this example findRelease has to run, but then the output of it can be distributed to first (getReleaseMediums) and second (getCountry) in parallel
11:04:12 <ocharles> and then recombine sort of combines the 2 to lose some now redundant information
11:04:13 <SegFaultAX|work2> Whoops, wrong room. :)
11:04:43 <ocharles> (which would need to wait for first and second to terminate)
11:05:22 <hiptobecubic> is sparking with par not sufficient here?
11:06:00 <rudyl313> does anybody know of a way to use the show function on a String without having unicode chars escaped?
11:06:21 <joe9> rudyl313: groom?
11:06:22 <sipa> rudyl313: why don't you want them escaped? you know what show is for?
11:06:27 <joe9> rudyl313: Text.Groom
11:06:36 <rudyl313> joe9: will check it out
11:06:40 <ocharles> rudyl313: that is the identity function, no?
11:06:52 <monochrom> don't use show. just putStrLn when you need output
11:06:54 <rudyl313> sipa: I'm putting the string into a json field thats going into a query string
11:06:59 <rudyl313> the reason I use show is...
11:07:13 <rudyl313> it automatically escapes things
11:07:24 <monochrom> alright then don't use show, just ++
11:07:45 <hiptobecubic> does show escape things appropriately for json though?
11:07:48 <rudyl313> so if the string contains "hello\"bye"... that becomes "\"hello\\\"bye\""
11:07:59 <sipa> show is for turning values into Haskell source
11:08:28 <hiptobecubic> sipa, yes, but i guess he's abusing that to turn it into json, on the assumption that they are equivalent for the strings he cares about?
11:08:33 <monochrom> actually beware that json uses something like utf-16, you're better off not using String at all for storing json
11:08:53 <monochrom> yes this means you're throwing away the whole Show framework
11:08:59 <monochrom> (good riddance)
11:09:20 <rudyl313> my main concern is being able to take any input string and put it into my json field without ever prematurely closing the \"
11:09:24 <k0ral> hello
11:09:27 <rudyl313> or anything like that
11:09:53 <rudyl313> so I'm going "{\"key\":" ++ show value ++ "}"
11:10:52 <rudyl313> is there an alternative approach that will ensure that value never yields invalid json?
11:10:59 <k0ral> I forgot the name of the operator that makes it possible to write TypeConstructor f1 f2 f3 f4 with TypeConstructor :: a1 -> a2 -> a3 -> a4 -> Type and fX :: Monad m => m aX
11:11:08 <sipa> rudyl313: use a JSON package?
11:11:11 <k0ral> would anyone remind me of it please ?
11:11:46 <monochrom> GADTs
11:17:59 <k0ral> actually I would like to write something like TypeConstructor f1 OPERATOR f2 OPERATOR f3 OPERATOR f4, or something close; I know there is an operator for that
11:21:22 <monochrom> <*> ?
11:21:27 <nand`> k0ral: are you thinking of applicative style?
11:21:48 <nand`> TypeConstructor <$> f1 <*> f2 <*> f3 <*> f4
11:22:13 <beaky> hello
11:24:36 <beaky> In Haskell, how do I write a function that returns the length of the longest String in a [String]?
11:24:58 <sipa> beaky: homework?
11:25:21 <Botje> beaky: 1) grab the length of each string in turn 2) return the biggest number.
11:25:38 <beaky> no I just want to compare a Haskell solution to this C++ one: http://ideone.com/fsS57
11:26:16 <Botje> maximum (map length strings)
11:26:40 <k0ral> nand`, monochrom: yes, I was thinking of that exactly, thanks !
11:26:58 <MostAwesomeDude> > maximum $ map length ["asdf", "ghjkl", "qwerty"]
11:27:00 <lambdabot>   6
11:27:08 <beaky> wow
11:27:11 <Botje> (note: no warranty implied. code for demonstration purposes only. do not benchmark. contact doctor if swallowed. void where prohibited)
11:27:19 <beaky> lol
11:27:22 <ps-auxw> maxStrLen = maximum . map length -- ;)
11:27:24 <monochrom> @type maximumBy
11:27:25 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
11:27:34 <monochrom> @type comparing
11:27:35 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
11:27:51 <monochrom> maximumBy (comparing length)
11:27:53 <MostAwesomeDude> > maximumBy (comparing length) ["asdf", "ghjkl", "qwerty"]
11:27:54 <lambdabot>   "qwerty"
11:28:11 <monochrom> use a random number to decide which to use
11:28:19 <t7> \dfrac{A \vee (B \vee C)}{\dfrac{A \quad (B \vee C)}{\dfrac {A \quad B \quad C}{\dfrac{(A \vee B) \quad C}{(A \vee B) \vee C}}}}
11:28:36 <armlesshobo> t7: easy to read lol
11:28:36 <monochrom> this is why latex is a write-only language, like perl
11:29:17 <armlesshobo> perl is the only language where the code looks the same before and after passing it through RSA
11:29:21 <armlesshobo> lol
11:29:28 <armlesshobo> (or something like that)
11:30:16 <companion_cube> through md5 :)
11:36:14 <merijn> monochrom: Although I haven't seen anything that's more readable than LaTeX for writing math...
11:36:30 <merijn> If you have, do let me know :p
11:36:56 <armlesshobo> merijn: i thought there was something that could take a more readable form of an equation and convert it for you
11:37:02 <monochrom> I have. A‚à©B is more readable than A \cap B
11:37:30 <merijn> monochrom: unicode is limited to single line math, though
11:37:32 <armlesshobo> merijn: where you could write sqrt( ( 1 + x^2) / (3x^3))
11:37:38 <armlesshobo> and it would do it for you
11:37:47 <armlesshobo> merijn: wolfram alpha
11:37:47 <merijn> Also, I still have no reasonable input format for unicode math symbols
11:37:48 <armlesshobo> lol
11:37:52 <monochrom> sure, use something else to arrange 2D layout
11:37:57 <armlesshobo> type it in there, dl the picture, and incorporate it into work
11:37:58 <armlesshobo> lol
11:41:06 <KBme> hi
11:41:45 <KBme> I already have a version of ghc installed, but i'd like to bootstrap ghc as if I didn't, how could I manage that does anyone know?
11:42:55 <monochrom> latex 2D layout code is as readable as html markdown etc
11:43:25 <merijn> monochrom: In all seriousness, though. How do you input unicode?
11:43:39 <KBme> compose sequences
11:44:25 <merijn> Yes, but I don't fancy coming up with compose sequences for 100 or so characters that I then have to memorise (which I probably won't since I don't use them that often)
11:44:49 <monochrom> I have SCIM and its "additional tables". sadly, it means I still enter \ c a p for ‚à©. but I believe in saving reader's time
11:44:58 <t7> merijn: are you on winblows
11:45:28 <monochrom> you always have my http://www.vex.net/~trebla/symbols/select.html as your last resort
11:45:57 <geekosaur> KBme: -funregisterised generates ANSI C which can be built on another system to build a bootstrap ghc.  performance is lousy, its only real use is as a starting place for building a native optimized one
11:46:29 <hpaste> merijn pasted ‚ÄúFFI auto generation‚Äù at http://hpaste.org/73946
11:46:36 <merijn> t7: OSX
11:46:49 <t7> merijn: because i have abandoned my vim latex name -> unicode plugin in favor of windows anywhere latex -> name unicode app
11:46:50 <monochrom> SCIM is a linux thing
11:47:08 <t7> i spent all day on it at work today instead of working
11:47:39 <KBme> geekosaur, thing is that I havea ghc installed, and it wants to use that to compile but that fails
11:47:40 <monochrom> but you can run virtualbox, put linux and scim in it, enter in it, then copy-paste back out :)
11:47:43 <merijn> Unrelatedly, given the paste I just made, how do I (as automatically as possible, prefferably entirely automatic) turn the C definition into that Haskell definition
11:48:02 <merijn> t7: Can't you make one for OSX? :p
11:48:04 <monochrom> I think c2hs or something does that?
11:48:17 <merijn> monochrom: Yes, but the examples and documentation are wholly awful :(
11:48:38 <monochrom> there are several c2hs-like things for that. I forgot the names of the rest.
11:48:46 <merijn> Or rather, the documentation doesn't have examples and other tutorials are very convoluted spending fifteen gazillion lines talking about other things
11:48:53 <t7> shouldnt the Xorg tools todo this work on mac?
11:49:22 <merijn> I know there's hsc2hs and c2hs, but I can't figure out how to get it done without investing several hours, which seems a waste for something that should be so simple
11:49:31 <merijn> t7: Probably not if you want it to work natively
11:49:55 <t7> you can write the mac frontend for my thing
11:50:06 <t7> requires mono tho
11:50:27 <merijn> blah
11:50:37 <merijn> I saw some universal input interface that works on windows and OSX
11:51:00 <merijn> But the documentation was a bit tricky since most users where chinese/japanese, so the docs where of...questionable understandability
11:51:41 <armlesshobo> merijn: do the one command under which to optimal sun care
11:53:07 <joe9> is this good haskell code? it compiles, but, am more concerned on the structure of the data, style, etc. http://codepad.org/xi8dnaPb
11:54:25 * hackagebot factual-api 0.5.1 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.5.1 (RudigerLippert)
11:54:31 <rosie> I import Data.List (find), but List.find is not in scope. Ideas?
11:54:39 <joe9> i am trying to use typeclasses and types as much as I can.
11:55:35 <monochrom> "import Data.List(find)" introduces the name "Data.List.find". clearly.
11:55:49 <merijn> joe9: Semi-related, if you want to use an existing type as a different one, but with enforced conversion/separate instance (i.e. your Circle type) you can also use newtype
11:56:56 <joe9> merijn: ok, thanks.
11:57:10 <joe9> merijn: do you see anything else that is weird with that code?
11:57:36 <merijn> joe9: The difference is that newtype is eliminated and replaced with the component type at compile time, so "newtype Circle = Circle Int" will be just an Int (but it'll have been typechecked properly, unlike type which just introduces a synonym)
11:57:57 <rosie> monochrom: ah, sorry, referred to a different module altogether
11:58:33 <merijn> joe9: Not very weird, you're indenting looks a bit odd in some places, but that might just be my personal preference or due to the barebones code
11:58:57 <joe9> merijn: yes, this is still very barebones code.
11:59:06 <joe9> i am trying out a few things
11:59:16 <joe9> before I start writing the meat of it.
12:01:08 <joe9> merijn: but, with newtype I cannot pattern match correct?
12:01:49 <c_wraith> the only* way to unwrap a newtype is to pattern-match on its constructor.  *Or call a function that does
12:01:51 <joe9> I mean on the Circle constructor, but, probably, I do not need that.
12:02:09 <merijn> joe9: You can pattern match, but newtypes only allow one constructor
12:02:40 <joe9> ok, thanks. the circle seems to be an ideal case for newtype.
12:02:50 <Eduard_Munteanu> And they can only contain one value.
12:02:58 <Eduard_Munteanu> You can't have multiple fields.
12:05:33 <joe9> http://codepad.org/7MfkXxQR can I have an instance with a typeclass?
12:05:46 <joe9> error http://codepad.org/oqhDZ27Z
12:09:24 <joe9> or, am I going into the Type families world with this?
12:09:25 * hackagebot gtk-traymanager 0.1.3 - A wrapper around the eggtraymanager library for Linux system trays  http://hackage.haskell.org/package/gtk-traymanager-0.1.3 (TristanRavitch)
12:09:27 * hackagebot taffybar 0.2.1 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.2.1 (TristanRavitch)
12:09:29 * hackagebot Ebnf2ps 1.0.11 - Peter's Syntax Diagram Drawing Tool  http://hackage.haskell.org/package/Ebnf2ps-1.0.11 (PeterThiemann)
12:09:48 <merijn> joe9: I don't understand what it's trying to do?
12:09:57 * merijn stabs c2hs
12:10:20 <merijn> Anyone with c2hs/hsc2hs experience around?
12:10:39 <merijn> Before I gauge my eyes out in frustration...
12:11:00 <joe9> merijn: i want to return some Gcode's. I could define the Gcodes as a Gcode data type as in Line 30
12:11:45 <joe9> but, I am also thinking of trying to split out that Gcode into different standalone types.
12:12:19 <joe9> merijn: don't bother. I think I will stick with one function and a Gcode data type. instead of many different types for that.
12:12:26 <merijn> joe9: Line 46 is completely unparsable to me, no clue what it's supposed to achieve
12:12:30 <nestor_> hola
12:12:34 <armlesshobo> nestor_: que tal?
12:12:40 <armlesshobo> bienvenido
12:12:41 <armlesshobo> :)
12:12:52 <nestor_> gracias :)
12:14:45 <rosie> if I say type SomeWords = Text, how should I match a value of type SomeWords against a String if the type SomeWords = Text is not visible in the current module?
12:15:26 <merijn> rosie: "type" is a type synonym, so "SomeWords" and "Text" are identical
12:15:33 <merijn> rosie: Similar to [Char] and String
12:16:49 <merijn> rosie: So you mostly use them for hiding complexer types, if your goal was to make "SomeWords" distinct from Text (i.e. making it a type error to pass a Text to something expecting SomeWords then type is not what you want)
12:17:47 <Fifo> Hi
12:18:08 <shachaf> hi Fifo. hifo
12:19:55 <armlesshobo> nestor_: como te podemos ayudar?
12:20:36 <Fifo> I‚Äôm currently logged in with an iPhone (it‚Äôs possible)!
12:21:27 <Botje> next step: use vi from your phone. it's fun :)
12:22:00 <srhb> Conversely, using Emacs from your phone is distinctly nonfun.
12:22:01 <Eduard_Munteanu> Does that make it a ViPhone? :P
12:23:24 <Fifo> It's not possible to run Vi or Emacs on the iPhone.
12:23:31 <srhb> Sure it is
12:24:03 <Fifo> No it's not!
12:24:16 <shachaf> srhb: I think Fifo won this one.
12:24:20 <shachaf> Sorry.
12:24:31 <srhb> Well, since you put an exclamation point after. I yield.
12:25:04 <t7> http://www.vex.net/~trebla/humour/missing_dollar.html wut?
12:25:14 * geekosaur has run vim on iphone.  (jailbroken...)
12:25:22 <geekosaur> not especially friendly...
12:25:54 <srhb> Better than Emacs, still :P I tried both.
12:25:54 <Fifo> Cool! My iPhone is jailbroken too!
12:25:58 <srhb> ....
12:26:01 * srhb slaps Fifo
12:26:23 <srhb> <_<
12:26:46 <t7> vim is in the app store
12:27:27 <gwern> > 5 * 1.22
12:27:28 <lambdabot>   6.1
12:28:13 <Fifo> I'm back
12:28:25 <Botje> had to take a call? :P
12:28:39 <Fifo> Yes :P
12:29:15 <Botje> tell them to ping you on irc instead
12:29:25 <Botje> much more civilized
12:29:40 <Fifo> I will tell them
12:29:41 <meursault> anyone here good at understanding haskell parallel performance?
12:29:47 <Eduard_Munteanu> You have to close the browser to take a call?
12:30:06 <Fifo> Yes because I needed to open the Phone app.
12:30:12 <monochrom> my Perils of Functional Algorithm Design has arrived!
12:30:17 <Eduard_Munteanu> meursault: you never know if you don't ask :)
12:30:31 <t7> this is why apple is shit
12:30:35 <t7> multitasking
12:31:41 <shachaf> t7: Please don't feed the trolls.
12:31:44 <Fifo> The iPhone has nultitasking, but it does not save the app's state in the memory
12:31:46 <shachaf> And don't troll yourself.
12:31:48 <timthelion> t7: is that the only thing you find wrong with the firm?  Their software?  You don't find them too morally repulsive to get so far as to evaluate their technology?
12:31:59 <shachaf> timthelion: You too.
12:32:08 <t7> yeah i have a mental list
12:32:30 <aib> :r
12:32:32 <aib> oops
12:32:52 <t7> but i havnt ranted about apple yet today
12:32:55 <t7> :(
12:33:10 <t7> aib: i kept doing that in vim, it repeats the whole file
12:33:10 <shachaf> Go do it in #not-haskell
12:33:12 <timthelion> Me neither.
12:33:15 <meursault> I have two pieces of code "testSumSqrPar = sum (parMap rdeepseq sqrt [1..1000000])" and "testSumSqr = sum (map sqrt [1..1000000])" The second one evaluates in 1/50th of the time of the first one - any ideas what I am doing wrong? If I want decent parallel performance on a data parallel problem is my only real answer to split the list into different lists and use different rheads?
12:33:23 <aib> t7: ouch!
12:34:49 <shachaf> meursault: I doubt that thing is worth parallelizing...
12:34:56 <Fifo> I'm back; there was another call.
12:35:12 <t7> popular
12:35:57 <meursault> that particular case isn't worth parallelizing but if I can't even get it close the case I need won't be either - the case I need is 15 -200 million 3 vectors and a bunch of properties - having a map computation applied to selected properties or components of the vector
12:36:34 <Fifo> lambdabot: let villain = (28,"chirs") in fst villain
12:37:27 <armlesshobo> Fifo: why not snd?
12:37:40 <beaky> What is the difference between a monad and a functor?
12:37:44 <meursault> I'm just trying to understand where I went wrong in terms of the parallel version takes 5 seconds and non parallel version takes 1 second
12:38:55 <roconnor> beaky: a monad is a functor with join and return operations
12:39:07 <beaky> right
12:39:11 <shachaf> meursault: Probably overhead from too-fine-grained parallelism?
12:39:13 * Eduard_Munteanu isn't sure if beaky asked *that* question
12:39:48 <Eduard_Munteanu> beaky: normally Monad should require Functor but it doesn't.
12:39:49 <Botje> beaky: the typeclassopedia has a nice explanation of how you can 'grow' a functor into a monad.
12:40:06 <Botje> beaky: it also has a neat graph.
12:40:24 <Fifo> > let villain = (28,"chirs") in fst villain
12:40:25 <lambdabot>   28
12:40:45 <Eduard_Munteanu> Also, not all functors are monads but all monads are functors.
12:42:56 <startling> @pl \fn -> (>>= return . fn)
12:42:56 <lambdabot> fmap
12:43:16 <Botje> haha, clever \bot
12:43:22 <spobat> why some functinos have a '?
12:43:28 <spobat> like meeeep'
12:43:32 <spobat> and then.. meeeep''
12:43:35 <Eduard_Munteanu> @botsnack
12:43:35 <lambdabot> :)
12:43:36 <startling> spobat: it's the same as every other character
12:43:45 <spobat> What's the intention behind it?
12:43:49 <spobat> behind naming functions like this?
12:44:03 <Yuu-chan> spobat: it's something like a "modified meeeep"
12:44:05 <startling> spobat: "meep' is sort of like meep but different"
12:44:06 <Eduard_Munteanu> spobat: they're usually variants of the function, but it's not something specific
12:44:20 <spobat> Okay
12:44:29 <Eduard_Munteanu> Like foldl and foldl' where foldl' is a strict variant of the former.
12:44:40 <Yuu-chan> ' is used often in the math this way
12:44:57 <spobat> k
12:45:39 <hiptobecubic> I can find a lot of papers talking about how great automatic differentiation is, but very few that demonstrate it on a problem which isn't a toy, specifically designed to show if off.
12:45:40 <Yuu-chan> > reverse "(:"
12:45:41 <lambdabot>   ":("
12:46:27 <Botje> hiptobecubic: I vaguely remember a couple of blog posts that abused Num for that.
12:46:39 <hiptobecubic> Botje, yes, there are many.
12:46:59 <hiptobecubic> I'm talking about using it the way the papers talk about it. In large-scale simulations, for example.
12:47:12 <Botje> ah :)
12:47:56 <spobat> > 3
12:47:57 <lambdabot>   3
12:48:55 <spobat> 3 still seems to be... 3
12:49:37 <blue_> hi everyone
12:49:45 <Botje> hallo
12:49:48 <spobat> hi blue_
12:50:20 <ion> Œª> data Four = Four; instance Show Four where { show _ = "4" }; instance Num Four where { fromInteger _ = Four }
12:50:23 <ion> Œª> 3 :: Four
12:50:25 <ion> 4
12:51:42 <djahandarie> newtype What = What Int; instance Show What where {show (What i) = show $ i+1}; instance Num What where { fromInteger = What }
12:51:44 <t7> > let 3 = 4 in 3
12:51:45 <lambdabot>   3
12:52:48 <t7> :t (let id = \x -> x in id id id) (let id = \x -> x in id id id) (let id = \x -> x in id id id) (let id = \x -> x in id id id) (let id = \x -> x in id id id) (let id = \x -> x in id id id)
12:52:49 <lambdabot> forall t. t -> t
12:53:16 <t7> :t (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x i
12:53:17 <lambdabot> parse error (possibly incorrect indentation)
12:53:24 <t7> :t (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id) (let id = \x -> x in id id id (id id) id id id id id id id)
12:53:26 <lambdabot> forall t. t -> t
12:53:29 <ousado> ??
12:53:38 <t7> so fast
12:54:07 <aib> I'm trying to get the nth cartesian exponent (series of cartesian products) of a list: nth 3 [0..9] will give me 000, 001 ... 999 (3^10) results. (sequence . take n . repeat $ ns) is working fine, but I was wondering if there was a more "monadic" way, something along the lines of (take n (foldr1 <*> (repeat ns))) maybe
12:54:47 <n-dolio> replicateM?
12:55:03 <n-dolio> > replicateM 3 [0..9]
12:55:04 <lambdabot>   [[0,0,0],[0,0,1],[0,0,2],[0,0,3],[0,0,4],[0,0,5],[0,0,6],[0,0,7],[0,0,8],[0...
12:55:26 <Eduard_Munteanu> @type let m = fmap . fmap . fmap; n = m . m . m in n . n . n . n . n
12:55:28 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *) (f7 :: * -> *) (f8 :: * -> *) (f9 :: * -> *) (f10 :: * -> *) (f11 :: * -> *) (f12 :: * -
12:55:28 <lambdabot> > *) (f13 :: * -> *) (f14 :: * -> *) (f15 :: * -> *) (f16 :: * -> *) (f17 :: * -> *) (f18 :: * -> *) (f19 :: * -> *) (f20 :: * -> *) (f21 :: * -> *) (f22 :: * -> *) (f23 :: * -> *) (f24 :: * -> *) (
12:55:28 <lambdabot> f25 :: * -> *) (f26 :: * -> *) (f27 :: * -> *) (f28 :: * -> *) (f29 :: * -> *) (f30 :: * -> *) (f31 :: * -> *) (f32 :: * -> *) (f33 :: * -> *) (f34 :: * -> *) (f35 :: * -> *) a b (f36 :: * -> *) (
12:55:28 <lambdabot> f37 :: * -> *) (f38 :: * -> *) (f39 :: * -> *) (f40 :: * -> *) (f41 :: * -> *) (f42 :: * -> *) (f43 :: * -> *) (f44 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4, Functor f5,
12:55:28 <lambdabot>  Functor f6, Functor f7, Functor f8, Functor f9, Functor f10, Functor f11, Functor f12, Functor f13, Functor f14, Functor f15, Functor f16, Functor f17, Functor f18, Functor f19, Functor f20,
12:55:30 <lambdabot> [5 @more lines]
12:55:51 <identity> Can you guys recommend a good JSON package from hackage?
12:55:53 <Eduard_Munteanu> t7: is that what you were looking for
12:55:54 <t7> @djynn \a b c d e f g h i j k -> b -> c -> f -> h -> h -> c
12:55:54 <Eduard_Munteanu> ?
12:55:54 <lambdabot> Cannot parse command
12:56:01 <timthelion> I wonder if we can get lambdabot kicked for flooding :D
12:56:05 <parcs`> identity: people like aeson
12:56:15 <t7> Eduard_Munteanu: yeah :)
12:56:24 <identity> parcs`: thanks
12:56:29 <t7> or just make it timeout
12:56:37 <parcs`> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
12:56:52 <lambdabot> thread killed
12:56:57 <parcs`> yay
12:56:58 <allsystemsarego> what does lambdabot do with @pl? what is that command for?
12:57:02 <sipa> @pi
12:57:02 <lambdabot> pong
12:57:04 <t7> wooo
12:57:08 <aib> n-dolio: both sequence and replicate are list-specific. some solution that doesn't explicitly specify lists would help me understand monads better, I'm thinking
12:57:10 <parcs`> allsystemsarego: it removes lambdas from an expression
12:57:12 <Eduard_Munteanu> @help pl
12:57:12 <lambdabot> pointless <expr>. Play with pointfree code.
12:57:30 <Eduard_Munteanu> allsystemsarego: it converts pointful code to pointfree style
12:57:34 <allsystemsarego> aha, I see
12:57:41 <allsystemsarego> thanks
12:57:43 <Eduard_Munteanu> @pl \x -> f x
12:57:43 <lambdabot> f
12:57:52 <Eduard_Munteanu> @unpl f
12:57:53 <lambdabot> f
12:58:03 <Eduard_Munteanu> @unpl \x -> f x
12:58:03 <lambdabot> \ x -> f x
12:58:45 <identity> parcs`: Happen to have a preferred HTTP library? I don't like 'HTTP'. I needs https as well
12:58:46 <Eduard_Munteanu> @. unpl pl fmap fmap fmap
12:58:47 <lambdabot> fmap fmap fmap
12:58:47 <dgpratt> @unpl f . g
12:58:47 <lambdabot> (\ c -> f (g c))
12:59:08 <identity> http-enumerator any good?
12:59:14 <identity> oh, http-conduit is its replacement
13:00:14 <spark_> im having a problem
13:00:46 <spark_> my code outputs data on ghci, but it seems that it doesnt give output on compiled
13:00:56 <spark_> let me paste it
13:01:16 <jang> I've a quick question. I'm a relative Haskell newbie. I'm looking at a probabilistic algorithm - which (given a weighted random decision maker) has a very neat functional expression. What I'm interested in is if there's any funky machinery to take that expression and evaluate _every_ path, annotating the resulting executions/results with a probabilistic measure?
13:02:36 <hpaste> spark_ pasted ‚Äúlazy bytestring weird behaviour?‚Äù at http://hpaste.org/73948
13:05:25 <joe9> is it wrong to have orphan instances. Why does ghci -Wall give a warning about it?
13:05:58 <ziman> jang, that sounds like a work for some nondeterministic monad; if you just take the list monad, you already traverse every path, just not counting the probabilities
13:07:28 <jang> yeah. only, my experience of Haskell is that "monad" is shorthand for (a bit of handwaving and delegating to some insanely clever library or other). What I'm asking is if anyone knows of such a beast in this instance.
13:08:02 <jfischoff> joe9: it slows down compilation. Its explained more in the ghc user guide.
13:08:12 <joe9> jfischoff: ok, thanks.
13:08:49 <johnw> jang: could you just do a map that returns a list of pairs, to provide your annotation along with results?
13:09:27 <spark_> yay my first true bug encounter
13:09:37 <spark_> If I do ghci > main, it prints to the file
13:09:53 <spark_> it i do ghc myfile.hs && myfile.exe, it doesnt print
13:10:10 <ziman> http://hackage.haskell.org/packages/archive/probability/0.2.4/doc/html/Numeric-Probability-Distribution.html#t:T -- possibly?
13:10:19 <jang> hrm, possibly. I can certainly carry along probabilistic measures "by hand" and force the evaluation of every randomly-selected alternative. What I was wondering is whether someone'd knocked up something clever that'd sugar my regular haskell function definitions with the machinery to do that for me, automatically.
13:10:45 <jang> (fortuantely, the algorithm in question most definitely terminates, so I don't have to worry about ratholing)
13:11:03 <jang> (most definitely terminates in bounded time, I should have said)
13:12:28 <identity> Hmm.. Aeson expects you to write parsers that decode the data into your own datatypes directly? Is there no way to return the parsed 'json structure' as such?
13:13:36 <ocharles> Is it possible to define |&| such that a |&| b |&| c |&| d == a &&& (b &&& (c &&& d)) ?
13:13:57 <ocharles> actually ,let me expand that example
13:14:35 <ocharles> it's more like foo ^>> bar |&| wob ^>> baz == (foo ^>> bar) |&| (wob ^>> baz)
13:14:45 <hpaste> lpvb pasted ‚ÄúException: Prelude.head: empty list‚Äù at http://hpaste.org/73952
13:14:53 <lpvb> anyone know why I get that^
13:14:54 <ocharles> I've tried infixr |&| 1, but I think because ^>> has infixl 1, the ^>> is taking precedance
13:15:18 <ziman> jang, this appears to work: http://hpaste.org/73951
13:15:44 <jang> oooooh, that looks promising.
13:15:55 <parcs`> identity: http-conduit
13:16:33 <Cale> ocharles: I don't think you should be able to mix operators with the same precedence in an expression without parenthesising them
13:16:38 <c_wraith> identity: you can parse into Aeson.Value if you want the generic tree
13:16:40 <ziman> if you use the Applicative instance instead of the Monad one, you can get nice applicative formulas instead of (sometimes unnecessary) do-blocks ;)
13:16:49 <ocharles> Cale: that's a shame :(
13:16:51 <Cale> (different operators)
13:16:56 <ocharles> but it makes sense
13:17:07 <Cale> You'll have to give them different precedence levels
13:17:09 <parcs`> identity: you probably want to parse a 'Value' if you want the json structure
13:17:17 <jang> ziman, that's a tad beyond my (utterly newbie) haskell knowledge, but it gives me something concrete to read up on. Thanks very much!
13:17:24 <parcs`> (which is an instance of FromJSON)
13:17:28 <ocharles> https://gist.github.com/5c86d01e72bd21c3ac81 is what I'm trying to get work, with less parethesis
13:17:30 <ocharles> because this is starting to walk
13:18:08 <Cale> It looks like maybe you want |&| to have precedence level 0
13:18:15 <ocharles> oh, I didn't know you could go down to 0
13:18:51 <spark_> Can someone share a light? Tried to explain my bug the best here http://stackoverflow.com/questions/12204821/lazy-bytestring-strange-behaviour-or-bug
13:19:29 <Cale> spark_: You didn't close the filehandle
13:19:40 <Cale> spark_: or hFlush it
13:19:45 <Cale> hmm
13:19:54 <spark_> Cale: I never needed that before @.@
13:20:08 <Cale> oh wait
13:20:24 <Cale> you said you compiled the program with ghc, but did you actually run it after that?
13:20:26 <jang> ziman: looks just the ticket, thanks. Has conditional probability support. I _do_ like the haskell community. They seem to have already solved my problems. There's none of this "first, implement your own evaluation engine" nonsense :-)
13:20:28 <spark_> shouldnt it close automatically when the process ends?
13:20:35 <spark_> yes, ofc, test3.exe
13:20:44 <spark_> it overwrites the file to a 0kb file
13:20:48 <Cale> yeah, I think it should, as long as you don't exit abnormally
13:20:59 <spark_> the weird thing is
13:21:17 <spark_> on my other code my type was bytestring ->lazybytestring on interval finder
13:21:38 <spark_> and changing interval finder to map (bl.pack . b.pack) outputs to the file correctly
13:21:48 <spark_> ops
13:21:52 <spark_> and changing interval finder to map (bl.pack . b.unpack) outputs to the file correctly
13:22:15 <ziman> jang, yes, hackage has grown considerably :)
13:22:31 <Cale> spark_: Yeah, I think just calling hClose filehandle is the solution
13:22:45 <Cale> spark_: I tried that here, and it made the program work correctly.
13:22:46 <spark_> ok
13:22:53 <ocharles> https://gist.github.com/5c86d01e72bd21c3ac81 woohoo, now that's looks sweet
13:23:00 <spark_> Cale: thank you!
13:23:12 <spark_> Cale:  but is there an explanation for behaving like that?
13:24:22 <spark_> maybe before the output was so big that hputstring was outputing parts of data to the file?
13:24:37 <ocharles> Is there a way to make arrows run in parallel? ie, a fanout can be performed in parallel
13:24:40 <Cale> spark_: Well, if the output is, say, line buffered, then writing newlines will cause the file to actually be written.
13:24:50 <ocharles> or will haskell in fact just do that?
13:24:52 <Cale> If it's block buffered, then you just have to write enough data
13:25:34 <Cale> I believe when you compile your program, opened file handles default to block buffering.
13:25:35 <spark_> Cale: the default behaviour is line buffered?
13:25:55 <spark_> ah
13:26:01 <spark_> yeah, blocks makes more sense in fact
13:26:05 <Cale> ocharles: depends on the arrow
13:26:39 <Cale> ocharles: and Haskell will never automatically parallelise anything without your use of operations that are explicitly parallel
13:26:41 <ocharles> I see. In this case the majority (or at least the ones I'd like to run in parallel) are Kleisli IO
13:27:36 <Russel-Athletic> hiho
13:27:40 <Cale> hello
13:28:09 <Russel-Athletic> i just try to learn a bit of haskell and for fun i ported some common lisp code directly to haskell
13:28:09 <Cale> ocharles: You could write something which uses some MVars to wait on the results of the two computations.
13:28:17 <Russel-Athletic> but i am wondering because in haskell it is a lot slower
13:28:36 <Russel-Athletic> somebody wants to look at roughly 40 lines of code to help me to learn why it is slow?
13:28:55 <Cale> Russel-Athletic: If you directly translate code which was written to be efficient under strict evaluation, then performance will usually be poor.
13:29:18 <Cale> I can have a quick look
13:29:50 <hpaste> Russel-Athletic pasted ‚Äútest code‚Äù at http://hpaste.org/73955
13:29:56 <Cale> ocharles: Kleisli IO is a poorly-behaved arrow though, sadly.
13:29:59 <Russel-Athletic> there it is
13:30:19 <Russel-Athletic> but i don't think it uses very much the fact that it is strict evaluation
13:30:34 <Cale> btw, the usual way to indent if/then/else is like:
13:30:36 <Cale> if foo
13:30:37 <Cale>    then bar
13:30:40 <Cale>    else quux
13:31:02 <Russel-Athletic> oh makes sense
13:31:27 <roconnor> Russel-Athletic: was the list code using arbitrary precision rational numbers?
13:31:32 <roconnor> *lisp code
13:31:58 <Russel-Athletic> i was only using fixnum in lisp
13:32:04 <Russel-Athletic> which could be the problem
13:32:52 <Cale> Russel-Athletic: another thing to note is that you don't have to nest lets like that
13:32:57 <Cale> let foo = 1
13:32:59 <Cale>     bar = 2
13:33:05 <Cale>  in foo + bar
13:33:09 <Russel-Athletic> oh nice
13:33:13 <Russel-Athletic> that is different in lisp :)
13:33:29 <Cale> the definitions in each let are allowed to be mutually recursive as well
13:33:46 <Cale> So it's really like lisp's letrec* or whatever it's called
13:33:49 <Russel-Athletic> so do you think the slowdown is only because haskell uses non-fixnum values?
13:33:56 <spark_> he, introducing one function in the core chain of functions in my program reduced the run-time memory use by half
13:34:05 <roconnor> if denominator x == 1 then True else False can be simplified to (denominator x == 1)
13:34:19 <Cale> Russel-Athletic: this runs in 0.5s on my machine
13:34:28 * hackagebot factual-api 0.5.2 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.5.2 (RudigerLippert)
13:35:18 <Cale> Russel-Athletic: Try compiling with -O
13:35:36 <Russel-Athletic> my lisp code on my machine is 0.13 sec and my haskell is in 4 sec
13:35:49 <Cale> ah, it does run quite a lot slower if you don't compile with optimisations turned on
13:36:16 <Russel-Athletic> i did ghc -O -o test test.hs
13:36:20 <Russel-Athletic> which should be optimizations
13:36:23 <Cale> yes
13:36:30 <Russel-Athletic> still 4 seconds
13:36:32 <Cale> weird
13:36:36 <Cale> Which GHC is that?
13:36:41 <Russel-Athletic> 7.4.1
13:36:49 <lightquake> did you try -O2?
13:36:49 <Russel-Athletic> debian testing or stable
13:36:56 <Russel-Athletic> lightquake: yeah, doesn't really change much
13:37:07 <jfischoff> has anyone used the zeroth package before? Does it work? Here's the link http://hackage.haskell.org/package/zeroth-2009.6.23.3
13:37:39 <lightquake> it takes about 1 second on my machine, using ghc 6.12
13:37:50 <Cale> Russel-Athletic: well, okay, let's just rewrite it a bit more idiomatically and see if it gets better. Let me take a moment to figure out what this is actually computing.
13:38:11 <Russel-Athletic> thanks :)
13:38:17 <Cale>  if denominator x == 1 then True else False  <-- this is silly btw
13:38:19 <spark_> why the smaller -o?
13:38:21 <Russel-Athletic> but still weird if it takes long on my machine
13:39:09 <Russel-Athletic> oh now i know why it takes so long
13:39:11 <ocharles> Cale: poorly behaved in what sense?
13:39:20 <Russel-Athletic> ghc doesn't actually remove all files it compiled
13:39:28 <Russel-Athletic> so i had unoptimized stuff still in my directory
13:40:06 <Cale> ocharles: hm?
13:40:34 <ocharles> Cale: you mentioned Kleisli IO might not be as glorious as I think it is (as an arrow)
13:40:40 <Cale> ocharles: oh, right
13:40:49 <lightquake> spark_: -o specifies the location of the output executable
13:41:05 <Cale> ocharles: It fails the law  (a >>> b) *** (c >>> d) = (a *** c) >>> (b *** d)
13:41:09 <jang> oh, right. Now I think I understand monads. Also, the penny has dropped about where the name came from; that's quite cute.
13:41:21 <Saizan> can someone tell me if syb-with-class builds on 7.4.2 ?
13:41:54 <Cale> ocharles: which the original paper by Hughes explicitly rejected in order that arrows would generalise monads, but which I think is kind of essential for arrows to make sense as an abstraction.
13:42:01 <roconnor> Cale: does Kleisli state statisfy that?
13:42:06 <Cale> no
13:42:13 <Cale> But most FRP arrows *do* satisfy that
13:42:15 <spark_> lightquake: ahh, i see, thanks
13:42:17 <roconnor> oh
13:42:20 <Cale> including, e.g. Yampa
13:42:20 <ocharles> hmm
13:42:37 <ocharles> using things that openly break laws does not fill me with joy...
13:42:49 <Cale> Kleisli m will satisfy that iff m is a commutative monad.
13:43:29 <ocharles> I will hopefully be dropping down from IO to something a bit more constrained, so maybe what that is can meet that law when it becomes an arrow
13:43:38 <Cale> ocharles: Basically, it means that the wiring diagrams that people tend to draw for arrows won't actually make any sense for it.
13:43:56 <Cale> (unless you explicitly show how things are built up with boxes)
13:44:07 <ocharles> I'm trying to model a way to start with really simple records and sort of join things together in memory to create larger records (ala HList), via database access
13:44:29 <Cale> to see this, draw the diagram for  (a >>> b) *** (c >>> d)  and the diagram for  (a *** c) >>> (b *** d) and compare them
13:44:32 <ocharles> arrows felt like a good fit for moving around the various levels of data and plumbing things together to reduce calls
13:44:37 * ocharles grabs a pen
13:45:31 <hpc> Cale: is there an algebraic law that corresponds to that, i wonder?
13:45:46 <hpc> it looks suspiciously distributive
13:45:52 <Cale> hpc: It's called the interchange law
13:46:05 <ocharles> so that's basically 2 'parallel' computations?
13:46:10 <Cale> ocharles: yeah
13:46:16 <ocharles> i see how they are equivilent
13:46:20 <hpc> Cale: link? im getting financial results
13:46:26 <ksf> :t uncurry
13:46:27 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:46:35 <ksf> Russel-Athletic, ^^^
13:46:50 <ksf> instead of that lambda lines 31..24
13:46:52 <ksf> *34
13:46:55 <Cale> http://en.wikipedia.org/wiki/2-category
13:47:03 <Cale> http://planetmath.org/InterchangeLaw.html
13:47:22 <hpc> ooh
13:47:23 <Russel-Athletic> ksf: `
13:47:25 <Russel-Athletic> ksf: ?
13:47:29 <ksf> line 30, concat . map == concatMap (or List's >>=)
13:47:44 <Cale> hpc: did you see my response?
13:47:45 <Russel-Athletic> oh ok thanks
13:47:49 <hpc> and that's where the "monads are monads in the 2-category of categories" joke comes from?
13:47:50 <Cale> hpc: in pm last night?
13:47:55 <hpc> oh, yes
13:47:56 <ksf> Russel-Athletic, you can change lines 31 to 34 to map (uncurry test_op)
13:48:16 <hpaste> author annotated ‚Äútest code‚Äù with ‚Äútest code (annotation 1)‚Äù at http://hpaste.org/73955#a73956
13:48:28 <hpaste> lpvb pasted ‚ÄúException: calcRPN.hs:(12,7)-(15,27): Non-exhaustive patterns in case‚Äù at http://hpaste.org/73957
13:48:40 <lpvb> I get that ^^^ when doing parseRPN "3 3 +"
13:48:46 <Russel-Athletic> thanks
13:48:47 <lpvb> :(
13:49:05 <lpvb> why is it trying to pattern match that with the 2nd definition?
13:49:23 <shachaf> lpvb: Because "(x:xs) token" matches your argument.
13:50:07 <shachaf> Arguments.
13:50:21 <shachaf> So it's going into the function body. What else should it do?
13:50:41 <lpvb> shachaf, but (x:y:ys) matches it first?
13:50:45 <monochrom> @type foldl
13:50:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:51:05 <lpvb> it should match "3 3 +" to (y:x:ys)
13:51:48 <monochrom> no, y:x:ys is your stack, token is "3" or "3" or "+"
13:52:12 <lpvb> that's my stack of numbers with ["3","3"] on it
13:52:16 <lpvb> token is "+"
13:52:27 <shachaf> lpvb: Oh, I misunderstood.
13:52:38 <lpvb> should match ["3","3"] with (y:x:ys) to (3:3:[])
13:52:40 <lpvb> ?
13:52:55 <lpvb> if not, how would I do this better?
13:53:05 <monochrom> what does foldl do?
13:53:32 <hpaste> author annotated ‚Äútest code‚Äù with ‚Äútest code (annotation 2)‚Äù at http://hpaste.org/73955#a73958
13:53:33 <lpvb> accumulates numbers, and if comes accross a function, evaluate the function with arguments on the stack
13:53:35 <jang> monochrom: it's a list reduction that works from the left-hand-side
13:53:40 <Russel-Athletic> mhhh what does liftM2 do?
13:53:49 <shachaf> Russel-Athletic: Cartesian product.
13:53:50 <monochrom> > foldl f 0 [a,b,c]
13:53:52 <lambdabot>   Ambiguous occurrence `f'
13:53:52 <lambdabot>  It could refer to either `L.f', defined at <local...
13:53:54 <shachaf> With a specified function.
13:53:58 <monochrom> > foldl f 0 [a,b,c] :: Expr
13:53:58 <Russel-Athletic> why is it called liftM2?
13:53:59 <lambdabot>   Ambiguous occurrence `f'
13:53:59 <lambdabot>  It could refer to either `L.f', defined at <local...
13:54:03 <shachaf> > liftM2 (,) [1,2,3] "abc"
13:54:04 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
13:54:06 <monochrom> @undefine
13:54:07 <monochrom> > foldl f 0 [a,b,c] :: Expr
13:54:08 <lambdabot>   f (f (f 0 a) b) c
13:54:28 <shachaf> Russel-Athletic: Because it "lifts" a function that works on a single pair of items to a function that works on a pair of lists.
13:55:04 <shachaf> Russel-Athletic: (liftM2 also does a whole bunch of other things. But when you use it on lists it does cartesian product.)
13:55:14 <Russel-Athletic> mhhh
13:55:16 <Russel-Athletic> ok thanks
13:55:19 <shachaf> Another way of writing liftM2 f l1 l2 is [f x y | x <- l1, y <- l2]
13:55:23 <lightquake> lpvb: you have no rule for what happens if there's at least one token on the stack, and it encounters something that isn't sin, cos, or tan
13:55:28 <Russel-Athletic> i guess i still need to learn  a lot more haskell :)
13:55:41 <BrazilianCCStude> Hi guys!!
13:55:54 <tdammers> shachaf: that one only works for lists though, right?
13:55:58 <monochrom> oh, right, stack is "3":[] and token is "3"
13:56:06 <lpvb> lightquake: isn't that the last one, foldingFunction xs token = (read token::Double):xs
13:56:07 <shachaf> tdammers: Unless you have -XMonadComprehensions
13:56:15 <tdammers> ah, hm, k
13:56:27 <lpvb> I tried adding _ -> (read token::Double):xs
13:56:27 <Cale> lpvb: the (x:xs) token one matches first
13:56:31 <lpvb> to the end of the second case
13:56:32 <shachaf> lpvb: That one only gets matched if neither of the others gets matched.
13:56:32 <lightquake> yeah
13:56:33 <spark_> (,) == zip?
13:56:36 <monochrom> stack 3:[] clearly matches x:xs which comes first
13:56:39 <lpvb> but that also gives me read error
13:56:39 <lightquake> once the (x:xs) matches it doesn't 'let go' when the case fails
13:56:48 <BrazilianCCStude> brazillian here?
13:57:55 <spark_> BrazilianCCStude: most haskellers are from outer-space
13:58:07 <monochrom> In general "3 3 4 + +" crashes your logic
13:59:27 * armlesshobo nods
13:59:28 * hackagebot test-simple 0.1.5 - Simple Perl inspired testing  http://hackage.haskell.org/package/test-simple-0.1.5 (BorisSukholitko)
13:59:36 <spark_> You know what would be helpfulll in irc? In place of having a big damn list where everyones talking, having small windows for every topic of conversation in channel
14:00:03 <armlesshobo> spark_: that just sounds annoying
14:00:13 <dncr> next you'll want to get rid of TERM!
14:00:16 <shachaf> Feel free to make it workable and get people to use it.
14:00:33 <hpaste> lpvb pasted ‚ÄúException: Prelude.read: no parse‚Äù at http://hpaste.org/73959
14:00:37 <spark_> armlesshobo: when there are 5 diferent topics, having 5 windows seems better than sorting out the blob yourself
14:00:37 <monochrom> I like writing one sentence that applies to two or more conversations
14:00:38 * dncr wants each program output to be separated
14:00:38 <ksf> spark_, IRC does have that.
14:00:39 <GaloDoido> hi
14:00:40 <lpvb> then what about that?
14:00:44 <ksf> spark_, it's called channels.
14:01:00 <spark_> ksf: hahaha I know, but I'm saying, channels inside channels
14:01:08 <shachaf> whoa, dude
14:01:15 <tdammers> spark_: "Yo dawg, I heard you liked channels..."
14:01:24 <spark_> we need to go deeper
14:01:35 <spark_> they would be lambda channels, without names
14:01:44 <tdammers> channels all the way down
14:01:50 <lightquake> lpvb: what line do you get the 'read: no parse on?
14:02:05 <lpvb> doesn't say
14:02:06 <dncr> it sounds a lot like email..
14:02:08 <hpc> > fix ("#" ++) -- channels within channels, FOREVER
14:02:10 <lambdabot>   "##########################################################################...
14:02:17 <lpvb> used parseRPN "3 3 +"
14:02:26 <lightquake> oh hm it doesn't show
14:02:53 <johnw> > fix (\f x -> x : f x) '#'
14:02:54 <lambdabot>   "##########################################################################...
14:03:35 <dncr> (cycle "#") hits the sweet spot for me
14:03:40 <johnw> lol
14:04:02 <lightquake> lpvb: oh, the problem is that in the line you added you're getting rid of the top element on the stack
14:04:25 <ousado> is there a haskell-only database/-store based on Data.Data?
14:04:48 <hpc> ousado: you probably want acid-state
14:04:52 <hpc> which is not quite the same thing
14:04:56 <beaky> How do I build a haskell program with autotools?
14:05:14 <johnw> the same way you'd build anything with autotools
14:05:23 <hpc> with great difficulty
14:05:27 <Jurily> eww
14:05:28 <shachaf> By trying to take over the world!
14:05:38 <beaky> I use autotools for all my projects
14:05:39 <dncr> how do i fix this error from "ghc-pkg check": Warning: haddock-interfaces: /home/danl/.cabal/share/doc/csv-conduit-0.3/html/csv-conduit.haddock doesn't exist or isn't a file
14:05:41 <monochrom> how does autotools come into the picture?
14:05:46 <johnw> even better, rewrite cabal in m4
14:05:51 <ousado> hpc: woo
14:05:53 <beaky> ah so I use cabal?
14:05:57 <ousado> hpc: thanks
14:05:58 <johnw> yes :)
14:06:00 <dncr> reinstalling the package doesn't help
14:06:06 <johnw> autotools is unnecessary
14:06:13 <johnw> cabal already works on all platforms
14:07:00 <lpvb> lightquake: I'm confused... after "3 3 +" it should match the first one and recduce to "6" and be done?
14:07:03 <monochrom> dncr: it just means you didn't build docs. it is not an error.
14:07:19 <dncr> monochrom: but i did build docs!
14:07:21 <spark_> the day cabal may install c bindings, it shall take over the world
14:07:30 <johnw> dncr: you have "documentation: true" in your ~/.cabal/config?
14:07:36 <lightquake> lpvb: no, because after "3 3" the stack is still just [3.0]
14:07:51 <dncr> johnw: yes
14:07:58 <lightquake> because when you match [3.0] "3" against  (x:xs) token, x is [3] and xs is []
14:08:14 <lpvb> oh I see
14:08:25 <c_wraith> fortunately, you don't need autotools with haskell.  most of the time.  (except for some bindings to native libs)
14:09:09 <lpvb> lightquake: okay, fixed it by doing ys@(x:xs) and appending the element to ys, thanks
14:09:18 <lpvb> tyvm
14:10:57 <dncr> looks like Haddock bails
14:11:11 <dncr> the package doc must be broken
14:11:39 <spark_> in profiling
14:11:40 <rosie> merijn: thanks
14:11:45 <spark_> when i have function.\
14:11:51 <spark_> what the \ stands for?
14:12:25 <johnw> a little more context?
14:12:32 <rosie> Which command produces this output? "Could not find module ‚Ä¶ Use -v to see a list of the files searched for."
14:12:46 <spark_> noiseEnergy  x = (Vu.foldl' (\b a-> b+(magnitude a)) 0 (Vu.drop 1 x))/32
14:12:48 <monochrom> ghc
14:12:51 <Mon_Ouie> It's part of the syntax to define lambda functions
14:12:53 <spark_> noiseEnergy.\                 Main                  31.6   17.6
14:13:04 <johnw> rosie: ghc?
14:13:14 <rosie> thanks monochrome and johnw
14:13:28 <johnw> I have no idea what that second line means
14:13:47 <spark_> johnw: it's a line from the .prof
14:13:56 <spark_> johnw: from running the profiler
14:13:57 <johnw> oh
14:14:01 <johnw> it's profiling the lambda
14:14:11 <spark_> ahhhh
14:14:12 <johnw> it means your lambda is being executed often
14:14:19 <spark_> so .\ means lambda, ok!
14:14:23 <johnw> no surprise in a foldl
14:14:26 <Hadaka> silly question - there's a flag, -XNoTraditionalRecordSyntax, that removes the ability to do Record { x = 3 } - what's there to replace it? what's the non-traditional record syntax?
14:14:29 * hackagebot hedis 0.6 - Client library for the Redis datastore: supports full command set,  pipelining.  http://hackage.haskell.org/package/hedis-0.6 (FalkoPeters)
14:16:16 <spark_> is there a way to force inlining of functions I've imported? Or this just doesn't make sense?
14:16:22 <mm_freak> Hadaka: Record 3
14:16:44 <johnw> spark_: it doesn't makes sense to me, but that isn't a final determination
14:17:35 <Hadaka> mm_freak: so the "new" way is to not say which fields you are setting? (that is, omit the "x" in the first example)
14:18:00 <johnw> where is Record 3 documented?
14:18:07 <monochrom> Haskel 98
14:18:13 <spark_> johnw: D:
14:18:19 <johnw> so traditional records are from when?
14:18:19 <monochrom> probably Haskell 1.4 too
14:18:46 <monochrom> "Record 3" is no different from "Just 3" and "(:) 3 []"
14:18:58 <johnw> also, when will Hasekll 98 stop being the "golden standard", and the world upgrade to Haskell '10?
14:19:14 <Cale> johnw: The two are almost identical
14:19:19 <roconnor> johnw: when Haskell '10 gets meaningful extensions :D
14:19:22 <monochrom> I do not imply that Haskell 98 is a gold standard
14:19:30 <Cale> johnw: So people don't distinguish them.
14:19:41 <johnw> by comparison C++98 was two whole languages ago for us
14:19:59 <liyang> lowest common denominator
14:20:10 <monochrom> you ask "where is Record 3 documented" and I try to answer with an early definition
14:20:18 <monochrom> (to show you it is not new at all)
14:20:24 <johnw> ok
14:20:26 <Jurily> c++11 is at least 7 different languages
14:20:31 <johnw> I'll just wait for Record 4
14:21:00 <monochrom> "Record 3" the "3" is not a version number
14:23:04 <Cale> thatsthejoke.avi?
14:25:04 <Hadaka> so, without the "traditional" record syntax, there is no way to update record fields by name? or am I missing something entirely?
14:25:42 <spark_> Hadaka: I think there is a tool for that
14:26:07 <spark_> Hadaka: record update syntax iff my memory serves well
14:26:32 <spark_> but im prob not the most indicate to answer that
14:26:34 <nand`> Hadaka: lenses :D
14:27:07 <Peaker> module-granularity recompiles are annoying.. would be nice if it used finer-grained dependencies
14:27:09 <johnw> are lenses a good way to update multiple fields at once?
14:27:22 <johnw> Peaker: you mean function granularity?
14:27:35 <nand`> about as good as (f1 .~ x1) . (f2 .~ x2) . (f3 .~ x3) is
14:27:48 <edwardk> spark_: re inlining functions you've imported, if its inlinable there is the 'inline' keyword you can use. but that requires the put an INLINEABLE declaration in the source file or that it was small enough to get included
14:27:52 <nand`> but I don't think you can do polymorphic updates of multiple field with interdependent types at all using lenses
14:27:58 <johnw> nand`: vs record { x1 = , x2 = , x3 = } hmm
14:28:01 <nand`> without using a special traversal for those
14:28:03 <edwardk> nand`: correct
14:28:05 <johnw> i think record syntax is more clear in that case
14:28:25 <edwardk> johnw: as long as you can make the change in the type of the record by doing each change in isolation, lenses work
14:28:27 <Peaker> johnw, definition/type yeah
14:28:36 <johnw> what would be cool is if record { x = } was just sugar for (f1 .~ x)
14:29:05 <edwardk> data Pair a = Pair a a -- can't be changed from Pair a to Pair b by using a lens into its first parameter and a lens into its second parameter.
14:29:07 <johnw> then I could composed record updates :)
14:29:23 <johnw> oh
14:29:23 <edwardk> johnw yeah thats why lenses were invented ;)
14:29:37 <nand`> lenses are great for pointfree record manipulation
14:29:41 <edwardk> johnw: turns out that is a vanishingly small percentage of your updates
14:30:03 <johnw> an evanescent percentage, even
14:30:08 <nand`> I'm writing lots of lensy code right now :)
14:30:25 <johnw> i find the lensy way of changing parts of filenames to be brilliant
14:30:37 <spark_> why the name 'lenses'?
14:30:37 <Hadaka> hmmh, I must read about lenses
14:30:41 <edwardk> i've been trying to build a lens based version of bound so i can use it at work
14:30:43 <hbIppo> every time I connect to this channel I discover a new feature/library/something
14:30:54 <johnw> _directory . _filename .~ "hey" $ "/root/foo/bar.cpp" => "/root/hey/bar.cpp"
14:31:11 <timthelion> What set of symbols really say "event listener" to you?
14:31:12 <edwardk> spark_: you use the lens to focus in on the part of the structure you care about.
14:31:19 <edwardk> timthelion: 'eventListener'
14:31:29 <johnw> i don't know of another library that makes that kind of expression so easy to write -- while being composable to boot!
14:31:36 <timthelion> edwardk: In a chain of less than 4?
14:31:46 <nand`> even for simple stuff like list accessing it's nice: view (element 3) [1..10]   =>  4  since apparently !! doesn't have a name
14:32:01 <johnw> isn't the name (!!)?
14:32:08 <edwardk> obs ;)
14:32:14 <johnw> :t obs
14:32:14 <spark_> edwardk: ah, so you are seeing your structure through lenses, make sense
14:32:15 <lambdabot> Not in scope: `obs'
14:32:24 <johnw> spark_: not just seeing
14:32:29 <johnw> lenses are a two-way portal
14:32:36 <nand`> timthelion: ‚âÖ‚Üí‚Äô‚àß does, honestly
14:32:42 <johnw> think of alice's looking glass
14:33:06 <edwardk> When you stare into the abyss, the abyss stares back into you.
14:33:28 <johnw> when you've focused down to what you want to see, you can then change that thing, and it makes a new data structure containing that thing in that position
14:33:31 <timthelion> nand`: it does kinda, but do you want to type that 40 times per application?
14:33:36 <johnw> edwardk: what is the lens for map access?
14:33:45 * timthelion was thinkg ->!
14:33:48 <nand`> timthelion: (I just typed out random symbols)
14:33:59 <nand`> perhaps a snowman could be used as well
14:34:14 <johnw> black snowman!!
14:34:20 <johnw> the most underutilized Unicode symbol ever
14:34:35 * nand` .oO( yellow snowman )
14:34:44 <spark_> o.O
14:34:52 <spark_> snowman lost his head
14:35:03 <johnw> ‚õá
14:35:07 <edwardk> johnw: 'at'
14:35:12 <johnw> i guess courier doesn't have black snowman
14:35:16 <edwardk> m^.at "hello"
14:35:29 <johnw> edwardk: I love your lenses library
14:35:50 <edwardk> thanks =)
14:35:50 <nand`> deref :: Addr -> TIM Frame; deref a = use (heap.at a) `or` "Failed dereferencing address: " ++ show a  -- beautiful code
14:36:17 <johnw> I wish I could mirror the entirety of hackage.org, so that I can use hoogle 100% offline
14:36:25 <nand`> johnw: you can
14:36:36 <johnw> even when I run hoogle data --local && hoogle server --local, clicking on "head" still takes me to the Prelude docs on hackage
14:36:46 <nand`> you can download all of hackage.org, it's not that large; and you can generate your own hoogle cache and run the tool locally
14:37:05 <johnw> and I rebuilt my world with "documentation: true".  I even edited the cabal-install bootstrap.sh to make sure docs were generated for *everything*
14:37:13 <johnw> nand`: how do I download it?
14:37:18 <edwardk> you should be able to update your config to build docs, oh you did
14:37:24 <Hadaka> hmmh, am I completely wrong or does the implementation of lenses use the traditional record syntax? I mean, deriveLenses will create objects that use that?
14:37:58 <nand`> johnw: http://hackage.haskell.org/cgi-bin/hackage-scripts/archive.tar <- only latest versions
14:37:59 <edwardk> Hadaka: basically you define your records with fields named like the lenses you want but with _'s in front, then 'makeLenses' will build the real lenses
14:38:23 <nand`> I think Hadaka was asking about the lenses ‚ÄòmakeLenses‚Äô will generate
14:38:30 <Hadaka> edwardk: but does it use the traditional record syntax internally?
14:38:33 <johnw> nand`: thanks!
14:38:46 <Hadaka> or traditional record update syntax, I gather?
14:38:51 <edwardk> data Foo = Foo { _year, _month, _day :: Int }; makeLenses ''Foo
14:39:01 <edwardk> oh, it uses the constructor for the updates internally
14:39:11 <edwardk> the field names are just used to find the fields to edit
14:39:27 <edwardk> it would generate
14:40:08 <edwardk> month :: Simple Lens Foo Int; month f (Foo yy mm dd) = (\mm' -> Foo yy mm' dd) <$> f mm
14:40:17 <edwardk> or at least the equivalent with uglier names
14:40:20 <johnw> ‚õÑ <-- "SNOWMAN WITHOUT SNOW"
14:40:28 <johnw> because, you know, we have to distinguish these things
14:40:34 <nand`> ‚ÄòMAN‚Äô
14:40:36 <Cale> Isn't that just a man?
14:40:37 <Cale> yeah
14:40:41 <edwardk> Cale: =)
14:40:52 <johnw> ‚õÖ
14:40:59 <johnw> is that glyph full color for you guys too?
14:41:05 <johnw> SUN BEHIND CLOUD
14:41:05 <Cale> no
14:41:11 <johnw> i see a yellow sun
14:41:14 <Jeanne-Kamikaze> I get a gray box
14:41:16 <nand`> I don't see any of those, for starters
14:41:20 <johnw> ah
14:41:22 <hbIppo> I see nothing, I don't support unicode yet
14:41:25 * johnw hugs Emacs 24
14:41:26 <Hadaka> edwardk: oh okay - are the examples found in the documentation just to make it easier to understand
14:41:33 <Hadaka> edwardk: I mean: p1Score = fromGetSet p1Score_ (\x s -> s { p1Score_ = x })
14:41:44 <Hadaka> etc.
14:42:11 <nand`> fromGetSet doesn't look like a name from package lens
14:42:21 <edwardk> Hadaka: you're looking at the wrong lens pacage
14:42:26 <edwardk> look at 'lens'
14:42:34 <nand`> ‚Äòwrong‚Äô hehe
14:42:35 <Hadaka> oh god
14:42:45 <edwardk> lens is a bit bigger ;)
14:42:49 <johnw> nand`: archive.tar is just a bunch of tarballs
14:42:57 <johnw> how does that answer my question?
14:43:07 <edwardk> johnw: yes it is in color
14:43:09 <johnw> I want to mirror all of haskell.org.  that means the haskellwiki, hoogle, the haddock docs, etc.
14:43:20 <nand`> sorry, thought you meant hackage
14:43:27 <edwardk> johnw: we don't have a tarball of that sort of thing anywhere
14:43:27 <johnw> I already have a hackage mirror
14:43:33 <johnw> using that hackage-mirror project on github
14:43:37 <Hadaka> if I google for "haskell lenses" that's all I get - I have to scroll down to get somebody saying something about Data.Lens
14:43:49 <edwardk> @hackage lens
14:43:49 <lambdabot> http://hackage.haskell.org/package/lens
14:43:52 <edwardk> that one
14:43:54 <johnw> well, if I had a complete mirror of haskell.org, I'd be happy to run it on my VPS as a fallback
14:43:55 <nand`> you want Control.Lens
14:43:59 <edwardk> Data.Lens was my old one.
14:44:17 <johnw> somebody should just run an rsync server on haskell.org
14:44:32 <Hadaka> yeah, I know how to find it know - I'm just wondering how I could've found the right package by googling
14:44:46 <Cale> lol UML
14:44:58 <edwardk> Cale: oh the uml diagram for lenses? =)
14:45:04 <Cale> yeah
14:45:14 <dncr> ok i had to do this to make Haddock happy: https://gist.github.com/3541961
14:45:16 <nand`> Cale: Control.Lens is all about making Haskell seem like an imperative OOP language
14:45:16 <edwardk> yo dawg i heard you like uml, so we designed uml for your field accessors so you can uml while you uml
14:45:36 <Hadaka> okay, so there's three: Data.Lenses, Data.Lens and Control.Lens (roughly) - and Control.Lens is the one which should be used?
14:45:40 <dncr> my question is, is that something you can never do w/ Haddock?  or only w/ newer version?
14:45:47 <danharaj> Control.Lens wins by a  large margin.
14:46:06 <edwardk> Hadaka: there is also fclabels and accessors, i think, but the amount of comparative engineering effort between the different packages should show ;)
14:46:10 <nand`> Hadaka: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285
14:46:15 <nand`> for a quick overview of the different implementations
14:46:23 <nand`> and why they shouldn't be used in favor of the glorious Control.Lens
14:46:44 <merijn> nand`: oh, it was expanded with a description of Control.Lens?
14:47:07 <nand`> yeah at the bottom
14:47:22 <Hadaka> does the makeLenses thing need some language extensions like templatehaskell or does it work without them?
14:47:33 <edwardk> merijn: just a short blurb really
14:47:47 <nand`> Hadaka: it needs TemplateHaskell
14:47:48 <edwardk> Hadaka: makeLenses uses extensions, in fact lens is pretty extension heavy
14:48:23 <Hadaka> okay, so is there any alternative to the "traditional" record syntax which does not need heavy use of extensions?
14:48:29 <nand`> I finally understood this comment: ‚ÄúI like the fclabels for its optimistic approach :->‚Äù <- it seems I had to be sufficiently tired
14:48:33 <johnw> is fplang still around?
14:48:51 <danharaj> You don't need to know about the extensions in lens to use lens. The interface is almost Haskell98
14:48:55 <nand`> Hadaka: well you can make the lenses yourself
14:48:58 <merijn> edwardk: The types of Control.Lens are still voodoo to me xD
14:49:23 <nand`> merijn: most of them still are to me. I often just leave off the type signatures when writing convenience combinators for lens stuff because they're so huge and ugly
14:49:26 <merijn> edwardk: Also, this example seems wrong? "_2 (a,b) = (,) a <$> f b" where does f come from?
14:49:27 <edwardk> merijn: i'm working up a worksheet on them
14:49:30 * hackagebot haskell-xmpp 1.0.2 - Haskell XMPP (eXtensible Message Passing Protocol, a.k.a. Jabber) library  http://hackage.haskell.org/package/haskell-xmpp-1.0.2 (DmitryAstapov)
14:49:39 <edwardk> _2 f (a,b) = (,) a <$> f b
14:49:49 <edwardk> merijn: thats a typo in the docs whereever you found it
14:49:50 <merijn> That's what I figured
14:49:54 <edwardk> where was that?
14:49:58 <nand`> edwardk: it's in the SO post
14:50:01 <merijn> The stackoverflow answer
14:50:15 <edwardk> want to edit it? its community wiki by now so i get nothing for editing it myself ;)
14:50:22 <Hadaka> nand`: right - although the whole point of the record syntax was to avoid manually writing functions for each member - otherwise I would just use a new type without naming them
14:53:19 <merijn> Fixed it (I think), the edit is in the queue
14:53:34 <edwardk>  data (&) :: (((k,k) -> *) -> (k,k) -> *) -> (((k,k) -> *) -> (k,k) -> *) -> ((k,k) -> *) -> (k,k) -> * where (:&) :: f a '(i,j) -> g a '(j,k) -> (f & g) a '(i,k)
14:53:36 <edwardk> whee
14:54:02 <hiptobecubic> lol
14:54:12 <edwardk> i actually needed that thing ;)
14:54:22 <hiptobecubic> you would
14:54:41 <merijn> Man, open source is slow, it's been 11 hours and my patch still isn't accepted :p
14:54:47 <edwardk> Hadaka: the benefit of lenses over records, even if you had to manually write the lens is that they compose.
14:55:08 <edwardk> Hadaka: when you go to edit a nested field of a field of a field you get a combinatorial explosion in the amount of code
14:55:16 <hiptobecubic> It's possible to declare a class as an instance of another class, right?
14:55:37 <edwardk> foo { bar = f (bar foo) }  -- isn't so bad, now go two levels deep
14:55:38 <nand`> hiptobecubic: huh
14:55:49 <edwardk> hiptobecubic: yes
14:56:00 <edwardk> hiptobecubic: you need {-# LANGUAGE ConstraintKinds #-}
14:56:22 <hiptobecubic> really? It wanted FlexibleInstances... maybe i did it wrong
14:56:27 <Hadaka> edwardk: yeah, the benefits of lenses are nice
14:56:34 <hiptobecubic> it doesn't build regardless :D
14:56:55 <edwardk> hiptobecubic: https://github.com/ekmett/constraints/blob/master/Data/Constraint.hs#L164
14:56:57 <merijn> also, let me try again: anyone with hsc2hs or c2hs experience around?
14:57:17 <Hadaka> although, if manually writing the lens, I'm not sure why one would use a record type at all instead of a simple data type
14:57:58 <edwardk> Hadaka: lenses in the 'lens' package sense compose with things that aren't lenses. like 'traverse' and give you a suite of combinators that you can employ on these weaker structures.
14:58:16 <edwardk> Hadaka: by just doing something one-off you lose that compositionality
14:58:40 <hiptobecubic> edwardk, what's going on there? I was hoping for something along the lines of  `instance Foo a => Bar a where...`
14:58:42 <edwardk> and yes, you can just write the data type directly if you are going to hand roll the lenses
14:58:50 <edwardk> hiptobecubic: don't do it. its a bad idea
14:59:06 <Hadaka> edwardk: right, okay
14:59:19 <hiptobecubic> edwardk, it's not my first. :)
14:59:24 <edwardk> hiptobecubic: you can write a WrappedFoo, and make instance Foo f => Bar (WrappedFoo f) -- but the instance Foo a => Bar a is a terrible idea
14:59:45 <johnw> meh, I just can't get hoogle to behave locally
14:59:52 <edwardk> it just doesn't work in so many situations and causes you to never be able to safely add instances to the class in any other module ever again
15:00:04 <edwardk> its just a bad idea
15:00:05 <johnw> I run hoogle server --local, search for Control.Lens, select the lens packag, and it takes me straight to haskell.org
15:00:05 <hiptobecubic> edwardk, are you saying that the way you're doing it here is accomplishing what I want, but isn't a bad idea?
15:00:09 <johnw> even though I have that documentation locally
15:00:54 <hiptobecubic> edwardk, and what is the benefit of making a WrappedFoo if all you do is Bar it?
15:00:58 <edwardk> hiptobecubic: no what i'm doing here is literally what you said at first, making a class an instance of a class. e.g. making an instance of Class for Show.
15:01:07 <Hadaka> on a completely unrelated note - how solid is "safe haskell"? how many years has it seen use? is it experimental or ready for full scale production?
15:01:09 <edwardk> its not what you meant to say, which you clarified later
15:01:22 <hiptobecubic> edwardk, ah ok. i see
15:01:39 <edwardk> hiptobecubic: instance Foo a => Bar a is saying to the compiler, hey, all instances of Bar will alwyas be Foo!, because a overlaps with every other possible instance.
15:01:49 <edwardk> the compiler will see that and go great! let me go look for a Foo!
15:01:57 <geekosaur> Hadaka, many of us consider it still experimental; moreover, it's not "safe" in the sense of security, only of purity
15:02:08 <edwardk> if it doesn't find one it doesn't back up and go 'oh i guess there wasn't one :(' it just craps out
15:02:27 <hiptobecubic> But that does sound like what i want
15:02:38 <edwardk> do you have any instances of Bar that are not instances of Foo?
15:02:39 <hiptobecubic> i guess that's where the bad idea comes into play :)
15:02:41 <Hadaka> geekosaur: thanks
15:02:43 <hiptobecubic> No
15:02:48 <edwardk> then why is Bar even a class?
15:03:10 <edwardk> why aren't these combinators in Foo, or why isn't Foo a superclass of Bar?
15:03:21 <edwardk> those are the two solutions that make sense ;)
15:03:52 <hiptobecubic> well *that* sounds more like what i'm trying to do anyway
15:03:53 <edwardk> the third is where you have something like Applicative which should be a superclass of Monad. but you can't make instance Monad m => Applicative m -- it causes all sorts of problems.
15:05:11 <hiptobecubic> if Foo is a superclass of Bar, we're saying that all Bars are also Foos, yes?
15:05:12 <edwardk> anyways, i wanted to make sure to emphasize how terrible an idea it was, lest someone come along and try to sell you overlapping instances or incoherent instances or something and send you into a pile of bad design =P
15:05:17 <edwardk> yes
15:05:46 <hiptobecubic> edwardk, what is the difference between that, and what i'm saying then?
15:05:56 <edwardk> class Functor f => Applicative f -- every applicative is a Functor
15:06:09 <hiptobecubic> yes
15:06:30 <edwardk> instance Applicative f => Functor f -- is a different beast. thats saying every valid Functor is given rise to in this particular way from its Applicative dictionary
15:07:00 <edwardk> you can make superclasses. they are good. the big general instances like instance Monad f => Applicative f are what i'm saying is bad.
15:07:10 <hiptobecubic> i see
15:07:18 <hiptobecubic> possibly. :)
15:07:30 <edwardk> the problem is the type checker is going to look at the instance head and nothing else to decide what instance to use
15:07:41 <edwardk> lets take a look at show for a sec as an example
15:07:45 <hiptobecubic> yes. it already bitched about that
15:07:45 <edwardk> instance Show a => Show [a]
15:07:46 <Philippa> edwardk: remind me, someone other than me's hawked the idea of instances-in-potentia that you can instantiate for more specific types now, right?
15:08:13 <edwardk> instance Foo a => Show a
15:08:35 <edwardk> theclass dispatch has to figure out what it needs to do, solely based on the head. its like pattern matching at the type level
15:08:47 <edwardk> that gives you two 'pattern match' rules, one for [a] and one for a.
15:09:03 <edwardk> now it matters which one gets picked first, because they overlap in an incoherent manner
15:09:11 <edwardk> instance Show a => Show (Maybe a)
15:09:26 <edwardk> we can resolve this one against [a] just by matching on the type constructor Maybe.
15:09:37 <edwardk> so it can pick which of those two instances free and clear
15:09:59 <edwardk> but when you add 'a' as an instance head. then the compiler should be free to choose that instance all the time for everything.
15:10:11 <hiptobecubic> i see
15:10:35 <edwardk> so if you added a new instance. instance Show Bar in another module. the compiler can (and probably will) just completely ignore it, picking the instance for Show a, that it knows is good for all types!
15:11:12 <edwardk> the place for 'every foo is a bar'-style relationships is in 'class', not 'instance'
15:11:40 <hiptobecubic> ok yes. that's clear. definitely not what i intended
15:11:50 <merijn> Even the example in the c2hs documentation refuses to work :(
15:11:57 <edwardk> ok, point belabored =)
15:12:02 <Philippa> edwardk: right, my suggestion is basically that we should be allowed to say "every foo can be a bar and here's a way to do it" :-)
15:12:35 <edwardk> Philippa: c# has something kind of similar for method dispatch (but not classes), so does scala.
15:12:37 <hiptobecubic> Philippa, how we decide if we should do it then?
15:12:40 <edwardk> i'm not a huge fan of either in practice.
15:13:13 <Philippa> hiptobecubic: instance MyClass signature = whateverWeCalledTheInstanceInPotentia
15:13:26 <Philippa> in other words: "and now I'm going to do it"
15:13:41 <Philippa> (at which point all the usual machinery works just fine)
15:13:49 <edwardk> Philippa: amusingly thats very close to the way we define instances internally in ermine here ;)
15:14:04 <Philippa> edwardk: I can't imagine how such a coincidence might occur :-)
15:14:31 <Philippa> (it's amazing what happens when you think of evidence as just another sort, no?)
15:18:15 <edwardk> trying to abuse that to get restricted monads in my little 'indexed' side project
15:22:09 <Lajla> Philippa, you wouldn't perchance happen to know if it is at all possible in some way to create an ad hoc polymorphism for a function to make it accept different tuple types=
15:22:22 <Lajla> As in 'variable argument functions', if you will?
15:23:30 <timthelion> Lajla: It's hard.  You want multiple numbers of elements to the tuple?
15:23:52 <merijn> Hmm, is c2hs just unmaintained or something?
15:24:03 <hbIppo> I thought that was actually impossible, since tuples of different lengths have different types
15:24:03 <Lajla> timthelion, numbers, types, you name it.
15:24:13 <Lajla> Well, basically it's just overloarding if you will
15:24:29 <Lajla> Where a tuple is a type, I guess.
15:24:51 <timthelion> Lajla: Overloading is easy.  Just make yourself a typeclass.  And then create an instance of that typeclass for each type of arguement you want to hande.
15:24:54 <timthelion> handle
15:25:20 <Lajla> yes, I know, but that approach doesn't really work in this situation.
15:25:34 <timthelion> Lajla: concrete example?
15:26:26 <Lajla> Hmm, nevermind, I think you can actually work it.
15:26:39 <hiptobecubic> edwardk, so if i have `class Foo a where bar :: b`  and I want it to be a super class of Baz, do I have to come up with a stupid name for the Baz version of the bar method and the give it a default implementation using bar itself?
15:26:50 <hiptobecubic> ...hmm  that's not as clear as i'd hoped :D
15:27:14 <edwardk> hiptobecubic: depends on how modern you want to be
15:27:27 <timthelion> Lajla: the "hard" thing, is if you want to apply some function across arbitrary kinds.  Then you need to use an Onion.  aka (a,(b,(c,d)))
15:27:27 <edwardk> if you are willing to limit yourself to 7.4.x you can ise DefaultSignatures
15:27:29 <spark_> Lajla: my noob mind says make a type with diferent constructor for each tuple, and pattern match a function for every constructor with the appropriate example
15:27:42 <edwardk> define Foo and Bar in the same module and then
15:27:44 <ocharles> Hey, I'm having a hard time figuring out how to sort of merge 2 parallel arrows into a single function call, and then have the output fanned out accross the original arrows. https://gist.github.com/14ff50d1aee066b71167 is what i'm working with so far, and it's almost done
15:27:53 <spark_> Lajla: but this requires that you make a function forevery tuple, and may not be what you want
15:28:00 <hiptobecubic> Foo's can bar.  Baz's are Foo's, so Baz's should be able to bar as well. But i can't declare bar in Baz's class because it conflicts
15:28:07 <ocharles> I just can't see how to move forward from where I am (in `myComp`)
15:28:22 <Lajla> Yeah, I know, basically I just want those functions to have the same name for convience sake and let the type system figure it out.
15:28:22 <edwardk> class Foo a where bar :: a; default bar :: Baz a => a; bar = programwithBazHere
15:28:27 <Lajla> As you would in say Java
15:28:48 <hiptobecubic> edwardk, aha
15:28:49 <edwardk> that is a 7.4'ism
15:28:56 <edwardk> but putting them all in the same module can be painful
15:29:03 <spark_> Lajla:  then you can do what I've said, imo
15:29:15 <hiptobecubic> edwardk, and before that it was  bazBar = bar   ?
15:29:20 <spark_> Lajla: or create a class?
15:29:33 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/WithIndex.hs#L87
15:29:50 <timthelion> spark_: typeclass, not class :)  we'd like to avoid confusion with C++ clases.
15:29:55 <Lajla> spark_, indeed, I'm just going with the type class, doth require me to create a class each and every time for all the possible tuples the function can consume for every different function, but it'll have to be.
15:30:00 <edwardk> hiptobecubic: that uses default signatures quite a bit
15:30:15 <spark_> timthelion: well, I thought class was typeclass all times here D:
15:30:33 <jfischoff> Is there a better method for baking TH code, besides copying the output of -ddump-splices?
15:30:54 <edwardk> jfischoff: baking lenses?
15:31:00 <edwardk> jfischoff: or more exotic stuff
15:31:02 <hiptobecubic> edwardk, but you give a sig for imap and then a second, default sig for imap again?
15:31:12 <edwardk> hiptobecubic: yes, the first is the real sig
15:31:23 <hiptobecubic> from Functor?
15:31:23 <edwardk> the second is 'if this signature matches, fill in this definition for me'
15:31:40 <edwardk> no, its an 'indexed' functor, in that it has a key associated with every position
15:31:42 <hiptobecubic> Oh i see....
15:31:49 <edwardk> not to be confused with the indexed package i'm writing now ;)
15:31:52 <jfischoff> edwardk: I just have a bunch of th code, mostly ToJSON/FromJSON instances that is causing a serious slowdown
15:32:12 <edwardk> jfischoff: ah. i'm planning on doing the same sort of manual TH expansion for 'ad'
15:32:27 <jfischoff> so manual is the way I guess
15:32:30 <jfischoff> that sucks
15:33:11 <hiptobecubic> edwardk, so the default sig lets you change the implementation based on constraints then?
15:33:14 <edwardk> what i'll probably do is add a -DUSE_TEMPLATE_HASKELL  and use TH in that case or use the copied splices otherwise
15:33:32 <jfischoff> that's exactly what I just setup
15:33:36 <edwardk> hiptobecubic: it is basically equivalent to writing the definition in by hand. you can only put one default signature
15:34:11 <edwardk> e.g. if Control.Applicative had default signatures, then you'd have
15:34:59 <edwardk> class Functor f =>  Applicative f where (<*>) :: f (a -> b) -> f a -> f b; default (<*>) :: Monad f => f (a -> b) -> f a -> f b; (<*>) = ap; ...
15:35:27 <hiptobecubic> edwardk, what i'm seeing is that everywhere you're using them, it's to check for TraversableWithIndex
15:35:57 <hiptobecubic> edwardk, yes. sure. So you use it to check if you satisfy some additional constraint on the types
15:36:27 <edwardk> hiptobecubic: class (Functor f, Foldable f) => Traversable f -- those are superclasses because fmapDefault and foldMapDefault exist.
15:36:52 <edwardk> fmapDefault f = runIdentity . traverse (Identity . f)  -- is a valid default definition for fmap
15:37:09 <edwardk> the same thing holds here just with some extra noise in the way
15:37:57 <edwardk> making use of DefaultSignatures requires you to turn your class hierarchy into a jumbled mess all placed in one file though
15:38:03 <edwardk> so i don't recommend abusing it much ;)
15:38:14 <edwardk> it also favors heavily linearized class hierarchies
15:38:26 <edwardk> Functor => Applicative => Monad
15:38:30 <hiptobecubic> right
15:38:36 <hiptobecubic> perhaps not great then
15:38:40 <edwardk> but when you add Functor => Comonad -- you can't make it default fmap
15:38:56 <hiptobecubic> The alternative was to do that ugly thing i mentioned then?
15:39:52 <edwardk> hiptobecubic: the usual way i would do it is if you can define Foo's bar method using the combinators in Baz alone would be just write a barDefault method in the Bar module, and encourage the user to use it by hand
15:40:31 <edwardk> e.g. even though given Traversable i can define Functor, i may not want to do it that way
15:40:42 <edwardk> also i may be able to get away with fewer constraints
15:41:28 <hiptobecubic> edwardk, i was hoping to essentially end up with an overloaded bar that just works
15:41:43 <edwardk> instance (Traversable f, Traversable g) => Traversable (f * g); -- using fmapDefault I'd need Traversable f, and Traversable g, but you should usually be able to write instance (Functor f, Functor g) => Functor (f * g) instead
15:41:55 <edwardk> if you want that, do default signatures.
15:43:35 <hiptobecubic> edwardk, but that forces you to only have one subclass right?
15:44:05 <edwardk> hiptobecubic: you can have other subclasses, but only one defaultsignature. you'd have to wrte the method by hand for everything else
15:45:38 <Peaker> Using transformers without mtl, what's the standard way to lift a "Reader.local" operation into other transformers?
15:47:11 <edwardk> Peaker: by hand. ;) there isn't a liftLocal usually
15:47:18 <edwardk> at least that i can think of
15:47:40 <edwardk> listen, pass, catch, callCC all get that treatment, but not local
15:47:53 <edwardk> mostly because local is comparatively simpler
15:48:07 <edwardk> i'm sure ross'd take a patch though ;)
15:48:12 <Peaker> hmm.. I have my own wrappers around "local" of the inner monad
15:48:37 <Peaker> now the new outer transformer needs to duplicate them, cause it can't really lift  (inner a -> inner a) -> outer a -> outer a
15:48:39 <edwardk> of course, if you were using lenses you could just magnify ;)
15:48:45 <roconnor> edwardk: censor?
15:49:05 <edwardk> roconnor: censor is a combinator implemented in terms of other stuff iirc
15:50:03 <Peaker> edwardk, the lens stuff is all mtl though, and I prefer transformers :(
15:50:09 <roconnor> oh right
15:50:22 <edwardk> Peaker: sure. i was mostly poking fun
15:50:30 <roconnor> I was thinking of pass which is in your list
15:51:12 <Peaker> edwardk, I have https://github.com/Peaker/bottle/blob/master/codeedit/Editor/OTransaction.hs
15:51:28 <Peaker> and I want to split the Reader part from the writer-state part which I want to throw to a wrapper module
15:51:43 <Peaker> but I'm not sure what to do about all the functions that call "local"
15:51:57 <Peaker> the wrapper cannot lift them
15:52:06 <Peaker> but I'd rather not duplicate them :(
15:52:32 <gadtfly> @pl foo c f (x:xs) = c (f x) xs
15:52:33 <lambdabot> foo = flip flip tail . (ap .) . flip flip head . ((.) .) . (.)
15:52:47 <Peaker> I guess I can convert them all to be lens and do the "local" part at the callers' with the appropriate monad's "local"
15:53:28 <edwardk> there are some instances of magnify that i think can still be written that i haven't yet. need to go figure out how to deal with state
15:53:47 <Peaker> what's magnify?
15:55:34 <edwardk> http://ekmett.github.com/lens/Control-Lens-Zoom.html#v:magnify
15:55:45 <edwardk> its a 'deep local'
15:55:54 <edwardk> that can change the type of the environment where possible
15:56:55 <hiptobecubic> alright. enough of this foolery for tonight
15:56:57 <hiptobecubic> edwardk, thanks again
15:58:09 <Hadaka> has anyone considered in creating a sitemap for hackage? might promote the priority of the latest versions of each software so google wouldn't constantly come up linking to a very outdated version
15:58:12 <hiptobecubic> edwardk, oh.. was also going to ask you about large scale AD usage since you're the only person that seems to care or know anything about it,, but that can wait for another time.
15:58:25 <edwardk> kk
15:58:47 <edwardk> 3.1 should enable it to scale up quite a bit
15:59:38 <edwardk> bah i think i may have just run into a limitation of polykinds =(
15:59:53 <edwardk> my indexed package may be put off for another year =/
16:00:49 <timthelion> edwardk: what is the limitation?
16:01:09 <edwardk> one sec, i'll push
16:02:19 <edwardk> https://github.com/ekmett/indexed/blob/master/src/Indexed/Thrist.hs#L34
16:03:07 <copumpkin> pfft, thrist
16:03:13 <edwardk> i can't define ireturn there. it seems at first glance that the compiler doesn't know that the kind should be determined to be (i,i) based on the monad.
16:03:16 <copumpkin> it's clearly called Star or RTC
16:03:31 <edwardk> it wants it to be polymorphic
16:03:36 <edwardk> but there isn't a signature to say
16:03:46 <copumpkin> I thought you could put signatures in now
16:03:49 <copumpkin> on class implementations
16:03:52 <copumpkin> instances
16:04:07 <edwardk> class IMonad k (m :: (k -> *) -> k -> *) | m -> k where
16:04:18 <edwardk> that doesn't say k is determined by m, just that k exists
16:04:27 <edwardk> it makes k float polymorphically
16:04:33 <edwardk> i need k determined by the type m
16:04:59 <edwardk> at least so far as i can tell
16:05:12 <edwardk> i'm still getting my head around them fully. we don't have data kinds here ;)
16:05:38 <copumpkin> odd that your ibind is the same as your imap for thrist
16:05:46 <copumpkin> oh wait
16:05:49 <copumpkin> it's not
16:06:08 <edwardk> >< is indexed monad concatenation.
16:06:13 <copumpkin> I see
16:06:15 <edwardk> it'd be . if the kinds lined up
16:06:18 <edwardk> ;)
16:13:53 <nand`> is there a name for .= ?
16:15:48 <edwardk> nand`: yes, .+
16:15:52 <edwardk> er .= =)
16:16:04 <edwardk> no prefix name though
16:16:05 <nand`> well, a non-operator name
16:16:15 <nand`> shame
16:16:21 <edwardk> could add something like 'assign'
16:16:42 <nand`> I was just writing ‚Äòassign = (.=)‚Äô when you wrote that
16:17:01 <edwardk> fits the imperative nature of the names for State
16:17:05 <nand`> use foo >>= assign bar
16:19:34 <roconnor> (bar .=)
16:21:02 <edwardk> hrmm looks like i can use class IFunctor (f :: (k -> *) -> k -> *) | f -> k
16:21:15 <edwardk> however, that doesn't work when i want to write something later that is polymorphic as an instance.
16:21:19 <edwardk> =(
16:21:32 <edwardk> hrmm, maybe i can get away with it some other way
16:22:14 * ggreif loves to see thrists used by edwardk :-)
16:22:30 <edwardk> =P
16:23:16 <edwardk> getting lots of 'the impossible happened' errors i'm trying to work around
16:23:36 <ggreif> I have almost gotten around my thrist-0.3 package (for GHC 7.6 with kind vars)
16:23:41 <hbIppo> I'm getting a strange error
16:23:53 <hbIppo> I open a file with readFile
16:24:05 <edwardk> ggreif: ah
16:24:05 <hbIppo> but when I try to apply lines to it
16:24:11 <hbIppo> it gives this error
16:24:23 <hbIppo> Couldn't match expected type `String' with actual type `a0 -> a0'
16:24:24 <hbIppo>     In the first argument of `lines', namely `log'
16:24:31 <edwardk> ggreif: they are in here because they force me to get proper indexed foldable/indexed traversable support right
16:24:52 <edwardk> The interface for `indexed-0.1:Indexed.Monad'Declaration for IMonad:  Iface type variable out of scope:  k
16:24:55 <edwardk> bah
16:25:06 <edwardk> thats a new one
16:25:12 <ggreif> edwardk: but I'll stick with the 2-parameter version, you have the params paired up as one
16:25:25 <edwardk> i need them that way or i can't do some other stuff
16:25:47 <edwardk> the other stuff is what matters to me ;)
16:25:55 <ggreif> sure go on :-)
16:26:38 <edwardk> class IMonad m => IMonadFree (f :: (i -> *) -> i -> *) (m :: ((i -> *) -> i -> *) -> (i -> *) -> i -> *) | m -> f i where -- compiles, but demands something of the downstream interface file it can't compile
16:28:28 <hbIppo> the worst part is that evaluating in ghci works
16:28:40 <hbIppo> I can't understand what that error means
16:29:22 <wyfrn> does anybody know who formed the sentence "if it compiles it works" ... i read it some time ago bot i can't remember ...
16:29:58 <maloi> hbIppo: maybe paste the code
16:30:05 <edwardk> wyfrn: its rather apocryphal at this point.
16:30:46 <hpaste> hbIppo pasted ‚Äúlines‚Äù at http://hpaste.org/73961
16:30:56 <edwardk> ok. i think i need to give up on this =(
16:31:09 <edwardk> going to have to figure out how to distill it down to a test case for ghc hq and give up
16:31:56 <hbIppo> the error it gives is
16:31:59 <hbIppo> Couldn't match expected type `String' with actual type `a0 -> a0'
16:31:59 <hbIppo>     In the first argument of `lines', namely `log'
16:32:00 <edwardk> putting constraints on the kind kind of works, but then i get all sorts of illegal interface file panics and need to compile from scratch, plus i can't make any polykinded instances
16:35:08 <hbIppo> I can't get my head around this
16:35:13 <hbIppo> in ghci it works
16:35:22 <hbIppo> but it won't let me load the file
16:35:47 <maloi> is this everything in the file?
16:36:17 <hbIppo> yes, pretty much
16:36:29 <hbIppo> a couple of imports, and another expression that is unused
16:36:36 <ggreif> member:edwardk: IFunctor is Conor's parlance?
16:36:50 <edwardk> yeah
16:37:24 <hbIppo> ok, now that's the exact same content of the file, and doesn't load
16:38:48 <monochrom> actual code?
16:39:09 <edwardk> wonder if i can make up some kind of kind-carrying proxy, that just exists to describe the shape of the kind
16:39:28 <edwardk> then make the fundep determine that or something
16:39:37 <maloi> hbIppo: log is a function in Prelude
16:40:19 <hbIppo> ... wow, this was embarassing
16:40:43 <hbIppo> but why does it work in interactive mode?
16:40:57 <hbIppo> and why can I bind the result of readFile to the name?
16:41:14 <monochrom> you can always bind to any name you like
16:42:31 <monochrom> also, when the human contradicts the computer, I stand with the computer
16:43:07 <edwardk> interesting. IMonad compiles differently when its in the same module with IFunctor than when it is not
16:43:27 <edwardk> when it is in the same module: class IFunctor k m => IMonad k m | m -> k where
16:43:40 <blue_> I don't understand, but thank you anyway
16:43:43 <edwardk> otherwise: class IFunctor m => IMonad m | m -> k where
16:43:48 <edwardk> notice the missing 'k's ;)
16:43:56 <hbIppo> ops, sorry, wrong account
16:43:59 <hbIppo> I'm blue
16:44:08 <hbIppo> I'm in the channel with two nicks
16:44:11 <hbIppo> sorry about that
16:46:00 <spark_> he, im glad I read reddit today
16:46:08 <spark_> reduced my runtime size from 1/8
16:46:14 <spark_> to*
16:46:48 <ggreif> spark_: the parsec article?
16:46:52 <spark_> yep
16:47:13 <spark_> I wasn't expecting my 100mb parsed would use 800mb though
16:48:13 <spark_> I guess the type system is huge when suposed to be lazy things are evaluated and retained
16:48:22 <ggreif> edwardk: smells like a bug (a gross one)
16:48:33 <edwardk> ggreif: yeah lots of little bugs here it seems
16:48:44 <edwardk> it works surprisingly well in a single module so far
16:48:45 <hpaste> hbIppo pasted ‚Äúlines (corrected)‚Äù at http://hpaste.org/73962
16:48:56 <edwardk> i may have to ball up my entire package into a mondo module ;)
16:49:01 <hbIppo> now it loads and should work...
16:49:09 <hbIppo> except I get an exception from (!!)
16:49:12 <hbIppo> index too large
16:49:34 <monochrom> I don't see any occurrence of (!!)
16:49:45 <hbIppo> me neither...
16:50:00 <hbIppo> *** Exception: Prelude.(!!): index too large
16:50:08 <spark_> he
16:51:50 <geekosaur> at a guess it comes from that msgFromString function
16:52:06 <hbIppo> checking it right now
16:52:40 <nand`> in ‚Äúspineless, tagless g-machine‚Äù what does ‚Äòtagless‚Äô refer to?
16:53:13 <hbIppo> yes it definitely happens in there
16:53:23 <hbIppo> there are just two occurrences
16:53:28 <hbIppo> (!!) 1
16:53:31 <hbIppo> and (!!) 2
16:53:46 <hbIppo> I guess that at least one lines results in a list shorter than that
16:53:51 <hbIppo> I'll check for that
16:54:00 <hbIppo> thanks for the help
16:54:24 <ddarius> Why in God's name is (!!) being used?
16:54:51 <monochrom> because the lib was not written by God
16:54:54 <hbIppo> a very, very primitive and very wrong IRC parser
16:55:15 <spark_> where you got it?
16:55:19 <hbIppo> it gets the string from the server (this server), and parses it in parts
16:55:34 <hbIppo> the source, the command, the target and the message
16:55:51 <hbIppo> I use (!!) to access the "parts" after breaking the string
16:55:57 <spark_> Having !! in a parser makes no sense
16:56:10 <spark_> are you using parsec?
16:56:12 <hbIppo> well, I call it parser, because it does a parsing, but it's not
16:56:25 <hbIppo> no, it's just a very naive and nooby function
16:56:26 <spark_> I see what you mean D:
16:56:37 <hbIppo> it doesn't work that bad
16:56:42 <spark_> but parsec is really easy to use, maybe you could try it
16:56:46 <hbIppo> but there must be an edge case I didn't see
16:56:54 <hbIppo> I will... tomorrow, it's 2AM here :D
16:57:02 <spark_> D:
16:57:02 <hbIppo> anyway it works pretty good already...
16:57:14 <hbIppo> it's been showing me all the messages till now :)
17:01:39 <ssbr> Is there any nice thing for computing the fixed point of some function given a starting input? e.g. something like fix :: (a -> a) -> a -> a , so that fix (\x ->x `div` 2) 100 == 0 ?
17:02:20 <nand`> perhaps Eq a =>
17:02:24 <ssbr> errr, yes
17:02:26 <ssbr> Eq a => :)
17:02:39 <ssbr> other than writing it myself, I mean (fix f v = let v' = f v in if v == v' then v else fix f v')
17:03:20 <ssbr> (also, what's a good name for it? I think "fix" is taken.)
17:04:59 <c_wraith> "break" is already taken.
17:05:04 <edwardk>   ireturn a = unsafeCoerce (unsafeCoerce a :- Nil)
17:05:07 <edwardk> problem solved ;)
17:05:32 <nand`> note to self: never ask edwardk how to fix type errors
17:05:40 <ddarius> fixedpoint
17:05:46 <edwardk> well, the type is fine, the typechecker is broken ;)
17:06:05 <ddarius> edwardk: That's what C programmer's say.
17:06:17 <edwardk> woops, relapsed
17:06:30 <ggreif> edwardk: did you file a bug?
17:06:50 <edwardk> ggreif: not yet, going to head home and distill it
17:07:41 <ggreif> edwardk: spj and co. are pretty keen on getting good quality in 7.6 for kind polymorpism
17:07:48 <edwardk> yeah
17:08:08 <edwardk> i went and did a binge like this before 7.4 before giving up on it then
17:08:15 <edwardk> figured i needed to kick the tires this time around
17:08:39 <ggreif> edwardk: yes, definitely
17:08:51 <edwardk> its kind of troubling that i can't give the better type for the instance for thrist though
17:09:09 <nand`> edwardk: is there a version of ‚Äòat‚Äô without the Maybe? or would I have to mix in ‚ÄòfromJust‚Äô somehow? (I know for certain that the value at that key exists)
17:09:16 <edwardk> 'traverseAt'
17:09:32 * jfischoff is excited to see thrist mentioned in #haskell
17:09:35 <edwardk> but thats a traversal
17:09:40 <nand`> edwardk: that should be fine, thanks
17:09:50 <nand`> I just need to update it
17:10:04 <edwardk> you guys know i've had thrists as a type in multipass for months, right? =)
17:10:28 <jfischoff> I saw you where using them somewhere
17:10:49 <ggreif> they pop up everywhere :-o
17:11:12 <edwardk> i mostly went with the thrist name because i was already using path, and most of the alternative names
17:11:44 <jfischoff> a thrist of isomorphisms could make undo
17:11:49 <jfischoff> not sure if it is practical
17:12:08 <edwardk> i use them to name calculations in multipass
17:12:16 <edwardk> you compose named operations getting a composite named operation
17:12:44 <edwardk> i'm sad though. i was really hoping this would work =(
17:14:34 <jfischoff> edwardk: be happy I just used your wl-pprint-terminfo do a cool little trick.
17:14:38 <hpaste> ‚ÄúJonathan Fischoff‚Äù pasted ‚Äúcolored diffs‚Äù at http://hpaste.org/73963
17:15:16 <edwardk> heh
17:15:31 <jfischoff> it makes my test failures look pretty
17:15:44 <edwardk> if you have to fail, fail with style i say
17:15:49 <jfischoff> hehe
17:17:10 <jfischoff> So I doubt think baking in the TH made my compile increase
17:17:19 <edwardk> ?
17:17:25 <edwardk> same speed?
17:17:37 <jfischoff> I'm testing the times now but it appears to be very similar
17:17:55 <jfischoff> without was 3m 5s
17:17:58 <edwardk> main difference is that i think profiling works better with it off
17:18:07 <jfischoff> ah
17:19:12 <jfischoff> I feel something weird is going on. I am compiling one file with a about a 200 hundred data types, and it takes forever to make .o file
17:19:39 <jfischoff> now why I have two hundred data types is Adobe's fault
17:19:49 <edwardk> i may be able to salvage the thrist code by doing something more drastic with the indices
17:19:54 <edwardk> but =/
17:20:15 <jfischoff> TH code 3m 18s :(
17:20:34 <edwardk> woot. hope that thirteen seconds tastes like victory
17:20:52 <jfischoff> we have different tastes ;)
17:21:14 <jfischoff> different files i FTW?
17:21:36 <jfischoff> s /i/
17:22:39 <Cale> So, you can define monads in an arbitrary 2-category which is fairly straightforward generalisation of monads in Cat, but I'd forgotten that you can actually define a whole 2-category Mnd(C) of monads in a 2-category C. So it's possible to iterate that process.
17:23:27 <Cale> I wonder what sorts of things live in Mnd(Mnd(Cat)) :)
17:24:06 <Jafet> Yo, cat, I heard you like monads
17:24:35 <nand`> Cale: dogs do, clearly
17:25:16 <hpc> a bind within a bind
17:25:18 <hpc> binception
17:25:43 <jfischoff> Cale: its not special:  superJoin Mnd(Mnd(Cat)) = Mnd(Cat) ;)
17:26:15 <Cale> lol
17:27:26 <Cale> lol, I wonder if Mnd is a monad in the 3-category of 2-categories.
17:28:25 <Cale> Actually, is that a 3-category? I remember that being the case from somewhere, but I might be wrong.
17:29:08 <spark_> when i heap profile, what (pinned) accounts for?
17:29:16 * jfischoff is still working on 0.1.0.0 categories
17:30:32 <parcs`> @hoogle Storable a => a -> (Ptr a -> IO b) -> IO b
17:30:33 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
17:30:33 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
17:30:33 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
17:30:37 <parcs`> nice!
17:32:08 <Cale> yeah, that's right
17:44:09 <slack1256> if I use snoc 2 times on a vector (from the vector package). Is the intermediary vector fused away?
17:44:15 <slack1256> this is what fusion is for, right?
17:46:02 <Cale> slack1256: I believe so.
17:46:14 <hpc> slack1256: probably; i understand vector is fairly sophisticated in terms of optimization
17:46:17 <Cale> slack1256: The definition uses stream and unstream
17:46:36 <Cale> I believe they should fuse
17:47:03 <slack1256> yeah they should.
17:47:42 <Cale> There's this elemseq thing in between, and I'm not sure exactly what that is, whether it'll be lifted or there's another rule which applies, but I would sure hope so :)
17:48:23 <slack1256> but if I want to guaranty that looping a vector will be competitive (same league) in speed with mutation (a la C). then I should use ST right?
17:49:08 <Cale> Not necessarily
17:49:14 <ddarius> You should use C.
17:49:19 <Cale> that could hurt things
17:49:24 <ddarius> What happens if your code goes too fast?
17:49:57 <hpc> you can't really beat C by trying to do the same things faster
17:50:50 <shachaf> @quote einstein
17:50:50 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
17:51:45 <morolin> Sure, and you can get your program to run faster if you just write pure assembly. The point of higher levels of abstraction is to increase programmer productivity.
17:52:10 <amosr> slack1256: if you're very dedicated, you can dump the core (-ddump-prep -dppr-case-as-let etc) and make sure it comes out as a tight loop doing no unboxing, allocation, etc?
17:53:03 <slack1256> ddarius: (a la C) doesn't mean C. when I reefer in the same league i mean it isn't a order of magnitude slower, 8 times slower would be fine.
17:54:11 <slack1256> amosr: I guess, reading core isn't that difficult. good advice.
17:55:04 <shachaf> Isn't it satisfying when your boolean condition is exactly 9 characters long?
17:55:08 <Cale> slack1256: in that case, there's pure ByteString and Vector code which is within a factor of 2 or 4, occasionally you even get an example which runs better than somewhat naive C
17:55:24 <Cale> otherwise
17:57:02 <lightquake> if i'm using phantom types for FormData a where a is Validated or Unvalidated, what's the recommended way to let functions know whether a given FormData is Validated or not?
17:57:52 <lightquake> something like a GetValidatedness typeclass with instances for FormData Validated and FormData Unvalidated?
17:58:24 <Cale> lightquake: That seems weird
17:58:32 <Cale> lightquake: Because you should know statically
17:59:06 <lightquake> Cale: this is more an academic question; i don't have a specific use case in mind
17:59:34 <slack1256> Cale: oh great. In my head looping a structure (growing it for example with snoc) seemed quite expensive. But isn't that bad apparently.
17:59:37 <slack1256> Cale: thanks
18:00:04 <Cale> slack1256: You'll usually be rewarded for doing things in a uniform way though
18:01:03 <Cale> lightquake: If you want to allow both possibilities, you already need to form some kind of sum type (or else be entirely polymorphic in the validation state)
18:02:19 <slack1256> Cale: what does that mean? I don't get it.
18:02:26 <Cale> lightquake: For example,  Either (FormData Unvalidated) (FormData Validated), where matching on the Left or Right will tell you which
18:02:39 <Cale> (more likely you make your own type for this if you're using it a lot)
18:03:30 <Cale> or you might decide to make FormData a GADT with some constructor(s) producing FormData Unvalidated and some producing FormData Validated, in which case pattern matching on the constructor will discharge a type equality constraint
18:03:49 <Cale> and so you'll know statically whether it's validated or not
18:06:21 <Cale> If you make something like  data ForgottenValidation where FV :: FormData a -> ForgottenValidation, then recovering the validation state will be hard unless FormData is such a GADT.
18:06:46 <Cale> But I don't think you should have to do that
18:17:33 <ddarius> There are many ways of recovering static type information.
18:24:01 <nh2> lambdabot: last $ scanl1 (+) [1..100000000]
18:24:35 <MostAwesomeDude> > last $ scanl1 (+) [1..100000000]
18:24:42 <lambdabot>   mueval: ExitFailure 1
18:24:42 <lambdabot>  mueval: Prelude.undefined
18:24:57 <nh2> is there a version of scanl that forces the accumulator? I see no point of copy-pasting that into my own code
18:25:14 <MostAwesomeDude> @hoogle scanl'
18:25:15 <lambdabot> No results found
18:25:17 <MostAwesomeDude> Hmmm.
18:26:15 <Cale> nh2: You really want to force the long list onto the heap all at once?
18:26:35 <Cale> Oh, I think I know what you may want
18:27:07 <nh2> Cale: well I would paste it. Is hpaste down?
18:27:33 <nh2> hmm no seems to be a DNS flaw
18:27:39 <Cale> nh2: yeah, it's up
18:27:51 <hpaste> nh2 pasted ‚Äúscanl'‚Äù at http://hpaste.org/73966
18:28:03 <nh2> Cale: that is what I want http://hpaste.org/73966
18:28:26 <adnauseam> just a quick question since i'm confusing myself here .. Maybe is a data type, and Just is a data constructor, right ?
18:28:36 <nh2> MostAwesomeDude: wouldn't you agree that that's stupid? Have a look at the suggestions at the bottom of http://www.haskell.org/haskellwiki/Stack_overflow#column-one
18:28:46 <Cale> Yeah, you can factor that out as  strictList [] = []; strictList (x:xs) = x `seq` (x : strictList xs)
18:29:27 <MostAwesomeDude> nh2: TBH I'm not equipped to measure stupid.
18:29:53 <nh2> MostAwesomeDude, Cale: "forcing the list while going along"? WTH. That means if call last on a list I must know that the list is implemented with scanl's fancy sharing somewhere deep in my code
18:32:22 <nh2> Cale: yeah, but then I'd have to use that in the *caller*, right? I'd like to avoid to force them to know that I implement my function with this 'issue' in scanl
18:32:44 <nh2> in that case, would you agree that the seq in my scanl' is the right way?
18:33:32 <nh2> and also, how does that work again when one wants to send a patch for Data.List / the base libraries?
18:33:37 <Cale> nh2: You'd just use it wherever you're currently using scanl
18:33:55 <Cale> nh2: It makes it so that evaluating each cons will also force one element of the list
18:34:21 <nh2> Cale: oh yes I was a bit confused
18:34:43 <nh2> however, I think foldl' justifies a scanl'
18:35:00 <Cale> pretty reasonable
18:35:02 <Cale> yeah
18:35:24 <nh2> so where do they keep the base code? Can I send a pull request ;)
18:35:54 <nh2> Cale: your strictList, do you know if that exists in some library already?
18:35:55 <Cale> I dunno, at the very least, it's in GHC
18:36:03 <Cale> oh, strictList?
18:36:07 <Cale> I've seen it around...
18:36:16 <Cale> But I don't know if it's in a library
18:36:25 <amosr> http://github.com/ghc/packages-base ?
18:37:27 <nh2> amosr: a fair link. A shame it says "DO NOT SUBMIT PULL REQUESTS HERE". How do they want me to do that? darcs send?
18:37:50 <parcs`> git format-patch :)
18:37:53 <adnauseam>  woah is lambdabot2 being developed ?
18:38:09 <adnauseam> -/whois shapr
18:38:11 <amosr> nh2: ah, the real git repository is on darcs.haskell.org
18:38:11 <adnauseam> err
18:38:17 * adnauseam fails
18:38:35 * adnauseam is reading up on #haskell 
18:39:57 <nh2> amosr: git on a darcs subdomain is a bit confusing IMO, but OK, good for me
18:40:11 <nh2> parcs`: ok, but where do I send that then?
18:40:22 <amosr> yes, I don't quite know why they changed to git?
18:40:31 <parcs`> nh2: attach it to a ticket in the trac repository
18:40:50 <lispy> amosr: there was good reason, but it's hard to express it over irc
18:41:30 <parcs`> wasn't it "darcs is too slow and git is fast?"
18:41:35 <lispy> I would say the lesson is: Never name your domains after applications. Instead name it after the capability/service. repository.haskell.org or source.haskell.org or project.haskell.org or scm.haskell.org would have all been better
18:41:45 <amosr> fair enough
18:42:23 <lispy> parcs`: I think the ghc devs found it fast enough. I think it really had more to do with community pressure.
18:42:30 <lpvb> what changed to git?
18:42:35 <lispy> And posting on github makes the code a lot more accessible too
18:42:42 <lispy> lpvb: ghc sources
18:42:47 <lpvb> cool
18:44:13 <lispy> I think the change over was painful for some, but most are now aclimated and fine with it
18:44:51 * lispy <-- was a long time darcs user/supporter but now just uses git/github for stuff
18:45:01 <lispy> github is kind of hard to beat
18:45:27 <lispy> anyway...I saw a fun talk about agda this week
18:46:26 <lispy> Not on our vimeo channel yet, but hopefully soon: http://vimeo.com/galois/videos
18:46:42 <lispy> The talk focus on formalizing category theory, so it had some use for haskellers
18:47:01 <ion> Would you mind pinging me when it is available?
18:47:24 <lispy> ion: if you have an rss reader you can subcribe: http://vimeo.com/galois/videos/rss
18:47:31 <lispy> ion: I will likely forget :(
18:47:47 <lispy> you can also follow galois on vimeo if you have an account
18:48:15 <ion> I‚Äôll try to remember to check the channel later.
18:48:47 <nh2> how do I build base? cabal configure gives me "cabal: configure script not found."
18:49:05 <dcoutts> nh2: you don't. It comes with ghc and cannot be rebuilt.
18:49:08 <lispy> nh2: do you need to run autoconf first?
18:49:11 <lispy> ah
18:49:30 <parcs`> i like git, but i dislike github
18:50:31 <dcoutts> parcs`: heh, and I thought github might be ok if only they didn't use git
18:50:35 <nh2> dcoutts: how can I check if the patch I'm going to send compiles then?
18:50:37 <ddarius> lispy: It's certainly the case that category theory has been useless for Haskellers up to now.
18:51:06 <ion> I noticed Galois is hiring ArduPilot people. That‚Äôs cool. I‚Äôm going to try to make a drone out of an RC plane with a couple of friends. We‚Äôre not going to use ArduPilot, though; i want to NIH my own in Haskell to learn things like using the Kalman filter for sensor fusion.
18:51:06 <dcoutts> nh2: ohh ok, you're hacking on base? Then you need to build it with ghc. See the ghc dev wiki for instructions on building ghc from sources.
18:51:36 <nh2> dcoutts: thanks. Yeah I'd like to add scanl'
18:51:42 <lispy> ddarius: Well, we don't need to understand it deeply, but cat theory hasn't been useless. It's given us something to talk about on the mailing lists :)
18:51:55 <ddarius> lispy: Not to mention IRC!
18:51:59 <lispy> ion: hardcore!
18:52:04 <geekosaur> hm.  patch-tag?
18:52:24 <nh2> parcs`: if deep in your heart you would like to like github, I can make some arguments for you ;)
18:52:31 <lispy> geekosaur: I still like github a few orders of magnitude more (not that patch-tag is bad for a one man show part-time)
18:52:47 <ddarius> ion: I'll probably release some unscented (and scented?) Kalman filter soon.
18:52:55 <ion> ddarius: cool
18:53:50 * nand` likes darcsden
18:54:21 <hpaste> edwardk pasted ‚Äúshrunk indexed issue‚Äù at http://hpaste.org/73967
18:54:59 <shapr> Whoa, Galois hiring ArduPilot?!
18:55:25 <lispy> shapr: we need to formally verify some autonomous vehicles
18:55:33 <shapr> wow, crazy awesome
18:55:46 <shapr> Haskell + Arduino = awesome
18:55:46 <lispy> shapr: http://corp.galois.com/blog/2012/8/21/galois-internship-available.html
18:56:17 <ion> I‚Äôm going to use a Beagle Bone instead of an Arduino. A bit more CPU power for those heavy Kalman filter calculations et al. :-)
18:56:24 <shapr> lispy: Um, I want to be a Galois intern :-)
18:56:55 <shapr> But I'm not available until the next summer :-(
18:57:21 <lispy> shapr: apply feb/march for summer
18:57:29 <shapr> sounds good to me
18:57:40 <lispy> put it on your calendar, right now :)
18:57:50 <lispy> even if you don't see us make an announcment
18:57:52 * geekosaur looked at that but doesn't think he qualifies as intern... also a little dubious on some of the qualifications, meh
19:02:29 <lispy> geekosaur: my philosophy is to apply. I encourage everyone to apply
19:02:46 <lispy> geekosaur: let us decide about your qualifications, for instance
19:02:59 <ddarius> ion: I've also been looking at Sequential Monte Carlo, but those seem to typically be pretty heavy.  You may want to look into Covariance Intersection though.
19:04:54 <ion> ddarius: Thanks, will google.
19:05:39 <adnauseam> woah
19:05:50 * adnauseam adds galois to his list 
19:05:59 <adnauseam> i'll try in a couple of years :o
19:06:10 <lispy> adnauseam: awesome
19:06:41 <adnauseam> it's nice to see the haskell job market has life in it
19:06:46 <lispy> our internship program has been really successful. We've found some great long term folks that way
19:07:12 <adnauseam> it's one of my worries, no one at my uni does haskell, i think i'm the only guy who likes it. most of my fellow students look at me strangely :[
19:07:30 <lispy> heh
19:07:33 <avpx> adnauseam: I know that feeling
19:08:00 <lispy> Well, take a page from dons' book. Demonstrate how awesome it is and maybe they'll notice and like what they see.
19:08:02 <adnauseam> thatfeelhug.jpg :[
19:08:02 <edwardk> adnauseam: meh. why follow the pack? all you can do is aspire to be mediocre that way
19:08:20 <avpx> True, with Haskell you gain a sense of superiority over your peers
19:08:42 <edwardk> by copying what everyone else does all you can do is not get fired and regress to the mean
19:09:08 <edwardk> its not so much about superiority, its just that folks have been there, done that. do something new. ;)
19:09:11 <adnauseam> edwardk: it's going to be a bumpy ride tbh. it seems that if i choose haskell the haskell, our professors here will either have to find someone to grade my project once i get to doing it.
19:09:11 <lispy> I'm not smart enough to program complex things in other languages. Strict imperative code is hard. Mutability hurts my brain. So, superior? I dunno. Productive? Yes.
19:09:56 <Nafai> I wish I would have known about Haskell back in university
19:10:07 <edwardk> adnauseam: well, mix and match to suit the situation, of course
19:10:23 <lispy> (Now, with that said I do have to use C and C++ somewhat regularly either for low level OS stuff or because a framework I need is written in it)
19:10:25 <avpx> Nafai: I dunno, I've been writing code in Haskell since high school and it's really made me hate programming in many of the more popular languages.
19:10:28 <edwardk> i discovered haskell right as i was leaving academia
19:10:48 <adnauseam> aye, hopefully php will be enough OOP practice while i keep on the haskell way
19:10:55 <danharaj> hahahah php
19:10:56 <adnauseam> i hope to start doing some opengl stuff soon
19:11:07 <avpx> adnauseam: PHP is an excellent example of the sort of thing Haskell makes you hate
19:11:10 <adnauseam> well it's either that or go java server pages :P
19:11:12 <lispy> adnauseam: cool, you can help make the haskell opengl better :)
19:11:25 <adnauseam> building wordpress plugins/themes is how i plan to get into web design on the side :o
19:11:42 <lispy> speaking of which, I really need to explain to the other hopengl folks what we need to do to get a version bump in for the next HP
19:11:44 <Nafai> avpx: Yeah, there is that problem.
19:11:45 <avpx> I think the biggest idiotic decision in PHP I discovered this summer was this: ints are fixed-size but vary by platform, there is no way to choose an int size, and when ints get too big they are automatically promoted to floats
19:11:51 <nh2> Cale: http://hackage.haskell.org/trac/ghc/ticket/7203
19:12:05 <adnauseam> avpx: haskell makes you hate everything else i've noticed.
19:12:12 <adnauseam> i was a nuetral java person before
19:12:20 <adnauseam> now i look at java and rage.
19:12:29 <avpx> Java's alright, it has parametric polymorphism at least
19:12:32 <lispy> Haskell hasn't made me hate Agda :)
19:12:42 <adnauseam> mhm, agda :o
19:12:46 <danharaj> Agda makes me hate agda :p
19:12:49 <avpx> I haven't used Agda yet
19:13:42 <adnauseam> agda is functional! :o that's cheating :P
19:13:51 <adnauseam> functional won't hate functional, all that much :P
19:13:53 <avpx> It's sort of like the Haskell type system but with dependent (undecidable) types?
19:13:56 <ddarius> avpx: PHP is an excellent example of the sort of thing PHP makes you hate.
19:14:07 <avpx> ddarius: Yeah, there really are no redeeming characteristics
19:14:28 <lispy> avpx: they are decidable in the right contexts (meaning that you have to do evaluation at compile time)
19:14:36 <danharaj> Is PHP even a programming language? It doesn't seem to have a well defined grammar.
19:14:37 <adnauseam> ddarius:  i understand where avpx is coming from really, but if one wants to get into some heavy worpress modding, it's inescapable, plus it's not as bad as people make out to be
19:15:08 <lispy> avpx: dependent means that types can depend on values. The classic example being "Vec 5" is a list of 5 elements
19:15:11 <avpx> adnauseam: I used it quite a bit this summer and I have to say, it's quite a bit worse than people make it out to be. But that's obviously opinion :p
19:15:12 <adnauseam> well whether it is or not is not exactly an argument to whether we should use it or not. there are good systems written withi t
19:15:22 <adnauseam> and technically, i wouldn't classify php as a language
19:15:33 <avpx> adnauseam: It's more of a frustration engine?
19:15:36 <monochrom> so don't do wordpress modding. unless you get paid heavily
19:15:39 <adnauseam> it's an interpreted server side scripting language, i suppose
19:15:45 <adnauseam> haha avpx
19:16:06 <avpx> lispy: Sounds interesting, and I guess that would replace some TH stuff we have to deal with
19:16:32 <adnauseam> yeah, learning it is a drag, i kind of miss haskell's type system and cruelty there. the error messages are pretty lacking
19:17:28 <avpx> adnauseam: T_PAAMAYIM_NEKUDOTAYIM not helpful enough?
19:17:39 <lispy> avpx: I'm not really familiar with using TH to simulate dependent typed programming in Haskell. More often I see people "reflect" values to the type level, like data Zero; data Succ a; and then Succ Zero = 1
19:17:42 <adnauseam> lol avpx
19:17:47 <adnauseam> ironically i understand hebrew ;[
19:18:03 <adnauseam> and i find what they did there extremely retarded
19:18:04 <lispy> avpx: and then you can use a type class for arithmetic and functional dependencies to add a relation for adding
19:18:23 <avpx> lispy: I wasn't suggesting that TH can do dependent types (can it? I'm not familiar enough to say), but rather that you can use it to automatically generate functions that operate on various-length tuples, for instance
19:19:05 <avpx> lispy: That's quite interesting though, I'll have to check it out
19:19:11 <lispy> avpx: I've never really thought about the overlap between stagged computations (that's how I would describe TH) and dependent types. I'm sure you can come up with lots of overlap.
19:20:17 <lispy> avpx: it's interesting to do type level programming in Haskell, but if you use it in "production" code people will want to shoot you :)
19:20:42 <avpx> I try to avoid TH for that reason; I find it hard to deal with, and would rather write a little boilerplate
19:20:42 <lispy> But don't let that scare you away from studying it. It's a good way to learn more about Haskell
19:22:08 <avpx> Reading more about this, it's kind of interesting the design decisions they made in Agda.
19:22:14 <avpx> No runtime errors?
19:22:27 <lispy> Very few people "run" Agda programs
19:22:37 <avpx> You basically just typecheck?
19:22:42 <lispy> Yeah
19:22:48 * roconnor has stopped running Haskell programs
19:22:53 <lispy> At least if you're proving things
19:23:10 <avpx> Right, as a programming language it's probably not much use if you're just type checking :p
19:23:21 <lispy> avpx: if you want to have the option of proofs but you plan to run the programs, I would recommend Idris instead.
19:23:55 <lispy> avpx: well, you can formalize math problems or program specifications and then prove things about them (aka reason about the specification)
19:24:26 <lispy> avpx: http://corp.galois.com/blog/2012/8/21/tech-talk-abstract-anything-theory-and-proof-reuse-via-dtp.html
19:24:27 <avpx> Sounds cool
19:24:56 <lispy> avpx: that talk was all about showing elegant ways to encode basic category theory things in Agda and start making proofs about them
19:25:34 <avpx> Could you do something like use the type system to prove a supposed "monoid" really is associative and has an identity that works?
19:26:06 <ixmatus> I really like Haskell a lot - I cut my functional programming chops on Erlang and Scheme but the more I use Haskell the more I fall in love with it
19:26:14 <lispy> avpx: a big unresolved technical problem in the theorem proving community is how to take all that code and turn it into something that runs fast
19:26:14 <ixmatus> </random_swoon>
19:26:39 <avpx> lispy: What do you mean "runs fast?"
19:26:44 <avpx> At type check time or at actual runtime?
19:26:46 <lispy> avpx: yes, but quickcheck might be a better place to start (if you find a counter example then you save yourself the effort of trying to prove something that isn't true)
19:27:14 <avpx> ixmatus: Agreed
19:27:28 <avpx> ixmatus: One thing I miss very much in Scheme is pattern matching :-\
19:27:35 <lispy> avpx: Suppose you code up some physics simulation in Agda so you can prove properties about it. Now you want to run the simulation. If you compile the agda it will likely run 1000 times slower than in Haskell.
19:27:48 <avpx> Ah.
19:28:04 <ixmatus> avpx Racket provides a module for that, including some cool stricter Typing related modules too
19:28:51 <avpx> lispy: That's interesting, and a bit surprising to me
19:28:53 <ixmatus> LISP's homoiconicity is just too much "free form" IMHO though - and with Haskell you get quasi quotes which allow you to build new syntactic structures anyway!
19:29:21 <lispy> avpx: There are essentially 4 approaches here: 1) Extract from Agda to Haskell. 2) Compile from Agda to something native. 3) Write in C and translate the spec to Agda and verify just the spec. 4) Write two copies that are almost identical, except one is in Agda.
19:29:58 * slack1256 wishes to have 2-3 free months to learn Agda/Coq/Epigram and start pushing it in his academy
19:30:09 <lispy> avpx: Once the code is in Agda it can be hard to tell what is there to make the type checker happy (remember it evaluates thing at compile time), and what is there to implement the algorithms (the physics simulation)
19:30:22 <avpx> Ah, I see now
19:30:35 <lispy> avpx: so if you go with (1) it's hard to figure out what to throw away
19:30:43 <avpx> Yeah, that makes sense.
19:30:50 <lispy> I guess that's true of (2) as well
19:31:15 <lispy> The problem with (3) should be obvious and the problem with (4) is similar.
19:31:22 <ixmatus> lispy what about Haskell makes theorem proving unreasonable? Haskell seems pretty pure to me from a non-academic user's point of view
19:31:45 <lispy> In theory, dependent code should be able to be made very very efficient because you know so much more and have strong guarantees
19:32:20 <avpx> lispy: That's what I figured, and why I was surprised. It seems like the more information you give the compiler about exactly what your program *can* do, the better off you are
19:32:22 <lispy> ixmatus: You can do the loose and fast reasoning with Haskell pretty effectively
19:32:33 <lispy> ixmatus: but it's not considered formal
19:33:00 <avpx> But I can also see that when types and values start to mingle, it becomes hard to distinguish the actual computation from the type checking
19:33:13 <ixmatus> ahh okay - I suppose I don't understand enough about formal reasoners to know why Haskell wouldn't be a good fit for it
19:33:36 <lispy> ixmatus: not formal in the sense of logic or mathematical rigor. For instance, I can insert undefined or _|_ pretty much anywhere in a Haskell program
19:34:21 <lispy> ixmatus: did you know that if Haskell was a logic then the type of fix would be "absurd"?
19:34:27 <lispy> :t fix
19:34:29 <lambdabot> forall a. (a -> a) -> a
19:35:02 <lispy> ixmatus: if you were reading that as a proposition it would say, give me an implication that 'a' implies 'a' and I'll give you 'a'
19:35:20 <lispy> ixmatus: But that's circular logic
19:35:22 <adnauseam> kind of does sound like magic :o
19:35:29 <ixmatus> yes true I understand that
19:35:38 <adnauseam> (a -> a) -> a -> a sounds better
19:35:40 <adnauseam> but.
19:35:52 <ixmatus> wouldn't it be reasonable to write a subset of the Haskell standard that could be "formal"?
19:36:13 <ixmatus> er I should be asking "would" rather than "wouldn't"
19:36:14 <MostAwesomeDude> No. You want a *simple* system if you're gonna prove things.
19:36:20 <lispy> ixmatus: What this means for proofs is that you can't really use the logic of Haskell's type system to prove anything very strong about Haskell programs
19:36:21 <adnauseam> mhm, i wouldn't mess with the base, you could create a formal lib though
19:36:26 <adnauseam> it shouldn't be a problem at all.
19:36:46 <MostAwesomeDude> This is why things like Coq are not powerful enough to be Turing-complete.
19:37:08 <lispy> ixmatus: your intuition is right on. Milner invented ML for writing programs to check proofs.
19:37:22 <ixmatus> lispy MostAwesomeDude this is very interesting because I remember reading a little bit about BitC
19:37:35 <lispy> ixmatus: the foundation of these HOL style theorem provers is the simply typed lambda calc
19:38:37 <ixmatus> yeah I figured lambda calculus is a natural fit - I guess I assume too much about Haskell's type system (I thought logical formalism would be reasonable but what you and MostAwesomeDude are saying makes complete sense)
19:38:53 <nh2> how would you write a test case that checks if you have a memory leak?
19:39:26 <lispy> ixmatus: http://people.cs.uu.nl/andres/LambdaPi/LambdaPi-old.pdf
19:39:37 <nh2> e.g. my newly added (last . scanl') runs in constant memory, and I'd like to add some test case for my function using it that checks if the memory usage goes crazy
19:39:50 <lispy> ixmatus: that "tutorial" teaches you how to implement a dependently typed lambda calculus starting from the simply typed
19:40:02 <nh2> a hack workaround would qualify
19:40:35 <lispy> ixmatus: I have a reading list (too long to send over IRC) that I could share with you
19:40:37 <avpx> nh2: Feed it some infinite list, I guess
19:40:56 <ixmatus> lispy I would love that
19:41:04 <lispy> > (last . scanl') [1..]
19:41:05 <lambdabot>   Not in scope: `scanl''
19:41:09 <lispy> > (last . scanl) [1..]
19:41:10 <lambdabot>   Couldn't match expected type `[a]'
19:41:10 <lambdabot>         against inferred type `a1 -> [b]...
19:41:15 <nh2> avpx: I'd like the test case to go red, not my computer to run out of resources
19:41:16 <lispy> you get the idea
19:41:33 <avpx> nh2: I see what you mean
19:41:58 <nh2> like a call into GHC internals that allow me to limit the memory usage to some arbitrary value
19:43:10 <nh2> I once saw some package on hackage that claimed to test for "how lazy a function is"
19:43:42 <nh2> ah, sloth: http://hackage.haskell.org/package/sloth
19:46:00 <Jafet> +RTS -something
19:46:34 <Jafet> Set a heap size
19:56:01 <slack1256> until how much time in GC is acceptable? 40%?
19:57:32 <lispy> slack1256: yeah, shoot for < 30%
19:57:36 <lispy> later all
19:57:47 <slack1256> later lispy
19:58:00 <n00b6502> how mcuh time in  gc is aceptablee.. 0 :)
19:58:42 <slack1256> noob6502: let's set the heap in 25Gb
19:59:02 <slack1256> that should be enough for anybody right?
20:08:06 <Z`> Does _ also match the () ?
20:08:17 <Z`> function (xs:_) = ...
20:08:36 <Z`> does that guarantee the existence of 1 more element after xs ?
20:09:07 <Jafet> > let (x:xs) = [1] in (x, xs)
20:09:08 <lambdabot>   (1,[])
20:09:11 <nh2> Z`: if (x:_) matches, yes, your list has at least one element
20:09:22 <carpi> is this valid and legal -> "data Btre a = Maybe (a (Btre a) (Btre a))" ?
20:09:25 <Jafet> > let (x:xs) = (1:[]) in (x, xs)
20:09:26 <lambdabot>   (1,[])
20:09:58 <AfC> Z`: calling it (xs:_) is misleading. The usual idiom is (x:xs) for a reason
20:10:01 <Jafet> carpi: what do you think it means?
20:10:07 <Jafet> It's legal
20:10:18 <nh2> anyone knows what the name of that package was that exposes run-time info/statistics of the current haskell program, e.g. about a webserver?
20:10:26 <nh2> ah ekg
20:11:37 <carpi> Jafet: I think it means that a value of type "Btre a" can either be "Nothing" or "Just a". In this case 'a' being (a (Btre a) (Btre a))
20:11:46 <carpi> would i be wrong?
20:12:01 <Z`> If I;d like to match a list with 3 elements, would I write:    myf [x,y,z] = ... or myf (x:y:z) = ... ?
20:12:11 <Z`> I assume the first ?
20:12:31 <Jafet> That defines (Btre a) as a type with a constructor Maybe containing a value of type (a (Btre a) (Btre a))
20:12:44 <Jafet> The type a has kind (* -> * -> *)
20:13:28 <Jafet> So for example (Btre (,)) has a corecursive structure Maybe (Maybe (Maybe ..., Maybe ...), Maybe ...)
20:13:52 <Jafet> It's a very fun tree, but probably not what you mean
20:14:36 <adnauseam> to implement a hash tree, should one go for a binary search tree, or a rose tree ?
20:14:37 <carpi> Jafet: lol. I honestly thought it would allow me to represent a simple binary tree with a single value constructor.
20:14:41 <carpi> guess im wrong
20:15:11 <carpi> i wasn't actually 'lol'ing. why did i type that.. !
20:15:13 <adnauseam> hmm, what's a single valued constructor btw ? (excuse my ignorance)
20:15:18 <carpi> habit
20:15:21 <Jafet> Btre a = Btre (Maybe (a, Btre a, Btre a))
20:15:22 <adnauseam> that's the internet for you
20:16:43 <Jafet> What is a hash tree?
20:16:51 <Jafet> Is that anything like hemp
20:16:58 <adnauseam> jafet, wouldn't that need a a nothing somewhere ? :o
20:17:10 <Jafet> Sure, Btre Nothing
20:17:10 <adnauseam> Jafet: hah :P
20:17:17 <carpi> Jafet: but now a value of type "Btre a" cannot be 'nothing' .. which is actually correct.
20:17:38 <adnauseam> it's a hash table structure stored in in a tree instead of regular array
20:17:59 <carpi> the reason i used "data Btre a = Maybe (a (Btre a) (Btre a))" was cos i thought a value of type "Btre a" could be "nothing"
20:18:23 <adnauseam> Jafet: oh, is  nothing derived by having Maybe there? since maybe itself is Nothing | Just a ?
20:18:24 <Jafet> Nothing has the type (Maybe a)
20:18:32 <Jafet> It cannot have the type (Btre a)
20:18:37 <adnauseam> true
20:18:40 <Jafet> as they look pretty different
20:18:55 <adnauseam> i always confuse data types and data constructors >.<
20:19:06 <carpi> same >>.<<
20:19:07 <Jafet> But if the Btre constructor has Maybe as a parameter, it can produce Btre Nothing
20:20:30 <Jafet> adnauseam: if you are using a search tree to store the hash table, then there is no point writing your own search tree. Just use Map
20:20:48 <adnauseam> Jafet: just an academic exercise man
20:21:51 <carpi> can  a tree defined this way really be as efficient as a tree that is described in an imperative language?
20:22:15 <Jafet> Efficient in what
20:22:24 <adnauseam> hmm, that heavilly depends on the use
20:22:40 <Jafet> Trees in containers use a bit more faerie dust than those from glibc
20:23:03 <Jafet> But we only source from sustainable welsh folk tales
20:23:07 <adnauseam> tree libraries are written by some hardcore people, and i think they use sets and collections and other fancy data structures to make things efficient
20:25:00 <carpi> Jafet: efficient in terms of speed ... for example. Cos i find it hard to believe that a tree type described so trivially in 2 lines in haskell can be as efficient as tree data structures in imperative languages..
20:25:45 <dibblego> suspend disbelief before investigation
20:25:47 <Jafet> Trees are not executable
20:25:51 <adnauseam> ^
20:26:01 <Jafet> Algorithms on trees are executable, and have speed
20:26:15 <Jafet> Trees do not have speed, unless you count the ones in middle-earth
20:26:39 * adnauseam cheered for the ents
20:28:54 <carpi> i liked the middle-earth reference. I wonder if the one eyed sauron would have won if he knew haskell. I doubt
20:30:06 <startling> carpi: obv. the non-haskel code is less efficient. more disk reads
20:30:10 <Jafet> Trees are trivial to describe in imperative languages
20:30:42 <Jafet> template <class T> class Btre { T a; Btre <T> *l, *r; };
20:31:17 <Jafet> data Btre a = Nil | Btre a (Btre a) (Btre a)
20:31:26 <Jafet> It's not even much shorter
20:32:10 <carpi> startling: meaning .. haskell naturally tends to avoid reading from the disk as much as possible?
20:32:17 <startling> carpi: shorter code
20:42:01 <Z`> I don't see to be able to use 'Either' correctly. I write:      myf :: [a] -> Either a []
20:42:18 <Z`> meaning that I'd like it to map all types of lists of a to either a or the empty list
20:42:39 <Saizan> "the empty list" is not a type
20:42:47 <startling> Z`: well, "the empty list" is a value of many possible types
20:42:55 <Z`> ooops, there you go
20:42:56 <Z`> :)
20:42:59 <startling> Z`: but this isn't really what Either is for
20:43:04 <startling> Z`: you probably want Maybe
20:43:17 <Z`> Starfire: maybe
20:43:26 <Z`> let me read on that :)
20:43:48 <startling> Z`: a value of Maybe a can either by Just (some a) or Nothing
20:44:14 <Saizan> myf :: [a] -> Either a [a] would be a valid type, and would let you return (Right []), but it also allows (Right (x : xs))
20:48:20 <Z`> if I write myf :: [a] -> Maybe a  I cannot then write myf [x,y] = x
20:49:32 <Saizan> you couldn't with Either
20:49:43 <augur> http://xkcd.com/1090/
20:49:44 <augur> :D
20:49:46 <Z`> Indeed
20:50:18 <Saizan> write myf [x,y] = Just x, then
20:52:21 <Z`> alright, but houw could I return the empty list if an empty list was given?   myf [] = []
20:53:07 <startling> Z`: sure
20:53:45 <Z`> ghc says that it can't match 'maybe a' with actual type '[a]' in myf [] = []
20:54:01 <scshunt> win 22
20:54:52 <startling> Z`: oh, you'd want myf [] = Just []
20:55:08 <Z`> I tried that too. it didn't work
20:55:10 <startling> Z`: data Maybe a = Just a | Nothing
20:55:14 <Z`> ah
20:55:15 <Z`> hold on
20:56:12 <Z`> yeh.  myf :: [a] -> Maybe a     and then    myf [] = Just []     errors
20:56:44 <startling> Z`: oh right
20:56:50 <startling> you want Maybe [a], right?
20:57:00 <startling> or do you want to return only one of a value?
20:57:06 <Z`> only 1
20:57:17 <startling> Z`: then how would myf [] = [] ?
20:57:28 <Z`> opps, right. let me fix it
20:57:36 <startling> Z`: you might want myf [] = Nothing
20:57:41 <startling> Z`: what does myf do?
20:58:28 <Z`> yupi. it works :D startling: it returns the previous but last element of a list. (exercise, not real problem)
20:58:34 <Z`> thanks for caring
20:58:54 <jfischoff> so why would splitting a large file into several pieces increase a clean build time by third (one minute) ?
20:58:59 <startling> Z`: ah, yeah, you'd want myf [] = Nothing
20:59:24 <jfischoff> err decrease I mena
20:59:26 <ion> jfischoff: Dunno, but you get less optimization across the pieces.
20:59:34 <jfischoff> it sped up
20:59:43 <Z`> Are there any subtleties on return 'Just something' ? Would I have later on problems with matching 'something' against 'Just something' ?
20:59:49 <jfischoff> ion: good point
21:00:08 <ion> unless your compiler does whole-program optimization.
21:00:32 <startling> Z`: Just something == Just something
21:01:16 <jfischoff> does ghc do any whole-program optimization?
21:01:54 <startling> jfischoff: are you paging out?
21:02:10 <startling> re "so why would splitting a large file into several pieces increase a clean build time by third (one minute) ?"
21:02:33 <jfischoff> i meant decreasing and no
21:02:44 <startling> hm. no idea
21:04:36 <jfischoff> I think ion could be right, could be optimization related, but I haven't explicitly set my optimization level
21:05:25 <startling> Z`: in other words, so long as a has Eq, Maybe a also has Eq
21:05:47 <Z`> thanks startling
21:06:10 <startling> but something == Just something is nonsensical -- they're different types
21:13:30 <Z`> I write    myf [] :: [a] -> Int    and then I use the equation     myf [] = 0
21:13:42 <Z`> but If I call it from ghci as myf [] it says non-exhaustive matching
21:14:01 <Z`> why didn't it match ?
21:14:45 <Fuuzetsu> that's not a correct signature in the first place I think
21:14:48 <Sculptor> Z`, shouldn't you lose the [ ] part
21:14:55 <Sculptor> before ::
21:14:59 <Fuuzetsu> ^
21:15:04 <startling> Z`: yeah, the type signature is messed up
21:15:16 <Sculptor> i started learning haskell 2 days ago. 5 credits for me
21:15:18 <startling> Z`: but dunno why it's not working for you -- perhaps you didn' savethe file?
21:15:37 <startling> would also explain the lack of syntax errors
21:15:50 <Z`> er sorry, I meant:   myf :: [a] -> Int
21:16:05 <Sculptor> gtg to wrk
21:16:11 <Fuuzetsu> Z`: then it should work
21:16:15 <Fuuzetsu> myf :: [a] -> Int
21:16:18 <Fuuzetsu> myf [] = 0
21:16:26 <Fuuzetsu> gives me 0 when I apply myf to []
21:16:52 <Z`> bummer, I had a typo in functions name. Sorry for noise:|
21:17:31 <startling> hehe
21:17:45 <Z`> haskell won again
21:17:49 <Z`> grr
21:19:13 <carter> lispy: are any galois folks playing with idris or agda in some level :)?
21:20:16 <Z`> f . g is \x -> f (g x)   but isn't f g the same as well ?
21:20:23 <Z`> what am I missing
21:21:06 <Saizan> f g is not that, it's just f g
21:21:09 <vodik> f g would imply f :: (a -> a) -> a
21:21:14 <vodik> iirc
21:21:23 <startling> Z`: no, f g is different
21:21:32 <vodik> assuming f and f have a -> a in your f . g example
21:21:43 <startling> Z`: f g calls f with g as the first argument
21:21:59 <Z`> whereas f . g ?
21:22:20 <vodik> Z`: consider the types
21:22:26 <vodik> f :: a -> a
21:22:27 <startling> Z`: f . g is \x -> f (g x)
21:22:31 <vodik> g :: a -> a
21:22:39 <vodik> f . g :: a -> a
21:22:45 <vodik> f g however wouldn't compile
21:22:51 <vodik> f would need to be
21:23:02 <vodik> f :: (a -> a) -> ...
21:23:04 <Z`> oh, alright I'm starting to getting it
21:23:14 <vodik> since its expecting g to /litteraly/ be the first argument
21:23:22 <startling> Z`: have you seen map yet?
21:23:26 <Z`> and not the results of its execution ?
21:23:31 <Z`> startling: a little
21:23:38 <startling> Z`: map is an example of a function that takes a function as an argument
21:23:53 <startling> Z`: map (+1) calls map with (+ 1) as its argument
21:23:57 <Z`> so f g is "call f with g as the 1st argument" whereas f . g is "call g and feed the result of it to f" ?
21:24:27 <startling> Z`: map . (+ 1) is (in most cases) nonsensical
21:24:36 <startling> (it'd make sense in caleskell, but shhh)
21:25:00 <Z`> alright, so the defition of f . g is in alignment with that in mathematics
21:25:04 <Z`> were f o g = f(g(x))
21:25:07 <startling> Z`: indeed
21:25:30 <Z`> thanks people for being so patient with me. I appreicate it!
21:25:35 <startling> Z`: note that haskell's currying has some fun implications here
21:25:40 <Z`> like ?
21:27:06 <startling> :t map . map
21:27:07 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
21:27:27 <Z`> mind blowing
21:27:42 <Catnaroek> join ##c++
21:27:49 <startling> Catnaroek: no, you
21:27:51 <Catnaroek> sorry fail
21:28:04 <Catnaroek> :-(
21:28:05 <Z`> BTW, I've found a funny implementation of calculating the length of a list. The author writes:      myLength = sum . map(\_->1)
21:28:17 <monochrom> /leave ##c++
21:28:44 <Z`> so basically map matches every element of the list to 1, and then sums over allo the 1's ?
21:28:49 <monochrom> yes
21:28:55 <Z`> cool
21:29:06 <startling> @pl sum . map (const 1)
21:29:06 <lambdabot> sum . map (const 1)
21:29:23 <startling> Z`: const x = \_ -> x; perhaps a bit more idiomatic
21:29:34 <Z`> oh ok
21:29:48 <Catnaroek> Do you not find explicit lambdas a little bit ugly?optimizations. The resulting code one gets from judicious use of templates can substantially outperform even well-tuned C code.
21:29:51 <Catnaroek> Damn.
21:29:54 <Catnaroek> Again I am pasting wrong test.
21:29:55 <Z`> when we do pattern matching in right of '=' do we need to always put a leading \ ?
21:30:03 <Z`> for example in the left of '=', we don't
21:30:11 <Z`> myf (_:xs) = ...
21:30:12 <startling> Z`: not sure what you mean
21:30:17 <startling> leading \ is "lambda"
21:30:29 <Z`> ah ok! lamda function or anonymous function
21:30:45 <Z`> I though it was escaping the '_' :P
21:30:46 * Z` ducks
21:30:48 <startling> both
21:31:42 <startling> no, _ just means "don't use this argument, we don't care what it is"
21:32:11 <monochrom> _ is part of pattern matching. this is the wildcard pattern
21:32:40 <Z`> alright, so map(\ _ -> 1) matches every element and 'sends' it to 1
21:32:48 <Z`> what if, I'd like to match 2 consecutive elements
21:32:50 <vodik> startling: _ is a wildcard, so to speak
21:32:54 <vodik> err Z` ^
21:33:05 <Z`> like, map(\ _ _ -> 1) and get half of the elements of the list ?
21:33:11 <startling> Z`: map doesn't do that
21:33:19 <Z`> thanks vodik / monochrom . so it's like '*' in shell scripting
21:33:27 <startling> sure, why not
21:33:29 <vodik> Z`: each _ /could/ be a variable
21:33:33 <monochrom> a lambda expression is (\ pattern -> body), you can use _ in the pattern
21:33:37 <vodik> Z`: no, not like *, thats wrong actually
21:33:46 <vodik> Z`: \_ _ -> 1 is the same as \x y -> 1
21:33:55 <monochrom> a defintion is "name pattern = body", you can use _ in the pattern
21:34:02 <vodik> Z`: but if you don't use x or y, you can use _ instead to so that its unused
21:34:37 <Z`> ok, so why doesn't  halfsum = sum . map(\ _ _ ->1) work. hm
21:34:40 * hackagebot tagstream-conduit 0.5.0 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.0 (YiHuang)
21:34:42 * hackagebot tagstream-conduit 0.5.1 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.1 (YiHuang)
21:34:50 <vodik> Z`: because map doesn't take _2_ arguments
21:34:56 <Z`> ah, ok
21:35:04 <monochrom> type error
21:35:06 <Z`> let mem read its signature
21:35:16 <startling> no, it should work
21:35:22 <startling> well, not with sum
21:35:25 <startling> but you can do
21:35:25 <vodik> Z`: \_ -> 1
21:35:25 <vodik> :t map
21:35:26 <vodik> @t map
21:35:26 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:35:26 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:35:35 <startling> > map (\_ _ -> 1) [1, 2, 3]
21:35:36 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
21:35:36 <lambdabot>    arising from a use of ...
21:35:56 <startling> Z`: it gives you a list of (\_ -> 1) functions
21:36:05 <startling> because of partial application
21:36:09 <Z`> ah heh, yes
21:36:24 <startling> and you can't sum (\_ -> 1) functions in standard haskell
21:36:28 <vodik> > map ($ 3) $ map (\x _ -> 1) [1, 2, 3]
21:36:29 <lambdabot>   [1,1,1]
21:36:34 <vodik> hmm
21:36:44 <vodik> > map ($ 3) $ map (\x _ -> 1 + x) [1, 2, 3]
21:36:45 <lambdabot>   [2,3,4]
21:37:00 <vodik> > map ($ 3) $ map (\_ x -> 1 + x) [1, 2, 3]
21:37:00 <startling> vodik: lambdabot has instance Num for Num d => x -> d
21:37:01 <lambdabot>   [4,4,4]
21:37:05 <vodik> there we go
21:37:29 <vodik> startling: interesting
21:37:33 <startling> > (sum . map (\_ _ -> 1)) [1, 2, 3]
21:37:37 <lambdabot>   mueval-core: Time limit exceeded
21:37:48 <startling> woah weird
21:38:05 <vodik> i think its Num d => d -> x
21:38:12 <Z`> so map (\_ _ -> 1) [1,2,3] partially applies the lambda function \_ _ -> 1 to every element of the list ?
21:38:17 <startling> Z`: yep
21:38:27 <vodik> Z`: yes sir
21:38:29 <startling> > map 1 [1, 2, 3]
21:38:30 <Z`> :)
21:38:30 <lambdabot>   [1,1,1]
21:38:39 <startling> vodik: nope, 1 is (const 1)
21:38:44 <Z`> what is the result of partial application of \_ _ -> 1 to the 3rd element for example?
21:38:52 <startling> Z`: \_ -> 1
21:38:53 <vodik> startling: interesting
21:39:04 <startling> vodik: so fn + fn = \x -> fn x + fn x
21:39:32 <vodik> cool
21:39:37 <Z`> startling: the result is another lambda function taking 1 argument and return always 1 ?
21:39:42 <startling> Z`: yep
21:39:43 <Jafet> The Num instance is just the vector space over functions
21:39:56 <Z`> alright
21:39:57 <startling> Z`: except "lambda function"s aren't any different than regular functions
21:40:02 <Jafet> Though I don't want to know what (*) is, maybe it's the inner product
21:40:07 <Z`> comprehension is such a calming feeling
21:40:11 <Jafet> Actually it can't be
21:40:26 <startling> Z`: because applying one argument to (\_ _ -> 1) gets you (\_ -> 1)
21:41:06 <vodik> > (\_ _ -> 1) 2 3
21:41:07 <lambdabot>   1
21:41:25 <vodik> ^ applying two arguments to the lambda
21:41:32 <vodik> > (\_ x -> x) 2 3
21:41:33 <lambdabot>   3
21:41:48 <Z`> vodik: wait, the first one returned 1 not \_ -> 1
21:41:54 <Z`> ah
21:41:55 <Z`> lol
21:41:57 <vodik> Z`: because there are 2
21:41:58 <vodik> arguments
21:41:59 <Z`> of course, you passed 2 args
21:42:00 <vodik> 2 and 3
21:42:03 <vodik> yup
21:42:08 <Z`> I read it as [2 3],sorry
21:42:16 <vodik> @t (\_ _ -> 1) 4
21:42:16 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:42:41 <vodik> > :t (\_ _ -> 1) 4
21:42:42 <lambdabot>   <no location info>: parse error on input `:'
21:42:48 <Z`> (\_ _ ->1) 4 :: Num a => t -> a
21:42:53 <vodik> hmm, how do i get it to output type
21:42:58 <Z`> how does this type read ? mm
21:43:12 <vodik> Z`: yeah
21:43:16 <vodik> err no
21:43:19 <Z`> (\_ _ ->1) 4 is a type of Num that takes a type as argument
21:43:20 <vodik> two arguments
21:43:25 <Z`> and evalutes to t -> a ?
21:43:46 <vodik> (\_ _ -> a) :: Num a => b -> c -> a
21:44:03 <vodik> there are two arguments there
21:44:08 <vodik> remember
21:44:30 <vodik> (\_ _ -> 1) :: Num a => t -> t1 -> a
22:00:31 <johnw> is anyone else able to use a local hoogle server to browse local Haddock documentation?
22:00:43 <johnw> for instance, I have the Control.Lens docs installed, I can browse them directly
22:00:53 <johnw> but my local Hoogle refuses to link to them, no matter what flags I try
22:01:34 <crdueck> is there a predefined filterMap function? as in filterMap :: (a -> b) -> (a -> Bool) -> [a] -> [b]
22:02:15 <crdueck> @hoogle (a -> b) -> (a -> Bool) -> [a] -> [b]
22:02:15 <johnw> @hoogle (a -> b) -> (a -> Bool) -> [a] -> [b]
22:02:15 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
22:02:15 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
22:02:15 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
22:02:15 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
22:02:15 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
22:02:17 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
22:02:23 <Jafet> @pl \f g -> map f . filter g
22:02:23 <lambdabot> (. filter) . (.) . map
22:02:37 <johnw> wow, grossness in the extreme
22:02:57 <Jafet> The name filterMap actually implies (b > Bool)
22:03:13 <Jafet> There, already the function is not unique
22:09:41 * hackagebot xml2json 0.1.0.0 - translate xml to json  http://hackage.haskell.org/package/xml2json-0.1.0.0 (YiHuang)
22:18:28 <wagle-prime> @pl \f g h -> filter f . map g . filter h
22:18:29 <lambdabot> (. ((. filter) . (.) . map)) . (.) . (.) . filter
22:19:10 <wagle-prime> really IS pointless
22:24:41 * hackagebot xml2json 0.1.0.1 - translate xml to json  http://hackage.haskell.org/package/xml2json-0.1.0.1 (YiHuang)
22:56:52 <ClaireBennett> hi
22:57:01 <ClaireBennett> does the * in Haskell just mean a kind?
22:57:53 <nus> @kind ()
22:57:54 <lambdabot> *
22:58:00 <nus> @kind (->)
22:58:01 <lambdabot> ?? -> ? -> *
22:58:21 <covi> Has any of you tried to learn Ruby with some kind of tutorial? Is there any fairly good tutorial that fits Haskelly apetite?
22:59:22 <ClaireBennett> @kind *
22:59:23 <lambdabot> parse error on input `*'
22:59:54 <nus> @type (*)
22:59:55 <lambdabot> forall a. (Num a) => a -> a -> a
23:01:11 <nus> @type (:)
23:01:12 <lambdabot> forall a. a -> [a] -> [a]
23:01:15 <nus> @kind []
23:01:16 <lambdabot> * -> *
23:02:45 * ClaireBennett tries to comprehend
23:03:10 <nus> @src []
23:03:10 <lambdabot> data [] a = [] | a : [a]
23:03:31 <nus> @src ()
23:03:31 <lambdabot> data () = ()
23:05:21 <newsham> ?src Zero
23:05:22 <lambdabot> Source not found. Maybe you made a typo?
23:05:28 <newsham> ?src False
23:05:28 <lambdabot> Source not found. I am sorry.
23:08:49 <certainty> morning. I read that it is best practice to put type declarations before function definitions. Is that also true for auxiliary functions that apear in a where?
23:09:17 <adnauseam> certainty: no, infact, that's not possible
23:09:26 <certainty> adnauseam: oh, i see
23:09:33 <newsham> you can put type decls in where clause.. its not often done.
23:09:38 <newsham> sometimes its necessary
23:09:50 <adnauseam> if you still want to let them have a declared type, you could just write them as seperate functions, which is more or less the same
23:09:57 <adnauseam> oh
23:10:00 <adnauseam> i stand corrected
23:10:31 <certainty> thanks
23:11:50 <arcatan> hmm, i do it all the time. i guess it's a stylistic issue.
23:11:57 <newsham> see for example http://www.thenewsh.com/~newsham/formal/curryhoward/IntTheorems.hs
23:12:35 <mikeplus64> if the function is big and complicated in the where clause i would probably put a type sig there
23:12:53 <mikeplus64> but if the types are easy to tell from the actual function's type then maybe not
23:15:24 <ClaireBennett> @type !!
23:15:26 <lambdabot> parse error on input `!!'
23:15:34 <newsham> ?type (!!)
23:15:35 <lambdabot> forall a. [a] -> Int -> a
23:16:07 <newsham> > "test" !! 10000
23:16:09 <lambdabot>   *Exception: Prelude.(!!): index too large
23:16:17 <adnauseam> that's actually fascinating
23:16:59 <newsham> that Maybe fascinating
23:17:17 <newsham> but its also irritating
23:17:26 <adnauseam> why do you fight this :o
23:18:15 <newsham> wish there were at least total versions of all these partial fnctions in the prelude
23:20:59 <adnauseam> mhm, which partial functions ?
23:21:17 <newsham> > head []
23:21:18 <lambdabot>   *Exception: Prelude.head: empty list
23:21:19 <newsham> > tail []
23:21:20 <lambdabot>   *Exception: Prelude.tail: empty list
23:21:25 <newsham> > "test" !! 1000
23:21:26 <lambdabot>   *Exception: Prelude.(!!): index too large
23:21:36 <newsham> etc.
23:22:06 <adnauseam> aren't they supposed to fail ?
23:22:15 <Jafet> @hackage spoon
23:22:15 <lambdabot> http://hackage.haskell.org/package/spoon
23:22:25 <adnauseam> i'm a noob btw, i'm trying to understand the problem there
23:22:43 <newsham> pure code throwing an exception means that your pure code can have weird side effects
23:22:50 <newsham> even though the type signature doenst say so
23:23:11 <newsham> you could make them total functions by, for example using   head :: [a] -> Maybe a
23:23:18 <adnauseam> oh, because the exception isn't; included in the result kind ?
23:23:22 <newsham> with no exceptions / side effects
23:23:29 <adnauseam> just like a Maybe covers that with its Nothing ?
23:24:03 <newsham> then you could have a functionw hich turns the total maybehead into the partial head which can throw an exception
23:24:08 <johnw> newsham: how does it have side-effects?  You mean, it can change the code-flow of the code that called the pure function?
23:24:19 <newsham> (or even turn it into    somehead :: [a] -> Either String a)
23:24:48 <adnauseam> i guess because it doesn't say "func() throws SomeException {} "
23:25:12 <newsham> johnw: the exception can happen or not happen depending on what parts of the result are demanded
23:25:12 <Jafet> head [] is undefined
23:25:16 <adnauseam> if we were dealign with custom exception, that could turn awry
23:25:33 <newsham> and might happen much later in your code
23:25:33 <Jafet> That is the problem
23:25:51 <Jafet> This stuff about side effects is irrelevant
23:26:03 <adnauseam> do yuou think it will be ever implemented ?
23:26:12 <adnauseam> or isit a non issue ?
23:26:49 <Jafet> People who want it just implement it themselves, or use a library for it
23:26:55 <certainty> aha, so typeclasses are much like templates in C++
23:27:01 <Jafet> No, they're not
23:27:07 <newsham> its a non-issue if 1) you design your code to properly handle all possible exceptions or 2) you avoid any conditions that can lead to an exception
23:27:16 <adnauseam> it's a mistake to try and compare things in haskell to things outside of haskell
23:27:17 <certainty> Jafet: they appear so
23:27:22 <shachaf> certainty: They're not.
23:27:38 <adnauseam> you have awaken shachaf
23:27:46 <newsham> 1) is harder.  2) is feasible but you dont get any help from the type checker
23:27:48 <Jafet> If you think they are like templates, then you should describe how to implement them using templates.
23:28:02 <johnw> certainty: typeclasses are like the concepts proposal for C++
23:28:04 <Jafet> newsham: 2 implies 1
23:28:06 <certainty> adnauseam: i need something to relate it to so that i can benifit from a mental model i already have. I'm aware that i might be taking it too simple
23:28:08 <newsham> but you could just do it "the hard way" or rely on a third party tool to do the analysis for you
23:28:42 <adnauseam> certainty: i understnad your problem. i'm currently having a problem grasping it myself.
23:29:30 <certainty> johnw: you mean because i can derive from multiple typeclasses√? I was more thinking of them like teplate policies as introduced by alexandrescu
23:29:52 <johnw> template policies == concepts, I believe
23:29:57 <certainty> ah i see
23:30:00 <johnw> for example, if I have template<typename T> class foo
23:30:06 <johnw> concepts says that "T" must support a certain interface
23:30:08 <johnw> aka, type classes
23:30:21 <adnauseam> Show, Eq, etc
23:30:22 <johnw> so, think compile-time interfaces
23:30:24 <shachaf> The best way to understand type classes is to not think about C++.
23:30:25 <certainty> yeah that's semantically somewhat equal
23:30:55 <shachaf> "compile-time interfaces" is hardly a helpful description for type classes. :-(
23:30:56 <johnw> another formulation: interfaces that permit generic algorithms to be optimized at compile-time
23:31:08 <adnauseam> i think typeclasses are more abstract that c++ classes
23:31:13 <adnauseam> s/that/than
23:31:17 <johnw> shachaf: how is it not?
23:31:34 <johnw> and stop giving me frowny faces!
23:31:53 <Jafet> Type classes provide runtime polymorphism.
23:31:54 <certainty> shachaf: i try to understand them seperately. It currently helps me to distinguish the type constructors from value constructors, by relating type constructors to something like a C++ template. I'll try to get rid of that help
23:32:20 <johnw> type classes provide the typechecker with the information it needs to check whether your type is suitable at compile time
23:32:26 <shachaf> certainty: Parametric polymorphism -- e.g. reverse :: [a] -> [a] -- has nothing to do with type classes.
23:32:29 <adnauseam> value constructors = Int ?
23:33:06 <certainty> shachaf: oh right. See i'm already confusing things
23:33:24 <adnauseam> i thought a type constructor is something like a datatype container
23:33:43 <certainty> Maybe a is type constructor wheras Just 1 is a value constructor
23:33:45 <johnw> shachaf: do you care to explain while "compile-time interfaces" is not helpful?
23:33:46 <adnauseam> you got class, data, and instances
23:33:49 <johnw> s/while/why
23:33:50 <certainty> if i understand that correctly
23:33:51 <adnauseam> no ?
23:34:43 * hackagebot monad-task 0.1.0 - A monad transformer that turns event processing into co-routine programming.  http://hackage.haskell.org/package/monad-task-0.1.0 (PaulLiu)
23:34:45 * hackagebot GLFW-task 0.1.0 - GLFW utility functions for use with monad-task.  http://hackage.haskell.org/package/GLFW-task-0.1.0 (PaulLiu)
23:34:47 <shachaf> johnw: Maybe it's helpful if by "compile-time interface" you mean "type class".
23:35:00 <shachaf> But I don't know what you mean, so arguing about that won't help. :-)
23:35:08 <certainty> so is it somewhat ok to relate parametric types to templates, then? This was what i was originally referrring to, i confused the terms
23:36:15 <adnauseam> i think that's a safe assumption, i think of generics which is more or less the same
23:36:15 <certainty> i guess not, since i again compare to other languages.
23:36:33 * certainty stops it
23:36:40 <johnw> shachaf: actually, I think a more accurate rendition would be "instantiation-time interface", in C++ terms
23:36:42 <adnauseam> well it's ok to have something to aid you, but try to understandi t in its own right eventually
23:36:57 <shachaf> johnw: I shan't argue with you on C++ terms.
23:37:40 <adnauseam> so atleast oget things straight, so Maybe is type constructor? is it also a data type ?
23:37:54 <johnw> for template <typename a>, if a must be a Num, the R++ compiler won't know unless you misuse the argument in some way.  In Haskell, you can say that "a" must be an instance of the type class Num, which causes "instantiation" to fail immediately.  This is _exactly_ the behavior model for C++ concepts
23:38:12 <johnw> ok, so R and C are very close on a Dvorak keyboard :)
23:38:18 <certainty> :)
23:38:19 <adnauseam> and Just is a value constructor, is it also a data constructor ?
23:38:41 <johnw> adnauseam: Maybe a is a type constructor; Just a is a value constructor
23:38:46 <johnw> I don't know what a data constructor is
23:38:59 <johnw> rather, Maybe is a type constructor
23:39:02 <johnw> Just is a value constructor
23:39:06 <johnw> sorry about the parameters
23:39:07 <adnauseam> fair enough, i'm confusing myself :[
23:39:42 <Axman6> Maybe is a type constructor, Maybe Int is a type, if that makes it clearer
23:39:46 <johnw> shachaf: one of these days, I'm going to give you a frowny face, and we'll just see how you like it then, won't we
23:40:04 <adnauseam> Axman6: oh yes that did
23:40:06 <Axman6> Maybe needs some type argument before it can become a proper type
23:40:12 <adnauseam> i'm writing this down :o
23:40:29 <adnauseam> is Int also a type ?
23:40:30 <certainty> nice i read types can also partially "applied"
23:40:34 <johnw> adnauseam: yes
23:40:37 <Axman6> adnauseam: it's like how Just is a function of type a -> Maybe a, so Just applied to 1 forms the value Just 1
23:40:44 <johnw> adnauseam: it is a concrete type
23:40:57 <Axman6> :t Just
23:40:58 <lambdabot> forall a. a -> Maybe a
23:41:01 <johnw> adnauseam: type constructors are also used to create concrete types, like Maybe Int
23:41:06 <Axman6> > map Just [1,2,3]
23:41:07 <lambdabot>   [Just 1,Just 2,Just 3]
23:41:27 <johnw> adnauseam: Just is a function (a value constructor function), it is used to create values, like Just 10
23:41:44 <johnw> "Just is just a function."
23:42:24 <johnw> the special thing about Just as a function is (a) it's capitalized, and (b) it can appear in a pattern match
23:42:28 <certainty> Just 1 is a value of the type Maybe Int then, correct? I'm not sure about the Int part, what would the typesystem assume here?
23:42:30 <adnauseam> righton
23:42:39 <johnw> otherwise, you can use it anywhere you could use a unary function
23:42:45 <johnw> certainty: yes
23:43:01 <adnauseam> i always wonder about numbers and letters
23:43:10 <adnauseam> do they internal show up as "Int 7"
23:43:14 <adnauseam> internally*
23:43:21 <Axman6> eh, sort of
23:43:25 <Axman6> @src Int
23:43:25 <lambdabot> data Int = I# Int#
23:43:37 <adnauseam> never seen # used before :o
23:43:39 <johnw> > I# 7
23:43:39 <Axman6> Int# is a machine int (like int in C)
23:43:40 <lambdabot>   Not in scope: data constructor `I#'
23:43:57 <adnauseam> oh i see, like a pointer
23:44:40 <Axman6> right. but it can point to either an actual int value, or a _thunk_, a computation that when evaluated, produces an Int# value
23:45:12 <adnauseam> i see :o
23:45:39 <Axman6> this is how laziness works. it means there can be quite a lot of indirection in haskell types, but we've also got ways to deal wight hat
23:45:42 <Axman6> that*
23:45:45 <Axman6> hats are fine
23:46:00 <adnauseam> indeed they are good sir
23:47:06 <adnauseam> hmm, now classes, are they part of this hirarchy? or are they more like attributes given then to type constructors?
23:47:23 <adnauseam> through instance x y where
23:48:45 * Axman6 lets someone else answer that because he doesn't have a good answer. points at shachaf and quicksilver 
23:48:49 <johnw> no, and no
23:48:57 <johnw> I will point at shachaf
23:49:24 <adnauseam> i sort of understand that a class relates to polymorphism
23:49:26 <shachaf> Answer what?
23:49:45 <adnauseam> and an instance is one morphism of such class
23:50:07 <adnauseam> shachaf: i'm just confused about the relationship between classes and instances
23:50:22 <adnauseam> about the hirarchy of it all
23:51:00 <shachaf> I'm not sure what you mean by "morphism" and "polymorphism"...
23:51:02 <Axman6> it's kind of like a type level predicate. so you have the show function, which has type Show a => a -> String, so any types which are instances of the Show class can have show applied to them
23:51:05 <certainty> hmm why doesn't Just $ read "6"::Int work, wheras Just $ (read "6"::Int) work?
23:51:19 <shachaf> certainty: Because :: is syntax but $ is just an operator.
23:51:25 <Axman6> :: has the lowest precedence
23:51:27 <certainty> shachaf: aha!
23:51:36 <Axman6> or what shachaf said
23:51:55 <adnauseam> mhm
23:52:31 <adnauseam> ah
23:52:35 <adnauseam> i think i understnad now
23:52:49 <johnw> adnauseam: http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
23:52:56 <certainty> shachaf: how do I tell what is syntax and what is not?
23:53:03 <johnw> :t (::)
23:53:04 <lambdabot> parse error on input `::'
23:53:10 <johnw> that's one way
23:53:12 <Axman6> so they allow polymorphic functions, but only if they implement a certain class.
23:53:13 <certainty> ok
23:53:13 <adnauseam> johnw: aye i should read that
23:53:17 <shachaf> certainty: By knowing.
23:53:26 <shachaf> certainty: Read introductions to Haskell until you know.
23:53:41 <certainty> ok, will do.
23:53:45 <shachaf> There isn't a crazy amount of syntax. You learn it all pretty quickly.
23:53:46 <Axman6> @where lyah
23:53:46 <lambdabot> http://www.learnyouahaskell.com/
23:54:00 <certainty> Axman6: thanks. I'm reading it :)
23:54:05 <shachaf> certainty: (Alternatively, the Report specifies the entire syntax.)
23:54:25 <johnw> shachaf: do you recommend reading the 98 report before 2010, or just 2010?
23:54:50 <certainty> shachaf: i didn't yet read it, because i thought i might not understand much anyway.
23:55:27 <shachaf> johnw: Either is fine.
23:55:28 <certainty> i will do at some point though, as reading r5rs helped me as well for scheme
23:55:33 <shachaf> You can just read 2010.
23:56:24 <johnw> ok, thanks
23:56:32 <nus> shachaf, '::' is a reserved operator
23:56:48 <nus> http://www.haskell.org/onlinereport/lexemes.html
23:57:03 <nus> http://www.haskell.org/haskellwiki/Keywords
23:57:06 <shachaf> Ah, what nus said. I was misusing the word "operator". :-)
23:57:33 <certainty> is there a way to exten haskell's syntax?
23:57:37 <certainty> extend, even
23:57:58 <Axman6> there's template haskell
23:58:06 <certainty> i figured that you can do much of the stuff you normally need things like macros, whith functions due to haskell's lazyness
23:58:21 <Axman6> which allows you to produce haskell code at compile time
23:58:36 <certainty> Axman6: thanks. I'll read up on that
23:58:46 <Axman6> it's pretty confusing imo
23:59:34 <shachaf> certainty: Don't use Template Haskell.
