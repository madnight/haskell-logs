00:16:12 <Okasu> Cale: and why State/tell contains some of previous tells, like ("#haskell",(Nothing,[Note {noteSender = "Baughn", noteContents = "Have any of you seen parse errors when using haskell-indentation.el? (Kuribas' mode)", noteTime = (1257180374,821670000000), noteType = Ask}]))("#haskell",(Nothing,[Note {noteSender = "Baughn", noteContents = "Have any of you seen parse errors when using haskell-indentation.el? (Kuribas' mode)", noteTime = (1257180374,821670000
00:16:58 <shachaf> Okasu: lambdabot's state happened to be committed.
00:17:02 <shachaf> Don't use @tell for anything secret.
00:17:17 <Okasu> heh :)
00:18:44 <hpaste> nand` pasted “Tupper's function” at http://hpaste.org/73211
00:18:47 <nand`> it's... beautiful
00:20:11 <zzing_> I love errors that don't tell me anything
00:21:40 <sopvop> nand` what is this?
00:21:50 <nand`> https://en.wikipedia.org/wiki/Tupper%27s_self-referential_formula as mentioned earlier
00:22:38 <sopvop> Whoa, that's pretty cool
00:22:45 <zzing_> forgetting the value of k of course
00:23:47 <nand`> yeah, it's not a true quine since it produces a lot of other junk other than itself
00:25:32 <nand`> http://www.peda.com/selfplot/selfplot3big.png
00:25:33 <nand`> there we go
00:33:40 <zzing_> What function should I use inplace of read because read can cause a parse exception
00:34:25 <Nereid> zzing_: a proper parser
00:34:34 <shachaf> zzing_: reads
00:34:39 <Nereid> or that
00:34:45 <Nereid> or catch the exception
00:34:58 <shachaf> Nereid: No, use reads.
00:35:11 <Nereid> I never use Read.
00:35:15 <Nereid> so I wouldnt' know.
00:35:15 <zzing_> Nereid, I am just trying to patch a bug, and let the maintainer (stepcut likely) decide
00:35:17 <shachaf> Unless by "catch the exception" you mean "pattern-match on the output of reads". Which is catching an exception in a sense.
00:36:19 <danr> :t listToMaybe . reads
00:36:21 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
00:36:23 <zzing_> shachaf, how do you use reads? It doesn't look same to me: reads :: Read a => ReadS a
00:36:38 <Nereid> @info ReadS
00:36:39 <lambdabot> ReadS
00:36:43 <Nereid> blurp
00:36:44 <shachaf> zzing_: You have to pattern-match on the result.
00:36:56 <shachaf> ReadS a = a -> [(a,String)] or something like that.
00:37:16 <zzing_> hmms, lots of trouble
00:37:37 <shachaf> There ought to be a safeRead function.
00:37:38 <MostAwesomeDude> Hey, I really want to like Gloss, but is it actually a good thing? Or is it too good to be true?
00:37:45 <zzing_> I am just going to put 80 in there
00:37:50 <shachaf> There isn't one in the standard library right now, but you can add one to your project.
00:38:20 <Nereid> @src read
00:38:21 <lambdabot> read s = either error id (readEither s)
00:38:37 <danr> @hoogle readEither
00:38:38 <lambdabot> No results found
00:38:40 <danr> o_O
00:38:42 <nand`> :t either (const Nothing) id . readEither
00:38:44 <lambdabot> Not in scope: `readEither'
00:38:44 <Nereid> > either (const Nothing) Just . readEither
00:38:46 <lambdabot>   Not in scope: `readEither'
00:38:49 <Nereid> lol
00:38:57 <MostAwesomeDude> Also, if I use Gloss, what would be the best way to load PNGs to bitmaps in a way that Gloss likes?
00:39:18 <Nereid> :t either (const Nothing) Just . Text.Read.readEither
00:39:20 <lambdabot> Not in scope: `Text.Read.readEither'
00:39:51 <nand`> huh, looks like readEither isn't exported from Text.Read; even though it's defined
00:40:09 <nand`> is there a compelling reason for that?
00:40:57 <Nereid> :t \s -> case [x | (x,"") <- reads s] of {[x] -> Just x; _ -> Nothing}
00:40:59 <lambdabot> forall a. (Read a) => String -> Maybe a
00:41:05 <mikeplus64> MostAwesomeDude: there is Graphics.Gloss.Data.Picture.loadBMP
00:41:14 <mikeplus64> MostAwesomeDude: http://hackage.haskell.org/packages/archive/gloss/1.7.4.1/doc/html/Graphics-Gloss-Data-Picture.html scroll to the end of this
00:41:19 <zzing_> You guys ever love something but hate its rough edges?
00:41:28 <danr> :t guard (null . snd) . listToMaybe . reads
00:41:29 <lambdabot>     Couldn't match expected type `Bool'
00:41:30 <lambdabot>            against inferred type `(a1, [a]) -> Bool'
00:41:30 <lambdabot>     In the first argument of `guard', namely `(null . snd)'
00:41:39 <danr> oops
00:41:41 <Nereid> :t \s -> case reads s of {[(x,"")] -> Just x; _ -> Nothing}
00:41:43 <lambdabot> forall a. (Read a) => String -> Maybe a
00:41:57 <danr> :t fmap fst . (guard (null . snd) >>) . listToMaybe . reads
00:41:59 <lambdabot>     Couldn't match expected type `Bool'
00:41:59 <lambdabot>            against inferred type `(a1, [a]) -> Bool'
00:41:59 <lambdabot>     In the first argument of `guard', namely `(null . snd)'
00:42:35 <mikeplus64> MostAwesomeDude: also there is http://hackage.haskell.org/packages/archive/repa-devil/0.3.2/doc/html/Data-Array-Repa-IO-DevIL.html
00:42:52 <mikeplus64> (but i'm not sure how you'd load a Picture from that)
00:43:19 <MostAwesomeDude> Hmmmmm.
00:43:27 <MostAwesomeDude> Maybe I'll just stick with SDL for now.
00:44:20 <zzing_> Does anyone know anything like clckwrks that is a little further along in development?
00:44:34 <mikeplus64> zzing_: hakyll
00:45:07 <zzing_> too bad that is just a static site generator
00:46:57 <zzing_> Is there any reason why runhaskell would give me something like Could not find module `Clckwrks.ProfileData.Acid'   when ghci imports it fine?
00:55:18 <kanedank> hey in this https://gist.github.com/3357460 where does the variable 'result' come from?
00:56:09 <shachaf> kanedank: It's an argument to tryParse.
00:56:42 <shachaf> > let tryParse [(foo,bar):xs) = (foo,bar,xs) in tryParse [('a',1),('b',2),('c',3)]
00:56:43 <lambdabot>   <no location info>: parse error on input `)'
00:56:48 <shachaf> > let tryParse ((foo,bar):xs) = (foo,bar,xs) in tryParse [('a',1),('b',2),('c',3)]
00:56:49 <lambdabot>   ('a',1,[('b',2),('c',3)])
01:06:01 <kanedank> shachaf: haha, you're absolutely right. I guess that's what I get for trying to learn haskell at this ungodly hour.
01:07:11 <xrq> this is a great hour to learn haskell
01:08:30 <Jurily> but not haskell+gtk
01:09:08 <c_wraith> there's no good hour for that
01:09:12 <tdammers> every hour is a great hour for learning haskell
01:09:28 <tdammers> but the smaller the hour's UNIX timestamp, the better.
01:10:28 <c_wraith> I learned that POSIX timestamps are non-unique recently.  that surprised me.
01:10:48 <c_wraith> I figure most people learned that at about the same time, though
01:11:48 <timthelion> non-unique?
01:12:29 <shachaf> As in leap seconds?
01:13:29 <timthelion> shachaf: a leap seconds would be an ommition, not a duplication, eh?
01:14:11 <nand`> POSIX timestamps don't regard leap-anything, do they? it's just a straight up counting the number of seconds
01:14:46 <c_wraith> POSIX timestamps are *not* defined as the number of seconds since the epoch
01:15:08 <c_wraith> they are the number of days since the epoch * whatever constant + the number of seconds since midnight
01:15:21 <c_wraith> leap seconds cause duplicate POSIX timestamps
01:17:37 <timthelion> oh, ok.
01:17:41 * timthelion doesn't care.
01:17:45 <nand`> I see
01:17:48 <nand`> that seems silly
01:18:00 <Jurily> something tells me it would be easier to write my gtk code in C and a binding to it, than trying to work aroung gtk2hs.
01:18:05 <nand`> the wikipedia article describes a TAI-based variant that is in fact a linear counting of seconds, disregarding days
01:18:31 <c_wraith> TAI counts seconds, yes
01:18:34 <c_wraith> POSIX counts days
01:18:48 <timthelion> Jurily: gtk2hs is not that hard, some bugs, but really not hard at all.
01:19:09 <Jurily> timthelion: how do I create a custom signal, with a single Int argument?
01:19:20 <timthelion> Jurily: custom signal?
01:19:53 <timthelion> Jurily: are you trying to make custom widgets?
01:20:06 <KJChernov> Hello. Do I understand right, that the threads which are created by the forkIO is not a real threads created by, for example, C pthread_create?
01:20:14 <merijn> KJChernov: Yes
01:20:16 <timthelion> KJChernov: yes
01:20:27 <KJChernov> so there's no limit on the number of such threads?
01:20:36 <merijn> KJChernov: They can be multiplexed over multiple actual pthreads when you compile with threaded
01:21:10 <KJChernov> merijn, can you explain, please?:)
01:21:32 <merijn> KJChernov: Well, there's *a* limit, presumably. Although you have to really create unreasonably many to hit it. For example, for IO task you can easily create upwards of 100K forkIO threads on a normal desktop
01:21:34 <timthelion> KJChernov: No, there is no limit.  But you have to be careful that if you use like gtk2hs(which uses normal threads) to use -threaded when you compile, and forkOS for any actual threads.  Otherwise you'll get weird blocking conditions
01:21:53 <Jurily> timthelion: just abstractions over the existing widgets.
01:22:12 <timthelion> Jurily: what are you actually trying to accomplish?
01:22:33 <merijn> KJChernov: forkIO threads can either be multiplexed on a single OS thread, but if you compile with -threaded you can give the runtime an extra argument that says "create N pthreads to run forkIO tasks on in parallel"
01:23:09 <KJChernov> well, I'm willing to write a simple tcp repeater, and instead of writing a connection pool I want to use forkIO for each connection handler
01:23:10 <merijn> KJChernov: Actually I think it uses a single compute OS thread and some extra threads to prevent blocking calls from blocking *all* threads, but you get the idea
01:23:18 <timthelion> merijn: it won't use multiple OS threads at all, if you don't?  That's idiotic!
01:23:41 <shachaf> Idiotic! If you don't enable threading, it won't use threads!
01:23:45 <merijn> KJChernov: That should be perfectly fine, as I said for IO things like networks you can probably easily create up to 100k forkIO threads if not more
01:24:06 <Jurily> timthelion: intercept double click in treeview -> get the corresponding item from its model -> show it to the outside as a signal containing the item
01:24:06 <KJChernov> merijn, timthelion, thank you :)
01:24:15 <timthelion> shachaf: You have to enable threading on runtime?  It really ought to be default behavior.
01:24:45 <c_wraith> timthelion: you have to enable using multiple OS threads in the runtime.
01:25:04 <c_wraith> timthelion: you do not have to enable concurrency in the runtime.  It simulates it just fine on a single OS thread if you don't
01:25:05 <Jurily> 7.6 will be able to set the runtime threads from haskell
01:25:17 <merijn> timthelion: And how many threads should it create by default, according to you?
01:25:20 <timthelion> Jurily: why would you want to use GTK's internal signals and not TVars or something?
01:26:02 <timthelion> merijn: well, since I have core2duo, it should use all 4 channels(or whatever you call them) pipelines...
01:26:14 <Jurily> timthelion: because I'm already running a gtk event loop?
01:26:25 <merijn> timthelion: And how does the runtime figure out how many hardware threads you have?
01:26:49 <timthelion> c_wraith: the more I learn about haskell's threading, the more I feel dissapointed :(  The way it was sold to me, it was sold to me as a high level language that would "automatically" scale to the architecture...
01:27:06 <ibid> badly sold, then
01:27:07 <c_wraith> timthelion: then someone lied to you. There's no such thing as automatic scaling.
01:27:22 <shachaf> timthelion: You can enable it at compile-time.
01:27:35 <merijn> timthelion: What? You think changing "-n 2" to "-n 4" is hard work? (ignore the fact that I forgot the actual flag)
01:27:43 <c_wraith> merijn: -N :)
01:27:44 <merijn> Seems pretty automatic to me
01:28:05 <merijn> Also, take it from me as someone who has tried to write autodetection for how many hardware threads are available: It's freaking hard
01:28:07 <timthelion> Jurily: Oh, I design my GTK2HS apps differently.  I wouldn't sugest using GTK's event loop.  It leads to bad design choices.  Keep your own thread, have events communicate with it through MVars or TVars or something.
01:28:15 <merijn> Doing it portably even more so
01:28:16 <shachaf> -N will determine the number of threads to use automatically.
01:29:18 <timthelion> merijn: :(  This is pathetic.  The operating system knows how many hardware threads there are.  If the software cannot find that out, that's nothing short of a design flaw(be it in POSIX or haskell)
01:29:44 <shachaf> timthelion: Please read one line above.
01:29:52 <timthelion> merijn: and you want me to tell random users that they need to run my application with some argument?   Are you crazy?  Not everything is run on the serverside...
01:29:53 * hackagebot lens 2.3 - Lenses, Folds and Traversals (EdwardKmett)
01:29:57 <shachaf> I would tell you to contribute a patch, except that this is already implemented.
01:30:22 <timthelion> shachaf: Is there a way I can get it to run with -N automatically?
01:30:29 * shachaf wonders if timthelion is reading what people are saying or just complaining about it.
01:30:32 <shachaf> timthelion: Yes.
01:30:38 <c_wraith> timthelion: so you quit ignoring the people who are telling you that you can set that argument at *compile* time
01:30:53 <timthelion> c_wraith: and it's different than -threaded?
01:30:55 <c_wraith> yes
01:31:01 <edwardk> timthelion: honestly you often want to run with fewer cores than your architecture supports overall due to NUMA concerns, or wanting to leave a core to the OS.
01:31:01 <Jurily>   ghc-options:         -threaded -with-rtsopts=-N
01:31:03 <c_wraith> you can set rts options at compile time
01:31:43 <Jurily> also, OS threads have a sizable memory overhead
01:32:13 <Okasu> hm, do any of you have experience in connecting lambdabot to mibbit?
01:32:16 <timthelion> edwardk: I should think, if the OS cannot give itself space, then it's not a very well written kernel.  Even at 100% + 100% linux can still be pretty snappy.
01:32:30 <edwardk> timthelion: then there are no well written kernels =P
01:32:32 <c_wraith> And you have to be doing some pretty heavy-duty stuff, with a well-designed program, to actually benefit from multiple cores
01:32:39 <Okasu> it connects fine but for some reason bot just won't join a channel :/
01:32:41 <c_wraith> Okasu: I couldn't ever get it to work right
01:32:45 <shachaf> c_wraith: Hardly.
01:32:46 <c_wraith> Okasu: that's exactly the problem I had
01:33:07 <c_wraith> Okasu: though I could send it @join directives to have it join the channel later
01:33:09 <shachaf> c_wraith: There are lots of simple programs that benefit from multiple cores easily.
01:33:10 <edwardk> timthelion: speaking as someone who has done a _lot_ of heavy multithreaded applications across a lot of platforms
01:33:18 <shachaf> Okasu: join server:#channel
01:33:26 <shachaf> c_wraith: join server:#channel
01:33:34 <c_wraith> shachaf: that doesn't work on mibbit
01:33:39 <shachaf> ?
01:33:44 <shachaf> It's lambdabot syntax.
01:33:44 <c_wraith> don't know why.
01:33:47 <c_wraith> yes.
01:33:51 <c_wraith> doesn't work
01:33:55 <shachaf> If you send it @join it works?
01:33:58 <c_wraith> yes
01:34:04 <shachaf> Weird.
01:34:17 <nohonor_alt> when cabal returns  an error where can i find more info ?
01:34:19 <edwardk> the moment you go to run something like MPI or a non-workstealing based scheduler across say all 8 cores, and watch your performance grind to under half of what it was you'll see what i mean
01:34:22 <Okasu> c_wraith: thanks for advise
01:34:23 <nohonor_alt> cabal: failed doesn't tell me much
01:34:55 <shachaf> nohonor_alt: cabal -v?
01:34:58 <c_wraith> nohonor_alt: try scrolling up in the output, looking for an error message
01:35:05 <merijn> edwardk: But debugging weird multicore behaviour is fun!
01:35:12 <edwardk> merijn: =)
01:35:15 <c_wraith> nohonor_alt: sometimes it's not the last output from cabal
01:35:42 <nohonor_alt> there are only two lines of output
01:35:46 <nohonor_alt> with or without -v
01:35:57 <merijn> Speaking of which, I have a really odd behaviour in my multithread (non-haskell) code where going from 1 to 2 threads actually decreases performance dramatically but 3 or more again scales quite nicely
01:36:02 <nohonor_alt> D:\Program Files (x86)\Haskell Platform\2011.2.0.1\bin>cabal update -v
01:36:02 <nohonor_alt> Downloading the latest package list from hackage.haskell.org
01:36:03 <nohonor_alt> cabal: failed
01:36:11 <merijn> Yay, debugging \o/
01:36:28 <shachaf> nohonor_alt: What IP does hackage.haskell.org resolve to?
01:36:31 <edwardk> adding that second thread is when you incur all the synchronization overhead, no?
01:36:35 <timthelion> edwardk: preformance of what?  MPI, or the rest of the system?
01:36:38 <Jurily> nohonor_alt: do you have curl or wget?
01:36:58 <edwardk> timthelion: the MPI or non-workstealing scheduled app
01:37:03 <nohonor_alt> schachaf, 66.193.37.204
01:37:15 <edwardk> because you can now have 7 of the cores waiting on the one laggard that is competing with the OS
01:37:19 <nohonor_alt> Jurily, i have wget in my path
01:37:26 <edwardk> any barrier synchronization system will get you
01:37:29 <timthelion> edwardk: so you think that true multithreading is still less efficient than just running in one thread?
01:37:30 <nohonor_alt> not in a default location and not in the haskell directory
01:37:46 <merijn> edwardk: That is/was my first guess, But there's not really all that much synchronisation overhead since there's not really any locking except some lock-free FiFO's, which shouldn't really be a barrier
01:37:46 <edwardk> when did i ever say that?
01:38:05 <merijn> timthelion: For many workloads it is
01:38:21 <c_wraith> "efficient" is an interesting question
01:38:26 <edwardk> timthelion: from 1 to 2 threads, it often is, from 7 to 8 is another matter
01:38:28 <merijn> Especially in haskell, due to GC synchronisation
01:38:34 <c_wraith> algorithms are often more efficient in one thread
01:38:51 <Okasu> c_wraith: oh, when i've added second irc server(freenode/mibbit), bot connects just fine :/
01:38:53 <c_wraith> But efficient isn't the same as completing as fast as possible
01:38:58 <Okasu> without @join
01:39:16 <timthelion> merijn: why would GC synchronization be a problem?  I'm sharing an L3(or whatever they call it on the core2) it's the same freekin memory!
01:39:28 <c_wraith> timthelion: stop-the-world garbage collection
01:39:59 <merijn> timthelion: For one of my haskell prototypes going from 1 worker to 2 workers increases runtime by 75%
01:40:10 <timthelion> c_wraith: of course that's going to stop everything, but it stopps everything on one thread too!
01:40:24 <edwardk> timethelion: keep in mind, on a lot of not very old chipsets to cost of a memory barrier to synchronize _either_ reads or writes between cores can be upwards of 2000 cycles
01:40:33 <merijn> timthelion: In one thread it doesn't need to synchronise
01:41:01 <edwardk> timthelion: thats just issuing a single 'mfence' 'sfence' or 'lfence' opcode
01:41:29 <edwardk> timthelion: when you run in a single threaded environment you don't have to pay that tax
01:41:32 <timthelion> merijn: what kind of synchronization are we talking about?  Does it run two seperate GC's with two seperate buffers(despite the fact that those two buffers are on the same physical memory?)
01:41:52 <edwardk> and thats a huge tax. an indirect jump is comparatively something like 50 of those cycles
01:42:11 <nohonor_alt> i guess no one know how to help me with my cabal issue
01:42:24 <nohonor_alt> i wish i could ditch Windows for good
01:42:26 <shachaf> edwardk: 50 cycles?
01:42:38 <nohonor_alt> windows (r) - things just DON'T work
01:42:49 <edwardk> shachaf: old benchmark numbers i used to live by, that are now suredly out of date
01:42:50 <merijn> timthelion: Both threads need to stop running and caches need to be synchronised/writes flushed
01:42:55 <edwardk> as mesofacts usually go
01:42:58 <timthelion> edwardk: it's clear to me, that the whole increase in clock speed thing was meaningless, now that you start quoting those numbers.  I recal that on the older cpu's jmp was like 12 or something...
01:43:00 <shachaf> edwardk: Is that a best case or worst case or what?
01:43:12 <shachaf> Well, presumably not a worst case.
01:43:17 <edwardk> shachaf: average case caused by branch misprediction
01:43:20 <Jurily> I've been meaning to write a Haskell on Windows tutorial, but I'm too lazy to reinstall everything :)
01:43:39 <edwardk> timthelion: jumps to know addresses are basically free
01:43:40 <shachaf> Ah, a mispredicted branch. I suppose.
01:43:44 <edwardk> its mispredictions that go to hell
01:43:52 <edwardk> and those barriers
01:43:54 <shachaf> Right. That's always the problem. :-)
01:43:58 * shachaf should get a better intuition for the cost of these things.
01:44:01 <edwardk> modern chipsets make the barriers a lot cheaper
01:44:07 <merijn> timthelion: With separate caches for each core there's no such thing as threads being "on the same physical memory"
01:44:32 <merijn> At least not in any useful sense
01:44:33 <Jurily> merijn: hyperthreading is two logical cores on the same cache
01:44:46 <edwardk> x86 gives you a pretty good illusion of decent happens before semantics because of write order consistency guarantees compared to other cpu architectures, but the abstraction leaks
01:44:53 <merijn> Jurily: Of course, but your GC can't assume you're running on the same core
01:45:08 <shachaf> x86? Abstraction leaks?!
01:45:21 <timthelion> merijn: The L2 is only like 4 megabytes, and then core2 duos(the intel dual core CPU'S) have a shared cache bellow that(I think?)
01:45:38 <merijn> timthelion: I fail to see how that's relevant? Synchronising caches is expensive
01:46:03 <edwardk> timthelion: but you only have per cpu write order guarantees for it, and beyond that have to fence. you saw the fence numbers i tossed out
01:46:07 <merijn> So expensive that many hardware manufacturers are examining NUMA
01:46:31 <timthelion> merijn: why should it have to?  Without shared memory(ok, a few MVars to communicate) we're not talking about much that needs to be synchronised.  That's the great thing about mutability.
01:46:38 <edwardk> the moment i have to touch data that another cpu may or may not have dirtied things get hella slow
01:47:03 <merijn> timthelion: You can't mutate things, the runtime can. Think of updating whether a thunk has been evaluated, etc.
01:47:08 <edwardk> timthelion: the mvar. you wrote to it. to tell me about it, you did what again? oh you fenced.
01:47:38 <timthelion> edwardk: but is this only for MVar opperations, or for side effect free ones as well?
01:48:08 <Jurily> timthelion: no, this is an inherent property of the hardware
01:48:50 <timthelion> Jurily: that's a statement, that is very much like your question about signals and GTK, you need to think out of the box here a bit.
01:48:51 <edwardk> for the mvar operation itself necessarily, ghc pulls some seriously dirty tricks for non-io thunks to avoid fencing everywhere that relies on x86 write order guarantees for basic soundness (i'm not at all sure of the soundness of the approach used for black/greyholing on other architectures honestly)
01:49:15 <edwardk> timthelion: no, the box is pretty well fixed ;)
01:49:33 <Jurily> brb, inventing my own architecture
01:49:56 <timthelion> edwardk: how much overhead is there, when I run two completely unrelated applications, on two different cores.  What do those applications have to synchronise between eachother?
01:50:00 <edwardk> Jurily: sweet, let me know how you solve the consistency problem ;)
01:50:10 <merijn> Jurily: Ha, I have a research group here who'd love to sell you a low cost concurrency hardware micorthreading platform!
01:50:11 <edwardk> completely unrelated applications? almost nothing
01:50:27 <merijn> Minor catch, you don't get memory consistency :>
01:50:33 <edwardk> you get choke points when you make syscalls, etc.
01:50:39 <edwardk> but you aren't talking to each other otherwise
01:50:43 <merijn> Then again, Intel and AMD will probably drop that soonish anyway
01:51:01 <companion_cube> memory consistency? :D
01:51:02 <timthelion> edwardk: So if I have two threads, in a haskell application.  And the ONLY thing they share is one MVar with an Int inside it.  How much do they need to synchronise beteween eachother?
01:51:13 <merijn> edwardk: Solving the consistency is easy, just don't have consistent memory! \o/
01:51:43 <Jurily> timthelion: you're assuming the RTS doesn't do anything.
01:51:54 <timthelion> Jurily: why not have two RTS's then?
01:52:02 <Jurily> why not have 15?
01:52:07 <merijn> timthelion: That is called running two processes
01:52:11 <edwardk> timthelion: a fair bit, because they share access to the same global pool of memory. nowadays threads can do most of their gc locally thanks to a lot of excellent work by JaffaCake1, but they still need to talk to each other a fair bit during gc.
01:52:27 <merijn> timthelion: And there's no problem with having two RTSes, just run the same program twice instead of using forkIO
01:52:48 <edwardk> timthelion: the closest you get to the idea you seem to want is what erlang does where each process has its own completely separate memory and does its own gc
01:53:13 <timthelion> edwardk: that would seem reasonable, if haskell does it in such a preformance poor fasion
01:53:20 <Jurily> which would be nice in haskell too btw
01:53:38 <edwardk> the problem is that that forces you into call-by-value or call-by-name semantics in certain circumstances which is crap for haskell. if two threads can access the same thunk and one updates it you want the other to be able to see the updated answer
01:53:46 <timthelion> merijn: running the same program twice, and communicating via pipes or something, is something I'd consider...  But it's a pitty to burn type saftey that way.
01:54:03 <edwardk> haskell does it in an amazingly good performance fashion compared to everybody else, its the hardware that is craptastic ;)
01:55:14 <edwardk> anyways the original point was going from 1 core to 2 is a net loss for many workloads, and no we're not pulling your chain. ;)
01:55:29 <timthelion> edwardk: that's a real pitty :(
01:55:32 <edwardk> and sometimes you want to run fewer cores for a process than the system allows =P
01:55:48 <edwardk> timthelion: every multithreaded architecture for every language has that same issue
01:56:13 <timthelion> edwardk: I was under the impression that functional languages with imutable objects where the solution to that problem :)
01:56:22 <shachaf> timthelion: I think generating efficient multicore code is harder than you give it credit for.
01:56:22 <edwardk> they help a great great deal
01:57:01 <edwardk> i write functional code and i make it parallel as an afterthought. i write imperative code and i have to preplan the entire thing and even then i may get it wrong
01:57:38 <edwardk> i can sprinkle my speculation combinators, a few sparks and a some other noise through my code and wham i can get pretty good utilization out of all of my cores
01:58:08 <timthelion> edwardk: for example.  I am writting a program that maps across a large image and looks for "features"(pure map, no mutable objects, nothing shared, all points could be theoretically inspected in paralel)  Haskell should be good at putting this across two corse.  is it faster at this point, to cut the image in half and pipe two halves of the image to two seperate processes?
01:58:24 <edwardk> no
01:58:41 <edwardk> its probably faster for that kind of embarassingly parallel workload
01:58:51 <edwardk> the moment you use the word 'pipe' you lose ;)
01:59:08 <timthelion> edwardk: I should HOPE it's faster :)
02:00:30 <edwardk> timthelion: write the code, throw the threaded runtime at it, throw the normal runtime at it, get a feel for the relative performance loss just running threaded on one core, then check upwards from there. graph it and don't fear it ;)
02:00:43 <timthelion> OK
02:01:00 <edwardk> there are a ton of ways to make code faster in haskell
02:02:54 <timthelion> I actually lied.  I map across rows of pixels(have to look for derivatives) but it still should be easy to paralel.
02:03:18 <edwardk> still easy =)
02:03:40 * timthelion feels a bit better now :)
02:04:13 <edwardk> we pretty much dominate any multithreaded benchmark you can ask for, so take everything said with a grain of salt
02:06:00 <frerich> Hm, given an unordered list of 2D vertices like [(0,0),(1,0),(0,1),(2,1),(3,3),(3,1),(3,2)] - does anybody have some suggestions how to turns that into the smallest number of 'paths' (where a path is a sorted list of vertices which are adjacent)? For instance, for the given output, the result may be [[(1,0),(0,0),(0,1)],[(2,1)],[(3,3),(3,2),(3,1)]] (three paths)?
02:06:18 <shachaf> edwardk: Really?
02:06:43 <shachaf> I hope you don't mean thread-ring.
02:07:11 <edwardk> shachaf: well we used to =)
02:07:22 <shachaf> Which benchmarks?
02:07:30 <Okasu> what is it about "Main: caught (and ignoring) too few bytes. Failed reading at byte position 8"
02:07:38 <Okasu> lambdabot spams me with it
02:07:50 <edwardk> i was going for thread-ring to be honest ;)
02:08:00 <shachaf> edwardk: thread-ring is way slower with -threaded +RTS -N
02:08:09 <edwardk> heh fair nuff
02:08:10 <shachaf> And it basically cheats because it's not preëmptive.
02:08:14 <edwardk> of course
02:08:28 <edwardk> but its a nice way to show off ;)
02:09:52 * timthelion thinks about that SPJ line "your software still won't be bug free... but the bugs you get will be more interesting."
02:10:29 <mjga> edwark: unfortunately having a common heap GC means that it scales up to 12 processors at most, usually best for 4-8. I recently tried embarrasingly parallel code that could gain a lot of performance from shared mem, but it got killed by GC costs of up to 90% when increasing number of processors.
02:10:44 <mjga> edwardk: [sry for repost] unfortunately having a common heap GC means that it scales up to 12 processors at most, usually best for 4-8. I recently tried embarrasingly parallel code that could gain a lot of performance from shared mem, but it got killed by GC costs of up to 90% when increasing number of processors.
02:11:08 <edwardk> mjga: yep
02:11:39 <edwardk> mjga: thats why i haven't stopped using erlang yet ;)
02:11:46 <shachaf> That sounds unpleasant.
02:11:47 <merijn> Does haskell really need a common heap?
02:11:52 <shachaf> What can be done about that?
02:11:56 <merijn> Or is it just for hysterical raisins
02:12:04 <shachaf> merijn: Sounds pretty tricky to implement the sorts of things GHC gives you without one.
02:12:19 <merijn> shachaf: That's why I'm in the business of science!
02:12:21 <edwardk> merijn: consider two threads that update thunks in a common pool. consider every use of sparks
02:12:41 <timthelion> edwardk: so basically, this all comes down to laziness ;)
02:12:55 <edwardk> yes =P
02:12:56 <timthelion> laziness comes and bights us in the tush for once...
02:12:58 <mjga> edwardk: anybody pushing in this direction? there seems to be nice incremental parallel multiple heaps for Java implemented by IBM, but nothing else I know about. Erlang just separates heaps, and copies full messages AFAIR?
02:13:02 <edwardk> speaking of laziness.
02:13:24 <hiptobecubic> mjga, i think erlang copies full messages, yes
02:13:28 <mjga> merijn: I don't think it does need, since most allocations never cross thread barrier.
02:13:44 <hiptobecubic> edwardk, do you not get... annoyed, with erlangs performance though?
02:13:51 <cods> Hi. I'm trying to compute a bounding box from a list of 2D coordinate. I tried something naive: http://hpaste.org/73214 but it blow the stack (from ~1 million points). How can I improve it?
02:13:59 <edwardk> mjga: one of the gsoc projects proposed this year was to do numa allocation, but it didn't get accepted. really what you probably want is to just use somethinglike cloud haskell for separate heaps
02:14:01 <hiptobecubic> HiPE was pretty pitiful it thought
02:14:10 <edwardk> hiptobecubic: throwing 50 machines at it? =)
02:14:19 <shachaf> cods: Add a strictness annotation.
02:14:21 <shachaf> Or maybe use foldl'
02:14:24 <merijn> hiptobecubic: HiPE?
02:14:32 <mjga> merijn: in other words: there are things that may need to live on common heap (or at least pairwise shared between few threads), but they are minority.
02:14:41 <merijn> mjga: Yeah
02:14:50 <hiptobecubic> edwardk, I guess if you have them. Seems like a waste :)
02:14:58 <merijn> mjga: Actually this makes my own research seem much more interesting than it used to before :p
02:15:09 <edwardk> hiptobecubic: thats what amazon is for. spike scaling
02:15:17 <merijn> mjga: Unfortunately it also blows holes in my expectation of implementing it in haskell :p
02:15:27 <mjga> merijn: what do you research? region based GC for haskell?
02:15:58 <edwardk> merijn: use cloud haskell or something like it and talk between processes as needed. work locally with shared memory and locks as needed and just go from there
02:16:02 <timthelion> edwardk: So the problem is threadA has a pointer to thunkC and threadB also has a pointer to thunkC.  ThunkC gets evaluated, and then threadB has to tell threadA to update it's pointer?
02:16:08 <mjga> merijn: one can use distributed haskell (cabal install remote), and shuttle things between different Haskell processes. Then you may even scale on a cluster ;-)
02:16:10 <merijn> mjga: I don't even do research in haskell :p We're looking into combinators for concurrent programming
02:16:25 <merijn> And how to aggregate cost models
02:16:42 <edwardk> timthelion: all the while not being able to know if threada knows anything about threadc because you want to deny it shared memory ;)
02:16:54 <edwardk> and any sort of rendezvous ;)
02:17:01 <hpaste> “[author]” annotated “Naive bounding box” with “Naive bounding box (annotation)” at http://hpaste.org/73214#a73215
02:17:06 <shachaf> cods: Try that.
02:17:11 <merijn> edwardk: Yeah, I've looked at cloud haskell, but it'd need some rewriting for our purposes
02:17:15 <mjga> merijn: for research it is probably okay, only if you produce/consume a lot of data, then GC starts to bite ;-). [I am in computational science.]
02:17:22 <merijn> edwardk: It's not lazy enough :)
02:17:23 <edwardk> merijn: it doesn't meet mine either.
02:17:43 <merijn> mjga: Not scaling is kind of dead-end for research into scalability :p
02:18:01 <edwardk> i've been working on a little dsl for doing distributed computing over the wire that can send lambdas, turn into loop code for gpus, etc.
02:18:15 <merijn> edwardk: I think Cloud Haskell messages are copied completely like erlang, right?
02:18:28 <mjga> merijn: indeed. Especially that I have a free access to 48-processor cluster nodes, and have to split my programs into 8 or 12-processor bunches.
02:18:28 <edwardk> merijn: exactly like erlang, erlang is their inspiration
02:18:51 <merijn> Actually, that's not really a problem I guess. I could implement our lazy data fetching on top of that by passing references rather than data inside messages
02:18:52 <timthelion> edwardk: at the cost of a JMP and a couple of reads:  ThreadA could have pointer to ThunkManagerC ThreadB could have a pointer to ThunkManagerC and ThunkManagerC would simply be a pointer to the CurrentActualThunkC...
02:19:10 <cods> shachaf: thank, it works!
02:19:18 <mjga> merijn: since there seems to be currently an effort to improve and rewrite Distributed/Cloud Haskell, I believe you may add your wishes to their list or possibly join the effort.
02:19:31 <hiptobecubic> merijn, used to be a standalone erlang compiler from uppsala, but now it's included with erland/OTP as +native option. Basically it just tries harder and compiles to native code (which still needs BEAM anyway i think?) http://www.it.uu.se/research/group/hipe/index.shtml
02:19:46 <edwardk> timthelion: if i have to tell you someting there is a barrier involved. you don't see my writes necessarily otherwise
02:20:16 <edwardk> happensbefore semantics are mostly undefined until that happens (more defined on x86 than elsewhere)
02:20:57 <mjga> merijn: And I am sure everybody would be grateful for expansions of GHC runtime with Cloud Haskell-compatible distributed MVars, or distributed sparks ;-)
02:21:22 <edwardk> distributed mvars are a cruel joke of a concept =P
02:21:44 <timthelion> edwardk: how so?
02:21:59 <Jurily> we're edging into "reimplement the whole OS" territory
02:22:16 <merijn> Essentially what we have now (in C, ugh) is a set of combinators for defining CSP with a single typed input and typed output stream, some special merge combinators and flow inheritance of data (kinda like record polymorphism for stream types)
02:22:25 <merijn> Jurily: Yes
02:22:27 <edwardk> almost any distributed transaction framework is awful in performance, and tinged with failures that can occur at all sorts of odd places in the process
02:22:47 <mjga> edwardk: I disagree on goods of Cloud haskell: one would rather want separate per-thread/spark-separated GC regions for bulk stuff, and some shared memory for the things that are _really_ shared between some threads. Recall that most of Haskell programs allocate memory very fast, even if they barely use it later.
02:23:10 <timthelion> Jurily: so what did you decide with gtk2hs?  Did you take my sugestion? Or give up?
02:23:19 <Okasu> meh, Seen module cause this
02:23:21 <mjga> edwardk: using Cloud Haskell for heavy parallel Haskell code means a replication of much of common data structures that are usually immutable, and huge input data.
02:23:32 <edwardk> i've used paxos, variants of paxos, 2 phase and 3 phase commits, using ad hoc services or things like DTS, eventual consistency, distributed gc, etc. all of those suck for different reasons
02:23:33 <Jurily> timthelion: right now, I'm reading the chat :)
02:23:42 <merijn> So records "A * B * C" will match "A * B" streams/processes and the C will just be inherited to the output. Which turns out to present you with really fun distributed ref counting issues for garbage collecting the data in a distributed setting
02:24:07 <edwardk> that was to timthelion
02:24:13 <Jurily> and my UI will probably be one huge ugly module
02:24:33 <edwardk> mjga: in my toy my main focus has been on moving computation to the data
02:24:42 <colin4124> I want to learn Haskell,can you recommand some ways,such books to me?
02:25:06 <mjga> edwardk: I think what we needs is some kind of "regions" with different kinds of garbage collection policies in RTS (e.g. a) regions that are collected by a single thread, b) regions collected by a pair or pack of communicating threads c) regions shared by everybody d) immutable input region that never gets collected after it is created)
02:25:27 <edwardk> mjga: as thats what i used to do with column store data and it makes sense if i'm looking at letting the dsl generate code to run on things like gpus, etc. where i have some pretty bad data mobility issues ;)
02:25:30 <mjga> edwardk: what do you mean "moving computation to the data"
02:25:45 <timthelion> edwardk: I know it aint polite to link to myself but http://hackage.haskell.org/package/ThreadObjects I've built a library off of "moving computation to the data"
02:25:54 <edwardk> i mean something that i'm going to have to talk about tomorrow. its 5:30 in the morning, and i need to work tomorrow
02:25:57 <timthelion> (for entirely unrelated reasons)
02:26:09 <mjga> edwardk: column store? URL?
02:26:17 <merijn> edwardk: Since you're knowledgeable about distributed computing: On a 1 to 10 scale, how interesting is a new distributed reference counting algorithm whose space and operation complexity have a best case complexity similar to naive ref counting and a worst case complexity bounded by network size rather than program behaviour? :)
02:26:31 <edwardk> mjga: check pm
02:27:07 <edwardk> merijn: the moment distributed gc comes up i usually just stop listening ;)
02:27:30 <merijn> edwardk: I'd be interested in that too (moving computation to data)
02:27:51 <shachaf> edwardk: There's a URL?
02:27:59 <edwardk> i'll be on tomorrow. but for now i need to get sleep
02:28:12 <shachaf> Aw.
02:28:26 <merijn> edwardk: Depends on the number and size of things you're collecting :p
02:28:39 <timthelion> merijn: he left :/
02:28:58 <shachaf> I once tried to find something about his column store thing but didn't see anything.
02:29:18 <merijn> That's what I get for disabling joins/parts in here :p
02:32:12 <hpaste> b52 pasted “whileM_ or something” at http://hpaste.org/73218
02:32:20 <b52> hey fellas
02:32:42 <b52> i need a monadic function to create a while-loop-ish construct
02:32:53 <shachaf> Have you seen Control.Monad.Loops?
02:33:17 <shachaf> Hmm, not that you necessarily need that.
02:33:31 <dabblego> I wrote while using ST a while back :)
02:33:48 <mikeplus64> b52: while pred x = do { r <- pred; if r then do { x; while pred x } else return ()
02:33:49 <shachaf> habblego
02:33:50 <mikeplus64> maybe
02:34:03 <shachaf> b52 wants something more complicated than that, I think.
02:34:29 <mikeplus64> yeah
02:34:31 <shachaf> On the other hand that code can probably be simplified not to need that. :-)
02:34:47 <b52> hoe come?
02:34:49 <b52> how come?
02:35:13 <shachaf> On the other other hand, do you even need a mutable array here?
02:35:19 <b52> yeah
02:35:22 <shachaf> Well, maybe.
02:35:30 <b52> i tried an immutable unboxed array but it was too slow
02:36:16 <shachaf> I think your question may be too low-level. :-)
02:36:42 <shachaf> Anyway, you can probably get away with fix?
02:36:58 <shachaf> I don't know where you want your CONTINUE and ABORT to be bounded.
02:42:45 <hpaste> “[author]” annotated “whileM_ or something” with “whileM_ or something (annotation)” at http://hpaste.org/73218#a73219
02:42:49 <shachaf> b52: Try that.
02:45:21 <danr> b52: to break out of for loops, read Dan Burton's http://unknownparallel.wordpress.com/2012/07/12/breaking-from-a-loop-with-contt/
02:45:51 <shachaf> danr: No, don't use that.
02:46:03 <shachaf> ContT is pretty much never justified. :-)
02:46:35 <shachaf> (That's not true. But in general it provides way more power than you need.)
02:46:41 <shachaf> MaybeT would probably do just as well here.
02:46:55 <danr> then read Tekmo's blog post which uses Either instead http://www.haskellforall.com/2012/07/breaking-from-loop.html, which Dan's was a response to
02:46:58 <shachaf> Or the thing I wrote, which just uses, like, recursion, man.
02:47:26 <shachaf> He responded to a suggestion to use EitherT with a suggestion to use ContT?!
02:47:53 <timthelion> shachaf: beleive it or not, you CAN implement C# entirely as a DSL of haskell.
02:49:31 <danr> shachaf: yes :)
02:49:55 <shachaf> danr: The first post explicitly said that teaching ContT is a bad idea. :-(
02:50:34 <shachaf> That's like teaching people about "goto" instead of break or exceptions.
02:52:04 <timthelion> I remember, when I was like 12, and learning C++, my dad said he would never help me with any code that had a GOTO in it.  Such an angry and hatefull man.
02:52:10 <timthelion> ;)
02:52:46 <timthelion> That last part was not intended to insult my father, for those of you without humor detectors.
02:53:06 <hiptobecubic> No GOTO's? How did you loop?
02:53:16 <timthelion> hiptobecubic: copy paste !
02:53:25 <hiptobecubic> ah ok then
02:54:41 <Jurily> the good old days, when you could choose between two letter variable names with goto, and poking machine code directly into memory.
02:54:51 <timthelion> hiptobecubic: if(!(n > 1)){x;if(!(n>2){x;...
02:55:47 <hiptobecubic> timthelion, you could write the output to a file, and then call the program as many times as you need
02:56:45 <timthelion> hiptobecubic: I hadn't thought of that!  What a great idea.
02:57:11 <hiptobecubic> fputs(atoi(fgets(...))++)
02:57:28 <hiptobecubic> ./a.out; ./a.out; ./a.out;....
02:58:20 <timthelion> hiptobecubic: I just put my program in the Startup folder.  And then cause a kernel panic that triggers computer restart every time I wana loop :P
02:58:39 <hiptobecubic> timthelion, you could flip the breaker to the house on and off
02:59:07 <timthelion> hiptobecubic: timing issues,  How am I supposed to know when the program needs restarting?
02:59:17 <hiptobecubic> timthelion, sleep 1
02:59:52 <hiptobecubic> timthelion, for you I mean. not the program :)
03:00:43 <timthelion> hiptobecubic: On the AVR arduinos, memory adressing is circular.  so if you write in assembler and you don't put any kind of break at the end, and your code is exactly the 1kb that the thing holds...  it will loop without gotos !!!
03:01:21 <hiptobecubic> timthelion, well you can pad it with no-ops right?
03:01:31 <Jurily> are we linking Mel yet?
03:01:32 <timthelion> perhaps.
03:02:03 <timthelion> Jurily: dono
03:02:12 <hiptobecubic> you could have the arduino flip the breaker to the house with the gpio pins and a relay maybe
03:04:22 <timthelion> hiptobecubic: I'll just replace windows .dll with my program.  And have my program trigger a critical exception every time it needs to loop.  That way, when windows tries to load the error dialog, my program will get run again!
03:04:34 <shachaf> "Evidence, or values of type (~), is automatically generated by GHC during type checking. Deferring type errors simply means generating runtime errors as evidence!"
03:04:39 <shachaf> Neat.
03:05:13 <timthelion> shachaf: what is this good for?
03:05:29 <shachaf> Deferring type errors.
03:05:32 <shachaf> http://dreixel.net/research/pdf/ghc7.6mwtte_pres_dhd2012.pdf
03:05:48 <timthelion> shachaf: because you WANT more runtime errors?
03:06:26 <shachaf> No.
03:06:32 <Jurily> well someone must have found it useful if it's implemented...
03:07:57 <mekeor> shachaf: cool
03:09:56 <hiptobecubic> timthelion, now you're onto something :)   What about replacing the stickykeys lib with it, then every five times you press `shift` it will do a loop
03:13:34 <cods> I'm still having difficulties to understand the behavior here: http://hpaste.org/73220   Isn't foldl' supposed to avoid the stack overflow problem?
03:14:19 <shachaf> cods: Yes, but it's forcing the tuple, not its contents.
03:15:26 <hiptobecubic> a `seq` (a,a) perhaps
03:15:56 <hiptobecubic> ah no, it's in the merge of course, disregard that :D
03:15:57 <shachaf> hiptobecubic: Huh? The fix is in the function itself, not the places that use it.
03:16:22 <shachaf> cods: If (,,,) was strict you wouldn't have this problem...
03:16:58 <cods> hmm, you mean that the tuple will be evaluated, but will hold 4 unevalatued thunks (for each expression)?
03:17:01 <hiptobecubic> shachaf, yes of course. I don't think the int literals are overflowing :)
03:17:08 <hiptobecubic> cods, yes
03:17:20 <shachaf> Making merge strict in *{min,max} will fix it, but that'll work even with regular foldl.
03:17:27 <shachaf> cods: Right, that's what I mean.
03:18:16 <hiptobecubic> shachaf, so i guess throw some bangs in there. merge (!xmin, !xmax..)  would do it?
03:18:19 <hiptobecubic> throwing*
03:19:12 <cods> hiptobecubic: that's what shachaf suggested to me in a previous hpaste, and it works.
03:19:22 <shachaf> hiptobecubic: Right -- we've been through that, but cods wants it to work with foldl'.
03:19:35 <shachaf> A reasonable desire but I'm not sure if it'll work with lazy tuples...
03:19:54 <shachaf> One solution would be to data BoundingBox = BoundingBox { xmin, xmax, ymin, ymax :: !Int } :-)
03:20:19 <cods> your solution is fine, but I'd like to understand how Haskell works in other cases.
03:21:20 <hpaste> mekeor pasted “this is kinda cool” at http://hpaste.org/73221
03:22:19 <mekeor> that's *kind* of cool :D
03:22:32 <cods> I tried that and it works too, but looks verbose: http://hpaste.org/73222
03:22:42 <cods> (poor style I guess)
03:23:55 <typoclass> mekeor: seems interesting. what is it? a vector where the type system knows the length ...?
03:24:09 <mekeor> typoclass: yup
03:24:19 <shachaf> cods: No real reason to be strict on the results instead of the arguments.
03:24:37 <shachaf> typoclass: See the PDF I posted before, I think.
03:25:01 <mekeor> typoclass: you could e.g. then do "vecHead :: Vec a (S n) -> a" which makes sure that you don't get an empty vector :D
03:26:02 <mekeor> typoclass: or you can define (+++) :: Vec a n -> Vec a m -> Vec a (n+m) -- (after making N an instance of Num, probably)
03:27:04 <fmap> cods: you probably want data structure with strict fields
03:27:04 <lambdabot> fmap: You have 1 new message. '/msg lambdabot @messages' to read it.
03:27:12 <mekeor> typoclass: or,  zipWithVec :: (a -> b -> c) -> Vec a n -> Vec b n -> Vec c n -- would make sure that the vectors are equally long! :)
03:27:26 <fmap> oh, shachaf has already mentioned it, sorry
03:28:05 <typoclass> mekeor: very nice :-)
03:28:41 <mekeor> typoclass: btw, idris already has all this features.. without language extensions! :)
03:28:44 <typoclass> shachaf: thanks, found it in the logs. looks nice
03:29:45 <typoclass> mekeor: how about inference? do you have to write a lot of type signatures? i asked this about agda once, somebody said yes, and i immediately lost interest :-/
03:30:03 <shachaf> typoclass: Oh, oops, you weren't here when I pasted that.
03:30:30 <shachaf> typoclass: This isn't real dependent types. I think it's still inferrable, or at least inferrable in most cases.
03:30:35 <typoclass> shachaf: it was simple to find. thanks
03:30:46 <shachaf> typoclass: It's mostly nicer support for things you could already do (like HList).
03:30:52 <raichoo> mekeor: Idris <3 <3
03:30:55 <typoclass> shachaf: which one, idris or mekeor's example?
03:31:10 <mekeor> typoclass: the examples
03:31:16 <shachaf> Haskell with the new things.
03:31:26 <mekeor> typoclass: in idris you have to write the type signatures down
03:31:49 <mekeor> typoclass: but i don't think this is a big disadvantage
03:32:04 <typoclass> hm ... that sounds like a gigantic buzzkill to me
03:32:17 <mekeor> typoclass: (ghc also gives a warning (with -Wall) for top-level functions without type sig)
03:32:44 <raichoo> types are propositions, values are proofs. Why would you leave the proposition out? ^^
03:33:00 * mekeor almost always writes down the type sig in haskell, too.
03:33:04 <raichoo> I always write down the typesignatures, even in haskell.
03:33:11 <mekeor> yeah
03:33:13 <raichoo> ^^
03:33:28 <shachaf> typoclass: If it makes you feel any better, most Agda code I've seen has had complicated signatures but trivial implementatins.
03:33:47 <raichoo> full type inference goes out of the window with full dependent types anyway.
03:34:13 <raichoo> coq "suffers" from the same "problem"
03:34:13 <typoclass> mekeor: yeah, top-level is the accepted middle ground. but there's tons of stuff without signatures in 'let' and 'where', for example
03:34:38 <mekeor> typoclass: oh, yeah, i'm not sure whether you need the signatures there
03:34:44 <mekeor> raichoo: do you know?
03:35:44 <typoclass> shachaf: never mind full dependent types. i've often thought that it'd already be infinitely useful if haskell could "just" do non-empty lists conveniently, and things like "an Int which isn't 0", "an Int between 1 and 24", etc.
03:36:17 <DT``> typoclass, (statically checked) contracts?
03:36:32 <mekeor> non-empty list? there's such a datatype somewhere defined...
03:36:45 <shachaf> "conveniently"
03:36:47 <typoclass> DT``: yeah, something like that
03:36:51 <Jafet> Just don't export any of the constructors
03:37:02 <typoclass> mekeor: i think it's the package hlist or something. dunno
03:37:08 <raichoo> mekeor: hm?
03:37:10 <typoclass> shachaf reads me like an open book :-D
03:37:10 <shachaf> Jafet: Constructors?
03:37:14 <mekeor> typoclass: data NonEmpty a = X a | Y a (NonEmpty a)
03:37:23 <shachaf> type NonEmpty a = (a,[a])
03:37:28 <mekeor> @hoogle nonempty
03:37:28 <lambdabot> Test.QuickCheck.Modifiers NonEmpty :: [a] -> NonEmptyList a
03:37:28 <lambdabot> Test.QuickCheck NonEmpty :: [a] -> NonEmptyList a
03:37:28 <lambdabot> package NonEmpty
03:37:49 <shachaf> The issue is all the list operations that you have on lists.
03:38:03 <mekeor> ah, yup
03:39:45 <Jafet> The issue is that you want dependent types without wanting dependent types
03:40:28 <typoclass> Jafet: yup :) i'd like a cake as well while you're at it, and how is that pony coming along?
03:40:30 <Jafet> x :: NonZeroInt -- now you need to write or derive a formal proof of that
03:40:39 <DT``> typoclass, http://hackage.haskell.org/trac/ghc/wiki/Commentary/Contracts
03:40:47 <Jafet> Based on the (arbitrarily complicated) definition of x
03:41:06 <typoclass> shachaf: exactly. if you have a random list [0..5] from god knows where, will it fit into a function that accepts (a,[a])? the answer afaik is no. you'd need some conversion function "fromList", and that couldn't do much more than throw a runtime error if the list was empty, defeating the purpose ...
03:41:19 <Jafet> Oh, and prove that it isn't penis, because that's bad
03:41:23 <DT``> but it seems to be kind of dead-ish(?).
03:41:36 <typoclass> DT``: hm interesting, thanks
03:42:21 <Jafet> Oh, one more fun thing
03:42:26 <Jafet> You need to formalize Haskell first
03:43:10 <shachaf> Jafet: You can get pretty far without dependent types.
03:43:33 <Jafet> Sure, and Haskell already has
03:48:38 <Jafet> The contract thing looks promising, but has limitations
03:49:47 <Jafet> Since it's written directly in the language, I don't think you can write eg. the semantics of id
03:50:03 <Jafet> (Though in this case it's already obvious from the type)
03:51:27 <frerich> :t flip id
03:51:29 <lambdabot> forall a b. a -> (a -> b) -> b
03:51:56 <frerich> I'm having troubles explaining that signature, even though 'flip' and 'id' are rather straightforward. Can anybody maybe explain it, slowly? :-)
03:52:10 <Jafet> flip f a b = f b a
03:52:15 <Jafet> Being the definition of flip
03:52:26 <Jafet> So flip id x f = id f x = f x
03:52:36 <dmwit> frerich: id :: (a -> b) -> (a -> b) = (a -> b) -> a -> b
03:52:45 <dmwit> frerich: So, flip the two function arguments. done
03:52:49 <shachaf> Hah, a value-level explanation and a type-level explanation.
03:53:01 <shachaf> Only one can win.
03:53:02 <Jafet> Now we just need a kind-level one
03:53:17 <shachaf> Jafet: You mean a proof-level one!
03:53:29 <shachaf> Where proof : value = value : type
03:53:36 <Jafet> No can do; we need dependent typing for that
03:53:42 <dmwit> frerich: (Is this perchance related to the SO question?)
03:53:45 <frerich> dmwit: Aah, that's easy!
03:53:54 <typoclass> :t flip
03:53:55 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
03:53:57 <frerich> dmwit: Possibly, I just read a comment at http://stackoverflow.com/questions/11967645/why-cant-a-function-take-monadic-value-and-return-another-monadic-value
03:54:07 <typoclass> ^^ lemme clarify the issue some more :-}
03:54:09 <dmwit> yeah, I'm Daniel Wagner =)
03:54:12 <frerich> dmwit: Oh, hold on - *you* are Daniel Wagner!
03:54:30 <shachaf> "Got a problem? Daniel M. Wagner it!"
03:54:37 <dmwit> =D
03:55:06 <frerich> dmwit: I think your type-level explanation is actaully really neat, it didn't occur to me to see that 'a -> a' == '(a -> b) -> (a -> b)' == '(a -> b) -> a -> b'. And then flipping *that* is easy.
03:55:15 <shachaf> Does M. stand for Merrill?
03:55:21 * frerich re-reads Jafet's explanation to digest the value-level view.
03:55:23 <dmwit> nope
03:55:29 <shachaf> Change it!
03:55:38 <dmwit> What's good about Merrill?
03:56:02 <typoclass> how about Mu?
03:56:06 <shachaf> What's so good about the current thing it stands for?
03:56:10 <shachaf> Oh, yes, change it to Moo!
03:56:17 <dmwit> backwards compatibility
03:56:30 <shachaf> I guess that's true.
03:57:24 * shachaf once met dmwit in person.
03:57:37 <dmwit> amazing
03:57:39 <shachaf> He's just like on IRC, except maybe a bit younger-looking.
03:58:02 <shachaf> ddarius, on the other hand, is nothing like IRC.
03:58:12 <typoclass> shachaf: you mean he consists of letters? on irc he consists of letters and occasional numbers
03:59:13 * shachaf doesn't get that Stackover Flow question.
04:00:05 <dmwit> Yeah, I haven't written an answer because I don't really know what the misunderstanding is that needs to be corrected.
04:04:21 <bitonic> where can I find the LLVM bindings mentioned here: <http://augustss.blogspot.co.uk/2009/06/more-llvm-recently-someone-asked-me-on.html>?  specifically the `compile' function looks really interesting :)
04:05:09 <dmwit> ?hackage llvm maybe?
04:05:10 <lambdabot> http://hackage.haskell.org/package/llvm maybe?
04:05:50 <bitonic> dmwit: I'm not that lazy :)
04:06:18 <dmwit> I mean, he defines "compile" in that blog post...
04:07:41 <bitonic> ohhhh.
04:07:48 * bitonic hides
04:08:29 <bitonic> I thought there was some magic function that compiled Haskell functions dynamically.
04:08:57 <dmwit> Well, that's what the GHC API is for.
04:09:04 <dmwit> But that's not what this post was about, I think. =P
04:09:55 <bitonic> dmwit: well but I don't think that such a function exists - to compile/execute arbitrary code in a string
04:09:59 <bitonic> without creating a module
04:10:47 <dmwit> Okay, I'll take your word for it. I've never really looked at that stuff.
04:11:50 <bitonic> well I didn't dig too deep into the GHC api either, but I can't recall a function like that.  you can definitely load modules dynamically...
04:14:44 <KJChernov> is this true that any function called from the inside of do block must return a IO value (have type smth -> IO smth)?
04:15:11 <dmwit> No.
04:15:19 <dmwit> Some do blocks operate in monads other than IO.
04:15:53 <dmwit> ...and some sneaky do blocks don't operate in any monad at all.
04:16:02 <dmwit> But that's a syntactic artifact, and not really abused very much.
04:16:14 <KJChernov> that's too compicated for me yet... is there any way of passing the bytestring I read to the function that doesnt return IO?
04:16:16 <dmwit> > let don't = 3 in do don't -- for example
04:16:18 <lambdabot>   3
04:16:21 <shachaf> KJChernov: No.
04:16:23 <dmwit> No.
04:16:28 <shachaf> KJChernov: You should read an introduction to IO in Haskell.
04:16:33 <shachaf> @google introduction to IO in Haskell
04:16:35 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
04:16:35 <lambdabot> Title: Introduction to IO - HaskellWiki
04:16:37 <shachaf> That one.
04:16:43 <KJChernov> thx
04:16:47 <shachaf> @where faq -- also see the FAQ. :-)
04:16:48 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:17:30 <dmwit> Q: "How do I get the a out of an IO a?" A: "You don't, you turn the function that wants an a into a function that wants an IO a."
04:17:36 <shachaf> @quote shachaf /bin/ls
04:17:37 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
04:18:03 * shachaf self-quotes.
04:18:45 <companion_cube> nice quote
04:18:49 <shachaf> It's scary how much allocation GHC does.
04:21:13 <Jafet> Well, it's great when you realize that allocation indicates computation
04:21:22 <Jafet> Or do you mean /usr/bin/ghc
04:21:51 <shachaf> I mean GHC-compiled programs.
04:21:59 <shachaf> Nothing wrong with lots of allocation.
04:28:04 <cods> Still trying to work around my bounding box function, this time reading data from sqlite3: http://hpaste.org/73223  The naive solution in Python is 10 times faster than the Haskell one. Obviously I'm doing something wrong here. How can I improve this?
04:28:36 <cods> (both version use the same database, even if the names differ -data.db vs test.db-)
04:29:17 <shachaf> Do you have a sample dataset to try it out with?
04:31:00 <hpc> cods: try folding right instead of left
04:31:06 <hpc> and if that doesn't work, do some profiling
04:31:23 <shachaf> hpc: Huh?
04:31:29 <shachaf> Folding right is almost certainly the wrong thing to do here.
04:31:58 <hpc> uh
04:32:06 <hpc> oh yes, im dumb
04:32:25 * hpc is too used to folding from a list to another list
04:33:54 <shachaf> cods: An easy way to speed it up by a bit would be to add {-# OPTIONS_GHC -funbox-strict-fields #-} to the top of the file.
04:33:55 <donri> how about -funbox-strict-fields if you're banging them ints anyway
04:33:58 <shachaf> But that won't give you 10x
04:34:45 <dmwit> You're compiling with optimizations, right?
04:35:01 <donri> dmwit: -O2, see comment
04:35:14 <cods> right
04:35:20 <dmwit> Have you tried doing the conversion from [a,b] to (fromSql a, fromSql b) inside the fold instead?
04:35:39 <dmwit> Since that looks like one of the few places you're doing allocation...
04:35:47 <shachaf> dmwit: Aw, come on, the function should be stand-alone.
04:36:10 <shachaf> If the bottleneck is HDBC (compared to Python's sqlite3), that's a different matter, of course.
04:37:09 <dmwit> Yeah, it might not hurt to do a bit of profiling.
04:37:12 <frx> foldl (-) 0 [1,2,3] is the same as 0 - 1 - 2 - 3, giving me -6. am i right?
04:37:21 <dmwit> Nothing looks obviously terrible about the code.
04:37:32 <cods> dmwit: nope, I've not tried that. Doing it now.
04:38:00 <shachaf> cods: I suspect the bottleneck might not be in bb at all.
04:38:19 * dmwit is tempted to blame HDBC too
04:38:33 <frx> why does foldr (-) 0 [1,2,3] return 2?  shouldn't it be equal to 0 - 3 - 2 - 1 ?
04:38:50 <dmwit> No, it's right-associative.
04:38:54 <dmwit> 1 - (2 - (3 - 0))
04:39:07 <dmwit> That's what the 'r' means.
04:39:35 <hiptobecubic> foldr snocs instead of cons'ing
04:39:38 <dmwit> The left-associative fold is ((0 - 1) - 2) - 3.
04:39:44 <frx> i see
04:40:09 <dmwit> > foldr (-) 0 [1,2,3] :: Expr
04:40:10 <lambdabot>   1 - (2 - (3 - 0))
04:40:17 <dmwit> > foldl (-) 0 [1,2,3] :: Expr
04:40:19 <lambdabot>   0 - 1 - 2 - 3
04:40:59 <dmwit> > foldr (flip (-)) 0 [1,2,3] :: Expr
04:41:02 <lambdabot>   0 - 3 - 2 - 1
04:41:24 <statusfailed> woah, sweet, standalone deriving declarations :D
04:41:37 <dmwit> Yeah, StandaloneDeriving is great!
04:44:47 <mekeor> what is StandaloneDeriving and what is Expr?
04:45:40 <shachaf> @google what is StandaloneDeriving
04:45:42 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Stand-alone_deriving_declarations
04:45:42 <lambdabot> Title: GHC/Stand-alone deriving declarations - HaskellWiki
04:45:55 <mekeor> :D
04:45:59 <dmwit> ?where simple-reflect
04:46:00 <lambdabot> I know nothing about simple-reflect.
04:46:13 <dmwit> ?hackage simple-reflect
04:46:14 <lambdabot> http://hackage.haskell.org/package/simple-reflect
04:46:15 <shachaf> cods: Yes, I think it's in SQLite.
04:46:29 <dmwit> The Hackage page includes a link to a blog post describing Expr.
04:46:35 <KJChernov> shachaf, I get it now about IO. only thing I still cant understand is why do we need a pure functions, if any action I do starting from main (which is IO) must be IO?
04:46:45 <shachaf> I've never used any database libraries in Haskell so I don't know how good they are.
04:46:52 <shachaf> KJChernov: Pure functions are simpler.
04:47:02 <KJChernov> but how we can use them then?
04:47:05 <KJChernov> *can we
04:47:05 <mekeor> thanks, dmwit
04:47:23 <cods> shachaf: ok. Thanks again for taking the time to look at it!
04:47:29 <shachaf> cods: Hah, for example:
04:47:44 <shachaf> cods: import Control.DeepSeq; and let xys = force [...]
04:48:16 <mekeor> KJChernov: using "return"? return :: Monad m => a -> m a
04:48:36 <shachaf> KJChernov: Maybe you should read an introduction to Haskell.
04:48:46 <shachaf> KJChernov: This topic is well-covered in all of them. :-)
04:48:49 <hpc> hmm
04:48:49 <mekeor> *nod*
04:48:53 <frx> if both foldl and foldr will work (order of operation doesn't matter) is there a convention to prefer one over the other? say foldl (+) 0 [1..5]
04:49:09 <hpc> is there a way in assembly to test if a ghc value is a thunk or evaluated?
04:49:15 <shachaf> cods: It takes it a lot longer to get to the "Got ...", but then the computation is almost instant.
04:49:21 <cods> shachaf: interesting, not faster, but most of the time is now in the list computation, not bounding box.. So, yes, that's a performance problem with HDBC.
04:49:21 <dmwit> frx: foldr is preferred for lazy operations, and foldl' for strict ones.
04:49:32 <shachaf> cods: Yep. Sorry. :-(
04:49:37 <shachaf> At least your code is fast! :-)
04:49:48 <dmwit> frx: There are also various foldb (both-associative) implementations floating around, some with some attempts at parallelism, etc.
04:49:48 <mekeor> frx: (just in case you really do "foldl (+)", there's also "sum" ;])
04:50:13 <mekeor> dmwit: oh, cool
04:50:21 <shachaf> frx: And foldl' (+)
04:50:37 <merijn> frx: If you operator can sometimes return without evaluating the second argument, then foldr will work on infinite structures, foldl won't
04:50:54 <mekeor> @src sum
04:50:54 <lambdabot> sum = foldl (+) 0
04:51:03 <merijn> > foldr (&&) True (repeat False)
04:51:05 <lambdabot>   False
04:51:05 <frx> thanks for all the responses! let me process them all
04:51:10 <merijn> > foldl (&&) True (repeat False)
04:51:16 <lambdabot>   mueval-core: Time limit exceeded
04:51:39 <shachaf> cods: For what it's worth, Python takes a lot longer after the "got" stage.
04:52:03 <shachaf> So once you fix this it'll be good.
04:52:50 <cods> shachaf: yep. I'm trying the sqlite package instead to check if it's better (vs HDBC-sqlite)
04:53:50 <Jafet> hpc: undoubtedly
04:53:53 <tdammers> shachaf: but to be fair, python has to do a lot of stuff at runtime that ghc does compile-time
04:54:03 <shachaf> tdammers: Sure.
04:54:10 <shachaf> I'm just saying it's not hopeless.
04:54:23 <tdammers> :o
04:55:14 <Jafet> Just detect the structure for closures and for nfdata
04:56:05 <frx> is there also apply-like function? or am I suppose to emulate it with fold* functions
04:56:36 <shachaf> frx: You should give an example like you did last time.
04:57:32 <frx> apply + [1..3] would return 6, without having to give an initial value.
04:58:07 <Jafet> What is apply (+) []?
04:58:21 <quicksilver> foldl1
04:58:38 <frx> Jafet it would try to call + without arguments
04:58:46 <sipa> :t apply
04:58:50 <lambdabot> Not in scope: `apply'
04:58:56 <quicksilver> although it's not realy the same
04:59:02 <quicksilver> because + in LISP is actually n-ary
04:59:03 <Jafet> You can't call a function without arguments
04:59:06 <Fulax> foldl1 expects a non-empty list
04:59:16 <quicksilver> whereas foldl1 is just repeated binary +
04:59:36 <frx> all functions in haskell take at least one argument?
04:59:46 <Jafet> At most one, too
04:59:46 <sipa> exactly one
04:59:58 <Jafet> Anyway, '+ in haskell is sum
05:00:05 <Jafet> > (sum [1..3], sum [])
05:00:07 <lambdabot>   (6,0)
05:00:09 <quicksilver> if it doesn't take an argument it's not a function
05:00:38 <Jafet> And apply is ($), or id
05:00:57 <KJChernov> shachaf, finally I get it:) I can use pure function in the 'case' (for example) inside an IO block, but I can't use pure function directly in the do block:) thanks for pointing me into the right direction
05:01:23 <KJChernov> (do block of course, not IO block)
05:01:33 <merijn> KJChernov: The usual approach is to have a gooey pure center of code, surrounded by a coat of IO at the outermost layer
05:02:00 <Jafet> Dark IO or milk IO?
05:02:08 <mrotondo> Is there a way to use GHC to generate new source files with template haskell expanded?
05:02:26 <Jafet> Probably, look at the compilation phase options
05:03:19 <merijn> KJChernov: Also, if you want to beat pure functions/values into the right shape you have "fmap :: (a -> b) -> IO a -> IO b" and "return :: a -> IO a" (Note, that is actually a lie, fmap and return work for many more things, not just IO)
05:03:34 <quicksilver> I don't think there is, because TH doesn't expand into haskell source
05:03:52 <mrotondo> Oh, interesting
05:04:02 <quicksilver> it can "expands into" actual IO actions which get run, as well as directly into parsed AST
05:04:17 <mrotondo> Ok, that's helpful
05:04:25 <quicksilver> I could be wrong though :)
05:04:32 <mrotondo> :) fair nuff
05:05:50 <Jafet> Perhaps one of the -ddump options gives Haskells
05:06:02 <dmwit> mrotondo: You can see what code GHC actually puts in with -ddump-splices.
05:07:14 <myme> I'd like to apply elements of an array to a function until the function is fully applied. Does that make sense at all, and how in that case?
05:07:38 <mrotondo> dmwit, thanks
05:07:39 <dmwit> Yes, it makes sense, and there's a StackOverflow question discussing how to do it.
05:07:42 <dmwit> one moment
05:08:41 <dmwit> http://stackoverflow.com/q/6168880/791604
05:08:48 <luite> mrotondo: zeroth
05:09:13 <pyt_> I'd like to write a function for the pythagorean theorem of type Int -> Int -> Float is this possible? I tried sqrt (a^ 2 + b^2) but it does not work because Int is not an Instance of Floating. But I would like keep Int and not change it to Float, because than everything else had to be changed and I guess Float is much slower than Int.. ?
05:09:27 <luite> though it might have bitrotted a bit
05:09:41 <hiptobecubic> pyt_, fromIntegral (a^2 + b^2)
05:09:46 <mrotondo> luite, I'll take a look! Thanks
05:09:50 <shachaf> cods: By the way, when I put the data in a simple text file and parsed it by hand, the whole program runs in ~4.5 seconds on my computer.
05:09:51 <myme> dmwit: Thanks!
05:09:55 <hiptobecubic> sorry fromIntegral (sqrt ...)
05:10:07 <hiptobecubic> no actually, that's backwards! was right the frist time
05:10:09 <hiptobecubic> :)
05:10:30 <luite> mrotondo: it's quite likely that it doesn't build with the latest ghc, but it does exactly what you ask, it scans files for template haskell and generates a new file with the result
05:10:54 <shachaf> (Almost all of which is parsing, of course.)
05:11:09 <pyt_> hiptobecubic: thanks!
05:11:09 <hiptobecubic> > sqrt $ fromIntegral ((2::Int)^2 + (3::Int)^2)
05:11:11 <lambdabot>   3.605551275463989
05:11:14 <mrotondo> luite, Huh! Any idea why it's rotted? Just abandonware?
05:11:33 <luite> looks like it, latest upload to hackage was in 2009
05:11:33 <hiptobecubic> :t fromIntegral
05:11:35 <lambdabot> forall a b. (Integral a, Num b) => a -> b
05:12:30 <frx> ok my example for apply was wrong since + takes only two arguments. apply take (2,[1,2,3]) would be the same as take 2 [1,2,3]. is there a function like that?
05:12:50 <hiptobecubic> uncurry?
05:12:53 <hiptobecubic> :t uncurry
05:12:54 <cods> shachaf: ok, one more proof than HDBC is the bottleneck I guess.
05:12:55 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
05:13:10 <Jafet> frx: you normally don't need such a function
05:15:03 <Jafet> You can write a suitable family of functions, at some cost to your own sanity
05:15:30 <Jafet> But try to write the type of apply and you will see why we don't actually want it
05:16:46 <dmwit> > uncurry take (2,[1,2,3])
05:16:48 <lambdabot>   [1,2]
05:19:58 * hackagebot language-objc 0.4.2.3 - Analysis and generation of Objective C code (JohnLato)
05:20:39 <cods> shachaf: for the record, the version using the (non HDBC) sqlite package takes only 3s! Python is still faster for me, but that's a lot better anyway.
05:21:06 <schlicht> is Text.Regex.Posix the only regex module that comes with ghc?
05:21:15 <joe9> does the author of implicitCAD hang out here? colah_ ?
05:22:01 <shachaf> cods: Can you @paste the fast versions?
05:22:34 <cods> shachaf: sure
05:22:53 <shachaf> Not that it matters.
05:22:57 * shachaf ought to go to sleep.
05:24:45 <cods> shachaf: http://hpaste.org/73223  (still a Haskell newbie, so it's probably ugly)
05:24:59 * hackagebot uni-util 2.2.1.2 - Utilities for the uniform workbench (ChristianMaeder)
05:26:47 <shachaf> cods: Hah, ~17s here.
05:26:54 <shachaf> I wonder what accounts for the big difference.
05:27:39 <cods> shachaf: I'm running on a i7@3.4GHz and GHC 7.4.1
05:28:00 <nus> what happens if you use quickQuery'
05:29:14 <cods> nus: In this case, my HDBC version terminate with a stack space overflow (just by using quickQuery' without other modification)
05:30:01 * hackagebot uni-posixutil 2.2.1.1 - Posix utilities for the uniform workbench (ChristianMaeder)
05:30:03 * hackagebot uni-uDrawGraph 2.2.0.1 - Graphs binding (ChristianMaeder)
05:30:34 <nus> cods, +RTS -K
05:31:38 <cods> nus: sure I can increase the stack, but I'm expecting a very low use of the stack actually for such a computation.
05:31:56 <cods> (if that was you were implying)
05:32:19 <nus> it won't icrease, just upper bound
05:37:33 <cods> nus: with -K32M it works, but take 33s (2x slower than the original)
05:37:59 <mikeplus64> what's the nicest way of updating say a list only between a given range or index?
05:38:02 <jrajav> Is it alright if I ask a non-Haskell-related functional programming question in here?
05:38:20 <timthelion> jrajav: You can, but there's also #haskell-blah
05:39:35 <mekeor> mikeplus64: probably take+map or so..
05:39:49 <timthelion> mikeplus64: what do you mean, if you want to say update list a :: [a] between index 10 and 15, you can "take 10 a ++ newValues ++ drop 15 a"
05:40:31 <timthelion> mikeplus64: and if you want more preformance, it's possible a foldr would give it to you.
05:40:37 <mikeplus64> yeah
05:40:42 <mekeor> it's prolly more efficient with splitAt instead of take+drop..
05:40:46 <nus> cods, so, it appears that most time is spent in quickQuery
05:40:58 <mikeplus64> i just thought this was something that someone could flaunt a lens at :)
05:41:24 <timthelion> mekeor: why would splitAt be more efficient?
05:41:48 <Jafet> Because it walks the list once
05:42:01 <mekeor> "let (t,d) = splitAt ..." is more efficient than "let t = take ...; d = drop ..."
05:42:30 <timthelion> Well, OK
05:43:22 <jrajav> I'm relatively new to functional programming but I've become very interested in learning as much as I can about it. I started learning Haskell for real over the weekend, but I'm also trying to find out how simple it is to apply some of the concepts in other languages I know. Specifically, what I'd like to know now is this: I heard someone say that, given closures, you can "bootstrap" most of the important bits of lambda calculus. With the addition of closure
05:43:22 <jrajav>  Objective C (and maybe C sometime soon?), does that mean it would be feasible to use real functional programming in it? I can see that there are already some libraries providing something like this, but I'd like to know how much they can actually accomplish
05:43:53 <jrajav> I'm referring to the clang blocks btw
05:43:56 <dmwit> Is there a Haskell question in there?
05:44:07 <earthy> dmwit: no
05:44:08 <jrajav> I did ask to ask
05:44:22 <dmwit> This might not be the right forum if not.
05:44:38 <earthy> jrajav: closures will buy you what you describe, yes.
05:44:41 <Jafet> Haskell isn't C with closures
05:44:50 <earthy> haskell provides quite a bit more though
05:45:17 <earthy> such as laziness, type inference, type constructors
05:45:46 <mekeor> monads
05:45:50 <mekeor> pureness
05:45:52 <eacameron> someone please give me a one-sentence summary of a monad in complete dummy terms
05:45:54 <Saizan> you get a lisp without macros :)
05:46:09 <Jafet> @quote monads.are
05:46:10 <lambdabot> monochrom says: <mauke> monoids are simple  <elliott> And as we all know, monads are basically just monoids!  <monochrom> haskell is basically just ascii
05:46:17 <Jafet> @quote monads.are
05:46:18 <lambdabot> kmc: says: "monads are like containers, as long as you forget everything you know about containers, and treat it as a synonym for 'monad'"
05:46:34 <Saizan> eacameron: look at the definition of the Monad type class
05:46:35 <merijn> eacameron: An abstract model that fits lots of different things
05:46:42 <timthelion> eacameron: Monads are members of the typeclass monad.
05:46:52 <eacameron> you guys are great....thanks for nothing ;)
05:47:01 <merijn> eacameron: Are you familiar with groups/rings in the algebra sense? (If not, forget I said anything about algebra)
05:47:08 <timthelion> eacameron: no really, Monads, are members of the typeclass Monad.
05:47:21 <colthurling> how will we evaluate x+y where x=2 and y=3
05:47:35 <eacameron> timthelion: haha...i dont get it
05:47:43 <timthelion> eacameron: do you know what a type class is?
05:47:56 <earthy> eacameron: monads are a structuring mechanism for code that allows you to layer a 'computation' over function composition
05:47:59 <colthurling> no
05:48:01 <timthelion> eacameron: it's a speciall way of constructing an overloaded function.
05:48:02 <eacameron> timthelion: yes (as much as it's possible to "know" anything in Haskell)
05:48:03 <dmwit> > x+y where x=2; y=3
05:48:05 <colthurling> i am just a begginer
05:48:05 <lambdabot>   <no location info>: parse error on input `where'
05:48:15 <dmwit> oh right
05:48:22 <dmwit> > let x=2; y=3 in x+y
05:48:24 <lambdabot>   5
05:48:39 <colthurling> ohh we need to put semicolon
05:48:39 <colthurling> :)
05:48:48 <mekeor> or newline
05:49:14 <Eduard_Munteanu> What's the idiomatic way to handle multiple connections / non-blocking IO with Network(.Socket)?
05:49:17 <Jafet> We need to avoid using collective pronouns
05:49:26 <dmwit> Eduard_Munteanu: Fork a thread per socket.
05:49:26 <eacameron> is there an easy way to describe monads in non-haskell terms? like to somehow who programs in Basic?
05:49:27 <timthelion> eacameron: So a monad(instance), says that the functions in the typeclass Monad, can be used with a given data type.
05:49:28 <merijn> Eduard_Munteanu: One thread per socket, I think
05:49:45 <merijn> eacameron: Not really, they're just a (very general!) abstraction
05:49:59 <jrajav> earthy: Is it not fundamentally possible to do laziness in Objective C?
05:50:00 <eacameron> merijn: I was afraid of that ;)
05:50:08 <colthurling> x+y where x=2; y=3 this is not working but let x=2;y=4 in x+y is working :)
05:50:09 <jrajav> There are attempts like this apparently: https://github.com/stuartervine/OCTotallyLazy
05:50:12 <merijn> eacameron: If you're familiar with xpath/jquery you could look at how those two are monads too
05:50:18 <earthy> jrajav: no. but it is hard work.
05:50:24 <Saizan> merijn: they aren't..
05:50:29 <jrajav> Hard work to implement or to use?
05:50:34 <Eduard_Munteanu> dmwit, merijn: I see, and I'm supposed to use chans to communicate between threads?
05:50:50 <merijn> Eduard_Munteanu: Or MVar's, or IORef's
05:50:58 <earthy> eacameron: think of monads as a way to overload the semicolon in e.g. C
05:51:03 <DT``> eacameron, think of an interface, that's what monads really are.
05:51:11 <DT``> or typeclasses in general.
05:51:12 <timthelion> merijn: never say the word IORef again!
05:51:15 <Eduard_Munteanu> Maybe I should something else.
05:51:17 <tdammers> earthy: I found that to be more confusing than helpful
05:51:20 <merijn> Eduard_Munteanu: The only thing I find annoying is the lack of select that lets you read from either a socket or a chan, depending on which has data first
05:51:33 <eacameron> DT``: earthy: hmm...that's not too bad
05:51:33 <merijn> Saizan: Why not?
05:51:34 <earthy> tdammers: yes. that is why I didn't start out with it.
05:51:37 <tdammers> better forget about imperative-style programming and come back to the parallels later.
05:51:45 <timthelion> merijn: that's why you need STM and TVars
05:51:54 <Eduard_Munteanu> merijn: hm, yes, how do you handle that?
05:51:57 <Jafet> Well, you can just make threads that write sockets to chans
05:52:15 <dmwit> Eduard_Munteanu: You can use any communication method you like.
05:52:21 <eacameron> the general trouble I have learning haskell is this: whenever I want to understand something, the haskellers just throw type signatures at me!!
05:52:22 <merijn> Eduard_Munteanu: Right now I don't and I changed how my program is structured
05:52:25 <earthy> but if you are firmly stuck in an imperative mindset, the possibility of overloading the statement-composition operator is one of the ways of using monads
05:52:26 <dmwit> merijn, Eduard_Munteanu: Use STM if you want composable communication.
05:52:28 <timthelion> Or you can stop using Chans entirely, and use composed STM opperations instead.
05:52:29 <Saizan> merijn: http://www.reddit.com/r/haskell/comments/ive1n/you_got_your_type_class_in_my_jquery_applicative/c26y5oj
05:52:57 <earthy> eacameron: because type signatures disallow so extremely much
05:53:07 <merijn> eacameron: Understanding how to read type signatures is probably the most crucial and important step of learning haskell. The rest pales in comparison
05:53:10 <Jafet> The general trouble you have is that you think trolling #haskell accomplishes anything productive for yourself
05:53:19 <Jafet> It generally doesn't
05:53:37 <eacameron> Jafet: is that for me/
05:53:38 <eacameron> ?
05:53:42 <merijn> Saizan: Ah, I'll read it later (if at all), I blacklisted reddit during the day :p
05:53:45 <dmwit> It's for basically everybody here, I guess.
05:53:50 <timthelion> eacameron: we tend to think newbs are trolls.
05:54:01 <merijn> timthelion: Speak for yourself
05:54:06 <dmwit> Just remember everybody: you're not being productive in here!
05:54:09 <quicksilver> I resent that remark.
05:54:20 <merijn> In my experience people here tend to assume trolls are newbs, rather than vice versa
05:54:26 <jrajav> Learning is being productive
05:54:27 <Cerise> So, um... I'm trying to write a simple 'cat' implementation in Haskell, and I've come up with "main = getArgs >>= mapM_ (readFile >>= putStr)", but obviously I can't do (readFile >>= putStr)... How'd I work around that?
05:54:28 <tdammers> earthy: if you are firmly stuck in an imperative mindset, you'll have to find a way to break out
05:54:33 <eacameron> timthelion: yeah...I suppose you might be right. I've been using haskell for almost two years (on and off) and I still barely understand half of what's going on. and that's with concerted effort!
05:54:40 <Jafet> There's usually a clear difference between newbies and trolls, even if trolls here disguise themselves that way
05:54:42 <earthy> tdammers: true enough.
05:54:48 <eacameron> timthelion: so I'm less of a n00b and more of a dimwit
05:54:48 <dmwit> Cerise: (readFile >=> putStr)
05:54:49 <dmwit> =)
05:55:04 <Jafet> \x -> readFile x >>= putStr
05:55:04 <timthelion> eacameron: dmwit here isn't so dim.
05:55:11 <Jafet> @src (>=>)
05:55:12 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:55:13 <quicksilver> dmwit here is 80% of a dimwit, and he does well :)
05:55:17 <dmwit> Cerise: Or, if you're not familiar with all the libraries, you'd solve it yourself by doing something like (\filename -> readFile filename >>= putStr)
05:55:20 <eacameron> eacameron: he shames the name
05:55:23 <quicksilver> hmm, no, 83%.
05:55:31 <eikke> In "newtype M1 i c f p = M1 {unM1 :: f p}", are those type parameter names a little joke?
05:55:38 * earthy laughs at quicksilver
05:55:38 <quicksilver> yes, eikke
05:55:55 <Cerise> [14:54:34] <dmwit> Cerise: (readFile >=> putStr) << damn it, this works! I can't believe it's possible to make this work by just changing >>= to >=>, lol
05:55:55 <quicksilver> joke might possibly be too strong a word for it
05:56:03 <quicksilver> but it's a light hearted reference
05:56:23 <eacameron> i'll stop trolling, thanks for your time all
05:56:27 <eikke> that's what I meant (non-native speaker, couldnt find a synonym soon enough)
05:56:30 <Saizan> merijn: tl;dr: it's not polymorphic enough and the laws don't hold
05:56:48 <Cerise> I can easily understand that lambda, but I guess I'll have to look into (>=>)
05:57:01 <dmwit> Cerise: (>=>) is that lambda
05:57:02 <Jafet> Even I don't remember what >=> is
05:57:06 <dmwit> ?src (>=>)
05:57:06 <lambdabot> Source not found. stty: unknown mode: doofus
05:57:07 <merijn> :t (>=>)
05:57:09 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:57:16 <dmwit> f >=> g = \x -> f x >>= g
05:57:29 <dmwit> That's the actual factual definition.
05:57:36 <hiptobecubic> oh i get it
05:57:40 <Jafet> If your backslash key is broken, there's also (>>= putStr) . readFile
05:57:42 <hiptobecubic> the arrows are for x :)
05:58:00 <dmwit> (>=>) is just like (.), but for monadic functions instead =)
05:58:01 <hiptobecubic> putStr <<= readFile ?
05:58:03 <dmwit> compare:
05:58:05 <dmwit> :t (.)
05:58:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:58:12 <dmwit> bleh
05:58:15 <dmwit> :t (Prelude..)
05:58:17 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:59:11 <hiptobecubic> sure
06:18:29 <efie> can someone help me to fix this error? http://hpaste.org/73226 I don't understand what's wrong
06:19:15 <bitonic> efie: what does this mean: `type Network = [Coor,Member]'?
06:19:18 <parcs`> oh jeez that's connfusing
06:19:20 <donri> efie: maybe you meant type Network = [(Coor,Member)]?
06:19:30 <efie> oh yes
06:19:33 <bitonic> also, I think you enabled DataKinds without really knowing what it means.
06:19:46 <bitonic> don't enable language extensions unless you know what you're doing
06:19:59 <statusfailed> or unless they sound really really cool
06:20:16 <quicksilver> -XHalpIAccidentallyTheWholeExtensions
06:20:58 <efie> sorrybitonic: I didn't enable language extensions :) or I am not aware of that I did ..
06:21:12 <efie> thanks
06:21:18 <bitonic> efie: mhm, really?  then I'm surprised that it spits that error out.
06:22:07 <bitonic> efie: you're right.
06:23:03 <bitonic> that is peculiar.  `type Foo = [Int, String]' compiles fine.
06:23:30 <quicksilver> bitonic: GHC has made this mistake before - they generalise the internal structures for a new set of extensions, and they fail to lock them out completely and you get the weirdest error messages :-(
06:23:49 <parcs`> that's why #haskell exists
06:24:02 <bitonic> quicksilver: it's worse than that, I don't see how `type Foo = [Int, String]' can be valid haskell2010.
06:24:11 <flux> parcs`, good thing they do that, then, otherwise #haskell wouldn't exist ;)
06:26:09 <quicksilver> bitonic: agreed
06:26:25 * bitonic goes to file a bug
06:26:51 <statusfailed> Why is is `lookup` from Data.Hashtable.ST.Cuckoo an ST action? Isn't it possible to look up a value without affecting the state?
06:27:17 <statusfailed> or is it because the state itself is in ST
06:27:32 <parcs`> yes!
06:28:05 <quicksilver> statusfailed: if you could run it outside ST, and you had two different cuckoos, which one would it look it up in?
06:28:53 <statusfailed> ok, so can I pull out the table itself from the ST to get an immutable structure?
06:30:08 <statusfailed> or: Is there a lookup datastructure using hashes? :D
06:30:25 <quicksilver> I think you can only get it out as a list
06:30:38 <quicksilver> look at unordered-containers if you want a persistent/immutable one
06:34:25 <timthelion> Is the `fmap` here http://hackage.haskell.org/packages/archive/threadmanager/0.1.4/doc/html/src/Control-Concurrent-ThreadManager.html#make really any different than a pair of parentheses? :P
06:35:34 <quicksilver> timthelion: yes.
06:35:50 <quicksilver> > Just ([4])
06:35:51 <lambdabot>   Just [4]
06:35:55 <quicksilver> > Just `fmap` [4]
06:35:56 <lambdabot>   [Just 4]
06:36:00 <quicksilver> timthelion: ^^ see the difference?
06:36:05 <timthelion> thanks
06:36:50 <quicksilver> the long-hand do notation way to write (TM `fmap` newMVar M.empty) would be (do { mv <- newMVar M.empty; return (TM mv) })
06:37:25 <timthelion> quicksilver: Oh, I see.
06:37:52 * timthelion prefers the long hand :)
06:37:58 <quicksilver> most people use <$> for infix fmap
06:38:33 <mekeor> *nod*
06:38:59 <bitonic> efie, quicksilver: http://hackage.haskell.org/trac/ghc/ticket/7151
06:39:17 <timthelion> the fmap there is truely pointless.  (for example, I'm adding just one more record to TM...  So now I'd need a bifmap...
06:39:33 <mekeor> bitonic: cool :)
06:39:37 <timthelion> It's better to use the do formation, since it's easier to change.
06:40:09 <quicksilver> if TM had two parameters you'd do this:
06:40:25 <quicksilver> TM <$> newMVar M.empty <*> newMVar otherValue
06:40:35 <Jafet> liftA2 TM
06:40:42 <quicksilver> where <$> is `fmap` and <*> is `ap`
06:40:51 <quicksilver> or you could indeed use liftA2
06:41:06 <jtza8> If I've got a huge word list that I have to read from a file every single time, could it be practicle to serialise that word list into a haskell file and then compile it into a more efficient piece of data?
06:41:23 <timthelion> quicksilver: thanks!
06:41:36 <bitonic> jtza8: try and benchmark?  it probably does not make a big difference if the original format is simple to parse.
06:41:37 <quicksilver> timthelion: there is nothing wrong with the do notaiton way though :)
06:41:40 <timthelion> jtza8: is that more efficient?
06:42:03 <quicksilver> timthelion: understanding both is handy.
06:42:06 <Jafet> That would be more efficient for looking up words
06:42:26 <Jafet> Using an executable as a database is a bit dumb, though
06:42:30 <timthelion> quicksilver: yes, I see that...
06:42:41 <jtza8> I suppose I'll have to try it and see.
06:43:08 <timthelion> Jafet: so long as the database is imutable, it might be the best way.
06:43:32 <Jafet> The thing is, they never are
06:50:03 <statusfailed> quicksilver: cheers
07:02:58 <mm_freak> class Injectable e f | f -> e where
07:02:59 <mm_freak> instance (Monoid e) => Injectable e Maybe where
07:03:03 <mm_freak> is this really undecidable?
07:03:43 <mm_freak> or is it just that GHC doesn't know it's decidable?
07:04:13 <mm_freak> (there will be no other Maybe instances)
07:04:58 <merijn> mm_freak: If I understand fundeps correctly that fundep means there's only one possible e that's an instance of Injectable?
07:05:36 <merijn> Fundeps are 1-to-1 mappings, right? So if you only define Maybe for f then you can only get one possible valid e, right?
07:05:49 <merijn> Or do I fail at understanding fundeps
07:06:30 <mm_freak> many-to-one in this case
07:06:35 <mm_freak> otherwise i'd need e -> f, too
07:07:20 <merijn> mm_freak: That's what I'm asking, I didn't think that was how it worked
07:07:28 <Saizan> mm_freak: "f -> e" means that given f there has to be only one e, but your instance says that if f = Maybe then e can be anything, so that's clearly violated
07:08:01 <Saizan> mm_freak: basically, there's no way to interpret that relation as a function from * -> * types to * types
07:08:02 <merijn> Ha! So I was right, then :)
07:08:24 <Saizan> different f's can point to the same e
07:08:26 <mm_freak> is there a better way to express this?
07:08:39 <mm_freak> i want a function toSignal :: f a -> Either e a
07:08:40 <Saizan> but the other way around is not allowed
07:09:03 <mm_freak> where 'e' is polymorphic with a Monoid constraint when f = Maybe
07:09:25 <mm_freak> for Either toSignal should be 'id'
07:09:34 <merijn> "instance (Monoid e, f ~ Maybe) => Injectable e f"?
07:09:44 <merijn> I forgot whether I got the ~ syntax correctly
07:09:48 <mm_freak> merijn: that seems worse
07:09:55 <merijn> Why?
07:09:58 <mm_freak> same thing, just more clumsy syntax
07:10:01 <merijn> No
07:10:04 <merijn> Not the same thing
07:10:19 <merijn> Mine allows any "e and Maybe" combination
07:10:24 <merijn> Yours only allows one
07:10:24 <Saizan> that instance says you don't allow any other f's, unless you want to turn on OverlappingInstances
07:10:52 <McManiaC> is there a convenient function that turns 0.819999999999 into 0.82, i.e. gives me the number of float digits I want?
07:10:57 <mm_freak> Saizan: f-s?  you mean e-s?
07:11:06 <mm_freak> ah, you mean merijn's instance
07:11:07 <merijn> Saizan: Well, presumably that's what he want with an instance like " where
07:11:24 <merijn> "instance (Monoid e) => Injectable e Maybe where"
07:11:39 <Saizan> merijn: he just said he wants (Either e) too
07:11:48 <mm_freak> well, basically i'd like to have a natural transformation to Either from both Either and Maybe (and later perhaps others)
07:12:04 <merijn> Saizan: Just define an an extra instance without that constraint for either?
07:12:13 <mm_freak> for Maybe it would be maybe (Left mempty) Right
07:12:45 <Saizan> merijn: you can't if you have "instance (Monoid e, f ~ Maybe) => Injectable e f" alreadu
07:12:46 <danr> > printf "%.2f" (0.819999999999 :: Double) :: String
07:12:48 <lambdabot>   "0.82"
07:13:13 <merijn> Saizan: Oh, because of OverlappingInstances, right
07:13:24 <merijn> Dammit, I really want instance chains for shit like this >.<
07:13:37 <danr> McManiaC: ^
07:14:06 <Saizan> mm_freak: you could try without the fundep, maybe it won't be so bad
07:14:47 <McManiaC> danr: that's pretty hackish :(
07:14:48 <mm_freak> Saizan: you're right
07:15:11 <danr> McManiaC: oh. why? :)
07:15:11 <merijn> Has anyone ever looked into implementing instance chains? i.e. can someone point me to any mailing list/wiki discussion on it if it exists?
07:15:38 <mm_freak> Saizan: i just want to avoid having to write redundant type signatures =)
07:16:00 <Saizan> they did in Habit, i assume
07:16:04 <mm_freak> but it's fine in this case, because the 'e' is always unified with something else
07:16:10 <merijn> Saizan: I meant in GHC
07:16:58 <realz> ahoy
07:17:02 <merijn> Because that'd allow lots of really neat typeclass/typehacking things
07:17:26 <Saizan> an instance like Injectable e f would be a pain with instance chains too, btw
07:17:32 <realz> I am getting "Could not find module `Random`"
07:17:44 <realz> any clues?
07:17:52 <merijn> Saizan: Maybe, but I want them regardless :p
07:17:54 <realz> import Random (randomIO, randomRIO) << offending line
07:18:00 <realz> random package is installed
07:18:04 <Saizan> realz: use System.Random
07:18:08 <merijn> realz: I think you want System.Random
07:18:40 <McManiaC> danr: http://npaste.de/o4yS/
07:18:41 <McManiaC> :O
07:18:44 <Saizan> realz: Random was the old name
07:18:46 <merijn> realz: Working with old code/examples by any chance?
07:18:55 <realz> yes
07:19:08 <realz> old code, and I am deciphering/learning haskell at the same time ;)
07:19:20 <merijn> realz: There was a reorganisation, if you get more errors you can try to search Hoogle for the new package location
07:19:23 <merijn> @where hoogle
07:19:24 <lambdabot> http://haskell.org/hoogle
07:19:58 <McManiaC> danr: guess I'll just dont add something to this "pretty" double
07:19:59 <McManiaC> :D
07:21:03 <kuribas> If (>>=) is left associative, then will "Nothing >>= f1 >>= f2 >>= f3" be evaluated to "(((Nothing >>= f1) >>= f2 ) >>= f3)" ?
07:22:04 <danr> McManiaC: hehe, yeah Doubles can be a bit "fragile"... But is this a question about printing doubles?
07:22:08 <kuribas> Isn't that inefficient, or does the compiler know to reduce it to just "Nothing"?
07:22:10 <S11001001> kuribas: yes, for some meaning of "evaluated"
07:22:29 <McManiaC> danr: more or less
07:22:31 <kuribas> S11001001: Better word is "equivalent"
07:22:32 <danr> It's usually ok to store something like 0.19999999999 instead of 0.2 (or whatever), and then you print it rounded some nice way for the user
07:22:49 <McManiaC> danr: I'm parsing 1.82 and get 1.8199999 which is annoying
07:23:06 <danr> get over it :)
07:23:13 <_flow_> How can I append two Word32 values? I need something with :: Word32 -> Word32 -> Word64 as signature
07:23:14 <McManiaC> works now
07:23:14 <McManiaC> :)
07:23:17 <realz> ty guys
07:23:46 <merijn> _flow_: Convert the first Word32 to Word64, left-shift 32 positions, add the second Word32 to it?
07:23:58 <roconnor> what are flexible contexts
07:24:07 <shachaf> .|. the second Word32 to it, presumably.
07:24:20 <merijn> shachaf: Potato, potato :p
07:24:44 <kuribas> Will the generated code evaluate all the (>>=) functions, even when the result is Nothing?
07:24:59 <S11001001> kuribas: excluding inlining, sure; but it's trivial, and anyway you can't make that right-associative
07:25:08 <S11001001> kuribas: what would you suggest it do in the absence of inlining?
07:25:13 <shachaf> At any rate, what merijn said. Just like in C. :-)
07:25:17 <_flow_> merijn: converting with fromIntegral?
07:25:40 <merijn> _flow_: For example
07:26:11 <kuribas> S11001001: Inlining is fine I guess, if the compiler will always do this optimisation.
07:26:16 <_flow_> merijn: ty
07:26:36 <shachaf> fromIntegral? Real programmers use unsafeCoerce.
07:26:41 <shachaf> (Yes, use fromIntegral.)
07:26:47 <S11001001> kuribas: it's inlining; "always" isn't a thing :)
07:26:54 <timthelion> It seems it's almost always faster to write your own code, than to try to understand someone elses and modify it.
07:27:15 <mekeor> shachaf: i think you shouldn't make such jokes since people might take them seriously ;)
07:27:33 <merijn> shachaf: Real programmers use peek and that other function to modify raw memory :p
07:28:04 <shachaf> merijn: Peek and prod?
07:28:04 <mekeor> merijn: real programmers use butterflies
07:28:18 <shachaf> mekeor: Please don't.
07:28:37 <mekeor> heh :)
07:39:58 <Veinor> 10:26:33         <timthelion> It seems it's almost always faster to write your own code, than to try to understand someone elses and modify it.
07:40:11 <Veinor> i don't understand why you say that
07:40:45 <DMcGill> how long does hpaste keep pastes for>
07:41:15 <shachaf> DMcGill: Until the next rewrite.
07:41:41 <DMcGill> So "no way of knowing, but there're not going anywhere soon"?
07:41:48 <DMcGill> they're*
07:42:03 <shachaf> Something like that.
07:45:26 <WzC> why is bug 2583 (http://hackage.haskell.org/trac/ghc/ticket/2583) closed as wontfix. This is clearly a bug .....
07:46:03 <timthelion> If I have two versions of a package installed, how do I tell GHC to compile with an older version?
07:46:16 <danr> WzC: maybe the last comment "I think it would be best to make a  library proposal for this.
07:46:20 <danr> " gives some clues
07:46:28 <WzC> yes
07:46:54 <WzC> but the link refers to a wiki-page which basically explains bugs in core libraries should be reported to the appropriate people
07:47:09 <geekosaur> which would be libraries@haskell.org
07:47:19 <hpaste> Moosefish pasted “QuickCheck coverage” at http://hpaste.org/73227
07:47:24 <moosefish> I just found a coverage bug in aeson quickchecks -- long story short, I (decode . encode) data declarations, and just found out that my Arbitrary instance only ever generated one out of a dozen or so possible contructors.
07:47:29 <geekosaur> not the ghc developers
07:47:59 <moosefish> See the above hpaste. I'm wondering if there's any way to structure that so that ghc catches the coverage issue automatically, like it would if this was a case statement on Foz
07:48:19 <quicksilver> WzC: "wontfix" doesn't meant it isnt' a bug, I don't think.
07:48:21 <moosefish> (sorry, I found a bug in MY aeson quickchecks)
07:48:48 <quicksilver> "wontfix" means "The core team do not have time to fix this and do not ever expect it to seem more important than 12 other things we don't have time to do"
07:49:10 <hpaste> Moosefish annotated “QuickCheck coverage” with “QuickCheck coverage (annotation)” at http://hpaste.org/73227#a73228
07:49:24 <WzC> then why does the bug-tracker of the base package refer to the ghc-trac to report bugs
07:49:32 <WzC> anyhow
07:49:42 <WzC> how do I go around in getting it fixed ....
07:53:01 <tgeeky> edwardk: ping
07:53:15 <edwardk> pong
07:54:26 <tgeeky> edwardk: I fixed some things from last night re: haskell-src-meta building. Now I'm stuck with this "no instance for "Lift Word8"" problem, and I know where it's coming from.
07:54:37 <tgeeky> from th-2.7 to th-2.8 this: http://hackage.haskell.org/packages/archive/template-haskell/2.7.0.0/doc/html/src/Language-Haskell-TH-Syntax.html#Lit
07:54:52 <tgeeky> StringPrimL now has type StringPrimL [Word8]
07:55:06 * hackagebot authenticate 1.3.1 - Authentication methods for Haskell web applications. (MichaelSnoyman)
07:55:08 * hackagebot http-conduit 1.6.0 - HTTP client package with conduit interface and HTTPS support. (MichaelSnoyman)
07:55:37 <tgeeky> edwardk: I can't derive "Lift Word8" because it has kind # instead of *
07:55:45 <tgeeky> advice?
07:56:26 <edwardk> tgeeky_: Word8 has kind *
07:56:31 <edwardk> missing the issue
07:56:42 <tgeeky>  ghc-prim:GHC.Prim.Word# :: #
07:56:49 <tgeeky>     Couldn't match kind `*' against `#'
07:56:59 <c_wraith> Oh.  Write an explicit Lift instance for it.
07:56:59 <shachaf> Word# /= Word8
07:57:18 <shachaf> Oh, you're trying to derive an instance.
07:57:25 <shachaf> Right, I doubt that'll work.
07:57:39 <tgeeky> well, I'm just stubmling around trying to get something to build :)
07:57:48 <c_wraith> It's a trivial lift instance.  like lift = numE or the like
07:59:40 <otters> peek and poke
07:59:48 <shachaf> pick and prod
08:00:06 * hackagebot yesod 1.1.0.1 - Creation of type-safe, RESTful web applications. (MichaelSnoyman)
08:00:18 <c_wraith> oh.  return . LitE . IntegerL
08:02:17 <c_wraith> hmm.  with a toInteger in there
08:03:16 <tgeeky> isn't this supposed to be a string of characters?
08:03:42 <edwardk> tgeeky: use WordPrimL's and explicitly convert them to Word8s with fromIntegral in the Lift instance
08:03:57 <c_wraith> tgeeky: lift = litE . IntegerL . toInteger
08:04:05 <c_wraith> that's my final offer!
08:04:14 <tgeeky> c_wraith: yes, I've been trying those things.
08:04:39 <tgeeky> c_wraith: it worked with return, it doesn't work without return
08:04:57 <c_wraith> tgeeky: lowercase l...  litE, as opposed to LitE
08:05:03 <c_wraith> tgeeky: needs a different import
08:05:03 <edwardk> instance Lift Word8 where lift w = varT 'fromIntegral `appT` lift (toInteger w)  -- or something like that
08:05:07 <tgeeky> c_wraith: oh, right.
08:05:08 * hackagebot yesod-auth 1.1.1 - Authentication for Yesod. (MichaelSnoyman)
08:05:10 * hackagebot keter 0.2.0 - Web application deployment manager, focusing on Haskell web frameworks (MichaelSnoyman)
08:05:12 * hackagebot antfarm 0.1.0.0 - Referring expressions for definitions (EricKow)
08:05:49 <edwardk> c_wraith: worried about the types not checking in your version
08:05:59 <tgeeky> instance Lift Word8 where
08:05:59 <tgeeky>      lift = return . LitE . IntegerL . toInteger
08:06:04 <tgeeky> that compiled, and I have a new problem :)
08:06:10 <edwardk> tgeeky_: try the one i gave
08:06:13 <tgeeky> edwardk: on it
08:06:20 <edwardk> tgeeky_: you'll probably fail to unify with the one you had
08:06:39 <c_wraith> edwardk: the docs for IntegerL say: Used for overloaded and non-overloaded literals. We don't have a good way to represent non-overloaded literals at the moment. Maybe that doesn't matter?
08:06:56 <edwardk> maybe its fine then
08:07:02 <c_wraith> edwardk: so the fromIntegral should be implicit
08:07:09 <edwardk> k
08:07:11 <c_wraith> err, fromInteger
08:07:39 <armlesshobo> hmmm. i did not know/notice that head/tail chomp off the rest of the string until now
08:07:45 <edwardk> c_wraith: you're probably right
08:08:19 <armlesshobo> > let it = "HELLO"
08:08:20 <lambdabot>   not an expression: `let it = "HELLO"'
08:08:20 <c_wraith> Makes me curious if StringL works with OverloadedStrings
08:08:26 <edwardk> heh
08:08:50 <edwardk> kinda awkward to require the end user to turn on overloadedstrings though
08:09:04 <c_wraith> I didn't say it was a good idea! :)
08:10:01 <kuribas> For my music notation program I have the following data definitions: http://hpaste.org/73230
08:11:06 <kuribas> Notes and rests are events, all the rest are attributes (including dyamics, etc...).  The idea is that the program runs in several passes over the input, and adds attributes.
08:12:10 <kuribas> (Using a custom monad that can read global parameters, extract attributes, etc..)
08:12:18 <kuribas> Is that a good representation?
08:17:51 <kuribas> The disadvantage is that there are a lot of attributes, and searching them will be (relatively) slow...
08:17:59 <bitonic> efie: as you can see, the GHC devs are very fast: http://hackage.haskell.org/trac/ghc/ticket/7151
08:19:05 <mekeor> bitonic: wow! they fixed it?? oO
08:19:13 <danr> that's quick ;)
08:19:19 <bitonic> mekeor: yes :)
08:19:24 <bitonic> that kind of thing often happen
08:19:56 <mekeor> even by spj himself :)
08:20:44 <bitonic> well it's either him or simonmar, most of the times
08:21:07 <mekeor> btw, which version control does ghc use?
08:21:15 <frerich> And he didn't submit a test for this!
08:21:17 <bitonic> git
08:21:28 <mekeor> ah
08:21:50 <bitonic> used to be darcs
08:21:52 <quicksilver> harsh, bitonic :)
08:22:06 <mekeor> why did they change?
08:22:08 <roconnor> kuribas: people who enjoyed "decorating data structures with attributes" also enjoyed "comonads".
08:22:20 <edwardk> roconnor: =P
08:22:21 <luite> mekeor: there's a mirror at http://github.com/ghc/ghc
08:22:21 <bitonic> mekeor: darcs is too slow
08:22:30 <mekeor> :(
08:22:32 <bitonic> quicksilver: harsh?  who :)?
08:22:45 <kuribas> roconnor: Any links?
08:22:51 <efie> bitonic: nice!
08:23:08 <mekeor> bitonic: that's like accepting that haskell is slower than c :(
08:23:22 <bitonic> efie: your code would still be wrong obviously, but the error message would be much better.
08:23:27 <roconnor> http://www.ioc.ee/~tarmo/papers/sfp01-book.pdf
08:23:35 <bitonic> and earlier, the type declaration alone would set GHC off.
08:23:43 <Aune> Im trying to wrap my head around the Tardis package by building a simple regexp -> NFA parser. Though I cant quite get my head around it. I think that I am imagining dataflow that isnt there. Link: http://hpaste.org/73232
08:23:47 <bitonic> mekeor: no, it's not :P
08:24:02 <Aune> Is it possible to do it that way or am I being silly?
08:24:11 <roconnor> okay, that paper appears to be unreadable
08:24:26 <quicksilver> mekeor: a reimplementation of git's algorithms in haskell would be much faster than darcs
08:24:44 <kuribas> roconnor: I was going to say that...
08:24:44 <mekeor> quicksilver: oh cool
08:24:46 <quicksilver> git is fast because of its file formats and algorithms, not the (primarily) language it's written
08:25:00 <mekeor> quicksilver: why does darcs use a worse algorithm?
08:25:09 <quicksilver> there is a sense in which it's better
08:25:15 <mekeor> namely?
08:25:16 <quicksilver> however it appears not to be a sense which many people care about.
08:25:30 <quicksilver> it's much more sophisticated and robust handling of changesets
08:25:40 <mekeor> hm
08:25:42 <bitonic> it is better in most senses as far as I know.  but until recently it had exponential behaviour in many situations
08:25:44 <roconnor> kuribas: I've got nothin' :(
08:25:48 <bitonic> I think they fixed most of those
08:25:58 <quicksilver> I actually don't really believe in patch theory.
08:25:59 <sclv> darcs' algorithm is much much better!
08:26:04 <bitonic> and I don't think it is inherently slower, or at least not much slower
08:26:16 <mekeor> hmm
08:26:25 <danr> quicksilver: care to elaborate on patch theory?
08:26:30 <bitonic> quicksilver: I like that usage of "believing" :)
08:26:31 <kuribas> roconnor: I found this: Comonadic functional attribute evaluation www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/03num.pdf
08:26:35 <sclv> the main obastacles to darcs performance at this point, afaik are just low level bithacking issues
08:26:43 <mekeor> darcs seems to be a controversial topic
08:27:08 <quicksilver> To be more precise, I don't believe that the detection of commutative changes by checking if changesets touch disjoint portions of files has any value to it.
08:27:10 <sclv> some people got turned off when it had performance issues
08:27:13 <sclv> they've been fixed now
08:27:18 <sclv> but people still remember the problems
08:27:43 <sclv> patch theory could be more powerful if we had more patch types, and semantic patch types
08:27:43 <mekeor> cool
08:27:43 <quicksilver> I think that rather defeats the point of formalising commutativity in the first place.
08:27:44 <luite> quicksilver: yeah it's just a theory, not fact ;)
08:28:12 <sclv> i've found darcs to be better and easier to use than hg or git
08:28:27 <sclv> simple example: i have two branches
08:28:46 <sclv> and then i have uncommitted changes in one, and i commit changes in branch b
08:28:51 <edwardk> i miss darcs, but i've reached a fairly productive place with igt
08:28:53 <edwardk> er git
08:28:54 <tdammers> luite: science sucks. All they ever come up with is theories.
08:29:02 <sclv> now i want to merge branch b back into branch a
08:29:10 <sclv> git and mercurial make me commit all changes to branch a!
08:29:15 <sclv> darcs just does it.
08:29:22 <quicksilver> sclv: really? how bizarre.
08:29:25 <quicksilver> sclv: bzr does not.
08:29:30 <tdammers> git stash, git checkout, git stash pop
08:29:41 <sclv> tdammers: yeah, its a hack
08:29:45 <sclv> the darcs model does it right
08:30:06 <bitonic> sclv: what do you mean "and then i have uncommitted changes in one"?  hg and git handle uncommitted changes differently
08:30:18 <scshunt> sclv: what is the darcs model?
08:30:20 <sclv> branch A has changes that have not been committed
08:30:22 <bitonic> in hg, uncommitted changes are not in any branch really
08:30:24 <sclv> scshunt: commuting patches
08:30:30 <quicksilver> git is a terrible model, with an excellent ondisk representation, and expressive (if weirdly designed) user interface.
08:30:35 <sclv> sorry. my checkout of branch A
08:30:39 <bitonic> you can have changes and switch to another branch, and the changes will remain
08:30:39 <sclv> not the "branch" itself
08:30:45 <scshunt> ^
08:30:47 <tdammers> git sure has quirky semantics
08:30:59 <scshunt> if the files differ between branches, you must stash to do it safely
08:31:13 <bitonic> sclv: if I understand what you're saying, hg behaves like you want it to.
08:31:14 <tdammers> this has nothing to do with branches though, really
08:31:15 <sclv> not in darcs you don't have to
08:31:20 <typoclass> quicksilver: expressive in the sense of 8000 commands with 4 million switches and manpages written in complicated jargon ...
08:31:23 <sclv> darcs doesn't have traditional branches
08:31:28 <sclv> it has bags of patches that you can select from
08:31:44 <sclv> the model is simple and clear to think with.
08:31:52 <roconnor> am I right in understanding git rebase loses information?
08:31:54 <quicksilver> typoclass: expressive means that you can do lots of stuff.
08:32:05 <quicksilver> typoclass: it absolutely doesn't speak to the ease of use.
08:32:16 <quicksilver> typoclass: which is why I put the parenthetical in.
08:32:27 <bitonic> roconnor: yes
08:32:31 <quicksilver> sclv: I find it simple and wrong.
08:32:44 <quicksilver> as a software engineer you do not have 'bags of patches'
08:32:55 <roconnor> I'm surprised git rebase is so advocated given the potential for unrevertable changes.
08:32:57 <sclv> yes I do :-P
08:33:05 <bitonic> roconnor: I'm surprised too.
08:33:09 <quicksilver> a previously untested "Selection of patches" may not do anything useful.
08:33:16 <roconnor> irrevertable? unrevertable?
08:33:20 <quicksilver> just because darcs thinks the patches commute
08:33:29 <quicksilver> (which it thinks by naive textual analysis)
08:33:32 <sclv> https://github.com/mndrix/merge-this
08:33:33 <quicksilver> does not make them independent
08:33:42 <quicksilver> they may have subtle semantic interdependencies.
08:33:56 <scshunt> roconnor: they're not unrevertable
08:34:00 <sclv> yes. you can declare that by hand or just realize that's generally unsolvable
08:34:05 <sclv> by a machine
08:34:12 <scshunt> roconnor: it just takes a bit of knowledge of git to undo them
08:34:13 <quicksilver> sclv: right. it's generally unsolvable, so it's a poor model.
08:34:16 <roconnor> bitonic: seems like a bad property of a revision control system.
08:34:19 <quicksilver> I don't have bags of patches.
08:34:27 <roconnor> scshunt: really?
08:34:27 <sclv> quicksilver: if your model is meaningful compiling units yr right
08:34:32 <typoclass> quicksilver: i dunno, to me "expressive" has a lot to do with clarity as well
08:34:34 <quicksilver> I have branches which represent working states
08:34:37 <sclv> if your model is text files then you're not
08:34:37 <scshunt> roconnor: Yes, because the rebase creates new commits
08:34:43 <sclv> so some bags of patches don't compile
08:34:45 <sclv> i don't care.
08:34:48 <scshunt> the old commits are still around until you do a cleanup
08:34:48 <roconnor> scshunt: an the old commits?
08:34:48 <sclv> i don't think in compiling units
08:34:49 <quicksilver> typoclass: let's not argue about the meaning of words? That's not what I mean by it in this sense :)
08:34:54 <sclv> i think in units of meaningful commits
08:35:05 <roconnor> scshunt: when does a cleanup happen?
08:35:12 <bitonic> roconnor: it doesn't matter that much, in the end.  but I agree with you.
08:35:15 <quicksilver> sclv: commits are meaningful because they represent a movement from one sensible state to another sensible state
08:35:25 <sclv> this is a fundamental philosophical difference :-)
08:35:33 <quicksilver> sclv: the fact you can attempt to apply that commit to another sensibile state
08:35:36 <quicksilver> and possibly get rubbish
08:35:39 <quicksilver> doesn't appeal to me.
08:35:39 <sclv> my idea of a sensible state doesn't necessarily involve ability to compile.
08:35:46 <sclv> :-P
08:35:47 <quicksilver> I agree, it doesn't have to.
08:35:54 <scshunt> roconnor: when you run git gc
08:35:56 <quicksilver> that's just a simple notion of 'sensible' which is easy to talk about.
08:35:58 <typoclass> i thought git also encourages you to commit non-compiling or untested code, because of the whole thing "write code, put some subset in the index, commit the index"
08:36:09 <quicksilver> I agree that other notions of sensible may be more appropriate
08:36:13 <quicksilver> (and harder to make precise)
08:36:22 <scshunt> roconnor: the previous commits are reachable through the reflog, or with fscking
08:36:56 <roconnor> scshunt: hmm I don't fully understand, but I do feel better.
08:37:17 <scshunt> roconnor: the reflog is the log of user actions, basically
08:37:25 <roconnor> good good
08:37:25 <scshunt> every time you do a checkout or commit or anything, it's updated
08:37:48 <bitonic> roconnor, scshunt: no no, rebase does modify the history.  the fact that you can recover that with the reflog is not that relevant in the end - you're not meant to rely on that...
08:38:02 <scshunt> bitonic: true, and it's not pushed
08:38:18 <scshunt> but if you screw up a rebase you can undo it in the future shortly thereafter
08:38:24 <roconnor> I'm the type of person who uses rcs, and does a "ci", thinking that I don't know how to access old revisions with RCS, but if the day comes, I can figure it out then.
08:38:25 <typoclass> i thought the reflog was some auxiliary thing not part of the core data structure
08:38:41 <scshunt> roconnor: if you commit to a headless branch for instance, the reflog will have a reference to the new commit even if you check something else out
08:38:42 <roconnor> bitonic: not meant to rely on it?
08:38:52 <roconnor> bitonic: meaning it is potentially unreliable?
08:39:31 <bitonic> roconnor: it's a bit like relying on the fs not actually deleting the file data when you delete a file.  since deleting a file only removes some entry in a table.
08:39:35 <bitonic> maybe a bit better than that.
08:40:00 <bitonic> but you get the idea
08:40:06 <edsko> anyone know what type "*" means in a -hy heap profile?
08:40:27 <bitonic> or relying on files in /tmp.  or whatever.
08:40:28 <roconnor> bitonic: that does sound unreliable
08:40:45 <roconnor> scshunt: does git gc remove the ability to recover the orginal commits of a rebase?
08:41:02 <bitonic> roconnor: iirc, yes
08:41:16 <merijn> I just installed hg-git and blissfully ignore the fact that my colleagues work with git :>
08:41:19 <Veinor> let me check
08:41:29 <roconnor> okay, I'm convinced that git rebase is bad
08:41:37 <kini> I found and fixed a bug in hg-git the first time I used it
08:41:39 <EvanR> rebase is bad
08:41:50 <EvanR> its also kinda of popular
08:41:57 <merijn> kini: How long ago? I haven't hit any problems yet
08:42:08 <danr> roconnor: you might like this article http://paul.stadig.name/2010/12/thou-shalt-not-lie-git-rebase-ammend.html
08:42:08 <bitonic> roconnor: according to the man page, it's configurable.  by default it expires everything older than 90 days.
08:42:11 <EvanR> but sometimes you hear people say git sucks because everyone rebases, and that makes no sense
08:42:29 <kini> merijn: few months ago - it choked on a malformed hg commit when trying to convert to git's different commit format
08:42:32 <bitonic> roconnor: but the central thing is that the reflog is *not* where git stores changes.  it's an additional thing
08:42:36 <typoclass> merijn: i like your style :-D
08:42:36 <roconnor> EvanR: I don't understand why it is popular.  Well I do understand its merits, but it hard to beleive people think it outweights its demerits.
08:42:45 <kini> also the pure python reimplementation of git it depends on (dulwich) produces really unoptimized git data
08:42:56 <merijn> Well, one, but that's not a bug as much as an implementation decision (the fact that mercurial can't trace blame past file moves on git imported repo's)
08:43:00 <Veinor> git gc doesn't actually destroy the original commit
08:43:06 <Veinor> at least, not right away
08:43:14 <Veinor> i just did a rebase followed by gc and was still able to get back
08:43:18 <EvanR> roconnor: really its only for advanced use to change your own history if no one else has pulled from you yet
08:43:40 <EvanR> not matter-of-course work
08:43:43 <bitonic> EvanR: I know people that always rebase
08:43:45 <kini> for example after converting one mercurial repo to git with hg-git I shrunk the resulting dulwich-produced git repo by 95% using git
08:43:49 <EvanR> bitonic: yeah, they shouldnt
08:43:53 <kini> from 400 MB to 20 MB
08:44:04 <bitonic> EvanR: I tell them, but they like the linear history too much
08:44:30 <roconnor> EvanR: I'm okay with git rebase for expectional circumstances; but it feels like git rebase is part of standard git workflow
08:44:40 <kini> merijn: if you were talking to me, no, it was a bug
08:44:42 <roconnor> granted I'm not a big git user, so maybe I'm wrong
08:44:44 <scshunt> roconnor: fwiw, I agree, and I rebase only when necessary
08:44:48 <kini> mercurial stores one field for commit author, git stores four
08:44:53 <scshunt> or when I'm preparing a sequence of patches for upstreaming
08:44:58 <Veinor> by default, git gc only kills unreachable commits after 30 days
08:44:59 <scshunt> and it can be divided into units
08:45:00 <kini> git author name, git author email, git committer name, and git committer email
08:45:02 <merijn> kini: No, the fact that I only hit one issue while using hg-git
08:45:16 <mjga> roconnor: don't know about rebase, but git is very fast and reliable compared to competition I used
08:45:21 <kini> oh
08:45:37 <roconnor> scshunt: git rebasing for "preparing a sequence of patches for upstreaming" doesn't feel like "rebase only when necessary"  It seems like "always rebase".
08:45:51 <shachaf> roconnor: I think people's attitude tends to be one of "I want my commit history to be clean" and "I want my commit history to reflect development".
08:46:01 <bitonic> roconnor: yeah, they want to have a clean history
08:46:11 <shachaf> roconnor: If your attitude is the former, git-rebase makes a lot of sense.
08:46:12 <bitonic> the same applies to squashing commits
08:46:27 <shachaf> Squashing commits is part of rebase, isn't it?
08:46:33 <bitonic> it has its disadvantages, if done with discipline
08:46:38 <quicksilver> there certainly are cases when history editing is unarguably necessary
08:46:39 <bitonic> shachaf: ah yes
08:46:40 <scshunt> roconnor: No, I don't rebase onto HEAD
08:46:45 <kini> shachaf: yup, exactly
08:46:46 <merijn> The one thing I've grown to love in Hg is Mercurial Queues
08:46:48 <hpaste> tgeeky pasted “building  h-s-m” at http://hpaste.org/73234
08:46:51 <quicksilver> accidental commit of a very large, or confidently, file.
08:46:53 <shachaf> roconnor: Consider that the same person might, instead of rebasing, just spend a long time with uncommitted changes.
08:46:57 <quicksilver> confidential!
08:47:02 <tgeeky> aww edwardk is gone
08:47:04 <scshunt> roconnor: I rebase to remove typo-fixing commits and the like
08:47:08 <shachaf> git lets them have some benefits of version control while still keeping a clean history. :-)
08:47:13 <roconnor> what so bad about git merge?
08:47:16 <merijn> shachaf: MQ solves that problem in mercurial :p
08:47:18 <scshunt> roconnor: I use the merge model for managing branches
08:47:28 <kini> mq is an ugly hack
08:47:33 <merijn> kini: Why?
08:47:38 <merijn> It works brilliantly
08:47:39 <tgeeky> c_wraith: here's my latest: your suggestion still works
08:47:46 <tgeeky> c_wraith: see hpaste ^^
08:47:49 <shachaf> merijn: I don't know much about Mercurial. Is MQ similar to git-rebase?
08:47:53 <typoclass> roconnor: about why git is so popular, i think it's psychological. people tend to be overconfident that they can handle the complexity, whether it's the three-figure number of git commands, or appropriately free()ing every time you malloc()ed, or 80% of everyone thinking they're better than average at everything, etc.
08:48:09 <roconnor> typoclass: interesting
08:48:22 <shachaf> merijn: Ah, looks like it introduces a new kind of commit or something?
08:48:34 <shachaf> typoclass: Oh, come on.
08:48:35 <kini> mq allows you to convert commits into patches which sit in a folder
08:48:50 <merijn> shachaf: MQ creates a stack of patches which it tracks, the bonus is that until you finalise them you can pop them, refresh them, combine them and remove them
08:48:55 <roconnor> danr: your link reflects my feelings about rebasing et. al. quite well.
08:49:03 <bitonic> typoclass: I disagree.  of all the scm I've tried git is the one that clicked faster, for me
08:49:13 <roconnor> ``his makes it look like you were working from foo the whole time. However, each commit to your topic branch was birthed in a context and by a sequence of events that was unique to that time and that topic branch. You are yanking those commits out of their context and putting them into a totally new context.
08:49:16 <bitonic> definitely a lot more than hg.
08:49:18 <merijn> kini: That is an afterthought which won't really work for changes that have been pushed and not it's intended usecase
08:49:23 <Cale> I've been using git lately and it seems so awkward to me compared to darcs.
08:49:37 <shachaf> typoclass: git works well. It has a UI which is more complicated than it needs to be, but when you get an idea of the data model, and how the UI maps onto it, it makes a lot of sense.
08:49:39 <kini> merijn: that's the way you need to use it if you want to use it to simulate git rebase
08:49:44 <tgeeky> c_wraith: I still don't understand if these are supposed to be strings (of characters?) or numbers or whatever, but your suggestion compiles at least :o
08:49:45 <kini> hg does have a rebase extension, though
08:50:04 <shachaf> You'd think #haskell people would like this whole functional-data-structure thing!
08:50:07 <Cale> shachaf: I don't want to have to understand the data model of my revision control system
08:50:13 <merijn> kini: I didn't say you should use it for rebasing, I said it is neat and solves the "spending lots of time with untracked changes" problem
08:50:28 <kini> oh, that's true certainly
08:50:37 <kini> I still find it kind of hackish though
08:50:39 <shachaf> Cale: Maybe we mean a different thing by "data model".
08:50:45 <merijn> shachaf: The basic idea is that I'm editing something, notice a bug I need fixed (but unrelated to what I'm working on), I don't want to mix that fix in my feature commit
08:50:58 <kini> I mean, how nonsensical is it that you have to turn on git-style diffs in your .hgrc in order to have mq notice binary files
08:51:02 <shachaf> It seems pretty fundamental to me.
08:51:34 <c_wraith> tgeeky: Actually, the goal is to create AST nodes. and the reason the other version isn't working, I think, is that it needs AppE, not AppT
08:51:36 <merijn> shachaf: At that point you "refresh" (or create) your patch, pop it of the stack, fix the bug (and commit or keep the fix as a patch in the queue too) and push the original feature patch again
08:51:55 <merijn> shachaf: Keep going until satisfied that feature and bugfix are working as intended, then finalise the patches into commits
08:52:23 <roconnor> danr: I agree with eat-a-git's comments even more than the orginal article.
08:53:06 <Cale> shachaf: In my experience, git fails to abstract its internals horribly all over the place.
08:53:10 * shapr yawns
08:53:22 <merijn> shachaf: As kini points out you *can* convert commits back into patches, (effectively letting you rebase, since you can edit and reorder the patches) but if those patches are already pushed to someone elses repo that'll just create an alternative history, rather than changing it
08:53:24 <typoclass> shachaf: you're right that the basics are easy enough to understand. but there's tons of other stuff you come into contact with. i mean, people in this discussion weren't sure what the "reflog" is, whether it should be relied on, there's conflicting stories how it interacts with git-gc, etc.
08:53:26 <EvanR> i still dont see the complexity referrenced in the git hate
08:53:28 <danr> roconnor: oh thanks, I had missed that comment
08:53:35 <tgeeky> c_wraith: that makes sense. At least I'm not crazy (he used varT and appT, which I didn't catch).
08:53:37 <kini> merijn: rebasing in git does that anyway
08:53:42 <tgeeky> c_wraith: and that works (with varE and appE
08:53:52 <merijn> Also, I just noticed we're not in -blah :>
08:54:03 <shachaf> typoclass: Before you can understand git-reflog, you have to understand git-flog!
08:54:13 <kini> lol shachaf
08:54:15 <EvanR> 'git sucks because everyone rebases' is like haskell sucks because it has unsafePerformIO
08:55:00 <Cale> git's merge is also bad, and does weird things
08:55:02 <merijn> EvanR: git sucks because I find the UI horribly unintuitive, as opposed to hg which I've figured out almost entirely from autocomplete, hg (prints the most used commands) and "hg help"
08:55:15 <merijn> EvanR: Git took me 2 or 3 blog articles and I still don't know how to do shit
08:55:26 <EvanR> git does have nice looking websites
08:55:48 <roconnor> merijn: I might give hg a go one day
08:56:07 <shapr> I've been using git for ghclive this summer, and I think I understand it at this point. But I find darcs simpler and easier to use.
08:56:20 <EvanR> linus rewrote hg why? because its proprietary? too slow? he didnt write it?
08:56:37 <typoclass> shachaf: the sad thing is that i really can't tell if "git flog" is a joke or an actual command. just to be sure, i'll laugh at "flog", as at all git commands
08:56:40 <merijn> EvanR: Too slow at the time he started writing git
08:56:54 <kini> weren't hg and git started within a couple weeks of each other
08:56:56 <shachaf> EvanR: git was released before mercurial.
08:57:02 <merijn> EvanR: Now it's still slower than git, but in my experience not problematically so (i.e. negligible for almost all projects)
08:57:06 <shapr> EvanR: iirc, Linux was using bitkeeper, it went commercial, so Linus tried a bunch of different VC options and ended up writing his own.
08:57:08 <shachaf> Anyway, #-blah.
08:57:16 <shapr> I agree with shachaf :-)
08:57:22 <shachaf> Too many pages of scrollback in this channel.
08:57:38 <EvanR> i was definitely wondering if this was still #haskell
08:57:41 <shapr> ghclive is ALMOST ready for the alpha release!
08:58:04 <shapr> That is, it's almost to the point where it gives value to newbies straight out of the box.
08:58:12 <shapr> After that, it just needs to get pretty.
08:58:12 <fryguybob> shapr: Woohoo!!!
08:58:15 <kini> figures, the only time I stop lurking is when people are off topic... one day I'll learn haskell and join the cool kids talking about arcane stuff :)
08:58:16 <shapr> fryguybob: yah!
08:58:20 <shachaf> shapr: Which value does it give them?
08:58:45 * EvanR gives kini an endoplastic reticulum or whatever
08:58:47 <shachaf> kini: Don't worry, have some nice Haskell snippets to calm you down.
08:58:54 <shachaf> > (!!1)<$>transpose[show$sum[100^2^n`div`(a^i*i)*(8-i.&.3*4)|i<-[1,3..9*2^n],a<-[2,3]]|n<-[0..]]
08:58:56 <EvanR> s/sti/smi/
08:58:56 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
08:59:01 <shapr> shachaf: ghclive is designed to beat the "I have a problem, now I'll try to coordinate hpaste, mu-eval and irc to discuss the problem".
08:59:16 <kini> shachaf: nice :D
08:59:32 <EvanR> the "I have a problem, now I'll try  to coordinate hpaste, mu-eval and irc to discuss the problem" problem
08:59:42 <EvanR> what a problem
08:59:44 <quicksilver> shapr: "and now you have four problems"?
08:59:48 <shapr> quicksilver: yes!
09:00:04 <shapr> EvanR: It's a pretty big problem from what I've seen. What do you think?
09:00:06 <quicksilver> shapr: and your goal is to replace all of those problems with a new problem called shapr.
09:00:09 <quicksilver> @get-shapr
09:00:09 <lambdabot> shapr!!
09:00:10 <shapr> haha, sure :-)
09:00:24 <EvanR> shapr: i thought #haskell was part of the build chain
09:00:42 <shapr> EvanR: It can be, sometimes that's good, sometimes not :-)
09:00:42 <shachaf> "I have a problem. I know, I'll ask #haskell. Now I have a short one-liner that solves an unrelated problem."
09:00:48 <shapr> shachaf: haha, yes!
09:00:59 <typoclass> ... and a huge discussion how to solve that with lenses
09:01:05 <EvanR> heh.
09:01:08 <EvanR> not funny
09:01:12 <shachaf> typoclass: Depends on who's in the channel at the time.
09:02:03 <shachaf> typoclass: With you, it's more likely to be a meownoid in the lolcategory of end o' problems.
09:02:05 <EvanR> for what its worth, i didnt get any help on how to make an instance for String without flexible instances
09:02:14 <shapr> So the idea is to have a shared multi-user Haskell editor in a browser, then load the resulting module into hint on the same server, so the newbie and experience person can easily share questions and answers.
09:02:20 <typoclass> shachaf: :D
09:02:45 <shapr> I've got all the pieces together, but it's in desperate need of css
09:02:56 <mm_freak> is toInteger ever used implicitly?
09:03:03 <mm_freak> (like fromInteger)
09:03:21 <shachaf> mm_freak: Where would that happen?
09:03:35 <mm_freak> shachaf: good question…  i just want to make sure it doesn't =)
09:03:55 <typoclass> shapr: sounds awesome. the chat will be public, right? i mean because it's a terrific learning experience to just read along in #haskell
09:04:07 <shachaf> mm_freak: I'll just say it doesn't.
09:04:18 <mm_freak> because i'm considering adding an Integral instance with toInteger = undefined
09:04:22 <shapr> typoclass: Sure, for the first part I'm not integrating chat, I'm expecting users to use #haskell
09:04:42 <shapr> typoclass: but I plan on integrating webchat that points to #haskell after the interface is cleaner.
09:05:01 <shapr> typoclass: Got any other feature ideas/suggestions?
09:05:50 <mm_freak> is toRational ever used implicitly?
09:06:15 <shachaf> mm_freak: I'll just say "no" again.
09:06:53 <mm_freak> wow, Integral indirectly depends on Enum
09:07:51 <shachaf> mm_freak: I just searched the Report for you. The answer is no.
09:07:59 <mm_freak> thanks
09:08:13 <shachaf> mm_freak: "indirectly"?
09:08:25 <mm_freak> not even indirectly
09:08:30 <shachaf> class Enum a => Integral a seems pretty direct. :-)
09:08:34 <typoclass> shapr: syntax highlighting? haddocks being shown alongside the editor? displaying inferred types everywhere (no need for ":t foo" all the time)?
09:08:52 <mm_freak> shachaf: i just don't understand that dependency
09:08:55 <shapr> hm, that's a good idea
09:09:01 <shachaf> mm_freak: It's ridiculous, of course.
09:09:04 <shapr> It's already got syntax highlighting
09:09:08 <typoclass> (note that i'm hearing about the whole ghclive thing just now for the first time, so take it with a grain of stuff)
09:09:09 <Cale> mm_freak: Yes, that's very silly
09:09:22 <shachaf> @src Real
09:09:23 <lambdabot> class  (Num a, Ord a) => Real a  where
09:09:23 <lambdabot>     toRational      ::  a -> Rational
09:09:31 <shachaf> That's the best class right there.
09:09:52 <Cale> It should at least take an epsilon :)
09:10:23 <mm_freak> the Ord constraint is even worse, yeah…  disregarding the unfortunate name
09:10:33 <Cale> Ord is semi-okay there.
09:11:06 <mm_freak> when the report was written, they must have thought:  "functions must never act like numbers, otherwise you are a stupid retard"
09:11:28 <shachaf> Cale: Semi-okay because equality is "semi-decidable"? :-)
09:11:39 <Cale> shachaf: heh
09:11:44 <Cale> yes
09:12:17 <Cale> Well, if you have a way to convert to Rational, you should have a decidable ordering.
09:12:22 <Cale> (A real way)
09:12:39 <shachaf> Sure.
09:12:49 <shachaf> So now we're just left with the unfortunate name.
09:12:50 <Cale> But if you're taking approximations, then it becomes more questionable
09:13:00 <shapr> typoclass: I must not have done enough advertising.
09:15:49 <Cale> shapr: That's a great idea btw.
09:16:12 <mm_freak> Cale: i really dislike arbitrary constraints…  but i could live with Ord on Real…  what i can't live with is Real/Enum on Integral
09:16:26 <shapr> Cale: I certainly hope it will be popular! If it's not popular, I expect lots of feedback on how it can be improved from people who teach on #haskell
09:16:35 <typoclass> shapr: i just meant to say "i'm in no way an expert on ghclive". about advertising, it's probably that i haven't paid attention :)
09:17:21 <arcatan> is ghclive live?
09:17:24 <Cale> mm_freak: Well, Integral currently has toInteger, which means that toRational ought to be easy, so a Real constraint isn't unreasonable.
09:17:45 <Cale> mm_freak: But it could be argued that toInteger doesn't belong with the other stuff that's currently in Integral.
09:18:00 <Cale> (which is Euclidean algorithm stuff)
09:18:09 <mm_freak> Cale: exactly
09:18:44 <EvanR> whats the rationale for toInteger
09:19:03 <mm_freak> all those to* functions are dealbreakers…  and there is also the weirdly named fromEnum (otherwise Enum would be very possible)
09:19:07 <Cale> or maybe I should just say division algorithm stuff
09:19:24 <Cale> EvanR: toInteger is half of fromIntegral
09:19:35 <EvanR> :t fromIntegral
09:19:36 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:19:49 <mm_freak> :t fromInteger . toInteger
09:19:51 <lambdabot> forall a a1. (Num a, Integral a1) => a1 -> a
09:19:54 <Cale> which is of course, very useful in real code, all over the place
09:20:01 <EvanR> oh
09:20:24 <EvanR> sounds like we want a ToNum class
09:20:26 <Cale> Maybe it shouldn't be in the same class as that other stuff, but it's undeniably useful :)
09:20:31 <parcs`> in practice almost every integral type has a rewrite rule that circumvents that definition
09:20:55 <Cale> You certainly want the fallback in the case that the rewrite rule fails
09:21:23 <Cale> Application of rewrite rules should always be treated as unreliable, if only because it's not always done :)
09:21:28 <EvanR> i was somehow thinking that division is useful in converting between numeric types
09:21:52 <EvanR> in some generic default way
09:22:19 <mm_freak> EvanR: if you have isZero and isNegative, then yes
09:22:47 <EvanR> == 0 ;)
09:22:48 <Cale> tbh, the numeric classes in Haskell are a lot better than what's available in most other languages, and dropping in the standard mathematical abstractions isn't as ideal a solution as you might at first think (remember we have things like Double and Float hanging around, so these things are not rings)
09:22:54 <EvanR> < 0
09:23:00 <Cale> But there is a bit too much clumpiness
09:23:05 <quicksilver> mm_freak: toInteger is used in fromIntegral
09:23:14 <shachaf> Cale: They're not even semigroups!
09:23:18 <quicksilver> mm_freak: oh, someone else already pointed that out :)
09:23:22 <mm_freak> quicksilver: i know…  but it really doesn't belong to Integral
09:23:46 <mm_freak> anyway, i'll live with liftA2 mod
09:23:52 <EvanR> and now i am not sure why Integral is called that
09:24:05 <mm_freak> would be much better to be able to write "x `mod` y" instead of "liftA2 mod x y"
09:24:16 <shachaf> Because you can integrate functions : Integral -> Integral, of course.
09:25:15 <Cale> The idea behind Integral is that it's for integer-like numeric types
09:25:47 <monochrom> haha shachaf
09:25:48 <Cale> So, on integer-like numeric types, we can apply the division algorithm, and we can also convert to Integer (because that's universal)
09:26:10 <Cale> But the division algorithm actually might apply a bit more generally -- for example, to polynomials.
09:26:21 <mysticc> How to set number of threads in haskell program ?
09:26:35 <mysticc> +RTS -N<number> ??
09:26:36 <timthelion> mysticc: as it number of OS threads?
09:26:39 <Cale> mysticc: yes
09:26:53 <mysticc> Cale: Then how do I give command line argument ..
09:27:11 <Cale> mysticc: Presumably on the commandline?
09:27:22 <mysticc> Cale: ./myprog +RTS -N8 somearg
09:27:23 <timthelion> mysticc: before the +RTS
09:27:28 <mysticc> oh thanks
09:27:32 <klugez> mysticc: First the arguments, then the +RTS
09:27:36 <Cale> or put -RTS
09:27:40 <Cale> at the end
09:27:42 <Cale> and then args
09:27:48 <Cale> but yeah, usually just put them before :P
09:28:12 <mysticc> Cale: I was so much frustated searching for this thing :P
09:28:28 <timthelion> mysticc: think about how one would write a parser for it.
09:28:47 <timthelion> mysticc: after the +RTS would be really hard to parse.
09:28:50 <Nereid> how do you pass an argument which consists of "+RTS" to the program? :P
09:29:01 <timthelion> Nereid: :P
09:29:02 <Cale> mysticc: Also see  ./myprog +RTS --help
09:29:23 <Cale> oh, I guess it's supposed to be +RTS -?
09:29:25 <Cale> lol
09:29:25 <shachaf> Nereid: ./foo +RTS --RTS +RTS
09:29:41 <shachaf> (Really.)
09:29:43 <Nereid> of course there's a way.
09:29:50 <Nereid> I figured it would be some kind of -- thing.
09:31:12 <Cale> You can also pass them in the GHCRTS environment variable, apparently
09:31:15 <Cale> I've never tried that
09:32:01 <timthelion> are there any plans to replace hackage with a more flexible system?
09:32:45 <byorgey> timthelion: a complete rewrite of Hackage is currently being worked on.
09:32:58 <johnw> may I recommend using Nix?
09:33:08 <timthelion> johnw: Nix?
09:33:21 <johnw> it's a functionally declared package distribution system
09:33:34 <timthelion> byorgey: The killer feature for me, would be a way to manage my own packages.. Like create a package for a while, then delete it...
09:33:37 <hpaste> “Ertugrul Söylemez” pasted “Noisy FRP clock (netwire)” at http://hpaste.org/73237
09:33:42 <johnw> with support for rollbacks and specific dependencies local to a package
09:34:00 <mm_freak> http://hpaste.org/73237 ⇐ anyway, that's how it looks like without the Integral instance
09:34:04 <mm_freak> still quite nice i think
09:34:04 <johnw> timthelion: can't you do that by just running "cabal install" inside your source tree?
09:34:29 <timthelion> johnw: I want other people to be able to cabal install my package too though.
09:34:33 <johnw> oh, true
09:34:34 <typoclass> timthelion: have you tried to do "cabal init" in your project directory, then doing "cabal install"? (not "cabal install foobar")
09:34:57 <timthelion> typoclass: my problem isn't with cabal, but hackage...
09:36:36 <timthelion> The problem for me, is that I have something that I can release now, but it requires a change to another package on hackage... And I have no clue how long it'll take for that guy to upload my change, as he doesn't appear to be very active.. I'd like to be able to upload my own version of his package, and then delete my version once/if he gets around to applying my change...
09:37:16 <efie> how do I export the record "data Member = Member  { name :: String }" in a module?
09:37:18 <johnw> timthelion: that's where local package dependencies comes in handy
09:37:29 <timthelion> johnw: how does that work?
09:37:38 <shachaf> efie: The record or the type or the constructor or what?
09:37:57 <shachaf> If you do module Blah (Member(..), ...) where, it'll export all of that.
09:38:03 <johnw> the way Nix does it is with trees managed via symlinks, so that your package sees its own "lib" and "bin", part of whose contents come from the "global state", and part of which come from the local state for your package
09:38:05 <shachaf> (Well, I'm not sure what it means to export the record.)
09:38:34 <johnw> that way, the world can upgrade around you, but for those packages where you need a very specific version, your package always sees just that version
09:38:37 <edwardk> preflex: xseen roconnor
09:38:37 <preflex>  roconnor was last seen on freenode/#haskell 42 minutes and 49 seconds ago, saying: merijn: I might give hg a go one day
09:38:45 <donri> timthelion: you can upload releases for any package on hackage, so if the maintainer is completely unresponsive...
09:39:20 <efie> shachaf: ok, thanks, I mixed it up
09:39:32 <timthelion> donri: is that true?  though that sounds a bit dangerous/rude...
09:40:32 <donri> it's rude if the maintainer is active ;) and yea hackage isn't really secure at all currently
09:40:52 <donri> you need an account, and you can only get one by asking the admin, but still
09:41:17 <timthelion> johnw: I'll look into Nix, but I was hoping I could do things the "standard" way so that the people who like to just type "cabal install" will be happy
09:41:45 <johnw> sure
09:42:05 <johnw> I was thinking that if Nix were the infrastructure for Hackage, then cabal would simply execute nix commands to fetch remote packages
09:42:07 <timthelion> donri: sadly, this doesn't solve my problem.  If he doesn't respond in a responce, I might think about it.  But the thing is, I don't want to delay the release of a package just to wait for an email...
09:42:13 <donri> timthelion: you can always run a hackage repo yourself... i think it's possible to use multiple repos at once? i.e. what yesod does for dev releases
09:42:20 <johnw> that way, this same problem doesn't need to be solved over and over again
09:42:53 <johnw> the only downside is that although Nix's config files use a purely functional language, Nix itself is written in C++, so that may be a loss there
09:42:56 <edwardk> johnw: there has been a lot of discussion or reducing the amount of state in hackage and moving to something more nix like, tibbe in particular has expressed interest in it
09:42:58 <timthelion> donri: that sounds complex.  Maybe I'll just delay the release :/
09:43:08 <johnw> edwardk: cool!
09:43:16 <johnw> where can I join that discussion?
09:43:18 <edwardk> johnw: there turn out to be a number of issues with package flags, etc. but it doesn't seem insurmountable in the long term
09:43:29 <edwardk> talk to tibbe and dcoutts when they are on here
09:43:34 <johnw> kk
09:43:36 <shachaf> tibbe was just online.
09:43:47 <tibbe> I'm here
09:43:47 <johnw> i have dealt with more package distribution systems than I care to think about
09:43:48 <dcoutts_> what's the problem?
09:43:53 <edwardk> not sure how much past 'pie in the sky' it has gone
09:43:55 <johnw> tibbe: hello!
09:43:59 <tibbe> dcoutts: you live!
09:44:03 <edwardk> no problem, just the nix-like hackage topic came up
09:44:03 <dcoutts_> @arr!
09:44:04 <lambdabot> Swab the deck!
09:44:15 <edwardk> and i referred johnw to you to ;)
09:44:21 <edwardk> er two
09:44:26 <shachaf> two you to
09:44:40 <johnw> too true
09:44:43 <tibbe> johnw: so I think we have a plan for slaying the dependency beast. Cabal will use a nix-like package store
09:44:57 <dcoutts_> johnw: the main reason we don't just use nix directly is because it's not really portable to windows etc
09:45:01 <johnw> will it have rollbacks too?
09:45:10 * hackagebot hsc2hs 0.67.20120610 - A preprocessor that helps with writing Haskell bindings to C code (ThomasDuBuisson)
09:45:13 <dcoutts_> johnw: instead we're trying to steal the ideas and implement them in the cabal context
09:45:14 <johnw> yeah, and I can understand wanting to maintain it in Haskell
09:45:38 <johnw> when I saw Nix I initially got excited thinking it WAS in Haskell, but then I found out it's not
09:45:56 <edwardk> roconnor: i want to run the new zoom combinator by you and get your impressions when you get a chance
09:46:00 <johnw> but the ideas derive benefit from using the functional paradigm in their execution model
09:46:03 <edwardk> johnw: likewise
09:46:32 <tbelaire> Err I'm getting a weird cabal issue
09:46:33 <tbelaire> what does
09:46:34 <tbelaire> base-4.5.0.0 was excluded because of the top level dependency base -any
09:46:39 <tbelaire> Mean?
09:47:01 <tbelaire> I would think that "-any" would allow any version, no?
09:47:06 <johnw> it would be great to create something in Haskell that was general enough to solve what Nix solves, and then replace Nix
09:47:08 <roconnor> edwardk: zoom?  This vaguely sounds like something I thought you were joking about.
09:47:17 <tibbe> johnw: there's a bunch of engineering work that needs to be done still, but we're making progress
09:47:22 <typoclass> tbelaire: try making it more verbose with -v. if you get stuck, feel free to put cabal's output on hpaste and ask in here
09:47:24 <johnw> having a Haskell-managed Linux OS would be fun
09:47:25 <typoclass> @where hpaste
09:47:25 <lambdabot> http://hpaste.org/
09:47:26 <edwardk> roconnor: i worked up versions of focus that work on deeply nested state and reader environments
09:48:05 <edwardk> thinking about phasing out focus in favor of them
09:48:18 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Type.hs#L358
09:48:24 <edwardk> but focus can work with traversals
09:48:26 <johnw> tibbe: any chance my partner and I could lend a hand?  We're C++ people, not Haskell people (yet), but we care a great deal about the package management problem (mainly wrt the Boost project), and it might be a fun way to involve ourselves in Haskell while solving a larger problem we've been working against for a while
09:48:33 <edwardk> and zoom can only work on a real lens
09:48:35 <donri> i think nix seems nice, but fear it might lead to people not fixing dependency issues, and for example if there's a security bugfix release you kinda want to rebuild all revdeps against the fixed version? but nix sort of encourages you to not care about such things
09:49:04 <shachaf> Hmm, what's Focus?
09:49:17 <johnw> donri: that's true.  there needs to be some kind of "priority override" that a package manager can specify.  Like: "do not allow dependencies on this package below this version"
09:49:22 <edwardk> shachaf: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Type.hs#L290
09:49:23 <tbelaire> typoclass: -v doesn't change the output at all.  Anyways, I must head off
09:49:28 <tibbe> johnw: I'm not one to turn down contributors. :) Now, we're not trying to solve this problem for all OS packages (like Nix). If you're still interested I could point you at some resources.
09:49:35 <shachaf> _1 is a class now?
09:49:41 <edwardk> shachaf: focus came first, it used to be specific to an individual state monad type in data-lens
09:49:46 <johnw> tibbe: point me: johnw@boostpro.com
09:49:46 <edwardk> shachaf: _1 is in a class, yes
09:49:50 <shachaf> Ack, so much generated code.
09:50:03 <johnw> we've been hacking on 0install for a while now
09:50:04 <edwardk> shachaf: you can use ("foo",(),12)^._1 to get "foo"
09:50:09 <shachaf> (...I hope it's generated.)
09:50:11 <johnw> but nothing so far is ideal
09:50:27 <tibbe> johnw: will send you some pointers
09:50:35 <edwardk> shachaf: sadly not as generated as it could have been. ;)
09:50:35 <johnw> and 0install's use of .NET on Windows and Python everywhere else is positively schizo
09:50:42 <edwardk> shachaf: mostly vim macros as i worked
09:50:58 <johnw> tibbe: thanks.  I can't promise anything right now, but I'll give it a serious look and talk it over with Dave
09:51:05 <shachaf> vim macros are probably more efficient if you only have to do it once.
09:51:10 <timthelion> johnw: I have an entirely different direction that I'm pushing with package management.
09:51:11 <edwardk> yep
09:51:15 <tibbe> johnw: fair enough
09:51:21 <typoclass> tbelaire: sorry, i was unclear. i meant "-v3"
09:51:28 <timthelion> johnw: that is, that each file should have enough pragma info, that it can build on it's own
09:51:28 <EvanR> so whats the current state of haskell on a horse
09:52:01 <timthelion> johnw: If you had one function per file... Then you would import functions, and not modules.. And not have packages at all...
09:52:13 <kallisti> EvanR: dead. beaten.
09:52:25 <edwardk> roconnor: ideally i'd be able to just generalize the types used by Zoom and Magnify to support working with an arbitrary traversal or in magnify's case an arbitrary fold
09:52:27 <johnw> timthelion: writing one function per file would be onerous, no?
09:52:28 <monochrom> it is now haskell on a pony for lightweightness :)
09:52:31 <shachaf> Wait, lens is 2.3 already?
09:52:38 <shachaf> That was fast.
09:52:42 <edwardk> shachaf: yes
09:52:44 * shachaf $ cabal update
09:52:46 <timthelion> johnw: the advantage being, that lots of usefull functions. are parts of applications, and not parts of libraries..  And thus they are never properly exposed
09:52:47 <donri> 2-3 releases a day ;)
09:52:48 <monochrom> 2.3 beats 0.0.2.3
09:52:52 <johnw> edwardk: thank you for not using 0.2.3 :)
09:53:03 <johnw> timthelion: yes, that is true, especially so of Haskell
09:53:09 <edwardk> johnw: the pvp would have required me to use 0.23 ;)
09:53:15 <donri> it would have to be 0.23 for pvp... yea
09:53:16 <johnw> timthelion: you end up with "catch-all" packages, like MissingH
09:53:33 <edwardk> donri: i've been averaging less than a less a day since 2.0 ;)
09:53:34 <timthelion> johnw: so you would be reading the source code to an application, and you would just require some bit of it...
09:53:56 <edwardk> https://github.com/ekmett/lens/tags
09:54:19 <shachaf> I like how compiling a program that uses Control.Lens has ~a dozen "loading package ..."
09:54:23 <edwardk> er less than a release a day
09:54:31 <donri> edwardk: git rebase is nice for this. i had like five consecutive commits for new lens releases that i could squash into one, on more than one occasion :p
09:54:48 <edwardk> donri: i really don't like rebasing
09:55:01 <roconnor> edwardk: I use focusish stuff on non-lenses ... granted I used it on a partial lens after guarding it is not . nullOf
09:55:01 <donri> edwardk: well for unpushed commits
09:55:04 <shachaf> edwardk: Any idea why :t doesn't always show the nice type synonyms?
09:55:18 <edwardk> donri: i tend to push them up to get travis to check them on a clean environment
09:55:26 <scooty-puff> probably too general of a question, but if a function builds a list using build f, for some f, can i assume it is a good producer?
09:55:42 <edwardk> roconnor: yeah, hence why ideally i'd like to generalize the signature of zoom to permit the use of zoom on a traversal
09:55:43 <donri> yea, travis only runs on the HEAD on each push, not each commit
09:55:53 <edwardk> shachaf: because type synonyms are fragile beasts
09:56:54 <EvanR> which type synonym is the nice one
09:56:59 <EvanR> they are synonymous
09:57:24 <johnw> hmm.. cabal install lambdabot just failed
09:57:26 <johnw> now I'm in dependency hell ;)
09:58:04 <kallisti> johnw: try cabal install cabal-dev && cabal-dev install lambdabot
09:58:10 <johnw> ah, ok
09:58:10 <typoclass> johnw: you're aware lambdabot can also be /query'd privately? (just making sure)
09:58:30 <johnw> yeah, but I want it (a) local, and (b) want to write some sexy Emacs code for shooting code to a slave lambdabot
09:58:43 <ReinH> johnw: dependencies are (NP) hard ;)
09:59:06 <kallisti> johnw: cabal-dev basically just makes a sandbox to install packages in, so that cabal-install doesn't have to worry about other packages on the system.
09:59:09 <johnw> cabal install cabal-dev fails: The following packages are likely to be broken by the reinstalls
09:59:20 <kallisti> johnw: so you could just install lambdabot in the sandbox and then move the executable elsewhere.
09:59:26 <johnw> ah
09:59:31 <johnw> I should have installed that first then
10:00:05 <kallisti> johnw: possibly, you can make the GHC package system forget about something using ghc-pkg unregister
10:00:22 <johnw> i just blew away .cabal and .ghc and will start over
10:00:42 <kallisti> that works. assuming you didn't have a custom config file. ;)
10:00:52 <johnw> getting that from backup now... ;)
10:01:24 <johnw> thank the stars for ZFS and snapshots
10:01:24 <dcoutts_> johnw: you can just install things allowing others to become broken in the process
10:01:33 <kallisti> I should release a cabal-nuke package on hackage. Think of the irony...
10:01:42 <johnw> that's a good idea t,actually
10:01:45 <johnw> I bet this is an FAQ here
10:01:50 <kallisti> well, it's a good idea to release it elsewhere.
10:01:59 <dcoutts_> johnw: or you can ask to also install the things that would be broken
10:02:07 <ReinH> what's the current state of cabal dep resolution discussion?
10:02:26 <dcoutts_> so they'll be installed simultaneously with consistent deps
10:03:23 <monochrom> cabal dep resolution works fine. promiscuous humans are the problem. promiscuous means wanting too many packages and too many versions
10:03:48 <typoclass> dcoutts_: after a "the following packages will be broken" message, what is the switch for reinstalling those packages?
10:04:08 <dcoutts_> ReinH: the dep resolution is basically ok now, the issues are all to do with managing package environments
10:04:24 <dcoutts_> typoclass: there isn't any, copy and paste them onto the target list
10:04:34 <typoclass> dcoutts_: oh i see. thanks
10:04:50 <dcoutts_> typoclass: there's no guarantee they can be installed simultaneously btw
10:04:54 <edwardk> roconnor: for now at least, i think it makes sense to keep the Focus class around
10:05:11 * roconnor looks forward to the lens themed ICFP contest
10:05:23 <edwardk> roconnor: =)
10:05:40 <edwardk> roconnor: its almost got enough prepositions to be a real language
10:06:07 <edwardk> to, from, alongside, after, throughout, via, over, under, ...
10:06:08 <shachaf> edwardk: Can you beat Perl for poetry yet?
10:06:15 <edwardk> shachaf: probably not ;)
10:06:23 <donri> does cabal use any particular SAT solver?
10:06:33 <dcoutts_> donri: no, it doesn't use SAT
10:06:39 <donri> oh
10:06:43 <roconnor> donri: does bactracking state monad count?
10:07:11 <donri> no idea :)
10:08:16 <donri> isn't SAT applicable to cabal depsolving?
10:09:30 <dcoutts_> donri: yes
10:09:40 <dcoutts_> donri: the tricky bit is error messages
10:10:30 <donri> what i heard is that SAT solvers can improve error messages
10:10:52 <dcoutts_> to use SAT you would need to use a solver that gives an irreducible core set of constraints, and a way to translate that back into the high level constraints, and then a way to translate that into something human understandable
10:11:36 <byorgey> sounds like a fun PhD
10:11:42 <dcoutts_> with a solver operating more directly with the higher level constraints it's easier to collect info that can be used in the error messages
10:12:55 <dcoutts_> donri: the solver is based on the techniques described here
10:12:56 <dcoutts_> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.4704
10:13:07 <dcoutts_> "Modular Lazy Search for Constraint Satisfaction Problems"
10:14:34 <dcoutts_> donri: really sophisticated solvers are not really required, since the typical problems are big but not "hard"
10:15:05 <dcoutts_> so performance isn't really a problem, but good error messages are really important
10:15:13 <donri> aye
10:15:43 <dcoutts_> that paper describes solver techniques which are fairly agnostic in the form of constraint
10:16:08 <dcoutts_> where as SAT obviously only works with a very limited kind of constraint, so there's that extra translation step
10:16:28 <dcoutts_> and it's the reverse translation step that makes it tricky for the error messages
10:17:15 <dcoutts_> donri: I don't doubt it's possible, but it's much harder than it first looks. It'd be interesting to see how SUSE does it.
10:17:16 <donri> so it sounds like what cabal is doing is very similar to SAT, but generalized to some abstract "constraint" rather than booleans?
10:17:31 <johnw> the hoogle package really needs to depend on happy
10:17:33 <donri> yea http://en.opensuse.org/openSUSE:Libzypp_satsolver was where i was reading about it in the context of depsolving
10:17:47 <johnw> i keep getting build failures on hoogle until I read the error log and it says happy is missing
10:18:01 <dcoutts_> donri: yes, the thing to look for is how they do error messages
10:18:22 <JoeyA> Ugh, isn't HUnit supposed to keep you from having to write boilerplate like this?  when (cases /= tried || errors /= 0 || failures /= 0) $ exitFailure
10:18:45 <dcoutts_> donri: also, distros don't need to deal with errors so much since they can arrange things such that there is a solution
10:18:55 <donri> JoeyA: duno, but you can use e.g. test-framework on top of it
10:19:06 <donri> dcoutts_: true
10:19:18 <dcoutts_> donri: and yes, SAT is but one special case of constraint solving
10:19:33 * nand` .oO ( when (cases + errors + failures /= tried) )
10:19:36 <dcoutts_> one with particularly fast solver
10:20:11 <strager> Any good resources on profiling and optimizing Haskell software?
10:20:31 <merijn> strager: This channel is pretty good :p
10:20:39 <merijn> strager: (Also, RWH has a chapter on profiling)
10:21:47 <donri> dcoutts_: well, cabal configure is somewhat slow, although i got the feeling it got a lot faster in a recent version?
10:21:58 <donri> am i imagining that
10:22:32 <strager> I have a ~10k LOC program, and it's not clear to me from GHC's various profiling options (-p, -hc, -hr, etc.) where the performance problems are exactly.
10:22:42 <dcoutts_> donri: yes but that's not to do with the solver
10:22:58 <strager> It's a compiler, and it seems like the parser is slow, but I can't find where.  (It's parsec-based, and yes, I have removed as many 'try's as I can.)
10:22:59 <donri> oh, i thought that was mostly what configure does
10:23:13 <dcoutts_> donri: the new solver is actually faster, but that's not the main contribution. The improved performance recently is mainly due to a cache on the package index.
10:23:39 <donri> aha
10:34:16 <Egbert9e9> What is a good lingua franca file format for Data.Vector data?
10:34:46 <Egbert9e9> file format and the haskell library that deals with it
10:43:31 <johnw> how do I tell cabal install to look for readline in a specific directory?
10:43:50 <dcoutts_> johnw: --extra-lib-dir / --extra-include-dir
10:43:51 <geekosaur> --extra-{include,lib}-dirs
10:43:54 <johnw> ah, thanks!
10:47:22 <shachaf> Egbert9e9: That's kind of vague.
10:47:28 <shachaf> A vector can mean a lot of things. :-)
10:48:58 <Egbert9e9> lets see.. hpasteing
10:50:16 <hpaste> Egbert9e9 pasted “game of strife data types” at http://hpaste.org/73241
10:50:44 <Egbert9e9> shachaf: ^^^ data of the World type
10:52:56 <Egbert9e9> shachaf: like python's h5py for HDF5 file formats
10:54:54 * shachaf wonoders whether Vector is what you really want.
10:54:57 <shachaf> Anyway there are lots of serialization libraries in Haskell.
10:54:59 <pqmodn> what's the proper termonology for something like 'iterate', except that it returns (a, () -> Unfolder a) where the fst is value and snd produces the next pair when applied?
10:55:23 <shachaf> Show/Read is the simplest one, but not very good for this sort of thing.
10:55:26 * shachaf wonders what this thing is.
10:55:28 <shachaf> Egbert9e9: If you have a two-dimensional array, maybe you should use that to represent the board?
10:55:47 <roconnor> pqmodn: in Haskell () -> a is morally isomorphic to a.
10:55:49 <danil> pqmodn: in a lazy language, that's a list.
10:56:13 <Egbert9e9> I keep seeing the term "moral" in this channel and I wonder what that means.
10:56:20 <shachaf> (Or some functional data structure equivalent.)
10:56:21 <Egbert9e9> shachaf: Not sure what you mean by that.
10:56:26 <danil> pqmodn: (in Scheme or ML they'd call it a stream, probably)
10:56:47 <shachaf> pqmodn: Why would you have a function :: () -> Unfolder a?
10:56:48 <jfischoff> repa would probably be better fit because it supports multidimensional arrays, but it is not clear that a packed array is necessary.
10:56:48 <shachaf> Rather than just a value :: Unfolder a.
10:56:52 <pqmodn> danil: yeah i think that's the term i'm looking for, thanks
10:57:11 <roconnor> Egbert9e9: http://www.cs.chalmers.se/~nad/repos/fast-and-loose-proofs/
10:57:22 <pqmodn> shachaf: i suppose it isn't justified in a lazy language, but to model infinite data
10:57:36 <pqmodn> shachaf: oh, right
10:57:47 <shachaf> pqmodn: You shouldn't model things with () -> a :-)
10:58:46 <Egbert9e9> roconnor: Forbidden
10:58:51 <roconnor> Egbert9e9: ah oops
10:58:55 <johnw> how do I get cabal to keep its build products?
10:59:10 <roconnor> Egbert9e9: http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/fast+loose.pdf is what I meant
10:59:11 <efie> during a cabal install process I get "The pkg-config package pango version >=1.0 is required but it could not be found." How do you fix it?
10:59:23 <efie> I am using Ubuntu
10:59:36 <n00b6502> are there  any haskell libraries for efficient 2d arrays e.g. tilied memory layout
11:00:24 <n00b6502> (heh i realize efficient is the wrong word there)
11:00:44 <n00b6502> i should say, datastructures designed for 2d access
11:00:51 <luite> n00b6502: repa
11:01:04 <luite> oh tiled, i think you need to build stuff on top of repa then
11:01:07 * roconnor wonders if a peano curve layout would be efficent
11:01:22 * roconnor wonders how to fill a rectangle with a peano curve
11:01:56 <n00b6502> whats the Z type ordered peano curve called..
11:02:00 <luite> roconnor: is there an easy way to iterate a row, column or rectangle of pixels that way?
11:02:04 <monochrom> you need libgtk2.0-dev and libglade2-dev. this will also bring in pango's dev etc
11:02:06 <n00b6502> you get array indices by interleaing bits
11:02:16 <roconnor> luite: probably not
11:02:30 <roconnor> luite: but I"m not sure
11:02:34 <n00b6502> get2d(array, x,y) = array1d[interleave_bits(x,y)]
11:02:45 <roconnor> it seems there should be some sort of nice relation between bits and position
11:03:21 <luite> right, 2 bits determine the position in a 2x2 squar
11:03:22 <luite> e
11:03:30 <n00b6502> and in haskell-land... instead of "iterators" for a datastructure... you'd define ways to map over it ?
11:03:34 <Egbert9e9> roconnor: Wow. This theory is kilometers above my head.
11:04:05 <roconnor> Egbert9e9: anyhow, that is the canonical definition of moral that I'm aware of.
11:04:56 <roconnor> Egbert9e9: loosely speaking morally means ignoring partial values.
11:04:58 <luite> roconnor: hm i had never thought of that, wonder if it's more efficient than a linear layout if you apply 2d kernels
11:05:22 <nand`> edwardk: you mentioned wanting to add acceleration/friction to paddle movements in Pong.hs; I wonder how an AI that deals with this perfectly would look like (ie. accelerates in a perfect movement for reaching the destination in the shortest time possible; probably involving ‘braking’ by pressing the opposite movement key)
11:05:24 <roconnor> luite: the goal here would be to make gains with storage locality
11:05:46 <roconnor> luite: still, there will be a few big gaps
11:05:50 <edwardk> nand`: the simplest heuristic would be to just maximize the speed of the ball
11:05:55 <roconnor> luite: but maybe fewer than normal layouts
11:06:22 <luite> roconnor: yeah that's what i mean, a linear layout would require a new cache page for every line perpendicular to the layout
11:06:45 <danil> nand`: if you really want "perfect" look up "optimal control"
11:06:52 <n00b6502> the other side of  this is 'efficient for emulating mutability in haskell' , which is also what i had in mind with 2d-'tiles' or whatever
11:07:11 <n00b6502> e.g. mutated version of a datasructure has references to original tiles but one new tile with a change
11:07:14 <roconnor> n00b6502: what's the latest research on cash-oblivious 2-d arrays?
11:07:40 <n00b6502> that i do not knoe
11:07:41 <n00b6502> that i do not know
11:08:15 <n00b6502> but obviously i know that GPUs can use tiles or z-order for texture filtering
11:08:40 <n00b6502> sorry by z-order i mean that thing like a peano curve but Z's instead of U's ..
11:09:14 <roconnor> luite: back when I did graphics work we taylored our tile sizes to the cache size of the machines we were selling.
11:09:21 <luite> n00b6502: is it still a curve then?
11:09:23 <roconnor> not exactly cache-oblivious
11:09:39 <n00b6502> its not contiguous but it has many properties of the peano curve
11:09:52 * roconnor nods
11:09:53 <nand`> danil: the wikipedia article on that has lots of math symbols none of which I understand :(
11:10:02 <roconnor> continutity isn't really a property we need
11:10:03 <luite> n00b6502: right
11:10:29 <roconnor> just locality ... which is close to continuity.
11:10:38 <n00b6502> its like the  peano curve but simpler to implement in hardware... just interveave x,y bits to get an adress
11:10:54 <luite> yeah i understand the interleave now :)
11:10:56 <n00b6502> so contiguous regions of memory are tiles
11:11:03 <n00b6502> 2d tiles
11:11:17 <sipa> *of size power 2
11:11:45 <n00b6502> so i guess you could have a 1D array with mutation optimization... then make a 2d mutable tiles array by just fitting bit-interleave of indices around it
11:11:59 <roconnor> n00b6502: ship it
11:12:03 <luite> n00b6502: you could do that with an unboxed array and an appropriate Ix instance
11:12:12 <n00b6502> i'm guessing haskell already has it i just dont know what its called :)
11:12:26 <roconnor> n00b6502: nobody knows what is on hackage
11:12:28 <luite> dunno if repa can do it
11:13:21 <n00b6502> learning haskel itself is one thing.. learning a whole new world of libraries is another
11:14:01 <n00b6502> i can visualize datastructures in c++ easily of course
11:14:24 <mebaran151> I'm trying to put together a quick salesforce binding for Haskell but am wondering what the best way to structure it
11:15:04 <n00b6502> ok very simple question:  whats the most elegant way in haskell to interleave the bits of 2 ints
11:15:29 <roconnor> where is intercal when you need it
11:15:55 <DanBurton> the "elegant" way would be to turn the ints into lists of bits, and then interleave the lists and turn it back into an int
11:16:00 <DanBurton> might be slow though
11:16:04 <n00b6502> a0a1a2a3..,  b0b1b2b3..  ->  a0b0a1b1a2b3a3b3..
11:16:16 <danil> nand`: wow yeah, that is not much of an introduction.  Basically, there are general methods (the calculus of variations) for finding a function (e.g. thrust as a function of time) that optimizes some functional (say, amount of rocket fuel used) subject to constraints (get from point A to point B with an instantaneous acceleration at most X).
11:16:17 <roconnor> DanBurton: that is pretty elegant
11:16:37 <n00b6502> you'd have to hope some inliner would figure out shifts and masks behind the scenes...
11:16:45 <luite> yeah it wouldn't
11:16:46 <luite> :)
11:17:04 <n00b6502> the ideal is some optimizing compiler that can detect peices of graph and replace them
11:17:09 <DanBurton> well list fusion would probably eliminate the intermediate lists
11:17:25 <DanBurton> but splitting into individual bits is probably unavoidable
11:17:31 <DanBurton> unless you add some serious hacks to ghc
11:17:41 <n00b6502> bit-manipulation hackage
11:17:52 <luite> n00b6502: really it would probably be some combination of shifts or multiply and bitwise operations with a few magic numbers, like in C without specific hardware support
11:18:02 <luite> n00b6502: Data.Bits
11:18:03 <danil> nand`: if your optimization problem is simple enough you can solve it analytically, but if not there are still numerical optimization methods.  I suspect 1-d movement with acceleration and friction has a well-known closed form solution out there somewhere.
11:18:07 <nand`> danil: I see. That does sound related. Here it's “direction as function of time” where direction is either -1, 0 or 1 and thrust is direction * C for some constant C; while optimizing amount of time used overall subject to the constraint (get from point A to point B)
11:18:30 <nand`> no concept of fuel or human limits
11:18:40 <nand`> human/structural/accelerational/speed/whatever
11:18:44 <n00b6502> i suspect a good C implementation will have some lookup table going on
11:19:44 <DanBurton> I'm trying to think if you could write a fast implementation of (interleave :: UVector (a,a) -> UVector a)
11:20:30 <n00b6502> eg at least a 16 byte LUT taking  4bits and returning the bits expanded out lut[a0a1a2a3] = a0__a1__a2__a3   where __=0
11:21:28 <n00b6502> interleave(a,b) = expand(a)<<1 | expand(b);    expand(a) = lut[a&0xf]|(l(ut(a&0xf0>>4)]<<4) ..etc
11:21:45 <roconnor> maybe we can interleave bits with edwardk bit lenses
11:21:48 <n00b6502> missed some casting
11:22:11 * roconnor wonders if there is some sort of zipwith for traversals
11:22:55 <nh2> I use listOf . listOf $ arbitrary `suchThat` (`notElem` ['\NUL', '\n']) instead of the default arbitrary [String]. Why does this disable shrinking?
11:24:19 <DanBurton> roconnor: is lens-family going to be deprecated in favor of edwardk's new lens package? It's basically the same, right?
11:24:23 <danil> nand`: right, in that case your constraints are just the start/end conditions and the fact that direction(t) is in {-1, 0, 1}.  If there's no friction and you want to end up *at rest* at point B, the solution that minimizes time spent is to thrust towards B until you're half way there and then thrust the other way until you stop.
11:24:51 <danil> nand`: but in pong you probably want friction and a max paddle speed, if only for the human player's sanity
11:25:05 <roconnor> DanBurton: I think lens-family will be a slower paced development of lenses and traversals
11:25:28 <nand`> danil: is there a way to write that function so it's independent of state? ie. without a concept of “half-way there”; since you don't know where you started from
11:25:38 <n00b6502> how would you write a lookup table in haskell... matching? not list literal i guess, as thats going to imply link lists?
11:25:50 <luite> an array
11:26:11 <nand`> I'm thinking it decides which way to accelerate based on three parameters: 1. current speed, 2. distance to the goal, 3. direction to the goal
11:26:13 <n00b6502> would it still be a function
11:26:39 <danil> nand`: sure, just find out where you'd stop if you started braking now, and if that's not B yet keep thrusting
11:26:47 <n00b6502> from haskells syntax POV ... i.e. how you use it.. but using a literal array in data. i mean specifically a compile time constant array
11:26:52 <nand`> danil: ah yes, that sounds exactly like what I was thinking
11:27:19 <nand`> works well with friction too; since you simply include friction in the “braking now” deceleration speed
11:27:31 <nand`> and for acceleration you can ignore friction
11:28:49 <luite> n00b6502: hm, i'm not sure if ghc does special tricks to compile lists of constants efficiently, it does do it with strings
11:29:13 <nand`> danil: it would actually have to be slightly modified to make it truly optimal; it would continue accelerating as well if the time spent to arrive at the destination when braking is *longer* than the time the ball needs to reach there
11:29:18 <n00b6502> thats why i thought matching or some sort of case statement might be more likely to do it
11:29:29 <nand`> with the obvious side effect of “overshooting”; but at the benefit of still catching the ball
11:29:33 <n00b6502> as far as i know lists aren't really intended for random access
11:29:55 <luite> it's actually quite tricky to insert arbitrary binary data into a (ghc compiled) haskell executable
11:30:53 <monochrom> whether you use array or bst or hash table or... you can always add a function wrapper
11:31:08 <nand`> danil: so I guess that transforms the problem specification somewhat: basically the same as before, but with the additional constraints that 1. the total time may not exceed some value t, and 2. you want the minimum end speed while not violating (1)
11:31:14 <danil> nand`: yeah, what you actually want is something like to pass through the time/place where the ball will be with the minimum speed at that instant
11:31:37 <nand`> you know where the ball is going to hit, that's a given
11:31:47 <nand`> and when too
11:32:05 <n00b6502> crudely if you say    lut :: Int -> Int     Lut 0 -> 0x00       Lut 1 -> 0x02    Lut 2 -> 0x8   Lut 3 -> 0xa etc ... will it figure out 'Lut' can be a data table
11:32:29 <n00b6502> theres probably a better way..
11:35:42 <roconnor> mingle a b = foldr id 0 [bitAt i.~ (if i^.bitAt 0 then a else b)^.bitAt (i `div` 2) | i < bitSize (mingle a b)]
11:36:33 <roconnor> probably too slow
11:36:52 <roconnor> I guess you could memoize with an array
11:37:49 <n00b6502> well right now if i was going to do something with a 2d array... i think i'd settle for a fixed tiling scheme e.g. 8x8 tiles, trivial to make the index. the bit-interleave thing is nice though because its scalable
11:38:38 <roconnor> n00b6502: can you make 8x8 tiles of 8x8 tiles?
11:39:05 <n00b6502> heh ok
11:39:08 <roconnor> 16x16 seems better than 8x8
11:39:39 <n00b6502> depends on use case i guess
11:40:06 <efie> thanks to the one who gave me the hints concerning pango and libgtk2.0-dev, libglade2-dev ..
11:40:08 <n00b6502> tiles big enough to mean pointer overhead is negligable
11:41:40 <efie> When saying "cabal install X"- gets the owner of X to know that his package has been downloaded and is in use? I'd like him to know that I like and use his package ..
11:42:43 <Athas> efie: he is not informed.  You can send him an email and thank him, though.
11:42:53 <Athas> Most people would appreciate that.
11:42:58 <n00b6502> does FP make it easier for programmers to share code or work on a large program without needing to modify eachothers code
11:43:46 <efie> athas: ah ok, I will do this
11:44:01 <n00b6502> thats a question for anyone using haskell on a  collaborative project perhaps, e.g. with version control and multiple people commiting
11:47:11 <scooty-puff> is there any reason for an mbuild :: (forall b . (a -> b -> b) -> b -> m b) -> m [a] and related rewrite rules?
11:50:15 * hackagebot mwc-random 0.12.0.1 - Fast, high quality pseudo random number generation (BryanOSullivan)
11:51:22 <Enigmagic> n00b6502: i find it easier than c++ for that, yeah. we have 4 developers total and a rather large haskell codebase.
11:52:27 <Enigmagic> having a blessed set of packages helps. 4 developers grabbing shit randomly from hackage wouldn't work as well.
11:52:49 <n00b6502> for me the experience of multiple developpers on C++ has been hell tbh :)
11:53:24 <n00b6502> my perception is, the way C++ encourages you to structure code means people have to modify eachothers work more often.
11:53:48 <Enigmagic> depends on the project and developers. i've done projects in c++ from anywhere from about 2 to 200 devs with varying degrees of success :P
11:53:52 <n00b6502> which is why people moved to version control systems with "multiple checkout"
11:55:18 <Enigmagic> well we do modify other peoples code still, i don't think you can avoid it
11:55:18 <n00b6502> i've got more faith in FP for abstraction and reusability than OOP
11:57:07 <Athas> n00b6502: use of pure code means that there are fewer moving parts that can get in the way of each other.
11:57:19 <hpaste> DanBurton pasted “Interleave two unboxed vectors” at http://hpaste.org/73244
11:57:19 <nand`> powerful type systems help too
11:57:28 <nand`> when it comes to abstraction/reusability
11:57:33 <DanBurton> how does this look for efficiency? ^'
11:58:16 <Athas> Yes, the type system is a handy way to encode a specification that you write code against.
11:58:27 <n00b6502> that along with parallelism is why i'm interested in haskell :)
11:58:32 <Athas> And because the type system is so expressive, you can encode a great amount of the invariants.
11:58:51 <Athas> Traditional project management and design principles are still necessary, of course.  There is no silver bullet.
11:59:04 <danil> nand`: it seems that the solution is still going to looke like "accelerate for X seconds, brake for Y seconds", and then you can use (non-variational) calculus to find X, Y that minimize the final velocity subject to the known current position/velocity and the required position at t
12:00:05 <nand`> danil: yeah
12:00:53 <nand`> in other words, there's going to be a boolean condition that says whether to accelerate or decelerate; (ignoring the case where neither action is performed eg. if the goal is reached prematurely)
12:05:00 <nh2> I use listOf . listOf $ arbitrary `suchThat` (`notElem` ['\NUL', '\n']) instead of the default arbitrary [String]. Why does this disable shrinking?
12:06:21 <jfischoff> What is a good way to avoid explicit recursion when converting between two recursive data structures. I'm looking for an approach in the vain of (Uni|Bi|Multi)Plate?
12:06:33 <Reaga> man i love haskell
12:06:48 <DanBurton> Reaga: well then you're in good company :)
12:07:02 <Reaga> oh my bad, thought i was in ##java
12:08:35 <DanBurton> jfischoff: what did explicit recursion ever do to you? why avoid it?
12:09:04 <copumpkin> it's eeevil
12:09:12 <Jurily> recursion killed my dog
12:09:12 <DanBurton> scrap your boilerplate stuff might help
12:09:16 <danil> nand`: Yeah.  There's often some efficient way to compute what to do at any given moment without computing it for all time, but to actually derive what the boolean condition should be you solve the system and figure out what needs to hold for (optimal) X to be nonzero.
12:09:45 <edwardk> DanBurton: SYB for what?
12:09:58 <DanBurton> for "converting between two recursive data structures"
12:10:06 <edwardk> ah
12:10:24 <edwardk> then i can't recommend my golden hammer ;)
12:10:26 <jfischoff> DanBurton: All types of things. Comes over to my house, goes through my stuff, mocks me in front of people I respect. Maybe I just need to standup to it.
12:10:42 <edwardk> was hoping the 'every' traversal would fit
12:11:03 <monochrom> I like recursion. it taught me many things. my mentor.
12:11:10 <monochrom> and my role model
12:11:57 <edwardk> jfischoff: its recursion though, just wait for it to get closer and closer to its base case. it should slim down enough that you can beat it -- then by induction you win.
12:12:04 <jfischoff> using the plates transform functions, just makes things so clean. I was hoping there was something equivalent for conversions.
12:12:26 <edwardk> jfischoff you need to wait for my multisorted traversals ;)
12:13:30 <Clint> there's no chance of any of this lens stuff without TH, is there?
12:13:35 <jfischoff> edwardk: hurry! It just left a really embarrsing facebook message.
12:14:00 <edwardk> Clint: you don't like the library dependency on TH?
12:14:19 <edwardk> Clint: it uses a couple of type families, so the TH dependency is pretty small change ;)
12:14:39 <edwardk> and you don't need to use TH to use lenses if you want to write them yourself
12:15:06 <Clint> edwardk: well, it means i can't depend on lens on platforms without TH
12:15:15 * hackagebot vector-algorithms 0.5.3.1 - Efficient algorithms for vector arrays (BryanOSullivan)
12:15:22 <zzing_> :t read
12:15:25 <lambdabot> forall a. (Read a) => String -> a
12:15:28 <roconnor> Clint: there is lens-familiy
12:15:40 <edwardk> Clint: sadly, no. you can use the lens-family-core lenses which are compatible with mine
12:16:01 <edwardk> Clint: that gives you a portable core for dealing with lenses and traversals
12:16:04 <zzing_> Is there a read that can take a default value and absolutely not cause an exception?
12:16:08 <Clint> thanks, i'll take a look
12:16:09 <edwardk> but it loses you isomorphisms, indexed traversals, etc.
12:16:14 <merijn> zzing_: Wrap reads
12:16:14 <roconnor> edwardk: not traversals (yet)
12:16:16 <merijn> :t reads
12:16:18 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:16:19 <nand`> zzing_: there's readEither (though not exported) and reads
12:16:22 <Clint> ah, hmm
12:16:34 <merijn> zzing_: reads returns empty list (which you obviously need to check for) if read fails
12:16:59 <nand`> case reads x of [(x', "")] -> ...; _ -> default
12:17:08 <edwardk> ultimately, i bent over backwards and shipped a ton of packages that went out of their way to support everyone in a  nice gradation from haskell 98 on up in terms of comfort level. this resulted in me having to push literally 40 packages every time i made a change in the base layer. it was hell on me as a developer and nobody used them to speak of
12:17:14 <zzing_> > reads "27"
12:17:16 <lambdabot>   []
12:17:32 <edwardk> i shipped lens with all the batteries included and its got more users than all of those other packages put together
12:17:36 <zzing_> > (reads "27")::([Integer, String)]
12:17:37 <lambdabot>   <no location info>: parse error on input `,'
12:17:45 <roconnor> edwardk: to be fair, lenses are super awesome
12:17:45 <zzing_> > (reads "27")::([Integer, String])
12:17:47 <lambdabot>   <no location info>: parse error on input `,'
12:17:56 <edwardk> so i think i'm done with trying to appeal to the lowest common denominator
12:18:00 <merijn> > reads "27" :: [(Integer, String)]
12:18:01 <edwardk> sorry
12:18:02 <lambdabot>   [(27,"")]
12:18:13 <merijn> zzing_: You messed up the brackets of the tuple :)
12:18:15 <nand`> edwardk: was this about category-extras?
12:18:22 <roconnor> Clint: ATM I fully intend to support the lowest common denominator
12:18:27 <edwardk> category-extras was monolithic and people used it.
12:18:36 <merijn> edwardk: Screw the lowest common denominator! :)
12:18:38 <nand`> I mean the broken up versions we have now
12:18:41 <edwardk> i broke it into a million packages, and i got a few users of comonad and semigroups
12:18:41 <Clint> roconnor: good to know
12:18:50 <roconnor> actually it is my fault edwardk exploded category-extras
12:19:01 <cods> What would you suggest for a fast mutable and memory efficient 3D array of Int8 (to build an RGB image to later save in pgm format)?
12:19:04 <edwardk> and then the bulk of the hierarchy wallows in pain ;)
12:19:06 <roconnor> I wanted Haskell-98 comonads and lenses
12:19:24 <roconnor> not knowing it would break edwardk's psyche
12:19:24 <edwardk> i'm perfectly okay with comonad as it wound up broken out
12:19:29 <edwardk> i think its a good model
12:19:34 <edwardk> i also like semigroups as it exists
12:19:48 <edwardk> btw- if anyone wants to petition for either of those to go into the platform now is pretty much the time
12:20:01 <roconnor> ya, those are the two parts of category-extras I care most about :D
12:20:16 <nand`> yeah I don't think semigroups should be lumped into any huge package involving kan extensions and whatnot; it seems about as basic as something like Monoid
12:20:33 <edwardk> i think that the cost/benefit ratio of the breakout on the rest of the hierarchy is somewhat dubious
12:20:36 <nand`> I'm fine with comonads in the platform
12:20:52 <nand`> never really used semigroups though so I have no opinion
12:20:55 <edwardk> nand`: i deliberately made the semigroups package compile on everything. its hugs compatible even
12:21:07 <edwardk> thats elliottc1ble's doing
12:21:46 <DanBurton> edwardk: regarding the TH, you can just tell people to use lens-family-th to remove the dependency, right? Or do you have additional TH that you make use of?
12:22:02 <edwardk> dolio made a pretty compelling case when i started to break up lens into multiple packages that supporting the minority that want portability comes at the expense of making everyone else import three arcane packages
12:22:19 <edwardk> DanBurton: i don't use lens-family-th in lens. it has a much smarter template haskell generator
12:22:55 <edwardk> it goes through and generates correct signatures for lenses, isomorphism lenses, etc. does the alpha renaming and checks for constraints put on the types by other fields, etc.
12:23:22 <DanBurton> edwardk: oh my, I hadn't looked into it yet. That's very cool.
12:23:36 * roconnor needs to move before it starts raining
12:23:45 <DanBurton> You could still split off the TH into its own module if people don't like that dependency. "lens-th" is probably untaken
12:24:21 <edwardk> right now its pretty much a wont-fix because i already have type families used in the module, when there is another haskell implementation that offers type families i'll consider splitting
12:24:42 <edwardk> to do so now just makes a pain point for no reason
12:25:18 <edwardk> i need type families to make indexed traversals type check cleanly
12:25:33 <edwardk> because of the need for (~)
12:26:23 <c_wraith> Funny that you don't actually need type families..  just the type equality operator
12:26:40 <edwardk> there are two ways i can write the instance
12:26:41 <merijn> edwardk: The correct response is "I await your patch with great anticipation" :)
12:26:50 <edwardk> merijn: no, because i'd refuse the patch
12:27:02 <edwardk> no sense giving a false sense of hope ;)
12:27:11 <nathanel_> is it somehow possible to get the X11 window id from a GLUT Window?
12:27:23 <merijn> edwardk: :p
12:27:49 <DanBurton> fair enough. edwardk are you planning on writing up a prose guide to the new lenses? There's an awful lot in your new package to take in without guidance.
12:27:59 <edwardk> DanBurton: did you look on the wiki?
12:28:12 <edwardk> github.com/ekmett/lens/wiki has a writeup on the derivation of these types
12:28:24 <edwardk> it also has a big uml diagram tour of the center of the hierarchy
12:29:18 <edwardk> i intend to write up separately sections on isomorphism lenses, and indexed lenses
12:29:20 <c_wraith> I'd find a quick-reference on the operators handy, too
12:29:46 <edwardk> c_wraith: yeah thinking about making an incredibly large version of the uml diagram with all the operators and the full hierarchy
12:30:28 * nand` wishes there was a naming convention for functions which may call ‘error’
12:30:47 <Reaga> hey :)
12:30:48 <edwardk> nand`: it starts with a letter _ or a symbol ;)
12:31:00 <c_wraith> I said *quick* :)
12:31:01 <nand`> ...that distinguishes it from functions which don't :)
12:31:03 <Reaga> _
12:31:21 <Athas> Why is Robert Harper so grumpy?
12:31:27 <Reaga> nand`: why on earth would you design a function which calls error
12:31:30 <merijn> Athas: Because no one really uses ML :D
12:31:33 <Reaga> bad coder
12:31:42 <DanBurton> Athas: he's not grumpy he's just an unfortunately intelligent troll
12:31:47 <edwardk> c_wraith: https://github.com/ekmett/lens#field-guide was intended to give you a tour of the important ones
12:31:51 <nand`> Reaga: I wouldn't :(
12:31:58 <c_wraith> Athas: he doesn't like some of haskell's design decisions - and he really doesn't like that they're turning out to be popular.
12:33:33 <DanBurton> Lenses make me so happy; I wonder if lenses are going to be the new monads as far as inaccurate metaphors and abundant tutorials go
12:33:40 <edwardk> You know, Bob Harper's approach to Haskell makes sense when you consider his night job is hosting a democratic talk radio show. If you visualize his words spewing forth from the mouth of Rush Limbaugh, you can see he's only doing this to boost ML's ratings. ;)
12:34:02 <Athas> His points are really good, and it's just really amusing how he always seems to angle his presentation to snipe at Haskell.
12:34:21 <edwardk> Athas: he doesn't like lazy languages and non-strict semantics in general
12:34:45 <Athas> That is evident from his blog, to put it mildly.
12:35:31 <edwardk> DanBurton: i really enjoy programming with the new lens api.
12:35:55 <edwardk> that and now that i have laws on things like traversals i can actually reason about them
12:36:19 <c_wraith> I really want one of these "new prelude" projects to notice what you've been doing, and try building on top of it, instead of doing ad-hoc stuff
12:36:36 <DanBurton> oh I for one have definitely noticed :)
12:36:48 <DanBurton> (I'm working on basic-prelude and modular-prelude)
12:37:04 <edwardk> i just get sad when i look at the classy prelude and all those uninstantiable classes
12:37:17 <Reaga> heh
12:37:18 <edwardk> they pay all the prices for fundeps then they don't bother to put them in
12:37:51 <edwardk> 9 out of 10 classes in that package can have no other instances than the instance it already has =(
12:37:58 <Jurily> how many preludes do we have at this point?
12:38:06 <edwardk> Jurily: one and a bunch of imposters ;)
12:38:06 <c_wraith> probably 10
12:38:09 <DanBurton> Jurily: plenty
12:38:47 <edwardk> the whole basic-prelude thing i can actually get behind. just exporting all the stuff in greater generality with Foldable, Traversable, etc.
12:38:50 <DanBurton> edwardk: well in fairness, those classes are meant to provide overloading for those particular libraries, and nothing more; it accomplishes this goal admirably
12:39:00 <edwardk> DanBurton: let me provide you with an example
12:39:30 <edwardk> class CanMap f i o where map :: (i -> o) -> f
12:39:32 <DanBurton> oh I'm definitely planning to work Foldable & Traversable into BasicPrelude
12:39:42 <DanBurton> maybe I should open a ticket now so I don't forget
12:39:48 <edwardk> The only instance: instance CanMapFunc ci co i o => CanMap (ci -> co) i o
12:39:56 <edwardk> lets just take this first class off the top of the file for a minute
12:40:06 <edwardk> that class is broken
12:40:18 <edwardk> it has 3 type parameters, and an instance that instantiates 2 of them universally
12:40:30 <edwardk> so no other instance can refine those parameters!
12:40:57 <edwardk> so at the _very_ least, that class should be class CanMap f i o | f -> i o where  -- because f had better determine i and o!
12:41:18 <edwardk> all of the classes in there except ~ 3 of them have this problem
12:41:29 <edwardk> they pay all the price for fundeps but get none of the benefits
12:41:46 <edwardk> you can see this at work when you look at CanMapFunc right below it
12:42:11 <edwardk> where because one of them instantiates it polymorphically on 3 arguments, all the others have to
12:42:27 <edwardk> so CanMapFunc dispatches entirely on its first argument.
12:42:33 <edwardk> this isn't the best signature it can have either
12:42:48 <edwardk> type inference doesn't flow through it at all right now.
12:43:20 <DanBurton> I'm sure Michael is eagerly awaiting your patch ;)
12:43:22 <edwardk> it should at least flow from ci -> i o co, because you're paying for it already by the shape of the instances
12:43:27 <nand`> how does ImpredicativeTypes compare to RankNTypes?
12:43:47 <nand`> maybe I'm misunderstanding but it seems to me the latter deprecates the former; or are they distinct?
12:43:52 <copumpkin> nand`: it's RankNTypes for every position but to the left and right of a (->)
12:44:04 <edwardk> i posted the issue in response to max cantor when he asked for substantive isues with the design, and then cantor and snoyman both decided that there were no issues with the design being raised and we just didn't like the smell of the API.
12:44:23 <edwardk> i don't like the API because it doesn't work. not because it does ad hoc overloading
12:44:35 <edwardk> it pays all the prices for fundeps then doesn't use them
12:44:41 <edwardk> its just badly written
12:45:18 <DanBurton> I don't disagree, but I still think it's at least a small step in the right direction as far as convenience and enhanced Preludes go
12:45:35 <DanBurton> badly written is better than not written
12:48:58 <edwardk> i'm not sure that i agree
12:49:19 <jfischoff> if no one uses a badly written prelude then there is no problem
12:49:20 <edwardk> i buy the basic-prelude effort. not sure i'd be willing to incur the extra dependency
12:49:40 <edwardk> but the major motivation behind me writing lens was putting these adhoc traversals in a formal light
12:51:13 <merijn> edwardk: I thught the main motivation was to allow the rest of us to be lazy buggers and not have to actually write code...
12:52:02 <roconnor> edwardk: which adhoc traversals?
12:52:28 <DanBurton> edwardk: on a different topic, is Control.Lens.Indexed related at all to Gabriel's indexed stuff in index-core?
12:53:07 <DanBurton> not that Gabriel owns those ideas or anything
12:54:02 <copumpkin> similar idea, on the value level
12:54:14 <copumpkin> but so is anything "indexed"
12:55:07 <edwardk> roconnor: http://hackage.haskell.org/packages/archive/classy-prelude/0.1.0.0/doc/html/ClassyPrelude-Classes.html#t:CanMapMFunc etc
12:55:44 <edwardk> DanBurton: nope, the indexed traversal comes from the notion of traverseWithKey, traverseWithIndex, etc. from other containers. i tried putting them in the same formalism but they don't fit
12:56:31 <edwardk> basically an indexed traversal  looks like (i -> c -> f d) -> a -> f b  -- which isn't obvious how to make it fit the pattern of (c -> f d) -> a -> f b  that the other traversals, etc. satisfy
12:56:46 <roconnor> edwardk: that was your major motiviation :(
12:56:55 <edwardk> roconnor: killing it dead. yes
12:57:13 <roconnor> all this time I thought I sold you on multilenses
12:57:16 <edwardk> roconnor: =)
12:57:28 <edwardk> roconnor: it was a gestalt of the two ;)
12:57:32 <roconnor> :D
12:57:45 <edwardk> i was mad about the lack of laws for multilenses and mad about the completely ad hoc nature of the classy prelude
12:57:58 <edwardk> so i sat down and started building them up from first principles
12:58:06 <roconnor> edwardk: I told you the laws for multilenses
12:58:16 <edwardk> you said a bunch of stuff about composing coalgebroids
12:58:19 <roconnor> edwardk: same as for lenses ... if you pick the right laws
12:58:27 <roconnor> edwardk: precisely
12:58:50 <edwardk> which is a pretty unmotivated way to think about them, and i don't think cover all of the essence of the iterator pattern traversable laws
12:59:28 <edwardk> i've yet to actually show that your laws and the laws i use are equivalent
12:59:39 <roconnor> edwardk: the laws in he essence of the iterator pattern traversable laws are equvalent to the coalgbroid laws and almost identially stated.
12:59:44 <edwardk> i know that my laws imply yours, not ure about the converse
12:59:46 <roconnor> *identically
13:00:51 <roconnor> Let's take a look shall we
13:00:54 <edwardk> roconnor: i'm not sure. some of those essence laws are pretty tricky and not stated at all algebraically
13:01:53 <roconnor> law 1)  Gibbons says that traverse (Id . f) = Id . (fmap f);  my law (1) says traverse Id = Id
13:02:02 <roconnor> clearly taking f = id implies my law
13:02:07 <edwardk> yep. laws 1 and 2 i buy
13:02:15 <roconnor> and the free theorem of my law implies his law 1
13:02:23 <roconnor> (I"m guessing ;P)
13:02:40 <edwardk> free theorems are remarkably weak for traversals compared to traversables
13:02:43 <edwardk> be careful
13:02:58 <roconnor> @free Data.Travarsable.traverse
13:02:59 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
13:03:04 <roconnor> :/
13:03:11 <roconnor> @type Data.Traversable.traverse
13:03:13 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:03:28 <edwardk> fmap (t f) . t g = getCompose . t (Compose . fmap f . g)
13:03:38 <edwardk> i'm willing to grant those 2, but those are gibbons' only laws
13:03:52 <edwardk> section 5.5 provides the no duplicate traversal rule
13:03:58 <edwardk> which is _not_ stated algebraically
13:04:09 <edwardk> er aren't gibbons' only laws
13:04:23 <edwardk> and i don't see how your coalgebroid rules imply that at all
13:05:12 <edwardk> that was when i decided to rephrase everything in terms of the iterator pattern laws
13:08:30 <JunkBee> Does Haskell work well for list parsing?
13:08:35 <edwardk> JunkBee: yes
13:08:57 <edwardk> for a while when it was first designed it excelled at little else ;)
13:09:02 <hpc> heh
13:09:28 <hpc> edwardk: back when it was called LISt Processing?
13:09:30 <JunkBee> edwardk: versus perl, the complexity of the Haskell code would be higher, but it would be shorter perhaps?
13:09:31 <hpc> :P
13:09:54 <monochrom> perl doesn't do list parsing
13:10:26 <roconnor> edwardk: Gibbon's funky traverse for lists appears to fail the traverse Identity = Identity law to me.
13:10:33 <monochrom> or at least, I am not convinced that it does
13:10:46 <Jurily> more complex, you say? http://www.ozonehouse.com/mark/periodic/
13:11:01 <roconnor> edwardk: what am I missing here?
13:11:03 <c_wraith> I'm not sure perl does anything except enable crazy code you can't understand or change later
13:11:04 <edwardk> JunkBee: i used to write my sub-100 line projects in perl, i still do for a few things that involve just raw text mangling, but otherwise i tend to default to haskell. for just aggressive text mangling? the perl will be a bit shorter, for everything else the edge tends to go to haskell with extra points for confidence
13:11:10 <JunkBee> monochrom: oh I ment literally parsing a list. Is there a difference between parsing a list in an imperitave language verse a functional?
13:11:25 <edwardk> roconnor: Identity works fine there, it'll give you back the original list.
13:11:45 <edwardk> it ignores the second value it got from traversing x twice
13:11:49 <hpc> c_wraith: if you are sufficiently evil with your regex flags, you can write parsers in lex/yacc style
13:11:50 <roconnor> edwardk: ah I see
13:11:52 <monochrom> I mean parsing a list, too. still unconvinced.
13:11:59 <roconnor> @unpl (const (:))
13:12:00 <lambdabot> (\ _ -> (:))
13:12:02 <hpc> it's actually quite nice, if you are used to the notation
13:12:03 <edwardk> but it can accumulate unwanted extra side-effects
13:12:29 <edwardk> those are pretty hard to rule out with an algebraically stated rule
13:13:44 <JunkBee> Are there many papers on list parsing, or tutorials?
13:14:30 <edwardk> > read "['h','e','l','l','o']" :: String
13:14:32 <lambdabot>   "hello"
13:14:37 <edwardk> look, parsing a list ;)
13:14:44 <Jurily> JunkBee: http://www.shlomifish.org/lecture/Perl/Haskell/slides/
13:15:00 <JunkBee> My lists are a little more compelx than that :(
13:15:26 <monochrom> show an example
13:15:33 <DanBurton> given a sufficiently smart read instance... you can do anything
13:16:11 <JunkBee> monochrom: walabee, koala, dog, spider, wolf, mouse ..
13:16:17 <nand`> > read "[[1,2],[3,4],[5,6]]" :: [[Int]]
13:16:18 <lambdabot>   [[1,2],[3,4],[5,6]]
13:16:31 <ParahSailin_> :t read
13:16:33 <lambdabot> forall a. (Read a) => String -> a
13:16:43 <JunkBee> I think I have 100,000 line list now
13:16:44 <b52> does anyone of you recently tried to install git-annex ?
13:16:46 <DanBurton> JunkBee: what are you supposed to parse that list into? a list of strings?
13:17:00 <JunkBee> A list of significant strings :)
13:17:04 <Jurily> :t unlines
13:17:05 <monochrom> using parsec, it's just: many1 letters `sepBy` string ", "
13:17:06 <lambdabot> [String] -> String
13:17:06 <nand`> splitBy ", " -- ?
13:18:20 <JunkBee> my perl script (40 lines?) can count the frequencies of each term being mentioned, but I am not sure about list parsing for significant data. Counting terms is easy, I was checking here if there could be help for more complex methods of parsing though.
13:18:42 <hpc> perhaps many1 letters `sepBy` (string "," >> whitespace)
13:18:48 <hpc> fsvo whitespace
13:18:55 <ParahSailin_> :t many1
13:18:57 <lambdabot> Not in scope: `many1'
13:19:09 <monochrom> look for simpler methods, not more complex methods
13:20:39 <monochrom> it should not need 40 lines in perl either
13:21:58 <jfischoff> @hoogle splitOn
13:22:01 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
13:22:01 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
13:22:15 <jfischoff> huh no Data.List.Split
13:22:38 <jfischoff> I guess the cool kids don't use strings anymore
13:22:56 <JoeyA> Is there a class with these methods?  class Enum' a where fromEnum' :: a -> Int; toEnum' :: Int -> Maybe a
13:23:30 <JoeyA> Like Enum, but where toEnum isn't a partial function, and there's no requirement for ranges.
13:24:10 <DanBurton> does parsec have some sort of regex plugin?
13:28:36 <johnw> DanBurton: you mean, for lexing?
13:35:51 <jfischoff> Has anyone used parsec on a stream of XML tags? Perhaps using this: http://hackage.haskell.org/package/xml-parsec ?
13:36:30 <DanBurton> johnw: yeah, some parser like (regexParser :: RegEx -> Parser String)
13:45:17 * hackagebot vector-algorithms 0.5.4.1 - Efficient algorithms for vector arrays (BryanOSullivan)
13:45:29 <srhb> In the argument that IO-type values are actually pure in the sense that the IO something is a "recipe" that is composable in a pure manner, does not every language with first class functions have the ability for pure IO, suddenly?
13:46:53 <roconnor> edwardk: I really hope the coalgebroid law disallows this duplicate element stuff
13:46:55 <roconnor> edwardk: BBL
13:47:16 <edwardk> i'm somewhat dubious to be honest
13:47:41 <nand`> note to self: don't trust edwardk
13:47:53 <Frank___> Hello
13:48:02 <srhb> Frank___: Hi :)
13:48:18 <Frank___> How are you?
13:48:21 <edwardk> nand`: heh
13:48:37 <edwardk> my packages are all marked trustworthy though, so you can trust them!
13:48:37 <srhb> Frank___: Fine thanks, what brings you to #haskell? :-)
13:48:45 <nand`> excellent
13:48:57 <Frank___> I need little help to solve a problem
13:49:01 <srhb> Although they may suddenly bump from 1.4.1 to 2.2 in a matter of days!
13:49:06 <srhb> Frank___: Shoot.
13:49:20 <Frank___> So
13:49:28 <MostAwesomeDude> srhb: Sure.
13:49:58 <Frank___> My final program should do like this      1 + [1,2,3] = [2,3,4]
13:50:12 <srhb> Frank___: That equals sign is dubious!
13:51:05 <srhb> > let foo x xs = x : take 2 xs in foo [2,3,4] -- Frank___
13:51:06 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [[t]])
13:51:07 <lambdabot>    arising from a ...
13:51:09 <Frank___> You can choose a number that  sum the other numbers or elements in the list
13:51:10 <srhb> oh dear
13:51:20 <srhb> Frank___: Oh
13:51:34 <kallisti> > map (+1) [1,2,3]
13:51:35 <Frank___> Understand what I mean srhb?
13:51:36 <lambdabot>   [2,3,4]
13:51:40 <nand`> instance Num a => Num [a] where fromInteger = repeat . fromInteger; (+) = zipWith (+) --- ?
13:51:48 <kallisti> nand`: ew ew ew
13:51:51 <srhb> Frank___: Not quite, but perhaps kallisti got it :-)
13:52:05 <Frank___> kallisti you are right!
13:52:06 <vaflis> > let f n l = map (+n) l in f 1 [1,2,3]
13:52:07 <lambdabot>   [2,3,4]
13:52:17 <nand`> oh, this was that simple of a question :(
13:52:25 <srhb> Apparently :P
13:52:27 <nand`> I thought you actually wanted to write “1 + [2,3,4]” and have it work
13:52:41 <vaflis> what's the point :D
13:52:42 <srhb> I thought he wanted to bump values off... I was confused.
13:53:05 <vaflis> your thoughts are so complex you no longer understand simple problems :D
13:53:19 <atriq> Is Ziplist a monad?
13:53:21 <srhb> I also misread the problem :P
13:53:23 <nand`> no
13:53:26 <Frank___> Sorry I am new in haskell and wanna learn it, so better you are not suprised about it ;)
13:53:37 <nand`> atriq: I think it can be, but it's entirely non-trivial; there's no default instance
13:53:45 <srhb> Frank___: No problem, the shortest definition of that function would be foo n = map (+n)
13:53:45 <atriq> Okay
13:53:50 <Frank___> But thanks very much!
13:54:16 <Frank___> Ahh ok srhb I make a note
13:54:23 <nand`> foo = map . (+)
13:54:24 <Jurily> @pl foo n = map (+n)
13:54:24 <lambdabot> foo = map . (+)
13:54:31 <srhb> nand`: Screw you :-)
13:55:18 * hackagebot text 0.11.2.3 - An efficient packed Unicode text type. (BryanOSullivan)
13:55:21 <srhb> s/shortest/shorter/ :(
13:56:43 <zhulikas> it would be nice to specify function definition, a set of input/output and let lambdabot figure out the code for it
13:57:07 <Frank___> srhb are you admin here?
13:57:10 <srhb> zhulikas: You can get fairly far with djinn for simple functions
13:57:17 <srhb> Frank___: No, no not at all, and I'm not a guru either :P
13:57:18 <kallisti> zhulikas: that's called a Map
13:57:19 <nand`> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
13:57:19 <lambdabot> f a b =
13:57:19 <lambdabot>     case a of
13:57:20 <lambdabot>     Nothing -> Nothing
13:57:20 <lambdabot>     Just c -> b c
13:57:31 <kallisti> or, well, a total map.
13:57:51 <Jurily> once you have the signature, most of the work is done
13:57:56 <Frank___> Ok so again thx for your help!
13:58:00 <zhulikas> hmm yea... it's kind of map... :|
13:58:11 <nand`> makeFun :: Default b => [(a,b)] -> a -> b
13:58:53 <nand`> makeFun xs a = case lookup a xs of Just b -> b; Nothing -> def
13:58:55 <srhb> I wonder if there are enough "how do I do x"-questions to warrant that functionality in lambdabot.
13:58:56 <srhb> :P
13:59:08 <srhb> We might even have a useful @faw!
13:59:12 <nand`> oh, would require Eq a too mind :(
13:59:12 <srhb>  @faq ~~
13:59:13 <kallisti> zhulikas: a total map is where every element of the key type is defined in the map. The lookup function doesn't need to have a Maybe result. It's the same thing as a function, mathematically.
14:01:09 <atriq> nand`, fromMaybe default . lookup ?
14:03:04 <nand`> faq xs = foldr (<|>) empty $ map (`ask` xs) [edwardk..]
14:03:19 <nand`> atriq: yes that looks better :)
14:03:23 <atriq> :)
14:03:49 <atriq> Well, goodnight
14:05:18 * hackagebot hashable 1.1.2.4 - A class for types that can be converted to a hash value (JohanTibell)
14:10:18 * hackagebot certificate 1.2.5 - Certificates and Key Reader/Writer (VincentHanquez)
14:12:11 <otters> > [1,2] + [3,4]
14:12:12 <lambdabot>   No instance for (GHC.Num.Num [t])
14:12:12 <lambdabot>    arising from a use of `e_11234' at <in...
14:12:16 <otters> well, there should be
14:12:43 <Athas> otters: what would it do?
14:12:54 <otters> well, I know what 1 + [2,3,4] would do
14:13:06 <Athas> That's not well-typed though.
14:13:15 <Jurily> > 1 + [2,3,4]
14:13:16 <lambdabot>   No instance for (GHC.Num.Num [t])
14:13:16 <lambdabot>    arising from a use of `e_11234' at <in...
14:13:17 <ParahSailin_> > zipWith (+) [1,2] [3,4]
14:13:18 <lambdabot>   [4,6]
14:13:32 <otters> well, I'd think it would be like [x + y | x <- xs, y <- ys}
14:13:36 <otters> s/}s]/
14:13:46 <otters> s/s/\//
14:14:16 <otters> and [1,2] + 3 is well-typed if you define a Num t => Num [t] instance like how I said
14:14:38 <otters> I assume because it's sugar for [1,2] + fromInteger 3
14:14:46 <otters> where fromInteger x = [fromInteger x]
14:14:48 <zhulikas> > [1] ++ [2,3,4]
14:14:51 <lambdabot>   [1,2,3,4]
14:15:09 <Twey> Couldn't you have an instance for *any* binary operation that way?
14:15:15 <otters> Probably
14:15:18 <Twey> Smells a lot like weak typing to me
14:15:29 <otters> \O_o/
14:15:39 <Twey> But then I never liked implicit typeclasses to start with :þ
14:15:47 <otters> Well who does
14:18:13 <nand`> profiling versions of libraries are installed in addition to the non-profiling copies, right?
14:18:36 <Jurily> nand`: in ghc, yes. In cabal, there's a setting for it, default off
14:19:02 <Jurily> -- library-profiling: False
14:19:03 <nand`> yeah I'm wondering if enabling profile mode globally will detract from my executables compiled with profiling off
14:19:22 <Jurily> -- executable-profiling: False
14:19:40 <Athas> nand`: it won't.
14:19:56 <Athas> If you enable library profiling, two different object files are generated per library.
14:20:01 <Athas> (Also, libraries are compiled twice.)
14:20:18 * hackagebot unordered-containers 0.2.2.0 - Efficient hashing-based container types (JohanTibell)
14:20:20 * hackagebot tls 0.9.9 - TLS/SSL protocol native implementation (Server and Client) (VincentHanquez)
14:25:18 * hackagebot hashable 1.1.2.5 - A class for types that can be converted to a hash value (JohanTibell)
14:29:39 <danil> Type errors in Happy parsers produce hilarious error messages.  This one involves type variables up to "t310".
14:33:16 <Reaga> hey
14:35:19 * hackagebot List 0.4.4 - List monad transformer and class (YairChuchem)
14:36:25 <jtza8> > reverse "level"
14:36:26 <lambdabot>   "level"
14:37:07 <byorgey> hi Reaga
14:37:17 <armlesshobo> >reverse "racecar"
14:37:23 <armlesshobo> > reverse "racecar"
14:37:25 <lambdabot>   "racecar"
14:38:02 <nand`> Is there a way to dump profiling data even in the case of nonstandard termination?
14:39:13 <nand`> maybe some signal I can send in order to make it terminate nicely
14:40:19 * hackagebot criterion 0.6.1.1 - Robust, reliable performance measurement and analysis (BryanOSullivan)
14:40:34 <Reaga> i have a query about html. why dont we just scrap it and let browsers execute haskell code
14:40:54 <Reaga> call it "haskell browser elite" and they web pages shown would rock. they'd be like full blown games and s tuff, no html limits
14:41:17 <jtza8> Reaga: Do you seriously want to designers to mess with Haskell?
14:41:48 <JunkBee> If I want to find significant pattern in k [String] lists, k being arbitrary value, are there techniques already made to do this?
14:41:51 --- mode: ChanServ set +o mauke
14:41:51 --- mode: mauke set +b $a:Reaga
14:41:56 <JunkBee> Or I make my own, all the strings are unkown weight.
14:41:57 --- mode: mauke set -b *!~Dantion@host81-141-142-107.wlms-broadband.com
14:43:57 --- mode: mauke set -o mauke
14:44:16 --- mode: ChanServ set +o mauke
14:44:16 --- mode: mauke set -bbbb strmpnk!*@*$##fix_your_connection *!null@ugh.thatss.smelly.cc$##fix_your_connection GoMittGo!*@* girl22!*@*
14:44:19 --- mode: mauke set -bb *PardoSandia*!*@* buddha!*@*
14:45:21 * hackagebot List 0.5.0 - List monad transformer and class (YairChuchem)
14:46:16 --- mode: mauke set -o mauke
14:52:15 <DanBurton> @google elm haskell
14:52:17 <lambdabot> http://hackage.haskell.org/package/Elm
14:52:17 <lambdabot> Title: HackageDB: Elm-0.3.6
14:52:48 <DanBurton> Reaga: what you describe sounds like Elm ^
14:53:22 <DanBurton> sadly there are subtle differences that make Elm be Not Haskell
14:53:30 <donri> see also fay, ghcjs
14:53:44 <donri> could make something like elm in those
14:54:06 <donri> but html limits are good for you, or rather, good for accessibility etc
14:55:15 <daniel_-> how do i catch a exception thats not in the IO monad?
14:55:53 <geekosaur> go through the IO monad.
14:55:54 <Jurily> daniel_-: you wait until it gets into the IO monad
14:55:59 <geekosaur> :t Control.Exception.evaluate
14:56:01 <lambdabot> forall a. a -> IO a
14:56:05 <daniel_-> oh
14:56:31 <daniel_-> i thought first about lifting it into IO but that seems stupid
14:56:44 <donri> if you really need to you can use the spoon package
14:57:04 <geekosaur> merely lifting won't work, evaluate exists specifically so you can catch an exception in pure code
14:57:09 <donri> although you lose the exact error details with spoon
14:57:17 <daniel_-> ok
14:57:58 <daniel_-> well its basicly this i want "decode . BL.fromChunks . (:[])" with it decoding to a specific datatype but it can obviously fail with "corrupted binary data for method"
14:58:52 <donri> and why can't you handle it in IO?
14:59:00 <daniel_-> no reason
14:59:57 <daniel_-> im just thinking since it will be used in a few places i guess ill write it as returning IO (Maybe DataType)
15:15:04 <Jacco> any wxHaskell users here?
15:16:41 <Peaker> My friend uploaded a new version of a package, and dependent broke because they imported-open and new names now collide! :(
15:16:49 <Cale> Jacco: I wrote a small wxHaskell app a long time ago
15:16:56 <Peaker> Haskellers should put safety before convenience and do qualified or closed imports...
15:17:11 <Peaker> Especially for code published on Hackage...
15:17:27 <Cale> Peaker: Qualified names look horrible
15:17:49 <Cale> Peaker: If the separator wasn't . then I'd use explicit qualification more often.
15:18:10 <Peaker> Cale, compiler errors triggered by innocent name adding look even worse, though :(
15:18:25 <Peaker> Cale, also, it's always possible to -ddump-minimal-imports and throw the .imports on top
15:18:37 <Cale> Easy fix: use the old method of naming things in probably-unique ways
15:18:49 <Cale> lookupFM ftw
15:20:13 <Peaker> It's pretty terrible to doubly-qualify stuff
15:20:17 <billFrank> @pl  let f x = 5 + 8 / x in f
15:20:18 <lambdabot> (5 +) . (8 /)
15:20:24 <Peaker> Reader.runReader <-- bah
15:20:33 <billFrank> @pl  let f x =
15:20:34 <lambdabot> (line 1, column 10):
15:20:34 <lambdabot> unexpected end of input
15:20:34 <lambdabot> expecting lambda abstraction or expression
15:20:46 <LadyAurora> Cale: yeah, dot is bad. Prelude.. or however that's spelled, anyone?
15:20:52 <LadyAurora> :t Prelude..
15:20:54 <lambdabot> parse error on input `Prelude..'
15:20:54 <Cale> Peaker: yeah, but you don't have to doubly qualify stuff :)
15:21:05 <LadyAurora> :t Prelude.(.)
15:21:05 <billFrank> @pl  let mf c o l = filter c (map o l) in mf
15:21:06 <lambdabot> (. map) . (.) . filter
15:21:06 <lambdabot> Not in scope: data constructor `Prelude'
15:21:11 <Peaker> Cale, you might open-import and risk collisions unless everyone puts the entire namespace/module into every name
15:21:19 <Cale> Peaker: Just import unqualified and use names that are nicely separate because they were designed not to trample on each other :)
15:21:30 <mauke> every type should be called T
15:21:41 <Jacco> Cale, ok, I'm trying to make a simple application in wxHaskell (Windows 7, wxhaskell 0.90)), but building takes a minute or maybe more. Would that be normal?
15:21:50 <LadyAurora> Except these called U.
15:21:52 <Peaker> Cale, The scheme is fallible (unlike qualified names) and trusts the authors of all the dependencies to name stuff accordingly, and means qualification becomes ugly/discouraged
15:22:19 <Peaker> Cale, as long as module qualification is part of Haskell, it's a bit silly to qualify modules in every exported name
15:23:15 <Peaker> Cale, If you import stuff the slightly-unaesthetic way -- it won't ever break by new names being added or innocuous changes
15:23:52 <Cale> Peaker: Well, sure.
15:24:10 <Cale> But I'd rather write pretty code that I might have to adjust later than ugly code.
15:24:32 <Peaker> Cale, the problem is now any library you use can be broken by its uploader -- making it a burden for him
15:24:47 <Peaker> Cale, my friend now has to spend his time worrying about breakage in a user module because they imported unqualified
15:24:59 <jmcarthur> i wish we had the ability to rename things upon import
15:25:12 <jmcarthur> the best i can do is import qualified and then bind a new name for it
15:25:27 <jmcarthur> at which point i might as well just use the qualified name
15:25:57 <LadyAurora> Peaker: teach your friend how to use WONTFIX.
15:26:12 <LadyAurora> Ditto for NOTABUG.
15:26:24 <lamefun> hi
15:27:13 <Peaker> jmcarthur, Using qualified names is great if the names aren't doubly qualified
15:27:34 <Peaker> (.) is always called with spaces around it, so there's "f . g" and "F.g" -- pretty distinguished IMO
15:29:11 <ion> > (succ.pred) 42
15:29:13 <lambdabot>   42
15:30:39 <Cale> Peaker: He doesn't have to worry, the user does.
15:31:09 <Cale> If it's really important, depend on a specific version of the library, and problem solved ;)
15:32:13 <Cale> (though maybe not really, because of the situation we have where it's impossible to install more than one copy of the same library/version combination, but that's another thing)
15:33:04 <JoeHazzers> is anyone here familiar with TagSoup? i'm trying to get all of the a tags that are children of a certain class of div tag, of which there are several
15:33:48 <Peaker> Cale, if everyone just put safety over convenience (Much of the spirit of Haskell, IMO) it would be great
15:34:21 <Okasu> Cale: do you know how to fix Seen module in lambdabot?
15:34:55 <Okasu> Cale: now it's porducing "Main: caught (and ignoring) too few bytes. Failed reading at byte position 8" error
15:36:21 <Cale> Okasu: Nope, I just disabled it
15:37:07 <Cale> Okasu: You can't just delete the seen database, you have to re-copy a fresh one over, it seemed, and this was becoming too annoying.
15:37:38 <Cale> Peaker: I don't think Haskell is designed to make that nice to do in this case.
15:37:58 <Okasu> Cale: thanks for info
15:40:34 <Peaker> Cale, it's really a matter of slight aesthetics.. unspaced-dot=qualification, spaced-dot=composition.. I use it all the time and don't find it so bad
15:42:35 <LadyAurora> It's a non-issue, you can't use modules for much more than name qualification. Haskell's not Python.
15:42:58 <Saizan> JoeHazzers: partitions is in the right direction, though "children" implies being able to match closing tags and that's not straightforward
15:43:05 <startling> we just need to come up with a system wherein module qualification is the same as function composition
15:43:17 <startling> easy
15:43:41 <Saizan> JoeHazzers: you can use the TagTree utils though
15:46:59 <Peaker> LadyAurora, Python did a good thing by making unqualified open import be ugly
15:47:02 <Peaker> That's tasteful
15:47:15 <Peaker> and make qualified/closed import be pretty
15:47:25 <Peaker> open unqualified is conceptually ugly, and Haskell makes *that* case pretty :(
15:48:30 <Cale> While I can see the logic of the argument that qualified imports are more stable, I also just really liked how things were in the old days and people all designed libraries carefully not to step on each other's toes.
15:48:42 <Cale> Back before hierarchical modules
15:48:46 <MostAwesomeDude> As Pythonistas say, "We're all adults here."
15:49:26 <JoeHazzers> Saizan: yeah, what i want to search for is something along the lines of <div class=x><a href=y></div>
15:49:31 <Cale> when you could just import a bunch of things, and use them without having to fiddle around with importing every module twice and such
15:49:34 <JoeHazzers> Saizan: so all i really want is that href
15:49:37 <JoeHazzers> closed, of course
15:50:08 <Jacco> Cale, compiling a very small wxhaskell application takes about a minute with GHC on my Win7, is that normal?
15:50:17 <Cale> Obviously, I'm just going to completely write off the idea of using qualified infix operators from the start. I also despise having to qualify anything in types -- maybe that's irrational.
15:50:24 <Cale> Jacco: no idea
15:50:50 <Jacco> Cale, ok thanks, it seems odd though
15:50:52 <Cale> Jacco: That depends on your CPU, and also I use Linux
15:50:58 <Cale> So, I don't know.
15:53:12 <LadyAurora> Peaker: I know, my point was that in Python modules are first-class citizens, that's not the case in Haskell; thus Foo.func is quite unambiguous.
15:53:17 <JoeHazzers> Saizan: wow, thanks for that pointer
15:56:12 <Saizan> JoeHazzers: np
16:08:01 <Mandarin> Is there a test pacakge that can test if pattern match can match all kinds of input?
16:08:51 <Mandarin> Imagine if you've got two functions: f ( g x ) so that g x can return a value which f can't match
16:09:19 <nand`> GHC should warn you if you have incomplete patterns
16:09:58 <Mandarin> Yeah but I think that's only if you run the code and it can't match?
16:10:24 <startling> yeah, it's a run-time error
16:10:54 <nand`> uhm
16:10:57 <nand`> -fwarn-incomplete-patterns
16:11:00 <nand`> should be at compile time
16:11:04 <jfischoff> listen to nand`
16:11:16 <nand`> (isn't that on by default?)
16:11:49 <jfischoff> nand`: I think overlapping is but not that one
16:12:00 <jfischoff> nand`: not positive though..
16:12:19 <osa1> what is evalState equivalent for Maybe monad?
16:12:42 <Mandarin> It isn't included in -Wall at least
16:12:46 <geekosaur> :t maybe
16:12:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:13:00 <Mandarin> Sorry it is, my bad
16:13:04 <mm_freak> Mandarin: compile your code with -W
16:13:16 <ion> @type fromMaybe  -- as well
16:13:17 <lambdabot> forall a. a -> Maybe a -> a
16:13:17 <Mandarin> mm_freak: yeah, I read the wrong line ^^
16:13:23 <mm_freak> Mandarin: that gives you a warning about incomplete patterns as well as some other useful things
16:13:23 <osa1> thanks
16:13:38 <geekosaur> Maybe doesn't really have a runState/evalState/execState type setup; it's too simple.
16:13:41 <ion> That doesn’t really have anything to do with the monad instance, though.
16:13:42 <mm_freak> -Wall is very pedantic…  mostly it just goes on my nerves, but -W is very reasonable
16:13:43 <Mandarin> mm_freak: Do you use Werror?
16:13:48 <mm_freak> Mandarin: nope
16:14:00 <mm_freak> Mandarin: i manually make sure that no warnings remain, when i release a package
16:14:01 <Mandarin> mm_freak: Any reason why not?
16:14:22 <mm_freak> Mandarin: because sometimes i just want to leave it the way it is, do something else first and then return to the offensive code
16:14:30 <mm_freak> -Werror forces me to fixate on that code
16:14:58 <janua1> I am trying to use lift in the IO monad to add a string to the result of getLine and then output it to putStrLn. I am not sure how to do this; Currently i have: putStrLn $ "String was: " ++ `liftM` getLine
16:15:33 <mm_freak> janua1: liftM (++ "blah") getLine >>= putStrLn
16:15:38 <nand`> I run something like -Wall -fno-warn-name-shadowing -fno-warn-orphans -fno-warn-type-defaults -fno-warn-unused-do-bind
16:15:43 <mauke> mm_freak: at that point, why liftM?
16:15:54 <Mandarin> mm_freak: Do you have anyother nice compiler flags? I use -O2 -Wall
16:15:55 <mm_freak> janua1: or alternatively:  getLine >>= putStrLn . (++ "blah")
16:15:55 <ion> do l <- getLine; putStrLn ("The string was: " ++ l)
16:15:57 <mauke> getLine >>= putStrLn . ("blah" ++)
16:16:25 <mm_freak> mauke: because i wanted to answer the actual question
16:16:42 <Mandarin> nand`: -fno-warn-name-shadowing is in -Wall :)
16:16:43 <janua1> mm_freak mauke: Thanks! I will have a look and try to understand it
16:16:51 <mauke> oh, the actual question?
16:16:57 <ion> People rarely benefit from an answer to their actual question. :-P
16:17:01 <nand`> Mandarin: since when? I disabled it manually because with just -Wall I got tons of them
16:17:01 <mauke> join $ liftM (putStrLn . ("blah" ++)) getLine
16:17:02 <mm_freak> Mandarin: for libraries i use only -W (cabal takes care of adding optimization)
16:17:14 <mm_freak> Mandarin: for executables i always compile with -threaded and almost always with -rtsopts
16:17:26 <mm_freak> Mandarin: beware of the security implications of -rtsopts though
16:17:39 <Mandarin> nand`: I'm sorry I didn't think that it said -fno. Gotta go to bed soon
16:17:40 <mm_freak> don't use that option for SUID executables
16:17:42 <nand`> “-Wall  enable almost all warnings (details in )”
16:17:43 <nand`> uh huh
16:18:10 <osa1> so how can I refactor this 5 lines of code with maybe monad to remove duplicate Nothing part? http://hpaste.org/73256
16:18:32 <mm_freak> janua1: anyway, look at the type of liftM…  more generally:  whenever you want to know how to do something, look at the types
16:18:35 <mm_freak> :t liftM
16:18:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:18:41 <nand`> fromJust $ M.lookup name env >>= (`M.lookup` store)
16:18:50 <nand`> something like that at any rate
16:18:58 <mm_freak> nand`: that's a type error
16:19:08 <mm_freak> oh no, it isn't
16:21:20 <mm_freak> janua1: note that IO is also a Functor…  fmap is usually nicer to use, because you don't need an import, and it's more aesthetically pleasing in source code =)
16:21:23 <ion> osa1: You’re not using the monad at all. But you could use the monad like nand said. Except that do *not* use fromJust.
16:21:30 <mm_freak> fmap (++ "blah") getLine
16:21:59 <nand`> ion: that's what he asked, how to use the monad to improve it
16:22:01 <sentientwaffle> how would I refactor this code to use Control.Applicative instead of "do" notation? http://hpaste.org/73257
16:23:02 <janua1> mm_freak: One step at a time *gasps for air*
16:23:09 <dibblego> sentientwaffle: it's not really a good case for Applicative, because you need (>>=)
16:23:15 <hpaste> donri annotated “refactor -> control.applicative” with “refactor -> control.applicative (annotation)” at http://hpaste.org/73257#a73258
16:23:17 <nand`> sentientwaffle: I don't think you can
16:23:24 <mm_freak> sentientwaffle: you can't get rid of the monadic stuff there…  you need a Kleisli category to do it, which will be much uglier than your current code
16:23:43 <startling> sentientwaffle: diamond <$> square plane size rfact <*> pure pl <*> pure size <*> pure rfact
16:23:46 <mm_freak> sentientwaffle: i think the code isn't that bad
16:23:50 <startling> ^^ what's wrong with that?
16:24:02 <roconnor> edwardk: I proved that Jeremy and Bruno's duplicate traversal instance fails the coalgebroid compostion law.  I will email you the counterexample shortly.
16:24:02 <startling> errr, get rid of <*> pure pl
16:24:06 <mm_freak> startling: only that it probably doesn't have the type sentientwaffle wants =)
16:24:07 <ion> nand: Except that fromJust makes it worse: his original code has a specific error message upon bottom, fromJust has a generic one without any further information. Pattern matching will at least give a line number.
16:24:07 <Peaker> sentientwaffle, Applicative is applicable when you want to lift pure functions to work with multiple applicative-wrapped values
16:24:19 <mm_freak> startling: you need an additional 'join' and hence are back to monads =)
16:24:20 <sentientwaffle> thanks everyon! i was trying to understand control.applicative better, I assumed i was missing something
16:24:21 <edwardk> roconnor: good =)
16:24:33 <Peaker> sentientwaffle, functions like:  a -> IO b   generally require monadic composition if "a" depends on previous output
16:24:35 <startling> mm_freak: oh, right
16:24:42 <sentientwaffle> Peaker: so it doesnt work b/c I'm not dealing with a pure function?
16:24:43 <nand`> ion: yeah, I'd tend to agree. I figured he would actually need something like ‘maybe’ for his particular use case
16:24:43 <osa1> ion: I'm not using monad because I'm using a state monad in that code. is there a way to use monad without a do block?
16:24:51 <donri> oh yea join (diamond' <$> ...) but better use monad
16:25:23 <Peaker> sentientwaffle, yeah, though if you had a function like:  IO (a -> b) that's usable with Applicative too.. because the IO effect does not depend on the "a".  (a -> IO b) is not very useful in applicative style
16:25:37 <mm_freak> osa1: of course…  a do-block translates into applications of (>>=)
16:25:41 <ion> osa1: Err. “do” is just syntactic sugar for (>>=)s among other things.
16:25:58 <Peaker> sentientwaffle, if your function (a -> b -> c -> ...) is pure, applicative style is basically to lift it to become (f a -> f b -> f c -> ...)
16:26:02 <mm_freak> :t getLine >>= putStrLn
16:26:04 <lambdabot> IO ()
16:26:11 <mm_freak> :t do x <- getLine; putStrLn x
16:26:13 <lambdabot> IO ()
16:26:20 <sentientwaffle> mm_freak, ion: I know that, but when it the variable needed isnt the last argument you need "do" notation
16:27:37 <donri> sentientwaffle: or lambda
16:27:53 <donri> or lots of flip'in ;)
16:28:36 <janua1> mm_freak: About the functor example you gave, what if i only wanted to take in one line? Isn't fmap going to iterate all that is available?
16:29:03 <mm_freak> janua1: no, 'fmap' maps a function over a monadic value
16:29:06 <sentientwaffle> donri: thanks, didnt know about "flip"
16:29:08 <mm_freak> getLine :: IO String
16:29:24 <mm_freak> it modifies the result of getLine
16:29:33 <mm_freak> for monads it's the same as liftM
16:29:42 <mm_freak> just with a more sensible name =)
16:30:11 <janua1> mm_freak: Ok i see what you are saying. But how do i put this into putStrLn?
16:30:29 <roconnor> edwardk: email'd
16:30:33 <edwardk> kk
16:30:36 <janua1> I am looking at fmap signature, trying to figure out a way
16:32:01 <Okasu> Cale: how can i enable logging?
16:32:08 <mm_freak> janua1: you don't
16:32:23 <mm_freak> fmap modifies results
16:32:29 <mauke> janua1: you put putStrLn into it
16:32:34 <mm_freak> so you modify the result of getLine and then pass it to putStrLn
16:32:49 <Cale> Okasu: Logging of what?
16:33:00 <edwardk> roconnor: good, then i can replace that ambiguous third statement with the coalgebroid law
16:33:10 <mm_freak> janua1: for monads the following identity holds:  fmap f c >>= d = c >>= d . f
16:33:15 <mm_freak> same for liftM
16:33:32 <Okasu> Cale: if irc channel of which lambdabot resides
16:33:39 <Okasu> s/if/of/
16:33:44 <roconnor> edwardk: category theory:1  functional programming researchers: 0
16:33:45 <mm_freak> fmap f getLine >>= putStrLn = getLine >>= putStrLn . f
16:33:53 <roconnor> for those keeping score
16:34:05 <Okasu> s/of/on/
16:34:08 <Okasu> ohh
16:34:27 <edwardk> roconnor: never heard a category theorist talk about coalgebroids ;)
16:34:44 <acowley> You guys are making that word up just to mess with us.
16:34:54 <edwardk> otoh who am i to talk, i ramble on about semigroupoids all the time
16:35:01 <Saizan> which are the coalgebroids laws?
16:35:02 <MostAwesomeDude> Semialgebraic comanifold topologies~
16:35:03 <janua1> mm_freak: Trying to understand!
16:35:04 <roconnor> edwardk: that because category theoriest only think of one object categories ...
16:35:06 <roconnor> ?
16:35:31 <edwardk> Saizan: they are roconnor's version of the multilens laws
16:35:36 <roconnor> edwardk: I don't know if anyone talks about coalgebroids.  I've seen a little bit on algebroids and just stuck a co in front of it.
16:35:50 <janua1> mm_freak: I dont understand the middle part of that, putStrLn = getLine
16:35:50 <roconnor> edwardk: Saizan: travesal laws
16:35:55 <Peaker> maybe easier:  putStrLn =<< fmap f getLine  =  putStrLn . f =<< getLine
16:36:05 <mm_freak> janua1: there is only one equals sign there
16:36:18 <edwardk> do you have your multilens laws listed somewhere?
16:36:24 <mm_freak> the whole left of it is equal to the whole right of it
16:36:35 <roconnor> edwardk: http://hackage.haskell.org/packages/archive/lens-family-core/0.1.0/doc/html/Lens-Family-Unchecked.html
16:36:51 <janua1> mm_freak: I see what you are saying now, let me play a bit!
16:36:57 <roconnor> edwardk: expect there is a supurious === id there that should be ignored
16:37:08 <edwardk> yeah
16:37:09 <edwardk> k
16:37:39 <edwardk> ah the second iterator law
16:37:44 <roconnor> edwardk: you can inline composeCoalgebroid which is what Jermey and Burno did in their paper
16:37:46 <edwardk> so no need for the third condition
16:37:50 <edwardk> yep
16:37:53 <roconnor> of course not :D
16:37:53 <edwardk> perfect!
16:38:23 <roconnor> the third condition was vague anyways
16:38:27 <edwardk> yep
16:38:30 <edwardk> i hated it
16:38:38 <edwardk> knowing it can't hold is great
16:39:24 <roconnor> edwardk: I was about to hand evaluate the counterexample; then I realized I could get ghc to execute it for me.
16:39:27 <roconnor> fewer errors this way
16:39:34 <edwardk> i'll stick to just calling it 'sequential composition' like gibbons does though ;)
16:39:51 <roconnor> edwardk: coalgebroids are warm and fuzzy too
16:39:55 <roconnor> :(
16:39:55 <Okasu> Cale: http://users.ece.cmu.edu/~allbery/lambdabot/logs/openafs/ for example like this, Log.hs states it should create log dig with txt files(with actually logs) in it
16:40:02 <edwardk> heh
16:40:09 <edwardk> warm fuzzy composition then
16:40:27 <Saizan> so they thought they had a bad example that still satisfied the first two laws but it actually didn't?
16:40:33 <edwardk> Saizan: exactly
16:40:45 <edwardk> roconnor disproved their wonky example
16:41:17 <edwardk> but after Lens.Family2 we've revoked his naming rights ;)
16:41:56 <Saizan> this must be punishment for the time gibbons said logicians don't understand math proofs are a social thing
16:42:04 <roconnor> I'm pretty bad at making names
16:42:21 <edwardk> roconnor: to be fair its just that i take all the good ones ;)
16:42:38 <roconnor> Saizan: technically gibbons didn't say thet their example satifiesd the second law. ... they didn't talk about the second law at all for some reason.
16:42:49 <roconnor> edwardk: you can have %%~
16:42:57 <roconnor> :D
16:42:58 <edwardk> roconnor: wasnt that one yours?
16:43:02 <roconnor> nope
16:43:05 <roconnor> it is from Data.Lens
16:43:09 <roconnor> back when you made it
16:43:09 <edwardk> oh
16:43:21 <roconnor> maybe you got it from somewhere else?
16:43:26 <edwardk> i think i did
16:43:34 <roconnor> ah, so you are not to blame
16:43:42 <Enigmagic> i snuck it in along with <<>~~~
16:43:42 <edwardk> thats what i get for going for compatibility
16:43:45 <dibblego> sentientwaffle: next time you have a do-expression and the values on the left of <- are never used on the right of -> then bring it, because it is likely a case for Applicative
16:45:17 <edwardk> btw did you notice because of the precedence of ^. you can section accessor chains? (^._1._2)
16:45:37 <roconnor> you mean at level 8
16:45:41 <roconnor> I think I was aware of this
16:45:43 <edwardk> yeah
16:46:02 <roconnor> I advocated sections as a way of converting to projection functions.
16:46:09 <nand`> dibblego: what about do { a <- foo; b <- bar; c <- bat; return (f a b c) } -- ? looks like a pretty compelling example of Applicative to me
16:46:15 <nand`> namely f <$> foo <*> bar <*> bat
16:46:33 <dibblego> nand`: sure, that meets the criteria
16:48:16 <nand`> then I don't understand what you were saying whatsoever
16:48:31 <edwardk> roconnor: so can i use a cartesian store to characterize a traversal like we do with clone for a lens?
16:48:53 <dibblego> nand`: a, b and c are not used to the right of <-
16:48:55 <roconnor> yes, though I'm thinking of renaming it kleene store
16:49:04 <edwardk> thats fine ;)
16:49:15 <edwardk> feel like banging out a clone traversal test?
16:49:34 <edwardk> that would let me work on upgrading zoom to support traversals
16:49:37 <nand`> dibblego: oh, you said ‘to the right of ->’, I thought you were meaning as in the lambdas >>= \x -> ...
16:50:04 <edwardk> kleene store is pretty nice
16:50:09 <nand`> dibblego: but what about do { a <- b; a } ?
16:50:21 <nand`> surely that implements ‘join’ which is outside Applicative
16:50:35 <acowley> I have a remarkable number of files named Camera.hs. The emacs default of <2>, <3>, etc. suffixes doesn't scale in a very friendly way.
16:50:35 <roconnor> edwardk: I don't quite know how to make it indexed
16:50:40 <roconnor> edwardk: well I haven't thought about it
16:50:52 <edwardk> roconnor: hence why i'm poking at you ;)
16:51:06 <roconnor> edwardk: I'm happy to do it; very slowly though
16:51:31 <mekeor> is there a fast and lightweight module for rendering markdown into html? or is pandoc fast enough to be called each time someone accesses a page on a/my blog?
16:51:56 <dibblego> oh yeah sorry I mean <-
16:52:05 <edwardk> lets try: data KleeneStore b d a = Unit a | Battery (KleeneStore b (d -> a)) b  -- is probably the indexed form
16:52:24 <roconnor> seems likely
16:52:41 <ddarius> mekeor: You could just cache the result.
16:53:00 <edwardk> then (c -> KleeneStore c d a) -> a -> KleeneStore c d b -- would be our desired characterized traversal
16:53:01 <dibblego> nand`: yeah, it's not a hard-fast rule — I could modify it to require a use of return
16:53:11 <mekeor> ddarius: you mean, saving the result in a file or so?
16:53:15 <nand`> then I'd probably agree with it :)
16:53:21 <roconnor>  (c -> KleeneStore c d d) -> a -> KleeneStore c d b
16:53:24 <nand`> I think there's another thing that escapes Applicative though
16:53:43 <nand`> do { a <- b; return (f a a) } -- not f <$> b <*> b
16:53:54 <edwardk> yes
16:53:56 <ddarius> mekeor: It doesn't have to be a file, but that's an option as well that would reduce the problem to just pretranslating the results and then serving them.
16:53:57 <nand`> oh
16:54:00 <nand`> join f <$> b -- should work
16:54:01 <edwardk> also i screwed up the indexed form
16:54:09 <edwardk> the (b -> a) went wonky
16:54:20 <nand`> yeah nvm, any permutations on the right hand side of ‘return’ can be made into a function
16:54:36 <edwardk> data KleeneStore c d a  = Unit a  | Battery (KleeneStore c d (d -> a)) c  --?
16:54:37 <mekeor> ddarius: yup. i actually had this concept in mind but i wondered whether pandoc as-is is fast enough already.
16:54:46 <ddarius> mekeor: Maybe.  Try it.
16:54:58 <roconnor> edwardk: sounds better
16:55:04 <mekeor> ddarius: ok :)
16:55:50 <edwardk> nowyou wanted to flip the Applicative to traverse over the left hand side instead?
16:56:38 <roconnor> ya, twan's first applicative instance @ http://twanvl.nl/blog/haskell/non-regular1 was correct, with all the flip nonsense
16:57:55 <roconnor> edwardk: it's really hard to tell when making an applicative instance which way is forward and which way is backwards;  IIRC the version with flip was lazier.
16:58:08 <edwardk> *nods*
16:58:12 <roconnor> edwardk: and supports infinite dimensional klenne stores
16:58:21 <roconnor> thus must be the correct direction
17:02:30 <edwardk> the indexed kleene store typechecks. as you'd expect. indexed comonads wind up unindexed as monads/applicatives and vice versa so the applicative structure remains intact
17:02:48 <edwardk> not sure i like the name, but i'll let it slide for now ;)
17:03:14 <roconnor> edwardk: it's an improvement on "StaredStore"
17:03:21 <edwardk> heh
17:04:01 <roconnor> edwardk: did you/can you add the comonad instances?
17:04:08 <edwardk> can't its indexed
17:04:11 <roconnor> right
17:04:13 <edwardk> i don't have indexed comonads
17:04:23 <roconnor> no worries
17:04:23 <edwardk> and i don't need them for the traversal plumbing
17:04:33 <roconnor> nope
17:06:31 <edwardk> working in the indexed comonad operations for completeness
17:06:34 <edwardk> ;)
17:08:46 <Peaker> Is the generalized "sequenceA . fmap" an idiom? Maybe a generalized mapM?
17:08:50 <Peaker> @hoogle mapM
17:08:51 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:08:51 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:08:51 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
17:08:59 <edwardk> extract = unkleene =P
17:09:22 <c_wraith> who are you calling unclean?
17:11:26 <edwardk> @hpaste
17:11:27 <lambdabot> Haskell pastebin: http://hpaste.org/
17:11:52 <hpaste> edwardk pasted “indexed kleene store” at http://hpaste.org/73261
17:12:00 <edwardk> roconnor: ^
17:14:54 <ragusa> Is a Kleene store a shop where you can buy Kleene stars?
17:15:33 <edwardk> ragusa: yep
17:15:45 <MostAwesomeDude> How many can you buy at a time?
17:16:18 <c_wraith> *
17:17:53 <edwardk> \** -- you take them greedily until they run out of stars
17:30:23 <edwardk> roconnor: got it almost right, the reified traversal now runs backwards
17:30:26 * hackagebot hpygments 0.1.1 - Highlight source code using Pygments (DavidLazar)
17:30:28 * hackagebot Pup-Events-Client 1.1.4 - A networked event handling framework for hooking  into other programs. (DanielWilson)
17:32:29 <edwardk> @hpaste
17:32:30 <lambdabot> Haskell pastebin: http://hpaste.org/
17:32:40 <hpaste> edwardk pasted “edwardk” at http://hpaste.org/73262
17:33:12 <edwardk> roconnor: that version works for cloning a traversal from a monomorphic instantiation to kleene
17:34:32 <edwardk> not sure why i can't get it to flip around without the backwards. i should be able to run the effects in the other order
17:35:12 <edwardk> got it without backwards
17:35:52 <rdesfo> no
17:36:11 <hpaste> edwardk annotated “edwardk” with “kleener traversals” at http://hpaste.org/73262#a73263
17:36:22 <hpaste> KGZM pasted “IO Monad Woes” at http://hpaste.org/73264
17:36:39 <kgzm> I'm not sure if anyone can help me with this but..
17:36:48 <edwardk> thats the version that'll go in lens i think
17:37:20 <kgzm> I'd really appreciate it if someone would take a look I'm not sure where I've gone wrong or how to formulate the question.
17:37:44 <kgzm> I'd even appreciate being told how to formulate the question.
17:38:55 <Athas> kgzm: try changing the right-hand side of the first clause of build to 'return ps'.
17:41:07 <kgzm> Hrm that made it compile but the result is unexpected. Do I also need a return in the recursive case?
17:45:10 <edwardk> roconnor: committed
17:46:09 <Veinor> kgzm: how is it unexpected?
17:46:15 <c_wraith> kgzm: if it compiled, adding a return will make it not compile.  (look at what return does)
17:49:20 <kgzm> Ah. My test was screwed up. It seems to work now. Wow. I drove myself crazy trying to make that work. Thanks.
17:50:08 <shachaf> > id id 5
17:50:10 <lambdabot>   5
17:50:10 <shachaf> > return id id 5
17:50:11 <lambdabot>   5
17:51:38 <kennyp> ['a','b']
17:51:39 * mekeor just learned about -XRecordWildCards
18:03:36 <ddarius> > let (:) { .. } = [1] in 3
18:03:38 <lambdabot>   Illegal `..' in record pattern
18:03:38 <lambdabot>  Use -XRecordWildCards to permit this
18:06:26 <roconnor> edwardk: kleene f (More k c) = kleene f k <**> f c
18:06:41 <edwardk> roconnor: yeah got that one
18:06:42 <roconnor> edwardk: I know it is all very weird
18:06:49 <roconnor> but it appears to be correct
18:07:02 <roconnor> some here said they had seen this sort of use of <**> before
18:07:17 <roconnor> oh right kleene f (More k c) = f c <**> kleene f k
18:07:21 <roconnor> I see now
18:08:12 <edwardk> i now have a separate 'zooms' combinator worked most of the way through the Zoom typeclass
18:08:16 <edwardk> have almost all the instances done
18:08:22 <Twey> ddarius: What does that do?  o.@
18:08:44 <edwardk> missing State, RWS, and Cont so far
18:08:57 <edwardk> er rather just RWS and Cont i think
18:09:04 <roconnor> edwardk: I don't quite understand what you use cloning for
18:09:32 <edwardk> i could make them take an explicit Traversal i suppose
18:09:49 <edwardk> class (MonadState s m, MonadState t n) => Zoom m n s t | m -> s, n -> t, m t -> n, n s -> m where  zooms :: Monoid c => SimpleLensLike (Kleene s s) t s -> m c -> n c
18:10:00 <roconnor> O_o
18:10:10 <edwardk> obvious, no? =)
18:10:30 <roconnor> I'm pretty sure Kleene is much worse than KleeneStore :D
18:10:39 <edwardk> name wise?
18:10:46 <roconnor> ya
18:10:58 <edwardk> its buried in Control.Lens.Internal and not exported by default
18:11:03 <roconnor> ah
18:11:10 <roconnor> I guess that isn't so bad then
18:11:31 <edwardk> i have a lot of short named 'needed for one off purposes' style monoids, etc. in there
18:11:40 <edwardk> Min, Mon, Max, etc.
18:13:17 <edwardk> i think i can get rid of the use of an explicit indexed kleene store there, i was hoping that by switching to it i could turn things around so that the monoid was only demanded of actual traversals
18:13:23 <edwardk> and then i could collapse zoom into zooms
18:13:40 <edwardk> but that doesn't appear to be the case
18:13:48 <roconnor> ah
18:14:22 <edwardk> i don't like having the separate combinators where everywhere else they all just magically work
18:15:27 <edwardk> its galling to me that i can focus, but i can't do nested focuses. etc.
18:18:12 <edwardk> hrmm, maybe i can fix it another way
18:18:18 <edwardk> trying something
18:20:07 <roconnor> edwardk: your arrows in your UML diagram are imperfectly aligned.
18:20:28 <edwardk> roconnor: github.com/ekmett/lens/wiki  -- click on the image, it is editable online
18:20:32 <nand`> call the cops
18:20:40 <roconnor> edwardk: people who liked UML also liked diagrams
18:20:45 <roconnor> @hackage diagrams
18:20:45 <lambdabot> http://hackage.haskell.org/package/diagrams
18:20:50 <edwardk> =P
18:21:51 <roconnor> github needs automatic haddock
18:22:07 <nand`> yes
18:22:27 <roconnor> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Traversal.hs appears to still have law 3
18:23:23 <otters> there needs to be an rdoc.info for haskell
18:24:07 <edwardk> roconnor: yep. haven't hacked it out yet
18:24:18 <roconnor> ok
18:24:36 <edwardk> my focus for now has been getting zoom to work with traversals and magnify to accept folds
18:24:54 <edwardk> then i can kill the focus special case
18:25:24 <n00b6502> lenses:. zoom, magnify, focus.. what do those words refer to ?
18:25:29 <edwardk> heh, magnify should be 'enhance' .. zoom, enhance, zoom!
18:25:35 <roconnor> n00b6502: I only know focus myself
18:25:49 <edwardk> n00b6502: they are somewhat of a pun off the lens analogy
18:25:56 <n00b6502> yeah i kind of guessed :)
18:26:06 <edwardk> zoom is used to run actions that take smaller states in a larger context
18:26:15 <edwardk> you 'zoom' in on part of the larger state
18:26:16 <roconnor> n00b6502: focus is where you use a lens to lift a state monad on a substructure to a state monad on a superstructure.
18:26:32 <n00b6502> i recall when i first suggested the word "actor", someone else suggestd deallocation/reset would be "kill cast"
18:26:46 <edwardk> magnify is the same thing for the reader monad, it lets you magnify part of a larger environment
18:26:46 <edwardk> n00b6502: =)
18:27:13 <edwardk> focus used to only work when state was the outermost monad
18:27:19 <roconnor> edwardk: zoom is multifocus?
18:27:24 <edwardk> with zoom i was able to make it work nested
18:27:35 <edwardk> but it could only take a lens not a traversal
18:27:39 <edwardk> so it didn't subsume focus
18:27:46 <edwardk> now i'm fixing that
18:28:15 <edwardk> e.g. with zoom you can use it as if it was zoom :: 'Monad' m => 'Simple' 'Lens' a b -> ErrorT e (RWST r w b m c) -> ErrorT e (RWST r w a m c)
18:28:21 <edwardk> to swap out the state a couple monads deep
18:29:41 <edwardk> this is particularly nice because it even works for monomorphic state-like monads
18:32:28 <edwardk> but letting that work for traversals would be a scarily powerful combinator
18:32:48 <edwardk> because you can run the traversal and get a monoidal summary of a series of actions rather than just one
18:32:58 <roconnor> edwardk: sounds awesome to me
18:33:01 <roconnor> and possibly useful
18:34:16 <edwardk> it also completes symmetry with the power of %%= and focus
18:35:31 <roconnor> edwardk: even more awesome if you use a KleeneState monad somehow
18:35:45 <edwardk> heh
18:35:56 <edwardk> haven't needed kleene state yet ;)
18:36:03 <roconnor> me neither :/
18:39:12 <mekeor> any ideas why i get "Could not find module `Foo.Bar'" when i import src/Foo/Bar.hs (which has the header "module Foo.Bar where") from src/Foo.hs?
18:40:17 <roconnor> mekeor: your cwd isn't src?
18:40:25 <mekeor> oh, i should say that i only get this error in GHCI, not in GHC.
18:40:28 * hackagebot zoom-cache 1.2.1.4 - A streamable, seekable, zoomable cache file format (ConradParker)
18:40:34 <roconnor> mekeor: your cwd isn't src?
18:40:36 <mekeor> roconnor: cwd?
18:40:41 <roconnor> current working directory
18:40:58 <mekeor> oh hm lemme try
18:42:04 <mekeor> roconnor: can i print the cwd in ghci?
18:43:01 <roconnor> I think so
18:43:12 <roconnor> getCurrentDirectory?
18:43:34 <mekeor> roconnor: thanks, it works .)
18:43:35 <mekeor> :)
18:43:43 <roconnor> didn't work for me :/
18:43:45 <BMeph> mekeor: Use ":! <command-line command>".
18:44:02 <mekeor> thanks BMeph
18:44:47 <BMeph> mekeor: Rather, you can use that in gchi.
18:44:57 <geekosaur> roconnor's answer is better; ":!cd foo" is not going to do anything useful
18:45:10 <BMeph> mekeor: you're welcome.
18:45:25 <mekeor> BMeph: yeah, of course in ghci :)
18:50:20 <roconnor> KleeneStores are kinda of a nice example of something that is applicative but not a monad
18:50:30 <roconnor> nicer than ZipList I think
18:50:38 <roconnor> though not as easy to understand I suppose
18:51:06 <yitz> roconnor: link?
18:51:38 <roconnor> yitz: http://arxiv.org/abs/1103.2841 -- it is called CartesianStore in this paper
18:51:49 <yitz> roconnor: tnx
18:51:55 <aristid> what's wrong with zip lists? :)
18:52:19 <roconnor> aristid: the truncation to the shorter list makes me feel a little ill
18:52:54 <aristid> roconnor: yeah i guess that's not always what you want
18:56:13 <JoeyA> Can I use my own newtypes as FFI arguments?  E.g. newtype ErrorCode = ErrorCode CInt
18:56:58 <Cale> JoeyA: yes
18:57:07 <JoeyA> foo :: IO ErrorCode
18:57:09 <JoeyA> Thanks
18:57:24 <JoeyA> Also, what happens if 'Int' (not CInt) is used as an argument?
18:58:36 <yitz> roconnor: so you're saying it's applicative and a comonad but not a monad?
18:58:49 <roconnor> yitz: yes
18:59:11 <edwardk> yitz: yep
18:59:34 <edwardk> the version i'm using in lens is just applicative, since its based on the indexed version of the comonad
19:00:26 <edwardk> roconnor: i have zoom working with traversals in RWST, StateT, ReaderT'd things it works in, and IdentityT'd things it works in so far
19:00:41 <dmwit> haha
19:00:44 <edwardk> was a bit messy
19:00:48 <dmwit> https://www.evernote.com/shard/s28/sh/64a0faa5-7be4-4a9f-a506-3e9a701755c0/84e3e7d67679ba9df73a4261e25f81a8 is pretty funny
19:01:08 <edwardk> lolwut
19:01:23 <dmwit> http://stackoverflow.com/q/11974602/791604
19:04:40 <roconnor> dmwit: ugh, jpeg artifacts
19:04:46 <dmwit> yes, well
19:04:59 <dmwit> I think the point of the image shines through quite clearly despite the artifacts.
19:19:08 <rekado_> Hi, I'm using postgresql-simple, but fail to understand how to get queries with "IN" to work
19:21:37 <hpc> rekado: is there some unexpected behavior you are getting, or is it a more conceptual problem?
19:21:55 <rekado> connection problems here, sorry
19:22:09 <rekado> ids :: [Only Integer] <- query db "SELECT id FROM posts WHERE id IN ?" $ In ([1,2,3,4] :: [Integer])
19:22:14 <rekado> That doesn't compile
19:22:21 <rekado>  Fails with: No instance for (ToRow (In [Integer]))
19:22:31 <hpc> hmm
19:22:35 <rekado> do I really need to create an instance for "In" or is there something else wrong?
19:22:53 <hpc> i would have to read the docs; i am unfamiliar with that package
19:23:06 <hpc> but from experience with other libs, that looks correct
19:23:20 <rekado> the docs only state that lists should be wrapped in "In"
19:23:26 <rekado> "In" is just a newtype wrapper
19:23:45 <rekado> doesn't come with an unwrapper function, so it seems unlikely I should write an instance myself.
19:24:16 <hpc> well, if you have the constructor you can write a destructor
19:24:29 <hpc> i would definitely not go writing instances to try and solve the problem
19:24:38 <hpc> what's the type of In?
19:25:04 <rekado> newtype In a
19:25:47 <hpc> http://hackage.haskell.org/packages/archive/postgresql-simple/0.2.3.0/doc/html/Database-PostgreSQL-Simple.html#t:In
19:25:50 <hpc> hmm
19:26:26 <shachaf> rekado: Does PostgreSQL support arbitrary-size integers?
19:26:46 <rekado> shachaf: I tried other types, too, with the same result.
19:26:48 <hpc> shachaf: not the problem; it's looking for ToRow, not ToField
19:27:08 <shachaf> There's instance ToField a => ToRow [a]
19:27:20 <hpc> try wrapping again in Only, perhaps
19:27:25 <hpc> or change the type of ids
19:27:36 <rekado> hmm
19:27:38 <shachaf> Oh, there is a ToField Integer instance.
19:27:47 <hpc> it might be typechecking it kinda backwards, because of the type of query or something
19:28:08 <hpc> oh
19:28:14 <hpc> or don't wrap it with In
19:28:19 <hpc> http://hackage.haskell.org/packages/archive/postgresql-simple/0.2.3.0/doc/html/Database-PostgreSQL-Simple.html#t:ToRow
19:28:22 <hpc> see the second instance there
19:28:23 <shachaf> No, that doesn't make sense.
19:28:28 <shachaf> Wait, what's the "In" for?
19:28:31 <rekado> that typechecks, but then there's a runtime error
19:28:35 <shachaf> query :: (ToRow q, FromRow r) => Connection -> Query -> q -> IO [r]
19:28:39 <rekado> > Wrap a list of values for use in an IN clause. Replaces a single "?" character with a parenthesized list of rendered values.
19:28:40 <lambdabot>   <no location info>: parse error on input `of'
19:28:42 <shachaf> There's an instance ToRow [Integer]
19:28:53 <shachaf> Does it work if you just get rid of the In?
19:28:59 <rekado> runtime error.
19:29:05 <rekado> It cannot build the query then.
19:29:15 <rekado> because there's only one placeholder.
19:29:52 <rekado> according to the docs, In is what I need to use a list of arbitrary length in a "SELECT ... IN ..." query
19:30:01 <shachaf> Oh, yes.
19:30:18 <shachaf> Is there even a ToRow instance for In?
19:30:21 <shachaf> There's a ToField instance.
19:30:36 <shachaf> Maybe query ... [In [...]] will work?
19:30:44 <rekado> I can't see a ToRow instance in the docs.
19:30:50 <rekado> shachaf: I'll try that
19:31:12 <rekado> shachaf: yes, it's working.
19:31:13 <rekado> nice
19:31:18 <rekado> so the docs are wrong.
19:31:21 <shachaf> OK, either the documentation or the package is broken.
19:31:33 <shachaf> Submit a bug report or something. :-)
19:31:36 <rekado> I'll write Leon
19:31:39 <rekado> thanks!
19:32:54 <edwardk> roconnor: got everything to zoom, except Cont. my brain broke on Cont
19:34:35 <roconnor> edwardk: just ask djinn for the instance
19:34:41 <edwardk> roconnor: =P
19:34:51 <edwardk> doesn't quite work here =)
19:40:31 * hackagebot proctest 0.1.2.0 - An IO library for testing interactive command line programs (NiklasHambuechen)
19:50:35 <Kuraitou> Is there a module for extracting HTML data in a jQuery or even XPath-style method?
19:55:00 <dmwit> Dunno, but tagsoup seems pretty popular for screen scraping.
19:56:04 <Kuraitou> That's what I'm looking at now, but it's a bit more complicated than I had hoped.
20:10:28 <kanedank> what does "=>" mean in haskell?
20:10:34 <nand`> type constraint
20:10:42 <nand`> (when used in type signatures)
20:10:50 <nand`> (I'm not sure if it's a valid operator name)
20:11:03 <nand`> > let (=>) = (>=) in 7 => 3
20:11:04 <lambdabot>   <no location info>: parse error on input `=>'
20:11:06 <nand`> it isn't
20:13:58 * shapr hugs johnw
20:14:07 <johnw> hey shapr!
20:14:23 <shapr> howdy johnw!
20:15:01 <danil> anyone have a recommended pretty-printing library?
20:20:56 <nand`> no love for ugly printing libraries?
20:22:34 <johnw> danil: I would like to know what you find
20:25:07 <danil> nand`: I've been using Show so far, does that count?  I've gotten to the point where my debugging output ends with stuff like "(Lit (LitInt 2))])]}))])]}))])]}))]))]".
20:25:21 <nand`> yikes
20:25:40 <shapr> oh, I saw a lib on hackage that prettifies that for you...
20:27:46 <tacosanta> clear
20:28:24 <shapr> CLEAR
20:28:41 * shapr tries to jump start the channel
20:29:05 <johnw> shapr: tell me how to get lambdabot to install on a Mac
20:29:10 <johnw> this readline dependency is awful
20:29:24 <shapr> I haven't been able to install lambdabot lately :-(
20:29:24 <edwardk> heya shapr
20:29:28 <johnw> no matter what I try to do, I just can't get it to build
20:29:32 <johnw> i'm even trying from sources now
20:29:33 <shapr> :-(
20:29:35 <shapr> edwardk: howdy!
20:29:51 <edwardk> i think based on netsplit activity, your attempt at defibrillation may have damaged the patient
20:30:08 <danil> shapr: automatic would be nice.  I was thinking of writing something more involved using either the Hughes-PJ or Wadler-Leijen combinators, but it looks like there are a bunch of libraries and I can't tell which are better.
20:30:19 <shapr> edwardk: haha
20:34:26 <ddarius> There's some package with a disgusting function that parses the (derived) output of show and (re)pretty prints it.
20:34:32 <ddarius> I don't remember the name off the top of my head though.
20:34:34 <johnw> have any Mac users gotten lambdabot to compile?
20:35:18 <johnw> I found an older hpaste pastie with my exact error: http://hpaste.org/72177
20:35:24 <johnw> so I know others have been down this road before me...
20:42:22 <slack1256> how can I sort with 'sortBy' so it returns me a list ordered from max to min
20:42:29 <slack1256> reverse . sort isn't a option
20:43:49 <danil> > sortBy (flip compare) "how's this?"
20:43:52 <lambdabot>   "wtssoihh?' "
20:44:07 <johnw> so, I got lambdabot to run
20:44:10 <johnw> it loaded plugins
20:44:19 <johnw> but isn't it supposed to give me a prompt or something?
20:44:50 <lpvb> prompt where
20:44:54 <johnw> it's just sitting at the terminal
20:45:03 <lpvb> you have to configure it to connect to an irc
20:45:12 <johnw> at the command-line.  the whole reason why it linked in readline :)
20:45:14 <lpvb> it should have config files nearby
20:45:15 <geekosaur> ifyou run it without parameters, it should run in a local mode rwith a prompt
20:45:22 <geekosaur> or it used to, at least...
20:45:28 <johnw> yeah, I just ran "lambdabot"
20:46:03 <Clint> looks like this
20:46:04 <Clint> Initialising plugins ................................................... done.
20:46:05 <Clint> lambdabot>
20:46:07 <johnw> ah
20:46:12 <johnw> it's that second line I'm not seeing
20:46:30 <johnw> it catches signals
20:46:40 <geekosaur> right.  could you have somehow not configured the command line ("offline" module, iirc?)
20:46:44 <slack1256> danil: you rock. thanks
20:46:53 <johnw> I haven't configured anything
20:47:02 <slack1256> why didn't I see that?
20:48:17 <johnw> i'm using GHC 7.4.2, is that perhaps part of the problem?
20:48:30 <lpvb> do you need a command line prompt?
20:48:34 <johnw> yes
20:48:40 <johnw> I want to interact with it from Emacs
20:48:46 <johnw> via a subshell
20:49:03 <lpvb> lambdabot is old and unmaintained
20:49:05 <lpvb> so idk
20:49:36 <shapr> lpvb: it's unmaintained? :-(
20:49:43 <nohonor_alt> poor lambdabot
20:49:59 <nohonor_alt> i imagine the terrible pain in all the diodes down its left side
20:50:04 <lpvb> well it doesn't compile easy on the latest ghc and has a bunch of errors the last time I tried
20:50:12 <johnw> ok
20:50:16 <johnw> it compiled OK here
20:50:18 <shapr> lpvb: I thought it had a maintainer?
20:50:34 <shapr> If lambdabot is really unmaintained I'll have to pick it back up again.
20:50:42 <nohonor_alt> anyone have an idea why hackage is in the peerblock blacklist?
20:50:43 <shapr> I hosted and maintained lambdabot for several years.
20:50:56 <shapr> nohonor_alt: No idea, when did that happen?
20:50:57 <lpvb> please do
20:51:12 <lpvb> so I can spread the love to other irc channels
20:51:13 <nohonor_alt> shapr, i spent an hour yesterday figuring out why cabal doesn't work
20:52:20 <shapr> nohonor_alt: Wow, craziness
20:54:05 <ion> PeerBlock lets you control who your computer "talks to" on the Internet.  By selecting appropriate lists of "known bad" computers, you can block communication with advertising or spyware oriented servers, computers monitoring your p2p activities, Haskell package repositories, computers which have been "hacked", even entire countries!
20:58:59 <Ralith> peerblock is known for breaking things at random
21:09:52 <djahandarie> ddarius, do you have any thoughts on what would happen if you relaxed the cartesian closedness of an elementary topos to be symmetric monoidal? (Does this make any sense at all? Do I get to keep any of the interesting theorems?)
21:15:29 <tam1138> hi
21:16:25 <EN1RA> hello
21:17:18 <tam1138> sorry if this is a dumb question, but a lot of googling didn't bring enlightenment.
21:17:32 <tam1138> let t1 = pack "Hi!" ; let t2 = t1 ++ "asdf" ++ t1 ....  kablooie
21:17:55 <tam1138> ghci thinks the rhs of t2 is of type [a0]
21:17:59 <tam1138> i don't understand why
21:18:18 <dmwit> tam1138: For two reasons: 1. because (++) operates on lists 2. because "asdf" is a list
21:18:33 <dmwit> :t (Prelude.++)
21:18:35 <lambdabot> forall a. [a] -> [a] -> [a]
21:19:01 <dmwit> :t "asdf"
21:19:02 <tam1138> ahhhhh
21:19:03 <lambdabot> [Char]
21:19:06 <tam1138> i see!
21:19:19 <tam1138> so i need T.concat
21:19:24 <dmwit> right
21:19:28 <tam1138> awesome
21:19:29 <tam1138> thanks
21:19:31 <djahandarie> (Note that "asdf" may not be a list if you have OverloadedStrings on, but I suspect you don't if you're manually calling pack.)
21:19:48 <tam1138> i actually do have OverloadedStrings on
21:19:50 <tam1138> though not in ghci
21:20:30 <tam1138> i get the same error on essentially the same code with OverloadedStrings on
21:20:41 <djahandarie> Yeah, that's due to the (++).
21:21:08 <mm_freak> tam1138: i wouldn't expect GHCi to infer any type, but rather a type error
21:21:27 <mm_freak> oh, you get an error
21:21:44 <djahandarie> Also, if you want the analog of (++) for ByteString, you actually want append, not concat.
21:22:21 <dmwit> Presumably this is Text, not ByteString.
21:22:26 <tam1138> this is Text
21:22:34 <tam1138> but i could make it ByteString
21:22:39 <dmwit> Given the T. module qualification and my heuristics about how humans choose abbreviations. =P
21:22:46 <tam1138> ;)
21:22:47 <dmwit> No, Text is better for text (surprise!).
21:22:47 <djahandarie> Good call.
21:22:56 <djahandarie> Yeah, Text is better if you are working with text.
21:23:08 <djahandarie> It's still append anyways.
21:23:15 <djahandarie> Just the append from the Data.Text module.
21:23:25 <tam1138> it's actually data that's come in over the network.  i thought it would be appropriate to convert it from ByteString to Text before i had it to the user.
21:23:52 <djahandarie> 'Append-like' functions are generalized into Data.Monoid.mappend if you're interested in always using a single function for Lists, ByteString, and Text.
21:24:46 <djahandarie> And Data.Monoid.mappend has an alias of (<>) in newer version of the Data.Monoid module, which makes things pretty concise.
21:24:58 <tam1138> thanks, but i'm not that advanced yet.  i'm hoping to make this stuff work, then ask for comments on the whole she-bang, because i'm quite sure i'm doing it wrong.
21:25:14 <tam1138> or at least very suboptimal
21:25:18 <djahandarie> Sounds good. :)
21:25:53 <dmwit> Is the data that came in from the network actually text or not?
21:26:33 <tam1138> yes, it is text
21:26:40 <tam1138> in the form of a ByteString
21:27:02 <tam1138> i'm writing a FastCGI server (i know it's been done before, but this is a learning exercise)
21:27:06 <dmwit> Right. So long as you understand how encodings work and such, I'll shut up.
21:27:26 <tam1138> i call T.decodeUtf8 on the ByteString to get the Text :)
21:29:46 <tam1138> sweet, it works.  thanks everybody!
21:34:45 <Guest55743> i have type T = readerT r IO and im having a hard time writing a function to 'run' a (T a) with an MVar as in withMVar
21:34:59 <JoeHazzers> i know i'm going to get shot for this, like through my beautiful face
21:35:02 <Guest55743> without providing the r
21:35:25 <JoeHazzers> but how do i match the url (in the "href" tuple) in this with a list comprehension? [[TagLeaf (TagText "\r\n\"),TagBranch "a" [("title","fdsklfjsdkl"),("href","http://url.com")] [TagLeaf (TagText "\r\n\Text!")],TagLeaf (TagText "\r\n\t\t\t\t")]]
21:35:31 <Guest55743> guess i need to use liftIO then runReaderT with the r from ask
21:35:53 <Guest55743> inside of withMVar
21:35:58 <Guest55743> seems crazy
21:36:49 <tgeeky> have you heard of Sarah Palin?
21:37:49 <danil> Guest55743: monad transformers don't play too nice with functions taking actions as arguments, sadly
21:38:05 <Guest55743> bah
21:41:03 <mm_freak> Guest55743: see the lifted-base package
21:41:03 <danil> Guest55743: though I think your case is covered by liftWith in the monad-control package
21:41:55 <mm_freak> but if it's ReaderT and you want 'ask' i wouldn't bother with monad-control/lifted-base
21:42:04 <mm_freak> just runReaderT within the action again
21:44:05 * ddarius finally watches Tony Hoare's "Billion Dollar Mistake" talk.
21:44:24 * djahandarie attempts to pick ddarius's brain
21:45:06 <djahandarie> Did you see my possibly unanswerable question earlier?
21:45:51 <tgeeky> Potentially
21:46:38 <djahandarie> I suppose I should go read Sketches of an elephant and then try to figure it out myself, but it's definitely easier to ask
21:47:40 * ddarius would like to see djahandarie read Sketches of an Elephant.
21:47:49 <djahandarie> :(
21:48:22 <djahandarie> It'd be annoying to read it all only to realize that my question was stupid.
21:48:55 <ddarius> djahandarie: You even have access to Sketches of an Elephant?
21:49:27 <ddarius> Anyway, you may be able to view it as an "internal" topos or an elementary topos in an enriched category.
21:50:10 <djahandarie> I don't have access to it right now, but I don't see why it'd be impossible to get access. Isn't it purchasable?
21:50:23 <ddarius> You'd almost certainly need to add some additional axioms that would no longer come for free.  I strongly suspect you'd lose finite colimits for free.
21:50:56 <ddarius> djahandarie: Sure, only $394
21:51:35 <Guest55743> also bah @ overloaded strings plus functions which take any IsString
21:51:49 <Guest55743> now it doesnt know what the string literal is supposed to be
21:51:56 <ddarius> There's also a notion of pre-topos and another notion of a logos, but I don't think they'd be too helpful to you, but I'm not that knowledgeable about them.
21:52:00 <Guest55743> gotta put manual type sigs
21:53:58 <djahandarie> ddarius, wouldn't an elementry topos in an enriched category be relaxing the wrong cartesianness constraint?
21:55:01 <djahandarie> Unless you mean enriched over some specific category
21:55:16 <ddarius> djahandarie: Yes, it wouldn't be an arbitrary category.
21:56:02 <ddarius> djahandarie: You could also approach this (and it is probably easier) by considering the internal language/logic of an elementary topos and what that change would mean logically.
21:56:20 <ddarius> Which would likely also suggest the axioms you'd want to re-add to get something nice.
21:56:32 <djahandarie> That's actually where I'm trying to go with this, and for some reason decided to start on the categorical side instead.
21:57:11 <ddarius> Well, you certainly could talk about a symmetric monoidally closed category with a "monoidal subobject classifier" and figure out what it's internal language would be.
21:58:21 <djahandarie> What I'm actually trying to do is relax cartesianness in a Grothendieck topos (which I'm using to embed first-order logic with a least fixed point (by squashing the initial algebras, which I'm allowed to do because it's locally presentable)) and see what logic I get.
21:58:21 <ddarius> Going the other way, though, you'd be reducing a very minimal intuitionistic set theory to something that doesn't have contraction and weakening.
21:58:33 <djahandarie> Yeah.
21:58:36 <ddarius> You'd have to see what base constructions/axioms that would destroy.
21:59:05 <ddarius> @google "geometric logic" topos
21:59:07 <lambdabot> http://www.amazon.com/The-Topos-Music-Geometric-Performance/dp/3764357312
21:59:12 <ddarius> Hmm
22:01:29 <djahandarie> I technically only need a well-powered geometric category to intepret FOL, but having initial algebras for accessible endofunctors (including dependent polynomials) always available (like in a Grothendieck topos) seems key to interalizing this language I want
22:01:30 <ddarius> djahandarie: Why are you using a Grothendieck topos for this?
22:01:35 <djahandarie> ^
22:02:28 <djahandarie> There's no typed first-order logic with a LFP lying around, but I think the LFP is exactly the rule for an inductive defintion of a propostion.
22:03:11 <djahandarie> And since the categorical semantics of inductive types generally describe them as initial algebras for dependent polynomial endo functors, I think you'd just need to apply bracket/squash (image factorization) to the initial algebra to get an inductive proposition.
22:03:21 <djahandarie> And that's why I want the category to be locally presentable
22:03:27 <djahandarie> I think :)
22:09:19 <Guest55743> > length "\255\255\1"
22:09:21 <lambdabot>   3
22:09:57 <djahandarie> One snag with this LFP operator is that it's only positive, not strictly positive. But since I'm defining propositions, I think the non-strict positivity is okay.
22:10:14 <djahandarie> Since the problem with non-strict positivity for inductive types is that the double-powerset functor is non-strict positive but has no fixed points
22:17:48 <djahandarie> Anyways, this is clearly far more complicated than just working with an elementary topos, so I was going to try and start there.
22:18:23 <djahandarie> I guess I'll try to see if I can come up with a definitely of an elementary topos that starts with a symmetric monoidal category and see if I can get anything interesting out of it.
22:18:27 <djahandarie> Feels like it's going to take forever.
22:18:53 <djahandarie> definition*
22:21:41 * djahandarie wonders if there's something called a 'locally symmetrical monoidally closed category' and if that's what a relaxed elementary topos would be
22:22:05 <ddarius> What would that mean?  Every slice is a symmetrically monoidally closed category?
22:22:08 <djahandarie> Yeah.
22:22:39 <djahandarie> It'd be interesting to see what the right adjoint of the base change functor would be there
22:22:43 <ddarius> I think that would produce something but it would, I suspect, be hard to "globalize".  The different slices would be harder to relate to each other.
22:23:09 <ddarius> But, that's probably fixable by a given axiom.
22:24:07 <ddarius> I don't know that may be interesting.
22:25:02 <djahandarie> Feels like I'd end up getting something like a linear dependent type theory out of all of this if any of it actually works.
22:26:23 <djahandarie> And if the pullbacks preserve the colimits still, and I have finite colimits in this category I'm trying to come up with, then I'd probably be able to get my initial algebras too
22:28:50 <djahandarie> Oh well, too much speculation, too little math. I'll see if I can bang something out
22:30:00 <ddarius> Perhaps (?) look at LLF and CLF...
22:33:20 <JoeyA> Quick API survey: which approach should a low-level C API binding take for managing objects?
22:33:45 <JoeyA>  1) newtype Foo = Foo (Ptr CFoo) -- CFoo is a phantom type
22:33:56 <JoeyA> This is the approach taken by direct-sqlite
22:34:32 <shachaf> As opposed to what?
22:34:41 <JoeyA>  2) newtype Foo = Foo (ForeignPtr CFoo) -- close the Foo when it's garbage collected
22:34:57 <JoeyA> This is the approach taken by the libpq package
22:35:00 <JoeyA> @hackage libpq
22:35:01 <lambdabot> http://hackage.haskell.org/package/libpq
22:35:04 <JoeyA> err
22:35:26 <JoeyA> The postgresql-libpq package
22:35:39 <JoeyA> @hackage postgresql-libpq
22:35:40 <lambdabot> http://hackage.haskell.org/package/postgresql-libpq
22:36:07 <ddarius> You should assume that garbage collection happens once at the very end of your program when it comes to finalizers.
22:37:04 <JoeyA>  3) newtype Foo = Foo (MVar (ForeignPtr CFoo)) -- Like (2), but use locking to guard against concurrent access.
22:37:29 <ddarius> For a low-level C API, you should use the first one.
22:37:42 <JoeyA> ddarius: But early finalization might have a negative impact, e.g. an error message is freed prematurely.
22:38:17 <JoeyA> (in reference to "you should assume ...")
22:38:41 <ddarius> JoeyA: That seems like you are agreeing with me.
22:39:12 <JoeyA> ddarius: I am about "For a low-level C API".
22:39:36 <JoeyA> But for assuming garbage collection happens at the end, that assumption is admissible for performance, but not for safety.
22:40:21 <JoeyA> For example, an API might (wrongly) turn a CString into a ByteString with unsafeYaddaYadda
22:40:53 <ddarius> My point wasn't that you can assume that, but rather, you can't assume finalizer happen promptly or even at all until the end of the program, so if you are relying on them for clean-up, you better be fine with "leaking" the resources for the entire life-time of the program.
22:41:06 <Okasu> i'm trying to ressurect markov chains modue but no luck, do you know how to fix it? http://vpaste.net/NtBaj
22:41:10 <JoeyA> Makes sense.
22:41:23 <ddarius> At any rate, it's the job of the mid-level/high-level interfaces to make this stuff pretty.
22:41:36 <shachaf> Okasu: System.Random?
22:41:57 <shachaf> JoeyA: Yes, "low-level" presumably means "as close to the C API as possible, except in Haskell instead of C".
22:42:03 <JoeyA> ddarius: I'm currently romping around in direct-sqlite.  Should I insist on exporting the definitions of the C pointers?
22:42:06 <Okasu> shachaf: yep, (in module's source: import System.Random (RandomGen, randomR))
22:42:07 <ddarius> They will probably have more information and structure and can thus do a better job than you can at the low level.  Your low-level "niceties" will end up being wasteful at best or actively getting in the way at worst.
22:42:18 <shachaf> Okasu: So?
22:42:25 <Okasu> shachaf: So?
22:42:27 <JoeyA> (Without them, users can't write additional FFI bindings using the same types, as of GHC 7.6)
22:42:37 <JoeyA> err
22:42:40 <Okasu> shachaf: http://vpaste.net/NtBaj error
22:42:47 <shachaf> Okasu: Right.
22:42:52 <JoeyA> exporting the definition of: newtype Database  = Database  (Ptr CDatabase)
22:42:55 <JoeyA> Rather than making it abstract.
22:42:56 <shachaf> Okasu: The error is in your ghci line, not in the module.
22:43:05 <shachaf> Okasu: You can tell, because the module compiled, and your line didn't. :-)
22:43:19 <shachaf> Okasu: Therefore you should use System.Random.
22:44:13 <ddarius> JoeyA: I don't think there is any harm in doing that unless you are trying to maintain some invariant, at which point, you probably aren't allowing free extension anyway, so you wouldn't have that conflict.
22:44:55 <JoeyA> Agreed
22:45:22 <ion> joeya: I’d make the low-level bindings follow the C API as closely as possible. Manual deallocation in C? Manual deallocation in the bindings. Then build a high-level API that feels like Haskell on top of that, handling GC and concurrency issues.
22:46:10 <ion> Btw, bindings-DSL is awesome for the low-level bindings part.
22:47:46 <Okasu> shachaf: thanks, compiling solves the prob
22:47:54 <shachaf> Okasu: ?
22:48:05 <shachaf> Okasu: The problem was an error in the line you typed into ghci.
22:48:41 <JoeyA> Now what about exceptions?  Should the low-level API return error values, or throw exceptions?  Perhaps that depends on how low I want to go.
22:49:09 <JoeyA> But here's what I think a binding should *not* do: return the raw error code number, rather than decoding it as an ADT.
22:49:25 <Okasu> shachaf: nvm, it was a brain lag, sorry
22:49:25 <ion> joeya: Depends on whether the C API throws exceptions. ;-)
22:50:22 <shachaf> JoeyA: Having multiple levels of FFI wrappers is OK.
22:50:37 <shachaf> You can have a low-level binding, a medium-level binding that uses it, and a high-level binding that uses that.
22:50:52 <ion> OVER 9000 LEVELS OF FFI WRAPPERS
22:50:54 <shachaf> Or even more!
22:51:04 <JoeyA> More realistically, 4.
22:51:25 <JoeyA> Though nobody's gotten to 4 before.
22:53:20 <Enigmagic> sounds like a competition.
22:53:47 * shachaf 's FFI uses kind-level Mu.
22:55:44 <JoeyA> In any case, I really like situations where when someone asks "Should I use package A or B?" we can answer "A depends on B".
22:56:53 <ddarius> JoeyA: A low-level C binding should be just enough so that if I want to use it, I will not have to write any C or run my code through CPP (to get constants for example).
22:57:20 <nand`> is there an (Enum a, Enum b) => Enum (a,b) instance somewhere that enumerates by listing the diagonals?
22:57:53 <ddarius> Really, the Haskell tao of FFI is to as much as possible in Haskell so you are -already- going to have that C function that returns raw error numbers, so why not export it as well as anything nicer you feel you need to make.
22:58:33 <Twisol> Can anyone point me to a conduits tutorial for beginners? I want to experiment with the library but I don't understand how to use it, and the tutorials I've found are either too simple (sourceFile a $$ sinkFile b) or too technical.
22:59:22 <ddarius> Twisol: Isn't there one referenced in the package?
22:59:50 <Twisol> ddarius: I thought that one was pretty technical.
23:03:51 <nand`> mm_freak: would it be fair to compare conduits to souped up automaton arrows? I'm seeing the same sort of ‘HaveOutput next .. output’; and ‘NeedInput (input -> next)’
23:04:26 <nand`> (of course some extra stuff with the leftovers / Done / PipeM)
23:05:32 <mbuf> given a [String], say a = ["a", "b", "1", "d"], is there another way to match for the number 1, other than using [ x | x <- a, x =~ "[0-9]+" ]
23:05:45 <shachaf> (=="1")
23:06:14 <mbuf> shachaf: actually match for the regex
23:06:25 <nand`> > filter (all isDigit) ["a", "b", "1", "d", "123"]
23:06:26 <shachaf> > filter (all isDigit) ["a","b","1","d"] -- I'm not sure what you actually want yet.
23:06:27 <lambdabot>   ["1","123"]
23:06:27 <lambdabot>   ["1"]
23:06:35 <ddarius> filter (=~ "[0-9]+)
23:06:41 <mbuf> ddarius: thanks
23:06:45 <mbuf> shachaf: thanks
23:07:03 <ddarius> @undo [x | x <- a, x =~ "[0-9]+"]
23:07:03 <lambdabot> concatMap (\ x -> if x =~ "[0-9]+" then [x] else []) a
23:07:10 <ddarius> A little too literal.
23:07:13 * shachaf notes that "a1" matches "[0-9]+"
23:07:48 <shachaf> Fixing that regexp is slightly more complicated than you might think.
23:08:10 <nand`> ^\d+$ ?
23:08:16 <shachaf> Nop.e
23:08:17 * shachaf notes that "a\n1" matches "^[0-9]+$"
23:08:29 <Twisol> \a\d+\Z?
23:08:35 <Twisol> (if I recall the casing right)
23:09:13 <shachaf> I think Ruby has \A...\z?
23:09:30 <shachaf> I don't know that whatever Text.Regex uses has that.
23:09:46 <Twisol> I'm just familiar with PCRE
23:09:59 <ddarius> There are multiple backends for the regex libraries.
23:10:10 <shachaf> Right.
23:10:15 <shachaf> Whatever you're using, then.
23:12:03 <nand`> (Doesn't ^$ only match on linebreaks when multi-line mode is enabled?)
23:12:35 <nand`> I'm not sure how the various haskell regex libraries treat modes like that, I've never used them
23:12:37 <shachaf> Something like that.
23:13:02 <Twisol> as a Haskell neophyte, is there any super-important stuff I should know before tackling Data.Conduit? Because none of it is making sense right now.
23:16:48 <nand`> I tested it, at least regex-posix has multi-line mode enables by default
23:23:23 <nand`> let me just comment on how excruciating it is to do anything with regex-posix
23:23:53 <nand`> I tried somehow disabling multi-line mode when matching. I gave up after I got 3 simultaneous ambiguous type errors relating to MPTCs
23:25:21 <shachaf> (=~) :: Regexish a => a
23:27:08 <ddarius> The Regex library has a large pile of stupid.  (=~) is one of the larger mounds of it.
23:28:38 <nand`> s/regex-posix/regex-base/
23:30:22 <mm_freak> nand`: not really…  pipes/conduits and automata are orthogonal
23:30:32 <mm_freak> in the sense of how they consume and produce
23:30:56 <mm_freak> but you could probably implement pipes in terms of automata
23:31:08 <nand`> automata always produce one value for each value they consume; and pipes can consume and produce in arbitrary quantities?
23:31:24 <ddarius> Hardware, why must you have so attractively easy algorithms that are difficult to efficiently reproduce in software?
23:45:40 * hackagebot simple-sendfile 0.2.6 - Cross platform library for the sendfile system call (KazuYamamoto)
23:45:46 * hackagebot wai-app-file-cgi 0.7.1 - File/CGI/Rev Proxy App of WAI (KazuYamamoto)
23:45:48 * hackagebot mighttpd2 2.7.2 - High performance web server on WAI/warp (KazuYamamoto)
