00:00:35 <Jafet> nub is lazy
00:00:42 <danil> @src nub
00:00:42 <lambdabot> nub = nubBy (==)
00:00:50 <danil> @src nubBy
00:00:50 <lambdabot> nubBy eq []             =  []
00:00:50 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:01:51 <latro`a> hmm
00:01:56 <opqdonut> it basically iterates through the list and outputs only values that haven't yet appeared
00:02:30 <latro`a> but it only does the filtering based on the "current" element, which means it will break down if the relation supplied isn't an equivalence
00:03:16 <latro`a> that is, it assumes eq x y -> eq z y for all z that have already been prepended
00:03:37 <latro`a> hmm
00:03:54 <Jafet> This is only relevant if you just wrote an Eq instance that isn't an equivalence relation
00:04:06 <latro`a> only with just nub, I was using nubBy
00:04:19 <latro`a> with a subset checker, on lists that have the same length
00:04:25 <ksf> why is everybody ignoring maximum munch/minimum munch when implementing the alternative API that fails to distinguish between them?
00:04:44 <latro`a> which....hrm, that's still an equivalence no?
00:05:30 <Jafet> What is a subset checker?
00:05:36 <ksf> also it's kinda strange most haskell parsers use minimum munch by default, as it's usually the one you don't want.
00:05:45 <latro`a> treat the lists as multisets, determine whether one is a subset of the other
00:06:10 <ksf> latro`a, try Data.Set
00:06:14 <Cale> actually nubBy is great with nonequivalences, except that half the time, the library authors manage to swap the argument order on you and mess everything up
00:06:21 <latro`a> just Data.Set wouldn't do, but Data.MultiSet could do
00:06:35 <latro`a> I definitely need multiplicity, or it doesn't work
00:06:40 <latro`a> for what I'm doing
00:07:03 <latro`a> (the actual thing I'm trying to do is generate a combinations list, then do some processing on it)
00:07:33 <latro`a> (nubBy is *probably* not the best way to do this
00:07:33 <latro`a> )
00:07:58 <ksf> nub it O(n^2) worst-case IIRC.
00:07:59 <Jafet> @check \xs ys zs -> let e x y = intersect x y `elem` [x, y] in xs`e`ys && ys`e`zs == xs`e`zs
00:08:00 <lambdabot>   "OK, passed 500 tests."
00:08:10 <latro`a> it is, yes
00:08:13 <Jafet> @check \xs ys zs -> let e x y = intersect x y `elem` [x, y] in (xs::Bool)`e`ys && ys`e`zs == xs`e`zs
00:08:14 <Cale> > nubBy (<=) [1,1,2,3,1,2,3,5,4,7]
00:08:14 <lambdabot>   Couldn't match expected type `[a]'
00:08:15 <ksf> ...mainly because it doesn't reorder the list.
00:08:15 <lambdabot>   [1,2,3,5,7]
00:08:21 <Cale> ^^ peaks
00:08:32 <Jafet> @check \xs ys zs -> let e x y = intersect x y `elem` [x, y] in (xs::[Bool])`e`ys && ys`e`zs == xs`e`zs
00:08:33 <lambdabot>   "Falsifiable, after 3 tests:\n[False,True,False,True]\n[True]\n[True,False,...
00:09:05 <Cale> > groupBy (<=) [1,1,2,3,1,2,3,5,4,7]
00:09:06 <lambdabot>   [[1,1,2,3,1,2,3,5,4,7]]
00:09:14 <Cale> ^^ "incorrect"
00:09:19 <Cale> > groupBy (>=) [1,1,2,3,1,2,3,5,4,7]
00:09:20 <lambdabot>   [[1,1],[2],[3,1,2,3],[5,4],[7]]
00:10:13 <Cale> oh, no, I just messed up :)
00:10:18 <Cale> > groupBy (<) [1,1,2,3,1,2,3,5,4,7]
00:10:19 <lambdabot>   [[1],[1,2,3],[1,2,3,5,4,7]]
00:11:06 <Cale> This does something nice when you use it recursively to form a tree.
00:11:32 <latro`a> incidentally
00:11:34 <latro`a> the line in question
00:11:48 <Cale> For example, suppose you have a bunch of document sections like 1, 1.1, 1.2, 1.2.1, etc.
00:11:58 <latro`a> combs = nubBy subset [[c1,c2,c3,v1,v2] | c1 <- cs, c2 <- cs, c3 <-  cs, v1 <- vs, v2 <- vs]
00:12:03 <latro`a> cs is length 17, vs is length 5
00:12:20 <ddarius> > 17^3 * 5^2
00:12:21 <lambdabot>   122825
00:12:28 <ddarius> > 122825 ^ 2
00:12:29 <lambdabot>   15085980625
00:12:50 <latro`a> nub has a <1 constant in the worst case, but yeah, it's of that order
00:13:06 <Jafet> Oh, I got the logic wrong
00:13:44 <Jafet> @check \xs ys zs -> let eq x y = intersect x y `elem` [x, y]; a `implies` b = not a || (a && b) in ((xs::[Bool])`eq`ys && ys`eq`zs) `implies` (xs`eq`zs)
00:13:45 <lambdabot>   "Falsifiable, after 4 tests:\n[False,False,True,False]\n[False,False,False]...
00:13:53 <latro`a> ...oh, hey, I can reduce this tremendously
00:13:56 <latro`a> by splitting it into two problems
00:13:58 <latro`a> \o/
00:14:16 <edwardk> preflex: xseen danil
00:14:16 <preflex>  danil was last seen on freenode/#haskell 13 minutes and 26 seconds ago, saying: @src nubBy
00:14:25 <edwardk> preflex: xseen danharaj
00:14:25 <preflex>  danharaj was last seen on freenode/#haskell 9 hours, 21 minutes and 46 seconds ago, saying: the*
00:14:29 <edwardk> woops
00:14:44 <Cale> By the way, if you want a faster but still lazy nub and you're working with ordered data, it's possible to write one using Data.Set to accumulate a set of the elements you've already seen.
00:15:30 <hpaste> trbotime pasted ‚ÄúError‚Äù at http://hpaste.org/72469
00:15:36 <trbotime> hi, i am a haskell noob, i was in the interpreter and i tried this simple map function: map Char.toUpper "foo"
00:16:01 <Cale> trbotime: The Char module has become Data.Char
00:16:14 <trbotime> ah, ok! thank you!
00:16:26 <Cale> trbotime: you can also  import Data.Char  and then you only have to write  map toUpper
00:17:22 <trbotime> Oh, thank you ^_^
00:19:33 <Cale> trbotime: Incidentally, it's telling you that you could use the haskell98 package for compatibility with the old standard, but you'd have to awkwardly run ghci with  ghci -hide-package base -package haskell98  since it'll conflict with the base package otherwise.
00:19:59 <Cale> But yeah, probably just better to learn where stuff is now :)
00:20:23 <ddarius> Non-hierarchical modules have not been used for almost the entire time Haskell 98 was the standard.
00:26:39 <hpaste> js pasted ‚Äúquickcheck mergesort‚Äù at http://hpaste.org/72470
00:26:59 <jaredc> i've written mergesort when i do verboseCheck i get a bunch of output with [()....]. does this mean quickCheck generating :: [()] or is that just the output? the documentation says something like "Only variables quantified over inside the verbose are printed." So i am testing [()] lists or not setting up the test right? http://hpaste.org/72470
00:27:21 <Jafet> @check \xs -> xs == reverse xs
00:27:22 <lambdabot>   "OK, passed 500 tests."
00:27:28 <Jafet> @check \xs -> xs == reverse (xs::Bool)
00:27:29 <lambdabot>   Couldn't match expected type `[a]'
00:27:34 <Jafet> @check \xs -> xs == reverse (xs::[Bool])
00:27:35 <lambdabot>   "Falsifiable, after 5 tests:\n[False,False,True]\n"
00:28:22 <Jafet> Basically yes
00:30:20 <jaredc> so would the solution be to do what you did and give a concrete type like Int? how did quickCheck choose () ?
00:30:57 <Jafet> The type of prop_minimum is Ord a => something something a
00:31:01 <Cale> assuming you're running the tests inside ghci, ghci has extended defaulting rules
00:31:16 <Jafet> Somewhere, a is defaulted to ()
00:32:24 <frerich> Interesting, is there a particular reason why () is chosen instead of a type which has more values?
00:33:00 <Cale> because () is really simple and is often what you want when a type doesn't matter to you
00:34:48 <jaredc> ah thanks
00:35:12 <jaredc> ghc guide section 2.4.5 has the defaulting rules
00:35:51 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
00:36:31 <Jafet> Because you really don't want ghci choosing some arbitrary type for you
00:38:37 <Cale> lol, adding an instance of Num for () is a hilarious abuse of that
00:39:12 <Cale> ghci> instance Num () where fromInteger _ = ()
00:39:16 <Cale> ghci> 5
00:39:16 <Cale> ()
00:39:17 <Jafet> The unit ring is totally legit
00:40:40 <Cale> (because it puts () at the start of the list of defaults, and not the end)
00:41:08 <jaredc> awesome adding a type signature worked, thanks for the help
00:42:15 <hpaste> tgeeky pasted ‚Äúcoefficient calculation of SM paramters‚Äù at http://hpaste.org/72471
00:43:34 <tgeeky> first time: I'm running a novel calculation -- that will take several hours/days to complete
00:43:40 <tgeeky> and I accidentically started it in GHCi :(
00:44:00 <trbotime> Ah ok Cale thanks...I think I'll just find a newer book to learn from :^)
00:48:59 <tgeeky> damn. it's going to be wrong, even if it finishes! damn science!
00:49:00 * hackagebot hcron 0.0.0.2 - A simple job scheduler, which just runs some IO action at a given time. (TimoHuebel)
00:49:05 <Taneb> What is the connection between Monads and Monoids?
00:49:16 <tgeeky> Taneb: Monads are just monoids in the category of endofunctors.
00:49:19 <tgeeky> (tm)
00:50:10 <malthe> that
00:50:13 <malthe> is pretty dense
00:50:48 <Taneb> tgeeky, I've heard that line many times, but...
00:51:04 <tgeeky> Taneb: yes. It's slightly less condescending if s/just//
00:51:40 <Taneb> tgeeky, unfortunately, it seems to be formulated to pack as much meaning into as little understanding
00:51:42 <tgeeky> monads are just the simplest thing one can do given the mechanism of adjunctions
00:51:46 <tgeeky> in the category of endofunctors
00:52:33 <tgeeky> I'm pretty much making this up, too, so who knows
00:54:36 <Taneb> I think the connection I'm looking for is that you need a monoid to make Writer a monad
00:54:55 <tgeeky> you need a monoid to make any monad, I think?
00:55:06 <tgeeky> a reader monad is a monoid over all environments
00:55:13 <tgeeky> ?
00:55:41 <Taneb> As in Monoid w => Monad ((,) w)
00:55:45 <mauke> Taneb: that doesn't look related to anything
00:55:47 <edwardk> woot. i got i think i may have a releasable lens 1.3
00:55:59 <edwardk> heh s/woot. i got/
00:56:09 <tgeeky> edwardk: finally! what took you so long!
00:56:33 <edwardk> i completely rewrote all the template haskell, so it now generates full type signatures for isomorphism and lens families
00:56:41 <edwardk> and it makes isomorphisms when you apply it to a newtype
00:56:47 <edwardk> or to a data type with one constructor
00:56:59 <tgeeky> do you use that newtype class thing?
00:57:01 <tgeeky> I forget who wrote that
00:57:03 <edwardk> no
00:57:05 <edwardk> djahandarie
00:57:29 <edwardk> i've been talking to him about adding a combinator for using newtypes more easily with lenses
00:57:36 <edwardk> but it needs to live there, not here
00:57:49 <edwardk> fortunately he incurs no dependency on this to provide it
00:57:57 <Taneb> Is lens a replacement for data-lens?
00:58:07 <Taneb> As in, "should I switch"
00:58:18 <tgeeky> I think the switch will happen behind the scenes
00:58:35 <Taneb> Behind which scenes?
00:58:48 <tgeeky> i think edwardk maintains data-lens?
00:58:48 <Taneb> Because I'm behind at least 1 scene
00:58:52 <edwardk> Taneb: yes. my official release will be this weekend for hac phi, but its already far better than data-lens
00:58:53 <Taneb> Oh, that scene
00:59:03 <edwardk> i wrote data-lens, technically roconnor maintains it
00:59:17 <tgeeky> well, the pair of you are the current leaders of the lens revolution
01:00:01 <edwardk> uploading 1.3
01:00:06 <edwardk> now with moar laws
01:00:49 <edwardk> i even included all my lenses and traversals for doing things like alpha renaming and doing substitution for types into template haskell
01:00:55 <edwardk> figured they'd be useful to others
01:01:28 <tgeeky> plus inlining in template haskell is available in HEAD :O
01:01:35 <tgeeky> well, pragma passthrough
01:01:37 <tgeeky> but good enough
01:02:02 <edwardk> https://github.com/ekmett/lens/blob/master/src/Language/Haskell/TH/Lens.hs#L57
01:02:10 <edwardk> i think those turned out pretty
01:04:00 * hackagebot lens 1.3 - Lenses, Folds and Traversals (EdwardKmett)
01:04:16 <edwardk> i may ship a 1.4 where i extend the template haskell support to be able to do things like automatically compose with a 'HasFoo' lens for you, but the API overall shouldn't change much from here
01:07:32 <poincare101> haskell is awesome
01:13:02 * sopvop is ashamed of being "not smart enough". edwardk strikes again!
01:13:12 <edwardk> sopvop: ?
01:15:42 <sopvop> Yeah, I don't quite understand how lenses work :) Well, I can understand "pair of setter and getter", but all the IndexedStore, AppliedState things and comonds... What does it do? How can I use it myself? I'm clearly not smart enough :(
01:15:59 <edwardk> no comonads here any more =)
01:16:08 <edwardk> IndexedStore and AppliedState are implementation details
01:16:30 <edwardk> just look at the signatures above the, where i describe what you can pretend the types are
01:16:39 <edwardk> those are more useful for intuition
01:18:52 <sopvop> Implementation details is the most interesting part of every library. Well also design of API. :)
01:19:17 <edwardk> the idea is that everything in this library more or less looks like
01:19:27 <edwardk> (c -> f d) -> (a -> f b)   -- for some choice of f
01:19:34 <edwardk> the trick is picking the right f
01:21:01 <edwardk> since they all have that form, they all compose, as long as the 'f's agree
01:33:18 <Dybber> It doesn't seem like there are any GHC-binaries that works for Debian Wheezy (testing), except those in the Debian repository, and they create a lot of dependency problems for me. Those on the GHC website requires a version of libgmp that isn't available in Wheezy
01:33:30 <sopvop> BTW, excelent docs in Control.Lens
01:34:08 <edwardk> thanks
01:34:14 <edwardk> i still need more examples
01:34:45 <edwardk> but i've been going out of my way to force myself to keep my haddocks reporting 100% commented ;)
01:36:53 <vodik> im having some trouble. with attoparsecs, how do i collect input until the end of input or a particular character is hit?
01:38:00 <Taneb> Are there any things which are both Monads and Alternatives, but not MonadPluses?
01:38:41 <edwardk> off hand i don't have a counterexample, but there should be
01:39:10 <Taneb> The only way I can see this happening is if empty >>= f is not empty
01:39:54 <latro`a> that depends on there even being an empty
01:39:57 <latro`a> which isn't always the case
01:40:21 <edwardk> Monad + Alternative, not Applicative =)
01:40:26 <latro`a> oh
01:40:28 <latro`a> hm
01:40:33 <latro`a> ah, right, derp
01:40:42 <latro`a> in *that* case I suspect not
01:41:02 <latro`a> assuming the components play nice with *each other*, which *technically* they needn't, I guess
01:41:21 <latro`a> that is, they could satisfy their own laws but the Alternative and Monad instances could have different functions
01:41:29 <latro`a> (maybe)
01:41:33 <Taneb> Which I think would break the (>>= return) = id rule
01:41:33 <latro`a> (brainstorming)
01:41:48 <latro`a> empty has nothing to do with return, afaict
01:47:37 <Taneb> Or give you something from nothing
01:50:28 <latro`a> hm, maybe a stupid question
01:50:53 <latro`a> but about how much faster is code compiled by GHC than code interpreted by GHCi
01:50:53 <latro`a> ?
01:51:15 <edwardk> an order of magnitude or more
01:51:22 <edwardk> depends on what its doing
01:51:32 <edwardk> of course, if its just sitting there blocked you can't tell the difference
01:51:52 <edwardk> also ghci will use a lot of loaded libraries as object code so they'll be fast even if the surface thunks are slow
01:52:12 <Jafet> Usually I don't bother to find the answer to that question
02:27:33 --- mode: wolfe.freenode.net set +o ChanServ
02:29:03 * hackagebot lens 1.3.1 - Lenses, Folds and Traversals (EdwardKmett)
02:29:31 <edwardk> added some operations on folds and lists
02:35:09 <Taneb> Under further examination, Alternative laws seem few and far between
02:35:55 <typoclass> @hoogle Alternative
02:35:56 <lambdabot> Control.Applicative class Applicative f => Alternative f
02:36:09 <Taneb> It's in Control.Applicative
02:36:17 <typoclass> yup
02:37:43 <Taneb> Assuming it follows the Monoid laws...
02:38:10 <Taneb> empty <|> x = x
02:38:18 <Taneb> x <|> empty = x
02:38:36 <Taneb> x <|> (y <|> z) = (x <|> y) <|> z
02:39:21 <latro`a> is there any expectation that <|> has anything to do with pure/<*>?
02:39:25 <latro`a> erm
02:39:32 <latro`a> empty/<|> has anything to do with pure/<*>?
02:39:36 <Taneb> No, I do not think so
02:39:47 <edwardk> yes
02:39:57 <edwardk> there are laws for alternative
02:39:57 <latro`a> I figured as much, since there's an applicative constraint
02:40:08 <mcstar> hey
02:40:14 <Taneb> Hello
02:40:18 <edwardk> i have them around here somewhere
02:40:19 <mcstar> i did something stupid
02:40:38 <Taneb> We all do that from time to time, how stupid?
02:40:59 <mcstar> i had a nice fast ternary search tree, and then i did a batch insert function in ST, and now it is 7 times slower
02:41:10 <Taneb> :(
02:41:25 <latro`a> apparently GHC is a ninja
02:41:34 <latro`a> to turn pure code into better-than-ST code
02:42:10 <hpaste> mcstar pasted ‚Äúmea culpa‚Äù at http://hpaste.org/72473
02:42:46 <mcstar> my idea was that, i need to load up a whole dict into the tree
02:42:51 <Taneb> I remember an early version of family-tree used IORefs, Ir was awful.
02:42:51 <mcstar> so i would do it in st
02:42:59 <mcstar> and return a nice immutable tree as a result
02:43:27 <mcstar> so the ST part is the fromList function, above it is the non-st version
02:43:30 <mcstar> commented out
02:44:08 <mcstar> and there in an unST function, that takes a tree with nodes of strefs, and turns it into a tree of pure nodes
02:44:45 <mcstar> the motivation was, to gain speed, because i thought, i dont need to destructure the branches and build them up, as i insert the strings
02:44:57 * sopvop just realized what (a,(b,(c,d))) is much better than (a,b,c,d) most of the times.
02:45:01 <mcstar> i just need to pass the strefs, and modify them, as in an imperative language
02:45:14 <mikeplus64> sopvop: why?
02:46:45 <sopvop> It's like heterogenous list, and works pretty with fst,snd and dozens of other functions over tuples most of which operate on pairs
02:46:49 <mcstar> with the immutable version, there was a 50% GC time, so i thought i could improve on it
02:47:04 <mcstar> so, i welcome suggestions
02:47:51 <mikeplus64> sopvop: (fst . fst . fst) imo is not any nicer than (\(_, _, c, _) -> c)
02:48:13 <mcstar> fst .fst doesnt make sense
02:48:15 <danil> mcstar: how much does the mutable version cut down on allocation?
02:48:17 <mikeplus64> most of the time if you use a tuple you do actually want each individual elements though
02:48:22 <mcstar> mikeplus64: snd . fst
02:48:29 <mcstar> snd . snd . fst
02:48:30 <mikeplus64> mcstar: sorry, yes, snd . fst
02:48:46 <sopvop> You can always (_,(_,c,_)) if you rally need it, but otherwise you can always work on the head only
02:48:57 <mcstar> danil: all in all, gc time is around 60%
02:49:20 <mcstar> danil: but take a look at the unST function, i have to copy the state tree to un-state tree
02:49:21 <sopvop> or data a :. b = a :. b   and go for ( a :. b :. c :. d), but will need to make fst snd and other things
02:49:55 <mcstar> danil: yesterday, i was interested if it was possible to do this without Refs
02:50:27 <mcstar> is it possible to provide my own primitives in ST? like, the STRef is a primitive
02:51:22 <danbst> @pl (\x -> union x (obviousRelations x))
02:51:22 <lambdabot> ap union obviousRelations
02:52:02 <Taneb> danbst, union <*> obviousRelations looks nicer?
02:52:21 <danbst> Taneb, yes
02:54:03 <danil> mcstar: ST primitives are actually IO primitives that have been converted by unsafeIOtoST, so it's possible, but it doesn't actually buy you anything here
02:54:28 <Taneb> What does ST stand for?
02:54:37 <mcstar> state
02:54:39 <danil> state thread
02:54:42 <Taneb> Okay
02:55:01 <typoclass> ST is the thing that has nothing to do with multithreading, right?
02:55:05 <Taneb> And it's IO without the I or the O, right?
02:55:07 <mcstar> no
02:55:12 <Taneb> typoclass, I think that's STM?
02:55:12 <mauke> typoclass: no, that's State
02:55:18 <mauke> Taneb: wrong
02:55:29 <Taneb> mauke, I'm used to that
02:55:45 <mauke> STM has a lot to do with multithreading
02:56:20 <Peaker> STM - transactional memory.   State - (s -> (s, a))     ST - Local destructive-write-impurity
02:56:25 <Taneb> I meant that STM was the one he was thinking of and gets mixed up with ST?
02:56:55 <danil> typoclass: yeah, they're called state threads because ST s and ST t (for s /= t) are different threads/streams/sequences of computation that don't interact
02:57:06 <HugoDaniel> hmm
02:57:32 <mcstar> danil: i now have a record of fields of STRef, but what i had in mind, is to provide an STRecord, with mutable fields, but which arent STRefs
02:57:41 <mcstar> danil: like consider a mutable vector
02:57:54 <mcstar> the whole vector is mutable, the lements are not IORefs
02:59:04 <typoclass> yes, stm is transactional memory, i.e. it has plenty to do with multithreading. it's just that ST is described as "support for strict state threads", so it does sound like something vaguely forkIO-ish
02:59:19 <danil> if you put a newtype around an STArray that could work, but presumably you want nice things like fields of different types...
02:59:59 <mcstar> danil: but is it possible for me to define such a container?
03:00:06 <mcstar> or do i need to turn to an array
03:00:51 <mcstar> i guess, it is possible, but it would be hard, and it would use a lot of unsafe*
03:00:51 <danil> I don't know how STArray is implemented, but I don't think it's deep magic -- you could look at it and do something similar
03:01:36 <Taneb> Haskell's interesting in that some things that seem like deep magic are simple once you know what is going on
03:01:43 <mcstar> danil: what would really be nice, is to avoid the unST functions i have
03:01:55 <danbst> Guys, how can I determine, when the sequence stops changing? Eg, findLastValue [1,2,3,4,4,4,4,4...] == 4
03:02:17 <Taneb> Mathematically impossible, I think
03:02:17 <mauke> danbst: findLastValue = last
03:02:19 <mcstar> danil: because, the 2 kind of containers wouldnt be really represented differently in  memory, but one wold have ST other wouldnt, in its type
03:02:33 <Taneb> You could have [1,2,3,4,4,4,4,...,5,5,5,5...]
03:03:24 <danbst> oh, i mean not last value, sorry. Just know when sequence stops changing, its fixpoint. My sequence has always
03:03:26 <typoclass> > group [1,2,3,4,4,4,4] -- danbst, this may help. also have a look at groupBy
03:03:28 <lambdabot>   [[1],[2],[3],[4,4,4,4]]
03:03:52 <danil> mcstar: yeah, having the same in-memory representation is what you need
03:04:01 <mauke> danbst: findLastValue = last
03:04:26 <danbst> my sequence is infinite, last won't help
03:04:52 <mauke> danbst: you can't know whether an infinite sequence will stop changing
03:04:52 <latro`a> you can't determine even the ordinary limit of an arbitrary sequence in finite time
03:04:56 <mroman> Impossible.
03:05:03 <latro`a> much less the discrete metric limit (which is what you're asking for)
03:05:06 <mcstar> > let uniqepart (x:xs) = x: if head xs == x then [] else uniqepart xs in uniqepart [1,2,3,4,4,4,4,4]
03:05:07 <lambdabot>   [1,2,3,4]
03:06:17 <Taneb> > head . head . dropWhile (null . tail) . group $ [1,2,3] ++ repeat 4
03:06:19 <lambdabot>   4
03:06:21 <kuribas> Is this the main haskell-mode repository?   https://github.com/pheaver/haskell-mode
03:07:02 <Taneb> fromJust is kind of like head
03:07:18 <danbst> Taneb, yes. I thought there is concise way to do it
03:07:26 <Taneb> Hmm
03:07:48 <byorgey> kuribas: no, https://github.com/haskell/haskell-mode
03:08:32 <kuribas> byorgey: Ok, thanks!
03:08:55 <kuribas> byorgey: Could I get write permission on the repository?
03:09:18 <kuribas> (I wrote the first version of haskell-indentation.el)
03:09:26 <typoclass> kuribas: i think anybody can fork it and send pull requests and stuff?
03:09:40 <byorgey> kuribas: I don't know, I'm not the person to ask
03:10:13 <kuribas> typoclass: I see, I am not familiar with github.
03:11:48 <typoclass> kuribas: me neither :) but afaict, you can copy the repo into your own account quite easily, commit changes, and then press a button so the original guy is asked to review and pull in your changes
03:12:32 <mcstar> so the question is, are you an original guy?
03:13:07 <danbst> > find (curry (+)) . (\x -> zip x (tail x)) $[1,2,3] ++ [4..]
03:13:07 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
03:13:08 <lambdabot>         against inferred type ...
03:13:37 <kuribas> typoclass: I see.  That's quite convenient.
03:13:40 <mroman> fromMaybe @fromJust
03:13:44 <Taneb> If I could rewrite the core typeclasses of Haskell, everyone would hate me
03:13:50 <mroman> allows you to set a default value if it is nothing.
03:14:00 <typoclass> danbst: seems like a good idea, if you put in (==) instead of (+). also note that [4..] is [4,5,6,...]
03:14:14 <danbst> > find (curry (==)) . (\x -> zip x (tail x)) $[1,2,3] ++ [4,4..]
03:14:15 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
03:14:16 <lambdabot>         against inferred type ...
03:14:36 <danbst> > find (uncurry (==)) . (\x -> zip x (tail x)) $[1,2,3] ++ [4,4..]
03:14:38 <lambdabot>   Just (4,4)
03:15:18 <danbst> > fst . fromMaybe . find (uncurry (==)) . (zip <*> tail) $[1,2,3] ++ [4,4..]
03:15:19 <lambdabot>   Couldn't match expected type `(a, b)'
03:15:19 <lambdabot>         against inferred type `Data.M...
03:15:22 <Taneb> Because in my mind classes should just introduce a single thing, or a group of equivalent things
03:15:32 <mroman> > fst . fromMaybe . find (uncurry (==)) . (zip <*> tail)  $[1,2,3] ++ [4,4..]
03:15:33 <lambdabot>   Couldn't match expected type `(a, b)'
03:15:34 <lambdabot>         against inferred type `Data.M...
03:15:37 <mroman> > fst . fromMaybe 0 . find (uncurry (==)) . (zip <*> tail)  $[1,2,3] ++ [4,4..]
03:15:39 <lambdabot>   4
03:16:29 <Taneb> Is there an easier way of doing "class (Foo a, Bar a) => Baz a; instance (Foo a, Bar a) => Baz a"
03:16:32 <Taneb> ?
03:16:55 <danbst> mroman, thanks.
03:17:17 <danil> Taneb: with constraint kinds you can say "type Baz a = (Foo a, Bar a)"
03:18:11 <Taneb> danil, thanks
03:18:24 <mroman> Do you need the (Foo a, Bar a) => for the instance?
03:18:37 <Taneb> mroman, it's meant to be just a handy synonym
03:18:41 <mroman> Seems redundant as the class definition would already require that.
03:18:46 <Taneb> Oh, I see what you mean
03:20:14 <Taneb> mroman, you seem to
03:20:46 <Taneb> Neither work without FlexibleInstances, and only the verbose one works with that
03:25:07 <typoclass> doctest is the best thing since sliced things. but it seems to run the example code, do 'show' on the result, and then compare the result String with the expected String. am i the only one finding that weird?
03:25:12 <typoclass> ( https://github.com/sol/doctest-haskell#readme )
03:26:26 <typoclass> i mean as opposed to 'read'ing the expected String and doing (==) with the example code's result
03:26:59 <kuribas> Why can't the "then" be aligned with the "if" in this code?  http://trac.haskell.org/haskellmode-emacs/ticket/19
03:27:11 <irene-knapp> because that happens to not be how it works
03:27:23 <typoclass> kuribas: "then" usually needs to be aligned with "else", not with the "if"
03:27:25 <irene-knapp> it needs to be indented more, if it's not on the same line
03:27:57 <typoclass> i noticed the doctest thing because it judges "(37, 42)" to be different from "(37,42)"
03:29:41 <hpaste> kuribas pasted ‚Äúif then else indentation‚Äù at http://hpaste.org/72475
03:29:50 <kuribas> irene-knapp: That's simply not true: http://hpaste.org/72475
03:30:02 <Valk> is there a simple tutorial somewhere on using Data.Aeson for a newbie in Haskell?
03:30:21 <irene-knapp> I've always found it to be the case.  I admit I don't understand the details of the layout rule (I'm not sure anybody does)
03:31:18 <mcstar> there is no documentation for GHC.Base
03:31:35 <mcstar> are the stuff scattered around in GHC.* ?
03:32:45 <mcstar> i think the stuff is in GHC.Prim
03:35:16 <typoclass> kuribas: about the trac link, do you mean the "then" in the "too high" line or the "then" in the "too low" line?
03:35:53 <kuribas> typoclass: the "too high" line.
03:37:34 <kuribas> Maybe it has to do with nested ifthenelse's.
03:38:30 * kuribas is checking the report.
03:38:41 <mcstar> it can be aligned, emacs-mode doesnt do it, thats all
03:38:50 <mcstar> it is a bit more readable that way
03:38:59 <mcstar> haskell-mode*
03:41:04 <kuribas> mcstar: I tested it in ghci, and it gives a type error when aligned.
03:41:33 <kuribas> mcstar: So it does parse, but gives another meaning.
03:41:51 <mcstar> ill look at it again
03:44:34 <mcstar> kuribas: idk, it works for me for all kinds of indentations
03:44:43 <mcstar> you are doing something else
03:45:18 <hpaste> mcstar pasted ‚Äúok‚Äù at http://hpaste.org/72476
03:46:08 <Yuu-chan> Hello!
03:46:23 <kuribas> mcstar: Oh I see, I forgot to indent the doGuessing.
03:47:03 <Yuu-chan> Could anyone please help me with installing GHC properly? I have some troubles with missing libraries.
03:47:05 <Taneb> ArrowChoice is sort of like Cotensor
03:47:39 <Valk> where does the "Done" come from in this snippet: https://gist.github.com/985645 ?
03:47:59 <cleantc> how are pattern guards desugared? ex: "f | g0 ,p <- g1  = h"
03:48:55 <mcstar> @hoogle Done
03:48:55 <lambdabot> Network.HTTP.Base Done :: ResponseNextStep
03:48:55 <lambdabot> Control.Parallel.Strategies type Done = ()
03:48:55 <lambdabot> Test.QuickCheck.Test doneTesting :: State -> (StdGen -> Int -> Prop) -> IO Result
03:49:21 <Jafet> How does ghc desugar them? It probably writes them with case
03:49:42 <hpaste> typoclass annotated ‚Äúif then else indentation‚Äù with ‚Äúif then else indentation (annotation)‚Äù at http://hpaste.org/72475#a72477
03:49:52 <Jafet> case (g0, g1) of (True, p) ->
03:49:58 <Valk> yeah I checked it with Hoogle but none of those results seem to feet, or do they?
03:50:14 <typoclass> ^^ it seems to depend on the "do". that said, it's weird. i find it confuzzling
03:50:27 <Yuu-chan> I have Centos 6 and had to install a generic Linux package. When I try to launch even ghci, it says it ´can't load .so/.DLL for: libgmp.soª, but this library is installed.
03:50:35 <Jafet> Valk: import that file into ghci and :i Done
03:51:00 <Valk> "Not in scope: data constructor `Done'"
03:51:16 <Jafet> Yuu-chan: you probably have the wrong version or libgmp has a different filename
03:51:19 <typoclass> valk: try ":t Done" to get the type
03:51:32 <Valk> same response
03:51:41 <mcstar> data.attoparsec
03:51:44 <mcstar> obviously
03:51:58 <cleantc> Jafet: then the question is how the following is desugared: "case x of y | g0, p <- g1 -> h"
03:52:07 <Jafet> It is undoubtedly from Data.Aeson, because that's the only thing you import unqualified
03:52:13 <danbst> @pl fx (a:b) = if (head b) \\ a == [] then a else fx b
03:52:13 <lambdabot> (line 1, column 10):
03:52:13 <lambdabot> unexpected "="
03:52:13 <lambdabot> expecting variable, "(", operator or end of input
03:52:13 <mcstar> no
03:52:30 <Valk> thanks, mcstar!
03:52:33 <typoclass> valk: are you sure that you have done ":l yourfile.hs"?
03:52:41 <Jafet> Oh, (..)
03:52:45 <Valk> typoclass: yes
03:52:53 <danbst> @pl fix (\f (a:b) ->  if (head b) \\ a == [] then a else f b)
03:52:53 <lambdabot> (line 1, column 31):
03:52:53 <lambdabot> unexpected "\\"
03:52:53 <lambdabot> expecting variable, "(", operator or "then"
03:53:07 <mcstar> http://hackage.haskell.org/packages/archive/attoparsec/latest/doc/html/Data-Attoparsec-Types.html
03:53:12 <danbst> @pl (\f (a:b) ->  if (head b) \\ a == [] then a else f b)
03:53:12 <lambdabot> (line 1, column 27):
03:53:12 <lambdabot> unexpected "\\"
03:53:12 <lambdabot> expecting variable, "(", operator or "then"
03:53:24 <Yuu-chan> Jafet: how can I check that? ldd ghc says ´libgmp.so.3 => /usr/lib64/libgmp.so.3 (0x00007f2b2a2b9000)ª and the .so is there.
03:53:24 <typoclass> danbst: lambdabot is also available in private chats :)
03:53:40 <Valk> apparently I had to change the "Result(..)" to "IResult(..)" in importing Data.Attoparsec. thanks again
03:53:49 <danbst> typoclass, how to do that???
03:53:59 <Jafet> cleantc: dunno
03:54:03 <mcstar>  /query lambdabot
03:54:10 <typoclass> danbst: yes, what mcstar said
03:54:12 <Jafet> I guess you can read the ghc core
03:54:27 <danbst> thanks!!
03:54:53 <Jafet> It will use case in some way, because that's what core has
03:55:32 <Jafet> typo: I'm only surprised the first one is ok
03:55:52 <typoclass> Jafet: yeah exactly
03:56:02 <Jafet> I would guess because if_then_else_ is magical
03:56:22 <Jafet> do, let, case etc. should all give the same result
03:57:27 <cleantc> semantically, aren't the two equivalent ?   "case x of y  | p <- g1  -> h"   ---> "case x of y -> let p = g1 in h"
03:57:36 <typoclass> i also find it hard to explain to newbies that there's those strange little differences inside a do block vs. outside ...
03:58:23 <Botje> cleantc: with PatternGuards, the match on p might fail
03:58:35 <t7> is there a name for this \x -> x ^ x
03:58:44 <Jafet> @google tetration
03:58:45 <lambdabot> http://en.wikipedia.org/wiki/Tetration
03:58:45 <lambdabot> Title: Tetration - Wikipedia, the free encyclopedia
03:59:06 <Jafet> No wait
03:59:15 <cleantc> Botje: correct
03:59:32 <Jafet> cleantc: I'm not sure if let is strict enough
04:00:20 <Jafet> > case () of () | True <- False -> ()
04:00:23 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
04:00:35 <Jafet> > case () of () -> let True = False in ()
04:00:36 <lambdabot>   ()
04:00:42 <Jafet> Now I am
04:02:09 <frerich> Is there a performance benefit in preferring pattern matching over guards (i.e. case expressions)?
04:02:36 <Jafet> They are desugared to the same thing
04:02:38 <cleantc> for typechecking,  are equivalent?
04:02:45 <t7> Jafet: whats the inverse ?
04:02:45 <Jafet> So probably no
04:02:46 <cleantc> *the two
04:03:03 <Jafet> t7: inverse of that function?
04:03:07 <t7> yeah
04:03:11 <Jafet> Probably something involving lambert W
04:04:55 <t7> like if i wanted to write a bignum library, if each block was 2 ^ 64, then the max number for a block would be the inverse-tetration for 2^64 ?
04:05:03 <Jafet> It's not tetration
04:05:41 <t7> hmm
04:06:51 <Jafet> Well, rewrite it as exp (x * log x) and kick it until the lambertw falls out
04:08:23 <Yuu-chan> Jafet: installing gmp-devel helped. Thanks anyway :)
04:09:03 <Jafet> centos must be a strange land
04:09:46 <Yuu-chan> It still doesn't have haskell packages in public repositories :(
04:09:50 <Jafet> t7: You can kick it to mathematica, though that might not work very well in a .cabal file
04:10:28 <Jafet> > 16^16 == 2^64
04:10:29 <lambdabot>   True
04:10:40 <t7> mathmatica isnt free software
04:11:16 <t7> well actually i need the inverse of 2 ^ 64 - 1 ?
04:11:21 <t7> 15 ^ 15 then
04:12:03 <Jafet> Wait, what is maximum number of a block
04:12:10 <t7> 2 ^ 64
04:12:21 <typoclass> t7: what are you trying to calculate? i've lost track
04:12:42 <t7> - 1
04:12:56 <Jafet> You want to find the logarithm of the number of 64-bit blocks that will fit in 2^64 bytes?
04:12:56 <t7> 2 ^ 64 is the number of different vlaues of a block :)
04:13:27 <t7> i want to know the maximum number i can exp by itself that is less than 2 ^ 64
04:13:41 <Jafet> That's 15 then
04:14:34 <mcstar> 2^64 == 16 ^ 16
04:14:40 <mcstar> fyi
04:14:59 <mcstar> oh, you guys figured that out alrady, good job
04:16:02 <Jafet> Mathematica is a cool guy, eh solves equations and doesn't afraid of ProductLog
04:16:34 <t7> but your freedoms?
04:16:37 <mcstar> i like its notebook
04:16:38 <typoclass> a cool guy, eh :-)
04:16:50 <mcstar> but wolfram is delusion, id rather not use his product
04:16:57 <mcstar> delusional*
04:17:03 <t7> RMS thinks its unethical
04:17:55 <Jafet> So call some other guy to solve your equation.
04:18:27 <t7> maybe RMS can solve it
04:19:35 <mcstar> ArrayRef seems to be deprecated, whats a replacement package?
04:20:00 <mcstar> ghc-6.10
04:20:04 <mcstar> that was ages ago
04:20:18 <mcstar> i want resizable arrays
04:20:48 <t7> use realloc
04:21:43 <mcstar> t7: why dont you try to figure out exponentiation instead?
04:22:19 <t7> im trollan lel
04:26:52 <dmwit> IORef IOArray?
04:27:22 <dmwit> But yes, I've wondered why MArray's getBounds returns a monadic value when all of the implementations are pure.
04:29:19 * hackagebot tup-functor 0.2.0.1 - Homogeneous tuples (BalazsKomuves)
04:36:14 <mcstar> dmwit: lol @ your mugshot on your site
04:36:41 <dmwit> =D
04:36:46 <mcstar> very addictive
04:36:55 <dmwit> My wife's idea. =)
04:46:44 <t7> should i be using elliptic curves over prime fields ?
04:47:05 <t7> or binary field
04:48:44 <t7> prime field looks nicer
04:49:44 <Jafet> We're in haskell, so performance is out the window anyway
04:49:58 <t7> its 2012
04:50:05 <t7> i have a quadcore smartphone
04:53:09 <Botje> t7++ # that's my catchphrase too!
04:54:13 <typoclass> "use more c. those tripled development times are totally worth the 0.4 s saved at runtime."‚Ñ¢
04:55:36 <Athas> And even if you have hard real-time requirements, there's always Functional Reactive Programming!
04:55:59 <Athas> (That's code for "Haskell that outputs a C program".)
04:56:24 <Dustin> Everyone, I have a question. I was looking on the Haskell wiki, and it says you cold use the fold function with + by doing
04:56:26 <Dustin> fold (+) [1,2,3,4,5]
04:56:40 <Dustin> I tried that in Haskell, and it doesn't work
04:56:56 <rtharper> > foldr (+) 0 [1,2,3,4,5]
04:56:57 <lambdabot>   15
04:57:06 <Dustin> Oh
04:57:08 <rtharper> :)
04:57:46 <Jafet> > let fold = foldr1 in fold (+) [1..5]
04:57:47 <lambdabot>   15
04:58:13 <t7> 3x¬≤ is that 3 * x ^ 2 or (3 * x) ^ 2 ?
04:58:29 <t7> i guess the first?
04:58:29 <mcstar> lol
04:58:38 <mcstar> t7: no the latter
04:58:39 <mcstar> im sure
04:58:41 <mcstar> very sure
04:58:42 <typoclass> Dustin: could you give us the link to the haskell wiki page? we need to correct that, "fold" is not a function in the standard library (only foldr, foldr1, foldl, etc.)
04:58:45 <mcstar> jesus
04:58:54 <t7> mcstar: but bodmas ?
04:59:15 <t7> fucking retarded notation
04:59:21 <Dustin> rtharper thank you, that does work. (here is the page I found the code on http://www.haskell.org/haskellwiki/Fold)
04:59:21 <mcstar> sometimes im not in the mood for trolls
04:59:30 <Botje> t7: ^ binds harder than *
04:59:58 <typoclass> t7: yes, square the number first, _then_ multiply by 3
05:00:53 <Yuu-chan> > 3 * x ^ 2
05:00:54 <lambdabot>   3 * (x * x)
05:02:57 <Yuu-chan> Btw, why is foldl in Prelude and foldl' is hidden in the Data.List?
05:03:32 <typoclass> Yuu-chan: good question. it might be better if that was reversed
05:04:33 <rtharper> Dustin: you'll note that's not valid haskell, that's given later on
05:05:59 <Dustin> Oh, so it's meant to be pseudocode?
05:06:53 <typoclass> rtharper: yeah, but it's kind of misleading in my opinion. it's formatted to look the same as the code later on (it's not just put in the running text inside quotes, for example)
05:07:02 <rtharper> typoclass: yeah
05:07:16 <rtharper> feel free to change it =)
05:08:36 <typoclass> rtharper: yup i will :)
05:12:02 <kallisti> hm, why can't you declare implicit parameters in the top-level of a module?
05:17:05 <kallisti> has anyone attempted to write a "debug monad"?
05:17:23 <Taneb> Writer [String]?
05:17:27 <kallisti> basically a monad transformer that injects trace statements in >>=
05:18:12 <typoclass> kallisti: good question on the top-level implicit params. but what you can do is this: suppose you have a lot of functions with an implicit ?verbose :: Bool, you can make a function "quiet :: ((?verbose :: Bool) => a) -> a", which you can then use like "main = quiet $ do stuff stuff stuff", where "stuff" are the users of the ?verbose flag
05:18:48 <typoclass> er, quiet's implementation is just "quiet f = let ?verbose = False in f"
05:19:08 <typoclass> (btw, the module with the "main = quiet $ do ..." doesn't even need XImplicitParams enabled that way)
05:19:14 <kallisti> hm, actually I'm not sure that such an automatic tracing mechanism is possible without requiring a Show/Typeable instance.
05:21:12 <kallisti> it would be nice if Debug.Trace had a trace function that works on arbitrary values, regardless of a show instance
05:21:16 <typoclass> ... erm ... you know the feeling when you thought the code is quite clear and neat, and then you explain it to someone, and it all seems weird and reckless
05:21:25 <kallisti> I think you would only want it to work correctly with -prof enabled though
05:21:30 <Taneb> kallisti, I would really go for Writer [String]. The automation isn't possible without something like hex dumping
05:22:05 <typoclass> kallisti: i think "trace" in fact has no constraint Show a, but of course it doesn't output the a's to stderr
05:22:42 <kallisti> typoclass: traceShow does, which is what you would need to use to display "arbitrary values"
05:22:50 <kallisti> except they're not quite arbitrary enough.
05:22:54 <kallisti> for a Monad instance
05:23:16 <typoclass> kallisti: that's true, the regular "trace" is basically id as far as the 'a' value is concerned
05:24:05 <kallisti> typoclass: I'm talking about a monad that does something similar to join traceShow everytime you use >>=
05:24:53 <_flow_> Is it possible to give ReaderT an parameterized type as environment? I try someting like http://hpaste.org/72474
05:24:57 <typoclass> yeah. i like the idea of this Debug monad. could we somehow have a class that has instances for everything under the sun, and given something Show'able shows it, and otherwise just outputs at least the line number or something?
05:25:26 <Taneb> Perhaps ContT (Writer [String]) (not what you are talking about but similar)
05:25:52 <kallisti> typoclass: that's my question. I don't think it's possible unless there's some kind of unsafeCoerce hack.
05:26:00 <kallisti> which would of course be GHC dependent
05:26:09 <Taneb> Actually, MaybeT (Writer [String]) would be best
05:26:33 <typoclass> Taneb: you mean so you can exit prematurely by giving a Nothing?
05:26:37 <t7> grrr this paper never explained how to multiply a scaler by a point on an elliptic curve...
05:26:40 <Taneb> typoclass, yeah
05:26:52 <Taneb> If everything goes horribly wrong
05:27:04 <Taneb> And you record a log using the Writer
05:27:21 <t7> oh yes it did
05:27:38 <Taneb> oh no it didn't
05:27:38 <kallisti> Taneb: the idea is that you just through a runDebug somewhere and it automatically adds trace statements to everything else without requiring any modification
05:27:47 <Taneb> t7, it's behind you!
05:27:47 <kallisti> s/through/throw/
05:28:03 <Taneb> I'm not sure that's possible... :(
05:28:30 <Taneb> Unless you had an isInstance predicate?
05:28:53 <typoclass> er, i'm confused. can we have an "instance (Show a) => A a" that catches everything that has a Show instance? we can't right?
05:29:04 <kallisti> a isn't a parameter of the typeclas
05:29:09 <kallisti> it's class Monad m where ...
05:29:22 <kallisti> (unless you can do something with scoped type variables but I don't think you can)
05:29:51 <Taneb> There may be something template haskelly
05:30:17 <typoclass> kallisti: no, i meant on a hypothetical typeclass "A" that i brilliantly will start to invent before failing pathetically
05:30:48 <Taneb> You can, typoclass
05:30:48 <kallisti> typoclass: you can, but it'll overlap with any other class constraint
05:31:02 <kallisti> which isn't a big deal if that's the only constraint you want ever.
05:31:16 <kallisti> interpolatedstring-perl6 has such a Show a  instance.
05:32:20 <typoclass> _flow_: could you add ghc's error message to your paste? to me it kinda looks like it should kinda work
05:32:46 <kallisti> Taneb: you could trace everything at the module level under the assumption that literally every value either has a Show, Typeable, Generic, etc  instance
05:32:58 <kallisti> via rebindable syntax
05:33:16 <kallisti> and redefining >>= to use a different typeclass
05:33:26 <Taneb> I was thinking the other day about something like foo :: Not Show a => a -> String
05:34:00 <_flow_> typoclass: I seems that I want a parameterized monad. I have added the ghc messages
05:35:08 <kallisti> _flow_: don't use class constraints in newtype/data declarations
05:35:32 <kallisti> _flaw_: what are you attempting to make possible?
05:35:36 <kallisti> *flow
05:36:00 <kallisti> _flow_: or rather, what would this hypothetical feature allow you to do?
05:36:36 <kallisti> if you just want a class constraint on a parameter of your monad
05:36:42 <kallisti> then you can just explicitly add constraints to it
05:36:46 <Dustin> Everyone, to import the Char module is import Char, right? Because I'm trying to use toUpper, and it's still not working even after import Char
05:36:48 <kallisti> you'll need to do that anyway
05:36:57 <kallisti> Dustin: it's import Data.Char
05:37:39 <hpaste> typoclass pasted ‚Äúcrazy idea about the Debug monad‚Äù at http://hpaste.org/72482
05:37:44 <kallisti> Dustin: but yes, the answer to your first question is "yes", it's just that you're importing the wrong module.
05:38:05 <kallisti> typoclass: the requires overlapping instances
05:38:07 <typoclass> ^^ that's what i meant ... not sure :-/ i bet it requires all sorts of dangerous extensions
05:38:10 <Dustin> Thank you kallisti, and thank you all for your patience (this is my second day of ever using Haskell)
05:38:51 <kallisti> typoclass: this typeclass doesn't alleviate the need to insert manual trace statements
05:38:53 <ksf> Dustin, now it's too late. an hour would have been safe, but now you're irrevokably addicted.
05:39:17 <kallisti> typoclass: I'd rather use join traceShow than stringify
05:39:32 <typoclass> kallisti: the point is, the hypothetical Debug monad could then rely on stringify
05:39:36 <_flow_> kallisti: Well I have MConf Mstate made a parameterized type. My programm has an datastructure that is basically an Map and I want different implementations to be possible. Kind if Map interface and the implementations in java
05:39:42 <kallisti> typoclass: it can't
05:39:47 <kallisti> because it needs the Debuggable constraint
05:39:55 <kallisti> typoclass: if that were the fix, then I could just rely on a Show constraint
05:40:06 <kallisti> and have an instance Show a where ..
05:40:24 <typoclass> right, got you
05:41:14 <kallisti> _flow_: so you want a typeclass for your "Map" interface
05:41:22 <kallisti> is that BE?
05:41:36 <_flow_> yes
05:42:05 <kallisti> _flow_: okay. so take the BE b constraint out of your newtype
05:42:11 <kallisti> and when you need to use this map-like interface
05:42:18 <kallisti> add the constraint to the individual function that uses it
05:42:54 <kallisti> the problem you're having is that generalized newtype deriving doesn't know how to handle your constraint
05:42:57 <kallisti> but it doesn't /need/ to handle it.
05:43:06 <kallisti> there's absolutely no reason that the BE constraint needs to be on the newtype.
05:43:19 <kallisti> instead you'd have
05:43:43 <kallisti> newtype M b a = M (ReaderT (MConf b) (StateT (MState b) IO) a)
05:43:58 <kallisti> and then when you have some function that needs to access the BE interface
05:44:08 <Taneb> That looks ridiculous
05:44:26 <t7> @hoogle (a -> a) -> a -> [a]
05:44:27 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
05:44:27 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
05:44:27 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
05:45:02 <kallisti> _flow_: myfunc :: (BE b, MonadReader (MConf b) m) => String -> String -> Int -> m Bool
05:45:13 <kallisti> or just
05:45:29 <kallisti> _flow_: myfunc :: BE b  => String -> String -> Int -> M b Bool
05:45:45 <_flow_> kallisti: thanks I seems just reversing a b did the trick
05:45:56 <kallisti> _flow_: but you also don't need the class constraint there
05:46:06 <kallisti> the fact that it compiles doesn't mean you should be doing it like that. ;)
05:46:16 <_flow_> true :)
05:46:39 <kallisti> _flow_: and yeah the "result" parameter of the monad is always the last parameter
05:47:28 <kallisti> though it would be cool if we had type lambdas of some kind...
05:47:59 <kallisti> instance Whatever b => Monad (\a -> M a b) where ...
05:49:36 <kallisti> _flow_: putting a typeclass into the newtype or type declaration directly actually doesn't give you anything
05:49:44 <kallisti> you still need to explicitly declare the constraint in functions
05:50:10 <kallisti> and if you don't add the constraint everywhere (even if it's not needed) then it will be a type error.
05:50:55 <kallisti> essentially if you have newtype (B a) => M a = Stuff
05:50:59 <kallisti> and
05:51:25 <kallisti> f :: Int -> M (Map String String)
05:51:38 <kallisti> the B constraint is not implied
05:51:52 <kallisti> the newtype only /requires/ that the constraint exists, it doesn't imply it automatically.
05:53:12 <Taneb> :t let f :: Show (a -> b -> a) => (a -> b -> a) -> Int; f c = length (show c) in f
05:53:13 <lambdabot> forall a b. (Show (a -> b -> a)) => (a -> b -> a) -> Int
05:54:32 <kallisti> Taneb: confused about why that's not an error?
05:54:42 <Taneb> Nah, just playing around
05:57:21 <kallisti> _flow_: so, to emphasize why this is bad, if any function in which you use the M type doesn't also have a BE constraint on the first parameter to M, it won't type.
05:58:05 <_flow_> kallisti: I guess that's why I've been addin the BE constraint in the last few minutes to my code
05:58:05 <kallisti> so you need to add explicit BE constraits because they wouldn't otherwise be implied.
05:59:05 <kallisti> taking the BE constraint out of the newtype declaration however, allows this to type properly:  f :: Int -> M b Bool
06:00:27 <kallisti> and also lets this compile:  f :: BE b => Int -> b Bool
06:00:35 <kallisti> s/compile/type/
06:00:52 <kallisti> *M b Bool
06:00:55 <kallisti> oppse
06:15:01 <t7> how do i find the Modular_multiplicative_inverse using extended gcd ?
06:15:06 <t7> wikipedia isnt very clear
06:16:36 <t7> oh just "fst . extgcd" ?
06:17:19 <Athas> Is there a nice haskell-mode for getting type information?
06:17:47 <Athas> I'd be perfectly satisfied with only showing the types of imported definitions, which should be easy.
06:18:27 <malthe> hey guys
06:18:28 <malthe> why do I get Expected type: [Distribution.TestSuite.Test], Actual type: [test-framework-0.6:Test.Framework.Core.Test]
06:24:21 <Saizan> malthe: you have different versions of test-framework installed and you're mixing them
06:27:50 <statusfailed> Is there an easy way to create a numeric type constrained to a certain range?
06:28:03 <statusfailed> e.g., an Integer constrained to 0-100
06:28:05 <malthe> hmm "Continuing even though the plan contains dangerous reinstalls."
06:28:45 <DKordic> statusfailed: Good question.
06:29:54 <Athas> statusfailed: not really, no.
06:30:15 <Athas> The problem lies in maintaining the range invariant when doing computations on it.
06:30:46 <Athas> What's the type of adding two range-constrainted integers?
06:31:03 <Athas> You could just do your computations modulo 100, of course, but I doubt that's what you need.
06:31:29 <t7> oh bugger it doesnt work
06:32:54 <malthe> Saizan, this is an empty cabal install; I get: http://pastie.org/private/a04ynztew9vduzxupujrw.
06:33:54 <malthe> so is it because this package is older than the base packages installed with the haskell platform?
06:34:06 <statusfailed> Athas: What about the Bounded class?
06:34:14 <statusfailed> Is that not a range constraint?
06:34:28 <statusfailed> Lots of types are members of that
06:35:13 <statusfailed> I would imagine the result of adding two Bounded numbers depends- but the aim of Bounded is to restrict the domain
06:36:02 <kuribas> Is it recommended to use tail-recursion for nonlazy functions?
06:37:20 <roconnor> kuribas: approximately
06:38:13 <Gurragchaa> Are there any online Haskell REPL's where you can define functions?  I'd like to start working on the 99 Haskell Problems, and I'm at a public terminal.
06:38:17 <Dustin> Ok, I have a question about SplitOn, I am trying this line,  splitOn ".." "a..b...c....d.." == ["a","b",".c","","d",""] which I found at http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html but it doesn't seem to be working, not even when I import Data.List
06:38:17 <Athas> statusfailed: Bounded is descriptive, not prescriptive.
06:38:45 <Athas> Defining something as an instance of Bounded doesn't do anything but "export" already-existing bounds.
06:39:01 <t7> after like 3 hours implementing my ECC DSA doesnt work
06:39:06 <t7> i have no idea why :(
06:39:39 <statusfailed> Athas: By that, do you mean it's just an indicator of what bounds should be, but doesn't restrict the domain?
06:39:52 <typoclass> Gurragchaa: have you tried http://tryhaskell.org ? you can do "let ... in ...", but i'm not sure about actually defining functions. alternatively: lambdabot is available in private chats and has "@let"
06:39:52 <statusfailed> oh wait, I get you
06:40:09 <Athas> statusfailed: yes.
06:40:28 <statusfailed> But, doesn't the question "what's the type of adding two range-constrained integerse" still apply to, say, Int?
06:40:47 <quicksilver> Dustin: you need to install the package split and them import Data.List.Split
06:40:47 <Athas> Yes, it does.  And for Int, the answer is that everything is modulo the maximum integer size.
06:40:56 <Athas> If that's what you want, it's possible to do.
06:41:30 <Gurragchaa> typoclass: tryhaskell.org doesn't let me define functions without "let.. in.."; I'll try privmsg'ing lambdabot
06:42:01 <statusfailed> Athas: actually, I guess I don't _want_ a Num instance- just Enum. Is there a way to generate "large" Enum classes?
06:42:17 <malthe> ok I think I get it; test-framework-quickcheck is outdated.
06:42:19 <Athas> statusfailed: what is a "large" class?  I'm not sure I follow you.
06:42:34 <nh2> is there an alternative to hGetContents that does not close the handle? I want to read "as much as has been written so far"
06:43:23 * ksf wants a list of a's that are interspersed with one or more b's and the whole thing preceded and succeeded by b's or not.
06:43:46 <ksf> in a type that's not a bugger to work with, if possible.
06:43:49 <statusfailed> Athas: Well, I want to write a sudoku solver, so each cell can have values "undetermined, [1..9]"
06:44:09 <statusfailed> Athas: but I don't want to type "data Cell = Undetermined | One | Two ..."
06:44:17 <statusfailed> can I generate an Enum instance somehow?
06:44:30 <Athas> statusfailed: that's what you have to do.  Make it an Maybe Int if you don't want to.
06:44:35 <ksf> statusfailed, just add a deriving clause.
06:44:38 <Athas> You can generate an Enum instance for that Cell type, yes.
06:44:44 <ksf> works unless your types are non-simple.
06:44:51 <ksf> s/types/constructors
06:45:13 <ksf> you can even say [Undetermined..Two], then.
06:45:46 <schovi> hello. Looking for module, which can remove diacritics from string. (√Å√âƒå to AEC). And in better way can do "parameterizing." ("S√≥me t√©xt w√≠th d√≠√°critics" -> "some-text-with-diacritics"). Thanks
06:45:57 <ksf> statusfailed, are you sure you want that 1..9 restriction?
06:46:18 <ksf> common sudokus might be constrained to that, but I bet that's because of humans, not because of the game.
06:46:37 <ksf> that is, Maybe Integer would be a splendid type.
06:47:58 <statusfailed> ksf: Well, it's just an example really, but what I want is to generate an Enum type of n elements.
06:48:18 <alpounet> Athas, have you tried ghc-mod?
06:48:22 <alpounet> it can do a bunch of stuffs
06:48:25 <alpounet> maybe it can do what you want
06:48:30 <typoclass> schovi: i guess that text-icu could help
06:48:39 <Athas> alpounet: yes, I'm trying it out.  It does some things.
06:48:58 <schovi> typoclass: thanks. gonna look
06:48:59 <Gurragchaa> typoclass: how do you undefine a function you've defined in lambdabot? [i.e. having made an errour in a function definition]
06:48:59 <alpounet> Athas, if it doesn't do what you want, i'm pretty sure you can extend it so that it does
06:48:59 <Athas> It chokes on others, though, because it insists on compiling the current file for most operations.
06:49:43 <eusebio> Can I generate a html-link with matplotlib?
06:49:49 <eusebio> Like with google charts api?
06:51:40 <typoclass> Gurragchaa: i think it's @undef to delete everything
06:51:46 <typoclass> ^^ does anyone else know?
06:52:42 <Cale> tryhaskell.org doesn't use lambdabot for evaluation
06:52:50 <DKordic> statusfailed: What is the best solution you currently have?
06:52:59 <Cale> oh, perhaps I misunderstood
06:53:01 <Cale> @undefine
06:53:14 <Gurragchaa> does lambdabot support recursion?
06:53:23 <Cale> sure
06:53:26 <Gurragchaa> I'll put my code on pastebin, perhaps I'm doing something wrong
06:53:54 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in (take 5 evens, take 5 odds)
06:53:55 <lambdabot>   ([0,2,4,6,8],[1,3,5,7,9])
06:53:56 <Gurragchaa> or rather, the one in the topic
06:54:05 <Cale> ^^ even mutual recursion :)
06:54:27 <statusfailed> DKordic: create a type wrapping an Integer, manually create the instance for Enum
06:54:30 <hpaste> Gurragchaa pasted ‚Äúincorrect recursion‚Äù at http://hpaste.org/72490
06:54:47 <nand`> Gurragchaa: has to be in the same definition
06:54:54 <nand`> Gurragchaa: @let myLast x =x; myLast (x:xs) = myLast xs
06:55:11 <Gurragchaa> oh, I didn't know you could use semicolons like that, thanks
06:55:14 <nand`> note that defining it this way will make the latter definition redundant
06:55:17 <nand`> since x always matches
06:55:18 <Cale> also, myLast x = x means that for every list x, myLast will just produce x as the result
06:55:24 <Cale> yeah
06:55:47 <Cale> you probably meant to write  myLast [x] = x
06:55:49 <nand`> (and if you swap them, the result is always [])
06:55:52 <quicksilver> Athas: it's pretty hard to calculate types without compiling the file...
06:56:16 <DKordic> statusfailed: What about modulo arithmetic?
06:56:17 <Athas> quicksilver: it's pretty trivial do calculate the types of imported names, though, and that's really what I need.
06:56:31 <quicksilver> Athas: but you might shadow them with local names
06:56:39 <statusfailed> DKordic: I'm not making the type an instance of Num
06:56:51 <Athas> quicksilver: that's an uncommon case that doesn't happen in my code.
06:57:03 <Athas> It seems like haskell-doc-mode should be able to do this, but I can't figure it out...
06:57:05 <quicksilver> Athas: it may not happen in your code but it isn't uncommon :)
06:57:21 <quicksilver> it's also not *that* simple to get the types of imported names as far as I know.
06:57:24 <LaughingMan> why isn't my default instance selected?
06:58:03 <quicksilver> what do you mean LaughingMan ?
06:58:22 <malthe> is HTF preferable over HUnit?
06:59:06 <LaughingMan> class C a where f :: ... in another module: instance C x where f = defaultImpl
06:59:11 <LaughingMan> the module is imported
06:59:30 <LaughingMan> but at runtime no instance nor default method error is thrown
07:00:19 <Cale> LaughingMan: Doesn't sound like it should happen from that description
07:01:40 <quicksilver> LaughingMan: you shouldn't get an error, but instances like that are useless.
07:01:52 <quicksilver> haskell doesn't support a notion of 'default instance'
07:02:04 <Cale> yeah, if it actually says "instance C x where", that's probably the issue
07:02:10 <quicksilver> but the error you *should* get is the overlapping instances error.
07:02:25 <LaughingMan> year Overlapping and Flexible is activated
07:02:34 <quicksilver> don't use Overlapping instances
07:02:38 <Athas> quicksilver: isn't there a command line tool to do that?  There's certainly an API.
07:02:44 <quicksilver> it's a bug disguised as a feature.
07:03:08 <quicksilver> the main bug with overlapping isntances is that they make people thing that default instance fallbacks will work, and they don't ;P
07:03:30 <LaughingMan> is it because the "default instance" is an orphan instance?
07:04:02 <LaughingMan> it would be useful (real-life code here)
07:04:06 <quicksilver> orphan instances are annoying for the compiler but they should work.
07:04:23 <quicksilver> that is, if imported/visible they should be found.
07:04:35 <quicksilver> I think you may need to show actual code and an actual error if you want an actual answer.
07:05:04 <Cale> yeah, it's a little too hard from this description to give any real advice and not just throw out generalities :)
07:05:41 <kennyp> firefox
07:05:46 <LaughingMan> class Simulation f where
07:05:48 <LaughingMan>     decision :: f -> DecisionFunction f
07:05:49 <LaughingMan>     trace :: f-> TraceFunction
07:05:51 <LaughingMan>     termination :: f -> TerminationFunction f
07:05:53 <LaughingMan> in module A
07:06:19 <LaughingMan> instance Simulation f where
07:06:21 <LaughingMan>     trace = const dumpToConsole
07:06:23 <LaughingMan>     decision = const alwaysFirstEvent
07:06:25 <LaughingMan>     termination = const consumeAllEvents
07:06:26 <Cale> no!
07:06:26 <LaughingMan> in module B
07:06:37 <Cale> Replace that f with an actual type
07:06:41 <Cale> in the instance head
07:07:26 <LaughingMan> no, wait I see the problem
07:07:32 <Cale> If you want those to be the default implementations of the methods, then put them in the class declaration
07:07:40 <LaughingMan> instance Simulation Sim where
07:07:41 <LaughingMan>     eventSources = const [eventsource0]
07:08:00 <Cale> oh, right
07:08:08 <Cale> you didn't define those in the Sim instance
07:08:12 <Spockz> Is it known who first coined the term `lenses' in the sense of Data Lenses where you can easily compose getters/seters?
07:08:18 <Cale> so they're going to be undefined
07:08:19 <LaughingMan> I somehow expected trace to b defined in the instance for Simulation Sim, but that doesn't make any sense
07:09:11 <edwardk> Spockz: benjamin pierce sites older references in his paper on boomerang, i didn't chase them very far
07:09:48 <LaughingMan> but its all or nothing
07:10:19 <Cale> LaughingMan: you may want to move the default method implementations into the class declaration for Simulation
07:10:40 <LaughingMan> I can't
07:10:40 <Cale> That'll make them apply to the Sim instance, and you won't need OverlappingInstances
07:10:44 <Cale> oh
07:10:48 <Cale> ?
07:11:01 <Cale> why not?
07:11:33 <LaughingMan> because the functions to implement them are in another module, which shouldn't be referenced from the module where the class is defined
07:11:40 <Cale> ah, okay
07:11:57 <Cale> yeah, then you're out of luck there, just make each instance refer to them
07:12:28 <LaughingMan> but default methods exist, thats a pitty
07:13:01 <Cale> Yeah, you just have to be able to bring those definitions into scope at the place where the class is defined.
07:15:27 <Spockz> edwardk: I think the oldest is http://dl.acm.org/citation.cfm?id=652535&CFID=133839028&CFTOKEN=31266791, and if you read the paper (http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf) then it suggests that it was already a known term by then because it doesn't contain a reference for lenses
07:15:41 <edwardk> yep
07:15:44 <simply-chris> edwardk: fyi - my new nick (poucet)
07:15:56 <cai> hello
07:16:00 <edwardk> heya poucet
07:16:26 <typoclass> hello cai
07:16:30 <edwardk> thats a different kind of lens
07:16:35 <edwardk> those lenses are catamorphisms
07:16:49 <Spockz> edwardk: but they can be composed
07:17:04 <edwardk> not with anything resembling similar properties
07:17:20 <edwardk> the term lens there refers tot he funny brackets
07:17:22 <akamaus> hi, can anyone suggest an api to get difference in time between two invocations of a function? Resolution of order of milliseconds would suffice.
07:17:35 <edwardk> as for the origin of _that_ notion of a lens it goes back to lambert meertens
07:17:57 <monochrom> oh, those lenses, and bananas
07:18:06 <typoclass> akamaus: you could always use getPOSIXTime, store it somewhere, call it again, and subtract ...
07:18:14 <typoclass> it's in Data.Time.Clock.POSIX
07:18:33 <Spockz> edwardk: aah, but I'm indeed not looking for those type of lenses :)
07:20:12 <akamaus> typoclass, thanks! I thought it would be in seconds.
07:20:26 <DKordic> statusfailed: What about 'newtype MyInt = MyInt Int'
07:20:49 <typoclass> akamaus: yeah it's a bit confusing. there's another similar function that indeed has only second-resolution (epochTime from System.Posix.Time or some such)
07:21:01 <Spockz> edwardk: I guess Pierce is the first then
07:21:10 <edwardk> spockz: http://dl.acm.org/citation.cfm?doid=1232420.1232424 is one source
07:21:22 <edwardk> but i had thought he cited someone, it may have been a self citation though
07:21:30 <nand`> @pl let (b, a) = l x in a (f b)
07:21:30 <lambdabot> (line 1, column 5):
07:21:30 <lambdabot> unexpected "("
07:21:30 <lambdabot> expecting "()", natural, identifier or "in"
07:21:41 <edwardk> since looking for it i cant find anything really older than 2005
07:21:46 <nand`> @pl (\(b, a) -> a (f b)) (l x)
07:21:48 <lambdabot> snd (l x) (f (fst (l x)))
07:22:57 <Spockz> edwardk: the one he cites is not talking about it in a FP setting
07:23:30 <Spockz> edwardk: do you mean: http://dl.acm.org/citation.cfm?id=1142399&CFID=133839028&CFTOKEN=31266791 ?
07:26:02 <edwardk> Spockz: http://www.st.cs.ru.nl/papers/2005/eves2005-FFormsIFL04.pdf at least highlights the functional reference technique, but they don't use the name lens
07:26:30 <roconnor> Spockz: to answer a slightly different question, kagawa in "Compositional references for stateful functional programming" is the oldest article that I found containing the lens laws as mathematical statements, though he calls a lens a "mutator" in that article, and he references earlier articles that also have the lens laws, but written as english prose.
07:27:54 <Spockz> roconnor: I could see how one would name them mutators though
07:29:21 <roconnor> Spockz: in fact it is probably a better name
07:30:18 <edwardk> that pushes it back to 1997
07:30:41 <Spockz> roconnor: as in that it mutates it input. But the idea of the term lens is to give the impression that you can stack / compose them
07:30:51 <edwardk> yeah
07:31:15 <roconnor> edwardk: that Ref data type in your link looks a bit odd
07:31:22 <edwardk> i prefer the lens name, even if we're somewhat disingenuous stealing it from dmwit and company over in benjamin pierce's camp
07:32:14 <edwardk> roconnor: its get/modify rather than get/set
07:33:06 <roconnor> disingenuous?
07:34:00 <Spockz> not candid or sincere, typically by pretending that one knows less about something than one really does.
07:34:07 <roconnor> Spockz: oh Kagawa calls it Mutable s t, not Mutator.  I misremembered
07:34:15 <edwardk> well, pierce used lenses to describe the bidirectional concept, and reserved 'very well-behaved lenses' for what we use
07:34:27 <roconnor> edwardk: okay
07:34:32 <roconnor> ya, I feel kind of bad about that
07:34:52 <roconnor> seems ripe for confusion and potentially long rants against functional programmers on SO
07:37:11 <Spockz> let's start a thread :D
07:38:15 <ksf> bloody hell can't parser writers distinguish between minimum and maximum munch.
07:38:52 <ksf> especially droll are those libraries that tend to have mixed munch. like readp.
07:41:59 <DKordic> Why is there no error when I try to do 'case of notInstanceOfEqTypeClass'.  For example ByteString.
07:42:56 <frerich> DKordic: I think it's because "case" deconstructs the value instead of testing for equality.
07:43:31 <frerich> DKordic: I.e. it looks which of the constructors was used to create the value instead of testing the value for equality with something.
07:43:52 <EvanR> it can also test for equality
07:44:07 <DKordic> There is "Warning: Pattern match(es) are overlapped" though.
07:44:12 <EvanR> 3 is a valid pattern for a num
07:44:52 <EvanR> hopefully your Eq instance has pattern matches as equal ;)
07:44:58 <Cale> > case reverse of x -> 5
07:44:59 <lambdabot>   5
07:45:05 <EvanR> maybe that should be a law
07:45:20 <frerich> EvanR: Maybe you could think of '3' being a value constructor in a sense (like 'data Int = ... -1 | 0 | 1 | ...')
07:45:25 <EvanR> yes
07:45:28 <EvanR> thats how it works
07:45:33 <EvanR> its not literally Eq (==)
07:45:53 <frerich> Hm I think that's a point where the "value constructors are just functions" mindset breaks: value constructors can be nullary, functions can't.
07:46:52 <EvanR> frerich: not all are functions
07:47:01 <EvanR> some are CAF
07:47:04 <EvanR> :t Just
07:47:05 <lambdabot> forall a. a -> Maybe a
07:47:09 <EvanR> :t Nothing
07:47:10 <lambdabot> forall a. Maybe a
07:47:20 <EvanR> :t (,)
07:47:21 <lambdabot> forall a b. a -> b -> (a, b)
07:47:35 <frerich> Yes, that's what I meant (I only recently read "Value constructors are just functions" in some part of LYAH but now I see that this isn't quite correct).
07:47:47 <EvanR> some are functions some arent
07:47:52 <hpaste> nand` pasted ‚ÄúVarious lenses, generalized to allow polymorphic updates‚Äù at http://hpaste.org/72493
07:48:11 <EvanR> frerich: is Nothing really a constructor ;)
07:48:17 <nand`> ‚ÄúI leave it as an exercise to the reader to generalize the other lens types.‚Äù <- challenge accepted
07:48:26 <EvanR> i guess so in pattern matching terminology
07:48:32 <n-dolio> Yes, it is a constructor.
07:49:13 <DKordic> frerich: I thought that constants can be interpreted as nullary functions.
07:49:26 <EvanR> i like to think of all functions have exactly one argument
07:49:32 <EvanR> not zero or one
07:49:42 <frerich> DKordic: Not really, in Haskell, functions always take one argument and yield one value. So a function value has a "->" in it's type.
07:49:45 <EvanR> 'nullary functions' are more specifically called CAFs
07:50:20 <nand`> canadian armed forces?
07:50:53 <roconnor> nand`: put . first f . get
07:50:54 <frerich> DKordic: There are no nullary functions - I think the closest would be a function which takes (and ignores!) its argument and always yields the same value. Actually, 'const' produces such functions.
07:51:22 <EvanR> continuous affine functor
07:51:49 <nand`> roconnor: nice
07:51:56 <EvanR> countable abelian field
07:52:40 <nand`> frerich: I would see ‚Äú() -> x‚Äù as a nullary function
07:52:43 <EvanR> frerich: not really close to a nullary function at all
07:53:01 <EvanR> > (\() -> undefined) 3
07:53:02 <lambdabot>   No instance for (GHC.Num.Num ())
07:53:02 <lambdabot>    arising from the literal `3' at <intera...
07:53:04 <nand`> (it actually makes sense if you consider ‚Äú(a) -> x‚Äù a function of arity 1, and ‚Äú(a, b) -> x‚Äù a function of arity 2)
07:53:05 <EvanR> > (\() -> undefined) ()
07:53:06 <lambdabot>   *Exception: Prelude.undefined
07:53:17 <frerich> nand`: Well except that it's not a nullary function, because it takes a value of type "()" :-)
07:53:31 <EvanR> nand`: and also if you consider () a tuple with nothing in it, and (a) as being valid haskell
07:53:51 <frerich> It's really simple - if it has " -> " in the signature, it's a function. Otherwise, it's not.
07:53:59 <nand`> (a) is valid Haskell
07:54:06 <EvanR> its not a tuple
07:54:26 <EvanR> data One a = One a
07:55:49 <nand`> I still think the analogy applies, even if it isn't a type
07:56:27 <EvanR> what is the arity of Either a b -> x ;)
07:56:36 <EvanR> i ?
07:56:43 <EvanR> 2i
07:56:47 <n-dolio> One.
07:57:08 <nand`> I'd think ‚Äòone‚Äô as well
07:57:10 <EvanR> tuples are thus a special type
07:57:16 <n-dolio> In languages that actually have functions with various arities, they're taking tuples. It's just baked in.
07:57:51 <n-dolio> Funcions of zero arity take zero tuples, etc. And a 'T' is a good enough approximation of a one tuple of 'T'. It's an unlifted tuple.
07:58:06 <roconnor> EvanR: it should be something like Log 2 arguments
07:58:14 <nand`> EvanR: in practice, ‚Äú(a, b) -> x‚Äù is a function of arity 1 as well, since all functions in haskell are that
07:58:17 <roconnor> EvanR: I'm not sure what the base of the logrithm is
07:58:32 <EvanR> heh
07:58:52 <nand`> that's why I said ‚Äòconsider‚Äô :P
07:59:26 <tromp_> > 4*11230495
07:59:27 <lambdabot>   44921980
07:59:29 <n-dolio> In math they actually take products, so 'T' is more analogous than all the other tuples.
08:00:19 <nand`> but what distinguishes (a,b) from a√ób? If you look at Hask, it fulfills all of the product laws
08:00:27 <n-dolio> No it does not.
08:00:31 <nand`> it does not?
08:01:09 <n-dolio> Eta fails.
08:01:38 <nand`> eta?
08:01:48 <n-dolio> p = (fst p , snd p)
08:03:04 <nand`> what breaks this? ‚ä•?
08:03:16 <EvanR> i need to get unicode working in screen
08:03:27 <n-dolio> I don't know what character that is, but the problem is undefined.
08:03:40 <nand`> ‚ä• = _|_ = bottom
08:03:59 <nand`> so yeah, undefined
08:04:48 <n-dolio> It's a box with 4 zeroes here, because my font is poor probably.
08:04:55 <nand`> perhaps
08:06:06 <n-dolio> Anyhow, that's not the categorical phrasing, but it's the problem.
08:07:10 <jfischoff> preflex: seen cads
08:07:10 <preflex>  cads was last seen on #haskell-blah 1 day, 11 hours, 31 minutes and 36 seconds ago, saying: it's awesome how fractals are everywhere in nature
08:16:04 <dgpratt> I remember coming across a graph recently (on reddit?) describing cross-language influence; does anyone know of that which I speak? I can't seem to find it
08:22:35 <allsystemsarego> @src Maybe
08:22:35 <lambdabot> data Maybe a = Nothing | Just a
08:24:34 <kallisti> it should be possible to safely convert an ST computation to STM, right?
08:24:59 <t7> roconnor: is http://r6.ca/Purecoin down?
08:25:22 <n-dolio> kallisti: It depends what you expect from it.
08:25:32 <DMcGill> To the people familiar with Cabal's internals: I have an InstalledPackageInfo and I need to turn it into a PackageDescription to give to Distribution,Simple.Haddock.haddock
08:25:44 <roconnor> t7: you need to use darcs get
08:25:55 <t7> i am :p
08:26:19 <t7> 403, quoteth the server
08:26:19 <DMcGill> surely a PackageDescription is a subset of a InstalledPackageInfo?
08:26:24 <roconnor> $ darcs get http://r6.ca/Purecoin
08:26:26 <roconnor> Copying patches, to get lazy repository hit ctrl-C...
08:26:27 <roconnor> Finished getting.
08:26:38 <allsystemsarego> @src Applicative
08:26:38 <lambdabot> class Functor f => Applicative f where
08:26:38 <lambdabot>     pure  :: a -> f a
08:26:38 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
08:27:25 <t7> roconner nand` gets 403 too :S
08:27:40 <t7> am i running the wrong version (2.8.1)
08:28:20 <Dustin> Everyone,  I have a question about cabal. Is cabal automatically installed when you install Haskell? How do you actually use cabal to install things? What directory do you have to be in in Command Prompt (I am on a Windows 7 machine)
08:29:02 <S11001001> Dustin: cabal is included with haskell *platform*, which is what you got if you followed the obvious install path on haskell.org
08:29:05 <roconnor> $ darcs --version
08:29:07 <roconnor> 2.4.4 (release)
08:29:08 <roconnor> hmm
08:29:10 <allsystemsarego> on ArchLinux I installed cabal-install separately from ghc
08:29:19 <roconnor> let me build a newer darcs
08:29:51 <S11001001> Dustin: I did this on windows, and have cabal in my path; check your PATH environment var for haskell stuff, which the platform installer should have put there, and restart cmd if you don't have it in cmd's environment
08:33:23 <Dustin> All right, it's going, thank you  S11001001
08:34:06 <kallisti> alwaysSucceeds is a weird thing to me.
08:34:21 <kallisti> why would you want to add a global invariant to every transaction?
08:38:26 <nh2> is there an alternative to hGetContents that does not close the handle? I want to read "as much as has been written so far"
08:38:50 <nh2> and I don't want to use hGetChar to read byte by byte
08:41:16 <monochrom> hGetContents does not close the handle until it hits EOF
08:41:52 <monochrom> but it doesn't tell you how much is immediately available either
08:42:43 <quicksilver> hGetContents is useless to nh2
08:42:48 <quicksilver> use hReadNonBlocking
08:42:50 <danr> is there a name for \ f x = f <*> pure x :: f (a -> b) -> a -> f b ?
08:42:53 <younder> I see a deligtful change  in HPC attitudes where MIMD, SIMD and larger capacity CPU's work together. This is the future I think.
08:42:54 <quicksilver> or whatever it's called
08:43:16 <danr> uh make that a -> rather than a =
08:43:49 <nh2> quicksilver: doesn't seem to be called like that. In which package shall I look?
08:44:02 <younder> It better works with Amhdals law. Mircot hreds will always be limited by overhead and
08:44:37 <monochrom> hGetBufNonBlocking
08:44:47 <younder> It better works with Amhdals law. Microthreds will always be limited by overhead and large irreductible chunks.
08:45:15 <quicksilver> nh2: hGetBufNonBlocking is the only (slightly clumsy) one in the base library.
08:45:24 <quicksilver> but there is also one in one of the bytestring IO packages
08:46:09 <monochrom> hGetNonBlocking in bytestring
08:46:11 <quicksilver> Data.Bytestring.hGetNonBlocking
08:46:15 <quicksilver> as monochrom said :)
08:47:25 <JaffaCake1> hGetBufSome is maybe what you want
08:47:37 <JaffaCake1> in GHC.IO.Handle.Text
08:47:54 <parcs`> @type flip -- danr ;)
08:47:55 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:48:02 <BrianHV> how can you tell if a double is divisible by 2 if you can't convert to/from integrals? (I'm using Fay)
08:48:17 <quicksilver> there is an hGetBufSome in System.IO too
08:48:32 <JaffaCake1> oh, did we put it there?
08:48:50 <t7> BrianHV: mod 2 == 0?
08:48:51 <younder> for crist sake use dbus in the gLib. That is portable and far better than this bit fiddeling
08:49:04 <JaffaCake1> right you are, that's a better place
08:49:05 <monochrom> is 2.00001 divisible by 2?
08:49:05 <BrianHV> t7: mod is an integral function
08:49:07 <t7> is 1.6 divisible by 2?
08:49:15 <BrianHV> no to both
08:49:21 <monochrom> I say yes. in fact, every Double is divisible by 2
08:49:29 <nh2> quicksilver, monochrom, JaffaCake1: I appreciate your responses!
08:49:36 <monochrom> isThisDoubleDivisibleBy2 = const True
08:49:40 <BrianHV> ha
08:49:52 <BrianHV> that doesn't help my zebra striping function. ;)
08:49:52 <nh2> the base haddoc is broken, though: http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/GHC-IO-Handle-Text.html
08:50:04 <monochrom> but really, is 2.000000001 divisible by 2? that's a thorny question for you.
08:50:10 <liyang> Is machine epsilon divisible by 2?
08:50:15 <t7> theres no round?
08:50:17 <younder> monochrom, only half :)
08:50:25 <nand`> @ask edwardk In your lens 1.2 you have type SimpleSetter a b = Lens a a b b; shouldn't this be = Setter a a b b ?
08:50:26 <lambdabot> Consider it noted.
08:50:26 <quicksilver> if you're checking doubles for divisibility by 2 you're probably doing it wrong.
08:50:40 <quicksilver> although checking it's withing epsilon of the nearest multiple of 2 might be sane, perhaps.
08:50:43 <BrianHV> quicksilver: in Fay, all numbers are doubles. at least at the moment.
08:50:56 <monochrom> yeah, if you use Double, you are unlikely to get perfect "2"s and "3"s all the time
08:50:58 <quicksilver> so why "can't you" convert to an integral?
08:51:01 <BrianHV> I'd be satisfied with that as well.
08:51:12 <BrianHV> quicksilver: because Fay hasn't implemented those functinos.
08:51:14 <BrianHV> functions*
08:51:25 <monochrom> you are more likely to get "1.9999999999" and "2.0000000001" all the time
08:51:26 <t7> BrianHV: use 'print' and some yucky string manip :)
08:51:31 <quicksilver> what is Fay?
08:51:42 <BrianHV> quicksilver: Haskell compiler that emits javascript
08:51:46 <t7> Haskell to javascript without custom type classes
08:51:48 <monochrom> Fay is chrisdone's haskell subset to be compiled to javascript
08:52:08 <quicksilver> and you can't use 'round' in it?
08:52:09 <nand`> hmm, can I undo an @ask? I was looking at an outdated package version
08:52:18 <monochrom> yeah javascript works on the "everything is floating point" level
08:52:37 <younder> monochrom, only half :) well actually since we use two complement there is exactly one more even number that odd and it is negative.
08:52:47 <quicksilver> nand`: you can just say @tell someone ignore that was looking at old version.
08:53:08 <danr> parcs`: is that Caleskel? :)
08:53:10 <nand`> @tell edwardk Ignore my previous message, you already fixed that in the newest version
08:53:10 <lambdabot> Consider it noted.
08:53:25 <int-e> monochrom: well it all depends on what you're doing. in particular, doubles make perfectly good 53 bit (plus sign) integers.
08:53:28 <danr> it's a nice way of viewing flip that I hadn't seen before, thanks
08:53:45 <BrianHV> quicksilver: my first attempt at doing that failed... but let me try something else
08:53:52 <hpaste> donri pasted ‚Äúwhich version does #haskell prefer?‚Äù at http://hpaste.org/72497
08:53:53 <monochrom> how do you check "divisible by 2" in javascript? do the same in Fay.
08:53:58 <danr> or maybe more confusing than nice...
08:54:46 <BrianHV> monochrom: you use %. I guess I could ffi out to javascript... that just makes the types all wacky.
08:54:59 <int-e> monochrom: (which, of course, is a less useful fact now that 64 bit computers are the norm.)
08:55:09 <monochrom> no, I mean translate the javascript code back to Fay
08:55:42 <BrianHV> % is an operator in javascript. the haskell equivalent would be mod, but it's not implemented.
08:55:45 <monochrom> well, I guess Fay doesn't give you floating-point mod like javascript does
08:55:52 <BrianHV> right
08:56:02 <monochrom> does Fay have floor?
08:56:08 <younder> Who said anything about unsigned
08:56:19 <BrianHV> monochrom: it seems to, but it gives me an integral type that I can't seem to do much with
08:56:35 <younder> unsigned is lovely, much mor tidy.
08:57:20 <monochrom> x - 2*floor(x / 2)  assuming x>=0
08:57:22 <quicksilver> I don't understand.
08:57:28 <quicksilver> Fay is a compiler for haskell.
08:57:41 <quicksilver> it may be *implementing* everything as double, behind the scenes
08:57:45 <monochrom> no, a subset of haskell
08:57:47 <quicksilver> but surely it "supports" haskell Int
08:57:55 <quicksilver> (even if it's compiling it to double in javascript)
08:58:03 <younder> http://en.wikipedia.org/wiki/Double-precision_floating-point_format
08:58:04 <quicksilver> otherwise nothing (take, length, drop) would work
08:58:16 <monochrom> well mod is not implemented yet and I don't know whether it will be
08:58:27 <younder> I feel like an idiot, thinking of long
08:58:30 <donri> quicksilver: well it's used with NoImplicitPrelude so it could have special versions of those i guess
08:58:42 <quicksilver> it could
08:58:44 <quicksilver> but does it?
08:58:45 <BrianHV> and div isn't implemented either...
08:58:50 <quicksilver> let us have facts, not speculation!
08:59:02 <quicksilver> I strongly suspect it supports Int (even if it doesn't support every operation on Ints)
08:59:06 <quicksilver> from what I hear.
08:59:59 <BrianHV> quicksilver: I've had limited success with Int in my type signatures. if the Ints stay very isolated, it seems to kind of do the right thing.
09:00:07 * quicksilver nods
09:00:22 <BrianHV> you just can't really do much with them
09:00:25 <quicksilver> but it supports round, and realToFrac?
09:00:41 <BrianHV> round, yes. let me check realToFrac.
09:00:46 <quicksilver> so you should be able to do x == round(realToFrac x / 2)
09:00:50 <quicksilver> as an even-ness test
09:00:50 <younder> well thhe link I gave sais it all, well mosat of it
09:00:55 <roconnor> t7:
09:00:58 <roconnor> $ /nix/store/mppdd39zib1ciz5hv350jjiqw2lap533-haskell-darcs-ghc7.4.1-2.8.1/bin/darcs get http://r6.ca/Purecoin
09:01:00 <roconnor> Copying patches, to get lazy repository hit ctrl-C...
09:01:01 <roconnor> Finished getting.
09:01:30 <BrianHV> realToFrac is not defined
09:01:42 <donri> quicksilver: it seems to export Integer but not Int
09:01:59 <donri> and no take, drop, length
09:01:59 <BrianHV> maybe I just need to pick an example that doesn't require math. ;)
09:02:11 <quicksilver> curious
09:02:13 <younder> there is no gereral conversion from real to frac without a precition
09:02:17 <quicksilver> but it's a work in progress.
09:02:19 <donri> should be noted fay is early devel
09:02:53 <monochrom> you can pick an example that requires math but not numbers
09:03:00 <quicksilver> I'm thinking string manipulation is the way, BrianHV :)
09:03:03 <BrianHV> and, frankly, this is why I'm doing this stuff. I'm trying to figure out where the pain points are at the moment.
09:03:06 <quicksilver> convert the number to string.
09:03:17 <monochrom> consider how "sets" is considered "data structure" but not "math"
09:03:22 <donri> so no one wants to comment on my hpaste? http://hpaste.org/72497 :(
09:03:27 <BrianHV> quicksilver: you may be right :)
09:03:31 <quicksilver> if the thing before the . is 2,4,6,8,0 and the thign after the dot is 0; OR the thing before the dot is 1,3,5,7,9 and the thing after the dot is 9, call it even.
09:03:57 <monochrom> to some extent, sets are even more mathy than numbers
09:04:13 <quicksilver> /([24680]\.0|[13579]\.9)/
09:04:17 <quicksilver> perhaps
09:04:23 <adnam> donri: 1st one is most readable to me
09:04:34 <quicksilver> although as a rule of thumb, if I type a regexp in this channel, mauke tells me it's wrong :)
09:05:02 <donri> adnam: yea i think i agree
09:05:28 * edwardk waves hello.
09:05:28 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:05:36 <younder> monochrom, Sets have place in computers which computes everything in sequences. Which I might add are just as general as sets
09:05:39 <mauke> quicksilver: redundant ( )?
09:06:10 <younder> monochrom, Sets have ^NO^ place in computers which computes everything in sequences.
09:06:12 <quicksilver> could be worse :)
09:07:46 <younder> Seriously set's make a awful basis as it is inefficient
09:07:56 <dhow119> j #/g/
09:08:24 <donri> younder: parMap? :(
09:11:08 <younder> Realize that verything that can be expressed by sets can (and is) represented by sequences. And that the sequence (array) is more natural to the computer
09:14:55 <younder> Category theory can be enlightening in this respect. It unambiguously represents the properties you need.
09:16:20 <roconnor> 403 is a redirect?
09:16:26 <younder> I recommend 'The categorical analysis of logic' by Robert Goldblat
09:16:35 <quicksilver> no, 403 is an error
09:16:42 <quicksilver> authentication normally
09:16:53 <donri> you shall not pass!
09:17:00 <younder> isn't that a HTTP error?
09:17:16 <roconnor> I have no idea why r6.ca would serve up a 403
09:17:28 <roconnor> must be some proxy?
09:18:19 <roconnor> nand`: do you want to try do debug this 403 error?
09:18:45 <krey_> o/, someone mentioned that when we say monad in haskell we really mean strong monad. can someone explain the difference?
09:19:35 <quicksilver> they mean that you can go from (a , m b) to m (a , b)
09:19:45 <quicksilver> it's a trivial property in the haskell setting
09:20:17 <quicksilver> but it is important in more general categories.
09:20:49 <quicksilver> :t \(x,y) -> do { j <- y; return (x,j) }
09:20:50 <lambdabot> forall t (m :: * -> *) t1. (Monad m) => (t, m t1) -> m (t, t1)
09:21:20 <mauke> :t uncurry (fmap . (,))
09:21:22 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
09:21:32 <byorgey> in fact you can go from (a, f b)  to  f (a,b)  for any Functor f.
09:21:41 <byorgey> ah, as mauke just demonstrated.
09:21:51 <younder> why would you uncurry a monad?
09:22:02 <mauke> younder: what does that even mean?
09:22:21 <younder> mauke, exactly
09:23:24 <younder> mauke, Oh sorry I misread
09:24:15 <krey_> thanks for the answers
09:24:21 <roconnor> oh I see why a 403 is returned; someone is trying to access a directory.  I don't see why darcs would do that.
09:24:23 <nand`> roconnor: let me amend my error: it fails with a 403 Forbidden if I open it in my browser, but ‚Äòdarcs get http://r6.ca/Purecoin/‚Äô works fine
09:24:31 <hpaste> Gurragchaa pasted ‚Äúgurragchaa 's second error‚Äù at http://hpaste.org/72498
09:24:41 <roconnor> nand`: ah good.  That is the way it is intended.
09:24:46 <nand`> then all is fine here
09:24:49 <roconnor> :)
09:25:24 <younder> Yes a firewall thing, not a Haskel thing
09:25:47 <krey_> can someone hint at the theoretical significance of this?
09:25:48 <mauke> Gurragchaa: what error?
09:26:28 <Gurragchaa> I'm trying to solve 99 Haskell Problems #1
09:26:38 <younder> krey_, sure you have a deny allow on your serever and haven't explicitly allowed this
09:26:44 <mauke> ‡≤†_‡≤†
09:26:48 <roconnor> krey_: well, functors are not always strong in every category.  So it is useful to know that if a construction requires a strong monad or a strong functor, then it can be translated into Haskell.
09:27:00 <nand`> Gurragchaa: Cale and I already mentioned the error earlier
09:27:20 <Gurragchaa> I reordered the conditions so it wouldn't match everything to x
09:27:34 <Yuu-chan> > "–ÛÒÒÍËÂ ·ÛÍ‚˚"
09:27:35 <lambdabot>   "\65533\65533\65533\65533\65533\65533\65533 \65533\65533\65533\65533\65533"
09:27:58 <Yuu-chan> > putStrLn "–ÛÒÒÍËÂ ·ÛÍ‚˚"
09:27:59 <lambdabot>   <IO ()>
09:28:05 <nand`> Gurragchaa: (that wasn't actually the error, the original order was correct: but ‚ÄúmyLast x = x‚Äù was not)
09:28:37 <Gurragchaa> thanks for the tip; I'll try to work that out
09:28:45 <nand`> note that myLast [1] = mylast (1:[]); which in your definition expands to myLast []
09:28:48 <pozic_> Are there any IDEs/editors for Haskell which return correct and complete completions?
09:29:06 <Gurragchaa> oh! I forgot they're lispy lists
09:29:16 <nand`> lispy lists?
09:29:41 <nand`> they're linked lists in general
09:29:52 <Yuu-chan> How to print something using the stdout encoding?
09:29:59 <mauke> (defun my-last (xs) (if (consp xs) (my-last (cdr xs)) xs))
09:30:05 <merijn> Yuu-chan: stdout doesn't have an encoding
09:30:36 <Yuu-chan> putStrLn does it right way, but print escapes all non-ASCII symbols and makes a total mess.
09:30:51 <merijn> Yuu-chan: You have to check the environment variables (or better) locale to figure out which encoding to print
09:30:58 <mauke> @src print
09:30:58 <lambdabot> print x = putStrLn (show x)
09:31:00 <merijn> Yuu-chan: print = putStrLn . show
09:31:01 <nand`> print = putStrLn . show
09:31:04 <nand`> :(
09:31:13 <Yuu-chan> merijn: I meant hSetEncoding stdout utf8 >> putStrLn "<some national here>"
09:31:28 <Yuu-chan> I know, but what to do?
09:31:29 <merijn> Yuu-chan: In other words, your string gets stringified and then printed if you use print, hence the escaping
09:31:42 <mauke> Yuu-chan: that depends on what you're trying to achieve
09:31:47 <merijn> if putStrLn works then everythin is working as intended
09:31:59 <quicksilver> Yuu-chan: the effect of show and hence print is to escape things to a 7-bit safe representation
09:32:13 <jfischoff> can I make prefix constructors like: :!: a ?
09:32:15 <quicksilver> this is so you don't need to worry about encoding for show'ed data.
09:32:20 <nand`> note that ‚ÄòputStrLn "√ê√≥√±√±√™√®√• √°√≥√™√¢√ª"‚Äô works as I'd expect for me
09:32:26 <nand`> not sure what you're asking
09:32:32 <quicksilver> but if you dont' want that effect - just don't use show (or print)
09:32:44 <Gurragchaa> finally did it! @let myLast (x:[]) = x; myLast (x:xs) = myLast xs
09:32:59 <nand`> Gurragchaa: that's better. Note that (x:[]) = [x]
09:33:01 <otters> Gurragchaa: you could do myLast [x] = x
09:33:04 <otters> save a bit of typing
09:33:05 <nand`> so it can be prettified somewhat
09:33:14 <Yuu-chan> I'd want to print some values without user-defined serializing functions...
09:33:15 <mauke> nand`: I'm not sure that's actually better
09:33:57 <orzo> is there an idiom to follow when i want to do a case but i'm not interested in pattern matching anything, i just have a series of gaurd expressions to test?
09:34:08 <mauke> case () of _
09:34:34 <Yuu-chan> Seems I have to add TypeSynonyms and/or OverlappingInstances and redefine show for my (String, String) and so on
09:34:38 <Yuu-chan> Right?
09:34:47 <younder> nop
09:34:53 <mauke> Yuu-chan: wtf
09:35:13 <Gurragchaa> I feel like there's a shorter way of doing this with folds
09:35:53 <younder> Gurragchaa, avoid fold if you can, they are no better than loops
09:36:00 <Spockz> younder: ?
09:36:12 <nand`> Gurragchaa: ‚Äòfold‚Äô is usually used when your base case is []
09:36:33 <Spockz> Gurragchaa last = fold1 ?
09:36:34 <Yuu-chan> mauke: smth like {-# LANGUAGE OverlappingInstances #-} instance Show (String, String) where show (a, b) = printf "(%s,%s)" a b
09:36:35 <younder> They accumulate SO they can not be parallelized
09:37:11 <nand`> > foldr1 (flip const) "hello, world"
09:37:13 <lambdabot>   'd'
09:37:14 <mauke> Yuu-chan: how about no
09:37:18 <Yuu-chan> So they won't be escaped.
09:37:20 <quicksilver> Yuu-chan: just don't use show or print.
09:37:45 <Spockz> nand`: that one yes
09:37:52 <quicksilver> use putStrLn (or define your own function for types like (String,String))
09:38:07 <Enigmagic> Yuu-chan: there should already be a show instance for (,)
09:38:13 <Yuu-chan> Ok, thanks.
09:38:31 <Enigmagic> > show ("foo", "bar")
09:38:32 <lambdabot>   "(\"foo\",\"bar\")"
09:38:44 <nand`> Enigmagic: he doesn't want the strings to be escaped
09:38:47 <quicksilver> Enigmagic: yes, and it doesn't do what Yuu-chan wants. Which is why I'm telling him not to use it.
09:38:57 <nand`> what he wants is \(a,b) -> "(" ++ a ++ ", " ++ b ++ ")")
09:39:06 <Enigmagic> sounds like he doesn't want Show
09:39:13 <orzo> thanks, mauke
09:39:21 <quicksilver> indeed it does.
09:39:39 <n-dolio> @type uncurry (printf "(%s, %s)")
09:39:40 <lambdabot> forall a b c. (PrintfArg a, PrintfArg b, PrintfType c) => (a, b) -> c
09:39:41 <Yuu-chan> quicksilver, I'm a she :)
09:39:58 <nand`> you never know with those honorifics these days
09:40:39 <quicksilver> Yuu-chan: apologies :) It's hard to tell on the internet.
09:40:53 <Yuu-chan> Good ol' days when there were no girls in the Internet, right?
09:41:12 <allsystemsarego> @src Functor
09:41:12 <lambdabot> class  Functor f  where
09:41:12 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:41:27 <quicksilver> no, not really...
09:43:22 <edwardk> @tell danharaj i think i figured out indexing
09:43:22 <lambdabot> Consider it noted.
09:43:42 <younder> Haskell doesn't have a macro processor does it?
09:43:52 <c_wraith> younder: you can use CPP - but it's kinda ugly
09:44:01 <edwardk> younder: you can use CPP or template haskell
09:44:06 <Yuu-chan> younder: and there is Template Haskell
09:44:08 <merijn> younder: Or Template Haskell for more complex meta-programming
09:44:22 <younder> Well how can it do variable argument calls like a printf?
09:44:33 <nand`> younder: type trickery
09:44:42 <nand`> best look at the source code of printf for that one I'd say
09:44:46 <c_wraith> > printf "hello %s" "person" :: String
09:44:47 <lambdabot>   "hello person"
09:44:50 <Yuu-chan> @src printf
09:44:50 <lambdabot> Source not found. Sorry.
09:45:08 <c_wraith> not that the source for printf is particularly enlightening before you know a fair bit about type classes
09:45:10 <nand`> see http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Printf.html#t:PrintfType
09:45:28 <Yuu-chan> @type printf
09:45:29 <lambdabot> forall r. (PrintfType r) => String -> r
09:45:42 <younder> I see I have a LOT more to learn
09:45:59 <c_wraith> edwardk: what does the api for indexing end up looking like?
09:46:00 <nand`> basically, PrintfType can be either String or PrintfArg a => a -> String
09:46:06 <nand`> depending on how many arguments you pass it
09:46:14 <c_wraith> nand`: or, disturbingly, IO ()
09:46:23 <parcs`> younder: that printf is not type safe, though. you can make a type safe printf with template haskell
09:46:30 <parcs`> > printf "hi" 3
09:46:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:46:31 <lambdabot>    `Text.Printf.PrintfType ...
09:46:36 <edwardk> one sec and i'll paste
09:46:45 <parcs`> > printf "hi" (3 :: Int)
09:46:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:46:46 <lambdabot>    `GHC.Show.Show a'
09:46:46 <lambdabot>      a...
09:46:57 <nand`> parcs`: you need to give the exact return type
09:46:58 <c_wraith> parcs`: you need to tell it the whole expression is a string
09:47:17 <parcs`> > printf "hi" 3 :: String
09:47:19 <lambdabot>   "hi*Exception: Printf.printf: formatting string ended prematurely
09:47:39 <nand`> printf is a hack
09:47:53 <parcs`> check out the 'printf-
09:48:01 <Yuu-chan> Why there are so few formatting flags in Haskell printf? :(
09:48:03 <parcs`> printf-mauke package for a type safe printf
09:48:33 <n-dolio> Because nobody is interested in using printf in Haskell.
09:48:39 <nand`> ^
09:49:04 <mauke> Yuu-chan: what's missing?
09:49:05 <nand`> ‚ÄúWhy are there only bad SQL/Regex/JSON/whatever implementations in Haskell?‚Äù ‚ÄúBecause in Haskell we have better data types for these things‚Äù
09:49:33 * hackagebot BirdPP 1.1 - A preprocessor for Bird-style Literate Haskell comments with Haddock markup. (SeanMcLaughlin)
09:49:35 <kallisti> I wouldn't consider the SQL and JSON libraries bad
09:49:50 <nand`> kallisti: well, I would consider the SQL libraries bad because SQL is bad
09:49:56 <nand`> so that's pretty much a given
09:49:57 <kallisti> not the same thing
09:50:07 <kallisti> our SQL libraries are comparable to most others.
09:50:07 <younder> Non type safe printf.. Not sure I like that one
09:50:24 <nand`> yes, but bad compared to elegant, type-safe pure haskell stuff
09:50:26 <allsystemsarego> if not via an SQL API, how does Haskell interface with a relational database?
09:50:34 <c_wraith> younder: well, it's not like C printf is type-safe either
09:51:01 <c_wraith> younder: it's just sacrificing most of the good stuff in haskell for a bit of convenience that, honestly, is pretty rare to actually see used.
09:51:06 <nand`> allsystemsarego: there are pure-haskell database systems around for various purposes
09:51:11 <younder> c_wraith, well then I might as well write it in C right ;)
09:51:14 <int-e> younder: it's perfectly type safe ... it's not format string safe ... ;)
09:51:17 <nand`> depending on how much overkill you need
09:51:29 <c_wraith> younder: or not use printf :)
09:51:32 <merijn> allsystemsarego: Why wouldn't you use the SQL API for relational databases?
09:51:36 <allsystemsarego> nand`, including graph databases?
09:51:45 <younder> c_wraith, My thought exactly
09:51:52 <int-e> younder: (printf is type driven, but at runtime will check whether the %foo pattern makes sense for the given type)
09:52:06 <nand`> allsystemsarego: I don't know what those are, I don't know an awful lot more than what I already said
09:52:27 <nand`> but I'd personally be highly uncomfortable with traditional SQL systems
09:52:31 <allsystemsarego> merijn, I wasn't questioning that, I was intrigued by nand`s statement and asked for clarification
09:53:02 <merijn> allsystemsarego: acid-state is pretty neat, it provides ACID guarantees for haskell data structures
09:53:04 <edwardk> @hpaste
09:53:05 <lambdabot> Haskell pastebin: http://hpaste.org/
09:53:11 <nand`> acid-state is great fun
09:53:24 <younder> I like SQL. It is a logical set oriented system. Clean and Logical. Whay would that be a problem with Haskell?
09:53:26 <hpaste> edwardk pasted ‚Äúindexed traversals (not done!)‚Äù at http://hpaste.org/72500
09:53:34 <edwardk> c_wraith: that is the sketch of what i'm using
09:54:13 <edwardk> c_wraith: basically i swap out the function (->) between (c -> f d) and (a -> f b) for another data type
09:54:25 <edwardk> then i can make it hold an (i -> c -> f d) -> a -> f b
09:54:31 <edwardk> but you cn use it as a function
09:54:35 <edwardk> so it composes with other traversals
09:54:47 <edwardk> if you use .# you can compose the indices
09:55:12 <Yuu-chan> mauke: er... seems I'm messing up something, please sorry :-[ I have a shadowy reminiscence of adding instance for PrintfArg Char, or so on... Or it was in an another life...
09:55:28 <nand`> no more ugly zipWith .. [0..] ?
09:55:39 <edwardk> so traverseList.#traverseList -- will give you a composite traversal where if you traverseWithIndexOf (traverseList.#traverseList) you'll get a function ((Int,Int) -> a -> f b) -> [[a]] -> f [[b]]
09:55:44 <edwardk> nand`: thats the thought
09:56:21 <edwardk> ideally i should be able to augment it so every traversal can be used to obtain a supplemental index based on its position
09:56:24 <Yuu-chan> younder: there is a type-safe version of printf in Template Haskell. But it is template.
09:56:28 <nand`> edwardk: again, it's surprising how much of existing code this would generalize away, eg. Indexed k (Map k v) (Map k v') v v'
09:56:30 <edwardk> but some folds and traversals may be able to give you their actual keys
09:56:37 <edwardk> yep
09:57:14 <edwardk> basically traverseMap will be able to provide indexed folds and indexed traversals by position or key, foldrWithKey, etc.
09:57:23 <donri> allsystemsarego: the persistent package is one way to interface with relational databases without SQL.
09:57:29 <edwardk> and all the combinators will just work
09:57:54 <edwardk> and if you traverseMap.#traverseMap  and use one of those combinators then it will just give you the composed keys
09:58:19 <donri> allsystemsarego: although, haskell does have some fun things for raw SQL, such as compile-time checked SQL syntax and compile-time testing of database interactions against a real database
09:58:42 <edwardk> this is one of two major extensions to the concept i'm exploring
09:59:10 <donri> allsystemsarego: but, if you just want data durability acid-state is in deed nice.
09:59:27 <edwardk> the other would enable you to write 'methods'  and do things like index STArrays, etc, but is more invasive
09:59:50 <ParahSailin_> Module Main where main = ... is always needed for ghc to produce an executable?
10:00:18 <edwardk> it requires me to swap out all the uses of Const and Identity to ConstT m Identity and IdentityT Identity -- which is a little silly looking ;)
10:00:46 <donri> allsystemsarego: acid-state allows you to use basically any haskell data structure, so without really knowing what a graph database is i'd say you could probably do it on top of acid-state.
10:01:09 <edwardk> the nice thing is that normal combinators just work on indexed traversals
10:01:26 <pozic_> Is there some way to write loops using imperative looking constructions (while) which then compiles down to uses of foldl'?
10:01:36 <pozic_> The D programming language has that basically.
10:02:09 <edwardk> there are some rough edges though, i'm still armwrestling with type inference here and there
10:02:25 <pozic_> The D programming language approach seems to require less code, because you don't have to deconstruct and construct the foldr results.
10:02:26 <c_wraith> pozic_: that seems a little backwards. the purpose of using things like fold and map is that they *limit* what's going on in the loop, so it's easier to understand quickly
10:02:28 <Yuu-chan> ParahSailin_ no, Main module declaration can be omitted
10:03:51 <Yuu-chan> pozic_: could you please show an example of loop that you'd want?
10:03:52 <pozic_> All folds are of the form (a,b,c,d) -> let a'=f a;b'=g b;c'=h c;d'=i d in (a',b',c',d')
10:05:13 <c_wraith> pozic_: that doesn't look much look a fold at all.
10:06:56 * BMeph thinks that looks more like a map than a fold.
10:07:24 <allsystemsarego> donri, thanks for the explanations
10:07:41 <donri> BMeph: not sure about map either, note how the function changes
10:08:08 <otters> @djinn (a -> e) -> (b -> f) -> (c -> g) -> (d -> h) -> (a,b,c,d) -> (e,f,g,h)
10:08:08 <lambdabot> f a b c d (e, f, g, h) = (a e, b f, c g, d h)
10:09:11 <Yuu-chan> Wow, what kind of magic is this?
10:09:19 <ParahSailin_> Yuu-chan: ah i see the main-is ghc option
10:10:14 <BMeph> donri: oh, I thought it was a list of tuples, not  over just the tuple.
10:10:54 <edwardk> c_wraith: ghci> runIdentity $ traverseWithIndexOf (traverseList.#traverseList) (\i j -> Identity (i,j)) [[1],[2,4,5,6],[3]]
10:10:54 <edwardk> [[((0,0),1)],[((1,0),2),((1,1),4),((1,2),5),((1,3),6)],[((2,0),3)]]
10:11:04 <nand`> is there some sort of function like ‚Äòat :: Picture -> (Float, Float) -> Picture‚Äô in gloss? So I can write say ‚Äúcircle r `at` pos‚Äù
10:11:26 <Yuu-chan> @djinn (a -> a) -> a -> [a]
10:11:26 <lambdabot> Error: Undefined type []
10:11:45 <MostAwesomeDude> @djinn (a -> a) -> a -> m a
10:11:45 <lambdabot> -- f cannot be realized.
10:12:07 <roconnor> edwardk: hi edwardk
10:12:13 <edwardk> heya
10:12:16 <MostAwesomeDude> @ty f g a = [g a]
10:12:17 <lambdabot> parse error on input `='
10:12:21 <edwardk> btw- focusing was already applicative
10:12:32 <MostAwesomeDude> @ty let f g a = [g a] in f
10:12:33 <lambdabot> forall t t1. (t -> t1) -> t -> [t1]
10:12:38 <edwardk> and the reason you don't use compose is that we use focusing when we only have a monad in many places
10:12:39 <MostAwesomeDude> Yuu-chan: ^^
10:12:46 <roconnor> edwardk: do you know anything about matrix algorithms for min-cut max-flow?
10:12:55 <Yuu-chan> @djinn a -> b -> a
10:12:56 <lambdabot> f a _ = a
10:12:56 <mauke> MostAwesomeDude: iterate
10:12:57 <edwardk> not presently =)
10:13:28 <MostAwesomeDude> mauke: That'd work too.
10:13:56 <Yuu-chan> @djinn build a castle
10:13:57 <lambdabot> -- f cannot be realized.
10:14:38 <edwardk> nand`: i'm thinking i can make something like 'indexed' that takes any traversal and adds the [0..] index, to make an indexed traversal. and then i can supply indexed folds for things like maps, etc. that use the key by default
10:14:54 <Yuu-chan> Bye :)
10:17:27 <augur_> edwardk: do you know if there's anything i can read about the difference between generative descriptions of strings vs. static propositional descriptions
10:17:37 <augur_> edwardk: what im thinking of is sort of like this:
10:17:47 <edwardk> nada
10:18:40 <augur_> edwardk: you could generate a string by rewriting it successively, or you could describe it via a sequence of strings, where each pair of strings is required to satisfy a rewriting rule
10:18:51 <augur_> and i feel like these should be obviously related views
10:19:00 <augur_> where one is sort of the view "from the inside"
10:19:24 <danharaj> edwardk: makeLenses broke for me with 1.3: Not in scope: type constructor or class `Control.Lens.Lens' at the line of instantiation.
10:19:25 <lambdabot> danharaj: You have 1 new message. '/msg lambdabot @messages' to read it.
10:19:43 <danharaj> edwardk: I am excited to hear about indexing.
10:19:44 <edwardk> danharaj: you need to import Control.Lens to use it now
10:19:51 <copumpkin> OMG IT'S N-DOLIO
10:19:55 <edwardk> it changed quite a bit
10:19:59 <edwardk> it generates type signatures now
10:20:04 <copumpkin> N-DOLIO: HOW ARE YOU DOING?
10:20:11 <edwardk> in particular it generates isomorphisms automatically when you feed it a newtype
10:20:19 <edwardk> or if you feed it a single argument data constructor
10:20:35 <danharaj> You have doubled my imports in some files! what a regression :P
10:20:42 <edwardk> sorry man
10:20:52 <nand`> In gloss, can I somehow ensure that the drawing area is always (-1,-1) to (1,1) ?
10:20:54 <edwardk> the alternative was that everyone with -Wall got whined at by every lens
10:21:20 <roconnor> -Wall pisses me off. It wants me to write 2 ^ (8 :: Int) everywhere
10:21:28 <edwardk> danharaj: did you see the indexing code?
10:21:36 <danharaj> edwardk: not yet.
10:21:38 <edwardk> its not in the branch yet, but its working loclly
10:21:45 <donri> edwardk: how did you manage type signatures?
10:21:48 <edwardk> one sec i'll hpaste the unbroken version
10:21:48 <edwardk> @hpaste
10:21:49 <lambdabot> Haskell pastebin: http://hpaste.org/
10:22:16 <hpaste> edwardk pasted ‚Äúworking Control.Lens.Indexed‚Äù at http://hpaste.org/72503
10:22:52 <edwardk> its the same trick as isomorphic
10:23:12 <edwardk> basically i make   class Indexed i k where  indexed :: ((i -> a) -> b) -> k a b  -- then make (->) an instancce
10:23:38 <edwardk> its a little more fragile at the declaration site, but its solid at the use site with the ~ there
10:23:54 <edwardk> so you can use an indexed traversal directly as a traversal
10:24:08 <edwardk> and we can make an indexed traversal out of any traversal by using an as yet unwritten 'indexed' combinator
10:24:47 <applicative> boy this channel has turned into #lens ;  I suspect it's a step  up.
10:25:36 <arcatan> what comes after lenses?
10:25:44 <danharaj> That sounds great. I was going to play around with lenses inside monads some time today after I hunt down some terrible array bugs.
10:25:46 <applicative> more lenses
10:25:48 <danharaj> plates!
10:25:51 <edwardk> arcatan: sorry bout that
10:25:57 <edwardk> danharaj; oh i started on those too
10:26:04 <edwardk> (lenses for monads)
10:26:21 <edwardk> it requires a pretty invasive rewrite to do it right though
10:26:25 <pozic_> Does anyone understand Japanese? http://twitter.com/kazu_yamamoto/statuses/210588119727226882
10:26:42 <pozic_> Basically ghcmod gives some weird error message.
10:26:46 <edwardk> basically what you can do is switch to (c -> t f d) -> a -> t f b
10:26:49 <danharaj> edwardk: Would it be too terrible to make them separate and have `mlens' to lift pure lenses?
10:27:00 <edwardk> yeah it would suck =P
10:27:00 <danharaj> wrap them in a newtype and give a category instance etc.
10:27:03 <danharaj> :P
10:27:16 <edwardk> because the nice thing is this way is you'd get the ability to mix and match them directly
10:27:23 <applicative> danharaj: do you or someone have a nice complex module with skillful use of the new lenses
10:27:26 <stephenjudkins> not Haskell, but has anyone here used Roy (http://roy.brianmckenna.org/) for a real project?
10:27:35 <edwardk> applicative: sure, one sec
10:27:42 <danharaj> applicative : I would not consider anything I write 'skillful'
10:27:48 <danharaj> For example right now my code doesn't compile.
10:27:59 <danharaj> and when it does compile it throws an array index error.
10:28:13 <applicative> i'll wait for that tutorial module, then
10:28:49 <danharaj> The new ones are not hard to use. If you used data-lens then you just have to change a few combinators and reverse the order of lens composition.
10:28:49 <applicative> I'm getting it, but I think one needs practice to notice when what one's doing is best done with these combinators
10:29:08 <edwardk> applicative: https://github.com/ekmett/lens/blob/master/src/Language/Haskell/TH/Lens.hs#L57 uses them in anger a bit
10:29:17 <pozic_> stephenjudkins: why would anyone want to use something like that which hasn't any tools to support it?
10:29:48 <danharaj> edwardk: btw I love the use of lens to parametrize makeLense. It's very meta and not hard to use.
10:29:57 <edwardk> danharaj: =)
10:29:59 <danharaj> (I had a lense name that clashed with an iso lens being autogenerated)
10:30:00 <pozic_> stephenjudkins: it only creates some compile lag as far as I am concerned.
10:30:09 <stephenjudkins> pozic_: unsure what you mean? what tools are missing vs, say, coffeescript? I am intrigued by its vaguely haskell-like semantics
10:30:13 <eusebio> does haskell have a plotting lib?
10:30:17 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/TH.hs#L187 also shows some uses
10:30:31 <edwardk> relevantBndr b = s^.contains (b^.name)
10:30:32 <edwardk> etc.
10:30:39 <stephenjudkins> pattern matching, some measure of static guarantees,  etc seem like a reasonable win for a quick compile step
10:30:48 <edwardk> danharaj: yeah the makeLensesFor code is a nice example
10:30:56 <pozic_> stephenjudkins: people interested in that would use Opa.
10:30:57 <edwardk> danharaj: did you notice i smuggled in <~ as an alias for ^~
10:30:57 <edwardk> ?
10:31:10 <applicative> yes, nice.
10:31:13 <younder> eusebio, of cource, but you would be better off using gnu lib
10:31:38 <edwardk> bitAt 4 <~ True $ 0
10:31:39 <applicative> Maybe a module using them with a bunch of familiar types would make for good pedagogy though.
10:31:50 <edwardk> applicative: yeah i've been working on a tutorial
10:31:54 <younder> eusebio, yes oddly gnu plot IS more portable
10:32:03 <pozic_> Nobody who uses ghcmod here?
10:32:24 <younder> I do
10:32:25 <shurikas> @src isNothing
10:32:25 <lambdabot> isNothing Nothing = True
10:32:25 <lambdabot> isNothing _       = False
10:32:27 <shurikas> so
10:32:37 <pozic_> younder: I don't quite understand why it completes System. to System.foldM for example.
10:32:44 <shurikas> would you rather import a foreign module or define a trivial function yourself?
10:32:47 <pozic_> In fact, why it completes it at all.
10:32:53 <shurikas> what's the prefered approach?
10:32:53 <applicative> edwardk: someone mentioned that they were working beautifully with arrays. Maybe they could come up with a demo module for the wiki or an /examples dir
10:33:03 <edwardk> yeah, that was danharaj
10:33:19 <pozic_> Because without an import statement, it shouldn't even exist.
10:33:27 <applicative> haha, thats what I thought.  I guess he got carried away ...
10:33:50 <danharaj> Still working on that. I had a ton of arrays with different coordinate systems floating around, so I'm experimenting with lenses to manage traversal and coordinate changes.
10:33:53 <edwardk> basically with an array they let you use traverseOf, etc. on an array out of the box.
10:34:05 <edwardk> danharaj: i should push the indexed code quickly then ;)
10:34:12 <applicative> danharaj: well, if you get a nice module that does something that we would otherwise do in a ham-handed way, I bet many not just myself would like to study  it
10:34:13 <younder> pozic_, I am not sure I understand your question. I never claimed anything about a complete system.
10:34:30 <pozic_> younder: are you the author?
10:34:50 <younder> pozic_, Of what?
10:34:57 <pozic_> younder: of ghcmod of course.
10:35:10 <younder> pozic_, I am not
10:35:21 <applicative> danharaj: somehow I learn better by studying concrete applications, demo modules are better than 'documentation' for me. I think this is common
10:35:24 <pozic_> younder: why do you use ghcmod then, if not for completion?
10:35:39 <younder> pozic_, I am Just your average Linux programmer
10:35:56 <Bobikins> @query \f -> f a b
10:35:56 <lambdabot> Unknown command, try @list
10:36:00 <danharaj> applicative: interesting. I can't read other people's codes. I learn by staring at the docs and following the types.
10:36:01 <Bobikins> @pl \f -> f a b
10:36:01 <lambdabot> flip ($ a) b
10:36:39 * Philippa likes demos where they're still doing due diligence, as it were
10:36:58 <Philippa> unfortunately, I got a decade worth of MS ones to kick off with instead?
10:37:08 <applicative> danharaj: yes, I think that's common too, but so is the other way.  I read the docs, and in edwark's sort of case, meditate on types and fool with them; but then I don't find the combinators coming into my head when I'm writing something definite.
10:37:37 <Philippa> as usual, if you've got time: do both/all
10:37:38 <pozic_> Does anyone have working completion in any environment where you can write programs for Haskell (this excludes ghci)?
10:37:57 <applicative> Philippa: doing due diligence?
10:38:44 <Philippa> applicative: I prefer my demos to come without nasal demons, for example. Not doing "suicidal" things about error handling, too
10:39:13 <applicative> nasal demons?
10:39:35 * applicative is finding Philippa uncharacteristically mysterious today
10:40:20 <applicative> I think the little demos in e.g. the aeson package, or acid-state cast a giant flood of light over everything.
10:40:23 <donri> edwardk: I got an Iso for the field in a record with just one field, but i might be adding fields to that record later. wouldn't it be prudent to make it a Lens from start?
10:40:41 <pozic_> stephenjudkins: also the monad support is a complete joke in that language.
10:41:02 <stephenjudkins> pozic_: why? what is missing?
10:41:17 <applicative> Philippa, I also think our documentation-allergic friends would probably find an examples directory much easier to write.
10:41:18 <pozic_> stephenjudkins: I am guessing you are the author.
10:41:31 <applicative> or consider the /examples in the enumerator package
10:41:32 <stephenjudkins> pozic_: i am definitely not the author
10:41:38 <edwardk> you get an iso lens for the field too if you name it
10:41:48 <pozic_> stephenjudkins: then just take my advice; stay away from it.
10:41:52 <edwardk> it'll cease to be an iso if you add fields though
10:42:51 <stephenjudkins> pozic_: ok, sorry for asking for your opinion. I'm not trying to be combative, just genuinely curious what's wrong with it.
10:42:51 <applicative> any I am continuing my effort to grasp Control.Lens
10:43:01 <applicative> anyway, rather
10:43:09 <pozic_> stephenjudkins: by the time you know Haskell, you will know.
10:43:11 <donri> edwardk: yea, but couldn't it mean i might be using it as an iso and have to change that code later?
10:43:21 <pozic_> stephenjudkins: and otherwise just happily use it in ignorance.
10:43:30 <pozic_> stephenjudkins: perhaps you might even be happy with it.
10:44:00 <donri> edwardk: it just feels odd that the number of fields changes the type of the field lenses
10:44:08 <donri> (but i could be missing the point :))
10:44:29 <stephenjudkins> pozic_: *sigh* I would like to know actual reasons not to use it. if you don't want to discuss the subject, that's fine... but I am trying to learn here.
10:45:19 <Soultaker> I want to read a bunch of lines as strings, apply a function each string, and then print it as a single line.  Is there are nicer way to do this then this?
10:45:25 <Soultaker> readLn >>= (`replicateM` getLine) >>= mapM_ (putStrln . someFunc)
10:47:31 <byorgey> Soultaker: that code looks pretty nice to me, though it doesn't seem like it quite does what you said
10:47:33 <applicative> pozic vanished before I could tell him  that textmate completes everything for me
10:47:37 <donri> edwardk: I also got an iso for the record itself that i'm not using and either have to export or will get an unused warning from :) but, nitpicking
10:47:52 <edwardk> you can tell it no to make it
10:47:55 <Soultaker> byorgey: you mean that it reads the number of lines to read first? Or did I make a mistake?
10:47:57 <danharaj> The interface for disabling the iso rule is nice.
10:47:59 <danharaj> It's a lens!
10:48:08 <Soultaker> (if I wanted to process all  lines in the input I could just have used "interact')
10:48:27 <donri> danharaj: i tried isoLensRule ^~ const nothing, didn't change anything
10:48:42 <byorgey> I mean it doesn't "print it as a single line"
10:48:44 <edwardk> makeLensesWith $ isoLensRule <~ const Nothing $ defaultLensRules
10:48:48 <byorgey> it prints a bunch of lines.
10:49:06 <donri> edwardk: it's <~ now? hm
10:49:07 <edwardk> donri: it didnt?
10:49:08 <edwardk> hrmm
10:49:16 <edwardk> <~ and ^~ do the same
10:49:17 <Soultaker> oh, that's what I meant.  For each line of input, I want to print one line of output.  Sorry if that wasn't clear.
10:49:24 <byorgey> oh, or did you mean "print each processed string as a single line"?
10:49:26 <danharaj> isoLensRule ^~ const nothing worked for me.
10:49:26 <edwardk> its just prettier, ^~ is consistent, <~ is pretty
10:49:32 <byorgey> ok, sorry, makes sense now
10:49:53 <donri> wait let me try again, i could have been confused by the other thing
10:50:31 <applicative> but Soultaker 's general idea of beginning readLn >>= (`replicateM` getLine) >>=  ... is handsome Haskell, I'd say
10:51:05 * byorgey agrees
10:51:32 <donri> yes it works ^_^
10:51:37 <edwardk> donri: =)
10:51:47 <edwardk> i can make a isosAsLensesRule or something
10:52:00 * BMeph thinks 'mapM (interact some Func)' would be a clever solution.
10:52:00 <Soultaker> ok, guess I'll keep it as is then.  (Figured I should ask in case there was a utility function that combined a few steps that I didn't know about.)
10:52:03 <donri> i got confused because i still needed to import Iso,isomorphic because of the field lens
10:52:16 <Soultaker> thanks for the input, guys.
10:52:17 <edwardk> ah yeah
10:52:29 <edwardk> wait, isomorphic didn't come in correctly with just Control.Lens ?
10:52:34 <donri> edwardk: shrug, i'm already doing makeLensesWith because i'm overriding the fieldLensRule as well
10:52:47 <donri> edwardk: oh sure, i'm just using explicit import lists
10:53:23 <r3uben> Hi, does anybody know if there is a curl-like monad/monad-trasformer out there?
10:55:07 <mekeor> r3uben: what should this monad(-transformer) be able to do?
10:56:01 <r3uben> transfer data to servers via various protocols like HTTP
10:56:59 <merijn> r3uben: Take a look at conduits? (Which are mostly (completely?) unrelated to monad/transformers, but is probably more what you're looking for
10:57:15 <r3uben> thanks
10:57:25 <r3uben> thanks merijn
10:59:38 <nand`> edwardk: your lenses are making some pong code I'm writing very clean: ‚Äúwhen (abs y > 1) $ do ballPos._y ^= (2 - abs y) * signum y; ballSpeed._y %= negate‚Äù
10:59:44 <donri> r3uben: specifically http-conduit
10:59:46 <edwardk> =)
11:00:02 <nand`> hmm
11:00:17 <nand`> I could abuse NumInstances for that: ballPos._y %= (2 - abs) * signum
11:00:27 <nand`> too confusing?
11:00:35 <edwardk> too confusing
11:01:45 <roconnor> um, are we all going to use _ to begin lens names?
11:01:53 <scooty-puff> i tried writing a unification library (so failure is possible), and then sticking ErrorT underneath it (and the means that variables are written/read) - but it keeps seeming like i have to push /\  down into \/ - i.e. (a \/ b) /\ c --> (a /\ c) \/ (b /\ c) - is this common?
11:02:07 <roconnor> should I call the RGB component lenses: _r, _g, and _b?
11:02:18 <roconnor> similarly for hsl and hsv?
11:02:28 <nand`> roconnor: well, I copied it from _1 and _2 (which _x and _y are just aliases for)
11:02:28 <donri> what is _y anyway
11:02:36 <nand`> since I didn't want ‚Äòx‚Äô and ‚Äòy‚Äô to collide with other usages
11:02:38 <r3uben> donri: thanks
11:02:39 <nand`> which it would
11:02:45 <nand`> roconnor: I wouldn't be too upset about _r _g _b personally
11:02:48 <scooty-puff> (pushing the "and"s down in to the "or"s doesn't work where ErrorT is above the MonadRef - but this is expected)
11:03:04 <byorgey> I thought usually record fields are named with underscores, and then the lenses are underscoreless
11:03:19 <nand`> byorgey: yeah, that's what I'm doing for names ‚Äòeg. ballSize, ballSpeed‚Äô
11:03:28 <nand`> but single letters like that shouldn't collide
11:06:45 <nand`> I'm a bit confused about how to most elegantly handle held down input in gloss (using ‚Äòplay‚Äô), in my update function I want to update depending on whether or not a key is being held down. Am I supposed to just keep a Set Char in my program state somewhere and update that on Events?
11:07:10 <scooty-puff> looks like i have to convert to conjuctive normal form - perhaps i should write an Alternative or MonadPlus that does this automatically
11:07:20 <nand`> Set Key rather
11:08:25 <r3uben> \quit
11:11:07 <eusebio> :t (@)
11:11:08 <lambdabot> parse error on input `@'
11:11:16 <eusebio> what is @ in haskell?
11:11:26 <nand`> as-patterns
11:12:02 <eusebio> > "5" @ Int
11:12:03 <lambdabot>   <no location info>: parse error on input `@'
11:12:05 <nand`> x@(Foo a b c) <- matches and assigns ‚Äòa‚Äô ‚Äòb‚Äô ‚Äòc‚Äô but also assigns the entire match to ‚Äòx‚Äô
11:12:19 <nand`> eusebio: it's only valid when pattern matching
11:12:23 <roconnor> eusebio: @ is used in pattern matching
11:12:35 <eusebio> > x@(Just 5)
11:12:37 <lambdabot>   Pattern syntax in expression context: x@(Just 5)
11:12:53 <nand`> > case Just 5 of x@(Just y) -> (x,y)
11:12:53 <eusebio> > let y = x@(Just 5) in y
11:12:53 <lambdabot>   (Just 5,5)
11:12:54 <lambdabot>   Pattern syntax in expression context: x@(Just 5)
11:13:18 <roconnor> > let x@(Just y) = Just 5 in (x,y)
11:13:20 <lambdabot>   (Just 5,5)
11:13:52 <ParahSailin_> whats the inverse of return
11:14:33 <monochrom> no inverse
11:14:54 <monochrom> find another approach altogether
11:15:02 <Soultaker> if you mean inverse in the sense that you are looking for a function f such that (f . return) == id, then there isn't one.
11:15:50 <edwardk> roconnor: i use _ for a few lenses in Data.List.Lens but i try to use the 'ed' suffix
11:16:03 <edwardk> interspersed, intercalated, etc.
11:16:06 <edwardk> reversed
11:16:18 <SailingPariah> unreturned ldo
11:16:22 <edwardk> but i have _head _tail, _init, etc.
11:16:32 <edwardk> since those don't translate idiomatically to past tense
11:16:44 <SailingPariah> whats a lens?
11:16:53 <edwardk> i actually kinda like the _x, _y, _z convention for short lens names
11:17:24 <edwardk> SailingPariah: a lens is a 'functional reference'. the simplest way to think of them is as a pair of a 'getter: a -> b' and a 'setter: a -> b -> a' that satisfy some obvious laws.
11:17:29 <edwardk> they can be composed with each other
11:17:39 <edwardk> the ones we're talking about right now are the ones in my lens package
11:18:01 <nand`> Soultaker: but isn't join . return = id ?
11:19:07 <hpaste> Valk pasted ‚Äúhurt . aeson $ brain‚Äù at http://hpaste.org/72504
11:20:09 <Valk> I'm trying to parse a nested JSON response and cannot figure out what type I need for the raid_members to be parsed here: http://hpaste.org/72504 (marked with a triple question mark). Help please?
11:20:21 <Valk> (using Data.Aeson)
11:22:47 <ParahSailin_> :t System.IO.Unsafe.unsafePerformIO
11:22:48 <lambdabot> forall a. IO a -> a
11:23:10 <ParahSailin_> :t System.IO.Unsafe.unsafePerformIO . return
11:23:11 <lambdabot> forall a. a -> a
11:23:21 <c_wraith> Valk: If you want the most direct representation, Vector RaidMember
11:23:36 <ParahSailin_> not that i would use something that says unsafe in the name anyway
11:25:16 <c_wraith> Valk: note that you'll also need a FromJSON instance for RaidMember
11:25:26 <ParahSailin_> System.IO.Unsafe.unsafePerformIO . return == id
11:26:49 <Valk> thanks, trying to do it now and getting indentation errors for the RaidMember instance
11:28:09 <Valk> ok, got rid of the error
11:28:16 <Valk> however, the parser returns Nothing
11:28:21 <Valk> on Vector RaidMember
11:31:05 <c_wraith> Oh, I misread your example data badly.
11:31:30 <c_wraith> it's not a list of RaidMember, it's a map of some key to them
11:31:49 <Valk> oh, yeah...
11:32:32 <c_wraith> The simplest, then, is making it a HashMap Text RaidMember
11:32:57 <c_wraith> except that won't convert automatically
11:33:05 <c_wraith> Oh, maybe it's fine
11:34:16 <c_wraith> Yeah, that's fine
11:34:28 <c_wraith> there's an appropriate FromJSON instance for HashMap Text
11:36:57 <Valk> any hints on how to construct the instance please?
11:39:09 <augur_> preflex: seen ski
11:39:10 <preflex>  ski was last seen on #haskell 3 days, 20 hours, 41 minutes and 31 seconds ago, saying: * ski should look more at how packages the work, ty for the reminder
11:39:22 <augur_> :(
11:40:20 <c_wraith> Valk: what you have should pretty much be it.  Can you update the paste with your current code and any compile errors it is giving?
11:42:27 <Valk> c_wraith: http://hpaste.org/72507
11:43:47 <sp3ctum> i'm trying to construct two-dimensional arrays with listArray ((1,1), (9,9) [1..81]. this works in the ghci repl but not when I compile. why?
11:44:02 <sp3ctum> > listArray ((1,1), (9,9) [1..81]
11:44:03 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:44:10 <sp3ctum> > listArray ((1,1), (9,9)) [1..81]
11:44:11 <lambdabot>   array ((1,1),(9,9)) [((1,1),1),((1,2),2),((1,3),3),((1,4),4),((1,5),5),((1,...
11:44:22 <sp3ctum> works fine here too
11:44:31 <sp3ctum> :t listArray
11:44:32 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
11:44:43 <c_wraith> Valk: hmm.  What version of Aeson are you using?
11:44:51 <Valk> the most current one
11:44:59 <sp3ctum> here there is only a tuple of (i,i) where i is the index type, in my example there is the type ((i,i),(i,i)) yet it still works
11:45:02 <Valk> did a cabal install aeson just a few hours ago
11:45:28 <SailingPariah> So anyone here won a olympic medla yet?
11:46:20 <c_wraith> Valk: What import are you using for HashMap, then?
11:46:39 <Ralith> sp3ctum: there is an instance of Ix for tuples.
11:48:33 <Ralith> In parsec, is there any way to compose a (GenParser a s b) with a (GenParser b s c)?
11:48:52 <Valk> c_wraith: the most current one, too.
11:48:58 <sp3ctum> Ralith, i see, that makes sense. any idea why it won't compile then? :S
11:49:15 <Ralith> sp3ctum: maybe you should paste a minimal testcase.
11:49:29 <c_wraith> Valk: I meant, what is the actual import line you're using?
11:49:34 <Valk> import Data.HashMap
11:50:08 <c_wraith> ok, that's a problem.
11:50:11 <c_wraith> That's the wrong package
11:50:17 <Valk> Huh?
11:50:20 <sp3ctum> Ralith, right. i'll make one
11:50:25 <quicksilver> Ralith: that doesn't sound normally useful. A (GenParser a s b) takes a token stream of many as, and produces at most only one b.
11:50:32 <c_wraith> You need Data.HashMap.Strict from unordered-containers
11:50:54 <quicksilver> Ralith: then a (GenParser b s c) wants many bs and you only have one b to give it.
11:51:13 <Valk> Not in scope: data constructor `HashMap'
11:51:16 <quicksilver> however if that's what you really want it's obviously simple enough to string two 'runParsers' together.
11:51:21 <Valk> with import Data.HashMap.Strict
11:51:26 <bishopplox> \exit
11:52:31 <Valk> ahhhh, got it
11:52:38 <Ralith> quicksilver: okay, stepping back a bit then--I want to lazily tokenize a String and parse those tokens, such that I can call getInput and get the remaining String corresponding to unparsed input.
11:52:38 <Valk> testing now
11:52:40 <c_wraith> oh, good.  because I was starting to get confused :)
11:53:06 <quicksilver> Ralith: parsec can't "lazily" anything.
11:53:12 <Ralith> ?
11:53:16 <quicksilver> because it has to commit to find errors.
11:53:17 <Valk> nope...
11:53:18 <Valk> All the requested packages are already installed:
11:53:18 <Valk> unordered-containers-0.2.1.0
11:53:29 <Valk> I thought I didn't have that package.
11:53:42 <quicksilver> so if you want a lazy tokeniser as your top level, you can either write a simple lazy one yourself
11:53:58 <quicksilver> or use parsec's build in tokenising stuff (which isn't itself a GenParser, it's something simpler/special)
11:54:05 <c_wraith> Valk: unordered-containers is a dependency of Aeson
11:54:25 <Ralith> parsec's built in tokenising stuff seems very specific to a certain kind of grammar
11:54:45 <quicksilver> you mean, "things like haskell" ? :-)
11:54:51 <quicksilver> yes, it does, I agree.
11:54:52 <Ralith> yes.
11:54:53 <quicksilver> I've never used it :)
11:55:00 <quicksilver> I write my own simple tokenisers
11:55:01 <Ralith> my grammar is not like haskell.
11:56:09 <Ralith> how would a simple lazy one like you describe differ from the standard approach, i.e. two passes?
11:56:17 <sp3ctum> it seems my error is not related to listArray after all. thanks for the help!
11:56:45 <c_wraith> Valk: Well, the error message in the last code you pasted indicated that *some* type wasn't the one I thought. Because the types I was thinking of definitely have the necessary instances of FromJSON
11:56:46 <Ralith> sp3ctum: np; reducing to a simple testcase will often reveal things like that.
11:56:55 <quicksilver> Ralith: well, it is two pass conceptually.
11:57:08 <quicksilver> Ralith: but operationally, the tokenising phase is "interleaved" with the parsing
11:57:14 <Ralith> how?
11:57:20 <quicksilver> because that's what laziness does.
11:57:31 <quicksilver> if the tokenising is only done as needed to generate the next token to the parser
11:57:34 <Ralith> I'm not referring to Haskell's native laziness.
11:57:59 <Ralith> I specifically want the remaining unparsed String to be available in the parser.
11:58:00 <quicksilver> well, whether your code your own laziness or use Haskell's, surely this is still the effect of having a lazy tokeniser?
11:58:09 <Ralith> as I descrbed above.
11:58:09 <Valk> Oh, oops, sorry! Forgot to modify my instance declaration after experimenting with the types. It works now. Thanks!
11:58:13 <Valk> c_wraith++
11:58:14 <quicksilver> if you have a lazy tokeniser then you get operational interleaving.
11:58:22 <Valk> (Or whatever the karma command is.)
11:58:28 <Ralith> operational interleaving is orthogonal to my need.
11:58:37 <c_wraith> Valk: excellent
11:58:59 <Ralith> the problem is the 'conceptual' two-pass.
11:59:17 <ReinH> Ralith: that's the difference between theory and practice, right? ;)
11:59:24 <ReinH> in theory, it works in practice.
12:00:07 <nand`> Can I center text in gloss?
12:00:35 <ReinH> Ralith: what kind of language is it?
12:00:42 <ReinH> (that you're parsing)
12:01:04 <Ralith> ReinH: s-expressions
12:01:29 <exFalso> hi, i'm trying to cross compile ghc for powerpc. Do i need a cross compiler gcc first?
12:02:11 <exFalso> should i be asking that @ #ghc?
12:04:29 <nand`> edwardk: have you defined a Setter (a,a) (b,b) a b anywhere?
12:04:37 <edwardk> no
12:04:51 <nand`> shame
12:04:59 <edwardk> it can be an actual traversal =P
12:05:04 <nand`> indeed
12:05:15 <geekosaur> exFalso, ghc cannot cross-compile at all.  You can produce an unregisterised build, which generates slow but portable ANSI C
12:05:38 <ReinH> Ralith: what about Happy?
12:05:47 <edwardk> Data.Pair.Lens.both :: Traversal (a,a) (b,b) a b ?
12:05:48 <nand`> edwardk: ‚Äòboth‚Äô would be a nice name
12:05:52 <edwardk> heh
12:05:54 <nand`> looks good to me
12:05:54 <geekosaur> but I suspect that won't help you
12:06:02 <Ralith> ReinH: what about it?
12:06:11 <ReinH> Ralith: have you tried it?
12:06:21 <Ralith> nope.
12:06:21 <nand`> edwardk: ballSpeed.both %= (* speedIncrease)  -- :)
12:06:26 <edwardk> heh
12:06:46 <Ralith> I'm trying to stay with parsec for outside reasons
12:07:04 <exFalso> geekosaur: http://hackage.haskell.org/trac/ghc/wiki/CrossCompilation there is a comment hinting at cross compilation support in 7.4.1?
12:07:18 <ReinH> Ralith: ok
12:09:06 <exFalso> also, i could compile stage1, in stage2 there were "unknown instruction" errors coming from gcc, which is why i'm wondering whether a cross compiler gcc is needed
12:09:24 <geekosaur> exFalso, that's news to me.  it also says you need to ask in #ghc and get help from the ghc devs --- this is pretty clearly not quite releae quality
12:09:38 <geekosaur> and yes, a cross-gcc would be necessary for building the runtime
12:10:03 <geekosaur> that's also where you're likely to run into problems trying to do this
12:10:04 <exFalso> geekosaur: ok, thank you!
12:10:14 <exFalso> yeah...
12:10:47 <ReinH> Ralith: is your language context-free?
12:11:00 <Ralith> should be.
12:11:07 <ReinH> Ralith: then you probably want an Applicative?
12:11:11 <Ralith> huh?
12:11:25 <ReinH> you don't need intermediate structures
12:11:31 <geekosaur> the relationship between the compiler and the runtime is painfully incestuous, I'm afraid.  not entirely impossible something thinks it can build something with the cross-compiler and then run it to generate some header or something
12:11:32 <ReinH> you can bind to a name immediately
12:11:37 <ReinH> so you don't need a monadic parser
12:11:43 <Ralith> bind what? o.O
12:11:56 <ReinH> Ralith: sorry, you can tokenize immediately
12:12:11 <Ralith> what does 'immediately' mean there
12:12:13 <exFalso> ouch
12:12:28 <ReinH> Ralith: without preserving context
12:12:44 <Ralith> what good does that do me?
12:13:21 <exFalso> i'll try building a cross-gcc and then see whats what, thanks!
12:14:10 <ReinH> Ralith: if you don't need backtracking, it's much easier to for a recursive parser to walk through the string and return a list of token pairs lazily
12:14:32 <ReinH> which is I think what you're after?
12:14:41 <Ralith> 'token pairs'?
12:14:59 <ReinH> (Token, String)
12:15:03 <Ralith> right
12:15:20 <ReinH> Ralith: so are you using parsec applicatively or monadically?
12:16:08 <Ralith> now that I think about it I think there's a little context introduced by ambiguity between various kinds of number literals
12:16:20 <ReinH> Ralith: lisp f.e. is context-sensitive
12:16:23 <ReinH> so I was a bit worried :)
12:16:31 <Ralith> :P
12:16:41 <Ralith> anyway I think I can get by just by stuffing the tail into the first-pass token type
12:16:51 <Ralith> would've been nice to intergrate more cleanly with the parsec API, is all
12:16:57 <ReinH> understood
12:17:15 <ReinH> it's a pretty great peg for certain hole shapes
12:17:52 <Ralith> I don't suppose it's possible to extract a character number from a SourcePos?
12:18:46 <quicksilver> it's up to you how you model SourcePos
12:18:54 <quicksilver> you can incorporate character numbers into it if you like
12:21:00 <Ralith> right, I'm just wondering if I can resolve all my needs by simply including an actual SourcePos :P
12:22:38 <gwern> > 2^((2050-2012)/1.5)
12:22:39 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:22:39 <lambdabot>    `GHC.Real.Fractional t'
12:22:39 <lambdabot> ...
12:22:43 <gwern> > 2**((2050-2012)/1.5)
12:22:45 <lambdabot>   4.227593519406609e7
12:23:32 <hpaste> nand` pasted ‚ÄúFunctional pong with lenses and gloss‚Äù at http://hpaste.org/72509
12:23:55 <roconnor> t7: did you get it to work?
12:24:18 <nand`> I guess it's a good sign if running hlint for the first time after having finished the code results in no warnings
12:24:49 <roconnor> nand`: or it is so bad that no one has even considered hlint rules for what you've written :P
12:25:00 <nand`> roconnor: equally possible :)
12:25:11 <nand`> roconnor: we need lots and lots and lots and lots of hlint rules for lenses
12:25:20 <nand`> ‚Äúeverything you've ever written is now a lens‚Äù
12:26:00 <roconnor> nand`: you used: `id`; why not: `^%~.traverse`
12:26:07 <roconnor> gah
12:26:09 * nand` :rolleyes:
12:26:13 <roconnor> stupid irc client
12:27:41 <danharaj> "error in array index"
12:27:46 <danharaj> I hate you error in array index.
12:27:50 <danharaj> Where are you hiding this time?
12:28:21 <chrisdone> BrianHV: you're supposed to use NoImplicitPrelude btw. and you can use this
12:28:22 <chrisdone> BrianHV: mod :: Double -> Double -> Double
12:28:22 <chrisdone> BrianHV: mod = ffi "%1 %% %2"
12:28:25 <chrisdone> BrianHV: which will get you mod. we should stick that in the stdlib. Int isn't supported just because I didn't export it yet, it seems we can export it with the usual operations provided we're careful to ensure the underlining JS operations don't go adding decimal places don't want people trying to take xs !! 1.5 inadvertently :o
12:28:34 <nand`> danharaj: time for type-safe indexing with static bounds checking?
12:29:00 <edwardk> or just use the lens
12:29:29 <danharaj> half my code is non-lense and the other half is lens right as I migrate.
12:29:40 <danharaj> (need lenses in monads for some of it :P)
12:29:49 <edwardk> =)
12:30:05 <danharaj> The impedance mismatch isn't so terrible it's just that I need to *find* where the mismatch is.
12:30:05 <roconnor> what are lenses in monads?
12:30:07 <edwardk> i'll see if i can release a monadic-lens package at some point for you =P
12:30:20 <edwardk> roconnor: been toying with a few variations on the design
12:30:29 <edwardk> you can do things with monadic side effects to get actions
12:30:42 <roconnor> edwardk: a -> m (b -> w a) ? :P
12:30:57 <edwardk> (c -> t m d) -> a -> t m b
12:31:22 <edwardk> most of the current things use m = Identity
12:31:48 <edwardk> but lenses for things like STArrays etc would use m = ST s or MonadST, etc.
12:32:01 <edwardk> and then a getter is empowered to become an 'action'
12:32:16 <roconnor> that seems strange
12:32:29 <edwardk> action :: (a -> m c) -> Action m a c -- where it acts in the monad
12:32:39 <edwardk> and they compose with .
12:32:51 <edwardk> it is very strange ;)
12:33:42 <edwardk> anyways current getters are just actions that with over some kind of ConstT r m -- for all 'r' and any monad m.
12:33:54 <edwardk> instantated at Identity lets you run them
12:34:34 <edwardk> (ConstT isn't a monad transformer its just a  composition putting the const inside the monad
12:34:46 <edwardk> i'm not sold on them yet
12:34:57 <edwardk> but i'm thinking about writing a few up in a separate package or something
12:35:06 <edwardk> and seeing if they are useful enough
12:35:28 <edwardk> do x <- foo^!bar.baz.quux
12:36:11 <edwardk> lets you chain actions, but you also have lens-like actions, which you probably want to be idempotent for getting purposes
12:37:14 <edwardk> i think its too invasive to the design of 'lens' to add them in directly right now
12:37:40 <danharaj> oh god
12:37:45 <edwardk> ?
12:37:50 <danharaj> I just realized my cabal config didn't have library profiling on by default.
12:37:56 <danharaj> Now I have to reinstall everything.
12:37:57 <edwardk> ?
12:37:59 <edwardk> hahaha
12:39:42 * hackagebot AspectAG 0.3.6.1 - Attribute Grammars in the form of an EDSL (MarcosViera)
12:45:48 <timthelion> {-Without having to do-} let foo = x in bar "pattern1" = foo ; bar "pattern2" = foo -- is there any way to match one deffinition to two patterns?
12:45:59 <nand`> I want to try outsourcing some of my pong code (the collision checking) to a physics library
12:46:11 <nand`> is there any pure physics library that doesn't involve IO I could use here?
12:46:23 <nand`> ideally one I can easily combine with gloss
12:46:59 <timthelion> nand`: reality doesn't use IO ;) -- asshole comment, sorry
12:47:28 <nand`> timthelion: I had to re-read that like 5 times to get it
12:47:46 <timthelion> nand`:  :D :D :D
12:47:55 <scooty-puff> i'm having trouble illustrating a problem i'm having - using MonadPlus from Either, i have a set of functions calls (mutually recursive) that look like: http://hastebin.com/toxicibibo.txt
12:48:07 <scooty-puff> where X is the only exit point
12:48:30 <scooty-puff> at the diamond like area, a few options are given (joined with mplus), then continues
12:48:39 <nand`> since I need to update in discrete time-based intervals, I could use something like Float -> SomeState -> SomeState
12:48:59 <scooty-puff> however, on backtrack, i would like each of those retried - is there a way to do this without restruction it to 3 streams looping back?
12:49:24 <scooty-puff> https://github.com/sonyandy/unify/blob/master/examples/unify-main/Main.hs#L44
12:49:27 <scooty-puff> is the related code
12:50:05 <scooty-puff> "flight" is the 3 streams, that are rejoined at "&& reach z y"
12:51:18 <scooty-puff> if flight includes the clause x == Chicago && y == LosAngeles after the first x == Chicago, and the reachability of x := Chicago, y := LosAngeles is checked, it will fail
12:51:55 <scooty-puff> however, if i move "&& reach z y" into the flight function (and into each disjunction), it works
12:54:40 <nand`> (In particular, I'm interested in 2D body physics)
12:54:45 <danharaj> what I don't understand is, since cabal *knows* when I am missing a profiling library, why can't it just install the profiling version automatically?
12:55:36 <timthelion> danharaj: don't you want to write us a new package management system?  We all hate cabal.
12:55:45 <danharaj> I like cabal except when I don't.
12:59:04 <nand`> my package manager does that (for haskell packages, which is why I mentioned it)
13:00:47 <tempire> https://gist.github.com/3240125
13:00:59 * roconnor kinda wants to write a new package management system.
13:01:09 * ciaranm already wrote one
13:01:36 <tempire> Since span returns all the elements that match (==x), I would expect first to have [3,3], but it only has 3, since x must be prepended with (x:first)
13:01:52 * tempire asks why
13:01:55 <roconnor> it seems really hard.  I haven't quite understood how to manage "versions" of packages
13:02:21 <ciaranm> there's that quote from Babbage about people asking whether his machine would give the right answers if given the wrong input. writing a package mangler is basically doing just that.
13:02:30 <roconnor> beyond treating them as unrelated packages
13:02:54 <nand`> roconnor: you mean for having multiple versions of the same package installed?
13:03:15 <ciaranm> gentoo got the right concept for that ten years ago, with slots
13:03:20 <roconnor> nand`: no, I don't think I mean that; clearly multiple versions of tehe same package should be allowed
13:03:25 <roconnor> *the
13:04:03 <roconnor> nand`: but this leaves the question as to what version numbers mean.
13:04:08 <nand`> tempire: span is being applied to ‚Äòxs‚Äô, not ‚Äòx:xs‚Äô so the first x you removed is already gone
13:04:27 <roconnor> maybe version numbers are just part of the name of a package
13:04:33 <tempire> oooooh
13:04:36 <tempire> excellent, thanks.
13:04:45 <nand`> roconnor: I don't think treating version numbers as completely separate packages is valid, since for example I want my package manager to update to newer versions of the ‚Äòsame‚Äô package automatically, and I want dependencies on version ranges of a single package
13:05:00 <ciaranm> what will really get you with version numbers is whether 1.10 > 1.9 or not
13:05:10 <ciaranm> nearly everyone thinks it is. except perl.
13:05:14 <nand`> ciaranm: I think it is too
13:05:33 <nand`> ciaranm: clearly, the solution is to use ordinals to make it explicit
13:05:44 <ciaranm> nand`: perl versions aren't even orderable
13:05:46 <roconnor> nand`: ya, and I want a pony :D
13:06:01 <ciaranm> in perl you can have versions such that a > b > c > a
13:06:13 <danharaj> did somebody say ponies?? I want a pony.
13:06:30 <nand`> GHC version œâ¬≤¬∑7 + œâ¬∑4 + 2
13:06:33 <nand`> what's the problem?
13:07:50 <timthelion> Is someList++(someElement:[]) hugely inefficient in haskell?  Like should I do the old perl trick of reversing the list if I'm going to do this many times?
13:07:57 <dgpratt> Well, it's official, folks...Haskell has hit the big time!
13:08:07 <timthelion> dgpratt: ?
13:08:13 <dgpratt> Thanks to the heroic efforts of yours truly, Haskell will be the topic of our next .Net Developer user group meeting.
13:08:28 <danharaj> but Haskell isn't .Net
13:08:28 <timthelion> oh
13:08:32 <nand`> timthelion: it's a linked list, so appending to the end is fairly inefficient
13:08:34 <danharaj> Wouldn't F# make more sense :P
13:08:42 <danharaj> nand`: except when laziness means it's ok.
13:08:47 <dgpratt> now I know you're thinking, "Big Deal!", but what you don't realize is...
13:08:49 <nand`> yeah
13:08:50 <geekosaur> timthelion, lists are exactly that... singly linked lists.  Not arrays,
13:09:05 <dgpratt> my UG is in Eastern Maine...Eastern Maine!
13:09:16 <nand`> timthelion: if you need to append to the end a lot I would use a data structure suited for this
13:09:20 <timthelion> geekosaur: it seems so ugly to reverse it though :/
13:09:21 <dgpratt> believe me, if it gets here, it's going places!
13:09:22 <nand`> like a sequence or a snoc list
13:09:32 <nand`> I wouldn't go with reversing :(
13:10:05 <danharaj> appending to a list you're going to evaluate front-to-back lazily isn't that expensive.
13:10:05 <nand`> (unless of course you write an isomorphism [a] -> RevList a, then I'd be fine)
13:10:06 <dgpratt> danharaj: sometimes I wonder if F# was a very bad thing to happen to FP
13:10:07 <danharaj> It's a thunk.
13:10:19 <timthelion> dgpratt: everyone already uses haskell though.  And if it becomes haskell.net I'll quit
13:10:36 <nand`> don't worry, Haskell is immutable
13:10:51 <danharaj> just use unsafeLanguageExtension
13:10:52 <dgpratt> timthelion: maybe so, but until it hits Eastern Maine, it's not official
13:10:55 <nand`> even if somebody bastardizes it into a Haskell.NET spin-off that doesn't mean you can't continue using the current
13:11:09 <timthelion> dgpratt: never even heard of Eastern Main.
13:11:24 <dgpratt> timthelion: you accidentally an 'e'
13:11:46 <timthelion> dgpratt: where?
13:11:59 <timthelion> oh
13:12:01 <timthelion> Maine
13:12:06 <timthelion> You in France?
13:13:05 <timthelion> or england, or some other backwards country that adds needless things to the ends of words?
13:13:30 <dgpratt> timthelion: there's Southern Maine, which is unofficially still a part of Massachusetts, and Eastern Maine...there's also rumored to be a Northern Maine, but frankly I doubt it
13:14:29 <timthelion> dgpratt: OOHHHH, I see, Maine, like the state, not Main like the junction.
13:14:47 <dgpratt> timthelion: right-o!
13:14:58 <timthelion> Now I get it.
13:15:39 <timthelion> Isn't like 7 am EST?
13:16:00 <dgpratt> timthelion: err...no
13:16:15 <timthelion> Sorry, I'm on CET, so it's like 10pm where I am...
13:16:29 <timthelion> or not CET, but whatever the timezone to the east of that is.
13:16:33 <dgpratt> it just got very quiet in here...makes sense, I think folks are still processing this shocking new information
13:16:46 * timthelion realises, he doesn't know his timezone!
13:17:52 <dgpratt> timthelion: you're east of EST?!
13:18:08 <dgpratt> or CET? so confused
13:18:10 <timthelion> I guess I'm in CEST
13:18:24 <timthelion> I'm in Prague, whatever timezone that is :D
13:18:35 <dgpratt> timthelion: I don't think that's an appropriate topic for this forum
13:18:42 <mekeor> @time timthelion
13:18:44 <lambdabot> Local time for timthelion is Thu Aug  2 22:17:28 2012
13:19:08 <timthelion> mekeor: Wait, that is so bad ass :D
13:19:11 <timthelion> @time dgpratt
13:19:13 <lambdabot> Local time for dgpratt is Thu Aug 02 16:18:53
13:19:21 <nand`> roconnor: if you're looking for a good approach to package versioning, I like what portage does: it resolves concurrent installs via ‚Äòslots‚Äô, and handles version comparisons entirely as you'd expect them to, for example ‚Äò7.4.1-r1‚Äô is above ‚Äò7.4.1‚Äô but ‚Äò7.4.2_pre3‚Äô is below ‚Äò7.4.2‚Äô
13:19:21 <mekeor> @time augur_
13:19:22 <lambdabot> Local time for augur_ is 2012-08-02 20:19:02 +0000
13:19:40 <timthelion> @time lambdabot
13:19:40 <lambdabot> I live on the internet, do you expect me to have a local time?
13:19:45 <nand`> the only thing that feels hacky about it is the convention of using version 9999 for ‚Äòlive‚Äô packages
13:19:47 <otters> does forkIO create a new OS thread?
13:19:54 <c_wraith> no
13:20:23 <augur_> mekeor: beep
13:20:33 <mekeor> boop
13:20:36 <augur_> mekeor: im in DC
13:20:38 <augur_> so that time is wrong
13:20:41 <mzero> do cabal configuration flags automatically result in some compile time flag I can test in my source - either through some cabal generated .hs file, or c-preprocessing?
13:20:44 <augur_> its current 4:20p here
13:20:44 <mekeor> ah, oh, okay.
13:20:54 <mzero> or do I have to use conditionals in my .cabal file to add -DFoo flags to GHC?
13:20:59 <mekeor> augur_: yea, i guessed that you're time differs from mine extremly.
13:21:09 <c_wraith> mzero: the latter
13:21:15 <timthelion> mekeor: your, your
13:21:38 <mzero> fie - seems like something that should be more "integrated" that having to use c pre-processing -
13:21:41 <c_wraith> mzero: cabal *does* set some CPP flags by itself, but none based on what configuration flags it had
13:21:50 <Cale> otters: forkIO only creates a new Haskell thread, it's very lightweight.
13:22:07 <mzero> I would be happier if it generated a file, like it does for paths, that was configuration variables of type Bool
13:22:12 <mekeor> timthelion: oh, yes, i know. that happens automatically, you know. i mean, subconsciously.
13:22:12 <otters> do haskell threads run in parallel?
13:22:32 <ciaranm> otters: potentially yes
13:22:34 <merijn> otters: If you compile with -threaded and instruct the runtime to use multiple OS threads, then yes
13:23:01 <merijn> otters: Haskell threads get multiplexed on 1 or more OS threads
13:23:20 <otters> Okay
13:24:11 <merijn> As for how costly there are, server applications using them for IO should easily be capable of dealing with 100k threads
13:24:19 <c_wraith> mzero: well, that's not really feasible for when the flags control alternatives that wouldn't even compile if the wrong one was chosen. That's a pretty common use for them
13:27:07 <mzero> sure - but I'm just trying to distingush developer from production build - a   Foo_flags.hs file could just like Bool flags for each configuation - which would be useable in many situations
13:36:39 <nand`> edwardk: first = adjust _1
13:36:45 <edwardk> yep
13:36:45 <nand`> another cute little redundancy thanks to lenses :)
13:37:02 <edwardk> as dsls go it has a lot of power
13:37:19 <edwardk> writing code to make it so the template haskell can autogenerate a class to precompose on all of its lenses
13:37:34 <edwardk> so given a monomorphic type Foo, you can get HasFoo
13:37:56 <edwardk> then the field lenses will all precompose the 'foo' lens
13:38:05 <edwardk> its a common enough idiom and i want to kill the boilerplate
13:38:14 <nand`> not sure I understand, code example?
13:38:51 <Enigmagic> classy-lenses!
13:38:53 <edwardk> data Foo = { _fooYear :: Int, _fooMonth :: Int, _fooDay :: Integer }; makeClassyLenses ''Foo
13:39:00 <edwardk> thats what i'm calling it ;)
13:39:23 <edwardk> then you get a class HasFoo t where foo :: Simple Lens t Foo
13:39:25 <Enigmagic> sure to cause much popcorn to be eaten while refreshing reddit
13:39:29 <edwardk> instance HasFoo Foo where foo = id
13:39:51 <edwardk> and your lenses will come out
13:40:22 <edwardk> fooYear :: HasFoo t => Simple Lens t Int; fooMonth :: HasFoo t => Simple Lens t Int; fooDay :: HasFoo t => Simple Lens t Integer
13:40:29 <nand`> got it :)
13:40:47 <edwardk> so when later you make dat Bar = Bar { _barFoo :: Foo }; makeClassyLenses ''Bar; you can define
13:41:00 <edwardk> instance HasFoo Bar where foo = fooBar
13:41:09 <edwardk> and then all the other lenses will work on it
13:41:16 <edwardk> no boilerplate
13:41:21 <danharaj> Why not a mptc `Has'? :P
13:41:39 <edwardk> because how do you use it?
13:41:43 <nand`> so you want to kill barFoo.fooYear
13:41:56 <danharaj> Has Foo t => ... doesn't work?
13:41:59 <edwardk> i just want to make it unnecessary to manually precompose a lens filter
13:42:10 <edwardk> danharaj: the problem is the call then needs an explicit signature to tell it which one it means
13:42:18 <danharaj> ah I see.
13:42:19 <edwardk> it doesn't know which has you want
13:42:33 <edwardk> i tend to shy away from MPTCs for that reason when i want to make an easy to use dsl
13:42:48 <edwardk> its too easy to fall into the morass that is stuff like the classy-prelude where you need signatures on everything
13:43:23 <edwardk> anyways it only makes Has predicates for monomorphic types
13:43:31 <edwardk> if your typeclass takes arguments i don't build the class
13:43:31 <Enigmagic> edwardk: yeah i ran into the explcit signature thing a while ago when dicking around with lenses and dates : https://github.com/alphaHeavy/time-cube/blob/master/fclabels/Data/Time/Cube/Label.hs#L181
13:43:40 <nand`> edwardk: was just wondering about that
13:44:00 <edwardk> Enigmagic: messy eh? =)
13:44:18 <danharaj> Too bad you can't pass types to terms explicitly. So you could have `has' as the member of Has and you say `has Foo' in code instead of `foo'
13:44:22 <Enigmagic> edwardk: yeah ... mainly annoying that it would be required for each lens package
13:44:56 <Nereid> has (undefined :: Foo)
13:45:00 <Nereid> -- gross
13:45:03 <danharaj> indeed
13:45:07 <edwardk> yeah thats worse than the problem
13:45:14 <edwardk> at least use Proxy ;)
13:45:34 <edwardk> but then you're back to where we started
13:45:43 <edwardk> has proxyFoo  vs foo
13:45:46 <edwardk> foo is shorter
13:46:42 <nand`> time lenses, I hadn't even considered that yet
13:46:44 <nand`> nice
13:46:44 <edwardk> i also make isomorphisms in preference to classes. its a mess of configuration options
13:46:58 <edwardk> i had lenses for data.time.calendar in lens but i ripped them out
13:47:00 <quicksilver> edwardk: you don't always want Hasthings to be unique data types
13:47:03 <edwardk> too much variation in the design space
13:47:18 <danharaj> You mean your preference isn't the One True Way?
13:47:30 <edwardk> quicksilver: you can build them, i just won't build them by default
13:47:34 <quicksilver> edwardk: it would be quite sane to have HasRadius and HasCircumference both being doubles
13:47:39 <danharaj> Clearly you are not a library implementer
13:47:42 <quicksilver> true
13:48:12 <edwardk> and the Has thing is named by a delegated function
13:48:19 <edwardk> by default it just bolts 'Has' on the front
13:48:39 <edwardk> danharaj: clearly ;)
13:48:57 <danharaj> almost done reinstalling my entire environment ._. now I can turn on profiling!
13:49:33 <Enigmagic> edwardk: i frequently need to calculate stuff like 'seconds since the beginning of the day in eastern time'. i think it should be possible to make this work right using lenses but haven't found a design that i like.
13:49:39 <edwardk> makeClassyLensesWith ''Foo $ classLensRule <- const (Just "ASDHK") $ defaultLensConfig -- would let you name it whatever you want.
13:49:56 <Enigmagic> just adding the basics "seconds since epoch", "day of month", etc isn't enough
13:50:10 <edwardk> Enigmagic: check lens 1.2 it had a sketch of a design. i'll probably do something similar to time-lens, but i want it to be a separate package
13:50:20 <danharaj> edwardk: do you guys use lenses at work in your in-house lang?
13:50:24 <edwardk> breaking changes to the api mandate a major version bump in the pvp, and i'd iterate that design too much
13:50:36 <edwardk> we used to use them a _lot_. the current design is pretty light on lenses though
13:50:47 <edwardk> he issue is we live in scala
13:50:55 <edwardk> and this approach isn't very scala friendly
13:51:02 <edwardk> i've been able to concoct something like
13:51:03 <Enigmagic> edwardk: yeah i've been trying various things out in time-cube. hoping to get it to the point that we can use it instead of our older home grown time library.
13:51:22 * nand` goes ahead and makes himself a live package for lens so he always gets the latest and greatest
13:51:56 <edwardk> class LensLike[+T[+_],-A,+B,+C,-D] { def apply[F[+_]<:T](f: C => F[D], a: A): F[B] } -- and you can roll combinators for it, etc.
13:51:57 <Enigmagic> i'm toying with putting the timezone in the type. PosixTime 'UTC, or PosixTime "US/Eastern"
13:51:57 <edwardk> but its hard
13:53:22 <astory> I'm trying to benchmark some computation, and I need a way to force evaluation of an expression (in an IO monad, if that helps, but the expression itself is pure).  I don't think seq does this because it just forces the head.  What do?
13:53:46 <Enigmagic> astory: NFData from deepseq
13:53:46 <Nereid> what about deepseq
13:53:54 <astory> didn't know about that, looking up
13:54:09 <ciaranm> deepseq should be called !!!
13:54:16 <astory> looks like what I want, thanks
13:57:20 <djahandarie> copumpkin, you're not coming to hac phi?!
13:57:30 <copumpkin> djahandarie: not any more :(
13:57:36 <djahandarie> What!
13:57:37 <copumpkin> dmwit: I should probably unsubscribe :(
13:57:54 <copumpkin> I'm sick and feel rotten
13:57:55 <djahandarie> Just wear one of those white mask things
13:57:58 <copumpkin> lol
13:58:11 <alpounet> hah
13:58:29 <djahandarie> You're probably just hungover from vegas still
13:58:49 <chrisdone> copumpkin: take some cocodamol :p
13:58:58 <djahandarie> Whoa, it's chrisdone
13:59:05 <chrisdone> shut up ya face!
13:59:08 <chrisdone> hi :)
13:59:11 <djahandarie> Snap
13:59:34 <copumpkin> :)
13:59:37 <copumpkin> not hungover, nope
13:59:52 <djahandarie> Well I'd love to drive this channel more off-topic, but looks like it's time for me to go home and then fix my half-broken computer
14:00:00 * djahandarie waves
14:00:34 <luite> it's chrisdone!
14:01:52 <luite> i'm doign some ghcjs hacking because he's stealing all our clientele with fay ;)
14:01:58 <chrisdone> lol
14:03:06 <mekeor> chrisdone: thanks
14:03:22 <astory> is there a way to use deepseq without having to make my object an instance of NFData?  It's complex and I don't want to add a dependency on deepseq to my libraries if I can avoid it
14:03:33 <luite> no actually i'm trying to experiment with  not using javascript closures for haskell closures, and hope that that will be more performant and less leaky
14:04:23 <Enigmagic> astory: no. deepseq ships with GHC so it's not all that bad.
14:04:29 <c_wraith> astory: nope. deepseq x y = rnf x `seq` y
14:04:43 <chrisdone> luite: not using javascript closures? what do you use in place of it?
14:04:43 * JoeHazzers waves to clsmith 
14:04:48 <astory> ok, I'll just have to argue with my coworkers tomorrow then :D
14:04:49 <luite> chrisdone: arrays
14:04:54 <Enigmagic> astory: you could make a function that uses seq to evaluate your type, it would be about the same amount of work unless you're using other types with NFData instances already.
14:05:04 <scooty-puff> does anyone have an experience with unification-fd and if it can handle backtracking properly?
14:05:09 <scooty-puff> (for IntBinding)
14:05:14 <astory> Enigmagic: it's all build from NFData types, but it's pretty deep tree
14:05:32 <astory> hrm, except for channels
14:05:45 <astory> I'll have to write this myself then I guess
14:06:01 <chrisdone> luite: like what?
14:06:05 <astory> so if I recurse down and `seq` everything, it'll be equivalent?
14:06:06 <luite> chrisdone: a thunk is an "enter" function and an array of free variables.
14:06:19 <luite> chrisdone: where only dynamic free variables are included, static ones
14:06:25 <luite> can be referred to directly
14:06:36 <chrisdone> that's faster than using a built-in js closure?
14:06:45 <luite> dunno, i'm trying to find out
14:07:13 <chrisdone> js closures are super optimized in v8 and spidermonkey. i'll be interested to see if that does work
14:08:11 <donri> hm aren't arrays in js horrible
14:08:46 <donri> chrisdone: did you see that silkapp talk i linked you on reddit? he implies that nested closures sucked for performance
14:08:49 <chrisdone> benchmarks in da house
14:09:01 <chrisdone> donri: er let me see
14:09:16 <donri> http://skillsmatter.com/podcast/home/silkapp-a-case-study-in-creating-rich-internet-apps-in-haskell/js-3880
14:09:19 <edwardk> the main problem with evaluating stg code in javascript is you lack the wadler-style gc assistance you need to avoid leaking memory
14:09:38 <luite> chrisdone: how does the garbage collector deal with them, say i have a closure with a huge array x, but the function i return only uses some small y. can it collect x then?
14:09:48 <edwardk> you need the garbage collector to automatically forward field accessors to the part of the structure they access or you wind up with a huge class of space leaks
14:10:20 <ParahSailin_> :t error
14:10:20 <luite> chrisdone: ohter than performance of nested closures, this leaky stuff is what i'm trying to solve :)
14:10:22 <lambdabot> forall a. [Char] -> a
14:10:22 <edwardk> the usual example is you have an unevaluated fst applied to (a, HUGE_MESS)
14:10:34 <edwardk> you want the gc to replace that with 'a'
14:10:42 <edwardk> so it can throw away the HUGE_MESS
14:11:06 <astory> ugh, I think it's actually less work to just show the string and just print out the length to some file that I can delete.
14:11:43 <luite> don't have the accessor thunk type yet though
14:11:45 <edwardk> unfortunately, this is a pretty big problem and without a resolution to it, no 'hey look i compiled my toy lazy language to javascript' tool will be able to avoid leaking memory
14:12:22 <Enigmagic> astory: you can deriving NFData instances using derive (or other template haskell libraries) and copy & paste the generated code into your library if you don't want a template-haskell dependency
14:12:23 <fryguybob> I know, lets ditch JS! ... sigh ...
14:12:39 <edwardk> http://homepages.inf.ed.ac.uk/wadler/topics/garbage-collection.html is the paper iirc
14:12:52 <edwardk> fryguybob: it bites us with our toy language here in java even a little
14:13:09 <luite> edwardk: that's already in my ghcjs directory in goodreader :)
14:13:11 <chrisdone> luite: sure, depends on the particular GC of course. (function(){var x = hueg_array; return function(){ return 1; }; }) /could/ do region analysis and strip the x from the environment, but i doubt it. did you test that (as opposed to speculating)?
14:13:15 <edwardk> luite: just wanted to let you know there are some space leaks you won't be able to quash without modeling the whole heap yourself
14:13:39 <edwardk> that said you can still get pretty far
14:14:39 <luite> edwardk: yeah that's pretty much what i'm doing atm, every heap object is an array with free variables, but it's a lot of work to fully implement these accessor thunks and bitmaps
14:15:10 <edwardk> well, what i mean is you need to perform the actual gc pass yourself to forward accessors to make that problem go away
14:15:13 <edwardk> which is a pain
14:15:14 <luite> and i need a stack with continuations now...
14:15:39 <luite> edwardk: oh the gc pass needs to be done anyway, otherwise there's no way to run finalizers
14:15:40 <edwardk> fortunately with the ambient gc in place you don't need to do so very often
14:15:49 <edwardk> *nods*
14:15:50 <edwardk> good
14:16:47 <luite> anyway it'
14:17:00 <luite> anyway it's all been written in papers, so the rest is just scribbling ;)
14:17:20 <roconnor> nand`: version comparison doesn't bother me so much as what versioning means.
14:17:37 <luite> (which means i have no idea what i'm getting myself into)
14:18:09 <jfischoff> anyone know a function like: isNatural :: String -> Bool ?
14:18:20 <roconnor> You cannot automatically update to "newer" versions safely
14:18:26 <luite> also i still donkt know how yet to implement exceptions (regular and async)
14:18:35 <solrize> jfischoff, you mean you want to check for a digit string?
14:18:41 <solrize> i think you'd normally use readS
14:18:49 <Digit> ^_^
14:18:54 <luite> so anyone want to sponsor ghcjs dev, haskell in browser is fun, right? :p
14:19:04 <jfischoff> solrize: okay cool
14:19:53 <alpounet> > all . map isDigit $ "1243"
14:19:54 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
14:19:54 <lambdabot>         against inferred ...
14:20:17 <sipa> drop the $
14:20:20 <c_wraith> either "and" or remove the "map"
14:20:27 <c_wraith> > all isDigit "1234"
14:20:28 <lambdabot>   True
14:20:39 <gdeest> solrize: read will throw an exception if the string doesn't represent a natural, right ?
14:20:42 <jfischoff> ah isDigit cool
14:20:49 <c_wraith> > and . map isDigit $ "1234"
14:20:50 <gdeest> not sure that's what jfischoff really wants
14:20:51 <lambdabot>   True
14:20:56 <luite> i should've done this for gsoc :(
14:21:18 <jfischoff> isDigit works
14:22:06 <nand`> > read " 1234 " :: Integer
14:22:07 <lambdabot>   1234
14:22:12 <ParahSailin_> :t zip
14:22:13 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
14:22:18 <solrize> isDigit isn't really the right thing, you have to handle signed numbers, 0x hexadecimals etc
14:22:36 <gdeest> well, it depends on the usecase
14:22:39 <nand`> solrize: signed numbers are not natural either way
14:22:57 <solrize> oh ok
14:22:59 <nand`> negative ones, that is
14:23:22 <solrize> > reads "123"
14:23:23 <lambdabot>   []
14:25:28 <solrize> :t reads "123"
14:25:29 <lambdabot> forall a. (Read a) => [(a, String)]
14:25:39 <solrize> > reads "123" :: [(Int, String)]
14:25:40 <lambdabot>   [(123,"")]
14:25:46 <solrize> > reads "0x123" :: [(Int, String)]
14:25:47 <lambdabot>   [(291,"")]
14:25:52 <solrize> > reads "x1y23" :: [(Int, String)]
14:25:53 <lambdabot>   []
14:26:04 <solrize> > reads "123xy4" :: [(Int, String)]
14:26:05 <lambdabot>   [(123,"xy4")]
14:26:13 <S11001001> edwardk: http://hackage.haskell.org/packages/archive/acme-php/0.0.1/doc/html/Prelude-PHP.html
14:26:22 <edwardk> *twitch*
14:26:29 <S11001001> edwardk: source link for fun
14:27:12 <edwardk> Safe-Infered!
14:27:54 <solrize> > let isNatural s = case reads s of { [(n::Int),""] -> n>=0; otherwise -> False } in map isNatural ["123","-234","0x234","234xy432"]
14:27:55 <lambdabot>   Couldn't match expected type `(a, GHC.Base.String)'
14:27:55 <lambdabot>         against inferre...
14:27:56 <luite> chrisdone: no not tested
14:29:34 <roconnor>  properFraction x = (proper, frac) where proper = fromInteger (read (takeWhile (/= '.') x)); frac = tail (dropWhile (/= '.') x)
14:30:23 <roconnor>   cos x = sin (x + 90)  ?!
14:30:39 <sipa> yes
14:30:58 <alpounet> in degrees, yes
14:31:53 <roconnor>   sin x = show (sin (read x))
14:31:55 <danharaj_> What's a degree.
14:32:27 <roconnor> sortBy compare = head . head . dropWhile (not . null . drop 1) . group . iterate bubble
14:32:56 <nand`> ‚Äú-- sort function, optimized for lists‚Äù
14:33:13 <roconnor> PHPlint says you wrote (drop 1) why not (tail) ?
14:33:21 <mauke> roconnor: []
14:34:18 <sipa> danharaj_: pi/180 radials
14:34:25 <nand`> foldl' f z xs = xs `seq` foldl f z xs
14:34:30 <c_wraith> sipa: that's a lot of tires
14:34:45 <sipa> ...?
14:34:50 * hackagebot swish 0.7.0.0 - A semantic web toolkit. (DouglasBurke)
14:35:01 <c_wraith> holy crap.  subtract = (-)
14:35:01 <c_wraith> nice
14:35:43 <c_wraith> sipa: just a joke about radials vs radians
14:35:54 <chrisdone> luite: in a trivial case it works
14:35:58 <hpaste> chrisdone pasted ‚Äútrivial gc test‚Äù at http://hpaste.org/72514
14:36:30 <sipa> c_wraith: oh, in dutch it is "radiaal", so i probably incorrectly assumed it was radial in english
14:37:14 <chrisdone> luite: i trigger the gc manually with gc(); to avoid having to write some code to make the generations occur
14:37:26 <chrisdone> (as a 'real' program would)
14:37:44 <jfischoff> chrisdone: how are the benchmarks looking?
14:38:17 <luite> ah that's good news
14:38:27 <chrisdone> luite: but x() ends so maybe the environment is ending, so let's try gc maybe from *within* x()
14:38:37 <c_wraith> sipa: I realized that after you didn't get my joke. Sorry about that.
14:39:01 <sipa> np, learnt (learned?) something!
14:39:28 <luite> chrisdone: also it doesn't refer to anything in foo anymore
14:40:19 <hpaste> chrisdone annotated ‚Äútrivial gc test‚Äù with ‚ÄúGC from within x‚Äù at http://hpaste.org/72514#a72515
14:41:01 <chrisdone> luite: but indeed this is a trivial test. i'd like to see the more real-worldy nested-functions code you're testing with, out of curiousity
14:41:28 <chrisdone> (i won't be implementing any such optimizations in fay, not now, too much work atm)
14:41:46 <chrisdone> jfischoff: for what aspect? i did add tail-call optimization for tail-recursive functions
14:42:17 <jfischoff> chrisdone: Oh I thought you said you had Fay benchmarks in da' house
14:42:24 <luite> chrisdone: can fay still overflow the js call stack where haskell wouldn't?
14:43:20 <chrisdone> luite: not sure. i don't think so, but not sure. a tail-recursive function won't, it will run in constant space. e.g. `forever' or a tail-recursive sum will run forever
14:43:36 <chrisdone> luite: does ghc do any more optimization than that?
14:44:04 <chrisdone> (well, it doesn't need to optimize away those of course. but i know it does do TCO additionally to make the tail-recursive functions go faster)
14:44:11 <luite> uh well, in stg almost anything is a tail call
14:45:26 <luite> it has a stack for arguments, but things don't need to be a tail-recursive function for it not to grow
14:45:34 <chrisdone> luite: so sum 0 = 0; sum n = 1 + sum (n-1) will run in constant space in ghc?
14:45:49 <chrisdone> (or any function like it)
14:46:57 <applicative> awesome Control.Lens illustration,  nand`
14:47:00 <jfischoff> is there a name for this function: f :: (a -> b) -> (a, a) -> (b, b)?
14:47:19 <chrisdone> jfischoff: well "sum 0 acc = acc; sum n acc = sum (n - 1) (acc + n)" compiles down to roughly while(true){ var tmp; if (n==0){return acc;} else { tmp = n; n = n-1; acc=acc+tmp } }
14:47:23 <JoeyA> Probably something in Arrow
14:47:28 <parcs`> jfischoff: join (***)
14:47:38 <jfischoff> parks`: thanks
14:47:40 <jfischoff> crap
14:47:49 <nand`> chrisdone: only if you make (+) strict
14:48:02 <nand`> actually I'm not sure
14:48:03 <chrisdone> nand`: (+) is strict
14:48:07 <luite> chrisdone: uh with optimization it would probably, without it, it would probably overflow, since it would apply (+), eval the first argument, and push a continuation for doing the rest of the sum
14:48:13 * jfischoff needs to figure out how to get rid of auto correct on colloquy
14:48:14 <chrisdone> jfischoff: which brings sum's speed down to 50ms~ where the pure js is 12ms~
14:48:29 <jfischoff> chrisdone: cool
14:49:03 <chrisdone> nand`: oh, i don't know which sentence of mine you're referring to
14:49:26 <chrisdone> luite: right
14:49:35 <nand`> chrisdone: the ‚Äòsum‚Äô. I declared your sum in ghci and ran ‚Äúsum (maxBound :: Int)‚Äù, what happened is that memory usage steadily increased at a slow pace until I got a stack overflow
14:49:43 <nand`> but that's unoptimized afaik
14:51:13 <chrisdone> nand`: i think with a strict + you still have to increase the stack with +  then compute sum(n-1), which in turn puts + on the stack, etc. but of course it depends on the optimizations in place!
14:52:19 <chrisdone> luite: so the ghc runtime is a trampoline? not sure i follow pushing a continuation -- to what?
14:52:53 <nand`> applicative: the pong?
14:53:18 <applicative> oh yeah, i was just studying the use of fancy lenses in it
14:54:23 <nand`> one thing I'm not quite happy about is how I use ‚Äòp <- get‚Äô
14:54:24 <luite> chrisdone: oh as i understand the paper is that a case e of ... statement enters the e thunk, and pushes a continuation of what to do with the result first. when something is reduced to a data constructor closure, it calls the continuation on entering
14:54:27 <chrisdone> luite: i considered using a trampoline but the speed hit is awful‚Ä¶
14:54:31 <applicative> tell edwardk to put it in the /examples directory :)
14:54:39 <edwardk> ?
14:54:40 * applicative looks at get
14:54:40 <nand`> I feel like I could be able to rewrite it somehow to avoid the state monad, but that deprives me of nice things like ‚Äòwhen‚Äô
14:54:44 <chrisdone> luite: ahhh, interestings
14:55:01 <luite> the enter code for a datacon does that directly
14:55:22 <luite> so even if it's been evaluated completely, just entering the thunk does the right thing
14:55:29 <edwardk> nand`: link?
14:55:31 <chrisdone> nod
14:55:33 <nand`> edwardk: http://hpaste.org/72509
14:55:36 <luite> of course this is paper, so in reality it may be much more cleverer
14:55:46 <applicative> i cant quite figure out how the definition of reset works I have to look at the types.
14:56:00 <chrisdone> i imagine many more special cases and tricks :)
14:56:05 <nand`> applicative: ^= is ^~ lifted into a state monad automatically
14:56:20 <nand`> so I'm just setting those two fields using their lenses
14:56:35 <luite> chrisdone: both calls are tailcalls here of course
14:56:54 <edwardk>     player1 %= (+ paddleSpeed * time)
14:57:01 <edwardk> player1 += paddleSpeed * time
14:57:02 <applicative> nand`: yeah, its clear  what it does even before you figure out how it can; thats one of the nice things
14:57:12 <nand`> edwardk: oh! oh! I can't believe I forgot about those
14:57:13 <edwardk> should work
14:57:18 <nand`> edwardk: it should :)
14:57:20 <luite> chrisdone: in my javascript implementation i just call with a regular function call, but still push the continuation so the computation can be resumed if the thunk reaches max stack depth or if the thread needs to be suspended for some reason
14:57:33 <nand`> that is so much cleaner, also -= gets rid of the ugliness
14:57:58 <luite> chrisdone: if the regular function call returns, yay, we have avoided the overhed of trampoline, otherwise the continuation is called
14:58:05 <edwardk> ballSpeed both *= speedIncrease
14:58:10 <edwardk> etc
14:58:19 <chrisdone> luite: sure
14:58:23 <ion> ballsPeed
14:58:34 <luite> chrisdone: it keeps a counter of how deep it is in the call stack and throws an exception if it reaches some depth
14:58:40 <edwardk> not bad over all. a bit more pointfree than i tend to go, but very readable
14:58:41 <chrisdone> luite: my friend tried a trampoline which just lets the stack increase normally and throws‚Ä¶
14:58:42 <chrisdone> yeah
14:58:42 <chrisdone> that
14:58:44 <chrisdone> :)
14:59:04 <applicative> it is quite readable, I thought
14:59:09 <nand`> edwardk: I wonder if we could shoehorn some ++like thing for += 1
14:59:09 <luite> yeah i benchmarked a few of that, and it didn't seem much faster than returning continuations to the trampoline in the usal way
14:59:33 <edwardk> nand`: ++ kinda sucks because of the lack of unary operators
14:59:36 <chrisdone> consistent with what he said. shame, as it's a clever idea, feels like it should've been more beneficial
14:59:37 <nand`> yeah
14:59:45 <edwardk> you can make 'increment' and 'decrement' though
14:59:48 <nand`> inc/dec could w--
14:59:50 <nand`> yeah
14:59:51 * hackagebot fast-tagsoup 1.0.0 - Fast parser for tagsoup package (VladimirShabanov)
15:00:04 <edwardk> not sure i want to put them in directly
15:00:24 <nand`> edwardk: I especially like the definition of ‚Äòhandle‚Äô
15:00:32 <edwardk> yeah
15:00:57 <luite> chrisdone: but perhaps in this more complex situation it still helps, since at least this lets you usually call fixed argument functions, instead of function.call or .apply or something, with an array of args (or loading them from some stack manually)
15:01:08 <edwardk> i may steal that approach for the arcade ;)
15:01:25 <luite> and regular function calls with arguments are 2x faster than vararg calls with array
15:01:28 <chrisdone> indeed
15:01:46 <hpaste> nand` annotated ‚ÄúFunctional pong with lenses and gloss‚Äù with ‚ÄúFunctional pong with lenses and gloss (added += etc)‚Äù at http://hpaste.org/72509#a72516
15:01:54 <levi> The stack calls + exception thing reminds me of Cheney on the MTA.
15:01:59 <edwardk> took me a minute to parse the score._2 %= (1+) >> reset lines
15:02:14 <nand`> edwardk: it's note score._2 += 1 >> reset
15:02:16 <nand`> it's now*
15:02:17 <edwardk> yeah
15:02:30 <edwardk> got a fresh hpaste yet? =)
15:02:38 <ion> _2 still exists and people are beginning to use it? :-(
15:02:44 <nand`> I feel like I could factor out some of the redundancies in ‚ÄòcheckBounds‚Äô
15:02:46 <edwardk> ion: its popular
15:02:50 <luite> chrisdone: anyway i don't really know what i'm doing so this might end up an utter failure :)
15:02:57 <applicative> ion, we're loving it
15:02:59 <nand`> I don't like the code duplication between ‚Äòcollide‚Äô and lines 101-103, also lines 113-121
15:03:11 <nand`> ion: got anything better?
15:03:21 <alpounet> _1 _2 etc reminds me of Boost
15:03:24 <nand`> ion: I would like ‚Äòfst‚Äô but the amount of code that would break is unimaginable
15:03:29 <ion> sndL
15:03:33 <applicative> ion, in fact nand renamed them _x and _y for some reason
15:03:33 <edwardk>   let { collide = do     ballSpeed._x %= negate  -- idn't want to indent farther?
15:03:49 <luite> chrisdone: but the current ghcjs code is too slow for what i want with it, so if i can't make it a lot faster, i'll have to find alternative for running haskell in js
15:03:51 <nand`> applicative: I did that for clarity since I was dealing with 2D points
15:04:00 <chrisdone> luite: i suspect in v8 that regular function calls with named args will even use registers. wouldn't be surprised anyway. i learned that function Foo(){this.x=1} is an order of magnitude faster than {x:1} because v8 will use a real struct with pointers for the object rather than a dictionary lookup. it's amazing to find these tricks, the speed gains‚Ä¶
15:04:04 <nand`> I wanted to see ‚ÄòballSpeed._y %= negate‚Äô and know instantly what's being done
15:04:15 <chrisdone> luite: just for bragging rights and motivation, how long does ‚Äúsum 0 acc = acc; sum n acc = sum (n - 1) (acc + n); sum 1000000 0‚Äù take? :p
15:04:21 <ion> Doesn‚Äôt GHC warn about evaluating things beginning with _?
15:04:25 <edwardk> no
15:04:32 <edwardk> it just doesn't warn if you don't use them
15:04:34 <chrisdone> (‚Ä¶ that is, bragging that you can run a trivial tail-recursive function fast)
15:04:38 <applicative> right of course, I was comprehending it when I was reading it.
15:04:41 <nand`> edwardk: I don't like indenting that far
15:04:46 <luite> chrisdone: hehe i can't even answer that becase the code generator is far from ready
15:05:00 <luite> chrisdone: i can only run stuff if i mostly hand-compile it :)
15:05:11 <luite> only started a few days ago with this
15:05:18 <chrisdone> ah, the intermediate state
15:06:01 <applicative> nand` edward as a tutorial illustration it would be helped if the type of a couple of the TH derived lenses was mentioned after $(makeLenses ''Pong)
15:06:10 <luite> i'm just doing simple singlethreaded stuff without exceptions, if it looks like it can get fast enough i'll continue
15:06:31 <nand`> ‚ÄòSimpleLens Pong Point‚Äô, ‚ÄòSimpleLens Pong Vector‚Äô etc.
15:06:42 <hpaste> chrisdone pasted ‚Äúbenchmarks‚Äù at http://hpaste.org/72517
15:07:13 <applicative> Simple Lens Pong Point
15:07:51 <luite> chrisdone: oh you can pass String directly/
15:07:55 <luite> to ffi
15:08:04 <nand`> edwardk: when are we getting Data.Pair.Lens.both ?
15:08:07 <chrisdone> luite: i know it's an isolated case, but for those tight loops (e.g. forM_ or foldl this is a literal JS while(){‚Ä¶}. are you going to consider using js native iteration constructs or is it not worth it?
15:08:12 <edwardk> its in my dev branch
15:08:21 <edwardk> i have a bunch of TH patches in flight though
15:08:33 <chrisdone> luite: yeah‚Ä¶ it serializes them into JS strings. is that a bad thing?
15:08:35 <edwardk> because the TH is getting smart enough to precompose stuff, and that adds a lot of edge cases
15:08:43 <edwardk> so i picked up a lot of flags and options i need to plumb through
15:08:59 <nand`> fair enough
15:09:23 <edwardk> makeLensesWith $ classLensRule <~ classyClassLensRule $ defaultLensRules -- etc
15:09:26 <luite> chrisdone: oh i guess not, ghcjs does have some conversion, but i don't think it has such a nice ffi function
15:09:27 <SailingPariah> How do you people deal with nasty people? Like just pure evil, manipulative people that tries to put you down.
15:09:42 <nand`> /ignore
15:09:50 <luite> chrisdone: are you going to add threads? so you can forkIO $ ajax ... ?
15:09:51 <chrisdone> luite: i guess in standard GHC it makes sense not to serialize String because it's specializing on a crappy performance data structure
15:09:59 <edwardk> i'll probably make nice names for those classLensRule <~ classyClassLensRule like combinators
15:11:23 <chrisdone> luite: not really, just normal async style. it seems one would sacrifice some speed for threading fairness? is that a deal breaker for you? i considered that js's async can be modelled with a monad. so x <- ajax ‚Ä¶ is really just ajax ‚Ä¶ >>\x -> anyway
15:12:11 <edwardk> makeLensesWith noClasses ''Foo or the like might be nicer
15:12:32 <edwardk> makeLensesWith (classLensRule <~ noClassLensRule) ''Foo
15:12:53 <luite> chrisdone: hmm, i'm not sure what you mean. can you continue running other haskell while waiting for the ajax result?
15:13:02 <chrisdone> luite: i like threads in haskell but, personally, i want a really simple close-to-js runtime that retains speed and doesn't abstract too much (well, as much as one can avoid that by using haskell). just because i want to reduce bewwilderment‚Ä¶ i don't know. what's your thoughts?
15:13:12 <chrisdone> luite: sure, as in normal js
15:13:14 <edwardk> then you can pass id for the base case or a id <~ of you want to set it or something
15:13:37 <chrisdone> luite: timeouts and jquery clicks and whatnot work, the ajax result isn't any different for me
15:13:55 <chrisdone> http://fay-lang.org/examples/canvas.water.html ‚Üê this is a simple timeout
15:14:06 <luite> cool!
15:14:26 <nvrpunk> good evening
15:14:27 <nvrpunk> :)
15:15:48 <chrisdone> luite: ghcjs can do the same right?
15:16:27 <chrisdone> actually interesting, how *does* it do timers in the presence of threads? is that like spawning a new thread every n ms?
15:16:57 <luite> chrisdone: well i don't know if it would work exactly, it might need some rt fixs, but it has threading, so you'd probably forkIO instead
15:17:07 <hpaste> applicative annotated ‚ÄúFunctional pong with lenses and gloss‚Äù with ‚ÄúFunctional pong with lenses and gloss (annotation)‚Äù at http://hpaste.org/72509#a72518
15:17:16 <chrisdone> ah, forever $ do delayThread n; forkIO m
15:17:20 <chrisdone> something like that
15:17:24 <nand`> edwardk: I didn't realized (<~) = (^~); is it really necessarily to have two?
15:17:27 <nand`> -d
15:17:55 <applicative> nand`: edwardk here's nand` s module with the emendations mentioned earlier, for what its worth,
15:17:58 <edwardk> not entirely but i like the fact that you can always take foo= and get foo~ for functional modification
15:18:05 <edwardk> and i can't take <= for obvous reasons
15:18:25 <luite> chrisdone: yeah, that would keep the current thread in that loop of course, so setInterval would probably be more like that with a forkIO
15:18:30 <edwardk> <~ is a lot easier to type and easier on the eyes, ^~ is more consistent
15:18:34 <nand`> personally, I think ^~ is just ugly
15:18:43 <edwardk> me too, thats why i use <~ everywhere
15:18:44 <luite> chrisdone: also the current version doesn't do blackholing i think
15:18:47 <nand`> ^= makes sense because the ‚Äò=‚Äô is still there, indicating assignment
15:18:52 <nand`> I will be using <~ too
15:19:03 <luite> but my experiment does eager blackholing
15:19:22 <applicative> oh wait nand` already did it;  I added a couple comments about the TH and _x _y
15:19:24 <donri> edwardk: ~< and =< then!
15:19:40 <nand`> edwardk: actually, I'm not entirely sure I like ‚Äò%=‚Äô ‚Äò%~‚Äô, where does the % take its inspiration from?
15:19:41 <edwardk> i tried killing ^= by renaming it to other things like ~= etc but it never feels right
15:19:46 <edwardk> 'mod'
15:19:50 <donri> i guess that can be interpreted as %= (<)
15:19:51 <edwardk> % = mod get it?
15:19:53 <applicative> (That Point = (Float,Float) wasnt obvious
15:20:01 <nand`> I just thought of ~= as well
15:20:06 <nand`> but ~~ is silly
15:20:08 <edwardk> yep
15:20:14 <edwardk> thats why i gave up on that
15:20:28 <donri> wait no that would be <= not =<
15:20:29 <edwardk> i have the functional ones as =*= but they looked too symmetrical
15:20:30 <nand`> applicative: ah, yeah; I grumbled a bit about that and decided I'd go with the one that seems most sane
15:20:48 <edwardk> er i _had_
15:20:54 <nand`> I'm not sure I like that
15:20:59 <donri> i like how <~ looks like do notation, sneaky ;)
15:21:04 <edwardk> yep
15:21:04 <nand`> reminds me of =>=
15:21:21 <edwardk> makeLensesFor got a pretty definition that way
15:21:26 <edwardk> only issue is the logic flows backwards
15:21:31 <nand`> haha, I sort of wish <~ was the State version just to be extra confusing
15:21:34 <nand`> but ^= works perfectly for it
15:21:41 <edwardk> hahahaha
15:21:46 <edwardk> i hadn't thought of that =)
15:21:49 <donri> :D
15:21:53 <chrisdone> luite: nice. heh, i initially forgot to make actions in the Fay monad not cached, so it would run the action just once. confusing :-)
15:22:18 <chrisdone> luite: how does ghcjs know that ‚Äúprint 123‚Äù should be ran every time?
15:22:18 <edwardk> <~ should clearly take a monadic action on the right and store its action in the lens
15:22:21 <nand`> ~> would be an obvious flip (<~) but that's taken for Data.Function.Pointless
15:22:23 <edwardk> er value
15:22:44 <edwardk> i don't use data.function.pointless so i feel free to piss on all their operator names ;)
15:22:48 <nand`> edwardk: that sounds interesting
15:22:54 <nand`> :(
15:22:56 <chrisdone> luite: i think i must've missed something obvious that would handle this in a general sense rather than special-casing the monad
15:22:58 <luite> chrisdone: actually i don't know
15:23:13 * applicative always uses Pointless.<~ anyway
15:23:18 <edwardk> do foo.bar.baz <~ code you'd otherwise write anyways
15:23:28 <nand`> I like pointless-fun, foo $:: bar ~> bat ~> baz  just has this nice feeling to it compared with \a b -> baz $ foo (bar a) (bat b)
15:23:35 <edwardk> nand`: its just that its impossible to avoid colliding with everyone
15:23:42 <nand`> true
15:23:47 <edwardk> so i try to avoid colliding with the platform and go from there
15:24:06 <nand`> I'm just arguing in favor of my own trends here
15:24:10 <edwardk> *nods*
15:24:16 <edwardk> i still can't read that $:: mess =P
15:24:26 <luite> chrisdone: my new experiment doesn't do io yet, i've seen some code related to this in the original one, but haven't really looked into it. i hoped it would be trivial once i have the rest :p
15:24:26 <applicative> yes, the platformed things have a bit of 'authority', else it seems silly.
15:24:46 <Taneb> I'll need to write these new lenses for FamilyTree, then see how they do in practise
15:24:49 <chrisdone> luite: heh, it will all fall into place. *mr burns hands*
15:24:55 <nand`> say you're writing Num a => Num (Identity a) by hand for some odd reason; (*) = (*) $:: runIdentity ~> runIdentity ~> Identity
15:25:24 <nand`> then again, that's not much prettier than Identity a * Identity b = Identity (a*b)
15:25:28 <nand`> I think the latter wins in this situation
15:25:30 <edwardk> yeah
15:25:40 <edwardk> i tend to try for the principle of least confusion
15:25:55 <luite> chrisdone: what other haskell features are you going to add?
15:25:59 <edwardk> i even go out of my way to minimize the use of flip, etc.
15:26:08 <nand`> I don't like flip either
15:26:17 <Taneb> :t flip either
15:26:18 <lambdabot> forall a c b. (b -> c) -> (a -> c) -> Either a b -> c
15:26:23 <nand`> :)
15:26:24 <edwardk> Taneb: i definitely look forward to your results
15:26:43 <Taneb> edwardk, I did it for data-lens, but I'm all confused with this version
15:26:49 <edwardk> how so?
15:27:03 <Taneb> I don't know where to start, more than anything
15:27:08 <nand`> Taneb: line your bed with haddock comments and absorb it via osmosis
15:27:18 <Taneb> I'll read that mirrored lens blog post thing
15:27:20 <edwardk> fair enough, Lens a a b b is more or less a lens as you know it
15:27:30 <nand`> Taneb: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285 http://comonad.com/reader/2012/mirrored-lenses/
15:27:33 <nand`> cleaned up my initial confusion
15:27:37 <nand`> also http://r6.ca/blog/20120623T104901Z.html
15:27:44 <edwardk> when something says it takes a getter, setter, traversal or fold it can take a lens
15:27:47 <nand`> but you might already know those
15:27:56 <edwardk> the others are just more limited things than lenses that you can use for some situations
15:28:04 <edwardk> e.g. a getter is just like a function
15:28:10 <edwardk> a setter is just like a functor
15:28:15 <edwardk> a fold is just like a foldable
15:28:23 <edwardk> and a traversal is just like a traversable
15:28:30 <edwardk> but they can all be composed with .
15:28:39 <donri> (from Prelude)
15:28:55 <edwardk> :t Data.Traversable.traverse . Data.Traversable.traverse
15:28:56 <lambdabot> forall (f :: * -> *) (t :: * -> *) a b (t1 :: * -> *). (Data.Traversable.Traversable t, Applicative f, Data.Traversable.Traversable t1) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
15:29:03 <chrisdone> luite: other syntactic niceities. strictness annotations. still thinking about how to handle "null" values in js. possibly null ‚Üí Nothing. seems a little ad-hoc, but seems to make sense too.  donri might add XmlSyntax support
15:29:10 <edwardk> notice how that still has the shape of a 'traversal', it just knows how to go two levels deep
15:29:38 <edwardk> the menagerie of combinators in there enable you to take something like that and use combinators like those from foldMap, etc.
15:29:42 <luite> chrisdone: no type classes / families?
15:29:42 <donri> chrisdone: i was thinking, do you think it would be abusive to use QQ syntax special-cased for some things, like css selectors?
15:29:47 <chrisdone> luite: but i suppose you meant more interesting features than that. no type-classes is an issue. i considered restricted type-classes
15:30:19 <nand`> edwardk: the most confusing thing for me was the amount of auxiliary functions like the ones ending in ‚ÄòOf‚Äô and the incredible amounts of cross-equality between them
15:30:21 <edwardk> anyOf text (=='c') $ "hello"^.packed-- packs hello into a Data.Text, then anyOf takes a fold, here we're passing it the text traversal.
15:30:22 <chrisdone> luite: not without type checking. i will re-look at the GHC API some time, and look forward to haskell-type-exts being released
15:30:33 <nand`> and of course no less than three separate functions defined as ‚Äòid‚Äô
15:30:39 <chrisdone> donri: for example?
15:30:41 <roconnor> "hello"^.packed seems excessive.
15:30:48 <edwardk> nand`: yeah basically you can ignore anything with 'Of' in it in first pass
15:30:54 <edwardk> roconnor: its in Data.Text.Lens
15:30:55 <nand`> roconnor: I think so too, except when combining
15:30:58 <edwardk> you have to import it directly
15:31:10 <edwardk> text = from packed . traverse
15:31:13 <roconnor> why not (pack "hello") ?
15:31:16 <edwardk> also in Data.Text.Lens
15:31:20 <edwardk> because it chains with other lenses
15:31:29 <donri> chrisdone: boxes <- jQuery [sel| div.box |]
15:31:34 <edwardk> and its an isomorphism so you don't need two names
15:31:38 <edwardk> you can use packed and 'from packed'
15:31:49 <luite> chrisdone: ghc translates typeclasses to dictionaries (= unboxed tuples of methods) in core, but perhaps that would make the generated javascript not close enough to haskell anymore?
15:31:58 <edwardk> plus it is carefully designed so that the name doesn't clash between text and bytestring
15:32:01 <chrisdone> luite: but as you know the GHC API is hard work just finding what you want, so undocumented. and, not overengineered, just really icky to use‚Ä¶ everything's a chore. at least compared to haskell-src-exts. you know?
15:32:01 <donri> chrisdone: the idea being that it's parsed at compile time, catching mistakes earlier
15:32:17 <edwardk> because in bytestring i have packedWords and packedChars
15:32:34 <chrisdone> luite: the translation to dictionaries is fine for me. the problem is knowing what instances are in use. like, what's the instance dictionary for x = def?
15:32:35 <donri> chrisdone: and could be given its own type in HS, but probably just compiles to a string in JS
15:32:46 <edwardk> if you ever worked with both text and bytestring you know how painful it is with them both exporting a complete copy of all list functions in the prelude
15:33:19 <luite> chrisdone: oh it automatically calls def with the right dictionary if you translate from core :)
15:33:20 <edwardk> anyways that anyOf example was too small to get much mileage out of it
15:33:24 <luite> chrisdone: or stg
15:33:38 <edwardk> s^.contains (n^.name)        is the kind of pattern that pops up a lot in my code now
15:33:47 <chrisdone> donri: ahhhh. yeah. do you know if we can use the GHC API for running TH on a file and getting the output?
15:33:52 <luite> chrisdone: if it's polymorphic, the dictionary is passed to the outer function
15:34:03 <chrisdone> luite: sure, but then i'd be doing the ghcjs/uhc project i suppose
15:34:03 <timthelion> edwardk: just imagine what it will be like, when someone finally gets arround to writting the long promised SafePrelude, where div and head return Maybes :D
15:34:09 <luite> chrisdone: yeah!
15:34:10 <edwardk> heh
15:34:12 <chrisdone> luite: yeah i read the type classes paper that explains this translation
15:34:16 <luite> chrisdone: so why don't you do that ;)
15:34:20 <edwardk> timthelion: headOf is a safe variant
15:34:24 <edwardk> timthelion: so is maximumOf, etc.
15:34:32 <chrisdone> all foo :: Foo x => ‚Ä¶ types are translated to foo :: Foo x -> ‚Ä¶
15:34:33 <donri> chrisdone: that's what i meant by special-cased. i meant that fay just parses the QQs with HSE and uses a predefined set of supported quoters by name
15:34:35 <nand`> and of course stuff like ‚Äòfrom packed %~ reverse‚Äô
15:34:37 <edwardk> for the most part the lens package exports a safe-ified version of the prelude
15:34:45 <edwardk> nand`: cute =)
15:34:47 <donri> chrisdone: it feels dirty, but not sure if fay could easily run TH as you say
15:35:00 <MostAwesomeDude> edwardk: I need to write a VFS with lenses now.
15:35:20 <S11001001> edwardk: safe fromMaybe?
15:35:23 <chrisdone> luite: because it takes months to get anything usable? (that's not a joke, seriously, it's hard work. respect for working on it)
15:35:28 <edwardk> S11001001: =P
15:35:33 <edwardk> its called case ;)
15:35:35 <timthelion> chrisdone: did you actually use special input to write those ...'s out short hand?
15:35:50 <Bobikins> Is there anything like every n xs = take n xs:every n (drop n xs) in the standard library?
15:35:52 <donri> @google compose key
15:35:53 <lambdabot> http://en.wikipedia.org/wiki/Compose_key
15:35:53 <lambdabot> Title: Compose key - Wikipedia, the free encyclopedia
15:35:57 <donri> ^ timthelion
15:36:10 <luite> chrisdone: hehe yeah your project is also far more likely to succeed...
15:36:13 <chrisdone> donri: ahhhh. could special case that i guess
15:36:37 <timthelion> donri: thanks
15:36:37 <chrisdone> timthelion: compose+..
15:36:42 <luite> chrisdone: and what you're doing with it looks a lot nicer than ghcjs code so far
15:36:47 <donri> ‚ò∫
15:37:08 <donri> ‚ò∫ ‚â† ‚òπ ‚ô•
15:37:12 <donri> yay compose key!
15:37:44 <luite> chrisdone: how important is it for you that the generated javascript is "relatable" to the haskell?
15:37:52 <chrisdone> luite: thanks. of course, qualified all this from the start that i will switch to ghcjs/uhc whence they are polished. i'm just impatient >_>
15:37:52 <donri> chrisdone, luite: isn't much of the point with fay also that it generates smaller code?
15:38:01 <donri> or is that less of an issue with ghcjs these days
15:38:10 <nvrpunk> ghci> let x = x + x + x
15:38:10 <nvrpunk> ghci> x + 5
15:38:12 <nvrpunk> :(
15:38:18 <luite> donri: it is an issue, but mainly due to the libraries most code uses
15:38:39 <donri> luite: so if you code "fay style" where you don't really use libraries?
15:38:39 <luite> ghcjs eliminates unused functions
15:38:56 <donri> it does? without requiring closure?
15:38:58 <nand`> edwardk: I like how there's this whole little EDSL that deprecates basically the entire Prelude now, eg. ‚Äúmapped %~ view packed‚Äù vs ‚Äúmap pack‚Äù
15:39:00 <luite> it's probably still a bit heavier because it has a biffer rts
15:39:10 <edwardk> hahaha
15:39:12 <luite> yes closure then minifies the result again
15:39:43 <luite> fay is probably still a lot smaller
15:39:49 <donri> nand`: just prelude you say?
15:39:58 <nand`> time to rename it EdwardsKell and publish it as a new language
15:40:00 <nand`> rake in millions
15:40:03 <donri> nand`: there's now a lens version of basically all code ever written.
15:40:28 <nand`> ‚Äúall the comfort of confusing OOP syntax with the safety and sanity of Haskell‚Äù
15:40:41 <nvrpunk> are there any native interpreters for haskell?
15:40:47 <luite> and i think fay doesn't really support cabal packages, so you're less likely with something that requires humongous modules, Data.Text.Lazy is more than 2MB of javascript because it inlines everything and the kitchen sink
15:40:48 <nvrpunk> so it can be run instead of compiled first
15:40:56 <nand`> nvrpunk: there's ‚Äúrunhaskell‚Äù
15:40:56 <ParahSailin_> runghc is interpreted
15:40:57 <donri> nvrpunk: runhaskell
15:41:01 <chrisdone> luite: not sure. i thought it would be simpler to hack on (for me personally and for others), and for people to feel "safe/trust" with it, like, they know pretty much what's going to be generated. i don't want to be scared of when shit-hits-fan in production because i don't understand/can't isolate the js. but yeah maybe that's not an issue? it's mostly the KISS principle taken to the extreme
15:41:02 <nvrpunk> lol
15:41:03 <nvrpunk> thanks
15:41:06 <nand`> I think that JITs or something
15:41:12 <donri> oh?
15:41:22 <luite> chrisdone: yeah it seems to be working at least, lots of interest
15:41:23 <nand`> (how would you do static type checking without considering the entire code, at any rate?)
15:41:46 <nand`> though I guess that's a separate distinction
15:41:47 <MostAwesomeDude> nand`: Well, it does compile the code somewhat, but it runs it instead of emitting native code.
15:42:53 <donri> luite: couldn't ghcjs have some way to ignore inlining?
15:42:55 <chrisdone> luite: donri: seems that ghcjs generates smallish code indeed. for the ghcjs-compiles-fay example, the js source wasn't so massive. considering it was all of haskell-src-exts, pretty nice
15:43:09 <donri> ya
15:43:12 <nand`> edwardk: one criticism is that errors are not as clear as they could be
15:43:13 <luite> donri: yeah it should probably modify that in the flags
15:43:20 <edwardk> sadly i don't have much control there
15:43:36 <chrisdone> right‚Ä¶ inlining explodes
15:43:37 <edwardk> i tried working with specialized types for Const and Identity to get 'Getting' and 'Setting' in the errors
15:43:45 <edwardk> but it didn't work very well
15:43:49 <donri> chrisdone: and i think HSE in turn uses happy? although the package might be shipping generated code, hm
15:43:49 <roconnor> oh?
15:43:58 <nand`> you can run into like 10-lines errors with ‚ÄúExpected type: IsoLike (->) Backwards Identity a0 b1 c0 d0‚Äù
15:44:09 <nand`> which somebody who hasn't carefully studied the implementation wouldn't know a thing about
15:44:12 <edwardk> roconnor: you saw, you just didn't get much mileage out of the errors
15:44:24 <chrisdone> luite: (i thought about supporting cabal packages for fay packages, e.g. someone is working on fay-jquery, it seems that would work for fay code. but not for proper haskell packages.)
15:44:27 <edwardk> yeah
15:44:34 <nand`> edwardk: clearly the solution is to optimize GHC for lenses instead
15:44:39 <chrisdone> donri: doesn't happy just generate the parser? not sure
15:44:44 <luite> chrisdone: problem is that inlining really helps performance, in particular here, because longer sequences of primops are pretty much the only thing that's relatively fast in js, all thes function calls ahve a lot of overhead. so we don't want to tone it down too much :)
15:45:08 <donri> chrisdone: well the parser is defined in terms of happy, in the source, but not soure about the "source" dist you get from hackage
15:45:31 <luite> chrisdone: right, i hacked cabal support for ghcjs a few months ago and it's horrible! horrible i say!
15:45:55 <chrisdone> luite: indeed. inlining _(x) to x instanceof Fay$$Thunk? _(x) : x reduces the sum example from 200ms to 50ms, but it does blow up the code output‚Ä¶
15:47:03 <nand`> donri: from now on my libraries will hinge around 1. writing a data-type, 2. writing a lens for it
15:47:09 <luite> chrisdone: i have a lot of inlining atm, macro's that push stuff on the stack or initialize heap objects, but they don't really blow up gzipped code size
15:47:15 <nand`> if the user wants more specific operations they can easily compose them
15:47:21 <luite> chrisdone: it's still harder on the parser of course
15:47:37 <luite> probably need to find some balance there :)
15:47:54 <donri> my ghc-compiled executables tend to be 30M+ and JS being text should multiply that number by a bit :P
15:48:01 <chrisdone> luite: heh, so i thought with a custom Setup.hs you could compile the .hs files to .js and stick them in a share/package-x.y.z/js/ dir. so when fay is compiling (well, "linking") package package-x.y.z it looks in there for the js, like object files. how did you do it?
15:48:02 <donri> but, that's using a shitton of packages
15:48:48 <donri> nand`: (you even get monads from lenses, did you see?)
15:48:56 * roconnor is confused why Getting and Setting didn't help for errors
15:49:10 <chrisdone> luite: indeed. gzipped probably doesn't flinch
15:49:12 <luite> chrisdone: ghcjs keeps its own package database (ghcjs-pkg list), you use ghcjs-cabal to install a pacakge. it then installs stuff to ~/.cabal/lib/ghcjs-something
15:49:21 <nand`> donri: no, I want to see
15:49:34 <donri> nand`: http://hackage.haskell.org/packages/archive/lens/1.3.1/doc/html/Control-Lens-Representable.html
15:49:45 <donri> nand`: ok so you still need to write one instance
15:49:48 <chrisdone> luite: does that let you use ghci with the ghc package?
15:49:51 <nand`> roconnor: I think using names like ‚ÄòGetting‚Äô and ‚ÄòSetting‚Äô would confuse me due to the existing ‚ÄòGetting‚Äô, ‚ÄòSetting‚Äô, ‚ÄòSetter‚Äô etc.
15:49:54 <edwardk> roconnor: just doesn't make a huge difference in them, Const and Identity are rarely the sources of conflict
15:49:56 <chrisdone> s/ghc p/ghcjs p
15:50:14 <roconnor> hmm
15:50:16 <edwardk> nand`: well, i stole those names from the Getting and Setting data types and used them for wildly different purposes
15:50:30 <luite> chrisdone: uh perhaps with some more hacking, but that's only because ghcjs also builds a native version of the pacakges :)
15:50:34 <edwardk> if you go to read from a setter that will blow up, but i don't define a lot of setters
15:51:05 <nand`> edwardk: lastOf = headOf . backwards ?
15:51:09 <edwardk> yeah
15:51:15 <chrisdone> luite: gotcha. yeah ghci just-working is important for me personally
15:51:21 <nand`> might want to add those to the comments, for clarity
15:51:29 <edwardk> its implemented differently though
15:51:34 <edwardk> it uses the last monoid instead
15:51:45 <luite> chrisdone: hmm, how do you run ghci? do you use something with node?
15:51:48 <edwardk> so its hazardous to make that claim because the monoid is visible in its type
15:51:52 <nand`> ah
15:53:23 <nvrpunk> is there a mean median and mode function?
15:53:30 <chrisdone> luite: no. i thought, i could. but pointless really. the stuff in the Fay () monad is probably gonna be code useful in a browser, and pure functions are ‚Ä¶ regular Haskell functions so they can be run in ghci. but i meant just for type-checking and inspection, i just that constantly from emacs
15:53:37 <ParahSailin_> :t backwards
15:53:39 <lambdabot> Not in scope: `backwards'
15:54:14 <nand`> edwardk: I'm never quite sure when I want ‚Äòbackwards‚Äô and when I want ‚Äòreversed‚Äô, what's the mnemonic?
15:54:20 <chrisdone> luite: though yeah i guess i could attach to a remote chrome session and literally have a ghci which runs directly in the browser (or a node session, if one is into that kind of thing). could be an idea?
15:54:21 <alpounet> nvrpunk, in the "statistics" package most likely
15:54:21 <edwardk> there isn't one sadly
15:54:31 <edwardk> backwards works on traversables, and reversed works on folds
15:54:36 <alpounet> but statistics works around Data.Vector, not lists
15:54:42 <edwardk> Control.Applicative.Backwards is where backwards comes from
15:54:56 <edwardk> Prelude.reverse is where reversed comes from ;)
15:55:02 <edwardk> the former works on applicatives
15:55:03 <ParahSailin_> i wish ghci had import for modules
15:55:03 <nvrpunk> alpounet, nice where is a list of available packages?
15:55:14 <alpounet> @where hackage
15:55:14 <lambdabot> <http://hackage.haskell.org/package/>, also see `revdeps'
15:55:15 <ParahSailin_> i have to jump around with :m
15:55:18 <chrisdone> ParahSailin: ghc 7.x has import
15:55:18 <edwardk> the latter works on folds
15:55:29 <edwardk> there isn't a good way to get one combinator that does both
15:55:34 <alpounet> nvrpunk, there you go
15:55:38 <ParahSailin_> im on 7.4
15:55:42 <ParahSailin_> how do i import
15:55:45 <chrisdone> import X
15:55:55 <edwardk> in general i try to use 'ed' suffixes on things that can be chained in getters.
15:55:58 <chrisdone> i'm on 7.4.2
15:56:09 <alpounet> you can even define data types in ghci now ParahSailin_ :)
15:56:16 <edwardk> while backwards is a combinator that takes a traversal and gives you a traversal
15:56:24 <nand`> that could work; I'll use the mnemonic ‚Äòbackwards performs actions backwards‚Äô and ‚Äòreversed reverses the monoid‚Äô
15:56:30 <nand`> wait
15:56:32 <nand`> that works both ways
15:56:36 <luite> chrisdone: a right. still i think something would be possible for ghcjs, it knows the location of all modules through the package database, and the module source code files themselves contain information about dependencies. so it's not too hard to figure out which modules need to be loaded if a user does something like import Data.Text.Lazy
15:56:42 <MostAwesomeDude> ParahSailin_: Waait, you're not SailingPariah?
15:56:50 <edwardk> yeah and there is also a Reversed applicative, etc.
15:56:58 <ParahSailin_> no relation
15:57:05 <MostAwesomeDude> Curious.
15:57:09 <chrisdone> luite: sure, nice
15:57:11 <nand`> MostAwesomeDude: I got confused over that too, mostly on part of SailingPariah
15:57:38 <SailingPariah> MostAwesomeDude: why would 2 different names bne the same? You think we are Sarah Palin as well?
15:57:39 <luite> chrisdone: hamishmack has been focussing on compiling "executables", which are stripped of all unused functions, but i myself want a more ghci-like thing where modules are loaded, for my still unreleased site :p
15:57:59 <chrisdone> heh
15:58:17 <chrisdone> ‚ÄúIf you wish to make an apple pie from scratch, you must first invent the universe.‚Äù
15:58:42 <nand`> if you wish to just make an apple pie, you use a lens
15:59:02 <chrisdone> lens or lense?
15:59:10 <nand`> pie^.baked
15:59:10 <edwardk> lens, i'm american damnit ;)
15:59:29 <otters> do they really say lense in the UK?
15:59:32 <SailingPariah> So how useless is Haskell for signal processing and why?
15:59:38 <otters> I'm surprised that island hasn't sunk under the weight of all the extra Es
15:59:56 <SailingPariah> ><>
15:59:58 <alpounet> SailingPariah, there's a library or two for it
15:59:59 <alpounet> so not totally
16:00:43 <chrisdone> otter: probably from french or italian lenza 'line'
16:00:47 <SailingPariah> But in practice+
16:01:07 <roconnor> Philippa: is lense UK spelling or just wrong spelling?
16:01:13 <roconnor> lense feels like a verb to me.
16:01:23 <BrockObomba> edwardk: you voting for Obama again?
16:01:46 <edwardk> of course
16:01:49 <chrisdone> otter: italy didn't use to be shaped like a boot, it was actually a log, but it's been sinking due to corrosion from syllables
16:01:51 <BrockObomba> hippie
16:02:14 <edwardk> *shrug*
16:02:26 <otters> I took a political quiz and it said my views matched Obama's
16:02:31 <BrockObomba> I want Bush back. Now thats a guy id take a bear with. (Yes I spelled it as I meant it.)
16:02:33 <otters> an unverifiable internet source is all I need to make important decisions
16:02:46 <donri> BrockObomba: "id"?
16:02:48 <chrisdone> i need to read reddit to tell me what to think on this issue
16:02:49 <BrockObomba> otters: vote Ron Paul
16:03:02 <donri> BrockObomba: I guess you mean latin "id"
16:03:06 <BrockObomba> id = I would.
16:03:26 <edwardk> i work in an industry where the norm is to switch jobs every few years. the health care bill is important to me. romney will say anything to get elected and when and if he does he'll have to make good on some if not all of his rhetoric, and that terrifies me
16:03:28 <BrockObomba> gnight
16:03:28 <otters> chrisdone: read /r/circlejerk, they have some really good stuff there
16:03:41 <edwardk> and tats all the politics i have for #haskell =P
16:04:11 <edwardk> ron paul scares me more than romney =P
16:04:18 <JoeyA> edwardk: Important as in your pro- or anti- it?
16:04:20 <JoeyA> you're*
16:05:03 <chrisdone> the politics of the us is very interesting, and the olympics are very interesting. that's all i got
16:05:11 <edwardk> i'm very much pro. its not perfect, there are some rough edges in how it deals with preventative concerns here and there, but its a heck of a lot better than what went before and when the only thing your opponents can do is fear monger, you're doing something right.
16:05:28 <JoeyA> Well said.
16:05:51 <roconnor> edwardk: come to Canada
16:06:12 <roconnor> you probably have enough money to buy RIM
16:08:30 <chrisdone> <edwardk> i work in an industry where the norm is succession through assassination. the health care bill is important to me. wizards will do anything to get elected and when and if we do we have to make good on some if not all of our rhetoric, and that terrifies me
16:08:43 * chrisdone . o O ( that's how i prefer to read it ‚Ä¶ )
16:08:45 <edwardk> =)
16:09:24 <edwardk> sorry roconnor, in order for my lens library to succeed, you and all your family must be extirpated.
16:09:32 <chrisdone> (i'm reading so many terry pratchett books at the moment. i am continuously drawing parallels between wizards and programmers)
16:09:36 <nand`> edwardk: ‚Äúto = from view‚Äù <- from view doesn't typecheck over here
16:09:41 <roconnor> @wn extirpated
16:09:42 <lambdabot> No match for "extirpated".
16:09:45 <edwardk> nand`: oh yeah i had to remove it
16:10:06 <edwardk> http://www.merriam-webster.com/dictionary/extirpated
16:10:28 <chrisdone> extirpated is a trick word people use to find americans :p
16:10:28 <geekosaur> you extirpated it?
16:10:43 <edwardk> from wordnet, yes
16:11:07 <edwardk> @wn extirpate
16:11:08 <lambdabot> *** "extirpate" wn "WordNet (r) 3.0 (2006)"
16:11:08 <lambdabot> extirpate
16:11:08 <lambdabot>     v 1: destroy completely, as if down to the roots; "the vestiges
16:11:08 <lambdabot>          of political democracy were soon uprooted" "root out
16:11:08 <lambdabot>          corruption" [syn: {uproot}, {eradicate}, {extirpate}, {root
16:11:10 <lambdabot> [5 @more lines]
16:11:27 <JoeyA> On Wikipedia, it mentions local extinction.
16:11:58 <JoeyA> For example, transformers could "extirpate" MonadIO, but it would still exist (although in a less portable but more general form) in transformers-base.
16:12:35 <VitamnP> I have this code: "data Cell = Bool Point". Does anyone know why I might be getting "Not in scope: data constructor `Cell'" when I try to make a new Cell in GHCI?
16:13:15 <roconnor> VitamnP: you want data Cell = Cell Bool Point
16:13:38 <VitamnP> ahhhh thanks
16:13:43 <hpaste> ‚ÄúJoey Adams‚Äù pasted ‚ÄúIs a state machine a good approach to managing a network connection?‚Äù at http://hpaste.org/72520
16:13:46 <chrisdone> (1) wizards are predominantly male (2) wizards are arrogant, resistant to change, (3) wizards are solitary, (4) wizards are bearded, (5) wizards spend their time dabbling with things they don't fully understand and casting spells
16:13:53 <chrisdone> that's programmers
16:14:25 <nand`> ‚Äòresisant to change‚Äô <- I'd still be programming C#
16:14:28 <irene-knapp> the only actual bearded programmers I've known personally are large Edwards
16:14:29 <nand`> resistant*
16:15:07 <ddarius> nand`: You're programming in a language that outlaws mutation.
16:15:12 <chrisdone> irene-knapp: well, we're talking about stereotypes here :)
16:15:15 <irene-knapp> true :)
16:15:24 <nand`> ddarius: good point
16:15:38 <chrisdone> ddarius: hahaha
16:15:56 <JoeyA> I'm working on a connection manager for my application.  The basic idea is that it needs to stay connected to the server, but notify the application if the connection is lost.
16:16:08 <JoeyA> The paste I gave is a simplification of the approach I plan to take.
16:16:35 <JoeyA> Is this a pretty decent design?  Namely, the definition of a State type, and a step function for moving from state to state.
16:16:45 <nand`> ‚ÄúsumOf (folded.folded._1)‚Äù vs ‚Äúsum . map sum . map (map fst)‚Äù :P
16:17:07 <JoeyA> One practical advantage is that I can reuse field names in multiple states; notice how I use timeOfConnect in multiple states.
16:17:28 <edwardk> sum . map (sum . map fst)
16:18:19 * roconnor kinda wishes folded was called crushed
16:18:26 <edwardk> hah
16:18:35 <alpounet> Crushable a => ...
16:18:38 <alpounet> hell yeah
16:19:09 <MostAwesomeDude> crushomorphism
16:19:13 <JoeyA> The issue this state machine tackles is having to propagate a bunch of context that comes and goes.
16:19:25 <nand`> edwardk: another thing to get used to is reading lens type signatures; I'd prefer something like ‚Äú(Foldable f, Monoid m) => Getting m (f a) (f b) a b‚Äù but instead I'm seeing ‚Äú(Foldable f, Monoid m) => (c -> Const m d) -> f c -> Const m b
16:19:35 <JoeyA> e.g. so I don't have signatures that look like this: Manager -> Config -> (Event -> STM ()) -> Conn IO a -> IO (Either SomeException a)
16:19:46 <edwardk> yeah
16:19:51 <nand`> well, ‚Äòf b‚Äô can be changed to ‚Äòc‚Äô or so
16:19:54 <nand`> but still
16:19:56 <edwardk> the type decls aren't very durable
16:20:29 <nand`> that's a general problem I seem to come across, GHC isn't aggressive in displaying type synonym
16:20:33 <nand`> +s
16:21:38 <donri> it won't do it for inferred types, right?
16:21:47 <donri> :t map toUpper
16:21:48 <lambdabot> [Char] -> [Char]
16:22:13 <MostAwesomeDude> :t map toUpper :: String -> String
16:22:14 <lambdabot> String -> String
16:23:19 <donri> :t map toUpper . show
16:23:20 <lambdabot> forall a. (Show a) => a -> [Char]
16:23:56 <nand`> it would be cool if GHC could figure out that I meant a -> String here since ‚Äòshow‚Äô already has the String on it
16:24:00 <MostAwesomeDude> :t show
16:24:01 <lambdabot> forall a. (Show a) => a -> String
16:24:04 <MostAwesomeDude> Annoying.
16:25:06 <donri> nand`: or maybe even it could find matching type synonyms in scope?
16:25:40 <donri> although then it might end up saying FilePath :)
16:26:33 <alpounet> show 4 :: FilePath
16:26:35 <alpounet> yay
16:26:38 <edwardk> donri: well in my case i have type aliases hiding quantifiers, so it probably won't find them
16:26:58 <edwardk> even if it wanted to
16:27:03 <donri> poor ghc
16:27:06 <edwardk> since they'll lift up over the -> and away
16:27:44 <nand`> I wonder what an EDSL with APL-inspired syntax for lens operators and common lenses would be like
16:28:01 <donri> nand`: see the "lens" package
16:28:08 * donri ducks
16:28:25 <nand`> not nearly enough unicode
16:36:20 <ddarius> APL preceded Unicode by a long margin.
16:37:04 <nand`> edwardk: a fold is like a read-only traversal?
16:37:08 <edwardk> yep
16:37:27 <edwardk> thats why traverse_ etc. work with folds
16:37:32 <edwardk> you never read the answers
16:37:48 <geekosaur> people who complain about significant whitespace should learn about significant *backspace* ;}
16:37:56 <edwardk> geekosaur: hahaha
16:43:02 <monochrom> hahaha significant backspace
16:43:08 <chrisdone> mind blown
16:43:21 <scooty-puff-sr> not sure if this is cool or not, but:
16:43:25 <hpaste> scooty-puff-sr pasted ‚ÄúDisjT Monad‚Äù at http://hpaste.org/72521
16:43:44 <scooty-puff-sr> and the only meaningful Monad, MonadPlus instances
16:43:58 <nand`> ‚ÄúCorepresentable endofunctors represented by their polymorphic lenses ‚Äù <- uh huh
16:44:08 <scooty-puff-sr> make it so that (a \/ b) /\ c is treated like (a /\ c) \/ (b /\ c)
16:44:34 <scooty-puff-sr> where /\ is >>, \/ is mplus or <|>
16:44:49 <scooty-puff-sr> or seems to, for some cases..
16:45:09 * hackagebot Chart 0.16 - A library for generating 2D Charts and Plots (TimDocker)
16:45:48 <chrisdone> bit of uplifting science music anyone? http://www.youtube.com/watch?v=XGK84Poeynk
16:49:50 <gertc> who feels like helping today? warning question maybe stupid
16:50:19 <gertc> http://stackoverflow.com/questions/11787372/haskell-couchdb-conduit-example
16:50:26 <gertc> no its not the same
16:50:41 * ddarius starts a band called "Corepresentable Endofunctors"
16:50:55 <gertc> could be the same kind but i found a way to ask it differently :)
16:51:00 * nand` likes the band ‚ÄúAxiom of Choice‚Äù; especially their album ‚ÄòUnfolding‚Äô
16:53:20 <alpounet> chrisdone, i found maggot brain to be quite uplifting too
16:54:10 <chrisdone> by funkadelic?
16:54:23 <alpounet> yes
16:54:35 <alpounet> not the same kind of music though :p
16:55:10 * hackagebot Chart-gtk 0.16 - Utility functions for using the chart library with GTK (TimDocker)
16:55:39 <chrisdone> prog rock. i like this style. probably inspired godspeed you black emporer who i also like
17:01:12 <chrisdone> Ridley Scott just acquired the rights to make Wool (figured haskeellers would care)
17:01:18 <chrisdone> alright i'm ‚Üí bed
17:01:20 <chrisdone> ciao
17:03:35 <nand`> darn it all, my CPU is beating me at pong
17:04:26 <alpounet> put your lenses on ;)
17:04:29 <sipa> try plasma pong
17:04:41 <chrisdone> ah, also i started a #fay channel which you can idle in if you like
17:04:50 * chrisdone disappears
17:05:25 <ddarius> "Join my channel which I'm about to leave.
17:06:22 <nand`> alpounet: I have them on, maybe they're not strong enough
17:06:31 * nand` strengthens them by adding a traverse or two
17:07:14 <alpounet> throw in a backwards, just in case
17:07:41 <nand`> I don't want to see everything upside down
17:07:45 <nand`> not that it would matter much for pong
17:07:57 <alpounet> maybe you'll beat the CPU though
17:07:59 <alpounet> :P
17:17:56 <nand`> I've juggled around my code somewhat, ‚Äúp^.score.pretty.to text‚Äù <- cute :)
17:19:23 <absence> mm_freak: are there more clever ways to do env or env' ? basically i want to run a bunch of wires sequentially for specified durations. http://hpaste.org/72522
17:23:22 <dmwit> copumpkin: Oh, bummer!
17:23:31 <dmwit> We'll miss you.
17:24:14 <overscore> anyone use vty-ui?
17:24:16 <danharaj_> I just fixed a bug without knowing how I fixed it.
17:24:19 <danharaj_> :|
17:25:38 <nand`> @ask edwardk Do you think a built in combinator for the following patterns: l <~ v^.l  and  l ^= v^.l  would be useful? idea: ‚Äúcopy a field from another value‚Äù. For example ballSpeed <<~ initialState
17:25:38 <lambdabot> Consider it noted.
17:26:13 <nand`> @tell edwardk as much as I like <<~, it would be a rather unfortunate clash with <<= for the state version
17:26:13 <lambdabot> Consider it noted.
17:26:44 <donri> @hoogle (<<=)
17:26:45 <lambdabot> No results found
17:27:04 <nand`> donri: Comonad w => (w a -> b) -> w a -> w b
17:31:09 <nand`> @tell edwardk on an unrelated note, <‚âà could be a nice alias for ^= to match <~ :)
17:31:09 <lambdabot> Consider it noted.
17:32:53 <nand`> @ask edwardk maybe a <~^ b for a <~ b^.a  also  <=^
17:32:53 <lambdabot> Consider it noted.
17:38:03 <ddarius> It begins.
17:40:00 <hpaste> vp pasted ‚Äú81??‚Äù at http://hpaste.org/72524
17:41:11 <monochrom> length f * length grid = 81
17:41:17 <geekosaur> mmm, isn;t that essentually a Cartesian product there?  so it will do Cell a b over 9 * 9
17:41:48 <monochrom> > length [ (a,b) | a<-[(),()], b<-[(),()] ]
17:41:49 <lambdabot>   4
17:41:52 <monochrom> 4, not 2
17:42:08 <monochrom> however:
17:42:23 <monochrom> > length (zip [(),()] [(),()])
17:42:24 <lambdabot>   2
17:42:52 <overscore> which is more efficient,  a ++ verylonglist  or verylonglist ++ a
17:43:00 <nand`> > length [ (a,b) | a <- [(), ()] | b <- [(), ()] ]
17:43:01 <lambdabot>   2
17:43:04 <monochrom> "zipWith Cell f grid" has length 9
17:43:22 <monochrom> a ++ verylonglist is faster
17:44:10 <otters> @src (++)
17:44:10 <lambdabot> []     ++ ys = ys
17:44:10 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:44:10 <lambdabot> -- OR
17:44:10 <lambdabot> xs ++ ys = foldr (:) ys xs
17:44:19 <badkins> I discovered how to enter a lambda char in Emacs on Mac OSX, but I'm getting a parse error when compiling it: myfun = Œªx -> x * x
17:44:27 <otters> overscore: looks like a ++ verylonglist
17:44:43 <badkins> do I need a different lambda char maybe?
17:45:10 <nand`> UnicodeSyntax doesn't allow Œª for \
17:45:20 <monochrom> Œª is a letter. great for variable names. for example linear algebraists can use Œª for eigenvalues in their algorithms
17:45:21 * hackagebot egison 2.3.10 - An Interpreter for the Programming Language Egison (SatoshiEgi)
17:45:30 <badkins> bummer
17:45:40 <nand`> it does allow ‚Üí for -> though
17:45:51 <monochrom> just to show you how little monopoly you have on Œª
17:46:16 <badkins> -> doesn't bother me as much as \   oh well
17:46:30 <nand`> if you want to avoid using lambdas, you can write point-free :)
17:46:42 <monochrom> linear algebraists look at Œªx and say Ax = Œªx
17:46:45 <donri> can't you have emacs show the ascii as unicode visually?
17:46:48 <donri> i do that in vim
17:46:54 <badkins> donri: probably
17:46:58 <badkins> if vim can do it ;)
17:47:21 <badkins> although maybe \ will be in other contexts also
17:47:49 <donri> works fine in vim for me
17:48:13 <badkins> donri: what do you see in "hello\n"  ? a lambda there?
17:48:34 <donri> nope, string region takes preference
17:48:39 <badkins> ok
17:49:28 <nand`> what about Data.List.(\\) ?
17:49:57 <ddarius> (Data.List.\\)
17:50:06 <nand`> oh, right
17:50:18 <nand`> (I've never actually used qualified operators)
17:51:12 <overscore> i feel like i'm reinventing a state monad
17:52:02 <monochrom> that is not a sin
17:52:39 <ddarius> Damn you Nishimura.
17:53:01 <donri> badkins, nand`: http://i.imgur.com/q44xz.png
17:53:59 <nand`> donri: neat. But that font would kill me :)
17:54:04 <donri> :)
17:54:21 <edwardk> <‚âà  takes me outside of what i can type ;)
17:54:23 <overscore> comic sans ms?
17:54:23 <donri> i change fonts often, easily bored
17:54:24 <overscore> :p
17:54:29 <donri> overscore: monofur
17:55:28 <badkins> donri: cool. thx. Maybe I'll dig into getting Emacs to do that.
17:55:36 <monochrom> donri: nice demo :)
17:55:50 <donri> https://github.com/dag/vim2hs
17:55:56 <monochrom> wait, why are the line numbers in countdown order?!
17:55:56 <donri> yay self-plug
17:56:05 <donri> monochrom: :set relativenumber
17:56:16 <donri> monochrom: it's distance from cursor
17:56:19 <donri> makes movement easier
17:56:20 <otters> holy crap
17:56:23 <otters> jump to source file
17:56:30 <monochrom> oh hahaha I see why now, damn you vi
17:57:19 <badkins> donri: cool, looks like I already have it and didn't know it: http://blog.prb.io/emacs-haskell-mode-unicode-cuteness.html
17:57:39 <donri> badkins: ah :)
17:59:01 <badkins> donri: hmm... there is a warning that it changes the alignment, so it might mess up white space sensitivity. I presume because -> goes from two chars to one - you ever have a problem with this?
17:59:31 <donri> badkins: yep. i have those disabled by default in vim2hs but enabled in my own configuration
17:59:53 <badkins> pity, it looks so nice :)
18:00:18 <donri> yea, but you still get a few ones by default like lambda and composition
18:00:56 <donri> i also collapse LANGUAGE and deriving lists into ellipsis ‚Ä¶
18:09:28 <donri> so what fonts does #haskell use for programming
18:09:36 <tylerkahn> monaco
18:09:39 <tylerkahn> :)
18:09:51 <nand`> terminus
18:09:54 <parcs`> comic sans
18:09:58 <nand`> parcs`: hehe
18:10:02 <tylerkahn> haha
18:10:38 <luite> consolas
18:10:45 <hpaste> nand` annotated ‚ÄúFunctional pong with lenses and gloss‚Äù with ‚ÄúFunctional pong with lenses and gloss (annotation)‚Äù at http://hpaste.org/72509#a72526
18:11:20 <donri> i find there are few fonts that work well with my hinting fontconfig and with the unicode in gvim
18:11:47 <donri> ubuntu mono renders ‚Üí too wide so you end up only seeing a line
18:12:27 <nand`> donri: I used to have similar issues, these days I use URxvt.font: xft:Terminus:pixelsize=14:lang=af,xft:Fixed:SemiCondensed:pixelsize=13:lang=cs
18:12:41 <nand`> which renders ‚àÉ ‚àÄ and all other chars that used to render too wide fine now
18:13:07 <donri> i don't use terminal vim for programming
18:13:22 <donri> and i don't use urxvt for that matter :)
18:13:38 <nand`> if gvim accepts xft font declarations you can use pretty much the same line
18:15:39 <tylerkahn> when i'm on ubuntu i use the ubuntu mono font
18:15:46 <tylerkahn> looks good
18:17:21 <dmj> @help
18:17:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:17:27 <dmj> list
18:17:31 <dmj> @help list
18:17:31 <lambdabot> list [module|command]
18:17:31 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
18:19:52 <dmj> Hi, I'm new and have a very basic question. What is the .lhs extension and how is it different from the .hs?
18:20:01 <nand`> lhs is Literate Haskell
18:20:33 <nand`> basically, everything is ignored except for sections either prefixed with ‚Äú> ‚Äù or surrounded by \begin{code} \end{code}
18:21:04 <nand`> it's useful for when you want to, say, write a LaTeX paper but actually make the examples compilable directly
18:21:11 <Cale> dmj: It's to support a "literate" style of programming in which comments are the default :)
18:22:51 <dmj> Ah I see. So LaTeX gets compiled to haskell?
18:23:11 <nand`> not really, no
18:23:14 <tsou> dmj: latex creates the dvi, haskell creates the binary
18:23:17 <Cale> yeah, just by extracting the bits of code surrounded by \begin{code} and \end{code} and compiling those
18:23:21 <nand`> but the inlined examples are
18:24:32 <roconnor> Can I have a priority search queue with O(1) access to both the highest and lowest priority?
18:24:49 <irene-knapp> of course.  by having two priority queues, one in each direction.
18:25:03 <edwardk> nand`: how is the pong going?
18:25:14 <roconnor> hmm
18:25:16 <edwardk> roconnor: yes
18:25:19 <irene-knapp> it sounds kinda dumb but it's a serious suggestion :)
18:25:24 <edwardk> roconnor: just use the fingertree representation
18:25:37 <nand`> edwardk: I changed bits here and there for clarity and reduced some of the collision checking code: http://hpaste.org/72526
18:25:39 <edwardk> roconnor: all it is is a shift in the monoid
18:25:43 <hpaste> scooty-puff-sr pasted ‚ÄúPerhaps interesting?‚Äù at http://hpaste.org/72527
18:25:50 <roconnor> edwardk: I'm looking at http://hackage.haskell.org/packages/archive/fingertree-psqueue/0.3/doc/html/Data-FingerTree-PSQueue.html
18:25:53 <nand`> I'd say it's pretty much in a presentable form as-is
18:26:09 <edwardk> roconnor: well you'd have to reimplement it, but its not hard
18:26:13 <roconnor> irene-knapp: kinda like saying I can have a priority search queue by having a priority queue and a search tree
18:26:22 <nand`> still a bit sour about the code duplication on lines 121-129 but my attempt at factoring out resulted in code that was the same length and harder to read
18:26:26 <luite> roconnor: Cale told me not to use that some time ago :)
18:26:27 <irene-knapp> well, yes
18:26:34 <roconnor> luite: oh, why not?
18:26:36 <irene-knapp> but it's a valid strategy, if heavy
18:26:41 <irene-knapp> large constant factor :)
18:27:05 <edwardk> roconnor: well thats basically what the psqueue fingertree approach gives you ;)
18:27:10 <luite> roconnor: i believe the PSQueue package is a lot faster, this one is just a demonstration thing of fingertrees or something
18:27:25 <edwardk> nand`: would you mind if i bundled this as an example?
18:27:29 <roconnor> luite: ok
18:27:30 <nand`> go ahead
18:27:36 <nand`> edwardk: what's your opinion on <~^ <=^ ?
18:27:37 <edwardk> it'll get it updated as the api changes ;)
18:27:45 <edwardk> kinda down on them at the moment
18:27:54 <edwardk> but i'm too focused on the TH changes to think about much
18:28:09 <edwardk> i'll give them a fair shake after
18:28:12 <nand`> alright
18:28:18 <roconnor> PSQ needs moor instances
18:29:21 <dmj> Cale: So .lhs is primarily used to generate code documentation?
18:29:43 <nand`> No, haddock is
18:29:54 <nand`> I'd say lhs is primarily used for writing papers about Haskell, but I could be wrong
18:30:41 <dmj> does haddock read the bird style syntax or \begin{code} and generate from that?
18:31:08 <nand`> haddock looks at Haskell comments in the form of ‚Äú-- |‚Äù or ‚Äú-- ^‚Äù
18:31:52 <edwardk> installing gloss to see your masterpiece
18:31:52 <dmj> Ah, thank you
18:32:17 <edwardk> dmj haddock and .lhs are largely incompatible
18:32:20 <nand`> edwardk: it's not entirely pretty :)
18:33:00 <nand`> come to think of it, I probably want to make the window slightly larger than the playing area
18:33:17 <nand`> (I use a tiling window manager so the window size gloss sets doesn't affect me at all, I hadn't noticed it)
18:34:59 <edwardk> nand`: that ball gets moving after a while ;)
18:35:02 <edwardk> yeah
18:35:08 <edwardk> the playing area is huge, the window is tiny
18:35:39 <Cale> dmj: another cool use is in blog posts or on mailing lists
18:36:08 <Cale> dmj: so you can have a posting which can just be wholesale copied and pasted to become a program -- the code lines marked with "> "
18:36:12 <nand`> edwardk: that's odd, the window should be the same size as the playing area
18:36:40 <edwardk> i just noticed that the ball was going off the screen and wondered where the paddles were, then i found the paddles by opening the window wider
18:36:46 <edwardk> but i never found the text ;)
18:36:49 <nand`> ah
18:36:49 <dmj> Cale: So you would post up the .lhs on your blog? Or run it through GHC first and it produces text?
18:37:29 <nand`> edwardk: well if you want, decrease the gameSize to 300 or something and add ‚ÄòwindowSize = 480‚Äô
18:37:46 <edwardk> to what?
18:37:58 <dmj> Cale: Ok nm I figured it out.
18:38:08 * edwardk <- gloss newbie
18:38:08 <nand`> edwardk: below line 15, also see line 177
18:38:15 <dmj> Cale: That's pretty cool, you can just run it through GHC
18:38:28 <dmj> or runhaskell
18:38:30 <mm_freak> absence: honestly i don't understand your code, but if you want to have one wire the first second, the next wire the next second, etc., this is currently not easily possible
18:38:33 <nand`> :177s/(gameSize, gameSize)/(windowSize, windowSize)/
18:38:55 <mm_freak> absence: but i will include something in the next version =)
18:39:13 <mm_freak> absence: currently your best bet is to write a custom switcher
18:40:09 <edwardk> no paddle-based angle change?
18:41:03 <grom358> Just looking at some of my haskell code I wrote years ago, http://hpaste.org/72528 . What is the $ operator on line 11? Its like function composition of some sort?
18:41:04 <edwardk> what are the (200,200)?
18:41:13 <Cale> $ is function application
18:41:17 <Cale> f $ x = f x
18:41:27 <Cale> but $ has very low operator precedence
18:41:39 <fuchsto> Can i declare a record as being an instance of a type class?
18:41:46 <Cale> So what you wrote is equivalent to
18:41:52 <nand`> edwardk: no angle change currently, I was thinking about outsourcing to a proper physics engine but I couldn't find one that didn't use IO
18:41:57 <Cale> (all (not . divides n)) $ (takeWhile (\p -> p*p <= n) primes')
18:42:00 <Cale> which is equal to
18:42:04 <Cale> (all (not . divides n)) (takeWhile (\p -> p*p <= n) primes')
18:42:06 <nand`> angle changes on edge hits would be nice
18:42:15 <fuchsto> So, when i have a type class defining a function   foo :: Int   and a record with a field   foo :: Int  , can the record be an instance of the type class?
18:42:16 <nand`> edwardk: (200, 200) is window position
18:42:23 <Cale> You can use it to avoid parens sometimes like that
18:42:28 <edwardk> ah
18:42:55 <nand`> edwardk: also note that decreasing the game size to 300 had the side effect of the text being in a somewhat unpleasant position, I've changed line 151 to (-0.1, 0.85)
18:43:47 <grom358> Cale: ah.. so its just makes it read a bit nicer. Yeah I only dabble with Haskell every now and then in free time so I forgot a lot of basic things with it
18:43:52 <nand`> edwardk: possible improvements would be to introduce a RandomGen and randomize the starting velocity. I wonder how lenses could factor into this
18:43:58 <zzing_> I mentioned yesterday that I am making a c image library for eventual binding to haskell. I have to pick a build system for the C library now, is there anything that would work particularly well with the cabalization of the haskell binding?
18:44:04 <edwardk> switching to FullScreen (800,600) worked fine
18:45:44 <fuchsto> edwardk, nand` Just because it sounds interesting: What game are you talking about?
18:45:52 <nand`> edwardk: interesting. I avoid FullScreen; it used to crash outright but now it seems it just resets my resolution / disables my other monitors
18:46:39 <nand`> fuchsto: http://hpaste.org/72526
18:46:39 <dmwit> nand`: Chipmunk is pretty nice. There's some Haskell bindings. Not sure why IO is a problem.
18:46:44 <edwardk> nand`: ah.
18:46:55 <edwardk> fuchsto: he wrote a pong clone using lens for position update etc.
18:47:11 <nand`> dmwit: well, because my update function is pure and that's where the calculation is being done. I could change to gloss's IO play that allows my update function to live in IO though
18:47:27 <dmwit> mmm
18:47:48 <dmwit> I wouldn't mind seeing a pure high-level interface to Chipmunk, though, if you're feeling really ambitious. That would be really awesome.
18:47:55 <nand`> heh
18:48:29 <nand`> maybe another day :)
18:48:29 <edwardk> dmwit: well i started writing a rigid body physics engine -in- haskell. mostly so i can have functional world state
18:48:40 <nand`> edwardk: I'd be interested in something like that
18:48:42 <fuchsto> edwardk: I'm hearing about lens a lot. Errm. What does it do, actually?
18:48:50 <nand`> fuchsto: makes all of your code obsolete
18:49:00 <nand`> fuchsto: (on a more serious note, provides lots of lenses and lens combinators)
18:49:01 <fuchsto> nand`: Finally!
18:49:33 <edwardk> fuchsto: lenses are 'functional references', 'lens' is based on a few observations about how you can generalize the signature of functors, foldables traversables and cps'd functions to make them all composable,
18:49:35 <nand`> just look at stuff like ‚Äú    ballSpeed.both *= speedIncrease‚Äù
18:49:46 <edwardk> and then a lens becomes a 'traversal' (generalized traverse) that is also a valid 'getter'
18:49:46 <fuchsto> nand`: Now you just have to tell me what 'lenses' are in the haskell context. I'm working for Zeiss, i think about refraction and chromatic aberration when hearing 'lens'.
18:50:09 <edwardk> fuchsto: a lens is something like a combination of a getter and a setter
18:50:14 <edwardk> the easiest way to see it is
18:50:22 <dmj> typeclasses finally just made sense to me
18:50:27 <nand`> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285 http://comonad.com/reader/2012/mirrored-lenses/
18:50:27 <edwardk> data Lens a b = Lens { get :: a -> b, set :: a -> b -> a }
18:50:33 <nand`> good posts too
18:50:33 <tylerkahn> they seem like they would be really useful‚Ä¶ working with record update syntax is really annoying
18:50:34 <dmj> just like interfaces in C#
18:50:36 <edwardk> you can actually compose lenses
18:50:48 <fuchsto> nand`, edwardk Thank you!
18:50:51 <edwardk> and they have some laws you want them to obey
18:51:16 <edwardk> the 'lens' package notices that if you generalize their signature you can make 'restricted' lenses that can do more or less
18:51:18 <fuchsto> Something like    ballSpeed *= something   doesn't look pure. But it is?
18:51:26 <edwardk> fuchsto: thats a state action
18:51:26 <nand`> perfectly pure
18:51:36 <edwardk> fuchsto: ballSpeed is a lens
18:51:48 <edwardk> he's using it to access part of the state he's got in his state monad, and update it
18:52:14 <nand`> fuchsto: it's mainly funny because now code looks like OOP: ‚Äúfoo.bar.bat += 3‚Äù
18:52:28 <fuchsto> dmj: This "Oh, a typeclass is an interface!" think will break your neck.
18:52:30 <edwardk> (*=) works in any monad with state for anything that can be used as a 'Setter', which includes lenses, traversals, indexed traversals, and isomorphisms
18:53:00 <fuchsto> dmj: I have to know. I'm still wearing a ruff
18:53:01 <nand`> edwardk: I feel like writing a colour-lenses package
18:53:07 <edwardk> fuchsto: i gave a talk on them in scala a while back its on youtube. google 'lenses: a functional imperative'
18:53:19 <edwardk> nand`: well, if you wait i'll just release my colorimetry package ;)
18:53:28 <fuchsto> edwardk: Great, i'll search for it now
18:53:29 <nand`> you're working on a colorimetry package? where?
18:53:43 <nand`> edwardk: does it do stuff like gamut transformations / proofing?
18:53:45 <edwardk> i have the code locally, along with a ton of data
18:54:25 <fuchsto> dmj: I learned the hard way that you probably don't want a type class if you intend to implement the behaviour of an interface.
18:54:40 <edwardk> its based on actual wavelengths and doing integration over the spectrum using tristimulus responses, and scotopic and photopic response curves
18:54:44 <fuchsto> dmj: Currying is way more flexible in most of my use cases
18:55:01 <nand`> edwardk: sounds pretty much like what I'd write
18:55:16 <edwardk> with the idea being that you can use it to check metamers for colorblind users because it has the SSPJ data, etc.
18:55:17 <nand`> edwardk: so I assume you're using XYZ somewhere as an intermediate form?
18:55:21 <edwardk> no
18:55:35 <edwardk> i use the actual wavelengths. i can swap to XYZ as an approximation
18:55:39 <nand`> ah
18:55:40 <dmj> fuchsto: Ah I see, that's good to know. I'm trying to make my function signatures more generic by using type classes. Instead of sum :: Int -> Int -> Int
18:55:47 <edwardk> but i was using it for a raytracer that would vary wavelengths for prism effects, etc.
18:55:53 <dmj> :fuchsto sum :: (Int a, Int b) => a -> b -> a
18:56:02 <dmj> :fuchsto but I'm getting an error
18:56:17 <edwardk> the usual problem with XYZ is that they summarize really badly when you deal with different ligth sources, etc.
18:56:20 <nand`> edwardk: I would mainly be interested in operating on colors that already live in a perceptual color space
18:56:30 <fuchsto> dmj: I think i have a note on github on a refactoring i made. I switched from type classes to a record of functions in a quite explicative use case
18:56:34 <edwardk> so i have the spectral density curves for different light sources, etc.
18:56:57 <dmj> fuchsto: I wouldn't mind taking a look at it
18:57:00 <dmj> fuchsto: `Int' is applied to too many type arguments
18:57:03 <dmj> :(
18:57:12 <fuchsto> dmj: (use fuchsto: please, not :fuchsto, otherwise the highlight in my irssi doesn't work)
18:57:15 <edwardk> i'm mostly interested in dealing with light in a scene, so metamerism in situ under different lighting conditions, etc.
18:57:30 <edwardk> and modeling the workspace it'll be presented to the user in in the end
18:57:32 <fuchsto> dmj: Oh, just add a paren here and there, it's always the same :)
18:57:35 <nand`> edwardk: it sounds super cool
18:57:40 <fuchsto> dmj: Or indentation
18:57:52 <dmj> fuchsto: ohhh, sorry, the typeclass syntax was screwing me up
18:57:55 <edwardk> its mostly a pile of data files and some spline fitting code so i can do automatic differentiation on it
18:58:00 <edwardk> i need to finish it
18:58:21 <edwardk> it was a side-track i lost myself down a while back ;)
18:58:35 <fuchsto> dmj: The line you pasted looks fine to me. Does it work now? If not, paste the whole source file on hpaste
18:59:46 <nand`> edwardk: a possible use case would be a pure-Haskell library for calibrating/profiling monitors using a spectrophotometer or similar
18:59:47 <fuchsto> dmj: What do you want to 'abstractify' using type classes? Using it for canonical functions is fine, but for behavioural contexts, i would prefer currying.
19:00:03 <levi> levi on #haskell (+Ccnpt,lag:0) ["Identify with NickServ to speak","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new
19:00:03 <levi> ERC> /join #dylan
19:00:03 <levi> <dmj> fuchsto: I wouldn't mind taking a look at it
19:00:03 <levi> <dmj> fuchsto: `Int' is applied to too many type arguments
19:00:04 <nand`> that would be something from my everyday life :)
19:00:06 <levi> <dmj> :(
19:00:09 <levi> <fuchsto> dmj: (use fuchsto: please, not :fuchsto, otherwise the highlight in
19:00:13 <levi>           my irssi doesn't work)
19:00:16 <levi> <edwardk> i'm mostly interested in dealing with light in a scene, so
19:00:17 <levi>           metamerism in situ under different lighting conditions, etc.
19:00:20 <levi> <edwardk> and modeling the workspace it'll be presented to the user in in the
19:00:24 <levi>           end                                                           [19:57]
19:00:27 <levi> <fuchsto> dmj: Oh, just add a paren here and there, it's always the same :)
19:00:30 <levi> <nand`> edwardk: it sounds super cool
19:00:33 <levi> <fuchsto> dmj: Or indentation
19:00:36 <levi> <dmj> fuchsto: ohhh, sorry, the typeclass syntax was screwing me up
19:00:40 <levi> <edwardk> its mostly a pile of data files and some spline fitting code so i
19:00:43 <levi>           can do automatic differentiation on it
19:00:46 <levi> <edwardk> i need to finish it
19:00:47 <levi> <edwardk> it was a side-track i lost myself down a while back ;)        [19:58]
19:00:50 <levi> <fuchsto> dmj: The line you pasted looks fine to me. Does it work now? If not,
19:00:54 <MostAwesomeDude> @where ops
19:00:54 <levi>           paste the whole source file on hpaste
19:00:54 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
19:00:57 <levi> <nand`> edwardk: a possible use case would be a pure-Haskell library for
19:01:00 <levi>         calibrating/profiling monitors using a spectrophotometer or similar
19:01:01 --- mode: ChanServ set +o monochrom
19:01:03 <levi>                                                                         [19:59]
19:01:06 <levi> <fuchsto> dmj: What do you want to 'abstractify' using type classes? Using it
19:01:07 --- mode: monochrom set +b *!*@c-174-52-219-147.hsd1.ut.comcast.net
19:01:08 --- kick: levi was kicked by monochrom (levi)
19:01:13 <fuchsto> Thanks
19:01:17 <MostAwesomeDude> monochrom: TYVM <3
19:01:19 <nand`> I wanted to see if it would start quoting itself or not
19:01:21 <fuchsto> What is 'levi'?
19:01:26 <dmj> fuchsto: It works now, I forgot to rename the function below it.
19:01:26 <nand`> just one line past my mark :(
19:02:12 <dmj> fuchsto: Can you give me an example of when currying would make sense over the typeclass route?
19:02:14 --- mode: monochrom set -b *!*@c-174-52-219-147.hsd1.ut.comcast.net
19:02:21 --- mode: monochrom set -o monochrom
19:02:32 <hpaste> dmj pasted ‚ÄúMultiply and Add‚Äù at http://hpaste.org/72530
19:02:56 <fuchsto> dmj: I you have a solid background in OOP, you are brainwashed the wrong way for haskell. That's why i think every OO-coder should learn haskell. But it hurts in the beginning. That's okay, that's just sore muscles.
19:03:35 <dmwit> dmj: f :: Num a => a -> a -> a; f x y = x + y
19:03:39 <dmwit> (or just f = (+)
19:03:41 <dmwit> )
19:03:41 <nand`> dmj: two errors with that, 1. (+) operates on two values of the same type so you can't distinguish between a/b like that
19:03:45 <nand`> and 2. missing a ,
19:05:28 <fuchsto> dmj: You need a 'new' type variable (like b) only if the type is different from existing type variables.
19:05:53 <dmj> fuchsto: It's true I'm brainwashed. Pattern matching feels rough at times :) I'm worse than OOP. I learned on .NET :) imperative C# turned into functional C# with LINQ, then F# looked cool, but then I realized all the F# people used Haskell.
19:05:57 <latro`a> eh, could be, not necessarily *is*
19:06:09 <nand`> edwardk: perhaps a library for operating on XYZ/Yxy/RGB/similar color spaces could be made compatible with your colorimetry library (eg. by providing lenses from one to the other)
19:06:39 <dmj> :dmwit Thanks. I see Num b is redundant
19:06:46 <fuchsto> dmj: I'm from a OSS background in C and C++, but being the consultant whore that i am, i'm working in C# now.
19:06:52 <nand`> it's not redundant, it's incorrect
19:07:04 <nand`> unless you have a (a ~ b) constraint, but then it would be redundant
19:07:11 <fuchsto> dmj: But i wouldn't use C# for a home project. I don't find my zen with C#.
19:07:27 <nand`> dmj: I came from C# to Haskell too. Now my C# code looks like crap
19:07:58 <fuchsto> nand`: Using delegates for everything and its mom now?
19:08:01 <nand`> (http://pastebin.com/KFfkMDjE for silliness)
19:08:04 <mauke> The paste KFfkMDjE has been copied to http://hpaste.org/72531
19:08:08 <dmj> fuschto: Nice! I was doing consulting as well, just quit to finish more school, really want to dive into the functional side of things.
19:08:13 <nand`> delegates? nah, Func<> everywhere
19:08:30 <dmj> nand': good to know I'm not alone, definitely an inspiration as well
19:08:47 <dmj> nand`: good to know I'm not alone, definitely an inspiration as well
19:09:05 <fuchsto> nand`: Mind if i pin a printout of this code on my office wall?
19:09:22 <fuchsto> nand`: I lol'ed indeed.
19:09:24 <nand`> fuchsto: O.o feel free, I guess; it wouldn't be a huge inspiration though
19:09:43 <nand`> it contains various tricks and even bugs to shoehorn it into the C# type system
19:10:14 <fuchsto> nand`: Naaa, it would make a great motivational. I just put the lines "P A R A D I G M S - Know when to follow them" under it.
19:10:17 <dmj> nand`: That is some insane C# code
19:10:26 <edwardk> nand`: well, i have a notion of XYZ and various RGB working spaces, i just am choosing mostly to focus on the spectral data
19:10:30 <dmj> nand`: That makes haskell look easy
19:10:59 <hpaste> nand` pasted ‚ÄúEDSL with free monads‚Äù at http://hpaste.org/72532
19:11:01 <nand`> ^- haskell version
19:11:04 <nand`> dmj: it does :)
19:11:16 <edwardk> nand`: mainly i needed to be able to say given a wavelength what is the XYZ tristimulus response, and what is the gradient of that response as the wavelength shifts
19:11:19 <nand`> (of course I could just use Control.Monad.Free, but I didn't for.. illustratory purposes)
19:12:08 <nand`> edwardk: Can gamut transformations (eg. XYZ -> XYZ) be lifted easily into Spectrum -> Spectrum ?
19:12:22 <edwardk> nand`: https://github.com/ekmett/highc/blob/master/highc/Monad.cs
19:12:40 <edwardk> not currently, but i haven't focused on those concerns at all
19:12:40 <fuchsto> nand`: The beauty of this C# code is undeniable. A marvelous hack, actually.
19:12:57 <edwardk> my main goal was just to get responses and gradients of them since nobody offers gradient info
19:13:05 <edwardk> and i was using hamiltonian techniques where i needed a derivative
19:13:45 <edwardk> https://github.com/ekmett/highc/blob/master/highc/Semigroupoid.cs is the most maintainble c# i've ever written ;)
19:13:55 <edwardk> nobody asks me to update it or anything ;)
19:14:12 <nand`> edwardk: how does this _<F, B> stuff work?
19:14:29 <edwardk> its a mess, i use them as a proxy for type application
19:14:30 <luite> 4 watchers, impressive :p
19:14:43 <edwardk> https://github.com/ekmett/highc/blob/master/highc/_.cs
19:14:47 <fuchsto> oh, i had a question, actually:
19:14:47 <luite> oops i clicked watch
19:15:02 <fuchsto> Can i declare a record as being an instance of a type class?
19:15:14 <fuchsto> So, when i have a type class defining a function   foo :: Int   and a record with a field   foo :: Int  , can the record be an instance of the type class?
19:15:28 <latro`a> an instance or a method?
19:15:37 <edwardk> anyways you have to provide all the overloads to get curried function application which makes it pretty tedious
19:15:38 <nand`> edwardk: that's actually pretty cool, I can free myself from the ugly hacks (explicit boxing/unboxing) I use to work around lack of type application
19:15:39 <dmj> nand`: I can't believe you put monads in C#. I'm still trying to get my head around this. Generics in C# can be so ugly
19:15:47 <latro`a> (method isn't the best word, but things like return/>>=/etc.
19:15:48 <latro`a> )
19:15:55 <nand`> dmj: I didn't put monads in C#
19:16:05 <nand`> dmj: that comes from Linq
19:16:19 <nand`> if anything, it looks like edwardk did :)
19:16:20 <edwardk> there are problems when you go to actually use it in anger. it was based on something someone posted on 'highj' and i thought 'highc' was a better pun
19:16:23 <edwardk> hah
19:16:24 <edwardk> yeah
19:16:33 <Saizan> fuchsto: you can do this: data R = R { field1 :: Int}; class C a where foo :: a -> Int; instance C R where foo = field1
19:17:28 <nand`> latro`a: I've stumbled across that dilemma before, how controversial is the usage of ‚Äòmethod‚Äô to mean ‚Äòtypeclass function‚Äô?
19:17:38 <dmj> nand`: But you created your own Bind implementation. Linq doesn't come with that out of the box
19:17:41 <latro`a> I'm not sure
19:17:45 <dmj> nand`: or does it...
19:17:59 <nand`> dmj: I wrote ‚ÄòSelectMany‚Äô, which is what Linq desugars to
19:18:15 <nand`> SelectMany is just a slightly souped up Bind (but it can be defaulted from Bind, as I did in the example)
19:18:42 <nand`> but Linq introduces SelectMany for many built in types, eg. Enumerables
19:19:33 <Saizan> so C# has higher-kinded polymorphism?
19:19:58 <edwardk> dmj: linq includes a bunch of combinators out of the box that desugar to things, the problem is of course that you have to implement them all for every !@*#( monad-like thing you come up with because they have no concept of higher kinded polymorphism
19:19:59 <edwardk> no
19:19:59 <dibblego> No.
19:20:00 <nand`> edwardk: fwiw lines 5/7 can be compacted to ‚Äòpublic object Value { get; private set; }‚Äô
19:20:01 <dmj> nand`: To be honest I've never used it. I use .Select a lot, but thats the same thing as map. How does SelectMany translate?
19:20:19 <edwardk> nand`: i have no intention of ever touching that code again ;)
19:20:23 <nand`> good :)
19:20:28 <dibblego> Linq is a syntactic mechanism that translates to the equivalent of (>>=) and fmap
19:20:42 <dibblego> but it is not generalised on the type constructor
19:20:48 <edwardk> if i want to contort my brain i just go write scala for a while
19:20:54 <nand`> dmj: SelectMany is just Bind with an extra Func<A,B,C>
19:21:15 <edwardk> and the contortions are then mostly to make the language behave
19:21:44 <deggis> (total newbie with opengl asking) haskell, opengl & glut: my vertex set stops rotating (using rotate command) as I load, link my own vertex/fragment shaders (from C files) and say currentProgram = those. how to do both?
19:21:47 <nand`> edwardk: I only wrote my code to paste it and say ‚Äòlook, this is how horrendously complex, buggy and long C# code is; here's the equivalent Haskell two-liner yadda yadda‚Äù
19:21:54 <edwardk> hahah
19:21:57 <edwardk> fair nuff
19:22:14 <dibblego> http://code.google.com/p/kinet/ some monads using linq
19:22:16 <nand`> (completely ignoring the fact that you don't get too many free monads in C# programs)
19:23:01 <otters> do you have to know category theory to understand what a free monad is?
19:23:06 <otters> I read the wiki and I didn't retain any of it
19:23:23 <fuchsto> Saizan: Thank you, i try that
19:23:23 <nand`> otters: wiki is not the best source for these things if you don't know the theory
19:23:31 <dmj> I'm kind of impressed with C# now
19:23:34 <nand`> otters: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
19:23:41 <dibblego> dmj: sorry, not intended
19:23:52 <otters> nand`: wikipedia syndrome
19:24:07 <edwardk> dmj: its actually a pretty decent imperative language.
19:24:22 <nand`> (silently assuming that isn't a contradiction)
19:24:31 <edwardk> i bemoan the lack of higher kinds, etc. but you can 'get stuff done' in it just fine
19:25:01 <nand`> C# is probably the language I'd whine least about if forced to use by some evil employer
19:25:42 <edwardk> when forced to choose between scala and c# i'd have a hard time, scala tries harder and fails, c# doesn't do enough, but succeeds at what it tries
19:25:52 <dmj> nand` yea, did you guys see that "Functional programming is a ghetto" article on Hacker News? Great quote in there: Java isn't a language people choose, its a language that people make other people use
19:25:57 <jrajav> C# is pretty dang sweet
19:26:07 <nand`> dmj: heh
19:26:44 <jrajav> It's definitely a good compromise language if you want to use something with good "business features" (lmao) that doesn't suck to code in
19:26:53 <nand`> dmj: C# is actually taking steps in introducing scary words to enterprise vocabulary, have you ever seen ‚Äòcovariant/contravariant interfaces‚Äô?
19:27:01 <nand`> those mean exactly what they do in category theory
19:27:18 <Saizan> oh, i've found the definition of _ :)
19:27:33 <dibblego> Erik Meijer and friends are sneakily introducing things like that into C#
19:27:55 <nand`> I suspect it won't be long until we see Corepresentable Endofunctors
19:27:55 <edwardk> thats mostly because they got beat up by them when they introduced linq
19:27:56 <dibblego> there are still C# programmers who get upset when you tell them than Linq is for working on monads
19:28:11 <edwardk> Saizan: =)
19:28:17 <nand`> dibblego: well, Linq doesn't have return
19:28:20 <nand`> so I'd have my own doubts
19:28:27 <MostAwesomeDude> So, uh, not to rain on the parade, but is C# free yet?
19:28:38 <dibblego> nand`: sure, so "semi-monad" then, but the objection is to the word, not its accurate usage
19:28:44 <nand`> MostAwesomeDude: I use ‚Äòmono‚Äô for any C# shenanigans, which I believe is free
19:28:51 <nand`> dibblego: oh
19:28:53 <otters> nand`: I'm kinda getting it now
19:28:54 <MostAwesomeDude> nand`: Not patent-free. :c
19:29:09 <edwardk> dibblego: you should rename Bind to Semimonad
19:29:09 <dibblego> nand`: you can waste your time reading this if you like http://apisuckage.wordpress.com/2009/06/19/on-linq-monads-and-the-blindness-of-power/
19:29:19 <dibblego> edwardk: you think? I've been wondering it myself
19:29:29 <otters> I don't see what situations it's good for though
19:29:30 <edwardk> while you're at it s/Costate/Store =P
19:29:36 <dibblego> edwardk: I've done that
19:29:41 <edwardk> =)
19:29:54 <dmj> nand`: I see, so IEqualityComparer<T> (T is contravariant). Just explicit comparison instructions. Implicit is covariant
19:30:08 <dmj> like IEnumerable<T>
19:30:39 <nand`> otters: a few good examples are provided, see also http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
19:30:46 <edwardk> i'd be down with Semimonad, but cosemimonad or semicomonad is a mouthful
19:31:05 <nand`> we should clearly invent a new word that has nothing to do with anything else
19:31:11 <dibblego> edwardk: so Semimonad and Extend?
19:31:13 <nand`> would fit in with the rest of algebraic names
19:31:24 <dibblego> could always type-alias for those with big mouths
19:31:25 <edwardk> well if you're keeping Extend, then Bind
19:31:33 <dmj> MostAwesomeDude: M$ open sourced MVC4, might have had something to do with Phil Haack going to github
19:31:34 <dibblego> type-alias both Extend and Bind?
19:31:40 <fuchsto> Saizan: Works like a charm, thank you
19:31:49 <edwardk> kinda messy because you can't use it when you instantiate it
19:31:52 <nand`> isn't the problem with names like Extend and Bind that they don't convey the actual monad/comonad laws associated with them?
19:31:54 <edwardk> you can't subclass an alias
19:32:13 <edwardk> so all you do is create a point where the user can get it wrong
19:32:20 <MostAwesomeDude> dmj: But have they released all the patents regarding the extended parts of .NET that everybody uses? IIUC only C#'s standardized part is patent-safe, and that doesn't include the stuff everybody uses.
19:32:40 <Saizan> fuchsto: np
19:32:45 <nand`> edwardk: isn't there an extension that allows this?
19:32:53 <nand`> or was that only for the RHS
19:32:58 <otters> I guess understanding free monads and finding a practical application for them is a big leap
19:33:09 <dmj> MostAwesomeDude: I assume not. They probably just made the framework code available to accept pull requests
19:33:09 <nand`> otters: the same goes for a lot of things
19:33:15 <dibblego> nand`: we are secretly discussing scala
19:33:20 <nand`> otters: but when you've done the latter, you can be more or less sure of the former :)
19:33:32 <nand`> dibblego: oh
19:33:36 <dmj> MostAwesomeDude: framework code meaning only the MVC4 assemblies
19:33:51 <MostAwesomeDude> dmj: Mm. I don't dislike the language, but, well, after seeing what's happened with Java, it's hard to avoid the once-bitten-twice-shy effect. :3
19:34:03 <nand`> with ‚Äòsubclass‚Äô I was thinking ‚Äòclass Foo a => Bar a‚Äô and ‚Äòinstantiate‚Äô had me thinking ‚Äôinstance Foo a where‚Äô ..
19:34:07 <nand`> that was sneaky
19:34:35 <dibblego> nand`: edwardk and I have a perverse pleasure in trying to make scala somewhat useful
19:34:44 <JoeyA> TIL: In record type syntax, you can do the signatures like this: data Point = Point { x, y, z :: Int }
19:34:51 <dmj> :nand` so selectmany is bind, and is that kind of like a flattening operation? http://msdn.microsoft.com/en-us/library/bb534336.aspx
19:34:54 <nand`> dibblego: I'll thank you in advance in case I'm ever forced to use Scala by some manically insane dictator
19:34:59 <dmj> nand`: so selectmany is bind, and is that kind of like a flattening operation? http://msdn.microsoft.com/en-us/library/bb534336.aspx
19:35:09 <edwardk> yep, and for me at least the secret to making scala fast is to rip out all my monads ;)
19:35:16 <dibblego> SelectMany is Bind, but it also has overloads
19:35:23 <dmj> MostAwesomeDude: Do you code Haskell for your job?
19:35:37 <nand`> dmj: if by ‚Äòflatten‚Äô you mean ‚Äòjoin‚Äô you should be able to implement that in terms of SelectMany
19:36:03 <MostAwesomeDude> dmj: My current job is writing web apps in Django. I do not especially enjoy it; Django is not well-suited to things that are not blogs.
19:36:49 <dmj> nand`: I'm still pretty new to all these monads. Linq was my gateway drug though, Is LYAH the best or would you recommend a better way to get my mind around them?
19:36:59 <nand`> dmj: I liked LYAH
19:37:05 <nand`> not sure if it's the best, but it's the best I've read
19:37:08 <dibblego> Select is fmap and has this type, implemented as a method on F<A>:  Func<A, B> => F<B>, while SelectMany is also implemented on F<A> as: Func<A, F<B>> => F<B>, but in order to properly use it in LINQ, you also need SelectMany on F<A>: Func<A, F<B>, Func<A, B, C> => F<C>
19:37:09 <nand`> which is not an awfully large set
19:37:25 <dmj> MostAwesomeDude: Python is a pretty sweet language, I'd take it over C#. Least you get to use a Mac :)
19:37:43 <dmj> nand`: Appreciate it, will keep banging my head on it
19:37:44 <MostAwesomeDude> dmj: Oh, I don't use Apple products, mostly on account of not being able to afford them.
19:37:50 <MostAwesomeDude> I do hear that Apples are shiny though.
19:38:14 <dmj> MostAwesomeDude: Do you use ubuntu?
19:38:35 <MostAwesomeDude> dmj: At work, Ubuntu; at home, Fedora.
19:40:08 <dmj> dibblego: On your last example:  Func<A, F<B>, Func<A, B, C>> => F<C> Did you mean to close here : Func<A,B,C>>
19:40:22 <dibblego> oh sorry, let me repeat
19:40:29 <dibblego> Select is fmap and has this type, implemented as a method on F<A>:  Func<A, B> => F<B>, while SelectMany is also implemented on F<A> as: Func<A, F<B>> => F<B>, but in order to properly use it in LINQ, you also need SelectMany on F<A>: Func<A, F<B>> => Func<A, B, C> => F<C>
19:40:29 <nand`> no, Func<A, F<B>>
19:40:38 <nand`> see (a -> m b) in >>=
19:41:46 <dmj> can I look it up from lambda bot?
19:41:54 <nand`> :t (>>=)
19:41:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:41:56 <nand`> like this?
19:42:00 <dmj> ah thanks
19:42:07 <dmj> So that is Bind
19:42:11 <beaky> http://ideone.com/mVtZB what are some alternative/better ways of accomplishing exponentiation in haskell?
19:42:12 <nand`> yes
19:42:28 <dibblego> @type \a f g -> a >>= \a' -> f >>= \b' -> return . g a'
19:42:29 <lambdabot> forall (m :: * -> *) a a1 a2 (m1 :: * -> *). (Monad m1, Functor m, Monad m) => m a -> m a1 -> (a -> m a2) -> m (m1 a2)
19:42:30 <dmj> flatten
19:42:36 <dmj> sorry ignore that
19:42:37 <nand`> is it bad if I read ‚Äòexponentiation‚Äô and thought ‚Äòcurrying‚Äô?
19:42:38 <dibblego> no
19:42:42 <nand`> I was about to reply too
19:42:50 <dmj> :)
19:43:01 <edwardk> hrmm, its bad when your template haskell causes ghc to flip out with an impossible happened
19:44:10 <dibblego> @type \a f g -> a >>= \a' -> f a' >>= return . g a'
19:44:11 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => m a -> (a -> m a1) -> (a -> a1 -> a2) -> m a2
19:44:21 <dmj> the >>= type signature is still blowing my mind. I just need to read more LYAH
19:44:31 <dibblego> Select=fmap, SelectMany = (>>=) as the above function too
19:45:17 <JoeyA> Is there a library to make reading nested records more convenient?  E.g. data Foo = Foo { ... }; data Bar = Bar { barFoo :: Foo, ... }; data Baz = Baz { bazBar :: Bar, ... }
19:45:34 <JoeyA> If I have a Baz, and want to get a field from the Foo, I have to say fooX . barFoo . bazBar
19:45:55 <JoeyA> Is there a lens library or something to make "subclassing" like this more convenient?
19:46:34 <JoeyA> e.g. by overloading fooX :: HasFoo foo => foo -> Int
19:47:00 <shachaf> That seems like a pretty weird type class.
19:47:12 <JoeyA> How so?
19:47:50 <nand`> ‚ÄúIs there a library to make reading nested records more convenient‚Äù <- edwardk, go!!
19:48:04 <JoeyA> instance HasFoo Foo where fooOf = id; instance HasFoo Bar where fooOf = barFoo; instance HasFoo Baz where fooOf = barFoo . bazBar
19:48:07 <edwardk> nand`: =P
19:48:20 <nand`> edwardk: oh look, he even replicated your makeClassyLenses
19:48:24 <edwardk> JoeyA: thats what lens is for, the new version will auto generate those
19:48:32 <dmj> nand`: So in the C# code, when you have a polymorphic data type, an object with a List<T> property. var result = petOwners.selectMany(x => x.Pets); It should contain a list of lists, but it contains one flattened list.
19:48:39 <edwardk> its going up as soon as i can fix this !@# template haskell bug
19:48:51 <dibblego> dmj: C# does not have a proper List, so it gets hairy
19:48:53 <dibblego> gotta go
19:49:16 <dmj> dibblego: ok then yes a hairy polymorphic list :)
19:49:29 <dmj> :dibblego take it easy and thanks for the info
19:49:33 <nand`> dibblego: ‚ÄúIt should contain a list of lists‚Äù <- no
19:49:41 <nand`> dibblego: that's what fmap is for
19:49:53 <edwardk> hrmm, can i get another set of eyes trying to help track down my TH bug?
19:49:54 <roconnor> @type maybe
19:49:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:50:01 <roconnor> @type maybe return mzero
19:50:03 <lambdabot> forall a (m :: * -> *) a1. (Monad m, MonadPlus ((->) a1)) => Maybe a1 -> a -> m a
19:50:11 <roconnor> @type maybe mzero return
19:50:12 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
19:50:20 <dibblego> sometimes should write acme.Linq
19:51:22 <edwardk> nand`: https://github.com/ekmett/lens/blob/master/examples/Test.hs it blows up when i try to do classy lenses
19:51:45 <nand`> edwardk: I do not know TH, sorry
19:52:13 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/TH.hs its somewhere in there ;)
19:52:25 <edwardk> maybe i should write code in more easily tested units
19:53:07 <nand`> edwardk: what lenses would line 8 generate, incidentally?
19:53:36 <edwardk> its a single constructor class so it gets an isomorphism lens based on the constructor name
19:53:48 <edwardk> foo :: Iso a b (Foo a) (Foo b)
19:54:02 <nand`> (not the other way round?)
19:54:05 <edwardk> yep
19:54:12 <edwardk> because its 'to Foo'
19:54:14 <edwardk> =)
19:54:18 <nand`> ah
19:54:18 <edwardk> the other way is 'from Foo ;)
19:54:22 <edwardk> er from foo
19:54:41 <edwardk> if you put a record field in there it'll make the lens the other way
19:54:47 <nand`> yeah
19:54:48 <edwardk> (as an isomorphism as well)
19:55:11 <parcs`> edwardk: doesn't blow up for me
19:55:40 <edwardk> parcs`: uncomment one of the last two
19:55:40 * hackagebot time-recurrence 0.9.0 - Generate recurring dates. (ChrisHeller)
19:55:46 <edwardk> those go down the classy path
19:55:51 <nand`> ‚Äòthd‚Äô <- there's one I haven't seen before
19:55:52 <edwardk> because they have no type arguments
19:55:57 <nand`> sounds like ‚Äòthud‚Äô
19:55:57 <edwardk> heh
19:56:21 <parcs`> uh oh
19:56:43 <edwardk> parcs`: i'm bettings its in my classDecls <-   part of makeFieldLenses
19:57:00 <parcs`> i have a somewhat recent build of ghc 7.5, let me try that
19:58:13 <edwardk> the goal is it should make class HasMono t where mono :: Lens t t Mono Mono; instance HasMono Mono where mono = id
19:58:32 <edwardk> and then define lenses for monoFoo an monoBar that use the class
19:58:36 <nand`> ‚ÄòThe exact Name `x_a47G' is not in scope ...‚Äù
19:58:50 <otters> so I've been reading this Pipes to Conduits guide
19:58:56 <otters> http://unknownparallel.wordpress.com/2012/07/24/pipes-to-conduits-part-0-combining-functors/
19:59:11 <otters> and he imports FreeF and liftF from Control.Monad.Free
19:59:20 <otters> but hoogle cannot find those, and they're not in free or control-monad-free
19:59:30 <nand`> edwardk: I thought you needed $( ) around TH stuff  <- I know nothing about TH
19:59:33 <edwardk> oh wait
19:59:40 <edwardk> nand`: no thats gone now
19:59:51 <otters> anybody know the source for those?
20:00:02 <edwardk> think i have it one sec
20:00:06 <nand`> should be updated in Pong then
20:00:16 <edwardk> i was putting the classP constraint around the constructor, not around var x
20:00:39 <fuchsto> Hm. Perhaps my approach is too OO-minded, but: I need some kind of polymorphism like in C++ etc.: Assuming i have a   data Something x   and a function accepting a Something x. Now assuming there is two complete types Something Foo and Something Bar. I can declare   sth = Something Foo   or sth = Something Bar  and passing either of them to my function works.
20:01:16 <fuchsto> However, i cannot declare   sth = if cond then Something Foo else Something Bar
20:01:28 <nand`> you can use Either Foo Bar if that's what you want
20:01:40 <nand`> I'm not sure what it is you want though
20:02:24 <Mortchek> fuchsto, if Foo and Bar are of different types, then Something Foo and Something Bar are of different types, and the variable must have one specific type.
20:02:42 <nand`> otters: free has liftF
20:02:46 <Saizan> yeah, you're probably using more types than you'd want
20:02:52 <fuchsto> Mortchek: Yes, i got that. So, what's the right way?
20:03:07 <Mortchek> fuchsto, Either sounds like a good idea.
20:03:22 <Mortchek> You'd write it as Left Foo or Right Bar, or the like.
20:03:25 <otters> nand`: I had to install pipes
20:03:32 <fuchsto> Mortchek: The receiving function is agnostic of the concrete types. It just knows the interface defined by Something
20:03:57 <JoeyA> You could call the function at the if/then site.
20:04:11 <fuchsto> And there is an arbitrary number of complete types as instances of Something
20:04:15 <JoeyA> e.g. instead of f (if cond then Something Foo else Something Bar)
20:04:27 <JoeyA> say if cond then f (Something Foo) else f (Something Bar)
20:04:54 <nand`> if f is polymorphic in a way for that to work, I suspect you can factor out something common about Foo and Bar
20:04:55 <fuchsto> JoeyA: Hm, that's true. The function always has the same return type, so that would work
20:04:59 <JoeyA> What you'd like to happen is for (if cond then Something Foo else Something Bar) to be typed as exists a. Something a
20:05:09 <nand`> (unless of course f is trivial)
20:05:39 <JoeyA> But Haskell doesn't type check that way.
20:05:48 <fuchsto> nand`: Everything they have in common is defined in Something, and every method in Something foo depends on foo, of course
20:05:51 <JoeyA> (I wonder what it would be like if it did, though)
20:05:51 <edwardk> yay
20:05:52 <edwardk> found it
20:05:57 <JoeyA> Tell us?
20:05:58 <edwardk> i had a dangling free variable in the type
20:06:33 <fuchsto> edwardk: Right, that's my problem
20:06:57 <fuchsto> edwardk: In C++ i could solve that using a plain old template
20:07:35 <fuchsto> edwardk: Or using a pointer typed to the abstract class
20:08:09 <edwardk> yay
20:08:10 <edwardk> mono :: (Functor f, HasMono t) => (Mono -> f Mono) -> t -> f t
20:08:18 <nand`> :)
20:08:41 <nand`> edwardk: come to think of it, will TH autogenerate instance HasMono Nucleosis?
20:08:47 <edwardk> nope
20:08:50 <nand`> for iso types
20:08:52 <edwardk> you have to make that yourself
20:08:53 <nand`> it would make sense
20:09:08 <edwardk> too many special cases already
20:09:18 <nand`> I see
20:09:24 <parcs`> yay metaprogramming
20:09:31 <nand`> would work well for newtypes as well, no additional boilerplate needed and you can just operate on the newtype as if it were the underlying type
20:09:36 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/TH.hs
20:09:56 * nand` emerges
20:09:57 <edwardk> the issue is i went ouf ot my way to provide flags so you can say 'don't make the instance or class for me', etc
20:10:11 <edwardk> inc ase you want to put otherstuff in there
20:10:20 <edwardk> the main focus is on creating the composed lenses for you
20:11:18 <nand`> Lens.hs:31:3: `mono' is not a (visible) method of class `Nucleosis' <- wait, what?
20:11:23 <nand`> what is it called?
20:11:33 <edwardk> ?
20:11:55 <edwardk> nuclear
20:11:58 <edwardk> you should be able to write
20:12:08 <edwardk> instance HasMono Nucleosis where mono = nuclear
20:12:36 <nand`> oh
20:12:38 <nand`> I'm being tired
20:12:47 <nand`> ‚Äúinstance Nucleosis HasMono‚Äù is what I wrote
20:12:53 <edwardk> =)
20:12:59 <nand`> too much C#
20:13:16 <edwardk> this will kill a ton of boilerplate for me
20:13:23 <nand`> oh, I like how ‚Äòmono‚Äô is a lens
20:13:45 <edwardk> yeah its the self-lens
20:13:53 <edwardk> its a little inconsistent with the current conventions
20:13:54 <nand`> I thought it was just HasMono a => a -> Mono
20:14:05 <edwardk> nah, coz you want to edit it
20:14:19 <nand`> yeah
20:15:02 <edwardk> anyways with the rules you can pretty much concoct whatever scheme you want for lens construction
20:15:11 <nand`> so classy is the default? I thought you'd be having that as makeClassyLenses
20:15:20 <edwardk> no isos, no classes, or always use classes, never isos, etc.
20:15:23 <edwardk> i was debating about it
20:15:29 <edwardk> right now its a mixed model by default
20:15:54 <edwardk> where it uses iso if it can, classes if it can, then makes boring lenses otherwise
20:16:14 <edwardk> iso overrides classes (and tends to steal the same name)
20:16:28 <nand`> I'd expect ‚Äònuclear‚Äô to have been polymorphic with HasNuclear too
20:16:55 <edwardk> didn't happen because it was an iso
20:16:58 <edwardk> iso trumped class
20:17:07 <edwardk> if you added another field itd lose
20:17:27 <edwardk> not sure if i like this behavior but i was experimenting with how to mix models
20:17:37 <edwardk> i'll probably make 3 sets of combinators
20:17:56 <edwardk> makeIso, makeClassy and makeLenses
20:19:25 <edwardk> the reason why nuclear lost is that if i use the class i can't have it generate an isomorphism
20:19:35 <nyingen> aw, I missed chrisdone
20:19:41 <edwardk> because nuclear will be a lens for all the other usecases
20:19:43 <nand`> I'm not sure I want classy by default
20:20:03 <edwardk> nand`: me neither
20:20:17 <edwardk> nand`: i'm thinking those 3 combinators with their corresponding defaults
20:20:48 <edwardk> makeLenses only makes lenses, makeIso only makes isomorphisms, and makeClassy only makes classy lenses and requires a monomorphic type.
20:21:24 <edwardk> but for right now i'm just basking in the fact that that sucker compiled ;)
20:21:25 <roconnor> @type repeat
20:21:26 <lambdabot> forall a. a -> [a]
20:21:27 <roconnor> er
20:21:30 <roconnor> @type forever
20:21:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
20:21:35 <roconnor> hmm
20:21:47 <edwardk> repeated :: Fold a a
20:21:53 <edwardk> =)
20:22:37 <edwardk> ghci> toListOf repeated 1    => [1,1,1,1,1,1,1,1,1,1,1,1
20:22:54 <edwardk> don't have a forever fold though ;)
20:24:26 <roconnor> needing stateT on the outside to use focus is a little annoying
20:24:39 <roconnor> I need to a commute operation for StateT and WriterT
20:25:39 <edwardk> well, you can make a custom focus class that can drill down and fine and swap the state but it needs mptcs
20:25:47 <edwardk> and i wasn't willing to put it in the main package
20:25:52 <edwardk> er find
20:38:21 <roconnor> @hoogle StateT
20:38:22 <lambdabot> Control.Monad.State.Lazy StateT :: (s -> m (a, s)) -> StateT s a
20:38:22 <lambdabot> Control.Monad.State.Strict StateT :: (s -> m (a, s)) -> StateT s a
20:38:22 <lambdabot> Control.Monad.Trans.State.Lazy StateT :: (s -> m (a, s)) -> StateT s m a
20:46:00 <VitamnP> hi, I'm trying to test this http://hpaste.org/72533 function in GHCI, but I get this error "No instance for (Show ([Cell] -> Cell)) arising from a use of `print'". I have Cell deriving from Show already what else do I need to do
20:46:52 <Cale> apply your function to more than one parameter
20:46:59 <latro`a> sounsd like you're only passing it one argument and then trying to show it, yeah
20:47:14 <VitamnP> ah ok thx
20:47:28 <latro`a> haskell errors are actually quite helpful
20:47:31 <VitamnP> oops lol i forgot the 2nd arg
20:47:32 <latro`a> imo
20:47:37 <VitamnP> yeah ur right
20:47:55 <Cale> They are, it just sometimes takes a bit of thought to make sense of what they say
20:48:15 <Cale> You get used to it though :)
20:56:52 <cleantc> what does it mean semantically? let  Just x | x < 5  = Just 4      Enough-Space     | x > 10 = Just 11   in x
21:01:49 <roconnor> StateT (execWriterT . runMaybeT . runStateT (forever step))
21:05:29 <edwardk> blech
21:05:51 <roconnor> I failed to cabal install lens
21:06:00 <roconnor> Preprocessing library array-0.4.0.0...
21:06:02 <roconnor> Data/Array/IArray.hs:1:14: Unsupported extension: Trustworthy
21:06:04 <roconnor> hmm
21:06:14 <roconnor> I wonder if this is an old ghc thing
21:06:57 <roconnor> probably have the wrong version of cabal for my ghc
21:06:59 <edwardk> roconnor: using old ghc?
21:07:07 <edwardk> i can probably work with older array
21:07:16 <roconnor> $ ghc --version
21:07:17 <roconnor> The Glorious Glasgow Haskell Compilation System, version 7.0.4
21:07:20 <edwardk> yeah
21:07:28 <edwardk> what version of array is installed on your machine?
21:07:36 <mm_freak> > let x | x < 3 = x in x
21:07:40 <lambdabot>   mueval-core: Time limit exceeded
21:07:45 <mm_freak> cleantc: it means bottom =)
21:07:51 <roconnor> edwardk: ghc-pkg list doesn't say
21:07:52 <edwardk> can you try to edit the bound on the cabal file to see if lowering it to include your version works?
21:08:03 <edwardk> ghc-pkg list | grep array shows nothing?
21:08:28 <mm_freak> cleantc: you're pattern-matching "Just x" against "Just 4", if x < 5‚Ä¶  in order to determine x < 5, it needs to know x
21:08:33 <mm_freak> and this recurs forever
21:08:37 <edwardk> array from the old platform was 0.3.0.2
21:08:45 <edwardk> so i can lower the bound in the repo at least
21:11:48 <edwardk> lowering bounds to permit anything from the old platform as well
21:12:07 <roconnor> package template-haskell-2.5.0.0 requires containers-0.4.0.0
21:12:09 <roconnor> package parallel-3.2.0.3 requires containers-0.5.0.0
21:12:10 <roconnor> package lens-1.3.1 requires containers-0.5.0.0
21:12:13 <roconnor> oh cabal why do you lie to me?
21:12:25 <cleantc> oh I see
21:12:44 <edwardk> you could just install the current platform =P
21:13:00 <roconnor> then none of my binaries will work
21:13:30 <roconnor> how do I tell cabal to use containers-0.4.0.0 ?
21:13:53 <edwardk> if you pull the latest lens from github, it may be permissive enough in bounds
21:14:06 <latro`a> do you have that much stuff that it's a burden to recompile?
21:14:08 <edwardk> i tried to include the old platform versions of everything except transformers and mtl
21:14:18 <edwardk> there you're hosed
21:14:43 <edwardk> not yet ready to push it to hackage though. i want to get the new TH in first
21:15:06 <edwardk> it compiles now, but the default config is kinda frustrating
21:15:07 <roconnor> I don't understand cabal's error
21:15:24 <edwardk> i have pretty tight bounds on stuff
21:15:28 <edwardk> i required the current platform
21:15:36 <edwardk> you can't install 90% of that on 7.0.4
21:15:44 <edwardk> so you can't succeed =P
21:15:56 <edwardk> the version i just shoved to github should work on 7.0.4
21:16:02 <edwardk> but i can't test it
21:16:05 <roconnor> but no one has tight bounds on containers
21:16:09 <roconnor> why is cabal complaining
21:16:25 <edwardk> no but once you install a package cabal is loathe to recompile it all
21:16:34 <roconnor> god damn you cabal
21:16:47 <edwardk> so you tend to get locked into the current version forever
21:16:49 * roconnor uses --reinstall
21:17:10 <edwardk> this is why when i release a new version of a low level package of mine i release bumped downstream dependents as well
21:17:17 <edwardk> because then cabal installs properly for most users
21:17:25 <edwardk> it makes a HUGE amount of work for me though
21:18:37 <roconnor> wants cabal to install multiple versions of the same version of packages one day
21:19:03 <roconnor> okay cabal configures now
21:19:10 <edwardk> yay
21:19:12 <roconnor> src/Control/Lens.hs:746:21: Not in scope: `<>'
21:19:15 <roconnor> ;(
21:19:17 <edwardk> haha
21:19:21 <edwardk> let me patch those
21:19:24 <edwardk> they aren't critical
21:22:29 <edwardk> ok pull and try again
21:22:44 <edwardk> i think i found them all
21:23:19 <roconnor> src/Data/Complex/Lens.hs:24:20:
21:23:20 <roconnor>     Could not deduce (RealFloat a) arising from a use of `:+'
21:23:22 <roconnor>     from the context (Functor f)
21:23:23 <roconnor>       bound by the type signature for
21:23:25 <roconnor>                  real :: Functor f => (a -> f a) -> Complex a -> f (Complex a)
21:23:26 <roconnor>       at src/Data/Complex/Lens.hs:24:1-32
21:23:28 <roconnor> strange
21:23:29 <roconnor> did Complex change?
21:23:36 <edwardk> ok, the old complex
21:23:37 <edwardk> yeah
21:23:50 <roconnor> hmm
21:23:57 * roconnor is feeling old
21:24:07 <roconnor> maybe I'll just use my lens package :D
21:24:54 <edwardk> base 4.3.1 was the last appearance of RealFloat on Complex
21:24:56 <edwardk> =P
21:25:14 <roconnor> was it changed in Haskel 2011?
21:25:30 <edwardk> well, they removed from the language, so yes
21:26:39 <edwardk> you're forcing me to make it more portable ;)
21:27:39 <edwardk> ghc-pkg list | grep base   shows what?
21:27:56 <roconnor> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
21:28:18 <edwardk> no base version?
21:28:39 <roconnor> nope, but that is probably because ghc-pkg is kinda broken on nix.
21:28:45 <edwardk> oh
21:28:50 <roconnor> Well, I'd argue it is kinda broken on every other system
21:29:12 <mk245> In configurator, once you've parsed your configuration file and lets say you have a list that comes back as List [String "aa", String "aa"] how do you access those values
21:29:12 <edwardk> ok pull and try now
21:29:30 <roconnor> wired-in package base mapped to base-4.3.1.0-20f281ec3ed98b354fcbff0a11ebb5b6
21:29:41 <edwardk> roconnor: great, thats the bound i assumed
21:29:59 <roconnor> oh, this is worse
21:30:05 <edwardk> hahaha
21:30:12 <edwardk> how?
21:30:13 <roconnor> src/Control/Lens/TH.hs:369:13:
21:30:14 <roconnor>     No instance for (Applicative Q)
21:30:16 <roconnor>       arising from a use of `for'
21:30:17 <roconnor>     Possible fix: add an instance declaration for (Applicative Q)
21:30:19 <roconnor>     In the expression: for (toList fieldMap)
21:30:23 <roconnor> oh wait, maybe it isn't bad
21:30:26 <edwardk> ok, now you're officially dead in the water ;)
21:30:47 <roconnor> oh come on, WrappedMonad
21:30:50 <roconnor> you are almost there
21:30:50 <edwardk> what version of template-haskell is that?
21:30:53 <roconnor> 2.5
21:31:26 <edwardk> ok 2.7 added the Applicative for Q
21:31:32 <roconnor> mabye I can use 2.7 somehow
21:31:33 <edwardk> so i'll just make an orphan for old ones ;)
21:31:36 <edwardk> no
21:31:39 <edwardk> its tied to ghc
21:31:44 <roconnor> oh right
21:32:00 <roconnor> why is it in hackage then?
21:32:06 * roconnor doesn't want to know
21:32:29 <edwardk> well, minor point releases may be compatible
21:33:40 <edwardk> pushed with Applicative Q orphan
21:33:44 <roconnor> edwardk: orphan?
21:33:50 <edwardk> its a local instance
21:33:56 <roconnor> WrappedMonad!
21:33:58 <roconnor> :D
21:34:00 <edwardk> screw that
21:34:01 <roconnor> okay whatever
21:34:08 <edwardk> and i refuse to rewrite the code to not use applicative sugar
21:34:14 <edwardk> so its this or nothing =P
21:34:36 <edwardk> i'm not living in wrappedmonad for 80 lines of code where _everything_ is in the monad
21:34:41 <roconnor> src/Control/Lens/TH.hs:65:11: Not in scope: `ap'
21:35:02 <Xbilprl> hey
21:35:09 <edwardk> next ;)
21:35:36 <roconnor> oh it builds
21:35:41 <edwardk> score
21:35:41 <roconnor>     Warning: orphan instance: instance Applicative Q
21:35:43 <roconnor> :P
21:35:45 <edwardk> yep
21:36:01 <roconnor> I'm impressed you induldged me
21:36:04 <roconnor> edwardk++
21:36:05 <edwardk> you can live with that for the sin of using an ancient platform
21:36:15 <roconnor> I don't use the haskell platform
21:36:42 <edwardk> i'll probably patch the state call in Control.Lens to relax the mtl/transformers bounds too
21:36:53 <edwardk> by using state when available or get/put when its not
21:37:32 <roconnor> I think I have the lastest transformers
21:37:48 <edwardk> you might, but i want to support the old platform entirely if i support it in half ;)
21:38:02 <roconnor> oh, I guess if you care about that sort of thing :D
21:39:14 <sipa> "backward compatibility... oh, you care about users?"
21:43:57 * shapr boings cheerfully
21:45:04 <edwardk> ok, i added all the CPP hacks to support the old mtl/transformers
21:45:48 * hackagebot shelly 0.13.4 - shell-like (systems) programming in Haskell (GregWeber)
21:48:24 <edwardk> now to beat myself against template haskell for a while
22:11:34 <fuchsto> When returning a function of type    fun :: IO ()  , what is the correct return value?  IO ( IO () )  ?
22:11:56 <latro`a> ....?
22:11:57 <dibblego> well, if you are returning IO (), then the correct return type is of course IO ()
22:11:59 <johnw> wouldn't it just be IO ()?
22:11:59 <lambdabot> johnw: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:12:00 <latro`a> I don't understand what you mean
22:12:19 <latro`a> if you're doing some IO to determine what IO to do
22:12:23 <latro`a> then you have an IO (IO ())
22:12:23 <fuchsto> latro`a: I have a function like    fun :: A -> B -> IO ()
22:12:54 <fuchsto> latro`a: And another function currying it with something like     return ( fun a b )
22:13:18 <latro`a> if you use return it's in IO (IO ()), but you may or may not actually want that
22:13:46 <fuchsto> and it's used as:     curriedFun <- newCurriedFun;
22:14:01 <fuchsto> It's similar to an OO factory.
22:23:14 <johnw> latro`a: got your lambabot messages.  thanks!
22:23:36 <Ralith> fuchsto: 'return' in haskell is very different from 'return' in imperative langs.
22:23:40 <latro`a> np :)
22:23:44 <johnw> VERY different
22:24:26 <Ralith> fuchsto: the "return value", or more properly just "value", of a binding should have the type that is declared for that binding.
22:25:48 <Nereid> return does the usual thing in the continuation monad though
22:25:52 <Nereid> !!
22:36:24 <fuchsto> Ralith: I know the former, but don't understand the latter
22:40:05 <fuchsto> Ralith: It's not return as in C (i find the name quite unfortunate), sure. But if   return 4   has type IO Int, then   return ( f :: IO () )  should be   IO ( IO () ), right? I am assuming that f is not executed in this case.
22:40:17 <fuchsto> If f is executed, then the type would be   IO ()
22:41:28 <fuchsto> My intention is something like a constructor (using currying in the factory-like function), so i don't want to execute f, i just want to 'build' it.
22:41:50 <fuchsto> errr, forget about 'constructor', i meant to say 'factory'
22:42:27 <fuchsto> I should visit a functional programming bootcamp to un-brainwash me from OO
22:42:34 <Ralith> fuchsto: types are static, and thus cannot change at runtime.
22:42:55 <Ralith> I encourage you to experiment interatively with ghci using the :t command to figure out what the types of various things are.
22:42:57 <fuchsto> Ralith: Yes, why? I'm not trying to change a type
22:43:05 <fuchsto> Oh, i do, i do a lot
22:43:34 <fuchsto> It's just that i can't decide if using a 'factory function' as i do is a good thing to do.
22:45:16 <fuchsto> it looks like this:    concreteFunA :: A -> B -> IO ()   concreteFunB :: C -> D -> IO ()      factory :: Something -> IO ( IO () ); factory = if cond then   return (concreteFunA a b)   else   return (concreteFunB c d)
22:46:01 <fuchsto> and the use case would be      myFun <- factory something;   anotherFun myFun
22:46:29 <fuchsto> (anotherFun finally calling myFun)
22:48:06 <Ralith> fuchsto: you should try to avoid writing code in IO that doesn't absolutely have to be.
22:49:16 <fuchsto> Ralith: I know, but it's a wrapper for communication with OpenGL, and using IO / IORefs is the best practice here
22:49:55 <fuchsto> Ralith: I would prefer a pure OpenGL binding, too, but the only usable ones are HOpenGL or OpenGLRaw, both very imperative
22:50:34 <Ralith> I don't think a pure OpenGL binding is a thing that would make sense. OpenGL is very stateful.
22:50:46 <Ralith> this is by design.
22:50:53 <fuchsto> Ralith: I spend 95% of my debugging time on non-pure functions. Pure functions tend to be correct if they compile without warnings.
22:51:33 <fuchsto> Ralith: True, but there is a pure wrapper for OpenGL ... i can't remember the package name right now ...
22:51:59 <Ralith> statically-typed functions are relatively likely to be correct if they compile cleanly.
22:52:14 <fuchsto> yep, loving it.
22:52:16 <Ralith> purity is orthogonal.
22:52:23 <nand`> fuchsto: do you mean gloss?
22:52:46 <fuchsto> nand`: gloss, right, i think that's it
22:53:06 <fuchsto> nand`: This pong game you talked about before is using it
22:53:10 <nand`> it's not exactly a pure interface to OpenGL; just a small subset of OpenGL (2d vector graphics)
22:53:37 <fuchsto> nand`: Yes, that's why i'm not using it. But i will write a visual editor using Gtk, and that's where i will use it
22:53:54 <fuchsto> (will ~ intend to)
22:54:16 <fuchsto> Either Gloss or Cairo
22:54:27 <nand`> isn't cairo just for compositing
22:55:01 <mm_freak> note that gloss isn't exactly composable
22:55:09 <mm_freak> i don't think you can combine it with GTK
22:55:16 <fuchsto> nand`: Don't expect a qualified answer from me on cairo, yet, i did not start with the visual editor component, yet.
22:55:22 <fuchsto> what do you mean by composable?
22:55:54 <mm_freak> you can't embed it into a toolkit
22:55:54 <nand`> he means gloss's denominator is the main IO ()
22:56:10 <fuchsto> All i know is that cairo works on SVG, stencil-based
22:56:19 <fuchsto> nand`: Why is that?!
22:56:26 <fuchsto> That's a ... deal breaker.
22:56:35 <mm_freak> fuchsto: gloss has a main loop and you can't write your own
22:56:42 <Ralith> oh man I hate libs like that
22:56:53 <XexonixXexillion> fuchsto: Gloss was originally written for students to use to make nice looking things; it was never designed for production
22:56:55 <fuchsto> But ... why?!   :'(
22:57:05 <mm_freak> gloss is great for very simple applications, but you won't find yourself doing a lot of serious stuff with it
22:57:07 <fuchsto> -sob-
22:57:20 <fuchsto> That's sad. Any chance this will change?
22:57:26 <mm_freak> doubt it
22:57:50 <mm_freak> ease is one of its main objectives
22:57:59 <fuchsto> Would it be *that* hard to make it composable? It doesn't *sound* too complicated.
22:58:32 <fuchsto> Just replace the main loop with a callback fun? No? Damn.
22:58:39 <mm_freak> doubt it‚Ä¶
22:58:48 <Ralith> likely easier said than done.
22:58:53 <mm_freak> also callback fun wouldn't make it better‚Ä¶  it is actually somewhat based on callbacks =)
22:59:01 <fuchsto> Ralith: Most probably :)
22:59:39 <fuchsto> Okay, cairo it is, then
22:59:55 <mm_freak> there are some experimental libraries on hackage, but for production currently your best bet is haskell's OpenGL library (which is already slightly higher level than the OpenGL API itself)
23:00:06 <fuchsto> Thank you, knowing this at least saves me from googling how to write a Gtk widget using Gloss.
23:00:26 <XexonixXexillion> fuchsto: well Ben recently added IO functions (i.e you transition function for the state can be IO) which make it slightly more useful, but it still needs to be the main loop
23:00:29 <mm_freak> if you don't need OpenGL, cairo is probably fine
23:00:40 <fuchsto> mm_freak: HOpenGL you mean? Yes, it's pretty awesome. And there is GtkGLExt for Gtk.
23:00:48 <mm_freak> fuchsto: i mean OpenGL
23:00:52 <fuchsto> (to embed OpenGL in Gtk)
23:00:53 <mm_freak> i have no experience with HOpenGL
23:01:34 <mm_freak> it's really difficult to combine OpenGL, declarative programming and efficiency =)
23:01:58 <fuchsto> mm_freak: All i found was HOpenGL: http://www.haskell.org/haskellwiki/Opengl
23:02:20 <fuchsto> mm_freak: Oh boy, you can say that again.
23:02:40 <mm_freak> @hackage OpenGL
23:02:40 <lambdabot> http://hackage.haskell.org/package/OpenGL
23:03:32 <fuchsto> mm_freak: But some combinations work pretty well. Indexed vertex arrays are efficient. OpenGL works with CArrays in this case (impure) but i generate the indices using pure functions. That's pretty efficient and half-pure.
23:04:25 <Ralith> fuchsto: if all you need is 2D graphics, use cairo.
23:05:12 <nand`> edwardk: I feel like writing an AI that will trace the ball's path forward and position itself correctly in advance
23:05:21 <edwardk> hah
23:05:28 <fuchsto> mm_freak: That's the API for HOpenGL. I think we are talking about the same thing?
23:05:29 <edwardk> i look forward to the patches ;)
23:05:43 <mm_freak> fuchsto: look at gloss anyway‚Ä¶  it's simple and not as efficient as it could be (in terms of drawing speed), but it's declarative
23:06:12 <edwardk> should add inertia to the paddles ;)
23:06:14 <fuchsto> Ralith: For my visual editor, i just need 2D, so i had to decide between Cairo and Gloss
23:06:39 <edwardk> just shift your controls off by a derivative
23:06:41 <mm_freak> even if you use cairo, some higher layer is always useful =)
23:06:47 <fuchsto> edwardk: and aerodynamic drag
23:07:10 <edwardk> well, right now you cant catch the ball after some point
23:07:20 <edwardk> so it'd be nice to be _able_ to if you can guess the right speed
23:08:13 <fuchsto> nand`: That's not exactly AI, is it
23:08:40 * nand` contemplates SimpleIso Vector (Angle, Magnitude)
23:08:49 <nand`> fuchsto: not in the slightest :(
23:09:12 <fuchsto> nand`: But it would be, if it also tries to play the ball in a direction that is probable to lead to a score
23:09:19 <fuchsto> tries/tried
23:09:26 <nand`> fuchsto: no ability to do that right now
23:10:00 <fuchsto> it's just an argmax on the distance between the current position of the players paddle and an edge
23:10:44 <nand`> I could use gloss to draw rounded paddles for that too
23:11:02 <fuchsto> Ah, but then it would always either play the ball to the very upper or very lower end. That's easy to conquer, then.
23:11:53 <fuchsto> nand`: Do you increase the ball's velocity with every bounce? It's not physically correct, but a nice feature for pong
23:12:15 <nand`> fuchsto: I do: ballSpeed.both *= speedIncrease
23:12:32 <fuchsto> nand`: With rounded corners, you can produce very sharp angles, so it can bounce more than twice
23:13:15 <fuchsto> nand`: Great! So if you manage to catch the ball with a paddle's edge (which is risky), you gain an advantage.
23:13:30 <nand`> like I said, no ability to do that right now
23:13:56 <fuchsto> I'm not talking about AI, just about rounded corners
23:13:56 <nand`> in fact, I should probably fix the drawing code so that the paddle's inner edge is aligned with the edge of the playing field, because as far as the game is concerned the paddle has zero width
23:14:06 <nand`> and I'm talking about rounded corners
23:14:10 <fuchsto> ah, got it
23:14:23 <mm_freak> despite my love towards lenses i'm unhappy to see java/c++ code in haskell
23:14:33 <nand`> the code is simple: either it bounces, in which case x speed is inverted, or it doesn't, in which case the enemy gets a point
23:16:04 <caolanm> is there something in the standard prelude that will let me apply a function with a curried argument, eg  apply x f = f x ?
23:16:11 <caolanm> that might be a stupid question :\
23:16:18 <edwardk> :t flip id
23:16:19 <lambdabot> forall a b. a -> (a -> b) -> b
23:16:37 <edwardk> :t flip ($)
23:16:38 <lambdabot> forall a b. a -> (a -> b) -> b
23:16:41 <mm_freak> and i'm not sure i want to support this insanity, so i'll stick with data-lens for now‚Ä¶  the lens library has the potential to lead to a lot of confusion and people trying to write C++ in haskell
23:16:47 <edwardk> might be better to think of it the latter way to get started
23:17:13 <edwardk> mm_freak: The *= combinators are also in data-lens
23:17:22 <mm_freak> edwardk: that's not what i'm talking about
23:17:25 <edwardk> they are just harder to use there ;)
23:17:27 <mm_freak> i'm talking about the abuse of (.)
23:17:43 <mm_freak> also (*=) is in data-lens-fd =)
23:18:07 <edwardk> http://hackage.haskell.org/packages/archive/data-lens/2.10.2/doc/html/Data-Lens-Lazy.html
23:18:19 <edwardk> the data-lens-fd version just lts it work for any monadstate
23:18:29 <edwardk> i wrote both ;)
23:18:42 <mm_freak> oh, indeed
23:18:42 <caolanm> edwardk: flip id made most sense to me
23:18:53 <caolanm> edwardk: thanks, I had forgotten about flip
23:19:48 <caolanm> although, just using a lambda is actually shorter and perhaps more readable
23:19:54 <mm_freak> in any case, please stop abusing (.)‚Ä¶  i won't use a library where i'll have to read compositions in the wrong order
23:20:01 <edwardk> mm_freak: mostly what i'm looking for is a way that you can support a number of combinators like traverseWithKey, etc. in a way that doesn't require a mountain of explicit imports
23:20:08 <mm_freak> if you insist on C++ syntax, at least make another combinator for that
23:20:17 <edwardk> i categorically refuse to stop using .
23:21:49 <mm_freak> don't stop using it, but keep it the way it was in data-lens‚Ä¶  it made sense there
23:22:06 <edwardk> thats like me asking you to type in all your programs while standing on one foot =P
23:22:26 <edwardk> you use . to compose lenses here too. it just happens that traverse and many other things are already lenses
23:22:37 <mm_freak> that's not what i mean
23:22:38 <edwardk> the order gets flipped and in the end that turns out to be a good thing
23:22:46 <mm_freak> x^.f.g.h
23:23:00 <edwardk> is beautiful and ugly at the same time
23:23:05 <mm_freak> instead of:  h . g . f ^$ x
23:23:14 <edwardk> its downright horrifying that it works, but its so nice
23:23:25 <edwardk> also it gives a clean distinction between foo.bar  and foo^.bar
23:23:42 <edwardk> i just wrote a bunch of simpleLenses       = lensFlags.contains SimpleLenses
23:23:56 <edwardk> style combinators and it was wonderful ;)
23:24:10 <mm_freak> what troubles me most (and probably compels you to leave out the spaces) is the reversed composition order
23:24:23 <mm_freak> this is just weird and inconsistent with all the rest of the haskell world
23:24:46 <edwardk> want me to get off your lawn while i'm at it?
23:24:53 <edwardk> =)
23:25:10 <mm_freak> i don't understand that question (not a native english speaker)
23:25:25 <edwardk> http://en.wikipedia.org/wiki/You_kids_get_off_my_lawn!
23:25:56 <Xbilprl> hi
23:26:18 <mm_freak> that page is useless for non-native english speakers =)
23:26:51 <mm_freak> to understand it, i'd have to look up about 20 words in my dictionary, and i really don't feel like doing that now ;)
23:26:55 <edwardk> "get off my lawn!" basically is something usually said by an old man who is yelling at kids who are underfoot doing things he doesn't like ;)
23:27:38 <mm_freak> ok, so the essence is:  i'm just whining like a kid and you don't take me seriously?
23:27:43 <edwardk> no
23:27:46 <edwardk> quite the opposite
23:27:57 <mm_freak> i surely hope so ;)
23:28:03 <edwardk> i'm the upstart kid who is doing something you don't like because its unfamiliar
23:28:18 <mm_freak> exactly the opposite
23:28:28 <davean> You're whining like an old person who hates anything new
23:28:30 <mm_freak> it's familiar, a trauma from C++ times i'
23:28:36 <mm_freak> i'm trying to avoid by using haskell
23:28:40 <edwardk> yes, and i'm trying to fix that trauma ;)
23:28:43 <zhulikas> @type (^.)
23:28:44 <lambdabot> Not in scope: `^.'
23:29:01 <jaredc|2> samples from get off my lawn first paragraph: jocularly sarcastic archetypical obstreperous bourgeoisie
23:29:14 <Cale> I really appreciate the fact that there's a ^ there
23:29:27 <mm_freak> davean: i wouldn't be programming haskell for many years now, which disproves your stupid statement
23:29:29 <edwardk> zhulikas: http://hackage.haskell.org/packages/archive/lens/1.3.1/doc/html/Control-Lens.html#v:-94-.
23:30:06 <edwardk> the ^. started as kind of a lark, but i'm glad, it does indicate something strange is going on
23:30:10 <davean> mm_freak: How does it disprove it?
23:30:40 <edwardk> mm_freak: he was summarizing the 'get off my lawn' comment, which is what i meant when i said that
23:30:58 <zhulikas> not sure why are you writing these lenses
23:31:10 <mm_freak> davean: if edwardk is right about summarizing, then i retract my stupid rant =)
23:31:11 <zhulikas> (proper noob question here)
23:31:33 <edwardk> zhulikas: how big is the api for, say, Data.ByteString?
23:31:40 <edwardk> its massive, right?
23:31:53 <edwardk> its basically everything in Data.List cut and pasted with different types
23:31:54 <edwardk> why?
23:31:56 <zhulikas> quite big
23:32:00 <edwardk> because the type of traversal is slightly different
23:32:17 <edwardk> the form of lenses I'm using permits me to work with bytestrings for traversals just like any other traversable
23:32:28 <edwardk> anyOf words (==0x80)
23:32:43 <edwardk> you wrote _1_ combinator, words, describing the traversal of bytestring
23:33:01 <edwardk> and all the other combinators for foldable and traversable adapt to your container, monomorphic or not
23:33:13 <zhulikas> I see...
23:33:15 <edwardk> and you can compose those things
23:33:25 <zhulikas> ok, that's cool :)
23:33:29 <mm_freak> davean: but to answer your question, i'm very curious about new and experimental stuff‚Ä¶  i just find the choice of (.) for forward composition very unfortunate
23:33:39 <edwardk> anyOf (traverse.words)  -- will walk into a container and traverse the words of the bytestrings it finds there
23:33:50 <latro`a> is there an optimization level such that given a definition of foldl, the compiler can do enough strictness analysis to infer that foldl' is equivalent?
23:33:59 <edwardk> it makes mm_freak uncomfortable because (.) composes in the opposite order he's used to
23:34:24 <mm_freak> well, f . g in haskell means "first g, then f"
23:34:26 <edwardk> :t traverse.map
23:34:27 <lambdabot> Not in scope: `traverse'
23:34:36 <edwardk> :t Data.Traversable.traverse . map
23:34:37 <lambdabot> forall b (t :: * -> *) a. (Data.Traversable.Traversable t) => (a -> b) -> t [a] -> [t b]
23:34:42 <edwardk> it already does that
23:34:49 <edwardk> i didn't do anything to make (.) compose that way
23:34:49 <latro`a> (nothing particularly special about foldl/foldl' in this example, just the most obvious case where there is a lazy function and a strict function with the same semantics)
23:35:12 <edwardk> :t Data.Traversable.traverse . map . map
23:35:13 <lambdabot> forall (t :: * -> *) a b. (Data.Traversable.Traversable t) => (a -> b) -> t [[a]] -> [t [b]]
23:35:17 <mm_freak> it still has that meaning in edwardk's lens library, but the lens representation is such that the effect is reversed‚Ä¶  i think this is achieved by CPS
23:35:20 <edwardk> :t Data.Traversable.traverse . map . map . data.Traversable.traverse
23:35:22 <lambdabot> parse error on input `data'
23:35:26 <edwardk> it is
23:35:46 <davean> mm_freak: I'd not call CPS very 'unusual' at all - infact quite a lot of Haskell code follows that pattern
23:35:57 <hpaste> nand` annotated ‚ÄúFunctional pong with lenses and gloss‚Äù with ‚ÄúFunctional pong with lenses and gloss (better CPU player)‚Äù at http://hpaste.org/72509#a72535
23:36:09 <nand`> edwardk: have fun playing against this one ^
23:36:09 <edwardk> cps'd functions, foldables, traversables, functors -- these are all very powerful things we already know how to use. this just lets you put them together
23:36:21 <nand`> edwardk: also let me know if you can optimize ‚Äòbounce‚Äô from line 63
23:36:40 <mm_freak> davean: i'm the developer of a CPS-based snaplet soon to be released‚Ä¶  try to read my explanation again =)
23:37:52 <edwardk> mm_freak: sadly there isn't a way to make this form of lens compose the other way, even if i wanted it to
23:38:05 <edwardk> mm_freak: and there isn't a way to make the other lens representations this powerful
23:38:28 <edwardk> so i expect you'll be uncomfortable for some time to come ;)
23:39:15 <nand`> bah, it 5-0'd me already
23:39:24 <nand`> I think this particular ‚Äòspeed‚Äô configuration makes it impossible for the player to win
23:39:29 <edwardk> heh, yeah
23:40:02 <mm_freak> edwardk: i see
23:40:04 <edwardk> almost have the new TH generator re-re-redone
23:40:28 <mm_freak> edwardk: it's not that much of a problem, but i'll write the spaces anyway =)
23:40:30 <nand`> edwardk: in bed earlier I was thinking about how I'd actually prefer my Iso lenses to be the ‚Äònormal way round‚Äô
23:40:48 <edwardk> feel free to write spaces. i use their absence to indicate things are lens-related
23:41:01 <nand`> edwardk: since I want to recurse into fields like foo.bar.bat; not foo.from bar.bat
23:41:18 <mm_freak> even though you have a category, perhaps it would make sense to add another operator anyway
23:41:23 <edwardk> "hello"^.mytypewrapper
23:41:36 <mm_freak> that also saves us from having to import Prelude hiding ((.), id) all the time
23:41:49 <edwardk> i don't have to
23:41:53 <edwardk> i compose with Prelude (.)
23:41:56 <edwardk> not Category (.)
23:42:00 <mm_freak> oh
23:42:06 <nand`> van laarhoven lenses
23:42:19 <nand`> also Prelude id is the identity lens
23:42:22 <edwardk> importing Category (.) is useful when you want to compose isomorphisms and get an isomorphism, but otherwise it isn't required
23:42:39 <edwardk> the latter is a pretty rare requirement
23:42:59 <edwardk> i have a .@ operator used to compose indexed traversals as well if you want to compose their indices
23:44:01 <mm_freak> i see‚Ä¶  this is really the weirdest use of (.) i've ever seen, but it's intriguing despite the reversed meaning =)
23:44:04 <edwardk> e.g. traverseWithIndexOf (traverseList .@ traverseList) (\(i,j) a -> Identity (i,j,a)) [[1,2],[3]]
23:44:08 <tgeeky_> i'm a little confused.
23:44:27 <tgeeky_> in one place, i have a ton of strings concatted, with strings like "\n" ++ "\t  x  \t" + ...
23:44:30 <edwardk> the use of (.) here is to compose functions between _objects_ that have the form (a -> f b)
23:44:43 <tgeeky_> and sometimes i see the tabs, and sometimes i see the "\t"s
23:44:45 <edwardk> the different restrictions on f are how you get the powers of the different lens types
23:44:45 <tgeeky_> what's going on?
23:45:26 <edwardk> traversal requires applicative, getter requires it to be Const r but doesn't constrain r,
23:45:39 <nand`> edwardk: where are indexed traversals right now?
23:45:45 <edwardk> folds put a Monoid constraint on the r, Setters require it to be Identity
23:45:51 <edwardk> in my folder unchecked in
23:45:59 <edwardk> been focusing on TH
23:46:04 <edwardk> needed the repo compiling for that
23:46:29 <edwardk> the file for them exists in a quantum superposition of different naming conventions
23:46:41 <edwardk> been trying to find a set of names i like
23:46:48 <latro`a> tgeeky_, it depends on whether you show or putStrLn
23:46:51 <nand`> reuse names from C++
23:47:06 <latro`a> erm, whether you show before or after you putStrLn
23:47:07 <edwardk> perfect =)
23:47:21 <nand`> why haven't we named traverse ‚Äòforeach‚Äô yet?
23:47:22 <latro`a> if you show, you get the string representation of special characters and you add quotation marks
23:47:37 <edwardk> what i'll do is overload < so i can say template <typename ... >
23:47:45 <mm_freak> tgeeky_: note also that print = putStrLn . show
23:47:52 <latro`a> that is important, yeah
23:47:59 <latro`a> and ghci calls print when it tries to show you a value
23:48:00 <tgeeky_> well, I haven't been typing print.
23:48:04 <edwardk> because i can't rename things in base ;)
23:48:14 <edwardk> we have for at least =)
23:48:15 <tgeeky_> I think this is because i have a custom show instance for one num tyme (instance Num Cyclotomic)
23:48:18 <tgeeky_> but not for anything else
23:48:22 <tgeeky_> type*
23:48:22 <nand`> edwardk: doesn't stop you from creating 50 billion aliases in Control.Lens
23:48:25 <edwardk> :t Data.Traversable.for
23:48:26 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Data.Traversable.Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
23:48:29 <edwardk> =)
23:48:44 <edwardk> i'm willing to retire some of them, but i want to find the _right_ names for things
23:48:56 <edwardk> and the nice thing about this library is almost everything is some form of id with newtype noise
23:49:02 <nand`> it took me a while to wrap my head around how all of the ‚Äò...Of‚Äô functions were supposed to be used
23:49:08 <edwardk> =)
23:49:15 <nand`> but now it makes perfect sense
23:49:30 <edwardk> when i got foldMapOf to work the first time is when i realized 'this is going to be awesome' =)
23:49:46 <nand`> eg. sumOf (traverse._1)
23:49:52 <nand`> instead of sum . map fst
23:50:06 <edwardk> *nods*
23:50:07 <tgeeky_> latro`a: so what's the message? don't put use show when you have a value that's showable?
23:50:08 <Enigmagic> looks kinda like boost
23:50:20 <Enigmagic> ._1
23:50:21 <edwardk> Enigmagic: yeah, the _1 and _2 came from scala
23:50:27 <latro`a> the message is "don't show strings", I think
23:50:33 <edwardk> but i've written a lot of boost too
23:50:48 <edwardk> they ruffled a few feathers too
23:50:52 <Enigmagic> edwardk: i think _1 in boost predates scala quite a bit
23:51:00 <latro`a> well, "don't show strings unless you're debugging"
23:51:04 <edwardk> sure, just saying where i reappropriated it
23:51:10 <tgeeky_> latro`a: I am debugging!
23:51:10 <latro`a> it's kinda nice that you can show them in general
23:51:14 <latro`a> oh
23:51:16 <latro`a> um
23:51:25 <latro`a> do you know where you're winding up showing, and where you're winding up not?
23:51:25 <edwardk> i meant the motivation for them in this library, not where they were first used
23:51:29 <latro`a> because that's the difference
23:51:36 <latro`a> > show "\t"
23:51:37 <lambdabot>   "\"\\t\""
23:51:47 <Enigmagic> edwardk: yah i get it. i do sometimes miss the _ from scala. but i don't miss scala :P
23:51:47 <latro`a> unfortunately I can't putStrLn in lambdabot
23:51:52 <latro`a> because it doesn't let you do IO
23:51:56 <edwardk> Enigmagic: heh
23:52:20 <nand`> > text $ show "\t"
23:52:21 <lambdabot>   "\t"
23:52:31 <Cale> > text "\t"
23:52:41 <nand`> > text "a\tb"
23:52:41 <lambdabot>   a        b
23:52:44 <Cale> ^^ interesting response
23:52:46 <latro`a> huh
23:52:57 <nand`> Cale: I think that might be freenode filtering empty messages
23:53:10 <nand`> actually, let me take that back
23:53:12 <latro`a> > text "\n"
23:53:13 <lambdabot>  Terminated
23:53:16 <latro`a> lolwut
23:53:28 <shachaf> > text "em\n/me"
23:53:29 <lambdabot>   em
23:53:29 <lambdabot>  /me
23:53:33 <shachaf> thanksalotambdabot
23:53:48 <latro`a> why is it silent on \t
23:53:50 <shachaf> edwardk: Is it just me or are lenses getting kind of complicated now? :-(
23:53:53 <latro`a> but says "terminated" on \n
23:53:55 <nand`> > text $ repeat '\n'
23:53:57 <edwardk> shachaf: yes
23:53:59 <Cale> > text "\n"
23:54:00 <lambdabot>   mueval: ExitFailure 1
23:54:00 <lambdabot>  mueval: Prelude.undefined
23:54:01 <lambdabot>  Terminated
23:54:04 <nand`> oo..kay
23:54:09 <Cale> curious :)
23:54:24 <edwardk> the isomorphisms and indexed traversals are more or less the top end of what i want
23:54:55 <shachaf> I mean, I know there are benefits and all, but the idea of a composable (getter,setter) was so simple and obviously nice...
23:54:59 <edwardk> i still would like to test a library for monadic lenses, and i'll probably package up partial lenses and embeddings/projections but separately
23:55:17 <Enigmagic> edwardk: and monadic unfolds..
23:55:18 <edwardk> traversals matter to me more than getters
23:55:51 <hpaste> tgeeky pasted ‚Äútabs and stuff‚Äù at http://hpaste.org/72536
23:55:57 <edwardk> unfolding isn't as primitive. there is an unfolded combinator in there, but its boring
23:56:07 <edwardk> just going through the classes people use
23:56:08 <tgeeky_> mm_freak: latro`a : see that hpsate
23:56:20 <Enigmagic> i think i'm the only person that uses unfoldTreeM_BF frequently :P
23:56:23 <shachaf> You should call these microscopes or something at this point.
23:56:31 <nand`> ha
23:56:31 <edwardk> functions, functor, foldable, traversable -- those are the things we let you compose easily
23:56:41 <shachaf> Enigmagic: And Data.Tree, for that matter!
23:56:43 <edwardk> thought about it, the name sucks though =P
23:56:53 <Enigmagic> shachaf: yeah, because it sucks.
23:57:09 <edwardk> considered naming the thing that kind of saws two lenses and puts them together a bifocal lens, then thought better of it =P
23:57:10 <nand`> telescopes
23:57:10 <Enigmagic> the first thing that i do after using unfoldTreeM_BF is turn the Trees into something else ;)
23:57:24 <edwardk> nand`: there is a telescope operator in 'free' ;)
23:57:25 <c_wraith> Binoculars
23:57:31 <shachaf> "telescope" is taken.
23:57:33 <edwardk> for composing lenses into a cofree comonad
23:57:43 <shachaf> I was thinking of the Agda thing.
23:57:50 <edwardk> i went through the entire thesaurus all the names suck =P
23:57:59 <edwardk> yeah
23:58:56 <Nereid> so uh
23:58:56 <edwardk> woot th compiles
23:59:12 <latro`a> how are you seeing the printout
23:59:24 <latro`a> running it in ghci? calling putStrLn in ghci?
23:59:49 <Nereid> nm
